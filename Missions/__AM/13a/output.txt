// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 56442 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 48333 0 9
// PrepareArabian ;
 140: CALL 3503 0 0
// PrepareRussian ;
 144: CALL 2638 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 57589 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6666 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 78390 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 78816 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 79211 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 79480 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 78756 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 79387 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 78816 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 79211 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 79480 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 78600 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 78756 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := false ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13910 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13910 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13910 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13910 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13910 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13910 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13910 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13910 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13910 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13910 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornell
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13910 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13910 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13910 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13910 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13910 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13910 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13910 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20543 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 60
1567: PPUSH
1568: LD_INT 6
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20543 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 3
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 75
1653: PPUSH
1654: LD_INT 6
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
// uc_side := 6 ;
1690: LD_ADDR_OWVAR 20
1694: PUSH
1695: LD_INT 6
1697: ST_TO_ADDR
// uc_nation := 3 ;
1698: LD_ADDR_OWVAR 21
1702: PUSH
1703: LD_INT 3
1705: ST_TO_ADDR
// InitHc ;
1706: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1710: LD_ADDR_EXP 31
1714: PUSH
1715: LD_STRING Gossudarov
1717: PPUSH
1718: CALL_OW 25
1722: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1723: LD_ADDR_EXP 32
1727: PUSH
1728: LD_STRING Kirilenkova
1730: PPUSH
1731: CALL_OW 25
1735: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1736: LD_ADDR_EXP 33
1740: PUSH
1741: LD_STRING Titov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Oblukov
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1762: LD_ADDR_EXP 35
1766: PUSH
1767: LD_STRING Dolgov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1775: LD_ADDR_EXP 36
1779: PUSH
1780: LD_STRING Petrosyan
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1788: LD_ADDR_EXP 37
1792: PUSH
1793: LD_STRING Scholtze
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1801: LD_ADDR_EXP 39
1805: PUSH
1806: LD_STRING Kapitsova
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_EXP 31
1823: PUSH
1824: LD_EXP 32
1828: PUSH
1829: LD_EXP 33
1833: PUSH
1834: LD_EXP 38
1838: PUSH
1839: LD_EXP 35
1843: PUSH
1844: LD_EXP 36
1848: PUSH
1849: LD_EXP 37
1853: PUSH
1854: LD_EXP 39
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 4
1874: PPUSH
1875: LD_INT 8
1877: PPUSH
1878: CALL_OW 380
// un := CreateHuman ;
1882: LD_ADDR_VAR 0 4
1886: PUSH
1887: CALL_OW 44
1891: ST_TO_ADDR
// tmp := tmp ^ un ;
1892: LD_ADDR_VAR 0 2
1896: PUSH
1897: LD_VAR 0 2
1901: PUSH
1902: LD_VAR 0 4
1906: ADD
1907: ST_TO_ADDR
// for i in tmp do
1908: LD_ADDR_VAR 0 3
1912: PUSH
1913: LD_VAR 0 2
1917: PUSH
1918: FOR_IN
1919: IFFALSE 1938
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1921: LD_VAR 0 3
1925: PPUSH
1926: LD_INT 14
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
1936: GO 1918
1938: POP
1939: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1940: LD_VAR 0 2
1944: PPUSH
1945: LD_EXP 3
1949: PPUSH
1950: CALL_OW 250
1954: PPUSH
1955: LD_EXP 3
1959: PPUSH
1960: CALL_OW 251
1964: PPUSH
1965: CALL_OW 111
// end ;
1969: LD_VAR 0 1
1973: RET
// export function PrepareBelkov ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := 4 ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_INT 4
1984: ST_TO_ADDR
// uc_nation := 3 ;
1985: LD_ADDR_OWVAR 21
1989: PUSH
1990: LD_INT 3
1992: ST_TO_ADDR
// InitHc ;
1993: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1997: LD_ADDR_EXP 46
2001: PUSH
2002: LD_STRING Belkov
2004: PPUSH
2005: CALL_OW 25
2009: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2010: LD_EXP 46
2014: PPUSH
2015: LD_INT 14
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: CALL_OW 49
// end ;
2025: LD_VAR 0 1
2029: RET
// export function PrepareGnyevko ; begin
2030: LD_INT 0
2032: PPUSH
// uc_side := 4 ;
2033: LD_ADDR_OWVAR 20
2037: PUSH
2038: LD_INT 4
2040: ST_TO_ADDR
// uc_nation := 3 ;
2041: LD_ADDR_OWVAR 21
2045: PUSH
2046: LD_INT 3
2048: ST_TO_ADDR
// InitHc ;
2049: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2053: LD_ADDR_EXP 47
2057: PUSH
2058: LD_STRING Gnyevko
2060: PPUSH
2061: CALL_OW 25
2065: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2066: LD_EXP 47
2070: PPUSH
2071: LD_INT 14
2073: PPUSH
2074: LD_INT 0
2076: PPUSH
2077: CALL_OW 49
// end ;
2081: LD_VAR 0 1
2085: RET
// export function PrepareBurlak ; var i , tmp ; begin
2086: LD_INT 0
2088: PPUSH
2089: PPUSH
2090: PPUSH
// uc_side := 4 ;
2091: LD_ADDR_OWVAR 20
2095: PUSH
2096: LD_INT 4
2098: ST_TO_ADDR
// uc_nation := 3 ;
2099: LD_ADDR_OWVAR 21
2103: PUSH
2104: LD_INT 3
2106: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2107: LD_INT 35
2109: PPUSH
2110: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2114: LD_INT 92
2116: PUSH
2117: LD_INT 123
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 3
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: PPUSH
2132: CALL_OW 69
2136: NOT
2137: IFFALSE 2107
// InitHc ;
2139: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2143: LD_ADDR_EXP 45
2147: PUSH
2148: LD_STRING Burlak
2150: PPUSH
2151: CALL_OW 25
2155: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2156: LD_INT 24
2158: PUSH
2159: LD_INT 23
2161: PUSH
2162: LD_INT 22
2164: PUSH
2165: EMPTY
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_OWVAR 67
2174: ARRAY
2175: PPUSH
2176: LD_INT 1
2178: PPUSH
2179: LD_INT 1
2181: PPUSH
2182: LD_INT 45
2184: PUSH
2185: LD_INT 44
2187: PUSH
2188: LD_INT 43
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 0
2204: PPUSH
2205: CALL 20543 0 5
// Masha := CreateVehicle ;
2209: LD_ADDR_EXP 48
2213: PUSH
2214: CALL_OW 45
2218: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2219: LD_EXP 48
2223: PUSH
2224: LD_EXP 45
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: PPUSH
2233: LD_INT 499
2235: PPUSH
2236: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2240: LD_EXP 48
2244: PPUSH
2245: LD_INT 3
2247: PPUSH
2248: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2252: LD_EXP 48
2256: PPUSH
2257: LD_INT 1
2259: PPUSH
2260: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2264: LD_EXP 48
2268: PPUSH
2269: LD_INT 18
2271: PPUSH
2272: LD_INT 0
2274: PPUSH
2275: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2279: LD_EXP 45
2283: PPUSH
2284: LD_INT 125
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 0
2292: PPUSH
2293: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2297: LD_EXP 45
2301: PPUSH
2302: LD_EXP 48
2306: PPUSH
2307: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2311: LD_INT 10
2313: PPUSH
2314: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2318: LD_EXP 48
2322: PPUSH
2323: LD_INT 110
2325: PPUSH
2326: LD_INT 10
2328: PPUSH
2329: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2333: LD_ADDR_EXP 41
2337: PUSH
2338: LD_STRING Petrovova
2340: PPUSH
2341: CALL_OW 25
2345: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2346: LD_ADDR_EXP 43
2350: PUSH
2351: LD_STRING Kuzmov
2353: PPUSH
2354: CALL_OW 25
2358: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Kovalyuk
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2372: LD_ADDR_EXP 40
2376: PUSH
2377: LD_STRING Lipshchin
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2385: LD_ADDR_EXP 44
2389: PUSH
2390: LD_STRING Karamazov
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2398: LD_ADDR_VAR 0 3
2402: PUSH
2403: LD_EXP 41
2407: PUSH
2408: LD_EXP 43
2412: PUSH
2413: LD_EXP 42
2417: PUSH
2418: LD_EXP 40
2422: PUSH
2423: LD_EXP 44
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: ST_TO_ADDR
// for i in tmp do
2435: LD_ADDR_VAR 0 2
2439: PUSH
2440: LD_VAR 0 3
2444: PUSH
2445: FOR_IN
2446: IFFALSE 2485
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2448: LD_VAR 0 2
2452: PPUSH
2453: LD_INT 399
2455: PPUSH
2456: LD_INT 799
2458: PPUSH
2459: CALL_OW 12
2463: PPUSH
2464: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2468: LD_VAR 0 2
2472: PPUSH
2473: LD_INT 19
2475: PPUSH
2476: LD_INT 0
2478: PPUSH
2479: CALL_OW 49
// end ;
2483: GO 2445
2485: POP
2486: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2487: LD_VAR 0 3
2491: PPUSH
2492: LD_INT 116
2494: PPUSH
2495: LD_INT 8
2497: PPUSH
2498: CALL_OW 111
// AddComHold ( tmp ) ;
2502: LD_VAR 0 3
2506: PPUSH
2507: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 3
2520: PPUSH
2521: LD_INT 25
2523: PUSH
2524: LD_INT 1
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 72
2535: PUSH
2536: FOR_IN
2537: IFFALSE 2577
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2539: LD_VAR 0 2
2543: PPUSH
2544: LD_INT 20
2546: PPUSH
2547: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2551: LD_VAR 0 2
2555: PPUSH
2556: LD_INT 147
2558: PPUSH
2559: LD_INT 45
2561: PPUSH
2562: CALL_OW 178
// AddComCrawl ( i ) ;
2566: LD_VAR 0 2
2570: PPUSH
2571: CALL_OW 197
// end ;
2575: GO 2536
2577: POP
2578: POP
// repeat wait ( 0 0$1 ) ;
2579: LD_INT 35
2581: PPUSH
2582: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2586: LD_EXP 48
2590: PPUSH
2591: LD_INT 110
2593: PPUSH
2594: LD_INT 10
2596: PPUSH
2597: CALL_OW 307
2601: PUSH
2602: LD_EXP 48
2606: PPUSH
2607: CALL_OW 305
2611: NOT
2612: OR
2613: IFFALSE 2579
// ComStop ( Burlak ) ;
2615: LD_EXP 45
2619: PPUSH
2620: CALL_OW 141
// AddComHold ( Burlak ) ;
2624: LD_EXP 45
2628: PPUSH
2629: CALL_OW 200
// end ; end_of_file
2633: LD_VAR 0 1
2637: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2638: LD_INT 0
2640: PPUSH
2641: PPUSH
2642: PPUSH
2643: PPUSH
// uc_side := 3 ;
2644: LD_ADDR_OWVAR 20
2648: PUSH
2649: LD_INT 3
2651: ST_TO_ADDR
// uc_nation := 3 ;
2652: LD_ADDR_OWVAR 21
2656: PUSH
2657: LD_INT 3
2659: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2660: LD_ADDR_EXP 49
2664: PUSH
2665: LD_INT 47
2667: PPUSH
2668: LD_INT 4
2670: PPUSH
2671: LD_STRING 
2673: PPUSH
2674: LD_INT 7
2676: PUSH
2677: LD_INT 8
2679: PUSH
2680: LD_INT 9
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PUSH
2688: LD_OWVAR 67
2692: ARRAY
2693: PPUSH
2694: LD_INT 10000
2696: PUSH
2697: LD_INT 3000
2699: PUSH
2700: LD_INT 300
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 9
2710: PUSH
2711: LD_INT 5
2713: PUSH
2714: LD_INT 6
2716: PUSH
2717: LD_INT 6
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL 23952 0 6
2730: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2731: LD_ADDR_EXP 58
2735: PUSH
2736: LD_EXP 58
2740: PPUSH
2741: LD_INT 2
2743: PPUSH
2744: LD_EXP 49
2748: PPUSH
2749: CALL_OW 1
2753: ST_TO_ADDR
// tmp := [ ] ;
2754: LD_ADDR_VAR 0 4
2758: PUSH
2759: EMPTY
2760: ST_TO_ADDR
// for i = 1 to 4 do
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: DOUBLE
2767: LD_INT 1
2769: DEC
2770: ST_TO_ADDR
2771: LD_INT 4
2773: PUSH
2774: FOR_TO
2775: IFFALSE 2868
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2777: LD_INT 22
2779: PPUSH
2780: LD_INT 3
2782: PPUSH
2783: LD_INT 3
2785: PPUSH
2786: LD_INT 43
2788: PUSH
2789: LD_INT 45
2791: PUSH
2792: LD_INT 45
2794: PUSH
2795: LD_INT 44
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: PUSH
2804: LD_VAR 0 2
2808: PUSH
2809: LD_INT 4
2811: MOD
2812: PUSH
2813: LD_INT 1
2815: PLUS
2816: ARRAY
2817: PPUSH
2818: LD_INT 100
2820: PPUSH
2821: CALL 20543 0 5
// veh := CreateVehicle ;
2825: LD_ADDR_VAR 0 3
2829: PUSH
2830: CALL_OW 45
2834: ST_TO_ADDR
// tmp := tmp ^ veh ;
2835: LD_ADDR_VAR 0 4
2839: PUSH
2840: LD_VAR 0 4
2844: PUSH
2845: LD_VAR 0 3
2849: ADD
2850: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2851: LD_VAR 0 3
2855: PPUSH
2856: LD_INT 2
2858: PPUSH
2859: LD_INT 0
2861: PPUSH
2862: CALL_OW 49
// end ;
2866: GO 2774
2868: POP
2869: POP
// russian_guard := tmp ;
2870: LD_ADDR_EXP 50
2874: PUSH
2875: LD_VAR 0 4
2879: ST_TO_ADDR
// end ;
2880: LD_VAR 0 1
2884: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2885: LD_INT 47
2887: PPUSH
2888: CALL_OW 302
2892: PUSH
2893: LD_EXP 6
2897: AND
2898: IFFALSE 3500
2900: GO 2902
2902: DISABLE
2903: LD_INT 0
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
// begin enable ;
2911: ENABLE
// base := 2 ;
2912: LD_ADDR_VAR 0 2
2916: PUSH
2917: LD_INT 2
2919: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2920: LD_ADDR_VAR 0 4
2924: PUSH
2925: LD_INT 0
2927: PUSH
2928: LD_INT 0
2930: PUSH
2931: LD_INT 0
2933: PUSH
2934: LD_INT 0
2936: PUSH
2937: LD_INT 0
2939: PUSH
2940: LD_INT 0
2942: PUSH
2943: LD_INT 0
2945: PUSH
2946: LD_INT 0
2948: PUSH
2949: LD_INT 1
2951: PUSH
2952: LD_INT 0
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2967: LD_ADDR_VAR 0 3
2971: PUSH
2972: LD_INT 22
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 3
2980: PUSH
2981: LD_INT 45
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_INT 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: LD_INT 45
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 22
3010: PUSH
3011: LD_INT 1
3013: PUSH
3014: LD_INT 3
3016: PUSH
3017: LD_INT 45
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: PUSH
3026: LD_INT 23
3028: PUSH
3029: LD_INT 1
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: LD_INT 46
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: LIST
3049: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3050: LD_ADDR_VAR 0 1
3054: PUSH
3055: DOUBLE
3056: LD_INT 1
3058: DEC
3059: ST_TO_ADDR
3060: LD_OWVAR 67
3064: PUSH
3065: LD_OWVAR 1
3069: PUSH
3070: LD_INT 21000
3072: DIV
3073: PLUS
3074: PUSH
3075: FOR_TO
3076: IFFALSE 3164
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3078: LD_ADDR_VAR 0 3
3082: PUSH
3083: LD_VAR 0 3
3087: PPUSH
3088: LD_VAR 0 3
3092: PUSH
3093: LD_INT 1
3095: PLUS
3096: PPUSH
3097: LD_INT 23
3099: PUSH
3100: LD_INT 24
3102: PUSH
3103: EMPTY
3104: LIST
3105: LIST
3106: PUSH
3107: LD_INT 1
3109: PPUSH
3110: LD_INT 2
3112: PPUSH
3113: CALL_OW 12
3117: ARRAY
3118: PUSH
3119: LD_INT 1
3121: PUSH
3122: LD_INT 3
3124: PUSH
3125: LD_INT 46
3127: PUSH
3128: LD_INT 47
3130: PUSH
3131: LD_INT 45
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: LIST
3138: PUSH
3139: LD_INT 1
3141: PPUSH
3142: LD_INT 3
3144: PPUSH
3145: CALL_OW 12
3149: ARRAY
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: PPUSH
3157: CALL_OW 2
3161: ST_TO_ADDR
3162: GO 3075
3164: POP
3165: POP
// MC_InsertProduceList ( base , tmp ) ;
3166: LD_VAR 0 2
3170: PPUSH
3171: LD_VAR 0 3
3175: PPUSH
3176: CALL 78756 0 2
// repeat wait ( 0 0$1 ) ;
3180: LD_INT 35
3182: PPUSH
3183: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3187: LD_EXP 77
3191: PUSH
3192: LD_VAR 0 2
3196: ARRAY
3197: PUSH
3198: LD_INT 6
3200: GREATER
3201: IFFALSE 3180
// wait ( 0 0$20 ) ;
3203: LD_INT 700
3205: PPUSH
3206: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3210: LD_ADDR_VAR 0 5
3214: PUSH
3215: LD_INT 71
3217: PUSH
3218: LD_INT 19
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: LD_INT 91
3227: PUSH
3228: LD_INT 67
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 52
3237: PUSH
3238: LD_INT 44
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 68
3247: PUSH
3248: LD_INT 48
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3261: LD_ADDR_VAR 0 6
3265: PUSH
3266: LD_EXP 77
3270: PUSH
3271: LD_VAR 0 2
3275: ARRAY
3276: PUSH
3277: LD_EXP 77
3281: PUSH
3282: LD_VAR 0 2
3286: ARRAY
3287: PPUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 34
3293: PUSH
3294: LD_INT 51
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 34
3303: PUSH
3304: LD_INT 52
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: PPUSH
3316: CALL_OW 72
3320: DIFF
3321: ST_TO_ADDR
// if not attackers then
3322: LD_VAR 0 6
3326: NOT
3327: IFFALSE 3331
// exit ;
3329: GO 3500
// ru_attackers := attackers ;
3331: LD_ADDR_EXP 51
3335: PUSH
3336: LD_VAR 0 6
3340: ST_TO_ADDR
// for i = 1 to attackers do
3341: LD_ADDR_VAR 0 1
3345: PUSH
3346: DOUBLE
3347: LD_INT 1
3349: DEC
3350: ST_TO_ADDR
3351: LD_VAR 0 6
3355: PUSH
3356: FOR_TO
3357: IFFALSE 3434
// begin case i mod 3 of 0 :
3359: LD_VAR 0 1
3363: PUSH
3364: LD_INT 3
3366: MOD
3367: PUSH
3368: LD_INT 0
3370: DOUBLE
3371: EQUAL
3372: IFTRUE 3376
3374: GO 3379
3376: POP
// ; 1 :
3377: GO 3432
3379: LD_INT 1
3381: DOUBLE
3382: EQUAL
3383: IFTRUE 3387
3385: GO 3405
3387: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3388: LD_VAR 0 1
3392: PPUSH
3393: LD_INT 32
3395: PPUSH
3396: LD_INT 49
3398: PPUSH
3399: CALL_OW 114
3403: GO 3432
3405: LD_INT 2
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 117
3421: PPUSH
3422: LD_INT 107
3424: PPUSH
3425: CALL_OW 114
3429: GO 3432
3431: POP
// end ;
3432: GO 3356
3434: POP
3435: POP
// repeat wait ( 0 0$1 ) ;
3436: LD_INT 35
3438: PPUSH
3439: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3443: LD_VAR 0 6
3447: PPUSH
3448: LD_INT 60
3450: PUSH
3451: EMPTY
3452: LIST
3453: PPUSH
3454: CALL_OW 72
3458: NOT
3459: IFFALSE 3436
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3461: LD_VAR 0 2
3465: PPUSH
3466: LD_VAR 0 6
3470: PPUSH
3471: LD_VAR 0 5
3475: PPUSH
3476: LD_VAR 0 4
3480: PPUSH
3481: CALL 78941 0 4
// if not first_attack then
3485: LD_EXP 7
3489: NOT
3490: IFFALSE 3500
// first_attack := true ;
3492: LD_ADDR_EXP 7
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// end ; end_of_file
3500: PPOPN 6
3502: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3503: LD_INT 0
3505: PPUSH
3506: PPUSH
3507: PPUSH
3508: PPUSH
3509: PPUSH
3510: PPUSH
3511: PPUSH
// uc_side := 2 ;
3512: LD_ADDR_OWVAR 20
3516: PUSH
3517: LD_INT 2
3519: ST_TO_ADDR
// uc_nation := 2 ;
3520: LD_ADDR_OWVAR 21
3524: PUSH
3525: LD_INT 2
3527: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3528: LD_ADDR_EXP 54
3532: PUSH
3533: LD_STRING Abdul
3535: PPUSH
3536: CALL_OW 25
3540: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3541: LD_EXP 54
3545: PPUSH
3546: LD_INT 11
3548: PPUSH
3549: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3553: LD_EXP 54
3557: PPUSH
3558: LD_INT 1
3560: PPUSH
3561: CALL_OW 52
// vc_chassis := 31 ;
3565: LD_ADDR_OWVAR 37
3569: PUSH
3570: LD_INT 31
3572: ST_TO_ADDR
// vc_control := control_rider ;
3573: LD_ADDR_OWVAR 38
3577: PUSH
3578: LD_INT 4
3580: ST_TO_ADDR
// mastodont := CreateVehicle ;
3581: LD_ADDR_EXP 55
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3591: LD_EXP 55
3595: PPUSH
3596: LD_INT 153
3598: PPUSH
3599: LD_INT 71
3601: PPUSH
3602: LD_INT 0
3604: PPUSH
3605: CALL_OW 48
// InitVc ;
3609: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3613: LD_ADDR_EXP 52
3617: PUSH
3618: LD_INT 1
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_STRING 
3626: PPUSH
3627: LD_INT 7
3629: PUSH
3630: LD_INT 8
3632: PUSH
3633: LD_INT 9
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: LIST
3640: PUSH
3641: LD_OWVAR 67
3645: ARRAY
3646: PPUSH
3647: LD_INT 5000
3649: PUSH
3650: LD_INT 1000
3652: PUSH
3653: LD_INT 300
3655: PUSH
3656: EMPTY
3657: LIST
3658: LIST
3659: LIST
3660: PPUSH
3661: LD_INT 22
3663: PUSH
3664: LD_INT 5
3666: PUSH
3667: LD_INT 6
3669: PUSH
3670: LD_INT 9
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: LIST
3677: LIST
3678: PPUSH
3679: CALL 23952 0 6
3683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3684: LD_ADDR_EXP 58
3688: PUSH
3689: LD_EXP 58
3693: PPUSH
3694: LD_INT 1
3696: PPUSH
3697: LD_EXP 52
3701: PPUSH
3702: CALL_OW 1
3706: ST_TO_ADDR
// tmp := [ ] ;
3707: LD_ADDR_VAR 0 4
3711: PUSH
3712: EMPTY
3713: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3714: LD_ADDR_OWVAR 37
3718: PUSH
3719: LD_INT 14
3721: ST_TO_ADDR
// vc_engine := engine_siberite ;
3722: LD_ADDR_OWVAR 39
3726: PUSH
3727: LD_INT 3
3729: ST_TO_ADDR
// vc_control := control_manual ;
3730: LD_ADDR_OWVAR 38
3734: PUSH
3735: LD_INT 1
3737: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3738: LD_ADDR_OWVAR 40
3742: PUSH
3743: LD_INT 31
3745: ST_TO_ADDR
// for i = 1 to 3 do
3746: LD_ADDR_VAR 0 2
3750: PUSH
3751: DOUBLE
3752: LD_INT 1
3754: DEC
3755: ST_TO_ADDR
3756: LD_INT 3
3758: PUSH
3759: FOR_TO
3760: IFFALSE 4004
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_INT 153
3769: PUSH
3770: LD_INT 71
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 155
3779: PUSH
3780: LD_INT 81
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 2
3798: MOD
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: ARRAY
3804: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3805: LD_INT 0
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_INT 7
3813: PUSH
3814: LD_INT 8
3816: PUSH
3817: LD_INT 9
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_OWVAR 67
3829: ARRAY
3830: PPUSH
3831: CALL_OW 380
// un := CreateVehicle ;
3835: LD_ADDR_VAR 0 6
3839: PUSH
3840: CALL_OW 45
3844: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3845: LD_VAR 0 6
3849: PPUSH
3850: LD_INT 0
3852: PPUSH
3853: LD_INT 5
3855: PPUSH
3856: CALL_OW 12
3860: PPUSH
3861: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_VAR 0 5
3874: PUSH
3875: LD_INT 1
3877: ARRAY
3878: PPUSH
3879: LD_VAR 0 5
3883: PUSH
3884: LD_INT 2
3886: ARRAY
3887: PPUSH
3888: LD_INT 6
3890: PPUSH
3891: LD_INT 0
3893: PPUSH
3894: CALL_OW 50
// un2 := CreateHuman ;
3898: LD_ADDR_VAR 0 7
3902: PUSH
3903: CALL_OW 44
3907: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3908: LD_VAR 0 7
3912: PPUSH
3913: LD_VAR 0 6
3917: PPUSH
3918: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3922: LD_ADDR_EXP 58
3926: PUSH
3927: LD_EXP 58
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_EXP 58
3939: PUSH
3940: LD_INT 1
3942: ARRAY
3943: PUSH
3944: LD_INT 1
3946: PLUS
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PPUSH
3952: LD_VAR 0 6
3956: PPUSH
3957: CALL 20665 0 3
3961: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3962: LD_ADDR_EXP 58
3966: PUSH
3967: LD_EXP 58
3971: PPUSH
3972: LD_INT 1
3974: PUSH
3975: LD_EXP 58
3979: PUSH
3980: LD_INT 1
3982: ARRAY
3983: PUSH
3984: LD_INT 1
3986: PLUS
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PPUSH
3992: LD_VAR 0 7
3996: PPUSH
3997: CALL 20665 0 3
4001: ST_TO_ADDR
// end ;
4002: GO 3759
4004: POP
4005: POP
// for i = 1 to 5 do
4006: LD_ADDR_VAR 0 2
4010: PUSH
4011: DOUBLE
4012: LD_INT 1
4014: DEC
4015: ST_TO_ADDR
4016: LD_INT 5
4018: PUSH
4019: FOR_TO
4020: IFFALSE 4113
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4022: LD_INT 14
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 25
4033: PUSH
4034: LD_INT 28
4036: PUSH
4037: LD_INT 28
4039: PUSH
4040: LD_INT 26
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: LIST
4047: LIST
4048: PUSH
4049: LD_VAR 0 2
4053: PUSH
4054: LD_INT 4
4056: MOD
4057: PUSH
4058: LD_INT 1
4060: PLUS
4061: ARRAY
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 20543 0 5
// veh := CreateVehicle ;
4070: LD_ADDR_VAR 0 3
4074: PUSH
4075: CALL_OW 45
4079: ST_TO_ADDR
// tmp := tmp ^ veh ;
4080: LD_ADDR_VAR 0 4
4084: PUSH
4085: LD_VAR 0 4
4089: PUSH
4090: LD_VAR 0 3
4094: ADD
4095: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4096: LD_VAR 0 3
4100: PPUSH
4101: LD_INT 1
4103: PPUSH
4104: LD_INT 0
4106: PPUSH
4107: CALL_OW 49
// end ;
4111: GO 4019
4113: POP
4114: POP
// arabian_guard := tmp ;
4115: LD_ADDR_EXP 53
4119: PUSH
4120: LD_VAR 0 4
4124: ST_TO_ADDR
// end ;
4125: LD_VAR 0 1
4129: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4130: LD_INT 22
4132: PUSH
4133: LD_INT 7
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 91
4142: PUSH
4143: LD_INT 1
4145: PUSH
4146: LD_INT 12
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: PPUSH
4158: CALL_OW 69
4162: PUSH
4163: LD_EXP 55
4167: PPUSH
4168: CALL_OW 256
4172: PUSH
4173: LD_INT 990
4175: LESS
4176: OR
4177: PUSH
4178: LD_EXP 54
4182: PPUSH
4183: CALL_OW 256
4187: PUSH
4188: LD_INT 990
4190: LESS
4191: OR
4192: IFFALSE 4335
4194: GO 4196
4196: DISABLE
// begin if IsInUnit ( Abdul ) then
4197: LD_EXP 54
4201: PPUSH
4202: CALL_OW 310
4206: IFFALSE 4217
// ComExitBuilding ( Abdul ) ;
4208: LD_EXP 54
4212: PPUSH
4213: CALL_OW 122
// if Mastodont then
4217: LD_EXP 55
4221: IFFALSE 4238
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4223: LD_EXP 55
4227: PPUSH
4228: LD_INT 205
4230: PPUSH
4231: LD_INT 132
4233: PPUSH
4234: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4238: LD_EXP 54
4242: PPUSH
4243: LD_INT 205
4245: PPUSH
4246: LD_INT 132
4248: PPUSH
4249: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4260: LD_EXP 54
4264: PPUSH
4265: LD_INT 21
4267: PPUSH
4268: CALL_OW 308
4272: IFFALSE 4253
// RemoveUnit ( Abdul ) ;
4274: LD_EXP 54
4278: PPUSH
4279: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4283: LD_INT 35
4285: PPUSH
4286: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4290: LD_EXP 55
4294: PPUSH
4295: LD_INT 21
4297: PPUSH
4298: CALL_OW 308
4302: PUSH
4303: LD_EXP 55
4307: PPUSH
4308: CALL_OW 301
4312: OR
4313: IFFALSE 4283
// if IsOk ( Mastodont ) then
4315: LD_EXP 55
4319: PPUSH
4320: CALL_OW 302
4324: IFFALSE 4335
// RemoveUnit ( Mastodont ) ;
4326: LD_EXP 55
4330: PPUSH
4331: CALL_OW 64
// end ;
4335: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4336: LD_EXP 54
4340: PPUSH
4341: CALL_OW 301
4345: PUSH
4346: LD_INT 22
4348: PUSH
4349: LD_INT 2
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: LD_INT 25
4361: PUSH
4362: LD_INT 1
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: LD_INT 25
4371: PUSH
4372: LD_INT 2
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 25
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 25
4391: PUSH
4392: LD_INT 4
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: PUSH
4399: LD_INT 25
4401: PUSH
4402: LD_INT 8
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: CALL_OW 69
4425: PUSH
4426: LD_INT 16
4428: PUSH
4429: LD_INT 19
4431: PUSH
4432: LD_INT 22
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_OWVAR 67
4444: ARRAY
4445: LESS
4446: OR
4447: IFFALSE 5120
4449: GO 4451
4451: DISABLE
4452: LD_INT 0
4454: PPUSH
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
4459: PPUSH
// begin MC_Kill ( 1 ) ;
4460: LD_INT 1
4462: PPUSH
4463: CALL 56677 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: LD_INT 22
4474: PUSH
4475: LD_INT 2
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 1
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: LD_INT 25
4497: PUSH
4498: LD_INT 2
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 25
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 25
4517: PUSH
4518: LD_INT 4
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: LD_INT 25
4527: PUSH
4528: LD_INT 8
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PPUSH
4547: CALL_OW 69
4551: ST_TO_ADDR
// for i in tmp do
4552: LD_ADDR_VAR 0 5
4556: PUSH
4557: LD_VAR 0 2
4561: PUSH
4562: FOR_IN
4563: IFFALSE 4579
// SetTag ( i , 10 ) ;
4565: LD_VAR 0 5
4569: PPUSH
4570: LD_INT 10
4572: PPUSH
4573: CALL_OW 109
4577: GO 4562
4579: POP
4580: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4581: LD_ADDR_VAR 0 3
4585: PUSH
4586: LD_INT 22
4588: PUSH
4589: LD_INT 2
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: LD_INT 21
4598: PUSH
4599: LD_INT 1
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: PUSH
4606: EMPTY
4607: LIST
4608: LIST
4609: PPUSH
4610: CALL_OW 69
4614: PUSH
4615: LD_VAR 0 2
4619: DIFF
4620: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4621: LD_ADDR_VAR 0 1
4625: PUSH
4626: LD_INT 22
4628: PUSH
4629: LD_INT 2
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: LD_INT 21
4638: PUSH
4639: LD_INT 2
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 24
4648: PUSH
4649: LD_INT 300
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: LIST
4660: PPUSH
4661: CALL_OW 69
4665: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4666: LD_ADDR_VAR 0 4
4670: PUSH
4671: LD_VAR 0 1
4675: PPUSH
4676: LD_INT 33
4678: PUSH
4679: LD_INT 1
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 58
4688: PUSH
4689: EMPTY
4690: LIST
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PPUSH
4696: CALL_OW 72
4700: ST_TO_ADDR
// for i in tmp do
4701: LD_ADDR_VAR 0 5
4705: PUSH
4706: LD_VAR 0 2
4710: PUSH
4711: FOR_IN
4712: IFFALSE 4896
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4714: LD_VAR 0 5
4718: PUSH
4719: LD_INT 55
4721: PUSH
4722: EMPTY
4723: LIST
4724: PPUSH
4725: CALL_OW 69
4729: IN
4730: IFFALSE 4749
// begin AddComMoveXY ( i , 209 , 132 ) ;
4732: LD_VAR 0 5
4736: PPUSH
4737: LD_INT 209
4739: PPUSH
4740: LD_INT 132
4742: PPUSH
4743: CALL_OW 171
// continue ;
4747: GO 4711
// end ; if IsInUnit ( i ) then
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 310
4758: IFFALSE 4776
// begin ComExitBuilding ( i ) ;
4760: LD_VAR 0 5
4764: PPUSH
4765: CALL_OW 122
// wait ( 3 ) ;
4769: LD_INT 3
4771: PPUSH
4772: CALL_OW 67
// end ; if tmp_empty then
4776: LD_VAR 0 4
4780: IFFALSE 4879
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4782: LD_VAR 0 5
4786: PPUSH
4787: LD_VAR 0 4
4791: PPUSH
4792: LD_VAR 0 5
4796: PPUSH
4797: CALL_OW 74
4801: PPUSH
4802: CALL_OW 296
4806: PUSH
4807: LD_INT 25
4809: LESS
4810: IFFALSE 4879
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4812: LD_ADDR_VAR 0 6
4816: PUSH
4817: LD_VAR 0 4
4821: PPUSH
4822: LD_VAR 0 5
4826: PPUSH
4827: CALL_OW 74
4831: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4832: LD_VAR 0 5
4836: PPUSH
4837: LD_VAR 0 6
4841: PPUSH
4842: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4846: LD_VAR 0 5
4850: PPUSH
4851: LD_INT 209
4853: PPUSH
4854: LD_INT 132
4856: PPUSH
4857: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4861: LD_ADDR_VAR 0 4
4865: PUSH
4866: LD_VAR 0 4
4870: PUSH
4871: LD_VAR 0 6
4875: DIFF
4876: ST_TO_ADDR
// continue ;
4877: GO 4711
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4879: LD_VAR 0 5
4883: PPUSH
4884: LD_INT 201
4886: PPUSH
4887: LD_INT 132
4889: PPUSH
4890: CALL_OW 171
// end ;
4894: GO 4711
4896: POP
4897: POP
// for i in tmp_ape do
4898: LD_ADDR_VAR 0 5
4902: PUSH
4903: LD_VAR 0 3
4907: PUSH
4908: FOR_IN
4909: IFFALSE 4948
// begin if IsInUnit ( i ) then
4911: LD_VAR 0 5
4915: PPUSH
4916: CALL_OW 310
4920: IFFALSE 4931
// ComExitBuilding ( i ) ;
4922: LD_VAR 0 5
4926: PPUSH
4927: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_INT 201
4938: PPUSH
4939: LD_INT 132
4941: PPUSH
4942: CALL_OW 171
// end ;
4946: GO 4908
4948: POP
4949: POP
// repeat wait ( 0 0$1 ) ;
4950: LD_INT 35
4952: PPUSH
4953: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4957: LD_ADDR_VAR 0 5
4961: PUSH
4962: LD_VAR 0 2
4966: PUSH
4967: LD_VAR 0 3
4971: UNION
4972: PUSH
4973: LD_VAR 0 1
4977: UNION
4978: PUSH
4979: FOR_IN
4980: IFFALSE 5011
// if not HasTask ( i ) then
4982: LD_VAR 0 5
4986: PPUSH
4987: CALL_OW 314
4991: NOT
4992: IFFALSE 5009
// ComMoveXY ( i , 201 , 132 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 201
5001: PPUSH
5002: LD_INT 132
5004: PPUSH
5005: CALL_OW 111
5009: GO 4979
5011: POP
5012: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5013: LD_INT 21
5015: PPUSH
5016: LD_INT 22
5018: PUSH
5019: LD_INT 2
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL_OW 70
5030: IFFALSE 5071
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5032: LD_ADDR_VAR 0 5
5036: PUSH
5037: LD_INT 21
5039: PPUSH
5040: LD_INT 22
5042: PUSH
5043: LD_INT 2
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: PPUSH
5050: CALL_OW 70
5054: PUSH
5055: FOR_IN
5056: IFFALSE 5069
// RemoveUnit ( i ) ;
5058: LD_VAR 0 5
5062: PPUSH
5063: CALL_OW 64
5067: GO 5055
5069: POP
5070: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5071: LD_INT 22
5073: PUSH
5074: LD_INT 2
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PUSH
5081: LD_INT 2
5083: PUSH
5084: LD_INT 21
5086: PUSH
5087: LD_INT 1
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 21
5096: PUSH
5097: LD_INT 2
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PPUSH
5113: CALL_OW 69
5117: NOT
5118: IFFALSE 4950
// end ;
5120: PPOPN 6
5122: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5123: LD_EXP 9
5127: PUSH
5128: LD_INT 92
5130: PPUSH
5131: LD_INT 40
5133: PPUSH
5134: CALL_OW 428
5138: PPUSH
5139: CALL_OW 266
5143: PUSH
5144: LD_INT 30
5146: EQUAL
5147: AND
5148: IFFALSE 5344
5150: GO 5152
5152: DISABLE
5153: LD_INT 0
5155: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_EXP 58
5165: PUSH
5166: LD_INT 1
5168: ARRAY
5169: PPUSH
5170: LD_INT 25
5172: PUSH
5173: LD_INT 4
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 72
5184: ST_TO_ADDR
// if not sci then
5185: LD_VAR 0 1
5189: NOT
5190: IFFALSE 5194
// exit ;
5192: GO 5344
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5194: LD_ADDR_EXP 58
5198: PUSH
5199: LD_EXP 58
5203: PPUSH
5204: LD_INT 1
5206: PPUSH
5207: LD_EXP 58
5211: PUSH
5212: LD_INT 1
5214: ARRAY
5215: PUSH
5216: LD_VAR 0 1
5220: PUSH
5221: LD_INT 1
5223: ARRAY
5224: DIFF
5225: PPUSH
5226: CALL_OW 1
5230: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5231: LD_VAR 0 1
5235: PUSH
5236: LD_INT 1
5238: ARRAY
5239: PPUSH
5240: CALL_OW 310
5244: IFFALSE 5259
// ComExitBuilding ( sci [ 1 ] ) ;
5246: LD_VAR 0 1
5250: PUSH
5251: LD_INT 1
5253: ARRAY
5254: PPUSH
5255: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5259: LD_INT 2
5261: PPUSH
5262: LD_INT 105
5264: PPUSH
5265: LD_INT 14
5267: PPUSH
5268: LD_INT 20
5270: PPUSH
5271: CALL 21561 0 4
5275: PUSH
5276: LD_INT 4
5278: ARRAY
5279: PUSH
5280: LD_INT 10
5282: LESS
5283: IFFALSE 5306
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5285: LD_VAR 0 1
5289: PUSH
5290: LD_INT 1
5292: ARRAY
5293: PPUSH
5294: LD_INT 105
5296: PPUSH
5297: LD_INT 14
5299: PPUSH
5300: CALL_OW 171
5304: GO 5325
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5306: LD_VAR 0 1
5310: PUSH
5311: LD_INT 1
5313: ARRAY
5314: PPUSH
5315: LD_INT 118
5317: PPUSH
5318: LD_INT 77
5320: PPUSH
5321: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5325: LD_VAR 0 1
5329: PUSH
5330: LD_INT 1
5332: ARRAY
5333: PPUSH
5334: LD_INT 92
5336: PPUSH
5337: LD_INT 40
5339: PPUSH
5340: CALL_OW 218
// end ;
5344: PPOPN 1
5346: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5347: LD_INT 1
5349: PPUSH
5350: CALL_OW 302
5354: PUSH
5355: LD_EXP 9
5359: AND
5360: IFFALSE 5819
5362: GO 5364
5364: DISABLE
5365: LD_INT 0
5367: PPUSH
5368: PPUSH
5369: PPUSH
5370: PPUSH
5371: PPUSH
5372: PPUSH
// begin enable ;
5373: ENABLE
// base := 1 ;
5374: LD_ADDR_VAR 0 2
5378: PUSH
5379: LD_INT 1
5381: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5382: LD_ADDR_VAR 0 4
5386: PUSH
5387: LD_INT 0
5389: PUSH
5390: LD_INT 0
5392: PUSH
5393: LD_INT 0
5395: PUSH
5396: LD_INT 0
5398: PUSH
5399: LD_INT 0
5401: PUSH
5402: LD_INT 0
5404: PUSH
5405: LD_INT 0
5407: PUSH
5408: LD_INT 0
5410: PUSH
5411: LD_INT 1
5413: PUSH
5414: LD_INT 0
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: LD_INT 14
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 2
5442: PUSH
5443: LD_INT 26
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: PUSH
5452: LD_INT 14
5454: PUSH
5455: LD_INT 1
5457: PUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 28
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 13
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: LD_INT 2
5478: PUSH
5479: LD_INT 29
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5493: LD_ADDR_VAR 0 1
5497: PUSH
5498: DOUBLE
5499: LD_INT 1
5501: DEC
5502: ST_TO_ADDR
5503: LD_OWVAR 67
5507: PUSH
5508: LD_OWVAR 1
5512: PUSH
5513: LD_INT 21000
5515: DIV
5516: PLUS
5517: PUSH
5518: FOR_TO
5519: IFFALSE 5611
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5521: LD_ADDR_VAR 0 3
5525: PUSH
5526: LD_VAR 0 3
5530: PPUSH
5531: LD_VAR 0 3
5535: PUSH
5536: LD_INT 1
5538: PLUS
5539: PPUSH
5540: LD_INT 13
5542: PUSH
5543: LD_INT 14
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 1
5552: PPUSH
5553: LD_INT 2
5555: PPUSH
5556: CALL_OW 12
5560: ARRAY
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 2
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: LD_INT 29
5573: PUSH
5574: LD_INT 25
5576: PUSH
5577: LD_INT 26
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 1
5588: PPUSH
5589: LD_INT 4
5591: PPUSH
5592: CALL_OW 12
5596: ARRAY
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PPUSH
5604: CALL_OW 2
5608: ST_TO_ADDR
5609: GO 5518
5611: POP
5612: POP
// MC_InsertProduceList ( base , tmp ) ;
5613: LD_VAR 0 2
5617: PPUSH
5618: LD_VAR 0 3
5622: PPUSH
5623: CALL 78756 0 2
// repeat wait ( 0 0$1 ) ;
5627: LD_INT 35
5629: PPUSH
5630: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5634: LD_EXP 77
5638: PUSH
5639: LD_VAR 0 2
5643: ARRAY
5644: PUSH
5645: LD_INT 6
5647: GREATER
5648: IFFALSE 5627
// wait ( 0 0$20 ) ;
5650: LD_INT 700
5652: PPUSH
5653: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5657: LD_ADDR_VAR 0 5
5661: PUSH
5662: LD_INT 124
5664: PUSH
5665: LD_INT 85
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: LD_INT 90
5674: PUSH
5675: LD_INT 61
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 69
5684: PUSH
5685: LD_INT 48
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 68
5694: PUSH
5695: LD_INT 48
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5708: LD_ADDR_VAR 0 6
5712: PUSH
5713: LD_EXP 77
5717: PUSH
5718: LD_VAR 0 2
5722: ARRAY
5723: PUSH
5724: LD_EXP 77
5728: PUSH
5729: LD_VAR 0 2
5733: ARRAY
5734: PPUSH
5735: LD_INT 34
5737: PUSH
5738: LD_INT 32
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: PPUSH
5745: CALL_OW 72
5749: DIFF
5750: ST_TO_ADDR
// if not attackers then
5751: LD_VAR 0 6
5755: NOT
5756: IFFALSE 5760
// exit ;
5758: GO 5819
// ar_attackers := attackers ;
5760: LD_ADDR_EXP 10
5764: PUSH
5765: LD_VAR 0 6
5769: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5770: LD_INT 35
5772: PPUSH
5773: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5777: LD_VAR 0 6
5781: PPUSH
5782: LD_INT 60
5784: PUSH
5785: EMPTY
5786: LIST
5787: PPUSH
5788: CALL_OW 72
5792: NOT
5793: IFFALSE 5770
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_VAR 0 6
5804: PPUSH
5805: LD_VAR 0 5
5809: PPUSH
5810: LD_VAR 0 4
5814: PPUSH
5815: CALL 78941 0 4
// end ;
5819: PPOPN 6
5821: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5822: LD_INT 1
5824: PPUSH
5825: CALL_OW 302
5829: PUSH
5830: LD_EXP 9
5834: AND
5835: PUSH
5836: LD_EXP 48
5840: PPUSH
5841: LD_INT 22
5843: PPUSH
5844: CALL_OW 308
5848: AND
5849: PUSH
5850: LD_INT 1
5852: PPUSH
5853: CALL 79104 0 1
5857: PUSH
5858: LD_INT 0
5860: EQUAL
5861: AND
5862: PUSH
5863: LD_EXP 10
5867: NOT
5868: AND
5869: IFFALSE 6333
5871: GO 5873
5873: DISABLE
5874: LD_INT 0
5876: PPUSH
5877: PPUSH
5878: PPUSH
5879: PPUSH
5880: PPUSH
5881: PPUSH
5882: PPUSH
// begin base := 1 ;
5883: LD_ADDR_VAR 0 2
5887: PUSH
5888: LD_INT 1
5890: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_INT 0
5898: PUSH
5899: LD_INT 0
5901: PUSH
5902: LD_INT 0
5904: PUSH
5905: LD_INT 0
5907: PUSH
5908: LD_INT 0
5910: PUSH
5911: LD_INT 0
5913: PUSH
5914: LD_INT 0
5916: PUSH
5917: LD_INT 0
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 0
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 28
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: LD_INT 13
5963: PUSH
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 27
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 13
5981: PUSH
5982: LD_INT 1
5984: PUSH
5985: LD_INT 2
5987: PUSH
5988: LD_INT 25
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 11
5999: PUSH
6000: LD_INT 2
6002: PUSH
6003: LD_INT 2
6005: PUSH
6006: LD_INT 24
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 11
6017: PUSH
6018: LD_INT 2
6020: PUSH
6021: LD_INT 2
6023: PUSH
6024: LD_INT 24
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6040: LD_VAR 0 2
6044: PPUSH
6045: LD_VAR 0 3
6049: PPUSH
6050: CALL 78756 0 2
// repeat wait ( 0 0$1 ) ;
6054: LD_INT 35
6056: PPUSH
6057: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6061: LD_EXP 77
6065: PUSH
6066: LD_VAR 0 2
6070: ARRAY
6071: PUSH
6072: LD_INT 6
6074: GREATEREQUAL
6075: IFFALSE 6054
// wait ( 0 0$20 ) ;
6077: LD_INT 700
6079: PPUSH
6080: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 119
6091: PUSH
6092: LD_INT 9
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6102: LD_ADDR_VAR 0 6
6106: PUSH
6107: LD_EXP 77
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_EXP 77
6122: PUSH
6123: LD_VAR 0 2
6127: ARRAY
6128: PPUSH
6129: LD_INT 34
6131: PUSH
6132: LD_INT 32
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PPUSH
6139: CALL_OW 72
6143: DIFF
6144: ST_TO_ADDR
// if not attackers then
6145: LD_VAR 0 6
6149: NOT
6150: IFFALSE 6154
// exit ;
6152: GO 6333
// uc_side := 2 ;
6154: LD_ADDR_OWVAR 20
6158: PUSH
6159: LD_INT 2
6161: ST_TO_ADDR
// uc_nation := 2 ;
6162: LD_ADDR_OWVAR 21
6166: PUSH
6167: LD_INT 2
6169: ST_TO_ADDR
// InitHc ;
6170: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6174: LD_ADDR_VAR 0 1
6178: PUSH
6179: DOUBLE
6180: LD_INT 1
6182: DEC
6183: ST_TO_ADDR
6184: LD_INT 4
6186: PUSH
6187: LD_INT 5
6189: PUSH
6190: LD_INT 6
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: PUSH
6198: LD_OWVAR 67
6202: ARRAY
6203: PUSH
6204: FOR_TO
6205: IFFALSE 6282
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 15
6212: PUSH
6213: LD_INT 17
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 1
6222: PPUSH
6223: LD_INT 2
6225: PPUSH
6226: CALL_OW 12
6230: ARRAY
6231: PPUSH
6232: LD_INT 8
6234: PPUSH
6235: CALL_OW 380
// un := CreateHuman ;
6239: LD_ADDR_VAR 0 7
6243: PUSH
6244: CALL_OW 44
6248: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6249: LD_VAR 0 7
6253: PPUSH
6254: LD_INT 23
6256: PPUSH
6257: LD_INT 0
6259: PPUSH
6260: CALL_OW 49
// attackers := attackers union un ;
6264: LD_ADDR_VAR 0 6
6268: PUSH
6269: LD_VAR 0 6
6273: PUSH
6274: LD_VAR 0 7
6278: UNION
6279: ST_TO_ADDR
// end ;
6280: GO 6204
6282: POP
6283: POP
// repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6291: LD_VAR 0 6
6295: PPUSH
6296: LD_INT 60
6298: PUSH
6299: EMPTY
6300: LIST
6301: PPUSH
6302: CALL_OW 72
6306: NOT
6307: IFFALSE 6284
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6309: LD_VAR 0 2
6313: PPUSH
6314: LD_VAR 0 6
6318: PPUSH
6319: LD_VAR 0 5
6323: PPUSH
6324: LD_VAR 0 4
6328: PPUSH
6329: CALL 78941 0 4
// end ; end_of_file
6333: PPOPN 7
6335: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6336: LD_INT 0
6338: PPUSH
6339: PPUSH
6340: PPUSH
6341: PPUSH
// uc_side := 1 ;
6342: LD_ADDR_OWVAR 20
6346: PUSH
6347: LD_INT 1
6349: ST_TO_ADDR
// uc_nation := 1 ;
6350: LD_ADDR_OWVAR 21
6354: PUSH
6355: LD_INT 1
6357: ST_TO_ADDR
// InitHc ;
6358: CALL_OW 19
// InitVc ;
6362: CALL_OW 20
// tmp := [ ] ;
6366: LD_ADDR_VAR 0 3
6370: PUSH
6371: EMPTY
6372: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6373: LD_ADDR_VAR 0 2
6377: PUSH
6378: DOUBLE
6379: LD_INT 1
6381: DEC
6382: ST_TO_ADDR
6383: LD_INT 5
6385: PUSH
6386: LD_INT 6
6388: PUSH
6389: LD_INT 6
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: LIST
6396: PUSH
6397: LD_OWVAR 67
6401: ARRAY
6402: PUSH
6403: FOR_TO
6404: IFFALSE 6541
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6406: LD_INT 2
6408: PUSH
6409: LD_INT 4
6411: PUSH
6412: LD_INT 5
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 1
6422: PPUSH
6423: LD_INT 3
6425: PPUSH
6426: CALL_OW 12
6430: ARRAY
6431: PPUSH
6432: LD_INT 1
6434: PUSH
6435: LD_INT 3
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 1
6444: PPUSH
6445: LD_INT 2
6447: PPUSH
6448: CALL_OW 12
6452: ARRAY
6453: PPUSH
6454: LD_INT 3
6456: PPUSH
6457: LD_INT 9
6459: PUSH
6460: LD_INT 7
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 2
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 78
6481: PPUSH
6482: CALL 20543 0 5
// veh := CreateVehicle ;
6486: LD_ADDR_VAR 0 4
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6496: LD_VAR 0 4
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6508: LD_VAR 0 4
6512: PPUSH
6513: LD_INT 17
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// tmp := tmp ^ veh ;
6523: LD_ADDR_VAR 0 3
6527: PUSH
6528: LD_VAR 0 3
6532: PUSH
6533: LD_VAR 0 4
6537: ADD
6538: ST_TO_ADDR
// end ;
6539: GO 6403
6541: POP
6542: POP
// if not tmp then
6543: LD_VAR 0 3
6547: NOT
6548: IFFALSE 6552
// exit ;
6550: GO 6661
// if not first_powell_attack then
6552: LD_EXP 11
6556: NOT
6557: IFFALSE 6567
// first_powell_attack := true ;
6559: LD_ADDR_EXP 11
6563: PUSH
6564: LD_INT 1
6566: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6567: LD_INT 70
6569: PPUSH
6570: CALL_OW 67
// for i in tmp do
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_VAR 0 3
6583: PUSH
6584: FOR_IN
6585: IFFALSE 6652
// if IsOk ( i ) then
6587: LD_VAR 0 2
6591: PPUSH
6592: CALL_OW 302
6596: IFFALSE 6634
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6598: LD_VAR 0 2
6602: PPUSH
6603: LD_INT 81
6605: PUSH
6606: LD_INT 1
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PPUSH
6613: CALL_OW 69
6617: PPUSH
6618: LD_VAR 0 2
6622: PPUSH
6623: CALL_OW 74
6627: PPUSH
6628: CALL_OW 115
6632: GO 6650
// tmp := tmp diff i ;
6634: LD_ADDR_VAR 0 3
6638: PUSH
6639: LD_VAR 0 3
6643: PUSH
6644: LD_VAR 0 2
6648: DIFF
6649: ST_TO_ADDR
6650: GO 6584
6652: POP
6653: POP
// until not tmp ;
6654: LD_VAR 0 3
6658: NOT
6659: IFFALSE 6567
// end ; end_of_file
6661: LD_VAR 0 1
6665: RET
// export function Action ; var tmp , i , un ; begin
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
6671: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6672: LD_INT 68
6674: PPUSH
6675: LD_INT 39
6677: PPUSH
6678: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6682: LD_ADDR_VAR 0 2
6686: PUSH
6687: LD_INT 22
6689: PUSH
6690: LD_INT 7
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PPUSH
6697: CALL_OW 69
6701: ST_TO_ADDR
// InGameOn ;
6702: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6706: LD_VAR 0 2
6710: PPUSH
6711: LD_INT 71
6713: PPUSH
6714: LD_INT 49
6716: PPUSH
6717: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6721: LD_INT 35
6723: PPUSH
6724: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6728: LD_INT 7
6730: PPUSH
6731: LD_INT 71
6733: PPUSH
6734: LD_INT 51
6736: PPUSH
6737: CALL_OW 293
6741: IFFALSE 6721
// DialogueOn ;
6743: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6747: LD_EXP 14
6751: PPUSH
6752: LD_STRING D1-JMM-1
6754: PPUSH
6755: CALL_OW 88
// if Joan then
6759: LD_EXP 29
6763: IFFALSE 6777
// Say ( Joan , D1-Joan-1 ) ;
6765: LD_EXP 29
6769: PPUSH
6770: LD_STRING D1-Joan-1
6772: PPUSH
6773: CALL_OW 88
// if Lisa then
6777: LD_EXP 16
6781: IFFALSE 6795
// Say ( Lisa , D1-Lisa-1 ) ;
6783: LD_EXP 16
6787: PPUSH
6788: LD_STRING D1-Lisa-1
6790: PPUSH
6791: CALL_OW 88
// if Joan or Lisa then
6795: LD_EXP 29
6799: PUSH
6800: LD_EXP 16
6804: OR
6805: IFFALSE 6819
// Say ( JMM , D1-JMM-2 ) ;
6807: LD_EXP 14
6811: PPUSH
6812: LD_STRING D1-JMM-2
6814: PPUSH
6815: CALL_OW 88
// DialogueOff ;
6819: CALL_OW 7
// InGameOff ;
6823: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6827: LD_INT 71
6829: PPUSH
6830: LD_INT 50
6832: PPUSH
6833: LD_INT 7
6835: PPUSH
6836: LD_INT 30
6838: NEG
6839: PPUSH
6840: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6844: LD_INT 71
6846: PPUSH
6847: LD_INT 50
6849: PPUSH
6850: LD_INT 7
6852: PPUSH
6853: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6857: LD_STRING M1
6859: PPUSH
6860: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6864: LD_INT 35
6866: PPUSH
6867: CALL_OW 67
// until freedom ;
6871: LD_EXP 3
6875: IFFALSE 6864
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6877: LD_INT 350
6879: PPUSH
6880: LD_INT 700
6882: PPUSH
6883: CALL_OW 12
6887: PPUSH
6888: CALL_OW 67
// PrepareGossudarov ;
6892: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6896: LD_INT 35
6898: PPUSH
6899: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6903: LD_INT 22
6905: PUSH
6906: LD_INT 6
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: LD_INT 24
6918: PUSH
6919: LD_INT 1000
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 69
6938: PUSH
6939: LD_INT 7
6941: PPUSH
6942: LD_EXP 31
6946: PPUSH
6947: CALL_OW 292
6951: OR
6952: IFFALSE 6896
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_INT 6
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: PPUSH
6969: CALL_OW 69
6973: ST_TO_ADDR
// for i in tmp do
6974: LD_ADDR_VAR 0 3
6978: PUSH
6979: LD_VAR 0 2
6983: PUSH
6984: FOR_IN
6985: IFFALSE 7001
// SetSide ( i , 7 ) ;
6987: LD_VAR 0 3
6991: PPUSH
6992: LD_INT 7
6994: PPUSH
6995: CALL_OW 235
6999: GO 6984
7001: POP
7002: POP
// DialogueOn ;
7003: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7007: LD_EXP 14
7011: PUSH
7012: LD_EXP 15
7016: PUSH
7017: EMPTY
7018: LIST
7019: LIST
7020: PPUSH
7021: LD_EXP 31
7025: PPUSH
7026: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7030: LD_EXP 31
7034: PPUSH
7035: CALL_OW 87
// if not Roth then
7039: LD_EXP 15
7043: NOT
7044: IFFALSE 7136
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7046: LD_VAR 0 2
7050: PPUSH
7051: LD_INT 3
7053: PUSH
7054: LD_INT 24
7056: PUSH
7057: LD_INT 1000
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: PPUSH
7068: CALL_OW 72
7072: IFFALSE 7086
// Say ( JMM , D2-JMM-1 ) ;
7074: LD_EXP 14
7078: PPUSH
7079: LD_STRING D2-JMM-1
7081: PPUSH
7082: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7086: LD_EXP 14
7090: PPUSH
7091: LD_STRING D2-JMM-1b
7093: PPUSH
7094: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7098: LD_EXP 31
7102: PPUSH
7103: LD_STRING D2-Gos-1
7105: PPUSH
7106: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7110: LD_EXP 14
7114: PPUSH
7115: LD_STRING D2-JMM-2
7117: PPUSH
7118: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7122: LD_EXP 31
7126: PPUSH
7127: LD_STRING D2-Gos-2
7129: PPUSH
7130: CALL_OW 88
// end else
7134: GO 7288
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7136: LD_VAR 0 2
7140: PPUSH
7141: LD_INT 3
7143: PUSH
7144: LD_INT 24
7146: PUSH
7147: LD_INT 1000
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PPUSH
7158: CALL_OW 72
7162: IFFALSE 7188
// begin Say ( Roth , D2-Roth-2 ) ;
7164: LD_EXP 15
7168: PPUSH
7169: LD_STRING D2-Roth-2
7171: PPUSH
7172: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7176: LD_EXP 14
7180: PPUSH
7181: LD_STRING D2-JMM-1a
7183: PPUSH
7184: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7188: LD_EXP 15
7192: PPUSH
7193: LD_STRING D2-Roth-2a
7195: PPUSH
7196: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7200: LD_EXP 15
7204: PPUSH
7205: LD_STRING D2-Roth-2b
7207: PPUSH
7208: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7212: LD_EXP 14
7216: PPUSH
7217: LD_STRING D2-JMM-3
7219: PPUSH
7220: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7224: LD_VAR 0 2
7228: PPUSH
7229: LD_INT 3
7231: PUSH
7232: LD_INT 24
7234: PUSH
7235: LD_INT 1000
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: PPUSH
7246: CALL_OW 72
7250: IFFALSE 7288
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7252: LD_EXP 31
7256: PPUSH
7257: LD_STRING D2-Gos-3
7259: PPUSH
7260: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7264: LD_EXP 14
7268: PPUSH
7269: LD_STRING D2-JMM-4
7271: PPUSH
7272: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7276: LD_EXP 31
7280: PPUSH
7281: LD_STRING D2-Gos-4
7283: PPUSH
7284: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7288: LD_EXP 14
7292: PPUSH
7293: LD_STRING D2-JMM-5
7295: PPUSH
7296: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7300: LD_EXP 31
7304: PPUSH
7305: LD_STRING D2-Gos-5
7307: PPUSH
7308: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7312: LD_EXP 14
7316: PPUSH
7317: LD_STRING D2-JMM-6
7319: PPUSH
7320: CALL_OW 88
// DialogueOff ;
7324: CALL_OW 7
// wait ( 0 0$2 ) ;
7328: LD_INT 70
7330: PPUSH
7331: CALL_OW 67
// if Kirilenkova then
7335: LD_EXP 32
7339: IFFALSE 7353
// Say ( Kirilenkova , D3-Kir-1 ) ;
7341: LD_EXP 32
7345: PPUSH
7346: LD_STRING D3-Kir-1
7348: PPUSH
7349: CALL_OW 88
// gossudarov_arrive := true ;
7353: LD_ADDR_EXP 4
7357: PUSH
7358: LD_INT 1
7360: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7361: LD_STRING CombinedForces
7363: PPUSH
7364: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7368: LD_INT 35
7370: PPUSH
7371: CALL_OW 67
// until ru_lab_builded ;
7375: LD_EXP 5
7379: IFFALSE 7368
// if Kirilenkova then
7381: LD_EXP 32
7385: IFFALSE 7401
// Say ( Kirilenkova , D3a-Kir-1 ) else
7387: LD_EXP 32
7391: PPUSH
7392: LD_STRING D3a-Kir-1
7394: PPUSH
7395: CALL_OW 88
7399: GO 7423
// begin un := SciRu ;
7401: LD_ADDR_VAR 0 4
7405: PUSH
7406: CALL 12393 0 0
7410: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7411: LD_VAR 0 4
7415: PPUSH
7416: LD_STRING D3a-Sci1-1
7418: PPUSH
7419: CALL_OW 88
// end ; if Kirilenkova or un then
7423: LD_EXP 32
7427: PUSH
7428: LD_VAR 0 4
7432: OR
7433: IFFALSE 7447
// Say ( JMM , D3a-JMM-1 ) ;
7435: LD_EXP 14
7439: PPUSH
7440: LD_STRING D3a-JMM-1
7442: PPUSH
7443: CALL_OW 88
// end ;
7447: LD_VAR 0 1
7451: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7452: LD_EXP 4
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_INT 7
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: PUSH
7467: LD_INT 2
7469: PUSH
7470: LD_INT 25
7472: PUSH
7473: LD_INT 1
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 25
7482: PUSH
7483: LD_INT 2
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 25
7492: PUSH
7493: LD_INT 3
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: LD_INT 25
7502: PUSH
7503: LD_INT 4
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 25
7512: PUSH
7513: LD_INT 5
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 25
7522: PUSH
7523: LD_INT 8
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 25
7532: PUSH
7533: LD_INT 9
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: LIST
7546: LIST
7547: LIST
7548: LIST
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PPUSH
7554: CALL_OW 69
7558: PUSH
7559: LD_INT 7
7561: LESS
7562: AND
7563: IFFALSE 7575
7565: GO 7567
7567: DISABLE
// YouLost ( TooMany ) ;
7568: LD_STRING TooMany
7570: PPUSH
7571: CALL_OW 104
7575: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7576: LD_EXP 31
7580: PPUSH
7581: CALL_OW 255
7585: PUSH
7586: LD_INT 7
7588: EQUAL
7589: IFFALSE 7789
7591: GO 7593
7593: DISABLE
7594: LD_INT 0
7596: PPUSH
7597: PPUSH
7598: PPUSH
// begin uc_side := 3 ;
7599: LD_ADDR_OWVAR 20
7603: PUSH
7604: LD_INT 3
7606: ST_TO_ADDR
// uc_nation := 3 ;
7607: LD_ADDR_OWVAR 21
7611: PUSH
7612: LD_INT 3
7614: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7615: LD_INT 21
7617: PPUSH
7618: LD_INT 3
7620: PPUSH
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 42
7626: PPUSH
7627: LD_INT 100
7629: PPUSH
7630: CALL 20543 0 5
// un := CreateVehicle ;
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: CALL_OW 45
7643: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7644: LD_VAR 0 3
7648: PPUSH
7649: LD_INT 15
7651: PPUSH
7652: LD_INT 0
7654: PPUSH
7655: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7659: LD_VAR 0 3
7663: PPUSH
7664: LD_INT 67
7666: PPUSH
7667: LD_INT 45
7669: PPUSH
7670: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7674: LD_VAR 0 3
7678: PPUSH
7679: LD_INT 70
7681: PPUSH
7682: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7686: LD_VAR 0 3
7690: PPUSH
7691: LD_INT 69
7693: PPUSH
7694: LD_INT 18
7696: PPUSH
7697: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7701: LD_VAR 0 3
7705: PPUSH
7706: LD_INT 60
7708: PPUSH
7709: LD_INT 2
7711: PPUSH
7712: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7716: LD_INT 35
7718: PPUSH
7719: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7723: LD_VAR 0 3
7727: PPUSH
7728: CALL_OW 302
7732: NOT
7733: PUSH
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 17
7741: PPUSH
7742: CALL_OW 308
7746: OR
7747: IFFALSE 7716
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7749: LD_VAR 0 3
7753: PPUSH
7754: LD_INT 17
7756: PPUSH
7757: CALL_OW 308
7761: PUSH
7762: LD_VAR 0 3
7766: PPUSH
7767: LD_INT 60
7769: PPUSH
7770: LD_INT 2
7772: PPUSH
7773: CALL_OW 307
7777: OR
7778: IFFALSE 7789
// RemoveUnit ( un ) ;
7780: LD_VAR 0 3
7784: PPUSH
7785: CALL_OW 64
// end ;
7789: PPOPN 3
7791: END
// every 0 0$2 do var i , un , tmp ;
7792: GO 7794
7794: DISABLE
7795: LD_INT 0
7797: PPUSH
7798: PPUSH
7799: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7800: LD_INT 70
7802: PPUSH
7803: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7807: LD_ADDR_VAR 0 3
7811: PUSH
7812: LD_INT 22
7814: PUSH
7815: LD_INT 7
7817: PUSH
7818: EMPTY
7819: LIST
7820: LIST
7821: PUSH
7822: LD_INT 101
7824: PUSH
7825: LD_INT 3
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL_OW 69
7840: ST_TO_ADDR
// until tmp ;
7841: LD_VAR 0 3
7845: IFFALSE 7800
// un := NearestUnitToUnit ( tmp , JMM ) ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 3
7856: PPUSH
7857: LD_EXP 14
7861: PPUSH
7862: CALL_OW 74
7866: ST_TO_ADDR
// player_spotted := true ;
7867: LD_ADDR_EXP 6
7871: PUSH
7872: LD_INT 1
7874: ST_TO_ADDR
// tmp := SciRu ;
7875: LD_ADDR_VAR 0 3
7879: PUSH
7880: CALL 12393 0 0
7884: ST_TO_ADDR
// if not tmp then
7885: LD_VAR 0 3
7889: NOT
7890: IFFALSE 7902
// tmp := SolRu ;
7892: LD_ADDR_VAR 0 3
7896: PUSH
7897: CALL 12540 0 0
7901: ST_TO_ADDR
// DialogueOn ;
7902: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7906: LD_VAR 0 2
7910: PPUSH
7911: CALL_OW 250
7915: PPUSH
7916: LD_VAR 0 2
7920: PPUSH
7921: CALL_OW 251
7925: PPUSH
7926: LD_INT 7
7928: PPUSH
7929: LD_INT 8
7931: NEG
7932: PPUSH
7933: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7937: LD_VAR 0 2
7941: PPUSH
7942: CALL_OW 87
// if tmp then
7946: LD_VAR 0 3
7950: IFFALSE 7964
// Say ( tmp , D4-RSci1-1 ) ;
7952: LD_VAR 0 3
7956: PPUSH
7957: LD_STRING D4-RSci1-1
7959: PPUSH
7960: CALL_OW 88
// if Gossudarov then
7964: LD_EXP 31
7968: IFFALSE 7994
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7970: LD_EXP 31
7974: PPUSH
7975: LD_STRING D4-Gos-1
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7982: LD_EXP 14
7986: PPUSH
7987: LD_STRING D4-JMM-1
7989: PPUSH
7990: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7994: LD_VAR 0 2
7998: PPUSH
7999: CALL_OW 250
8003: PPUSH
8004: LD_VAR 0 2
8008: PPUSH
8009: CALL_OW 251
8013: PPUSH
8014: LD_INT 7
8016: PPUSH
8017: CALL_OW 331
// DialogueOff ;
8021: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8025: LD_STRING M5
8027: PPUSH
8028: CALL_OW 337
// end ;
8032: PPOPN 3
8034: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8035: LD_EXP 6
8039: IFFALSE 8628
8041: GO 8043
8043: DISABLE
8044: LD_INT 0
8046: PPUSH
8047: PPUSH
8048: PPUSH
// begin PrepareBelkov ;
8049: CALL 1974 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8053: LD_EXP 46
8057: PPUSH
8058: LD_INT 118
8060: PPUSH
8061: LD_INT 106
8063: PPUSH
8064: CALL_OW 111
// AddComHold ( Belkov ) ;
8068: LD_EXP 46
8072: PPUSH
8073: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8077: LD_INT 35
8079: PPUSH
8080: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8084: LD_EXP 46
8088: PPUSH
8089: LD_INT 118
8091: PPUSH
8092: LD_INT 106
8094: PPUSH
8095: CALL_OW 307
8099: IFFALSE 8077
// ChangeSideFog ( 4 , 7 ) ;
8101: LD_INT 4
8103: PPUSH
8104: LD_INT 7
8106: PPUSH
8107: CALL_OW 343
// if IsOk ( Belkov ) then
8111: LD_EXP 46
8115: PPUSH
8116: CALL_OW 302
8120: IFFALSE 8204
// begin InGameOn ;
8122: CALL_OW 8
// DialogueOn ;
8126: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8130: LD_EXP 46
8134: PPUSH
8135: LD_STRING D5-Bel-1
8137: PPUSH
8138: CALL_OW 94
// if Gossudarov then
8142: LD_EXP 31
8146: IFFALSE 8196
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8148: LD_EXP 31
8152: PPUSH
8153: LD_STRING D5-Gos-1
8155: PPUSH
8156: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8160: LD_EXP 14
8164: PPUSH
8165: LD_STRING D5-JMM-1
8167: PPUSH
8168: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8172: LD_EXP 31
8176: PPUSH
8177: LD_STRING D5-Gos-2
8179: PPUSH
8180: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8184: LD_EXP 14
8188: PPUSH
8189: LD_STRING D5-JMM-2
8191: PPUSH
8192: CALL_OW 88
// end ; DialogueOff ;
8196: CALL_OW 7
// InGameOff ;
8200: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8204: LD_STRING QSaveBelkov
8206: PPUSH
8207: CALL_OW 97
8211: PUSH
8212: LD_INT 1
8214: DOUBLE
8215: EQUAL
8216: IFTRUE 8220
8218: GO 8270
8220: POP
// begin DialogueOn ;
8221: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8225: LD_EXP 14
8229: PPUSH
8230: LD_STRING D5a-JMM-1
8232: PPUSH
8233: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8237: LD_EXP 46
8241: PPUSH
8242: LD_STRING D5a-Bel-1
8244: PPUSH
8245: CALL_OW 94
// DialogueOff ;
8249: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8253: LD_EXP 46
8257: PPUSH
8258: LD_INT 83
8260: PPUSH
8261: LD_INT 49
8263: PPUSH
8264: CALL_OW 111
// end ; 2 :
8268: GO 8303
8270: LD_INT 2
8272: DOUBLE
8273: EQUAL
8274: IFTRUE 8278
8276: GO 8302
8278: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8279: LD_EXP 14
8283: PPUSH
8284: LD_STRING D5a-JMM-2
8286: PPUSH
8287: CALL_OW 88
// ComHold ( Belkov ) ;
8291: LD_EXP 46
8295: PPUSH
8296: CALL_OW 140
// end ; end ;
8300: GO 8303
8302: POP
// time := 0 0$00 ;
8303: LD_ADDR_VAR 0 1
8307: PUSH
8308: LD_INT 0
8310: ST_TO_ADDR
// vehSpawned := false ;
8311: LD_ADDR_VAR 0 3
8315: PUSH
8316: LD_INT 0
8318: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8319: LD_INT 35
8321: PPUSH
8322: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8326: LD_VAR 0 1
8330: PUSH
8331: LD_INT 350
8333: PUSH
8334: LD_INT 175
8336: PUSH
8337: LD_INT 70
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: PUSH
8345: LD_OWVAR 67
8349: ARRAY
8350: GREATEREQUAL
8351: PUSH
8352: LD_VAR 0 3
8356: NOT
8357: AND
8358: IFFALSE 8448
// begin vehSpawned := true ;
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 1
8367: ST_TO_ADDR
// uc_side := 3 ;
8368: LD_ADDR_OWVAR 20
8372: PUSH
8373: LD_INT 3
8375: ST_TO_ADDR
// uc_nation := 3 ;
8376: LD_ADDR_OWVAR 21
8380: PUSH
8381: LD_INT 3
8383: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8384: LD_INT 22
8386: PPUSH
8387: LD_INT 3
8389: PPUSH
8390: LD_INT 3
8392: PPUSH
8393: LD_INT 43
8395: PPUSH
8396: LD_INT 100
8398: PPUSH
8399: CALL 20543 0 5
// veh := CreateVehicle ;
8403: LD_ADDR_VAR 0 2
8407: PUSH
8408: CALL_OW 45
8412: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8413: LD_VAR 0 2
8417: PPUSH
8418: LD_INT 130
8420: PPUSH
8421: LD_INT 131
8423: PPUSH
8424: LD_INT 0
8426: PPUSH
8427: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8431: LD_VAR 0 2
8435: PPUSH
8436: LD_INT 100
8438: PPUSH
8439: LD_INT 82
8441: PPUSH
8442: CALL_OW 114
// end else
8446: GO 8462
// time := time + 0 0$1 ;
8448: LD_ADDR_VAR 0 1
8452: PUSH
8453: LD_VAR 0 1
8457: PUSH
8458: LD_INT 35
8460: PLUS
8461: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8462: LD_EXP 46
8466: PPUSH
8467: CALL_OW 301
8471: PUSH
8472: LD_EXP 46
8476: PPUSH
8477: CALL_OW 255
8481: PUSH
8482: LD_INT 4
8484: EQUAL
8485: AND
8486: PUSH
8487: LD_INT 22
8489: PUSH
8490: LD_INT 7
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PPUSH
8497: CALL_OW 69
8501: PPUSH
8502: LD_EXP 46
8506: PPUSH
8507: CALL_OW 74
8511: PPUSH
8512: LD_EXP 46
8516: PPUSH
8517: CALL_OW 296
8521: PUSH
8522: LD_INT 10
8524: LESS
8525: OR
8526: IFFALSE 8319
// if IsDead ( Belkov ) then
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 301
8537: IFFALSE 8562
// begin CenterNowOnUnits ( Belkov ) ;
8539: LD_EXP 46
8543: PPUSH
8544: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8548: LD_EXP 14
8552: PPUSH
8553: LD_STRING D5a-JMM-2a
8555: PPUSH
8556: CALL_OW 88
// exit ;
8560: GO 8628
// end ; if See ( 7 , Belkov ) then
8562: LD_INT 7
8564: PPUSH
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 292
8574: IFFALSE 8588
// SetSide ( Belkov , 7 ) ;
8576: LD_EXP 46
8580: PPUSH
8581: LD_INT 7
8583: PPUSH
8584: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8588: LD_INT 35
8590: PPUSH
8591: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8595: LD_EXP 46
8599: PPUSH
8600: LD_INT 66
8602: PPUSH
8603: LD_INT 45
8605: PPUSH
8606: CALL_OW 297
8610: PUSH
8611: LD_INT 30
8613: LESS
8614: IFFALSE 8588
// Say ( Belkov , D6-Bel-1 ) ;
8616: LD_EXP 46
8620: PPUSH
8621: LD_STRING D6-Bel-1
8623: PPUSH
8624: CALL_OW 88
// end ;
8628: PPOPN 3
8630: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8631: LD_EXP 46
8635: PPUSH
8636: CALL_OW 302
8640: PUSH
8641: LD_EXP 46
8645: PPUSH
8646: CALL_OW 504
8650: PUSH
8651: LD_INT 2
8653: PUSH
8654: LD_INT 34
8656: PUSH
8657: LD_INT 47
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: PUSH
8664: LD_INT 34
8666: PUSH
8667: LD_INT 45
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: LIST
8678: PPUSH
8679: CALL_OW 69
8683: IN
8684: AND
8685: IFFALSE 8702
8687: GO 8689
8689: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8690: LD_EXP 46
8694: PPUSH
8695: LD_STRING D7-Bel-1
8697: PPUSH
8698: CALL_OW 88
8702: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8703: LD_INT 22
8705: PUSH
8706: LD_INT 7
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: LD_INT 101
8715: PUSH
8716: LD_INT 2
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PPUSH
8727: CALL_OW 69
8731: PUSH
8732: LD_EXP 8
8736: NOT
8737: AND
8738: PUSH
8739: LD_EXP 45
8743: PPUSH
8744: CALL_OW 305
8748: NOT
8749: AND
8750: IFFALSE 9220
8752: GO 8754
8754: DISABLE
8755: LD_INT 0
8757: PPUSH
// begin ar_base_spotted := true ;
8758: LD_ADDR_EXP 8
8762: PUSH
8763: LD_INT 1
8765: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8766: LD_ADDR_VAR 0 1
8770: PUSH
8771: LD_INT 22
8773: PUSH
8774: LD_INT 2
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 21
8783: PUSH
8784: LD_INT 3
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8800: LD_ADDR_VAR 0 1
8804: PUSH
8805: LD_VAR 0 1
8809: PPUSH
8810: LD_EXP 14
8814: PPUSH
8815: CALL_OW 74
8819: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8820: LD_INT 7
8822: PPUSH
8823: LD_INT 3
8825: PPUSH
8826: CALL_OW 332
// DialogueOn ;
8830: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8834: LD_VAR 0 1
8838: PPUSH
8839: CALL_OW 250
8843: PPUSH
8844: LD_VAR 0 1
8848: PPUSH
8849: CALL_OW 251
8853: PPUSH
8854: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8858: LD_ADDR_VAR 0 1
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 7
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 23
8875: PUSH
8876: LD_INT 1
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: LD_INT 26
8885: PUSH
8886: LD_INT 1
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: PPUSH
8898: CALL_OW 69
8902: PUSH
8903: LD_EXP 14
8907: PUSH
8908: LD_EXP 18
8912: PUSH
8913: LD_EXP 19
8917: PUSH
8918: LD_EXP 26
8922: PUSH
8923: LD_EXP 15
8927: PUSH
8928: LD_EXP 24
8932: PUSH
8933: LD_EXP 20
8937: PUSH
8938: LD_EXP 22
8942: PUSH
8943: EMPTY
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: DIFF
8953: ST_TO_ADDR
// if not tmp then
8954: LD_VAR 0 1
8958: NOT
8959: IFFALSE 9033
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8961: LD_ADDR_VAR 0 1
8965: PUSH
8966: LD_INT 22
8968: PUSH
8969: LD_INT 7
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: PUSH
8976: LD_INT 23
8978: PUSH
8979: LD_INT 1
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: LD_INT 26
8988: PUSH
8989: LD_INT 2
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: PPUSH
9001: CALL_OW 69
9005: PUSH
9006: LD_EXP 29
9010: PUSH
9011: LD_EXP 16
9015: PUSH
9016: LD_EXP 27
9020: PUSH
9021: LD_EXP 28
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: LIST
9030: LIST
9031: DIFF
9032: ST_TO_ADDR
// if tmp then
9033: LD_VAR 0 1
9037: IFFALSE 9108
// case GetSex ( tmp [ 1 ] ) of sex_male :
9039: LD_VAR 0 1
9043: PUSH
9044: LD_INT 1
9046: ARRAY
9047: PPUSH
9048: CALL_OW 258
9052: PUSH
9053: LD_INT 1
9055: DOUBLE
9056: EQUAL
9057: IFTRUE 9061
9059: GO 9080
9061: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9062: LD_VAR 0 1
9066: PUSH
9067: LD_INT 1
9069: ARRAY
9070: PPUSH
9071: LD_STRING D9-Sol1-1
9073: PPUSH
9074: CALL_OW 88
9078: GO 9108
9080: LD_INT 2
9082: DOUBLE
9083: EQUAL
9084: IFTRUE 9088
9086: GO 9107
9088: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9089: LD_VAR 0 1
9093: PUSH
9094: LD_INT 1
9096: ARRAY
9097: PPUSH
9098: LD_STRING D9-FSol1-1
9100: PPUSH
9101: CALL_OW 88
9105: GO 9108
9107: POP
// if Frank then
9108: LD_EXP 26
9112: IFFALSE 9216
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9114: LD_EXP 55
9118: PPUSH
9119: CALL_OW 250
9123: PPUSH
9124: LD_EXP 55
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: LD_INT 7
9136: PPUSH
9137: LD_INT 8
9139: PPUSH
9140: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9144: LD_EXP 55
9148: PPUSH
9149: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9153: LD_EXP 26
9157: PPUSH
9158: LD_STRING D9-Frank-1
9160: PPUSH
9161: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9165: LD_EXP 14
9169: PPUSH
9170: LD_STRING D9-JMM-1
9172: PPUSH
9173: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9177: LD_EXP 26
9181: PPUSH
9182: LD_STRING D9-Frank-2
9184: PPUSH
9185: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9189: LD_EXP 55
9193: PPUSH
9194: CALL_OW 250
9198: PPUSH
9199: LD_EXP 55
9203: PPUSH
9204: CALL_OW 251
9208: PPUSH
9209: LD_INT 7
9211: PPUSH
9212: CALL_OW 331
// end ; DialogueOff ;
9216: CALL_OW 7
// end ;
9220: PPOPN 1
9222: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9223: LD_EXP 7
9227: PUSH
9228: LD_OWVAR 1
9232: PUSH
9233: LD_INT 42000
9235: GREATEREQUAL
9236: OR
9237: IFFALSE 10264
9239: GO 9241
9241: DISABLE
9242: LD_INT 0
9244: PPUSH
9245: PPUSH
// begin selected_option := 1 ;
9246: LD_ADDR_VAR 0 2
9250: PUSH
9251: LD_INT 1
9253: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9254: LD_INT 10500
9256: PPUSH
9257: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9261: LD_INT 35
9263: PPUSH
9264: CALL_OW 67
// until not ru_attackers ;
9268: LD_EXP 51
9272: NOT
9273: IFFALSE 9261
// PrepareBurlak ;
9275: CALL 2086 0 0
// repeat wait ( 0 0$2 ) ;
9279: LD_INT 70
9281: PPUSH
9282: CALL_OW 67
// until not HasTask ( Burlak ) ;
9286: LD_EXP 45
9290: PPUSH
9291: CALL_OW 314
9295: NOT
9296: IFFALSE 9279
// InGameOn ;
9298: CALL_OW 8
// DialogueOn ;
9302: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9306: LD_EXP 48
9310: PPUSH
9311: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9315: LD_EXP 45
9319: PPUSH
9320: LD_STRING D10-Bur-1
9322: PPUSH
9323: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9327: LD_EXP 46
9331: PUSH
9332: LD_EXP 46
9336: PPUSH
9337: CALL_OW 255
9341: PUSH
9342: LD_INT 7
9344: EQUAL
9345: AND
9346: IFFALSE 9360
// Say ( Belkov , D10-Bel-1 ) ;
9348: LD_EXP 46
9352: PPUSH
9353: LD_STRING D10-Bel-1
9355: PPUSH
9356: CALL_OW 88
// if Gossudarov then
9360: LD_EXP 31
9364: IFFALSE 9378
// Say ( Gossudarov , D10-Gos-1 ) ;
9366: LD_EXP 31
9370: PPUSH
9371: LD_STRING D10-Gos-1
9373: PPUSH
9374: CALL_OW 88
// if Kirilenkova then
9378: LD_EXP 32
9382: IFFALSE 9396
// Say ( Kirilenkova , D10-Kir-1 ) ;
9384: LD_EXP 32
9388: PPUSH
9389: LD_STRING D10-Kir-1
9391: PPUSH
9392: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9396: CALL 12540 0 0
9400: PPUSH
9401: LD_STRING D10-RSol1-1
9403: PPUSH
9404: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9408: LD_EXP 45
9412: PPUSH
9413: LD_STRING D10-Bur-2
9415: PPUSH
9416: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9420: LD_EXP 14
9424: PPUSH
9425: LD_STRING D10-JMM-2
9427: PPUSH
9428: CALL_OW 88
// if Kirilenkova then
9432: LD_EXP 32
9436: IFFALSE 9452
// Say ( Kirilenkova , D10-Kir-2 ) else
9438: LD_EXP 32
9442: PPUSH
9443: LD_STRING D10-Kir-2
9445: PPUSH
9446: CALL_OW 88
9450: GO 9464
// Say ( SolRu , D10-RSol1-2 ) ;
9452: CALL 12540 0 0
9456: PPUSH
9457: LD_STRING D10-RSol1-2
9459: PPUSH
9460: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9464: LD_EXP 14
9468: PPUSH
9469: LD_STRING D10-JMM-3
9471: PPUSH
9472: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9476: LD_EXP 45
9480: PPUSH
9481: LD_STRING D10-Bur-3
9483: PPUSH
9484: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9488: LD_EXP 14
9492: PPUSH
9493: LD_STRING D10-JMM-4
9495: PPUSH
9496: CALL_OW 88
// DialogueOff ;
9500: CALL_OW 7
// InGameOff ;
9504: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9508: LD_STRING M2
9510: PPUSH
9511: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9515: LD_INT 35
9517: PPUSH
9518: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9522: LD_INT 22
9524: PUSH
9525: LD_INT 7
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 91
9534: PUSH
9535: LD_EXP 45
9539: PUSH
9540: LD_INT 8
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PPUSH
9552: CALL_OW 69
9556: IFFALSE 9515
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9558: LD_ADDR_VAR 0 1
9562: PUSH
9563: LD_INT 22
9565: PUSH
9566: LD_INT 4
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PPUSH
9573: CALL_OW 69
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9595
// SetSide ( i , 7 ) ;
9581: LD_VAR 0 1
9585: PPUSH
9586: LD_INT 7
9588: PPUSH
9589: CALL_OW 235
9593: GO 9578
9595: POP
9596: POP
// ChangeMissionObjectives ( M3 ) ;
9597: LD_STRING M3
9599: PPUSH
9600: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9604: LD_INT 35
9606: PPUSH
9607: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9611: LD_EXP 14
9615: PPUSH
9616: LD_EXP 45
9620: PPUSH
9621: CALL_OW 296
9625: PUSH
9626: LD_INT 8
9628: LESS
9629: IFFALSE 9604
// ComTurnUnit ( JMM , Burlak ) ;
9631: LD_EXP 14
9635: PPUSH
9636: LD_EXP 45
9640: PPUSH
9641: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9645: LD_EXP 45
9649: PPUSH
9650: LD_EXP 14
9654: PPUSH
9655: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9659: LD_INT 10
9661: PPUSH
9662: CALL_OW 67
// DialogueOn ;
9666: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9670: LD_EXP 14
9674: PPUSH
9675: LD_STRING D11-JMM-1
9677: PPUSH
9678: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9682: LD_EXP 45
9686: PPUSH
9687: LD_STRING D11-Bur-1
9689: PPUSH
9690: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9694: LD_EXP 14
9698: PPUSH
9699: LD_STRING D11-JMM-2
9701: PPUSH
9702: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9706: LD_EXP 45
9710: PPUSH
9711: LD_STRING D11-Bur-2
9713: PPUSH
9714: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9718: LD_EXP 14
9722: PPUSH
9723: LD_STRING D11-JMM-3
9725: PPUSH
9726: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9730: LD_EXP 45
9734: PPUSH
9735: LD_STRING D11-Bur-3
9737: PPUSH
9738: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9742: LD_EXP 14
9746: PPUSH
9747: LD_STRING D11-JMM-4
9749: PPUSH
9750: CALL_OW 88
// if ar_base_spotted then
9754: LD_EXP 8
9758: IFFALSE 9774
// Say ( Burlak , D12-Bur-1 ) else
9760: LD_EXP 45
9764: PPUSH
9765: LD_STRING D12-Bur-1
9767: PPUSH
9768: CALL_OW 88
9772: GO 9813
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9774: LD_INT 7
9776: PPUSH
9777: LD_INT 3
9779: PPUSH
9780: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9784: LD_INT 127
9786: PPUSH
9787: LD_INT 45
9789: PPUSH
9790: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9794: LD_EXP 45
9798: PPUSH
9799: LD_STRING D12-Bur-1a
9801: PPUSH
9802: CALL_OW 88
// dwait ( 0 0$2 ) ;
9806: LD_INT 70
9808: PPUSH
9809: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9813: LD_EXP 45
9817: PPUSH
9818: LD_STRING D12-Bur-1b
9820: PPUSH
9821: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9825: LD_EXP 14
9829: PPUSH
9830: LD_STRING D12-JMM-1
9832: PPUSH
9833: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9837: LD_EXP 45
9841: PPUSH
9842: LD_STRING D12-Bur-2
9844: PPUSH
9845: CALL_OW 88
// if Roth then
9849: LD_EXP 15
9853: IFFALSE 9869
// Say ( Roth , D12-Roth-2 ) else
9855: LD_EXP 15
9859: PPUSH
9860: LD_STRING D12-Roth-2
9862: PPUSH
9863: CALL_OW 88
9867: GO 9881
// Say ( SciRu , D12-RSci1-2 ) ;
9869: CALL 12393 0 0
9873: PPUSH
9874: LD_STRING D12-RSci1-2
9876: PPUSH
9877: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9881: LD_EXP 14
9885: PPUSH
9886: LD_STRING D12-JMM-2
9888: PPUSH
9889: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9893: LD_EXP 45
9897: PPUSH
9898: LD_STRING D12-Bur-3
9900: PPUSH
9901: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9905: LD_EXP 14
9909: PPUSH
9910: LD_STRING D12-JMM-3
9912: PPUSH
9913: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9917: LD_EXP 45
9921: PPUSH
9922: LD_STRING D12-Bur-4
9924: PPUSH
9925: CALL_OW 88
// case Query ( QBase ) of 1 :
9929: LD_STRING QBase
9931: PPUSH
9932: CALL_OW 97
9936: PUSH
9937: LD_INT 1
9939: DOUBLE
9940: EQUAL
9941: IFTRUE 9945
9943: GO 10063
9945: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9946: LD_EXP 14
9950: PPUSH
9951: LD_STRING D13a-JMM-1
9953: PPUSH
9954: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9958: LD_EXP 45
9962: PPUSH
9963: LD_STRING D13a-Bur-1
9965: PPUSH
9966: CALL_OW 88
// if Roth then
9970: LD_EXP 15
9974: IFFALSE 9990
// Say ( Roth , D13a-Roth-1 ) else
9976: LD_EXP 15
9980: PPUSH
9981: LD_STRING D13a-Roth-1
9983: PPUSH
9984: CALL_OW 88
9988: GO 10002
// Say ( SciRu , D13a-RSci1-1 ) ;
9990: CALL 12393 0 0
9994: PPUSH
9995: LD_STRING D13a-RSci1-1
9997: PPUSH
9998: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10002: LD_EXP 14
10006: PPUSH
10007: LD_STRING D13a-JMM-2
10009: PPUSH
10010: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10014: LD_STRING QBaseAgain
10016: PPUSH
10017: CALL_OW 97
10021: PUSH
10022: LD_INT 1
10024: DOUBLE
10025: EQUAL
10026: IFTRUE 10030
10028: GO 10041
10030: POP
// selected_option := 2 ; 2 :
10031: LD_ADDR_VAR 0 2
10035: PUSH
10036: LD_INT 2
10038: ST_TO_ADDR
10039: GO 10061
10041: LD_INT 2
10043: DOUBLE
10044: EQUAL
10045: IFTRUE 10049
10047: GO 10060
10049: POP
// selected_option := 3 ; end ;
10050: LD_ADDR_VAR 0 2
10054: PUSH
10055: LD_INT 3
10057: ST_TO_ADDR
10058: GO 10061
10060: POP
// end ; 2 :
10061: GO 10102
10063: LD_INT 2
10065: DOUBLE
10066: EQUAL
10067: IFTRUE 10071
10069: GO 10082
10071: POP
// selected_option := 2 ; 3 :
10072: LD_ADDR_VAR 0 2
10076: PUSH
10077: LD_INT 2
10079: ST_TO_ADDR
10080: GO 10102
10082: LD_INT 3
10084: DOUBLE
10085: EQUAL
10086: IFTRUE 10090
10088: GO 10101
10090: POP
// selected_option := 3 ; end ;
10091: LD_ADDR_VAR 0 2
10095: PUSH
10096: LD_INT 3
10098: ST_TO_ADDR
10099: GO 10102
10101: POP
// if selected_option = 2 then
10102: LD_VAR 0 2
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10204
// begin Say ( JMM , D13b-JMM-1 ) ;
10112: LD_EXP 14
10116: PPUSH
10117: LD_STRING D13b-JMM-1
10119: PPUSH
10120: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10124: LD_EXP 45
10128: PPUSH
10129: LD_STRING D13b-Bur-1
10131: PPUSH
10132: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10136: LD_EXP 14
10140: PPUSH
10141: LD_STRING D13b-JMM-2
10143: PPUSH
10144: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10148: LD_EXP 54
10152: PPUSH
10153: LD_STRING D13b-Abd-2
10155: PPUSH
10156: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10160: LD_EXP 14
10164: PPUSH
10165: LD_STRING D13b-JMM-3
10167: PPUSH
10168: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10172: LD_EXP 54
10176: PPUSH
10177: LD_STRING D13b-Abd-3
10179: PPUSH
10180: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10184: LD_EXP 14
10188: PPUSH
10189: LD_STRING D13b-JMM-4
10191: PPUSH
10192: CALL_OW 88
// ar_active_attack := true ;
10196: LD_ADDR_EXP 9
10200: PUSH
10201: LD_INT 1
10203: ST_TO_ADDR
// end ; if selected_option = 3 then
10204: LD_VAR 0 2
10208: PUSH
10209: LD_INT 3
10211: EQUAL
10212: IFFALSE 10238
// begin Say ( JMM , D13c-JMM-1 ) ;
10214: LD_EXP 14
10218: PPUSH
10219: LD_STRING D13c-JMM-1
10221: PPUSH
10222: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10226: LD_EXP 45
10230: PPUSH
10231: LD_STRING D13c-Bur-1
10233: PPUSH
10234: CALL_OW 88
// end ; DialogueOff ;
10238: CALL_OW 7
// if not ar_active_attack then
10242: LD_EXP 9
10246: NOT
10247: IFFALSE 10264
// begin wait ( 6 6$00 ) ;
10249: LD_INT 12600
10251: PPUSH
10252: CALL_OW 67
// ar_active_attack := true ;
10256: LD_ADDR_EXP 9
10260: PUSH
10261: LD_INT 1
10263: ST_TO_ADDR
// end ; end ;
10264: PPOPN 2
10266: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10267: LD_EXP 45
10271: PPUSH
10272: CALL_OW 305
10276: PUSH
10277: LD_EXP 45
10281: PPUSH
10282: CALL_OW 255
10286: PUSH
10287: LD_INT 7
10289: EQUAL
10290: AND
10291: IFFALSE 10487
10293: GO 10295
10295: DISABLE
10296: LD_INT 0
10298: PPUSH
// begin wait ( 4 4$40 ) ;
10299: LD_INT 9800
10301: PPUSH
10302: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10306: LD_INT 35
10308: PPUSH
10309: CALL_OW 67
// until not ru_attackers ;
10313: LD_EXP 51
10317: NOT
10318: IFFALSE 10306
// PrepareGnyevko ;
10320: CALL 2030 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10324: LD_EXP 47
10328: PPUSH
10329: LD_INT 124
10331: PPUSH
10332: LD_INT 118
10334: PPUSH
10335: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10339: LD_EXP 47
10343: PPUSH
10344: CALL_OW 200
// time := 0 0$00 ;
10348: LD_ADDR_VAR 0 1
10352: PUSH
10353: LD_INT 0
10355: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10356: LD_INT 35
10358: PPUSH
10359: CALL_OW 67
// time := time + 0 0$1 ;
10363: LD_ADDR_VAR 0 1
10367: PUSH
10368: LD_VAR 0 1
10372: PUSH
10373: LD_INT 35
10375: PLUS
10376: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10377: LD_EXP 47
10381: PPUSH
10382: LD_INT 124
10384: PPUSH
10385: LD_INT 118
10387: PPUSH
10388: CALL_OW 307
10392: PUSH
10393: LD_VAR 0 1
10397: PUSH
10398: LD_INT 1050
10400: GREATEREQUAL
10401: OR
10402: IFFALSE 10356
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING DBelkov-Gny-1
10411: PPUSH
10412: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10416: LD_EXP 45
10420: PPUSH
10421: LD_STRING DBelkov-Bur-1a
10423: PPUSH
10424: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10428: LD_INT 35
10430: PPUSH
10431: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10435: LD_EXP 47
10439: PPUSH
10440: LD_INT 22
10442: PUSH
10443: LD_INT 7
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PPUSH
10450: CALL_OW 69
10454: PPUSH
10455: LD_EXP 47
10459: PPUSH
10460: CALL_OW 74
10464: PPUSH
10465: CALL_OW 296
10469: PUSH
10470: LD_INT 8
10472: LESS
10473: IFFALSE 10428
// SetSide ( Gnyevko , 7 ) ;
10475: LD_EXP 47
10479: PPUSH
10480: LD_INT 7
10482: PPUSH
10483: CALL_OW 235
// end ;
10487: PPOPN 1
10489: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10490: LD_EXP 45
10494: PPUSH
10495: CALL_OW 255
10499: PUSH
10500: LD_INT 7
10502: EQUAL
10503: IFFALSE 10513
10505: GO 10507
10507: DISABLE
// begin enable ;
10508: ENABLE
// PrepareAmericanAttack ;
10509: CALL 6336 0 0
// end ;
10513: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10514: LD_INT 22
10516: PUSH
10517: LD_INT 1
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PPUSH
10524: CALL_OW 69
10528: IFFALSE 10712
10530: GO 10532
10532: DISABLE
10533: LD_INT 0
10535: PPUSH
10536: PPUSH
// begin while true do
10537: LD_INT 1
10539: IFFALSE 10596
// begin wait ( 0 0$1 ) ;
10541: LD_INT 35
10543: PPUSH
10544: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10548: LD_ADDR_VAR 0 2
10552: PUSH
10553: LD_INT 22
10555: PUSH
10556: LD_INT 1
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: PPUSH
10563: CALL_OW 69
10567: PPUSH
10568: LD_EXP 14
10572: PPUSH
10573: CALL_OW 74
10577: ST_TO_ADDR
// if See ( 7 , tmp ) then
10578: LD_INT 7
10580: PPUSH
10581: LD_VAR 0 2
10585: PPUSH
10586: CALL_OW 292
10590: IFFALSE 10594
// break ;
10592: GO 10596
// end ;
10594: GO 10537
// DialogueOn ;
10596: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10609: LD_VAR 0 2
10613: PPUSH
10614: CALL_OW 250
10618: PPUSH
10619: LD_VAR 0 2
10623: PPUSH
10624: CALL_OW 251
10628: PPUSH
10629: LD_INT 7
10631: PPUSH
10632: LD_INT 8
10634: PPUSH
10635: CALL_OW 330
// if Denis then
10639: LD_EXP 20
10643: IFFALSE 10657
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10645: LD_EXP 20
10649: PPUSH
10650: LD_STRING DAmerAttack-Pet-1
10652: PPUSH
10653: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10657: LD_EXP 14
10661: PPUSH
10662: LD_STRING DAmerAttack-JMM-1
10664: PPUSH
10665: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10669: LD_EXP 45
10673: PPUSH
10674: LD_STRING DStop-Bur-1
10676: PPUSH
10677: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10681: LD_VAR 0 2
10685: PPUSH
10686: CALL_OW 250
10690: PPUSH
10691: LD_VAR 0 2
10695: PPUSH
10696: CALL_OW 251
10700: PPUSH
10701: LD_INT 7
10703: PPUSH
10704: CALL_OW 331
// DialogueOff ;
10708: CALL_OW 7
// end ;
10712: PPOPN 2
10714: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10715: LD_INT 22
10717: PUSH
10718: LD_INT 3
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: LD_INT 21
10727: PUSH
10728: LD_INT 1
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: PPUSH
10739: CALL_OW 69
10743: PUSH
10744: LD_INT 0
10746: EQUAL
10747: IFFALSE 10789
10749: GO 10751
10751: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10752: LD_STRING M5a
10754: PPUSH
10755: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10759: LD_EXP 14
10763: PPUSH
10764: LD_STRING D8-JMM-1
10766: PPUSH
10767: CALL_OW 88
// if Gossudarov then
10771: LD_EXP 31
10775: IFFALSE 10789
// Say ( Gossudarov , D8-Gos-1 ) ;
10777: LD_EXP 31
10781: PPUSH
10782: LD_STRING D8-Gos-1
10784: PPUSH
10785: CALL_OW 88
// end ;
10789: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10790: LD_INT 22
10792: PUSH
10793: LD_INT 2
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 21
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: PUSH
10819: LD_INT 0
10821: EQUAL
10822: IFFALSE 10872
10824: GO 10826
10826: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10827: LD_STRING M4c
10829: PPUSH
10830: CALL_OW 337
// if Roth then
10834: LD_EXP 15
10838: IFFALSE 10854
// Say ( Roth , DStop-Roth-1 ) else
10840: LD_EXP 15
10844: PPUSH
10845: LD_STRING DStop-Roth-1
10847: PPUSH
10848: CALL_OW 88
10852: GO 10872
// if Gossudarov then
10854: LD_EXP 31
10858: IFFALSE 10872
// Say ( Gossudarov , D8-Gos-1a ) ;
10860: LD_EXP 31
10864: PPUSH
10865: LD_STRING D8-Gos-1a
10867: PPUSH
10868: CALL_OW 88
// end ;
10872: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10873: LD_INT 7
10875: PPUSH
10876: LD_INT 1
10878: PPUSH
10879: LD_INT 1
10881: PPUSH
10882: CALL 13973 0 3
10886: PUSH
10887: LD_INT 0
10889: EQUAL
10890: PUSH
10891: LD_INT 7
10893: PPUSH
10894: LD_INT 3
10896: PPUSH
10897: LD_INT 1
10899: PPUSH
10900: CALL 13973 0 3
10904: PUSH
10905: LD_INT 0
10907: EQUAL
10908: AND
10909: IFFALSE 10921
10911: GO 10913
10913: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10914: LD_STRING M1a
10916: PPUSH
10917: CALL_OW 337
// end ;
10921: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10922: LD_INT 22
10924: PUSH
10925: LD_INT 2
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 1
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: LD_INT 0
10953: EQUAL
10954: PUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 69
10983: PUSH
10984: LD_INT 0
10986: EQUAL
10987: AND
10988: PUSH
10989: LD_INT 22
10991: PUSH
10992: LD_INT 1
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: LD_INT 0
11006: EQUAL
11007: AND
11008: PUSH
11009: LD_INT 7
11011: PPUSH
11012: LD_INT 1
11014: PPUSH
11015: LD_INT 1
11017: PPUSH
11018: CALL 13973 0 3
11022: PUSH
11023: LD_INT 0
11025: EQUAL
11026: AND
11027: PUSH
11028: LD_INT 7
11030: PPUSH
11031: LD_INT 3
11033: PPUSH
11034: LD_INT 1
11036: PPUSH
11037: CALL 13973 0 3
11041: PUSH
11042: LD_INT 0
11044: EQUAL
11045: AND
11046: IFFALSE 12390
11048: GO 11050
11050: DISABLE
11051: LD_INT 0
11053: PPUSH
11054: PPUSH
11055: PPUSH
// begin wait ( 0 0$3 ) ;
11056: LD_INT 105
11058: PPUSH
11059: CALL_OW 67
// if not IsDead ( Masha ) then
11063: LD_EXP 48
11067: PPUSH
11068: CALL_OW 301
11072: NOT
11073: IFFALSE 11087
// AddMedal ( Masha , 1 ) else
11075: LD_STRING Masha
11077: PPUSH
11078: LD_INT 1
11080: PPUSH
11081: CALL_OW 101
11085: GO 11098
// AddMedal ( Masha , - 1 ) ;
11087: LD_STRING Masha
11089: PPUSH
11090: LD_INT 1
11092: NEG
11093: PPUSH
11094: CALL_OW 101
// if abdul_escaped then
11098: LD_EXP 12
11102: IFFALSE 11117
// AddMedal ( Abdul , - 1 ) else
11104: LD_STRING Abdul
11106: PPUSH
11107: LD_INT 1
11109: NEG
11110: PPUSH
11111: CALL_OW 101
11115: GO 11127
// AddMedal ( Abdul , 1 ) ;
11117: LD_STRING Abdul
11119: PPUSH
11120: LD_INT 1
11122: PPUSH
11123: CALL_OW 101
// if loss_counter = 0 then
11127: LD_EXP 13
11131: PUSH
11132: LD_INT 0
11134: EQUAL
11135: IFFALSE 11149
// AddMedal ( People , 2 ) else
11137: LD_STRING People
11139: PPUSH
11140: LD_INT 2
11142: PPUSH
11143: CALL_OW 101
11147: GO 11199
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11149: LD_EXP 13
11153: PUSH
11154: LD_INT 3
11156: PUSH
11157: LD_INT 2
11159: PUSH
11160: LD_INT 2
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: PUSH
11168: LD_OWVAR 67
11172: ARRAY
11173: LESSEQUAL
11174: IFFALSE 11188
// AddMedal ( People , 1 ) else
11176: LD_STRING People
11178: PPUSH
11179: LD_INT 1
11181: PPUSH
11182: CALL_OW 101
11186: GO 11199
// AddMedal ( People , - 1 ) ;
11188: LD_STRING People
11190: PPUSH
11191: LD_INT 1
11193: NEG
11194: PPUSH
11195: CALL_OW 101
// GiveMedals ( MAIN ) ;
11199: LD_STRING MAIN
11201: PPUSH
11202: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11206: LD_ADDR_VAR 0 2
11210: PUSH
11211: LD_INT 22
11213: PUSH
11214: LD_INT 7
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: LD_INT 2
11223: PUSH
11224: LD_INT 25
11226: PUSH
11227: LD_INT 1
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 25
11236: PUSH
11237: LD_INT 2
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: LD_INT 25
11246: PUSH
11247: LD_INT 3
11249: PUSH
11250: EMPTY
11251: LIST
11252: LIST
11253: PUSH
11254: LD_INT 25
11256: PUSH
11257: LD_INT 4
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: PUSH
11264: LD_INT 25
11266: PUSH
11267: LD_INT 5
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 25
11276: PUSH
11277: LD_INT 8
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: PUSH
11284: LD_INT 25
11286: PUSH
11287: LD_INT 9
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PUSH
11304: EMPTY
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11313: LD_VAR 0 2
11317: PPUSH
11318: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11322: LD_ADDR_VAR 0 3
11326: PUSH
11327: LD_EXP 14
11331: PUSH
11332: LD_EXP 15
11336: PUSH
11337: LD_EXP 16
11341: PUSH
11342: LD_EXP 17
11346: PUSH
11347: LD_EXP 18
11351: PUSH
11352: LD_EXP 19
11356: PUSH
11357: LD_EXP 20
11361: PUSH
11362: LD_EXP 21
11366: PUSH
11367: LD_EXP 22
11371: PUSH
11372: LD_EXP 23
11376: PUSH
11377: LD_EXP 24
11381: PUSH
11382: LD_EXP 25
11386: PUSH
11387: LD_EXP 26
11391: PUSH
11392: LD_EXP 27
11396: PUSH
11397: LD_EXP 28
11401: PUSH
11402: LD_EXP 29
11406: PUSH
11407: LD_EXP 30
11411: PUSH
11412: LD_EXP 31
11416: PUSH
11417: LD_EXP 32
11421: PUSH
11422: LD_EXP 33
11426: PUSH
11427: LD_EXP 35
11431: PUSH
11432: LD_EXP 36
11436: PUSH
11437: LD_EXP 37
11441: PUSH
11442: LD_EXP 38
11446: PUSH
11447: LD_EXP 39
11451: PUSH
11452: LD_EXP 40
11456: PUSH
11457: LD_EXP 41
11461: PUSH
11462: LD_EXP 42
11466: PUSH
11467: LD_EXP 43
11471: PUSH
11472: LD_EXP 44
11476: PUSH
11477: LD_EXP 45
11481: PUSH
11482: LD_EXP 46
11486: PUSH
11487: LD_EXP 47
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: ST_TO_ADDR
// if tmp diff tmp2 then
11527: LD_VAR 0 2
11531: PUSH
11532: LD_VAR 0 3
11536: DIFF
11537: IFFALSE 11557
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11539: LD_VAR 0 2
11543: PUSH
11544: LD_VAR 0 3
11548: DIFF
11549: PPUSH
11550: LD_STRING 13a_others
11552: PPUSH
11553: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11557: LD_EXP 14
11561: PPUSH
11562: LD_STRING 13a_JMM
11564: PPUSH
11565: CALL_OW 38
// if Titov then
11569: LD_EXP 33
11573: IFFALSE 11587
// SaveCharacters ( Titov , 13a_Titov ) ;
11575: LD_EXP 33
11579: PPUSH
11580: LD_STRING 13a_Titov
11582: PPUSH
11583: CALL_OW 38
// if Dolgov then
11587: LD_EXP 35
11591: IFFALSE 11605
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11593: LD_EXP 35
11597: PPUSH
11598: LD_STRING 13a_Dolgov
11600: PPUSH
11601: CALL_OW 38
// if Petrosyan then
11605: LD_EXP 36
11609: IFFALSE 11623
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11611: LD_EXP 36
11615: PPUSH
11616: LD_STRING 13a_Petrosyan
11618: PPUSH
11619: CALL_OW 38
// if Scholtze then
11623: LD_EXP 37
11627: IFFALSE 11641
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11629: LD_EXP 37
11633: PPUSH
11634: LD_STRING 13a_Scholtze
11636: PPUSH
11637: CALL_OW 38
// if Oblukov then
11641: LD_EXP 38
11645: IFFALSE 11659
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11647: LD_EXP 38
11651: PPUSH
11652: LD_STRING 13a_Oblukov
11654: PPUSH
11655: CALL_OW 38
// if Kapitsova then
11659: LD_EXP 39
11663: IFFALSE 11677
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11665: LD_EXP 39
11669: PPUSH
11670: LD_STRING 13a_Kapitsova
11672: PPUSH
11673: CALL_OW 38
// if Lipshchin then
11677: LD_EXP 40
11681: IFFALSE 11695
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11683: LD_EXP 40
11687: PPUSH
11688: LD_STRING 13a_Lipshchin
11690: PPUSH
11691: CALL_OW 38
// if Petrovova then
11695: LD_EXP 41
11699: IFFALSE 11713
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11701: LD_EXP 41
11705: PPUSH
11706: LD_STRING 13a_Petrovova
11708: PPUSH
11709: CALL_OW 38
// if Kovalyuk then
11713: LD_EXP 42
11717: IFFALSE 11731
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11719: LD_EXP 42
11723: PPUSH
11724: LD_STRING 13a_Kovalyuk
11726: PPUSH
11727: CALL_OW 38
// if Kuzmov then
11731: LD_EXP 43
11735: IFFALSE 11749
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11737: LD_EXP 43
11741: PPUSH
11742: LD_STRING 13a_Kuzmov
11744: PPUSH
11745: CALL_OW 38
// if Karamazov then
11749: LD_EXP 44
11753: IFFALSE 11767
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11755: LD_EXP 44
11759: PPUSH
11760: LD_STRING 13a_Karamazov
11762: PPUSH
11763: CALL_OW 38
// if Burlak then
11767: LD_EXP 45
11771: IFFALSE 11785
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11773: LD_EXP 45
11777: PPUSH
11778: LD_STRING 13a_Burlak
11780: PPUSH
11781: CALL_OW 38
// if Belkov then
11785: LD_EXP 46
11789: IFFALSE 11803
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11791: LD_EXP 46
11795: PPUSH
11796: LD_STRING 13a_Belkov
11798: PPUSH
11799: CALL_OW 38
// if Gnyevko then
11803: LD_EXP 47
11807: IFFALSE 11821
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11809: LD_EXP 47
11813: PPUSH
11814: LD_STRING 13a_Gnyevko
11816: PPUSH
11817: CALL_OW 38
// if Lisa then
11821: LD_EXP 16
11825: IFFALSE 11839
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11827: LD_EXP 16
11831: PPUSH
11832: LD_STRING 13a_Lisa
11834: PPUSH
11835: CALL_OW 38
// if Donaldson then
11839: LD_EXP 17
11843: IFFALSE 11857
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11845: LD_EXP 17
11849: PPUSH
11850: LD_STRING 13a_Donaldson
11852: PPUSH
11853: CALL_OW 38
// if Bobby then
11857: LD_EXP 18
11861: IFFALSE 11875
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11863: LD_EXP 18
11867: PPUSH
11868: LD_STRING 13a_Bobby
11870: PPUSH
11871: CALL_OW 38
// if Cyrus then
11875: LD_EXP 19
11879: IFFALSE 11893
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11881: LD_EXP 19
11885: PPUSH
11886: LD_STRING 13a_Cyrus
11888: PPUSH
11889: CALL_OW 38
// if Denis then
11893: LD_EXP 20
11897: IFFALSE 11911
// SaveCharacters ( Denis , 13a_Denis ) ;
11899: LD_EXP 20
11903: PPUSH
11904: LD_STRING 13a_Denis
11906: PPUSH
11907: CALL_OW 38
// if Brown then
11911: LD_EXP 21
11915: IFFALSE 11929
// SaveCharacters ( Brown , 13a_Brown ) ;
11917: LD_EXP 21
11921: PPUSH
11922: LD_STRING 13a_Brown
11924: PPUSH
11925: CALL_OW 38
// if Gladstone then
11929: LD_EXP 22
11933: IFFALSE 11947
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11935: LD_EXP 22
11939: PPUSH
11940: LD_STRING 13a_Gladstone
11942: PPUSH
11943: CALL_OW 38
// if Houten then
11947: LD_EXP 23
11951: IFFALSE 11965
// SaveCharacters ( Houten , 13a_Houten ) ;
11953: LD_EXP 23
11957: PPUSH
11958: LD_STRING 13a_Houten
11960: PPUSH
11961: CALL_OW 38
// if Cornel then
11965: LD_EXP 24
11969: IFFALSE 11983
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11971: LD_EXP 24
11975: PPUSH
11976: LD_STRING 13a_Cornel
11978: PPUSH
11979: CALL_OW 38
// if Gary then
11983: LD_EXP 25
11987: IFFALSE 12001
// SaveCharacters ( Gary , 13a_Gary ) ;
11989: LD_EXP 25
11993: PPUSH
11994: LD_STRING 13a_Gary
11996: PPUSH
11997: CALL_OW 38
// if Frank then
12001: LD_EXP 26
12005: IFFALSE 12019
// SaveCharacters ( Frank , 13a_Frank ) ;
12007: LD_EXP 26
12011: PPUSH
12012: LD_STRING 13a_Frank
12014: PPUSH
12015: CALL_OW 38
// if Kikuchi then
12019: LD_EXP 27
12023: IFFALSE 12037
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12025: LD_EXP 27
12029: PPUSH
12030: LD_STRING 13a_Kikuchi
12032: PPUSH
12033: CALL_OW 38
// if Simms then
12037: LD_EXP 28
12041: IFFALSE 12055
// SaveCharacters ( Simms , 13a_Simms ) ;
12043: LD_EXP 28
12047: PPUSH
12048: LD_STRING 13a_Simms
12050: PPUSH
12051: CALL_OW 38
// if Joan then
12055: LD_EXP 29
12059: IFFALSE 12073
// SaveCharacters ( Joan , 13a_Joan ) ;
12061: LD_EXP 29
12065: PPUSH
12066: LD_STRING 13a_Joan
12068: PPUSH
12069: CALL_OW 38
// if DeltaDoctor then
12073: LD_EXP 30
12077: IFFALSE 12091
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12079: LD_EXP 30
12083: PPUSH
12084: LD_STRING 13a_DeltaDoctor
12086: PPUSH
12087: CALL_OW 38
// if Gossudarov then
12091: LD_EXP 31
12095: IFFALSE 12109
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12097: LD_EXP 31
12101: PPUSH
12102: LD_STRING 13a_Gossudarov
12104: PPUSH
12105: CALL_OW 38
// if Kirilenkova then
12109: LD_EXP 32
12113: IFFALSE 12127
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12115: LD_EXP 32
12119: PPUSH
12120: LD_STRING 13a_Kirilenkova
12122: PPUSH
12123: CALL_OW 38
// if Masha then
12127: LD_EXP 48
12131: IFFALSE 12186
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12133: LD_EXP 48
12137: PPUSH
12138: CALL_OW 265
12142: PUSH
12143: LD_EXP 48
12147: PPUSH
12148: CALL_OW 262
12152: PUSH
12153: LD_EXP 48
12157: PPUSH
12158: CALL_OW 263
12162: PUSH
12163: LD_EXP 48
12167: PPUSH
12168: CALL_OW 264
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: PPUSH
12179: LD_STRING 13a_Masha
12181: PPUSH
12182: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12186: LD_ADDR_VAR 0 2
12190: PUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 69
12205: ST_TO_ADDR
// tmp2 := [ ] ;
12206: LD_ADDR_VAR 0 3
12210: PUSH
12211: EMPTY
12212: ST_TO_ADDR
// if tmp then
12213: LD_VAR 0 2
12217: IFFALSE 12368
// for i in tmp do
12219: LD_ADDR_VAR 0 1
12223: PUSH
12224: LD_VAR 0 2
12228: PUSH
12229: FOR_IN
12230: IFFALSE 12366
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12232: LD_ADDR_VAR 0 3
12236: PUSH
12237: LD_VAR 0 3
12241: PUSH
12242: LD_VAR 0 1
12246: PPUSH
12247: CALL_OW 255
12251: PUSH
12252: LD_VAR 0 1
12256: PPUSH
12257: CALL_OW 248
12261: PUSH
12262: LD_VAR 0 1
12266: PPUSH
12267: CALL_OW 266
12271: PUSH
12272: LD_VAR 0 1
12276: PPUSH
12277: CALL_OW 250
12281: PUSH
12282: LD_VAR 0 1
12286: PPUSH
12287: CALL_OW 251
12291: PUSH
12292: LD_VAR 0 1
12296: PPUSH
12297: CALL_OW 254
12301: PUSH
12302: LD_VAR 0 1
12306: PPUSH
12307: CALL_OW 267
12311: PUSH
12312: LD_VAR 0 1
12316: PPUSH
12317: LD_INT 1
12319: PPUSH
12320: CALL_OW 268
12324: PUSH
12325: LD_VAR 0 1
12329: PPUSH
12330: LD_INT 2
12332: PPUSH
12333: CALL_OW 268
12337: PUSH
12338: LD_VAR 0 1
12342: PPUSH
12343: CALL_OW 269
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: ADD
12363: ST_TO_ADDR
12364: GO 12229
12366: POP
12367: POP
// if tmp2 then
12368: LD_VAR 0 3
12372: IFFALSE 12386
// SaveVariable ( tmp2 , 13a_buildings ) ;
12374: LD_VAR 0 3
12378: PPUSH
12379: LD_STRING 13a_buildings
12381: PPUSH
12382: CALL_OW 39
// YouWin ;
12386: CALL_OW 103
// end ;
12390: PPOPN 3
12392: END
// export function SciRu ; var tmp , t ; begin
12393: LD_INT 0
12395: PPUSH
12396: PPUSH
12397: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_EXP 31
12407: PUSH
12408: LD_EXP 45
12412: PUSH
12413: LD_EXP 33
12417: PUSH
12418: LD_EXP 46
12422: PUSH
12423: LD_EXP 47
12427: PUSH
12428: LD_EXP 36
12432: PUSH
12433: LD_EXP 37
12437: PUSH
12438: LD_EXP 35
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12453: LD_ADDR_VAR 0 2
12457: PUSH
12458: LD_INT 22
12460: PUSH
12461: LD_INT 7
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PUSH
12468: LD_INT 23
12470: PUSH
12471: LD_INT 3
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 25
12480: PUSH
12481: LD_INT 4
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 26
12490: PUSH
12491: LD_INT 1
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: PPUSH
12504: CALL_OW 69
12508: PUSH
12509: LD_VAR 0 3
12513: DIFF
12514: ST_TO_ADDR
// if tmp then
12515: LD_VAR 0 2
12519: IFFALSE 12535
// result := tmp [ 1 ] ;
12521: LD_ADDR_VAR 0 1
12525: PUSH
12526: LD_VAR 0 2
12530: PUSH
12531: LD_INT 1
12533: ARRAY
12534: ST_TO_ADDR
// end ;
12535: LD_VAR 0 1
12539: RET
// export function SolRu ; var tmp , t ; begin
12540: LD_INT 0
12542: PPUSH
12543: PPUSH
12544: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12545: LD_ADDR_VAR 0 3
12549: PUSH
12550: LD_EXP 31
12554: PUSH
12555: LD_EXP 45
12559: PUSH
12560: LD_EXP 33
12564: PUSH
12565: LD_EXP 46
12569: PUSH
12570: LD_EXP 47
12574: PUSH
12575: LD_EXP 36
12579: PUSH
12580: LD_EXP 37
12584: PUSH
12585: LD_EXP 35
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12600: LD_ADDR_VAR 0 2
12604: PUSH
12605: LD_INT 22
12607: PUSH
12608: LD_INT 7
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 23
12617: PUSH
12618: LD_INT 3
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 25
12627: PUSH
12628: LD_INT 1
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: LD_INT 26
12637: PUSH
12638: LD_INT 1
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PPUSH
12651: CALL_OW 69
12655: PUSH
12656: LD_VAR 0 3
12660: DIFF
12661: ST_TO_ADDR
// if tmp then
12662: LD_VAR 0 2
12666: IFFALSE 12682
// result := tmp [ 1 ] ;
12668: LD_ADDR_VAR 0 1
12672: PUSH
12673: LD_VAR 0 2
12677: PUSH
12678: LD_INT 1
12680: ARRAY
12681: ST_TO_ADDR
// end ; end_of_file
12682: LD_VAR 0 1
12686: RET
// export function CustomEvent ( event ) ; begin
12687: LD_INT 0
12689: PPUSH
// end ;
12690: LD_VAR 0 2
12694: RET
// on UnitDestroyed ( un ) do var i , side ;
12695: LD_INT 0
12697: PPUSH
12698: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12699: LD_VAR 0 1
12703: PUSH
12704: LD_INT 22
12706: PUSH
12707: LD_INT 7
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: PUSH
12714: LD_INT 2
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 1
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 25
12729: PUSH
12730: LD_INT 2
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 25
12739: PUSH
12740: LD_INT 3
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 25
12749: PUSH
12750: LD_INT 4
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: LD_INT 25
12759: PUSH
12760: LD_INT 5
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PUSH
12767: LD_INT 25
12769: PUSH
12770: LD_INT 8
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 25
12779: PUSH
12780: LD_INT 9
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: IN
12806: IFFALSE 12822
// loss_counter := loss_counter + 1 ;
12808: LD_ADDR_EXP 13
12812: PUSH
12813: LD_EXP 13
12817: PUSH
12818: LD_INT 1
12820: PLUS
12821: ST_TO_ADDR
// if un = Abdul then
12822: LD_VAR 0 1
12826: PUSH
12827: LD_EXP 54
12831: EQUAL
12832: IFFALSE 12842
// abdul_escaped := false ;
12834: LD_ADDR_EXP 12
12838: PUSH
12839: LD_INT 0
12841: ST_TO_ADDR
// if un in ru_attackers then
12842: LD_VAR 0 1
12846: PUSH
12847: LD_EXP 51
12851: IN
12852: IFFALSE 12870
// ru_attackers := ru_attackers diff un ;
12854: LD_ADDR_EXP 51
12858: PUSH
12859: LD_EXP 51
12863: PUSH
12864: LD_VAR 0 1
12868: DIFF
12869: ST_TO_ADDR
// if un in ar_attackers then
12870: LD_VAR 0 1
12874: PUSH
12875: LD_EXP 10
12879: IN
12880: IFFALSE 12898
// ar_attackers := ar_attackers diff un ;
12882: LD_ADDR_EXP 10
12886: PUSH
12887: LD_EXP 10
12891: PUSH
12892: LD_VAR 0 1
12896: DIFF
12897: ST_TO_ADDR
// if un = JMM then
12898: LD_VAR 0 1
12902: PUSH
12903: LD_EXP 14
12907: EQUAL
12908: IFFALSE 12919
// begin YouLost ( JMM ) ;
12910: LD_STRING JMM
12912: PPUSH
12913: CALL_OW 104
// exit ;
12917: GO 13008
// end ; if un = Burlak then
12919: LD_VAR 0 1
12923: PUSH
12924: LD_EXP 45
12928: EQUAL
12929: IFFALSE 12940
// begin YouLost ( Burlak ) ;
12931: LD_STRING Burlak
12933: PPUSH
12934: CALL_OW 104
// exit ;
12938: GO 13008
// end ; if un = freedom then
12940: LD_VAR 0 1
12944: PUSH
12945: LD_EXP 3
12949: EQUAL
12950: IFFALSE 12961
// begin YouLost ( Destroyed ) ;
12952: LD_STRING Destroyed
12954: PPUSH
12955: CALL_OW 104
// exit ;
12959: GO 13008
// end ; if un = Masha then
12961: LD_VAR 0 1
12965: PUSH
12966: LD_EXP 48
12970: EQUAL
12971: IFFALSE 12980
// ChangeMissionObjectives ( M4b ) ;
12973: LD_STRING M4b
12975: PPUSH
12976: CALL_OW 337
// if un = Mastodont then
12980: LD_VAR 0 1
12984: PUSH
12985: LD_EXP 55
12989: EQUAL
12990: IFFALSE 12999
// ChangeMissionObjectives ( M4a ) ;
12992: LD_STRING M4a
12994: PPUSH
12995: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12999: LD_VAR 0 1
13003: PPUSH
13004: CALL 82091 0 1
// end ;
13008: PPOPN 3
13010: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13011: LD_VAR 0 1
13015: PPUSH
13016: LD_VAR 0 2
13020: PPUSH
13021: CALL 84070 0 2
// end ;
13025: PPOPN 2
13027: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13028: LD_VAR 0 1
13032: PPUSH
13033: CALL 83138 0 1
// end ;
13037: PPOPN 1
13039: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13040: LD_VAR 0 1
13044: PUSH
13045: LD_INT 22
13047: PUSH
13048: LD_INT 7
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PUSH
13055: LD_INT 30
13057: PUSH
13058: LD_INT 0
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PPUSH
13069: CALL_OW 69
13073: IN
13074: IFFALSE 13113
// begin SetBName ( building , freedom ) ;
13076: LD_VAR 0 1
13080: PPUSH
13081: LD_STRING freedom
13083: PPUSH
13084: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13088: LD_INT 0
13090: PPUSH
13091: LD_INT 7
13093: PPUSH
13094: LD_INT 0
13096: PPUSH
13097: CALL_OW 324
// freedom := building ;
13101: LD_ADDR_EXP 3
13105: PUSH
13106: LD_VAR 0 1
13110: ST_TO_ADDR
// exit ;
13111: GO 13179
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13113: LD_VAR 0 1
13117: PUSH
13118: LD_INT 22
13120: PUSH
13121: LD_INT 7
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 23
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 30
13140: PUSH
13141: LD_INT 6
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: PPUSH
13153: CALL_OW 69
13157: IN
13158: IFFALSE 13170
// begin ru_lab_builded := true ;
13160: LD_ADDR_EXP 5
13164: PUSH
13165: LD_INT 1
13167: ST_TO_ADDR
// exit ;
13168: GO 13179
// end ; MCE_BuildingComplete ( building ) ;
13170: LD_VAR 0 1
13174: PPUSH
13175: CALL 83379 0 1
// end ;
13179: PPOPN 1
13181: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13182: LD_VAR 0 1
13186: PPUSH
13187: LD_VAR 0 2
13191: PPUSH
13192: CALL 81787 0 2
// end ;
13196: PPOPN 2
13198: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13199: LD_VAR 0 1
13203: PPUSH
13204: LD_VAR 0 2
13208: PPUSH
13209: LD_VAR 0 3
13213: PPUSH
13214: LD_VAR 0 4
13218: PPUSH
13219: LD_VAR 0 5
13223: PPUSH
13224: CALL 81407 0 5
// end ;
13228: PPOPN 5
13230: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13231: LD_VAR 0 1
13235: PPUSH
13236: LD_VAR 0 2
13240: PPUSH
13241: CALL 80997 0 2
// end ;
13245: PPOPN 2
13247: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13248: LD_VAR 0 1
13252: PPUSH
13253: LD_VAR 0 2
13257: PPUSH
13258: LD_VAR 0 3
13262: PPUSH
13263: LD_VAR 0 4
13267: PPUSH
13268: CALL 80835 0 4
// end ;
13272: PPOPN 4
13274: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: LD_VAR 0 2
13284: PPUSH
13285: LD_VAR 0 3
13289: PPUSH
13290: CALL 80610 0 3
// end ;
13294: PPOPN 3
13296: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13297: LD_VAR 0 1
13301: PPUSH
13302: LD_VAR 0 2
13306: PPUSH
13307: CALL 80495 0 2
// end ;
13311: PPOPN 2
13313: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13314: LD_VAR 0 1
13318: PPUSH
13319: LD_VAR 0 2
13323: PPUSH
13324: CALL 84331 0 2
// end ;
13328: PPOPN 2
13330: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13331: LD_VAR 0 1
13335: PPUSH
13336: LD_VAR 0 2
13340: PPUSH
13341: LD_VAR 0 3
13345: PPUSH
13346: LD_VAR 0 4
13350: PPUSH
13351: CALL 84547 0 4
// end ;
13355: PPOPN 4
13357: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13358: LD_VAR 0 1
13362: PPUSH
13363: LD_VAR 0 2
13367: PPUSH
13368: CALL 80304 0 2
// end ; end_of_file
13372: PPOPN 2
13374: END
// every 0 0$30 do var cr , time ;
13375: GO 13377
13377: DISABLE
13378: LD_INT 0
13380: PPUSH
13381: PPUSH
// begin time := 0 0$30 ;
13382: LD_ADDR_VAR 0 2
13386: PUSH
13387: LD_INT 1050
13389: ST_TO_ADDR
// while game do
13390: LD_EXP 2
13394: IFFALSE 13493
// begin wait ( time ) ;
13396: LD_VAR 0 2
13400: PPUSH
13401: CALL_OW 67
// if tick > 2 2$00 then
13405: LD_OWVAR 1
13409: PUSH
13410: LD_INT 4200
13412: GREATER
13413: IFFALSE 13446
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13415: LD_ADDR_VAR 0 2
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_INT 280
13427: PUSH
13428: LD_INT 420
13430: PUSH
13431: LD_INT 630
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: LIST
13438: PUSH
13439: LD_OWVAR 67
13443: ARRAY
13444: PLUS
13445: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13446: LD_INT 1
13448: PPUSH
13449: LD_INT 5
13451: PPUSH
13452: CALL_OW 12
13456: PPUSH
13457: LD_INT 70
13459: PPUSH
13460: LD_INT 49
13462: PPUSH
13463: LD_INT 25
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 56
// if time > 5 5$00 then
13473: LD_VAR 0 2
13477: PUSH
13478: LD_INT 10500
13480: GREATER
13481: IFFALSE 13491
// time := 0 0$30 ;
13483: LD_ADDR_VAR 0 2
13487: PUSH
13488: LD_INT 1050
13490: ST_TO_ADDR
// end ;
13491: GO 13390
// end ;
13493: PPOPN 2
13495: END
// every 0 0$30 do var cr , time ;
13496: GO 13498
13498: DISABLE
13499: LD_INT 0
13501: PPUSH
13502: PPUSH
// begin time := 0 0$20 ;
13503: LD_ADDR_VAR 0 2
13507: PUSH
13508: LD_INT 700
13510: ST_TO_ADDR
// while game do
13511: LD_EXP 2
13515: IFFALSE 13604
// begin wait ( time ) ;
13517: LD_VAR 0 2
13521: PPUSH
13522: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13526: LD_ADDR_VAR 0 2
13530: PUSH
13531: LD_VAR 0 2
13535: PUSH
13536: LD_INT 490
13538: PUSH
13539: LD_INT 525
13541: PUSH
13542: LD_INT 560
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: LIST
13549: PUSH
13550: LD_OWVAR 67
13554: ARRAY
13555: PLUS
13556: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13557: LD_INT 3
13559: PPUSH
13560: LD_INT 5
13562: PPUSH
13563: CALL_OW 12
13567: PPUSH
13568: LD_INT 26
13570: PPUSH
13571: LD_INT 9
13573: PPUSH
13574: LD_INT 30
13576: PPUSH
13577: LD_INT 1
13579: PPUSH
13580: CALL_OW 56
// if time > 3 3$00 then
13584: LD_VAR 0 2
13588: PUSH
13589: LD_INT 6300
13591: GREATER
13592: IFFALSE 13602
// time := 0 0$20 ;
13594: LD_ADDR_VAR 0 2
13598: PUSH
13599: LD_INT 700
13601: ST_TO_ADDR
// end ;
13602: GO 13511
// end ;
13604: PPOPN 2
13606: END
// every 0 0$30 do var cr , time ;
13607: GO 13609
13609: DISABLE
13610: LD_INT 0
13612: PPUSH
13613: PPUSH
// begin time := 0 0$20 ;
13614: LD_ADDR_VAR 0 2
13618: PUSH
13619: LD_INT 700
13621: ST_TO_ADDR
// while game do
13622: LD_EXP 2
13626: IFFALSE 13751
// begin wait ( time ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13637: LD_ADDR_VAR 0 2
13641: PUSH
13642: LD_VAR 0 2
13646: PUSH
13647: LD_INT 175
13649: PUSH
13650: LD_INT 210
13652: PUSH
13653: LD_INT 280
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: PUSH
13661: LD_OWVAR 67
13665: ARRAY
13666: PLUS
13667: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13668: LD_INT 1
13670: PPUSH
13671: LD_INT 5
13673: PPUSH
13674: CALL_OW 12
13678: PPUSH
13679: LD_INT 179
13681: PPUSH
13682: LD_INT 101
13684: PPUSH
13685: LD_INT 20
13687: PPUSH
13688: LD_INT 1
13690: PPUSH
13691: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13695: LD_INT 350
13697: PPUSH
13698: LD_INT 525
13700: PPUSH
13701: CALL_OW 12
13705: PPUSH
13706: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13710: LD_INT 1
13712: PPUSH
13713: LD_INT 5
13715: PPUSH
13716: CALL_OW 12
13720: PPUSH
13721: LD_INT 9
13723: PPUSH
13724: LD_INT 1
13726: PPUSH
13727: CALL_OW 55
// if time > 4 4$00 then
13731: LD_VAR 0 2
13735: PUSH
13736: LD_INT 8400
13738: GREATER
13739: IFFALSE 13749
// time := 0 0$30 ;
13741: LD_ADDR_VAR 0 2
13745: PUSH
13746: LD_INT 1050
13748: ST_TO_ADDR
// end ;
13749: GO 13622
// end ;
13751: PPOPN 2
13753: END
// every 0 0$30 do var cr , time ;
13754: GO 13756
13756: DISABLE
13757: LD_INT 0
13759: PPUSH
13760: PPUSH
// begin time := 0 0$10 ;
13761: LD_ADDR_VAR 0 2
13765: PUSH
13766: LD_INT 350
13768: ST_TO_ADDR
// while game do
13769: LD_EXP 2
13773: IFFALSE 13907
// begin wait ( time ) ;
13775: LD_VAR 0 2
13779: PPUSH
13780: CALL_OW 67
// time := time + 0 0$10 ;
13784: LD_ADDR_VAR 0 2
13788: PUSH
13789: LD_VAR 0 2
13793: PUSH
13794: LD_INT 350
13796: PLUS
13797: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13798: LD_INT 1
13800: PPUSH
13801: LD_INT 5
13803: PPUSH
13804: CALL_OW 12
13808: PPUSH
13809: LD_INT 11
13811: PPUSH
13812: LD_INT 1
13814: PPUSH
13815: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13819: LD_ADDR_VAR 0 1
13823: PUSH
13824: LD_INT 1
13826: PPUSH
13827: LD_INT 3
13829: PPUSH
13830: CALL_OW 12
13834: ST_TO_ADDR
// if cr = 1 then
13835: LD_VAR 0 1
13839: PUSH
13840: LD_INT 1
13842: EQUAL
13843: IFFALSE 13887
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13845: LD_INT 700
13847: PPUSH
13848: LD_INT 1575
13850: PPUSH
13851: CALL_OW 12
13855: PPUSH
13856: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13860: LD_INT 1
13862: PPUSH
13863: LD_INT 5
13865: PPUSH
13866: CALL_OW 12
13870: PPUSH
13871: LD_INT 34
13873: PPUSH
13874: LD_INT 50
13876: PPUSH
13877: LD_INT 7
13879: PPUSH
13880: LD_INT 1
13882: PPUSH
13883: CALL_OW 56
// end ; if time > 8 8$00 then
13887: LD_VAR 0 2
13891: PUSH
13892: LD_INT 16800
13894: GREATER
13895: IFFALSE 13905
// time := 0 0$40 ;
13897: LD_ADDR_VAR 0 2
13901: PUSH
13902: LD_INT 1400
13904: ST_TO_ADDR
// end ;
13905: GO 13769
// end ; end_of_file
13907: PPOPN 2
13909: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13910: LD_INT 0
13912: PPUSH
13913: PPUSH
// if exist_mode then
13914: LD_VAR 0 2
13918: IFFALSE 13943
// unit := CreateCharacter ( prefix & ident ) else
13920: LD_ADDR_VAR 0 5
13924: PUSH
13925: LD_VAR 0 3
13929: PUSH
13930: LD_VAR 0 1
13934: STR
13935: PPUSH
13936: CALL_OW 34
13940: ST_TO_ADDR
13941: GO 13958
// unit := NewCharacter ( ident ) ;
13943: LD_ADDR_VAR 0 5
13947: PUSH
13948: LD_VAR 0 1
13952: PPUSH
13953: CALL_OW 25
13957: ST_TO_ADDR
// result := unit ;
13958: LD_ADDR_VAR 0 4
13962: PUSH
13963: LD_VAR 0 5
13967: ST_TO_ADDR
// end ;
13968: LD_VAR 0 4
13972: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13973: LD_INT 0
13975: PPUSH
13976: PPUSH
// if not side or not nation then
13977: LD_VAR 0 1
13981: NOT
13982: PUSH
13983: LD_VAR 0 2
13987: NOT
13988: OR
13989: IFFALSE 13993
// exit ;
13991: GO 14629
// case nation of nation_american :
13993: LD_VAR 0 2
13997: PUSH
13998: LD_INT 1
14000: DOUBLE
14001: EQUAL
14002: IFTRUE 14006
14004: GO 14176
14006: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
14007: LD_ADDR_VAR 0 4
14011: PUSH
14012: LD_INT 35
14014: PUSH
14015: LD_INT 45
14017: PUSH
14018: LD_INT 46
14020: PUSH
14021: LD_INT 47
14023: PUSH
14024: LD_INT 1
14026: PUSH
14027: LD_INT 2
14029: PUSH
14030: LD_INT 6
14032: PUSH
14033: LD_INT 15
14035: PUSH
14036: LD_INT 16
14038: PUSH
14039: LD_INT 7
14041: PUSH
14042: LD_INT 12
14044: PUSH
14045: LD_INT 13
14047: PUSH
14048: LD_INT 10
14050: PUSH
14051: LD_INT 14
14053: PUSH
14054: LD_INT 20
14056: PUSH
14057: LD_INT 21
14059: PUSH
14060: LD_INT 22
14062: PUSH
14063: LD_INT 25
14065: PUSH
14066: LD_INT 32
14068: PUSH
14069: LD_INT 27
14071: PUSH
14072: LD_INT 36
14074: PUSH
14075: LD_INT 69
14077: PUSH
14078: LD_INT 39
14080: PUSH
14081: LD_INT 34
14083: PUSH
14084: LD_INT 40
14086: PUSH
14087: LD_INT 48
14089: PUSH
14090: LD_INT 49
14092: PUSH
14093: LD_INT 50
14095: PUSH
14096: LD_INT 51
14098: PUSH
14099: LD_INT 52
14101: PUSH
14102: LD_INT 53
14104: PUSH
14105: LD_INT 54
14107: PUSH
14108: LD_INT 55
14110: PUSH
14111: LD_INT 56
14113: PUSH
14114: LD_INT 57
14116: PUSH
14117: LD_INT 58
14119: PUSH
14120: LD_INT 59
14122: PUSH
14123: LD_INT 60
14125: PUSH
14126: LD_INT 61
14128: PUSH
14129: LD_INT 62
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: ST_TO_ADDR
14174: GO 14553
14176: LD_INT 2
14178: DOUBLE
14179: EQUAL
14180: IFTRUE 14184
14182: GO 14362
14184: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14185: LD_ADDR_VAR 0 4
14189: PUSH
14190: LD_INT 35
14192: PUSH
14193: LD_INT 45
14195: PUSH
14196: LD_INT 46
14198: PUSH
14199: LD_INT 47
14201: PUSH
14202: LD_INT 70
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: LD_INT 11
14210: PUSH
14211: LD_INT 3
14213: PUSH
14214: LD_INT 4
14216: PUSH
14217: LD_INT 5
14219: PUSH
14220: LD_INT 6
14222: PUSH
14223: LD_INT 15
14225: PUSH
14226: LD_INT 18
14228: PUSH
14229: LD_INT 7
14231: PUSH
14232: LD_INT 17
14234: PUSH
14235: LD_INT 8
14237: PUSH
14238: LD_INT 20
14240: PUSH
14241: LD_INT 21
14243: PUSH
14244: LD_INT 22
14246: PUSH
14247: LD_INT 72
14249: PUSH
14250: LD_INT 26
14252: PUSH
14253: LD_INT 69
14255: PUSH
14256: LD_INT 39
14258: PUSH
14259: LD_INT 40
14261: PUSH
14262: LD_INT 41
14264: PUSH
14265: LD_INT 42
14267: PUSH
14268: LD_INT 43
14270: PUSH
14271: LD_INT 48
14273: PUSH
14274: LD_INT 49
14276: PUSH
14277: LD_INT 50
14279: PUSH
14280: LD_INT 51
14282: PUSH
14283: LD_INT 52
14285: PUSH
14286: LD_INT 53
14288: PUSH
14289: LD_INT 54
14291: PUSH
14292: LD_INT 55
14294: PUSH
14295: LD_INT 56
14297: PUSH
14298: LD_INT 60
14300: PUSH
14301: LD_INT 61
14303: PUSH
14304: LD_INT 62
14306: PUSH
14307: LD_INT 66
14309: PUSH
14310: LD_INT 67
14312: PUSH
14313: LD_INT 68
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: ST_TO_ADDR
14360: GO 14553
14362: LD_INT 3
14364: DOUBLE
14365: EQUAL
14366: IFTRUE 14370
14368: GO 14552
14370: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14371: LD_ADDR_VAR 0 4
14375: PUSH
14376: LD_INT 46
14378: PUSH
14379: LD_INT 47
14381: PUSH
14382: LD_INT 1
14384: PUSH
14385: LD_INT 2
14387: PUSH
14388: LD_INT 11
14390: PUSH
14391: LD_INT 9
14393: PUSH
14394: LD_INT 20
14396: PUSH
14397: LD_INT 19
14399: PUSH
14400: LD_INT 21
14402: PUSH
14403: LD_INT 24
14405: PUSH
14406: LD_INT 22
14408: PUSH
14409: LD_INT 25
14411: PUSH
14412: LD_INT 28
14414: PUSH
14415: LD_INT 29
14417: PUSH
14418: LD_INT 30
14420: PUSH
14421: LD_INT 31
14423: PUSH
14424: LD_INT 37
14426: PUSH
14427: LD_INT 38
14429: PUSH
14430: LD_INT 32
14432: PUSH
14433: LD_INT 27
14435: PUSH
14436: LD_INT 33
14438: PUSH
14439: LD_INT 69
14441: PUSH
14442: LD_INT 39
14444: PUSH
14445: LD_INT 34
14447: PUSH
14448: LD_INT 40
14450: PUSH
14451: LD_INT 71
14453: PUSH
14454: LD_INT 23
14456: PUSH
14457: LD_INT 44
14459: PUSH
14460: LD_INT 48
14462: PUSH
14463: LD_INT 49
14465: PUSH
14466: LD_INT 50
14468: PUSH
14469: LD_INT 51
14471: PUSH
14472: LD_INT 52
14474: PUSH
14475: LD_INT 53
14477: PUSH
14478: LD_INT 54
14480: PUSH
14481: LD_INT 55
14483: PUSH
14484: LD_INT 56
14486: PUSH
14487: LD_INT 57
14489: PUSH
14490: LD_INT 58
14492: PUSH
14493: LD_INT 59
14495: PUSH
14496: LD_INT 63
14498: PUSH
14499: LD_INT 64
14501: PUSH
14502: LD_INT 65
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: ST_TO_ADDR
14550: GO 14553
14552: POP
// if state > - 1 and state < 3 then
14553: LD_VAR 0 3
14557: PUSH
14558: LD_INT 1
14560: NEG
14561: GREATER
14562: PUSH
14563: LD_VAR 0 3
14567: PUSH
14568: LD_INT 3
14570: LESS
14571: AND
14572: IFFALSE 14629
// for i in result do
14574: LD_ADDR_VAR 0 5
14578: PUSH
14579: LD_VAR 0 4
14583: PUSH
14584: FOR_IN
14585: IFFALSE 14627
// if GetTech ( i , side ) <> state then
14587: LD_VAR 0 5
14591: PPUSH
14592: LD_VAR 0 1
14596: PPUSH
14597: CALL_OW 321
14601: PUSH
14602: LD_VAR 0 3
14606: NONEQUAL
14607: IFFALSE 14625
// result := result diff i ;
14609: LD_ADDR_VAR 0 4
14613: PUSH
14614: LD_VAR 0 4
14618: PUSH
14619: LD_VAR 0 5
14623: DIFF
14624: ST_TO_ADDR
14625: GO 14584
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 4
14633: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14634: LD_INT 0
14636: PPUSH
14637: PPUSH
14638: PPUSH
// result := true ;
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 1
14646: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14647: LD_ADDR_VAR 0 5
14651: PUSH
14652: LD_VAR 0 2
14656: PPUSH
14657: CALL_OW 480
14661: ST_TO_ADDR
// if not tmp then
14662: LD_VAR 0 5
14666: NOT
14667: IFFALSE 14671
// exit ;
14669: GO 14720
// for i in tmp do
14671: LD_ADDR_VAR 0 4
14675: PUSH
14676: LD_VAR 0 5
14680: PUSH
14681: FOR_IN
14682: IFFALSE 14718
// if GetTech ( i , side ) <> state_researched then
14684: LD_VAR 0 4
14688: PPUSH
14689: LD_VAR 0 1
14693: PPUSH
14694: CALL_OW 321
14698: PUSH
14699: LD_INT 2
14701: NONEQUAL
14702: IFFALSE 14716
// begin result := false ;
14704: LD_ADDR_VAR 0 3
14708: PUSH
14709: LD_INT 0
14711: ST_TO_ADDR
// exit ;
14712: POP
14713: POP
14714: GO 14720
// end ;
14716: GO 14681
14718: POP
14719: POP
// end ;
14720: LD_VAR 0 3
14724: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14725: LD_INT 0
14727: PPUSH
14728: PPUSH
14729: PPUSH
14730: PPUSH
14731: PPUSH
14732: PPUSH
14733: PPUSH
14734: PPUSH
14735: PPUSH
14736: PPUSH
14737: PPUSH
14738: PPUSH
14739: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14740: LD_VAR 0 1
14744: NOT
14745: PUSH
14746: LD_VAR 0 1
14750: PPUSH
14751: CALL_OW 257
14755: PUSH
14756: LD_INT 9
14758: NONEQUAL
14759: OR
14760: IFFALSE 14764
// exit ;
14762: GO 15337
// side := GetSide ( unit ) ;
14764: LD_ADDR_VAR 0 9
14768: PUSH
14769: LD_VAR 0 1
14773: PPUSH
14774: CALL_OW 255
14778: ST_TO_ADDR
// tech_space := tech_spacanom ;
14779: LD_ADDR_VAR 0 12
14783: PUSH
14784: LD_INT 29
14786: ST_TO_ADDR
// tech_time := tech_taurad ;
14787: LD_ADDR_VAR 0 13
14791: PUSH
14792: LD_INT 28
14794: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14795: LD_ADDR_VAR 0 11
14799: PUSH
14800: LD_VAR 0 1
14804: PPUSH
14805: CALL_OW 310
14809: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14810: LD_VAR 0 11
14814: PPUSH
14815: CALL_OW 247
14819: PUSH
14820: LD_INT 2
14822: EQUAL
14823: IFFALSE 14827
// exit ;
14825: GO 15337
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14827: LD_ADDR_VAR 0 8
14831: PUSH
14832: LD_INT 81
14834: PUSH
14835: LD_VAR 0 9
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 3
14846: PUSH
14847: LD_INT 21
14849: PUSH
14850: LD_INT 3
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PPUSH
14865: CALL_OW 69
14869: ST_TO_ADDR
// if not tmp then
14870: LD_VAR 0 8
14874: NOT
14875: IFFALSE 14879
// exit ;
14877: GO 15337
// if in_unit then
14879: LD_VAR 0 11
14883: IFFALSE 14907
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14885: LD_ADDR_VAR 0 10
14889: PUSH
14890: LD_VAR 0 8
14894: PPUSH
14895: LD_VAR 0 11
14899: PPUSH
14900: CALL_OW 74
14904: ST_TO_ADDR
14905: GO 14927
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14907: LD_ADDR_VAR 0 10
14911: PUSH
14912: LD_VAR 0 8
14916: PPUSH
14917: LD_VAR 0 1
14921: PPUSH
14922: CALL_OW 74
14926: ST_TO_ADDR
// if not enemy then
14927: LD_VAR 0 10
14931: NOT
14932: IFFALSE 14936
// exit ;
14934: GO 15337
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14936: LD_VAR 0 11
14940: PUSH
14941: LD_VAR 0 11
14945: PPUSH
14946: LD_VAR 0 10
14950: PPUSH
14951: CALL_OW 296
14955: PUSH
14956: LD_INT 13
14958: GREATER
14959: AND
14960: PUSH
14961: LD_VAR 0 1
14965: PPUSH
14966: LD_VAR 0 10
14970: PPUSH
14971: CALL_OW 296
14975: PUSH
14976: LD_INT 12
14978: GREATER
14979: OR
14980: IFFALSE 14984
// exit ;
14982: GO 15337
// missile := [ 1 ] ;
14984: LD_ADDR_VAR 0 14
14988: PUSH
14989: LD_INT 1
14991: PUSH
14992: EMPTY
14993: LIST
14994: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14995: LD_VAR 0 9
14999: PPUSH
15000: LD_VAR 0 12
15004: PPUSH
15005: CALL_OW 325
15009: IFFALSE 15038
// missile := Insert ( missile , missile + 1 , 2 ) ;
15011: LD_ADDR_VAR 0 14
15015: PUSH
15016: LD_VAR 0 14
15020: PPUSH
15021: LD_VAR 0 14
15025: PUSH
15026: LD_INT 1
15028: PLUS
15029: PPUSH
15030: LD_INT 2
15032: PPUSH
15033: CALL_OW 2
15037: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15038: LD_VAR 0 9
15042: PPUSH
15043: LD_VAR 0 13
15047: PPUSH
15048: CALL_OW 325
15052: PUSH
15053: LD_VAR 0 10
15057: PPUSH
15058: CALL_OW 255
15062: PPUSH
15063: LD_VAR 0 13
15067: PPUSH
15068: CALL_OW 325
15072: NOT
15073: AND
15074: IFFALSE 15103
// missile := Insert ( missile , missile + 1 , 3 ) ;
15076: LD_ADDR_VAR 0 14
15080: PUSH
15081: LD_VAR 0 14
15085: PPUSH
15086: LD_VAR 0 14
15090: PUSH
15091: LD_INT 1
15093: PLUS
15094: PPUSH
15095: LD_INT 3
15097: PPUSH
15098: CALL_OW 2
15102: ST_TO_ADDR
// if missile < 2 then
15103: LD_VAR 0 14
15107: PUSH
15108: LD_INT 2
15110: LESS
15111: IFFALSE 15115
// exit ;
15113: GO 15337
// x := GetX ( enemy ) ;
15115: LD_ADDR_VAR 0 4
15119: PUSH
15120: LD_VAR 0 10
15124: PPUSH
15125: CALL_OW 250
15129: ST_TO_ADDR
// y := GetY ( enemy ) ;
15130: LD_ADDR_VAR 0 5
15134: PUSH
15135: LD_VAR 0 10
15139: PPUSH
15140: CALL_OW 251
15144: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15145: LD_ADDR_VAR 0 6
15149: PUSH
15150: LD_VAR 0 4
15154: PUSH
15155: LD_INT 1
15157: NEG
15158: PPUSH
15159: LD_INT 1
15161: PPUSH
15162: CALL_OW 12
15166: PLUS
15167: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15168: LD_ADDR_VAR 0 7
15172: PUSH
15173: LD_VAR 0 5
15177: PUSH
15178: LD_INT 1
15180: NEG
15181: PPUSH
15182: LD_INT 1
15184: PPUSH
15185: CALL_OW 12
15189: PLUS
15190: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15191: LD_VAR 0 6
15195: PPUSH
15196: LD_VAR 0 7
15200: PPUSH
15201: CALL_OW 488
15205: NOT
15206: IFFALSE 15228
// begin _x := x ;
15208: LD_ADDR_VAR 0 6
15212: PUSH
15213: LD_VAR 0 4
15217: ST_TO_ADDR
// _y := y ;
15218: LD_ADDR_VAR 0 7
15222: PUSH
15223: LD_VAR 0 5
15227: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15228: LD_ADDR_VAR 0 3
15232: PUSH
15233: LD_INT 1
15235: PPUSH
15236: LD_VAR 0 14
15240: PPUSH
15241: CALL_OW 12
15245: ST_TO_ADDR
// case i of 1 :
15246: LD_VAR 0 3
15250: PUSH
15251: LD_INT 1
15253: DOUBLE
15254: EQUAL
15255: IFTRUE 15259
15257: GO 15276
15259: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15260: LD_VAR 0 1
15264: PPUSH
15265: LD_VAR 0 10
15269: PPUSH
15270: CALL_OW 115
15274: GO 15337
15276: LD_INT 2
15278: DOUBLE
15279: EQUAL
15280: IFTRUE 15284
15282: GO 15306
15284: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15285: LD_VAR 0 1
15289: PPUSH
15290: LD_VAR 0 6
15294: PPUSH
15295: LD_VAR 0 7
15299: PPUSH
15300: CALL_OW 153
15304: GO 15337
15306: LD_INT 3
15308: DOUBLE
15309: EQUAL
15310: IFTRUE 15314
15312: GO 15336
15314: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_VAR 0 6
15324: PPUSH
15325: LD_VAR 0 7
15329: PPUSH
15330: CALL_OW 154
15334: GO 15337
15336: POP
// end ;
15337: LD_VAR 0 2
15341: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15342: LD_INT 0
15344: PPUSH
15345: PPUSH
15346: PPUSH
15347: PPUSH
15348: PPUSH
15349: PPUSH
// if not unit or not building then
15350: LD_VAR 0 1
15354: NOT
15355: PUSH
15356: LD_VAR 0 2
15360: NOT
15361: OR
15362: IFFALSE 15366
// exit ;
15364: GO 15524
// x := GetX ( building ) ;
15366: LD_ADDR_VAR 0 5
15370: PUSH
15371: LD_VAR 0 2
15375: PPUSH
15376: CALL_OW 250
15380: ST_TO_ADDR
// y := GetY ( building ) ;
15381: LD_ADDR_VAR 0 6
15385: PUSH
15386: LD_VAR 0 2
15390: PPUSH
15391: CALL_OW 251
15395: ST_TO_ADDR
// for i = 0 to 5 do
15396: LD_ADDR_VAR 0 4
15400: PUSH
15401: DOUBLE
15402: LD_INT 0
15404: DEC
15405: ST_TO_ADDR
15406: LD_INT 5
15408: PUSH
15409: FOR_TO
15410: IFFALSE 15522
// begin _x := ShiftX ( x , i , 3 ) ;
15412: LD_ADDR_VAR 0 7
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_VAR 0 4
15426: PPUSH
15427: LD_INT 3
15429: PPUSH
15430: CALL_OW 272
15434: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15435: LD_ADDR_VAR 0 8
15439: PUSH
15440: LD_VAR 0 6
15444: PPUSH
15445: LD_VAR 0 4
15449: PPUSH
15450: LD_INT 3
15452: PPUSH
15453: CALL_OW 273
15457: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15458: LD_VAR 0 7
15462: PPUSH
15463: LD_VAR 0 8
15467: PPUSH
15468: CALL_OW 488
15472: NOT
15473: IFFALSE 15477
// continue ;
15475: GO 15409
// if HexInfo ( _x , _y ) = 0 then
15477: LD_VAR 0 7
15481: PPUSH
15482: LD_VAR 0 8
15486: PPUSH
15487: CALL_OW 428
15491: PUSH
15492: LD_INT 0
15494: EQUAL
15495: IFFALSE 15520
// begin ComMoveXY ( unit , _x , _y ) ;
15497: LD_VAR 0 1
15501: PPUSH
15502: LD_VAR 0 7
15506: PPUSH
15507: LD_VAR 0 8
15511: PPUSH
15512: CALL_OW 111
// exit ;
15516: POP
15517: POP
15518: GO 15524
// end ; end ;
15520: GO 15409
15522: POP
15523: POP
// end ;
15524: LD_VAR 0 3
15528: RET
// export function ScanBase ( side , base_area ) ; begin
15529: LD_INT 0
15531: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15532: LD_ADDR_VAR 0 3
15536: PUSH
15537: LD_VAR 0 2
15541: PPUSH
15542: LD_INT 81
15544: PUSH
15545: LD_VAR 0 1
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 70
15558: ST_TO_ADDR
// end ;
15559: LD_VAR 0 3
15563: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15564: LD_INT 0
15566: PPUSH
15567: PPUSH
15568: PPUSH
15569: PPUSH
15570: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15571: LD_VAR 0 1
15575: NOT
15576: PUSH
15577: LD_EXP 58
15581: PUSH
15582: LD_VAR 0 1
15586: ARRAY
15587: NOT
15588: OR
15589: PUSH
15590: LD_VAR 0 2
15594: NOT
15595: OR
15596: PUSH
15597: LD_VAR 0 3
15601: NOT
15602: OR
15603: IFFALSE 15607
// exit ;
15605: GO 16057
// side := mc_sides [ base ] ;
15607: LD_ADDR_VAR 0 6
15611: PUSH
15612: LD_EXP 84
15616: PUSH
15617: LD_VAR 0 1
15621: ARRAY
15622: ST_TO_ADDR
// if not side then
15623: LD_VAR 0 6
15627: NOT
15628: IFFALSE 15632
// exit ;
15630: GO 16057
// for i in solds do
15632: LD_ADDR_VAR 0 7
15636: PUSH
15637: LD_VAR 0 2
15641: PUSH
15642: FOR_IN
15643: IFFALSE 15704
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15645: LD_VAR 0 7
15649: PPUSH
15650: CALL_OW 310
15654: PPUSH
15655: CALL_OW 266
15659: PUSH
15660: LD_INT 32
15662: PUSH
15663: LD_INT 31
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: IN
15670: IFFALSE 15690
// solds := solds diff i else
15672: LD_ADDR_VAR 0 2
15676: PUSH
15677: LD_VAR 0 2
15681: PUSH
15682: LD_VAR 0 7
15686: DIFF
15687: ST_TO_ADDR
15688: GO 15702
// SetTag ( i , 18 ) ;
15690: LD_VAR 0 7
15694: PPUSH
15695: LD_INT 18
15697: PPUSH
15698: CALL_OW 109
15702: GO 15642
15704: POP
15705: POP
// if not solds then
15706: LD_VAR 0 2
15710: NOT
15711: IFFALSE 15715
// exit ;
15713: GO 16057
// repeat wait ( 0 0$1 ) ;
15715: LD_INT 35
15717: PPUSH
15718: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15722: LD_ADDR_VAR 0 5
15726: PUSH
15727: LD_VAR 0 6
15731: PPUSH
15732: LD_VAR 0 3
15736: PPUSH
15737: CALL 15529 0 2
15741: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15742: LD_VAR 0 5
15746: NOT
15747: PUSH
15748: LD_VAR 0 5
15752: PUSH
15753: LD_INT 3
15755: GREATER
15756: OR
15757: PUSH
15758: LD_EXP 80
15762: PUSH
15763: LD_VAR 0 1
15767: ARRAY
15768: OR
15769: IFFALSE 15810
// begin for i in solds do
15771: LD_ADDR_VAR 0 7
15775: PUSH
15776: LD_VAR 0 2
15780: PUSH
15781: FOR_IN
15782: IFFALSE 15806
// if HasTask ( i ) then
15784: LD_VAR 0 7
15788: PPUSH
15789: CALL_OW 314
15793: IFFALSE 15804
// ComStop ( i ) ;
15795: LD_VAR 0 7
15799: PPUSH
15800: CALL_OW 141
15804: GO 15781
15806: POP
15807: POP
// break ;
15808: GO 16045
// end ; for i in solds do
15810: LD_ADDR_VAR 0 7
15814: PUSH
15815: LD_VAR 0 2
15819: PUSH
15820: FOR_IN
15821: IFFALSE 16037
// begin if IsInUnit ( i ) then
15823: LD_VAR 0 7
15827: PPUSH
15828: CALL_OW 310
15832: IFFALSE 15843
// ComExitBuilding ( i ) ;
15834: LD_VAR 0 7
15838: PPUSH
15839: CALL_OW 122
// if GetLives ( i ) > 333 then
15843: LD_VAR 0 7
15847: PPUSH
15848: CALL_OW 256
15852: PUSH
15853: LD_INT 333
15855: GREATER
15856: IFFALSE 15884
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15858: LD_VAR 0 7
15862: PPUSH
15863: LD_VAR 0 5
15867: PPUSH
15868: LD_VAR 0 7
15872: PPUSH
15873: CALL_OW 74
15877: PPUSH
15878: CALL_OW 115
15882: GO 16035
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15884: LD_ADDR_VAR 0 8
15888: PUSH
15889: LD_EXP 58
15893: PUSH
15894: LD_VAR 0 1
15898: ARRAY
15899: PPUSH
15900: LD_INT 2
15902: PUSH
15903: LD_INT 30
15905: PUSH
15906: LD_INT 0
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 30
15915: PUSH
15916: LD_INT 1
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: PUSH
15923: LD_INT 30
15925: PUSH
15926: LD_INT 6
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 72
15943: PPUSH
15944: LD_VAR 0 7
15948: PPUSH
15949: CALL_OW 74
15953: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15954: LD_VAR 0 7
15958: PPUSH
15959: LD_VAR 0 8
15963: PPUSH
15964: CALL_OW 250
15968: PPUSH
15969: LD_INT 3
15971: PPUSH
15972: LD_INT 5
15974: PPUSH
15975: CALL_OW 272
15979: PPUSH
15980: LD_VAR 0 8
15984: PPUSH
15985: CALL_OW 251
15989: PPUSH
15990: LD_INT 3
15992: PPUSH
15993: LD_INT 5
15995: PPUSH
15996: CALL_OW 273
16000: PPUSH
16001: CALL_OW 111
// SetTag ( i , 0 ) ;
16005: LD_VAR 0 7
16009: PPUSH
16010: LD_INT 0
16012: PPUSH
16013: CALL_OW 109
// solds := solds diff i ;
16017: LD_ADDR_VAR 0 2
16021: PUSH
16022: LD_VAR 0 2
16026: PUSH
16027: LD_VAR 0 7
16031: DIFF
16032: ST_TO_ADDR
// continue ;
16033: GO 15820
// end ; end ;
16035: GO 15820
16037: POP
16038: POP
// until solds ;
16039: LD_VAR 0 2
16043: IFFALSE 15715
// MC_Reset ( base , 18 ) ;
16045: LD_VAR 0 1
16049: PPUSH
16050: LD_INT 18
16052: PPUSH
16053: CALL 59555 0 2
// end ;
16057: LD_VAR 0 4
16061: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16062: LD_INT 0
16064: PPUSH
16065: PPUSH
16066: PPUSH
16067: PPUSH
16068: PPUSH
16069: PPUSH
16070: PPUSH
16071: PPUSH
16072: PPUSH
16073: PPUSH
16074: PPUSH
16075: PPUSH
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16080: LD_ADDR_VAR 0 12
16084: PUSH
16085: LD_EXP 58
16089: PUSH
16090: LD_VAR 0 1
16094: ARRAY
16095: PPUSH
16096: LD_INT 25
16098: PUSH
16099: LD_INT 3
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PPUSH
16106: CALL_OW 72
16110: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16111: LD_ADDR_VAR 0 8
16115: PUSH
16116: LD_EXP 58
16120: PUSH
16121: LD_VAR 0 1
16125: ARRAY
16126: PPUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 25
16132: PUSH
16133: LD_INT 1
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 25
16142: PUSH
16143: LD_INT 5
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PUSH
16150: LD_INT 25
16152: PUSH
16153: LD_INT 8
16155: PUSH
16156: EMPTY
16157: LIST
16158: LIST
16159: PUSH
16160: LD_INT 25
16162: PUSH
16163: LD_INT 9
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: PUSH
16170: EMPTY
16171: LIST
16172: LIST
16173: LIST
16174: LIST
16175: LIST
16176: PPUSH
16177: CALL_OW 72
16181: ST_TO_ADDR
// if not defenders and not solds then
16182: LD_VAR 0 2
16186: NOT
16187: PUSH
16188: LD_VAR 0 8
16192: NOT
16193: AND
16194: IFFALSE 16198
// exit ;
16196: GO 17564
// depot_under_attack := false ;
16198: LD_ADDR_VAR 0 16
16202: PUSH
16203: LD_INT 0
16205: ST_TO_ADDR
// sold_defenders := [ ] ;
16206: LD_ADDR_VAR 0 17
16210: PUSH
16211: EMPTY
16212: ST_TO_ADDR
// if mechs then
16213: LD_VAR 0 12
16217: IFFALSE 16346
// for i in defenders do
16219: LD_ADDR_VAR 0 5
16223: PUSH
16224: LD_VAR 0 2
16228: PUSH
16229: FOR_IN
16230: IFFALSE 16344
// begin SetTag ( i , 20 ) ;
16232: LD_VAR 0 5
16236: PPUSH
16237: LD_INT 20
16239: PPUSH
16240: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16244: LD_VAR 0 5
16248: PPUSH
16249: CALL_OW 263
16253: PUSH
16254: LD_INT 1
16256: EQUAL
16257: PUSH
16258: LD_VAR 0 5
16262: PPUSH
16263: CALL_OW 311
16267: NOT
16268: AND
16269: PUSH
16270: LD_VAR 0 12
16274: AND
16275: IFFALSE 16342
// begin un := mechs [ 1 ] ;
16277: LD_ADDR_VAR 0 10
16281: PUSH
16282: LD_VAR 0 12
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16291: LD_VAR 0 10
16295: PPUSH
16296: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16300: LD_VAR 0 10
16304: PPUSH
16305: LD_VAR 0 5
16309: PPUSH
16310: CALL_OW 180
// SetTag ( un , 19 ) ;
16314: LD_VAR 0 10
16318: PPUSH
16319: LD_INT 19
16321: PPUSH
16322: CALL_OW 109
// mechs := mechs diff un ;
16326: LD_ADDR_VAR 0 12
16330: PUSH
16331: LD_VAR 0 12
16335: PUSH
16336: LD_VAR 0 10
16340: DIFF
16341: ST_TO_ADDR
// end ; end ;
16342: GO 16229
16344: POP
16345: POP
// if solds then
16346: LD_VAR 0 8
16350: IFFALSE 16409
// for i in solds do
16352: LD_ADDR_VAR 0 5
16356: PUSH
16357: LD_VAR 0 8
16361: PUSH
16362: FOR_IN
16363: IFFALSE 16407
// if not GetTag ( i ) then
16365: LD_VAR 0 5
16369: PPUSH
16370: CALL_OW 110
16374: NOT
16375: IFFALSE 16405
// begin defenders := defenders union i ;
16377: LD_ADDR_VAR 0 2
16381: PUSH
16382: LD_VAR 0 2
16386: PUSH
16387: LD_VAR 0 5
16391: UNION
16392: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16393: LD_VAR 0 5
16397: PPUSH
16398: LD_INT 18
16400: PPUSH
16401: CALL_OW 109
// end ;
16405: GO 16362
16407: POP
16408: POP
// repeat wait ( 0 0$1 ) ;
16409: LD_INT 35
16411: PPUSH
16412: CALL_OW 67
// enemy := mc_scan [ base ] ;
16416: LD_ADDR_VAR 0 3
16420: PUSH
16421: LD_EXP 81
16425: PUSH
16426: LD_VAR 0 1
16430: ARRAY
16431: ST_TO_ADDR
// for i in defenders do
16432: LD_ADDR_VAR 0 5
16436: PUSH
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_IN
16443: IFFALSE 17128
// begin e := NearestUnitToUnit ( enemy , i ) ;
16445: LD_ADDR_VAR 0 13
16449: PUSH
16450: LD_VAR 0 3
16454: PPUSH
16455: LD_VAR 0 5
16459: PPUSH
16460: CALL_OW 74
16464: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16465: LD_ADDR_VAR 0 16
16469: PUSH
16470: LD_EXP 58
16474: PUSH
16475: LD_VAR 0 1
16479: ARRAY
16480: PPUSH
16481: LD_INT 2
16483: PUSH
16484: LD_INT 30
16486: PUSH
16487: LD_INT 0
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: LD_INT 30
16496: PUSH
16497: LD_INT 1
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: LIST
16508: PPUSH
16509: CALL_OW 72
16513: NOT
16514: PUSH
16515: LD_EXP 58
16519: PUSH
16520: LD_VAR 0 1
16524: ARRAY
16525: PPUSH
16526: LD_INT 2
16528: PUSH
16529: LD_INT 30
16531: PUSH
16532: LD_INT 0
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PUSH
16539: LD_INT 30
16541: PUSH
16542: LD_INT 1
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: PPUSH
16554: CALL_OW 72
16558: PPUSH
16559: CALL_OW 256
16563: PUSH
16564: LD_INT 600
16566: LESS
16567: OR
16568: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16569: LD_VAR 0 5
16573: PPUSH
16574: CALL_OW 247
16578: PUSH
16579: LD_INT 2
16581: DOUBLE
16582: EQUAL
16583: IFTRUE 16587
16585: GO 16834
16587: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16588: LD_VAR 0 5
16592: PPUSH
16593: CALL_OW 256
16597: PUSH
16598: LD_INT 650
16600: GREATER
16601: PUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: LD_VAR 0 13
16611: PPUSH
16612: CALL_OW 296
16616: PUSH
16617: LD_INT 40
16619: LESS
16620: AND
16621: IFFALSE 16639
// ComAttackUnit ( i , e ) else
16623: LD_VAR 0 5
16627: PPUSH
16628: LD_VAR 0 13
16632: PPUSH
16633: CALL_OW 115
16637: GO 16717
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16639: LD_VAR 0 5
16643: PPUSH
16644: LD_VAR 0 13
16648: PPUSH
16649: CALL_OW 296
16653: PUSH
16654: LD_INT 30
16656: GREATEREQUAL
16657: PUSH
16658: LD_VAR 0 5
16662: PPUSH
16663: CALL_OW 256
16667: PUSH
16668: LD_INT 650
16670: LESSEQUAL
16671: OR
16672: PUSH
16673: LD_VAR 0 5
16677: PPUSH
16678: LD_EXP 82
16682: PUSH
16683: LD_VAR 0 1
16687: ARRAY
16688: PPUSH
16689: CALL_OW 308
16693: NOT
16694: AND
16695: IFFALSE 16717
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16697: LD_VAR 0 5
16701: PPUSH
16702: LD_EXP 82
16706: PUSH
16707: LD_VAR 0 1
16711: ARRAY
16712: PPUSH
16713: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16717: LD_VAR 0 5
16721: PPUSH
16722: CALL_OW 256
16726: PUSH
16727: LD_INT 998
16729: LESS
16730: PUSH
16731: LD_VAR 0 5
16735: PPUSH
16736: CALL_OW 263
16740: PUSH
16741: LD_INT 1
16743: EQUAL
16744: AND
16745: PUSH
16746: LD_VAR 0 5
16750: PPUSH
16751: CALL_OW 311
16755: AND
16756: PUSH
16757: LD_VAR 0 5
16761: PPUSH
16762: LD_EXP 82
16766: PUSH
16767: LD_VAR 0 1
16771: ARRAY
16772: PPUSH
16773: CALL_OW 308
16777: AND
16778: IFFALSE 16832
// begin mech := IsDrivenBy ( i ) ;
16780: LD_ADDR_VAR 0 9
16784: PUSH
16785: LD_VAR 0 5
16789: PPUSH
16790: CALL_OW 311
16794: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16795: LD_VAR 0 9
16799: PPUSH
16800: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16804: LD_VAR 0 9
16808: PPUSH
16809: LD_VAR 0 5
16813: PPUSH
16814: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16818: LD_VAR 0 9
16822: PPUSH
16823: LD_VAR 0 5
16827: PPUSH
16828: CALL_OW 180
// end ; end ; unit_human :
16832: GO 17099
16834: LD_INT 1
16836: DOUBLE
16837: EQUAL
16838: IFTRUE 16842
16840: GO 17098
16842: POP
// begin b := IsInUnit ( i ) ;
16843: LD_ADDR_VAR 0 18
16847: PUSH
16848: LD_VAR 0 5
16852: PPUSH
16853: CALL_OW 310
16857: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16858: LD_ADDR_VAR 0 19
16862: PUSH
16863: LD_VAR 0 18
16867: NOT
16868: PUSH
16869: LD_VAR 0 18
16873: PPUSH
16874: CALL_OW 266
16878: PUSH
16879: LD_INT 32
16881: PUSH
16882: LD_INT 31
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: IN
16889: OR
16890: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16891: LD_VAR 0 16
16895: PUSH
16896: LD_VAR 0 2
16900: PPUSH
16901: LD_INT 21
16903: PUSH
16904: LD_INT 2
16906: PUSH
16907: EMPTY
16908: LIST
16909: LIST
16910: PPUSH
16911: CALL_OW 72
16915: PUSH
16916: LD_INT 1
16918: LESSEQUAL
16919: OR
16920: PUSH
16921: LD_VAR 0 19
16925: AND
16926: PUSH
16927: LD_VAR 0 5
16931: PUSH
16932: LD_VAR 0 17
16936: IN
16937: NOT
16938: AND
16939: IFFALSE 17032
// begin if b then
16941: LD_VAR 0 18
16945: IFFALSE 16994
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16947: LD_VAR 0 18
16951: PPUSH
16952: LD_VAR 0 3
16956: PPUSH
16957: LD_VAR 0 18
16961: PPUSH
16962: CALL_OW 74
16966: PPUSH
16967: CALL_OW 296
16971: PUSH
16972: LD_INT 10
16974: LESS
16975: PUSH
16976: LD_VAR 0 18
16980: PPUSH
16981: CALL_OW 461
16985: PUSH
16986: LD_INT 7
16988: NONEQUAL
16989: AND
16990: IFFALSE 16994
// continue ;
16992: GO 16442
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16994: LD_ADDR_VAR 0 17
16998: PUSH
16999: LD_VAR 0 17
17003: PPUSH
17004: LD_VAR 0 17
17008: PUSH
17009: LD_INT 1
17011: PLUS
17012: PPUSH
17013: LD_VAR 0 5
17017: PPUSH
17018: CALL_OW 1
17022: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17023: LD_VAR 0 5
17027: PPUSH
17028: CALL_OW 122
// end ; if sold_defenders then
17032: LD_VAR 0 17
17036: IFFALSE 17096
// if i in sold_defenders then
17038: LD_VAR 0 5
17042: PUSH
17043: LD_VAR 0 17
17047: IN
17048: IFFALSE 17096
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17050: LD_VAR 0 5
17054: PPUSH
17055: CALL_OW 314
17059: NOT
17060: PUSH
17061: LD_VAR 0 5
17065: PPUSH
17066: LD_VAR 0 13
17070: PPUSH
17071: CALL_OW 296
17075: PUSH
17076: LD_INT 30
17078: LESS
17079: AND
17080: IFFALSE 17096
// ComAttackUnit ( i , e ) ;
17082: LD_VAR 0 5
17086: PPUSH
17087: LD_VAR 0 13
17091: PPUSH
17092: CALL_OW 115
// end ; end ; end ;
17096: GO 17099
17098: POP
// if IsDead ( i ) then
17099: LD_VAR 0 5
17103: PPUSH
17104: CALL_OW 301
17108: IFFALSE 17126
// defenders := defenders diff i ;
17110: LD_ADDR_VAR 0 2
17114: PUSH
17115: LD_VAR 0 2
17119: PUSH
17120: LD_VAR 0 5
17124: DIFF
17125: ST_TO_ADDR
// end ;
17126: GO 16442
17128: POP
17129: POP
// until not enemy or not defenders ;
17130: LD_VAR 0 3
17134: NOT
17135: PUSH
17136: LD_VAR 0 2
17140: NOT
17141: OR
17142: IFFALSE 16409
// MC_Reset ( base , 18 ) ;
17144: LD_VAR 0 1
17148: PPUSH
17149: LD_INT 18
17151: PPUSH
17152: CALL 59555 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17156: LD_ADDR_VAR 0 2
17160: PUSH
17161: LD_VAR 0 2
17165: PUSH
17166: LD_VAR 0 2
17170: PPUSH
17171: LD_INT 2
17173: PUSH
17174: LD_INT 25
17176: PUSH
17177: LD_INT 1
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 25
17186: PUSH
17187: LD_INT 5
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 25
17196: PUSH
17197: LD_INT 8
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 25
17206: PUSH
17207: LD_INT 9
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: PPUSH
17221: CALL_OW 72
17225: DIFF
17226: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17227: LD_VAR 0 3
17231: NOT
17232: PUSH
17233: LD_VAR 0 2
17237: PPUSH
17238: LD_INT 21
17240: PUSH
17241: LD_INT 2
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 72
17252: AND
17253: IFFALSE 17515
// begin tmp := FilterByTag ( defenders , 19 ) ;
17255: LD_ADDR_VAR 0 11
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_INT 19
17267: PPUSH
17268: CALL 53862 0 2
17272: ST_TO_ADDR
// if tmp then
17273: LD_VAR 0 11
17277: IFFALSE 17347
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17279: LD_ADDR_VAR 0 11
17283: PUSH
17284: LD_VAR 0 11
17288: PPUSH
17289: LD_INT 25
17291: PUSH
17292: LD_INT 3
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PPUSH
17299: CALL_OW 72
17303: ST_TO_ADDR
// if tmp then
17304: LD_VAR 0 11
17308: IFFALSE 17347
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17310: LD_ADDR_EXP 70
17314: PUSH
17315: LD_EXP 70
17319: PPUSH
17320: LD_VAR 0 1
17324: PPUSH
17325: LD_EXP 70
17329: PUSH
17330: LD_VAR 0 1
17334: ARRAY
17335: PUSH
17336: LD_VAR 0 11
17340: UNION
17341: PPUSH
17342: CALL_OW 1
17346: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17347: LD_VAR 0 1
17351: PPUSH
17352: LD_INT 19
17354: PPUSH
17355: CALL 59555 0 2
// repeat wait ( 0 0$1 ) ;
17359: LD_INT 35
17361: PPUSH
17362: CALL_OW 67
// for i in defenders do
17366: LD_ADDR_VAR 0 5
17370: PUSH
17371: LD_VAR 0 2
17375: PUSH
17376: FOR_IN
17377: IFFALSE 17466
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17379: LD_VAR 0 5
17383: PPUSH
17384: LD_EXP 82
17388: PUSH
17389: LD_VAR 0 1
17393: ARRAY
17394: PPUSH
17395: CALL_OW 308
17399: NOT
17400: IFFALSE 17424
// ComMoveToArea ( i , mc_parking [ base ] ) else
17402: LD_VAR 0 5
17406: PPUSH
17407: LD_EXP 82
17411: PUSH
17412: LD_VAR 0 1
17416: ARRAY
17417: PPUSH
17418: CALL_OW 113
17422: GO 17464
// if GetControl ( i ) = control_manual then
17424: LD_VAR 0 5
17428: PPUSH
17429: CALL_OW 263
17433: PUSH
17434: LD_INT 1
17436: EQUAL
17437: IFFALSE 17464
// if IsDrivenBy ( i ) then
17439: LD_VAR 0 5
17443: PPUSH
17444: CALL_OW 311
17448: IFFALSE 17464
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17450: LD_VAR 0 5
17454: PPUSH
17455: CALL_OW 311
17459: PPUSH
17460: CALL_OW 121
// end ;
17464: GO 17376
17466: POP
17467: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17468: LD_VAR 0 2
17472: PPUSH
17473: LD_INT 95
17475: PUSH
17476: LD_EXP 82
17480: PUSH
17481: LD_VAR 0 1
17485: ARRAY
17486: PUSH
17487: EMPTY
17488: LIST
17489: LIST
17490: PPUSH
17491: CALL_OW 72
17495: PUSH
17496: LD_VAR 0 2
17500: EQUAL
17501: PUSH
17502: LD_EXP 81
17506: PUSH
17507: LD_VAR 0 1
17511: ARRAY
17512: OR
17513: IFFALSE 17359
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17515: LD_ADDR_EXP 80
17519: PUSH
17520: LD_EXP 80
17524: PPUSH
17525: LD_VAR 0 1
17529: PPUSH
17530: LD_EXP 80
17534: PUSH
17535: LD_VAR 0 1
17539: ARRAY
17540: PUSH
17541: LD_VAR 0 2
17545: UNION
17546: PPUSH
17547: CALL_OW 1
17551: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17552: LD_VAR 0 1
17556: PPUSH
17557: LD_INT 20
17559: PPUSH
17560: CALL 59555 0 2
// end ;
17564: LD_VAR 0 4
17568: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17569: LD_INT 0
17571: PPUSH
17572: PPUSH
17573: PPUSH
17574: PPUSH
// result := false ;
17575: LD_ADDR_VAR 0 2
17579: PUSH
17580: LD_INT 0
17582: ST_TO_ADDR
// side := GetSide ( unit ) ;
17583: LD_ADDR_VAR 0 3
17587: PUSH
17588: LD_VAR 0 1
17592: PPUSH
17593: CALL_OW 255
17597: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17598: LD_ADDR_VAR 0 4
17602: PUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: CALL_OW 248
17612: ST_TO_ADDR
// case nat of 1 :
17613: LD_VAR 0 4
17617: PUSH
17618: LD_INT 1
17620: DOUBLE
17621: EQUAL
17622: IFTRUE 17626
17624: GO 17637
17626: POP
// tech := tech_lassight ; 2 :
17627: LD_ADDR_VAR 0 5
17631: PUSH
17632: LD_INT 12
17634: ST_TO_ADDR
17635: GO 17676
17637: LD_INT 2
17639: DOUBLE
17640: EQUAL
17641: IFTRUE 17645
17643: GO 17656
17645: POP
// tech := tech_mortar ; 3 :
17646: LD_ADDR_VAR 0 5
17650: PUSH
17651: LD_INT 41
17653: ST_TO_ADDR
17654: GO 17676
17656: LD_INT 3
17658: DOUBLE
17659: EQUAL
17660: IFTRUE 17664
17662: GO 17675
17664: POP
// tech := tech_bazooka ; end ;
17665: LD_ADDR_VAR 0 5
17669: PUSH
17670: LD_INT 44
17672: ST_TO_ADDR
17673: GO 17676
17675: POP
// if Researched ( side , tech ) then
17676: LD_VAR 0 3
17680: PPUSH
17681: LD_VAR 0 5
17685: PPUSH
17686: CALL_OW 325
17690: IFFALSE 17717
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17692: LD_ADDR_VAR 0 2
17696: PUSH
17697: LD_INT 5
17699: PUSH
17700: LD_INT 8
17702: PUSH
17703: LD_INT 9
17705: PUSH
17706: EMPTY
17707: LIST
17708: LIST
17709: LIST
17710: PUSH
17711: LD_VAR 0 4
17715: ARRAY
17716: ST_TO_ADDR
// end ;
17717: LD_VAR 0 2
17721: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17722: LD_INT 0
17724: PPUSH
17725: PPUSH
17726: PPUSH
// if not mines then
17727: LD_VAR 0 2
17731: NOT
17732: IFFALSE 17736
// exit ;
17734: GO 17880
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17736: LD_ADDR_VAR 0 5
17740: PUSH
17741: LD_INT 81
17743: PUSH
17744: LD_VAR 0 1
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: PUSH
17753: LD_INT 3
17755: PUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 3
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PPUSH
17774: CALL_OW 69
17778: ST_TO_ADDR
// for i in mines do
17779: LD_ADDR_VAR 0 4
17783: PUSH
17784: LD_VAR 0 2
17788: PUSH
17789: FOR_IN
17790: IFFALSE 17878
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17792: LD_VAR 0 4
17796: PUSH
17797: LD_INT 1
17799: ARRAY
17800: PPUSH
17801: LD_VAR 0 4
17805: PUSH
17806: LD_INT 2
17808: ARRAY
17809: PPUSH
17810: CALL_OW 458
17814: NOT
17815: IFFALSE 17819
// continue ;
17817: GO 17789
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17819: LD_VAR 0 4
17823: PUSH
17824: LD_INT 1
17826: ARRAY
17827: PPUSH
17828: LD_VAR 0 4
17832: PUSH
17833: LD_INT 2
17835: ARRAY
17836: PPUSH
17837: CALL_OW 428
17841: PUSH
17842: LD_VAR 0 5
17846: IN
17847: IFFALSE 17876
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17849: LD_VAR 0 4
17853: PUSH
17854: LD_INT 1
17856: ARRAY
17857: PPUSH
17858: LD_VAR 0 4
17862: PUSH
17863: LD_INT 2
17865: ARRAY
17866: PPUSH
17867: LD_VAR 0 1
17871: PPUSH
17872: CALL_OW 456
// end ;
17876: GO 17789
17878: POP
17879: POP
// end ;
17880: LD_VAR 0 3
17884: RET
// export function Count ( array ) ; var i ; begin
17885: LD_INT 0
17887: PPUSH
17888: PPUSH
// result := 0 ;
17889: LD_ADDR_VAR 0 2
17893: PUSH
17894: LD_INT 0
17896: ST_TO_ADDR
// for i in array do
17897: LD_ADDR_VAR 0 3
17901: PUSH
17902: LD_VAR 0 1
17906: PUSH
17907: FOR_IN
17908: IFFALSE 17932
// if i then
17910: LD_VAR 0 3
17914: IFFALSE 17930
// result := result + 1 ;
17916: LD_ADDR_VAR 0 2
17920: PUSH
17921: LD_VAR 0 2
17925: PUSH
17926: LD_INT 1
17928: PLUS
17929: ST_TO_ADDR
17930: GO 17907
17932: POP
17933: POP
// end ;
17934: LD_VAR 0 2
17938: RET
// export function IsEmpty ( building ) ; begin
17939: LD_INT 0
17941: PPUSH
// if not building then
17942: LD_VAR 0 1
17946: NOT
17947: IFFALSE 17951
// exit ;
17949: GO 17994
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17951: LD_ADDR_VAR 0 2
17955: PUSH
17956: LD_VAR 0 1
17960: PUSH
17961: LD_INT 22
17963: PUSH
17964: LD_VAR 0 1
17968: PPUSH
17969: CALL_OW 255
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: PUSH
17978: LD_INT 58
17980: PUSH
17981: EMPTY
17982: LIST
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: PPUSH
17988: CALL_OW 69
17992: IN
17993: ST_TO_ADDR
// end ;
17994: LD_VAR 0 2
17998: RET
// export function IsNotFull ( building ) ; begin
17999: LD_INT 0
18001: PPUSH
// if not building then
18002: LD_VAR 0 1
18006: NOT
18007: IFFALSE 18011
// exit ;
18009: GO 18030
// result := UnitsInside ( building ) < 6 ;
18011: LD_ADDR_VAR 0 2
18015: PUSH
18016: LD_VAR 0 1
18020: PPUSH
18021: CALL_OW 313
18025: PUSH
18026: LD_INT 6
18028: LESS
18029: ST_TO_ADDR
// end ;
18030: LD_VAR 0 2
18034: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18035: LD_INT 0
18037: PPUSH
18038: PPUSH
18039: PPUSH
18040: PPUSH
// tmp := [ ] ;
18041: LD_ADDR_VAR 0 3
18045: PUSH
18046: EMPTY
18047: ST_TO_ADDR
// list := [ ] ;
18048: LD_ADDR_VAR 0 5
18052: PUSH
18053: EMPTY
18054: ST_TO_ADDR
// for i = 16 to 25 do
18055: LD_ADDR_VAR 0 4
18059: PUSH
18060: DOUBLE
18061: LD_INT 16
18063: DEC
18064: ST_TO_ADDR
18065: LD_INT 25
18067: PUSH
18068: FOR_TO
18069: IFFALSE 18142
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18071: LD_ADDR_VAR 0 3
18075: PUSH
18076: LD_VAR 0 3
18080: PUSH
18081: LD_INT 22
18083: PUSH
18084: LD_VAR 0 1
18088: PPUSH
18089: CALL_OW 255
18093: PUSH
18094: EMPTY
18095: LIST
18096: LIST
18097: PUSH
18098: LD_INT 91
18100: PUSH
18101: LD_VAR 0 1
18105: PUSH
18106: LD_INT 6
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PUSH
18114: LD_INT 30
18116: PUSH
18117: LD_VAR 0 4
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: LIST
18129: LIST
18130: PUSH
18131: EMPTY
18132: LIST
18133: PPUSH
18134: CALL_OW 69
18138: ADD
18139: ST_TO_ADDR
18140: GO 18068
18142: POP
18143: POP
// for i = 1 to tmp do
18144: LD_ADDR_VAR 0 4
18148: PUSH
18149: DOUBLE
18150: LD_INT 1
18152: DEC
18153: ST_TO_ADDR
18154: LD_VAR 0 3
18158: PUSH
18159: FOR_TO
18160: IFFALSE 18248
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18162: LD_ADDR_VAR 0 5
18166: PUSH
18167: LD_VAR 0 5
18171: PUSH
18172: LD_VAR 0 3
18176: PUSH
18177: LD_VAR 0 4
18181: ARRAY
18182: PPUSH
18183: CALL_OW 266
18187: PUSH
18188: LD_VAR 0 3
18192: PUSH
18193: LD_VAR 0 4
18197: ARRAY
18198: PPUSH
18199: CALL_OW 250
18203: PUSH
18204: LD_VAR 0 3
18208: PUSH
18209: LD_VAR 0 4
18213: ARRAY
18214: PPUSH
18215: CALL_OW 251
18219: PUSH
18220: LD_VAR 0 3
18224: PUSH
18225: LD_VAR 0 4
18229: ARRAY
18230: PPUSH
18231: CALL_OW 254
18235: PUSH
18236: EMPTY
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: PUSH
18242: EMPTY
18243: LIST
18244: ADD
18245: ST_TO_ADDR
18246: GO 18159
18248: POP
18249: POP
// result := list ;
18250: LD_ADDR_VAR 0 2
18254: PUSH
18255: LD_VAR 0 5
18259: ST_TO_ADDR
// end ;
18260: LD_VAR 0 2
18264: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18265: LD_INT 0
18267: PPUSH
18268: PPUSH
18269: PPUSH
18270: PPUSH
18271: PPUSH
18272: PPUSH
18273: PPUSH
// if not factory then
18274: LD_VAR 0 1
18278: NOT
18279: IFFALSE 18283
// exit ;
18281: GO 18808
// if control = control_apeman then
18283: LD_VAR 0 4
18287: PUSH
18288: LD_INT 5
18290: EQUAL
18291: IFFALSE 18400
// begin tmp := UnitsInside ( factory ) ;
18293: LD_ADDR_VAR 0 8
18297: PUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: CALL_OW 313
18307: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18308: LD_VAR 0 8
18312: PPUSH
18313: LD_INT 25
18315: PUSH
18316: LD_INT 12
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PPUSH
18323: CALL_OW 72
18327: NOT
18328: IFFALSE 18338
// control := control_manual ;
18330: LD_ADDR_VAR 0 4
18334: PUSH
18335: LD_INT 1
18337: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18338: LD_ADDR_VAR 0 8
18342: PUSH
18343: LD_VAR 0 1
18347: PPUSH
18348: CALL 18035 0 1
18352: ST_TO_ADDR
// if tmp then
18353: LD_VAR 0 8
18357: IFFALSE 18400
// begin for i in tmp do
18359: LD_ADDR_VAR 0 7
18363: PUSH
18364: LD_VAR 0 8
18368: PUSH
18369: FOR_IN
18370: IFFALSE 18398
// if i [ 1 ] = b_ext_radar then
18372: LD_VAR 0 7
18376: PUSH
18377: LD_INT 1
18379: ARRAY
18380: PUSH
18381: LD_INT 20
18383: EQUAL
18384: IFFALSE 18396
// begin control := control_remote ;
18386: LD_ADDR_VAR 0 4
18390: PUSH
18391: LD_INT 2
18393: ST_TO_ADDR
// break ;
18394: GO 18398
// end ;
18396: GO 18369
18398: POP
18399: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18400: LD_VAR 0 1
18404: PPUSH
18405: LD_VAR 0 2
18409: PPUSH
18410: LD_VAR 0 3
18414: PPUSH
18415: LD_VAR 0 4
18419: PPUSH
18420: LD_VAR 0 5
18424: PPUSH
18425: CALL_OW 448
18429: IFFALSE 18464
// begin result := [ chassis , engine , control , weapon ] ;
18431: LD_ADDR_VAR 0 6
18435: PUSH
18436: LD_VAR 0 2
18440: PUSH
18441: LD_VAR 0 3
18445: PUSH
18446: LD_VAR 0 4
18450: PUSH
18451: LD_VAR 0 5
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: ST_TO_ADDR
// exit ;
18462: GO 18808
// end ; _chassis := AvailableChassisList ( factory ) ;
18464: LD_ADDR_VAR 0 9
18468: PUSH
18469: LD_VAR 0 1
18473: PPUSH
18474: CALL_OW 475
18478: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18479: LD_ADDR_VAR 0 11
18483: PUSH
18484: LD_VAR 0 1
18488: PPUSH
18489: CALL_OW 476
18493: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18494: LD_ADDR_VAR 0 12
18498: PUSH
18499: LD_VAR 0 1
18503: PPUSH
18504: CALL_OW 477
18508: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18509: LD_ADDR_VAR 0 10
18513: PUSH
18514: LD_VAR 0 1
18518: PPUSH
18519: CALL_OW 478
18523: ST_TO_ADDR
// if not chassis in _chassis then
18524: LD_VAR 0 2
18528: PUSH
18529: LD_VAR 0 9
18533: IN
18534: NOT
18535: IFFALSE 18561
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_VAR 0 9
18546: PUSH
18547: LD_INT 1
18549: PPUSH
18550: LD_VAR 0 9
18554: PPUSH
18555: CALL_OW 12
18559: ARRAY
18560: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18561: LD_VAR 0 2
18565: PPUSH
18566: LD_VAR 0 3
18570: PPUSH
18571: CALL 18813 0 2
18575: NOT
18576: IFFALSE 18635
// repeat engine := _engine [ 1 ] ;
18578: LD_ADDR_VAR 0 3
18582: PUSH
18583: LD_VAR 0 11
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18592: LD_ADDR_VAR 0 11
18596: PUSH
18597: LD_VAR 0 11
18601: PPUSH
18602: LD_INT 1
18604: PPUSH
18605: CALL_OW 3
18609: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18610: LD_VAR 0 2
18614: PPUSH
18615: LD_VAR 0 3
18619: PPUSH
18620: CALL 18813 0 2
18624: PUSH
18625: LD_VAR 0 11
18629: PUSH
18630: EMPTY
18631: EQUAL
18632: OR
18633: IFFALSE 18578
// if not control in _control then
18635: LD_VAR 0 4
18639: PUSH
18640: LD_VAR 0 12
18644: IN
18645: NOT
18646: IFFALSE 18672
// control := _control [ rand ( 1 , _control ) ] ;
18648: LD_ADDR_VAR 0 4
18652: PUSH
18653: LD_VAR 0 12
18657: PUSH
18658: LD_INT 1
18660: PPUSH
18661: LD_VAR 0 12
18665: PPUSH
18666: CALL_OW 12
18670: ARRAY
18671: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18672: LD_VAR 0 2
18676: PPUSH
18677: LD_VAR 0 5
18681: PPUSH
18682: CALL 19033 0 2
18686: NOT
18687: IFFALSE 18746
// repeat weapon := _weapon [ 1 ] ;
18689: LD_ADDR_VAR 0 5
18693: PUSH
18694: LD_VAR 0 10
18698: PUSH
18699: LD_INT 1
18701: ARRAY
18702: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18703: LD_ADDR_VAR 0 10
18707: PUSH
18708: LD_VAR 0 10
18712: PPUSH
18713: LD_INT 1
18715: PPUSH
18716: CALL_OW 3
18720: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18721: LD_VAR 0 2
18725: PPUSH
18726: LD_VAR 0 5
18730: PPUSH
18731: CALL 19033 0 2
18735: PUSH
18736: LD_VAR 0 10
18740: PUSH
18741: EMPTY
18742: EQUAL
18743: OR
18744: IFFALSE 18689
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18746: LD_VAR 0 1
18750: PPUSH
18751: LD_VAR 0 2
18755: PPUSH
18756: LD_VAR 0 3
18760: PPUSH
18761: LD_VAR 0 4
18765: PPUSH
18766: LD_VAR 0 5
18770: PPUSH
18771: CALL_OW 448
18775: IFFALSE 18808
// result := [ chassis , engine , control , weapon ] ;
18777: LD_ADDR_VAR 0 6
18781: PUSH
18782: LD_VAR 0 2
18786: PUSH
18787: LD_VAR 0 3
18791: PUSH
18792: LD_VAR 0 4
18796: PUSH
18797: LD_VAR 0 5
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: ST_TO_ADDR
// end ;
18808: LD_VAR 0 6
18812: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18813: LD_INT 0
18815: PPUSH
// if not chassis or not engine then
18816: LD_VAR 0 1
18820: NOT
18821: PUSH
18822: LD_VAR 0 2
18826: NOT
18827: OR
18828: IFFALSE 18832
// exit ;
18830: GO 19028
// case engine of engine_solar :
18832: LD_VAR 0 2
18836: PUSH
18837: LD_INT 2
18839: DOUBLE
18840: EQUAL
18841: IFTRUE 18845
18843: GO 18883
18845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18846: LD_ADDR_VAR 0 3
18850: PUSH
18851: LD_INT 11
18853: PUSH
18854: LD_INT 12
18856: PUSH
18857: LD_INT 13
18859: PUSH
18860: LD_INT 14
18862: PUSH
18863: LD_INT 1
18865: PUSH
18866: LD_INT 2
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: LIST
18880: ST_TO_ADDR
18881: GO 19012
18883: LD_INT 1
18885: DOUBLE
18886: EQUAL
18887: IFTRUE 18891
18889: GO 18953
18891: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18892: LD_ADDR_VAR 0 3
18896: PUSH
18897: LD_INT 11
18899: PUSH
18900: LD_INT 12
18902: PUSH
18903: LD_INT 13
18905: PUSH
18906: LD_INT 14
18908: PUSH
18909: LD_INT 1
18911: PUSH
18912: LD_INT 2
18914: PUSH
18915: LD_INT 3
18917: PUSH
18918: LD_INT 4
18920: PUSH
18921: LD_INT 5
18923: PUSH
18924: LD_INT 21
18926: PUSH
18927: LD_INT 23
18929: PUSH
18930: LD_INT 22
18932: PUSH
18933: LD_INT 24
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: LIST
18949: LIST
18950: ST_TO_ADDR
18951: GO 19012
18953: LD_INT 3
18955: DOUBLE
18956: EQUAL
18957: IFTRUE 18961
18959: GO 19011
18961: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18962: LD_ADDR_VAR 0 3
18966: PUSH
18967: LD_INT 13
18969: PUSH
18970: LD_INT 14
18972: PUSH
18973: LD_INT 2
18975: PUSH
18976: LD_INT 3
18978: PUSH
18979: LD_INT 4
18981: PUSH
18982: LD_INT 5
18984: PUSH
18985: LD_INT 21
18987: PUSH
18988: LD_INT 22
18990: PUSH
18991: LD_INT 23
18993: PUSH
18994: LD_INT 24
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: LIST
19008: ST_TO_ADDR
19009: GO 19012
19011: POP
// result := ( chassis in result ) ;
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_VAR 0 1
19021: PUSH
19022: LD_VAR 0 3
19026: IN
19027: ST_TO_ADDR
// end ;
19028: LD_VAR 0 3
19032: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19033: LD_INT 0
19035: PPUSH
// if not chassis or not weapon then
19036: LD_VAR 0 1
19040: NOT
19041: PUSH
19042: LD_VAR 0 2
19046: NOT
19047: OR
19048: IFFALSE 19052
// exit ;
19050: GO 20078
// case weapon of us_machine_gun :
19052: LD_VAR 0 2
19056: PUSH
19057: LD_INT 2
19059: DOUBLE
19060: EQUAL
19061: IFTRUE 19065
19063: GO 19095
19065: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_INT 1
19073: PUSH
19074: LD_INT 2
19076: PUSH
19077: LD_INT 3
19079: PUSH
19080: LD_INT 4
19082: PUSH
19083: LD_INT 5
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: LIST
19092: ST_TO_ADDR
19093: GO 20062
19095: LD_INT 3
19097: DOUBLE
19098: EQUAL
19099: IFTRUE 19103
19101: GO 19133
19103: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19104: LD_ADDR_VAR 0 3
19108: PUSH
19109: LD_INT 1
19111: PUSH
19112: LD_INT 2
19114: PUSH
19115: LD_INT 3
19117: PUSH
19118: LD_INT 4
19120: PUSH
19121: LD_INT 5
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: LIST
19128: LIST
19129: LIST
19130: ST_TO_ADDR
19131: GO 20062
19133: LD_INT 11
19135: DOUBLE
19136: EQUAL
19137: IFTRUE 19141
19139: GO 19171
19141: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19142: LD_ADDR_VAR 0 3
19146: PUSH
19147: LD_INT 1
19149: PUSH
19150: LD_INT 2
19152: PUSH
19153: LD_INT 3
19155: PUSH
19156: LD_INT 4
19158: PUSH
19159: LD_INT 5
19161: PUSH
19162: EMPTY
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: ST_TO_ADDR
19169: GO 20062
19171: LD_INT 4
19173: DOUBLE
19174: EQUAL
19175: IFTRUE 19179
19177: GO 19205
19179: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19180: LD_ADDR_VAR 0 3
19184: PUSH
19185: LD_INT 2
19187: PUSH
19188: LD_INT 3
19190: PUSH
19191: LD_INT 4
19193: PUSH
19194: LD_INT 5
19196: PUSH
19197: EMPTY
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: ST_TO_ADDR
19203: GO 20062
19205: LD_INT 5
19207: DOUBLE
19208: EQUAL
19209: IFTRUE 19213
19211: GO 19239
19213: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19214: LD_ADDR_VAR 0 3
19218: PUSH
19219: LD_INT 2
19221: PUSH
19222: LD_INT 3
19224: PUSH
19225: LD_INT 4
19227: PUSH
19228: LD_INT 5
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: ST_TO_ADDR
19237: GO 20062
19239: LD_INT 9
19241: DOUBLE
19242: EQUAL
19243: IFTRUE 19247
19245: GO 19273
19247: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19248: LD_ADDR_VAR 0 3
19252: PUSH
19253: LD_INT 2
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: LD_INT 4
19261: PUSH
19262: LD_INT 5
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: LIST
19270: ST_TO_ADDR
19271: GO 20062
19273: LD_INT 7
19275: DOUBLE
19276: EQUAL
19277: IFTRUE 19281
19279: GO 19307
19281: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19282: LD_ADDR_VAR 0 3
19286: PUSH
19287: LD_INT 2
19289: PUSH
19290: LD_INT 3
19292: PUSH
19293: LD_INT 4
19295: PUSH
19296: LD_INT 5
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: ST_TO_ADDR
19305: GO 20062
19307: LD_INT 12
19309: DOUBLE
19310: EQUAL
19311: IFTRUE 19315
19313: GO 19341
19315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19316: LD_ADDR_VAR 0 3
19320: PUSH
19321: LD_INT 2
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: LD_INT 4
19329: PUSH
19330: LD_INT 5
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: ST_TO_ADDR
19339: GO 20062
19341: LD_INT 13
19343: DOUBLE
19344: EQUAL
19345: IFTRUE 19349
19347: GO 19375
19349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19350: LD_ADDR_VAR 0 3
19354: PUSH
19355: LD_INT 2
19357: PUSH
19358: LD_INT 3
19360: PUSH
19361: LD_INT 4
19363: PUSH
19364: LD_INT 5
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: ST_TO_ADDR
19373: GO 20062
19375: LD_INT 14
19377: DOUBLE
19378: EQUAL
19379: IFTRUE 19383
19381: GO 19401
19383: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19384: LD_ADDR_VAR 0 3
19388: PUSH
19389: LD_INT 4
19391: PUSH
19392: LD_INT 5
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: ST_TO_ADDR
19399: GO 20062
19401: LD_INT 6
19403: DOUBLE
19404: EQUAL
19405: IFTRUE 19409
19407: GO 19427
19409: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19410: LD_ADDR_VAR 0 3
19414: PUSH
19415: LD_INT 4
19417: PUSH
19418: LD_INT 5
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: ST_TO_ADDR
19425: GO 20062
19427: LD_INT 10
19429: DOUBLE
19430: EQUAL
19431: IFTRUE 19435
19433: GO 19453
19435: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19436: LD_ADDR_VAR 0 3
19440: PUSH
19441: LD_INT 4
19443: PUSH
19444: LD_INT 5
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: ST_TO_ADDR
19451: GO 20062
19453: LD_INT 22
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19487
19461: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19462: LD_ADDR_VAR 0 3
19466: PUSH
19467: LD_INT 11
19469: PUSH
19470: LD_INT 12
19472: PUSH
19473: LD_INT 13
19475: PUSH
19476: LD_INT 14
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: ST_TO_ADDR
19485: GO 20062
19487: LD_INT 23
19489: DOUBLE
19490: EQUAL
19491: IFTRUE 19495
19493: GO 19521
19495: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19496: LD_ADDR_VAR 0 3
19500: PUSH
19501: LD_INT 11
19503: PUSH
19504: LD_INT 12
19506: PUSH
19507: LD_INT 13
19509: PUSH
19510: LD_INT 14
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: ST_TO_ADDR
19519: GO 20062
19521: LD_INT 24
19523: DOUBLE
19524: EQUAL
19525: IFTRUE 19529
19527: GO 19555
19529: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_INT 11
19537: PUSH
19538: LD_INT 12
19540: PUSH
19541: LD_INT 13
19543: PUSH
19544: LD_INT 14
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: LIST
19551: LIST
19552: ST_TO_ADDR
19553: GO 20062
19555: LD_INT 30
19557: DOUBLE
19558: EQUAL
19559: IFTRUE 19563
19561: GO 19589
19563: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_INT 11
19571: PUSH
19572: LD_INT 12
19574: PUSH
19575: LD_INT 13
19577: PUSH
19578: LD_INT 14
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: ST_TO_ADDR
19587: GO 20062
19589: LD_INT 25
19591: DOUBLE
19592: EQUAL
19593: IFTRUE 19597
19595: GO 19615
19597: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19598: LD_ADDR_VAR 0 3
19602: PUSH
19603: LD_INT 13
19605: PUSH
19606: LD_INT 14
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: ST_TO_ADDR
19613: GO 20062
19615: LD_INT 27
19617: DOUBLE
19618: EQUAL
19619: IFTRUE 19623
19621: GO 19641
19623: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19624: LD_ADDR_VAR 0 3
19628: PUSH
19629: LD_INT 13
19631: PUSH
19632: LD_INT 14
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: ST_TO_ADDR
19639: GO 20062
19641: LD_INT 28
19643: DOUBLE
19644: EQUAL
19645: IFTRUE 19649
19647: GO 19667
19649: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19650: LD_ADDR_VAR 0 3
19654: PUSH
19655: LD_INT 13
19657: PUSH
19658: LD_INT 14
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: ST_TO_ADDR
19665: GO 20062
19667: LD_INT 29
19669: DOUBLE
19670: EQUAL
19671: IFTRUE 19675
19673: GO 19693
19675: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19676: LD_ADDR_VAR 0 3
19680: PUSH
19681: LD_INT 13
19683: PUSH
19684: LD_INT 14
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: ST_TO_ADDR
19691: GO 20062
19693: LD_INT 31
19695: DOUBLE
19696: EQUAL
19697: IFTRUE 19701
19699: GO 19719
19701: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19702: LD_ADDR_VAR 0 3
19706: PUSH
19707: LD_INT 13
19709: PUSH
19710: LD_INT 14
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: ST_TO_ADDR
19717: GO 20062
19719: LD_INT 26
19721: DOUBLE
19722: EQUAL
19723: IFTRUE 19727
19725: GO 19745
19727: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19728: LD_ADDR_VAR 0 3
19732: PUSH
19733: LD_INT 13
19735: PUSH
19736: LD_INT 14
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: ST_TO_ADDR
19743: GO 20062
19745: LD_INT 42
19747: DOUBLE
19748: EQUAL
19749: IFTRUE 19753
19751: GO 19779
19753: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19754: LD_ADDR_VAR 0 3
19758: PUSH
19759: LD_INT 21
19761: PUSH
19762: LD_INT 22
19764: PUSH
19765: LD_INT 23
19767: PUSH
19768: LD_INT 24
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: ST_TO_ADDR
19777: GO 20062
19779: LD_INT 43
19781: DOUBLE
19782: EQUAL
19783: IFTRUE 19787
19785: GO 19813
19787: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19788: LD_ADDR_VAR 0 3
19792: PUSH
19793: LD_INT 21
19795: PUSH
19796: LD_INT 22
19798: PUSH
19799: LD_INT 23
19801: PUSH
19802: LD_INT 24
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: ST_TO_ADDR
19811: GO 20062
19813: LD_INT 44
19815: DOUBLE
19816: EQUAL
19817: IFTRUE 19821
19819: GO 19847
19821: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19822: LD_ADDR_VAR 0 3
19826: PUSH
19827: LD_INT 21
19829: PUSH
19830: LD_INT 22
19832: PUSH
19833: LD_INT 23
19835: PUSH
19836: LD_INT 24
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: ST_TO_ADDR
19845: GO 20062
19847: LD_INT 45
19849: DOUBLE
19850: EQUAL
19851: IFTRUE 19855
19853: GO 19881
19855: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19856: LD_ADDR_VAR 0 3
19860: PUSH
19861: LD_INT 21
19863: PUSH
19864: LD_INT 22
19866: PUSH
19867: LD_INT 23
19869: PUSH
19870: LD_INT 24
19872: PUSH
19873: EMPTY
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: ST_TO_ADDR
19879: GO 20062
19881: LD_INT 49
19883: DOUBLE
19884: EQUAL
19885: IFTRUE 19889
19887: GO 19915
19889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19890: LD_ADDR_VAR 0 3
19894: PUSH
19895: LD_INT 21
19897: PUSH
19898: LD_INT 22
19900: PUSH
19901: LD_INT 23
19903: PUSH
19904: LD_INT 24
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: ST_TO_ADDR
19913: GO 20062
19915: LD_INT 51
19917: DOUBLE
19918: EQUAL
19919: IFTRUE 19923
19921: GO 19949
19923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19924: LD_ADDR_VAR 0 3
19928: PUSH
19929: LD_INT 21
19931: PUSH
19932: LD_INT 22
19934: PUSH
19935: LD_INT 23
19937: PUSH
19938: LD_INT 24
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: ST_TO_ADDR
19947: GO 20062
19949: LD_INT 52
19951: DOUBLE
19952: EQUAL
19953: IFTRUE 19957
19955: GO 19983
19957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19958: LD_ADDR_VAR 0 3
19962: PUSH
19963: LD_INT 21
19965: PUSH
19966: LD_INT 22
19968: PUSH
19969: LD_INT 23
19971: PUSH
19972: LD_INT 24
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: ST_TO_ADDR
19981: GO 20062
19983: LD_INT 53
19985: DOUBLE
19986: EQUAL
19987: IFTRUE 19991
19989: GO 20009
19991: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19992: LD_ADDR_VAR 0 3
19996: PUSH
19997: LD_INT 23
19999: PUSH
20000: LD_INT 24
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: ST_TO_ADDR
20007: GO 20062
20009: LD_INT 46
20011: DOUBLE
20012: EQUAL
20013: IFTRUE 20017
20015: GO 20035
20017: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20018: LD_ADDR_VAR 0 3
20022: PUSH
20023: LD_INT 23
20025: PUSH
20026: LD_INT 24
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: ST_TO_ADDR
20033: GO 20062
20035: LD_INT 47
20037: DOUBLE
20038: EQUAL
20039: IFTRUE 20043
20041: GO 20061
20043: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20044: LD_ADDR_VAR 0 3
20048: PUSH
20049: LD_INT 23
20051: PUSH
20052: LD_INT 24
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 20062
20061: POP
// result := ( chassis in result ) ;
20062: LD_ADDR_VAR 0 3
20066: PUSH
20067: LD_VAR 0 1
20071: PUSH
20072: LD_VAR 0 3
20076: IN
20077: ST_TO_ADDR
// end ;
20078: LD_VAR 0 3
20082: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20083: LD_INT 0
20085: PPUSH
20086: PPUSH
20087: PPUSH
20088: PPUSH
20089: PPUSH
20090: PPUSH
20091: PPUSH
// result := array ;
20092: LD_ADDR_VAR 0 5
20096: PUSH
20097: LD_VAR 0 1
20101: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20102: LD_VAR 0 1
20106: NOT
20107: PUSH
20108: LD_VAR 0 2
20112: NOT
20113: OR
20114: PUSH
20115: LD_VAR 0 3
20119: NOT
20120: OR
20121: PUSH
20122: LD_VAR 0 2
20126: PUSH
20127: LD_VAR 0 1
20131: GREATER
20132: OR
20133: PUSH
20134: LD_VAR 0 3
20138: PUSH
20139: LD_VAR 0 1
20143: GREATER
20144: OR
20145: IFFALSE 20149
// exit ;
20147: GO 20445
// if direction then
20149: LD_VAR 0 4
20153: IFFALSE 20217
// begin d := 1 ;
20155: LD_ADDR_VAR 0 9
20159: PUSH
20160: LD_INT 1
20162: ST_TO_ADDR
// if i_from > i_to then
20163: LD_VAR 0 2
20167: PUSH
20168: LD_VAR 0 3
20172: GREATER
20173: IFFALSE 20199
// length := ( array - i_from ) + i_to else
20175: LD_ADDR_VAR 0 11
20179: PUSH
20180: LD_VAR 0 1
20184: PUSH
20185: LD_VAR 0 2
20189: MINUS
20190: PUSH
20191: LD_VAR 0 3
20195: PLUS
20196: ST_TO_ADDR
20197: GO 20215
// length := i_to - i_from ;
20199: LD_ADDR_VAR 0 11
20203: PUSH
20204: LD_VAR 0 3
20208: PUSH
20209: LD_VAR 0 2
20213: MINUS
20214: ST_TO_ADDR
// end else
20215: GO 20278
// begin d := - 1 ;
20217: LD_ADDR_VAR 0 9
20221: PUSH
20222: LD_INT 1
20224: NEG
20225: ST_TO_ADDR
// if i_from > i_to then
20226: LD_VAR 0 2
20230: PUSH
20231: LD_VAR 0 3
20235: GREATER
20236: IFFALSE 20256
// length := i_from - i_to else
20238: LD_ADDR_VAR 0 11
20242: PUSH
20243: LD_VAR 0 2
20247: PUSH
20248: LD_VAR 0 3
20252: MINUS
20253: ST_TO_ADDR
20254: GO 20278
// length := ( array - i_to ) + i_from ;
20256: LD_ADDR_VAR 0 11
20260: PUSH
20261: LD_VAR 0 1
20265: PUSH
20266: LD_VAR 0 3
20270: MINUS
20271: PUSH
20272: LD_VAR 0 2
20276: PLUS
20277: ST_TO_ADDR
// end ; if not length then
20278: LD_VAR 0 11
20282: NOT
20283: IFFALSE 20287
// exit ;
20285: GO 20445
// tmp := array ;
20287: LD_ADDR_VAR 0 10
20291: PUSH
20292: LD_VAR 0 1
20296: ST_TO_ADDR
// for i = 1 to length do
20297: LD_ADDR_VAR 0 6
20301: PUSH
20302: DOUBLE
20303: LD_INT 1
20305: DEC
20306: ST_TO_ADDR
20307: LD_VAR 0 11
20311: PUSH
20312: FOR_TO
20313: IFFALSE 20433
// begin for j = 1 to array do
20315: LD_ADDR_VAR 0 7
20319: PUSH
20320: DOUBLE
20321: LD_INT 1
20323: DEC
20324: ST_TO_ADDR
20325: LD_VAR 0 1
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20419
// begin k := j + d ;
20333: LD_ADDR_VAR 0 8
20337: PUSH
20338: LD_VAR 0 7
20342: PUSH
20343: LD_VAR 0 9
20347: PLUS
20348: ST_TO_ADDR
// if k > array then
20349: LD_VAR 0 8
20353: PUSH
20354: LD_VAR 0 1
20358: GREATER
20359: IFFALSE 20369
// k := 1 ;
20361: LD_ADDR_VAR 0 8
20365: PUSH
20366: LD_INT 1
20368: ST_TO_ADDR
// if not k then
20369: LD_VAR 0 8
20373: NOT
20374: IFFALSE 20386
// k := array ;
20376: LD_ADDR_VAR 0 8
20380: PUSH
20381: LD_VAR 0 1
20385: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20386: LD_ADDR_VAR 0 10
20390: PUSH
20391: LD_VAR 0 10
20395: PPUSH
20396: LD_VAR 0 8
20400: PPUSH
20401: LD_VAR 0 1
20405: PUSH
20406: LD_VAR 0 7
20410: ARRAY
20411: PPUSH
20412: CALL_OW 1
20416: ST_TO_ADDR
// end ;
20417: GO 20330
20419: POP
20420: POP
// array := tmp ;
20421: LD_ADDR_VAR 0 1
20425: PUSH
20426: LD_VAR 0 10
20430: ST_TO_ADDR
// end ;
20431: GO 20312
20433: POP
20434: POP
// result := array ;
20435: LD_ADDR_VAR 0 5
20439: PUSH
20440: LD_VAR 0 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 5
20449: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20450: LD_INT 0
20452: PPUSH
20453: PPUSH
// result := 0 ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 0
20461: ST_TO_ADDR
// if not array or not value in array then
20462: LD_VAR 0 1
20466: NOT
20467: PUSH
20468: LD_VAR 0 2
20472: PUSH
20473: LD_VAR 0 1
20477: IN
20478: NOT
20479: OR
20480: IFFALSE 20484
// exit ;
20482: GO 20538
// for i = 1 to array do
20484: LD_ADDR_VAR 0 4
20488: PUSH
20489: DOUBLE
20490: LD_INT 1
20492: DEC
20493: ST_TO_ADDR
20494: LD_VAR 0 1
20498: PUSH
20499: FOR_TO
20500: IFFALSE 20536
// if value = array [ i ] then
20502: LD_VAR 0 2
20506: PUSH
20507: LD_VAR 0 1
20511: PUSH
20512: LD_VAR 0 4
20516: ARRAY
20517: EQUAL
20518: IFFALSE 20534
// begin result := i ;
20520: LD_ADDR_VAR 0 3
20524: PUSH
20525: LD_VAR 0 4
20529: ST_TO_ADDR
// exit ;
20530: POP
20531: POP
20532: GO 20538
// end ;
20534: GO 20499
20536: POP
20537: POP
// end ;
20538: LD_VAR 0 3
20542: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20543: LD_INT 0
20545: PPUSH
// vc_chassis := chassis ;
20546: LD_ADDR_OWVAR 37
20550: PUSH
20551: LD_VAR 0 1
20555: ST_TO_ADDR
// vc_engine := engine ;
20556: LD_ADDR_OWVAR 39
20560: PUSH
20561: LD_VAR 0 2
20565: ST_TO_ADDR
// vc_control := control ;
20566: LD_ADDR_OWVAR 38
20570: PUSH
20571: LD_VAR 0 3
20575: ST_TO_ADDR
// vc_weapon := weapon ;
20576: LD_ADDR_OWVAR 40
20580: PUSH
20581: LD_VAR 0 4
20585: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20586: LD_ADDR_OWVAR 41
20590: PUSH
20591: LD_VAR 0 5
20595: ST_TO_ADDR
// end ;
20596: LD_VAR 0 6
20600: RET
// export function WantPlant ( unit ) ; var task ; begin
20601: LD_INT 0
20603: PPUSH
20604: PPUSH
// result := false ;
20605: LD_ADDR_VAR 0 2
20609: PUSH
20610: LD_INT 0
20612: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20613: LD_ADDR_VAR 0 3
20617: PUSH
20618: LD_VAR 0 1
20622: PPUSH
20623: CALL_OW 437
20627: ST_TO_ADDR
// if task then
20628: LD_VAR 0 3
20632: IFFALSE 20660
// if task [ 1 ] [ 1 ] = p then
20634: LD_VAR 0 3
20638: PUSH
20639: LD_INT 1
20641: ARRAY
20642: PUSH
20643: LD_INT 1
20645: ARRAY
20646: PUSH
20647: LD_STRING p
20649: EQUAL
20650: IFFALSE 20660
// result := true ;
20652: LD_ADDR_VAR 0 2
20656: PUSH
20657: LD_INT 1
20659: ST_TO_ADDR
// end ;
20660: LD_VAR 0 2
20664: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20665: LD_INT 0
20667: PPUSH
20668: PPUSH
20669: PPUSH
20670: PPUSH
// if pos < 1 then
20671: LD_VAR 0 2
20675: PUSH
20676: LD_INT 1
20678: LESS
20679: IFFALSE 20683
// exit ;
20681: GO 20986
// if pos = 1 then
20683: LD_VAR 0 2
20687: PUSH
20688: LD_INT 1
20690: EQUAL
20691: IFFALSE 20724
// result := Replace ( arr , pos [ 1 ] , value ) else
20693: LD_ADDR_VAR 0 4
20697: PUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: LD_VAR 0 2
20707: PUSH
20708: LD_INT 1
20710: ARRAY
20711: PPUSH
20712: LD_VAR 0 3
20716: PPUSH
20717: CALL_OW 1
20721: ST_TO_ADDR
20722: GO 20986
// begin tmp := arr ;
20724: LD_ADDR_VAR 0 6
20728: PUSH
20729: LD_VAR 0 1
20733: ST_TO_ADDR
// s_arr := [ tmp ] ;
20734: LD_ADDR_VAR 0 7
20738: PUSH
20739: LD_VAR 0 6
20743: PUSH
20744: EMPTY
20745: LIST
20746: ST_TO_ADDR
// for i = 1 to pos - 1 do
20747: LD_ADDR_VAR 0 5
20751: PUSH
20752: DOUBLE
20753: LD_INT 1
20755: DEC
20756: ST_TO_ADDR
20757: LD_VAR 0 2
20761: PUSH
20762: LD_INT 1
20764: MINUS
20765: PUSH
20766: FOR_TO
20767: IFFALSE 20812
// begin tmp := tmp [ pos [ i ] ] ;
20769: LD_ADDR_VAR 0 6
20773: PUSH
20774: LD_VAR 0 6
20778: PUSH
20779: LD_VAR 0 2
20783: PUSH
20784: LD_VAR 0 5
20788: ARRAY
20789: ARRAY
20790: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20791: LD_ADDR_VAR 0 7
20795: PUSH
20796: LD_VAR 0 7
20800: PUSH
20801: LD_VAR 0 6
20805: PUSH
20806: EMPTY
20807: LIST
20808: ADD
20809: ST_TO_ADDR
// end ;
20810: GO 20766
20812: POP
20813: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20814: LD_ADDR_VAR 0 6
20818: PUSH
20819: LD_VAR 0 6
20823: PPUSH
20824: LD_VAR 0 2
20828: PUSH
20829: LD_VAR 0 2
20833: ARRAY
20834: PPUSH
20835: LD_VAR 0 3
20839: PPUSH
20840: CALL_OW 1
20844: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20845: LD_ADDR_VAR 0 7
20849: PUSH
20850: LD_VAR 0 7
20854: PPUSH
20855: LD_VAR 0 7
20859: PPUSH
20860: LD_VAR 0 6
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// for i = s_arr downto 2 do
20870: LD_ADDR_VAR 0 5
20874: PUSH
20875: DOUBLE
20876: LD_VAR 0 7
20880: INC
20881: ST_TO_ADDR
20882: LD_INT 2
20884: PUSH
20885: FOR_DOWNTO
20886: IFFALSE 20970
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20888: LD_ADDR_VAR 0 6
20892: PUSH
20893: LD_VAR 0 7
20897: PUSH
20898: LD_VAR 0 5
20902: PUSH
20903: LD_INT 1
20905: MINUS
20906: ARRAY
20907: PPUSH
20908: LD_VAR 0 2
20912: PUSH
20913: LD_VAR 0 5
20917: PUSH
20918: LD_INT 1
20920: MINUS
20921: ARRAY
20922: PPUSH
20923: LD_VAR 0 7
20927: PUSH
20928: LD_VAR 0 5
20932: ARRAY
20933: PPUSH
20934: CALL_OW 1
20938: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20939: LD_ADDR_VAR 0 7
20943: PUSH
20944: LD_VAR 0 7
20948: PPUSH
20949: LD_VAR 0 5
20953: PUSH
20954: LD_INT 1
20956: MINUS
20957: PPUSH
20958: LD_VAR 0 6
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// end ;
20968: GO 20885
20970: POP
20971: POP
// result := s_arr [ 1 ] ;
20972: LD_ADDR_VAR 0 4
20976: PUSH
20977: LD_VAR 0 7
20981: PUSH
20982: LD_INT 1
20984: ARRAY
20985: ST_TO_ADDR
// end ; end ;
20986: LD_VAR 0 4
20990: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20991: LD_INT 0
20993: PPUSH
20994: PPUSH
// if not list then
20995: LD_VAR 0 1
20999: NOT
21000: IFFALSE 21004
// exit ;
21002: GO 21095
// i := list [ pos1 ] ;
21004: LD_ADDR_VAR 0 5
21008: PUSH
21009: LD_VAR 0 1
21013: PUSH
21014: LD_VAR 0 2
21018: ARRAY
21019: ST_TO_ADDR
// if not i then
21020: LD_VAR 0 5
21024: NOT
21025: IFFALSE 21029
// exit ;
21027: GO 21095
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21029: LD_ADDR_VAR 0 1
21033: PUSH
21034: LD_VAR 0 1
21038: PPUSH
21039: LD_VAR 0 2
21043: PPUSH
21044: LD_VAR 0 1
21048: PUSH
21049: LD_VAR 0 3
21053: ARRAY
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21060: LD_ADDR_VAR 0 1
21064: PUSH
21065: LD_VAR 0 1
21069: PPUSH
21070: LD_VAR 0 3
21074: PPUSH
21075: LD_VAR 0 5
21079: PPUSH
21080: CALL_OW 1
21084: ST_TO_ADDR
// result := list ;
21085: LD_ADDR_VAR 0 4
21089: PUSH
21090: LD_VAR 0 1
21094: ST_TO_ADDR
// end ;
21095: LD_VAR 0 4
21099: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21100: LD_INT 0
21102: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21103: LD_ADDR_VAR 0 5
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 250
21117: PPUSH
21118: LD_VAR 0 1
21122: PPUSH
21123: CALL_OW 251
21127: PPUSH
21128: LD_VAR 0 2
21132: PPUSH
21133: LD_VAR 0 3
21137: PPUSH
21138: LD_VAR 0 4
21142: PPUSH
21143: CALL 21153 0 5
21147: ST_TO_ADDR
// end ;
21148: LD_VAR 0 5
21152: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21153: LD_INT 0
21155: PPUSH
21156: PPUSH
21157: PPUSH
21158: PPUSH
// if not list then
21159: LD_VAR 0 3
21163: NOT
21164: IFFALSE 21168
// exit ;
21166: GO 21556
// result := [ ] ;
21168: LD_ADDR_VAR 0 6
21172: PUSH
21173: EMPTY
21174: ST_TO_ADDR
// for i in list do
21175: LD_ADDR_VAR 0 7
21179: PUSH
21180: LD_VAR 0 3
21184: PUSH
21185: FOR_IN
21186: IFFALSE 21388
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21188: LD_ADDR_VAR 0 9
21192: PUSH
21193: LD_VAR 0 7
21197: PPUSH
21198: LD_VAR 0 1
21202: PPUSH
21203: LD_VAR 0 2
21207: PPUSH
21208: CALL_OW 297
21212: ST_TO_ADDR
// if not result then
21213: LD_VAR 0 6
21217: NOT
21218: IFFALSE 21244
// result := [ [ i , tmp ] ] else
21220: LD_ADDR_VAR 0 6
21224: PUSH
21225: LD_VAR 0 7
21229: PUSH
21230: LD_VAR 0 9
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: PUSH
21239: EMPTY
21240: LIST
21241: ST_TO_ADDR
21242: GO 21386
// begin if result [ result ] [ 2 ] < tmp then
21244: LD_VAR 0 6
21248: PUSH
21249: LD_VAR 0 6
21253: ARRAY
21254: PUSH
21255: LD_INT 2
21257: ARRAY
21258: PUSH
21259: LD_VAR 0 9
21263: LESS
21264: IFFALSE 21306
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21266: LD_ADDR_VAR 0 6
21270: PUSH
21271: LD_VAR 0 6
21275: PPUSH
21276: LD_VAR 0 6
21280: PUSH
21281: LD_INT 1
21283: PLUS
21284: PPUSH
21285: LD_VAR 0 7
21289: PUSH
21290: LD_VAR 0 9
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PPUSH
21299: CALL_OW 2
21303: ST_TO_ADDR
21304: GO 21386
// for j = 1 to result do
21306: LD_ADDR_VAR 0 8
21310: PUSH
21311: DOUBLE
21312: LD_INT 1
21314: DEC
21315: ST_TO_ADDR
21316: LD_VAR 0 6
21320: PUSH
21321: FOR_TO
21322: IFFALSE 21384
// begin if tmp < result [ j ] [ 2 ] then
21324: LD_VAR 0 9
21328: PUSH
21329: LD_VAR 0 6
21333: PUSH
21334: LD_VAR 0 8
21338: ARRAY
21339: PUSH
21340: LD_INT 2
21342: ARRAY
21343: LESS
21344: IFFALSE 21382
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21346: LD_ADDR_VAR 0 6
21350: PUSH
21351: LD_VAR 0 6
21355: PPUSH
21356: LD_VAR 0 8
21360: PPUSH
21361: LD_VAR 0 7
21365: PUSH
21366: LD_VAR 0 9
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PPUSH
21375: CALL_OW 2
21379: ST_TO_ADDR
// break ;
21380: GO 21384
// end ; end ;
21382: GO 21321
21384: POP
21385: POP
// end ; end ;
21386: GO 21185
21388: POP
21389: POP
// if result and not asc then
21390: LD_VAR 0 6
21394: PUSH
21395: LD_VAR 0 4
21399: NOT
21400: AND
21401: IFFALSE 21476
// begin tmp := result ;
21403: LD_ADDR_VAR 0 9
21407: PUSH
21408: LD_VAR 0 6
21412: ST_TO_ADDR
// for i = tmp downto 1 do
21413: LD_ADDR_VAR 0 7
21417: PUSH
21418: DOUBLE
21419: LD_VAR 0 9
21423: INC
21424: ST_TO_ADDR
21425: LD_INT 1
21427: PUSH
21428: FOR_DOWNTO
21429: IFFALSE 21474
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21431: LD_ADDR_VAR 0 6
21435: PUSH
21436: LD_VAR 0 6
21440: PPUSH
21441: LD_VAR 0 9
21445: PUSH
21446: LD_VAR 0 7
21450: MINUS
21451: PUSH
21452: LD_INT 1
21454: PLUS
21455: PPUSH
21456: LD_VAR 0 9
21460: PUSH
21461: LD_VAR 0 7
21465: ARRAY
21466: PPUSH
21467: CALL_OW 1
21471: ST_TO_ADDR
21472: GO 21428
21474: POP
21475: POP
// end ; tmp := [ ] ;
21476: LD_ADDR_VAR 0 9
21480: PUSH
21481: EMPTY
21482: ST_TO_ADDR
// if mode then
21483: LD_VAR 0 5
21487: IFFALSE 21556
// begin for i = 1 to result do
21489: LD_ADDR_VAR 0 7
21493: PUSH
21494: DOUBLE
21495: LD_INT 1
21497: DEC
21498: ST_TO_ADDR
21499: LD_VAR 0 6
21503: PUSH
21504: FOR_TO
21505: IFFALSE 21544
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21507: LD_ADDR_VAR 0 9
21511: PUSH
21512: LD_VAR 0 9
21516: PPUSH
21517: LD_VAR 0 7
21521: PPUSH
21522: LD_VAR 0 6
21526: PUSH
21527: LD_VAR 0 7
21531: ARRAY
21532: PUSH
21533: LD_INT 1
21535: ARRAY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
21542: GO 21504
21544: POP
21545: POP
// result := tmp ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 9
21555: ST_TO_ADDR
// end ; end ;
21556: LD_VAR 0 6
21560: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21561: LD_INT 0
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
21567: PPUSH
21568: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21569: LD_ADDR_VAR 0 5
21573: PUSH
21574: LD_INT 0
21576: PUSH
21577: LD_INT 0
21579: PUSH
21580: LD_INT 0
21582: PUSH
21583: EMPTY
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: ST_TO_ADDR
// if not x or not y then
21591: LD_VAR 0 2
21595: NOT
21596: PUSH
21597: LD_VAR 0 3
21601: NOT
21602: OR
21603: IFFALSE 21607
// exit ;
21605: GO 23253
// if not range then
21607: LD_VAR 0 4
21611: NOT
21612: IFFALSE 21622
// range := 10 ;
21614: LD_ADDR_VAR 0 4
21618: PUSH
21619: LD_INT 10
21621: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21622: LD_ADDR_VAR 0 8
21626: PUSH
21627: LD_INT 81
21629: PUSH
21630: LD_VAR 0 1
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 92
21641: PUSH
21642: LD_VAR 0 2
21646: PUSH
21647: LD_VAR 0 3
21651: PUSH
21652: LD_VAR 0 4
21656: PUSH
21657: EMPTY
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: PUSH
21663: LD_INT 3
21665: PUSH
21666: LD_INT 21
21668: PUSH
21669: LD_INT 3
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: LIST
21684: PPUSH
21685: CALL_OW 69
21689: ST_TO_ADDR
// if not tmp then
21690: LD_VAR 0 8
21694: NOT
21695: IFFALSE 21699
// exit ;
21697: GO 23253
// for i in tmp do
21699: LD_ADDR_VAR 0 6
21703: PUSH
21704: LD_VAR 0 8
21708: PUSH
21709: FOR_IN
21710: IFFALSE 23228
// begin points := [ 0 , 0 , 0 ] ;
21712: LD_ADDR_VAR 0 9
21716: PUSH
21717: LD_INT 0
21719: PUSH
21720: LD_INT 0
21722: PUSH
21723: LD_INT 0
21725: PUSH
21726: EMPTY
21727: LIST
21728: LIST
21729: LIST
21730: ST_TO_ADDR
// bpoints := 1 ;
21731: LD_ADDR_VAR 0 10
21735: PUSH
21736: LD_INT 1
21738: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21739: LD_VAR 0 6
21743: PPUSH
21744: CALL_OW 247
21748: PUSH
21749: LD_INT 1
21751: DOUBLE
21752: EQUAL
21753: IFTRUE 21757
21755: GO 22335
21757: POP
// begin if GetClass ( i ) = 1 then
21758: LD_VAR 0 6
21762: PPUSH
21763: CALL_OW 257
21767: PUSH
21768: LD_INT 1
21770: EQUAL
21771: IFFALSE 21792
// points := [ 10 , 5 , 3 ] ;
21773: LD_ADDR_VAR 0 9
21777: PUSH
21778: LD_INT 10
21780: PUSH
21781: LD_INT 5
21783: PUSH
21784: LD_INT 3
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: LIST
21791: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21792: LD_VAR 0 6
21796: PPUSH
21797: CALL_OW 257
21801: PUSH
21802: LD_INT 2
21804: PUSH
21805: LD_INT 3
21807: PUSH
21808: LD_INT 4
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: IN
21816: IFFALSE 21837
// points := [ 3 , 2 , 1 ] ;
21818: LD_ADDR_VAR 0 9
21822: PUSH
21823: LD_INT 3
21825: PUSH
21826: LD_INT 2
21828: PUSH
21829: LD_INT 1
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21837: LD_VAR 0 6
21841: PPUSH
21842: CALL_OW 257
21846: PUSH
21847: LD_INT 5
21849: EQUAL
21850: IFFALSE 21871
// points := [ 130 , 5 , 2 ] ;
21852: LD_ADDR_VAR 0 9
21856: PUSH
21857: LD_INT 130
21859: PUSH
21860: LD_INT 5
21862: PUSH
21863: LD_INT 2
21865: PUSH
21866: EMPTY
21867: LIST
21868: LIST
21869: LIST
21870: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21871: LD_VAR 0 6
21875: PPUSH
21876: CALL_OW 257
21880: PUSH
21881: LD_INT 8
21883: EQUAL
21884: IFFALSE 21905
// points := [ 35 , 35 , 30 ] ;
21886: LD_ADDR_VAR 0 9
21890: PUSH
21891: LD_INT 35
21893: PUSH
21894: LD_INT 35
21896: PUSH
21897: LD_INT 30
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21905: LD_VAR 0 6
21909: PPUSH
21910: CALL_OW 257
21914: PUSH
21915: LD_INT 9
21917: EQUAL
21918: IFFALSE 21939
// points := [ 20 , 55 , 40 ] ;
21920: LD_ADDR_VAR 0 9
21924: PUSH
21925: LD_INT 20
21927: PUSH
21928: LD_INT 55
21930: PUSH
21931: LD_INT 40
21933: PUSH
21934: EMPTY
21935: LIST
21936: LIST
21937: LIST
21938: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21939: LD_VAR 0 6
21943: PPUSH
21944: CALL_OW 257
21948: PUSH
21949: LD_INT 12
21951: PUSH
21952: LD_INT 16
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: IN
21959: IFFALSE 21980
// points := [ 5 , 3 , 2 ] ;
21961: LD_ADDR_VAR 0 9
21965: PUSH
21966: LD_INT 5
21968: PUSH
21969: LD_INT 3
21971: PUSH
21972: LD_INT 2
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: LIST
21979: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21980: LD_VAR 0 6
21984: PPUSH
21985: CALL_OW 257
21989: PUSH
21990: LD_INT 17
21992: EQUAL
21993: IFFALSE 22014
// points := [ 100 , 50 , 75 ] ;
21995: LD_ADDR_VAR 0 9
21999: PUSH
22000: LD_INT 100
22002: PUSH
22003: LD_INT 50
22005: PUSH
22006: LD_INT 75
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: LIST
22013: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22014: LD_VAR 0 6
22018: PPUSH
22019: CALL_OW 257
22023: PUSH
22024: LD_INT 15
22026: EQUAL
22027: IFFALSE 22048
// points := [ 10 , 5 , 3 ] ;
22029: LD_ADDR_VAR 0 9
22033: PUSH
22034: LD_INT 10
22036: PUSH
22037: LD_INT 5
22039: PUSH
22040: LD_INT 3
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: LIST
22047: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22048: LD_VAR 0 6
22052: PPUSH
22053: CALL_OW 257
22057: PUSH
22058: LD_INT 14
22060: EQUAL
22061: IFFALSE 22082
// points := [ 10 , 0 , 0 ] ;
22063: LD_ADDR_VAR 0 9
22067: PUSH
22068: LD_INT 10
22070: PUSH
22071: LD_INT 0
22073: PUSH
22074: LD_INT 0
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: LIST
22081: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 257
22091: PUSH
22092: LD_INT 11
22094: EQUAL
22095: IFFALSE 22116
// points := [ 30 , 10 , 5 ] ;
22097: LD_ADDR_VAR 0 9
22101: PUSH
22102: LD_INT 30
22104: PUSH
22105: LD_INT 10
22107: PUSH
22108: LD_INT 5
22110: PUSH
22111: EMPTY
22112: LIST
22113: LIST
22114: LIST
22115: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22116: LD_VAR 0 1
22120: PPUSH
22121: LD_INT 5
22123: PPUSH
22124: CALL_OW 321
22128: PUSH
22129: LD_INT 2
22131: EQUAL
22132: IFFALSE 22149
// bpoints := bpoints * 1.8 ;
22134: LD_ADDR_VAR 0 10
22138: PUSH
22139: LD_VAR 0 10
22143: PUSH
22144: LD_REAL  1.80000000000000E+0000
22147: MUL
22148: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22149: LD_VAR 0 6
22153: PPUSH
22154: CALL_OW 257
22158: PUSH
22159: LD_INT 1
22161: PUSH
22162: LD_INT 2
22164: PUSH
22165: LD_INT 3
22167: PUSH
22168: LD_INT 4
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: IN
22177: PUSH
22178: LD_VAR 0 1
22182: PPUSH
22183: LD_INT 51
22185: PPUSH
22186: CALL_OW 321
22190: PUSH
22191: LD_INT 2
22193: EQUAL
22194: AND
22195: IFFALSE 22212
// bpoints := bpoints * 1.2 ;
22197: LD_ADDR_VAR 0 10
22201: PUSH
22202: LD_VAR 0 10
22206: PUSH
22207: LD_REAL  1.20000000000000E+0000
22210: MUL
22211: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22212: LD_VAR 0 6
22216: PPUSH
22217: CALL_OW 257
22221: PUSH
22222: LD_INT 5
22224: PUSH
22225: LD_INT 7
22227: PUSH
22228: LD_INT 9
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: LIST
22235: IN
22236: PUSH
22237: LD_VAR 0 1
22241: PPUSH
22242: LD_INT 52
22244: PPUSH
22245: CALL_OW 321
22249: PUSH
22250: LD_INT 2
22252: EQUAL
22253: AND
22254: IFFALSE 22271
// bpoints := bpoints * 1.5 ;
22256: LD_ADDR_VAR 0 10
22260: PUSH
22261: LD_VAR 0 10
22265: PUSH
22266: LD_REAL  1.50000000000000E+0000
22269: MUL
22270: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22271: LD_VAR 0 1
22275: PPUSH
22276: LD_INT 66
22278: PPUSH
22279: CALL_OW 321
22283: PUSH
22284: LD_INT 2
22286: EQUAL
22287: IFFALSE 22304
// bpoints := bpoints * 1.1 ;
22289: LD_ADDR_VAR 0 10
22293: PUSH
22294: LD_VAR 0 10
22298: PUSH
22299: LD_REAL  1.10000000000000E+0000
22302: MUL
22303: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22304: LD_ADDR_VAR 0 10
22308: PUSH
22309: LD_VAR 0 10
22313: PUSH
22314: LD_VAR 0 6
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: CALL_OW 259
22326: PUSH
22327: LD_REAL  1.15000000000000E+0000
22330: MUL
22331: MUL
22332: ST_TO_ADDR
// end ; unit_vehicle :
22333: GO 23157
22335: LD_INT 2
22337: DOUBLE
22338: EQUAL
22339: IFTRUE 22343
22341: GO 23145
22343: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22344: LD_VAR 0 6
22348: PPUSH
22349: CALL_OW 264
22353: PUSH
22354: LD_INT 2
22356: PUSH
22357: LD_INT 42
22359: PUSH
22360: LD_INT 24
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: IN
22368: IFFALSE 22389
// points := [ 25 , 5 , 3 ] ;
22370: LD_ADDR_VAR 0 9
22374: PUSH
22375: LD_INT 25
22377: PUSH
22378: LD_INT 5
22380: PUSH
22381: LD_INT 3
22383: PUSH
22384: EMPTY
22385: LIST
22386: LIST
22387: LIST
22388: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22389: LD_VAR 0 6
22393: PPUSH
22394: CALL_OW 264
22398: PUSH
22399: LD_INT 4
22401: PUSH
22402: LD_INT 43
22404: PUSH
22405: LD_INT 25
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: LIST
22412: IN
22413: IFFALSE 22434
// points := [ 40 , 15 , 5 ] ;
22415: LD_ADDR_VAR 0 9
22419: PUSH
22420: LD_INT 40
22422: PUSH
22423: LD_INT 15
22425: PUSH
22426: LD_INT 5
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22434: LD_VAR 0 6
22438: PPUSH
22439: CALL_OW 264
22443: PUSH
22444: LD_INT 3
22446: PUSH
22447: LD_INT 23
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: IN
22454: IFFALSE 22475
// points := [ 7 , 25 , 8 ] ;
22456: LD_ADDR_VAR 0 9
22460: PUSH
22461: LD_INT 7
22463: PUSH
22464: LD_INT 25
22466: PUSH
22467: LD_INT 8
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: LIST
22474: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22475: LD_VAR 0 6
22479: PPUSH
22480: CALL_OW 264
22484: PUSH
22485: LD_INT 5
22487: PUSH
22488: LD_INT 27
22490: PUSH
22491: LD_INT 44
22493: PUSH
22494: EMPTY
22495: LIST
22496: LIST
22497: LIST
22498: IN
22499: IFFALSE 22520
// points := [ 14 , 50 , 16 ] ;
22501: LD_ADDR_VAR 0 9
22505: PUSH
22506: LD_INT 14
22508: PUSH
22509: LD_INT 50
22511: PUSH
22512: LD_INT 16
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: LIST
22519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22520: LD_VAR 0 6
22524: PPUSH
22525: CALL_OW 264
22529: PUSH
22530: LD_INT 6
22532: PUSH
22533: LD_INT 46
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: IN
22540: IFFALSE 22561
// points := [ 32 , 120 , 70 ] ;
22542: LD_ADDR_VAR 0 9
22546: PUSH
22547: LD_INT 32
22549: PUSH
22550: LD_INT 120
22552: PUSH
22553: LD_INT 70
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: LIST
22560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22561: LD_VAR 0 6
22565: PPUSH
22566: CALL_OW 264
22570: PUSH
22571: LD_INT 7
22573: PUSH
22574: LD_INT 28
22576: PUSH
22577: LD_INT 45
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: IN
22585: IFFALSE 22606
// points := [ 35 , 20 , 45 ] ;
22587: LD_ADDR_VAR 0 9
22591: PUSH
22592: LD_INT 35
22594: PUSH
22595: LD_INT 20
22597: PUSH
22598: LD_INT 45
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: LIST
22605: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22606: LD_VAR 0 6
22610: PPUSH
22611: CALL_OW 264
22615: PUSH
22616: LD_INT 47
22618: PUSH
22619: EMPTY
22620: LIST
22621: IN
22622: IFFALSE 22643
// points := [ 67 , 45 , 75 ] ;
22624: LD_ADDR_VAR 0 9
22628: PUSH
22629: LD_INT 67
22631: PUSH
22632: LD_INT 45
22634: PUSH
22635: LD_INT 75
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: LIST
22642: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22643: LD_VAR 0 6
22647: PPUSH
22648: CALL_OW 264
22652: PUSH
22653: LD_INT 26
22655: PUSH
22656: EMPTY
22657: LIST
22658: IN
22659: IFFALSE 22680
// points := [ 120 , 30 , 80 ] ;
22661: LD_ADDR_VAR 0 9
22665: PUSH
22666: LD_INT 120
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 80
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22680: LD_VAR 0 6
22684: PPUSH
22685: CALL_OW 264
22689: PUSH
22690: LD_INT 22
22692: PUSH
22693: EMPTY
22694: LIST
22695: IN
22696: IFFALSE 22717
// points := [ 40 , 1 , 1 ] ;
22698: LD_ADDR_VAR 0 9
22702: PUSH
22703: LD_INT 40
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: LD_INT 1
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22717: LD_VAR 0 6
22721: PPUSH
22722: CALL_OW 264
22726: PUSH
22727: LD_INT 29
22729: PUSH
22730: EMPTY
22731: LIST
22732: IN
22733: IFFALSE 22754
// points := [ 70 , 200 , 400 ] ;
22735: LD_ADDR_VAR 0 9
22739: PUSH
22740: LD_INT 70
22742: PUSH
22743: LD_INT 200
22745: PUSH
22746: LD_INT 400
22748: PUSH
22749: EMPTY
22750: LIST
22751: LIST
22752: LIST
22753: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22754: LD_VAR 0 6
22758: PPUSH
22759: CALL_OW 264
22763: PUSH
22764: LD_INT 14
22766: PUSH
22767: LD_INT 53
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: IN
22774: IFFALSE 22795
// points := [ 40 , 10 , 20 ] ;
22776: LD_ADDR_VAR 0 9
22780: PUSH
22781: LD_INT 40
22783: PUSH
22784: LD_INT 10
22786: PUSH
22787: LD_INT 20
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 264
22804: PUSH
22805: LD_INT 9
22807: PUSH
22808: EMPTY
22809: LIST
22810: IN
22811: IFFALSE 22832
// points := [ 5 , 70 , 20 ] ;
22813: LD_ADDR_VAR 0 9
22817: PUSH
22818: LD_INT 5
22820: PUSH
22821: LD_INT 70
22823: PUSH
22824: LD_INT 20
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: LIST
22831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22832: LD_VAR 0 6
22836: PPUSH
22837: CALL_OW 264
22841: PUSH
22842: LD_INT 10
22844: PUSH
22845: EMPTY
22846: LIST
22847: IN
22848: IFFALSE 22869
// points := [ 35 , 110 , 70 ] ;
22850: LD_ADDR_VAR 0 9
22854: PUSH
22855: LD_INT 35
22857: PUSH
22858: LD_INT 110
22860: PUSH
22861: LD_INT 70
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: LIST
22868: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22869: LD_VAR 0 6
22873: PPUSH
22874: CALL_OW 265
22878: PUSH
22879: LD_INT 25
22881: EQUAL
22882: IFFALSE 22903
// points := [ 80 , 65 , 100 ] ;
22884: LD_ADDR_VAR 0 9
22888: PUSH
22889: LD_INT 80
22891: PUSH
22892: LD_INT 65
22894: PUSH
22895: LD_INT 100
22897: PUSH
22898: EMPTY
22899: LIST
22900: LIST
22901: LIST
22902: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22903: LD_VAR 0 6
22907: PPUSH
22908: CALL_OW 263
22912: PUSH
22913: LD_INT 1
22915: EQUAL
22916: IFFALSE 22951
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22918: LD_ADDR_VAR 0 10
22922: PUSH
22923: LD_VAR 0 10
22927: PUSH
22928: LD_VAR 0 6
22932: PPUSH
22933: CALL_OW 311
22937: PPUSH
22938: LD_INT 3
22940: PPUSH
22941: CALL_OW 259
22945: PUSH
22946: LD_INT 4
22948: MUL
22949: MUL
22950: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22951: LD_VAR 0 6
22955: PPUSH
22956: CALL_OW 263
22960: PUSH
22961: LD_INT 2
22963: EQUAL
22964: IFFALSE 23015
// begin j := IsControledBy ( i ) ;
22966: LD_ADDR_VAR 0 7
22970: PUSH
22971: LD_VAR 0 6
22975: PPUSH
22976: CALL_OW 312
22980: ST_TO_ADDR
// if j then
22981: LD_VAR 0 7
22985: IFFALSE 23015
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22987: LD_ADDR_VAR 0 10
22991: PUSH
22992: LD_VAR 0 10
22996: PUSH
22997: LD_VAR 0 7
23001: PPUSH
23002: LD_INT 3
23004: PPUSH
23005: CALL_OW 259
23009: PUSH
23010: LD_INT 3
23012: MUL
23013: MUL
23014: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23015: LD_VAR 0 6
23019: PPUSH
23020: CALL_OW 264
23024: PUSH
23025: LD_INT 5
23027: PUSH
23028: LD_INT 6
23030: PUSH
23031: LD_INT 46
23033: PUSH
23034: LD_INT 44
23036: PUSH
23037: LD_INT 47
23039: PUSH
23040: LD_INT 45
23042: PUSH
23043: LD_INT 28
23045: PUSH
23046: LD_INT 7
23048: PUSH
23049: LD_INT 27
23051: PUSH
23052: LD_INT 29
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: LIST
23065: LIST
23066: IN
23067: PUSH
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_INT 52
23075: PPUSH
23076: CALL_OW 321
23080: PUSH
23081: LD_INT 2
23083: EQUAL
23084: AND
23085: IFFALSE 23102
// bpoints := bpoints * 1.2 ;
23087: LD_ADDR_VAR 0 10
23091: PUSH
23092: LD_VAR 0 10
23096: PUSH
23097: LD_REAL  1.20000000000000E+0000
23100: MUL
23101: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23102: LD_VAR 0 6
23106: PPUSH
23107: CALL_OW 264
23111: PUSH
23112: LD_INT 6
23114: PUSH
23115: LD_INT 46
23117: PUSH
23118: LD_INT 47
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: LIST
23125: IN
23126: IFFALSE 23143
// bpoints := bpoints * 1.2 ;
23128: LD_ADDR_VAR 0 10
23132: PUSH
23133: LD_VAR 0 10
23137: PUSH
23138: LD_REAL  1.20000000000000E+0000
23141: MUL
23142: ST_TO_ADDR
// end ; unit_building :
23143: GO 23157
23145: LD_INT 3
23147: DOUBLE
23148: EQUAL
23149: IFTRUE 23153
23151: GO 23156
23153: POP
// ; end ;
23154: GO 23157
23156: POP
// for j = 1 to 3 do
23157: LD_ADDR_VAR 0 7
23161: PUSH
23162: DOUBLE
23163: LD_INT 1
23165: DEC
23166: ST_TO_ADDR
23167: LD_INT 3
23169: PUSH
23170: FOR_TO
23171: IFFALSE 23224
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23173: LD_ADDR_VAR 0 5
23177: PUSH
23178: LD_VAR 0 5
23182: PPUSH
23183: LD_VAR 0 7
23187: PPUSH
23188: LD_VAR 0 5
23192: PUSH
23193: LD_VAR 0 7
23197: ARRAY
23198: PUSH
23199: LD_VAR 0 9
23203: PUSH
23204: LD_VAR 0 7
23208: ARRAY
23209: PUSH
23210: LD_VAR 0 10
23214: MUL
23215: PLUS
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
23222: GO 23170
23224: POP
23225: POP
// end ;
23226: GO 21709
23228: POP
23229: POP
// result := Replace ( result , 4 , tmp ) ;
23230: LD_ADDR_VAR 0 5
23234: PUSH
23235: LD_VAR 0 5
23239: PPUSH
23240: LD_INT 4
23242: PPUSH
23243: LD_VAR 0 8
23247: PPUSH
23248: CALL_OW 1
23252: ST_TO_ADDR
// end ;
23253: LD_VAR 0 5
23257: RET
// export function DangerAtRange ( unit , range ) ; begin
23258: LD_INT 0
23260: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23261: LD_ADDR_VAR 0 3
23265: PUSH
23266: LD_VAR 0 1
23270: PPUSH
23271: CALL_OW 255
23275: PPUSH
23276: LD_VAR 0 1
23280: PPUSH
23281: CALL_OW 250
23285: PPUSH
23286: LD_VAR 0 1
23290: PPUSH
23291: CALL_OW 251
23295: PPUSH
23296: LD_VAR 0 2
23300: PPUSH
23301: CALL 21561 0 4
23305: ST_TO_ADDR
// end ;
23306: LD_VAR 0 3
23310: RET
// export function DangerInArea ( side , area ) ; begin
23311: LD_INT 0
23313: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_VAR 0 2
23323: PPUSH
23324: LD_INT 81
23326: PUSH
23327: LD_VAR 0 1
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: PPUSH
23336: CALL_OW 70
23340: ST_TO_ADDR
// end ;
23341: LD_VAR 0 3
23345: RET
// export function IsExtension ( b ) ; begin
23346: LD_INT 0
23348: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23349: LD_ADDR_VAR 0 2
23353: PUSH
23354: LD_VAR 0 1
23358: PUSH
23359: LD_INT 23
23361: PUSH
23362: LD_INT 20
23364: PUSH
23365: LD_INT 22
23367: PUSH
23368: LD_INT 17
23370: PUSH
23371: LD_INT 24
23373: PUSH
23374: LD_INT 21
23376: PUSH
23377: LD_INT 19
23379: PUSH
23380: LD_INT 16
23382: PUSH
23383: LD_INT 25
23385: PUSH
23386: LD_INT 18
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: IN
23401: ST_TO_ADDR
// end ;
23402: LD_VAR 0 2
23406: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23407: LD_INT 0
23409: PPUSH
23410: PPUSH
23411: PPUSH
// result := [ ] ;
23412: LD_ADDR_VAR 0 3
23416: PUSH
23417: EMPTY
23418: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23419: LD_ADDR_VAR 0 4
23423: PUSH
23424: LD_VAR 0 2
23428: PPUSH
23429: LD_INT 21
23431: PUSH
23432: LD_INT 3
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PPUSH
23439: CALL_OW 70
23443: ST_TO_ADDR
// if not tmp then
23444: LD_VAR 0 4
23448: NOT
23449: IFFALSE 23453
// exit ;
23451: GO 23511
// for i in tmp do
23453: LD_ADDR_VAR 0 5
23457: PUSH
23458: LD_VAR 0 4
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23499
// if GetBase ( i ) <> base then
23466: LD_VAR 0 5
23470: PPUSH
23471: CALL_OW 274
23475: PUSH
23476: LD_VAR 0 1
23480: NONEQUAL
23481: IFFALSE 23497
// ComLinkToBase ( base , i ) ;
23483: LD_VAR 0 1
23487: PPUSH
23488: LD_VAR 0 5
23492: PPUSH
23493: CALL_OW 169
23497: GO 23463
23499: POP
23500: POP
// result := tmp ;
23501: LD_ADDR_VAR 0 3
23505: PUSH
23506: LD_VAR 0 4
23510: ST_TO_ADDR
// end ;
23511: LD_VAR 0 3
23515: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23516: LD_INT 0
23518: PPUSH
23519: PPUSH
// if BuildingStatus ( b ) = bs_build then
23520: LD_VAR 0 2
23524: PPUSH
23525: CALL_OW 461
23529: PUSH
23530: LD_INT 1
23532: EQUAL
23533: IFFALSE 23593
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23535: LD_VAR 0 1
23539: PPUSH
23540: LD_STRING h
23542: PUSH
23543: LD_VAR 0 2
23547: PPUSH
23548: CALL_OW 250
23552: PUSH
23553: LD_VAR 0 2
23557: PPUSH
23558: CALL_OW 251
23562: PUSH
23563: LD_VAR 0 2
23567: PUSH
23568: LD_INT 0
23570: PUSH
23571: LD_INT 0
23573: PUSH
23574: LD_INT 0
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: PUSH
23586: EMPTY
23587: LIST
23588: PPUSH
23589: CALL_OW 446
// end ;
23593: LD_VAR 0 3
23597: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23598: LD_INT 0
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23606: LD_VAR 0 1
23610: NOT
23611: PUSH
23612: LD_VAR 0 1
23616: PPUSH
23617: CALL_OW 263
23621: PUSH
23622: LD_INT 2
23624: EQUAL
23625: NOT
23626: OR
23627: IFFALSE 23631
// exit ;
23629: GO 23947
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23631: LD_ADDR_VAR 0 6
23635: PUSH
23636: LD_INT 22
23638: PUSH
23639: LD_VAR 0 1
23643: PPUSH
23644: CALL_OW 255
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: PUSH
23653: LD_INT 2
23655: PUSH
23656: LD_INT 30
23658: PUSH
23659: LD_INT 36
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: PUSH
23666: LD_INT 34
23668: PUSH
23669: LD_INT 31
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: LIST
23680: PUSH
23681: EMPTY
23682: LIST
23683: LIST
23684: PPUSH
23685: CALL_OW 69
23689: ST_TO_ADDR
// if not tmp then
23690: LD_VAR 0 6
23694: NOT
23695: IFFALSE 23699
// exit ;
23697: GO 23947
// result := [ ] ;
23699: LD_ADDR_VAR 0 2
23703: PUSH
23704: EMPTY
23705: ST_TO_ADDR
// for i in tmp do
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_VAR 0 6
23715: PUSH
23716: FOR_IN
23717: IFFALSE 23788
// begin t := UnitsInside ( i ) ;
23719: LD_ADDR_VAR 0 4
23723: PUSH
23724: LD_VAR 0 3
23728: PPUSH
23729: CALL_OW 313
23733: ST_TO_ADDR
// if t then
23734: LD_VAR 0 4
23738: IFFALSE 23786
// for j in t do
23740: LD_ADDR_VAR 0 7
23744: PUSH
23745: LD_VAR 0 4
23749: PUSH
23750: FOR_IN
23751: IFFALSE 23784
// result := Insert ( result , result + 1 , j ) ;
23753: LD_ADDR_VAR 0 2
23757: PUSH
23758: LD_VAR 0 2
23762: PPUSH
23763: LD_VAR 0 2
23767: PUSH
23768: LD_INT 1
23770: PLUS
23771: PPUSH
23772: LD_VAR 0 7
23776: PPUSH
23777: CALL_OW 2
23781: ST_TO_ADDR
23782: GO 23750
23784: POP
23785: POP
// end ;
23786: GO 23716
23788: POP
23789: POP
// if not result then
23790: LD_VAR 0 2
23794: NOT
23795: IFFALSE 23799
// exit ;
23797: GO 23947
// mech := result [ 1 ] ;
23799: LD_ADDR_VAR 0 5
23803: PUSH
23804: LD_VAR 0 2
23808: PUSH
23809: LD_INT 1
23811: ARRAY
23812: ST_TO_ADDR
// if result > 1 then
23813: LD_VAR 0 2
23817: PUSH
23818: LD_INT 1
23820: GREATER
23821: IFFALSE 23933
// for i = 2 to result do
23823: LD_ADDR_VAR 0 3
23827: PUSH
23828: DOUBLE
23829: LD_INT 2
23831: DEC
23832: ST_TO_ADDR
23833: LD_VAR 0 2
23837: PUSH
23838: FOR_TO
23839: IFFALSE 23931
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23841: LD_ADDR_VAR 0 4
23845: PUSH
23846: LD_VAR 0 2
23850: PUSH
23851: LD_VAR 0 3
23855: ARRAY
23856: PPUSH
23857: LD_INT 3
23859: PPUSH
23860: CALL_OW 259
23864: PUSH
23865: LD_VAR 0 2
23869: PUSH
23870: LD_VAR 0 3
23874: ARRAY
23875: PPUSH
23876: CALL_OW 432
23880: MINUS
23881: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23882: LD_VAR 0 4
23886: PUSH
23887: LD_VAR 0 5
23891: PPUSH
23892: LD_INT 3
23894: PPUSH
23895: CALL_OW 259
23899: PUSH
23900: LD_VAR 0 5
23904: PPUSH
23905: CALL_OW 432
23909: MINUS
23910: GREATEREQUAL
23911: IFFALSE 23929
// mech := result [ i ] ;
23913: LD_ADDR_VAR 0 5
23917: PUSH
23918: LD_VAR 0 2
23922: PUSH
23923: LD_VAR 0 3
23927: ARRAY
23928: ST_TO_ADDR
// end ;
23929: GO 23838
23931: POP
23932: POP
// ComLinkTo ( vehicle , mech ) ;
23933: LD_VAR 0 1
23937: PPUSH
23938: LD_VAR 0 5
23942: PPUSH
23943: CALL_OW 135
// end ;
23947: LD_VAR 0 2
23951: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23952: LD_INT 0
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
// result := [ ] ;
23967: LD_ADDR_VAR 0 7
23971: PUSH
23972: EMPTY
23973: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23974: LD_VAR 0 1
23978: PPUSH
23979: CALL_OW 266
23983: PUSH
23984: LD_INT 0
23986: PUSH
23987: LD_INT 1
23989: PUSH
23990: EMPTY
23991: LIST
23992: LIST
23993: IN
23994: NOT
23995: IFFALSE 23999
// exit ;
23997: GO 25630
// if name then
23999: LD_VAR 0 3
24003: IFFALSE 24019
// SetBName ( base_dep , name ) ;
24005: LD_VAR 0 1
24009: PPUSH
24010: LD_VAR 0 3
24014: PPUSH
24015: CALL_OW 500
// base := GetBase ( base_dep ) ;
24019: LD_ADDR_VAR 0 15
24023: PUSH
24024: LD_VAR 0 1
24028: PPUSH
24029: CALL_OW 274
24033: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24034: LD_ADDR_VAR 0 16
24038: PUSH
24039: LD_VAR 0 1
24043: PPUSH
24044: CALL_OW 255
24048: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24049: LD_ADDR_VAR 0 17
24053: PUSH
24054: LD_VAR 0 1
24058: PPUSH
24059: CALL_OW 248
24063: ST_TO_ADDR
// if sources then
24064: LD_VAR 0 5
24068: IFFALSE 24115
// for i = 1 to 3 do
24070: LD_ADDR_VAR 0 8
24074: PUSH
24075: DOUBLE
24076: LD_INT 1
24078: DEC
24079: ST_TO_ADDR
24080: LD_INT 3
24082: PUSH
24083: FOR_TO
24084: IFFALSE 24113
// AddResourceType ( base , i , sources [ i ] ) ;
24086: LD_VAR 0 15
24090: PPUSH
24091: LD_VAR 0 8
24095: PPUSH
24096: LD_VAR 0 5
24100: PUSH
24101: LD_VAR 0 8
24105: ARRAY
24106: PPUSH
24107: CALL_OW 276
24111: GO 24083
24113: POP
24114: POP
// buildings := GetBaseBuildings ( base , area ) ;
24115: LD_ADDR_VAR 0 18
24119: PUSH
24120: LD_VAR 0 15
24124: PPUSH
24125: LD_VAR 0 2
24129: PPUSH
24130: CALL 23407 0 2
24134: ST_TO_ADDR
// InitHc ;
24135: CALL_OW 19
// InitUc ;
24139: CALL_OW 18
// uc_side := side ;
24143: LD_ADDR_OWVAR 20
24147: PUSH
24148: LD_VAR 0 16
24152: ST_TO_ADDR
// uc_nation := nation ;
24153: LD_ADDR_OWVAR 21
24157: PUSH
24158: LD_VAR 0 17
24162: ST_TO_ADDR
// if buildings then
24163: LD_VAR 0 18
24167: IFFALSE 25489
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24169: LD_ADDR_VAR 0 19
24173: PUSH
24174: LD_VAR 0 18
24178: PPUSH
24179: LD_INT 2
24181: PUSH
24182: LD_INT 30
24184: PUSH
24185: LD_INT 29
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PUSH
24192: LD_INT 30
24194: PUSH
24195: LD_INT 30
24197: PUSH
24198: EMPTY
24199: LIST
24200: LIST
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: LIST
24206: PPUSH
24207: CALL_OW 72
24211: ST_TO_ADDR
// if tmp then
24212: LD_VAR 0 19
24216: IFFALSE 24264
// for i in tmp do
24218: LD_ADDR_VAR 0 8
24222: PUSH
24223: LD_VAR 0 19
24227: PUSH
24228: FOR_IN
24229: IFFALSE 24262
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24231: LD_VAR 0 8
24235: PPUSH
24236: CALL_OW 250
24240: PPUSH
24241: LD_VAR 0 8
24245: PPUSH
24246: CALL_OW 251
24250: PPUSH
24251: LD_VAR 0 16
24255: PPUSH
24256: CALL_OW 441
24260: GO 24228
24262: POP
24263: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24264: LD_VAR 0 18
24268: PPUSH
24269: LD_INT 2
24271: PUSH
24272: LD_INT 30
24274: PUSH
24275: LD_INT 32
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 30
24284: PUSH
24285: LD_INT 33
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: LIST
24296: PPUSH
24297: CALL_OW 72
24301: IFFALSE 24389
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24303: LD_ADDR_VAR 0 8
24307: PUSH
24308: LD_VAR 0 18
24312: PPUSH
24313: LD_INT 2
24315: PUSH
24316: LD_INT 30
24318: PUSH
24319: LD_INT 32
24321: PUSH
24322: EMPTY
24323: LIST
24324: LIST
24325: PUSH
24326: LD_INT 30
24328: PUSH
24329: LD_INT 33
24331: PUSH
24332: EMPTY
24333: LIST
24334: LIST
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: PPUSH
24341: CALL_OW 72
24345: PUSH
24346: FOR_IN
24347: IFFALSE 24387
// begin if not GetBWeapon ( i ) then
24349: LD_VAR 0 8
24353: PPUSH
24354: CALL_OW 269
24358: NOT
24359: IFFALSE 24385
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24361: LD_VAR 0 8
24365: PPUSH
24366: LD_VAR 0 8
24370: PPUSH
24371: LD_VAR 0 2
24375: PPUSH
24376: CALL 25635 0 2
24380: PPUSH
24381: CALL_OW 431
// end ;
24385: GO 24346
24387: POP
24388: POP
// end ; for i = 1 to personel do
24389: LD_ADDR_VAR 0 8
24393: PUSH
24394: DOUBLE
24395: LD_INT 1
24397: DEC
24398: ST_TO_ADDR
24399: LD_VAR 0 6
24403: PUSH
24404: FOR_TO
24405: IFFALSE 25469
// begin if i > 4 then
24407: LD_VAR 0 8
24411: PUSH
24412: LD_INT 4
24414: GREATER
24415: IFFALSE 24419
// break ;
24417: GO 25469
// case i of 1 :
24419: LD_VAR 0 8
24423: PUSH
24424: LD_INT 1
24426: DOUBLE
24427: EQUAL
24428: IFTRUE 24432
24430: GO 24512
24432: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24433: LD_ADDR_VAR 0 12
24437: PUSH
24438: LD_VAR 0 18
24442: PPUSH
24443: LD_INT 22
24445: PUSH
24446: LD_VAR 0 16
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 58
24457: PUSH
24458: EMPTY
24459: LIST
24460: PUSH
24461: LD_INT 2
24463: PUSH
24464: LD_INT 30
24466: PUSH
24467: LD_INT 32
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 30
24476: PUSH
24477: LD_INT 4
24479: PUSH
24480: EMPTY
24481: LIST
24482: LIST
24483: PUSH
24484: LD_INT 30
24486: PUSH
24487: LD_INT 5
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: PPUSH
24505: CALL_OW 72
24509: ST_TO_ADDR
24510: GO 24734
24512: LD_INT 2
24514: DOUBLE
24515: EQUAL
24516: IFTRUE 24520
24518: GO 24582
24520: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24521: LD_ADDR_VAR 0 12
24525: PUSH
24526: LD_VAR 0 18
24530: PPUSH
24531: LD_INT 22
24533: PUSH
24534: LD_VAR 0 16
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: LD_INT 2
24545: PUSH
24546: LD_INT 30
24548: PUSH
24549: LD_INT 0
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: PUSH
24556: LD_INT 30
24558: PUSH
24559: LD_INT 1
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 72
24579: ST_TO_ADDR
24580: GO 24734
24582: LD_INT 3
24584: DOUBLE
24585: EQUAL
24586: IFTRUE 24590
24588: GO 24652
24590: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24591: LD_ADDR_VAR 0 12
24595: PUSH
24596: LD_VAR 0 18
24600: PPUSH
24601: LD_INT 22
24603: PUSH
24604: LD_VAR 0 16
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: PUSH
24613: LD_INT 2
24615: PUSH
24616: LD_INT 30
24618: PUSH
24619: LD_INT 2
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 30
24628: PUSH
24629: LD_INT 3
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: LIST
24640: PUSH
24641: EMPTY
24642: LIST
24643: LIST
24644: PPUSH
24645: CALL_OW 72
24649: ST_TO_ADDR
24650: GO 24734
24652: LD_INT 4
24654: DOUBLE
24655: EQUAL
24656: IFTRUE 24660
24658: GO 24733
24660: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24661: LD_ADDR_VAR 0 12
24665: PUSH
24666: LD_VAR 0 18
24670: PPUSH
24671: LD_INT 22
24673: PUSH
24674: LD_VAR 0 16
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 2
24685: PUSH
24686: LD_INT 30
24688: PUSH
24689: LD_INT 6
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 30
24698: PUSH
24699: LD_INT 7
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 30
24708: PUSH
24709: LD_INT 8
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PPUSH
24726: CALL_OW 72
24730: ST_TO_ADDR
24731: GO 24734
24733: POP
// if i = 1 then
24734: LD_VAR 0 8
24738: PUSH
24739: LD_INT 1
24741: EQUAL
24742: IFFALSE 24853
// begin tmp := [ ] ;
24744: LD_ADDR_VAR 0 19
24748: PUSH
24749: EMPTY
24750: ST_TO_ADDR
// for j in f do
24751: LD_ADDR_VAR 0 9
24755: PUSH
24756: LD_VAR 0 12
24760: PUSH
24761: FOR_IN
24762: IFFALSE 24835
// if GetBType ( j ) = b_bunker then
24764: LD_VAR 0 9
24768: PPUSH
24769: CALL_OW 266
24773: PUSH
24774: LD_INT 32
24776: EQUAL
24777: IFFALSE 24804
// tmp := Insert ( tmp , 1 , j ) else
24779: LD_ADDR_VAR 0 19
24783: PUSH
24784: LD_VAR 0 19
24788: PPUSH
24789: LD_INT 1
24791: PPUSH
24792: LD_VAR 0 9
24796: PPUSH
24797: CALL_OW 2
24801: ST_TO_ADDR
24802: GO 24833
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24804: LD_ADDR_VAR 0 19
24808: PUSH
24809: LD_VAR 0 19
24813: PPUSH
24814: LD_VAR 0 19
24818: PUSH
24819: LD_INT 1
24821: PLUS
24822: PPUSH
24823: LD_VAR 0 9
24827: PPUSH
24828: CALL_OW 2
24832: ST_TO_ADDR
24833: GO 24761
24835: POP
24836: POP
// if tmp then
24837: LD_VAR 0 19
24841: IFFALSE 24853
// f := tmp ;
24843: LD_ADDR_VAR 0 12
24847: PUSH
24848: LD_VAR 0 19
24852: ST_TO_ADDR
// end ; x := personel [ i ] ;
24853: LD_ADDR_VAR 0 13
24857: PUSH
24858: LD_VAR 0 6
24862: PUSH
24863: LD_VAR 0 8
24867: ARRAY
24868: ST_TO_ADDR
// if x = - 1 then
24869: LD_VAR 0 13
24873: PUSH
24874: LD_INT 1
24876: NEG
24877: EQUAL
24878: IFFALSE 25087
// begin for j in f do
24880: LD_ADDR_VAR 0 9
24884: PUSH
24885: LD_VAR 0 12
24889: PUSH
24890: FOR_IN
24891: IFFALSE 25083
// repeat InitHc ;
24893: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24897: LD_VAR 0 9
24901: PPUSH
24902: CALL_OW 266
24906: PUSH
24907: LD_INT 5
24909: EQUAL
24910: IFFALSE 24980
// begin if UnitsInside ( j ) < 3 then
24912: LD_VAR 0 9
24916: PPUSH
24917: CALL_OW 313
24921: PUSH
24922: LD_INT 3
24924: LESS
24925: IFFALSE 24961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24927: LD_INT 0
24929: PPUSH
24930: LD_INT 5
24932: PUSH
24933: LD_INT 8
24935: PUSH
24936: LD_INT 9
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: LIST
24943: PUSH
24944: LD_VAR 0 17
24948: ARRAY
24949: PPUSH
24950: LD_VAR 0 4
24954: PPUSH
24955: CALL_OW 380
24959: GO 24978
// PrepareHuman ( false , i , skill ) ;
24961: LD_INT 0
24963: PPUSH
24964: LD_VAR 0 8
24968: PPUSH
24969: LD_VAR 0 4
24973: PPUSH
24974: CALL_OW 380
// end else
24978: GO 24997
// PrepareHuman ( false , i , skill ) ;
24980: LD_INT 0
24982: PPUSH
24983: LD_VAR 0 8
24987: PPUSH
24988: LD_VAR 0 4
24992: PPUSH
24993: CALL_OW 380
// un := CreateHuman ;
24997: LD_ADDR_VAR 0 14
25001: PUSH
25002: CALL_OW 44
25006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25007: LD_ADDR_VAR 0 7
25011: PUSH
25012: LD_VAR 0 7
25016: PPUSH
25017: LD_INT 1
25019: PPUSH
25020: LD_VAR 0 14
25024: PPUSH
25025: CALL_OW 2
25029: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25030: LD_VAR 0 14
25034: PPUSH
25035: LD_VAR 0 9
25039: PPUSH
25040: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25044: LD_VAR 0 9
25048: PPUSH
25049: CALL_OW 313
25053: PUSH
25054: LD_INT 6
25056: EQUAL
25057: PUSH
25058: LD_VAR 0 9
25062: PPUSH
25063: CALL_OW 266
25067: PUSH
25068: LD_INT 32
25070: PUSH
25071: LD_INT 31
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: IN
25078: OR
25079: IFFALSE 24893
25081: GO 24890
25083: POP
25084: POP
// end else
25085: GO 25467
// for j = 1 to x do
25087: LD_ADDR_VAR 0 9
25091: PUSH
25092: DOUBLE
25093: LD_INT 1
25095: DEC
25096: ST_TO_ADDR
25097: LD_VAR 0 13
25101: PUSH
25102: FOR_TO
25103: IFFALSE 25465
// begin InitHc ;
25105: CALL_OW 19
// if not f then
25109: LD_VAR 0 12
25113: NOT
25114: IFFALSE 25203
// begin PrepareHuman ( false , i , skill ) ;
25116: LD_INT 0
25118: PPUSH
25119: LD_VAR 0 8
25123: PPUSH
25124: LD_VAR 0 4
25128: PPUSH
25129: CALL_OW 380
// un := CreateHuman ;
25133: LD_ADDR_VAR 0 14
25137: PUSH
25138: CALL_OW 44
25142: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25143: LD_ADDR_VAR 0 7
25147: PUSH
25148: LD_VAR 0 7
25152: PPUSH
25153: LD_INT 1
25155: PPUSH
25156: LD_VAR 0 14
25160: PPUSH
25161: CALL_OW 2
25165: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25166: LD_VAR 0 14
25170: PPUSH
25171: LD_VAR 0 1
25175: PPUSH
25176: CALL_OW 250
25180: PPUSH
25181: LD_VAR 0 1
25185: PPUSH
25186: CALL_OW 251
25190: PPUSH
25191: LD_INT 10
25193: PPUSH
25194: LD_INT 0
25196: PPUSH
25197: CALL_OW 50
// continue ;
25201: GO 25102
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25203: LD_VAR 0 12
25207: PUSH
25208: LD_INT 1
25210: ARRAY
25211: PPUSH
25212: CALL_OW 313
25216: PUSH
25217: LD_VAR 0 12
25221: PUSH
25222: LD_INT 1
25224: ARRAY
25225: PPUSH
25226: CALL_OW 266
25230: PUSH
25231: LD_INT 32
25233: PUSH
25234: LD_INT 31
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: IN
25241: AND
25242: PUSH
25243: LD_VAR 0 12
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: PPUSH
25252: CALL_OW 313
25256: PUSH
25257: LD_INT 6
25259: EQUAL
25260: OR
25261: IFFALSE 25281
// f := Delete ( f , 1 ) ;
25263: LD_ADDR_VAR 0 12
25267: PUSH
25268: LD_VAR 0 12
25272: PPUSH
25273: LD_INT 1
25275: PPUSH
25276: CALL_OW 3
25280: ST_TO_ADDR
// if not f then
25281: LD_VAR 0 12
25285: NOT
25286: IFFALSE 25304
// begin x := x + 2 ;
25288: LD_ADDR_VAR 0 13
25292: PUSH
25293: LD_VAR 0 13
25297: PUSH
25298: LD_INT 2
25300: PLUS
25301: ST_TO_ADDR
// continue ;
25302: GO 25102
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25304: LD_VAR 0 12
25308: PUSH
25309: LD_INT 1
25311: ARRAY
25312: PPUSH
25313: CALL_OW 266
25317: PUSH
25318: LD_INT 5
25320: EQUAL
25321: IFFALSE 25395
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25323: LD_VAR 0 12
25327: PUSH
25328: LD_INT 1
25330: ARRAY
25331: PPUSH
25332: CALL_OW 313
25336: PUSH
25337: LD_INT 3
25339: LESS
25340: IFFALSE 25376
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25342: LD_INT 0
25344: PPUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 8
25350: PUSH
25351: LD_INT 9
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: LIST
25358: PUSH
25359: LD_VAR 0 17
25363: ARRAY
25364: PPUSH
25365: LD_VAR 0 4
25369: PPUSH
25370: CALL_OW 380
25374: GO 25393
// PrepareHuman ( false , i , skill ) ;
25376: LD_INT 0
25378: PPUSH
25379: LD_VAR 0 8
25383: PPUSH
25384: LD_VAR 0 4
25388: PPUSH
25389: CALL_OW 380
// end else
25393: GO 25412
// PrepareHuman ( false , i , skill ) ;
25395: LD_INT 0
25397: PPUSH
25398: LD_VAR 0 8
25402: PPUSH
25403: LD_VAR 0 4
25407: PPUSH
25408: CALL_OW 380
// un := CreateHuman ;
25412: LD_ADDR_VAR 0 14
25416: PUSH
25417: CALL_OW 44
25421: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25422: LD_ADDR_VAR 0 7
25426: PUSH
25427: LD_VAR 0 7
25431: PPUSH
25432: LD_INT 1
25434: PPUSH
25435: LD_VAR 0 14
25439: PPUSH
25440: CALL_OW 2
25444: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25445: LD_VAR 0 14
25449: PPUSH
25450: LD_VAR 0 12
25454: PUSH
25455: LD_INT 1
25457: ARRAY
25458: PPUSH
25459: CALL_OW 52
// end ;
25463: GO 25102
25465: POP
25466: POP
// end ;
25467: GO 24404
25469: POP
25470: POP
// result := result ^ buildings ;
25471: LD_ADDR_VAR 0 7
25475: PUSH
25476: LD_VAR 0 7
25480: PUSH
25481: LD_VAR 0 18
25485: ADD
25486: ST_TO_ADDR
// end else
25487: GO 25630
// begin for i = 1 to personel do
25489: LD_ADDR_VAR 0 8
25493: PUSH
25494: DOUBLE
25495: LD_INT 1
25497: DEC
25498: ST_TO_ADDR
25499: LD_VAR 0 6
25503: PUSH
25504: FOR_TO
25505: IFFALSE 25628
// begin if i > 4 then
25507: LD_VAR 0 8
25511: PUSH
25512: LD_INT 4
25514: GREATER
25515: IFFALSE 25519
// break ;
25517: GO 25628
// x := personel [ i ] ;
25519: LD_ADDR_VAR 0 13
25523: PUSH
25524: LD_VAR 0 6
25528: PUSH
25529: LD_VAR 0 8
25533: ARRAY
25534: ST_TO_ADDR
// if x = - 1 then
25535: LD_VAR 0 13
25539: PUSH
25540: LD_INT 1
25542: NEG
25543: EQUAL
25544: IFFALSE 25548
// continue ;
25546: GO 25504
// PrepareHuman ( false , i , skill ) ;
25548: LD_INT 0
25550: PPUSH
25551: LD_VAR 0 8
25555: PPUSH
25556: LD_VAR 0 4
25560: PPUSH
25561: CALL_OW 380
// un := CreateHuman ;
25565: LD_ADDR_VAR 0 14
25569: PUSH
25570: CALL_OW 44
25574: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25575: LD_VAR 0 14
25579: PPUSH
25580: LD_VAR 0 1
25584: PPUSH
25585: CALL_OW 250
25589: PPUSH
25590: LD_VAR 0 1
25594: PPUSH
25595: CALL_OW 251
25599: PPUSH
25600: LD_INT 10
25602: PPUSH
25603: LD_INT 0
25605: PPUSH
25606: CALL_OW 50
// result := result ^ un ;
25610: LD_ADDR_VAR 0 7
25614: PUSH
25615: LD_VAR 0 7
25619: PUSH
25620: LD_VAR 0 14
25624: ADD
25625: ST_TO_ADDR
// end ;
25626: GO 25504
25628: POP
25629: POP
// end ; end ;
25630: LD_VAR 0 7
25634: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25635: LD_INT 0
25637: PPUSH
25638: PPUSH
25639: PPUSH
25640: PPUSH
25641: PPUSH
25642: PPUSH
25643: PPUSH
25644: PPUSH
25645: PPUSH
25646: PPUSH
25647: PPUSH
25648: PPUSH
25649: PPUSH
25650: PPUSH
25651: PPUSH
25652: PPUSH
// result := false ;
25653: LD_ADDR_VAR 0 3
25657: PUSH
25658: LD_INT 0
25660: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25661: LD_VAR 0 1
25665: NOT
25666: PUSH
25667: LD_VAR 0 1
25671: PPUSH
25672: CALL_OW 266
25676: PUSH
25677: LD_INT 32
25679: PUSH
25680: LD_INT 33
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: IN
25687: NOT
25688: OR
25689: IFFALSE 25693
// exit ;
25691: GO 26829
// nat := GetNation ( tower ) ;
25693: LD_ADDR_VAR 0 12
25697: PUSH
25698: LD_VAR 0 1
25702: PPUSH
25703: CALL_OW 248
25707: ST_TO_ADDR
// side := GetSide ( tower ) ;
25708: LD_ADDR_VAR 0 16
25712: PUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: CALL_OW 255
25722: ST_TO_ADDR
// x := GetX ( tower ) ;
25723: LD_ADDR_VAR 0 10
25727: PUSH
25728: LD_VAR 0 1
25732: PPUSH
25733: CALL_OW 250
25737: ST_TO_ADDR
// y := GetY ( tower ) ;
25738: LD_ADDR_VAR 0 11
25742: PUSH
25743: LD_VAR 0 1
25747: PPUSH
25748: CALL_OW 251
25752: ST_TO_ADDR
// if not x or not y then
25753: LD_VAR 0 10
25757: NOT
25758: PUSH
25759: LD_VAR 0 11
25763: NOT
25764: OR
25765: IFFALSE 25769
// exit ;
25767: GO 26829
// weapon := 0 ;
25769: LD_ADDR_VAR 0 18
25773: PUSH
25774: LD_INT 0
25776: ST_TO_ADDR
// fac_list := [ ] ;
25777: LD_ADDR_VAR 0 17
25781: PUSH
25782: EMPTY
25783: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25784: LD_ADDR_VAR 0 6
25788: PUSH
25789: LD_VAR 0 1
25793: PPUSH
25794: CALL_OW 274
25798: PPUSH
25799: LD_VAR 0 2
25803: PPUSH
25804: CALL 23407 0 2
25808: PPUSH
25809: LD_INT 30
25811: PUSH
25812: LD_INT 3
25814: PUSH
25815: EMPTY
25816: LIST
25817: LIST
25818: PPUSH
25819: CALL_OW 72
25823: ST_TO_ADDR
// if not factories then
25824: LD_VAR 0 6
25828: NOT
25829: IFFALSE 25833
// exit ;
25831: GO 26829
// for i in factories do
25833: LD_ADDR_VAR 0 8
25837: PUSH
25838: LD_VAR 0 6
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25869
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25846: LD_ADDR_VAR 0 17
25850: PUSH
25851: LD_VAR 0 17
25855: PUSH
25856: LD_VAR 0 8
25860: PPUSH
25861: CALL_OW 478
25865: UNION
25866: ST_TO_ADDR
25867: GO 25843
25869: POP
25870: POP
// if not fac_list then
25871: LD_VAR 0 17
25875: NOT
25876: IFFALSE 25880
// exit ;
25878: GO 26829
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25880: LD_ADDR_VAR 0 5
25884: PUSH
25885: LD_INT 4
25887: PUSH
25888: LD_INT 5
25890: PUSH
25891: LD_INT 9
25893: PUSH
25894: LD_INT 10
25896: PUSH
25897: LD_INT 6
25899: PUSH
25900: LD_INT 7
25902: PUSH
25903: LD_INT 11
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: LIST
25910: LIST
25911: LIST
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 27
25917: PUSH
25918: LD_INT 28
25920: PUSH
25921: LD_INT 26
25923: PUSH
25924: LD_INT 30
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 43
25935: PUSH
25936: LD_INT 44
25938: PUSH
25939: LD_INT 46
25941: PUSH
25942: LD_INT 45
25944: PUSH
25945: LD_INT 47
25947: PUSH
25948: LD_INT 49
25950: PUSH
25951: EMPTY
25952: LIST
25953: LIST
25954: LIST
25955: LIST
25956: LIST
25957: LIST
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: LIST
25963: PUSH
25964: LD_VAR 0 12
25968: ARRAY
25969: ST_TO_ADDR
// for i in list do
25970: LD_ADDR_VAR 0 8
25974: PUSH
25975: LD_VAR 0 5
25979: PUSH
25980: FOR_IN
25981: IFFALSE 26014
// if not i in fac_list then
25983: LD_VAR 0 8
25987: PUSH
25988: LD_VAR 0 17
25992: IN
25993: NOT
25994: IFFALSE 26012
// list := list diff i ;
25996: LD_ADDR_VAR 0 5
26000: PUSH
26001: LD_VAR 0 5
26005: PUSH
26006: LD_VAR 0 8
26010: DIFF
26011: ST_TO_ADDR
26012: GO 25980
26014: POP
26015: POP
// if not list then
26016: LD_VAR 0 5
26020: NOT
26021: IFFALSE 26025
// exit ;
26023: GO 26829
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26025: LD_VAR 0 12
26029: PUSH
26030: LD_INT 3
26032: EQUAL
26033: PUSH
26034: LD_INT 49
26036: PUSH
26037: LD_VAR 0 5
26041: IN
26042: AND
26043: PUSH
26044: LD_INT 31
26046: PPUSH
26047: LD_VAR 0 16
26051: PPUSH
26052: CALL_OW 321
26056: PUSH
26057: LD_INT 2
26059: EQUAL
26060: AND
26061: IFFALSE 26121
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26063: LD_INT 22
26065: PUSH
26066: LD_VAR 0 16
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 35
26077: PUSH
26078: LD_INT 49
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 91
26087: PUSH
26088: LD_VAR 0 1
26092: PUSH
26093: LD_INT 10
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: LIST
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: PPUSH
26106: CALL_OW 69
26110: NOT
26111: IFFALSE 26121
// weapon := ru_time_lapser ;
26113: LD_ADDR_VAR 0 18
26117: PUSH
26118: LD_INT 49
26120: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26121: LD_VAR 0 12
26125: PUSH
26126: LD_INT 1
26128: PUSH
26129: LD_INT 2
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: IN
26136: PUSH
26137: LD_INT 11
26139: PUSH
26140: LD_VAR 0 5
26144: IN
26145: PUSH
26146: LD_INT 30
26148: PUSH
26149: LD_VAR 0 5
26153: IN
26154: OR
26155: AND
26156: PUSH
26157: LD_INT 6
26159: PPUSH
26160: LD_VAR 0 16
26164: PPUSH
26165: CALL_OW 321
26169: PUSH
26170: LD_INT 2
26172: EQUAL
26173: AND
26174: IFFALSE 26339
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26176: LD_INT 22
26178: PUSH
26179: LD_VAR 0 16
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: PUSH
26191: LD_INT 35
26193: PUSH
26194: LD_INT 11
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: PUSH
26201: LD_INT 35
26203: PUSH
26204: LD_INT 30
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 91
26218: PUSH
26219: LD_VAR 0 1
26223: PUSH
26224: LD_INT 18
26226: PUSH
26227: EMPTY
26228: LIST
26229: LIST
26230: LIST
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: LIST
26236: PPUSH
26237: CALL_OW 69
26241: NOT
26242: PUSH
26243: LD_INT 22
26245: PUSH
26246: LD_VAR 0 16
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 32
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 33
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 91
26285: PUSH
26286: LD_VAR 0 1
26290: PUSH
26291: LD_INT 12
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: LIST
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: LIST
26303: PUSH
26304: EMPTY
26305: LIST
26306: PPUSH
26307: CALL_OW 69
26311: PUSH
26312: LD_INT 2
26314: GREATER
26315: AND
26316: IFFALSE 26339
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26318: LD_ADDR_VAR 0 18
26322: PUSH
26323: LD_INT 11
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_VAR 0 12
26337: ARRAY
26338: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26339: LD_VAR 0 18
26343: NOT
26344: PUSH
26345: LD_INT 40
26347: PPUSH
26348: LD_VAR 0 16
26352: PPUSH
26353: CALL_OW 321
26357: PUSH
26358: LD_INT 2
26360: EQUAL
26361: AND
26362: PUSH
26363: LD_INT 7
26365: PUSH
26366: LD_VAR 0 5
26370: IN
26371: PUSH
26372: LD_INT 28
26374: PUSH
26375: LD_VAR 0 5
26379: IN
26380: OR
26381: PUSH
26382: LD_INT 45
26384: PUSH
26385: LD_VAR 0 5
26389: IN
26390: OR
26391: AND
26392: IFFALSE 26646
// begin hex := GetHexInfo ( x , y ) ;
26394: LD_ADDR_VAR 0 4
26398: PUSH
26399: LD_VAR 0 10
26403: PPUSH
26404: LD_VAR 0 11
26408: PPUSH
26409: CALL_OW 546
26413: ST_TO_ADDR
// if hex [ 1 ] then
26414: LD_VAR 0 4
26418: PUSH
26419: LD_INT 1
26421: ARRAY
26422: IFFALSE 26426
// exit ;
26424: GO 26829
// height := hex [ 2 ] ;
26426: LD_ADDR_VAR 0 15
26430: PUSH
26431: LD_VAR 0 4
26435: PUSH
26436: LD_INT 2
26438: ARRAY
26439: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26440: LD_ADDR_VAR 0 14
26444: PUSH
26445: LD_INT 0
26447: PUSH
26448: LD_INT 2
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 5
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: LIST
26462: ST_TO_ADDR
// for i in tmp do
26463: LD_ADDR_VAR 0 8
26467: PUSH
26468: LD_VAR 0 14
26472: PUSH
26473: FOR_IN
26474: IFFALSE 26644
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26476: LD_ADDR_VAR 0 9
26480: PUSH
26481: LD_VAR 0 10
26485: PPUSH
26486: LD_VAR 0 8
26490: PPUSH
26491: LD_INT 5
26493: PPUSH
26494: CALL_OW 272
26498: PUSH
26499: LD_VAR 0 11
26503: PPUSH
26504: LD_VAR 0 8
26508: PPUSH
26509: LD_INT 5
26511: PPUSH
26512: CALL_OW 273
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26521: LD_VAR 0 9
26525: PUSH
26526: LD_INT 1
26528: ARRAY
26529: PPUSH
26530: LD_VAR 0 9
26534: PUSH
26535: LD_INT 2
26537: ARRAY
26538: PPUSH
26539: CALL_OW 488
26543: IFFALSE 26642
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26545: LD_ADDR_VAR 0 4
26549: PUSH
26550: LD_VAR 0 9
26554: PUSH
26555: LD_INT 1
26557: ARRAY
26558: PPUSH
26559: LD_VAR 0 9
26563: PUSH
26564: LD_INT 2
26566: ARRAY
26567: PPUSH
26568: CALL_OW 546
26572: ST_TO_ADDR
// if hex [ 1 ] then
26573: LD_VAR 0 4
26577: PUSH
26578: LD_INT 1
26580: ARRAY
26581: IFFALSE 26585
// continue ;
26583: GO 26473
// h := hex [ 2 ] ;
26585: LD_ADDR_VAR 0 13
26589: PUSH
26590: LD_VAR 0 4
26594: PUSH
26595: LD_INT 2
26597: ARRAY
26598: ST_TO_ADDR
// if h + 7 < height then
26599: LD_VAR 0 13
26603: PUSH
26604: LD_INT 7
26606: PLUS
26607: PUSH
26608: LD_VAR 0 15
26612: LESS
26613: IFFALSE 26642
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26615: LD_ADDR_VAR 0 18
26619: PUSH
26620: LD_INT 7
26622: PUSH
26623: LD_INT 28
26625: PUSH
26626: LD_INT 45
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: LIST
26633: PUSH
26634: LD_VAR 0 12
26638: ARRAY
26639: ST_TO_ADDR
// break ;
26640: GO 26644
// end ; end ; end ;
26642: GO 26473
26644: POP
26645: POP
// end ; if not weapon then
26646: LD_VAR 0 18
26650: NOT
26651: IFFALSE 26711
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26653: LD_ADDR_VAR 0 5
26657: PUSH
26658: LD_VAR 0 5
26662: PUSH
26663: LD_INT 11
26665: PUSH
26666: LD_INT 30
26668: PUSH
26669: LD_INT 49
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: DIFF
26677: ST_TO_ADDR
// if not list then
26678: LD_VAR 0 5
26682: NOT
26683: IFFALSE 26687
// exit ;
26685: GO 26829
// weapon := list [ rand ( 1 , list ) ] ;
26687: LD_ADDR_VAR 0 18
26691: PUSH
26692: LD_VAR 0 5
26696: PUSH
26697: LD_INT 1
26699: PPUSH
26700: LD_VAR 0 5
26704: PPUSH
26705: CALL_OW 12
26709: ARRAY
26710: ST_TO_ADDR
// end ; if weapon then
26711: LD_VAR 0 18
26715: IFFALSE 26829
// begin tmp := CostOfWeapon ( weapon ) ;
26717: LD_ADDR_VAR 0 14
26721: PUSH
26722: LD_VAR 0 18
26726: PPUSH
26727: CALL_OW 451
26731: ST_TO_ADDR
// j := GetBase ( tower ) ;
26732: LD_ADDR_VAR 0 9
26736: PUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 274
26746: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26747: LD_VAR 0 9
26751: PPUSH
26752: LD_INT 1
26754: PPUSH
26755: CALL_OW 275
26759: PUSH
26760: LD_VAR 0 14
26764: PUSH
26765: LD_INT 1
26767: ARRAY
26768: GREATEREQUAL
26769: PUSH
26770: LD_VAR 0 9
26774: PPUSH
26775: LD_INT 2
26777: PPUSH
26778: CALL_OW 275
26782: PUSH
26783: LD_VAR 0 14
26787: PUSH
26788: LD_INT 2
26790: ARRAY
26791: GREATEREQUAL
26792: AND
26793: PUSH
26794: LD_VAR 0 9
26798: PPUSH
26799: LD_INT 3
26801: PPUSH
26802: CALL_OW 275
26806: PUSH
26807: LD_VAR 0 14
26811: PUSH
26812: LD_INT 3
26814: ARRAY
26815: GREATEREQUAL
26816: AND
26817: IFFALSE 26829
// result := weapon ;
26819: LD_ADDR_VAR 0 3
26823: PUSH
26824: LD_VAR 0 18
26828: ST_TO_ADDR
// end ; end ;
26829: LD_VAR 0 3
26833: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26834: LD_INT 0
26836: PPUSH
26837: PPUSH
// result := true ;
26838: LD_ADDR_VAR 0 3
26842: PUSH
26843: LD_INT 1
26845: ST_TO_ADDR
// if array1 = array2 then
26846: LD_VAR 0 1
26850: PUSH
26851: LD_VAR 0 2
26855: EQUAL
26856: IFFALSE 26916
// begin for i = 1 to array1 do
26858: LD_ADDR_VAR 0 4
26862: PUSH
26863: DOUBLE
26864: LD_INT 1
26866: DEC
26867: ST_TO_ADDR
26868: LD_VAR 0 1
26872: PUSH
26873: FOR_TO
26874: IFFALSE 26912
// if array1 [ i ] <> array2 [ i ] then
26876: LD_VAR 0 1
26880: PUSH
26881: LD_VAR 0 4
26885: ARRAY
26886: PUSH
26887: LD_VAR 0 2
26891: PUSH
26892: LD_VAR 0 4
26896: ARRAY
26897: NONEQUAL
26898: IFFALSE 26910
// begin result := false ;
26900: LD_ADDR_VAR 0 3
26904: PUSH
26905: LD_INT 0
26907: ST_TO_ADDR
// break ;
26908: GO 26912
// end ;
26910: GO 26873
26912: POP
26913: POP
// end else
26914: GO 26924
// result := false ;
26916: LD_ADDR_VAR 0 3
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// end ;
26924: LD_VAR 0 3
26928: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26929: LD_INT 0
26931: PPUSH
26932: PPUSH
26933: PPUSH
// pom := GetBase ( fac ) ;
26934: LD_ADDR_VAR 0 5
26938: PUSH
26939: LD_VAR 0 1
26943: PPUSH
26944: CALL_OW 274
26948: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26949: LD_ADDR_VAR 0 4
26953: PUSH
26954: LD_VAR 0 2
26958: PUSH
26959: LD_INT 1
26961: ARRAY
26962: PPUSH
26963: LD_VAR 0 2
26967: PUSH
26968: LD_INT 2
26970: ARRAY
26971: PPUSH
26972: LD_VAR 0 2
26976: PUSH
26977: LD_INT 3
26979: ARRAY
26980: PPUSH
26981: LD_VAR 0 2
26985: PUSH
26986: LD_INT 4
26988: ARRAY
26989: PPUSH
26990: CALL_OW 449
26994: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26995: LD_ADDR_VAR 0 3
26999: PUSH
27000: LD_VAR 0 5
27004: PPUSH
27005: LD_INT 1
27007: PPUSH
27008: CALL_OW 275
27012: PUSH
27013: LD_VAR 0 4
27017: PUSH
27018: LD_INT 1
27020: ARRAY
27021: GREATEREQUAL
27022: PUSH
27023: LD_VAR 0 5
27027: PPUSH
27028: LD_INT 2
27030: PPUSH
27031: CALL_OW 275
27035: PUSH
27036: LD_VAR 0 4
27040: PUSH
27041: LD_INT 2
27043: ARRAY
27044: GREATEREQUAL
27045: AND
27046: PUSH
27047: LD_VAR 0 5
27051: PPUSH
27052: LD_INT 3
27054: PPUSH
27055: CALL_OW 275
27059: PUSH
27060: LD_VAR 0 4
27064: PUSH
27065: LD_INT 3
27067: ARRAY
27068: GREATEREQUAL
27069: AND
27070: ST_TO_ADDR
// end ;
27071: LD_VAR 0 3
27075: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27076: LD_INT 0
27078: PPUSH
27079: PPUSH
27080: PPUSH
27081: PPUSH
// pom := GetBase ( building ) ;
27082: LD_ADDR_VAR 0 3
27086: PUSH
27087: LD_VAR 0 1
27091: PPUSH
27092: CALL_OW 274
27096: ST_TO_ADDR
// if not pom then
27097: LD_VAR 0 3
27101: NOT
27102: IFFALSE 27106
// exit ;
27104: GO 27276
// btype := GetBType ( building ) ;
27106: LD_ADDR_VAR 0 5
27110: PUSH
27111: LD_VAR 0 1
27115: PPUSH
27116: CALL_OW 266
27120: ST_TO_ADDR
// if btype = b_armoury then
27121: LD_VAR 0 5
27125: PUSH
27126: LD_INT 4
27128: EQUAL
27129: IFFALSE 27139
// btype := b_barracks ;
27131: LD_ADDR_VAR 0 5
27135: PUSH
27136: LD_INT 5
27138: ST_TO_ADDR
// if btype = b_depot then
27139: LD_VAR 0 5
27143: PUSH
27144: LD_INT 0
27146: EQUAL
27147: IFFALSE 27157
// btype := b_warehouse ;
27149: LD_ADDR_VAR 0 5
27153: PUSH
27154: LD_INT 1
27156: ST_TO_ADDR
// if btype = b_workshop then
27157: LD_VAR 0 5
27161: PUSH
27162: LD_INT 2
27164: EQUAL
27165: IFFALSE 27175
// btype := b_factory ;
27167: LD_ADDR_VAR 0 5
27171: PUSH
27172: LD_INT 3
27174: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27175: LD_ADDR_VAR 0 4
27179: PUSH
27180: LD_VAR 0 5
27184: PPUSH
27185: LD_VAR 0 1
27189: PPUSH
27190: CALL_OW 248
27194: PPUSH
27195: CALL_OW 450
27199: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27200: LD_ADDR_VAR 0 2
27204: PUSH
27205: LD_VAR 0 3
27209: PPUSH
27210: LD_INT 1
27212: PPUSH
27213: CALL_OW 275
27217: PUSH
27218: LD_VAR 0 4
27222: PUSH
27223: LD_INT 1
27225: ARRAY
27226: GREATEREQUAL
27227: PUSH
27228: LD_VAR 0 3
27232: PPUSH
27233: LD_INT 2
27235: PPUSH
27236: CALL_OW 275
27240: PUSH
27241: LD_VAR 0 4
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: GREATEREQUAL
27250: AND
27251: PUSH
27252: LD_VAR 0 3
27256: PPUSH
27257: LD_INT 3
27259: PPUSH
27260: CALL_OW 275
27264: PUSH
27265: LD_VAR 0 4
27269: PUSH
27270: LD_INT 3
27272: ARRAY
27273: GREATEREQUAL
27274: AND
27275: ST_TO_ADDR
// end ;
27276: LD_VAR 0 2
27280: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27281: LD_INT 0
27283: PPUSH
27284: PPUSH
27285: PPUSH
// pom := GetBase ( building ) ;
27286: LD_ADDR_VAR 0 4
27290: PUSH
27291: LD_VAR 0 1
27295: PPUSH
27296: CALL_OW 274
27300: ST_TO_ADDR
// if not pom then
27301: LD_VAR 0 4
27305: NOT
27306: IFFALSE 27310
// exit ;
27308: GO 27411
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27310: LD_ADDR_VAR 0 5
27314: PUSH
27315: LD_VAR 0 2
27319: PPUSH
27320: LD_VAR 0 1
27324: PPUSH
27325: CALL_OW 248
27329: PPUSH
27330: CALL_OW 450
27334: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27335: LD_ADDR_VAR 0 3
27339: PUSH
27340: LD_VAR 0 4
27344: PPUSH
27345: LD_INT 1
27347: PPUSH
27348: CALL_OW 275
27352: PUSH
27353: LD_VAR 0 5
27357: PUSH
27358: LD_INT 1
27360: ARRAY
27361: GREATEREQUAL
27362: PUSH
27363: LD_VAR 0 4
27367: PPUSH
27368: LD_INT 2
27370: PPUSH
27371: CALL_OW 275
27375: PUSH
27376: LD_VAR 0 5
27380: PUSH
27381: LD_INT 2
27383: ARRAY
27384: GREATEREQUAL
27385: AND
27386: PUSH
27387: LD_VAR 0 4
27391: PPUSH
27392: LD_INT 3
27394: PPUSH
27395: CALL_OW 275
27399: PUSH
27400: LD_VAR 0 5
27404: PUSH
27405: LD_INT 3
27407: ARRAY
27408: GREATEREQUAL
27409: AND
27410: ST_TO_ADDR
// end ;
27411: LD_VAR 0 3
27415: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27416: LD_INT 0
27418: PPUSH
27419: PPUSH
27420: PPUSH
27421: PPUSH
27422: PPUSH
27423: PPUSH
27424: PPUSH
27425: PPUSH
27426: PPUSH
27427: PPUSH
// result := false ;
27428: LD_ADDR_VAR 0 6
27432: PUSH
27433: LD_INT 0
27435: ST_TO_ADDR
// if not base or not btype or not x or not y then
27436: LD_VAR 0 1
27440: NOT
27441: PUSH
27442: LD_VAR 0 2
27446: NOT
27447: OR
27448: PUSH
27449: LD_VAR 0 3
27453: NOT
27454: OR
27455: PUSH
27456: LD_VAR 0 4
27460: NOT
27461: OR
27462: IFFALSE 27466
// exit ;
27464: GO 28057
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27466: LD_ADDR_VAR 0 12
27470: PUSH
27471: LD_VAR 0 2
27475: PPUSH
27476: LD_VAR 0 3
27480: PPUSH
27481: LD_VAR 0 4
27485: PPUSH
27486: LD_VAR 0 5
27490: PPUSH
27491: LD_VAR 0 1
27495: PUSH
27496: LD_INT 1
27498: ARRAY
27499: PPUSH
27500: CALL_OW 248
27504: PPUSH
27505: LD_INT 0
27507: PPUSH
27508: CALL 28894 0 6
27512: ST_TO_ADDR
// if not hexes then
27513: LD_VAR 0 12
27517: NOT
27518: IFFALSE 27522
// exit ;
27520: GO 28057
// for i = 1 to hexes do
27522: LD_ADDR_VAR 0 7
27526: PUSH
27527: DOUBLE
27528: LD_INT 1
27530: DEC
27531: ST_TO_ADDR
27532: LD_VAR 0 12
27536: PUSH
27537: FOR_TO
27538: IFFALSE 28055
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27540: LD_ADDR_VAR 0 11
27544: PUSH
27545: LD_VAR 0 12
27549: PUSH
27550: LD_VAR 0 7
27554: ARRAY
27555: PUSH
27556: LD_INT 1
27558: ARRAY
27559: PPUSH
27560: LD_VAR 0 12
27564: PUSH
27565: LD_VAR 0 7
27569: ARRAY
27570: PUSH
27571: LD_INT 2
27573: ARRAY
27574: PPUSH
27575: CALL_OW 428
27579: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27580: LD_VAR 0 12
27584: PUSH
27585: LD_VAR 0 7
27589: ARRAY
27590: PUSH
27591: LD_INT 1
27593: ARRAY
27594: PPUSH
27595: LD_VAR 0 12
27599: PUSH
27600: LD_VAR 0 7
27604: ARRAY
27605: PUSH
27606: LD_INT 2
27608: ARRAY
27609: PPUSH
27610: CALL_OW 351
27614: PUSH
27615: LD_VAR 0 12
27619: PUSH
27620: LD_VAR 0 7
27624: ARRAY
27625: PUSH
27626: LD_INT 1
27628: ARRAY
27629: PPUSH
27630: LD_VAR 0 12
27634: PUSH
27635: LD_VAR 0 7
27639: ARRAY
27640: PUSH
27641: LD_INT 2
27643: ARRAY
27644: PPUSH
27645: CALL_OW 488
27649: NOT
27650: OR
27651: PUSH
27652: LD_VAR 0 11
27656: PPUSH
27657: CALL_OW 247
27661: PUSH
27662: LD_INT 3
27664: EQUAL
27665: OR
27666: IFFALSE 27672
// exit ;
27668: POP
27669: POP
27670: GO 28057
// if not tmp then
27672: LD_VAR 0 11
27676: NOT
27677: IFFALSE 27681
// continue ;
27679: GO 27537
// result := true ;
27681: LD_ADDR_VAR 0 6
27685: PUSH
27686: LD_INT 1
27688: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27689: LD_ADDR_VAR 0 15
27693: PUSH
27694: LD_INT 22
27696: PUSH
27697: LD_VAR 0 11
27701: PPUSH
27702: CALL_OW 255
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: LD_INT 2
27713: PUSH
27714: LD_INT 30
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 30
27726: PUSH
27727: LD_INT 1
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: LIST
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PPUSH
27743: CALL_OW 69
27747: ST_TO_ADDR
// if dep then
27748: LD_VAR 0 15
27752: IFFALSE 27888
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27754: LD_ADDR_VAR 0 14
27758: PUSH
27759: LD_VAR 0 15
27763: PUSH
27764: LD_INT 1
27766: ARRAY
27767: PPUSH
27768: CALL_OW 250
27772: PPUSH
27773: LD_VAR 0 15
27777: PUSH
27778: LD_INT 1
27780: ARRAY
27781: PPUSH
27782: CALL_OW 254
27786: PPUSH
27787: LD_INT 5
27789: PPUSH
27790: CALL_OW 272
27794: PUSH
27795: LD_VAR 0 15
27799: PUSH
27800: LD_INT 1
27802: ARRAY
27803: PPUSH
27804: CALL_OW 251
27808: PPUSH
27809: LD_VAR 0 15
27813: PUSH
27814: LD_INT 1
27816: ARRAY
27817: PPUSH
27818: CALL_OW 254
27822: PPUSH
27823: LD_INT 5
27825: PPUSH
27826: CALL_OW 273
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27835: LD_VAR 0 14
27839: PUSH
27840: LD_INT 1
27842: ARRAY
27843: PPUSH
27844: LD_VAR 0 14
27848: PUSH
27849: LD_INT 2
27851: ARRAY
27852: PPUSH
27853: CALL_OW 488
27857: IFFALSE 27888
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27859: LD_VAR 0 11
27863: PPUSH
27864: LD_VAR 0 14
27868: PUSH
27869: LD_INT 1
27871: ARRAY
27872: PPUSH
27873: LD_VAR 0 14
27877: PUSH
27878: LD_INT 2
27880: ARRAY
27881: PPUSH
27882: CALL_OW 111
// continue ;
27886: GO 27537
// end ; end ; r := GetDir ( tmp ) ;
27888: LD_ADDR_VAR 0 13
27892: PUSH
27893: LD_VAR 0 11
27897: PPUSH
27898: CALL_OW 254
27902: ST_TO_ADDR
// if r = 5 then
27903: LD_VAR 0 13
27907: PUSH
27908: LD_INT 5
27910: EQUAL
27911: IFFALSE 27921
// r := 0 ;
27913: LD_ADDR_VAR 0 13
27917: PUSH
27918: LD_INT 0
27920: ST_TO_ADDR
// for j = r to 5 do
27921: LD_ADDR_VAR 0 8
27925: PUSH
27926: DOUBLE
27927: LD_VAR 0 13
27931: DEC
27932: ST_TO_ADDR
27933: LD_INT 5
27935: PUSH
27936: FOR_TO
27937: IFFALSE 28051
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27939: LD_ADDR_VAR 0 9
27943: PUSH
27944: LD_VAR 0 11
27948: PPUSH
27949: CALL_OW 250
27953: PPUSH
27954: LD_VAR 0 8
27958: PPUSH
27959: LD_INT 2
27961: PPUSH
27962: CALL_OW 272
27966: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27967: LD_ADDR_VAR 0 10
27971: PUSH
27972: LD_VAR 0 11
27976: PPUSH
27977: CALL_OW 251
27981: PPUSH
27982: LD_VAR 0 8
27986: PPUSH
27987: LD_INT 2
27989: PPUSH
27990: CALL_OW 273
27994: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27995: LD_VAR 0 9
27999: PPUSH
28000: LD_VAR 0 10
28004: PPUSH
28005: CALL_OW 488
28009: PUSH
28010: LD_VAR 0 9
28014: PPUSH
28015: LD_VAR 0 10
28019: PPUSH
28020: CALL_OW 428
28024: NOT
28025: AND
28026: IFFALSE 28049
// begin ComMoveXY ( tmp , _x , _y ) ;
28028: LD_VAR 0 11
28032: PPUSH
28033: LD_VAR 0 9
28037: PPUSH
28038: LD_VAR 0 10
28042: PPUSH
28043: CALL_OW 111
// break ;
28047: GO 28051
// end ; end ;
28049: GO 27936
28051: POP
28052: POP
// end ;
28053: GO 27537
28055: POP
28056: POP
// end ;
28057: LD_VAR 0 6
28061: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28062: LD_INT 0
28064: PPUSH
28065: PPUSH
28066: PPUSH
28067: PPUSH
28068: PPUSH
28069: PPUSH
28070: PPUSH
28071: PPUSH
28072: PPUSH
28073: PPUSH
// result := false ;
28074: LD_ADDR_VAR 0 6
28078: PUSH
28079: LD_INT 0
28081: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28082: LD_VAR 0 1
28086: NOT
28087: PUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 266
28097: PUSH
28098: LD_INT 0
28100: PUSH
28101: LD_INT 1
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: IN
28108: NOT
28109: OR
28110: PUSH
28111: LD_VAR 0 2
28115: NOT
28116: OR
28117: PUSH
28118: LD_VAR 0 5
28122: PUSH
28123: LD_INT 0
28125: PUSH
28126: LD_INT 1
28128: PUSH
28129: LD_INT 2
28131: PUSH
28132: LD_INT 3
28134: PUSH
28135: LD_INT 4
28137: PUSH
28138: LD_INT 5
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: IN
28149: NOT
28150: OR
28151: PUSH
28152: LD_VAR 0 3
28156: PPUSH
28157: LD_VAR 0 4
28161: PPUSH
28162: CALL_OW 488
28166: NOT
28167: OR
28168: IFFALSE 28172
// exit ;
28170: GO 28889
// pom := GetBase ( bdepot ) ;
28172: LD_ADDR_VAR 0 10
28176: PUSH
28177: LD_VAR 0 1
28181: PPUSH
28182: CALL_OW 274
28186: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
28187: LD_ADDR_VAR 0 11
28191: PUSH
28192: LD_VAR 0 2
28196: PPUSH
28197: LD_VAR 0 1
28201: PPUSH
28202: CALL_OW 248
28206: PPUSH
28207: CALL_OW 450
28211: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28212: LD_VAR 0 10
28216: PPUSH
28217: LD_INT 1
28219: PPUSH
28220: CALL_OW 275
28224: PUSH
28225: LD_VAR 0 11
28229: PUSH
28230: LD_INT 1
28232: ARRAY
28233: GREATEREQUAL
28234: PUSH
28235: LD_VAR 0 10
28239: PPUSH
28240: LD_INT 2
28242: PPUSH
28243: CALL_OW 275
28247: PUSH
28248: LD_VAR 0 11
28252: PUSH
28253: LD_INT 2
28255: ARRAY
28256: GREATEREQUAL
28257: AND
28258: PUSH
28259: LD_VAR 0 10
28263: PPUSH
28264: LD_INT 3
28266: PPUSH
28267: CALL_OW 275
28271: PUSH
28272: LD_VAR 0 11
28276: PUSH
28277: LD_INT 3
28279: ARRAY
28280: GREATEREQUAL
28281: AND
28282: NOT
28283: IFFALSE 28287
// exit ;
28285: GO 28889
// if GetBType ( bdepot ) = b_depot then
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 266
28296: PUSH
28297: LD_INT 0
28299: EQUAL
28300: IFFALSE 28312
// dist := 28 else
28302: LD_ADDR_VAR 0 14
28306: PUSH
28307: LD_INT 28
28309: ST_TO_ADDR
28310: GO 28320
// dist := 36 ;
28312: LD_ADDR_VAR 0 14
28316: PUSH
28317: LD_INT 36
28319: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
28320: LD_VAR 0 1
28324: PPUSH
28325: LD_VAR 0 3
28329: PPUSH
28330: LD_VAR 0 4
28334: PPUSH
28335: CALL_OW 297
28339: PUSH
28340: LD_VAR 0 14
28344: GREATER
28345: IFFALSE 28349
// exit ;
28347: GO 28889
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
28349: LD_ADDR_VAR 0 12
28353: PUSH
28354: LD_VAR 0 2
28358: PPUSH
28359: LD_VAR 0 3
28363: PPUSH
28364: LD_VAR 0 4
28368: PPUSH
28369: LD_VAR 0 5
28373: PPUSH
28374: LD_VAR 0 1
28378: PPUSH
28379: CALL_OW 248
28383: PPUSH
28384: LD_INT 0
28386: PPUSH
28387: CALL 28894 0 6
28391: ST_TO_ADDR
// if not hexes then
28392: LD_VAR 0 12
28396: NOT
28397: IFFALSE 28401
// exit ;
28399: GO 28889
// hex := GetHexInfo ( x , y ) ;
28401: LD_ADDR_VAR 0 15
28405: PUSH
28406: LD_VAR 0 3
28410: PPUSH
28411: LD_VAR 0 4
28415: PPUSH
28416: CALL_OW 546
28420: ST_TO_ADDR
// if hex [ 1 ] then
28421: LD_VAR 0 15
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: IFFALSE 28433
// exit ;
28431: GO 28889
// height := hex [ 2 ] ;
28433: LD_ADDR_VAR 0 13
28437: PUSH
28438: LD_VAR 0 15
28442: PUSH
28443: LD_INT 2
28445: ARRAY
28446: ST_TO_ADDR
// for i = 1 to hexes do
28447: LD_ADDR_VAR 0 7
28451: PUSH
28452: DOUBLE
28453: LD_INT 1
28455: DEC
28456: ST_TO_ADDR
28457: LD_VAR 0 12
28461: PUSH
28462: FOR_TO
28463: IFFALSE 28793
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28465: LD_VAR 0 12
28469: PUSH
28470: LD_VAR 0 7
28474: ARRAY
28475: PUSH
28476: LD_INT 1
28478: ARRAY
28479: PPUSH
28480: LD_VAR 0 12
28484: PUSH
28485: LD_VAR 0 7
28489: ARRAY
28490: PUSH
28491: LD_INT 2
28493: ARRAY
28494: PPUSH
28495: CALL_OW 488
28499: NOT
28500: PUSH
28501: LD_VAR 0 12
28505: PUSH
28506: LD_VAR 0 7
28510: ARRAY
28511: PUSH
28512: LD_INT 1
28514: ARRAY
28515: PPUSH
28516: LD_VAR 0 12
28520: PUSH
28521: LD_VAR 0 7
28525: ARRAY
28526: PUSH
28527: LD_INT 2
28529: ARRAY
28530: PPUSH
28531: CALL_OW 428
28535: PUSH
28536: LD_INT 0
28538: GREATER
28539: OR
28540: PUSH
28541: LD_VAR 0 12
28545: PUSH
28546: LD_VAR 0 7
28550: ARRAY
28551: PUSH
28552: LD_INT 1
28554: ARRAY
28555: PPUSH
28556: LD_VAR 0 12
28560: PUSH
28561: LD_VAR 0 7
28565: ARRAY
28566: PUSH
28567: LD_INT 2
28569: ARRAY
28570: PPUSH
28571: CALL_OW 351
28575: OR
28576: IFFALSE 28582
// exit ;
28578: POP
28579: POP
28580: GO 28889
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28582: LD_ADDR_VAR 0 8
28586: PUSH
28587: LD_VAR 0 12
28591: PUSH
28592: LD_VAR 0 7
28596: ARRAY
28597: PUSH
28598: LD_INT 1
28600: ARRAY
28601: PPUSH
28602: LD_VAR 0 12
28606: PUSH
28607: LD_VAR 0 7
28611: ARRAY
28612: PUSH
28613: LD_INT 2
28615: ARRAY
28616: PPUSH
28617: CALL_OW 546
28621: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28622: LD_VAR 0 8
28626: PUSH
28627: LD_INT 1
28629: ARRAY
28630: PUSH
28631: LD_VAR 0 8
28635: PUSH
28636: LD_INT 2
28638: ARRAY
28639: PUSH
28640: LD_VAR 0 13
28644: PUSH
28645: LD_INT 2
28647: PLUS
28648: GREATER
28649: OR
28650: PUSH
28651: LD_VAR 0 8
28655: PUSH
28656: LD_INT 2
28658: ARRAY
28659: PUSH
28660: LD_VAR 0 13
28664: PUSH
28665: LD_INT 2
28667: MINUS
28668: LESS
28669: OR
28670: PUSH
28671: LD_VAR 0 8
28675: PUSH
28676: LD_INT 3
28678: ARRAY
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 8
28685: PUSH
28686: LD_INT 9
28688: PUSH
28689: LD_INT 10
28691: PUSH
28692: LD_INT 11
28694: PUSH
28695: LD_INT 12
28697: PUSH
28698: LD_INT 13
28700: PUSH
28701: LD_INT 16
28703: PUSH
28704: LD_INT 17
28706: PUSH
28707: LD_INT 18
28709: PUSH
28710: LD_INT 19
28712: PUSH
28713: LD_INT 20
28715: PUSH
28716: LD_INT 21
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: LIST
28723: LIST
28724: LIST
28725: LIST
28726: LIST
28727: LIST
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: LIST
28733: IN
28734: NOT
28735: OR
28736: PUSH
28737: LD_VAR 0 8
28741: PUSH
28742: LD_INT 5
28744: ARRAY
28745: NOT
28746: OR
28747: PUSH
28748: LD_VAR 0 8
28752: PUSH
28753: LD_INT 6
28755: ARRAY
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: LD_INT 2
28762: PUSH
28763: LD_INT 7
28765: PUSH
28766: LD_INT 9
28768: PUSH
28769: LD_INT 10
28771: PUSH
28772: LD_INT 11
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: IN
28783: NOT
28784: OR
28785: IFFALSE 28791
// exit ;
28787: POP
28788: POP
28789: GO 28889
// end ;
28791: GO 28462
28793: POP
28794: POP
// side := GetSide ( bdepot ) ;
28795: LD_ADDR_VAR 0 9
28799: PUSH
28800: LD_VAR 0 1
28804: PPUSH
28805: CALL_OW 255
28809: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28810: LD_VAR 0 9
28814: PPUSH
28815: LD_VAR 0 3
28819: PPUSH
28820: LD_VAR 0 4
28824: PPUSH
28825: LD_INT 20
28827: PPUSH
28828: CALL 21561 0 4
28832: PUSH
28833: LD_INT 4
28835: ARRAY
28836: IFFALSE 28840
// exit ;
28838: GO 28889
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28840: LD_VAR 0 2
28844: PUSH
28845: LD_INT 29
28847: PUSH
28848: LD_INT 30
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: IN
28855: PUSH
28856: LD_VAR 0 3
28860: PPUSH
28861: LD_VAR 0 4
28865: PPUSH
28866: LD_VAR 0 9
28870: PPUSH
28871: CALL_OW 440
28875: NOT
28876: AND
28877: IFFALSE 28881
// exit ;
28879: GO 28889
// result := true ;
28881: LD_ADDR_VAR 0 6
28885: PUSH
28886: LD_INT 1
28888: ST_TO_ADDR
// end ;
28889: LD_VAR 0 6
28893: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28894: LD_INT 0
28896: PPUSH
28897: PPUSH
28898: PPUSH
28899: PPUSH
28900: PPUSH
28901: PPUSH
28902: PPUSH
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
28921: PPUSH
28922: PPUSH
28923: PPUSH
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
// result = [ ] ;
28954: LD_ADDR_VAR 0 7
28958: PUSH
28959: EMPTY
28960: ST_TO_ADDR
// temp_list = [ ] ;
28961: LD_ADDR_VAR 0 9
28965: PUSH
28966: EMPTY
28967: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28968: LD_VAR 0 4
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 1
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 4
28987: PUSH
28988: LD_INT 5
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: IN
28999: NOT
29000: PUSH
29001: LD_VAR 0 1
29005: PUSH
29006: LD_INT 0
29008: PUSH
29009: LD_INT 1
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: IN
29016: PUSH
29017: LD_VAR 0 5
29021: PUSH
29022: LD_INT 1
29024: PUSH
29025: LD_INT 2
29027: PUSH
29028: LD_INT 3
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: LIST
29035: IN
29036: NOT
29037: AND
29038: OR
29039: IFFALSE 29043
// exit ;
29041: GO 47428
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29043: LD_VAR 0 1
29047: PUSH
29048: LD_INT 6
29050: PUSH
29051: LD_INT 7
29053: PUSH
29054: LD_INT 8
29056: PUSH
29057: LD_INT 13
29059: PUSH
29060: LD_INT 12
29062: PUSH
29063: LD_INT 15
29065: PUSH
29066: LD_INT 11
29068: PUSH
29069: LD_INT 14
29071: PUSH
29072: LD_INT 10
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: IN
29086: IFFALSE 29096
// btype = b_lab ;
29088: LD_ADDR_VAR 0 1
29092: PUSH
29093: LD_INT 6
29095: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29096: LD_VAR 0 6
29100: PUSH
29101: LD_INT 0
29103: PUSH
29104: LD_INT 1
29106: PUSH
29107: LD_INT 2
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: IN
29115: NOT
29116: PUSH
29117: LD_VAR 0 1
29121: PUSH
29122: LD_INT 0
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 2
29130: PUSH
29131: LD_INT 3
29133: PUSH
29134: LD_INT 6
29136: PUSH
29137: LD_INT 36
29139: PUSH
29140: LD_INT 4
29142: PUSH
29143: LD_INT 5
29145: PUSH
29146: LD_INT 31
29148: PUSH
29149: LD_INT 32
29151: PUSH
29152: LD_INT 33
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: LIST
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: IN
29168: NOT
29169: PUSH
29170: LD_VAR 0 6
29174: PUSH
29175: LD_INT 1
29177: EQUAL
29178: AND
29179: OR
29180: PUSH
29181: LD_VAR 0 1
29185: PUSH
29186: LD_INT 2
29188: PUSH
29189: LD_INT 3
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: IN
29196: NOT
29197: PUSH
29198: LD_VAR 0 6
29202: PUSH
29203: LD_INT 2
29205: EQUAL
29206: AND
29207: OR
29208: IFFALSE 29218
// mode = 0 ;
29210: LD_ADDR_VAR 0 6
29214: PUSH
29215: LD_INT 0
29217: ST_TO_ADDR
// case mode of 0 :
29218: LD_VAR 0 6
29222: PUSH
29223: LD_INT 0
29225: DOUBLE
29226: EQUAL
29227: IFTRUE 29231
29229: GO 40684
29231: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29232: LD_ADDR_VAR 0 11
29236: PUSH
29237: LD_INT 0
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: LD_INT 0
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: LD_INT 1
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 0
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 1
29301: NEG
29302: PUSH
29303: LD_INT 1
29305: NEG
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 1
29313: NEG
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 0
29325: PUSH
29326: LD_INT 2
29328: NEG
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: LD_INT 2
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 0
29357: PUSH
29358: LD_INT 2
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 1
29367: NEG
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: LD_INT 3
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: LD_INT 3
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: LD_INT 2
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29425: LD_ADDR_VAR 0 12
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 0
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 1
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 2
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: NEG
29538: PUSH
29539: LD_INT 1
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 2
29548: NEG
29549: PUSH
29550: LD_INT 0
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 2
29559: NEG
29560: PUSH
29561: LD_INT 1
29563: NEG
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 3
29582: NEG
29583: PUSH
29584: LD_INT 0
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 3
29593: NEG
29594: PUSH
29595: LD_INT 1
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29621: LD_ADDR_VAR 0 13
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 0
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 2
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 2
29724: PUSH
29725: LD_INT 2
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: LD_INT 2
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 2
29744: NEG
29745: PUSH
29746: LD_INT 1
29748: NEG
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 2
29756: NEG
29757: PUSH
29758: LD_INT 2
29760: NEG
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: LD_INT 3
29772: NEG
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 3
29780: NEG
29781: PUSH
29782: LD_INT 2
29784: NEG
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 3
29792: NEG
29793: PUSH
29794: LD_INT 3
29796: NEG
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29820: LD_ADDR_VAR 0 14
29824: PUSH
29825: LD_INT 0
29827: PUSH
29828: LD_INT 0
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: LD_INT 1
29840: NEG
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: LD_INT 1
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 0
29868: PUSH
29869: LD_INT 1
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 1
29878: NEG
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 1
29889: NEG
29890: PUSH
29891: LD_INT 1
29893: NEG
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 1
29901: NEG
29902: PUSH
29903: LD_INT 2
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 0
29913: PUSH
29914: LD_INT 2
29916: NEG
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 1
29924: PUSH
29925: LD_INT 1
29927: NEG
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: LD_INT 2
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 2
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 1
29955: NEG
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: LD_INT 3
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 3
29981: NEG
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 2
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30016: LD_ADDR_VAR 0 15
30020: PUSH
30021: LD_INT 0
30023: PUSH
30024: LD_INT 0
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 1
30074: NEG
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: NEG
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 2
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 2
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 1
30128: NEG
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 2
30139: NEG
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: NEG
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 1
30165: NEG
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 3
30173: PUSH
30174: LD_INT 0
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 3
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30209: LD_ADDR_VAR 0 16
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 0
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 0
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 1
30267: NEG
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: NEG
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: NEG
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 2
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: LD_INT 2
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: PUSH
30323: LD_INT 2
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: NEG
30345: PUSH
30346: LD_INT 2
30348: NEG
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 3
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 3
30366: PUSH
30367: LD_INT 3
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 2
30376: PUSH
30377: LD_INT 3
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30402: LD_ADDR_VAR 0 17
30406: PUSH
30407: LD_INT 0
30409: PUSH
30410: LD_INT 0
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: LD_INT 1
30422: NEG
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: LD_INT 0
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: NEG
30461: PUSH
30462: LD_INT 0
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 1
30483: NEG
30484: PUSH
30485: LD_INT 2
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: LD_INT 2
30498: NEG
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: LD_INT 1
30509: NEG
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 2
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 2
30527: PUSH
30528: LD_INT 1
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 2
30537: PUSH
30538: LD_INT 2
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 2
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 2
30578: NEG
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 2
30589: NEG
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 2
30601: NEG
30602: PUSH
30603: LD_INT 2
30605: NEG
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30632: LD_ADDR_VAR 0 18
30636: PUSH
30637: LD_INT 0
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: LD_INT 1
30652: NEG
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 1
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 1
30670: PUSH
30671: LD_INT 1
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: LD_INT 1
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 1
30701: NEG
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 1
30713: NEG
30714: PUSH
30715: LD_INT 2
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: LD_INT 2
30728: NEG
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 2
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 2
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 2
30767: PUSH
30768: LD_INT 2
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 1
30777: PUSH
30778: LD_INT 2
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 2
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 2
30808: NEG
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 2
30819: NEG
30820: PUSH
30821: LD_INT 1
30823: NEG
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: LD_INT 2
30835: NEG
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30862: LD_ADDR_VAR 0 19
30866: PUSH
30867: LD_INT 0
30869: PUSH
30870: LD_INT 0
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 1
30900: PUSH
30901: LD_INT 1
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 1
30920: NEG
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: LD_INT 1
30935: NEG
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: LD_INT 1
30943: NEG
30944: PUSH
30945: LD_INT 2
30947: NEG
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: LD_INT 2
30958: NEG
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 1
30966: PUSH
30967: LD_INT 1
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 2
30977: PUSH
30978: LD_INT 0
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 2
30987: PUSH
30988: LD_INT 1
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 2
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: PUSH
31008: LD_INT 2
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: LD_INT 2
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 2
31038: NEG
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 2
31061: NEG
31062: PUSH
31063: LD_INT 2
31065: NEG
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31092: LD_ADDR_VAR 0 20
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: LD_INT 1
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 0
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 0
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 0
31185: PUSH
31186: LD_INT 2
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 1
31199: NEG
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: LD_INT 2
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: LD_INT 2
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 0
31247: PUSH
31248: LD_INT 2
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 2
31268: NEG
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 2
31279: NEG
31280: PUSH
31281: LD_INT 1
31283: NEG
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: NEG
31292: PUSH
31293: LD_INT 2
31295: NEG
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31322: LD_ADDR_VAR 0 21
31326: PUSH
31327: LD_INT 0
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: LD_INT 0
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 1
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 0
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: NEG
31381: PUSH
31382: LD_INT 0
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: LD_INT 1
31395: NEG
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 1
31403: NEG
31404: PUSH
31405: LD_INT 2
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 0
31415: PUSH
31416: LD_INT 2
31418: NEG
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: PUSH
31427: LD_INT 1
31429: NEG
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 2
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 2
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 2
31457: PUSH
31458: LD_INT 2
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: LD_INT 2
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 2
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 1
31487: NEG
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 2
31498: NEG
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 2
31509: NEG
31510: PUSH
31511: LD_INT 1
31513: NEG
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 2
31521: NEG
31522: PUSH
31523: LD_INT 2
31525: NEG
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31552: LD_ADDR_VAR 0 22
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 1
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 0
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 0
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 1
31633: NEG
31634: PUSH
31635: LD_INT 2
31637: NEG
31638: PUSH
31639: EMPTY
31640: LIST
31641: LIST
31642: PUSH
31643: LD_INT 0
31645: PUSH
31646: LD_INT 2
31648: NEG
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 2
31667: PUSH
31668: LD_INT 0
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 2
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 2
31687: PUSH
31688: LD_INT 2
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 2
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: LD_INT 2
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 1
31717: NEG
31718: PUSH
31719: LD_INT 1
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 2
31739: NEG
31740: PUSH
31741: LD_INT 1
31743: NEG
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 2
31751: NEG
31752: PUSH
31753: LD_INT 2
31755: NEG
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31782: LD_ADDR_VAR 0 23
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: LD_INT 1
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 0
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 0
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 1
31851: NEG
31852: PUSH
31853: LD_INT 1
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: NEG
31864: PUSH
31865: LD_INT 2
31867: NEG
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: LD_INT 2
31878: NEG
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: LD_INT 2
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: LD_INT 2
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: LD_INT 2
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: NEG
31948: PUSH
31949: LD_INT 1
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: NEG
31970: PUSH
31971: LD_INT 1
31973: NEG
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 2
31981: NEG
31982: PUSH
31983: LD_INT 2
31985: NEG
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: LD_INT 3
31997: NEG
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 3
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32062: LD_ADDR_VAR 0 24
32066: PUSH
32067: LD_INT 0
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 1
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 1
32100: PUSH
32101: LD_INT 1
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: LD_INT 1
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 1
32120: NEG
32121: PUSH
32122: LD_INT 0
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 1
32143: NEG
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 0
32155: PUSH
32156: LD_INT 2
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 1
32166: PUSH
32167: LD_INT 1
32169: NEG
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: LD_INT 2
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: PUSH
32185: LD_INT 2
32187: PUSH
32188: LD_INT 1
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: LD_INT 2
32197: PUSH
32198: LD_INT 2
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: PUSH
32208: LD_INT 2
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 2
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: NEG
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 2
32238: NEG
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 2
32249: NEG
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: NEG
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: LD_INT 2
32276: NEG
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 1
32287: NEG
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 3
32295: PUSH
32296: LD_INT 1
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 3
32305: PUSH
32306: LD_INT 2
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32338: LD_ADDR_VAR 0 25
32342: PUSH
32343: LD_INT 0
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: NEG
32397: PUSH
32398: LD_INT 0
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: LD_INT 1
32407: NEG
32408: PUSH
32409: LD_INT 1
32411: NEG
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: LD_INT 2
32434: NEG
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 1
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: LD_INT 0
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: LD_INT 1
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 2
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 1
32483: PUSH
32484: LD_INT 2
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 0
32493: PUSH
32494: LD_INT 2
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: NEG
32504: PUSH
32505: LD_INT 1
32507: PUSH
32508: EMPTY
32509: LIST
32510: LIST
32511: PUSH
32512: LD_INT 2
32514: NEG
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: LD_INT 1
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: LD_INT 2
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 3
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 3
32559: PUSH
32560: LD_INT 2
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: LD_INT 3
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 3
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32612: LD_ADDR_VAR 0 26
32616: PUSH
32617: LD_INT 0
32619: PUSH
32620: LD_INT 0
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: LD_INT 1
32632: NEG
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 1
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: LD_INT 1
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: LD_INT 1
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 1
32670: NEG
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: NEG
32682: PUSH
32683: LD_INT 1
32685: NEG
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 1
32693: NEG
32694: PUSH
32695: LD_INT 2
32697: NEG
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: LD_INT 2
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: NEG
32800: PUSH
32801: LD_INT 1
32803: NEG
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: NEG
32812: PUSH
32813: LD_INT 2
32815: NEG
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: LD_INT 3
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: LD_INT 3
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: LD_INT 2
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 2
32854: NEG
32855: PUSH
32856: LD_INT 1
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32888: LD_ADDR_VAR 0 27
32892: PUSH
32893: LD_INT 0
32895: PUSH
32896: LD_INT 0
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: LD_INT 1
32908: NEG
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 1
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 1
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 0
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: LD_INT 2
32973: NEG
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 0
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: LD_INT 1
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 2
33003: PUSH
33004: LD_INT 0
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: LD_INT 1
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: LD_INT 2
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: LD_INT 2
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 0
33043: PUSH
33044: LD_INT 2
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 1
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: LD_INT 0
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: LD_INT 1
33079: NEG
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: NEG
33088: PUSH
33089: LD_INT 2
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 2
33110: NEG
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 3
33121: NEG
33122: PUSH
33123: LD_INT 1
33125: NEG
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 3
33133: NEG
33134: PUSH
33135: LD_INT 2
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33168: LD_ADDR_VAR 0 28
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 1
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 1
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: LD_INT 1
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: NEG
33227: PUSH
33228: LD_INT 0
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 1
33237: NEG
33238: PUSH
33239: LD_INT 1
33241: NEG
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: LD_INT 2
33253: NEG
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: LD_INT 1
33275: NEG
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: LD_INT 1
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 1
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 0
33323: PUSH
33324: LD_INT 2
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 1
33333: NEG
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 0
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 2
33355: NEG
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: LD_INT 2
33371: NEG
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 2
33379: NEG
33380: PUSH
33381: LD_INT 3
33383: NEG
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: LD_INT 3
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 3
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33450: LD_ADDR_VAR 0 29
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 1
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: NEG
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: LD_INT 2
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: LD_INT 1
33557: NEG
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: PUSH
33566: LD_INT 0
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 2
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: PUSH
33586: LD_INT 2
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 0
33595: PUSH
33596: LD_INT 2
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 1
33605: NEG
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: LD_INT 1
33620: NEG
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 2
33628: NEG
33629: PUSH
33630: LD_INT 2
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 2
33640: NEG
33641: PUSH
33642: LD_INT 3
33644: NEG
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: LD_INT 1
33655: NEG
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 3
33663: PUSH
33664: LD_INT 1
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: LD_INT 3
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 2
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 3
33694: NEG
33695: PUSH
33696: LD_INT 2
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33729: LD_ADDR_VAR 0 30
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: LD_INT 0
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: LD_INT 1
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 1
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: LD_INT 1
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 1
33787: NEG
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 1
33810: NEG
33811: PUSH
33812: LD_INT 2
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 0
33822: PUSH
33823: LD_INT 2
33825: NEG
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: LD_INT 1
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 2
33844: PUSH
33845: LD_INT 0
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 2
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 2
33864: PUSH
33865: LD_INT 2
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: NEG
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 2
33906: NEG
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 3
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 2
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: LD_INT 2
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: LD_INT 3
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 2
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 3
33972: NEG
33973: PUSH
33974: LD_INT 1
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34007: LD_ADDR_VAR 0 31
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 0
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: NEG
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 1
34088: NEG
34089: PUSH
34090: LD_INT 2
34092: NEG
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 2
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 2
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 2
34131: PUSH
34132: LD_INT 2
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: LD_INT 2
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 0
34151: PUSH
34152: LD_INT 2
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: NEG
34197: PUSH
34198: LD_INT 3
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: LD_INT 3
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 2
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 3
34250: NEG
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34285: LD_ADDR_VAR 0 32
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: LD_INT 2
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 2
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 0
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 1
34440: NEG
34441: PUSH
34442: LD_INT 1
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 2
34451: NEG
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 2
34462: NEG
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 3
34478: NEG
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: PUSH
34487: LD_INT 2
34489: NEG
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 3
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 3
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: NEG
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 3
34528: NEG
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34563: LD_ADDR_VAR 0 33
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: LD_INT 0
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 1
34601: PUSH
34602: LD_INT 1
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: LD_INT 1
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: LD_INT 1
34636: NEG
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: NEG
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 1
34687: PUSH
34688: LD_INT 2
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: LD_INT 2
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: NEG
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 2
34729: NEG
34730: PUSH
34731: LD_INT 1
34733: NEG
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 2
34741: NEG
34742: PUSH
34743: LD_INT 2
34745: NEG
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 2
34753: NEG
34754: PUSH
34755: LD_INT 3
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 2
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 3
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: LD_INT 3
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 3
34807: NEG
34808: PUSH
34809: LD_INT 2
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34842: LD_ADDR_VAR 0 34
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: LD_INT 0
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 0
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: LD_INT 1
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: LD_INT 1
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: LD_INT 0
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: NEG
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: LD_INT 2
34927: NEG
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 1
34946: PUSH
34947: LD_INT 1
34949: NEG
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 2
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 3
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 2
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 3
35056: PUSH
35057: LD_INT 2
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 2
35066: PUSH
35067: LD_INT 3
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 2
35076: NEG
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 3
35087: NEG
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35122: LD_ADDR_VAR 0 35
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: LD_INT 0
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: LD_INT 1
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 0
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: NEG
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 2
35213: NEG
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35234: LD_ADDR_VAR 0 36
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: LD_INT 1
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: LD_INT 0
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 1
35303: NEG
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 2
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: LD_INT 2
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35346: LD_ADDR_VAR 0 37
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: LD_INT 0
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: LD_INT 0
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35458: LD_ADDR_VAR 0 38
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 2
35549: NEG
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35570: LD_ADDR_VAR 0 39
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35682: LD_ADDR_VAR 0 40
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: NEG
35775: PUSH
35776: LD_INT 1
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35794: LD_ADDR_VAR 0 41
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 0
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 1
35863: NEG
35864: PUSH
35865: LD_INT 1
35867: NEG
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 1
35875: NEG
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 1
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 2
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 2
35960: NEG
35961: PUSH
35962: LD_INT 1
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 2
35972: NEG
35973: PUSH
35974: LD_INT 2
35976: NEG
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 2
35984: NEG
35985: PUSH
35986: LD_INT 3
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 2
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 3
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 3
36017: PUSH
36018: LD_INT 1
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: PUSH
36025: LD_INT 3
36027: PUSH
36028: LD_INT 2
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 3
36037: PUSH
36038: LD_INT 3
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: LD_INT 3
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: NEG
36058: PUSH
36059: LD_INT 1
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: NEG
36069: PUSH
36070: LD_INT 0
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 3
36079: NEG
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 3
36091: NEG
36092: PUSH
36093: LD_INT 2
36095: NEG
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 3
36103: NEG
36104: PUSH
36105: LD_INT 3
36107: NEG
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: EMPTY
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36144: LD_ADDR_VAR 0 42
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 0
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 1
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 0
36289: PUSH
36290: LD_INT 2
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: NEG
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: LD_INT 2
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 2
36334: NEG
36335: PUSH
36336: LD_INT 3
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 3
36350: NEG
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: LD_INT 3
36361: NEG
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: LD_INT 2
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 3
36380: PUSH
36381: LD_INT 2
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: LD_INT 3
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 3
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 3
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: LD_INT 3
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 1
36430: NEG
36431: PUSH
36432: LD_INT 2
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 3
36441: NEG
36442: PUSH
36443: LD_INT 2
36445: NEG
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 3
36453: NEG
36454: PUSH
36455: LD_INT 3
36457: NEG
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36494: LD_ADDR_VAR 0 43
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 0
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: LD_INT 1
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 0
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: NEG
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 2
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 1
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 2
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 2
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: LD_INT 2
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 2
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 1
36649: NEG
36650: PUSH
36651: LD_INT 1
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PUSH
36669: LD_INT 2
36671: NEG
36672: PUSH
36673: LD_INT 1
36675: NEG
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: NEG
36684: PUSH
36685: LD_INT 3
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 0
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 2
36709: NEG
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 2
36717: PUSH
36718: LD_INT 1
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 3
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 3
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: LD_INT 3
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 0
36758: PUSH
36759: LD_INT 3
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 2
36779: NEG
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 3
36790: NEG
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 3
36801: NEG
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: LIST
36815: LIST
36816: LIST
36817: LIST
36818: LIST
36819: LIST
36820: LIST
36821: LIST
36822: LIST
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36842: LD_ADDR_VAR 0 44
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 1
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 1
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 1
36900: NEG
36901: PUSH
36902: LD_INT 0
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 1
36923: NEG
36924: PUSH
36925: LD_INT 2
36927: NEG
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: LD_INT 1
36938: NEG
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 2
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 2
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 2
36966: PUSH
36967: LD_INT 2
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: LD_INT 2
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: NEG
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 2
36997: NEG
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: NEG
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: NEG
37021: PUSH
37022: LD_INT 2
37024: NEG
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 2
37032: NEG
37033: PUSH
37034: LD_INT 3
37036: NEG
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 2
37044: PUSH
37045: LD_INT 1
37047: NEG
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: LD_INT 0
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: LD_INT 1
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 3
37075: PUSH
37076: LD_INT 2
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 3
37085: PUSH
37086: LD_INT 3
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: LD_INT 3
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 2
37105: NEG
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: LD_INT 3
37116: NEG
37117: PUSH
37118: LD_INT 0
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 3
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 3
37139: NEG
37140: PUSH
37141: LD_INT 2
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 3
37151: NEG
37152: PUSH
37153: LD_INT 3
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37192: LD_ADDR_VAR 0 45
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 0
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 1
37220: PUSH
37221: LD_INT 0
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 1
37250: NEG
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 1
37261: NEG
37262: PUSH
37263: LD_INT 1
37265: NEG
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: LD_INT 2
37277: NEG
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: LD_INT 2
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: PUSH
37297: LD_INT 1
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: LD_INT 2
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 1
37327: PUSH
37328: LD_INT 2
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 0
37337: PUSH
37338: LD_INT 2
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 1
37347: NEG
37348: PUSH
37349: LD_INT 1
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: NEG
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 2
37382: NEG
37383: PUSH
37384: LD_INT 3
37386: NEG
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: LD_INT 3
37398: NEG
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 0
37406: PUSH
37407: LD_INT 3
37409: NEG
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 3
37428: PUSH
37429: LD_INT 2
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 3
37438: PUSH
37439: LD_INT 3
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: PUSH
37449: LD_INT 3
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: PUSH
37459: LD_INT 3
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 0
37468: PUSH
37469: LD_INT 3
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 1
37478: NEG
37479: PUSH
37480: LD_INT 2
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 3
37489: NEG
37490: PUSH
37491: LD_INT 2
37493: NEG
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: LD_INT 3
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37542: LD_ADDR_VAR 0 46
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 0
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 0
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 0
37590: PUSH
37591: LD_INT 1
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 0
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 2
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: LD_INT 2
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 0
37687: PUSH
37688: LD_INT 2
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 1
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 2
37708: NEG
37709: PUSH
37710: LD_INT 0
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: NEG
37720: PUSH
37721: LD_INT 1
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: LD_INT 3
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 0
37743: PUSH
37744: LD_INT 3
37746: NEG
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 2
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 2
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 3
37776: PUSH
37777: LD_INT 0
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: LD_INT 3
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 1
37796: PUSH
37797: LD_INT 3
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: LD_INT 3
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 1
37816: NEG
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 2
37827: NEG
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 3
37838: NEG
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 3
37849: NEG
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37890: LD_ADDR_VAR 0 47
37894: PUSH
37895: LD_INT 0
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 0
37907: PUSH
37908: LD_INT 1
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 1
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 1
37928: PUSH
37929: LD_INT 1
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 0
37938: PUSH
37939: LD_INT 1
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: LD_INT 0
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 1
37959: NEG
37960: PUSH
37961: LD_INT 1
37963: NEG
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 1
37971: NEG
37972: PUSH
37973: LD_INT 2
37975: NEG
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: LD_INT 2
37986: NEG
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 2
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: LD_INT 2
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38041: LD_ADDR_VAR 0 48
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 0
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 0
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 1
38110: NEG
38111: PUSH
38112: LD_INT 1
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: LD_INT 2
38126: NEG
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 0
38134: PUSH
38135: LD_INT 2
38137: NEG
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 2
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: PUSH
38167: LD_INT 1
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38188: LD_ADDR_VAR 0 49
38192: PUSH
38193: LD_INT 0
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: LD_INT 1
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 1
38226: PUSH
38227: LD_INT 1
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 0
38236: PUSH
38237: LD_INT 1
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 1
38257: NEG
38258: PUSH
38259: LD_INT 1
38261: NEG
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 2
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: PUSH
38301: LD_INT 2
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 1
38310: PUSH
38311: LD_INT 2
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38332: LD_ADDR_VAR 0 50
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 0
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: LD_INT 1
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 0
38380: PUSH
38381: LD_INT 1
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 1
38390: NEG
38391: PUSH
38392: LD_INT 0
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 1
38405: NEG
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 2
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: LD_INT 2
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: PUSH
38434: LD_INT 2
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 0
38443: PUSH
38444: LD_INT 2
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38476: LD_ADDR_VAR 0 51
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: PUSH
38515: LD_INT 1
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 0
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 1
38545: NEG
38546: PUSH
38547: LD_INT 1
38549: NEG
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 1
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 2
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: LD_INT 1
38603: NEG
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38623: LD_ADDR_VAR 0 52
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: LD_INT 1
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 1
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 1
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 1
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: LD_INT 1
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 2
38727: NEG
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 2
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: LIST
38770: LIST
38771: LIST
38772: LIST
38773: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38774: LD_ADDR_VAR 0 53
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: LD_INT 1
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 1
38802: PUSH
38803: LD_INT 0
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 1
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 1
38832: NEG
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: NEG
38844: PUSH
38845: LD_INT 1
38847: NEG
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: LD_INT 2
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 2
38870: NEG
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: LD_INT 1
38881: NEG
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 2
38889: PUSH
38890: LD_INT 0
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 2
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 2
38909: PUSH
38910: LD_INT 2
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: LD_INT 2
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 2
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 2
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 2
38973: NEG
38974: PUSH
38975: LD_INT 2
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: LIST
38987: LIST
38988: LIST
38989: LIST
38990: LIST
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39004: LD_ADDR_VAR 0 54
39008: PUSH
39009: LD_INT 0
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: LD_INT 1
39024: NEG
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 1
39042: PUSH
39043: LD_INT 1
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: LD_INT 1
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: LD_INT 1
39077: NEG
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 1
39085: NEG
39086: PUSH
39087: LD_INT 2
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: LD_INT 1
39111: NEG
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: LD_INT 2
39119: PUSH
39120: LD_INT 0
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 2
39129: PUSH
39130: LD_INT 1
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 2
39139: PUSH
39140: LD_INT 2
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: LD_INT 2
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: NEG
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: NEG
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 2
39191: NEG
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 2
39203: NEG
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: LIST
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39234: LD_ADDR_VAR 0 55
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: LD_INT 0
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 1
39272: PUSH
39273: LD_INT 1
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 1
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 1
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 0
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 2
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 2
39369: PUSH
39370: LD_INT 2
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: LD_INT 2
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: LD_INT 2
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: NEG
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 2
39410: NEG
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: NEG
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39464: LD_ADDR_VAR 0 56
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: NEG
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 1
39545: NEG
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 0
39557: PUSH
39558: LD_INT 2
39560: NEG
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 1
39568: PUSH
39569: LD_INT 1
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 2
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 2
39589: PUSH
39590: LD_INT 1
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: LD_INT 2
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: LD_INT 2
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 0
39619: PUSH
39620: LD_INT 2
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 1
39629: NEG
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: LD_INT 2
39640: NEG
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: LD_INT 1
39655: NEG
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: NEG
39664: PUSH
39665: LD_INT 2
39667: NEG
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: LIST
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39694: LD_ADDR_VAR 0 57
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: LD_INT 0
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 1
39722: PUSH
39723: LD_INT 0
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 0
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 1
39752: NEG
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: LD_INT 1
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 1
39775: NEG
39776: PUSH
39777: LD_INT 2
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 2
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 2
39809: PUSH
39810: LD_INT 0
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 2
39819: PUSH
39820: LD_INT 1
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: PUSH
39830: LD_INT 2
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: LD_INT 2
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 0
39849: PUSH
39850: LD_INT 2
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 1
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 2
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 2
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 2
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39924: LD_ADDR_VAR 0 58
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: LD_INT 0
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 1
39962: PUSH
39963: LD_INT 1
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 0
39972: PUSH
39973: LD_INT 1
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 1
39982: NEG
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 1
40005: NEG
40006: PUSH
40007: LD_INT 2
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: LD_INT 2
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 1
40028: PUSH
40029: LD_INT 1
40031: NEG
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 2
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 2
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 2
40059: PUSH
40060: LD_INT 2
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: PUSH
40070: LD_INT 2
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 0
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: NEG
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 2
40111: NEG
40112: PUSH
40113: LD_INT 1
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 2
40123: NEG
40124: PUSH
40125: LD_INT 2
40127: NEG
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40154: LD_ADDR_VAR 0 59
40158: PUSH
40159: LD_INT 0
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: LD_INT 0
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 1
40192: PUSH
40193: LD_INT 1
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: LD_INT 1
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 1
40212: NEG
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 1
40223: NEG
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40242: LD_ADDR_VAR 0 60
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: LD_INT 1
40262: NEG
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 1
40270: PUSH
40271: LD_INT 0
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 1
40280: PUSH
40281: LD_INT 1
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: LD_INT 1
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 1
40300: NEG
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: NEG
40312: PUSH
40313: LD_INT 1
40315: NEG
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40330: LD_ADDR_VAR 0 61
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: LD_INT 0
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: LD_INT 1
40350: NEG
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 0
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: PUSH
40369: LD_INT 1
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: LD_INT 1
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 1
40399: NEG
40400: PUSH
40401: LD_INT 1
40403: NEG
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40418: LD_ADDR_VAR 0 62
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: LD_INT 0
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: LD_INT 1
40438: NEG
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 1
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: LD_INT 1
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 0
40466: PUSH
40467: LD_INT 1
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 1
40476: NEG
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: NEG
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40506: LD_ADDR_VAR 0 63
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: LD_INT 0
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: LD_INT 1
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 1
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 1
40544: PUSH
40545: LD_INT 1
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: LD_INT 1
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 1
40564: NEG
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: LD_INT 1
40579: NEG
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40594: LD_ADDR_VAR 0 64
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: LD_INT 0
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: LD_INT 1
40614: NEG
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 1
40622: PUSH
40623: LD_INT 0
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 1
40632: PUSH
40633: LD_INT 1
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 0
40642: PUSH
40643: LD_INT 1
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 1
40652: NEG
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 1
40663: NEG
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: ST_TO_ADDR
// end ; 1 :
40682: GO 46579
40684: LD_INT 1
40686: DOUBLE
40687: EQUAL
40688: IFTRUE 40692
40690: GO 43315
40692: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40693: LD_ADDR_VAR 0 11
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: LD_INT 3
40704: NEG
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: LD_INT 3
40715: NEG
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: LD_INT 2
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: LIST
40736: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40737: LD_ADDR_VAR 0 12
40741: PUSH
40742: LD_INT 2
40744: PUSH
40745: LD_INT 1
40747: NEG
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 3
40755: PUSH
40756: LD_INT 0
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 3
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40778: LD_ADDR_VAR 0 13
40782: PUSH
40783: LD_INT 3
40785: PUSH
40786: LD_INT 2
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: PUSH
40796: LD_INT 3
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 2
40805: PUSH
40806: LD_INT 3
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40818: LD_ADDR_VAR 0 14
40822: PUSH
40823: LD_INT 1
40825: PUSH
40826: LD_INT 3
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 1
40845: NEG
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: LIST
40858: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40859: LD_ADDR_VAR 0 15
40863: PUSH
40864: LD_INT 2
40866: NEG
40867: PUSH
40868: LD_INT 1
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: NEG
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40903: LD_ADDR_VAR 0 16
40907: PUSH
40908: LD_INT 2
40910: NEG
40911: PUSH
40912: LD_INT 3
40914: NEG
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: NEG
40923: PUSH
40924: LD_INT 2
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 3
40934: NEG
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: LIST
40948: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40949: LD_ADDR_VAR 0 17
40953: PUSH
40954: LD_INT 1
40956: NEG
40957: PUSH
40958: LD_INT 3
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 0
40968: PUSH
40969: LD_INT 3
40971: NEG
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: LIST
40992: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40993: LD_ADDR_VAR 0 18
40997: PUSH
40998: LD_INT 2
41000: PUSH
41001: LD_INT 1
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 3
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: LD_INT 1
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: LIST
41033: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41034: LD_ADDR_VAR 0 19
41038: PUSH
41039: LD_INT 3
41041: PUSH
41042: LD_INT 2
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: LD_INT 3
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: PUSH
41062: LD_INT 3
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41074: LD_ADDR_VAR 0 20
41078: PUSH
41079: LD_INT 1
41081: PUSH
41082: LD_INT 3
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: LD_INT 3
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: LD_INT 2
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: LIST
41114: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41115: LD_ADDR_VAR 0 21
41119: PUSH
41120: LD_INT 2
41122: NEG
41123: PUSH
41124: LD_INT 1
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 3
41133: NEG
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 1
41148: NEG
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41159: LD_ADDR_VAR 0 22
41163: PUSH
41164: LD_INT 2
41166: NEG
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 3
41178: NEG
41179: PUSH
41180: LD_INT 2
41182: NEG
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 3
41190: NEG
41191: PUSH
41192: LD_INT 3
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41205: LD_ADDR_VAR 0 23
41209: PUSH
41210: LD_INT 0
41212: PUSH
41213: LD_INT 3
41215: NEG
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 1
41223: NEG
41224: PUSH
41225: LD_INT 4
41227: NEG
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: LD_INT 3
41238: NEG
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: LIST
41248: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41249: LD_ADDR_VAR 0 24
41253: PUSH
41254: LD_INT 3
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 3
41266: PUSH
41267: LD_INT 1
41269: NEG
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 4
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: LIST
41289: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41290: LD_ADDR_VAR 0 25
41294: PUSH
41295: LD_INT 3
41297: PUSH
41298: LD_INT 3
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 4
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 3
41317: PUSH
41318: LD_INT 4
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: LIST
41329: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41330: LD_ADDR_VAR 0 26
41334: PUSH
41335: LD_INT 0
41337: PUSH
41338: LD_INT 3
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 1
41357: NEG
41358: PUSH
41359: LD_INT 3
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: LIST
41370: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41371: LD_ADDR_VAR 0 27
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: LD_INT 1
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 4
41400: NEG
41401: PUSH
41402: LD_INT 1
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41415: LD_ADDR_VAR 0 28
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 3
41434: NEG
41435: PUSH
41436: LD_INT 4
41438: NEG
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 3
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: LIST
41460: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41461: LD_ADDR_VAR 0 29
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 3
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 2
41494: NEG
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 1
41502: NEG
41503: PUSH
41504: LD_INT 4
41506: NEG
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 0
41514: PUSH
41515: LD_INT 4
41517: NEG
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: LD_INT 3
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: LD_INT 5
41540: NEG
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 0
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: LD_INT 4
41562: NEG
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: LD_INT 6
41574: NEG
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 6
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 1
41593: PUSH
41594: LD_INT 5
41596: NEG
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41616: LD_ADDR_VAR 0 30
41620: PUSH
41621: LD_INT 2
41623: PUSH
41624: LD_INT 1
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: PUSH
41635: LD_INT 0
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 3
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 3
41654: PUSH
41655: LD_INT 1
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 4
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 4
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 4
41685: PUSH
41686: LD_INT 1
41688: NEG
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: LD_INT 5
41696: PUSH
41697: LD_INT 0
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 5
41706: PUSH
41707: LD_INT 1
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 5
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 6
41727: PUSH
41728: LD_INT 0
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 6
41737: PUSH
41738: LD_INT 1
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41759: LD_ADDR_VAR 0 31
41763: PUSH
41764: LD_INT 3
41766: PUSH
41767: LD_INT 2
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: PUSH
41777: LD_INT 3
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 2
41786: PUSH
41787: LD_INT 3
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 4
41796: PUSH
41797: LD_INT 3
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 4
41806: PUSH
41807: LD_INT 4
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 3
41816: PUSH
41817: LD_INT 4
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 5
41826: PUSH
41827: LD_INT 4
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 5
41836: PUSH
41837: LD_INT 5
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 4
41846: PUSH
41847: LD_INT 5
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 6
41856: PUSH
41857: LD_INT 5
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 6
41866: PUSH
41867: LD_INT 6
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 5
41876: PUSH
41877: LD_INT 6
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: LIST
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41898: LD_ADDR_VAR 0 32
41902: PUSH
41903: LD_INT 1
41905: PUSH
41906: LD_INT 3
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 0
41915: PUSH
41916: LD_INT 3
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 1
41925: NEG
41926: PUSH
41927: LD_INT 2
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 1
41936: PUSH
41937: LD_INT 4
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: LD_INT 4
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: NEG
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 1
41967: PUSH
41968: LD_INT 5
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 0
41977: PUSH
41978: LD_INT 5
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 4
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 1
41998: PUSH
41999: LD_INT 6
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 0
42008: PUSH
42009: LD_INT 6
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 5
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: LIST
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: LIST
42040: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42041: LD_ADDR_VAR 0 33
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: LD_INT 0
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 3
42070: NEG
42071: PUSH
42072: LD_INT 1
42074: NEG
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 3
42082: NEG
42083: PUSH
42084: LD_INT 1
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: NEG
42094: PUSH
42095: LD_INT 0
42097: PUSH
42098: EMPTY
42099: LIST
42100: LIST
42101: PUSH
42102: LD_INT 4
42104: NEG
42105: PUSH
42106: LD_INT 1
42108: NEG
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 4
42116: NEG
42117: PUSH
42118: LD_INT 1
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 5
42127: NEG
42128: PUSH
42129: LD_INT 0
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 5
42138: NEG
42139: PUSH
42140: LD_INT 1
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 5
42150: NEG
42151: PUSH
42152: LD_INT 1
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 6
42161: NEG
42162: PUSH
42163: LD_INT 0
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 6
42172: NEG
42173: PUSH
42174: LD_INT 1
42176: NEG
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42196: LD_ADDR_VAR 0 34
42200: PUSH
42201: LD_INT 2
42203: NEG
42204: PUSH
42205: LD_INT 3
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 3
42239: NEG
42240: PUSH
42241: LD_INT 4
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 4
42251: NEG
42252: PUSH
42253: LD_INT 3
42255: NEG
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 4
42263: NEG
42264: PUSH
42265: LD_INT 4
42267: NEG
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 4
42275: NEG
42276: PUSH
42277: LD_INT 5
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 5
42287: NEG
42288: PUSH
42289: LD_INT 4
42291: NEG
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 5
42299: NEG
42300: PUSH
42301: LD_INT 5
42303: NEG
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: LD_INT 5
42311: NEG
42312: PUSH
42313: LD_INT 6
42315: NEG
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 6
42323: NEG
42324: PUSH
42325: LD_INT 5
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 6
42335: NEG
42336: PUSH
42337: LD_INT 6
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42359: LD_ADDR_VAR 0 41
42363: PUSH
42364: LD_INT 0
42366: PUSH
42367: LD_INT 2
42369: NEG
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 1
42377: NEG
42378: PUSH
42379: LD_INT 3
42381: NEG
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 1
42389: PUSH
42390: LD_INT 2
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: LIST
42402: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42403: LD_ADDR_VAR 0 42
42407: PUSH
42408: LD_INT 2
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 2
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 3
42431: PUSH
42432: LD_INT 1
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: LIST
42443: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42444: LD_ADDR_VAR 0 43
42448: PUSH
42449: LD_INT 2
42451: PUSH
42452: LD_INT 2
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 3
42461: PUSH
42462: LD_INT 2
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 2
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: LIST
42483: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42484: LD_ADDR_VAR 0 44
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 2
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 1
42511: NEG
42512: PUSH
42513: LD_INT 2
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: LIST
42524: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42525: LD_ADDR_VAR 0 45
42529: PUSH
42530: LD_INT 2
42532: NEG
42533: PUSH
42534: LD_INT 0
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: LD_INT 1
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 3
42554: NEG
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: LIST
42568: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42569: LD_ADDR_VAR 0 46
42573: PUSH
42574: LD_INT 2
42576: NEG
42577: PUSH
42578: LD_INT 2
42580: NEG
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 2
42588: NEG
42589: PUSH
42590: LD_INT 3
42592: NEG
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 3
42600: NEG
42601: PUSH
42602: LD_INT 2
42604: NEG
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: LIST
42614: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42615: LD_ADDR_VAR 0 47
42619: PUSH
42620: LD_INT 2
42622: NEG
42623: PUSH
42624: LD_INT 3
42626: NEG
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 1
42634: NEG
42635: PUSH
42636: LD_INT 3
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42648: LD_ADDR_VAR 0 48
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: LD_INT 2
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 2
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42679: LD_ADDR_VAR 0 49
42683: PUSH
42684: LD_INT 3
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 3
42696: PUSH
42697: LD_INT 2
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42708: LD_ADDR_VAR 0 50
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: LD_INT 3
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 1
42725: PUSH
42726: LD_INT 3
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42737: LD_ADDR_VAR 0 51
42741: PUSH
42742: LD_INT 1
42744: NEG
42745: PUSH
42746: LD_INT 2
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 2
42755: NEG
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42768: LD_ADDR_VAR 0 52
42772: PUSH
42773: LD_INT 3
42775: NEG
42776: PUSH
42777: LD_INT 1
42779: NEG
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: LD_INT 2
42791: NEG
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42801: LD_ADDR_VAR 0 53
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 3
42812: NEG
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: LD_INT 3
42823: NEG
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 1
42831: PUSH
42832: LD_INT 2
42834: NEG
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: LIST
42844: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42845: LD_ADDR_VAR 0 54
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: LD_INT 1
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 3
42863: PUSH
42864: LD_INT 0
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PUSH
42871: LD_INT 3
42873: PUSH
42874: LD_INT 1
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: LIST
42885: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42886: LD_ADDR_VAR 0 55
42890: PUSH
42891: LD_INT 3
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: LD_INT 3
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 2
42913: PUSH
42914: LD_INT 3
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: LIST
42925: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42926: LD_ADDR_VAR 0 56
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 3
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 0
42943: PUSH
42944: LD_INT 3
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 1
42953: NEG
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: LIST
42966: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42967: LD_ADDR_VAR 0 57
42971: PUSH
42972: LD_INT 2
42974: NEG
42975: PUSH
42976: LD_INT 1
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 3
42985: NEG
42986: PUSH
42987: LD_INT 0
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: PUSH
42994: LD_INT 3
42996: NEG
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43011: LD_ADDR_VAR 0 58
43015: PUSH
43016: LD_INT 2
43018: NEG
43019: PUSH
43020: LD_INT 3
43022: NEG
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: LD_INT 3
43030: NEG
43031: PUSH
43032: LD_INT 2
43034: NEG
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 3
43042: NEG
43043: PUSH
43044: LD_INT 3
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: LIST
43056: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43057: LD_ADDR_VAR 0 59
43061: PUSH
43062: LD_INT 1
43064: NEG
43065: PUSH
43066: LD_INT 2
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: LD_INT 2
43079: NEG
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 1
43087: PUSH
43088: LD_INT 1
43090: NEG
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: LIST
43100: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43101: LD_ADDR_VAR 0 60
43105: PUSH
43106: LD_INT 1
43108: PUSH
43109: LD_INT 1
43111: NEG
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 2
43119: PUSH
43120: LD_INT 0
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 2
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: LIST
43141: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43142: LD_ADDR_VAR 0 61
43146: PUSH
43147: LD_INT 2
43149: PUSH
43150: LD_INT 1
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: PUSH
43160: LD_INT 2
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: PUSH
43170: LD_INT 2
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43182: LD_ADDR_VAR 0 62
43186: PUSH
43187: LD_INT 1
43189: PUSH
43190: LD_INT 2
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 0
43199: PUSH
43200: LD_INT 2
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 1
43209: NEG
43210: PUSH
43211: LD_INT 1
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: LIST
43222: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43223: LD_ADDR_VAR 0 63
43227: PUSH
43228: LD_INT 1
43230: NEG
43231: PUSH
43232: LD_INT 1
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: LD_INT 0
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: LD_INT 2
43252: NEG
43253: PUSH
43254: LD_INT 1
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43267: LD_ADDR_VAR 0 64
43271: PUSH
43272: LD_INT 1
43274: NEG
43275: PUSH
43276: LD_INT 2
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 2
43286: NEG
43287: PUSH
43288: LD_INT 1
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 2
43298: NEG
43299: PUSH
43300: LD_INT 2
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: LIST
43312: ST_TO_ADDR
// end ; 2 :
43313: GO 46579
43315: LD_INT 2
43317: DOUBLE
43318: EQUAL
43319: IFTRUE 43323
43321: GO 46578
43323: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43324: LD_ADDR_VAR 0 29
43328: PUSH
43329: LD_INT 4
43331: PUSH
43332: LD_INT 0
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 4
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 5
43352: PUSH
43353: LD_INT 0
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 5
43362: PUSH
43363: LD_INT 1
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 4
43372: PUSH
43373: LD_INT 1
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 3
43382: PUSH
43383: LD_INT 0
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 3
43392: PUSH
43393: LD_INT 1
43395: NEG
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 2
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 5
43414: PUSH
43415: LD_INT 2
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 3
43424: PUSH
43425: LD_INT 3
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 3
43434: PUSH
43435: LD_INT 2
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 4
43444: PUSH
43445: LD_INT 3
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 4
43454: PUSH
43455: LD_INT 4
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 3
43464: PUSH
43465: LD_INT 4
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 3
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 2
43484: PUSH
43485: LD_INT 2
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 4
43494: PUSH
43495: LD_INT 2
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 2
43504: PUSH
43505: LD_INT 4
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 0
43514: PUSH
43515: LD_INT 4
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: LD_INT 3
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 1
43534: PUSH
43535: LD_INT 4
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: LD_INT 5
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 0
43554: PUSH
43555: LD_INT 5
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 1
43564: NEG
43565: PUSH
43566: LD_INT 4
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 1
43575: NEG
43576: PUSH
43577: LD_INT 3
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 2
43586: PUSH
43587: LD_INT 5
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 2
43596: NEG
43597: PUSH
43598: LD_INT 3
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 3
43607: NEG
43608: PUSH
43609: LD_INT 0
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 3
43618: NEG
43619: PUSH
43620: LD_INT 1
43622: NEG
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: NEG
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 2
43641: NEG
43642: PUSH
43643: LD_INT 1
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 3
43652: NEG
43653: PUSH
43654: LD_INT 1
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 4
43663: NEG
43664: PUSH
43665: LD_INT 0
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 4
43674: NEG
43675: PUSH
43676: LD_INT 1
43678: NEG
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 4
43686: NEG
43687: PUSH
43688: LD_INT 2
43690: NEG
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: LD_INT 2
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 4
43709: NEG
43710: PUSH
43711: LD_INT 4
43713: NEG
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 4
43721: NEG
43722: PUSH
43723: LD_INT 5
43725: NEG
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 3
43733: NEG
43734: PUSH
43735: LD_INT 4
43737: NEG
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: LD_INT 3
43749: NEG
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 4
43757: NEG
43758: PUSH
43759: LD_INT 3
43761: NEG
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: LD_INT 5
43769: NEG
43770: PUSH
43771: LD_INT 4
43773: NEG
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: LD_INT 5
43785: NEG
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 3
43793: NEG
43794: PUSH
43795: LD_INT 5
43797: NEG
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 5
43805: NEG
43806: PUSH
43807: LD_INT 3
43809: NEG
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43862: LD_ADDR_VAR 0 30
43866: PUSH
43867: LD_INT 4
43869: PUSH
43870: LD_INT 4
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 4
43879: PUSH
43880: LD_INT 3
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 5
43889: PUSH
43890: LD_INT 4
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 5
43899: PUSH
43900: LD_INT 5
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 4
43909: PUSH
43910: LD_INT 5
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: PUSH
43920: LD_INT 4
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 3
43929: PUSH
43930: LD_INT 3
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 5
43939: PUSH
43940: LD_INT 3
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 3
43949: PUSH
43950: LD_INT 5
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 0
43959: PUSH
43960: LD_INT 3
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 0
43969: PUSH
43970: LD_INT 2
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 1
43979: PUSH
43980: LD_INT 3
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PUSH
43987: LD_INT 1
43989: PUSH
43990: LD_INT 4
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 0
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: NEG
44010: PUSH
44011: LD_INT 3
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 1
44020: NEG
44021: PUSH
44022: LD_INT 2
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 2
44041: NEG
44042: PUSH
44043: LD_INT 2
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 4
44052: NEG
44053: PUSH
44054: LD_INT 0
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 4
44063: NEG
44064: PUSH
44065: LD_INT 1
44067: NEG
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 3
44075: NEG
44076: PUSH
44077: LD_INT 0
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 3
44086: NEG
44087: PUSH
44088: LD_INT 1
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 4
44097: NEG
44098: PUSH
44099: LD_INT 1
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 5
44108: NEG
44109: PUSH
44110: LD_INT 0
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: LD_INT 5
44119: NEG
44120: PUSH
44121: LD_INT 1
44123: NEG
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 5
44131: NEG
44132: PUSH
44133: LD_INT 2
44135: NEG
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 3
44143: NEG
44144: PUSH
44145: LD_INT 2
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 3
44154: NEG
44155: PUSH
44156: LD_INT 3
44158: NEG
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 3
44166: NEG
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: EMPTY
44173: LIST
44174: LIST
44175: PUSH
44176: LD_INT 2
44178: NEG
44179: PUSH
44180: LD_INT 3
44182: NEG
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 2
44190: NEG
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 3
44202: NEG
44203: PUSH
44204: LD_INT 2
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 4
44214: NEG
44215: PUSH
44216: LD_INT 3
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: LD_INT 4
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 2
44238: NEG
44239: PUSH
44240: LD_INT 4
44242: NEG
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 4
44250: NEG
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: LD_INT 4
44265: NEG
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 5
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 1
44284: PUSH
44285: LD_INT 4
44287: NEG
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 1
44295: PUSH
44296: LD_INT 3
44298: NEG
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 0
44306: PUSH
44307: LD_INT 3
44309: NEG
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 1
44317: NEG
44318: PUSH
44319: LD_INT 4
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 1
44329: NEG
44330: PUSH
44331: LD_INT 5
44333: NEG
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 2
44341: PUSH
44342: LD_INT 3
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: LD_INT 5
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44409: LD_ADDR_VAR 0 31
44413: PUSH
44414: LD_INT 0
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: LD_INT 3
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 1
44436: PUSH
44437: LD_INT 4
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: PUSH
44447: LD_INT 5
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: LD_INT 5
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 1
44466: NEG
44467: PUSH
44468: LD_INT 4
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 1
44477: NEG
44478: PUSH
44479: LD_INT 3
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PUSH
44486: LD_INT 2
44488: PUSH
44489: LD_INT 5
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 2
44498: NEG
44499: PUSH
44500: LD_INT 3
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 3
44509: NEG
44510: PUSH
44511: LD_INT 0
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 3
44520: NEG
44521: PUSH
44522: LD_INT 1
44524: NEG
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 2
44532: NEG
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: LD_INT 1
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 3
44554: NEG
44555: PUSH
44556: LD_INT 1
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 4
44565: NEG
44566: PUSH
44567: LD_INT 0
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: LD_INT 4
44576: NEG
44577: PUSH
44578: LD_INT 1
44580: NEG
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 4
44588: NEG
44589: PUSH
44590: LD_INT 2
44592: NEG
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 2
44600: NEG
44601: PUSH
44602: LD_INT 2
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: LD_INT 4
44611: NEG
44612: PUSH
44613: LD_INT 4
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 4
44623: NEG
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 3
44635: NEG
44636: PUSH
44637: LD_INT 4
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 3
44647: NEG
44648: PUSH
44649: LD_INT 3
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 4
44659: NEG
44660: PUSH
44661: LD_INT 3
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 5
44671: NEG
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 5
44683: NEG
44684: PUSH
44685: LD_INT 5
44687: NEG
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 3
44695: NEG
44696: PUSH
44697: LD_INT 5
44699: NEG
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 5
44707: NEG
44708: PUSH
44709: LD_INT 3
44711: NEG
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: LD_INT 3
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 1
44741: PUSH
44742: LD_INT 3
44744: NEG
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 1
44752: PUSH
44753: LD_INT 2
44755: NEG
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 0
44763: PUSH
44764: LD_INT 2
44766: NEG
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 1
44774: NEG
44775: PUSH
44776: LD_INT 3
44778: NEG
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: LD_INT 1
44786: NEG
44787: PUSH
44788: LD_INT 4
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 2
44798: PUSH
44799: LD_INT 2
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 2
44809: NEG
44810: PUSH
44811: LD_INT 4
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 4
44821: PUSH
44822: LD_INT 0
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 4
44831: PUSH
44832: LD_INT 1
44834: NEG
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 5
44842: PUSH
44843: LD_INT 0
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 5
44852: PUSH
44853: LD_INT 1
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: PUSH
44863: LD_INT 1
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 3
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 3
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 2
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 5
44904: PUSH
44905: LD_INT 2
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44959: LD_ADDR_VAR 0 32
44963: PUSH
44964: LD_INT 4
44966: NEG
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 4
44977: NEG
44978: PUSH
44979: LD_INT 1
44981: NEG
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 3
44989: NEG
44990: PUSH
44991: LD_INT 0
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 3
45000: NEG
45001: PUSH
45002: LD_INT 1
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: LD_INT 4
45011: NEG
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: PUSH
45020: LD_INT 5
45022: NEG
45023: PUSH
45024: LD_INT 0
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 5
45033: NEG
45034: PUSH
45035: LD_INT 1
45037: NEG
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_INT 5
45045: NEG
45046: PUSH
45047: LD_INT 2
45049: NEG
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 3
45057: NEG
45058: PUSH
45059: LD_INT 2
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 3
45068: NEG
45069: PUSH
45070: LD_INT 3
45072: NEG
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 3
45080: NEG
45081: PUSH
45082: LD_INT 4
45084: NEG
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 2
45092: NEG
45093: PUSH
45094: LD_INT 3
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 2
45104: NEG
45105: PUSH
45106: LD_INT 2
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 3
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 4
45128: NEG
45129: PUSH
45130: LD_INT 3
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 4
45140: NEG
45141: PUSH
45142: LD_INT 4
45144: NEG
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: LD_INT 2
45152: NEG
45153: PUSH
45154: LD_INT 4
45156: NEG
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: LD_INT 4
45164: NEG
45165: PUSH
45166: LD_INT 2
45168: NEG
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 0
45176: PUSH
45177: LD_INT 4
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: LD_INT 5
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 1
45198: PUSH
45199: LD_INT 4
45201: NEG
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 1
45209: PUSH
45210: LD_INT 3
45212: NEG
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 0
45220: PUSH
45221: LD_INT 3
45223: NEG
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 1
45231: NEG
45232: PUSH
45233: LD_INT 4
45235: NEG
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 1
45243: NEG
45244: PUSH
45245: LD_INT 5
45247: NEG
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 2
45255: PUSH
45256: LD_INT 3
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 2
45266: NEG
45267: PUSH
45268: LD_INT 5
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 3
45278: PUSH
45279: LD_INT 0
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 3
45288: PUSH
45289: LD_INT 1
45291: NEG
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 4
45299: PUSH
45300: LD_INT 0
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 4
45309: PUSH
45310: LD_INT 1
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: LD_INT 1
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 2
45329: PUSH
45330: LD_INT 0
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 2
45339: PUSH
45340: LD_INT 1
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 2
45350: PUSH
45351: LD_INT 2
45353: NEG
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 4
45361: PUSH
45362: LD_INT 2
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 4
45371: PUSH
45372: LD_INT 4
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: LD_INT 3
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 5
45391: PUSH
45392: LD_INT 4
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 5
45401: PUSH
45402: LD_INT 5
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 4
45411: PUSH
45412: LD_INT 5
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: PUSH
45422: LD_INT 4
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: LD_INT 3
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 5
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 3
45451: PUSH
45452: LD_INT 5
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45506: LD_ADDR_VAR 0 33
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: LD_INT 4
45517: NEG
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: LD_INT 4
45525: NEG
45526: PUSH
45527: LD_INT 5
45529: NEG
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: NEG
45538: PUSH
45539: LD_INT 4
45541: NEG
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 3
45549: NEG
45550: PUSH
45551: LD_INT 3
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 4
45561: NEG
45562: PUSH
45563: LD_INT 3
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 5
45573: NEG
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 5
45585: NEG
45586: PUSH
45587: LD_INT 5
45589: NEG
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: LD_INT 3
45597: NEG
45598: PUSH
45599: LD_INT 5
45601: NEG
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 5
45609: NEG
45610: PUSH
45611: LD_INT 3
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 0
45621: PUSH
45622: LD_INT 3
45624: NEG
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 0
45632: PUSH
45633: LD_INT 4
45635: NEG
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 1
45643: PUSH
45644: LD_INT 3
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 1
45654: PUSH
45655: LD_INT 2
45657: NEG
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PUSH
45663: LD_INT 0
45665: PUSH
45666: LD_INT 2
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 1
45676: NEG
45677: PUSH
45678: LD_INT 3
45680: NEG
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 1
45688: NEG
45689: PUSH
45690: LD_INT 4
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 2
45700: PUSH
45701: LD_INT 2
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 2
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 4
45723: PUSH
45724: LD_INT 0
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 4
45733: PUSH
45734: LD_INT 1
45736: NEG
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 5
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 5
45754: PUSH
45755: LD_INT 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 4
45764: PUSH
45765: LD_INT 1
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: LD_INT 0
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 3
45784: PUSH
45785: LD_INT 1
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 3
45795: PUSH
45796: LD_INT 2
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 5
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 3
45816: PUSH
45817: LD_INT 3
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: LD_INT 3
45826: PUSH
45827: LD_INT 2
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 4
45836: PUSH
45837: LD_INT 3
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 4
45846: PUSH
45847: LD_INT 4
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: LD_INT 4
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 2
45866: PUSH
45867: LD_INT 3
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 2
45876: PUSH
45877: LD_INT 2
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 4
45886: PUSH
45887: LD_INT 2
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 2
45896: PUSH
45897: LD_INT 4
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 0
45906: PUSH
45907: LD_INT 4
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 0
45916: PUSH
45917: LD_INT 3
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 1
45926: PUSH
45927: LD_INT 4
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 1
45936: PUSH
45937: LD_INT 5
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 0
45946: PUSH
45947: LD_INT 5
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 1
45956: NEG
45957: PUSH
45958: LD_INT 4
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 1
45967: NEG
45968: PUSH
45969: LD_INT 3
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 2
45978: PUSH
45979: LD_INT 5
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 2
45988: NEG
45989: PUSH
45990: LD_INT 3
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46044: LD_ADDR_VAR 0 34
46048: PUSH
46049: LD_INT 0
46051: PUSH
46052: LD_INT 4
46054: NEG
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: LD_INT 5
46065: NEG
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 1
46073: PUSH
46074: LD_INT 4
46076: NEG
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 1
46084: PUSH
46085: LD_INT 3
46087: NEG
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 0
46095: PUSH
46096: LD_INT 3
46098: NEG
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 1
46106: NEG
46107: PUSH
46108: LD_INT 4
46110: NEG
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 1
46118: NEG
46119: PUSH
46120: LD_INT 5
46122: NEG
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 2
46130: PUSH
46131: LD_INT 3
46133: NEG
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 2
46141: NEG
46142: PUSH
46143: LD_INT 5
46145: NEG
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 3
46153: PUSH
46154: LD_INT 0
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 3
46163: PUSH
46164: LD_INT 1
46166: NEG
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 4
46174: PUSH
46175: LD_INT 0
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 4
46184: PUSH
46185: LD_INT 1
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 3
46194: PUSH
46195: LD_INT 1
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 2
46204: PUSH
46205: LD_INT 0
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 2
46214: PUSH
46215: LD_INT 1
46217: NEG
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 2
46225: PUSH
46226: LD_INT 2
46228: NEG
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 4
46236: PUSH
46237: LD_INT 2
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: LD_INT 4
46246: PUSH
46247: LD_INT 4
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 5
46266: PUSH
46267: LD_INT 4
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 5
46276: PUSH
46277: LD_INT 5
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 4
46286: PUSH
46287: LD_INT 5
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 3
46296: PUSH
46297: LD_INT 4
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 3
46306: PUSH
46307: LD_INT 3
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 5
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: LD_INT 5
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 0
46336: PUSH
46337: LD_INT 3
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: LD_INT 0
46346: PUSH
46347: LD_INT 2
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: LD_INT 3
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: LD_INT 1
46366: PUSH
46367: LD_INT 4
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 0
46376: PUSH
46377: LD_INT 4
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 1
46386: NEG
46387: PUSH
46388: LD_INT 3
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 1
46397: NEG
46398: PUSH
46399: LD_INT 2
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 2
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 2
46418: NEG
46419: PUSH
46420: LD_INT 2
46422: PUSH
46423: EMPTY
46424: LIST
46425: LIST
46426: PUSH
46427: LD_INT 4
46429: NEG
46430: PUSH
46431: LD_INT 0
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 4
46440: NEG
46441: PUSH
46442: LD_INT 1
46444: NEG
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 3
46452: NEG
46453: PUSH
46454: LD_INT 0
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 3
46463: NEG
46464: PUSH
46465: LD_INT 1
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: PUSH
46472: LD_INT 4
46474: NEG
46475: PUSH
46476: LD_INT 1
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: PUSH
46483: LD_INT 5
46485: NEG
46486: PUSH
46487: LD_INT 0
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 5
46496: NEG
46497: PUSH
46498: LD_INT 1
46500: NEG
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 5
46508: NEG
46509: PUSH
46510: LD_INT 2
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: LD_INT 2
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: ST_TO_ADDR
// end ; end ;
46576: GO 46579
46578: POP
// case btype of b_depot , b_warehouse :
46579: LD_VAR 0 1
46583: PUSH
46584: LD_INT 0
46586: DOUBLE
46587: EQUAL
46588: IFTRUE 46598
46590: LD_INT 1
46592: DOUBLE
46593: EQUAL
46594: IFTRUE 46598
46596: GO 46799
46598: POP
// case nation of nation_american :
46599: LD_VAR 0 5
46603: PUSH
46604: LD_INT 1
46606: DOUBLE
46607: EQUAL
46608: IFTRUE 46612
46610: GO 46668
46612: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46613: LD_ADDR_VAR 0 9
46617: PUSH
46618: LD_VAR 0 11
46622: PUSH
46623: LD_VAR 0 12
46627: PUSH
46628: LD_VAR 0 13
46632: PUSH
46633: LD_VAR 0 14
46637: PUSH
46638: LD_VAR 0 15
46642: PUSH
46643: LD_VAR 0 16
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 4
46660: PUSH
46661: LD_INT 1
46663: PLUS
46664: ARRAY
46665: ST_TO_ADDR
46666: GO 46797
46668: LD_INT 2
46670: DOUBLE
46671: EQUAL
46672: IFTRUE 46676
46674: GO 46732
46676: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 17
46686: PUSH
46687: LD_VAR 0 18
46691: PUSH
46692: LD_VAR 0 19
46696: PUSH
46697: LD_VAR 0 20
46701: PUSH
46702: LD_VAR 0 21
46706: PUSH
46707: LD_VAR 0 22
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: PUSH
46720: LD_VAR 0 4
46724: PUSH
46725: LD_INT 1
46727: PLUS
46728: ARRAY
46729: ST_TO_ADDR
46730: GO 46797
46732: LD_INT 3
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46740
46738: GO 46796
46740: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46741: LD_ADDR_VAR 0 9
46745: PUSH
46746: LD_VAR 0 23
46750: PUSH
46751: LD_VAR 0 24
46755: PUSH
46756: LD_VAR 0 25
46760: PUSH
46761: LD_VAR 0 26
46765: PUSH
46766: LD_VAR 0 27
46770: PUSH
46771: LD_VAR 0 28
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: PUSH
46784: LD_VAR 0 4
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: ARRAY
46793: ST_TO_ADDR
46794: GO 46797
46796: POP
46797: GO 47346
46799: LD_INT 2
46801: DOUBLE
46802: EQUAL
46803: IFTRUE 46813
46805: LD_INT 3
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46813
46811: GO 46869
46813: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46814: LD_ADDR_VAR 0 9
46818: PUSH
46819: LD_VAR 0 29
46823: PUSH
46824: LD_VAR 0 30
46828: PUSH
46829: LD_VAR 0 31
46833: PUSH
46834: LD_VAR 0 32
46838: PUSH
46839: LD_VAR 0 33
46843: PUSH
46844: LD_VAR 0 34
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: PUSH
46857: LD_VAR 0 4
46861: PUSH
46862: LD_INT 1
46864: PLUS
46865: ARRAY
46866: ST_TO_ADDR
46867: GO 47346
46869: LD_INT 16
46871: DOUBLE
46872: EQUAL
46873: IFTRUE 46925
46875: LD_INT 17
46877: DOUBLE
46878: EQUAL
46879: IFTRUE 46925
46881: LD_INT 18
46883: DOUBLE
46884: EQUAL
46885: IFTRUE 46925
46887: LD_INT 19
46889: DOUBLE
46890: EQUAL
46891: IFTRUE 46925
46893: LD_INT 20
46895: DOUBLE
46896: EQUAL
46897: IFTRUE 46925
46899: LD_INT 21
46901: DOUBLE
46902: EQUAL
46903: IFTRUE 46925
46905: LD_INT 23
46907: DOUBLE
46908: EQUAL
46909: IFTRUE 46925
46911: LD_INT 24
46913: DOUBLE
46914: EQUAL
46915: IFTRUE 46925
46917: LD_INT 25
46919: DOUBLE
46920: EQUAL
46921: IFTRUE 46925
46923: GO 46981
46925: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46926: LD_ADDR_VAR 0 9
46930: PUSH
46931: LD_VAR 0 35
46935: PUSH
46936: LD_VAR 0 36
46940: PUSH
46941: LD_VAR 0 37
46945: PUSH
46946: LD_VAR 0 38
46950: PUSH
46951: LD_VAR 0 39
46955: PUSH
46956: LD_VAR 0 40
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: PUSH
46969: LD_VAR 0 4
46973: PUSH
46974: LD_INT 1
46976: PLUS
46977: ARRAY
46978: ST_TO_ADDR
46979: GO 47346
46981: LD_INT 6
46983: DOUBLE
46984: EQUAL
46985: IFTRUE 47037
46987: LD_INT 7
46989: DOUBLE
46990: EQUAL
46991: IFTRUE 47037
46993: LD_INT 8
46995: DOUBLE
46996: EQUAL
46997: IFTRUE 47037
46999: LD_INT 13
47001: DOUBLE
47002: EQUAL
47003: IFTRUE 47037
47005: LD_INT 12
47007: DOUBLE
47008: EQUAL
47009: IFTRUE 47037
47011: LD_INT 15
47013: DOUBLE
47014: EQUAL
47015: IFTRUE 47037
47017: LD_INT 11
47019: DOUBLE
47020: EQUAL
47021: IFTRUE 47037
47023: LD_INT 14
47025: DOUBLE
47026: EQUAL
47027: IFTRUE 47037
47029: LD_INT 10
47031: DOUBLE
47032: EQUAL
47033: IFTRUE 47037
47035: GO 47093
47037: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47038: LD_ADDR_VAR 0 9
47042: PUSH
47043: LD_VAR 0 41
47047: PUSH
47048: LD_VAR 0 42
47052: PUSH
47053: LD_VAR 0 43
47057: PUSH
47058: LD_VAR 0 44
47062: PUSH
47063: LD_VAR 0 45
47067: PUSH
47068: LD_VAR 0 46
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: PUSH
47081: LD_VAR 0 4
47085: PUSH
47086: LD_INT 1
47088: PLUS
47089: ARRAY
47090: ST_TO_ADDR
47091: GO 47346
47093: LD_INT 36
47095: DOUBLE
47096: EQUAL
47097: IFTRUE 47101
47099: GO 47157
47101: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47102: LD_ADDR_VAR 0 9
47106: PUSH
47107: LD_VAR 0 47
47111: PUSH
47112: LD_VAR 0 48
47116: PUSH
47117: LD_VAR 0 49
47121: PUSH
47122: LD_VAR 0 50
47126: PUSH
47127: LD_VAR 0 51
47131: PUSH
47132: LD_VAR 0 52
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: PUSH
47145: LD_VAR 0 4
47149: PUSH
47150: LD_INT 1
47152: PLUS
47153: ARRAY
47154: ST_TO_ADDR
47155: GO 47346
47157: LD_INT 4
47159: DOUBLE
47160: EQUAL
47161: IFTRUE 47183
47163: LD_INT 5
47165: DOUBLE
47166: EQUAL
47167: IFTRUE 47183
47169: LD_INT 34
47171: DOUBLE
47172: EQUAL
47173: IFTRUE 47183
47175: LD_INT 37
47177: DOUBLE
47178: EQUAL
47179: IFTRUE 47183
47181: GO 47239
47183: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47184: LD_ADDR_VAR 0 9
47188: PUSH
47189: LD_VAR 0 53
47193: PUSH
47194: LD_VAR 0 54
47198: PUSH
47199: LD_VAR 0 55
47203: PUSH
47204: LD_VAR 0 56
47208: PUSH
47209: LD_VAR 0 57
47213: PUSH
47214: LD_VAR 0 58
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: PUSH
47227: LD_VAR 0 4
47231: PUSH
47232: LD_INT 1
47234: PLUS
47235: ARRAY
47236: ST_TO_ADDR
47237: GO 47346
47239: LD_INT 31
47241: DOUBLE
47242: EQUAL
47243: IFTRUE 47289
47245: LD_INT 32
47247: DOUBLE
47248: EQUAL
47249: IFTRUE 47289
47251: LD_INT 33
47253: DOUBLE
47254: EQUAL
47255: IFTRUE 47289
47257: LD_INT 27
47259: DOUBLE
47260: EQUAL
47261: IFTRUE 47289
47263: LD_INT 26
47265: DOUBLE
47266: EQUAL
47267: IFTRUE 47289
47269: LD_INT 28
47271: DOUBLE
47272: EQUAL
47273: IFTRUE 47289
47275: LD_INT 29
47277: DOUBLE
47278: EQUAL
47279: IFTRUE 47289
47281: LD_INT 30
47283: DOUBLE
47284: EQUAL
47285: IFTRUE 47289
47287: GO 47345
47289: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47290: LD_ADDR_VAR 0 9
47294: PUSH
47295: LD_VAR 0 59
47299: PUSH
47300: LD_VAR 0 60
47304: PUSH
47305: LD_VAR 0 61
47309: PUSH
47310: LD_VAR 0 62
47314: PUSH
47315: LD_VAR 0 63
47319: PUSH
47320: LD_VAR 0 64
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: PUSH
47333: LD_VAR 0 4
47337: PUSH
47338: LD_INT 1
47340: PLUS
47341: ARRAY
47342: ST_TO_ADDR
47343: GO 47346
47345: POP
// temp_list2 = [ ] ;
47346: LD_ADDR_VAR 0 10
47350: PUSH
47351: EMPTY
47352: ST_TO_ADDR
// for i in temp_list do
47353: LD_ADDR_VAR 0 8
47357: PUSH
47358: LD_VAR 0 9
47362: PUSH
47363: FOR_IN
47364: IFFALSE 47416
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47366: LD_ADDR_VAR 0 10
47370: PUSH
47371: LD_VAR 0 10
47375: PUSH
47376: LD_VAR 0 8
47380: PUSH
47381: LD_INT 1
47383: ARRAY
47384: PUSH
47385: LD_VAR 0 2
47389: PLUS
47390: PUSH
47391: LD_VAR 0 8
47395: PUSH
47396: LD_INT 2
47398: ARRAY
47399: PUSH
47400: LD_VAR 0 3
47404: PLUS
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: EMPTY
47411: LIST
47412: ADD
47413: ST_TO_ADDR
47414: GO 47363
47416: POP
47417: POP
// result = temp_list2 ;
47418: LD_ADDR_VAR 0 7
47422: PUSH
47423: LD_VAR 0 10
47427: ST_TO_ADDR
// end ;
47428: LD_VAR 0 7
47432: RET
// export function EnemyInRange ( unit , dist ) ; begin
47433: LD_INT 0
47435: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47436: LD_ADDR_VAR 0 3
47440: PUSH
47441: LD_VAR 0 1
47445: PPUSH
47446: CALL_OW 255
47450: PPUSH
47451: LD_VAR 0 1
47455: PPUSH
47456: CALL_OW 250
47460: PPUSH
47461: LD_VAR 0 1
47465: PPUSH
47466: CALL_OW 251
47470: PPUSH
47471: LD_VAR 0 2
47475: PPUSH
47476: CALL 21561 0 4
47480: PUSH
47481: LD_INT 4
47483: ARRAY
47484: ST_TO_ADDR
// end ;
47485: LD_VAR 0 3
47489: RET
// export function PlayerSeeMe ( unit ) ; begin
47490: LD_INT 0
47492: PPUSH
// result := See ( your_side , unit ) ;
47493: LD_ADDR_VAR 0 2
47497: PUSH
47498: LD_OWVAR 2
47502: PPUSH
47503: LD_VAR 0 1
47507: PPUSH
47508: CALL_OW 292
47512: ST_TO_ADDR
// end ;
47513: LD_VAR 0 2
47517: RET
// export function ReverseDir ( unit ) ; begin
47518: LD_INT 0
47520: PPUSH
// if not unit then
47521: LD_VAR 0 1
47525: NOT
47526: IFFALSE 47530
// exit ;
47528: GO 47576
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47530: LD_ADDR_VAR 0 2
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 4
47540: PUSH
47541: LD_INT 5
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: LD_INT 1
47549: PUSH
47550: LD_INT 2
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 1
47565: PPUSH
47566: CALL_OW 254
47570: PUSH
47571: LD_INT 1
47573: PLUS
47574: ARRAY
47575: ST_TO_ADDR
// end ;
47576: LD_VAR 0 2
47580: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47581: LD_INT 0
47583: PPUSH
47584: PPUSH
47585: PPUSH
47586: PPUSH
47587: PPUSH
// if not hexes then
47588: LD_VAR 0 2
47592: NOT
47593: IFFALSE 47597
// exit ;
47595: GO 47745
// dist := 9999 ;
47597: LD_ADDR_VAR 0 5
47601: PUSH
47602: LD_INT 9999
47604: ST_TO_ADDR
// for i = 1 to hexes do
47605: LD_ADDR_VAR 0 4
47609: PUSH
47610: DOUBLE
47611: LD_INT 1
47613: DEC
47614: ST_TO_ADDR
47615: LD_VAR 0 2
47619: PUSH
47620: FOR_TO
47621: IFFALSE 47733
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47623: LD_VAR 0 1
47627: PPUSH
47628: LD_VAR 0 2
47632: PUSH
47633: LD_VAR 0 4
47637: ARRAY
47638: PUSH
47639: LD_INT 1
47641: ARRAY
47642: PPUSH
47643: LD_VAR 0 2
47647: PUSH
47648: LD_VAR 0 4
47652: ARRAY
47653: PUSH
47654: LD_INT 2
47656: ARRAY
47657: PPUSH
47658: CALL_OW 297
47662: PUSH
47663: LD_VAR 0 5
47667: LESS
47668: IFFALSE 47731
// begin hex := hexes [ i ] ;
47670: LD_ADDR_VAR 0 7
47674: PUSH
47675: LD_VAR 0 2
47679: PUSH
47680: LD_VAR 0 4
47684: ARRAY
47685: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47686: LD_ADDR_VAR 0 5
47690: PUSH
47691: LD_VAR 0 1
47695: PPUSH
47696: LD_VAR 0 2
47700: PUSH
47701: LD_VAR 0 4
47705: ARRAY
47706: PUSH
47707: LD_INT 1
47709: ARRAY
47710: PPUSH
47711: LD_VAR 0 2
47715: PUSH
47716: LD_VAR 0 4
47720: ARRAY
47721: PUSH
47722: LD_INT 2
47724: ARRAY
47725: PPUSH
47726: CALL_OW 297
47730: ST_TO_ADDR
// end ; end ;
47731: GO 47620
47733: POP
47734: POP
// result := hex ;
47735: LD_ADDR_VAR 0 3
47739: PUSH
47740: LD_VAR 0 7
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 3
47749: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47750: LD_INT 0
47752: PPUSH
47753: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47754: LD_VAR 0 1
47758: NOT
47759: PUSH
47760: LD_VAR 0 1
47764: PUSH
47765: LD_INT 21
47767: PUSH
47768: LD_INT 2
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: PUSH
47775: LD_INT 23
47777: PUSH
47778: LD_INT 2
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PPUSH
47789: CALL_OW 69
47793: IN
47794: NOT
47795: OR
47796: IFFALSE 47800
// exit ;
47798: GO 47847
// for i = 1 to 3 do
47800: LD_ADDR_VAR 0 3
47804: PUSH
47805: DOUBLE
47806: LD_INT 1
47808: DEC
47809: ST_TO_ADDR
47810: LD_INT 3
47812: PUSH
47813: FOR_TO
47814: IFFALSE 47845
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47816: LD_VAR 0 1
47820: PPUSH
47821: CALL_OW 250
47825: PPUSH
47826: LD_VAR 0 1
47830: PPUSH
47831: CALL_OW 251
47835: PPUSH
47836: LD_INT 1
47838: PPUSH
47839: CALL_OW 453
47843: GO 47813
47845: POP
47846: POP
// end ;
47847: LD_VAR 0 2
47851: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47852: LD_INT 0
47854: PPUSH
47855: PPUSH
47856: PPUSH
47857: PPUSH
47858: PPUSH
47859: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47860: LD_VAR 0 1
47864: NOT
47865: PUSH
47866: LD_VAR 0 2
47870: NOT
47871: OR
47872: PUSH
47873: LD_VAR 0 1
47877: PPUSH
47878: CALL_OW 314
47882: OR
47883: IFFALSE 47887
// exit ;
47885: GO 48328
// x := GetX ( enemy_unit ) ;
47887: LD_ADDR_VAR 0 7
47891: PUSH
47892: LD_VAR 0 2
47896: PPUSH
47897: CALL_OW 250
47901: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47902: LD_ADDR_VAR 0 8
47906: PUSH
47907: LD_VAR 0 2
47911: PPUSH
47912: CALL_OW 251
47916: ST_TO_ADDR
// if not x or not y then
47917: LD_VAR 0 7
47921: NOT
47922: PUSH
47923: LD_VAR 0 8
47927: NOT
47928: OR
47929: IFFALSE 47933
// exit ;
47931: GO 48328
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47933: LD_ADDR_VAR 0 6
47937: PUSH
47938: LD_VAR 0 7
47942: PPUSH
47943: LD_INT 0
47945: PPUSH
47946: LD_INT 4
47948: PPUSH
47949: CALL_OW 272
47953: PUSH
47954: LD_VAR 0 8
47958: PPUSH
47959: LD_INT 0
47961: PPUSH
47962: LD_INT 4
47964: PPUSH
47965: CALL_OW 273
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PUSH
47974: LD_VAR 0 7
47978: PPUSH
47979: LD_INT 1
47981: PPUSH
47982: LD_INT 4
47984: PPUSH
47985: CALL_OW 272
47989: PUSH
47990: LD_VAR 0 8
47994: PPUSH
47995: LD_INT 1
47997: PPUSH
47998: LD_INT 4
48000: PPUSH
48001: CALL_OW 273
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_VAR 0 7
48014: PPUSH
48015: LD_INT 2
48017: PPUSH
48018: LD_INT 4
48020: PPUSH
48021: CALL_OW 272
48025: PUSH
48026: LD_VAR 0 8
48030: PPUSH
48031: LD_INT 2
48033: PPUSH
48034: LD_INT 4
48036: PPUSH
48037: CALL_OW 273
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_VAR 0 7
48050: PPUSH
48051: LD_INT 3
48053: PPUSH
48054: LD_INT 4
48056: PPUSH
48057: CALL_OW 272
48061: PUSH
48062: LD_VAR 0 8
48066: PPUSH
48067: LD_INT 3
48069: PPUSH
48070: LD_INT 4
48072: PPUSH
48073: CALL_OW 273
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: LD_VAR 0 7
48086: PPUSH
48087: LD_INT 4
48089: PPUSH
48090: LD_INT 4
48092: PPUSH
48093: CALL_OW 272
48097: PUSH
48098: LD_VAR 0 8
48102: PPUSH
48103: LD_INT 4
48105: PPUSH
48106: LD_INT 4
48108: PPUSH
48109: CALL_OW 273
48113: PUSH
48114: EMPTY
48115: LIST
48116: LIST
48117: PUSH
48118: LD_VAR 0 7
48122: PPUSH
48123: LD_INT 5
48125: PPUSH
48126: LD_INT 4
48128: PPUSH
48129: CALL_OW 272
48133: PUSH
48134: LD_VAR 0 8
48138: PPUSH
48139: LD_INT 5
48141: PPUSH
48142: LD_INT 4
48144: PPUSH
48145: CALL_OW 273
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: ST_TO_ADDR
// for i = tmp downto 1 do
48162: LD_ADDR_VAR 0 4
48166: PUSH
48167: DOUBLE
48168: LD_VAR 0 6
48172: INC
48173: ST_TO_ADDR
48174: LD_INT 1
48176: PUSH
48177: FOR_DOWNTO
48178: IFFALSE 48279
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48180: LD_VAR 0 6
48184: PUSH
48185: LD_VAR 0 4
48189: ARRAY
48190: PUSH
48191: LD_INT 1
48193: ARRAY
48194: PPUSH
48195: LD_VAR 0 6
48199: PUSH
48200: LD_VAR 0 4
48204: ARRAY
48205: PUSH
48206: LD_INT 2
48208: ARRAY
48209: PPUSH
48210: CALL_OW 488
48214: NOT
48215: PUSH
48216: LD_VAR 0 6
48220: PUSH
48221: LD_VAR 0 4
48225: ARRAY
48226: PUSH
48227: LD_INT 1
48229: ARRAY
48230: PPUSH
48231: LD_VAR 0 6
48235: PUSH
48236: LD_VAR 0 4
48240: ARRAY
48241: PUSH
48242: LD_INT 2
48244: ARRAY
48245: PPUSH
48246: CALL_OW 428
48250: PUSH
48251: LD_INT 0
48253: NONEQUAL
48254: OR
48255: IFFALSE 48277
// tmp := Delete ( tmp , i ) ;
48257: LD_ADDR_VAR 0 6
48261: PUSH
48262: LD_VAR 0 6
48266: PPUSH
48267: LD_VAR 0 4
48271: PPUSH
48272: CALL_OW 3
48276: ST_TO_ADDR
48277: GO 48177
48279: POP
48280: POP
// j := GetClosestHex ( unit , tmp ) ;
48281: LD_ADDR_VAR 0 5
48285: PUSH
48286: LD_VAR 0 1
48290: PPUSH
48291: LD_VAR 0 6
48295: PPUSH
48296: CALL 47581 0 2
48300: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48301: LD_VAR 0 1
48305: PPUSH
48306: LD_VAR 0 5
48310: PUSH
48311: LD_INT 1
48313: ARRAY
48314: PPUSH
48315: LD_VAR 0 5
48319: PUSH
48320: LD_INT 2
48322: ARRAY
48323: PPUSH
48324: CALL_OW 111
// end ;
48328: LD_VAR 0 3
48332: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48333: LD_INT 0
48335: PPUSH
48336: PPUSH
48337: PPUSH
// uc_side = 0 ;
48338: LD_ADDR_OWVAR 20
48342: PUSH
48343: LD_INT 0
48345: ST_TO_ADDR
// uc_nation = 0 ;
48346: LD_ADDR_OWVAR 21
48350: PUSH
48351: LD_INT 0
48353: ST_TO_ADDR
// InitHc ;
48354: CALL_OW 19
// InitVc ;
48358: CALL_OW 20
// if mastodonts then
48362: LD_VAR 0 6
48366: IFFALSE 48433
// for i = 1 to mastodonts do
48368: LD_ADDR_VAR 0 11
48372: PUSH
48373: DOUBLE
48374: LD_INT 1
48376: DEC
48377: ST_TO_ADDR
48378: LD_VAR 0 6
48382: PUSH
48383: FOR_TO
48384: IFFALSE 48431
// begin vc_chassis := 31 ;
48386: LD_ADDR_OWVAR 37
48390: PUSH
48391: LD_INT 31
48393: ST_TO_ADDR
// vc_control := control_rider ;
48394: LD_ADDR_OWVAR 38
48398: PUSH
48399: LD_INT 4
48401: ST_TO_ADDR
// animal := CreateVehicle ;
48402: LD_ADDR_VAR 0 12
48406: PUSH
48407: CALL_OW 45
48411: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48412: LD_VAR 0 12
48416: PPUSH
48417: LD_VAR 0 8
48421: PPUSH
48422: LD_INT 0
48424: PPUSH
48425: CALL 55139 0 3
// end ;
48429: GO 48383
48431: POP
48432: POP
// if horses then
48433: LD_VAR 0 5
48437: IFFALSE 48504
// for i = 1 to horses do
48439: LD_ADDR_VAR 0 11
48443: PUSH
48444: DOUBLE
48445: LD_INT 1
48447: DEC
48448: ST_TO_ADDR
48449: LD_VAR 0 5
48453: PUSH
48454: FOR_TO
48455: IFFALSE 48502
// begin hc_class := 21 ;
48457: LD_ADDR_OWVAR 28
48461: PUSH
48462: LD_INT 21
48464: ST_TO_ADDR
// hc_gallery :=  ;
48465: LD_ADDR_OWVAR 33
48469: PUSH
48470: LD_STRING 
48472: ST_TO_ADDR
// animal := CreateHuman ;
48473: LD_ADDR_VAR 0 12
48477: PUSH
48478: CALL_OW 44
48482: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48483: LD_VAR 0 12
48487: PPUSH
48488: LD_VAR 0 8
48492: PPUSH
48493: LD_INT 0
48495: PPUSH
48496: CALL 55139 0 3
// end ;
48500: GO 48454
48502: POP
48503: POP
// if birds then
48504: LD_VAR 0 1
48508: IFFALSE 48575
// for i = 1 to birds do
48510: LD_ADDR_VAR 0 11
48514: PUSH
48515: DOUBLE
48516: LD_INT 1
48518: DEC
48519: ST_TO_ADDR
48520: LD_VAR 0 1
48524: PUSH
48525: FOR_TO
48526: IFFALSE 48573
// begin hc_class = 18 ;
48528: LD_ADDR_OWVAR 28
48532: PUSH
48533: LD_INT 18
48535: ST_TO_ADDR
// hc_gallery =  ;
48536: LD_ADDR_OWVAR 33
48540: PUSH
48541: LD_STRING 
48543: ST_TO_ADDR
// animal := CreateHuman ;
48544: LD_ADDR_VAR 0 12
48548: PUSH
48549: CALL_OW 44
48553: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48554: LD_VAR 0 12
48558: PPUSH
48559: LD_VAR 0 8
48563: PPUSH
48564: LD_INT 0
48566: PPUSH
48567: CALL 55139 0 3
// end ;
48571: GO 48525
48573: POP
48574: POP
// if tigers then
48575: LD_VAR 0 2
48579: IFFALSE 48663
// for i = 1 to tigers do
48581: LD_ADDR_VAR 0 11
48585: PUSH
48586: DOUBLE
48587: LD_INT 1
48589: DEC
48590: ST_TO_ADDR
48591: LD_VAR 0 2
48595: PUSH
48596: FOR_TO
48597: IFFALSE 48661
// begin hc_class = class_tiger ;
48599: LD_ADDR_OWVAR 28
48603: PUSH
48604: LD_INT 14
48606: ST_TO_ADDR
// hc_gallery =  ;
48607: LD_ADDR_OWVAR 33
48611: PUSH
48612: LD_STRING 
48614: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48615: LD_ADDR_OWVAR 35
48619: PUSH
48620: LD_INT 7
48622: NEG
48623: PPUSH
48624: LD_INT 7
48626: PPUSH
48627: CALL_OW 12
48631: ST_TO_ADDR
// animal := CreateHuman ;
48632: LD_ADDR_VAR 0 12
48636: PUSH
48637: CALL_OW 44
48641: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48642: LD_VAR 0 12
48646: PPUSH
48647: LD_VAR 0 8
48651: PPUSH
48652: LD_INT 0
48654: PPUSH
48655: CALL 55139 0 3
// end ;
48659: GO 48596
48661: POP
48662: POP
// if apemans then
48663: LD_VAR 0 3
48667: IFFALSE 48790
// for i = 1 to apemans do
48669: LD_ADDR_VAR 0 11
48673: PUSH
48674: DOUBLE
48675: LD_INT 1
48677: DEC
48678: ST_TO_ADDR
48679: LD_VAR 0 3
48683: PUSH
48684: FOR_TO
48685: IFFALSE 48788
// begin hc_class = class_apeman ;
48687: LD_ADDR_OWVAR 28
48691: PUSH
48692: LD_INT 12
48694: ST_TO_ADDR
// hc_gallery =  ;
48695: LD_ADDR_OWVAR 33
48699: PUSH
48700: LD_STRING 
48702: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48703: LD_ADDR_OWVAR 35
48707: PUSH
48708: LD_INT 5
48710: NEG
48711: PPUSH
48712: LD_INT 5
48714: PPUSH
48715: CALL_OW 12
48719: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48720: LD_ADDR_OWVAR 31
48724: PUSH
48725: LD_INT 1
48727: PPUSH
48728: LD_INT 3
48730: PPUSH
48731: CALL_OW 12
48735: PUSH
48736: LD_INT 1
48738: PPUSH
48739: LD_INT 3
48741: PPUSH
48742: CALL_OW 12
48746: PUSH
48747: LD_INT 0
48749: PUSH
48750: LD_INT 0
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: ST_TO_ADDR
// animal := CreateHuman ;
48759: LD_ADDR_VAR 0 12
48763: PUSH
48764: CALL_OW 44
48768: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48769: LD_VAR 0 12
48773: PPUSH
48774: LD_VAR 0 8
48778: PPUSH
48779: LD_INT 0
48781: PPUSH
48782: CALL 55139 0 3
// end ;
48786: GO 48684
48788: POP
48789: POP
// if enchidnas then
48790: LD_VAR 0 4
48794: IFFALSE 48861
// for i = 1 to enchidnas do
48796: LD_ADDR_VAR 0 11
48800: PUSH
48801: DOUBLE
48802: LD_INT 1
48804: DEC
48805: ST_TO_ADDR
48806: LD_VAR 0 4
48810: PUSH
48811: FOR_TO
48812: IFFALSE 48859
// begin hc_class = 13 ;
48814: LD_ADDR_OWVAR 28
48818: PUSH
48819: LD_INT 13
48821: ST_TO_ADDR
// hc_gallery =  ;
48822: LD_ADDR_OWVAR 33
48826: PUSH
48827: LD_STRING 
48829: ST_TO_ADDR
// animal := CreateHuman ;
48830: LD_ADDR_VAR 0 12
48834: PUSH
48835: CALL_OW 44
48839: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48840: LD_VAR 0 12
48844: PPUSH
48845: LD_VAR 0 8
48849: PPUSH
48850: LD_INT 0
48852: PPUSH
48853: CALL 55139 0 3
// end ;
48857: GO 48811
48859: POP
48860: POP
// if fishes then
48861: LD_VAR 0 7
48865: IFFALSE 48932
// for i = 1 to fishes do
48867: LD_ADDR_VAR 0 11
48871: PUSH
48872: DOUBLE
48873: LD_INT 1
48875: DEC
48876: ST_TO_ADDR
48877: LD_VAR 0 7
48881: PUSH
48882: FOR_TO
48883: IFFALSE 48930
// begin hc_class = 20 ;
48885: LD_ADDR_OWVAR 28
48889: PUSH
48890: LD_INT 20
48892: ST_TO_ADDR
// hc_gallery =  ;
48893: LD_ADDR_OWVAR 33
48897: PUSH
48898: LD_STRING 
48900: ST_TO_ADDR
// animal := CreateHuman ;
48901: LD_ADDR_VAR 0 12
48905: PUSH
48906: CALL_OW 44
48910: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48911: LD_VAR 0 12
48915: PPUSH
48916: LD_VAR 0 9
48920: PPUSH
48921: LD_INT 0
48923: PPUSH
48924: CALL 55139 0 3
// end ;
48928: GO 48882
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 10
48936: RET
// export function WantHeal ( sci , unit ) ; begin
48937: LD_INT 0
48939: PPUSH
// if GetTaskList ( sci ) > 0 then
48940: LD_VAR 0 1
48944: PPUSH
48945: CALL_OW 437
48949: PUSH
48950: LD_INT 0
48952: GREATER
48953: IFFALSE 49023
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48955: LD_VAR 0 1
48959: PPUSH
48960: CALL_OW 437
48964: PUSH
48965: LD_INT 1
48967: ARRAY
48968: PUSH
48969: LD_INT 1
48971: ARRAY
48972: PUSH
48973: LD_STRING l
48975: EQUAL
48976: PUSH
48977: LD_VAR 0 1
48981: PPUSH
48982: CALL_OW 437
48986: PUSH
48987: LD_INT 1
48989: ARRAY
48990: PUSH
48991: LD_INT 4
48993: ARRAY
48994: PUSH
48995: LD_VAR 0 2
48999: EQUAL
49000: AND
49001: IFFALSE 49013
// result := true else
49003: LD_ADDR_VAR 0 3
49007: PUSH
49008: LD_INT 1
49010: ST_TO_ADDR
49011: GO 49021
// result := false ;
49013: LD_ADDR_VAR 0 3
49017: PUSH
49018: LD_INT 0
49020: ST_TO_ADDR
// end else
49021: GO 49031
// result := false ;
49023: LD_ADDR_VAR 0 3
49027: PUSH
49028: LD_INT 0
49030: ST_TO_ADDR
// end ;
49031: LD_VAR 0 3
49035: RET
// export function HealTarget ( sci ) ; begin
49036: LD_INT 0
49038: PPUSH
// if not sci then
49039: LD_VAR 0 1
49043: NOT
49044: IFFALSE 49048
// exit ;
49046: GO 49113
// result := 0 ;
49048: LD_ADDR_VAR 0 2
49052: PUSH
49053: LD_INT 0
49055: ST_TO_ADDR
// if GetTaskList ( sci ) then
49056: LD_VAR 0 1
49060: PPUSH
49061: CALL_OW 437
49065: IFFALSE 49113
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49067: LD_VAR 0 1
49071: PPUSH
49072: CALL_OW 437
49076: PUSH
49077: LD_INT 1
49079: ARRAY
49080: PUSH
49081: LD_INT 1
49083: ARRAY
49084: PUSH
49085: LD_STRING l
49087: EQUAL
49088: IFFALSE 49113
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49090: LD_ADDR_VAR 0 2
49094: PUSH
49095: LD_VAR 0 1
49099: PPUSH
49100: CALL_OW 437
49104: PUSH
49105: LD_INT 1
49107: ARRAY
49108: PUSH
49109: LD_INT 4
49111: ARRAY
49112: ST_TO_ADDR
// end ;
49113: LD_VAR 0 2
49117: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
49118: LD_INT 0
49120: PPUSH
49121: PPUSH
49122: PPUSH
49123: PPUSH
49124: PPUSH
49125: PPUSH
49126: PPUSH
49127: PPUSH
49128: PPUSH
49129: PPUSH
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
49150: PPUSH
49151: PPUSH
49152: PPUSH
// if not list then
49153: LD_VAR 0 1
49157: NOT
49158: IFFALSE 49162
// exit ;
49160: GO 53750
// base := list [ 1 ] ;
49162: LD_ADDR_VAR 0 3
49166: PUSH
49167: LD_VAR 0 1
49171: PUSH
49172: LD_INT 1
49174: ARRAY
49175: ST_TO_ADDR
// group := list [ 2 ] ;
49176: LD_ADDR_VAR 0 4
49180: PUSH
49181: LD_VAR 0 1
49185: PUSH
49186: LD_INT 2
49188: ARRAY
49189: ST_TO_ADDR
// path := list [ 3 ] ;
49190: LD_ADDR_VAR 0 5
49194: PUSH
49195: LD_VAR 0 1
49199: PUSH
49200: LD_INT 3
49202: ARRAY
49203: ST_TO_ADDR
// flags := list [ 4 ] ;
49204: LD_ADDR_VAR 0 6
49208: PUSH
49209: LD_VAR 0 1
49213: PUSH
49214: LD_INT 4
49216: ARRAY
49217: ST_TO_ADDR
// mined := [ ] ;
49218: LD_ADDR_VAR 0 27
49222: PUSH
49223: EMPTY
49224: ST_TO_ADDR
// bombed := [ ] ;
49225: LD_ADDR_VAR 0 28
49229: PUSH
49230: EMPTY
49231: ST_TO_ADDR
// healers := [ ] ;
49232: LD_ADDR_VAR 0 31
49236: PUSH
49237: EMPTY
49238: ST_TO_ADDR
// to_heal := [ ] ;
49239: LD_ADDR_VAR 0 30
49243: PUSH
49244: EMPTY
49245: ST_TO_ADDR
// repairs := [ ] ;
49246: LD_ADDR_VAR 0 33
49250: PUSH
49251: EMPTY
49252: ST_TO_ADDR
// to_repair := [ ] ;
49253: LD_ADDR_VAR 0 32
49257: PUSH
49258: EMPTY
49259: ST_TO_ADDR
// if not group or not path then
49260: LD_VAR 0 4
49264: NOT
49265: PUSH
49266: LD_VAR 0 5
49270: NOT
49271: OR
49272: IFFALSE 49276
// exit ;
49274: GO 53750
// if flags then
49276: LD_VAR 0 6
49280: IFFALSE 49424
// begin f_ignore_area := flags [ 1 ] ;
49282: LD_ADDR_VAR 0 17
49286: PUSH
49287: LD_VAR 0 6
49291: PUSH
49292: LD_INT 1
49294: ARRAY
49295: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49296: LD_ADDR_VAR 0 18
49300: PUSH
49301: LD_VAR 0 6
49305: PUSH
49306: LD_INT 2
49308: ARRAY
49309: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49310: LD_ADDR_VAR 0 19
49314: PUSH
49315: LD_VAR 0 6
49319: PUSH
49320: LD_INT 3
49322: ARRAY
49323: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49324: LD_ADDR_VAR 0 20
49328: PUSH
49329: LD_VAR 0 6
49333: PUSH
49334: LD_INT 4
49336: ARRAY
49337: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49338: LD_ADDR_VAR 0 21
49342: PUSH
49343: LD_VAR 0 6
49347: PUSH
49348: LD_INT 5
49350: ARRAY
49351: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49352: LD_ADDR_VAR 0 22
49356: PUSH
49357: LD_VAR 0 6
49361: PUSH
49362: LD_INT 6
49364: ARRAY
49365: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49366: LD_ADDR_VAR 0 23
49370: PUSH
49371: LD_VAR 0 6
49375: PUSH
49376: LD_INT 7
49378: ARRAY
49379: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49380: LD_ADDR_VAR 0 24
49384: PUSH
49385: LD_VAR 0 6
49389: PUSH
49390: LD_INT 8
49392: ARRAY
49393: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49394: LD_ADDR_VAR 0 25
49398: PUSH
49399: LD_VAR 0 6
49403: PUSH
49404: LD_INT 9
49406: ARRAY
49407: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49408: LD_ADDR_VAR 0 26
49412: PUSH
49413: LD_VAR 0 6
49417: PUSH
49418: LD_INT 10
49420: ARRAY
49421: ST_TO_ADDR
// end else
49422: GO 49504
// begin f_ignore_area := false ;
49424: LD_ADDR_VAR 0 17
49428: PUSH
49429: LD_INT 0
49431: ST_TO_ADDR
// f_capture := false ;
49432: LD_ADDR_VAR 0 18
49436: PUSH
49437: LD_INT 0
49439: ST_TO_ADDR
// f_ignore_civ := false ;
49440: LD_ADDR_VAR 0 19
49444: PUSH
49445: LD_INT 0
49447: ST_TO_ADDR
// f_murder := false ;
49448: LD_ADDR_VAR 0 20
49452: PUSH
49453: LD_INT 0
49455: ST_TO_ADDR
// f_mines := false ;
49456: LD_ADDR_VAR 0 21
49460: PUSH
49461: LD_INT 0
49463: ST_TO_ADDR
// f_repair := false ;
49464: LD_ADDR_VAR 0 22
49468: PUSH
49469: LD_INT 0
49471: ST_TO_ADDR
// f_heal := false ;
49472: LD_ADDR_VAR 0 23
49476: PUSH
49477: LD_INT 0
49479: ST_TO_ADDR
// f_spacetime := false ;
49480: LD_ADDR_VAR 0 24
49484: PUSH
49485: LD_INT 0
49487: ST_TO_ADDR
// f_attack_depot := false ;
49488: LD_ADDR_VAR 0 25
49492: PUSH
49493: LD_INT 0
49495: ST_TO_ADDR
// f_crawl := false ;
49496: LD_ADDR_VAR 0 26
49500: PUSH
49501: LD_INT 0
49503: ST_TO_ADDR
// end ; if f_heal then
49504: LD_VAR 0 23
49508: IFFALSE 49535
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49510: LD_ADDR_VAR 0 31
49514: PUSH
49515: LD_VAR 0 4
49519: PPUSH
49520: LD_INT 25
49522: PUSH
49523: LD_INT 4
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PPUSH
49530: CALL_OW 72
49534: ST_TO_ADDR
// if f_repair then
49535: LD_VAR 0 22
49539: IFFALSE 49566
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49541: LD_ADDR_VAR 0 33
49545: PUSH
49546: LD_VAR 0 4
49550: PPUSH
49551: LD_INT 25
49553: PUSH
49554: LD_INT 3
49556: PUSH
49557: EMPTY
49558: LIST
49559: LIST
49560: PPUSH
49561: CALL_OW 72
49565: ST_TO_ADDR
// units_path := [ ] ;
49566: LD_ADDR_VAR 0 16
49570: PUSH
49571: EMPTY
49572: ST_TO_ADDR
// for i = 1 to group do
49573: LD_ADDR_VAR 0 7
49577: PUSH
49578: DOUBLE
49579: LD_INT 1
49581: DEC
49582: ST_TO_ADDR
49583: LD_VAR 0 4
49587: PUSH
49588: FOR_TO
49589: IFFALSE 49618
// units_path := Replace ( units_path , i , path ) ;
49591: LD_ADDR_VAR 0 16
49595: PUSH
49596: LD_VAR 0 16
49600: PPUSH
49601: LD_VAR 0 7
49605: PPUSH
49606: LD_VAR 0 5
49610: PPUSH
49611: CALL_OW 1
49615: ST_TO_ADDR
49616: GO 49588
49618: POP
49619: POP
// repeat for i = group downto 1 do
49620: LD_ADDR_VAR 0 7
49624: PUSH
49625: DOUBLE
49626: LD_VAR 0 4
49630: INC
49631: ST_TO_ADDR
49632: LD_INT 1
49634: PUSH
49635: FOR_DOWNTO
49636: IFFALSE 53732
// begin wait ( 5 ) ;
49638: LD_INT 5
49640: PPUSH
49641: CALL_OW 67
// tmp := [ ] ;
49645: LD_ADDR_VAR 0 14
49649: PUSH
49650: EMPTY
49651: ST_TO_ADDR
// attacking := false ;
49652: LD_ADDR_VAR 0 29
49656: PUSH
49657: LD_INT 0
49659: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49660: LD_VAR 0 4
49664: PUSH
49665: LD_VAR 0 7
49669: ARRAY
49670: PPUSH
49671: CALL_OW 301
49675: PUSH
49676: LD_VAR 0 4
49680: PUSH
49681: LD_VAR 0 7
49685: ARRAY
49686: NOT
49687: OR
49688: IFFALSE 49797
// begin if GetType ( group [ i ] ) = unit_human then
49690: LD_VAR 0 4
49694: PUSH
49695: LD_VAR 0 7
49699: ARRAY
49700: PPUSH
49701: CALL_OW 247
49705: PUSH
49706: LD_INT 1
49708: EQUAL
49709: IFFALSE 49755
// begin to_heal := to_heal diff group [ i ] ;
49711: LD_ADDR_VAR 0 30
49715: PUSH
49716: LD_VAR 0 30
49720: PUSH
49721: LD_VAR 0 4
49725: PUSH
49726: LD_VAR 0 7
49730: ARRAY
49731: DIFF
49732: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49733: LD_ADDR_VAR 0 31
49737: PUSH
49738: LD_VAR 0 31
49742: PUSH
49743: LD_VAR 0 4
49747: PUSH
49748: LD_VAR 0 7
49752: ARRAY
49753: DIFF
49754: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49755: LD_ADDR_VAR 0 4
49759: PUSH
49760: LD_VAR 0 4
49764: PPUSH
49765: LD_VAR 0 7
49769: PPUSH
49770: CALL_OW 3
49774: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49775: LD_ADDR_VAR 0 16
49779: PUSH
49780: LD_VAR 0 16
49784: PPUSH
49785: LD_VAR 0 7
49789: PPUSH
49790: CALL_OW 3
49794: ST_TO_ADDR
// continue ;
49795: GO 49635
// end ; if f_repair then
49797: LD_VAR 0 22
49801: IFFALSE 50290
// begin if GetType ( group [ i ] ) = unit_vehicle then
49803: LD_VAR 0 4
49807: PUSH
49808: LD_VAR 0 7
49812: ARRAY
49813: PPUSH
49814: CALL_OW 247
49818: PUSH
49819: LD_INT 2
49821: EQUAL
49822: IFFALSE 50012
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49824: LD_VAR 0 4
49828: PUSH
49829: LD_VAR 0 7
49833: ARRAY
49834: PPUSH
49835: CALL_OW 256
49839: PUSH
49840: LD_INT 700
49842: LESS
49843: PUSH
49844: LD_VAR 0 4
49848: PUSH
49849: LD_VAR 0 7
49853: ARRAY
49854: PUSH
49855: LD_VAR 0 32
49859: IN
49860: NOT
49861: AND
49862: IFFALSE 49886
// to_repair := to_repair union group [ i ] ;
49864: LD_ADDR_VAR 0 32
49868: PUSH
49869: LD_VAR 0 32
49873: PUSH
49874: LD_VAR 0 4
49878: PUSH
49879: LD_VAR 0 7
49883: ARRAY
49884: UNION
49885: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49886: LD_VAR 0 4
49890: PUSH
49891: LD_VAR 0 7
49895: ARRAY
49896: PPUSH
49897: CALL_OW 256
49901: PUSH
49902: LD_INT 1000
49904: EQUAL
49905: PUSH
49906: LD_VAR 0 4
49910: PUSH
49911: LD_VAR 0 7
49915: ARRAY
49916: PUSH
49917: LD_VAR 0 32
49921: IN
49922: AND
49923: IFFALSE 49947
// to_repair := to_repair diff group [ i ] ;
49925: LD_ADDR_VAR 0 32
49929: PUSH
49930: LD_VAR 0 32
49934: PUSH
49935: LD_VAR 0 4
49939: PUSH
49940: LD_VAR 0 7
49944: ARRAY
49945: DIFF
49946: ST_TO_ADDR
// if group [ i ] in to_repair then
49947: LD_VAR 0 4
49951: PUSH
49952: LD_VAR 0 7
49956: ARRAY
49957: PUSH
49958: LD_VAR 0 32
49962: IN
49963: IFFALSE 50010
// begin if not IsInArea ( group [ i ] , f_repair ) then
49965: LD_VAR 0 4
49969: PUSH
49970: LD_VAR 0 7
49974: ARRAY
49975: PPUSH
49976: LD_VAR 0 22
49980: PPUSH
49981: CALL_OW 308
49985: NOT
49986: IFFALSE 50008
// ComMoveToArea ( group [ i ] , f_repair ) ;
49988: LD_VAR 0 4
49992: PUSH
49993: LD_VAR 0 7
49997: ARRAY
49998: PPUSH
49999: LD_VAR 0 22
50003: PPUSH
50004: CALL_OW 113
// continue ;
50008: GO 49635
// end ; end else
50010: GO 50290
// if group [ i ] in repairs then
50012: LD_VAR 0 4
50016: PUSH
50017: LD_VAR 0 7
50021: ARRAY
50022: PUSH
50023: LD_VAR 0 33
50027: IN
50028: IFFALSE 50290
// begin if IsInUnit ( group [ i ] ) then
50030: LD_VAR 0 4
50034: PUSH
50035: LD_VAR 0 7
50039: ARRAY
50040: PPUSH
50041: CALL_OW 310
50045: IFFALSE 50113
// begin z := IsInUnit ( group [ i ] ) ;
50047: LD_ADDR_VAR 0 13
50051: PUSH
50052: LD_VAR 0 4
50056: PUSH
50057: LD_VAR 0 7
50061: ARRAY
50062: PPUSH
50063: CALL_OW 310
50067: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50068: LD_VAR 0 13
50072: PUSH
50073: LD_VAR 0 32
50077: IN
50078: PUSH
50079: LD_VAR 0 13
50083: PPUSH
50084: LD_VAR 0 22
50088: PPUSH
50089: CALL_OW 308
50093: AND
50094: IFFALSE 50111
// ComExitVehicle ( group [ i ] ) ;
50096: LD_VAR 0 4
50100: PUSH
50101: LD_VAR 0 7
50105: ARRAY
50106: PPUSH
50107: CALL_OW 121
// end else
50111: GO 50290
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50113: LD_ADDR_VAR 0 13
50117: PUSH
50118: LD_VAR 0 4
50122: PPUSH
50123: LD_INT 95
50125: PUSH
50126: LD_VAR 0 22
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 58
50137: PUSH
50138: EMPTY
50139: LIST
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PPUSH
50145: CALL_OW 72
50149: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50150: LD_VAR 0 4
50154: PUSH
50155: LD_VAR 0 7
50159: ARRAY
50160: PPUSH
50161: CALL_OW 314
50165: NOT
50166: IFFALSE 50288
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50168: LD_ADDR_VAR 0 10
50172: PUSH
50173: LD_VAR 0 13
50177: PPUSH
50178: LD_VAR 0 4
50182: PUSH
50183: LD_VAR 0 7
50187: ARRAY
50188: PPUSH
50189: CALL_OW 74
50193: ST_TO_ADDR
// if not x then
50194: LD_VAR 0 10
50198: NOT
50199: IFFALSE 50203
// continue ;
50201: GO 49635
// if GetLives ( x ) < 1000 then
50203: LD_VAR 0 10
50207: PPUSH
50208: CALL_OW 256
50212: PUSH
50213: LD_INT 1000
50215: LESS
50216: IFFALSE 50240
// ComRepairVehicle ( group [ i ] , x ) else
50218: LD_VAR 0 4
50222: PUSH
50223: LD_VAR 0 7
50227: ARRAY
50228: PPUSH
50229: LD_VAR 0 10
50233: PPUSH
50234: CALL_OW 129
50238: GO 50288
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50240: LD_VAR 0 23
50244: PUSH
50245: LD_VAR 0 4
50249: PUSH
50250: LD_VAR 0 7
50254: ARRAY
50255: PPUSH
50256: CALL_OW 256
50260: PUSH
50261: LD_INT 1000
50263: LESS
50264: AND
50265: NOT
50266: IFFALSE 50288
// ComEnterUnit ( group [ i ] , x ) ;
50268: LD_VAR 0 4
50272: PUSH
50273: LD_VAR 0 7
50277: ARRAY
50278: PPUSH
50279: LD_VAR 0 10
50283: PPUSH
50284: CALL_OW 120
// end ; continue ;
50288: GO 49635
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50290: LD_VAR 0 23
50294: PUSH
50295: LD_VAR 0 4
50299: PUSH
50300: LD_VAR 0 7
50304: ARRAY
50305: PPUSH
50306: CALL_OW 247
50310: PUSH
50311: LD_INT 1
50313: EQUAL
50314: AND
50315: IFFALSE 50793
// begin if group [ i ] in healers then
50317: LD_VAR 0 4
50321: PUSH
50322: LD_VAR 0 7
50326: ARRAY
50327: PUSH
50328: LD_VAR 0 31
50332: IN
50333: IFFALSE 50606
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50335: LD_VAR 0 4
50339: PUSH
50340: LD_VAR 0 7
50344: ARRAY
50345: PPUSH
50346: LD_VAR 0 23
50350: PPUSH
50351: CALL_OW 308
50355: NOT
50356: PUSH
50357: LD_VAR 0 4
50361: PUSH
50362: LD_VAR 0 7
50366: ARRAY
50367: PPUSH
50368: CALL_OW 314
50372: NOT
50373: AND
50374: IFFALSE 50398
// ComMoveToArea ( group [ i ] , f_heal ) else
50376: LD_VAR 0 4
50380: PUSH
50381: LD_VAR 0 7
50385: ARRAY
50386: PPUSH
50387: LD_VAR 0 23
50391: PPUSH
50392: CALL_OW 113
50396: GO 50604
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50398: LD_VAR 0 4
50402: PUSH
50403: LD_VAR 0 7
50407: ARRAY
50408: PPUSH
50409: CALL 49036 0 1
50413: PPUSH
50414: CALL_OW 256
50418: PUSH
50419: LD_INT 1000
50421: EQUAL
50422: IFFALSE 50441
// ComStop ( group [ i ] ) else
50424: LD_VAR 0 4
50428: PUSH
50429: LD_VAR 0 7
50433: ARRAY
50434: PPUSH
50435: CALL_OW 141
50439: GO 50604
// if not HasTask ( group [ i ] ) and to_heal then
50441: LD_VAR 0 4
50445: PUSH
50446: LD_VAR 0 7
50450: ARRAY
50451: PPUSH
50452: CALL_OW 314
50456: NOT
50457: PUSH
50458: LD_VAR 0 30
50462: AND
50463: IFFALSE 50604
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50465: LD_ADDR_VAR 0 13
50469: PUSH
50470: LD_VAR 0 30
50474: PPUSH
50475: LD_INT 3
50477: PUSH
50478: LD_INT 54
50480: PUSH
50481: EMPTY
50482: LIST
50483: PUSH
50484: EMPTY
50485: LIST
50486: LIST
50487: PPUSH
50488: CALL_OW 72
50492: PPUSH
50493: LD_VAR 0 4
50497: PUSH
50498: LD_VAR 0 7
50502: ARRAY
50503: PPUSH
50504: CALL_OW 74
50508: ST_TO_ADDR
// if z then
50509: LD_VAR 0 13
50513: IFFALSE 50604
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50515: LD_INT 91
50517: PUSH
50518: LD_VAR 0 13
50522: PUSH
50523: LD_INT 10
50525: PUSH
50526: EMPTY
50527: LIST
50528: LIST
50529: LIST
50530: PUSH
50531: LD_INT 81
50533: PUSH
50534: LD_VAR 0 13
50538: PPUSH
50539: CALL_OW 255
50543: PUSH
50544: EMPTY
50545: LIST
50546: LIST
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PPUSH
50552: CALL_OW 69
50556: PUSH
50557: LD_INT 0
50559: EQUAL
50560: IFFALSE 50584
// ComHeal ( group [ i ] , z ) else
50562: LD_VAR 0 4
50566: PUSH
50567: LD_VAR 0 7
50571: ARRAY
50572: PPUSH
50573: LD_VAR 0 13
50577: PPUSH
50578: CALL_OW 128
50582: GO 50604
// ComMoveToArea ( group [ i ] , f_heal ) ;
50584: LD_VAR 0 4
50588: PUSH
50589: LD_VAR 0 7
50593: ARRAY
50594: PPUSH
50595: LD_VAR 0 23
50599: PPUSH
50600: CALL_OW 113
// end ; continue ;
50604: GO 49635
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50606: LD_VAR 0 4
50610: PUSH
50611: LD_VAR 0 7
50615: ARRAY
50616: PPUSH
50617: CALL_OW 256
50621: PUSH
50622: LD_INT 700
50624: LESS
50625: PUSH
50626: LD_VAR 0 4
50630: PUSH
50631: LD_VAR 0 7
50635: ARRAY
50636: PUSH
50637: LD_VAR 0 30
50641: IN
50642: NOT
50643: AND
50644: IFFALSE 50668
// to_heal := to_heal union group [ i ] ;
50646: LD_ADDR_VAR 0 30
50650: PUSH
50651: LD_VAR 0 30
50655: PUSH
50656: LD_VAR 0 4
50660: PUSH
50661: LD_VAR 0 7
50665: ARRAY
50666: UNION
50667: ST_TO_ADDR
// if group [ i ] in to_heal then
50668: LD_VAR 0 4
50672: PUSH
50673: LD_VAR 0 7
50677: ARRAY
50678: PUSH
50679: LD_VAR 0 30
50683: IN
50684: IFFALSE 50793
// begin if GetLives ( group [ i ] ) = 1000 then
50686: LD_VAR 0 4
50690: PUSH
50691: LD_VAR 0 7
50695: ARRAY
50696: PPUSH
50697: CALL_OW 256
50701: PUSH
50702: LD_INT 1000
50704: EQUAL
50705: IFFALSE 50731
// to_heal := to_heal diff group [ i ] else
50707: LD_ADDR_VAR 0 30
50711: PUSH
50712: LD_VAR 0 30
50716: PUSH
50717: LD_VAR 0 4
50721: PUSH
50722: LD_VAR 0 7
50726: ARRAY
50727: DIFF
50728: ST_TO_ADDR
50729: GO 50793
// begin if not IsInArea ( group [ i ] , to_heal ) then
50731: LD_VAR 0 4
50735: PUSH
50736: LD_VAR 0 7
50740: ARRAY
50741: PPUSH
50742: LD_VAR 0 30
50746: PPUSH
50747: CALL_OW 308
50751: NOT
50752: IFFALSE 50776
// ComMoveToArea ( group [ i ] , f_heal ) else
50754: LD_VAR 0 4
50758: PUSH
50759: LD_VAR 0 7
50763: ARRAY
50764: PPUSH
50765: LD_VAR 0 23
50769: PPUSH
50770: CALL_OW 113
50774: GO 50791
// ComHold ( group [ i ] ) ;
50776: LD_VAR 0 4
50780: PUSH
50781: LD_VAR 0 7
50785: ARRAY
50786: PPUSH
50787: CALL_OW 140
// continue ;
50791: GO 49635
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50793: LD_VAR 0 4
50797: PUSH
50798: LD_VAR 0 7
50802: ARRAY
50803: PPUSH
50804: LD_INT 10
50806: PPUSH
50807: CALL 47433 0 2
50811: NOT
50812: PUSH
50813: LD_VAR 0 16
50817: PUSH
50818: LD_VAR 0 7
50822: ARRAY
50823: PUSH
50824: EMPTY
50825: EQUAL
50826: NOT
50827: AND
50828: IFFALSE 51094
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50830: LD_VAR 0 4
50834: PUSH
50835: LD_VAR 0 7
50839: ARRAY
50840: PPUSH
50841: CALL_OW 262
50845: PUSH
50846: LD_INT 1
50848: PUSH
50849: LD_INT 2
50851: PUSH
50852: EMPTY
50853: LIST
50854: LIST
50855: IN
50856: IFFALSE 50897
// if GetFuel ( group [ i ] ) < 10 then
50858: LD_VAR 0 4
50862: PUSH
50863: LD_VAR 0 7
50867: ARRAY
50868: PPUSH
50869: CALL_OW 261
50873: PUSH
50874: LD_INT 10
50876: LESS
50877: IFFALSE 50897
// SetFuel ( group [ i ] , 12 ) ;
50879: LD_VAR 0 4
50883: PUSH
50884: LD_VAR 0 7
50888: ARRAY
50889: PPUSH
50890: LD_INT 12
50892: PPUSH
50893: CALL_OW 240
// if units_path [ i ] then
50897: LD_VAR 0 16
50901: PUSH
50902: LD_VAR 0 7
50906: ARRAY
50907: IFFALSE 51092
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50909: LD_VAR 0 4
50913: PUSH
50914: LD_VAR 0 7
50918: ARRAY
50919: PPUSH
50920: LD_VAR 0 16
50924: PUSH
50925: LD_VAR 0 7
50929: ARRAY
50930: PUSH
50931: LD_INT 1
50933: ARRAY
50934: PUSH
50935: LD_INT 1
50937: ARRAY
50938: PPUSH
50939: LD_VAR 0 16
50943: PUSH
50944: LD_VAR 0 7
50948: ARRAY
50949: PUSH
50950: LD_INT 1
50952: ARRAY
50953: PUSH
50954: LD_INT 2
50956: ARRAY
50957: PPUSH
50958: CALL_OW 297
50962: PUSH
50963: LD_INT 6
50965: GREATER
50966: IFFALSE 51041
// begin if not HasTask ( group [ i ] ) then
50968: LD_VAR 0 4
50972: PUSH
50973: LD_VAR 0 7
50977: ARRAY
50978: PPUSH
50979: CALL_OW 314
50983: NOT
50984: IFFALSE 51039
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50986: LD_VAR 0 4
50990: PUSH
50991: LD_VAR 0 7
50995: ARRAY
50996: PPUSH
50997: LD_VAR 0 16
51001: PUSH
51002: LD_VAR 0 7
51006: ARRAY
51007: PUSH
51008: LD_INT 1
51010: ARRAY
51011: PUSH
51012: LD_INT 1
51014: ARRAY
51015: PPUSH
51016: LD_VAR 0 16
51020: PUSH
51021: LD_VAR 0 7
51025: ARRAY
51026: PUSH
51027: LD_INT 1
51029: ARRAY
51030: PUSH
51031: LD_INT 2
51033: ARRAY
51034: PPUSH
51035: CALL_OW 114
// end else
51039: GO 51092
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51041: LD_ADDR_VAR 0 15
51045: PUSH
51046: LD_VAR 0 16
51050: PUSH
51051: LD_VAR 0 7
51055: ARRAY
51056: PPUSH
51057: LD_INT 1
51059: PPUSH
51060: CALL_OW 3
51064: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51065: LD_ADDR_VAR 0 16
51069: PUSH
51070: LD_VAR 0 16
51074: PPUSH
51075: LD_VAR 0 7
51079: PPUSH
51080: LD_VAR 0 15
51084: PPUSH
51085: CALL_OW 1
51089: ST_TO_ADDR
// continue ;
51090: GO 49635
// end ; end ; end else
51092: GO 53730
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51094: LD_ADDR_VAR 0 14
51098: PUSH
51099: LD_INT 81
51101: PUSH
51102: LD_VAR 0 4
51106: PUSH
51107: LD_VAR 0 7
51111: ARRAY
51112: PPUSH
51113: CALL_OW 255
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PPUSH
51122: CALL_OW 69
51126: ST_TO_ADDR
// if not tmp then
51127: LD_VAR 0 14
51131: NOT
51132: IFFALSE 51136
// continue ;
51134: GO 49635
// if f_ignore_area then
51136: LD_VAR 0 17
51140: IFFALSE 51228
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51142: LD_ADDR_VAR 0 15
51146: PUSH
51147: LD_VAR 0 14
51151: PPUSH
51152: LD_INT 3
51154: PUSH
51155: LD_INT 92
51157: PUSH
51158: LD_VAR 0 17
51162: PUSH
51163: LD_INT 1
51165: ARRAY
51166: PUSH
51167: LD_VAR 0 17
51171: PUSH
51172: LD_INT 2
51174: ARRAY
51175: PUSH
51176: LD_VAR 0 17
51180: PUSH
51181: LD_INT 3
51183: ARRAY
51184: PUSH
51185: EMPTY
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PPUSH
51195: CALL_OW 72
51199: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51200: LD_VAR 0 14
51204: PUSH
51205: LD_VAR 0 15
51209: DIFF
51210: IFFALSE 51228
// tmp := tmp diff tmp2 ;
51212: LD_ADDR_VAR 0 14
51216: PUSH
51217: LD_VAR 0 14
51221: PUSH
51222: LD_VAR 0 15
51226: DIFF
51227: ST_TO_ADDR
// end ; if not f_murder then
51228: LD_VAR 0 20
51232: NOT
51233: IFFALSE 51291
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51235: LD_ADDR_VAR 0 15
51239: PUSH
51240: LD_VAR 0 14
51244: PPUSH
51245: LD_INT 3
51247: PUSH
51248: LD_INT 50
51250: PUSH
51251: EMPTY
51252: LIST
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PPUSH
51258: CALL_OW 72
51262: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51263: LD_VAR 0 14
51267: PUSH
51268: LD_VAR 0 15
51272: DIFF
51273: IFFALSE 51291
// tmp := tmp diff tmp2 ;
51275: LD_ADDR_VAR 0 14
51279: PUSH
51280: LD_VAR 0 14
51284: PUSH
51285: LD_VAR 0 15
51289: DIFF
51290: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51291: LD_ADDR_VAR 0 14
51295: PUSH
51296: LD_VAR 0 4
51300: PUSH
51301: LD_VAR 0 7
51305: ARRAY
51306: PPUSH
51307: LD_VAR 0 14
51311: PPUSH
51312: LD_INT 1
51314: PPUSH
51315: LD_INT 1
51317: PPUSH
51318: CALL 21100 0 4
51322: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51323: LD_VAR 0 4
51327: PUSH
51328: LD_VAR 0 7
51332: ARRAY
51333: PPUSH
51334: CALL_OW 257
51338: PUSH
51339: LD_INT 1
51341: EQUAL
51342: IFFALSE 51790
// begin if WantPlant ( group [ i ] ) then
51344: LD_VAR 0 4
51348: PUSH
51349: LD_VAR 0 7
51353: ARRAY
51354: PPUSH
51355: CALL 20601 0 1
51359: IFFALSE 51363
// continue ;
51361: GO 49635
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51363: LD_VAR 0 18
51367: PUSH
51368: LD_VAR 0 4
51372: PUSH
51373: LD_VAR 0 7
51377: ARRAY
51378: PPUSH
51379: CALL_OW 310
51383: NOT
51384: AND
51385: PUSH
51386: LD_VAR 0 14
51390: PUSH
51391: LD_INT 1
51393: ARRAY
51394: PUSH
51395: LD_VAR 0 14
51399: PPUSH
51400: LD_INT 21
51402: PUSH
51403: LD_INT 2
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 58
51412: PUSH
51413: EMPTY
51414: LIST
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PPUSH
51420: CALL_OW 72
51424: IN
51425: AND
51426: IFFALSE 51462
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51428: LD_VAR 0 4
51432: PUSH
51433: LD_VAR 0 7
51437: ARRAY
51438: PPUSH
51439: LD_VAR 0 14
51443: PUSH
51444: LD_INT 1
51446: ARRAY
51447: PPUSH
51448: CALL_OW 120
// attacking := true ;
51452: LD_ADDR_VAR 0 29
51456: PUSH
51457: LD_INT 1
51459: ST_TO_ADDR
// continue ;
51460: GO 49635
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51462: LD_VAR 0 26
51466: PUSH
51467: LD_VAR 0 4
51471: PUSH
51472: LD_VAR 0 7
51476: ARRAY
51477: PPUSH
51478: CALL_OW 257
51482: PUSH
51483: LD_INT 1
51485: EQUAL
51486: AND
51487: PUSH
51488: LD_VAR 0 4
51492: PUSH
51493: LD_VAR 0 7
51497: ARRAY
51498: PPUSH
51499: CALL_OW 256
51503: PUSH
51504: LD_INT 800
51506: LESS
51507: AND
51508: PUSH
51509: LD_VAR 0 4
51513: PUSH
51514: LD_VAR 0 7
51518: ARRAY
51519: PPUSH
51520: CALL_OW 318
51524: NOT
51525: AND
51526: IFFALSE 51543
// ComCrawl ( group [ i ] ) ;
51528: LD_VAR 0 4
51532: PUSH
51533: LD_VAR 0 7
51537: ARRAY
51538: PPUSH
51539: CALL_OW 137
// if f_mines then
51543: LD_VAR 0 21
51547: IFFALSE 51790
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51549: LD_VAR 0 14
51553: PUSH
51554: LD_INT 1
51556: ARRAY
51557: PPUSH
51558: CALL_OW 247
51562: PUSH
51563: LD_INT 3
51565: EQUAL
51566: PUSH
51567: LD_VAR 0 14
51571: PUSH
51572: LD_INT 1
51574: ARRAY
51575: PUSH
51576: LD_VAR 0 27
51580: IN
51581: NOT
51582: AND
51583: IFFALSE 51790
// begin x := GetX ( tmp [ 1 ] ) ;
51585: LD_ADDR_VAR 0 10
51589: PUSH
51590: LD_VAR 0 14
51594: PUSH
51595: LD_INT 1
51597: ARRAY
51598: PPUSH
51599: CALL_OW 250
51603: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51604: LD_ADDR_VAR 0 11
51608: PUSH
51609: LD_VAR 0 14
51613: PUSH
51614: LD_INT 1
51616: ARRAY
51617: PPUSH
51618: CALL_OW 251
51622: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51623: LD_ADDR_VAR 0 12
51627: PUSH
51628: LD_VAR 0 4
51632: PUSH
51633: LD_VAR 0 7
51637: ARRAY
51638: PPUSH
51639: CALL 47518 0 1
51643: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51644: LD_VAR 0 4
51648: PUSH
51649: LD_VAR 0 7
51653: ARRAY
51654: PPUSH
51655: LD_VAR 0 10
51659: PPUSH
51660: LD_VAR 0 11
51664: PPUSH
51665: LD_VAR 0 14
51669: PUSH
51670: LD_INT 1
51672: ARRAY
51673: PPUSH
51674: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51678: LD_VAR 0 4
51682: PUSH
51683: LD_VAR 0 7
51687: ARRAY
51688: PPUSH
51689: LD_VAR 0 10
51693: PPUSH
51694: LD_VAR 0 12
51698: PPUSH
51699: LD_INT 7
51701: PPUSH
51702: CALL_OW 272
51706: PPUSH
51707: LD_VAR 0 11
51711: PPUSH
51712: LD_VAR 0 12
51716: PPUSH
51717: LD_INT 7
51719: PPUSH
51720: CALL_OW 273
51724: PPUSH
51725: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51729: LD_VAR 0 4
51733: PUSH
51734: LD_VAR 0 7
51738: ARRAY
51739: PPUSH
51740: LD_INT 71
51742: PPUSH
51743: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51747: LD_ADDR_VAR 0 27
51751: PUSH
51752: LD_VAR 0 27
51756: PPUSH
51757: LD_VAR 0 27
51761: PUSH
51762: LD_INT 1
51764: PLUS
51765: PPUSH
51766: LD_VAR 0 14
51770: PUSH
51771: LD_INT 1
51773: ARRAY
51774: PPUSH
51775: CALL_OW 1
51779: ST_TO_ADDR
// attacking := true ;
51780: LD_ADDR_VAR 0 29
51784: PUSH
51785: LD_INT 1
51787: ST_TO_ADDR
// continue ;
51788: GO 49635
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51790: LD_VAR 0 4
51794: PUSH
51795: LD_VAR 0 7
51799: ARRAY
51800: PPUSH
51801: CALL_OW 257
51805: PUSH
51806: LD_INT 17
51808: EQUAL
51809: PUSH
51810: LD_VAR 0 4
51814: PUSH
51815: LD_VAR 0 7
51819: ARRAY
51820: PPUSH
51821: CALL_OW 110
51825: PUSH
51826: LD_INT 71
51828: EQUAL
51829: NOT
51830: AND
51831: IFFALSE 51977
// begin attacking := false ;
51833: LD_ADDR_VAR 0 29
51837: PUSH
51838: LD_INT 0
51840: ST_TO_ADDR
// k := 5 ;
51841: LD_ADDR_VAR 0 9
51845: PUSH
51846: LD_INT 5
51848: ST_TO_ADDR
// if tmp < k then
51849: LD_VAR 0 14
51853: PUSH
51854: LD_VAR 0 9
51858: LESS
51859: IFFALSE 51871
// k := tmp ;
51861: LD_ADDR_VAR 0 9
51865: PUSH
51866: LD_VAR 0 14
51870: ST_TO_ADDR
// for j = 1 to k do
51871: LD_ADDR_VAR 0 8
51875: PUSH
51876: DOUBLE
51877: LD_INT 1
51879: DEC
51880: ST_TO_ADDR
51881: LD_VAR 0 9
51885: PUSH
51886: FOR_TO
51887: IFFALSE 51975
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51889: LD_VAR 0 14
51893: PUSH
51894: LD_VAR 0 8
51898: ARRAY
51899: PUSH
51900: LD_VAR 0 14
51904: PPUSH
51905: LD_INT 58
51907: PUSH
51908: EMPTY
51909: LIST
51910: PPUSH
51911: CALL_OW 72
51915: IN
51916: NOT
51917: IFFALSE 51973
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51919: LD_VAR 0 4
51923: PUSH
51924: LD_VAR 0 7
51928: ARRAY
51929: PPUSH
51930: LD_VAR 0 14
51934: PUSH
51935: LD_VAR 0 8
51939: ARRAY
51940: PPUSH
51941: CALL_OW 115
// attacking := true ;
51945: LD_ADDR_VAR 0 29
51949: PUSH
51950: LD_INT 1
51952: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51953: LD_VAR 0 4
51957: PUSH
51958: LD_VAR 0 7
51962: ARRAY
51963: PPUSH
51964: LD_INT 71
51966: PPUSH
51967: CALL_OW 109
// continue ;
51971: GO 51886
// end ; end ;
51973: GO 51886
51975: POP
51976: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51977: LD_VAR 0 4
51981: PUSH
51982: LD_VAR 0 7
51986: ARRAY
51987: PPUSH
51988: CALL_OW 257
51992: PUSH
51993: LD_INT 8
51995: EQUAL
51996: PUSH
51997: LD_VAR 0 4
52001: PUSH
52002: LD_VAR 0 7
52006: ARRAY
52007: PPUSH
52008: CALL_OW 264
52012: PUSH
52013: LD_INT 28
52015: PUSH
52016: LD_INT 45
52018: PUSH
52019: LD_INT 7
52021: PUSH
52022: LD_INT 47
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: IN
52031: OR
52032: IFFALSE 52262
// begin attacking := false ;
52034: LD_ADDR_VAR 0 29
52038: PUSH
52039: LD_INT 0
52041: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52042: LD_VAR 0 14
52046: PUSH
52047: LD_INT 1
52049: ARRAY
52050: PPUSH
52051: CALL_OW 266
52055: PUSH
52056: LD_INT 32
52058: PUSH
52059: LD_INT 31
52061: PUSH
52062: LD_INT 33
52064: PUSH
52065: LD_INT 4
52067: PUSH
52068: LD_INT 5
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: LIST
52075: LIST
52076: LIST
52077: IN
52078: IFFALSE 52262
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52080: LD_ADDR_VAR 0 9
52084: PUSH
52085: LD_VAR 0 14
52089: PUSH
52090: LD_INT 1
52092: ARRAY
52093: PPUSH
52094: CALL_OW 266
52098: PPUSH
52099: LD_VAR 0 14
52103: PUSH
52104: LD_INT 1
52106: ARRAY
52107: PPUSH
52108: CALL_OW 250
52112: PPUSH
52113: LD_VAR 0 14
52117: PUSH
52118: LD_INT 1
52120: ARRAY
52121: PPUSH
52122: CALL_OW 251
52126: PPUSH
52127: LD_VAR 0 14
52131: PUSH
52132: LD_INT 1
52134: ARRAY
52135: PPUSH
52136: CALL_OW 254
52140: PPUSH
52141: LD_VAR 0 14
52145: PUSH
52146: LD_INT 1
52148: ARRAY
52149: PPUSH
52150: CALL_OW 248
52154: PPUSH
52155: LD_INT 0
52157: PPUSH
52158: CALL 28894 0 6
52162: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52163: LD_ADDR_VAR 0 8
52167: PUSH
52168: LD_VAR 0 4
52172: PUSH
52173: LD_VAR 0 7
52177: ARRAY
52178: PPUSH
52179: LD_VAR 0 9
52183: PPUSH
52184: CALL 47581 0 2
52188: ST_TO_ADDR
// if j then
52189: LD_VAR 0 8
52193: IFFALSE 52262
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52195: LD_VAR 0 8
52199: PUSH
52200: LD_INT 1
52202: ARRAY
52203: PPUSH
52204: LD_VAR 0 8
52208: PUSH
52209: LD_INT 2
52211: ARRAY
52212: PPUSH
52213: CALL_OW 488
52217: IFFALSE 52262
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52219: LD_VAR 0 4
52223: PUSH
52224: LD_VAR 0 7
52228: ARRAY
52229: PPUSH
52230: LD_VAR 0 8
52234: PUSH
52235: LD_INT 1
52237: ARRAY
52238: PPUSH
52239: LD_VAR 0 8
52243: PUSH
52244: LD_INT 2
52246: ARRAY
52247: PPUSH
52248: CALL_OW 116
// attacking := true ;
52252: LD_ADDR_VAR 0 29
52256: PUSH
52257: LD_INT 1
52259: ST_TO_ADDR
// continue ;
52260: GO 49635
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52262: LD_VAR 0 4
52266: PUSH
52267: LD_VAR 0 7
52271: ARRAY
52272: PPUSH
52273: CALL_OW 265
52277: PUSH
52278: LD_INT 11
52280: EQUAL
52281: IFFALSE 52559
// begin k := 10 ;
52283: LD_ADDR_VAR 0 9
52287: PUSH
52288: LD_INT 10
52290: ST_TO_ADDR
// x := 0 ;
52291: LD_ADDR_VAR 0 10
52295: PUSH
52296: LD_INT 0
52298: ST_TO_ADDR
// if tmp < k then
52299: LD_VAR 0 14
52303: PUSH
52304: LD_VAR 0 9
52308: LESS
52309: IFFALSE 52321
// k := tmp ;
52311: LD_ADDR_VAR 0 9
52315: PUSH
52316: LD_VAR 0 14
52320: ST_TO_ADDR
// for j = k downto 1 do
52321: LD_ADDR_VAR 0 8
52325: PUSH
52326: DOUBLE
52327: LD_VAR 0 9
52331: INC
52332: ST_TO_ADDR
52333: LD_INT 1
52335: PUSH
52336: FOR_DOWNTO
52337: IFFALSE 52412
// begin if GetType ( tmp [ j ] ) = unit_human then
52339: LD_VAR 0 14
52343: PUSH
52344: LD_VAR 0 8
52348: ARRAY
52349: PPUSH
52350: CALL_OW 247
52354: PUSH
52355: LD_INT 1
52357: EQUAL
52358: IFFALSE 52410
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52360: LD_VAR 0 4
52364: PUSH
52365: LD_VAR 0 7
52369: ARRAY
52370: PPUSH
52371: LD_VAR 0 14
52375: PUSH
52376: LD_VAR 0 8
52380: ARRAY
52381: PPUSH
52382: CALL 47852 0 2
// x := tmp [ j ] ;
52386: LD_ADDR_VAR 0 10
52390: PUSH
52391: LD_VAR 0 14
52395: PUSH
52396: LD_VAR 0 8
52400: ARRAY
52401: ST_TO_ADDR
// attacking := true ;
52402: LD_ADDR_VAR 0 29
52406: PUSH
52407: LD_INT 1
52409: ST_TO_ADDR
// end ; end ;
52410: GO 52336
52412: POP
52413: POP
// if not x then
52414: LD_VAR 0 10
52418: NOT
52419: IFFALSE 52559
// begin attacking := true ;
52421: LD_ADDR_VAR 0 29
52425: PUSH
52426: LD_INT 1
52428: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52429: LD_VAR 0 4
52433: PUSH
52434: LD_VAR 0 7
52438: ARRAY
52439: PPUSH
52440: CALL_OW 250
52444: PPUSH
52445: LD_VAR 0 4
52449: PUSH
52450: LD_VAR 0 7
52454: ARRAY
52455: PPUSH
52456: CALL_OW 251
52460: PPUSH
52461: CALL_OW 546
52465: PUSH
52466: LD_INT 2
52468: ARRAY
52469: PUSH
52470: LD_VAR 0 14
52474: PUSH
52475: LD_INT 1
52477: ARRAY
52478: PPUSH
52479: CALL_OW 250
52483: PPUSH
52484: LD_VAR 0 14
52488: PUSH
52489: LD_INT 1
52491: ARRAY
52492: PPUSH
52493: CALL_OW 251
52497: PPUSH
52498: CALL_OW 546
52502: PUSH
52503: LD_INT 2
52505: ARRAY
52506: EQUAL
52507: IFFALSE 52535
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52509: LD_VAR 0 4
52513: PUSH
52514: LD_VAR 0 7
52518: ARRAY
52519: PPUSH
52520: LD_VAR 0 14
52524: PUSH
52525: LD_INT 1
52527: ARRAY
52528: PPUSH
52529: CALL 47852 0 2
52533: GO 52559
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52535: LD_VAR 0 4
52539: PUSH
52540: LD_VAR 0 7
52544: ARRAY
52545: PPUSH
52546: LD_VAR 0 14
52550: PUSH
52551: LD_INT 1
52553: ARRAY
52554: PPUSH
52555: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52559: LD_VAR 0 4
52563: PUSH
52564: LD_VAR 0 7
52568: ARRAY
52569: PPUSH
52570: CALL_OW 264
52574: PUSH
52575: LD_INT 29
52577: EQUAL
52578: IFFALSE 52944
// begin if WantsToAttack ( group [ i ] ) in bombed then
52580: LD_VAR 0 4
52584: PUSH
52585: LD_VAR 0 7
52589: ARRAY
52590: PPUSH
52591: CALL_OW 319
52595: PUSH
52596: LD_VAR 0 28
52600: IN
52601: IFFALSE 52605
// continue ;
52603: GO 49635
// k := 8 ;
52605: LD_ADDR_VAR 0 9
52609: PUSH
52610: LD_INT 8
52612: ST_TO_ADDR
// x := 0 ;
52613: LD_ADDR_VAR 0 10
52617: PUSH
52618: LD_INT 0
52620: ST_TO_ADDR
// if tmp < k then
52621: LD_VAR 0 14
52625: PUSH
52626: LD_VAR 0 9
52630: LESS
52631: IFFALSE 52643
// k := tmp ;
52633: LD_ADDR_VAR 0 9
52637: PUSH
52638: LD_VAR 0 14
52642: ST_TO_ADDR
// for j = 1 to k do
52643: LD_ADDR_VAR 0 8
52647: PUSH
52648: DOUBLE
52649: LD_INT 1
52651: DEC
52652: ST_TO_ADDR
52653: LD_VAR 0 9
52657: PUSH
52658: FOR_TO
52659: IFFALSE 52791
// begin if GetType ( tmp [ j ] ) = unit_building then
52661: LD_VAR 0 14
52665: PUSH
52666: LD_VAR 0 8
52670: ARRAY
52671: PPUSH
52672: CALL_OW 247
52676: PUSH
52677: LD_INT 3
52679: EQUAL
52680: IFFALSE 52789
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52682: LD_VAR 0 14
52686: PUSH
52687: LD_VAR 0 8
52691: ARRAY
52692: PUSH
52693: LD_VAR 0 28
52697: IN
52698: NOT
52699: PUSH
52700: LD_VAR 0 14
52704: PUSH
52705: LD_VAR 0 8
52709: ARRAY
52710: PPUSH
52711: CALL_OW 313
52715: AND
52716: IFFALSE 52789
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52718: LD_VAR 0 4
52722: PUSH
52723: LD_VAR 0 7
52727: ARRAY
52728: PPUSH
52729: LD_VAR 0 14
52733: PUSH
52734: LD_VAR 0 8
52738: ARRAY
52739: PPUSH
52740: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52744: LD_ADDR_VAR 0 28
52748: PUSH
52749: LD_VAR 0 28
52753: PPUSH
52754: LD_VAR 0 28
52758: PUSH
52759: LD_INT 1
52761: PLUS
52762: PPUSH
52763: LD_VAR 0 14
52767: PUSH
52768: LD_VAR 0 8
52772: ARRAY
52773: PPUSH
52774: CALL_OW 1
52778: ST_TO_ADDR
// attacking := true ;
52779: LD_ADDR_VAR 0 29
52783: PUSH
52784: LD_INT 1
52786: ST_TO_ADDR
// break ;
52787: GO 52791
// end ; end ;
52789: GO 52658
52791: POP
52792: POP
// if not attacking and f_attack_depot then
52793: LD_VAR 0 29
52797: NOT
52798: PUSH
52799: LD_VAR 0 25
52803: AND
52804: IFFALSE 52899
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52806: LD_ADDR_VAR 0 13
52810: PUSH
52811: LD_VAR 0 14
52815: PPUSH
52816: LD_INT 2
52818: PUSH
52819: LD_INT 30
52821: PUSH
52822: LD_INT 0
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: LD_INT 30
52831: PUSH
52832: LD_INT 1
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: LIST
52843: PPUSH
52844: CALL_OW 72
52848: ST_TO_ADDR
// if z then
52849: LD_VAR 0 13
52853: IFFALSE 52899
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52855: LD_VAR 0 4
52859: PUSH
52860: LD_VAR 0 7
52864: ARRAY
52865: PPUSH
52866: LD_VAR 0 13
52870: PPUSH
52871: LD_VAR 0 4
52875: PUSH
52876: LD_VAR 0 7
52880: ARRAY
52881: PPUSH
52882: CALL_OW 74
52886: PPUSH
52887: CALL_OW 115
// attacking := true ;
52891: LD_ADDR_VAR 0 29
52895: PUSH
52896: LD_INT 1
52898: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52899: LD_VAR 0 4
52903: PUSH
52904: LD_VAR 0 7
52908: ARRAY
52909: PPUSH
52910: CALL_OW 256
52914: PUSH
52915: LD_INT 500
52917: LESS
52918: IFFALSE 52944
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52920: LD_VAR 0 4
52924: PUSH
52925: LD_VAR 0 7
52929: ARRAY
52930: PPUSH
52931: LD_VAR 0 14
52935: PUSH
52936: LD_INT 1
52938: ARRAY
52939: PPUSH
52940: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52944: LD_VAR 0 4
52948: PUSH
52949: LD_VAR 0 7
52953: ARRAY
52954: PPUSH
52955: CALL_OW 264
52959: PUSH
52960: LD_INT 49
52962: EQUAL
52963: IFFALSE 53084
// begin if not HasTask ( group [ i ] ) then
52965: LD_VAR 0 4
52969: PUSH
52970: LD_VAR 0 7
52974: ARRAY
52975: PPUSH
52976: CALL_OW 314
52980: NOT
52981: IFFALSE 53084
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52983: LD_ADDR_VAR 0 9
52987: PUSH
52988: LD_INT 81
52990: PUSH
52991: LD_VAR 0 4
52995: PUSH
52996: LD_VAR 0 7
53000: ARRAY
53001: PPUSH
53002: CALL_OW 255
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: PPUSH
53011: CALL_OW 69
53015: PPUSH
53016: LD_VAR 0 4
53020: PUSH
53021: LD_VAR 0 7
53025: ARRAY
53026: PPUSH
53027: CALL_OW 74
53031: ST_TO_ADDR
// if k then
53032: LD_VAR 0 9
53036: IFFALSE 53084
// if GetDistUnits ( group [ i ] , k ) > 10 then
53038: LD_VAR 0 4
53042: PUSH
53043: LD_VAR 0 7
53047: ARRAY
53048: PPUSH
53049: LD_VAR 0 9
53053: PPUSH
53054: CALL_OW 296
53058: PUSH
53059: LD_INT 10
53061: GREATER
53062: IFFALSE 53084
// ComMoveUnit ( group [ i ] , k ) ;
53064: LD_VAR 0 4
53068: PUSH
53069: LD_VAR 0 7
53073: ARRAY
53074: PPUSH
53075: LD_VAR 0 9
53079: PPUSH
53080: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53084: LD_VAR 0 4
53088: PUSH
53089: LD_VAR 0 7
53093: ARRAY
53094: PPUSH
53095: CALL_OW 256
53099: PUSH
53100: LD_INT 250
53102: LESS
53103: PUSH
53104: LD_VAR 0 4
53108: PUSH
53109: LD_VAR 0 7
53113: ARRAY
53114: PUSH
53115: LD_INT 21
53117: PUSH
53118: LD_INT 2
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: PUSH
53125: LD_INT 23
53127: PUSH
53128: LD_INT 2
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: PUSH
53135: EMPTY
53136: LIST
53137: LIST
53138: PPUSH
53139: CALL_OW 69
53143: IN
53144: AND
53145: IFFALSE 53270
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53147: LD_ADDR_VAR 0 9
53151: PUSH
53152: LD_OWVAR 3
53156: PUSH
53157: LD_VAR 0 4
53161: PUSH
53162: LD_VAR 0 7
53166: ARRAY
53167: DIFF
53168: PPUSH
53169: LD_VAR 0 4
53173: PUSH
53174: LD_VAR 0 7
53178: ARRAY
53179: PPUSH
53180: CALL_OW 74
53184: ST_TO_ADDR
// if not k then
53185: LD_VAR 0 9
53189: NOT
53190: IFFALSE 53194
// continue ;
53192: GO 49635
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53194: LD_VAR 0 9
53198: PUSH
53199: LD_INT 81
53201: PUSH
53202: LD_VAR 0 4
53206: PUSH
53207: LD_VAR 0 7
53211: ARRAY
53212: PPUSH
53213: CALL_OW 255
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PPUSH
53222: CALL_OW 69
53226: IN
53227: PUSH
53228: LD_VAR 0 9
53232: PPUSH
53233: LD_VAR 0 4
53237: PUSH
53238: LD_VAR 0 7
53242: ARRAY
53243: PPUSH
53244: CALL_OW 296
53248: PUSH
53249: LD_INT 5
53251: LESS
53252: AND
53253: IFFALSE 53270
// ComAutodestruct ( group [ i ] ) ;
53255: LD_VAR 0 4
53259: PUSH
53260: LD_VAR 0 7
53264: ARRAY
53265: PPUSH
53266: CALL 47750 0 1
// end ; if f_attack_depot then
53270: LD_VAR 0 25
53274: IFFALSE 53386
// begin k := 6 ;
53276: LD_ADDR_VAR 0 9
53280: PUSH
53281: LD_INT 6
53283: ST_TO_ADDR
// if tmp < k then
53284: LD_VAR 0 14
53288: PUSH
53289: LD_VAR 0 9
53293: LESS
53294: IFFALSE 53306
// k := tmp ;
53296: LD_ADDR_VAR 0 9
53300: PUSH
53301: LD_VAR 0 14
53305: ST_TO_ADDR
// for j = 1 to k do
53306: LD_ADDR_VAR 0 8
53310: PUSH
53311: DOUBLE
53312: LD_INT 1
53314: DEC
53315: ST_TO_ADDR
53316: LD_VAR 0 9
53320: PUSH
53321: FOR_TO
53322: IFFALSE 53384
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53324: LD_VAR 0 8
53328: PPUSH
53329: CALL_OW 266
53333: PUSH
53334: LD_INT 0
53336: PUSH
53337: LD_INT 1
53339: PUSH
53340: EMPTY
53341: LIST
53342: LIST
53343: IN
53344: IFFALSE 53382
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53346: LD_VAR 0 4
53350: PUSH
53351: LD_VAR 0 7
53355: ARRAY
53356: PPUSH
53357: LD_VAR 0 14
53361: PUSH
53362: LD_VAR 0 8
53366: ARRAY
53367: PPUSH
53368: CALL_OW 115
// attacking := true ;
53372: LD_ADDR_VAR 0 29
53376: PUSH
53377: LD_INT 1
53379: ST_TO_ADDR
// break ;
53380: GO 53384
// end ;
53382: GO 53321
53384: POP
53385: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53386: LD_VAR 0 4
53390: PUSH
53391: LD_VAR 0 7
53395: ARRAY
53396: PPUSH
53397: CALL_OW 302
53401: PUSH
53402: LD_VAR 0 29
53406: NOT
53407: AND
53408: IFFALSE 53730
// begin if GetTag ( group [ i ] ) = 71 then
53410: LD_VAR 0 4
53414: PUSH
53415: LD_VAR 0 7
53419: ARRAY
53420: PPUSH
53421: CALL_OW 110
53425: PUSH
53426: LD_INT 71
53428: EQUAL
53429: IFFALSE 53470
// begin if HasTask ( group [ i ] ) then
53431: LD_VAR 0 4
53435: PUSH
53436: LD_VAR 0 7
53440: ARRAY
53441: PPUSH
53442: CALL_OW 314
53446: IFFALSE 53452
// continue else
53448: GO 49635
53450: GO 53470
// SetTag ( group [ i ] , 0 ) ;
53452: LD_VAR 0 4
53456: PUSH
53457: LD_VAR 0 7
53461: ARRAY
53462: PPUSH
53463: LD_INT 0
53465: PPUSH
53466: CALL_OW 109
// end ; k := 8 ;
53470: LD_ADDR_VAR 0 9
53474: PUSH
53475: LD_INT 8
53477: ST_TO_ADDR
// x := 0 ;
53478: LD_ADDR_VAR 0 10
53482: PUSH
53483: LD_INT 0
53485: ST_TO_ADDR
// if tmp < k then
53486: LD_VAR 0 14
53490: PUSH
53491: LD_VAR 0 9
53495: LESS
53496: IFFALSE 53508
// k := tmp ;
53498: LD_ADDR_VAR 0 9
53502: PUSH
53503: LD_VAR 0 14
53507: ST_TO_ADDR
// for j = 1 to k do
53508: LD_ADDR_VAR 0 8
53512: PUSH
53513: DOUBLE
53514: LD_INT 1
53516: DEC
53517: ST_TO_ADDR
53518: LD_VAR 0 9
53522: PUSH
53523: FOR_TO
53524: IFFALSE 53622
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53526: LD_VAR 0 14
53530: PUSH
53531: LD_VAR 0 8
53535: ARRAY
53536: PPUSH
53537: CALL_OW 247
53541: PUSH
53542: LD_INT 1
53544: EQUAL
53545: PUSH
53546: LD_VAR 0 14
53550: PUSH
53551: LD_VAR 0 8
53555: ARRAY
53556: PPUSH
53557: CALL_OW 256
53561: PUSH
53562: LD_INT 250
53564: LESS
53565: PUSH
53566: LD_VAR 0 20
53570: AND
53571: PUSH
53572: LD_VAR 0 20
53576: NOT
53577: PUSH
53578: LD_VAR 0 14
53582: PUSH
53583: LD_VAR 0 8
53587: ARRAY
53588: PPUSH
53589: CALL_OW 256
53593: PUSH
53594: LD_INT 250
53596: GREATEREQUAL
53597: AND
53598: OR
53599: AND
53600: IFFALSE 53620
// begin x := tmp [ j ] ;
53602: LD_ADDR_VAR 0 10
53606: PUSH
53607: LD_VAR 0 14
53611: PUSH
53612: LD_VAR 0 8
53616: ARRAY
53617: ST_TO_ADDR
// break ;
53618: GO 53622
// end ;
53620: GO 53523
53622: POP
53623: POP
// if x then
53624: LD_VAR 0 10
53628: IFFALSE 53652
// ComAttackUnit ( group [ i ] , x ) else
53630: LD_VAR 0 4
53634: PUSH
53635: LD_VAR 0 7
53639: ARRAY
53640: PPUSH
53641: LD_VAR 0 10
53645: PPUSH
53646: CALL_OW 115
53650: GO 53676
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53652: LD_VAR 0 4
53656: PUSH
53657: LD_VAR 0 7
53661: ARRAY
53662: PPUSH
53663: LD_VAR 0 14
53667: PUSH
53668: LD_INT 1
53670: ARRAY
53671: PPUSH
53672: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53676: LD_VAR 0 4
53680: PUSH
53681: LD_VAR 0 7
53685: ARRAY
53686: PPUSH
53687: CALL_OW 314
53691: NOT
53692: IFFALSE 53730
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53694: LD_VAR 0 4
53698: PUSH
53699: LD_VAR 0 7
53703: ARRAY
53704: PPUSH
53705: LD_VAR 0 14
53709: PPUSH
53710: LD_VAR 0 4
53714: PUSH
53715: LD_VAR 0 7
53719: ARRAY
53720: PPUSH
53721: CALL_OW 74
53725: PPUSH
53726: CALL_OW 115
// end ; end ; end ;
53730: GO 49635
53732: POP
53733: POP
// wait ( 0 0$1 ) ;
53734: LD_INT 35
53736: PPUSH
53737: CALL_OW 67
// until group = [ ] ;
53741: LD_VAR 0 4
53745: PUSH
53746: EMPTY
53747: EQUAL
53748: IFFALSE 49620
// end ;
53750: LD_VAR 0 2
53754: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53755: LD_INT 0
53757: PPUSH
53758: PPUSH
53759: PPUSH
53760: PPUSH
// if not base_units then
53761: LD_VAR 0 1
53765: NOT
53766: IFFALSE 53770
// exit ;
53768: GO 53857
// result := false ;
53770: LD_ADDR_VAR 0 2
53774: PUSH
53775: LD_INT 0
53777: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53778: LD_ADDR_VAR 0 5
53782: PUSH
53783: LD_VAR 0 1
53787: PPUSH
53788: LD_INT 21
53790: PUSH
53791: LD_INT 3
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: PPUSH
53798: CALL_OW 72
53802: ST_TO_ADDR
// if not tmp then
53803: LD_VAR 0 5
53807: NOT
53808: IFFALSE 53812
// exit ;
53810: GO 53857
// for i in tmp do
53812: LD_ADDR_VAR 0 3
53816: PUSH
53817: LD_VAR 0 5
53821: PUSH
53822: FOR_IN
53823: IFFALSE 53855
// begin result := EnemyInRange ( i , 22 ) ;
53825: LD_ADDR_VAR 0 2
53829: PUSH
53830: LD_VAR 0 3
53834: PPUSH
53835: LD_INT 22
53837: PPUSH
53838: CALL 47433 0 2
53842: ST_TO_ADDR
// if result then
53843: LD_VAR 0 2
53847: IFFALSE 53853
// exit ;
53849: POP
53850: POP
53851: GO 53857
// end ;
53853: GO 53822
53855: POP
53856: POP
// end ;
53857: LD_VAR 0 2
53861: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53862: LD_INT 0
53864: PPUSH
53865: PPUSH
// if not units then
53866: LD_VAR 0 1
53870: NOT
53871: IFFALSE 53875
// exit ;
53873: GO 53945
// result := [ ] ;
53875: LD_ADDR_VAR 0 3
53879: PUSH
53880: EMPTY
53881: ST_TO_ADDR
// for i in units do
53882: LD_ADDR_VAR 0 4
53886: PUSH
53887: LD_VAR 0 1
53891: PUSH
53892: FOR_IN
53893: IFFALSE 53943
// if GetTag ( i ) = tag then
53895: LD_VAR 0 4
53899: PPUSH
53900: CALL_OW 110
53904: PUSH
53905: LD_VAR 0 2
53909: EQUAL
53910: IFFALSE 53941
// result := Insert ( result , result + 1 , i ) ;
53912: LD_ADDR_VAR 0 3
53916: PUSH
53917: LD_VAR 0 3
53921: PPUSH
53922: LD_VAR 0 3
53926: PUSH
53927: LD_INT 1
53929: PLUS
53930: PPUSH
53931: LD_VAR 0 4
53935: PPUSH
53936: CALL_OW 2
53940: ST_TO_ADDR
53941: GO 53892
53943: POP
53944: POP
// end ;
53945: LD_VAR 0 3
53949: RET
// export function IsDriver ( un ) ; begin
53950: LD_INT 0
53952: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53953: LD_ADDR_VAR 0 2
53957: PUSH
53958: LD_VAR 0 1
53962: PUSH
53963: LD_INT 55
53965: PUSH
53966: EMPTY
53967: LIST
53968: PPUSH
53969: CALL_OW 69
53973: IN
53974: ST_TO_ADDR
// end ;
53975: LD_VAR 0 2
53979: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53980: LD_INT 0
53982: PPUSH
53983: PPUSH
// list := [ ] ;
53984: LD_ADDR_VAR 0 5
53988: PUSH
53989: EMPTY
53990: ST_TO_ADDR
// case d of 0 :
53991: LD_VAR 0 3
53995: PUSH
53996: LD_INT 0
53998: DOUBLE
53999: EQUAL
54000: IFTRUE 54004
54002: GO 54137
54004: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54005: LD_ADDR_VAR 0 5
54009: PUSH
54010: LD_VAR 0 1
54014: PUSH
54015: LD_INT 4
54017: MINUS
54018: PUSH
54019: LD_VAR 0 2
54023: PUSH
54024: LD_INT 4
54026: MINUS
54027: PUSH
54028: LD_INT 2
54030: PUSH
54031: EMPTY
54032: LIST
54033: LIST
54034: LIST
54035: PUSH
54036: LD_VAR 0 1
54040: PUSH
54041: LD_INT 3
54043: MINUS
54044: PUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: PUSH
54053: EMPTY
54054: LIST
54055: LIST
54056: LIST
54057: PUSH
54058: LD_VAR 0 1
54062: PUSH
54063: LD_INT 4
54065: PLUS
54066: PUSH
54067: LD_VAR 0 2
54071: PUSH
54072: LD_INT 4
54074: PUSH
54075: EMPTY
54076: LIST
54077: LIST
54078: LIST
54079: PUSH
54080: LD_VAR 0 1
54084: PUSH
54085: LD_INT 3
54087: PLUS
54088: PUSH
54089: LD_VAR 0 2
54093: PUSH
54094: LD_INT 3
54096: PLUS
54097: PUSH
54098: LD_INT 5
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: LIST
54105: PUSH
54106: LD_VAR 0 1
54110: PUSH
54111: LD_VAR 0 2
54115: PUSH
54116: LD_INT 4
54118: PLUS
54119: PUSH
54120: LD_INT 0
54122: PUSH
54123: EMPTY
54124: LIST
54125: LIST
54126: LIST
54127: PUSH
54128: EMPTY
54129: LIST
54130: LIST
54131: LIST
54132: LIST
54133: LIST
54134: ST_TO_ADDR
// end ; 1 :
54135: GO 54835
54137: LD_INT 1
54139: DOUBLE
54140: EQUAL
54141: IFTRUE 54145
54143: GO 54278
54145: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54146: LD_ADDR_VAR 0 5
54150: PUSH
54151: LD_VAR 0 1
54155: PUSH
54156: LD_VAR 0 2
54160: PUSH
54161: LD_INT 4
54163: MINUS
54164: PUSH
54165: LD_INT 3
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: LIST
54172: PUSH
54173: LD_VAR 0 1
54177: PUSH
54178: LD_INT 3
54180: MINUS
54181: PUSH
54182: LD_VAR 0 2
54186: PUSH
54187: LD_INT 3
54189: MINUS
54190: PUSH
54191: LD_INT 2
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: LIST
54198: PUSH
54199: LD_VAR 0 1
54203: PUSH
54204: LD_INT 4
54206: MINUS
54207: PUSH
54208: LD_VAR 0 2
54212: PUSH
54213: LD_INT 1
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: LIST
54220: PUSH
54221: LD_VAR 0 1
54225: PUSH
54226: LD_VAR 0 2
54230: PUSH
54231: LD_INT 3
54233: PLUS
54234: PUSH
54235: LD_INT 0
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: LIST
54242: PUSH
54243: LD_VAR 0 1
54247: PUSH
54248: LD_INT 4
54250: PLUS
54251: PUSH
54252: LD_VAR 0 2
54256: PUSH
54257: LD_INT 4
54259: PLUS
54260: PUSH
54261: LD_INT 5
54263: PUSH
54264: EMPTY
54265: LIST
54266: LIST
54267: LIST
54268: PUSH
54269: EMPTY
54270: LIST
54271: LIST
54272: LIST
54273: LIST
54274: LIST
54275: ST_TO_ADDR
// end ; 2 :
54276: GO 54835
54278: LD_INT 2
54280: DOUBLE
54281: EQUAL
54282: IFTRUE 54286
54284: GO 54415
54286: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54287: LD_ADDR_VAR 0 5
54291: PUSH
54292: LD_VAR 0 1
54296: PUSH
54297: LD_VAR 0 2
54301: PUSH
54302: LD_INT 3
54304: MINUS
54305: PUSH
54306: LD_INT 3
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: PUSH
54314: LD_VAR 0 1
54318: PUSH
54319: LD_INT 4
54321: PLUS
54322: PUSH
54323: LD_VAR 0 2
54327: PUSH
54328: LD_INT 4
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: LIST
54335: PUSH
54336: LD_VAR 0 1
54340: PUSH
54341: LD_VAR 0 2
54345: PUSH
54346: LD_INT 4
54348: PLUS
54349: PUSH
54350: LD_INT 0
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: LIST
54357: PUSH
54358: LD_VAR 0 1
54362: PUSH
54363: LD_INT 3
54365: MINUS
54366: PUSH
54367: LD_VAR 0 2
54371: PUSH
54372: LD_INT 1
54374: PUSH
54375: EMPTY
54376: LIST
54377: LIST
54378: LIST
54379: PUSH
54380: LD_VAR 0 1
54384: PUSH
54385: LD_INT 4
54387: MINUS
54388: PUSH
54389: LD_VAR 0 2
54393: PUSH
54394: LD_INT 4
54396: MINUS
54397: PUSH
54398: LD_INT 2
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: LIST
54405: PUSH
54406: EMPTY
54407: LIST
54408: LIST
54409: LIST
54410: LIST
54411: LIST
54412: ST_TO_ADDR
// end ; 3 :
54413: GO 54835
54415: LD_INT 3
54417: DOUBLE
54418: EQUAL
54419: IFTRUE 54423
54421: GO 54556
54423: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54424: LD_ADDR_VAR 0 5
54428: PUSH
54429: LD_VAR 0 1
54433: PUSH
54434: LD_INT 3
54436: PLUS
54437: PUSH
54438: LD_VAR 0 2
54442: PUSH
54443: LD_INT 4
54445: PUSH
54446: EMPTY
54447: LIST
54448: LIST
54449: LIST
54450: PUSH
54451: LD_VAR 0 1
54455: PUSH
54456: LD_INT 4
54458: PLUS
54459: PUSH
54460: LD_VAR 0 2
54464: PUSH
54465: LD_INT 4
54467: PLUS
54468: PUSH
54469: LD_INT 5
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: LIST
54476: PUSH
54477: LD_VAR 0 1
54481: PUSH
54482: LD_INT 4
54484: MINUS
54485: PUSH
54486: LD_VAR 0 2
54490: PUSH
54491: LD_INT 1
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: LIST
54498: PUSH
54499: LD_VAR 0 1
54503: PUSH
54504: LD_VAR 0 2
54508: PUSH
54509: LD_INT 4
54511: MINUS
54512: PUSH
54513: LD_INT 3
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: LIST
54520: PUSH
54521: LD_VAR 0 1
54525: PUSH
54526: LD_INT 3
54528: MINUS
54529: PUSH
54530: LD_VAR 0 2
54534: PUSH
54535: LD_INT 3
54537: MINUS
54538: PUSH
54539: LD_INT 2
54541: PUSH
54542: EMPTY
54543: LIST
54544: LIST
54545: LIST
54546: PUSH
54547: EMPTY
54548: LIST
54549: LIST
54550: LIST
54551: LIST
54552: LIST
54553: ST_TO_ADDR
// end ; 4 :
54554: GO 54835
54556: LD_INT 4
54558: DOUBLE
54559: EQUAL
54560: IFTRUE 54564
54562: GO 54697
54564: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54565: LD_ADDR_VAR 0 5
54569: PUSH
54570: LD_VAR 0 1
54574: PUSH
54575: LD_VAR 0 2
54579: PUSH
54580: LD_INT 4
54582: PLUS
54583: PUSH
54584: LD_INT 0
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: LIST
54591: PUSH
54592: LD_VAR 0 1
54596: PUSH
54597: LD_INT 3
54599: PLUS
54600: PUSH
54601: LD_VAR 0 2
54605: PUSH
54606: LD_INT 3
54608: PLUS
54609: PUSH
54610: LD_INT 5
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: LIST
54617: PUSH
54618: LD_VAR 0 1
54622: PUSH
54623: LD_INT 4
54625: PLUS
54626: PUSH
54627: LD_VAR 0 2
54631: PUSH
54632: LD_INT 4
54634: PUSH
54635: EMPTY
54636: LIST
54637: LIST
54638: LIST
54639: PUSH
54640: LD_VAR 0 1
54644: PUSH
54645: LD_VAR 0 2
54649: PUSH
54650: LD_INT 3
54652: MINUS
54653: PUSH
54654: LD_INT 3
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: PUSH
54662: LD_VAR 0 1
54666: PUSH
54667: LD_INT 4
54669: MINUS
54670: PUSH
54671: LD_VAR 0 2
54675: PUSH
54676: LD_INT 4
54678: MINUS
54679: PUSH
54680: LD_INT 2
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: LIST
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: LIST
54692: LIST
54693: LIST
54694: ST_TO_ADDR
// end ; 5 :
54695: GO 54835
54697: LD_INT 5
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54834
54705: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54706: LD_ADDR_VAR 0 5
54710: PUSH
54711: LD_VAR 0 1
54715: PUSH
54716: LD_INT 4
54718: MINUS
54719: PUSH
54720: LD_VAR 0 2
54724: PUSH
54725: LD_INT 1
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: PUSH
54733: LD_VAR 0 1
54737: PUSH
54738: LD_VAR 0 2
54742: PUSH
54743: LD_INT 4
54745: MINUS
54746: PUSH
54747: LD_INT 3
54749: PUSH
54750: EMPTY
54751: LIST
54752: LIST
54753: LIST
54754: PUSH
54755: LD_VAR 0 1
54759: PUSH
54760: LD_INT 4
54762: PLUS
54763: PUSH
54764: LD_VAR 0 2
54768: PUSH
54769: LD_INT 4
54771: PLUS
54772: PUSH
54773: LD_INT 5
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: PUSH
54781: LD_VAR 0 1
54785: PUSH
54786: LD_INT 3
54788: PLUS
54789: PUSH
54790: LD_VAR 0 2
54794: PUSH
54795: LD_INT 4
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: LIST
54802: PUSH
54803: LD_VAR 0 1
54807: PUSH
54808: LD_VAR 0 2
54812: PUSH
54813: LD_INT 3
54815: PLUS
54816: PUSH
54817: LD_INT 0
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: LIST
54829: LIST
54830: LIST
54831: ST_TO_ADDR
// end ; end ;
54832: GO 54835
54834: POP
// result := list ;
54835: LD_ADDR_VAR 0 4
54839: PUSH
54840: LD_VAR 0 5
54844: ST_TO_ADDR
// end ;
54845: LD_VAR 0 4
54849: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54850: LD_INT 0
54852: PPUSH
54853: PPUSH
54854: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54855: LD_VAR 0 1
54859: NOT
54860: PUSH
54861: LD_VAR 0 2
54865: PUSH
54866: LD_INT 1
54868: PUSH
54869: LD_INT 2
54871: PUSH
54872: LD_INT 3
54874: PUSH
54875: LD_INT 4
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: LIST
54882: LIST
54883: IN
54884: NOT
54885: OR
54886: IFFALSE 54890
// exit ;
54888: GO 54982
// tmp := [ ] ;
54890: LD_ADDR_VAR 0 5
54894: PUSH
54895: EMPTY
54896: ST_TO_ADDR
// for i in units do
54897: LD_ADDR_VAR 0 4
54901: PUSH
54902: LD_VAR 0 1
54906: PUSH
54907: FOR_IN
54908: IFFALSE 54951
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54910: LD_ADDR_VAR 0 5
54914: PUSH
54915: LD_VAR 0 5
54919: PPUSH
54920: LD_VAR 0 5
54924: PUSH
54925: LD_INT 1
54927: PLUS
54928: PPUSH
54929: LD_VAR 0 4
54933: PPUSH
54934: LD_VAR 0 2
54938: PPUSH
54939: CALL_OW 259
54943: PPUSH
54944: CALL_OW 2
54948: ST_TO_ADDR
54949: GO 54907
54951: POP
54952: POP
// if not tmp then
54953: LD_VAR 0 5
54957: NOT
54958: IFFALSE 54962
// exit ;
54960: GO 54982
// result := SortListByListDesc ( units , tmp ) ;
54962: LD_ADDR_VAR 0 3
54966: PUSH
54967: LD_VAR 0 1
54971: PPUSH
54972: LD_VAR 0 5
54976: PPUSH
54977: CALL_OW 77
54981: ST_TO_ADDR
// end ;
54982: LD_VAR 0 3
54986: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54987: LD_INT 0
54989: PPUSH
54990: PPUSH
54991: PPUSH
// x := GetX ( building ) ;
54992: LD_ADDR_VAR 0 4
54996: PUSH
54997: LD_VAR 0 2
55001: PPUSH
55002: CALL_OW 250
55006: ST_TO_ADDR
// y := GetY ( building ) ;
55007: LD_ADDR_VAR 0 5
55011: PUSH
55012: LD_VAR 0 2
55016: PPUSH
55017: CALL_OW 251
55021: ST_TO_ADDR
// if GetTaskList ( unit ) then
55022: LD_VAR 0 1
55026: PPUSH
55027: CALL_OW 437
55031: IFFALSE 55126
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55033: LD_STRING e
55035: PUSH
55036: LD_VAR 0 1
55040: PPUSH
55041: CALL_OW 437
55045: PUSH
55046: LD_INT 1
55048: ARRAY
55049: PUSH
55050: LD_INT 1
55052: ARRAY
55053: EQUAL
55054: PUSH
55055: LD_VAR 0 4
55059: PUSH
55060: LD_VAR 0 1
55064: PPUSH
55065: CALL_OW 437
55069: PUSH
55070: LD_INT 1
55072: ARRAY
55073: PUSH
55074: LD_INT 2
55076: ARRAY
55077: EQUAL
55078: AND
55079: PUSH
55080: LD_VAR 0 5
55084: PUSH
55085: LD_VAR 0 1
55089: PPUSH
55090: CALL_OW 437
55094: PUSH
55095: LD_INT 1
55097: ARRAY
55098: PUSH
55099: LD_INT 3
55101: ARRAY
55102: EQUAL
55103: AND
55104: IFFALSE 55116
// result := true else
55106: LD_ADDR_VAR 0 3
55110: PUSH
55111: LD_INT 1
55113: ST_TO_ADDR
55114: GO 55124
// result := false ;
55116: LD_ADDR_VAR 0 3
55120: PUSH
55121: LD_INT 0
55123: ST_TO_ADDR
// end else
55124: GO 55134
// result := false ;
55126: LD_ADDR_VAR 0 3
55130: PUSH
55131: LD_INT 0
55133: ST_TO_ADDR
// end ;
55134: LD_VAR 0 3
55138: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55139: LD_INT 0
55141: PPUSH
55142: PPUSH
55143: PPUSH
55144: PPUSH
// if not unit or not area then
55145: LD_VAR 0 1
55149: NOT
55150: PUSH
55151: LD_VAR 0 2
55155: NOT
55156: OR
55157: IFFALSE 55161
// exit ;
55159: GO 55325
// tmp := AreaToList ( area , i ) ;
55161: LD_ADDR_VAR 0 6
55165: PUSH
55166: LD_VAR 0 2
55170: PPUSH
55171: LD_VAR 0 5
55175: PPUSH
55176: CALL_OW 517
55180: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55181: LD_ADDR_VAR 0 5
55185: PUSH
55186: DOUBLE
55187: LD_INT 1
55189: DEC
55190: ST_TO_ADDR
55191: LD_VAR 0 6
55195: PUSH
55196: LD_INT 1
55198: ARRAY
55199: PUSH
55200: FOR_TO
55201: IFFALSE 55323
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55203: LD_ADDR_VAR 0 7
55207: PUSH
55208: LD_VAR 0 6
55212: PUSH
55213: LD_INT 1
55215: ARRAY
55216: PUSH
55217: LD_VAR 0 5
55221: ARRAY
55222: PUSH
55223: LD_VAR 0 6
55227: PUSH
55228: LD_INT 2
55230: ARRAY
55231: PUSH
55232: LD_VAR 0 5
55236: ARRAY
55237: PUSH
55238: EMPTY
55239: LIST
55240: LIST
55241: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55242: LD_VAR 0 7
55246: PUSH
55247: LD_INT 1
55249: ARRAY
55250: PPUSH
55251: LD_VAR 0 7
55255: PUSH
55256: LD_INT 2
55258: ARRAY
55259: PPUSH
55260: CALL_OW 428
55264: PUSH
55265: LD_INT 0
55267: EQUAL
55268: IFFALSE 55321
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55270: LD_VAR 0 1
55274: PPUSH
55275: LD_VAR 0 7
55279: PUSH
55280: LD_INT 1
55282: ARRAY
55283: PPUSH
55284: LD_VAR 0 7
55288: PUSH
55289: LD_INT 2
55291: ARRAY
55292: PPUSH
55293: LD_VAR 0 3
55297: PPUSH
55298: CALL_OW 48
// result := IsPlaced ( unit ) ;
55302: LD_ADDR_VAR 0 4
55306: PUSH
55307: LD_VAR 0 1
55311: PPUSH
55312: CALL_OW 305
55316: ST_TO_ADDR
// exit ;
55317: POP
55318: POP
55319: GO 55325
// end ; end ;
55321: GO 55200
55323: POP
55324: POP
// end ;
55325: LD_VAR 0 4
55329: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55330: LD_INT 0
55332: PPUSH
55333: PPUSH
55334: PPUSH
// if not side or side > 8 then
55335: LD_VAR 0 1
55339: NOT
55340: PUSH
55341: LD_VAR 0 1
55345: PUSH
55346: LD_INT 8
55348: GREATER
55349: OR
55350: IFFALSE 55354
// exit ;
55352: GO 55541
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55354: LD_ADDR_VAR 0 4
55358: PUSH
55359: LD_INT 22
55361: PUSH
55362: LD_VAR 0 1
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: PUSH
55371: LD_INT 21
55373: PUSH
55374: LD_INT 3
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: PUSH
55381: EMPTY
55382: LIST
55383: LIST
55384: PPUSH
55385: CALL_OW 69
55389: ST_TO_ADDR
// if not tmp then
55390: LD_VAR 0 4
55394: NOT
55395: IFFALSE 55399
// exit ;
55397: GO 55541
// enable_addtolog := true ;
55399: LD_ADDR_OWVAR 81
55403: PUSH
55404: LD_INT 1
55406: ST_TO_ADDR
// AddToLog ( [ ) ;
55407: LD_STRING [
55409: PPUSH
55410: CALL_OW 561
// for i in tmp do
55414: LD_ADDR_VAR 0 3
55418: PUSH
55419: LD_VAR 0 4
55423: PUSH
55424: FOR_IN
55425: IFFALSE 55532
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55427: LD_STRING [
55429: PUSH
55430: LD_VAR 0 3
55434: PPUSH
55435: CALL_OW 266
55439: STR
55440: PUSH
55441: LD_STRING , 
55443: STR
55444: PUSH
55445: LD_VAR 0 3
55449: PPUSH
55450: CALL_OW 250
55454: STR
55455: PUSH
55456: LD_STRING , 
55458: STR
55459: PUSH
55460: LD_VAR 0 3
55464: PPUSH
55465: CALL_OW 251
55469: STR
55470: PUSH
55471: LD_STRING , 
55473: STR
55474: PUSH
55475: LD_VAR 0 3
55479: PPUSH
55480: CALL_OW 254
55484: STR
55485: PUSH
55486: LD_STRING , 
55488: STR
55489: PUSH
55490: LD_VAR 0 3
55494: PPUSH
55495: LD_INT 1
55497: PPUSH
55498: CALL_OW 268
55502: STR
55503: PUSH
55504: LD_STRING , 
55506: STR
55507: PUSH
55508: LD_VAR 0 3
55512: PPUSH
55513: LD_INT 2
55515: PPUSH
55516: CALL_OW 268
55520: STR
55521: PUSH
55522: LD_STRING ],
55524: STR
55525: PPUSH
55526: CALL_OW 561
// end ;
55530: GO 55424
55532: POP
55533: POP
// AddToLog ( ]; ) ;
55534: LD_STRING ];
55536: PPUSH
55537: CALL_OW 561
// end ;
55541: LD_VAR 0 2
55545: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55546: LD_INT 0
55548: PPUSH
55549: PPUSH
55550: PPUSH
55551: PPUSH
55552: PPUSH
// if not area or not rate or not max then
55553: LD_VAR 0 1
55557: NOT
55558: PUSH
55559: LD_VAR 0 2
55563: NOT
55564: OR
55565: PUSH
55566: LD_VAR 0 4
55570: NOT
55571: OR
55572: IFFALSE 55576
// exit ;
55574: GO 55768
// while 1 do
55576: LD_INT 1
55578: IFFALSE 55768
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55580: LD_ADDR_VAR 0 9
55584: PUSH
55585: LD_VAR 0 1
55589: PPUSH
55590: LD_INT 1
55592: PPUSH
55593: CALL_OW 287
55597: PUSH
55598: LD_INT 10
55600: MUL
55601: ST_TO_ADDR
// r := rate / 10 ;
55602: LD_ADDR_VAR 0 7
55606: PUSH
55607: LD_VAR 0 2
55611: PUSH
55612: LD_INT 10
55614: DIVREAL
55615: ST_TO_ADDR
// time := 1 1$00 ;
55616: LD_ADDR_VAR 0 8
55620: PUSH
55621: LD_INT 2100
55623: ST_TO_ADDR
// if amount < min then
55624: LD_VAR 0 9
55628: PUSH
55629: LD_VAR 0 3
55633: LESS
55634: IFFALSE 55652
// r := r * 2 else
55636: LD_ADDR_VAR 0 7
55640: PUSH
55641: LD_VAR 0 7
55645: PUSH
55646: LD_INT 2
55648: MUL
55649: ST_TO_ADDR
55650: GO 55678
// if amount > max then
55652: LD_VAR 0 9
55656: PUSH
55657: LD_VAR 0 4
55661: GREATER
55662: IFFALSE 55678
// r := r / 2 ;
55664: LD_ADDR_VAR 0 7
55668: PUSH
55669: LD_VAR 0 7
55673: PUSH
55674: LD_INT 2
55676: DIVREAL
55677: ST_TO_ADDR
// time := time / r ;
55678: LD_ADDR_VAR 0 8
55682: PUSH
55683: LD_VAR 0 8
55687: PUSH
55688: LD_VAR 0 7
55692: DIVREAL
55693: ST_TO_ADDR
// if time < 0 then
55694: LD_VAR 0 8
55698: PUSH
55699: LD_INT 0
55701: LESS
55702: IFFALSE 55719
// time := time * - 1 ;
55704: LD_ADDR_VAR 0 8
55708: PUSH
55709: LD_VAR 0 8
55713: PUSH
55714: LD_INT 1
55716: NEG
55717: MUL
55718: ST_TO_ADDR
// wait ( time ) ;
55719: LD_VAR 0 8
55723: PPUSH
55724: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55728: LD_INT 35
55730: PPUSH
55731: LD_INT 875
55733: PPUSH
55734: CALL_OW 12
55738: PPUSH
55739: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55743: LD_INT 1
55745: PPUSH
55746: LD_INT 5
55748: PPUSH
55749: CALL_OW 12
55753: PPUSH
55754: LD_VAR 0 1
55758: PPUSH
55759: LD_INT 1
55761: PPUSH
55762: CALL_OW 55
// end ;
55766: GO 55576
// end ;
55768: LD_VAR 0 5
55772: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55773: LD_INT 0
55775: PPUSH
55776: PPUSH
55777: PPUSH
55778: PPUSH
55779: PPUSH
55780: PPUSH
55781: PPUSH
55782: PPUSH
// if not turrets or not factories then
55783: LD_VAR 0 1
55787: NOT
55788: PUSH
55789: LD_VAR 0 2
55793: NOT
55794: OR
55795: IFFALSE 55799
// exit ;
55797: GO 56106
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55799: LD_ADDR_VAR 0 10
55803: PUSH
55804: LD_INT 5
55806: PUSH
55807: LD_INT 6
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: LD_INT 2
55816: PUSH
55817: LD_INT 4
55819: PUSH
55820: EMPTY
55821: LIST
55822: LIST
55823: PUSH
55824: LD_INT 3
55826: PUSH
55827: LD_INT 5
55829: PUSH
55830: EMPTY
55831: LIST
55832: LIST
55833: PUSH
55834: EMPTY
55835: LIST
55836: LIST
55837: LIST
55838: PUSH
55839: LD_INT 24
55841: PUSH
55842: LD_INT 25
55844: PUSH
55845: EMPTY
55846: LIST
55847: LIST
55848: PUSH
55849: LD_INT 23
55851: PUSH
55852: LD_INT 27
55854: PUSH
55855: EMPTY
55856: LIST
55857: LIST
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: PUSH
55863: LD_INT 42
55865: PUSH
55866: LD_INT 43
55868: PUSH
55869: EMPTY
55870: LIST
55871: LIST
55872: PUSH
55873: LD_INT 44
55875: PUSH
55876: LD_INT 46
55878: PUSH
55879: EMPTY
55880: LIST
55881: LIST
55882: PUSH
55883: LD_INT 45
55885: PUSH
55886: LD_INT 47
55888: PUSH
55889: EMPTY
55890: LIST
55891: LIST
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: LIST
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: LIST
55902: ST_TO_ADDR
// result := [ ] ;
55903: LD_ADDR_VAR 0 3
55907: PUSH
55908: EMPTY
55909: ST_TO_ADDR
// for i in turrets do
55910: LD_ADDR_VAR 0 4
55914: PUSH
55915: LD_VAR 0 1
55919: PUSH
55920: FOR_IN
55921: IFFALSE 56104
// begin nat := GetNation ( i ) ;
55923: LD_ADDR_VAR 0 7
55927: PUSH
55928: LD_VAR 0 4
55932: PPUSH
55933: CALL_OW 248
55937: ST_TO_ADDR
// weapon := 0 ;
55938: LD_ADDR_VAR 0 8
55942: PUSH
55943: LD_INT 0
55945: ST_TO_ADDR
// if not nat then
55946: LD_VAR 0 7
55950: NOT
55951: IFFALSE 55955
// continue ;
55953: GO 55920
// for j in list [ nat ] do
55955: LD_ADDR_VAR 0 5
55959: PUSH
55960: LD_VAR 0 10
55964: PUSH
55965: LD_VAR 0 7
55969: ARRAY
55970: PUSH
55971: FOR_IN
55972: IFFALSE 56013
// if GetBWeapon ( i ) = j [ 1 ] then
55974: LD_VAR 0 4
55978: PPUSH
55979: CALL_OW 269
55983: PUSH
55984: LD_VAR 0 5
55988: PUSH
55989: LD_INT 1
55991: ARRAY
55992: EQUAL
55993: IFFALSE 56011
// begin weapon := j [ 2 ] ;
55995: LD_ADDR_VAR 0 8
55999: PUSH
56000: LD_VAR 0 5
56004: PUSH
56005: LD_INT 2
56007: ARRAY
56008: ST_TO_ADDR
// break ;
56009: GO 56013
// end ;
56011: GO 55971
56013: POP
56014: POP
// if not weapon then
56015: LD_VAR 0 8
56019: NOT
56020: IFFALSE 56024
// continue ;
56022: GO 55920
// for k in factories do
56024: LD_ADDR_VAR 0 6
56028: PUSH
56029: LD_VAR 0 2
56033: PUSH
56034: FOR_IN
56035: IFFALSE 56100
// begin weapons := AvailableWeaponList ( k ) ;
56037: LD_ADDR_VAR 0 9
56041: PUSH
56042: LD_VAR 0 6
56046: PPUSH
56047: CALL_OW 478
56051: ST_TO_ADDR
// if not weapons then
56052: LD_VAR 0 9
56056: NOT
56057: IFFALSE 56061
// continue ;
56059: GO 56034
// if weapon in weapons then
56061: LD_VAR 0 8
56065: PUSH
56066: LD_VAR 0 9
56070: IN
56071: IFFALSE 56098
// begin result := [ i , weapon ] ;
56073: LD_ADDR_VAR 0 3
56077: PUSH
56078: LD_VAR 0 4
56082: PUSH
56083: LD_VAR 0 8
56087: PUSH
56088: EMPTY
56089: LIST
56090: LIST
56091: ST_TO_ADDR
// exit ;
56092: POP
56093: POP
56094: POP
56095: POP
56096: GO 56106
// end ; end ;
56098: GO 56034
56100: POP
56101: POP
// end ;
56102: GO 55920
56104: POP
56105: POP
// end ;
56106: LD_VAR 0 3
56110: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56111: LD_INT 0
56113: PPUSH
// if not side or side > 8 then
56114: LD_VAR 0 3
56118: NOT
56119: PUSH
56120: LD_VAR 0 3
56124: PUSH
56125: LD_INT 8
56127: GREATER
56128: OR
56129: IFFALSE 56133
// exit ;
56131: GO 56192
// if not range then
56133: LD_VAR 0 4
56137: NOT
56138: IFFALSE 56149
// range := - 12 ;
56140: LD_ADDR_VAR 0 4
56144: PUSH
56145: LD_INT 12
56147: NEG
56148: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56149: LD_VAR 0 1
56153: PPUSH
56154: LD_VAR 0 2
56158: PPUSH
56159: LD_VAR 0 3
56163: PPUSH
56164: LD_VAR 0 4
56168: PPUSH
56169: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56173: LD_VAR 0 1
56177: PPUSH
56178: LD_VAR 0 2
56182: PPUSH
56183: LD_VAR 0 3
56187: PPUSH
56188: CALL_OW 331
// end ;
56192: LD_VAR 0 5
56196: RET
// export function Video ( mode ) ; begin
56197: LD_INT 0
56199: PPUSH
// ingame_video = mode ;
56200: LD_ADDR_OWVAR 52
56204: PUSH
56205: LD_VAR 0 1
56209: ST_TO_ADDR
// interface_hidden = mode ;
56210: LD_ADDR_OWVAR 54
56214: PUSH
56215: LD_VAR 0 1
56219: ST_TO_ADDR
// end ;
56220: LD_VAR 0 2
56224: RET
// export function Join ( array , element ) ; begin
56225: LD_INT 0
56227: PPUSH
// result := array ^ element ;
56228: LD_ADDR_VAR 0 3
56232: PUSH
56233: LD_VAR 0 1
56237: PUSH
56238: LD_VAR 0 2
56242: ADD
56243: ST_TO_ADDR
// end ;
56244: LD_VAR 0 3
56248: RET
// export function JoinUnion ( array , element ) ; begin
56249: LD_INT 0
56251: PPUSH
// result := array union element ;
56252: LD_ADDR_VAR 0 3
56256: PUSH
56257: LD_VAR 0 1
56261: PUSH
56262: LD_VAR 0 2
56266: UNION
56267: ST_TO_ADDR
// end ;
56268: LD_VAR 0 3
56272: RET
// export function GetBehemoths ( side ) ; begin
56273: LD_INT 0
56275: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56276: LD_ADDR_VAR 0 2
56280: PUSH
56281: LD_INT 22
56283: PUSH
56284: LD_VAR 0 1
56288: PUSH
56289: EMPTY
56290: LIST
56291: LIST
56292: PUSH
56293: LD_INT 31
56295: PUSH
56296: LD_INT 25
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: PPUSH
56307: CALL_OW 69
56311: ST_TO_ADDR
// end ;
56312: LD_VAR 0 2
56316: RET
// export function Shuffle ( array ) ; var i , index ; begin
56317: LD_INT 0
56319: PPUSH
56320: PPUSH
56321: PPUSH
// result := [ ] ;
56322: LD_ADDR_VAR 0 2
56326: PUSH
56327: EMPTY
56328: ST_TO_ADDR
// if not array then
56329: LD_VAR 0 1
56333: NOT
56334: IFFALSE 56338
// exit ;
56336: GO 56437
// Randomize ;
56338: CALL_OW 10
// for i = array downto 1 do
56342: LD_ADDR_VAR 0 3
56346: PUSH
56347: DOUBLE
56348: LD_VAR 0 1
56352: INC
56353: ST_TO_ADDR
56354: LD_INT 1
56356: PUSH
56357: FOR_DOWNTO
56358: IFFALSE 56435
// begin index := rand ( 1 , array ) ;
56360: LD_ADDR_VAR 0 4
56364: PUSH
56365: LD_INT 1
56367: PPUSH
56368: LD_VAR 0 1
56372: PPUSH
56373: CALL_OW 12
56377: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56378: LD_ADDR_VAR 0 2
56382: PUSH
56383: LD_VAR 0 2
56387: PPUSH
56388: LD_VAR 0 2
56392: PUSH
56393: LD_INT 1
56395: PLUS
56396: PPUSH
56397: LD_VAR 0 1
56401: PUSH
56402: LD_VAR 0 4
56406: ARRAY
56407: PPUSH
56408: CALL_OW 2
56412: ST_TO_ADDR
// array := Delete ( array , index ) ;
56413: LD_ADDR_VAR 0 1
56417: PUSH
56418: LD_VAR 0 1
56422: PPUSH
56423: LD_VAR 0 4
56427: PPUSH
56428: CALL_OW 3
56432: ST_TO_ADDR
// end ;
56433: GO 56357
56435: POP
56436: POP
// end ; end_of_file
56437: LD_VAR 0 2
56441: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56442: LD_INT 0
56444: PPUSH
56445: PPUSH
// skirmish := false ;
56446: LD_ADDR_EXP 56
56450: PUSH
56451: LD_INT 0
56453: ST_TO_ADDR
// debug_mc := false ;
56454: LD_ADDR_EXP 57
56458: PUSH
56459: LD_INT 0
56461: ST_TO_ADDR
// mc_bases := [ ] ;
56462: LD_ADDR_EXP 58
56466: PUSH
56467: EMPTY
56468: ST_TO_ADDR
// mc_sides := [ ] ;
56469: LD_ADDR_EXP 84
56473: PUSH
56474: EMPTY
56475: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56476: LD_ADDR_EXP 59
56480: PUSH
56481: EMPTY
56482: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56483: LD_ADDR_EXP 60
56487: PUSH
56488: EMPTY
56489: ST_TO_ADDR
// mc_need_heal := [ ] ;
56490: LD_ADDR_EXP 61
56494: PUSH
56495: EMPTY
56496: ST_TO_ADDR
// mc_healers := [ ] ;
56497: LD_ADDR_EXP 62
56501: PUSH
56502: EMPTY
56503: ST_TO_ADDR
// mc_build_list := [ ] ;
56504: LD_ADDR_EXP 63
56508: PUSH
56509: EMPTY
56510: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56511: LD_ADDR_EXP 90
56515: PUSH
56516: EMPTY
56517: ST_TO_ADDR
// mc_builders := [ ] ;
56518: LD_ADDR_EXP 64
56522: PUSH
56523: EMPTY
56524: ST_TO_ADDR
// mc_construct_list := [ ] ;
56525: LD_ADDR_EXP 65
56529: PUSH
56530: EMPTY
56531: ST_TO_ADDR
// mc_turret_list := [ ] ;
56532: LD_ADDR_EXP 66
56536: PUSH
56537: EMPTY
56538: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56539: LD_ADDR_EXP 67
56543: PUSH
56544: EMPTY
56545: ST_TO_ADDR
// mc_miners := [ ] ;
56546: LD_ADDR_EXP 72
56550: PUSH
56551: EMPTY
56552: ST_TO_ADDR
// mc_mines := [ ] ;
56553: LD_ADDR_EXP 71
56557: PUSH
56558: EMPTY
56559: ST_TO_ADDR
// mc_minefields := [ ] ;
56560: LD_ADDR_EXP 73
56564: PUSH
56565: EMPTY
56566: ST_TO_ADDR
// mc_crates := [ ] ;
56567: LD_ADDR_EXP 74
56571: PUSH
56572: EMPTY
56573: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56574: LD_ADDR_EXP 75
56578: PUSH
56579: EMPTY
56580: ST_TO_ADDR
// mc_crates_area := [ ] ;
56581: LD_ADDR_EXP 76
56585: PUSH
56586: EMPTY
56587: ST_TO_ADDR
// mc_vehicles := [ ] ;
56588: LD_ADDR_EXP 77
56592: PUSH
56593: EMPTY
56594: ST_TO_ADDR
// mc_attack := [ ] ;
56595: LD_ADDR_EXP 78
56599: PUSH
56600: EMPTY
56601: ST_TO_ADDR
// mc_produce := [ ] ;
56602: LD_ADDR_EXP 79
56606: PUSH
56607: EMPTY
56608: ST_TO_ADDR
// mc_defender := [ ] ;
56609: LD_ADDR_EXP 80
56613: PUSH
56614: EMPTY
56615: ST_TO_ADDR
// mc_parking := [ ] ;
56616: LD_ADDR_EXP 82
56620: PUSH
56621: EMPTY
56622: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56623: LD_ADDR_EXP 68
56627: PUSH
56628: EMPTY
56629: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56630: LD_ADDR_EXP 70
56634: PUSH
56635: EMPTY
56636: ST_TO_ADDR
// mc_scan := [ ] ;
56637: LD_ADDR_EXP 81
56641: PUSH
56642: EMPTY
56643: ST_TO_ADDR
// mc_scan_area := [ ] ;
56644: LD_ADDR_EXP 83
56648: PUSH
56649: EMPTY
56650: ST_TO_ADDR
// mc_tech := [ ] ;
56651: LD_ADDR_EXP 85
56655: PUSH
56656: EMPTY
56657: ST_TO_ADDR
// mc_class := [ ] ;
56658: LD_ADDR_EXP 99
56662: PUSH
56663: EMPTY
56664: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56665: LD_ADDR_EXP 100
56669: PUSH
56670: EMPTY
56671: ST_TO_ADDR
// end ;
56672: LD_VAR 0 1
56676: RET
// export function MC_Kill ( base ) ; begin
56677: LD_INT 0
56679: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56680: LD_ADDR_EXP 58
56684: PUSH
56685: LD_EXP 58
56689: PPUSH
56690: LD_VAR 0 1
56694: PPUSH
56695: EMPTY
56696: PPUSH
56697: CALL_OW 1
56701: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56702: LD_ADDR_EXP 59
56706: PUSH
56707: LD_EXP 59
56711: PPUSH
56712: LD_VAR 0 1
56716: PPUSH
56717: EMPTY
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56724: LD_ADDR_EXP 60
56728: PUSH
56729: LD_EXP 60
56733: PPUSH
56734: LD_VAR 0 1
56738: PPUSH
56739: EMPTY
56740: PPUSH
56741: CALL_OW 1
56745: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56746: LD_ADDR_EXP 61
56750: PUSH
56751: LD_EXP 61
56755: PPUSH
56756: LD_VAR 0 1
56760: PPUSH
56761: EMPTY
56762: PPUSH
56763: CALL_OW 1
56767: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56768: LD_ADDR_EXP 62
56772: PUSH
56773: LD_EXP 62
56777: PPUSH
56778: LD_VAR 0 1
56782: PPUSH
56783: EMPTY
56784: PPUSH
56785: CALL_OW 1
56789: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56790: LD_ADDR_EXP 63
56794: PUSH
56795: LD_EXP 63
56799: PPUSH
56800: LD_VAR 0 1
56804: PPUSH
56805: EMPTY
56806: PPUSH
56807: CALL_OW 1
56811: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56812: LD_ADDR_EXP 64
56816: PUSH
56817: LD_EXP 64
56821: PPUSH
56822: LD_VAR 0 1
56826: PPUSH
56827: EMPTY
56828: PPUSH
56829: CALL_OW 1
56833: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56834: LD_ADDR_EXP 65
56838: PUSH
56839: LD_EXP 65
56843: PPUSH
56844: LD_VAR 0 1
56848: PPUSH
56849: EMPTY
56850: PPUSH
56851: CALL_OW 1
56855: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56856: LD_ADDR_EXP 66
56860: PUSH
56861: LD_EXP 66
56865: PPUSH
56866: LD_VAR 0 1
56870: PPUSH
56871: EMPTY
56872: PPUSH
56873: CALL_OW 1
56877: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56878: LD_ADDR_EXP 67
56882: PUSH
56883: LD_EXP 67
56887: PPUSH
56888: LD_VAR 0 1
56892: PPUSH
56893: EMPTY
56894: PPUSH
56895: CALL_OW 1
56899: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56900: LD_ADDR_EXP 68
56904: PUSH
56905: LD_EXP 68
56909: PPUSH
56910: LD_VAR 0 1
56914: PPUSH
56915: EMPTY
56916: PPUSH
56917: CALL_OW 1
56921: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56922: LD_ADDR_EXP 69
56926: PUSH
56927: LD_EXP 69
56931: PPUSH
56932: LD_VAR 0 1
56936: PPUSH
56937: LD_INT 0
56939: PPUSH
56940: CALL_OW 1
56944: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56945: LD_ADDR_EXP 70
56949: PUSH
56950: LD_EXP 70
56954: PPUSH
56955: LD_VAR 0 1
56959: PPUSH
56960: EMPTY
56961: PPUSH
56962: CALL_OW 1
56966: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56967: LD_ADDR_EXP 71
56971: PUSH
56972: LD_EXP 71
56976: PPUSH
56977: LD_VAR 0 1
56981: PPUSH
56982: EMPTY
56983: PPUSH
56984: CALL_OW 1
56988: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56989: LD_ADDR_EXP 72
56993: PUSH
56994: LD_EXP 72
56998: PPUSH
56999: LD_VAR 0 1
57003: PPUSH
57004: EMPTY
57005: PPUSH
57006: CALL_OW 1
57010: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57011: LD_ADDR_EXP 73
57015: PUSH
57016: LD_EXP 73
57020: PPUSH
57021: LD_VAR 0 1
57025: PPUSH
57026: EMPTY
57027: PPUSH
57028: CALL_OW 1
57032: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57033: LD_ADDR_EXP 74
57037: PUSH
57038: LD_EXP 74
57042: PPUSH
57043: LD_VAR 0 1
57047: PPUSH
57048: EMPTY
57049: PPUSH
57050: CALL_OW 1
57054: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57055: LD_ADDR_EXP 75
57059: PUSH
57060: LD_EXP 75
57064: PPUSH
57065: LD_VAR 0 1
57069: PPUSH
57070: EMPTY
57071: PPUSH
57072: CALL_OW 1
57076: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57077: LD_ADDR_EXP 76
57081: PUSH
57082: LD_EXP 76
57086: PPUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: EMPTY
57093: PPUSH
57094: CALL_OW 1
57098: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57099: LD_ADDR_EXP 77
57103: PUSH
57104: LD_EXP 77
57108: PPUSH
57109: LD_VAR 0 1
57113: PPUSH
57114: EMPTY
57115: PPUSH
57116: CALL_OW 1
57120: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57121: LD_ADDR_EXP 78
57125: PUSH
57126: LD_EXP 78
57130: PPUSH
57131: LD_VAR 0 1
57135: PPUSH
57136: EMPTY
57137: PPUSH
57138: CALL_OW 1
57142: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57143: LD_ADDR_EXP 79
57147: PUSH
57148: LD_EXP 79
57152: PPUSH
57153: LD_VAR 0 1
57157: PPUSH
57158: EMPTY
57159: PPUSH
57160: CALL_OW 1
57164: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57165: LD_ADDR_EXP 80
57169: PUSH
57170: LD_EXP 80
57174: PPUSH
57175: LD_VAR 0 1
57179: PPUSH
57180: EMPTY
57181: PPUSH
57182: CALL_OW 1
57186: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57187: LD_ADDR_EXP 81
57191: PUSH
57192: LD_EXP 81
57196: PPUSH
57197: LD_VAR 0 1
57201: PPUSH
57202: EMPTY
57203: PPUSH
57204: CALL_OW 1
57208: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57209: LD_ADDR_EXP 82
57213: PUSH
57214: LD_EXP 82
57218: PPUSH
57219: LD_VAR 0 1
57223: PPUSH
57224: EMPTY
57225: PPUSH
57226: CALL_OW 1
57230: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57231: LD_ADDR_EXP 83
57235: PUSH
57236: LD_EXP 83
57240: PPUSH
57241: LD_VAR 0 1
57245: PPUSH
57246: EMPTY
57247: PPUSH
57248: CALL_OW 1
57252: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57253: LD_ADDR_EXP 85
57257: PUSH
57258: LD_EXP 85
57262: PPUSH
57263: LD_VAR 0 1
57267: PPUSH
57268: EMPTY
57269: PPUSH
57270: CALL_OW 1
57274: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57275: LD_ADDR_EXP 87
57279: PUSH
57280: LD_EXP 87
57284: PPUSH
57285: LD_VAR 0 1
57289: PPUSH
57290: EMPTY
57291: PPUSH
57292: CALL_OW 1
57296: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57297: LD_ADDR_EXP 88
57301: PUSH
57302: LD_EXP 88
57306: PPUSH
57307: LD_VAR 0 1
57311: PPUSH
57312: EMPTY
57313: PPUSH
57314: CALL_OW 1
57318: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57319: LD_ADDR_EXP 89
57323: PUSH
57324: LD_EXP 89
57328: PPUSH
57329: LD_VAR 0 1
57333: PPUSH
57334: EMPTY
57335: PPUSH
57336: CALL_OW 1
57340: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57341: LD_ADDR_EXP 90
57345: PUSH
57346: LD_EXP 90
57350: PPUSH
57351: LD_VAR 0 1
57355: PPUSH
57356: EMPTY
57357: PPUSH
57358: CALL_OW 1
57362: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57363: LD_ADDR_EXP 91
57367: PUSH
57368: LD_EXP 91
57372: PPUSH
57373: LD_VAR 0 1
57377: PPUSH
57378: EMPTY
57379: PPUSH
57380: CALL_OW 1
57384: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57385: LD_ADDR_EXP 92
57389: PUSH
57390: LD_EXP 92
57394: PPUSH
57395: LD_VAR 0 1
57399: PPUSH
57400: EMPTY
57401: PPUSH
57402: CALL_OW 1
57406: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57407: LD_ADDR_EXP 93
57411: PUSH
57412: LD_EXP 93
57416: PPUSH
57417: LD_VAR 0 1
57421: PPUSH
57422: EMPTY
57423: PPUSH
57424: CALL_OW 1
57428: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57429: LD_ADDR_EXP 94
57433: PUSH
57434: LD_EXP 94
57438: PPUSH
57439: LD_VAR 0 1
57443: PPUSH
57444: EMPTY
57445: PPUSH
57446: CALL_OW 1
57450: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57451: LD_ADDR_EXP 95
57455: PUSH
57456: LD_EXP 95
57460: PPUSH
57461: LD_VAR 0 1
57465: PPUSH
57466: EMPTY
57467: PPUSH
57468: CALL_OW 1
57472: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57473: LD_ADDR_EXP 96
57477: PUSH
57478: LD_EXP 96
57482: PPUSH
57483: LD_VAR 0 1
57487: PPUSH
57488: EMPTY
57489: PPUSH
57490: CALL_OW 1
57494: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57495: LD_ADDR_EXP 97
57499: PUSH
57500: LD_EXP 97
57504: PPUSH
57505: LD_VAR 0 1
57509: PPUSH
57510: EMPTY
57511: PPUSH
57512: CALL_OW 1
57516: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57517: LD_ADDR_EXP 98
57521: PUSH
57522: LD_EXP 98
57526: PPUSH
57527: LD_VAR 0 1
57531: PPUSH
57532: EMPTY
57533: PPUSH
57534: CALL_OW 1
57538: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57539: LD_ADDR_EXP 99
57543: PUSH
57544: LD_EXP 99
57548: PPUSH
57549: LD_VAR 0 1
57553: PPUSH
57554: EMPTY
57555: PPUSH
57556: CALL_OW 1
57560: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57561: LD_ADDR_EXP 100
57565: PUSH
57566: LD_EXP 100
57570: PPUSH
57571: LD_VAR 0 1
57575: PPUSH
57576: LD_INT 0
57578: PPUSH
57579: CALL_OW 1
57583: ST_TO_ADDR
// end ;
57584: LD_VAR 0 2
57588: RET
// export function MC_Start ( ) ; var i ; begin
57589: LD_INT 0
57591: PPUSH
57592: PPUSH
// for i = 1 to mc_bases do
57593: LD_ADDR_VAR 0 2
57597: PUSH
57598: DOUBLE
57599: LD_INT 1
57601: DEC
57602: ST_TO_ADDR
57603: LD_EXP 58
57607: PUSH
57608: FOR_TO
57609: IFFALSE 58686
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57611: LD_ADDR_EXP 58
57615: PUSH
57616: LD_EXP 58
57620: PPUSH
57621: LD_VAR 0 2
57625: PPUSH
57626: LD_EXP 58
57630: PUSH
57631: LD_VAR 0 2
57635: ARRAY
57636: PUSH
57637: LD_INT 0
57639: DIFF
57640: PPUSH
57641: CALL_OW 1
57645: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57646: LD_ADDR_EXP 59
57650: PUSH
57651: LD_EXP 59
57655: PPUSH
57656: LD_VAR 0 2
57660: PPUSH
57661: EMPTY
57662: PPUSH
57663: CALL_OW 1
57667: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57668: LD_ADDR_EXP 60
57672: PUSH
57673: LD_EXP 60
57677: PPUSH
57678: LD_VAR 0 2
57682: PPUSH
57683: EMPTY
57684: PPUSH
57685: CALL_OW 1
57689: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57690: LD_ADDR_EXP 61
57694: PUSH
57695: LD_EXP 61
57699: PPUSH
57700: LD_VAR 0 2
57704: PPUSH
57705: EMPTY
57706: PPUSH
57707: CALL_OW 1
57711: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57712: LD_ADDR_EXP 62
57716: PUSH
57717: LD_EXP 62
57721: PPUSH
57722: LD_VAR 0 2
57726: PPUSH
57727: EMPTY
57728: PUSH
57729: EMPTY
57730: PUSH
57731: EMPTY
57732: LIST
57733: LIST
57734: PPUSH
57735: CALL_OW 1
57739: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57740: LD_ADDR_EXP 63
57744: PUSH
57745: LD_EXP 63
57749: PPUSH
57750: LD_VAR 0 2
57754: PPUSH
57755: EMPTY
57756: PPUSH
57757: CALL_OW 1
57761: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57762: LD_ADDR_EXP 90
57766: PUSH
57767: LD_EXP 90
57771: PPUSH
57772: LD_VAR 0 2
57776: PPUSH
57777: EMPTY
57778: PPUSH
57779: CALL_OW 1
57783: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57784: LD_ADDR_EXP 64
57788: PUSH
57789: LD_EXP 64
57793: PPUSH
57794: LD_VAR 0 2
57798: PPUSH
57799: EMPTY
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57806: LD_ADDR_EXP 65
57810: PUSH
57811: LD_EXP 65
57815: PPUSH
57816: LD_VAR 0 2
57820: PPUSH
57821: EMPTY
57822: PPUSH
57823: CALL_OW 1
57827: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57828: LD_ADDR_EXP 66
57832: PUSH
57833: LD_EXP 66
57837: PPUSH
57838: LD_VAR 0 2
57842: PPUSH
57843: LD_EXP 58
57847: PUSH
57848: LD_VAR 0 2
57852: ARRAY
57853: PPUSH
57854: LD_INT 2
57856: PUSH
57857: LD_INT 30
57859: PUSH
57860: LD_INT 32
57862: PUSH
57863: EMPTY
57864: LIST
57865: LIST
57866: PUSH
57867: LD_INT 30
57869: PUSH
57870: LD_INT 33
57872: PUSH
57873: EMPTY
57874: LIST
57875: LIST
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: LIST
57881: PPUSH
57882: CALL_OW 72
57886: PPUSH
57887: CALL_OW 1
57891: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57892: LD_ADDR_EXP 67
57896: PUSH
57897: LD_EXP 67
57901: PPUSH
57902: LD_VAR 0 2
57906: PPUSH
57907: LD_EXP 58
57911: PUSH
57912: LD_VAR 0 2
57916: ARRAY
57917: PPUSH
57918: LD_INT 2
57920: PUSH
57921: LD_INT 30
57923: PUSH
57924: LD_INT 32
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: PUSH
57931: LD_INT 30
57933: PUSH
57934: LD_INT 31
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: PUSH
57941: EMPTY
57942: LIST
57943: LIST
57944: LIST
57945: PUSH
57946: LD_INT 58
57948: PUSH
57949: EMPTY
57950: LIST
57951: PUSH
57952: EMPTY
57953: LIST
57954: LIST
57955: PPUSH
57956: CALL_OW 72
57960: PPUSH
57961: CALL_OW 1
57965: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57966: LD_ADDR_EXP 68
57970: PUSH
57971: LD_EXP 68
57975: PPUSH
57976: LD_VAR 0 2
57980: PPUSH
57981: EMPTY
57982: PPUSH
57983: CALL_OW 1
57987: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57988: LD_ADDR_EXP 72
57992: PUSH
57993: LD_EXP 72
57997: PPUSH
57998: LD_VAR 0 2
58002: PPUSH
58003: EMPTY
58004: PPUSH
58005: CALL_OW 1
58009: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58010: LD_ADDR_EXP 71
58014: PUSH
58015: LD_EXP 71
58019: PPUSH
58020: LD_VAR 0 2
58024: PPUSH
58025: EMPTY
58026: PPUSH
58027: CALL_OW 1
58031: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58032: LD_ADDR_EXP 73
58036: PUSH
58037: LD_EXP 73
58041: PPUSH
58042: LD_VAR 0 2
58046: PPUSH
58047: EMPTY
58048: PPUSH
58049: CALL_OW 1
58053: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58054: LD_ADDR_EXP 74
58058: PUSH
58059: LD_EXP 74
58063: PPUSH
58064: LD_VAR 0 2
58068: PPUSH
58069: EMPTY
58070: PPUSH
58071: CALL_OW 1
58075: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58076: LD_ADDR_EXP 75
58080: PUSH
58081: LD_EXP 75
58085: PPUSH
58086: LD_VAR 0 2
58090: PPUSH
58091: EMPTY
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
58098: LD_ADDR_EXP 76
58102: PUSH
58103: LD_EXP 76
58107: PPUSH
58108: LD_VAR 0 2
58112: PPUSH
58113: EMPTY
58114: PPUSH
58115: CALL_OW 1
58119: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
58120: LD_ADDR_EXP 77
58124: PUSH
58125: LD_EXP 77
58129: PPUSH
58130: LD_VAR 0 2
58134: PPUSH
58135: EMPTY
58136: PPUSH
58137: CALL_OW 1
58141: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
58142: LD_ADDR_EXP 78
58146: PUSH
58147: LD_EXP 78
58151: PPUSH
58152: LD_VAR 0 2
58156: PPUSH
58157: EMPTY
58158: PPUSH
58159: CALL_OW 1
58163: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
58164: LD_ADDR_EXP 79
58168: PUSH
58169: LD_EXP 79
58173: PPUSH
58174: LD_VAR 0 2
58178: PPUSH
58179: EMPTY
58180: PPUSH
58181: CALL_OW 1
58185: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58186: LD_ADDR_EXP 80
58190: PUSH
58191: LD_EXP 80
58195: PPUSH
58196: LD_VAR 0 2
58200: PPUSH
58201: EMPTY
58202: PPUSH
58203: CALL_OW 1
58207: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58208: LD_ADDR_EXP 69
58212: PUSH
58213: LD_EXP 69
58217: PPUSH
58218: LD_VAR 0 2
58222: PPUSH
58223: LD_INT 0
58225: PPUSH
58226: CALL_OW 1
58230: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58231: LD_ADDR_EXP 82
58235: PUSH
58236: LD_EXP 82
58240: PPUSH
58241: LD_VAR 0 2
58245: PPUSH
58246: LD_INT 0
58248: PPUSH
58249: CALL_OW 1
58253: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58254: LD_ADDR_EXP 70
58258: PUSH
58259: LD_EXP 70
58263: PPUSH
58264: LD_VAR 0 2
58268: PPUSH
58269: EMPTY
58270: PPUSH
58271: CALL_OW 1
58275: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58276: LD_ADDR_EXP 81
58280: PUSH
58281: LD_EXP 81
58285: PPUSH
58286: LD_VAR 0 2
58290: PPUSH
58291: LD_INT 0
58293: PPUSH
58294: CALL_OW 1
58298: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58299: LD_ADDR_EXP 83
58303: PUSH
58304: LD_EXP 83
58308: PPUSH
58309: LD_VAR 0 2
58313: PPUSH
58314: EMPTY
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58321: LD_ADDR_EXP 86
58325: PUSH
58326: LD_EXP 86
58330: PPUSH
58331: LD_VAR 0 2
58335: PPUSH
58336: LD_INT 0
58338: PPUSH
58339: CALL_OW 1
58343: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58344: LD_ADDR_EXP 87
58348: PUSH
58349: LD_EXP 87
58353: PPUSH
58354: LD_VAR 0 2
58358: PPUSH
58359: EMPTY
58360: PPUSH
58361: CALL_OW 1
58365: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58366: LD_ADDR_EXP 88
58370: PUSH
58371: LD_EXP 88
58375: PPUSH
58376: LD_VAR 0 2
58380: PPUSH
58381: EMPTY
58382: PPUSH
58383: CALL_OW 1
58387: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58388: LD_ADDR_EXP 89
58392: PUSH
58393: LD_EXP 89
58397: PPUSH
58398: LD_VAR 0 2
58402: PPUSH
58403: EMPTY
58404: PPUSH
58405: CALL_OW 1
58409: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58410: LD_ADDR_EXP 91
58414: PUSH
58415: LD_EXP 91
58419: PPUSH
58420: LD_VAR 0 2
58424: PPUSH
58425: LD_EXP 58
58429: PUSH
58430: LD_VAR 0 2
58434: ARRAY
58435: PPUSH
58436: LD_INT 2
58438: PUSH
58439: LD_INT 30
58441: PUSH
58442: LD_INT 6
58444: PUSH
58445: EMPTY
58446: LIST
58447: LIST
58448: PUSH
58449: LD_INT 30
58451: PUSH
58452: LD_INT 7
58454: PUSH
58455: EMPTY
58456: LIST
58457: LIST
58458: PUSH
58459: LD_INT 30
58461: PUSH
58462: LD_INT 8
58464: PUSH
58465: EMPTY
58466: LIST
58467: LIST
58468: PUSH
58469: EMPTY
58470: LIST
58471: LIST
58472: LIST
58473: LIST
58474: PPUSH
58475: CALL_OW 72
58479: PPUSH
58480: CALL_OW 1
58484: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58485: LD_ADDR_EXP 92
58489: PUSH
58490: LD_EXP 92
58494: PPUSH
58495: LD_VAR 0 2
58499: PPUSH
58500: EMPTY
58501: PPUSH
58502: CALL_OW 1
58506: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58507: LD_ADDR_EXP 93
58511: PUSH
58512: LD_EXP 93
58516: PPUSH
58517: LD_VAR 0 2
58521: PPUSH
58522: EMPTY
58523: PPUSH
58524: CALL_OW 1
58528: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58529: LD_ADDR_EXP 94
58533: PUSH
58534: LD_EXP 94
58538: PPUSH
58539: LD_VAR 0 2
58543: PPUSH
58544: EMPTY
58545: PPUSH
58546: CALL_OW 1
58550: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58551: LD_ADDR_EXP 95
58555: PUSH
58556: LD_EXP 95
58560: PPUSH
58561: LD_VAR 0 2
58565: PPUSH
58566: EMPTY
58567: PPUSH
58568: CALL_OW 1
58572: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58573: LD_ADDR_EXP 96
58577: PUSH
58578: LD_EXP 96
58582: PPUSH
58583: LD_VAR 0 2
58587: PPUSH
58588: EMPTY
58589: PPUSH
58590: CALL_OW 1
58594: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58595: LD_ADDR_EXP 97
58599: PUSH
58600: LD_EXP 97
58604: PPUSH
58605: LD_VAR 0 2
58609: PPUSH
58610: EMPTY
58611: PPUSH
58612: CALL_OW 1
58616: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58617: LD_ADDR_EXP 98
58621: PUSH
58622: LD_EXP 98
58626: PPUSH
58627: LD_VAR 0 2
58631: PPUSH
58632: EMPTY
58633: PPUSH
58634: CALL_OW 1
58638: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58639: LD_ADDR_EXP 99
58643: PUSH
58644: LD_EXP 99
58648: PPUSH
58649: LD_VAR 0 2
58653: PPUSH
58654: EMPTY
58655: PPUSH
58656: CALL_OW 1
58660: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58661: LD_ADDR_EXP 100
58665: PUSH
58666: LD_EXP 100
58670: PPUSH
58671: LD_VAR 0 2
58675: PPUSH
58676: LD_INT 0
58678: PPUSH
58679: CALL_OW 1
58683: ST_TO_ADDR
// end ;
58684: GO 57608
58686: POP
58687: POP
// MC_InitSides ( ) ;
58688: CALL 58974 0 0
// MC_InitResearch ( ) ;
58692: CALL 58713 0 0
// CustomInitMacro ( ) ;
58696: CALL 174 0 0
// skirmish := true ;
58700: LD_ADDR_EXP 56
58704: PUSH
58705: LD_INT 1
58707: ST_TO_ADDR
// end ;
58708: LD_VAR 0 1
58712: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58713: LD_INT 0
58715: PPUSH
58716: PPUSH
58717: PPUSH
58718: PPUSH
58719: PPUSH
58720: PPUSH
// if not mc_bases then
58721: LD_EXP 58
58725: NOT
58726: IFFALSE 58730
// exit ;
58728: GO 58969
// for i = 1 to 8 do
58730: LD_ADDR_VAR 0 2
58734: PUSH
58735: DOUBLE
58736: LD_INT 1
58738: DEC
58739: ST_TO_ADDR
58740: LD_INT 8
58742: PUSH
58743: FOR_TO
58744: IFFALSE 58770
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58746: LD_ADDR_EXP 85
58750: PUSH
58751: LD_EXP 85
58755: PPUSH
58756: LD_VAR 0 2
58760: PPUSH
58761: EMPTY
58762: PPUSH
58763: CALL_OW 1
58767: ST_TO_ADDR
58768: GO 58743
58770: POP
58771: POP
// tmp := [ ] ;
58772: LD_ADDR_VAR 0 5
58776: PUSH
58777: EMPTY
58778: ST_TO_ADDR
// for i = 1 to mc_sides do
58779: LD_ADDR_VAR 0 2
58783: PUSH
58784: DOUBLE
58785: LD_INT 1
58787: DEC
58788: ST_TO_ADDR
58789: LD_EXP 84
58793: PUSH
58794: FOR_TO
58795: IFFALSE 58853
// if not mc_sides [ i ] in tmp then
58797: LD_EXP 84
58801: PUSH
58802: LD_VAR 0 2
58806: ARRAY
58807: PUSH
58808: LD_VAR 0 5
58812: IN
58813: NOT
58814: IFFALSE 58851
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58816: LD_ADDR_VAR 0 5
58820: PUSH
58821: LD_VAR 0 5
58825: PPUSH
58826: LD_VAR 0 5
58830: PUSH
58831: LD_INT 1
58833: PLUS
58834: PPUSH
58835: LD_EXP 84
58839: PUSH
58840: LD_VAR 0 2
58844: ARRAY
58845: PPUSH
58846: CALL_OW 2
58850: ST_TO_ADDR
58851: GO 58794
58853: POP
58854: POP
// if not tmp then
58855: LD_VAR 0 5
58859: NOT
58860: IFFALSE 58864
// exit ;
58862: GO 58969
// for j in tmp do
58864: LD_ADDR_VAR 0 3
58868: PUSH
58869: LD_VAR 0 5
58873: PUSH
58874: FOR_IN
58875: IFFALSE 58967
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58877: LD_ADDR_VAR 0 6
58881: PUSH
58882: LD_INT 22
58884: PUSH
58885: LD_VAR 0 3
58889: PUSH
58890: EMPTY
58891: LIST
58892: LIST
58893: PPUSH
58894: CALL_OW 69
58898: ST_TO_ADDR
// if not un then
58899: LD_VAR 0 6
58903: NOT
58904: IFFALSE 58908
// continue ;
58906: GO 58874
// nation := GetNation ( un [ 1 ] ) ;
58908: LD_ADDR_VAR 0 4
58912: PUSH
58913: LD_VAR 0 6
58917: PUSH
58918: LD_INT 1
58920: ARRAY
58921: PPUSH
58922: CALL_OW 248
58926: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58927: LD_ADDR_EXP 85
58931: PUSH
58932: LD_EXP 85
58936: PPUSH
58937: LD_VAR 0 3
58941: PPUSH
58942: LD_VAR 0 3
58946: PPUSH
58947: LD_VAR 0 4
58951: PPUSH
58952: LD_INT 1
58954: PPUSH
58955: CALL 13973 0 3
58959: PPUSH
58960: CALL_OW 1
58964: ST_TO_ADDR
// end ;
58965: GO 58874
58967: POP
58968: POP
// end ;
58969: LD_VAR 0 1
58973: RET
// export function MC_InitSides ( ) ; var i ; begin
58974: LD_INT 0
58976: PPUSH
58977: PPUSH
// if not mc_bases then
58978: LD_EXP 58
58982: NOT
58983: IFFALSE 58987
// exit ;
58985: GO 59061
// for i = 1 to mc_bases do
58987: LD_ADDR_VAR 0 2
58991: PUSH
58992: DOUBLE
58993: LD_INT 1
58995: DEC
58996: ST_TO_ADDR
58997: LD_EXP 58
59001: PUSH
59002: FOR_TO
59003: IFFALSE 59059
// if mc_bases [ i ] then
59005: LD_EXP 58
59009: PUSH
59010: LD_VAR 0 2
59014: ARRAY
59015: IFFALSE 59057
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59017: LD_ADDR_EXP 84
59021: PUSH
59022: LD_EXP 84
59026: PPUSH
59027: LD_VAR 0 2
59031: PPUSH
59032: LD_EXP 58
59036: PUSH
59037: LD_VAR 0 2
59041: ARRAY
59042: PUSH
59043: LD_INT 1
59045: ARRAY
59046: PPUSH
59047: CALL_OW 255
59051: PPUSH
59052: CALL_OW 1
59056: ST_TO_ADDR
59057: GO 59002
59059: POP
59060: POP
// end ;
59061: LD_VAR 0 1
59065: RET
// every 0 0$01 trigger skirmish do
59066: LD_EXP 56
59070: IFFALSE 59224
59072: GO 59074
59074: DISABLE
// begin enable ;
59075: ENABLE
// MC_CheckBuildings ( ) ;
59076: CALL 63713 0 0
// MC_CheckPeopleLife ( ) ;
59080: CALL 63838 0 0
// RaiseSailEvent ( 100 ) ;
59084: LD_INT 100
59086: PPUSH
59087: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
59091: LD_INT 103
59093: PPUSH
59094: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
59098: LD_INT 104
59100: PPUSH
59101: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
59105: LD_INT 105
59107: PPUSH
59108: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
59112: LD_INT 106
59114: PPUSH
59115: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
59119: LD_INT 107
59121: PPUSH
59122: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
59126: LD_INT 108
59128: PPUSH
59129: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
59133: LD_INT 109
59135: PPUSH
59136: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
59140: LD_INT 110
59142: PPUSH
59143: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
59147: LD_INT 111
59149: PPUSH
59150: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
59154: LD_INT 112
59156: PPUSH
59157: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
59161: LD_INT 113
59163: PPUSH
59164: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59168: LD_INT 120
59170: PPUSH
59171: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59175: LD_INT 121
59177: PPUSH
59178: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59182: LD_INT 122
59184: PPUSH
59185: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59189: LD_INT 123
59191: PPUSH
59192: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59196: LD_INT 124
59198: PPUSH
59199: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59203: LD_INT 125
59205: PPUSH
59206: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59210: LD_INT 126
59212: PPUSH
59213: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59217: LD_INT 200
59219: PPUSH
59220: CALL_OW 427
// end ;
59224: END
// on SailEvent ( event ) do begin if event < 100 then
59225: LD_VAR 0 1
59229: PUSH
59230: LD_INT 100
59232: LESS
59233: IFFALSE 59244
// CustomEvent ( event ) ;
59235: LD_VAR 0 1
59239: PPUSH
59240: CALL 12687 0 1
// if event = 100 then
59244: LD_VAR 0 1
59248: PUSH
59249: LD_INT 100
59251: EQUAL
59252: IFFALSE 59258
// MC_ClassManager ( ) ;
59254: CALL 59650 0 0
// if event = 101 then
59258: LD_VAR 0 1
59262: PUSH
59263: LD_INT 101
59265: EQUAL
59266: IFFALSE 59272
// MC_RepairBuildings ( ) ;
59268: CALL 64434 0 0
// if event = 102 then
59272: LD_VAR 0 1
59276: PUSH
59277: LD_INT 102
59279: EQUAL
59280: IFFALSE 59286
// MC_Heal ( ) ;
59282: CALL 64840 0 0
// if event = 103 then
59286: LD_VAR 0 1
59290: PUSH
59291: LD_INT 103
59293: EQUAL
59294: IFFALSE 59300
// MC_Build ( ) ;
59296: CALL 65262 0 0
// if event = 104 then
59300: LD_VAR 0 1
59304: PUSH
59305: LD_INT 104
59307: EQUAL
59308: IFFALSE 59314
// MC_TurretWeapon ( ) ;
59310: CALL 66875 0 0
// if event = 105 then
59314: LD_VAR 0 1
59318: PUSH
59319: LD_INT 105
59321: EQUAL
59322: IFFALSE 59328
// MC_BuildUpgrade ( ) ;
59324: CALL 66426 0 0
// if event = 106 then
59328: LD_VAR 0 1
59332: PUSH
59333: LD_INT 106
59335: EQUAL
59336: IFFALSE 59342
// MC_PlantMines ( ) ;
59338: CALL 67305 0 0
// if event = 107 then
59342: LD_VAR 0 1
59346: PUSH
59347: LD_INT 107
59349: EQUAL
59350: IFFALSE 59356
// MC_CollectCrates ( ) ;
59352: CALL 68339 0 0
// if event = 108 then
59356: LD_VAR 0 1
59360: PUSH
59361: LD_INT 108
59363: EQUAL
59364: IFFALSE 59370
// MC_LinkRemoteControl ( ) ;
59366: CALL 70096 0 0
// if event = 109 then
59370: LD_VAR 0 1
59374: PUSH
59375: LD_INT 109
59377: EQUAL
59378: IFFALSE 59384
// MC_ProduceVehicle ( ) ;
59380: CALL 70277 0 0
// if event = 110 then
59384: LD_VAR 0 1
59388: PUSH
59389: LD_INT 110
59391: EQUAL
59392: IFFALSE 59398
// MC_SendAttack ( ) ;
59394: CALL 70758 0 0
// if event = 111 then
59398: LD_VAR 0 1
59402: PUSH
59403: LD_INT 111
59405: EQUAL
59406: IFFALSE 59412
// MC_Defend ( ) ;
59408: CALL 70866 0 0
// if event = 112 then
59412: LD_VAR 0 1
59416: PUSH
59417: LD_INT 112
59419: EQUAL
59420: IFFALSE 59426
// MC_Research ( ) ;
59422: CALL 71493 0 0
// if event = 113 then
59426: LD_VAR 0 1
59430: PUSH
59431: LD_INT 113
59433: EQUAL
59434: IFFALSE 59440
// MC_MinesTrigger ( ) ;
59436: CALL 72607 0 0
// if event = 120 then
59440: LD_VAR 0 1
59444: PUSH
59445: LD_INT 120
59447: EQUAL
59448: IFFALSE 59454
// MC_RepairVehicle ( ) ;
59450: CALL 72706 0 0
// if event = 121 then
59454: LD_VAR 0 1
59458: PUSH
59459: LD_INT 121
59461: EQUAL
59462: IFFALSE 59468
// MC_TameApe ( ) ;
59464: CALL 73449 0 0
// if event = 122 then
59468: LD_VAR 0 1
59472: PUSH
59473: LD_INT 122
59475: EQUAL
59476: IFFALSE 59482
// MC_ChangeApeClass ( ) ;
59478: CALL 74278 0 0
// if event = 123 then
59482: LD_VAR 0 1
59486: PUSH
59487: LD_INT 123
59489: EQUAL
59490: IFFALSE 59496
// MC_Bazooka ( ) ;
59492: CALL 74928 0 0
// if event = 124 then
59496: LD_VAR 0 1
59500: PUSH
59501: LD_INT 124
59503: EQUAL
59504: IFFALSE 59510
// MC_TeleportExit ( ) ;
59506: CALL 75126 0 0
// if event = 125 then
59510: LD_VAR 0 1
59514: PUSH
59515: LD_INT 125
59517: EQUAL
59518: IFFALSE 59524
// MC_Deposits ( ) ;
59520: CALL 75773 0 0
// if event = 126 then
59524: LD_VAR 0 1
59528: PUSH
59529: LD_INT 126
59531: EQUAL
59532: IFFALSE 59538
// MC_RemoteDriver ( ) ;
59534: CALL 76398 0 0
// if event = 200 then
59538: LD_VAR 0 1
59542: PUSH
59543: LD_INT 200
59545: EQUAL
59546: IFFALSE 59552
// MC_Idle ( ) ;
59548: CALL 78131 0 0
// end ;
59552: PPOPN 1
59554: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59555: LD_INT 0
59557: PPUSH
59558: PPUSH
// if not mc_bases [ base ] or not tag then
59559: LD_EXP 58
59563: PUSH
59564: LD_VAR 0 1
59568: ARRAY
59569: NOT
59570: PUSH
59571: LD_VAR 0 2
59575: NOT
59576: OR
59577: IFFALSE 59581
// exit ;
59579: GO 59645
// for i in mc_bases [ base ] union mc_ape [ base ] do
59581: LD_ADDR_VAR 0 4
59585: PUSH
59586: LD_EXP 58
59590: PUSH
59591: LD_VAR 0 1
59595: ARRAY
59596: PUSH
59597: LD_EXP 87
59601: PUSH
59602: LD_VAR 0 1
59606: ARRAY
59607: UNION
59608: PUSH
59609: FOR_IN
59610: IFFALSE 59643
// if GetTag ( i ) = tag then
59612: LD_VAR 0 4
59616: PPUSH
59617: CALL_OW 110
59621: PUSH
59622: LD_VAR 0 2
59626: EQUAL
59627: IFFALSE 59641
// SetTag ( i , 0 ) ;
59629: LD_VAR 0 4
59633: PPUSH
59634: LD_INT 0
59636: PPUSH
59637: CALL_OW 109
59641: GO 59609
59643: POP
59644: POP
// end ;
59645: LD_VAR 0 3
59649: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59650: LD_INT 0
59652: PPUSH
59653: PPUSH
59654: PPUSH
59655: PPUSH
59656: PPUSH
59657: PPUSH
59658: PPUSH
59659: PPUSH
// if not mc_bases then
59660: LD_EXP 58
59664: NOT
59665: IFFALSE 59669
// exit ;
59667: GO 60127
// for i = 1 to mc_bases do
59669: LD_ADDR_VAR 0 2
59673: PUSH
59674: DOUBLE
59675: LD_INT 1
59677: DEC
59678: ST_TO_ADDR
59679: LD_EXP 58
59683: PUSH
59684: FOR_TO
59685: IFFALSE 60125
// begin tmp := MC_ClassCheckReq ( i ) ;
59687: LD_ADDR_VAR 0 4
59691: PUSH
59692: LD_VAR 0 2
59696: PPUSH
59697: CALL 60132 0 1
59701: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59702: LD_ADDR_EXP 99
59706: PUSH
59707: LD_EXP 99
59711: PPUSH
59712: LD_VAR 0 2
59716: PPUSH
59717: LD_VAR 0 4
59721: PPUSH
59722: CALL_OW 1
59726: ST_TO_ADDR
// if not tmp then
59727: LD_VAR 0 4
59731: NOT
59732: IFFALSE 59736
// continue ;
59734: GO 59684
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59736: LD_ADDR_VAR 0 6
59740: PUSH
59741: LD_EXP 58
59745: PUSH
59746: LD_VAR 0 2
59750: ARRAY
59751: PPUSH
59752: LD_INT 2
59754: PUSH
59755: LD_INT 30
59757: PUSH
59758: LD_INT 4
59760: PUSH
59761: EMPTY
59762: LIST
59763: LIST
59764: PUSH
59765: LD_INT 30
59767: PUSH
59768: LD_INT 5
59770: PUSH
59771: EMPTY
59772: LIST
59773: LIST
59774: PUSH
59775: EMPTY
59776: LIST
59777: LIST
59778: LIST
59779: PPUSH
59780: CALL_OW 72
59784: PUSH
59785: LD_EXP 58
59789: PUSH
59790: LD_VAR 0 2
59794: ARRAY
59795: PPUSH
59796: LD_INT 2
59798: PUSH
59799: LD_INT 30
59801: PUSH
59802: LD_INT 0
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: PUSH
59809: LD_INT 30
59811: PUSH
59812: LD_INT 1
59814: PUSH
59815: EMPTY
59816: LIST
59817: LIST
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: LIST
59823: PPUSH
59824: CALL_OW 72
59828: PUSH
59829: LD_EXP 58
59833: PUSH
59834: LD_VAR 0 2
59838: ARRAY
59839: PPUSH
59840: LD_INT 30
59842: PUSH
59843: LD_INT 3
59845: PUSH
59846: EMPTY
59847: LIST
59848: LIST
59849: PPUSH
59850: CALL_OW 72
59854: PUSH
59855: LD_EXP 58
59859: PUSH
59860: LD_VAR 0 2
59864: ARRAY
59865: PPUSH
59866: LD_INT 2
59868: PUSH
59869: LD_INT 30
59871: PUSH
59872: LD_INT 6
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PUSH
59879: LD_INT 30
59881: PUSH
59882: LD_INT 7
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: LD_INT 30
59891: PUSH
59892: LD_INT 8
59894: PUSH
59895: EMPTY
59896: LIST
59897: LIST
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: LIST
59903: LIST
59904: PPUSH
59905: CALL_OW 72
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: LIST
59914: LIST
59915: ST_TO_ADDR
// for j = 1 to 4 do
59916: LD_ADDR_VAR 0 3
59920: PUSH
59921: DOUBLE
59922: LD_INT 1
59924: DEC
59925: ST_TO_ADDR
59926: LD_INT 4
59928: PUSH
59929: FOR_TO
59930: IFFALSE 60121
// begin if not tmp [ j ] then
59932: LD_VAR 0 4
59936: PUSH
59937: LD_VAR 0 3
59941: ARRAY
59942: NOT
59943: IFFALSE 59947
// continue ;
59945: GO 59929
// for p in tmp [ j ] do
59947: LD_ADDR_VAR 0 5
59951: PUSH
59952: LD_VAR 0 4
59956: PUSH
59957: LD_VAR 0 3
59961: ARRAY
59962: PUSH
59963: FOR_IN
59964: IFFALSE 60117
// begin if not b [ j ] then
59966: LD_VAR 0 6
59970: PUSH
59971: LD_VAR 0 3
59975: ARRAY
59976: NOT
59977: IFFALSE 59981
// break ;
59979: GO 60117
// e := 0 ;
59981: LD_ADDR_VAR 0 7
59985: PUSH
59986: LD_INT 0
59988: ST_TO_ADDR
// for k in b [ j ] do
59989: LD_ADDR_VAR 0 8
59993: PUSH
59994: LD_VAR 0 6
59998: PUSH
59999: LD_VAR 0 3
60003: ARRAY
60004: PUSH
60005: FOR_IN
60006: IFFALSE 60033
// if IsNotFull ( k ) then
60008: LD_VAR 0 8
60012: PPUSH
60013: CALL 17999 0 1
60017: IFFALSE 60031
// begin e := k ;
60019: LD_ADDR_VAR 0 7
60023: PUSH
60024: LD_VAR 0 8
60028: ST_TO_ADDR
// break ;
60029: GO 60033
// end ;
60031: GO 60005
60033: POP
60034: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60035: LD_VAR 0 7
60039: PUSH
60040: LD_VAR 0 5
60044: PPUSH
60045: LD_VAR 0 7
60049: PPUSH
60050: CALL 54987 0 2
60054: NOT
60055: AND
60056: IFFALSE 60115
// begin if IsInUnit ( p ) then
60058: LD_VAR 0 5
60062: PPUSH
60063: CALL_OW 310
60067: IFFALSE 60078
// ComExitBuilding ( p ) ;
60069: LD_VAR 0 5
60073: PPUSH
60074: CALL_OW 122
// ComEnterUnit ( p , e ) ;
60078: LD_VAR 0 5
60082: PPUSH
60083: LD_VAR 0 7
60087: PPUSH
60088: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
60092: LD_VAR 0 5
60096: PPUSH
60097: LD_VAR 0 3
60101: PPUSH
60102: CALL_OW 183
// AddComExitBuilding ( p ) ;
60106: LD_VAR 0 5
60110: PPUSH
60111: CALL_OW 182
// end ; end ;
60115: GO 59963
60117: POP
60118: POP
// end ;
60119: GO 59929
60121: POP
60122: POP
// end ;
60123: GO 59684
60125: POP
60126: POP
// end ;
60127: LD_VAR 0 1
60131: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
60132: LD_INT 0
60134: PPUSH
60135: PPUSH
60136: PPUSH
60137: PPUSH
60138: PPUSH
60139: PPUSH
60140: PPUSH
60141: PPUSH
60142: PPUSH
60143: PPUSH
60144: PPUSH
60145: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60146: LD_VAR 0 1
60150: NOT
60151: PUSH
60152: LD_EXP 58
60156: PUSH
60157: LD_VAR 0 1
60161: ARRAY
60162: NOT
60163: OR
60164: PUSH
60165: LD_EXP 58
60169: PUSH
60170: LD_VAR 0 1
60174: ARRAY
60175: PPUSH
60176: LD_INT 2
60178: PUSH
60179: LD_INT 30
60181: PUSH
60182: LD_INT 0
60184: PUSH
60185: EMPTY
60186: LIST
60187: LIST
60188: PUSH
60189: LD_INT 30
60191: PUSH
60192: LD_INT 1
60194: PUSH
60195: EMPTY
60196: LIST
60197: LIST
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: LIST
60203: PPUSH
60204: CALL_OW 72
60208: NOT
60209: OR
60210: IFFALSE 60214
// exit ;
60212: GO 63708
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60214: LD_ADDR_VAR 0 4
60218: PUSH
60219: LD_EXP 58
60223: PUSH
60224: LD_VAR 0 1
60228: ARRAY
60229: PPUSH
60230: LD_INT 2
60232: PUSH
60233: LD_INT 25
60235: PUSH
60236: LD_INT 1
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: PUSH
60243: LD_INT 25
60245: PUSH
60246: LD_INT 2
60248: PUSH
60249: EMPTY
60250: LIST
60251: LIST
60252: PUSH
60253: LD_INT 25
60255: PUSH
60256: LD_INT 3
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: LD_INT 25
60265: PUSH
60266: LD_INT 4
60268: PUSH
60269: EMPTY
60270: LIST
60271: LIST
60272: PUSH
60273: LD_INT 25
60275: PUSH
60276: LD_INT 5
60278: PUSH
60279: EMPTY
60280: LIST
60281: LIST
60282: PUSH
60283: LD_INT 25
60285: PUSH
60286: LD_INT 8
60288: PUSH
60289: EMPTY
60290: LIST
60291: LIST
60292: PUSH
60293: LD_INT 25
60295: PUSH
60296: LD_INT 9
60298: PUSH
60299: EMPTY
60300: LIST
60301: LIST
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: LIST
60307: LIST
60308: LIST
60309: LIST
60310: LIST
60311: LIST
60312: PPUSH
60313: CALL_OW 72
60317: ST_TO_ADDR
// for i in tmp do
60318: LD_ADDR_VAR 0 3
60322: PUSH
60323: LD_VAR 0 4
60327: PUSH
60328: FOR_IN
60329: IFFALSE 60360
// if GetTag ( i ) then
60331: LD_VAR 0 3
60335: PPUSH
60336: CALL_OW 110
60340: IFFALSE 60358
// tmp := tmp diff i ;
60342: LD_ADDR_VAR 0 4
60346: PUSH
60347: LD_VAR 0 4
60351: PUSH
60352: LD_VAR 0 3
60356: DIFF
60357: ST_TO_ADDR
60358: GO 60328
60360: POP
60361: POP
// if not tmp then
60362: LD_VAR 0 4
60366: NOT
60367: IFFALSE 60371
// exit ;
60369: GO 63708
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60371: LD_ADDR_VAR 0 5
60375: PUSH
60376: LD_EXP 58
60380: PUSH
60381: LD_VAR 0 1
60385: ARRAY
60386: PPUSH
60387: LD_INT 2
60389: PUSH
60390: LD_INT 25
60392: PUSH
60393: LD_INT 1
60395: PUSH
60396: EMPTY
60397: LIST
60398: LIST
60399: PUSH
60400: LD_INT 25
60402: PUSH
60403: LD_INT 5
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PUSH
60410: LD_INT 25
60412: PUSH
60413: LD_INT 8
60415: PUSH
60416: EMPTY
60417: LIST
60418: LIST
60419: PUSH
60420: LD_INT 25
60422: PUSH
60423: LD_INT 9
60425: PUSH
60426: EMPTY
60427: LIST
60428: LIST
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: LIST
60434: LIST
60435: LIST
60436: PPUSH
60437: CALL_OW 72
60441: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60442: LD_ADDR_VAR 0 6
60446: PUSH
60447: LD_EXP 58
60451: PUSH
60452: LD_VAR 0 1
60456: ARRAY
60457: PPUSH
60458: LD_INT 25
60460: PUSH
60461: LD_INT 2
60463: PUSH
60464: EMPTY
60465: LIST
60466: LIST
60467: PPUSH
60468: CALL_OW 72
60472: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60473: LD_ADDR_VAR 0 7
60477: PUSH
60478: LD_EXP 58
60482: PUSH
60483: LD_VAR 0 1
60487: ARRAY
60488: PPUSH
60489: LD_INT 25
60491: PUSH
60492: LD_INT 3
60494: PUSH
60495: EMPTY
60496: LIST
60497: LIST
60498: PPUSH
60499: CALL_OW 72
60503: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60504: LD_ADDR_VAR 0 8
60508: PUSH
60509: LD_EXP 58
60513: PUSH
60514: LD_VAR 0 1
60518: ARRAY
60519: PPUSH
60520: LD_INT 25
60522: PUSH
60523: LD_INT 4
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: PUSH
60530: LD_INT 24
60532: PUSH
60533: LD_INT 251
60535: PUSH
60536: EMPTY
60537: LIST
60538: LIST
60539: PUSH
60540: EMPTY
60541: LIST
60542: LIST
60543: PPUSH
60544: CALL_OW 72
60548: ST_TO_ADDR
// if mc_scan [ base ] then
60549: LD_EXP 81
60553: PUSH
60554: LD_VAR 0 1
60558: ARRAY
60559: IFFALSE 61020
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60561: LD_ADDR_EXP 100
60565: PUSH
60566: LD_EXP 100
60570: PPUSH
60571: LD_VAR 0 1
60575: PPUSH
60576: LD_INT 4
60578: PPUSH
60579: CALL_OW 1
60583: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60584: LD_ADDR_VAR 0 12
60588: PUSH
60589: LD_EXP 58
60593: PUSH
60594: LD_VAR 0 1
60598: ARRAY
60599: PPUSH
60600: LD_INT 2
60602: PUSH
60603: LD_INT 30
60605: PUSH
60606: LD_INT 4
60608: PUSH
60609: EMPTY
60610: LIST
60611: LIST
60612: PUSH
60613: LD_INT 30
60615: PUSH
60616: LD_INT 5
60618: PUSH
60619: EMPTY
60620: LIST
60621: LIST
60622: PUSH
60623: EMPTY
60624: LIST
60625: LIST
60626: LIST
60627: PPUSH
60628: CALL_OW 72
60632: ST_TO_ADDR
// if not b then
60633: LD_VAR 0 12
60637: NOT
60638: IFFALSE 60642
// exit ;
60640: GO 63708
// p := [ ] ;
60642: LD_ADDR_VAR 0 11
60646: PUSH
60647: EMPTY
60648: ST_TO_ADDR
// if sci >= 2 then
60649: LD_VAR 0 8
60653: PUSH
60654: LD_INT 2
60656: GREATEREQUAL
60657: IFFALSE 60688
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60659: LD_ADDR_VAR 0 8
60663: PUSH
60664: LD_VAR 0 8
60668: PUSH
60669: LD_INT 1
60671: ARRAY
60672: PUSH
60673: LD_VAR 0 8
60677: PUSH
60678: LD_INT 2
60680: ARRAY
60681: PUSH
60682: EMPTY
60683: LIST
60684: LIST
60685: ST_TO_ADDR
60686: GO 60749
// if sci = 1 then
60688: LD_VAR 0 8
60692: PUSH
60693: LD_INT 1
60695: EQUAL
60696: IFFALSE 60717
// sci := [ sci [ 1 ] ] else
60698: LD_ADDR_VAR 0 8
60702: PUSH
60703: LD_VAR 0 8
60707: PUSH
60708: LD_INT 1
60710: ARRAY
60711: PUSH
60712: EMPTY
60713: LIST
60714: ST_TO_ADDR
60715: GO 60749
// if sci = 0 then
60717: LD_VAR 0 8
60721: PUSH
60722: LD_INT 0
60724: EQUAL
60725: IFFALSE 60749
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60727: LD_ADDR_VAR 0 11
60731: PUSH
60732: LD_VAR 0 4
60736: PPUSH
60737: LD_INT 4
60739: PPUSH
60740: CALL 54850 0 2
60744: PUSH
60745: LD_INT 1
60747: ARRAY
60748: ST_TO_ADDR
// if eng > 4 then
60749: LD_VAR 0 6
60753: PUSH
60754: LD_INT 4
60756: GREATER
60757: IFFALSE 60803
// for i = eng downto 4 do
60759: LD_ADDR_VAR 0 3
60763: PUSH
60764: DOUBLE
60765: LD_VAR 0 6
60769: INC
60770: ST_TO_ADDR
60771: LD_INT 4
60773: PUSH
60774: FOR_DOWNTO
60775: IFFALSE 60801
// eng := eng diff eng [ i ] ;
60777: LD_ADDR_VAR 0 6
60781: PUSH
60782: LD_VAR 0 6
60786: PUSH
60787: LD_VAR 0 6
60791: PUSH
60792: LD_VAR 0 3
60796: ARRAY
60797: DIFF
60798: ST_TO_ADDR
60799: GO 60774
60801: POP
60802: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60803: LD_ADDR_VAR 0 4
60807: PUSH
60808: LD_VAR 0 4
60812: PUSH
60813: LD_VAR 0 5
60817: PUSH
60818: LD_VAR 0 6
60822: UNION
60823: PUSH
60824: LD_VAR 0 7
60828: UNION
60829: PUSH
60830: LD_VAR 0 8
60834: UNION
60835: DIFF
60836: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60837: LD_ADDR_VAR 0 13
60841: PUSH
60842: LD_EXP 58
60846: PUSH
60847: LD_VAR 0 1
60851: ARRAY
60852: PPUSH
60853: LD_INT 2
60855: PUSH
60856: LD_INT 30
60858: PUSH
60859: LD_INT 32
60861: PUSH
60862: EMPTY
60863: LIST
60864: LIST
60865: PUSH
60866: LD_INT 30
60868: PUSH
60869: LD_INT 31
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PUSH
60876: EMPTY
60877: LIST
60878: LIST
60879: LIST
60880: PPUSH
60881: CALL_OW 72
60885: PUSH
60886: LD_EXP 58
60890: PUSH
60891: LD_VAR 0 1
60895: ARRAY
60896: PPUSH
60897: LD_INT 2
60899: PUSH
60900: LD_INT 30
60902: PUSH
60903: LD_INT 4
60905: PUSH
60906: EMPTY
60907: LIST
60908: LIST
60909: PUSH
60910: LD_INT 30
60912: PUSH
60913: LD_INT 5
60915: PUSH
60916: EMPTY
60917: LIST
60918: LIST
60919: PUSH
60920: EMPTY
60921: LIST
60922: LIST
60923: LIST
60924: PPUSH
60925: CALL_OW 72
60929: PUSH
60930: LD_INT 6
60932: MUL
60933: PLUS
60934: ST_TO_ADDR
// if bcount < tmp then
60935: LD_VAR 0 13
60939: PUSH
60940: LD_VAR 0 4
60944: LESS
60945: IFFALSE 60991
// for i = tmp downto bcount do
60947: LD_ADDR_VAR 0 3
60951: PUSH
60952: DOUBLE
60953: LD_VAR 0 4
60957: INC
60958: ST_TO_ADDR
60959: LD_VAR 0 13
60963: PUSH
60964: FOR_DOWNTO
60965: IFFALSE 60989
// tmp := Delete ( tmp , tmp ) ;
60967: LD_ADDR_VAR 0 4
60971: PUSH
60972: LD_VAR 0 4
60976: PPUSH
60977: LD_VAR 0 4
60981: PPUSH
60982: CALL_OW 3
60986: ST_TO_ADDR
60987: GO 60964
60989: POP
60990: POP
// result := [ tmp , 0 , 0 , p ] ;
60991: LD_ADDR_VAR 0 2
60995: PUSH
60996: LD_VAR 0 4
61000: PUSH
61001: LD_INT 0
61003: PUSH
61004: LD_INT 0
61006: PUSH
61007: LD_VAR 0 11
61011: PUSH
61012: EMPTY
61013: LIST
61014: LIST
61015: LIST
61016: LIST
61017: ST_TO_ADDR
// exit ;
61018: GO 63708
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61020: LD_EXP 58
61024: PUSH
61025: LD_VAR 0 1
61029: ARRAY
61030: PPUSH
61031: LD_INT 2
61033: PUSH
61034: LD_INT 30
61036: PUSH
61037: LD_INT 6
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: PUSH
61044: LD_INT 30
61046: PUSH
61047: LD_INT 7
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: LD_INT 30
61056: PUSH
61057: LD_INT 8
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PUSH
61064: EMPTY
61065: LIST
61066: LIST
61067: LIST
61068: LIST
61069: PPUSH
61070: CALL_OW 72
61074: NOT
61075: PUSH
61076: LD_EXP 58
61080: PUSH
61081: LD_VAR 0 1
61085: ARRAY
61086: PPUSH
61087: LD_INT 30
61089: PUSH
61090: LD_INT 3
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: PPUSH
61097: CALL_OW 72
61101: NOT
61102: AND
61103: IFFALSE 61175
// begin if eng = tmp then
61105: LD_VAR 0 6
61109: PUSH
61110: LD_VAR 0 4
61114: EQUAL
61115: IFFALSE 61119
// exit ;
61117: GO 63708
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
61119: LD_ADDR_EXP 100
61123: PUSH
61124: LD_EXP 100
61128: PPUSH
61129: LD_VAR 0 1
61133: PPUSH
61134: LD_INT 1
61136: PPUSH
61137: CALL_OW 1
61141: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
61142: LD_ADDR_VAR 0 2
61146: PUSH
61147: LD_INT 0
61149: PUSH
61150: LD_VAR 0 4
61154: PUSH
61155: LD_VAR 0 6
61159: DIFF
61160: PUSH
61161: LD_INT 0
61163: PUSH
61164: LD_INT 0
61166: PUSH
61167: EMPTY
61168: LIST
61169: LIST
61170: LIST
61171: LIST
61172: ST_TO_ADDR
// exit ;
61173: GO 63708
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61175: LD_EXP 85
61179: PUSH
61180: LD_EXP 84
61184: PUSH
61185: LD_VAR 0 1
61189: ARRAY
61190: ARRAY
61191: PUSH
61192: LD_EXP 58
61196: PUSH
61197: LD_VAR 0 1
61201: ARRAY
61202: PPUSH
61203: LD_INT 2
61205: PUSH
61206: LD_INT 30
61208: PUSH
61209: LD_INT 6
61211: PUSH
61212: EMPTY
61213: LIST
61214: LIST
61215: PUSH
61216: LD_INT 30
61218: PUSH
61219: LD_INT 7
61221: PUSH
61222: EMPTY
61223: LIST
61224: LIST
61225: PUSH
61226: LD_INT 30
61228: PUSH
61229: LD_INT 8
61231: PUSH
61232: EMPTY
61233: LIST
61234: LIST
61235: PUSH
61236: EMPTY
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: PPUSH
61242: CALL_OW 72
61246: AND
61247: PUSH
61248: LD_EXP 58
61252: PUSH
61253: LD_VAR 0 1
61257: ARRAY
61258: PPUSH
61259: LD_INT 30
61261: PUSH
61262: LD_INT 3
61264: PUSH
61265: EMPTY
61266: LIST
61267: LIST
61268: PPUSH
61269: CALL_OW 72
61273: NOT
61274: AND
61275: IFFALSE 61489
// begin if sci >= 6 then
61277: LD_VAR 0 8
61281: PUSH
61282: LD_INT 6
61284: GREATEREQUAL
61285: IFFALSE 61289
// exit ;
61287: GO 63708
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61289: LD_ADDR_EXP 100
61293: PUSH
61294: LD_EXP 100
61298: PPUSH
61299: LD_VAR 0 1
61303: PPUSH
61304: LD_INT 2
61306: PPUSH
61307: CALL_OW 1
61311: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61312: LD_ADDR_VAR 0 9
61316: PUSH
61317: LD_VAR 0 4
61321: PUSH
61322: LD_VAR 0 8
61326: DIFF
61327: PPUSH
61328: LD_INT 4
61330: PPUSH
61331: CALL 54850 0 2
61335: ST_TO_ADDR
// p := [ ] ;
61336: LD_ADDR_VAR 0 11
61340: PUSH
61341: EMPTY
61342: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61343: LD_VAR 0 8
61347: PUSH
61348: LD_INT 6
61350: LESS
61351: PUSH
61352: LD_VAR 0 9
61356: PUSH
61357: LD_INT 6
61359: GREATER
61360: AND
61361: IFFALSE 61442
// begin for i = 1 to 6 - sci do
61363: LD_ADDR_VAR 0 3
61367: PUSH
61368: DOUBLE
61369: LD_INT 1
61371: DEC
61372: ST_TO_ADDR
61373: LD_INT 6
61375: PUSH
61376: LD_VAR 0 8
61380: MINUS
61381: PUSH
61382: FOR_TO
61383: IFFALSE 61438
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61385: LD_ADDR_VAR 0 11
61389: PUSH
61390: LD_VAR 0 11
61394: PPUSH
61395: LD_VAR 0 11
61399: PUSH
61400: LD_INT 1
61402: PLUS
61403: PPUSH
61404: LD_VAR 0 9
61408: PUSH
61409: LD_INT 1
61411: ARRAY
61412: PPUSH
61413: CALL_OW 2
61417: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61418: LD_ADDR_VAR 0 9
61422: PUSH
61423: LD_VAR 0 9
61427: PPUSH
61428: LD_INT 1
61430: PPUSH
61431: CALL_OW 3
61435: ST_TO_ADDR
// end ;
61436: GO 61382
61438: POP
61439: POP
// end else
61440: GO 61462
// if sort then
61442: LD_VAR 0 9
61446: IFFALSE 61462
// p := sort [ 1 ] ;
61448: LD_ADDR_VAR 0 11
61452: PUSH
61453: LD_VAR 0 9
61457: PUSH
61458: LD_INT 1
61460: ARRAY
61461: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61462: LD_ADDR_VAR 0 2
61466: PUSH
61467: LD_INT 0
61469: PUSH
61470: LD_INT 0
61472: PUSH
61473: LD_INT 0
61475: PUSH
61476: LD_VAR 0 11
61480: PUSH
61481: EMPTY
61482: LIST
61483: LIST
61484: LIST
61485: LIST
61486: ST_TO_ADDR
// exit ;
61487: GO 63708
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61489: LD_EXP 85
61493: PUSH
61494: LD_EXP 84
61498: PUSH
61499: LD_VAR 0 1
61503: ARRAY
61504: ARRAY
61505: PUSH
61506: LD_EXP 58
61510: PUSH
61511: LD_VAR 0 1
61515: ARRAY
61516: PPUSH
61517: LD_INT 2
61519: PUSH
61520: LD_INT 30
61522: PUSH
61523: LD_INT 6
61525: PUSH
61526: EMPTY
61527: LIST
61528: LIST
61529: PUSH
61530: LD_INT 30
61532: PUSH
61533: LD_INT 7
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 30
61542: PUSH
61543: LD_INT 8
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: LIST
61554: LIST
61555: PPUSH
61556: CALL_OW 72
61560: AND
61561: PUSH
61562: LD_EXP 58
61566: PUSH
61567: LD_VAR 0 1
61571: ARRAY
61572: PPUSH
61573: LD_INT 30
61575: PUSH
61576: LD_INT 3
61578: PUSH
61579: EMPTY
61580: LIST
61581: LIST
61582: PPUSH
61583: CALL_OW 72
61587: AND
61588: IFFALSE 62322
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61590: LD_ADDR_EXP 100
61594: PUSH
61595: LD_EXP 100
61599: PPUSH
61600: LD_VAR 0 1
61604: PPUSH
61605: LD_INT 3
61607: PPUSH
61608: CALL_OW 1
61612: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61613: LD_ADDR_VAR 0 2
61617: PUSH
61618: LD_INT 0
61620: PUSH
61621: LD_INT 0
61623: PUSH
61624: LD_INT 0
61626: PUSH
61627: LD_INT 0
61629: PUSH
61630: EMPTY
61631: LIST
61632: LIST
61633: LIST
61634: LIST
61635: ST_TO_ADDR
// if not eng then
61636: LD_VAR 0 6
61640: NOT
61641: IFFALSE 61704
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61643: LD_ADDR_VAR 0 11
61647: PUSH
61648: LD_VAR 0 4
61652: PPUSH
61653: LD_INT 2
61655: PPUSH
61656: CALL 54850 0 2
61660: PUSH
61661: LD_INT 1
61663: ARRAY
61664: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61665: LD_ADDR_VAR 0 2
61669: PUSH
61670: LD_VAR 0 2
61674: PPUSH
61675: LD_INT 2
61677: PPUSH
61678: LD_VAR 0 11
61682: PPUSH
61683: CALL_OW 1
61687: ST_TO_ADDR
// tmp := tmp diff p ;
61688: LD_ADDR_VAR 0 4
61692: PUSH
61693: LD_VAR 0 4
61697: PUSH
61698: LD_VAR 0 11
61702: DIFF
61703: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61704: LD_VAR 0 4
61708: PUSH
61709: LD_VAR 0 8
61713: PUSH
61714: LD_INT 6
61716: LESS
61717: AND
61718: IFFALSE 61906
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61720: LD_ADDR_VAR 0 9
61724: PUSH
61725: LD_VAR 0 4
61729: PUSH
61730: LD_VAR 0 8
61734: PUSH
61735: LD_VAR 0 7
61739: UNION
61740: DIFF
61741: PPUSH
61742: LD_INT 4
61744: PPUSH
61745: CALL 54850 0 2
61749: ST_TO_ADDR
// p := [ ] ;
61750: LD_ADDR_VAR 0 11
61754: PUSH
61755: EMPTY
61756: ST_TO_ADDR
// if sort then
61757: LD_VAR 0 9
61761: IFFALSE 61877
// for i = 1 to 6 - sci do
61763: LD_ADDR_VAR 0 3
61767: PUSH
61768: DOUBLE
61769: LD_INT 1
61771: DEC
61772: ST_TO_ADDR
61773: LD_INT 6
61775: PUSH
61776: LD_VAR 0 8
61780: MINUS
61781: PUSH
61782: FOR_TO
61783: IFFALSE 61875
// begin if i = sort then
61785: LD_VAR 0 3
61789: PUSH
61790: LD_VAR 0 9
61794: EQUAL
61795: IFFALSE 61799
// break ;
61797: GO 61875
// if GetClass ( i ) = 4 then
61799: LD_VAR 0 3
61803: PPUSH
61804: CALL_OW 257
61808: PUSH
61809: LD_INT 4
61811: EQUAL
61812: IFFALSE 61816
// continue ;
61814: GO 61782
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61816: LD_ADDR_VAR 0 11
61820: PUSH
61821: LD_VAR 0 11
61825: PPUSH
61826: LD_VAR 0 11
61830: PUSH
61831: LD_INT 1
61833: PLUS
61834: PPUSH
61835: LD_VAR 0 9
61839: PUSH
61840: LD_VAR 0 3
61844: ARRAY
61845: PPUSH
61846: CALL_OW 2
61850: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61851: LD_ADDR_VAR 0 4
61855: PUSH
61856: LD_VAR 0 4
61860: PUSH
61861: LD_VAR 0 9
61865: PUSH
61866: LD_VAR 0 3
61870: ARRAY
61871: DIFF
61872: ST_TO_ADDR
// end ;
61873: GO 61782
61875: POP
61876: POP
// if p then
61877: LD_VAR 0 11
61881: IFFALSE 61906
// result := Replace ( result , 4 , p ) ;
61883: LD_ADDR_VAR 0 2
61887: PUSH
61888: LD_VAR 0 2
61892: PPUSH
61893: LD_INT 4
61895: PPUSH
61896: LD_VAR 0 11
61900: PPUSH
61901: CALL_OW 1
61905: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61906: LD_VAR 0 4
61910: PUSH
61911: LD_VAR 0 7
61915: PUSH
61916: LD_INT 6
61918: LESS
61919: AND
61920: IFFALSE 62108
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61922: LD_ADDR_VAR 0 9
61926: PUSH
61927: LD_VAR 0 4
61931: PUSH
61932: LD_VAR 0 8
61936: PUSH
61937: LD_VAR 0 7
61941: UNION
61942: DIFF
61943: PPUSH
61944: LD_INT 3
61946: PPUSH
61947: CALL 54850 0 2
61951: ST_TO_ADDR
// p := [ ] ;
61952: LD_ADDR_VAR 0 11
61956: PUSH
61957: EMPTY
61958: ST_TO_ADDR
// if sort then
61959: LD_VAR 0 9
61963: IFFALSE 62079
// for i = 1 to 6 - mech do
61965: LD_ADDR_VAR 0 3
61969: PUSH
61970: DOUBLE
61971: LD_INT 1
61973: DEC
61974: ST_TO_ADDR
61975: LD_INT 6
61977: PUSH
61978: LD_VAR 0 7
61982: MINUS
61983: PUSH
61984: FOR_TO
61985: IFFALSE 62077
// begin if i = sort then
61987: LD_VAR 0 3
61991: PUSH
61992: LD_VAR 0 9
61996: EQUAL
61997: IFFALSE 62001
// break ;
61999: GO 62077
// if GetClass ( i ) = 3 then
62001: LD_VAR 0 3
62005: PPUSH
62006: CALL_OW 257
62010: PUSH
62011: LD_INT 3
62013: EQUAL
62014: IFFALSE 62018
// continue ;
62016: GO 61984
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62018: LD_ADDR_VAR 0 11
62022: PUSH
62023: LD_VAR 0 11
62027: PPUSH
62028: LD_VAR 0 11
62032: PUSH
62033: LD_INT 1
62035: PLUS
62036: PPUSH
62037: LD_VAR 0 9
62041: PUSH
62042: LD_VAR 0 3
62046: ARRAY
62047: PPUSH
62048: CALL_OW 2
62052: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62053: LD_ADDR_VAR 0 4
62057: PUSH
62058: LD_VAR 0 4
62062: PUSH
62063: LD_VAR 0 9
62067: PUSH
62068: LD_VAR 0 3
62072: ARRAY
62073: DIFF
62074: ST_TO_ADDR
// end ;
62075: GO 61984
62077: POP
62078: POP
// if p then
62079: LD_VAR 0 11
62083: IFFALSE 62108
// result := Replace ( result , 3 , p ) ;
62085: LD_ADDR_VAR 0 2
62089: PUSH
62090: LD_VAR 0 2
62094: PPUSH
62095: LD_INT 3
62097: PPUSH
62098: LD_VAR 0 11
62102: PPUSH
62103: CALL_OW 1
62107: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
62108: LD_VAR 0 4
62112: PUSH
62113: LD_INT 6
62115: GREATER
62116: PUSH
62117: LD_VAR 0 6
62121: PUSH
62122: LD_INT 6
62124: LESS
62125: AND
62126: IFFALSE 62320
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62128: LD_ADDR_VAR 0 9
62132: PUSH
62133: LD_VAR 0 4
62137: PUSH
62138: LD_VAR 0 8
62142: PUSH
62143: LD_VAR 0 7
62147: UNION
62148: PUSH
62149: LD_VAR 0 6
62153: UNION
62154: DIFF
62155: PPUSH
62156: LD_INT 2
62158: PPUSH
62159: CALL 54850 0 2
62163: ST_TO_ADDR
// p := [ ] ;
62164: LD_ADDR_VAR 0 11
62168: PUSH
62169: EMPTY
62170: ST_TO_ADDR
// if sort then
62171: LD_VAR 0 9
62175: IFFALSE 62291
// for i = 1 to 6 - eng do
62177: LD_ADDR_VAR 0 3
62181: PUSH
62182: DOUBLE
62183: LD_INT 1
62185: DEC
62186: ST_TO_ADDR
62187: LD_INT 6
62189: PUSH
62190: LD_VAR 0 6
62194: MINUS
62195: PUSH
62196: FOR_TO
62197: IFFALSE 62289
// begin if i = sort then
62199: LD_VAR 0 3
62203: PUSH
62204: LD_VAR 0 9
62208: EQUAL
62209: IFFALSE 62213
// break ;
62211: GO 62289
// if GetClass ( i ) = 2 then
62213: LD_VAR 0 3
62217: PPUSH
62218: CALL_OW 257
62222: PUSH
62223: LD_INT 2
62225: EQUAL
62226: IFFALSE 62230
// continue ;
62228: GO 62196
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62230: LD_ADDR_VAR 0 11
62234: PUSH
62235: LD_VAR 0 11
62239: PPUSH
62240: LD_VAR 0 11
62244: PUSH
62245: LD_INT 1
62247: PLUS
62248: PPUSH
62249: LD_VAR 0 9
62253: PUSH
62254: LD_VAR 0 3
62258: ARRAY
62259: PPUSH
62260: CALL_OW 2
62264: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62265: LD_ADDR_VAR 0 4
62269: PUSH
62270: LD_VAR 0 4
62274: PUSH
62275: LD_VAR 0 9
62279: PUSH
62280: LD_VAR 0 3
62284: ARRAY
62285: DIFF
62286: ST_TO_ADDR
// end ;
62287: GO 62196
62289: POP
62290: POP
// if p then
62291: LD_VAR 0 11
62295: IFFALSE 62320
// result := Replace ( result , 2 , p ) ;
62297: LD_ADDR_VAR 0 2
62301: PUSH
62302: LD_VAR 0 2
62306: PPUSH
62307: LD_INT 2
62309: PPUSH
62310: LD_VAR 0 11
62314: PPUSH
62315: CALL_OW 1
62319: ST_TO_ADDR
// end ; exit ;
62320: GO 63708
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62322: LD_EXP 85
62326: PUSH
62327: LD_EXP 84
62331: PUSH
62332: LD_VAR 0 1
62336: ARRAY
62337: ARRAY
62338: NOT
62339: PUSH
62340: LD_EXP 58
62344: PUSH
62345: LD_VAR 0 1
62349: ARRAY
62350: PPUSH
62351: LD_INT 30
62353: PUSH
62354: LD_INT 3
62356: PUSH
62357: EMPTY
62358: LIST
62359: LIST
62360: PPUSH
62361: CALL_OW 72
62365: AND
62366: PUSH
62367: LD_EXP 63
62371: PUSH
62372: LD_VAR 0 1
62376: ARRAY
62377: AND
62378: IFFALSE 62986
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62380: LD_ADDR_EXP 100
62384: PUSH
62385: LD_EXP 100
62389: PPUSH
62390: LD_VAR 0 1
62394: PPUSH
62395: LD_INT 5
62397: PPUSH
62398: CALL_OW 1
62402: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62403: LD_ADDR_VAR 0 2
62407: PUSH
62408: LD_INT 0
62410: PUSH
62411: LD_INT 0
62413: PUSH
62414: LD_INT 0
62416: PUSH
62417: LD_INT 0
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: LIST
62424: LIST
62425: ST_TO_ADDR
// if sci > 1 then
62426: LD_VAR 0 8
62430: PUSH
62431: LD_INT 1
62433: GREATER
62434: IFFALSE 62462
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62436: LD_ADDR_VAR 0 4
62440: PUSH
62441: LD_VAR 0 4
62445: PUSH
62446: LD_VAR 0 8
62450: PUSH
62451: LD_VAR 0 8
62455: PUSH
62456: LD_INT 1
62458: ARRAY
62459: DIFF
62460: DIFF
62461: ST_TO_ADDR
// if tmp and not sci then
62462: LD_VAR 0 4
62466: PUSH
62467: LD_VAR 0 8
62471: NOT
62472: AND
62473: IFFALSE 62542
// begin sort := SortBySkill ( tmp , 4 ) ;
62475: LD_ADDR_VAR 0 9
62479: PUSH
62480: LD_VAR 0 4
62484: PPUSH
62485: LD_INT 4
62487: PPUSH
62488: CALL 54850 0 2
62492: ST_TO_ADDR
// if sort then
62493: LD_VAR 0 9
62497: IFFALSE 62513
// p := sort [ 1 ] ;
62499: LD_ADDR_VAR 0 11
62503: PUSH
62504: LD_VAR 0 9
62508: PUSH
62509: LD_INT 1
62511: ARRAY
62512: ST_TO_ADDR
// if p then
62513: LD_VAR 0 11
62517: IFFALSE 62542
// result := Replace ( result , 4 , p ) ;
62519: LD_ADDR_VAR 0 2
62523: PUSH
62524: LD_VAR 0 2
62528: PPUSH
62529: LD_INT 4
62531: PPUSH
62532: LD_VAR 0 11
62536: PPUSH
62537: CALL_OW 1
62541: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62542: LD_ADDR_VAR 0 4
62546: PUSH
62547: LD_VAR 0 4
62551: PUSH
62552: LD_VAR 0 7
62556: DIFF
62557: ST_TO_ADDR
// if tmp and mech < 6 then
62558: LD_VAR 0 4
62562: PUSH
62563: LD_VAR 0 7
62567: PUSH
62568: LD_INT 6
62570: LESS
62571: AND
62572: IFFALSE 62760
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62574: LD_ADDR_VAR 0 9
62578: PUSH
62579: LD_VAR 0 4
62583: PUSH
62584: LD_VAR 0 8
62588: PUSH
62589: LD_VAR 0 7
62593: UNION
62594: DIFF
62595: PPUSH
62596: LD_INT 3
62598: PPUSH
62599: CALL 54850 0 2
62603: ST_TO_ADDR
// p := [ ] ;
62604: LD_ADDR_VAR 0 11
62608: PUSH
62609: EMPTY
62610: ST_TO_ADDR
// if sort then
62611: LD_VAR 0 9
62615: IFFALSE 62731
// for i = 1 to 6 - mech do
62617: LD_ADDR_VAR 0 3
62621: PUSH
62622: DOUBLE
62623: LD_INT 1
62625: DEC
62626: ST_TO_ADDR
62627: LD_INT 6
62629: PUSH
62630: LD_VAR 0 7
62634: MINUS
62635: PUSH
62636: FOR_TO
62637: IFFALSE 62729
// begin if i = sort then
62639: LD_VAR 0 3
62643: PUSH
62644: LD_VAR 0 9
62648: EQUAL
62649: IFFALSE 62653
// break ;
62651: GO 62729
// if GetClass ( i ) = 3 then
62653: LD_VAR 0 3
62657: PPUSH
62658: CALL_OW 257
62662: PUSH
62663: LD_INT 3
62665: EQUAL
62666: IFFALSE 62670
// continue ;
62668: GO 62636
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62670: LD_ADDR_VAR 0 11
62674: PUSH
62675: LD_VAR 0 11
62679: PPUSH
62680: LD_VAR 0 11
62684: PUSH
62685: LD_INT 1
62687: PLUS
62688: PPUSH
62689: LD_VAR 0 9
62693: PUSH
62694: LD_VAR 0 3
62698: ARRAY
62699: PPUSH
62700: CALL_OW 2
62704: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62705: LD_ADDR_VAR 0 4
62709: PUSH
62710: LD_VAR 0 4
62714: PUSH
62715: LD_VAR 0 9
62719: PUSH
62720: LD_VAR 0 3
62724: ARRAY
62725: DIFF
62726: ST_TO_ADDR
// end ;
62727: GO 62636
62729: POP
62730: POP
// if p then
62731: LD_VAR 0 11
62735: IFFALSE 62760
// result := Replace ( result , 3 , p ) ;
62737: LD_ADDR_VAR 0 2
62741: PUSH
62742: LD_VAR 0 2
62746: PPUSH
62747: LD_INT 3
62749: PPUSH
62750: LD_VAR 0 11
62754: PPUSH
62755: CALL_OW 1
62759: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62760: LD_ADDR_VAR 0 4
62764: PUSH
62765: LD_VAR 0 4
62769: PUSH
62770: LD_VAR 0 6
62774: DIFF
62775: ST_TO_ADDR
// if tmp and eng < 6 then
62776: LD_VAR 0 4
62780: PUSH
62781: LD_VAR 0 6
62785: PUSH
62786: LD_INT 6
62788: LESS
62789: AND
62790: IFFALSE 62984
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62792: LD_ADDR_VAR 0 9
62796: PUSH
62797: LD_VAR 0 4
62801: PUSH
62802: LD_VAR 0 8
62806: PUSH
62807: LD_VAR 0 7
62811: UNION
62812: PUSH
62813: LD_VAR 0 6
62817: UNION
62818: DIFF
62819: PPUSH
62820: LD_INT 2
62822: PPUSH
62823: CALL 54850 0 2
62827: ST_TO_ADDR
// p := [ ] ;
62828: LD_ADDR_VAR 0 11
62832: PUSH
62833: EMPTY
62834: ST_TO_ADDR
// if sort then
62835: LD_VAR 0 9
62839: IFFALSE 62955
// for i = 1 to 6 - eng do
62841: LD_ADDR_VAR 0 3
62845: PUSH
62846: DOUBLE
62847: LD_INT 1
62849: DEC
62850: ST_TO_ADDR
62851: LD_INT 6
62853: PUSH
62854: LD_VAR 0 6
62858: MINUS
62859: PUSH
62860: FOR_TO
62861: IFFALSE 62953
// begin if i = sort then
62863: LD_VAR 0 3
62867: PUSH
62868: LD_VAR 0 9
62872: EQUAL
62873: IFFALSE 62877
// break ;
62875: GO 62953
// if GetClass ( i ) = 2 then
62877: LD_VAR 0 3
62881: PPUSH
62882: CALL_OW 257
62886: PUSH
62887: LD_INT 2
62889: EQUAL
62890: IFFALSE 62894
// continue ;
62892: GO 62860
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62894: LD_ADDR_VAR 0 11
62898: PUSH
62899: LD_VAR 0 11
62903: PPUSH
62904: LD_VAR 0 11
62908: PUSH
62909: LD_INT 1
62911: PLUS
62912: PPUSH
62913: LD_VAR 0 9
62917: PUSH
62918: LD_VAR 0 3
62922: ARRAY
62923: PPUSH
62924: CALL_OW 2
62928: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62929: LD_ADDR_VAR 0 4
62933: PUSH
62934: LD_VAR 0 4
62938: PUSH
62939: LD_VAR 0 9
62943: PUSH
62944: LD_VAR 0 3
62948: ARRAY
62949: DIFF
62950: ST_TO_ADDR
// end ;
62951: GO 62860
62953: POP
62954: POP
// if p then
62955: LD_VAR 0 11
62959: IFFALSE 62984
// result := Replace ( result , 2 , p ) ;
62961: LD_ADDR_VAR 0 2
62965: PUSH
62966: LD_VAR 0 2
62970: PPUSH
62971: LD_INT 2
62973: PPUSH
62974: LD_VAR 0 11
62978: PPUSH
62979: CALL_OW 1
62983: ST_TO_ADDR
// end ; exit ;
62984: GO 63708
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62986: LD_EXP 85
62990: PUSH
62991: LD_EXP 84
62995: PUSH
62996: LD_VAR 0 1
63000: ARRAY
63001: ARRAY
63002: NOT
63003: PUSH
63004: LD_EXP 58
63008: PUSH
63009: LD_VAR 0 1
63013: ARRAY
63014: PPUSH
63015: LD_INT 30
63017: PUSH
63018: LD_INT 3
63020: PUSH
63021: EMPTY
63022: LIST
63023: LIST
63024: PPUSH
63025: CALL_OW 72
63029: AND
63030: PUSH
63031: LD_EXP 63
63035: PUSH
63036: LD_VAR 0 1
63040: ARRAY
63041: NOT
63042: AND
63043: IFFALSE 63708
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63045: LD_ADDR_EXP 100
63049: PUSH
63050: LD_EXP 100
63054: PPUSH
63055: LD_VAR 0 1
63059: PPUSH
63060: LD_INT 6
63062: PPUSH
63063: CALL_OW 1
63067: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63068: LD_ADDR_VAR 0 2
63072: PUSH
63073: LD_INT 0
63075: PUSH
63076: LD_INT 0
63078: PUSH
63079: LD_INT 0
63081: PUSH
63082: LD_INT 0
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: LIST
63089: LIST
63090: ST_TO_ADDR
// if sci >= 1 then
63091: LD_VAR 0 8
63095: PUSH
63096: LD_INT 1
63098: GREATEREQUAL
63099: IFFALSE 63121
// tmp := tmp diff sci [ 1 ] ;
63101: LD_ADDR_VAR 0 4
63105: PUSH
63106: LD_VAR 0 4
63110: PUSH
63111: LD_VAR 0 8
63115: PUSH
63116: LD_INT 1
63118: ARRAY
63119: DIFF
63120: ST_TO_ADDR
// if tmp and not sci then
63121: LD_VAR 0 4
63125: PUSH
63126: LD_VAR 0 8
63130: NOT
63131: AND
63132: IFFALSE 63201
// begin sort := SortBySkill ( tmp , 4 ) ;
63134: LD_ADDR_VAR 0 9
63138: PUSH
63139: LD_VAR 0 4
63143: PPUSH
63144: LD_INT 4
63146: PPUSH
63147: CALL 54850 0 2
63151: ST_TO_ADDR
// if sort then
63152: LD_VAR 0 9
63156: IFFALSE 63172
// p := sort [ 1 ] ;
63158: LD_ADDR_VAR 0 11
63162: PUSH
63163: LD_VAR 0 9
63167: PUSH
63168: LD_INT 1
63170: ARRAY
63171: ST_TO_ADDR
// if p then
63172: LD_VAR 0 11
63176: IFFALSE 63201
// result := Replace ( result , 4 , p ) ;
63178: LD_ADDR_VAR 0 2
63182: PUSH
63183: LD_VAR 0 2
63187: PPUSH
63188: LD_INT 4
63190: PPUSH
63191: LD_VAR 0 11
63195: PPUSH
63196: CALL_OW 1
63200: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63201: LD_ADDR_VAR 0 4
63205: PUSH
63206: LD_VAR 0 4
63210: PUSH
63211: LD_VAR 0 7
63215: DIFF
63216: ST_TO_ADDR
// if tmp and mech < 6 then
63217: LD_VAR 0 4
63221: PUSH
63222: LD_VAR 0 7
63226: PUSH
63227: LD_INT 6
63229: LESS
63230: AND
63231: IFFALSE 63413
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63233: LD_ADDR_VAR 0 9
63237: PUSH
63238: LD_VAR 0 4
63242: PUSH
63243: LD_VAR 0 7
63247: DIFF
63248: PPUSH
63249: LD_INT 3
63251: PPUSH
63252: CALL 54850 0 2
63256: ST_TO_ADDR
// p := [ ] ;
63257: LD_ADDR_VAR 0 11
63261: PUSH
63262: EMPTY
63263: ST_TO_ADDR
// if sort then
63264: LD_VAR 0 9
63268: IFFALSE 63384
// for i = 1 to 6 - mech do
63270: LD_ADDR_VAR 0 3
63274: PUSH
63275: DOUBLE
63276: LD_INT 1
63278: DEC
63279: ST_TO_ADDR
63280: LD_INT 6
63282: PUSH
63283: LD_VAR 0 7
63287: MINUS
63288: PUSH
63289: FOR_TO
63290: IFFALSE 63382
// begin if i = sort then
63292: LD_VAR 0 3
63296: PUSH
63297: LD_VAR 0 9
63301: EQUAL
63302: IFFALSE 63306
// break ;
63304: GO 63382
// if GetClass ( i ) = 3 then
63306: LD_VAR 0 3
63310: PPUSH
63311: CALL_OW 257
63315: PUSH
63316: LD_INT 3
63318: EQUAL
63319: IFFALSE 63323
// continue ;
63321: GO 63289
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63323: LD_ADDR_VAR 0 11
63327: PUSH
63328: LD_VAR 0 11
63332: PPUSH
63333: LD_VAR 0 11
63337: PUSH
63338: LD_INT 1
63340: PLUS
63341: PPUSH
63342: LD_VAR 0 9
63346: PUSH
63347: LD_VAR 0 3
63351: ARRAY
63352: PPUSH
63353: CALL_OW 2
63357: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63358: LD_ADDR_VAR 0 4
63362: PUSH
63363: LD_VAR 0 4
63367: PUSH
63368: LD_VAR 0 9
63372: PUSH
63373: LD_VAR 0 3
63377: ARRAY
63378: DIFF
63379: ST_TO_ADDR
// end ;
63380: GO 63289
63382: POP
63383: POP
// if p then
63384: LD_VAR 0 11
63388: IFFALSE 63413
// result := Replace ( result , 3 , p ) ;
63390: LD_ADDR_VAR 0 2
63394: PUSH
63395: LD_VAR 0 2
63399: PPUSH
63400: LD_INT 3
63402: PPUSH
63403: LD_VAR 0 11
63407: PPUSH
63408: CALL_OW 1
63412: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63413: LD_ADDR_VAR 0 4
63417: PUSH
63418: LD_VAR 0 4
63422: PUSH
63423: LD_VAR 0 6
63427: DIFF
63428: ST_TO_ADDR
// if tmp and eng < 4 then
63429: LD_VAR 0 4
63433: PUSH
63434: LD_VAR 0 6
63438: PUSH
63439: LD_INT 4
63441: LESS
63442: AND
63443: IFFALSE 63633
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63445: LD_ADDR_VAR 0 9
63449: PUSH
63450: LD_VAR 0 4
63454: PUSH
63455: LD_VAR 0 7
63459: PUSH
63460: LD_VAR 0 6
63464: UNION
63465: DIFF
63466: PPUSH
63467: LD_INT 2
63469: PPUSH
63470: CALL 54850 0 2
63474: ST_TO_ADDR
// p := [ ] ;
63475: LD_ADDR_VAR 0 11
63479: PUSH
63480: EMPTY
63481: ST_TO_ADDR
// if sort then
63482: LD_VAR 0 9
63486: IFFALSE 63602
// for i = 1 to 4 - eng do
63488: LD_ADDR_VAR 0 3
63492: PUSH
63493: DOUBLE
63494: LD_INT 1
63496: DEC
63497: ST_TO_ADDR
63498: LD_INT 4
63500: PUSH
63501: LD_VAR 0 6
63505: MINUS
63506: PUSH
63507: FOR_TO
63508: IFFALSE 63600
// begin if i = sort then
63510: LD_VAR 0 3
63514: PUSH
63515: LD_VAR 0 9
63519: EQUAL
63520: IFFALSE 63524
// break ;
63522: GO 63600
// if GetClass ( i ) = 2 then
63524: LD_VAR 0 3
63528: PPUSH
63529: CALL_OW 257
63533: PUSH
63534: LD_INT 2
63536: EQUAL
63537: IFFALSE 63541
// continue ;
63539: GO 63507
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63541: LD_ADDR_VAR 0 11
63545: PUSH
63546: LD_VAR 0 11
63550: PPUSH
63551: LD_VAR 0 11
63555: PUSH
63556: LD_INT 1
63558: PLUS
63559: PPUSH
63560: LD_VAR 0 9
63564: PUSH
63565: LD_VAR 0 3
63569: ARRAY
63570: PPUSH
63571: CALL_OW 2
63575: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63576: LD_ADDR_VAR 0 4
63580: PUSH
63581: LD_VAR 0 4
63585: PUSH
63586: LD_VAR 0 9
63590: PUSH
63591: LD_VAR 0 3
63595: ARRAY
63596: DIFF
63597: ST_TO_ADDR
// end ;
63598: GO 63507
63600: POP
63601: POP
// if p then
63602: LD_VAR 0 11
63606: IFFALSE 63631
// result := Replace ( result , 2 , p ) ;
63608: LD_ADDR_VAR 0 2
63612: PUSH
63613: LD_VAR 0 2
63617: PPUSH
63618: LD_INT 2
63620: PPUSH
63621: LD_VAR 0 11
63625: PPUSH
63626: CALL_OW 1
63630: ST_TO_ADDR
// end else
63631: GO 63677
// for i = eng downto 5 do
63633: LD_ADDR_VAR 0 3
63637: PUSH
63638: DOUBLE
63639: LD_VAR 0 6
63643: INC
63644: ST_TO_ADDR
63645: LD_INT 5
63647: PUSH
63648: FOR_DOWNTO
63649: IFFALSE 63675
// tmp := tmp union eng [ i ] ;
63651: LD_ADDR_VAR 0 4
63655: PUSH
63656: LD_VAR 0 4
63660: PUSH
63661: LD_VAR 0 6
63665: PUSH
63666: LD_VAR 0 3
63670: ARRAY
63671: UNION
63672: ST_TO_ADDR
63673: GO 63648
63675: POP
63676: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63677: LD_ADDR_VAR 0 2
63681: PUSH
63682: LD_VAR 0 2
63686: PPUSH
63687: LD_INT 1
63689: PPUSH
63690: LD_VAR 0 4
63694: PUSH
63695: LD_VAR 0 5
63699: DIFF
63700: PPUSH
63701: CALL_OW 1
63705: ST_TO_ADDR
// exit ;
63706: GO 63708
// end ; end ;
63708: LD_VAR 0 2
63712: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63713: LD_INT 0
63715: PPUSH
63716: PPUSH
63717: PPUSH
// if not mc_bases then
63718: LD_EXP 58
63722: NOT
63723: IFFALSE 63727
// exit ;
63725: GO 63833
// for i = 1 to mc_bases do
63727: LD_ADDR_VAR 0 2
63731: PUSH
63732: DOUBLE
63733: LD_INT 1
63735: DEC
63736: ST_TO_ADDR
63737: LD_EXP 58
63741: PUSH
63742: FOR_TO
63743: IFFALSE 63824
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63745: LD_ADDR_VAR 0 3
63749: PUSH
63750: LD_EXP 58
63754: PUSH
63755: LD_VAR 0 2
63759: ARRAY
63760: PPUSH
63761: LD_INT 21
63763: PUSH
63764: LD_INT 3
63766: PUSH
63767: EMPTY
63768: LIST
63769: LIST
63770: PUSH
63771: LD_INT 3
63773: PUSH
63774: LD_INT 24
63776: PUSH
63777: LD_INT 1000
63779: PUSH
63780: EMPTY
63781: LIST
63782: LIST
63783: PUSH
63784: EMPTY
63785: LIST
63786: LIST
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PPUSH
63792: CALL_OW 72
63796: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63797: LD_ADDR_EXP 59
63801: PUSH
63802: LD_EXP 59
63806: PPUSH
63807: LD_VAR 0 2
63811: PPUSH
63812: LD_VAR 0 3
63816: PPUSH
63817: CALL_OW 1
63821: ST_TO_ADDR
// end ;
63822: GO 63742
63824: POP
63825: POP
// RaiseSailEvent ( 101 ) ;
63826: LD_INT 101
63828: PPUSH
63829: CALL_OW 427
// end ;
63833: LD_VAR 0 1
63837: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63838: LD_INT 0
63840: PPUSH
63841: PPUSH
63842: PPUSH
63843: PPUSH
63844: PPUSH
63845: PPUSH
63846: PPUSH
// if not mc_bases then
63847: LD_EXP 58
63851: NOT
63852: IFFALSE 63856
// exit ;
63854: GO 64429
// for i = 1 to mc_bases do
63856: LD_ADDR_VAR 0 2
63860: PUSH
63861: DOUBLE
63862: LD_INT 1
63864: DEC
63865: ST_TO_ADDR
63866: LD_EXP 58
63870: PUSH
63871: FOR_TO
63872: IFFALSE 64420
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
63874: LD_ADDR_VAR 0 5
63878: PUSH
63879: LD_EXP 58
63883: PUSH
63884: LD_VAR 0 2
63888: ARRAY
63889: PUSH
63890: LD_EXP 87
63894: PUSH
63895: LD_VAR 0 2
63899: ARRAY
63900: UNION
63901: PPUSH
63902: LD_INT 21
63904: PUSH
63905: LD_INT 1
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: LD_INT 1
63914: PUSH
63915: LD_INT 3
63917: PUSH
63918: LD_INT 54
63920: PUSH
63921: EMPTY
63922: LIST
63923: PUSH
63924: EMPTY
63925: LIST
63926: LIST
63927: PUSH
63928: LD_INT 3
63930: PUSH
63931: LD_INT 24
63933: PUSH
63934: LD_INT 750
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: EMPTY
63942: LIST
63943: LIST
63944: PUSH
63945: EMPTY
63946: LIST
63947: LIST
63948: LIST
63949: PUSH
63950: EMPTY
63951: LIST
63952: LIST
63953: PPUSH
63954: CALL_OW 72
63958: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63959: LD_ADDR_VAR 0 6
63963: PUSH
63964: LD_EXP 58
63968: PUSH
63969: LD_VAR 0 2
63973: ARRAY
63974: PPUSH
63975: LD_INT 21
63977: PUSH
63978: LD_INT 1
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: PUSH
63985: LD_INT 1
63987: PUSH
63988: LD_INT 3
63990: PUSH
63991: LD_INT 54
63993: PUSH
63994: EMPTY
63995: LIST
63996: PUSH
63997: EMPTY
63998: LIST
63999: LIST
64000: PUSH
64001: LD_INT 3
64003: PUSH
64004: LD_INT 24
64006: PUSH
64007: LD_INT 250
64009: PUSH
64010: EMPTY
64011: LIST
64012: LIST
64013: PUSH
64014: EMPTY
64015: LIST
64016: LIST
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: LIST
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PPUSH
64027: CALL_OW 72
64031: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
64032: LD_ADDR_VAR 0 7
64036: PUSH
64037: LD_VAR 0 5
64041: PUSH
64042: LD_VAR 0 6
64046: DIFF
64047: ST_TO_ADDR
// if not need_heal_1 then
64048: LD_VAR 0 6
64052: NOT
64053: IFFALSE 64086
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
64055: LD_ADDR_EXP 61
64059: PUSH
64060: LD_EXP 61
64064: PPUSH
64065: LD_VAR 0 2
64069: PUSH
64070: LD_INT 1
64072: PUSH
64073: EMPTY
64074: LIST
64075: LIST
64076: PPUSH
64077: EMPTY
64078: PPUSH
64079: CALL 20665 0 3
64083: ST_TO_ADDR
64084: GO 64156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
64086: LD_ADDR_EXP 61
64090: PUSH
64091: LD_EXP 61
64095: PPUSH
64096: LD_VAR 0 2
64100: PUSH
64101: LD_INT 1
64103: PUSH
64104: EMPTY
64105: LIST
64106: LIST
64107: PPUSH
64108: LD_EXP 61
64112: PUSH
64113: LD_VAR 0 2
64117: ARRAY
64118: PUSH
64119: LD_INT 1
64121: ARRAY
64122: PPUSH
64123: LD_INT 3
64125: PUSH
64126: LD_INT 24
64128: PUSH
64129: LD_INT 1000
64131: PUSH
64132: EMPTY
64133: LIST
64134: LIST
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PPUSH
64140: CALL_OW 72
64144: PUSH
64145: LD_VAR 0 6
64149: UNION
64150: PPUSH
64151: CALL 20665 0 3
64155: ST_TO_ADDR
// if not need_heal_2 then
64156: LD_VAR 0 7
64160: NOT
64161: IFFALSE 64194
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
64163: LD_ADDR_EXP 61
64167: PUSH
64168: LD_EXP 61
64172: PPUSH
64173: LD_VAR 0 2
64177: PUSH
64178: LD_INT 2
64180: PUSH
64181: EMPTY
64182: LIST
64183: LIST
64184: PPUSH
64185: EMPTY
64186: PPUSH
64187: CALL 20665 0 3
64191: ST_TO_ADDR
64192: GO 64226
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64194: LD_ADDR_EXP 61
64198: PUSH
64199: LD_EXP 61
64203: PPUSH
64204: LD_VAR 0 2
64208: PUSH
64209: LD_INT 2
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PPUSH
64216: LD_VAR 0 7
64220: PPUSH
64221: CALL 20665 0 3
64225: ST_TO_ADDR
// if need_heal_2 then
64226: LD_VAR 0 7
64230: IFFALSE 64402
// for j in need_heal_2 do
64232: LD_ADDR_VAR 0 3
64236: PUSH
64237: LD_VAR 0 7
64241: PUSH
64242: FOR_IN
64243: IFFALSE 64400
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
64245: LD_ADDR_VAR 0 5
64249: PUSH
64250: LD_EXP 58
64254: PUSH
64255: LD_VAR 0 2
64259: ARRAY
64260: PPUSH
64261: LD_INT 2
64263: PUSH
64264: LD_INT 30
64266: PUSH
64267: LD_INT 6
64269: PUSH
64270: EMPTY
64271: LIST
64272: LIST
64273: PUSH
64274: LD_INT 30
64276: PUSH
64277: LD_INT 7
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: LD_INT 30
64286: PUSH
64287: LD_INT 8
64289: PUSH
64290: EMPTY
64291: LIST
64292: LIST
64293: PUSH
64294: LD_INT 30
64296: PUSH
64297: LD_INT 0
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 30
64306: PUSH
64307: LD_INT 1
64309: PUSH
64310: EMPTY
64311: LIST
64312: LIST
64313: PUSH
64314: LD_INT 25
64316: PUSH
64317: LD_INT 4
64319: PUSH
64320: EMPTY
64321: LIST
64322: LIST
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: PPUSH
64333: CALL_OW 72
64337: ST_TO_ADDR
// if tmp then
64338: LD_VAR 0 5
64342: IFFALSE 64398
// begin k := NearestUnitToUnit ( tmp , j ) ;
64344: LD_ADDR_VAR 0 4
64348: PUSH
64349: LD_VAR 0 5
64353: PPUSH
64354: LD_VAR 0 3
64358: PPUSH
64359: CALL_OW 74
64363: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
64364: LD_VAR 0 3
64368: PPUSH
64369: LD_VAR 0 4
64373: PPUSH
64374: CALL_OW 296
64378: PUSH
64379: LD_INT 7
64381: GREATER
64382: IFFALSE 64398
// ComMoveUnit ( j , k ) ;
64384: LD_VAR 0 3
64388: PPUSH
64389: LD_VAR 0 4
64393: PPUSH
64394: CALL_OW 112
// end ; end ;
64398: GO 64242
64400: POP
64401: POP
// if not need_heal_1 and not need_heal_2 then
64402: LD_VAR 0 6
64406: NOT
64407: PUSH
64408: LD_VAR 0 7
64412: NOT
64413: AND
64414: IFFALSE 64418
// continue ;
64416: GO 63871
// end ;
64418: GO 63871
64420: POP
64421: POP
// RaiseSailEvent ( 102 ) ;
64422: LD_INT 102
64424: PPUSH
64425: CALL_OW 427
// end ;
64429: LD_VAR 0 1
64433: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
64434: LD_INT 0
64436: PPUSH
64437: PPUSH
64438: PPUSH
64439: PPUSH
64440: PPUSH
// if not mc_bases then
64441: LD_EXP 58
64445: NOT
64446: IFFALSE 64450
// exit ;
64448: GO 64835
// for i = 1 to mc_bases do
64450: LD_ADDR_VAR 0 2
64454: PUSH
64455: DOUBLE
64456: LD_INT 1
64458: DEC
64459: ST_TO_ADDR
64460: LD_EXP 58
64464: PUSH
64465: FOR_TO
64466: IFFALSE 64833
// begin if not mc_building_need_repair [ i ] then
64468: LD_EXP 59
64472: PUSH
64473: LD_VAR 0 2
64477: ARRAY
64478: NOT
64479: IFFALSE 64517
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64481: LD_ADDR_EXP 60
64485: PUSH
64486: LD_EXP 60
64490: PPUSH
64491: LD_VAR 0 2
64495: PPUSH
64496: EMPTY
64497: PPUSH
64498: CALL_OW 1
64502: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64503: LD_VAR 0 2
64507: PPUSH
64508: LD_INT 101
64510: PPUSH
64511: CALL 59555 0 2
// continue ;
64515: GO 64465
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64517: LD_ADDR_EXP 64
64521: PUSH
64522: LD_EXP 64
64526: PPUSH
64527: LD_VAR 0 2
64531: PPUSH
64532: EMPTY
64533: PPUSH
64534: CALL_OW 1
64538: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64539: LD_VAR 0 2
64543: PPUSH
64544: LD_INT 103
64546: PPUSH
64547: CALL 59555 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64551: LD_ADDR_VAR 0 5
64555: PUSH
64556: LD_EXP 58
64560: PUSH
64561: LD_VAR 0 2
64565: ARRAY
64566: PUSH
64567: LD_EXP 87
64571: PUSH
64572: LD_VAR 0 2
64576: ARRAY
64577: UNION
64578: PPUSH
64579: LD_INT 2
64581: PUSH
64582: LD_INT 25
64584: PUSH
64585: LD_INT 2
64587: PUSH
64588: EMPTY
64589: LIST
64590: LIST
64591: PUSH
64592: LD_INT 25
64594: PUSH
64595: LD_INT 16
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PUSH
64602: EMPTY
64603: LIST
64604: LIST
64605: LIST
64606: PUSH
64607: EMPTY
64608: LIST
64609: PPUSH
64610: CALL_OW 72
64614: ST_TO_ADDR
// if not tmp then
64615: LD_VAR 0 5
64619: NOT
64620: IFFALSE 64624
// continue ;
64622: GO 64465
// for j in tmp do
64624: LD_ADDR_VAR 0 3
64628: PUSH
64629: LD_VAR 0 5
64633: PUSH
64634: FOR_IN
64635: IFFALSE 64829
// begin if mc_need_heal [ i ] then
64637: LD_EXP 61
64641: PUSH
64642: LD_VAR 0 2
64646: ARRAY
64647: IFFALSE 64695
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
64649: LD_VAR 0 3
64653: PUSH
64654: LD_EXP 61
64658: PUSH
64659: LD_VAR 0 2
64663: ARRAY
64664: PUSH
64665: LD_INT 1
64667: ARRAY
64668: IN
64669: PUSH
64670: LD_VAR 0 3
64674: PUSH
64675: LD_EXP 61
64679: PUSH
64680: LD_VAR 0 2
64684: ARRAY
64685: PUSH
64686: LD_INT 2
64688: ARRAY
64689: IN
64690: OR
64691: IFFALSE 64695
// continue ;
64693: GO 64634
// if IsInUnit ( j ) then
64695: LD_VAR 0 3
64699: PPUSH
64700: CALL_OW 310
64704: IFFALSE 64715
// ComExitBuilding ( j ) ;
64706: LD_VAR 0 3
64710: PPUSH
64711: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64715: LD_VAR 0 3
64719: PUSH
64720: LD_EXP 60
64724: PUSH
64725: LD_VAR 0 2
64729: ARRAY
64730: IN
64731: NOT
64732: IFFALSE 64790
// begin SetTag ( j , 101 ) ;
64734: LD_VAR 0 3
64738: PPUSH
64739: LD_INT 101
64741: PPUSH
64742: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64746: LD_ADDR_EXP 60
64750: PUSH
64751: LD_EXP 60
64755: PPUSH
64756: LD_VAR 0 2
64760: PUSH
64761: LD_EXP 60
64765: PUSH
64766: LD_VAR 0 2
64770: ARRAY
64771: PUSH
64772: LD_INT 1
64774: PLUS
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PPUSH
64780: LD_VAR 0 3
64784: PPUSH
64785: CALL 20665 0 3
64789: ST_TO_ADDR
// end ; wait ( 1 ) ;
64790: LD_INT 1
64792: PPUSH
64793: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
64797: LD_VAR 0 3
64801: PPUSH
64802: LD_EXP 59
64806: PUSH
64807: LD_VAR 0 2
64811: ARRAY
64812: PPUSH
64813: LD_VAR 0 3
64817: PPUSH
64818: CALL_OW 74
64822: PPUSH
64823: CALL_OW 130
// end ;
64827: GO 64634
64829: POP
64830: POP
// end ;
64831: GO 64465
64833: POP
64834: POP
// end ;
64835: LD_VAR 0 1
64839: RET
// export function MC_Heal ; var i , j , tmp ; begin
64840: LD_INT 0
64842: PPUSH
64843: PPUSH
64844: PPUSH
64845: PPUSH
// if not mc_bases then
64846: LD_EXP 58
64850: NOT
64851: IFFALSE 64855
// exit ;
64853: GO 65257
// for i = 1 to mc_bases do
64855: LD_ADDR_VAR 0 2
64859: PUSH
64860: DOUBLE
64861: LD_INT 1
64863: DEC
64864: ST_TO_ADDR
64865: LD_EXP 58
64869: PUSH
64870: FOR_TO
64871: IFFALSE 65255
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64873: LD_EXP 61
64877: PUSH
64878: LD_VAR 0 2
64882: ARRAY
64883: PUSH
64884: LD_INT 1
64886: ARRAY
64887: NOT
64888: PUSH
64889: LD_EXP 61
64893: PUSH
64894: LD_VAR 0 2
64898: ARRAY
64899: PUSH
64900: LD_INT 2
64902: ARRAY
64903: NOT
64904: AND
64905: IFFALSE 64943
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64907: LD_ADDR_EXP 62
64911: PUSH
64912: LD_EXP 62
64916: PPUSH
64917: LD_VAR 0 2
64921: PPUSH
64922: EMPTY
64923: PPUSH
64924: CALL_OW 1
64928: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64929: LD_VAR 0 2
64933: PPUSH
64934: LD_INT 102
64936: PPUSH
64937: CALL 59555 0 2
// continue ;
64941: GO 64870
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64943: LD_ADDR_VAR 0 4
64947: PUSH
64948: LD_EXP 58
64952: PUSH
64953: LD_VAR 0 2
64957: ARRAY
64958: PPUSH
64959: LD_INT 25
64961: PUSH
64962: LD_INT 4
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: PPUSH
64969: CALL_OW 72
64973: ST_TO_ADDR
// if not tmp then
64974: LD_VAR 0 4
64978: NOT
64979: IFFALSE 64983
// continue ;
64981: GO 64870
// if mc_taming [ i ] then
64983: LD_EXP 89
64987: PUSH
64988: LD_VAR 0 2
64992: ARRAY
64993: IFFALSE 65017
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64995: LD_ADDR_EXP 89
64999: PUSH
65000: LD_EXP 89
65004: PPUSH
65005: LD_VAR 0 2
65009: PPUSH
65010: EMPTY
65011: PPUSH
65012: CALL_OW 1
65016: ST_TO_ADDR
// for j in tmp do
65017: LD_ADDR_VAR 0 3
65021: PUSH
65022: LD_VAR 0 4
65026: PUSH
65027: FOR_IN
65028: IFFALSE 65251
// begin if IsInUnit ( j ) then
65030: LD_VAR 0 3
65034: PPUSH
65035: CALL_OW 310
65039: IFFALSE 65050
// ComExitBuilding ( j ) ;
65041: LD_VAR 0 3
65045: PPUSH
65046: CALL_OW 122
// if not j in mc_healers [ i ] then
65050: LD_VAR 0 3
65054: PUSH
65055: LD_EXP 62
65059: PUSH
65060: LD_VAR 0 2
65064: ARRAY
65065: IN
65066: NOT
65067: IFFALSE 65113
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65069: LD_ADDR_EXP 62
65073: PUSH
65074: LD_EXP 62
65078: PPUSH
65079: LD_VAR 0 2
65083: PUSH
65084: LD_EXP 62
65088: PUSH
65089: LD_VAR 0 2
65093: ARRAY
65094: PUSH
65095: LD_INT 1
65097: PLUS
65098: PUSH
65099: EMPTY
65100: LIST
65101: LIST
65102: PPUSH
65103: LD_VAR 0 3
65107: PPUSH
65108: CALL 20665 0 3
65112: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65113: LD_VAR 0 3
65117: PPUSH
65118: CALL_OW 110
65122: PUSH
65123: LD_INT 102
65125: NONEQUAL
65126: IFFALSE 65140
// SetTag ( j , 102 ) ;
65128: LD_VAR 0 3
65132: PPUSH
65133: LD_INT 102
65135: PPUSH
65136: CALL_OW 109
// Wait ( 3 ) ;
65140: LD_INT 3
65142: PPUSH
65143: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65147: LD_EXP 61
65151: PUSH
65152: LD_VAR 0 2
65156: ARRAY
65157: PUSH
65158: LD_INT 1
65160: ARRAY
65161: IFFALSE 65193
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65163: LD_VAR 0 3
65167: PPUSH
65168: LD_EXP 61
65172: PUSH
65173: LD_VAR 0 2
65177: ARRAY
65178: PUSH
65179: LD_INT 1
65181: ARRAY
65182: PUSH
65183: LD_INT 1
65185: ARRAY
65186: PPUSH
65187: CALL_OW 128
65191: GO 65249
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65193: LD_VAR 0 3
65197: PPUSH
65198: CALL_OW 314
65202: NOT
65203: PUSH
65204: LD_EXP 61
65208: PUSH
65209: LD_VAR 0 2
65213: ARRAY
65214: PUSH
65215: LD_INT 2
65217: ARRAY
65218: AND
65219: IFFALSE 65249
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65221: LD_VAR 0 3
65225: PPUSH
65226: LD_EXP 61
65230: PUSH
65231: LD_VAR 0 2
65235: ARRAY
65236: PUSH
65237: LD_INT 2
65239: ARRAY
65240: PUSH
65241: LD_INT 1
65243: ARRAY
65244: PPUSH
65245: CALL_OW 128
// end ;
65249: GO 65027
65251: POP
65252: POP
// end ;
65253: GO 64870
65255: POP
65256: POP
// end ;
65257: LD_VAR 0 1
65261: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65262: LD_INT 0
65264: PPUSH
65265: PPUSH
65266: PPUSH
65267: PPUSH
65268: PPUSH
// if not mc_bases then
65269: LD_EXP 58
65273: NOT
65274: IFFALSE 65278
// exit ;
65276: GO 66421
// for i = 1 to mc_bases do
65278: LD_ADDR_VAR 0 2
65282: PUSH
65283: DOUBLE
65284: LD_INT 1
65286: DEC
65287: ST_TO_ADDR
65288: LD_EXP 58
65292: PUSH
65293: FOR_TO
65294: IFFALSE 66419
// begin if mc_scan [ i ] then
65296: LD_EXP 81
65300: PUSH
65301: LD_VAR 0 2
65305: ARRAY
65306: IFFALSE 65310
// continue ;
65308: GO 65293
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65310: LD_EXP 63
65314: PUSH
65315: LD_VAR 0 2
65319: ARRAY
65320: NOT
65321: PUSH
65322: LD_EXP 65
65326: PUSH
65327: LD_VAR 0 2
65331: ARRAY
65332: NOT
65333: AND
65334: PUSH
65335: LD_EXP 64
65339: PUSH
65340: LD_VAR 0 2
65344: ARRAY
65345: AND
65346: IFFALSE 65384
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65348: LD_ADDR_EXP 64
65352: PUSH
65353: LD_EXP 64
65357: PPUSH
65358: LD_VAR 0 2
65362: PPUSH
65363: EMPTY
65364: PPUSH
65365: CALL_OW 1
65369: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65370: LD_VAR 0 2
65374: PPUSH
65375: LD_INT 103
65377: PPUSH
65378: CALL 59555 0 2
// continue ;
65382: GO 65293
// end ; if mc_construct_list [ i ] then
65384: LD_EXP 65
65388: PUSH
65389: LD_VAR 0 2
65393: ARRAY
65394: IFFALSE 65614
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65396: LD_ADDR_VAR 0 4
65400: PUSH
65401: LD_EXP 58
65405: PUSH
65406: LD_VAR 0 2
65410: ARRAY
65411: PPUSH
65412: LD_INT 25
65414: PUSH
65415: LD_INT 2
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PPUSH
65422: CALL_OW 72
65426: PUSH
65427: LD_EXP 60
65431: PUSH
65432: LD_VAR 0 2
65436: ARRAY
65437: DIFF
65438: ST_TO_ADDR
// if not tmp then
65439: LD_VAR 0 4
65443: NOT
65444: IFFALSE 65448
// continue ;
65446: GO 65293
// for j in tmp do
65448: LD_ADDR_VAR 0 3
65452: PUSH
65453: LD_VAR 0 4
65457: PUSH
65458: FOR_IN
65459: IFFALSE 65610
// begin if not mc_builders [ i ] then
65461: LD_EXP 64
65465: PUSH
65466: LD_VAR 0 2
65470: ARRAY
65471: NOT
65472: IFFALSE 65530
// begin SetTag ( j , 103 ) ;
65474: LD_VAR 0 3
65478: PPUSH
65479: LD_INT 103
65481: PPUSH
65482: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65486: LD_ADDR_EXP 64
65490: PUSH
65491: LD_EXP 64
65495: PPUSH
65496: LD_VAR 0 2
65500: PUSH
65501: LD_EXP 64
65505: PUSH
65506: LD_VAR 0 2
65510: ARRAY
65511: PUSH
65512: LD_INT 1
65514: PLUS
65515: PUSH
65516: EMPTY
65517: LIST
65518: LIST
65519: PPUSH
65520: LD_VAR 0 3
65524: PPUSH
65525: CALL 20665 0 3
65529: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65530: LD_VAR 0 3
65534: PPUSH
65535: CALL_OW 310
65539: IFFALSE 65550
// ComExitBuilding ( j ) ;
65541: LD_VAR 0 3
65545: PPUSH
65546: CALL_OW 122
// wait ( 3 ) ;
65550: LD_INT 3
65552: PPUSH
65553: CALL_OW 67
// if not mc_construct_list [ i ] then
65557: LD_EXP 65
65561: PUSH
65562: LD_VAR 0 2
65566: ARRAY
65567: NOT
65568: IFFALSE 65572
// break ;
65570: GO 65610
// if not HasTask ( j ) then
65572: LD_VAR 0 3
65576: PPUSH
65577: CALL_OW 314
65581: NOT
65582: IFFALSE 65608
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65584: LD_VAR 0 3
65588: PPUSH
65589: LD_EXP 65
65593: PUSH
65594: LD_VAR 0 2
65598: ARRAY
65599: PUSH
65600: LD_INT 1
65602: ARRAY
65603: PPUSH
65604: CALL 23516 0 2
// end ;
65608: GO 65458
65610: POP
65611: POP
// end else
65612: GO 66417
// if mc_build_list [ i ] then
65614: LD_EXP 63
65618: PUSH
65619: LD_VAR 0 2
65623: ARRAY
65624: IFFALSE 66417
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65626: LD_ADDR_VAR 0 5
65630: PUSH
65631: LD_EXP 58
65635: PUSH
65636: LD_VAR 0 2
65640: ARRAY
65641: PPUSH
65642: LD_INT 2
65644: PUSH
65645: LD_INT 30
65647: PUSH
65648: LD_INT 0
65650: PUSH
65651: EMPTY
65652: LIST
65653: LIST
65654: PUSH
65655: LD_INT 30
65657: PUSH
65658: LD_INT 1
65660: PUSH
65661: EMPTY
65662: LIST
65663: LIST
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: LIST
65669: PPUSH
65670: CALL_OW 72
65674: ST_TO_ADDR
// if depot then
65675: LD_VAR 0 5
65679: IFFALSE 65697
// depot := depot [ 1 ] else
65681: LD_ADDR_VAR 0 5
65685: PUSH
65686: LD_VAR 0 5
65690: PUSH
65691: LD_INT 1
65693: ARRAY
65694: ST_TO_ADDR
65695: GO 65705
// depot := 0 ;
65697: LD_ADDR_VAR 0 5
65701: PUSH
65702: LD_INT 0
65704: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65705: LD_EXP 63
65709: PUSH
65710: LD_VAR 0 2
65714: ARRAY
65715: PUSH
65716: LD_INT 1
65718: ARRAY
65719: PUSH
65720: LD_INT 1
65722: ARRAY
65723: PPUSH
65724: CALL 23346 0 1
65728: PUSH
65729: LD_EXP 58
65733: PUSH
65734: LD_VAR 0 2
65738: ARRAY
65739: PPUSH
65740: LD_INT 2
65742: PUSH
65743: LD_INT 30
65745: PUSH
65746: LD_INT 2
65748: PUSH
65749: EMPTY
65750: LIST
65751: LIST
65752: PUSH
65753: LD_INT 30
65755: PUSH
65756: LD_INT 3
65758: PUSH
65759: EMPTY
65760: LIST
65761: LIST
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: LIST
65767: PPUSH
65768: CALL_OW 72
65772: NOT
65773: AND
65774: IFFALSE 65879
// begin for j = 1 to mc_build_list [ i ] do
65776: LD_ADDR_VAR 0 3
65780: PUSH
65781: DOUBLE
65782: LD_INT 1
65784: DEC
65785: ST_TO_ADDR
65786: LD_EXP 63
65790: PUSH
65791: LD_VAR 0 2
65795: ARRAY
65796: PUSH
65797: FOR_TO
65798: IFFALSE 65877
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65800: LD_EXP 63
65804: PUSH
65805: LD_VAR 0 2
65809: ARRAY
65810: PUSH
65811: LD_VAR 0 3
65815: ARRAY
65816: PUSH
65817: LD_INT 1
65819: ARRAY
65820: PUSH
65821: LD_INT 2
65823: EQUAL
65824: IFFALSE 65875
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65826: LD_ADDR_EXP 63
65830: PUSH
65831: LD_EXP 63
65835: PPUSH
65836: LD_VAR 0 2
65840: PPUSH
65841: LD_EXP 63
65845: PUSH
65846: LD_VAR 0 2
65850: ARRAY
65851: PPUSH
65852: LD_VAR 0 3
65856: PPUSH
65857: LD_INT 1
65859: PPUSH
65860: LD_INT 0
65862: PPUSH
65863: CALL 20083 0 4
65867: PPUSH
65868: CALL_OW 1
65872: ST_TO_ADDR
// break ;
65873: GO 65877
// end ;
65875: GO 65797
65877: POP
65878: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65879: LD_EXP 63
65883: PUSH
65884: LD_VAR 0 2
65888: ARRAY
65889: PUSH
65890: LD_INT 1
65892: ARRAY
65893: PUSH
65894: LD_INT 1
65896: ARRAY
65897: PUSH
65898: LD_INT 0
65900: EQUAL
65901: PUSH
65902: LD_VAR 0 5
65906: PUSH
65907: LD_VAR 0 5
65911: PPUSH
65912: LD_EXP 63
65916: PUSH
65917: LD_VAR 0 2
65921: ARRAY
65922: PUSH
65923: LD_INT 1
65925: ARRAY
65926: PUSH
65927: LD_INT 1
65929: ARRAY
65930: PPUSH
65931: LD_EXP 63
65935: PUSH
65936: LD_VAR 0 2
65940: ARRAY
65941: PUSH
65942: LD_INT 1
65944: ARRAY
65945: PUSH
65946: LD_INT 2
65948: ARRAY
65949: PPUSH
65950: LD_EXP 63
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: PUSH
65961: LD_INT 1
65963: ARRAY
65964: PUSH
65965: LD_INT 3
65967: ARRAY
65968: PPUSH
65969: LD_EXP 63
65973: PUSH
65974: LD_VAR 0 2
65978: ARRAY
65979: PUSH
65980: LD_INT 1
65982: ARRAY
65983: PUSH
65984: LD_INT 4
65986: ARRAY
65987: PPUSH
65988: CALL 28062 0 5
65992: AND
65993: OR
65994: IFFALSE 66275
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65996: LD_ADDR_VAR 0 4
66000: PUSH
66001: LD_EXP 58
66005: PUSH
66006: LD_VAR 0 2
66010: ARRAY
66011: PPUSH
66012: LD_INT 25
66014: PUSH
66015: LD_INT 2
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PPUSH
66022: CALL_OW 72
66026: PUSH
66027: LD_EXP 60
66031: PUSH
66032: LD_VAR 0 2
66036: ARRAY
66037: DIFF
66038: ST_TO_ADDR
// if not tmp then
66039: LD_VAR 0 4
66043: NOT
66044: IFFALSE 66048
// continue ;
66046: GO 65293
// for j in tmp do
66048: LD_ADDR_VAR 0 3
66052: PUSH
66053: LD_VAR 0 4
66057: PUSH
66058: FOR_IN
66059: IFFALSE 66271
// begin if not mc_builders [ i ] then
66061: LD_EXP 64
66065: PUSH
66066: LD_VAR 0 2
66070: ARRAY
66071: NOT
66072: IFFALSE 66130
// begin SetTag ( j , 103 ) ;
66074: LD_VAR 0 3
66078: PPUSH
66079: LD_INT 103
66081: PPUSH
66082: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66086: LD_ADDR_EXP 64
66090: PUSH
66091: LD_EXP 64
66095: PPUSH
66096: LD_VAR 0 2
66100: PUSH
66101: LD_EXP 64
66105: PUSH
66106: LD_VAR 0 2
66110: ARRAY
66111: PUSH
66112: LD_INT 1
66114: PLUS
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PPUSH
66120: LD_VAR 0 3
66124: PPUSH
66125: CALL 20665 0 3
66129: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66130: LD_VAR 0 3
66134: PPUSH
66135: CALL_OW 310
66139: IFFALSE 66150
// ComExitBuilding ( j ) ;
66141: LD_VAR 0 3
66145: PPUSH
66146: CALL_OW 122
// wait ( 3 ) ;
66150: LD_INT 3
66152: PPUSH
66153: CALL_OW 67
// if not mc_build_list [ i ] then
66157: LD_EXP 63
66161: PUSH
66162: LD_VAR 0 2
66166: ARRAY
66167: NOT
66168: IFFALSE 66172
// break ;
66170: GO 66271
// if not HasTask ( j ) then
66172: LD_VAR 0 3
66176: PPUSH
66177: CALL_OW 314
66181: NOT
66182: IFFALSE 66269
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66184: LD_VAR 0 3
66188: PPUSH
66189: LD_EXP 63
66193: PUSH
66194: LD_VAR 0 2
66198: ARRAY
66199: PUSH
66200: LD_INT 1
66202: ARRAY
66203: PUSH
66204: LD_INT 1
66206: ARRAY
66207: PPUSH
66208: LD_EXP 63
66212: PUSH
66213: LD_VAR 0 2
66217: ARRAY
66218: PUSH
66219: LD_INT 1
66221: ARRAY
66222: PUSH
66223: LD_INT 2
66225: ARRAY
66226: PPUSH
66227: LD_EXP 63
66231: PUSH
66232: LD_VAR 0 2
66236: ARRAY
66237: PUSH
66238: LD_INT 1
66240: ARRAY
66241: PUSH
66242: LD_INT 3
66244: ARRAY
66245: PPUSH
66246: LD_EXP 63
66250: PUSH
66251: LD_VAR 0 2
66255: ARRAY
66256: PUSH
66257: LD_INT 1
66259: ARRAY
66260: PUSH
66261: LD_INT 4
66263: ARRAY
66264: PPUSH
66265: CALL_OW 145
// end ;
66269: GO 66058
66271: POP
66272: POP
// end else
66273: GO 66417
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
66275: LD_EXP 58
66279: PUSH
66280: LD_VAR 0 2
66284: ARRAY
66285: PPUSH
66286: LD_EXP 63
66290: PUSH
66291: LD_VAR 0 2
66295: ARRAY
66296: PUSH
66297: LD_INT 1
66299: ARRAY
66300: PUSH
66301: LD_INT 1
66303: ARRAY
66304: PPUSH
66305: LD_EXP 63
66309: PUSH
66310: LD_VAR 0 2
66314: ARRAY
66315: PUSH
66316: LD_INT 1
66318: ARRAY
66319: PUSH
66320: LD_INT 2
66322: ARRAY
66323: PPUSH
66324: LD_EXP 63
66328: PUSH
66329: LD_VAR 0 2
66333: ARRAY
66334: PUSH
66335: LD_INT 1
66337: ARRAY
66338: PUSH
66339: LD_INT 3
66341: ARRAY
66342: PPUSH
66343: LD_EXP 63
66347: PUSH
66348: LD_VAR 0 2
66352: ARRAY
66353: PUSH
66354: LD_INT 1
66356: ARRAY
66357: PUSH
66358: LD_INT 4
66360: ARRAY
66361: PPUSH
66362: CALL 27416 0 5
66366: NOT
66367: IFFALSE 66417
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66369: LD_ADDR_EXP 63
66373: PUSH
66374: LD_EXP 63
66378: PPUSH
66379: LD_VAR 0 2
66383: PPUSH
66384: LD_EXP 63
66388: PUSH
66389: LD_VAR 0 2
66393: ARRAY
66394: PPUSH
66395: LD_INT 1
66397: PPUSH
66398: LD_INT 1
66400: NEG
66401: PPUSH
66402: LD_INT 0
66404: PPUSH
66405: CALL 20083 0 4
66409: PPUSH
66410: CALL_OW 1
66414: ST_TO_ADDR
// continue ;
66415: GO 65293
// end ; end ; end ;
66417: GO 65293
66419: POP
66420: POP
// end ;
66421: LD_VAR 0 1
66425: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66426: LD_INT 0
66428: PPUSH
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
66433: PPUSH
// if not mc_bases then
66434: LD_EXP 58
66438: NOT
66439: IFFALSE 66443
// exit ;
66441: GO 66870
// for i = 1 to mc_bases do
66443: LD_ADDR_VAR 0 2
66447: PUSH
66448: DOUBLE
66449: LD_INT 1
66451: DEC
66452: ST_TO_ADDR
66453: LD_EXP 58
66457: PUSH
66458: FOR_TO
66459: IFFALSE 66868
// begin tmp := mc_build_upgrade [ i ] ;
66461: LD_ADDR_VAR 0 4
66465: PUSH
66466: LD_EXP 90
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66477: LD_ADDR_VAR 0 6
66481: PUSH
66482: LD_EXP 91
66486: PUSH
66487: LD_VAR 0 2
66491: ARRAY
66492: PPUSH
66493: LD_INT 2
66495: PUSH
66496: LD_INT 30
66498: PUSH
66499: LD_INT 6
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 30
66508: PUSH
66509: LD_INT 7
66511: PUSH
66512: EMPTY
66513: LIST
66514: LIST
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: LIST
66520: PPUSH
66521: CALL_OW 72
66525: ST_TO_ADDR
// if not tmp and not lab then
66526: LD_VAR 0 4
66530: NOT
66531: PUSH
66532: LD_VAR 0 6
66536: NOT
66537: AND
66538: IFFALSE 66542
// continue ;
66540: GO 66458
// if tmp then
66542: LD_VAR 0 4
66546: IFFALSE 66666
// for j in tmp do
66548: LD_ADDR_VAR 0 3
66552: PUSH
66553: LD_VAR 0 4
66557: PUSH
66558: FOR_IN
66559: IFFALSE 66664
// begin if UpgradeCost ( j ) then
66561: LD_VAR 0 3
66565: PPUSH
66566: CALL 27076 0 1
66570: IFFALSE 66662
// begin ComUpgrade ( j ) ;
66572: LD_VAR 0 3
66576: PPUSH
66577: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66581: LD_ADDR_EXP 90
66585: PUSH
66586: LD_EXP 90
66590: PPUSH
66591: LD_VAR 0 2
66595: PPUSH
66596: LD_EXP 90
66600: PUSH
66601: LD_VAR 0 2
66605: ARRAY
66606: PUSH
66607: LD_VAR 0 3
66611: DIFF
66612: PPUSH
66613: CALL_OW 1
66617: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66618: LD_ADDR_EXP 65
66622: PUSH
66623: LD_EXP 65
66627: PPUSH
66628: LD_VAR 0 2
66632: PUSH
66633: LD_EXP 65
66637: PUSH
66638: LD_VAR 0 2
66642: ARRAY
66643: PUSH
66644: LD_INT 1
66646: PLUS
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PPUSH
66652: LD_VAR 0 3
66656: PPUSH
66657: CALL 20665 0 3
66661: ST_TO_ADDR
// end ; end ;
66662: GO 66558
66664: POP
66665: POP
// if not lab or not mc_lab_upgrade [ i ] then
66666: LD_VAR 0 6
66670: NOT
66671: PUSH
66672: LD_EXP 92
66676: PUSH
66677: LD_VAR 0 2
66681: ARRAY
66682: NOT
66683: OR
66684: IFFALSE 66688
// continue ;
66686: GO 66458
// for j in lab do
66688: LD_ADDR_VAR 0 3
66692: PUSH
66693: LD_VAR 0 6
66697: PUSH
66698: FOR_IN
66699: IFFALSE 66864
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66701: LD_VAR 0 3
66705: PPUSH
66706: CALL_OW 266
66710: PUSH
66711: LD_INT 6
66713: PUSH
66714: LD_INT 7
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: IN
66721: PUSH
66722: LD_VAR 0 3
66726: PPUSH
66727: CALL_OW 461
66731: PUSH
66732: LD_INT 1
66734: NONEQUAL
66735: AND
66736: IFFALSE 66862
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66738: LD_VAR 0 3
66742: PPUSH
66743: LD_EXP 92
66747: PUSH
66748: LD_VAR 0 2
66752: ARRAY
66753: PUSH
66754: LD_INT 1
66756: ARRAY
66757: PPUSH
66758: CALL 27281 0 2
66762: IFFALSE 66862
// begin ComCancel ( j ) ;
66764: LD_VAR 0 3
66768: PPUSH
66769: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66773: LD_VAR 0 3
66777: PPUSH
66778: LD_EXP 92
66782: PUSH
66783: LD_VAR 0 2
66787: ARRAY
66788: PUSH
66789: LD_INT 1
66791: ARRAY
66792: PPUSH
66793: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66797: LD_VAR 0 3
66801: PUSH
66802: LD_EXP 65
66806: PUSH
66807: LD_VAR 0 2
66811: ARRAY
66812: IN
66813: NOT
66814: IFFALSE 66860
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66816: LD_ADDR_EXP 65
66820: PUSH
66821: LD_EXP 65
66825: PPUSH
66826: LD_VAR 0 2
66830: PUSH
66831: LD_EXP 65
66835: PUSH
66836: LD_VAR 0 2
66840: ARRAY
66841: PUSH
66842: LD_INT 1
66844: PLUS
66845: PUSH
66846: EMPTY
66847: LIST
66848: LIST
66849: PPUSH
66850: LD_VAR 0 3
66854: PPUSH
66855: CALL 20665 0 3
66859: ST_TO_ADDR
// break ;
66860: GO 66864
// end ; end ; end ;
66862: GO 66698
66864: POP
66865: POP
// end ;
66866: GO 66458
66868: POP
66869: POP
// end ;
66870: LD_VAR 0 1
66874: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66875: LD_INT 0
66877: PPUSH
66878: PPUSH
66879: PPUSH
66880: PPUSH
66881: PPUSH
66882: PPUSH
66883: PPUSH
66884: PPUSH
66885: PPUSH
// if not mc_bases then
66886: LD_EXP 58
66890: NOT
66891: IFFALSE 66895
// exit ;
66893: GO 67300
// for i = 1 to mc_bases do
66895: LD_ADDR_VAR 0 2
66899: PUSH
66900: DOUBLE
66901: LD_INT 1
66903: DEC
66904: ST_TO_ADDR
66905: LD_EXP 58
66909: PUSH
66910: FOR_TO
66911: IFFALSE 67298
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66913: LD_EXP 66
66917: PUSH
66918: LD_VAR 0 2
66922: ARRAY
66923: NOT
66924: PUSH
66925: LD_EXP 58
66929: PUSH
66930: LD_VAR 0 2
66934: ARRAY
66935: PPUSH
66936: LD_INT 30
66938: PUSH
66939: LD_INT 3
66941: PUSH
66942: EMPTY
66943: LIST
66944: LIST
66945: PPUSH
66946: CALL_OW 72
66950: NOT
66951: OR
66952: IFFALSE 66956
// continue ;
66954: GO 66910
// busy := false ;
66956: LD_ADDR_VAR 0 8
66960: PUSH
66961: LD_INT 0
66963: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66964: LD_ADDR_VAR 0 4
66968: PUSH
66969: LD_EXP 58
66973: PUSH
66974: LD_VAR 0 2
66978: ARRAY
66979: PPUSH
66980: LD_INT 30
66982: PUSH
66983: LD_INT 3
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: PPUSH
66990: CALL_OW 72
66994: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66995: LD_ADDR_VAR 0 6
66999: PUSH
67000: LD_EXP 66
67004: PUSH
67005: LD_VAR 0 2
67009: ARRAY
67010: PPUSH
67011: LD_INT 2
67013: PUSH
67014: LD_INT 30
67016: PUSH
67017: LD_INT 32
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 30
67026: PUSH
67027: LD_INT 33
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: LIST
67038: PPUSH
67039: CALL_OW 72
67043: ST_TO_ADDR
// if not t then
67044: LD_VAR 0 6
67048: NOT
67049: IFFALSE 67053
// continue ;
67051: GO 66910
// for j in tmp do
67053: LD_ADDR_VAR 0 3
67057: PUSH
67058: LD_VAR 0 4
67062: PUSH
67063: FOR_IN
67064: IFFALSE 67094
// if not BuildingStatus ( j ) = bs_idle then
67066: LD_VAR 0 3
67070: PPUSH
67071: CALL_OW 461
67075: PUSH
67076: LD_INT 2
67078: EQUAL
67079: NOT
67080: IFFALSE 67092
// begin busy := true ;
67082: LD_ADDR_VAR 0 8
67086: PUSH
67087: LD_INT 1
67089: ST_TO_ADDR
// break ;
67090: GO 67094
// end ;
67092: GO 67063
67094: POP
67095: POP
// if busy then
67096: LD_VAR 0 8
67100: IFFALSE 67104
// continue ;
67102: GO 66910
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67104: LD_ADDR_VAR 0 7
67108: PUSH
67109: LD_VAR 0 6
67113: PPUSH
67114: LD_INT 35
67116: PUSH
67117: LD_INT 0
67119: PUSH
67120: EMPTY
67121: LIST
67122: LIST
67123: PPUSH
67124: CALL_OW 72
67128: ST_TO_ADDR
// if tw then
67129: LD_VAR 0 7
67133: IFFALSE 67210
// begin tw := tw [ 1 ] ;
67135: LD_ADDR_VAR 0 7
67139: PUSH
67140: LD_VAR 0 7
67144: PUSH
67145: LD_INT 1
67147: ARRAY
67148: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67149: LD_ADDR_VAR 0 9
67153: PUSH
67154: LD_VAR 0 7
67158: PPUSH
67159: LD_EXP 83
67163: PUSH
67164: LD_VAR 0 2
67168: ARRAY
67169: PPUSH
67170: CALL 25635 0 2
67174: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67175: LD_EXP 97
67179: PUSH
67180: LD_VAR 0 2
67184: ARRAY
67185: IFFALSE 67208
// if not weapon in mc_allowed_tower_weapons [ i ] then
67187: LD_VAR 0 9
67191: PUSH
67192: LD_EXP 97
67196: PUSH
67197: LD_VAR 0 2
67201: ARRAY
67202: IN
67203: NOT
67204: IFFALSE 67208
// continue ;
67206: GO 66910
// end else
67208: GO 67273
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67210: LD_ADDR_VAR 0 5
67214: PUSH
67215: LD_EXP 66
67219: PUSH
67220: LD_VAR 0 2
67224: ARRAY
67225: PPUSH
67226: LD_VAR 0 4
67230: PPUSH
67231: CALL 55773 0 2
67235: ST_TO_ADDR
// if not tmp2 then
67236: LD_VAR 0 5
67240: NOT
67241: IFFALSE 67245
// continue ;
67243: GO 66910
// tw := tmp2 [ 1 ] ;
67245: LD_ADDR_VAR 0 7
67249: PUSH
67250: LD_VAR 0 5
67254: PUSH
67255: LD_INT 1
67257: ARRAY
67258: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67259: LD_ADDR_VAR 0 9
67263: PUSH
67264: LD_VAR 0 5
67268: PUSH
67269: LD_INT 2
67271: ARRAY
67272: ST_TO_ADDR
// end ; if not weapon then
67273: LD_VAR 0 9
67277: NOT
67278: IFFALSE 67282
// continue ;
67280: GO 66910
// ComPlaceWeapon ( tw , weapon ) ;
67282: LD_VAR 0 7
67286: PPUSH
67287: LD_VAR 0 9
67291: PPUSH
67292: CALL_OW 148
// end ;
67296: GO 66910
67298: POP
67299: POP
// end ;
67300: LD_VAR 0 1
67304: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
67305: LD_INT 0
67307: PPUSH
67308: PPUSH
67309: PPUSH
67310: PPUSH
67311: PPUSH
67312: PPUSH
// if not mc_bases then
67313: LD_EXP 58
67317: NOT
67318: IFFALSE 67322
// exit ;
67320: GO 68334
// for i = 1 to mc_bases do
67322: LD_ADDR_VAR 0 2
67326: PUSH
67327: DOUBLE
67328: LD_INT 1
67330: DEC
67331: ST_TO_ADDR
67332: LD_EXP 58
67336: PUSH
67337: FOR_TO
67338: IFFALSE 68332
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
67340: LD_EXP 71
67344: PUSH
67345: LD_VAR 0 2
67349: ARRAY
67350: NOT
67351: PUSH
67352: LD_EXP 71
67356: PUSH
67357: LD_VAR 0 2
67361: ARRAY
67362: PUSH
67363: LD_EXP 72
67367: PUSH
67368: LD_VAR 0 2
67372: ARRAY
67373: EQUAL
67374: OR
67375: IFFALSE 67379
// continue ;
67377: GO 67337
// if mc_miners [ i ] then
67379: LD_EXP 72
67383: PUSH
67384: LD_VAR 0 2
67388: ARRAY
67389: IFFALSE 68019
// begin k := 1 ;
67391: LD_ADDR_VAR 0 4
67395: PUSH
67396: LD_INT 1
67398: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
67399: LD_ADDR_VAR 0 3
67403: PUSH
67404: DOUBLE
67405: LD_EXP 72
67409: PUSH
67410: LD_VAR 0 2
67414: ARRAY
67415: INC
67416: ST_TO_ADDR
67417: LD_INT 1
67419: PUSH
67420: FOR_DOWNTO
67421: IFFALSE 68017
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67423: LD_EXP 72
67427: PUSH
67428: LD_VAR 0 2
67432: ARRAY
67433: PUSH
67434: LD_VAR 0 3
67438: ARRAY
67439: PPUSH
67440: CALL_OW 301
67444: PUSH
67445: LD_EXP 72
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: PUSH
67456: LD_VAR 0 3
67460: ARRAY
67461: PPUSH
67462: CALL_OW 257
67466: PUSH
67467: LD_INT 1
67469: NONEQUAL
67470: OR
67471: IFFALSE 67534
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67473: LD_ADDR_VAR 0 5
67477: PUSH
67478: LD_EXP 72
67482: PUSH
67483: LD_VAR 0 2
67487: ARRAY
67488: PUSH
67489: LD_EXP 72
67493: PUSH
67494: LD_VAR 0 2
67498: ARRAY
67499: PUSH
67500: LD_VAR 0 3
67504: ARRAY
67505: DIFF
67506: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67507: LD_ADDR_EXP 72
67511: PUSH
67512: LD_EXP 72
67516: PPUSH
67517: LD_VAR 0 2
67521: PPUSH
67522: LD_VAR 0 5
67526: PPUSH
67527: CALL_OW 1
67531: ST_TO_ADDR
// continue ;
67532: GO 67420
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
67534: LD_EXP 72
67538: PUSH
67539: LD_VAR 0 2
67543: ARRAY
67544: PUSH
67545: LD_VAR 0 3
67549: ARRAY
67550: PPUSH
67551: CALL 20601 0 1
67555: PUSH
67556: LD_EXP 72
67560: PUSH
67561: LD_VAR 0 2
67565: ARRAY
67566: PUSH
67567: LD_VAR 0 3
67571: ARRAY
67572: PPUSH
67573: CALL_OW 255
67577: PPUSH
67578: LD_EXP 71
67582: PUSH
67583: LD_VAR 0 2
67587: ARRAY
67588: PUSH
67589: LD_VAR 0 4
67593: ARRAY
67594: PUSH
67595: LD_INT 1
67597: ARRAY
67598: PPUSH
67599: LD_EXP 71
67603: PUSH
67604: LD_VAR 0 2
67608: ARRAY
67609: PUSH
67610: LD_VAR 0 4
67614: ARRAY
67615: PUSH
67616: LD_INT 2
67618: ARRAY
67619: PPUSH
67620: LD_INT 15
67622: PPUSH
67623: CALL 21561 0 4
67627: PUSH
67628: LD_INT 4
67630: ARRAY
67631: PUSH
67632: LD_EXP 72
67636: PUSH
67637: LD_VAR 0 2
67641: ARRAY
67642: PUSH
67643: LD_VAR 0 3
67647: ARRAY
67648: PPUSH
67649: LD_INT 10
67651: PPUSH
67652: CALL 23258 0 2
67656: PUSH
67657: LD_INT 4
67659: ARRAY
67660: OR
67661: AND
67662: IFFALSE 67685
// ComStop ( mc_miners [ i ] [ j ] ) ;
67664: LD_EXP 72
67668: PUSH
67669: LD_VAR 0 2
67673: ARRAY
67674: PUSH
67675: LD_VAR 0 3
67679: ARRAY
67680: PPUSH
67681: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
67685: LD_EXP 72
67689: PUSH
67690: LD_VAR 0 2
67694: ARRAY
67695: PUSH
67696: LD_VAR 0 3
67700: ARRAY
67701: PPUSH
67702: CALL_OW 257
67706: PUSH
67707: LD_INT 1
67709: EQUAL
67710: PUSH
67711: LD_EXP 72
67715: PUSH
67716: LD_VAR 0 2
67720: ARRAY
67721: PUSH
67722: LD_VAR 0 3
67726: ARRAY
67727: PPUSH
67728: CALL_OW 459
67732: NOT
67733: AND
67734: PUSH
67735: LD_EXP 72
67739: PUSH
67740: LD_VAR 0 2
67744: ARRAY
67745: PUSH
67746: LD_VAR 0 3
67750: ARRAY
67751: PPUSH
67752: CALL_OW 255
67756: PPUSH
67757: LD_EXP 71
67761: PUSH
67762: LD_VAR 0 2
67766: ARRAY
67767: PUSH
67768: LD_VAR 0 4
67772: ARRAY
67773: PUSH
67774: LD_INT 1
67776: ARRAY
67777: PPUSH
67778: LD_EXP 71
67782: PUSH
67783: LD_VAR 0 2
67787: ARRAY
67788: PUSH
67789: LD_VAR 0 4
67793: ARRAY
67794: PUSH
67795: LD_INT 2
67797: ARRAY
67798: PPUSH
67799: LD_INT 15
67801: PPUSH
67802: CALL 21561 0 4
67806: PUSH
67807: LD_INT 4
67809: ARRAY
67810: PUSH
67811: LD_INT 0
67813: EQUAL
67814: AND
67815: PUSH
67816: LD_EXP 72
67820: PUSH
67821: LD_VAR 0 2
67825: ARRAY
67826: PUSH
67827: LD_VAR 0 3
67831: ARRAY
67832: PPUSH
67833: CALL_OW 314
67837: NOT
67838: AND
67839: IFFALSE 68015
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67841: LD_EXP 72
67845: PUSH
67846: LD_VAR 0 2
67850: ARRAY
67851: PUSH
67852: LD_VAR 0 3
67856: ARRAY
67857: PPUSH
67858: CALL_OW 310
67862: IFFALSE 67885
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67864: LD_EXP 72
67868: PUSH
67869: LD_VAR 0 2
67873: ARRAY
67874: PUSH
67875: LD_VAR 0 3
67879: ARRAY
67880: PPUSH
67881: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67885: LD_EXP 72
67889: PUSH
67890: LD_VAR 0 2
67894: ARRAY
67895: PUSH
67896: LD_VAR 0 3
67900: ARRAY
67901: PPUSH
67902: CALL_OW 314
67906: NOT
67907: IFFALSE 67975
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
67909: LD_EXP 72
67913: PUSH
67914: LD_VAR 0 2
67918: ARRAY
67919: PUSH
67920: LD_VAR 0 3
67924: ARRAY
67925: PPUSH
67926: LD_EXP 71
67930: PUSH
67931: LD_VAR 0 2
67935: ARRAY
67936: PUSH
67937: LD_VAR 0 4
67941: ARRAY
67942: PUSH
67943: LD_INT 1
67945: ARRAY
67946: PPUSH
67947: LD_EXP 71
67951: PUSH
67952: LD_VAR 0 2
67956: ARRAY
67957: PUSH
67958: LD_VAR 0 4
67962: ARRAY
67963: PUSH
67964: LD_INT 2
67966: ARRAY
67967: PPUSH
67968: LD_INT 0
67970: PPUSH
67971: CALL_OW 193
// k := k + 1 ;
67975: LD_ADDR_VAR 0 4
67979: PUSH
67980: LD_VAR 0 4
67984: PUSH
67985: LD_INT 1
67987: PLUS
67988: ST_TO_ADDR
// if k > mc_mines [ i ] then
67989: LD_VAR 0 4
67993: PUSH
67994: LD_EXP 71
67998: PUSH
67999: LD_VAR 0 2
68003: ARRAY
68004: GREATER
68005: IFFALSE 68015
// k := 1 ;
68007: LD_ADDR_VAR 0 4
68011: PUSH
68012: LD_INT 1
68014: ST_TO_ADDR
// end ; end ;
68015: GO 67420
68017: POP
68018: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
68019: LD_ADDR_VAR 0 5
68023: PUSH
68024: LD_EXP 58
68028: PUSH
68029: LD_VAR 0 2
68033: ARRAY
68034: PPUSH
68035: LD_INT 2
68037: PUSH
68038: LD_INT 30
68040: PUSH
68041: LD_INT 4
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: LD_INT 30
68050: PUSH
68051: LD_INT 5
68053: PUSH
68054: EMPTY
68055: LIST
68056: LIST
68057: PUSH
68058: LD_INT 30
68060: PUSH
68061: LD_INT 32
68063: PUSH
68064: EMPTY
68065: LIST
68066: LIST
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: LIST
68072: LIST
68073: PPUSH
68074: CALL_OW 72
68078: ST_TO_ADDR
// if not tmp then
68079: LD_VAR 0 5
68083: NOT
68084: IFFALSE 68088
// continue ;
68086: GO 67337
// list := [ ] ;
68088: LD_ADDR_VAR 0 6
68092: PUSH
68093: EMPTY
68094: ST_TO_ADDR
// for j in tmp do
68095: LD_ADDR_VAR 0 3
68099: PUSH
68100: LD_VAR 0 5
68104: PUSH
68105: FOR_IN
68106: IFFALSE 68175
// begin for k in UnitsInside ( j ) do
68108: LD_ADDR_VAR 0 4
68112: PUSH
68113: LD_VAR 0 3
68117: PPUSH
68118: CALL_OW 313
68122: PUSH
68123: FOR_IN
68124: IFFALSE 68171
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68126: LD_VAR 0 4
68130: PPUSH
68131: CALL_OW 257
68135: PUSH
68136: LD_INT 1
68138: EQUAL
68139: PUSH
68140: LD_VAR 0 4
68144: PPUSH
68145: CALL_OW 459
68149: NOT
68150: AND
68151: IFFALSE 68169
// list := list ^ k ;
68153: LD_ADDR_VAR 0 6
68157: PUSH
68158: LD_VAR 0 6
68162: PUSH
68163: LD_VAR 0 4
68167: ADD
68168: ST_TO_ADDR
68169: GO 68123
68171: POP
68172: POP
// end ;
68173: GO 68105
68175: POP
68176: POP
// list := list diff mc_miners [ i ] ;
68177: LD_ADDR_VAR 0 6
68181: PUSH
68182: LD_VAR 0 6
68186: PUSH
68187: LD_EXP 72
68191: PUSH
68192: LD_VAR 0 2
68196: ARRAY
68197: DIFF
68198: ST_TO_ADDR
// if not list then
68199: LD_VAR 0 6
68203: NOT
68204: IFFALSE 68208
// continue ;
68206: GO 67337
// k := mc_mines [ i ] - mc_miners [ i ] ;
68208: LD_ADDR_VAR 0 4
68212: PUSH
68213: LD_EXP 71
68217: PUSH
68218: LD_VAR 0 2
68222: ARRAY
68223: PUSH
68224: LD_EXP 72
68228: PUSH
68229: LD_VAR 0 2
68233: ARRAY
68234: MINUS
68235: ST_TO_ADDR
// if k > list then
68236: LD_VAR 0 4
68240: PUSH
68241: LD_VAR 0 6
68245: GREATER
68246: IFFALSE 68258
// k := list ;
68248: LD_ADDR_VAR 0 4
68252: PUSH
68253: LD_VAR 0 6
68257: ST_TO_ADDR
// for j = 1 to k do
68258: LD_ADDR_VAR 0 3
68262: PUSH
68263: DOUBLE
68264: LD_INT 1
68266: DEC
68267: ST_TO_ADDR
68268: LD_VAR 0 4
68272: PUSH
68273: FOR_TO
68274: IFFALSE 68328
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68276: LD_ADDR_EXP 72
68280: PUSH
68281: LD_EXP 72
68285: PPUSH
68286: LD_VAR 0 2
68290: PUSH
68291: LD_EXP 72
68295: PUSH
68296: LD_VAR 0 2
68300: ARRAY
68301: PUSH
68302: LD_INT 1
68304: PLUS
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PPUSH
68310: LD_VAR 0 6
68314: PUSH
68315: LD_VAR 0 3
68319: ARRAY
68320: PPUSH
68321: CALL 20665 0 3
68325: ST_TO_ADDR
68326: GO 68273
68328: POP
68329: POP
// end ;
68330: GO 67337
68332: POP
68333: POP
// end ;
68334: LD_VAR 0 1
68338: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
68339: LD_INT 0
68341: PPUSH
68342: PPUSH
68343: PPUSH
68344: PPUSH
68345: PPUSH
68346: PPUSH
68347: PPUSH
68348: PPUSH
68349: PPUSH
68350: PPUSH
// if not mc_bases then
68351: LD_EXP 58
68355: NOT
68356: IFFALSE 68360
// exit ;
68358: GO 70091
// for i = 1 to mc_bases do
68360: LD_ADDR_VAR 0 2
68364: PUSH
68365: DOUBLE
68366: LD_INT 1
68368: DEC
68369: ST_TO_ADDR
68370: LD_EXP 58
68374: PUSH
68375: FOR_TO
68376: IFFALSE 70089
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68378: LD_EXP 58
68382: PUSH
68383: LD_VAR 0 2
68387: ARRAY
68388: NOT
68389: PUSH
68390: LD_EXP 65
68394: PUSH
68395: LD_VAR 0 2
68399: ARRAY
68400: OR
68401: IFFALSE 68405
// continue ;
68403: GO 68375
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68405: LD_EXP 74
68409: PUSH
68410: LD_VAR 0 2
68414: ARRAY
68415: NOT
68416: PUSH
68417: LD_EXP 75
68421: PUSH
68422: LD_VAR 0 2
68426: ARRAY
68427: AND
68428: IFFALSE 68466
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68430: LD_ADDR_EXP 75
68434: PUSH
68435: LD_EXP 75
68439: PPUSH
68440: LD_VAR 0 2
68444: PPUSH
68445: EMPTY
68446: PPUSH
68447: CALL_OW 1
68451: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68452: LD_VAR 0 2
68456: PPUSH
68457: LD_INT 107
68459: PPUSH
68460: CALL 59555 0 2
// continue ;
68464: GO 68375
// end ; target := [ ] ;
68466: LD_ADDR_VAR 0 6
68470: PUSH
68471: EMPTY
68472: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68473: LD_ADDR_VAR 0 3
68477: PUSH
68478: DOUBLE
68479: LD_EXP 74
68483: PUSH
68484: LD_VAR 0 2
68488: ARRAY
68489: INC
68490: ST_TO_ADDR
68491: LD_INT 1
68493: PUSH
68494: FOR_DOWNTO
68495: IFFALSE 68755
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68497: LD_EXP 74
68501: PUSH
68502: LD_VAR 0 2
68506: ARRAY
68507: PUSH
68508: LD_VAR 0 3
68512: ARRAY
68513: PUSH
68514: LD_INT 2
68516: ARRAY
68517: PPUSH
68518: LD_EXP 74
68522: PUSH
68523: LD_VAR 0 2
68527: ARRAY
68528: PUSH
68529: LD_VAR 0 3
68533: ARRAY
68534: PUSH
68535: LD_INT 3
68537: ARRAY
68538: PPUSH
68539: CALL_OW 488
68543: PUSH
68544: LD_EXP 74
68548: PUSH
68549: LD_VAR 0 2
68553: ARRAY
68554: PUSH
68555: LD_VAR 0 3
68559: ARRAY
68560: PUSH
68561: LD_INT 2
68563: ARRAY
68564: PPUSH
68565: LD_EXP 74
68569: PUSH
68570: LD_VAR 0 2
68574: ARRAY
68575: PUSH
68576: LD_VAR 0 3
68580: ARRAY
68581: PUSH
68582: LD_INT 3
68584: ARRAY
68585: PPUSH
68586: CALL_OW 284
68590: PUSH
68591: LD_INT 0
68593: EQUAL
68594: AND
68595: IFFALSE 68650
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68597: LD_ADDR_VAR 0 5
68601: PUSH
68602: LD_EXP 74
68606: PUSH
68607: LD_VAR 0 2
68611: ARRAY
68612: PPUSH
68613: LD_VAR 0 3
68617: PPUSH
68618: CALL_OW 3
68622: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68623: LD_ADDR_EXP 74
68627: PUSH
68628: LD_EXP 74
68632: PPUSH
68633: LD_VAR 0 2
68637: PPUSH
68638: LD_VAR 0 5
68642: PPUSH
68643: CALL_OW 1
68647: ST_TO_ADDR
// continue ;
68648: GO 68494
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68650: LD_EXP 58
68654: PUSH
68655: LD_VAR 0 2
68659: ARRAY
68660: PUSH
68661: LD_INT 1
68663: ARRAY
68664: PPUSH
68665: CALL_OW 255
68669: PPUSH
68670: LD_EXP 74
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PUSH
68681: LD_VAR 0 3
68685: ARRAY
68686: PUSH
68687: LD_INT 2
68689: ARRAY
68690: PPUSH
68691: LD_EXP 74
68695: PUSH
68696: LD_VAR 0 2
68700: ARRAY
68701: PUSH
68702: LD_VAR 0 3
68706: ARRAY
68707: PUSH
68708: LD_INT 3
68710: ARRAY
68711: PPUSH
68712: LD_INT 30
68714: PPUSH
68715: CALL 21561 0 4
68719: PUSH
68720: LD_INT 4
68722: ARRAY
68723: PUSH
68724: LD_INT 0
68726: EQUAL
68727: IFFALSE 68753
// begin target := mc_crates [ i ] [ j ] ;
68729: LD_ADDR_VAR 0 6
68733: PUSH
68734: LD_EXP 74
68738: PUSH
68739: LD_VAR 0 2
68743: ARRAY
68744: PUSH
68745: LD_VAR 0 3
68749: ARRAY
68750: ST_TO_ADDR
// break ;
68751: GO 68755
// end ; end ;
68753: GO 68494
68755: POP
68756: POP
// if not target then
68757: LD_VAR 0 6
68761: NOT
68762: IFFALSE 68766
// continue ;
68764: GO 68375
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68766: LD_ADDR_VAR 0 7
68770: PUSH
68771: LD_EXP 77
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: PPUSH
68782: LD_INT 2
68784: PUSH
68785: LD_INT 3
68787: PUSH
68788: LD_INT 58
68790: PUSH
68791: EMPTY
68792: LIST
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 61
68800: PUSH
68801: EMPTY
68802: LIST
68803: PUSH
68804: LD_INT 33
68806: PUSH
68807: LD_INT 5
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 33
68816: PUSH
68817: LD_INT 3
68819: PUSH
68820: EMPTY
68821: LIST
68822: LIST
68823: PUSH
68824: EMPTY
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: PUSH
68831: LD_INT 2
68833: PUSH
68834: LD_INT 34
68836: PUSH
68837: LD_INT 32
68839: PUSH
68840: EMPTY
68841: LIST
68842: LIST
68843: PUSH
68844: LD_INT 34
68846: PUSH
68847: LD_INT 51
68849: PUSH
68850: EMPTY
68851: LIST
68852: LIST
68853: PUSH
68854: LD_INT 34
68856: PUSH
68857: LD_INT 12
68859: PUSH
68860: EMPTY
68861: LIST
68862: LIST
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PPUSH
68874: CALL_OW 72
68878: ST_TO_ADDR
// if not cargo then
68879: LD_VAR 0 7
68883: NOT
68884: IFFALSE 69527
// begin if mc_crates_collector [ i ] < 5 then
68886: LD_EXP 75
68890: PUSH
68891: LD_VAR 0 2
68895: ARRAY
68896: PUSH
68897: LD_INT 5
68899: LESS
68900: IFFALSE 69266
// begin if mc_ape [ i ] then
68902: LD_EXP 87
68906: PUSH
68907: LD_VAR 0 2
68911: ARRAY
68912: IFFALSE 68959
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68914: LD_ADDR_VAR 0 5
68918: PUSH
68919: LD_EXP 87
68923: PUSH
68924: LD_VAR 0 2
68928: ARRAY
68929: PPUSH
68930: LD_INT 25
68932: PUSH
68933: LD_INT 16
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 24
68942: PUSH
68943: LD_INT 750
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: PUSH
68950: EMPTY
68951: LIST
68952: LIST
68953: PPUSH
68954: CALL_OW 72
68958: ST_TO_ADDR
// if not tmp then
68959: LD_VAR 0 5
68963: NOT
68964: IFFALSE 69011
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68966: LD_ADDR_VAR 0 5
68970: PUSH
68971: LD_EXP 58
68975: PUSH
68976: LD_VAR 0 2
68980: ARRAY
68981: PPUSH
68982: LD_INT 25
68984: PUSH
68985: LD_INT 2
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 24
68994: PUSH
68995: LD_INT 750
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PPUSH
69006: CALL_OW 72
69010: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
69011: LD_EXP 87
69015: PUSH
69016: LD_VAR 0 2
69020: ARRAY
69021: PUSH
69022: LD_EXP 58
69026: PUSH
69027: LD_VAR 0 2
69031: ARRAY
69032: PPUSH
69033: LD_INT 25
69035: PUSH
69036: LD_INT 2
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 24
69045: PUSH
69046: LD_INT 750
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PPUSH
69057: CALL_OW 72
69061: AND
69062: PUSH
69063: LD_VAR 0 5
69067: PUSH
69068: LD_INT 5
69070: LESS
69071: AND
69072: IFFALSE 69154
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69074: LD_ADDR_VAR 0 3
69078: PUSH
69079: LD_EXP 58
69083: PUSH
69084: LD_VAR 0 2
69088: ARRAY
69089: PPUSH
69090: LD_INT 25
69092: PUSH
69093: LD_INT 2
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 24
69102: PUSH
69103: LD_INT 750
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PPUSH
69114: CALL_OW 72
69118: PUSH
69119: FOR_IN
69120: IFFALSE 69152
// begin tmp := tmp union j ;
69122: LD_ADDR_VAR 0 5
69126: PUSH
69127: LD_VAR 0 5
69131: PUSH
69132: LD_VAR 0 3
69136: UNION
69137: ST_TO_ADDR
// if tmp >= 5 then
69138: LD_VAR 0 5
69142: PUSH
69143: LD_INT 5
69145: GREATEREQUAL
69146: IFFALSE 69150
// break ;
69148: GO 69152
// end ;
69150: GO 69119
69152: POP
69153: POP
// end ; if not tmp then
69154: LD_VAR 0 5
69158: NOT
69159: IFFALSE 69163
// continue ;
69161: GO 68375
// for j in tmp do
69163: LD_ADDR_VAR 0 3
69167: PUSH
69168: LD_VAR 0 5
69172: PUSH
69173: FOR_IN
69174: IFFALSE 69264
// if not GetTag ( j ) then
69176: LD_VAR 0 3
69180: PPUSH
69181: CALL_OW 110
69185: NOT
69186: IFFALSE 69262
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69188: LD_ADDR_EXP 75
69192: PUSH
69193: LD_EXP 75
69197: PPUSH
69198: LD_VAR 0 2
69202: PUSH
69203: LD_EXP 75
69207: PUSH
69208: LD_VAR 0 2
69212: ARRAY
69213: PUSH
69214: LD_INT 1
69216: PLUS
69217: PUSH
69218: EMPTY
69219: LIST
69220: LIST
69221: PPUSH
69222: LD_VAR 0 3
69226: PPUSH
69227: CALL 20665 0 3
69231: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69232: LD_VAR 0 3
69236: PPUSH
69237: LD_INT 107
69239: PPUSH
69240: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69244: LD_EXP 75
69248: PUSH
69249: LD_VAR 0 2
69253: ARRAY
69254: PUSH
69255: LD_INT 5
69257: GREATEREQUAL
69258: IFFALSE 69262
// break ;
69260: GO 69264
// end ;
69262: GO 69173
69264: POP
69265: POP
// end ; if mc_crates_collector [ i ] and target then
69266: LD_EXP 75
69270: PUSH
69271: LD_VAR 0 2
69275: ARRAY
69276: PUSH
69277: LD_VAR 0 6
69281: AND
69282: IFFALSE 69525
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69284: LD_EXP 75
69288: PUSH
69289: LD_VAR 0 2
69293: ARRAY
69294: PUSH
69295: LD_VAR 0 6
69299: PUSH
69300: LD_INT 1
69302: ARRAY
69303: LESS
69304: IFFALSE 69324
// tmp := mc_crates_collector [ i ] else
69306: LD_ADDR_VAR 0 5
69310: PUSH
69311: LD_EXP 75
69315: PUSH
69316: LD_VAR 0 2
69320: ARRAY
69321: ST_TO_ADDR
69322: GO 69338
// tmp := target [ 1 ] ;
69324: LD_ADDR_VAR 0 5
69328: PUSH
69329: LD_VAR 0 6
69333: PUSH
69334: LD_INT 1
69336: ARRAY
69337: ST_TO_ADDR
// k := 0 ;
69338: LD_ADDR_VAR 0 4
69342: PUSH
69343: LD_INT 0
69345: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69346: LD_ADDR_VAR 0 3
69350: PUSH
69351: LD_EXP 75
69355: PUSH
69356: LD_VAR 0 2
69360: ARRAY
69361: PUSH
69362: FOR_IN
69363: IFFALSE 69523
// begin k := k + 1 ;
69365: LD_ADDR_VAR 0 4
69369: PUSH
69370: LD_VAR 0 4
69374: PUSH
69375: LD_INT 1
69377: PLUS
69378: ST_TO_ADDR
// if k > tmp then
69379: LD_VAR 0 4
69383: PUSH
69384: LD_VAR 0 5
69388: GREATER
69389: IFFALSE 69393
// break ;
69391: GO 69523
// if not GetClass ( j ) in [ 2 , 16 ] then
69393: LD_VAR 0 3
69397: PPUSH
69398: CALL_OW 257
69402: PUSH
69403: LD_INT 2
69405: PUSH
69406: LD_INT 16
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: IN
69413: NOT
69414: IFFALSE 69467
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69416: LD_ADDR_EXP 75
69420: PUSH
69421: LD_EXP 75
69425: PPUSH
69426: LD_VAR 0 2
69430: PPUSH
69431: LD_EXP 75
69435: PUSH
69436: LD_VAR 0 2
69440: ARRAY
69441: PUSH
69442: LD_VAR 0 3
69446: DIFF
69447: PPUSH
69448: CALL_OW 1
69452: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69453: LD_VAR 0 3
69457: PPUSH
69458: LD_INT 0
69460: PPUSH
69461: CALL_OW 109
// continue ;
69465: GO 69362
// end ; if IsInUnit ( j ) then
69467: LD_VAR 0 3
69471: PPUSH
69472: CALL_OW 310
69476: IFFALSE 69487
// ComExitBuilding ( j ) ;
69478: LD_VAR 0 3
69482: PPUSH
69483: CALL_OW 122
// wait ( 3 ) ;
69487: LD_INT 3
69489: PPUSH
69490: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69494: LD_VAR 0 3
69498: PPUSH
69499: LD_VAR 0 6
69503: PUSH
69504: LD_INT 2
69506: ARRAY
69507: PPUSH
69508: LD_VAR 0 6
69512: PUSH
69513: LD_INT 3
69515: ARRAY
69516: PPUSH
69517: CALL_OW 117
// end ;
69521: GO 69362
69523: POP
69524: POP
// end ; end else
69525: GO 70087
// begin for j in cargo do
69527: LD_ADDR_VAR 0 3
69531: PUSH
69532: LD_VAR 0 7
69536: PUSH
69537: FOR_IN
69538: IFFALSE 70085
// begin if GetTag ( j ) <> 0 then
69540: LD_VAR 0 3
69544: PPUSH
69545: CALL_OW 110
69549: PUSH
69550: LD_INT 0
69552: NONEQUAL
69553: IFFALSE 69557
// continue ;
69555: GO 69537
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69557: LD_VAR 0 3
69561: PPUSH
69562: CALL_OW 256
69566: PUSH
69567: LD_INT 1000
69569: LESS
69570: PUSH
69571: LD_VAR 0 3
69575: PPUSH
69576: LD_EXP 82
69580: PUSH
69581: LD_VAR 0 2
69585: ARRAY
69586: PPUSH
69587: CALL_OW 308
69591: NOT
69592: AND
69593: IFFALSE 69615
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69595: LD_VAR 0 3
69599: PPUSH
69600: LD_EXP 82
69604: PUSH
69605: LD_VAR 0 2
69609: ARRAY
69610: PPUSH
69611: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69615: LD_VAR 0 3
69619: PPUSH
69620: CALL_OW 256
69624: PUSH
69625: LD_INT 1000
69627: LESS
69628: PUSH
69629: LD_VAR 0 3
69633: PPUSH
69634: LD_EXP 82
69638: PUSH
69639: LD_VAR 0 2
69643: ARRAY
69644: PPUSH
69645: CALL_OW 308
69649: AND
69650: IFFALSE 69654
// continue ;
69652: GO 69537
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69654: LD_VAR 0 3
69658: PPUSH
69659: CALL_OW 262
69663: PUSH
69664: LD_INT 2
69666: EQUAL
69667: PUSH
69668: LD_VAR 0 3
69672: PPUSH
69673: CALL_OW 261
69677: PUSH
69678: LD_INT 15
69680: LESS
69681: AND
69682: IFFALSE 69686
// continue ;
69684: GO 69537
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69686: LD_VAR 0 3
69690: PPUSH
69691: CALL_OW 262
69695: PUSH
69696: LD_INT 1
69698: EQUAL
69699: PUSH
69700: LD_VAR 0 3
69704: PPUSH
69705: CALL_OW 261
69709: PUSH
69710: LD_INT 10
69712: LESS
69713: AND
69714: IFFALSE 70024
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69716: LD_ADDR_VAR 0 8
69720: PUSH
69721: LD_EXP 58
69725: PUSH
69726: LD_VAR 0 2
69730: ARRAY
69731: PPUSH
69732: LD_INT 2
69734: PUSH
69735: LD_INT 30
69737: PUSH
69738: LD_INT 0
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: PUSH
69745: LD_INT 30
69747: PUSH
69748: LD_INT 1
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: PUSH
69755: EMPTY
69756: LIST
69757: LIST
69758: LIST
69759: PPUSH
69760: CALL_OW 72
69764: ST_TO_ADDR
// if not depot then
69765: LD_VAR 0 8
69769: NOT
69770: IFFALSE 69774
// continue ;
69772: GO 69537
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69774: LD_VAR 0 3
69778: PPUSH
69779: LD_VAR 0 8
69783: PPUSH
69784: LD_VAR 0 3
69788: PPUSH
69789: CALL_OW 74
69793: PPUSH
69794: CALL_OW 296
69798: PUSH
69799: LD_INT 6
69801: LESS
69802: IFFALSE 69818
// SetFuel ( j , 100 ) else
69804: LD_VAR 0 3
69808: PPUSH
69809: LD_INT 100
69811: PPUSH
69812: CALL_OW 240
69816: GO 70024
// if GetFuel ( j ) = 0 then
69818: LD_VAR 0 3
69822: PPUSH
69823: CALL_OW 261
69827: PUSH
69828: LD_INT 0
69830: EQUAL
69831: IFFALSE 70024
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69833: LD_ADDR_EXP 77
69837: PUSH
69838: LD_EXP 77
69842: PPUSH
69843: LD_VAR 0 2
69847: PPUSH
69848: LD_EXP 77
69852: PUSH
69853: LD_VAR 0 2
69857: ARRAY
69858: PUSH
69859: LD_VAR 0 3
69863: DIFF
69864: PPUSH
69865: CALL_OW 1
69869: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69870: LD_VAR 0 3
69874: PPUSH
69875: CALL_OW 263
69879: PUSH
69880: LD_INT 1
69882: EQUAL
69883: IFFALSE 69899
// ComExitVehicle ( IsInUnit ( j ) ) ;
69885: LD_VAR 0 3
69889: PPUSH
69890: CALL_OW 310
69894: PPUSH
69895: CALL_OW 121
// if GetControl ( j ) = control_remote then
69899: LD_VAR 0 3
69903: PPUSH
69904: CALL_OW 263
69908: PUSH
69909: LD_INT 2
69911: EQUAL
69912: IFFALSE 69923
// ComUnlink ( j ) ;
69914: LD_VAR 0 3
69918: PPUSH
69919: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
69923: LD_ADDR_VAR 0 9
69927: PUSH
69928: LD_VAR 0 2
69932: PPUSH
69933: LD_INT 3
69935: PPUSH
69936: CALL 79128 0 2
69940: ST_TO_ADDR
// if fac then
69941: LD_VAR 0 9
69945: IFFALSE 70022
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69947: LD_ADDR_VAR 0 10
69951: PUSH
69952: LD_VAR 0 9
69956: PPUSH
69957: LD_VAR 0 3
69961: PPUSH
69962: CALL_OW 265
69966: PPUSH
69967: LD_VAR 0 3
69971: PPUSH
69972: CALL_OW 262
69976: PPUSH
69977: LD_VAR 0 3
69981: PPUSH
69982: CALL_OW 263
69986: PPUSH
69987: LD_VAR 0 3
69991: PPUSH
69992: CALL_OW 264
69996: PPUSH
69997: CALL 18265 0 5
70001: ST_TO_ADDR
// if components then
70002: LD_VAR 0 10
70006: IFFALSE 70022
// MC_InsertProduceList ( i , components ) ;
70008: LD_VAR 0 2
70012: PPUSH
70013: LD_VAR 0 10
70017: PPUSH
70018: CALL 78756 0 2
// end ; continue ;
70022: GO 69537
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70024: LD_VAR 0 3
70028: PPUSH
70029: LD_INT 1
70031: PPUSH
70032: CALL_OW 289
70036: PUSH
70037: LD_INT 100
70039: LESS
70040: PUSH
70041: LD_VAR 0 3
70045: PPUSH
70046: CALL_OW 314
70050: NOT
70051: AND
70052: IFFALSE 70081
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70054: LD_VAR 0 3
70058: PPUSH
70059: LD_VAR 0 6
70063: PUSH
70064: LD_INT 2
70066: ARRAY
70067: PPUSH
70068: LD_VAR 0 6
70072: PUSH
70073: LD_INT 3
70075: ARRAY
70076: PPUSH
70077: CALL_OW 117
// break ;
70081: GO 70085
// end ;
70083: GO 69537
70085: POP
70086: POP
// end ; end ;
70087: GO 68375
70089: POP
70090: POP
// end ;
70091: LD_VAR 0 1
70095: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70096: LD_INT 0
70098: PPUSH
70099: PPUSH
70100: PPUSH
70101: PPUSH
// if not mc_bases then
70102: LD_EXP 58
70106: NOT
70107: IFFALSE 70111
// exit ;
70109: GO 70272
// for i = 1 to mc_bases do
70111: LD_ADDR_VAR 0 2
70115: PUSH
70116: DOUBLE
70117: LD_INT 1
70119: DEC
70120: ST_TO_ADDR
70121: LD_EXP 58
70125: PUSH
70126: FOR_TO
70127: IFFALSE 70270
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70129: LD_ADDR_VAR 0 4
70133: PUSH
70134: LD_EXP 77
70138: PUSH
70139: LD_VAR 0 2
70143: ARRAY
70144: PUSH
70145: LD_EXP 80
70149: PUSH
70150: LD_VAR 0 2
70154: ARRAY
70155: UNION
70156: PPUSH
70157: LD_INT 33
70159: PUSH
70160: LD_INT 2
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PPUSH
70167: CALL_OW 72
70171: ST_TO_ADDR
// if tmp then
70172: LD_VAR 0 4
70176: IFFALSE 70268
// for j in tmp do
70178: LD_ADDR_VAR 0 3
70182: PUSH
70183: LD_VAR 0 4
70187: PUSH
70188: FOR_IN
70189: IFFALSE 70266
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70191: LD_VAR 0 3
70195: PPUSH
70196: CALL_OW 312
70200: NOT
70201: PUSH
70202: LD_VAR 0 3
70206: PPUSH
70207: CALL_OW 256
70211: PUSH
70212: LD_INT 250
70214: GREATEREQUAL
70215: AND
70216: IFFALSE 70229
// Connect ( j ) else
70218: LD_VAR 0 3
70222: PPUSH
70223: CALL 23598 0 1
70227: GO 70264
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70229: LD_VAR 0 3
70233: PPUSH
70234: CALL_OW 256
70238: PUSH
70239: LD_INT 250
70241: LESS
70242: PUSH
70243: LD_VAR 0 3
70247: PPUSH
70248: CALL_OW 312
70252: AND
70253: IFFALSE 70264
// ComUnlink ( j ) ;
70255: LD_VAR 0 3
70259: PPUSH
70260: CALL_OW 136
70264: GO 70188
70266: POP
70267: POP
// end ;
70268: GO 70126
70270: POP
70271: POP
// end ;
70272: LD_VAR 0 1
70276: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70277: LD_INT 0
70279: PPUSH
70280: PPUSH
70281: PPUSH
70282: PPUSH
70283: PPUSH
// if not mc_bases then
70284: LD_EXP 58
70288: NOT
70289: IFFALSE 70293
// exit ;
70291: GO 70753
// for i = 1 to mc_bases do
70293: LD_ADDR_VAR 0 2
70297: PUSH
70298: DOUBLE
70299: LD_INT 1
70301: DEC
70302: ST_TO_ADDR
70303: LD_EXP 58
70307: PUSH
70308: FOR_TO
70309: IFFALSE 70751
// begin if not mc_produce [ i ] then
70311: LD_EXP 79
70315: PUSH
70316: LD_VAR 0 2
70320: ARRAY
70321: NOT
70322: IFFALSE 70326
// continue ;
70324: GO 70308
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70326: LD_ADDR_VAR 0 5
70330: PUSH
70331: LD_EXP 58
70335: PUSH
70336: LD_VAR 0 2
70340: ARRAY
70341: PPUSH
70342: LD_INT 30
70344: PUSH
70345: LD_INT 3
70347: PUSH
70348: EMPTY
70349: LIST
70350: LIST
70351: PPUSH
70352: CALL_OW 72
70356: ST_TO_ADDR
// if not fac then
70357: LD_VAR 0 5
70361: NOT
70362: IFFALSE 70366
// continue ;
70364: GO 70308
// for j in fac do
70366: LD_ADDR_VAR 0 3
70370: PUSH
70371: LD_VAR 0 5
70375: PUSH
70376: FOR_IN
70377: IFFALSE 70747
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
70379: LD_VAR 0 3
70383: PPUSH
70384: CALL_OW 461
70388: PUSH
70389: LD_INT 2
70391: NONEQUAL
70392: PUSH
70393: LD_VAR 0 3
70397: PPUSH
70398: LD_INT 15
70400: PPUSH
70401: CALL 23258 0 2
70405: PUSH
70406: LD_INT 4
70408: ARRAY
70409: OR
70410: PUSH
70411: LD_VAR 0 3
70415: PPUSH
70416: CALL_OW 313
70420: PUSH
70421: LD_INT 0
70423: EQUAL
70424: OR
70425: IFFALSE 70429
// continue ;
70427: GO 70376
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70429: LD_VAR 0 3
70433: PPUSH
70434: LD_EXP 79
70438: PUSH
70439: LD_VAR 0 2
70443: ARRAY
70444: PUSH
70445: LD_INT 1
70447: ARRAY
70448: PUSH
70449: LD_INT 1
70451: ARRAY
70452: PPUSH
70453: LD_EXP 79
70457: PUSH
70458: LD_VAR 0 2
70462: ARRAY
70463: PUSH
70464: LD_INT 1
70466: ARRAY
70467: PUSH
70468: LD_INT 2
70470: ARRAY
70471: PPUSH
70472: LD_EXP 79
70476: PUSH
70477: LD_VAR 0 2
70481: ARRAY
70482: PUSH
70483: LD_INT 1
70485: ARRAY
70486: PUSH
70487: LD_INT 3
70489: ARRAY
70490: PPUSH
70491: LD_EXP 79
70495: PUSH
70496: LD_VAR 0 2
70500: ARRAY
70501: PUSH
70502: LD_INT 1
70504: ARRAY
70505: PUSH
70506: LD_INT 4
70508: ARRAY
70509: PPUSH
70510: CALL_OW 448
70514: PUSH
70515: LD_VAR 0 3
70519: PPUSH
70520: LD_EXP 79
70524: PUSH
70525: LD_VAR 0 2
70529: ARRAY
70530: PUSH
70531: LD_INT 1
70533: ARRAY
70534: PUSH
70535: LD_INT 1
70537: ARRAY
70538: PUSH
70539: LD_EXP 79
70543: PUSH
70544: LD_VAR 0 2
70548: ARRAY
70549: PUSH
70550: LD_INT 1
70552: ARRAY
70553: PUSH
70554: LD_INT 2
70556: ARRAY
70557: PUSH
70558: LD_EXP 79
70562: PUSH
70563: LD_VAR 0 2
70567: ARRAY
70568: PUSH
70569: LD_INT 1
70571: ARRAY
70572: PUSH
70573: LD_INT 3
70575: ARRAY
70576: PUSH
70577: LD_EXP 79
70581: PUSH
70582: LD_VAR 0 2
70586: ARRAY
70587: PUSH
70588: LD_INT 1
70590: ARRAY
70591: PUSH
70592: LD_INT 4
70594: ARRAY
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: LIST
70600: LIST
70601: PPUSH
70602: CALL 26929 0 2
70606: AND
70607: IFFALSE 70745
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70609: LD_VAR 0 3
70613: PPUSH
70614: LD_EXP 79
70618: PUSH
70619: LD_VAR 0 2
70623: ARRAY
70624: PUSH
70625: LD_INT 1
70627: ARRAY
70628: PUSH
70629: LD_INT 1
70631: ARRAY
70632: PPUSH
70633: LD_EXP 79
70637: PUSH
70638: LD_VAR 0 2
70642: ARRAY
70643: PUSH
70644: LD_INT 1
70646: ARRAY
70647: PUSH
70648: LD_INT 2
70650: ARRAY
70651: PPUSH
70652: LD_EXP 79
70656: PUSH
70657: LD_VAR 0 2
70661: ARRAY
70662: PUSH
70663: LD_INT 1
70665: ARRAY
70666: PUSH
70667: LD_INT 3
70669: ARRAY
70670: PPUSH
70671: LD_EXP 79
70675: PUSH
70676: LD_VAR 0 2
70680: ARRAY
70681: PUSH
70682: LD_INT 1
70684: ARRAY
70685: PUSH
70686: LD_INT 4
70688: ARRAY
70689: PPUSH
70690: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70694: LD_ADDR_VAR 0 4
70698: PUSH
70699: LD_EXP 79
70703: PUSH
70704: LD_VAR 0 2
70708: ARRAY
70709: PPUSH
70710: LD_INT 1
70712: PPUSH
70713: CALL_OW 3
70717: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70718: LD_ADDR_EXP 79
70722: PUSH
70723: LD_EXP 79
70727: PPUSH
70728: LD_VAR 0 2
70732: PPUSH
70733: LD_VAR 0 4
70737: PPUSH
70738: CALL_OW 1
70742: ST_TO_ADDR
// break ;
70743: GO 70747
// end ; end ;
70745: GO 70376
70747: POP
70748: POP
// end ;
70749: GO 70308
70751: POP
70752: POP
// end ;
70753: LD_VAR 0 1
70757: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70758: LD_INT 0
70760: PPUSH
70761: PPUSH
70762: PPUSH
// if not mc_bases then
70763: LD_EXP 58
70767: NOT
70768: IFFALSE 70772
// exit ;
70770: GO 70861
// for i = 1 to mc_bases do
70772: LD_ADDR_VAR 0 2
70776: PUSH
70777: DOUBLE
70778: LD_INT 1
70780: DEC
70781: ST_TO_ADDR
70782: LD_EXP 58
70786: PUSH
70787: FOR_TO
70788: IFFALSE 70859
// begin if mc_attack [ i ] then
70790: LD_EXP 78
70794: PUSH
70795: LD_VAR 0 2
70799: ARRAY
70800: IFFALSE 70857
// begin tmp := mc_attack [ i ] [ 1 ] ;
70802: LD_ADDR_VAR 0 3
70806: PUSH
70807: LD_EXP 78
70811: PUSH
70812: LD_VAR 0 2
70816: ARRAY
70817: PUSH
70818: LD_INT 1
70820: ARRAY
70821: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70822: LD_ADDR_EXP 78
70826: PUSH
70827: LD_EXP 78
70831: PPUSH
70832: LD_VAR 0 2
70836: PPUSH
70837: EMPTY
70838: PPUSH
70839: CALL_OW 1
70843: ST_TO_ADDR
// Attack ( tmp ) ;
70844: LD_VAR 0 3
70848: PPUSH
70849: CALL 49118 0 1
// exit ;
70853: POP
70854: POP
70855: GO 70861
// end ; end ;
70857: GO 70787
70859: POP
70860: POP
// end ;
70861: LD_VAR 0 1
70865: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70866: LD_INT 0
70868: PPUSH
70869: PPUSH
70870: PPUSH
70871: PPUSH
70872: PPUSH
70873: PPUSH
70874: PPUSH
// if not mc_bases then
70875: LD_EXP 58
70879: NOT
70880: IFFALSE 70884
// exit ;
70882: GO 71488
// for i = 1 to mc_bases do
70884: LD_ADDR_VAR 0 2
70888: PUSH
70889: DOUBLE
70890: LD_INT 1
70892: DEC
70893: ST_TO_ADDR
70894: LD_EXP 58
70898: PUSH
70899: FOR_TO
70900: IFFALSE 71486
// begin if not mc_bases [ i ] then
70902: LD_EXP 58
70906: PUSH
70907: LD_VAR 0 2
70911: ARRAY
70912: NOT
70913: IFFALSE 70917
// continue ;
70915: GO 70899
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70917: LD_ADDR_VAR 0 7
70921: PUSH
70922: LD_EXP 58
70926: PUSH
70927: LD_VAR 0 2
70931: ARRAY
70932: PUSH
70933: LD_INT 1
70935: ARRAY
70936: PPUSH
70937: CALL 17569 0 1
70941: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70942: LD_ADDR_EXP 81
70946: PUSH
70947: LD_EXP 81
70951: PPUSH
70952: LD_VAR 0 2
70956: PPUSH
70957: LD_EXP 58
70961: PUSH
70962: LD_VAR 0 2
70966: ARRAY
70967: PUSH
70968: LD_INT 1
70970: ARRAY
70971: PPUSH
70972: CALL_OW 255
70976: PPUSH
70977: LD_EXP 83
70981: PUSH
70982: LD_VAR 0 2
70986: ARRAY
70987: PPUSH
70988: CALL 15529 0 2
70992: PPUSH
70993: CALL_OW 1
70997: ST_TO_ADDR
// if not mc_scan [ i ] then
70998: LD_EXP 81
71002: PUSH
71003: LD_VAR 0 2
71007: ARRAY
71008: NOT
71009: IFFALSE 71164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71011: LD_ADDR_VAR 0 4
71015: PUSH
71016: LD_EXP 58
71020: PUSH
71021: LD_VAR 0 2
71025: ARRAY
71026: PPUSH
71027: LD_INT 2
71029: PUSH
71030: LD_INT 25
71032: PUSH
71033: LD_INT 5
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 25
71042: PUSH
71043: LD_INT 8
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 25
71052: PUSH
71053: LD_INT 9
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: EMPTY
71061: LIST
71062: LIST
71063: LIST
71064: LIST
71065: PPUSH
71066: CALL_OW 72
71070: ST_TO_ADDR
// if not tmp then
71071: LD_VAR 0 4
71075: NOT
71076: IFFALSE 71080
// continue ;
71078: GO 70899
// for j in tmp do
71080: LD_ADDR_VAR 0 3
71084: PUSH
71085: LD_VAR 0 4
71089: PUSH
71090: FOR_IN
71091: IFFALSE 71162
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71093: LD_VAR 0 3
71097: PPUSH
71098: CALL_OW 310
71102: PPUSH
71103: CALL_OW 266
71107: PUSH
71108: LD_INT 5
71110: EQUAL
71111: PUSH
71112: LD_VAR 0 3
71116: PPUSH
71117: CALL_OW 257
71121: PUSH
71122: LD_INT 1
71124: EQUAL
71125: AND
71126: PUSH
71127: LD_VAR 0 3
71131: PPUSH
71132: CALL_OW 459
71136: NOT
71137: AND
71138: PUSH
71139: LD_VAR 0 7
71143: AND
71144: IFFALSE 71160
// ComChangeProfession ( j , class ) ;
71146: LD_VAR 0 3
71150: PPUSH
71151: LD_VAR 0 7
71155: PPUSH
71156: CALL_OW 123
71160: GO 71090
71162: POP
71163: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71164: LD_EXP 81
71168: PUSH
71169: LD_VAR 0 2
71173: ARRAY
71174: PUSH
71175: LD_EXP 80
71179: PUSH
71180: LD_VAR 0 2
71184: ARRAY
71185: NOT
71186: AND
71187: PUSH
71188: LD_EXP 58
71192: PUSH
71193: LD_VAR 0 2
71197: ARRAY
71198: PPUSH
71199: LD_INT 30
71201: PUSH
71202: LD_INT 32
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: PPUSH
71209: CALL_OW 72
71213: NOT
71214: AND
71215: PUSH
71216: LD_EXP 58
71220: PUSH
71221: LD_VAR 0 2
71225: ARRAY
71226: PPUSH
71227: LD_INT 2
71229: PUSH
71230: LD_INT 30
71232: PUSH
71233: LD_INT 4
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: LD_INT 30
71242: PUSH
71243: LD_INT 5
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: LIST
71254: PPUSH
71255: CALL_OW 72
71259: NOT
71260: AND
71261: IFFALSE 71393
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71263: LD_ADDR_VAR 0 4
71267: PUSH
71268: LD_EXP 58
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PPUSH
71279: LD_INT 2
71281: PUSH
71282: LD_INT 25
71284: PUSH
71285: LD_INT 1
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 25
71294: PUSH
71295: LD_INT 5
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PUSH
71302: LD_INT 25
71304: PUSH
71305: LD_INT 8
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: LD_INT 25
71314: PUSH
71315: LD_INT 9
71317: PUSH
71318: EMPTY
71319: LIST
71320: LIST
71321: PUSH
71322: EMPTY
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: PPUSH
71329: CALL_OW 72
71333: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71334: LD_ADDR_VAR 0 4
71338: PUSH
71339: LD_VAR 0 4
71343: PUSH
71344: LD_VAR 0 4
71348: PPUSH
71349: LD_INT 18
71351: PPUSH
71352: CALL 53862 0 2
71356: DIFF
71357: ST_TO_ADDR
// if tmp then
71358: LD_VAR 0 4
71362: IFFALSE 71393
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
71364: LD_VAR 0 2
71368: PPUSH
71369: LD_VAR 0 4
71373: PPUSH
71374: LD_EXP 83
71378: PUSH
71379: LD_VAR 0 2
71383: ARRAY
71384: PPUSH
71385: CALL 15564 0 3
// exit ;
71389: POP
71390: POP
71391: GO 71488
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
71393: LD_EXP 81
71397: PUSH
71398: LD_VAR 0 2
71402: ARRAY
71403: PUSH
71404: LD_EXP 80
71408: PUSH
71409: LD_VAR 0 2
71413: ARRAY
71414: AND
71415: IFFALSE 71484
// begin tmp := mc_defender [ i ] ;
71417: LD_ADDR_VAR 0 4
71421: PUSH
71422: LD_EXP 80
71426: PUSH
71427: LD_VAR 0 2
71431: ARRAY
71432: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71433: LD_ADDR_EXP 80
71437: PUSH
71438: LD_EXP 80
71442: PPUSH
71443: LD_VAR 0 2
71447: PPUSH
71448: EMPTY
71449: PPUSH
71450: CALL_OW 1
71454: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
71455: LD_VAR 0 2
71459: PPUSH
71460: LD_VAR 0 4
71464: PPUSH
71465: LD_EXP 81
71469: PUSH
71470: LD_VAR 0 2
71474: ARRAY
71475: PPUSH
71476: CALL 16062 0 3
// exit ;
71480: POP
71481: POP
71482: GO 71488
// end ; end ;
71484: GO 70899
71486: POP
71487: POP
// end ;
71488: LD_VAR 0 1
71492: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71493: LD_INT 0
71495: PPUSH
71496: PPUSH
71497: PPUSH
71498: PPUSH
71499: PPUSH
71500: PPUSH
71501: PPUSH
71502: PPUSH
71503: PPUSH
71504: PPUSH
71505: PPUSH
// if not mc_bases then
71506: LD_EXP 58
71510: NOT
71511: IFFALSE 71515
// exit ;
71513: GO 72602
// for i = 1 to mc_bases do
71515: LD_ADDR_VAR 0 2
71519: PUSH
71520: DOUBLE
71521: LD_INT 1
71523: DEC
71524: ST_TO_ADDR
71525: LD_EXP 58
71529: PUSH
71530: FOR_TO
71531: IFFALSE 72600
// begin tmp := mc_lab [ i ] ;
71533: LD_ADDR_VAR 0 6
71537: PUSH
71538: LD_EXP 91
71542: PUSH
71543: LD_VAR 0 2
71547: ARRAY
71548: ST_TO_ADDR
// if not tmp then
71549: LD_VAR 0 6
71553: NOT
71554: IFFALSE 71558
// continue ;
71556: GO 71530
// idle_lab := 0 ;
71558: LD_ADDR_VAR 0 11
71562: PUSH
71563: LD_INT 0
71565: ST_TO_ADDR
// for j in tmp do
71566: LD_ADDR_VAR 0 3
71570: PUSH
71571: LD_VAR 0 6
71575: PUSH
71576: FOR_IN
71577: IFFALSE 72596
// begin researching := false ;
71579: LD_ADDR_VAR 0 10
71583: PUSH
71584: LD_INT 0
71586: ST_TO_ADDR
// side := GetSide ( j ) ;
71587: LD_ADDR_VAR 0 4
71591: PUSH
71592: LD_VAR 0 3
71596: PPUSH
71597: CALL_OW 255
71601: ST_TO_ADDR
// if not mc_tech [ side ] then
71602: LD_EXP 85
71606: PUSH
71607: LD_VAR 0 4
71611: ARRAY
71612: NOT
71613: IFFALSE 71617
// continue ;
71615: GO 71576
// if BuildingStatus ( j ) = bs_idle then
71617: LD_VAR 0 3
71621: PPUSH
71622: CALL_OW 461
71626: PUSH
71627: LD_INT 2
71629: EQUAL
71630: IFFALSE 71818
// begin if idle_lab and UnitsInside ( j ) < 6 then
71632: LD_VAR 0 11
71636: PUSH
71637: LD_VAR 0 3
71641: PPUSH
71642: CALL_OW 313
71646: PUSH
71647: LD_INT 6
71649: LESS
71650: AND
71651: IFFALSE 71722
// begin tmp2 := UnitsInside ( idle_lab ) ;
71653: LD_ADDR_VAR 0 9
71657: PUSH
71658: LD_VAR 0 11
71662: PPUSH
71663: CALL_OW 313
71667: ST_TO_ADDR
// if tmp2 then
71668: LD_VAR 0 9
71672: IFFALSE 71714
// for x in tmp2 do
71674: LD_ADDR_VAR 0 7
71678: PUSH
71679: LD_VAR 0 9
71683: PUSH
71684: FOR_IN
71685: IFFALSE 71712
// begin ComExitBuilding ( x ) ;
71687: LD_VAR 0 7
71691: PPUSH
71692: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71696: LD_VAR 0 7
71700: PPUSH
71701: LD_VAR 0 3
71705: PPUSH
71706: CALL_OW 180
// end ;
71710: GO 71684
71712: POP
71713: POP
// idle_lab := 0 ;
71714: LD_ADDR_VAR 0 11
71718: PUSH
71719: LD_INT 0
71721: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71722: LD_ADDR_VAR 0 5
71726: PUSH
71727: LD_EXP 85
71731: PUSH
71732: LD_VAR 0 4
71736: ARRAY
71737: PUSH
71738: FOR_IN
71739: IFFALSE 71799
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71741: LD_VAR 0 3
71745: PPUSH
71746: LD_VAR 0 5
71750: PPUSH
71751: CALL_OW 430
71755: PUSH
71756: LD_VAR 0 4
71760: PPUSH
71761: LD_VAR 0 5
71765: PPUSH
71766: CALL 14634 0 2
71770: AND
71771: IFFALSE 71797
// begin researching := true ;
71773: LD_ADDR_VAR 0 10
71777: PUSH
71778: LD_INT 1
71780: ST_TO_ADDR
// ComResearch ( j , t ) ;
71781: LD_VAR 0 3
71785: PPUSH
71786: LD_VAR 0 5
71790: PPUSH
71791: CALL_OW 124
// break ;
71795: GO 71799
// end ;
71797: GO 71738
71799: POP
71800: POP
// if not researching then
71801: LD_VAR 0 10
71805: NOT
71806: IFFALSE 71818
// idle_lab := j ;
71808: LD_ADDR_VAR 0 11
71812: PUSH
71813: LD_VAR 0 3
71817: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71818: LD_VAR 0 3
71822: PPUSH
71823: CALL_OW 461
71827: PUSH
71828: LD_INT 10
71830: EQUAL
71831: IFFALSE 72419
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71833: LD_EXP 87
71837: PUSH
71838: LD_VAR 0 2
71842: ARRAY
71843: NOT
71844: PUSH
71845: LD_EXP 88
71849: PUSH
71850: LD_VAR 0 2
71854: ARRAY
71855: NOT
71856: AND
71857: PUSH
71858: LD_EXP 85
71862: PUSH
71863: LD_VAR 0 4
71867: ARRAY
71868: PUSH
71869: LD_INT 1
71871: GREATER
71872: AND
71873: IFFALSE 72004
// begin ComCancel ( j ) ;
71875: LD_VAR 0 3
71879: PPUSH
71880: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71884: LD_ADDR_EXP 85
71888: PUSH
71889: LD_EXP 85
71893: PPUSH
71894: LD_VAR 0 4
71898: PPUSH
71899: LD_EXP 85
71903: PUSH
71904: LD_VAR 0 4
71908: ARRAY
71909: PPUSH
71910: LD_EXP 85
71914: PUSH
71915: LD_VAR 0 4
71919: ARRAY
71920: PUSH
71921: LD_INT 1
71923: MINUS
71924: PPUSH
71925: LD_EXP 85
71929: PUSH
71930: LD_VAR 0 4
71934: ARRAY
71935: PPUSH
71936: LD_INT 0
71938: PPUSH
71939: CALL 20083 0 4
71943: PPUSH
71944: CALL_OW 1
71948: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71949: LD_ADDR_EXP 85
71953: PUSH
71954: LD_EXP 85
71958: PPUSH
71959: LD_VAR 0 4
71963: PPUSH
71964: LD_EXP 85
71968: PUSH
71969: LD_VAR 0 4
71973: ARRAY
71974: PPUSH
71975: LD_EXP 85
71979: PUSH
71980: LD_VAR 0 4
71984: ARRAY
71985: PPUSH
71986: LD_INT 1
71988: PPUSH
71989: LD_INT 0
71991: PPUSH
71992: CALL 20083 0 4
71996: PPUSH
71997: CALL_OW 1
72001: ST_TO_ADDR
// continue ;
72002: GO 71576
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72004: LD_EXP 87
72008: PUSH
72009: LD_VAR 0 2
72013: ARRAY
72014: PUSH
72015: LD_EXP 88
72019: PUSH
72020: LD_VAR 0 2
72024: ARRAY
72025: NOT
72026: AND
72027: IFFALSE 72154
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72029: LD_ADDR_EXP 88
72033: PUSH
72034: LD_EXP 88
72038: PPUSH
72039: LD_VAR 0 2
72043: PUSH
72044: LD_EXP 88
72048: PUSH
72049: LD_VAR 0 2
72053: ARRAY
72054: PUSH
72055: LD_INT 1
72057: PLUS
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: PPUSH
72063: LD_EXP 87
72067: PUSH
72068: LD_VAR 0 2
72072: ARRAY
72073: PUSH
72074: LD_INT 1
72076: ARRAY
72077: PPUSH
72078: CALL 20665 0 3
72082: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72083: LD_EXP 87
72087: PUSH
72088: LD_VAR 0 2
72092: ARRAY
72093: PUSH
72094: LD_INT 1
72096: ARRAY
72097: PPUSH
72098: LD_INT 112
72100: PPUSH
72101: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72105: LD_ADDR_VAR 0 9
72109: PUSH
72110: LD_EXP 87
72114: PUSH
72115: LD_VAR 0 2
72119: ARRAY
72120: PPUSH
72121: LD_INT 1
72123: PPUSH
72124: CALL_OW 3
72128: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72129: LD_ADDR_EXP 87
72133: PUSH
72134: LD_EXP 87
72138: PPUSH
72139: LD_VAR 0 2
72143: PPUSH
72144: LD_VAR 0 9
72148: PPUSH
72149: CALL_OW 1
72153: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72154: LD_EXP 87
72158: PUSH
72159: LD_VAR 0 2
72163: ARRAY
72164: PUSH
72165: LD_EXP 88
72169: PUSH
72170: LD_VAR 0 2
72174: ARRAY
72175: AND
72176: PUSH
72177: LD_EXP 88
72181: PUSH
72182: LD_VAR 0 2
72186: ARRAY
72187: PUSH
72188: LD_INT 1
72190: ARRAY
72191: PPUSH
72192: CALL_OW 310
72196: NOT
72197: AND
72198: PUSH
72199: LD_VAR 0 3
72203: PPUSH
72204: CALL_OW 313
72208: PUSH
72209: LD_INT 6
72211: EQUAL
72212: AND
72213: IFFALSE 72269
// begin tmp2 := UnitsInside ( j ) ;
72215: LD_ADDR_VAR 0 9
72219: PUSH
72220: LD_VAR 0 3
72224: PPUSH
72225: CALL_OW 313
72229: ST_TO_ADDR
// if tmp2 = 6 then
72230: LD_VAR 0 9
72234: PUSH
72235: LD_INT 6
72237: EQUAL
72238: IFFALSE 72269
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72240: LD_VAR 0 9
72244: PUSH
72245: LD_INT 1
72247: ARRAY
72248: PPUSH
72249: LD_INT 112
72251: PPUSH
72252: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72256: LD_VAR 0 9
72260: PUSH
72261: LD_INT 1
72263: ARRAY
72264: PPUSH
72265: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72269: LD_EXP 88
72273: PUSH
72274: LD_VAR 0 2
72278: ARRAY
72279: PUSH
72280: LD_EXP 88
72284: PUSH
72285: LD_VAR 0 2
72289: ARRAY
72290: PUSH
72291: LD_INT 1
72293: ARRAY
72294: PPUSH
72295: CALL_OW 314
72299: NOT
72300: AND
72301: PUSH
72302: LD_EXP 88
72306: PUSH
72307: LD_VAR 0 2
72311: ARRAY
72312: PUSH
72313: LD_INT 1
72315: ARRAY
72316: PPUSH
72317: CALL_OW 310
72321: NOT
72322: AND
72323: IFFALSE 72349
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72325: LD_EXP 88
72329: PUSH
72330: LD_VAR 0 2
72334: ARRAY
72335: PUSH
72336: LD_INT 1
72338: ARRAY
72339: PPUSH
72340: LD_VAR 0 3
72344: PPUSH
72345: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72349: LD_EXP 88
72353: PUSH
72354: LD_VAR 0 2
72358: ARRAY
72359: PUSH
72360: LD_INT 1
72362: ARRAY
72363: PPUSH
72364: CALL_OW 310
72368: PUSH
72369: LD_EXP 88
72373: PUSH
72374: LD_VAR 0 2
72378: ARRAY
72379: PUSH
72380: LD_INT 1
72382: ARRAY
72383: PPUSH
72384: CALL_OW 310
72388: PPUSH
72389: CALL_OW 461
72393: PUSH
72394: LD_INT 3
72396: NONEQUAL
72397: AND
72398: IFFALSE 72419
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72400: LD_EXP 88
72404: PUSH
72405: LD_VAR 0 2
72409: ARRAY
72410: PUSH
72411: LD_INT 1
72413: ARRAY
72414: PPUSH
72415: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72419: LD_VAR 0 3
72423: PPUSH
72424: CALL_OW 461
72428: PUSH
72429: LD_INT 6
72431: EQUAL
72432: PUSH
72433: LD_VAR 0 6
72437: PUSH
72438: LD_INT 1
72440: GREATER
72441: AND
72442: IFFALSE 72594
// begin sci := [ ] ;
72444: LD_ADDR_VAR 0 8
72448: PUSH
72449: EMPTY
72450: ST_TO_ADDR
// for x in ( tmp diff j ) do
72451: LD_ADDR_VAR 0 7
72455: PUSH
72456: LD_VAR 0 6
72460: PUSH
72461: LD_VAR 0 3
72465: DIFF
72466: PUSH
72467: FOR_IN
72468: IFFALSE 72520
// begin if sci = 6 then
72470: LD_VAR 0 8
72474: PUSH
72475: LD_INT 6
72477: EQUAL
72478: IFFALSE 72482
// break ;
72480: GO 72520
// if BuildingStatus ( x ) = bs_idle then
72482: LD_VAR 0 7
72486: PPUSH
72487: CALL_OW 461
72491: PUSH
72492: LD_INT 2
72494: EQUAL
72495: IFFALSE 72518
// sci := sci ^ UnitsInside ( x ) ;
72497: LD_ADDR_VAR 0 8
72501: PUSH
72502: LD_VAR 0 8
72506: PUSH
72507: LD_VAR 0 7
72511: PPUSH
72512: CALL_OW 313
72516: ADD
72517: ST_TO_ADDR
// end ;
72518: GO 72467
72520: POP
72521: POP
// if not sci then
72522: LD_VAR 0 8
72526: NOT
72527: IFFALSE 72531
// continue ;
72529: GO 71576
// for x in sci do
72531: LD_ADDR_VAR 0 7
72535: PUSH
72536: LD_VAR 0 8
72540: PUSH
72541: FOR_IN
72542: IFFALSE 72592
// if IsInUnit ( x ) and not HasTask ( x ) then
72544: LD_VAR 0 7
72548: PPUSH
72549: CALL_OW 310
72553: PUSH
72554: LD_VAR 0 7
72558: PPUSH
72559: CALL_OW 314
72563: NOT
72564: AND
72565: IFFALSE 72590
// begin ComExitBuilding ( x ) ;
72567: LD_VAR 0 7
72571: PPUSH
72572: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72576: LD_VAR 0 7
72580: PPUSH
72581: LD_VAR 0 3
72585: PPUSH
72586: CALL_OW 180
// end ;
72590: GO 72541
72592: POP
72593: POP
// end ; end ;
72594: GO 71576
72596: POP
72597: POP
// end ;
72598: GO 71530
72600: POP
72601: POP
// end ;
72602: LD_VAR 0 1
72606: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72607: LD_INT 0
72609: PPUSH
72610: PPUSH
// if not mc_bases then
72611: LD_EXP 58
72615: NOT
72616: IFFALSE 72620
// exit ;
72618: GO 72701
// for i = 1 to mc_bases do
72620: LD_ADDR_VAR 0 2
72624: PUSH
72625: DOUBLE
72626: LD_INT 1
72628: DEC
72629: ST_TO_ADDR
72630: LD_EXP 58
72634: PUSH
72635: FOR_TO
72636: IFFALSE 72699
// if mc_mines [ i ] and mc_miners [ i ] then
72638: LD_EXP 71
72642: PUSH
72643: LD_VAR 0 2
72647: ARRAY
72648: PUSH
72649: LD_EXP 72
72653: PUSH
72654: LD_VAR 0 2
72658: ARRAY
72659: AND
72660: IFFALSE 72697
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72662: LD_EXP 72
72666: PUSH
72667: LD_VAR 0 2
72671: ARRAY
72672: PUSH
72673: LD_INT 1
72675: ARRAY
72676: PPUSH
72677: CALL_OW 255
72681: PPUSH
72682: LD_EXP 71
72686: PUSH
72687: LD_VAR 0 2
72691: ARRAY
72692: PPUSH
72693: CALL 17722 0 2
72697: GO 72635
72699: POP
72700: POP
// end ;
72701: LD_VAR 0 1
72705: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72706: LD_INT 0
72708: PPUSH
72709: PPUSH
72710: PPUSH
72711: PPUSH
72712: PPUSH
72713: PPUSH
72714: PPUSH
72715: PPUSH
// if not mc_bases or not mc_parking then
72716: LD_EXP 58
72720: NOT
72721: PUSH
72722: LD_EXP 82
72726: NOT
72727: OR
72728: IFFALSE 72732
// exit ;
72730: GO 73444
// for i = 1 to mc_bases do
72732: LD_ADDR_VAR 0 2
72736: PUSH
72737: DOUBLE
72738: LD_INT 1
72740: DEC
72741: ST_TO_ADDR
72742: LD_EXP 58
72746: PUSH
72747: FOR_TO
72748: IFFALSE 73442
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72750: LD_EXP 58
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: NOT
72761: PUSH
72762: LD_EXP 82
72766: PUSH
72767: LD_VAR 0 2
72771: ARRAY
72772: NOT
72773: OR
72774: IFFALSE 72778
// continue ;
72776: GO 72747
// if mc_scan [ i ] then
72778: LD_EXP 81
72782: PUSH
72783: LD_VAR 0 2
72787: ARRAY
72788: IFFALSE 72814
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72790: LD_ADDR_EXP 70
72794: PUSH
72795: LD_EXP 70
72799: PPUSH
72800: LD_VAR 0 2
72804: PPUSH
72805: EMPTY
72806: PPUSH
72807: CALL_OW 1
72811: ST_TO_ADDR
// continue ;
72812: GO 72747
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72814: LD_ADDR_VAR 0 5
72818: PUSH
72819: LD_EXP 58
72823: PUSH
72824: LD_VAR 0 2
72828: ARRAY
72829: PUSH
72830: LD_INT 1
72832: ARRAY
72833: PPUSH
72834: CALL_OW 255
72838: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72839: LD_ADDR_VAR 0 6
72843: PUSH
72844: LD_EXP 58
72848: PUSH
72849: LD_VAR 0 2
72853: ARRAY
72854: PPUSH
72855: LD_INT 30
72857: PUSH
72858: LD_INT 3
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PPUSH
72865: CALL_OW 72
72869: ST_TO_ADDR
// if not fac then
72870: LD_VAR 0 6
72874: NOT
72875: IFFALSE 72926
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72877: LD_ADDR_VAR 0 6
72881: PUSH
72882: LD_EXP 58
72886: PUSH
72887: LD_VAR 0 2
72891: ARRAY
72892: PPUSH
72893: LD_INT 2
72895: PUSH
72896: LD_INT 30
72898: PUSH
72899: LD_INT 0
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 30
72908: PUSH
72909: LD_INT 1
72911: PUSH
72912: EMPTY
72913: LIST
72914: LIST
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: LIST
72920: PPUSH
72921: CALL_OW 72
72925: ST_TO_ADDR
// if not fac then
72926: LD_VAR 0 6
72930: NOT
72931: IFFALSE 72935
// continue ;
72933: GO 72747
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72935: LD_ADDR_VAR 0 7
72939: PUSH
72940: LD_EXP 82
72944: PUSH
72945: LD_VAR 0 2
72949: ARRAY
72950: PPUSH
72951: LD_INT 22
72953: PUSH
72954: LD_VAR 0 5
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 21
72965: PUSH
72966: LD_INT 2
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: PUSH
72973: LD_INT 3
72975: PUSH
72976: LD_INT 24
72978: PUSH
72979: LD_INT 1000
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: EMPTY
72987: LIST
72988: LIST
72989: PUSH
72990: EMPTY
72991: LIST
72992: LIST
72993: LIST
72994: PPUSH
72995: CALL_OW 70
72999: PUSH
73000: LD_INT 22
73002: PUSH
73003: LD_VAR 0 5
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PUSH
73012: LD_INT 91
73014: PUSH
73015: LD_VAR 0 6
73019: PUSH
73020: LD_INT 1
73022: ARRAY
73023: PUSH
73024: LD_INT 25
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: LIST
73031: PUSH
73032: LD_INT 21
73034: PUSH
73035: LD_INT 2
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 3
73044: PUSH
73045: LD_INT 24
73047: PUSH
73048: LD_INT 1000
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: EMPTY
73056: LIST
73057: LIST
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: PPUSH
73065: CALL_OW 69
73069: UNION
73070: ST_TO_ADDR
// if not vehs then
73071: LD_VAR 0 7
73075: NOT
73076: IFFALSE 73102
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73078: LD_ADDR_EXP 70
73082: PUSH
73083: LD_EXP 70
73087: PPUSH
73088: LD_VAR 0 2
73092: PPUSH
73093: EMPTY
73094: PPUSH
73095: CALL_OW 1
73099: ST_TO_ADDR
// continue ;
73100: GO 72747
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73102: LD_ADDR_VAR 0 8
73106: PUSH
73107: LD_EXP 58
73111: PUSH
73112: LD_VAR 0 2
73116: ARRAY
73117: PPUSH
73118: LD_INT 30
73120: PUSH
73121: LD_INT 3
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: PPUSH
73128: CALL_OW 72
73132: ST_TO_ADDR
// if tmp then
73133: LD_VAR 0 8
73137: IFFALSE 73240
// begin for j in tmp do
73139: LD_ADDR_VAR 0 3
73143: PUSH
73144: LD_VAR 0 8
73148: PUSH
73149: FOR_IN
73150: IFFALSE 73238
// for k in UnitsInside ( j ) do
73152: LD_ADDR_VAR 0 4
73156: PUSH
73157: LD_VAR 0 3
73161: PPUSH
73162: CALL_OW 313
73166: PUSH
73167: FOR_IN
73168: IFFALSE 73234
// if k then
73170: LD_VAR 0 4
73174: IFFALSE 73232
// if not k in mc_repair_vehicle [ i ] then
73176: LD_VAR 0 4
73180: PUSH
73181: LD_EXP 70
73185: PUSH
73186: LD_VAR 0 2
73190: ARRAY
73191: IN
73192: NOT
73193: IFFALSE 73232
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73195: LD_ADDR_EXP 70
73199: PUSH
73200: LD_EXP 70
73204: PPUSH
73205: LD_VAR 0 2
73209: PPUSH
73210: LD_EXP 70
73214: PUSH
73215: LD_VAR 0 2
73219: ARRAY
73220: PUSH
73221: LD_VAR 0 4
73225: UNION
73226: PPUSH
73227: CALL_OW 1
73231: ST_TO_ADDR
73232: GO 73167
73234: POP
73235: POP
73236: GO 73149
73238: POP
73239: POP
// end ; if not mc_repair_vehicle [ i ] then
73240: LD_EXP 70
73244: PUSH
73245: LD_VAR 0 2
73249: ARRAY
73250: NOT
73251: IFFALSE 73255
// continue ;
73253: GO 72747
// for j in mc_repair_vehicle [ i ] do
73255: LD_ADDR_VAR 0 3
73259: PUSH
73260: LD_EXP 70
73264: PUSH
73265: LD_VAR 0 2
73269: ARRAY
73270: PUSH
73271: FOR_IN
73272: IFFALSE 73438
// begin if GetClass ( j ) <> 3 then
73274: LD_VAR 0 3
73278: PPUSH
73279: CALL_OW 257
73283: PUSH
73284: LD_INT 3
73286: NONEQUAL
73287: IFFALSE 73328
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73289: LD_ADDR_EXP 70
73293: PUSH
73294: LD_EXP 70
73298: PPUSH
73299: LD_VAR 0 2
73303: PPUSH
73304: LD_EXP 70
73308: PUSH
73309: LD_VAR 0 2
73313: ARRAY
73314: PUSH
73315: LD_VAR 0 3
73319: DIFF
73320: PPUSH
73321: CALL_OW 1
73325: ST_TO_ADDR
// continue ;
73326: GO 73271
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73328: LD_VAR 0 3
73332: PPUSH
73333: CALL_OW 311
73337: NOT
73338: PUSH
73339: LD_VAR 0 3
73343: PUSH
73344: LD_EXP 61
73348: PUSH
73349: LD_VAR 0 2
73353: ARRAY
73354: PUSH
73355: LD_INT 1
73357: ARRAY
73358: IN
73359: NOT
73360: AND
73361: PUSH
73362: LD_VAR 0 3
73366: PUSH
73367: LD_EXP 61
73371: PUSH
73372: LD_VAR 0 2
73376: ARRAY
73377: PUSH
73378: LD_INT 2
73380: ARRAY
73381: IN
73382: NOT
73383: AND
73384: IFFALSE 73436
// begin if IsInUnit ( j ) then
73386: LD_VAR 0 3
73390: PPUSH
73391: CALL_OW 310
73395: IFFALSE 73406
// ComExitBuilding ( j ) ;
73397: LD_VAR 0 3
73401: PPUSH
73402: CALL_OW 122
// if not HasTask ( j ) then
73406: LD_VAR 0 3
73410: PPUSH
73411: CALL_OW 314
73415: NOT
73416: IFFALSE 73436
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
73418: LD_VAR 0 3
73422: PPUSH
73423: LD_VAR 0 7
73427: PUSH
73428: LD_INT 1
73430: ARRAY
73431: PPUSH
73432: CALL_OW 189
// end ; end ;
73436: GO 73271
73438: POP
73439: POP
// end ;
73440: GO 72747
73442: POP
73443: POP
// end ;
73444: LD_VAR 0 1
73448: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73449: LD_INT 0
73451: PPUSH
73452: PPUSH
73453: PPUSH
73454: PPUSH
73455: PPUSH
73456: PPUSH
73457: PPUSH
73458: PPUSH
73459: PPUSH
73460: PPUSH
73461: PPUSH
// if not mc_bases then
73462: LD_EXP 58
73466: NOT
73467: IFFALSE 73471
// exit ;
73469: GO 74273
// for i = 1 to mc_bases do
73471: LD_ADDR_VAR 0 2
73475: PUSH
73476: DOUBLE
73477: LD_INT 1
73479: DEC
73480: ST_TO_ADDR
73481: LD_EXP 58
73485: PUSH
73486: FOR_TO
73487: IFFALSE 74271
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73489: LD_EXP 86
73493: PUSH
73494: LD_VAR 0 2
73498: ARRAY
73499: NOT
73500: PUSH
73501: LD_EXP 61
73505: PUSH
73506: LD_VAR 0 2
73510: ARRAY
73511: PUSH
73512: LD_INT 1
73514: ARRAY
73515: OR
73516: PUSH
73517: LD_EXP 61
73521: PUSH
73522: LD_VAR 0 2
73526: ARRAY
73527: PUSH
73528: LD_INT 2
73530: ARRAY
73531: OR
73532: PUSH
73533: LD_EXP 84
73537: PUSH
73538: LD_VAR 0 2
73542: ARRAY
73543: PPUSH
73544: LD_INT 1
73546: PPUSH
73547: CALL_OW 325
73551: NOT
73552: OR
73553: PUSH
73554: LD_EXP 81
73558: PUSH
73559: LD_VAR 0 2
73563: ARRAY
73564: OR
73565: IFFALSE 73569
// continue ;
73567: GO 73486
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73569: LD_ADDR_VAR 0 8
73573: PUSH
73574: LD_EXP 58
73578: PUSH
73579: LD_VAR 0 2
73583: ARRAY
73584: PPUSH
73585: LD_INT 25
73587: PUSH
73588: LD_INT 4
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PUSH
73595: LD_INT 50
73597: PUSH
73598: EMPTY
73599: LIST
73600: PUSH
73601: LD_INT 3
73603: PUSH
73604: LD_INT 60
73606: PUSH
73607: EMPTY
73608: LIST
73609: PUSH
73610: EMPTY
73611: LIST
73612: LIST
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: LIST
73618: PPUSH
73619: CALL_OW 72
73623: PUSH
73624: LD_EXP 62
73628: PUSH
73629: LD_VAR 0 2
73633: ARRAY
73634: DIFF
73635: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73636: LD_ADDR_VAR 0 9
73640: PUSH
73641: LD_EXP 58
73645: PUSH
73646: LD_VAR 0 2
73650: ARRAY
73651: PPUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 30
73657: PUSH
73658: LD_INT 0
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 30
73667: PUSH
73668: LD_INT 1
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: LIST
73679: PPUSH
73680: CALL_OW 72
73684: ST_TO_ADDR
// if not tmp or not dep then
73685: LD_VAR 0 8
73689: NOT
73690: PUSH
73691: LD_VAR 0 9
73695: NOT
73696: OR
73697: IFFALSE 73701
// continue ;
73699: GO 73486
// side := GetSide ( tmp [ 1 ] ) ;
73701: LD_ADDR_VAR 0 11
73705: PUSH
73706: LD_VAR 0 8
73710: PUSH
73711: LD_INT 1
73713: ARRAY
73714: PPUSH
73715: CALL_OW 255
73719: ST_TO_ADDR
// dep := dep [ 1 ] ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_VAR 0 9
73729: PUSH
73730: LD_INT 1
73732: ARRAY
73733: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73734: LD_ADDR_VAR 0 7
73738: PUSH
73739: LD_EXP 86
73743: PUSH
73744: LD_VAR 0 2
73748: ARRAY
73749: PPUSH
73750: LD_INT 22
73752: PUSH
73753: LD_INT 0
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: LD_INT 25
73762: PUSH
73763: LD_INT 12
73765: PUSH
73766: EMPTY
73767: LIST
73768: LIST
73769: PUSH
73770: EMPTY
73771: LIST
73772: LIST
73773: PPUSH
73774: CALL_OW 70
73778: PUSH
73779: LD_INT 22
73781: PUSH
73782: LD_INT 0
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 25
73791: PUSH
73792: LD_INT 12
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PUSH
73799: LD_INT 91
73801: PUSH
73802: LD_VAR 0 9
73806: PUSH
73807: LD_INT 20
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: LIST
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: LIST
73819: PPUSH
73820: CALL_OW 69
73824: UNION
73825: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73826: LD_ADDR_VAR 0 10
73830: PUSH
73831: LD_EXP 86
73835: PUSH
73836: LD_VAR 0 2
73840: ARRAY
73841: PPUSH
73842: LD_INT 81
73844: PUSH
73845: LD_VAR 0 11
73849: PUSH
73850: EMPTY
73851: LIST
73852: LIST
73853: PPUSH
73854: CALL_OW 70
73858: ST_TO_ADDR
// if not apes or danger_at_area then
73859: LD_VAR 0 7
73863: NOT
73864: PUSH
73865: LD_VAR 0 10
73869: OR
73870: IFFALSE 73920
// begin if mc_taming [ i ] then
73872: LD_EXP 89
73876: PUSH
73877: LD_VAR 0 2
73881: ARRAY
73882: IFFALSE 73918
// begin MC_Reset ( i , 121 ) ;
73884: LD_VAR 0 2
73888: PPUSH
73889: LD_INT 121
73891: PPUSH
73892: CALL 59555 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73896: LD_ADDR_EXP 89
73900: PUSH
73901: LD_EXP 89
73905: PPUSH
73906: LD_VAR 0 2
73910: PPUSH
73911: EMPTY
73912: PPUSH
73913: CALL_OW 1
73917: ST_TO_ADDR
// end ; continue ;
73918: GO 73486
// end ; for j in tmp do
73920: LD_ADDR_VAR 0 3
73924: PUSH
73925: LD_VAR 0 8
73929: PUSH
73930: FOR_IN
73931: IFFALSE 74267
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73933: LD_VAR 0 3
73937: PUSH
73938: LD_EXP 89
73942: PUSH
73943: LD_VAR 0 2
73947: ARRAY
73948: IN
73949: NOT
73950: PUSH
73951: LD_EXP 89
73955: PUSH
73956: LD_VAR 0 2
73960: ARRAY
73961: PUSH
73962: LD_INT 3
73964: LESS
73965: AND
73966: IFFALSE 74024
// begin SetTag ( j , 121 ) ;
73968: LD_VAR 0 3
73972: PPUSH
73973: LD_INT 121
73975: PPUSH
73976: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73980: LD_ADDR_EXP 89
73984: PUSH
73985: LD_EXP 89
73989: PPUSH
73990: LD_VAR 0 2
73994: PUSH
73995: LD_EXP 89
73999: PUSH
74000: LD_VAR 0 2
74004: ARRAY
74005: PUSH
74006: LD_INT 1
74008: PLUS
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PPUSH
74014: LD_VAR 0 3
74018: PPUSH
74019: CALL 20665 0 3
74023: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74024: LD_VAR 0 3
74028: PUSH
74029: LD_EXP 89
74033: PUSH
74034: LD_VAR 0 2
74038: ARRAY
74039: IN
74040: IFFALSE 74265
// begin if GetClass ( j ) <> 4 then
74042: LD_VAR 0 3
74046: PPUSH
74047: CALL_OW 257
74051: PUSH
74052: LD_INT 4
74054: NONEQUAL
74055: IFFALSE 74108
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74057: LD_ADDR_EXP 89
74061: PUSH
74062: LD_EXP 89
74066: PPUSH
74067: LD_VAR 0 2
74071: PPUSH
74072: LD_EXP 89
74076: PUSH
74077: LD_VAR 0 2
74081: ARRAY
74082: PUSH
74083: LD_VAR 0 3
74087: DIFF
74088: PPUSH
74089: CALL_OW 1
74093: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74094: LD_VAR 0 3
74098: PPUSH
74099: LD_INT 0
74101: PPUSH
74102: CALL_OW 109
// continue ;
74106: GO 73930
// end ; if IsInUnit ( j ) then
74108: LD_VAR 0 3
74112: PPUSH
74113: CALL_OW 310
74117: IFFALSE 74128
// ComExitBuilding ( j ) ;
74119: LD_VAR 0 3
74123: PPUSH
74124: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74128: LD_ADDR_VAR 0 6
74132: PUSH
74133: LD_VAR 0 7
74137: PPUSH
74138: LD_VAR 0 3
74142: PPUSH
74143: CALL_OW 74
74147: ST_TO_ADDR
// if not ape then
74148: LD_VAR 0 6
74152: NOT
74153: IFFALSE 74157
// break ;
74155: GO 74267
// x := GetX ( ape ) ;
74157: LD_ADDR_VAR 0 4
74161: PUSH
74162: LD_VAR 0 6
74166: PPUSH
74167: CALL_OW 250
74171: ST_TO_ADDR
// y := GetY ( ape ) ;
74172: LD_ADDR_VAR 0 5
74176: PUSH
74177: LD_VAR 0 6
74181: PPUSH
74182: CALL_OW 251
74186: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74187: LD_VAR 0 4
74191: PPUSH
74192: LD_VAR 0 5
74196: PPUSH
74197: CALL_OW 488
74201: NOT
74202: PUSH
74203: LD_VAR 0 11
74207: PPUSH
74208: LD_VAR 0 4
74212: PPUSH
74213: LD_VAR 0 5
74217: PPUSH
74218: LD_INT 20
74220: PPUSH
74221: CALL 21561 0 4
74225: PUSH
74226: LD_INT 4
74228: ARRAY
74229: OR
74230: IFFALSE 74234
// break ;
74232: GO 74267
// if not HasTask ( j ) then
74234: LD_VAR 0 3
74238: PPUSH
74239: CALL_OW 314
74243: NOT
74244: IFFALSE 74265
// ComTameXY ( j , x , y ) ;
74246: LD_VAR 0 3
74250: PPUSH
74251: LD_VAR 0 4
74255: PPUSH
74256: LD_VAR 0 5
74260: PPUSH
74261: CALL_OW 131
// end ; end ;
74265: GO 73930
74267: POP
74268: POP
// end ;
74269: GO 73486
74271: POP
74272: POP
// end ;
74273: LD_VAR 0 1
74277: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74278: LD_INT 0
74280: PPUSH
74281: PPUSH
74282: PPUSH
74283: PPUSH
74284: PPUSH
74285: PPUSH
74286: PPUSH
74287: PPUSH
// if not mc_bases then
74288: LD_EXP 58
74292: NOT
74293: IFFALSE 74297
// exit ;
74295: GO 74923
// for i = 1 to mc_bases do
74297: LD_ADDR_VAR 0 2
74301: PUSH
74302: DOUBLE
74303: LD_INT 1
74305: DEC
74306: ST_TO_ADDR
74307: LD_EXP 58
74311: PUSH
74312: FOR_TO
74313: IFFALSE 74921
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74315: LD_EXP 87
74319: PUSH
74320: LD_VAR 0 2
74324: ARRAY
74325: NOT
74326: PUSH
74327: LD_EXP 87
74331: PUSH
74332: LD_VAR 0 2
74336: ARRAY
74337: PPUSH
74338: LD_INT 25
74340: PUSH
74341: LD_INT 12
74343: PUSH
74344: EMPTY
74345: LIST
74346: LIST
74347: PPUSH
74348: CALL_OW 72
74352: NOT
74353: OR
74354: IFFALSE 74358
// continue ;
74356: GO 74312
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74358: LD_ADDR_VAR 0 5
74362: PUSH
74363: LD_EXP 87
74367: PUSH
74368: LD_VAR 0 2
74372: ARRAY
74373: PUSH
74374: LD_INT 1
74376: ARRAY
74377: PPUSH
74378: CALL_OW 255
74382: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74383: LD_VAR 0 5
74387: PPUSH
74388: LD_INT 2
74390: PPUSH
74391: CALL_OW 325
74395: IFFALSE 74648
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74397: LD_ADDR_VAR 0 4
74401: PUSH
74402: LD_EXP 87
74406: PUSH
74407: LD_VAR 0 2
74411: ARRAY
74412: PPUSH
74413: LD_INT 25
74415: PUSH
74416: LD_INT 16
74418: PUSH
74419: EMPTY
74420: LIST
74421: LIST
74422: PPUSH
74423: CALL_OW 72
74427: ST_TO_ADDR
// if tmp < 6 then
74428: LD_VAR 0 4
74432: PUSH
74433: LD_INT 6
74435: LESS
74436: IFFALSE 74648
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74438: LD_ADDR_VAR 0 6
74442: PUSH
74443: LD_EXP 58
74447: PUSH
74448: LD_VAR 0 2
74452: ARRAY
74453: PPUSH
74454: LD_INT 2
74456: PUSH
74457: LD_INT 30
74459: PUSH
74460: LD_INT 0
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 30
74469: PUSH
74470: LD_INT 1
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: EMPTY
74478: LIST
74479: LIST
74480: LIST
74481: PPUSH
74482: CALL_OW 72
74486: ST_TO_ADDR
// if depot then
74487: LD_VAR 0 6
74491: IFFALSE 74648
// begin selected := 0 ;
74493: LD_ADDR_VAR 0 7
74497: PUSH
74498: LD_INT 0
74500: ST_TO_ADDR
// for j in depot do
74501: LD_ADDR_VAR 0 3
74505: PUSH
74506: LD_VAR 0 6
74510: PUSH
74511: FOR_IN
74512: IFFALSE 74543
// begin if UnitsInside ( j ) < 6 then
74514: LD_VAR 0 3
74518: PPUSH
74519: CALL_OW 313
74523: PUSH
74524: LD_INT 6
74526: LESS
74527: IFFALSE 74541
// begin selected := j ;
74529: LD_ADDR_VAR 0 7
74533: PUSH
74534: LD_VAR 0 3
74538: ST_TO_ADDR
// break ;
74539: GO 74543
// end ; end ;
74541: GO 74511
74543: POP
74544: POP
// if selected then
74545: LD_VAR 0 7
74549: IFFALSE 74648
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74551: LD_ADDR_VAR 0 3
74555: PUSH
74556: LD_EXP 87
74560: PUSH
74561: LD_VAR 0 2
74565: ARRAY
74566: PPUSH
74567: LD_INT 25
74569: PUSH
74570: LD_INT 12
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PPUSH
74577: CALL_OW 72
74581: PUSH
74582: FOR_IN
74583: IFFALSE 74646
// if not HasTask ( j ) then
74585: LD_VAR 0 3
74589: PPUSH
74590: CALL_OW 314
74594: NOT
74595: IFFALSE 74644
// begin if not IsInUnit ( j ) then
74597: LD_VAR 0 3
74601: PPUSH
74602: CALL_OW 310
74606: NOT
74607: IFFALSE 74623
// ComEnterUnit ( j , selected ) ;
74609: LD_VAR 0 3
74613: PPUSH
74614: LD_VAR 0 7
74618: PPUSH
74619: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74623: LD_VAR 0 3
74627: PPUSH
74628: LD_INT 16
74630: PPUSH
74631: CALL_OW 183
// AddComExitBuilding ( j ) ;
74635: LD_VAR 0 3
74639: PPUSH
74640: CALL_OW 182
// end ;
74644: GO 74582
74646: POP
74647: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74648: LD_VAR 0 5
74652: PPUSH
74653: LD_INT 11
74655: PPUSH
74656: CALL_OW 325
74660: IFFALSE 74919
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74662: LD_ADDR_VAR 0 4
74666: PUSH
74667: LD_EXP 87
74671: PUSH
74672: LD_VAR 0 2
74676: ARRAY
74677: PPUSH
74678: LD_INT 25
74680: PUSH
74681: LD_INT 16
74683: PUSH
74684: EMPTY
74685: LIST
74686: LIST
74687: PPUSH
74688: CALL_OW 72
74692: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74693: LD_VAR 0 4
74697: PUSH
74698: LD_INT 6
74700: GREATEREQUAL
74701: PUSH
74702: LD_VAR 0 5
74706: PPUSH
74707: LD_INT 2
74709: PPUSH
74710: CALL_OW 325
74714: NOT
74715: OR
74716: IFFALSE 74919
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74718: LD_ADDR_VAR 0 8
74722: PUSH
74723: LD_EXP 58
74727: PUSH
74728: LD_VAR 0 2
74732: ARRAY
74733: PPUSH
74734: LD_INT 2
74736: PUSH
74737: LD_INT 30
74739: PUSH
74740: LD_INT 4
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 30
74749: PUSH
74750: LD_INT 5
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PUSH
74757: EMPTY
74758: LIST
74759: LIST
74760: LIST
74761: PPUSH
74762: CALL_OW 72
74766: ST_TO_ADDR
// if barracks then
74767: LD_VAR 0 8
74771: IFFALSE 74919
// begin selected := 0 ;
74773: LD_ADDR_VAR 0 7
74777: PUSH
74778: LD_INT 0
74780: ST_TO_ADDR
// for j in barracks do
74781: LD_ADDR_VAR 0 3
74785: PUSH
74786: LD_VAR 0 8
74790: PUSH
74791: FOR_IN
74792: IFFALSE 74823
// begin if UnitsInside ( j ) < 6 then
74794: LD_VAR 0 3
74798: PPUSH
74799: CALL_OW 313
74803: PUSH
74804: LD_INT 6
74806: LESS
74807: IFFALSE 74821
// begin selected := j ;
74809: LD_ADDR_VAR 0 7
74813: PUSH
74814: LD_VAR 0 3
74818: ST_TO_ADDR
// break ;
74819: GO 74823
// end ; end ;
74821: GO 74791
74823: POP
74824: POP
// if selected then
74825: LD_VAR 0 7
74829: IFFALSE 74919
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74831: LD_ADDR_VAR 0 3
74835: PUSH
74836: LD_EXP 87
74840: PUSH
74841: LD_VAR 0 2
74845: ARRAY
74846: PPUSH
74847: LD_INT 25
74849: PUSH
74850: LD_INT 12
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PPUSH
74857: CALL_OW 72
74861: PUSH
74862: FOR_IN
74863: IFFALSE 74917
// if not IsInUnit ( j ) and not HasTask ( j ) then
74865: LD_VAR 0 3
74869: PPUSH
74870: CALL_OW 310
74874: NOT
74875: PUSH
74876: LD_VAR 0 3
74880: PPUSH
74881: CALL_OW 314
74885: NOT
74886: AND
74887: IFFALSE 74915
// begin ComEnterUnit ( j , selected ) ;
74889: LD_VAR 0 3
74893: PPUSH
74894: LD_VAR 0 7
74898: PPUSH
74899: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74903: LD_VAR 0 3
74907: PPUSH
74908: LD_INT 15
74910: PPUSH
74911: CALL_OW 183
// end ;
74915: GO 74862
74917: POP
74918: POP
// end ; end ; end ; end ; end ;
74919: GO 74312
74921: POP
74922: POP
// end ;
74923: LD_VAR 0 1
74927: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74928: LD_INT 0
74930: PPUSH
74931: PPUSH
74932: PPUSH
74933: PPUSH
// if not mc_bases then
74934: LD_EXP 58
74938: NOT
74939: IFFALSE 74943
// exit ;
74941: GO 75121
// for i = 1 to mc_bases do
74943: LD_ADDR_VAR 0 2
74947: PUSH
74948: DOUBLE
74949: LD_INT 1
74951: DEC
74952: ST_TO_ADDR
74953: LD_EXP 58
74957: PUSH
74958: FOR_TO
74959: IFFALSE 75119
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74961: LD_ADDR_VAR 0 4
74965: PUSH
74966: LD_EXP 58
74970: PUSH
74971: LD_VAR 0 2
74975: ARRAY
74976: PPUSH
74977: LD_INT 25
74979: PUSH
74980: LD_INT 9
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PPUSH
74987: CALL_OW 72
74991: ST_TO_ADDR
// if not tmp then
74992: LD_VAR 0 4
74996: NOT
74997: IFFALSE 75001
// continue ;
74999: GO 74958
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75001: LD_EXP 84
75005: PUSH
75006: LD_VAR 0 2
75010: ARRAY
75011: PPUSH
75012: LD_INT 29
75014: PPUSH
75015: CALL_OW 325
75019: NOT
75020: PUSH
75021: LD_EXP 84
75025: PUSH
75026: LD_VAR 0 2
75030: ARRAY
75031: PPUSH
75032: LD_INT 28
75034: PPUSH
75035: CALL_OW 325
75039: NOT
75040: AND
75041: IFFALSE 75045
// continue ;
75043: GO 74958
// for j in tmp do
75045: LD_ADDR_VAR 0 3
75049: PUSH
75050: LD_VAR 0 4
75054: PUSH
75055: FOR_IN
75056: IFFALSE 75115
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75058: LD_VAR 0 3
75062: PUSH
75063: LD_EXP 61
75067: PUSH
75068: LD_VAR 0 2
75072: ARRAY
75073: PUSH
75074: LD_INT 1
75076: ARRAY
75077: IN
75078: NOT
75079: PUSH
75080: LD_VAR 0 3
75084: PUSH
75085: LD_EXP 61
75089: PUSH
75090: LD_VAR 0 2
75094: ARRAY
75095: PUSH
75096: LD_INT 2
75098: ARRAY
75099: IN
75100: NOT
75101: AND
75102: IFFALSE 75113
// ComSpaceTimeShoot ( j ) ;
75104: LD_VAR 0 3
75108: PPUSH
75109: CALL 14725 0 1
75113: GO 75055
75115: POP
75116: POP
// end ;
75117: GO 74958
75119: POP
75120: POP
// end ;
75121: LD_VAR 0 1
75125: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75126: LD_INT 0
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
75136: PPUSH
// if not mc_bases then
75137: LD_EXP 58
75141: NOT
75142: IFFALSE 75146
// exit ;
75144: GO 75768
// for i = 1 to mc_bases do
75146: LD_ADDR_VAR 0 2
75150: PUSH
75151: DOUBLE
75152: LD_INT 1
75154: DEC
75155: ST_TO_ADDR
75156: LD_EXP 58
75160: PUSH
75161: FOR_TO
75162: IFFALSE 75766
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75164: LD_EXP 93
75168: PUSH
75169: LD_VAR 0 2
75173: ARRAY
75174: NOT
75175: PUSH
75176: LD_INT 38
75178: PPUSH
75179: LD_EXP 84
75183: PUSH
75184: LD_VAR 0 2
75188: ARRAY
75189: PPUSH
75190: CALL_OW 321
75194: PUSH
75195: LD_INT 2
75197: NONEQUAL
75198: OR
75199: IFFALSE 75203
// continue ;
75201: GO 75161
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75203: LD_ADDR_VAR 0 8
75207: PUSH
75208: LD_EXP 58
75212: PUSH
75213: LD_VAR 0 2
75217: ARRAY
75218: PPUSH
75219: LD_INT 30
75221: PUSH
75222: LD_INT 34
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PPUSH
75229: CALL_OW 72
75233: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75234: LD_ADDR_VAR 0 9
75238: PUSH
75239: LD_EXP 58
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PPUSH
75250: LD_INT 25
75252: PUSH
75253: LD_INT 4
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PPUSH
75260: CALL_OW 72
75264: PPUSH
75265: LD_INT 0
75267: PPUSH
75268: CALL 53862 0 2
75272: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75273: LD_VAR 0 9
75277: NOT
75278: PUSH
75279: LD_VAR 0 8
75283: NOT
75284: OR
75285: PUSH
75286: LD_EXP 58
75290: PUSH
75291: LD_VAR 0 2
75295: ARRAY
75296: PPUSH
75297: LD_INT 124
75299: PPUSH
75300: CALL 53862 0 2
75304: OR
75305: IFFALSE 75309
// continue ;
75307: GO 75161
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75309: LD_EXP 94
75313: PUSH
75314: LD_VAR 0 2
75318: ARRAY
75319: PUSH
75320: LD_EXP 93
75324: PUSH
75325: LD_VAR 0 2
75329: ARRAY
75330: LESS
75331: PUSH
75332: LD_EXP 94
75336: PUSH
75337: LD_VAR 0 2
75341: ARRAY
75342: PUSH
75343: LD_VAR 0 8
75347: LESS
75348: AND
75349: IFFALSE 75764
// begin tmp := sci [ 1 ] ;
75351: LD_ADDR_VAR 0 7
75355: PUSH
75356: LD_VAR 0 9
75360: PUSH
75361: LD_INT 1
75363: ARRAY
75364: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75365: LD_VAR 0 7
75369: PPUSH
75370: LD_INT 124
75372: PPUSH
75373: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75377: LD_ADDR_VAR 0 3
75381: PUSH
75382: DOUBLE
75383: LD_EXP 93
75387: PUSH
75388: LD_VAR 0 2
75392: ARRAY
75393: INC
75394: ST_TO_ADDR
75395: LD_EXP 93
75399: PUSH
75400: LD_VAR 0 2
75404: ARRAY
75405: PUSH
75406: FOR_DOWNTO
75407: IFFALSE 75750
// begin if IsInUnit ( tmp ) then
75409: LD_VAR 0 7
75413: PPUSH
75414: CALL_OW 310
75418: IFFALSE 75429
// ComExitBuilding ( tmp ) ;
75420: LD_VAR 0 7
75424: PPUSH
75425: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75429: LD_INT 35
75431: PPUSH
75432: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75436: LD_VAR 0 7
75440: PPUSH
75441: CALL_OW 310
75445: NOT
75446: PUSH
75447: LD_VAR 0 7
75451: PPUSH
75452: CALL_OW 314
75456: NOT
75457: AND
75458: IFFALSE 75429
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75460: LD_ADDR_VAR 0 6
75464: PUSH
75465: LD_VAR 0 7
75469: PPUSH
75470: CALL_OW 250
75474: PUSH
75475: LD_VAR 0 7
75479: PPUSH
75480: CALL_OW 251
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75489: LD_INT 35
75491: PPUSH
75492: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75496: LD_ADDR_VAR 0 4
75500: PUSH
75501: LD_EXP 93
75505: PUSH
75506: LD_VAR 0 2
75510: ARRAY
75511: PUSH
75512: LD_VAR 0 3
75516: ARRAY
75517: PUSH
75518: LD_INT 1
75520: ARRAY
75521: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75522: LD_ADDR_VAR 0 5
75526: PUSH
75527: LD_EXP 93
75531: PUSH
75532: LD_VAR 0 2
75536: ARRAY
75537: PUSH
75538: LD_VAR 0 3
75542: ARRAY
75543: PUSH
75544: LD_INT 2
75546: ARRAY
75547: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75548: LD_VAR 0 7
75552: PPUSH
75553: LD_INT 10
75555: PPUSH
75556: CALL 23258 0 2
75560: PUSH
75561: LD_INT 4
75563: ARRAY
75564: IFFALSE 75602
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75566: LD_VAR 0 7
75570: PPUSH
75571: LD_VAR 0 6
75575: PUSH
75576: LD_INT 1
75578: ARRAY
75579: PPUSH
75580: LD_VAR 0 6
75584: PUSH
75585: LD_INT 2
75587: ARRAY
75588: PPUSH
75589: CALL_OW 111
// wait ( 0 0$10 ) ;
75593: LD_INT 350
75595: PPUSH
75596: CALL_OW 67
// end else
75600: GO 75628
// begin ComMoveXY ( tmp , x , y ) ;
75602: LD_VAR 0 7
75606: PPUSH
75607: LD_VAR 0 4
75611: PPUSH
75612: LD_VAR 0 5
75616: PPUSH
75617: CALL_OW 111
// wait ( 0 0$3 ) ;
75621: LD_INT 105
75623: PPUSH
75624: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75628: LD_VAR 0 7
75632: PPUSH
75633: LD_VAR 0 4
75637: PPUSH
75638: LD_VAR 0 5
75642: PPUSH
75643: CALL_OW 307
75647: IFFALSE 75489
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75649: LD_VAR 0 7
75653: PPUSH
75654: LD_VAR 0 4
75658: PPUSH
75659: LD_VAR 0 5
75663: PPUSH
75664: LD_VAR 0 8
75668: PUSH
75669: LD_VAR 0 3
75673: ARRAY
75674: PPUSH
75675: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75679: LD_INT 35
75681: PPUSH
75682: CALL_OW 67
// until not HasTask ( tmp ) ;
75686: LD_VAR 0 7
75690: PPUSH
75691: CALL_OW 314
75695: NOT
75696: IFFALSE 75679
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75698: LD_ADDR_EXP 94
75702: PUSH
75703: LD_EXP 94
75707: PPUSH
75708: LD_VAR 0 2
75712: PUSH
75713: LD_EXP 94
75717: PUSH
75718: LD_VAR 0 2
75722: ARRAY
75723: PUSH
75724: LD_INT 1
75726: PLUS
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: PPUSH
75732: LD_VAR 0 8
75736: PUSH
75737: LD_VAR 0 3
75741: ARRAY
75742: PPUSH
75743: CALL 20665 0 3
75747: ST_TO_ADDR
// end ;
75748: GO 75406
75750: POP
75751: POP
// MC_Reset ( i , 124 ) ;
75752: LD_VAR 0 2
75756: PPUSH
75757: LD_INT 124
75759: PPUSH
75760: CALL 59555 0 2
// end ; end ;
75764: GO 75161
75766: POP
75767: POP
// end ;
75768: LD_VAR 0 1
75772: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75773: LD_INT 0
75775: PPUSH
75776: PPUSH
75777: PPUSH
// if not mc_bases then
75778: LD_EXP 58
75782: NOT
75783: IFFALSE 75787
// exit ;
75785: GO 76393
// for i = 1 to mc_bases do
75787: LD_ADDR_VAR 0 2
75791: PUSH
75792: DOUBLE
75793: LD_INT 1
75795: DEC
75796: ST_TO_ADDR
75797: LD_EXP 58
75801: PUSH
75802: FOR_TO
75803: IFFALSE 76391
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75805: LD_ADDR_VAR 0 3
75809: PUSH
75810: LD_EXP 58
75814: PUSH
75815: LD_VAR 0 2
75819: ARRAY
75820: PPUSH
75821: LD_INT 25
75823: PUSH
75824: LD_INT 4
75826: PUSH
75827: EMPTY
75828: LIST
75829: LIST
75830: PPUSH
75831: CALL_OW 72
75835: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75836: LD_VAR 0 3
75840: NOT
75841: PUSH
75842: LD_EXP 95
75846: PUSH
75847: LD_VAR 0 2
75851: ARRAY
75852: NOT
75853: OR
75854: PUSH
75855: LD_EXP 58
75859: PUSH
75860: LD_VAR 0 2
75864: ARRAY
75865: PPUSH
75866: LD_INT 2
75868: PUSH
75869: LD_INT 30
75871: PUSH
75872: LD_INT 0
75874: PUSH
75875: EMPTY
75876: LIST
75877: LIST
75878: PUSH
75879: LD_INT 30
75881: PUSH
75882: LD_INT 1
75884: PUSH
75885: EMPTY
75886: LIST
75887: LIST
75888: PUSH
75889: EMPTY
75890: LIST
75891: LIST
75892: LIST
75893: PPUSH
75894: CALL_OW 72
75898: NOT
75899: OR
75900: IFFALSE 75950
// begin if mc_deposits_finder [ i ] then
75902: LD_EXP 96
75906: PUSH
75907: LD_VAR 0 2
75911: ARRAY
75912: IFFALSE 75948
// begin MC_Reset ( i , 125 ) ;
75914: LD_VAR 0 2
75918: PPUSH
75919: LD_INT 125
75921: PPUSH
75922: CALL 59555 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75926: LD_ADDR_EXP 96
75930: PUSH
75931: LD_EXP 96
75935: PPUSH
75936: LD_VAR 0 2
75940: PPUSH
75941: EMPTY
75942: PPUSH
75943: CALL_OW 1
75947: ST_TO_ADDR
// end ; continue ;
75948: GO 75802
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75950: LD_EXP 95
75954: PUSH
75955: LD_VAR 0 2
75959: ARRAY
75960: PUSH
75961: LD_INT 1
75963: ARRAY
75964: PUSH
75965: LD_INT 3
75967: ARRAY
75968: PUSH
75969: LD_INT 1
75971: EQUAL
75972: PUSH
75973: LD_INT 20
75975: PPUSH
75976: LD_EXP 84
75980: PUSH
75981: LD_VAR 0 2
75985: ARRAY
75986: PPUSH
75987: CALL_OW 321
75991: PUSH
75992: LD_INT 2
75994: NONEQUAL
75995: AND
75996: IFFALSE 76046
// begin if mc_deposits_finder [ i ] then
75998: LD_EXP 96
76002: PUSH
76003: LD_VAR 0 2
76007: ARRAY
76008: IFFALSE 76044
// begin MC_Reset ( i , 125 ) ;
76010: LD_VAR 0 2
76014: PPUSH
76015: LD_INT 125
76017: PPUSH
76018: CALL 59555 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76022: LD_ADDR_EXP 96
76026: PUSH
76027: LD_EXP 96
76031: PPUSH
76032: LD_VAR 0 2
76036: PPUSH
76037: EMPTY
76038: PPUSH
76039: CALL_OW 1
76043: ST_TO_ADDR
// end ; continue ;
76044: GO 75802
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76046: LD_EXP 95
76050: PUSH
76051: LD_VAR 0 2
76055: ARRAY
76056: PUSH
76057: LD_INT 1
76059: ARRAY
76060: PUSH
76061: LD_INT 1
76063: ARRAY
76064: PPUSH
76065: LD_EXP 95
76069: PUSH
76070: LD_VAR 0 2
76074: ARRAY
76075: PUSH
76076: LD_INT 1
76078: ARRAY
76079: PUSH
76080: LD_INT 2
76082: ARRAY
76083: PPUSH
76084: LD_EXP 84
76088: PUSH
76089: LD_VAR 0 2
76093: ARRAY
76094: PPUSH
76095: CALL_OW 440
76099: IFFALSE 76142
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76101: LD_ADDR_EXP 95
76105: PUSH
76106: LD_EXP 95
76110: PPUSH
76111: LD_VAR 0 2
76115: PPUSH
76116: LD_EXP 95
76120: PUSH
76121: LD_VAR 0 2
76125: ARRAY
76126: PPUSH
76127: LD_INT 1
76129: PPUSH
76130: CALL_OW 3
76134: PPUSH
76135: CALL_OW 1
76139: ST_TO_ADDR
76140: GO 76389
// begin if not mc_deposits_finder [ i ] then
76142: LD_EXP 96
76146: PUSH
76147: LD_VAR 0 2
76151: ARRAY
76152: NOT
76153: IFFALSE 76205
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76155: LD_ADDR_EXP 96
76159: PUSH
76160: LD_EXP 96
76164: PPUSH
76165: LD_VAR 0 2
76169: PPUSH
76170: LD_VAR 0 3
76174: PUSH
76175: LD_INT 1
76177: ARRAY
76178: PUSH
76179: EMPTY
76180: LIST
76181: PPUSH
76182: CALL_OW 1
76186: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76187: LD_VAR 0 3
76191: PUSH
76192: LD_INT 1
76194: ARRAY
76195: PPUSH
76196: LD_INT 125
76198: PPUSH
76199: CALL_OW 109
// end else
76203: GO 76389
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76205: LD_EXP 96
76209: PUSH
76210: LD_VAR 0 2
76214: ARRAY
76215: PUSH
76216: LD_INT 1
76218: ARRAY
76219: PPUSH
76220: CALL_OW 310
76224: IFFALSE 76247
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76226: LD_EXP 96
76230: PUSH
76231: LD_VAR 0 2
76235: ARRAY
76236: PUSH
76237: LD_INT 1
76239: ARRAY
76240: PPUSH
76241: CALL_OW 122
76245: GO 76389
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76247: LD_EXP 96
76251: PUSH
76252: LD_VAR 0 2
76256: ARRAY
76257: PUSH
76258: LD_INT 1
76260: ARRAY
76261: PPUSH
76262: CALL_OW 314
76266: NOT
76267: PUSH
76268: LD_EXP 96
76272: PUSH
76273: LD_VAR 0 2
76277: ARRAY
76278: PUSH
76279: LD_INT 1
76281: ARRAY
76282: PPUSH
76283: LD_EXP 95
76287: PUSH
76288: LD_VAR 0 2
76292: ARRAY
76293: PUSH
76294: LD_INT 1
76296: ARRAY
76297: PUSH
76298: LD_INT 1
76300: ARRAY
76301: PPUSH
76302: LD_EXP 95
76306: PUSH
76307: LD_VAR 0 2
76311: ARRAY
76312: PUSH
76313: LD_INT 1
76315: ARRAY
76316: PUSH
76317: LD_INT 2
76319: ARRAY
76320: PPUSH
76321: CALL_OW 297
76325: PUSH
76326: LD_INT 6
76328: GREATER
76329: AND
76330: IFFALSE 76389
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76332: LD_EXP 96
76336: PUSH
76337: LD_VAR 0 2
76341: ARRAY
76342: PUSH
76343: LD_INT 1
76345: ARRAY
76346: PPUSH
76347: LD_EXP 95
76351: PUSH
76352: LD_VAR 0 2
76356: ARRAY
76357: PUSH
76358: LD_INT 1
76360: ARRAY
76361: PUSH
76362: LD_INT 1
76364: ARRAY
76365: PPUSH
76366: LD_EXP 95
76370: PUSH
76371: LD_VAR 0 2
76375: ARRAY
76376: PUSH
76377: LD_INT 1
76379: ARRAY
76380: PUSH
76381: LD_INT 2
76383: ARRAY
76384: PPUSH
76385: CALL_OW 111
// end ; end ; end ;
76389: GO 75802
76391: POP
76392: POP
// end ;
76393: LD_VAR 0 1
76397: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76398: LD_INT 0
76400: PPUSH
76401: PPUSH
76402: PPUSH
76403: PPUSH
76404: PPUSH
76405: PPUSH
76406: PPUSH
76407: PPUSH
76408: PPUSH
76409: PPUSH
76410: PPUSH
// if not mc_bases then
76411: LD_EXP 58
76415: NOT
76416: IFFALSE 76420
// exit ;
76418: GO 77144
// for i = 1 to mc_bases do
76420: LD_ADDR_VAR 0 2
76424: PUSH
76425: DOUBLE
76426: LD_INT 1
76428: DEC
76429: ST_TO_ADDR
76430: LD_EXP 58
76434: PUSH
76435: FOR_TO
76436: IFFALSE 77142
// begin if not mc_bases [ i ] then
76438: LD_EXP 58
76442: PUSH
76443: LD_VAR 0 2
76447: ARRAY
76448: NOT
76449: IFFALSE 76453
// continue ;
76451: GO 76435
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76453: LD_ADDR_VAR 0 7
76457: PUSH
76458: LD_EXP 58
76462: PUSH
76463: LD_VAR 0 2
76467: ARRAY
76468: PUSH
76469: LD_INT 1
76471: ARRAY
76472: PPUSH
76473: CALL_OW 248
76477: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76478: LD_VAR 0 7
76482: PUSH
76483: LD_INT 3
76485: EQUAL
76486: PUSH
76487: LD_EXP 77
76491: PUSH
76492: LD_VAR 0 2
76496: ARRAY
76497: PUSH
76498: LD_EXP 80
76502: PUSH
76503: LD_VAR 0 2
76507: ARRAY
76508: UNION
76509: PPUSH
76510: LD_INT 33
76512: PUSH
76513: LD_INT 2
76515: PUSH
76516: EMPTY
76517: LIST
76518: LIST
76519: PPUSH
76520: CALL_OW 72
76524: NOT
76525: OR
76526: IFFALSE 76530
// continue ;
76528: GO 76435
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76530: LD_ADDR_VAR 0 9
76534: PUSH
76535: LD_EXP 58
76539: PUSH
76540: LD_VAR 0 2
76544: ARRAY
76545: PPUSH
76546: LD_INT 30
76548: PUSH
76549: LD_INT 36
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: PPUSH
76556: CALL_OW 72
76560: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76561: LD_ADDR_VAR 0 10
76565: PUSH
76566: LD_EXP 77
76570: PUSH
76571: LD_VAR 0 2
76575: ARRAY
76576: PPUSH
76577: LD_INT 34
76579: PUSH
76580: LD_INT 31
76582: PUSH
76583: EMPTY
76584: LIST
76585: LIST
76586: PPUSH
76587: CALL_OW 72
76591: ST_TO_ADDR
// if not cts and not mcts then
76592: LD_VAR 0 9
76596: NOT
76597: PUSH
76598: LD_VAR 0 10
76602: NOT
76603: AND
76604: IFFALSE 76608
// continue ;
76606: GO 76435
// x := cts ;
76608: LD_ADDR_VAR 0 11
76612: PUSH
76613: LD_VAR 0 9
76617: ST_TO_ADDR
// if not x then
76618: LD_VAR 0 11
76622: NOT
76623: IFFALSE 76635
// x := mcts ;
76625: LD_ADDR_VAR 0 11
76629: PUSH
76630: LD_VAR 0 10
76634: ST_TO_ADDR
// if mc_remote_driver [ i ] then
76635: LD_EXP 98
76639: PUSH
76640: LD_VAR 0 2
76644: ARRAY
76645: IFFALSE 76914
// for j in mc_remote_driver [ i ] do
76647: LD_ADDR_VAR 0 3
76651: PUSH
76652: LD_EXP 98
76656: PUSH
76657: LD_VAR 0 2
76661: ARRAY
76662: PUSH
76663: FOR_IN
76664: IFFALSE 76912
// begin if GetClass ( j ) <> 3 then
76666: LD_VAR 0 3
76670: PPUSH
76671: CALL_OW 257
76675: PUSH
76676: LD_INT 3
76678: NONEQUAL
76679: IFFALSE 76732
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76681: LD_ADDR_EXP 98
76685: PUSH
76686: LD_EXP 98
76690: PPUSH
76691: LD_VAR 0 2
76695: PPUSH
76696: LD_EXP 98
76700: PUSH
76701: LD_VAR 0 2
76705: ARRAY
76706: PUSH
76707: LD_VAR 0 3
76711: DIFF
76712: PPUSH
76713: CALL_OW 1
76717: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76718: LD_VAR 0 3
76722: PPUSH
76723: LD_INT 0
76725: PPUSH
76726: CALL_OW 109
// continue ;
76730: GO 76663
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76732: LD_VAR 0 3
76736: PPUSH
76737: CALL_OW 310
76741: NOT
76742: PUSH
76743: LD_VAR 0 3
76747: PPUSH
76748: CALL_OW 310
76752: PPUSH
76753: CALL_OW 266
76757: PUSH
76758: LD_INT 36
76760: NONEQUAL
76761: PUSH
76762: LD_VAR 0 3
76766: PPUSH
76767: CALL 53950 0 1
76771: NOT
76772: AND
76773: OR
76774: IFFALSE 76910
// begin if IsInUnit ( j ) then
76776: LD_VAR 0 3
76780: PPUSH
76781: CALL_OW 310
76785: IFFALSE 76796
// ComExitBuilding ( j ) ;
76787: LD_VAR 0 3
76791: PPUSH
76792: CALL_OW 122
// ct := 0 ;
76796: LD_ADDR_VAR 0 8
76800: PUSH
76801: LD_INT 0
76803: ST_TO_ADDR
// for k in x do
76804: LD_ADDR_VAR 0 4
76808: PUSH
76809: LD_VAR 0 11
76813: PUSH
76814: FOR_IN
76815: IFFALSE 76888
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76817: LD_VAR 0 4
76821: PPUSH
76822: CALL_OW 264
76826: PUSH
76827: LD_INT 31
76829: EQUAL
76830: PUSH
76831: LD_VAR 0 4
76835: PPUSH
76836: CALL_OW 311
76840: NOT
76841: AND
76842: PUSH
76843: LD_VAR 0 4
76847: PPUSH
76848: CALL_OW 266
76852: PUSH
76853: LD_INT 36
76855: EQUAL
76856: PUSH
76857: LD_VAR 0 4
76861: PPUSH
76862: CALL_OW 313
76866: PUSH
76867: LD_INT 3
76869: LESS
76870: AND
76871: OR
76872: IFFALSE 76886
// begin ct := k ;
76874: LD_ADDR_VAR 0 8
76878: PUSH
76879: LD_VAR 0 4
76883: ST_TO_ADDR
// break ;
76884: GO 76888
// end ;
76886: GO 76814
76888: POP
76889: POP
// if ct then
76890: LD_VAR 0 8
76894: IFFALSE 76910
// ComEnterUnit ( j , ct ) ;
76896: LD_VAR 0 3
76900: PPUSH
76901: LD_VAR 0 8
76905: PPUSH
76906: CALL_OW 120
// end ; end ;
76910: GO 76663
76912: POP
76913: POP
// places := 0 ;
76914: LD_ADDR_VAR 0 5
76918: PUSH
76919: LD_INT 0
76921: ST_TO_ADDR
// for j = 1 to x do
76922: LD_ADDR_VAR 0 3
76926: PUSH
76927: DOUBLE
76928: LD_INT 1
76930: DEC
76931: ST_TO_ADDR
76932: LD_VAR 0 11
76936: PUSH
76937: FOR_TO
76938: IFFALSE 76993
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76940: LD_VAR 0 11
76944: PUSH
76945: LD_VAR 0 3
76949: ARRAY
76950: PPUSH
76951: CALL_OW 264
76955: PUSH
76956: LD_INT 31
76958: EQUAL
76959: IFFALSE 76977
// places := places + 1 else
76961: LD_ADDR_VAR 0 5
76965: PUSH
76966: LD_VAR 0 5
76970: PUSH
76971: LD_INT 1
76973: PLUS
76974: ST_TO_ADDR
76975: GO 76991
// places := places + 3 ;
76977: LD_ADDR_VAR 0 5
76981: PUSH
76982: LD_VAR 0 5
76986: PUSH
76987: LD_INT 3
76989: PLUS
76990: ST_TO_ADDR
76991: GO 76937
76993: POP
76994: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76995: LD_ADDR_VAR 0 6
76999: PUSH
77000: LD_EXP 58
77004: PUSH
77005: LD_VAR 0 2
77009: ARRAY
77010: PPUSH
77011: LD_INT 25
77013: PUSH
77014: LD_INT 3
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PPUSH
77021: CALL_OW 72
77025: PUSH
77026: LD_EXP 98
77030: PUSH
77031: LD_VAR 0 2
77035: ARRAY
77036: DIFF
77037: PPUSH
77038: LD_INT 3
77040: PPUSH
77041: CALL 54850 0 2
77045: ST_TO_ADDR
// if not tmp then
77046: LD_VAR 0 6
77050: NOT
77051: IFFALSE 77055
// continue ;
77053: GO 76435
// places := places - mc_remote_driver [ i ] ;
77055: LD_ADDR_VAR 0 5
77059: PUSH
77060: LD_VAR 0 5
77064: PUSH
77065: LD_EXP 98
77069: PUSH
77070: LD_VAR 0 2
77074: ARRAY
77075: MINUS
77076: ST_TO_ADDR
// if places then
77077: LD_VAR 0 5
77081: IFFALSE 77140
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77083: LD_ADDR_EXP 98
77087: PUSH
77088: LD_EXP 98
77092: PPUSH
77093: LD_VAR 0 2
77097: PPUSH
77098: LD_EXP 98
77102: PUSH
77103: LD_VAR 0 2
77107: ARRAY
77108: PUSH
77109: LD_VAR 0 6
77113: PUSH
77114: LD_INT 1
77116: ARRAY
77117: UNION
77118: PPUSH
77119: CALL_OW 1
77123: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77124: LD_VAR 0 6
77128: PUSH
77129: LD_INT 1
77131: ARRAY
77132: PPUSH
77133: LD_INT 126
77135: PPUSH
77136: CALL_OW 109
// end ; end ;
77140: GO 76435
77142: POP
77143: POP
// end ;
77144: LD_VAR 0 1
77148: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77149: LD_INT 0
77151: PPUSH
77152: PPUSH
77153: PPUSH
77154: PPUSH
77155: PPUSH
77156: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77157: LD_VAR 0 1
77161: NOT
77162: PUSH
77163: LD_VAR 0 2
77167: NOT
77168: OR
77169: PUSH
77170: LD_VAR 0 3
77174: NOT
77175: OR
77176: PUSH
77177: LD_VAR 0 4
77181: PUSH
77182: LD_INT 1
77184: PUSH
77185: LD_INT 2
77187: PUSH
77188: LD_INT 3
77190: PUSH
77191: LD_INT 4
77193: PUSH
77194: LD_INT 5
77196: PUSH
77197: LD_INT 8
77199: PUSH
77200: LD_INT 9
77202: PUSH
77203: LD_INT 15
77205: PUSH
77206: LD_INT 16
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: IN
77220: NOT
77221: OR
77222: IFFALSE 77226
// exit ;
77224: GO 78126
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77226: LD_ADDR_VAR 0 2
77230: PUSH
77231: LD_VAR 0 2
77235: PPUSH
77236: LD_INT 21
77238: PUSH
77239: LD_INT 3
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 24
77248: PUSH
77249: LD_INT 250
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PPUSH
77260: CALL_OW 72
77264: ST_TO_ADDR
// case class of 1 , 15 :
77265: LD_VAR 0 4
77269: PUSH
77270: LD_INT 1
77272: DOUBLE
77273: EQUAL
77274: IFTRUE 77284
77276: LD_INT 15
77278: DOUBLE
77279: EQUAL
77280: IFTRUE 77284
77282: GO 77369
77284: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77285: LD_ADDR_VAR 0 8
77289: PUSH
77290: LD_VAR 0 2
77294: PPUSH
77295: LD_INT 2
77297: PUSH
77298: LD_INT 30
77300: PUSH
77301: LD_INT 32
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 30
77310: PUSH
77311: LD_INT 31
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: LIST
77322: PPUSH
77323: CALL_OW 72
77327: PUSH
77328: LD_VAR 0 2
77332: PPUSH
77333: LD_INT 2
77335: PUSH
77336: LD_INT 30
77338: PUSH
77339: LD_INT 4
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 30
77348: PUSH
77349: LD_INT 5
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: LIST
77360: PPUSH
77361: CALL_OW 72
77365: ADD
77366: ST_TO_ADDR
77367: GO 77615
77369: LD_INT 2
77371: DOUBLE
77372: EQUAL
77373: IFTRUE 77383
77375: LD_INT 16
77377: DOUBLE
77378: EQUAL
77379: IFTRUE 77383
77381: GO 77429
77383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77384: LD_ADDR_VAR 0 8
77388: PUSH
77389: LD_VAR 0 2
77393: PPUSH
77394: LD_INT 2
77396: PUSH
77397: LD_INT 30
77399: PUSH
77400: LD_INT 0
77402: PUSH
77403: EMPTY
77404: LIST
77405: LIST
77406: PUSH
77407: LD_INT 30
77409: PUSH
77410: LD_INT 1
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: EMPTY
77418: LIST
77419: LIST
77420: LIST
77421: PPUSH
77422: CALL_OW 72
77426: ST_TO_ADDR
77427: GO 77615
77429: LD_INT 3
77431: DOUBLE
77432: EQUAL
77433: IFTRUE 77437
77435: GO 77483
77437: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77438: LD_ADDR_VAR 0 8
77442: PUSH
77443: LD_VAR 0 2
77447: PPUSH
77448: LD_INT 2
77450: PUSH
77451: LD_INT 30
77453: PUSH
77454: LD_INT 2
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 30
77463: PUSH
77464: LD_INT 3
77466: PUSH
77467: EMPTY
77468: LIST
77469: LIST
77470: PUSH
77471: EMPTY
77472: LIST
77473: LIST
77474: LIST
77475: PPUSH
77476: CALL_OW 72
77480: ST_TO_ADDR
77481: GO 77615
77483: LD_INT 4
77485: DOUBLE
77486: EQUAL
77487: IFTRUE 77491
77489: GO 77548
77491: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77492: LD_ADDR_VAR 0 8
77496: PUSH
77497: LD_VAR 0 2
77501: PPUSH
77502: LD_INT 2
77504: PUSH
77505: LD_INT 30
77507: PUSH
77508: LD_INT 6
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 30
77517: PUSH
77518: LD_INT 7
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 30
77527: PUSH
77528: LD_INT 8
77530: PUSH
77531: EMPTY
77532: LIST
77533: LIST
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: LIST
77539: LIST
77540: PPUSH
77541: CALL_OW 72
77545: ST_TO_ADDR
77546: GO 77615
77548: LD_INT 5
77550: DOUBLE
77551: EQUAL
77552: IFTRUE 77568
77554: LD_INT 8
77556: DOUBLE
77557: EQUAL
77558: IFTRUE 77568
77560: LD_INT 9
77562: DOUBLE
77563: EQUAL
77564: IFTRUE 77568
77566: GO 77614
77568: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77569: LD_ADDR_VAR 0 8
77573: PUSH
77574: LD_VAR 0 2
77578: PPUSH
77579: LD_INT 2
77581: PUSH
77582: LD_INT 30
77584: PUSH
77585: LD_INT 4
77587: PUSH
77588: EMPTY
77589: LIST
77590: LIST
77591: PUSH
77592: LD_INT 30
77594: PUSH
77595: LD_INT 5
77597: PUSH
77598: EMPTY
77599: LIST
77600: LIST
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: LIST
77606: PPUSH
77607: CALL_OW 72
77611: ST_TO_ADDR
77612: GO 77615
77614: POP
// if not tmp then
77615: LD_VAR 0 8
77619: NOT
77620: IFFALSE 77624
// exit ;
77622: GO 78126
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77624: LD_VAR 0 4
77628: PUSH
77629: LD_INT 1
77631: PUSH
77632: LD_INT 15
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: IN
77639: PUSH
77640: LD_EXP 67
77644: PUSH
77645: LD_VAR 0 1
77649: ARRAY
77650: AND
77651: IFFALSE 77807
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77653: LD_ADDR_VAR 0 9
77657: PUSH
77658: LD_EXP 67
77662: PUSH
77663: LD_VAR 0 1
77667: ARRAY
77668: PUSH
77669: LD_INT 1
77671: ARRAY
77672: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77673: LD_VAR 0 9
77677: PUSH
77678: LD_EXP 68
77682: PUSH
77683: LD_VAR 0 1
77687: ARRAY
77688: IN
77689: NOT
77690: IFFALSE 77805
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77692: LD_ADDR_EXP 68
77696: PUSH
77697: LD_EXP 68
77701: PPUSH
77702: LD_VAR 0 1
77706: PUSH
77707: LD_EXP 68
77711: PUSH
77712: LD_VAR 0 1
77716: ARRAY
77717: PUSH
77718: LD_INT 1
77720: PLUS
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PPUSH
77726: LD_VAR 0 9
77730: PPUSH
77731: CALL 20665 0 3
77735: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77736: LD_ADDR_EXP 67
77740: PUSH
77741: LD_EXP 67
77745: PPUSH
77746: LD_VAR 0 1
77750: PPUSH
77751: LD_EXP 67
77755: PUSH
77756: LD_VAR 0 1
77760: ARRAY
77761: PUSH
77762: LD_VAR 0 9
77766: DIFF
77767: PPUSH
77768: CALL_OW 1
77772: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77773: LD_VAR 0 3
77777: PPUSH
77778: LD_EXP 68
77782: PUSH
77783: LD_VAR 0 1
77787: ARRAY
77788: PUSH
77789: LD_EXP 68
77793: PUSH
77794: LD_VAR 0 1
77798: ARRAY
77799: ARRAY
77800: PPUSH
77801: CALL_OW 120
// end ; exit ;
77805: GO 78126
// end ; if tmp > 1 then
77807: LD_VAR 0 8
77811: PUSH
77812: LD_INT 1
77814: GREATER
77815: IFFALSE 77919
// for i = 2 to tmp do
77817: LD_ADDR_VAR 0 6
77821: PUSH
77822: DOUBLE
77823: LD_INT 2
77825: DEC
77826: ST_TO_ADDR
77827: LD_VAR 0 8
77831: PUSH
77832: FOR_TO
77833: IFFALSE 77917
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77835: LD_VAR 0 8
77839: PUSH
77840: LD_VAR 0 6
77844: ARRAY
77845: PPUSH
77846: CALL_OW 461
77850: PUSH
77851: LD_INT 6
77853: EQUAL
77854: IFFALSE 77915
// begin x := tmp [ i ] ;
77856: LD_ADDR_VAR 0 9
77860: PUSH
77861: LD_VAR 0 8
77865: PUSH
77866: LD_VAR 0 6
77870: ARRAY
77871: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77872: LD_ADDR_VAR 0 8
77876: PUSH
77877: LD_VAR 0 8
77881: PPUSH
77882: LD_VAR 0 6
77886: PPUSH
77887: CALL_OW 3
77891: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77892: LD_ADDR_VAR 0 8
77896: PUSH
77897: LD_VAR 0 8
77901: PPUSH
77902: LD_INT 1
77904: PPUSH
77905: LD_VAR 0 9
77909: PPUSH
77910: CALL_OW 2
77914: ST_TO_ADDR
// end ;
77915: GO 77832
77917: POP
77918: POP
// for i in tmp do
77919: LD_ADDR_VAR 0 6
77923: PUSH
77924: LD_VAR 0 8
77928: PUSH
77929: FOR_IN
77930: IFFALSE 77999
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77932: LD_VAR 0 6
77936: PPUSH
77937: CALL_OW 313
77941: PUSH
77942: LD_INT 6
77944: LESS
77945: PUSH
77946: LD_VAR 0 6
77950: PPUSH
77951: CALL_OW 266
77955: PUSH
77956: LD_INT 31
77958: PUSH
77959: LD_INT 32
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: IN
77966: NOT
77967: AND
77968: PUSH
77969: LD_VAR 0 6
77973: PPUSH
77974: CALL_OW 313
77978: PUSH
77979: LD_INT 0
77981: EQUAL
77982: OR
77983: IFFALSE 77997
// begin j := i ;
77985: LD_ADDR_VAR 0 7
77989: PUSH
77990: LD_VAR 0 6
77994: ST_TO_ADDR
// break ;
77995: GO 77999
// end ; end ;
77997: GO 77929
77999: POP
78000: POP
// if j then
78001: LD_VAR 0 7
78005: IFFALSE 78023
// ComEnterUnit ( unit , j ) else
78007: LD_VAR 0 3
78011: PPUSH
78012: LD_VAR 0 7
78016: PPUSH
78017: CALL_OW 120
78021: GO 78126
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78023: LD_ADDR_VAR 0 10
78027: PUSH
78028: LD_VAR 0 2
78032: PPUSH
78033: LD_INT 2
78035: PUSH
78036: LD_INT 30
78038: PUSH
78039: LD_INT 0
78041: PUSH
78042: EMPTY
78043: LIST
78044: LIST
78045: PUSH
78046: LD_INT 30
78048: PUSH
78049: LD_INT 1
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: LIST
78060: PPUSH
78061: CALL_OW 72
78065: ST_TO_ADDR
// if depot then
78066: LD_VAR 0 10
78070: IFFALSE 78126
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78072: LD_ADDR_VAR 0 10
78076: PUSH
78077: LD_VAR 0 10
78081: PPUSH
78082: LD_VAR 0 3
78086: PPUSH
78087: CALL_OW 74
78091: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78092: LD_VAR 0 3
78096: PPUSH
78097: LD_VAR 0 10
78101: PPUSH
78102: CALL_OW 296
78106: PUSH
78107: LD_INT 10
78109: GREATER
78110: IFFALSE 78126
// ComStandNearbyBuilding ( unit , depot ) ;
78112: LD_VAR 0 3
78116: PPUSH
78117: LD_VAR 0 10
78121: PPUSH
78122: CALL 15342 0 2
// end ; end ; end ;
78126: LD_VAR 0 5
78130: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78131: LD_INT 0
78133: PPUSH
78134: PPUSH
78135: PPUSH
78136: PPUSH
// if not mc_bases then
78137: LD_EXP 58
78141: NOT
78142: IFFALSE 78146
// exit ;
78144: GO 78385
// for i = 1 to mc_bases do
78146: LD_ADDR_VAR 0 2
78150: PUSH
78151: DOUBLE
78152: LD_INT 1
78154: DEC
78155: ST_TO_ADDR
78156: LD_EXP 58
78160: PUSH
78161: FOR_TO
78162: IFFALSE 78383
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78164: LD_ADDR_VAR 0 4
78168: PUSH
78169: LD_EXP 58
78173: PUSH
78174: LD_VAR 0 2
78178: ARRAY
78179: PPUSH
78180: LD_INT 21
78182: PUSH
78183: LD_INT 1
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PPUSH
78190: CALL_OW 72
78194: PUSH
78195: LD_EXP 87
78199: PUSH
78200: LD_VAR 0 2
78204: ARRAY
78205: UNION
78206: ST_TO_ADDR
// if not tmp then
78207: LD_VAR 0 4
78211: NOT
78212: IFFALSE 78216
// continue ;
78214: GO 78161
// for j in tmp do
78216: LD_ADDR_VAR 0 3
78220: PUSH
78221: LD_VAR 0 4
78225: PUSH
78226: FOR_IN
78227: IFFALSE 78379
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78229: LD_VAR 0 3
78233: PPUSH
78234: CALL_OW 110
78238: NOT
78239: PUSH
78240: LD_VAR 0 3
78244: PPUSH
78245: CALL_OW 314
78249: NOT
78250: AND
78251: PUSH
78252: LD_VAR 0 3
78256: PPUSH
78257: CALL_OW 311
78261: NOT
78262: AND
78263: PUSH
78264: LD_VAR 0 3
78268: PPUSH
78269: CALL_OW 310
78273: NOT
78274: AND
78275: PUSH
78276: LD_VAR 0 3
78280: PUSH
78281: LD_EXP 61
78285: PUSH
78286: LD_VAR 0 2
78290: ARRAY
78291: PUSH
78292: LD_INT 1
78294: ARRAY
78295: IN
78296: NOT
78297: AND
78298: PUSH
78299: LD_VAR 0 3
78303: PUSH
78304: LD_EXP 61
78308: PUSH
78309: LD_VAR 0 2
78313: ARRAY
78314: PUSH
78315: LD_INT 2
78317: ARRAY
78318: IN
78319: NOT
78320: AND
78321: PUSH
78322: LD_VAR 0 3
78326: PUSH
78327: LD_EXP 70
78331: PUSH
78332: LD_VAR 0 2
78336: ARRAY
78337: IN
78338: NOT
78339: AND
78340: IFFALSE 78377
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78342: LD_VAR 0 2
78346: PPUSH
78347: LD_EXP 58
78351: PUSH
78352: LD_VAR 0 2
78356: ARRAY
78357: PPUSH
78358: LD_VAR 0 3
78362: PPUSH
78363: LD_VAR 0 3
78367: PPUSH
78368: CALL_OW 257
78372: PPUSH
78373: CALL 77149 0 4
// end ;
78377: GO 78226
78379: POP
78380: POP
// end ;
78381: GO 78161
78383: POP
78384: POP
// end ;
78385: LD_VAR 0 1
78389: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78390: LD_INT 0
78392: PPUSH
78393: PPUSH
78394: PPUSH
78395: PPUSH
78396: PPUSH
78397: PPUSH
// if not mc_bases [ base ] then
78398: LD_EXP 58
78402: PUSH
78403: LD_VAR 0 1
78407: ARRAY
78408: NOT
78409: IFFALSE 78413
// exit ;
78411: GO 78595
// tmp := [ ] ;
78413: LD_ADDR_VAR 0 6
78417: PUSH
78418: EMPTY
78419: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78420: LD_ADDR_VAR 0 7
78424: PUSH
78425: LD_VAR 0 3
78429: PPUSH
78430: LD_INT 0
78432: PPUSH
78433: CALL_OW 517
78437: ST_TO_ADDR
// if not list then
78438: LD_VAR 0 7
78442: NOT
78443: IFFALSE 78447
// exit ;
78445: GO 78595
// for i = 1 to amount do
78447: LD_ADDR_VAR 0 5
78451: PUSH
78452: DOUBLE
78453: LD_INT 1
78455: DEC
78456: ST_TO_ADDR
78457: LD_VAR 0 2
78461: PUSH
78462: FOR_TO
78463: IFFALSE 78543
// begin x := rand ( 1 , list [ 1 ] ) ;
78465: LD_ADDR_VAR 0 8
78469: PUSH
78470: LD_INT 1
78472: PPUSH
78473: LD_VAR 0 7
78477: PUSH
78478: LD_INT 1
78480: ARRAY
78481: PPUSH
78482: CALL_OW 12
78486: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78487: LD_ADDR_VAR 0 6
78491: PUSH
78492: LD_VAR 0 6
78496: PPUSH
78497: LD_VAR 0 5
78501: PPUSH
78502: LD_VAR 0 7
78506: PUSH
78507: LD_INT 1
78509: ARRAY
78510: PUSH
78511: LD_VAR 0 8
78515: ARRAY
78516: PUSH
78517: LD_VAR 0 7
78521: PUSH
78522: LD_INT 2
78524: ARRAY
78525: PUSH
78526: LD_VAR 0 8
78530: ARRAY
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PPUSH
78536: CALL_OW 1
78540: ST_TO_ADDR
// end ;
78541: GO 78462
78543: POP
78544: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78545: LD_ADDR_EXP 71
78549: PUSH
78550: LD_EXP 71
78554: PPUSH
78555: LD_VAR 0 1
78559: PPUSH
78560: LD_VAR 0 6
78564: PPUSH
78565: CALL_OW 1
78569: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78570: LD_ADDR_EXP 73
78574: PUSH
78575: LD_EXP 73
78579: PPUSH
78580: LD_VAR 0 1
78584: PPUSH
78585: LD_VAR 0 3
78589: PPUSH
78590: CALL_OW 1
78594: ST_TO_ADDR
// end ;
78595: LD_VAR 0 4
78599: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78600: LD_INT 0
78602: PPUSH
// if not mc_bases [ base ] then
78603: LD_EXP 58
78607: PUSH
78608: LD_VAR 0 1
78612: ARRAY
78613: NOT
78614: IFFALSE 78618
// exit ;
78616: GO 78643
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78618: LD_ADDR_EXP 63
78622: PUSH
78623: LD_EXP 63
78627: PPUSH
78628: LD_VAR 0 1
78632: PPUSH
78633: LD_VAR 0 2
78637: PPUSH
78638: CALL_OW 1
78642: ST_TO_ADDR
// end ;
78643: LD_VAR 0 3
78647: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78648: LD_INT 0
78650: PPUSH
// if not mc_bases [ base ] then
78651: LD_EXP 58
78655: PUSH
78656: LD_VAR 0 1
78660: ARRAY
78661: NOT
78662: IFFALSE 78666
// exit ;
78664: GO 78703
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78666: LD_ADDR_EXP 63
78670: PUSH
78671: LD_EXP 63
78675: PPUSH
78676: LD_VAR 0 1
78680: PPUSH
78681: LD_EXP 63
78685: PUSH
78686: LD_VAR 0 1
78690: ARRAY
78691: PUSH
78692: LD_VAR 0 2
78696: UNION
78697: PPUSH
78698: CALL_OW 1
78702: ST_TO_ADDR
// end ;
78703: LD_VAR 0 3
78707: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78708: LD_INT 0
78710: PPUSH
// if not mc_bases [ base ] then
78711: LD_EXP 58
78715: PUSH
78716: LD_VAR 0 1
78720: ARRAY
78721: NOT
78722: IFFALSE 78726
// exit ;
78724: GO 78751
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78726: LD_ADDR_EXP 79
78730: PUSH
78731: LD_EXP 79
78735: PPUSH
78736: LD_VAR 0 1
78740: PPUSH
78741: LD_VAR 0 2
78745: PPUSH
78746: CALL_OW 1
78750: ST_TO_ADDR
// end ;
78751: LD_VAR 0 3
78755: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78756: LD_INT 0
78758: PPUSH
// if not mc_bases [ base ] then
78759: LD_EXP 58
78763: PUSH
78764: LD_VAR 0 1
78768: ARRAY
78769: NOT
78770: IFFALSE 78774
// exit ;
78772: GO 78811
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78774: LD_ADDR_EXP 79
78778: PUSH
78779: LD_EXP 79
78783: PPUSH
78784: LD_VAR 0 1
78788: PPUSH
78789: LD_EXP 79
78793: PUSH
78794: LD_VAR 0 1
78798: ARRAY
78799: PUSH
78800: LD_VAR 0 2
78804: ADD
78805: PPUSH
78806: CALL_OW 1
78810: ST_TO_ADDR
// end ;
78811: LD_VAR 0 3
78815: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78816: LD_INT 0
78818: PPUSH
// if not mc_bases [ base ] then
78819: LD_EXP 58
78823: PUSH
78824: LD_VAR 0 1
78828: ARRAY
78829: NOT
78830: IFFALSE 78834
// exit ;
78832: GO 78888
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78834: LD_ADDR_EXP 80
78838: PUSH
78839: LD_EXP 80
78843: PPUSH
78844: LD_VAR 0 1
78848: PPUSH
78849: LD_VAR 0 2
78853: PPUSH
78854: CALL_OW 1
78858: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78859: LD_ADDR_EXP 69
78863: PUSH
78864: LD_EXP 69
78868: PPUSH
78869: LD_VAR 0 1
78873: PPUSH
78874: LD_VAR 0 2
78878: PUSH
78879: LD_INT 0
78881: PLUS
78882: PPUSH
78883: CALL_OW 1
78887: ST_TO_ADDR
// end ;
78888: LD_VAR 0 3
78892: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78893: LD_INT 0
78895: PPUSH
// if not mc_bases [ base ] then
78896: LD_EXP 58
78900: PUSH
78901: LD_VAR 0 1
78905: ARRAY
78906: NOT
78907: IFFALSE 78911
// exit ;
78909: GO 78936
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78911: LD_ADDR_EXP 69
78915: PUSH
78916: LD_EXP 69
78920: PPUSH
78921: LD_VAR 0 1
78925: PPUSH
78926: LD_VAR 0 2
78930: PPUSH
78931: CALL_OW 1
78935: ST_TO_ADDR
// end ;
78936: LD_VAR 0 3
78940: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78941: LD_INT 0
78943: PPUSH
78944: PPUSH
78945: PPUSH
78946: PPUSH
// if not mc_bases [ base ] then
78947: LD_EXP 58
78951: PUSH
78952: LD_VAR 0 1
78956: ARRAY
78957: NOT
78958: IFFALSE 78962
// exit ;
78960: GO 79027
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78962: LD_ADDR_EXP 78
78966: PUSH
78967: LD_EXP 78
78971: PPUSH
78972: LD_VAR 0 1
78976: PUSH
78977: LD_EXP 78
78981: PUSH
78982: LD_VAR 0 1
78986: ARRAY
78987: PUSH
78988: LD_INT 1
78990: PLUS
78991: PUSH
78992: EMPTY
78993: LIST
78994: LIST
78995: PPUSH
78996: LD_VAR 0 1
79000: PUSH
79001: LD_VAR 0 2
79005: PUSH
79006: LD_VAR 0 3
79010: PUSH
79011: LD_VAR 0 4
79015: PUSH
79016: EMPTY
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: PPUSH
79022: CALL 20665 0 3
79026: ST_TO_ADDR
// end ;
79027: LD_VAR 0 5
79031: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79032: LD_INT 0
79034: PPUSH
// if not mc_bases [ base ] then
79035: LD_EXP 58
79039: PUSH
79040: LD_VAR 0 1
79044: ARRAY
79045: NOT
79046: IFFALSE 79050
// exit ;
79048: GO 79075
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79050: LD_ADDR_EXP 95
79054: PUSH
79055: LD_EXP 95
79059: PPUSH
79060: LD_VAR 0 1
79064: PPUSH
79065: LD_VAR 0 2
79069: PPUSH
79070: CALL_OW 1
79074: ST_TO_ADDR
// end ;
79075: LD_VAR 0 3
79079: RET
// export function MC_GetMinesField ( base ) ; begin
79080: LD_INT 0
79082: PPUSH
// result := mc_mines [ base ] ;
79083: LD_ADDR_VAR 0 2
79087: PUSH
79088: LD_EXP 71
79092: PUSH
79093: LD_VAR 0 1
79097: ARRAY
79098: ST_TO_ADDR
// end ;
79099: LD_VAR 0 2
79103: RET
// export function MC_GetProduceList ( base ) ; begin
79104: LD_INT 0
79106: PPUSH
// result := mc_produce [ base ] ;
79107: LD_ADDR_VAR 0 2
79111: PUSH
79112: LD_EXP 79
79116: PUSH
79117: LD_VAR 0 1
79121: ARRAY
79122: ST_TO_ADDR
// end ;
79123: LD_VAR 0 2
79127: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79128: LD_INT 0
79130: PPUSH
79131: PPUSH
// if not mc_bases then
79132: LD_EXP 58
79136: NOT
79137: IFFALSE 79141
// exit ;
79139: GO 79206
// if mc_bases [ base ] then
79141: LD_EXP 58
79145: PUSH
79146: LD_VAR 0 1
79150: ARRAY
79151: IFFALSE 79206
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79153: LD_ADDR_VAR 0 3
79157: PUSH
79158: LD_EXP 58
79162: PUSH
79163: LD_VAR 0 1
79167: ARRAY
79168: PPUSH
79169: LD_INT 30
79171: PUSH
79172: LD_VAR 0 2
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PPUSH
79181: CALL_OW 72
79185: ST_TO_ADDR
// if result then
79186: LD_VAR 0 3
79190: IFFALSE 79206
// result := result [ 1 ] ;
79192: LD_ADDR_VAR 0 3
79196: PUSH
79197: LD_VAR 0 3
79201: PUSH
79202: LD_INT 1
79204: ARRAY
79205: ST_TO_ADDR
// end ; end ;
79206: LD_VAR 0 3
79210: RET
// export function MC_SetTame ( base , area ) ; begin
79211: LD_INT 0
79213: PPUSH
// if not mc_bases or not base then
79214: LD_EXP 58
79218: NOT
79219: PUSH
79220: LD_VAR 0 1
79224: NOT
79225: OR
79226: IFFALSE 79230
// exit ;
79228: GO 79255
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79230: LD_ADDR_EXP 86
79234: PUSH
79235: LD_EXP 86
79239: PPUSH
79240: LD_VAR 0 1
79244: PPUSH
79245: LD_VAR 0 2
79249: PPUSH
79250: CALL_OW 1
79254: ST_TO_ADDR
// end ;
79255: LD_VAR 0 3
79259: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79260: LD_INT 0
79262: PPUSH
79263: PPUSH
// if not mc_bases or not base then
79264: LD_EXP 58
79268: NOT
79269: PUSH
79270: LD_VAR 0 1
79274: NOT
79275: OR
79276: IFFALSE 79280
// exit ;
79278: GO 79382
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79280: LD_ADDR_VAR 0 4
79284: PUSH
79285: LD_EXP 58
79289: PUSH
79290: LD_VAR 0 1
79294: ARRAY
79295: PPUSH
79296: LD_INT 30
79298: PUSH
79299: LD_VAR 0 2
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: PPUSH
79308: CALL_OW 72
79312: ST_TO_ADDR
// if not tmp then
79313: LD_VAR 0 4
79317: NOT
79318: IFFALSE 79322
// exit ;
79320: GO 79382
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79322: LD_ADDR_EXP 90
79326: PUSH
79327: LD_EXP 90
79331: PPUSH
79332: LD_VAR 0 1
79336: PPUSH
79337: LD_EXP 90
79341: PUSH
79342: LD_VAR 0 1
79346: ARRAY
79347: PPUSH
79348: LD_EXP 90
79352: PUSH
79353: LD_VAR 0 1
79357: ARRAY
79358: PUSH
79359: LD_INT 1
79361: PLUS
79362: PPUSH
79363: LD_VAR 0 4
79367: PUSH
79368: LD_INT 1
79370: ARRAY
79371: PPUSH
79372: CALL_OW 2
79376: PPUSH
79377: CALL_OW 1
79381: ST_TO_ADDR
// end ;
79382: LD_VAR 0 3
79386: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79387: LD_INT 0
79389: PPUSH
79390: PPUSH
// if not mc_bases or not base or not kinds then
79391: LD_EXP 58
79395: NOT
79396: PUSH
79397: LD_VAR 0 1
79401: NOT
79402: OR
79403: PUSH
79404: LD_VAR 0 2
79408: NOT
79409: OR
79410: IFFALSE 79414
// exit ;
79412: GO 79475
// for i in kinds do
79414: LD_ADDR_VAR 0 4
79418: PUSH
79419: LD_VAR 0 2
79423: PUSH
79424: FOR_IN
79425: IFFALSE 79473
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79427: LD_ADDR_EXP 92
79431: PUSH
79432: LD_EXP 92
79436: PPUSH
79437: LD_VAR 0 1
79441: PUSH
79442: LD_EXP 92
79446: PUSH
79447: LD_VAR 0 1
79451: ARRAY
79452: PUSH
79453: LD_INT 1
79455: PLUS
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PPUSH
79461: LD_VAR 0 4
79465: PPUSH
79466: CALL 20665 0 3
79470: ST_TO_ADDR
79471: GO 79424
79473: POP
79474: POP
// end ;
79475: LD_VAR 0 3
79479: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79480: LD_INT 0
79482: PPUSH
// if not mc_bases or not base or not areas then
79483: LD_EXP 58
79487: NOT
79488: PUSH
79489: LD_VAR 0 1
79493: NOT
79494: OR
79495: PUSH
79496: LD_VAR 0 2
79500: NOT
79501: OR
79502: IFFALSE 79506
// exit ;
79504: GO 79531
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79506: LD_ADDR_EXP 76
79510: PUSH
79511: LD_EXP 76
79515: PPUSH
79516: LD_VAR 0 1
79520: PPUSH
79521: LD_VAR 0 2
79525: PPUSH
79526: CALL_OW 1
79530: ST_TO_ADDR
// end ;
79531: LD_VAR 0 3
79535: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79536: LD_INT 0
79538: PPUSH
// if not mc_bases or not base or not teleports_exit then
79539: LD_EXP 58
79543: NOT
79544: PUSH
79545: LD_VAR 0 1
79549: NOT
79550: OR
79551: PUSH
79552: LD_VAR 0 2
79556: NOT
79557: OR
79558: IFFALSE 79562
// exit ;
79560: GO 79587
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79562: LD_ADDR_EXP 93
79566: PUSH
79567: LD_EXP 93
79571: PPUSH
79572: LD_VAR 0 1
79576: PPUSH
79577: LD_VAR 0 2
79581: PPUSH
79582: CALL_OW 1
79586: ST_TO_ADDR
// end ;
79587: LD_VAR 0 3
79591: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79592: LD_INT 0
79594: PPUSH
79595: PPUSH
79596: PPUSH
// if not mc_bases or not base or not ext_list then
79597: LD_EXP 58
79601: NOT
79602: PUSH
79603: LD_VAR 0 1
79607: NOT
79608: OR
79609: PUSH
79610: LD_VAR 0 5
79614: NOT
79615: OR
79616: IFFALSE 79620
// exit ;
79618: GO 79793
// tmp := GetFacExtXYD ( x , y , d ) ;
79620: LD_ADDR_VAR 0 8
79624: PUSH
79625: LD_VAR 0 2
79629: PPUSH
79630: LD_VAR 0 3
79634: PPUSH
79635: LD_VAR 0 4
79639: PPUSH
79640: CALL 53980 0 3
79644: ST_TO_ADDR
// if not tmp then
79645: LD_VAR 0 8
79649: NOT
79650: IFFALSE 79654
// exit ;
79652: GO 79793
// for i in tmp do
79654: LD_ADDR_VAR 0 7
79658: PUSH
79659: LD_VAR 0 8
79663: PUSH
79664: FOR_IN
79665: IFFALSE 79791
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79667: LD_ADDR_EXP 63
79671: PUSH
79672: LD_EXP 63
79676: PPUSH
79677: LD_VAR 0 1
79681: PPUSH
79682: LD_EXP 63
79686: PUSH
79687: LD_VAR 0 1
79691: ARRAY
79692: PPUSH
79693: LD_EXP 63
79697: PUSH
79698: LD_VAR 0 1
79702: ARRAY
79703: PUSH
79704: LD_INT 1
79706: PLUS
79707: PPUSH
79708: LD_VAR 0 5
79712: PUSH
79713: LD_INT 1
79715: ARRAY
79716: PUSH
79717: LD_VAR 0 7
79721: PUSH
79722: LD_INT 1
79724: ARRAY
79725: PUSH
79726: LD_VAR 0 7
79730: PUSH
79731: LD_INT 2
79733: ARRAY
79734: PUSH
79735: LD_VAR 0 7
79739: PUSH
79740: LD_INT 3
79742: ARRAY
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: PPUSH
79750: CALL_OW 2
79754: PPUSH
79755: CALL_OW 1
79759: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79760: LD_ADDR_VAR 0 5
79764: PUSH
79765: LD_VAR 0 5
79769: PPUSH
79770: LD_INT 1
79772: PPUSH
79773: CALL_OW 3
79777: ST_TO_ADDR
// if not ext_list then
79778: LD_VAR 0 5
79782: NOT
79783: IFFALSE 79789
// exit ;
79785: POP
79786: POP
79787: GO 79793
// end ;
79789: GO 79664
79791: POP
79792: POP
// end ;
79793: LD_VAR 0 6
79797: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79798: LD_INT 0
79800: PPUSH
// if not mc_bases or not base or not weapon_list then
79801: LD_EXP 58
79805: NOT
79806: PUSH
79807: LD_VAR 0 1
79811: NOT
79812: OR
79813: PUSH
79814: LD_VAR 0 2
79818: NOT
79819: OR
79820: IFFALSE 79824
// exit ;
79822: GO 79849
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79824: LD_ADDR_EXP 97
79828: PUSH
79829: LD_EXP 97
79833: PPUSH
79834: LD_VAR 0 1
79838: PPUSH
79839: LD_VAR 0 2
79843: PPUSH
79844: CALL_OW 1
79848: ST_TO_ADDR
// end ;
79849: LD_VAR 0 3
79853: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79854: LD_INT 0
79856: PPUSH
// if not mc_bases or not base or not tech_list then
79857: LD_EXP 58
79861: NOT
79862: PUSH
79863: LD_VAR 0 1
79867: NOT
79868: OR
79869: PUSH
79870: LD_VAR 0 2
79874: NOT
79875: OR
79876: IFFALSE 79880
// exit ;
79878: GO 79905
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79880: LD_ADDR_EXP 85
79884: PUSH
79885: LD_EXP 85
79889: PPUSH
79890: LD_VAR 0 1
79894: PPUSH
79895: LD_VAR 0 2
79899: PPUSH
79900: CALL_OW 1
79904: ST_TO_ADDR
// end ;
79905: LD_VAR 0 3
79909: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79910: LD_INT 0
79912: PPUSH
// if not mc_bases or not parking_area or not base then
79913: LD_EXP 58
79917: NOT
79918: PUSH
79919: LD_VAR 0 2
79923: NOT
79924: OR
79925: PUSH
79926: LD_VAR 0 1
79930: NOT
79931: OR
79932: IFFALSE 79936
// exit ;
79934: GO 79961
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79936: LD_ADDR_EXP 82
79940: PUSH
79941: LD_EXP 82
79945: PPUSH
79946: LD_VAR 0 1
79950: PPUSH
79951: LD_VAR 0 2
79955: PPUSH
79956: CALL_OW 1
79960: ST_TO_ADDR
// end ;
79961: LD_VAR 0 3
79965: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79966: LD_INT 0
79968: PPUSH
// if not mc_bases or not base or not scan_area then
79969: LD_EXP 58
79973: NOT
79974: PUSH
79975: LD_VAR 0 1
79979: NOT
79980: OR
79981: PUSH
79982: LD_VAR 0 2
79986: NOT
79987: OR
79988: IFFALSE 79992
// exit ;
79990: GO 80017
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79992: LD_ADDR_EXP 83
79996: PUSH
79997: LD_EXP 83
80001: PPUSH
80002: LD_VAR 0 1
80006: PPUSH
80007: LD_VAR 0 2
80011: PPUSH
80012: CALL_OW 1
80016: ST_TO_ADDR
// end ;
80017: LD_VAR 0 3
80021: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80022: LD_INT 0
80024: PPUSH
80025: PPUSH
// if not mc_bases or not base then
80026: LD_EXP 58
80030: NOT
80031: PUSH
80032: LD_VAR 0 1
80036: NOT
80037: OR
80038: IFFALSE 80042
// exit ;
80040: GO 80106
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80042: LD_ADDR_VAR 0 3
80046: PUSH
80047: LD_INT 1
80049: PUSH
80050: LD_INT 2
80052: PUSH
80053: LD_INT 3
80055: PUSH
80056: LD_INT 4
80058: PUSH
80059: LD_INT 11
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80069: LD_ADDR_EXP 85
80073: PUSH
80074: LD_EXP 85
80078: PPUSH
80079: LD_VAR 0 1
80083: PPUSH
80084: LD_EXP 85
80088: PUSH
80089: LD_VAR 0 1
80093: ARRAY
80094: PUSH
80095: LD_VAR 0 3
80099: DIFF
80100: PPUSH
80101: CALL_OW 1
80105: ST_TO_ADDR
// end ;
80106: LD_VAR 0 2
80110: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80111: LD_INT 0
80113: PPUSH
// result := mc_vehicles [ base ] ;
80114: LD_ADDR_VAR 0 3
80118: PUSH
80119: LD_EXP 77
80123: PUSH
80124: LD_VAR 0 1
80128: ARRAY
80129: ST_TO_ADDR
// if onlyCombat then
80130: LD_VAR 0 2
80134: IFFALSE 80299
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80136: LD_ADDR_VAR 0 3
80140: PUSH
80141: LD_VAR 0 3
80145: PUSH
80146: LD_VAR 0 3
80150: PPUSH
80151: LD_INT 2
80153: PUSH
80154: LD_INT 34
80156: PUSH
80157: LD_INT 12
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 34
80166: PUSH
80167: LD_INT 51
80169: PUSH
80170: EMPTY
80171: LIST
80172: LIST
80173: PUSH
80174: LD_INT 34
80176: PUSH
80177: LD_EXP 102
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 34
80188: PUSH
80189: LD_INT 32
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 34
80198: PUSH
80199: LD_INT 13
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 34
80208: PUSH
80209: LD_INT 52
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PUSH
80216: LD_INT 34
80218: PUSH
80219: LD_INT 14
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: PUSH
80226: LD_INT 34
80228: PUSH
80229: LD_INT 53
80231: PUSH
80232: EMPTY
80233: LIST
80234: LIST
80235: PUSH
80236: LD_INT 34
80238: PUSH
80239: LD_EXP 101
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 34
80250: PUSH
80251: LD_INT 31
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 34
80260: PUSH
80261: LD_INT 48
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 34
80270: PUSH
80271: LD_INT 8
80273: PUSH
80274: EMPTY
80275: LIST
80276: LIST
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: PPUSH
80293: CALL_OW 72
80297: DIFF
80298: ST_TO_ADDR
// end ; end_of_file
80299: LD_VAR 0 3
80303: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80304: LD_INT 0
80306: PPUSH
80307: PPUSH
80308: PPUSH
// if not mc_bases or not skirmish then
80309: LD_EXP 58
80313: NOT
80314: PUSH
80315: LD_EXP 56
80319: NOT
80320: OR
80321: IFFALSE 80325
// exit ;
80323: GO 80490
// for i = 1 to mc_bases do
80325: LD_ADDR_VAR 0 4
80329: PUSH
80330: DOUBLE
80331: LD_INT 1
80333: DEC
80334: ST_TO_ADDR
80335: LD_EXP 58
80339: PUSH
80340: FOR_TO
80341: IFFALSE 80488
// begin if sci in mc_bases [ i ] then
80343: LD_VAR 0 2
80347: PUSH
80348: LD_EXP 58
80352: PUSH
80353: LD_VAR 0 4
80357: ARRAY
80358: IN
80359: IFFALSE 80486
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80361: LD_ADDR_EXP 87
80365: PUSH
80366: LD_EXP 87
80370: PPUSH
80371: LD_VAR 0 4
80375: PUSH
80376: LD_EXP 87
80380: PUSH
80381: LD_VAR 0 4
80385: ARRAY
80386: PUSH
80387: LD_INT 1
80389: PLUS
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PPUSH
80395: LD_VAR 0 1
80399: PPUSH
80400: CALL 20665 0 3
80404: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80405: LD_ADDR_VAR 0 5
80409: PUSH
80410: LD_EXP 58
80414: PUSH
80415: LD_VAR 0 4
80419: ARRAY
80420: PPUSH
80421: LD_INT 2
80423: PUSH
80424: LD_INT 30
80426: PUSH
80427: LD_INT 0
80429: PUSH
80430: EMPTY
80431: LIST
80432: LIST
80433: PUSH
80434: LD_INT 30
80436: PUSH
80437: LD_INT 1
80439: PUSH
80440: EMPTY
80441: LIST
80442: LIST
80443: PUSH
80444: EMPTY
80445: LIST
80446: LIST
80447: LIST
80448: PPUSH
80449: CALL_OW 72
80453: PPUSH
80454: LD_VAR 0 1
80458: PPUSH
80459: CALL_OW 74
80463: ST_TO_ADDR
// if tmp then
80464: LD_VAR 0 5
80468: IFFALSE 80484
// ComStandNearbyBuilding ( ape , tmp ) ;
80470: LD_VAR 0 1
80474: PPUSH
80475: LD_VAR 0 5
80479: PPUSH
80480: CALL 15342 0 2
// break ;
80484: GO 80488
// end ; end ;
80486: GO 80340
80488: POP
80489: POP
// end ;
80490: LD_VAR 0 3
80494: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80495: LD_INT 0
80497: PPUSH
80498: PPUSH
80499: PPUSH
// if not mc_bases or not skirmish then
80500: LD_EXP 58
80504: NOT
80505: PUSH
80506: LD_EXP 56
80510: NOT
80511: OR
80512: IFFALSE 80516
// exit ;
80514: GO 80605
// for i = 1 to mc_bases do
80516: LD_ADDR_VAR 0 4
80520: PUSH
80521: DOUBLE
80522: LD_INT 1
80524: DEC
80525: ST_TO_ADDR
80526: LD_EXP 58
80530: PUSH
80531: FOR_TO
80532: IFFALSE 80603
// begin if building in mc_busy_turret_list [ i ] then
80534: LD_VAR 0 1
80538: PUSH
80539: LD_EXP 68
80543: PUSH
80544: LD_VAR 0 4
80548: ARRAY
80549: IN
80550: IFFALSE 80601
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80552: LD_ADDR_VAR 0 5
80556: PUSH
80557: LD_EXP 68
80561: PUSH
80562: LD_VAR 0 4
80566: ARRAY
80567: PUSH
80568: LD_VAR 0 1
80572: DIFF
80573: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80574: LD_ADDR_EXP 68
80578: PUSH
80579: LD_EXP 68
80583: PPUSH
80584: LD_VAR 0 4
80588: PPUSH
80589: LD_VAR 0 5
80593: PPUSH
80594: CALL_OW 1
80598: ST_TO_ADDR
// break ;
80599: GO 80603
// end ; end ;
80601: GO 80531
80603: POP
80604: POP
// end ;
80605: LD_VAR 0 3
80609: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80610: LD_INT 0
80612: PPUSH
80613: PPUSH
80614: PPUSH
// if not mc_bases or not skirmish then
80615: LD_EXP 58
80619: NOT
80620: PUSH
80621: LD_EXP 56
80625: NOT
80626: OR
80627: IFFALSE 80631
// exit ;
80629: GO 80830
// for i = 1 to mc_bases do
80631: LD_ADDR_VAR 0 5
80635: PUSH
80636: DOUBLE
80637: LD_INT 1
80639: DEC
80640: ST_TO_ADDR
80641: LD_EXP 58
80645: PUSH
80646: FOR_TO
80647: IFFALSE 80828
// if building in mc_bases [ i ] then
80649: LD_VAR 0 1
80653: PUSH
80654: LD_EXP 58
80658: PUSH
80659: LD_VAR 0 5
80663: ARRAY
80664: IN
80665: IFFALSE 80826
// begin tmp := mc_bases [ i ] diff building ;
80667: LD_ADDR_VAR 0 6
80671: PUSH
80672: LD_EXP 58
80676: PUSH
80677: LD_VAR 0 5
80681: ARRAY
80682: PUSH
80683: LD_VAR 0 1
80687: DIFF
80688: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80689: LD_ADDR_EXP 58
80693: PUSH
80694: LD_EXP 58
80698: PPUSH
80699: LD_VAR 0 5
80703: PPUSH
80704: LD_VAR 0 6
80708: PPUSH
80709: CALL_OW 1
80713: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80714: LD_VAR 0 1
80718: PUSH
80719: LD_EXP 66
80723: PUSH
80724: LD_VAR 0 5
80728: ARRAY
80729: IN
80730: IFFALSE 80769
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80732: LD_ADDR_EXP 66
80736: PUSH
80737: LD_EXP 66
80741: PPUSH
80742: LD_VAR 0 5
80746: PPUSH
80747: LD_EXP 66
80751: PUSH
80752: LD_VAR 0 5
80756: ARRAY
80757: PUSH
80758: LD_VAR 0 1
80762: DIFF
80763: PPUSH
80764: CALL_OW 1
80768: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80769: LD_VAR 0 1
80773: PUSH
80774: LD_EXP 67
80778: PUSH
80779: LD_VAR 0 5
80783: ARRAY
80784: IN
80785: IFFALSE 80824
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80787: LD_ADDR_EXP 67
80791: PUSH
80792: LD_EXP 67
80796: PPUSH
80797: LD_VAR 0 5
80801: PPUSH
80802: LD_EXP 67
80806: PUSH
80807: LD_VAR 0 5
80811: ARRAY
80812: PUSH
80813: LD_VAR 0 1
80817: DIFF
80818: PPUSH
80819: CALL_OW 1
80823: ST_TO_ADDR
// break ;
80824: GO 80828
// end ;
80826: GO 80646
80828: POP
80829: POP
// end ;
80830: LD_VAR 0 4
80834: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80835: LD_INT 0
80837: PPUSH
80838: PPUSH
80839: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80840: LD_EXP 58
80844: NOT
80845: PUSH
80846: LD_EXP 56
80850: NOT
80851: OR
80852: PUSH
80853: LD_VAR 0 3
80857: PUSH
80858: LD_EXP 84
80862: IN
80863: NOT
80864: OR
80865: IFFALSE 80869
// exit ;
80867: GO 80992
// for i = 1 to mc_vehicles do
80869: LD_ADDR_VAR 0 6
80873: PUSH
80874: DOUBLE
80875: LD_INT 1
80877: DEC
80878: ST_TO_ADDR
80879: LD_EXP 77
80883: PUSH
80884: FOR_TO
80885: IFFALSE 80990
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80887: LD_VAR 0 2
80891: PUSH
80892: LD_EXP 77
80896: PUSH
80897: LD_VAR 0 6
80901: ARRAY
80902: IN
80903: PUSH
80904: LD_VAR 0 1
80908: PUSH
80909: LD_EXP 77
80913: PUSH
80914: LD_VAR 0 6
80918: ARRAY
80919: IN
80920: OR
80921: IFFALSE 80988
// begin tmp := mc_vehicles [ i ] diff old ;
80923: LD_ADDR_VAR 0 7
80927: PUSH
80928: LD_EXP 77
80932: PUSH
80933: LD_VAR 0 6
80937: ARRAY
80938: PUSH
80939: LD_VAR 0 2
80943: DIFF
80944: ST_TO_ADDR
// tmp := tmp diff new ;
80945: LD_ADDR_VAR 0 7
80949: PUSH
80950: LD_VAR 0 7
80954: PUSH
80955: LD_VAR 0 1
80959: DIFF
80960: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80961: LD_ADDR_EXP 77
80965: PUSH
80966: LD_EXP 77
80970: PPUSH
80971: LD_VAR 0 6
80975: PPUSH
80976: LD_VAR 0 7
80980: PPUSH
80981: CALL_OW 1
80985: ST_TO_ADDR
// break ;
80986: GO 80990
// end ;
80988: GO 80884
80990: POP
80991: POP
// end ;
80992: LD_VAR 0 5
80996: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80997: LD_INT 0
80999: PPUSH
81000: PPUSH
81001: PPUSH
81002: PPUSH
// if not mc_bases or not skirmish then
81003: LD_EXP 58
81007: NOT
81008: PUSH
81009: LD_EXP 56
81013: NOT
81014: OR
81015: IFFALSE 81019
// exit ;
81017: GO 81402
// side := GetSide ( vehicle ) ;
81019: LD_ADDR_VAR 0 5
81023: PUSH
81024: LD_VAR 0 1
81028: PPUSH
81029: CALL_OW 255
81033: ST_TO_ADDR
// for i = 1 to mc_bases do
81034: LD_ADDR_VAR 0 4
81038: PUSH
81039: DOUBLE
81040: LD_INT 1
81042: DEC
81043: ST_TO_ADDR
81044: LD_EXP 58
81048: PUSH
81049: FOR_TO
81050: IFFALSE 81400
// begin if factory in mc_bases [ i ] then
81052: LD_VAR 0 2
81056: PUSH
81057: LD_EXP 58
81061: PUSH
81062: LD_VAR 0 4
81066: ARRAY
81067: IN
81068: IFFALSE 81398
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
81070: LD_EXP 80
81074: PUSH
81075: LD_VAR 0 4
81079: ARRAY
81080: PUSH
81081: LD_EXP 69
81085: PUSH
81086: LD_VAR 0 4
81090: ARRAY
81091: LESS
81092: PUSH
81093: LD_VAR 0 1
81097: PPUSH
81098: CALL_OW 264
81102: PUSH
81103: LD_INT 31
81105: PUSH
81106: LD_INT 32
81108: PUSH
81109: LD_INT 51
81111: PUSH
81112: LD_EXP 102
81116: PUSH
81117: LD_INT 12
81119: PUSH
81120: LD_INT 30
81122: PUSH
81123: LD_EXP 101
81127: PUSH
81128: LD_INT 11
81130: PUSH
81131: LD_INT 53
81133: PUSH
81134: LD_INT 14
81136: PUSH
81137: LD_EXP 105
81141: PUSH
81142: LD_INT 29
81144: PUSH
81145: LD_EXP 103
81149: PUSH
81150: LD_INT 13
81152: PUSH
81153: LD_INT 52
81155: PUSH
81156: LD_INT 48
81158: PUSH
81159: LD_INT 8
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: IN
81181: NOT
81182: AND
81183: IFFALSE 81224
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
81185: LD_ADDR_EXP 80
81189: PUSH
81190: LD_EXP 80
81194: PPUSH
81195: LD_VAR 0 4
81199: PPUSH
81200: LD_EXP 80
81204: PUSH
81205: LD_VAR 0 4
81209: ARRAY
81210: PUSH
81211: LD_VAR 0 1
81215: ADD
81216: PPUSH
81217: CALL_OW 1
81221: ST_TO_ADDR
81222: GO 81268
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81224: LD_ADDR_EXP 77
81228: PUSH
81229: LD_EXP 77
81233: PPUSH
81234: LD_VAR 0 4
81238: PUSH
81239: LD_EXP 77
81243: PUSH
81244: LD_VAR 0 4
81248: ARRAY
81249: PUSH
81250: LD_INT 1
81252: PLUS
81253: PUSH
81254: EMPTY
81255: LIST
81256: LIST
81257: PPUSH
81258: LD_VAR 0 1
81262: PPUSH
81263: CALL 20665 0 3
81267: ST_TO_ADDR
// if not mc_scan [ i ] then
81268: LD_EXP 81
81272: PUSH
81273: LD_VAR 0 4
81277: ARRAY
81278: NOT
81279: IFFALSE 81398
// begin if GetControl ( vehicle ) = control_remote then
81281: LD_VAR 0 1
81285: PPUSH
81286: CALL_OW 263
81290: PUSH
81291: LD_INT 2
81293: EQUAL
81294: IFFALSE 81314
// repeat wait ( 0 0$1 ) ;
81296: LD_INT 35
81298: PPUSH
81299: CALL_OW 67
// until IsControledBy ( vehicle ) ;
81303: LD_VAR 0 1
81307: PPUSH
81308: CALL_OW 312
81312: IFFALSE 81296
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81314: LD_VAR 0 1
81318: PPUSH
81319: LD_EXP 82
81323: PUSH
81324: LD_VAR 0 4
81328: ARRAY
81329: PPUSH
81330: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81334: LD_VAR 0 1
81338: PPUSH
81339: CALL_OW 263
81343: PUSH
81344: LD_INT 1
81346: NONEQUAL
81347: IFFALSE 81351
// break ;
81349: GO 81400
// repeat wait ( 0 0$1 ) ;
81351: LD_INT 35
81353: PPUSH
81354: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81358: LD_VAR 0 1
81362: PPUSH
81363: LD_EXP 82
81367: PUSH
81368: LD_VAR 0 4
81372: ARRAY
81373: PPUSH
81374: CALL_OW 308
81378: IFFALSE 81351
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81380: LD_VAR 0 1
81384: PPUSH
81385: CALL_OW 311
81389: PPUSH
81390: CALL_OW 121
// exit ;
81394: POP
81395: POP
81396: GO 81402
// end ; end ; end ;
81398: GO 81049
81400: POP
81401: POP
// end ;
81402: LD_VAR 0 3
81406: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81407: LD_INT 0
81409: PPUSH
81410: PPUSH
81411: PPUSH
81412: PPUSH
// if not mc_bases or not skirmish then
81413: LD_EXP 58
81417: NOT
81418: PUSH
81419: LD_EXP 56
81423: NOT
81424: OR
81425: IFFALSE 81429
// exit ;
81427: GO 81782
// repeat wait ( 0 0$1 ) ;
81429: LD_INT 35
81431: PPUSH
81432: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81436: LD_VAR 0 2
81440: PPUSH
81441: LD_VAR 0 3
81445: PPUSH
81446: CALL_OW 284
81450: IFFALSE 81429
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81452: LD_VAR 0 2
81456: PPUSH
81457: LD_VAR 0 3
81461: PPUSH
81462: CALL_OW 283
81466: PUSH
81467: LD_INT 4
81469: EQUAL
81470: IFFALSE 81474
// exit ;
81472: GO 81782
// for i = 1 to mc_bases do
81474: LD_ADDR_VAR 0 7
81478: PUSH
81479: DOUBLE
81480: LD_INT 1
81482: DEC
81483: ST_TO_ADDR
81484: LD_EXP 58
81488: PUSH
81489: FOR_TO
81490: IFFALSE 81780
// begin if mc_crates_area [ i ] then
81492: LD_EXP 76
81496: PUSH
81497: LD_VAR 0 7
81501: ARRAY
81502: IFFALSE 81613
// for j in mc_crates_area [ i ] do
81504: LD_ADDR_VAR 0 8
81508: PUSH
81509: LD_EXP 76
81513: PUSH
81514: LD_VAR 0 7
81518: ARRAY
81519: PUSH
81520: FOR_IN
81521: IFFALSE 81611
// if InArea ( x , y , j ) then
81523: LD_VAR 0 2
81527: PPUSH
81528: LD_VAR 0 3
81532: PPUSH
81533: LD_VAR 0 8
81537: PPUSH
81538: CALL_OW 309
81542: IFFALSE 81609
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81544: LD_ADDR_EXP 74
81548: PUSH
81549: LD_EXP 74
81553: PPUSH
81554: LD_VAR 0 7
81558: PUSH
81559: LD_EXP 74
81563: PUSH
81564: LD_VAR 0 7
81568: ARRAY
81569: PUSH
81570: LD_INT 1
81572: PLUS
81573: PUSH
81574: EMPTY
81575: LIST
81576: LIST
81577: PPUSH
81578: LD_VAR 0 4
81582: PUSH
81583: LD_VAR 0 2
81587: PUSH
81588: LD_VAR 0 3
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: LIST
81597: PPUSH
81598: CALL 20665 0 3
81602: ST_TO_ADDR
// exit ;
81603: POP
81604: POP
81605: POP
81606: POP
81607: GO 81782
// end ;
81609: GO 81520
81611: POP
81612: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81613: LD_ADDR_VAR 0 9
81617: PUSH
81618: LD_EXP 58
81622: PUSH
81623: LD_VAR 0 7
81627: ARRAY
81628: PPUSH
81629: LD_INT 2
81631: PUSH
81632: LD_INT 30
81634: PUSH
81635: LD_INT 0
81637: PUSH
81638: EMPTY
81639: LIST
81640: LIST
81641: PUSH
81642: LD_INT 30
81644: PUSH
81645: LD_INT 1
81647: PUSH
81648: EMPTY
81649: LIST
81650: LIST
81651: PUSH
81652: EMPTY
81653: LIST
81654: LIST
81655: LIST
81656: PPUSH
81657: CALL_OW 72
81661: ST_TO_ADDR
// if not depot then
81662: LD_VAR 0 9
81666: NOT
81667: IFFALSE 81671
// continue ;
81669: GO 81489
// for j in depot do
81671: LD_ADDR_VAR 0 8
81675: PUSH
81676: LD_VAR 0 9
81680: PUSH
81681: FOR_IN
81682: IFFALSE 81776
// if GetDistUnitXY ( j , x , y ) < 30 then
81684: LD_VAR 0 8
81688: PPUSH
81689: LD_VAR 0 2
81693: PPUSH
81694: LD_VAR 0 3
81698: PPUSH
81699: CALL_OW 297
81703: PUSH
81704: LD_INT 30
81706: LESS
81707: IFFALSE 81774
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81709: LD_ADDR_EXP 74
81713: PUSH
81714: LD_EXP 74
81718: PPUSH
81719: LD_VAR 0 7
81723: PUSH
81724: LD_EXP 74
81728: PUSH
81729: LD_VAR 0 7
81733: ARRAY
81734: PUSH
81735: LD_INT 1
81737: PLUS
81738: PUSH
81739: EMPTY
81740: LIST
81741: LIST
81742: PPUSH
81743: LD_VAR 0 4
81747: PUSH
81748: LD_VAR 0 2
81752: PUSH
81753: LD_VAR 0 3
81757: PUSH
81758: EMPTY
81759: LIST
81760: LIST
81761: LIST
81762: PPUSH
81763: CALL 20665 0 3
81767: ST_TO_ADDR
// exit ;
81768: POP
81769: POP
81770: POP
81771: POP
81772: GO 81782
// end ;
81774: GO 81681
81776: POP
81777: POP
// end ;
81778: GO 81489
81780: POP
81781: POP
// end ;
81782: LD_VAR 0 6
81786: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81787: LD_INT 0
81789: PPUSH
81790: PPUSH
81791: PPUSH
81792: PPUSH
// if not mc_bases or not skirmish then
81793: LD_EXP 58
81797: NOT
81798: PUSH
81799: LD_EXP 56
81803: NOT
81804: OR
81805: IFFALSE 81809
// exit ;
81807: GO 82086
// side := GetSide ( lab ) ;
81809: LD_ADDR_VAR 0 4
81813: PUSH
81814: LD_VAR 0 2
81818: PPUSH
81819: CALL_OW 255
81823: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81824: LD_VAR 0 4
81828: PUSH
81829: LD_EXP 84
81833: IN
81834: NOT
81835: PUSH
81836: LD_EXP 85
81840: NOT
81841: OR
81842: PUSH
81843: LD_EXP 58
81847: NOT
81848: OR
81849: IFFALSE 81853
// exit ;
81851: GO 82086
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81853: LD_ADDR_EXP 85
81857: PUSH
81858: LD_EXP 85
81862: PPUSH
81863: LD_VAR 0 4
81867: PPUSH
81868: LD_EXP 85
81872: PUSH
81873: LD_VAR 0 4
81877: ARRAY
81878: PUSH
81879: LD_VAR 0 1
81883: DIFF
81884: PPUSH
81885: CALL_OW 1
81889: ST_TO_ADDR
// for i = 1 to mc_bases do
81890: LD_ADDR_VAR 0 5
81894: PUSH
81895: DOUBLE
81896: LD_INT 1
81898: DEC
81899: ST_TO_ADDR
81900: LD_EXP 58
81904: PUSH
81905: FOR_TO
81906: IFFALSE 82084
// begin if lab in mc_bases [ i ] then
81908: LD_VAR 0 2
81912: PUSH
81913: LD_EXP 58
81917: PUSH
81918: LD_VAR 0 5
81922: ARRAY
81923: IN
81924: IFFALSE 82082
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81926: LD_VAR 0 1
81930: PUSH
81931: LD_INT 11
81933: PUSH
81934: LD_INT 4
81936: PUSH
81937: LD_INT 3
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: LIST
81947: LIST
81948: IN
81949: PUSH
81950: LD_EXP 88
81954: PUSH
81955: LD_VAR 0 5
81959: ARRAY
81960: AND
81961: IFFALSE 82082
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81963: LD_ADDR_VAR 0 6
81967: PUSH
81968: LD_EXP 88
81972: PUSH
81973: LD_VAR 0 5
81977: ARRAY
81978: PUSH
81979: LD_INT 1
81981: ARRAY
81982: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81983: LD_ADDR_EXP 88
81987: PUSH
81988: LD_EXP 88
81992: PPUSH
81993: LD_VAR 0 5
81997: PPUSH
81998: EMPTY
81999: PPUSH
82000: CALL_OW 1
82004: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82005: LD_VAR 0 6
82009: PPUSH
82010: LD_INT 0
82012: PPUSH
82013: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82017: LD_VAR 0 6
82021: PPUSH
82022: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82026: LD_ADDR_EXP 87
82030: PUSH
82031: LD_EXP 87
82035: PPUSH
82036: LD_VAR 0 5
82040: PPUSH
82041: LD_EXP 87
82045: PUSH
82046: LD_VAR 0 5
82050: ARRAY
82051: PPUSH
82052: LD_INT 1
82054: PPUSH
82055: LD_VAR 0 6
82059: PPUSH
82060: CALL_OW 2
82064: PPUSH
82065: CALL_OW 1
82069: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82070: LD_VAR 0 5
82074: PPUSH
82075: LD_INT 112
82077: PPUSH
82078: CALL 59555 0 2
// end ; end ; end ;
82082: GO 81905
82084: POP
82085: POP
// end ;
82086: LD_VAR 0 3
82090: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82091: LD_INT 0
82093: PPUSH
82094: PPUSH
82095: PPUSH
82096: PPUSH
82097: PPUSH
82098: PPUSH
82099: PPUSH
82100: PPUSH
// if not mc_bases or not skirmish then
82101: LD_EXP 58
82105: NOT
82106: PUSH
82107: LD_EXP 56
82111: NOT
82112: OR
82113: IFFALSE 82117
// exit ;
82115: GO 83133
// for i = 1 to mc_bases do
82117: LD_ADDR_VAR 0 3
82121: PUSH
82122: DOUBLE
82123: LD_INT 1
82125: DEC
82126: ST_TO_ADDR
82127: LD_EXP 58
82131: PUSH
82132: FOR_TO
82133: IFFALSE 83131
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82135: LD_VAR 0 1
82139: PUSH
82140: LD_EXP 58
82144: PUSH
82145: LD_VAR 0 3
82149: ARRAY
82150: IN
82151: PUSH
82152: LD_VAR 0 1
82156: PUSH
82157: LD_EXP 65
82161: PUSH
82162: LD_VAR 0 3
82166: ARRAY
82167: IN
82168: OR
82169: PUSH
82170: LD_VAR 0 1
82174: PUSH
82175: LD_EXP 77
82179: PUSH
82180: LD_VAR 0 3
82184: ARRAY
82185: IN
82186: OR
82187: PUSH
82188: LD_VAR 0 1
82192: PUSH
82193: LD_EXP 87
82197: PUSH
82198: LD_VAR 0 3
82202: ARRAY
82203: IN
82204: OR
82205: PUSH
82206: LD_VAR 0 1
82210: PUSH
82211: LD_EXP 88
82215: PUSH
82216: LD_VAR 0 3
82220: ARRAY
82221: IN
82222: OR
82223: IFFALSE 83129
// begin if un in mc_ape [ i ] then
82225: LD_VAR 0 1
82229: PUSH
82230: LD_EXP 87
82234: PUSH
82235: LD_VAR 0 3
82239: ARRAY
82240: IN
82241: IFFALSE 82280
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82243: LD_ADDR_EXP 87
82247: PUSH
82248: LD_EXP 87
82252: PPUSH
82253: LD_VAR 0 3
82257: PPUSH
82258: LD_EXP 87
82262: PUSH
82263: LD_VAR 0 3
82267: ARRAY
82268: PUSH
82269: LD_VAR 0 1
82273: DIFF
82274: PPUSH
82275: CALL_OW 1
82279: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82280: LD_VAR 0 1
82284: PUSH
82285: LD_EXP 88
82289: PUSH
82290: LD_VAR 0 3
82294: ARRAY
82295: IN
82296: IFFALSE 82320
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82298: LD_ADDR_EXP 88
82302: PUSH
82303: LD_EXP 88
82307: PPUSH
82308: LD_VAR 0 3
82312: PPUSH
82313: EMPTY
82314: PPUSH
82315: CALL_OW 1
82319: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
82320: LD_VAR 0 1
82324: PPUSH
82325: CALL_OW 247
82329: PUSH
82330: LD_INT 2
82332: EQUAL
82333: PUSH
82334: LD_VAR 0 1
82338: PPUSH
82339: CALL_OW 110
82343: PUSH
82344: LD_INT 20
82346: EQUAL
82347: PUSH
82348: LD_VAR 0 1
82352: PUSH
82353: LD_EXP 80
82357: PUSH
82358: LD_VAR 0 3
82362: ARRAY
82363: IN
82364: OR
82365: AND
82366: IFFALSE 82469
// begin fac := MC_GetBuilding ( i , b_factory ) ;
82368: LD_ADDR_VAR 0 8
82372: PUSH
82373: LD_VAR 0 3
82377: PPUSH
82378: LD_INT 3
82380: PPUSH
82381: CALL 79128 0 2
82385: ST_TO_ADDR
// if fac then
82386: LD_VAR 0 8
82390: IFFALSE 82469
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82392: LD_ADDR_VAR 0 9
82396: PUSH
82397: LD_VAR 0 8
82401: PPUSH
82402: LD_VAR 0 1
82406: PPUSH
82407: CALL_OW 265
82411: PPUSH
82412: LD_VAR 0 1
82416: PPUSH
82417: CALL_OW 262
82421: PPUSH
82422: LD_VAR 0 1
82426: PPUSH
82427: CALL_OW 263
82431: PPUSH
82432: LD_VAR 0 1
82436: PPUSH
82437: CALL_OW 264
82441: PPUSH
82442: CALL 18265 0 5
82446: ST_TO_ADDR
// if components then
82447: LD_VAR 0 9
82451: IFFALSE 82467
// MC_InsertProduceList ( i , components ) ;
82453: LD_VAR 0 3
82457: PPUSH
82458: LD_VAR 0 9
82462: PPUSH
82463: CALL 78756 0 2
// break ;
82467: GO 83131
// end ; end ; if GetType ( un ) = unit_building then
82469: LD_VAR 0 1
82473: PPUSH
82474: CALL_OW 247
82478: PUSH
82479: LD_INT 3
82481: EQUAL
82482: IFFALSE 82797
// begin btype := GetBType ( un ) ;
82484: LD_ADDR_VAR 0 5
82488: PUSH
82489: LD_VAR 0 1
82493: PPUSH
82494: CALL_OW 266
82498: ST_TO_ADDR
// if btype = b_warehouse then
82499: LD_VAR 0 5
82503: PUSH
82504: LD_INT 1
82506: EQUAL
82507: IFFALSE 82525
// begin btype := b_depot ;
82509: LD_ADDR_VAR 0 5
82513: PUSH
82514: LD_INT 0
82516: ST_TO_ADDR
// pos := 1 ;
82517: LD_ADDR_VAR 0 6
82521: PUSH
82522: LD_INT 1
82524: ST_TO_ADDR
// end ; if btype = b_factory then
82525: LD_VAR 0 5
82529: PUSH
82530: LD_INT 3
82532: EQUAL
82533: IFFALSE 82551
// begin btype := b_workshop ;
82535: LD_ADDR_VAR 0 5
82539: PUSH
82540: LD_INT 2
82542: ST_TO_ADDR
// pos := 1 ;
82543: LD_ADDR_VAR 0 6
82547: PUSH
82548: LD_INT 1
82550: ST_TO_ADDR
// end ; if btype = b_barracks then
82551: LD_VAR 0 5
82555: PUSH
82556: LD_INT 5
82558: EQUAL
82559: IFFALSE 82569
// btype := b_armoury ;
82561: LD_ADDR_VAR 0 5
82565: PUSH
82566: LD_INT 4
82568: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82569: LD_VAR 0 5
82573: PUSH
82574: LD_INT 7
82576: PUSH
82577: LD_INT 8
82579: PUSH
82580: EMPTY
82581: LIST
82582: LIST
82583: IN
82584: IFFALSE 82594
// btype := b_lab ;
82586: LD_ADDR_VAR 0 5
82590: PUSH
82591: LD_INT 6
82593: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82594: LD_ADDR_EXP 63
82598: PUSH
82599: LD_EXP 63
82603: PPUSH
82604: LD_VAR 0 3
82608: PUSH
82609: LD_EXP 63
82613: PUSH
82614: LD_VAR 0 3
82618: ARRAY
82619: PUSH
82620: LD_INT 1
82622: PLUS
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PPUSH
82628: LD_VAR 0 5
82632: PUSH
82633: LD_VAR 0 1
82637: PPUSH
82638: CALL_OW 250
82642: PUSH
82643: LD_VAR 0 1
82647: PPUSH
82648: CALL_OW 251
82652: PUSH
82653: LD_VAR 0 1
82657: PPUSH
82658: CALL_OW 254
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: LIST
82667: LIST
82668: PPUSH
82669: CALL 20665 0 3
82673: ST_TO_ADDR
// if pos = 1 then
82674: LD_VAR 0 6
82678: PUSH
82679: LD_INT 1
82681: EQUAL
82682: IFFALSE 82797
// begin tmp := mc_build_list [ i ] ;
82684: LD_ADDR_VAR 0 7
82688: PUSH
82689: LD_EXP 63
82693: PUSH
82694: LD_VAR 0 3
82698: ARRAY
82699: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82700: LD_VAR 0 7
82704: PPUSH
82705: LD_INT 2
82707: PUSH
82708: LD_INT 30
82710: PUSH
82711: LD_INT 0
82713: PUSH
82714: EMPTY
82715: LIST
82716: LIST
82717: PUSH
82718: LD_INT 30
82720: PUSH
82721: LD_INT 1
82723: PUSH
82724: EMPTY
82725: LIST
82726: LIST
82727: PUSH
82728: EMPTY
82729: LIST
82730: LIST
82731: LIST
82732: PPUSH
82733: CALL_OW 72
82737: IFFALSE 82747
// pos := 2 ;
82739: LD_ADDR_VAR 0 6
82743: PUSH
82744: LD_INT 2
82746: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82747: LD_ADDR_VAR 0 7
82751: PUSH
82752: LD_VAR 0 7
82756: PPUSH
82757: LD_VAR 0 6
82761: PPUSH
82762: LD_VAR 0 7
82766: PPUSH
82767: CALL 20991 0 3
82771: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82772: LD_ADDR_EXP 63
82776: PUSH
82777: LD_EXP 63
82781: PPUSH
82782: LD_VAR 0 3
82786: PPUSH
82787: LD_VAR 0 7
82791: PPUSH
82792: CALL_OW 1
82796: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82797: LD_VAR 0 1
82801: PUSH
82802: LD_EXP 58
82806: PUSH
82807: LD_VAR 0 3
82811: ARRAY
82812: IN
82813: IFFALSE 82852
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82815: LD_ADDR_EXP 58
82819: PUSH
82820: LD_EXP 58
82824: PPUSH
82825: LD_VAR 0 3
82829: PPUSH
82830: LD_EXP 58
82834: PUSH
82835: LD_VAR 0 3
82839: ARRAY
82840: PUSH
82841: LD_VAR 0 1
82845: DIFF
82846: PPUSH
82847: CALL_OW 1
82851: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82852: LD_VAR 0 1
82856: PUSH
82857: LD_EXP 65
82861: PUSH
82862: LD_VAR 0 3
82866: ARRAY
82867: IN
82868: IFFALSE 82907
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82870: LD_ADDR_EXP 65
82874: PUSH
82875: LD_EXP 65
82879: PPUSH
82880: LD_VAR 0 3
82884: PPUSH
82885: LD_EXP 65
82889: PUSH
82890: LD_VAR 0 3
82894: ARRAY
82895: PUSH
82896: LD_VAR 0 1
82900: DIFF
82901: PPUSH
82902: CALL_OW 1
82906: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82907: LD_VAR 0 1
82911: PUSH
82912: LD_EXP 77
82916: PUSH
82917: LD_VAR 0 3
82921: ARRAY
82922: IN
82923: IFFALSE 82962
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82925: LD_ADDR_EXP 77
82929: PUSH
82930: LD_EXP 77
82934: PPUSH
82935: LD_VAR 0 3
82939: PPUSH
82940: LD_EXP 77
82944: PUSH
82945: LD_VAR 0 3
82949: ARRAY
82950: PUSH
82951: LD_VAR 0 1
82955: DIFF
82956: PPUSH
82957: CALL_OW 1
82961: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82962: LD_VAR 0 1
82966: PUSH
82967: LD_EXP 80
82971: PUSH
82972: LD_VAR 0 3
82976: ARRAY
82977: IN
82978: IFFALSE 83017
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82980: LD_ADDR_EXP 80
82984: PUSH
82985: LD_EXP 80
82989: PPUSH
82990: LD_VAR 0 3
82994: PPUSH
82995: LD_EXP 80
82999: PUSH
83000: LD_VAR 0 3
83004: ARRAY
83005: PUSH
83006: LD_VAR 0 1
83010: DIFF
83011: PPUSH
83012: CALL_OW 1
83016: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83017: LD_VAR 0 1
83021: PUSH
83022: LD_EXP 67
83026: PUSH
83027: LD_VAR 0 3
83031: ARRAY
83032: IN
83033: IFFALSE 83072
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83035: LD_ADDR_EXP 67
83039: PUSH
83040: LD_EXP 67
83044: PPUSH
83045: LD_VAR 0 3
83049: PPUSH
83050: LD_EXP 67
83054: PUSH
83055: LD_VAR 0 3
83059: ARRAY
83060: PUSH
83061: LD_VAR 0 1
83065: DIFF
83066: PPUSH
83067: CALL_OW 1
83071: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83072: LD_VAR 0 1
83076: PUSH
83077: LD_EXP 66
83081: PUSH
83082: LD_VAR 0 3
83086: ARRAY
83087: IN
83088: IFFALSE 83127
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83090: LD_ADDR_EXP 66
83094: PUSH
83095: LD_EXP 66
83099: PPUSH
83100: LD_VAR 0 3
83104: PPUSH
83105: LD_EXP 66
83109: PUSH
83110: LD_VAR 0 3
83114: ARRAY
83115: PUSH
83116: LD_VAR 0 1
83120: DIFF
83121: PPUSH
83122: CALL_OW 1
83126: ST_TO_ADDR
// end ; break ;
83127: GO 83131
// end ;
83129: GO 82132
83131: POP
83132: POP
// end ;
83133: LD_VAR 0 2
83137: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83138: LD_INT 0
83140: PPUSH
83141: PPUSH
83142: PPUSH
// if not mc_bases or not skirmish then
83143: LD_EXP 58
83147: NOT
83148: PUSH
83149: LD_EXP 56
83153: NOT
83154: OR
83155: IFFALSE 83159
// exit ;
83157: GO 83374
// for i = 1 to mc_bases do
83159: LD_ADDR_VAR 0 3
83163: PUSH
83164: DOUBLE
83165: LD_INT 1
83167: DEC
83168: ST_TO_ADDR
83169: LD_EXP 58
83173: PUSH
83174: FOR_TO
83175: IFFALSE 83372
// begin if building in mc_construct_list [ i ] then
83177: LD_VAR 0 1
83181: PUSH
83182: LD_EXP 65
83186: PUSH
83187: LD_VAR 0 3
83191: ARRAY
83192: IN
83193: IFFALSE 83370
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83195: LD_ADDR_EXP 65
83199: PUSH
83200: LD_EXP 65
83204: PPUSH
83205: LD_VAR 0 3
83209: PPUSH
83210: LD_EXP 65
83214: PUSH
83215: LD_VAR 0 3
83219: ARRAY
83220: PUSH
83221: LD_VAR 0 1
83225: DIFF
83226: PPUSH
83227: CALL_OW 1
83231: ST_TO_ADDR
// if building in mc_lab [ i ] then
83232: LD_VAR 0 1
83236: PUSH
83237: LD_EXP 91
83241: PUSH
83242: LD_VAR 0 3
83246: ARRAY
83247: IN
83248: IFFALSE 83303
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83250: LD_ADDR_EXP 92
83254: PUSH
83255: LD_EXP 92
83259: PPUSH
83260: LD_VAR 0 3
83264: PPUSH
83265: LD_EXP 92
83269: PUSH
83270: LD_VAR 0 3
83274: ARRAY
83275: PPUSH
83276: LD_INT 1
83278: PPUSH
83279: LD_EXP 92
83283: PUSH
83284: LD_VAR 0 3
83288: ARRAY
83289: PPUSH
83290: LD_INT 0
83292: PPUSH
83293: CALL 20083 0 4
83297: PPUSH
83298: CALL_OW 1
83302: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83303: LD_VAR 0 1
83307: PUSH
83308: LD_EXP 58
83312: PUSH
83313: LD_VAR 0 3
83317: ARRAY
83318: IN
83319: NOT
83320: IFFALSE 83366
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83322: LD_ADDR_EXP 58
83326: PUSH
83327: LD_EXP 58
83331: PPUSH
83332: LD_VAR 0 3
83336: PUSH
83337: LD_EXP 58
83341: PUSH
83342: LD_VAR 0 3
83346: ARRAY
83347: PUSH
83348: LD_INT 1
83350: PLUS
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PPUSH
83356: LD_VAR 0 1
83360: PPUSH
83361: CALL 20665 0 3
83365: ST_TO_ADDR
// exit ;
83366: POP
83367: POP
83368: GO 83374
// end ; end ;
83370: GO 83174
83372: POP
83373: POP
// end ;
83374: LD_VAR 0 2
83378: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83379: LD_INT 0
83381: PPUSH
83382: PPUSH
83383: PPUSH
83384: PPUSH
83385: PPUSH
83386: PPUSH
83387: PPUSH
// if not mc_bases or not skirmish then
83388: LD_EXP 58
83392: NOT
83393: PUSH
83394: LD_EXP 56
83398: NOT
83399: OR
83400: IFFALSE 83404
// exit ;
83402: GO 84065
// for i = 1 to mc_bases do
83404: LD_ADDR_VAR 0 3
83408: PUSH
83409: DOUBLE
83410: LD_INT 1
83412: DEC
83413: ST_TO_ADDR
83414: LD_EXP 58
83418: PUSH
83419: FOR_TO
83420: IFFALSE 84063
// begin if building in mc_construct_list [ i ] then
83422: LD_VAR 0 1
83426: PUSH
83427: LD_EXP 65
83431: PUSH
83432: LD_VAR 0 3
83436: ARRAY
83437: IN
83438: IFFALSE 84061
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83440: LD_ADDR_EXP 65
83444: PUSH
83445: LD_EXP 65
83449: PPUSH
83450: LD_VAR 0 3
83454: PPUSH
83455: LD_EXP 65
83459: PUSH
83460: LD_VAR 0 3
83464: ARRAY
83465: PUSH
83466: LD_VAR 0 1
83470: DIFF
83471: PPUSH
83472: CALL_OW 1
83476: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83477: LD_ADDR_EXP 58
83481: PUSH
83482: LD_EXP 58
83486: PPUSH
83487: LD_VAR 0 3
83491: PUSH
83492: LD_EXP 58
83496: PUSH
83497: LD_VAR 0 3
83501: ARRAY
83502: PUSH
83503: LD_INT 1
83505: PLUS
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PPUSH
83511: LD_VAR 0 1
83515: PPUSH
83516: CALL 20665 0 3
83520: ST_TO_ADDR
// btype := GetBType ( building ) ;
83521: LD_ADDR_VAR 0 5
83525: PUSH
83526: LD_VAR 0 1
83530: PPUSH
83531: CALL_OW 266
83535: ST_TO_ADDR
// side := GetSide ( building ) ;
83536: LD_ADDR_VAR 0 8
83540: PUSH
83541: LD_VAR 0 1
83545: PPUSH
83546: CALL_OW 255
83550: ST_TO_ADDR
// if btype = b_lab then
83551: LD_VAR 0 5
83555: PUSH
83556: LD_INT 6
83558: EQUAL
83559: IFFALSE 83609
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83561: LD_ADDR_EXP 91
83565: PUSH
83566: LD_EXP 91
83570: PPUSH
83571: LD_VAR 0 3
83575: PUSH
83576: LD_EXP 91
83580: PUSH
83581: LD_VAR 0 3
83585: ARRAY
83586: PUSH
83587: LD_INT 1
83589: PLUS
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: PPUSH
83595: LD_VAR 0 1
83599: PPUSH
83600: CALL 20665 0 3
83604: ST_TO_ADDR
// exit ;
83605: POP
83606: POP
83607: GO 84065
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83609: LD_VAR 0 5
83613: PUSH
83614: LD_INT 0
83616: PUSH
83617: LD_INT 2
83619: PUSH
83620: LD_INT 4
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: LIST
83627: IN
83628: IFFALSE 83752
// begin if btype = b_armoury then
83630: LD_VAR 0 5
83634: PUSH
83635: LD_INT 4
83637: EQUAL
83638: IFFALSE 83648
// btype := b_barracks ;
83640: LD_ADDR_VAR 0 5
83644: PUSH
83645: LD_INT 5
83647: ST_TO_ADDR
// if btype = b_depot then
83648: LD_VAR 0 5
83652: PUSH
83653: LD_INT 0
83655: EQUAL
83656: IFFALSE 83666
// btype := b_warehouse ;
83658: LD_ADDR_VAR 0 5
83662: PUSH
83663: LD_INT 1
83665: ST_TO_ADDR
// if btype = b_workshop then
83666: LD_VAR 0 5
83670: PUSH
83671: LD_INT 2
83673: EQUAL
83674: IFFALSE 83684
// btype := b_factory ;
83676: LD_ADDR_VAR 0 5
83680: PUSH
83681: LD_INT 3
83683: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83684: LD_VAR 0 5
83688: PPUSH
83689: LD_VAR 0 8
83693: PPUSH
83694: CALL_OW 323
83698: PUSH
83699: LD_INT 1
83701: EQUAL
83702: IFFALSE 83748
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83704: LD_ADDR_EXP 90
83708: PUSH
83709: LD_EXP 90
83713: PPUSH
83714: LD_VAR 0 3
83718: PUSH
83719: LD_EXP 90
83723: PUSH
83724: LD_VAR 0 3
83728: ARRAY
83729: PUSH
83730: LD_INT 1
83732: PLUS
83733: PUSH
83734: EMPTY
83735: LIST
83736: LIST
83737: PPUSH
83738: LD_VAR 0 1
83742: PPUSH
83743: CALL 20665 0 3
83747: ST_TO_ADDR
// exit ;
83748: POP
83749: POP
83750: GO 84065
// end ; if btype in [ b_bunker , b_turret ] then
83752: LD_VAR 0 5
83756: PUSH
83757: LD_INT 32
83759: PUSH
83760: LD_INT 33
83762: PUSH
83763: EMPTY
83764: LIST
83765: LIST
83766: IN
83767: IFFALSE 84057
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83769: LD_ADDR_EXP 66
83773: PUSH
83774: LD_EXP 66
83778: PPUSH
83779: LD_VAR 0 3
83783: PUSH
83784: LD_EXP 66
83788: PUSH
83789: LD_VAR 0 3
83793: ARRAY
83794: PUSH
83795: LD_INT 1
83797: PLUS
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PPUSH
83803: LD_VAR 0 1
83807: PPUSH
83808: CALL 20665 0 3
83812: ST_TO_ADDR
// if btype = b_bunker then
83813: LD_VAR 0 5
83817: PUSH
83818: LD_INT 32
83820: EQUAL
83821: IFFALSE 84057
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83823: LD_ADDR_EXP 67
83827: PUSH
83828: LD_EXP 67
83832: PPUSH
83833: LD_VAR 0 3
83837: PUSH
83838: LD_EXP 67
83842: PUSH
83843: LD_VAR 0 3
83847: ARRAY
83848: PUSH
83849: LD_INT 1
83851: PLUS
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PPUSH
83857: LD_VAR 0 1
83861: PPUSH
83862: CALL 20665 0 3
83866: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83867: LD_ADDR_VAR 0 6
83871: PUSH
83872: LD_EXP 58
83876: PUSH
83877: LD_VAR 0 3
83881: ARRAY
83882: PPUSH
83883: LD_INT 25
83885: PUSH
83886: LD_INT 1
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 3
83895: PUSH
83896: LD_INT 54
83898: PUSH
83899: EMPTY
83900: LIST
83901: PUSH
83902: EMPTY
83903: LIST
83904: LIST
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: PPUSH
83910: CALL_OW 72
83914: ST_TO_ADDR
// if tmp then
83915: LD_VAR 0 6
83919: IFFALSE 83925
// exit ;
83921: POP
83922: POP
83923: GO 84065
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83925: LD_ADDR_VAR 0 6
83929: PUSH
83930: LD_EXP 58
83934: PUSH
83935: LD_VAR 0 3
83939: ARRAY
83940: PPUSH
83941: LD_INT 2
83943: PUSH
83944: LD_INT 30
83946: PUSH
83947: LD_INT 4
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: LD_INT 30
83956: PUSH
83957: LD_INT 5
83959: PUSH
83960: EMPTY
83961: LIST
83962: LIST
83963: PUSH
83964: EMPTY
83965: LIST
83966: LIST
83967: LIST
83968: PPUSH
83969: CALL_OW 72
83973: ST_TO_ADDR
// if not tmp then
83974: LD_VAR 0 6
83978: NOT
83979: IFFALSE 83985
// exit ;
83981: POP
83982: POP
83983: GO 84065
// for j in tmp do
83985: LD_ADDR_VAR 0 4
83989: PUSH
83990: LD_VAR 0 6
83994: PUSH
83995: FOR_IN
83996: IFFALSE 84055
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83998: LD_ADDR_VAR 0 7
84002: PUSH
84003: LD_VAR 0 4
84007: PPUSH
84008: CALL_OW 313
84012: PPUSH
84013: LD_INT 25
84015: PUSH
84016: LD_INT 1
84018: PUSH
84019: EMPTY
84020: LIST
84021: LIST
84022: PPUSH
84023: CALL_OW 72
84027: ST_TO_ADDR
// if units then
84028: LD_VAR 0 7
84032: IFFALSE 84053
// begin ComExitBuilding ( units [ 1 ] ) ;
84034: LD_VAR 0 7
84038: PUSH
84039: LD_INT 1
84041: ARRAY
84042: PPUSH
84043: CALL_OW 122
// exit ;
84047: POP
84048: POP
84049: POP
84050: POP
84051: GO 84065
// end ; end ;
84053: GO 83995
84055: POP
84056: POP
// end ; end ; exit ;
84057: POP
84058: POP
84059: GO 84065
// end ; end ;
84061: GO 83419
84063: POP
84064: POP
// end ;
84065: LD_VAR 0 2
84069: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84070: LD_INT 0
84072: PPUSH
84073: PPUSH
84074: PPUSH
84075: PPUSH
84076: PPUSH
84077: PPUSH
84078: PPUSH
// if not mc_bases or not skirmish then
84079: LD_EXP 58
84083: NOT
84084: PUSH
84085: LD_EXP 56
84089: NOT
84090: OR
84091: IFFALSE 84095
// exit ;
84093: GO 84326
// btype := GetBType ( building ) ;
84095: LD_ADDR_VAR 0 6
84099: PUSH
84100: LD_VAR 0 1
84104: PPUSH
84105: CALL_OW 266
84109: ST_TO_ADDR
// x := GetX ( building ) ;
84110: LD_ADDR_VAR 0 7
84114: PUSH
84115: LD_VAR 0 1
84119: PPUSH
84120: CALL_OW 250
84124: ST_TO_ADDR
// y := GetY ( building ) ;
84125: LD_ADDR_VAR 0 8
84129: PUSH
84130: LD_VAR 0 1
84134: PPUSH
84135: CALL_OW 251
84139: ST_TO_ADDR
// d := GetDir ( building ) ;
84140: LD_ADDR_VAR 0 9
84144: PUSH
84145: LD_VAR 0 1
84149: PPUSH
84150: CALL_OW 254
84154: ST_TO_ADDR
// for i = 1 to mc_bases do
84155: LD_ADDR_VAR 0 4
84159: PUSH
84160: DOUBLE
84161: LD_INT 1
84163: DEC
84164: ST_TO_ADDR
84165: LD_EXP 58
84169: PUSH
84170: FOR_TO
84171: IFFALSE 84324
// begin if not mc_build_list [ i ] then
84173: LD_EXP 63
84177: PUSH
84178: LD_VAR 0 4
84182: ARRAY
84183: NOT
84184: IFFALSE 84188
// continue ;
84186: GO 84170
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
84188: LD_VAR 0 6
84192: PUSH
84193: LD_VAR 0 7
84197: PUSH
84198: LD_VAR 0 8
84202: PUSH
84203: LD_VAR 0 9
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: PPUSH
84214: LD_EXP 63
84218: PUSH
84219: LD_VAR 0 4
84223: ARRAY
84224: PUSH
84225: LD_INT 1
84227: ARRAY
84228: PPUSH
84229: CALL 26834 0 2
84233: IFFALSE 84322
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
84235: LD_ADDR_EXP 63
84239: PUSH
84240: LD_EXP 63
84244: PPUSH
84245: LD_VAR 0 4
84249: PPUSH
84250: LD_EXP 63
84254: PUSH
84255: LD_VAR 0 4
84259: ARRAY
84260: PPUSH
84261: LD_INT 1
84263: PPUSH
84264: CALL_OW 3
84268: PPUSH
84269: CALL_OW 1
84273: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84274: LD_ADDR_EXP 65
84278: PUSH
84279: LD_EXP 65
84283: PPUSH
84284: LD_VAR 0 4
84288: PUSH
84289: LD_EXP 65
84293: PUSH
84294: LD_VAR 0 4
84298: ARRAY
84299: PUSH
84300: LD_INT 1
84302: PLUS
84303: PUSH
84304: EMPTY
84305: LIST
84306: LIST
84307: PPUSH
84308: LD_VAR 0 1
84312: PPUSH
84313: CALL 20665 0 3
84317: ST_TO_ADDR
// exit ;
84318: POP
84319: POP
84320: GO 84326
// end ; end ;
84322: GO 84170
84324: POP
84325: POP
// end ;
84326: LD_VAR 0 3
84330: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84331: LD_INT 0
84333: PPUSH
84334: PPUSH
84335: PPUSH
// if not mc_bases or not skirmish then
84336: LD_EXP 58
84340: NOT
84341: PUSH
84342: LD_EXP 56
84346: NOT
84347: OR
84348: IFFALSE 84352
// exit ;
84350: GO 84542
// for i = 1 to mc_bases do
84352: LD_ADDR_VAR 0 4
84356: PUSH
84357: DOUBLE
84358: LD_INT 1
84360: DEC
84361: ST_TO_ADDR
84362: LD_EXP 58
84366: PUSH
84367: FOR_TO
84368: IFFALSE 84455
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84370: LD_VAR 0 1
84374: PUSH
84375: LD_EXP 66
84379: PUSH
84380: LD_VAR 0 4
84384: ARRAY
84385: IN
84386: PUSH
84387: LD_VAR 0 1
84391: PUSH
84392: LD_EXP 67
84396: PUSH
84397: LD_VAR 0 4
84401: ARRAY
84402: IN
84403: NOT
84404: AND
84405: IFFALSE 84453
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84407: LD_ADDR_EXP 67
84411: PUSH
84412: LD_EXP 67
84416: PPUSH
84417: LD_VAR 0 4
84421: PUSH
84422: LD_EXP 67
84426: PUSH
84427: LD_VAR 0 4
84431: ARRAY
84432: PUSH
84433: LD_INT 1
84435: PLUS
84436: PUSH
84437: EMPTY
84438: LIST
84439: LIST
84440: PPUSH
84441: LD_VAR 0 1
84445: PPUSH
84446: CALL 20665 0 3
84450: ST_TO_ADDR
// break ;
84451: GO 84455
// end ; end ;
84453: GO 84367
84455: POP
84456: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84457: LD_VAR 0 1
84461: PPUSH
84462: CALL_OW 257
84466: PUSH
84467: LD_EXP 84
84471: IN
84472: PUSH
84473: LD_VAR 0 1
84477: PPUSH
84478: CALL_OW 266
84482: PUSH
84483: LD_INT 5
84485: EQUAL
84486: AND
84487: PUSH
84488: LD_VAR 0 2
84492: PPUSH
84493: CALL_OW 110
84497: PUSH
84498: LD_INT 18
84500: NONEQUAL
84501: AND
84502: IFFALSE 84542
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84504: LD_VAR 0 2
84508: PPUSH
84509: CALL_OW 257
84513: PUSH
84514: LD_INT 5
84516: PUSH
84517: LD_INT 8
84519: PUSH
84520: LD_INT 9
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: LIST
84527: IN
84528: IFFALSE 84542
// SetClass ( unit , 1 ) ;
84530: LD_VAR 0 2
84534: PPUSH
84535: LD_INT 1
84537: PPUSH
84538: CALL_OW 336
// end ;
84542: LD_VAR 0 3
84546: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84547: LD_INT 0
84549: PPUSH
84550: PPUSH
// if not mc_bases or not skirmish then
84551: LD_EXP 58
84555: NOT
84556: PUSH
84557: LD_EXP 56
84561: NOT
84562: OR
84563: IFFALSE 84567
// exit ;
84565: GO 84683
// if GetLives ( abandoned_vehicle ) > 250 then
84567: LD_VAR 0 2
84571: PPUSH
84572: CALL_OW 256
84576: PUSH
84577: LD_INT 250
84579: GREATER
84580: IFFALSE 84584
// exit ;
84582: GO 84683
// for i = 1 to mc_bases do
84584: LD_ADDR_VAR 0 6
84588: PUSH
84589: DOUBLE
84590: LD_INT 1
84592: DEC
84593: ST_TO_ADDR
84594: LD_EXP 58
84598: PUSH
84599: FOR_TO
84600: IFFALSE 84681
// begin if driver in mc_bases [ i ] then
84602: LD_VAR 0 1
84606: PUSH
84607: LD_EXP 58
84611: PUSH
84612: LD_VAR 0 6
84616: ARRAY
84617: IN
84618: IFFALSE 84679
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84620: LD_VAR 0 1
84624: PPUSH
84625: LD_EXP 58
84629: PUSH
84630: LD_VAR 0 6
84634: ARRAY
84635: PPUSH
84636: LD_INT 2
84638: PUSH
84639: LD_INT 30
84641: PUSH
84642: LD_INT 0
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 30
84651: PUSH
84652: LD_INT 1
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: LIST
84663: PPUSH
84664: CALL_OW 72
84668: PUSH
84669: LD_INT 1
84671: ARRAY
84672: PPUSH
84673: CALL_OW 112
// break ;
84677: GO 84681
// end ; end ;
84679: GO 84599
84681: POP
84682: POP
// end ; end_of_file
84683: LD_VAR 0 5
84687: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
84688: GO 84690
84690: DISABLE
// begin ru_radar := 98 ;
84691: LD_ADDR_EXP 101
84695: PUSH
84696: LD_INT 98
84698: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84699: LD_ADDR_EXP 102
84703: PUSH
84704: LD_INT 89
84706: ST_TO_ADDR
// us_hack := 99 ;
84707: LD_ADDR_EXP 103
84711: PUSH
84712: LD_INT 99
84714: ST_TO_ADDR
// us_artillery := 97 ;
84715: LD_ADDR_EXP 104
84719: PUSH
84720: LD_INT 97
84722: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84723: LD_ADDR_EXP 105
84727: PUSH
84728: LD_INT 91
84730: ST_TO_ADDR
// end ;
84731: END
