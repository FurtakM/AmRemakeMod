// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 55803 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 47938 0 9
// PrepareArabian ;
 140: CALL 3430 0 0
// PrepareRussian ;
 144: CALL 2554 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 56950 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6627 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 77428 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 77854 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 78307 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 78576 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 77794 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 78483 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 77854 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 78307 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 78576 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 77638 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 77794 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := 1 ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 1
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13515 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13515 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13515 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13515 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13515 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13515 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13515 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13515 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13515 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13515 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornel
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13515 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13515 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13515 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13515 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13515 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13515 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13515 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20148 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 63 , 9 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 63
1567: PPUSH
1568: LD_INT 9
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20148 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 2
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 4 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 60
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
// uc_side := 6 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 6
1696: ST_TO_ADDR
// uc_nation := 3 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// InitHc ;
1705: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1709: LD_ADDR_EXP 31
1713: PUSH
1714: LD_STRING Gossudarov
1716: PPUSH
1717: CALL_OW 25
1721: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1722: LD_ADDR_EXP 32
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: CALL_OW 25
1734: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1735: LD_ADDR_EXP 33
1739: PUSH
1740: LD_STRING Titov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Oblukov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1761: LD_ADDR_EXP 35
1765: PUSH
1766: LD_STRING Dolgov
1768: PPUSH
1769: CALL_OW 25
1773: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1774: LD_ADDR_EXP 36
1778: PUSH
1779: LD_STRING Petrosyan
1781: PPUSH
1782: CALL_OW 25
1786: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1787: LD_ADDR_EXP 37
1791: PUSH
1792: LD_STRING Scholtze
1794: PPUSH
1795: CALL_OW 25
1799: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1800: LD_ADDR_EXP 39
1804: PUSH
1805: LD_STRING Kapitsova
1807: PPUSH
1808: CALL_OW 25
1812: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_EXP 31
1822: PUSH
1823: LD_EXP 32
1827: PUSH
1828: LD_EXP 33
1832: PUSH
1833: LD_EXP 38
1837: PUSH
1838: LD_EXP 35
1842: PUSH
1843: LD_EXP 36
1847: PUSH
1848: LD_EXP 37
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1898
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1881: LD_VAR 0 3
1885: PPUSH
1886: LD_INT 14
1888: PPUSH
1889: LD_INT 0
1891: PPUSH
1892: CALL_OW 49
1896: GO 1878
1898: POP
1899: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1900: LD_VAR 0 2
1904: PPUSH
1905: LD_EXP 3
1909: PPUSH
1910: CALL_OW 250
1914: PPUSH
1915: LD_EXP 3
1919: PPUSH
1920: CALL_OW 251
1924: PPUSH
1925: CALL_OW 111
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareBelkov ; begin
1934: LD_INT 0
1936: PPUSH
// uc_side := 4 ;
1937: LD_ADDR_OWVAR 20
1941: PUSH
1942: LD_INT 4
1944: ST_TO_ADDR
// uc_nation := 3 ;
1945: LD_ADDR_OWVAR 21
1949: PUSH
1950: LD_INT 3
1952: ST_TO_ADDR
// InitHc ;
1953: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1957: LD_ADDR_EXP 46
1961: PUSH
1962: LD_STRING Belkov
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1970: LD_EXP 46
1974: PPUSH
1975: LD_INT 14
1977: PPUSH
1978: LD_INT 0
1980: PPUSH
1981: CALL_OW 49
// end ;
1985: LD_VAR 0 1
1989: RET
// export function PrepareGnyevko ; begin
1990: LD_INT 0
1992: PPUSH
// uc_side := 4 ;
1993: LD_ADDR_OWVAR 20
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// uc_nation := 3 ;
2001: LD_ADDR_OWVAR 21
2005: PUSH
2006: LD_INT 3
2008: ST_TO_ADDR
// InitHc ;
2009: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2013: LD_ADDR_EXP 47
2017: PUSH
2018: LD_STRING Gnyevko
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2026: LD_EXP 47
2030: PPUSH
2031: LD_INT 14
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 49
// end ;
2041: LD_VAR 0 1
2045: RET
// export function PrepareBurlak ; var i , tmp ; begin
2046: LD_INT 0
2048: PPUSH
2049: PPUSH
2050: PPUSH
// uc_side := 4 ;
2051: LD_ADDR_OWVAR 20
2055: PUSH
2056: LD_INT 4
2058: ST_TO_ADDR
// uc_nation := 3 ;
2059: LD_ADDR_OWVAR 21
2063: PUSH
2064: LD_INT 3
2066: ST_TO_ADDR
// InitHc ;
2067: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2071: LD_ADDR_EXP 45
2075: PUSH
2076: LD_STRING Burlak
2078: PPUSH
2079: CALL_OW 25
2083: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2084: LD_INT 24
2086: PUSH
2087: LD_INT 23
2089: PUSH
2090: LD_INT 22
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_OWVAR 67
2102: ARRAY
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: LD_INT 45
2112: PUSH
2113: LD_INT 44
2115: PUSH
2116: LD_INT 43
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: LIST
2123: PUSH
2124: LD_OWVAR 67
2128: ARRAY
2129: PPUSH
2130: LD_INT 0
2132: PPUSH
2133: CALL 20148 0 5
// Masha := CreateVehicle ;
2137: LD_ADDR_EXP 48
2141: PUSH
2142: CALL_OW 45
2146: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2147: LD_EXP 48
2151: PUSH
2152: LD_EXP 45
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PPUSH
2161: LD_INT 499
2163: PPUSH
2164: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2168: LD_EXP 48
2172: PPUSH
2173: LD_INT 3
2175: PPUSH
2176: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2180: LD_EXP 48
2184: PPUSH
2185: LD_INT 1
2187: PPUSH
2188: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2192: LD_EXP 48
2196: PPUSH
2197: LD_INT 18
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2207: LD_EXP 45
2211: PPUSH
2212: LD_INT 125
2214: PPUSH
2215: LD_INT 1
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2225: LD_EXP 45
2229: PPUSH
2230: LD_EXP 48
2234: PPUSH
2235: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2239: LD_INT 10
2241: PPUSH
2242: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2246: LD_EXP 48
2250: PPUSH
2251: LD_INT 110
2253: PPUSH
2254: LD_INT 10
2256: PPUSH
2257: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2261: LD_ADDR_EXP 41
2265: PUSH
2266: LD_STRING Petrovova
2268: PPUSH
2269: CALL_OW 25
2273: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2274: LD_ADDR_EXP 43
2278: PUSH
2279: LD_STRING Kuzmov
2281: PPUSH
2282: CALL_OW 25
2286: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2287: LD_ADDR_EXP 42
2291: PUSH
2292: LD_STRING Kovalyuk
2294: PPUSH
2295: CALL_OW 25
2299: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2300: LD_ADDR_EXP 40
2304: PUSH
2305: LD_STRING Lipshchin
2307: PPUSH
2308: CALL_OW 25
2312: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2313: LD_ADDR_EXP 44
2317: PUSH
2318: LD_STRING Karamazov
2320: PPUSH
2321: CALL_OW 25
2325: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: LD_EXP 41
2335: PUSH
2336: LD_EXP 43
2340: PUSH
2341: LD_EXP 42
2345: PUSH
2346: LD_EXP 40
2350: PUSH
2351: LD_EXP 44
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: ST_TO_ADDR
// for i in tmp do
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_IN
2374: IFFALSE 2413
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 399
2383: PPUSH
2384: LD_INT 799
2386: PPUSH
2387: CALL_OW 12
2391: PPUSH
2392: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2396: LD_VAR 0 2
2400: PPUSH
2401: LD_INT 19
2403: PPUSH
2404: LD_INT 0
2406: PPUSH
2407: CALL_OW 49
// end ;
2411: GO 2373
2413: POP
2414: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2415: LD_VAR 0 3
2419: PPUSH
2420: LD_INT 116
2422: PPUSH
2423: LD_INT 8
2425: PPUSH
2426: CALL_OW 111
// AddComHold ( tmp ) ;
2430: LD_VAR 0 3
2434: PPUSH
2435: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2439: LD_ADDR_VAR 0 2
2443: PUSH
2444: LD_VAR 0 3
2448: PPUSH
2449: LD_INT 25
2451: PUSH
2452: LD_INT 1
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PPUSH
2459: CALL_OW 72
2463: PUSH
2464: FOR_IN
2465: IFFALSE 2505
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2467: LD_VAR 0 2
2471: PPUSH
2472: LD_INT 20
2474: PPUSH
2475: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2479: LD_VAR 0 2
2483: PPUSH
2484: LD_INT 147
2486: PPUSH
2487: LD_INT 45
2489: PPUSH
2490: CALL_OW 178
// AddComCrawl ( i ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: CALL_OW 197
// end ;
2503: GO 2464
2505: POP
2506: POP
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) ;
2514: LD_EXP 48
2518: PPUSH
2519: LD_INT 110
2521: PPUSH
2522: LD_INT 10
2524: PPUSH
2525: CALL_OW 307
2529: IFFALSE 2507
// ComStop ( Burlak ) ;
2531: LD_EXP 45
2535: PPUSH
2536: CALL_OW 141
// AddComHold ( Burlak ) ;
2540: LD_EXP 45
2544: PPUSH
2545: CALL_OW 200
// end ; end_of_file
2549: LD_VAR 0 1
2553: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// uc_side := 3 ;
2560: LD_ADDR_OWVAR 20
2564: PUSH
2565: LD_INT 3
2567: ST_TO_ADDR
// uc_nation := 3 ;
2568: LD_ADDR_OWVAR 21
2572: PUSH
2573: LD_INT 3
2575: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2576: LD_ADDR_EXP 49
2580: PUSH
2581: LD_INT 47
2583: PPUSH
2584: LD_INT 4
2586: PPUSH
2587: LD_STRING 
2589: PPUSH
2590: LD_INT 7
2592: PUSH
2593: LD_INT 8
2595: PUSH
2596: LD_INT 9
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: PUSH
2604: LD_OWVAR 67
2608: ARRAY
2609: PPUSH
2610: LD_INT 10000
2612: PUSH
2613: LD_INT 3000
2615: PUSH
2616: LD_INT 300
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: PPUSH
2624: LD_INT 9
2626: PUSH
2627: LD_INT 5
2629: PUSH
2630: LD_INT 6
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: PPUSH
2642: CALL 23557 0 6
2646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2647: LD_ADDR_EXP 58
2651: PUSH
2652: LD_EXP 58
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: LD_EXP 49
2664: PPUSH
2665: CALL_OW 1
2669: ST_TO_ADDR
// tmp := [ ] ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: EMPTY
2676: ST_TO_ADDR
// for i = 1 to 4 do
2677: LD_ADDR_VAR 0 2
2681: PUSH
2682: DOUBLE
2683: LD_INT 1
2685: DEC
2686: ST_TO_ADDR
2687: LD_INT 4
2689: PUSH
2690: FOR_TO
2691: IFFALSE 2784
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2693: LD_INT 22
2695: PPUSH
2696: LD_INT 3
2698: PPUSH
2699: LD_INT 3
2701: PPUSH
2702: LD_INT 43
2704: PUSH
2705: LD_INT 45
2707: PUSH
2708: LD_INT 45
2710: PUSH
2711: LD_INT 44
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_INT 4
2727: MOD
2728: PUSH
2729: LD_INT 1
2731: PLUS
2732: ARRAY
2733: PPUSH
2734: LD_INT 100
2736: PPUSH
2737: CALL 20148 0 5
// veh := CreateVehicle ;
2741: LD_ADDR_VAR 0 3
2745: PUSH
2746: CALL_OW 45
2750: ST_TO_ADDR
// tmp := tmp ^ veh ;
2751: LD_ADDR_VAR 0 4
2755: PUSH
2756: LD_VAR 0 4
2760: PUSH
2761: LD_VAR 0 3
2765: ADD
2766: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 2
2774: PPUSH
2775: LD_INT 0
2777: PPUSH
2778: CALL_OW 49
// end ;
2782: GO 2690
2784: POP
2785: POP
// russian_guard := tmp ;
2786: LD_ADDR_EXP 50
2790: PUSH
2791: LD_VAR 0 4
2795: ST_TO_ADDR
// end ;
2796: LD_VAR 0 1
2800: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2801: LD_INT 47
2803: PPUSH
2804: CALL_OW 302
2808: PUSH
2809: LD_EXP 6
2813: AND
2814: IFFALSE 3427
2816: GO 2818
2818: DISABLE
2819: LD_INT 0
2821: PPUSH
2822: PPUSH
2823: PPUSH
2824: PPUSH
2825: PPUSH
2826: PPUSH
// begin enable ;
2827: ENABLE
// base := 2 ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 2
2835: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2836: LD_ADDR_VAR 0 4
2840: PUSH
2841: LD_INT 0
2843: PUSH
2844: LD_INT 0
2846: PUSH
2847: LD_INT 0
2849: PUSH
2850: LD_INT 0
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 0
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: LD_INT 0
2864: PUSH
2865: LD_INT 1
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2883: LD_ADDR_VAR 0 3
2887: PUSH
2888: LD_INT 22
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: LD_INT 45
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: LD_INT 21
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: LD_INT 3
2914: PUSH
2915: LD_INT 45
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: PUSH
2924: LD_INT 22
2926: PUSH
2927: LD_INT 1
2929: PUSH
2930: LD_INT 3
2932: PUSH
2933: LD_INT 45
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 23
2944: PUSH
2945: LD_INT 1
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: LD_INT 46
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
2966: LD_ADDR_VAR 0 1
2970: PUSH
2971: DOUBLE
2972: LD_INT 1
2974: DEC
2975: ST_TO_ADDR
2976: LD_OWVAR 67
2980: PUSH
2981: LD_OWVAR 1
2985: PUSH
2986: LD_INT 21000
2988: DIV
2989: PLUS
2990: PUSH
2991: FOR_TO
2992: IFFALSE 3080
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_VAR 0 3
3003: PPUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_INT 1
3011: PLUS
3012: PPUSH
3013: LD_INT 23
3015: PUSH
3016: LD_INT 24
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 1
3025: PPUSH
3026: LD_INT 2
3028: PPUSH
3029: CALL_OW 12
3033: ARRAY
3034: PUSH
3035: LD_INT 1
3037: PUSH
3038: LD_INT 3
3040: PUSH
3041: LD_INT 46
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 45
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 3
3060: PPUSH
3061: CALL_OW 12
3065: ARRAY
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 2
3077: ST_TO_ADDR
3078: GO 2991
3080: POP
3081: POP
// MC_SetProduceList ( base , tmp ) ;
3082: LD_VAR 0 2
3086: PPUSH
3087: LD_VAR 0 3
3091: PPUSH
3092: CALL 77746 0 2
// repeat wait ( 0 0$1 ) ;
3096: LD_INT 35
3098: PPUSH
3099: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
3103: LD_VAR 0 2
3107: PPUSH
3108: CALL 78200 0 1
3112: PUSH
3113: LD_INT 0
3115: EQUAL
3116: IFFALSE 3096
// wait ( 0 0$20 ) ;
3118: LD_INT 700
3120: PPUSH
3121: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3125: LD_ADDR_VAR 0 5
3129: PUSH
3130: LD_INT 71
3132: PUSH
3133: LD_INT 19
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: PUSH
3140: LD_INT 91
3142: PUSH
3143: LD_INT 67
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 52
3152: PUSH
3153: LD_INT 44
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: LD_INT 68
3162: PUSH
3163: LD_INT 48
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ) ;
3176: LD_ADDR_VAR 0 6
3180: PUSH
3181: LD_EXP 77
3185: PUSH
3186: LD_VAR 0 2
3190: ARRAY
3191: PUSH
3192: LD_EXP 80
3196: PUSH
3197: LD_VAR 0 2
3201: ARRAY
3202: PUSH
3203: LD_EXP 77
3207: PUSH
3208: LD_VAR 0 2
3212: ARRAY
3213: PPUSH
3214: LD_INT 2
3216: PUSH
3217: LD_INT 34
3219: PUSH
3220: LD_INT 51
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 34
3229: PUSH
3230: LD_INT 52
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 72
3246: UNION
3247: DIFF
3248: ST_TO_ADDR
// if not attackers then
3249: LD_VAR 0 6
3253: NOT
3254: IFFALSE 3258
// exit ;
3256: GO 3427
// ru_attackers := attackers ;
3258: LD_ADDR_EXP 51
3262: PUSH
3263: LD_VAR 0 6
3267: ST_TO_ADDR
// for i = 1 to attackers do
3268: LD_ADDR_VAR 0 1
3272: PUSH
3273: DOUBLE
3274: LD_INT 1
3276: DEC
3277: ST_TO_ADDR
3278: LD_VAR 0 6
3282: PUSH
3283: FOR_TO
3284: IFFALSE 3361
// begin case i mod 3 of 0 :
3286: LD_VAR 0 1
3290: PUSH
3291: LD_INT 3
3293: MOD
3294: PUSH
3295: LD_INT 0
3297: DOUBLE
3298: EQUAL
3299: IFTRUE 3303
3301: GO 3306
3303: POP
// ; 1 :
3304: GO 3359
3306: LD_INT 1
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3332
3314: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3315: LD_VAR 0 1
3319: PPUSH
3320: LD_INT 32
3322: PPUSH
3323: LD_INT 49
3325: PPUSH
3326: CALL_OW 114
3330: GO 3359
3332: LD_INT 2
3334: DOUBLE
3335: EQUAL
3336: IFTRUE 3340
3338: GO 3358
3340: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3341: LD_VAR 0 1
3345: PPUSH
3346: LD_INT 117
3348: PPUSH
3349: LD_INT 107
3351: PPUSH
3352: CALL_OW 114
3356: GO 3359
3358: POP
// end ;
3359: GO 3283
3361: POP
3362: POP
// repeat wait ( 0 0$1 ) ;
3363: LD_INT 35
3365: PPUSH
3366: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3370: LD_VAR 0 6
3374: PPUSH
3375: LD_INT 60
3377: PUSH
3378: EMPTY
3379: LIST
3380: PPUSH
3381: CALL_OW 72
3385: NOT
3386: IFFALSE 3363
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3388: LD_VAR 0 2
3392: PPUSH
3393: LD_VAR 0 6
3397: PPUSH
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_VAR 0 4
3407: PPUSH
3408: CALL 78037 0 4
// if not first_attack then
3412: LD_EXP 7
3416: NOT
3417: IFFALSE 3427
// first_attack := true ;
3419: LD_ADDR_EXP 7
3423: PUSH
3424: LD_INT 1
3426: ST_TO_ADDR
// end ; end_of_file
3427: PPOPN 6
3429: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3430: LD_INT 0
3432: PPUSH
3433: PPUSH
3434: PPUSH
3435: PPUSH
3436: PPUSH
3437: PPUSH
3438: PPUSH
// uc_side := 2 ;
3439: LD_ADDR_OWVAR 20
3443: PUSH
3444: LD_INT 2
3446: ST_TO_ADDR
// uc_nation := 2 ;
3447: LD_ADDR_OWVAR 21
3451: PUSH
3452: LD_INT 2
3454: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3455: LD_ADDR_EXP 54
3459: PUSH
3460: LD_STRING Abdul
3462: PPUSH
3463: CALL_OW 25
3467: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3468: LD_EXP 54
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3480: LD_EXP 54
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: CALL_OW 52
// vc_chassis := 31 ;
3492: LD_ADDR_OWVAR 37
3496: PUSH
3497: LD_INT 31
3499: ST_TO_ADDR
// vc_control := control_rider ;
3500: LD_ADDR_OWVAR 38
3504: PUSH
3505: LD_INT 4
3507: ST_TO_ADDR
// mastodont := CreateVehicle ;
3508: LD_ADDR_EXP 55
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3518: LD_EXP 55
3522: PPUSH
3523: LD_INT 153
3525: PPUSH
3526: LD_INT 71
3528: PPUSH
3529: LD_INT 0
3531: PPUSH
3532: CALL_OW 48
// InitVc ;
3536: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3540: LD_ADDR_EXP 52
3544: PUSH
3545: LD_INT 1
3547: PPUSH
3548: LD_INT 3
3550: PPUSH
3551: LD_STRING 
3553: PPUSH
3554: LD_INT 7
3556: PUSH
3557: LD_INT 8
3559: PUSH
3560: LD_INT 9
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: PUSH
3568: LD_OWVAR 67
3572: ARRAY
3573: PPUSH
3574: LD_INT 5000
3576: PUSH
3577: LD_INT 1000
3579: PUSH
3580: LD_INT 300
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: PPUSH
3588: LD_INT 22
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 6
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PPUSH
3606: CALL 23557 0 6
3610: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3611: LD_ADDR_EXP 58
3615: PUSH
3616: LD_EXP 58
3620: PPUSH
3621: LD_INT 1
3623: PPUSH
3624: LD_EXP 52
3628: PPUSH
3629: CALL_OW 1
3633: ST_TO_ADDR
// tmp := [ ] ;
3634: LD_ADDR_VAR 0 4
3638: PUSH
3639: EMPTY
3640: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3641: LD_ADDR_OWVAR 37
3645: PUSH
3646: LD_INT 14
3648: ST_TO_ADDR
// vc_engine := engine_siberite ;
3649: LD_ADDR_OWVAR 39
3653: PUSH
3654: LD_INT 3
3656: ST_TO_ADDR
// vc_control := control_manual ;
3657: LD_ADDR_OWVAR 38
3661: PUSH
3662: LD_INT 1
3664: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3665: LD_ADDR_OWVAR 40
3669: PUSH
3670: LD_INT 31
3672: ST_TO_ADDR
// for i = 1 to 3 do
3673: LD_ADDR_VAR 0 2
3677: PUSH
3678: DOUBLE
3679: LD_INT 1
3681: DEC
3682: ST_TO_ADDR
3683: LD_INT 3
3685: PUSH
3686: FOR_TO
3687: IFFALSE 3931
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3689: LD_ADDR_VAR 0 5
3693: PUSH
3694: LD_INT 153
3696: PUSH
3697: LD_INT 71
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 155
3706: PUSH
3707: LD_INT 81
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_VAR 0 2
3722: PUSH
3723: LD_INT 2
3725: MOD
3726: PUSH
3727: LD_INT 1
3729: PLUS
3730: ARRAY
3731: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3732: LD_INT 0
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 7
3740: PUSH
3741: LD_INT 8
3743: PUSH
3744: LD_INT 9
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: PUSH
3752: LD_OWVAR 67
3756: ARRAY
3757: PPUSH
3758: CALL_OW 380
// un := CreateVehicle ;
3762: LD_ADDR_VAR 0 6
3766: PUSH
3767: CALL_OW 45
3771: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3772: LD_VAR 0 6
3776: PPUSH
3777: LD_INT 0
3779: PPUSH
3780: LD_INT 5
3782: PPUSH
3783: CALL_OW 12
3787: PPUSH
3788: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3792: LD_VAR 0 6
3796: PPUSH
3797: LD_VAR 0 5
3801: PUSH
3802: LD_INT 1
3804: ARRAY
3805: PPUSH
3806: LD_VAR 0 5
3810: PUSH
3811: LD_INT 2
3813: ARRAY
3814: PPUSH
3815: LD_INT 6
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 50
// un2 := CreateHuman ;
3825: LD_ADDR_VAR 0 7
3829: PUSH
3830: CALL_OW 44
3834: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3835: LD_VAR 0 7
3839: PPUSH
3840: LD_VAR 0 6
3844: PPUSH
3845: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3849: LD_ADDR_EXP 58
3853: PUSH
3854: LD_EXP 58
3858: PPUSH
3859: LD_INT 1
3861: PUSH
3862: LD_EXP 58
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PUSH
3871: LD_INT 1
3873: PLUS
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: LD_VAR 0 6
3883: PPUSH
3884: CALL 20270 0 3
3888: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3889: LD_ADDR_EXP 58
3893: PUSH
3894: LD_EXP 58
3898: PPUSH
3899: LD_INT 1
3901: PUSH
3902: LD_EXP 58
3906: PUSH
3907: LD_INT 1
3909: ARRAY
3910: PUSH
3911: LD_INT 1
3913: PLUS
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: PPUSH
3919: LD_VAR 0 7
3923: PPUSH
3924: CALL 20270 0 3
3928: ST_TO_ADDR
// end ;
3929: GO 3686
3931: POP
3932: POP
// for i = 1 to 5 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 5
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4040
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3949: LD_INT 14
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 25
3960: PUSH
3961: LD_INT 28
3963: PUSH
3964: LD_INT 28
3966: PUSH
3967: LD_INT 26
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: PUSH
3976: LD_VAR 0 2
3980: PUSH
3981: LD_INT 4
3983: MOD
3984: PUSH
3985: LD_INT 1
3987: PLUS
3988: ARRAY
3989: PPUSH
3990: LD_INT 100
3992: PPUSH
3993: CALL 20148 0 5
// veh := CreateVehicle ;
3997: LD_ADDR_VAR 0 3
4001: PUSH
4002: CALL_OW 45
4006: ST_TO_ADDR
// tmp := tmp ^ veh ;
4007: LD_ADDR_VAR 0 4
4011: PUSH
4012: LD_VAR 0 4
4016: PUSH
4017: LD_VAR 0 3
4021: ADD
4022: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4023: LD_VAR 0 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 49
// end ;
4038: GO 3946
4040: POP
4041: POP
// arabian_guard := tmp ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_VAR 0 4
4051: ST_TO_ADDR
// end ;
4052: LD_VAR 0 1
4056: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4057: LD_INT 22
4059: PUSH
4060: LD_INT 7
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 91
4069: PUSH
4070: LD_INT 1
4072: PUSH
4073: LD_INT 12
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: LIST
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PPUSH
4085: CALL_OW 69
4089: PUSH
4090: LD_EXP 55
4094: PPUSH
4095: CALL_OW 256
4099: PUSH
4100: LD_INT 990
4102: LESS
4103: OR
4104: PUSH
4105: LD_EXP 54
4109: PPUSH
4110: CALL_OW 256
4114: PUSH
4115: LD_INT 990
4117: LESS
4118: OR
4119: IFFALSE 4262
4121: GO 4123
4123: DISABLE
// begin if IsInUnit ( Abdul ) then
4124: LD_EXP 54
4128: PPUSH
4129: CALL_OW 310
4133: IFFALSE 4144
// ComExitBuilding ( Abdul ) ;
4135: LD_EXP 54
4139: PPUSH
4140: CALL_OW 122
// if Mastodont then
4144: LD_EXP 55
4148: IFFALSE 4165
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4150: LD_EXP 55
4154: PPUSH
4155: LD_INT 205
4157: PPUSH
4158: LD_INT 132
4160: PPUSH
4161: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4165: LD_EXP 54
4169: PPUSH
4170: LD_INT 205
4172: PPUSH
4173: LD_INT 132
4175: PPUSH
4176: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4187: LD_EXP 54
4191: PPUSH
4192: LD_INT 21
4194: PPUSH
4195: CALL_OW 308
4199: IFFALSE 4180
// RemoveUnit ( Abdul ) ;
4201: LD_EXP 54
4205: PPUSH
4206: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4210: LD_INT 35
4212: PPUSH
4213: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4217: LD_EXP 55
4221: PPUSH
4222: LD_INT 21
4224: PPUSH
4225: CALL_OW 308
4229: PUSH
4230: LD_EXP 55
4234: PPUSH
4235: CALL_OW 301
4239: OR
4240: IFFALSE 4210
// if IsOk ( Mastodont ) then
4242: LD_EXP 55
4246: PPUSH
4247: CALL_OW 302
4251: IFFALSE 4262
// RemoveUnit ( Mastodont ) ;
4253: LD_EXP 55
4257: PPUSH
4258: CALL_OW 64
// end ;
4262: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4263: LD_EXP 54
4267: PPUSH
4268: CALL_OW 301
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 2
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 2
4285: PUSH
4286: LD_INT 25
4288: PUSH
4289: LD_INT 1
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 25
4298: PUSH
4299: LD_INT 2
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 25
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 25
4318: PUSH
4319: LD_INT 4
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 25
4328: PUSH
4329: LD_INT 8
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL_OW 69
4352: PUSH
4353: LD_INT 16
4355: PUSH
4356: LD_INT 19
4358: PUSH
4359: LD_INT 22
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PUSH
4367: LD_OWVAR 67
4371: ARRAY
4372: LESS
4373: OR
4374: IFFALSE 5047
4376: GO 4378
4378: DISABLE
4379: LD_INT 0
4381: PPUSH
4382: PPUSH
4383: PPUSH
4384: PPUSH
4385: PPUSH
4386: PPUSH
// begin MC_Kill ( 1 ) ;
4387: LD_INT 1
4389: PPUSH
4390: CALL 56038 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4394: LD_ADDR_VAR 0 2
4398: PUSH
4399: LD_INT 22
4401: PUSH
4402: LD_INT 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 25
4414: PUSH
4415: LD_INT 1
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 25
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 25
4434: PUSH
4435: LD_INT 3
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 4
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 25
4454: PUSH
4455: LD_INT 8
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 69
4478: ST_TO_ADDR
// for i in tmp do
4479: LD_ADDR_VAR 0 5
4483: PUSH
4484: LD_VAR 0 2
4488: PUSH
4489: FOR_IN
4490: IFFALSE 4506
// SetTag ( i , 10 ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_INT 10
4499: PPUSH
4500: CALL_OW 109
4504: GO 4489
4506: POP
4507: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: LD_INT 22
4515: PUSH
4516: LD_INT 2
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 21
4525: PUSH
4526: LD_INT 1
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PPUSH
4537: CALL_OW 69
4541: PUSH
4542: LD_VAR 0 2
4546: DIFF
4547: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4548: LD_ADDR_VAR 0 1
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 2
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 21
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: LD_INT 24
4575: PUSH
4576: LD_INT 300
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4593: LD_ADDR_VAR 0 4
4597: PUSH
4598: LD_VAR 0 1
4602: PPUSH
4603: LD_INT 33
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: LD_INT 58
4615: PUSH
4616: EMPTY
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 72
4627: ST_TO_ADDR
// for i in tmp do
4628: LD_ADDR_VAR 0 5
4632: PUSH
4633: LD_VAR 0 2
4637: PUSH
4638: FOR_IN
4639: IFFALSE 4823
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4641: LD_VAR 0 5
4645: PUSH
4646: LD_INT 55
4648: PUSH
4649: EMPTY
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: IN
4657: IFFALSE 4676
// begin AddComMoveXY ( i , 209 , 132 ) ;
4659: LD_VAR 0 5
4663: PPUSH
4664: LD_INT 209
4666: PPUSH
4667: LD_INT 132
4669: PPUSH
4670: CALL_OW 171
// continue ;
4674: GO 4638
// end ; if IsInUnit ( i ) then
4676: LD_VAR 0 5
4680: PPUSH
4681: CALL_OW 310
4685: IFFALSE 4703
// begin ComExitBuilding ( i ) ;
4687: LD_VAR 0 5
4691: PPUSH
4692: CALL_OW 122
// wait ( 3 ) ;
4696: LD_INT 3
4698: PPUSH
4699: CALL_OW 67
// end ; if tmp_empty then
4703: LD_VAR 0 4
4707: IFFALSE 4806
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_VAR 0 4
4718: PPUSH
4719: LD_VAR 0 5
4723: PPUSH
4724: CALL_OW 74
4728: PPUSH
4729: CALL_OW 296
4733: PUSH
4734: LD_INT 25
4736: LESS
4737: IFFALSE 4806
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4739: LD_ADDR_VAR 0 6
4743: PUSH
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 74
4758: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4759: LD_VAR 0 5
4763: PPUSH
4764: LD_VAR 0 6
4768: PPUSH
4769: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4773: LD_VAR 0 5
4777: PPUSH
4778: LD_INT 209
4780: PPUSH
4781: LD_INT 132
4783: PPUSH
4784: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4788: LD_ADDR_VAR 0 4
4792: PUSH
4793: LD_VAR 0 4
4797: PUSH
4798: LD_VAR 0 6
4802: DIFF
4803: ST_TO_ADDR
// continue ;
4804: GO 4638
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4806: LD_VAR 0 5
4810: PPUSH
4811: LD_INT 201
4813: PPUSH
4814: LD_INT 132
4816: PPUSH
4817: CALL_OW 171
// end ;
4821: GO 4638
4823: POP
4824: POP
// for i in tmp_ape do
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_VAR 0 3
4834: PUSH
4835: FOR_IN
4836: IFFALSE 4875
// begin if IsInUnit ( i ) then
4838: LD_VAR 0 5
4842: PPUSH
4843: CALL_OW 310
4847: IFFALSE 4858
// ComExitBuilding ( i ) ;
4849: LD_VAR 0 5
4853: PPUSH
4854: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_INT 201
4865: PPUSH
4866: LD_INT 132
4868: PPUSH
4869: CALL_OW 171
// end ;
4873: GO 4835
4875: POP
4876: POP
// repeat wait ( 0 0$1 ) ;
4877: LD_INT 35
4879: PPUSH
4880: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4884: LD_ADDR_VAR 0 5
4888: PUSH
4889: LD_VAR 0 2
4893: PUSH
4894: LD_VAR 0 3
4898: UNION
4899: PUSH
4900: LD_VAR 0 1
4904: UNION
4905: PUSH
4906: FOR_IN
4907: IFFALSE 4938
// if not HasTask ( i ) then
4909: LD_VAR 0 5
4913: PPUSH
4914: CALL_OW 314
4918: NOT
4919: IFFALSE 4936
// ComMoveXY ( i , 201 , 132 ) ;
4921: LD_VAR 0 5
4925: PPUSH
4926: LD_INT 201
4928: PPUSH
4929: LD_INT 132
4931: PPUSH
4932: CALL_OW 111
4936: GO 4906
4938: POP
4939: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4940: LD_INT 21
4942: PPUSH
4943: LD_INT 22
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 70
4957: IFFALSE 4998
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4959: LD_ADDR_VAR 0 5
4963: PUSH
4964: LD_INT 21
4966: PPUSH
4967: LD_INT 22
4969: PUSH
4970: LD_INT 2
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PPUSH
4977: CALL_OW 70
4981: PUSH
4982: FOR_IN
4983: IFFALSE 4996
// RemoveUnit ( i ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: CALL_OW 64
4994: GO 4982
4996: POP
4997: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
4998: LD_INT 22
5000: PUSH
5001: LD_INT 2
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: LD_INT 21
5013: PUSH
5014: LD_INT 1
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 21
5023: PUSH
5024: LD_INT 2
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: NOT
5045: IFFALSE 4877
// end ;
5047: PPOPN 6
5049: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5050: LD_EXP 9
5054: PUSH
5055: LD_INT 92
5057: PPUSH
5058: LD_INT 40
5060: PPUSH
5061: CALL_OW 428
5065: PPUSH
5066: CALL_OW 266
5070: PUSH
5071: LD_INT 30
5073: EQUAL
5074: AND
5075: IFFALSE 5271
5077: GO 5079
5079: DISABLE
5080: LD_INT 0
5082: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5083: LD_ADDR_VAR 0 1
5087: PUSH
5088: LD_EXP 58
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: PPUSH
5097: LD_INT 25
5099: PUSH
5100: LD_INT 4
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 72
5111: ST_TO_ADDR
// if not sci then
5112: LD_VAR 0 1
5116: NOT
5117: IFFALSE 5121
// exit ;
5119: GO 5271
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5121: LD_ADDR_EXP 58
5125: PUSH
5126: LD_EXP 58
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_EXP 58
5138: PUSH
5139: LD_INT 1
5141: ARRAY
5142: PUSH
5143: LD_VAR 0 1
5147: PUSH
5148: LD_INT 1
5150: ARRAY
5151: DIFF
5152: PPUSH
5153: CALL_OW 1
5157: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5158: LD_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ARRAY
5166: PPUSH
5167: CALL_OW 310
5171: IFFALSE 5186
// ComExitBuilding ( sci [ 1 ] ) ;
5173: LD_VAR 0 1
5177: PUSH
5178: LD_INT 1
5180: ARRAY
5181: PPUSH
5182: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5186: LD_INT 2
5188: PPUSH
5189: LD_INT 105
5191: PPUSH
5192: LD_INT 14
5194: PPUSH
5195: LD_INT 20
5197: PPUSH
5198: CALL 21166 0 4
5202: PUSH
5203: LD_INT 4
5205: ARRAY
5206: PUSH
5207: LD_INT 10
5209: LESS
5210: IFFALSE 5233
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5212: LD_VAR 0 1
5216: PUSH
5217: LD_INT 1
5219: ARRAY
5220: PPUSH
5221: LD_INT 105
5223: PPUSH
5224: LD_INT 14
5226: PPUSH
5227: CALL_OW 171
5231: GO 5252
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5233: LD_VAR 0 1
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PPUSH
5242: LD_INT 118
5244: PPUSH
5245: LD_INT 77
5247: PPUSH
5248: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5252: LD_VAR 0 1
5256: PUSH
5257: LD_INT 1
5259: ARRAY
5260: PPUSH
5261: LD_INT 92
5263: PPUSH
5264: LD_INT 40
5266: PPUSH
5267: CALL_OW 218
// end ;
5271: PPOPN 1
5273: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5274: LD_INT 1
5276: PPUSH
5277: CALL_OW 302
5281: PUSH
5282: LD_EXP 9
5286: AND
5287: IFFALSE 5757
5289: GO 5291
5291: DISABLE
5292: LD_INT 0
5294: PPUSH
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
5299: PPUSH
// begin enable ;
5300: ENABLE
// base := 1 ;
5301: LD_ADDR_VAR 0 2
5305: PUSH
5306: LD_INT 1
5308: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5309: LD_ADDR_VAR 0 4
5313: PUSH
5314: LD_INT 0
5316: PUSH
5317: LD_INT 0
5319: PUSH
5320: LD_INT 0
5322: PUSH
5323: LD_INT 0
5325: PUSH
5326: LD_INT 0
5328: PUSH
5329: LD_INT 0
5331: PUSH
5332: LD_INT 0
5334: PUSH
5335: LD_INT 0
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: LD_INT 0
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: LIST
5355: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5356: LD_ADDR_VAR 0 3
5360: PUSH
5361: LD_INT 14
5363: PUSH
5364: LD_INT 1
5366: PUSH
5367: LD_INT 2
5369: PUSH
5370: LD_INT 26
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 14
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: LD_INT 2
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 13
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 2
5405: PUSH
5406: LD_INT 29
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5420: LD_ADDR_VAR 0 1
5424: PUSH
5425: DOUBLE
5426: LD_INT 1
5428: DEC
5429: ST_TO_ADDR
5430: LD_OWVAR 67
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 21000
5442: DIV
5443: PLUS
5444: PUSH
5445: FOR_TO
5446: IFFALSE 5538
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5448: LD_ADDR_VAR 0 3
5452: PUSH
5453: LD_VAR 0 3
5457: PPUSH
5458: LD_VAR 0 3
5462: PUSH
5463: LD_INT 1
5465: PLUS
5466: PPUSH
5467: LD_INT 13
5469: PUSH
5470: LD_INT 14
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 1
5479: PPUSH
5480: LD_INT 2
5482: PPUSH
5483: CALL_OW 12
5487: ARRAY
5488: PUSH
5489: LD_INT 1
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: LD_INT 28
5497: PUSH
5498: LD_INT 29
5500: PUSH
5501: LD_INT 25
5503: PUSH
5504: LD_INT 26
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 1
5515: PPUSH
5516: LD_INT 4
5518: PPUSH
5519: CALL_OW 12
5523: ARRAY
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PPUSH
5531: CALL_OW 2
5535: ST_TO_ADDR
5536: GO 5445
5538: POP
5539: POP
// MC_SetProduceList ( base , tmp ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_VAR 0 3
5549: PPUSH
5550: CALL 77746 0 2
// repeat wait ( 0 0$1 ) ;
5554: LD_INT 35
5556: PPUSH
5557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL 78200 0 1
5570: PUSH
5571: LD_INT 0
5573: EQUAL
5574: IFFALSE 5554
// wait ( 0 0$20 ) ;
5576: LD_INT 700
5578: PPUSH
5579: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5583: LD_ADDR_VAR 0 5
5587: PUSH
5588: LD_INT 124
5590: PUSH
5591: LD_INT 85
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 90
5600: PUSH
5601: LD_INT 61
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 69
5610: PUSH
5611: LD_INT 48
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 68
5620: PUSH
5621: LD_INT 48
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
5634: LD_ADDR_VAR 0 6
5638: PUSH
5639: LD_EXP 77
5643: PUSH
5644: LD_VAR 0 2
5648: ARRAY
5649: PUSH
5650: LD_EXP 80
5654: PUSH
5655: LD_VAR 0 2
5659: ARRAY
5660: PUSH
5661: LD_EXP 77
5665: PUSH
5666: LD_VAR 0 2
5670: ARRAY
5671: PPUSH
5672: LD_INT 34
5674: PUSH
5675: LD_INT 32
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PPUSH
5682: CALL_OW 72
5686: UNION
5687: DIFF
5688: ST_TO_ADDR
// if not attackers then
5689: LD_VAR 0 6
5693: NOT
5694: IFFALSE 5698
// exit ;
5696: GO 5757
// ar_attackers := attackers ;
5698: LD_ADDR_EXP 10
5702: PUSH
5703: LD_VAR 0 6
5707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5715: LD_VAR 0 6
5719: PPUSH
5720: LD_INT 60
5722: PUSH
5723: EMPTY
5724: LIST
5725: PPUSH
5726: CALL_OW 72
5730: NOT
5731: IFFALSE 5708
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5733: LD_VAR 0 2
5737: PPUSH
5738: LD_VAR 0 6
5742: PPUSH
5743: LD_VAR 0 5
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL 78037 0 4
// end ;
5757: PPOPN 6
5759: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5760: LD_INT 1
5762: PPUSH
5763: CALL_OW 302
5767: PUSH
5768: LD_EXP 9
5772: AND
5773: PUSH
5774: LD_EXP 48
5778: PPUSH
5779: LD_INT 22
5781: PPUSH
5782: CALL_OW 308
5786: AND
5787: PUSH
5788: LD_INT 1
5790: PPUSH
5791: CALL 78200 0 1
5795: PUSH
5796: LD_INT 0
5798: EQUAL
5799: AND
5800: PUSH
5801: LD_EXP 10
5805: NOT
5806: AND
5807: IFFALSE 6282
5809: GO 5811
5811: DISABLE
5812: LD_INT 0
5814: PPUSH
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
// begin base := 1 ;
5821: LD_ADDR_VAR 0 2
5825: PUSH
5826: LD_INT 1
5828: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 0
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: LD_INT 0
5848: PUSH
5849: LD_INT 0
5851: PUSH
5852: LD_INT 0
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 0
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 13
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 27
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 13
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: LD_INT 25
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 11
5937: PUSH
5938: LD_INT 2
5940: PUSH
5941: LD_INT 2
5943: PUSH
5944: LD_INT 24
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 11
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 24
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// MC_SetProduceList ( base , tmp ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL 77746 0 2
// repeat wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 78200 0 1
6008: PUSH
6009: LD_INT 0
6011: EQUAL
6012: IFFALSE 5992
// wait ( 0 0$20 ) ;
6014: LD_INT 700
6016: PPUSH
6017: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6021: LD_ADDR_VAR 0 5
6025: PUSH
6026: LD_INT 119
6028: PUSH
6029: LD_INT 9
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PUSH
6036: EMPTY
6037: LIST
6038: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
6039: LD_ADDR_VAR 0 6
6043: PUSH
6044: LD_EXP 77
6048: PUSH
6049: LD_VAR 0 2
6053: ARRAY
6054: PUSH
6055: LD_EXP 80
6059: PUSH
6060: LD_VAR 0 2
6064: ARRAY
6065: PUSH
6066: LD_EXP 77
6070: PUSH
6071: LD_VAR 0 2
6075: ARRAY
6076: PPUSH
6077: LD_INT 34
6079: PUSH
6080: LD_INT 32
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: UNION
6092: DIFF
6093: ST_TO_ADDR
// if not attackers then
6094: LD_VAR 0 6
6098: NOT
6099: IFFALSE 6103
// exit ;
6101: GO 6282
// uc_side := 2 ;
6103: LD_ADDR_OWVAR 20
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// uc_nation := 2 ;
6111: LD_ADDR_OWVAR 21
6115: PUSH
6116: LD_INT 2
6118: ST_TO_ADDR
// InitHc ;
6119: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: DOUBLE
6129: LD_INT 1
6131: DEC
6132: ST_TO_ADDR
6133: LD_INT 4
6135: PUSH
6136: LD_INT 5
6138: PUSH
6139: LD_INT 6
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_OWVAR 67
6151: ARRAY
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6231
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6156: LD_INT 0
6158: PPUSH
6159: LD_INT 15
6161: PUSH
6162: LD_INT 17
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: PPUSH
6181: LD_INT 8
6183: PPUSH
6184: CALL_OW 380
// un := CreateHuman ;
6188: LD_ADDR_VAR 0 7
6192: PUSH
6193: CALL_OW 44
6197: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6198: LD_VAR 0 7
6202: PPUSH
6203: LD_INT 23
6205: PPUSH
6206: LD_INT 0
6208: PPUSH
6209: CALL_OW 49
// attackers := attackers union un ;
6213: LD_ADDR_VAR 0 6
6217: PUSH
6218: LD_VAR 0 6
6222: PUSH
6223: LD_VAR 0 7
6227: UNION
6228: ST_TO_ADDR
// end ;
6229: GO 6153
6231: POP
6232: POP
// repeat wait ( 0 0$1 ) ;
6233: LD_INT 35
6235: PPUSH
6236: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6240: LD_VAR 0 6
6244: PPUSH
6245: LD_INT 60
6247: PUSH
6248: EMPTY
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: NOT
6256: IFFALSE 6233
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6258: LD_VAR 0 2
6262: PPUSH
6263: LD_VAR 0 6
6267: PPUSH
6268: LD_VAR 0 5
6272: PPUSH
6273: LD_VAR 0 4
6277: PPUSH
6278: CALL 78037 0 4
// end ; end_of_file
6282: PPOPN 7
6284: END
// export function PrepareAmericanAttack ; var i , tmp , veh , flags , _target ; begin
6285: LD_INT 0
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
6291: PPUSH
6292: PPUSH
// uc_side := 1 ;
6293: LD_ADDR_OWVAR 20
6297: PUSH
6298: LD_INT 1
6300: ST_TO_ADDR
// uc_nation := 1 ;
6301: LD_ADDR_OWVAR 21
6305: PUSH
6306: LD_INT 1
6308: ST_TO_ADDR
// InitHc ;
6309: CALL_OW 19
// InitVc ;
6313: CALL_OW 20
// tmp := [ ] ;
6317: LD_ADDR_VAR 0 3
6321: PUSH
6322: EMPTY
6323: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6324: LD_ADDR_VAR 0 5
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_INT 0
6334: PUSH
6335: LD_INT 0
6337: PUSH
6338: LD_INT 0
6340: PUSH
6341: LD_INT 0
6343: PUSH
6344: LD_INT 0
6346: PUSH
6347: LD_INT 0
6349: PUSH
6350: LD_INT 0
6352: PUSH
6353: LD_INT 1
6355: PUSH
6356: LD_INT 0
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: ST_TO_ADDR
// _target := [ [ 71 , 34 ] , [ 63 , 49 ] ] ;
6371: LD_ADDR_VAR 0 6
6375: PUSH
6376: LD_INT 71
6378: PUSH
6379: LD_INT 34
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 63
6388: PUSH
6389: LD_INT 49
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6400: LD_ADDR_VAR 0 2
6404: PUSH
6405: DOUBLE
6406: LD_INT 1
6408: DEC
6409: ST_TO_ADDR
6410: LD_INT 5
6412: PUSH
6413: LD_INT 6
6415: PUSH
6416: LD_INT 6
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_OWVAR 67
6428: ARRAY
6429: PUSH
6430: FOR_TO
6431: IFFALSE 6568
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6433: LD_INT 2
6435: PUSH
6436: LD_INT 4
6438: PUSH
6439: LD_INT 5
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 1
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: CALL_OW 12
6457: ARRAY
6458: PPUSH
6459: LD_INT 1
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 2
6474: PPUSH
6475: CALL_OW 12
6479: ARRAY
6480: PPUSH
6481: LD_INT 3
6483: PPUSH
6484: LD_INT 9
6486: PUSH
6487: LD_INT 7
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 1
6496: PPUSH
6497: LD_INT 2
6499: PPUSH
6500: CALL_OW 12
6504: ARRAY
6505: PPUSH
6506: LD_INT 78
6508: PPUSH
6509: CALL 20148 0 5
// veh := CreateVehicle ;
6513: LD_ADDR_VAR 0 4
6517: PUSH
6518: CALL_OW 45
6522: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 2
6530: PPUSH
6531: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6535: LD_VAR 0 4
6539: PPUSH
6540: LD_INT 17
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// tmp := tmp ^ veh ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 4
6564: ADD
6565: ST_TO_ADDR
// end ;
6566: GO 6430
6568: POP
6569: POP
// if not tmp then
6570: LD_VAR 0 3
6574: NOT
6575: IFFALSE 6579
// exit ;
6577: GO 6622
// if not first_powell_attack then
6579: LD_EXP 11
6583: NOT
6584: IFFALSE 6594
// first_powell_attack := true ;
6586: LD_ADDR_EXP 11
6590: PUSH
6591: LD_INT 1
6593: ST_TO_ADDR
// Attack ( [ 0 , tmp , _target , flags ] ) ;
6594: LD_INT 0
6596: PUSH
6597: LD_VAR 0 3
6601: PUSH
6602: LD_VAR 0 6
6606: PUSH
6607: LD_VAR 0 5
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PPUSH
6618: CALL 48723 0 1
// end ; end_of_file
6622: LD_VAR 0 1
6626: RET
// export function Action ; var tmp , i , un ; begin
6627: LD_INT 0
6629: PPUSH
6630: PPUSH
6631: PPUSH
6632: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6633: LD_INT 68
6635: PPUSH
6636: LD_INT 39
6638: PPUSH
6639: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6643: LD_ADDR_VAR 0 2
6647: PUSH
6648: LD_INT 22
6650: PUSH
6651: LD_INT 7
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PPUSH
6658: CALL_OW 69
6662: ST_TO_ADDR
// InGameOn ;
6663: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 71
6674: PPUSH
6675: LD_INT 49
6677: PPUSH
6678: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6682: LD_INT 35
6684: PPUSH
6685: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6689: LD_INT 7
6691: PPUSH
6692: LD_INT 71
6694: PPUSH
6695: LD_INT 51
6697: PPUSH
6698: CALL_OW 293
6702: IFFALSE 6682
// DialogueOn ;
6704: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6708: LD_EXP 14
6712: PPUSH
6713: LD_STRING D1-JMM-1
6715: PPUSH
6716: CALL_OW 88
// if Joan then
6720: LD_EXP 29
6724: IFFALSE 6738
// Say ( Joan , D1-Joan-1 ) ;
6726: LD_EXP 29
6730: PPUSH
6731: LD_STRING D1-Joan-1
6733: PPUSH
6734: CALL_OW 88
// if Lisa then
6738: LD_EXP 16
6742: IFFALSE 6756
// Say ( Lisa , D1-Lisa-1 ) ;
6744: LD_EXP 16
6748: PPUSH
6749: LD_STRING D1-Lisa-1
6751: PPUSH
6752: CALL_OW 88
// if Joan or Lisa then
6756: LD_EXP 29
6760: PUSH
6761: LD_EXP 16
6765: OR
6766: IFFALSE 6780
// Say ( JMM , D1-JMM-2 ) ;
6768: LD_EXP 14
6772: PPUSH
6773: LD_STRING D1-JMM-2
6775: PPUSH
6776: CALL_OW 88
// DialogueOff ;
6780: CALL_OW 7
// InGameOff ;
6784: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6788: LD_INT 71
6790: PPUSH
6791: LD_INT 50
6793: PPUSH
6794: LD_INT 7
6796: PPUSH
6797: LD_INT 30
6799: NEG
6800: PPUSH
6801: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6805: LD_INT 71
6807: PPUSH
6808: LD_INT 50
6810: PPUSH
6811: LD_INT 7
6813: PPUSH
6814: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6818: LD_STRING M1
6820: PPUSH
6821: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6825: LD_INT 35
6827: PPUSH
6828: CALL_OW 67
// until freedom ;
6832: LD_EXP 3
6836: IFFALSE 6825
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6838: LD_INT 350
6840: PPUSH
6841: LD_INT 700
6843: PPUSH
6844: CALL_OW 12
6848: PPUSH
6849: CALL_OW 67
// PrepareGossudarov ;
6853: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6857: LD_INT 35
6859: PPUSH
6860: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6864: LD_INT 22
6866: PUSH
6867: LD_INT 6
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: LD_INT 24
6879: PUSH
6880: LD_INT 1000
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: PPUSH
6895: CALL_OW 69
6899: IFFALSE 6857
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6901: LD_ADDR_VAR 0 2
6905: PUSH
6906: LD_INT 22
6908: PUSH
6909: LD_INT 6
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for i in tmp do
6921: LD_ADDR_VAR 0 3
6925: PUSH
6926: LD_VAR 0 2
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6948
// SetSide ( i , 7 ) ;
6934: LD_VAR 0 3
6938: PPUSH
6939: LD_INT 7
6941: PPUSH
6942: CALL_OW 235
6946: GO 6931
6948: POP
6949: POP
// DialogueOn ;
6950: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6954: LD_EXP 14
6958: PUSH
6959: LD_EXP 15
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6977: LD_EXP 31
6981: PPUSH
6982: CALL_OW 87
// if not Roth then
6986: LD_EXP 15
6990: NOT
6991: IFFALSE 7055
// begin Say ( JMM , D2-JMM-1 ) ;
6993: LD_EXP 14
6997: PPUSH
6998: LD_STRING D2-JMM-1
7000: PPUSH
7001: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7005: LD_EXP 14
7009: PPUSH
7010: LD_STRING D2-JMM-1b
7012: PPUSH
7013: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7017: LD_EXP 31
7021: PPUSH
7022: LD_STRING D2-Gos-1
7024: PPUSH
7025: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7029: LD_EXP 14
7033: PPUSH
7034: LD_STRING D2-JMM-2
7036: PPUSH
7037: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7041: LD_EXP 31
7045: PPUSH
7046: LD_STRING D2-Gos-2
7048: PPUSH
7049: CALL_OW 88
// end else
7053: GO 7151
// begin Say ( Roth , D2-Roth-2 ) ;
7055: LD_EXP 15
7059: PPUSH
7060: LD_STRING D2-Roth-2
7062: PPUSH
7063: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7067: LD_EXP 14
7071: PPUSH
7072: LD_STRING D2-JMM-1a
7074: PPUSH
7075: CALL_OW 88
// Say ( Roth , D2-Roth-2a ) ;
7079: LD_EXP 15
7083: PPUSH
7084: LD_STRING D2-Roth-2a
7086: PPUSH
7087: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7091: LD_EXP 15
7095: PPUSH
7096: LD_STRING D2-Roth-2b
7098: PPUSH
7099: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7103: LD_EXP 14
7107: PPUSH
7108: LD_STRING D2-JMM-3
7110: PPUSH
7111: CALL_OW 88
// Say ( Gossudarov , D2-Gos-3 ) ;
7115: LD_EXP 31
7119: PPUSH
7120: LD_STRING D2-Gos-3
7122: PPUSH
7123: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7127: LD_EXP 14
7131: PPUSH
7132: LD_STRING D2-JMM-4
7134: PPUSH
7135: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7139: LD_EXP 31
7143: PPUSH
7144: LD_STRING D2-Gos-4
7146: PPUSH
7147: CALL_OW 88
// end ; Say ( JMM , D2-JMM-5 ) ;
7151: LD_EXP 14
7155: PPUSH
7156: LD_STRING D2-JMM-5
7158: PPUSH
7159: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7163: LD_EXP 31
7167: PPUSH
7168: LD_STRING D2-Gos-5
7170: PPUSH
7171: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7175: LD_EXP 14
7179: PPUSH
7180: LD_STRING D2-JMM-6
7182: PPUSH
7183: CALL_OW 88
// DialogueOff ;
7187: CALL_OW 7
// wait ( 0 0$2 ) ;
7191: LD_INT 70
7193: PPUSH
7194: CALL_OW 67
// if Kirilenkova then
7198: LD_EXP 32
7202: IFFALSE 7216
// Say ( Kirilenkova , D3-Kir-1 ) ;
7204: LD_EXP 32
7208: PPUSH
7209: LD_STRING D3-Kir-1
7211: PPUSH
7212: CALL_OW 88
// gossudarov_arrive := true ;
7216: LD_ADDR_EXP 4
7220: PUSH
7221: LD_INT 1
7223: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7224: LD_INT 35
7226: PPUSH
7227: CALL_OW 67
// until ru_lab_builded ;
7231: LD_EXP 5
7235: IFFALSE 7224
// if Kirilenkova then
7237: LD_EXP 32
7241: IFFALSE 7257
// Say ( Kirilenkova , D3a-Kir-1 ) else
7243: LD_EXP 32
7247: PPUSH
7248: LD_STRING D3a-Kir-1
7250: PPUSH
7251: CALL_OW 88
7255: GO 7279
// begin un := SciRu ;
7257: LD_ADDR_VAR 0 4
7261: PUSH
7262: CALL 12046 0 0
7266: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7267: LD_VAR 0 4
7271: PPUSH
7272: LD_STRING D3a-Sci1-1
7274: PPUSH
7275: CALL_OW 88
// end ; if Kirilenkova or un then
7279: LD_EXP 32
7283: PUSH
7284: LD_VAR 0 4
7288: OR
7289: IFFALSE 7303
// Say ( JMM , D3a-JMM-1 ) ;
7291: LD_EXP 14
7295: PPUSH
7296: LD_STRING D3a-JMM-1
7298: PPUSH
7299: CALL_OW 88
// end ;
7303: LD_VAR 0 1
7307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7308: LD_EXP 4
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_INT 7
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 1
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: LD_INT 25
7338: PUSH
7339: LD_INT 2
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PUSH
7346: LD_INT 25
7348: PUSH
7349: LD_INT 3
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 25
7358: PUSH
7359: LD_INT 4
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: PUSH
7366: LD_INT 25
7368: PUSH
7369: LD_INT 5
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PUSH
7376: LD_INT 25
7378: PUSH
7379: LD_INT 8
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 25
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PPUSH
7410: CALL_OW 69
7414: PUSH
7415: LD_INT 6
7417: LESS
7418: AND
7419: IFFALSE 7431
7421: GO 7423
7423: DISABLE
// YouLost ( TooMany ) ;
7424: LD_STRING TooMany
7426: PPUSH
7427: CALL_OW 104
7431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7432: LD_EXP 31
7436: PPUSH
7437: CALL_OW 255
7441: PUSH
7442: LD_INT 7
7444: EQUAL
7445: IFFALSE 7645
7447: GO 7449
7449: DISABLE
7450: LD_INT 0
7452: PPUSH
7453: PPUSH
7454: PPUSH
// begin uc_side := 3 ;
7455: LD_ADDR_OWVAR 20
7459: PUSH
7460: LD_INT 3
7462: ST_TO_ADDR
// uc_nation := 3 ;
7463: LD_ADDR_OWVAR 21
7467: PUSH
7468: LD_INT 3
7470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7471: LD_INT 21
7473: PPUSH
7474: LD_INT 3
7476: PPUSH
7477: LD_INT 3
7479: PPUSH
7480: LD_INT 42
7482: PPUSH
7483: LD_INT 100
7485: PPUSH
7486: CALL 20148 0 5
// un := CreateVehicle ;
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: CALL_OW 45
7499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7500: LD_VAR 0 3
7504: PPUSH
7505: LD_INT 15
7507: PPUSH
7508: LD_INT 0
7510: PPUSH
7511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7515: LD_VAR 0 3
7519: PPUSH
7520: LD_INT 67
7522: PPUSH
7523: LD_INT 45
7525: PPUSH
7526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7530: LD_VAR 0 3
7534: PPUSH
7535: LD_INT 70
7537: PPUSH
7538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7542: LD_VAR 0 3
7546: PPUSH
7547: LD_INT 69
7549: PPUSH
7550: LD_INT 18
7552: PPUSH
7553: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7557: LD_VAR 0 3
7561: PPUSH
7562: LD_INT 60
7564: PPUSH
7565: LD_INT 2
7567: PPUSH
7568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7572: LD_INT 35
7574: PPUSH
7575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7579: LD_VAR 0 3
7583: PPUSH
7584: CALL_OW 302
7588: NOT
7589: PUSH
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 17
7597: PPUSH
7598: CALL_OW 308
7602: OR
7603: IFFALSE 7572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 17
7612: PPUSH
7613: CALL_OW 308
7617: PUSH
7618: LD_VAR 0 3
7622: PPUSH
7623: LD_INT 60
7625: PPUSH
7626: LD_INT 2
7628: PPUSH
7629: CALL_OW 307
7633: OR
7634: IFFALSE 7645
// RemoveUnit ( un ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 64
// end ;
7645: PPOPN 3
7647: END
// every 0 0$2 do var i , un , tmp ;
7648: GO 7650
7650: DISABLE
7651: LD_INT 0
7653: PPUSH
7654: PPUSH
7655: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7656: LD_INT 70
7658: PPUSH
7659: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7663: LD_ADDR_VAR 0 3
7667: PUSH
7668: LD_INT 22
7670: PUSH
7671: LD_INT 7
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 101
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PPUSH
7692: CALL_OW 69
7696: ST_TO_ADDR
// until tmp ;
7697: LD_VAR 0 3
7701: IFFALSE 7656
// un := NearestUnitToUnit ( tmp , JMM ) ;
7703: LD_ADDR_VAR 0 2
7707: PUSH
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_EXP 14
7717: PPUSH
7718: CALL_OW 74
7722: ST_TO_ADDR
// player_spotted := true ;
7723: LD_ADDR_EXP 6
7727: PUSH
7728: LD_INT 1
7730: ST_TO_ADDR
// tmp := SciRu ;
7731: LD_ADDR_VAR 0 3
7735: PUSH
7736: CALL 12046 0 0
7740: ST_TO_ADDR
// DialogueOn ;
7741: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7745: LD_VAR 0 2
7749: PPUSH
7750: CALL_OW 250
7754: PPUSH
7755: LD_VAR 0 2
7759: PPUSH
7760: CALL_OW 251
7764: PPUSH
7765: LD_INT 7
7767: PPUSH
7768: LD_INT 8
7770: NEG
7771: PPUSH
7772: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: CALL_OW 87
// if tmp then
7785: LD_VAR 0 3
7789: IFFALSE 7803
// Say ( tmp , D4-RSci1-1 ) ;
7791: LD_VAR 0 3
7795: PPUSH
7796: LD_STRING D4-RSci1-1
7798: PPUSH
7799: CALL_OW 88
// if Gossudarov then
7803: LD_EXP 31
7807: IFFALSE 7833
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7809: LD_EXP 31
7813: PPUSH
7814: LD_STRING D4-Gos-1
7816: PPUSH
7817: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7821: LD_EXP 14
7825: PPUSH
7826: LD_STRING D4-JMM-1
7828: PPUSH
7829: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7833: LD_VAR 0 2
7837: PPUSH
7838: CALL_OW 250
7842: PPUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: CALL_OW 251
7852: PPUSH
7853: LD_INT 7
7855: PPUSH
7856: CALL_OW 331
// DialogueOff ;
7860: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7864: LD_STRING M5
7866: PPUSH
7867: CALL_OW 337
// end ;
7871: PPOPN 3
7873: END
// every 0 0$30 + 2 2$30 trigger player_spotted do
7874: LD_EXP 6
7878: IFFALSE 8337
7880: GO 7882
7882: DISABLE
// begin PrepareBelkov ;
7883: CALL 1934 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7887: LD_EXP 46
7891: PPUSH
7892: LD_INT 118
7894: PPUSH
7895: LD_INT 106
7897: PPUSH
7898: CALL_OW 111
// AddComHold ( Belkov ) ;
7902: LD_EXP 46
7906: PPUSH
7907: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
7911: LD_INT 35
7913: PPUSH
7914: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
7918: LD_EXP 46
7922: PPUSH
7923: LD_INT 118
7925: PPUSH
7926: LD_INT 106
7928: PPUSH
7929: CALL_OW 307
7933: IFFALSE 7911
// ChangeSideFog ( 4 , 7 ) ;
7935: LD_INT 4
7937: PPUSH
7938: LD_INT 7
7940: PPUSH
7941: CALL_OW 343
// if IsOk ( Belkov ) then
7945: LD_EXP 46
7949: PPUSH
7950: CALL_OW 302
7954: IFFALSE 8038
// begin InGameOn ;
7956: CALL_OW 8
// DialogueOn ;
7960: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
7964: LD_EXP 46
7968: PPUSH
7969: LD_STRING D5-Bel-1
7971: PPUSH
7972: CALL_OW 94
// if Gossudarov then
7976: LD_EXP 31
7980: IFFALSE 8030
// begin Say ( Gossudarov , D5-Gos-1 ) ;
7982: LD_EXP 31
7986: PPUSH
7987: LD_STRING D5-Gos-1
7989: PPUSH
7990: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
7994: LD_EXP 14
7998: PPUSH
7999: LD_STRING D5-JMM-1
8001: PPUSH
8002: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8006: LD_EXP 31
8010: PPUSH
8011: LD_STRING D5-Gos-2
8013: PPUSH
8014: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8018: LD_EXP 14
8022: PPUSH
8023: LD_STRING D5-JMM-2
8025: PPUSH
8026: CALL_OW 88
// end ; DialogueOff ;
8030: CALL_OW 7
// InGameOff ;
8034: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8038: LD_STRING QSaveBelkov
8040: PPUSH
8041: CALL_OW 97
8045: PUSH
8046: LD_INT 1
8048: DOUBLE
8049: EQUAL
8050: IFTRUE 8054
8052: GO 8104
8054: POP
// begin DialogueOn ;
8055: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8059: LD_EXP 14
8063: PPUSH
8064: LD_STRING D5a-JMM-1
8066: PPUSH
8067: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8071: LD_EXP 46
8075: PPUSH
8076: LD_STRING D5a-Bel-1
8078: PPUSH
8079: CALL_OW 94
// DialogueOff ;
8083: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8087: LD_EXP 46
8091: PPUSH
8092: LD_INT 83
8094: PPUSH
8095: LD_INT 49
8097: PPUSH
8098: CALL_OW 111
// end ; 2 :
8102: GO 8164
8104: LD_INT 2
8106: DOUBLE
8107: EQUAL
8108: IFTRUE 8112
8110: GO 8163
8112: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8113: LD_EXP 14
8117: PPUSH
8118: LD_STRING D5a-JMM-2
8120: PPUSH
8121: CALL_OW 88
// ComWait ( Belkov , 0 0$10 ) ;
8125: LD_EXP 46
8129: PPUSH
8130: LD_INT 350
8132: PPUSH
8133: CALL_OW 142
// AddComMoveXY ( Belkov , 107 , 109 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_INT 107
8144: PPUSH
8145: LD_INT 109
8147: PPUSH
8148: CALL_OW 171
// AddComHold ( Belkov ) ;
8152: LD_EXP 46
8156: PPUSH
8157: CALL_OW 200
// end ; end ;
8161: GO 8164
8163: POP
// repeat wait ( 0 0$1 ) ;
8164: LD_INT 35
8166: PPUSH
8167: CALL_OW 67
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8171: LD_EXP 46
8175: PPUSH
8176: CALL_OW 301
8180: PUSH
8181: LD_EXP 46
8185: PPUSH
8186: CALL_OW 255
8190: PUSH
8191: LD_INT 4
8193: EQUAL
8194: AND
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 7
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PPUSH
8206: CALL_OW 69
8210: PPUSH
8211: LD_EXP 46
8215: PPUSH
8216: CALL_OW 74
8220: PPUSH
8221: LD_EXP 46
8225: PPUSH
8226: CALL_OW 296
8230: PUSH
8231: LD_INT 10
8233: LESS
8234: OR
8235: IFFALSE 8164
// if IsDead ( Belkov ) then
8237: LD_EXP 46
8241: PPUSH
8242: CALL_OW 301
8246: IFFALSE 8271
// begin CenterNowOnUnits ( Belkov ) ;
8248: LD_EXP 46
8252: PPUSH
8253: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8257: LD_EXP 14
8261: PPUSH
8262: LD_STRING D5a-JMM-2a
8264: PPUSH
8265: CALL_OW 88
// exit ;
8269: GO 8337
// end ; if See ( 7 , Belkov ) then
8271: LD_INT 7
8273: PPUSH
8274: LD_EXP 46
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8297
// SetSide ( Belkov , 7 ) ;
8285: LD_EXP 46
8289: PPUSH
8290: LD_INT 7
8292: PPUSH
8293: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8304: LD_EXP 46
8308: PPUSH
8309: LD_INT 66
8311: PPUSH
8312: LD_INT 45
8314: PPUSH
8315: CALL_OW 297
8319: PUSH
8320: LD_INT 30
8322: LESS
8323: IFFALSE 8297
// Say ( Belkov , D6-Bel-1 ) ;
8325: LD_EXP 46
8329: PPUSH
8330: LD_STRING D6-Bel-1
8332: PPUSH
8333: CALL_OW 88
// end ;
8337: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8338: LD_EXP 46
8342: PPUSH
8343: CALL_OW 302
8347: PUSH
8348: LD_EXP 46
8352: PPUSH
8353: CALL_OW 504
8357: PUSH
8358: LD_INT 2
8360: PUSH
8361: LD_INT 34
8363: PUSH
8364: LD_INT 47
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PUSH
8371: LD_INT 34
8373: PUSH
8374: LD_INT 45
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: PPUSH
8386: CALL_OW 69
8390: IN
8391: AND
8392: IFFALSE 8409
8394: GO 8396
8396: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8397: LD_EXP 46
8401: PPUSH
8402: LD_STRING D7-Bel-1
8404: PPUSH
8405: CALL_OW 88
8409: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8410: LD_INT 22
8412: PUSH
8413: LD_INT 7
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 101
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PPUSH
8434: CALL_OW 69
8438: PUSH
8439: LD_EXP 8
8443: NOT
8444: AND
8445: PUSH
8446: LD_EXP 45
8450: PPUSH
8451: CALL_OW 305
8455: NOT
8456: AND
8457: IFFALSE 8927
8459: GO 8461
8461: DISABLE
8462: LD_INT 0
8464: PPUSH
// begin ar_base_spotted := true ;
8465: LD_ADDR_EXP 8
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 21
8490: PUSH
8491: LD_INT 3
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8507: LD_ADDR_VAR 0 1
8511: PUSH
8512: LD_VAR 0 1
8516: PPUSH
8517: LD_EXP 14
8521: PPUSH
8522: CALL_OW 74
8526: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8527: LD_INT 7
8529: PPUSH
8530: LD_INT 3
8532: PPUSH
8533: CALL_OW 332
// DialogueOn ;
8537: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8541: LD_VAR 0 1
8545: PPUSH
8546: CALL_OW 250
8550: PPUSH
8551: LD_VAR 0 1
8555: PPUSH
8556: CALL_OW 251
8560: PPUSH
8561: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_INT 22
8572: PUSH
8573: LD_INT 7
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PUSH
8580: LD_INT 23
8582: PUSH
8583: LD_INT 1
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PUSH
8590: LD_INT 26
8592: PUSH
8593: LD_INT 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: LIST
8604: PPUSH
8605: CALL_OW 69
8609: PUSH
8610: LD_EXP 14
8614: PUSH
8615: LD_EXP 18
8619: PUSH
8620: LD_EXP 19
8624: PUSH
8625: LD_EXP 26
8629: PUSH
8630: LD_EXP 15
8634: PUSH
8635: LD_EXP 24
8639: PUSH
8640: LD_EXP 20
8644: PUSH
8645: LD_EXP 22
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: DIFF
8660: ST_TO_ADDR
// if not tmp then
8661: LD_VAR 0 1
8665: NOT
8666: IFFALSE 8740
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8668: LD_ADDR_VAR 0 1
8672: PUSH
8673: LD_INT 22
8675: PUSH
8676: LD_INT 7
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 23
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: PUSH
8693: LD_INT 26
8695: PUSH
8696: LD_INT 2
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: PUSH
8713: LD_EXP 29
8717: PUSH
8718: LD_EXP 16
8722: PUSH
8723: LD_EXP 27
8727: PUSH
8728: LD_EXP 28
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: DIFF
8739: ST_TO_ADDR
// if tmp then
8740: LD_VAR 0 1
8744: IFFALSE 8815
// case GetSex ( tmp [ 1 ] ) of sex_male :
8746: LD_VAR 0 1
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: CALL_OW 258
8759: PUSH
8760: LD_INT 1
8762: DOUBLE
8763: EQUAL
8764: IFTRUE 8768
8766: GO 8787
8768: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8769: LD_VAR 0 1
8773: PUSH
8774: LD_INT 1
8776: ARRAY
8777: PPUSH
8778: LD_STRING D9-Sol1-1
8780: PPUSH
8781: CALL_OW 88
8785: GO 8815
8787: LD_INT 2
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8814
8795: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
8796: LD_VAR 0 1
8800: PUSH
8801: LD_INT 1
8803: ARRAY
8804: PPUSH
8805: LD_STRING D9-FSol1-1
8807: PPUSH
8808: CALL_OW 88
8812: GO 8815
8814: POP
// if Frank then
8815: LD_EXP 26
8819: IFFALSE 8923
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
8821: LD_EXP 55
8825: PPUSH
8826: CALL_OW 250
8830: PPUSH
8831: LD_EXP 55
8835: PPUSH
8836: CALL_OW 251
8840: PPUSH
8841: LD_INT 7
8843: PPUSH
8844: LD_INT 8
8846: PPUSH
8847: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
8851: LD_EXP 55
8855: PPUSH
8856: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
8860: LD_EXP 26
8864: PPUSH
8865: LD_STRING D9-Frank-1
8867: PPUSH
8868: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
8872: LD_EXP 14
8876: PPUSH
8877: LD_STRING D9-JMM-1
8879: PPUSH
8880: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
8884: LD_EXP 26
8888: PPUSH
8889: LD_STRING D9-Frank-2
8891: PPUSH
8892: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
8896: LD_EXP 55
8900: PPUSH
8901: CALL_OW 250
8905: PPUSH
8906: LD_EXP 55
8910: PPUSH
8911: CALL_OW 251
8915: PPUSH
8916: LD_INT 7
8918: PPUSH
8919: CALL_OW 331
// end ; DialogueOff ;
8923: CALL_OW 7
// end ;
8927: PPOPN 1
8929: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
8930: LD_EXP 7
8934: PUSH
8935: LD_OWVAR 1
8939: PUSH
8940: LD_INT 42000
8942: GREATEREQUAL
8943: OR
8944: IFFALSE 9971
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
8952: PPUSH
// begin selected_option := 1 ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_INT 1
8960: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8961: LD_INT 10500
8963: PPUSH
8964: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8968: LD_INT 35
8970: PPUSH
8971: CALL_OW 67
// until not ru_attackers ;
8975: LD_EXP 51
8979: NOT
8980: IFFALSE 8968
// PrepareBurlak ;
8982: CALL 2046 0 0
// repeat wait ( 0 0$2 ) ;
8986: LD_INT 70
8988: PPUSH
8989: CALL_OW 67
// until not HasTask ( Burlak ) ;
8993: LD_EXP 45
8997: PPUSH
8998: CALL_OW 314
9002: NOT
9003: IFFALSE 8986
// InGameOn ;
9005: CALL_OW 8
// DialogueOn ;
9009: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9013: LD_EXP 48
9017: PPUSH
9018: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9022: LD_EXP 45
9026: PPUSH
9027: LD_STRING D10-Bur-1
9029: PPUSH
9030: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9034: LD_EXP 46
9038: PUSH
9039: LD_EXP 46
9043: PPUSH
9044: CALL_OW 255
9048: PUSH
9049: LD_INT 7
9051: EQUAL
9052: AND
9053: IFFALSE 9067
// Say ( Belkov , D10-Bel-1 ) ;
9055: LD_EXP 46
9059: PPUSH
9060: LD_STRING D10-Bel-1
9062: PPUSH
9063: CALL_OW 88
// if Gossudarov then
9067: LD_EXP 31
9071: IFFALSE 9085
// Say ( Gossudarov , D10-Gos-1 ) ;
9073: LD_EXP 31
9077: PPUSH
9078: LD_STRING D10-Gos-1
9080: PPUSH
9081: CALL_OW 88
// if Kirilenkova then
9085: LD_EXP 32
9089: IFFALSE 9103
// Say ( Kirilenkova , D10-Kir-1 ) ;
9091: LD_EXP 32
9095: PPUSH
9096: LD_STRING D10-Kir-1
9098: PPUSH
9099: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9103: CALL 12175 0 0
9107: PPUSH
9108: LD_STRING D10-RSol1-1
9110: PPUSH
9111: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9115: LD_EXP 45
9119: PPUSH
9120: LD_STRING D10-Bur-2
9122: PPUSH
9123: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9127: LD_EXP 14
9131: PPUSH
9132: LD_STRING D10-JMM-2
9134: PPUSH
9135: CALL_OW 88
// if Kirilenkova then
9139: LD_EXP 32
9143: IFFALSE 9159
// Say ( Kirilenkova , D10-Kir-2 ) else
9145: LD_EXP 32
9149: PPUSH
9150: LD_STRING D10-Kir-2
9152: PPUSH
9153: CALL_OW 88
9157: GO 9171
// Say ( SolRu , D10-RSol1-2 ) ;
9159: CALL 12175 0 0
9163: PPUSH
9164: LD_STRING D10-RSol1-2
9166: PPUSH
9167: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9171: LD_EXP 14
9175: PPUSH
9176: LD_STRING D10-JMM-3
9178: PPUSH
9179: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9183: LD_EXP 45
9187: PPUSH
9188: LD_STRING D10-Bur-3
9190: PPUSH
9191: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9195: LD_EXP 14
9199: PPUSH
9200: LD_STRING D10-JMM-4
9202: PPUSH
9203: CALL_OW 88
// DialogueOff ;
9207: CALL_OW 7
// InGameOff ;
9211: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9215: LD_STRING M2
9217: PPUSH
9218: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9222: LD_INT 35
9224: PPUSH
9225: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9229: LD_INT 22
9231: PUSH
9232: LD_INT 7
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 91
9241: PUSH
9242: LD_EXP 45
9246: PUSH
9247: LD_INT 8
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: PPUSH
9259: CALL_OW 69
9263: IFFALSE 9222
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9265: LD_ADDR_VAR 0 1
9269: PUSH
9270: LD_INT 22
9272: PUSH
9273: LD_INT 4
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 69
9284: PUSH
9285: FOR_IN
9286: IFFALSE 9302
// SetSide ( i , 7 ) ;
9288: LD_VAR 0 1
9292: PPUSH
9293: LD_INT 7
9295: PPUSH
9296: CALL_OW 235
9300: GO 9285
9302: POP
9303: POP
// ChangeMissionObjectives ( M3 ) ;
9304: LD_STRING M3
9306: PPUSH
9307: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9311: LD_INT 35
9313: PPUSH
9314: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9318: LD_EXP 14
9322: PPUSH
9323: LD_EXP 45
9327: PPUSH
9328: CALL_OW 296
9332: PUSH
9333: LD_INT 8
9335: LESS
9336: IFFALSE 9311
// ComTurnUnit ( JMM , Burlak ) ;
9338: LD_EXP 14
9342: PPUSH
9343: LD_EXP 45
9347: PPUSH
9348: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9352: LD_EXP 45
9356: PPUSH
9357: LD_EXP 14
9361: PPUSH
9362: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9366: LD_INT 10
9368: PPUSH
9369: CALL_OW 67
// DialogueOn ;
9373: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9377: LD_EXP 14
9381: PPUSH
9382: LD_STRING D11-JMM-1
9384: PPUSH
9385: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9389: LD_EXP 45
9393: PPUSH
9394: LD_STRING D11-Bur-1
9396: PPUSH
9397: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9401: LD_EXP 14
9405: PPUSH
9406: LD_STRING D11-JMM-2
9408: PPUSH
9409: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9413: LD_EXP 45
9417: PPUSH
9418: LD_STRING D11-Bur-2
9420: PPUSH
9421: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9425: LD_EXP 14
9429: PPUSH
9430: LD_STRING D11-JMM-3
9432: PPUSH
9433: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9437: LD_EXP 45
9441: PPUSH
9442: LD_STRING D11-Bur-3
9444: PPUSH
9445: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9449: LD_EXP 14
9453: PPUSH
9454: LD_STRING D11-JMM-4
9456: PPUSH
9457: CALL_OW 88
// if ar_base_spotted then
9461: LD_EXP 8
9465: IFFALSE 9481
// Say ( Burlak , D12-Bur-1 ) else
9467: LD_EXP 45
9471: PPUSH
9472: LD_STRING D12-Bur-1
9474: PPUSH
9475: CALL_OW 88
9479: GO 9520
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9481: LD_INT 7
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9491: LD_INT 127
9493: PPUSH
9494: LD_INT 45
9496: PPUSH
9497: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9501: LD_EXP 45
9505: PPUSH
9506: LD_STRING D12-Bur-1a
9508: PPUSH
9509: CALL_OW 88
// dwait ( 0 0$2 ) ;
9513: LD_INT 70
9515: PPUSH
9516: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9520: LD_EXP 45
9524: PPUSH
9525: LD_STRING D12-Bur-1b
9527: PPUSH
9528: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9532: LD_EXP 14
9536: PPUSH
9537: LD_STRING D12-JMM-1
9539: PPUSH
9540: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9544: LD_EXP 45
9548: PPUSH
9549: LD_STRING D12-Bur-2
9551: PPUSH
9552: CALL_OW 88
// if Roth then
9556: LD_EXP 15
9560: IFFALSE 9576
// Say ( Roth , D12-Roth-2 ) else
9562: LD_EXP 15
9566: PPUSH
9567: LD_STRING D12-Roth-2
9569: PPUSH
9570: CALL_OW 88
9574: GO 9588
// Say ( SciRu , D12-RSci1-2 ) ;
9576: CALL 12046 0 0
9580: PPUSH
9581: LD_STRING D12-RSci1-2
9583: PPUSH
9584: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9588: LD_EXP 14
9592: PPUSH
9593: LD_STRING D12-JMM-2
9595: PPUSH
9596: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9600: LD_EXP 45
9604: PPUSH
9605: LD_STRING D12-Bur-3
9607: PPUSH
9608: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9612: LD_EXP 14
9616: PPUSH
9617: LD_STRING D12-JMM-3
9619: PPUSH
9620: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9624: LD_EXP 45
9628: PPUSH
9629: LD_STRING D12-Bur-4
9631: PPUSH
9632: CALL_OW 88
// case Query ( QBase ) of 1 :
9636: LD_STRING QBase
9638: PPUSH
9639: CALL_OW 97
9643: PUSH
9644: LD_INT 1
9646: DOUBLE
9647: EQUAL
9648: IFTRUE 9652
9650: GO 9770
9652: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9653: LD_EXP 14
9657: PPUSH
9658: LD_STRING D13a-JMM-1
9660: PPUSH
9661: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9665: LD_EXP 45
9669: PPUSH
9670: LD_STRING D13a-Bur-1
9672: PPUSH
9673: CALL_OW 88
// if Roth then
9677: LD_EXP 15
9681: IFFALSE 9697
// Say ( Roth , D13a-Roth-1 ) else
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D13a-Roth-1
9690: PPUSH
9691: CALL_OW 88
9695: GO 9709
// Say ( SciRu , D13a-RSci1-1 ) ;
9697: CALL 12046 0 0
9701: PPUSH
9702: LD_STRING D13a-RSci1-1
9704: PPUSH
9705: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9709: LD_EXP 14
9713: PPUSH
9714: LD_STRING D13a-JMM-2
9716: PPUSH
9717: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9721: LD_STRING QBaseAgain
9723: PPUSH
9724: CALL_OW 97
9728: PUSH
9729: LD_INT 1
9731: DOUBLE
9732: EQUAL
9733: IFTRUE 9737
9735: GO 9748
9737: POP
// selected_option := 2 ; 2 :
9738: LD_ADDR_VAR 0 2
9742: PUSH
9743: LD_INT 2
9745: ST_TO_ADDR
9746: GO 9768
9748: LD_INT 2
9750: DOUBLE
9751: EQUAL
9752: IFTRUE 9756
9754: GO 9767
9756: POP
// selected_option := 3 ; end ;
9757: LD_ADDR_VAR 0 2
9761: PUSH
9762: LD_INT 3
9764: ST_TO_ADDR
9765: GO 9768
9767: POP
// end ; 2 :
9768: GO 9809
9770: LD_INT 2
9772: DOUBLE
9773: EQUAL
9774: IFTRUE 9778
9776: GO 9789
9778: POP
// selected_option := 2 ; 3 :
9779: LD_ADDR_VAR 0 2
9783: PUSH
9784: LD_INT 2
9786: ST_TO_ADDR
9787: GO 9809
9789: LD_INT 3
9791: DOUBLE
9792: EQUAL
9793: IFTRUE 9797
9795: GO 9808
9797: POP
// selected_option := 3 ; end ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 3
9805: ST_TO_ADDR
9806: GO 9809
9808: POP
// if selected_option = 2 then
9809: LD_VAR 0 2
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: IFFALSE 9911
// begin Say ( JMM , D13b-JMM-1 ) ;
9819: LD_EXP 14
9823: PPUSH
9824: LD_STRING D13b-JMM-1
9826: PPUSH
9827: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
9831: LD_EXP 45
9835: PPUSH
9836: LD_STRING D13b-Bur-1
9838: PPUSH
9839: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
9843: LD_EXP 14
9847: PPUSH
9848: LD_STRING D13b-JMM-2
9850: PPUSH
9851: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
9855: LD_EXP 54
9859: PPUSH
9860: LD_STRING D13b-Abd-2
9862: PPUSH
9863: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
9867: LD_EXP 14
9871: PPUSH
9872: LD_STRING D13b-JMM-3
9874: PPUSH
9875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
9879: LD_EXP 54
9883: PPUSH
9884: LD_STRING D13b-Abd-3
9886: PPUSH
9887: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
9891: LD_EXP 14
9895: PPUSH
9896: LD_STRING D13b-JMM-4
9898: PPUSH
9899: CALL_OW 88
// ar_active_attack := true ;
9903: LD_ADDR_EXP 9
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// end ; if selected_option = 3 then
9911: LD_VAR 0 2
9915: PUSH
9916: LD_INT 3
9918: EQUAL
9919: IFFALSE 9945
// begin Say ( JMM , D13c-JMM-1 ) ;
9921: LD_EXP 14
9925: PPUSH
9926: LD_STRING D13c-JMM-1
9928: PPUSH
9929: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
9933: LD_EXP 45
9937: PPUSH
9938: LD_STRING D13c-Bur-1
9940: PPUSH
9941: CALL_OW 88
// end ; DialogueOff ;
9945: CALL_OW 7
// if not ar_active_attack then
9949: LD_EXP 9
9953: NOT
9954: IFFALSE 9971
// begin wait ( 6 6$00 ) ;
9956: LD_INT 12600
9958: PPUSH
9959: CALL_OW 67
// ar_active_attack := true ;
9963: LD_ADDR_EXP 9
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// end ; end ;
9971: PPOPN 2
9973: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do
9974: LD_EXP 45
9978: PPUSH
9979: CALL_OW 305
9983: PUSH
9984: LD_EXP 45
9988: PPUSH
9989: CALL_OW 255
9993: PUSH
9994: LD_INT 7
9996: EQUAL
9997: AND
9998: IFFALSE 10159
10000: GO 10002
10002: DISABLE
// begin wait ( 4 4$40 ) ;
10003: LD_INT 9800
10005: PPUSH
10006: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10010: LD_INT 35
10012: PPUSH
10013: CALL_OW 67
// until not ru_attackers ;
10017: LD_EXP 51
10021: NOT
10022: IFFALSE 10010
// PrepareGnyevko ;
10024: CALL 1990 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10028: LD_EXP 47
10032: PPUSH
10033: LD_INT 124
10035: PPUSH
10036: LD_INT 118
10038: PPUSH
10039: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10043: LD_EXP 47
10047: PPUSH
10048: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10052: LD_INT 35
10054: PPUSH
10055: CALL_OW 67
// until IsAt ( Gnyevko , 124 , 118 ) ;
10059: LD_EXP 47
10063: PPUSH
10064: LD_INT 124
10066: PPUSH
10067: LD_INT 118
10069: PPUSH
10070: CALL_OW 307
10074: IFFALSE 10052
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10076: LD_EXP 47
10080: PPUSH
10081: LD_STRING DBelkov-Gny-1
10083: PPUSH
10084: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10088: LD_EXP 45
10092: PPUSH
10093: LD_STRING DBelkov-Bur-1a
10095: PPUSH
10096: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10100: LD_INT 35
10102: PPUSH
10103: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10107: LD_EXP 47
10111: PPUSH
10112: LD_INT 22
10114: PUSH
10115: LD_INT 7
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PPUSH
10122: CALL_OW 69
10126: PPUSH
10127: LD_EXP 47
10131: PPUSH
10132: CALL_OW 74
10136: PPUSH
10137: CALL_OW 296
10141: PUSH
10142: LD_INT 8
10144: LESS
10145: IFFALSE 10100
// SetSide ( Gnyevko , 7 ) ;
10147: LD_EXP 47
10151: PPUSH
10152: LD_INT 7
10154: PPUSH
10155: CALL_OW 235
// end ;
10159: END
// every 10 10$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10160: LD_EXP 45
10164: PPUSH
10165: CALL_OW 255
10169: PUSH
10170: LD_INT 7
10172: EQUAL
10173: IFFALSE 10183
10175: GO 10177
10177: DISABLE
// begin enable ;
10178: ENABLE
// PrepareAmericanAttack ;
10179: CALL 6285 0 0
// end ;
10183: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10184: LD_INT 22
10186: PUSH
10187: LD_INT 1
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10382
10200: GO 10202
10202: DISABLE
10203: LD_INT 0
10205: PPUSH
10206: PPUSH
// begin while true do
10207: LD_INT 1
10209: IFFALSE 10266
// begin wait ( 0 0$1 ) ;
10211: LD_INT 35
10213: PPUSH
10214: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10218: LD_ADDR_VAR 0 2
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_INT 1
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PPUSH
10233: CALL_OW 69
10237: PPUSH
10238: LD_EXP 14
10242: PPUSH
10243: CALL_OW 74
10247: ST_TO_ADDR
// if See ( 7 , tmp ) then
10248: LD_INT 7
10250: PPUSH
10251: LD_VAR 0 2
10255: PPUSH
10256: CALL_OW 292
10260: IFFALSE 10264
// break ;
10262: GO 10266
// end ;
10264: GO 10207
// DialogueOn ;
10266: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10270: LD_VAR 0 2
10274: PPUSH
10275: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10279: LD_VAR 0 2
10283: PPUSH
10284: CALL_OW 250
10288: PPUSH
10289: LD_VAR 0 2
10293: PPUSH
10294: CALL_OW 251
10298: PPUSH
10299: LD_INT 7
10301: PPUSH
10302: LD_INT 8
10304: PPUSH
10305: CALL_OW 330
// if Denis then
10309: LD_EXP 20
10313: IFFALSE 10327
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10315: LD_EXP 20
10319: PPUSH
10320: LD_STRING DAmerAttack-Pet-1
10322: PPUSH
10323: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10327: LD_EXP 14
10331: PPUSH
10332: LD_STRING DAmerAttack-JMM-1
10334: PPUSH
10335: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10339: LD_EXP 45
10343: PPUSH
10344: LD_STRING DStop-Bur-1
10346: PPUSH
10347: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10351: LD_VAR 0 2
10355: PPUSH
10356: CALL_OW 250
10360: PPUSH
10361: LD_VAR 0 2
10365: PPUSH
10366: CALL_OW 251
10370: PPUSH
10371: LD_INT 7
10373: PPUSH
10374: CALL_OW 331
// DialogueOff ;
10378: CALL_OW 7
// end ;
10382: PPOPN 2
10384: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10385: LD_INT 22
10387: PUSH
10388: LD_INT 3
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 1
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PPUSH
10409: CALL_OW 69
10413: PUSH
10414: LD_INT 0
10416: EQUAL
10417: IFFALSE 10459
10419: GO 10421
10421: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10422: LD_STRING M5a
10424: PPUSH
10425: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10429: LD_EXP 14
10433: PPUSH
10434: LD_STRING D8-JMM-1
10436: PPUSH
10437: CALL_OW 88
// if Gossudarov then
10441: LD_EXP 31
10445: IFFALSE 10459
// Say ( Gossudarov , D8-Gos-1 ) ;
10447: LD_EXP 31
10451: PPUSH
10452: LD_STRING D8-Gos-1
10454: PPUSH
10455: CALL_OW 88
// end ;
10459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10460: LD_INT 22
10462: PUSH
10463: LD_INT 2
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: LD_INT 21
10472: PUSH
10473: LD_INT 1
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 69
10488: PUSH
10489: LD_INT 0
10491: EQUAL
10492: IFFALSE 10542
10494: GO 10496
10496: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10497: LD_STRING M4c
10499: PPUSH
10500: CALL_OW 337
// if Roth then
10504: LD_EXP 15
10508: IFFALSE 10524
// Say ( Roth , DStop-Roth-1 ) else
10510: LD_EXP 15
10514: PPUSH
10515: LD_STRING DStop-Roth-1
10517: PPUSH
10518: CALL_OW 88
10522: GO 10542
// if Gossudarov then
10524: LD_EXP 31
10528: IFFALSE 10542
// Say ( Gossudarov , D8-Gos-1a ) ;
10530: LD_EXP 31
10534: PPUSH
10535: LD_STRING D8-Gos-1a
10537: PPUSH
10538: CALL_OW 88
// end ;
10542: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10543: LD_INT 7
10545: PPUSH
10546: LD_INT 1
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 13578 0 3
10556: PUSH
10557: LD_INT 0
10559: EQUAL
10560: PUSH
10561: LD_INT 7
10563: PPUSH
10564: LD_INT 3
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 13578 0 3
10574: PUSH
10575: LD_INT 0
10577: EQUAL
10578: AND
10579: IFFALSE 10591
10581: GO 10583
10583: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10584: LD_STRING M1a
10586: PPUSH
10587: CALL_OW 337
// end ;
10591: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 3 ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10592: LD_INT 22
10594: PUSH
10595: LD_INT 2
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: LD_INT 21
10604: PUSH
10605: LD_INT 1
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 69
10620: PUSH
10621: LD_INT 0
10623: EQUAL
10624: PUSH
10625: LD_INT 22
10627: PUSH
10628: LD_INT 3
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PPUSH
10635: CALL_OW 69
10639: PUSH
10640: LD_INT 0
10642: EQUAL
10643: AND
10644: PUSH
10645: LD_INT 22
10647: PUSH
10648: LD_INT 1
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 69
10659: PUSH
10660: LD_INT 0
10662: EQUAL
10663: AND
10664: PUSH
10665: LD_INT 7
10667: PPUSH
10668: LD_INT 1
10670: PPUSH
10671: LD_INT 1
10673: PPUSH
10674: CALL 13578 0 3
10678: PUSH
10679: LD_INT 0
10681: EQUAL
10682: AND
10683: PUSH
10684: LD_INT 7
10686: PPUSH
10687: LD_INT 3
10689: PPUSH
10690: LD_INT 1
10692: PPUSH
10693: CALL 13578 0 3
10697: PUSH
10698: LD_INT 0
10700: EQUAL
10701: AND
10702: IFFALSE 12043
10704: GO 10706
10706: DISABLE
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// begin wait ( 0 0$3 ) ;
10712: LD_INT 105
10714: PPUSH
10715: CALL_OW 67
// if not IsDead ( Masha ) then
10719: LD_EXP 48
10723: PPUSH
10724: CALL_OW 301
10728: NOT
10729: IFFALSE 10743
// AddMedal ( Masha , 1 ) else
10731: LD_STRING Masha
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 101
10741: GO 10754
// AddMedal ( Masha , - 1 ) ;
10743: LD_STRING Masha
10745: PPUSH
10746: LD_INT 1
10748: NEG
10749: PPUSH
10750: CALL_OW 101
// if abdul_escaped then
10754: LD_EXP 12
10758: IFFALSE 10773
// AddMedal ( Abdul , - 1 ) else
10760: LD_STRING Abdul
10762: PPUSH
10763: LD_INT 1
10765: NEG
10766: PPUSH
10767: CALL_OW 101
10771: GO 10783
// AddMedal ( Abdul , 1 ) ;
10773: LD_STRING Abdul
10775: PPUSH
10776: LD_INT 1
10778: PPUSH
10779: CALL_OW 101
// if loss_counter = 0 then
10783: LD_EXP 13
10787: PUSH
10788: LD_INT 0
10790: EQUAL
10791: IFFALSE 10805
// AddMedal ( People , 2 ) else
10793: LD_STRING People
10795: PPUSH
10796: LD_INT 2
10798: PPUSH
10799: CALL_OW 101
10803: GO 10855
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
10805: LD_EXP 13
10809: PUSH
10810: LD_INT 3
10812: PUSH
10813: LD_INT 2
10815: PUSH
10816: LD_INT 2
10818: PUSH
10819: EMPTY
10820: LIST
10821: LIST
10822: LIST
10823: PUSH
10824: LD_OWVAR 67
10828: ARRAY
10829: LESSEQUAL
10830: IFFALSE 10844
// AddMedal ( People , 1 ) else
10832: LD_STRING People
10834: PPUSH
10835: LD_INT 1
10837: PPUSH
10838: CALL_OW 101
10842: GO 10855
// AddMedal ( People , - 1 ) ;
10844: LD_STRING People
10846: PPUSH
10847: LD_INT 1
10849: NEG
10850: PPUSH
10851: CALL_OW 101
// GiveMedals ( MAIN ) ;
10855: LD_STRING MAIN
10857: PPUSH
10858: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
10862: LD_ADDR_VAR 0 2
10866: PUSH
10867: LD_INT 22
10869: PUSH
10870: LD_INT 7
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: PUSH
10877: LD_INT 2
10879: PUSH
10880: LD_INT 25
10882: PUSH
10883: LD_INT 1
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PUSH
10890: LD_INT 25
10892: PUSH
10893: LD_INT 2
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PUSH
10900: LD_INT 25
10902: PUSH
10903: LD_INT 3
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PUSH
10910: LD_INT 25
10912: PUSH
10913: LD_INT 4
10915: PUSH
10916: EMPTY
10917: LIST
10918: LIST
10919: PUSH
10920: LD_INT 25
10922: PUSH
10923: LD_INT 5
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: LD_INT 25
10932: PUSH
10933: LD_INT 8
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: PUSH
10940: LD_INT 25
10942: PUSH
10943: LD_INT 9
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: LIST
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PPUSH
10964: CALL_OW 69
10968: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
10978: LD_ADDR_VAR 0 3
10982: PUSH
10983: LD_EXP 14
10987: PUSH
10988: LD_EXP 15
10992: PUSH
10993: LD_EXP 16
10997: PUSH
10998: LD_EXP 17
11002: PUSH
11003: LD_EXP 18
11007: PUSH
11008: LD_EXP 19
11012: PUSH
11013: LD_EXP 20
11017: PUSH
11018: LD_EXP 21
11022: PUSH
11023: LD_EXP 22
11027: PUSH
11028: LD_EXP 23
11032: PUSH
11033: LD_EXP 24
11037: PUSH
11038: LD_EXP 25
11042: PUSH
11043: LD_EXP 26
11047: PUSH
11048: LD_EXP 27
11052: PUSH
11053: LD_EXP 28
11057: PUSH
11058: LD_EXP 29
11062: PUSH
11063: LD_EXP 30
11067: PUSH
11068: LD_EXP 31
11072: PUSH
11073: LD_EXP 32
11077: PUSH
11078: LD_EXP 33
11082: PUSH
11083: LD_EXP 35
11087: PUSH
11088: LD_EXP 36
11092: PUSH
11093: LD_EXP 37
11097: PUSH
11098: LD_EXP 38
11102: PUSH
11103: LD_EXP 39
11107: PUSH
11108: LD_EXP 40
11112: PUSH
11113: LD_EXP 41
11117: PUSH
11118: LD_EXP 42
11122: PUSH
11123: LD_EXP 43
11127: PUSH
11128: LD_EXP 44
11132: PUSH
11133: LD_EXP 45
11137: PUSH
11138: LD_EXP 46
11142: PUSH
11143: LD_EXP 47
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: LIST
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: ST_TO_ADDR
// if tmp diff tmp2 then
11183: LD_VAR 0 2
11187: PUSH
11188: LD_VAR 0 3
11192: DIFF
11193: IFFALSE 11213
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11195: LD_VAR 0 2
11199: PUSH
11200: LD_VAR 0 3
11204: DIFF
11205: PPUSH
11206: LD_STRING 13a_others
11208: PPUSH
11209: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11213: LD_EXP 14
11217: PPUSH
11218: LD_STRING 13a_JMM
11220: PPUSH
11221: CALL_OW 38
// if Titov then
11225: LD_EXP 33
11229: IFFALSE 11243
// SaveCharacters ( Titov , 13a_Titov ) ;
11231: LD_EXP 33
11235: PPUSH
11236: LD_STRING 13a_Titov
11238: PPUSH
11239: CALL_OW 38
// if Dolgov then
11243: LD_EXP 35
11247: IFFALSE 11261
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11249: LD_EXP 35
11253: PPUSH
11254: LD_STRING 13a_Dolgov
11256: PPUSH
11257: CALL_OW 38
// if Petrosyan then
11261: LD_EXP 36
11265: IFFALSE 11279
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11267: LD_EXP 36
11271: PPUSH
11272: LD_STRING 13a_Petrosyan
11274: PPUSH
11275: CALL_OW 38
// if Scholtze then
11279: LD_EXP 37
11283: IFFALSE 11297
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11285: LD_EXP 37
11289: PPUSH
11290: LD_STRING 13a_Scholtze
11292: PPUSH
11293: CALL_OW 38
// if Oblukov then
11297: LD_EXP 38
11301: IFFALSE 11315
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11303: LD_EXP 38
11307: PPUSH
11308: LD_STRING 13a_Oblukov
11310: PPUSH
11311: CALL_OW 38
// if Kapitsova then
11315: LD_EXP 39
11319: IFFALSE 11333
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11321: LD_EXP 39
11325: PPUSH
11326: LD_STRING 13a_Kapitsova
11328: PPUSH
11329: CALL_OW 38
// if Lipshchin then
11333: LD_EXP 40
11337: IFFALSE 11351
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11339: LD_EXP 40
11343: PPUSH
11344: LD_STRING 13a_Lipshchin
11346: PPUSH
11347: CALL_OW 38
// if Petrovova then
11351: LD_EXP 41
11355: IFFALSE 11369
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11357: LD_EXP 41
11361: PPUSH
11362: LD_STRING 13a_Petrovova
11364: PPUSH
11365: CALL_OW 38
// if Kovalyuk then
11369: LD_EXP 42
11373: IFFALSE 11387
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11375: LD_EXP 42
11379: PPUSH
11380: LD_STRING 13a_Kovalyuk
11382: PPUSH
11383: CALL_OW 38
// if Kuzmov then
11387: LD_EXP 43
11391: IFFALSE 11405
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11393: LD_EXP 43
11397: PPUSH
11398: LD_STRING 13a_Kuzmov
11400: PPUSH
11401: CALL_OW 38
// if Karamazov then
11405: LD_EXP 44
11409: IFFALSE 11423
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11411: LD_EXP 44
11415: PPUSH
11416: LD_STRING 13a_Karamazov
11418: PPUSH
11419: CALL_OW 38
// if Burlak then
11423: LD_EXP 45
11427: IFFALSE 11441
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11429: LD_EXP 45
11433: PPUSH
11434: LD_STRING 13a_Burlak
11436: PPUSH
11437: CALL_OW 38
// if Belkov then
11441: LD_EXP 46
11445: IFFALSE 11459
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11447: LD_EXP 46
11451: PPUSH
11452: LD_STRING 13a_Belkov
11454: PPUSH
11455: CALL_OW 38
// if Gnyevko then
11459: LD_EXP 47
11463: IFFALSE 11477
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11465: LD_EXP 47
11469: PPUSH
11470: LD_STRING 13a_Gnyevko
11472: PPUSH
11473: CALL_OW 38
// if Lisa then
11477: LD_EXP 16
11481: IFFALSE 11495
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11483: LD_EXP 16
11487: PPUSH
11488: LD_STRING 13a_Lisa
11490: PPUSH
11491: CALL_OW 38
// if Donaldson then
11495: LD_EXP 17
11499: IFFALSE 11513
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11501: LD_EXP 17
11505: PPUSH
11506: LD_STRING 13a_Donaldson
11508: PPUSH
11509: CALL_OW 38
// if Bobby then
11513: LD_EXP 18
11517: IFFALSE 11531
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11519: LD_EXP 18
11523: PPUSH
11524: LD_STRING 13a_Bobby
11526: PPUSH
11527: CALL_OW 38
// if Cyrus then
11531: LD_EXP 19
11535: IFFALSE 11549
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11537: LD_EXP 19
11541: PPUSH
11542: LD_STRING 13a_Cyrus
11544: PPUSH
11545: CALL_OW 38
// if Denis then
11549: LD_EXP 20
11553: IFFALSE 11567
// SaveCharacters ( Denis , 13a_Denis ) ;
11555: LD_EXP 20
11559: PPUSH
11560: LD_STRING 13a_Denis
11562: PPUSH
11563: CALL_OW 38
// if Brown then
11567: LD_EXP 21
11571: IFFALSE 11585
// SaveCharacters ( Brown , 13a_Brown ) ;
11573: LD_EXP 21
11577: PPUSH
11578: LD_STRING 13a_Brown
11580: PPUSH
11581: CALL_OW 38
// if Gladstone then
11585: LD_EXP 22
11589: IFFALSE 11603
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11591: LD_EXP 22
11595: PPUSH
11596: LD_STRING 13a_Gladstone
11598: PPUSH
11599: CALL_OW 38
// if Houten then
11603: LD_EXP 23
11607: IFFALSE 11621
// SaveCharacters ( Houten , 13a_Houten ) ;
11609: LD_EXP 23
11613: PPUSH
11614: LD_STRING 13a_Houten
11616: PPUSH
11617: CALL_OW 38
// if Cornel then
11621: LD_EXP 24
11625: IFFALSE 11639
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11627: LD_EXP 24
11631: PPUSH
11632: LD_STRING 13a_Cornel
11634: PPUSH
11635: CALL_OW 38
// if Gary then
11639: LD_EXP 25
11643: IFFALSE 11657
// SaveCharacters ( Gary , 13a_Gary ) ;
11645: LD_EXP 25
11649: PPUSH
11650: LD_STRING 13a_Gary
11652: PPUSH
11653: CALL_OW 38
// if Frank then
11657: LD_EXP 26
11661: IFFALSE 11675
// SaveCharacters ( Frank , 13a_Frank ) ;
11663: LD_EXP 26
11667: PPUSH
11668: LD_STRING 13a_Frank
11670: PPUSH
11671: CALL_OW 38
// if Kikuchi then
11675: LD_EXP 27
11679: IFFALSE 11693
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11681: LD_EXP 27
11685: PPUSH
11686: LD_STRING 13a_Kikuchi
11688: PPUSH
11689: CALL_OW 38
// if Simms then
11693: LD_EXP 28
11697: IFFALSE 11711
// SaveCharacters ( Simms , 13a_Simms ) ;
11699: LD_EXP 28
11703: PPUSH
11704: LD_STRING 13a_Simms
11706: PPUSH
11707: CALL_OW 38
// if Joan then
11711: LD_EXP 29
11715: IFFALSE 11729
// SaveCharacters ( Joan , 13a_Joan ) ;
11717: LD_EXP 29
11721: PPUSH
11722: LD_STRING 13a_Joan
11724: PPUSH
11725: CALL_OW 38
// if DeltaDoctor then
11729: LD_EXP 30
11733: IFFALSE 11747
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
11735: LD_EXP 30
11739: PPUSH
11740: LD_STRING 13a_DeltaDoctor
11742: PPUSH
11743: CALL_OW 38
// if Gossudarov then
11747: LD_EXP 31
11751: IFFALSE 11765
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
11753: LD_EXP 31
11757: PPUSH
11758: LD_STRING 13a_Gossudarov
11760: PPUSH
11761: CALL_OW 38
// if Kirilenkova then
11765: LD_EXP 32
11769: IFFALSE 11783
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
11771: LD_EXP 32
11775: PPUSH
11776: LD_STRING 13a_Kirilenkova
11778: PPUSH
11779: CALL_OW 38
// if Masha then
11783: LD_EXP 48
11787: IFFALSE 11842
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
11789: LD_EXP 48
11793: PPUSH
11794: CALL_OW 265
11798: PUSH
11799: LD_EXP 48
11803: PPUSH
11804: CALL_OW 262
11808: PUSH
11809: LD_EXP 48
11813: PPUSH
11814: CALL_OW 263
11818: PUSH
11819: LD_EXP 48
11823: PPUSH
11824: CALL_OW 264
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: PPUSH
11835: LD_STRING 13a_Masha
11837: PPUSH
11838: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
11842: LD_ADDR_VAR 0 2
11846: PUSH
11847: LD_INT 21
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: ST_TO_ADDR
// tmp2 := [ ] ;
11862: LD_ADDR_VAR 0 3
11866: PUSH
11867: EMPTY
11868: ST_TO_ADDR
// if tmp then
11869: LD_VAR 0 2
11873: IFFALSE 12021
// for i in tmp do
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_VAR 0 2
11884: PUSH
11885: FOR_IN
11886: IFFALSE 12019
// tmp2 := tmp2 ^ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: LD_VAR 0 1
11902: PPUSH
11903: CALL_OW 255
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL_OW 248
11917: PUSH
11918: LD_VAR 0 1
11922: PPUSH
11923: CALL_OW 266
11927: PUSH
11928: LD_VAR 0 1
11932: PPUSH
11933: CALL_OW 250
11937: PUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 251
11947: PUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 254
11957: PUSH
11958: LD_VAR 0 1
11962: PPUSH
11963: CALL_OW 267
11967: PUSH
11968: LD_VAR 0 1
11972: PPUSH
11973: LD_INT 1
11975: PPUSH
11976: CALL_OW 268
11980: PUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: LD_INT 2
11988: PPUSH
11989: CALL_OW 268
11993: PUSH
11994: LD_VAR 0 1
11998: PPUSH
11999: CALL_OW 269
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: ADD
12016: ST_TO_ADDR
12017: GO 11885
12019: POP
12020: POP
// if tmp2 then
12021: LD_VAR 0 3
12025: IFFALSE 12039
// SaveVariable ( tmp2 , 13a_buildings ) ;
12027: LD_VAR 0 3
12031: PPUSH
12032: LD_STRING 13a_buildings
12034: PPUSH
12035: CALL_OW 39
// YouWin ;
12039: CALL_OW 103
// end ;
12043: PPOPN 3
12045: END
// export function SciRu ; var tmp , t ; begin
12046: LD_INT 0
12048: PPUSH
12049: PPUSH
12050: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12051: LD_ADDR_VAR 0 3
12055: PUSH
12056: LD_EXP 31
12060: PUSH
12061: LD_EXP 45
12065: PUSH
12066: LD_EXP 33
12070: PUSH
12071: LD_EXP 46
12075: PUSH
12076: LD_EXP 47
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12088: LD_ADDR_VAR 0 2
12092: PUSH
12093: LD_INT 22
12095: PUSH
12096: LD_INT 7
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 23
12105: PUSH
12106: LD_INT 3
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 4
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 26
12125: PUSH
12126: LD_INT 1
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: PPUSH
12139: CALL_OW 69
12143: PUSH
12144: LD_VAR 0 3
12148: DIFF
12149: ST_TO_ADDR
// if tmp then
12150: LD_VAR 0 2
12154: IFFALSE 12170
// result := tmp [ 1 ] ;
12156: LD_ADDR_VAR 0 1
12160: PUSH
12161: LD_VAR 0 2
12165: PUSH
12166: LD_INT 1
12168: ARRAY
12169: ST_TO_ADDR
// end ;
12170: LD_VAR 0 1
12174: RET
// export function SolRu ; var tmp , t ; begin
12175: LD_INT 0
12177: PPUSH
12178: PPUSH
12179: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12180: LD_ADDR_VAR 0 3
12184: PUSH
12185: LD_EXP 46
12189: PUSH
12190: LD_EXP 45
12194: PUSH
12195: LD_EXP 31
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: LIST
12204: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12205: LD_ADDR_VAR 0 2
12209: PUSH
12210: LD_INT 22
12212: PUSH
12213: LD_INT 7
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 23
12222: PUSH
12223: LD_INT 3
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: LD_INT 25
12232: PUSH
12233: LD_INT 1
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: PUSH
12240: LD_INT 26
12242: PUSH
12243: LD_INT 1
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PUSH
12250: EMPTY
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: PPUSH
12256: CALL_OW 69
12260: PUSH
12261: LD_VAR 0 3
12265: DIFF
12266: ST_TO_ADDR
// if tmp then
12267: LD_VAR 0 2
12271: IFFALSE 12287
// result := tmp [ 1 ] ;
12273: LD_ADDR_VAR 0 1
12277: PUSH
12278: LD_VAR 0 2
12282: PUSH
12283: LD_INT 1
12285: ARRAY
12286: ST_TO_ADDR
// end ; end_of_file
12287: LD_VAR 0 1
12291: RET
// export function CustomEvent ( event ) ; begin
12292: LD_INT 0
12294: PPUSH
// end ;
12295: LD_VAR 0 2
12299: RET
// on UnitDestroyed ( un ) do var i , side ;
12300: LD_INT 0
12302: PPUSH
12303: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12304: LD_VAR 0 1
12308: PUSH
12309: LD_INT 22
12311: PUSH
12312: LD_INT 7
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 2
12321: PUSH
12322: LD_INT 25
12324: PUSH
12325: LD_INT 1
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: LD_INT 25
12334: PUSH
12335: LD_INT 2
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PUSH
12342: LD_INT 25
12344: PUSH
12345: LD_INT 3
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: PUSH
12352: LD_INT 25
12354: PUSH
12355: LD_INT 4
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PUSH
12362: LD_INT 25
12364: PUSH
12365: LD_INT 5
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: LD_INT 25
12374: PUSH
12375: LD_INT 8
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 25
12384: PUSH
12385: LD_INT 9
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PPUSH
12406: CALL_OW 69
12410: IN
12411: IFFALSE 12427
// loss_counter := loss_counter + 1 ;
12413: LD_ADDR_EXP 13
12417: PUSH
12418: LD_EXP 13
12422: PUSH
12423: LD_INT 1
12425: PLUS
12426: ST_TO_ADDR
// if un = Abdul then
12427: LD_VAR 0 1
12431: PUSH
12432: LD_EXP 54
12436: EQUAL
12437: IFFALSE 12447
// abdul_escaped := false ;
12439: LD_ADDR_EXP 12
12443: PUSH
12444: LD_INT 0
12446: ST_TO_ADDR
// if un in ru_attackers then
12447: LD_VAR 0 1
12451: PUSH
12452: LD_EXP 51
12456: IN
12457: IFFALSE 12475
// ru_attackers := ru_attackers diff un ;
12459: LD_ADDR_EXP 51
12463: PUSH
12464: LD_EXP 51
12468: PUSH
12469: LD_VAR 0 1
12473: DIFF
12474: ST_TO_ADDR
// if un in ar_attackers then
12475: LD_VAR 0 1
12479: PUSH
12480: LD_EXP 10
12484: IN
12485: IFFALSE 12503
// ar_attackers := ar_attackers diff un ;
12487: LD_ADDR_EXP 10
12491: PUSH
12492: LD_EXP 10
12496: PUSH
12497: LD_VAR 0 1
12501: DIFF
12502: ST_TO_ADDR
// if un = JMM then
12503: LD_VAR 0 1
12507: PUSH
12508: LD_EXP 14
12512: EQUAL
12513: IFFALSE 12524
// begin YouLost ( JMM ) ;
12515: LD_STRING JMM
12517: PPUSH
12518: CALL_OW 104
// exit ;
12522: GO 12613
// end ; if un = Burlak then
12524: LD_VAR 0 1
12528: PUSH
12529: LD_EXP 45
12533: EQUAL
12534: IFFALSE 12545
// begin YouLost ( Burlak ) ;
12536: LD_STRING Burlak
12538: PPUSH
12539: CALL_OW 104
// exit ;
12543: GO 12613
// end ; if un = freedom then
12545: LD_VAR 0 1
12549: PUSH
12550: LD_EXP 3
12554: EQUAL
12555: IFFALSE 12566
// begin YouLost ( Destroyed ) ;
12557: LD_STRING Destroyed
12559: PPUSH
12560: CALL_OW 104
// exit ;
12564: GO 12613
// end ; if un = Masha then
12566: LD_VAR 0 1
12570: PUSH
12571: LD_EXP 48
12575: EQUAL
12576: IFFALSE 12585
// ChangeMissionObjectives ( M4b ) ;
12578: LD_STRING M4b
12580: PPUSH
12581: CALL_OW 337
// if un = Mastodont then
12585: LD_VAR 0 1
12589: PUSH
12590: LD_EXP 55
12594: EQUAL
12595: IFFALSE 12604
// ChangeMissionObjectives ( M4a ) ;
12597: LD_STRING M4a
12599: PPUSH
12600: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: CALL 80936 0 1
// end ;
12613: PPOPN 3
12615: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12616: LD_VAR 0 1
12620: PPUSH
12621: LD_VAR 0 2
12625: PPUSH
12626: CALL 82821 0 2
// end ;
12630: PPOPN 2
12632: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL 81903 0 1
// end ;
12642: PPOPN 1
12644: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12645: LD_VAR 0 1
12649: PUSH
12650: LD_INT 22
12652: PUSH
12653: LD_INT 7
12655: PUSH
12656: EMPTY
12657: LIST
12658: LIST
12659: PUSH
12660: LD_INT 30
12662: PUSH
12663: LD_INT 0
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: PPUSH
12674: CALL_OW 69
12678: IN
12679: IFFALSE 12718
// begin SetBName ( building , freedom ) ;
12681: LD_VAR 0 1
12685: PPUSH
12686: LD_STRING freedom
12688: PPUSH
12689: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12693: LD_INT 0
12695: PPUSH
12696: LD_INT 7
12698: PPUSH
12699: LD_INT 0
12701: PPUSH
12702: CALL_OW 324
// freedom := building ;
12706: LD_ADDR_EXP 3
12710: PUSH
12711: LD_VAR 0 1
12715: ST_TO_ADDR
// exit ;
12716: GO 12784
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
12718: LD_VAR 0 1
12722: PUSH
12723: LD_INT 22
12725: PUSH
12726: LD_INT 7
12728: PUSH
12729: EMPTY
12730: LIST
12731: LIST
12732: PUSH
12733: LD_INT 23
12735: PUSH
12736: LD_INT 3
12738: PUSH
12739: EMPTY
12740: LIST
12741: LIST
12742: PUSH
12743: LD_INT 30
12745: PUSH
12746: LD_INT 6
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: LIST
12757: PPUSH
12758: CALL_OW 69
12762: IN
12763: IFFALSE 12775
// begin ru_lab_builded := true ;
12765: LD_ADDR_EXP 5
12769: PUSH
12770: LD_INT 1
12772: ST_TO_ADDR
// exit ;
12773: GO 12784
// end ; MCE_BuildingComplete ( building ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: CALL 82137 0 1
// end ;
12784: PPOPN 1
12786: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12787: LD_VAR 0 1
12791: PPUSH
12792: LD_VAR 0 2
12796: PPUSH
12797: CALL 80648 0 2
// end ;
12801: PPOPN 2
12803: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: LD_VAR 0 4
12823: PPUSH
12824: LD_VAR 0 5
12828: PPUSH
12829: CALL 80275 0 5
// end ;
12833: PPOPN 5
12835: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12836: LD_VAR 0 1
12840: PPUSH
12841: LD_VAR 0 2
12845: PPUSH
12846: CALL 79872 0 2
// end ;
12850: PPOPN 2
12852: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12853: LD_VAR 0 1
12857: PPUSH
12858: LD_VAR 0 2
12862: PPUSH
12863: LD_VAR 0 3
12867: PPUSH
12868: LD_VAR 0 4
12872: PPUSH
12873: CALL 79717 0 4
// end ;
12877: PPOPN 4
12879: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12880: LD_VAR 0 1
12884: PPUSH
12885: LD_VAR 0 2
12889: PPUSH
12890: LD_VAR 0 3
12894: PPUSH
12895: CALL 79499 0 3
// end ;
12899: PPOPN 3
12901: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12902: LD_VAR 0 1
12906: PPUSH
12907: LD_VAR 0 2
12911: PPUSH
12912: CALL 79391 0 2
// end ;
12916: PPOPN 2
12918: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12919: LD_VAR 0 1
12923: PPUSH
12924: LD_VAR 0 2
12928: PPUSH
12929: CALL 83075 0 2
// end ;
12933: PPOPN 2
12935: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12936: LD_VAR 0 1
12940: PPUSH
12941: LD_VAR 0 2
12945: PPUSH
12946: LD_VAR 0 3
12950: PPUSH
12951: LD_VAR 0 4
12955: PPUSH
12956: CALL 83284 0 4
// end ;
12960: PPOPN 4
12962: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12963: LD_VAR 0 1
12967: PPUSH
12968: LD_VAR 0 2
12972: PPUSH
12973: CALL 79207 0 2
// end ; end_of_file
12977: PPOPN 2
12979: END
// every 0 0$30 do var cr , time ;
12980: GO 12982
12982: DISABLE
12983: LD_INT 0
12985: PPUSH
12986: PPUSH
// begin time := 0 0$10 ;
12987: LD_ADDR_VAR 0 2
12991: PUSH
12992: LD_INT 350
12994: ST_TO_ADDR
// while game do
12995: LD_EXP 2
12999: IFFALSE 13098
// begin wait ( time ) ;
13001: LD_VAR 0 2
13005: PPUSH
13006: CALL_OW 67
// if tick > 2 2$00 then
13010: LD_OWVAR 1
13014: PUSH
13015: LD_INT 4200
13017: GREATER
13018: IFFALSE 13051
// time := time + [ 0 0$06 , 0 0$07 , 0 0$08 ] [ Difficulty ] ;
13020: LD_ADDR_VAR 0 2
13024: PUSH
13025: LD_VAR 0 2
13029: PUSH
13030: LD_INT 210
13032: PUSH
13033: LD_INT 245
13035: PUSH
13036: LD_INT 280
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: PUSH
13044: LD_OWVAR 67
13048: ARRAY
13049: PLUS
13050: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13051: LD_INT 1
13053: PPUSH
13054: LD_INT 5
13056: PPUSH
13057: CALL_OW 12
13061: PPUSH
13062: LD_INT 70
13064: PPUSH
13065: LD_INT 49
13067: PPUSH
13068: LD_INT 25
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 56
// if time > 5 5$00 then
13078: LD_VAR 0 2
13082: PUSH
13083: LD_INT 10500
13085: GREATER
13086: IFFALSE 13096
// time := 0 0$30 ;
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: LD_INT 1050
13095: ST_TO_ADDR
// end ;
13096: GO 12995
// end ;
13098: PPOPN 2
13100: END
// every 0 0$30 do var cr , time ;
13101: GO 13103
13103: DISABLE
13104: LD_INT 0
13106: PPUSH
13107: PPUSH
// begin time := 0 0$01 ;
13108: LD_ADDR_VAR 0 2
13112: PUSH
13113: LD_INT 35
13115: ST_TO_ADDR
// while game do
13116: LD_EXP 2
13120: IFFALSE 13209
// begin wait ( time ) ;
13122: LD_VAR 0 2
13126: PPUSH
13127: CALL_OW 67
// time := time + [ 0 0$04 , 0 0$05 , 0 0$06 ] [ Difficulty ] ;
13131: LD_ADDR_VAR 0 2
13135: PUSH
13136: LD_VAR 0 2
13140: PUSH
13141: LD_INT 140
13143: PUSH
13144: LD_INT 175
13146: PUSH
13147: LD_INT 210
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: LIST
13154: PUSH
13155: LD_OWVAR 67
13159: ARRAY
13160: PLUS
13161: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13162: LD_INT 3
13164: PPUSH
13165: LD_INT 5
13167: PPUSH
13168: CALL_OW 12
13172: PPUSH
13173: LD_INT 26
13175: PPUSH
13176: LD_INT 9
13178: PPUSH
13179: LD_INT 30
13181: PPUSH
13182: LD_INT 1
13184: PPUSH
13185: CALL_OW 56
// if time > 3 3$00 then
13189: LD_VAR 0 2
13193: PUSH
13194: LD_INT 6300
13196: GREATER
13197: IFFALSE 13207
// time := 0 0$20 ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 700
13206: ST_TO_ADDR
// end ;
13207: GO 13116
// end ;
13209: PPOPN 2
13211: END
// every 0 0$30 do var cr , time ;
13212: GO 13214
13214: DISABLE
13215: LD_INT 0
13217: PPUSH
13218: PPUSH
// begin time := 0 0$20 ;
13219: LD_ADDR_VAR 0 2
13223: PUSH
13224: LD_INT 700
13226: ST_TO_ADDR
// while game do
13227: LD_EXP 2
13231: IFFALSE 13356
// begin wait ( time ) ;
13233: LD_VAR 0 2
13237: PPUSH
13238: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13242: LD_ADDR_VAR 0 2
13246: PUSH
13247: LD_VAR 0 2
13251: PUSH
13252: LD_INT 175
13254: PUSH
13255: LD_INT 210
13257: PUSH
13258: LD_INT 280
13260: PUSH
13261: EMPTY
13262: LIST
13263: LIST
13264: LIST
13265: PUSH
13266: LD_OWVAR 67
13270: ARRAY
13271: PLUS
13272: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13273: LD_INT 1
13275: PPUSH
13276: LD_INT 5
13278: PPUSH
13279: CALL_OW 12
13283: PPUSH
13284: LD_INT 179
13286: PPUSH
13287: LD_INT 101
13289: PPUSH
13290: LD_INT 20
13292: PPUSH
13293: LD_INT 1
13295: PPUSH
13296: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13300: LD_INT 350
13302: PPUSH
13303: LD_INT 525
13305: PPUSH
13306: CALL_OW 12
13310: PPUSH
13311: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13315: LD_INT 1
13317: PPUSH
13318: LD_INT 5
13320: PPUSH
13321: CALL_OW 12
13325: PPUSH
13326: LD_INT 9
13328: PPUSH
13329: LD_INT 1
13331: PPUSH
13332: CALL_OW 55
// if time > 4 4$00 then
13336: LD_VAR 0 2
13340: PUSH
13341: LD_INT 8400
13343: GREATER
13344: IFFALSE 13354
// time := 0 0$30 ;
13346: LD_ADDR_VAR 0 2
13350: PUSH
13351: LD_INT 1050
13353: ST_TO_ADDR
// end ;
13354: GO 13227
// end ;
13356: PPOPN 2
13358: END
// every 0 0$30 do var cr , time ;
13359: GO 13361
13361: DISABLE
13362: LD_INT 0
13364: PPUSH
13365: PPUSH
// begin time := 0 0$10 ;
13366: LD_ADDR_VAR 0 2
13370: PUSH
13371: LD_INT 350
13373: ST_TO_ADDR
// while game do
13374: LD_EXP 2
13378: IFFALSE 13512
// begin wait ( time ) ;
13380: LD_VAR 0 2
13384: PPUSH
13385: CALL_OW 67
// time := time + 0 0$10 ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: LD_VAR 0 2
13398: PUSH
13399: LD_INT 350
13401: PLUS
13402: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13403: LD_INT 1
13405: PPUSH
13406: LD_INT 5
13408: PPUSH
13409: CALL_OW 12
13413: PPUSH
13414: LD_INT 11
13416: PPUSH
13417: LD_INT 1
13419: PPUSH
13420: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_INT 1
13431: PPUSH
13432: LD_INT 3
13434: PPUSH
13435: CALL_OW 12
13439: ST_TO_ADDR
// if cr = 1 then
13440: LD_VAR 0 1
13444: PUSH
13445: LD_INT 1
13447: EQUAL
13448: IFFALSE 13492
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13450: LD_INT 700
13452: PPUSH
13453: LD_INT 1575
13455: PPUSH
13456: CALL_OW 12
13460: PPUSH
13461: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13465: LD_INT 1
13467: PPUSH
13468: LD_INT 5
13470: PPUSH
13471: CALL_OW 12
13475: PPUSH
13476: LD_INT 34
13478: PPUSH
13479: LD_INT 50
13481: PPUSH
13482: LD_INT 7
13484: PPUSH
13485: LD_INT 1
13487: PPUSH
13488: CALL_OW 56
// end ; if time > 8 8$00 then
13492: LD_VAR 0 2
13496: PUSH
13497: LD_INT 16800
13499: GREATER
13500: IFFALSE 13510
// time := 0 0$40 ;
13502: LD_ADDR_VAR 0 2
13506: PUSH
13507: LD_INT 1400
13509: ST_TO_ADDR
// end ;
13510: GO 13374
// end ; end_of_file
13512: PPOPN 2
13514: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13515: LD_INT 0
13517: PPUSH
13518: PPUSH
// if exist_mode then
13519: LD_VAR 0 2
13523: IFFALSE 13548
// unit := CreateCharacter ( prefix & ident ) else
13525: LD_ADDR_VAR 0 5
13529: PUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 1
13539: STR
13540: PPUSH
13541: CALL_OW 34
13545: ST_TO_ADDR
13546: GO 13563
// unit := NewCharacter ( ident ) ;
13548: LD_ADDR_VAR 0 5
13552: PUSH
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 25
13562: ST_TO_ADDR
// result := unit ;
13563: LD_ADDR_VAR 0 4
13567: PUSH
13568: LD_VAR 0 5
13572: ST_TO_ADDR
// end ;
13573: LD_VAR 0 4
13577: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13578: LD_INT 0
13580: PPUSH
13581: PPUSH
// if not side or not nation then
13582: LD_VAR 0 1
13586: NOT
13587: PUSH
13588: LD_VAR 0 2
13592: NOT
13593: OR
13594: IFFALSE 13598
// exit ;
13596: GO 14234
// case nation of nation_american :
13598: LD_VAR 0 2
13602: PUSH
13603: LD_INT 1
13605: DOUBLE
13606: EQUAL
13607: IFTRUE 13611
13609: GO 13781
13611: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13612: LD_ADDR_VAR 0 4
13616: PUSH
13617: LD_INT 35
13619: PUSH
13620: LD_INT 45
13622: PUSH
13623: LD_INT 46
13625: PUSH
13626: LD_INT 47
13628: PUSH
13629: LD_INT 1
13631: PUSH
13632: LD_INT 2
13634: PUSH
13635: LD_INT 6
13637: PUSH
13638: LD_INT 15
13640: PUSH
13641: LD_INT 16
13643: PUSH
13644: LD_INT 7
13646: PUSH
13647: LD_INT 12
13649: PUSH
13650: LD_INT 13
13652: PUSH
13653: LD_INT 10
13655: PUSH
13656: LD_INT 14
13658: PUSH
13659: LD_INT 20
13661: PUSH
13662: LD_INT 21
13664: PUSH
13665: LD_INT 22
13667: PUSH
13668: LD_INT 25
13670: PUSH
13671: LD_INT 32
13673: PUSH
13674: LD_INT 27
13676: PUSH
13677: LD_INT 36
13679: PUSH
13680: LD_INT 69
13682: PUSH
13683: LD_INT 39
13685: PUSH
13686: LD_INT 34
13688: PUSH
13689: LD_INT 40
13691: PUSH
13692: LD_INT 48
13694: PUSH
13695: LD_INT 49
13697: PUSH
13698: LD_INT 50
13700: PUSH
13701: LD_INT 51
13703: PUSH
13704: LD_INT 52
13706: PUSH
13707: LD_INT 53
13709: PUSH
13710: LD_INT 54
13712: PUSH
13713: LD_INT 55
13715: PUSH
13716: LD_INT 56
13718: PUSH
13719: LD_INT 57
13721: PUSH
13722: LD_INT 58
13724: PUSH
13725: LD_INT 59
13727: PUSH
13728: LD_INT 60
13730: PUSH
13731: LD_INT 61
13733: PUSH
13734: LD_INT 62
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: ST_TO_ADDR
13779: GO 14158
13781: LD_INT 2
13783: DOUBLE
13784: EQUAL
13785: IFTRUE 13789
13787: GO 13967
13789: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
13790: LD_ADDR_VAR 0 4
13794: PUSH
13795: LD_INT 35
13797: PUSH
13798: LD_INT 45
13800: PUSH
13801: LD_INT 46
13803: PUSH
13804: LD_INT 47
13806: PUSH
13807: LD_INT 70
13809: PUSH
13810: LD_INT 1
13812: PUSH
13813: LD_INT 11
13815: PUSH
13816: LD_INT 3
13818: PUSH
13819: LD_INT 4
13821: PUSH
13822: LD_INT 5
13824: PUSH
13825: LD_INT 6
13827: PUSH
13828: LD_INT 15
13830: PUSH
13831: LD_INT 18
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: LD_INT 17
13839: PUSH
13840: LD_INT 8
13842: PUSH
13843: LD_INT 20
13845: PUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 22
13851: PUSH
13852: LD_INT 72
13854: PUSH
13855: LD_INT 26
13857: PUSH
13858: LD_INT 69
13860: PUSH
13861: LD_INT 39
13863: PUSH
13864: LD_INT 40
13866: PUSH
13867: LD_INT 41
13869: PUSH
13870: LD_INT 42
13872: PUSH
13873: LD_INT 43
13875: PUSH
13876: LD_INT 48
13878: PUSH
13879: LD_INT 49
13881: PUSH
13882: LD_INT 50
13884: PUSH
13885: LD_INT 51
13887: PUSH
13888: LD_INT 52
13890: PUSH
13891: LD_INT 53
13893: PUSH
13894: LD_INT 54
13896: PUSH
13897: LD_INT 55
13899: PUSH
13900: LD_INT 56
13902: PUSH
13903: LD_INT 60
13905: PUSH
13906: LD_INT 61
13908: PUSH
13909: LD_INT 62
13911: PUSH
13912: LD_INT 66
13914: PUSH
13915: LD_INT 67
13917: PUSH
13918: LD_INT 68
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: ST_TO_ADDR
13965: GO 14158
13967: LD_INT 3
13969: DOUBLE
13970: EQUAL
13971: IFTRUE 13975
13973: GO 14157
13975: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
13976: LD_ADDR_VAR 0 4
13980: PUSH
13981: LD_INT 46
13983: PUSH
13984: LD_INT 47
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: LD_INT 2
13992: PUSH
13993: LD_INT 11
13995: PUSH
13996: LD_INT 9
13998: PUSH
13999: LD_INT 20
14001: PUSH
14002: LD_INT 19
14004: PUSH
14005: LD_INT 21
14007: PUSH
14008: LD_INT 24
14010: PUSH
14011: LD_INT 22
14013: PUSH
14014: LD_INT 25
14016: PUSH
14017: LD_INT 28
14019: PUSH
14020: LD_INT 29
14022: PUSH
14023: LD_INT 30
14025: PUSH
14026: LD_INT 31
14028: PUSH
14029: LD_INT 37
14031: PUSH
14032: LD_INT 38
14034: PUSH
14035: LD_INT 32
14037: PUSH
14038: LD_INT 27
14040: PUSH
14041: LD_INT 33
14043: PUSH
14044: LD_INT 69
14046: PUSH
14047: LD_INT 39
14049: PUSH
14050: LD_INT 34
14052: PUSH
14053: LD_INT 40
14055: PUSH
14056: LD_INT 71
14058: PUSH
14059: LD_INT 23
14061: PUSH
14062: LD_INT 44
14064: PUSH
14065: LD_INT 48
14067: PUSH
14068: LD_INT 49
14070: PUSH
14071: LD_INT 50
14073: PUSH
14074: LD_INT 51
14076: PUSH
14077: LD_INT 52
14079: PUSH
14080: LD_INT 53
14082: PUSH
14083: LD_INT 54
14085: PUSH
14086: LD_INT 55
14088: PUSH
14089: LD_INT 56
14091: PUSH
14092: LD_INT 57
14094: PUSH
14095: LD_INT 58
14097: PUSH
14098: LD_INT 59
14100: PUSH
14101: LD_INT 63
14103: PUSH
14104: LD_INT 64
14106: PUSH
14107: LD_INT 65
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: ST_TO_ADDR
14155: GO 14158
14157: POP
// if state > - 1 and state < 3 then
14158: LD_VAR 0 3
14162: PUSH
14163: LD_INT 1
14165: NEG
14166: GREATER
14167: PUSH
14168: LD_VAR 0 3
14172: PUSH
14173: LD_INT 3
14175: LESS
14176: AND
14177: IFFALSE 14234
// for i in result do
14179: LD_ADDR_VAR 0 5
14183: PUSH
14184: LD_VAR 0 4
14188: PUSH
14189: FOR_IN
14190: IFFALSE 14232
// if GetTech ( i , side ) <> state then
14192: LD_VAR 0 5
14196: PPUSH
14197: LD_VAR 0 1
14201: PPUSH
14202: CALL_OW 321
14206: PUSH
14207: LD_VAR 0 3
14211: NONEQUAL
14212: IFFALSE 14230
// result := result diff i ;
14214: LD_ADDR_VAR 0 4
14218: PUSH
14219: LD_VAR 0 4
14223: PUSH
14224: LD_VAR 0 5
14228: DIFF
14229: ST_TO_ADDR
14230: GO 14189
14232: POP
14233: POP
// end ;
14234: LD_VAR 0 4
14238: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14239: LD_INT 0
14241: PPUSH
14242: PPUSH
14243: PPUSH
// result := true ;
14244: LD_ADDR_VAR 0 3
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14252: LD_ADDR_VAR 0 5
14256: PUSH
14257: LD_VAR 0 2
14261: PPUSH
14262: CALL_OW 480
14266: ST_TO_ADDR
// if not tmp then
14267: LD_VAR 0 5
14271: NOT
14272: IFFALSE 14276
// exit ;
14274: GO 14325
// for i in tmp do
14276: LD_ADDR_VAR 0 4
14280: PUSH
14281: LD_VAR 0 5
14285: PUSH
14286: FOR_IN
14287: IFFALSE 14323
// if GetTech ( i , side ) <> state_researched then
14289: LD_VAR 0 4
14293: PPUSH
14294: LD_VAR 0 1
14298: PPUSH
14299: CALL_OW 321
14303: PUSH
14304: LD_INT 2
14306: NONEQUAL
14307: IFFALSE 14321
// begin result := false ;
14309: LD_ADDR_VAR 0 3
14313: PUSH
14314: LD_INT 0
14316: ST_TO_ADDR
// exit ;
14317: POP
14318: POP
14319: GO 14325
// end ;
14321: GO 14286
14323: POP
14324: POP
// end ;
14325: LD_VAR 0 3
14329: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14330: LD_INT 0
14332: PPUSH
14333: PPUSH
14334: PPUSH
14335: PPUSH
14336: PPUSH
14337: PPUSH
14338: PPUSH
14339: PPUSH
14340: PPUSH
14341: PPUSH
14342: PPUSH
14343: PPUSH
14344: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14345: LD_VAR 0 1
14349: NOT
14350: PUSH
14351: LD_VAR 0 1
14355: PPUSH
14356: CALL_OW 257
14360: PUSH
14361: LD_INT 9
14363: NONEQUAL
14364: OR
14365: IFFALSE 14369
// exit ;
14367: GO 14942
// side := GetSide ( unit ) ;
14369: LD_ADDR_VAR 0 9
14373: PUSH
14374: LD_VAR 0 1
14378: PPUSH
14379: CALL_OW 255
14383: ST_TO_ADDR
// tech_space := tech_spacanom ;
14384: LD_ADDR_VAR 0 12
14388: PUSH
14389: LD_INT 29
14391: ST_TO_ADDR
// tech_time := tech_taurad ;
14392: LD_ADDR_VAR 0 13
14396: PUSH
14397: LD_INT 28
14399: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14400: LD_ADDR_VAR 0 11
14404: PUSH
14405: LD_VAR 0 1
14409: PPUSH
14410: CALL_OW 310
14414: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14415: LD_VAR 0 11
14419: PPUSH
14420: CALL_OW 247
14424: PUSH
14425: LD_INT 2
14427: EQUAL
14428: IFFALSE 14432
// exit ;
14430: GO 14942
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14432: LD_ADDR_VAR 0 8
14436: PUSH
14437: LD_INT 81
14439: PUSH
14440: LD_VAR 0 9
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 3
14451: PUSH
14452: LD_INT 21
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: ST_TO_ADDR
// if not tmp then
14475: LD_VAR 0 8
14479: NOT
14480: IFFALSE 14484
// exit ;
14482: GO 14942
// if in_unit then
14484: LD_VAR 0 11
14488: IFFALSE 14512
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14490: LD_ADDR_VAR 0 10
14494: PUSH
14495: LD_VAR 0 8
14499: PPUSH
14500: LD_VAR 0 11
14504: PPUSH
14505: CALL_OW 74
14509: ST_TO_ADDR
14510: GO 14532
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14512: LD_ADDR_VAR 0 10
14516: PUSH
14517: LD_VAR 0 8
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 74
14531: ST_TO_ADDR
// if not enemy then
14532: LD_VAR 0 10
14536: NOT
14537: IFFALSE 14541
// exit ;
14539: GO 14942
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14541: LD_VAR 0 11
14545: PUSH
14546: LD_VAR 0 11
14550: PPUSH
14551: LD_VAR 0 10
14555: PPUSH
14556: CALL_OW 296
14560: PUSH
14561: LD_INT 13
14563: GREATER
14564: AND
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: LD_VAR 0 10
14575: PPUSH
14576: CALL_OW 296
14580: PUSH
14581: LD_INT 12
14583: GREATER
14584: OR
14585: IFFALSE 14589
// exit ;
14587: GO 14942
// missile := [ 1 ] ;
14589: LD_ADDR_VAR 0 14
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14600: LD_VAR 0 9
14604: PPUSH
14605: LD_VAR 0 12
14609: PPUSH
14610: CALL_OW 325
14614: IFFALSE 14643
// missile := Insert ( missile , missile + 1 , 2 ) ;
14616: LD_ADDR_VAR 0 14
14620: PUSH
14621: LD_VAR 0 14
14625: PPUSH
14626: LD_VAR 0 14
14630: PUSH
14631: LD_INT 1
14633: PLUS
14634: PPUSH
14635: LD_INT 2
14637: PPUSH
14638: CALL_OW 2
14642: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14643: LD_VAR 0 9
14647: PPUSH
14648: LD_VAR 0 13
14652: PPUSH
14653: CALL_OW 325
14657: PUSH
14658: LD_VAR 0 10
14662: PPUSH
14663: CALL_OW 255
14667: PPUSH
14668: LD_VAR 0 13
14672: PPUSH
14673: CALL_OW 325
14677: NOT
14678: AND
14679: IFFALSE 14708
// missile := Insert ( missile , missile + 1 , 3 ) ;
14681: LD_ADDR_VAR 0 14
14685: PUSH
14686: LD_VAR 0 14
14690: PPUSH
14691: LD_VAR 0 14
14695: PUSH
14696: LD_INT 1
14698: PLUS
14699: PPUSH
14700: LD_INT 3
14702: PPUSH
14703: CALL_OW 2
14707: ST_TO_ADDR
// if missile < 2 then
14708: LD_VAR 0 14
14712: PUSH
14713: LD_INT 2
14715: LESS
14716: IFFALSE 14720
// exit ;
14718: GO 14942
// x := GetX ( enemy ) ;
14720: LD_ADDR_VAR 0 4
14724: PUSH
14725: LD_VAR 0 10
14729: PPUSH
14730: CALL_OW 250
14734: ST_TO_ADDR
// y := GetY ( enemy ) ;
14735: LD_ADDR_VAR 0 5
14739: PUSH
14740: LD_VAR 0 10
14744: PPUSH
14745: CALL_OW 251
14749: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14750: LD_ADDR_VAR 0 6
14754: PUSH
14755: LD_VAR 0 4
14759: PUSH
14760: LD_INT 1
14762: NEG
14763: PPUSH
14764: LD_INT 1
14766: PPUSH
14767: CALL_OW 12
14771: PLUS
14772: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14773: LD_ADDR_VAR 0 7
14777: PUSH
14778: LD_VAR 0 5
14782: PUSH
14783: LD_INT 1
14785: NEG
14786: PPUSH
14787: LD_INT 1
14789: PPUSH
14790: CALL_OW 12
14794: PLUS
14795: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
14796: LD_VAR 0 6
14800: PPUSH
14801: LD_VAR 0 7
14805: PPUSH
14806: CALL_OW 488
14810: NOT
14811: IFFALSE 14833
// begin _x := x ;
14813: LD_ADDR_VAR 0 6
14817: PUSH
14818: LD_VAR 0 4
14822: ST_TO_ADDR
// _y := y ;
14823: LD_ADDR_VAR 0 7
14827: PUSH
14828: LD_VAR 0 5
14832: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
14833: LD_ADDR_VAR 0 3
14837: PUSH
14838: LD_INT 1
14840: PPUSH
14841: LD_VAR 0 14
14845: PPUSH
14846: CALL_OW 12
14850: ST_TO_ADDR
// case i of 1 :
14851: LD_VAR 0 3
14855: PUSH
14856: LD_INT 1
14858: DOUBLE
14859: EQUAL
14860: IFTRUE 14864
14862: GO 14881
14864: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
14865: LD_VAR 0 1
14869: PPUSH
14870: LD_VAR 0 10
14874: PPUSH
14875: CALL_OW 115
14879: GO 14942
14881: LD_INT 2
14883: DOUBLE
14884: EQUAL
14885: IFTRUE 14889
14887: GO 14911
14889: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
14890: LD_VAR 0 1
14894: PPUSH
14895: LD_VAR 0 6
14899: PPUSH
14900: LD_VAR 0 7
14904: PPUSH
14905: CALL_OW 153
14909: GO 14942
14911: LD_INT 3
14913: DOUBLE
14914: EQUAL
14915: IFTRUE 14919
14917: GO 14941
14919: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
14920: LD_VAR 0 1
14924: PPUSH
14925: LD_VAR 0 6
14929: PPUSH
14930: LD_VAR 0 7
14934: PPUSH
14935: CALL_OW 154
14939: GO 14942
14941: POP
// end ;
14942: LD_VAR 0 2
14946: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
14947: LD_INT 0
14949: PPUSH
14950: PPUSH
14951: PPUSH
14952: PPUSH
14953: PPUSH
14954: PPUSH
// if not unit or not building then
14955: LD_VAR 0 1
14959: NOT
14960: PUSH
14961: LD_VAR 0 2
14965: NOT
14966: OR
14967: IFFALSE 14971
// exit ;
14969: GO 15129
// x := GetX ( building ) ;
14971: LD_ADDR_VAR 0 5
14975: PUSH
14976: LD_VAR 0 2
14980: PPUSH
14981: CALL_OW 250
14985: ST_TO_ADDR
// y := GetY ( building ) ;
14986: LD_ADDR_VAR 0 6
14990: PUSH
14991: LD_VAR 0 2
14995: PPUSH
14996: CALL_OW 251
15000: ST_TO_ADDR
// for i = 0 to 5 do
15001: LD_ADDR_VAR 0 4
15005: PUSH
15006: DOUBLE
15007: LD_INT 0
15009: DEC
15010: ST_TO_ADDR
15011: LD_INT 5
15013: PUSH
15014: FOR_TO
15015: IFFALSE 15127
// begin _x := ShiftX ( x , i , 3 ) ;
15017: LD_ADDR_VAR 0 7
15021: PUSH
15022: LD_VAR 0 5
15026: PPUSH
15027: LD_VAR 0 4
15031: PPUSH
15032: LD_INT 3
15034: PPUSH
15035: CALL_OW 272
15039: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15040: LD_ADDR_VAR 0 8
15044: PUSH
15045: LD_VAR 0 6
15049: PPUSH
15050: LD_VAR 0 4
15054: PPUSH
15055: LD_INT 3
15057: PPUSH
15058: CALL_OW 273
15062: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15063: LD_VAR 0 7
15067: PPUSH
15068: LD_VAR 0 8
15072: PPUSH
15073: CALL_OW 488
15077: NOT
15078: IFFALSE 15082
// continue ;
15080: GO 15014
// if HexInfo ( _x , _y ) = 0 then
15082: LD_VAR 0 7
15086: PPUSH
15087: LD_VAR 0 8
15091: PPUSH
15092: CALL_OW 428
15096: PUSH
15097: LD_INT 0
15099: EQUAL
15100: IFFALSE 15125
// begin ComMoveXY ( unit , _x , _y ) ;
15102: LD_VAR 0 1
15106: PPUSH
15107: LD_VAR 0 7
15111: PPUSH
15112: LD_VAR 0 8
15116: PPUSH
15117: CALL_OW 111
// exit ;
15121: POP
15122: POP
15123: GO 15129
// end ; end ;
15125: GO 15014
15127: POP
15128: POP
// end ;
15129: LD_VAR 0 3
15133: RET
// export function ScanBase ( side , base_area ) ; begin
15134: LD_INT 0
15136: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15137: LD_ADDR_VAR 0 3
15141: PUSH
15142: LD_VAR 0 2
15146: PPUSH
15147: LD_INT 81
15149: PUSH
15150: LD_VAR 0 1
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PPUSH
15159: CALL_OW 70
15163: ST_TO_ADDR
// end ;
15164: LD_VAR 0 3
15168: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15169: LD_INT 0
15171: PPUSH
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15176: LD_VAR 0 1
15180: NOT
15181: PUSH
15182: LD_EXP 58
15186: PUSH
15187: LD_VAR 0 1
15191: ARRAY
15192: NOT
15193: OR
15194: PUSH
15195: LD_VAR 0 2
15199: NOT
15200: OR
15201: PUSH
15202: LD_VAR 0 3
15206: NOT
15207: OR
15208: IFFALSE 15212
// exit ;
15210: GO 15662
// side := mc_sides [ base ] ;
15212: LD_ADDR_VAR 0 6
15216: PUSH
15217: LD_EXP 84
15221: PUSH
15222: LD_VAR 0 1
15226: ARRAY
15227: ST_TO_ADDR
// if not side then
15228: LD_VAR 0 6
15232: NOT
15233: IFFALSE 15237
// exit ;
15235: GO 15662
// for i in solds do
15237: LD_ADDR_VAR 0 7
15241: PUSH
15242: LD_VAR 0 2
15246: PUSH
15247: FOR_IN
15248: IFFALSE 15309
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15250: LD_VAR 0 7
15254: PPUSH
15255: CALL_OW 310
15259: PPUSH
15260: CALL_OW 266
15264: PUSH
15265: LD_INT 32
15267: PUSH
15268: LD_INT 31
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: IN
15275: IFFALSE 15295
// solds := solds diff i else
15277: LD_ADDR_VAR 0 2
15281: PUSH
15282: LD_VAR 0 2
15286: PUSH
15287: LD_VAR 0 7
15291: DIFF
15292: ST_TO_ADDR
15293: GO 15307
// SetTag ( i , 18 ) ;
15295: LD_VAR 0 7
15299: PPUSH
15300: LD_INT 18
15302: PPUSH
15303: CALL_OW 109
15307: GO 15247
15309: POP
15310: POP
// if not solds then
15311: LD_VAR 0 2
15315: NOT
15316: IFFALSE 15320
// exit ;
15318: GO 15662
// repeat wait ( 0 0$1 ) ;
15320: LD_INT 35
15322: PPUSH
15323: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15327: LD_ADDR_VAR 0 5
15331: PUSH
15332: LD_VAR 0 6
15336: PPUSH
15337: LD_VAR 0 3
15341: PPUSH
15342: CALL 15134 0 2
15346: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15347: LD_VAR 0 5
15351: NOT
15352: PUSH
15353: LD_VAR 0 5
15357: PUSH
15358: LD_INT 3
15360: GREATER
15361: OR
15362: PUSH
15363: LD_EXP 80
15367: PUSH
15368: LD_VAR 0 1
15372: ARRAY
15373: OR
15374: IFFALSE 15415
// begin for i in solds do
15376: LD_ADDR_VAR 0 7
15380: PUSH
15381: LD_VAR 0 2
15385: PUSH
15386: FOR_IN
15387: IFFALSE 15411
// if HasTask ( i ) then
15389: LD_VAR 0 7
15393: PPUSH
15394: CALL_OW 314
15398: IFFALSE 15409
// ComStop ( i ) ;
15400: LD_VAR 0 7
15404: PPUSH
15405: CALL_OW 141
15409: GO 15386
15411: POP
15412: POP
// break ;
15413: GO 15650
// end ; for i in solds do
15415: LD_ADDR_VAR 0 7
15419: PUSH
15420: LD_VAR 0 2
15424: PUSH
15425: FOR_IN
15426: IFFALSE 15642
// begin if IsInUnit ( i ) then
15428: LD_VAR 0 7
15432: PPUSH
15433: CALL_OW 310
15437: IFFALSE 15448
// ComExitBuilding ( i ) ;
15439: LD_VAR 0 7
15443: PPUSH
15444: CALL_OW 122
// if GetLives ( i ) > 333 then
15448: LD_VAR 0 7
15452: PPUSH
15453: CALL_OW 256
15457: PUSH
15458: LD_INT 333
15460: GREATER
15461: IFFALSE 15489
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15463: LD_VAR 0 7
15467: PPUSH
15468: LD_VAR 0 5
15472: PPUSH
15473: LD_VAR 0 7
15477: PPUSH
15478: CALL_OW 74
15482: PPUSH
15483: CALL_OW 115
15487: GO 15640
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15489: LD_ADDR_VAR 0 8
15493: PUSH
15494: LD_EXP 58
15498: PUSH
15499: LD_VAR 0 1
15503: ARRAY
15504: PPUSH
15505: LD_INT 2
15507: PUSH
15508: LD_INT 30
15510: PUSH
15511: LD_INT 0
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: LD_INT 30
15520: PUSH
15521: LD_INT 1
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PUSH
15528: LD_INT 30
15530: PUSH
15531: LD_INT 6
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL_OW 72
15548: PPUSH
15549: LD_VAR 0 7
15553: PPUSH
15554: CALL_OW 74
15558: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15559: LD_VAR 0 7
15563: PPUSH
15564: LD_VAR 0 8
15568: PPUSH
15569: CALL_OW 250
15573: PPUSH
15574: LD_INT 3
15576: PPUSH
15577: LD_INT 5
15579: PPUSH
15580: CALL_OW 272
15584: PPUSH
15585: LD_VAR 0 8
15589: PPUSH
15590: CALL_OW 251
15594: PPUSH
15595: LD_INT 3
15597: PPUSH
15598: LD_INT 5
15600: PPUSH
15601: CALL_OW 273
15605: PPUSH
15606: CALL_OW 111
// SetTag ( i , 0 ) ;
15610: LD_VAR 0 7
15614: PPUSH
15615: LD_INT 0
15617: PPUSH
15618: CALL_OW 109
// solds := solds diff i ;
15622: LD_ADDR_VAR 0 2
15626: PUSH
15627: LD_VAR 0 2
15631: PUSH
15632: LD_VAR 0 7
15636: DIFF
15637: ST_TO_ADDR
// continue ;
15638: GO 15425
// end ; end ;
15640: GO 15425
15642: POP
15643: POP
// until solds ;
15644: LD_VAR 0 2
15648: IFFALSE 15320
// MC_Reset ( base , 18 ) ;
15650: LD_VAR 0 1
15654: PPUSH
15655: LD_INT 18
15657: PPUSH
15658: CALL 58916 0 2
// end ;
15662: LD_VAR 0 4
15666: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15667: LD_INT 0
15669: PPUSH
15670: PPUSH
15671: PPUSH
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
15677: PPUSH
15678: PPUSH
15679: PPUSH
15680: PPUSH
15681: PPUSH
15682: PPUSH
15683: PPUSH
15684: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15685: LD_ADDR_VAR 0 12
15689: PUSH
15690: LD_EXP 58
15694: PUSH
15695: LD_VAR 0 1
15699: ARRAY
15700: PPUSH
15701: LD_INT 25
15703: PUSH
15704: LD_INT 3
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PPUSH
15711: CALL_OW 72
15715: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15716: LD_ADDR_VAR 0 8
15720: PUSH
15721: LD_EXP 58
15725: PUSH
15726: LD_VAR 0 1
15730: ARRAY
15731: PPUSH
15732: LD_INT 2
15734: PUSH
15735: LD_INT 25
15737: PUSH
15738: LD_INT 1
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 25
15747: PUSH
15748: LD_INT 5
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 25
15757: PUSH
15758: LD_INT 8
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: LD_INT 25
15767: PUSH
15768: LD_INT 9
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: PPUSH
15782: CALL_OW 72
15786: ST_TO_ADDR
// if not defenders and not solds then
15787: LD_VAR 0 2
15791: NOT
15792: PUSH
15793: LD_VAR 0 8
15797: NOT
15798: AND
15799: IFFALSE 15803
// exit ;
15801: GO 17169
// depot_under_attack := false ;
15803: LD_ADDR_VAR 0 16
15807: PUSH
15808: LD_INT 0
15810: ST_TO_ADDR
// sold_defenders := [ ] ;
15811: LD_ADDR_VAR 0 17
15815: PUSH
15816: EMPTY
15817: ST_TO_ADDR
// if mechs then
15818: LD_VAR 0 12
15822: IFFALSE 15951
// for i in defenders do
15824: LD_ADDR_VAR 0 5
15828: PUSH
15829: LD_VAR 0 2
15833: PUSH
15834: FOR_IN
15835: IFFALSE 15949
// begin SetTag ( i , 20 ) ;
15837: LD_VAR 0 5
15841: PPUSH
15842: LD_INT 20
15844: PPUSH
15845: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
15849: LD_VAR 0 5
15853: PPUSH
15854: CALL_OW 263
15858: PUSH
15859: LD_INT 1
15861: EQUAL
15862: PUSH
15863: LD_VAR 0 5
15867: PPUSH
15868: CALL_OW 311
15872: NOT
15873: AND
15874: PUSH
15875: LD_VAR 0 12
15879: AND
15880: IFFALSE 15947
// begin un := mechs [ 1 ] ;
15882: LD_ADDR_VAR 0 10
15886: PUSH
15887: LD_VAR 0 12
15891: PUSH
15892: LD_INT 1
15894: ARRAY
15895: ST_TO_ADDR
// ComExitBuilding ( un ) ;
15896: LD_VAR 0 10
15900: PPUSH
15901: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
15905: LD_VAR 0 10
15909: PPUSH
15910: LD_VAR 0 5
15914: PPUSH
15915: CALL_OW 180
// SetTag ( un , 19 ) ;
15919: LD_VAR 0 10
15923: PPUSH
15924: LD_INT 19
15926: PPUSH
15927: CALL_OW 109
// mechs := mechs diff un ;
15931: LD_ADDR_VAR 0 12
15935: PUSH
15936: LD_VAR 0 12
15940: PUSH
15941: LD_VAR 0 10
15945: DIFF
15946: ST_TO_ADDR
// end ; end ;
15947: GO 15834
15949: POP
15950: POP
// if solds then
15951: LD_VAR 0 8
15955: IFFALSE 16014
// for i in solds do
15957: LD_ADDR_VAR 0 5
15961: PUSH
15962: LD_VAR 0 8
15966: PUSH
15967: FOR_IN
15968: IFFALSE 16012
// if not GetTag ( i ) then
15970: LD_VAR 0 5
15974: PPUSH
15975: CALL_OW 110
15979: NOT
15980: IFFALSE 16010
// begin defenders := defenders union i ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 2
15991: PUSH
15992: LD_VAR 0 5
15996: UNION
15997: ST_TO_ADDR
// SetTag ( i , 18 ) ;
15998: LD_VAR 0 5
16002: PPUSH
16003: LD_INT 18
16005: PPUSH
16006: CALL_OW 109
// end ;
16010: GO 15967
16012: POP
16013: POP
// repeat wait ( 0 0$1 ) ;
16014: LD_INT 35
16016: PPUSH
16017: CALL_OW 67
// enemy := mc_scan [ base ] ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_EXP 81
16030: PUSH
16031: LD_VAR 0 1
16035: ARRAY
16036: ST_TO_ADDR
// for i in defenders do
16037: LD_ADDR_VAR 0 5
16041: PUSH
16042: LD_VAR 0 2
16046: PUSH
16047: FOR_IN
16048: IFFALSE 16733
// begin e := NearestUnitToUnit ( enemy , i ) ;
16050: LD_ADDR_VAR 0 13
16054: PUSH
16055: LD_VAR 0 3
16059: PPUSH
16060: LD_VAR 0 5
16064: PPUSH
16065: CALL_OW 74
16069: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16070: LD_ADDR_VAR 0 16
16074: PUSH
16075: LD_EXP 58
16079: PUSH
16080: LD_VAR 0 1
16084: ARRAY
16085: PPUSH
16086: LD_INT 2
16088: PUSH
16089: LD_INT 30
16091: PUSH
16092: LD_INT 0
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: PUSH
16099: LD_INT 30
16101: PUSH
16102: LD_INT 1
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: LIST
16113: PPUSH
16114: CALL_OW 72
16118: NOT
16119: PUSH
16120: LD_EXP 58
16124: PUSH
16125: LD_VAR 0 1
16129: ARRAY
16130: PPUSH
16131: LD_INT 2
16133: PUSH
16134: LD_INT 30
16136: PUSH
16137: LD_INT 0
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: PUSH
16144: LD_INT 30
16146: PUSH
16147: LD_INT 1
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: LIST
16158: PPUSH
16159: CALL_OW 72
16163: PPUSH
16164: CALL_OW 256
16168: PUSH
16169: LD_INT 600
16171: LESS
16172: OR
16173: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16174: LD_VAR 0 5
16178: PPUSH
16179: CALL_OW 247
16183: PUSH
16184: LD_INT 2
16186: DOUBLE
16187: EQUAL
16188: IFTRUE 16192
16190: GO 16439
16192: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16193: LD_VAR 0 5
16197: PPUSH
16198: CALL_OW 256
16202: PUSH
16203: LD_INT 650
16205: GREATER
16206: PUSH
16207: LD_VAR 0 5
16211: PPUSH
16212: LD_VAR 0 13
16216: PPUSH
16217: CALL_OW 296
16221: PUSH
16222: LD_INT 40
16224: LESS
16225: AND
16226: IFFALSE 16244
// ComAttackUnit ( i , e ) else
16228: LD_VAR 0 5
16232: PPUSH
16233: LD_VAR 0 13
16237: PPUSH
16238: CALL_OW 115
16242: GO 16322
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16244: LD_VAR 0 5
16248: PPUSH
16249: LD_VAR 0 13
16253: PPUSH
16254: CALL_OW 296
16258: PUSH
16259: LD_INT 30
16261: GREATEREQUAL
16262: PUSH
16263: LD_VAR 0 5
16267: PPUSH
16268: CALL_OW 256
16272: PUSH
16273: LD_INT 650
16275: LESSEQUAL
16276: OR
16277: PUSH
16278: LD_VAR 0 5
16282: PPUSH
16283: LD_EXP 82
16287: PUSH
16288: LD_VAR 0 1
16292: ARRAY
16293: PPUSH
16294: CALL_OW 308
16298: NOT
16299: AND
16300: IFFALSE 16322
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16302: LD_VAR 0 5
16306: PPUSH
16307: LD_EXP 82
16311: PUSH
16312: LD_VAR 0 1
16316: ARRAY
16317: PPUSH
16318: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16322: LD_VAR 0 5
16326: PPUSH
16327: CALL_OW 256
16331: PUSH
16332: LD_INT 998
16334: LESS
16335: PUSH
16336: LD_VAR 0 5
16340: PPUSH
16341: CALL_OW 263
16345: PUSH
16346: LD_INT 1
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_VAR 0 5
16355: PPUSH
16356: CALL_OW 311
16360: AND
16361: PUSH
16362: LD_VAR 0 5
16366: PPUSH
16367: LD_EXP 82
16371: PUSH
16372: LD_VAR 0 1
16376: ARRAY
16377: PPUSH
16378: CALL_OW 308
16382: AND
16383: IFFALSE 16437
// begin mech := IsDrivenBy ( i ) ;
16385: LD_ADDR_VAR 0 9
16389: PUSH
16390: LD_VAR 0 5
16394: PPUSH
16395: CALL_OW 311
16399: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16400: LD_VAR 0 9
16404: PPUSH
16405: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16409: LD_VAR 0 9
16413: PPUSH
16414: LD_VAR 0 5
16418: PPUSH
16419: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16423: LD_VAR 0 9
16427: PPUSH
16428: LD_VAR 0 5
16432: PPUSH
16433: CALL_OW 180
// end ; end ; unit_human :
16437: GO 16704
16439: LD_INT 1
16441: DOUBLE
16442: EQUAL
16443: IFTRUE 16447
16445: GO 16703
16447: POP
// begin b := IsInUnit ( i ) ;
16448: LD_ADDR_VAR 0 18
16452: PUSH
16453: LD_VAR 0 5
16457: PPUSH
16458: CALL_OW 310
16462: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16463: LD_ADDR_VAR 0 19
16467: PUSH
16468: LD_VAR 0 18
16472: NOT
16473: PUSH
16474: LD_VAR 0 18
16478: PPUSH
16479: CALL_OW 266
16483: PUSH
16484: LD_INT 32
16486: PUSH
16487: LD_INT 31
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: IN
16494: OR
16495: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16496: LD_VAR 0 16
16500: PUSH
16501: LD_VAR 0 2
16505: PPUSH
16506: LD_INT 21
16508: PUSH
16509: LD_INT 2
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 72
16520: PUSH
16521: LD_INT 1
16523: LESSEQUAL
16524: OR
16525: PUSH
16526: LD_VAR 0 19
16530: AND
16531: PUSH
16532: LD_VAR 0 5
16536: PUSH
16537: LD_VAR 0 17
16541: IN
16542: NOT
16543: AND
16544: IFFALSE 16637
// begin if b then
16546: LD_VAR 0 18
16550: IFFALSE 16599
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16552: LD_VAR 0 18
16556: PPUSH
16557: LD_VAR 0 3
16561: PPUSH
16562: LD_VAR 0 18
16566: PPUSH
16567: CALL_OW 74
16571: PPUSH
16572: CALL_OW 296
16576: PUSH
16577: LD_INT 10
16579: LESS
16580: PUSH
16581: LD_VAR 0 18
16585: PPUSH
16586: CALL_OW 461
16590: PUSH
16591: LD_INT 7
16593: NONEQUAL
16594: AND
16595: IFFALSE 16599
// continue ;
16597: GO 16047
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16599: LD_ADDR_VAR 0 17
16603: PUSH
16604: LD_VAR 0 17
16608: PPUSH
16609: LD_VAR 0 17
16613: PUSH
16614: LD_INT 1
16616: PLUS
16617: PPUSH
16618: LD_VAR 0 5
16622: PPUSH
16623: CALL_OW 1
16627: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16628: LD_VAR 0 5
16632: PPUSH
16633: CALL_OW 122
// end ; if sold_defenders then
16637: LD_VAR 0 17
16641: IFFALSE 16701
// if i in sold_defenders then
16643: LD_VAR 0 5
16647: PUSH
16648: LD_VAR 0 17
16652: IN
16653: IFFALSE 16701
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16655: LD_VAR 0 5
16659: PPUSH
16660: CALL_OW 314
16664: NOT
16665: PUSH
16666: LD_VAR 0 5
16670: PPUSH
16671: LD_VAR 0 13
16675: PPUSH
16676: CALL_OW 296
16680: PUSH
16681: LD_INT 30
16683: LESS
16684: AND
16685: IFFALSE 16701
// ComAttackUnit ( i , e ) ;
16687: LD_VAR 0 5
16691: PPUSH
16692: LD_VAR 0 13
16696: PPUSH
16697: CALL_OW 115
// end ; end ; end ;
16701: GO 16704
16703: POP
// if IsDead ( i ) then
16704: LD_VAR 0 5
16708: PPUSH
16709: CALL_OW 301
16713: IFFALSE 16731
// defenders := defenders diff i ;
16715: LD_ADDR_VAR 0 2
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: LD_VAR 0 5
16729: DIFF
16730: ST_TO_ADDR
// end ;
16731: GO 16047
16733: POP
16734: POP
// until not enemy or not defenders ;
16735: LD_VAR 0 3
16739: NOT
16740: PUSH
16741: LD_VAR 0 2
16745: NOT
16746: OR
16747: IFFALSE 16014
// MC_Reset ( base , 18 ) ;
16749: LD_VAR 0 1
16753: PPUSH
16754: LD_INT 18
16756: PPUSH
16757: CALL 58916 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16761: LD_ADDR_VAR 0 2
16765: PUSH
16766: LD_VAR 0 2
16770: PUSH
16771: LD_VAR 0 2
16775: PPUSH
16776: LD_INT 2
16778: PUSH
16779: LD_INT 25
16781: PUSH
16782: LD_INT 1
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 5
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: LD_INT 25
16801: PUSH
16802: LD_INT 8
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 25
16811: PUSH
16812: LD_INT 9
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: PPUSH
16826: CALL_OW 72
16830: DIFF
16831: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
16832: LD_VAR 0 3
16836: NOT
16837: PUSH
16838: LD_VAR 0 2
16842: PPUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 2
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 72
16857: AND
16858: IFFALSE 17120
// begin tmp := FilterByTag ( defenders , 19 ) ;
16860: LD_ADDR_VAR 0 11
16864: PUSH
16865: LD_VAR 0 2
16869: PPUSH
16870: LD_INT 19
16872: PPUSH
16873: CALL 53467 0 2
16877: ST_TO_ADDR
// if tmp then
16878: LD_VAR 0 11
16882: IFFALSE 16952
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
16884: LD_ADDR_VAR 0 11
16888: PUSH
16889: LD_VAR 0 11
16893: PPUSH
16894: LD_INT 25
16896: PUSH
16897: LD_INT 3
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PPUSH
16904: CALL_OW 72
16908: ST_TO_ADDR
// if tmp then
16909: LD_VAR 0 11
16913: IFFALSE 16952
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
16915: LD_ADDR_EXP 70
16919: PUSH
16920: LD_EXP 70
16924: PPUSH
16925: LD_VAR 0 1
16929: PPUSH
16930: LD_EXP 70
16934: PUSH
16935: LD_VAR 0 1
16939: ARRAY
16940: PUSH
16941: LD_VAR 0 11
16945: UNION
16946: PPUSH
16947: CALL_OW 1
16951: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
16952: LD_VAR 0 1
16956: PPUSH
16957: LD_INT 19
16959: PPUSH
16960: CALL 58916 0 2
// repeat wait ( 0 0$1 ) ;
16964: LD_INT 35
16966: PPUSH
16967: CALL_OW 67
// for i in defenders do
16971: LD_ADDR_VAR 0 5
16975: PUSH
16976: LD_VAR 0 2
16980: PUSH
16981: FOR_IN
16982: IFFALSE 17071
// begin if not IsInArea ( i , mc_parking [ base ] ) then
16984: LD_VAR 0 5
16988: PPUSH
16989: LD_EXP 82
16993: PUSH
16994: LD_VAR 0 1
16998: ARRAY
16999: PPUSH
17000: CALL_OW 308
17004: NOT
17005: IFFALSE 17029
// ComMoveToArea ( i , mc_parking [ base ] ) else
17007: LD_VAR 0 5
17011: PPUSH
17012: LD_EXP 82
17016: PUSH
17017: LD_VAR 0 1
17021: ARRAY
17022: PPUSH
17023: CALL_OW 113
17027: GO 17069
// if GetControl ( i ) = control_manual then
17029: LD_VAR 0 5
17033: PPUSH
17034: CALL_OW 263
17038: PUSH
17039: LD_INT 1
17041: EQUAL
17042: IFFALSE 17069
// if IsDrivenBy ( i ) then
17044: LD_VAR 0 5
17048: PPUSH
17049: CALL_OW 311
17053: IFFALSE 17069
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17055: LD_VAR 0 5
17059: PPUSH
17060: CALL_OW 311
17064: PPUSH
17065: CALL_OW 121
// end ;
17069: GO 16981
17071: POP
17072: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17073: LD_VAR 0 2
17077: PPUSH
17078: LD_INT 95
17080: PUSH
17081: LD_EXP 82
17085: PUSH
17086: LD_VAR 0 1
17090: ARRAY
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PPUSH
17096: CALL_OW 72
17100: PUSH
17101: LD_VAR 0 2
17105: EQUAL
17106: PUSH
17107: LD_EXP 81
17111: PUSH
17112: LD_VAR 0 1
17116: ARRAY
17117: OR
17118: IFFALSE 16964
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17120: LD_ADDR_EXP 80
17124: PUSH
17125: LD_EXP 80
17129: PPUSH
17130: LD_VAR 0 1
17134: PPUSH
17135: LD_EXP 80
17139: PUSH
17140: LD_VAR 0 1
17144: ARRAY
17145: PUSH
17146: LD_VAR 0 2
17150: UNION
17151: PPUSH
17152: CALL_OW 1
17156: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17157: LD_VAR 0 1
17161: PPUSH
17162: LD_INT 20
17164: PPUSH
17165: CALL 58916 0 2
// end ;
17169: LD_VAR 0 4
17173: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17174: LD_INT 0
17176: PPUSH
17177: PPUSH
17178: PPUSH
17179: PPUSH
// result := false ;
17180: LD_ADDR_VAR 0 2
17184: PUSH
17185: LD_INT 0
17187: ST_TO_ADDR
// side := GetSide ( unit ) ;
17188: LD_ADDR_VAR 0 3
17192: PUSH
17193: LD_VAR 0 1
17197: PPUSH
17198: CALL_OW 255
17202: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17203: LD_ADDR_VAR 0 4
17207: PUSH
17208: LD_VAR 0 1
17212: PPUSH
17213: CALL_OW 248
17217: ST_TO_ADDR
// case nat of 1 :
17218: LD_VAR 0 4
17222: PUSH
17223: LD_INT 1
17225: DOUBLE
17226: EQUAL
17227: IFTRUE 17231
17229: GO 17242
17231: POP
// tech := tech_lassight ; 2 :
17232: LD_ADDR_VAR 0 5
17236: PUSH
17237: LD_INT 12
17239: ST_TO_ADDR
17240: GO 17281
17242: LD_INT 2
17244: DOUBLE
17245: EQUAL
17246: IFTRUE 17250
17248: GO 17261
17250: POP
// tech := tech_mortar ; 3 :
17251: LD_ADDR_VAR 0 5
17255: PUSH
17256: LD_INT 41
17258: ST_TO_ADDR
17259: GO 17281
17261: LD_INT 3
17263: DOUBLE
17264: EQUAL
17265: IFTRUE 17269
17267: GO 17280
17269: POP
// tech := tech_bazooka ; end ;
17270: LD_ADDR_VAR 0 5
17274: PUSH
17275: LD_INT 44
17277: ST_TO_ADDR
17278: GO 17281
17280: POP
// if Researched ( side , tech ) then
17281: LD_VAR 0 3
17285: PPUSH
17286: LD_VAR 0 5
17290: PPUSH
17291: CALL_OW 325
17295: IFFALSE 17322
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17297: LD_ADDR_VAR 0 2
17301: PUSH
17302: LD_INT 5
17304: PUSH
17305: LD_INT 8
17307: PUSH
17308: LD_INT 9
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: PUSH
17316: LD_VAR 0 4
17320: ARRAY
17321: ST_TO_ADDR
// end ;
17322: LD_VAR 0 2
17326: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17327: LD_INT 0
17329: PPUSH
17330: PPUSH
17331: PPUSH
// if not mines then
17332: LD_VAR 0 2
17336: NOT
17337: IFFALSE 17341
// exit ;
17339: GO 17485
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17341: LD_ADDR_VAR 0 5
17345: PUSH
17346: LD_INT 81
17348: PUSH
17349: LD_VAR 0 1
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: LD_INT 3
17360: PUSH
17361: LD_INT 21
17363: PUSH
17364: LD_INT 3
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 69
17383: ST_TO_ADDR
// for i in mines do
17384: LD_ADDR_VAR 0 4
17388: PUSH
17389: LD_VAR 0 2
17393: PUSH
17394: FOR_IN
17395: IFFALSE 17483
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17397: LD_VAR 0 4
17401: PUSH
17402: LD_INT 1
17404: ARRAY
17405: PPUSH
17406: LD_VAR 0 4
17410: PUSH
17411: LD_INT 2
17413: ARRAY
17414: PPUSH
17415: CALL_OW 458
17419: NOT
17420: IFFALSE 17424
// continue ;
17422: GO 17394
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17424: LD_VAR 0 4
17428: PUSH
17429: LD_INT 1
17431: ARRAY
17432: PPUSH
17433: LD_VAR 0 4
17437: PUSH
17438: LD_INT 2
17440: ARRAY
17441: PPUSH
17442: CALL_OW 428
17446: PUSH
17447: LD_VAR 0 5
17451: IN
17452: IFFALSE 17481
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17454: LD_VAR 0 4
17458: PUSH
17459: LD_INT 1
17461: ARRAY
17462: PPUSH
17463: LD_VAR 0 4
17467: PUSH
17468: LD_INT 2
17470: ARRAY
17471: PPUSH
17472: LD_VAR 0 1
17476: PPUSH
17477: CALL_OW 456
// end ;
17481: GO 17394
17483: POP
17484: POP
// end ;
17485: LD_VAR 0 3
17489: RET
// export function Count ( array ) ; var i ; begin
17490: LD_INT 0
17492: PPUSH
17493: PPUSH
// result := 0 ;
17494: LD_ADDR_VAR 0 2
17498: PUSH
17499: LD_INT 0
17501: ST_TO_ADDR
// for i in array do
17502: LD_ADDR_VAR 0 3
17506: PUSH
17507: LD_VAR 0 1
17511: PUSH
17512: FOR_IN
17513: IFFALSE 17537
// if i then
17515: LD_VAR 0 3
17519: IFFALSE 17535
// result := result + 1 ;
17521: LD_ADDR_VAR 0 2
17525: PUSH
17526: LD_VAR 0 2
17530: PUSH
17531: LD_INT 1
17533: PLUS
17534: ST_TO_ADDR
17535: GO 17512
17537: POP
17538: POP
// end ;
17539: LD_VAR 0 2
17543: RET
// export function IsEmpty ( building ) ; begin
17544: LD_INT 0
17546: PPUSH
// if not building then
17547: LD_VAR 0 1
17551: NOT
17552: IFFALSE 17556
// exit ;
17554: GO 17599
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17556: LD_ADDR_VAR 0 2
17560: PUSH
17561: LD_VAR 0 1
17565: PUSH
17566: LD_INT 22
17568: PUSH
17569: LD_VAR 0 1
17573: PPUSH
17574: CALL_OW 255
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: LD_INT 58
17585: PUSH
17586: EMPTY
17587: LIST
17588: PUSH
17589: EMPTY
17590: LIST
17591: LIST
17592: PPUSH
17593: CALL_OW 69
17597: IN
17598: ST_TO_ADDR
// end ;
17599: LD_VAR 0 2
17603: RET
// export function IsNotFull ( building ) ; begin
17604: LD_INT 0
17606: PPUSH
// if not building then
17607: LD_VAR 0 1
17611: NOT
17612: IFFALSE 17616
// exit ;
17614: GO 17635
// result := UnitsInside ( building ) < 6 ;
17616: LD_ADDR_VAR 0 2
17620: PUSH
17621: LD_VAR 0 1
17625: PPUSH
17626: CALL_OW 313
17630: PUSH
17631: LD_INT 6
17633: LESS
17634: ST_TO_ADDR
// end ;
17635: LD_VAR 0 2
17639: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17640: LD_INT 0
17642: PPUSH
17643: PPUSH
17644: PPUSH
17645: PPUSH
// tmp := [ ] ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: EMPTY
17652: ST_TO_ADDR
// list := [ ] ;
17653: LD_ADDR_VAR 0 5
17657: PUSH
17658: EMPTY
17659: ST_TO_ADDR
// for i = 16 to 25 do
17660: LD_ADDR_VAR 0 4
17664: PUSH
17665: DOUBLE
17666: LD_INT 16
17668: DEC
17669: ST_TO_ADDR
17670: LD_INT 25
17672: PUSH
17673: FOR_TO
17674: IFFALSE 17747
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17676: LD_ADDR_VAR 0 3
17680: PUSH
17681: LD_VAR 0 3
17685: PUSH
17686: LD_INT 22
17688: PUSH
17689: LD_VAR 0 1
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: EMPTY
17700: LIST
17701: LIST
17702: PUSH
17703: LD_INT 91
17705: PUSH
17706: LD_VAR 0 1
17710: PUSH
17711: LD_INT 6
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: PUSH
17719: LD_INT 30
17721: PUSH
17722: LD_VAR 0 4
17726: PUSH
17727: EMPTY
17728: LIST
17729: LIST
17730: PUSH
17731: EMPTY
17732: LIST
17733: LIST
17734: LIST
17735: PUSH
17736: EMPTY
17737: LIST
17738: PPUSH
17739: CALL_OW 69
17743: ADD
17744: ST_TO_ADDR
17745: GO 17673
17747: POP
17748: POP
// for i = 1 to tmp do
17749: LD_ADDR_VAR 0 4
17753: PUSH
17754: DOUBLE
17755: LD_INT 1
17757: DEC
17758: ST_TO_ADDR
17759: LD_VAR 0 3
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17853
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17767: LD_ADDR_VAR 0 5
17771: PUSH
17772: LD_VAR 0 5
17776: PUSH
17777: LD_VAR 0 3
17781: PUSH
17782: LD_VAR 0 4
17786: ARRAY
17787: PPUSH
17788: CALL_OW 266
17792: PUSH
17793: LD_VAR 0 3
17797: PUSH
17798: LD_VAR 0 4
17802: ARRAY
17803: PPUSH
17804: CALL_OW 250
17808: PUSH
17809: LD_VAR 0 3
17813: PUSH
17814: LD_VAR 0 4
17818: ARRAY
17819: PPUSH
17820: CALL_OW 251
17824: PUSH
17825: LD_VAR 0 3
17829: PUSH
17830: LD_VAR 0 4
17834: ARRAY
17835: PPUSH
17836: CALL_OW 254
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: PUSH
17847: EMPTY
17848: LIST
17849: ADD
17850: ST_TO_ADDR
17851: GO 17764
17853: POP
17854: POP
// result := list ;
17855: LD_ADDR_VAR 0 2
17859: PUSH
17860: LD_VAR 0 5
17864: ST_TO_ADDR
// end ;
17865: LD_VAR 0 2
17869: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17870: LD_INT 0
17872: PPUSH
17873: PPUSH
17874: PPUSH
17875: PPUSH
17876: PPUSH
17877: PPUSH
17878: PPUSH
// if not factory then
17879: LD_VAR 0 1
17883: NOT
17884: IFFALSE 17888
// exit ;
17886: GO 18413
// if control = control_apeman then
17888: LD_VAR 0 4
17892: PUSH
17893: LD_INT 5
17895: EQUAL
17896: IFFALSE 18005
// begin tmp := UnitsInside ( factory ) ;
17898: LD_ADDR_VAR 0 8
17902: PUSH
17903: LD_VAR 0 1
17907: PPUSH
17908: CALL_OW 313
17912: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17913: LD_VAR 0 8
17917: PPUSH
17918: LD_INT 25
17920: PUSH
17921: LD_INT 12
17923: PUSH
17924: EMPTY
17925: LIST
17926: LIST
17927: PPUSH
17928: CALL_OW 72
17932: NOT
17933: IFFALSE 17943
// control := control_manual ;
17935: LD_ADDR_VAR 0 4
17939: PUSH
17940: LD_INT 1
17942: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17943: LD_ADDR_VAR 0 8
17947: PUSH
17948: LD_VAR 0 1
17952: PPUSH
17953: CALL 17640 0 1
17957: ST_TO_ADDR
// if tmp then
17958: LD_VAR 0 8
17962: IFFALSE 18005
// begin for i in tmp do
17964: LD_ADDR_VAR 0 7
17968: PUSH
17969: LD_VAR 0 8
17973: PUSH
17974: FOR_IN
17975: IFFALSE 18003
// if i [ 1 ] = b_ext_radar then
17977: LD_VAR 0 7
17981: PUSH
17982: LD_INT 1
17984: ARRAY
17985: PUSH
17986: LD_INT 20
17988: EQUAL
17989: IFFALSE 18001
// begin control := control_remote ;
17991: LD_ADDR_VAR 0 4
17995: PUSH
17996: LD_INT 2
17998: ST_TO_ADDR
// break ;
17999: GO 18003
// end ;
18001: GO 17974
18003: POP
18004: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18005: LD_VAR 0 1
18009: PPUSH
18010: LD_VAR 0 2
18014: PPUSH
18015: LD_VAR 0 3
18019: PPUSH
18020: LD_VAR 0 4
18024: PPUSH
18025: LD_VAR 0 5
18029: PPUSH
18030: CALL_OW 448
18034: IFFALSE 18069
// begin result := [ chassis , engine , control , weapon ] ;
18036: LD_ADDR_VAR 0 6
18040: PUSH
18041: LD_VAR 0 2
18045: PUSH
18046: LD_VAR 0 3
18050: PUSH
18051: LD_VAR 0 4
18055: PUSH
18056: LD_VAR 0 5
18060: PUSH
18061: EMPTY
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: ST_TO_ADDR
// exit ;
18067: GO 18413
// end ; _chassis := AvailableChassisList ( factory ) ;
18069: LD_ADDR_VAR 0 9
18073: PUSH
18074: LD_VAR 0 1
18078: PPUSH
18079: CALL_OW 475
18083: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18084: LD_ADDR_VAR 0 11
18088: PUSH
18089: LD_VAR 0 1
18093: PPUSH
18094: CALL_OW 476
18098: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18099: LD_ADDR_VAR 0 12
18103: PUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: CALL_OW 477
18113: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18114: LD_ADDR_VAR 0 10
18118: PUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: CALL_OW 478
18128: ST_TO_ADDR
// if not chassis in _chassis then
18129: LD_VAR 0 2
18133: PUSH
18134: LD_VAR 0 9
18138: IN
18139: NOT
18140: IFFALSE 18166
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18142: LD_ADDR_VAR 0 2
18146: PUSH
18147: LD_VAR 0 9
18151: PUSH
18152: LD_INT 1
18154: PPUSH
18155: LD_VAR 0 9
18159: PPUSH
18160: CALL_OW 12
18164: ARRAY
18165: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18166: LD_VAR 0 2
18170: PPUSH
18171: LD_VAR 0 3
18175: PPUSH
18176: CALL 18418 0 2
18180: NOT
18181: IFFALSE 18240
// repeat engine := _engine [ 1 ] ;
18183: LD_ADDR_VAR 0 3
18187: PUSH
18188: LD_VAR 0 11
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18197: LD_ADDR_VAR 0 11
18201: PUSH
18202: LD_VAR 0 11
18206: PPUSH
18207: LD_INT 1
18209: PPUSH
18210: CALL_OW 3
18214: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18215: LD_VAR 0 2
18219: PPUSH
18220: LD_VAR 0 3
18224: PPUSH
18225: CALL 18418 0 2
18229: PUSH
18230: LD_VAR 0 11
18234: PUSH
18235: EMPTY
18236: EQUAL
18237: OR
18238: IFFALSE 18183
// if not control in _control then
18240: LD_VAR 0 4
18244: PUSH
18245: LD_VAR 0 12
18249: IN
18250: NOT
18251: IFFALSE 18277
// control := _control [ rand ( 1 , _control ) ] ;
18253: LD_ADDR_VAR 0 4
18257: PUSH
18258: LD_VAR 0 12
18262: PUSH
18263: LD_INT 1
18265: PPUSH
18266: LD_VAR 0 12
18270: PPUSH
18271: CALL_OW 12
18275: ARRAY
18276: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18277: LD_VAR 0 2
18281: PPUSH
18282: LD_VAR 0 5
18286: PPUSH
18287: CALL 18638 0 2
18291: NOT
18292: IFFALSE 18351
// repeat weapon := _weapon [ 1 ] ;
18294: LD_ADDR_VAR 0 5
18298: PUSH
18299: LD_VAR 0 10
18303: PUSH
18304: LD_INT 1
18306: ARRAY
18307: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18308: LD_ADDR_VAR 0 10
18312: PUSH
18313: LD_VAR 0 10
18317: PPUSH
18318: LD_INT 1
18320: PPUSH
18321: CALL_OW 3
18325: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18326: LD_VAR 0 2
18330: PPUSH
18331: LD_VAR 0 5
18335: PPUSH
18336: CALL 18638 0 2
18340: PUSH
18341: LD_VAR 0 10
18345: PUSH
18346: EMPTY
18347: EQUAL
18348: OR
18349: IFFALSE 18294
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18351: LD_VAR 0 1
18355: PPUSH
18356: LD_VAR 0 2
18360: PPUSH
18361: LD_VAR 0 3
18365: PPUSH
18366: LD_VAR 0 4
18370: PPUSH
18371: LD_VAR 0 5
18375: PPUSH
18376: CALL_OW 448
18380: IFFALSE 18413
// result := [ chassis , engine , control , weapon ] ;
18382: LD_ADDR_VAR 0 6
18386: PUSH
18387: LD_VAR 0 2
18391: PUSH
18392: LD_VAR 0 3
18396: PUSH
18397: LD_VAR 0 4
18401: PUSH
18402: LD_VAR 0 5
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: ST_TO_ADDR
// end ;
18413: LD_VAR 0 6
18417: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18418: LD_INT 0
18420: PPUSH
// if not chassis or not engine then
18421: LD_VAR 0 1
18425: NOT
18426: PUSH
18427: LD_VAR 0 2
18431: NOT
18432: OR
18433: IFFALSE 18437
// exit ;
18435: GO 18633
// case engine of engine_solar :
18437: LD_VAR 0 2
18441: PUSH
18442: LD_INT 2
18444: DOUBLE
18445: EQUAL
18446: IFTRUE 18450
18448: GO 18488
18450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18451: LD_ADDR_VAR 0 3
18455: PUSH
18456: LD_INT 11
18458: PUSH
18459: LD_INT 12
18461: PUSH
18462: LD_INT 13
18464: PUSH
18465: LD_INT 14
18467: PUSH
18468: LD_INT 1
18470: PUSH
18471: LD_INT 2
18473: PUSH
18474: LD_INT 3
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18617
18488: LD_INT 1
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18558
18496: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 11
18504: PUSH
18505: LD_INT 12
18507: PUSH
18508: LD_INT 13
18510: PUSH
18511: LD_INT 14
18513: PUSH
18514: LD_INT 1
18516: PUSH
18517: LD_INT 2
18519: PUSH
18520: LD_INT 3
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: LD_INT 5
18528: PUSH
18529: LD_INT 21
18531: PUSH
18532: LD_INT 23
18534: PUSH
18535: LD_INT 22
18537: PUSH
18538: LD_INT 24
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: ST_TO_ADDR
18556: GO 18617
18558: LD_INT 3
18560: DOUBLE
18561: EQUAL
18562: IFTRUE 18566
18564: GO 18616
18566: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18567: LD_ADDR_VAR 0 3
18571: PUSH
18572: LD_INT 13
18574: PUSH
18575: LD_INT 14
18577: PUSH
18578: LD_INT 2
18580: PUSH
18581: LD_INT 3
18583: PUSH
18584: LD_INT 4
18586: PUSH
18587: LD_INT 5
18589: PUSH
18590: LD_INT 21
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
18614: GO 18617
18616: POP
// result := ( chassis in result ) ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_VAR 0 1
18626: PUSH
18627: LD_VAR 0 3
18631: IN
18632: ST_TO_ADDR
// end ;
18633: LD_VAR 0 3
18637: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18638: LD_INT 0
18640: PPUSH
// if not chassis or not weapon then
18641: LD_VAR 0 1
18645: NOT
18646: PUSH
18647: LD_VAR 0 2
18651: NOT
18652: OR
18653: IFFALSE 18657
// exit ;
18655: GO 19683
// case weapon of us_machine_gun :
18657: LD_VAR 0 2
18661: PUSH
18662: LD_INT 2
18664: DOUBLE
18665: EQUAL
18666: IFTRUE 18670
18668: GO 18700
18670: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: LD_INT 1
18678: PUSH
18679: LD_INT 2
18681: PUSH
18682: LD_INT 3
18684: PUSH
18685: LD_INT 4
18687: PUSH
18688: LD_INT 5
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: ST_TO_ADDR
18698: GO 19667
18700: LD_INT 3
18702: DOUBLE
18703: EQUAL
18704: IFTRUE 18708
18706: GO 18738
18708: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18709: LD_ADDR_VAR 0 3
18713: PUSH
18714: LD_INT 1
18716: PUSH
18717: LD_INT 2
18719: PUSH
18720: LD_INT 3
18722: PUSH
18723: LD_INT 4
18725: PUSH
18726: LD_INT 5
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: LIST
18733: LIST
18734: LIST
18735: ST_TO_ADDR
18736: GO 19667
18738: LD_INT 11
18740: DOUBLE
18741: EQUAL
18742: IFTRUE 18746
18744: GO 18776
18746: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18747: LD_ADDR_VAR 0 3
18751: PUSH
18752: LD_INT 1
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 3
18760: PUSH
18761: LD_INT 4
18763: PUSH
18764: LD_INT 5
18766: PUSH
18767: EMPTY
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: ST_TO_ADDR
18774: GO 19667
18776: LD_INT 4
18778: DOUBLE
18779: EQUAL
18780: IFTRUE 18784
18782: GO 18810
18784: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18785: LD_ADDR_VAR 0 3
18789: PUSH
18790: LD_INT 2
18792: PUSH
18793: LD_INT 3
18795: PUSH
18796: LD_INT 4
18798: PUSH
18799: LD_INT 5
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: ST_TO_ADDR
18808: GO 19667
18810: LD_INT 5
18812: DOUBLE
18813: EQUAL
18814: IFTRUE 18818
18816: GO 18844
18818: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18819: LD_ADDR_VAR 0 3
18823: PUSH
18824: LD_INT 2
18826: PUSH
18827: LD_INT 3
18829: PUSH
18830: LD_INT 4
18832: PUSH
18833: LD_INT 5
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: ST_TO_ADDR
18842: GO 19667
18844: LD_INT 9
18846: DOUBLE
18847: EQUAL
18848: IFTRUE 18852
18850: GO 18878
18852: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18853: LD_ADDR_VAR 0 3
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: LD_INT 3
18863: PUSH
18864: LD_INT 4
18866: PUSH
18867: LD_INT 5
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: LIST
18874: LIST
18875: ST_TO_ADDR
18876: GO 19667
18878: LD_INT 7
18880: DOUBLE
18881: EQUAL
18882: IFTRUE 18886
18884: GO 18912
18886: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18887: LD_ADDR_VAR 0 3
18891: PUSH
18892: LD_INT 2
18894: PUSH
18895: LD_INT 3
18897: PUSH
18898: LD_INT 4
18900: PUSH
18901: LD_INT 5
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: LIST
18908: LIST
18909: ST_TO_ADDR
18910: GO 19667
18912: LD_INT 12
18914: DOUBLE
18915: EQUAL
18916: IFTRUE 18920
18918: GO 18946
18920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18921: LD_ADDR_VAR 0 3
18925: PUSH
18926: LD_INT 2
18928: PUSH
18929: LD_INT 3
18931: PUSH
18932: LD_INT 4
18934: PUSH
18935: LD_INT 5
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: ST_TO_ADDR
18944: GO 19667
18946: LD_INT 13
18948: DOUBLE
18949: EQUAL
18950: IFTRUE 18954
18952: GO 18980
18954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18955: LD_ADDR_VAR 0 3
18959: PUSH
18960: LD_INT 2
18962: PUSH
18963: LD_INT 3
18965: PUSH
18966: LD_INT 4
18968: PUSH
18969: LD_INT 5
18971: PUSH
18972: EMPTY
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: ST_TO_ADDR
18978: GO 19667
18980: LD_INT 14
18982: DOUBLE
18983: EQUAL
18984: IFTRUE 18988
18986: GO 19006
18988: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18989: LD_ADDR_VAR 0 3
18993: PUSH
18994: LD_INT 4
18996: PUSH
18997: LD_INT 5
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: ST_TO_ADDR
19004: GO 19667
19006: LD_INT 6
19008: DOUBLE
19009: EQUAL
19010: IFTRUE 19014
19012: GO 19032
19014: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19015: LD_ADDR_VAR 0 3
19019: PUSH
19020: LD_INT 4
19022: PUSH
19023: LD_INT 5
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: ST_TO_ADDR
19030: GO 19667
19032: LD_INT 10
19034: DOUBLE
19035: EQUAL
19036: IFTRUE 19040
19038: GO 19058
19040: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19041: LD_ADDR_VAR 0 3
19045: PUSH
19046: LD_INT 4
19048: PUSH
19049: LD_INT 5
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: ST_TO_ADDR
19056: GO 19667
19058: LD_INT 22
19060: DOUBLE
19061: EQUAL
19062: IFTRUE 19066
19064: GO 19092
19066: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19067: LD_ADDR_VAR 0 3
19071: PUSH
19072: LD_INT 11
19074: PUSH
19075: LD_INT 12
19077: PUSH
19078: LD_INT 13
19080: PUSH
19081: LD_INT 14
19083: PUSH
19084: EMPTY
19085: LIST
19086: LIST
19087: LIST
19088: LIST
19089: ST_TO_ADDR
19090: GO 19667
19092: LD_INT 23
19094: DOUBLE
19095: EQUAL
19096: IFTRUE 19100
19098: GO 19126
19100: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19101: LD_ADDR_VAR 0 3
19105: PUSH
19106: LD_INT 11
19108: PUSH
19109: LD_INT 12
19111: PUSH
19112: LD_INT 13
19114: PUSH
19115: LD_INT 14
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: ST_TO_ADDR
19124: GO 19667
19126: LD_INT 24
19128: DOUBLE
19129: EQUAL
19130: IFTRUE 19134
19132: GO 19160
19134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19135: LD_ADDR_VAR 0 3
19139: PUSH
19140: LD_INT 11
19142: PUSH
19143: LD_INT 12
19145: PUSH
19146: LD_INT 13
19148: PUSH
19149: LD_INT 14
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: ST_TO_ADDR
19158: GO 19667
19160: LD_INT 30
19162: DOUBLE
19163: EQUAL
19164: IFTRUE 19168
19166: GO 19194
19168: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19169: LD_ADDR_VAR 0 3
19173: PUSH
19174: LD_INT 11
19176: PUSH
19177: LD_INT 12
19179: PUSH
19180: LD_INT 13
19182: PUSH
19183: LD_INT 14
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: ST_TO_ADDR
19192: GO 19667
19194: LD_INT 25
19196: DOUBLE
19197: EQUAL
19198: IFTRUE 19202
19200: GO 19220
19202: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19203: LD_ADDR_VAR 0 3
19207: PUSH
19208: LD_INT 13
19210: PUSH
19211: LD_INT 14
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: ST_TO_ADDR
19218: GO 19667
19220: LD_INT 27
19222: DOUBLE
19223: EQUAL
19224: IFTRUE 19228
19226: GO 19246
19228: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19229: LD_ADDR_VAR 0 3
19233: PUSH
19234: LD_INT 13
19236: PUSH
19237: LD_INT 14
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: ST_TO_ADDR
19244: GO 19667
19246: LD_INT 28
19248: DOUBLE
19249: EQUAL
19250: IFTRUE 19254
19252: GO 19272
19254: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19255: LD_ADDR_VAR 0 3
19259: PUSH
19260: LD_INT 13
19262: PUSH
19263: LD_INT 14
19265: PUSH
19266: EMPTY
19267: LIST
19268: LIST
19269: ST_TO_ADDR
19270: GO 19667
19272: LD_INT 29
19274: DOUBLE
19275: EQUAL
19276: IFTRUE 19280
19278: GO 19298
19280: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19281: LD_ADDR_VAR 0 3
19285: PUSH
19286: LD_INT 13
19288: PUSH
19289: LD_INT 14
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: ST_TO_ADDR
19296: GO 19667
19298: LD_INT 31
19300: DOUBLE
19301: EQUAL
19302: IFTRUE 19306
19304: GO 19324
19306: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19307: LD_ADDR_VAR 0 3
19311: PUSH
19312: LD_INT 13
19314: PUSH
19315: LD_INT 14
19317: PUSH
19318: EMPTY
19319: LIST
19320: LIST
19321: ST_TO_ADDR
19322: GO 19667
19324: LD_INT 26
19326: DOUBLE
19327: EQUAL
19328: IFTRUE 19332
19330: GO 19350
19332: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19333: LD_ADDR_VAR 0 3
19337: PUSH
19338: LD_INT 13
19340: PUSH
19341: LD_INT 14
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: ST_TO_ADDR
19348: GO 19667
19350: LD_INT 42
19352: DOUBLE
19353: EQUAL
19354: IFTRUE 19358
19356: GO 19384
19358: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19359: LD_ADDR_VAR 0 3
19363: PUSH
19364: LD_INT 21
19366: PUSH
19367: LD_INT 22
19369: PUSH
19370: LD_INT 23
19372: PUSH
19373: LD_INT 24
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: ST_TO_ADDR
19382: GO 19667
19384: LD_INT 43
19386: DOUBLE
19387: EQUAL
19388: IFTRUE 19392
19390: GO 19418
19392: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19393: LD_ADDR_VAR 0 3
19397: PUSH
19398: LD_INT 21
19400: PUSH
19401: LD_INT 22
19403: PUSH
19404: LD_INT 23
19406: PUSH
19407: LD_INT 24
19409: PUSH
19410: EMPTY
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: ST_TO_ADDR
19416: GO 19667
19418: LD_INT 44
19420: DOUBLE
19421: EQUAL
19422: IFTRUE 19426
19424: GO 19452
19426: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19427: LD_ADDR_VAR 0 3
19431: PUSH
19432: LD_INT 21
19434: PUSH
19435: LD_INT 22
19437: PUSH
19438: LD_INT 23
19440: PUSH
19441: LD_INT 24
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: ST_TO_ADDR
19450: GO 19667
19452: LD_INT 45
19454: DOUBLE
19455: EQUAL
19456: IFTRUE 19460
19458: GO 19486
19460: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19461: LD_ADDR_VAR 0 3
19465: PUSH
19466: LD_INT 21
19468: PUSH
19469: LD_INT 22
19471: PUSH
19472: LD_INT 23
19474: PUSH
19475: LD_INT 24
19477: PUSH
19478: EMPTY
19479: LIST
19480: LIST
19481: LIST
19482: LIST
19483: ST_TO_ADDR
19484: GO 19667
19486: LD_INT 49
19488: DOUBLE
19489: EQUAL
19490: IFTRUE 19494
19492: GO 19520
19494: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19495: LD_ADDR_VAR 0 3
19499: PUSH
19500: LD_INT 21
19502: PUSH
19503: LD_INT 22
19505: PUSH
19506: LD_INT 23
19508: PUSH
19509: LD_INT 24
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: ST_TO_ADDR
19518: GO 19667
19520: LD_INT 51
19522: DOUBLE
19523: EQUAL
19524: IFTRUE 19528
19526: GO 19554
19528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19529: LD_ADDR_VAR 0 3
19533: PUSH
19534: LD_INT 21
19536: PUSH
19537: LD_INT 22
19539: PUSH
19540: LD_INT 23
19542: PUSH
19543: LD_INT 24
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: LIST
19550: LIST
19551: ST_TO_ADDR
19552: GO 19667
19554: LD_INT 52
19556: DOUBLE
19557: EQUAL
19558: IFTRUE 19562
19560: GO 19588
19562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19563: LD_ADDR_VAR 0 3
19567: PUSH
19568: LD_INT 21
19570: PUSH
19571: LD_INT 22
19573: PUSH
19574: LD_INT 23
19576: PUSH
19577: LD_INT 24
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: ST_TO_ADDR
19586: GO 19667
19588: LD_INT 53
19590: DOUBLE
19591: EQUAL
19592: IFTRUE 19596
19594: GO 19614
19596: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19597: LD_ADDR_VAR 0 3
19601: PUSH
19602: LD_INT 23
19604: PUSH
19605: LD_INT 24
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: ST_TO_ADDR
19612: GO 19667
19614: LD_INT 46
19616: DOUBLE
19617: EQUAL
19618: IFTRUE 19622
19620: GO 19640
19622: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19623: LD_ADDR_VAR 0 3
19627: PUSH
19628: LD_INT 23
19630: PUSH
19631: LD_INT 24
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: ST_TO_ADDR
19638: GO 19667
19640: LD_INT 47
19642: DOUBLE
19643: EQUAL
19644: IFTRUE 19648
19646: GO 19666
19648: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19649: LD_ADDR_VAR 0 3
19653: PUSH
19654: LD_INT 23
19656: PUSH
19657: LD_INT 24
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: ST_TO_ADDR
19664: GO 19667
19666: POP
// result := ( chassis in result ) ;
19667: LD_ADDR_VAR 0 3
19671: PUSH
19672: LD_VAR 0 1
19676: PUSH
19677: LD_VAR 0 3
19681: IN
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 3
19687: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19688: LD_INT 0
19690: PPUSH
19691: PPUSH
19692: PPUSH
19693: PPUSH
19694: PPUSH
19695: PPUSH
19696: PPUSH
// result := array ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_VAR 0 1
19706: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19707: LD_VAR 0 1
19711: NOT
19712: PUSH
19713: LD_VAR 0 2
19717: NOT
19718: OR
19719: PUSH
19720: LD_VAR 0 3
19724: NOT
19725: OR
19726: PUSH
19727: LD_VAR 0 2
19731: PUSH
19732: LD_VAR 0 1
19736: GREATER
19737: OR
19738: PUSH
19739: LD_VAR 0 3
19743: PUSH
19744: LD_VAR 0 1
19748: GREATER
19749: OR
19750: IFFALSE 19754
// exit ;
19752: GO 20050
// if direction then
19754: LD_VAR 0 4
19758: IFFALSE 19822
// begin d := 1 ;
19760: LD_ADDR_VAR 0 9
19764: PUSH
19765: LD_INT 1
19767: ST_TO_ADDR
// if i_from > i_to then
19768: LD_VAR 0 2
19772: PUSH
19773: LD_VAR 0 3
19777: GREATER
19778: IFFALSE 19804
// length := ( array - i_from ) + i_to else
19780: LD_ADDR_VAR 0 11
19784: PUSH
19785: LD_VAR 0 1
19789: PUSH
19790: LD_VAR 0 2
19794: MINUS
19795: PUSH
19796: LD_VAR 0 3
19800: PLUS
19801: ST_TO_ADDR
19802: GO 19820
// length := i_to - i_from ;
19804: LD_ADDR_VAR 0 11
19808: PUSH
19809: LD_VAR 0 3
19813: PUSH
19814: LD_VAR 0 2
19818: MINUS
19819: ST_TO_ADDR
// end else
19820: GO 19883
// begin d := - 1 ;
19822: LD_ADDR_VAR 0 9
19826: PUSH
19827: LD_INT 1
19829: NEG
19830: ST_TO_ADDR
// if i_from > i_to then
19831: LD_VAR 0 2
19835: PUSH
19836: LD_VAR 0 3
19840: GREATER
19841: IFFALSE 19861
// length := i_from - i_to else
19843: LD_ADDR_VAR 0 11
19847: PUSH
19848: LD_VAR 0 2
19852: PUSH
19853: LD_VAR 0 3
19857: MINUS
19858: ST_TO_ADDR
19859: GO 19883
// length := ( array - i_to ) + i_from ;
19861: LD_ADDR_VAR 0 11
19865: PUSH
19866: LD_VAR 0 1
19870: PUSH
19871: LD_VAR 0 3
19875: MINUS
19876: PUSH
19877: LD_VAR 0 2
19881: PLUS
19882: ST_TO_ADDR
// end ; if not length then
19883: LD_VAR 0 11
19887: NOT
19888: IFFALSE 19892
// exit ;
19890: GO 20050
// tmp := array ;
19892: LD_ADDR_VAR 0 10
19896: PUSH
19897: LD_VAR 0 1
19901: ST_TO_ADDR
// for i = 1 to length do
19902: LD_ADDR_VAR 0 6
19906: PUSH
19907: DOUBLE
19908: LD_INT 1
19910: DEC
19911: ST_TO_ADDR
19912: LD_VAR 0 11
19916: PUSH
19917: FOR_TO
19918: IFFALSE 20038
// begin for j = 1 to array do
19920: LD_ADDR_VAR 0 7
19924: PUSH
19925: DOUBLE
19926: LD_INT 1
19928: DEC
19929: ST_TO_ADDR
19930: LD_VAR 0 1
19934: PUSH
19935: FOR_TO
19936: IFFALSE 20024
// begin k := j + d ;
19938: LD_ADDR_VAR 0 8
19942: PUSH
19943: LD_VAR 0 7
19947: PUSH
19948: LD_VAR 0 9
19952: PLUS
19953: ST_TO_ADDR
// if k > array then
19954: LD_VAR 0 8
19958: PUSH
19959: LD_VAR 0 1
19963: GREATER
19964: IFFALSE 19974
// k := 1 ;
19966: LD_ADDR_VAR 0 8
19970: PUSH
19971: LD_INT 1
19973: ST_TO_ADDR
// if not k then
19974: LD_VAR 0 8
19978: NOT
19979: IFFALSE 19991
// k := array ;
19981: LD_ADDR_VAR 0 8
19985: PUSH
19986: LD_VAR 0 1
19990: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19991: LD_ADDR_VAR 0 10
19995: PUSH
19996: LD_VAR 0 10
20000: PPUSH
20001: LD_VAR 0 8
20005: PPUSH
20006: LD_VAR 0 1
20010: PUSH
20011: LD_VAR 0 7
20015: ARRAY
20016: PPUSH
20017: CALL_OW 1
20021: ST_TO_ADDR
// end ;
20022: GO 19935
20024: POP
20025: POP
// array := tmp ;
20026: LD_ADDR_VAR 0 1
20030: PUSH
20031: LD_VAR 0 10
20035: ST_TO_ADDR
// end ;
20036: GO 19917
20038: POP
20039: POP
// result := array ;
20040: LD_ADDR_VAR 0 5
20044: PUSH
20045: LD_VAR 0 1
20049: ST_TO_ADDR
// end ;
20050: LD_VAR 0 5
20054: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20055: LD_INT 0
20057: PPUSH
20058: PPUSH
// result := 0 ;
20059: LD_ADDR_VAR 0 3
20063: PUSH
20064: LD_INT 0
20066: ST_TO_ADDR
// if not array or not value in array then
20067: LD_VAR 0 1
20071: NOT
20072: PUSH
20073: LD_VAR 0 2
20077: PUSH
20078: LD_VAR 0 1
20082: IN
20083: NOT
20084: OR
20085: IFFALSE 20089
// exit ;
20087: GO 20143
// for i = 1 to array do
20089: LD_ADDR_VAR 0 4
20093: PUSH
20094: DOUBLE
20095: LD_INT 1
20097: DEC
20098: ST_TO_ADDR
20099: LD_VAR 0 1
20103: PUSH
20104: FOR_TO
20105: IFFALSE 20141
// if value = array [ i ] then
20107: LD_VAR 0 2
20111: PUSH
20112: LD_VAR 0 1
20116: PUSH
20117: LD_VAR 0 4
20121: ARRAY
20122: EQUAL
20123: IFFALSE 20139
// begin result := i ;
20125: LD_ADDR_VAR 0 3
20129: PUSH
20130: LD_VAR 0 4
20134: ST_TO_ADDR
// exit ;
20135: POP
20136: POP
20137: GO 20143
// end ;
20139: GO 20104
20141: POP
20142: POP
// end ;
20143: LD_VAR 0 3
20147: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20148: LD_INT 0
20150: PPUSH
// vc_chassis := chassis ;
20151: LD_ADDR_OWVAR 37
20155: PUSH
20156: LD_VAR 0 1
20160: ST_TO_ADDR
// vc_engine := engine ;
20161: LD_ADDR_OWVAR 39
20165: PUSH
20166: LD_VAR 0 2
20170: ST_TO_ADDR
// vc_control := control ;
20171: LD_ADDR_OWVAR 38
20175: PUSH
20176: LD_VAR 0 3
20180: ST_TO_ADDR
// vc_weapon := weapon ;
20181: LD_ADDR_OWVAR 40
20185: PUSH
20186: LD_VAR 0 4
20190: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20191: LD_ADDR_OWVAR 41
20195: PUSH
20196: LD_VAR 0 5
20200: ST_TO_ADDR
// end ;
20201: LD_VAR 0 6
20205: RET
// export function WantPlant ( unit ) ; var task ; begin
20206: LD_INT 0
20208: PPUSH
20209: PPUSH
// result := false ;
20210: LD_ADDR_VAR 0 2
20214: PUSH
20215: LD_INT 0
20217: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20218: LD_ADDR_VAR 0 3
20222: PUSH
20223: LD_VAR 0 1
20227: PPUSH
20228: CALL_OW 437
20232: ST_TO_ADDR
// if task then
20233: LD_VAR 0 3
20237: IFFALSE 20265
// if task [ 1 ] [ 1 ] = p then
20239: LD_VAR 0 3
20243: PUSH
20244: LD_INT 1
20246: ARRAY
20247: PUSH
20248: LD_INT 1
20250: ARRAY
20251: PUSH
20252: LD_STRING p
20254: EQUAL
20255: IFFALSE 20265
// result := true ;
20257: LD_ADDR_VAR 0 2
20261: PUSH
20262: LD_INT 1
20264: ST_TO_ADDR
// end ;
20265: LD_VAR 0 2
20269: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20270: LD_INT 0
20272: PPUSH
20273: PPUSH
20274: PPUSH
20275: PPUSH
// if pos < 1 then
20276: LD_VAR 0 2
20280: PUSH
20281: LD_INT 1
20283: LESS
20284: IFFALSE 20288
// exit ;
20286: GO 20591
// if pos = 1 then
20288: LD_VAR 0 2
20292: PUSH
20293: LD_INT 1
20295: EQUAL
20296: IFFALSE 20329
// result := Replace ( arr , pos [ 1 ] , value ) else
20298: LD_ADDR_VAR 0 4
20302: PUSH
20303: LD_VAR 0 1
20307: PPUSH
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 3
20321: PPUSH
20322: CALL_OW 1
20326: ST_TO_ADDR
20327: GO 20591
// begin tmp := arr ;
20329: LD_ADDR_VAR 0 6
20333: PUSH
20334: LD_VAR 0 1
20338: ST_TO_ADDR
// s_arr := [ tmp ] ;
20339: LD_ADDR_VAR 0 7
20343: PUSH
20344: LD_VAR 0 6
20348: PUSH
20349: EMPTY
20350: LIST
20351: ST_TO_ADDR
// for i = 1 to pos - 1 do
20352: LD_ADDR_VAR 0 5
20356: PUSH
20357: DOUBLE
20358: LD_INT 1
20360: DEC
20361: ST_TO_ADDR
20362: LD_VAR 0 2
20366: PUSH
20367: LD_INT 1
20369: MINUS
20370: PUSH
20371: FOR_TO
20372: IFFALSE 20417
// begin tmp := tmp [ pos [ i ] ] ;
20374: LD_ADDR_VAR 0 6
20378: PUSH
20379: LD_VAR 0 6
20383: PUSH
20384: LD_VAR 0 2
20388: PUSH
20389: LD_VAR 0 5
20393: ARRAY
20394: ARRAY
20395: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20396: LD_ADDR_VAR 0 7
20400: PUSH
20401: LD_VAR 0 7
20405: PUSH
20406: LD_VAR 0 6
20410: PUSH
20411: EMPTY
20412: LIST
20413: ADD
20414: ST_TO_ADDR
// end ;
20415: GO 20371
20417: POP
20418: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20419: LD_ADDR_VAR 0 6
20423: PUSH
20424: LD_VAR 0 6
20428: PPUSH
20429: LD_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: ARRAY
20439: PPUSH
20440: LD_VAR 0 3
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20450: LD_ADDR_VAR 0 7
20454: PUSH
20455: LD_VAR 0 7
20459: PPUSH
20460: LD_VAR 0 7
20464: PPUSH
20465: LD_VAR 0 6
20469: PPUSH
20470: CALL_OW 1
20474: ST_TO_ADDR
// for i = s_arr downto 2 do
20475: LD_ADDR_VAR 0 5
20479: PUSH
20480: DOUBLE
20481: LD_VAR 0 7
20485: INC
20486: ST_TO_ADDR
20487: LD_INT 2
20489: PUSH
20490: FOR_DOWNTO
20491: IFFALSE 20575
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20493: LD_ADDR_VAR 0 6
20497: PUSH
20498: LD_VAR 0 7
20502: PUSH
20503: LD_VAR 0 5
20507: PUSH
20508: LD_INT 1
20510: MINUS
20511: ARRAY
20512: PPUSH
20513: LD_VAR 0 2
20517: PUSH
20518: LD_VAR 0 5
20522: PUSH
20523: LD_INT 1
20525: MINUS
20526: ARRAY
20527: PPUSH
20528: LD_VAR 0 7
20532: PUSH
20533: LD_VAR 0 5
20537: ARRAY
20538: PPUSH
20539: CALL_OW 1
20543: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20544: LD_ADDR_VAR 0 7
20548: PUSH
20549: LD_VAR 0 7
20553: PPUSH
20554: LD_VAR 0 5
20558: PUSH
20559: LD_INT 1
20561: MINUS
20562: PPUSH
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 1
20572: ST_TO_ADDR
// end ;
20573: GO 20490
20575: POP
20576: POP
// result := s_arr [ 1 ] ;
20577: LD_ADDR_VAR 0 4
20581: PUSH
20582: LD_VAR 0 7
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: ST_TO_ADDR
// end ; end ;
20591: LD_VAR 0 4
20595: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20596: LD_INT 0
20598: PPUSH
20599: PPUSH
// if not list then
20600: LD_VAR 0 1
20604: NOT
20605: IFFALSE 20609
// exit ;
20607: GO 20700
// i := list [ pos1 ] ;
20609: LD_ADDR_VAR 0 5
20613: PUSH
20614: LD_VAR 0 1
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: ST_TO_ADDR
// if not i then
20625: LD_VAR 0 5
20629: NOT
20630: IFFALSE 20634
// exit ;
20632: GO 20700
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20634: LD_ADDR_VAR 0 1
20638: PUSH
20639: LD_VAR 0 1
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: LD_VAR 0 1
20653: PUSH
20654: LD_VAR 0 3
20658: ARRAY
20659: PPUSH
20660: CALL_OW 1
20664: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20665: LD_ADDR_VAR 0 1
20669: PUSH
20670: LD_VAR 0 1
20674: PPUSH
20675: LD_VAR 0 3
20679: PPUSH
20680: LD_VAR 0 5
20684: PPUSH
20685: CALL_OW 1
20689: ST_TO_ADDR
// result := list ;
20690: LD_ADDR_VAR 0 4
20694: PUSH
20695: LD_VAR 0 1
20699: ST_TO_ADDR
// end ;
20700: LD_VAR 0 4
20704: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20705: LD_INT 0
20707: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: LD_VAR 0 1
20717: PPUSH
20718: CALL_OW 250
20722: PPUSH
20723: LD_VAR 0 1
20727: PPUSH
20728: CALL_OW 251
20732: PPUSH
20733: LD_VAR 0 2
20737: PPUSH
20738: LD_VAR 0 3
20742: PPUSH
20743: LD_VAR 0 4
20747: PPUSH
20748: CALL 20758 0 5
20752: ST_TO_ADDR
// end ;
20753: LD_VAR 0 5
20757: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not list then
20764: LD_VAR 0 3
20768: NOT
20769: IFFALSE 20773
// exit ;
20771: GO 21161
// result := [ ] ;
20773: LD_ADDR_VAR 0 6
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// for i in list do
20780: LD_ADDR_VAR 0 7
20784: PUSH
20785: LD_VAR 0 3
20789: PUSH
20790: FOR_IN
20791: IFFALSE 20993
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20793: LD_ADDR_VAR 0 9
20797: PUSH
20798: LD_VAR 0 7
20802: PPUSH
20803: LD_VAR 0 1
20807: PPUSH
20808: LD_VAR 0 2
20812: PPUSH
20813: CALL_OW 297
20817: ST_TO_ADDR
// if not result then
20818: LD_VAR 0 6
20822: NOT
20823: IFFALSE 20849
// result := [ [ i , tmp ] ] else
20825: LD_ADDR_VAR 0 6
20829: PUSH
20830: LD_VAR 0 7
20834: PUSH
20835: LD_VAR 0 9
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: PUSH
20844: EMPTY
20845: LIST
20846: ST_TO_ADDR
20847: GO 20991
// begin if result [ result ] [ 2 ] < tmp then
20849: LD_VAR 0 6
20853: PUSH
20854: LD_VAR 0 6
20858: ARRAY
20859: PUSH
20860: LD_INT 2
20862: ARRAY
20863: PUSH
20864: LD_VAR 0 9
20868: LESS
20869: IFFALSE 20911
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20871: LD_ADDR_VAR 0 6
20875: PUSH
20876: LD_VAR 0 6
20880: PPUSH
20881: LD_VAR 0 6
20885: PUSH
20886: LD_INT 1
20888: PLUS
20889: PPUSH
20890: LD_VAR 0 7
20894: PUSH
20895: LD_VAR 0 9
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PPUSH
20904: CALL_OW 2
20908: ST_TO_ADDR
20909: GO 20991
// for j = 1 to result do
20911: LD_ADDR_VAR 0 8
20915: PUSH
20916: DOUBLE
20917: LD_INT 1
20919: DEC
20920: ST_TO_ADDR
20921: LD_VAR 0 6
20925: PUSH
20926: FOR_TO
20927: IFFALSE 20989
// begin if tmp < result [ j ] [ 2 ] then
20929: LD_VAR 0 9
20933: PUSH
20934: LD_VAR 0 6
20938: PUSH
20939: LD_VAR 0 8
20943: ARRAY
20944: PUSH
20945: LD_INT 2
20947: ARRAY
20948: LESS
20949: IFFALSE 20987
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20951: LD_ADDR_VAR 0 6
20955: PUSH
20956: LD_VAR 0 6
20960: PPUSH
20961: LD_VAR 0 8
20965: PPUSH
20966: LD_VAR 0 7
20970: PUSH
20971: LD_VAR 0 9
20975: PUSH
20976: EMPTY
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 2
20984: ST_TO_ADDR
// break ;
20985: GO 20989
// end ; end ;
20987: GO 20926
20989: POP
20990: POP
// end ; end ;
20991: GO 20790
20993: POP
20994: POP
// if result and not asc then
20995: LD_VAR 0 6
20999: PUSH
21000: LD_VAR 0 4
21004: NOT
21005: AND
21006: IFFALSE 21081
// begin tmp := result ;
21008: LD_ADDR_VAR 0 9
21012: PUSH
21013: LD_VAR 0 6
21017: ST_TO_ADDR
// for i = tmp downto 1 do
21018: LD_ADDR_VAR 0 7
21022: PUSH
21023: DOUBLE
21024: LD_VAR 0 9
21028: INC
21029: ST_TO_ADDR
21030: LD_INT 1
21032: PUSH
21033: FOR_DOWNTO
21034: IFFALSE 21079
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21036: LD_ADDR_VAR 0 6
21040: PUSH
21041: LD_VAR 0 6
21045: PPUSH
21046: LD_VAR 0 9
21050: PUSH
21051: LD_VAR 0 7
21055: MINUS
21056: PUSH
21057: LD_INT 1
21059: PLUS
21060: PPUSH
21061: LD_VAR 0 9
21065: PUSH
21066: LD_VAR 0 7
21070: ARRAY
21071: PPUSH
21072: CALL_OW 1
21076: ST_TO_ADDR
21077: GO 21033
21079: POP
21080: POP
// end ; tmp := [ ] ;
21081: LD_ADDR_VAR 0 9
21085: PUSH
21086: EMPTY
21087: ST_TO_ADDR
// if mode then
21088: LD_VAR 0 5
21092: IFFALSE 21161
// begin for i = 1 to result do
21094: LD_ADDR_VAR 0 7
21098: PUSH
21099: DOUBLE
21100: LD_INT 1
21102: DEC
21103: ST_TO_ADDR
21104: LD_VAR 0 6
21108: PUSH
21109: FOR_TO
21110: IFFALSE 21149
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21112: LD_ADDR_VAR 0 9
21116: PUSH
21117: LD_VAR 0 9
21121: PPUSH
21122: LD_VAR 0 7
21126: PPUSH
21127: LD_VAR 0 6
21131: PUSH
21132: LD_VAR 0 7
21136: ARRAY
21137: PUSH
21138: LD_INT 1
21140: ARRAY
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
21147: GO 21109
21149: POP
21150: POP
// result := tmp ;
21151: LD_ADDR_VAR 0 6
21155: PUSH
21156: LD_VAR 0 9
21160: ST_TO_ADDR
// end ; end ;
21161: LD_VAR 0 6
21165: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21166: LD_INT 0
21168: PPUSH
21169: PPUSH
21170: PPUSH
21171: PPUSH
21172: PPUSH
21173: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21174: LD_ADDR_VAR 0 5
21178: PUSH
21179: LD_INT 0
21181: PUSH
21182: LD_INT 0
21184: PUSH
21185: LD_INT 0
21187: PUSH
21188: EMPTY
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: ST_TO_ADDR
// if not x or not y then
21196: LD_VAR 0 2
21200: NOT
21201: PUSH
21202: LD_VAR 0 3
21206: NOT
21207: OR
21208: IFFALSE 21212
// exit ;
21210: GO 22858
// if not range then
21212: LD_VAR 0 4
21216: NOT
21217: IFFALSE 21227
// range := 10 ;
21219: LD_ADDR_VAR 0 4
21223: PUSH
21224: LD_INT 10
21226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21227: LD_ADDR_VAR 0 8
21231: PUSH
21232: LD_INT 81
21234: PUSH
21235: LD_VAR 0 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: LD_INT 92
21246: PUSH
21247: LD_VAR 0 2
21251: PUSH
21252: LD_VAR 0 3
21256: PUSH
21257: LD_VAR 0 4
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 3
21270: PUSH
21271: LD_INT 21
21273: PUSH
21274: LD_INT 3
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: PPUSH
21290: CALL_OW 69
21294: ST_TO_ADDR
// if not tmp then
21295: LD_VAR 0 8
21299: NOT
21300: IFFALSE 21304
// exit ;
21302: GO 22858
// for i in tmp do
21304: LD_ADDR_VAR 0 6
21308: PUSH
21309: LD_VAR 0 8
21313: PUSH
21314: FOR_IN
21315: IFFALSE 22833
// begin points := [ 0 , 0 , 0 ] ;
21317: LD_ADDR_VAR 0 9
21321: PUSH
21322: LD_INT 0
21324: PUSH
21325: LD_INT 0
21327: PUSH
21328: LD_INT 0
21330: PUSH
21331: EMPTY
21332: LIST
21333: LIST
21334: LIST
21335: ST_TO_ADDR
// bpoints := 1 ;
21336: LD_ADDR_VAR 0 10
21340: PUSH
21341: LD_INT 1
21343: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21344: LD_VAR 0 6
21348: PPUSH
21349: CALL_OW 247
21353: PUSH
21354: LD_INT 1
21356: DOUBLE
21357: EQUAL
21358: IFTRUE 21362
21360: GO 21940
21362: POP
// begin if GetClass ( i ) = 1 then
21363: LD_VAR 0 6
21367: PPUSH
21368: CALL_OW 257
21372: PUSH
21373: LD_INT 1
21375: EQUAL
21376: IFFALSE 21397
// points := [ 10 , 5 , 3 ] ;
21378: LD_ADDR_VAR 0 9
21382: PUSH
21383: LD_INT 10
21385: PUSH
21386: LD_INT 5
21388: PUSH
21389: LD_INT 3
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21397: LD_VAR 0 6
21401: PPUSH
21402: CALL_OW 257
21406: PUSH
21407: LD_INT 2
21409: PUSH
21410: LD_INT 3
21412: PUSH
21413: LD_INT 4
21415: PUSH
21416: EMPTY
21417: LIST
21418: LIST
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 3 , 2 , 1 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 3
21430: PUSH
21431: LD_INT 2
21433: PUSH
21434: LD_INT 1
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 257
21451: PUSH
21452: LD_INT 5
21454: EQUAL
21455: IFFALSE 21476
// points := [ 130 , 5 , 2 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 130
21464: PUSH
21465: LD_INT 5
21467: PUSH
21468: LD_INT 2
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 257
21485: PUSH
21486: LD_INT 8
21488: EQUAL
21489: IFFALSE 21510
// points := [ 35 , 35 , 30 ] ;
21491: LD_ADDR_VAR 0 9
21495: PUSH
21496: LD_INT 35
21498: PUSH
21499: LD_INT 35
21501: PUSH
21502: LD_INT 30
21504: PUSH
21505: EMPTY
21506: LIST
21507: LIST
21508: LIST
21509: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21510: LD_VAR 0 6
21514: PPUSH
21515: CALL_OW 257
21519: PUSH
21520: LD_INT 9
21522: EQUAL
21523: IFFALSE 21544
// points := [ 20 , 55 , 40 ] ;
21525: LD_ADDR_VAR 0 9
21529: PUSH
21530: LD_INT 20
21532: PUSH
21533: LD_INT 55
21535: PUSH
21536: LD_INT 40
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: LIST
21543: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 257
21553: PUSH
21554: LD_INT 12
21556: PUSH
21557: LD_INT 16
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: IN
21564: IFFALSE 21585
// points := [ 5 , 3 , 2 ] ;
21566: LD_ADDR_VAR 0 9
21570: PUSH
21571: LD_INT 5
21573: PUSH
21574: LD_INT 3
21576: PUSH
21577: LD_INT 2
21579: PUSH
21580: EMPTY
21581: LIST
21582: LIST
21583: LIST
21584: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21585: LD_VAR 0 6
21589: PPUSH
21590: CALL_OW 257
21594: PUSH
21595: LD_INT 17
21597: EQUAL
21598: IFFALSE 21619
// points := [ 100 , 50 , 75 ] ;
21600: LD_ADDR_VAR 0 9
21604: PUSH
21605: LD_INT 100
21607: PUSH
21608: LD_INT 50
21610: PUSH
21611: LD_INT 75
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: LIST
21618: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21619: LD_VAR 0 6
21623: PPUSH
21624: CALL_OW 257
21628: PUSH
21629: LD_INT 15
21631: EQUAL
21632: IFFALSE 21653
// points := [ 10 , 5 , 3 ] ;
21634: LD_ADDR_VAR 0 9
21638: PUSH
21639: LD_INT 10
21641: PUSH
21642: LD_INT 5
21644: PUSH
21645: LD_INT 3
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21653: LD_VAR 0 6
21657: PPUSH
21658: CALL_OW 257
21662: PUSH
21663: LD_INT 14
21665: EQUAL
21666: IFFALSE 21687
// points := [ 10 , 0 , 0 ] ;
21668: LD_ADDR_VAR 0 9
21672: PUSH
21673: LD_INT 10
21675: PUSH
21676: LD_INT 0
21678: PUSH
21679: LD_INT 0
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: LIST
21686: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21687: LD_VAR 0 6
21691: PPUSH
21692: CALL_OW 257
21696: PUSH
21697: LD_INT 11
21699: EQUAL
21700: IFFALSE 21721
// points := [ 30 , 10 , 5 ] ;
21702: LD_ADDR_VAR 0 9
21706: PUSH
21707: LD_INT 30
21709: PUSH
21710: LD_INT 10
21712: PUSH
21713: LD_INT 5
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: LIST
21720: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21721: LD_VAR 0 1
21725: PPUSH
21726: LD_INT 5
21728: PPUSH
21729: CALL_OW 321
21733: PUSH
21734: LD_INT 2
21736: EQUAL
21737: IFFALSE 21754
// bpoints := bpoints * 1.8 ;
21739: LD_ADDR_VAR 0 10
21743: PUSH
21744: LD_VAR 0 10
21748: PUSH
21749: LD_REAL  1.80000000000000E+0000
21752: MUL
21753: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21754: LD_VAR 0 6
21758: PPUSH
21759: CALL_OW 257
21763: PUSH
21764: LD_INT 1
21766: PUSH
21767: LD_INT 2
21769: PUSH
21770: LD_INT 3
21772: PUSH
21773: LD_INT 4
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: IN
21782: PUSH
21783: LD_VAR 0 1
21787: PPUSH
21788: LD_INT 51
21790: PPUSH
21791: CALL_OW 321
21795: PUSH
21796: LD_INT 2
21798: EQUAL
21799: AND
21800: IFFALSE 21817
// bpoints := bpoints * 1.2 ;
21802: LD_ADDR_VAR 0 10
21806: PUSH
21807: LD_VAR 0 10
21811: PUSH
21812: LD_REAL  1.20000000000000E+0000
21815: MUL
21816: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21817: LD_VAR 0 6
21821: PPUSH
21822: CALL_OW 257
21826: PUSH
21827: LD_INT 5
21829: PUSH
21830: LD_INT 7
21832: PUSH
21833: LD_INT 9
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: LIST
21840: IN
21841: PUSH
21842: LD_VAR 0 1
21846: PPUSH
21847: LD_INT 52
21849: PPUSH
21850: CALL_OW 321
21854: PUSH
21855: LD_INT 2
21857: EQUAL
21858: AND
21859: IFFALSE 21876
// bpoints := bpoints * 1.5 ;
21861: LD_ADDR_VAR 0 10
21865: PUSH
21866: LD_VAR 0 10
21870: PUSH
21871: LD_REAL  1.50000000000000E+0000
21874: MUL
21875: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21876: LD_VAR 0 1
21880: PPUSH
21881: LD_INT 66
21883: PPUSH
21884: CALL_OW 321
21888: PUSH
21889: LD_INT 2
21891: EQUAL
21892: IFFALSE 21909
// bpoints := bpoints * 1.1 ;
21894: LD_ADDR_VAR 0 10
21898: PUSH
21899: LD_VAR 0 10
21903: PUSH
21904: LD_REAL  1.10000000000000E+0000
21907: MUL
21908: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21909: LD_ADDR_VAR 0 10
21913: PUSH
21914: LD_VAR 0 10
21918: PUSH
21919: LD_VAR 0 6
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 259
21931: PUSH
21932: LD_REAL  1.15000000000000E+0000
21935: MUL
21936: MUL
21937: ST_TO_ADDR
// end ; unit_vehicle :
21938: GO 22762
21940: LD_INT 2
21942: DOUBLE
21943: EQUAL
21944: IFTRUE 21948
21946: GO 22750
21948: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21949: LD_VAR 0 6
21953: PPUSH
21954: CALL_OW 264
21958: PUSH
21959: LD_INT 2
21961: PUSH
21962: LD_INT 42
21964: PUSH
21965: LD_INT 24
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: LIST
21972: IN
21973: IFFALSE 21994
// points := [ 25 , 5 , 3 ] ;
21975: LD_ADDR_VAR 0 9
21979: PUSH
21980: LD_INT 25
21982: PUSH
21983: LD_INT 5
21985: PUSH
21986: LD_INT 3
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: LIST
21993: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21994: LD_VAR 0 6
21998: PPUSH
21999: CALL_OW 264
22003: PUSH
22004: LD_INT 4
22006: PUSH
22007: LD_INT 43
22009: PUSH
22010: LD_INT 25
22012: PUSH
22013: EMPTY
22014: LIST
22015: LIST
22016: LIST
22017: IN
22018: IFFALSE 22039
// points := [ 40 , 15 , 5 ] ;
22020: LD_ADDR_VAR 0 9
22024: PUSH
22025: LD_INT 40
22027: PUSH
22028: LD_INT 15
22030: PUSH
22031: LD_INT 5
22033: PUSH
22034: EMPTY
22035: LIST
22036: LIST
22037: LIST
22038: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22039: LD_VAR 0 6
22043: PPUSH
22044: CALL_OW 264
22048: PUSH
22049: LD_INT 3
22051: PUSH
22052: LD_INT 23
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: IN
22059: IFFALSE 22080
// points := [ 7 , 25 , 8 ] ;
22061: LD_ADDR_VAR 0 9
22065: PUSH
22066: LD_INT 7
22068: PUSH
22069: LD_INT 25
22071: PUSH
22072: LD_INT 8
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: LIST
22079: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22080: LD_VAR 0 6
22084: PPUSH
22085: CALL_OW 264
22089: PUSH
22090: LD_INT 5
22092: PUSH
22093: LD_INT 27
22095: PUSH
22096: LD_INT 44
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: LIST
22103: IN
22104: IFFALSE 22125
// points := [ 14 , 50 , 16 ] ;
22106: LD_ADDR_VAR 0 9
22110: PUSH
22111: LD_INT 14
22113: PUSH
22114: LD_INT 50
22116: PUSH
22117: LD_INT 16
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: LIST
22124: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22125: LD_VAR 0 6
22129: PPUSH
22130: CALL_OW 264
22134: PUSH
22135: LD_INT 6
22137: PUSH
22138: LD_INT 46
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: IN
22145: IFFALSE 22166
// points := [ 32 , 120 , 70 ] ;
22147: LD_ADDR_VAR 0 9
22151: PUSH
22152: LD_INT 32
22154: PUSH
22155: LD_INT 120
22157: PUSH
22158: LD_INT 70
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: LIST
22165: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22166: LD_VAR 0 6
22170: PPUSH
22171: CALL_OW 264
22175: PUSH
22176: LD_INT 7
22178: PUSH
22179: LD_INT 28
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: LIST
22189: IN
22190: IFFALSE 22211
// points := [ 35 , 20 , 45 ] ;
22192: LD_ADDR_VAR 0 9
22196: PUSH
22197: LD_INT 35
22199: PUSH
22200: LD_INT 20
22202: PUSH
22203: LD_INT 45
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22211: LD_VAR 0 6
22215: PPUSH
22216: CALL_OW 264
22220: PUSH
22221: LD_INT 47
22223: PUSH
22224: EMPTY
22225: LIST
22226: IN
22227: IFFALSE 22248
// points := [ 67 , 45 , 75 ] ;
22229: LD_ADDR_VAR 0 9
22233: PUSH
22234: LD_INT 67
22236: PUSH
22237: LD_INT 45
22239: PUSH
22240: LD_INT 75
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: LIST
22247: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22248: LD_VAR 0 6
22252: PPUSH
22253: CALL_OW 264
22257: PUSH
22258: LD_INT 26
22260: PUSH
22261: EMPTY
22262: LIST
22263: IN
22264: IFFALSE 22285
// points := [ 120 , 30 , 80 ] ;
22266: LD_ADDR_VAR 0 9
22270: PUSH
22271: LD_INT 120
22273: PUSH
22274: LD_INT 30
22276: PUSH
22277: LD_INT 80
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: LIST
22284: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22285: LD_VAR 0 6
22289: PPUSH
22290: CALL_OW 264
22294: PUSH
22295: LD_INT 22
22297: PUSH
22298: EMPTY
22299: LIST
22300: IN
22301: IFFALSE 22322
// points := [ 40 , 1 , 1 ] ;
22303: LD_ADDR_VAR 0 9
22307: PUSH
22308: LD_INT 40
22310: PUSH
22311: LD_INT 1
22313: PUSH
22314: LD_INT 1
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: LIST
22321: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22322: LD_VAR 0 6
22326: PPUSH
22327: CALL_OW 264
22331: PUSH
22332: LD_INT 29
22334: PUSH
22335: EMPTY
22336: LIST
22337: IN
22338: IFFALSE 22359
// points := [ 70 , 200 , 400 ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: LD_INT 70
22347: PUSH
22348: LD_INT 200
22350: PUSH
22351: LD_INT 400
22353: PUSH
22354: EMPTY
22355: LIST
22356: LIST
22357: LIST
22358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 53
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: IN
22379: IFFALSE 22400
// points := [ 40 , 10 , 20 ] ;
22381: LD_ADDR_VAR 0 9
22385: PUSH
22386: LD_INT 40
22388: PUSH
22389: LD_INT 10
22391: PUSH
22392: LD_INT 20
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: LIST
22399: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22400: LD_VAR 0 6
22404: PPUSH
22405: CALL_OW 264
22409: PUSH
22410: LD_INT 9
22412: PUSH
22413: EMPTY
22414: LIST
22415: IN
22416: IFFALSE 22437
// points := [ 5 , 70 , 20 ] ;
22418: LD_ADDR_VAR 0 9
22422: PUSH
22423: LD_INT 5
22425: PUSH
22426: LD_INT 70
22428: PUSH
22429: LD_INT 20
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: LIST
22436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22437: LD_VAR 0 6
22441: PPUSH
22442: CALL_OW 264
22446: PUSH
22447: LD_INT 10
22449: PUSH
22450: EMPTY
22451: LIST
22452: IN
22453: IFFALSE 22474
// points := [ 35 , 110 , 70 ] ;
22455: LD_ADDR_VAR 0 9
22459: PUSH
22460: LD_INT 35
22462: PUSH
22463: LD_INT 110
22465: PUSH
22466: LD_INT 70
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: LIST
22473: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22474: LD_VAR 0 6
22478: PPUSH
22479: CALL_OW 265
22483: PUSH
22484: LD_INT 25
22486: EQUAL
22487: IFFALSE 22508
// points := [ 80 , 65 , 100 ] ;
22489: LD_ADDR_VAR 0 9
22493: PUSH
22494: LD_INT 80
22496: PUSH
22497: LD_INT 65
22499: PUSH
22500: LD_INT 100
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: LIST
22507: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22508: LD_VAR 0 6
22512: PPUSH
22513: CALL_OW 263
22517: PUSH
22518: LD_INT 1
22520: EQUAL
22521: IFFALSE 22556
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22523: LD_ADDR_VAR 0 10
22527: PUSH
22528: LD_VAR 0 10
22532: PUSH
22533: LD_VAR 0 6
22537: PPUSH
22538: CALL_OW 311
22542: PPUSH
22543: LD_INT 3
22545: PPUSH
22546: CALL_OW 259
22550: PUSH
22551: LD_INT 4
22553: MUL
22554: MUL
22555: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22556: LD_VAR 0 6
22560: PPUSH
22561: CALL_OW 263
22565: PUSH
22566: LD_INT 2
22568: EQUAL
22569: IFFALSE 22620
// begin j := IsControledBy ( i ) ;
22571: LD_ADDR_VAR 0 7
22575: PUSH
22576: LD_VAR 0 6
22580: PPUSH
22581: CALL_OW 312
22585: ST_TO_ADDR
// if j then
22586: LD_VAR 0 7
22590: IFFALSE 22620
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22592: LD_ADDR_VAR 0 10
22596: PUSH
22597: LD_VAR 0 10
22601: PUSH
22602: LD_VAR 0 7
22606: PPUSH
22607: LD_INT 3
22609: PPUSH
22610: CALL_OW 259
22614: PUSH
22615: LD_INT 3
22617: MUL
22618: MUL
22619: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22620: LD_VAR 0 6
22624: PPUSH
22625: CALL_OW 264
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: LD_INT 6
22635: PUSH
22636: LD_INT 46
22638: PUSH
22639: LD_INT 44
22641: PUSH
22642: LD_INT 47
22644: PUSH
22645: LD_INT 45
22647: PUSH
22648: LD_INT 28
22650: PUSH
22651: LD_INT 7
22653: PUSH
22654: LD_INT 27
22656: PUSH
22657: LD_INT 29
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: LIST
22671: IN
22672: PUSH
22673: LD_VAR 0 1
22677: PPUSH
22678: LD_INT 52
22680: PPUSH
22681: CALL_OW 321
22685: PUSH
22686: LD_INT 2
22688: EQUAL
22689: AND
22690: IFFALSE 22707
// bpoints := bpoints * 1.2 ;
22692: LD_ADDR_VAR 0 10
22696: PUSH
22697: LD_VAR 0 10
22701: PUSH
22702: LD_REAL  1.20000000000000E+0000
22705: MUL
22706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22707: LD_VAR 0 6
22711: PPUSH
22712: CALL_OW 264
22716: PUSH
22717: LD_INT 6
22719: PUSH
22720: LD_INT 46
22722: PUSH
22723: LD_INT 47
22725: PUSH
22726: EMPTY
22727: LIST
22728: LIST
22729: LIST
22730: IN
22731: IFFALSE 22748
// bpoints := bpoints * 1.2 ;
22733: LD_ADDR_VAR 0 10
22737: PUSH
22738: LD_VAR 0 10
22742: PUSH
22743: LD_REAL  1.20000000000000E+0000
22746: MUL
22747: ST_TO_ADDR
// end ; unit_building :
22748: GO 22762
22750: LD_INT 3
22752: DOUBLE
22753: EQUAL
22754: IFTRUE 22758
22756: GO 22761
22758: POP
// ; end ;
22759: GO 22762
22761: POP
// for j = 1 to 3 do
22762: LD_ADDR_VAR 0 7
22766: PUSH
22767: DOUBLE
22768: LD_INT 1
22770: DEC
22771: ST_TO_ADDR
22772: LD_INT 3
22774: PUSH
22775: FOR_TO
22776: IFFALSE 22829
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22778: LD_ADDR_VAR 0 5
22782: PUSH
22783: LD_VAR 0 5
22787: PPUSH
22788: LD_VAR 0 7
22792: PPUSH
22793: LD_VAR 0 5
22797: PUSH
22798: LD_VAR 0 7
22802: ARRAY
22803: PUSH
22804: LD_VAR 0 9
22808: PUSH
22809: LD_VAR 0 7
22813: ARRAY
22814: PUSH
22815: LD_VAR 0 10
22819: MUL
22820: PLUS
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
22827: GO 22775
22829: POP
22830: POP
// end ;
22831: GO 21314
22833: POP
22834: POP
// result := Replace ( result , 4 , tmp ) ;
22835: LD_ADDR_VAR 0 5
22839: PUSH
22840: LD_VAR 0 5
22844: PPUSH
22845: LD_INT 4
22847: PPUSH
22848: LD_VAR 0 8
22852: PPUSH
22853: CALL_OW 1
22857: ST_TO_ADDR
// end ;
22858: LD_VAR 0 5
22862: RET
// export function DangerAtRange ( unit , range ) ; begin
22863: LD_INT 0
22865: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22866: LD_ADDR_VAR 0 3
22870: PUSH
22871: LD_VAR 0 1
22875: PPUSH
22876: CALL_OW 255
22880: PPUSH
22881: LD_VAR 0 1
22885: PPUSH
22886: CALL_OW 250
22890: PPUSH
22891: LD_VAR 0 1
22895: PPUSH
22896: CALL_OW 251
22900: PPUSH
22901: LD_VAR 0 2
22905: PPUSH
22906: CALL 21166 0 4
22910: ST_TO_ADDR
// end ;
22911: LD_VAR 0 3
22915: RET
// export function DangerInArea ( side , area ) ; begin
22916: LD_INT 0
22918: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_VAR 0 2
22928: PPUSH
22929: LD_INT 81
22931: PUSH
22932: LD_VAR 0 1
22936: PUSH
22937: EMPTY
22938: LIST
22939: LIST
22940: PPUSH
22941: CALL_OW 70
22945: ST_TO_ADDR
// end ;
22946: LD_VAR 0 3
22950: RET
// export function IsExtension ( b ) ; begin
22951: LD_INT 0
22953: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22954: LD_ADDR_VAR 0 2
22958: PUSH
22959: LD_VAR 0 1
22963: PUSH
22964: LD_INT 23
22966: PUSH
22967: LD_INT 20
22969: PUSH
22970: LD_INT 22
22972: PUSH
22973: LD_INT 17
22975: PUSH
22976: LD_INT 24
22978: PUSH
22979: LD_INT 21
22981: PUSH
22982: LD_INT 19
22984: PUSH
22985: LD_INT 16
22987: PUSH
22988: LD_INT 25
22990: PUSH
22991: LD_INT 18
22993: PUSH
22994: EMPTY
22995: LIST
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: LIST
23001: LIST
23002: LIST
23003: LIST
23004: LIST
23005: IN
23006: ST_TO_ADDR
// end ;
23007: LD_VAR 0 2
23011: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23012: LD_INT 0
23014: PPUSH
23015: PPUSH
23016: PPUSH
// result := [ ] ;
23017: LD_ADDR_VAR 0 3
23021: PUSH
23022: EMPTY
23023: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23024: LD_ADDR_VAR 0 4
23028: PUSH
23029: LD_VAR 0 2
23033: PPUSH
23034: LD_INT 21
23036: PUSH
23037: LD_INT 3
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PPUSH
23044: CALL_OW 70
23048: ST_TO_ADDR
// if not tmp then
23049: LD_VAR 0 4
23053: NOT
23054: IFFALSE 23058
// exit ;
23056: GO 23116
// for i in tmp do
23058: LD_ADDR_VAR 0 5
23062: PUSH
23063: LD_VAR 0 4
23067: PUSH
23068: FOR_IN
23069: IFFALSE 23104
// if GetBase ( i ) <> base then
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 274
23080: PUSH
23081: LD_VAR 0 1
23085: NONEQUAL
23086: IFFALSE 23102
// ComLinkToBase ( base , i ) ;
23088: LD_VAR 0 1
23092: PPUSH
23093: LD_VAR 0 5
23097: PPUSH
23098: CALL_OW 169
23102: GO 23068
23104: POP
23105: POP
// result := tmp ;
23106: LD_ADDR_VAR 0 3
23110: PUSH
23111: LD_VAR 0 4
23115: ST_TO_ADDR
// end ;
23116: LD_VAR 0 3
23120: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23121: LD_INT 0
23123: PPUSH
23124: PPUSH
// if BuildingStatus ( b ) = bs_build then
23125: LD_VAR 0 2
23129: PPUSH
23130: CALL_OW 461
23134: PUSH
23135: LD_INT 1
23137: EQUAL
23138: IFFALSE 23198
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23140: LD_VAR 0 1
23144: PPUSH
23145: LD_STRING h
23147: PUSH
23148: LD_VAR 0 2
23152: PPUSH
23153: CALL_OW 250
23157: PUSH
23158: LD_VAR 0 2
23162: PPUSH
23163: CALL_OW 251
23167: PUSH
23168: LD_VAR 0 2
23172: PUSH
23173: LD_INT 0
23175: PUSH
23176: LD_INT 0
23178: PUSH
23179: LD_INT 0
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: PPUSH
23194: CALL_OW 446
// end ;
23198: LD_VAR 0 3
23202: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23203: LD_INT 0
23205: PPUSH
23206: PPUSH
23207: PPUSH
23208: PPUSH
23209: PPUSH
23210: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23211: LD_VAR 0 1
23215: NOT
23216: PUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: CALL_OW 263
23226: PUSH
23227: LD_INT 2
23229: EQUAL
23230: NOT
23231: OR
23232: IFFALSE 23236
// exit ;
23234: GO 23552
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23236: LD_ADDR_VAR 0 6
23240: PUSH
23241: LD_INT 22
23243: PUSH
23244: LD_VAR 0 1
23248: PPUSH
23249: CALL_OW 255
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: LD_INT 2
23260: PUSH
23261: LD_INT 30
23263: PUSH
23264: LD_INT 36
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: PUSH
23271: LD_INT 34
23273: PUSH
23274: LD_INT 31
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PPUSH
23290: CALL_OW 69
23294: ST_TO_ADDR
// if not tmp then
23295: LD_VAR 0 6
23299: NOT
23300: IFFALSE 23304
// exit ;
23302: GO 23552
// result := [ ] ;
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: EMPTY
23310: ST_TO_ADDR
// for i in tmp do
23311: LD_ADDR_VAR 0 3
23315: PUSH
23316: LD_VAR 0 6
23320: PUSH
23321: FOR_IN
23322: IFFALSE 23393
// begin t := UnitsInside ( i ) ;
23324: LD_ADDR_VAR 0 4
23328: PUSH
23329: LD_VAR 0 3
23333: PPUSH
23334: CALL_OW 313
23338: ST_TO_ADDR
// if t then
23339: LD_VAR 0 4
23343: IFFALSE 23391
// for j in t do
23345: LD_ADDR_VAR 0 7
23349: PUSH
23350: LD_VAR 0 4
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23389
// result := Insert ( result , result + 1 , j ) ;
23358: LD_ADDR_VAR 0 2
23362: PUSH
23363: LD_VAR 0 2
23367: PPUSH
23368: LD_VAR 0 2
23372: PUSH
23373: LD_INT 1
23375: PLUS
23376: PPUSH
23377: LD_VAR 0 7
23381: PPUSH
23382: CALL_OW 2
23386: ST_TO_ADDR
23387: GO 23355
23389: POP
23390: POP
// end ;
23391: GO 23321
23393: POP
23394: POP
// if not result then
23395: LD_VAR 0 2
23399: NOT
23400: IFFALSE 23404
// exit ;
23402: GO 23552
// mech := result [ 1 ] ;
23404: LD_ADDR_VAR 0 5
23408: PUSH
23409: LD_VAR 0 2
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: ST_TO_ADDR
// if result > 1 then
23418: LD_VAR 0 2
23422: PUSH
23423: LD_INT 1
23425: GREATER
23426: IFFALSE 23538
// for i = 2 to result do
23428: LD_ADDR_VAR 0 3
23432: PUSH
23433: DOUBLE
23434: LD_INT 2
23436: DEC
23437: ST_TO_ADDR
23438: LD_VAR 0 2
23442: PUSH
23443: FOR_TO
23444: IFFALSE 23536
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23446: LD_ADDR_VAR 0 4
23450: PUSH
23451: LD_VAR 0 2
23455: PUSH
23456: LD_VAR 0 3
23460: ARRAY
23461: PPUSH
23462: LD_INT 3
23464: PPUSH
23465: CALL_OW 259
23469: PUSH
23470: LD_VAR 0 2
23474: PUSH
23475: LD_VAR 0 3
23479: ARRAY
23480: PPUSH
23481: CALL_OW 432
23485: MINUS
23486: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23487: LD_VAR 0 4
23491: PUSH
23492: LD_VAR 0 5
23496: PPUSH
23497: LD_INT 3
23499: PPUSH
23500: CALL_OW 259
23504: PUSH
23505: LD_VAR 0 5
23509: PPUSH
23510: CALL_OW 432
23514: MINUS
23515: GREATEREQUAL
23516: IFFALSE 23534
// mech := result [ i ] ;
23518: LD_ADDR_VAR 0 5
23522: PUSH
23523: LD_VAR 0 2
23527: PUSH
23528: LD_VAR 0 3
23532: ARRAY
23533: ST_TO_ADDR
// end ;
23534: GO 23443
23536: POP
23537: POP
// ComLinkTo ( vehicle , mech ) ;
23538: LD_VAR 0 1
23542: PPUSH
23543: LD_VAR 0 5
23547: PPUSH
23548: CALL_OW 135
// end ;
23552: LD_VAR 0 2
23556: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23557: LD_INT 0
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
23567: PPUSH
23568: PPUSH
23569: PPUSH
23570: PPUSH
23571: PPUSH
// result := [ ] ;
23572: LD_ADDR_VAR 0 7
23576: PUSH
23577: EMPTY
23578: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23579: LD_VAR 0 1
23583: PPUSH
23584: CALL_OW 266
23588: PUSH
23589: LD_INT 0
23591: PUSH
23592: LD_INT 1
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: IN
23599: NOT
23600: IFFALSE 23604
// exit ;
23602: GO 25235
// if name then
23604: LD_VAR 0 3
23608: IFFALSE 23624
// SetBName ( base_dep , name ) ;
23610: LD_VAR 0 1
23614: PPUSH
23615: LD_VAR 0 3
23619: PPUSH
23620: CALL_OW 500
// base := GetBase ( base_dep ) ;
23624: LD_ADDR_VAR 0 15
23628: PUSH
23629: LD_VAR 0 1
23633: PPUSH
23634: CALL_OW 274
23638: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23639: LD_ADDR_VAR 0 16
23643: PUSH
23644: LD_VAR 0 1
23648: PPUSH
23649: CALL_OW 255
23653: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23654: LD_ADDR_VAR 0 17
23658: PUSH
23659: LD_VAR 0 1
23663: PPUSH
23664: CALL_OW 248
23668: ST_TO_ADDR
// if sources then
23669: LD_VAR 0 5
23673: IFFALSE 23720
// for i = 1 to 3 do
23675: LD_ADDR_VAR 0 8
23679: PUSH
23680: DOUBLE
23681: LD_INT 1
23683: DEC
23684: ST_TO_ADDR
23685: LD_INT 3
23687: PUSH
23688: FOR_TO
23689: IFFALSE 23718
// AddResourceType ( base , i , sources [ i ] ) ;
23691: LD_VAR 0 15
23695: PPUSH
23696: LD_VAR 0 8
23700: PPUSH
23701: LD_VAR 0 5
23705: PUSH
23706: LD_VAR 0 8
23710: ARRAY
23711: PPUSH
23712: CALL_OW 276
23716: GO 23688
23718: POP
23719: POP
// buildings := GetBaseBuildings ( base , area ) ;
23720: LD_ADDR_VAR 0 18
23724: PUSH
23725: LD_VAR 0 15
23729: PPUSH
23730: LD_VAR 0 2
23734: PPUSH
23735: CALL 23012 0 2
23739: ST_TO_ADDR
// InitHc ;
23740: CALL_OW 19
// InitUc ;
23744: CALL_OW 18
// uc_side := side ;
23748: LD_ADDR_OWVAR 20
23752: PUSH
23753: LD_VAR 0 16
23757: ST_TO_ADDR
// uc_nation := nation ;
23758: LD_ADDR_OWVAR 21
23762: PUSH
23763: LD_VAR 0 17
23767: ST_TO_ADDR
// if buildings then
23768: LD_VAR 0 18
23772: IFFALSE 25094
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23774: LD_ADDR_VAR 0 19
23778: PUSH
23779: LD_VAR 0 18
23783: PPUSH
23784: LD_INT 2
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 29
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 30
23799: PUSH
23800: LD_INT 30
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: LIST
23811: PPUSH
23812: CALL_OW 72
23816: ST_TO_ADDR
// if tmp then
23817: LD_VAR 0 19
23821: IFFALSE 23869
// for i in tmp do
23823: LD_ADDR_VAR 0 8
23827: PUSH
23828: LD_VAR 0 19
23832: PUSH
23833: FOR_IN
23834: IFFALSE 23867
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23836: LD_VAR 0 8
23840: PPUSH
23841: CALL_OW 250
23845: PPUSH
23846: LD_VAR 0 8
23850: PPUSH
23851: CALL_OW 251
23855: PPUSH
23856: LD_VAR 0 16
23860: PPUSH
23861: CALL_OW 441
23865: GO 23833
23867: POP
23868: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23869: LD_VAR 0 18
23873: PPUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 30
23879: PUSH
23880: LD_INT 32
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 30
23889: PUSH
23890: LD_INT 33
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 72
23906: IFFALSE 23994
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23908: LD_ADDR_VAR 0 8
23912: PUSH
23913: LD_VAR 0 18
23917: PPUSH
23918: LD_INT 2
23920: PUSH
23921: LD_INT 30
23923: PUSH
23924: LD_INT 32
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PUSH
23931: LD_INT 30
23933: PUSH
23934: LD_INT 33
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: LIST
23945: PPUSH
23946: CALL_OW 72
23950: PUSH
23951: FOR_IN
23952: IFFALSE 23992
// begin if not GetBWeapon ( i ) then
23954: LD_VAR 0 8
23958: PPUSH
23959: CALL_OW 269
23963: NOT
23964: IFFALSE 23990
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23966: LD_VAR 0 8
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 2
23980: PPUSH
23981: CALL 25240 0 2
23985: PPUSH
23986: CALL_OW 431
// end ;
23990: GO 23951
23992: POP
23993: POP
// end ; for i = 1 to personel do
23994: LD_ADDR_VAR 0 8
23998: PUSH
23999: DOUBLE
24000: LD_INT 1
24002: DEC
24003: ST_TO_ADDR
24004: LD_VAR 0 6
24008: PUSH
24009: FOR_TO
24010: IFFALSE 25074
// begin if i > 4 then
24012: LD_VAR 0 8
24016: PUSH
24017: LD_INT 4
24019: GREATER
24020: IFFALSE 24024
// break ;
24022: GO 25074
// case i of 1 :
24024: LD_VAR 0 8
24028: PUSH
24029: LD_INT 1
24031: DOUBLE
24032: EQUAL
24033: IFTRUE 24037
24035: GO 24117
24037: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24038: LD_ADDR_VAR 0 12
24042: PUSH
24043: LD_VAR 0 18
24047: PPUSH
24048: LD_INT 22
24050: PUSH
24051: LD_VAR 0 16
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PUSH
24060: LD_INT 58
24062: PUSH
24063: EMPTY
24064: LIST
24065: PUSH
24066: LD_INT 2
24068: PUSH
24069: LD_INT 30
24071: PUSH
24072: LD_INT 32
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: LD_INT 30
24081: PUSH
24082: LD_INT 4
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PUSH
24089: LD_INT 30
24091: PUSH
24092: LD_INT 5
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: LIST
24103: LIST
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: LIST
24109: PPUSH
24110: CALL_OW 72
24114: ST_TO_ADDR
24115: GO 24339
24117: LD_INT 2
24119: DOUBLE
24120: EQUAL
24121: IFTRUE 24125
24123: GO 24187
24125: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24126: LD_ADDR_VAR 0 12
24130: PUSH
24131: LD_VAR 0 18
24135: PPUSH
24136: LD_INT 22
24138: PUSH
24139: LD_VAR 0 16
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: LD_INT 2
24150: PUSH
24151: LD_INT 30
24153: PUSH
24154: LD_INT 0
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: LD_INT 30
24163: PUSH
24164: LD_INT 1
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: EMPTY
24172: LIST
24173: LIST
24174: LIST
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PPUSH
24180: CALL_OW 72
24184: ST_TO_ADDR
24185: GO 24339
24187: LD_INT 3
24189: DOUBLE
24190: EQUAL
24191: IFTRUE 24195
24193: GO 24257
24195: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24196: LD_ADDR_VAR 0 12
24200: PUSH
24201: LD_VAR 0 18
24205: PPUSH
24206: LD_INT 22
24208: PUSH
24209: LD_VAR 0 16
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: PUSH
24218: LD_INT 2
24220: PUSH
24221: LD_INT 30
24223: PUSH
24224: LD_INT 2
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 30
24233: PUSH
24234: LD_INT 3
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: LIST
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PPUSH
24250: CALL_OW 72
24254: ST_TO_ADDR
24255: GO 24339
24257: LD_INT 4
24259: DOUBLE
24260: EQUAL
24261: IFTRUE 24265
24263: GO 24338
24265: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 18
24275: PPUSH
24276: LD_INT 22
24278: PUSH
24279: LD_VAR 0 16
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 2
24290: PUSH
24291: LD_INT 30
24293: PUSH
24294: LD_INT 6
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: LD_INT 30
24303: PUSH
24304: LD_INT 7
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: PUSH
24311: LD_INT 30
24313: PUSH
24314: LD_INT 8
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PPUSH
24331: CALL_OW 72
24335: ST_TO_ADDR
24336: GO 24339
24338: POP
// if i = 1 then
24339: LD_VAR 0 8
24343: PUSH
24344: LD_INT 1
24346: EQUAL
24347: IFFALSE 24458
// begin tmp := [ ] ;
24349: LD_ADDR_VAR 0 19
24353: PUSH
24354: EMPTY
24355: ST_TO_ADDR
// for j in f do
24356: LD_ADDR_VAR 0 9
24360: PUSH
24361: LD_VAR 0 12
24365: PUSH
24366: FOR_IN
24367: IFFALSE 24440
// if GetBType ( j ) = b_bunker then
24369: LD_VAR 0 9
24373: PPUSH
24374: CALL_OW 266
24378: PUSH
24379: LD_INT 32
24381: EQUAL
24382: IFFALSE 24409
// tmp := Insert ( tmp , 1 , j ) else
24384: LD_ADDR_VAR 0 19
24388: PUSH
24389: LD_VAR 0 19
24393: PPUSH
24394: LD_INT 1
24396: PPUSH
24397: LD_VAR 0 9
24401: PPUSH
24402: CALL_OW 2
24406: ST_TO_ADDR
24407: GO 24438
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24409: LD_ADDR_VAR 0 19
24413: PUSH
24414: LD_VAR 0 19
24418: PPUSH
24419: LD_VAR 0 19
24423: PUSH
24424: LD_INT 1
24426: PLUS
24427: PPUSH
24428: LD_VAR 0 9
24432: PPUSH
24433: CALL_OW 2
24437: ST_TO_ADDR
24438: GO 24366
24440: POP
24441: POP
// if tmp then
24442: LD_VAR 0 19
24446: IFFALSE 24458
// f := tmp ;
24448: LD_ADDR_VAR 0 12
24452: PUSH
24453: LD_VAR 0 19
24457: ST_TO_ADDR
// end ; x := personel [ i ] ;
24458: LD_ADDR_VAR 0 13
24462: PUSH
24463: LD_VAR 0 6
24467: PUSH
24468: LD_VAR 0 8
24472: ARRAY
24473: ST_TO_ADDR
// if x = - 1 then
24474: LD_VAR 0 13
24478: PUSH
24479: LD_INT 1
24481: NEG
24482: EQUAL
24483: IFFALSE 24692
// begin for j in f do
24485: LD_ADDR_VAR 0 9
24489: PUSH
24490: LD_VAR 0 12
24494: PUSH
24495: FOR_IN
24496: IFFALSE 24688
// repeat InitHc ;
24498: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24502: LD_VAR 0 9
24506: PPUSH
24507: CALL_OW 266
24511: PUSH
24512: LD_INT 5
24514: EQUAL
24515: IFFALSE 24585
// begin if UnitsInside ( j ) < 3 then
24517: LD_VAR 0 9
24521: PPUSH
24522: CALL_OW 313
24526: PUSH
24527: LD_INT 3
24529: LESS
24530: IFFALSE 24566
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24532: LD_INT 0
24534: PPUSH
24535: LD_INT 5
24537: PUSH
24538: LD_INT 8
24540: PUSH
24541: LD_INT 9
24543: PUSH
24544: EMPTY
24545: LIST
24546: LIST
24547: LIST
24548: PUSH
24549: LD_VAR 0 17
24553: ARRAY
24554: PPUSH
24555: LD_VAR 0 4
24559: PPUSH
24560: CALL_OW 380
24564: GO 24583
// PrepareHuman ( false , i , skill ) ;
24566: LD_INT 0
24568: PPUSH
24569: LD_VAR 0 8
24573: PPUSH
24574: LD_VAR 0 4
24578: PPUSH
24579: CALL_OW 380
// end else
24583: GO 24602
// PrepareHuman ( false , i , skill ) ;
24585: LD_INT 0
24587: PPUSH
24588: LD_VAR 0 8
24592: PPUSH
24593: LD_VAR 0 4
24597: PPUSH
24598: CALL_OW 380
// un := CreateHuman ;
24602: LD_ADDR_VAR 0 14
24606: PUSH
24607: CALL_OW 44
24611: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24612: LD_ADDR_VAR 0 7
24616: PUSH
24617: LD_VAR 0 7
24621: PPUSH
24622: LD_INT 1
24624: PPUSH
24625: LD_VAR 0 14
24629: PPUSH
24630: CALL_OW 2
24634: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24635: LD_VAR 0 14
24639: PPUSH
24640: LD_VAR 0 9
24644: PPUSH
24645: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24649: LD_VAR 0 9
24653: PPUSH
24654: CALL_OW 313
24658: PUSH
24659: LD_INT 6
24661: EQUAL
24662: PUSH
24663: LD_VAR 0 9
24667: PPUSH
24668: CALL_OW 266
24672: PUSH
24673: LD_INT 32
24675: PUSH
24676: LD_INT 31
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: IN
24683: OR
24684: IFFALSE 24498
24686: GO 24495
24688: POP
24689: POP
// end else
24690: GO 25072
// for j = 1 to x do
24692: LD_ADDR_VAR 0 9
24696: PUSH
24697: DOUBLE
24698: LD_INT 1
24700: DEC
24701: ST_TO_ADDR
24702: LD_VAR 0 13
24706: PUSH
24707: FOR_TO
24708: IFFALSE 25070
// begin InitHc ;
24710: CALL_OW 19
// if not f then
24714: LD_VAR 0 12
24718: NOT
24719: IFFALSE 24808
// begin PrepareHuman ( false , i , skill ) ;
24721: LD_INT 0
24723: PPUSH
24724: LD_VAR 0 8
24728: PPUSH
24729: LD_VAR 0 4
24733: PPUSH
24734: CALL_OW 380
// un := CreateHuman ;
24738: LD_ADDR_VAR 0 14
24742: PUSH
24743: CALL_OW 44
24747: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24748: LD_ADDR_VAR 0 7
24752: PUSH
24753: LD_VAR 0 7
24757: PPUSH
24758: LD_INT 1
24760: PPUSH
24761: LD_VAR 0 14
24765: PPUSH
24766: CALL_OW 2
24770: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24771: LD_VAR 0 14
24775: PPUSH
24776: LD_VAR 0 1
24780: PPUSH
24781: CALL_OW 250
24785: PPUSH
24786: LD_VAR 0 1
24790: PPUSH
24791: CALL_OW 251
24795: PPUSH
24796: LD_INT 10
24798: PPUSH
24799: LD_INT 0
24801: PPUSH
24802: CALL_OW 50
// continue ;
24806: GO 24707
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24808: LD_VAR 0 12
24812: PUSH
24813: LD_INT 1
24815: ARRAY
24816: PPUSH
24817: CALL_OW 313
24821: PUSH
24822: LD_VAR 0 12
24826: PUSH
24827: LD_INT 1
24829: ARRAY
24830: PPUSH
24831: CALL_OW 266
24835: PUSH
24836: LD_INT 32
24838: PUSH
24839: LD_INT 31
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: IN
24846: AND
24847: PUSH
24848: LD_VAR 0 12
24852: PUSH
24853: LD_INT 1
24855: ARRAY
24856: PPUSH
24857: CALL_OW 313
24861: PUSH
24862: LD_INT 6
24864: EQUAL
24865: OR
24866: IFFALSE 24886
// f := Delete ( f , 1 ) ;
24868: LD_ADDR_VAR 0 12
24872: PUSH
24873: LD_VAR 0 12
24877: PPUSH
24878: LD_INT 1
24880: PPUSH
24881: CALL_OW 3
24885: ST_TO_ADDR
// if not f then
24886: LD_VAR 0 12
24890: NOT
24891: IFFALSE 24909
// begin x := x + 2 ;
24893: LD_ADDR_VAR 0 13
24897: PUSH
24898: LD_VAR 0 13
24902: PUSH
24903: LD_INT 2
24905: PLUS
24906: ST_TO_ADDR
// continue ;
24907: GO 24707
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24909: LD_VAR 0 12
24913: PUSH
24914: LD_INT 1
24916: ARRAY
24917: PPUSH
24918: CALL_OW 266
24922: PUSH
24923: LD_INT 5
24925: EQUAL
24926: IFFALSE 25000
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24928: LD_VAR 0 12
24932: PUSH
24933: LD_INT 1
24935: ARRAY
24936: PPUSH
24937: CALL_OW 313
24941: PUSH
24942: LD_INT 3
24944: LESS
24945: IFFALSE 24981
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24947: LD_INT 0
24949: PPUSH
24950: LD_INT 5
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 9
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_VAR 0 17
24968: ARRAY
24969: PPUSH
24970: LD_VAR 0 4
24974: PPUSH
24975: CALL_OW 380
24979: GO 24998
// PrepareHuman ( false , i , skill ) ;
24981: LD_INT 0
24983: PPUSH
24984: LD_VAR 0 8
24988: PPUSH
24989: LD_VAR 0 4
24993: PPUSH
24994: CALL_OW 380
// end else
24998: GO 25017
// PrepareHuman ( false , i , skill ) ;
25000: LD_INT 0
25002: PPUSH
25003: LD_VAR 0 8
25007: PPUSH
25008: LD_VAR 0 4
25012: PPUSH
25013: CALL_OW 380
// un := CreateHuman ;
25017: LD_ADDR_VAR 0 14
25021: PUSH
25022: CALL_OW 44
25026: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25027: LD_ADDR_VAR 0 7
25031: PUSH
25032: LD_VAR 0 7
25036: PPUSH
25037: LD_INT 1
25039: PPUSH
25040: LD_VAR 0 14
25044: PPUSH
25045: CALL_OW 2
25049: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25050: LD_VAR 0 14
25054: PPUSH
25055: LD_VAR 0 12
25059: PUSH
25060: LD_INT 1
25062: ARRAY
25063: PPUSH
25064: CALL_OW 52
// end ;
25068: GO 24707
25070: POP
25071: POP
// end ;
25072: GO 24009
25074: POP
25075: POP
// result := result ^ buildings ;
25076: LD_ADDR_VAR 0 7
25080: PUSH
25081: LD_VAR 0 7
25085: PUSH
25086: LD_VAR 0 18
25090: ADD
25091: ST_TO_ADDR
// end else
25092: GO 25235
// begin for i = 1 to personel do
25094: LD_ADDR_VAR 0 8
25098: PUSH
25099: DOUBLE
25100: LD_INT 1
25102: DEC
25103: ST_TO_ADDR
25104: LD_VAR 0 6
25108: PUSH
25109: FOR_TO
25110: IFFALSE 25233
// begin if i > 4 then
25112: LD_VAR 0 8
25116: PUSH
25117: LD_INT 4
25119: GREATER
25120: IFFALSE 25124
// break ;
25122: GO 25233
// x := personel [ i ] ;
25124: LD_ADDR_VAR 0 13
25128: PUSH
25129: LD_VAR 0 6
25133: PUSH
25134: LD_VAR 0 8
25138: ARRAY
25139: ST_TO_ADDR
// if x = - 1 then
25140: LD_VAR 0 13
25144: PUSH
25145: LD_INT 1
25147: NEG
25148: EQUAL
25149: IFFALSE 25153
// continue ;
25151: GO 25109
// PrepareHuman ( false , i , skill ) ;
25153: LD_INT 0
25155: PPUSH
25156: LD_VAR 0 8
25160: PPUSH
25161: LD_VAR 0 4
25165: PPUSH
25166: CALL_OW 380
// un := CreateHuman ;
25170: LD_ADDR_VAR 0 14
25174: PUSH
25175: CALL_OW 44
25179: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25180: LD_VAR 0 14
25184: PPUSH
25185: LD_VAR 0 1
25189: PPUSH
25190: CALL_OW 250
25194: PPUSH
25195: LD_VAR 0 1
25199: PPUSH
25200: CALL_OW 251
25204: PPUSH
25205: LD_INT 10
25207: PPUSH
25208: LD_INT 0
25210: PPUSH
25211: CALL_OW 50
// result := result ^ un ;
25215: LD_ADDR_VAR 0 7
25219: PUSH
25220: LD_VAR 0 7
25224: PUSH
25225: LD_VAR 0 14
25229: ADD
25230: ST_TO_ADDR
// end ;
25231: GO 25109
25233: POP
25234: POP
// end ; end ;
25235: LD_VAR 0 7
25239: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25240: LD_INT 0
25242: PPUSH
25243: PPUSH
25244: PPUSH
25245: PPUSH
25246: PPUSH
25247: PPUSH
25248: PPUSH
25249: PPUSH
25250: PPUSH
25251: PPUSH
25252: PPUSH
25253: PPUSH
25254: PPUSH
25255: PPUSH
25256: PPUSH
25257: PPUSH
// result := false ;
25258: LD_ADDR_VAR 0 3
25262: PUSH
25263: LD_INT 0
25265: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25266: LD_VAR 0 1
25270: NOT
25271: PUSH
25272: LD_VAR 0 1
25276: PPUSH
25277: CALL_OW 266
25281: PUSH
25282: LD_INT 32
25284: PUSH
25285: LD_INT 33
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: IN
25292: NOT
25293: OR
25294: IFFALSE 25298
// exit ;
25296: GO 26434
// nat := GetNation ( tower ) ;
25298: LD_ADDR_VAR 0 12
25302: PUSH
25303: LD_VAR 0 1
25307: PPUSH
25308: CALL_OW 248
25312: ST_TO_ADDR
// side := GetSide ( tower ) ;
25313: LD_ADDR_VAR 0 16
25317: PUSH
25318: LD_VAR 0 1
25322: PPUSH
25323: CALL_OW 255
25327: ST_TO_ADDR
// x := GetX ( tower ) ;
25328: LD_ADDR_VAR 0 10
25332: PUSH
25333: LD_VAR 0 1
25337: PPUSH
25338: CALL_OW 250
25342: ST_TO_ADDR
// y := GetY ( tower ) ;
25343: LD_ADDR_VAR 0 11
25347: PUSH
25348: LD_VAR 0 1
25352: PPUSH
25353: CALL_OW 251
25357: ST_TO_ADDR
// if not x or not y then
25358: LD_VAR 0 10
25362: NOT
25363: PUSH
25364: LD_VAR 0 11
25368: NOT
25369: OR
25370: IFFALSE 25374
// exit ;
25372: GO 26434
// weapon := 0 ;
25374: LD_ADDR_VAR 0 18
25378: PUSH
25379: LD_INT 0
25381: ST_TO_ADDR
// fac_list := [ ] ;
25382: LD_ADDR_VAR 0 17
25386: PUSH
25387: EMPTY
25388: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25389: LD_ADDR_VAR 0 6
25393: PUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: CALL_OW 274
25403: PPUSH
25404: LD_VAR 0 2
25408: PPUSH
25409: CALL 23012 0 2
25413: PPUSH
25414: LD_INT 30
25416: PUSH
25417: LD_INT 3
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PPUSH
25424: CALL_OW 72
25428: ST_TO_ADDR
// if not factories then
25429: LD_VAR 0 6
25433: NOT
25434: IFFALSE 25438
// exit ;
25436: GO 26434
// for i in factories do
25438: LD_ADDR_VAR 0 8
25442: PUSH
25443: LD_VAR 0 6
25447: PUSH
25448: FOR_IN
25449: IFFALSE 25474
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25451: LD_ADDR_VAR 0 17
25455: PUSH
25456: LD_VAR 0 17
25460: PUSH
25461: LD_VAR 0 8
25465: PPUSH
25466: CALL_OW 478
25470: UNION
25471: ST_TO_ADDR
25472: GO 25448
25474: POP
25475: POP
// if not fac_list then
25476: LD_VAR 0 17
25480: NOT
25481: IFFALSE 25485
// exit ;
25483: GO 26434
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25485: LD_ADDR_VAR 0 5
25489: PUSH
25490: LD_INT 4
25492: PUSH
25493: LD_INT 5
25495: PUSH
25496: LD_INT 9
25498: PUSH
25499: LD_INT 10
25501: PUSH
25502: LD_INT 6
25504: PUSH
25505: LD_INT 7
25507: PUSH
25508: LD_INT 11
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 27
25522: PUSH
25523: LD_INT 28
25525: PUSH
25526: LD_INT 26
25528: PUSH
25529: LD_INT 30
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 43
25540: PUSH
25541: LD_INT 44
25543: PUSH
25544: LD_INT 46
25546: PUSH
25547: LD_INT 45
25549: PUSH
25550: LD_INT 47
25552: PUSH
25553: LD_INT 49
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: LIST
25560: LIST
25561: LIST
25562: LIST
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: PUSH
25569: LD_VAR 0 12
25573: ARRAY
25574: ST_TO_ADDR
// for i in list do
25575: LD_ADDR_VAR 0 8
25579: PUSH
25580: LD_VAR 0 5
25584: PUSH
25585: FOR_IN
25586: IFFALSE 25619
// if not i in fac_list then
25588: LD_VAR 0 8
25592: PUSH
25593: LD_VAR 0 17
25597: IN
25598: NOT
25599: IFFALSE 25617
// list := list diff i ;
25601: LD_ADDR_VAR 0 5
25605: PUSH
25606: LD_VAR 0 5
25610: PUSH
25611: LD_VAR 0 8
25615: DIFF
25616: ST_TO_ADDR
25617: GO 25585
25619: POP
25620: POP
// if not list then
25621: LD_VAR 0 5
25625: NOT
25626: IFFALSE 25630
// exit ;
25628: GO 26434
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25630: LD_VAR 0 12
25634: PUSH
25635: LD_INT 3
25637: EQUAL
25638: PUSH
25639: LD_INT 49
25641: PUSH
25642: LD_VAR 0 5
25646: IN
25647: AND
25648: PUSH
25649: LD_INT 31
25651: PPUSH
25652: LD_VAR 0 16
25656: PPUSH
25657: CALL_OW 321
25661: PUSH
25662: LD_INT 2
25664: EQUAL
25665: AND
25666: IFFALSE 25726
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25668: LD_INT 22
25670: PUSH
25671: LD_VAR 0 16
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: PUSH
25680: LD_INT 35
25682: PUSH
25683: LD_INT 49
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 91
25692: PUSH
25693: LD_VAR 0 1
25697: PUSH
25698: LD_INT 10
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: LIST
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: LIST
25710: PPUSH
25711: CALL_OW 69
25715: NOT
25716: IFFALSE 25726
// weapon := ru_time_lapser ;
25718: LD_ADDR_VAR 0 18
25722: PUSH
25723: LD_INT 49
25725: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25726: LD_VAR 0 12
25730: PUSH
25731: LD_INT 1
25733: PUSH
25734: LD_INT 2
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: IN
25741: PUSH
25742: LD_INT 11
25744: PUSH
25745: LD_VAR 0 5
25749: IN
25750: PUSH
25751: LD_INT 30
25753: PUSH
25754: LD_VAR 0 5
25758: IN
25759: OR
25760: AND
25761: PUSH
25762: LD_INT 6
25764: PPUSH
25765: LD_VAR 0 16
25769: PPUSH
25770: CALL_OW 321
25774: PUSH
25775: LD_INT 2
25777: EQUAL
25778: AND
25779: IFFALSE 25944
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25781: LD_INT 22
25783: PUSH
25784: LD_VAR 0 16
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: PUSH
25796: LD_INT 35
25798: PUSH
25799: LD_INT 11
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 35
25808: PUSH
25809: LD_INT 30
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: LIST
25820: PUSH
25821: LD_INT 91
25823: PUSH
25824: LD_VAR 0 1
25828: PUSH
25829: LD_INT 18
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: LIST
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: LIST
25841: PPUSH
25842: CALL_OW 69
25846: NOT
25847: PUSH
25848: LD_INT 22
25850: PUSH
25851: LD_VAR 0 16
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: LD_INT 30
25865: PUSH
25866: LD_INT 32
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 30
25875: PUSH
25876: LD_INT 33
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 91
25890: PUSH
25891: LD_VAR 0 1
25895: PUSH
25896: LD_INT 12
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: LIST
25908: PUSH
25909: EMPTY
25910: LIST
25911: PPUSH
25912: CALL_OW 69
25916: PUSH
25917: LD_INT 2
25919: GREATER
25920: AND
25921: IFFALSE 25944
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25923: LD_ADDR_VAR 0 18
25927: PUSH
25928: LD_INT 11
25930: PUSH
25931: LD_INT 30
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_VAR 0 12
25942: ARRAY
25943: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25944: LD_VAR 0 18
25948: NOT
25949: PUSH
25950: LD_INT 40
25952: PPUSH
25953: LD_VAR 0 16
25957: PPUSH
25958: CALL_OW 321
25962: PUSH
25963: LD_INT 2
25965: EQUAL
25966: AND
25967: PUSH
25968: LD_INT 7
25970: PUSH
25971: LD_VAR 0 5
25975: IN
25976: PUSH
25977: LD_INT 28
25979: PUSH
25980: LD_VAR 0 5
25984: IN
25985: OR
25986: PUSH
25987: LD_INT 45
25989: PUSH
25990: LD_VAR 0 5
25994: IN
25995: OR
25996: AND
25997: IFFALSE 26251
// begin hex := GetHexInfo ( x , y ) ;
25999: LD_ADDR_VAR 0 4
26003: PUSH
26004: LD_VAR 0 10
26008: PPUSH
26009: LD_VAR 0 11
26013: PPUSH
26014: CALL_OW 546
26018: ST_TO_ADDR
// if hex [ 1 ] then
26019: LD_VAR 0 4
26023: PUSH
26024: LD_INT 1
26026: ARRAY
26027: IFFALSE 26031
// exit ;
26029: GO 26434
// height := hex [ 2 ] ;
26031: LD_ADDR_VAR 0 15
26035: PUSH
26036: LD_VAR 0 4
26040: PUSH
26041: LD_INT 2
26043: ARRAY
26044: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26045: LD_ADDR_VAR 0 14
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 2
26055: PUSH
26056: LD_INT 3
26058: PUSH
26059: LD_INT 5
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: LIST
26066: LIST
26067: ST_TO_ADDR
// for i in tmp do
26068: LD_ADDR_VAR 0 8
26072: PUSH
26073: LD_VAR 0 14
26077: PUSH
26078: FOR_IN
26079: IFFALSE 26249
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26081: LD_ADDR_VAR 0 9
26085: PUSH
26086: LD_VAR 0 10
26090: PPUSH
26091: LD_VAR 0 8
26095: PPUSH
26096: LD_INT 5
26098: PPUSH
26099: CALL_OW 272
26103: PUSH
26104: LD_VAR 0 11
26108: PPUSH
26109: LD_VAR 0 8
26113: PPUSH
26114: LD_INT 5
26116: PPUSH
26117: CALL_OW 273
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26126: LD_VAR 0 9
26130: PUSH
26131: LD_INT 1
26133: ARRAY
26134: PPUSH
26135: LD_VAR 0 9
26139: PUSH
26140: LD_INT 2
26142: ARRAY
26143: PPUSH
26144: CALL_OW 488
26148: IFFALSE 26247
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26150: LD_ADDR_VAR 0 4
26154: PUSH
26155: LD_VAR 0 9
26159: PUSH
26160: LD_INT 1
26162: ARRAY
26163: PPUSH
26164: LD_VAR 0 9
26168: PUSH
26169: LD_INT 2
26171: ARRAY
26172: PPUSH
26173: CALL_OW 546
26177: ST_TO_ADDR
// if hex [ 1 ] then
26178: LD_VAR 0 4
26182: PUSH
26183: LD_INT 1
26185: ARRAY
26186: IFFALSE 26190
// continue ;
26188: GO 26078
// h := hex [ 2 ] ;
26190: LD_ADDR_VAR 0 13
26194: PUSH
26195: LD_VAR 0 4
26199: PUSH
26200: LD_INT 2
26202: ARRAY
26203: ST_TO_ADDR
// if h + 7 < height then
26204: LD_VAR 0 13
26208: PUSH
26209: LD_INT 7
26211: PLUS
26212: PUSH
26213: LD_VAR 0 15
26217: LESS
26218: IFFALSE 26247
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26220: LD_ADDR_VAR 0 18
26224: PUSH
26225: LD_INT 7
26227: PUSH
26228: LD_INT 28
26230: PUSH
26231: LD_INT 45
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: LIST
26238: PUSH
26239: LD_VAR 0 12
26243: ARRAY
26244: ST_TO_ADDR
// break ;
26245: GO 26249
// end ; end ; end ;
26247: GO 26078
26249: POP
26250: POP
// end ; if not weapon then
26251: LD_VAR 0 18
26255: NOT
26256: IFFALSE 26316
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26258: LD_ADDR_VAR 0 5
26262: PUSH
26263: LD_VAR 0 5
26267: PUSH
26268: LD_INT 11
26270: PUSH
26271: LD_INT 30
26273: PUSH
26274: LD_INT 49
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: LIST
26281: DIFF
26282: ST_TO_ADDR
// if not list then
26283: LD_VAR 0 5
26287: NOT
26288: IFFALSE 26292
// exit ;
26290: GO 26434
// weapon := list [ rand ( 1 , list ) ] ;
26292: LD_ADDR_VAR 0 18
26296: PUSH
26297: LD_VAR 0 5
26301: PUSH
26302: LD_INT 1
26304: PPUSH
26305: LD_VAR 0 5
26309: PPUSH
26310: CALL_OW 12
26314: ARRAY
26315: ST_TO_ADDR
// end ; if weapon then
26316: LD_VAR 0 18
26320: IFFALSE 26434
// begin tmp := CostOfWeapon ( weapon ) ;
26322: LD_ADDR_VAR 0 14
26326: PUSH
26327: LD_VAR 0 18
26331: PPUSH
26332: CALL_OW 451
26336: ST_TO_ADDR
// j := GetBase ( tower ) ;
26337: LD_ADDR_VAR 0 9
26341: PUSH
26342: LD_VAR 0 1
26346: PPUSH
26347: CALL_OW 274
26351: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26352: LD_VAR 0 9
26356: PPUSH
26357: LD_INT 1
26359: PPUSH
26360: CALL_OW 275
26364: PUSH
26365: LD_VAR 0 14
26369: PUSH
26370: LD_INT 1
26372: ARRAY
26373: GREATEREQUAL
26374: PUSH
26375: LD_VAR 0 9
26379: PPUSH
26380: LD_INT 2
26382: PPUSH
26383: CALL_OW 275
26387: PUSH
26388: LD_VAR 0 14
26392: PUSH
26393: LD_INT 2
26395: ARRAY
26396: GREATEREQUAL
26397: AND
26398: PUSH
26399: LD_VAR 0 9
26403: PPUSH
26404: LD_INT 3
26406: PPUSH
26407: CALL_OW 275
26411: PUSH
26412: LD_VAR 0 14
26416: PUSH
26417: LD_INT 3
26419: ARRAY
26420: GREATEREQUAL
26421: AND
26422: IFFALSE 26434
// result := weapon ;
26424: LD_ADDR_VAR 0 3
26428: PUSH
26429: LD_VAR 0 18
26433: ST_TO_ADDR
// end ; end ;
26434: LD_VAR 0 3
26438: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26439: LD_INT 0
26441: PPUSH
26442: PPUSH
// result := true ;
26443: LD_ADDR_VAR 0 3
26447: PUSH
26448: LD_INT 1
26450: ST_TO_ADDR
// if array1 = array2 then
26451: LD_VAR 0 1
26455: PUSH
26456: LD_VAR 0 2
26460: EQUAL
26461: IFFALSE 26521
// begin for i = 1 to array1 do
26463: LD_ADDR_VAR 0 4
26467: PUSH
26468: DOUBLE
26469: LD_INT 1
26471: DEC
26472: ST_TO_ADDR
26473: LD_VAR 0 1
26477: PUSH
26478: FOR_TO
26479: IFFALSE 26517
// if array1 [ i ] <> array2 [ i ] then
26481: LD_VAR 0 1
26485: PUSH
26486: LD_VAR 0 4
26490: ARRAY
26491: PUSH
26492: LD_VAR 0 2
26496: PUSH
26497: LD_VAR 0 4
26501: ARRAY
26502: NONEQUAL
26503: IFFALSE 26515
// begin result := false ;
26505: LD_ADDR_VAR 0 3
26509: PUSH
26510: LD_INT 0
26512: ST_TO_ADDR
// break ;
26513: GO 26517
// end ;
26515: GO 26478
26517: POP
26518: POP
// end else
26519: GO 26529
// result := false ;
26521: LD_ADDR_VAR 0 3
26525: PUSH
26526: LD_INT 0
26528: ST_TO_ADDR
// end ;
26529: LD_VAR 0 3
26533: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26534: LD_INT 0
26536: PPUSH
26537: PPUSH
26538: PPUSH
// pom := GetBase ( fac ) ;
26539: LD_ADDR_VAR 0 5
26543: PUSH
26544: LD_VAR 0 1
26548: PPUSH
26549: CALL_OW 274
26553: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26554: LD_ADDR_VAR 0 4
26558: PUSH
26559: LD_VAR 0 2
26563: PUSH
26564: LD_INT 1
26566: ARRAY
26567: PPUSH
26568: LD_VAR 0 2
26572: PUSH
26573: LD_INT 2
26575: ARRAY
26576: PPUSH
26577: LD_VAR 0 2
26581: PUSH
26582: LD_INT 3
26584: ARRAY
26585: PPUSH
26586: LD_VAR 0 2
26590: PUSH
26591: LD_INT 4
26593: ARRAY
26594: PPUSH
26595: CALL_OW 449
26599: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26600: LD_ADDR_VAR 0 3
26604: PUSH
26605: LD_VAR 0 5
26609: PPUSH
26610: LD_INT 1
26612: PPUSH
26613: CALL_OW 275
26617: PUSH
26618: LD_VAR 0 4
26622: PUSH
26623: LD_INT 1
26625: ARRAY
26626: GREATEREQUAL
26627: PUSH
26628: LD_VAR 0 5
26632: PPUSH
26633: LD_INT 2
26635: PPUSH
26636: CALL_OW 275
26640: PUSH
26641: LD_VAR 0 4
26645: PUSH
26646: LD_INT 2
26648: ARRAY
26649: GREATEREQUAL
26650: AND
26651: PUSH
26652: LD_VAR 0 5
26656: PPUSH
26657: LD_INT 3
26659: PPUSH
26660: CALL_OW 275
26664: PUSH
26665: LD_VAR 0 4
26669: PUSH
26670: LD_INT 3
26672: ARRAY
26673: GREATEREQUAL
26674: AND
26675: ST_TO_ADDR
// end ;
26676: LD_VAR 0 3
26680: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26681: LD_INT 0
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
// pom := GetBase ( building ) ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: LD_VAR 0 1
26696: PPUSH
26697: CALL_OW 274
26701: ST_TO_ADDR
// if not pom then
26702: LD_VAR 0 3
26706: NOT
26707: IFFALSE 26711
// exit ;
26709: GO 26881
// btype := GetBType ( building ) ;
26711: LD_ADDR_VAR 0 5
26715: PUSH
26716: LD_VAR 0 1
26720: PPUSH
26721: CALL_OW 266
26725: ST_TO_ADDR
// if btype = b_armoury then
26726: LD_VAR 0 5
26730: PUSH
26731: LD_INT 4
26733: EQUAL
26734: IFFALSE 26744
// btype := b_barracks ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_INT 5
26743: ST_TO_ADDR
// if btype = b_depot then
26744: LD_VAR 0 5
26748: PUSH
26749: LD_INT 0
26751: EQUAL
26752: IFFALSE 26762
// btype := b_warehouse ;
26754: LD_ADDR_VAR 0 5
26758: PUSH
26759: LD_INT 1
26761: ST_TO_ADDR
// if btype = b_workshop then
26762: LD_VAR 0 5
26766: PUSH
26767: LD_INT 2
26769: EQUAL
26770: IFFALSE 26780
// btype := b_factory ;
26772: LD_ADDR_VAR 0 5
26776: PUSH
26777: LD_INT 3
26779: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26780: LD_ADDR_VAR 0 4
26784: PUSH
26785: LD_VAR 0 5
26789: PPUSH
26790: LD_VAR 0 1
26794: PPUSH
26795: CALL_OW 248
26799: PPUSH
26800: CALL_OW 450
26804: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26805: LD_ADDR_VAR 0 2
26809: PUSH
26810: LD_VAR 0 3
26814: PPUSH
26815: LD_INT 1
26817: PPUSH
26818: CALL_OW 275
26822: PUSH
26823: LD_VAR 0 4
26827: PUSH
26828: LD_INT 1
26830: ARRAY
26831: GREATEREQUAL
26832: PUSH
26833: LD_VAR 0 3
26837: PPUSH
26838: LD_INT 2
26840: PPUSH
26841: CALL_OW 275
26845: PUSH
26846: LD_VAR 0 4
26850: PUSH
26851: LD_INT 2
26853: ARRAY
26854: GREATEREQUAL
26855: AND
26856: PUSH
26857: LD_VAR 0 3
26861: PPUSH
26862: LD_INT 3
26864: PPUSH
26865: CALL_OW 275
26869: PUSH
26870: LD_VAR 0 4
26874: PUSH
26875: LD_INT 3
26877: ARRAY
26878: GREATEREQUAL
26879: AND
26880: ST_TO_ADDR
// end ;
26881: LD_VAR 0 2
26885: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26886: LD_INT 0
26888: PPUSH
26889: PPUSH
26890: PPUSH
// pom := GetBase ( building ) ;
26891: LD_ADDR_VAR 0 4
26895: PUSH
26896: LD_VAR 0 1
26900: PPUSH
26901: CALL_OW 274
26905: ST_TO_ADDR
// if not pom then
26906: LD_VAR 0 4
26910: NOT
26911: IFFALSE 26915
// exit ;
26913: GO 27016
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26915: LD_ADDR_VAR 0 5
26919: PUSH
26920: LD_VAR 0 2
26924: PPUSH
26925: LD_VAR 0 1
26929: PPUSH
26930: CALL_OW 248
26934: PPUSH
26935: CALL_OW 450
26939: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26940: LD_ADDR_VAR 0 3
26944: PUSH
26945: LD_VAR 0 4
26949: PPUSH
26950: LD_INT 1
26952: PPUSH
26953: CALL_OW 275
26957: PUSH
26958: LD_VAR 0 5
26962: PUSH
26963: LD_INT 1
26965: ARRAY
26966: GREATEREQUAL
26967: PUSH
26968: LD_VAR 0 4
26972: PPUSH
26973: LD_INT 2
26975: PPUSH
26976: CALL_OW 275
26980: PUSH
26981: LD_VAR 0 5
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: GREATEREQUAL
26990: AND
26991: PUSH
26992: LD_VAR 0 4
26996: PPUSH
26997: LD_INT 3
26999: PPUSH
27000: CALL_OW 275
27004: PUSH
27005: LD_VAR 0 5
27009: PUSH
27010: LD_INT 3
27012: ARRAY
27013: GREATEREQUAL
27014: AND
27015: ST_TO_ADDR
// end ;
27016: LD_VAR 0 3
27020: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27021: LD_INT 0
27023: PPUSH
27024: PPUSH
27025: PPUSH
27026: PPUSH
27027: PPUSH
27028: PPUSH
27029: PPUSH
27030: PPUSH
27031: PPUSH
27032: PPUSH
// result := false ;
27033: LD_ADDR_VAR 0 6
27037: PUSH
27038: LD_INT 0
27040: ST_TO_ADDR
// if not base or not btype or not x or not y then
27041: LD_VAR 0 1
27045: NOT
27046: PUSH
27047: LD_VAR 0 2
27051: NOT
27052: OR
27053: PUSH
27054: LD_VAR 0 3
27058: NOT
27059: OR
27060: PUSH
27061: LD_VAR 0 4
27065: NOT
27066: OR
27067: IFFALSE 27071
// exit ;
27069: GO 27662
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27071: LD_ADDR_VAR 0 12
27075: PUSH
27076: LD_VAR 0 2
27080: PPUSH
27081: LD_VAR 0 3
27085: PPUSH
27086: LD_VAR 0 4
27090: PPUSH
27091: LD_VAR 0 5
27095: PPUSH
27096: LD_VAR 0 1
27100: PUSH
27101: LD_INT 1
27103: ARRAY
27104: PPUSH
27105: CALL_OW 248
27109: PPUSH
27110: LD_INT 0
27112: PPUSH
27113: CALL 28499 0 6
27117: ST_TO_ADDR
// if not hexes then
27118: LD_VAR 0 12
27122: NOT
27123: IFFALSE 27127
// exit ;
27125: GO 27662
// for i = 1 to hexes do
27127: LD_ADDR_VAR 0 7
27131: PUSH
27132: DOUBLE
27133: LD_INT 1
27135: DEC
27136: ST_TO_ADDR
27137: LD_VAR 0 12
27141: PUSH
27142: FOR_TO
27143: IFFALSE 27660
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27145: LD_ADDR_VAR 0 11
27149: PUSH
27150: LD_VAR 0 12
27154: PUSH
27155: LD_VAR 0 7
27159: ARRAY
27160: PUSH
27161: LD_INT 1
27163: ARRAY
27164: PPUSH
27165: LD_VAR 0 12
27169: PUSH
27170: LD_VAR 0 7
27174: ARRAY
27175: PUSH
27176: LD_INT 2
27178: ARRAY
27179: PPUSH
27180: CALL_OW 428
27184: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27185: LD_VAR 0 12
27189: PUSH
27190: LD_VAR 0 7
27194: ARRAY
27195: PUSH
27196: LD_INT 1
27198: ARRAY
27199: PPUSH
27200: LD_VAR 0 12
27204: PUSH
27205: LD_VAR 0 7
27209: ARRAY
27210: PUSH
27211: LD_INT 2
27213: ARRAY
27214: PPUSH
27215: CALL_OW 351
27219: PUSH
27220: LD_VAR 0 12
27224: PUSH
27225: LD_VAR 0 7
27229: ARRAY
27230: PUSH
27231: LD_INT 1
27233: ARRAY
27234: PPUSH
27235: LD_VAR 0 12
27239: PUSH
27240: LD_VAR 0 7
27244: ARRAY
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: PPUSH
27250: CALL_OW 488
27254: NOT
27255: OR
27256: PUSH
27257: LD_VAR 0 11
27261: PPUSH
27262: CALL_OW 247
27266: PUSH
27267: LD_INT 3
27269: EQUAL
27270: OR
27271: IFFALSE 27277
// exit ;
27273: POP
27274: POP
27275: GO 27662
// if not tmp then
27277: LD_VAR 0 11
27281: NOT
27282: IFFALSE 27286
// continue ;
27284: GO 27142
// result := true ;
27286: LD_ADDR_VAR 0 6
27290: PUSH
27291: LD_INT 1
27293: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27294: LD_ADDR_VAR 0 15
27298: PUSH
27299: LD_INT 22
27301: PUSH
27302: LD_VAR 0 11
27306: PPUSH
27307: CALL_OW 255
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 2
27318: PUSH
27319: LD_INT 30
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 30
27331: PUSH
27332: LD_INT 1
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: LIST
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PPUSH
27348: CALL_OW 69
27352: ST_TO_ADDR
// if dep then
27353: LD_VAR 0 15
27357: IFFALSE 27493
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27359: LD_ADDR_VAR 0 14
27363: PUSH
27364: LD_VAR 0 15
27368: PUSH
27369: LD_INT 1
27371: ARRAY
27372: PPUSH
27373: CALL_OW 250
27377: PPUSH
27378: LD_VAR 0 15
27382: PUSH
27383: LD_INT 1
27385: ARRAY
27386: PPUSH
27387: CALL_OW 254
27391: PPUSH
27392: LD_INT 5
27394: PPUSH
27395: CALL_OW 272
27399: PUSH
27400: LD_VAR 0 15
27404: PUSH
27405: LD_INT 1
27407: ARRAY
27408: PPUSH
27409: CALL_OW 251
27413: PPUSH
27414: LD_VAR 0 15
27418: PUSH
27419: LD_INT 1
27421: ARRAY
27422: PPUSH
27423: CALL_OW 254
27427: PPUSH
27428: LD_INT 5
27430: PPUSH
27431: CALL_OW 273
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27440: LD_VAR 0 14
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PPUSH
27449: LD_VAR 0 14
27453: PUSH
27454: LD_INT 2
27456: ARRAY
27457: PPUSH
27458: CALL_OW 488
27462: IFFALSE 27493
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27464: LD_VAR 0 11
27468: PPUSH
27469: LD_VAR 0 14
27473: PUSH
27474: LD_INT 1
27476: ARRAY
27477: PPUSH
27478: LD_VAR 0 14
27482: PUSH
27483: LD_INT 2
27485: ARRAY
27486: PPUSH
27487: CALL_OW 111
// continue ;
27491: GO 27142
// end ; end ; r := GetDir ( tmp ) ;
27493: LD_ADDR_VAR 0 13
27497: PUSH
27498: LD_VAR 0 11
27502: PPUSH
27503: CALL_OW 254
27507: ST_TO_ADDR
// if r = 5 then
27508: LD_VAR 0 13
27512: PUSH
27513: LD_INT 5
27515: EQUAL
27516: IFFALSE 27526
// r := 0 ;
27518: LD_ADDR_VAR 0 13
27522: PUSH
27523: LD_INT 0
27525: ST_TO_ADDR
// for j = r to 5 do
27526: LD_ADDR_VAR 0 8
27530: PUSH
27531: DOUBLE
27532: LD_VAR 0 13
27536: DEC
27537: ST_TO_ADDR
27538: LD_INT 5
27540: PUSH
27541: FOR_TO
27542: IFFALSE 27656
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27544: LD_ADDR_VAR 0 9
27548: PUSH
27549: LD_VAR 0 11
27553: PPUSH
27554: CALL_OW 250
27558: PPUSH
27559: LD_VAR 0 8
27563: PPUSH
27564: LD_INT 2
27566: PPUSH
27567: CALL_OW 272
27571: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27572: LD_ADDR_VAR 0 10
27576: PUSH
27577: LD_VAR 0 11
27581: PPUSH
27582: CALL_OW 251
27586: PPUSH
27587: LD_VAR 0 8
27591: PPUSH
27592: LD_INT 2
27594: PPUSH
27595: CALL_OW 273
27599: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27600: LD_VAR 0 9
27604: PPUSH
27605: LD_VAR 0 10
27609: PPUSH
27610: CALL_OW 488
27614: PUSH
27615: LD_VAR 0 9
27619: PPUSH
27620: LD_VAR 0 10
27624: PPUSH
27625: CALL_OW 428
27629: NOT
27630: AND
27631: IFFALSE 27654
// begin ComMoveXY ( tmp , _x , _y ) ;
27633: LD_VAR 0 11
27637: PPUSH
27638: LD_VAR 0 9
27642: PPUSH
27643: LD_VAR 0 10
27647: PPUSH
27648: CALL_OW 111
// break ;
27652: GO 27656
// end ; end ;
27654: GO 27541
27656: POP
27657: POP
// end ;
27658: GO 27142
27660: POP
27661: POP
// end ;
27662: LD_VAR 0 6
27666: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27667: LD_INT 0
27669: PPUSH
27670: PPUSH
27671: PPUSH
27672: PPUSH
27673: PPUSH
27674: PPUSH
27675: PPUSH
27676: PPUSH
27677: PPUSH
27678: PPUSH
// result := false ;
27679: LD_ADDR_VAR 0 6
27683: PUSH
27684: LD_INT 0
27686: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27687: LD_VAR 0 1
27691: NOT
27692: PUSH
27693: LD_VAR 0 1
27697: PPUSH
27698: CALL_OW 266
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: LD_INT 1
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: IN
27713: NOT
27714: OR
27715: PUSH
27716: LD_VAR 0 2
27720: NOT
27721: OR
27722: PUSH
27723: LD_VAR 0 5
27727: PUSH
27728: LD_INT 0
27730: PUSH
27731: LD_INT 1
27733: PUSH
27734: LD_INT 2
27736: PUSH
27737: LD_INT 3
27739: PUSH
27740: LD_INT 4
27742: PUSH
27743: LD_INT 5
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: IN
27754: NOT
27755: OR
27756: PUSH
27757: LD_VAR 0 3
27761: PPUSH
27762: LD_VAR 0 4
27766: PPUSH
27767: CALL_OW 488
27771: NOT
27772: OR
27773: IFFALSE 27777
// exit ;
27775: GO 28494
// pom := GetBase ( bdepot ) ;
27777: LD_ADDR_VAR 0 10
27781: PUSH
27782: LD_VAR 0 1
27786: PPUSH
27787: CALL_OW 274
27791: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
27792: LD_ADDR_VAR 0 11
27796: PUSH
27797: LD_VAR 0 2
27801: PPUSH
27802: LD_VAR 0 1
27806: PPUSH
27807: CALL_OW 248
27811: PPUSH
27812: CALL_OW 450
27816: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27817: LD_VAR 0 10
27821: PPUSH
27822: LD_INT 1
27824: PPUSH
27825: CALL_OW 275
27829: PUSH
27830: LD_VAR 0 11
27834: PUSH
27835: LD_INT 1
27837: ARRAY
27838: GREATEREQUAL
27839: PUSH
27840: LD_VAR 0 10
27844: PPUSH
27845: LD_INT 2
27847: PPUSH
27848: CALL_OW 275
27852: PUSH
27853: LD_VAR 0 11
27857: PUSH
27858: LD_INT 2
27860: ARRAY
27861: GREATEREQUAL
27862: AND
27863: PUSH
27864: LD_VAR 0 10
27868: PPUSH
27869: LD_INT 3
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_VAR 0 11
27881: PUSH
27882: LD_INT 3
27884: ARRAY
27885: GREATEREQUAL
27886: AND
27887: NOT
27888: IFFALSE 27892
// exit ;
27890: GO 28494
// if GetBType ( bdepot ) = b_depot then
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 266
27901: PUSH
27902: LD_INT 0
27904: EQUAL
27905: IFFALSE 27917
// dist := 28 else
27907: LD_ADDR_VAR 0 14
27911: PUSH
27912: LD_INT 28
27914: ST_TO_ADDR
27915: GO 27925
// dist := 36 ;
27917: LD_ADDR_VAR 0 14
27921: PUSH
27922: LD_INT 36
27924: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
27925: LD_VAR 0 1
27929: PPUSH
27930: LD_VAR 0 3
27934: PPUSH
27935: LD_VAR 0 4
27939: PPUSH
27940: CALL_OW 297
27944: PUSH
27945: LD_VAR 0 14
27949: GREATER
27950: IFFALSE 27954
// exit ;
27952: GO 28494
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
27954: LD_ADDR_VAR 0 12
27958: PUSH
27959: LD_VAR 0 2
27963: PPUSH
27964: LD_VAR 0 3
27968: PPUSH
27969: LD_VAR 0 4
27973: PPUSH
27974: LD_VAR 0 5
27978: PPUSH
27979: LD_VAR 0 1
27983: PPUSH
27984: CALL_OW 248
27988: PPUSH
27989: LD_INT 0
27991: PPUSH
27992: CALL 28499 0 6
27996: ST_TO_ADDR
// if not hexes then
27997: LD_VAR 0 12
28001: NOT
28002: IFFALSE 28006
// exit ;
28004: GO 28494
// hex := GetHexInfo ( x , y ) ;
28006: LD_ADDR_VAR 0 15
28010: PUSH
28011: LD_VAR 0 3
28015: PPUSH
28016: LD_VAR 0 4
28020: PPUSH
28021: CALL_OW 546
28025: ST_TO_ADDR
// if hex [ 1 ] then
28026: LD_VAR 0 15
28030: PUSH
28031: LD_INT 1
28033: ARRAY
28034: IFFALSE 28038
// exit ;
28036: GO 28494
// height := hex [ 2 ] ;
28038: LD_ADDR_VAR 0 13
28042: PUSH
28043: LD_VAR 0 15
28047: PUSH
28048: LD_INT 2
28050: ARRAY
28051: ST_TO_ADDR
// for i = 1 to hexes do
28052: LD_ADDR_VAR 0 7
28056: PUSH
28057: DOUBLE
28058: LD_INT 1
28060: DEC
28061: ST_TO_ADDR
28062: LD_VAR 0 12
28066: PUSH
28067: FOR_TO
28068: IFFALSE 28398
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28070: LD_VAR 0 12
28074: PUSH
28075: LD_VAR 0 7
28079: ARRAY
28080: PUSH
28081: LD_INT 1
28083: ARRAY
28084: PPUSH
28085: LD_VAR 0 12
28089: PUSH
28090: LD_VAR 0 7
28094: ARRAY
28095: PUSH
28096: LD_INT 2
28098: ARRAY
28099: PPUSH
28100: CALL_OW 488
28104: NOT
28105: PUSH
28106: LD_VAR 0 12
28110: PUSH
28111: LD_VAR 0 7
28115: ARRAY
28116: PUSH
28117: LD_INT 1
28119: ARRAY
28120: PPUSH
28121: LD_VAR 0 12
28125: PUSH
28126: LD_VAR 0 7
28130: ARRAY
28131: PUSH
28132: LD_INT 2
28134: ARRAY
28135: PPUSH
28136: CALL_OW 428
28140: PUSH
28141: LD_INT 0
28143: GREATER
28144: OR
28145: PUSH
28146: LD_VAR 0 12
28150: PUSH
28151: LD_VAR 0 7
28155: ARRAY
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: LD_VAR 0 12
28165: PUSH
28166: LD_VAR 0 7
28170: ARRAY
28171: PUSH
28172: LD_INT 2
28174: ARRAY
28175: PPUSH
28176: CALL_OW 351
28180: OR
28181: IFFALSE 28187
// exit ;
28183: POP
28184: POP
28185: GO 28494
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28187: LD_ADDR_VAR 0 8
28191: PUSH
28192: LD_VAR 0 12
28196: PUSH
28197: LD_VAR 0 7
28201: ARRAY
28202: PUSH
28203: LD_INT 1
28205: ARRAY
28206: PPUSH
28207: LD_VAR 0 12
28211: PUSH
28212: LD_VAR 0 7
28216: ARRAY
28217: PUSH
28218: LD_INT 2
28220: ARRAY
28221: PPUSH
28222: CALL_OW 546
28226: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28227: LD_VAR 0 8
28231: PUSH
28232: LD_INT 1
28234: ARRAY
28235: PUSH
28236: LD_VAR 0 8
28240: PUSH
28241: LD_INT 2
28243: ARRAY
28244: PUSH
28245: LD_VAR 0 13
28249: PUSH
28250: LD_INT 2
28252: PLUS
28253: GREATER
28254: OR
28255: PUSH
28256: LD_VAR 0 8
28260: PUSH
28261: LD_INT 2
28263: ARRAY
28264: PUSH
28265: LD_VAR 0 13
28269: PUSH
28270: LD_INT 2
28272: MINUS
28273: LESS
28274: OR
28275: PUSH
28276: LD_VAR 0 8
28280: PUSH
28281: LD_INT 3
28283: ARRAY
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: LD_INT 8
28290: PUSH
28291: LD_INT 9
28293: PUSH
28294: LD_INT 10
28296: PUSH
28297: LD_INT 11
28299: PUSH
28300: LD_INT 12
28302: PUSH
28303: LD_INT 13
28305: PUSH
28306: LD_INT 16
28308: PUSH
28309: LD_INT 17
28311: PUSH
28312: LD_INT 18
28314: PUSH
28315: LD_INT 19
28317: PUSH
28318: LD_INT 20
28320: PUSH
28321: LD_INT 21
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: IN
28339: NOT
28340: OR
28341: PUSH
28342: LD_VAR 0 8
28346: PUSH
28347: LD_INT 5
28349: ARRAY
28350: NOT
28351: OR
28352: PUSH
28353: LD_VAR 0 8
28357: PUSH
28358: LD_INT 6
28360: ARRAY
28361: PUSH
28362: LD_INT 1
28364: PUSH
28365: LD_INT 2
28367: PUSH
28368: LD_INT 7
28370: PUSH
28371: LD_INT 9
28373: PUSH
28374: LD_INT 10
28376: PUSH
28377: LD_INT 11
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: IN
28388: NOT
28389: OR
28390: IFFALSE 28396
// exit ;
28392: POP
28393: POP
28394: GO 28494
// end ;
28396: GO 28067
28398: POP
28399: POP
// side := GetSide ( bdepot ) ;
28400: LD_ADDR_VAR 0 9
28404: PUSH
28405: LD_VAR 0 1
28409: PPUSH
28410: CALL_OW 255
28414: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28415: LD_VAR 0 9
28419: PPUSH
28420: LD_VAR 0 3
28424: PPUSH
28425: LD_VAR 0 4
28429: PPUSH
28430: LD_INT 20
28432: PPUSH
28433: CALL 21166 0 4
28437: PUSH
28438: LD_INT 4
28440: ARRAY
28441: IFFALSE 28445
// exit ;
28443: GO 28494
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28445: LD_VAR 0 2
28449: PUSH
28450: LD_INT 29
28452: PUSH
28453: LD_INT 30
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: IN
28460: PUSH
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_VAR 0 4
28470: PPUSH
28471: LD_VAR 0 9
28475: PPUSH
28476: CALL_OW 440
28480: NOT
28481: AND
28482: IFFALSE 28486
// exit ;
28484: GO 28494
// result := true ;
28486: LD_ADDR_VAR 0 6
28490: PUSH
28491: LD_INT 1
28493: ST_TO_ADDR
// end ;
28494: LD_VAR 0 6
28498: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28499: LD_INT 0
28501: PPUSH
28502: PPUSH
28503: PPUSH
28504: PPUSH
28505: PPUSH
28506: PPUSH
28507: PPUSH
28508: PPUSH
28509: PPUSH
28510: PPUSH
28511: PPUSH
28512: PPUSH
28513: PPUSH
28514: PPUSH
28515: PPUSH
28516: PPUSH
28517: PPUSH
28518: PPUSH
28519: PPUSH
28520: PPUSH
28521: PPUSH
28522: PPUSH
28523: PPUSH
28524: PPUSH
28525: PPUSH
28526: PPUSH
28527: PPUSH
28528: PPUSH
28529: PPUSH
28530: PPUSH
28531: PPUSH
28532: PPUSH
28533: PPUSH
28534: PPUSH
28535: PPUSH
28536: PPUSH
28537: PPUSH
28538: PPUSH
28539: PPUSH
28540: PPUSH
28541: PPUSH
28542: PPUSH
28543: PPUSH
28544: PPUSH
28545: PPUSH
28546: PPUSH
28547: PPUSH
28548: PPUSH
28549: PPUSH
28550: PPUSH
28551: PPUSH
28552: PPUSH
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
// result = [ ] ;
28559: LD_ADDR_VAR 0 7
28563: PUSH
28564: EMPTY
28565: ST_TO_ADDR
// temp_list = [ ] ;
28566: LD_ADDR_VAR 0 9
28570: PUSH
28571: EMPTY
28572: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28573: LD_VAR 0 4
28577: PUSH
28578: LD_INT 0
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 2
28586: PUSH
28587: LD_INT 3
28589: PUSH
28590: LD_INT 4
28592: PUSH
28593: LD_INT 5
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: IN
28604: NOT
28605: PUSH
28606: LD_VAR 0 1
28610: PUSH
28611: LD_INT 0
28613: PUSH
28614: LD_INT 1
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: IN
28621: PUSH
28622: LD_VAR 0 5
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: LD_INT 2
28632: PUSH
28633: LD_INT 3
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: LIST
28640: IN
28641: NOT
28642: AND
28643: OR
28644: IFFALSE 28648
// exit ;
28646: GO 47033
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28648: LD_VAR 0 1
28652: PUSH
28653: LD_INT 6
28655: PUSH
28656: LD_INT 7
28658: PUSH
28659: LD_INT 8
28661: PUSH
28662: LD_INT 13
28664: PUSH
28665: LD_INT 12
28667: PUSH
28668: LD_INT 15
28670: PUSH
28671: LD_INT 11
28673: PUSH
28674: LD_INT 14
28676: PUSH
28677: LD_INT 10
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: IN
28691: IFFALSE 28701
// btype = b_lab ;
28693: LD_ADDR_VAR 0 1
28697: PUSH
28698: LD_INT 6
28700: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28701: LD_VAR 0 6
28705: PUSH
28706: LD_INT 0
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: LD_INT 2
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: LIST
28719: IN
28720: NOT
28721: PUSH
28722: LD_VAR 0 1
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: LD_INT 1
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: LD_INT 3
28738: PUSH
28739: LD_INT 6
28741: PUSH
28742: LD_INT 36
28744: PUSH
28745: LD_INT 4
28747: PUSH
28748: LD_INT 5
28750: PUSH
28751: LD_INT 31
28753: PUSH
28754: LD_INT 32
28756: PUSH
28757: LD_INT 33
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: IN
28773: NOT
28774: PUSH
28775: LD_VAR 0 6
28779: PUSH
28780: LD_INT 1
28782: EQUAL
28783: AND
28784: OR
28785: PUSH
28786: LD_VAR 0 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: LD_INT 3
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: IN
28801: NOT
28802: PUSH
28803: LD_VAR 0 6
28807: PUSH
28808: LD_INT 2
28810: EQUAL
28811: AND
28812: OR
28813: IFFALSE 28823
// mode = 0 ;
28815: LD_ADDR_VAR 0 6
28819: PUSH
28820: LD_INT 0
28822: ST_TO_ADDR
// case mode of 0 :
28823: LD_VAR 0 6
28827: PUSH
28828: LD_INT 0
28830: DOUBLE
28831: EQUAL
28832: IFTRUE 28836
28834: GO 40289
28836: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28837: LD_ADDR_VAR 0 11
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: LD_INT 0
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 0
28854: PUSH
28855: LD_INT 1
28857: NEG
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: LD_INT 0
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 1
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 0
28885: PUSH
28886: LD_INT 1
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: LD_INT 0
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 1
28906: NEG
28907: PUSH
28908: LD_INT 1
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 1
28918: NEG
28919: PUSH
28920: LD_INT 2
28922: NEG
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 0
28930: PUSH
28931: LD_INT 2
28933: NEG
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: PUSH
28939: LD_INT 1
28941: PUSH
28942: LD_INT 1
28944: NEG
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 1
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: LD_INT 3
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 0
28993: PUSH
28994: LD_INT 3
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 1
29003: NEG
29004: PUSH
29005: LD_INT 2
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29030: LD_ADDR_VAR 0 12
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: LD_INT 0
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: LD_INT 1
29050: NEG
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 1
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 0
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: NEG
29089: PUSH
29090: LD_INT 0
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 1
29099: NEG
29100: PUSH
29101: LD_INT 1
29103: NEG
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 2
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 2
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 1
29142: NEG
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 2
29153: NEG
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 2
29164: NEG
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: NEG
29177: PUSH
29178: LD_INT 1
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 3
29187: NEG
29188: PUSH
29189: LD_INT 0
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 3
29198: NEG
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29226: LD_ADDR_VAR 0 13
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 0
29243: PUSH
29244: LD_INT 1
29246: NEG
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: LD_INT 0
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 1
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 1
29284: NEG
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: NEG
29296: PUSH
29297: LD_INT 1
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: LD_INT 1
29307: NEG
29308: PUSH
29309: LD_INT 2
29311: NEG
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 2
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 2
29329: PUSH
29330: LD_INT 2
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 1
29339: PUSH
29340: LD_INT 2
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: NEG
29350: PUSH
29351: LD_INT 1
29353: NEG
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 2
29361: NEG
29362: PUSH
29363: LD_INT 2
29365: NEG
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 2
29373: NEG
29374: PUSH
29375: LD_INT 3
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 3
29385: NEG
29386: PUSH
29387: LD_INT 2
29389: NEG
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 3
29397: NEG
29398: PUSH
29399: LD_INT 3
29401: NEG
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29425: LD_ADDR_VAR 0 14
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 0
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 1
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: NEG
29507: PUSH
29508: LD_INT 2
29510: NEG
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 2
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 1
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: LD_INT 2
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 1
29571: NEG
29572: PUSH
29573: LD_INT 3
29575: NEG
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 0
29583: PUSH
29584: LD_INT 3
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29621: LD_ADDR_VAR 0 15
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 0
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 1
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 2
29713: PUSH
29714: LD_INT 0
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 2
29723: PUSH
29724: LD_INT 1
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 1
29733: NEG
29734: PUSH
29735: LD_INT 1
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 2
29744: NEG
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 2
29755: NEG
29756: PUSH
29757: LD_INT 1
29759: NEG
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 2
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 3
29778: PUSH
29779: LD_INT 0
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 3
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29814: LD_ADDR_VAR 0 16
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 0
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 0
29831: PUSH
29832: LD_INT 1
29834: NEG
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 0
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: NEG
29873: PUSH
29874: LD_INT 0
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: NEG
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 1
29895: NEG
29896: PUSH
29897: LD_INT 2
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 2
29917: PUSH
29918: LD_INT 2
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 1
29927: PUSH
29928: LD_INT 2
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 2
29937: NEG
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: NEG
29950: PUSH
29951: LD_INT 2
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 3
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 3
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 2
29981: PUSH
29982: LD_INT 3
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30007: LD_ADDR_VAR 0 17
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: LD_INT 0
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 0
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 1
30065: NEG
30066: PUSH
30067: LD_INT 0
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 1
30076: NEG
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: NEG
30089: PUSH
30090: LD_INT 2
30092: NEG
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 0
30100: PUSH
30101: LD_INT 2
30103: NEG
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: PUSH
30123: LD_INT 0
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 2
30142: PUSH
30143: LD_INT 2
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: LD_INT 2
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: LD_INT 2
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 2
30183: NEG
30184: PUSH
30185: LD_INT 0
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 2
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30237: LD_ADDR_VAR 0 18
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: LD_INT 0
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: LD_INT 1
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 0
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: LD_INT 0
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 1
30306: NEG
30307: PUSH
30308: LD_INT 1
30310: NEG
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 1
30318: NEG
30319: PUSH
30320: LD_INT 2
30322: NEG
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: LD_INT 2
30333: NEG
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: LD_INT 1
30344: NEG
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 2
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 2
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 2
30372: PUSH
30373: LD_INT 2
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: PUSH
30383: LD_INT 2
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 0
30392: PUSH
30393: LD_INT 2
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 1
30402: NEG
30403: PUSH
30404: LD_INT 1
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 2
30413: NEG
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 2
30424: NEG
30425: PUSH
30426: LD_INT 1
30428: NEG
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 2
30436: NEG
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30467: LD_ADDR_VAR 0 19
30471: PUSH
30472: LD_INT 0
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 0
30484: PUSH
30485: LD_INT 1
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 0
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PUSH
30503: LD_INT 1
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 0
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 0
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 1
30536: NEG
30537: PUSH
30538: LD_INT 1
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 1
30548: NEG
30549: PUSH
30550: LD_INT 2
30552: NEG
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 0
30560: PUSH
30561: LD_INT 2
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 2
30582: PUSH
30583: LD_INT 0
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 2
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 2
30602: PUSH
30603: LD_INT 2
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 1
30612: PUSH
30613: LD_INT 2
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 0
30622: PUSH
30623: LD_INT 2
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 2
30643: NEG
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: LD_INT 1
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 2
30666: NEG
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30697: LD_ADDR_VAR 0 20
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 0
30714: PUSH
30715: LD_INT 1
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 1
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: LD_INT 1
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 1
30766: NEG
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: LD_INT 2
30782: NEG
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 2
30812: PUSH
30813: LD_INT 0
30815: PUSH
30816: EMPTY
30817: LIST
30818: LIST
30819: PUSH
30820: LD_INT 2
30822: PUSH
30823: LD_INT 1
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 2
30832: PUSH
30833: LD_INT 2
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: PUSH
30843: LD_INT 2
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: LD_INT 1
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 2
30873: NEG
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 2
30884: NEG
30885: PUSH
30886: LD_INT 1
30888: NEG
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 2
30896: NEG
30897: PUSH
30898: LD_INT 2
30900: NEG
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30927: LD_ADDR_VAR 0 21
30931: PUSH
30932: LD_INT 0
30934: PUSH
30935: LD_INT 0
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: LD_INT 1
30947: NEG
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: LD_INT 0
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: LD_INT 1
30965: PUSH
30966: LD_INT 1
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 1
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 1
30985: NEG
30986: PUSH
30987: LD_INT 0
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 1
30996: NEG
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 1
31008: NEG
31009: PUSH
31010: LD_INT 2
31012: NEG
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 0
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: LD_INT 1
31034: NEG
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 2
31042: PUSH
31043: LD_INT 0
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 2
31052: PUSH
31053: LD_INT 1
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 2
31062: PUSH
31063: LD_INT 2
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 1
31072: PUSH
31073: LD_INT 2
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 0
31082: PUSH
31083: LD_INT 2
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: NEG
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 2
31103: NEG
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 2
31114: NEG
31115: PUSH
31116: LD_INT 1
31118: NEG
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: LD_INT 2
31126: NEG
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31157: LD_ADDR_VAR 0 22
31161: PUSH
31162: LD_INT 0
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 0
31174: PUSH
31175: LD_INT 1
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 0
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: LD_INT 1
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: LD_INT 1
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 1
31215: NEG
31216: PUSH
31217: LD_INT 0
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 1
31226: NEG
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 1
31238: NEG
31239: PUSH
31240: LD_INT 2
31242: NEG
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 0
31250: PUSH
31251: LD_INT 2
31253: NEG
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 2
31272: PUSH
31273: LD_INT 0
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: LD_INT 1
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: LD_INT 2
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 0
31312: PUSH
31313: LD_INT 2
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: NEG
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 2
31333: NEG
31334: PUSH
31335: LD_INT 0
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: NEG
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 2
31356: NEG
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31387: LD_ADDR_VAR 0 23
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 1
31415: PUSH
31416: LD_INT 0
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 1
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 1
31445: NEG
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: NEG
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: LD_INT 2
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 2
31502: PUSH
31503: LD_INT 0
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 2
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 2
31522: PUSH
31523: LD_INT 2
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: LD_INT 2
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: LD_INT 2
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: LD_INT 1
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: NEG
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 2
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 2
31586: NEG
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 2
31598: NEG
31599: PUSH
31600: LD_INT 3
31602: NEG
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 3
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 1
31622: PUSH
31623: LD_INT 2
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 2
31633: PUSH
31634: LD_INT 1
31636: NEG
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31667: LD_ADDR_VAR 0 24
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: LD_INT 1
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 1
31736: NEG
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 0
31760: PUSH
31761: LD_INT 2
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: LD_INT 0
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 0
31822: PUSH
31823: LD_INT 2
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: LD_INT 1
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: NEG
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: LD_INT 2
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 1
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 2
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 3
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: LD_INT 2
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31943: LD_ADDR_VAR 0 25
31947: PUSH
31948: LD_INT 0
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: LD_INT 1
31963: NEG
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: NEG
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 2
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: PUSH
32089: LD_INT 2
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 0
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 2
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 2
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: PUSH
32155: LD_INT 1
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 3
32164: PUSH
32165: LD_INT 2
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: LD_INT 3
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: LD_INT 3
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32217: LD_ADDR_VAR 0 26
32221: PUSH
32222: LD_INT 0
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 1
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 0
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 1
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 0
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 1
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 2
32332: PUSH
32333: LD_INT 0
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: LD_INT 2
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 2
32393: NEG
32394: PUSH
32395: LD_INT 0
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 2
32404: NEG
32405: PUSH
32406: LD_INT 1
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: LD_INT 2
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 2
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 1
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 1
32448: NEG
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 2
32459: NEG
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32493: LD_ADDR_VAR 0 27
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 0
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 0
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 0
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: LD_INT 2
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: LD_INT 2
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: LD_INT 0
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 2
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 2
32628: PUSH
32629: LD_INT 2
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: LD_INT 2
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: LD_INT 2
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: LD_INT 1
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 2
32669: NEG
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 2
32692: NEG
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: LD_INT 1
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 3
32726: NEG
32727: PUSH
32728: LD_INT 1
32730: NEG
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32773: LD_ADDR_VAR 0 28
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 1
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 2
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: NEG
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 1
32877: PUSH
32878: LD_INT 1
32880: NEG
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: PUSH
32899: LD_INT 1
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 2
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: LD_INT 2
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: LD_INT 0
32928: PUSH
32929: LD_INT 2
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 1
32938: NEG
32939: PUSH
32940: LD_INT 1
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 2
32960: NEG
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: LD_INT 2
32976: NEG
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: LD_INT 3
32988: NEG
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 1
32996: NEG
32997: PUSH
32998: LD_INT 3
33000: NEG
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 3
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 3
33020: NEG
33021: PUSH
33022: LD_INT 2
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33055: LD_ADDR_VAR 0 29
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: LD_INT 0
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 0
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 1
33113: NEG
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: NEG
33125: PUSH
33126: LD_INT 1
33128: NEG
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 1
33136: NEG
33137: PUSH
33138: LD_INT 2
33140: NEG
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: LD_INT 2
33151: NEG
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: PUSH
33157: LD_INT 1
33159: PUSH
33160: LD_INT 1
33162: NEG
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 2
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 2
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 0
33200: PUSH
33201: LD_INT 2
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: NEG
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 2
33245: NEG
33246: PUSH
33247: LD_INT 3
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 2
33257: PUSH
33258: LD_INT 1
33260: NEG
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 3
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 3
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 2
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 3
33299: NEG
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33334: LD_ADDR_VAR 0 30
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: LD_INT 1
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: PUSH
33363: LD_INT 0
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: LD_INT 0
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 2
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 1
33441: NEG
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 1
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 1
33489: NEG
33490: PUSH
33491: LD_INT 1
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 2
33500: NEG
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 2
33511: NEG
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: LD_INT 3
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 3
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 2
33556: PUSH
33557: LD_INT 3
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 2
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 3
33577: NEG
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33612: LD_ADDR_VAR 0 31
33616: PUSH
33617: LD_INT 0
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: LD_INT 1
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 1
33670: NEG
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: NEG
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 2
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 2
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: LD_INT 2
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: NEG
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 2
33777: NEG
33778: PUSH
33779: LD_INT 1
33781: NEG
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 2
33789: NEG
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 3
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 1
33816: NEG
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 3
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: LD_INT 2
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 3
33855: NEG
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33890: LD_ADDR_VAR 0 32
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 0
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 1
33959: NEG
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 2
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 1
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 2
34005: PUSH
34006: LD_INT 1
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: LD_INT 2
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: LD_INT 2
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: NEG
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 2
34067: NEG
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: LD_INT 3
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: LD_INT 2
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 3
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 2
34112: PUSH
34113: LD_INT 3
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: LD_INT 1
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 3
34133: NEG
34134: PUSH
34135: LD_INT 1
34137: NEG
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34168: LD_ADDR_VAR 0 33
34172: PUSH
34173: LD_INT 0
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 1
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 2
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: LD_INT 1
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 2
34323: NEG
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 2
34334: NEG
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: LD_INT 2
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: NEG
34359: PUSH
34360: LD_INT 3
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 3
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: LD_INT 3
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: LD_INT 2
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 3
34412: NEG
34413: PUSH
34414: LD_INT 2
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34447: LD_ADDR_VAR 0 34
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 1
34467: NEG
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 1
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: LD_INT 1
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 1
34528: NEG
34529: PUSH
34530: LD_INT 2
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: LD_INT 2
34543: NEG
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 2
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: LD_INT 2
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 1
34638: NEG
34639: PUSH
34640: LD_INT 3
34642: NEG
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 1
34650: PUSH
34651: LD_INT 2
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: LD_INT 2
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 2
34671: PUSH
34672: LD_INT 3
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 2
34681: NEG
34682: PUSH
34683: LD_INT 1
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 3
34692: NEG
34693: PUSH
34694: LD_INT 1
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34727: LD_ADDR_VAR 0 35
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 0
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34839: LD_ADDR_VAR 0 36
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 1
34859: NEG
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: NEG
34898: PUSH
34899: LD_INT 0
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: LD_INT 1
34912: NEG
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 1
34920: NEG
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: LD_INT 2
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34951: LD_ADDR_VAR 0 37
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: LD_INT 0
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: LD_INT 1
34971: NEG
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 1
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 1
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: LD_INT 0
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: LD_INT 1
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35063: LD_ADDR_VAR 0 38
35067: PUSH
35068: LD_INT 0
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 0
35080: PUSH
35081: LD_INT 1
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 1
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 1
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 0
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 2
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35175: LD_ADDR_VAR 0 39
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: LD_INT 0
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: LD_INT 0
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: LD_INT 0
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: LD_INT 1
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 0
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: NEG
35257: PUSH
35258: LD_INT 2
35260: NEG
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 1
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35287: LD_ADDR_VAR 0 40
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 1
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 0
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 1
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35399: LD_ADDR_VAR 0 41
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 0
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 2
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 2
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 2
35523: PUSH
35524: LD_INT 2
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: LD_INT 2
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: NEG
35544: PUSH
35545: LD_INT 1
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 2
35554: NEG
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 2
35577: NEG
35578: PUSH
35579: LD_INT 2
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 2
35589: NEG
35590: PUSH
35591: LD_INT 3
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: LD_INT 1
35604: NEG
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 3
35612: PUSH
35613: LD_INT 0
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 3
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 3
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 3
35642: PUSH
35643: LD_INT 3
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 2
35652: PUSH
35653: LD_INT 3
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 2
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 3
35673: NEG
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 3
35684: NEG
35685: PUSH
35686: LD_INT 1
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 3
35696: NEG
35697: PUSH
35698: LD_INT 2
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 3
35708: NEG
35709: PUSH
35710: LD_INT 3
35712: NEG
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35749: LD_ADDR_VAR 0 42
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 0
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 0
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 0
35797: PUSH
35798: LD_INT 1
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: LD_INT 1
35822: NEG
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 2
35845: NEG
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 2
35864: PUSH
35865: LD_INT 1
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 2
35874: PUSH
35875: LD_INT 2
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 2
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 0
35894: PUSH
35895: LD_INT 2
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 2
35915: NEG
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 2
35927: NEG
35928: PUSH
35929: LD_INT 2
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 3
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: LD_INT 3
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 3
35985: PUSH
35986: LD_INT 2
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: PUSH
35993: LD_INT 3
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 2
36005: PUSH
36006: LD_INT 3
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 1
36015: PUSH
36016: LD_INT 3
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 0
36025: PUSH
36026: LD_INT 3
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 3
36046: NEG
36047: PUSH
36048: LD_INT 2
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: LD_INT 3
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36099: LD_ADDR_VAR 0 43
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 0
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 0
36116: PUSH
36117: LD_INT 1
36119: NEG
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: NEG
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: LD_INT 1
36172: NEG
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: LD_INT 2
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 2
36195: NEG
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 2
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 2
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 3
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 3
36303: NEG
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 1
36311: PUSH
36312: LD_INT 2
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: PUSH
36323: LD_INT 1
36325: NEG
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 3
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 3
36343: PUSH
36344: LD_INT 1
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: PUSH
36354: LD_INT 3
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: LD_INT 3
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: LD_INT 2
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 2
36384: NEG
36385: PUSH
36386: LD_INT 1
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 3
36406: NEG
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: LIST
36422: LIST
36423: LIST
36424: LIST
36425: LIST
36426: LIST
36427: LIST
36428: LIST
36429: LIST
36430: LIST
36431: LIST
36432: LIST
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36447: LD_ADDR_VAR 0 44
36451: PUSH
36452: LD_INT 0
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 0
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 1
36475: PUSH
36476: LD_INT 0
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 1
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: LD_INT 1
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 1
36516: NEG
36517: PUSH
36518: LD_INT 1
36520: NEG
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 1
36528: NEG
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: LD_INT 1
36543: NEG
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 2
36561: PUSH
36562: LD_INT 1
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 2
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: LD_INT 2
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 2
36613: NEG
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 2
36625: NEG
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 2
36637: NEG
36638: PUSH
36639: LD_INT 3
36641: NEG
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 3
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 3
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 3
36680: PUSH
36681: LD_INT 2
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 3
36690: PUSH
36691: LD_INT 3
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: PUSH
36701: LD_INT 3
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: NEG
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: NEG
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 3
36732: NEG
36733: PUSH
36734: LD_INT 1
36736: NEG
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 3
36744: NEG
36745: PUSH
36746: LD_INT 2
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 3
36756: NEG
36757: PUSH
36758: LD_INT 3
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: LIST
36781: LIST
36782: LIST
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36797: LD_ADDR_VAR 0 45
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: PUSH
36826: LD_INT 0
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 1
36835: PUSH
36836: LD_INT 1
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 0
36845: PUSH
36846: LD_INT 1
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 1
36855: NEG
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 2
36893: NEG
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 1
36904: NEG
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 2
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 1
36932: PUSH
36933: LD_INT 2
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: LD_INT 2
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: LD_INT 1
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 2
36987: NEG
36988: PUSH
36989: LD_INT 3
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: LD_INT 3
37003: NEG
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: LD_INT 0
37011: PUSH
37012: LD_INT 3
37014: NEG
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: LD_INT 2
37025: NEG
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 3
37033: PUSH
37034: LD_INT 2
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 3
37043: PUSH
37044: LD_INT 3
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 2
37053: PUSH
37054: LD_INT 3
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 3
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 0
37073: PUSH
37074: LD_INT 3
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: LD_INT 2
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 3
37094: NEG
37095: PUSH
37096: LD_INT 2
37098: NEG
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: LD_INT 3
37106: NEG
37107: PUSH
37108: LD_INT 3
37110: NEG
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37147: LD_ADDR_VAR 0 46
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: LD_INT 0
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 0
37164: PUSH
37165: LD_INT 1
37167: NEG
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 1
37175: PUSH
37176: LD_INT 0
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: LD_INT 1
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: LD_INT 1
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 1
37205: NEG
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 1
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 2
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 2
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 1
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 2
37262: PUSH
37263: LD_INT 0
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: LD_INT 1
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: LD_INT 2
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 0
37292: PUSH
37293: LD_INT 2
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 1
37302: NEG
37303: PUSH
37304: LD_INT 1
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 2
37313: NEG
37314: PUSH
37315: LD_INT 0
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 1
37336: NEG
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 0
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: LD_INT 1
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 1
37401: PUSH
37402: LD_INT 3
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 3
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: NEG
37422: PUSH
37423: LD_INT 2
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 2
37432: NEG
37433: PUSH
37434: LD_INT 1
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: LD_INT 0
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 3
37454: NEG
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: LIST
37468: LIST
37469: LIST
37470: LIST
37471: LIST
37472: LIST
37473: LIST
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: LIST
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37495: LD_ADDR_VAR 0 47
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: LD_INT 0
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PUSH
37531: LD_INT 1
37533: PUSH
37534: LD_INT 1
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: LD_INT 1
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: NEG
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: LD_INT 2
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 0
37588: PUSH
37589: LD_INT 2
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 2
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37646: LD_ADDR_VAR 0 48
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: LD_INT 0
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 1
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 1
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: LD_INT 1
37719: NEG
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 1
37727: NEG
37728: PUSH
37729: LD_INT 2
37731: NEG
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 2
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37793: LD_ADDR_VAR 0 49
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: LD_INT 0
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: LD_INT 0
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 1
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 1
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 1
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: LD_INT 1
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: LD_INT 1
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: PUSH
37886: LD_INT 0
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 2
37895: PUSH
37896: LD_INT 1
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 2
37905: PUSH
37906: LD_INT 2
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: LD_INT 2
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37937: LD_ADDR_VAR 0 50
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: LD_INT 1
37957: NEG
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 1
37965: PUSH
37966: LD_INT 0
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 1
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: LD_INT 1
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: LD_INT 0
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 2
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 2
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38081: LD_ADDR_VAR 0 51
38085: PUSH
38086: LD_INT 0
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: LD_INT 1
38101: NEG
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: LD_INT 1
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: NEG
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: LD_INT 2
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 0
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 2
38193: NEG
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: LD_INT 1
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: LIST
38218: LIST
38219: LIST
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38228: LD_ADDR_VAR 0 52
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: LD_INT 1
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: NEG
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 1
38297: NEG
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 1
38309: NEG
38310: PUSH
38311: LD_INT 2
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 1
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 2
38332: NEG
38333: PUSH
38334: LD_INT 0
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 2
38343: NEG
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 2
38355: NEG
38356: PUSH
38357: LD_INT 2
38359: NEG
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38379: LD_ADDR_VAR 0 53
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 1
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 1
38437: NEG
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: NEG
38449: PUSH
38450: LD_INT 1
38452: NEG
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: LD_INT 2
38464: NEG
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: LD_INT 2
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 1
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: LD_INT 0
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 2
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: LD_INT 2
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: NEG
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: NEG
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 2
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38609: LD_ADDR_VAR 0 54
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 1
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: NEG
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: PUSH
38725: LD_INT 0
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 2
38734: PUSH
38735: LD_INT 1
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 2
38744: PUSH
38745: LD_INT 2
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: LD_INT 1
38754: PUSH
38755: LD_INT 2
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 0
38764: PUSH
38765: LD_INT 2
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 1
38774: NEG
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 2
38785: NEG
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: NEG
38797: PUSH
38798: LD_INT 1
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 2
38808: NEG
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38839: LD_ADDR_VAR 0 55
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: LD_INT 0
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 0
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 1
38867: PUSH
38868: LD_INT 0
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 1
38920: NEG
38921: PUSH
38922: LD_INT 2
38924: NEG
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: LD_INT 2
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 0
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 2
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 2
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 2
39038: NEG
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39069: LD_ADDR_VAR 0 56
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: LD_INT 1
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 1
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: LD_INT 1
39107: PUSH
39108: LD_INT 1
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 0
39117: PUSH
39118: LD_INT 1
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 1
39127: NEG
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: NEG
39139: PUSH
39140: LD_INT 1
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: LD_INT 2
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 2
39165: NEG
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 2
39184: PUSH
39185: LD_INT 0
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 2
39194: PUSH
39195: LD_INT 1
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 2
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 1
39214: PUSH
39215: LD_INT 2
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 0
39224: PUSH
39225: LD_INT 2
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 1
39234: NEG
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: LD_INT 0
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PUSH
39254: LD_INT 2
39256: NEG
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 2
39268: NEG
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39299: LD_ADDR_VAR 0 57
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 1
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: LD_INT 1
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 0
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 1
39357: NEG
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: NEG
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: LD_INT 1
39406: NEG
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 2
39414: PUSH
39415: LD_INT 0
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 2
39424: PUSH
39425: LD_INT 1
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 2
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: LD_INT 2
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: LD_INT 1
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 2
39475: NEG
39476: PUSH
39477: LD_INT 0
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: NEG
39487: PUSH
39488: LD_INT 1
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 2
39498: NEG
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39529: LD_ADDR_VAR 0 58
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: LD_INT 1
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 1
39557: PUSH
39558: LD_INT 0
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 1
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: LD_INT 1
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 1
39587: NEG
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 1
39610: NEG
39611: PUSH
39612: LD_INT 2
39614: NEG
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 0
39622: PUSH
39623: LD_INT 2
39625: NEG
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 2
39644: PUSH
39645: LD_INT 0
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 2
39654: PUSH
39655: LD_INT 1
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 2
39664: PUSH
39665: LD_INT 2
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 1
39674: PUSH
39675: LD_INT 2
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: LD_INT 2
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: NEG
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 2
39705: NEG
39706: PUSH
39707: LD_INT 0
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 2
39716: NEG
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 2
39728: NEG
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39759: LD_ADDR_VAR 0 59
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: LD_INT 1
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: LD_INT 0
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 1
39817: NEG
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 1
39828: NEG
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39847: LD_ADDR_VAR 0 60
39851: PUSH
39852: LD_INT 0
39854: PUSH
39855: LD_INT 0
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 0
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 1
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: PUSH
39886: LD_INT 1
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 1
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: NEG
39917: PUSH
39918: LD_INT 1
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39935: LD_ADDR_VAR 0 61
39939: PUSH
39940: LD_INT 0
39942: PUSH
39943: LD_INT 0
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 1
39973: PUSH
39974: LD_INT 1
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 1
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: LD_INT 0
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: NEG
40005: PUSH
40006: LD_INT 1
40008: NEG
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40023: LD_ADDR_VAR 0 62
40027: PUSH
40028: LD_INT 0
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 0
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 1
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 1
40081: NEG
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: NEG
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40111: LD_ADDR_VAR 0 63
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 0
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 0
40128: PUSH
40129: LD_INT 1
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: LD_INT 1
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 1
40180: NEG
40181: PUSH
40182: LD_INT 1
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40199: LD_ADDR_VAR 0 64
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 1
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 1
40237: PUSH
40238: LD_INT 1
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 0
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 1
40257: NEG
40258: PUSH
40259: LD_INT 0
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 1
40272: NEG
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: ST_TO_ADDR
// end ; 1 :
40287: GO 46184
40289: LD_INT 1
40291: DOUBLE
40292: EQUAL
40293: IFTRUE 40297
40295: GO 42920
40297: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40298: LD_ADDR_VAR 0 11
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: LD_INT 3
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 3
40320: NEG
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: LD_INT 2
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: LIST
40341: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40342: LD_ADDR_VAR 0 12
40346: PUSH
40347: LD_INT 2
40349: PUSH
40350: LD_INT 1
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 3
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: LIST
40382: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40383: LD_ADDR_VAR 0 13
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 3
40400: PUSH
40401: LD_INT 3
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 2
40410: PUSH
40411: LD_INT 3
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: LIST
40422: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40423: LD_ADDR_VAR 0 14
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: LD_INT 3
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 0
40440: PUSH
40441: LD_INT 3
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: LIST
40463: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40464: LD_ADDR_VAR 0 15
40468: PUSH
40469: LD_INT 2
40471: NEG
40472: PUSH
40473: LD_INT 1
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 3
40482: NEG
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 3
40493: NEG
40494: PUSH
40495: LD_INT 1
40497: NEG
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: LIST
40507: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40508: LD_ADDR_VAR 0 16
40512: PUSH
40513: LD_INT 2
40515: NEG
40516: PUSH
40517: LD_INT 3
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: LD_INT 2
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 3
40539: NEG
40540: PUSH
40541: LD_INT 3
40543: NEG
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: LIST
40553: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40554: LD_ADDR_VAR 0 17
40558: PUSH
40559: LD_INT 1
40561: NEG
40562: PUSH
40563: LD_INT 3
40565: NEG
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: LD_INT 0
40573: PUSH
40574: LD_INT 3
40576: NEG
40577: PUSH
40578: EMPTY
40579: LIST
40580: LIST
40581: PUSH
40582: LD_INT 1
40584: PUSH
40585: LD_INT 2
40587: NEG
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: LIST
40597: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40598: LD_ADDR_VAR 0 18
40602: PUSH
40603: LD_INT 2
40605: PUSH
40606: LD_INT 1
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 3
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 3
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: LIST
40638: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40639: LD_ADDR_VAR 0 19
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: LD_INT 2
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 3
40656: PUSH
40657: LD_INT 3
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 2
40666: PUSH
40667: LD_INT 3
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: LIST
40678: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40679: LD_ADDR_VAR 0 20
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 3
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 0
40696: PUSH
40697: LD_INT 3
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 1
40706: NEG
40707: PUSH
40708: LD_INT 2
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: LIST
40719: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40720: LD_ADDR_VAR 0 21
40724: PUSH
40725: LD_INT 2
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 3
40738: NEG
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 3
40749: NEG
40750: PUSH
40751: LD_INT 1
40753: NEG
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: LIST
40763: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40764: LD_ADDR_VAR 0 22
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: LD_INT 3
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 3
40783: NEG
40784: PUSH
40785: LD_INT 2
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: LD_INT 3
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: LIST
40809: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40810: LD_ADDR_VAR 0 23
40814: PUSH
40815: LD_INT 0
40817: PUSH
40818: LD_INT 3
40820: NEG
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 1
40828: NEG
40829: PUSH
40830: LD_INT 4
40832: NEG
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 1
40840: PUSH
40841: LD_INT 3
40843: NEG
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: LIST
40853: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40854: LD_ADDR_VAR 0 24
40858: PUSH
40859: LD_INT 3
40861: PUSH
40862: LD_INT 0
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 3
40871: PUSH
40872: LD_INT 1
40874: NEG
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: LIST
40894: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40895: LD_ADDR_VAR 0 25
40899: PUSH
40900: LD_INT 3
40902: PUSH
40903: LD_INT 3
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: PUSH
40913: LD_INT 3
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: PUSH
40923: LD_INT 4
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: LIST
40934: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40935: LD_ADDR_VAR 0 26
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 3
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: LD_INT 4
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 1
40962: NEG
40963: PUSH
40964: LD_INT 3
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: LIST
40975: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40976: LD_ADDR_VAR 0 27
40980: PUSH
40981: LD_INT 3
40983: NEG
40984: PUSH
40985: LD_INT 0
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 3
40994: NEG
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 4
41005: NEG
41006: PUSH
41007: LD_INT 1
41009: NEG
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: LIST
41019: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41020: LD_ADDR_VAR 0 28
41024: PUSH
41025: LD_INT 3
41027: NEG
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: LD_INT 4
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 4
41051: NEG
41052: PUSH
41053: LD_INT 3
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: LIST
41065: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41066: LD_ADDR_VAR 0 29
41070: PUSH
41071: LD_INT 1
41073: NEG
41074: PUSH
41075: LD_INT 3
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 0
41085: PUSH
41086: LD_INT 3
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: LD_INT 2
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 4
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 4
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 3
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 5
41145: NEG
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 0
41153: PUSH
41154: LD_INT 5
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: LD_INT 4
41167: NEG
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 1
41175: NEG
41176: PUSH
41177: LD_INT 6
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 0
41187: PUSH
41188: LD_INT 6
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: LD_INT 5
41201: NEG
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41221: LD_ADDR_VAR 0 30
41225: PUSH
41226: LD_INT 2
41228: PUSH
41229: LD_INT 1
41231: NEG
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 3
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 4
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 4
41280: PUSH
41281: LD_INT 1
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 4
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 5
41301: PUSH
41302: LD_INT 0
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 5
41311: PUSH
41312: LD_INT 1
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 5
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 6
41332: PUSH
41333: LD_INT 0
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 6
41342: PUSH
41343: LD_INT 1
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41364: LD_ADDR_VAR 0 31
41368: PUSH
41369: LD_INT 3
41371: PUSH
41372: LD_INT 2
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 3
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 2
41391: PUSH
41392: LD_INT 3
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 4
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 4
41411: PUSH
41412: LD_INT 4
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 3
41421: PUSH
41422: LD_INT 4
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 5
41431: PUSH
41432: LD_INT 4
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 5
41441: PUSH
41442: LD_INT 5
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 4
41451: PUSH
41452: LD_INT 5
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 6
41461: PUSH
41462: LD_INT 5
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 6
41471: PUSH
41472: LD_INT 6
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 5
41481: PUSH
41482: LD_INT 6
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41503: LD_ADDR_VAR 0 32
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: LD_INT 3
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 0
41520: PUSH
41521: LD_INT 3
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 1
41530: NEG
41531: PUSH
41532: LD_INT 2
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: LD_INT 4
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 0
41551: PUSH
41552: LD_INT 4
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 1
41561: NEG
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 1
41572: PUSH
41573: LD_INT 5
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 5
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 1
41592: NEG
41593: PUSH
41594: LD_INT 4
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 1
41603: PUSH
41604: LD_INT 6
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 0
41613: PUSH
41614: LD_INT 6
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 1
41623: NEG
41624: PUSH
41625: LD_INT 5
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41646: LD_ADDR_VAR 0 33
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: LD_INT 1
41679: NEG
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 3
41687: NEG
41688: PUSH
41689: LD_INT 1
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 4
41698: NEG
41699: PUSH
41700: LD_INT 0
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 4
41709: NEG
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 4
41721: NEG
41722: PUSH
41723: LD_INT 1
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 5
41732: NEG
41733: PUSH
41734: LD_INT 0
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 5
41743: NEG
41744: PUSH
41745: LD_INT 1
41747: NEG
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: LD_INT 5
41755: NEG
41756: PUSH
41757: LD_INT 1
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 6
41766: NEG
41767: PUSH
41768: LD_INT 0
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 6
41777: NEG
41778: PUSH
41779: LD_INT 1
41781: NEG
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41801: LD_ADDR_VAR 0 34
41805: PUSH
41806: LD_INT 2
41808: NEG
41809: PUSH
41810: LD_INT 3
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: LD_INT 2
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 3
41832: NEG
41833: PUSH
41834: LD_INT 3
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: NEG
41845: PUSH
41846: LD_INT 4
41848: NEG
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 4
41856: NEG
41857: PUSH
41858: LD_INT 3
41860: NEG
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 4
41868: NEG
41869: PUSH
41870: LD_INT 4
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 4
41880: NEG
41881: PUSH
41882: LD_INT 5
41884: NEG
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 5
41892: NEG
41893: PUSH
41894: LD_INT 4
41896: NEG
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 5
41904: NEG
41905: PUSH
41906: LD_INT 5
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 5
41916: NEG
41917: PUSH
41918: LD_INT 6
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 6
41928: NEG
41929: PUSH
41930: LD_INT 5
41932: NEG
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 6
41940: NEG
41941: PUSH
41942: LD_INT 6
41944: NEG
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41964: LD_ADDR_VAR 0 41
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: LD_INT 2
41974: NEG
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 1
41982: NEG
41983: PUSH
41984: LD_INT 3
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: LIST
42007: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42008: LD_ADDR_VAR 0 42
42012: PUSH
42013: LD_INT 2
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 2
42025: PUSH
42026: LD_INT 1
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 3
42036: PUSH
42037: LD_INT 1
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: LIST
42048: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42049: LD_ADDR_VAR 0 43
42053: PUSH
42054: LD_INT 2
42056: PUSH
42057: LD_INT 2
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: PUSH
42067: LD_INT 2
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 2
42076: PUSH
42077: LD_INT 3
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: LIST
42088: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42089: LD_ADDR_VAR 0 44
42093: PUSH
42094: LD_INT 0
42096: PUSH
42097: LD_INT 2
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 1
42106: PUSH
42107: LD_INT 3
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 1
42116: NEG
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: LIST
42129: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42130: LD_ADDR_VAR 0 45
42134: PUSH
42135: LD_INT 2
42137: NEG
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 2
42148: NEG
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 3
42159: NEG
42160: PUSH
42161: LD_INT 1
42163: NEG
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: LIST
42173: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42174: LD_ADDR_VAR 0 46
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 2
42185: NEG
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 2
42193: NEG
42194: PUSH
42195: LD_INT 3
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 3
42205: NEG
42206: PUSH
42207: LD_INT 2
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: LIST
42219: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42220: LD_ADDR_VAR 0 47
42224: PUSH
42225: LD_INT 2
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42253: LD_ADDR_VAR 0 48
42257: PUSH
42258: LD_INT 1
42260: PUSH
42261: LD_INT 2
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 2
42271: PUSH
42272: LD_INT 1
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42284: LD_ADDR_VAR 0 49
42288: PUSH
42289: LD_INT 3
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 3
42301: PUSH
42302: LD_INT 2
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42313: LD_ADDR_VAR 0 50
42317: PUSH
42318: LD_INT 2
42320: PUSH
42321: LD_INT 3
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 1
42330: PUSH
42331: LD_INT 3
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42342: LD_ADDR_VAR 0 51
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 2
42360: NEG
42361: PUSH
42362: LD_INT 1
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42373: LD_ADDR_VAR 0 52
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: LD_INT 2
42396: NEG
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42406: LD_ADDR_VAR 0 53
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 3
42417: NEG
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 0
42425: PUSH
42426: LD_INT 3
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 1
42436: PUSH
42437: LD_INT 2
42439: NEG
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42450: LD_ADDR_VAR 0 54
42454: PUSH
42455: LD_INT 2
42457: PUSH
42458: LD_INT 1
42460: NEG
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 3
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 3
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: LIST
42490: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42491: LD_ADDR_VAR 0 55
42495: PUSH
42496: LD_INT 3
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 3
42508: PUSH
42509: LD_INT 3
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 2
42518: PUSH
42519: LD_INT 3
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42531: LD_ADDR_VAR 0 56
42535: PUSH
42536: LD_INT 1
42538: PUSH
42539: LD_INT 3
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 0
42548: PUSH
42549: LD_INT 3
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: LIST
42571: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42572: LD_ADDR_VAR 0 57
42576: PUSH
42577: LD_INT 2
42579: NEG
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 3
42590: NEG
42591: PUSH
42592: LD_INT 0
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 3
42601: NEG
42602: PUSH
42603: LD_INT 1
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: LIST
42615: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42616: LD_ADDR_VAR 0 58
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 3
42635: NEG
42636: PUSH
42637: LD_INT 2
42639: NEG
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 3
42647: NEG
42648: PUSH
42649: LD_INT 3
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: LIST
42661: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42662: LD_ADDR_VAR 0 59
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: NEG
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 0
42681: PUSH
42682: LD_INT 2
42684: NEG
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: LD_INT 1
42695: NEG
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: LIST
42705: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42706: LD_ADDR_VAR 0 60
42710: PUSH
42711: LD_INT 1
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 2
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 2
42734: PUSH
42735: LD_INT 1
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42747: LD_ADDR_VAR 0 61
42751: PUSH
42752: LD_INT 2
42754: PUSH
42755: LD_INT 1
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 2
42764: PUSH
42765: LD_INT 2
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 1
42774: PUSH
42775: LD_INT 2
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: LIST
42786: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42787: LD_ADDR_VAR 0 62
42791: PUSH
42792: LD_INT 1
42794: PUSH
42795: LD_INT 2
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 0
42804: PUSH
42805: LD_INT 2
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: LIST
42827: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42828: LD_ADDR_VAR 0 63
42832: PUSH
42833: LD_INT 1
42835: NEG
42836: PUSH
42837: LD_INT 1
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 2
42846: NEG
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 2
42857: NEG
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: LIST
42871: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42872: LD_ADDR_VAR 0 64
42876: PUSH
42877: LD_INT 1
42879: NEG
42880: PUSH
42881: LD_INT 2
42883: NEG
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 2
42891: NEG
42892: PUSH
42893: LD_INT 1
42895: NEG
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 2
42907: NEG
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: LIST
42917: ST_TO_ADDR
// end ; 2 :
42918: GO 46184
42920: LD_INT 2
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42928
42926: GO 46183
42928: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42929: LD_ADDR_VAR 0 29
42933: PUSH
42934: LD_INT 4
42936: PUSH
42937: LD_INT 0
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 4
42946: PUSH
42947: LD_INT 1
42949: NEG
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 5
42957: PUSH
42958: LD_INT 0
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 5
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 4
42977: PUSH
42978: LD_INT 1
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 3
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 3
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: LD_INT 2
43011: NEG
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 5
43019: PUSH
43020: LD_INT 2
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 3
43029: PUSH
43030: LD_INT 3
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: PUSH
43040: LD_INT 2
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 4
43049: PUSH
43050: LD_INT 3
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 4
43059: PUSH
43060: LD_INT 4
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 3
43069: PUSH
43070: LD_INT 4
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 3
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: PUSH
43090: LD_INT 2
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 4
43099: PUSH
43100: LD_INT 2
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 2
43109: PUSH
43110: LD_INT 4
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 0
43119: PUSH
43120: LD_INT 4
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: LD_INT 3
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: LD_INT 4
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 5
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: LD_INT 5
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: NEG
43170: PUSH
43171: LD_INT 4
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 1
43180: NEG
43181: PUSH
43182: LD_INT 3
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: PUSH
43192: LD_INT 5
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 2
43201: NEG
43202: PUSH
43203: LD_INT 3
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 3
43212: NEG
43213: PUSH
43214: LD_INT 0
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: NEG
43224: PUSH
43225: LD_INT 1
43227: NEG
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: PUSH
43233: LD_INT 2
43235: NEG
43236: PUSH
43237: LD_INT 0
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 2
43246: NEG
43247: PUSH
43248: LD_INT 1
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 3
43257: NEG
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 4
43268: NEG
43269: PUSH
43270: LD_INT 0
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 4
43279: NEG
43280: PUSH
43281: LD_INT 1
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 4
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 2
43303: NEG
43304: PUSH
43305: LD_INT 2
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 4
43314: NEG
43315: PUSH
43316: LD_INT 4
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 4
43326: NEG
43327: PUSH
43328: LD_INT 5
43330: NEG
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 3
43338: NEG
43339: PUSH
43340: LD_INT 4
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 3
43350: NEG
43351: PUSH
43352: LD_INT 3
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 4
43362: NEG
43363: PUSH
43364: LD_INT 3
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 5
43374: NEG
43375: PUSH
43376: LD_INT 4
43378: NEG
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 5
43386: NEG
43387: PUSH
43388: LD_INT 5
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 3
43398: NEG
43399: PUSH
43400: LD_INT 5
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 5
43410: NEG
43411: PUSH
43412: LD_INT 3
43414: NEG
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: LIST
43428: LIST
43429: LIST
43430: LIST
43431: LIST
43432: LIST
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: LIST
43444: LIST
43445: LIST
43446: LIST
43447: LIST
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: LIST
43465: LIST
43466: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43467: LD_ADDR_VAR 0 30
43471: PUSH
43472: LD_INT 4
43474: PUSH
43475: LD_INT 4
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 4
43484: PUSH
43485: LD_INT 3
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 5
43494: PUSH
43495: LD_INT 4
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 5
43504: PUSH
43505: LD_INT 5
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 5
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 3
43524: PUSH
43525: LD_INT 4
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: LD_INT 3
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 5
43544: PUSH
43545: LD_INT 3
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 3
43554: PUSH
43555: LD_INT 5
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 0
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 0
43574: PUSH
43575: LD_INT 2
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 1
43584: PUSH
43585: LD_INT 3
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 1
43594: PUSH
43595: LD_INT 4
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: LD_INT 4
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 1
43614: NEG
43615: PUSH
43616: LD_INT 3
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: LD_INT 4
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 2
43646: NEG
43647: PUSH
43648: LD_INT 2
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 4
43657: NEG
43658: PUSH
43659: LD_INT 0
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 4
43668: NEG
43669: PUSH
43670: LD_INT 1
43672: NEG
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: LD_INT 3
43680: NEG
43681: PUSH
43682: LD_INT 0
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 3
43691: NEG
43692: PUSH
43693: LD_INT 1
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 4
43702: NEG
43703: PUSH
43704: LD_INT 1
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 5
43713: NEG
43714: PUSH
43715: LD_INT 0
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: LD_INT 5
43724: NEG
43725: PUSH
43726: LD_INT 1
43728: NEG
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 5
43736: NEG
43737: PUSH
43738: LD_INT 2
43740: NEG
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 3
43748: NEG
43749: PUSH
43750: LD_INT 2
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 3
43759: NEG
43760: PUSH
43761: LD_INT 3
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: LD_INT 4
43775: NEG
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 2
43783: NEG
43784: PUSH
43785: LD_INT 3
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 2
43795: NEG
43796: PUSH
43797: LD_INT 2
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 3
43807: NEG
43808: PUSH
43809: LD_INT 2
43811: NEG
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 4
43819: NEG
43820: PUSH
43821: LD_INT 3
43823: NEG
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 4
43831: NEG
43832: PUSH
43833: LD_INT 4
43835: NEG
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 2
43843: NEG
43844: PUSH
43845: LD_INT 4
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 4
43855: NEG
43856: PUSH
43857: LD_INT 2
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 4
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: LD_INT 5
43881: NEG
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: LD_INT 4
43892: NEG
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: PUSH
43901: LD_INT 3
43903: NEG
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: LD_INT 3
43914: NEG
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: LD_INT 4
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 1
43934: NEG
43935: PUSH
43936: LD_INT 5
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 2
43946: PUSH
43947: LD_INT 3
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 2
43957: NEG
43958: PUSH
43959: LD_INT 5
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: LIST
43987: LIST
43988: LIST
43989: LIST
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: LIST
44003: LIST
44004: LIST
44005: LIST
44006: LIST
44007: LIST
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44014: LD_ADDR_VAR 0 31
44018: PUSH
44019: LD_INT 0
44021: PUSH
44022: LD_INT 4
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: LD_INT 3
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 1
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: LD_INT 5
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 0
44061: PUSH
44062: LD_INT 5
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: LD_INT 4
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 1
44082: NEG
44083: PUSH
44084: LD_INT 3
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 2
44093: PUSH
44094: LD_INT 5
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 2
44103: NEG
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 3
44114: NEG
44115: PUSH
44116: LD_INT 0
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PUSH
44123: LD_INT 3
44125: NEG
44126: PUSH
44127: LD_INT 1
44129: NEG
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 2
44137: NEG
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 2
44148: NEG
44149: PUSH
44150: LD_INT 1
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: LD_INT 3
44159: NEG
44160: PUSH
44161: LD_INT 1
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: LD_INT 0
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 4
44181: NEG
44182: PUSH
44183: LD_INT 1
44185: NEG
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: LD_INT 2
44197: NEG
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: NEG
44206: PUSH
44207: LD_INT 2
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 4
44216: NEG
44217: PUSH
44218: LD_INT 4
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 4
44228: NEG
44229: PUSH
44230: LD_INT 5
44232: NEG
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 3
44240: NEG
44241: PUSH
44242: LD_INT 4
44244: NEG
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 3
44252: NEG
44253: PUSH
44254: LD_INT 3
44256: NEG
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 4
44264: NEG
44265: PUSH
44266: LD_INT 3
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 5
44276: NEG
44277: PUSH
44278: LD_INT 4
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 5
44288: NEG
44289: PUSH
44290: LD_INT 5
44292: NEG
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 3
44300: NEG
44301: PUSH
44302: LD_INT 5
44304: NEG
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 5
44312: NEG
44313: PUSH
44314: LD_INT 3
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 0
44324: PUSH
44325: LD_INT 3
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 0
44335: PUSH
44336: LD_INT 4
44338: NEG
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 1
44346: PUSH
44347: LD_INT 3
44349: NEG
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 1
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 3
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 4
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 2
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 2
44414: NEG
44415: PUSH
44416: LD_INT 4
44418: NEG
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: LD_INT 0
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 4
44436: PUSH
44437: LD_INT 1
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 5
44447: PUSH
44448: LD_INT 0
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 5
44457: PUSH
44458: LD_INT 1
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 4
44467: PUSH
44468: LD_INT 1
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 3
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 3
44487: PUSH
44488: LD_INT 1
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 3
44498: PUSH
44499: LD_INT 2
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 5
44509: PUSH
44510: LD_INT 2
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44564: LD_ADDR_VAR 0 32
44568: PUSH
44569: LD_INT 4
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 4
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 3
44594: NEG
44595: PUSH
44596: LD_INT 0
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 3
44605: NEG
44606: PUSH
44607: LD_INT 1
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 4
44616: NEG
44617: PUSH
44618: LD_INT 1
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: LD_INT 0
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 5
44638: NEG
44639: PUSH
44640: LD_INT 1
44642: NEG
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 5
44650: NEG
44651: PUSH
44652: LD_INT 2
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: LD_INT 2
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 3
44673: NEG
44674: PUSH
44675: LD_INT 3
44677: NEG
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 3
44685: NEG
44686: PUSH
44687: LD_INT 4
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 2
44697: NEG
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 2
44709: NEG
44710: PUSH
44711: LD_INT 2
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 3
44721: NEG
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: LD_INT 3
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 4
44745: NEG
44746: PUSH
44747: LD_INT 4
44749: NEG
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 2
44757: NEG
44758: PUSH
44759: LD_INT 4
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 4
44769: NEG
44770: PUSH
44771: LD_INT 2
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 0
44781: PUSH
44782: LD_INT 4
44784: NEG
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 0
44792: PUSH
44793: LD_INT 5
44795: NEG
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: LD_INT 4
44806: NEG
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 1
44814: PUSH
44815: LD_INT 3
44817: NEG
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 3
44828: NEG
44829: PUSH
44830: EMPTY
44831: LIST
44832: LIST
44833: PUSH
44834: LD_INT 1
44836: NEG
44837: PUSH
44838: LD_INT 4
44840: NEG
44841: PUSH
44842: EMPTY
44843: LIST
44844: LIST
44845: PUSH
44846: LD_INT 1
44848: NEG
44849: PUSH
44850: LD_INT 5
44852: NEG
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: LD_INT 2
44860: PUSH
44861: LD_INT 3
44863: NEG
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 2
44871: NEG
44872: PUSH
44873: LD_INT 5
44875: NEG
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 3
44883: PUSH
44884: LD_INT 0
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 1
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 4
44904: PUSH
44905: LD_INT 0
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 4
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 3
44924: PUSH
44925: LD_INT 1
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 2
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 2
44944: PUSH
44945: LD_INT 1
44947: NEG
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 2
44955: PUSH
44956: LD_INT 2
44958: NEG
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 4
44966: PUSH
44967: LD_INT 2
44969: PUSH
44970: EMPTY
44971: LIST
44972: LIST
44973: PUSH
44974: LD_INT 4
44976: PUSH
44977: LD_INT 4
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 4
44986: PUSH
44987: LD_INT 3
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 5
44996: PUSH
44997: LD_INT 4
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: LD_INT 5
45006: PUSH
45007: LD_INT 5
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 4
45016: PUSH
45017: LD_INT 5
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 4
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 3
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 5
45046: PUSH
45047: LD_INT 3
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 5
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45111: LD_ADDR_VAR 0 33
45115: PUSH
45116: LD_INT 4
45118: NEG
45119: PUSH
45120: LD_INT 4
45122: NEG
45123: PUSH
45124: EMPTY
45125: LIST
45126: LIST
45127: PUSH
45128: LD_INT 4
45130: NEG
45131: PUSH
45132: LD_INT 5
45134: NEG
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 3
45142: NEG
45143: PUSH
45144: LD_INT 4
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 3
45154: NEG
45155: PUSH
45156: LD_INT 3
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 4
45166: NEG
45167: PUSH
45168: LD_INT 3
45170: NEG
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 5
45178: NEG
45179: PUSH
45180: LD_INT 4
45182: NEG
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 5
45190: NEG
45191: PUSH
45192: LD_INT 5
45194: NEG
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 3
45202: NEG
45203: PUSH
45204: LD_INT 5
45206: NEG
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 0
45226: PUSH
45227: LD_INT 3
45229: NEG
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 4
45240: NEG
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 1
45248: PUSH
45249: LD_INT 3
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 1
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: LD_INT 2
45273: NEG
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 1
45281: NEG
45282: PUSH
45283: LD_INT 3
45285: NEG
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 1
45293: NEG
45294: PUSH
45295: LD_INT 4
45297: NEG
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 2
45305: PUSH
45306: LD_INT 2
45308: NEG
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 2
45316: NEG
45317: PUSH
45318: LD_INT 4
45320: NEG
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 4
45328: PUSH
45329: LD_INT 0
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 4
45338: PUSH
45339: LD_INT 1
45341: NEG
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 5
45349: PUSH
45350: LD_INT 0
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 5
45359: PUSH
45360: LD_INT 1
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 4
45369: PUSH
45370: LD_INT 1
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 3
45379: PUSH
45380: LD_INT 0
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 3
45389: PUSH
45390: LD_INT 1
45392: NEG
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: LD_INT 3
45400: PUSH
45401: LD_INT 2
45403: NEG
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 5
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: PUSH
45422: LD_INT 3
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: LD_INT 2
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 4
45451: PUSH
45452: LD_INT 4
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: PUSH
45462: LD_INT 4
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 2
45471: PUSH
45472: LD_INT 3
45474: PUSH
45475: EMPTY
45476: LIST
45477: LIST
45478: PUSH
45479: LD_INT 2
45481: PUSH
45482: LD_INT 2
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: PUSH
45489: LD_INT 4
45491: PUSH
45492: LD_INT 2
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 2
45501: PUSH
45502: LD_INT 4
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 4
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 0
45521: PUSH
45522: LD_INT 3
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 1
45531: PUSH
45532: LD_INT 4
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 1
45541: PUSH
45542: LD_INT 5
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 0
45551: PUSH
45552: LD_INT 5
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 1
45561: NEG
45562: PUSH
45563: LD_INT 4
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 1
45572: NEG
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 2
45583: PUSH
45584: LD_INT 5
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 2
45593: NEG
45594: PUSH
45595: LD_INT 3
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45649: LD_ADDR_VAR 0 34
45653: PUSH
45654: LD_INT 0
45656: PUSH
45657: LD_INT 4
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: LD_INT 5
45670: NEG
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 1
45678: PUSH
45679: LD_INT 4
45681: NEG
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 1
45689: PUSH
45690: LD_INT 3
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 0
45700: PUSH
45701: LD_INT 3
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 1
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 1
45723: NEG
45724: PUSH
45725: LD_INT 5
45727: NEG
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 2
45735: PUSH
45736: LD_INT 3
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 2
45746: NEG
45747: PUSH
45748: LD_INT 5
45750: NEG
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 3
45758: PUSH
45759: LD_INT 0
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 1
45771: NEG
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 4
45779: PUSH
45780: LD_INT 0
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 4
45789: PUSH
45790: LD_INT 1
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 3
45799: PUSH
45800: LD_INT 1
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: LD_INT 0
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 2
45819: PUSH
45820: LD_INT 1
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 2
45830: PUSH
45831: LD_INT 2
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: LD_INT 2
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: LD_INT 4
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 4
45861: PUSH
45862: LD_INT 3
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 5
45871: PUSH
45872: LD_INT 4
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 5
45881: PUSH
45882: LD_INT 5
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_INT 4
45891: PUSH
45892: LD_INT 5
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 3
45901: PUSH
45902: LD_INT 4
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 3
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 5
45921: PUSH
45922: LD_INT 3
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 3
45931: PUSH
45932: LD_INT 5
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 0
45941: PUSH
45942: LD_INT 3
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 0
45951: PUSH
45952: LD_INT 2
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 1
45961: PUSH
45962: LD_INT 3
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 1
45971: PUSH
45972: LD_INT 4
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 0
45981: PUSH
45982: LD_INT 4
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 1
45991: NEG
45992: PUSH
45993: LD_INT 3
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 1
46002: NEG
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 2
46013: PUSH
46014: LD_INT 4
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: LD_INT 2
46023: NEG
46024: PUSH
46025: LD_INT 2
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 4
46034: NEG
46035: PUSH
46036: LD_INT 0
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 4
46045: NEG
46046: PUSH
46047: LD_INT 1
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 3
46057: NEG
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: NEG
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: LD_INT 1
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: PUSH
46088: LD_INT 5
46090: NEG
46091: PUSH
46092: LD_INT 0
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 5
46101: NEG
46102: PUSH
46103: LD_INT 1
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 5
46113: NEG
46114: PUSH
46115: LD_INT 2
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 3
46125: NEG
46126: PUSH
46127: LD_INT 2
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: ST_TO_ADDR
// end ; end ;
46181: GO 46184
46183: POP
// case btype of b_depot , b_warehouse :
46184: LD_VAR 0 1
46188: PUSH
46189: LD_INT 0
46191: DOUBLE
46192: EQUAL
46193: IFTRUE 46203
46195: LD_INT 1
46197: DOUBLE
46198: EQUAL
46199: IFTRUE 46203
46201: GO 46404
46203: POP
// case nation of nation_american :
46204: LD_VAR 0 5
46208: PUSH
46209: LD_INT 1
46211: DOUBLE
46212: EQUAL
46213: IFTRUE 46217
46215: GO 46273
46217: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46218: LD_ADDR_VAR 0 9
46222: PUSH
46223: LD_VAR 0 11
46227: PUSH
46228: LD_VAR 0 12
46232: PUSH
46233: LD_VAR 0 13
46237: PUSH
46238: LD_VAR 0 14
46242: PUSH
46243: LD_VAR 0 15
46247: PUSH
46248: LD_VAR 0 16
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: PUSH
46261: LD_VAR 0 4
46265: PUSH
46266: LD_INT 1
46268: PLUS
46269: ARRAY
46270: ST_TO_ADDR
46271: GO 46402
46273: LD_INT 2
46275: DOUBLE
46276: EQUAL
46277: IFTRUE 46281
46279: GO 46337
46281: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46282: LD_ADDR_VAR 0 9
46286: PUSH
46287: LD_VAR 0 17
46291: PUSH
46292: LD_VAR 0 18
46296: PUSH
46297: LD_VAR 0 19
46301: PUSH
46302: LD_VAR 0 20
46306: PUSH
46307: LD_VAR 0 21
46311: PUSH
46312: LD_VAR 0 22
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: PUSH
46325: LD_VAR 0 4
46329: PUSH
46330: LD_INT 1
46332: PLUS
46333: ARRAY
46334: ST_TO_ADDR
46335: GO 46402
46337: LD_INT 3
46339: DOUBLE
46340: EQUAL
46341: IFTRUE 46345
46343: GO 46401
46345: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46346: LD_ADDR_VAR 0 9
46350: PUSH
46351: LD_VAR 0 23
46355: PUSH
46356: LD_VAR 0 24
46360: PUSH
46361: LD_VAR 0 25
46365: PUSH
46366: LD_VAR 0 26
46370: PUSH
46371: LD_VAR 0 27
46375: PUSH
46376: LD_VAR 0 28
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: PUSH
46389: LD_VAR 0 4
46393: PUSH
46394: LD_INT 1
46396: PLUS
46397: ARRAY
46398: ST_TO_ADDR
46399: GO 46402
46401: POP
46402: GO 46951
46404: LD_INT 2
46406: DOUBLE
46407: EQUAL
46408: IFTRUE 46418
46410: LD_INT 3
46412: DOUBLE
46413: EQUAL
46414: IFTRUE 46418
46416: GO 46474
46418: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46419: LD_ADDR_VAR 0 9
46423: PUSH
46424: LD_VAR 0 29
46428: PUSH
46429: LD_VAR 0 30
46433: PUSH
46434: LD_VAR 0 31
46438: PUSH
46439: LD_VAR 0 32
46443: PUSH
46444: LD_VAR 0 33
46448: PUSH
46449: LD_VAR 0 34
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: PUSH
46462: LD_VAR 0 4
46466: PUSH
46467: LD_INT 1
46469: PLUS
46470: ARRAY
46471: ST_TO_ADDR
46472: GO 46951
46474: LD_INT 16
46476: DOUBLE
46477: EQUAL
46478: IFTRUE 46530
46480: LD_INT 17
46482: DOUBLE
46483: EQUAL
46484: IFTRUE 46530
46486: LD_INT 18
46488: DOUBLE
46489: EQUAL
46490: IFTRUE 46530
46492: LD_INT 19
46494: DOUBLE
46495: EQUAL
46496: IFTRUE 46530
46498: LD_INT 20
46500: DOUBLE
46501: EQUAL
46502: IFTRUE 46530
46504: LD_INT 21
46506: DOUBLE
46507: EQUAL
46508: IFTRUE 46530
46510: LD_INT 23
46512: DOUBLE
46513: EQUAL
46514: IFTRUE 46530
46516: LD_INT 24
46518: DOUBLE
46519: EQUAL
46520: IFTRUE 46530
46522: LD_INT 25
46524: DOUBLE
46525: EQUAL
46526: IFTRUE 46530
46528: GO 46586
46530: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46531: LD_ADDR_VAR 0 9
46535: PUSH
46536: LD_VAR 0 35
46540: PUSH
46541: LD_VAR 0 36
46545: PUSH
46546: LD_VAR 0 37
46550: PUSH
46551: LD_VAR 0 38
46555: PUSH
46556: LD_VAR 0 39
46560: PUSH
46561: LD_VAR 0 40
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: PUSH
46574: LD_VAR 0 4
46578: PUSH
46579: LD_INT 1
46581: PLUS
46582: ARRAY
46583: ST_TO_ADDR
46584: GO 46951
46586: LD_INT 6
46588: DOUBLE
46589: EQUAL
46590: IFTRUE 46642
46592: LD_INT 7
46594: DOUBLE
46595: EQUAL
46596: IFTRUE 46642
46598: LD_INT 8
46600: DOUBLE
46601: EQUAL
46602: IFTRUE 46642
46604: LD_INT 13
46606: DOUBLE
46607: EQUAL
46608: IFTRUE 46642
46610: LD_INT 12
46612: DOUBLE
46613: EQUAL
46614: IFTRUE 46642
46616: LD_INT 15
46618: DOUBLE
46619: EQUAL
46620: IFTRUE 46642
46622: LD_INT 11
46624: DOUBLE
46625: EQUAL
46626: IFTRUE 46642
46628: LD_INT 14
46630: DOUBLE
46631: EQUAL
46632: IFTRUE 46642
46634: LD_INT 10
46636: DOUBLE
46637: EQUAL
46638: IFTRUE 46642
46640: GO 46698
46642: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46643: LD_ADDR_VAR 0 9
46647: PUSH
46648: LD_VAR 0 41
46652: PUSH
46653: LD_VAR 0 42
46657: PUSH
46658: LD_VAR 0 43
46662: PUSH
46663: LD_VAR 0 44
46667: PUSH
46668: LD_VAR 0 45
46672: PUSH
46673: LD_VAR 0 46
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: PUSH
46686: LD_VAR 0 4
46690: PUSH
46691: LD_INT 1
46693: PLUS
46694: ARRAY
46695: ST_TO_ADDR
46696: GO 46951
46698: LD_INT 36
46700: DOUBLE
46701: EQUAL
46702: IFTRUE 46706
46704: GO 46762
46706: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46707: LD_ADDR_VAR 0 9
46711: PUSH
46712: LD_VAR 0 47
46716: PUSH
46717: LD_VAR 0 48
46721: PUSH
46722: LD_VAR 0 49
46726: PUSH
46727: LD_VAR 0 50
46731: PUSH
46732: LD_VAR 0 51
46736: PUSH
46737: LD_VAR 0 52
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: PUSH
46750: LD_VAR 0 4
46754: PUSH
46755: LD_INT 1
46757: PLUS
46758: ARRAY
46759: ST_TO_ADDR
46760: GO 46951
46762: LD_INT 4
46764: DOUBLE
46765: EQUAL
46766: IFTRUE 46788
46768: LD_INT 5
46770: DOUBLE
46771: EQUAL
46772: IFTRUE 46788
46774: LD_INT 34
46776: DOUBLE
46777: EQUAL
46778: IFTRUE 46788
46780: LD_INT 37
46782: DOUBLE
46783: EQUAL
46784: IFTRUE 46788
46786: GO 46844
46788: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46789: LD_ADDR_VAR 0 9
46793: PUSH
46794: LD_VAR 0 53
46798: PUSH
46799: LD_VAR 0 54
46803: PUSH
46804: LD_VAR 0 55
46808: PUSH
46809: LD_VAR 0 56
46813: PUSH
46814: LD_VAR 0 57
46818: PUSH
46819: LD_VAR 0 58
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: PUSH
46832: LD_VAR 0 4
46836: PUSH
46837: LD_INT 1
46839: PLUS
46840: ARRAY
46841: ST_TO_ADDR
46842: GO 46951
46844: LD_INT 31
46846: DOUBLE
46847: EQUAL
46848: IFTRUE 46894
46850: LD_INT 32
46852: DOUBLE
46853: EQUAL
46854: IFTRUE 46894
46856: LD_INT 33
46858: DOUBLE
46859: EQUAL
46860: IFTRUE 46894
46862: LD_INT 27
46864: DOUBLE
46865: EQUAL
46866: IFTRUE 46894
46868: LD_INT 26
46870: DOUBLE
46871: EQUAL
46872: IFTRUE 46894
46874: LD_INT 28
46876: DOUBLE
46877: EQUAL
46878: IFTRUE 46894
46880: LD_INT 29
46882: DOUBLE
46883: EQUAL
46884: IFTRUE 46894
46886: LD_INT 30
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 46950
46894: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
46895: LD_ADDR_VAR 0 9
46899: PUSH
46900: LD_VAR 0 59
46904: PUSH
46905: LD_VAR 0 60
46909: PUSH
46910: LD_VAR 0 61
46914: PUSH
46915: LD_VAR 0 62
46919: PUSH
46920: LD_VAR 0 63
46924: PUSH
46925: LD_VAR 0 64
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_INT 1
46945: PLUS
46946: ARRAY
46947: ST_TO_ADDR
46948: GO 46951
46950: POP
// temp_list2 = [ ] ;
46951: LD_ADDR_VAR 0 10
46955: PUSH
46956: EMPTY
46957: ST_TO_ADDR
// for i in temp_list do
46958: LD_ADDR_VAR 0 8
46962: PUSH
46963: LD_VAR 0 9
46967: PUSH
46968: FOR_IN
46969: IFFALSE 47021
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46971: LD_ADDR_VAR 0 10
46975: PUSH
46976: LD_VAR 0 10
46980: PUSH
46981: LD_VAR 0 8
46985: PUSH
46986: LD_INT 1
46988: ARRAY
46989: PUSH
46990: LD_VAR 0 2
46994: PLUS
46995: PUSH
46996: LD_VAR 0 8
47000: PUSH
47001: LD_INT 2
47003: ARRAY
47004: PUSH
47005: LD_VAR 0 3
47009: PLUS
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: EMPTY
47016: LIST
47017: ADD
47018: ST_TO_ADDR
47019: GO 46968
47021: POP
47022: POP
// result = temp_list2 ;
47023: LD_ADDR_VAR 0 7
47027: PUSH
47028: LD_VAR 0 10
47032: ST_TO_ADDR
// end ;
47033: LD_VAR 0 7
47037: RET
// export function EnemyInRange ( unit , dist ) ; begin
47038: LD_INT 0
47040: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47041: LD_ADDR_VAR 0 3
47045: PUSH
47046: LD_VAR 0 1
47050: PPUSH
47051: CALL_OW 255
47055: PPUSH
47056: LD_VAR 0 1
47060: PPUSH
47061: CALL_OW 250
47065: PPUSH
47066: LD_VAR 0 1
47070: PPUSH
47071: CALL_OW 251
47075: PPUSH
47076: LD_VAR 0 2
47080: PPUSH
47081: CALL 21166 0 4
47085: PUSH
47086: LD_INT 4
47088: ARRAY
47089: ST_TO_ADDR
// end ;
47090: LD_VAR 0 3
47094: RET
// export function PlayerSeeMe ( unit ) ; begin
47095: LD_INT 0
47097: PPUSH
// result := See ( your_side , unit ) ;
47098: LD_ADDR_VAR 0 2
47102: PUSH
47103: LD_OWVAR 2
47107: PPUSH
47108: LD_VAR 0 1
47112: PPUSH
47113: CALL_OW 292
47117: ST_TO_ADDR
// end ;
47118: LD_VAR 0 2
47122: RET
// export function ReverseDir ( unit ) ; begin
47123: LD_INT 0
47125: PPUSH
// if not unit then
47126: LD_VAR 0 1
47130: NOT
47131: IFFALSE 47135
// exit ;
47133: GO 47181
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47135: LD_ADDR_VAR 0 2
47139: PUSH
47140: LD_INT 3
47142: PUSH
47143: LD_INT 4
47145: PUSH
47146: LD_INT 5
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: LD_INT 1
47154: PUSH
47155: LD_INT 2
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: PUSH
47166: LD_VAR 0 1
47170: PPUSH
47171: CALL_OW 254
47175: PUSH
47176: LD_INT 1
47178: PLUS
47179: ARRAY
47180: ST_TO_ADDR
// end ;
47181: LD_VAR 0 2
47185: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47186: LD_INT 0
47188: PPUSH
47189: PPUSH
47190: PPUSH
47191: PPUSH
47192: PPUSH
// if not hexes then
47193: LD_VAR 0 2
47197: NOT
47198: IFFALSE 47202
// exit ;
47200: GO 47350
// dist := 9999 ;
47202: LD_ADDR_VAR 0 5
47206: PUSH
47207: LD_INT 9999
47209: ST_TO_ADDR
// for i = 1 to hexes do
47210: LD_ADDR_VAR 0 4
47214: PUSH
47215: DOUBLE
47216: LD_INT 1
47218: DEC
47219: ST_TO_ADDR
47220: LD_VAR 0 2
47224: PUSH
47225: FOR_TO
47226: IFFALSE 47338
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47228: LD_VAR 0 1
47232: PPUSH
47233: LD_VAR 0 2
47237: PUSH
47238: LD_VAR 0 4
47242: ARRAY
47243: PUSH
47244: LD_INT 1
47246: ARRAY
47247: PPUSH
47248: LD_VAR 0 2
47252: PUSH
47253: LD_VAR 0 4
47257: ARRAY
47258: PUSH
47259: LD_INT 2
47261: ARRAY
47262: PPUSH
47263: CALL_OW 297
47267: PUSH
47268: LD_VAR 0 5
47272: LESS
47273: IFFALSE 47336
// begin hex := hexes [ i ] ;
47275: LD_ADDR_VAR 0 7
47279: PUSH
47280: LD_VAR 0 2
47284: PUSH
47285: LD_VAR 0 4
47289: ARRAY
47290: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47291: LD_ADDR_VAR 0 5
47295: PUSH
47296: LD_VAR 0 1
47300: PPUSH
47301: LD_VAR 0 2
47305: PUSH
47306: LD_VAR 0 4
47310: ARRAY
47311: PUSH
47312: LD_INT 1
47314: ARRAY
47315: PPUSH
47316: LD_VAR 0 2
47320: PUSH
47321: LD_VAR 0 4
47325: ARRAY
47326: PUSH
47327: LD_INT 2
47329: ARRAY
47330: PPUSH
47331: CALL_OW 297
47335: ST_TO_ADDR
// end ; end ;
47336: GO 47225
47338: POP
47339: POP
// result := hex ;
47340: LD_ADDR_VAR 0 3
47344: PUSH
47345: LD_VAR 0 7
47349: ST_TO_ADDR
// end ;
47350: LD_VAR 0 3
47354: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47355: LD_INT 0
47357: PPUSH
47358: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47359: LD_VAR 0 1
47363: NOT
47364: PUSH
47365: LD_VAR 0 1
47369: PUSH
47370: LD_INT 21
47372: PUSH
47373: LD_INT 2
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 23
47382: PUSH
47383: LD_INT 2
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: PPUSH
47394: CALL_OW 69
47398: IN
47399: NOT
47400: OR
47401: IFFALSE 47405
// exit ;
47403: GO 47452
// for i = 1 to 3 do
47405: LD_ADDR_VAR 0 3
47409: PUSH
47410: DOUBLE
47411: LD_INT 1
47413: DEC
47414: ST_TO_ADDR
47415: LD_INT 3
47417: PUSH
47418: FOR_TO
47419: IFFALSE 47450
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47421: LD_VAR 0 1
47425: PPUSH
47426: CALL_OW 250
47430: PPUSH
47431: LD_VAR 0 1
47435: PPUSH
47436: CALL_OW 251
47440: PPUSH
47441: LD_INT 1
47443: PPUSH
47444: CALL_OW 453
47448: GO 47418
47450: POP
47451: POP
// end ;
47452: LD_VAR 0 2
47456: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47457: LD_INT 0
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
47463: PPUSH
47464: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47465: LD_VAR 0 1
47469: NOT
47470: PUSH
47471: LD_VAR 0 2
47475: NOT
47476: OR
47477: PUSH
47478: LD_VAR 0 1
47482: PPUSH
47483: CALL_OW 314
47487: OR
47488: IFFALSE 47492
// exit ;
47490: GO 47933
// x := GetX ( enemy_unit ) ;
47492: LD_ADDR_VAR 0 7
47496: PUSH
47497: LD_VAR 0 2
47501: PPUSH
47502: CALL_OW 250
47506: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47507: LD_ADDR_VAR 0 8
47511: PUSH
47512: LD_VAR 0 2
47516: PPUSH
47517: CALL_OW 251
47521: ST_TO_ADDR
// if not x or not y then
47522: LD_VAR 0 7
47526: NOT
47527: PUSH
47528: LD_VAR 0 8
47532: NOT
47533: OR
47534: IFFALSE 47538
// exit ;
47536: GO 47933
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47538: LD_ADDR_VAR 0 6
47542: PUSH
47543: LD_VAR 0 7
47547: PPUSH
47548: LD_INT 0
47550: PPUSH
47551: LD_INT 4
47553: PPUSH
47554: CALL_OW 272
47558: PUSH
47559: LD_VAR 0 8
47563: PPUSH
47564: LD_INT 0
47566: PPUSH
47567: LD_INT 4
47569: PPUSH
47570: CALL_OW 273
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: LD_VAR 0 7
47583: PPUSH
47584: LD_INT 1
47586: PPUSH
47587: LD_INT 4
47589: PPUSH
47590: CALL_OW 272
47594: PUSH
47595: LD_VAR 0 8
47599: PPUSH
47600: LD_INT 1
47602: PPUSH
47603: LD_INT 4
47605: PPUSH
47606: CALL_OW 273
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: PUSH
47615: LD_VAR 0 7
47619: PPUSH
47620: LD_INT 2
47622: PPUSH
47623: LD_INT 4
47625: PPUSH
47626: CALL_OW 272
47630: PUSH
47631: LD_VAR 0 8
47635: PPUSH
47636: LD_INT 2
47638: PPUSH
47639: LD_INT 4
47641: PPUSH
47642: CALL_OW 273
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_VAR 0 7
47655: PPUSH
47656: LD_INT 3
47658: PPUSH
47659: LD_INT 4
47661: PPUSH
47662: CALL_OW 272
47666: PUSH
47667: LD_VAR 0 8
47671: PPUSH
47672: LD_INT 3
47674: PPUSH
47675: LD_INT 4
47677: PPUSH
47678: CALL_OW 273
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: PUSH
47687: LD_VAR 0 7
47691: PPUSH
47692: LD_INT 4
47694: PPUSH
47695: LD_INT 4
47697: PPUSH
47698: CALL_OW 272
47702: PUSH
47703: LD_VAR 0 8
47707: PPUSH
47708: LD_INT 4
47710: PPUSH
47711: LD_INT 4
47713: PPUSH
47714: CALL_OW 273
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_VAR 0 7
47727: PPUSH
47728: LD_INT 5
47730: PPUSH
47731: LD_INT 4
47733: PPUSH
47734: CALL_OW 272
47738: PUSH
47739: LD_VAR 0 8
47743: PPUSH
47744: LD_INT 5
47746: PPUSH
47747: LD_INT 4
47749: PPUSH
47750: CALL_OW 273
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: ST_TO_ADDR
// for i = tmp downto 1 do
47767: LD_ADDR_VAR 0 4
47771: PUSH
47772: DOUBLE
47773: LD_VAR 0 6
47777: INC
47778: ST_TO_ADDR
47779: LD_INT 1
47781: PUSH
47782: FOR_DOWNTO
47783: IFFALSE 47884
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47785: LD_VAR 0 6
47789: PUSH
47790: LD_VAR 0 4
47794: ARRAY
47795: PUSH
47796: LD_INT 1
47798: ARRAY
47799: PPUSH
47800: LD_VAR 0 6
47804: PUSH
47805: LD_VAR 0 4
47809: ARRAY
47810: PUSH
47811: LD_INT 2
47813: ARRAY
47814: PPUSH
47815: CALL_OW 488
47819: NOT
47820: PUSH
47821: LD_VAR 0 6
47825: PUSH
47826: LD_VAR 0 4
47830: ARRAY
47831: PUSH
47832: LD_INT 1
47834: ARRAY
47835: PPUSH
47836: LD_VAR 0 6
47840: PUSH
47841: LD_VAR 0 4
47845: ARRAY
47846: PUSH
47847: LD_INT 2
47849: ARRAY
47850: PPUSH
47851: CALL_OW 428
47855: PUSH
47856: LD_INT 0
47858: NONEQUAL
47859: OR
47860: IFFALSE 47882
// tmp := Delete ( tmp , i ) ;
47862: LD_ADDR_VAR 0 6
47866: PUSH
47867: LD_VAR 0 6
47871: PPUSH
47872: LD_VAR 0 4
47876: PPUSH
47877: CALL_OW 3
47881: ST_TO_ADDR
47882: GO 47782
47884: POP
47885: POP
// j := GetClosestHex ( unit , tmp ) ;
47886: LD_ADDR_VAR 0 5
47890: PUSH
47891: LD_VAR 0 1
47895: PPUSH
47896: LD_VAR 0 6
47900: PPUSH
47901: CALL 47186 0 2
47905: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47906: LD_VAR 0 1
47910: PPUSH
47911: LD_VAR 0 5
47915: PUSH
47916: LD_INT 1
47918: ARRAY
47919: PPUSH
47920: LD_VAR 0 5
47924: PUSH
47925: LD_INT 2
47927: ARRAY
47928: PPUSH
47929: CALL_OW 111
// end ;
47933: LD_VAR 0 3
47937: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47938: LD_INT 0
47940: PPUSH
47941: PPUSH
47942: PPUSH
// uc_side = 0 ;
47943: LD_ADDR_OWVAR 20
47947: PUSH
47948: LD_INT 0
47950: ST_TO_ADDR
// uc_nation = 0 ;
47951: LD_ADDR_OWVAR 21
47955: PUSH
47956: LD_INT 0
47958: ST_TO_ADDR
// InitHc ;
47959: CALL_OW 19
// InitVc ;
47963: CALL_OW 20
// if mastodonts then
47967: LD_VAR 0 6
47971: IFFALSE 48038
// for i = 1 to mastodonts do
47973: LD_ADDR_VAR 0 11
47977: PUSH
47978: DOUBLE
47979: LD_INT 1
47981: DEC
47982: ST_TO_ADDR
47983: LD_VAR 0 6
47987: PUSH
47988: FOR_TO
47989: IFFALSE 48036
// begin vc_chassis := 31 ;
47991: LD_ADDR_OWVAR 37
47995: PUSH
47996: LD_INT 31
47998: ST_TO_ADDR
// vc_control := control_rider ;
47999: LD_ADDR_OWVAR 38
48003: PUSH
48004: LD_INT 4
48006: ST_TO_ADDR
// animal := CreateVehicle ;
48007: LD_ADDR_VAR 0 12
48011: PUSH
48012: CALL_OW 45
48016: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48017: LD_VAR 0 12
48021: PPUSH
48022: LD_VAR 0 8
48026: PPUSH
48027: LD_INT 0
48029: PPUSH
48030: CALL 54744 0 3
// end ;
48034: GO 47988
48036: POP
48037: POP
// if horses then
48038: LD_VAR 0 5
48042: IFFALSE 48109
// for i = 1 to horses do
48044: LD_ADDR_VAR 0 11
48048: PUSH
48049: DOUBLE
48050: LD_INT 1
48052: DEC
48053: ST_TO_ADDR
48054: LD_VAR 0 5
48058: PUSH
48059: FOR_TO
48060: IFFALSE 48107
// begin hc_class := 21 ;
48062: LD_ADDR_OWVAR 28
48066: PUSH
48067: LD_INT 21
48069: ST_TO_ADDR
// hc_gallery :=  ;
48070: LD_ADDR_OWVAR 33
48074: PUSH
48075: LD_STRING 
48077: ST_TO_ADDR
// animal := CreateHuman ;
48078: LD_ADDR_VAR 0 12
48082: PUSH
48083: CALL_OW 44
48087: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48088: LD_VAR 0 12
48092: PPUSH
48093: LD_VAR 0 8
48097: PPUSH
48098: LD_INT 0
48100: PPUSH
48101: CALL 54744 0 3
// end ;
48105: GO 48059
48107: POP
48108: POP
// if birds then
48109: LD_VAR 0 1
48113: IFFALSE 48180
// for i = 1 to birds do
48115: LD_ADDR_VAR 0 11
48119: PUSH
48120: DOUBLE
48121: LD_INT 1
48123: DEC
48124: ST_TO_ADDR
48125: LD_VAR 0 1
48129: PUSH
48130: FOR_TO
48131: IFFALSE 48178
// begin hc_class = 18 ;
48133: LD_ADDR_OWVAR 28
48137: PUSH
48138: LD_INT 18
48140: ST_TO_ADDR
// hc_gallery =  ;
48141: LD_ADDR_OWVAR 33
48145: PUSH
48146: LD_STRING 
48148: ST_TO_ADDR
// animal := CreateHuman ;
48149: LD_ADDR_VAR 0 12
48153: PUSH
48154: CALL_OW 44
48158: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48159: LD_VAR 0 12
48163: PPUSH
48164: LD_VAR 0 8
48168: PPUSH
48169: LD_INT 0
48171: PPUSH
48172: CALL 54744 0 3
// end ;
48176: GO 48130
48178: POP
48179: POP
// if tigers then
48180: LD_VAR 0 2
48184: IFFALSE 48268
// for i = 1 to tigers do
48186: LD_ADDR_VAR 0 11
48190: PUSH
48191: DOUBLE
48192: LD_INT 1
48194: DEC
48195: ST_TO_ADDR
48196: LD_VAR 0 2
48200: PUSH
48201: FOR_TO
48202: IFFALSE 48266
// begin hc_class = class_tiger ;
48204: LD_ADDR_OWVAR 28
48208: PUSH
48209: LD_INT 14
48211: ST_TO_ADDR
// hc_gallery =  ;
48212: LD_ADDR_OWVAR 33
48216: PUSH
48217: LD_STRING 
48219: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48220: LD_ADDR_OWVAR 35
48224: PUSH
48225: LD_INT 7
48227: NEG
48228: PPUSH
48229: LD_INT 7
48231: PPUSH
48232: CALL_OW 12
48236: ST_TO_ADDR
// animal := CreateHuman ;
48237: LD_ADDR_VAR 0 12
48241: PUSH
48242: CALL_OW 44
48246: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48247: LD_VAR 0 12
48251: PPUSH
48252: LD_VAR 0 8
48256: PPUSH
48257: LD_INT 0
48259: PPUSH
48260: CALL 54744 0 3
// end ;
48264: GO 48201
48266: POP
48267: POP
// if apemans then
48268: LD_VAR 0 3
48272: IFFALSE 48395
// for i = 1 to apemans do
48274: LD_ADDR_VAR 0 11
48278: PUSH
48279: DOUBLE
48280: LD_INT 1
48282: DEC
48283: ST_TO_ADDR
48284: LD_VAR 0 3
48288: PUSH
48289: FOR_TO
48290: IFFALSE 48393
// begin hc_class = class_apeman ;
48292: LD_ADDR_OWVAR 28
48296: PUSH
48297: LD_INT 12
48299: ST_TO_ADDR
// hc_gallery =  ;
48300: LD_ADDR_OWVAR 33
48304: PUSH
48305: LD_STRING 
48307: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48308: LD_ADDR_OWVAR 35
48312: PUSH
48313: LD_INT 5
48315: NEG
48316: PPUSH
48317: LD_INT 5
48319: PPUSH
48320: CALL_OW 12
48324: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48325: LD_ADDR_OWVAR 31
48329: PUSH
48330: LD_INT 1
48332: PPUSH
48333: LD_INT 3
48335: PPUSH
48336: CALL_OW 12
48340: PUSH
48341: LD_INT 1
48343: PPUSH
48344: LD_INT 3
48346: PPUSH
48347: CALL_OW 12
48351: PUSH
48352: LD_INT 0
48354: PUSH
48355: LD_INT 0
48357: PUSH
48358: EMPTY
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: ST_TO_ADDR
// animal := CreateHuman ;
48364: LD_ADDR_VAR 0 12
48368: PUSH
48369: CALL_OW 44
48373: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48374: LD_VAR 0 12
48378: PPUSH
48379: LD_VAR 0 8
48383: PPUSH
48384: LD_INT 0
48386: PPUSH
48387: CALL 54744 0 3
// end ;
48391: GO 48289
48393: POP
48394: POP
// if enchidnas then
48395: LD_VAR 0 4
48399: IFFALSE 48466
// for i = 1 to enchidnas do
48401: LD_ADDR_VAR 0 11
48405: PUSH
48406: DOUBLE
48407: LD_INT 1
48409: DEC
48410: ST_TO_ADDR
48411: LD_VAR 0 4
48415: PUSH
48416: FOR_TO
48417: IFFALSE 48464
// begin hc_class = 13 ;
48419: LD_ADDR_OWVAR 28
48423: PUSH
48424: LD_INT 13
48426: ST_TO_ADDR
// hc_gallery =  ;
48427: LD_ADDR_OWVAR 33
48431: PUSH
48432: LD_STRING 
48434: ST_TO_ADDR
// animal := CreateHuman ;
48435: LD_ADDR_VAR 0 12
48439: PUSH
48440: CALL_OW 44
48444: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48445: LD_VAR 0 12
48449: PPUSH
48450: LD_VAR 0 8
48454: PPUSH
48455: LD_INT 0
48457: PPUSH
48458: CALL 54744 0 3
// end ;
48462: GO 48416
48464: POP
48465: POP
// if fishes then
48466: LD_VAR 0 7
48470: IFFALSE 48537
// for i = 1 to fishes do
48472: LD_ADDR_VAR 0 11
48476: PUSH
48477: DOUBLE
48478: LD_INT 1
48480: DEC
48481: ST_TO_ADDR
48482: LD_VAR 0 7
48486: PUSH
48487: FOR_TO
48488: IFFALSE 48535
// begin hc_class = 20 ;
48490: LD_ADDR_OWVAR 28
48494: PUSH
48495: LD_INT 20
48497: ST_TO_ADDR
// hc_gallery =  ;
48498: LD_ADDR_OWVAR 33
48502: PUSH
48503: LD_STRING 
48505: ST_TO_ADDR
// animal := CreateHuman ;
48506: LD_ADDR_VAR 0 12
48510: PUSH
48511: CALL_OW 44
48515: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48516: LD_VAR 0 12
48520: PPUSH
48521: LD_VAR 0 9
48525: PPUSH
48526: LD_INT 0
48528: PPUSH
48529: CALL 54744 0 3
// end ;
48533: GO 48487
48535: POP
48536: POP
// end ;
48537: LD_VAR 0 10
48541: RET
// export function WantHeal ( sci , unit ) ; begin
48542: LD_INT 0
48544: PPUSH
// if GetTaskList ( sci ) > 0 then
48545: LD_VAR 0 1
48549: PPUSH
48550: CALL_OW 437
48554: PUSH
48555: LD_INT 0
48557: GREATER
48558: IFFALSE 48628
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48560: LD_VAR 0 1
48564: PPUSH
48565: CALL_OW 437
48569: PUSH
48570: LD_INT 1
48572: ARRAY
48573: PUSH
48574: LD_INT 1
48576: ARRAY
48577: PUSH
48578: LD_STRING l
48580: EQUAL
48581: PUSH
48582: LD_VAR 0 1
48586: PPUSH
48587: CALL_OW 437
48591: PUSH
48592: LD_INT 1
48594: ARRAY
48595: PUSH
48596: LD_INT 4
48598: ARRAY
48599: PUSH
48600: LD_VAR 0 2
48604: EQUAL
48605: AND
48606: IFFALSE 48618
// result := true else
48608: LD_ADDR_VAR 0 3
48612: PUSH
48613: LD_INT 1
48615: ST_TO_ADDR
48616: GO 48626
// result := false ;
48618: LD_ADDR_VAR 0 3
48622: PUSH
48623: LD_INT 0
48625: ST_TO_ADDR
// end else
48626: GO 48636
// result := false ;
48628: LD_ADDR_VAR 0 3
48632: PUSH
48633: LD_INT 0
48635: ST_TO_ADDR
// end ;
48636: LD_VAR 0 3
48640: RET
// export function HealTarget ( sci ) ; begin
48641: LD_INT 0
48643: PPUSH
// if not sci then
48644: LD_VAR 0 1
48648: NOT
48649: IFFALSE 48653
// exit ;
48651: GO 48718
// result := 0 ;
48653: LD_ADDR_VAR 0 2
48657: PUSH
48658: LD_INT 0
48660: ST_TO_ADDR
// if GetTaskList ( sci ) then
48661: LD_VAR 0 1
48665: PPUSH
48666: CALL_OW 437
48670: IFFALSE 48718
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48672: LD_VAR 0 1
48676: PPUSH
48677: CALL_OW 437
48681: PUSH
48682: LD_INT 1
48684: ARRAY
48685: PUSH
48686: LD_INT 1
48688: ARRAY
48689: PUSH
48690: LD_STRING l
48692: EQUAL
48693: IFFALSE 48718
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48695: LD_ADDR_VAR 0 2
48699: PUSH
48700: LD_VAR 0 1
48704: PPUSH
48705: CALL_OW 437
48709: PUSH
48710: LD_INT 1
48712: ARRAY
48713: PUSH
48714: LD_INT 4
48716: ARRAY
48717: ST_TO_ADDR
// end ;
48718: LD_VAR 0 2
48722: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
48723: LD_INT 0
48725: PPUSH
48726: PPUSH
48727: PPUSH
48728: PPUSH
48729: PPUSH
48730: PPUSH
48731: PPUSH
48732: PPUSH
48733: PPUSH
48734: PPUSH
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
48744: PPUSH
48745: PPUSH
48746: PPUSH
48747: PPUSH
48748: PPUSH
48749: PPUSH
48750: PPUSH
48751: PPUSH
48752: PPUSH
48753: PPUSH
48754: PPUSH
48755: PPUSH
48756: PPUSH
48757: PPUSH
// if not list then
48758: LD_VAR 0 1
48762: NOT
48763: IFFALSE 48767
// exit ;
48765: GO 53355
// base := list [ 1 ] ;
48767: LD_ADDR_VAR 0 3
48771: PUSH
48772: LD_VAR 0 1
48776: PUSH
48777: LD_INT 1
48779: ARRAY
48780: ST_TO_ADDR
// group := list [ 2 ] ;
48781: LD_ADDR_VAR 0 4
48785: PUSH
48786: LD_VAR 0 1
48790: PUSH
48791: LD_INT 2
48793: ARRAY
48794: ST_TO_ADDR
// path := list [ 3 ] ;
48795: LD_ADDR_VAR 0 5
48799: PUSH
48800: LD_VAR 0 1
48804: PUSH
48805: LD_INT 3
48807: ARRAY
48808: ST_TO_ADDR
// flags := list [ 4 ] ;
48809: LD_ADDR_VAR 0 6
48813: PUSH
48814: LD_VAR 0 1
48818: PUSH
48819: LD_INT 4
48821: ARRAY
48822: ST_TO_ADDR
// mined := [ ] ;
48823: LD_ADDR_VAR 0 27
48827: PUSH
48828: EMPTY
48829: ST_TO_ADDR
// bombed := [ ] ;
48830: LD_ADDR_VAR 0 28
48834: PUSH
48835: EMPTY
48836: ST_TO_ADDR
// healers := [ ] ;
48837: LD_ADDR_VAR 0 31
48841: PUSH
48842: EMPTY
48843: ST_TO_ADDR
// to_heal := [ ] ;
48844: LD_ADDR_VAR 0 30
48848: PUSH
48849: EMPTY
48850: ST_TO_ADDR
// repairs := [ ] ;
48851: LD_ADDR_VAR 0 33
48855: PUSH
48856: EMPTY
48857: ST_TO_ADDR
// to_repair := [ ] ;
48858: LD_ADDR_VAR 0 32
48862: PUSH
48863: EMPTY
48864: ST_TO_ADDR
// if not group or not path then
48865: LD_VAR 0 4
48869: NOT
48870: PUSH
48871: LD_VAR 0 5
48875: NOT
48876: OR
48877: IFFALSE 48881
// exit ;
48879: GO 53355
// if flags then
48881: LD_VAR 0 6
48885: IFFALSE 49029
// begin f_ignore_area := flags [ 1 ] ;
48887: LD_ADDR_VAR 0 17
48891: PUSH
48892: LD_VAR 0 6
48896: PUSH
48897: LD_INT 1
48899: ARRAY
48900: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
48901: LD_ADDR_VAR 0 18
48905: PUSH
48906: LD_VAR 0 6
48910: PUSH
48911: LD_INT 2
48913: ARRAY
48914: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
48915: LD_ADDR_VAR 0 19
48919: PUSH
48920: LD_VAR 0 6
48924: PUSH
48925: LD_INT 3
48927: ARRAY
48928: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
48929: LD_ADDR_VAR 0 20
48933: PUSH
48934: LD_VAR 0 6
48938: PUSH
48939: LD_INT 4
48941: ARRAY
48942: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
48943: LD_ADDR_VAR 0 21
48947: PUSH
48948: LD_VAR 0 6
48952: PUSH
48953: LD_INT 5
48955: ARRAY
48956: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
48957: LD_ADDR_VAR 0 22
48961: PUSH
48962: LD_VAR 0 6
48966: PUSH
48967: LD_INT 6
48969: ARRAY
48970: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
48971: LD_ADDR_VAR 0 23
48975: PUSH
48976: LD_VAR 0 6
48980: PUSH
48981: LD_INT 7
48983: ARRAY
48984: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
48985: LD_ADDR_VAR 0 24
48989: PUSH
48990: LD_VAR 0 6
48994: PUSH
48995: LD_INT 8
48997: ARRAY
48998: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
48999: LD_ADDR_VAR 0 25
49003: PUSH
49004: LD_VAR 0 6
49008: PUSH
49009: LD_INT 9
49011: ARRAY
49012: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49013: LD_ADDR_VAR 0 26
49017: PUSH
49018: LD_VAR 0 6
49022: PUSH
49023: LD_INT 10
49025: ARRAY
49026: ST_TO_ADDR
// end else
49027: GO 49109
// begin f_ignore_area := false ;
49029: LD_ADDR_VAR 0 17
49033: PUSH
49034: LD_INT 0
49036: ST_TO_ADDR
// f_capture := false ;
49037: LD_ADDR_VAR 0 18
49041: PUSH
49042: LD_INT 0
49044: ST_TO_ADDR
// f_ignore_civ := false ;
49045: LD_ADDR_VAR 0 19
49049: PUSH
49050: LD_INT 0
49052: ST_TO_ADDR
// f_murder := false ;
49053: LD_ADDR_VAR 0 20
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// f_mines := false ;
49061: LD_ADDR_VAR 0 21
49065: PUSH
49066: LD_INT 0
49068: ST_TO_ADDR
// f_repair := false ;
49069: LD_ADDR_VAR 0 22
49073: PUSH
49074: LD_INT 0
49076: ST_TO_ADDR
// f_heal := false ;
49077: LD_ADDR_VAR 0 23
49081: PUSH
49082: LD_INT 0
49084: ST_TO_ADDR
// f_spacetime := false ;
49085: LD_ADDR_VAR 0 24
49089: PUSH
49090: LD_INT 0
49092: ST_TO_ADDR
// f_attack_depot := false ;
49093: LD_ADDR_VAR 0 25
49097: PUSH
49098: LD_INT 0
49100: ST_TO_ADDR
// f_crawl := false ;
49101: LD_ADDR_VAR 0 26
49105: PUSH
49106: LD_INT 0
49108: ST_TO_ADDR
// end ; if f_heal then
49109: LD_VAR 0 23
49113: IFFALSE 49140
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49115: LD_ADDR_VAR 0 31
49119: PUSH
49120: LD_VAR 0 4
49124: PPUSH
49125: LD_INT 25
49127: PUSH
49128: LD_INT 4
49130: PUSH
49131: EMPTY
49132: LIST
49133: LIST
49134: PPUSH
49135: CALL_OW 72
49139: ST_TO_ADDR
// if f_repair then
49140: LD_VAR 0 22
49144: IFFALSE 49171
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49146: LD_ADDR_VAR 0 33
49150: PUSH
49151: LD_VAR 0 4
49155: PPUSH
49156: LD_INT 25
49158: PUSH
49159: LD_INT 3
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PPUSH
49166: CALL_OW 72
49170: ST_TO_ADDR
// units_path := [ ] ;
49171: LD_ADDR_VAR 0 16
49175: PUSH
49176: EMPTY
49177: ST_TO_ADDR
// for i = 1 to group do
49178: LD_ADDR_VAR 0 7
49182: PUSH
49183: DOUBLE
49184: LD_INT 1
49186: DEC
49187: ST_TO_ADDR
49188: LD_VAR 0 4
49192: PUSH
49193: FOR_TO
49194: IFFALSE 49223
// units_path := Replace ( units_path , i , path ) ;
49196: LD_ADDR_VAR 0 16
49200: PUSH
49201: LD_VAR 0 16
49205: PPUSH
49206: LD_VAR 0 7
49210: PPUSH
49211: LD_VAR 0 5
49215: PPUSH
49216: CALL_OW 1
49220: ST_TO_ADDR
49221: GO 49193
49223: POP
49224: POP
// repeat for i = group downto 1 do
49225: LD_ADDR_VAR 0 7
49229: PUSH
49230: DOUBLE
49231: LD_VAR 0 4
49235: INC
49236: ST_TO_ADDR
49237: LD_INT 1
49239: PUSH
49240: FOR_DOWNTO
49241: IFFALSE 53337
// begin wait ( 5 ) ;
49243: LD_INT 5
49245: PPUSH
49246: CALL_OW 67
// tmp := [ ] ;
49250: LD_ADDR_VAR 0 14
49254: PUSH
49255: EMPTY
49256: ST_TO_ADDR
// attacking := false ;
49257: LD_ADDR_VAR 0 29
49261: PUSH
49262: LD_INT 0
49264: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49265: LD_VAR 0 4
49269: PUSH
49270: LD_VAR 0 7
49274: ARRAY
49275: PPUSH
49276: CALL_OW 301
49280: PUSH
49281: LD_VAR 0 4
49285: PUSH
49286: LD_VAR 0 7
49290: ARRAY
49291: NOT
49292: OR
49293: IFFALSE 49402
// begin if GetType ( group [ i ] ) = unit_human then
49295: LD_VAR 0 4
49299: PUSH
49300: LD_VAR 0 7
49304: ARRAY
49305: PPUSH
49306: CALL_OW 247
49310: PUSH
49311: LD_INT 1
49313: EQUAL
49314: IFFALSE 49360
// begin to_heal := to_heal diff group [ i ] ;
49316: LD_ADDR_VAR 0 30
49320: PUSH
49321: LD_VAR 0 30
49325: PUSH
49326: LD_VAR 0 4
49330: PUSH
49331: LD_VAR 0 7
49335: ARRAY
49336: DIFF
49337: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49338: LD_ADDR_VAR 0 31
49342: PUSH
49343: LD_VAR 0 31
49347: PUSH
49348: LD_VAR 0 4
49352: PUSH
49353: LD_VAR 0 7
49357: ARRAY
49358: DIFF
49359: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49360: LD_ADDR_VAR 0 4
49364: PUSH
49365: LD_VAR 0 4
49369: PPUSH
49370: LD_VAR 0 7
49374: PPUSH
49375: CALL_OW 3
49379: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49380: LD_ADDR_VAR 0 16
49384: PUSH
49385: LD_VAR 0 16
49389: PPUSH
49390: LD_VAR 0 7
49394: PPUSH
49395: CALL_OW 3
49399: ST_TO_ADDR
// continue ;
49400: GO 49240
// end ; if f_repair then
49402: LD_VAR 0 22
49406: IFFALSE 49895
// begin if GetType ( group [ i ] ) = unit_vehicle then
49408: LD_VAR 0 4
49412: PUSH
49413: LD_VAR 0 7
49417: ARRAY
49418: PPUSH
49419: CALL_OW 247
49423: PUSH
49424: LD_INT 2
49426: EQUAL
49427: IFFALSE 49617
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49429: LD_VAR 0 4
49433: PUSH
49434: LD_VAR 0 7
49438: ARRAY
49439: PPUSH
49440: CALL_OW 256
49444: PUSH
49445: LD_INT 700
49447: LESS
49448: PUSH
49449: LD_VAR 0 4
49453: PUSH
49454: LD_VAR 0 7
49458: ARRAY
49459: PUSH
49460: LD_VAR 0 32
49464: IN
49465: NOT
49466: AND
49467: IFFALSE 49491
// to_repair := to_repair union group [ i ] ;
49469: LD_ADDR_VAR 0 32
49473: PUSH
49474: LD_VAR 0 32
49478: PUSH
49479: LD_VAR 0 4
49483: PUSH
49484: LD_VAR 0 7
49488: ARRAY
49489: UNION
49490: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49491: LD_VAR 0 4
49495: PUSH
49496: LD_VAR 0 7
49500: ARRAY
49501: PPUSH
49502: CALL_OW 256
49506: PUSH
49507: LD_INT 1000
49509: EQUAL
49510: PUSH
49511: LD_VAR 0 4
49515: PUSH
49516: LD_VAR 0 7
49520: ARRAY
49521: PUSH
49522: LD_VAR 0 32
49526: IN
49527: AND
49528: IFFALSE 49552
// to_repair := to_repair diff group [ i ] ;
49530: LD_ADDR_VAR 0 32
49534: PUSH
49535: LD_VAR 0 32
49539: PUSH
49540: LD_VAR 0 4
49544: PUSH
49545: LD_VAR 0 7
49549: ARRAY
49550: DIFF
49551: ST_TO_ADDR
// if group [ i ] in to_repair then
49552: LD_VAR 0 4
49556: PUSH
49557: LD_VAR 0 7
49561: ARRAY
49562: PUSH
49563: LD_VAR 0 32
49567: IN
49568: IFFALSE 49615
// begin if not IsInArea ( group [ i ] , f_repair ) then
49570: LD_VAR 0 4
49574: PUSH
49575: LD_VAR 0 7
49579: ARRAY
49580: PPUSH
49581: LD_VAR 0 22
49585: PPUSH
49586: CALL_OW 308
49590: NOT
49591: IFFALSE 49613
// ComMoveToArea ( group [ i ] , f_repair ) ;
49593: LD_VAR 0 4
49597: PUSH
49598: LD_VAR 0 7
49602: ARRAY
49603: PPUSH
49604: LD_VAR 0 22
49608: PPUSH
49609: CALL_OW 113
// continue ;
49613: GO 49240
// end ; end else
49615: GO 49895
// if group [ i ] in repairs then
49617: LD_VAR 0 4
49621: PUSH
49622: LD_VAR 0 7
49626: ARRAY
49627: PUSH
49628: LD_VAR 0 33
49632: IN
49633: IFFALSE 49895
// begin if IsInUnit ( group [ i ] ) then
49635: LD_VAR 0 4
49639: PUSH
49640: LD_VAR 0 7
49644: ARRAY
49645: PPUSH
49646: CALL_OW 310
49650: IFFALSE 49718
// begin z := IsInUnit ( group [ i ] ) ;
49652: LD_ADDR_VAR 0 13
49656: PUSH
49657: LD_VAR 0 4
49661: PUSH
49662: LD_VAR 0 7
49666: ARRAY
49667: PPUSH
49668: CALL_OW 310
49672: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49673: LD_VAR 0 13
49677: PUSH
49678: LD_VAR 0 32
49682: IN
49683: PUSH
49684: LD_VAR 0 13
49688: PPUSH
49689: LD_VAR 0 22
49693: PPUSH
49694: CALL_OW 308
49698: AND
49699: IFFALSE 49716
// ComExitVehicle ( group [ i ] ) ;
49701: LD_VAR 0 4
49705: PUSH
49706: LD_VAR 0 7
49710: ARRAY
49711: PPUSH
49712: CALL_OW 121
// end else
49716: GO 49895
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
49718: LD_ADDR_VAR 0 13
49722: PUSH
49723: LD_VAR 0 4
49727: PPUSH
49728: LD_INT 95
49730: PUSH
49731: LD_VAR 0 22
49735: PUSH
49736: EMPTY
49737: LIST
49738: LIST
49739: PUSH
49740: LD_INT 58
49742: PUSH
49743: EMPTY
49744: LIST
49745: PUSH
49746: EMPTY
49747: LIST
49748: LIST
49749: PPUSH
49750: CALL_OW 72
49754: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
49755: LD_VAR 0 4
49759: PUSH
49760: LD_VAR 0 7
49764: ARRAY
49765: PPUSH
49766: CALL_OW 314
49770: NOT
49771: IFFALSE 49893
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
49773: LD_ADDR_VAR 0 10
49777: PUSH
49778: LD_VAR 0 13
49782: PPUSH
49783: LD_VAR 0 4
49787: PUSH
49788: LD_VAR 0 7
49792: ARRAY
49793: PPUSH
49794: CALL_OW 74
49798: ST_TO_ADDR
// if not x then
49799: LD_VAR 0 10
49803: NOT
49804: IFFALSE 49808
// continue ;
49806: GO 49240
// if GetLives ( x ) < 1000 then
49808: LD_VAR 0 10
49812: PPUSH
49813: CALL_OW 256
49817: PUSH
49818: LD_INT 1000
49820: LESS
49821: IFFALSE 49845
// ComRepairVehicle ( group [ i ] , x ) else
49823: LD_VAR 0 4
49827: PUSH
49828: LD_VAR 0 7
49832: ARRAY
49833: PPUSH
49834: LD_VAR 0 10
49838: PPUSH
49839: CALL_OW 129
49843: GO 49893
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
49845: LD_VAR 0 23
49849: PUSH
49850: LD_VAR 0 4
49854: PUSH
49855: LD_VAR 0 7
49859: ARRAY
49860: PPUSH
49861: CALL_OW 256
49865: PUSH
49866: LD_INT 1000
49868: LESS
49869: AND
49870: NOT
49871: IFFALSE 49893
// ComEnterUnit ( group [ i ] , x ) ;
49873: LD_VAR 0 4
49877: PUSH
49878: LD_VAR 0 7
49882: ARRAY
49883: PPUSH
49884: LD_VAR 0 10
49888: PPUSH
49889: CALL_OW 120
// end ; continue ;
49893: GO 49240
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
49895: LD_VAR 0 23
49899: PUSH
49900: LD_VAR 0 4
49904: PUSH
49905: LD_VAR 0 7
49909: ARRAY
49910: PPUSH
49911: CALL_OW 247
49915: PUSH
49916: LD_INT 1
49918: EQUAL
49919: AND
49920: IFFALSE 50398
// begin if group [ i ] in healers then
49922: LD_VAR 0 4
49926: PUSH
49927: LD_VAR 0 7
49931: ARRAY
49932: PUSH
49933: LD_VAR 0 31
49937: IN
49938: IFFALSE 50211
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
49940: LD_VAR 0 4
49944: PUSH
49945: LD_VAR 0 7
49949: ARRAY
49950: PPUSH
49951: LD_VAR 0 23
49955: PPUSH
49956: CALL_OW 308
49960: NOT
49961: PUSH
49962: LD_VAR 0 4
49966: PUSH
49967: LD_VAR 0 7
49971: ARRAY
49972: PPUSH
49973: CALL_OW 314
49977: NOT
49978: AND
49979: IFFALSE 50003
// ComMoveToArea ( group [ i ] , f_heal ) else
49981: LD_VAR 0 4
49985: PUSH
49986: LD_VAR 0 7
49990: ARRAY
49991: PPUSH
49992: LD_VAR 0 23
49996: PPUSH
49997: CALL_OW 113
50001: GO 50209
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50003: LD_VAR 0 4
50007: PUSH
50008: LD_VAR 0 7
50012: ARRAY
50013: PPUSH
50014: CALL 48641 0 1
50018: PPUSH
50019: CALL_OW 256
50023: PUSH
50024: LD_INT 1000
50026: EQUAL
50027: IFFALSE 50046
// ComStop ( group [ i ] ) else
50029: LD_VAR 0 4
50033: PUSH
50034: LD_VAR 0 7
50038: ARRAY
50039: PPUSH
50040: CALL_OW 141
50044: GO 50209
// if not HasTask ( group [ i ] ) and to_heal then
50046: LD_VAR 0 4
50050: PUSH
50051: LD_VAR 0 7
50055: ARRAY
50056: PPUSH
50057: CALL_OW 314
50061: NOT
50062: PUSH
50063: LD_VAR 0 30
50067: AND
50068: IFFALSE 50209
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50070: LD_ADDR_VAR 0 13
50074: PUSH
50075: LD_VAR 0 30
50079: PPUSH
50080: LD_INT 3
50082: PUSH
50083: LD_INT 54
50085: PUSH
50086: EMPTY
50087: LIST
50088: PUSH
50089: EMPTY
50090: LIST
50091: LIST
50092: PPUSH
50093: CALL_OW 72
50097: PPUSH
50098: LD_VAR 0 4
50102: PUSH
50103: LD_VAR 0 7
50107: ARRAY
50108: PPUSH
50109: CALL_OW 74
50113: ST_TO_ADDR
// if z then
50114: LD_VAR 0 13
50118: IFFALSE 50209
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50120: LD_INT 91
50122: PUSH
50123: LD_VAR 0 13
50127: PUSH
50128: LD_INT 10
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: LIST
50135: PUSH
50136: LD_INT 81
50138: PUSH
50139: LD_VAR 0 13
50143: PPUSH
50144: CALL_OW 255
50148: PUSH
50149: EMPTY
50150: LIST
50151: LIST
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PPUSH
50157: CALL_OW 69
50161: PUSH
50162: LD_INT 0
50164: EQUAL
50165: IFFALSE 50189
// ComHeal ( group [ i ] , z ) else
50167: LD_VAR 0 4
50171: PUSH
50172: LD_VAR 0 7
50176: ARRAY
50177: PPUSH
50178: LD_VAR 0 13
50182: PPUSH
50183: CALL_OW 128
50187: GO 50209
// ComMoveToArea ( group [ i ] , f_heal ) ;
50189: LD_VAR 0 4
50193: PUSH
50194: LD_VAR 0 7
50198: ARRAY
50199: PPUSH
50200: LD_VAR 0 23
50204: PPUSH
50205: CALL_OW 113
// end ; continue ;
50209: GO 49240
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50211: LD_VAR 0 4
50215: PUSH
50216: LD_VAR 0 7
50220: ARRAY
50221: PPUSH
50222: CALL_OW 256
50226: PUSH
50227: LD_INT 700
50229: LESS
50230: PUSH
50231: LD_VAR 0 4
50235: PUSH
50236: LD_VAR 0 7
50240: ARRAY
50241: PUSH
50242: LD_VAR 0 30
50246: IN
50247: NOT
50248: AND
50249: IFFALSE 50273
// to_heal := to_heal union group [ i ] ;
50251: LD_ADDR_VAR 0 30
50255: PUSH
50256: LD_VAR 0 30
50260: PUSH
50261: LD_VAR 0 4
50265: PUSH
50266: LD_VAR 0 7
50270: ARRAY
50271: UNION
50272: ST_TO_ADDR
// if group [ i ] in to_heal then
50273: LD_VAR 0 4
50277: PUSH
50278: LD_VAR 0 7
50282: ARRAY
50283: PUSH
50284: LD_VAR 0 30
50288: IN
50289: IFFALSE 50398
// begin if GetLives ( group [ i ] ) = 1000 then
50291: LD_VAR 0 4
50295: PUSH
50296: LD_VAR 0 7
50300: ARRAY
50301: PPUSH
50302: CALL_OW 256
50306: PUSH
50307: LD_INT 1000
50309: EQUAL
50310: IFFALSE 50336
// to_heal := to_heal diff group [ i ] else
50312: LD_ADDR_VAR 0 30
50316: PUSH
50317: LD_VAR 0 30
50321: PUSH
50322: LD_VAR 0 4
50326: PUSH
50327: LD_VAR 0 7
50331: ARRAY
50332: DIFF
50333: ST_TO_ADDR
50334: GO 50398
// begin if not IsInArea ( group [ i ] , to_heal ) then
50336: LD_VAR 0 4
50340: PUSH
50341: LD_VAR 0 7
50345: ARRAY
50346: PPUSH
50347: LD_VAR 0 30
50351: PPUSH
50352: CALL_OW 308
50356: NOT
50357: IFFALSE 50381
// ComMoveToArea ( group [ i ] , f_heal ) else
50359: LD_VAR 0 4
50363: PUSH
50364: LD_VAR 0 7
50368: ARRAY
50369: PPUSH
50370: LD_VAR 0 23
50374: PPUSH
50375: CALL_OW 113
50379: GO 50396
// ComHold ( group [ i ] ) ;
50381: LD_VAR 0 4
50385: PUSH
50386: LD_VAR 0 7
50390: ARRAY
50391: PPUSH
50392: CALL_OW 140
// continue ;
50396: GO 49240
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50398: LD_VAR 0 4
50402: PUSH
50403: LD_VAR 0 7
50407: ARRAY
50408: PPUSH
50409: LD_INT 10
50411: PPUSH
50412: CALL 47038 0 2
50416: NOT
50417: PUSH
50418: LD_VAR 0 16
50422: PUSH
50423: LD_VAR 0 7
50427: ARRAY
50428: PUSH
50429: EMPTY
50430: EQUAL
50431: NOT
50432: AND
50433: IFFALSE 50699
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50435: LD_VAR 0 4
50439: PUSH
50440: LD_VAR 0 7
50444: ARRAY
50445: PPUSH
50446: CALL_OW 262
50450: PUSH
50451: LD_INT 1
50453: PUSH
50454: LD_INT 2
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: IN
50461: IFFALSE 50502
// if GetFuel ( group [ i ] ) < 10 then
50463: LD_VAR 0 4
50467: PUSH
50468: LD_VAR 0 7
50472: ARRAY
50473: PPUSH
50474: CALL_OW 261
50478: PUSH
50479: LD_INT 10
50481: LESS
50482: IFFALSE 50502
// SetFuel ( group [ i ] , 12 ) ;
50484: LD_VAR 0 4
50488: PUSH
50489: LD_VAR 0 7
50493: ARRAY
50494: PPUSH
50495: LD_INT 12
50497: PPUSH
50498: CALL_OW 240
// if units_path [ i ] then
50502: LD_VAR 0 16
50506: PUSH
50507: LD_VAR 0 7
50511: ARRAY
50512: IFFALSE 50697
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50514: LD_VAR 0 4
50518: PUSH
50519: LD_VAR 0 7
50523: ARRAY
50524: PPUSH
50525: LD_VAR 0 16
50529: PUSH
50530: LD_VAR 0 7
50534: ARRAY
50535: PUSH
50536: LD_INT 1
50538: ARRAY
50539: PUSH
50540: LD_INT 1
50542: ARRAY
50543: PPUSH
50544: LD_VAR 0 16
50548: PUSH
50549: LD_VAR 0 7
50553: ARRAY
50554: PUSH
50555: LD_INT 1
50557: ARRAY
50558: PUSH
50559: LD_INT 2
50561: ARRAY
50562: PPUSH
50563: CALL_OW 297
50567: PUSH
50568: LD_INT 6
50570: GREATER
50571: IFFALSE 50646
// begin if not HasTask ( group [ i ] ) then
50573: LD_VAR 0 4
50577: PUSH
50578: LD_VAR 0 7
50582: ARRAY
50583: PPUSH
50584: CALL_OW 314
50588: NOT
50589: IFFALSE 50644
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50591: LD_VAR 0 4
50595: PUSH
50596: LD_VAR 0 7
50600: ARRAY
50601: PPUSH
50602: LD_VAR 0 16
50606: PUSH
50607: LD_VAR 0 7
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: ARRAY
50620: PPUSH
50621: LD_VAR 0 16
50625: PUSH
50626: LD_VAR 0 7
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: PUSH
50636: LD_INT 2
50638: ARRAY
50639: PPUSH
50640: CALL_OW 114
// end else
50644: GO 50697
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50646: LD_ADDR_VAR 0 15
50650: PUSH
50651: LD_VAR 0 16
50655: PUSH
50656: LD_VAR 0 7
50660: ARRAY
50661: PPUSH
50662: LD_INT 1
50664: PPUSH
50665: CALL_OW 3
50669: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50670: LD_ADDR_VAR 0 16
50674: PUSH
50675: LD_VAR 0 16
50679: PPUSH
50680: LD_VAR 0 7
50684: PPUSH
50685: LD_VAR 0 15
50689: PPUSH
50690: CALL_OW 1
50694: ST_TO_ADDR
// continue ;
50695: GO 49240
// end ; end ; end else
50697: GO 53335
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50699: LD_ADDR_VAR 0 14
50703: PUSH
50704: LD_INT 81
50706: PUSH
50707: LD_VAR 0 4
50711: PUSH
50712: LD_VAR 0 7
50716: ARRAY
50717: PPUSH
50718: CALL_OW 255
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PPUSH
50727: CALL_OW 69
50731: ST_TO_ADDR
// if not tmp then
50732: LD_VAR 0 14
50736: NOT
50737: IFFALSE 50741
// continue ;
50739: GO 49240
// if f_ignore_area then
50741: LD_VAR 0 17
50745: IFFALSE 50833
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
50747: LD_ADDR_VAR 0 15
50751: PUSH
50752: LD_VAR 0 14
50756: PPUSH
50757: LD_INT 3
50759: PUSH
50760: LD_INT 92
50762: PUSH
50763: LD_VAR 0 17
50767: PUSH
50768: LD_INT 1
50770: ARRAY
50771: PUSH
50772: LD_VAR 0 17
50776: PUSH
50777: LD_INT 2
50779: ARRAY
50780: PUSH
50781: LD_VAR 0 17
50785: PUSH
50786: LD_INT 3
50788: ARRAY
50789: PUSH
50790: EMPTY
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PPUSH
50800: CALL_OW 72
50804: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50805: LD_VAR 0 14
50809: PUSH
50810: LD_VAR 0 15
50814: DIFF
50815: IFFALSE 50833
// tmp := tmp diff tmp2 ;
50817: LD_ADDR_VAR 0 14
50821: PUSH
50822: LD_VAR 0 14
50826: PUSH
50827: LD_VAR 0 15
50831: DIFF
50832: ST_TO_ADDR
// end ; if not f_murder then
50833: LD_VAR 0 20
50837: NOT
50838: IFFALSE 50896
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
50840: LD_ADDR_VAR 0 15
50844: PUSH
50845: LD_VAR 0 14
50849: PPUSH
50850: LD_INT 3
50852: PUSH
50853: LD_INT 50
50855: PUSH
50856: EMPTY
50857: LIST
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PPUSH
50863: CALL_OW 72
50867: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50868: LD_VAR 0 14
50872: PUSH
50873: LD_VAR 0 15
50877: DIFF
50878: IFFALSE 50896
// tmp := tmp diff tmp2 ;
50880: LD_ADDR_VAR 0 14
50884: PUSH
50885: LD_VAR 0 14
50889: PUSH
50890: LD_VAR 0 15
50894: DIFF
50895: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
50896: LD_ADDR_VAR 0 14
50900: PUSH
50901: LD_VAR 0 4
50905: PUSH
50906: LD_VAR 0 7
50910: ARRAY
50911: PPUSH
50912: LD_VAR 0 14
50916: PPUSH
50917: LD_INT 1
50919: PPUSH
50920: LD_INT 1
50922: PPUSH
50923: CALL 20705 0 4
50927: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
50928: LD_VAR 0 4
50932: PUSH
50933: LD_VAR 0 7
50937: ARRAY
50938: PPUSH
50939: CALL_OW 257
50943: PUSH
50944: LD_INT 1
50946: EQUAL
50947: IFFALSE 51395
// begin if WantPlant ( group [ i ] ) then
50949: LD_VAR 0 4
50953: PUSH
50954: LD_VAR 0 7
50958: ARRAY
50959: PPUSH
50960: CALL 20206 0 1
50964: IFFALSE 50968
// continue ;
50966: GO 49240
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
50968: LD_VAR 0 18
50972: PUSH
50973: LD_VAR 0 4
50977: PUSH
50978: LD_VAR 0 7
50982: ARRAY
50983: PPUSH
50984: CALL_OW 310
50988: NOT
50989: AND
50990: PUSH
50991: LD_VAR 0 14
50995: PUSH
50996: LD_INT 1
50998: ARRAY
50999: PUSH
51000: LD_VAR 0 14
51004: PPUSH
51005: LD_INT 21
51007: PUSH
51008: LD_INT 2
51010: PUSH
51011: EMPTY
51012: LIST
51013: LIST
51014: PUSH
51015: LD_INT 58
51017: PUSH
51018: EMPTY
51019: LIST
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: PPUSH
51025: CALL_OW 72
51029: IN
51030: AND
51031: IFFALSE 51067
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51033: LD_VAR 0 4
51037: PUSH
51038: LD_VAR 0 7
51042: ARRAY
51043: PPUSH
51044: LD_VAR 0 14
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: CALL_OW 120
// attacking := true ;
51057: LD_ADDR_VAR 0 29
51061: PUSH
51062: LD_INT 1
51064: ST_TO_ADDR
// continue ;
51065: GO 49240
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51067: LD_VAR 0 26
51071: PUSH
51072: LD_VAR 0 4
51076: PUSH
51077: LD_VAR 0 7
51081: ARRAY
51082: PPUSH
51083: CALL_OW 257
51087: PUSH
51088: LD_INT 1
51090: EQUAL
51091: AND
51092: PUSH
51093: LD_VAR 0 4
51097: PUSH
51098: LD_VAR 0 7
51102: ARRAY
51103: PPUSH
51104: CALL_OW 256
51108: PUSH
51109: LD_INT 800
51111: LESS
51112: AND
51113: PUSH
51114: LD_VAR 0 4
51118: PUSH
51119: LD_VAR 0 7
51123: ARRAY
51124: PPUSH
51125: CALL_OW 318
51129: NOT
51130: AND
51131: IFFALSE 51148
// ComCrawl ( group [ i ] ) ;
51133: LD_VAR 0 4
51137: PUSH
51138: LD_VAR 0 7
51142: ARRAY
51143: PPUSH
51144: CALL_OW 137
// if f_mines then
51148: LD_VAR 0 21
51152: IFFALSE 51395
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51154: LD_VAR 0 14
51158: PUSH
51159: LD_INT 1
51161: ARRAY
51162: PPUSH
51163: CALL_OW 247
51167: PUSH
51168: LD_INT 3
51170: EQUAL
51171: PUSH
51172: LD_VAR 0 14
51176: PUSH
51177: LD_INT 1
51179: ARRAY
51180: PUSH
51181: LD_VAR 0 27
51185: IN
51186: NOT
51187: AND
51188: IFFALSE 51395
// begin x := GetX ( tmp [ 1 ] ) ;
51190: LD_ADDR_VAR 0 10
51194: PUSH
51195: LD_VAR 0 14
51199: PUSH
51200: LD_INT 1
51202: ARRAY
51203: PPUSH
51204: CALL_OW 250
51208: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51209: LD_ADDR_VAR 0 11
51213: PUSH
51214: LD_VAR 0 14
51218: PUSH
51219: LD_INT 1
51221: ARRAY
51222: PPUSH
51223: CALL_OW 251
51227: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51228: LD_ADDR_VAR 0 12
51232: PUSH
51233: LD_VAR 0 4
51237: PUSH
51238: LD_VAR 0 7
51242: ARRAY
51243: PPUSH
51244: CALL 47123 0 1
51248: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51249: LD_VAR 0 4
51253: PUSH
51254: LD_VAR 0 7
51258: ARRAY
51259: PPUSH
51260: LD_VAR 0 10
51264: PPUSH
51265: LD_VAR 0 11
51269: PPUSH
51270: LD_VAR 0 14
51274: PUSH
51275: LD_INT 1
51277: ARRAY
51278: PPUSH
51279: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51283: LD_VAR 0 4
51287: PUSH
51288: LD_VAR 0 7
51292: ARRAY
51293: PPUSH
51294: LD_VAR 0 10
51298: PPUSH
51299: LD_VAR 0 12
51303: PPUSH
51304: LD_INT 7
51306: PPUSH
51307: CALL_OW 272
51311: PPUSH
51312: LD_VAR 0 11
51316: PPUSH
51317: LD_VAR 0 12
51321: PPUSH
51322: LD_INT 7
51324: PPUSH
51325: CALL_OW 273
51329: PPUSH
51330: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51334: LD_VAR 0 4
51338: PUSH
51339: LD_VAR 0 7
51343: ARRAY
51344: PPUSH
51345: LD_INT 71
51347: PPUSH
51348: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51352: LD_ADDR_VAR 0 27
51356: PUSH
51357: LD_VAR 0 27
51361: PPUSH
51362: LD_VAR 0 27
51366: PUSH
51367: LD_INT 1
51369: PLUS
51370: PPUSH
51371: LD_VAR 0 14
51375: PUSH
51376: LD_INT 1
51378: ARRAY
51379: PPUSH
51380: CALL_OW 1
51384: ST_TO_ADDR
// attacking := true ;
51385: LD_ADDR_VAR 0 29
51389: PUSH
51390: LD_INT 1
51392: ST_TO_ADDR
// continue ;
51393: GO 49240
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51395: LD_VAR 0 4
51399: PUSH
51400: LD_VAR 0 7
51404: ARRAY
51405: PPUSH
51406: CALL_OW 257
51410: PUSH
51411: LD_INT 17
51413: EQUAL
51414: PUSH
51415: LD_VAR 0 4
51419: PUSH
51420: LD_VAR 0 7
51424: ARRAY
51425: PPUSH
51426: CALL_OW 110
51430: PUSH
51431: LD_INT 71
51433: EQUAL
51434: NOT
51435: AND
51436: IFFALSE 51582
// begin attacking := false ;
51438: LD_ADDR_VAR 0 29
51442: PUSH
51443: LD_INT 0
51445: ST_TO_ADDR
// k := 5 ;
51446: LD_ADDR_VAR 0 9
51450: PUSH
51451: LD_INT 5
51453: ST_TO_ADDR
// if tmp < k then
51454: LD_VAR 0 14
51458: PUSH
51459: LD_VAR 0 9
51463: LESS
51464: IFFALSE 51476
// k := tmp ;
51466: LD_ADDR_VAR 0 9
51470: PUSH
51471: LD_VAR 0 14
51475: ST_TO_ADDR
// for j = 1 to k do
51476: LD_ADDR_VAR 0 8
51480: PUSH
51481: DOUBLE
51482: LD_INT 1
51484: DEC
51485: ST_TO_ADDR
51486: LD_VAR 0 9
51490: PUSH
51491: FOR_TO
51492: IFFALSE 51580
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51494: LD_VAR 0 14
51498: PUSH
51499: LD_VAR 0 8
51503: ARRAY
51504: PUSH
51505: LD_VAR 0 14
51509: PPUSH
51510: LD_INT 58
51512: PUSH
51513: EMPTY
51514: LIST
51515: PPUSH
51516: CALL_OW 72
51520: IN
51521: NOT
51522: IFFALSE 51578
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51524: LD_VAR 0 4
51528: PUSH
51529: LD_VAR 0 7
51533: ARRAY
51534: PPUSH
51535: LD_VAR 0 14
51539: PUSH
51540: LD_VAR 0 8
51544: ARRAY
51545: PPUSH
51546: CALL_OW 115
// attacking := true ;
51550: LD_ADDR_VAR 0 29
51554: PUSH
51555: LD_INT 1
51557: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51558: LD_VAR 0 4
51562: PUSH
51563: LD_VAR 0 7
51567: ARRAY
51568: PPUSH
51569: LD_INT 71
51571: PPUSH
51572: CALL_OW 109
// continue ;
51576: GO 51491
// end ; end ;
51578: GO 51491
51580: POP
51581: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51582: LD_VAR 0 4
51586: PUSH
51587: LD_VAR 0 7
51591: ARRAY
51592: PPUSH
51593: CALL_OW 257
51597: PUSH
51598: LD_INT 8
51600: EQUAL
51601: PUSH
51602: LD_VAR 0 4
51606: PUSH
51607: LD_VAR 0 7
51611: ARRAY
51612: PPUSH
51613: CALL_OW 264
51617: PUSH
51618: LD_INT 28
51620: PUSH
51621: LD_INT 45
51623: PUSH
51624: LD_INT 7
51626: PUSH
51627: LD_INT 47
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: IN
51636: OR
51637: IFFALSE 51867
// begin attacking := false ;
51639: LD_ADDR_VAR 0 29
51643: PUSH
51644: LD_INT 0
51646: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51647: LD_VAR 0 14
51651: PUSH
51652: LD_INT 1
51654: ARRAY
51655: PPUSH
51656: CALL_OW 266
51660: PUSH
51661: LD_INT 32
51663: PUSH
51664: LD_INT 31
51666: PUSH
51667: LD_INT 33
51669: PUSH
51670: LD_INT 4
51672: PUSH
51673: LD_INT 5
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: IN
51683: IFFALSE 51867
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51685: LD_ADDR_VAR 0 9
51689: PUSH
51690: LD_VAR 0 14
51694: PUSH
51695: LD_INT 1
51697: ARRAY
51698: PPUSH
51699: CALL_OW 266
51703: PPUSH
51704: LD_VAR 0 14
51708: PUSH
51709: LD_INT 1
51711: ARRAY
51712: PPUSH
51713: CALL_OW 250
51717: PPUSH
51718: LD_VAR 0 14
51722: PUSH
51723: LD_INT 1
51725: ARRAY
51726: PPUSH
51727: CALL_OW 251
51731: PPUSH
51732: LD_VAR 0 14
51736: PUSH
51737: LD_INT 1
51739: ARRAY
51740: PPUSH
51741: CALL_OW 254
51745: PPUSH
51746: LD_VAR 0 14
51750: PUSH
51751: LD_INT 1
51753: ARRAY
51754: PPUSH
51755: CALL_OW 248
51759: PPUSH
51760: LD_INT 0
51762: PPUSH
51763: CALL 28499 0 6
51767: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
51768: LD_ADDR_VAR 0 8
51772: PUSH
51773: LD_VAR 0 4
51777: PUSH
51778: LD_VAR 0 7
51782: ARRAY
51783: PPUSH
51784: LD_VAR 0 9
51788: PPUSH
51789: CALL 47186 0 2
51793: ST_TO_ADDR
// if j then
51794: LD_VAR 0 8
51798: IFFALSE 51867
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
51800: LD_VAR 0 8
51804: PUSH
51805: LD_INT 1
51807: ARRAY
51808: PPUSH
51809: LD_VAR 0 8
51813: PUSH
51814: LD_INT 2
51816: ARRAY
51817: PPUSH
51818: CALL_OW 488
51822: IFFALSE 51867
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
51824: LD_VAR 0 4
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PPUSH
51835: LD_VAR 0 8
51839: PUSH
51840: LD_INT 1
51842: ARRAY
51843: PPUSH
51844: LD_VAR 0 8
51848: PUSH
51849: LD_INT 2
51851: ARRAY
51852: PPUSH
51853: CALL_OW 116
// attacking := true ;
51857: LD_ADDR_VAR 0 29
51861: PUSH
51862: LD_INT 1
51864: ST_TO_ADDR
// continue ;
51865: GO 49240
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 7
51876: ARRAY
51877: PPUSH
51878: CALL_OW 265
51882: PUSH
51883: LD_INT 11
51885: EQUAL
51886: IFFALSE 52164
// begin k := 10 ;
51888: LD_ADDR_VAR 0 9
51892: PUSH
51893: LD_INT 10
51895: ST_TO_ADDR
// x := 0 ;
51896: LD_ADDR_VAR 0 10
51900: PUSH
51901: LD_INT 0
51903: ST_TO_ADDR
// if tmp < k then
51904: LD_VAR 0 14
51908: PUSH
51909: LD_VAR 0 9
51913: LESS
51914: IFFALSE 51926
// k := tmp ;
51916: LD_ADDR_VAR 0 9
51920: PUSH
51921: LD_VAR 0 14
51925: ST_TO_ADDR
// for j = k downto 1 do
51926: LD_ADDR_VAR 0 8
51930: PUSH
51931: DOUBLE
51932: LD_VAR 0 9
51936: INC
51937: ST_TO_ADDR
51938: LD_INT 1
51940: PUSH
51941: FOR_DOWNTO
51942: IFFALSE 52017
// begin if GetType ( tmp [ j ] ) = unit_human then
51944: LD_VAR 0 14
51948: PUSH
51949: LD_VAR 0 8
51953: ARRAY
51954: PPUSH
51955: CALL_OW 247
51959: PUSH
51960: LD_INT 1
51962: EQUAL
51963: IFFALSE 52015
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
51965: LD_VAR 0 4
51969: PUSH
51970: LD_VAR 0 7
51974: ARRAY
51975: PPUSH
51976: LD_VAR 0 14
51980: PUSH
51981: LD_VAR 0 8
51985: ARRAY
51986: PPUSH
51987: CALL 47457 0 2
// x := tmp [ j ] ;
51991: LD_ADDR_VAR 0 10
51995: PUSH
51996: LD_VAR 0 14
52000: PUSH
52001: LD_VAR 0 8
52005: ARRAY
52006: ST_TO_ADDR
// attacking := true ;
52007: LD_ADDR_VAR 0 29
52011: PUSH
52012: LD_INT 1
52014: ST_TO_ADDR
// end ; end ;
52015: GO 51941
52017: POP
52018: POP
// if not x then
52019: LD_VAR 0 10
52023: NOT
52024: IFFALSE 52164
// begin attacking := true ;
52026: LD_ADDR_VAR 0 29
52030: PUSH
52031: LD_INT 1
52033: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52034: LD_VAR 0 4
52038: PUSH
52039: LD_VAR 0 7
52043: ARRAY
52044: PPUSH
52045: CALL_OW 250
52049: PPUSH
52050: LD_VAR 0 4
52054: PUSH
52055: LD_VAR 0 7
52059: ARRAY
52060: PPUSH
52061: CALL_OW 251
52065: PPUSH
52066: CALL_OW 546
52070: PUSH
52071: LD_INT 2
52073: ARRAY
52074: PUSH
52075: LD_VAR 0 14
52079: PUSH
52080: LD_INT 1
52082: ARRAY
52083: PPUSH
52084: CALL_OW 250
52088: PPUSH
52089: LD_VAR 0 14
52093: PUSH
52094: LD_INT 1
52096: ARRAY
52097: PPUSH
52098: CALL_OW 251
52102: PPUSH
52103: CALL_OW 546
52107: PUSH
52108: LD_INT 2
52110: ARRAY
52111: EQUAL
52112: IFFALSE 52140
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52114: LD_VAR 0 4
52118: PUSH
52119: LD_VAR 0 7
52123: ARRAY
52124: PPUSH
52125: LD_VAR 0 14
52129: PUSH
52130: LD_INT 1
52132: ARRAY
52133: PPUSH
52134: CALL 47457 0 2
52138: GO 52164
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52140: LD_VAR 0 4
52144: PUSH
52145: LD_VAR 0 7
52149: ARRAY
52150: PPUSH
52151: LD_VAR 0 14
52155: PUSH
52156: LD_INT 1
52158: ARRAY
52159: PPUSH
52160: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52164: LD_VAR 0 4
52168: PUSH
52169: LD_VAR 0 7
52173: ARRAY
52174: PPUSH
52175: CALL_OW 264
52179: PUSH
52180: LD_INT 29
52182: EQUAL
52183: IFFALSE 52549
// begin if WantsToAttack ( group [ i ] ) in bombed then
52185: LD_VAR 0 4
52189: PUSH
52190: LD_VAR 0 7
52194: ARRAY
52195: PPUSH
52196: CALL_OW 319
52200: PUSH
52201: LD_VAR 0 28
52205: IN
52206: IFFALSE 52210
// continue ;
52208: GO 49240
// k := 8 ;
52210: LD_ADDR_VAR 0 9
52214: PUSH
52215: LD_INT 8
52217: ST_TO_ADDR
// x := 0 ;
52218: LD_ADDR_VAR 0 10
52222: PUSH
52223: LD_INT 0
52225: ST_TO_ADDR
// if tmp < k then
52226: LD_VAR 0 14
52230: PUSH
52231: LD_VAR 0 9
52235: LESS
52236: IFFALSE 52248
// k := tmp ;
52238: LD_ADDR_VAR 0 9
52242: PUSH
52243: LD_VAR 0 14
52247: ST_TO_ADDR
// for j = 1 to k do
52248: LD_ADDR_VAR 0 8
52252: PUSH
52253: DOUBLE
52254: LD_INT 1
52256: DEC
52257: ST_TO_ADDR
52258: LD_VAR 0 9
52262: PUSH
52263: FOR_TO
52264: IFFALSE 52396
// begin if GetType ( tmp [ j ] ) = unit_building then
52266: LD_VAR 0 14
52270: PUSH
52271: LD_VAR 0 8
52275: ARRAY
52276: PPUSH
52277: CALL_OW 247
52281: PUSH
52282: LD_INT 3
52284: EQUAL
52285: IFFALSE 52394
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52287: LD_VAR 0 14
52291: PUSH
52292: LD_VAR 0 8
52296: ARRAY
52297: PUSH
52298: LD_VAR 0 28
52302: IN
52303: NOT
52304: PUSH
52305: LD_VAR 0 14
52309: PUSH
52310: LD_VAR 0 8
52314: ARRAY
52315: PPUSH
52316: CALL_OW 313
52320: AND
52321: IFFALSE 52394
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52323: LD_VAR 0 4
52327: PUSH
52328: LD_VAR 0 7
52332: ARRAY
52333: PPUSH
52334: LD_VAR 0 14
52338: PUSH
52339: LD_VAR 0 8
52343: ARRAY
52344: PPUSH
52345: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52349: LD_ADDR_VAR 0 28
52353: PUSH
52354: LD_VAR 0 28
52358: PPUSH
52359: LD_VAR 0 28
52363: PUSH
52364: LD_INT 1
52366: PLUS
52367: PPUSH
52368: LD_VAR 0 14
52372: PUSH
52373: LD_VAR 0 8
52377: ARRAY
52378: PPUSH
52379: CALL_OW 1
52383: ST_TO_ADDR
// attacking := true ;
52384: LD_ADDR_VAR 0 29
52388: PUSH
52389: LD_INT 1
52391: ST_TO_ADDR
// break ;
52392: GO 52396
// end ; end ;
52394: GO 52263
52396: POP
52397: POP
// if not attacking and f_attack_depot then
52398: LD_VAR 0 29
52402: NOT
52403: PUSH
52404: LD_VAR 0 25
52408: AND
52409: IFFALSE 52504
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52411: LD_ADDR_VAR 0 13
52415: PUSH
52416: LD_VAR 0 14
52420: PPUSH
52421: LD_INT 2
52423: PUSH
52424: LD_INT 30
52426: PUSH
52427: LD_INT 0
52429: PUSH
52430: EMPTY
52431: LIST
52432: LIST
52433: PUSH
52434: LD_INT 30
52436: PUSH
52437: LD_INT 1
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: LIST
52448: PPUSH
52449: CALL_OW 72
52453: ST_TO_ADDR
// if z then
52454: LD_VAR 0 13
52458: IFFALSE 52504
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52460: LD_VAR 0 4
52464: PUSH
52465: LD_VAR 0 7
52469: ARRAY
52470: PPUSH
52471: LD_VAR 0 13
52475: PPUSH
52476: LD_VAR 0 4
52480: PUSH
52481: LD_VAR 0 7
52485: ARRAY
52486: PPUSH
52487: CALL_OW 74
52491: PPUSH
52492: CALL_OW 115
// attacking := true ;
52496: LD_ADDR_VAR 0 29
52500: PUSH
52501: LD_INT 1
52503: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52504: LD_VAR 0 4
52508: PUSH
52509: LD_VAR 0 7
52513: ARRAY
52514: PPUSH
52515: CALL_OW 256
52519: PUSH
52520: LD_INT 500
52522: LESS
52523: IFFALSE 52549
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52525: LD_VAR 0 4
52529: PUSH
52530: LD_VAR 0 7
52534: ARRAY
52535: PPUSH
52536: LD_VAR 0 14
52540: PUSH
52541: LD_INT 1
52543: ARRAY
52544: PPUSH
52545: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52549: LD_VAR 0 4
52553: PUSH
52554: LD_VAR 0 7
52558: ARRAY
52559: PPUSH
52560: CALL_OW 264
52564: PUSH
52565: LD_INT 49
52567: EQUAL
52568: IFFALSE 52689
// begin if not HasTask ( group [ i ] ) then
52570: LD_VAR 0 4
52574: PUSH
52575: LD_VAR 0 7
52579: ARRAY
52580: PPUSH
52581: CALL_OW 314
52585: NOT
52586: IFFALSE 52689
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52588: LD_ADDR_VAR 0 9
52592: PUSH
52593: LD_INT 81
52595: PUSH
52596: LD_VAR 0 4
52600: PUSH
52601: LD_VAR 0 7
52605: ARRAY
52606: PPUSH
52607: CALL_OW 255
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: PPUSH
52616: CALL_OW 69
52620: PPUSH
52621: LD_VAR 0 4
52625: PUSH
52626: LD_VAR 0 7
52630: ARRAY
52631: PPUSH
52632: CALL_OW 74
52636: ST_TO_ADDR
// if k then
52637: LD_VAR 0 9
52641: IFFALSE 52689
// if GetDistUnits ( group [ i ] , k ) > 10 then
52643: LD_VAR 0 4
52647: PUSH
52648: LD_VAR 0 7
52652: ARRAY
52653: PPUSH
52654: LD_VAR 0 9
52658: PPUSH
52659: CALL_OW 296
52663: PUSH
52664: LD_INT 10
52666: GREATER
52667: IFFALSE 52689
// ComMoveUnit ( group [ i ] , k ) ;
52669: LD_VAR 0 4
52673: PUSH
52674: LD_VAR 0 7
52678: ARRAY
52679: PPUSH
52680: LD_VAR 0 9
52684: PPUSH
52685: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52689: LD_VAR 0 4
52693: PUSH
52694: LD_VAR 0 7
52698: ARRAY
52699: PPUSH
52700: CALL_OW 256
52704: PUSH
52705: LD_INT 250
52707: LESS
52708: PUSH
52709: LD_VAR 0 4
52713: PUSH
52714: LD_VAR 0 7
52718: ARRAY
52719: PUSH
52720: LD_INT 21
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PUSH
52730: LD_INT 23
52732: PUSH
52733: LD_INT 2
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PPUSH
52744: CALL_OW 69
52748: IN
52749: AND
52750: IFFALSE 52875
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
52752: LD_ADDR_VAR 0 9
52756: PUSH
52757: LD_OWVAR 3
52761: PUSH
52762: LD_VAR 0 4
52766: PUSH
52767: LD_VAR 0 7
52771: ARRAY
52772: DIFF
52773: PPUSH
52774: LD_VAR 0 4
52778: PUSH
52779: LD_VAR 0 7
52783: ARRAY
52784: PPUSH
52785: CALL_OW 74
52789: ST_TO_ADDR
// if not k then
52790: LD_VAR 0 9
52794: NOT
52795: IFFALSE 52799
// continue ;
52797: GO 49240
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
52799: LD_VAR 0 9
52803: PUSH
52804: LD_INT 81
52806: PUSH
52807: LD_VAR 0 4
52811: PUSH
52812: LD_VAR 0 7
52816: ARRAY
52817: PPUSH
52818: CALL_OW 255
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PPUSH
52827: CALL_OW 69
52831: IN
52832: PUSH
52833: LD_VAR 0 9
52837: PPUSH
52838: LD_VAR 0 4
52842: PUSH
52843: LD_VAR 0 7
52847: ARRAY
52848: PPUSH
52849: CALL_OW 296
52853: PUSH
52854: LD_INT 5
52856: LESS
52857: AND
52858: IFFALSE 52875
// ComAutodestruct ( group [ i ] ) ;
52860: LD_VAR 0 4
52864: PUSH
52865: LD_VAR 0 7
52869: ARRAY
52870: PPUSH
52871: CALL 47355 0 1
// end ; if f_attack_depot then
52875: LD_VAR 0 25
52879: IFFALSE 52991
// begin k := 6 ;
52881: LD_ADDR_VAR 0 9
52885: PUSH
52886: LD_INT 6
52888: ST_TO_ADDR
// if tmp < k then
52889: LD_VAR 0 14
52893: PUSH
52894: LD_VAR 0 9
52898: LESS
52899: IFFALSE 52911
// k := tmp ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_VAR 0 14
52910: ST_TO_ADDR
// for j = 1 to k do
52911: LD_ADDR_VAR 0 8
52915: PUSH
52916: DOUBLE
52917: LD_INT 1
52919: DEC
52920: ST_TO_ADDR
52921: LD_VAR 0 9
52925: PUSH
52926: FOR_TO
52927: IFFALSE 52989
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
52929: LD_VAR 0 8
52933: PPUSH
52934: CALL_OW 266
52938: PUSH
52939: LD_INT 0
52941: PUSH
52942: LD_INT 1
52944: PUSH
52945: EMPTY
52946: LIST
52947: LIST
52948: IN
52949: IFFALSE 52987
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52951: LD_VAR 0 4
52955: PUSH
52956: LD_VAR 0 7
52960: ARRAY
52961: PPUSH
52962: LD_VAR 0 14
52966: PUSH
52967: LD_VAR 0 8
52971: ARRAY
52972: PPUSH
52973: CALL_OW 115
// attacking := true ;
52977: LD_ADDR_VAR 0 29
52981: PUSH
52982: LD_INT 1
52984: ST_TO_ADDR
// break ;
52985: GO 52989
// end ;
52987: GO 52926
52989: POP
52990: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
52991: LD_VAR 0 4
52995: PUSH
52996: LD_VAR 0 7
53000: ARRAY
53001: PPUSH
53002: CALL_OW 302
53006: PUSH
53007: LD_VAR 0 29
53011: NOT
53012: AND
53013: IFFALSE 53335
// begin if GetTag ( group [ i ] ) = 71 then
53015: LD_VAR 0 4
53019: PUSH
53020: LD_VAR 0 7
53024: ARRAY
53025: PPUSH
53026: CALL_OW 110
53030: PUSH
53031: LD_INT 71
53033: EQUAL
53034: IFFALSE 53075
// begin if HasTask ( group [ i ] ) then
53036: LD_VAR 0 4
53040: PUSH
53041: LD_VAR 0 7
53045: ARRAY
53046: PPUSH
53047: CALL_OW 314
53051: IFFALSE 53057
// continue else
53053: GO 49240
53055: GO 53075
// SetTag ( group [ i ] , 0 ) ;
53057: LD_VAR 0 4
53061: PUSH
53062: LD_VAR 0 7
53066: ARRAY
53067: PPUSH
53068: LD_INT 0
53070: PPUSH
53071: CALL_OW 109
// end ; k := 8 ;
53075: LD_ADDR_VAR 0 9
53079: PUSH
53080: LD_INT 8
53082: ST_TO_ADDR
// x := 0 ;
53083: LD_ADDR_VAR 0 10
53087: PUSH
53088: LD_INT 0
53090: ST_TO_ADDR
// if tmp < k then
53091: LD_VAR 0 14
53095: PUSH
53096: LD_VAR 0 9
53100: LESS
53101: IFFALSE 53113
// k := tmp ;
53103: LD_ADDR_VAR 0 9
53107: PUSH
53108: LD_VAR 0 14
53112: ST_TO_ADDR
// for j = 1 to k do
53113: LD_ADDR_VAR 0 8
53117: PUSH
53118: DOUBLE
53119: LD_INT 1
53121: DEC
53122: ST_TO_ADDR
53123: LD_VAR 0 9
53127: PUSH
53128: FOR_TO
53129: IFFALSE 53227
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53131: LD_VAR 0 14
53135: PUSH
53136: LD_VAR 0 8
53140: ARRAY
53141: PPUSH
53142: CALL_OW 247
53146: PUSH
53147: LD_INT 1
53149: EQUAL
53150: PUSH
53151: LD_VAR 0 14
53155: PUSH
53156: LD_VAR 0 8
53160: ARRAY
53161: PPUSH
53162: CALL_OW 256
53166: PUSH
53167: LD_INT 250
53169: LESS
53170: PUSH
53171: LD_VAR 0 20
53175: AND
53176: PUSH
53177: LD_VAR 0 20
53181: NOT
53182: PUSH
53183: LD_VAR 0 14
53187: PUSH
53188: LD_VAR 0 8
53192: ARRAY
53193: PPUSH
53194: CALL_OW 256
53198: PUSH
53199: LD_INT 250
53201: GREATEREQUAL
53202: AND
53203: OR
53204: AND
53205: IFFALSE 53225
// begin x := tmp [ j ] ;
53207: LD_ADDR_VAR 0 10
53211: PUSH
53212: LD_VAR 0 14
53216: PUSH
53217: LD_VAR 0 8
53221: ARRAY
53222: ST_TO_ADDR
// break ;
53223: GO 53227
// end ;
53225: GO 53128
53227: POP
53228: POP
// if x then
53229: LD_VAR 0 10
53233: IFFALSE 53257
// ComAttackUnit ( group [ i ] , x ) else
53235: LD_VAR 0 4
53239: PUSH
53240: LD_VAR 0 7
53244: ARRAY
53245: PPUSH
53246: LD_VAR 0 10
53250: PPUSH
53251: CALL_OW 115
53255: GO 53281
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53257: LD_VAR 0 4
53261: PUSH
53262: LD_VAR 0 7
53266: ARRAY
53267: PPUSH
53268: LD_VAR 0 14
53272: PUSH
53273: LD_INT 1
53275: ARRAY
53276: PPUSH
53277: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53281: LD_VAR 0 4
53285: PUSH
53286: LD_VAR 0 7
53290: ARRAY
53291: PPUSH
53292: CALL_OW 314
53296: NOT
53297: IFFALSE 53335
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53299: LD_VAR 0 4
53303: PUSH
53304: LD_VAR 0 7
53308: ARRAY
53309: PPUSH
53310: LD_VAR 0 14
53314: PPUSH
53315: LD_VAR 0 4
53319: PUSH
53320: LD_VAR 0 7
53324: ARRAY
53325: PPUSH
53326: CALL_OW 74
53330: PPUSH
53331: CALL_OW 115
// end ; end ; end ;
53335: GO 49240
53337: POP
53338: POP
// wait ( 0 0$1 ) ;
53339: LD_INT 35
53341: PPUSH
53342: CALL_OW 67
// until group = [ ] ;
53346: LD_VAR 0 4
53350: PUSH
53351: EMPTY
53352: EQUAL
53353: IFFALSE 49225
// end ;
53355: LD_VAR 0 2
53359: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53360: LD_INT 0
53362: PPUSH
53363: PPUSH
53364: PPUSH
53365: PPUSH
// if not base_units then
53366: LD_VAR 0 1
53370: NOT
53371: IFFALSE 53375
// exit ;
53373: GO 53462
// result := false ;
53375: LD_ADDR_VAR 0 2
53379: PUSH
53380: LD_INT 0
53382: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53383: LD_ADDR_VAR 0 5
53387: PUSH
53388: LD_VAR 0 1
53392: PPUSH
53393: LD_INT 21
53395: PUSH
53396: LD_INT 3
53398: PUSH
53399: EMPTY
53400: LIST
53401: LIST
53402: PPUSH
53403: CALL_OW 72
53407: ST_TO_ADDR
// if not tmp then
53408: LD_VAR 0 5
53412: NOT
53413: IFFALSE 53417
// exit ;
53415: GO 53462
// for i in tmp do
53417: LD_ADDR_VAR 0 3
53421: PUSH
53422: LD_VAR 0 5
53426: PUSH
53427: FOR_IN
53428: IFFALSE 53460
// begin result := EnemyInRange ( i , 22 ) ;
53430: LD_ADDR_VAR 0 2
53434: PUSH
53435: LD_VAR 0 3
53439: PPUSH
53440: LD_INT 22
53442: PPUSH
53443: CALL 47038 0 2
53447: ST_TO_ADDR
// if result then
53448: LD_VAR 0 2
53452: IFFALSE 53458
// exit ;
53454: POP
53455: POP
53456: GO 53462
// end ;
53458: GO 53427
53460: POP
53461: POP
// end ;
53462: LD_VAR 0 2
53466: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53467: LD_INT 0
53469: PPUSH
53470: PPUSH
// if not units then
53471: LD_VAR 0 1
53475: NOT
53476: IFFALSE 53480
// exit ;
53478: GO 53550
// result := [ ] ;
53480: LD_ADDR_VAR 0 3
53484: PUSH
53485: EMPTY
53486: ST_TO_ADDR
// for i in units do
53487: LD_ADDR_VAR 0 4
53491: PUSH
53492: LD_VAR 0 1
53496: PUSH
53497: FOR_IN
53498: IFFALSE 53548
// if GetTag ( i ) = tag then
53500: LD_VAR 0 4
53504: PPUSH
53505: CALL_OW 110
53509: PUSH
53510: LD_VAR 0 2
53514: EQUAL
53515: IFFALSE 53546
// result := Insert ( result , result + 1 , i ) ;
53517: LD_ADDR_VAR 0 3
53521: PUSH
53522: LD_VAR 0 3
53526: PPUSH
53527: LD_VAR 0 3
53531: PUSH
53532: LD_INT 1
53534: PLUS
53535: PPUSH
53536: LD_VAR 0 4
53540: PPUSH
53541: CALL_OW 2
53545: ST_TO_ADDR
53546: GO 53497
53548: POP
53549: POP
// end ;
53550: LD_VAR 0 3
53554: RET
// export function IsDriver ( un ) ; begin
53555: LD_INT 0
53557: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53558: LD_ADDR_VAR 0 2
53562: PUSH
53563: LD_VAR 0 1
53567: PUSH
53568: LD_INT 55
53570: PUSH
53571: EMPTY
53572: LIST
53573: PPUSH
53574: CALL_OW 69
53578: IN
53579: ST_TO_ADDR
// end ;
53580: LD_VAR 0 2
53584: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53585: LD_INT 0
53587: PPUSH
53588: PPUSH
// list := [ ] ;
53589: LD_ADDR_VAR 0 5
53593: PUSH
53594: EMPTY
53595: ST_TO_ADDR
// case d of 0 :
53596: LD_VAR 0 3
53600: PUSH
53601: LD_INT 0
53603: DOUBLE
53604: EQUAL
53605: IFTRUE 53609
53607: GO 53742
53609: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53610: LD_ADDR_VAR 0 5
53614: PUSH
53615: LD_VAR 0 1
53619: PUSH
53620: LD_INT 4
53622: MINUS
53623: PUSH
53624: LD_VAR 0 2
53628: PUSH
53629: LD_INT 4
53631: MINUS
53632: PUSH
53633: LD_INT 2
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: LIST
53640: PUSH
53641: LD_VAR 0 1
53645: PUSH
53646: LD_INT 3
53648: MINUS
53649: PUSH
53650: LD_VAR 0 2
53654: PUSH
53655: LD_INT 1
53657: PUSH
53658: EMPTY
53659: LIST
53660: LIST
53661: LIST
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_INT 4
53670: PLUS
53671: PUSH
53672: LD_VAR 0 2
53676: PUSH
53677: LD_INT 4
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: LIST
53684: PUSH
53685: LD_VAR 0 1
53689: PUSH
53690: LD_INT 3
53692: PLUS
53693: PUSH
53694: LD_VAR 0 2
53698: PUSH
53699: LD_INT 3
53701: PLUS
53702: PUSH
53703: LD_INT 5
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: LIST
53710: PUSH
53711: LD_VAR 0 1
53715: PUSH
53716: LD_VAR 0 2
53720: PUSH
53721: LD_INT 4
53723: PLUS
53724: PUSH
53725: LD_INT 0
53727: PUSH
53728: EMPTY
53729: LIST
53730: LIST
53731: LIST
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: LIST
53737: LIST
53738: LIST
53739: ST_TO_ADDR
// end ; 1 :
53740: GO 54440
53742: LD_INT 1
53744: DOUBLE
53745: EQUAL
53746: IFTRUE 53750
53748: GO 53883
53750: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53751: LD_ADDR_VAR 0 5
53755: PUSH
53756: LD_VAR 0 1
53760: PUSH
53761: LD_VAR 0 2
53765: PUSH
53766: LD_INT 4
53768: MINUS
53769: PUSH
53770: LD_INT 3
53772: PUSH
53773: EMPTY
53774: LIST
53775: LIST
53776: LIST
53777: PUSH
53778: LD_VAR 0 1
53782: PUSH
53783: LD_INT 3
53785: MINUS
53786: PUSH
53787: LD_VAR 0 2
53791: PUSH
53792: LD_INT 3
53794: MINUS
53795: PUSH
53796: LD_INT 2
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: LIST
53803: PUSH
53804: LD_VAR 0 1
53808: PUSH
53809: LD_INT 4
53811: MINUS
53812: PUSH
53813: LD_VAR 0 2
53817: PUSH
53818: LD_INT 1
53820: PUSH
53821: EMPTY
53822: LIST
53823: LIST
53824: LIST
53825: PUSH
53826: LD_VAR 0 1
53830: PUSH
53831: LD_VAR 0 2
53835: PUSH
53836: LD_INT 3
53838: PLUS
53839: PUSH
53840: LD_INT 0
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: LIST
53847: PUSH
53848: LD_VAR 0 1
53852: PUSH
53853: LD_INT 4
53855: PLUS
53856: PUSH
53857: LD_VAR 0 2
53861: PUSH
53862: LD_INT 4
53864: PLUS
53865: PUSH
53866: LD_INT 5
53868: PUSH
53869: EMPTY
53870: LIST
53871: LIST
53872: LIST
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: LIST
53878: LIST
53879: LIST
53880: ST_TO_ADDR
// end ; 2 :
53881: GO 54440
53883: LD_INT 2
53885: DOUBLE
53886: EQUAL
53887: IFTRUE 53891
53889: GO 54020
53891: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53892: LD_ADDR_VAR 0 5
53896: PUSH
53897: LD_VAR 0 1
53901: PUSH
53902: LD_VAR 0 2
53906: PUSH
53907: LD_INT 3
53909: MINUS
53910: PUSH
53911: LD_INT 3
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: LIST
53918: PUSH
53919: LD_VAR 0 1
53923: PUSH
53924: LD_INT 4
53926: PLUS
53927: PUSH
53928: LD_VAR 0 2
53932: PUSH
53933: LD_INT 4
53935: PUSH
53936: EMPTY
53937: LIST
53938: LIST
53939: LIST
53940: PUSH
53941: LD_VAR 0 1
53945: PUSH
53946: LD_VAR 0 2
53950: PUSH
53951: LD_INT 4
53953: PLUS
53954: PUSH
53955: LD_INT 0
53957: PUSH
53958: EMPTY
53959: LIST
53960: LIST
53961: LIST
53962: PUSH
53963: LD_VAR 0 1
53967: PUSH
53968: LD_INT 3
53970: MINUS
53971: PUSH
53972: LD_VAR 0 2
53976: PUSH
53977: LD_INT 1
53979: PUSH
53980: EMPTY
53981: LIST
53982: LIST
53983: LIST
53984: PUSH
53985: LD_VAR 0 1
53989: PUSH
53990: LD_INT 4
53992: MINUS
53993: PUSH
53994: LD_VAR 0 2
53998: PUSH
53999: LD_INT 4
54001: MINUS
54002: PUSH
54003: LD_INT 2
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: LIST
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: ST_TO_ADDR
// end ; 3 :
54018: GO 54440
54020: LD_INT 3
54022: DOUBLE
54023: EQUAL
54024: IFTRUE 54028
54026: GO 54161
54028: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54029: LD_ADDR_VAR 0 5
54033: PUSH
54034: LD_VAR 0 1
54038: PUSH
54039: LD_INT 3
54041: PLUS
54042: PUSH
54043: LD_VAR 0 2
54047: PUSH
54048: LD_INT 4
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: LIST
54055: PUSH
54056: LD_VAR 0 1
54060: PUSH
54061: LD_INT 4
54063: PLUS
54064: PUSH
54065: LD_VAR 0 2
54069: PUSH
54070: LD_INT 4
54072: PLUS
54073: PUSH
54074: LD_INT 5
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: LIST
54081: PUSH
54082: LD_VAR 0 1
54086: PUSH
54087: LD_INT 4
54089: MINUS
54090: PUSH
54091: LD_VAR 0 2
54095: PUSH
54096: LD_INT 1
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: LIST
54103: PUSH
54104: LD_VAR 0 1
54108: PUSH
54109: LD_VAR 0 2
54113: PUSH
54114: LD_INT 4
54116: MINUS
54117: PUSH
54118: LD_INT 3
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: LIST
54125: PUSH
54126: LD_VAR 0 1
54130: PUSH
54131: LD_INT 3
54133: MINUS
54134: PUSH
54135: LD_VAR 0 2
54139: PUSH
54140: LD_INT 3
54142: MINUS
54143: PUSH
54144: LD_INT 2
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: LIST
54157: LIST
54158: ST_TO_ADDR
// end ; 4 :
54159: GO 54440
54161: LD_INT 4
54163: DOUBLE
54164: EQUAL
54165: IFTRUE 54169
54167: GO 54302
54169: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54170: LD_ADDR_VAR 0 5
54174: PUSH
54175: LD_VAR 0 1
54179: PUSH
54180: LD_VAR 0 2
54184: PUSH
54185: LD_INT 4
54187: PLUS
54188: PUSH
54189: LD_INT 0
54191: PUSH
54192: EMPTY
54193: LIST
54194: LIST
54195: LIST
54196: PUSH
54197: LD_VAR 0 1
54201: PUSH
54202: LD_INT 3
54204: PLUS
54205: PUSH
54206: LD_VAR 0 2
54210: PUSH
54211: LD_INT 3
54213: PLUS
54214: PUSH
54215: LD_INT 5
54217: PUSH
54218: EMPTY
54219: LIST
54220: LIST
54221: LIST
54222: PUSH
54223: LD_VAR 0 1
54227: PUSH
54228: LD_INT 4
54230: PLUS
54231: PUSH
54232: LD_VAR 0 2
54236: PUSH
54237: LD_INT 4
54239: PUSH
54240: EMPTY
54241: LIST
54242: LIST
54243: LIST
54244: PUSH
54245: LD_VAR 0 1
54249: PUSH
54250: LD_VAR 0 2
54254: PUSH
54255: LD_INT 3
54257: MINUS
54258: PUSH
54259: LD_INT 3
54261: PUSH
54262: EMPTY
54263: LIST
54264: LIST
54265: LIST
54266: PUSH
54267: LD_VAR 0 1
54271: PUSH
54272: LD_INT 4
54274: MINUS
54275: PUSH
54276: LD_VAR 0 2
54280: PUSH
54281: LD_INT 4
54283: MINUS
54284: PUSH
54285: LD_INT 2
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: LIST
54292: PUSH
54293: EMPTY
54294: LIST
54295: LIST
54296: LIST
54297: LIST
54298: LIST
54299: ST_TO_ADDR
// end ; 5 :
54300: GO 54440
54302: LD_INT 5
54304: DOUBLE
54305: EQUAL
54306: IFTRUE 54310
54308: GO 54439
54310: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54311: LD_ADDR_VAR 0 5
54315: PUSH
54316: LD_VAR 0 1
54320: PUSH
54321: LD_INT 4
54323: MINUS
54324: PUSH
54325: LD_VAR 0 2
54329: PUSH
54330: LD_INT 1
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: LIST
54337: PUSH
54338: LD_VAR 0 1
54342: PUSH
54343: LD_VAR 0 2
54347: PUSH
54348: LD_INT 4
54350: MINUS
54351: PUSH
54352: LD_INT 3
54354: PUSH
54355: EMPTY
54356: LIST
54357: LIST
54358: LIST
54359: PUSH
54360: LD_VAR 0 1
54364: PUSH
54365: LD_INT 4
54367: PLUS
54368: PUSH
54369: LD_VAR 0 2
54373: PUSH
54374: LD_INT 4
54376: PLUS
54377: PUSH
54378: LD_INT 5
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: LIST
54385: PUSH
54386: LD_VAR 0 1
54390: PUSH
54391: LD_INT 3
54393: PLUS
54394: PUSH
54395: LD_VAR 0 2
54399: PUSH
54400: LD_INT 4
54402: PUSH
54403: EMPTY
54404: LIST
54405: LIST
54406: LIST
54407: PUSH
54408: LD_VAR 0 1
54412: PUSH
54413: LD_VAR 0 2
54417: PUSH
54418: LD_INT 3
54420: PLUS
54421: PUSH
54422: LD_INT 0
54424: PUSH
54425: EMPTY
54426: LIST
54427: LIST
54428: LIST
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: LIST
54434: LIST
54435: LIST
54436: ST_TO_ADDR
// end ; end ;
54437: GO 54440
54439: POP
// result := list ;
54440: LD_ADDR_VAR 0 4
54444: PUSH
54445: LD_VAR 0 5
54449: ST_TO_ADDR
// end ;
54450: LD_VAR 0 4
54454: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54455: LD_INT 0
54457: PPUSH
54458: PPUSH
54459: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54460: LD_VAR 0 1
54464: NOT
54465: PUSH
54466: LD_VAR 0 2
54470: PUSH
54471: LD_INT 1
54473: PUSH
54474: LD_INT 2
54476: PUSH
54477: LD_INT 3
54479: PUSH
54480: LD_INT 4
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: LIST
54487: LIST
54488: IN
54489: NOT
54490: OR
54491: IFFALSE 54495
// exit ;
54493: GO 54587
// tmp := [ ] ;
54495: LD_ADDR_VAR 0 5
54499: PUSH
54500: EMPTY
54501: ST_TO_ADDR
// for i in units do
54502: LD_ADDR_VAR 0 4
54506: PUSH
54507: LD_VAR 0 1
54511: PUSH
54512: FOR_IN
54513: IFFALSE 54556
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54515: LD_ADDR_VAR 0 5
54519: PUSH
54520: LD_VAR 0 5
54524: PPUSH
54525: LD_VAR 0 5
54529: PUSH
54530: LD_INT 1
54532: PLUS
54533: PPUSH
54534: LD_VAR 0 4
54538: PPUSH
54539: LD_VAR 0 2
54543: PPUSH
54544: CALL_OW 259
54548: PPUSH
54549: CALL_OW 2
54553: ST_TO_ADDR
54554: GO 54512
54556: POP
54557: POP
// if not tmp then
54558: LD_VAR 0 5
54562: NOT
54563: IFFALSE 54567
// exit ;
54565: GO 54587
// result := SortListByListDesc ( units , tmp ) ;
54567: LD_ADDR_VAR 0 3
54571: PUSH
54572: LD_VAR 0 1
54576: PPUSH
54577: LD_VAR 0 5
54581: PPUSH
54582: CALL_OW 77
54586: ST_TO_ADDR
// end ;
54587: LD_VAR 0 3
54591: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
// x := GetX ( building ) ;
54597: LD_ADDR_VAR 0 4
54601: PUSH
54602: LD_VAR 0 2
54606: PPUSH
54607: CALL_OW 250
54611: ST_TO_ADDR
// y := GetY ( building ) ;
54612: LD_ADDR_VAR 0 5
54616: PUSH
54617: LD_VAR 0 2
54621: PPUSH
54622: CALL_OW 251
54626: ST_TO_ADDR
// if GetTaskList ( unit ) then
54627: LD_VAR 0 1
54631: PPUSH
54632: CALL_OW 437
54636: IFFALSE 54731
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54638: LD_STRING e
54640: PUSH
54641: LD_VAR 0 1
54645: PPUSH
54646: CALL_OW 437
54650: PUSH
54651: LD_INT 1
54653: ARRAY
54654: PUSH
54655: LD_INT 1
54657: ARRAY
54658: EQUAL
54659: PUSH
54660: LD_VAR 0 4
54664: PUSH
54665: LD_VAR 0 1
54669: PPUSH
54670: CALL_OW 437
54674: PUSH
54675: LD_INT 1
54677: ARRAY
54678: PUSH
54679: LD_INT 2
54681: ARRAY
54682: EQUAL
54683: AND
54684: PUSH
54685: LD_VAR 0 5
54689: PUSH
54690: LD_VAR 0 1
54694: PPUSH
54695: CALL_OW 437
54699: PUSH
54700: LD_INT 1
54702: ARRAY
54703: PUSH
54704: LD_INT 3
54706: ARRAY
54707: EQUAL
54708: AND
54709: IFFALSE 54721
// result := true else
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_INT 1
54718: ST_TO_ADDR
54719: GO 54729
// result := false ;
54721: LD_ADDR_VAR 0 3
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// end else
54729: GO 54739
// result := false ;
54731: LD_ADDR_VAR 0 3
54735: PUSH
54736: LD_INT 0
54738: ST_TO_ADDR
// end ;
54739: LD_VAR 0 3
54743: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54744: LD_INT 0
54746: PPUSH
54747: PPUSH
54748: PPUSH
54749: PPUSH
// if not unit or not area then
54750: LD_VAR 0 1
54754: NOT
54755: PUSH
54756: LD_VAR 0 2
54760: NOT
54761: OR
54762: IFFALSE 54766
// exit ;
54764: GO 54931
// tmp := AreaToList ( area , i ) ;
54766: LD_ADDR_VAR 0 6
54770: PUSH
54771: LD_VAR 0 2
54775: PPUSH
54776: LD_VAR 0 5
54780: PPUSH
54781: CALL_OW 517
54785: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54786: LD_ADDR_VAR 0 5
54790: PUSH
54791: DOUBLE
54792: LD_INT 1
54794: DEC
54795: ST_TO_ADDR
54796: LD_VAR 0 6
54800: PUSH
54801: LD_INT 1
54803: ARRAY
54804: PUSH
54805: FOR_TO
54806: IFFALSE 54921
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54808: LD_ADDR_VAR 0 7
54812: PUSH
54813: LD_VAR 0 6
54817: PUSH
54818: LD_INT 1
54820: ARRAY
54821: PUSH
54822: LD_VAR 0 5
54826: ARRAY
54827: PUSH
54828: LD_VAR 0 6
54832: PUSH
54833: LD_INT 2
54835: ARRAY
54836: PUSH
54837: LD_VAR 0 5
54841: ARRAY
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54847: LD_VAR 0 7
54851: PUSH
54852: LD_INT 1
54854: ARRAY
54855: PPUSH
54856: LD_VAR 0 7
54860: PUSH
54861: LD_INT 2
54863: ARRAY
54864: PPUSH
54865: CALL_OW 428
54869: PUSH
54870: LD_INT 0
54872: EQUAL
54873: IFFALSE 54919
// begin result := true ;
54875: LD_ADDR_VAR 0 4
54879: PUSH
54880: LD_INT 1
54882: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54883: LD_VAR 0 1
54887: PPUSH
54888: LD_VAR 0 7
54892: PUSH
54893: LD_INT 1
54895: ARRAY
54896: PPUSH
54897: LD_VAR 0 7
54901: PUSH
54902: LD_INT 2
54904: ARRAY
54905: PPUSH
54906: LD_VAR 0 3
54910: PPUSH
54911: CALL_OW 48
// exit ;
54915: POP
54916: POP
54917: GO 54931
// end ; end ;
54919: GO 54805
54921: POP
54922: POP
// result := false ;
54923: LD_ADDR_VAR 0 4
54927: PUSH
54928: LD_INT 0
54930: ST_TO_ADDR
// end ;
54931: LD_VAR 0 4
54935: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54936: LD_INT 0
54938: PPUSH
54939: PPUSH
54940: PPUSH
// if not side or side > 8 then
54941: LD_VAR 0 1
54945: NOT
54946: PUSH
54947: LD_VAR 0 1
54951: PUSH
54952: LD_INT 8
54954: GREATER
54955: OR
54956: IFFALSE 54960
// exit ;
54958: GO 55147
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54960: LD_ADDR_VAR 0 4
54964: PUSH
54965: LD_INT 22
54967: PUSH
54968: LD_VAR 0 1
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: PUSH
54977: LD_INT 21
54979: PUSH
54980: LD_INT 3
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PPUSH
54991: CALL_OW 69
54995: ST_TO_ADDR
// if not tmp then
54996: LD_VAR 0 4
55000: NOT
55001: IFFALSE 55005
// exit ;
55003: GO 55147
// enable_addtolog := true ;
55005: LD_ADDR_OWVAR 81
55009: PUSH
55010: LD_INT 1
55012: ST_TO_ADDR
// AddToLog ( [ ) ;
55013: LD_STRING [
55015: PPUSH
55016: CALL_OW 561
// for i in tmp do
55020: LD_ADDR_VAR 0 3
55024: PUSH
55025: LD_VAR 0 4
55029: PUSH
55030: FOR_IN
55031: IFFALSE 55138
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55033: LD_STRING [
55035: PUSH
55036: LD_VAR 0 3
55040: PPUSH
55041: CALL_OW 266
55045: STR
55046: PUSH
55047: LD_STRING , 
55049: STR
55050: PUSH
55051: LD_VAR 0 3
55055: PPUSH
55056: CALL_OW 250
55060: STR
55061: PUSH
55062: LD_STRING , 
55064: STR
55065: PUSH
55066: LD_VAR 0 3
55070: PPUSH
55071: CALL_OW 251
55075: STR
55076: PUSH
55077: LD_STRING , 
55079: STR
55080: PUSH
55081: LD_VAR 0 3
55085: PPUSH
55086: CALL_OW 254
55090: STR
55091: PUSH
55092: LD_STRING , 
55094: STR
55095: PUSH
55096: LD_VAR 0 3
55100: PPUSH
55101: LD_INT 1
55103: PPUSH
55104: CALL_OW 268
55108: STR
55109: PUSH
55110: LD_STRING , 
55112: STR
55113: PUSH
55114: LD_VAR 0 3
55118: PPUSH
55119: LD_INT 2
55121: PPUSH
55122: CALL_OW 268
55126: STR
55127: PUSH
55128: LD_STRING ],
55130: STR
55131: PPUSH
55132: CALL_OW 561
// end ;
55136: GO 55030
55138: POP
55139: POP
// AddToLog ( ]; ) ;
55140: LD_STRING ];
55142: PPUSH
55143: CALL_OW 561
// end ;
55147: LD_VAR 0 2
55151: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55152: LD_INT 0
55154: PPUSH
55155: PPUSH
55156: PPUSH
55157: PPUSH
55158: PPUSH
// if not area or not rate or not max then
55159: LD_VAR 0 1
55163: NOT
55164: PUSH
55165: LD_VAR 0 2
55169: NOT
55170: OR
55171: PUSH
55172: LD_VAR 0 4
55176: NOT
55177: OR
55178: IFFALSE 55182
// exit ;
55180: GO 55374
// while 1 do
55182: LD_INT 1
55184: IFFALSE 55374
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55186: LD_ADDR_VAR 0 9
55190: PUSH
55191: LD_VAR 0 1
55195: PPUSH
55196: LD_INT 1
55198: PPUSH
55199: CALL_OW 287
55203: PUSH
55204: LD_INT 10
55206: MUL
55207: ST_TO_ADDR
// r := rate / 10 ;
55208: LD_ADDR_VAR 0 7
55212: PUSH
55213: LD_VAR 0 2
55217: PUSH
55218: LD_INT 10
55220: DIVREAL
55221: ST_TO_ADDR
// time := 1 1$00 ;
55222: LD_ADDR_VAR 0 8
55226: PUSH
55227: LD_INT 2100
55229: ST_TO_ADDR
// if amount < min then
55230: LD_VAR 0 9
55234: PUSH
55235: LD_VAR 0 3
55239: LESS
55240: IFFALSE 55258
// r := r * 2 else
55242: LD_ADDR_VAR 0 7
55246: PUSH
55247: LD_VAR 0 7
55251: PUSH
55252: LD_INT 2
55254: MUL
55255: ST_TO_ADDR
55256: GO 55284
// if amount > max then
55258: LD_VAR 0 9
55262: PUSH
55263: LD_VAR 0 4
55267: GREATER
55268: IFFALSE 55284
// r := r / 2 ;
55270: LD_ADDR_VAR 0 7
55274: PUSH
55275: LD_VAR 0 7
55279: PUSH
55280: LD_INT 2
55282: DIVREAL
55283: ST_TO_ADDR
// time := time / r ;
55284: LD_ADDR_VAR 0 8
55288: PUSH
55289: LD_VAR 0 8
55293: PUSH
55294: LD_VAR 0 7
55298: DIVREAL
55299: ST_TO_ADDR
// if time < 0 then
55300: LD_VAR 0 8
55304: PUSH
55305: LD_INT 0
55307: LESS
55308: IFFALSE 55325
// time := time * - 1 ;
55310: LD_ADDR_VAR 0 8
55314: PUSH
55315: LD_VAR 0 8
55319: PUSH
55320: LD_INT 1
55322: NEG
55323: MUL
55324: ST_TO_ADDR
// wait ( time ) ;
55325: LD_VAR 0 8
55329: PPUSH
55330: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55334: LD_INT 35
55336: PPUSH
55337: LD_INT 875
55339: PPUSH
55340: CALL_OW 12
55344: PPUSH
55345: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55349: LD_INT 1
55351: PPUSH
55352: LD_INT 5
55354: PPUSH
55355: CALL_OW 12
55359: PPUSH
55360: LD_VAR 0 1
55364: PPUSH
55365: LD_INT 1
55367: PPUSH
55368: CALL_OW 55
// end ;
55372: GO 55182
// end ;
55374: LD_VAR 0 5
55378: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55379: LD_INT 0
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
55385: PPUSH
55386: PPUSH
55387: PPUSH
55388: PPUSH
// if not turrets or not factories then
55389: LD_VAR 0 1
55393: NOT
55394: PUSH
55395: LD_VAR 0 2
55399: NOT
55400: OR
55401: IFFALSE 55405
// exit ;
55403: GO 55712
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55405: LD_ADDR_VAR 0 10
55409: PUSH
55410: LD_INT 5
55412: PUSH
55413: LD_INT 6
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: PUSH
55420: LD_INT 2
55422: PUSH
55423: LD_INT 4
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: PUSH
55430: LD_INT 3
55432: PUSH
55433: LD_INT 5
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: PUSH
55445: LD_INT 24
55447: PUSH
55448: LD_INT 25
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: PUSH
55455: LD_INT 23
55457: PUSH
55458: LD_INT 27
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 42
55471: PUSH
55472: LD_INT 43
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PUSH
55479: LD_INT 44
55481: PUSH
55482: LD_INT 46
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PUSH
55489: LD_INT 45
55491: PUSH
55492: LD_INT 47
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: LIST
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: ST_TO_ADDR
// result := [ ] ;
55509: LD_ADDR_VAR 0 3
55513: PUSH
55514: EMPTY
55515: ST_TO_ADDR
// for i in turrets do
55516: LD_ADDR_VAR 0 4
55520: PUSH
55521: LD_VAR 0 1
55525: PUSH
55526: FOR_IN
55527: IFFALSE 55710
// begin nat := GetNation ( i ) ;
55529: LD_ADDR_VAR 0 7
55533: PUSH
55534: LD_VAR 0 4
55538: PPUSH
55539: CALL_OW 248
55543: ST_TO_ADDR
// weapon := 0 ;
55544: LD_ADDR_VAR 0 8
55548: PUSH
55549: LD_INT 0
55551: ST_TO_ADDR
// if not nat then
55552: LD_VAR 0 7
55556: NOT
55557: IFFALSE 55561
// continue ;
55559: GO 55526
// for j in list [ nat ] do
55561: LD_ADDR_VAR 0 5
55565: PUSH
55566: LD_VAR 0 10
55570: PUSH
55571: LD_VAR 0 7
55575: ARRAY
55576: PUSH
55577: FOR_IN
55578: IFFALSE 55619
// if GetBWeapon ( i ) = j [ 1 ] then
55580: LD_VAR 0 4
55584: PPUSH
55585: CALL_OW 269
55589: PUSH
55590: LD_VAR 0 5
55594: PUSH
55595: LD_INT 1
55597: ARRAY
55598: EQUAL
55599: IFFALSE 55617
// begin weapon := j [ 2 ] ;
55601: LD_ADDR_VAR 0 8
55605: PUSH
55606: LD_VAR 0 5
55610: PUSH
55611: LD_INT 2
55613: ARRAY
55614: ST_TO_ADDR
// break ;
55615: GO 55619
// end ;
55617: GO 55577
55619: POP
55620: POP
// if not weapon then
55621: LD_VAR 0 8
55625: NOT
55626: IFFALSE 55630
// continue ;
55628: GO 55526
// for k in factories do
55630: LD_ADDR_VAR 0 6
55634: PUSH
55635: LD_VAR 0 2
55639: PUSH
55640: FOR_IN
55641: IFFALSE 55706
// begin weapons := AvailableWeaponList ( k ) ;
55643: LD_ADDR_VAR 0 9
55647: PUSH
55648: LD_VAR 0 6
55652: PPUSH
55653: CALL_OW 478
55657: ST_TO_ADDR
// if not weapons then
55658: LD_VAR 0 9
55662: NOT
55663: IFFALSE 55667
// continue ;
55665: GO 55640
// if weapon in weapons then
55667: LD_VAR 0 8
55671: PUSH
55672: LD_VAR 0 9
55676: IN
55677: IFFALSE 55704
// begin result := [ i , weapon ] ;
55679: LD_ADDR_VAR 0 3
55683: PUSH
55684: LD_VAR 0 4
55688: PUSH
55689: LD_VAR 0 8
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: ST_TO_ADDR
// exit ;
55698: POP
55699: POP
55700: POP
55701: POP
55702: GO 55712
// end ; end ;
55704: GO 55640
55706: POP
55707: POP
// end ;
55708: GO 55526
55710: POP
55711: POP
// end ;
55712: LD_VAR 0 3
55716: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55717: LD_INT 0
55719: PPUSH
// if not side or side > 8 then
55720: LD_VAR 0 3
55724: NOT
55725: PUSH
55726: LD_VAR 0 3
55730: PUSH
55731: LD_INT 8
55733: GREATER
55734: OR
55735: IFFALSE 55739
// exit ;
55737: GO 55798
// if not range then
55739: LD_VAR 0 4
55743: NOT
55744: IFFALSE 55755
// range := - 12 ;
55746: LD_ADDR_VAR 0 4
55750: PUSH
55751: LD_INT 12
55753: NEG
55754: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55755: LD_VAR 0 1
55759: PPUSH
55760: LD_VAR 0 2
55764: PPUSH
55765: LD_VAR 0 3
55769: PPUSH
55770: LD_VAR 0 4
55774: PPUSH
55775: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55779: LD_VAR 0 1
55783: PPUSH
55784: LD_VAR 0 2
55788: PPUSH
55789: LD_VAR 0 3
55793: PPUSH
55794: CALL_OW 331
// end ; end_of_file
55798: LD_VAR 0 5
55802: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
55803: LD_INT 0
55805: PPUSH
55806: PPUSH
// skirmish := false ;
55807: LD_ADDR_EXP 56
55811: PUSH
55812: LD_INT 0
55814: ST_TO_ADDR
// debug_mc := false ;
55815: LD_ADDR_EXP 57
55819: PUSH
55820: LD_INT 0
55822: ST_TO_ADDR
// mc_bases := [ ] ;
55823: LD_ADDR_EXP 58
55827: PUSH
55828: EMPTY
55829: ST_TO_ADDR
// mc_sides := [ ] ;
55830: LD_ADDR_EXP 84
55834: PUSH
55835: EMPTY
55836: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55837: LD_ADDR_EXP 59
55841: PUSH
55842: EMPTY
55843: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55844: LD_ADDR_EXP 60
55848: PUSH
55849: EMPTY
55850: ST_TO_ADDR
// mc_need_heal := [ ] ;
55851: LD_ADDR_EXP 61
55855: PUSH
55856: EMPTY
55857: ST_TO_ADDR
// mc_healers := [ ] ;
55858: LD_ADDR_EXP 62
55862: PUSH
55863: EMPTY
55864: ST_TO_ADDR
// mc_build_list := [ ] ;
55865: LD_ADDR_EXP 63
55869: PUSH
55870: EMPTY
55871: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55872: LD_ADDR_EXP 90
55876: PUSH
55877: EMPTY
55878: ST_TO_ADDR
// mc_builders := [ ] ;
55879: LD_ADDR_EXP 64
55883: PUSH
55884: EMPTY
55885: ST_TO_ADDR
// mc_construct_list := [ ] ;
55886: LD_ADDR_EXP 65
55890: PUSH
55891: EMPTY
55892: ST_TO_ADDR
// mc_turret_list := [ ] ;
55893: LD_ADDR_EXP 66
55897: PUSH
55898: EMPTY
55899: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55900: LD_ADDR_EXP 67
55904: PUSH
55905: EMPTY
55906: ST_TO_ADDR
// mc_miners := [ ] ;
55907: LD_ADDR_EXP 72
55911: PUSH
55912: EMPTY
55913: ST_TO_ADDR
// mc_mines := [ ] ;
55914: LD_ADDR_EXP 71
55918: PUSH
55919: EMPTY
55920: ST_TO_ADDR
// mc_minefields := [ ] ;
55921: LD_ADDR_EXP 73
55925: PUSH
55926: EMPTY
55927: ST_TO_ADDR
// mc_crates := [ ] ;
55928: LD_ADDR_EXP 74
55932: PUSH
55933: EMPTY
55934: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55935: LD_ADDR_EXP 75
55939: PUSH
55940: EMPTY
55941: ST_TO_ADDR
// mc_crates_area := [ ] ;
55942: LD_ADDR_EXP 76
55946: PUSH
55947: EMPTY
55948: ST_TO_ADDR
// mc_vehicles := [ ] ;
55949: LD_ADDR_EXP 77
55953: PUSH
55954: EMPTY
55955: ST_TO_ADDR
// mc_attack := [ ] ;
55956: LD_ADDR_EXP 78
55960: PUSH
55961: EMPTY
55962: ST_TO_ADDR
// mc_produce := [ ] ;
55963: LD_ADDR_EXP 79
55967: PUSH
55968: EMPTY
55969: ST_TO_ADDR
// mc_defender := [ ] ;
55970: LD_ADDR_EXP 80
55974: PUSH
55975: EMPTY
55976: ST_TO_ADDR
// mc_parking := [ ] ;
55977: LD_ADDR_EXP 82
55981: PUSH
55982: EMPTY
55983: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55984: LD_ADDR_EXP 68
55988: PUSH
55989: EMPTY
55990: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55991: LD_ADDR_EXP 70
55995: PUSH
55996: EMPTY
55997: ST_TO_ADDR
// mc_scan := [ ] ;
55998: LD_ADDR_EXP 81
56002: PUSH
56003: EMPTY
56004: ST_TO_ADDR
// mc_scan_area := [ ] ;
56005: LD_ADDR_EXP 83
56009: PUSH
56010: EMPTY
56011: ST_TO_ADDR
// mc_tech := [ ] ;
56012: LD_ADDR_EXP 85
56016: PUSH
56017: EMPTY
56018: ST_TO_ADDR
// mc_class := [ ] ;
56019: LD_ADDR_EXP 99
56023: PUSH
56024: EMPTY
56025: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56026: LD_ADDR_EXP 100
56030: PUSH
56031: EMPTY
56032: ST_TO_ADDR
// end ;
56033: LD_VAR 0 1
56037: RET
// export function MC_Kill ( base ) ; begin
56038: LD_INT 0
56040: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56041: LD_ADDR_EXP 58
56045: PUSH
56046: LD_EXP 58
56050: PPUSH
56051: LD_VAR 0 1
56055: PPUSH
56056: EMPTY
56057: PPUSH
56058: CALL_OW 1
56062: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56063: LD_ADDR_EXP 59
56067: PUSH
56068: LD_EXP 59
56072: PPUSH
56073: LD_VAR 0 1
56077: PPUSH
56078: EMPTY
56079: PPUSH
56080: CALL_OW 1
56084: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56085: LD_ADDR_EXP 60
56089: PUSH
56090: LD_EXP 60
56094: PPUSH
56095: LD_VAR 0 1
56099: PPUSH
56100: EMPTY
56101: PPUSH
56102: CALL_OW 1
56106: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56107: LD_ADDR_EXP 61
56111: PUSH
56112: LD_EXP 61
56116: PPUSH
56117: LD_VAR 0 1
56121: PPUSH
56122: EMPTY
56123: PPUSH
56124: CALL_OW 1
56128: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56129: LD_ADDR_EXP 62
56133: PUSH
56134: LD_EXP 62
56138: PPUSH
56139: LD_VAR 0 1
56143: PPUSH
56144: EMPTY
56145: PPUSH
56146: CALL_OW 1
56150: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56151: LD_ADDR_EXP 63
56155: PUSH
56156: LD_EXP 63
56160: PPUSH
56161: LD_VAR 0 1
56165: PPUSH
56166: EMPTY
56167: PPUSH
56168: CALL_OW 1
56172: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56173: LD_ADDR_EXP 64
56177: PUSH
56178: LD_EXP 64
56182: PPUSH
56183: LD_VAR 0 1
56187: PPUSH
56188: EMPTY
56189: PPUSH
56190: CALL_OW 1
56194: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56195: LD_ADDR_EXP 65
56199: PUSH
56200: LD_EXP 65
56204: PPUSH
56205: LD_VAR 0 1
56209: PPUSH
56210: EMPTY
56211: PPUSH
56212: CALL_OW 1
56216: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56217: LD_ADDR_EXP 66
56221: PUSH
56222: LD_EXP 66
56226: PPUSH
56227: LD_VAR 0 1
56231: PPUSH
56232: EMPTY
56233: PPUSH
56234: CALL_OW 1
56238: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56239: LD_ADDR_EXP 67
56243: PUSH
56244: LD_EXP 67
56248: PPUSH
56249: LD_VAR 0 1
56253: PPUSH
56254: EMPTY
56255: PPUSH
56256: CALL_OW 1
56260: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56261: LD_ADDR_EXP 68
56265: PUSH
56266: LD_EXP 68
56270: PPUSH
56271: LD_VAR 0 1
56275: PPUSH
56276: EMPTY
56277: PPUSH
56278: CALL_OW 1
56282: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56283: LD_ADDR_EXP 69
56287: PUSH
56288: LD_EXP 69
56292: PPUSH
56293: LD_VAR 0 1
56297: PPUSH
56298: LD_INT 0
56300: PPUSH
56301: CALL_OW 1
56305: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56306: LD_ADDR_EXP 70
56310: PUSH
56311: LD_EXP 70
56315: PPUSH
56316: LD_VAR 0 1
56320: PPUSH
56321: EMPTY
56322: PPUSH
56323: CALL_OW 1
56327: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56328: LD_ADDR_EXP 71
56332: PUSH
56333: LD_EXP 71
56337: PPUSH
56338: LD_VAR 0 1
56342: PPUSH
56343: EMPTY
56344: PPUSH
56345: CALL_OW 1
56349: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56350: LD_ADDR_EXP 72
56354: PUSH
56355: LD_EXP 72
56359: PPUSH
56360: LD_VAR 0 1
56364: PPUSH
56365: EMPTY
56366: PPUSH
56367: CALL_OW 1
56371: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56372: LD_ADDR_EXP 73
56376: PUSH
56377: LD_EXP 73
56381: PPUSH
56382: LD_VAR 0 1
56386: PPUSH
56387: EMPTY
56388: PPUSH
56389: CALL_OW 1
56393: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56394: LD_ADDR_EXP 74
56398: PUSH
56399: LD_EXP 74
56403: PPUSH
56404: LD_VAR 0 1
56408: PPUSH
56409: EMPTY
56410: PPUSH
56411: CALL_OW 1
56415: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56416: LD_ADDR_EXP 75
56420: PUSH
56421: LD_EXP 75
56425: PPUSH
56426: LD_VAR 0 1
56430: PPUSH
56431: EMPTY
56432: PPUSH
56433: CALL_OW 1
56437: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56438: LD_ADDR_EXP 76
56442: PUSH
56443: LD_EXP 76
56447: PPUSH
56448: LD_VAR 0 1
56452: PPUSH
56453: EMPTY
56454: PPUSH
56455: CALL_OW 1
56459: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56460: LD_ADDR_EXP 77
56464: PUSH
56465: LD_EXP 77
56469: PPUSH
56470: LD_VAR 0 1
56474: PPUSH
56475: EMPTY
56476: PPUSH
56477: CALL_OW 1
56481: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56482: LD_ADDR_EXP 78
56486: PUSH
56487: LD_EXP 78
56491: PPUSH
56492: LD_VAR 0 1
56496: PPUSH
56497: EMPTY
56498: PPUSH
56499: CALL_OW 1
56503: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56504: LD_ADDR_EXP 79
56508: PUSH
56509: LD_EXP 79
56513: PPUSH
56514: LD_VAR 0 1
56518: PPUSH
56519: EMPTY
56520: PPUSH
56521: CALL_OW 1
56525: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56526: LD_ADDR_EXP 80
56530: PUSH
56531: LD_EXP 80
56535: PPUSH
56536: LD_VAR 0 1
56540: PPUSH
56541: EMPTY
56542: PPUSH
56543: CALL_OW 1
56547: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56548: LD_ADDR_EXP 81
56552: PUSH
56553: LD_EXP 81
56557: PPUSH
56558: LD_VAR 0 1
56562: PPUSH
56563: EMPTY
56564: PPUSH
56565: CALL_OW 1
56569: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56570: LD_ADDR_EXP 82
56574: PUSH
56575: LD_EXP 82
56579: PPUSH
56580: LD_VAR 0 1
56584: PPUSH
56585: EMPTY
56586: PPUSH
56587: CALL_OW 1
56591: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56592: LD_ADDR_EXP 83
56596: PUSH
56597: LD_EXP 83
56601: PPUSH
56602: LD_VAR 0 1
56606: PPUSH
56607: EMPTY
56608: PPUSH
56609: CALL_OW 1
56613: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56614: LD_ADDR_EXP 85
56618: PUSH
56619: LD_EXP 85
56623: PPUSH
56624: LD_VAR 0 1
56628: PPUSH
56629: EMPTY
56630: PPUSH
56631: CALL_OW 1
56635: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56636: LD_ADDR_EXP 87
56640: PUSH
56641: LD_EXP 87
56645: PPUSH
56646: LD_VAR 0 1
56650: PPUSH
56651: EMPTY
56652: PPUSH
56653: CALL_OW 1
56657: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56658: LD_ADDR_EXP 88
56662: PUSH
56663: LD_EXP 88
56667: PPUSH
56668: LD_VAR 0 1
56672: PPUSH
56673: EMPTY
56674: PPUSH
56675: CALL_OW 1
56679: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56680: LD_ADDR_EXP 89
56684: PUSH
56685: LD_EXP 89
56689: PPUSH
56690: LD_VAR 0 1
56694: PPUSH
56695: EMPTY
56696: PPUSH
56697: CALL_OW 1
56701: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56702: LD_ADDR_EXP 90
56706: PUSH
56707: LD_EXP 90
56711: PPUSH
56712: LD_VAR 0 1
56716: PPUSH
56717: EMPTY
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56724: LD_ADDR_EXP 91
56728: PUSH
56729: LD_EXP 91
56733: PPUSH
56734: LD_VAR 0 1
56738: PPUSH
56739: EMPTY
56740: PPUSH
56741: CALL_OW 1
56745: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56746: LD_ADDR_EXP 92
56750: PUSH
56751: LD_EXP 92
56755: PPUSH
56756: LD_VAR 0 1
56760: PPUSH
56761: EMPTY
56762: PPUSH
56763: CALL_OW 1
56767: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56768: LD_ADDR_EXP 93
56772: PUSH
56773: LD_EXP 93
56777: PPUSH
56778: LD_VAR 0 1
56782: PPUSH
56783: EMPTY
56784: PPUSH
56785: CALL_OW 1
56789: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56790: LD_ADDR_EXP 94
56794: PUSH
56795: LD_EXP 94
56799: PPUSH
56800: LD_VAR 0 1
56804: PPUSH
56805: EMPTY
56806: PPUSH
56807: CALL_OW 1
56811: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56812: LD_ADDR_EXP 95
56816: PUSH
56817: LD_EXP 95
56821: PPUSH
56822: LD_VAR 0 1
56826: PPUSH
56827: EMPTY
56828: PPUSH
56829: CALL_OW 1
56833: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56834: LD_ADDR_EXP 96
56838: PUSH
56839: LD_EXP 96
56843: PPUSH
56844: LD_VAR 0 1
56848: PPUSH
56849: EMPTY
56850: PPUSH
56851: CALL_OW 1
56855: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56856: LD_ADDR_EXP 97
56860: PUSH
56861: LD_EXP 97
56865: PPUSH
56866: LD_VAR 0 1
56870: PPUSH
56871: EMPTY
56872: PPUSH
56873: CALL_OW 1
56877: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56878: LD_ADDR_EXP 98
56882: PUSH
56883: LD_EXP 98
56887: PPUSH
56888: LD_VAR 0 1
56892: PPUSH
56893: EMPTY
56894: PPUSH
56895: CALL_OW 1
56899: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56900: LD_ADDR_EXP 99
56904: PUSH
56905: LD_EXP 99
56909: PPUSH
56910: LD_VAR 0 1
56914: PPUSH
56915: EMPTY
56916: PPUSH
56917: CALL_OW 1
56921: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56922: LD_ADDR_EXP 100
56926: PUSH
56927: LD_EXP 100
56931: PPUSH
56932: LD_VAR 0 1
56936: PPUSH
56937: LD_INT 0
56939: PPUSH
56940: CALL_OW 1
56944: ST_TO_ADDR
// end ;
56945: LD_VAR 0 2
56949: RET
// export function MC_Start ( ) ; var i ; begin
56950: LD_INT 0
56952: PPUSH
56953: PPUSH
// for i = 1 to mc_bases do
56954: LD_ADDR_VAR 0 2
56958: PUSH
56959: DOUBLE
56960: LD_INT 1
56962: DEC
56963: ST_TO_ADDR
56964: LD_EXP 58
56968: PUSH
56969: FOR_TO
56970: IFFALSE 58047
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56972: LD_ADDR_EXP 58
56976: PUSH
56977: LD_EXP 58
56981: PPUSH
56982: LD_VAR 0 2
56986: PPUSH
56987: LD_EXP 58
56991: PUSH
56992: LD_VAR 0 2
56996: ARRAY
56997: PUSH
56998: LD_INT 0
57000: DIFF
57001: PPUSH
57002: CALL_OW 1
57006: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57007: LD_ADDR_EXP 59
57011: PUSH
57012: LD_EXP 59
57016: PPUSH
57017: LD_VAR 0 2
57021: PPUSH
57022: EMPTY
57023: PPUSH
57024: CALL_OW 1
57028: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57029: LD_ADDR_EXP 60
57033: PUSH
57034: LD_EXP 60
57038: PPUSH
57039: LD_VAR 0 2
57043: PPUSH
57044: EMPTY
57045: PPUSH
57046: CALL_OW 1
57050: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57051: LD_ADDR_EXP 61
57055: PUSH
57056: LD_EXP 61
57060: PPUSH
57061: LD_VAR 0 2
57065: PPUSH
57066: EMPTY
57067: PPUSH
57068: CALL_OW 1
57072: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57073: LD_ADDR_EXP 62
57077: PUSH
57078: LD_EXP 62
57082: PPUSH
57083: LD_VAR 0 2
57087: PPUSH
57088: EMPTY
57089: PUSH
57090: EMPTY
57091: PUSH
57092: EMPTY
57093: LIST
57094: LIST
57095: PPUSH
57096: CALL_OW 1
57100: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57101: LD_ADDR_EXP 63
57105: PUSH
57106: LD_EXP 63
57110: PPUSH
57111: LD_VAR 0 2
57115: PPUSH
57116: EMPTY
57117: PPUSH
57118: CALL_OW 1
57122: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57123: LD_ADDR_EXP 90
57127: PUSH
57128: LD_EXP 90
57132: PPUSH
57133: LD_VAR 0 2
57137: PPUSH
57138: EMPTY
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57145: LD_ADDR_EXP 64
57149: PUSH
57150: LD_EXP 64
57154: PPUSH
57155: LD_VAR 0 2
57159: PPUSH
57160: EMPTY
57161: PPUSH
57162: CALL_OW 1
57166: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57167: LD_ADDR_EXP 65
57171: PUSH
57172: LD_EXP 65
57176: PPUSH
57177: LD_VAR 0 2
57181: PPUSH
57182: EMPTY
57183: PPUSH
57184: CALL_OW 1
57188: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57189: LD_ADDR_EXP 66
57193: PUSH
57194: LD_EXP 66
57198: PPUSH
57199: LD_VAR 0 2
57203: PPUSH
57204: LD_EXP 58
57208: PUSH
57209: LD_VAR 0 2
57213: ARRAY
57214: PPUSH
57215: LD_INT 2
57217: PUSH
57218: LD_INT 30
57220: PUSH
57221: LD_INT 32
57223: PUSH
57224: EMPTY
57225: LIST
57226: LIST
57227: PUSH
57228: LD_INT 30
57230: PUSH
57231: LD_INT 33
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: PUSH
57238: EMPTY
57239: LIST
57240: LIST
57241: LIST
57242: PPUSH
57243: CALL_OW 72
57247: PPUSH
57248: CALL_OW 1
57252: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57253: LD_ADDR_EXP 67
57257: PUSH
57258: LD_EXP 67
57262: PPUSH
57263: LD_VAR 0 2
57267: PPUSH
57268: LD_EXP 58
57272: PUSH
57273: LD_VAR 0 2
57277: ARRAY
57278: PPUSH
57279: LD_INT 2
57281: PUSH
57282: LD_INT 30
57284: PUSH
57285: LD_INT 32
57287: PUSH
57288: EMPTY
57289: LIST
57290: LIST
57291: PUSH
57292: LD_INT 30
57294: PUSH
57295: LD_INT 31
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: PUSH
57302: EMPTY
57303: LIST
57304: LIST
57305: LIST
57306: PUSH
57307: LD_INT 58
57309: PUSH
57310: EMPTY
57311: LIST
57312: PUSH
57313: EMPTY
57314: LIST
57315: LIST
57316: PPUSH
57317: CALL_OW 72
57321: PPUSH
57322: CALL_OW 1
57326: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57327: LD_ADDR_EXP 68
57331: PUSH
57332: LD_EXP 68
57336: PPUSH
57337: LD_VAR 0 2
57341: PPUSH
57342: EMPTY
57343: PPUSH
57344: CALL_OW 1
57348: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57349: LD_ADDR_EXP 72
57353: PUSH
57354: LD_EXP 72
57358: PPUSH
57359: LD_VAR 0 2
57363: PPUSH
57364: EMPTY
57365: PPUSH
57366: CALL_OW 1
57370: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57371: LD_ADDR_EXP 71
57375: PUSH
57376: LD_EXP 71
57380: PPUSH
57381: LD_VAR 0 2
57385: PPUSH
57386: EMPTY
57387: PPUSH
57388: CALL_OW 1
57392: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57393: LD_ADDR_EXP 73
57397: PUSH
57398: LD_EXP 73
57402: PPUSH
57403: LD_VAR 0 2
57407: PPUSH
57408: EMPTY
57409: PPUSH
57410: CALL_OW 1
57414: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57415: LD_ADDR_EXP 74
57419: PUSH
57420: LD_EXP 74
57424: PPUSH
57425: LD_VAR 0 2
57429: PPUSH
57430: EMPTY
57431: PPUSH
57432: CALL_OW 1
57436: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57437: LD_ADDR_EXP 75
57441: PUSH
57442: LD_EXP 75
57446: PPUSH
57447: LD_VAR 0 2
57451: PPUSH
57452: EMPTY
57453: PPUSH
57454: CALL_OW 1
57458: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57459: LD_ADDR_EXP 76
57463: PUSH
57464: LD_EXP 76
57468: PPUSH
57469: LD_VAR 0 2
57473: PPUSH
57474: EMPTY
57475: PPUSH
57476: CALL_OW 1
57480: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57481: LD_ADDR_EXP 77
57485: PUSH
57486: LD_EXP 77
57490: PPUSH
57491: LD_VAR 0 2
57495: PPUSH
57496: EMPTY
57497: PPUSH
57498: CALL_OW 1
57502: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57503: LD_ADDR_EXP 78
57507: PUSH
57508: LD_EXP 78
57512: PPUSH
57513: LD_VAR 0 2
57517: PPUSH
57518: EMPTY
57519: PPUSH
57520: CALL_OW 1
57524: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57525: LD_ADDR_EXP 79
57529: PUSH
57530: LD_EXP 79
57534: PPUSH
57535: LD_VAR 0 2
57539: PPUSH
57540: EMPTY
57541: PPUSH
57542: CALL_OW 1
57546: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57547: LD_ADDR_EXP 80
57551: PUSH
57552: LD_EXP 80
57556: PPUSH
57557: LD_VAR 0 2
57561: PPUSH
57562: EMPTY
57563: PPUSH
57564: CALL_OW 1
57568: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57569: LD_ADDR_EXP 69
57573: PUSH
57574: LD_EXP 69
57578: PPUSH
57579: LD_VAR 0 2
57583: PPUSH
57584: LD_INT 0
57586: PPUSH
57587: CALL_OW 1
57591: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57592: LD_ADDR_EXP 82
57596: PUSH
57597: LD_EXP 82
57601: PPUSH
57602: LD_VAR 0 2
57606: PPUSH
57607: LD_INT 0
57609: PPUSH
57610: CALL_OW 1
57614: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57615: LD_ADDR_EXP 70
57619: PUSH
57620: LD_EXP 70
57624: PPUSH
57625: LD_VAR 0 2
57629: PPUSH
57630: EMPTY
57631: PPUSH
57632: CALL_OW 1
57636: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57637: LD_ADDR_EXP 81
57641: PUSH
57642: LD_EXP 81
57646: PPUSH
57647: LD_VAR 0 2
57651: PPUSH
57652: LD_INT 0
57654: PPUSH
57655: CALL_OW 1
57659: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57660: LD_ADDR_EXP 83
57664: PUSH
57665: LD_EXP 83
57669: PPUSH
57670: LD_VAR 0 2
57674: PPUSH
57675: EMPTY
57676: PPUSH
57677: CALL_OW 1
57681: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57682: LD_ADDR_EXP 86
57686: PUSH
57687: LD_EXP 86
57691: PPUSH
57692: LD_VAR 0 2
57696: PPUSH
57697: LD_INT 0
57699: PPUSH
57700: CALL_OW 1
57704: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57705: LD_ADDR_EXP 87
57709: PUSH
57710: LD_EXP 87
57714: PPUSH
57715: LD_VAR 0 2
57719: PPUSH
57720: EMPTY
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57727: LD_ADDR_EXP 88
57731: PUSH
57732: LD_EXP 88
57736: PPUSH
57737: LD_VAR 0 2
57741: PPUSH
57742: EMPTY
57743: PPUSH
57744: CALL_OW 1
57748: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57749: LD_ADDR_EXP 89
57753: PUSH
57754: LD_EXP 89
57758: PPUSH
57759: LD_VAR 0 2
57763: PPUSH
57764: EMPTY
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57771: LD_ADDR_EXP 91
57775: PUSH
57776: LD_EXP 91
57780: PPUSH
57781: LD_VAR 0 2
57785: PPUSH
57786: LD_EXP 58
57790: PUSH
57791: LD_VAR 0 2
57795: ARRAY
57796: PPUSH
57797: LD_INT 2
57799: PUSH
57800: LD_INT 30
57802: PUSH
57803: LD_INT 6
57805: PUSH
57806: EMPTY
57807: LIST
57808: LIST
57809: PUSH
57810: LD_INT 30
57812: PUSH
57813: LD_INT 7
57815: PUSH
57816: EMPTY
57817: LIST
57818: LIST
57819: PUSH
57820: LD_INT 30
57822: PUSH
57823: LD_INT 8
57825: PUSH
57826: EMPTY
57827: LIST
57828: LIST
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: LIST
57834: LIST
57835: PPUSH
57836: CALL_OW 72
57840: PPUSH
57841: CALL_OW 1
57845: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57846: LD_ADDR_EXP 92
57850: PUSH
57851: LD_EXP 92
57855: PPUSH
57856: LD_VAR 0 2
57860: PPUSH
57861: EMPTY
57862: PPUSH
57863: CALL_OW 1
57867: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57868: LD_ADDR_EXP 93
57872: PUSH
57873: LD_EXP 93
57877: PPUSH
57878: LD_VAR 0 2
57882: PPUSH
57883: EMPTY
57884: PPUSH
57885: CALL_OW 1
57889: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57890: LD_ADDR_EXP 94
57894: PUSH
57895: LD_EXP 94
57899: PPUSH
57900: LD_VAR 0 2
57904: PPUSH
57905: EMPTY
57906: PPUSH
57907: CALL_OW 1
57911: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57912: LD_ADDR_EXP 95
57916: PUSH
57917: LD_EXP 95
57921: PPUSH
57922: LD_VAR 0 2
57926: PPUSH
57927: EMPTY
57928: PPUSH
57929: CALL_OW 1
57933: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57934: LD_ADDR_EXP 96
57938: PUSH
57939: LD_EXP 96
57943: PPUSH
57944: LD_VAR 0 2
57948: PPUSH
57949: EMPTY
57950: PPUSH
57951: CALL_OW 1
57955: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57956: LD_ADDR_EXP 97
57960: PUSH
57961: LD_EXP 97
57965: PPUSH
57966: LD_VAR 0 2
57970: PPUSH
57971: EMPTY
57972: PPUSH
57973: CALL_OW 1
57977: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57978: LD_ADDR_EXP 98
57982: PUSH
57983: LD_EXP 98
57987: PPUSH
57988: LD_VAR 0 2
57992: PPUSH
57993: EMPTY
57994: PPUSH
57995: CALL_OW 1
57999: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58000: LD_ADDR_EXP 99
58004: PUSH
58005: LD_EXP 99
58009: PPUSH
58010: LD_VAR 0 2
58014: PPUSH
58015: EMPTY
58016: PPUSH
58017: CALL_OW 1
58021: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58022: LD_ADDR_EXP 100
58026: PUSH
58027: LD_EXP 100
58031: PPUSH
58032: LD_VAR 0 2
58036: PPUSH
58037: LD_INT 0
58039: PPUSH
58040: CALL_OW 1
58044: ST_TO_ADDR
// end ;
58045: GO 56969
58047: POP
58048: POP
// MC_InitSides ( ) ;
58049: CALL 58335 0 0
// MC_InitResearch ( ) ;
58053: CALL 58074 0 0
// CustomInitMacro ( ) ;
58057: CALL 174 0 0
// skirmish := true ;
58061: LD_ADDR_EXP 56
58065: PUSH
58066: LD_INT 1
58068: ST_TO_ADDR
// end ;
58069: LD_VAR 0 1
58073: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58074: LD_INT 0
58076: PPUSH
58077: PPUSH
58078: PPUSH
58079: PPUSH
58080: PPUSH
58081: PPUSH
// if not mc_bases then
58082: LD_EXP 58
58086: NOT
58087: IFFALSE 58091
// exit ;
58089: GO 58330
// for i = 1 to 8 do
58091: LD_ADDR_VAR 0 2
58095: PUSH
58096: DOUBLE
58097: LD_INT 1
58099: DEC
58100: ST_TO_ADDR
58101: LD_INT 8
58103: PUSH
58104: FOR_TO
58105: IFFALSE 58131
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58107: LD_ADDR_EXP 85
58111: PUSH
58112: LD_EXP 85
58116: PPUSH
58117: LD_VAR 0 2
58121: PPUSH
58122: EMPTY
58123: PPUSH
58124: CALL_OW 1
58128: ST_TO_ADDR
58129: GO 58104
58131: POP
58132: POP
// tmp := [ ] ;
58133: LD_ADDR_VAR 0 5
58137: PUSH
58138: EMPTY
58139: ST_TO_ADDR
// for i = 1 to mc_sides do
58140: LD_ADDR_VAR 0 2
58144: PUSH
58145: DOUBLE
58146: LD_INT 1
58148: DEC
58149: ST_TO_ADDR
58150: LD_EXP 84
58154: PUSH
58155: FOR_TO
58156: IFFALSE 58214
// if not mc_sides [ i ] in tmp then
58158: LD_EXP 84
58162: PUSH
58163: LD_VAR 0 2
58167: ARRAY
58168: PUSH
58169: LD_VAR 0 5
58173: IN
58174: NOT
58175: IFFALSE 58212
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58177: LD_ADDR_VAR 0 5
58181: PUSH
58182: LD_VAR 0 5
58186: PPUSH
58187: LD_VAR 0 5
58191: PUSH
58192: LD_INT 1
58194: PLUS
58195: PPUSH
58196: LD_EXP 84
58200: PUSH
58201: LD_VAR 0 2
58205: ARRAY
58206: PPUSH
58207: CALL_OW 2
58211: ST_TO_ADDR
58212: GO 58155
58214: POP
58215: POP
// if not tmp then
58216: LD_VAR 0 5
58220: NOT
58221: IFFALSE 58225
// exit ;
58223: GO 58330
// for j in tmp do
58225: LD_ADDR_VAR 0 3
58229: PUSH
58230: LD_VAR 0 5
58234: PUSH
58235: FOR_IN
58236: IFFALSE 58328
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58238: LD_ADDR_VAR 0 6
58242: PUSH
58243: LD_INT 22
58245: PUSH
58246: LD_VAR 0 3
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: PPUSH
58255: CALL_OW 69
58259: ST_TO_ADDR
// if not un then
58260: LD_VAR 0 6
58264: NOT
58265: IFFALSE 58269
// continue ;
58267: GO 58235
// nation := GetNation ( un [ 1 ] ) ;
58269: LD_ADDR_VAR 0 4
58273: PUSH
58274: LD_VAR 0 6
58278: PUSH
58279: LD_INT 1
58281: ARRAY
58282: PPUSH
58283: CALL_OW 248
58287: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58288: LD_ADDR_EXP 85
58292: PUSH
58293: LD_EXP 85
58297: PPUSH
58298: LD_VAR 0 3
58302: PPUSH
58303: LD_VAR 0 3
58307: PPUSH
58308: LD_VAR 0 4
58312: PPUSH
58313: LD_INT 1
58315: PPUSH
58316: CALL 13578 0 3
58320: PPUSH
58321: CALL_OW 1
58325: ST_TO_ADDR
// end ;
58326: GO 58235
58328: POP
58329: POP
// end ;
58330: LD_VAR 0 1
58334: RET
// export function MC_InitSides ( ) ; var i ; begin
58335: LD_INT 0
58337: PPUSH
58338: PPUSH
// if not mc_bases then
58339: LD_EXP 58
58343: NOT
58344: IFFALSE 58348
// exit ;
58346: GO 58422
// for i = 1 to mc_bases do
58348: LD_ADDR_VAR 0 2
58352: PUSH
58353: DOUBLE
58354: LD_INT 1
58356: DEC
58357: ST_TO_ADDR
58358: LD_EXP 58
58362: PUSH
58363: FOR_TO
58364: IFFALSE 58420
// if mc_bases [ i ] then
58366: LD_EXP 58
58370: PUSH
58371: LD_VAR 0 2
58375: ARRAY
58376: IFFALSE 58418
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58378: LD_ADDR_EXP 84
58382: PUSH
58383: LD_EXP 84
58387: PPUSH
58388: LD_VAR 0 2
58392: PPUSH
58393: LD_EXP 58
58397: PUSH
58398: LD_VAR 0 2
58402: ARRAY
58403: PUSH
58404: LD_INT 1
58406: ARRAY
58407: PPUSH
58408: CALL_OW 255
58412: PPUSH
58413: CALL_OW 1
58417: ST_TO_ADDR
58418: GO 58363
58420: POP
58421: POP
// end ;
58422: LD_VAR 0 1
58426: RET
// every 0 0$01 trigger skirmish do
58427: LD_EXP 56
58431: IFFALSE 58585
58433: GO 58435
58435: DISABLE
// begin enable ;
58436: ENABLE
// MC_CheckBuildings ( ) ;
58437: CALL 62751 0 0
// MC_CheckPeopleLife ( ) ;
58441: CALL 62876 0 0
// RaiseSailEvent ( 100 ) ;
58445: LD_INT 100
58447: PPUSH
58448: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58452: LD_INT 103
58454: PPUSH
58455: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58459: LD_INT 104
58461: PPUSH
58462: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58466: LD_INT 105
58468: PPUSH
58469: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58473: LD_INT 106
58475: PPUSH
58476: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58480: LD_INT 107
58482: PPUSH
58483: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58487: LD_INT 108
58489: PPUSH
58490: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58494: LD_INT 109
58496: PPUSH
58497: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58501: LD_INT 110
58503: PPUSH
58504: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58508: LD_INT 111
58510: PPUSH
58511: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58515: LD_INT 112
58517: PPUSH
58518: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58522: LD_INT 113
58524: PPUSH
58525: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58529: LD_INT 120
58531: PPUSH
58532: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58536: LD_INT 121
58538: PPUSH
58539: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58543: LD_INT 122
58545: PPUSH
58546: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58550: LD_INT 123
58552: PPUSH
58553: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58557: LD_INT 124
58559: PPUSH
58560: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58564: LD_INT 125
58566: PPUSH
58567: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58571: LD_INT 126
58573: PPUSH
58574: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58578: LD_INT 200
58580: PPUSH
58581: CALL_OW 427
// end ;
58585: END
// on SailEvent ( event ) do begin if event < 100 then
58586: LD_VAR 0 1
58590: PUSH
58591: LD_INT 100
58593: LESS
58594: IFFALSE 58605
// CustomEvent ( event ) ;
58596: LD_VAR 0 1
58600: PPUSH
58601: CALL 12292 0 1
// if event = 100 then
58605: LD_VAR 0 1
58609: PUSH
58610: LD_INT 100
58612: EQUAL
58613: IFFALSE 58619
// MC_ClassManager ( ) ;
58615: CALL 59011 0 0
// if event = 101 then
58619: LD_VAR 0 1
58623: PUSH
58624: LD_INT 101
58626: EQUAL
58627: IFFALSE 58633
// MC_RepairBuildings ( ) ;
58629: CALL 63472 0 0
// if event = 102 then
58633: LD_VAR 0 1
58637: PUSH
58638: LD_INT 102
58640: EQUAL
58641: IFFALSE 58647
// MC_Heal ( ) ;
58643: CALL 63878 0 0
// if event = 103 then
58647: LD_VAR 0 1
58651: PUSH
58652: LD_INT 103
58654: EQUAL
58655: IFFALSE 58661
// MC_Build ( ) ;
58657: CALL 64300 0 0
// if event = 104 then
58661: LD_VAR 0 1
58665: PUSH
58666: LD_INT 104
58668: EQUAL
58669: IFFALSE 58675
// MC_TurretWeapon ( ) ;
58671: CALL 65913 0 0
// if event = 105 then
58675: LD_VAR 0 1
58679: PUSH
58680: LD_INT 105
58682: EQUAL
58683: IFFALSE 58689
// MC_BuildUpgrade ( ) ;
58685: CALL 65464 0 0
// if event = 106 then
58689: LD_VAR 0 1
58693: PUSH
58694: LD_INT 106
58696: EQUAL
58697: IFFALSE 58703
// MC_PlantMines ( ) ;
58699: CALL 66343 0 0
// if event = 107 then
58703: LD_VAR 0 1
58707: PUSH
58708: LD_INT 107
58710: EQUAL
58711: IFFALSE 58717
// MC_CollectCrates ( ) ;
58713: CALL 67377 0 0
// if event = 108 then
58717: LD_VAR 0 1
58721: PUSH
58722: LD_INT 108
58724: EQUAL
58725: IFFALSE 58731
// MC_LinkRemoteControl ( ) ;
58727: CALL 69134 0 0
// if event = 109 then
58731: LD_VAR 0 1
58735: PUSH
58736: LD_INT 109
58738: EQUAL
58739: IFFALSE 58745
// MC_ProduceVehicle ( ) ;
58741: CALL 69315 0 0
// if event = 110 then
58745: LD_VAR 0 1
58749: PUSH
58750: LD_INT 110
58752: EQUAL
58753: IFFALSE 58759
// MC_SendAttack ( ) ;
58755: CALL 69796 0 0
// if event = 111 then
58759: LD_VAR 0 1
58763: PUSH
58764: LD_INT 111
58766: EQUAL
58767: IFFALSE 58773
// MC_Defend ( ) ;
58769: CALL 69904 0 0
// if event = 112 then
58773: LD_VAR 0 1
58777: PUSH
58778: LD_INT 112
58780: EQUAL
58781: IFFALSE 58787
// MC_Research ( ) ;
58783: CALL 70531 0 0
// if event = 113 then
58787: LD_VAR 0 1
58791: PUSH
58792: LD_INT 113
58794: EQUAL
58795: IFFALSE 58801
// MC_MinesTrigger ( ) ;
58797: CALL 71645 0 0
// if event = 120 then
58801: LD_VAR 0 1
58805: PUSH
58806: LD_INT 120
58808: EQUAL
58809: IFFALSE 58815
// MC_RepairVehicle ( ) ;
58811: CALL 71744 0 0
// if event = 121 then
58815: LD_VAR 0 1
58819: PUSH
58820: LD_INT 121
58822: EQUAL
58823: IFFALSE 58829
// MC_TameApe ( ) ;
58825: CALL 72487 0 0
// if event = 122 then
58829: LD_VAR 0 1
58833: PUSH
58834: LD_INT 122
58836: EQUAL
58837: IFFALSE 58843
// MC_ChangeApeClass ( ) ;
58839: CALL 73316 0 0
// if event = 123 then
58843: LD_VAR 0 1
58847: PUSH
58848: LD_INT 123
58850: EQUAL
58851: IFFALSE 58857
// MC_Bazooka ( ) ;
58853: CALL 73966 0 0
// if event = 124 then
58857: LD_VAR 0 1
58861: PUSH
58862: LD_INT 124
58864: EQUAL
58865: IFFALSE 58871
// MC_TeleportExit ( ) ;
58867: CALL 74164 0 0
// if event = 125 then
58871: LD_VAR 0 1
58875: PUSH
58876: LD_INT 125
58878: EQUAL
58879: IFFALSE 58885
// MC_Deposits ( ) ;
58881: CALL 74811 0 0
// if event = 126 then
58885: LD_VAR 0 1
58889: PUSH
58890: LD_INT 126
58892: EQUAL
58893: IFFALSE 58899
// MC_RemoteDriver ( ) ;
58895: CALL 75436 0 0
// if event = 200 then
58899: LD_VAR 0 1
58903: PUSH
58904: LD_INT 200
58906: EQUAL
58907: IFFALSE 58913
// MC_Idle ( ) ;
58909: CALL 77169 0 0
// end ;
58913: PPOPN 1
58915: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58916: LD_INT 0
58918: PPUSH
58919: PPUSH
// if not mc_bases [ base ] or not tag then
58920: LD_EXP 58
58924: PUSH
58925: LD_VAR 0 1
58929: ARRAY
58930: NOT
58931: PUSH
58932: LD_VAR 0 2
58936: NOT
58937: OR
58938: IFFALSE 58942
// exit ;
58940: GO 59006
// for i in mc_bases [ base ] union mc_ape [ base ] do
58942: LD_ADDR_VAR 0 4
58946: PUSH
58947: LD_EXP 58
58951: PUSH
58952: LD_VAR 0 1
58956: ARRAY
58957: PUSH
58958: LD_EXP 87
58962: PUSH
58963: LD_VAR 0 1
58967: ARRAY
58968: UNION
58969: PUSH
58970: FOR_IN
58971: IFFALSE 59004
// if GetTag ( i ) = tag then
58973: LD_VAR 0 4
58977: PPUSH
58978: CALL_OW 110
58982: PUSH
58983: LD_VAR 0 2
58987: EQUAL
58988: IFFALSE 59002
// SetTag ( i , 0 ) ;
58990: LD_VAR 0 4
58994: PPUSH
58995: LD_INT 0
58997: PPUSH
58998: CALL_OW 109
59002: GO 58970
59004: POP
59005: POP
// end ;
59006: LD_VAR 0 3
59010: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59011: LD_INT 0
59013: PPUSH
59014: PPUSH
59015: PPUSH
59016: PPUSH
59017: PPUSH
59018: PPUSH
59019: PPUSH
59020: PPUSH
// if not mc_bases then
59021: LD_EXP 58
59025: NOT
59026: IFFALSE 59030
// exit ;
59028: GO 59488
// for i = 1 to mc_bases do
59030: LD_ADDR_VAR 0 2
59034: PUSH
59035: DOUBLE
59036: LD_INT 1
59038: DEC
59039: ST_TO_ADDR
59040: LD_EXP 58
59044: PUSH
59045: FOR_TO
59046: IFFALSE 59486
// begin tmp := MC_ClassCheckReq ( i ) ;
59048: LD_ADDR_VAR 0 4
59052: PUSH
59053: LD_VAR 0 2
59057: PPUSH
59058: CALL 59493 0 1
59062: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59063: LD_ADDR_EXP 99
59067: PUSH
59068: LD_EXP 99
59072: PPUSH
59073: LD_VAR 0 2
59077: PPUSH
59078: LD_VAR 0 4
59082: PPUSH
59083: CALL_OW 1
59087: ST_TO_ADDR
// if not tmp then
59088: LD_VAR 0 4
59092: NOT
59093: IFFALSE 59097
// continue ;
59095: GO 59045
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59097: LD_ADDR_VAR 0 6
59101: PUSH
59102: LD_EXP 58
59106: PUSH
59107: LD_VAR 0 2
59111: ARRAY
59112: PPUSH
59113: LD_INT 2
59115: PUSH
59116: LD_INT 30
59118: PUSH
59119: LD_INT 4
59121: PUSH
59122: EMPTY
59123: LIST
59124: LIST
59125: PUSH
59126: LD_INT 30
59128: PUSH
59129: LD_INT 5
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: PUSH
59136: EMPTY
59137: LIST
59138: LIST
59139: LIST
59140: PPUSH
59141: CALL_OW 72
59145: PUSH
59146: LD_EXP 58
59150: PUSH
59151: LD_VAR 0 2
59155: ARRAY
59156: PPUSH
59157: LD_INT 2
59159: PUSH
59160: LD_INT 30
59162: PUSH
59163: LD_INT 0
59165: PUSH
59166: EMPTY
59167: LIST
59168: LIST
59169: PUSH
59170: LD_INT 30
59172: PUSH
59173: LD_INT 1
59175: PUSH
59176: EMPTY
59177: LIST
59178: LIST
59179: PUSH
59180: EMPTY
59181: LIST
59182: LIST
59183: LIST
59184: PPUSH
59185: CALL_OW 72
59189: PUSH
59190: LD_EXP 58
59194: PUSH
59195: LD_VAR 0 2
59199: ARRAY
59200: PPUSH
59201: LD_INT 30
59203: PUSH
59204: LD_INT 3
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: PPUSH
59211: CALL_OW 72
59215: PUSH
59216: LD_EXP 58
59220: PUSH
59221: LD_VAR 0 2
59225: ARRAY
59226: PPUSH
59227: LD_INT 2
59229: PUSH
59230: LD_INT 30
59232: PUSH
59233: LD_INT 6
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PUSH
59240: LD_INT 30
59242: PUSH
59243: LD_INT 7
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: PUSH
59250: LD_INT 30
59252: PUSH
59253: LD_INT 8
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: PUSH
59260: EMPTY
59261: LIST
59262: LIST
59263: LIST
59264: LIST
59265: PPUSH
59266: CALL_OW 72
59270: PUSH
59271: EMPTY
59272: LIST
59273: LIST
59274: LIST
59275: LIST
59276: ST_TO_ADDR
// for j = 1 to 4 do
59277: LD_ADDR_VAR 0 3
59281: PUSH
59282: DOUBLE
59283: LD_INT 1
59285: DEC
59286: ST_TO_ADDR
59287: LD_INT 4
59289: PUSH
59290: FOR_TO
59291: IFFALSE 59482
// begin if not tmp [ j ] then
59293: LD_VAR 0 4
59297: PUSH
59298: LD_VAR 0 3
59302: ARRAY
59303: NOT
59304: IFFALSE 59308
// continue ;
59306: GO 59290
// for p in tmp [ j ] do
59308: LD_ADDR_VAR 0 5
59312: PUSH
59313: LD_VAR 0 4
59317: PUSH
59318: LD_VAR 0 3
59322: ARRAY
59323: PUSH
59324: FOR_IN
59325: IFFALSE 59478
// begin if not b [ j ] then
59327: LD_VAR 0 6
59331: PUSH
59332: LD_VAR 0 3
59336: ARRAY
59337: NOT
59338: IFFALSE 59342
// break ;
59340: GO 59478
// e := 0 ;
59342: LD_ADDR_VAR 0 7
59346: PUSH
59347: LD_INT 0
59349: ST_TO_ADDR
// for k in b [ j ] do
59350: LD_ADDR_VAR 0 8
59354: PUSH
59355: LD_VAR 0 6
59359: PUSH
59360: LD_VAR 0 3
59364: ARRAY
59365: PUSH
59366: FOR_IN
59367: IFFALSE 59394
// if IsNotFull ( k ) then
59369: LD_VAR 0 8
59373: PPUSH
59374: CALL 17604 0 1
59378: IFFALSE 59392
// begin e := k ;
59380: LD_ADDR_VAR 0 7
59384: PUSH
59385: LD_VAR 0 8
59389: ST_TO_ADDR
// break ;
59390: GO 59394
// end ;
59392: GO 59366
59394: POP
59395: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59396: LD_VAR 0 7
59400: PUSH
59401: LD_VAR 0 5
59405: PPUSH
59406: LD_VAR 0 7
59410: PPUSH
59411: CALL 54592 0 2
59415: NOT
59416: AND
59417: IFFALSE 59476
// begin if IsInUnit ( p ) then
59419: LD_VAR 0 5
59423: PPUSH
59424: CALL_OW 310
59428: IFFALSE 59439
// ComExitBuilding ( p ) ;
59430: LD_VAR 0 5
59434: PPUSH
59435: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59439: LD_VAR 0 5
59443: PPUSH
59444: LD_VAR 0 7
59448: PPUSH
59449: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59453: LD_VAR 0 5
59457: PPUSH
59458: LD_VAR 0 3
59462: PPUSH
59463: CALL_OW 183
// AddComExitBuilding ( p ) ;
59467: LD_VAR 0 5
59471: PPUSH
59472: CALL_OW 182
// end ; end ;
59476: GO 59324
59478: POP
59479: POP
// end ;
59480: GO 59290
59482: POP
59483: POP
// end ;
59484: GO 59045
59486: POP
59487: POP
// end ;
59488: LD_VAR 0 1
59492: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59493: LD_INT 0
59495: PPUSH
59496: PPUSH
59497: PPUSH
59498: PPUSH
59499: PPUSH
59500: PPUSH
59501: PPUSH
59502: PPUSH
59503: PPUSH
59504: PPUSH
59505: PPUSH
59506: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59507: LD_VAR 0 1
59511: NOT
59512: PUSH
59513: LD_EXP 58
59517: PUSH
59518: LD_VAR 0 1
59522: ARRAY
59523: NOT
59524: OR
59525: PUSH
59526: LD_EXP 58
59530: PUSH
59531: LD_VAR 0 1
59535: ARRAY
59536: PPUSH
59537: LD_INT 2
59539: PUSH
59540: LD_INT 30
59542: PUSH
59543: LD_INT 0
59545: PUSH
59546: EMPTY
59547: LIST
59548: LIST
59549: PUSH
59550: LD_INT 30
59552: PUSH
59553: LD_INT 1
59555: PUSH
59556: EMPTY
59557: LIST
59558: LIST
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: LIST
59564: PPUSH
59565: CALL_OW 72
59569: NOT
59570: OR
59571: IFFALSE 59575
// exit ;
59573: GO 62746
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59575: LD_ADDR_VAR 0 4
59579: PUSH
59580: LD_EXP 58
59584: PUSH
59585: LD_VAR 0 1
59589: ARRAY
59590: PPUSH
59591: LD_INT 2
59593: PUSH
59594: LD_INT 25
59596: PUSH
59597: LD_INT 1
59599: PUSH
59600: EMPTY
59601: LIST
59602: LIST
59603: PUSH
59604: LD_INT 25
59606: PUSH
59607: LD_INT 2
59609: PUSH
59610: EMPTY
59611: LIST
59612: LIST
59613: PUSH
59614: LD_INT 25
59616: PUSH
59617: LD_INT 3
59619: PUSH
59620: EMPTY
59621: LIST
59622: LIST
59623: PUSH
59624: LD_INT 25
59626: PUSH
59627: LD_INT 4
59629: PUSH
59630: EMPTY
59631: LIST
59632: LIST
59633: PUSH
59634: LD_INT 25
59636: PUSH
59637: LD_INT 5
59639: PUSH
59640: EMPTY
59641: LIST
59642: LIST
59643: PUSH
59644: LD_INT 25
59646: PUSH
59647: LD_INT 8
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: LD_INT 25
59656: PUSH
59657: LD_INT 9
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: LIST
59668: LIST
59669: LIST
59670: LIST
59671: LIST
59672: LIST
59673: PPUSH
59674: CALL_OW 72
59678: ST_TO_ADDR
// for i in tmp do
59679: LD_ADDR_VAR 0 3
59683: PUSH
59684: LD_VAR 0 4
59688: PUSH
59689: FOR_IN
59690: IFFALSE 59721
// if GetTag ( i ) then
59692: LD_VAR 0 3
59696: PPUSH
59697: CALL_OW 110
59701: IFFALSE 59719
// tmp := tmp diff i ;
59703: LD_ADDR_VAR 0 4
59707: PUSH
59708: LD_VAR 0 4
59712: PUSH
59713: LD_VAR 0 3
59717: DIFF
59718: ST_TO_ADDR
59719: GO 59689
59721: POP
59722: POP
// if not tmp then
59723: LD_VAR 0 4
59727: NOT
59728: IFFALSE 59732
// exit ;
59730: GO 62746
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59732: LD_ADDR_VAR 0 5
59736: PUSH
59737: LD_EXP 58
59741: PUSH
59742: LD_VAR 0 1
59746: ARRAY
59747: PPUSH
59748: LD_INT 2
59750: PUSH
59751: LD_INT 25
59753: PUSH
59754: LD_INT 1
59756: PUSH
59757: EMPTY
59758: LIST
59759: LIST
59760: PUSH
59761: LD_INT 25
59763: PUSH
59764: LD_INT 5
59766: PUSH
59767: EMPTY
59768: LIST
59769: LIST
59770: PUSH
59771: LD_INT 25
59773: PUSH
59774: LD_INT 8
59776: PUSH
59777: EMPTY
59778: LIST
59779: LIST
59780: PUSH
59781: LD_INT 25
59783: PUSH
59784: LD_INT 9
59786: PUSH
59787: EMPTY
59788: LIST
59789: LIST
59790: PUSH
59791: EMPTY
59792: LIST
59793: LIST
59794: LIST
59795: LIST
59796: LIST
59797: PPUSH
59798: CALL_OW 72
59802: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59803: LD_ADDR_VAR 0 6
59807: PUSH
59808: LD_EXP 58
59812: PUSH
59813: LD_VAR 0 1
59817: ARRAY
59818: PPUSH
59819: LD_INT 25
59821: PUSH
59822: LD_INT 2
59824: PUSH
59825: EMPTY
59826: LIST
59827: LIST
59828: PPUSH
59829: CALL_OW 72
59833: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59834: LD_ADDR_VAR 0 7
59838: PUSH
59839: LD_EXP 58
59843: PUSH
59844: LD_VAR 0 1
59848: ARRAY
59849: PPUSH
59850: LD_INT 25
59852: PUSH
59853: LD_INT 3
59855: PUSH
59856: EMPTY
59857: LIST
59858: LIST
59859: PPUSH
59860: CALL_OW 72
59864: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59865: LD_ADDR_VAR 0 8
59869: PUSH
59870: LD_EXP 58
59874: PUSH
59875: LD_VAR 0 1
59879: ARRAY
59880: PPUSH
59881: LD_INT 25
59883: PUSH
59884: LD_INT 4
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PUSH
59891: LD_INT 24
59893: PUSH
59894: LD_INT 251
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: PPUSH
59905: CALL_OW 72
59909: ST_TO_ADDR
// if mc_scan [ base ] then
59910: LD_EXP 81
59914: PUSH
59915: LD_VAR 0 1
59919: ARRAY
59920: IFFALSE 60381
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59922: LD_ADDR_EXP 100
59926: PUSH
59927: LD_EXP 100
59931: PPUSH
59932: LD_VAR 0 1
59936: PPUSH
59937: LD_INT 4
59939: PPUSH
59940: CALL_OW 1
59944: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59945: LD_ADDR_VAR 0 12
59949: PUSH
59950: LD_EXP 58
59954: PUSH
59955: LD_VAR 0 1
59959: ARRAY
59960: PPUSH
59961: LD_INT 2
59963: PUSH
59964: LD_INT 30
59966: PUSH
59967: LD_INT 4
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: PUSH
59974: LD_INT 30
59976: PUSH
59977: LD_INT 5
59979: PUSH
59980: EMPTY
59981: LIST
59982: LIST
59983: PUSH
59984: EMPTY
59985: LIST
59986: LIST
59987: LIST
59988: PPUSH
59989: CALL_OW 72
59993: ST_TO_ADDR
// if not b then
59994: LD_VAR 0 12
59998: NOT
59999: IFFALSE 60003
// exit ;
60001: GO 62746
// p := [ ] ;
60003: LD_ADDR_VAR 0 11
60007: PUSH
60008: EMPTY
60009: ST_TO_ADDR
// if sci >= 2 then
60010: LD_VAR 0 8
60014: PUSH
60015: LD_INT 2
60017: GREATEREQUAL
60018: IFFALSE 60049
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60020: LD_ADDR_VAR 0 8
60024: PUSH
60025: LD_VAR 0 8
60029: PUSH
60030: LD_INT 1
60032: ARRAY
60033: PUSH
60034: LD_VAR 0 8
60038: PUSH
60039: LD_INT 2
60041: ARRAY
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: ST_TO_ADDR
60047: GO 60110
// if sci = 1 then
60049: LD_VAR 0 8
60053: PUSH
60054: LD_INT 1
60056: EQUAL
60057: IFFALSE 60078
// sci := [ sci [ 1 ] ] else
60059: LD_ADDR_VAR 0 8
60063: PUSH
60064: LD_VAR 0 8
60068: PUSH
60069: LD_INT 1
60071: ARRAY
60072: PUSH
60073: EMPTY
60074: LIST
60075: ST_TO_ADDR
60076: GO 60110
// if sci = 0 then
60078: LD_VAR 0 8
60082: PUSH
60083: LD_INT 0
60085: EQUAL
60086: IFFALSE 60110
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60088: LD_ADDR_VAR 0 11
60092: PUSH
60093: LD_VAR 0 4
60097: PPUSH
60098: LD_INT 4
60100: PPUSH
60101: CALL 54455 0 2
60105: PUSH
60106: LD_INT 1
60108: ARRAY
60109: ST_TO_ADDR
// if eng > 4 then
60110: LD_VAR 0 6
60114: PUSH
60115: LD_INT 4
60117: GREATER
60118: IFFALSE 60164
// for i = eng downto 4 do
60120: LD_ADDR_VAR 0 3
60124: PUSH
60125: DOUBLE
60126: LD_VAR 0 6
60130: INC
60131: ST_TO_ADDR
60132: LD_INT 4
60134: PUSH
60135: FOR_DOWNTO
60136: IFFALSE 60162
// eng := eng diff eng [ i ] ;
60138: LD_ADDR_VAR 0 6
60142: PUSH
60143: LD_VAR 0 6
60147: PUSH
60148: LD_VAR 0 6
60152: PUSH
60153: LD_VAR 0 3
60157: ARRAY
60158: DIFF
60159: ST_TO_ADDR
60160: GO 60135
60162: POP
60163: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60164: LD_ADDR_VAR 0 4
60168: PUSH
60169: LD_VAR 0 4
60173: PUSH
60174: LD_VAR 0 5
60178: PUSH
60179: LD_VAR 0 6
60183: UNION
60184: PUSH
60185: LD_VAR 0 7
60189: UNION
60190: PUSH
60191: LD_VAR 0 8
60195: UNION
60196: DIFF
60197: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60198: LD_ADDR_VAR 0 13
60202: PUSH
60203: LD_EXP 58
60207: PUSH
60208: LD_VAR 0 1
60212: ARRAY
60213: PPUSH
60214: LD_INT 2
60216: PUSH
60217: LD_INT 30
60219: PUSH
60220: LD_INT 32
60222: PUSH
60223: EMPTY
60224: LIST
60225: LIST
60226: PUSH
60227: LD_INT 30
60229: PUSH
60230: LD_INT 31
60232: PUSH
60233: EMPTY
60234: LIST
60235: LIST
60236: PUSH
60237: EMPTY
60238: LIST
60239: LIST
60240: LIST
60241: PPUSH
60242: CALL_OW 72
60246: PUSH
60247: LD_EXP 58
60251: PUSH
60252: LD_VAR 0 1
60256: ARRAY
60257: PPUSH
60258: LD_INT 2
60260: PUSH
60261: LD_INT 30
60263: PUSH
60264: LD_INT 4
60266: PUSH
60267: EMPTY
60268: LIST
60269: LIST
60270: PUSH
60271: LD_INT 30
60273: PUSH
60274: LD_INT 5
60276: PUSH
60277: EMPTY
60278: LIST
60279: LIST
60280: PUSH
60281: EMPTY
60282: LIST
60283: LIST
60284: LIST
60285: PPUSH
60286: CALL_OW 72
60290: PUSH
60291: LD_INT 6
60293: MUL
60294: PLUS
60295: ST_TO_ADDR
// if bcount < tmp then
60296: LD_VAR 0 13
60300: PUSH
60301: LD_VAR 0 4
60305: LESS
60306: IFFALSE 60352
// for i = tmp downto bcount do
60308: LD_ADDR_VAR 0 3
60312: PUSH
60313: DOUBLE
60314: LD_VAR 0 4
60318: INC
60319: ST_TO_ADDR
60320: LD_VAR 0 13
60324: PUSH
60325: FOR_DOWNTO
60326: IFFALSE 60350
// tmp := Delete ( tmp , tmp ) ;
60328: LD_ADDR_VAR 0 4
60332: PUSH
60333: LD_VAR 0 4
60337: PPUSH
60338: LD_VAR 0 4
60342: PPUSH
60343: CALL_OW 3
60347: ST_TO_ADDR
60348: GO 60325
60350: POP
60351: POP
// result := [ tmp , 0 , 0 , p ] ;
60352: LD_ADDR_VAR 0 2
60356: PUSH
60357: LD_VAR 0 4
60361: PUSH
60362: LD_INT 0
60364: PUSH
60365: LD_INT 0
60367: PUSH
60368: LD_VAR 0 11
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: LIST
60377: LIST
60378: ST_TO_ADDR
// exit ;
60379: GO 62746
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60381: LD_EXP 58
60385: PUSH
60386: LD_VAR 0 1
60390: ARRAY
60391: PPUSH
60392: LD_INT 2
60394: PUSH
60395: LD_INT 30
60397: PUSH
60398: LD_INT 6
60400: PUSH
60401: EMPTY
60402: LIST
60403: LIST
60404: PUSH
60405: LD_INT 30
60407: PUSH
60408: LD_INT 7
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: LD_INT 30
60417: PUSH
60418: LD_INT 8
60420: PUSH
60421: EMPTY
60422: LIST
60423: LIST
60424: PUSH
60425: EMPTY
60426: LIST
60427: LIST
60428: LIST
60429: LIST
60430: PPUSH
60431: CALL_OW 72
60435: NOT
60436: PUSH
60437: LD_EXP 58
60441: PUSH
60442: LD_VAR 0 1
60446: ARRAY
60447: PPUSH
60448: LD_INT 30
60450: PUSH
60451: LD_INT 3
60453: PUSH
60454: EMPTY
60455: LIST
60456: LIST
60457: PPUSH
60458: CALL_OW 72
60462: NOT
60463: AND
60464: IFFALSE 60536
// begin if eng = tmp then
60466: LD_VAR 0 6
60470: PUSH
60471: LD_VAR 0 4
60475: EQUAL
60476: IFFALSE 60480
// exit ;
60478: GO 62746
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60480: LD_ADDR_EXP 100
60484: PUSH
60485: LD_EXP 100
60489: PPUSH
60490: LD_VAR 0 1
60494: PPUSH
60495: LD_INT 1
60497: PPUSH
60498: CALL_OW 1
60502: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60503: LD_ADDR_VAR 0 2
60507: PUSH
60508: LD_INT 0
60510: PUSH
60511: LD_VAR 0 4
60515: PUSH
60516: LD_VAR 0 6
60520: DIFF
60521: PUSH
60522: LD_INT 0
60524: PUSH
60525: LD_INT 0
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: LIST
60532: LIST
60533: ST_TO_ADDR
// exit ;
60534: GO 62746
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60536: LD_EXP 85
60540: PUSH
60541: LD_EXP 84
60545: PUSH
60546: LD_VAR 0 1
60550: ARRAY
60551: ARRAY
60552: PUSH
60553: LD_EXP 58
60557: PUSH
60558: LD_VAR 0 1
60562: ARRAY
60563: PPUSH
60564: LD_INT 2
60566: PUSH
60567: LD_INT 30
60569: PUSH
60570: LD_INT 6
60572: PUSH
60573: EMPTY
60574: LIST
60575: LIST
60576: PUSH
60577: LD_INT 30
60579: PUSH
60580: LD_INT 7
60582: PUSH
60583: EMPTY
60584: LIST
60585: LIST
60586: PUSH
60587: LD_INT 30
60589: PUSH
60590: LD_INT 8
60592: PUSH
60593: EMPTY
60594: LIST
60595: LIST
60596: PUSH
60597: EMPTY
60598: LIST
60599: LIST
60600: LIST
60601: LIST
60602: PPUSH
60603: CALL_OW 72
60607: AND
60608: PUSH
60609: LD_EXP 58
60613: PUSH
60614: LD_VAR 0 1
60618: ARRAY
60619: PPUSH
60620: LD_INT 30
60622: PUSH
60623: LD_INT 3
60625: PUSH
60626: EMPTY
60627: LIST
60628: LIST
60629: PPUSH
60630: CALL_OW 72
60634: NOT
60635: AND
60636: IFFALSE 60850
// begin if sci >= 6 then
60638: LD_VAR 0 8
60642: PUSH
60643: LD_INT 6
60645: GREATEREQUAL
60646: IFFALSE 60650
// exit ;
60648: GO 62746
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60650: LD_ADDR_EXP 100
60654: PUSH
60655: LD_EXP 100
60659: PPUSH
60660: LD_VAR 0 1
60664: PPUSH
60665: LD_INT 2
60667: PPUSH
60668: CALL_OW 1
60672: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60673: LD_ADDR_VAR 0 9
60677: PUSH
60678: LD_VAR 0 4
60682: PUSH
60683: LD_VAR 0 8
60687: DIFF
60688: PPUSH
60689: LD_INT 4
60691: PPUSH
60692: CALL 54455 0 2
60696: ST_TO_ADDR
// p := [ ] ;
60697: LD_ADDR_VAR 0 11
60701: PUSH
60702: EMPTY
60703: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60704: LD_VAR 0 8
60708: PUSH
60709: LD_INT 6
60711: LESS
60712: PUSH
60713: LD_VAR 0 9
60717: PUSH
60718: LD_INT 6
60720: GREATER
60721: AND
60722: IFFALSE 60803
// begin for i = 1 to 6 - sci do
60724: LD_ADDR_VAR 0 3
60728: PUSH
60729: DOUBLE
60730: LD_INT 1
60732: DEC
60733: ST_TO_ADDR
60734: LD_INT 6
60736: PUSH
60737: LD_VAR 0 8
60741: MINUS
60742: PUSH
60743: FOR_TO
60744: IFFALSE 60799
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60746: LD_ADDR_VAR 0 11
60750: PUSH
60751: LD_VAR 0 11
60755: PPUSH
60756: LD_VAR 0 11
60760: PUSH
60761: LD_INT 1
60763: PLUS
60764: PPUSH
60765: LD_VAR 0 9
60769: PUSH
60770: LD_INT 1
60772: ARRAY
60773: PPUSH
60774: CALL_OW 2
60778: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60779: LD_ADDR_VAR 0 9
60783: PUSH
60784: LD_VAR 0 9
60788: PPUSH
60789: LD_INT 1
60791: PPUSH
60792: CALL_OW 3
60796: ST_TO_ADDR
// end ;
60797: GO 60743
60799: POP
60800: POP
// end else
60801: GO 60823
// if sort then
60803: LD_VAR 0 9
60807: IFFALSE 60823
// p := sort [ 1 ] ;
60809: LD_ADDR_VAR 0 11
60813: PUSH
60814: LD_VAR 0 9
60818: PUSH
60819: LD_INT 1
60821: ARRAY
60822: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60823: LD_ADDR_VAR 0 2
60827: PUSH
60828: LD_INT 0
60830: PUSH
60831: LD_INT 0
60833: PUSH
60834: LD_INT 0
60836: PUSH
60837: LD_VAR 0 11
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: LIST
60846: LIST
60847: ST_TO_ADDR
// exit ;
60848: GO 62746
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60850: LD_EXP 85
60854: PUSH
60855: LD_EXP 84
60859: PUSH
60860: LD_VAR 0 1
60864: ARRAY
60865: ARRAY
60866: PUSH
60867: LD_EXP 58
60871: PUSH
60872: LD_VAR 0 1
60876: ARRAY
60877: PPUSH
60878: LD_INT 2
60880: PUSH
60881: LD_INT 30
60883: PUSH
60884: LD_INT 6
60886: PUSH
60887: EMPTY
60888: LIST
60889: LIST
60890: PUSH
60891: LD_INT 30
60893: PUSH
60894: LD_INT 7
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: PUSH
60901: LD_INT 30
60903: PUSH
60904: LD_INT 8
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PUSH
60911: EMPTY
60912: LIST
60913: LIST
60914: LIST
60915: LIST
60916: PPUSH
60917: CALL_OW 72
60921: AND
60922: PUSH
60923: LD_EXP 58
60927: PUSH
60928: LD_VAR 0 1
60932: ARRAY
60933: PPUSH
60934: LD_INT 30
60936: PUSH
60937: LD_INT 3
60939: PUSH
60940: EMPTY
60941: LIST
60942: LIST
60943: PPUSH
60944: CALL_OW 72
60948: AND
60949: IFFALSE 61476
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60951: LD_ADDR_EXP 100
60955: PUSH
60956: LD_EXP 100
60960: PPUSH
60961: LD_VAR 0 1
60965: PPUSH
60966: LD_INT 3
60968: PPUSH
60969: CALL_OW 1
60973: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60974: LD_ADDR_VAR 0 2
60978: PUSH
60979: LD_INT 0
60981: PUSH
60982: LD_INT 0
60984: PUSH
60985: LD_INT 0
60987: PUSH
60988: LD_INT 0
60990: PUSH
60991: EMPTY
60992: LIST
60993: LIST
60994: LIST
60995: LIST
60996: ST_TO_ADDR
// if not eng then
60997: LD_VAR 0 6
61001: NOT
61002: IFFALSE 61065
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61004: LD_ADDR_VAR 0 11
61008: PUSH
61009: LD_VAR 0 4
61013: PPUSH
61014: LD_INT 2
61016: PPUSH
61017: CALL 54455 0 2
61021: PUSH
61022: LD_INT 1
61024: ARRAY
61025: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61026: LD_ADDR_VAR 0 2
61030: PUSH
61031: LD_VAR 0 2
61035: PPUSH
61036: LD_INT 2
61038: PPUSH
61039: LD_VAR 0 11
61043: PPUSH
61044: CALL_OW 1
61048: ST_TO_ADDR
// tmp := tmp diff p ;
61049: LD_ADDR_VAR 0 4
61053: PUSH
61054: LD_VAR 0 4
61058: PUSH
61059: LD_VAR 0 11
61063: DIFF
61064: ST_TO_ADDR
// end ; if not eng then
61065: LD_VAR 0 6
61069: NOT
61070: IFFALSE 61096
// tmp := tmp diff ( mech union sci ) else
61072: LD_ADDR_VAR 0 4
61076: PUSH
61077: LD_VAR 0 4
61081: PUSH
61082: LD_VAR 0 7
61086: PUSH
61087: LD_VAR 0 8
61091: UNION
61092: DIFF
61093: ST_TO_ADDR
61094: GO 61128
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
61096: LD_ADDR_VAR 0 4
61100: PUSH
61101: LD_VAR 0 4
61105: PUSH
61106: LD_VAR 0 6
61110: PUSH
61111: LD_INT 1
61113: ARRAY
61114: PUSH
61115: LD_VAR 0 7
61119: UNION
61120: PUSH
61121: LD_VAR 0 8
61125: UNION
61126: DIFF
61127: ST_TO_ADDR
// if tmp and sci < 6 then
61128: LD_VAR 0 4
61132: PUSH
61133: LD_VAR 0 8
61137: PUSH
61138: LD_INT 6
61140: LESS
61141: AND
61142: IFFALSE 61301
// begin sort := SortBySkill ( tmp , 4 ) ;
61144: LD_ADDR_VAR 0 9
61148: PUSH
61149: LD_VAR 0 4
61153: PPUSH
61154: LD_INT 4
61156: PPUSH
61157: CALL 54455 0 2
61161: ST_TO_ADDR
// p := [ ] ;
61162: LD_ADDR_VAR 0 11
61166: PUSH
61167: EMPTY
61168: ST_TO_ADDR
// if sort then
61169: LD_VAR 0 9
61173: IFFALSE 61272
// for i = 1 to 6 - sci do
61175: LD_ADDR_VAR 0 3
61179: PUSH
61180: DOUBLE
61181: LD_INT 1
61183: DEC
61184: ST_TO_ADDR
61185: LD_INT 6
61187: PUSH
61188: LD_VAR 0 8
61192: MINUS
61193: PUSH
61194: FOR_TO
61195: IFFALSE 61270
// begin if i = sort then
61197: LD_VAR 0 3
61201: PUSH
61202: LD_VAR 0 9
61206: EQUAL
61207: IFFALSE 61211
// break ;
61209: GO 61270
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61211: LD_ADDR_VAR 0 11
61215: PUSH
61216: LD_VAR 0 11
61220: PPUSH
61221: LD_VAR 0 11
61225: PUSH
61226: LD_INT 1
61228: PLUS
61229: PPUSH
61230: LD_VAR 0 9
61234: PUSH
61235: LD_VAR 0 3
61239: ARRAY
61240: PPUSH
61241: CALL_OW 2
61245: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61246: LD_ADDR_VAR 0 4
61250: PUSH
61251: LD_VAR 0 4
61255: PUSH
61256: LD_VAR 0 9
61260: PUSH
61261: LD_VAR 0 3
61265: ARRAY
61266: DIFF
61267: ST_TO_ADDR
// end ;
61268: GO 61194
61270: POP
61271: POP
// if p then
61272: LD_VAR 0 11
61276: IFFALSE 61301
// result := Replace ( result , 4 , p ) ;
61278: LD_ADDR_VAR 0 2
61282: PUSH
61283: LD_VAR 0 2
61287: PPUSH
61288: LD_INT 4
61290: PPUSH
61291: LD_VAR 0 11
61295: PPUSH
61296: CALL_OW 1
61300: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61301: LD_VAR 0 4
61305: PUSH
61306: LD_VAR 0 7
61310: PUSH
61311: LD_INT 6
61313: LESS
61314: AND
61315: IFFALSE 61474
// begin sort := SortBySkill ( tmp , 3 ) ;
61317: LD_ADDR_VAR 0 9
61321: PUSH
61322: LD_VAR 0 4
61326: PPUSH
61327: LD_INT 3
61329: PPUSH
61330: CALL 54455 0 2
61334: ST_TO_ADDR
// p := [ ] ;
61335: LD_ADDR_VAR 0 11
61339: PUSH
61340: EMPTY
61341: ST_TO_ADDR
// if sort then
61342: LD_VAR 0 9
61346: IFFALSE 61445
// for i = 1 to 6 - mech do
61348: LD_ADDR_VAR 0 3
61352: PUSH
61353: DOUBLE
61354: LD_INT 1
61356: DEC
61357: ST_TO_ADDR
61358: LD_INT 6
61360: PUSH
61361: LD_VAR 0 7
61365: MINUS
61366: PUSH
61367: FOR_TO
61368: IFFALSE 61443
// begin if i = sort then
61370: LD_VAR 0 3
61374: PUSH
61375: LD_VAR 0 9
61379: EQUAL
61380: IFFALSE 61384
// break ;
61382: GO 61443
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61384: LD_ADDR_VAR 0 11
61388: PUSH
61389: LD_VAR 0 11
61393: PPUSH
61394: LD_VAR 0 11
61398: PUSH
61399: LD_INT 1
61401: PLUS
61402: PPUSH
61403: LD_VAR 0 9
61407: PUSH
61408: LD_VAR 0 3
61412: ARRAY
61413: PPUSH
61414: CALL_OW 2
61418: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61419: LD_ADDR_VAR 0 4
61423: PUSH
61424: LD_VAR 0 4
61428: PUSH
61429: LD_VAR 0 9
61433: PUSH
61434: LD_VAR 0 3
61438: ARRAY
61439: DIFF
61440: ST_TO_ADDR
// end ;
61441: GO 61367
61443: POP
61444: POP
// if p then
61445: LD_VAR 0 11
61449: IFFALSE 61474
// result := Replace ( result , 3 , p ) ;
61451: LD_ADDR_VAR 0 2
61455: PUSH
61456: LD_VAR 0 2
61460: PPUSH
61461: LD_INT 3
61463: PPUSH
61464: LD_VAR 0 11
61468: PPUSH
61469: CALL_OW 1
61473: ST_TO_ADDR
// end ; exit ;
61474: GO 62746
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61476: LD_EXP 85
61480: PUSH
61481: LD_EXP 84
61485: PUSH
61486: LD_VAR 0 1
61490: ARRAY
61491: ARRAY
61492: NOT
61493: PUSH
61494: LD_EXP 58
61498: PUSH
61499: LD_VAR 0 1
61503: ARRAY
61504: PPUSH
61505: LD_INT 30
61507: PUSH
61508: LD_INT 3
61510: PUSH
61511: EMPTY
61512: LIST
61513: LIST
61514: PPUSH
61515: CALL_OW 72
61519: AND
61520: PUSH
61521: LD_EXP 63
61525: PUSH
61526: LD_VAR 0 1
61530: ARRAY
61531: AND
61532: IFFALSE 62076
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61534: LD_ADDR_EXP 100
61538: PUSH
61539: LD_EXP 100
61543: PPUSH
61544: LD_VAR 0 1
61548: PPUSH
61549: LD_INT 5
61551: PPUSH
61552: CALL_OW 1
61556: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61557: LD_ADDR_VAR 0 2
61561: PUSH
61562: LD_INT 0
61564: PUSH
61565: LD_INT 0
61567: PUSH
61568: LD_INT 0
61570: PUSH
61571: LD_INT 0
61573: PUSH
61574: EMPTY
61575: LIST
61576: LIST
61577: LIST
61578: LIST
61579: ST_TO_ADDR
// if sci > 1 then
61580: LD_VAR 0 8
61584: PUSH
61585: LD_INT 1
61587: GREATER
61588: IFFALSE 61616
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61590: LD_ADDR_VAR 0 4
61594: PUSH
61595: LD_VAR 0 4
61599: PUSH
61600: LD_VAR 0 8
61604: PUSH
61605: LD_VAR 0 8
61609: PUSH
61610: LD_INT 1
61612: ARRAY
61613: DIFF
61614: DIFF
61615: ST_TO_ADDR
// if tmp and not sci then
61616: LD_VAR 0 4
61620: PUSH
61621: LD_VAR 0 8
61625: NOT
61626: AND
61627: IFFALSE 61696
// begin sort := SortBySkill ( tmp , 4 ) ;
61629: LD_ADDR_VAR 0 9
61633: PUSH
61634: LD_VAR 0 4
61638: PPUSH
61639: LD_INT 4
61641: PPUSH
61642: CALL 54455 0 2
61646: ST_TO_ADDR
// if sort then
61647: LD_VAR 0 9
61651: IFFALSE 61667
// p := sort [ 1 ] ;
61653: LD_ADDR_VAR 0 11
61657: PUSH
61658: LD_VAR 0 9
61662: PUSH
61663: LD_INT 1
61665: ARRAY
61666: ST_TO_ADDR
// if p then
61667: LD_VAR 0 11
61671: IFFALSE 61696
// result := Replace ( result , 4 , p ) ;
61673: LD_ADDR_VAR 0 2
61677: PUSH
61678: LD_VAR 0 2
61682: PPUSH
61683: LD_INT 4
61685: PPUSH
61686: LD_VAR 0 11
61690: PPUSH
61691: CALL_OW 1
61695: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61696: LD_ADDR_VAR 0 4
61700: PUSH
61701: LD_VAR 0 4
61705: PUSH
61706: LD_VAR 0 7
61710: DIFF
61711: ST_TO_ADDR
// if tmp and mech < 6 then
61712: LD_VAR 0 4
61716: PUSH
61717: LD_VAR 0 7
61721: PUSH
61722: LD_INT 6
61724: LESS
61725: AND
61726: IFFALSE 61885
// begin sort := SortBySkill ( tmp , 3 ) ;
61728: LD_ADDR_VAR 0 9
61732: PUSH
61733: LD_VAR 0 4
61737: PPUSH
61738: LD_INT 3
61740: PPUSH
61741: CALL 54455 0 2
61745: ST_TO_ADDR
// p := [ ] ;
61746: LD_ADDR_VAR 0 11
61750: PUSH
61751: EMPTY
61752: ST_TO_ADDR
// if sort then
61753: LD_VAR 0 9
61757: IFFALSE 61856
// for i = 1 to 6 - mech do
61759: LD_ADDR_VAR 0 3
61763: PUSH
61764: DOUBLE
61765: LD_INT 1
61767: DEC
61768: ST_TO_ADDR
61769: LD_INT 6
61771: PUSH
61772: LD_VAR 0 7
61776: MINUS
61777: PUSH
61778: FOR_TO
61779: IFFALSE 61854
// begin if i = sort then
61781: LD_VAR 0 3
61785: PUSH
61786: LD_VAR 0 9
61790: EQUAL
61791: IFFALSE 61795
// break ;
61793: GO 61854
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61795: LD_ADDR_VAR 0 11
61799: PUSH
61800: LD_VAR 0 11
61804: PPUSH
61805: LD_VAR 0 11
61809: PUSH
61810: LD_INT 1
61812: PLUS
61813: PPUSH
61814: LD_VAR 0 9
61818: PUSH
61819: LD_VAR 0 3
61823: ARRAY
61824: PPUSH
61825: CALL_OW 2
61829: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61830: LD_ADDR_VAR 0 4
61834: PUSH
61835: LD_VAR 0 4
61839: PUSH
61840: LD_VAR 0 9
61844: PUSH
61845: LD_VAR 0 3
61849: ARRAY
61850: DIFF
61851: ST_TO_ADDR
// end ;
61852: GO 61778
61854: POP
61855: POP
// if p then
61856: LD_VAR 0 11
61860: IFFALSE 61885
// result := Replace ( result , 3 , p ) ;
61862: LD_ADDR_VAR 0 2
61866: PUSH
61867: LD_VAR 0 2
61871: PPUSH
61872: LD_INT 3
61874: PPUSH
61875: LD_VAR 0 11
61879: PPUSH
61880: CALL_OW 1
61884: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61885: LD_ADDR_VAR 0 4
61889: PUSH
61890: LD_VAR 0 4
61894: PUSH
61895: LD_VAR 0 6
61899: DIFF
61900: ST_TO_ADDR
// if tmp and eng < 6 then
61901: LD_VAR 0 4
61905: PUSH
61906: LD_VAR 0 6
61910: PUSH
61911: LD_INT 6
61913: LESS
61914: AND
61915: IFFALSE 62074
// begin sort := SortBySkill ( tmp , 2 ) ;
61917: LD_ADDR_VAR 0 9
61921: PUSH
61922: LD_VAR 0 4
61926: PPUSH
61927: LD_INT 2
61929: PPUSH
61930: CALL 54455 0 2
61934: ST_TO_ADDR
// p := [ ] ;
61935: LD_ADDR_VAR 0 11
61939: PUSH
61940: EMPTY
61941: ST_TO_ADDR
// if sort then
61942: LD_VAR 0 9
61946: IFFALSE 62045
// for i = 1 to 6 - eng do
61948: LD_ADDR_VAR 0 3
61952: PUSH
61953: DOUBLE
61954: LD_INT 1
61956: DEC
61957: ST_TO_ADDR
61958: LD_INT 6
61960: PUSH
61961: LD_VAR 0 6
61965: MINUS
61966: PUSH
61967: FOR_TO
61968: IFFALSE 62043
// begin if i = sort then
61970: LD_VAR 0 3
61974: PUSH
61975: LD_VAR 0 9
61979: EQUAL
61980: IFFALSE 61984
// break ;
61982: GO 62043
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61984: LD_ADDR_VAR 0 11
61988: PUSH
61989: LD_VAR 0 11
61993: PPUSH
61994: LD_VAR 0 11
61998: PUSH
61999: LD_INT 1
62001: PLUS
62002: PPUSH
62003: LD_VAR 0 9
62007: PUSH
62008: LD_VAR 0 3
62012: ARRAY
62013: PPUSH
62014: CALL_OW 2
62018: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62019: LD_ADDR_VAR 0 4
62023: PUSH
62024: LD_VAR 0 4
62028: PUSH
62029: LD_VAR 0 9
62033: PUSH
62034: LD_VAR 0 3
62038: ARRAY
62039: DIFF
62040: ST_TO_ADDR
// end ;
62041: GO 61967
62043: POP
62044: POP
// if p then
62045: LD_VAR 0 11
62049: IFFALSE 62074
// result := Replace ( result , 2 , p ) ;
62051: LD_ADDR_VAR 0 2
62055: PUSH
62056: LD_VAR 0 2
62060: PPUSH
62061: LD_INT 2
62063: PPUSH
62064: LD_VAR 0 11
62068: PPUSH
62069: CALL_OW 1
62073: ST_TO_ADDR
// end ; exit ;
62074: GO 62746
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62076: LD_EXP 85
62080: PUSH
62081: LD_EXP 84
62085: PUSH
62086: LD_VAR 0 1
62090: ARRAY
62091: ARRAY
62092: NOT
62093: PUSH
62094: LD_EXP 58
62098: PUSH
62099: LD_VAR 0 1
62103: ARRAY
62104: PPUSH
62105: LD_INT 30
62107: PUSH
62108: LD_INT 3
62110: PUSH
62111: EMPTY
62112: LIST
62113: LIST
62114: PPUSH
62115: CALL_OW 72
62119: AND
62120: PUSH
62121: LD_EXP 63
62125: PUSH
62126: LD_VAR 0 1
62130: ARRAY
62131: NOT
62132: AND
62133: IFFALSE 62746
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62135: LD_ADDR_EXP 100
62139: PUSH
62140: LD_EXP 100
62144: PPUSH
62145: LD_VAR 0 1
62149: PPUSH
62150: LD_INT 6
62152: PPUSH
62153: CALL_OW 1
62157: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62158: LD_ADDR_VAR 0 2
62162: PUSH
62163: LD_INT 0
62165: PUSH
62166: LD_INT 0
62168: PUSH
62169: LD_INT 0
62171: PUSH
62172: LD_INT 0
62174: PUSH
62175: EMPTY
62176: LIST
62177: LIST
62178: LIST
62179: LIST
62180: ST_TO_ADDR
// if sci >= 1 then
62181: LD_VAR 0 8
62185: PUSH
62186: LD_INT 1
62188: GREATEREQUAL
62189: IFFALSE 62211
// tmp := tmp diff sci [ 1 ] ;
62191: LD_ADDR_VAR 0 4
62195: PUSH
62196: LD_VAR 0 4
62200: PUSH
62201: LD_VAR 0 8
62205: PUSH
62206: LD_INT 1
62208: ARRAY
62209: DIFF
62210: ST_TO_ADDR
// if tmp and not sci then
62211: LD_VAR 0 4
62215: PUSH
62216: LD_VAR 0 8
62220: NOT
62221: AND
62222: IFFALSE 62291
// begin sort := SortBySkill ( tmp , 4 ) ;
62224: LD_ADDR_VAR 0 9
62228: PUSH
62229: LD_VAR 0 4
62233: PPUSH
62234: LD_INT 4
62236: PPUSH
62237: CALL 54455 0 2
62241: ST_TO_ADDR
// if sort then
62242: LD_VAR 0 9
62246: IFFALSE 62262
// p := sort [ 1 ] ;
62248: LD_ADDR_VAR 0 11
62252: PUSH
62253: LD_VAR 0 9
62257: PUSH
62258: LD_INT 1
62260: ARRAY
62261: ST_TO_ADDR
// if p then
62262: LD_VAR 0 11
62266: IFFALSE 62291
// result := Replace ( result , 4 , p ) ;
62268: LD_ADDR_VAR 0 2
62272: PUSH
62273: LD_VAR 0 2
62277: PPUSH
62278: LD_INT 4
62280: PPUSH
62281: LD_VAR 0 11
62285: PPUSH
62286: CALL_OW 1
62290: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62291: LD_ADDR_VAR 0 4
62295: PUSH
62296: LD_VAR 0 4
62300: PUSH
62301: LD_VAR 0 7
62305: DIFF
62306: ST_TO_ADDR
// if tmp and mech < 6 then
62307: LD_VAR 0 4
62311: PUSH
62312: LD_VAR 0 7
62316: PUSH
62317: LD_INT 6
62319: LESS
62320: AND
62321: IFFALSE 62480
// begin sort := SortBySkill ( tmp , 3 ) ;
62323: LD_ADDR_VAR 0 9
62327: PUSH
62328: LD_VAR 0 4
62332: PPUSH
62333: LD_INT 3
62335: PPUSH
62336: CALL 54455 0 2
62340: ST_TO_ADDR
// p := [ ] ;
62341: LD_ADDR_VAR 0 11
62345: PUSH
62346: EMPTY
62347: ST_TO_ADDR
// if sort then
62348: LD_VAR 0 9
62352: IFFALSE 62451
// for i = 1 to 6 - mech do
62354: LD_ADDR_VAR 0 3
62358: PUSH
62359: DOUBLE
62360: LD_INT 1
62362: DEC
62363: ST_TO_ADDR
62364: LD_INT 6
62366: PUSH
62367: LD_VAR 0 7
62371: MINUS
62372: PUSH
62373: FOR_TO
62374: IFFALSE 62449
// begin if i = sort then
62376: LD_VAR 0 3
62380: PUSH
62381: LD_VAR 0 9
62385: EQUAL
62386: IFFALSE 62390
// break ;
62388: GO 62449
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62390: LD_ADDR_VAR 0 11
62394: PUSH
62395: LD_VAR 0 11
62399: PPUSH
62400: LD_VAR 0 11
62404: PUSH
62405: LD_INT 1
62407: PLUS
62408: PPUSH
62409: LD_VAR 0 9
62413: PUSH
62414: LD_VAR 0 3
62418: ARRAY
62419: PPUSH
62420: CALL_OW 2
62424: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62425: LD_ADDR_VAR 0 4
62429: PUSH
62430: LD_VAR 0 4
62434: PUSH
62435: LD_VAR 0 9
62439: PUSH
62440: LD_VAR 0 3
62444: ARRAY
62445: DIFF
62446: ST_TO_ADDR
// end ;
62447: GO 62373
62449: POP
62450: POP
// if p then
62451: LD_VAR 0 11
62455: IFFALSE 62480
// result := Replace ( result , 3 , p ) ;
62457: LD_ADDR_VAR 0 2
62461: PUSH
62462: LD_VAR 0 2
62466: PPUSH
62467: LD_INT 3
62469: PPUSH
62470: LD_VAR 0 11
62474: PPUSH
62475: CALL_OW 1
62479: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62480: LD_ADDR_VAR 0 4
62484: PUSH
62485: LD_VAR 0 4
62489: PUSH
62490: LD_VAR 0 6
62494: DIFF
62495: ST_TO_ADDR
// if tmp and eng < 4 then
62496: LD_VAR 0 4
62500: PUSH
62501: LD_VAR 0 6
62505: PUSH
62506: LD_INT 4
62508: LESS
62509: AND
62510: IFFALSE 62671
// begin sort := SortBySkill ( tmp , 2 ) ;
62512: LD_ADDR_VAR 0 9
62516: PUSH
62517: LD_VAR 0 4
62521: PPUSH
62522: LD_INT 2
62524: PPUSH
62525: CALL 54455 0 2
62529: ST_TO_ADDR
// p := [ ] ;
62530: LD_ADDR_VAR 0 11
62534: PUSH
62535: EMPTY
62536: ST_TO_ADDR
// if sort then
62537: LD_VAR 0 9
62541: IFFALSE 62640
// for i = 1 to 4 - eng do
62543: LD_ADDR_VAR 0 3
62547: PUSH
62548: DOUBLE
62549: LD_INT 1
62551: DEC
62552: ST_TO_ADDR
62553: LD_INT 4
62555: PUSH
62556: LD_VAR 0 6
62560: MINUS
62561: PUSH
62562: FOR_TO
62563: IFFALSE 62638
// begin if i = sort then
62565: LD_VAR 0 3
62569: PUSH
62570: LD_VAR 0 9
62574: EQUAL
62575: IFFALSE 62579
// break ;
62577: GO 62638
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62579: LD_ADDR_VAR 0 11
62583: PUSH
62584: LD_VAR 0 11
62588: PPUSH
62589: LD_VAR 0 11
62593: PUSH
62594: LD_INT 1
62596: PLUS
62597: PPUSH
62598: LD_VAR 0 9
62602: PUSH
62603: LD_VAR 0 3
62607: ARRAY
62608: PPUSH
62609: CALL_OW 2
62613: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62614: LD_ADDR_VAR 0 4
62618: PUSH
62619: LD_VAR 0 4
62623: PUSH
62624: LD_VAR 0 9
62628: PUSH
62629: LD_VAR 0 3
62633: ARRAY
62634: DIFF
62635: ST_TO_ADDR
// end ;
62636: GO 62562
62638: POP
62639: POP
// if p then
62640: LD_VAR 0 11
62644: IFFALSE 62669
// result := Replace ( result , 2 , p ) ;
62646: LD_ADDR_VAR 0 2
62650: PUSH
62651: LD_VAR 0 2
62655: PPUSH
62656: LD_INT 2
62658: PPUSH
62659: LD_VAR 0 11
62663: PPUSH
62664: CALL_OW 1
62668: ST_TO_ADDR
// end else
62669: GO 62715
// for i = eng downto 5 do
62671: LD_ADDR_VAR 0 3
62675: PUSH
62676: DOUBLE
62677: LD_VAR 0 6
62681: INC
62682: ST_TO_ADDR
62683: LD_INT 5
62685: PUSH
62686: FOR_DOWNTO
62687: IFFALSE 62713
// tmp := tmp union eng [ i ] ;
62689: LD_ADDR_VAR 0 4
62693: PUSH
62694: LD_VAR 0 4
62698: PUSH
62699: LD_VAR 0 6
62703: PUSH
62704: LD_VAR 0 3
62708: ARRAY
62709: UNION
62710: ST_TO_ADDR
62711: GO 62686
62713: POP
62714: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62715: LD_ADDR_VAR 0 2
62719: PUSH
62720: LD_VAR 0 2
62724: PPUSH
62725: LD_INT 1
62727: PPUSH
62728: LD_VAR 0 4
62732: PUSH
62733: LD_VAR 0 5
62737: DIFF
62738: PPUSH
62739: CALL_OW 1
62743: ST_TO_ADDR
// exit ;
62744: GO 62746
// end ; end ;
62746: LD_VAR 0 2
62750: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62751: LD_INT 0
62753: PPUSH
62754: PPUSH
62755: PPUSH
// if not mc_bases then
62756: LD_EXP 58
62760: NOT
62761: IFFALSE 62765
// exit ;
62763: GO 62871
// for i = 1 to mc_bases do
62765: LD_ADDR_VAR 0 2
62769: PUSH
62770: DOUBLE
62771: LD_INT 1
62773: DEC
62774: ST_TO_ADDR
62775: LD_EXP 58
62779: PUSH
62780: FOR_TO
62781: IFFALSE 62862
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62783: LD_ADDR_VAR 0 3
62787: PUSH
62788: LD_EXP 58
62792: PUSH
62793: LD_VAR 0 2
62797: ARRAY
62798: PPUSH
62799: LD_INT 21
62801: PUSH
62802: LD_INT 3
62804: PUSH
62805: EMPTY
62806: LIST
62807: LIST
62808: PUSH
62809: LD_INT 3
62811: PUSH
62812: LD_INT 24
62814: PUSH
62815: LD_INT 1000
62817: PUSH
62818: EMPTY
62819: LIST
62820: LIST
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: EMPTY
62827: LIST
62828: LIST
62829: PPUSH
62830: CALL_OW 72
62834: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62835: LD_ADDR_EXP 59
62839: PUSH
62840: LD_EXP 59
62844: PPUSH
62845: LD_VAR 0 2
62849: PPUSH
62850: LD_VAR 0 3
62854: PPUSH
62855: CALL_OW 1
62859: ST_TO_ADDR
// end ;
62860: GO 62780
62862: POP
62863: POP
// RaiseSailEvent ( 101 ) ;
62864: LD_INT 101
62866: PPUSH
62867: CALL_OW 427
// end ;
62871: LD_VAR 0 1
62875: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62876: LD_INT 0
62878: PPUSH
62879: PPUSH
62880: PPUSH
62881: PPUSH
62882: PPUSH
62883: PPUSH
62884: PPUSH
// if not mc_bases then
62885: LD_EXP 58
62889: NOT
62890: IFFALSE 62894
// exit ;
62892: GO 63467
// for i = 1 to mc_bases do
62894: LD_ADDR_VAR 0 2
62898: PUSH
62899: DOUBLE
62900: LD_INT 1
62902: DEC
62903: ST_TO_ADDR
62904: LD_EXP 58
62908: PUSH
62909: FOR_TO
62910: IFFALSE 63458
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
62912: LD_ADDR_VAR 0 5
62916: PUSH
62917: LD_EXP 58
62921: PUSH
62922: LD_VAR 0 2
62926: ARRAY
62927: PUSH
62928: LD_EXP 87
62932: PUSH
62933: LD_VAR 0 2
62937: ARRAY
62938: UNION
62939: PPUSH
62940: LD_INT 21
62942: PUSH
62943: LD_INT 1
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PUSH
62950: LD_INT 1
62952: PUSH
62953: LD_INT 3
62955: PUSH
62956: LD_INT 54
62958: PUSH
62959: EMPTY
62960: LIST
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: PUSH
62966: LD_INT 3
62968: PUSH
62969: LD_INT 24
62971: PUSH
62972: LD_INT 750
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: PUSH
62979: EMPTY
62980: LIST
62981: LIST
62982: PUSH
62983: EMPTY
62984: LIST
62985: LIST
62986: LIST
62987: PUSH
62988: EMPTY
62989: LIST
62990: LIST
62991: PPUSH
62992: CALL_OW 72
62996: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62997: LD_ADDR_VAR 0 6
63001: PUSH
63002: LD_EXP 58
63006: PUSH
63007: LD_VAR 0 2
63011: ARRAY
63012: PPUSH
63013: LD_INT 21
63015: PUSH
63016: LD_INT 1
63018: PUSH
63019: EMPTY
63020: LIST
63021: LIST
63022: PUSH
63023: LD_INT 1
63025: PUSH
63026: LD_INT 3
63028: PUSH
63029: LD_INT 54
63031: PUSH
63032: EMPTY
63033: LIST
63034: PUSH
63035: EMPTY
63036: LIST
63037: LIST
63038: PUSH
63039: LD_INT 3
63041: PUSH
63042: LD_INT 24
63044: PUSH
63045: LD_INT 250
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: PUSH
63052: EMPTY
63053: LIST
63054: LIST
63055: PUSH
63056: EMPTY
63057: LIST
63058: LIST
63059: LIST
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: PPUSH
63065: CALL_OW 72
63069: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63070: LD_ADDR_VAR 0 7
63074: PUSH
63075: LD_VAR 0 5
63079: PUSH
63080: LD_VAR 0 6
63084: DIFF
63085: ST_TO_ADDR
// if not need_heal_1 then
63086: LD_VAR 0 6
63090: NOT
63091: IFFALSE 63124
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63093: LD_ADDR_EXP 61
63097: PUSH
63098: LD_EXP 61
63102: PPUSH
63103: LD_VAR 0 2
63107: PUSH
63108: LD_INT 1
63110: PUSH
63111: EMPTY
63112: LIST
63113: LIST
63114: PPUSH
63115: EMPTY
63116: PPUSH
63117: CALL 20270 0 3
63121: ST_TO_ADDR
63122: GO 63194
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63124: LD_ADDR_EXP 61
63128: PUSH
63129: LD_EXP 61
63133: PPUSH
63134: LD_VAR 0 2
63138: PUSH
63139: LD_INT 1
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: PPUSH
63146: LD_EXP 61
63150: PUSH
63151: LD_VAR 0 2
63155: ARRAY
63156: PUSH
63157: LD_INT 1
63159: ARRAY
63160: PPUSH
63161: LD_INT 3
63163: PUSH
63164: LD_INT 24
63166: PUSH
63167: LD_INT 1000
63169: PUSH
63170: EMPTY
63171: LIST
63172: LIST
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: PPUSH
63178: CALL_OW 72
63182: PUSH
63183: LD_VAR 0 6
63187: UNION
63188: PPUSH
63189: CALL 20270 0 3
63193: ST_TO_ADDR
// if not need_heal_2 then
63194: LD_VAR 0 7
63198: NOT
63199: IFFALSE 63232
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63201: LD_ADDR_EXP 61
63205: PUSH
63206: LD_EXP 61
63210: PPUSH
63211: LD_VAR 0 2
63215: PUSH
63216: LD_INT 2
63218: PUSH
63219: EMPTY
63220: LIST
63221: LIST
63222: PPUSH
63223: EMPTY
63224: PPUSH
63225: CALL 20270 0 3
63229: ST_TO_ADDR
63230: GO 63264
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63232: LD_ADDR_EXP 61
63236: PUSH
63237: LD_EXP 61
63241: PPUSH
63242: LD_VAR 0 2
63246: PUSH
63247: LD_INT 2
63249: PUSH
63250: EMPTY
63251: LIST
63252: LIST
63253: PPUSH
63254: LD_VAR 0 7
63258: PPUSH
63259: CALL 20270 0 3
63263: ST_TO_ADDR
// if need_heal_2 then
63264: LD_VAR 0 7
63268: IFFALSE 63440
// for j in need_heal_2 do
63270: LD_ADDR_VAR 0 3
63274: PUSH
63275: LD_VAR 0 7
63279: PUSH
63280: FOR_IN
63281: IFFALSE 63438
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
63283: LD_ADDR_VAR 0 5
63287: PUSH
63288: LD_EXP 58
63292: PUSH
63293: LD_VAR 0 2
63297: ARRAY
63298: PPUSH
63299: LD_INT 2
63301: PUSH
63302: LD_INT 30
63304: PUSH
63305: LD_INT 6
63307: PUSH
63308: EMPTY
63309: LIST
63310: LIST
63311: PUSH
63312: LD_INT 30
63314: PUSH
63315: LD_INT 7
63317: PUSH
63318: EMPTY
63319: LIST
63320: LIST
63321: PUSH
63322: LD_INT 30
63324: PUSH
63325: LD_INT 8
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PUSH
63332: LD_INT 30
63334: PUSH
63335: LD_INT 0
63337: PUSH
63338: EMPTY
63339: LIST
63340: LIST
63341: PUSH
63342: LD_INT 30
63344: PUSH
63345: LD_INT 1
63347: PUSH
63348: EMPTY
63349: LIST
63350: LIST
63351: PUSH
63352: LD_INT 25
63354: PUSH
63355: LD_INT 4
63357: PUSH
63358: EMPTY
63359: LIST
63360: LIST
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: LIST
63370: PPUSH
63371: CALL_OW 72
63375: ST_TO_ADDR
// if tmp then
63376: LD_VAR 0 5
63380: IFFALSE 63436
// begin k := NearestUnitToUnit ( tmp , j ) ;
63382: LD_ADDR_VAR 0 4
63386: PUSH
63387: LD_VAR 0 5
63391: PPUSH
63392: LD_VAR 0 3
63396: PPUSH
63397: CALL_OW 74
63401: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63402: LD_VAR 0 3
63406: PPUSH
63407: LD_VAR 0 4
63411: PPUSH
63412: CALL_OW 296
63416: PUSH
63417: LD_INT 7
63419: GREATER
63420: IFFALSE 63436
// ComMoveUnit ( j , k ) ;
63422: LD_VAR 0 3
63426: PPUSH
63427: LD_VAR 0 4
63431: PPUSH
63432: CALL_OW 112
// end ; end ;
63436: GO 63280
63438: POP
63439: POP
// if not need_heal_1 and not need_heal_2 then
63440: LD_VAR 0 6
63444: NOT
63445: PUSH
63446: LD_VAR 0 7
63450: NOT
63451: AND
63452: IFFALSE 63456
// continue ;
63454: GO 62909
// end ;
63456: GO 62909
63458: POP
63459: POP
// RaiseSailEvent ( 102 ) ;
63460: LD_INT 102
63462: PPUSH
63463: CALL_OW 427
// end ;
63467: LD_VAR 0 1
63471: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
63472: LD_INT 0
63474: PPUSH
63475: PPUSH
63476: PPUSH
63477: PPUSH
63478: PPUSH
// if not mc_bases then
63479: LD_EXP 58
63483: NOT
63484: IFFALSE 63488
// exit ;
63486: GO 63873
// for i = 1 to mc_bases do
63488: LD_ADDR_VAR 0 2
63492: PUSH
63493: DOUBLE
63494: LD_INT 1
63496: DEC
63497: ST_TO_ADDR
63498: LD_EXP 58
63502: PUSH
63503: FOR_TO
63504: IFFALSE 63871
// begin if not mc_building_need_repair [ i ] then
63506: LD_EXP 59
63510: PUSH
63511: LD_VAR 0 2
63515: ARRAY
63516: NOT
63517: IFFALSE 63555
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63519: LD_ADDR_EXP 60
63523: PUSH
63524: LD_EXP 60
63528: PPUSH
63529: LD_VAR 0 2
63533: PPUSH
63534: EMPTY
63535: PPUSH
63536: CALL_OW 1
63540: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63541: LD_VAR 0 2
63545: PPUSH
63546: LD_INT 101
63548: PPUSH
63549: CALL 58916 0 2
// continue ;
63553: GO 63503
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63555: LD_ADDR_EXP 64
63559: PUSH
63560: LD_EXP 64
63564: PPUSH
63565: LD_VAR 0 2
63569: PPUSH
63570: EMPTY
63571: PPUSH
63572: CALL_OW 1
63576: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63577: LD_VAR 0 2
63581: PPUSH
63582: LD_INT 103
63584: PPUSH
63585: CALL 58916 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63589: LD_ADDR_VAR 0 5
63593: PUSH
63594: LD_EXP 58
63598: PUSH
63599: LD_VAR 0 2
63603: ARRAY
63604: PUSH
63605: LD_EXP 87
63609: PUSH
63610: LD_VAR 0 2
63614: ARRAY
63615: UNION
63616: PPUSH
63617: LD_INT 2
63619: PUSH
63620: LD_INT 25
63622: PUSH
63623: LD_INT 2
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 25
63632: PUSH
63633: LD_INT 16
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: EMPTY
63641: LIST
63642: LIST
63643: LIST
63644: PUSH
63645: EMPTY
63646: LIST
63647: PPUSH
63648: CALL_OW 72
63652: ST_TO_ADDR
// if not tmp then
63653: LD_VAR 0 5
63657: NOT
63658: IFFALSE 63662
// continue ;
63660: GO 63503
// for j in tmp do
63662: LD_ADDR_VAR 0 3
63666: PUSH
63667: LD_VAR 0 5
63671: PUSH
63672: FOR_IN
63673: IFFALSE 63867
// begin if mc_need_heal [ i ] then
63675: LD_EXP 61
63679: PUSH
63680: LD_VAR 0 2
63684: ARRAY
63685: IFFALSE 63733
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63687: LD_VAR 0 3
63691: PUSH
63692: LD_EXP 61
63696: PUSH
63697: LD_VAR 0 2
63701: ARRAY
63702: PUSH
63703: LD_INT 1
63705: ARRAY
63706: IN
63707: PUSH
63708: LD_VAR 0 3
63712: PUSH
63713: LD_EXP 61
63717: PUSH
63718: LD_VAR 0 2
63722: ARRAY
63723: PUSH
63724: LD_INT 2
63726: ARRAY
63727: IN
63728: OR
63729: IFFALSE 63733
// continue ;
63731: GO 63672
// if IsInUnit ( j ) then
63733: LD_VAR 0 3
63737: PPUSH
63738: CALL_OW 310
63742: IFFALSE 63753
// ComExitBuilding ( j ) ;
63744: LD_VAR 0 3
63748: PPUSH
63749: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63753: LD_VAR 0 3
63757: PUSH
63758: LD_EXP 60
63762: PUSH
63763: LD_VAR 0 2
63767: ARRAY
63768: IN
63769: NOT
63770: IFFALSE 63828
// begin SetTag ( j , 101 ) ;
63772: LD_VAR 0 3
63776: PPUSH
63777: LD_INT 101
63779: PPUSH
63780: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63784: LD_ADDR_EXP 60
63788: PUSH
63789: LD_EXP 60
63793: PPUSH
63794: LD_VAR 0 2
63798: PUSH
63799: LD_EXP 60
63803: PUSH
63804: LD_VAR 0 2
63808: ARRAY
63809: PUSH
63810: LD_INT 1
63812: PLUS
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PPUSH
63818: LD_VAR 0 3
63822: PPUSH
63823: CALL 20270 0 3
63827: ST_TO_ADDR
// end ; wait ( 1 ) ;
63828: LD_INT 1
63830: PPUSH
63831: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
63835: LD_VAR 0 3
63839: PPUSH
63840: LD_EXP 59
63844: PUSH
63845: LD_VAR 0 2
63849: ARRAY
63850: PPUSH
63851: LD_VAR 0 3
63855: PPUSH
63856: CALL_OW 74
63860: PPUSH
63861: CALL_OW 130
// end ;
63865: GO 63672
63867: POP
63868: POP
// end ;
63869: GO 63503
63871: POP
63872: POP
// end ;
63873: LD_VAR 0 1
63877: RET
// export function MC_Heal ; var i , j , tmp ; begin
63878: LD_INT 0
63880: PPUSH
63881: PPUSH
63882: PPUSH
63883: PPUSH
// if not mc_bases then
63884: LD_EXP 58
63888: NOT
63889: IFFALSE 63893
// exit ;
63891: GO 64295
// for i = 1 to mc_bases do
63893: LD_ADDR_VAR 0 2
63897: PUSH
63898: DOUBLE
63899: LD_INT 1
63901: DEC
63902: ST_TO_ADDR
63903: LD_EXP 58
63907: PUSH
63908: FOR_TO
63909: IFFALSE 64293
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63911: LD_EXP 61
63915: PUSH
63916: LD_VAR 0 2
63920: ARRAY
63921: PUSH
63922: LD_INT 1
63924: ARRAY
63925: NOT
63926: PUSH
63927: LD_EXP 61
63931: PUSH
63932: LD_VAR 0 2
63936: ARRAY
63937: PUSH
63938: LD_INT 2
63940: ARRAY
63941: NOT
63942: AND
63943: IFFALSE 63981
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63945: LD_ADDR_EXP 62
63949: PUSH
63950: LD_EXP 62
63954: PPUSH
63955: LD_VAR 0 2
63959: PPUSH
63960: EMPTY
63961: PPUSH
63962: CALL_OW 1
63966: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63967: LD_VAR 0 2
63971: PPUSH
63972: LD_INT 102
63974: PPUSH
63975: CALL 58916 0 2
// continue ;
63979: GO 63908
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63981: LD_ADDR_VAR 0 4
63985: PUSH
63986: LD_EXP 58
63990: PUSH
63991: LD_VAR 0 2
63995: ARRAY
63996: PPUSH
63997: LD_INT 25
63999: PUSH
64000: LD_INT 4
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PPUSH
64007: CALL_OW 72
64011: ST_TO_ADDR
// if not tmp then
64012: LD_VAR 0 4
64016: NOT
64017: IFFALSE 64021
// continue ;
64019: GO 63908
// if mc_taming [ i ] then
64021: LD_EXP 89
64025: PUSH
64026: LD_VAR 0 2
64030: ARRAY
64031: IFFALSE 64055
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64033: LD_ADDR_EXP 89
64037: PUSH
64038: LD_EXP 89
64042: PPUSH
64043: LD_VAR 0 2
64047: PPUSH
64048: EMPTY
64049: PPUSH
64050: CALL_OW 1
64054: ST_TO_ADDR
// for j in tmp do
64055: LD_ADDR_VAR 0 3
64059: PUSH
64060: LD_VAR 0 4
64064: PUSH
64065: FOR_IN
64066: IFFALSE 64289
// begin if IsInUnit ( j ) then
64068: LD_VAR 0 3
64072: PPUSH
64073: CALL_OW 310
64077: IFFALSE 64088
// ComExitBuilding ( j ) ;
64079: LD_VAR 0 3
64083: PPUSH
64084: CALL_OW 122
// if not j in mc_healers [ i ] then
64088: LD_VAR 0 3
64092: PUSH
64093: LD_EXP 62
64097: PUSH
64098: LD_VAR 0 2
64102: ARRAY
64103: IN
64104: NOT
64105: IFFALSE 64151
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64107: LD_ADDR_EXP 62
64111: PUSH
64112: LD_EXP 62
64116: PPUSH
64117: LD_VAR 0 2
64121: PUSH
64122: LD_EXP 62
64126: PUSH
64127: LD_VAR 0 2
64131: ARRAY
64132: PUSH
64133: LD_INT 1
64135: PLUS
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PPUSH
64141: LD_VAR 0 3
64145: PPUSH
64146: CALL 20270 0 3
64150: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64151: LD_VAR 0 3
64155: PPUSH
64156: CALL_OW 110
64160: PUSH
64161: LD_INT 102
64163: NONEQUAL
64164: IFFALSE 64178
// SetTag ( j , 102 ) ;
64166: LD_VAR 0 3
64170: PPUSH
64171: LD_INT 102
64173: PPUSH
64174: CALL_OW 109
// Wait ( 3 ) ;
64178: LD_INT 3
64180: PPUSH
64181: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64185: LD_EXP 61
64189: PUSH
64190: LD_VAR 0 2
64194: ARRAY
64195: PUSH
64196: LD_INT 1
64198: ARRAY
64199: IFFALSE 64231
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64201: LD_VAR 0 3
64205: PPUSH
64206: LD_EXP 61
64210: PUSH
64211: LD_VAR 0 2
64215: ARRAY
64216: PUSH
64217: LD_INT 1
64219: ARRAY
64220: PUSH
64221: LD_INT 1
64223: ARRAY
64224: PPUSH
64225: CALL_OW 128
64229: GO 64287
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64231: LD_VAR 0 3
64235: PPUSH
64236: CALL_OW 314
64240: NOT
64241: PUSH
64242: LD_EXP 61
64246: PUSH
64247: LD_VAR 0 2
64251: ARRAY
64252: PUSH
64253: LD_INT 2
64255: ARRAY
64256: AND
64257: IFFALSE 64287
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64259: LD_VAR 0 3
64263: PPUSH
64264: LD_EXP 61
64268: PUSH
64269: LD_VAR 0 2
64273: ARRAY
64274: PUSH
64275: LD_INT 2
64277: ARRAY
64278: PUSH
64279: LD_INT 1
64281: ARRAY
64282: PPUSH
64283: CALL_OW 128
// end ;
64287: GO 64065
64289: POP
64290: POP
// end ;
64291: GO 63908
64293: POP
64294: POP
// end ;
64295: LD_VAR 0 1
64299: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64300: LD_INT 0
64302: PPUSH
64303: PPUSH
64304: PPUSH
64305: PPUSH
64306: PPUSH
// if not mc_bases then
64307: LD_EXP 58
64311: NOT
64312: IFFALSE 64316
// exit ;
64314: GO 65459
// for i = 1 to mc_bases do
64316: LD_ADDR_VAR 0 2
64320: PUSH
64321: DOUBLE
64322: LD_INT 1
64324: DEC
64325: ST_TO_ADDR
64326: LD_EXP 58
64330: PUSH
64331: FOR_TO
64332: IFFALSE 65457
// begin if mc_scan [ i ] then
64334: LD_EXP 81
64338: PUSH
64339: LD_VAR 0 2
64343: ARRAY
64344: IFFALSE 64348
// continue ;
64346: GO 64331
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64348: LD_EXP 63
64352: PUSH
64353: LD_VAR 0 2
64357: ARRAY
64358: NOT
64359: PUSH
64360: LD_EXP 65
64364: PUSH
64365: LD_VAR 0 2
64369: ARRAY
64370: NOT
64371: AND
64372: PUSH
64373: LD_EXP 64
64377: PUSH
64378: LD_VAR 0 2
64382: ARRAY
64383: AND
64384: IFFALSE 64422
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64386: LD_ADDR_EXP 64
64390: PUSH
64391: LD_EXP 64
64395: PPUSH
64396: LD_VAR 0 2
64400: PPUSH
64401: EMPTY
64402: PPUSH
64403: CALL_OW 1
64407: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64408: LD_VAR 0 2
64412: PPUSH
64413: LD_INT 103
64415: PPUSH
64416: CALL 58916 0 2
// continue ;
64420: GO 64331
// end ; if mc_construct_list [ i ] then
64422: LD_EXP 65
64426: PUSH
64427: LD_VAR 0 2
64431: ARRAY
64432: IFFALSE 64652
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64434: LD_ADDR_VAR 0 4
64438: PUSH
64439: LD_EXP 58
64443: PUSH
64444: LD_VAR 0 2
64448: ARRAY
64449: PPUSH
64450: LD_INT 25
64452: PUSH
64453: LD_INT 2
64455: PUSH
64456: EMPTY
64457: LIST
64458: LIST
64459: PPUSH
64460: CALL_OW 72
64464: PUSH
64465: LD_EXP 60
64469: PUSH
64470: LD_VAR 0 2
64474: ARRAY
64475: DIFF
64476: ST_TO_ADDR
// if not tmp then
64477: LD_VAR 0 4
64481: NOT
64482: IFFALSE 64486
// continue ;
64484: GO 64331
// for j in tmp do
64486: LD_ADDR_VAR 0 3
64490: PUSH
64491: LD_VAR 0 4
64495: PUSH
64496: FOR_IN
64497: IFFALSE 64648
// begin if not mc_builders [ i ] then
64499: LD_EXP 64
64503: PUSH
64504: LD_VAR 0 2
64508: ARRAY
64509: NOT
64510: IFFALSE 64568
// begin SetTag ( j , 103 ) ;
64512: LD_VAR 0 3
64516: PPUSH
64517: LD_INT 103
64519: PPUSH
64520: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64524: LD_ADDR_EXP 64
64528: PUSH
64529: LD_EXP 64
64533: PPUSH
64534: LD_VAR 0 2
64538: PUSH
64539: LD_EXP 64
64543: PUSH
64544: LD_VAR 0 2
64548: ARRAY
64549: PUSH
64550: LD_INT 1
64552: PLUS
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PPUSH
64558: LD_VAR 0 3
64562: PPUSH
64563: CALL 20270 0 3
64567: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64568: LD_VAR 0 3
64572: PPUSH
64573: CALL_OW 310
64577: IFFALSE 64588
// ComExitBuilding ( j ) ;
64579: LD_VAR 0 3
64583: PPUSH
64584: CALL_OW 122
// wait ( 3 ) ;
64588: LD_INT 3
64590: PPUSH
64591: CALL_OW 67
// if not mc_construct_list [ i ] then
64595: LD_EXP 65
64599: PUSH
64600: LD_VAR 0 2
64604: ARRAY
64605: NOT
64606: IFFALSE 64610
// break ;
64608: GO 64648
// if not HasTask ( j ) then
64610: LD_VAR 0 3
64614: PPUSH
64615: CALL_OW 314
64619: NOT
64620: IFFALSE 64646
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64622: LD_VAR 0 3
64626: PPUSH
64627: LD_EXP 65
64631: PUSH
64632: LD_VAR 0 2
64636: ARRAY
64637: PUSH
64638: LD_INT 1
64640: ARRAY
64641: PPUSH
64642: CALL 23121 0 2
// end ;
64646: GO 64496
64648: POP
64649: POP
// end else
64650: GO 65455
// if mc_build_list [ i ] then
64652: LD_EXP 63
64656: PUSH
64657: LD_VAR 0 2
64661: ARRAY
64662: IFFALSE 65455
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64664: LD_ADDR_VAR 0 5
64668: PUSH
64669: LD_EXP 58
64673: PUSH
64674: LD_VAR 0 2
64678: ARRAY
64679: PPUSH
64680: LD_INT 2
64682: PUSH
64683: LD_INT 30
64685: PUSH
64686: LD_INT 0
64688: PUSH
64689: EMPTY
64690: LIST
64691: LIST
64692: PUSH
64693: LD_INT 30
64695: PUSH
64696: LD_INT 1
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: EMPTY
64704: LIST
64705: LIST
64706: LIST
64707: PPUSH
64708: CALL_OW 72
64712: ST_TO_ADDR
// if depot then
64713: LD_VAR 0 5
64717: IFFALSE 64735
// depot := depot [ 1 ] else
64719: LD_ADDR_VAR 0 5
64723: PUSH
64724: LD_VAR 0 5
64728: PUSH
64729: LD_INT 1
64731: ARRAY
64732: ST_TO_ADDR
64733: GO 64743
// depot := 0 ;
64735: LD_ADDR_VAR 0 5
64739: PUSH
64740: LD_INT 0
64742: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64743: LD_EXP 63
64747: PUSH
64748: LD_VAR 0 2
64752: ARRAY
64753: PUSH
64754: LD_INT 1
64756: ARRAY
64757: PUSH
64758: LD_INT 1
64760: ARRAY
64761: PPUSH
64762: CALL 22951 0 1
64766: PUSH
64767: LD_EXP 58
64771: PUSH
64772: LD_VAR 0 2
64776: ARRAY
64777: PPUSH
64778: LD_INT 2
64780: PUSH
64781: LD_INT 30
64783: PUSH
64784: LD_INT 2
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: LD_INT 30
64793: PUSH
64794: LD_INT 3
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: EMPTY
64802: LIST
64803: LIST
64804: LIST
64805: PPUSH
64806: CALL_OW 72
64810: NOT
64811: AND
64812: IFFALSE 64917
// begin for j = 1 to mc_build_list [ i ] do
64814: LD_ADDR_VAR 0 3
64818: PUSH
64819: DOUBLE
64820: LD_INT 1
64822: DEC
64823: ST_TO_ADDR
64824: LD_EXP 63
64828: PUSH
64829: LD_VAR 0 2
64833: ARRAY
64834: PUSH
64835: FOR_TO
64836: IFFALSE 64915
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64838: LD_EXP 63
64842: PUSH
64843: LD_VAR 0 2
64847: ARRAY
64848: PUSH
64849: LD_VAR 0 3
64853: ARRAY
64854: PUSH
64855: LD_INT 1
64857: ARRAY
64858: PUSH
64859: LD_INT 2
64861: EQUAL
64862: IFFALSE 64913
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64864: LD_ADDR_EXP 63
64868: PUSH
64869: LD_EXP 63
64873: PPUSH
64874: LD_VAR 0 2
64878: PPUSH
64879: LD_EXP 63
64883: PUSH
64884: LD_VAR 0 2
64888: ARRAY
64889: PPUSH
64890: LD_VAR 0 3
64894: PPUSH
64895: LD_INT 1
64897: PPUSH
64898: LD_INT 0
64900: PPUSH
64901: CALL 19688 0 4
64905: PPUSH
64906: CALL_OW 1
64910: ST_TO_ADDR
// break ;
64911: GO 64915
// end ;
64913: GO 64835
64915: POP
64916: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64917: LD_EXP 63
64921: PUSH
64922: LD_VAR 0 2
64926: ARRAY
64927: PUSH
64928: LD_INT 1
64930: ARRAY
64931: PUSH
64932: LD_INT 1
64934: ARRAY
64935: PUSH
64936: LD_INT 0
64938: EQUAL
64939: PUSH
64940: LD_VAR 0 5
64944: PUSH
64945: LD_VAR 0 5
64949: PPUSH
64950: LD_EXP 63
64954: PUSH
64955: LD_VAR 0 2
64959: ARRAY
64960: PUSH
64961: LD_INT 1
64963: ARRAY
64964: PUSH
64965: LD_INT 1
64967: ARRAY
64968: PPUSH
64969: LD_EXP 63
64973: PUSH
64974: LD_VAR 0 2
64978: ARRAY
64979: PUSH
64980: LD_INT 1
64982: ARRAY
64983: PUSH
64984: LD_INT 2
64986: ARRAY
64987: PPUSH
64988: LD_EXP 63
64992: PUSH
64993: LD_VAR 0 2
64997: ARRAY
64998: PUSH
64999: LD_INT 1
65001: ARRAY
65002: PUSH
65003: LD_INT 3
65005: ARRAY
65006: PPUSH
65007: LD_EXP 63
65011: PUSH
65012: LD_VAR 0 2
65016: ARRAY
65017: PUSH
65018: LD_INT 1
65020: ARRAY
65021: PUSH
65022: LD_INT 4
65024: ARRAY
65025: PPUSH
65026: CALL 27667 0 5
65030: AND
65031: OR
65032: IFFALSE 65313
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65034: LD_ADDR_VAR 0 4
65038: PUSH
65039: LD_EXP 58
65043: PUSH
65044: LD_VAR 0 2
65048: ARRAY
65049: PPUSH
65050: LD_INT 25
65052: PUSH
65053: LD_INT 2
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PPUSH
65060: CALL_OW 72
65064: PUSH
65065: LD_EXP 60
65069: PUSH
65070: LD_VAR 0 2
65074: ARRAY
65075: DIFF
65076: ST_TO_ADDR
// if not tmp then
65077: LD_VAR 0 4
65081: NOT
65082: IFFALSE 65086
// continue ;
65084: GO 64331
// for j in tmp do
65086: LD_ADDR_VAR 0 3
65090: PUSH
65091: LD_VAR 0 4
65095: PUSH
65096: FOR_IN
65097: IFFALSE 65309
// begin if not mc_builders [ i ] then
65099: LD_EXP 64
65103: PUSH
65104: LD_VAR 0 2
65108: ARRAY
65109: NOT
65110: IFFALSE 65168
// begin SetTag ( j , 103 ) ;
65112: LD_VAR 0 3
65116: PPUSH
65117: LD_INT 103
65119: PPUSH
65120: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65124: LD_ADDR_EXP 64
65128: PUSH
65129: LD_EXP 64
65133: PPUSH
65134: LD_VAR 0 2
65138: PUSH
65139: LD_EXP 64
65143: PUSH
65144: LD_VAR 0 2
65148: ARRAY
65149: PUSH
65150: LD_INT 1
65152: PLUS
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PPUSH
65158: LD_VAR 0 3
65162: PPUSH
65163: CALL 20270 0 3
65167: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65168: LD_VAR 0 3
65172: PPUSH
65173: CALL_OW 310
65177: IFFALSE 65188
// ComExitBuilding ( j ) ;
65179: LD_VAR 0 3
65183: PPUSH
65184: CALL_OW 122
// wait ( 3 ) ;
65188: LD_INT 3
65190: PPUSH
65191: CALL_OW 67
// if not mc_build_list [ i ] then
65195: LD_EXP 63
65199: PUSH
65200: LD_VAR 0 2
65204: ARRAY
65205: NOT
65206: IFFALSE 65210
// break ;
65208: GO 65309
// if not HasTask ( j ) then
65210: LD_VAR 0 3
65214: PPUSH
65215: CALL_OW 314
65219: NOT
65220: IFFALSE 65307
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65222: LD_VAR 0 3
65226: PPUSH
65227: LD_EXP 63
65231: PUSH
65232: LD_VAR 0 2
65236: ARRAY
65237: PUSH
65238: LD_INT 1
65240: ARRAY
65241: PUSH
65242: LD_INT 1
65244: ARRAY
65245: PPUSH
65246: LD_EXP 63
65250: PUSH
65251: LD_VAR 0 2
65255: ARRAY
65256: PUSH
65257: LD_INT 1
65259: ARRAY
65260: PUSH
65261: LD_INT 2
65263: ARRAY
65264: PPUSH
65265: LD_EXP 63
65269: PUSH
65270: LD_VAR 0 2
65274: ARRAY
65275: PUSH
65276: LD_INT 1
65278: ARRAY
65279: PUSH
65280: LD_INT 3
65282: ARRAY
65283: PPUSH
65284: LD_EXP 63
65288: PUSH
65289: LD_VAR 0 2
65293: ARRAY
65294: PUSH
65295: LD_INT 1
65297: ARRAY
65298: PUSH
65299: LD_INT 4
65301: ARRAY
65302: PPUSH
65303: CALL_OW 145
// end ;
65307: GO 65096
65309: POP
65310: POP
// end else
65311: GO 65455
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65313: LD_EXP 58
65317: PUSH
65318: LD_VAR 0 2
65322: ARRAY
65323: PPUSH
65324: LD_EXP 63
65328: PUSH
65329: LD_VAR 0 2
65333: ARRAY
65334: PUSH
65335: LD_INT 1
65337: ARRAY
65338: PUSH
65339: LD_INT 1
65341: ARRAY
65342: PPUSH
65343: LD_EXP 63
65347: PUSH
65348: LD_VAR 0 2
65352: ARRAY
65353: PUSH
65354: LD_INT 1
65356: ARRAY
65357: PUSH
65358: LD_INT 2
65360: ARRAY
65361: PPUSH
65362: LD_EXP 63
65366: PUSH
65367: LD_VAR 0 2
65371: ARRAY
65372: PUSH
65373: LD_INT 1
65375: ARRAY
65376: PUSH
65377: LD_INT 3
65379: ARRAY
65380: PPUSH
65381: LD_EXP 63
65385: PUSH
65386: LD_VAR 0 2
65390: ARRAY
65391: PUSH
65392: LD_INT 1
65394: ARRAY
65395: PUSH
65396: LD_INT 4
65398: ARRAY
65399: PPUSH
65400: CALL 27021 0 5
65404: NOT
65405: IFFALSE 65455
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65407: LD_ADDR_EXP 63
65411: PUSH
65412: LD_EXP 63
65416: PPUSH
65417: LD_VAR 0 2
65421: PPUSH
65422: LD_EXP 63
65426: PUSH
65427: LD_VAR 0 2
65431: ARRAY
65432: PPUSH
65433: LD_INT 1
65435: PPUSH
65436: LD_INT 1
65438: NEG
65439: PPUSH
65440: LD_INT 0
65442: PPUSH
65443: CALL 19688 0 4
65447: PPUSH
65448: CALL_OW 1
65452: ST_TO_ADDR
// continue ;
65453: GO 64331
// end ; end ; end ;
65455: GO 64331
65457: POP
65458: POP
// end ;
65459: LD_VAR 0 1
65463: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65464: LD_INT 0
65466: PPUSH
65467: PPUSH
65468: PPUSH
65469: PPUSH
65470: PPUSH
65471: PPUSH
// if not mc_bases then
65472: LD_EXP 58
65476: NOT
65477: IFFALSE 65481
// exit ;
65479: GO 65908
// for i = 1 to mc_bases do
65481: LD_ADDR_VAR 0 2
65485: PUSH
65486: DOUBLE
65487: LD_INT 1
65489: DEC
65490: ST_TO_ADDR
65491: LD_EXP 58
65495: PUSH
65496: FOR_TO
65497: IFFALSE 65906
// begin tmp := mc_build_upgrade [ i ] ;
65499: LD_ADDR_VAR 0 4
65503: PUSH
65504: LD_EXP 90
65508: PUSH
65509: LD_VAR 0 2
65513: ARRAY
65514: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65515: LD_ADDR_VAR 0 6
65519: PUSH
65520: LD_EXP 91
65524: PUSH
65525: LD_VAR 0 2
65529: ARRAY
65530: PPUSH
65531: LD_INT 2
65533: PUSH
65534: LD_INT 30
65536: PUSH
65537: LD_INT 6
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 30
65546: PUSH
65547: LD_INT 7
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: LIST
65558: PPUSH
65559: CALL_OW 72
65563: ST_TO_ADDR
// if not tmp and not lab then
65564: LD_VAR 0 4
65568: NOT
65569: PUSH
65570: LD_VAR 0 6
65574: NOT
65575: AND
65576: IFFALSE 65580
// continue ;
65578: GO 65496
// if tmp then
65580: LD_VAR 0 4
65584: IFFALSE 65704
// for j in tmp do
65586: LD_ADDR_VAR 0 3
65590: PUSH
65591: LD_VAR 0 4
65595: PUSH
65596: FOR_IN
65597: IFFALSE 65702
// begin if UpgradeCost ( j ) then
65599: LD_VAR 0 3
65603: PPUSH
65604: CALL 26681 0 1
65608: IFFALSE 65700
// begin ComUpgrade ( j ) ;
65610: LD_VAR 0 3
65614: PPUSH
65615: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65619: LD_ADDR_EXP 90
65623: PUSH
65624: LD_EXP 90
65628: PPUSH
65629: LD_VAR 0 2
65633: PPUSH
65634: LD_EXP 90
65638: PUSH
65639: LD_VAR 0 2
65643: ARRAY
65644: PUSH
65645: LD_VAR 0 3
65649: DIFF
65650: PPUSH
65651: CALL_OW 1
65655: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65656: LD_ADDR_EXP 65
65660: PUSH
65661: LD_EXP 65
65665: PPUSH
65666: LD_VAR 0 2
65670: PUSH
65671: LD_EXP 65
65675: PUSH
65676: LD_VAR 0 2
65680: ARRAY
65681: PUSH
65682: LD_INT 1
65684: PLUS
65685: PUSH
65686: EMPTY
65687: LIST
65688: LIST
65689: PPUSH
65690: LD_VAR 0 3
65694: PPUSH
65695: CALL 20270 0 3
65699: ST_TO_ADDR
// end ; end ;
65700: GO 65596
65702: POP
65703: POP
// if not lab or not mc_lab_upgrade [ i ] then
65704: LD_VAR 0 6
65708: NOT
65709: PUSH
65710: LD_EXP 92
65714: PUSH
65715: LD_VAR 0 2
65719: ARRAY
65720: NOT
65721: OR
65722: IFFALSE 65726
// continue ;
65724: GO 65496
// for j in lab do
65726: LD_ADDR_VAR 0 3
65730: PUSH
65731: LD_VAR 0 6
65735: PUSH
65736: FOR_IN
65737: IFFALSE 65902
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65739: LD_VAR 0 3
65743: PPUSH
65744: CALL_OW 266
65748: PUSH
65749: LD_INT 6
65751: PUSH
65752: LD_INT 7
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: IN
65759: PUSH
65760: LD_VAR 0 3
65764: PPUSH
65765: CALL_OW 461
65769: PUSH
65770: LD_INT 1
65772: NONEQUAL
65773: AND
65774: IFFALSE 65900
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65776: LD_VAR 0 3
65780: PPUSH
65781: LD_EXP 92
65785: PUSH
65786: LD_VAR 0 2
65790: ARRAY
65791: PUSH
65792: LD_INT 1
65794: ARRAY
65795: PPUSH
65796: CALL 26886 0 2
65800: IFFALSE 65900
// begin ComCancel ( j ) ;
65802: LD_VAR 0 3
65806: PPUSH
65807: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65811: LD_VAR 0 3
65815: PPUSH
65816: LD_EXP 92
65820: PUSH
65821: LD_VAR 0 2
65825: ARRAY
65826: PUSH
65827: LD_INT 1
65829: ARRAY
65830: PPUSH
65831: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65835: LD_VAR 0 3
65839: PUSH
65840: LD_EXP 65
65844: PUSH
65845: LD_VAR 0 2
65849: ARRAY
65850: IN
65851: NOT
65852: IFFALSE 65898
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65854: LD_ADDR_EXP 65
65858: PUSH
65859: LD_EXP 65
65863: PPUSH
65864: LD_VAR 0 2
65868: PUSH
65869: LD_EXP 65
65873: PUSH
65874: LD_VAR 0 2
65878: ARRAY
65879: PUSH
65880: LD_INT 1
65882: PLUS
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PPUSH
65888: LD_VAR 0 3
65892: PPUSH
65893: CALL 20270 0 3
65897: ST_TO_ADDR
// break ;
65898: GO 65902
// end ; end ; end ;
65900: GO 65736
65902: POP
65903: POP
// end ;
65904: GO 65496
65906: POP
65907: POP
// end ;
65908: LD_VAR 0 1
65912: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65913: LD_INT 0
65915: PPUSH
65916: PPUSH
65917: PPUSH
65918: PPUSH
65919: PPUSH
65920: PPUSH
65921: PPUSH
65922: PPUSH
65923: PPUSH
// if not mc_bases then
65924: LD_EXP 58
65928: NOT
65929: IFFALSE 65933
// exit ;
65931: GO 66338
// for i = 1 to mc_bases do
65933: LD_ADDR_VAR 0 2
65937: PUSH
65938: DOUBLE
65939: LD_INT 1
65941: DEC
65942: ST_TO_ADDR
65943: LD_EXP 58
65947: PUSH
65948: FOR_TO
65949: IFFALSE 66336
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65951: LD_EXP 66
65955: PUSH
65956: LD_VAR 0 2
65960: ARRAY
65961: NOT
65962: PUSH
65963: LD_EXP 58
65967: PUSH
65968: LD_VAR 0 2
65972: ARRAY
65973: PPUSH
65974: LD_INT 30
65976: PUSH
65977: LD_INT 3
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PPUSH
65984: CALL_OW 72
65988: NOT
65989: OR
65990: IFFALSE 65994
// continue ;
65992: GO 65948
// busy := false ;
65994: LD_ADDR_VAR 0 8
65998: PUSH
65999: LD_INT 0
66001: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66002: LD_ADDR_VAR 0 4
66006: PUSH
66007: LD_EXP 58
66011: PUSH
66012: LD_VAR 0 2
66016: ARRAY
66017: PPUSH
66018: LD_INT 30
66020: PUSH
66021: LD_INT 3
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PPUSH
66028: CALL_OW 72
66032: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66033: LD_ADDR_VAR 0 6
66037: PUSH
66038: LD_EXP 66
66042: PUSH
66043: LD_VAR 0 2
66047: ARRAY
66048: PPUSH
66049: LD_INT 2
66051: PUSH
66052: LD_INT 30
66054: PUSH
66055: LD_INT 32
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PUSH
66062: LD_INT 30
66064: PUSH
66065: LD_INT 33
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: LIST
66076: PPUSH
66077: CALL_OW 72
66081: ST_TO_ADDR
// if not t then
66082: LD_VAR 0 6
66086: NOT
66087: IFFALSE 66091
// continue ;
66089: GO 65948
// for j in tmp do
66091: LD_ADDR_VAR 0 3
66095: PUSH
66096: LD_VAR 0 4
66100: PUSH
66101: FOR_IN
66102: IFFALSE 66132
// if not BuildingStatus ( j ) = bs_idle then
66104: LD_VAR 0 3
66108: PPUSH
66109: CALL_OW 461
66113: PUSH
66114: LD_INT 2
66116: EQUAL
66117: NOT
66118: IFFALSE 66130
// begin busy := true ;
66120: LD_ADDR_VAR 0 8
66124: PUSH
66125: LD_INT 1
66127: ST_TO_ADDR
// break ;
66128: GO 66132
// end ;
66130: GO 66101
66132: POP
66133: POP
// if busy then
66134: LD_VAR 0 8
66138: IFFALSE 66142
// continue ;
66140: GO 65948
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66142: LD_ADDR_VAR 0 7
66146: PUSH
66147: LD_VAR 0 6
66151: PPUSH
66152: LD_INT 35
66154: PUSH
66155: LD_INT 0
66157: PUSH
66158: EMPTY
66159: LIST
66160: LIST
66161: PPUSH
66162: CALL_OW 72
66166: ST_TO_ADDR
// if tw then
66167: LD_VAR 0 7
66171: IFFALSE 66248
// begin tw := tw [ 1 ] ;
66173: LD_ADDR_VAR 0 7
66177: PUSH
66178: LD_VAR 0 7
66182: PUSH
66183: LD_INT 1
66185: ARRAY
66186: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66187: LD_ADDR_VAR 0 9
66191: PUSH
66192: LD_VAR 0 7
66196: PPUSH
66197: LD_EXP 83
66201: PUSH
66202: LD_VAR 0 2
66206: ARRAY
66207: PPUSH
66208: CALL 25240 0 2
66212: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66213: LD_EXP 97
66217: PUSH
66218: LD_VAR 0 2
66222: ARRAY
66223: IFFALSE 66246
// if not weapon in mc_allowed_tower_weapons [ i ] then
66225: LD_VAR 0 9
66229: PUSH
66230: LD_EXP 97
66234: PUSH
66235: LD_VAR 0 2
66239: ARRAY
66240: IN
66241: NOT
66242: IFFALSE 66246
// continue ;
66244: GO 65948
// end else
66246: GO 66311
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66248: LD_ADDR_VAR 0 5
66252: PUSH
66253: LD_EXP 66
66257: PUSH
66258: LD_VAR 0 2
66262: ARRAY
66263: PPUSH
66264: LD_VAR 0 4
66268: PPUSH
66269: CALL 55379 0 2
66273: ST_TO_ADDR
// if not tmp2 then
66274: LD_VAR 0 5
66278: NOT
66279: IFFALSE 66283
// continue ;
66281: GO 65948
// tw := tmp2 [ 1 ] ;
66283: LD_ADDR_VAR 0 7
66287: PUSH
66288: LD_VAR 0 5
66292: PUSH
66293: LD_INT 1
66295: ARRAY
66296: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66297: LD_ADDR_VAR 0 9
66301: PUSH
66302: LD_VAR 0 5
66306: PUSH
66307: LD_INT 2
66309: ARRAY
66310: ST_TO_ADDR
// end ; if not weapon then
66311: LD_VAR 0 9
66315: NOT
66316: IFFALSE 66320
// continue ;
66318: GO 65948
// ComPlaceWeapon ( tw , weapon ) ;
66320: LD_VAR 0 7
66324: PPUSH
66325: LD_VAR 0 9
66329: PPUSH
66330: CALL_OW 148
// end ;
66334: GO 65948
66336: POP
66337: POP
// end ;
66338: LD_VAR 0 1
66342: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
66343: LD_INT 0
66345: PPUSH
66346: PPUSH
66347: PPUSH
66348: PPUSH
66349: PPUSH
66350: PPUSH
// if not mc_bases then
66351: LD_EXP 58
66355: NOT
66356: IFFALSE 66360
// exit ;
66358: GO 67372
// for i = 1 to mc_bases do
66360: LD_ADDR_VAR 0 2
66364: PUSH
66365: DOUBLE
66366: LD_INT 1
66368: DEC
66369: ST_TO_ADDR
66370: LD_EXP 58
66374: PUSH
66375: FOR_TO
66376: IFFALSE 67370
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
66378: LD_EXP 71
66382: PUSH
66383: LD_VAR 0 2
66387: ARRAY
66388: NOT
66389: PUSH
66390: LD_EXP 71
66394: PUSH
66395: LD_VAR 0 2
66399: ARRAY
66400: PUSH
66401: LD_EXP 72
66405: PUSH
66406: LD_VAR 0 2
66410: ARRAY
66411: EQUAL
66412: OR
66413: IFFALSE 66417
// continue ;
66415: GO 66375
// if mc_miners [ i ] then
66417: LD_EXP 72
66421: PUSH
66422: LD_VAR 0 2
66426: ARRAY
66427: IFFALSE 67057
// begin k := 1 ;
66429: LD_ADDR_VAR 0 4
66433: PUSH
66434: LD_INT 1
66436: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
66437: LD_ADDR_VAR 0 3
66441: PUSH
66442: DOUBLE
66443: LD_EXP 72
66447: PUSH
66448: LD_VAR 0 2
66452: ARRAY
66453: INC
66454: ST_TO_ADDR
66455: LD_INT 1
66457: PUSH
66458: FOR_DOWNTO
66459: IFFALSE 67055
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66461: LD_EXP 72
66465: PUSH
66466: LD_VAR 0 2
66470: ARRAY
66471: PUSH
66472: LD_VAR 0 3
66476: ARRAY
66477: PPUSH
66478: CALL_OW 301
66482: PUSH
66483: LD_EXP 72
66487: PUSH
66488: LD_VAR 0 2
66492: ARRAY
66493: PUSH
66494: LD_VAR 0 3
66498: ARRAY
66499: PPUSH
66500: CALL_OW 257
66504: PUSH
66505: LD_INT 1
66507: NONEQUAL
66508: OR
66509: IFFALSE 66572
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66511: LD_ADDR_VAR 0 5
66515: PUSH
66516: LD_EXP 72
66520: PUSH
66521: LD_VAR 0 2
66525: ARRAY
66526: PUSH
66527: LD_EXP 72
66531: PUSH
66532: LD_VAR 0 2
66536: ARRAY
66537: PUSH
66538: LD_VAR 0 3
66542: ARRAY
66543: DIFF
66544: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66545: LD_ADDR_EXP 72
66549: PUSH
66550: LD_EXP 72
66554: PPUSH
66555: LD_VAR 0 2
66559: PPUSH
66560: LD_VAR 0 5
66564: PPUSH
66565: CALL_OW 1
66569: ST_TO_ADDR
// continue ;
66570: GO 66458
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
66572: LD_EXP 72
66576: PUSH
66577: LD_VAR 0 2
66581: ARRAY
66582: PUSH
66583: LD_VAR 0 3
66587: ARRAY
66588: PPUSH
66589: CALL 20206 0 1
66593: PUSH
66594: LD_EXP 72
66598: PUSH
66599: LD_VAR 0 2
66603: ARRAY
66604: PUSH
66605: LD_VAR 0 3
66609: ARRAY
66610: PPUSH
66611: CALL_OW 255
66615: PPUSH
66616: LD_EXP 71
66620: PUSH
66621: LD_VAR 0 2
66625: ARRAY
66626: PUSH
66627: LD_VAR 0 4
66631: ARRAY
66632: PUSH
66633: LD_INT 1
66635: ARRAY
66636: PPUSH
66637: LD_EXP 71
66641: PUSH
66642: LD_VAR 0 2
66646: ARRAY
66647: PUSH
66648: LD_VAR 0 4
66652: ARRAY
66653: PUSH
66654: LD_INT 2
66656: ARRAY
66657: PPUSH
66658: LD_INT 15
66660: PPUSH
66661: CALL 21166 0 4
66665: PUSH
66666: LD_INT 4
66668: ARRAY
66669: PUSH
66670: LD_EXP 72
66674: PUSH
66675: LD_VAR 0 2
66679: ARRAY
66680: PUSH
66681: LD_VAR 0 3
66685: ARRAY
66686: PPUSH
66687: LD_INT 10
66689: PPUSH
66690: CALL 22863 0 2
66694: PUSH
66695: LD_INT 4
66697: ARRAY
66698: OR
66699: AND
66700: IFFALSE 66723
// ComStop ( mc_miners [ i ] [ j ] ) ;
66702: LD_EXP 72
66706: PUSH
66707: LD_VAR 0 2
66711: ARRAY
66712: PUSH
66713: LD_VAR 0 3
66717: ARRAY
66718: PPUSH
66719: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
66723: LD_EXP 72
66727: PUSH
66728: LD_VAR 0 2
66732: ARRAY
66733: PUSH
66734: LD_VAR 0 3
66738: ARRAY
66739: PPUSH
66740: CALL_OW 257
66744: PUSH
66745: LD_INT 1
66747: EQUAL
66748: PUSH
66749: LD_EXP 72
66753: PUSH
66754: LD_VAR 0 2
66758: ARRAY
66759: PUSH
66760: LD_VAR 0 3
66764: ARRAY
66765: PPUSH
66766: CALL_OW 459
66770: NOT
66771: AND
66772: PUSH
66773: LD_EXP 72
66777: PUSH
66778: LD_VAR 0 2
66782: ARRAY
66783: PUSH
66784: LD_VAR 0 3
66788: ARRAY
66789: PPUSH
66790: CALL_OW 255
66794: PPUSH
66795: LD_EXP 71
66799: PUSH
66800: LD_VAR 0 2
66804: ARRAY
66805: PUSH
66806: LD_VAR 0 4
66810: ARRAY
66811: PUSH
66812: LD_INT 1
66814: ARRAY
66815: PPUSH
66816: LD_EXP 71
66820: PUSH
66821: LD_VAR 0 2
66825: ARRAY
66826: PUSH
66827: LD_VAR 0 4
66831: ARRAY
66832: PUSH
66833: LD_INT 2
66835: ARRAY
66836: PPUSH
66837: LD_INT 15
66839: PPUSH
66840: CALL 21166 0 4
66844: PUSH
66845: LD_INT 4
66847: ARRAY
66848: PUSH
66849: LD_INT 0
66851: EQUAL
66852: AND
66853: PUSH
66854: LD_EXP 72
66858: PUSH
66859: LD_VAR 0 2
66863: ARRAY
66864: PUSH
66865: LD_VAR 0 3
66869: ARRAY
66870: PPUSH
66871: CALL_OW 314
66875: NOT
66876: AND
66877: IFFALSE 67053
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66879: LD_EXP 72
66883: PUSH
66884: LD_VAR 0 2
66888: ARRAY
66889: PUSH
66890: LD_VAR 0 3
66894: ARRAY
66895: PPUSH
66896: CALL_OW 310
66900: IFFALSE 66923
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66902: LD_EXP 72
66906: PUSH
66907: LD_VAR 0 2
66911: ARRAY
66912: PUSH
66913: LD_VAR 0 3
66917: ARRAY
66918: PPUSH
66919: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66923: LD_EXP 72
66927: PUSH
66928: LD_VAR 0 2
66932: ARRAY
66933: PUSH
66934: LD_VAR 0 3
66938: ARRAY
66939: PPUSH
66940: CALL_OW 314
66944: NOT
66945: IFFALSE 67013
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
66947: LD_EXP 72
66951: PUSH
66952: LD_VAR 0 2
66956: ARRAY
66957: PUSH
66958: LD_VAR 0 3
66962: ARRAY
66963: PPUSH
66964: LD_EXP 71
66968: PUSH
66969: LD_VAR 0 2
66973: ARRAY
66974: PUSH
66975: LD_VAR 0 4
66979: ARRAY
66980: PUSH
66981: LD_INT 1
66983: ARRAY
66984: PPUSH
66985: LD_EXP 71
66989: PUSH
66990: LD_VAR 0 2
66994: ARRAY
66995: PUSH
66996: LD_VAR 0 4
67000: ARRAY
67001: PUSH
67002: LD_INT 2
67004: ARRAY
67005: PPUSH
67006: LD_INT 0
67008: PPUSH
67009: CALL_OW 193
// k := k + 1 ;
67013: LD_ADDR_VAR 0 4
67017: PUSH
67018: LD_VAR 0 4
67022: PUSH
67023: LD_INT 1
67025: PLUS
67026: ST_TO_ADDR
// if k > mc_mines [ i ] then
67027: LD_VAR 0 4
67031: PUSH
67032: LD_EXP 71
67036: PUSH
67037: LD_VAR 0 2
67041: ARRAY
67042: GREATER
67043: IFFALSE 67053
// k := 1 ;
67045: LD_ADDR_VAR 0 4
67049: PUSH
67050: LD_INT 1
67052: ST_TO_ADDR
// end ; end ;
67053: GO 66458
67055: POP
67056: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67057: LD_ADDR_VAR 0 5
67061: PUSH
67062: LD_EXP 58
67066: PUSH
67067: LD_VAR 0 2
67071: ARRAY
67072: PPUSH
67073: LD_INT 2
67075: PUSH
67076: LD_INT 30
67078: PUSH
67079: LD_INT 4
67081: PUSH
67082: EMPTY
67083: LIST
67084: LIST
67085: PUSH
67086: LD_INT 30
67088: PUSH
67089: LD_INT 5
67091: PUSH
67092: EMPTY
67093: LIST
67094: LIST
67095: PUSH
67096: LD_INT 30
67098: PUSH
67099: LD_INT 32
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: EMPTY
67107: LIST
67108: LIST
67109: LIST
67110: LIST
67111: PPUSH
67112: CALL_OW 72
67116: ST_TO_ADDR
// if not tmp then
67117: LD_VAR 0 5
67121: NOT
67122: IFFALSE 67126
// continue ;
67124: GO 66375
// list := [ ] ;
67126: LD_ADDR_VAR 0 6
67130: PUSH
67131: EMPTY
67132: ST_TO_ADDR
// for j in tmp do
67133: LD_ADDR_VAR 0 3
67137: PUSH
67138: LD_VAR 0 5
67142: PUSH
67143: FOR_IN
67144: IFFALSE 67213
// begin for k in UnitsInside ( j ) do
67146: LD_ADDR_VAR 0 4
67150: PUSH
67151: LD_VAR 0 3
67155: PPUSH
67156: CALL_OW 313
67160: PUSH
67161: FOR_IN
67162: IFFALSE 67209
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67164: LD_VAR 0 4
67168: PPUSH
67169: CALL_OW 257
67173: PUSH
67174: LD_INT 1
67176: EQUAL
67177: PUSH
67178: LD_VAR 0 4
67182: PPUSH
67183: CALL_OW 459
67187: NOT
67188: AND
67189: IFFALSE 67207
// list := list ^ k ;
67191: LD_ADDR_VAR 0 6
67195: PUSH
67196: LD_VAR 0 6
67200: PUSH
67201: LD_VAR 0 4
67205: ADD
67206: ST_TO_ADDR
67207: GO 67161
67209: POP
67210: POP
// end ;
67211: GO 67143
67213: POP
67214: POP
// list := list diff mc_miners [ i ] ;
67215: LD_ADDR_VAR 0 6
67219: PUSH
67220: LD_VAR 0 6
67224: PUSH
67225: LD_EXP 72
67229: PUSH
67230: LD_VAR 0 2
67234: ARRAY
67235: DIFF
67236: ST_TO_ADDR
// if not list then
67237: LD_VAR 0 6
67241: NOT
67242: IFFALSE 67246
// continue ;
67244: GO 66375
// k := mc_mines [ i ] - mc_miners [ i ] ;
67246: LD_ADDR_VAR 0 4
67250: PUSH
67251: LD_EXP 71
67255: PUSH
67256: LD_VAR 0 2
67260: ARRAY
67261: PUSH
67262: LD_EXP 72
67266: PUSH
67267: LD_VAR 0 2
67271: ARRAY
67272: MINUS
67273: ST_TO_ADDR
// if k > list then
67274: LD_VAR 0 4
67278: PUSH
67279: LD_VAR 0 6
67283: GREATER
67284: IFFALSE 67296
// k := list ;
67286: LD_ADDR_VAR 0 4
67290: PUSH
67291: LD_VAR 0 6
67295: ST_TO_ADDR
// for j = 1 to k do
67296: LD_ADDR_VAR 0 3
67300: PUSH
67301: DOUBLE
67302: LD_INT 1
67304: DEC
67305: ST_TO_ADDR
67306: LD_VAR 0 4
67310: PUSH
67311: FOR_TO
67312: IFFALSE 67366
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67314: LD_ADDR_EXP 72
67318: PUSH
67319: LD_EXP 72
67323: PPUSH
67324: LD_VAR 0 2
67328: PUSH
67329: LD_EXP 72
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: PUSH
67340: LD_INT 1
67342: PLUS
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PPUSH
67348: LD_VAR 0 6
67352: PUSH
67353: LD_VAR 0 3
67357: ARRAY
67358: PPUSH
67359: CALL 20270 0 3
67363: ST_TO_ADDR
67364: GO 67311
67366: POP
67367: POP
// end ;
67368: GO 66375
67370: POP
67371: POP
// end ;
67372: LD_VAR 0 1
67376: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67377: LD_INT 0
67379: PPUSH
67380: PPUSH
67381: PPUSH
67382: PPUSH
67383: PPUSH
67384: PPUSH
67385: PPUSH
67386: PPUSH
67387: PPUSH
67388: PPUSH
// if not mc_bases then
67389: LD_EXP 58
67393: NOT
67394: IFFALSE 67398
// exit ;
67396: GO 69129
// for i = 1 to mc_bases do
67398: LD_ADDR_VAR 0 2
67402: PUSH
67403: DOUBLE
67404: LD_INT 1
67406: DEC
67407: ST_TO_ADDR
67408: LD_EXP 58
67412: PUSH
67413: FOR_TO
67414: IFFALSE 69127
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67416: LD_EXP 58
67420: PUSH
67421: LD_VAR 0 2
67425: ARRAY
67426: NOT
67427: PUSH
67428: LD_EXP 65
67432: PUSH
67433: LD_VAR 0 2
67437: ARRAY
67438: OR
67439: IFFALSE 67443
// continue ;
67441: GO 67413
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67443: LD_EXP 74
67447: PUSH
67448: LD_VAR 0 2
67452: ARRAY
67453: NOT
67454: PUSH
67455: LD_EXP 75
67459: PUSH
67460: LD_VAR 0 2
67464: ARRAY
67465: AND
67466: IFFALSE 67504
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67468: LD_ADDR_EXP 75
67472: PUSH
67473: LD_EXP 75
67477: PPUSH
67478: LD_VAR 0 2
67482: PPUSH
67483: EMPTY
67484: PPUSH
67485: CALL_OW 1
67489: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67490: LD_VAR 0 2
67494: PPUSH
67495: LD_INT 107
67497: PPUSH
67498: CALL 58916 0 2
// continue ;
67502: GO 67413
// end ; target := [ ] ;
67504: LD_ADDR_VAR 0 6
67508: PUSH
67509: EMPTY
67510: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67511: LD_ADDR_VAR 0 3
67515: PUSH
67516: DOUBLE
67517: LD_EXP 74
67521: PUSH
67522: LD_VAR 0 2
67526: ARRAY
67527: INC
67528: ST_TO_ADDR
67529: LD_INT 1
67531: PUSH
67532: FOR_DOWNTO
67533: IFFALSE 67793
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67535: LD_EXP 74
67539: PUSH
67540: LD_VAR 0 2
67544: ARRAY
67545: PUSH
67546: LD_VAR 0 3
67550: ARRAY
67551: PUSH
67552: LD_INT 2
67554: ARRAY
67555: PPUSH
67556: LD_EXP 74
67560: PUSH
67561: LD_VAR 0 2
67565: ARRAY
67566: PUSH
67567: LD_VAR 0 3
67571: ARRAY
67572: PUSH
67573: LD_INT 3
67575: ARRAY
67576: PPUSH
67577: CALL_OW 488
67581: PUSH
67582: LD_EXP 74
67586: PUSH
67587: LD_VAR 0 2
67591: ARRAY
67592: PUSH
67593: LD_VAR 0 3
67597: ARRAY
67598: PUSH
67599: LD_INT 2
67601: ARRAY
67602: PPUSH
67603: LD_EXP 74
67607: PUSH
67608: LD_VAR 0 2
67612: ARRAY
67613: PUSH
67614: LD_VAR 0 3
67618: ARRAY
67619: PUSH
67620: LD_INT 3
67622: ARRAY
67623: PPUSH
67624: CALL_OW 284
67628: PUSH
67629: LD_INT 0
67631: EQUAL
67632: AND
67633: IFFALSE 67688
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67635: LD_ADDR_VAR 0 5
67639: PUSH
67640: LD_EXP 74
67644: PUSH
67645: LD_VAR 0 2
67649: ARRAY
67650: PPUSH
67651: LD_VAR 0 3
67655: PPUSH
67656: CALL_OW 3
67660: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67661: LD_ADDR_EXP 74
67665: PUSH
67666: LD_EXP 74
67670: PPUSH
67671: LD_VAR 0 2
67675: PPUSH
67676: LD_VAR 0 5
67680: PPUSH
67681: CALL_OW 1
67685: ST_TO_ADDR
// continue ;
67686: GO 67532
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67688: LD_EXP 58
67692: PUSH
67693: LD_VAR 0 2
67697: ARRAY
67698: PUSH
67699: LD_INT 1
67701: ARRAY
67702: PPUSH
67703: CALL_OW 255
67707: PPUSH
67708: LD_EXP 74
67712: PUSH
67713: LD_VAR 0 2
67717: ARRAY
67718: PUSH
67719: LD_VAR 0 3
67723: ARRAY
67724: PUSH
67725: LD_INT 2
67727: ARRAY
67728: PPUSH
67729: LD_EXP 74
67733: PUSH
67734: LD_VAR 0 2
67738: ARRAY
67739: PUSH
67740: LD_VAR 0 3
67744: ARRAY
67745: PUSH
67746: LD_INT 3
67748: ARRAY
67749: PPUSH
67750: LD_INT 30
67752: PPUSH
67753: CALL 21166 0 4
67757: PUSH
67758: LD_INT 4
67760: ARRAY
67761: PUSH
67762: LD_INT 0
67764: EQUAL
67765: IFFALSE 67791
// begin target := mc_crates [ i ] [ j ] ;
67767: LD_ADDR_VAR 0 6
67771: PUSH
67772: LD_EXP 74
67776: PUSH
67777: LD_VAR 0 2
67781: ARRAY
67782: PUSH
67783: LD_VAR 0 3
67787: ARRAY
67788: ST_TO_ADDR
// break ;
67789: GO 67793
// end ; end ;
67791: GO 67532
67793: POP
67794: POP
// if not target then
67795: LD_VAR 0 6
67799: NOT
67800: IFFALSE 67804
// continue ;
67802: GO 67413
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67804: LD_ADDR_VAR 0 7
67808: PUSH
67809: LD_EXP 77
67813: PUSH
67814: LD_VAR 0 2
67818: ARRAY
67819: PPUSH
67820: LD_INT 2
67822: PUSH
67823: LD_INT 3
67825: PUSH
67826: LD_INT 58
67828: PUSH
67829: EMPTY
67830: LIST
67831: PUSH
67832: EMPTY
67833: LIST
67834: LIST
67835: PUSH
67836: LD_INT 61
67838: PUSH
67839: EMPTY
67840: LIST
67841: PUSH
67842: LD_INT 33
67844: PUSH
67845: LD_INT 5
67847: PUSH
67848: EMPTY
67849: LIST
67850: LIST
67851: PUSH
67852: LD_INT 33
67854: PUSH
67855: LD_INT 3
67857: PUSH
67858: EMPTY
67859: LIST
67860: LIST
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 2
67871: PUSH
67872: LD_INT 34
67874: PUSH
67875: LD_INT 32
67877: PUSH
67878: EMPTY
67879: LIST
67880: LIST
67881: PUSH
67882: LD_INT 34
67884: PUSH
67885: LD_INT 51
67887: PUSH
67888: EMPTY
67889: LIST
67890: LIST
67891: PUSH
67892: LD_INT 34
67894: PUSH
67895: LD_INT 12
67897: PUSH
67898: EMPTY
67899: LIST
67900: LIST
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: LIST
67906: LIST
67907: PUSH
67908: EMPTY
67909: LIST
67910: LIST
67911: PPUSH
67912: CALL_OW 72
67916: ST_TO_ADDR
// if not cargo then
67917: LD_VAR 0 7
67921: NOT
67922: IFFALSE 68565
// begin if mc_crates_collector [ i ] < 5 then
67924: LD_EXP 75
67928: PUSH
67929: LD_VAR 0 2
67933: ARRAY
67934: PUSH
67935: LD_INT 5
67937: LESS
67938: IFFALSE 68304
// begin if mc_ape [ i ] then
67940: LD_EXP 87
67944: PUSH
67945: LD_VAR 0 2
67949: ARRAY
67950: IFFALSE 67997
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67952: LD_ADDR_VAR 0 5
67956: PUSH
67957: LD_EXP 87
67961: PUSH
67962: LD_VAR 0 2
67966: ARRAY
67967: PPUSH
67968: LD_INT 25
67970: PUSH
67971: LD_INT 16
67973: PUSH
67974: EMPTY
67975: LIST
67976: LIST
67977: PUSH
67978: LD_INT 24
67980: PUSH
67981: LD_INT 750
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PPUSH
67992: CALL_OW 72
67996: ST_TO_ADDR
// if not tmp then
67997: LD_VAR 0 5
68001: NOT
68002: IFFALSE 68049
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68004: LD_ADDR_VAR 0 5
68008: PUSH
68009: LD_EXP 58
68013: PUSH
68014: LD_VAR 0 2
68018: ARRAY
68019: PPUSH
68020: LD_INT 25
68022: PUSH
68023: LD_INT 2
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: LD_INT 24
68032: PUSH
68033: LD_INT 750
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PPUSH
68044: CALL_OW 72
68048: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68049: LD_EXP 87
68053: PUSH
68054: LD_VAR 0 2
68058: ARRAY
68059: PUSH
68060: LD_EXP 58
68064: PUSH
68065: LD_VAR 0 2
68069: ARRAY
68070: PPUSH
68071: LD_INT 25
68073: PUSH
68074: LD_INT 2
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 24
68083: PUSH
68084: LD_INT 750
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PPUSH
68095: CALL_OW 72
68099: AND
68100: PUSH
68101: LD_VAR 0 5
68105: PUSH
68106: LD_INT 5
68108: LESS
68109: AND
68110: IFFALSE 68192
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68112: LD_ADDR_VAR 0 3
68116: PUSH
68117: LD_EXP 58
68121: PUSH
68122: LD_VAR 0 2
68126: ARRAY
68127: PPUSH
68128: LD_INT 25
68130: PUSH
68131: LD_INT 2
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 24
68140: PUSH
68141: LD_INT 750
68143: PUSH
68144: EMPTY
68145: LIST
68146: LIST
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PPUSH
68152: CALL_OW 72
68156: PUSH
68157: FOR_IN
68158: IFFALSE 68190
// begin tmp := tmp union j ;
68160: LD_ADDR_VAR 0 5
68164: PUSH
68165: LD_VAR 0 5
68169: PUSH
68170: LD_VAR 0 3
68174: UNION
68175: ST_TO_ADDR
// if tmp >= 5 then
68176: LD_VAR 0 5
68180: PUSH
68181: LD_INT 5
68183: GREATEREQUAL
68184: IFFALSE 68188
// break ;
68186: GO 68190
// end ;
68188: GO 68157
68190: POP
68191: POP
// end ; if not tmp then
68192: LD_VAR 0 5
68196: NOT
68197: IFFALSE 68201
// continue ;
68199: GO 67413
// for j in tmp do
68201: LD_ADDR_VAR 0 3
68205: PUSH
68206: LD_VAR 0 5
68210: PUSH
68211: FOR_IN
68212: IFFALSE 68302
// if not GetTag ( j ) then
68214: LD_VAR 0 3
68218: PPUSH
68219: CALL_OW 110
68223: NOT
68224: IFFALSE 68300
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68226: LD_ADDR_EXP 75
68230: PUSH
68231: LD_EXP 75
68235: PPUSH
68236: LD_VAR 0 2
68240: PUSH
68241: LD_EXP 75
68245: PUSH
68246: LD_VAR 0 2
68250: ARRAY
68251: PUSH
68252: LD_INT 1
68254: PLUS
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PPUSH
68260: LD_VAR 0 3
68264: PPUSH
68265: CALL 20270 0 3
68269: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68270: LD_VAR 0 3
68274: PPUSH
68275: LD_INT 107
68277: PPUSH
68278: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68282: LD_EXP 75
68286: PUSH
68287: LD_VAR 0 2
68291: ARRAY
68292: PUSH
68293: LD_INT 5
68295: GREATEREQUAL
68296: IFFALSE 68300
// break ;
68298: GO 68302
// end ;
68300: GO 68211
68302: POP
68303: POP
// end ; if mc_crates_collector [ i ] and target then
68304: LD_EXP 75
68308: PUSH
68309: LD_VAR 0 2
68313: ARRAY
68314: PUSH
68315: LD_VAR 0 6
68319: AND
68320: IFFALSE 68563
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68322: LD_EXP 75
68326: PUSH
68327: LD_VAR 0 2
68331: ARRAY
68332: PUSH
68333: LD_VAR 0 6
68337: PUSH
68338: LD_INT 1
68340: ARRAY
68341: LESS
68342: IFFALSE 68362
// tmp := mc_crates_collector [ i ] else
68344: LD_ADDR_VAR 0 5
68348: PUSH
68349: LD_EXP 75
68353: PUSH
68354: LD_VAR 0 2
68358: ARRAY
68359: ST_TO_ADDR
68360: GO 68376
// tmp := target [ 1 ] ;
68362: LD_ADDR_VAR 0 5
68366: PUSH
68367: LD_VAR 0 6
68371: PUSH
68372: LD_INT 1
68374: ARRAY
68375: ST_TO_ADDR
// k := 0 ;
68376: LD_ADDR_VAR 0 4
68380: PUSH
68381: LD_INT 0
68383: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68384: LD_ADDR_VAR 0 3
68388: PUSH
68389: LD_EXP 75
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: PUSH
68400: FOR_IN
68401: IFFALSE 68561
// begin k := k + 1 ;
68403: LD_ADDR_VAR 0 4
68407: PUSH
68408: LD_VAR 0 4
68412: PUSH
68413: LD_INT 1
68415: PLUS
68416: ST_TO_ADDR
// if k > tmp then
68417: LD_VAR 0 4
68421: PUSH
68422: LD_VAR 0 5
68426: GREATER
68427: IFFALSE 68431
// break ;
68429: GO 68561
// if not GetClass ( j ) in [ 2 , 16 ] then
68431: LD_VAR 0 3
68435: PPUSH
68436: CALL_OW 257
68440: PUSH
68441: LD_INT 2
68443: PUSH
68444: LD_INT 16
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: IN
68451: NOT
68452: IFFALSE 68505
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68454: LD_ADDR_EXP 75
68458: PUSH
68459: LD_EXP 75
68463: PPUSH
68464: LD_VAR 0 2
68468: PPUSH
68469: LD_EXP 75
68473: PUSH
68474: LD_VAR 0 2
68478: ARRAY
68479: PUSH
68480: LD_VAR 0 3
68484: DIFF
68485: PPUSH
68486: CALL_OW 1
68490: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68491: LD_VAR 0 3
68495: PPUSH
68496: LD_INT 0
68498: PPUSH
68499: CALL_OW 109
// continue ;
68503: GO 68400
// end ; if IsInUnit ( j ) then
68505: LD_VAR 0 3
68509: PPUSH
68510: CALL_OW 310
68514: IFFALSE 68525
// ComExitBuilding ( j ) ;
68516: LD_VAR 0 3
68520: PPUSH
68521: CALL_OW 122
// wait ( 3 ) ;
68525: LD_INT 3
68527: PPUSH
68528: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68532: LD_VAR 0 3
68536: PPUSH
68537: LD_VAR 0 6
68541: PUSH
68542: LD_INT 2
68544: ARRAY
68545: PPUSH
68546: LD_VAR 0 6
68550: PUSH
68551: LD_INT 3
68553: ARRAY
68554: PPUSH
68555: CALL_OW 117
// end ;
68559: GO 68400
68561: POP
68562: POP
// end ; end else
68563: GO 69125
// begin for j in cargo do
68565: LD_ADDR_VAR 0 3
68569: PUSH
68570: LD_VAR 0 7
68574: PUSH
68575: FOR_IN
68576: IFFALSE 69123
// begin if GetTag ( j ) <> 0 then
68578: LD_VAR 0 3
68582: PPUSH
68583: CALL_OW 110
68587: PUSH
68588: LD_INT 0
68590: NONEQUAL
68591: IFFALSE 68595
// continue ;
68593: GO 68575
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68595: LD_VAR 0 3
68599: PPUSH
68600: CALL_OW 256
68604: PUSH
68605: LD_INT 1000
68607: LESS
68608: PUSH
68609: LD_VAR 0 3
68613: PPUSH
68614: LD_EXP 82
68618: PUSH
68619: LD_VAR 0 2
68623: ARRAY
68624: PPUSH
68625: CALL_OW 308
68629: NOT
68630: AND
68631: IFFALSE 68653
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68633: LD_VAR 0 3
68637: PPUSH
68638: LD_EXP 82
68642: PUSH
68643: LD_VAR 0 2
68647: ARRAY
68648: PPUSH
68649: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68653: LD_VAR 0 3
68657: PPUSH
68658: CALL_OW 256
68662: PUSH
68663: LD_INT 1000
68665: LESS
68666: PUSH
68667: LD_VAR 0 3
68671: PPUSH
68672: LD_EXP 82
68676: PUSH
68677: LD_VAR 0 2
68681: ARRAY
68682: PPUSH
68683: CALL_OW 308
68687: AND
68688: IFFALSE 68692
// continue ;
68690: GO 68575
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68692: LD_VAR 0 3
68696: PPUSH
68697: CALL_OW 262
68701: PUSH
68702: LD_INT 2
68704: EQUAL
68705: PUSH
68706: LD_VAR 0 3
68710: PPUSH
68711: CALL_OW 261
68715: PUSH
68716: LD_INT 15
68718: LESS
68719: AND
68720: IFFALSE 68724
// continue ;
68722: GO 68575
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68724: LD_VAR 0 3
68728: PPUSH
68729: CALL_OW 262
68733: PUSH
68734: LD_INT 1
68736: EQUAL
68737: PUSH
68738: LD_VAR 0 3
68742: PPUSH
68743: CALL_OW 261
68747: PUSH
68748: LD_INT 10
68750: LESS
68751: AND
68752: IFFALSE 69062
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68754: LD_ADDR_VAR 0 8
68758: PUSH
68759: LD_EXP 58
68763: PUSH
68764: LD_VAR 0 2
68768: ARRAY
68769: PPUSH
68770: LD_INT 2
68772: PUSH
68773: LD_INT 30
68775: PUSH
68776: LD_INT 0
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 30
68785: PUSH
68786: LD_INT 1
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: EMPTY
68794: LIST
68795: LIST
68796: LIST
68797: PPUSH
68798: CALL_OW 72
68802: ST_TO_ADDR
// if not depot then
68803: LD_VAR 0 8
68807: NOT
68808: IFFALSE 68812
// continue ;
68810: GO 68575
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68812: LD_VAR 0 3
68816: PPUSH
68817: LD_VAR 0 8
68821: PPUSH
68822: LD_VAR 0 3
68826: PPUSH
68827: CALL_OW 74
68831: PPUSH
68832: CALL_OW 296
68836: PUSH
68837: LD_INT 6
68839: LESS
68840: IFFALSE 68856
// SetFuel ( j , 100 ) else
68842: LD_VAR 0 3
68846: PPUSH
68847: LD_INT 100
68849: PPUSH
68850: CALL_OW 240
68854: GO 69062
// if GetFuel ( j ) = 0 then
68856: LD_VAR 0 3
68860: PPUSH
68861: CALL_OW 261
68865: PUSH
68866: LD_INT 0
68868: EQUAL
68869: IFFALSE 69062
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68871: LD_ADDR_EXP 77
68875: PUSH
68876: LD_EXP 77
68880: PPUSH
68881: LD_VAR 0 2
68885: PPUSH
68886: LD_EXP 77
68890: PUSH
68891: LD_VAR 0 2
68895: ARRAY
68896: PUSH
68897: LD_VAR 0 3
68901: DIFF
68902: PPUSH
68903: CALL_OW 1
68907: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68908: LD_VAR 0 3
68912: PPUSH
68913: CALL_OW 263
68917: PUSH
68918: LD_INT 1
68920: EQUAL
68921: IFFALSE 68937
// ComExitVehicle ( IsInUnit ( j ) ) ;
68923: LD_VAR 0 3
68927: PPUSH
68928: CALL_OW 310
68932: PPUSH
68933: CALL_OW 121
// if GetControl ( j ) = control_remote then
68937: LD_VAR 0 3
68941: PPUSH
68942: CALL_OW 263
68946: PUSH
68947: LD_INT 2
68949: EQUAL
68950: IFFALSE 68961
// ComUnlink ( j ) ;
68952: LD_VAR 0 3
68956: PPUSH
68957: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
68961: LD_ADDR_VAR 0 9
68965: PUSH
68966: LD_VAR 0 2
68970: PPUSH
68971: LD_INT 3
68973: PPUSH
68974: CALL 78224 0 2
68978: ST_TO_ADDR
// if fac then
68979: LD_VAR 0 9
68983: IFFALSE 69060
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68985: LD_ADDR_VAR 0 10
68989: PUSH
68990: LD_VAR 0 9
68994: PPUSH
68995: LD_VAR 0 3
68999: PPUSH
69000: CALL_OW 265
69004: PPUSH
69005: LD_VAR 0 3
69009: PPUSH
69010: CALL_OW 262
69014: PPUSH
69015: LD_VAR 0 3
69019: PPUSH
69020: CALL_OW 263
69024: PPUSH
69025: LD_VAR 0 3
69029: PPUSH
69030: CALL_OW 264
69034: PPUSH
69035: CALL 17870 0 5
69039: ST_TO_ADDR
// if components then
69040: LD_VAR 0 10
69044: IFFALSE 69060
// MC_InsertProduceList ( i , components ) ;
69046: LD_VAR 0 2
69050: PPUSH
69051: LD_VAR 0 10
69055: PPUSH
69056: CALL 77794 0 2
// end ; continue ;
69060: GO 68575
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69062: LD_VAR 0 3
69066: PPUSH
69067: LD_INT 1
69069: PPUSH
69070: CALL_OW 289
69074: PUSH
69075: LD_INT 100
69077: LESS
69078: PUSH
69079: LD_VAR 0 3
69083: PPUSH
69084: CALL_OW 314
69088: NOT
69089: AND
69090: IFFALSE 69119
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69092: LD_VAR 0 3
69096: PPUSH
69097: LD_VAR 0 6
69101: PUSH
69102: LD_INT 2
69104: ARRAY
69105: PPUSH
69106: LD_VAR 0 6
69110: PUSH
69111: LD_INT 3
69113: ARRAY
69114: PPUSH
69115: CALL_OW 117
// break ;
69119: GO 69123
// end ;
69121: GO 68575
69123: POP
69124: POP
// end ; end ;
69125: GO 67413
69127: POP
69128: POP
// end ;
69129: LD_VAR 0 1
69133: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69134: LD_INT 0
69136: PPUSH
69137: PPUSH
69138: PPUSH
69139: PPUSH
// if not mc_bases then
69140: LD_EXP 58
69144: NOT
69145: IFFALSE 69149
// exit ;
69147: GO 69310
// for i = 1 to mc_bases do
69149: LD_ADDR_VAR 0 2
69153: PUSH
69154: DOUBLE
69155: LD_INT 1
69157: DEC
69158: ST_TO_ADDR
69159: LD_EXP 58
69163: PUSH
69164: FOR_TO
69165: IFFALSE 69308
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69167: LD_ADDR_VAR 0 4
69171: PUSH
69172: LD_EXP 77
69176: PUSH
69177: LD_VAR 0 2
69181: ARRAY
69182: PUSH
69183: LD_EXP 80
69187: PUSH
69188: LD_VAR 0 2
69192: ARRAY
69193: UNION
69194: PPUSH
69195: LD_INT 33
69197: PUSH
69198: LD_INT 2
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PPUSH
69205: CALL_OW 72
69209: ST_TO_ADDR
// if tmp then
69210: LD_VAR 0 4
69214: IFFALSE 69306
// for j in tmp do
69216: LD_ADDR_VAR 0 3
69220: PUSH
69221: LD_VAR 0 4
69225: PUSH
69226: FOR_IN
69227: IFFALSE 69304
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69229: LD_VAR 0 3
69233: PPUSH
69234: CALL_OW 312
69238: NOT
69239: PUSH
69240: LD_VAR 0 3
69244: PPUSH
69245: CALL_OW 256
69249: PUSH
69250: LD_INT 250
69252: GREATEREQUAL
69253: AND
69254: IFFALSE 69267
// Connect ( j ) else
69256: LD_VAR 0 3
69260: PPUSH
69261: CALL 23203 0 1
69265: GO 69302
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69267: LD_VAR 0 3
69271: PPUSH
69272: CALL_OW 256
69276: PUSH
69277: LD_INT 250
69279: LESS
69280: PUSH
69281: LD_VAR 0 3
69285: PPUSH
69286: CALL_OW 312
69290: AND
69291: IFFALSE 69302
// ComUnlink ( j ) ;
69293: LD_VAR 0 3
69297: PPUSH
69298: CALL_OW 136
69302: GO 69226
69304: POP
69305: POP
// end ;
69306: GO 69164
69308: POP
69309: POP
// end ;
69310: LD_VAR 0 1
69314: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69315: LD_INT 0
69317: PPUSH
69318: PPUSH
69319: PPUSH
69320: PPUSH
69321: PPUSH
// if not mc_bases then
69322: LD_EXP 58
69326: NOT
69327: IFFALSE 69331
// exit ;
69329: GO 69791
// for i = 1 to mc_bases do
69331: LD_ADDR_VAR 0 2
69335: PUSH
69336: DOUBLE
69337: LD_INT 1
69339: DEC
69340: ST_TO_ADDR
69341: LD_EXP 58
69345: PUSH
69346: FOR_TO
69347: IFFALSE 69789
// begin if not mc_produce [ i ] then
69349: LD_EXP 79
69353: PUSH
69354: LD_VAR 0 2
69358: ARRAY
69359: NOT
69360: IFFALSE 69364
// continue ;
69362: GO 69346
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69364: LD_ADDR_VAR 0 5
69368: PUSH
69369: LD_EXP 58
69373: PUSH
69374: LD_VAR 0 2
69378: ARRAY
69379: PPUSH
69380: LD_INT 30
69382: PUSH
69383: LD_INT 3
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PPUSH
69390: CALL_OW 72
69394: ST_TO_ADDR
// if not fac then
69395: LD_VAR 0 5
69399: NOT
69400: IFFALSE 69404
// continue ;
69402: GO 69346
// for j in fac do
69404: LD_ADDR_VAR 0 3
69408: PUSH
69409: LD_VAR 0 5
69413: PUSH
69414: FOR_IN
69415: IFFALSE 69785
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
69417: LD_VAR 0 3
69421: PPUSH
69422: CALL_OW 461
69426: PUSH
69427: LD_INT 2
69429: NONEQUAL
69430: PUSH
69431: LD_VAR 0 3
69435: PPUSH
69436: LD_INT 15
69438: PPUSH
69439: CALL 22863 0 2
69443: PUSH
69444: LD_INT 4
69446: ARRAY
69447: OR
69448: PUSH
69449: LD_VAR 0 3
69453: PPUSH
69454: CALL_OW 313
69458: PUSH
69459: LD_INT 0
69461: EQUAL
69462: OR
69463: IFFALSE 69467
// continue ;
69465: GO 69414
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69467: LD_VAR 0 3
69471: PPUSH
69472: LD_EXP 79
69476: PUSH
69477: LD_VAR 0 2
69481: ARRAY
69482: PUSH
69483: LD_INT 1
69485: ARRAY
69486: PUSH
69487: LD_INT 1
69489: ARRAY
69490: PPUSH
69491: LD_EXP 79
69495: PUSH
69496: LD_VAR 0 2
69500: ARRAY
69501: PUSH
69502: LD_INT 1
69504: ARRAY
69505: PUSH
69506: LD_INT 2
69508: ARRAY
69509: PPUSH
69510: LD_EXP 79
69514: PUSH
69515: LD_VAR 0 2
69519: ARRAY
69520: PUSH
69521: LD_INT 1
69523: ARRAY
69524: PUSH
69525: LD_INT 3
69527: ARRAY
69528: PPUSH
69529: LD_EXP 79
69533: PUSH
69534: LD_VAR 0 2
69538: ARRAY
69539: PUSH
69540: LD_INT 1
69542: ARRAY
69543: PUSH
69544: LD_INT 4
69546: ARRAY
69547: PPUSH
69548: CALL_OW 448
69552: PUSH
69553: LD_VAR 0 3
69557: PPUSH
69558: LD_EXP 79
69562: PUSH
69563: LD_VAR 0 2
69567: ARRAY
69568: PUSH
69569: LD_INT 1
69571: ARRAY
69572: PUSH
69573: LD_INT 1
69575: ARRAY
69576: PUSH
69577: LD_EXP 79
69581: PUSH
69582: LD_VAR 0 2
69586: ARRAY
69587: PUSH
69588: LD_INT 1
69590: ARRAY
69591: PUSH
69592: LD_INT 2
69594: ARRAY
69595: PUSH
69596: LD_EXP 79
69600: PUSH
69601: LD_VAR 0 2
69605: ARRAY
69606: PUSH
69607: LD_INT 1
69609: ARRAY
69610: PUSH
69611: LD_INT 3
69613: ARRAY
69614: PUSH
69615: LD_EXP 79
69619: PUSH
69620: LD_VAR 0 2
69624: ARRAY
69625: PUSH
69626: LD_INT 1
69628: ARRAY
69629: PUSH
69630: LD_INT 4
69632: ARRAY
69633: PUSH
69634: EMPTY
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: PPUSH
69640: CALL 26534 0 2
69644: AND
69645: IFFALSE 69783
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69647: LD_VAR 0 3
69651: PPUSH
69652: LD_EXP 79
69656: PUSH
69657: LD_VAR 0 2
69661: ARRAY
69662: PUSH
69663: LD_INT 1
69665: ARRAY
69666: PUSH
69667: LD_INT 1
69669: ARRAY
69670: PPUSH
69671: LD_EXP 79
69675: PUSH
69676: LD_VAR 0 2
69680: ARRAY
69681: PUSH
69682: LD_INT 1
69684: ARRAY
69685: PUSH
69686: LD_INT 2
69688: ARRAY
69689: PPUSH
69690: LD_EXP 79
69694: PUSH
69695: LD_VAR 0 2
69699: ARRAY
69700: PUSH
69701: LD_INT 1
69703: ARRAY
69704: PUSH
69705: LD_INT 3
69707: ARRAY
69708: PPUSH
69709: LD_EXP 79
69713: PUSH
69714: LD_VAR 0 2
69718: ARRAY
69719: PUSH
69720: LD_INT 1
69722: ARRAY
69723: PUSH
69724: LD_INT 4
69726: ARRAY
69727: PPUSH
69728: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69732: LD_ADDR_VAR 0 4
69736: PUSH
69737: LD_EXP 79
69741: PUSH
69742: LD_VAR 0 2
69746: ARRAY
69747: PPUSH
69748: LD_INT 1
69750: PPUSH
69751: CALL_OW 3
69755: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69756: LD_ADDR_EXP 79
69760: PUSH
69761: LD_EXP 79
69765: PPUSH
69766: LD_VAR 0 2
69770: PPUSH
69771: LD_VAR 0 4
69775: PPUSH
69776: CALL_OW 1
69780: ST_TO_ADDR
// break ;
69781: GO 69785
// end ; end ;
69783: GO 69414
69785: POP
69786: POP
// end ;
69787: GO 69346
69789: POP
69790: POP
// end ;
69791: LD_VAR 0 1
69795: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69796: LD_INT 0
69798: PPUSH
69799: PPUSH
69800: PPUSH
// if not mc_bases then
69801: LD_EXP 58
69805: NOT
69806: IFFALSE 69810
// exit ;
69808: GO 69899
// for i = 1 to mc_bases do
69810: LD_ADDR_VAR 0 2
69814: PUSH
69815: DOUBLE
69816: LD_INT 1
69818: DEC
69819: ST_TO_ADDR
69820: LD_EXP 58
69824: PUSH
69825: FOR_TO
69826: IFFALSE 69897
// begin if mc_attack [ i ] then
69828: LD_EXP 78
69832: PUSH
69833: LD_VAR 0 2
69837: ARRAY
69838: IFFALSE 69895
// begin tmp := mc_attack [ i ] [ 1 ] ;
69840: LD_ADDR_VAR 0 3
69844: PUSH
69845: LD_EXP 78
69849: PUSH
69850: LD_VAR 0 2
69854: ARRAY
69855: PUSH
69856: LD_INT 1
69858: ARRAY
69859: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69860: LD_ADDR_EXP 78
69864: PUSH
69865: LD_EXP 78
69869: PPUSH
69870: LD_VAR 0 2
69874: PPUSH
69875: EMPTY
69876: PPUSH
69877: CALL_OW 1
69881: ST_TO_ADDR
// Attack ( tmp ) ;
69882: LD_VAR 0 3
69886: PPUSH
69887: CALL 48723 0 1
// exit ;
69891: POP
69892: POP
69893: GO 69899
// end ; end ;
69895: GO 69825
69897: POP
69898: POP
// end ;
69899: LD_VAR 0 1
69903: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69904: LD_INT 0
69906: PPUSH
69907: PPUSH
69908: PPUSH
69909: PPUSH
69910: PPUSH
69911: PPUSH
69912: PPUSH
// if not mc_bases then
69913: LD_EXP 58
69917: NOT
69918: IFFALSE 69922
// exit ;
69920: GO 70526
// for i = 1 to mc_bases do
69922: LD_ADDR_VAR 0 2
69926: PUSH
69927: DOUBLE
69928: LD_INT 1
69930: DEC
69931: ST_TO_ADDR
69932: LD_EXP 58
69936: PUSH
69937: FOR_TO
69938: IFFALSE 70524
// begin if not mc_bases [ i ] then
69940: LD_EXP 58
69944: PUSH
69945: LD_VAR 0 2
69949: ARRAY
69950: NOT
69951: IFFALSE 69955
// continue ;
69953: GO 69937
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69955: LD_ADDR_VAR 0 7
69959: PUSH
69960: LD_EXP 58
69964: PUSH
69965: LD_VAR 0 2
69969: ARRAY
69970: PUSH
69971: LD_INT 1
69973: ARRAY
69974: PPUSH
69975: CALL 17174 0 1
69979: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69980: LD_ADDR_EXP 81
69984: PUSH
69985: LD_EXP 81
69989: PPUSH
69990: LD_VAR 0 2
69994: PPUSH
69995: LD_EXP 58
69999: PUSH
70000: LD_VAR 0 2
70004: ARRAY
70005: PUSH
70006: LD_INT 1
70008: ARRAY
70009: PPUSH
70010: CALL_OW 255
70014: PPUSH
70015: LD_EXP 83
70019: PUSH
70020: LD_VAR 0 2
70024: ARRAY
70025: PPUSH
70026: CALL 15134 0 2
70030: PPUSH
70031: CALL_OW 1
70035: ST_TO_ADDR
// if not mc_scan [ i ] then
70036: LD_EXP 81
70040: PUSH
70041: LD_VAR 0 2
70045: ARRAY
70046: NOT
70047: IFFALSE 70202
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70049: LD_ADDR_VAR 0 4
70053: PUSH
70054: LD_EXP 58
70058: PUSH
70059: LD_VAR 0 2
70063: ARRAY
70064: PPUSH
70065: LD_INT 2
70067: PUSH
70068: LD_INT 25
70070: PUSH
70071: LD_INT 5
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 25
70080: PUSH
70081: LD_INT 8
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: LD_INT 25
70090: PUSH
70091: LD_INT 9
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: LIST
70102: LIST
70103: PPUSH
70104: CALL_OW 72
70108: ST_TO_ADDR
// if not tmp then
70109: LD_VAR 0 4
70113: NOT
70114: IFFALSE 70118
// continue ;
70116: GO 69937
// for j in tmp do
70118: LD_ADDR_VAR 0 3
70122: PUSH
70123: LD_VAR 0 4
70127: PUSH
70128: FOR_IN
70129: IFFALSE 70200
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70131: LD_VAR 0 3
70135: PPUSH
70136: CALL_OW 310
70140: PPUSH
70141: CALL_OW 266
70145: PUSH
70146: LD_INT 5
70148: EQUAL
70149: PUSH
70150: LD_VAR 0 3
70154: PPUSH
70155: CALL_OW 257
70159: PUSH
70160: LD_INT 1
70162: EQUAL
70163: AND
70164: PUSH
70165: LD_VAR 0 3
70169: PPUSH
70170: CALL_OW 459
70174: NOT
70175: AND
70176: PUSH
70177: LD_VAR 0 7
70181: AND
70182: IFFALSE 70198
// ComChangeProfession ( j , class ) ;
70184: LD_VAR 0 3
70188: PPUSH
70189: LD_VAR 0 7
70193: PPUSH
70194: CALL_OW 123
70198: GO 70128
70200: POP
70201: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70202: LD_EXP 81
70206: PUSH
70207: LD_VAR 0 2
70211: ARRAY
70212: PUSH
70213: LD_EXP 80
70217: PUSH
70218: LD_VAR 0 2
70222: ARRAY
70223: NOT
70224: AND
70225: PUSH
70226: LD_EXP 58
70230: PUSH
70231: LD_VAR 0 2
70235: ARRAY
70236: PPUSH
70237: LD_INT 30
70239: PUSH
70240: LD_INT 32
70242: PUSH
70243: EMPTY
70244: LIST
70245: LIST
70246: PPUSH
70247: CALL_OW 72
70251: NOT
70252: AND
70253: PUSH
70254: LD_EXP 58
70258: PUSH
70259: LD_VAR 0 2
70263: ARRAY
70264: PPUSH
70265: LD_INT 2
70267: PUSH
70268: LD_INT 30
70270: PUSH
70271: LD_INT 4
70273: PUSH
70274: EMPTY
70275: LIST
70276: LIST
70277: PUSH
70278: LD_INT 30
70280: PUSH
70281: LD_INT 5
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: LIST
70292: PPUSH
70293: CALL_OW 72
70297: NOT
70298: AND
70299: IFFALSE 70431
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70301: LD_ADDR_VAR 0 4
70305: PUSH
70306: LD_EXP 58
70310: PUSH
70311: LD_VAR 0 2
70315: ARRAY
70316: PPUSH
70317: LD_INT 2
70319: PUSH
70320: LD_INT 25
70322: PUSH
70323: LD_INT 1
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: LD_INT 25
70332: PUSH
70333: LD_INT 5
70335: PUSH
70336: EMPTY
70337: LIST
70338: LIST
70339: PUSH
70340: LD_INT 25
70342: PUSH
70343: LD_INT 8
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 25
70352: PUSH
70353: LD_INT 9
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: LIST
70364: LIST
70365: LIST
70366: PPUSH
70367: CALL_OW 72
70371: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70372: LD_ADDR_VAR 0 4
70376: PUSH
70377: LD_VAR 0 4
70381: PUSH
70382: LD_VAR 0 4
70386: PPUSH
70387: LD_INT 18
70389: PPUSH
70390: CALL 53467 0 2
70394: DIFF
70395: ST_TO_ADDR
// if tmp then
70396: LD_VAR 0 4
70400: IFFALSE 70431
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70402: LD_VAR 0 2
70406: PPUSH
70407: LD_VAR 0 4
70411: PPUSH
70412: LD_EXP 83
70416: PUSH
70417: LD_VAR 0 2
70421: ARRAY
70422: PPUSH
70423: CALL 15169 0 3
// exit ;
70427: POP
70428: POP
70429: GO 70526
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70431: LD_EXP 81
70435: PUSH
70436: LD_VAR 0 2
70440: ARRAY
70441: PUSH
70442: LD_EXP 80
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: AND
70453: IFFALSE 70522
// begin tmp := mc_defender [ i ] ;
70455: LD_ADDR_VAR 0 4
70459: PUSH
70460: LD_EXP 80
70464: PUSH
70465: LD_VAR 0 2
70469: ARRAY
70470: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70471: LD_ADDR_EXP 80
70475: PUSH
70476: LD_EXP 80
70480: PPUSH
70481: LD_VAR 0 2
70485: PPUSH
70486: EMPTY
70487: PPUSH
70488: CALL_OW 1
70492: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70493: LD_VAR 0 2
70497: PPUSH
70498: LD_VAR 0 4
70502: PPUSH
70503: LD_EXP 81
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: PPUSH
70514: CALL 15667 0 3
// exit ;
70518: POP
70519: POP
70520: GO 70526
// end ; end ;
70522: GO 69937
70524: POP
70525: POP
// end ;
70526: LD_VAR 0 1
70530: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70531: LD_INT 0
70533: PPUSH
70534: PPUSH
70535: PPUSH
70536: PPUSH
70537: PPUSH
70538: PPUSH
70539: PPUSH
70540: PPUSH
70541: PPUSH
70542: PPUSH
70543: PPUSH
// if not mc_bases then
70544: LD_EXP 58
70548: NOT
70549: IFFALSE 70553
// exit ;
70551: GO 71640
// for i = 1 to mc_bases do
70553: LD_ADDR_VAR 0 2
70557: PUSH
70558: DOUBLE
70559: LD_INT 1
70561: DEC
70562: ST_TO_ADDR
70563: LD_EXP 58
70567: PUSH
70568: FOR_TO
70569: IFFALSE 71638
// begin tmp := mc_lab [ i ] ;
70571: LD_ADDR_VAR 0 6
70575: PUSH
70576: LD_EXP 91
70580: PUSH
70581: LD_VAR 0 2
70585: ARRAY
70586: ST_TO_ADDR
// if not tmp then
70587: LD_VAR 0 6
70591: NOT
70592: IFFALSE 70596
// continue ;
70594: GO 70568
// idle_lab := 0 ;
70596: LD_ADDR_VAR 0 11
70600: PUSH
70601: LD_INT 0
70603: ST_TO_ADDR
// for j in tmp do
70604: LD_ADDR_VAR 0 3
70608: PUSH
70609: LD_VAR 0 6
70613: PUSH
70614: FOR_IN
70615: IFFALSE 71634
// begin researching := false ;
70617: LD_ADDR_VAR 0 10
70621: PUSH
70622: LD_INT 0
70624: ST_TO_ADDR
// side := GetSide ( j ) ;
70625: LD_ADDR_VAR 0 4
70629: PUSH
70630: LD_VAR 0 3
70634: PPUSH
70635: CALL_OW 255
70639: ST_TO_ADDR
// if not mc_tech [ side ] then
70640: LD_EXP 85
70644: PUSH
70645: LD_VAR 0 4
70649: ARRAY
70650: NOT
70651: IFFALSE 70655
// continue ;
70653: GO 70614
// if BuildingStatus ( j ) = bs_idle then
70655: LD_VAR 0 3
70659: PPUSH
70660: CALL_OW 461
70664: PUSH
70665: LD_INT 2
70667: EQUAL
70668: IFFALSE 70856
// begin if idle_lab and UnitsInside ( j ) < 6 then
70670: LD_VAR 0 11
70674: PUSH
70675: LD_VAR 0 3
70679: PPUSH
70680: CALL_OW 313
70684: PUSH
70685: LD_INT 6
70687: LESS
70688: AND
70689: IFFALSE 70760
// begin tmp2 := UnitsInside ( idle_lab ) ;
70691: LD_ADDR_VAR 0 9
70695: PUSH
70696: LD_VAR 0 11
70700: PPUSH
70701: CALL_OW 313
70705: ST_TO_ADDR
// if tmp2 then
70706: LD_VAR 0 9
70710: IFFALSE 70752
// for x in tmp2 do
70712: LD_ADDR_VAR 0 7
70716: PUSH
70717: LD_VAR 0 9
70721: PUSH
70722: FOR_IN
70723: IFFALSE 70750
// begin ComExitBuilding ( x ) ;
70725: LD_VAR 0 7
70729: PPUSH
70730: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70734: LD_VAR 0 7
70738: PPUSH
70739: LD_VAR 0 3
70743: PPUSH
70744: CALL_OW 180
// end ;
70748: GO 70722
70750: POP
70751: POP
// idle_lab := 0 ;
70752: LD_ADDR_VAR 0 11
70756: PUSH
70757: LD_INT 0
70759: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70760: LD_ADDR_VAR 0 5
70764: PUSH
70765: LD_EXP 85
70769: PUSH
70770: LD_VAR 0 4
70774: ARRAY
70775: PUSH
70776: FOR_IN
70777: IFFALSE 70837
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70779: LD_VAR 0 3
70783: PPUSH
70784: LD_VAR 0 5
70788: PPUSH
70789: CALL_OW 430
70793: PUSH
70794: LD_VAR 0 4
70798: PPUSH
70799: LD_VAR 0 5
70803: PPUSH
70804: CALL 14239 0 2
70808: AND
70809: IFFALSE 70835
// begin researching := true ;
70811: LD_ADDR_VAR 0 10
70815: PUSH
70816: LD_INT 1
70818: ST_TO_ADDR
// ComResearch ( j , t ) ;
70819: LD_VAR 0 3
70823: PPUSH
70824: LD_VAR 0 5
70828: PPUSH
70829: CALL_OW 124
// break ;
70833: GO 70837
// end ;
70835: GO 70776
70837: POP
70838: POP
// if not researching then
70839: LD_VAR 0 10
70843: NOT
70844: IFFALSE 70856
// idle_lab := j ;
70846: LD_ADDR_VAR 0 11
70850: PUSH
70851: LD_VAR 0 3
70855: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70856: LD_VAR 0 3
70860: PPUSH
70861: CALL_OW 461
70865: PUSH
70866: LD_INT 10
70868: EQUAL
70869: IFFALSE 71457
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70871: LD_EXP 87
70875: PUSH
70876: LD_VAR 0 2
70880: ARRAY
70881: NOT
70882: PUSH
70883: LD_EXP 88
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: NOT
70894: AND
70895: PUSH
70896: LD_EXP 85
70900: PUSH
70901: LD_VAR 0 4
70905: ARRAY
70906: PUSH
70907: LD_INT 1
70909: GREATER
70910: AND
70911: IFFALSE 71042
// begin ComCancel ( j ) ;
70913: LD_VAR 0 3
70917: PPUSH
70918: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70922: LD_ADDR_EXP 85
70926: PUSH
70927: LD_EXP 85
70931: PPUSH
70932: LD_VAR 0 4
70936: PPUSH
70937: LD_EXP 85
70941: PUSH
70942: LD_VAR 0 4
70946: ARRAY
70947: PPUSH
70948: LD_EXP 85
70952: PUSH
70953: LD_VAR 0 4
70957: ARRAY
70958: PUSH
70959: LD_INT 1
70961: MINUS
70962: PPUSH
70963: LD_EXP 85
70967: PUSH
70968: LD_VAR 0 4
70972: ARRAY
70973: PPUSH
70974: LD_INT 0
70976: PPUSH
70977: CALL 19688 0 4
70981: PPUSH
70982: CALL_OW 1
70986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70987: LD_ADDR_EXP 85
70991: PUSH
70992: LD_EXP 85
70996: PPUSH
70997: LD_VAR 0 4
71001: PPUSH
71002: LD_EXP 85
71006: PUSH
71007: LD_VAR 0 4
71011: ARRAY
71012: PPUSH
71013: LD_EXP 85
71017: PUSH
71018: LD_VAR 0 4
71022: ARRAY
71023: PPUSH
71024: LD_INT 1
71026: PPUSH
71027: LD_INT 0
71029: PPUSH
71030: CALL 19688 0 4
71034: PPUSH
71035: CALL_OW 1
71039: ST_TO_ADDR
// continue ;
71040: GO 70614
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71042: LD_EXP 87
71046: PUSH
71047: LD_VAR 0 2
71051: ARRAY
71052: PUSH
71053: LD_EXP 88
71057: PUSH
71058: LD_VAR 0 2
71062: ARRAY
71063: NOT
71064: AND
71065: IFFALSE 71192
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71067: LD_ADDR_EXP 88
71071: PUSH
71072: LD_EXP 88
71076: PPUSH
71077: LD_VAR 0 2
71081: PUSH
71082: LD_EXP 88
71086: PUSH
71087: LD_VAR 0 2
71091: ARRAY
71092: PUSH
71093: LD_INT 1
71095: PLUS
71096: PUSH
71097: EMPTY
71098: LIST
71099: LIST
71100: PPUSH
71101: LD_EXP 87
71105: PUSH
71106: LD_VAR 0 2
71110: ARRAY
71111: PUSH
71112: LD_INT 1
71114: ARRAY
71115: PPUSH
71116: CALL 20270 0 3
71120: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71121: LD_EXP 87
71125: PUSH
71126: LD_VAR 0 2
71130: ARRAY
71131: PUSH
71132: LD_INT 1
71134: ARRAY
71135: PPUSH
71136: LD_INT 112
71138: PPUSH
71139: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71143: LD_ADDR_VAR 0 9
71147: PUSH
71148: LD_EXP 87
71152: PUSH
71153: LD_VAR 0 2
71157: ARRAY
71158: PPUSH
71159: LD_INT 1
71161: PPUSH
71162: CALL_OW 3
71166: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71167: LD_ADDR_EXP 87
71171: PUSH
71172: LD_EXP 87
71176: PPUSH
71177: LD_VAR 0 2
71181: PPUSH
71182: LD_VAR 0 9
71186: PPUSH
71187: CALL_OW 1
71191: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71192: LD_EXP 87
71196: PUSH
71197: LD_VAR 0 2
71201: ARRAY
71202: PUSH
71203: LD_EXP 88
71207: PUSH
71208: LD_VAR 0 2
71212: ARRAY
71213: AND
71214: PUSH
71215: LD_EXP 88
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: PUSH
71226: LD_INT 1
71228: ARRAY
71229: PPUSH
71230: CALL_OW 310
71234: NOT
71235: AND
71236: PUSH
71237: LD_VAR 0 3
71241: PPUSH
71242: CALL_OW 313
71246: PUSH
71247: LD_INT 6
71249: EQUAL
71250: AND
71251: IFFALSE 71307
// begin tmp2 := UnitsInside ( j ) ;
71253: LD_ADDR_VAR 0 9
71257: PUSH
71258: LD_VAR 0 3
71262: PPUSH
71263: CALL_OW 313
71267: ST_TO_ADDR
// if tmp2 = 6 then
71268: LD_VAR 0 9
71272: PUSH
71273: LD_INT 6
71275: EQUAL
71276: IFFALSE 71307
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71278: LD_VAR 0 9
71282: PUSH
71283: LD_INT 1
71285: ARRAY
71286: PPUSH
71287: LD_INT 112
71289: PPUSH
71290: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71294: LD_VAR 0 9
71298: PUSH
71299: LD_INT 1
71301: ARRAY
71302: PPUSH
71303: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71307: LD_EXP 88
71311: PUSH
71312: LD_VAR 0 2
71316: ARRAY
71317: PUSH
71318: LD_EXP 88
71322: PUSH
71323: LD_VAR 0 2
71327: ARRAY
71328: PUSH
71329: LD_INT 1
71331: ARRAY
71332: PPUSH
71333: CALL_OW 314
71337: NOT
71338: AND
71339: PUSH
71340: LD_EXP 88
71344: PUSH
71345: LD_VAR 0 2
71349: ARRAY
71350: PUSH
71351: LD_INT 1
71353: ARRAY
71354: PPUSH
71355: CALL_OW 310
71359: NOT
71360: AND
71361: IFFALSE 71387
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71363: LD_EXP 88
71367: PUSH
71368: LD_VAR 0 2
71372: ARRAY
71373: PUSH
71374: LD_INT 1
71376: ARRAY
71377: PPUSH
71378: LD_VAR 0 3
71382: PPUSH
71383: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71387: LD_EXP 88
71391: PUSH
71392: LD_VAR 0 2
71396: ARRAY
71397: PUSH
71398: LD_INT 1
71400: ARRAY
71401: PPUSH
71402: CALL_OW 310
71406: PUSH
71407: LD_EXP 88
71411: PUSH
71412: LD_VAR 0 2
71416: ARRAY
71417: PUSH
71418: LD_INT 1
71420: ARRAY
71421: PPUSH
71422: CALL_OW 310
71426: PPUSH
71427: CALL_OW 461
71431: PUSH
71432: LD_INT 3
71434: NONEQUAL
71435: AND
71436: IFFALSE 71457
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71438: LD_EXP 88
71442: PUSH
71443: LD_VAR 0 2
71447: ARRAY
71448: PUSH
71449: LD_INT 1
71451: ARRAY
71452: PPUSH
71453: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71457: LD_VAR 0 3
71461: PPUSH
71462: CALL_OW 461
71466: PUSH
71467: LD_INT 6
71469: EQUAL
71470: PUSH
71471: LD_VAR 0 6
71475: PUSH
71476: LD_INT 1
71478: GREATER
71479: AND
71480: IFFALSE 71632
// begin sci := [ ] ;
71482: LD_ADDR_VAR 0 8
71486: PUSH
71487: EMPTY
71488: ST_TO_ADDR
// for x in ( tmp diff j ) do
71489: LD_ADDR_VAR 0 7
71493: PUSH
71494: LD_VAR 0 6
71498: PUSH
71499: LD_VAR 0 3
71503: DIFF
71504: PUSH
71505: FOR_IN
71506: IFFALSE 71558
// begin if sci = 6 then
71508: LD_VAR 0 8
71512: PUSH
71513: LD_INT 6
71515: EQUAL
71516: IFFALSE 71520
// break ;
71518: GO 71558
// if BuildingStatus ( x ) = bs_idle then
71520: LD_VAR 0 7
71524: PPUSH
71525: CALL_OW 461
71529: PUSH
71530: LD_INT 2
71532: EQUAL
71533: IFFALSE 71556
// sci := sci ^ UnitsInside ( x ) ;
71535: LD_ADDR_VAR 0 8
71539: PUSH
71540: LD_VAR 0 8
71544: PUSH
71545: LD_VAR 0 7
71549: PPUSH
71550: CALL_OW 313
71554: ADD
71555: ST_TO_ADDR
// end ;
71556: GO 71505
71558: POP
71559: POP
// if not sci then
71560: LD_VAR 0 8
71564: NOT
71565: IFFALSE 71569
// continue ;
71567: GO 70614
// for x in sci do
71569: LD_ADDR_VAR 0 7
71573: PUSH
71574: LD_VAR 0 8
71578: PUSH
71579: FOR_IN
71580: IFFALSE 71630
// if IsInUnit ( x ) and not HasTask ( x ) then
71582: LD_VAR 0 7
71586: PPUSH
71587: CALL_OW 310
71591: PUSH
71592: LD_VAR 0 7
71596: PPUSH
71597: CALL_OW 314
71601: NOT
71602: AND
71603: IFFALSE 71628
// begin ComExitBuilding ( x ) ;
71605: LD_VAR 0 7
71609: PPUSH
71610: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71614: LD_VAR 0 7
71618: PPUSH
71619: LD_VAR 0 3
71623: PPUSH
71624: CALL_OW 180
// end ;
71628: GO 71579
71630: POP
71631: POP
// end ; end ;
71632: GO 70614
71634: POP
71635: POP
// end ;
71636: GO 70568
71638: POP
71639: POP
// end ;
71640: LD_VAR 0 1
71644: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71645: LD_INT 0
71647: PPUSH
71648: PPUSH
// if not mc_bases then
71649: LD_EXP 58
71653: NOT
71654: IFFALSE 71658
// exit ;
71656: GO 71739
// for i = 1 to mc_bases do
71658: LD_ADDR_VAR 0 2
71662: PUSH
71663: DOUBLE
71664: LD_INT 1
71666: DEC
71667: ST_TO_ADDR
71668: LD_EXP 58
71672: PUSH
71673: FOR_TO
71674: IFFALSE 71737
// if mc_mines [ i ] and mc_miners [ i ] then
71676: LD_EXP 71
71680: PUSH
71681: LD_VAR 0 2
71685: ARRAY
71686: PUSH
71687: LD_EXP 72
71691: PUSH
71692: LD_VAR 0 2
71696: ARRAY
71697: AND
71698: IFFALSE 71735
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71700: LD_EXP 72
71704: PUSH
71705: LD_VAR 0 2
71709: ARRAY
71710: PUSH
71711: LD_INT 1
71713: ARRAY
71714: PPUSH
71715: CALL_OW 255
71719: PPUSH
71720: LD_EXP 71
71724: PUSH
71725: LD_VAR 0 2
71729: ARRAY
71730: PPUSH
71731: CALL 17327 0 2
71735: GO 71673
71737: POP
71738: POP
// end ;
71739: LD_VAR 0 1
71743: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71744: LD_INT 0
71746: PPUSH
71747: PPUSH
71748: PPUSH
71749: PPUSH
71750: PPUSH
71751: PPUSH
71752: PPUSH
71753: PPUSH
// if not mc_bases or not mc_parking then
71754: LD_EXP 58
71758: NOT
71759: PUSH
71760: LD_EXP 82
71764: NOT
71765: OR
71766: IFFALSE 71770
// exit ;
71768: GO 72482
// for i = 1 to mc_bases do
71770: LD_ADDR_VAR 0 2
71774: PUSH
71775: DOUBLE
71776: LD_INT 1
71778: DEC
71779: ST_TO_ADDR
71780: LD_EXP 58
71784: PUSH
71785: FOR_TO
71786: IFFALSE 72480
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71788: LD_EXP 58
71792: PUSH
71793: LD_VAR 0 2
71797: ARRAY
71798: NOT
71799: PUSH
71800: LD_EXP 82
71804: PUSH
71805: LD_VAR 0 2
71809: ARRAY
71810: NOT
71811: OR
71812: IFFALSE 71816
// continue ;
71814: GO 71785
// if mc_scan [ i ] then
71816: LD_EXP 81
71820: PUSH
71821: LD_VAR 0 2
71825: ARRAY
71826: IFFALSE 71852
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71828: LD_ADDR_EXP 70
71832: PUSH
71833: LD_EXP 70
71837: PPUSH
71838: LD_VAR 0 2
71842: PPUSH
71843: EMPTY
71844: PPUSH
71845: CALL_OW 1
71849: ST_TO_ADDR
// continue ;
71850: GO 71785
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71852: LD_ADDR_VAR 0 5
71856: PUSH
71857: LD_EXP 58
71861: PUSH
71862: LD_VAR 0 2
71866: ARRAY
71867: PUSH
71868: LD_INT 1
71870: ARRAY
71871: PPUSH
71872: CALL_OW 255
71876: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71877: LD_ADDR_VAR 0 6
71881: PUSH
71882: LD_EXP 58
71886: PUSH
71887: LD_VAR 0 2
71891: ARRAY
71892: PPUSH
71893: LD_INT 30
71895: PUSH
71896: LD_INT 3
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PPUSH
71903: CALL_OW 72
71907: ST_TO_ADDR
// if not fac then
71908: LD_VAR 0 6
71912: NOT
71913: IFFALSE 71964
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71915: LD_ADDR_VAR 0 6
71919: PUSH
71920: LD_EXP 58
71924: PUSH
71925: LD_VAR 0 2
71929: ARRAY
71930: PPUSH
71931: LD_INT 2
71933: PUSH
71934: LD_INT 30
71936: PUSH
71937: LD_INT 0
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 30
71946: PUSH
71947: LD_INT 1
71949: PUSH
71950: EMPTY
71951: LIST
71952: LIST
71953: PUSH
71954: EMPTY
71955: LIST
71956: LIST
71957: LIST
71958: PPUSH
71959: CALL_OW 72
71963: ST_TO_ADDR
// if not fac then
71964: LD_VAR 0 6
71968: NOT
71969: IFFALSE 71973
// continue ;
71971: GO 71785
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71973: LD_ADDR_VAR 0 7
71977: PUSH
71978: LD_EXP 82
71982: PUSH
71983: LD_VAR 0 2
71987: ARRAY
71988: PPUSH
71989: LD_INT 22
71991: PUSH
71992: LD_VAR 0 5
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: LD_INT 21
72003: PUSH
72004: LD_INT 2
72006: PUSH
72007: EMPTY
72008: LIST
72009: LIST
72010: PUSH
72011: LD_INT 3
72013: PUSH
72014: LD_INT 24
72016: PUSH
72017: LD_INT 1000
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PUSH
72028: EMPTY
72029: LIST
72030: LIST
72031: LIST
72032: PPUSH
72033: CALL_OW 70
72037: PUSH
72038: LD_INT 22
72040: PUSH
72041: LD_VAR 0 5
72045: PUSH
72046: EMPTY
72047: LIST
72048: LIST
72049: PUSH
72050: LD_INT 91
72052: PUSH
72053: LD_VAR 0 6
72057: PUSH
72058: LD_INT 1
72060: ARRAY
72061: PUSH
72062: LD_INT 25
72064: PUSH
72065: EMPTY
72066: LIST
72067: LIST
72068: LIST
72069: PUSH
72070: LD_INT 21
72072: PUSH
72073: LD_INT 2
72075: PUSH
72076: EMPTY
72077: LIST
72078: LIST
72079: PUSH
72080: LD_INT 3
72082: PUSH
72083: LD_INT 24
72085: PUSH
72086: LD_INT 1000
72088: PUSH
72089: EMPTY
72090: LIST
72091: LIST
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: PPUSH
72103: CALL_OW 69
72107: UNION
72108: ST_TO_ADDR
// if not vehs then
72109: LD_VAR 0 7
72113: NOT
72114: IFFALSE 72140
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72116: LD_ADDR_EXP 70
72120: PUSH
72121: LD_EXP 70
72125: PPUSH
72126: LD_VAR 0 2
72130: PPUSH
72131: EMPTY
72132: PPUSH
72133: CALL_OW 1
72137: ST_TO_ADDR
// continue ;
72138: GO 71785
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72140: LD_ADDR_VAR 0 8
72144: PUSH
72145: LD_EXP 58
72149: PUSH
72150: LD_VAR 0 2
72154: ARRAY
72155: PPUSH
72156: LD_INT 30
72158: PUSH
72159: LD_INT 3
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PPUSH
72166: CALL_OW 72
72170: ST_TO_ADDR
// if tmp then
72171: LD_VAR 0 8
72175: IFFALSE 72278
// begin for j in tmp do
72177: LD_ADDR_VAR 0 3
72181: PUSH
72182: LD_VAR 0 8
72186: PUSH
72187: FOR_IN
72188: IFFALSE 72276
// for k in UnitsInside ( j ) do
72190: LD_ADDR_VAR 0 4
72194: PUSH
72195: LD_VAR 0 3
72199: PPUSH
72200: CALL_OW 313
72204: PUSH
72205: FOR_IN
72206: IFFALSE 72272
// if k then
72208: LD_VAR 0 4
72212: IFFALSE 72270
// if not k in mc_repair_vehicle [ i ] then
72214: LD_VAR 0 4
72218: PUSH
72219: LD_EXP 70
72223: PUSH
72224: LD_VAR 0 2
72228: ARRAY
72229: IN
72230: NOT
72231: IFFALSE 72270
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72233: LD_ADDR_EXP 70
72237: PUSH
72238: LD_EXP 70
72242: PPUSH
72243: LD_VAR 0 2
72247: PPUSH
72248: LD_EXP 70
72252: PUSH
72253: LD_VAR 0 2
72257: ARRAY
72258: PUSH
72259: LD_VAR 0 4
72263: UNION
72264: PPUSH
72265: CALL_OW 1
72269: ST_TO_ADDR
72270: GO 72205
72272: POP
72273: POP
72274: GO 72187
72276: POP
72277: POP
// end ; if not mc_repair_vehicle [ i ] then
72278: LD_EXP 70
72282: PUSH
72283: LD_VAR 0 2
72287: ARRAY
72288: NOT
72289: IFFALSE 72293
// continue ;
72291: GO 71785
// for j in mc_repair_vehicle [ i ] do
72293: LD_ADDR_VAR 0 3
72297: PUSH
72298: LD_EXP 70
72302: PUSH
72303: LD_VAR 0 2
72307: ARRAY
72308: PUSH
72309: FOR_IN
72310: IFFALSE 72476
// begin if GetClass ( j ) <> 3 then
72312: LD_VAR 0 3
72316: PPUSH
72317: CALL_OW 257
72321: PUSH
72322: LD_INT 3
72324: NONEQUAL
72325: IFFALSE 72366
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72327: LD_ADDR_EXP 70
72331: PUSH
72332: LD_EXP 70
72336: PPUSH
72337: LD_VAR 0 2
72341: PPUSH
72342: LD_EXP 70
72346: PUSH
72347: LD_VAR 0 2
72351: ARRAY
72352: PUSH
72353: LD_VAR 0 3
72357: DIFF
72358: PPUSH
72359: CALL_OW 1
72363: ST_TO_ADDR
// continue ;
72364: GO 72309
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72366: LD_VAR 0 3
72370: PPUSH
72371: CALL_OW 311
72375: NOT
72376: PUSH
72377: LD_VAR 0 3
72381: PUSH
72382: LD_EXP 61
72386: PUSH
72387: LD_VAR 0 2
72391: ARRAY
72392: PUSH
72393: LD_INT 1
72395: ARRAY
72396: IN
72397: NOT
72398: AND
72399: PUSH
72400: LD_VAR 0 3
72404: PUSH
72405: LD_EXP 61
72409: PUSH
72410: LD_VAR 0 2
72414: ARRAY
72415: PUSH
72416: LD_INT 2
72418: ARRAY
72419: IN
72420: NOT
72421: AND
72422: IFFALSE 72474
// begin if IsInUnit ( j ) then
72424: LD_VAR 0 3
72428: PPUSH
72429: CALL_OW 310
72433: IFFALSE 72444
// ComExitBuilding ( j ) ;
72435: LD_VAR 0 3
72439: PPUSH
72440: CALL_OW 122
// if not HasTask ( j ) then
72444: LD_VAR 0 3
72448: PPUSH
72449: CALL_OW 314
72453: NOT
72454: IFFALSE 72474
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72456: LD_VAR 0 3
72460: PPUSH
72461: LD_VAR 0 7
72465: PUSH
72466: LD_INT 1
72468: ARRAY
72469: PPUSH
72470: CALL_OW 189
// end ; end ;
72474: GO 72309
72476: POP
72477: POP
// end ;
72478: GO 71785
72480: POP
72481: POP
// end ;
72482: LD_VAR 0 1
72486: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72487: LD_INT 0
72489: PPUSH
72490: PPUSH
72491: PPUSH
72492: PPUSH
72493: PPUSH
72494: PPUSH
72495: PPUSH
72496: PPUSH
72497: PPUSH
72498: PPUSH
72499: PPUSH
// if not mc_bases then
72500: LD_EXP 58
72504: NOT
72505: IFFALSE 72509
// exit ;
72507: GO 73311
// for i = 1 to mc_bases do
72509: LD_ADDR_VAR 0 2
72513: PUSH
72514: DOUBLE
72515: LD_INT 1
72517: DEC
72518: ST_TO_ADDR
72519: LD_EXP 58
72523: PUSH
72524: FOR_TO
72525: IFFALSE 73309
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72527: LD_EXP 86
72531: PUSH
72532: LD_VAR 0 2
72536: ARRAY
72537: NOT
72538: PUSH
72539: LD_EXP 61
72543: PUSH
72544: LD_VAR 0 2
72548: ARRAY
72549: PUSH
72550: LD_INT 1
72552: ARRAY
72553: OR
72554: PUSH
72555: LD_EXP 61
72559: PUSH
72560: LD_VAR 0 2
72564: ARRAY
72565: PUSH
72566: LD_INT 2
72568: ARRAY
72569: OR
72570: PUSH
72571: LD_EXP 84
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: PPUSH
72582: LD_INT 1
72584: PPUSH
72585: CALL_OW 325
72589: NOT
72590: OR
72591: PUSH
72592: LD_EXP 81
72596: PUSH
72597: LD_VAR 0 2
72601: ARRAY
72602: OR
72603: IFFALSE 72607
// continue ;
72605: GO 72524
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72607: LD_ADDR_VAR 0 8
72611: PUSH
72612: LD_EXP 58
72616: PUSH
72617: LD_VAR 0 2
72621: ARRAY
72622: PPUSH
72623: LD_INT 25
72625: PUSH
72626: LD_INT 4
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 50
72635: PUSH
72636: EMPTY
72637: LIST
72638: PUSH
72639: LD_INT 3
72641: PUSH
72642: LD_INT 60
72644: PUSH
72645: EMPTY
72646: LIST
72647: PUSH
72648: EMPTY
72649: LIST
72650: LIST
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: LIST
72656: PPUSH
72657: CALL_OW 72
72661: PUSH
72662: LD_EXP 62
72666: PUSH
72667: LD_VAR 0 2
72671: ARRAY
72672: DIFF
72673: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72674: LD_ADDR_VAR 0 9
72678: PUSH
72679: LD_EXP 58
72683: PUSH
72684: LD_VAR 0 2
72688: ARRAY
72689: PPUSH
72690: LD_INT 2
72692: PUSH
72693: LD_INT 30
72695: PUSH
72696: LD_INT 0
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 30
72705: PUSH
72706: LD_INT 1
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: EMPTY
72714: LIST
72715: LIST
72716: LIST
72717: PPUSH
72718: CALL_OW 72
72722: ST_TO_ADDR
// if not tmp or not dep then
72723: LD_VAR 0 8
72727: NOT
72728: PUSH
72729: LD_VAR 0 9
72733: NOT
72734: OR
72735: IFFALSE 72739
// continue ;
72737: GO 72524
// side := GetSide ( tmp [ 1 ] ) ;
72739: LD_ADDR_VAR 0 11
72743: PUSH
72744: LD_VAR 0 8
72748: PUSH
72749: LD_INT 1
72751: ARRAY
72752: PPUSH
72753: CALL_OW 255
72757: ST_TO_ADDR
// dep := dep [ 1 ] ;
72758: LD_ADDR_VAR 0 9
72762: PUSH
72763: LD_VAR 0 9
72767: PUSH
72768: LD_INT 1
72770: ARRAY
72771: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72772: LD_ADDR_VAR 0 7
72776: PUSH
72777: LD_EXP 86
72781: PUSH
72782: LD_VAR 0 2
72786: ARRAY
72787: PPUSH
72788: LD_INT 22
72790: PUSH
72791: LD_INT 0
72793: PUSH
72794: EMPTY
72795: LIST
72796: LIST
72797: PUSH
72798: LD_INT 25
72800: PUSH
72801: LD_INT 12
72803: PUSH
72804: EMPTY
72805: LIST
72806: LIST
72807: PUSH
72808: EMPTY
72809: LIST
72810: LIST
72811: PPUSH
72812: CALL_OW 70
72816: PUSH
72817: LD_INT 22
72819: PUSH
72820: LD_INT 0
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: LD_INT 25
72829: PUSH
72830: LD_INT 12
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PUSH
72837: LD_INT 91
72839: PUSH
72840: LD_VAR 0 9
72844: PUSH
72845: LD_INT 20
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: LIST
72852: PUSH
72853: EMPTY
72854: LIST
72855: LIST
72856: LIST
72857: PPUSH
72858: CALL_OW 69
72862: UNION
72863: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72864: LD_ADDR_VAR 0 10
72868: PUSH
72869: LD_EXP 86
72873: PUSH
72874: LD_VAR 0 2
72878: ARRAY
72879: PPUSH
72880: LD_INT 81
72882: PUSH
72883: LD_VAR 0 11
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PPUSH
72892: CALL_OW 70
72896: ST_TO_ADDR
// if not apes or danger_at_area then
72897: LD_VAR 0 7
72901: NOT
72902: PUSH
72903: LD_VAR 0 10
72907: OR
72908: IFFALSE 72958
// begin if mc_taming [ i ] then
72910: LD_EXP 89
72914: PUSH
72915: LD_VAR 0 2
72919: ARRAY
72920: IFFALSE 72956
// begin MC_Reset ( i , 121 ) ;
72922: LD_VAR 0 2
72926: PPUSH
72927: LD_INT 121
72929: PPUSH
72930: CALL 58916 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72934: LD_ADDR_EXP 89
72938: PUSH
72939: LD_EXP 89
72943: PPUSH
72944: LD_VAR 0 2
72948: PPUSH
72949: EMPTY
72950: PPUSH
72951: CALL_OW 1
72955: ST_TO_ADDR
// end ; continue ;
72956: GO 72524
// end ; for j in tmp do
72958: LD_ADDR_VAR 0 3
72962: PUSH
72963: LD_VAR 0 8
72967: PUSH
72968: FOR_IN
72969: IFFALSE 73305
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72971: LD_VAR 0 3
72975: PUSH
72976: LD_EXP 89
72980: PUSH
72981: LD_VAR 0 2
72985: ARRAY
72986: IN
72987: NOT
72988: PUSH
72989: LD_EXP 89
72993: PUSH
72994: LD_VAR 0 2
72998: ARRAY
72999: PUSH
73000: LD_INT 3
73002: LESS
73003: AND
73004: IFFALSE 73062
// begin SetTag ( j , 121 ) ;
73006: LD_VAR 0 3
73010: PPUSH
73011: LD_INT 121
73013: PPUSH
73014: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73018: LD_ADDR_EXP 89
73022: PUSH
73023: LD_EXP 89
73027: PPUSH
73028: LD_VAR 0 2
73032: PUSH
73033: LD_EXP 89
73037: PUSH
73038: LD_VAR 0 2
73042: ARRAY
73043: PUSH
73044: LD_INT 1
73046: PLUS
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PPUSH
73052: LD_VAR 0 3
73056: PPUSH
73057: CALL 20270 0 3
73061: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73062: LD_VAR 0 3
73066: PUSH
73067: LD_EXP 89
73071: PUSH
73072: LD_VAR 0 2
73076: ARRAY
73077: IN
73078: IFFALSE 73303
// begin if GetClass ( j ) <> 4 then
73080: LD_VAR 0 3
73084: PPUSH
73085: CALL_OW 257
73089: PUSH
73090: LD_INT 4
73092: NONEQUAL
73093: IFFALSE 73146
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73095: LD_ADDR_EXP 89
73099: PUSH
73100: LD_EXP 89
73104: PPUSH
73105: LD_VAR 0 2
73109: PPUSH
73110: LD_EXP 89
73114: PUSH
73115: LD_VAR 0 2
73119: ARRAY
73120: PUSH
73121: LD_VAR 0 3
73125: DIFF
73126: PPUSH
73127: CALL_OW 1
73131: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73132: LD_VAR 0 3
73136: PPUSH
73137: LD_INT 0
73139: PPUSH
73140: CALL_OW 109
// continue ;
73144: GO 72968
// end ; if IsInUnit ( j ) then
73146: LD_VAR 0 3
73150: PPUSH
73151: CALL_OW 310
73155: IFFALSE 73166
// ComExitBuilding ( j ) ;
73157: LD_VAR 0 3
73161: PPUSH
73162: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73166: LD_ADDR_VAR 0 6
73170: PUSH
73171: LD_VAR 0 7
73175: PPUSH
73176: LD_VAR 0 3
73180: PPUSH
73181: CALL_OW 74
73185: ST_TO_ADDR
// if not ape then
73186: LD_VAR 0 6
73190: NOT
73191: IFFALSE 73195
// break ;
73193: GO 73305
// x := GetX ( ape ) ;
73195: LD_ADDR_VAR 0 4
73199: PUSH
73200: LD_VAR 0 6
73204: PPUSH
73205: CALL_OW 250
73209: ST_TO_ADDR
// y := GetY ( ape ) ;
73210: LD_ADDR_VAR 0 5
73214: PUSH
73215: LD_VAR 0 6
73219: PPUSH
73220: CALL_OW 251
73224: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73225: LD_VAR 0 4
73229: PPUSH
73230: LD_VAR 0 5
73234: PPUSH
73235: CALL_OW 488
73239: NOT
73240: PUSH
73241: LD_VAR 0 11
73245: PPUSH
73246: LD_VAR 0 4
73250: PPUSH
73251: LD_VAR 0 5
73255: PPUSH
73256: LD_INT 20
73258: PPUSH
73259: CALL 21166 0 4
73263: PUSH
73264: LD_INT 4
73266: ARRAY
73267: OR
73268: IFFALSE 73272
// break ;
73270: GO 73305
// if not HasTask ( j ) then
73272: LD_VAR 0 3
73276: PPUSH
73277: CALL_OW 314
73281: NOT
73282: IFFALSE 73303
// ComTameXY ( j , x , y ) ;
73284: LD_VAR 0 3
73288: PPUSH
73289: LD_VAR 0 4
73293: PPUSH
73294: LD_VAR 0 5
73298: PPUSH
73299: CALL_OW 131
// end ; end ;
73303: GO 72968
73305: POP
73306: POP
// end ;
73307: GO 72524
73309: POP
73310: POP
// end ;
73311: LD_VAR 0 1
73315: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73316: LD_INT 0
73318: PPUSH
73319: PPUSH
73320: PPUSH
73321: PPUSH
73322: PPUSH
73323: PPUSH
73324: PPUSH
73325: PPUSH
// if not mc_bases then
73326: LD_EXP 58
73330: NOT
73331: IFFALSE 73335
// exit ;
73333: GO 73961
// for i = 1 to mc_bases do
73335: LD_ADDR_VAR 0 2
73339: PUSH
73340: DOUBLE
73341: LD_INT 1
73343: DEC
73344: ST_TO_ADDR
73345: LD_EXP 58
73349: PUSH
73350: FOR_TO
73351: IFFALSE 73959
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73353: LD_EXP 87
73357: PUSH
73358: LD_VAR 0 2
73362: ARRAY
73363: NOT
73364: PUSH
73365: LD_EXP 87
73369: PUSH
73370: LD_VAR 0 2
73374: ARRAY
73375: PPUSH
73376: LD_INT 25
73378: PUSH
73379: LD_INT 12
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PPUSH
73386: CALL_OW 72
73390: NOT
73391: OR
73392: IFFALSE 73396
// continue ;
73394: GO 73350
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73396: LD_ADDR_VAR 0 5
73400: PUSH
73401: LD_EXP 87
73405: PUSH
73406: LD_VAR 0 2
73410: ARRAY
73411: PUSH
73412: LD_INT 1
73414: ARRAY
73415: PPUSH
73416: CALL_OW 255
73420: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73421: LD_VAR 0 5
73425: PPUSH
73426: LD_INT 2
73428: PPUSH
73429: CALL_OW 325
73433: IFFALSE 73686
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73435: LD_ADDR_VAR 0 4
73439: PUSH
73440: LD_EXP 87
73444: PUSH
73445: LD_VAR 0 2
73449: ARRAY
73450: PPUSH
73451: LD_INT 25
73453: PUSH
73454: LD_INT 16
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PPUSH
73461: CALL_OW 72
73465: ST_TO_ADDR
// if tmp < 6 then
73466: LD_VAR 0 4
73470: PUSH
73471: LD_INT 6
73473: LESS
73474: IFFALSE 73686
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73476: LD_ADDR_VAR 0 6
73480: PUSH
73481: LD_EXP 58
73485: PUSH
73486: LD_VAR 0 2
73490: ARRAY
73491: PPUSH
73492: LD_INT 2
73494: PUSH
73495: LD_INT 30
73497: PUSH
73498: LD_INT 0
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 30
73507: PUSH
73508: LD_INT 1
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: EMPTY
73516: LIST
73517: LIST
73518: LIST
73519: PPUSH
73520: CALL_OW 72
73524: ST_TO_ADDR
// if depot then
73525: LD_VAR 0 6
73529: IFFALSE 73686
// begin selected := 0 ;
73531: LD_ADDR_VAR 0 7
73535: PUSH
73536: LD_INT 0
73538: ST_TO_ADDR
// for j in depot do
73539: LD_ADDR_VAR 0 3
73543: PUSH
73544: LD_VAR 0 6
73548: PUSH
73549: FOR_IN
73550: IFFALSE 73581
// begin if UnitsInside ( j ) < 6 then
73552: LD_VAR 0 3
73556: PPUSH
73557: CALL_OW 313
73561: PUSH
73562: LD_INT 6
73564: LESS
73565: IFFALSE 73579
// begin selected := j ;
73567: LD_ADDR_VAR 0 7
73571: PUSH
73572: LD_VAR 0 3
73576: ST_TO_ADDR
// break ;
73577: GO 73581
// end ; end ;
73579: GO 73549
73581: POP
73582: POP
// if selected then
73583: LD_VAR 0 7
73587: IFFALSE 73686
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73589: LD_ADDR_VAR 0 3
73593: PUSH
73594: LD_EXP 87
73598: PUSH
73599: LD_VAR 0 2
73603: ARRAY
73604: PPUSH
73605: LD_INT 25
73607: PUSH
73608: LD_INT 12
73610: PUSH
73611: EMPTY
73612: LIST
73613: LIST
73614: PPUSH
73615: CALL_OW 72
73619: PUSH
73620: FOR_IN
73621: IFFALSE 73684
// if not HasTask ( j ) then
73623: LD_VAR 0 3
73627: PPUSH
73628: CALL_OW 314
73632: NOT
73633: IFFALSE 73682
// begin if not IsInUnit ( j ) then
73635: LD_VAR 0 3
73639: PPUSH
73640: CALL_OW 310
73644: NOT
73645: IFFALSE 73661
// ComEnterUnit ( j , selected ) ;
73647: LD_VAR 0 3
73651: PPUSH
73652: LD_VAR 0 7
73656: PPUSH
73657: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73661: LD_VAR 0 3
73665: PPUSH
73666: LD_INT 16
73668: PPUSH
73669: CALL_OW 183
// AddComExitBuilding ( j ) ;
73673: LD_VAR 0 3
73677: PPUSH
73678: CALL_OW 182
// end ;
73682: GO 73620
73684: POP
73685: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73686: LD_VAR 0 5
73690: PPUSH
73691: LD_INT 11
73693: PPUSH
73694: CALL_OW 325
73698: IFFALSE 73957
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73700: LD_ADDR_VAR 0 4
73704: PUSH
73705: LD_EXP 87
73709: PUSH
73710: LD_VAR 0 2
73714: ARRAY
73715: PPUSH
73716: LD_INT 25
73718: PUSH
73719: LD_INT 16
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PPUSH
73726: CALL_OW 72
73730: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73731: LD_VAR 0 4
73735: PUSH
73736: LD_INT 6
73738: GREATEREQUAL
73739: PUSH
73740: LD_VAR 0 5
73744: PPUSH
73745: LD_INT 2
73747: PPUSH
73748: CALL_OW 325
73752: NOT
73753: OR
73754: IFFALSE 73957
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73756: LD_ADDR_VAR 0 8
73760: PUSH
73761: LD_EXP 58
73765: PUSH
73766: LD_VAR 0 2
73770: ARRAY
73771: PPUSH
73772: LD_INT 2
73774: PUSH
73775: LD_INT 30
73777: PUSH
73778: LD_INT 4
73780: PUSH
73781: EMPTY
73782: LIST
73783: LIST
73784: PUSH
73785: LD_INT 30
73787: PUSH
73788: LD_INT 5
73790: PUSH
73791: EMPTY
73792: LIST
73793: LIST
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: LIST
73799: PPUSH
73800: CALL_OW 72
73804: ST_TO_ADDR
// if barracks then
73805: LD_VAR 0 8
73809: IFFALSE 73957
// begin selected := 0 ;
73811: LD_ADDR_VAR 0 7
73815: PUSH
73816: LD_INT 0
73818: ST_TO_ADDR
// for j in barracks do
73819: LD_ADDR_VAR 0 3
73823: PUSH
73824: LD_VAR 0 8
73828: PUSH
73829: FOR_IN
73830: IFFALSE 73861
// begin if UnitsInside ( j ) < 6 then
73832: LD_VAR 0 3
73836: PPUSH
73837: CALL_OW 313
73841: PUSH
73842: LD_INT 6
73844: LESS
73845: IFFALSE 73859
// begin selected := j ;
73847: LD_ADDR_VAR 0 7
73851: PUSH
73852: LD_VAR 0 3
73856: ST_TO_ADDR
// break ;
73857: GO 73861
// end ; end ;
73859: GO 73829
73861: POP
73862: POP
// if selected then
73863: LD_VAR 0 7
73867: IFFALSE 73957
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73869: LD_ADDR_VAR 0 3
73873: PUSH
73874: LD_EXP 87
73878: PUSH
73879: LD_VAR 0 2
73883: ARRAY
73884: PPUSH
73885: LD_INT 25
73887: PUSH
73888: LD_INT 12
73890: PUSH
73891: EMPTY
73892: LIST
73893: LIST
73894: PPUSH
73895: CALL_OW 72
73899: PUSH
73900: FOR_IN
73901: IFFALSE 73955
// if not IsInUnit ( j ) and not HasTask ( j ) then
73903: LD_VAR 0 3
73907: PPUSH
73908: CALL_OW 310
73912: NOT
73913: PUSH
73914: LD_VAR 0 3
73918: PPUSH
73919: CALL_OW 314
73923: NOT
73924: AND
73925: IFFALSE 73953
// begin ComEnterUnit ( j , selected ) ;
73927: LD_VAR 0 3
73931: PPUSH
73932: LD_VAR 0 7
73936: PPUSH
73937: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73941: LD_VAR 0 3
73945: PPUSH
73946: LD_INT 15
73948: PPUSH
73949: CALL_OW 183
// end ;
73953: GO 73900
73955: POP
73956: POP
// end ; end ; end ; end ; end ;
73957: GO 73350
73959: POP
73960: POP
// end ;
73961: LD_VAR 0 1
73965: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73966: LD_INT 0
73968: PPUSH
73969: PPUSH
73970: PPUSH
73971: PPUSH
// if not mc_bases then
73972: LD_EXP 58
73976: NOT
73977: IFFALSE 73981
// exit ;
73979: GO 74159
// for i = 1 to mc_bases do
73981: LD_ADDR_VAR 0 2
73985: PUSH
73986: DOUBLE
73987: LD_INT 1
73989: DEC
73990: ST_TO_ADDR
73991: LD_EXP 58
73995: PUSH
73996: FOR_TO
73997: IFFALSE 74157
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73999: LD_ADDR_VAR 0 4
74003: PUSH
74004: LD_EXP 58
74008: PUSH
74009: LD_VAR 0 2
74013: ARRAY
74014: PPUSH
74015: LD_INT 25
74017: PUSH
74018: LD_INT 9
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PPUSH
74025: CALL_OW 72
74029: ST_TO_ADDR
// if not tmp then
74030: LD_VAR 0 4
74034: NOT
74035: IFFALSE 74039
// continue ;
74037: GO 73996
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74039: LD_EXP 84
74043: PUSH
74044: LD_VAR 0 2
74048: ARRAY
74049: PPUSH
74050: LD_INT 29
74052: PPUSH
74053: CALL_OW 325
74057: NOT
74058: PUSH
74059: LD_EXP 84
74063: PUSH
74064: LD_VAR 0 2
74068: ARRAY
74069: PPUSH
74070: LD_INT 28
74072: PPUSH
74073: CALL_OW 325
74077: NOT
74078: AND
74079: IFFALSE 74083
// continue ;
74081: GO 73996
// for j in tmp do
74083: LD_ADDR_VAR 0 3
74087: PUSH
74088: LD_VAR 0 4
74092: PUSH
74093: FOR_IN
74094: IFFALSE 74153
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74096: LD_VAR 0 3
74100: PUSH
74101: LD_EXP 61
74105: PUSH
74106: LD_VAR 0 2
74110: ARRAY
74111: PUSH
74112: LD_INT 1
74114: ARRAY
74115: IN
74116: NOT
74117: PUSH
74118: LD_VAR 0 3
74122: PUSH
74123: LD_EXP 61
74127: PUSH
74128: LD_VAR 0 2
74132: ARRAY
74133: PUSH
74134: LD_INT 2
74136: ARRAY
74137: IN
74138: NOT
74139: AND
74140: IFFALSE 74151
// ComSpaceTimeShoot ( j ) ;
74142: LD_VAR 0 3
74146: PPUSH
74147: CALL 14330 0 1
74151: GO 74093
74153: POP
74154: POP
// end ;
74155: GO 73996
74157: POP
74158: POP
// end ;
74159: LD_VAR 0 1
74163: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74164: LD_INT 0
74166: PPUSH
74167: PPUSH
74168: PPUSH
74169: PPUSH
74170: PPUSH
74171: PPUSH
74172: PPUSH
74173: PPUSH
74174: PPUSH
// if not mc_bases then
74175: LD_EXP 58
74179: NOT
74180: IFFALSE 74184
// exit ;
74182: GO 74806
// for i = 1 to mc_bases do
74184: LD_ADDR_VAR 0 2
74188: PUSH
74189: DOUBLE
74190: LD_INT 1
74192: DEC
74193: ST_TO_ADDR
74194: LD_EXP 58
74198: PUSH
74199: FOR_TO
74200: IFFALSE 74804
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74202: LD_EXP 93
74206: PUSH
74207: LD_VAR 0 2
74211: ARRAY
74212: NOT
74213: PUSH
74214: LD_INT 38
74216: PPUSH
74217: LD_EXP 84
74221: PUSH
74222: LD_VAR 0 2
74226: ARRAY
74227: PPUSH
74228: CALL_OW 321
74232: PUSH
74233: LD_INT 2
74235: NONEQUAL
74236: OR
74237: IFFALSE 74241
// continue ;
74239: GO 74199
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74241: LD_ADDR_VAR 0 8
74245: PUSH
74246: LD_EXP 58
74250: PUSH
74251: LD_VAR 0 2
74255: ARRAY
74256: PPUSH
74257: LD_INT 30
74259: PUSH
74260: LD_INT 34
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PPUSH
74267: CALL_OW 72
74271: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74272: LD_ADDR_VAR 0 9
74276: PUSH
74277: LD_EXP 58
74281: PUSH
74282: LD_VAR 0 2
74286: ARRAY
74287: PPUSH
74288: LD_INT 25
74290: PUSH
74291: LD_INT 4
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PPUSH
74298: CALL_OW 72
74302: PPUSH
74303: LD_INT 0
74305: PPUSH
74306: CALL 53467 0 2
74310: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74311: LD_VAR 0 9
74315: NOT
74316: PUSH
74317: LD_VAR 0 8
74321: NOT
74322: OR
74323: PUSH
74324: LD_EXP 58
74328: PUSH
74329: LD_VAR 0 2
74333: ARRAY
74334: PPUSH
74335: LD_INT 124
74337: PPUSH
74338: CALL 53467 0 2
74342: OR
74343: IFFALSE 74347
// continue ;
74345: GO 74199
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74347: LD_EXP 94
74351: PUSH
74352: LD_VAR 0 2
74356: ARRAY
74357: PUSH
74358: LD_EXP 93
74362: PUSH
74363: LD_VAR 0 2
74367: ARRAY
74368: LESS
74369: PUSH
74370: LD_EXP 94
74374: PUSH
74375: LD_VAR 0 2
74379: ARRAY
74380: PUSH
74381: LD_VAR 0 8
74385: LESS
74386: AND
74387: IFFALSE 74802
// begin tmp := sci [ 1 ] ;
74389: LD_ADDR_VAR 0 7
74393: PUSH
74394: LD_VAR 0 9
74398: PUSH
74399: LD_INT 1
74401: ARRAY
74402: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74403: LD_VAR 0 7
74407: PPUSH
74408: LD_INT 124
74410: PPUSH
74411: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74415: LD_ADDR_VAR 0 3
74419: PUSH
74420: DOUBLE
74421: LD_EXP 93
74425: PUSH
74426: LD_VAR 0 2
74430: ARRAY
74431: INC
74432: ST_TO_ADDR
74433: LD_EXP 93
74437: PUSH
74438: LD_VAR 0 2
74442: ARRAY
74443: PUSH
74444: FOR_DOWNTO
74445: IFFALSE 74788
// begin if IsInUnit ( tmp ) then
74447: LD_VAR 0 7
74451: PPUSH
74452: CALL_OW 310
74456: IFFALSE 74467
// ComExitBuilding ( tmp ) ;
74458: LD_VAR 0 7
74462: PPUSH
74463: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74467: LD_INT 35
74469: PPUSH
74470: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74474: LD_VAR 0 7
74478: PPUSH
74479: CALL_OW 310
74483: NOT
74484: PUSH
74485: LD_VAR 0 7
74489: PPUSH
74490: CALL_OW 314
74494: NOT
74495: AND
74496: IFFALSE 74467
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74498: LD_ADDR_VAR 0 6
74502: PUSH
74503: LD_VAR 0 7
74507: PPUSH
74508: CALL_OW 250
74512: PUSH
74513: LD_VAR 0 7
74517: PPUSH
74518: CALL_OW 251
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74527: LD_INT 35
74529: PPUSH
74530: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74534: LD_ADDR_VAR 0 4
74538: PUSH
74539: LD_EXP 93
74543: PUSH
74544: LD_VAR 0 2
74548: ARRAY
74549: PUSH
74550: LD_VAR 0 3
74554: ARRAY
74555: PUSH
74556: LD_INT 1
74558: ARRAY
74559: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74560: LD_ADDR_VAR 0 5
74564: PUSH
74565: LD_EXP 93
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: PUSH
74576: LD_VAR 0 3
74580: ARRAY
74581: PUSH
74582: LD_INT 2
74584: ARRAY
74585: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74586: LD_VAR 0 7
74590: PPUSH
74591: LD_INT 10
74593: PPUSH
74594: CALL 22863 0 2
74598: PUSH
74599: LD_INT 4
74601: ARRAY
74602: IFFALSE 74640
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74604: LD_VAR 0 7
74608: PPUSH
74609: LD_VAR 0 6
74613: PUSH
74614: LD_INT 1
74616: ARRAY
74617: PPUSH
74618: LD_VAR 0 6
74622: PUSH
74623: LD_INT 2
74625: ARRAY
74626: PPUSH
74627: CALL_OW 111
// wait ( 0 0$10 ) ;
74631: LD_INT 350
74633: PPUSH
74634: CALL_OW 67
// end else
74638: GO 74666
// begin ComMoveXY ( tmp , x , y ) ;
74640: LD_VAR 0 7
74644: PPUSH
74645: LD_VAR 0 4
74649: PPUSH
74650: LD_VAR 0 5
74654: PPUSH
74655: CALL_OW 111
// wait ( 0 0$3 ) ;
74659: LD_INT 105
74661: PPUSH
74662: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74666: LD_VAR 0 7
74670: PPUSH
74671: LD_VAR 0 4
74675: PPUSH
74676: LD_VAR 0 5
74680: PPUSH
74681: CALL_OW 307
74685: IFFALSE 74527
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74687: LD_VAR 0 7
74691: PPUSH
74692: LD_VAR 0 4
74696: PPUSH
74697: LD_VAR 0 5
74701: PPUSH
74702: LD_VAR 0 8
74706: PUSH
74707: LD_VAR 0 3
74711: ARRAY
74712: PPUSH
74713: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74717: LD_INT 35
74719: PPUSH
74720: CALL_OW 67
// until not HasTask ( tmp ) ;
74724: LD_VAR 0 7
74728: PPUSH
74729: CALL_OW 314
74733: NOT
74734: IFFALSE 74717
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74736: LD_ADDR_EXP 94
74740: PUSH
74741: LD_EXP 94
74745: PPUSH
74746: LD_VAR 0 2
74750: PUSH
74751: LD_EXP 94
74755: PUSH
74756: LD_VAR 0 2
74760: ARRAY
74761: PUSH
74762: LD_INT 1
74764: PLUS
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: PPUSH
74770: LD_VAR 0 8
74774: PUSH
74775: LD_VAR 0 3
74779: ARRAY
74780: PPUSH
74781: CALL 20270 0 3
74785: ST_TO_ADDR
// end ;
74786: GO 74444
74788: POP
74789: POP
// MC_Reset ( i , 124 ) ;
74790: LD_VAR 0 2
74794: PPUSH
74795: LD_INT 124
74797: PPUSH
74798: CALL 58916 0 2
// end ; end ;
74802: GO 74199
74804: POP
74805: POP
// end ;
74806: LD_VAR 0 1
74810: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74811: LD_INT 0
74813: PPUSH
74814: PPUSH
74815: PPUSH
// if not mc_bases then
74816: LD_EXP 58
74820: NOT
74821: IFFALSE 74825
// exit ;
74823: GO 75431
// for i = 1 to mc_bases do
74825: LD_ADDR_VAR 0 2
74829: PUSH
74830: DOUBLE
74831: LD_INT 1
74833: DEC
74834: ST_TO_ADDR
74835: LD_EXP 58
74839: PUSH
74840: FOR_TO
74841: IFFALSE 75429
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74843: LD_ADDR_VAR 0 3
74847: PUSH
74848: LD_EXP 58
74852: PUSH
74853: LD_VAR 0 2
74857: ARRAY
74858: PPUSH
74859: LD_INT 25
74861: PUSH
74862: LD_INT 4
74864: PUSH
74865: EMPTY
74866: LIST
74867: LIST
74868: PPUSH
74869: CALL_OW 72
74873: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74874: LD_VAR 0 3
74878: NOT
74879: PUSH
74880: LD_EXP 95
74884: PUSH
74885: LD_VAR 0 2
74889: ARRAY
74890: NOT
74891: OR
74892: PUSH
74893: LD_EXP 58
74897: PUSH
74898: LD_VAR 0 2
74902: ARRAY
74903: PPUSH
74904: LD_INT 2
74906: PUSH
74907: LD_INT 30
74909: PUSH
74910: LD_INT 0
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 30
74919: PUSH
74920: LD_INT 1
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: EMPTY
74928: LIST
74929: LIST
74930: LIST
74931: PPUSH
74932: CALL_OW 72
74936: NOT
74937: OR
74938: IFFALSE 74988
// begin if mc_deposits_finder [ i ] then
74940: LD_EXP 96
74944: PUSH
74945: LD_VAR 0 2
74949: ARRAY
74950: IFFALSE 74986
// begin MC_Reset ( i , 125 ) ;
74952: LD_VAR 0 2
74956: PPUSH
74957: LD_INT 125
74959: PPUSH
74960: CALL 58916 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74964: LD_ADDR_EXP 96
74968: PUSH
74969: LD_EXP 96
74973: PPUSH
74974: LD_VAR 0 2
74978: PPUSH
74979: EMPTY
74980: PPUSH
74981: CALL_OW 1
74985: ST_TO_ADDR
// end ; continue ;
74986: GO 74840
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74988: LD_EXP 95
74992: PUSH
74993: LD_VAR 0 2
74997: ARRAY
74998: PUSH
74999: LD_INT 1
75001: ARRAY
75002: PUSH
75003: LD_INT 3
75005: ARRAY
75006: PUSH
75007: LD_INT 1
75009: EQUAL
75010: PUSH
75011: LD_INT 20
75013: PPUSH
75014: LD_EXP 84
75018: PUSH
75019: LD_VAR 0 2
75023: ARRAY
75024: PPUSH
75025: CALL_OW 321
75029: PUSH
75030: LD_INT 2
75032: NONEQUAL
75033: AND
75034: IFFALSE 75084
// begin if mc_deposits_finder [ i ] then
75036: LD_EXP 96
75040: PUSH
75041: LD_VAR 0 2
75045: ARRAY
75046: IFFALSE 75082
// begin MC_Reset ( i , 125 ) ;
75048: LD_VAR 0 2
75052: PPUSH
75053: LD_INT 125
75055: PPUSH
75056: CALL 58916 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75060: LD_ADDR_EXP 96
75064: PUSH
75065: LD_EXP 96
75069: PPUSH
75070: LD_VAR 0 2
75074: PPUSH
75075: EMPTY
75076: PPUSH
75077: CALL_OW 1
75081: ST_TO_ADDR
// end ; continue ;
75082: GO 74840
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75084: LD_EXP 95
75088: PUSH
75089: LD_VAR 0 2
75093: ARRAY
75094: PUSH
75095: LD_INT 1
75097: ARRAY
75098: PUSH
75099: LD_INT 1
75101: ARRAY
75102: PPUSH
75103: LD_EXP 95
75107: PUSH
75108: LD_VAR 0 2
75112: ARRAY
75113: PUSH
75114: LD_INT 1
75116: ARRAY
75117: PUSH
75118: LD_INT 2
75120: ARRAY
75121: PPUSH
75122: LD_EXP 84
75126: PUSH
75127: LD_VAR 0 2
75131: ARRAY
75132: PPUSH
75133: CALL_OW 440
75137: IFFALSE 75180
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75139: LD_ADDR_EXP 95
75143: PUSH
75144: LD_EXP 95
75148: PPUSH
75149: LD_VAR 0 2
75153: PPUSH
75154: LD_EXP 95
75158: PUSH
75159: LD_VAR 0 2
75163: ARRAY
75164: PPUSH
75165: LD_INT 1
75167: PPUSH
75168: CALL_OW 3
75172: PPUSH
75173: CALL_OW 1
75177: ST_TO_ADDR
75178: GO 75427
// begin if not mc_deposits_finder [ i ] then
75180: LD_EXP 96
75184: PUSH
75185: LD_VAR 0 2
75189: ARRAY
75190: NOT
75191: IFFALSE 75243
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75193: LD_ADDR_EXP 96
75197: PUSH
75198: LD_EXP 96
75202: PPUSH
75203: LD_VAR 0 2
75207: PPUSH
75208: LD_VAR 0 3
75212: PUSH
75213: LD_INT 1
75215: ARRAY
75216: PUSH
75217: EMPTY
75218: LIST
75219: PPUSH
75220: CALL_OW 1
75224: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75225: LD_VAR 0 3
75229: PUSH
75230: LD_INT 1
75232: ARRAY
75233: PPUSH
75234: LD_INT 125
75236: PPUSH
75237: CALL_OW 109
// end else
75241: GO 75427
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75243: LD_EXP 96
75247: PUSH
75248: LD_VAR 0 2
75252: ARRAY
75253: PUSH
75254: LD_INT 1
75256: ARRAY
75257: PPUSH
75258: CALL_OW 310
75262: IFFALSE 75285
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75264: LD_EXP 96
75268: PUSH
75269: LD_VAR 0 2
75273: ARRAY
75274: PUSH
75275: LD_INT 1
75277: ARRAY
75278: PPUSH
75279: CALL_OW 122
75283: GO 75427
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75285: LD_EXP 96
75289: PUSH
75290: LD_VAR 0 2
75294: ARRAY
75295: PUSH
75296: LD_INT 1
75298: ARRAY
75299: PPUSH
75300: CALL_OW 314
75304: NOT
75305: PUSH
75306: LD_EXP 96
75310: PUSH
75311: LD_VAR 0 2
75315: ARRAY
75316: PUSH
75317: LD_INT 1
75319: ARRAY
75320: PPUSH
75321: LD_EXP 95
75325: PUSH
75326: LD_VAR 0 2
75330: ARRAY
75331: PUSH
75332: LD_INT 1
75334: ARRAY
75335: PUSH
75336: LD_INT 1
75338: ARRAY
75339: PPUSH
75340: LD_EXP 95
75344: PUSH
75345: LD_VAR 0 2
75349: ARRAY
75350: PUSH
75351: LD_INT 1
75353: ARRAY
75354: PUSH
75355: LD_INT 2
75357: ARRAY
75358: PPUSH
75359: CALL_OW 297
75363: PUSH
75364: LD_INT 6
75366: GREATER
75367: AND
75368: IFFALSE 75427
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75370: LD_EXP 96
75374: PUSH
75375: LD_VAR 0 2
75379: ARRAY
75380: PUSH
75381: LD_INT 1
75383: ARRAY
75384: PPUSH
75385: LD_EXP 95
75389: PUSH
75390: LD_VAR 0 2
75394: ARRAY
75395: PUSH
75396: LD_INT 1
75398: ARRAY
75399: PUSH
75400: LD_INT 1
75402: ARRAY
75403: PPUSH
75404: LD_EXP 95
75408: PUSH
75409: LD_VAR 0 2
75413: ARRAY
75414: PUSH
75415: LD_INT 1
75417: ARRAY
75418: PUSH
75419: LD_INT 2
75421: ARRAY
75422: PPUSH
75423: CALL_OW 111
// end ; end ; end ;
75427: GO 74840
75429: POP
75430: POP
// end ;
75431: LD_VAR 0 1
75435: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75436: LD_INT 0
75438: PPUSH
75439: PPUSH
75440: PPUSH
75441: PPUSH
75442: PPUSH
75443: PPUSH
75444: PPUSH
75445: PPUSH
75446: PPUSH
75447: PPUSH
75448: PPUSH
// if not mc_bases then
75449: LD_EXP 58
75453: NOT
75454: IFFALSE 75458
// exit ;
75456: GO 76182
// for i = 1 to mc_bases do
75458: LD_ADDR_VAR 0 2
75462: PUSH
75463: DOUBLE
75464: LD_INT 1
75466: DEC
75467: ST_TO_ADDR
75468: LD_EXP 58
75472: PUSH
75473: FOR_TO
75474: IFFALSE 76180
// begin if not mc_bases [ i ] then
75476: LD_EXP 58
75480: PUSH
75481: LD_VAR 0 2
75485: ARRAY
75486: NOT
75487: IFFALSE 75491
// continue ;
75489: GO 75473
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75491: LD_ADDR_VAR 0 7
75495: PUSH
75496: LD_EXP 58
75500: PUSH
75501: LD_VAR 0 2
75505: ARRAY
75506: PUSH
75507: LD_INT 1
75509: ARRAY
75510: PPUSH
75511: CALL_OW 248
75515: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75516: LD_VAR 0 7
75520: PUSH
75521: LD_INT 3
75523: EQUAL
75524: PUSH
75525: LD_EXP 77
75529: PUSH
75530: LD_VAR 0 2
75534: ARRAY
75535: PUSH
75536: LD_EXP 80
75540: PUSH
75541: LD_VAR 0 2
75545: ARRAY
75546: UNION
75547: PPUSH
75548: LD_INT 33
75550: PUSH
75551: LD_INT 2
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PPUSH
75558: CALL_OW 72
75562: NOT
75563: OR
75564: IFFALSE 75568
// continue ;
75566: GO 75473
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75568: LD_ADDR_VAR 0 9
75572: PUSH
75573: LD_EXP 58
75577: PUSH
75578: LD_VAR 0 2
75582: ARRAY
75583: PPUSH
75584: LD_INT 30
75586: PUSH
75587: LD_INT 36
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PPUSH
75594: CALL_OW 72
75598: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75599: LD_ADDR_VAR 0 10
75603: PUSH
75604: LD_EXP 77
75608: PUSH
75609: LD_VAR 0 2
75613: ARRAY
75614: PPUSH
75615: LD_INT 34
75617: PUSH
75618: LD_INT 31
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: PPUSH
75625: CALL_OW 72
75629: ST_TO_ADDR
// if not cts and not mcts then
75630: LD_VAR 0 9
75634: NOT
75635: PUSH
75636: LD_VAR 0 10
75640: NOT
75641: AND
75642: IFFALSE 75646
// continue ;
75644: GO 75473
// x := cts ;
75646: LD_ADDR_VAR 0 11
75650: PUSH
75651: LD_VAR 0 9
75655: ST_TO_ADDR
// if not x then
75656: LD_VAR 0 11
75660: NOT
75661: IFFALSE 75673
// x := mcts ;
75663: LD_ADDR_VAR 0 11
75667: PUSH
75668: LD_VAR 0 10
75672: ST_TO_ADDR
// if mc_remote_driver [ i ] then
75673: LD_EXP 98
75677: PUSH
75678: LD_VAR 0 2
75682: ARRAY
75683: IFFALSE 75952
// for j in mc_remote_driver [ i ] do
75685: LD_ADDR_VAR 0 3
75689: PUSH
75690: LD_EXP 98
75694: PUSH
75695: LD_VAR 0 2
75699: ARRAY
75700: PUSH
75701: FOR_IN
75702: IFFALSE 75950
// begin if GetClass ( j ) <> 3 then
75704: LD_VAR 0 3
75708: PPUSH
75709: CALL_OW 257
75713: PUSH
75714: LD_INT 3
75716: NONEQUAL
75717: IFFALSE 75770
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75719: LD_ADDR_EXP 98
75723: PUSH
75724: LD_EXP 98
75728: PPUSH
75729: LD_VAR 0 2
75733: PPUSH
75734: LD_EXP 98
75738: PUSH
75739: LD_VAR 0 2
75743: ARRAY
75744: PUSH
75745: LD_VAR 0 3
75749: DIFF
75750: PPUSH
75751: CALL_OW 1
75755: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75756: LD_VAR 0 3
75760: PPUSH
75761: LD_INT 0
75763: PPUSH
75764: CALL_OW 109
// continue ;
75768: GO 75701
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75770: LD_VAR 0 3
75774: PPUSH
75775: CALL_OW 310
75779: NOT
75780: PUSH
75781: LD_VAR 0 3
75785: PPUSH
75786: CALL_OW 310
75790: PPUSH
75791: CALL_OW 266
75795: PUSH
75796: LD_INT 36
75798: NONEQUAL
75799: PUSH
75800: LD_VAR 0 3
75804: PPUSH
75805: CALL 53555 0 1
75809: NOT
75810: AND
75811: OR
75812: IFFALSE 75948
// begin if IsInUnit ( j ) then
75814: LD_VAR 0 3
75818: PPUSH
75819: CALL_OW 310
75823: IFFALSE 75834
// ComExitBuilding ( j ) ;
75825: LD_VAR 0 3
75829: PPUSH
75830: CALL_OW 122
// ct := 0 ;
75834: LD_ADDR_VAR 0 8
75838: PUSH
75839: LD_INT 0
75841: ST_TO_ADDR
// for k in x do
75842: LD_ADDR_VAR 0 4
75846: PUSH
75847: LD_VAR 0 11
75851: PUSH
75852: FOR_IN
75853: IFFALSE 75926
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75855: LD_VAR 0 4
75859: PPUSH
75860: CALL_OW 264
75864: PUSH
75865: LD_INT 31
75867: EQUAL
75868: PUSH
75869: LD_VAR 0 4
75873: PPUSH
75874: CALL_OW 311
75878: NOT
75879: AND
75880: PUSH
75881: LD_VAR 0 4
75885: PPUSH
75886: CALL_OW 266
75890: PUSH
75891: LD_INT 36
75893: EQUAL
75894: PUSH
75895: LD_VAR 0 4
75899: PPUSH
75900: CALL_OW 313
75904: PUSH
75905: LD_INT 3
75907: LESS
75908: AND
75909: OR
75910: IFFALSE 75924
// begin ct := k ;
75912: LD_ADDR_VAR 0 8
75916: PUSH
75917: LD_VAR 0 4
75921: ST_TO_ADDR
// break ;
75922: GO 75926
// end ;
75924: GO 75852
75926: POP
75927: POP
// if ct then
75928: LD_VAR 0 8
75932: IFFALSE 75948
// ComEnterUnit ( j , ct ) ;
75934: LD_VAR 0 3
75938: PPUSH
75939: LD_VAR 0 8
75943: PPUSH
75944: CALL_OW 120
// end ; end ;
75948: GO 75701
75950: POP
75951: POP
// places := 0 ;
75952: LD_ADDR_VAR 0 5
75956: PUSH
75957: LD_INT 0
75959: ST_TO_ADDR
// for j = 1 to x do
75960: LD_ADDR_VAR 0 3
75964: PUSH
75965: DOUBLE
75966: LD_INT 1
75968: DEC
75969: ST_TO_ADDR
75970: LD_VAR 0 11
75974: PUSH
75975: FOR_TO
75976: IFFALSE 76031
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75978: LD_VAR 0 11
75982: PUSH
75983: LD_VAR 0 3
75987: ARRAY
75988: PPUSH
75989: CALL_OW 264
75993: PUSH
75994: LD_INT 31
75996: EQUAL
75997: IFFALSE 76015
// places := places + 1 else
75999: LD_ADDR_VAR 0 5
76003: PUSH
76004: LD_VAR 0 5
76008: PUSH
76009: LD_INT 1
76011: PLUS
76012: ST_TO_ADDR
76013: GO 76029
// places := places + 3 ;
76015: LD_ADDR_VAR 0 5
76019: PUSH
76020: LD_VAR 0 5
76024: PUSH
76025: LD_INT 3
76027: PLUS
76028: ST_TO_ADDR
76029: GO 75975
76031: POP
76032: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76033: LD_ADDR_VAR 0 6
76037: PUSH
76038: LD_EXP 58
76042: PUSH
76043: LD_VAR 0 2
76047: ARRAY
76048: PPUSH
76049: LD_INT 25
76051: PUSH
76052: LD_INT 3
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PPUSH
76059: CALL_OW 72
76063: PUSH
76064: LD_EXP 98
76068: PUSH
76069: LD_VAR 0 2
76073: ARRAY
76074: DIFF
76075: PPUSH
76076: LD_INT 3
76078: PPUSH
76079: CALL 54455 0 2
76083: ST_TO_ADDR
// if not tmp then
76084: LD_VAR 0 6
76088: NOT
76089: IFFALSE 76093
// continue ;
76091: GO 75473
// places := places - mc_remote_driver [ i ] ;
76093: LD_ADDR_VAR 0 5
76097: PUSH
76098: LD_VAR 0 5
76102: PUSH
76103: LD_EXP 98
76107: PUSH
76108: LD_VAR 0 2
76112: ARRAY
76113: MINUS
76114: ST_TO_ADDR
// if places then
76115: LD_VAR 0 5
76119: IFFALSE 76178
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76121: LD_ADDR_EXP 98
76125: PUSH
76126: LD_EXP 98
76130: PPUSH
76131: LD_VAR 0 2
76135: PPUSH
76136: LD_EXP 98
76140: PUSH
76141: LD_VAR 0 2
76145: ARRAY
76146: PUSH
76147: LD_VAR 0 6
76151: PUSH
76152: LD_INT 1
76154: ARRAY
76155: UNION
76156: PPUSH
76157: CALL_OW 1
76161: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76162: LD_VAR 0 6
76166: PUSH
76167: LD_INT 1
76169: ARRAY
76170: PPUSH
76171: LD_INT 126
76173: PPUSH
76174: CALL_OW 109
// end ; end ;
76178: GO 75473
76180: POP
76181: POP
// end ;
76182: LD_VAR 0 1
76186: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76187: LD_INT 0
76189: PPUSH
76190: PPUSH
76191: PPUSH
76192: PPUSH
76193: PPUSH
76194: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76195: LD_VAR 0 1
76199: NOT
76200: PUSH
76201: LD_VAR 0 2
76205: NOT
76206: OR
76207: PUSH
76208: LD_VAR 0 3
76212: NOT
76213: OR
76214: PUSH
76215: LD_VAR 0 4
76219: PUSH
76220: LD_INT 1
76222: PUSH
76223: LD_INT 2
76225: PUSH
76226: LD_INT 3
76228: PUSH
76229: LD_INT 4
76231: PUSH
76232: LD_INT 5
76234: PUSH
76235: LD_INT 8
76237: PUSH
76238: LD_INT 9
76240: PUSH
76241: LD_INT 15
76243: PUSH
76244: LD_INT 16
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: LIST
76251: LIST
76252: LIST
76253: LIST
76254: LIST
76255: LIST
76256: LIST
76257: IN
76258: NOT
76259: OR
76260: IFFALSE 76264
// exit ;
76262: GO 77164
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76264: LD_ADDR_VAR 0 2
76268: PUSH
76269: LD_VAR 0 2
76273: PPUSH
76274: LD_INT 21
76276: PUSH
76277: LD_INT 3
76279: PUSH
76280: EMPTY
76281: LIST
76282: LIST
76283: PUSH
76284: LD_INT 24
76286: PUSH
76287: LD_INT 250
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PPUSH
76298: CALL_OW 72
76302: ST_TO_ADDR
// case class of 1 , 15 :
76303: LD_VAR 0 4
76307: PUSH
76308: LD_INT 1
76310: DOUBLE
76311: EQUAL
76312: IFTRUE 76322
76314: LD_INT 15
76316: DOUBLE
76317: EQUAL
76318: IFTRUE 76322
76320: GO 76407
76322: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76323: LD_ADDR_VAR 0 8
76327: PUSH
76328: LD_VAR 0 2
76332: PPUSH
76333: LD_INT 2
76335: PUSH
76336: LD_INT 30
76338: PUSH
76339: LD_INT 32
76341: PUSH
76342: EMPTY
76343: LIST
76344: LIST
76345: PUSH
76346: LD_INT 30
76348: PUSH
76349: LD_INT 31
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: LIST
76360: PPUSH
76361: CALL_OW 72
76365: PUSH
76366: LD_VAR 0 2
76370: PPUSH
76371: LD_INT 2
76373: PUSH
76374: LD_INT 30
76376: PUSH
76377: LD_INT 4
76379: PUSH
76380: EMPTY
76381: LIST
76382: LIST
76383: PUSH
76384: LD_INT 30
76386: PUSH
76387: LD_INT 5
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: PUSH
76394: EMPTY
76395: LIST
76396: LIST
76397: LIST
76398: PPUSH
76399: CALL_OW 72
76403: ADD
76404: ST_TO_ADDR
76405: GO 76653
76407: LD_INT 2
76409: DOUBLE
76410: EQUAL
76411: IFTRUE 76421
76413: LD_INT 16
76415: DOUBLE
76416: EQUAL
76417: IFTRUE 76421
76419: GO 76467
76421: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76422: LD_ADDR_VAR 0 8
76426: PUSH
76427: LD_VAR 0 2
76431: PPUSH
76432: LD_INT 2
76434: PUSH
76435: LD_INT 30
76437: PUSH
76438: LD_INT 0
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PUSH
76445: LD_INT 30
76447: PUSH
76448: LD_INT 1
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: PUSH
76455: EMPTY
76456: LIST
76457: LIST
76458: LIST
76459: PPUSH
76460: CALL_OW 72
76464: ST_TO_ADDR
76465: GO 76653
76467: LD_INT 3
76469: DOUBLE
76470: EQUAL
76471: IFTRUE 76475
76473: GO 76521
76475: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76476: LD_ADDR_VAR 0 8
76480: PUSH
76481: LD_VAR 0 2
76485: PPUSH
76486: LD_INT 2
76488: PUSH
76489: LD_INT 30
76491: PUSH
76492: LD_INT 2
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PUSH
76499: LD_INT 30
76501: PUSH
76502: LD_INT 3
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: EMPTY
76510: LIST
76511: LIST
76512: LIST
76513: PPUSH
76514: CALL_OW 72
76518: ST_TO_ADDR
76519: GO 76653
76521: LD_INT 4
76523: DOUBLE
76524: EQUAL
76525: IFTRUE 76529
76527: GO 76586
76529: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76530: LD_ADDR_VAR 0 8
76534: PUSH
76535: LD_VAR 0 2
76539: PPUSH
76540: LD_INT 2
76542: PUSH
76543: LD_INT 30
76545: PUSH
76546: LD_INT 6
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 30
76555: PUSH
76556: LD_INT 7
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 30
76565: PUSH
76566: LD_INT 8
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: LIST
76577: LIST
76578: PPUSH
76579: CALL_OW 72
76583: ST_TO_ADDR
76584: GO 76653
76586: LD_INT 5
76588: DOUBLE
76589: EQUAL
76590: IFTRUE 76606
76592: LD_INT 8
76594: DOUBLE
76595: EQUAL
76596: IFTRUE 76606
76598: LD_INT 9
76600: DOUBLE
76601: EQUAL
76602: IFTRUE 76606
76604: GO 76652
76606: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76607: LD_ADDR_VAR 0 8
76611: PUSH
76612: LD_VAR 0 2
76616: PPUSH
76617: LD_INT 2
76619: PUSH
76620: LD_INT 30
76622: PUSH
76623: LD_INT 4
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: LD_INT 30
76632: PUSH
76633: LD_INT 5
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: LIST
76644: PPUSH
76645: CALL_OW 72
76649: ST_TO_ADDR
76650: GO 76653
76652: POP
// if not tmp then
76653: LD_VAR 0 8
76657: NOT
76658: IFFALSE 76662
// exit ;
76660: GO 77164
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76662: LD_VAR 0 4
76666: PUSH
76667: LD_INT 1
76669: PUSH
76670: LD_INT 15
76672: PUSH
76673: EMPTY
76674: LIST
76675: LIST
76676: IN
76677: PUSH
76678: LD_EXP 67
76682: PUSH
76683: LD_VAR 0 1
76687: ARRAY
76688: AND
76689: IFFALSE 76845
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76691: LD_ADDR_VAR 0 9
76695: PUSH
76696: LD_EXP 67
76700: PUSH
76701: LD_VAR 0 1
76705: ARRAY
76706: PUSH
76707: LD_INT 1
76709: ARRAY
76710: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76711: LD_VAR 0 9
76715: PUSH
76716: LD_EXP 68
76720: PUSH
76721: LD_VAR 0 1
76725: ARRAY
76726: IN
76727: NOT
76728: IFFALSE 76843
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76730: LD_ADDR_EXP 68
76734: PUSH
76735: LD_EXP 68
76739: PPUSH
76740: LD_VAR 0 1
76744: PUSH
76745: LD_EXP 68
76749: PUSH
76750: LD_VAR 0 1
76754: ARRAY
76755: PUSH
76756: LD_INT 1
76758: PLUS
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: PPUSH
76764: LD_VAR 0 9
76768: PPUSH
76769: CALL 20270 0 3
76773: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76774: LD_ADDR_EXP 67
76778: PUSH
76779: LD_EXP 67
76783: PPUSH
76784: LD_VAR 0 1
76788: PPUSH
76789: LD_EXP 67
76793: PUSH
76794: LD_VAR 0 1
76798: ARRAY
76799: PUSH
76800: LD_VAR 0 9
76804: DIFF
76805: PPUSH
76806: CALL_OW 1
76810: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76811: LD_VAR 0 3
76815: PPUSH
76816: LD_EXP 68
76820: PUSH
76821: LD_VAR 0 1
76825: ARRAY
76826: PUSH
76827: LD_EXP 68
76831: PUSH
76832: LD_VAR 0 1
76836: ARRAY
76837: ARRAY
76838: PPUSH
76839: CALL_OW 120
// end ; exit ;
76843: GO 77164
// end ; if tmp > 1 then
76845: LD_VAR 0 8
76849: PUSH
76850: LD_INT 1
76852: GREATER
76853: IFFALSE 76957
// for i = 2 to tmp do
76855: LD_ADDR_VAR 0 6
76859: PUSH
76860: DOUBLE
76861: LD_INT 2
76863: DEC
76864: ST_TO_ADDR
76865: LD_VAR 0 8
76869: PUSH
76870: FOR_TO
76871: IFFALSE 76955
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76873: LD_VAR 0 8
76877: PUSH
76878: LD_VAR 0 6
76882: ARRAY
76883: PPUSH
76884: CALL_OW 461
76888: PUSH
76889: LD_INT 6
76891: EQUAL
76892: IFFALSE 76953
// begin x := tmp [ i ] ;
76894: LD_ADDR_VAR 0 9
76898: PUSH
76899: LD_VAR 0 8
76903: PUSH
76904: LD_VAR 0 6
76908: ARRAY
76909: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76910: LD_ADDR_VAR 0 8
76914: PUSH
76915: LD_VAR 0 8
76919: PPUSH
76920: LD_VAR 0 6
76924: PPUSH
76925: CALL_OW 3
76929: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76930: LD_ADDR_VAR 0 8
76934: PUSH
76935: LD_VAR 0 8
76939: PPUSH
76940: LD_INT 1
76942: PPUSH
76943: LD_VAR 0 9
76947: PPUSH
76948: CALL_OW 2
76952: ST_TO_ADDR
// end ;
76953: GO 76870
76955: POP
76956: POP
// for i in tmp do
76957: LD_ADDR_VAR 0 6
76961: PUSH
76962: LD_VAR 0 8
76966: PUSH
76967: FOR_IN
76968: IFFALSE 77037
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76970: LD_VAR 0 6
76974: PPUSH
76975: CALL_OW 313
76979: PUSH
76980: LD_INT 6
76982: LESS
76983: PUSH
76984: LD_VAR 0 6
76988: PPUSH
76989: CALL_OW 266
76993: PUSH
76994: LD_INT 31
76996: PUSH
76997: LD_INT 32
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: IN
77004: NOT
77005: AND
77006: PUSH
77007: LD_VAR 0 6
77011: PPUSH
77012: CALL_OW 313
77016: PUSH
77017: LD_INT 0
77019: EQUAL
77020: OR
77021: IFFALSE 77035
// begin j := i ;
77023: LD_ADDR_VAR 0 7
77027: PUSH
77028: LD_VAR 0 6
77032: ST_TO_ADDR
// break ;
77033: GO 77037
// end ; end ;
77035: GO 76967
77037: POP
77038: POP
// if j then
77039: LD_VAR 0 7
77043: IFFALSE 77061
// ComEnterUnit ( unit , j ) else
77045: LD_VAR 0 3
77049: PPUSH
77050: LD_VAR 0 7
77054: PPUSH
77055: CALL_OW 120
77059: GO 77164
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77061: LD_ADDR_VAR 0 10
77065: PUSH
77066: LD_VAR 0 2
77070: PPUSH
77071: LD_INT 2
77073: PUSH
77074: LD_INT 30
77076: PUSH
77077: LD_INT 0
77079: PUSH
77080: EMPTY
77081: LIST
77082: LIST
77083: PUSH
77084: LD_INT 30
77086: PUSH
77087: LD_INT 1
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: LIST
77098: PPUSH
77099: CALL_OW 72
77103: ST_TO_ADDR
// if depot then
77104: LD_VAR 0 10
77108: IFFALSE 77164
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77110: LD_ADDR_VAR 0 10
77114: PUSH
77115: LD_VAR 0 10
77119: PPUSH
77120: LD_VAR 0 3
77124: PPUSH
77125: CALL_OW 74
77129: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77130: LD_VAR 0 3
77134: PPUSH
77135: LD_VAR 0 10
77139: PPUSH
77140: CALL_OW 296
77144: PUSH
77145: LD_INT 10
77147: GREATER
77148: IFFALSE 77164
// ComStandNearbyBuilding ( unit , depot ) ;
77150: LD_VAR 0 3
77154: PPUSH
77155: LD_VAR 0 10
77159: PPUSH
77160: CALL 14947 0 2
// end ; end ; end ;
77164: LD_VAR 0 5
77168: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77169: LD_INT 0
77171: PPUSH
77172: PPUSH
77173: PPUSH
77174: PPUSH
// if not mc_bases then
77175: LD_EXP 58
77179: NOT
77180: IFFALSE 77184
// exit ;
77182: GO 77423
// for i = 1 to mc_bases do
77184: LD_ADDR_VAR 0 2
77188: PUSH
77189: DOUBLE
77190: LD_INT 1
77192: DEC
77193: ST_TO_ADDR
77194: LD_EXP 58
77198: PUSH
77199: FOR_TO
77200: IFFALSE 77421
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77202: LD_ADDR_VAR 0 4
77206: PUSH
77207: LD_EXP 58
77211: PUSH
77212: LD_VAR 0 2
77216: ARRAY
77217: PPUSH
77218: LD_INT 21
77220: PUSH
77221: LD_INT 1
77223: PUSH
77224: EMPTY
77225: LIST
77226: LIST
77227: PPUSH
77228: CALL_OW 72
77232: PUSH
77233: LD_EXP 87
77237: PUSH
77238: LD_VAR 0 2
77242: ARRAY
77243: UNION
77244: ST_TO_ADDR
// if not tmp then
77245: LD_VAR 0 4
77249: NOT
77250: IFFALSE 77254
// continue ;
77252: GO 77199
// for j in tmp do
77254: LD_ADDR_VAR 0 3
77258: PUSH
77259: LD_VAR 0 4
77263: PUSH
77264: FOR_IN
77265: IFFALSE 77417
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77267: LD_VAR 0 3
77271: PPUSH
77272: CALL_OW 110
77276: NOT
77277: PUSH
77278: LD_VAR 0 3
77282: PPUSH
77283: CALL_OW 314
77287: NOT
77288: AND
77289: PUSH
77290: LD_VAR 0 3
77294: PPUSH
77295: CALL_OW 311
77299: NOT
77300: AND
77301: PUSH
77302: LD_VAR 0 3
77306: PPUSH
77307: CALL_OW 310
77311: NOT
77312: AND
77313: PUSH
77314: LD_VAR 0 3
77318: PUSH
77319: LD_EXP 61
77323: PUSH
77324: LD_VAR 0 2
77328: ARRAY
77329: PUSH
77330: LD_INT 1
77332: ARRAY
77333: IN
77334: NOT
77335: AND
77336: PUSH
77337: LD_VAR 0 3
77341: PUSH
77342: LD_EXP 61
77346: PUSH
77347: LD_VAR 0 2
77351: ARRAY
77352: PUSH
77353: LD_INT 2
77355: ARRAY
77356: IN
77357: NOT
77358: AND
77359: PUSH
77360: LD_VAR 0 3
77364: PUSH
77365: LD_EXP 70
77369: PUSH
77370: LD_VAR 0 2
77374: ARRAY
77375: IN
77376: NOT
77377: AND
77378: IFFALSE 77415
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77380: LD_VAR 0 2
77384: PPUSH
77385: LD_EXP 58
77389: PUSH
77390: LD_VAR 0 2
77394: ARRAY
77395: PPUSH
77396: LD_VAR 0 3
77400: PPUSH
77401: LD_VAR 0 3
77405: PPUSH
77406: CALL_OW 257
77410: PPUSH
77411: CALL 76187 0 4
// end ;
77415: GO 77264
77417: POP
77418: POP
// end ;
77419: GO 77199
77421: POP
77422: POP
// end ;
77423: LD_VAR 0 1
77427: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77428: LD_INT 0
77430: PPUSH
77431: PPUSH
77432: PPUSH
77433: PPUSH
77434: PPUSH
77435: PPUSH
// if not mc_bases [ base ] then
77436: LD_EXP 58
77440: PUSH
77441: LD_VAR 0 1
77445: ARRAY
77446: NOT
77447: IFFALSE 77451
// exit ;
77449: GO 77633
// tmp := [ ] ;
77451: LD_ADDR_VAR 0 6
77455: PUSH
77456: EMPTY
77457: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77458: LD_ADDR_VAR 0 7
77462: PUSH
77463: LD_VAR 0 3
77467: PPUSH
77468: LD_INT 0
77470: PPUSH
77471: CALL_OW 517
77475: ST_TO_ADDR
// if not list then
77476: LD_VAR 0 7
77480: NOT
77481: IFFALSE 77485
// exit ;
77483: GO 77633
// for i = 1 to amount do
77485: LD_ADDR_VAR 0 5
77489: PUSH
77490: DOUBLE
77491: LD_INT 1
77493: DEC
77494: ST_TO_ADDR
77495: LD_VAR 0 2
77499: PUSH
77500: FOR_TO
77501: IFFALSE 77581
// begin x := rand ( 1 , list [ 1 ] ) ;
77503: LD_ADDR_VAR 0 8
77507: PUSH
77508: LD_INT 1
77510: PPUSH
77511: LD_VAR 0 7
77515: PUSH
77516: LD_INT 1
77518: ARRAY
77519: PPUSH
77520: CALL_OW 12
77524: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77525: LD_ADDR_VAR 0 6
77529: PUSH
77530: LD_VAR 0 6
77534: PPUSH
77535: LD_VAR 0 5
77539: PPUSH
77540: LD_VAR 0 7
77544: PUSH
77545: LD_INT 1
77547: ARRAY
77548: PUSH
77549: LD_VAR 0 8
77553: ARRAY
77554: PUSH
77555: LD_VAR 0 7
77559: PUSH
77560: LD_INT 2
77562: ARRAY
77563: PUSH
77564: LD_VAR 0 8
77568: ARRAY
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PPUSH
77574: CALL_OW 1
77578: ST_TO_ADDR
// end ;
77579: GO 77500
77581: POP
77582: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77583: LD_ADDR_EXP 71
77587: PUSH
77588: LD_EXP 71
77592: PPUSH
77593: LD_VAR 0 1
77597: PPUSH
77598: LD_VAR 0 6
77602: PPUSH
77603: CALL_OW 1
77607: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77608: LD_ADDR_EXP 73
77612: PUSH
77613: LD_EXP 73
77617: PPUSH
77618: LD_VAR 0 1
77622: PPUSH
77623: LD_VAR 0 3
77627: PPUSH
77628: CALL_OW 1
77632: ST_TO_ADDR
// end ;
77633: LD_VAR 0 4
77637: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77638: LD_INT 0
77640: PPUSH
// if not mc_bases [ base ] then
77641: LD_EXP 58
77645: PUSH
77646: LD_VAR 0 1
77650: ARRAY
77651: NOT
77652: IFFALSE 77656
// exit ;
77654: GO 77681
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77656: LD_ADDR_EXP 63
77660: PUSH
77661: LD_EXP 63
77665: PPUSH
77666: LD_VAR 0 1
77670: PPUSH
77671: LD_VAR 0 2
77675: PPUSH
77676: CALL_OW 1
77680: ST_TO_ADDR
// end ;
77681: LD_VAR 0 3
77685: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77686: LD_INT 0
77688: PPUSH
// if not mc_bases [ base ] then
77689: LD_EXP 58
77693: PUSH
77694: LD_VAR 0 1
77698: ARRAY
77699: NOT
77700: IFFALSE 77704
// exit ;
77702: GO 77741
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77704: LD_ADDR_EXP 63
77708: PUSH
77709: LD_EXP 63
77713: PPUSH
77714: LD_VAR 0 1
77718: PPUSH
77719: LD_EXP 63
77723: PUSH
77724: LD_VAR 0 1
77728: ARRAY
77729: PUSH
77730: LD_VAR 0 2
77734: UNION
77735: PPUSH
77736: CALL_OW 1
77740: ST_TO_ADDR
// end ;
77741: LD_VAR 0 3
77745: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77746: LD_INT 0
77748: PPUSH
// if not mc_bases [ base ] then
77749: LD_EXP 58
77753: PUSH
77754: LD_VAR 0 1
77758: ARRAY
77759: NOT
77760: IFFALSE 77764
// exit ;
77762: GO 77789
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77764: LD_ADDR_EXP 79
77768: PUSH
77769: LD_EXP 79
77773: PPUSH
77774: LD_VAR 0 1
77778: PPUSH
77779: LD_VAR 0 2
77783: PPUSH
77784: CALL_OW 1
77788: ST_TO_ADDR
// end ;
77789: LD_VAR 0 3
77793: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
77794: LD_INT 0
77796: PPUSH
// if not mc_bases [ base ] then
77797: LD_EXP 58
77801: PUSH
77802: LD_VAR 0 1
77806: ARRAY
77807: NOT
77808: IFFALSE 77812
// exit ;
77810: GO 77849
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
77812: LD_ADDR_EXP 79
77816: PUSH
77817: LD_EXP 79
77821: PPUSH
77822: LD_VAR 0 1
77826: PPUSH
77827: LD_EXP 79
77831: PUSH
77832: LD_VAR 0 1
77836: ARRAY
77837: PUSH
77838: LD_VAR 0 2
77842: UNION
77843: PPUSH
77844: CALL_OW 1
77848: ST_TO_ADDR
// end ;
77849: LD_VAR 0 3
77853: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77854: LD_INT 0
77856: PPUSH
// if not mc_bases [ base ] then
77857: LD_EXP 58
77861: PUSH
77862: LD_VAR 0 1
77866: ARRAY
77867: NOT
77868: IFFALSE 77872
// exit ;
77870: GO 77984
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77872: LD_ADDR_EXP 80
77876: PUSH
77877: LD_EXP 80
77881: PPUSH
77882: LD_VAR 0 1
77886: PPUSH
77887: LD_VAR 0 2
77891: PPUSH
77892: CALL_OW 1
77896: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77897: LD_ADDR_EXP 69
77901: PUSH
77902: LD_EXP 69
77906: PPUSH
77907: LD_VAR 0 1
77911: PPUSH
77912: LD_VAR 0 2
77916: PUSH
77917: LD_INT 0
77919: PLUS
77920: PPUSH
77921: CALL_OW 1
77925: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
77926: LD_ADDR_EXP 77
77930: PUSH
77931: LD_EXP 77
77935: PPUSH
77936: LD_VAR 0 1
77940: PPUSH
77941: LD_EXP 77
77945: PUSH
77946: LD_VAR 0 1
77950: ARRAY
77951: PUSH
77952: LD_EXP 80
77956: PUSH
77957: LD_VAR 0 1
77961: ARRAY
77962: PPUSH
77963: LD_INT 21
77965: PUSH
77966: LD_INT 2
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PPUSH
77973: CALL_OW 72
77977: UNION
77978: PPUSH
77979: CALL_OW 1
77983: ST_TO_ADDR
// end ;
77984: LD_VAR 0 3
77988: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77989: LD_INT 0
77991: PPUSH
// if not mc_bases [ base ] then
77992: LD_EXP 58
77996: PUSH
77997: LD_VAR 0 1
78001: ARRAY
78002: NOT
78003: IFFALSE 78007
// exit ;
78005: GO 78032
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78007: LD_ADDR_EXP 69
78011: PUSH
78012: LD_EXP 69
78016: PPUSH
78017: LD_VAR 0 1
78021: PPUSH
78022: LD_VAR 0 2
78026: PPUSH
78027: CALL_OW 1
78031: ST_TO_ADDR
// end ;
78032: LD_VAR 0 3
78036: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78037: LD_INT 0
78039: PPUSH
78040: PPUSH
78041: PPUSH
78042: PPUSH
// if not mc_bases [ base ] then
78043: LD_EXP 58
78047: PUSH
78048: LD_VAR 0 1
78052: ARRAY
78053: NOT
78054: IFFALSE 78058
// exit ;
78056: GO 78123
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78058: LD_ADDR_EXP 78
78062: PUSH
78063: LD_EXP 78
78067: PPUSH
78068: LD_VAR 0 1
78072: PUSH
78073: LD_EXP 78
78077: PUSH
78078: LD_VAR 0 1
78082: ARRAY
78083: PUSH
78084: LD_INT 1
78086: PLUS
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PPUSH
78092: LD_VAR 0 1
78096: PUSH
78097: LD_VAR 0 2
78101: PUSH
78102: LD_VAR 0 3
78106: PUSH
78107: LD_VAR 0 4
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: LIST
78116: LIST
78117: PPUSH
78118: CALL 20270 0 3
78122: ST_TO_ADDR
// end ;
78123: LD_VAR 0 5
78127: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78128: LD_INT 0
78130: PPUSH
// if not mc_bases [ base ] then
78131: LD_EXP 58
78135: PUSH
78136: LD_VAR 0 1
78140: ARRAY
78141: NOT
78142: IFFALSE 78146
// exit ;
78144: GO 78171
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78146: LD_ADDR_EXP 95
78150: PUSH
78151: LD_EXP 95
78155: PPUSH
78156: LD_VAR 0 1
78160: PPUSH
78161: LD_VAR 0 2
78165: PPUSH
78166: CALL_OW 1
78170: ST_TO_ADDR
// end ;
78171: LD_VAR 0 3
78175: RET
// export function MC_GetMinesField ( base ) ; begin
78176: LD_INT 0
78178: PPUSH
// result := mc_mines [ base ] ;
78179: LD_ADDR_VAR 0 2
78183: PUSH
78184: LD_EXP 71
78188: PUSH
78189: LD_VAR 0 1
78193: ARRAY
78194: ST_TO_ADDR
// end ;
78195: LD_VAR 0 2
78199: RET
// export function MC_GetProduceList ( base ) ; begin
78200: LD_INT 0
78202: PPUSH
// result := mc_produce [ base ] ;
78203: LD_ADDR_VAR 0 2
78207: PUSH
78208: LD_EXP 79
78212: PUSH
78213: LD_VAR 0 1
78217: ARRAY
78218: ST_TO_ADDR
// end ;
78219: LD_VAR 0 2
78223: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78224: LD_INT 0
78226: PPUSH
78227: PPUSH
// if not mc_bases then
78228: LD_EXP 58
78232: NOT
78233: IFFALSE 78237
// exit ;
78235: GO 78302
// if mc_bases [ base ] then
78237: LD_EXP 58
78241: PUSH
78242: LD_VAR 0 1
78246: ARRAY
78247: IFFALSE 78302
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78249: LD_ADDR_VAR 0 3
78253: PUSH
78254: LD_EXP 58
78258: PUSH
78259: LD_VAR 0 1
78263: ARRAY
78264: PPUSH
78265: LD_INT 30
78267: PUSH
78268: LD_VAR 0 2
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PPUSH
78277: CALL_OW 72
78281: ST_TO_ADDR
// if result then
78282: LD_VAR 0 3
78286: IFFALSE 78302
// result := result [ 1 ] ;
78288: LD_ADDR_VAR 0 3
78292: PUSH
78293: LD_VAR 0 3
78297: PUSH
78298: LD_INT 1
78300: ARRAY
78301: ST_TO_ADDR
// end ; end ;
78302: LD_VAR 0 3
78306: RET
// export function MC_SetTame ( base , area ) ; begin
78307: LD_INT 0
78309: PPUSH
// if not mc_bases or not base then
78310: LD_EXP 58
78314: NOT
78315: PUSH
78316: LD_VAR 0 1
78320: NOT
78321: OR
78322: IFFALSE 78326
// exit ;
78324: GO 78351
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78326: LD_ADDR_EXP 86
78330: PUSH
78331: LD_EXP 86
78335: PPUSH
78336: LD_VAR 0 1
78340: PPUSH
78341: LD_VAR 0 2
78345: PPUSH
78346: CALL_OW 1
78350: ST_TO_ADDR
// end ;
78351: LD_VAR 0 3
78355: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78356: LD_INT 0
78358: PPUSH
78359: PPUSH
// if not mc_bases or not base then
78360: LD_EXP 58
78364: NOT
78365: PUSH
78366: LD_VAR 0 1
78370: NOT
78371: OR
78372: IFFALSE 78376
// exit ;
78374: GO 78478
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78376: LD_ADDR_VAR 0 4
78380: PUSH
78381: LD_EXP 58
78385: PUSH
78386: LD_VAR 0 1
78390: ARRAY
78391: PPUSH
78392: LD_INT 30
78394: PUSH
78395: LD_VAR 0 2
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: PPUSH
78404: CALL_OW 72
78408: ST_TO_ADDR
// if not tmp then
78409: LD_VAR 0 4
78413: NOT
78414: IFFALSE 78418
// exit ;
78416: GO 78478
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78418: LD_ADDR_EXP 90
78422: PUSH
78423: LD_EXP 90
78427: PPUSH
78428: LD_VAR 0 1
78432: PPUSH
78433: LD_EXP 90
78437: PUSH
78438: LD_VAR 0 1
78442: ARRAY
78443: PPUSH
78444: LD_EXP 90
78448: PUSH
78449: LD_VAR 0 1
78453: ARRAY
78454: PUSH
78455: LD_INT 1
78457: PLUS
78458: PPUSH
78459: LD_VAR 0 4
78463: PUSH
78464: LD_INT 1
78466: ARRAY
78467: PPUSH
78468: CALL_OW 2
78472: PPUSH
78473: CALL_OW 1
78477: ST_TO_ADDR
// end ;
78478: LD_VAR 0 3
78482: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78483: LD_INT 0
78485: PPUSH
78486: PPUSH
// if not mc_bases or not base or not kinds then
78487: LD_EXP 58
78491: NOT
78492: PUSH
78493: LD_VAR 0 1
78497: NOT
78498: OR
78499: PUSH
78500: LD_VAR 0 2
78504: NOT
78505: OR
78506: IFFALSE 78510
// exit ;
78508: GO 78571
// for i in kinds do
78510: LD_ADDR_VAR 0 4
78514: PUSH
78515: LD_VAR 0 2
78519: PUSH
78520: FOR_IN
78521: IFFALSE 78569
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78523: LD_ADDR_EXP 92
78527: PUSH
78528: LD_EXP 92
78532: PPUSH
78533: LD_VAR 0 1
78537: PUSH
78538: LD_EXP 92
78542: PUSH
78543: LD_VAR 0 1
78547: ARRAY
78548: PUSH
78549: LD_INT 1
78551: PLUS
78552: PUSH
78553: EMPTY
78554: LIST
78555: LIST
78556: PPUSH
78557: LD_VAR 0 4
78561: PPUSH
78562: CALL 20270 0 3
78566: ST_TO_ADDR
78567: GO 78520
78569: POP
78570: POP
// end ;
78571: LD_VAR 0 3
78575: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78576: LD_INT 0
78578: PPUSH
// if not mc_bases or not base or not areas then
78579: LD_EXP 58
78583: NOT
78584: PUSH
78585: LD_VAR 0 1
78589: NOT
78590: OR
78591: PUSH
78592: LD_VAR 0 2
78596: NOT
78597: OR
78598: IFFALSE 78602
// exit ;
78600: GO 78627
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78602: LD_ADDR_EXP 76
78606: PUSH
78607: LD_EXP 76
78611: PPUSH
78612: LD_VAR 0 1
78616: PPUSH
78617: LD_VAR 0 2
78621: PPUSH
78622: CALL_OW 1
78626: ST_TO_ADDR
// end ;
78627: LD_VAR 0 3
78631: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78632: LD_INT 0
78634: PPUSH
// if not mc_bases or not base or not teleports_exit then
78635: LD_EXP 58
78639: NOT
78640: PUSH
78641: LD_VAR 0 1
78645: NOT
78646: OR
78647: PUSH
78648: LD_VAR 0 2
78652: NOT
78653: OR
78654: IFFALSE 78658
// exit ;
78656: GO 78683
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78658: LD_ADDR_EXP 93
78662: PUSH
78663: LD_EXP 93
78667: PPUSH
78668: LD_VAR 0 1
78672: PPUSH
78673: LD_VAR 0 2
78677: PPUSH
78678: CALL_OW 1
78682: ST_TO_ADDR
// end ;
78683: LD_VAR 0 3
78687: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78688: LD_INT 0
78690: PPUSH
78691: PPUSH
78692: PPUSH
// if not mc_bases or not base or not ext_list then
78693: LD_EXP 58
78697: NOT
78698: PUSH
78699: LD_VAR 0 1
78703: NOT
78704: OR
78705: PUSH
78706: LD_VAR 0 5
78710: NOT
78711: OR
78712: IFFALSE 78716
// exit ;
78714: GO 78889
// tmp := GetFacExtXYD ( x , y , d ) ;
78716: LD_ADDR_VAR 0 8
78720: PUSH
78721: LD_VAR 0 2
78725: PPUSH
78726: LD_VAR 0 3
78730: PPUSH
78731: LD_VAR 0 4
78735: PPUSH
78736: CALL 53585 0 3
78740: ST_TO_ADDR
// if not tmp then
78741: LD_VAR 0 8
78745: NOT
78746: IFFALSE 78750
// exit ;
78748: GO 78889
// for i in tmp do
78750: LD_ADDR_VAR 0 7
78754: PUSH
78755: LD_VAR 0 8
78759: PUSH
78760: FOR_IN
78761: IFFALSE 78887
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78763: LD_ADDR_EXP 63
78767: PUSH
78768: LD_EXP 63
78772: PPUSH
78773: LD_VAR 0 1
78777: PPUSH
78778: LD_EXP 63
78782: PUSH
78783: LD_VAR 0 1
78787: ARRAY
78788: PPUSH
78789: LD_EXP 63
78793: PUSH
78794: LD_VAR 0 1
78798: ARRAY
78799: PUSH
78800: LD_INT 1
78802: PLUS
78803: PPUSH
78804: LD_VAR 0 5
78808: PUSH
78809: LD_INT 1
78811: ARRAY
78812: PUSH
78813: LD_VAR 0 7
78817: PUSH
78818: LD_INT 1
78820: ARRAY
78821: PUSH
78822: LD_VAR 0 7
78826: PUSH
78827: LD_INT 2
78829: ARRAY
78830: PUSH
78831: LD_VAR 0 7
78835: PUSH
78836: LD_INT 3
78838: ARRAY
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: PPUSH
78846: CALL_OW 2
78850: PPUSH
78851: CALL_OW 1
78855: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78856: LD_ADDR_VAR 0 5
78860: PUSH
78861: LD_VAR 0 5
78865: PPUSH
78866: LD_INT 1
78868: PPUSH
78869: CALL_OW 3
78873: ST_TO_ADDR
// if not ext_list then
78874: LD_VAR 0 5
78878: NOT
78879: IFFALSE 78885
// exit ;
78881: POP
78882: POP
78883: GO 78889
// end ;
78885: GO 78760
78887: POP
78888: POP
// end ;
78889: LD_VAR 0 6
78893: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78894: LD_INT 0
78896: PPUSH
// if not mc_bases or not base or not weapon_list then
78897: LD_EXP 58
78901: NOT
78902: PUSH
78903: LD_VAR 0 1
78907: NOT
78908: OR
78909: PUSH
78910: LD_VAR 0 2
78914: NOT
78915: OR
78916: IFFALSE 78920
// exit ;
78918: GO 78945
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78920: LD_ADDR_EXP 97
78924: PUSH
78925: LD_EXP 97
78929: PPUSH
78930: LD_VAR 0 1
78934: PPUSH
78935: LD_VAR 0 2
78939: PPUSH
78940: CALL_OW 1
78944: ST_TO_ADDR
// end ;
78945: LD_VAR 0 3
78949: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78950: LD_INT 0
78952: PPUSH
// if not mc_bases or not base or not tech_list then
78953: LD_EXP 58
78957: NOT
78958: PUSH
78959: LD_VAR 0 1
78963: NOT
78964: OR
78965: PUSH
78966: LD_VAR 0 2
78970: NOT
78971: OR
78972: IFFALSE 78976
// exit ;
78974: GO 79001
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78976: LD_ADDR_EXP 85
78980: PUSH
78981: LD_EXP 85
78985: PPUSH
78986: LD_VAR 0 1
78990: PPUSH
78991: LD_VAR 0 2
78995: PPUSH
78996: CALL_OW 1
79000: ST_TO_ADDR
// end ;
79001: LD_VAR 0 3
79005: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79006: LD_INT 0
79008: PPUSH
// if not mc_bases or not parking_area or not base then
79009: LD_EXP 58
79013: NOT
79014: PUSH
79015: LD_VAR 0 2
79019: NOT
79020: OR
79021: PUSH
79022: LD_VAR 0 1
79026: NOT
79027: OR
79028: IFFALSE 79032
// exit ;
79030: GO 79057
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79032: LD_ADDR_EXP 82
79036: PUSH
79037: LD_EXP 82
79041: PPUSH
79042: LD_VAR 0 1
79046: PPUSH
79047: LD_VAR 0 2
79051: PPUSH
79052: CALL_OW 1
79056: ST_TO_ADDR
// end ;
79057: LD_VAR 0 3
79061: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79062: LD_INT 0
79064: PPUSH
// if not mc_bases or not base or not scan_area then
79065: LD_EXP 58
79069: NOT
79070: PUSH
79071: LD_VAR 0 1
79075: NOT
79076: OR
79077: PUSH
79078: LD_VAR 0 2
79082: NOT
79083: OR
79084: IFFALSE 79088
// exit ;
79086: GO 79113
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79088: LD_ADDR_EXP 83
79092: PUSH
79093: LD_EXP 83
79097: PPUSH
79098: LD_VAR 0 1
79102: PPUSH
79103: LD_VAR 0 2
79107: PPUSH
79108: CALL_OW 1
79112: ST_TO_ADDR
// end ;
79113: LD_VAR 0 3
79117: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79118: LD_INT 0
79120: PPUSH
79121: PPUSH
// if not mc_bases or not base then
79122: LD_EXP 58
79126: NOT
79127: PUSH
79128: LD_VAR 0 1
79132: NOT
79133: OR
79134: IFFALSE 79138
// exit ;
79136: GO 79202
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79138: LD_ADDR_VAR 0 3
79142: PUSH
79143: LD_INT 1
79145: PUSH
79146: LD_INT 2
79148: PUSH
79149: LD_INT 3
79151: PUSH
79152: LD_INT 4
79154: PUSH
79155: LD_INT 11
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: LIST
79162: LIST
79163: LIST
79164: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79165: LD_ADDR_EXP 85
79169: PUSH
79170: LD_EXP 85
79174: PPUSH
79175: LD_VAR 0 1
79179: PPUSH
79180: LD_EXP 85
79184: PUSH
79185: LD_VAR 0 1
79189: ARRAY
79190: PUSH
79191: LD_VAR 0 3
79195: DIFF
79196: PPUSH
79197: CALL_OW 1
79201: ST_TO_ADDR
// end ; end_of_file
79202: LD_VAR 0 2
79206: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79207: LD_INT 0
79209: PPUSH
79210: PPUSH
79211: PPUSH
// if not mc_bases then
79212: LD_EXP 58
79216: NOT
79217: IFFALSE 79221
// exit ;
79219: GO 79386
// for i = 1 to mc_bases do
79221: LD_ADDR_VAR 0 4
79225: PUSH
79226: DOUBLE
79227: LD_INT 1
79229: DEC
79230: ST_TO_ADDR
79231: LD_EXP 58
79235: PUSH
79236: FOR_TO
79237: IFFALSE 79384
// begin if sci in mc_bases [ i ] then
79239: LD_VAR 0 2
79243: PUSH
79244: LD_EXP 58
79248: PUSH
79249: LD_VAR 0 4
79253: ARRAY
79254: IN
79255: IFFALSE 79382
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79257: LD_ADDR_EXP 87
79261: PUSH
79262: LD_EXP 87
79266: PPUSH
79267: LD_VAR 0 4
79271: PUSH
79272: LD_EXP 87
79276: PUSH
79277: LD_VAR 0 4
79281: ARRAY
79282: PUSH
79283: LD_INT 1
79285: PLUS
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PPUSH
79291: LD_VAR 0 1
79295: PPUSH
79296: CALL 20270 0 3
79300: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79301: LD_ADDR_VAR 0 5
79305: PUSH
79306: LD_EXP 58
79310: PUSH
79311: LD_VAR 0 4
79315: ARRAY
79316: PPUSH
79317: LD_INT 2
79319: PUSH
79320: LD_INT 30
79322: PUSH
79323: LD_INT 0
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 30
79332: PUSH
79333: LD_INT 1
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: LIST
79344: PPUSH
79345: CALL_OW 72
79349: PPUSH
79350: LD_VAR 0 1
79354: PPUSH
79355: CALL_OW 74
79359: ST_TO_ADDR
// if tmp then
79360: LD_VAR 0 5
79364: IFFALSE 79380
// ComStandNearbyBuilding ( ape , tmp ) ;
79366: LD_VAR 0 1
79370: PPUSH
79371: LD_VAR 0 5
79375: PPUSH
79376: CALL 14947 0 2
// break ;
79380: GO 79384
// end ; end ;
79382: GO 79236
79384: POP
79385: POP
// end ;
79386: LD_VAR 0 3
79390: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79391: LD_INT 0
79393: PPUSH
79394: PPUSH
79395: PPUSH
// if not mc_bases then
79396: LD_EXP 58
79400: NOT
79401: IFFALSE 79405
// exit ;
79403: GO 79494
// for i = 1 to mc_bases do
79405: LD_ADDR_VAR 0 4
79409: PUSH
79410: DOUBLE
79411: LD_INT 1
79413: DEC
79414: ST_TO_ADDR
79415: LD_EXP 58
79419: PUSH
79420: FOR_TO
79421: IFFALSE 79492
// begin if building in mc_busy_turret_list [ i ] then
79423: LD_VAR 0 1
79427: PUSH
79428: LD_EXP 68
79432: PUSH
79433: LD_VAR 0 4
79437: ARRAY
79438: IN
79439: IFFALSE 79490
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79441: LD_ADDR_VAR 0 5
79445: PUSH
79446: LD_EXP 68
79450: PUSH
79451: LD_VAR 0 4
79455: ARRAY
79456: PUSH
79457: LD_VAR 0 1
79461: DIFF
79462: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79463: LD_ADDR_EXP 68
79467: PUSH
79468: LD_EXP 68
79472: PPUSH
79473: LD_VAR 0 4
79477: PPUSH
79478: LD_VAR 0 5
79482: PPUSH
79483: CALL_OW 1
79487: ST_TO_ADDR
// break ;
79488: GO 79492
// end ; end ;
79490: GO 79420
79492: POP
79493: POP
// end ;
79494: LD_VAR 0 3
79498: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79499: LD_INT 0
79501: PPUSH
79502: PPUSH
79503: PPUSH
// if not mc_bases then
79504: LD_EXP 58
79508: NOT
79509: IFFALSE 79513
// exit ;
79511: GO 79712
// for i = 1 to mc_bases do
79513: LD_ADDR_VAR 0 5
79517: PUSH
79518: DOUBLE
79519: LD_INT 1
79521: DEC
79522: ST_TO_ADDR
79523: LD_EXP 58
79527: PUSH
79528: FOR_TO
79529: IFFALSE 79710
// if building in mc_bases [ i ] then
79531: LD_VAR 0 1
79535: PUSH
79536: LD_EXP 58
79540: PUSH
79541: LD_VAR 0 5
79545: ARRAY
79546: IN
79547: IFFALSE 79708
// begin tmp := mc_bases [ i ] diff building ;
79549: LD_ADDR_VAR 0 6
79553: PUSH
79554: LD_EXP 58
79558: PUSH
79559: LD_VAR 0 5
79563: ARRAY
79564: PUSH
79565: LD_VAR 0 1
79569: DIFF
79570: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79571: LD_ADDR_EXP 58
79575: PUSH
79576: LD_EXP 58
79580: PPUSH
79581: LD_VAR 0 5
79585: PPUSH
79586: LD_VAR 0 6
79590: PPUSH
79591: CALL_OW 1
79595: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79596: LD_VAR 0 1
79600: PUSH
79601: LD_EXP 66
79605: PUSH
79606: LD_VAR 0 5
79610: ARRAY
79611: IN
79612: IFFALSE 79651
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79614: LD_ADDR_EXP 66
79618: PUSH
79619: LD_EXP 66
79623: PPUSH
79624: LD_VAR 0 5
79628: PPUSH
79629: LD_EXP 66
79633: PUSH
79634: LD_VAR 0 5
79638: ARRAY
79639: PUSH
79640: LD_VAR 0 1
79644: DIFF
79645: PPUSH
79646: CALL_OW 1
79650: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79651: LD_VAR 0 1
79655: PUSH
79656: LD_EXP 67
79660: PUSH
79661: LD_VAR 0 5
79665: ARRAY
79666: IN
79667: IFFALSE 79706
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79669: LD_ADDR_EXP 67
79673: PUSH
79674: LD_EXP 67
79678: PPUSH
79679: LD_VAR 0 5
79683: PPUSH
79684: LD_EXP 67
79688: PUSH
79689: LD_VAR 0 5
79693: ARRAY
79694: PUSH
79695: LD_VAR 0 1
79699: DIFF
79700: PPUSH
79701: CALL_OW 1
79705: ST_TO_ADDR
// break ;
79706: GO 79710
// end ;
79708: GO 79528
79710: POP
79711: POP
// end ;
79712: LD_VAR 0 4
79716: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79717: LD_INT 0
79719: PPUSH
79720: PPUSH
79721: PPUSH
// if not mc_bases or not side in mc_sides then
79722: LD_EXP 58
79726: NOT
79727: PUSH
79728: LD_VAR 0 3
79732: PUSH
79733: LD_EXP 84
79737: IN
79738: NOT
79739: OR
79740: IFFALSE 79744
// exit ;
79742: GO 79867
// for i = 1 to mc_vehicles do
79744: LD_ADDR_VAR 0 6
79748: PUSH
79749: DOUBLE
79750: LD_INT 1
79752: DEC
79753: ST_TO_ADDR
79754: LD_EXP 77
79758: PUSH
79759: FOR_TO
79760: IFFALSE 79865
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79762: LD_VAR 0 2
79766: PUSH
79767: LD_EXP 77
79771: PUSH
79772: LD_VAR 0 6
79776: ARRAY
79777: IN
79778: PUSH
79779: LD_VAR 0 1
79783: PUSH
79784: LD_EXP 77
79788: PUSH
79789: LD_VAR 0 6
79793: ARRAY
79794: IN
79795: OR
79796: IFFALSE 79863
// begin tmp := mc_vehicles [ i ] diff old ;
79798: LD_ADDR_VAR 0 7
79802: PUSH
79803: LD_EXP 77
79807: PUSH
79808: LD_VAR 0 6
79812: ARRAY
79813: PUSH
79814: LD_VAR 0 2
79818: DIFF
79819: ST_TO_ADDR
// tmp := tmp diff new ;
79820: LD_ADDR_VAR 0 7
79824: PUSH
79825: LD_VAR 0 7
79829: PUSH
79830: LD_VAR 0 1
79834: DIFF
79835: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79836: LD_ADDR_EXP 77
79840: PUSH
79841: LD_EXP 77
79845: PPUSH
79846: LD_VAR 0 6
79850: PPUSH
79851: LD_VAR 0 7
79855: PPUSH
79856: CALL_OW 1
79860: ST_TO_ADDR
// break ;
79861: GO 79865
// end ;
79863: GO 79759
79865: POP
79866: POP
// end ;
79867: LD_VAR 0 5
79871: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79872: LD_INT 0
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
// if not mc_bases then
79878: LD_EXP 58
79882: NOT
79883: IFFALSE 79887
// exit ;
79885: GO 80270
// side := GetSide ( vehicle ) ;
79887: LD_ADDR_VAR 0 5
79891: PUSH
79892: LD_VAR 0 1
79896: PPUSH
79897: CALL_OW 255
79901: ST_TO_ADDR
// for i = 1 to mc_bases do
79902: LD_ADDR_VAR 0 4
79906: PUSH
79907: DOUBLE
79908: LD_INT 1
79910: DEC
79911: ST_TO_ADDR
79912: LD_EXP 58
79916: PUSH
79917: FOR_TO
79918: IFFALSE 80268
// begin if factory in mc_bases [ i ] then
79920: LD_VAR 0 2
79924: PUSH
79925: LD_EXP 58
79929: PUSH
79930: LD_VAR 0 4
79934: ARRAY
79935: IN
79936: IFFALSE 80266
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
79938: LD_EXP 80
79942: PUSH
79943: LD_VAR 0 4
79947: ARRAY
79948: PUSH
79949: LD_EXP 69
79953: PUSH
79954: LD_VAR 0 4
79958: ARRAY
79959: LESS
79960: PUSH
79961: LD_VAR 0 1
79965: PPUSH
79966: CALL_OW 264
79970: PUSH
79971: LD_INT 31
79973: PUSH
79974: LD_INT 32
79976: PUSH
79977: LD_INT 51
79979: PUSH
79980: LD_EXP 102
79984: PUSH
79985: LD_INT 12
79987: PUSH
79988: LD_INT 30
79990: PUSH
79991: LD_EXP 101
79995: PUSH
79996: LD_INT 11
79998: PUSH
79999: LD_INT 53
80001: PUSH
80002: LD_INT 14
80004: PUSH
80005: LD_EXP 105
80009: PUSH
80010: LD_INT 29
80012: PUSH
80013: LD_EXP 103
80017: PUSH
80018: LD_INT 13
80020: PUSH
80021: LD_INT 52
80023: PUSH
80024: LD_INT 48
80026: PUSH
80027: LD_INT 8
80029: PUSH
80030: EMPTY
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: LIST
80045: LIST
80046: LIST
80047: LIST
80048: IN
80049: NOT
80050: AND
80051: IFFALSE 80092
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
80053: LD_ADDR_EXP 80
80057: PUSH
80058: LD_EXP 80
80062: PPUSH
80063: LD_VAR 0 4
80067: PPUSH
80068: LD_EXP 80
80072: PUSH
80073: LD_VAR 0 4
80077: ARRAY
80078: PUSH
80079: LD_VAR 0 1
80083: ADD
80084: PPUSH
80085: CALL_OW 1
80089: ST_TO_ADDR
80090: GO 80136
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80092: LD_ADDR_EXP 77
80096: PUSH
80097: LD_EXP 77
80101: PPUSH
80102: LD_VAR 0 4
80106: PUSH
80107: LD_EXP 77
80111: PUSH
80112: LD_VAR 0 4
80116: ARRAY
80117: PUSH
80118: LD_INT 1
80120: PLUS
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: PPUSH
80126: LD_VAR 0 1
80130: PPUSH
80131: CALL 20270 0 3
80135: ST_TO_ADDR
// if not mc_scan [ i ] then
80136: LD_EXP 81
80140: PUSH
80141: LD_VAR 0 4
80145: ARRAY
80146: NOT
80147: IFFALSE 80266
// begin if GetControl ( vehicle ) = control_remote then
80149: LD_VAR 0 1
80153: PPUSH
80154: CALL_OW 263
80158: PUSH
80159: LD_INT 2
80161: EQUAL
80162: IFFALSE 80182
// repeat wait ( 0 0$1 ) ;
80164: LD_INT 35
80166: PPUSH
80167: CALL_OW 67
// until IsControledBy ( vehicle ) ;
80171: LD_VAR 0 1
80175: PPUSH
80176: CALL_OW 312
80180: IFFALSE 80164
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80182: LD_VAR 0 1
80186: PPUSH
80187: LD_EXP 82
80191: PUSH
80192: LD_VAR 0 4
80196: ARRAY
80197: PPUSH
80198: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80202: LD_VAR 0 1
80206: PPUSH
80207: CALL_OW 263
80211: PUSH
80212: LD_INT 1
80214: NONEQUAL
80215: IFFALSE 80219
// break ;
80217: GO 80268
// repeat wait ( 0 0$1 ) ;
80219: LD_INT 35
80221: PPUSH
80222: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80226: LD_VAR 0 1
80230: PPUSH
80231: LD_EXP 82
80235: PUSH
80236: LD_VAR 0 4
80240: ARRAY
80241: PPUSH
80242: CALL_OW 308
80246: IFFALSE 80219
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80248: LD_VAR 0 1
80252: PPUSH
80253: CALL_OW 311
80257: PPUSH
80258: CALL_OW 121
// exit ;
80262: POP
80263: POP
80264: GO 80270
// end ; end ; end ;
80266: GO 79917
80268: POP
80269: POP
// end ;
80270: LD_VAR 0 3
80274: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80275: LD_INT 0
80277: PPUSH
80278: PPUSH
80279: PPUSH
80280: PPUSH
// if not mc_bases then
80281: LD_EXP 58
80285: NOT
80286: IFFALSE 80290
// exit ;
80288: GO 80643
// repeat wait ( 0 0$1 ) ;
80290: LD_INT 35
80292: PPUSH
80293: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80297: LD_VAR 0 2
80301: PPUSH
80302: LD_VAR 0 3
80306: PPUSH
80307: CALL_OW 284
80311: IFFALSE 80290
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80313: LD_VAR 0 2
80317: PPUSH
80318: LD_VAR 0 3
80322: PPUSH
80323: CALL_OW 283
80327: PUSH
80328: LD_INT 4
80330: EQUAL
80331: IFFALSE 80335
// exit ;
80333: GO 80643
// for i = 1 to mc_bases do
80335: LD_ADDR_VAR 0 7
80339: PUSH
80340: DOUBLE
80341: LD_INT 1
80343: DEC
80344: ST_TO_ADDR
80345: LD_EXP 58
80349: PUSH
80350: FOR_TO
80351: IFFALSE 80641
// begin if mc_crates_area [ i ] then
80353: LD_EXP 76
80357: PUSH
80358: LD_VAR 0 7
80362: ARRAY
80363: IFFALSE 80474
// for j in mc_crates_area [ i ] do
80365: LD_ADDR_VAR 0 8
80369: PUSH
80370: LD_EXP 76
80374: PUSH
80375: LD_VAR 0 7
80379: ARRAY
80380: PUSH
80381: FOR_IN
80382: IFFALSE 80472
// if InArea ( x , y , j ) then
80384: LD_VAR 0 2
80388: PPUSH
80389: LD_VAR 0 3
80393: PPUSH
80394: LD_VAR 0 8
80398: PPUSH
80399: CALL_OW 309
80403: IFFALSE 80470
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80405: LD_ADDR_EXP 74
80409: PUSH
80410: LD_EXP 74
80414: PPUSH
80415: LD_VAR 0 7
80419: PUSH
80420: LD_EXP 74
80424: PUSH
80425: LD_VAR 0 7
80429: ARRAY
80430: PUSH
80431: LD_INT 1
80433: PLUS
80434: PUSH
80435: EMPTY
80436: LIST
80437: LIST
80438: PPUSH
80439: LD_VAR 0 4
80443: PUSH
80444: LD_VAR 0 2
80448: PUSH
80449: LD_VAR 0 3
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: LIST
80458: PPUSH
80459: CALL 20270 0 3
80463: ST_TO_ADDR
// exit ;
80464: POP
80465: POP
80466: POP
80467: POP
80468: GO 80643
// end ;
80470: GO 80381
80472: POP
80473: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80474: LD_ADDR_VAR 0 9
80478: PUSH
80479: LD_EXP 58
80483: PUSH
80484: LD_VAR 0 7
80488: ARRAY
80489: PPUSH
80490: LD_INT 2
80492: PUSH
80493: LD_INT 30
80495: PUSH
80496: LD_INT 0
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 30
80505: PUSH
80506: LD_INT 1
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: EMPTY
80514: LIST
80515: LIST
80516: LIST
80517: PPUSH
80518: CALL_OW 72
80522: ST_TO_ADDR
// if not depot then
80523: LD_VAR 0 9
80527: NOT
80528: IFFALSE 80532
// continue ;
80530: GO 80350
// for j in depot do
80532: LD_ADDR_VAR 0 8
80536: PUSH
80537: LD_VAR 0 9
80541: PUSH
80542: FOR_IN
80543: IFFALSE 80637
// if GetDistUnitXY ( j , x , y ) < 30 then
80545: LD_VAR 0 8
80549: PPUSH
80550: LD_VAR 0 2
80554: PPUSH
80555: LD_VAR 0 3
80559: PPUSH
80560: CALL_OW 297
80564: PUSH
80565: LD_INT 30
80567: LESS
80568: IFFALSE 80635
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80570: LD_ADDR_EXP 74
80574: PUSH
80575: LD_EXP 74
80579: PPUSH
80580: LD_VAR 0 7
80584: PUSH
80585: LD_EXP 74
80589: PUSH
80590: LD_VAR 0 7
80594: ARRAY
80595: PUSH
80596: LD_INT 1
80598: PLUS
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PPUSH
80604: LD_VAR 0 4
80608: PUSH
80609: LD_VAR 0 2
80613: PUSH
80614: LD_VAR 0 3
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: LIST
80623: PPUSH
80624: CALL 20270 0 3
80628: ST_TO_ADDR
// exit ;
80629: POP
80630: POP
80631: POP
80632: POP
80633: GO 80643
// end ;
80635: GO 80542
80637: POP
80638: POP
// end ;
80639: GO 80350
80641: POP
80642: POP
// end ;
80643: LD_VAR 0 6
80647: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80648: LD_INT 0
80650: PPUSH
80651: PPUSH
80652: PPUSH
80653: PPUSH
// side := GetSide ( lab ) ;
80654: LD_ADDR_VAR 0 4
80658: PUSH
80659: LD_VAR 0 2
80663: PPUSH
80664: CALL_OW 255
80668: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80669: LD_VAR 0 4
80673: PUSH
80674: LD_EXP 84
80678: IN
80679: NOT
80680: PUSH
80681: LD_EXP 85
80685: NOT
80686: OR
80687: PUSH
80688: LD_EXP 58
80692: NOT
80693: OR
80694: IFFALSE 80698
// exit ;
80696: GO 80931
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80698: LD_ADDR_EXP 85
80702: PUSH
80703: LD_EXP 85
80707: PPUSH
80708: LD_VAR 0 4
80712: PPUSH
80713: LD_EXP 85
80717: PUSH
80718: LD_VAR 0 4
80722: ARRAY
80723: PUSH
80724: LD_VAR 0 1
80728: DIFF
80729: PPUSH
80730: CALL_OW 1
80734: ST_TO_ADDR
// for i = 1 to mc_bases do
80735: LD_ADDR_VAR 0 5
80739: PUSH
80740: DOUBLE
80741: LD_INT 1
80743: DEC
80744: ST_TO_ADDR
80745: LD_EXP 58
80749: PUSH
80750: FOR_TO
80751: IFFALSE 80929
// begin if lab in mc_bases [ i ] then
80753: LD_VAR 0 2
80757: PUSH
80758: LD_EXP 58
80762: PUSH
80763: LD_VAR 0 5
80767: ARRAY
80768: IN
80769: IFFALSE 80927
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80771: LD_VAR 0 1
80775: PUSH
80776: LD_INT 11
80778: PUSH
80779: LD_INT 4
80781: PUSH
80782: LD_INT 3
80784: PUSH
80785: LD_INT 2
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: LIST
80792: LIST
80793: IN
80794: PUSH
80795: LD_EXP 88
80799: PUSH
80800: LD_VAR 0 5
80804: ARRAY
80805: AND
80806: IFFALSE 80927
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80808: LD_ADDR_VAR 0 6
80812: PUSH
80813: LD_EXP 88
80817: PUSH
80818: LD_VAR 0 5
80822: ARRAY
80823: PUSH
80824: LD_INT 1
80826: ARRAY
80827: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80828: LD_ADDR_EXP 88
80832: PUSH
80833: LD_EXP 88
80837: PPUSH
80838: LD_VAR 0 5
80842: PPUSH
80843: EMPTY
80844: PPUSH
80845: CALL_OW 1
80849: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80850: LD_VAR 0 6
80854: PPUSH
80855: LD_INT 0
80857: PPUSH
80858: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80862: LD_VAR 0 6
80866: PPUSH
80867: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80871: LD_ADDR_EXP 87
80875: PUSH
80876: LD_EXP 87
80880: PPUSH
80881: LD_VAR 0 5
80885: PPUSH
80886: LD_EXP 87
80890: PUSH
80891: LD_VAR 0 5
80895: ARRAY
80896: PPUSH
80897: LD_INT 1
80899: PPUSH
80900: LD_VAR 0 6
80904: PPUSH
80905: CALL_OW 2
80909: PPUSH
80910: CALL_OW 1
80914: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80915: LD_VAR 0 5
80919: PPUSH
80920: LD_INT 112
80922: PPUSH
80923: CALL 58916 0 2
// end ; end ; end ;
80927: GO 80750
80929: POP
80930: POP
// end ;
80931: LD_VAR 0 3
80935: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80936: LD_INT 0
80938: PPUSH
80939: PPUSH
80940: PPUSH
80941: PPUSH
80942: PPUSH
80943: PPUSH
80944: PPUSH
80945: PPUSH
// if not mc_bases then
80946: LD_EXP 58
80950: NOT
80951: IFFALSE 80955
// exit ;
80953: GO 81898
// for i = 1 to mc_bases do
80955: LD_ADDR_VAR 0 3
80959: PUSH
80960: DOUBLE
80961: LD_INT 1
80963: DEC
80964: ST_TO_ADDR
80965: LD_EXP 58
80969: PUSH
80970: FOR_TO
80971: IFFALSE 81896
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80973: LD_VAR 0 1
80977: PUSH
80978: LD_EXP 58
80982: PUSH
80983: LD_VAR 0 3
80987: ARRAY
80988: IN
80989: PUSH
80990: LD_VAR 0 1
80994: PUSH
80995: LD_EXP 65
80999: PUSH
81000: LD_VAR 0 3
81004: ARRAY
81005: IN
81006: OR
81007: PUSH
81008: LD_VAR 0 1
81012: PUSH
81013: LD_EXP 77
81017: PUSH
81018: LD_VAR 0 3
81022: ARRAY
81023: IN
81024: OR
81025: PUSH
81026: LD_VAR 0 1
81030: PUSH
81031: LD_EXP 87
81035: PUSH
81036: LD_VAR 0 3
81040: ARRAY
81041: IN
81042: OR
81043: PUSH
81044: LD_VAR 0 1
81048: PUSH
81049: LD_EXP 88
81053: PUSH
81054: LD_VAR 0 3
81058: ARRAY
81059: IN
81060: OR
81061: IFFALSE 81894
// begin if un in mc_ape [ i ] then
81063: LD_VAR 0 1
81067: PUSH
81068: LD_EXP 87
81072: PUSH
81073: LD_VAR 0 3
81077: ARRAY
81078: IN
81079: IFFALSE 81118
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81081: LD_ADDR_EXP 87
81085: PUSH
81086: LD_EXP 87
81090: PPUSH
81091: LD_VAR 0 3
81095: PPUSH
81096: LD_EXP 87
81100: PUSH
81101: LD_VAR 0 3
81105: ARRAY
81106: PUSH
81107: LD_VAR 0 1
81111: DIFF
81112: PPUSH
81113: CALL_OW 1
81117: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81118: LD_VAR 0 1
81122: PUSH
81123: LD_EXP 88
81127: PUSH
81128: LD_VAR 0 3
81132: ARRAY
81133: IN
81134: IFFALSE 81158
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81136: LD_ADDR_EXP 88
81140: PUSH
81141: LD_EXP 88
81145: PPUSH
81146: LD_VAR 0 3
81150: PPUSH
81151: EMPTY
81152: PPUSH
81153: CALL_OW 1
81157: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
81158: LD_VAR 0 1
81162: PPUSH
81163: CALL_OW 247
81167: PUSH
81168: LD_INT 2
81170: EQUAL
81171: PUSH
81172: LD_VAR 0 1
81176: PPUSH
81177: CALL_OW 110
81181: PUSH
81182: LD_INT 20
81184: EQUAL
81185: AND
81186: IFFALSE 81289
// begin fac := MC_GetBuilding ( i , b_factory ) ;
81188: LD_ADDR_VAR 0 8
81192: PUSH
81193: LD_VAR 0 3
81197: PPUSH
81198: LD_INT 3
81200: PPUSH
81201: CALL 78224 0 2
81205: ST_TO_ADDR
// if fac then
81206: LD_VAR 0 8
81210: IFFALSE 81289
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81212: LD_ADDR_VAR 0 9
81216: PUSH
81217: LD_VAR 0 8
81221: PPUSH
81222: LD_VAR 0 1
81226: PPUSH
81227: CALL_OW 265
81231: PPUSH
81232: LD_VAR 0 1
81236: PPUSH
81237: CALL_OW 262
81241: PPUSH
81242: LD_VAR 0 1
81246: PPUSH
81247: CALL_OW 263
81251: PPUSH
81252: LD_VAR 0 1
81256: PPUSH
81257: CALL_OW 264
81261: PPUSH
81262: CALL 17870 0 5
81266: ST_TO_ADDR
// if components then
81267: LD_VAR 0 9
81271: IFFALSE 81287
// MC_InsertProduceList ( i , components ) ;
81273: LD_VAR 0 3
81277: PPUSH
81278: LD_VAR 0 9
81282: PPUSH
81283: CALL 77794 0 2
// break ;
81287: GO 81896
// end ; end ; if GetType ( un ) = unit_building then
81289: LD_VAR 0 1
81293: PPUSH
81294: CALL_OW 247
81298: PUSH
81299: LD_INT 3
81301: EQUAL
81302: IFFALSE 81617
// begin btype := GetBType ( un ) ;
81304: LD_ADDR_VAR 0 5
81308: PUSH
81309: LD_VAR 0 1
81313: PPUSH
81314: CALL_OW 266
81318: ST_TO_ADDR
// if btype = b_warehouse then
81319: LD_VAR 0 5
81323: PUSH
81324: LD_INT 1
81326: EQUAL
81327: IFFALSE 81345
// begin btype := b_depot ;
81329: LD_ADDR_VAR 0 5
81333: PUSH
81334: LD_INT 0
81336: ST_TO_ADDR
// pos := 1 ;
81337: LD_ADDR_VAR 0 6
81341: PUSH
81342: LD_INT 1
81344: ST_TO_ADDR
// end ; if btype = b_factory then
81345: LD_VAR 0 5
81349: PUSH
81350: LD_INT 3
81352: EQUAL
81353: IFFALSE 81371
// begin btype := b_workshop ;
81355: LD_ADDR_VAR 0 5
81359: PUSH
81360: LD_INT 2
81362: ST_TO_ADDR
// pos := 1 ;
81363: LD_ADDR_VAR 0 6
81367: PUSH
81368: LD_INT 1
81370: ST_TO_ADDR
// end ; if btype = b_barracks then
81371: LD_VAR 0 5
81375: PUSH
81376: LD_INT 5
81378: EQUAL
81379: IFFALSE 81389
// btype := b_armoury ;
81381: LD_ADDR_VAR 0 5
81385: PUSH
81386: LD_INT 4
81388: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81389: LD_VAR 0 5
81393: PUSH
81394: LD_INT 7
81396: PUSH
81397: LD_INT 8
81399: PUSH
81400: EMPTY
81401: LIST
81402: LIST
81403: IN
81404: IFFALSE 81414
// btype := b_lab ;
81406: LD_ADDR_VAR 0 5
81410: PUSH
81411: LD_INT 6
81413: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81414: LD_ADDR_EXP 63
81418: PUSH
81419: LD_EXP 63
81423: PPUSH
81424: LD_VAR 0 3
81428: PUSH
81429: LD_EXP 63
81433: PUSH
81434: LD_VAR 0 3
81438: ARRAY
81439: PUSH
81440: LD_INT 1
81442: PLUS
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PPUSH
81448: LD_VAR 0 5
81452: PUSH
81453: LD_VAR 0 1
81457: PPUSH
81458: CALL_OW 250
81462: PUSH
81463: LD_VAR 0 1
81467: PPUSH
81468: CALL_OW 251
81472: PUSH
81473: LD_VAR 0 1
81477: PPUSH
81478: CALL_OW 254
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: PPUSH
81489: CALL 20270 0 3
81493: ST_TO_ADDR
// if pos = 1 then
81494: LD_VAR 0 6
81498: PUSH
81499: LD_INT 1
81501: EQUAL
81502: IFFALSE 81617
// begin tmp := mc_build_list [ i ] ;
81504: LD_ADDR_VAR 0 7
81508: PUSH
81509: LD_EXP 63
81513: PUSH
81514: LD_VAR 0 3
81518: ARRAY
81519: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81520: LD_VAR 0 7
81524: PPUSH
81525: LD_INT 2
81527: PUSH
81528: LD_INT 30
81530: PUSH
81531: LD_INT 0
81533: PUSH
81534: EMPTY
81535: LIST
81536: LIST
81537: PUSH
81538: LD_INT 30
81540: PUSH
81541: LD_INT 1
81543: PUSH
81544: EMPTY
81545: LIST
81546: LIST
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: LIST
81552: PPUSH
81553: CALL_OW 72
81557: IFFALSE 81567
// pos := 2 ;
81559: LD_ADDR_VAR 0 6
81563: PUSH
81564: LD_INT 2
81566: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81567: LD_ADDR_VAR 0 7
81571: PUSH
81572: LD_VAR 0 7
81576: PPUSH
81577: LD_VAR 0 6
81581: PPUSH
81582: LD_VAR 0 7
81586: PPUSH
81587: CALL 20596 0 3
81591: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81592: LD_ADDR_EXP 63
81596: PUSH
81597: LD_EXP 63
81601: PPUSH
81602: LD_VAR 0 3
81606: PPUSH
81607: LD_VAR 0 7
81611: PPUSH
81612: CALL_OW 1
81616: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81617: LD_VAR 0 1
81621: PUSH
81622: LD_EXP 58
81626: PUSH
81627: LD_VAR 0 3
81631: ARRAY
81632: IN
81633: IFFALSE 81672
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81635: LD_ADDR_EXP 58
81639: PUSH
81640: LD_EXP 58
81644: PPUSH
81645: LD_VAR 0 3
81649: PPUSH
81650: LD_EXP 58
81654: PUSH
81655: LD_VAR 0 3
81659: ARRAY
81660: PUSH
81661: LD_VAR 0 1
81665: DIFF
81666: PPUSH
81667: CALL_OW 1
81671: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81672: LD_VAR 0 1
81676: PUSH
81677: LD_EXP 65
81681: PUSH
81682: LD_VAR 0 3
81686: ARRAY
81687: IN
81688: IFFALSE 81727
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81690: LD_ADDR_EXP 65
81694: PUSH
81695: LD_EXP 65
81699: PPUSH
81700: LD_VAR 0 3
81704: PPUSH
81705: LD_EXP 65
81709: PUSH
81710: LD_VAR 0 3
81714: ARRAY
81715: PUSH
81716: LD_VAR 0 1
81720: DIFF
81721: PPUSH
81722: CALL_OW 1
81726: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81727: LD_VAR 0 1
81731: PUSH
81732: LD_EXP 77
81736: PUSH
81737: LD_VAR 0 3
81741: ARRAY
81742: IN
81743: IFFALSE 81782
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81745: LD_ADDR_EXP 77
81749: PUSH
81750: LD_EXP 77
81754: PPUSH
81755: LD_VAR 0 3
81759: PPUSH
81760: LD_EXP 77
81764: PUSH
81765: LD_VAR 0 3
81769: ARRAY
81770: PUSH
81771: LD_VAR 0 1
81775: DIFF
81776: PPUSH
81777: CALL_OW 1
81781: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81782: LD_VAR 0 1
81786: PUSH
81787: LD_EXP 67
81791: PUSH
81792: LD_VAR 0 3
81796: ARRAY
81797: IN
81798: IFFALSE 81837
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81800: LD_ADDR_EXP 67
81804: PUSH
81805: LD_EXP 67
81809: PPUSH
81810: LD_VAR 0 3
81814: PPUSH
81815: LD_EXP 67
81819: PUSH
81820: LD_VAR 0 3
81824: ARRAY
81825: PUSH
81826: LD_VAR 0 1
81830: DIFF
81831: PPUSH
81832: CALL_OW 1
81836: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81837: LD_VAR 0 1
81841: PUSH
81842: LD_EXP 66
81846: PUSH
81847: LD_VAR 0 3
81851: ARRAY
81852: IN
81853: IFFALSE 81892
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81855: LD_ADDR_EXP 66
81859: PUSH
81860: LD_EXP 66
81864: PPUSH
81865: LD_VAR 0 3
81869: PPUSH
81870: LD_EXP 66
81874: PUSH
81875: LD_VAR 0 3
81879: ARRAY
81880: PUSH
81881: LD_VAR 0 1
81885: DIFF
81886: PPUSH
81887: CALL_OW 1
81891: ST_TO_ADDR
// end ; break ;
81892: GO 81896
// end ;
81894: GO 80970
81896: POP
81897: POP
// end ;
81898: LD_VAR 0 2
81902: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81903: LD_INT 0
81905: PPUSH
81906: PPUSH
81907: PPUSH
// if not mc_bases then
81908: LD_EXP 58
81912: NOT
81913: IFFALSE 81917
// exit ;
81915: GO 82132
// for i = 1 to mc_bases do
81917: LD_ADDR_VAR 0 3
81921: PUSH
81922: DOUBLE
81923: LD_INT 1
81925: DEC
81926: ST_TO_ADDR
81927: LD_EXP 58
81931: PUSH
81932: FOR_TO
81933: IFFALSE 82130
// begin if building in mc_construct_list [ i ] then
81935: LD_VAR 0 1
81939: PUSH
81940: LD_EXP 65
81944: PUSH
81945: LD_VAR 0 3
81949: ARRAY
81950: IN
81951: IFFALSE 82128
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81953: LD_ADDR_EXP 65
81957: PUSH
81958: LD_EXP 65
81962: PPUSH
81963: LD_VAR 0 3
81967: PPUSH
81968: LD_EXP 65
81972: PUSH
81973: LD_VAR 0 3
81977: ARRAY
81978: PUSH
81979: LD_VAR 0 1
81983: DIFF
81984: PPUSH
81985: CALL_OW 1
81989: ST_TO_ADDR
// if building in mc_lab [ i ] then
81990: LD_VAR 0 1
81994: PUSH
81995: LD_EXP 91
81999: PUSH
82000: LD_VAR 0 3
82004: ARRAY
82005: IN
82006: IFFALSE 82061
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82008: LD_ADDR_EXP 92
82012: PUSH
82013: LD_EXP 92
82017: PPUSH
82018: LD_VAR 0 3
82022: PPUSH
82023: LD_EXP 92
82027: PUSH
82028: LD_VAR 0 3
82032: ARRAY
82033: PPUSH
82034: LD_INT 1
82036: PPUSH
82037: LD_EXP 92
82041: PUSH
82042: LD_VAR 0 3
82046: ARRAY
82047: PPUSH
82048: LD_INT 0
82050: PPUSH
82051: CALL 19688 0 4
82055: PPUSH
82056: CALL_OW 1
82060: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82061: LD_VAR 0 1
82065: PUSH
82066: LD_EXP 58
82070: PUSH
82071: LD_VAR 0 3
82075: ARRAY
82076: IN
82077: NOT
82078: IFFALSE 82124
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82080: LD_ADDR_EXP 58
82084: PUSH
82085: LD_EXP 58
82089: PPUSH
82090: LD_VAR 0 3
82094: PUSH
82095: LD_EXP 58
82099: PUSH
82100: LD_VAR 0 3
82104: ARRAY
82105: PUSH
82106: LD_INT 1
82108: PLUS
82109: PUSH
82110: EMPTY
82111: LIST
82112: LIST
82113: PPUSH
82114: LD_VAR 0 1
82118: PPUSH
82119: CALL 20270 0 3
82123: ST_TO_ADDR
// exit ;
82124: POP
82125: POP
82126: GO 82132
// end ; end ;
82128: GO 81932
82130: POP
82131: POP
// end ;
82132: LD_VAR 0 2
82136: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82137: LD_INT 0
82139: PPUSH
82140: PPUSH
82141: PPUSH
82142: PPUSH
82143: PPUSH
82144: PPUSH
82145: PPUSH
// if not mc_bases then
82146: LD_EXP 58
82150: NOT
82151: IFFALSE 82155
// exit ;
82153: GO 82816
// for i = 1 to mc_bases do
82155: LD_ADDR_VAR 0 3
82159: PUSH
82160: DOUBLE
82161: LD_INT 1
82163: DEC
82164: ST_TO_ADDR
82165: LD_EXP 58
82169: PUSH
82170: FOR_TO
82171: IFFALSE 82814
// begin if building in mc_construct_list [ i ] then
82173: LD_VAR 0 1
82177: PUSH
82178: LD_EXP 65
82182: PUSH
82183: LD_VAR 0 3
82187: ARRAY
82188: IN
82189: IFFALSE 82812
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82191: LD_ADDR_EXP 65
82195: PUSH
82196: LD_EXP 65
82200: PPUSH
82201: LD_VAR 0 3
82205: PPUSH
82206: LD_EXP 65
82210: PUSH
82211: LD_VAR 0 3
82215: ARRAY
82216: PUSH
82217: LD_VAR 0 1
82221: DIFF
82222: PPUSH
82223: CALL_OW 1
82227: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82228: LD_ADDR_EXP 58
82232: PUSH
82233: LD_EXP 58
82237: PPUSH
82238: LD_VAR 0 3
82242: PUSH
82243: LD_EXP 58
82247: PUSH
82248: LD_VAR 0 3
82252: ARRAY
82253: PUSH
82254: LD_INT 1
82256: PLUS
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PPUSH
82262: LD_VAR 0 1
82266: PPUSH
82267: CALL 20270 0 3
82271: ST_TO_ADDR
// btype := GetBType ( building ) ;
82272: LD_ADDR_VAR 0 5
82276: PUSH
82277: LD_VAR 0 1
82281: PPUSH
82282: CALL_OW 266
82286: ST_TO_ADDR
// side := GetSide ( building ) ;
82287: LD_ADDR_VAR 0 8
82291: PUSH
82292: LD_VAR 0 1
82296: PPUSH
82297: CALL_OW 255
82301: ST_TO_ADDR
// if btype = b_lab then
82302: LD_VAR 0 5
82306: PUSH
82307: LD_INT 6
82309: EQUAL
82310: IFFALSE 82360
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82312: LD_ADDR_EXP 91
82316: PUSH
82317: LD_EXP 91
82321: PPUSH
82322: LD_VAR 0 3
82326: PUSH
82327: LD_EXP 91
82331: PUSH
82332: LD_VAR 0 3
82336: ARRAY
82337: PUSH
82338: LD_INT 1
82340: PLUS
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: PPUSH
82346: LD_VAR 0 1
82350: PPUSH
82351: CALL 20270 0 3
82355: ST_TO_ADDR
// exit ;
82356: POP
82357: POP
82358: GO 82816
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82360: LD_VAR 0 5
82364: PUSH
82365: LD_INT 0
82367: PUSH
82368: LD_INT 2
82370: PUSH
82371: LD_INT 4
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: LIST
82378: IN
82379: IFFALSE 82503
// begin if btype = b_armoury then
82381: LD_VAR 0 5
82385: PUSH
82386: LD_INT 4
82388: EQUAL
82389: IFFALSE 82399
// btype := b_barracks ;
82391: LD_ADDR_VAR 0 5
82395: PUSH
82396: LD_INT 5
82398: ST_TO_ADDR
// if btype = b_depot then
82399: LD_VAR 0 5
82403: PUSH
82404: LD_INT 0
82406: EQUAL
82407: IFFALSE 82417
// btype := b_warehouse ;
82409: LD_ADDR_VAR 0 5
82413: PUSH
82414: LD_INT 1
82416: ST_TO_ADDR
// if btype = b_workshop then
82417: LD_VAR 0 5
82421: PUSH
82422: LD_INT 2
82424: EQUAL
82425: IFFALSE 82435
// btype := b_factory ;
82427: LD_ADDR_VAR 0 5
82431: PUSH
82432: LD_INT 3
82434: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82435: LD_VAR 0 5
82439: PPUSH
82440: LD_VAR 0 8
82444: PPUSH
82445: CALL_OW 323
82449: PUSH
82450: LD_INT 1
82452: EQUAL
82453: IFFALSE 82499
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82455: LD_ADDR_EXP 90
82459: PUSH
82460: LD_EXP 90
82464: PPUSH
82465: LD_VAR 0 3
82469: PUSH
82470: LD_EXP 90
82474: PUSH
82475: LD_VAR 0 3
82479: ARRAY
82480: PUSH
82481: LD_INT 1
82483: PLUS
82484: PUSH
82485: EMPTY
82486: LIST
82487: LIST
82488: PPUSH
82489: LD_VAR 0 1
82493: PPUSH
82494: CALL 20270 0 3
82498: ST_TO_ADDR
// exit ;
82499: POP
82500: POP
82501: GO 82816
// end ; if btype in [ b_bunker , b_turret ] then
82503: LD_VAR 0 5
82507: PUSH
82508: LD_INT 32
82510: PUSH
82511: LD_INT 33
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: IN
82518: IFFALSE 82808
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82520: LD_ADDR_EXP 66
82524: PUSH
82525: LD_EXP 66
82529: PPUSH
82530: LD_VAR 0 3
82534: PUSH
82535: LD_EXP 66
82539: PUSH
82540: LD_VAR 0 3
82544: ARRAY
82545: PUSH
82546: LD_INT 1
82548: PLUS
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PPUSH
82554: LD_VAR 0 1
82558: PPUSH
82559: CALL 20270 0 3
82563: ST_TO_ADDR
// if btype = b_bunker then
82564: LD_VAR 0 5
82568: PUSH
82569: LD_INT 32
82571: EQUAL
82572: IFFALSE 82808
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82574: LD_ADDR_EXP 67
82578: PUSH
82579: LD_EXP 67
82583: PPUSH
82584: LD_VAR 0 3
82588: PUSH
82589: LD_EXP 67
82593: PUSH
82594: LD_VAR 0 3
82598: ARRAY
82599: PUSH
82600: LD_INT 1
82602: PLUS
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: PPUSH
82608: LD_VAR 0 1
82612: PPUSH
82613: CALL 20270 0 3
82617: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82618: LD_ADDR_VAR 0 6
82622: PUSH
82623: LD_EXP 58
82627: PUSH
82628: LD_VAR 0 3
82632: ARRAY
82633: PPUSH
82634: LD_INT 25
82636: PUSH
82637: LD_INT 1
82639: PUSH
82640: EMPTY
82641: LIST
82642: LIST
82643: PUSH
82644: LD_INT 3
82646: PUSH
82647: LD_INT 54
82649: PUSH
82650: EMPTY
82651: LIST
82652: PUSH
82653: EMPTY
82654: LIST
82655: LIST
82656: PUSH
82657: EMPTY
82658: LIST
82659: LIST
82660: PPUSH
82661: CALL_OW 72
82665: ST_TO_ADDR
// if tmp then
82666: LD_VAR 0 6
82670: IFFALSE 82676
// exit ;
82672: POP
82673: POP
82674: GO 82816
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82676: LD_ADDR_VAR 0 6
82680: PUSH
82681: LD_EXP 58
82685: PUSH
82686: LD_VAR 0 3
82690: ARRAY
82691: PPUSH
82692: LD_INT 2
82694: PUSH
82695: LD_INT 30
82697: PUSH
82698: LD_INT 4
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PUSH
82705: LD_INT 30
82707: PUSH
82708: LD_INT 5
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: LIST
82719: PPUSH
82720: CALL_OW 72
82724: ST_TO_ADDR
// if not tmp then
82725: LD_VAR 0 6
82729: NOT
82730: IFFALSE 82736
// exit ;
82732: POP
82733: POP
82734: GO 82816
// for j in tmp do
82736: LD_ADDR_VAR 0 4
82740: PUSH
82741: LD_VAR 0 6
82745: PUSH
82746: FOR_IN
82747: IFFALSE 82806
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82749: LD_ADDR_VAR 0 7
82753: PUSH
82754: LD_VAR 0 4
82758: PPUSH
82759: CALL_OW 313
82763: PPUSH
82764: LD_INT 25
82766: PUSH
82767: LD_INT 1
82769: PUSH
82770: EMPTY
82771: LIST
82772: LIST
82773: PPUSH
82774: CALL_OW 72
82778: ST_TO_ADDR
// if units then
82779: LD_VAR 0 7
82783: IFFALSE 82804
// begin ComExitBuilding ( units [ 1 ] ) ;
82785: LD_VAR 0 7
82789: PUSH
82790: LD_INT 1
82792: ARRAY
82793: PPUSH
82794: CALL_OW 122
// exit ;
82798: POP
82799: POP
82800: POP
82801: POP
82802: GO 82816
// end ; end ;
82804: GO 82746
82806: POP
82807: POP
// end ; end ; exit ;
82808: POP
82809: POP
82810: GO 82816
// end ; end ;
82812: GO 82170
82814: POP
82815: POP
// end ;
82816: LD_VAR 0 2
82820: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82821: LD_INT 0
82823: PPUSH
82824: PPUSH
82825: PPUSH
82826: PPUSH
82827: PPUSH
82828: PPUSH
82829: PPUSH
// if not mc_bases then
82830: LD_EXP 58
82834: NOT
82835: IFFALSE 82839
// exit ;
82837: GO 83070
// btype := GetBType ( building ) ;
82839: LD_ADDR_VAR 0 6
82843: PUSH
82844: LD_VAR 0 1
82848: PPUSH
82849: CALL_OW 266
82853: ST_TO_ADDR
// x := GetX ( building ) ;
82854: LD_ADDR_VAR 0 7
82858: PUSH
82859: LD_VAR 0 1
82863: PPUSH
82864: CALL_OW 250
82868: ST_TO_ADDR
// y := GetY ( building ) ;
82869: LD_ADDR_VAR 0 8
82873: PUSH
82874: LD_VAR 0 1
82878: PPUSH
82879: CALL_OW 251
82883: ST_TO_ADDR
// d := GetDir ( building ) ;
82884: LD_ADDR_VAR 0 9
82888: PUSH
82889: LD_VAR 0 1
82893: PPUSH
82894: CALL_OW 254
82898: ST_TO_ADDR
// for i = 1 to mc_bases do
82899: LD_ADDR_VAR 0 4
82903: PUSH
82904: DOUBLE
82905: LD_INT 1
82907: DEC
82908: ST_TO_ADDR
82909: LD_EXP 58
82913: PUSH
82914: FOR_TO
82915: IFFALSE 83068
// begin if not mc_build_list [ i ] then
82917: LD_EXP 63
82921: PUSH
82922: LD_VAR 0 4
82926: ARRAY
82927: NOT
82928: IFFALSE 82932
// continue ;
82930: GO 82914
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
82932: LD_VAR 0 6
82936: PUSH
82937: LD_VAR 0 7
82941: PUSH
82942: LD_VAR 0 8
82946: PUSH
82947: LD_VAR 0 9
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: LIST
82956: LIST
82957: PPUSH
82958: LD_EXP 63
82962: PUSH
82963: LD_VAR 0 4
82967: ARRAY
82968: PUSH
82969: LD_INT 1
82971: ARRAY
82972: PPUSH
82973: CALL 26439 0 2
82977: IFFALSE 83066
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
82979: LD_ADDR_EXP 63
82983: PUSH
82984: LD_EXP 63
82988: PPUSH
82989: LD_VAR 0 4
82993: PPUSH
82994: LD_EXP 63
82998: PUSH
82999: LD_VAR 0 4
83003: ARRAY
83004: PPUSH
83005: LD_INT 1
83007: PPUSH
83008: CALL_OW 3
83012: PPUSH
83013: CALL_OW 1
83017: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83018: LD_ADDR_EXP 65
83022: PUSH
83023: LD_EXP 65
83027: PPUSH
83028: LD_VAR 0 4
83032: PUSH
83033: LD_EXP 65
83037: PUSH
83038: LD_VAR 0 4
83042: ARRAY
83043: PUSH
83044: LD_INT 1
83046: PLUS
83047: PUSH
83048: EMPTY
83049: LIST
83050: LIST
83051: PPUSH
83052: LD_VAR 0 1
83056: PPUSH
83057: CALL 20270 0 3
83061: ST_TO_ADDR
// exit ;
83062: POP
83063: POP
83064: GO 83070
// end ; end ;
83066: GO 82914
83068: POP
83069: POP
// end ;
83070: LD_VAR 0 3
83074: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83075: LD_INT 0
83077: PPUSH
83078: PPUSH
83079: PPUSH
// if not mc_bases then
83080: LD_EXP 58
83084: NOT
83085: IFFALSE 83089
// exit ;
83087: GO 83279
// for i = 1 to mc_bases do
83089: LD_ADDR_VAR 0 4
83093: PUSH
83094: DOUBLE
83095: LD_INT 1
83097: DEC
83098: ST_TO_ADDR
83099: LD_EXP 58
83103: PUSH
83104: FOR_TO
83105: IFFALSE 83192
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83107: LD_VAR 0 1
83111: PUSH
83112: LD_EXP 66
83116: PUSH
83117: LD_VAR 0 4
83121: ARRAY
83122: IN
83123: PUSH
83124: LD_VAR 0 1
83128: PUSH
83129: LD_EXP 67
83133: PUSH
83134: LD_VAR 0 4
83138: ARRAY
83139: IN
83140: NOT
83141: AND
83142: IFFALSE 83190
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83144: LD_ADDR_EXP 67
83148: PUSH
83149: LD_EXP 67
83153: PPUSH
83154: LD_VAR 0 4
83158: PUSH
83159: LD_EXP 67
83163: PUSH
83164: LD_VAR 0 4
83168: ARRAY
83169: PUSH
83170: LD_INT 1
83172: PLUS
83173: PUSH
83174: EMPTY
83175: LIST
83176: LIST
83177: PPUSH
83178: LD_VAR 0 1
83182: PPUSH
83183: CALL 20270 0 3
83187: ST_TO_ADDR
// break ;
83188: GO 83192
// end ; end ;
83190: GO 83104
83192: POP
83193: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83194: LD_VAR 0 1
83198: PPUSH
83199: CALL_OW 257
83203: PUSH
83204: LD_EXP 84
83208: IN
83209: PUSH
83210: LD_VAR 0 1
83214: PPUSH
83215: CALL_OW 266
83219: PUSH
83220: LD_INT 5
83222: EQUAL
83223: AND
83224: PUSH
83225: LD_VAR 0 2
83229: PPUSH
83230: CALL_OW 110
83234: PUSH
83235: LD_INT 18
83237: NONEQUAL
83238: AND
83239: IFFALSE 83279
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83241: LD_VAR 0 2
83245: PPUSH
83246: CALL_OW 257
83250: PUSH
83251: LD_INT 5
83253: PUSH
83254: LD_INT 8
83256: PUSH
83257: LD_INT 9
83259: PUSH
83260: EMPTY
83261: LIST
83262: LIST
83263: LIST
83264: IN
83265: IFFALSE 83279
// SetClass ( unit , 1 ) ;
83267: LD_VAR 0 2
83271: PPUSH
83272: LD_INT 1
83274: PPUSH
83275: CALL_OW 336
// end ;
83279: LD_VAR 0 3
83283: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83284: LD_INT 0
83286: PPUSH
83287: PPUSH
// if not mc_bases then
83288: LD_EXP 58
83292: NOT
83293: IFFALSE 83297
// exit ;
83295: GO 83413
// if GetLives ( abandoned_vehicle ) > 250 then
83297: LD_VAR 0 2
83301: PPUSH
83302: CALL_OW 256
83306: PUSH
83307: LD_INT 250
83309: GREATER
83310: IFFALSE 83314
// exit ;
83312: GO 83413
// for i = 1 to mc_bases do
83314: LD_ADDR_VAR 0 6
83318: PUSH
83319: DOUBLE
83320: LD_INT 1
83322: DEC
83323: ST_TO_ADDR
83324: LD_EXP 58
83328: PUSH
83329: FOR_TO
83330: IFFALSE 83411
// begin if driver in mc_bases [ i ] then
83332: LD_VAR 0 1
83336: PUSH
83337: LD_EXP 58
83341: PUSH
83342: LD_VAR 0 6
83346: ARRAY
83347: IN
83348: IFFALSE 83409
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83350: LD_VAR 0 1
83354: PPUSH
83355: LD_EXP 58
83359: PUSH
83360: LD_VAR 0 6
83364: ARRAY
83365: PPUSH
83366: LD_INT 2
83368: PUSH
83369: LD_INT 30
83371: PUSH
83372: LD_INT 0
83374: PUSH
83375: EMPTY
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 30
83381: PUSH
83382: LD_INT 1
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: LIST
83393: PPUSH
83394: CALL_OW 72
83398: PUSH
83399: LD_INT 1
83401: ARRAY
83402: PPUSH
83403: CALL_OW 112
// break ;
83407: GO 83411
// end ; end ;
83409: GO 83329
83411: POP
83412: POP
// end ; end_of_file
83413: LD_VAR 0 5
83417: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
83418: GO 83420
83420: DISABLE
// begin ru_radar := 98 ;
83421: LD_ADDR_EXP 101
83425: PUSH
83426: LD_INT 98
83428: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83429: LD_ADDR_EXP 102
83433: PUSH
83434: LD_INT 89
83436: ST_TO_ADDR
// us_hack := 99 ;
83437: LD_ADDR_EXP 103
83441: PUSH
83442: LD_INT 99
83444: ST_TO_ADDR
// us_artillery := 97 ;
83445: LD_ADDR_EXP 104
83449: PUSH
83450: LD_INT 97
83452: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83453: LD_ADDR_EXP 105
83457: PUSH
83458: LD_INT 91
83460: ST_TO_ADDR
// end ;
83461: END
