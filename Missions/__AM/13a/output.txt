// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 56331 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 48221 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 48221 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 48221 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 48221 0 9
// PrepareArabian ;
 140: CALL 3463 0 0
// PrepareRussian ;
 144: CALL 2598 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 57478 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6626 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 78279 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 78705 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 79100 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 79369 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 78645 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 79276 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 78705 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 79100 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 79369 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 78489 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 78645 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := false ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13798 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13798 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13798 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13798 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13798 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13798 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13798 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13798 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13798 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13798 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornell
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13798 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13798 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13798 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13798 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13798 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13798 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13798 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20431 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 60
1567: PPUSH
1568: LD_INT 6
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20431 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 3
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 75
1653: PPUSH
1654: LD_INT 6
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
// uc_side := 6 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 6
1696: ST_TO_ADDR
// uc_nation := 3 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// InitHc ;
1705: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1709: LD_ADDR_EXP 31
1713: PUSH
1714: LD_STRING Gossudarov
1716: PPUSH
1717: CALL_OW 25
1721: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1722: LD_ADDR_EXP 32
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: CALL_OW 25
1734: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1735: LD_ADDR_EXP 33
1739: PUSH
1740: LD_STRING Titov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Oblukov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1761: LD_ADDR_EXP 35
1765: PUSH
1766: LD_STRING Dolgov
1768: PPUSH
1769: CALL_OW 25
1773: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1774: LD_ADDR_EXP 36
1778: PUSH
1779: LD_STRING Petrosyan
1781: PPUSH
1782: CALL_OW 25
1786: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1787: LD_ADDR_EXP 37
1791: PUSH
1792: LD_STRING Scholtze
1794: PPUSH
1795: CALL_OW 25
1799: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1800: LD_ADDR_EXP 39
1804: PUSH
1805: LD_STRING Kapitsova
1807: PPUSH
1808: CALL_OW 25
1812: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_EXP 31
1822: PUSH
1823: LD_EXP 32
1827: PUSH
1828: LD_EXP 33
1832: PUSH
1833: LD_EXP 38
1837: PUSH
1838: LD_EXP 35
1842: PUSH
1843: LD_EXP 36
1847: PUSH
1848: LD_EXP 37
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1898
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1881: LD_VAR 0 3
1885: PPUSH
1886: LD_INT 14
1888: PPUSH
1889: LD_INT 0
1891: PPUSH
1892: CALL_OW 49
1896: GO 1878
1898: POP
1899: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1900: LD_VAR 0 2
1904: PPUSH
1905: LD_EXP 3
1909: PPUSH
1910: CALL_OW 250
1914: PPUSH
1915: LD_EXP 3
1919: PPUSH
1920: CALL_OW 251
1924: PPUSH
1925: CALL_OW 111
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareBelkov ; begin
1934: LD_INT 0
1936: PPUSH
// uc_side := 4 ;
1937: LD_ADDR_OWVAR 20
1941: PUSH
1942: LD_INT 4
1944: ST_TO_ADDR
// uc_nation := 3 ;
1945: LD_ADDR_OWVAR 21
1949: PUSH
1950: LD_INT 3
1952: ST_TO_ADDR
// InitHc ;
1953: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1957: LD_ADDR_EXP 46
1961: PUSH
1962: LD_STRING Belkov
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1970: LD_EXP 46
1974: PPUSH
1975: LD_INT 14
1977: PPUSH
1978: LD_INT 0
1980: PPUSH
1981: CALL_OW 49
// end ;
1985: LD_VAR 0 1
1989: RET
// export function PrepareGnyevko ; begin
1990: LD_INT 0
1992: PPUSH
// uc_side := 4 ;
1993: LD_ADDR_OWVAR 20
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// uc_nation := 3 ;
2001: LD_ADDR_OWVAR 21
2005: PUSH
2006: LD_INT 3
2008: ST_TO_ADDR
// InitHc ;
2009: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2013: LD_ADDR_EXP 47
2017: PUSH
2018: LD_STRING Gnyevko
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2026: LD_EXP 47
2030: PPUSH
2031: LD_INT 14
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 49
// end ;
2041: LD_VAR 0 1
2045: RET
// export function PrepareBurlak ; var i , tmp ; begin
2046: LD_INT 0
2048: PPUSH
2049: PPUSH
2050: PPUSH
// uc_side := 4 ;
2051: LD_ADDR_OWVAR 20
2055: PUSH
2056: LD_INT 4
2058: ST_TO_ADDR
// uc_nation := 3 ;
2059: LD_ADDR_OWVAR 21
2063: PUSH
2064: LD_INT 3
2066: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2067: LD_INT 35
2069: PPUSH
2070: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2074: LD_INT 92
2076: PUSH
2077: LD_INT 123
2079: PUSH
2080: LD_INT 3
2082: PUSH
2083: LD_INT 3
2085: PUSH
2086: EMPTY
2087: LIST
2088: LIST
2089: LIST
2090: LIST
2091: PPUSH
2092: CALL_OW 69
2096: NOT
2097: IFFALSE 2067
// InitHc ;
2099: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2103: LD_ADDR_EXP 45
2107: PUSH
2108: LD_STRING Burlak
2110: PPUSH
2111: CALL_OW 25
2115: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2116: LD_INT 24
2118: PUSH
2119: LD_INT 23
2121: PUSH
2122: LD_INT 22
2124: PUSH
2125: EMPTY
2126: LIST
2127: LIST
2128: LIST
2129: PUSH
2130: LD_OWVAR 67
2134: ARRAY
2135: PPUSH
2136: LD_INT 1
2138: PPUSH
2139: LD_INT 1
2141: PPUSH
2142: LD_INT 45
2144: PUSH
2145: LD_INT 44
2147: PUSH
2148: LD_INT 43
2150: PUSH
2151: EMPTY
2152: LIST
2153: LIST
2154: LIST
2155: PUSH
2156: LD_OWVAR 67
2160: ARRAY
2161: PPUSH
2162: LD_INT 0
2164: PPUSH
2165: CALL 20431 0 5
// Masha := CreateVehicle ;
2169: LD_ADDR_EXP 48
2173: PUSH
2174: CALL_OW 45
2178: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2179: LD_EXP 48
2183: PUSH
2184: LD_EXP 45
2188: PUSH
2189: EMPTY
2190: LIST
2191: LIST
2192: PPUSH
2193: LD_INT 499
2195: PPUSH
2196: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2200: LD_EXP 48
2204: PPUSH
2205: LD_INT 3
2207: PPUSH
2208: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2212: LD_EXP 48
2216: PPUSH
2217: LD_INT 1
2219: PPUSH
2220: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2224: LD_EXP 48
2228: PPUSH
2229: LD_INT 18
2231: PPUSH
2232: LD_INT 0
2234: PPUSH
2235: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2239: LD_EXP 45
2243: PPUSH
2244: LD_INT 125
2246: PPUSH
2247: LD_INT 1
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2257: LD_EXP 45
2261: PPUSH
2262: LD_EXP 48
2266: PPUSH
2267: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2271: LD_INT 10
2273: PPUSH
2274: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 110
2285: PPUSH
2286: LD_INT 10
2288: PPUSH
2289: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2293: LD_ADDR_EXP 41
2297: PUSH
2298: LD_STRING Petrovova
2300: PPUSH
2301: CALL_OW 25
2305: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2306: LD_ADDR_EXP 43
2310: PUSH
2311: LD_STRING Kuzmov
2313: PPUSH
2314: CALL_OW 25
2318: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2319: LD_ADDR_EXP 42
2323: PUSH
2324: LD_STRING Kovalyuk
2326: PPUSH
2327: CALL_OW 25
2331: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2332: LD_ADDR_EXP 40
2336: PUSH
2337: LD_STRING Lipshchin
2339: PPUSH
2340: CALL_OW 25
2344: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2345: LD_ADDR_EXP 44
2349: PUSH
2350: LD_STRING Karamazov
2352: PPUSH
2353: CALL_OW 25
2357: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2358: LD_ADDR_VAR 0 3
2362: PUSH
2363: LD_EXP 41
2367: PUSH
2368: LD_EXP 43
2372: PUSH
2373: LD_EXP 42
2377: PUSH
2378: LD_EXP 40
2382: PUSH
2383: LD_EXP 44
2387: PUSH
2388: EMPTY
2389: LIST
2390: LIST
2391: LIST
2392: LIST
2393: LIST
2394: ST_TO_ADDR
// for i in tmp do
2395: LD_ADDR_VAR 0 2
2399: PUSH
2400: LD_VAR 0 3
2404: PUSH
2405: FOR_IN
2406: IFFALSE 2445
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2408: LD_VAR 0 2
2412: PPUSH
2413: LD_INT 399
2415: PPUSH
2416: LD_INT 799
2418: PPUSH
2419: CALL_OW 12
2423: PPUSH
2424: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2428: LD_VAR 0 2
2432: PPUSH
2433: LD_INT 19
2435: PPUSH
2436: LD_INT 0
2438: PPUSH
2439: CALL_OW 49
// end ;
2443: GO 2405
2445: POP
2446: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2447: LD_VAR 0 3
2451: PPUSH
2452: LD_INT 116
2454: PPUSH
2455: LD_INT 8
2457: PPUSH
2458: CALL_OW 111
// AddComHold ( tmp ) ;
2462: LD_VAR 0 3
2466: PPUSH
2467: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2471: LD_ADDR_VAR 0 2
2475: PUSH
2476: LD_VAR 0 3
2480: PPUSH
2481: LD_INT 25
2483: PUSH
2484: LD_INT 1
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PPUSH
2491: CALL_OW 72
2495: PUSH
2496: FOR_IN
2497: IFFALSE 2537
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2499: LD_VAR 0 2
2503: PPUSH
2504: LD_INT 20
2506: PPUSH
2507: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2511: LD_VAR 0 2
2515: PPUSH
2516: LD_INT 147
2518: PPUSH
2519: LD_INT 45
2521: PPUSH
2522: CALL_OW 178
// AddComCrawl ( i ) ;
2526: LD_VAR 0 2
2530: PPUSH
2531: CALL_OW 197
// end ;
2535: GO 2496
2537: POP
2538: POP
// repeat wait ( 0 0$1 ) ;
2539: LD_INT 35
2541: PPUSH
2542: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2546: LD_EXP 48
2550: PPUSH
2551: LD_INT 110
2553: PPUSH
2554: LD_INT 10
2556: PPUSH
2557: CALL_OW 307
2561: PUSH
2562: LD_EXP 48
2566: PPUSH
2567: CALL_OW 305
2571: NOT
2572: OR
2573: IFFALSE 2539
// ComStop ( Burlak ) ;
2575: LD_EXP 45
2579: PPUSH
2580: CALL_OW 141
// AddComHold ( Burlak ) ;
2584: LD_EXP 45
2588: PPUSH
2589: CALL_OW 200
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
// uc_side := 3 ;
2604: LD_ADDR_OWVAR 20
2608: PUSH
2609: LD_INT 3
2611: ST_TO_ADDR
// uc_nation := 3 ;
2612: LD_ADDR_OWVAR 21
2616: PUSH
2617: LD_INT 3
2619: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2620: LD_ADDR_EXP 49
2624: PUSH
2625: LD_INT 47
2627: PPUSH
2628: LD_INT 4
2630: PPUSH
2631: LD_STRING 
2633: PPUSH
2634: LD_INT 7
2636: PUSH
2637: LD_INT 8
2639: PUSH
2640: LD_INT 9
2642: PUSH
2643: EMPTY
2644: LIST
2645: LIST
2646: LIST
2647: PUSH
2648: LD_OWVAR 67
2652: ARRAY
2653: PPUSH
2654: LD_INT 10000
2656: PUSH
2657: LD_INT 3000
2659: PUSH
2660: LD_INT 300
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: LIST
2667: PPUSH
2668: LD_INT 9
2670: PUSH
2671: LD_INT 5
2673: PUSH
2674: LD_INT 6
2676: PUSH
2677: LD_INT 6
2679: PUSH
2680: EMPTY
2681: LIST
2682: LIST
2683: LIST
2684: LIST
2685: PPUSH
2686: CALL 23840 0 6
2690: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2691: LD_ADDR_EXP 58
2695: PUSH
2696: LD_EXP 58
2700: PPUSH
2701: LD_INT 2
2703: PPUSH
2704: LD_EXP 49
2708: PPUSH
2709: CALL_OW 1
2713: ST_TO_ADDR
// tmp := [ ] ;
2714: LD_ADDR_VAR 0 4
2718: PUSH
2719: EMPTY
2720: ST_TO_ADDR
// for i = 1 to 4 do
2721: LD_ADDR_VAR 0 2
2725: PUSH
2726: DOUBLE
2727: LD_INT 1
2729: DEC
2730: ST_TO_ADDR
2731: LD_INT 4
2733: PUSH
2734: FOR_TO
2735: IFFALSE 2828
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2737: LD_INT 22
2739: PPUSH
2740: LD_INT 3
2742: PPUSH
2743: LD_INT 3
2745: PPUSH
2746: LD_INT 43
2748: PUSH
2749: LD_INT 45
2751: PUSH
2752: LD_INT 45
2754: PUSH
2755: LD_INT 44
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_VAR 0 2
2768: PUSH
2769: LD_INT 4
2771: MOD
2772: PUSH
2773: LD_INT 1
2775: PLUS
2776: ARRAY
2777: PPUSH
2778: LD_INT 100
2780: PPUSH
2781: CALL 20431 0 5
// veh := CreateVehicle ;
2785: LD_ADDR_VAR 0 3
2789: PUSH
2790: CALL_OW 45
2794: ST_TO_ADDR
// tmp := tmp ^ veh ;
2795: LD_ADDR_VAR 0 4
2799: PUSH
2800: LD_VAR 0 4
2804: PUSH
2805: LD_VAR 0 3
2809: ADD
2810: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2811: LD_VAR 0 3
2815: PPUSH
2816: LD_INT 2
2818: PPUSH
2819: LD_INT 0
2821: PPUSH
2822: CALL_OW 49
// end ;
2826: GO 2734
2828: POP
2829: POP
// russian_guard := tmp ;
2830: LD_ADDR_EXP 50
2834: PUSH
2835: LD_VAR 0 4
2839: ST_TO_ADDR
// end ;
2840: LD_VAR 0 1
2844: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2845: LD_INT 47
2847: PPUSH
2848: CALL_OW 302
2852: PUSH
2853: LD_EXP 6
2857: AND
2858: IFFALSE 3460
2860: GO 2862
2862: DISABLE
2863: LD_INT 0
2865: PPUSH
2866: PPUSH
2867: PPUSH
2868: PPUSH
2869: PPUSH
2870: PPUSH
// begin enable ;
2871: ENABLE
// base := 2 ;
2872: LD_ADDR_VAR 0 2
2876: PUSH
2877: LD_INT 2
2879: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2880: LD_ADDR_VAR 0 4
2884: PUSH
2885: LD_INT 0
2887: PUSH
2888: LD_INT 0
2890: PUSH
2891: LD_INT 0
2893: PUSH
2894: LD_INT 0
2896: PUSH
2897: LD_INT 0
2899: PUSH
2900: LD_INT 0
2902: PUSH
2903: LD_INT 0
2905: PUSH
2906: LD_INT 0
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: LD_INT 0
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: LIST
2924: LIST
2925: LIST
2926: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2927: LD_ADDR_VAR 0 3
2931: PUSH
2932: LD_INT 22
2934: PUSH
2935: LD_INT 1
2937: PUSH
2938: LD_INT 3
2940: PUSH
2941: LD_INT 45
2943: PUSH
2944: EMPTY
2945: LIST
2946: LIST
2947: LIST
2948: LIST
2949: PUSH
2950: LD_INT 21
2952: PUSH
2953: LD_INT 1
2955: PUSH
2956: LD_INT 3
2958: PUSH
2959: LD_INT 45
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: PUSH
2968: LD_INT 22
2970: PUSH
2971: LD_INT 1
2973: PUSH
2974: LD_INT 3
2976: PUSH
2977: LD_INT 45
2979: PUSH
2980: EMPTY
2981: LIST
2982: LIST
2983: LIST
2984: LIST
2985: PUSH
2986: LD_INT 23
2988: PUSH
2989: LD_INT 1
2991: PUSH
2992: LD_INT 3
2994: PUSH
2995: LD_INT 46
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: EMPTY
3005: LIST
3006: LIST
3007: LIST
3008: LIST
3009: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3010: LD_ADDR_VAR 0 1
3014: PUSH
3015: DOUBLE
3016: LD_INT 1
3018: DEC
3019: ST_TO_ADDR
3020: LD_OWVAR 67
3024: PUSH
3025: LD_OWVAR 1
3029: PUSH
3030: LD_INT 21000
3032: DIV
3033: PLUS
3034: PUSH
3035: FOR_TO
3036: IFFALSE 3124
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3038: LD_ADDR_VAR 0 3
3042: PUSH
3043: LD_VAR 0 3
3047: PPUSH
3048: LD_VAR 0 3
3052: PUSH
3053: LD_INT 1
3055: PLUS
3056: PPUSH
3057: LD_INT 23
3059: PUSH
3060: LD_INT 24
3062: PUSH
3063: EMPTY
3064: LIST
3065: LIST
3066: PUSH
3067: LD_INT 1
3069: PPUSH
3070: LD_INT 2
3072: PPUSH
3073: CALL_OW 12
3077: ARRAY
3078: PUSH
3079: LD_INT 1
3081: PUSH
3082: LD_INT 3
3084: PUSH
3085: LD_INT 46
3087: PUSH
3088: LD_INT 47
3090: PUSH
3091: LD_INT 45
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: PUSH
3099: LD_INT 1
3101: PPUSH
3102: LD_INT 3
3104: PPUSH
3105: CALL_OW 12
3109: ARRAY
3110: PUSH
3111: EMPTY
3112: LIST
3113: LIST
3114: LIST
3115: LIST
3116: PPUSH
3117: CALL_OW 2
3121: ST_TO_ADDR
3122: GO 3035
3124: POP
3125: POP
// MC_InsertProduceList ( base , tmp ) ;
3126: LD_VAR 0 2
3130: PPUSH
3131: LD_VAR 0 3
3135: PPUSH
3136: CALL 78645 0 2
// repeat wait ( 0 0$1 ) ;
3140: LD_INT 35
3142: PPUSH
3143: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3147: LD_EXP 77
3151: PUSH
3152: LD_VAR 0 2
3156: ARRAY
3157: PUSH
3158: LD_INT 6
3160: GREATER
3161: IFFALSE 3140
// wait ( 0 0$20 ) ;
3163: LD_INT 700
3165: PPUSH
3166: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3170: LD_ADDR_VAR 0 5
3174: PUSH
3175: LD_INT 71
3177: PUSH
3178: LD_INT 19
3180: PUSH
3181: EMPTY
3182: LIST
3183: LIST
3184: PUSH
3185: LD_INT 91
3187: PUSH
3188: LD_INT 67
3190: PUSH
3191: EMPTY
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 52
3197: PUSH
3198: LD_INT 44
3200: PUSH
3201: EMPTY
3202: LIST
3203: LIST
3204: PUSH
3205: LD_INT 68
3207: PUSH
3208: LD_INT 48
3210: PUSH
3211: EMPTY
3212: LIST
3213: LIST
3214: PUSH
3215: EMPTY
3216: LIST
3217: LIST
3218: LIST
3219: LIST
3220: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3221: LD_ADDR_VAR 0 6
3225: PUSH
3226: LD_EXP 77
3230: PUSH
3231: LD_VAR 0 2
3235: ARRAY
3236: PUSH
3237: LD_EXP 77
3241: PUSH
3242: LD_VAR 0 2
3246: ARRAY
3247: PPUSH
3248: LD_INT 2
3250: PUSH
3251: LD_INT 34
3253: PUSH
3254: LD_INT 51
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 34
3263: PUSH
3264: LD_INT 52
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: EMPTY
3272: LIST
3273: LIST
3274: LIST
3275: PPUSH
3276: CALL_OW 72
3280: DIFF
3281: ST_TO_ADDR
// if not attackers then
3282: LD_VAR 0 6
3286: NOT
3287: IFFALSE 3291
// exit ;
3289: GO 3460
// ru_attackers := attackers ;
3291: LD_ADDR_EXP 51
3295: PUSH
3296: LD_VAR 0 6
3300: ST_TO_ADDR
// for i = 1 to attackers do
3301: LD_ADDR_VAR 0 1
3305: PUSH
3306: DOUBLE
3307: LD_INT 1
3309: DEC
3310: ST_TO_ADDR
3311: LD_VAR 0 6
3315: PUSH
3316: FOR_TO
3317: IFFALSE 3394
// begin case i mod 3 of 0 :
3319: LD_VAR 0 1
3323: PUSH
3324: LD_INT 3
3326: MOD
3327: PUSH
3328: LD_INT 0
3330: DOUBLE
3331: EQUAL
3332: IFTRUE 3336
3334: GO 3339
3336: POP
// ; 1 :
3337: GO 3392
3339: LD_INT 1
3341: DOUBLE
3342: EQUAL
3343: IFTRUE 3347
3345: GO 3365
3347: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3348: LD_VAR 0 1
3352: PPUSH
3353: LD_INT 32
3355: PPUSH
3356: LD_INT 49
3358: PPUSH
3359: CALL_OW 114
3363: GO 3392
3365: LD_INT 2
3367: DOUBLE
3368: EQUAL
3369: IFTRUE 3373
3371: GO 3391
3373: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3374: LD_VAR 0 1
3378: PPUSH
3379: LD_INT 117
3381: PPUSH
3382: LD_INT 107
3384: PPUSH
3385: CALL_OW 114
3389: GO 3392
3391: POP
// end ;
3392: GO 3316
3394: POP
3395: POP
// repeat wait ( 0 0$1 ) ;
3396: LD_INT 35
3398: PPUSH
3399: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3403: LD_VAR 0 6
3407: PPUSH
3408: LD_INT 60
3410: PUSH
3411: EMPTY
3412: LIST
3413: PPUSH
3414: CALL_OW 72
3418: NOT
3419: IFFALSE 3396
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3421: LD_VAR 0 2
3425: PPUSH
3426: LD_VAR 0 6
3430: PPUSH
3431: LD_VAR 0 5
3435: PPUSH
3436: LD_VAR 0 4
3440: PPUSH
3441: CALL 78830 0 4
// if not first_attack then
3445: LD_EXP 7
3449: NOT
3450: IFFALSE 3460
// first_attack := true ;
3452: LD_ADDR_EXP 7
3456: PUSH
3457: LD_INT 1
3459: ST_TO_ADDR
// end ; end_of_file
3460: PPOPN 6
3462: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3463: LD_INT 0
3465: PPUSH
3466: PPUSH
3467: PPUSH
3468: PPUSH
3469: PPUSH
3470: PPUSH
3471: PPUSH
// uc_side := 2 ;
3472: LD_ADDR_OWVAR 20
3476: PUSH
3477: LD_INT 2
3479: ST_TO_ADDR
// uc_nation := 2 ;
3480: LD_ADDR_OWVAR 21
3484: PUSH
3485: LD_INT 2
3487: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3488: LD_ADDR_EXP 54
3492: PUSH
3493: LD_STRING Abdul
3495: PPUSH
3496: CALL_OW 25
3500: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3501: LD_EXP 54
3505: PPUSH
3506: LD_INT 11
3508: PPUSH
3509: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3513: LD_EXP 54
3517: PPUSH
3518: LD_INT 1
3520: PPUSH
3521: CALL_OW 52
// vc_chassis := 31 ;
3525: LD_ADDR_OWVAR 37
3529: PUSH
3530: LD_INT 31
3532: ST_TO_ADDR
// vc_control := control_rider ;
3533: LD_ADDR_OWVAR 38
3537: PUSH
3538: LD_INT 4
3540: ST_TO_ADDR
// mastodont := CreateVehicle ;
3541: LD_ADDR_EXP 55
3545: PUSH
3546: CALL_OW 45
3550: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3551: LD_EXP 55
3555: PPUSH
3556: LD_INT 153
3558: PPUSH
3559: LD_INT 71
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// InitVc ;
3569: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3573: LD_ADDR_EXP 52
3577: PUSH
3578: LD_INT 1
3580: PPUSH
3581: LD_INT 3
3583: PPUSH
3584: LD_STRING 
3586: PPUSH
3587: LD_INT 7
3589: PUSH
3590: LD_INT 8
3592: PUSH
3593: LD_INT 9
3595: PUSH
3596: EMPTY
3597: LIST
3598: LIST
3599: LIST
3600: PUSH
3601: LD_OWVAR 67
3605: ARRAY
3606: PPUSH
3607: LD_INT 5000
3609: PUSH
3610: LD_INT 1000
3612: PUSH
3613: LD_INT 300
3615: PUSH
3616: EMPTY
3617: LIST
3618: LIST
3619: LIST
3620: PPUSH
3621: LD_INT 22
3623: PUSH
3624: LD_INT 5
3626: PUSH
3627: LD_INT 6
3629: PUSH
3630: LD_INT 9
3632: PUSH
3633: EMPTY
3634: LIST
3635: LIST
3636: LIST
3637: LIST
3638: PPUSH
3639: CALL 23840 0 6
3643: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3644: LD_ADDR_EXP 58
3648: PUSH
3649: LD_EXP 58
3653: PPUSH
3654: LD_INT 1
3656: PPUSH
3657: LD_EXP 52
3661: PPUSH
3662: CALL_OW 1
3666: ST_TO_ADDR
// tmp := [ ] ;
3667: LD_ADDR_VAR 0 4
3671: PUSH
3672: EMPTY
3673: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3674: LD_ADDR_OWVAR 37
3678: PUSH
3679: LD_INT 14
3681: ST_TO_ADDR
// vc_engine := engine_siberite ;
3682: LD_ADDR_OWVAR 39
3686: PUSH
3687: LD_INT 3
3689: ST_TO_ADDR
// vc_control := control_manual ;
3690: LD_ADDR_OWVAR 38
3694: PUSH
3695: LD_INT 1
3697: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3698: LD_ADDR_OWVAR 40
3702: PUSH
3703: LD_INT 31
3705: ST_TO_ADDR
// for i = 1 to 3 do
3706: LD_ADDR_VAR 0 2
3710: PUSH
3711: DOUBLE
3712: LD_INT 1
3714: DEC
3715: ST_TO_ADDR
3716: LD_INT 3
3718: PUSH
3719: FOR_TO
3720: IFFALSE 3964
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3722: LD_ADDR_VAR 0 5
3726: PUSH
3727: LD_INT 153
3729: PUSH
3730: LD_INT 71
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: LD_INT 155
3739: PUSH
3740: LD_INT 81
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: PUSH
3751: LD_VAR 0 2
3755: PUSH
3756: LD_INT 2
3758: MOD
3759: PUSH
3760: LD_INT 1
3762: PLUS
3763: ARRAY
3764: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3765: LD_INT 0
3767: PPUSH
3768: LD_INT 3
3770: PPUSH
3771: LD_INT 7
3773: PUSH
3774: LD_INT 8
3776: PUSH
3777: LD_INT 9
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: LIST
3784: PUSH
3785: LD_OWVAR 67
3789: ARRAY
3790: PPUSH
3791: CALL_OW 380
// un := CreateVehicle ;
3795: LD_ADDR_VAR 0 6
3799: PUSH
3800: CALL_OW 45
3804: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3805: LD_VAR 0 6
3809: PPUSH
3810: LD_INT 0
3812: PPUSH
3813: LD_INT 5
3815: PPUSH
3816: CALL_OW 12
3820: PPUSH
3821: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3825: LD_VAR 0 6
3829: PPUSH
3830: LD_VAR 0 5
3834: PUSH
3835: LD_INT 1
3837: ARRAY
3838: PPUSH
3839: LD_VAR 0 5
3843: PUSH
3844: LD_INT 2
3846: ARRAY
3847: PPUSH
3848: LD_INT 6
3850: PPUSH
3851: LD_INT 0
3853: PPUSH
3854: CALL_OW 50
// un2 := CreateHuman ;
3858: LD_ADDR_VAR 0 7
3862: PUSH
3863: CALL_OW 44
3867: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3868: LD_VAR 0 7
3872: PPUSH
3873: LD_VAR 0 6
3877: PPUSH
3878: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3882: LD_ADDR_EXP 58
3886: PUSH
3887: LD_EXP 58
3891: PPUSH
3892: LD_INT 1
3894: PUSH
3895: LD_EXP 58
3899: PUSH
3900: LD_INT 1
3902: ARRAY
3903: PUSH
3904: LD_INT 1
3906: PLUS
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PPUSH
3912: LD_VAR 0 6
3916: PPUSH
3917: CALL 20553 0 3
3921: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3922: LD_ADDR_EXP 58
3926: PUSH
3927: LD_EXP 58
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_EXP 58
3939: PUSH
3940: LD_INT 1
3942: ARRAY
3943: PUSH
3944: LD_INT 1
3946: PLUS
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PPUSH
3952: LD_VAR 0 7
3956: PPUSH
3957: CALL 20553 0 3
3961: ST_TO_ADDR
// end ;
3962: GO 3719
3964: POP
3965: POP
// for i = 1 to 5 do
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: DOUBLE
3972: LD_INT 1
3974: DEC
3975: ST_TO_ADDR
3976: LD_INT 5
3978: PUSH
3979: FOR_TO
3980: IFFALSE 4073
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3982: LD_INT 14
3984: PPUSH
3985: LD_INT 3
3987: PPUSH
3988: LD_INT 1
3990: PPUSH
3991: LD_INT 25
3993: PUSH
3994: LD_INT 28
3996: PUSH
3997: LD_INT 28
3999: PUSH
4000: LD_INT 26
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: LIST
4007: LIST
4008: PUSH
4009: LD_VAR 0 2
4013: PUSH
4014: LD_INT 4
4016: MOD
4017: PUSH
4018: LD_INT 1
4020: PLUS
4021: ARRAY
4022: PPUSH
4023: LD_INT 100
4025: PPUSH
4026: CALL 20431 0 5
// veh := CreateVehicle ;
4030: LD_ADDR_VAR 0 3
4034: PUSH
4035: CALL_OW 45
4039: ST_TO_ADDR
// tmp := tmp ^ veh ;
4040: LD_ADDR_VAR 0 4
4044: PUSH
4045: LD_VAR 0 4
4049: PUSH
4050: LD_VAR 0 3
4054: ADD
4055: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4056: LD_VAR 0 3
4060: PPUSH
4061: LD_INT 1
4063: PPUSH
4064: LD_INT 0
4066: PPUSH
4067: CALL_OW 49
// end ;
4071: GO 3979
4073: POP
4074: POP
// arabian_guard := tmp ;
4075: LD_ADDR_EXP 53
4079: PUSH
4080: LD_VAR 0 4
4084: ST_TO_ADDR
// end ;
4085: LD_VAR 0 1
4089: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4090: LD_INT 22
4092: PUSH
4093: LD_INT 7
4095: PUSH
4096: EMPTY
4097: LIST
4098: LIST
4099: PUSH
4100: LD_INT 91
4102: PUSH
4103: LD_INT 1
4105: PUSH
4106: LD_INT 12
4108: PUSH
4109: EMPTY
4110: LIST
4111: LIST
4112: LIST
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: PPUSH
4118: CALL_OW 69
4122: PUSH
4123: LD_EXP 55
4127: PPUSH
4128: CALL_OW 256
4132: PUSH
4133: LD_INT 990
4135: LESS
4136: OR
4137: PUSH
4138: LD_EXP 54
4142: PPUSH
4143: CALL_OW 256
4147: PUSH
4148: LD_INT 990
4150: LESS
4151: OR
4152: IFFALSE 4295
4154: GO 4156
4156: DISABLE
// begin if IsInUnit ( Abdul ) then
4157: LD_EXP 54
4161: PPUSH
4162: CALL_OW 310
4166: IFFALSE 4177
// ComExitBuilding ( Abdul ) ;
4168: LD_EXP 54
4172: PPUSH
4173: CALL_OW 122
// if Mastodont then
4177: LD_EXP 55
4181: IFFALSE 4198
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4183: LD_EXP 55
4187: PPUSH
4188: LD_INT 205
4190: PPUSH
4191: LD_INT 132
4193: PPUSH
4194: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4198: LD_EXP 54
4202: PPUSH
4203: LD_INT 205
4205: PPUSH
4206: LD_INT 132
4208: PPUSH
4209: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4213: LD_INT 35
4215: PPUSH
4216: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4220: LD_EXP 54
4224: PPUSH
4225: LD_INT 21
4227: PPUSH
4228: CALL_OW 308
4232: IFFALSE 4213
// RemoveUnit ( Abdul ) ;
4234: LD_EXP 54
4238: PPUSH
4239: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4243: LD_INT 35
4245: PPUSH
4246: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4250: LD_EXP 55
4254: PPUSH
4255: LD_INT 21
4257: PPUSH
4258: CALL_OW 308
4262: PUSH
4263: LD_EXP 55
4267: PPUSH
4268: CALL_OW 301
4272: OR
4273: IFFALSE 4243
// if IsOk ( Mastodont ) then
4275: LD_EXP 55
4279: PPUSH
4280: CALL_OW 302
4284: IFFALSE 4295
// RemoveUnit ( Mastodont ) ;
4286: LD_EXP 55
4290: PPUSH
4291: CALL_OW 64
// end ;
4295: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4296: LD_EXP 54
4300: PPUSH
4301: CALL_OW 301
4305: PUSH
4306: LD_INT 22
4308: PUSH
4309: LD_INT 2
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 2
4318: PUSH
4319: LD_INT 25
4321: PUSH
4322: LD_INT 1
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: LD_INT 25
4331: PUSH
4332: LD_INT 2
4334: PUSH
4335: EMPTY
4336: LIST
4337: LIST
4338: PUSH
4339: LD_INT 25
4341: PUSH
4342: LD_INT 3
4344: PUSH
4345: EMPTY
4346: LIST
4347: LIST
4348: PUSH
4349: LD_INT 25
4351: PUSH
4352: LD_INT 4
4354: PUSH
4355: EMPTY
4356: LIST
4357: LIST
4358: PUSH
4359: LD_INT 25
4361: PUSH
4362: LD_INT 8
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: LIST
4373: LIST
4374: LIST
4375: LIST
4376: PUSH
4377: EMPTY
4378: LIST
4379: LIST
4380: PPUSH
4381: CALL_OW 69
4385: PUSH
4386: LD_INT 16
4388: PUSH
4389: LD_INT 19
4391: PUSH
4392: LD_INT 22
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: LIST
4399: PUSH
4400: LD_OWVAR 67
4404: ARRAY
4405: LESS
4406: OR
4407: IFFALSE 5080
4409: GO 4411
4411: DISABLE
4412: LD_INT 0
4414: PPUSH
4415: PPUSH
4416: PPUSH
4417: PPUSH
4418: PPUSH
4419: PPUSH
// begin MC_Kill ( 1 ) ;
4420: LD_INT 1
4422: PPUSH
4423: CALL 56566 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4427: LD_ADDR_VAR 0 2
4431: PUSH
4432: LD_INT 22
4434: PUSH
4435: LD_INT 2
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 2
4444: PUSH
4445: LD_INT 25
4447: PUSH
4448: LD_INT 1
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PUSH
4455: LD_INT 25
4457: PUSH
4458: LD_INT 2
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 25
4467: PUSH
4468: LD_INT 3
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 25
4477: PUSH
4478: LD_INT 4
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: PUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 8
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: EMPTY
4496: LIST
4497: LIST
4498: LIST
4499: LIST
4500: LIST
4501: LIST
4502: PUSH
4503: EMPTY
4504: LIST
4505: LIST
4506: PPUSH
4507: CALL_OW 69
4511: ST_TO_ADDR
// for i in tmp do
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_VAR 0 2
4521: PUSH
4522: FOR_IN
4523: IFFALSE 4539
// SetTag ( i , 10 ) ;
4525: LD_VAR 0 5
4529: PPUSH
4530: LD_INT 10
4532: PPUSH
4533: CALL_OW 109
4537: GO 4522
4539: POP
4540: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4541: LD_ADDR_VAR 0 3
4545: PUSH
4546: LD_INT 22
4548: PUSH
4549: LD_INT 2
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 21
4558: PUSH
4559: LD_INT 1
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PPUSH
4570: CALL_OW 69
4574: PUSH
4575: LD_VAR 0 2
4579: DIFF
4580: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4581: LD_ADDR_VAR 0 1
4585: PUSH
4586: LD_INT 22
4588: PUSH
4589: LD_INT 2
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: LD_INT 21
4598: PUSH
4599: LD_INT 2
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: PUSH
4606: LD_INT 24
4608: PUSH
4609: LD_INT 300
4611: PUSH
4612: EMPTY
4613: LIST
4614: LIST
4615: PUSH
4616: EMPTY
4617: LIST
4618: LIST
4619: LIST
4620: PPUSH
4621: CALL_OW 69
4625: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4626: LD_ADDR_VAR 0 4
4630: PUSH
4631: LD_VAR 0 1
4635: PPUSH
4636: LD_INT 33
4638: PUSH
4639: LD_INT 1
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 58
4648: PUSH
4649: EMPTY
4650: LIST
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PPUSH
4656: CALL_OW 72
4660: ST_TO_ADDR
// for i in tmp do
4661: LD_ADDR_VAR 0 5
4665: PUSH
4666: LD_VAR 0 2
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4856
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4674: LD_VAR 0 5
4678: PUSH
4679: LD_INT 55
4681: PUSH
4682: EMPTY
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: IN
4690: IFFALSE 4709
// begin AddComMoveXY ( i , 209 , 132 ) ;
4692: LD_VAR 0 5
4696: PPUSH
4697: LD_INT 209
4699: PPUSH
4700: LD_INT 132
4702: PPUSH
4703: CALL_OW 171
// continue ;
4707: GO 4671
// end ; if IsInUnit ( i ) then
4709: LD_VAR 0 5
4713: PPUSH
4714: CALL_OW 310
4718: IFFALSE 4736
// begin ComExitBuilding ( i ) ;
4720: LD_VAR 0 5
4724: PPUSH
4725: CALL_OW 122
// wait ( 3 ) ;
4729: LD_INT 3
4731: PPUSH
4732: CALL_OW 67
// end ; if tmp_empty then
4736: LD_VAR 0 4
4740: IFFALSE 4839
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4742: LD_VAR 0 5
4746: PPUSH
4747: LD_VAR 0 4
4751: PPUSH
4752: LD_VAR 0 5
4756: PPUSH
4757: CALL_OW 74
4761: PPUSH
4762: CALL_OW 296
4766: PUSH
4767: LD_INT 25
4769: LESS
4770: IFFALSE 4839
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4772: LD_ADDR_VAR 0 6
4776: PUSH
4777: LD_VAR 0 4
4781: PPUSH
4782: LD_VAR 0 5
4786: PPUSH
4787: CALL_OW 74
4791: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4792: LD_VAR 0 5
4796: PPUSH
4797: LD_VAR 0 6
4801: PPUSH
4802: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4806: LD_VAR 0 5
4810: PPUSH
4811: LD_INT 209
4813: PPUSH
4814: LD_INT 132
4816: PPUSH
4817: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4821: LD_ADDR_VAR 0 4
4825: PUSH
4826: LD_VAR 0 4
4830: PUSH
4831: LD_VAR 0 6
4835: DIFF
4836: ST_TO_ADDR
// continue ;
4837: GO 4671
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4839: LD_VAR 0 5
4843: PPUSH
4844: LD_INT 201
4846: PPUSH
4847: LD_INT 132
4849: PPUSH
4850: CALL_OW 171
// end ;
4854: GO 4671
4856: POP
4857: POP
// for i in tmp_ape do
4858: LD_ADDR_VAR 0 5
4862: PUSH
4863: LD_VAR 0 3
4867: PUSH
4868: FOR_IN
4869: IFFALSE 4908
// begin if IsInUnit ( i ) then
4871: LD_VAR 0 5
4875: PPUSH
4876: CALL_OW 310
4880: IFFALSE 4891
// ComExitBuilding ( i ) ;
4882: LD_VAR 0 5
4886: PPUSH
4887: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4891: LD_VAR 0 5
4895: PPUSH
4896: LD_INT 201
4898: PPUSH
4899: LD_INT 132
4901: PPUSH
4902: CALL_OW 171
// end ;
4906: GO 4868
4908: POP
4909: POP
// repeat wait ( 0 0$1 ) ;
4910: LD_INT 35
4912: PPUSH
4913: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4917: LD_ADDR_VAR 0 5
4921: PUSH
4922: LD_VAR 0 2
4926: PUSH
4927: LD_VAR 0 3
4931: UNION
4932: PUSH
4933: LD_VAR 0 1
4937: UNION
4938: PUSH
4939: FOR_IN
4940: IFFALSE 4971
// if not HasTask ( i ) then
4942: LD_VAR 0 5
4946: PPUSH
4947: CALL_OW 314
4951: NOT
4952: IFFALSE 4969
// ComMoveXY ( i , 201 , 132 ) ;
4954: LD_VAR 0 5
4958: PPUSH
4959: LD_INT 201
4961: PPUSH
4962: LD_INT 132
4964: PPUSH
4965: CALL_OW 111
4969: GO 4939
4971: POP
4972: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4973: LD_INT 21
4975: PPUSH
4976: LD_INT 22
4978: PUSH
4979: LD_INT 2
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: PPUSH
4986: CALL_OW 70
4990: IFFALSE 5031
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4992: LD_ADDR_VAR 0 5
4996: PUSH
4997: LD_INT 21
4999: PPUSH
5000: LD_INT 22
5002: PUSH
5003: LD_INT 2
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PPUSH
5010: CALL_OW 70
5014: PUSH
5015: FOR_IN
5016: IFFALSE 5029
// RemoveUnit ( i ) ;
5018: LD_VAR 0 5
5022: PPUSH
5023: CALL_OW 64
5027: GO 5015
5029: POP
5030: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5031: LD_INT 22
5033: PUSH
5034: LD_INT 2
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: PUSH
5041: LD_INT 2
5043: PUSH
5044: LD_INT 21
5046: PUSH
5047: LD_INT 1
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: PUSH
5054: LD_INT 21
5056: PUSH
5057: LD_INT 2
5059: PUSH
5060: EMPTY
5061: LIST
5062: LIST
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: LIST
5068: PUSH
5069: EMPTY
5070: LIST
5071: LIST
5072: PPUSH
5073: CALL_OW 69
5077: NOT
5078: IFFALSE 4910
// end ;
5080: PPOPN 6
5082: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5083: LD_EXP 9
5087: PUSH
5088: LD_INT 92
5090: PPUSH
5091: LD_INT 40
5093: PPUSH
5094: CALL_OW 428
5098: PPUSH
5099: CALL_OW 266
5103: PUSH
5104: LD_INT 30
5106: EQUAL
5107: AND
5108: IFFALSE 5304
5110: GO 5112
5112: DISABLE
5113: LD_INT 0
5115: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5116: LD_ADDR_VAR 0 1
5120: PUSH
5121: LD_EXP 58
5125: PUSH
5126: LD_INT 1
5128: ARRAY
5129: PPUSH
5130: LD_INT 25
5132: PUSH
5133: LD_INT 4
5135: PUSH
5136: EMPTY
5137: LIST
5138: LIST
5139: PPUSH
5140: CALL_OW 72
5144: ST_TO_ADDR
// if not sci then
5145: LD_VAR 0 1
5149: NOT
5150: IFFALSE 5154
// exit ;
5152: GO 5304
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5154: LD_ADDR_EXP 58
5158: PUSH
5159: LD_EXP 58
5163: PPUSH
5164: LD_INT 1
5166: PPUSH
5167: LD_EXP 58
5171: PUSH
5172: LD_INT 1
5174: ARRAY
5175: PUSH
5176: LD_VAR 0 1
5180: PUSH
5181: LD_INT 1
5183: ARRAY
5184: DIFF
5185: PPUSH
5186: CALL_OW 1
5190: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5191: LD_VAR 0 1
5195: PUSH
5196: LD_INT 1
5198: ARRAY
5199: PPUSH
5200: CALL_OW 310
5204: IFFALSE 5219
// ComExitBuilding ( sci [ 1 ] ) ;
5206: LD_VAR 0 1
5210: PUSH
5211: LD_INT 1
5213: ARRAY
5214: PPUSH
5215: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5219: LD_INT 2
5221: PPUSH
5222: LD_INT 105
5224: PPUSH
5225: LD_INT 14
5227: PPUSH
5228: LD_INT 20
5230: PPUSH
5231: CALL 21449 0 4
5235: PUSH
5236: LD_INT 4
5238: ARRAY
5239: PUSH
5240: LD_INT 10
5242: LESS
5243: IFFALSE 5266
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5245: LD_VAR 0 1
5249: PUSH
5250: LD_INT 1
5252: ARRAY
5253: PPUSH
5254: LD_INT 105
5256: PPUSH
5257: LD_INT 14
5259: PPUSH
5260: CALL_OW 171
5264: GO 5285
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5266: LD_VAR 0 1
5270: PUSH
5271: LD_INT 1
5273: ARRAY
5274: PPUSH
5275: LD_INT 118
5277: PPUSH
5278: LD_INT 77
5280: PPUSH
5281: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5285: LD_VAR 0 1
5289: PUSH
5290: LD_INT 1
5292: ARRAY
5293: PPUSH
5294: LD_INT 92
5296: PPUSH
5297: LD_INT 40
5299: PPUSH
5300: CALL_OW 218
// end ;
5304: PPOPN 1
5306: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5307: LD_INT 1
5309: PPUSH
5310: CALL_OW 302
5314: PUSH
5315: LD_EXP 9
5319: AND
5320: IFFALSE 5779
5322: GO 5324
5324: DISABLE
5325: LD_INT 0
5327: PPUSH
5328: PPUSH
5329: PPUSH
5330: PPUSH
5331: PPUSH
5332: PPUSH
// begin enable ;
5333: ENABLE
// base := 1 ;
5334: LD_ADDR_VAR 0 2
5338: PUSH
5339: LD_INT 1
5341: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5342: LD_ADDR_VAR 0 4
5346: PUSH
5347: LD_INT 0
5349: PUSH
5350: LD_INT 0
5352: PUSH
5353: LD_INT 0
5355: PUSH
5356: LD_INT 0
5358: PUSH
5359: LD_INT 0
5361: PUSH
5362: LD_INT 0
5364: PUSH
5365: LD_INT 0
5367: PUSH
5368: LD_INT 0
5370: PUSH
5371: LD_INT 1
5373: PUSH
5374: LD_INT 0
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: LIST
5382: LIST
5383: LIST
5384: LIST
5385: LIST
5386: LIST
5387: LIST
5388: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5389: LD_ADDR_VAR 0 3
5393: PUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 2
5402: PUSH
5403: LD_INT 26
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 2
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 13
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 2
5438: PUSH
5439: LD_INT 29
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5453: LD_ADDR_VAR 0 1
5457: PUSH
5458: DOUBLE
5459: LD_INT 1
5461: DEC
5462: ST_TO_ADDR
5463: LD_OWVAR 67
5467: PUSH
5468: LD_OWVAR 1
5472: PUSH
5473: LD_INT 21000
5475: DIV
5476: PLUS
5477: PUSH
5478: FOR_TO
5479: IFFALSE 5571
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5481: LD_ADDR_VAR 0 3
5485: PUSH
5486: LD_VAR 0 3
5490: PPUSH
5491: LD_VAR 0 3
5495: PUSH
5496: LD_INT 1
5498: PLUS
5499: PPUSH
5500: LD_INT 13
5502: PUSH
5503: LD_INT 14
5505: PUSH
5506: EMPTY
5507: LIST
5508: LIST
5509: PUSH
5510: LD_INT 1
5512: PPUSH
5513: LD_INT 2
5515: PPUSH
5516: CALL_OW 12
5520: ARRAY
5521: PUSH
5522: LD_INT 1
5524: PUSH
5525: LD_INT 2
5527: PUSH
5528: LD_INT 28
5530: PUSH
5531: LD_INT 29
5533: PUSH
5534: LD_INT 25
5536: PUSH
5537: LD_INT 26
5539: PUSH
5540: EMPTY
5541: LIST
5542: LIST
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 1
5548: PPUSH
5549: LD_INT 4
5551: PPUSH
5552: CALL_OW 12
5556: ARRAY
5557: PUSH
5558: EMPTY
5559: LIST
5560: LIST
5561: LIST
5562: LIST
5563: PPUSH
5564: CALL_OW 2
5568: ST_TO_ADDR
5569: GO 5478
5571: POP
5572: POP
// MC_InsertProduceList ( base , tmp ) ;
5573: LD_VAR 0 2
5577: PPUSH
5578: LD_VAR 0 3
5582: PPUSH
5583: CALL 78645 0 2
// repeat wait ( 0 0$1 ) ;
5587: LD_INT 35
5589: PPUSH
5590: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5594: LD_EXP 77
5598: PUSH
5599: LD_VAR 0 2
5603: ARRAY
5604: PUSH
5605: LD_INT 6
5607: GREATER
5608: IFFALSE 5587
// wait ( 0 0$20 ) ;
5610: LD_INT 700
5612: PPUSH
5613: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5617: LD_ADDR_VAR 0 5
5621: PUSH
5622: LD_INT 124
5624: PUSH
5625: LD_INT 85
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: PUSH
5632: LD_INT 90
5634: PUSH
5635: LD_INT 61
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PUSH
5642: LD_INT 69
5644: PUSH
5645: LD_INT 48
5647: PUSH
5648: EMPTY
5649: LIST
5650: LIST
5651: PUSH
5652: LD_INT 68
5654: PUSH
5655: LD_INT 48
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5668: LD_ADDR_VAR 0 6
5672: PUSH
5673: LD_EXP 77
5677: PUSH
5678: LD_VAR 0 2
5682: ARRAY
5683: PUSH
5684: LD_EXP 77
5688: PUSH
5689: LD_VAR 0 2
5693: ARRAY
5694: PPUSH
5695: LD_INT 34
5697: PUSH
5698: LD_INT 32
5700: PUSH
5701: EMPTY
5702: LIST
5703: LIST
5704: PPUSH
5705: CALL_OW 72
5709: DIFF
5710: ST_TO_ADDR
// if not attackers then
5711: LD_VAR 0 6
5715: NOT
5716: IFFALSE 5720
// exit ;
5718: GO 5779
// ar_attackers := attackers ;
5720: LD_ADDR_EXP 10
5724: PUSH
5725: LD_VAR 0 6
5729: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5730: LD_INT 35
5732: PPUSH
5733: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5737: LD_VAR 0 6
5741: PPUSH
5742: LD_INT 60
5744: PUSH
5745: EMPTY
5746: LIST
5747: PPUSH
5748: CALL_OW 72
5752: NOT
5753: IFFALSE 5730
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5755: LD_VAR 0 2
5759: PPUSH
5760: LD_VAR 0 6
5764: PPUSH
5765: LD_VAR 0 5
5769: PPUSH
5770: LD_VAR 0 4
5774: PPUSH
5775: CALL 78830 0 4
// end ;
5779: PPOPN 6
5781: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5782: LD_INT 1
5784: PPUSH
5785: CALL_OW 302
5789: PUSH
5790: LD_EXP 9
5794: AND
5795: PUSH
5796: LD_EXP 48
5800: PPUSH
5801: LD_INT 22
5803: PPUSH
5804: CALL_OW 308
5808: AND
5809: PUSH
5810: LD_INT 1
5812: PPUSH
5813: CALL 78993 0 1
5817: PUSH
5818: LD_INT 0
5820: EQUAL
5821: AND
5822: PUSH
5823: LD_EXP 10
5827: NOT
5828: AND
5829: IFFALSE 6293
5831: GO 5833
5833: DISABLE
5834: LD_INT 0
5836: PPUSH
5837: PPUSH
5838: PPUSH
5839: PPUSH
5840: PPUSH
5841: PPUSH
5842: PPUSH
// begin base := 1 ;
5843: LD_ADDR_VAR 0 2
5847: PUSH
5848: LD_INT 1
5850: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5851: LD_ADDR_VAR 0 4
5855: PUSH
5856: LD_INT 0
5858: PUSH
5859: LD_INT 0
5861: PUSH
5862: LD_INT 0
5864: PUSH
5865: LD_INT 0
5867: PUSH
5868: LD_INT 0
5870: PUSH
5871: LD_INT 0
5873: PUSH
5874: LD_INT 0
5876: PUSH
5877: LD_INT 0
5879: PUSH
5880: LD_INT 1
5882: PUSH
5883: LD_INT 0
5885: PUSH
5886: EMPTY
5887: LIST
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5898: LD_ADDR_VAR 0 3
5902: PUSH
5903: LD_INT 13
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 28
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: LD_INT 13
5923: PUSH
5924: LD_INT 1
5926: PUSH
5927: LD_INT 2
5929: PUSH
5930: LD_INT 27
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: PUSH
5939: LD_INT 13
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 2
5947: PUSH
5948: LD_INT 25
5950: PUSH
5951: EMPTY
5952: LIST
5953: LIST
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 11
5959: PUSH
5960: LD_INT 2
5962: PUSH
5963: LD_INT 2
5965: PUSH
5966: LD_INT 24
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: LIST
5973: LIST
5974: PUSH
5975: LD_INT 11
5977: PUSH
5978: LD_INT 2
5980: PUSH
5981: LD_INT 2
5983: PUSH
5984: LD_INT 24
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: LIST
5991: LIST
5992: PUSH
5993: EMPTY
5994: LIST
5995: LIST
5996: LIST
5997: LIST
5998: LIST
5999: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6000: LD_VAR 0 2
6004: PPUSH
6005: LD_VAR 0 3
6009: PPUSH
6010: CALL 78645 0 2
// repeat wait ( 0 0$1 ) ;
6014: LD_INT 35
6016: PPUSH
6017: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6021: LD_EXP 77
6025: PUSH
6026: LD_VAR 0 2
6030: ARRAY
6031: PUSH
6032: LD_INT 6
6034: GREATEREQUAL
6035: IFFALSE 6014
// wait ( 0 0$20 ) ;
6037: LD_INT 700
6039: PPUSH
6040: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6044: LD_ADDR_VAR 0 5
6048: PUSH
6049: LD_INT 119
6051: PUSH
6052: LD_INT 9
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6062: LD_ADDR_VAR 0 6
6066: PUSH
6067: LD_EXP 77
6071: PUSH
6072: LD_VAR 0 2
6076: ARRAY
6077: PUSH
6078: LD_EXP 77
6082: PUSH
6083: LD_VAR 0 2
6087: ARRAY
6088: PPUSH
6089: LD_INT 34
6091: PUSH
6092: LD_INT 32
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PPUSH
6099: CALL_OW 72
6103: DIFF
6104: ST_TO_ADDR
// if not attackers then
6105: LD_VAR 0 6
6109: NOT
6110: IFFALSE 6114
// exit ;
6112: GO 6293
// uc_side := 2 ;
6114: LD_ADDR_OWVAR 20
6118: PUSH
6119: LD_INT 2
6121: ST_TO_ADDR
// uc_nation := 2 ;
6122: LD_ADDR_OWVAR 21
6126: PUSH
6127: LD_INT 2
6129: ST_TO_ADDR
// InitHc ;
6130: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6134: LD_ADDR_VAR 0 1
6138: PUSH
6139: DOUBLE
6140: LD_INT 1
6142: DEC
6143: ST_TO_ADDR
6144: LD_INT 4
6146: PUSH
6147: LD_INT 5
6149: PUSH
6150: LD_INT 6
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: LIST
6157: PUSH
6158: LD_OWVAR 67
6162: ARRAY
6163: PUSH
6164: FOR_TO
6165: IFFALSE 6242
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6167: LD_INT 0
6169: PPUSH
6170: LD_INT 15
6172: PUSH
6173: LD_INT 17
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PUSH
6180: LD_INT 1
6182: PPUSH
6183: LD_INT 2
6185: PPUSH
6186: CALL_OW 12
6190: ARRAY
6191: PPUSH
6192: LD_INT 8
6194: PPUSH
6195: CALL_OW 380
// un := CreateHuman ;
6199: LD_ADDR_VAR 0 7
6203: PUSH
6204: CALL_OW 44
6208: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6209: LD_VAR 0 7
6213: PPUSH
6214: LD_INT 23
6216: PPUSH
6217: LD_INT 0
6219: PPUSH
6220: CALL_OW 49
// attackers := attackers union un ;
6224: LD_ADDR_VAR 0 6
6228: PUSH
6229: LD_VAR 0 6
6233: PUSH
6234: LD_VAR 0 7
6238: UNION
6239: ST_TO_ADDR
// end ;
6240: GO 6164
6242: POP
6243: POP
// repeat wait ( 0 0$1 ) ;
6244: LD_INT 35
6246: PPUSH
6247: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6251: LD_VAR 0 6
6255: PPUSH
6256: LD_INT 60
6258: PUSH
6259: EMPTY
6260: LIST
6261: PPUSH
6262: CALL_OW 72
6266: NOT
6267: IFFALSE 6244
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6269: LD_VAR 0 2
6273: PPUSH
6274: LD_VAR 0 6
6278: PPUSH
6279: LD_VAR 0 5
6283: PPUSH
6284: LD_VAR 0 4
6288: PPUSH
6289: CALL 78830 0 4
// end ; end_of_file
6293: PPOPN 7
6295: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6296: LD_INT 0
6298: PPUSH
6299: PPUSH
6300: PPUSH
6301: PPUSH
// uc_side := 1 ;
6302: LD_ADDR_OWVAR 20
6306: PUSH
6307: LD_INT 1
6309: ST_TO_ADDR
// uc_nation := 1 ;
6310: LD_ADDR_OWVAR 21
6314: PUSH
6315: LD_INT 1
6317: ST_TO_ADDR
// InitHc ;
6318: CALL_OW 19
// InitVc ;
6322: CALL_OW 20
// tmp := [ ] ;
6326: LD_ADDR_VAR 0 3
6330: PUSH
6331: EMPTY
6332: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6333: LD_ADDR_VAR 0 2
6337: PUSH
6338: DOUBLE
6339: LD_INT 1
6341: DEC
6342: ST_TO_ADDR
6343: LD_INT 5
6345: PUSH
6346: LD_INT 6
6348: PUSH
6349: LD_INT 6
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: LIST
6356: PUSH
6357: LD_OWVAR 67
6361: ARRAY
6362: PUSH
6363: FOR_TO
6364: IFFALSE 6501
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6366: LD_INT 2
6368: PUSH
6369: LD_INT 4
6371: PUSH
6372: LD_INT 5
6374: PUSH
6375: EMPTY
6376: LIST
6377: LIST
6378: LIST
6379: PUSH
6380: LD_INT 1
6382: PPUSH
6383: LD_INT 3
6385: PPUSH
6386: CALL_OW 12
6390: ARRAY
6391: PPUSH
6392: LD_INT 1
6394: PUSH
6395: LD_INT 3
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PUSH
6402: LD_INT 1
6404: PPUSH
6405: LD_INT 2
6407: PPUSH
6408: CALL_OW 12
6412: ARRAY
6413: PPUSH
6414: LD_INT 3
6416: PPUSH
6417: LD_INT 9
6419: PUSH
6420: LD_INT 7
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 1
6429: PPUSH
6430: LD_INT 2
6432: PPUSH
6433: CALL_OW 12
6437: ARRAY
6438: PPUSH
6439: LD_INT 78
6441: PPUSH
6442: CALL 20431 0 5
// veh := CreateVehicle ;
6446: LD_ADDR_VAR 0 4
6450: PUSH
6451: CALL_OW 45
6455: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6456: LD_VAR 0 4
6460: PPUSH
6461: LD_INT 2
6463: PPUSH
6464: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6468: LD_VAR 0 4
6472: PPUSH
6473: LD_INT 17
6475: PPUSH
6476: LD_INT 0
6478: PPUSH
6479: CALL_OW 49
// tmp := tmp ^ veh ;
6483: LD_ADDR_VAR 0 3
6487: PUSH
6488: LD_VAR 0 3
6492: PUSH
6493: LD_VAR 0 4
6497: ADD
6498: ST_TO_ADDR
// end ;
6499: GO 6363
6501: POP
6502: POP
// if not tmp then
6503: LD_VAR 0 3
6507: NOT
6508: IFFALSE 6512
// exit ;
6510: GO 6621
// if not first_powell_attack then
6512: LD_EXP 11
6516: NOT
6517: IFFALSE 6527
// first_powell_attack := true ;
6519: LD_ADDR_EXP 11
6523: PUSH
6524: LD_INT 1
6526: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6527: LD_INT 70
6529: PPUSH
6530: CALL_OW 67
// for i in tmp do
6534: LD_ADDR_VAR 0 2
6538: PUSH
6539: LD_VAR 0 3
6543: PUSH
6544: FOR_IN
6545: IFFALSE 6612
// if IsOk ( i ) then
6547: LD_VAR 0 2
6551: PPUSH
6552: CALL_OW 302
6556: IFFALSE 6594
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6558: LD_VAR 0 2
6562: PPUSH
6563: LD_INT 81
6565: PUSH
6566: LD_INT 1
6568: PUSH
6569: EMPTY
6570: LIST
6571: LIST
6572: PPUSH
6573: CALL_OW 69
6577: PPUSH
6578: LD_VAR 0 2
6582: PPUSH
6583: CALL_OW 74
6587: PPUSH
6588: CALL_OW 115
6592: GO 6610
// tmp := tmp diff i ;
6594: LD_ADDR_VAR 0 3
6598: PUSH
6599: LD_VAR 0 3
6603: PUSH
6604: LD_VAR 0 2
6608: DIFF
6609: ST_TO_ADDR
6610: GO 6544
6612: POP
6613: POP
// until not tmp ;
6614: LD_VAR 0 3
6618: NOT
6619: IFFALSE 6527
// end ; end_of_file
6621: LD_VAR 0 1
6625: RET
// export function Action ; var tmp , i , un ; begin
6626: LD_INT 0
6628: PPUSH
6629: PPUSH
6630: PPUSH
6631: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6632: LD_INT 68
6634: PPUSH
6635: LD_INT 39
6637: PPUSH
6638: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6642: LD_ADDR_VAR 0 2
6646: PUSH
6647: LD_INT 22
6649: PUSH
6650: LD_INT 7
6652: PUSH
6653: EMPTY
6654: LIST
6655: LIST
6656: PPUSH
6657: CALL_OW 69
6661: ST_TO_ADDR
// InGameOn ;
6662: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6666: LD_VAR 0 2
6670: PPUSH
6671: LD_INT 71
6673: PPUSH
6674: LD_INT 49
6676: PPUSH
6677: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6681: LD_INT 35
6683: PPUSH
6684: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6688: LD_INT 7
6690: PPUSH
6691: LD_INT 71
6693: PPUSH
6694: LD_INT 51
6696: PPUSH
6697: CALL_OW 293
6701: IFFALSE 6681
// DialogueOn ;
6703: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6707: LD_EXP 14
6711: PPUSH
6712: LD_STRING D1-JMM-1
6714: PPUSH
6715: CALL_OW 88
// if Joan then
6719: LD_EXP 29
6723: IFFALSE 6737
// Say ( Joan , D1-Joan-1 ) ;
6725: LD_EXP 29
6729: PPUSH
6730: LD_STRING D1-Joan-1
6732: PPUSH
6733: CALL_OW 88
// if Lisa then
6737: LD_EXP 16
6741: IFFALSE 6755
// Say ( Lisa , D1-Lisa-1 ) ;
6743: LD_EXP 16
6747: PPUSH
6748: LD_STRING D1-Lisa-1
6750: PPUSH
6751: CALL_OW 88
// if Joan or Lisa then
6755: LD_EXP 29
6759: PUSH
6760: LD_EXP 16
6764: OR
6765: IFFALSE 6779
// Say ( JMM , D1-JMM-2 ) ;
6767: LD_EXP 14
6771: PPUSH
6772: LD_STRING D1-JMM-2
6774: PPUSH
6775: CALL_OW 88
// DialogueOff ;
6779: CALL_OW 7
// InGameOff ;
6783: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6787: LD_INT 71
6789: PPUSH
6790: LD_INT 50
6792: PPUSH
6793: LD_INT 7
6795: PPUSH
6796: LD_INT 30
6798: NEG
6799: PPUSH
6800: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6804: LD_INT 71
6806: PPUSH
6807: LD_INT 50
6809: PPUSH
6810: LD_INT 7
6812: PPUSH
6813: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6817: LD_STRING M1
6819: PPUSH
6820: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6824: LD_INT 35
6826: PPUSH
6827: CALL_OW 67
// until freedom ;
6831: LD_EXP 3
6835: IFFALSE 6824
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6837: LD_INT 350
6839: PPUSH
6840: LD_INT 700
6842: PPUSH
6843: CALL_OW 12
6847: PPUSH
6848: CALL_OW 67
// PrepareGossudarov ;
6852: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6856: LD_INT 35
6858: PPUSH
6859: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6863: LD_INT 22
6865: PUSH
6866: LD_INT 6
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 3
6875: PUSH
6876: LD_INT 24
6878: PUSH
6879: LD_INT 1000
6881: PUSH
6882: EMPTY
6883: LIST
6884: LIST
6885: PUSH
6886: EMPTY
6887: LIST
6888: LIST
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PPUSH
6894: CALL_OW 69
6898: PUSH
6899: LD_INT 7
6901: PPUSH
6902: LD_EXP 31
6906: PPUSH
6907: CALL_OW 292
6911: OR
6912: IFFALSE 6856
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6914: LD_ADDR_VAR 0 2
6918: PUSH
6919: LD_INT 22
6921: PUSH
6922: LD_INT 6
6924: PUSH
6925: EMPTY
6926: LIST
6927: LIST
6928: PPUSH
6929: CALL_OW 69
6933: ST_TO_ADDR
// for i in tmp do
6934: LD_ADDR_VAR 0 3
6938: PUSH
6939: LD_VAR 0 2
6943: PUSH
6944: FOR_IN
6945: IFFALSE 6961
// SetSide ( i , 7 ) ;
6947: LD_VAR 0 3
6951: PPUSH
6952: LD_INT 7
6954: PPUSH
6955: CALL_OW 235
6959: GO 6944
6961: POP
6962: POP
// DialogueOn ;
6963: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6967: LD_EXP 14
6971: PUSH
6972: LD_EXP 15
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: PPUSH
6981: LD_EXP 31
6985: PPUSH
6986: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6990: LD_EXP 31
6994: PPUSH
6995: CALL_OW 87
// if not Roth then
6999: LD_EXP 15
7003: NOT
7004: IFFALSE 7096
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7006: LD_VAR 0 2
7010: PPUSH
7011: LD_INT 3
7013: PUSH
7014: LD_INT 24
7016: PUSH
7017: LD_INT 1000
7019: PUSH
7020: EMPTY
7021: LIST
7022: LIST
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: CALL_OW 72
7032: IFFALSE 7046
// Say ( JMM , D2-JMM-1 ) ;
7034: LD_EXP 14
7038: PPUSH
7039: LD_STRING D2-JMM-1
7041: PPUSH
7042: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7046: LD_EXP 14
7050: PPUSH
7051: LD_STRING D2-JMM-1b
7053: PPUSH
7054: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7058: LD_EXP 31
7062: PPUSH
7063: LD_STRING D2-Gos-1
7065: PPUSH
7066: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7070: LD_EXP 14
7074: PPUSH
7075: LD_STRING D2-JMM-2
7077: PPUSH
7078: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7082: LD_EXP 31
7086: PPUSH
7087: LD_STRING D2-Gos-2
7089: PPUSH
7090: CALL_OW 88
// end else
7094: GO 7248
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7096: LD_VAR 0 2
7100: PPUSH
7101: LD_INT 3
7103: PUSH
7104: LD_INT 24
7106: PUSH
7107: LD_INT 1000
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: PUSH
7114: EMPTY
7115: LIST
7116: LIST
7117: PPUSH
7118: CALL_OW 72
7122: IFFALSE 7148
// begin Say ( Roth , D2-Roth-2 ) ;
7124: LD_EXP 15
7128: PPUSH
7129: LD_STRING D2-Roth-2
7131: PPUSH
7132: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7136: LD_EXP 14
7140: PPUSH
7141: LD_STRING D2-JMM-1a
7143: PPUSH
7144: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7148: LD_EXP 15
7152: PPUSH
7153: LD_STRING D2-Roth-2a
7155: PPUSH
7156: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7160: LD_EXP 15
7164: PPUSH
7165: LD_STRING D2-Roth-2b
7167: PPUSH
7168: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7172: LD_EXP 14
7176: PPUSH
7177: LD_STRING D2-JMM-3
7179: PPUSH
7180: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7184: LD_VAR 0 2
7188: PPUSH
7189: LD_INT 3
7191: PUSH
7192: LD_INT 24
7194: PUSH
7195: LD_INT 1000
7197: PUSH
7198: EMPTY
7199: LIST
7200: LIST
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: PPUSH
7206: CALL_OW 72
7210: IFFALSE 7248
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7212: LD_EXP 31
7216: PPUSH
7217: LD_STRING D2-Gos-3
7219: PPUSH
7220: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7224: LD_EXP 14
7228: PPUSH
7229: LD_STRING D2-JMM-4
7231: PPUSH
7232: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7236: LD_EXP 31
7240: PPUSH
7241: LD_STRING D2-Gos-4
7243: PPUSH
7244: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7248: LD_EXP 14
7252: PPUSH
7253: LD_STRING D2-JMM-5
7255: PPUSH
7256: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7260: LD_EXP 31
7264: PPUSH
7265: LD_STRING D2-Gos-5
7267: PPUSH
7268: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7272: LD_EXP 14
7276: PPUSH
7277: LD_STRING D2-JMM-6
7279: PPUSH
7280: CALL_OW 88
// DialogueOff ;
7284: CALL_OW 7
// wait ( 0 0$2 ) ;
7288: LD_INT 70
7290: PPUSH
7291: CALL_OW 67
// if Kirilenkova then
7295: LD_EXP 32
7299: IFFALSE 7313
// Say ( Kirilenkova , D3-Kir-1 ) ;
7301: LD_EXP 32
7305: PPUSH
7306: LD_STRING D3-Kir-1
7308: PPUSH
7309: CALL_OW 88
// gossudarov_arrive := true ;
7313: LD_ADDR_EXP 4
7317: PUSH
7318: LD_INT 1
7320: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7321: LD_INT 35
7323: PPUSH
7324: CALL_OW 67
// until ru_lab_builded ;
7328: LD_EXP 5
7332: IFFALSE 7321
// if Kirilenkova then
7334: LD_EXP 32
7338: IFFALSE 7354
// Say ( Kirilenkova , D3a-Kir-1 ) else
7340: LD_EXP 32
7344: PPUSH
7345: LD_STRING D3a-Kir-1
7347: PPUSH
7348: CALL_OW 88
7352: GO 7376
// begin un := SciRu ;
7354: LD_ADDR_VAR 0 4
7358: PUSH
7359: CALL 12329 0 0
7363: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7364: LD_VAR 0 4
7368: PPUSH
7369: LD_STRING D3a-Sci1-1
7371: PPUSH
7372: CALL_OW 88
// end ; if Kirilenkova or un then
7376: LD_EXP 32
7380: PUSH
7381: LD_VAR 0 4
7385: OR
7386: IFFALSE 7400
// Say ( JMM , D3a-JMM-1 ) ;
7388: LD_EXP 14
7392: PPUSH
7393: LD_STRING D3a-JMM-1
7395: PPUSH
7396: CALL_OW 88
// end ;
7400: LD_VAR 0 1
7404: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7405: LD_EXP 4
7409: PUSH
7410: LD_INT 22
7412: PUSH
7413: LD_INT 7
7415: PUSH
7416: EMPTY
7417: LIST
7418: LIST
7419: PUSH
7420: LD_INT 2
7422: PUSH
7423: LD_INT 25
7425: PUSH
7426: LD_INT 1
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PUSH
7433: LD_INT 25
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: EMPTY
7440: LIST
7441: LIST
7442: PUSH
7443: LD_INT 25
7445: PUSH
7446: LD_INT 3
7448: PUSH
7449: EMPTY
7450: LIST
7451: LIST
7452: PUSH
7453: LD_INT 25
7455: PUSH
7456: LD_INT 4
7458: PUSH
7459: EMPTY
7460: LIST
7461: LIST
7462: PUSH
7463: LD_INT 25
7465: PUSH
7466: LD_INT 5
7468: PUSH
7469: EMPTY
7470: LIST
7471: LIST
7472: PUSH
7473: LD_INT 25
7475: PUSH
7476: LD_INT 8
7478: PUSH
7479: EMPTY
7480: LIST
7481: LIST
7482: PUSH
7483: LD_INT 25
7485: PUSH
7486: LD_INT 9
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: LIST
7497: LIST
7498: LIST
7499: LIST
7500: LIST
7501: LIST
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PPUSH
7507: CALL_OW 69
7511: PUSH
7512: LD_INT 6
7514: LESS
7515: AND
7516: IFFALSE 7528
7518: GO 7520
7520: DISABLE
// YouLost ( TooMany ) ;
7521: LD_STRING TooMany
7523: PPUSH
7524: CALL_OW 104
7528: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7529: LD_EXP 31
7533: PPUSH
7534: CALL_OW 255
7538: PUSH
7539: LD_INT 7
7541: EQUAL
7542: IFFALSE 7742
7544: GO 7546
7546: DISABLE
7547: LD_INT 0
7549: PPUSH
7550: PPUSH
7551: PPUSH
// begin uc_side := 3 ;
7552: LD_ADDR_OWVAR 20
7556: PUSH
7557: LD_INT 3
7559: ST_TO_ADDR
// uc_nation := 3 ;
7560: LD_ADDR_OWVAR 21
7564: PUSH
7565: LD_INT 3
7567: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7568: LD_INT 21
7570: PPUSH
7571: LD_INT 3
7573: PPUSH
7574: LD_INT 3
7576: PPUSH
7577: LD_INT 42
7579: PPUSH
7580: LD_INT 100
7582: PPUSH
7583: CALL 20431 0 5
// un := CreateVehicle ;
7587: LD_ADDR_VAR 0 3
7591: PUSH
7592: CALL_OW 45
7596: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7597: LD_VAR 0 3
7601: PPUSH
7602: LD_INT 15
7604: PPUSH
7605: LD_INT 0
7607: PPUSH
7608: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7612: LD_VAR 0 3
7616: PPUSH
7617: LD_INT 67
7619: PPUSH
7620: LD_INT 45
7622: PPUSH
7623: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7627: LD_VAR 0 3
7631: PPUSH
7632: LD_INT 70
7634: PPUSH
7635: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7639: LD_VAR 0 3
7643: PPUSH
7644: LD_INT 69
7646: PPUSH
7647: LD_INT 18
7649: PPUSH
7650: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7654: LD_VAR 0 3
7658: PPUSH
7659: LD_INT 60
7661: PPUSH
7662: LD_INT 2
7664: PPUSH
7665: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7669: LD_INT 35
7671: PPUSH
7672: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7676: LD_VAR 0 3
7680: PPUSH
7681: CALL_OW 302
7685: NOT
7686: PUSH
7687: LD_VAR 0 3
7691: PPUSH
7692: LD_INT 17
7694: PPUSH
7695: CALL_OW 308
7699: OR
7700: IFFALSE 7669
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7702: LD_VAR 0 3
7706: PPUSH
7707: LD_INT 17
7709: PPUSH
7710: CALL_OW 308
7714: PUSH
7715: LD_VAR 0 3
7719: PPUSH
7720: LD_INT 60
7722: PPUSH
7723: LD_INT 2
7725: PPUSH
7726: CALL_OW 307
7730: OR
7731: IFFALSE 7742
// RemoveUnit ( un ) ;
7733: LD_VAR 0 3
7737: PPUSH
7738: CALL_OW 64
// end ;
7742: PPOPN 3
7744: END
// every 0 0$2 do var i , un , tmp ;
7745: GO 7747
7747: DISABLE
7748: LD_INT 0
7750: PPUSH
7751: PPUSH
7752: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7753: LD_INT 70
7755: PPUSH
7756: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7760: LD_ADDR_VAR 0 3
7764: PUSH
7765: LD_INT 22
7767: PUSH
7768: LD_INT 7
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 101
7777: PUSH
7778: LD_INT 3
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: PPUSH
7789: CALL_OW 69
7793: ST_TO_ADDR
// until tmp ;
7794: LD_VAR 0 3
7798: IFFALSE 7753
// un := NearestUnitToUnit ( tmp , JMM ) ;
7800: LD_ADDR_VAR 0 2
7804: PUSH
7805: LD_VAR 0 3
7809: PPUSH
7810: LD_EXP 14
7814: PPUSH
7815: CALL_OW 74
7819: ST_TO_ADDR
// player_spotted := true ;
7820: LD_ADDR_EXP 6
7824: PUSH
7825: LD_INT 1
7827: ST_TO_ADDR
// tmp := SciRu ;
7828: LD_ADDR_VAR 0 3
7832: PUSH
7833: CALL 12329 0 0
7837: ST_TO_ADDR
// DialogueOn ;
7838: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7842: LD_VAR 0 2
7846: PPUSH
7847: CALL_OW 250
7851: PPUSH
7852: LD_VAR 0 2
7856: PPUSH
7857: CALL_OW 251
7861: PPUSH
7862: LD_INT 7
7864: PPUSH
7865: LD_INT 8
7867: NEG
7868: PPUSH
7869: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7873: LD_VAR 0 2
7877: PPUSH
7878: CALL_OW 87
// if tmp then
7882: LD_VAR 0 3
7886: IFFALSE 7900
// Say ( tmp , D4-RSci1-1 ) ;
7888: LD_VAR 0 3
7892: PPUSH
7893: LD_STRING D4-RSci1-1
7895: PPUSH
7896: CALL_OW 88
// if Gossudarov then
7900: LD_EXP 31
7904: IFFALSE 7930
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7906: LD_EXP 31
7910: PPUSH
7911: LD_STRING D4-Gos-1
7913: PPUSH
7914: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7918: LD_EXP 14
7922: PPUSH
7923: LD_STRING D4-JMM-1
7925: PPUSH
7926: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7930: LD_VAR 0 2
7934: PPUSH
7935: CALL_OW 250
7939: PPUSH
7940: LD_VAR 0 2
7944: PPUSH
7945: CALL_OW 251
7949: PPUSH
7950: LD_INT 7
7952: PPUSH
7953: CALL_OW 331
// DialogueOff ;
7957: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7961: LD_STRING M5
7963: PPUSH
7964: CALL_OW 337
// end ;
7968: PPOPN 3
7970: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
7971: LD_EXP 6
7975: IFFALSE 8564
7977: GO 7979
7979: DISABLE
7980: LD_INT 0
7982: PPUSH
7983: PPUSH
7984: PPUSH
// begin PrepareBelkov ;
7985: CALL 1934 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7989: LD_EXP 46
7993: PPUSH
7994: LD_INT 118
7996: PPUSH
7997: LD_INT 106
7999: PPUSH
8000: CALL_OW 111
// AddComHold ( Belkov ) ;
8004: LD_EXP 46
8008: PPUSH
8009: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8013: LD_INT 35
8015: PPUSH
8016: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8020: LD_EXP 46
8024: PPUSH
8025: LD_INT 118
8027: PPUSH
8028: LD_INT 106
8030: PPUSH
8031: CALL_OW 307
8035: IFFALSE 8013
// ChangeSideFog ( 4 , 7 ) ;
8037: LD_INT 4
8039: PPUSH
8040: LD_INT 7
8042: PPUSH
8043: CALL_OW 343
// if IsOk ( Belkov ) then
8047: LD_EXP 46
8051: PPUSH
8052: CALL_OW 302
8056: IFFALSE 8140
// begin InGameOn ;
8058: CALL_OW 8
// DialogueOn ;
8062: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8066: LD_EXP 46
8070: PPUSH
8071: LD_STRING D5-Bel-1
8073: PPUSH
8074: CALL_OW 94
// if Gossudarov then
8078: LD_EXP 31
8082: IFFALSE 8132
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8084: LD_EXP 31
8088: PPUSH
8089: LD_STRING D5-Gos-1
8091: PPUSH
8092: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8096: LD_EXP 14
8100: PPUSH
8101: LD_STRING D5-JMM-1
8103: PPUSH
8104: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8108: LD_EXP 31
8112: PPUSH
8113: LD_STRING D5-Gos-2
8115: PPUSH
8116: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8120: LD_EXP 14
8124: PPUSH
8125: LD_STRING D5-JMM-2
8127: PPUSH
8128: CALL_OW 88
// end ; DialogueOff ;
8132: CALL_OW 7
// InGameOff ;
8136: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8140: LD_STRING QSaveBelkov
8142: PPUSH
8143: CALL_OW 97
8147: PUSH
8148: LD_INT 1
8150: DOUBLE
8151: EQUAL
8152: IFTRUE 8156
8154: GO 8206
8156: POP
// begin DialogueOn ;
8157: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8161: LD_EXP 14
8165: PPUSH
8166: LD_STRING D5a-JMM-1
8168: PPUSH
8169: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8173: LD_EXP 46
8177: PPUSH
8178: LD_STRING D5a-Bel-1
8180: PPUSH
8181: CALL_OW 94
// DialogueOff ;
8185: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8189: LD_EXP 46
8193: PPUSH
8194: LD_INT 83
8196: PPUSH
8197: LD_INT 49
8199: PPUSH
8200: CALL_OW 111
// end ; 2 :
8204: GO 8239
8206: LD_INT 2
8208: DOUBLE
8209: EQUAL
8210: IFTRUE 8214
8212: GO 8238
8214: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8215: LD_EXP 14
8219: PPUSH
8220: LD_STRING D5a-JMM-2
8222: PPUSH
8223: CALL_OW 88
// ComHold ( Belkov ) ;
8227: LD_EXP 46
8231: PPUSH
8232: CALL_OW 140
// end ; end ;
8236: GO 8239
8238: POP
// time := 0 0$00 ;
8239: LD_ADDR_VAR 0 1
8243: PUSH
8244: LD_INT 0
8246: ST_TO_ADDR
// vehSpawned := false ;
8247: LD_ADDR_VAR 0 3
8251: PUSH
8252: LD_INT 0
8254: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8255: LD_INT 35
8257: PPUSH
8258: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8262: LD_VAR 0 1
8266: PUSH
8267: LD_INT 350
8269: PUSH
8270: LD_INT 175
8272: PUSH
8273: LD_INT 70
8275: PUSH
8276: EMPTY
8277: LIST
8278: LIST
8279: LIST
8280: PUSH
8281: LD_OWVAR 67
8285: ARRAY
8286: GREATEREQUAL
8287: PUSH
8288: LD_VAR 0 3
8292: NOT
8293: AND
8294: IFFALSE 8384
// begin vehSpawned := true ;
8296: LD_ADDR_VAR 0 3
8300: PUSH
8301: LD_INT 1
8303: ST_TO_ADDR
// uc_side := 3 ;
8304: LD_ADDR_OWVAR 20
8308: PUSH
8309: LD_INT 3
8311: ST_TO_ADDR
// uc_nation := 3 ;
8312: LD_ADDR_OWVAR 21
8316: PUSH
8317: LD_INT 3
8319: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8320: LD_INT 22
8322: PPUSH
8323: LD_INT 3
8325: PPUSH
8326: LD_INT 3
8328: PPUSH
8329: LD_INT 43
8331: PPUSH
8332: LD_INT 100
8334: PPUSH
8335: CALL 20431 0 5
// veh := CreateVehicle ;
8339: LD_ADDR_VAR 0 2
8343: PUSH
8344: CALL_OW 45
8348: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8349: LD_VAR 0 2
8353: PPUSH
8354: LD_INT 130
8356: PPUSH
8357: LD_INT 131
8359: PPUSH
8360: LD_INT 0
8362: PPUSH
8363: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8367: LD_VAR 0 2
8371: PPUSH
8372: LD_INT 100
8374: PPUSH
8375: LD_INT 82
8377: PPUSH
8378: CALL_OW 114
// end else
8382: GO 8398
// time := time + 0 0$1 ;
8384: LD_ADDR_VAR 0 1
8388: PUSH
8389: LD_VAR 0 1
8393: PUSH
8394: LD_INT 35
8396: PLUS
8397: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8398: LD_EXP 46
8402: PPUSH
8403: CALL_OW 301
8407: PUSH
8408: LD_EXP 46
8412: PPUSH
8413: CALL_OW 255
8417: PUSH
8418: LD_INT 4
8420: EQUAL
8421: AND
8422: PUSH
8423: LD_INT 22
8425: PUSH
8426: LD_INT 7
8428: PUSH
8429: EMPTY
8430: LIST
8431: LIST
8432: PPUSH
8433: CALL_OW 69
8437: PPUSH
8438: LD_EXP 46
8442: PPUSH
8443: CALL_OW 74
8447: PPUSH
8448: LD_EXP 46
8452: PPUSH
8453: CALL_OW 296
8457: PUSH
8458: LD_INT 10
8460: LESS
8461: OR
8462: IFFALSE 8255
// if IsDead ( Belkov ) then
8464: LD_EXP 46
8468: PPUSH
8469: CALL_OW 301
8473: IFFALSE 8498
// begin CenterNowOnUnits ( Belkov ) ;
8475: LD_EXP 46
8479: PPUSH
8480: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8484: LD_EXP 14
8488: PPUSH
8489: LD_STRING D5a-JMM-2a
8491: PPUSH
8492: CALL_OW 88
// exit ;
8496: GO 8564
// end ; if See ( 7 , Belkov ) then
8498: LD_INT 7
8500: PPUSH
8501: LD_EXP 46
8505: PPUSH
8506: CALL_OW 292
8510: IFFALSE 8524
// SetSide ( Belkov , 7 ) ;
8512: LD_EXP 46
8516: PPUSH
8517: LD_INT 7
8519: PPUSH
8520: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8524: LD_INT 35
8526: PPUSH
8527: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8531: LD_EXP 46
8535: PPUSH
8536: LD_INT 66
8538: PPUSH
8539: LD_INT 45
8541: PPUSH
8542: CALL_OW 297
8546: PUSH
8547: LD_INT 30
8549: LESS
8550: IFFALSE 8524
// Say ( Belkov , D6-Bel-1 ) ;
8552: LD_EXP 46
8556: PPUSH
8557: LD_STRING D6-Bel-1
8559: PPUSH
8560: CALL_OW 88
// end ;
8564: PPOPN 3
8566: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8567: LD_EXP 46
8571: PPUSH
8572: CALL_OW 302
8576: PUSH
8577: LD_EXP 46
8581: PPUSH
8582: CALL_OW 504
8586: PUSH
8587: LD_INT 2
8589: PUSH
8590: LD_INT 34
8592: PUSH
8593: LD_INT 47
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: LD_INT 34
8602: PUSH
8603: LD_INT 45
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: EMPTY
8611: LIST
8612: LIST
8613: LIST
8614: PPUSH
8615: CALL_OW 69
8619: IN
8620: AND
8621: IFFALSE 8638
8623: GO 8625
8625: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8626: LD_EXP 46
8630: PPUSH
8631: LD_STRING D7-Bel-1
8633: PPUSH
8634: CALL_OW 88
8638: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8639: LD_INT 22
8641: PUSH
8642: LD_INT 7
8644: PUSH
8645: EMPTY
8646: LIST
8647: LIST
8648: PUSH
8649: LD_INT 101
8651: PUSH
8652: LD_INT 2
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: PUSH
8659: EMPTY
8660: LIST
8661: LIST
8662: PPUSH
8663: CALL_OW 69
8667: PUSH
8668: LD_EXP 8
8672: NOT
8673: AND
8674: PUSH
8675: LD_EXP 45
8679: PPUSH
8680: CALL_OW 305
8684: NOT
8685: AND
8686: IFFALSE 9156
8688: GO 8690
8690: DISABLE
8691: LD_INT 0
8693: PPUSH
// begin ar_base_spotted := true ;
8694: LD_ADDR_EXP 8
8698: PUSH
8699: LD_INT 1
8701: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8702: LD_ADDR_VAR 0 1
8706: PUSH
8707: LD_INT 22
8709: PUSH
8710: LD_INT 2
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: PUSH
8717: LD_INT 21
8719: PUSH
8720: LD_INT 3
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PUSH
8727: EMPTY
8728: LIST
8729: LIST
8730: PPUSH
8731: CALL_OW 69
8735: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8736: LD_ADDR_VAR 0 1
8740: PUSH
8741: LD_VAR 0 1
8745: PPUSH
8746: LD_EXP 14
8750: PPUSH
8751: CALL_OW 74
8755: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8756: LD_INT 7
8758: PPUSH
8759: LD_INT 3
8761: PPUSH
8762: CALL_OW 332
// DialogueOn ;
8766: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8770: LD_VAR 0 1
8774: PPUSH
8775: CALL_OW 250
8779: PPUSH
8780: LD_VAR 0 1
8784: PPUSH
8785: CALL_OW 251
8789: PPUSH
8790: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8794: LD_ADDR_VAR 0 1
8798: PUSH
8799: LD_INT 22
8801: PUSH
8802: LD_INT 7
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: PUSH
8809: LD_INT 23
8811: PUSH
8812: LD_INT 1
8814: PUSH
8815: EMPTY
8816: LIST
8817: LIST
8818: PUSH
8819: LD_INT 26
8821: PUSH
8822: LD_INT 1
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PUSH
8829: EMPTY
8830: LIST
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: PUSH
8839: LD_EXP 14
8843: PUSH
8844: LD_EXP 18
8848: PUSH
8849: LD_EXP 19
8853: PUSH
8854: LD_EXP 26
8858: PUSH
8859: LD_EXP 15
8863: PUSH
8864: LD_EXP 24
8868: PUSH
8869: LD_EXP 20
8873: PUSH
8874: LD_EXP 22
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: LIST
8887: LIST
8888: DIFF
8889: ST_TO_ADDR
// if not tmp then
8890: LD_VAR 0 1
8894: NOT
8895: IFFALSE 8969
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8897: LD_ADDR_VAR 0 1
8901: PUSH
8902: LD_INT 22
8904: PUSH
8905: LD_INT 7
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: PUSH
8912: LD_INT 23
8914: PUSH
8915: LD_INT 1
8917: PUSH
8918: EMPTY
8919: LIST
8920: LIST
8921: PUSH
8922: LD_INT 26
8924: PUSH
8925: LD_INT 2
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: LIST
8936: PPUSH
8937: CALL_OW 69
8941: PUSH
8942: LD_EXP 29
8946: PUSH
8947: LD_EXP 16
8951: PUSH
8952: LD_EXP 27
8956: PUSH
8957: LD_EXP 28
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: LIST
8966: LIST
8967: DIFF
8968: ST_TO_ADDR
// if tmp then
8969: LD_VAR 0 1
8973: IFFALSE 9044
// case GetSex ( tmp [ 1 ] ) of sex_male :
8975: LD_VAR 0 1
8979: PUSH
8980: LD_INT 1
8982: ARRAY
8983: PPUSH
8984: CALL_OW 258
8988: PUSH
8989: LD_INT 1
8991: DOUBLE
8992: EQUAL
8993: IFTRUE 8997
8995: GO 9016
8997: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8998: LD_VAR 0 1
9002: PUSH
9003: LD_INT 1
9005: ARRAY
9006: PPUSH
9007: LD_STRING D9-Sol1-1
9009: PPUSH
9010: CALL_OW 88
9014: GO 9044
9016: LD_INT 2
9018: DOUBLE
9019: EQUAL
9020: IFTRUE 9024
9022: GO 9043
9024: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9025: LD_VAR 0 1
9029: PUSH
9030: LD_INT 1
9032: ARRAY
9033: PPUSH
9034: LD_STRING D9-FSol1-1
9036: PPUSH
9037: CALL_OW 88
9041: GO 9044
9043: POP
// if Frank then
9044: LD_EXP 26
9048: IFFALSE 9152
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9050: LD_EXP 55
9054: PPUSH
9055: CALL_OW 250
9059: PPUSH
9060: LD_EXP 55
9064: PPUSH
9065: CALL_OW 251
9069: PPUSH
9070: LD_INT 7
9072: PPUSH
9073: LD_INT 8
9075: PPUSH
9076: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9080: LD_EXP 55
9084: PPUSH
9085: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9089: LD_EXP 26
9093: PPUSH
9094: LD_STRING D9-Frank-1
9096: PPUSH
9097: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9101: LD_EXP 14
9105: PPUSH
9106: LD_STRING D9-JMM-1
9108: PPUSH
9109: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9113: LD_EXP 26
9117: PPUSH
9118: LD_STRING D9-Frank-2
9120: PPUSH
9121: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9125: LD_EXP 55
9129: PPUSH
9130: CALL_OW 250
9134: PPUSH
9135: LD_EXP 55
9139: PPUSH
9140: CALL_OW 251
9144: PPUSH
9145: LD_INT 7
9147: PPUSH
9148: CALL_OW 331
// end ; DialogueOff ;
9152: CALL_OW 7
// end ;
9156: PPOPN 1
9158: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9159: LD_EXP 7
9163: PUSH
9164: LD_OWVAR 1
9168: PUSH
9169: LD_INT 42000
9171: GREATEREQUAL
9172: OR
9173: IFFALSE 10200
9175: GO 9177
9177: DISABLE
9178: LD_INT 0
9180: PPUSH
9181: PPUSH
// begin selected_option := 1 ;
9182: LD_ADDR_VAR 0 2
9186: PUSH
9187: LD_INT 1
9189: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9190: LD_INT 10500
9192: PPUSH
9193: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9197: LD_INT 35
9199: PPUSH
9200: CALL_OW 67
// until not ru_attackers ;
9204: LD_EXP 51
9208: NOT
9209: IFFALSE 9197
// PrepareBurlak ;
9211: CALL 2046 0 0
// repeat wait ( 0 0$2 ) ;
9215: LD_INT 70
9217: PPUSH
9218: CALL_OW 67
// until not HasTask ( Burlak ) ;
9222: LD_EXP 45
9226: PPUSH
9227: CALL_OW 314
9231: NOT
9232: IFFALSE 9215
// InGameOn ;
9234: CALL_OW 8
// DialogueOn ;
9238: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9242: LD_EXP 48
9246: PPUSH
9247: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9251: LD_EXP 45
9255: PPUSH
9256: LD_STRING D10-Bur-1
9258: PPUSH
9259: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9263: LD_EXP 46
9267: PUSH
9268: LD_EXP 46
9272: PPUSH
9273: CALL_OW 255
9277: PUSH
9278: LD_INT 7
9280: EQUAL
9281: AND
9282: IFFALSE 9296
// Say ( Belkov , D10-Bel-1 ) ;
9284: LD_EXP 46
9288: PPUSH
9289: LD_STRING D10-Bel-1
9291: PPUSH
9292: CALL_OW 88
// if Gossudarov then
9296: LD_EXP 31
9300: IFFALSE 9314
// Say ( Gossudarov , D10-Gos-1 ) ;
9302: LD_EXP 31
9306: PPUSH
9307: LD_STRING D10-Gos-1
9309: PPUSH
9310: CALL_OW 88
// if Kirilenkova then
9314: LD_EXP 32
9318: IFFALSE 9332
// Say ( Kirilenkova , D10-Kir-1 ) ;
9320: LD_EXP 32
9324: PPUSH
9325: LD_STRING D10-Kir-1
9327: PPUSH
9328: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9332: CALL 12458 0 0
9336: PPUSH
9337: LD_STRING D10-RSol1-1
9339: PPUSH
9340: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9344: LD_EXP 45
9348: PPUSH
9349: LD_STRING D10-Bur-2
9351: PPUSH
9352: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9356: LD_EXP 14
9360: PPUSH
9361: LD_STRING D10-JMM-2
9363: PPUSH
9364: CALL_OW 88
// if Kirilenkova then
9368: LD_EXP 32
9372: IFFALSE 9388
// Say ( Kirilenkova , D10-Kir-2 ) else
9374: LD_EXP 32
9378: PPUSH
9379: LD_STRING D10-Kir-2
9381: PPUSH
9382: CALL_OW 88
9386: GO 9400
// Say ( SolRu , D10-RSol1-2 ) ;
9388: CALL 12458 0 0
9392: PPUSH
9393: LD_STRING D10-RSol1-2
9395: PPUSH
9396: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9400: LD_EXP 14
9404: PPUSH
9405: LD_STRING D10-JMM-3
9407: PPUSH
9408: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9412: LD_EXP 45
9416: PPUSH
9417: LD_STRING D10-Bur-3
9419: PPUSH
9420: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9424: LD_EXP 14
9428: PPUSH
9429: LD_STRING D10-JMM-4
9431: PPUSH
9432: CALL_OW 88
// DialogueOff ;
9436: CALL_OW 7
// InGameOff ;
9440: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9444: LD_STRING M2
9446: PPUSH
9447: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9451: LD_INT 35
9453: PPUSH
9454: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9458: LD_INT 22
9460: PUSH
9461: LD_INT 7
9463: PUSH
9464: EMPTY
9465: LIST
9466: LIST
9467: PUSH
9468: LD_INT 91
9470: PUSH
9471: LD_EXP 45
9475: PUSH
9476: LD_INT 8
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: LIST
9483: PUSH
9484: EMPTY
9485: LIST
9486: LIST
9487: PPUSH
9488: CALL_OW 69
9492: IFFALSE 9451
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9494: LD_ADDR_VAR 0 1
9498: PUSH
9499: LD_INT 22
9501: PUSH
9502: LD_INT 4
9504: PUSH
9505: EMPTY
9506: LIST
9507: LIST
9508: PPUSH
9509: CALL_OW 69
9513: PUSH
9514: FOR_IN
9515: IFFALSE 9531
// SetSide ( i , 7 ) ;
9517: LD_VAR 0 1
9521: PPUSH
9522: LD_INT 7
9524: PPUSH
9525: CALL_OW 235
9529: GO 9514
9531: POP
9532: POP
// ChangeMissionObjectives ( M3 ) ;
9533: LD_STRING M3
9535: PPUSH
9536: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9540: LD_INT 35
9542: PPUSH
9543: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9547: LD_EXP 14
9551: PPUSH
9552: LD_EXP 45
9556: PPUSH
9557: CALL_OW 296
9561: PUSH
9562: LD_INT 8
9564: LESS
9565: IFFALSE 9540
// ComTurnUnit ( JMM , Burlak ) ;
9567: LD_EXP 14
9571: PPUSH
9572: LD_EXP 45
9576: PPUSH
9577: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9581: LD_EXP 45
9585: PPUSH
9586: LD_EXP 14
9590: PPUSH
9591: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9595: LD_INT 10
9597: PPUSH
9598: CALL_OW 67
// DialogueOn ;
9602: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9606: LD_EXP 14
9610: PPUSH
9611: LD_STRING D11-JMM-1
9613: PPUSH
9614: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9618: LD_EXP 45
9622: PPUSH
9623: LD_STRING D11-Bur-1
9625: PPUSH
9626: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9630: LD_EXP 14
9634: PPUSH
9635: LD_STRING D11-JMM-2
9637: PPUSH
9638: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9642: LD_EXP 45
9646: PPUSH
9647: LD_STRING D11-Bur-2
9649: PPUSH
9650: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9654: LD_EXP 14
9658: PPUSH
9659: LD_STRING D11-JMM-3
9661: PPUSH
9662: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9666: LD_EXP 45
9670: PPUSH
9671: LD_STRING D11-Bur-3
9673: PPUSH
9674: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9678: LD_EXP 14
9682: PPUSH
9683: LD_STRING D11-JMM-4
9685: PPUSH
9686: CALL_OW 88
// if ar_base_spotted then
9690: LD_EXP 8
9694: IFFALSE 9710
// Say ( Burlak , D12-Bur-1 ) else
9696: LD_EXP 45
9700: PPUSH
9701: LD_STRING D12-Bur-1
9703: PPUSH
9704: CALL_OW 88
9708: GO 9749
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9710: LD_INT 7
9712: PPUSH
9713: LD_INT 3
9715: PPUSH
9716: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9720: LD_INT 127
9722: PPUSH
9723: LD_INT 45
9725: PPUSH
9726: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9730: LD_EXP 45
9734: PPUSH
9735: LD_STRING D12-Bur-1a
9737: PPUSH
9738: CALL_OW 88
// dwait ( 0 0$2 ) ;
9742: LD_INT 70
9744: PPUSH
9745: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9749: LD_EXP 45
9753: PPUSH
9754: LD_STRING D12-Bur-1b
9756: PPUSH
9757: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9761: LD_EXP 14
9765: PPUSH
9766: LD_STRING D12-JMM-1
9768: PPUSH
9769: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9773: LD_EXP 45
9777: PPUSH
9778: LD_STRING D12-Bur-2
9780: PPUSH
9781: CALL_OW 88
// if Roth then
9785: LD_EXP 15
9789: IFFALSE 9805
// Say ( Roth , D12-Roth-2 ) else
9791: LD_EXP 15
9795: PPUSH
9796: LD_STRING D12-Roth-2
9798: PPUSH
9799: CALL_OW 88
9803: GO 9817
// Say ( SciRu , D12-RSci1-2 ) ;
9805: CALL 12329 0 0
9809: PPUSH
9810: LD_STRING D12-RSci1-2
9812: PPUSH
9813: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9817: LD_EXP 14
9821: PPUSH
9822: LD_STRING D12-JMM-2
9824: PPUSH
9825: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9829: LD_EXP 45
9833: PPUSH
9834: LD_STRING D12-Bur-3
9836: PPUSH
9837: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9841: LD_EXP 14
9845: PPUSH
9846: LD_STRING D12-JMM-3
9848: PPUSH
9849: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9853: LD_EXP 45
9857: PPUSH
9858: LD_STRING D12-Bur-4
9860: PPUSH
9861: CALL_OW 88
// case Query ( QBase ) of 1 :
9865: LD_STRING QBase
9867: PPUSH
9868: CALL_OW 97
9872: PUSH
9873: LD_INT 1
9875: DOUBLE
9876: EQUAL
9877: IFTRUE 9881
9879: GO 9999
9881: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9882: LD_EXP 14
9886: PPUSH
9887: LD_STRING D13a-JMM-1
9889: PPUSH
9890: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9894: LD_EXP 45
9898: PPUSH
9899: LD_STRING D13a-Bur-1
9901: PPUSH
9902: CALL_OW 88
// if Roth then
9906: LD_EXP 15
9910: IFFALSE 9926
// Say ( Roth , D13a-Roth-1 ) else
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D13a-Roth-1
9919: PPUSH
9920: CALL_OW 88
9924: GO 9938
// Say ( SciRu , D13a-RSci1-1 ) ;
9926: CALL 12329 0 0
9930: PPUSH
9931: LD_STRING D13a-RSci1-1
9933: PPUSH
9934: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9938: LD_EXP 14
9942: PPUSH
9943: LD_STRING D13a-JMM-2
9945: PPUSH
9946: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9950: LD_STRING QBaseAgain
9952: PPUSH
9953: CALL_OW 97
9957: PUSH
9958: LD_INT 1
9960: DOUBLE
9961: EQUAL
9962: IFTRUE 9966
9964: GO 9977
9966: POP
// selected_option := 2 ; 2 :
9967: LD_ADDR_VAR 0 2
9971: PUSH
9972: LD_INT 2
9974: ST_TO_ADDR
9975: GO 9997
9977: LD_INT 2
9979: DOUBLE
9980: EQUAL
9981: IFTRUE 9985
9983: GO 9996
9985: POP
// selected_option := 3 ; end ;
9986: LD_ADDR_VAR 0 2
9990: PUSH
9991: LD_INT 3
9993: ST_TO_ADDR
9994: GO 9997
9996: POP
// end ; 2 :
9997: GO 10038
9999: LD_INT 2
10001: DOUBLE
10002: EQUAL
10003: IFTRUE 10007
10005: GO 10018
10007: POP
// selected_option := 2 ; 3 :
10008: LD_ADDR_VAR 0 2
10012: PUSH
10013: LD_INT 2
10015: ST_TO_ADDR
10016: GO 10038
10018: LD_INT 3
10020: DOUBLE
10021: EQUAL
10022: IFTRUE 10026
10024: GO 10037
10026: POP
// selected_option := 3 ; end ;
10027: LD_ADDR_VAR 0 2
10031: PUSH
10032: LD_INT 3
10034: ST_TO_ADDR
10035: GO 10038
10037: POP
// if selected_option = 2 then
10038: LD_VAR 0 2
10042: PUSH
10043: LD_INT 2
10045: EQUAL
10046: IFFALSE 10140
// begin Say ( JMM , D13b-JMM-1 ) ;
10048: LD_EXP 14
10052: PPUSH
10053: LD_STRING D13b-JMM-1
10055: PPUSH
10056: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10060: LD_EXP 45
10064: PPUSH
10065: LD_STRING D13b-Bur-1
10067: PPUSH
10068: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10072: LD_EXP 14
10076: PPUSH
10077: LD_STRING D13b-JMM-2
10079: PPUSH
10080: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10084: LD_EXP 54
10088: PPUSH
10089: LD_STRING D13b-Abd-2
10091: PPUSH
10092: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10096: LD_EXP 14
10100: PPUSH
10101: LD_STRING D13b-JMM-3
10103: PPUSH
10104: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10108: LD_EXP 54
10112: PPUSH
10113: LD_STRING D13b-Abd-3
10115: PPUSH
10116: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10120: LD_EXP 14
10124: PPUSH
10125: LD_STRING D13b-JMM-4
10127: PPUSH
10128: CALL_OW 88
// ar_active_attack := true ;
10132: LD_ADDR_EXP 9
10136: PUSH
10137: LD_INT 1
10139: ST_TO_ADDR
// end ; if selected_option = 3 then
10140: LD_VAR 0 2
10144: PUSH
10145: LD_INT 3
10147: EQUAL
10148: IFFALSE 10174
// begin Say ( JMM , D13c-JMM-1 ) ;
10150: LD_EXP 14
10154: PPUSH
10155: LD_STRING D13c-JMM-1
10157: PPUSH
10158: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10162: LD_EXP 45
10166: PPUSH
10167: LD_STRING D13c-Bur-1
10169: PPUSH
10170: CALL_OW 88
// end ; DialogueOff ;
10174: CALL_OW 7
// if not ar_active_attack then
10178: LD_EXP 9
10182: NOT
10183: IFFALSE 10200
// begin wait ( 6 6$00 ) ;
10185: LD_INT 12600
10187: PPUSH
10188: CALL_OW 67
// ar_active_attack := true ;
10192: LD_ADDR_EXP 9
10196: PUSH
10197: LD_INT 1
10199: ST_TO_ADDR
// end ; end ;
10200: PPOPN 2
10202: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10203: LD_EXP 45
10207: PPUSH
10208: CALL_OW 305
10212: PUSH
10213: LD_EXP 45
10217: PPUSH
10218: CALL_OW 255
10222: PUSH
10223: LD_INT 7
10225: EQUAL
10226: AND
10227: IFFALSE 10423
10229: GO 10231
10231: DISABLE
10232: LD_INT 0
10234: PPUSH
// begin wait ( 4 4$40 ) ;
10235: LD_INT 9800
10237: PPUSH
10238: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10242: LD_INT 35
10244: PPUSH
10245: CALL_OW 67
// until not ru_attackers ;
10249: LD_EXP 51
10253: NOT
10254: IFFALSE 10242
// PrepareGnyevko ;
10256: CALL 1990 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10260: LD_EXP 47
10264: PPUSH
10265: LD_INT 124
10267: PPUSH
10268: LD_INT 118
10270: PPUSH
10271: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10275: LD_EXP 47
10279: PPUSH
10280: CALL_OW 200
// time := 0 0$00 ;
10284: LD_ADDR_VAR 0 1
10288: PUSH
10289: LD_INT 0
10291: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10292: LD_INT 35
10294: PPUSH
10295: CALL_OW 67
// time := time + 0 0$1 ;
10299: LD_ADDR_VAR 0 1
10303: PUSH
10304: LD_VAR 0 1
10308: PUSH
10309: LD_INT 35
10311: PLUS
10312: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10313: LD_EXP 47
10317: PPUSH
10318: LD_INT 124
10320: PPUSH
10321: LD_INT 118
10323: PPUSH
10324: CALL_OW 307
10328: PUSH
10329: LD_VAR 0 1
10333: PUSH
10334: LD_INT 1050
10336: GREATEREQUAL
10337: OR
10338: IFFALSE 10292
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10340: LD_EXP 47
10344: PPUSH
10345: LD_STRING DBelkov-Gny-1
10347: PPUSH
10348: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10352: LD_EXP 45
10356: PPUSH
10357: LD_STRING DBelkov-Bur-1a
10359: PPUSH
10360: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10364: LD_INT 35
10366: PPUSH
10367: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10371: LD_EXP 47
10375: PPUSH
10376: LD_INT 22
10378: PUSH
10379: LD_INT 7
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: PPUSH
10386: CALL_OW 69
10390: PPUSH
10391: LD_EXP 47
10395: PPUSH
10396: CALL_OW 74
10400: PPUSH
10401: CALL_OW 296
10405: PUSH
10406: LD_INT 8
10408: LESS
10409: IFFALSE 10364
// SetSide ( Gnyevko , 7 ) ;
10411: LD_EXP 47
10415: PPUSH
10416: LD_INT 7
10418: PPUSH
10419: CALL_OW 235
// end ;
10423: PPOPN 1
10425: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10426: LD_EXP 45
10430: PPUSH
10431: CALL_OW 255
10435: PUSH
10436: LD_INT 7
10438: EQUAL
10439: IFFALSE 10449
10441: GO 10443
10443: DISABLE
// begin enable ;
10444: ENABLE
// PrepareAmericanAttack ;
10445: CALL 6296 0 0
// end ;
10449: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10450: LD_INT 22
10452: PUSH
10453: LD_INT 1
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PPUSH
10460: CALL_OW 69
10464: IFFALSE 10648
10466: GO 10468
10468: DISABLE
10469: LD_INT 0
10471: PPUSH
10472: PPUSH
// begin while true do
10473: LD_INT 1
10475: IFFALSE 10532
// begin wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10484: LD_ADDR_VAR 0 2
10488: PUSH
10489: LD_INT 22
10491: PUSH
10492: LD_INT 1
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PPUSH
10499: CALL_OW 69
10503: PPUSH
10504: LD_EXP 14
10508: PPUSH
10509: CALL_OW 74
10513: ST_TO_ADDR
// if See ( 7 , tmp ) then
10514: LD_INT 7
10516: PPUSH
10517: LD_VAR 0 2
10521: PPUSH
10522: CALL_OW 292
10526: IFFALSE 10530
// break ;
10528: GO 10532
// end ;
10530: GO 10473
// DialogueOn ;
10532: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10536: LD_VAR 0 2
10540: PPUSH
10541: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10545: LD_VAR 0 2
10549: PPUSH
10550: CALL_OW 250
10554: PPUSH
10555: LD_VAR 0 2
10559: PPUSH
10560: CALL_OW 251
10564: PPUSH
10565: LD_INT 7
10567: PPUSH
10568: LD_INT 8
10570: PPUSH
10571: CALL_OW 330
// if Denis then
10575: LD_EXP 20
10579: IFFALSE 10593
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10581: LD_EXP 20
10585: PPUSH
10586: LD_STRING DAmerAttack-Pet-1
10588: PPUSH
10589: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10593: LD_EXP 14
10597: PPUSH
10598: LD_STRING DAmerAttack-JMM-1
10600: PPUSH
10601: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10605: LD_EXP 45
10609: PPUSH
10610: LD_STRING DStop-Bur-1
10612: PPUSH
10613: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10617: LD_VAR 0 2
10621: PPUSH
10622: CALL_OW 250
10626: PPUSH
10627: LD_VAR 0 2
10631: PPUSH
10632: CALL_OW 251
10636: PPUSH
10637: LD_INT 7
10639: PPUSH
10640: CALL_OW 331
// DialogueOff ;
10644: CALL_OW 7
// end ;
10648: PPOPN 2
10650: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10651: LD_INT 22
10653: PUSH
10654: LD_INT 3
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: LD_INT 21
10663: PUSH
10664: LD_INT 1
10666: PUSH
10667: EMPTY
10668: LIST
10669: LIST
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: PPUSH
10675: CALL_OW 69
10679: PUSH
10680: LD_INT 0
10682: EQUAL
10683: IFFALSE 10725
10685: GO 10687
10687: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10688: LD_STRING M5a
10690: PPUSH
10691: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10695: LD_EXP 14
10699: PPUSH
10700: LD_STRING D8-JMM-1
10702: PPUSH
10703: CALL_OW 88
// if Gossudarov then
10707: LD_EXP 31
10711: IFFALSE 10725
// Say ( Gossudarov , D8-Gos-1 ) ;
10713: LD_EXP 31
10717: PPUSH
10718: LD_STRING D8-Gos-1
10720: PPUSH
10721: CALL_OW 88
// end ;
10725: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10726: LD_INT 22
10728: PUSH
10729: LD_INT 2
10731: PUSH
10732: EMPTY
10733: LIST
10734: LIST
10735: PUSH
10736: LD_INT 21
10738: PUSH
10739: LD_INT 1
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL_OW 69
10754: PUSH
10755: LD_INT 0
10757: EQUAL
10758: IFFALSE 10808
10760: GO 10762
10762: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10763: LD_STRING M4c
10765: PPUSH
10766: CALL_OW 337
// if Roth then
10770: LD_EXP 15
10774: IFFALSE 10790
// Say ( Roth , DStop-Roth-1 ) else
10776: LD_EXP 15
10780: PPUSH
10781: LD_STRING DStop-Roth-1
10783: PPUSH
10784: CALL_OW 88
10788: GO 10808
// if Gossudarov then
10790: LD_EXP 31
10794: IFFALSE 10808
// Say ( Gossudarov , D8-Gos-1a ) ;
10796: LD_EXP 31
10800: PPUSH
10801: LD_STRING D8-Gos-1a
10803: PPUSH
10804: CALL_OW 88
// end ;
10808: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10809: LD_INT 7
10811: PPUSH
10812: LD_INT 1
10814: PPUSH
10815: LD_INT 1
10817: PPUSH
10818: CALL 13861 0 3
10822: PUSH
10823: LD_INT 0
10825: EQUAL
10826: PUSH
10827: LD_INT 7
10829: PPUSH
10830: LD_INT 3
10832: PPUSH
10833: LD_INT 1
10835: PPUSH
10836: CALL 13861 0 3
10840: PUSH
10841: LD_INT 0
10843: EQUAL
10844: AND
10845: IFFALSE 10857
10847: GO 10849
10849: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10850: LD_STRING M1a
10852: PPUSH
10853: CALL_OW 337
// end ;
10857: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10858: LD_INT 22
10860: PUSH
10861: LD_INT 2
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: PUSH
10868: LD_INT 21
10870: PUSH
10871: LD_INT 1
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: EMPTY
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 69
10886: PUSH
10887: LD_INT 0
10889: EQUAL
10890: PUSH
10891: LD_INT 22
10893: PUSH
10894: LD_INT 3
10896: PUSH
10897: EMPTY
10898: LIST
10899: LIST
10900: PUSH
10901: LD_INT 21
10903: PUSH
10904: LD_INT 1
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: EMPTY
10912: LIST
10913: LIST
10914: PPUSH
10915: CALL_OW 69
10919: PUSH
10920: LD_INT 0
10922: EQUAL
10923: AND
10924: PUSH
10925: LD_INT 22
10927: PUSH
10928: LD_INT 1
10930: PUSH
10931: EMPTY
10932: LIST
10933: LIST
10934: PPUSH
10935: CALL_OW 69
10939: PUSH
10940: LD_INT 0
10942: EQUAL
10943: AND
10944: PUSH
10945: LD_INT 7
10947: PPUSH
10948: LD_INT 1
10950: PPUSH
10951: LD_INT 1
10953: PPUSH
10954: CALL 13861 0 3
10958: PUSH
10959: LD_INT 0
10961: EQUAL
10962: AND
10963: PUSH
10964: LD_INT 7
10966: PPUSH
10967: LD_INT 3
10969: PPUSH
10970: LD_INT 1
10972: PPUSH
10973: CALL 13861 0 3
10977: PUSH
10978: LD_INT 0
10980: EQUAL
10981: AND
10982: IFFALSE 12326
10984: GO 10986
10986: DISABLE
10987: LD_INT 0
10989: PPUSH
10990: PPUSH
10991: PPUSH
// begin wait ( 0 0$3 ) ;
10992: LD_INT 105
10994: PPUSH
10995: CALL_OW 67
// if not IsDead ( Masha ) then
10999: LD_EXP 48
11003: PPUSH
11004: CALL_OW 301
11008: NOT
11009: IFFALSE 11023
// AddMedal ( Masha , 1 ) else
11011: LD_STRING Masha
11013: PPUSH
11014: LD_INT 1
11016: PPUSH
11017: CALL_OW 101
11021: GO 11034
// AddMedal ( Masha , - 1 ) ;
11023: LD_STRING Masha
11025: PPUSH
11026: LD_INT 1
11028: NEG
11029: PPUSH
11030: CALL_OW 101
// if abdul_escaped then
11034: LD_EXP 12
11038: IFFALSE 11053
// AddMedal ( Abdul , - 1 ) else
11040: LD_STRING Abdul
11042: PPUSH
11043: LD_INT 1
11045: NEG
11046: PPUSH
11047: CALL_OW 101
11051: GO 11063
// AddMedal ( Abdul , 1 ) ;
11053: LD_STRING Abdul
11055: PPUSH
11056: LD_INT 1
11058: PPUSH
11059: CALL_OW 101
// if loss_counter = 0 then
11063: LD_EXP 13
11067: PUSH
11068: LD_INT 0
11070: EQUAL
11071: IFFALSE 11085
// AddMedal ( People , 2 ) else
11073: LD_STRING People
11075: PPUSH
11076: LD_INT 2
11078: PPUSH
11079: CALL_OW 101
11083: GO 11135
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11085: LD_EXP 13
11089: PUSH
11090: LD_INT 3
11092: PUSH
11093: LD_INT 2
11095: PUSH
11096: LD_INT 2
11098: PUSH
11099: EMPTY
11100: LIST
11101: LIST
11102: LIST
11103: PUSH
11104: LD_OWVAR 67
11108: ARRAY
11109: LESSEQUAL
11110: IFFALSE 11124
// AddMedal ( People , 1 ) else
11112: LD_STRING People
11114: PPUSH
11115: LD_INT 1
11117: PPUSH
11118: CALL_OW 101
11122: GO 11135
// AddMedal ( People , - 1 ) ;
11124: LD_STRING People
11126: PPUSH
11127: LD_INT 1
11129: NEG
11130: PPUSH
11131: CALL_OW 101
// GiveMedals ( MAIN ) ;
11135: LD_STRING MAIN
11137: PPUSH
11138: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11142: LD_ADDR_VAR 0 2
11146: PUSH
11147: LD_INT 22
11149: PUSH
11150: LD_INT 7
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: PUSH
11157: LD_INT 2
11159: PUSH
11160: LD_INT 25
11162: PUSH
11163: LD_INT 1
11165: PUSH
11166: EMPTY
11167: LIST
11168: LIST
11169: PUSH
11170: LD_INT 25
11172: PUSH
11173: LD_INT 2
11175: PUSH
11176: EMPTY
11177: LIST
11178: LIST
11179: PUSH
11180: LD_INT 25
11182: PUSH
11183: LD_INT 3
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PUSH
11190: LD_INT 25
11192: PUSH
11193: LD_INT 4
11195: PUSH
11196: EMPTY
11197: LIST
11198: LIST
11199: PUSH
11200: LD_INT 25
11202: PUSH
11203: LD_INT 5
11205: PUSH
11206: EMPTY
11207: LIST
11208: LIST
11209: PUSH
11210: LD_INT 25
11212: PUSH
11213: LD_INT 8
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 25
11222: PUSH
11223: LD_INT 9
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: LIST
11234: LIST
11235: LIST
11236: LIST
11237: LIST
11238: LIST
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PPUSH
11244: CALL_OW 69
11248: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11249: LD_VAR 0 2
11253: PPUSH
11254: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11258: LD_ADDR_VAR 0 3
11262: PUSH
11263: LD_EXP 14
11267: PUSH
11268: LD_EXP 15
11272: PUSH
11273: LD_EXP 16
11277: PUSH
11278: LD_EXP 17
11282: PUSH
11283: LD_EXP 18
11287: PUSH
11288: LD_EXP 19
11292: PUSH
11293: LD_EXP 20
11297: PUSH
11298: LD_EXP 21
11302: PUSH
11303: LD_EXP 22
11307: PUSH
11308: LD_EXP 23
11312: PUSH
11313: LD_EXP 24
11317: PUSH
11318: LD_EXP 25
11322: PUSH
11323: LD_EXP 26
11327: PUSH
11328: LD_EXP 27
11332: PUSH
11333: LD_EXP 28
11337: PUSH
11338: LD_EXP 29
11342: PUSH
11343: LD_EXP 30
11347: PUSH
11348: LD_EXP 31
11352: PUSH
11353: LD_EXP 32
11357: PUSH
11358: LD_EXP 33
11362: PUSH
11363: LD_EXP 35
11367: PUSH
11368: LD_EXP 36
11372: PUSH
11373: LD_EXP 37
11377: PUSH
11378: LD_EXP 38
11382: PUSH
11383: LD_EXP 39
11387: PUSH
11388: LD_EXP 40
11392: PUSH
11393: LD_EXP 41
11397: PUSH
11398: LD_EXP 42
11402: PUSH
11403: LD_EXP 43
11407: PUSH
11408: LD_EXP 44
11412: PUSH
11413: LD_EXP 45
11417: PUSH
11418: LD_EXP 46
11422: PUSH
11423: LD_EXP 47
11427: PUSH
11428: EMPTY
11429: LIST
11430: LIST
11431: LIST
11432: LIST
11433: LIST
11434: LIST
11435: LIST
11436: LIST
11437: LIST
11438: LIST
11439: LIST
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: LIST
11445: LIST
11446: LIST
11447: LIST
11448: LIST
11449: LIST
11450: LIST
11451: LIST
11452: LIST
11453: LIST
11454: LIST
11455: LIST
11456: LIST
11457: LIST
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: ST_TO_ADDR
// if tmp diff tmp2 then
11463: LD_VAR 0 2
11467: PUSH
11468: LD_VAR 0 3
11472: DIFF
11473: IFFALSE 11493
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11475: LD_VAR 0 2
11479: PUSH
11480: LD_VAR 0 3
11484: DIFF
11485: PPUSH
11486: LD_STRING 13a_others
11488: PPUSH
11489: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11493: LD_EXP 14
11497: PPUSH
11498: LD_STRING 13a_JMM
11500: PPUSH
11501: CALL_OW 38
// if Titov then
11505: LD_EXP 33
11509: IFFALSE 11523
// SaveCharacters ( Titov , 13a_Titov ) ;
11511: LD_EXP 33
11515: PPUSH
11516: LD_STRING 13a_Titov
11518: PPUSH
11519: CALL_OW 38
// if Dolgov then
11523: LD_EXP 35
11527: IFFALSE 11541
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11529: LD_EXP 35
11533: PPUSH
11534: LD_STRING 13a_Dolgov
11536: PPUSH
11537: CALL_OW 38
// if Petrosyan then
11541: LD_EXP 36
11545: IFFALSE 11559
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11547: LD_EXP 36
11551: PPUSH
11552: LD_STRING 13a_Petrosyan
11554: PPUSH
11555: CALL_OW 38
// if Scholtze then
11559: LD_EXP 37
11563: IFFALSE 11577
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11565: LD_EXP 37
11569: PPUSH
11570: LD_STRING 13a_Scholtze
11572: PPUSH
11573: CALL_OW 38
// if Oblukov then
11577: LD_EXP 38
11581: IFFALSE 11595
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11583: LD_EXP 38
11587: PPUSH
11588: LD_STRING 13a_Oblukov
11590: PPUSH
11591: CALL_OW 38
// if Kapitsova then
11595: LD_EXP 39
11599: IFFALSE 11613
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11601: LD_EXP 39
11605: PPUSH
11606: LD_STRING 13a_Kapitsova
11608: PPUSH
11609: CALL_OW 38
// if Lipshchin then
11613: LD_EXP 40
11617: IFFALSE 11631
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11619: LD_EXP 40
11623: PPUSH
11624: LD_STRING 13a_Lipshchin
11626: PPUSH
11627: CALL_OW 38
// if Petrovova then
11631: LD_EXP 41
11635: IFFALSE 11649
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11637: LD_EXP 41
11641: PPUSH
11642: LD_STRING 13a_Petrovova
11644: PPUSH
11645: CALL_OW 38
// if Kovalyuk then
11649: LD_EXP 42
11653: IFFALSE 11667
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11655: LD_EXP 42
11659: PPUSH
11660: LD_STRING 13a_Kovalyuk
11662: PPUSH
11663: CALL_OW 38
// if Kuzmov then
11667: LD_EXP 43
11671: IFFALSE 11685
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11673: LD_EXP 43
11677: PPUSH
11678: LD_STRING 13a_Kuzmov
11680: PPUSH
11681: CALL_OW 38
// if Karamazov then
11685: LD_EXP 44
11689: IFFALSE 11703
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11691: LD_EXP 44
11695: PPUSH
11696: LD_STRING 13a_Karamazov
11698: PPUSH
11699: CALL_OW 38
// if Burlak then
11703: LD_EXP 45
11707: IFFALSE 11721
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11709: LD_EXP 45
11713: PPUSH
11714: LD_STRING 13a_Burlak
11716: PPUSH
11717: CALL_OW 38
// if Belkov then
11721: LD_EXP 46
11725: IFFALSE 11739
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11727: LD_EXP 46
11731: PPUSH
11732: LD_STRING 13a_Belkov
11734: PPUSH
11735: CALL_OW 38
// if Gnyevko then
11739: LD_EXP 47
11743: IFFALSE 11757
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11745: LD_EXP 47
11749: PPUSH
11750: LD_STRING 13a_Gnyevko
11752: PPUSH
11753: CALL_OW 38
// if Lisa then
11757: LD_EXP 16
11761: IFFALSE 11775
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11763: LD_EXP 16
11767: PPUSH
11768: LD_STRING 13a_Lisa
11770: PPUSH
11771: CALL_OW 38
// if Donaldson then
11775: LD_EXP 17
11779: IFFALSE 11793
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11781: LD_EXP 17
11785: PPUSH
11786: LD_STRING 13a_Donaldson
11788: PPUSH
11789: CALL_OW 38
// if Bobby then
11793: LD_EXP 18
11797: IFFALSE 11811
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11799: LD_EXP 18
11803: PPUSH
11804: LD_STRING 13a_Bobby
11806: PPUSH
11807: CALL_OW 38
// if Cyrus then
11811: LD_EXP 19
11815: IFFALSE 11829
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11817: LD_EXP 19
11821: PPUSH
11822: LD_STRING 13a_Cyrus
11824: PPUSH
11825: CALL_OW 38
// if Denis then
11829: LD_EXP 20
11833: IFFALSE 11847
// SaveCharacters ( Denis , 13a_Denis ) ;
11835: LD_EXP 20
11839: PPUSH
11840: LD_STRING 13a_Denis
11842: PPUSH
11843: CALL_OW 38
// if Brown then
11847: LD_EXP 21
11851: IFFALSE 11865
// SaveCharacters ( Brown , 13a_Brown ) ;
11853: LD_EXP 21
11857: PPUSH
11858: LD_STRING 13a_Brown
11860: PPUSH
11861: CALL_OW 38
// if Gladstone then
11865: LD_EXP 22
11869: IFFALSE 11883
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11871: LD_EXP 22
11875: PPUSH
11876: LD_STRING 13a_Gladstone
11878: PPUSH
11879: CALL_OW 38
// if Houten then
11883: LD_EXP 23
11887: IFFALSE 11901
// SaveCharacters ( Houten , 13a_Houten ) ;
11889: LD_EXP 23
11893: PPUSH
11894: LD_STRING 13a_Houten
11896: PPUSH
11897: CALL_OW 38
// if Cornel then
11901: LD_EXP 24
11905: IFFALSE 11919
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11907: LD_EXP 24
11911: PPUSH
11912: LD_STRING 13a_Cornel
11914: PPUSH
11915: CALL_OW 38
// if Gary then
11919: LD_EXP 25
11923: IFFALSE 11937
// SaveCharacters ( Gary , 13a_Gary ) ;
11925: LD_EXP 25
11929: PPUSH
11930: LD_STRING 13a_Gary
11932: PPUSH
11933: CALL_OW 38
// if Frank then
11937: LD_EXP 26
11941: IFFALSE 11955
// SaveCharacters ( Frank , 13a_Frank ) ;
11943: LD_EXP 26
11947: PPUSH
11948: LD_STRING 13a_Frank
11950: PPUSH
11951: CALL_OW 38
// if Kikuchi then
11955: LD_EXP 27
11959: IFFALSE 11973
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11961: LD_EXP 27
11965: PPUSH
11966: LD_STRING 13a_Kikuchi
11968: PPUSH
11969: CALL_OW 38
// if Simms then
11973: LD_EXP 28
11977: IFFALSE 11991
// SaveCharacters ( Simms , 13a_Simms ) ;
11979: LD_EXP 28
11983: PPUSH
11984: LD_STRING 13a_Simms
11986: PPUSH
11987: CALL_OW 38
// if Joan then
11991: LD_EXP 29
11995: IFFALSE 12009
// SaveCharacters ( Joan , 13a_Joan ) ;
11997: LD_EXP 29
12001: PPUSH
12002: LD_STRING 13a_Joan
12004: PPUSH
12005: CALL_OW 38
// if DeltaDoctor then
12009: LD_EXP 30
12013: IFFALSE 12027
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12015: LD_EXP 30
12019: PPUSH
12020: LD_STRING 13a_DeltaDoctor
12022: PPUSH
12023: CALL_OW 38
// if Gossudarov then
12027: LD_EXP 31
12031: IFFALSE 12045
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12033: LD_EXP 31
12037: PPUSH
12038: LD_STRING 13a_Gossudarov
12040: PPUSH
12041: CALL_OW 38
// if Kirilenkova then
12045: LD_EXP 32
12049: IFFALSE 12063
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12051: LD_EXP 32
12055: PPUSH
12056: LD_STRING 13a_Kirilenkova
12058: PPUSH
12059: CALL_OW 38
// if Masha then
12063: LD_EXP 48
12067: IFFALSE 12122
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12069: LD_EXP 48
12073: PPUSH
12074: CALL_OW 265
12078: PUSH
12079: LD_EXP 48
12083: PPUSH
12084: CALL_OW 262
12088: PUSH
12089: LD_EXP 48
12093: PPUSH
12094: CALL_OW 263
12098: PUSH
12099: LD_EXP 48
12103: PPUSH
12104: CALL_OW 264
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: PPUSH
12115: LD_STRING 13a_Masha
12117: PPUSH
12118: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12122: LD_ADDR_VAR 0 2
12126: PUSH
12127: LD_INT 21
12129: PUSH
12130: LD_INT 3
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: PPUSH
12137: CALL_OW 69
12141: ST_TO_ADDR
// tmp2 := [ ] ;
12142: LD_ADDR_VAR 0 3
12146: PUSH
12147: EMPTY
12148: ST_TO_ADDR
// if tmp then
12149: LD_VAR 0 2
12153: IFFALSE 12304
// for i in tmp do
12155: LD_ADDR_VAR 0 1
12159: PUSH
12160: LD_VAR 0 2
12164: PUSH
12165: FOR_IN
12166: IFFALSE 12302
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12168: LD_ADDR_VAR 0 3
12172: PUSH
12173: LD_VAR 0 3
12177: PUSH
12178: LD_VAR 0 1
12182: PPUSH
12183: CALL_OW 255
12187: PUSH
12188: LD_VAR 0 1
12192: PPUSH
12193: CALL_OW 248
12197: PUSH
12198: LD_VAR 0 1
12202: PPUSH
12203: CALL_OW 266
12207: PUSH
12208: LD_VAR 0 1
12212: PPUSH
12213: CALL_OW 250
12217: PUSH
12218: LD_VAR 0 1
12222: PPUSH
12223: CALL_OW 251
12227: PUSH
12228: LD_VAR 0 1
12232: PPUSH
12233: CALL_OW 254
12237: PUSH
12238: LD_VAR 0 1
12242: PPUSH
12243: CALL_OW 267
12247: PUSH
12248: LD_VAR 0 1
12252: PPUSH
12253: LD_INT 1
12255: PPUSH
12256: CALL_OW 268
12260: PUSH
12261: LD_VAR 0 1
12265: PPUSH
12266: LD_INT 2
12268: PPUSH
12269: CALL_OW 268
12273: PUSH
12274: LD_VAR 0 1
12278: PPUSH
12279: CALL_OW 269
12283: PUSH
12284: EMPTY
12285: LIST
12286: LIST
12287: LIST
12288: LIST
12289: LIST
12290: LIST
12291: LIST
12292: LIST
12293: LIST
12294: LIST
12295: PUSH
12296: EMPTY
12297: LIST
12298: ADD
12299: ST_TO_ADDR
12300: GO 12165
12302: POP
12303: POP
// if tmp2 then
12304: LD_VAR 0 3
12308: IFFALSE 12322
// SaveVariable ( tmp2 , 13a_buildings ) ;
12310: LD_VAR 0 3
12314: PPUSH
12315: LD_STRING 13a_buildings
12317: PPUSH
12318: CALL_OW 39
// YouWin ;
12322: CALL_OW 103
// end ;
12326: PPOPN 3
12328: END
// export function SciRu ; var tmp , t ; begin
12329: LD_INT 0
12331: PPUSH
12332: PPUSH
12333: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12334: LD_ADDR_VAR 0 3
12338: PUSH
12339: LD_EXP 31
12343: PUSH
12344: LD_EXP 45
12348: PUSH
12349: LD_EXP 33
12353: PUSH
12354: LD_EXP 46
12358: PUSH
12359: LD_EXP 47
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: LIST
12368: LIST
12369: LIST
12370: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12371: LD_ADDR_VAR 0 2
12375: PUSH
12376: LD_INT 22
12378: PUSH
12379: LD_INT 7
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PUSH
12386: LD_INT 23
12388: PUSH
12389: LD_INT 3
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: PUSH
12396: LD_INT 25
12398: PUSH
12399: LD_INT 4
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PUSH
12406: LD_INT 26
12408: PUSH
12409: LD_INT 1
12411: PUSH
12412: EMPTY
12413: LIST
12414: LIST
12415: PUSH
12416: EMPTY
12417: LIST
12418: LIST
12419: LIST
12420: LIST
12421: PPUSH
12422: CALL_OW 69
12426: PUSH
12427: LD_VAR 0 3
12431: DIFF
12432: ST_TO_ADDR
// if tmp then
12433: LD_VAR 0 2
12437: IFFALSE 12453
// result := tmp [ 1 ] ;
12439: LD_ADDR_VAR 0 1
12443: PUSH
12444: LD_VAR 0 2
12448: PUSH
12449: LD_INT 1
12451: ARRAY
12452: ST_TO_ADDR
// end ;
12453: LD_VAR 0 1
12457: RET
// export function SolRu ; var tmp , t ; begin
12458: LD_INT 0
12460: PPUSH
12461: PPUSH
12462: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12463: LD_ADDR_VAR 0 3
12467: PUSH
12468: LD_EXP 46
12472: PUSH
12473: LD_EXP 45
12477: PUSH
12478: LD_EXP 31
12482: PUSH
12483: EMPTY
12484: LIST
12485: LIST
12486: LIST
12487: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12488: LD_ADDR_VAR 0 2
12492: PUSH
12493: LD_INT 22
12495: PUSH
12496: LD_INT 7
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: PUSH
12503: LD_INT 23
12505: PUSH
12506: LD_INT 3
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: PUSH
12513: LD_INT 25
12515: PUSH
12516: LD_INT 1
12518: PUSH
12519: EMPTY
12520: LIST
12521: LIST
12522: PUSH
12523: LD_INT 26
12525: PUSH
12526: LD_INT 1
12528: PUSH
12529: EMPTY
12530: LIST
12531: LIST
12532: PUSH
12533: EMPTY
12534: LIST
12535: LIST
12536: LIST
12537: LIST
12538: PPUSH
12539: CALL_OW 69
12543: PUSH
12544: LD_VAR 0 3
12548: DIFF
12549: ST_TO_ADDR
// if tmp then
12550: LD_VAR 0 2
12554: IFFALSE 12570
// result := tmp [ 1 ] ;
12556: LD_ADDR_VAR 0 1
12560: PUSH
12561: LD_VAR 0 2
12565: PUSH
12566: LD_INT 1
12568: ARRAY
12569: ST_TO_ADDR
// end ; end_of_file
12570: LD_VAR 0 1
12574: RET
// export function CustomEvent ( event ) ; begin
12575: LD_INT 0
12577: PPUSH
// end ;
12578: LD_VAR 0 2
12582: RET
// on UnitDestroyed ( un ) do var i , side ;
12583: LD_INT 0
12585: PPUSH
12586: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12587: LD_VAR 0 1
12591: PUSH
12592: LD_INT 22
12594: PUSH
12595: LD_INT 7
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: PUSH
12602: LD_INT 2
12604: PUSH
12605: LD_INT 25
12607: PUSH
12608: LD_INT 1
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 25
12617: PUSH
12618: LD_INT 2
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 25
12627: PUSH
12628: LD_INT 3
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: LD_INT 25
12637: PUSH
12638: LD_INT 4
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PUSH
12645: LD_INT 25
12647: PUSH
12648: LD_INT 5
12650: PUSH
12651: EMPTY
12652: LIST
12653: LIST
12654: PUSH
12655: LD_INT 25
12657: PUSH
12658: LD_INT 8
12660: PUSH
12661: EMPTY
12662: LIST
12663: LIST
12664: PUSH
12665: LD_INT 25
12667: PUSH
12668: LD_INT 9
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL_OW 69
12693: IN
12694: IFFALSE 12710
// loss_counter := loss_counter + 1 ;
12696: LD_ADDR_EXP 13
12700: PUSH
12701: LD_EXP 13
12705: PUSH
12706: LD_INT 1
12708: PLUS
12709: ST_TO_ADDR
// if un = Abdul then
12710: LD_VAR 0 1
12714: PUSH
12715: LD_EXP 54
12719: EQUAL
12720: IFFALSE 12730
// abdul_escaped := false ;
12722: LD_ADDR_EXP 12
12726: PUSH
12727: LD_INT 0
12729: ST_TO_ADDR
// if un in ru_attackers then
12730: LD_VAR 0 1
12734: PUSH
12735: LD_EXP 51
12739: IN
12740: IFFALSE 12758
// ru_attackers := ru_attackers diff un ;
12742: LD_ADDR_EXP 51
12746: PUSH
12747: LD_EXP 51
12751: PUSH
12752: LD_VAR 0 1
12756: DIFF
12757: ST_TO_ADDR
// if un in ar_attackers then
12758: LD_VAR 0 1
12762: PUSH
12763: LD_EXP 10
12767: IN
12768: IFFALSE 12786
// ar_attackers := ar_attackers diff un ;
12770: LD_ADDR_EXP 10
12774: PUSH
12775: LD_EXP 10
12779: PUSH
12780: LD_VAR 0 1
12784: DIFF
12785: ST_TO_ADDR
// if un = JMM then
12786: LD_VAR 0 1
12790: PUSH
12791: LD_EXP 14
12795: EQUAL
12796: IFFALSE 12807
// begin YouLost ( JMM ) ;
12798: LD_STRING JMM
12800: PPUSH
12801: CALL_OW 104
// exit ;
12805: GO 12896
// end ; if un = Burlak then
12807: LD_VAR 0 1
12811: PUSH
12812: LD_EXP 45
12816: EQUAL
12817: IFFALSE 12828
// begin YouLost ( Burlak ) ;
12819: LD_STRING Burlak
12821: PPUSH
12822: CALL_OW 104
// exit ;
12826: GO 12896
// end ; if un = freedom then
12828: LD_VAR 0 1
12832: PUSH
12833: LD_EXP 3
12837: EQUAL
12838: IFFALSE 12849
// begin YouLost ( Destroyed ) ;
12840: LD_STRING Destroyed
12842: PPUSH
12843: CALL_OW 104
// exit ;
12847: GO 12896
// end ; if un = Masha then
12849: LD_VAR 0 1
12853: PUSH
12854: LD_EXP 48
12858: EQUAL
12859: IFFALSE 12868
// ChangeMissionObjectives ( M4b ) ;
12861: LD_STRING M4b
12863: PPUSH
12864: CALL_OW 337
// if un = Mastodont then
12868: LD_VAR 0 1
12872: PUSH
12873: LD_EXP 55
12877: EQUAL
12878: IFFALSE 12887
// ChangeMissionObjectives ( M4a ) ;
12880: LD_STRING M4a
12882: PPUSH
12883: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12887: LD_VAR 0 1
12891: PPUSH
12892: CALL 81980 0 1
// end ;
12896: PPOPN 3
12898: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12899: LD_VAR 0 1
12903: PPUSH
12904: LD_VAR 0 2
12908: PPUSH
12909: CALL 83959 0 2
// end ;
12913: PPOPN 2
12915: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12916: LD_VAR 0 1
12920: PPUSH
12921: CALL 83027 0 1
// end ;
12925: PPOPN 1
12927: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12928: LD_VAR 0 1
12932: PUSH
12933: LD_INT 22
12935: PUSH
12936: LD_INT 7
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: PUSH
12943: LD_INT 30
12945: PUSH
12946: LD_INT 0
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: EMPTY
12954: LIST
12955: LIST
12956: PPUSH
12957: CALL_OW 69
12961: IN
12962: IFFALSE 13001
// begin SetBName ( building , freedom ) ;
12964: LD_VAR 0 1
12968: PPUSH
12969: LD_STRING freedom
12971: PPUSH
12972: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12976: LD_INT 0
12978: PPUSH
12979: LD_INT 7
12981: PPUSH
12982: LD_INT 0
12984: PPUSH
12985: CALL_OW 324
// freedom := building ;
12989: LD_ADDR_EXP 3
12993: PUSH
12994: LD_VAR 0 1
12998: ST_TO_ADDR
// exit ;
12999: GO 13067
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13001: LD_VAR 0 1
13005: PUSH
13006: LD_INT 22
13008: PUSH
13009: LD_INT 7
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: PUSH
13016: LD_INT 23
13018: PUSH
13019: LD_INT 3
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: PUSH
13026: LD_INT 30
13028: PUSH
13029: LD_INT 6
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: LIST
13040: PPUSH
13041: CALL_OW 69
13045: IN
13046: IFFALSE 13058
// begin ru_lab_builded := true ;
13048: LD_ADDR_EXP 5
13052: PUSH
13053: LD_INT 1
13055: ST_TO_ADDR
// exit ;
13056: GO 13067
// end ; MCE_BuildingComplete ( building ) ;
13058: LD_VAR 0 1
13062: PPUSH
13063: CALL 83268 0 1
// end ;
13067: PPOPN 1
13069: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13070: LD_VAR 0 1
13074: PPUSH
13075: LD_VAR 0 2
13079: PPUSH
13080: CALL 81676 0 2
// end ;
13084: PPOPN 2
13086: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13087: LD_VAR 0 1
13091: PPUSH
13092: LD_VAR 0 2
13096: PPUSH
13097: LD_VAR 0 3
13101: PPUSH
13102: LD_VAR 0 4
13106: PPUSH
13107: LD_VAR 0 5
13111: PPUSH
13112: CALL 81296 0 5
// end ;
13116: PPOPN 5
13118: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: LD_VAR 0 2
13128: PPUSH
13129: CALL 80886 0 2
// end ;
13133: PPOPN 2
13135: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13136: LD_VAR 0 1
13140: PPUSH
13141: LD_VAR 0 2
13145: PPUSH
13146: LD_VAR 0 3
13150: PPUSH
13151: LD_VAR 0 4
13155: PPUSH
13156: CALL 80724 0 4
// end ;
13160: PPOPN 4
13162: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13163: LD_VAR 0 1
13167: PPUSH
13168: LD_VAR 0 2
13172: PPUSH
13173: LD_VAR 0 3
13177: PPUSH
13178: CALL 80499 0 3
// end ;
13182: PPOPN 3
13184: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13185: LD_VAR 0 1
13189: PPUSH
13190: LD_VAR 0 2
13194: PPUSH
13195: CALL 80384 0 2
// end ;
13199: PPOPN 2
13201: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13202: LD_VAR 0 1
13206: PPUSH
13207: LD_VAR 0 2
13211: PPUSH
13212: CALL 84220 0 2
// end ;
13216: PPOPN 2
13218: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13219: LD_VAR 0 1
13223: PPUSH
13224: LD_VAR 0 2
13228: PPUSH
13229: LD_VAR 0 3
13233: PPUSH
13234: LD_VAR 0 4
13238: PPUSH
13239: CALL 84436 0 4
// end ;
13243: PPOPN 4
13245: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13246: LD_VAR 0 1
13250: PPUSH
13251: LD_VAR 0 2
13255: PPUSH
13256: CALL 80193 0 2
// end ; end_of_file
13260: PPOPN 2
13262: END
// every 0 0$30 do var cr , time ;
13263: GO 13265
13265: DISABLE
13266: LD_INT 0
13268: PPUSH
13269: PPUSH
// begin time := 0 0$30 ;
13270: LD_ADDR_VAR 0 2
13274: PUSH
13275: LD_INT 1050
13277: ST_TO_ADDR
// while game do
13278: LD_EXP 2
13282: IFFALSE 13381
// begin wait ( time ) ;
13284: LD_VAR 0 2
13288: PPUSH
13289: CALL_OW 67
// if tick > 2 2$00 then
13293: LD_OWVAR 1
13297: PUSH
13298: LD_INT 4200
13300: GREATER
13301: IFFALSE 13334
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13303: LD_ADDR_VAR 0 2
13307: PUSH
13308: LD_VAR 0 2
13312: PUSH
13313: LD_INT 280
13315: PUSH
13316: LD_INT 420
13318: PUSH
13319: LD_INT 630
13321: PUSH
13322: EMPTY
13323: LIST
13324: LIST
13325: LIST
13326: PUSH
13327: LD_OWVAR 67
13331: ARRAY
13332: PLUS
13333: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13334: LD_INT 1
13336: PPUSH
13337: LD_INT 5
13339: PPUSH
13340: CALL_OW 12
13344: PPUSH
13345: LD_INT 70
13347: PPUSH
13348: LD_INT 49
13350: PPUSH
13351: LD_INT 25
13353: PPUSH
13354: LD_INT 1
13356: PPUSH
13357: CALL_OW 56
// if time > 5 5$00 then
13361: LD_VAR 0 2
13365: PUSH
13366: LD_INT 10500
13368: GREATER
13369: IFFALSE 13379
// time := 0 0$30 ;
13371: LD_ADDR_VAR 0 2
13375: PUSH
13376: LD_INT 1050
13378: ST_TO_ADDR
// end ;
13379: GO 13278
// end ;
13381: PPOPN 2
13383: END
// every 0 0$30 do var cr , time ;
13384: GO 13386
13386: DISABLE
13387: LD_INT 0
13389: PPUSH
13390: PPUSH
// begin time := 0 0$20 ;
13391: LD_ADDR_VAR 0 2
13395: PUSH
13396: LD_INT 700
13398: ST_TO_ADDR
// while game do
13399: LD_EXP 2
13403: IFFALSE 13492
// begin wait ( time ) ;
13405: LD_VAR 0 2
13409: PPUSH
13410: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13414: LD_ADDR_VAR 0 2
13418: PUSH
13419: LD_VAR 0 2
13423: PUSH
13424: LD_INT 490
13426: PUSH
13427: LD_INT 525
13429: PUSH
13430: LD_INT 560
13432: PUSH
13433: EMPTY
13434: LIST
13435: LIST
13436: LIST
13437: PUSH
13438: LD_OWVAR 67
13442: ARRAY
13443: PLUS
13444: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13445: LD_INT 3
13447: PPUSH
13448: LD_INT 5
13450: PPUSH
13451: CALL_OW 12
13455: PPUSH
13456: LD_INT 26
13458: PPUSH
13459: LD_INT 9
13461: PPUSH
13462: LD_INT 30
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 56
// if time > 3 3$00 then
13472: LD_VAR 0 2
13476: PUSH
13477: LD_INT 6300
13479: GREATER
13480: IFFALSE 13490
// time := 0 0$20 ;
13482: LD_ADDR_VAR 0 2
13486: PUSH
13487: LD_INT 700
13489: ST_TO_ADDR
// end ;
13490: GO 13399
// end ;
13492: PPOPN 2
13494: END
// every 0 0$30 do var cr , time ;
13495: GO 13497
13497: DISABLE
13498: LD_INT 0
13500: PPUSH
13501: PPUSH
// begin time := 0 0$20 ;
13502: LD_ADDR_VAR 0 2
13506: PUSH
13507: LD_INT 700
13509: ST_TO_ADDR
// while game do
13510: LD_EXP 2
13514: IFFALSE 13639
// begin wait ( time ) ;
13516: LD_VAR 0 2
13520: PPUSH
13521: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13525: LD_ADDR_VAR 0 2
13529: PUSH
13530: LD_VAR 0 2
13534: PUSH
13535: LD_INT 175
13537: PUSH
13538: LD_INT 210
13540: PUSH
13541: LD_INT 280
13543: PUSH
13544: EMPTY
13545: LIST
13546: LIST
13547: LIST
13548: PUSH
13549: LD_OWVAR 67
13553: ARRAY
13554: PLUS
13555: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13556: LD_INT 1
13558: PPUSH
13559: LD_INT 5
13561: PPUSH
13562: CALL_OW 12
13566: PPUSH
13567: LD_INT 179
13569: PPUSH
13570: LD_INT 101
13572: PPUSH
13573: LD_INT 20
13575: PPUSH
13576: LD_INT 1
13578: PPUSH
13579: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13583: LD_INT 350
13585: PPUSH
13586: LD_INT 525
13588: PPUSH
13589: CALL_OW 12
13593: PPUSH
13594: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13598: LD_INT 1
13600: PPUSH
13601: LD_INT 5
13603: PPUSH
13604: CALL_OW 12
13608: PPUSH
13609: LD_INT 9
13611: PPUSH
13612: LD_INT 1
13614: PPUSH
13615: CALL_OW 55
// if time > 4 4$00 then
13619: LD_VAR 0 2
13623: PUSH
13624: LD_INT 8400
13626: GREATER
13627: IFFALSE 13637
// time := 0 0$30 ;
13629: LD_ADDR_VAR 0 2
13633: PUSH
13634: LD_INT 1050
13636: ST_TO_ADDR
// end ;
13637: GO 13510
// end ;
13639: PPOPN 2
13641: END
// every 0 0$30 do var cr , time ;
13642: GO 13644
13644: DISABLE
13645: LD_INT 0
13647: PPUSH
13648: PPUSH
// begin time := 0 0$10 ;
13649: LD_ADDR_VAR 0 2
13653: PUSH
13654: LD_INT 350
13656: ST_TO_ADDR
// while game do
13657: LD_EXP 2
13661: IFFALSE 13795
// begin wait ( time ) ;
13663: LD_VAR 0 2
13667: PPUSH
13668: CALL_OW 67
// time := time + 0 0$10 ;
13672: LD_ADDR_VAR 0 2
13676: PUSH
13677: LD_VAR 0 2
13681: PUSH
13682: LD_INT 350
13684: PLUS
13685: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13686: LD_INT 1
13688: PPUSH
13689: LD_INT 5
13691: PPUSH
13692: CALL_OW 12
13696: PPUSH
13697: LD_INT 11
13699: PPUSH
13700: LD_INT 1
13702: PPUSH
13703: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13707: LD_ADDR_VAR 0 1
13711: PUSH
13712: LD_INT 1
13714: PPUSH
13715: LD_INT 3
13717: PPUSH
13718: CALL_OW 12
13722: ST_TO_ADDR
// if cr = 1 then
13723: LD_VAR 0 1
13727: PUSH
13728: LD_INT 1
13730: EQUAL
13731: IFFALSE 13775
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13733: LD_INT 700
13735: PPUSH
13736: LD_INT 1575
13738: PPUSH
13739: CALL_OW 12
13743: PPUSH
13744: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13748: LD_INT 1
13750: PPUSH
13751: LD_INT 5
13753: PPUSH
13754: CALL_OW 12
13758: PPUSH
13759: LD_INT 34
13761: PPUSH
13762: LD_INT 50
13764: PPUSH
13765: LD_INT 7
13767: PPUSH
13768: LD_INT 1
13770: PPUSH
13771: CALL_OW 56
// end ; if time > 8 8$00 then
13775: LD_VAR 0 2
13779: PUSH
13780: LD_INT 16800
13782: GREATER
13783: IFFALSE 13793
// time := 0 0$40 ;
13785: LD_ADDR_VAR 0 2
13789: PUSH
13790: LD_INT 1400
13792: ST_TO_ADDR
// end ;
13793: GO 13657
// end ; end_of_file
13795: PPOPN 2
13797: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13798: LD_INT 0
13800: PPUSH
13801: PPUSH
// if exist_mode then
13802: LD_VAR 0 2
13806: IFFALSE 13831
// unit := CreateCharacter ( prefix & ident ) else
13808: LD_ADDR_VAR 0 5
13812: PUSH
13813: LD_VAR 0 3
13817: PUSH
13818: LD_VAR 0 1
13822: STR
13823: PPUSH
13824: CALL_OW 34
13828: ST_TO_ADDR
13829: GO 13846
// unit := NewCharacter ( ident ) ;
13831: LD_ADDR_VAR 0 5
13835: PUSH
13836: LD_VAR 0 1
13840: PPUSH
13841: CALL_OW 25
13845: ST_TO_ADDR
// result := unit ;
13846: LD_ADDR_VAR 0 4
13850: PUSH
13851: LD_VAR 0 5
13855: ST_TO_ADDR
// end ;
13856: LD_VAR 0 4
13860: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13861: LD_INT 0
13863: PPUSH
13864: PPUSH
// if not side or not nation then
13865: LD_VAR 0 1
13869: NOT
13870: PUSH
13871: LD_VAR 0 2
13875: NOT
13876: OR
13877: IFFALSE 13881
// exit ;
13879: GO 14517
// case nation of nation_american :
13881: LD_VAR 0 2
13885: PUSH
13886: LD_INT 1
13888: DOUBLE
13889: EQUAL
13890: IFTRUE 13894
13892: GO 14064
13894: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13895: LD_ADDR_VAR 0 4
13899: PUSH
13900: LD_INT 35
13902: PUSH
13903: LD_INT 45
13905: PUSH
13906: LD_INT 46
13908: PUSH
13909: LD_INT 47
13911: PUSH
13912: LD_INT 1
13914: PUSH
13915: LD_INT 2
13917: PUSH
13918: LD_INT 6
13920: PUSH
13921: LD_INT 15
13923: PUSH
13924: LD_INT 16
13926: PUSH
13927: LD_INT 7
13929: PUSH
13930: LD_INT 12
13932: PUSH
13933: LD_INT 13
13935: PUSH
13936: LD_INT 10
13938: PUSH
13939: LD_INT 14
13941: PUSH
13942: LD_INT 20
13944: PUSH
13945: LD_INT 21
13947: PUSH
13948: LD_INT 22
13950: PUSH
13951: LD_INT 25
13953: PUSH
13954: LD_INT 32
13956: PUSH
13957: LD_INT 27
13959: PUSH
13960: LD_INT 36
13962: PUSH
13963: LD_INT 69
13965: PUSH
13966: LD_INT 39
13968: PUSH
13969: LD_INT 34
13971: PUSH
13972: LD_INT 40
13974: PUSH
13975: LD_INT 48
13977: PUSH
13978: LD_INT 49
13980: PUSH
13981: LD_INT 50
13983: PUSH
13984: LD_INT 51
13986: PUSH
13987: LD_INT 52
13989: PUSH
13990: LD_INT 53
13992: PUSH
13993: LD_INT 54
13995: PUSH
13996: LD_INT 55
13998: PUSH
13999: LD_INT 56
14001: PUSH
14002: LD_INT 57
14004: PUSH
14005: LD_INT 58
14007: PUSH
14008: LD_INT 59
14010: PUSH
14011: LD_INT 60
14013: PUSH
14014: LD_INT 61
14016: PUSH
14017: LD_INT 62
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: LIST
14024: LIST
14025: LIST
14026: LIST
14027: LIST
14028: LIST
14029: LIST
14030: LIST
14031: LIST
14032: LIST
14033: LIST
14034: LIST
14035: LIST
14036: LIST
14037: LIST
14038: LIST
14039: LIST
14040: LIST
14041: LIST
14042: LIST
14043: LIST
14044: LIST
14045: LIST
14046: LIST
14047: LIST
14048: LIST
14049: LIST
14050: LIST
14051: LIST
14052: LIST
14053: LIST
14054: LIST
14055: LIST
14056: LIST
14057: LIST
14058: LIST
14059: LIST
14060: LIST
14061: ST_TO_ADDR
14062: GO 14441
14064: LD_INT 2
14066: DOUBLE
14067: EQUAL
14068: IFTRUE 14072
14070: GO 14250
14072: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14073: LD_ADDR_VAR 0 4
14077: PUSH
14078: LD_INT 35
14080: PUSH
14081: LD_INT 45
14083: PUSH
14084: LD_INT 46
14086: PUSH
14087: LD_INT 47
14089: PUSH
14090: LD_INT 70
14092: PUSH
14093: LD_INT 1
14095: PUSH
14096: LD_INT 11
14098: PUSH
14099: LD_INT 3
14101: PUSH
14102: LD_INT 4
14104: PUSH
14105: LD_INT 5
14107: PUSH
14108: LD_INT 6
14110: PUSH
14111: LD_INT 15
14113: PUSH
14114: LD_INT 18
14116: PUSH
14117: LD_INT 7
14119: PUSH
14120: LD_INT 17
14122: PUSH
14123: LD_INT 8
14125: PUSH
14126: LD_INT 20
14128: PUSH
14129: LD_INT 21
14131: PUSH
14132: LD_INT 22
14134: PUSH
14135: LD_INT 72
14137: PUSH
14138: LD_INT 26
14140: PUSH
14141: LD_INT 69
14143: PUSH
14144: LD_INT 39
14146: PUSH
14147: LD_INT 40
14149: PUSH
14150: LD_INT 41
14152: PUSH
14153: LD_INT 42
14155: PUSH
14156: LD_INT 43
14158: PUSH
14159: LD_INT 48
14161: PUSH
14162: LD_INT 49
14164: PUSH
14165: LD_INT 50
14167: PUSH
14168: LD_INT 51
14170: PUSH
14171: LD_INT 52
14173: PUSH
14174: LD_INT 53
14176: PUSH
14177: LD_INT 54
14179: PUSH
14180: LD_INT 55
14182: PUSH
14183: LD_INT 56
14185: PUSH
14186: LD_INT 60
14188: PUSH
14189: LD_INT 61
14191: PUSH
14192: LD_INT 62
14194: PUSH
14195: LD_INT 66
14197: PUSH
14198: LD_INT 67
14200: PUSH
14201: LD_INT 68
14203: PUSH
14204: EMPTY
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: LIST
14234: LIST
14235: LIST
14236: LIST
14237: LIST
14238: LIST
14239: LIST
14240: LIST
14241: LIST
14242: LIST
14243: LIST
14244: LIST
14245: LIST
14246: LIST
14247: ST_TO_ADDR
14248: GO 14441
14250: LD_INT 3
14252: DOUBLE
14253: EQUAL
14254: IFTRUE 14258
14256: GO 14440
14258: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14259: LD_ADDR_VAR 0 4
14263: PUSH
14264: LD_INT 46
14266: PUSH
14267: LD_INT 47
14269: PUSH
14270: LD_INT 1
14272: PUSH
14273: LD_INT 2
14275: PUSH
14276: LD_INT 11
14278: PUSH
14279: LD_INT 9
14281: PUSH
14282: LD_INT 20
14284: PUSH
14285: LD_INT 19
14287: PUSH
14288: LD_INT 21
14290: PUSH
14291: LD_INT 24
14293: PUSH
14294: LD_INT 22
14296: PUSH
14297: LD_INT 25
14299: PUSH
14300: LD_INT 28
14302: PUSH
14303: LD_INT 29
14305: PUSH
14306: LD_INT 30
14308: PUSH
14309: LD_INT 31
14311: PUSH
14312: LD_INT 37
14314: PUSH
14315: LD_INT 38
14317: PUSH
14318: LD_INT 32
14320: PUSH
14321: LD_INT 27
14323: PUSH
14324: LD_INT 33
14326: PUSH
14327: LD_INT 69
14329: PUSH
14330: LD_INT 39
14332: PUSH
14333: LD_INT 34
14335: PUSH
14336: LD_INT 40
14338: PUSH
14339: LD_INT 71
14341: PUSH
14342: LD_INT 23
14344: PUSH
14345: LD_INT 44
14347: PUSH
14348: LD_INT 48
14350: PUSH
14351: LD_INT 49
14353: PUSH
14354: LD_INT 50
14356: PUSH
14357: LD_INT 51
14359: PUSH
14360: LD_INT 52
14362: PUSH
14363: LD_INT 53
14365: PUSH
14366: LD_INT 54
14368: PUSH
14369: LD_INT 55
14371: PUSH
14372: LD_INT 56
14374: PUSH
14375: LD_INT 57
14377: PUSH
14378: LD_INT 58
14380: PUSH
14381: LD_INT 59
14383: PUSH
14384: LD_INT 63
14386: PUSH
14387: LD_INT 64
14389: PUSH
14390: LD_INT 65
14392: PUSH
14393: EMPTY
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: LIST
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: LIST
14432: LIST
14433: LIST
14434: LIST
14435: LIST
14436: LIST
14437: ST_TO_ADDR
14438: GO 14441
14440: POP
// if state > - 1 and state < 3 then
14441: LD_VAR 0 3
14445: PUSH
14446: LD_INT 1
14448: NEG
14449: GREATER
14450: PUSH
14451: LD_VAR 0 3
14455: PUSH
14456: LD_INT 3
14458: LESS
14459: AND
14460: IFFALSE 14517
// for i in result do
14462: LD_ADDR_VAR 0 5
14466: PUSH
14467: LD_VAR 0 4
14471: PUSH
14472: FOR_IN
14473: IFFALSE 14515
// if GetTech ( i , side ) <> state then
14475: LD_VAR 0 5
14479: PPUSH
14480: LD_VAR 0 1
14484: PPUSH
14485: CALL_OW 321
14489: PUSH
14490: LD_VAR 0 3
14494: NONEQUAL
14495: IFFALSE 14513
// result := result diff i ;
14497: LD_ADDR_VAR 0 4
14501: PUSH
14502: LD_VAR 0 4
14506: PUSH
14507: LD_VAR 0 5
14511: DIFF
14512: ST_TO_ADDR
14513: GO 14472
14515: POP
14516: POP
// end ;
14517: LD_VAR 0 4
14521: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14522: LD_INT 0
14524: PPUSH
14525: PPUSH
14526: PPUSH
// result := true ;
14527: LD_ADDR_VAR 0 3
14531: PUSH
14532: LD_INT 1
14534: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14535: LD_ADDR_VAR 0 5
14539: PUSH
14540: LD_VAR 0 2
14544: PPUSH
14545: CALL_OW 480
14549: ST_TO_ADDR
// if not tmp then
14550: LD_VAR 0 5
14554: NOT
14555: IFFALSE 14559
// exit ;
14557: GO 14608
// for i in tmp do
14559: LD_ADDR_VAR 0 4
14563: PUSH
14564: LD_VAR 0 5
14568: PUSH
14569: FOR_IN
14570: IFFALSE 14606
// if GetTech ( i , side ) <> state_researched then
14572: LD_VAR 0 4
14576: PPUSH
14577: LD_VAR 0 1
14581: PPUSH
14582: CALL_OW 321
14586: PUSH
14587: LD_INT 2
14589: NONEQUAL
14590: IFFALSE 14604
// begin result := false ;
14592: LD_ADDR_VAR 0 3
14596: PUSH
14597: LD_INT 0
14599: ST_TO_ADDR
// exit ;
14600: POP
14601: POP
14602: GO 14608
// end ;
14604: GO 14569
14606: POP
14607: POP
// end ;
14608: LD_VAR 0 3
14612: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14613: LD_INT 0
14615: PPUSH
14616: PPUSH
14617: PPUSH
14618: PPUSH
14619: PPUSH
14620: PPUSH
14621: PPUSH
14622: PPUSH
14623: PPUSH
14624: PPUSH
14625: PPUSH
14626: PPUSH
14627: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14628: LD_VAR 0 1
14632: NOT
14633: PUSH
14634: LD_VAR 0 1
14638: PPUSH
14639: CALL_OW 257
14643: PUSH
14644: LD_INT 9
14646: NONEQUAL
14647: OR
14648: IFFALSE 14652
// exit ;
14650: GO 15225
// side := GetSide ( unit ) ;
14652: LD_ADDR_VAR 0 9
14656: PUSH
14657: LD_VAR 0 1
14661: PPUSH
14662: CALL_OW 255
14666: ST_TO_ADDR
// tech_space := tech_spacanom ;
14667: LD_ADDR_VAR 0 12
14671: PUSH
14672: LD_INT 29
14674: ST_TO_ADDR
// tech_time := tech_taurad ;
14675: LD_ADDR_VAR 0 13
14679: PUSH
14680: LD_INT 28
14682: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14683: LD_ADDR_VAR 0 11
14687: PUSH
14688: LD_VAR 0 1
14692: PPUSH
14693: CALL_OW 310
14697: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14698: LD_VAR 0 11
14702: PPUSH
14703: CALL_OW 247
14707: PUSH
14708: LD_INT 2
14710: EQUAL
14711: IFFALSE 14715
// exit ;
14713: GO 15225
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14715: LD_ADDR_VAR 0 8
14719: PUSH
14720: LD_INT 81
14722: PUSH
14723: LD_VAR 0 9
14727: PUSH
14728: EMPTY
14729: LIST
14730: LIST
14731: PUSH
14732: LD_INT 3
14734: PUSH
14735: LD_INT 21
14737: PUSH
14738: LD_INT 3
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PPUSH
14753: CALL_OW 69
14757: ST_TO_ADDR
// if not tmp then
14758: LD_VAR 0 8
14762: NOT
14763: IFFALSE 14767
// exit ;
14765: GO 15225
// if in_unit then
14767: LD_VAR 0 11
14771: IFFALSE 14795
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14773: LD_ADDR_VAR 0 10
14777: PUSH
14778: LD_VAR 0 8
14782: PPUSH
14783: LD_VAR 0 11
14787: PPUSH
14788: CALL_OW 74
14792: ST_TO_ADDR
14793: GO 14815
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14795: LD_ADDR_VAR 0 10
14799: PUSH
14800: LD_VAR 0 8
14804: PPUSH
14805: LD_VAR 0 1
14809: PPUSH
14810: CALL_OW 74
14814: ST_TO_ADDR
// if not enemy then
14815: LD_VAR 0 10
14819: NOT
14820: IFFALSE 14824
// exit ;
14822: GO 15225
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14824: LD_VAR 0 11
14828: PUSH
14829: LD_VAR 0 11
14833: PPUSH
14834: LD_VAR 0 10
14838: PPUSH
14839: CALL_OW 296
14843: PUSH
14844: LD_INT 13
14846: GREATER
14847: AND
14848: PUSH
14849: LD_VAR 0 1
14853: PPUSH
14854: LD_VAR 0 10
14858: PPUSH
14859: CALL_OW 296
14863: PUSH
14864: LD_INT 12
14866: GREATER
14867: OR
14868: IFFALSE 14872
// exit ;
14870: GO 15225
// missile := [ 1 ] ;
14872: LD_ADDR_VAR 0 14
14876: PUSH
14877: LD_INT 1
14879: PUSH
14880: EMPTY
14881: LIST
14882: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14883: LD_VAR 0 9
14887: PPUSH
14888: LD_VAR 0 12
14892: PPUSH
14893: CALL_OW 325
14897: IFFALSE 14926
// missile := Insert ( missile , missile + 1 , 2 ) ;
14899: LD_ADDR_VAR 0 14
14903: PUSH
14904: LD_VAR 0 14
14908: PPUSH
14909: LD_VAR 0 14
14913: PUSH
14914: LD_INT 1
14916: PLUS
14917: PPUSH
14918: LD_INT 2
14920: PPUSH
14921: CALL_OW 2
14925: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14926: LD_VAR 0 9
14930: PPUSH
14931: LD_VAR 0 13
14935: PPUSH
14936: CALL_OW 325
14940: PUSH
14941: LD_VAR 0 10
14945: PPUSH
14946: CALL_OW 255
14950: PPUSH
14951: LD_VAR 0 13
14955: PPUSH
14956: CALL_OW 325
14960: NOT
14961: AND
14962: IFFALSE 14991
// missile := Insert ( missile , missile + 1 , 3 ) ;
14964: LD_ADDR_VAR 0 14
14968: PUSH
14969: LD_VAR 0 14
14973: PPUSH
14974: LD_VAR 0 14
14978: PUSH
14979: LD_INT 1
14981: PLUS
14982: PPUSH
14983: LD_INT 3
14985: PPUSH
14986: CALL_OW 2
14990: ST_TO_ADDR
// if missile < 2 then
14991: LD_VAR 0 14
14995: PUSH
14996: LD_INT 2
14998: LESS
14999: IFFALSE 15003
// exit ;
15001: GO 15225
// x := GetX ( enemy ) ;
15003: LD_ADDR_VAR 0 4
15007: PUSH
15008: LD_VAR 0 10
15012: PPUSH
15013: CALL_OW 250
15017: ST_TO_ADDR
// y := GetY ( enemy ) ;
15018: LD_ADDR_VAR 0 5
15022: PUSH
15023: LD_VAR 0 10
15027: PPUSH
15028: CALL_OW 251
15032: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15033: LD_ADDR_VAR 0 6
15037: PUSH
15038: LD_VAR 0 4
15042: PUSH
15043: LD_INT 1
15045: NEG
15046: PPUSH
15047: LD_INT 1
15049: PPUSH
15050: CALL_OW 12
15054: PLUS
15055: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15056: LD_ADDR_VAR 0 7
15060: PUSH
15061: LD_VAR 0 5
15065: PUSH
15066: LD_INT 1
15068: NEG
15069: PPUSH
15070: LD_INT 1
15072: PPUSH
15073: CALL_OW 12
15077: PLUS
15078: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15079: LD_VAR 0 6
15083: PPUSH
15084: LD_VAR 0 7
15088: PPUSH
15089: CALL_OW 488
15093: NOT
15094: IFFALSE 15116
// begin _x := x ;
15096: LD_ADDR_VAR 0 6
15100: PUSH
15101: LD_VAR 0 4
15105: ST_TO_ADDR
// _y := y ;
15106: LD_ADDR_VAR 0 7
15110: PUSH
15111: LD_VAR 0 5
15115: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15116: LD_ADDR_VAR 0 3
15120: PUSH
15121: LD_INT 1
15123: PPUSH
15124: LD_VAR 0 14
15128: PPUSH
15129: CALL_OW 12
15133: ST_TO_ADDR
// case i of 1 :
15134: LD_VAR 0 3
15138: PUSH
15139: LD_INT 1
15141: DOUBLE
15142: EQUAL
15143: IFTRUE 15147
15145: GO 15164
15147: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15148: LD_VAR 0 1
15152: PPUSH
15153: LD_VAR 0 10
15157: PPUSH
15158: CALL_OW 115
15162: GO 15225
15164: LD_INT 2
15166: DOUBLE
15167: EQUAL
15168: IFTRUE 15172
15170: GO 15194
15172: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15173: LD_VAR 0 1
15177: PPUSH
15178: LD_VAR 0 6
15182: PPUSH
15183: LD_VAR 0 7
15187: PPUSH
15188: CALL_OW 153
15192: GO 15225
15194: LD_INT 3
15196: DOUBLE
15197: EQUAL
15198: IFTRUE 15202
15200: GO 15224
15202: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15203: LD_VAR 0 1
15207: PPUSH
15208: LD_VAR 0 6
15212: PPUSH
15213: LD_VAR 0 7
15217: PPUSH
15218: CALL_OW 154
15222: GO 15225
15224: POP
// end ;
15225: LD_VAR 0 2
15229: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15230: LD_INT 0
15232: PPUSH
15233: PPUSH
15234: PPUSH
15235: PPUSH
15236: PPUSH
15237: PPUSH
// if not unit or not building then
15238: LD_VAR 0 1
15242: NOT
15243: PUSH
15244: LD_VAR 0 2
15248: NOT
15249: OR
15250: IFFALSE 15254
// exit ;
15252: GO 15412
// x := GetX ( building ) ;
15254: LD_ADDR_VAR 0 5
15258: PUSH
15259: LD_VAR 0 2
15263: PPUSH
15264: CALL_OW 250
15268: ST_TO_ADDR
// y := GetY ( building ) ;
15269: LD_ADDR_VAR 0 6
15273: PUSH
15274: LD_VAR 0 2
15278: PPUSH
15279: CALL_OW 251
15283: ST_TO_ADDR
// for i = 0 to 5 do
15284: LD_ADDR_VAR 0 4
15288: PUSH
15289: DOUBLE
15290: LD_INT 0
15292: DEC
15293: ST_TO_ADDR
15294: LD_INT 5
15296: PUSH
15297: FOR_TO
15298: IFFALSE 15410
// begin _x := ShiftX ( x , i , 3 ) ;
15300: LD_ADDR_VAR 0 7
15304: PUSH
15305: LD_VAR 0 5
15309: PPUSH
15310: LD_VAR 0 4
15314: PPUSH
15315: LD_INT 3
15317: PPUSH
15318: CALL_OW 272
15322: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15323: LD_ADDR_VAR 0 8
15327: PUSH
15328: LD_VAR 0 6
15332: PPUSH
15333: LD_VAR 0 4
15337: PPUSH
15338: LD_INT 3
15340: PPUSH
15341: CALL_OW 273
15345: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15346: LD_VAR 0 7
15350: PPUSH
15351: LD_VAR 0 8
15355: PPUSH
15356: CALL_OW 488
15360: NOT
15361: IFFALSE 15365
// continue ;
15363: GO 15297
// if HexInfo ( _x , _y ) = 0 then
15365: LD_VAR 0 7
15369: PPUSH
15370: LD_VAR 0 8
15374: PPUSH
15375: CALL_OW 428
15379: PUSH
15380: LD_INT 0
15382: EQUAL
15383: IFFALSE 15408
// begin ComMoveXY ( unit , _x , _y ) ;
15385: LD_VAR 0 1
15389: PPUSH
15390: LD_VAR 0 7
15394: PPUSH
15395: LD_VAR 0 8
15399: PPUSH
15400: CALL_OW 111
// exit ;
15404: POP
15405: POP
15406: GO 15412
// end ; end ;
15408: GO 15297
15410: POP
15411: POP
// end ;
15412: LD_VAR 0 3
15416: RET
// export function ScanBase ( side , base_area ) ; begin
15417: LD_INT 0
15419: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15420: LD_ADDR_VAR 0 3
15424: PUSH
15425: LD_VAR 0 2
15429: PPUSH
15430: LD_INT 81
15432: PUSH
15433: LD_VAR 0 1
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: PPUSH
15442: CALL_OW 70
15446: ST_TO_ADDR
// end ;
15447: LD_VAR 0 3
15451: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15452: LD_INT 0
15454: PPUSH
15455: PPUSH
15456: PPUSH
15457: PPUSH
15458: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15459: LD_VAR 0 1
15463: NOT
15464: PUSH
15465: LD_EXP 58
15469: PUSH
15470: LD_VAR 0 1
15474: ARRAY
15475: NOT
15476: OR
15477: PUSH
15478: LD_VAR 0 2
15482: NOT
15483: OR
15484: PUSH
15485: LD_VAR 0 3
15489: NOT
15490: OR
15491: IFFALSE 15495
// exit ;
15493: GO 15945
// side := mc_sides [ base ] ;
15495: LD_ADDR_VAR 0 6
15499: PUSH
15500: LD_EXP 84
15504: PUSH
15505: LD_VAR 0 1
15509: ARRAY
15510: ST_TO_ADDR
// if not side then
15511: LD_VAR 0 6
15515: NOT
15516: IFFALSE 15520
// exit ;
15518: GO 15945
// for i in solds do
15520: LD_ADDR_VAR 0 7
15524: PUSH
15525: LD_VAR 0 2
15529: PUSH
15530: FOR_IN
15531: IFFALSE 15592
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15533: LD_VAR 0 7
15537: PPUSH
15538: CALL_OW 310
15542: PPUSH
15543: CALL_OW 266
15547: PUSH
15548: LD_INT 32
15550: PUSH
15551: LD_INT 31
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: IN
15558: IFFALSE 15578
// solds := solds diff i else
15560: LD_ADDR_VAR 0 2
15564: PUSH
15565: LD_VAR 0 2
15569: PUSH
15570: LD_VAR 0 7
15574: DIFF
15575: ST_TO_ADDR
15576: GO 15590
// SetTag ( i , 18 ) ;
15578: LD_VAR 0 7
15582: PPUSH
15583: LD_INT 18
15585: PPUSH
15586: CALL_OW 109
15590: GO 15530
15592: POP
15593: POP
// if not solds then
15594: LD_VAR 0 2
15598: NOT
15599: IFFALSE 15603
// exit ;
15601: GO 15945
// repeat wait ( 0 0$1 ) ;
15603: LD_INT 35
15605: PPUSH
15606: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15610: LD_ADDR_VAR 0 5
15614: PUSH
15615: LD_VAR 0 6
15619: PPUSH
15620: LD_VAR 0 3
15624: PPUSH
15625: CALL 15417 0 2
15629: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15630: LD_VAR 0 5
15634: NOT
15635: PUSH
15636: LD_VAR 0 5
15640: PUSH
15641: LD_INT 3
15643: GREATER
15644: OR
15645: PUSH
15646: LD_EXP 80
15650: PUSH
15651: LD_VAR 0 1
15655: ARRAY
15656: OR
15657: IFFALSE 15698
// begin for i in solds do
15659: LD_ADDR_VAR 0 7
15663: PUSH
15664: LD_VAR 0 2
15668: PUSH
15669: FOR_IN
15670: IFFALSE 15694
// if HasTask ( i ) then
15672: LD_VAR 0 7
15676: PPUSH
15677: CALL_OW 314
15681: IFFALSE 15692
// ComStop ( i ) ;
15683: LD_VAR 0 7
15687: PPUSH
15688: CALL_OW 141
15692: GO 15669
15694: POP
15695: POP
// break ;
15696: GO 15933
// end ; for i in solds do
15698: LD_ADDR_VAR 0 7
15702: PUSH
15703: LD_VAR 0 2
15707: PUSH
15708: FOR_IN
15709: IFFALSE 15925
// begin if IsInUnit ( i ) then
15711: LD_VAR 0 7
15715: PPUSH
15716: CALL_OW 310
15720: IFFALSE 15731
// ComExitBuilding ( i ) ;
15722: LD_VAR 0 7
15726: PPUSH
15727: CALL_OW 122
// if GetLives ( i ) > 333 then
15731: LD_VAR 0 7
15735: PPUSH
15736: CALL_OW 256
15740: PUSH
15741: LD_INT 333
15743: GREATER
15744: IFFALSE 15772
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15746: LD_VAR 0 7
15750: PPUSH
15751: LD_VAR 0 5
15755: PPUSH
15756: LD_VAR 0 7
15760: PPUSH
15761: CALL_OW 74
15765: PPUSH
15766: CALL_OW 115
15770: GO 15923
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15772: LD_ADDR_VAR 0 8
15776: PUSH
15777: LD_EXP 58
15781: PUSH
15782: LD_VAR 0 1
15786: ARRAY
15787: PPUSH
15788: LD_INT 2
15790: PUSH
15791: LD_INT 30
15793: PUSH
15794: LD_INT 0
15796: PUSH
15797: EMPTY
15798: LIST
15799: LIST
15800: PUSH
15801: LD_INT 30
15803: PUSH
15804: LD_INT 1
15806: PUSH
15807: EMPTY
15808: LIST
15809: LIST
15810: PUSH
15811: LD_INT 30
15813: PUSH
15814: LD_INT 6
15816: PUSH
15817: EMPTY
15818: LIST
15819: LIST
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: LIST
15825: LIST
15826: PPUSH
15827: CALL_OW 72
15831: PPUSH
15832: LD_VAR 0 7
15836: PPUSH
15837: CALL_OW 74
15841: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15842: LD_VAR 0 7
15846: PPUSH
15847: LD_VAR 0 8
15851: PPUSH
15852: CALL_OW 250
15856: PPUSH
15857: LD_INT 3
15859: PPUSH
15860: LD_INT 5
15862: PPUSH
15863: CALL_OW 272
15867: PPUSH
15868: LD_VAR 0 8
15872: PPUSH
15873: CALL_OW 251
15877: PPUSH
15878: LD_INT 3
15880: PPUSH
15881: LD_INT 5
15883: PPUSH
15884: CALL_OW 273
15888: PPUSH
15889: CALL_OW 111
// SetTag ( i , 0 ) ;
15893: LD_VAR 0 7
15897: PPUSH
15898: LD_INT 0
15900: PPUSH
15901: CALL_OW 109
// solds := solds diff i ;
15905: LD_ADDR_VAR 0 2
15909: PUSH
15910: LD_VAR 0 2
15914: PUSH
15915: LD_VAR 0 7
15919: DIFF
15920: ST_TO_ADDR
// continue ;
15921: GO 15708
// end ; end ;
15923: GO 15708
15925: POP
15926: POP
// until solds ;
15927: LD_VAR 0 2
15931: IFFALSE 15603
// MC_Reset ( base , 18 ) ;
15933: LD_VAR 0 1
15937: PPUSH
15938: LD_INT 18
15940: PPUSH
15941: CALL 59444 0 2
// end ;
15945: LD_VAR 0 4
15949: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15950: LD_INT 0
15952: PPUSH
15953: PPUSH
15954: PPUSH
15955: PPUSH
15956: PPUSH
15957: PPUSH
15958: PPUSH
15959: PPUSH
15960: PPUSH
15961: PPUSH
15962: PPUSH
15963: PPUSH
15964: PPUSH
15965: PPUSH
15966: PPUSH
15967: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15968: LD_ADDR_VAR 0 12
15972: PUSH
15973: LD_EXP 58
15977: PUSH
15978: LD_VAR 0 1
15982: ARRAY
15983: PPUSH
15984: LD_INT 25
15986: PUSH
15987: LD_INT 3
15989: PUSH
15990: EMPTY
15991: LIST
15992: LIST
15993: PPUSH
15994: CALL_OW 72
15998: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15999: LD_ADDR_VAR 0 8
16003: PUSH
16004: LD_EXP 58
16008: PUSH
16009: LD_VAR 0 1
16013: ARRAY
16014: PPUSH
16015: LD_INT 2
16017: PUSH
16018: LD_INT 25
16020: PUSH
16021: LD_INT 1
16023: PUSH
16024: EMPTY
16025: LIST
16026: LIST
16027: PUSH
16028: LD_INT 25
16030: PUSH
16031: LD_INT 5
16033: PUSH
16034: EMPTY
16035: LIST
16036: LIST
16037: PUSH
16038: LD_INT 25
16040: PUSH
16041: LD_INT 8
16043: PUSH
16044: EMPTY
16045: LIST
16046: LIST
16047: PUSH
16048: LD_INT 25
16050: PUSH
16051: LD_INT 9
16053: PUSH
16054: EMPTY
16055: LIST
16056: LIST
16057: PUSH
16058: EMPTY
16059: LIST
16060: LIST
16061: LIST
16062: LIST
16063: LIST
16064: PPUSH
16065: CALL_OW 72
16069: ST_TO_ADDR
// if not defenders and not solds then
16070: LD_VAR 0 2
16074: NOT
16075: PUSH
16076: LD_VAR 0 8
16080: NOT
16081: AND
16082: IFFALSE 16086
// exit ;
16084: GO 17452
// depot_under_attack := false ;
16086: LD_ADDR_VAR 0 16
16090: PUSH
16091: LD_INT 0
16093: ST_TO_ADDR
// sold_defenders := [ ] ;
16094: LD_ADDR_VAR 0 17
16098: PUSH
16099: EMPTY
16100: ST_TO_ADDR
// if mechs then
16101: LD_VAR 0 12
16105: IFFALSE 16234
// for i in defenders do
16107: LD_ADDR_VAR 0 5
16111: PUSH
16112: LD_VAR 0 2
16116: PUSH
16117: FOR_IN
16118: IFFALSE 16232
// begin SetTag ( i , 20 ) ;
16120: LD_VAR 0 5
16124: PPUSH
16125: LD_INT 20
16127: PPUSH
16128: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16132: LD_VAR 0 5
16136: PPUSH
16137: CALL_OW 263
16141: PUSH
16142: LD_INT 1
16144: EQUAL
16145: PUSH
16146: LD_VAR 0 5
16150: PPUSH
16151: CALL_OW 311
16155: NOT
16156: AND
16157: PUSH
16158: LD_VAR 0 12
16162: AND
16163: IFFALSE 16230
// begin un := mechs [ 1 ] ;
16165: LD_ADDR_VAR 0 10
16169: PUSH
16170: LD_VAR 0 12
16174: PUSH
16175: LD_INT 1
16177: ARRAY
16178: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16179: LD_VAR 0 10
16183: PPUSH
16184: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16188: LD_VAR 0 10
16192: PPUSH
16193: LD_VAR 0 5
16197: PPUSH
16198: CALL_OW 180
// SetTag ( un , 19 ) ;
16202: LD_VAR 0 10
16206: PPUSH
16207: LD_INT 19
16209: PPUSH
16210: CALL_OW 109
// mechs := mechs diff un ;
16214: LD_ADDR_VAR 0 12
16218: PUSH
16219: LD_VAR 0 12
16223: PUSH
16224: LD_VAR 0 10
16228: DIFF
16229: ST_TO_ADDR
// end ; end ;
16230: GO 16117
16232: POP
16233: POP
// if solds then
16234: LD_VAR 0 8
16238: IFFALSE 16297
// for i in solds do
16240: LD_ADDR_VAR 0 5
16244: PUSH
16245: LD_VAR 0 8
16249: PUSH
16250: FOR_IN
16251: IFFALSE 16295
// if not GetTag ( i ) then
16253: LD_VAR 0 5
16257: PPUSH
16258: CALL_OW 110
16262: NOT
16263: IFFALSE 16293
// begin defenders := defenders union i ;
16265: LD_ADDR_VAR 0 2
16269: PUSH
16270: LD_VAR 0 2
16274: PUSH
16275: LD_VAR 0 5
16279: UNION
16280: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16281: LD_VAR 0 5
16285: PPUSH
16286: LD_INT 18
16288: PPUSH
16289: CALL_OW 109
// end ;
16293: GO 16250
16295: POP
16296: POP
// repeat wait ( 0 0$1 ) ;
16297: LD_INT 35
16299: PPUSH
16300: CALL_OW 67
// enemy := mc_scan [ base ] ;
16304: LD_ADDR_VAR 0 3
16308: PUSH
16309: LD_EXP 81
16313: PUSH
16314: LD_VAR 0 1
16318: ARRAY
16319: ST_TO_ADDR
// for i in defenders do
16320: LD_ADDR_VAR 0 5
16324: PUSH
16325: LD_VAR 0 2
16329: PUSH
16330: FOR_IN
16331: IFFALSE 17016
// begin e := NearestUnitToUnit ( enemy , i ) ;
16333: LD_ADDR_VAR 0 13
16337: PUSH
16338: LD_VAR 0 3
16342: PPUSH
16343: LD_VAR 0 5
16347: PPUSH
16348: CALL_OW 74
16352: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16353: LD_ADDR_VAR 0 16
16357: PUSH
16358: LD_EXP 58
16362: PUSH
16363: LD_VAR 0 1
16367: ARRAY
16368: PPUSH
16369: LD_INT 2
16371: PUSH
16372: LD_INT 30
16374: PUSH
16375: LD_INT 0
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 30
16384: PUSH
16385: LD_INT 1
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 72
16401: NOT
16402: PUSH
16403: LD_EXP 58
16407: PUSH
16408: LD_VAR 0 1
16412: ARRAY
16413: PPUSH
16414: LD_INT 2
16416: PUSH
16417: LD_INT 30
16419: PUSH
16420: LD_INT 0
16422: PUSH
16423: EMPTY
16424: LIST
16425: LIST
16426: PUSH
16427: LD_INT 30
16429: PUSH
16430: LD_INT 1
16432: PUSH
16433: EMPTY
16434: LIST
16435: LIST
16436: PUSH
16437: EMPTY
16438: LIST
16439: LIST
16440: LIST
16441: PPUSH
16442: CALL_OW 72
16446: PPUSH
16447: CALL_OW 256
16451: PUSH
16452: LD_INT 600
16454: LESS
16455: OR
16456: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16457: LD_VAR 0 5
16461: PPUSH
16462: CALL_OW 247
16466: PUSH
16467: LD_INT 2
16469: DOUBLE
16470: EQUAL
16471: IFTRUE 16475
16473: GO 16722
16475: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16476: LD_VAR 0 5
16480: PPUSH
16481: CALL_OW 256
16485: PUSH
16486: LD_INT 650
16488: GREATER
16489: PUSH
16490: LD_VAR 0 5
16494: PPUSH
16495: LD_VAR 0 13
16499: PPUSH
16500: CALL_OW 296
16504: PUSH
16505: LD_INT 40
16507: LESS
16508: AND
16509: IFFALSE 16527
// ComAttackUnit ( i , e ) else
16511: LD_VAR 0 5
16515: PPUSH
16516: LD_VAR 0 13
16520: PPUSH
16521: CALL_OW 115
16525: GO 16605
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16527: LD_VAR 0 5
16531: PPUSH
16532: LD_VAR 0 13
16536: PPUSH
16537: CALL_OW 296
16541: PUSH
16542: LD_INT 30
16544: GREATEREQUAL
16545: PUSH
16546: LD_VAR 0 5
16550: PPUSH
16551: CALL_OW 256
16555: PUSH
16556: LD_INT 650
16558: LESSEQUAL
16559: OR
16560: PUSH
16561: LD_VAR 0 5
16565: PPUSH
16566: LD_EXP 82
16570: PUSH
16571: LD_VAR 0 1
16575: ARRAY
16576: PPUSH
16577: CALL_OW 308
16581: NOT
16582: AND
16583: IFFALSE 16605
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16585: LD_VAR 0 5
16589: PPUSH
16590: LD_EXP 82
16594: PUSH
16595: LD_VAR 0 1
16599: ARRAY
16600: PPUSH
16601: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16605: LD_VAR 0 5
16609: PPUSH
16610: CALL_OW 256
16614: PUSH
16615: LD_INT 998
16617: LESS
16618: PUSH
16619: LD_VAR 0 5
16623: PPUSH
16624: CALL_OW 263
16628: PUSH
16629: LD_INT 1
16631: EQUAL
16632: AND
16633: PUSH
16634: LD_VAR 0 5
16638: PPUSH
16639: CALL_OW 311
16643: AND
16644: PUSH
16645: LD_VAR 0 5
16649: PPUSH
16650: LD_EXP 82
16654: PUSH
16655: LD_VAR 0 1
16659: ARRAY
16660: PPUSH
16661: CALL_OW 308
16665: AND
16666: IFFALSE 16720
// begin mech := IsDrivenBy ( i ) ;
16668: LD_ADDR_VAR 0 9
16672: PUSH
16673: LD_VAR 0 5
16677: PPUSH
16678: CALL_OW 311
16682: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16683: LD_VAR 0 9
16687: PPUSH
16688: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16692: LD_VAR 0 9
16696: PPUSH
16697: LD_VAR 0 5
16701: PPUSH
16702: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16706: LD_VAR 0 9
16710: PPUSH
16711: LD_VAR 0 5
16715: PPUSH
16716: CALL_OW 180
// end ; end ; unit_human :
16720: GO 16987
16722: LD_INT 1
16724: DOUBLE
16725: EQUAL
16726: IFTRUE 16730
16728: GO 16986
16730: POP
// begin b := IsInUnit ( i ) ;
16731: LD_ADDR_VAR 0 18
16735: PUSH
16736: LD_VAR 0 5
16740: PPUSH
16741: CALL_OW 310
16745: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16746: LD_ADDR_VAR 0 19
16750: PUSH
16751: LD_VAR 0 18
16755: NOT
16756: PUSH
16757: LD_VAR 0 18
16761: PPUSH
16762: CALL_OW 266
16766: PUSH
16767: LD_INT 32
16769: PUSH
16770: LD_INT 31
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: IN
16777: OR
16778: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16779: LD_VAR 0 16
16783: PUSH
16784: LD_VAR 0 2
16788: PPUSH
16789: LD_INT 21
16791: PUSH
16792: LD_INT 2
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PPUSH
16799: CALL_OW 72
16803: PUSH
16804: LD_INT 1
16806: LESSEQUAL
16807: OR
16808: PUSH
16809: LD_VAR 0 19
16813: AND
16814: PUSH
16815: LD_VAR 0 5
16819: PUSH
16820: LD_VAR 0 17
16824: IN
16825: NOT
16826: AND
16827: IFFALSE 16920
// begin if b then
16829: LD_VAR 0 18
16833: IFFALSE 16882
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16835: LD_VAR 0 18
16839: PPUSH
16840: LD_VAR 0 3
16844: PPUSH
16845: LD_VAR 0 18
16849: PPUSH
16850: CALL_OW 74
16854: PPUSH
16855: CALL_OW 296
16859: PUSH
16860: LD_INT 10
16862: LESS
16863: PUSH
16864: LD_VAR 0 18
16868: PPUSH
16869: CALL_OW 461
16873: PUSH
16874: LD_INT 7
16876: NONEQUAL
16877: AND
16878: IFFALSE 16882
// continue ;
16880: GO 16330
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16882: LD_ADDR_VAR 0 17
16886: PUSH
16887: LD_VAR 0 17
16891: PPUSH
16892: LD_VAR 0 17
16896: PUSH
16897: LD_INT 1
16899: PLUS
16900: PPUSH
16901: LD_VAR 0 5
16905: PPUSH
16906: CALL_OW 1
16910: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16911: LD_VAR 0 5
16915: PPUSH
16916: CALL_OW 122
// end ; if sold_defenders then
16920: LD_VAR 0 17
16924: IFFALSE 16984
// if i in sold_defenders then
16926: LD_VAR 0 5
16930: PUSH
16931: LD_VAR 0 17
16935: IN
16936: IFFALSE 16984
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16938: LD_VAR 0 5
16942: PPUSH
16943: CALL_OW 314
16947: NOT
16948: PUSH
16949: LD_VAR 0 5
16953: PPUSH
16954: LD_VAR 0 13
16958: PPUSH
16959: CALL_OW 296
16963: PUSH
16964: LD_INT 30
16966: LESS
16967: AND
16968: IFFALSE 16984
// ComAttackUnit ( i , e ) ;
16970: LD_VAR 0 5
16974: PPUSH
16975: LD_VAR 0 13
16979: PPUSH
16980: CALL_OW 115
// end ; end ; end ;
16984: GO 16987
16986: POP
// if IsDead ( i ) then
16987: LD_VAR 0 5
16991: PPUSH
16992: CALL_OW 301
16996: IFFALSE 17014
// defenders := defenders diff i ;
16998: LD_ADDR_VAR 0 2
17002: PUSH
17003: LD_VAR 0 2
17007: PUSH
17008: LD_VAR 0 5
17012: DIFF
17013: ST_TO_ADDR
// end ;
17014: GO 16330
17016: POP
17017: POP
// until not enemy or not defenders ;
17018: LD_VAR 0 3
17022: NOT
17023: PUSH
17024: LD_VAR 0 2
17028: NOT
17029: OR
17030: IFFALSE 16297
// MC_Reset ( base , 18 ) ;
17032: LD_VAR 0 1
17036: PPUSH
17037: LD_INT 18
17039: PPUSH
17040: CALL 59444 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17044: LD_ADDR_VAR 0 2
17048: PUSH
17049: LD_VAR 0 2
17053: PUSH
17054: LD_VAR 0 2
17058: PPUSH
17059: LD_INT 2
17061: PUSH
17062: LD_INT 25
17064: PUSH
17065: LD_INT 1
17067: PUSH
17068: EMPTY
17069: LIST
17070: LIST
17071: PUSH
17072: LD_INT 25
17074: PUSH
17075: LD_INT 5
17077: PUSH
17078: EMPTY
17079: LIST
17080: LIST
17081: PUSH
17082: LD_INT 25
17084: PUSH
17085: LD_INT 8
17087: PUSH
17088: EMPTY
17089: LIST
17090: LIST
17091: PUSH
17092: LD_INT 25
17094: PUSH
17095: LD_INT 9
17097: PUSH
17098: EMPTY
17099: LIST
17100: LIST
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: LIST
17106: LIST
17107: LIST
17108: PPUSH
17109: CALL_OW 72
17113: DIFF
17114: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17115: LD_VAR 0 3
17119: NOT
17120: PUSH
17121: LD_VAR 0 2
17125: PPUSH
17126: LD_INT 21
17128: PUSH
17129: LD_INT 2
17131: PUSH
17132: EMPTY
17133: LIST
17134: LIST
17135: PPUSH
17136: CALL_OW 72
17140: AND
17141: IFFALSE 17403
// begin tmp := FilterByTag ( defenders , 19 ) ;
17143: LD_ADDR_VAR 0 11
17147: PUSH
17148: LD_VAR 0 2
17152: PPUSH
17153: LD_INT 19
17155: PPUSH
17156: CALL 53750 0 2
17160: ST_TO_ADDR
// if tmp then
17161: LD_VAR 0 11
17165: IFFALSE 17235
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17167: LD_ADDR_VAR 0 11
17171: PUSH
17172: LD_VAR 0 11
17176: PPUSH
17177: LD_INT 25
17179: PUSH
17180: LD_INT 3
17182: PUSH
17183: EMPTY
17184: LIST
17185: LIST
17186: PPUSH
17187: CALL_OW 72
17191: ST_TO_ADDR
// if tmp then
17192: LD_VAR 0 11
17196: IFFALSE 17235
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17198: LD_ADDR_EXP 70
17202: PUSH
17203: LD_EXP 70
17207: PPUSH
17208: LD_VAR 0 1
17212: PPUSH
17213: LD_EXP 70
17217: PUSH
17218: LD_VAR 0 1
17222: ARRAY
17223: PUSH
17224: LD_VAR 0 11
17228: UNION
17229: PPUSH
17230: CALL_OW 1
17234: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17235: LD_VAR 0 1
17239: PPUSH
17240: LD_INT 19
17242: PPUSH
17243: CALL 59444 0 2
// repeat wait ( 0 0$1 ) ;
17247: LD_INT 35
17249: PPUSH
17250: CALL_OW 67
// for i in defenders do
17254: LD_ADDR_VAR 0 5
17258: PUSH
17259: LD_VAR 0 2
17263: PUSH
17264: FOR_IN
17265: IFFALSE 17354
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17267: LD_VAR 0 5
17271: PPUSH
17272: LD_EXP 82
17276: PUSH
17277: LD_VAR 0 1
17281: ARRAY
17282: PPUSH
17283: CALL_OW 308
17287: NOT
17288: IFFALSE 17312
// ComMoveToArea ( i , mc_parking [ base ] ) else
17290: LD_VAR 0 5
17294: PPUSH
17295: LD_EXP 82
17299: PUSH
17300: LD_VAR 0 1
17304: ARRAY
17305: PPUSH
17306: CALL_OW 113
17310: GO 17352
// if GetControl ( i ) = control_manual then
17312: LD_VAR 0 5
17316: PPUSH
17317: CALL_OW 263
17321: PUSH
17322: LD_INT 1
17324: EQUAL
17325: IFFALSE 17352
// if IsDrivenBy ( i ) then
17327: LD_VAR 0 5
17331: PPUSH
17332: CALL_OW 311
17336: IFFALSE 17352
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17338: LD_VAR 0 5
17342: PPUSH
17343: CALL_OW 311
17347: PPUSH
17348: CALL_OW 121
// end ;
17352: GO 17264
17354: POP
17355: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17356: LD_VAR 0 2
17360: PPUSH
17361: LD_INT 95
17363: PUSH
17364: LD_EXP 82
17368: PUSH
17369: LD_VAR 0 1
17373: ARRAY
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 72
17383: PUSH
17384: LD_VAR 0 2
17388: EQUAL
17389: PUSH
17390: LD_EXP 81
17394: PUSH
17395: LD_VAR 0 1
17399: ARRAY
17400: OR
17401: IFFALSE 17247
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17403: LD_ADDR_EXP 80
17407: PUSH
17408: LD_EXP 80
17412: PPUSH
17413: LD_VAR 0 1
17417: PPUSH
17418: LD_EXP 80
17422: PUSH
17423: LD_VAR 0 1
17427: ARRAY
17428: PUSH
17429: LD_VAR 0 2
17433: UNION
17434: PPUSH
17435: CALL_OW 1
17439: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17440: LD_VAR 0 1
17444: PPUSH
17445: LD_INT 20
17447: PPUSH
17448: CALL 59444 0 2
// end ;
17452: LD_VAR 0 4
17456: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17457: LD_INT 0
17459: PPUSH
17460: PPUSH
17461: PPUSH
17462: PPUSH
// result := false ;
17463: LD_ADDR_VAR 0 2
17467: PUSH
17468: LD_INT 0
17470: ST_TO_ADDR
// side := GetSide ( unit ) ;
17471: LD_ADDR_VAR 0 3
17475: PUSH
17476: LD_VAR 0 1
17480: PPUSH
17481: CALL_OW 255
17485: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17486: LD_ADDR_VAR 0 4
17490: PUSH
17491: LD_VAR 0 1
17495: PPUSH
17496: CALL_OW 248
17500: ST_TO_ADDR
// case nat of 1 :
17501: LD_VAR 0 4
17505: PUSH
17506: LD_INT 1
17508: DOUBLE
17509: EQUAL
17510: IFTRUE 17514
17512: GO 17525
17514: POP
// tech := tech_lassight ; 2 :
17515: LD_ADDR_VAR 0 5
17519: PUSH
17520: LD_INT 12
17522: ST_TO_ADDR
17523: GO 17564
17525: LD_INT 2
17527: DOUBLE
17528: EQUAL
17529: IFTRUE 17533
17531: GO 17544
17533: POP
// tech := tech_mortar ; 3 :
17534: LD_ADDR_VAR 0 5
17538: PUSH
17539: LD_INT 41
17541: ST_TO_ADDR
17542: GO 17564
17544: LD_INT 3
17546: DOUBLE
17547: EQUAL
17548: IFTRUE 17552
17550: GO 17563
17552: POP
// tech := tech_bazooka ; end ;
17553: LD_ADDR_VAR 0 5
17557: PUSH
17558: LD_INT 44
17560: ST_TO_ADDR
17561: GO 17564
17563: POP
// if Researched ( side , tech ) then
17564: LD_VAR 0 3
17568: PPUSH
17569: LD_VAR 0 5
17573: PPUSH
17574: CALL_OW 325
17578: IFFALSE 17605
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17580: LD_ADDR_VAR 0 2
17584: PUSH
17585: LD_INT 5
17587: PUSH
17588: LD_INT 8
17590: PUSH
17591: LD_INT 9
17593: PUSH
17594: EMPTY
17595: LIST
17596: LIST
17597: LIST
17598: PUSH
17599: LD_VAR 0 4
17603: ARRAY
17604: ST_TO_ADDR
// end ;
17605: LD_VAR 0 2
17609: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17610: LD_INT 0
17612: PPUSH
17613: PPUSH
17614: PPUSH
// if not mines then
17615: LD_VAR 0 2
17619: NOT
17620: IFFALSE 17624
// exit ;
17622: GO 17768
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17624: LD_ADDR_VAR 0 5
17628: PUSH
17629: LD_INT 81
17631: PUSH
17632: LD_VAR 0 1
17636: PUSH
17637: EMPTY
17638: LIST
17639: LIST
17640: PUSH
17641: LD_INT 3
17643: PUSH
17644: LD_INT 21
17646: PUSH
17647: LD_INT 3
17649: PUSH
17650: EMPTY
17651: LIST
17652: LIST
17653: PUSH
17654: EMPTY
17655: LIST
17656: LIST
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PPUSH
17662: CALL_OW 69
17666: ST_TO_ADDR
// for i in mines do
17667: LD_ADDR_VAR 0 4
17671: PUSH
17672: LD_VAR 0 2
17676: PUSH
17677: FOR_IN
17678: IFFALSE 17766
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17680: LD_VAR 0 4
17684: PUSH
17685: LD_INT 1
17687: ARRAY
17688: PPUSH
17689: LD_VAR 0 4
17693: PUSH
17694: LD_INT 2
17696: ARRAY
17697: PPUSH
17698: CALL_OW 458
17702: NOT
17703: IFFALSE 17707
// continue ;
17705: GO 17677
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17707: LD_VAR 0 4
17711: PUSH
17712: LD_INT 1
17714: ARRAY
17715: PPUSH
17716: LD_VAR 0 4
17720: PUSH
17721: LD_INT 2
17723: ARRAY
17724: PPUSH
17725: CALL_OW 428
17729: PUSH
17730: LD_VAR 0 5
17734: IN
17735: IFFALSE 17764
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17737: LD_VAR 0 4
17741: PUSH
17742: LD_INT 1
17744: ARRAY
17745: PPUSH
17746: LD_VAR 0 4
17750: PUSH
17751: LD_INT 2
17753: ARRAY
17754: PPUSH
17755: LD_VAR 0 1
17759: PPUSH
17760: CALL_OW 456
// end ;
17764: GO 17677
17766: POP
17767: POP
// end ;
17768: LD_VAR 0 3
17772: RET
// export function Count ( array ) ; var i ; begin
17773: LD_INT 0
17775: PPUSH
17776: PPUSH
// result := 0 ;
17777: LD_ADDR_VAR 0 2
17781: PUSH
17782: LD_INT 0
17784: ST_TO_ADDR
// for i in array do
17785: LD_ADDR_VAR 0 3
17789: PUSH
17790: LD_VAR 0 1
17794: PUSH
17795: FOR_IN
17796: IFFALSE 17820
// if i then
17798: LD_VAR 0 3
17802: IFFALSE 17818
// result := result + 1 ;
17804: LD_ADDR_VAR 0 2
17808: PUSH
17809: LD_VAR 0 2
17813: PUSH
17814: LD_INT 1
17816: PLUS
17817: ST_TO_ADDR
17818: GO 17795
17820: POP
17821: POP
// end ;
17822: LD_VAR 0 2
17826: RET
// export function IsEmpty ( building ) ; begin
17827: LD_INT 0
17829: PPUSH
// if not building then
17830: LD_VAR 0 1
17834: NOT
17835: IFFALSE 17839
// exit ;
17837: GO 17882
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17839: LD_ADDR_VAR 0 2
17843: PUSH
17844: LD_VAR 0 1
17848: PUSH
17849: LD_INT 22
17851: PUSH
17852: LD_VAR 0 1
17856: PPUSH
17857: CALL_OW 255
17861: PUSH
17862: EMPTY
17863: LIST
17864: LIST
17865: PUSH
17866: LD_INT 58
17868: PUSH
17869: EMPTY
17870: LIST
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: PPUSH
17876: CALL_OW 69
17880: IN
17881: ST_TO_ADDR
// end ;
17882: LD_VAR 0 2
17886: RET
// export function IsNotFull ( building ) ; begin
17887: LD_INT 0
17889: PPUSH
// if not building then
17890: LD_VAR 0 1
17894: NOT
17895: IFFALSE 17899
// exit ;
17897: GO 17918
// result := UnitsInside ( building ) < 6 ;
17899: LD_ADDR_VAR 0 2
17903: PUSH
17904: LD_VAR 0 1
17908: PPUSH
17909: CALL_OW 313
17913: PUSH
17914: LD_INT 6
17916: LESS
17917: ST_TO_ADDR
// end ;
17918: LD_VAR 0 2
17922: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17923: LD_INT 0
17925: PPUSH
17926: PPUSH
17927: PPUSH
17928: PPUSH
// tmp := [ ] ;
17929: LD_ADDR_VAR 0 3
17933: PUSH
17934: EMPTY
17935: ST_TO_ADDR
// list := [ ] ;
17936: LD_ADDR_VAR 0 5
17940: PUSH
17941: EMPTY
17942: ST_TO_ADDR
// for i = 16 to 25 do
17943: LD_ADDR_VAR 0 4
17947: PUSH
17948: DOUBLE
17949: LD_INT 16
17951: DEC
17952: ST_TO_ADDR
17953: LD_INT 25
17955: PUSH
17956: FOR_TO
17957: IFFALSE 18030
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17959: LD_ADDR_VAR 0 3
17963: PUSH
17964: LD_VAR 0 3
17968: PUSH
17969: LD_INT 22
17971: PUSH
17972: LD_VAR 0 1
17976: PPUSH
17977: CALL_OW 255
17981: PUSH
17982: EMPTY
17983: LIST
17984: LIST
17985: PUSH
17986: LD_INT 91
17988: PUSH
17989: LD_VAR 0 1
17993: PUSH
17994: LD_INT 6
17996: PUSH
17997: EMPTY
17998: LIST
17999: LIST
18000: LIST
18001: PUSH
18002: LD_INT 30
18004: PUSH
18005: LD_VAR 0 4
18009: PUSH
18010: EMPTY
18011: LIST
18012: LIST
18013: PUSH
18014: EMPTY
18015: LIST
18016: LIST
18017: LIST
18018: PUSH
18019: EMPTY
18020: LIST
18021: PPUSH
18022: CALL_OW 69
18026: ADD
18027: ST_TO_ADDR
18028: GO 17956
18030: POP
18031: POP
// for i = 1 to tmp do
18032: LD_ADDR_VAR 0 4
18036: PUSH
18037: DOUBLE
18038: LD_INT 1
18040: DEC
18041: ST_TO_ADDR
18042: LD_VAR 0 3
18046: PUSH
18047: FOR_TO
18048: IFFALSE 18136
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18050: LD_ADDR_VAR 0 5
18054: PUSH
18055: LD_VAR 0 5
18059: PUSH
18060: LD_VAR 0 3
18064: PUSH
18065: LD_VAR 0 4
18069: ARRAY
18070: PPUSH
18071: CALL_OW 266
18075: PUSH
18076: LD_VAR 0 3
18080: PUSH
18081: LD_VAR 0 4
18085: ARRAY
18086: PPUSH
18087: CALL_OW 250
18091: PUSH
18092: LD_VAR 0 3
18096: PUSH
18097: LD_VAR 0 4
18101: ARRAY
18102: PPUSH
18103: CALL_OW 251
18107: PUSH
18108: LD_VAR 0 3
18112: PUSH
18113: LD_VAR 0 4
18117: ARRAY
18118: PPUSH
18119: CALL_OW 254
18123: PUSH
18124: EMPTY
18125: LIST
18126: LIST
18127: LIST
18128: LIST
18129: PUSH
18130: EMPTY
18131: LIST
18132: ADD
18133: ST_TO_ADDR
18134: GO 18047
18136: POP
18137: POP
// result := list ;
18138: LD_ADDR_VAR 0 2
18142: PUSH
18143: LD_VAR 0 5
18147: ST_TO_ADDR
// end ;
18148: LD_VAR 0 2
18152: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18153: LD_INT 0
18155: PPUSH
18156: PPUSH
18157: PPUSH
18158: PPUSH
18159: PPUSH
18160: PPUSH
18161: PPUSH
// if not factory then
18162: LD_VAR 0 1
18166: NOT
18167: IFFALSE 18171
// exit ;
18169: GO 18696
// if control = control_apeman then
18171: LD_VAR 0 4
18175: PUSH
18176: LD_INT 5
18178: EQUAL
18179: IFFALSE 18288
// begin tmp := UnitsInside ( factory ) ;
18181: LD_ADDR_VAR 0 8
18185: PUSH
18186: LD_VAR 0 1
18190: PPUSH
18191: CALL_OW 313
18195: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18196: LD_VAR 0 8
18200: PPUSH
18201: LD_INT 25
18203: PUSH
18204: LD_INT 12
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 72
18215: NOT
18216: IFFALSE 18226
// control := control_manual ;
18218: LD_ADDR_VAR 0 4
18222: PUSH
18223: LD_INT 1
18225: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18226: LD_ADDR_VAR 0 8
18230: PUSH
18231: LD_VAR 0 1
18235: PPUSH
18236: CALL 17923 0 1
18240: ST_TO_ADDR
// if tmp then
18241: LD_VAR 0 8
18245: IFFALSE 18288
// begin for i in tmp do
18247: LD_ADDR_VAR 0 7
18251: PUSH
18252: LD_VAR 0 8
18256: PUSH
18257: FOR_IN
18258: IFFALSE 18286
// if i [ 1 ] = b_ext_radar then
18260: LD_VAR 0 7
18264: PUSH
18265: LD_INT 1
18267: ARRAY
18268: PUSH
18269: LD_INT 20
18271: EQUAL
18272: IFFALSE 18284
// begin control := control_remote ;
18274: LD_ADDR_VAR 0 4
18278: PUSH
18279: LD_INT 2
18281: ST_TO_ADDR
// break ;
18282: GO 18286
// end ;
18284: GO 18257
18286: POP
18287: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18288: LD_VAR 0 1
18292: PPUSH
18293: LD_VAR 0 2
18297: PPUSH
18298: LD_VAR 0 3
18302: PPUSH
18303: LD_VAR 0 4
18307: PPUSH
18308: LD_VAR 0 5
18312: PPUSH
18313: CALL_OW 448
18317: IFFALSE 18352
// begin result := [ chassis , engine , control , weapon ] ;
18319: LD_ADDR_VAR 0 6
18323: PUSH
18324: LD_VAR 0 2
18328: PUSH
18329: LD_VAR 0 3
18333: PUSH
18334: LD_VAR 0 4
18338: PUSH
18339: LD_VAR 0 5
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: ST_TO_ADDR
// exit ;
18350: GO 18696
// end ; _chassis := AvailableChassisList ( factory ) ;
18352: LD_ADDR_VAR 0 9
18356: PUSH
18357: LD_VAR 0 1
18361: PPUSH
18362: CALL_OW 475
18366: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18367: LD_ADDR_VAR 0 11
18371: PUSH
18372: LD_VAR 0 1
18376: PPUSH
18377: CALL_OW 476
18381: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18382: LD_ADDR_VAR 0 12
18386: PUSH
18387: LD_VAR 0 1
18391: PPUSH
18392: CALL_OW 477
18396: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18397: LD_ADDR_VAR 0 10
18401: PUSH
18402: LD_VAR 0 1
18406: PPUSH
18407: CALL_OW 478
18411: ST_TO_ADDR
// if not chassis in _chassis then
18412: LD_VAR 0 2
18416: PUSH
18417: LD_VAR 0 9
18421: IN
18422: NOT
18423: IFFALSE 18449
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18425: LD_ADDR_VAR 0 2
18429: PUSH
18430: LD_VAR 0 9
18434: PUSH
18435: LD_INT 1
18437: PPUSH
18438: LD_VAR 0 9
18442: PPUSH
18443: CALL_OW 12
18447: ARRAY
18448: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18449: LD_VAR 0 2
18453: PPUSH
18454: LD_VAR 0 3
18458: PPUSH
18459: CALL 18701 0 2
18463: NOT
18464: IFFALSE 18523
// repeat engine := _engine [ 1 ] ;
18466: LD_ADDR_VAR 0 3
18470: PUSH
18471: LD_VAR 0 11
18475: PUSH
18476: LD_INT 1
18478: ARRAY
18479: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18480: LD_ADDR_VAR 0 11
18484: PUSH
18485: LD_VAR 0 11
18489: PPUSH
18490: LD_INT 1
18492: PPUSH
18493: CALL_OW 3
18497: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18498: LD_VAR 0 2
18502: PPUSH
18503: LD_VAR 0 3
18507: PPUSH
18508: CALL 18701 0 2
18512: PUSH
18513: LD_VAR 0 11
18517: PUSH
18518: EMPTY
18519: EQUAL
18520: OR
18521: IFFALSE 18466
// if not control in _control then
18523: LD_VAR 0 4
18527: PUSH
18528: LD_VAR 0 12
18532: IN
18533: NOT
18534: IFFALSE 18560
// control := _control [ rand ( 1 , _control ) ] ;
18536: LD_ADDR_VAR 0 4
18540: PUSH
18541: LD_VAR 0 12
18545: PUSH
18546: LD_INT 1
18548: PPUSH
18549: LD_VAR 0 12
18553: PPUSH
18554: CALL_OW 12
18558: ARRAY
18559: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18560: LD_VAR 0 2
18564: PPUSH
18565: LD_VAR 0 5
18569: PPUSH
18570: CALL 18921 0 2
18574: NOT
18575: IFFALSE 18634
// repeat weapon := _weapon [ 1 ] ;
18577: LD_ADDR_VAR 0 5
18581: PUSH
18582: LD_VAR 0 10
18586: PUSH
18587: LD_INT 1
18589: ARRAY
18590: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18591: LD_ADDR_VAR 0 10
18595: PUSH
18596: LD_VAR 0 10
18600: PPUSH
18601: LD_INT 1
18603: PPUSH
18604: CALL_OW 3
18608: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18609: LD_VAR 0 2
18613: PPUSH
18614: LD_VAR 0 5
18618: PPUSH
18619: CALL 18921 0 2
18623: PUSH
18624: LD_VAR 0 10
18628: PUSH
18629: EMPTY
18630: EQUAL
18631: OR
18632: IFFALSE 18577
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18634: LD_VAR 0 1
18638: PPUSH
18639: LD_VAR 0 2
18643: PPUSH
18644: LD_VAR 0 3
18648: PPUSH
18649: LD_VAR 0 4
18653: PPUSH
18654: LD_VAR 0 5
18658: PPUSH
18659: CALL_OW 448
18663: IFFALSE 18696
// result := [ chassis , engine , control , weapon ] ;
18665: LD_ADDR_VAR 0 6
18669: PUSH
18670: LD_VAR 0 2
18674: PUSH
18675: LD_VAR 0 3
18679: PUSH
18680: LD_VAR 0 4
18684: PUSH
18685: LD_VAR 0 5
18689: PUSH
18690: EMPTY
18691: LIST
18692: LIST
18693: LIST
18694: LIST
18695: ST_TO_ADDR
// end ;
18696: LD_VAR 0 6
18700: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18701: LD_INT 0
18703: PPUSH
// if not chassis or not engine then
18704: LD_VAR 0 1
18708: NOT
18709: PUSH
18710: LD_VAR 0 2
18714: NOT
18715: OR
18716: IFFALSE 18720
// exit ;
18718: GO 18916
// case engine of engine_solar :
18720: LD_VAR 0 2
18724: PUSH
18725: LD_INT 2
18727: DOUBLE
18728: EQUAL
18729: IFTRUE 18733
18731: GO 18771
18733: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18734: LD_ADDR_VAR 0 3
18738: PUSH
18739: LD_INT 11
18741: PUSH
18742: LD_INT 12
18744: PUSH
18745: LD_INT 13
18747: PUSH
18748: LD_INT 14
18750: PUSH
18751: LD_INT 1
18753: PUSH
18754: LD_INT 2
18756: PUSH
18757: LD_INT 3
18759: PUSH
18760: EMPTY
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: ST_TO_ADDR
18769: GO 18900
18771: LD_INT 1
18773: DOUBLE
18774: EQUAL
18775: IFTRUE 18779
18777: GO 18841
18779: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18780: LD_ADDR_VAR 0 3
18784: PUSH
18785: LD_INT 11
18787: PUSH
18788: LD_INT 12
18790: PUSH
18791: LD_INT 13
18793: PUSH
18794: LD_INT 14
18796: PUSH
18797: LD_INT 1
18799: PUSH
18800: LD_INT 2
18802: PUSH
18803: LD_INT 3
18805: PUSH
18806: LD_INT 4
18808: PUSH
18809: LD_INT 5
18811: PUSH
18812: LD_INT 21
18814: PUSH
18815: LD_INT 23
18817: PUSH
18818: LD_INT 22
18820: PUSH
18821: LD_INT 24
18823: PUSH
18824: EMPTY
18825: LIST
18826: LIST
18827: LIST
18828: LIST
18829: LIST
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: LIST
18838: ST_TO_ADDR
18839: GO 18900
18841: LD_INT 3
18843: DOUBLE
18844: EQUAL
18845: IFTRUE 18849
18847: GO 18899
18849: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18850: LD_ADDR_VAR 0 3
18854: PUSH
18855: LD_INT 13
18857: PUSH
18858: LD_INT 14
18860: PUSH
18861: LD_INT 2
18863: PUSH
18864: LD_INT 3
18866: PUSH
18867: LD_INT 4
18869: PUSH
18870: LD_INT 5
18872: PUSH
18873: LD_INT 21
18875: PUSH
18876: LD_INT 22
18878: PUSH
18879: LD_INT 23
18881: PUSH
18882: LD_INT 24
18884: PUSH
18885: EMPTY
18886: LIST
18887: LIST
18888: LIST
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: LIST
18895: LIST
18896: ST_TO_ADDR
18897: GO 18900
18899: POP
// result := ( chassis in result ) ;
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_VAR 0 1
18909: PUSH
18910: LD_VAR 0 3
18914: IN
18915: ST_TO_ADDR
// end ;
18916: LD_VAR 0 3
18920: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18921: LD_INT 0
18923: PPUSH
// if not chassis or not weapon then
18924: LD_VAR 0 1
18928: NOT
18929: PUSH
18930: LD_VAR 0 2
18934: NOT
18935: OR
18936: IFFALSE 18940
// exit ;
18938: GO 19966
// case weapon of us_machine_gun :
18940: LD_VAR 0 2
18944: PUSH
18945: LD_INT 2
18947: DOUBLE
18948: EQUAL
18949: IFTRUE 18953
18951: GO 18983
18953: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18954: LD_ADDR_VAR 0 3
18958: PUSH
18959: LD_INT 1
18961: PUSH
18962: LD_INT 2
18964: PUSH
18965: LD_INT 3
18967: PUSH
18968: LD_INT 4
18970: PUSH
18971: LD_INT 5
18973: PUSH
18974: EMPTY
18975: LIST
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: ST_TO_ADDR
18981: GO 19950
18983: LD_INT 3
18985: DOUBLE
18986: EQUAL
18987: IFTRUE 18991
18989: GO 19021
18991: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18992: LD_ADDR_VAR 0 3
18996: PUSH
18997: LD_INT 1
18999: PUSH
19000: LD_INT 2
19002: PUSH
19003: LD_INT 3
19005: PUSH
19006: LD_INT 4
19008: PUSH
19009: LD_INT 5
19011: PUSH
19012: EMPTY
19013: LIST
19014: LIST
19015: LIST
19016: LIST
19017: LIST
19018: ST_TO_ADDR
19019: GO 19950
19021: LD_INT 11
19023: DOUBLE
19024: EQUAL
19025: IFTRUE 19029
19027: GO 19059
19029: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19030: LD_ADDR_VAR 0 3
19034: PUSH
19035: LD_INT 1
19037: PUSH
19038: LD_INT 2
19040: PUSH
19041: LD_INT 3
19043: PUSH
19044: LD_INT 4
19046: PUSH
19047: LD_INT 5
19049: PUSH
19050: EMPTY
19051: LIST
19052: LIST
19053: LIST
19054: LIST
19055: LIST
19056: ST_TO_ADDR
19057: GO 19950
19059: LD_INT 4
19061: DOUBLE
19062: EQUAL
19063: IFTRUE 19067
19065: GO 19093
19067: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19068: LD_ADDR_VAR 0 3
19072: PUSH
19073: LD_INT 2
19075: PUSH
19076: LD_INT 3
19078: PUSH
19079: LD_INT 4
19081: PUSH
19082: LD_INT 5
19084: PUSH
19085: EMPTY
19086: LIST
19087: LIST
19088: LIST
19089: LIST
19090: ST_TO_ADDR
19091: GO 19950
19093: LD_INT 5
19095: DOUBLE
19096: EQUAL
19097: IFTRUE 19101
19099: GO 19127
19101: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_INT 2
19109: PUSH
19110: LD_INT 3
19112: PUSH
19113: LD_INT 4
19115: PUSH
19116: LD_INT 5
19118: PUSH
19119: EMPTY
19120: LIST
19121: LIST
19122: LIST
19123: LIST
19124: ST_TO_ADDR
19125: GO 19950
19127: LD_INT 9
19129: DOUBLE
19130: EQUAL
19131: IFTRUE 19135
19133: GO 19161
19135: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19136: LD_ADDR_VAR 0 3
19140: PUSH
19141: LD_INT 2
19143: PUSH
19144: LD_INT 3
19146: PUSH
19147: LD_INT 4
19149: PUSH
19150: LD_INT 5
19152: PUSH
19153: EMPTY
19154: LIST
19155: LIST
19156: LIST
19157: LIST
19158: ST_TO_ADDR
19159: GO 19950
19161: LD_INT 7
19163: DOUBLE
19164: EQUAL
19165: IFTRUE 19169
19167: GO 19195
19169: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19170: LD_ADDR_VAR 0 3
19174: PUSH
19175: LD_INT 2
19177: PUSH
19178: LD_INT 3
19180: PUSH
19181: LD_INT 4
19183: PUSH
19184: LD_INT 5
19186: PUSH
19187: EMPTY
19188: LIST
19189: LIST
19190: LIST
19191: LIST
19192: ST_TO_ADDR
19193: GO 19950
19195: LD_INT 12
19197: DOUBLE
19198: EQUAL
19199: IFTRUE 19203
19201: GO 19229
19203: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19204: LD_ADDR_VAR 0 3
19208: PUSH
19209: LD_INT 2
19211: PUSH
19212: LD_INT 3
19214: PUSH
19215: LD_INT 4
19217: PUSH
19218: LD_INT 5
19220: PUSH
19221: EMPTY
19222: LIST
19223: LIST
19224: LIST
19225: LIST
19226: ST_TO_ADDR
19227: GO 19950
19229: LD_INT 13
19231: DOUBLE
19232: EQUAL
19233: IFTRUE 19237
19235: GO 19263
19237: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19238: LD_ADDR_VAR 0 3
19242: PUSH
19243: LD_INT 2
19245: PUSH
19246: LD_INT 3
19248: PUSH
19249: LD_INT 4
19251: PUSH
19252: LD_INT 5
19254: PUSH
19255: EMPTY
19256: LIST
19257: LIST
19258: LIST
19259: LIST
19260: ST_TO_ADDR
19261: GO 19950
19263: LD_INT 14
19265: DOUBLE
19266: EQUAL
19267: IFTRUE 19271
19269: GO 19289
19271: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19272: LD_ADDR_VAR 0 3
19276: PUSH
19277: LD_INT 4
19279: PUSH
19280: LD_INT 5
19282: PUSH
19283: EMPTY
19284: LIST
19285: LIST
19286: ST_TO_ADDR
19287: GO 19950
19289: LD_INT 6
19291: DOUBLE
19292: EQUAL
19293: IFTRUE 19297
19295: GO 19315
19297: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19298: LD_ADDR_VAR 0 3
19302: PUSH
19303: LD_INT 4
19305: PUSH
19306: LD_INT 5
19308: PUSH
19309: EMPTY
19310: LIST
19311: LIST
19312: ST_TO_ADDR
19313: GO 19950
19315: LD_INT 10
19317: DOUBLE
19318: EQUAL
19319: IFTRUE 19323
19321: GO 19341
19323: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19324: LD_ADDR_VAR 0 3
19328: PUSH
19329: LD_INT 4
19331: PUSH
19332: LD_INT 5
19334: PUSH
19335: EMPTY
19336: LIST
19337: LIST
19338: ST_TO_ADDR
19339: GO 19950
19341: LD_INT 22
19343: DOUBLE
19344: EQUAL
19345: IFTRUE 19349
19347: GO 19375
19349: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19350: LD_ADDR_VAR 0 3
19354: PUSH
19355: LD_INT 11
19357: PUSH
19358: LD_INT 12
19360: PUSH
19361: LD_INT 13
19363: PUSH
19364: LD_INT 14
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: ST_TO_ADDR
19373: GO 19950
19375: LD_INT 23
19377: DOUBLE
19378: EQUAL
19379: IFTRUE 19383
19381: GO 19409
19383: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19384: LD_ADDR_VAR 0 3
19388: PUSH
19389: LD_INT 11
19391: PUSH
19392: LD_INT 12
19394: PUSH
19395: LD_INT 13
19397: PUSH
19398: LD_INT 14
19400: PUSH
19401: EMPTY
19402: LIST
19403: LIST
19404: LIST
19405: LIST
19406: ST_TO_ADDR
19407: GO 19950
19409: LD_INT 24
19411: DOUBLE
19412: EQUAL
19413: IFTRUE 19417
19415: GO 19443
19417: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19418: LD_ADDR_VAR 0 3
19422: PUSH
19423: LD_INT 11
19425: PUSH
19426: LD_INT 12
19428: PUSH
19429: LD_INT 13
19431: PUSH
19432: LD_INT 14
19434: PUSH
19435: EMPTY
19436: LIST
19437: LIST
19438: LIST
19439: LIST
19440: ST_TO_ADDR
19441: GO 19950
19443: LD_INT 30
19445: DOUBLE
19446: EQUAL
19447: IFTRUE 19451
19449: GO 19477
19451: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19452: LD_ADDR_VAR 0 3
19456: PUSH
19457: LD_INT 11
19459: PUSH
19460: LD_INT 12
19462: PUSH
19463: LD_INT 13
19465: PUSH
19466: LD_INT 14
19468: PUSH
19469: EMPTY
19470: LIST
19471: LIST
19472: LIST
19473: LIST
19474: ST_TO_ADDR
19475: GO 19950
19477: LD_INT 25
19479: DOUBLE
19480: EQUAL
19481: IFTRUE 19485
19483: GO 19503
19485: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19486: LD_ADDR_VAR 0 3
19490: PUSH
19491: LD_INT 13
19493: PUSH
19494: LD_INT 14
19496: PUSH
19497: EMPTY
19498: LIST
19499: LIST
19500: ST_TO_ADDR
19501: GO 19950
19503: LD_INT 27
19505: DOUBLE
19506: EQUAL
19507: IFTRUE 19511
19509: GO 19529
19511: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19512: LD_ADDR_VAR 0 3
19516: PUSH
19517: LD_INT 13
19519: PUSH
19520: LD_INT 14
19522: PUSH
19523: EMPTY
19524: LIST
19525: LIST
19526: ST_TO_ADDR
19527: GO 19950
19529: LD_INT 28
19531: DOUBLE
19532: EQUAL
19533: IFTRUE 19537
19535: GO 19555
19537: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19538: LD_ADDR_VAR 0 3
19542: PUSH
19543: LD_INT 13
19545: PUSH
19546: LD_INT 14
19548: PUSH
19549: EMPTY
19550: LIST
19551: LIST
19552: ST_TO_ADDR
19553: GO 19950
19555: LD_INT 29
19557: DOUBLE
19558: EQUAL
19559: IFTRUE 19563
19561: GO 19581
19563: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_INT 13
19571: PUSH
19572: LD_INT 14
19574: PUSH
19575: EMPTY
19576: LIST
19577: LIST
19578: ST_TO_ADDR
19579: GO 19950
19581: LD_INT 31
19583: DOUBLE
19584: EQUAL
19585: IFTRUE 19589
19587: GO 19607
19589: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 13
19597: PUSH
19598: LD_INT 14
19600: PUSH
19601: EMPTY
19602: LIST
19603: LIST
19604: ST_TO_ADDR
19605: GO 19950
19607: LD_INT 26
19609: DOUBLE
19610: EQUAL
19611: IFTRUE 19615
19613: GO 19633
19615: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19616: LD_ADDR_VAR 0 3
19620: PUSH
19621: LD_INT 13
19623: PUSH
19624: LD_INT 14
19626: PUSH
19627: EMPTY
19628: LIST
19629: LIST
19630: ST_TO_ADDR
19631: GO 19950
19633: LD_INT 42
19635: DOUBLE
19636: EQUAL
19637: IFTRUE 19641
19639: GO 19667
19641: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19642: LD_ADDR_VAR 0 3
19646: PUSH
19647: LD_INT 21
19649: PUSH
19650: LD_INT 22
19652: PUSH
19653: LD_INT 23
19655: PUSH
19656: LD_INT 24
19658: PUSH
19659: EMPTY
19660: LIST
19661: LIST
19662: LIST
19663: LIST
19664: ST_TO_ADDR
19665: GO 19950
19667: LD_INT 43
19669: DOUBLE
19670: EQUAL
19671: IFTRUE 19675
19673: GO 19701
19675: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19676: LD_ADDR_VAR 0 3
19680: PUSH
19681: LD_INT 21
19683: PUSH
19684: LD_INT 22
19686: PUSH
19687: LD_INT 23
19689: PUSH
19690: LD_INT 24
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: LIST
19697: LIST
19698: ST_TO_ADDR
19699: GO 19950
19701: LD_INT 44
19703: DOUBLE
19704: EQUAL
19705: IFTRUE 19709
19707: GO 19735
19709: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19710: LD_ADDR_VAR 0 3
19714: PUSH
19715: LD_INT 21
19717: PUSH
19718: LD_INT 22
19720: PUSH
19721: LD_INT 23
19723: PUSH
19724: LD_INT 24
19726: PUSH
19727: EMPTY
19728: LIST
19729: LIST
19730: LIST
19731: LIST
19732: ST_TO_ADDR
19733: GO 19950
19735: LD_INT 45
19737: DOUBLE
19738: EQUAL
19739: IFTRUE 19743
19741: GO 19769
19743: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19744: LD_ADDR_VAR 0 3
19748: PUSH
19749: LD_INT 21
19751: PUSH
19752: LD_INT 22
19754: PUSH
19755: LD_INT 23
19757: PUSH
19758: LD_INT 24
19760: PUSH
19761: EMPTY
19762: LIST
19763: LIST
19764: LIST
19765: LIST
19766: ST_TO_ADDR
19767: GO 19950
19769: LD_INT 49
19771: DOUBLE
19772: EQUAL
19773: IFTRUE 19777
19775: GO 19803
19777: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19778: LD_ADDR_VAR 0 3
19782: PUSH
19783: LD_INT 21
19785: PUSH
19786: LD_INT 22
19788: PUSH
19789: LD_INT 23
19791: PUSH
19792: LD_INT 24
19794: PUSH
19795: EMPTY
19796: LIST
19797: LIST
19798: LIST
19799: LIST
19800: ST_TO_ADDR
19801: GO 19950
19803: LD_INT 51
19805: DOUBLE
19806: EQUAL
19807: IFTRUE 19811
19809: GO 19837
19811: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19812: LD_ADDR_VAR 0 3
19816: PUSH
19817: LD_INT 21
19819: PUSH
19820: LD_INT 22
19822: PUSH
19823: LD_INT 23
19825: PUSH
19826: LD_INT 24
19828: PUSH
19829: EMPTY
19830: LIST
19831: LIST
19832: LIST
19833: LIST
19834: ST_TO_ADDR
19835: GO 19950
19837: LD_INT 52
19839: DOUBLE
19840: EQUAL
19841: IFTRUE 19845
19843: GO 19871
19845: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19846: LD_ADDR_VAR 0 3
19850: PUSH
19851: LD_INT 21
19853: PUSH
19854: LD_INT 22
19856: PUSH
19857: LD_INT 23
19859: PUSH
19860: LD_INT 24
19862: PUSH
19863: EMPTY
19864: LIST
19865: LIST
19866: LIST
19867: LIST
19868: ST_TO_ADDR
19869: GO 19950
19871: LD_INT 53
19873: DOUBLE
19874: EQUAL
19875: IFTRUE 19879
19877: GO 19897
19879: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19880: LD_ADDR_VAR 0 3
19884: PUSH
19885: LD_INT 23
19887: PUSH
19888: LD_INT 24
19890: PUSH
19891: EMPTY
19892: LIST
19893: LIST
19894: ST_TO_ADDR
19895: GO 19950
19897: LD_INT 46
19899: DOUBLE
19900: EQUAL
19901: IFTRUE 19905
19903: GO 19923
19905: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19906: LD_ADDR_VAR 0 3
19910: PUSH
19911: LD_INT 23
19913: PUSH
19914: LD_INT 24
19916: PUSH
19917: EMPTY
19918: LIST
19919: LIST
19920: ST_TO_ADDR
19921: GO 19950
19923: LD_INT 47
19925: DOUBLE
19926: EQUAL
19927: IFTRUE 19931
19929: GO 19949
19931: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19932: LD_ADDR_VAR 0 3
19936: PUSH
19937: LD_INT 23
19939: PUSH
19940: LD_INT 24
19942: PUSH
19943: EMPTY
19944: LIST
19945: LIST
19946: ST_TO_ADDR
19947: GO 19950
19949: POP
// result := ( chassis in result ) ;
19950: LD_ADDR_VAR 0 3
19954: PUSH
19955: LD_VAR 0 1
19959: PUSH
19960: LD_VAR 0 3
19964: IN
19965: ST_TO_ADDR
// end ;
19966: LD_VAR 0 3
19970: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19971: LD_INT 0
19973: PPUSH
19974: PPUSH
19975: PPUSH
19976: PPUSH
19977: PPUSH
19978: PPUSH
19979: PPUSH
// result := array ;
19980: LD_ADDR_VAR 0 5
19984: PUSH
19985: LD_VAR 0 1
19989: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19990: LD_VAR 0 1
19994: NOT
19995: PUSH
19996: LD_VAR 0 2
20000: NOT
20001: OR
20002: PUSH
20003: LD_VAR 0 3
20007: NOT
20008: OR
20009: PUSH
20010: LD_VAR 0 2
20014: PUSH
20015: LD_VAR 0 1
20019: GREATER
20020: OR
20021: PUSH
20022: LD_VAR 0 3
20026: PUSH
20027: LD_VAR 0 1
20031: GREATER
20032: OR
20033: IFFALSE 20037
// exit ;
20035: GO 20333
// if direction then
20037: LD_VAR 0 4
20041: IFFALSE 20105
// begin d := 1 ;
20043: LD_ADDR_VAR 0 9
20047: PUSH
20048: LD_INT 1
20050: ST_TO_ADDR
// if i_from > i_to then
20051: LD_VAR 0 2
20055: PUSH
20056: LD_VAR 0 3
20060: GREATER
20061: IFFALSE 20087
// length := ( array - i_from ) + i_to else
20063: LD_ADDR_VAR 0 11
20067: PUSH
20068: LD_VAR 0 1
20072: PUSH
20073: LD_VAR 0 2
20077: MINUS
20078: PUSH
20079: LD_VAR 0 3
20083: PLUS
20084: ST_TO_ADDR
20085: GO 20103
// length := i_to - i_from ;
20087: LD_ADDR_VAR 0 11
20091: PUSH
20092: LD_VAR 0 3
20096: PUSH
20097: LD_VAR 0 2
20101: MINUS
20102: ST_TO_ADDR
// end else
20103: GO 20166
// begin d := - 1 ;
20105: LD_ADDR_VAR 0 9
20109: PUSH
20110: LD_INT 1
20112: NEG
20113: ST_TO_ADDR
// if i_from > i_to then
20114: LD_VAR 0 2
20118: PUSH
20119: LD_VAR 0 3
20123: GREATER
20124: IFFALSE 20144
// length := i_from - i_to else
20126: LD_ADDR_VAR 0 11
20130: PUSH
20131: LD_VAR 0 2
20135: PUSH
20136: LD_VAR 0 3
20140: MINUS
20141: ST_TO_ADDR
20142: GO 20166
// length := ( array - i_to ) + i_from ;
20144: LD_ADDR_VAR 0 11
20148: PUSH
20149: LD_VAR 0 1
20153: PUSH
20154: LD_VAR 0 3
20158: MINUS
20159: PUSH
20160: LD_VAR 0 2
20164: PLUS
20165: ST_TO_ADDR
// end ; if not length then
20166: LD_VAR 0 11
20170: NOT
20171: IFFALSE 20175
// exit ;
20173: GO 20333
// tmp := array ;
20175: LD_ADDR_VAR 0 10
20179: PUSH
20180: LD_VAR 0 1
20184: ST_TO_ADDR
// for i = 1 to length do
20185: LD_ADDR_VAR 0 6
20189: PUSH
20190: DOUBLE
20191: LD_INT 1
20193: DEC
20194: ST_TO_ADDR
20195: LD_VAR 0 11
20199: PUSH
20200: FOR_TO
20201: IFFALSE 20321
// begin for j = 1 to array do
20203: LD_ADDR_VAR 0 7
20207: PUSH
20208: DOUBLE
20209: LD_INT 1
20211: DEC
20212: ST_TO_ADDR
20213: LD_VAR 0 1
20217: PUSH
20218: FOR_TO
20219: IFFALSE 20307
// begin k := j + d ;
20221: LD_ADDR_VAR 0 8
20225: PUSH
20226: LD_VAR 0 7
20230: PUSH
20231: LD_VAR 0 9
20235: PLUS
20236: ST_TO_ADDR
// if k > array then
20237: LD_VAR 0 8
20241: PUSH
20242: LD_VAR 0 1
20246: GREATER
20247: IFFALSE 20257
// k := 1 ;
20249: LD_ADDR_VAR 0 8
20253: PUSH
20254: LD_INT 1
20256: ST_TO_ADDR
// if not k then
20257: LD_VAR 0 8
20261: NOT
20262: IFFALSE 20274
// k := array ;
20264: LD_ADDR_VAR 0 8
20268: PUSH
20269: LD_VAR 0 1
20273: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20274: LD_ADDR_VAR 0 10
20278: PUSH
20279: LD_VAR 0 10
20283: PPUSH
20284: LD_VAR 0 8
20288: PPUSH
20289: LD_VAR 0 1
20293: PUSH
20294: LD_VAR 0 7
20298: ARRAY
20299: PPUSH
20300: CALL_OW 1
20304: ST_TO_ADDR
// end ;
20305: GO 20218
20307: POP
20308: POP
// array := tmp ;
20309: LD_ADDR_VAR 0 1
20313: PUSH
20314: LD_VAR 0 10
20318: ST_TO_ADDR
// end ;
20319: GO 20200
20321: POP
20322: POP
// result := array ;
20323: LD_ADDR_VAR 0 5
20327: PUSH
20328: LD_VAR 0 1
20332: ST_TO_ADDR
// end ;
20333: LD_VAR 0 5
20337: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20338: LD_INT 0
20340: PPUSH
20341: PPUSH
// result := 0 ;
20342: LD_ADDR_VAR 0 3
20346: PUSH
20347: LD_INT 0
20349: ST_TO_ADDR
// if not array or not value in array then
20350: LD_VAR 0 1
20354: NOT
20355: PUSH
20356: LD_VAR 0 2
20360: PUSH
20361: LD_VAR 0 1
20365: IN
20366: NOT
20367: OR
20368: IFFALSE 20372
// exit ;
20370: GO 20426
// for i = 1 to array do
20372: LD_ADDR_VAR 0 4
20376: PUSH
20377: DOUBLE
20378: LD_INT 1
20380: DEC
20381: ST_TO_ADDR
20382: LD_VAR 0 1
20386: PUSH
20387: FOR_TO
20388: IFFALSE 20424
// if value = array [ i ] then
20390: LD_VAR 0 2
20394: PUSH
20395: LD_VAR 0 1
20399: PUSH
20400: LD_VAR 0 4
20404: ARRAY
20405: EQUAL
20406: IFFALSE 20422
// begin result := i ;
20408: LD_ADDR_VAR 0 3
20412: PUSH
20413: LD_VAR 0 4
20417: ST_TO_ADDR
// exit ;
20418: POP
20419: POP
20420: GO 20426
// end ;
20422: GO 20387
20424: POP
20425: POP
// end ;
20426: LD_VAR 0 3
20430: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20431: LD_INT 0
20433: PPUSH
// vc_chassis := chassis ;
20434: LD_ADDR_OWVAR 37
20438: PUSH
20439: LD_VAR 0 1
20443: ST_TO_ADDR
// vc_engine := engine ;
20444: LD_ADDR_OWVAR 39
20448: PUSH
20449: LD_VAR 0 2
20453: ST_TO_ADDR
// vc_control := control ;
20454: LD_ADDR_OWVAR 38
20458: PUSH
20459: LD_VAR 0 3
20463: ST_TO_ADDR
// vc_weapon := weapon ;
20464: LD_ADDR_OWVAR 40
20468: PUSH
20469: LD_VAR 0 4
20473: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20474: LD_ADDR_OWVAR 41
20478: PUSH
20479: LD_VAR 0 5
20483: ST_TO_ADDR
// end ;
20484: LD_VAR 0 6
20488: RET
// export function WantPlant ( unit ) ; var task ; begin
20489: LD_INT 0
20491: PPUSH
20492: PPUSH
// result := false ;
20493: LD_ADDR_VAR 0 2
20497: PUSH
20498: LD_INT 0
20500: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20501: LD_ADDR_VAR 0 3
20505: PUSH
20506: LD_VAR 0 1
20510: PPUSH
20511: CALL_OW 437
20515: ST_TO_ADDR
// if task then
20516: LD_VAR 0 3
20520: IFFALSE 20548
// if task [ 1 ] [ 1 ] = p then
20522: LD_VAR 0 3
20526: PUSH
20527: LD_INT 1
20529: ARRAY
20530: PUSH
20531: LD_INT 1
20533: ARRAY
20534: PUSH
20535: LD_STRING p
20537: EQUAL
20538: IFFALSE 20548
// result := true ;
20540: LD_ADDR_VAR 0 2
20544: PUSH
20545: LD_INT 1
20547: ST_TO_ADDR
// end ;
20548: LD_VAR 0 2
20552: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20553: LD_INT 0
20555: PPUSH
20556: PPUSH
20557: PPUSH
20558: PPUSH
// if pos < 1 then
20559: LD_VAR 0 2
20563: PUSH
20564: LD_INT 1
20566: LESS
20567: IFFALSE 20571
// exit ;
20569: GO 20874
// if pos = 1 then
20571: LD_VAR 0 2
20575: PUSH
20576: LD_INT 1
20578: EQUAL
20579: IFFALSE 20612
// result := Replace ( arr , pos [ 1 ] , value ) else
20581: LD_ADDR_VAR 0 4
20585: PUSH
20586: LD_VAR 0 1
20590: PPUSH
20591: LD_VAR 0 2
20595: PUSH
20596: LD_INT 1
20598: ARRAY
20599: PPUSH
20600: LD_VAR 0 3
20604: PPUSH
20605: CALL_OW 1
20609: ST_TO_ADDR
20610: GO 20874
// begin tmp := arr ;
20612: LD_ADDR_VAR 0 6
20616: PUSH
20617: LD_VAR 0 1
20621: ST_TO_ADDR
// s_arr := [ tmp ] ;
20622: LD_ADDR_VAR 0 7
20626: PUSH
20627: LD_VAR 0 6
20631: PUSH
20632: EMPTY
20633: LIST
20634: ST_TO_ADDR
// for i = 1 to pos - 1 do
20635: LD_ADDR_VAR 0 5
20639: PUSH
20640: DOUBLE
20641: LD_INT 1
20643: DEC
20644: ST_TO_ADDR
20645: LD_VAR 0 2
20649: PUSH
20650: LD_INT 1
20652: MINUS
20653: PUSH
20654: FOR_TO
20655: IFFALSE 20700
// begin tmp := tmp [ pos [ i ] ] ;
20657: LD_ADDR_VAR 0 6
20661: PUSH
20662: LD_VAR 0 6
20666: PUSH
20667: LD_VAR 0 2
20671: PUSH
20672: LD_VAR 0 5
20676: ARRAY
20677: ARRAY
20678: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20679: LD_ADDR_VAR 0 7
20683: PUSH
20684: LD_VAR 0 7
20688: PUSH
20689: LD_VAR 0 6
20693: PUSH
20694: EMPTY
20695: LIST
20696: ADD
20697: ST_TO_ADDR
// end ;
20698: GO 20654
20700: POP
20701: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20702: LD_ADDR_VAR 0 6
20706: PUSH
20707: LD_VAR 0 6
20711: PPUSH
20712: LD_VAR 0 2
20716: PUSH
20717: LD_VAR 0 2
20721: ARRAY
20722: PPUSH
20723: LD_VAR 0 3
20727: PPUSH
20728: CALL_OW 1
20732: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20733: LD_ADDR_VAR 0 7
20737: PUSH
20738: LD_VAR 0 7
20742: PPUSH
20743: LD_VAR 0 7
20747: PPUSH
20748: LD_VAR 0 6
20752: PPUSH
20753: CALL_OW 1
20757: ST_TO_ADDR
// for i = s_arr downto 2 do
20758: LD_ADDR_VAR 0 5
20762: PUSH
20763: DOUBLE
20764: LD_VAR 0 7
20768: INC
20769: ST_TO_ADDR
20770: LD_INT 2
20772: PUSH
20773: FOR_DOWNTO
20774: IFFALSE 20858
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20776: LD_ADDR_VAR 0 6
20780: PUSH
20781: LD_VAR 0 7
20785: PUSH
20786: LD_VAR 0 5
20790: PUSH
20791: LD_INT 1
20793: MINUS
20794: ARRAY
20795: PPUSH
20796: LD_VAR 0 2
20800: PUSH
20801: LD_VAR 0 5
20805: PUSH
20806: LD_INT 1
20808: MINUS
20809: ARRAY
20810: PPUSH
20811: LD_VAR 0 7
20815: PUSH
20816: LD_VAR 0 5
20820: ARRAY
20821: PPUSH
20822: CALL_OW 1
20826: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20827: LD_ADDR_VAR 0 7
20831: PUSH
20832: LD_VAR 0 7
20836: PPUSH
20837: LD_VAR 0 5
20841: PUSH
20842: LD_INT 1
20844: MINUS
20845: PPUSH
20846: LD_VAR 0 6
20850: PPUSH
20851: CALL_OW 1
20855: ST_TO_ADDR
// end ;
20856: GO 20773
20858: POP
20859: POP
// result := s_arr [ 1 ] ;
20860: LD_ADDR_VAR 0 4
20864: PUSH
20865: LD_VAR 0 7
20869: PUSH
20870: LD_INT 1
20872: ARRAY
20873: ST_TO_ADDR
// end ; end ;
20874: LD_VAR 0 4
20878: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20879: LD_INT 0
20881: PPUSH
20882: PPUSH
// if not list then
20883: LD_VAR 0 1
20887: NOT
20888: IFFALSE 20892
// exit ;
20890: GO 20983
// i := list [ pos1 ] ;
20892: LD_ADDR_VAR 0 5
20896: PUSH
20897: LD_VAR 0 1
20901: PUSH
20902: LD_VAR 0 2
20906: ARRAY
20907: ST_TO_ADDR
// if not i then
20908: LD_VAR 0 5
20912: NOT
20913: IFFALSE 20917
// exit ;
20915: GO 20983
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20917: LD_ADDR_VAR 0 1
20921: PUSH
20922: LD_VAR 0 1
20926: PPUSH
20927: LD_VAR 0 2
20931: PPUSH
20932: LD_VAR 0 1
20936: PUSH
20937: LD_VAR 0 3
20941: ARRAY
20942: PPUSH
20943: CALL_OW 1
20947: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20948: LD_ADDR_VAR 0 1
20952: PUSH
20953: LD_VAR 0 1
20957: PPUSH
20958: LD_VAR 0 3
20962: PPUSH
20963: LD_VAR 0 5
20967: PPUSH
20968: CALL_OW 1
20972: ST_TO_ADDR
// result := list ;
20973: LD_ADDR_VAR 0 4
20977: PUSH
20978: LD_VAR 0 1
20982: ST_TO_ADDR
// end ;
20983: LD_VAR 0 4
20987: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20988: LD_INT 0
20990: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20991: LD_ADDR_VAR 0 5
20995: PUSH
20996: LD_VAR 0 1
21000: PPUSH
21001: CALL_OW 250
21005: PPUSH
21006: LD_VAR 0 1
21010: PPUSH
21011: CALL_OW 251
21015: PPUSH
21016: LD_VAR 0 2
21020: PPUSH
21021: LD_VAR 0 3
21025: PPUSH
21026: LD_VAR 0 4
21030: PPUSH
21031: CALL 21041 0 5
21035: ST_TO_ADDR
// end ;
21036: LD_VAR 0 5
21040: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21041: LD_INT 0
21043: PPUSH
21044: PPUSH
21045: PPUSH
21046: PPUSH
// if not list then
21047: LD_VAR 0 3
21051: NOT
21052: IFFALSE 21056
// exit ;
21054: GO 21444
// result := [ ] ;
21056: LD_ADDR_VAR 0 6
21060: PUSH
21061: EMPTY
21062: ST_TO_ADDR
// for i in list do
21063: LD_ADDR_VAR 0 7
21067: PUSH
21068: LD_VAR 0 3
21072: PUSH
21073: FOR_IN
21074: IFFALSE 21276
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21076: LD_ADDR_VAR 0 9
21080: PUSH
21081: LD_VAR 0 7
21085: PPUSH
21086: LD_VAR 0 1
21090: PPUSH
21091: LD_VAR 0 2
21095: PPUSH
21096: CALL_OW 297
21100: ST_TO_ADDR
// if not result then
21101: LD_VAR 0 6
21105: NOT
21106: IFFALSE 21132
// result := [ [ i , tmp ] ] else
21108: LD_ADDR_VAR 0 6
21112: PUSH
21113: LD_VAR 0 7
21117: PUSH
21118: LD_VAR 0 9
21122: PUSH
21123: EMPTY
21124: LIST
21125: LIST
21126: PUSH
21127: EMPTY
21128: LIST
21129: ST_TO_ADDR
21130: GO 21274
// begin if result [ result ] [ 2 ] < tmp then
21132: LD_VAR 0 6
21136: PUSH
21137: LD_VAR 0 6
21141: ARRAY
21142: PUSH
21143: LD_INT 2
21145: ARRAY
21146: PUSH
21147: LD_VAR 0 9
21151: LESS
21152: IFFALSE 21194
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21154: LD_ADDR_VAR 0 6
21158: PUSH
21159: LD_VAR 0 6
21163: PPUSH
21164: LD_VAR 0 6
21168: PUSH
21169: LD_INT 1
21171: PLUS
21172: PPUSH
21173: LD_VAR 0 7
21177: PUSH
21178: LD_VAR 0 9
21182: PUSH
21183: EMPTY
21184: LIST
21185: LIST
21186: PPUSH
21187: CALL_OW 2
21191: ST_TO_ADDR
21192: GO 21274
// for j = 1 to result do
21194: LD_ADDR_VAR 0 8
21198: PUSH
21199: DOUBLE
21200: LD_INT 1
21202: DEC
21203: ST_TO_ADDR
21204: LD_VAR 0 6
21208: PUSH
21209: FOR_TO
21210: IFFALSE 21272
// begin if tmp < result [ j ] [ 2 ] then
21212: LD_VAR 0 9
21216: PUSH
21217: LD_VAR 0 6
21221: PUSH
21222: LD_VAR 0 8
21226: ARRAY
21227: PUSH
21228: LD_INT 2
21230: ARRAY
21231: LESS
21232: IFFALSE 21270
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21234: LD_ADDR_VAR 0 6
21238: PUSH
21239: LD_VAR 0 6
21243: PPUSH
21244: LD_VAR 0 8
21248: PPUSH
21249: LD_VAR 0 7
21253: PUSH
21254: LD_VAR 0 9
21258: PUSH
21259: EMPTY
21260: LIST
21261: LIST
21262: PPUSH
21263: CALL_OW 2
21267: ST_TO_ADDR
// break ;
21268: GO 21272
// end ; end ;
21270: GO 21209
21272: POP
21273: POP
// end ; end ;
21274: GO 21073
21276: POP
21277: POP
// if result and not asc then
21278: LD_VAR 0 6
21282: PUSH
21283: LD_VAR 0 4
21287: NOT
21288: AND
21289: IFFALSE 21364
// begin tmp := result ;
21291: LD_ADDR_VAR 0 9
21295: PUSH
21296: LD_VAR 0 6
21300: ST_TO_ADDR
// for i = tmp downto 1 do
21301: LD_ADDR_VAR 0 7
21305: PUSH
21306: DOUBLE
21307: LD_VAR 0 9
21311: INC
21312: ST_TO_ADDR
21313: LD_INT 1
21315: PUSH
21316: FOR_DOWNTO
21317: IFFALSE 21362
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21319: LD_ADDR_VAR 0 6
21323: PUSH
21324: LD_VAR 0 6
21328: PPUSH
21329: LD_VAR 0 9
21333: PUSH
21334: LD_VAR 0 7
21338: MINUS
21339: PUSH
21340: LD_INT 1
21342: PLUS
21343: PPUSH
21344: LD_VAR 0 9
21348: PUSH
21349: LD_VAR 0 7
21353: ARRAY
21354: PPUSH
21355: CALL_OW 1
21359: ST_TO_ADDR
21360: GO 21316
21362: POP
21363: POP
// end ; tmp := [ ] ;
21364: LD_ADDR_VAR 0 9
21368: PUSH
21369: EMPTY
21370: ST_TO_ADDR
// if mode then
21371: LD_VAR 0 5
21375: IFFALSE 21444
// begin for i = 1 to result do
21377: LD_ADDR_VAR 0 7
21381: PUSH
21382: DOUBLE
21383: LD_INT 1
21385: DEC
21386: ST_TO_ADDR
21387: LD_VAR 0 6
21391: PUSH
21392: FOR_TO
21393: IFFALSE 21432
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21395: LD_ADDR_VAR 0 9
21399: PUSH
21400: LD_VAR 0 9
21404: PPUSH
21405: LD_VAR 0 7
21409: PPUSH
21410: LD_VAR 0 6
21414: PUSH
21415: LD_VAR 0 7
21419: ARRAY
21420: PUSH
21421: LD_INT 1
21423: ARRAY
21424: PPUSH
21425: CALL_OW 1
21429: ST_TO_ADDR
21430: GO 21392
21432: POP
21433: POP
// result := tmp ;
21434: LD_ADDR_VAR 0 6
21438: PUSH
21439: LD_VAR 0 9
21443: ST_TO_ADDR
// end ; end ;
21444: LD_VAR 0 6
21448: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21449: LD_INT 0
21451: PPUSH
21452: PPUSH
21453: PPUSH
21454: PPUSH
21455: PPUSH
21456: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21457: LD_ADDR_VAR 0 5
21461: PUSH
21462: LD_INT 0
21464: PUSH
21465: LD_INT 0
21467: PUSH
21468: LD_INT 0
21470: PUSH
21471: EMPTY
21472: PUSH
21473: EMPTY
21474: LIST
21475: LIST
21476: LIST
21477: LIST
21478: ST_TO_ADDR
// if not x or not y then
21479: LD_VAR 0 2
21483: NOT
21484: PUSH
21485: LD_VAR 0 3
21489: NOT
21490: OR
21491: IFFALSE 21495
// exit ;
21493: GO 23141
// if not range then
21495: LD_VAR 0 4
21499: NOT
21500: IFFALSE 21510
// range := 10 ;
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: LD_INT 10
21509: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21510: LD_ADDR_VAR 0 8
21514: PUSH
21515: LD_INT 81
21517: PUSH
21518: LD_VAR 0 1
21522: PUSH
21523: EMPTY
21524: LIST
21525: LIST
21526: PUSH
21527: LD_INT 92
21529: PUSH
21530: LD_VAR 0 2
21534: PUSH
21535: LD_VAR 0 3
21539: PUSH
21540: LD_VAR 0 4
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: LIST
21549: LIST
21550: PUSH
21551: LD_INT 3
21553: PUSH
21554: LD_INT 21
21556: PUSH
21557: LD_INT 3
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: PUSH
21568: EMPTY
21569: LIST
21570: LIST
21571: LIST
21572: PPUSH
21573: CALL_OW 69
21577: ST_TO_ADDR
// if not tmp then
21578: LD_VAR 0 8
21582: NOT
21583: IFFALSE 21587
// exit ;
21585: GO 23141
// for i in tmp do
21587: LD_ADDR_VAR 0 6
21591: PUSH
21592: LD_VAR 0 8
21596: PUSH
21597: FOR_IN
21598: IFFALSE 23116
// begin points := [ 0 , 0 , 0 ] ;
21600: LD_ADDR_VAR 0 9
21604: PUSH
21605: LD_INT 0
21607: PUSH
21608: LD_INT 0
21610: PUSH
21611: LD_INT 0
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: LIST
21618: ST_TO_ADDR
// bpoints := 1 ;
21619: LD_ADDR_VAR 0 10
21623: PUSH
21624: LD_INT 1
21626: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21627: LD_VAR 0 6
21631: PPUSH
21632: CALL_OW 247
21636: PUSH
21637: LD_INT 1
21639: DOUBLE
21640: EQUAL
21641: IFTRUE 21645
21643: GO 22223
21645: POP
// begin if GetClass ( i ) = 1 then
21646: LD_VAR 0 6
21650: PPUSH
21651: CALL_OW 257
21655: PUSH
21656: LD_INT 1
21658: EQUAL
21659: IFFALSE 21680
// points := [ 10 , 5 , 3 ] ;
21661: LD_ADDR_VAR 0 9
21665: PUSH
21666: LD_INT 10
21668: PUSH
21669: LD_INT 5
21671: PUSH
21672: LD_INT 3
21674: PUSH
21675: EMPTY
21676: LIST
21677: LIST
21678: LIST
21679: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21680: LD_VAR 0 6
21684: PPUSH
21685: CALL_OW 257
21689: PUSH
21690: LD_INT 2
21692: PUSH
21693: LD_INT 3
21695: PUSH
21696: LD_INT 4
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: LIST
21703: IN
21704: IFFALSE 21725
// points := [ 3 , 2 , 1 ] ;
21706: LD_ADDR_VAR 0 9
21710: PUSH
21711: LD_INT 3
21713: PUSH
21714: LD_INT 2
21716: PUSH
21717: LD_INT 1
21719: PUSH
21720: EMPTY
21721: LIST
21722: LIST
21723: LIST
21724: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21725: LD_VAR 0 6
21729: PPUSH
21730: CALL_OW 257
21734: PUSH
21735: LD_INT 5
21737: EQUAL
21738: IFFALSE 21759
// points := [ 130 , 5 , 2 ] ;
21740: LD_ADDR_VAR 0 9
21744: PUSH
21745: LD_INT 130
21747: PUSH
21748: LD_INT 5
21750: PUSH
21751: LD_INT 2
21753: PUSH
21754: EMPTY
21755: LIST
21756: LIST
21757: LIST
21758: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21759: LD_VAR 0 6
21763: PPUSH
21764: CALL_OW 257
21768: PUSH
21769: LD_INT 8
21771: EQUAL
21772: IFFALSE 21793
// points := [ 35 , 35 , 30 ] ;
21774: LD_ADDR_VAR 0 9
21778: PUSH
21779: LD_INT 35
21781: PUSH
21782: LD_INT 35
21784: PUSH
21785: LD_INT 30
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: LIST
21792: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21793: LD_VAR 0 6
21797: PPUSH
21798: CALL_OW 257
21802: PUSH
21803: LD_INT 9
21805: EQUAL
21806: IFFALSE 21827
// points := [ 20 , 55 , 40 ] ;
21808: LD_ADDR_VAR 0 9
21812: PUSH
21813: LD_INT 20
21815: PUSH
21816: LD_INT 55
21818: PUSH
21819: LD_INT 40
21821: PUSH
21822: EMPTY
21823: LIST
21824: LIST
21825: LIST
21826: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21827: LD_VAR 0 6
21831: PPUSH
21832: CALL_OW 257
21836: PUSH
21837: LD_INT 12
21839: PUSH
21840: LD_INT 16
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: IN
21847: IFFALSE 21868
// points := [ 5 , 3 , 2 ] ;
21849: LD_ADDR_VAR 0 9
21853: PUSH
21854: LD_INT 5
21856: PUSH
21857: LD_INT 3
21859: PUSH
21860: LD_INT 2
21862: PUSH
21863: EMPTY
21864: LIST
21865: LIST
21866: LIST
21867: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21868: LD_VAR 0 6
21872: PPUSH
21873: CALL_OW 257
21877: PUSH
21878: LD_INT 17
21880: EQUAL
21881: IFFALSE 21902
// points := [ 100 , 50 , 75 ] ;
21883: LD_ADDR_VAR 0 9
21887: PUSH
21888: LD_INT 100
21890: PUSH
21891: LD_INT 50
21893: PUSH
21894: LD_INT 75
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: LIST
21901: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21902: LD_VAR 0 6
21906: PPUSH
21907: CALL_OW 257
21911: PUSH
21912: LD_INT 15
21914: EQUAL
21915: IFFALSE 21936
// points := [ 10 , 5 , 3 ] ;
21917: LD_ADDR_VAR 0 9
21921: PUSH
21922: LD_INT 10
21924: PUSH
21925: LD_INT 5
21927: PUSH
21928: LD_INT 3
21930: PUSH
21931: EMPTY
21932: LIST
21933: LIST
21934: LIST
21935: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21936: LD_VAR 0 6
21940: PPUSH
21941: CALL_OW 257
21945: PUSH
21946: LD_INT 14
21948: EQUAL
21949: IFFALSE 21970
// points := [ 10 , 0 , 0 ] ;
21951: LD_ADDR_VAR 0 9
21955: PUSH
21956: LD_INT 10
21958: PUSH
21959: LD_INT 0
21961: PUSH
21962: LD_INT 0
21964: PUSH
21965: EMPTY
21966: LIST
21967: LIST
21968: LIST
21969: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21970: LD_VAR 0 6
21974: PPUSH
21975: CALL_OW 257
21979: PUSH
21980: LD_INT 11
21982: EQUAL
21983: IFFALSE 22004
// points := [ 30 , 10 , 5 ] ;
21985: LD_ADDR_VAR 0 9
21989: PUSH
21990: LD_INT 30
21992: PUSH
21993: LD_INT 10
21995: PUSH
21996: LD_INT 5
21998: PUSH
21999: EMPTY
22000: LIST
22001: LIST
22002: LIST
22003: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22004: LD_VAR 0 1
22008: PPUSH
22009: LD_INT 5
22011: PPUSH
22012: CALL_OW 321
22016: PUSH
22017: LD_INT 2
22019: EQUAL
22020: IFFALSE 22037
// bpoints := bpoints * 1.8 ;
22022: LD_ADDR_VAR 0 10
22026: PUSH
22027: LD_VAR 0 10
22031: PUSH
22032: LD_REAL  1.80000000000000E+0000
22035: MUL
22036: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22037: LD_VAR 0 6
22041: PPUSH
22042: CALL_OW 257
22046: PUSH
22047: LD_INT 1
22049: PUSH
22050: LD_INT 2
22052: PUSH
22053: LD_INT 3
22055: PUSH
22056: LD_INT 4
22058: PUSH
22059: EMPTY
22060: LIST
22061: LIST
22062: LIST
22063: LIST
22064: IN
22065: PUSH
22066: LD_VAR 0 1
22070: PPUSH
22071: LD_INT 51
22073: PPUSH
22074: CALL_OW 321
22078: PUSH
22079: LD_INT 2
22081: EQUAL
22082: AND
22083: IFFALSE 22100
// bpoints := bpoints * 1.2 ;
22085: LD_ADDR_VAR 0 10
22089: PUSH
22090: LD_VAR 0 10
22094: PUSH
22095: LD_REAL  1.20000000000000E+0000
22098: MUL
22099: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22100: LD_VAR 0 6
22104: PPUSH
22105: CALL_OW 257
22109: PUSH
22110: LD_INT 5
22112: PUSH
22113: LD_INT 7
22115: PUSH
22116: LD_INT 9
22118: PUSH
22119: EMPTY
22120: LIST
22121: LIST
22122: LIST
22123: IN
22124: PUSH
22125: LD_VAR 0 1
22129: PPUSH
22130: LD_INT 52
22132: PPUSH
22133: CALL_OW 321
22137: PUSH
22138: LD_INT 2
22140: EQUAL
22141: AND
22142: IFFALSE 22159
// bpoints := bpoints * 1.5 ;
22144: LD_ADDR_VAR 0 10
22148: PUSH
22149: LD_VAR 0 10
22153: PUSH
22154: LD_REAL  1.50000000000000E+0000
22157: MUL
22158: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22159: LD_VAR 0 1
22163: PPUSH
22164: LD_INT 66
22166: PPUSH
22167: CALL_OW 321
22171: PUSH
22172: LD_INT 2
22174: EQUAL
22175: IFFALSE 22192
// bpoints := bpoints * 1.1 ;
22177: LD_ADDR_VAR 0 10
22181: PUSH
22182: LD_VAR 0 10
22186: PUSH
22187: LD_REAL  1.10000000000000E+0000
22190: MUL
22191: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22192: LD_ADDR_VAR 0 10
22196: PUSH
22197: LD_VAR 0 10
22201: PUSH
22202: LD_VAR 0 6
22206: PPUSH
22207: LD_INT 1
22209: PPUSH
22210: CALL_OW 259
22214: PUSH
22215: LD_REAL  1.15000000000000E+0000
22218: MUL
22219: MUL
22220: ST_TO_ADDR
// end ; unit_vehicle :
22221: GO 23045
22223: LD_INT 2
22225: DOUBLE
22226: EQUAL
22227: IFTRUE 22231
22229: GO 23033
22231: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22232: LD_VAR 0 6
22236: PPUSH
22237: CALL_OW 264
22241: PUSH
22242: LD_INT 2
22244: PUSH
22245: LD_INT 42
22247: PUSH
22248: LD_INT 24
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: LIST
22255: IN
22256: IFFALSE 22277
// points := [ 25 , 5 , 3 ] ;
22258: LD_ADDR_VAR 0 9
22262: PUSH
22263: LD_INT 25
22265: PUSH
22266: LD_INT 5
22268: PUSH
22269: LD_INT 3
22271: PUSH
22272: EMPTY
22273: LIST
22274: LIST
22275: LIST
22276: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22277: LD_VAR 0 6
22281: PPUSH
22282: CALL_OW 264
22286: PUSH
22287: LD_INT 4
22289: PUSH
22290: LD_INT 43
22292: PUSH
22293: LD_INT 25
22295: PUSH
22296: EMPTY
22297: LIST
22298: LIST
22299: LIST
22300: IN
22301: IFFALSE 22322
// points := [ 40 , 15 , 5 ] ;
22303: LD_ADDR_VAR 0 9
22307: PUSH
22308: LD_INT 40
22310: PUSH
22311: LD_INT 15
22313: PUSH
22314: LD_INT 5
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: LIST
22321: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22322: LD_VAR 0 6
22326: PPUSH
22327: CALL_OW 264
22331: PUSH
22332: LD_INT 3
22334: PUSH
22335: LD_INT 23
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: IN
22342: IFFALSE 22363
// points := [ 7 , 25 , 8 ] ;
22344: LD_ADDR_VAR 0 9
22348: PUSH
22349: LD_INT 7
22351: PUSH
22352: LD_INT 25
22354: PUSH
22355: LD_INT 8
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22363: LD_VAR 0 6
22367: PPUSH
22368: CALL_OW 264
22372: PUSH
22373: LD_INT 5
22375: PUSH
22376: LD_INT 27
22378: PUSH
22379: LD_INT 44
22381: PUSH
22382: EMPTY
22383: LIST
22384: LIST
22385: LIST
22386: IN
22387: IFFALSE 22408
// points := [ 14 , 50 , 16 ] ;
22389: LD_ADDR_VAR 0 9
22393: PUSH
22394: LD_INT 14
22396: PUSH
22397: LD_INT 50
22399: PUSH
22400: LD_INT 16
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: LIST
22407: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22408: LD_VAR 0 6
22412: PPUSH
22413: CALL_OW 264
22417: PUSH
22418: LD_INT 6
22420: PUSH
22421: LD_INT 46
22423: PUSH
22424: EMPTY
22425: LIST
22426: LIST
22427: IN
22428: IFFALSE 22449
// points := [ 32 , 120 , 70 ] ;
22430: LD_ADDR_VAR 0 9
22434: PUSH
22435: LD_INT 32
22437: PUSH
22438: LD_INT 120
22440: PUSH
22441: LD_INT 70
22443: PUSH
22444: EMPTY
22445: LIST
22446: LIST
22447: LIST
22448: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22449: LD_VAR 0 6
22453: PPUSH
22454: CALL_OW 264
22458: PUSH
22459: LD_INT 7
22461: PUSH
22462: LD_INT 28
22464: PUSH
22465: LD_INT 45
22467: PUSH
22468: EMPTY
22469: LIST
22470: LIST
22471: LIST
22472: IN
22473: IFFALSE 22494
// points := [ 35 , 20 , 45 ] ;
22475: LD_ADDR_VAR 0 9
22479: PUSH
22480: LD_INT 35
22482: PUSH
22483: LD_INT 20
22485: PUSH
22486: LD_INT 45
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: LIST
22493: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22494: LD_VAR 0 6
22498: PPUSH
22499: CALL_OW 264
22503: PUSH
22504: LD_INT 47
22506: PUSH
22507: EMPTY
22508: LIST
22509: IN
22510: IFFALSE 22531
// points := [ 67 , 45 , 75 ] ;
22512: LD_ADDR_VAR 0 9
22516: PUSH
22517: LD_INT 67
22519: PUSH
22520: LD_INT 45
22522: PUSH
22523: LD_INT 75
22525: PUSH
22526: EMPTY
22527: LIST
22528: LIST
22529: LIST
22530: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22531: LD_VAR 0 6
22535: PPUSH
22536: CALL_OW 264
22540: PUSH
22541: LD_INT 26
22543: PUSH
22544: EMPTY
22545: LIST
22546: IN
22547: IFFALSE 22568
// points := [ 120 , 30 , 80 ] ;
22549: LD_ADDR_VAR 0 9
22553: PUSH
22554: LD_INT 120
22556: PUSH
22557: LD_INT 30
22559: PUSH
22560: LD_INT 80
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: LIST
22567: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22568: LD_VAR 0 6
22572: PPUSH
22573: CALL_OW 264
22577: PUSH
22578: LD_INT 22
22580: PUSH
22581: EMPTY
22582: LIST
22583: IN
22584: IFFALSE 22605
// points := [ 40 , 1 , 1 ] ;
22586: LD_ADDR_VAR 0 9
22590: PUSH
22591: LD_INT 40
22593: PUSH
22594: LD_INT 1
22596: PUSH
22597: LD_INT 1
22599: PUSH
22600: EMPTY
22601: LIST
22602: LIST
22603: LIST
22604: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22605: LD_VAR 0 6
22609: PPUSH
22610: CALL_OW 264
22614: PUSH
22615: LD_INT 29
22617: PUSH
22618: EMPTY
22619: LIST
22620: IN
22621: IFFALSE 22642
// points := [ 70 , 200 , 400 ] ;
22623: LD_ADDR_VAR 0 9
22627: PUSH
22628: LD_INT 70
22630: PUSH
22631: LD_INT 200
22633: PUSH
22634: LD_INT 400
22636: PUSH
22637: EMPTY
22638: LIST
22639: LIST
22640: LIST
22641: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22642: LD_VAR 0 6
22646: PPUSH
22647: CALL_OW 264
22651: PUSH
22652: LD_INT 14
22654: PUSH
22655: LD_INT 53
22657: PUSH
22658: EMPTY
22659: LIST
22660: LIST
22661: IN
22662: IFFALSE 22683
// points := [ 40 , 10 , 20 ] ;
22664: LD_ADDR_VAR 0 9
22668: PUSH
22669: LD_INT 40
22671: PUSH
22672: LD_INT 10
22674: PUSH
22675: LD_INT 20
22677: PUSH
22678: EMPTY
22679: LIST
22680: LIST
22681: LIST
22682: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22683: LD_VAR 0 6
22687: PPUSH
22688: CALL_OW 264
22692: PUSH
22693: LD_INT 9
22695: PUSH
22696: EMPTY
22697: LIST
22698: IN
22699: IFFALSE 22720
// points := [ 5 , 70 , 20 ] ;
22701: LD_ADDR_VAR 0 9
22705: PUSH
22706: LD_INT 5
22708: PUSH
22709: LD_INT 70
22711: PUSH
22712: LD_INT 20
22714: PUSH
22715: EMPTY
22716: LIST
22717: LIST
22718: LIST
22719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22720: LD_VAR 0 6
22724: PPUSH
22725: CALL_OW 264
22729: PUSH
22730: LD_INT 10
22732: PUSH
22733: EMPTY
22734: LIST
22735: IN
22736: IFFALSE 22757
// points := [ 35 , 110 , 70 ] ;
22738: LD_ADDR_VAR 0 9
22742: PUSH
22743: LD_INT 35
22745: PUSH
22746: LD_INT 110
22748: PUSH
22749: LD_INT 70
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: LIST
22756: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22757: LD_VAR 0 6
22761: PPUSH
22762: CALL_OW 265
22766: PUSH
22767: LD_INT 25
22769: EQUAL
22770: IFFALSE 22791
// points := [ 80 , 65 , 100 ] ;
22772: LD_ADDR_VAR 0 9
22776: PUSH
22777: LD_INT 80
22779: PUSH
22780: LD_INT 65
22782: PUSH
22783: LD_INT 100
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: LIST
22790: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22791: LD_VAR 0 6
22795: PPUSH
22796: CALL_OW 263
22800: PUSH
22801: LD_INT 1
22803: EQUAL
22804: IFFALSE 22839
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22806: LD_ADDR_VAR 0 10
22810: PUSH
22811: LD_VAR 0 10
22815: PUSH
22816: LD_VAR 0 6
22820: PPUSH
22821: CALL_OW 311
22825: PPUSH
22826: LD_INT 3
22828: PPUSH
22829: CALL_OW 259
22833: PUSH
22834: LD_INT 4
22836: MUL
22837: MUL
22838: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22839: LD_VAR 0 6
22843: PPUSH
22844: CALL_OW 263
22848: PUSH
22849: LD_INT 2
22851: EQUAL
22852: IFFALSE 22903
// begin j := IsControledBy ( i ) ;
22854: LD_ADDR_VAR 0 7
22858: PUSH
22859: LD_VAR 0 6
22863: PPUSH
22864: CALL_OW 312
22868: ST_TO_ADDR
// if j then
22869: LD_VAR 0 7
22873: IFFALSE 22903
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22875: LD_ADDR_VAR 0 10
22879: PUSH
22880: LD_VAR 0 10
22884: PUSH
22885: LD_VAR 0 7
22889: PPUSH
22890: LD_INT 3
22892: PPUSH
22893: CALL_OW 259
22897: PUSH
22898: LD_INT 3
22900: MUL
22901: MUL
22902: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22903: LD_VAR 0 6
22907: PPUSH
22908: CALL_OW 264
22912: PUSH
22913: LD_INT 5
22915: PUSH
22916: LD_INT 6
22918: PUSH
22919: LD_INT 46
22921: PUSH
22922: LD_INT 44
22924: PUSH
22925: LD_INT 47
22927: PUSH
22928: LD_INT 45
22930: PUSH
22931: LD_INT 28
22933: PUSH
22934: LD_INT 7
22936: PUSH
22937: LD_INT 27
22939: PUSH
22940: LD_INT 29
22942: PUSH
22943: EMPTY
22944: LIST
22945: LIST
22946: LIST
22947: LIST
22948: LIST
22949: LIST
22950: LIST
22951: LIST
22952: LIST
22953: LIST
22954: IN
22955: PUSH
22956: LD_VAR 0 1
22960: PPUSH
22961: LD_INT 52
22963: PPUSH
22964: CALL_OW 321
22968: PUSH
22969: LD_INT 2
22971: EQUAL
22972: AND
22973: IFFALSE 22990
// bpoints := bpoints * 1.2 ;
22975: LD_ADDR_VAR 0 10
22979: PUSH
22980: LD_VAR 0 10
22984: PUSH
22985: LD_REAL  1.20000000000000E+0000
22988: MUL
22989: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22990: LD_VAR 0 6
22994: PPUSH
22995: CALL_OW 264
22999: PUSH
23000: LD_INT 6
23002: PUSH
23003: LD_INT 46
23005: PUSH
23006: LD_INT 47
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: LIST
23013: IN
23014: IFFALSE 23031
// bpoints := bpoints * 1.2 ;
23016: LD_ADDR_VAR 0 10
23020: PUSH
23021: LD_VAR 0 10
23025: PUSH
23026: LD_REAL  1.20000000000000E+0000
23029: MUL
23030: ST_TO_ADDR
// end ; unit_building :
23031: GO 23045
23033: LD_INT 3
23035: DOUBLE
23036: EQUAL
23037: IFTRUE 23041
23039: GO 23044
23041: POP
// ; end ;
23042: GO 23045
23044: POP
// for j = 1 to 3 do
23045: LD_ADDR_VAR 0 7
23049: PUSH
23050: DOUBLE
23051: LD_INT 1
23053: DEC
23054: ST_TO_ADDR
23055: LD_INT 3
23057: PUSH
23058: FOR_TO
23059: IFFALSE 23112
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23061: LD_ADDR_VAR 0 5
23065: PUSH
23066: LD_VAR 0 5
23070: PPUSH
23071: LD_VAR 0 7
23075: PPUSH
23076: LD_VAR 0 5
23080: PUSH
23081: LD_VAR 0 7
23085: ARRAY
23086: PUSH
23087: LD_VAR 0 9
23091: PUSH
23092: LD_VAR 0 7
23096: ARRAY
23097: PUSH
23098: LD_VAR 0 10
23102: MUL
23103: PLUS
23104: PPUSH
23105: CALL_OW 1
23109: ST_TO_ADDR
23110: GO 23058
23112: POP
23113: POP
// end ;
23114: GO 21597
23116: POP
23117: POP
// result := Replace ( result , 4 , tmp ) ;
23118: LD_ADDR_VAR 0 5
23122: PUSH
23123: LD_VAR 0 5
23127: PPUSH
23128: LD_INT 4
23130: PPUSH
23131: LD_VAR 0 8
23135: PPUSH
23136: CALL_OW 1
23140: ST_TO_ADDR
// end ;
23141: LD_VAR 0 5
23145: RET
// export function DangerAtRange ( unit , range ) ; begin
23146: LD_INT 0
23148: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23149: LD_ADDR_VAR 0 3
23153: PUSH
23154: LD_VAR 0 1
23158: PPUSH
23159: CALL_OW 255
23163: PPUSH
23164: LD_VAR 0 1
23168: PPUSH
23169: CALL_OW 250
23173: PPUSH
23174: LD_VAR 0 1
23178: PPUSH
23179: CALL_OW 251
23183: PPUSH
23184: LD_VAR 0 2
23188: PPUSH
23189: CALL 21449 0 4
23193: ST_TO_ADDR
// end ;
23194: LD_VAR 0 3
23198: RET
// export function DangerInArea ( side , area ) ; begin
23199: LD_INT 0
23201: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23202: LD_ADDR_VAR 0 3
23206: PUSH
23207: LD_VAR 0 2
23211: PPUSH
23212: LD_INT 81
23214: PUSH
23215: LD_VAR 0 1
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PPUSH
23224: CALL_OW 70
23228: ST_TO_ADDR
// end ;
23229: LD_VAR 0 3
23233: RET
// export function IsExtension ( b ) ; begin
23234: LD_INT 0
23236: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23237: LD_ADDR_VAR 0 2
23241: PUSH
23242: LD_VAR 0 1
23246: PUSH
23247: LD_INT 23
23249: PUSH
23250: LD_INT 20
23252: PUSH
23253: LD_INT 22
23255: PUSH
23256: LD_INT 17
23258: PUSH
23259: LD_INT 24
23261: PUSH
23262: LD_INT 21
23264: PUSH
23265: LD_INT 19
23267: PUSH
23268: LD_INT 16
23270: PUSH
23271: LD_INT 25
23273: PUSH
23274: LD_INT 18
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: LIST
23281: LIST
23282: LIST
23283: LIST
23284: LIST
23285: LIST
23286: LIST
23287: LIST
23288: IN
23289: ST_TO_ADDR
// end ;
23290: LD_VAR 0 2
23294: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23295: LD_INT 0
23297: PPUSH
23298: PPUSH
23299: PPUSH
// result := [ ] ;
23300: LD_ADDR_VAR 0 3
23304: PUSH
23305: EMPTY
23306: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23307: LD_ADDR_VAR 0 4
23311: PUSH
23312: LD_VAR 0 2
23316: PPUSH
23317: LD_INT 21
23319: PUSH
23320: LD_INT 3
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: PPUSH
23327: CALL_OW 70
23331: ST_TO_ADDR
// if not tmp then
23332: LD_VAR 0 4
23336: NOT
23337: IFFALSE 23341
// exit ;
23339: GO 23399
// for i in tmp do
23341: LD_ADDR_VAR 0 5
23345: PUSH
23346: LD_VAR 0 4
23350: PUSH
23351: FOR_IN
23352: IFFALSE 23387
// if GetBase ( i ) <> base then
23354: LD_VAR 0 5
23358: PPUSH
23359: CALL_OW 274
23363: PUSH
23364: LD_VAR 0 1
23368: NONEQUAL
23369: IFFALSE 23385
// ComLinkToBase ( base , i ) ;
23371: LD_VAR 0 1
23375: PPUSH
23376: LD_VAR 0 5
23380: PPUSH
23381: CALL_OW 169
23385: GO 23351
23387: POP
23388: POP
// result := tmp ;
23389: LD_ADDR_VAR 0 3
23393: PUSH
23394: LD_VAR 0 4
23398: ST_TO_ADDR
// end ;
23399: LD_VAR 0 3
23403: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23404: LD_INT 0
23406: PPUSH
23407: PPUSH
// if BuildingStatus ( b ) = bs_build then
23408: LD_VAR 0 2
23412: PPUSH
23413: CALL_OW 461
23417: PUSH
23418: LD_INT 1
23420: EQUAL
23421: IFFALSE 23481
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23423: LD_VAR 0 1
23427: PPUSH
23428: LD_STRING h
23430: PUSH
23431: LD_VAR 0 2
23435: PPUSH
23436: CALL_OW 250
23440: PUSH
23441: LD_VAR 0 2
23445: PPUSH
23446: CALL_OW 251
23450: PUSH
23451: LD_VAR 0 2
23455: PUSH
23456: LD_INT 0
23458: PUSH
23459: LD_INT 0
23461: PUSH
23462: LD_INT 0
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: LIST
23471: LIST
23472: LIST
23473: PUSH
23474: EMPTY
23475: LIST
23476: PPUSH
23477: CALL_OW 446
// end ;
23481: LD_VAR 0 3
23485: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23486: LD_INT 0
23488: PPUSH
23489: PPUSH
23490: PPUSH
23491: PPUSH
23492: PPUSH
23493: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23494: LD_VAR 0 1
23498: NOT
23499: PUSH
23500: LD_VAR 0 1
23504: PPUSH
23505: CALL_OW 263
23509: PUSH
23510: LD_INT 2
23512: EQUAL
23513: NOT
23514: OR
23515: IFFALSE 23519
// exit ;
23517: GO 23835
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23519: LD_ADDR_VAR 0 6
23523: PUSH
23524: LD_INT 22
23526: PUSH
23527: LD_VAR 0 1
23531: PPUSH
23532: CALL_OW 255
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: PUSH
23541: LD_INT 2
23543: PUSH
23544: LD_INT 30
23546: PUSH
23547: LD_INT 36
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PUSH
23554: LD_INT 34
23556: PUSH
23557: LD_INT 31
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: EMPTY
23565: LIST
23566: LIST
23567: LIST
23568: PUSH
23569: EMPTY
23570: LIST
23571: LIST
23572: PPUSH
23573: CALL_OW 69
23577: ST_TO_ADDR
// if not tmp then
23578: LD_VAR 0 6
23582: NOT
23583: IFFALSE 23587
// exit ;
23585: GO 23835
// result := [ ] ;
23587: LD_ADDR_VAR 0 2
23591: PUSH
23592: EMPTY
23593: ST_TO_ADDR
// for i in tmp do
23594: LD_ADDR_VAR 0 3
23598: PUSH
23599: LD_VAR 0 6
23603: PUSH
23604: FOR_IN
23605: IFFALSE 23676
// begin t := UnitsInside ( i ) ;
23607: LD_ADDR_VAR 0 4
23611: PUSH
23612: LD_VAR 0 3
23616: PPUSH
23617: CALL_OW 313
23621: ST_TO_ADDR
// if t then
23622: LD_VAR 0 4
23626: IFFALSE 23674
// for j in t do
23628: LD_ADDR_VAR 0 7
23632: PUSH
23633: LD_VAR 0 4
23637: PUSH
23638: FOR_IN
23639: IFFALSE 23672
// result := Insert ( result , result + 1 , j ) ;
23641: LD_ADDR_VAR 0 2
23645: PUSH
23646: LD_VAR 0 2
23650: PPUSH
23651: LD_VAR 0 2
23655: PUSH
23656: LD_INT 1
23658: PLUS
23659: PPUSH
23660: LD_VAR 0 7
23664: PPUSH
23665: CALL_OW 2
23669: ST_TO_ADDR
23670: GO 23638
23672: POP
23673: POP
// end ;
23674: GO 23604
23676: POP
23677: POP
// if not result then
23678: LD_VAR 0 2
23682: NOT
23683: IFFALSE 23687
// exit ;
23685: GO 23835
// mech := result [ 1 ] ;
23687: LD_ADDR_VAR 0 5
23691: PUSH
23692: LD_VAR 0 2
23696: PUSH
23697: LD_INT 1
23699: ARRAY
23700: ST_TO_ADDR
// if result > 1 then
23701: LD_VAR 0 2
23705: PUSH
23706: LD_INT 1
23708: GREATER
23709: IFFALSE 23821
// for i = 2 to result do
23711: LD_ADDR_VAR 0 3
23715: PUSH
23716: DOUBLE
23717: LD_INT 2
23719: DEC
23720: ST_TO_ADDR
23721: LD_VAR 0 2
23725: PUSH
23726: FOR_TO
23727: IFFALSE 23819
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23729: LD_ADDR_VAR 0 4
23733: PUSH
23734: LD_VAR 0 2
23738: PUSH
23739: LD_VAR 0 3
23743: ARRAY
23744: PPUSH
23745: LD_INT 3
23747: PPUSH
23748: CALL_OW 259
23752: PUSH
23753: LD_VAR 0 2
23757: PUSH
23758: LD_VAR 0 3
23762: ARRAY
23763: PPUSH
23764: CALL_OW 432
23768: MINUS
23769: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23770: LD_VAR 0 4
23774: PUSH
23775: LD_VAR 0 5
23779: PPUSH
23780: LD_INT 3
23782: PPUSH
23783: CALL_OW 259
23787: PUSH
23788: LD_VAR 0 5
23792: PPUSH
23793: CALL_OW 432
23797: MINUS
23798: GREATEREQUAL
23799: IFFALSE 23817
// mech := result [ i ] ;
23801: LD_ADDR_VAR 0 5
23805: PUSH
23806: LD_VAR 0 2
23810: PUSH
23811: LD_VAR 0 3
23815: ARRAY
23816: ST_TO_ADDR
// end ;
23817: GO 23726
23819: POP
23820: POP
// ComLinkTo ( vehicle , mech ) ;
23821: LD_VAR 0 1
23825: PPUSH
23826: LD_VAR 0 5
23830: PPUSH
23831: CALL_OW 135
// end ;
23835: LD_VAR 0 2
23839: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23840: LD_INT 0
23842: PPUSH
23843: PPUSH
23844: PPUSH
23845: PPUSH
23846: PPUSH
23847: PPUSH
23848: PPUSH
23849: PPUSH
23850: PPUSH
23851: PPUSH
23852: PPUSH
23853: PPUSH
23854: PPUSH
// result := [ ] ;
23855: LD_ADDR_VAR 0 7
23859: PUSH
23860: EMPTY
23861: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23862: LD_VAR 0 1
23866: PPUSH
23867: CALL_OW 266
23871: PUSH
23872: LD_INT 0
23874: PUSH
23875: LD_INT 1
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: IN
23882: NOT
23883: IFFALSE 23887
// exit ;
23885: GO 25518
// if name then
23887: LD_VAR 0 3
23891: IFFALSE 23907
// SetBName ( base_dep , name ) ;
23893: LD_VAR 0 1
23897: PPUSH
23898: LD_VAR 0 3
23902: PPUSH
23903: CALL_OW 500
// base := GetBase ( base_dep ) ;
23907: LD_ADDR_VAR 0 15
23911: PUSH
23912: LD_VAR 0 1
23916: PPUSH
23917: CALL_OW 274
23921: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23922: LD_ADDR_VAR 0 16
23926: PUSH
23927: LD_VAR 0 1
23931: PPUSH
23932: CALL_OW 255
23936: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23937: LD_ADDR_VAR 0 17
23941: PUSH
23942: LD_VAR 0 1
23946: PPUSH
23947: CALL_OW 248
23951: ST_TO_ADDR
// if sources then
23952: LD_VAR 0 5
23956: IFFALSE 24003
// for i = 1 to 3 do
23958: LD_ADDR_VAR 0 8
23962: PUSH
23963: DOUBLE
23964: LD_INT 1
23966: DEC
23967: ST_TO_ADDR
23968: LD_INT 3
23970: PUSH
23971: FOR_TO
23972: IFFALSE 24001
// AddResourceType ( base , i , sources [ i ] ) ;
23974: LD_VAR 0 15
23978: PPUSH
23979: LD_VAR 0 8
23983: PPUSH
23984: LD_VAR 0 5
23988: PUSH
23989: LD_VAR 0 8
23993: ARRAY
23994: PPUSH
23995: CALL_OW 276
23999: GO 23971
24001: POP
24002: POP
// buildings := GetBaseBuildings ( base , area ) ;
24003: LD_ADDR_VAR 0 18
24007: PUSH
24008: LD_VAR 0 15
24012: PPUSH
24013: LD_VAR 0 2
24017: PPUSH
24018: CALL 23295 0 2
24022: ST_TO_ADDR
// InitHc ;
24023: CALL_OW 19
// InitUc ;
24027: CALL_OW 18
// uc_side := side ;
24031: LD_ADDR_OWVAR 20
24035: PUSH
24036: LD_VAR 0 16
24040: ST_TO_ADDR
// uc_nation := nation ;
24041: LD_ADDR_OWVAR 21
24045: PUSH
24046: LD_VAR 0 17
24050: ST_TO_ADDR
// if buildings then
24051: LD_VAR 0 18
24055: IFFALSE 25377
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24057: LD_ADDR_VAR 0 19
24061: PUSH
24062: LD_VAR 0 18
24066: PPUSH
24067: LD_INT 2
24069: PUSH
24070: LD_INT 30
24072: PUSH
24073: LD_INT 29
24075: PUSH
24076: EMPTY
24077: LIST
24078: LIST
24079: PUSH
24080: LD_INT 30
24082: PUSH
24083: LD_INT 30
24085: PUSH
24086: EMPTY
24087: LIST
24088: LIST
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: LIST
24094: PPUSH
24095: CALL_OW 72
24099: ST_TO_ADDR
// if tmp then
24100: LD_VAR 0 19
24104: IFFALSE 24152
// for i in tmp do
24106: LD_ADDR_VAR 0 8
24110: PUSH
24111: LD_VAR 0 19
24115: PUSH
24116: FOR_IN
24117: IFFALSE 24150
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24119: LD_VAR 0 8
24123: PPUSH
24124: CALL_OW 250
24128: PPUSH
24129: LD_VAR 0 8
24133: PPUSH
24134: CALL_OW 251
24138: PPUSH
24139: LD_VAR 0 16
24143: PPUSH
24144: CALL_OW 441
24148: GO 24116
24150: POP
24151: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24152: LD_VAR 0 18
24156: PPUSH
24157: LD_INT 2
24159: PUSH
24160: LD_INT 30
24162: PUSH
24163: LD_INT 32
24165: PUSH
24166: EMPTY
24167: LIST
24168: LIST
24169: PUSH
24170: LD_INT 30
24172: PUSH
24173: LD_INT 33
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PUSH
24180: EMPTY
24181: LIST
24182: LIST
24183: LIST
24184: PPUSH
24185: CALL_OW 72
24189: IFFALSE 24277
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24191: LD_ADDR_VAR 0 8
24195: PUSH
24196: LD_VAR 0 18
24200: PPUSH
24201: LD_INT 2
24203: PUSH
24204: LD_INT 30
24206: PUSH
24207: LD_INT 32
24209: PUSH
24210: EMPTY
24211: LIST
24212: LIST
24213: PUSH
24214: LD_INT 30
24216: PUSH
24217: LD_INT 33
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: PUSH
24224: EMPTY
24225: LIST
24226: LIST
24227: LIST
24228: PPUSH
24229: CALL_OW 72
24233: PUSH
24234: FOR_IN
24235: IFFALSE 24275
// begin if not GetBWeapon ( i ) then
24237: LD_VAR 0 8
24241: PPUSH
24242: CALL_OW 269
24246: NOT
24247: IFFALSE 24273
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24249: LD_VAR 0 8
24253: PPUSH
24254: LD_VAR 0 8
24258: PPUSH
24259: LD_VAR 0 2
24263: PPUSH
24264: CALL 25523 0 2
24268: PPUSH
24269: CALL_OW 431
// end ;
24273: GO 24234
24275: POP
24276: POP
// end ; for i = 1 to personel do
24277: LD_ADDR_VAR 0 8
24281: PUSH
24282: DOUBLE
24283: LD_INT 1
24285: DEC
24286: ST_TO_ADDR
24287: LD_VAR 0 6
24291: PUSH
24292: FOR_TO
24293: IFFALSE 25357
// begin if i > 4 then
24295: LD_VAR 0 8
24299: PUSH
24300: LD_INT 4
24302: GREATER
24303: IFFALSE 24307
// break ;
24305: GO 25357
// case i of 1 :
24307: LD_VAR 0 8
24311: PUSH
24312: LD_INT 1
24314: DOUBLE
24315: EQUAL
24316: IFTRUE 24320
24318: GO 24400
24320: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24321: LD_ADDR_VAR 0 12
24325: PUSH
24326: LD_VAR 0 18
24330: PPUSH
24331: LD_INT 22
24333: PUSH
24334: LD_VAR 0 16
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: PUSH
24343: LD_INT 58
24345: PUSH
24346: EMPTY
24347: LIST
24348: PUSH
24349: LD_INT 2
24351: PUSH
24352: LD_INT 30
24354: PUSH
24355: LD_INT 32
24357: PUSH
24358: EMPTY
24359: LIST
24360: LIST
24361: PUSH
24362: LD_INT 30
24364: PUSH
24365: LD_INT 4
24367: PUSH
24368: EMPTY
24369: LIST
24370: LIST
24371: PUSH
24372: LD_INT 30
24374: PUSH
24375: LD_INT 5
24377: PUSH
24378: EMPTY
24379: LIST
24380: LIST
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: LIST
24386: LIST
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: LIST
24392: PPUSH
24393: CALL_OW 72
24397: ST_TO_ADDR
24398: GO 24622
24400: LD_INT 2
24402: DOUBLE
24403: EQUAL
24404: IFTRUE 24408
24406: GO 24470
24408: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24409: LD_ADDR_VAR 0 12
24413: PUSH
24414: LD_VAR 0 18
24418: PPUSH
24419: LD_INT 22
24421: PUSH
24422: LD_VAR 0 16
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_INT 2
24433: PUSH
24434: LD_INT 30
24436: PUSH
24437: LD_INT 0
24439: PUSH
24440: EMPTY
24441: LIST
24442: LIST
24443: PUSH
24444: LD_INT 30
24446: PUSH
24447: LD_INT 1
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: LIST
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PPUSH
24463: CALL_OW 72
24467: ST_TO_ADDR
24468: GO 24622
24470: LD_INT 3
24472: DOUBLE
24473: EQUAL
24474: IFTRUE 24478
24476: GO 24540
24478: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24479: LD_ADDR_VAR 0 12
24483: PUSH
24484: LD_VAR 0 18
24488: PPUSH
24489: LD_INT 22
24491: PUSH
24492: LD_VAR 0 16
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: PUSH
24501: LD_INT 2
24503: PUSH
24504: LD_INT 30
24506: PUSH
24507: LD_INT 2
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: PUSH
24514: LD_INT 30
24516: PUSH
24517: LD_INT 3
24519: PUSH
24520: EMPTY
24521: LIST
24522: LIST
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: PPUSH
24533: CALL_OW 72
24537: ST_TO_ADDR
24538: GO 24622
24540: LD_INT 4
24542: DOUBLE
24543: EQUAL
24544: IFTRUE 24548
24546: GO 24621
24548: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24549: LD_ADDR_VAR 0 12
24553: PUSH
24554: LD_VAR 0 18
24558: PPUSH
24559: LD_INT 22
24561: PUSH
24562: LD_VAR 0 16
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: LD_INT 2
24573: PUSH
24574: LD_INT 30
24576: PUSH
24577: LD_INT 6
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: LD_INT 30
24586: PUSH
24587: LD_INT 7
24589: PUSH
24590: EMPTY
24591: LIST
24592: LIST
24593: PUSH
24594: LD_INT 30
24596: PUSH
24597: LD_INT 8
24599: PUSH
24600: EMPTY
24601: LIST
24602: LIST
24603: PUSH
24604: EMPTY
24605: LIST
24606: LIST
24607: LIST
24608: LIST
24609: PUSH
24610: EMPTY
24611: LIST
24612: LIST
24613: PPUSH
24614: CALL_OW 72
24618: ST_TO_ADDR
24619: GO 24622
24621: POP
// if i = 1 then
24622: LD_VAR 0 8
24626: PUSH
24627: LD_INT 1
24629: EQUAL
24630: IFFALSE 24741
// begin tmp := [ ] ;
24632: LD_ADDR_VAR 0 19
24636: PUSH
24637: EMPTY
24638: ST_TO_ADDR
// for j in f do
24639: LD_ADDR_VAR 0 9
24643: PUSH
24644: LD_VAR 0 12
24648: PUSH
24649: FOR_IN
24650: IFFALSE 24723
// if GetBType ( j ) = b_bunker then
24652: LD_VAR 0 9
24656: PPUSH
24657: CALL_OW 266
24661: PUSH
24662: LD_INT 32
24664: EQUAL
24665: IFFALSE 24692
// tmp := Insert ( tmp , 1 , j ) else
24667: LD_ADDR_VAR 0 19
24671: PUSH
24672: LD_VAR 0 19
24676: PPUSH
24677: LD_INT 1
24679: PPUSH
24680: LD_VAR 0 9
24684: PPUSH
24685: CALL_OW 2
24689: ST_TO_ADDR
24690: GO 24721
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24692: LD_ADDR_VAR 0 19
24696: PUSH
24697: LD_VAR 0 19
24701: PPUSH
24702: LD_VAR 0 19
24706: PUSH
24707: LD_INT 1
24709: PLUS
24710: PPUSH
24711: LD_VAR 0 9
24715: PPUSH
24716: CALL_OW 2
24720: ST_TO_ADDR
24721: GO 24649
24723: POP
24724: POP
// if tmp then
24725: LD_VAR 0 19
24729: IFFALSE 24741
// f := tmp ;
24731: LD_ADDR_VAR 0 12
24735: PUSH
24736: LD_VAR 0 19
24740: ST_TO_ADDR
// end ; x := personel [ i ] ;
24741: LD_ADDR_VAR 0 13
24745: PUSH
24746: LD_VAR 0 6
24750: PUSH
24751: LD_VAR 0 8
24755: ARRAY
24756: ST_TO_ADDR
// if x = - 1 then
24757: LD_VAR 0 13
24761: PUSH
24762: LD_INT 1
24764: NEG
24765: EQUAL
24766: IFFALSE 24975
// begin for j in f do
24768: LD_ADDR_VAR 0 9
24772: PUSH
24773: LD_VAR 0 12
24777: PUSH
24778: FOR_IN
24779: IFFALSE 24971
// repeat InitHc ;
24781: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24785: LD_VAR 0 9
24789: PPUSH
24790: CALL_OW 266
24794: PUSH
24795: LD_INT 5
24797: EQUAL
24798: IFFALSE 24868
// begin if UnitsInside ( j ) < 3 then
24800: LD_VAR 0 9
24804: PPUSH
24805: CALL_OW 313
24809: PUSH
24810: LD_INT 3
24812: LESS
24813: IFFALSE 24849
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24815: LD_INT 0
24817: PPUSH
24818: LD_INT 5
24820: PUSH
24821: LD_INT 8
24823: PUSH
24824: LD_INT 9
24826: PUSH
24827: EMPTY
24828: LIST
24829: LIST
24830: LIST
24831: PUSH
24832: LD_VAR 0 17
24836: ARRAY
24837: PPUSH
24838: LD_VAR 0 4
24842: PPUSH
24843: CALL_OW 380
24847: GO 24866
// PrepareHuman ( false , i , skill ) ;
24849: LD_INT 0
24851: PPUSH
24852: LD_VAR 0 8
24856: PPUSH
24857: LD_VAR 0 4
24861: PPUSH
24862: CALL_OW 380
// end else
24866: GO 24885
// PrepareHuman ( false , i , skill ) ;
24868: LD_INT 0
24870: PPUSH
24871: LD_VAR 0 8
24875: PPUSH
24876: LD_VAR 0 4
24880: PPUSH
24881: CALL_OW 380
// un := CreateHuman ;
24885: LD_ADDR_VAR 0 14
24889: PUSH
24890: CALL_OW 44
24894: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24895: LD_ADDR_VAR 0 7
24899: PUSH
24900: LD_VAR 0 7
24904: PPUSH
24905: LD_INT 1
24907: PPUSH
24908: LD_VAR 0 14
24912: PPUSH
24913: CALL_OW 2
24917: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24918: LD_VAR 0 14
24922: PPUSH
24923: LD_VAR 0 9
24927: PPUSH
24928: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24932: LD_VAR 0 9
24936: PPUSH
24937: CALL_OW 313
24941: PUSH
24942: LD_INT 6
24944: EQUAL
24945: PUSH
24946: LD_VAR 0 9
24950: PPUSH
24951: CALL_OW 266
24955: PUSH
24956: LD_INT 32
24958: PUSH
24959: LD_INT 31
24961: PUSH
24962: EMPTY
24963: LIST
24964: LIST
24965: IN
24966: OR
24967: IFFALSE 24781
24969: GO 24778
24971: POP
24972: POP
// end else
24973: GO 25355
// for j = 1 to x do
24975: LD_ADDR_VAR 0 9
24979: PUSH
24980: DOUBLE
24981: LD_INT 1
24983: DEC
24984: ST_TO_ADDR
24985: LD_VAR 0 13
24989: PUSH
24990: FOR_TO
24991: IFFALSE 25353
// begin InitHc ;
24993: CALL_OW 19
// if not f then
24997: LD_VAR 0 12
25001: NOT
25002: IFFALSE 25091
// begin PrepareHuman ( false , i , skill ) ;
25004: LD_INT 0
25006: PPUSH
25007: LD_VAR 0 8
25011: PPUSH
25012: LD_VAR 0 4
25016: PPUSH
25017: CALL_OW 380
// un := CreateHuman ;
25021: LD_ADDR_VAR 0 14
25025: PUSH
25026: CALL_OW 44
25030: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25031: LD_ADDR_VAR 0 7
25035: PUSH
25036: LD_VAR 0 7
25040: PPUSH
25041: LD_INT 1
25043: PPUSH
25044: LD_VAR 0 14
25048: PPUSH
25049: CALL_OW 2
25053: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25054: LD_VAR 0 14
25058: PPUSH
25059: LD_VAR 0 1
25063: PPUSH
25064: CALL_OW 250
25068: PPUSH
25069: LD_VAR 0 1
25073: PPUSH
25074: CALL_OW 251
25078: PPUSH
25079: LD_INT 10
25081: PPUSH
25082: LD_INT 0
25084: PPUSH
25085: CALL_OW 50
// continue ;
25089: GO 24990
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25091: LD_VAR 0 12
25095: PUSH
25096: LD_INT 1
25098: ARRAY
25099: PPUSH
25100: CALL_OW 313
25104: PUSH
25105: LD_VAR 0 12
25109: PUSH
25110: LD_INT 1
25112: ARRAY
25113: PPUSH
25114: CALL_OW 266
25118: PUSH
25119: LD_INT 32
25121: PUSH
25122: LD_INT 31
25124: PUSH
25125: EMPTY
25126: LIST
25127: LIST
25128: IN
25129: AND
25130: PUSH
25131: LD_VAR 0 12
25135: PUSH
25136: LD_INT 1
25138: ARRAY
25139: PPUSH
25140: CALL_OW 313
25144: PUSH
25145: LD_INT 6
25147: EQUAL
25148: OR
25149: IFFALSE 25169
// f := Delete ( f , 1 ) ;
25151: LD_ADDR_VAR 0 12
25155: PUSH
25156: LD_VAR 0 12
25160: PPUSH
25161: LD_INT 1
25163: PPUSH
25164: CALL_OW 3
25168: ST_TO_ADDR
// if not f then
25169: LD_VAR 0 12
25173: NOT
25174: IFFALSE 25192
// begin x := x + 2 ;
25176: LD_ADDR_VAR 0 13
25180: PUSH
25181: LD_VAR 0 13
25185: PUSH
25186: LD_INT 2
25188: PLUS
25189: ST_TO_ADDR
// continue ;
25190: GO 24990
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25192: LD_VAR 0 12
25196: PUSH
25197: LD_INT 1
25199: ARRAY
25200: PPUSH
25201: CALL_OW 266
25205: PUSH
25206: LD_INT 5
25208: EQUAL
25209: IFFALSE 25283
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25211: LD_VAR 0 12
25215: PUSH
25216: LD_INT 1
25218: ARRAY
25219: PPUSH
25220: CALL_OW 313
25224: PUSH
25225: LD_INT 3
25227: LESS
25228: IFFALSE 25264
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25230: LD_INT 0
25232: PPUSH
25233: LD_INT 5
25235: PUSH
25236: LD_INT 8
25238: PUSH
25239: LD_INT 9
25241: PUSH
25242: EMPTY
25243: LIST
25244: LIST
25245: LIST
25246: PUSH
25247: LD_VAR 0 17
25251: ARRAY
25252: PPUSH
25253: LD_VAR 0 4
25257: PPUSH
25258: CALL_OW 380
25262: GO 25281
// PrepareHuman ( false , i , skill ) ;
25264: LD_INT 0
25266: PPUSH
25267: LD_VAR 0 8
25271: PPUSH
25272: LD_VAR 0 4
25276: PPUSH
25277: CALL_OW 380
// end else
25281: GO 25300
// PrepareHuman ( false , i , skill ) ;
25283: LD_INT 0
25285: PPUSH
25286: LD_VAR 0 8
25290: PPUSH
25291: LD_VAR 0 4
25295: PPUSH
25296: CALL_OW 380
// un := CreateHuman ;
25300: LD_ADDR_VAR 0 14
25304: PUSH
25305: CALL_OW 44
25309: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25310: LD_ADDR_VAR 0 7
25314: PUSH
25315: LD_VAR 0 7
25319: PPUSH
25320: LD_INT 1
25322: PPUSH
25323: LD_VAR 0 14
25327: PPUSH
25328: CALL_OW 2
25332: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25333: LD_VAR 0 14
25337: PPUSH
25338: LD_VAR 0 12
25342: PUSH
25343: LD_INT 1
25345: ARRAY
25346: PPUSH
25347: CALL_OW 52
// end ;
25351: GO 24990
25353: POP
25354: POP
// end ;
25355: GO 24292
25357: POP
25358: POP
// result := result ^ buildings ;
25359: LD_ADDR_VAR 0 7
25363: PUSH
25364: LD_VAR 0 7
25368: PUSH
25369: LD_VAR 0 18
25373: ADD
25374: ST_TO_ADDR
// end else
25375: GO 25518
// begin for i = 1 to personel do
25377: LD_ADDR_VAR 0 8
25381: PUSH
25382: DOUBLE
25383: LD_INT 1
25385: DEC
25386: ST_TO_ADDR
25387: LD_VAR 0 6
25391: PUSH
25392: FOR_TO
25393: IFFALSE 25516
// begin if i > 4 then
25395: LD_VAR 0 8
25399: PUSH
25400: LD_INT 4
25402: GREATER
25403: IFFALSE 25407
// break ;
25405: GO 25516
// x := personel [ i ] ;
25407: LD_ADDR_VAR 0 13
25411: PUSH
25412: LD_VAR 0 6
25416: PUSH
25417: LD_VAR 0 8
25421: ARRAY
25422: ST_TO_ADDR
// if x = - 1 then
25423: LD_VAR 0 13
25427: PUSH
25428: LD_INT 1
25430: NEG
25431: EQUAL
25432: IFFALSE 25436
// continue ;
25434: GO 25392
// PrepareHuman ( false , i , skill ) ;
25436: LD_INT 0
25438: PPUSH
25439: LD_VAR 0 8
25443: PPUSH
25444: LD_VAR 0 4
25448: PPUSH
25449: CALL_OW 380
// un := CreateHuman ;
25453: LD_ADDR_VAR 0 14
25457: PUSH
25458: CALL_OW 44
25462: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25463: LD_VAR 0 14
25467: PPUSH
25468: LD_VAR 0 1
25472: PPUSH
25473: CALL_OW 250
25477: PPUSH
25478: LD_VAR 0 1
25482: PPUSH
25483: CALL_OW 251
25487: PPUSH
25488: LD_INT 10
25490: PPUSH
25491: LD_INT 0
25493: PPUSH
25494: CALL_OW 50
// result := result ^ un ;
25498: LD_ADDR_VAR 0 7
25502: PUSH
25503: LD_VAR 0 7
25507: PUSH
25508: LD_VAR 0 14
25512: ADD
25513: ST_TO_ADDR
// end ;
25514: GO 25392
25516: POP
25517: POP
// end ; end ;
25518: LD_VAR 0 7
25522: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25523: LD_INT 0
25525: PPUSH
25526: PPUSH
25527: PPUSH
25528: PPUSH
25529: PPUSH
25530: PPUSH
25531: PPUSH
25532: PPUSH
25533: PPUSH
25534: PPUSH
25535: PPUSH
25536: PPUSH
25537: PPUSH
25538: PPUSH
25539: PPUSH
25540: PPUSH
// result := false ;
25541: LD_ADDR_VAR 0 3
25545: PUSH
25546: LD_INT 0
25548: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25549: LD_VAR 0 1
25553: NOT
25554: PUSH
25555: LD_VAR 0 1
25559: PPUSH
25560: CALL_OW 266
25564: PUSH
25565: LD_INT 32
25567: PUSH
25568: LD_INT 33
25570: PUSH
25571: EMPTY
25572: LIST
25573: LIST
25574: IN
25575: NOT
25576: OR
25577: IFFALSE 25581
// exit ;
25579: GO 26717
// nat := GetNation ( tower ) ;
25581: LD_ADDR_VAR 0 12
25585: PUSH
25586: LD_VAR 0 1
25590: PPUSH
25591: CALL_OW 248
25595: ST_TO_ADDR
// side := GetSide ( tower ) ;
25596: LD_ADDR_VAR 0 16
25600: PUSH
25601: LD_VAR 0 1
25605: PPUSH
25606: CALL_OW 255
25610: ST_TO_ADDR
// x := GetX ( tower ) ;
25611: LD_ADDR_VAR 0 10
25615: PUSH
25616: LD_VAR 0 1
25620: PPUSH
25621: CALL_OW 250
25625: ST_TO_ADDR
// y := GetY ( tower ) ;
25626: LD_ADDR_VAR 0 11
25630: PUSH
25631: LD_VAR 0 1
25635: PPUSH
25636: CALL_OW 251
25640: ST_TO_ADDR
// if not x or not y then
25641: LD_VAR 0 10
25645: NOT
25646: PUSH
25647: LD_VAR 0 11
25651: NOT
25652: OR
25653: IFFALSE 25657
// exit ;
25655: GO 26717
// weapon := 0 ;
25657: LD_ADDR_VAR 0 18
25661: PUSH
25662: LD_INT 0
25664: ST_TO_ADDR
// fac_list := [ ] ;
25665: LD_ADDR_VAR 0 17
25669: PUSH
25670: EMPTY
25671: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25672: LD_ADDR_VAR 0 6
25676: PUSH
25677: LD_VAR 0 1
25681: PPUSH
25682: CALL_OW 274
25686: PPUSH
25687: LD_VAR 0 2
25691: PPUSH
25692: CALL 23295 0 2
25696: PPUSH
25697: LD_INT 30
25699: PUSH
25700: LD_INT 3
25702: PUSH
25703: EMPTY
25704: LIST
25705: LIST
25706: PPUSH
25707: CALL_OW 72
25711: ST_TO_ADDR
// if not factories then
25712: LD_VAR 0 6
25716: NOT
25717: IFFALSE 25721
// exit ;
25719: GO 26717
// for i in factories do
25721: LD_ADDR_VAR 0 8
25725: PUSH
25726: LD_VAR 0 6
25730: PUSH
25731: FOR_IN
25732: IFFALSE 25757
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25734: LD_ADDR_VAR 0 17
25738: PUSH
25739: LD_VAR 0 17
25743: PUSH
25744: LD_VAR 0 8
25748: PPUSH
25749: CALL_OW 478
25753: UNION
25754: ST_TO_ADDR
25755: GO 25731
25757: POP
25758: POP
// if not fac_list then
25759: LD_VAR 0 17
25763: NOT
25764: IFFALSE 25768
// exit ;
25766: GO 26717
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25768: LD_ADDR_VAR 0 5
25772: PUSH
25773: LD_INT 4
25775: PUSH
25776: LD_INT 5
25778: PUSH
25779: LD_INT 9
25781: PUSH
25782: LD_INT 10
25784: PUSH
25785: LD_INT 6
25787: PUSH
25788: LD_INT 7
25790: PUSH
25791: LD_INT 11
25793: PUSH
25794: EMPTY
25795: LIST
25796: LIST
25797: LIST
25798: LIST
25799: LIST
25800: LIST
25801: LIST
25802: PUSH
25803: LD_INT 27
25805: PUSH
25806: LD_INT 28
25808: PUSH
25809: LD_INT 26
25811: PUSH
25812: LD_INT 30
25814: PUSH
25815: EMPTY
25816: LIST
25817: LIST
25818: LIST
25819: LIST
25820: PUSH
25821: LD_INT 43
25823: PUSH
25824: LD_INT 44
25826: PUSH
25827: LD_INT 46
25829: PUSH
25830: LD_INT 45
25832: PUSH
25833: LD_INT 47
25835: PUSH
25836: LD_INT 49
25838: PUSH
25839: EMPTY
25840: LIST
25841: LIST
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: PUSH
25847: EMPTY
25848: LIST
25849: LIST
25850: LIST
25851: PUSH
25852: LD_VAR 0 12
25856: ARRAY
25857: ST_TO_ADDR
// for i in list do
25858: LD_ADDR_VAR 0 8
25862: PUSH
25863: LD_VAR 0 5
25867: PUSH
25868: FOR_IN
25869: IFFALSE 25902
// if not i in fac_list then
25871: LD_VAR 0 8
25875: PUSH
25876: LD_VAR 0 17
25880: IN
25881: NOT
25882: IFFALSE 25900
// list := list diff i ;
25884: LD_ADDR_VAR 0 5
25888: PUSH
25889: LD_VAR 0 5
25893: PUSH
25894: LD_VAR 0 8
25898: DIFF
25899: ST_TO_ADDR
25900: GO 25868
25902: POP
25903: POP
// if not list then
25904: LD_VAR 0 5
25908: NOT
25909: IFFALSE 25913
// exit ;
25911: GO 26717
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25913: LD_VAR 0 12
25917: PUSH
25918: LD_INT 3
25920: EQUAL
25921: PUSH
25922: LD_INT 49
25924: PUSH
25925: LD_VAR 0 5
25929: IN
25930: AND
25931: PUSH
25932: LD_INT 31
25934: PPUSH
25935: LD_VAR 0 16
25939: PPUSH
25940: CALL_OW 321
25944: PUSH
25945: LD_INT 2
25947: EQUAL
25948: AND
25949: IFFALSE 26009
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25951: LD_INT 22
25953: PUSH
25954: LD_VAR 0 16
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: PUSH
25963: LD_INT 35
25965: PUSH
25966: LD_INT 49
25968: PUSH
25969: EMPTY
25970: LIST
25971: LIST
25972: PUSH
25973: LD_INT 91
25975: PUSH
25976: LD_VAR 0 1
25980: PUSH
25981: LD_INT 10
25983: PUSH
25984: EMPTY
25985: LIST
25986: LIST
25987: LIST
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: LIST
25993: PPUSH
25994: CALL_OW 69
25998: NOT
25999: IFFALSE 26009
// weapon := ru_time_lapser ;
26001: LD_ADDR_VAR 0 18
26005: PUSH
26006: LD_INT 49
26008: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26009: LD_VAR 0 12
26013: PUSH
26014: LD_INT 1
26016: PUSH
26017: LD_INT 2
26019: PUSH
26020: EMPTY
26021: LIST
26022: LIST
26023: IN
26024: PUSH
26025: LD_INT 11
26027: PUSH
26028: LD_VAR 0 5
26032: IN
26033: PUSH
26034: LD_INT 30
26036: PUSH
26037: LD_VAR 0 5
26041: IN
26042: OR
26043: AND
26044: PUSH
26045: LD_INT 6
26047: PPUSH
26048: LD_VAR 0 16
26052: PPUSH
26053: CALL_OW 321
26057: PUSH
26058: LD_INT 2
26060: EQUAL
26061: AND
26062: IFFALSE 26227
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26064: LD_INT 22
26066: PUSH
26067: LD_VAR 0 16
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: PUSH
26076: LD_INT 2
26078: PUSH
26079: LD_INT 35
26081: PUSH
26082: LD_INT 11
26084: PUSH
26085: EMPTY
26086: LIST
26087: LIST
26088: PUSH
26089: LD_INT 35
26091: PUSH
26092: LD_INT 30
26094: PUSH
26095: EMPTY
26096: LIST
26097: LIST
26098: PUSH
26099: EMPTY
26100: LIST
26101: LIST
26102: LIST
26103: PUSH
26104: LD_INT 91
26106: PUSH
26107: LD_VAR 0 1
26111: PUSH
26112: LD_INT 18
26114: PUSH
26115: EMPTY
26116: LIST
26117: LIST
26118: LIST
26119: PUSH
26120: EMPTY
26121: LIST
26122: LIST
26123: LIST
26124: PPUSH
26125: CALL_OW 69
26129: NOT
26130: PUSH
26131: LD_INT 22
26133: PUSH
26134: LD_VAR 0 16
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: PUSH
26143: LD_INT 2
26145: PUSH
26146: LD_INT 30
26148: PUSH
26149: LD_INT 32
26151: PUSH
26152: EMPTY
26153: LIST
26154: LIST
26155: PUSH
26156: LD_INT 30
26158: PUSH
26159: LD_INT 33
26161: PUSH
26162: EMPTY
26163: LIST
26164: LIST
26165: PUSH
26166: EMPTY
26167: LIST
26168: LIST
26169: LIST
26170: PUSH
26171: LD_INT 91
26173: PUSH
26174: LD_VAR 0 1
26178: PUSH
26179: LD_INT 12
26181: PUSH
26182: EMPTY
26183: LIST
26184: LIST
26185: LIST
26186: PUSH
26187: EMPTY
26188: LIST
26189: LIST
26190: LIST
26191: PUSH
26192: EMPTY
26193: LIST
26194: PPUSH
26195: CALL_OW 69
26199: PUSH
26200: LD_INT 2
26202: GREATER
26203: AND
26204: IFFALSE 26227
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26206: LD_ADDR_VAR 0 18
26210: PUSH
26211: LD_INT 11
26213: PUSH
26214: LD_INT 30
26216: PUSH
26217: EMPTY
26218: LIST
26219: LIST
26220: PUSH
26221: LD_VAR 0 12
26225: ARRAY
26226: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26227: LD_VAR 0 18
26231: NOT
26232: PUSH
26233: LD_INT 40
26235: PPUSH
26236: LD_VAR 0 16
26240: PPUSH
26241: CALL_OW 321
26245: PUSH
26246: LD_INT 2
26248: EQUAL
26249: AND
26250: PUSH
26251: LD_INT 7
26253: PUSH
26254: LD_VAR 0 5
26258: IN
26259: PUSH
26260: LD_INT 28
26262: PUSH
26263: LD_VAR 0 5
26267: IN
26268: OR
26269: PUSH
26270: LD_INT 45
26272: PUSH
26273: LD_VAR 0 5
26277: IN
26278: OR
26279: AND
26280: IFFALSE 26534
// begin hex := GetHexInfo ( x , y ) ;
26282: LD_ADDR_VAR 0 4
26286: PUSH
26287: LD_VAR 0 10
26291: PPUSH
26292: LD_VAR 0 11
26296: PPUSH
26297: CALL_OW 546
26301: ST_TO_ADDR
// if hex [ 1 ] then
26302: LD_VAR 0 4
26306: PUSH
26307: LD_INT 1
26309: ARRAY
26310: IFFALSE 26314
// exit ;
26312: GO 26717
// height := hex [ 2 ] ;
26314: LD_ADDR_VAR 0 15
26318: PUSH
26319: LD_VAR 0 4
26323: PUSH
26324: LD_INT 2
26326: ARRAY
26327: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26328: LD_ADDR_VAR 0 14
26332: PUSH
26333: LD_INT 0
26335: PUSH
26336: LD_INT 2
26338: PUSH
26339: LD_INT 3
26341: PUSH
26342: LD_INT 5
26344: PUSH
26345: EMPTY
26346: LIST
26347: LIST
26348: LIST
26349: LIST
26350: ST_TO_ADDR
// for i in tmp do
26351: LD_ADDR_VAR 0 8
26355: PUSH
26356: LD_VAR 0 14
26360: PUSH
26361: FOR_IN
26362: IFFALSE 26532
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26364: LD_ADDR_VAR 0 9
26368: PUSH
26369: LD_VAR 0 10
26373: PPUSH
26374: LD_VAR 0 8
26378: PPUSH
26379: LD_INT 5
26381: PPUSH
26382: CALL_OW 272
26386: PUSH
26387: LD_VAR 0 11
26391: PPUSH
26392: LD_VAR 0 8
26396: PPUSH
26397: LD_INT 5
26399: PPUSH
26400: CALL_OW 273
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26409: LD_VAR 0 9
26413: PUSH
26414: LD_INT 1
26416: ARRAY
26417: PPUSH
26418: LD_VAR 0 9
26422: PUSH
26423: LD_INT 2
26425: ARRAY
26426: PPUSH
26427: CALL_OW 488
26431: IFFALSE 26530
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26433: LD_ADDR_VAR 0 4
26437: PUSH
26438: LD_VAR 0 9
26442: PUSH
26443: LD_INT 1
26445: ARRAY
26446: PPUSH
26447: LD_VAR 0 9
26451: PUSH
26452: LD_INT 2
26454: ARRAY
26455: PPUSH
26456: CALL_OW 546
26460: ST_TO_ADDR
// if hex [ 1 ] then
26461: LD_VAR 0 4
26465: PUSH
26466: LD_INT 1
26468: ARRAY
26469: IFFALSE 26473
// continue ;
26471: GO 26361
// h := hex [ 2 ] ;
26473: LD_ADDR_VAR 0 13
26477: PUSH
26478: LD_VAR 0 4
26482: PUSH
26483: LD_INT 2
26485: ARRAY
26486: ST_TO_ADDR
// if h + 7 < height then
26487: LD_VAR 0 13
26491: PUSH
26492: LD_INT 7
26494: PLUS
26495: PUSH
26496: LD_VAR 0 15
26500: LESS
26501: IFFALSE 26530
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26503: LD_ADDR_VAR 0 18
26507: PUSH
26508: LD_INT 7
26510: PUSH
26511: LD_INT 28
26513: PUSH
26514: LD_INT 45
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: LIST
26521: PUSH
26522: LD_VAR 0 12
26526: ARRAY
26527: ST_TO_ADDR
// break ;
26528: GO 26532
// end ; end ; end ;
26530: GO 26361
26532: POP
26533: POP
// end ; if not weapon then
26534: LD_VAR 0 18
26538: NOT
26539: IFFALSE 26599
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26541: LD_ADDR_VAR 0 5
26545: PUSH
26546: LD_VAR 0 5
26550: PUSH
26551: LD_INT 11
26553: PUSH
26554: LD_INT 30
26556: PUSH
26557: LD_INT 49
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: LIST
26564: DIFF
26565: ST_TO_ADDR
// if not list then
26566: LD_VAR 0 5
26570: NOT
26571: IFFALSE 26575
// exit ;
26573: GO 26717
// weapon := list [ rand ( 1 , list ) ] ;
26575: LD_ADDR_VAR 0 18
26579: PUSH
26580: LD_VAR 0 5
26584: PUSH
26585: LD_INT 1
26587: PPUSH
26588: LD_VAR 0 5
26592: PPUSH
26593: CALL_OW 12
26597: ARRAY
26598: ST_TO_ADDR
// end ; if weapon then
26599: LD_VAR 0 18
26603: IFFALSE 26717
// begin tmp := CostOfWeapon ( weapon ) ;
26605: LD_ADDR_VAR 0 14
26609: PUSH
26610: LD_VAR 0 18
26614: PPUSH
26615: CALL_OW 451
26619: ST_TO_ADDR
// j := GetBase ( tower ) ;
26620: LD_ADDR_VAR 0 9
26624: PUSH
26625: LD_VAR 0 1
26629: PPUSH
26630: CALL_OW 274
26634: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26635: LD_VAR 0 9
26639: PPUSH
26640: LD_INT 1
26642: PPUSH
26643: CALL_OW 275
26647: PUSH
26648: LD_VAR 0 14
26652: PUSH
26653: LD_INT 1
26655: ARRAY
26656: GREATEREQUAL
26657: PUSH
26658: LD_VAR 0 9
26662: PPUSH
26663: LD_INT 2
26665: PPUSH
26666: CALL_OW 275
26670: PUSH
26671: LD_VAR 0 14
26675: PUSH
26676: LD_INT 2
26678: ARRAY
26679: GREATEREQUAL
26680: AND
26681: PUSH
26682: LD_VAR 0 9
26686: PPUSH
26687: LD_INT 3
26689: PPUSH
26690: CALL_OW 275
26694: PUSH
26695: LD_VAR 0 14
26699: PUSH
26700: LD_INT 3
26702: ARRAY
26703: GREATEREQUAL
26704: AND
26705: IFFALSE 26717
// result := weapon ;
26707: LD_ADDR_VAR 0 3
26711: PUSH
26712: LD_VAR 0 18
26716: ST_TO_ADDR
// end ; end ;
26717: LD_VAR 0 3
26721: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26722: LD_INT 0
26724: PPUSH
26725: PPUSH
// result := true ;
26726: LD_ADDR_VAR 0 3
26730: PUSH
26731: LD_INT 1
26733: ST_TO_ADDR
// if array1 = array2 then
26734: LD_VAR 0 1
26738: PUSH
26739: LD_VAR 0 2
26743: EQUAL
26744: IFFALSE 26804
// begin for i = 1 to array1 do
26746: LD_ADDR_VAR 0 4
26750: PUSH
26751: DOUBLE
26752: LD_INT 1
26754: DEC
26755: ST_TO_ADDR
26756: LD_VAR 0 1
26760: PUSH
26761: FOR_TO
26762: IFFALSE 26800
// if array1 [ i ] <> array2 [ i ] then
26764: LD_VAR 0 1
26768: PUSH
26769: LD_VAR 0 4
26773: ARRAY
26774: PUSH
26775: LD_VAR 0 2
26779: PUSH
26780: LD_VAR 0 4
26784: ARRAY
26785: NONEQUAL
26786: IFFALSE 26798
// begin result := false ;
26788: LD_ADDR_VAR 0 3
26792: PUSH
26793: LD_INT 0
26795: ST_TO_ADDR
// break ;
26796: GO 26800
// end ;
26798: GO 26761
26800: POP
26801: POP
// end else
26802: GO 26812
// result := false ;
26804: LD_ADDR_VAR 0 3
26808: PUSH
26809: LD_INT 0
26811: ST_TO_ADDR
// end ;
26812: LD_VAR 0 3
26816: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26817: LD_INT 0
26819: PPUSH
26820: PPUSH
26821: PPUSH
// pom := GetBase ( fac ) ;
26822: LD_ADDR_VAR 0 5
26826: PUSH
26827: LD_VAR 0 1
26831: PPUSH
26832: CALL_OW 274
26836: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26837: LD_ADDR_VAR 0 4
26841: PUSH
26842: LD_VAR 0 2
26846: PUSH
26847: LD_INT 1
26849: ARRAY
26850: PPUSH
26851: LD_VAR 0 2
26855: PUSH
26856: LD_INT 2
26858: ARRAY
26859: PPUSH
26860: LD_VAR 0 2
26864: PUSH
26865: LD_INT 3
26867: ARRAY
26868: PPUSH
26869: LD_VAR 0 2
26873: PUSH
26874: LD_INT 4
26876: ARRAY
26877: PPUSH
26878: CALL_OW 449
26882: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26883: LD_ADDR_VAR 0 3
26887: PUSH
26888: LD_VAR 0 5
26892: PPUSH
26893: LD_INT 1
26895: PPUSH
26896: CALL_OW 275
26900: PUSH
26901: LD_VAR 0 4
26905: PUSH
26906: LD_INT 1
26908: ARRAY
26909: GREATEREQUAL
26910: PUSH
26911: LD_VAR 0 5
26915: PPUSH
26916: LD_INT 2
26918: PPUSH
26919: CALL_OW 275
26923: PUSH
26924: LD_VAR 0 4
26928: PUSH
26929: LD_INT 2
26931: ARRAY
26932: GREATEREQUAL
26933: AND
26934: PUSH
26935: LD_VAR 0 5
26939: PPUSH
26940: LD_INT 3
26942: PPUSH
26943: CALL_OW 275
26947: PUSH
26948: LD_VAR 0 4
26952: PUSH
26953: LD_INT 3
26955: ARRAY
26956: GREATEREQUAL
26957: AND
26958: ST_TO_ADDR
// end ;
26959: LD_VAR 0 3
26963: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26964: LD_INT 0
26966: PPUSH
26967: PPUSH
26968: PPUSH
26969: PPUSH
// pom := GetBase ( building ) ;
26970: LD_ADDR_VAR 0 3
26974: PUSH
26975: LD_VAR 0 1
26979: PPUSH
26980: CALL_OW 274
26984: ST_TO_ADDR
// if not pom then
26985: LD_VAR 0 3
26989: NOT
26990: IFFALSE 26994
// exit ;
26992: GO 27164
// btype := GetBType ( building ) ;
26994: LD_ADDR_VAR 0 5
26998: PUSH
26999: LD_VAR 0 1
27003: PPUSH
27004: CALL_OW 266
27008: ST_TO_ADDR
// if btype = b_armoury then
27009: LD_VAR 0 5
27013: PUSH
27014: LD_INT 4
27016: EQUAL
27017: IFFALSE 27027
// btype := b_barracks ;
27019: LD_ADDR_VAR 0 5
27023: PUSH
27024: LD_INT 5
27026: ST_TO_ADDR
// if btype = b_depot then
27027: LD_VAR 0 5
27031: PUSH
27032: LD_INT 0
27034: EQUAL
27035: IFFALSE 27045
// btype := b_warehouse ;
27037: LD_ADDR_VAR 0 5
27041: PUSH
27042: LD_INT 1
27044: ST_TO_ADDR
// if btype = b_workshop then
27045: LD_VAR 0 5
27049: PUSH
27050: LD_INT 2
27052: EQUAL
27053: IFFALSE 27063
// btype := b_factory ;
27055: LD_ADDR_VAR 0 5
27059: PUSH
27060: LD_INT 3
27062: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27063: LD_ADDR_VAR 0 4
27067: PUSH
27068: LD_VAR 0 5
27072: PPUSH
27073: LD_VAR 0 1
27077: PPUSH
27078: CALL_OW 248
27082: PPUSH
27083: CALL_OW 450
27087: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27088: LD_ADDR_VAR 0 2
27092: PUSH
27093: LD_VAR 0 3
27097: PPUSH
27098: LD_INT 1
27100: PPUSH
27101: CALL_OW 275
27105: PUSH
27106: LD_VAR 0 4
27110: PUSH
27111: LD_INT 1
27113: ARRAY
27114: GREATEREQUAL
27115: PUSH
27116: LD_VAR 0 3
27120: PPUSH
27121: LD_INT 2
27123: PPUSH
27124: CALL_OW 275
27128: PUSH
27129: LD_VAR 0 4
27133: PUSH
27134: LD_INT 2
27136: ARRAY
27137: GREATEREQUAL
27138: AND
27139: PUSH
27140: LD_VAR 0 3
27144: PPUSH
27145: LD_INT 3
27147: PPUSH
27148: CALL_OW 275
27152: PUSH
27153: LD_VAR 0 4
27157: PUSH
27158: LD_INT 3
27160: ARRAY
27161: GREATEREQUAL
27162: AND
27163: ST_TO_ADDR
// end ;
27164: LD_VAR 0 2
27168: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27169: LD_INT 0
27171: PPUSH
27172: PPUSH
27173: PPUSH
// pom := GetBase ( building ) ;
27174: LD_ADDR_VAR 0 4
27178: PUSH
27179: LD_VAR 0 1
27183: PPUSH
27184: CALL_OW 274
27188: ST_TO_ADDR
// if not pom then
27189: LD_VAR 0 4
27193: NOT
27194: IFFALSE 27198
// exit ;
27196: GO 27299
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27198: LD_ADDR_VAR 0 5
27202: PUSH
27203: LD_VAR 0 2
27207: PPUSH
27208: LD_VAR 0 1
27212: PPUSH
27213: CALL_OW 248
27217: PPUSH
27218: CALL_OW 450
27222: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27223: LD_ADDR_VAR 0 3
27227: PUSH
27228: LD_VAR 0 4
27232: PPUSH
27233: LD_INT 1
27235: PPUSH
27236: CALL_OW 275
27240: PUSH
27241: LD_VAR 0 5
27245: PUSH
27246: LD_INT 1
27248: ARRAY
27249: GREATEREQUAL
27250: PUSH
27251: LD_VAR 0 4
27255: PPUSH
27256: LD_INT 2
27258: PPUSH
27259: CALL_OW 275
27263: PUSH
27264: LD_VAR 0 5
27268: PUSH
27269: LD_INT 2
27271: ARRAY
27272: GREATEREQUAL
27273: AND
27274: PUSH
27275: LD_VAR 0 4
27279: PPUSH
27280: LD_INT 3
27282: PPUSH
27283: CALL_OW 275
27287: PUSH
27288: LD_VAR 0 5
27292: PUSH
27293: LD_INT 3
27295: ARRAY
27296: GREATEREQUAL
27297: AND
27298: ST_TO_ADDR
// end ;
27299: LD_VAR 0 3
27303: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27304: LD_INT 0
27306: PPUSH
27307: PPUSH
27308: PPUSH
27309: PPUSH
27310: PPUSH
27311: PPUSH
27312: PPUSH
27313: PPUSH
27314: PPUSH
27315: PPUSH
// result := false ;
27316: LD_ADDR_VAR 0 6
27320: PUSH
27321: LD_INT 0
27323: ST_TO_ADDR
// if not base or not btype or not x or not y then
27324: LD_VAR 0 1
27328: NOT
27329: PUSH
27330: LD_VAR 0 2
27334: NOT
27335: OR
27336: PUSH
27337: LD_VAR 0 3
27341: NOT
27342: OR
27343: PUSH
27344: LD_VAR 0 4
27348: NOT
27349: OR
27350: IFFALSE 27354
// exit ;
27352: GO 27945
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27354: LD_ADDR_VAR 0 12
27358: PUSH
27359: LD_VAR 0 2
27363: PPUSH
27364: LD_VAR 0 3
27368: PPUSH
27369: LD_VAR 0 4
27373: PPUSH
27374: LD_VAR 0 5
27378: PPUSH
27379: LD_VAR 0 1
27383: PUSH
27384: LD_INT 1
27386: ARRAY
27387: PPUSH
27388: CALL_OW 248
27392: PPUSH
27393: LD_INT 0
27395: PPUSH
27396: CALL 28782 0 6
27400: ST_TO_ADDR
// if not hexes then
27401: LD_VAR 0 12
27405: NOT
27406: IFFALSE 27410
// exit ;
27408: GO 27945
// for i = 1 to hexes do
27410: LD_ADDR_VAR 0 7
27414: PUSH
27415: DOUBLE
27416: LD_INT 1
27418: DEC
27419: ST_TO_ADDR
27420: LD_VAR 0 12
27424: PUSH
27425: FOR_TO
27426: IFFALSE 27943
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27428: LD_ADDR_VAR 0 11
27432: PUSH
27433: LD_VAR 0 12
27437: PUSH
27438: LD_VAR 0 7
27442: ARRAY
27443: PUSH
27444: LD_INT 1
27446: ARRAY
27447: PPUSH
27448: LD_VAR 0 12
27452: PUSH
27453: LD_VAR 0 7
27457: ARRAY
27458: PUSH
27459: LD_INT 2
27461: ARRAY
27462: PPUSH
27463: CALL_OW 428
27467: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27468: LD_VAR 0 12
27472: PUSH
27473: LD_VAR 0 7
27477: ARRAY
27478: PUSH
27479: LD_INT 1
27481: ARRAY
27482: PPUSH
27483: LD_VAR 0 12
27487: PUSH
27488: LD_VAR 0 7
27492: ARRAY
27493: PUSH
27494: LD_INT 2
27496: ARRAY
27497: PPUSH
27498: CALL_OW 351
27502: PUSH
27503: LD_VAR 0 12
27507: PUSH
27508: LD_VAR 0 7
27512: ARRAY
27513: PUSH
27514: LD_INT 1
27516: ARRAY
27517: PPUSH
27518: LD_VAR 0 12
27522: PUSH
27523: LD_VAR 0 7
27527: ARRAY
27528: PUSH
27529: LD_INT 2
27531: ARRAY
27532: PPUSH
27533: CALL_OW 488
27537: NOT
27538: OR
27539: PUSH
27540: LD_VAR 0 11
27544: PPUSH
27545: CALL_OW 247
27549: PUSH
27550: LD_INT 3
27552: EQUAL
27553: OR
27554: IFFALSE 27560
// exit ;
27556: POP
27557: POP
27558: GO 27945
// if not tmp then
27560: LD_VAR 0 11
27564: NOT
27565: IFFALSE 27569
// continue ;
27567: GO 27425
// result := true ;
27569: LD_ADDR_VAR 0 6
27573: PUSH
27574: LD_INT 1
27576: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27577: LD_ADDR_VAR 0 15
27581: PUSH
27582: LD_INT 22
27584: PUSH
27585: LD_VAR 0 11
27589: PPUSH
27590: CALL_OW 255
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 2
27601: PUSH
27602: LD_INT 30
27604: PUSH
27605: LD_INT 0
27607: PUSH
27608: EMPTY
27609: LIST
27610: LIST
27611: PUSH
27612: LD_INT 30
27614: PUSH
27615: LD_INT 1
27617: PUSH
27618: EMPTY
27619: LIST
27620: LIST
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: LIST
27626: PUSH
27627: EMPTY
27628: LIST
27629: LIST
27630: PPUSH
27631: CALL_OW 69
27635: ST_TO_ADDR
// if dep then
27636: LD_VAR 0 15
27640: IFFALSE 27776
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27642: LD_ADDR_VAR 0 14
27646: PUSH
27647: LD_VAR 0 15
27651: PUSH
27652: LD_INT 1
27654: ARRAY
27655: PPUSH
27656: CALL_OW 250
27660: PPUSH
27661: LD_VAR 0 15
27665: PUSH
27666: LD_INT 1
27668: ARRAY
27669: PPUSH
27670: CALL_OW 254
27674: PPUSH
27675: LD_INT 5
27677: PPUSH
27678: CALL_OW 272
27682: PUSH
27683: LD_VAR 0 15
27687: PUSH
27688: LD_INT 1
27690: ARRAY
27691: PPUSH
27692: CALL_OW 251
27696: PPUSH
27697: LD_VAR 0 15
27701: PUSH
27702: LD_INT 1
27704: ARRAY
27705: PPUSH
27706: CALL_OW 254
27710: PPUSH
27711: LD_INT 5
27713: PPUSH
27714: CALL_OW 273
27718: PUSH
27719: EMPTY
27720: LIST
27721: LIST
27722: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27723: LD_VAR 0 14
27727: PUSH
27728: LD_INT 1
27730: ARRAY
27731: PPUSH
27732: LD_VAR 0 14
27736: PUSH
27737: LD_INT 2
27739: ARRAY
27740: PPUSH
27741: CALL_OW 488
27745: IFFALSE 27776
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27747: LD_VAR 0 11
27751: PPUSH
27752: LD_VAR 0 14
27756: PUSH
27757: LD_INT 1
27759: ARRAY
27760: PPUSH
27761: LD_VAR 0 14
27765: PUSH
27766: LD_INT 2
27768: ARRAY
27769: PPUSH
27770: CALL_OW 111
// continue ;
27774: GO 27425
// end ; end ; r := GetDir ( tmp ) ;
27776: LD_ADDR_VAR 0 13
27780: PUSH
27781: LD_VAR 0 11
27785: PPUSH
27786: CALL_OW 254
27790: ST_TO_ADDR
// if r = 5 then
27791: LD_VAR 0 13
27795: PUSH
27796: LD_INT 5
27798: EQUAL
27799: IFFALSE 27809
// r := 0 ;
27801: LD_ADDR_VAR 0 13
27805: PUSH
27806: LD_INT 0
27808: ST_TO_ADDR
// for j = r to 5 do
27809: LD_ADDR_VAR 0 8
27813: PUSH
27814: DOUBLE
27815: LD_VAR 0 13
27819: DEC
27820: ST_TO_ADDR
27821: LD_INT 5
27823: PUSH
27824: FOR_TO
27825: IFFALSE 27939
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27827: LD_ADDR_VAR 0 9
27831: PUSH
27832: LD_VAR 0 11
27836: PPUSH
27837: CALL_OW 250
27841: PPUSH
27842: LD_VAR 0 8
27846: PPUSH
27847: LD_INT 2
27849: PPUSH
27850: CALL_OW 272
27854: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27855: LD_ADDR_VAR 0 10
27859: PUSH
27860: LD_VAR 0 11
27864: PPUSH
27865: CALL_OW 251
27869: PPUSH
27870: LD_VAR 0 8
27874: PPUSH
27875: LD_INT 2
27877: PPUSH
27878: CALL_OW 273
27882: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27883: LD_VAR 0 9
27887: PPUSH
27888: LD_VAR 0 10
27892: PPUSH
27893: CALL_OW 488
27897: PUSH
27898: LD_VAR 0 9
27902: PPUSH
27903: LD_VAR 0 10
27907: PPUSH
27908: CALL_OW 428
27912: NOT
27913: AND
27914: IFFALSE 27937
// begin ComMoveXY ( tmp , _x , _y ) ;
27916: LD_VAR 0 11
27920: PPUSH
27921: LD_VAR 0 9
27925: PPUSH
27926: LD_VAR 0 10
27930: PPUSH
27931: CALL_OW 111
// break ;
27935: GO 27939
// end ; end ;
27937: GO 27824
27939: POP
27940: POP
// end ;
27941: GO 27425
27943: POP
27944: POP
// end ;
27945: LD_VAR 0 6
27949: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27950: LD_INT 0
27952: PPUSH
27953: PPUSH
27954: PPUSH
27955: PPUSH
27956: PPUSH
27957: PPUSH
27958: PPUSH
27959: PPUSH
27960: PPUSH
27961: PPUSH
// result := false ;
27962: LD_ADDR_VAR 0 6
27966: PUSH
27967: LD_INT 0
27969: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27970: LD_VAR 0 1
27974: NOT
27975: PUSH
27976: LD_VAR 0 1
27980: PPUSH
27981: CALL_OW 266
27985: PUSH
27986: LD_INT 0
27988: PUSH
27989: LD_INT 1
27991: PUSH
27992: EMPTY
27993: LIST
27994: LIST
27995: IN
27996: NOT
27997: OR
27998: PUSH
27999: LD_VAR 0 2
28003: NOT
28004: OR
28005: PUSH
28006: LD_VAR 0 5
28010: PUSH
28011: LD_INT 0
28013: PUSH
28014: LD_INT 1
28016: PUSH
28017: LD_INT 2
28019: PUSH
28020: LD_INT 3
28022: PUSH
28023: LD_INT 4
28025: PUSH
28026: LD_INT 5
28028: PUSH
28029: EMPTY
28030: LIST
28031: LIST
28032: LIST
28033: LIST
28034: LIST
28035: LIST
28036: IN
28037: NOT
28038: OR
28039: PUSH
28040: LD_VAR 0 3
28044: PPUSH
28045: LD_VAR 0 4
28049: PPUSH
28050: CALL_OW 488
28054: NOT
28055: OR
28056: IFFALSE 28060
// exit ;
28058: GO 28777
// pom := GetBase ( bdepot ) ;
28060: LD_ADDR_VAR 0 10
28064: PUSH
28065: LD_VAR 0 1
28069: PPUSH
28070: CALL_OW 274
28074: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
28075: LD_ADDR_VAR 0 11
28079: PUSH
28080: LD_VAR 0 2
28084: PPUSH
28085: LD_VAR 0 1
28089: PPUSH
28090: CALL_OW 248
28094: PPUSH
28095: CALL_OW 450
28099: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28100: LD_VAR 0 10
28104: PPUSH
28105: LD_INT 1
28107: PPUSH
28108: CALL_OW 275
28112: PUSH
28113: LD_VAR 0 11
28117: PUSH
28118: LD_INT 1
28120: ARRAY
28121: GREATEREQUAL
28122: PUSH
28123: LD_VAR 0 10
28127: PPUSH
28128: LD_INT 2
28130: PPUSH
28131: CALL_OW 275
28135: PUSH
28136: LD_VAR 0 11
28140: PUSH
28141: LD_INT 2
28143: ARRAY
28144: GREATEREQUAL
28145: AND
28146: PUSH
28147: LD_VAR 0 10
28151: PPUSH
28152: LD_INT 3
28154: PPUSH
28155: CALL_OW 275
28159: PUSH
28160: LD_VAR 0 11
28164: PUSH
28165: LD_INT 3
28167: ARRAY
28168: GREATEREQUAL
28169: AND
28170: NOT
28171: IFFALSE 28175
// exit ;
28173: GO 28777
// if GetBType ( bdepot ) = b_depot then
28175: LD_VAR 0 1
28179: PPUSH
28180: CALL_OW 266
28184: PUSH
28185: LD_INT 0
28187: EQUAL
28188: IFFALSE 28200
// dist := 28 else
28190: LD_ADDR_VAR 0 14
28194: PUSH
28195: LD_INT 28
28197: ST_TO_ADDR
28198: GO 28208
// dist := 36 ;
28200: LD_ADDR_VAR 0 14
28204: PUSH
28205: LD_INT 36
28207: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
28208: LD_VAR 0 1
28212: PPUSH
28213: LD_VAR 0 3
28217: PPUSH
28218: LD_VAR 0 4
28222: PPUSH
28223: CALL_OW 297
28227: PUSH
28228: LD_VAR 0 14
28232: GREATER
28233: IFFALSE 28237
// exit ;
28235: GO 28777
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
28237: LD_ADDR_VAR 0 12
28241: PUSH
28242: LD_VAR 0 2
28246: PPUSH
28247: LD_VAR 0 3
28251: PPUSH
28252: LD_VAR 0 4
28256: PPUSH
28257: LD_VAR 0 5
28261: PPUSH
28262: LD_VAR 0 1
28266: PPUSH
28267: CALL_OW 248
28271: PPUSH
28272: LD_INT 0
28274: PPUSH
28275: CALL 28782 0 6
28279: ST_TO_ADDR
// if not hexes then
28280: LD_VAR 0 12
28284: NOT
28285: IFFALSE 28289
// exit ;
28287: GO 28777
// hex := GetHexInfo ( x , y ) ;
28289: LD_ADDR_VAR 0 15
28293: PUSH
28294: LD_VAR 0 3
28298: PPUSH
28299: LD_VAR 0 4
28303: PPUSH
28304: CALL_OW 546
28308: ST_TO_ADDR
// if hex [ 1 ] then
28309: LD_VAR 0 15
28313: PUSH
28314: LD_INT 1
28316: ARRAY
28317: IFFALSE 28321
// exit ;
28319: GO 28777
// height := hex [ 2 ] ;
28321: LD_ADDR_VAR 0 13
28325: PUSH
28326: LD_VAR 0 15
28330: PUSH
28331: LD_INT 2
28333: ARRAY
28334: ST_TO_ADDR
// for i = 1 to hexes do
28335: LD_ADDR_VAR 0 7
28339: PUSH
28340: DOUBLE
28341: LD_INT 1
28343: DEC
28344: ST_TO_ADDR
28345: LD_VAR 0 12
28349: PUSH
28350: FOR_TO
28351: IFFALSE 28681
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28353: LD_VAR 0 12
28357: PUSH
28358: LD_VAR 0 7
28362: ARRAY
28363: PUSH
28364: LD_INT 1
28366: ARRAY
28367: PPUSH
28368: LD_VAR 0 12
28372: PUSH
28373: LD_VAR 0 7
28377: ARRAY
28378: PUSH
28379: LD_INT 2
28381: ARRAY
28382: PPUSH
28383: CALL_OW 488
28387: NOT
28388: PUSH
28389: LD_VAR 0 12
28393: PUSH
28394: LD_VAR 0 7
28398: ARRAY
28399: PUSH
28400: LD_INT 1
28402: ARRAY
28403: PPUSH
28404: LD_VAR 0 12
28408: PUSH
28409: LD_VAR 0 7
28413: ARRAY
28414: PUSH
28415: LD_INT 2
28417: ARRAY
28418: PPUSH
28419: CALL_OW 428
28423: PUSH
28424: LD_INT 0
28426: GREATER
28427: OR
28428: PUSH
28429: LD_VAR 0 12
28433: PUSH
28434: LD_VAR 0 7
28438: ARRAY
28439: PUSH
28440: LD_INT 1
28442: ARRAY
28443: PPUSH
28444: LD_VAR 0 12
28448: PUSH
28449: LD_VAR 0 7
28453: ARRAY
28454: PUSH
28455: LD_INT 2
28457: ARRAY
28458: PPUSH
28459: CALL_OW 351
28463: OR
28464: IFFALSE 28470
// exit ;
28466: POP
28467: POP
28468: GO 28777
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28470: LD_ADDR_VAR 0 8
28474: PUSH
28475: LD_VAR 0 12
28479: PUSH
28480: LD_VAR 0 7
28484: ARRAY
28485: PUSH
28486: LD_INT 1
28488: ARRAY
28489: PPUSH
28490: LD_VAR 0 12
28494: PUSH
28495: LD_VAR 0 7
28499: ARRAY
28500: PUSH
28501: LD_INT 2
28503: ARRAY
28504: PPUSH
28505: CALL_OW 546
28509: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28510: LD_VAR 0 8
28514: PUSH
28515: LD_INT 1
28517: ARRAY
28518: PUSH
28519: LD_VAR 0 8
28523: PUSH
28524: LD_INT 2
28526: ARRAY
28527: PUSH
28528: LD_VAR 0 13
28532: PUSH
28533: LD_INT 2
28535: PLUS
28536: GREATER
28537: OR
28538: PUSH
28539: LD_VAR 0 8
28543: PUSH
28544: LD_INT 2
28546: ARRAY
28547: PUSH
28548: LD_VAR 0 13
28552: PUSH
28553: LD_INT 2
28555: MINUS
28556: LESS
28557: OR
28558: PUSH
28559: LD_VAR 0 8
28563: PUSH
28564: LD_INT 3
28566: ARRAY
28567: PUSH
28568: LD_INT 0
28570: PUSH
28571: LD_INT 8
28573: PUSH
28574: LD_INT 9
28576: PUSH
28577: LD_INT 10
28579: PUSH
28580: LD_INT 11
28582: PUSH
28583: LD_INT 12
28585: PUSH
28586: LD_INT 13
28588: PUSH
28589: LD_INT 16
28591: PUSH
28592: LD_INT 17
28594: PUSH
28595: LD_INT 18
28597: PUSH
28598: LD_INT 19
28600: PUSH
28601: LD_INT 20
28603: PUSH
28604: LD_INT 21
28606: PUSH
28607: EMPTY
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: IN
28622: NOT
28623: OR
28624: PUSH
28625: LD_VAR 0 8
28629: PUSH
28630: LD_INT 5
28632: ARRAY
28633: NOT
28634: OR
28635: PUSH
28636: LD_VAR 0 8
28640: PUSH
28641: LD_INT 6
28643: ARRAY
28644: PUSH
28645: LD_INT 1
28647: PUSH
28648: LD_INT 2
28650: PUSH
28651: LD_INT 7
28653: PUSH
28654: LD_INT 9
28656: PUSH
28657: LD_INT 10
28659: PUSH
28660: LD_INT 11
28662: PUSH
28663: EMPTY
28664: LIST
28665: LIST
28666: LIST
28667: LIST
28668: LIST
28669: LIST
28670: IN
28671: NOT
28672: OR
28673: IFFALSE 28679
// exit ;
28675: POP
28676: POP
28677: GO 28777
// end ;
28679: GO 28350
28681: POP
28682: POP
// side := GetSide ( bdepot ) ;
28683: LD_ADDR_VAR 0 9
28687: PUSH
28688: LD_VAR 0 1
28692: PPUSH
28693: CALL_OW 255
28697: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28698: LD_VAR 0 9
28702: PPUSH
28703: LD_VAR 0 3
28707: PPUSH
28708: LD_VAR 0 4
28712: PPUSH
28713: LD_INT 20
28715: PPUSH
28716: CALL 21449 0 4
28720: PUSH
28721: LD_INT 4
28723: ARRAY
28724: IFFALSE 28728
// exit ;
28726: GO 28777
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28728: LD_VAR 0 2
28732: PUSH
28733: LD_INT 29
28735: PUSH
28736: LD_INT 30
28738: PUSH
28739: EMPTY
28740: LIST
28741: LIST
28742: IN
28743: PUSH
28744: LD_VAR 0 3
28748: PPUSH
28749: LD_VAR 0 4
28753: PPUSH
28754: LD_VAR 0 9
28758: PPUSH
28759: CALL_OW 440
28763: NOT
28764: AND
28765: IFFALSE 28769
// exit ;
28767: GO 28777
// result := true ;
28769: LD_ADDR_VAR 0 6
28773: PUSH
28774: LD_INT 1
28776: ST_TO_ADDR
// end ;
28777: LD_VAR 0 6
28781: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28782: LD_INT 0
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
28793: PPUSH
28794: PPUSH
28795: PPUSH
28796: PPUSH
28797: PPUSH
28798: PPUSH
28799: PPUSH
28800: PPUSH
28801: PPUSH
28802: PPUSH
28803: PPUSH
28804: PPUSH
28805: PPUSH
28806: PPUSH
28807: PPUSH
28808: PPUSH
28809: PPUSH
28810: PPUSH
28811: PPUSH
28812: PPUSH
28813: PPUSH
28814: PPUSH
28815: PPUSH
28816: PPUSH
28817: PPUSH
28818: PPUSH
28819: PPUSH
28820: PPUSH
28821: PPUSH
28822: PPUSH
28823: PPUSH
28824: PPUSH
28825: PPUSH
28826: PPUSH
28827: PPUSH
28828: PPUSH
28829: PPUSH
28830: PPUSH
28831: PPUSH
28832: PPUSH
28833: PPUSH
28834: PPUSH
28835: PPUSH
28836: PPUSH
28837: PPUSH
28838: PPUSH
28839: PPUSH
28840: PPUSH
28841: PPUSH
// result = [ ] ;
28842: LD_ADDR_VAR 0 7
28846: PUSH
28847: EMPTY
28848: ST_TO_ADDR
// temp_list = [ ] ;
28849: LD_ADDR_VAR 0 9
28853: PUSH
28854: EMPTY
28855: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28856: LD_VAR 0 4
28860: PUSH
28861: LD_INT 0
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: LD_INT 2
28869: PUSH
28870: LD_INT 3
28872: PUSH
28873: LD_INT 4
28875: PUSH
28876: LD_INT 5
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: LIST
28883: LIST
28884: LIST
28885: LIST
28886: IN
28887: NOT
28888: PUSH
28889: LD_VAR 0 1
28893: PUSH
28894: LD_INT 0
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: IN
28904: PUSH
28905: LD_VAR 0 5
28909: PUSH
28910: LD_INT 1
28912: PUSH
28913: LD_INT 2
28915: PUSH
28916: LD_INT 3
28918: PUSH
28919: EMPTY
28920: LIST
28921: LIST
28922: LIST
28923: IN
28924: NOT
28925: AND
28926: OR
28927: IFFALSE 28931
// exit ;
28929: GO 47316
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28931: LD_VAR 0 1
28935: PUSH
28936: LD_INT 6
28938: PUSH
28939: LD_INT 7
28941: PUSH
28942: LD_INT 8
28944: PUSH
28945: LD_INT 13
28947: PUSH
28948: LD_INT 12
28950: PUSH
28951: LD_INT 15
28953: PUSH
28954: LD_INT 11
28956: PUSH
28957: LD_INT 14
28959: PUSH
28960: LD_INT 10
28962: PUSH
28963: EMPTY
28964: LIST
28965: LIST
28966: LIST
28967: LIST
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: IN
28974: IFFALSE 28984
// btype = b_lab ;
28976: LD_ADDR_VAR 0 1
28980: PUSH
28981: LD_INT 6
28983: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28984: LD_VAR 0 6
28988: PUSH
28989: LD_INT 0
28991: PUSH
28992: LD_INT 1
28994: PUSH
28995: LD_INT 2
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: LIST
29002: IN
29003: NOT
29004: PUSH
29005: LD_VAR 0 1
29009: PUSH
29010: LD_INT 0
29012: PUSH
29013: LD_INT 1
29015: PUSH
29016: LD_INT 2
29018: PUSH
29019: LD_INT 3
29021: PUSH
29022: LD_INT 6
29024: PUSH
29025: LD_INT 36
29027: PUSH
29028: LD_INT 4
29030: PUSH
29031: LD_INT 5
29033: PUSH
29034: LD_INT 31
29036: PUSH
29037: LD_INT 32
29039: PUSH
29040: LD_INT 33
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: LIST
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: IN
29056: NOT
29057: PUSH
29058: LD_VAR 0 6
29062: PUSH
29063: LD_INT 1
29065: EQUAL
29066: AND
29067: OR
29068: PUSH
29069: LD_VAR 0 1
29073: PUSH
29074: LD_INT 2
29076: PUSH
29077: LD_INT 3
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: IN
29084: NOT
29085: PUSH
29086: LD_VAR 0 6
29090: PUSH
29091: LD_INT 2
29093: EQUAL
29094: AND
29095: OR
29096: IFFALSE 29106
// mode = 0 ;
29098: LD_ADDR_VAR 0 6
29102: PUSH
29103: LD_INT 0
29105: ST_TO_ADDR
// case mode of 0 :
29106: LD_VAR 0 6
29110: PUSH
29111: LD_INT 0
29113: DOUBLE
29114: EQUAL
29115: IFTRUE 29119
29117: GO 40572
29119: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29120: LD_ADDR_VAR 0 11
29124: PUSH
29125: LD_INT 0
29127: PUSH
29128: LD_INT 0
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 0
29137: PUSH
29138: LD_INT 1
29140: NEG
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 1
29148: PUSH
29149: LD_INT 0
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: PUSH
29159: LD_INT 1
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 0
29168: PUSH
29169: LD_INT 1
29171: PUSH
29172: EMPTY
29173: LIST
29174: LIST
29175: PUSH
29176: LD_INT 1
29178: NEG
29179: PUSH
29180: LD_INT 0
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 1
29189: NEG
29190: PUSH
29191: LD_INT 1
29193: NEG
29194: PUSH
29195: EMPTY
29196: LIST
29197: LIST
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: LD_INT 2
29205: NEG
29206: PUSH
29207: EMPTY
29208: LIST
29209: LIST
29210: PUSH
29211: LD_INT 0
29213: PUSH
29214: LD_INT 2
29216: NEG
29217: PUSH
29218: EMPTY
29219: LIST
29220: LIST
29221: PUSH
29222: LD_INT 1
29224: PUSH
29225: LD_INT 1
29227: NEG
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: LD_INT 1
29235: PUSH
29236: LD_INT 2
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: PUSH
29243: LD_INT 0
29245: PUSH
29246: LD_INT 2
29248: PUSH
29249: EMPTY
29250: LIST
29251: LIST
29252: PUSH
29253: LD_INT 1
29255: NEG
29256: PUSH
29257: LD_INT 1
29259: PUSH
29260: EMPTY
29261: LIST
29262: LIST
29263: PUSH
29264: LD_INT 1
29266: PUSH
29267: LD_INT 3
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 0
29276: PUSH
29277: LD_INT 3
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 1
29286: NEG
29287: PUSH
29288: LD_INT 2
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: LIST
29299: LIST
29300: LIST
29301: LIST
29302: LIST
29303: LIST
29304: LIST
29305: LIST
29306: LIST
29307: LIST
29308: LIST
29309: LIST
29310: LIST
29311: LIST
29312: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29313: LD_ADDR_VAR 0 12
29317: PUSH
29318: LD_INT 0
29320: PUSH
29321: LD_INT 0
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: PUSH
29328: LD_INT 0
29330: PUSH
29331: LD_INT 1
29333: NEG
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: LD_INT 1
29341: PUSH
29342: LD_INT 0
29344: PUSH
29345: EMPTY
29346: LIST
29347: LIST
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: LD_INT 1
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 0
29361: PUSH
29362: LD_INT 1
29364: PUSH
29365: EMPTY
29366: LIST
29367: LIST
29368: PUSH
29369: LD_INT 1
29371: NEG
29372: PUSH
29373: LD_INT 0
29375: PUSH
29376: EMPTY
29377: LIST
29378: LIST
29379: PUSH
29380: LD_INT 1
29382: NEG
29383: PUSH
29384: LD_INT 1
29386: NEG
29387: PUSH
29388: EMPTY
29389: LIST
29390: LIST
29391: PUSH
29392: LD_INT 1
29394: PUSH
29395: LD_INT 1
29397: NEG
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 2
29405: PUSH
29406: LD_INT 0
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 2
29415: PUSH
29416: LD_INT 1
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 1
29425: NEG
29426: PUSH
29427: LD_INT 1
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 2
29436: NEG
29437: PUSH
29438: LD_INT 0
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: PUSH
29445: LD_INT 2
29447: NEG
29448: PUSH
29449: LD_INT 1
29451: NEG
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: LD_INT 2
29459: NEG
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 3
29470: NEG
29471: PUSH
29472: LD_INT 0
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 3
29481: NEG
29482: PUSH
29483: LD_INT 1
29485: NEG
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: LIST
29495: LIST
29496: LIST
29497: LIST
29498: LIST
29499: LIST
29500: LIST
29501: LIST
29502: LIST
29503: LIST
29504: LIST
29505: LIST
29506: LIST
29507: LIST
29508: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29509: LD_ADDR_VAR 0 13
29513: PUSH
29514: LD_INT 0
29516: PUSH
29517: LD_INT 0
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 0
29526: PUSH
29527: LD_INT 1
29529: NEG
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: LD_INT 0
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: PUSH
29548: LD_INT 1
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 0
29557: PUSH
29558: LD_INT 1
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: LD_INT 1
29567: NEG
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 1
29578: NEG
29579: PUSH
29580: LD_INT 1
29582: NEG
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PUSH
29588: LD_INT 1
29590: NEG
29591: PUSH
29592: LD_INT 2
29594: NEG
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PUSH
29600: LD_INT 2
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: LD_INT 2
29612: PUSH
29613: LD_INT 2
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: LD_INT 2
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 2
29632: NEG
29633: PUSH
29634: LD_INT 1
29636: NEG
29637: PUSH
29638: EMPTY
29639: LIST
29640: LIST
29641: PUSH
29642: LD_INT 2
29644: NEG
29645: PUSH
29646: LD_INT 2
29648: NEG
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: LD_INT 3
29660: NEG
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: PUSH
29666: LD_INT 3
29668: NEG
29669: PUSH
29670: LD_INT 2
29672: NEG
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 3
29680: NEG
29681: PUSH
29682: LD_INT 3
29684: NEG
29685: PUSH
29686: EMPTY
29687: LIST
29688: LIST
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: LIST
29707: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29708: LD_ADDR_VAR 0 14
29712: PUSH
29713: LD_INT 0
29715: PUSH
29716: LD_INT 0
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 0
29725: PUSH
29726: LD_INT 1
29728: NEG
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 1
29736: PUSH
29737: LD_INT 0
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: LD_INT 1
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: LD_INT 1
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 0
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: NEG
29778: PUSH
29779: LD_INT 1
29781: NEG
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: LD_INT 2
29804: NEG
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 1
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 1
29823: PUSH
29824: LD_INT 2
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 0
29833: PUSH
29834: LD_INT 2
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 1
29843: NEG
29844: PUSH
29845: LD_INT 1
29847: PUSH
29848: EMPTY
29849: LIST
29850: LIST
29851: PUSH
29852: LD_INT 1
29854: NEG
29855: PUSH
29856: LD_INT 3
29858: NEG
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: PUSH
29864: LD_INT 0
29866: PUSH
29867: LD_INT 3
29869: NEG
29870: PUSH
29871: EMPTY
29872: LIST
29873: LIST
29874: PUSH
29875: LD_INT 1
29877: PUSH
29878: LD_INT 2
29880: NEG
29881: PUSH
29882: EMPTY
29883: LIST
29884: LIST
29885: PUSH
29886: EMPTY
29887: LIST
29888: LIST
29889: LIST
29890: LIST
29891: LIST
29892: LIST
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: LIST
29903: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29904: LD_ADDR_VAR 0 15
29908: PUSH
29909: LD_INT 0
29911: PUSH
29912: LD_INT 0
29914: PUSH
29915: EMPTY
29916: LIST
29917: LIST
29918: PUSH
29919: LD_INT 0
29921: PUSH
29922: LD_INT 1
29924: NEG
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 1
29932: PUSH
29933: LD_INT 0
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 1
29942: PUSH
29943: LD_INT 1
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: LD_INT 1
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 0
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 1
29973: NEG
29974: PUSH
29975: LD_INT 1
29977: NEG
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 1
29985: PUSH
29986: LD_INT 1
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 2
29996: PUSH
29997: LD_INT 0
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 2
30006: PUSH
30007: LD_INT 1
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: LD_INT 1
30016: NEG
30017: PUSH
30018: LD_INT 1
30020: PUSH
30021: EMPTY
30022: LIST
30023: LIST
30024: PUSH
30025: LD_INT 2
30027: NEG
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: NEG
30039: PUSH
30040: LD_INT 1
30042: NEG
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: PUSH
30048: LD_INT 2
30050: PUSH
30051: LD_INT 1
30053: NEG
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 3
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 3
30071: PUSH
30072: LD_INT 1
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: LIST
30088: LIST
30089: LIST
30090: LIST
30091: LIST
30092: LIST
30093: LIST
30094: LIST
30095: LIST
30096: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30097: LD_ADDR_VAR 0 16
30101: PUSH
30102: LD_INT 0
30104: PUSH
30105: LD_INT 0
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 0
30114: PUSH
30115: LD_INT 1
30117: NEG
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 1
30125: PUSH
30126: LD_INT 0
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: LD_INT 1
30138: PUSH
30139: EMPTY
30140: LIST
30141: LIST
30142: PUSH
30143: LD_INT 0
30145: PUSH
30146: LD_INT 1
30148: PUSH
30149: EMPTY
30150: LIST
30151: LIST
30152: PUSH
30153: LD_INT 1
30155: NEG
30156: PUSH
30157: LD_INT 0
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 1
30166: NEG
30167: PUSH
30168: LD_INT 1
30170: NEG
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 1
30178: NEG
30179: PUSH
30180: LD_INT 2
30182: NEG
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 2
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: LD_INT 2
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: PUSH
30211: LD_INT 2
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 2
30220: NEG
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: LD_INT 2
30232: NEG
30233: PUSH
30234: LD_INT 2
30236: NEG
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 3
30244: PUSH
30245: LD_INT 2
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 3
30254: PUSH
30255: LD_INT 3
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 2
30264: PUSH
30265: LD_INT 3
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: LIST
30276: LIST
30277: LIST
30278: LIST
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: LIST
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30290: LD_ADDR_VAR 0 17
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: LD_INT 0
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 0
30307: PUSH
30308: LD_INT 1
30310: NEG
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 1
30318: PUSH
30319: LD_INT 0
30321: PUSH
30322: EMPTY
30323: LIST
30324: LIST
30325: PUSH
30326: LD_INT 1
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 0
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: EMPTY
30343: LIST
30344: LIST
30345: PUSH
30346: LD_INT 1
30348: NEG
30349: PUSH
30350: LD_INT 0
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 1
30359: NEG
30360: PUSH
30361: LD_INT 1
30363: NEG
30364: PUSH
30365: EMPTY
30366: LIST
30367: LIST
30368: PUSH
30369: LD_INT 1
30371: NEG
30372: PUSH
30373: LD_INT 2
30375: NEG
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 0
30383: PUSH
30384: LD_INT 2
30386: NEG
30387: PUSH
30388: EMPTY
30389: LIST
30390: LIST
30391: PUSH
30392: LD_INT 1
30394: PUSH
30395: LD_INT 1
30397: NEG
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 2
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 2
30415: PUSH
30416: LD_INT 1
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 2
30425: PUSH
30426: LD_INT 2
30428: PUSH
30429: EMPTY
30430: LIST
30431: LIST
30432: PUSH
30433: LD_INT 1
30435: PUSH
30436: LD_INT 2
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: LD_INT 2
30448: PUSH
30449: EMPTY
30450: LIST
30451: LIST
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: LD_INT 1
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 2
30466: NEG
30467: PUSH
30468: LD_INT 0
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 2
30477: NEG
30478: PUSH
30479: LD_INT 1
30481: NEG
30482: PUSH
30483: EMPTY
30484: LIST
30485: LIST
30486: PUSH
30487: LD_INT 2
30489: NEG
30490: PUSH
30491: LD_INT 2
30493: NEG
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: LIST
30503: LIST
30504: LIST
30505: LIST
30506: LIST
30507: LIST
30508: LIST
30509: LIST
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30520: LD_ADDR_VAR 0 18
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: LD_INT 0
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 0
30537: PUSH
30538: LD_INT 1
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 1
30548: PUSH
30549: LD_INT 0
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 1
30558: PUSH
30559: LD_INT 1
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 0
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 1
30578: NEG
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 1
30589: NEG
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 1
30601: NEG
30602: PUSH
30603: LD_INT 2
30605: NEG
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 0
30613: PUSH
30614: LD_INT 2
30616: NEG
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 1
30624: PUSH
30625: LD_INT 1
30627: NEG
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 2
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: LD_INT 2
30645: PUSH
30646: LD_INT 1
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 2
30655: PUSH
30656: LD_INT 2
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 1
30665: PUSH
30666: LD_INT 2
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: LD_INT 2
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 1
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PUSH
30694: LD_INT 2
30696: NEG
30697: PUSH
30698: LD_INT 0
30700: PUSH
30701: EMPTY
30702: LIST
30703: LIST
30704: PUSH
30705: LD_INT 2
30707: NEG
30708: PUSH
30709: LD_INT 1
30711: NEG
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 2
30719: NEG
30720: PUSH
30721: LD_INT 2
30723: NEG
30724: PUSH
30725: EMPTY
30726: LIST
30727: LIST
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: LIST
30735: LIST
30736: LIST
30737: LIST
30738: LIST
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: LIST
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30750: LD_ADDR_VAR 0 19
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: LD_INT 0
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: PUSH
30779: LD_INT 0
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 1
30788: PUSH
30789: LD_INT 1
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 0
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 1
30808: NEG
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 1
30819: NEG
30820: PUSH
30821: LD_INT 1
30823: NEG
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 1
30831: NEG
30832: PUSH
30833: LD_INT 2
30835: NEG
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: LD_INT 2
30846: NEG
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 1
30854: PUSH
30855: LD_INT 1
30857: NEG
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 2
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: LD_INT 1
30878: PUSH
30879: EMPTY
30880: LIST
30881: LIST
30882: PUSH
30883: LD_INT 2
30885: PUSH
30886: LD_INT 2
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 1
30895: PUSH
30896: LD_INT 2
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: LD_INT 2
30908: PUSH
30909: EMPTY
30910: LIST
30911: LIST
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: LD_INT 1
30919: PUSH
30920: EMPTY
30921: LIST
30922: LIST
30923: PUSH
30924: LD_INT 2
30926: NEG
30927: PUSH
30928: LD_INT 0
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: PUSH
30935: LD_INT 2
30937: NEG
30938: PUSH
30939: LD_INT 1
30941: NEG
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 2
30949: NEG
30950: PUSH
30951: LD_INT 2
30953: NEG
30954: PUSH
30955: EMPTY
30956: LIST
30957: LIST
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: LIST
30963: LIST
30964: LIST
30965: LIST
30966: LIST
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30980: LD_ADDR_VAR 0 20
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: LD_INT 0
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 1
31008: PUSH
31009: LD_INT 0
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 1
31018: PUSH
31019: LD_INT 1
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 0
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 1
31038: NEG
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 1
31049: NEG
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: LD_INT 2
31065: NEG
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: LD_INT 2
31076: NEG
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 1
31084: PUSH
31085: LD_INT 1
31087: NEG
31088: PUSH
31089: EMPTY
31090: LIST
31091: LIST
31092: PUSH
31093: LD_INT 2
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: PUSH
31106: LD_INT 1
31108: PUSH
31109: EMPTY
31110: LIST
31111: LIST
31112: PUSH
31113: LD_INT 2
31115: PUSH
31116: LD_INT 2
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 1
31125: PUSH
31126: LD_INT 2
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: LD_INT 2
31138: PUSH
31139: EMPTY
31140: LIST
31141: LIST
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: LD_INT 1
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PUSH
31154: LD_INT 2
31156: NEG
31157: PUSH
31158: LD_INT 0
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 2
31167: NEG
31168: PUSH
31169: LD_INT 1
31171: NEG
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 2
31179: NEG
31180: PUSH
31181: LD_INT 2
31183: NEG
31184: PUSH
31185: EMPTY
31186: LIST
31187: LIST
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31210: LD_ADDR_VAR 0 21
31214: PUSH
31215: LD_INT 0
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 1
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 1
31248: PUSH
31249: LD_INT 1
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 0
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 1
31268: NEG
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 1
31279: NEG
31280: PUSH
31281: LD_INT 1
31283: NEG
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: LD_INT 2
31295: NEG
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: LD_INT 0
31303: PUSH
31304: LD_INT 2
31306: NEG
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 1
31314: PUSH
31315: LD_INT 1
31317: NEG
31318: PUSH
31319: EMPTY
31320: LIST
31321: LIST
31322: PUSH
31323: LD_INT 2
31325: PUSH
31326: LD_INT 0
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 2
31335: PUSH
31336: LD_INT 1
31338: PUSH
31339: EMPTY
31340: LIST
31341: LIST
31342: PUSH
31343: LD_INT 2
31345: PUSH
31346: LD_INT 2
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 1
31355: PUSH
31356: LD_INT 2
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 0
31365: PUSH
31366: LD_INT 2
31368: PUSH
31369: EMPTY
31370: LIST
31371: LIST
31372: PUSH
31373: LD_INT 1
31375: NEG
31376: PUSH
31377: LD_INT 1
31379: PUSH
31380: EMPTY
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: NEG
31387: PUSH
31388: LD_INT 0
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 2
31397: NEG
31398: PUSH
31399: LD_INT 1
31401: NEG
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 2
31409: NEG
31410: PUSH
31411: LD_INT 2
31413: NEG
31414: PUSH
31415: EMPTY
31416: LIST
31417: LIST
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: LIST
31423: LIST
31424: LIST
31425: LIST
31426: LIST
31427: LIST
31428: LIST
31429: LIST
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31440: LD_ADDR_VAR 0 22
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: LD_INT 0
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: PUSH
31479: LD_INT 1
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: LD_INT 0
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 1
31498: NEG
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 1
31509: NEG
31510: PUSH
31511: LD_INT 1
31513: NEG
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 1
31521: NEG
31522: PUSH
31523: LD_INT 2
31525: NEG
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 0
31533: PUSH
31534: LD_INT 2
31536: NEG
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 1
31544: PUSH
31545: LD_INT 1
31547: NEG
31548: PUSH
31549: EMPTY
31550: LIST
31551: LIST
31552: PUSH
31553: LD_INT 2
31555: PUSH
31556: LD_INT 0
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 2
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 2
31575: PUSH
31576: LD_INT 2
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 1
31585: PUSH
31586: LD_INT 2
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 0
31595: PUSH
31596: LD_INT 2
31598: PUSH
31599: EMPTY
31600: LIST
31601: LIST
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: EMPTY
31611: LIST
31612: LIST
31613: PUSH
31614: LD_INT 2
31616: NEG
31617: PUSH
31618: LD_INT 0
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: PUSH
31625: LD_INT 2
31627: NEG
31628: PUSH
31629: LD_INT 1
31631: NEG
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: NEG
31640: PUSH
31641: LD_INT 2
31643: NEG
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31670: LD_ADDR_VAR 0 23
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: LD_INT 0
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: PUSH
31696: LD_INT 1
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 1
31708: PUSH
31709: LD_INT 1
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: LD_INT 0
31718: PUSH
31719: LD_INT 1
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 1
31728: NEG
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 1
31739: NEG
31740: PUSH
31741: LD_INT 1
31743: NEG
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 1
31751: NEG
31752: PUSH
31753: LD_INT 2
31755: NEG
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: LD_INT 0
31763: PUSH
31764: LD_INT 2
31766: NEG
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: LD_INT 1
31777: NEG
31778: PUSH
31779: EMPTY
31780: LIST
31781: LIST
31782: PUSH
31783: LD_INT 2
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 2
31795: PUSH
31796: LD_INT 1
31798: PUSH
31799: EMPTY
31800: LIST
31801: LIST
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: LD_INT 2
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 1
31815: PUSH
31816: LD_INT 2
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 0
31825: PUSH
31826: LD_INT 2
31828: PUSH
31829: EMPTY
31830: LIST
31831: LIST
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: LD_INT 1
31839: PUSH
31840: EMPTY
31841: LIST
31842: LIST
31843: PUSH
31844: LD_INT 2
31846: NEG
31847: PUSH
31848: LD_INT 0
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: LD_INT 2
31857: NEG
31858: PUSH
31859: LD_INT 1
31861: NEG
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 2
31869: NEG
31870: PUSH
31871: LD_INT 2
31873: NEG
31874: PUSH
31875: EMPTY
31876: LIST
31877: LIST
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: LD_INT 3
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: NEG
31894: PUSH
31895: LD_INT 3
31897: NEG
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 1
31905: PUSH
31906: LD_INT 2
31908: NEG
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 2
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31950: LD_ADDR_VAR 0 24
31954: PUSH
31955: LD_INT 0
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: EMPTY
31962: LIST
31963: LIST
31964: PUSH
31965: LD_INT 0
31967: PUSH
31968: LD_INT 1
31970: NEG
31971: PUSH
31972: EMPTY
31973: LIST
31974: LIST
31975: PUSH
31976: LD_INT 1
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 1
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 0
31998: PUSH
31999: LD_INT 1
32001: PUSH
32002: EMPTY
32003: LIST
32004: LIST
32005: PUSH
32006: LD_INT 1
32008: NEG
32009: PUSH
32010: LD_INT 0
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 1
32019: NEG
32020: PUSH
32021: LD_INT 1
32023: NEG
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 0
32043: PUSH
32044: LD_INT 2
32046: NEG
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: LD_INT 1
32054: PUSH
32055: LD_INT 1
32057: NEG
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: PUSH
32063: LD_INT 2
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 2
32075: PUSH
32076: LD_INT 1
32078: PUSH
32079: EMPTY
32080: LIST
32081: LIST
32082: PUSH
32083: LD_INT 2
32085: PUSH
32086: LD_INT 2
32088: PUSH
32089: EMPTY
32090: LIST
32091: LIST
32092: PUSH
32093: LD_INT 1
32095: PUSH
32096: LD_INT 2
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 0
32105: PUSH
32106: LD_INT 2
32108: PUSH
32109: EMPTY
32110: LIST
32111: LIST
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 2
32126: NEG
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: LD_INT 1
32141: NEG
32142: PUSH
32143: EMPTY
32144: LIST
32145: LIST
32146: PUSH
32147: LD_INT 2
32149: NEG
32150: PUSH
32151: LD_INT 2
32153: NEG
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 1
32161: PUSH
32162: LD_INT 2
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 2
32172: PUSH
32173: LD_INT 1
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 3
32183: PUSH
32184: LD_INT 1
32186: PUSH
32187: EMPTY
32188: LIST
32189: LIST
32190: PUSH
32191: LD_INT 3
32193: PUSH
32194: LD_INT 2
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: LIST
32217: LIST
32218: LIST
32219: LIST
32220: LIST
32221: LIST
32222: LIST
32223: LIST
32224: LIST
32225: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32226: LD_ADDR_VAR 0 25
32230: PUSH
32231: LD_INT 0
32233: PUSH
32234: LD_INT 0
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 0
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: LD_INT 0
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: LD_INT 1
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 0
32274: PUSH
32275: LD_INT 1
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 1
32284: NEG
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 1
32295: NEG
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: EMPTY
32302: LIST
32303: LIST
32304: PUSH
32305: LD_INT 1
32307: NEG
32308: PUSH
32309: LD_INT 2
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: LD_INT 2
32322: NEG
32323: PUSH
32324: EMPTY
32325: LIST
32326: LIST
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: LD_INT 1
32333: NEG
32334: PUSH
32335: EMPTY
32336: LIST
32337: LIST
32338: PUSH
32339: LD_INT 2
32341: PUSH
32342: LD_INT 0
32344: PUSH
32345: EMPTY
32346: LIST
32347: LIST
32348: PUSH
32349: LD_INT 2
32351: PUSH
32352: LD_INT 1
32354: PUSH
32355: EMPTY
32356: LIST
32357: LIST
32358: PUSH
32359: LD_INT 2
32361: PUSH
32362: LD_INT 2
32364: PUSH
32365: EMPTY
32366: LIST
32367: LIST
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: LD_INT 2
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 0
32381: PUSH
32382: LD_INT 2
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 1
32391: NEG
32392: PUSH
32393: LD_INT 1
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 2
32402: NEG
32403: PUSH
32404: LD_INT 0
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 2
32413: NEG
32414: PUSH
32415: LD_INT 1
32417: NEG
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: LD_INT 2
32429: NEG
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 3
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 3
32447: PUSH
32448: LD_INT 2
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 2
32457: PUSH
32458: LD_INT 3
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 1
32467: PUSH
32468: LD_INT 3
32470: PUSH
32471: EMPTY
32472: LIST
32473: LIST
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32500: LD_ADDR_VAR 0 26
32504: PUSH
32505: LD_INT 0
32507: PUSH
32508: LD_INT 0
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 0
32517: PUSH
32518: LD_INT 1
32520: NEG
32521: PUSH
32522: EMPTY
32523: LIST
32524: LIST
32525: PUSH
32526: LD_INT 1
32528: PUSH
32529: LD_INT 0
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: PUSH
32539: LD_INT 1
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 0
32548: PUSH
32549: LD_INT 1
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 1
32558: NEG
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 1
32569: NEG
32570: PUSH
32571: LD_INT 1
32573: NEG
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 1
32581: NEG
32582: PUSH
32583: LD_INT 2
32585: NEG
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: PUSH
32591: LD_INT 0
32593: PUSH
32594: LD_INT 2
32596: NEG
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 1
32604: PUSH
32605: LD_INT 1
32607: NEG
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 2
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: LD_INT 2
32625: PUSH
32626: LD_INT 1
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 2
32635: PUSH
32636: LD_INT 2
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 1
32645: PUSH
32646: LD_INT 2
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 0
32655: PUSH
32656: LD_INT 2
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: LD_INT 1
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 2
32676: NEG
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 2
32687: NEG
32688: PUSH
32689: LD_INT 1
32691: NEG
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 2
32699: NEG
32700: PUSH
32701: LD_INT 2
32703: NEG
32704: PUSH
32705: EMPTY
32706: LIST
32707: LIST
32708: PUSH
32709: LD_INT 2
32711: PUSH
32712: LD_INT 3
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 1
32721: PUSH
32722: LD_INT 3
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: PUSH
32729: LD_INT 1
32731: NEG
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: LD_INT 1
32746: PUSH
32747: EMPTY
32748: LIST
32749: LIST
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: LIST
32773: LIST
32774: LIST
32775: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32776: LD_ADDR_VAR 0 27
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: LD_INT 0
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 0
32793: PUSH
32794: LD_INT 1
32796: NEG
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: LD_INT 1
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 0
32824: PUSH
32825: LD_INT 1
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 1
32834: NEG
32835: PUSH
32836: LD_INT 0
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 1
32845: NEG
32846: PUSH
32847: LD_INT 1
32849: NEG
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 0
32869: PUSH
32870: LD_INT 2
32872: NEG
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 1
32880: PUSH
32881: LD_INT 1
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 2
32891: PUSH
32892: LD_INT 0
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 2
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: LD_INT 2
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 2
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: LD_INT 2
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: LD_INT 1
32945: PUSH
32946: EMPTY
32947: LIST
32948: LIST
32949: PUSH
32950: LD_INT 2
32952: NEG
32953: PUSH
32954: LD_INT 0
32956: PUSH
32957: EMPTY
32958: LIST
32959: LIST
32960: PUSH
32961: LD_INT 2
32963: NEG
32964: PUSH
32965: LD_INT 1
32967: NEG
32968: PUSH
32969: EMPTY
32970: LIST
32971: LIST
32972: PUSH
32973: LD_INT 2
32975: NEG
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: PUSH
32985: LD_INT 1
32987: NEG
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 2
32998: NEG
32999: PUSH
33000: LD_INT 1
33002: PUSH
33003: EMPTY
33004: LIST
33005: LIST
33006: PUSH
33007: LD_INT 3
33009: NEG
33010: PUSH
33011: LD_INT 1
33013: NEG
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 3
33021: NEG
33022: PUSH
33023: LD_INT 2
33025: NEG
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33056: LD_ADDR_VAR 0 28
33060: PUSH
33061: LD_INT 0
33063: PUSH
33064: LD_INT 0
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: LD_INT 0
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: PUSH
33082: LD_INT 1
33084: PUSH
33085: LD_INT 0
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 1
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 0
33104: PUSH
33105: LD_INT 1
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 1
33114: NEG
33115: PUSH
33116: LD_INT 0
33118: PUSH
33119: EMPTY
33120: LIST
33121: LIST
33122: PUSH
33123: LD_INT 1
33125: NEG
33126: PUSH
33127: LD_INT 1
33129: NEG
33130: PUSH
33131: EMPTY
33132: LIST
33133: LIST
33134: PUSH
33135: LD_INT 1
33137: NEG
33138: PUSH
33139: LD_INT 2
33141: NEG
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 0
33149: PUSH
33150: LD_INT 2
33152: NEG
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: LD_INT 1
33163: NEG
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 2
33171: PUSH
33172: LD_INT 0
33174: PUSH
33175: EMPTY
33176: LIST
33177: LIST
33178: PUSH
33179: LD_INT 2
33181: PUSH
33182: LD_INT 1
33184: PUSH
33185: EMPTY
33186: LIST
33187: LIST
33188: PUSH
33189: LD_INT 2
33191: PUSH
33192: LD_INT 2
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 1
33201: PUSH
33202: LD_INT 2
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 0
33211: PUSH
33212: LD_INT 2
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 2
33232: NEG
33233: PUSH
33234: LD_INT 0
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 2
33243: NEG
33244: PUSH
33245: LD_INT 1
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: LD_INT 2
33255: NEG
33256: PUSH
33257: LD_INT 2
33259: NEG
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: LD_INT 3
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 1
33279: NEG
33280: PUSH
33281: LD_INT 3
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 3
33291: NEG
33292: PUSH
33293: LD_INT 1
33295: NEG
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 3
33303: NEG
33304: PUSH
33305: LD_INT 2
33307: NEG
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: EMPTY
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: LIST
33337: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33338: LD_ADDR_VAR 0 29
33342: PUSH
33343: LD_INT 0
33345: PUSH
33346: LD_INT 0
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: LD_INT 1
33358: NEG
33359: PUSH
33360: EMPTY
33361: LIST
33362: LIST
33363: PUSH
33364: LD_INT 1
33366: PUSH
33367: LD_INT 0
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 1
33376: PUSH
33377: LD_INT 1
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 0
33386: PUSH
33387: LD_INT 1
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: PUSH
33394: LD_INT 1
33396: NEG
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: LD_INT 1
33411: NEG
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 1
33419: NEG
33420: PUSH
33421: LD_INT 2
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 0
33431: PUSH
33432: LD_INT 2
33434: NEG
33435: PUSH
33436: EMPTY
33437: LIST
33438: LIST
33439: PUSH
33440: LD_INT 1
33442: PUSH
33443: LD_INT 1
33445: NEG
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 2
33453: PUSH
33454: LD_INT 0
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 2
33463: PUSH
33464: LD_INT 1
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 1
33473: PUSH
33474: LD_INT 2
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 0
33483: PUSH
33484: LD_INT 2
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: LD_INT 1
33493: NEG
33494: PUSH
33495: LD_INT 1
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 2
33504: NEG
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 2
33516: NEG
33517: PUSH
33518: LD_INT 2
33520: NEG
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 2
33528: NEG
33529: PUSH
33530: LD_INT 3
33532: NEG
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 2
33540: PUSH
33541: LD_INT 1
33543: NEG
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 3
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 3
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 1
33571: NEG
33572: PUSH
33573: LD_INT 2
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 3
33582: NEG
33583: PUSH
33584: LD_INT 2
33586: NEG
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: EMPTY
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: LIST
33615: LIST
33616: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33617: LD_ADDR_VAR 0 30
33621: PUSH
33622: LD_INT 0
33624: PUSH
33625: LD_INT 0
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 0
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 1
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 1
33655: PUSH
33656: LD_INT 1
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 0
33665: PUSH
33666: LD_INT 1
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 1
33675: NEG
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 1
33686: NEG
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: EMPTY
33693: LIST
33694: LIST
33695: PUSH
33696: LD_INT 1
33698: NEG
33699: PUSH
33700: LD_INT 2
33702: NEG
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: LD_INT 2
33713: NEG
33714: PUSH
33715: EMPTY
33716: LIST
33717: LIST
33718: PUSH
33719: LD_INT 1
33721: PUSH
33722: LD_INT 1
33724: NEG
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 2
33732: PUSH
33733: LD_INT 0
33735: PUSH
33736: EMPTY
33737: LIST
33738: LIST
33739: PUSH
33740: LD_INT 2
33742: PUSH
33743: LD_INT 1
33745: PUSH
33746: EMPTY
33747: LIST
33748: LIST
33749: PUSH
33750: LD_INT 2
33752: PUSH
33753: LD_INT 2
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 1
33762: PUSH
33763: LD_INT 2
33765: PUSH
33766: EMPTY
33767: LIST
33768: LIST
33769: PUSH
33770: LD_INT 1
33772: NEG
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 2
33783: NEG
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: NEG
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: EMPTY
33801: LIST
33802: LIST
33803: PUSH
33804: LD_INT 1
33806: NEG
33807: PUSH
33808: LD_INT 3
33810: NEG
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: PUSH
33819: LD_INT 2
33821: NEG
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 3
33829: PUSH
33830: LD_INT 2
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: PUSH
33837: LD_INT 2
33839: PUSH
33840: LD_INT 3
33842: PUSH
33843: EMPTY
33844: LIST
33845: LIST
33846: PUSH
33847: LD_INT 2
33849: NEG
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 3
33860: NEG
33861: PUSH
33862: LD_INT 1
33864: NEG
33865: PUSH
33866: EMPTY
33867: LIST
33868: LIST
33869: PUSH
33870: EMPTY
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: LIST
33890: LIST
33891: LIST
33892: LIST
33893: LIST
33894: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33895: LD_ADDR_VAR 0 31
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: LD_INT 0
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: LD_INT 1
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: PUSH
33924: LD_INT 0
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 1
33933: PUSH
33934: LD_INT 1
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 0
33943: PUSH
33944: LD_INT 1
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 1
33953: NEG
33954: PUSH
33955: LD_INT 0
33957: PUSH
33958: EMPTY
33959: LIST
33960: LIST
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: LD_INT 1
33968: NEG
33969: PUSH
33970: EMPTY
33971: LIST
33972: LIST
33973: PUSH
33974: LD_INT 1
33976: NEG
33977: PUSH
33978: LD_INT 2
33980: NEG
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: LD_INT 1
33991: NEG
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 2
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 2
34009: PUSH
34010: LD_INT 1
34012: PUSH
34013: EMPTY
34014: LIST
34015: LIST
34016: PUSH
34017: LD_INT 2
34019: PUSH
34020: LD_INT 2
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: LD_INT 2
34032: PUSH
34033: EMPTY
34034: LIST
34035: LIST
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: LD_INT 2
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 1
34049: NEG
34050: PUSH
34051: LD_INT 1
34053: PUSH
34054: EMPTY
34055: LIST
34056: LIST
34057: PUSH
34058: LD_INT 2
34060: NEG
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 2
34072: NEG
34073: PUSH
34074: LD_INT 2
34076: NEG
34077: PUSH
34078: EMPTY
34079: LIST
34080: LIST
34081: PUSH
34082: LD_INT 2
34084: NEG
34085: PUSH
34086: LD_INT 3
34088: NEG
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: PUSH
34094: LD_INT 2
34096: PUSH
34097: LD_INT 1
34099: NEG
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 3
34107: PUSH
34108: LD_INT 1
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: PUSH
34115: LD_INT 1
34117: PUSH
34118: LD_INT 3
34120: PUSH
34121: EMPTY
34122: LIST
34123: LIST
34124: PUSH
34125: LD_INT 1
34127: NEG
34128: PUSH
34129: LD_INT 2
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 3
34138: NEG
34139: PUSH
34140: LD_INT 2
34142: NEG
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: LIST
34172: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34173: LD_ADDR_VAR 0 32
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: LD_INT 0
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 0
34190: PUSH
34191: LD_INT 1
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: PUSH
34202: LD_INT 0
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 1
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 0
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 1
34231: NEG
34232: PUSH
34233: LD_INT 0
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 1
34254: NEG
34255: PUSH
34256: LD_INT 2
34258: NEG
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: LD_INT 2
34269: NEG
34270: PUSH
34271: EMPTY
34272: LIST
34273: LIST
34274: PUSH
34275: LD_INT 1
34277: PUSH
34278: LD_INT 1
34280: NEG
34281: PUSH
34282: EMPTY
34283: LIST
34284: LIST
34285: PUSH
34286: LD_INT 2
34288: PUSH
34289: LD_INT 1
34291: PUSH
34292: EMPTY
34293: LIST
34294: LIST
34295: PUSH
34296: LD_INT 2
34298: PUSH
34299: LD_INT 2
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: PUSH
34309: LD_INT 2
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: LD_INT 2
34321: PUSH
34322: EMPTY
34323: LIST
34324: LIST
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: LD_INT 1
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: LD_INT 2
34339: NEG
34340: PUSH
34341: LD_INT 0
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 2
34350: NEG
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: EMPTY
34357: LIST
34358: LIST
34359: PUSH
34360: LD_INT 1
34362: NEG
34363: PUSH
34364: LD_INT 3
34366: NEG
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 1
34374: PUSH
34375: LD_INT 2
34377: NEG
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 3
34385: PUSH
34386: LD_INT 2
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 2
34395: PUSH
34396: LD_INT 3
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: PUSH
34403: LD_INT 2
34405: NEG
34406: PUSH
34407: LD_INT 1
34409: PUSH
34410: EMPTY
34411: LIST
34412: LIST
34413: PUSH
34414: LD_INT 3
34416: NEG
34417: PUSH
34418: LD_INT 1
34420: NEG
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: EMPTY
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34451: LD_ADDR_VAR 0 33
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 0
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: LD_INT 1
34471: NEG
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: PUSH
34480: LD_INT 0
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: LD_INT 1
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 0
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: LD_INT 0
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: LD_INT 2
34536: NEG
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: LD_INT 1
34547: NEG
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 2
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: LD_INT 1
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 1
34575: PUSH
34576: LD_INT 2
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 0
34585: PUSH
34586: LD_INT 2
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: LD_INT 1
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 2
34606: NEG
34607: PUSH
34608: LD_INT 0
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: PUSH
34615: LD_INT 2
34617: NEG
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: EMPTY
34624: LIST
34625: LIST
34626: PUSH
34627: LD_INT 2
34629: NEG
34630: PUSH
34631: LD_INT 2
34633: NEG
34634: PUSH
34635: EMPTY
34636: LIST
34637: LIST
34638: PUSH
34639: LD_INT 2
34641: NEG
34642: PUSH
34643: LD_INT 3
34645: NEG
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 2
34653: PUSH
34654: LD_INT 1
34656: NEG
34657: PUSH
34658: EMPTY
34659: LIST
34660: LIST
34661: PUSH
34662: LD_INT 3
34664: PUSH
34665: LD_INT 1
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 1
34674: PUSH
34675: LD_INT 3
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 1
34684: NEG
34685: PUSH
34686: LD_INT 2
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 3
34695: NEG
34696: PUSH
34697: LD_INT 2
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34730: LD_ADDR_VAR 0 34
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: LD_INT 0
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 0
34747: PUSH
34748: LD_INT 1
34750: NEG
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 1
34758: PUSH
34759: LD_INT 0
34761: PUSH
34762: EMPTY
34763: LIST
34764: LIST
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 0
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: NEG
34789: PUSH
34790: LD_INT 0
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 1
34799: NEG
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: PUSH
34809: LD_INT 1
34811: NEG
34812: PUSH
34813: LD_INT 2
34815: NEG
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: PUSH
34821: LD_INT 0
34823: PUSH
34824: LD_INT 2
34826: NEG
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: PUSH
34832: LD_INT 1
34834: PUSH
34835: LD_INT 1
34837: NEG
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 2
34845: PUSH
34846: LD_INT 1
34848: PUSH
34849: EMPTY
34850: LIST
34851: LIST
34852: PUSH
34853: LD_INT 2
34855: PUSH
34856: LD_INT 2
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 1
34865: PUSH
34866: LD_INT 2
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 1
34875: NEG
34876: PUSH
34877: LD_INT 1
34879: PUSH
34880: EMPTY
34881: LIST
34882: LIST
34883: PUSH
34884: LD_INT 2
34886: NEG
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 2
34897: NEG
34898: PUSH
34899: LD_INT 1
34901: NEG
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 2
34909: NEG
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: LD_INT 3
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 1
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 3
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 2
34954: PUSH
34955: LD_INT 3
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 2
34964: NEG
34965: PUSH
34966: LD_INT 1
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 3
34975: NEG
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: LIST
34992: LIST
34993: LIST
34994: LIST
34995: LIST
34996: LIST
34997: LIST
34998: LIST
34999: LIST
35000: LIST
35001: LIST
35002: LIST
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35010: LD_ADDR_VAR 0 35
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: LD_INT 0
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 0
35027: PUSH
35028: LD_INT 1
35030: NEG
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 1
35038: PUSH
35039: LD_INT 0
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: LD_INT 1
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 0
35058: PUSH
35059: LD_INT 1
35061: PUSH
35062: EMPTY
35063: LIST
35064: LIST
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: LD_INT 0
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: LD_INT 1
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 2
35091: PUSH
35092: LD_INT 1
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 2
35101: NEG
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: EMPTY
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35122: LD_ADDR_VAR 0 36
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: LD_INT 0
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: LD_INT 1
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 0
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: NEG
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: NEG
35204: PUSH
35205: LD_INT 2
35207: NEG
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: LD_INT 1
35215: PUSH
35216: LD_INT 2
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35234: LD_ADDR_VAR 0 37
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: LD_INT 1
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: LD_INT 0
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 1
35303: NEG
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 1
35326: NEG
35327: PUSH
35328: LD_INT 1
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35346: LD_ADDR_VAR 0 38
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: LD_INT 0
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: LD_INT 0
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 2
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 2
35437: NEG
35438: PUSH
35439: LD_INT 1
35441: NEG
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35458: LD_ADDR_VAR 0 39
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: NEG
35540: PUSH
35541: LD_INT 2
35543: NEG
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: LD_INT 2
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35570: LD_ADDR_VAR 0 40
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: PUSH
35652: LD_INT 1
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35682: LD_ADDR_VAR 0 41
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 1
35763: NEG
35764: PUSH
35765: LD_INT 2
35767: NEG
35768: PUSH
35769: EMPTY
35770: LIST
35771: LIST
35772: PUSH
35773: LD_INT 1
35775: PUSH
35776: LD_INT 1
35778: NEG
35779: PUSH
35780: EMPTY
35781: LIST
35782: LIST
35783: PUSH
35784: LD_INT 2
35786: PUSH
35787: LD_INT 0
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 2
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 2
35806: PUSH
35807: LD_INT 2
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 1
35816: PUSH
35817: LD_INT 2
35819: PUSH
35820: EMPTY
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: LD_INT 1
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 2
35837: NEG
35838: PUSH
35839: LD_INT 0
35841: PUSH
35842: EMPTY
35843: LIST
35844: LIST
35845: PUSH
35846: LD_INT 2
35848: NEG
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: PUSH
35858: LD_INT 2
35860: NEG
35861: PUSH
35862: LD_INT 2
35864: NEG
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: PUSH
35870: LD_INT 2
35872: NEG
35873: PUSH
35874: LD_INT 3
35876: NEG
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: PUSH
35885: LD_INT 1
35887: NEG
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 3
35895: PUSH
35896: LD_INT 0
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 3
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 3
35915: PUSH
35916: LD_INT 2
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 3
35925: PUSH
35926: LD_INT 3
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 2
35935: PUSH
35936: LD_INT 3
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 2
35945: NEG
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 3
35956: NEG
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 3
35967: NEG
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 3
35979: NEG
35980: PUSH
35981: LD_INT 2
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 3
35991: NEG
35992: PUSH
35993: LD_INT 3
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: LIST
36013: LIST
36014: LIST
36015: LIST
36016: LIST
36017: LIST
36018: LIST
36019: LIST
36020: LIST
36021: LIST
36022: LIST
36023: LIST
36024: LIST
36025: LIST
36026: LIST
36027: LIST
36028: LIST
36029: LIST
36030: LIST
36031: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36032: LD_ADDR_VAR 0 42
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: LD_INT 0
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 0
36049: PUSH
36050: LD_INT 1
36052: NEG
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 1
36060: PUSH
36061: LD_INT 0
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: LD_INT 1
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 0
36080: PUSH
36081: LD_INT 1
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 1
36090: NEG
36091: PUSH
36092: LD_INT 0
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 1
36101: NEG
36102: PUSH
36103: LD_INT 1
36105: NEG
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: NEG
36114: PUSH
36115: LD_INT 2
36117: NEG
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 0
36125: PUSH
36126: LD_INT 2
36128: NEG
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 1
36136: PUSH
36137: LD_INT 1
36139: NEG
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 2
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 2
36157: PUSH
36158: LD_INT 2
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 1
36167: PUSH
36168: LD_INT 2
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 0
36177: PUSH
36178: LD_INT 2
36180: PUSH
36181: EMPTY
36182: LIST
36183: LIST
36184: PUSH
36185: LD_INT 1
36187: NEG
36188: PUSH
36189: LD_INT 1
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 2
36198: NEG
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 2
36210: NEG
36211: PUSH
36212: LD_INT 2
36214: NEG
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 2
36222: NEG
36223: PUSH
36224: LD_INT 3
36226: NEG
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: NEG
36235: PUSH
36236: LD_INT 3
36238: NEG
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: LD_INT 3
36249: NEG
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: LD_INT 2
36260: NEG
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 3
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 3
36278: PUSH
36279: LD_INT 3
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 2
36288: PUSH
36289: LD_INT 3
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 1
36298: PUSH
36299: LD_INT 3
36301: PUSH
36302: EMPTY
36303: LIST
36304: LIST
36305: PUSH
36306: LD_INT 0
36308: PUSH
36309: LD_INT 3
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: PUSH
36316: LD_INT 1
36318: NEG
36319: PUSH
36320: LD_INT 2
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 3
36329: NEG
36330: PUSH
36331: LD_INT 2
36333: NEG
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 3
36341: NEG
36342: PUSH
36343: LD_INT 3
36345: NEG
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: EMPTY
36352: LIST
36353: LIST
36354: LIST
36355: LIST
36356: LIST
36357: LIST
36358: LIST
36359: LIST
36360: LIST
36361: LIST
36362: LIST
36363: LIST
36364: LIST
36365: LIST
36366: LIST
36367: LIST
36368: LIST
36369: LIST
36370: LIST
36371: LIST
36372: LIST
36373: LIST
36374: LIST
36375: LIST
36376: LIST
36377: LIST
36378: LIST
36379: LIST
36380: LIST
36381: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36382: LD_ADDR_VAR 0 43
36386: PUSH
36387: LD_INT 0
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 0
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 1
36420: PUSH
36421: LD_INT 1
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 0
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 1
36440: NEG
36441: PUSH
36442: LD_INT 0
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 1
36451: NEG
36452: PUSH
36453: LD_INT 1
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: LD_INT 2
36467: NEG
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 0
36475: PUSH
36476: LD_INT 2
36478: NEG
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 1
36486: PUSH
36487: LD_INT 1
36489: NEG
36490: PUSH
36491: EMPTY
36492: LIST
36493: LIST
36494: PUSH
36495: LD_INT 2
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 2
36507: PUSH
36508: LD_INT 1
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 1
36517: PUSH
36518: LD_INT 2
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 0
36527: PUSH
36528: LD_INT 2
36530: PUSH
36531: EMPTY
36532: LIST
36533: LIST
36534: PUSH
36535: LD_INT 1
36537: NEG
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 2
36548: NEG
36549: PUSH
36550: LD_INT 0
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 2
36559: NEG
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 1
36571: NEG
36572: PUSH
36573: LD_INT 3
36575: NEG
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: LD_INT 3
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 1
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 2
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 3
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 3
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: LD_INT 3
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: LD_INT 3
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: LD_INT 2
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 2
36667: NEG
36668: PUSH
36669: LD_INT 1
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 3
36678: NEG
36679: PUSH
36680: LD_INT 0
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PUSH
36687: LD_INT 3
36689: NEG
36690: PUSH
36691: LD_INT 1
36693: NEG
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: LIST
36703: LIST
36704: LIST
36705: LIST
36706: LIST
36707: LIST
36708: LIST
36709: LIST
36710: LIST
36711: LIST
36712: LIST
36713: LIST
36714: LIST
36715: LIST
36716: LIST
36717: LIST
36718: LIST
36719: LIST
36720: LIST
36721: LIST
36722: LIST
36723: LIST
36724: LIST
36725: LIST
36726: LIST
36727: LIST
36728: LIST
36729: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36730: LD_ADDR_VAR 0 44
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: LD_INT 0
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 0
36747: PUSH
36748: LD_INT 1
36750: NEG
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 1
36758: PUSH
36759: LD_INT 0
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: PUSH
36769: LD_INT 1
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 0
36778: PUSH
36779: LD_INT 1
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 1
36788: NEG
36789: PUSH
36790: LD_INT 0
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: LD_INT 1
36803: NEG
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 1
36811: NEG
36812: PUSH
36813: LD_INT 2
36815: NEG
36816: PUSH
36817: EMPTY
36818: LIST
36819: LIST
36820: PUSH
36821: LD_INT 1
36823: PUSH
36824: LD_INT 1
36826: NEG
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: LD_INT 2
36834: PUSH
36835: LD_INT 0
36837: PUSH
36838: EMPTY
36839: LIST
36840: LIST
36841: PUSH
36842: LD_INT 2
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 2
36854: PUSH
36855: LD_INT 2
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: LD_INT 1
36864: PUSH
36865: LD_INT 2
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 2
36885: NEG
36886: PUSH
36887: LD_INT 0
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 2
36896: NEG
36897: PUSH
36898: LD_INT 1
36900: NEG
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: LD_INT 2
36908: NEG
36909: PUSH
36910: LD_INT 2
36912: NEG
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 2
36920: NEG
36921: PUSH
36922: LD_INT 3
36924: NEG
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 2
36932: PUSH
36933: LD_INT 1
36935: NEG
36936: PUSH
36937: EMPTY
36938: LIST
36939: LIST
36940: PUSH
36941: LD_INT 3
36943: PUSH
36944: LD_INT 0
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 3
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 3
36963: PUSH
36964: LD_INT 2
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 3
36973: PUSH
36974: LD_INT 3
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 2
36983: PUSH
36984: LD_INT 3
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 2
36993: NEG
36994: PUSH
36995: LD_INT 1
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 3
37004: NEG
37005: PUSH
37006: LD_INT 0
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 3
37015: NEG
37016: PUSH
37017: LD_INT 1
37019: NEG
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 3
37027: NEG
37028: PUSH
37029: LD_INT 2
37031: NEG
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 3
37039: NEG
37040: PUSH
37041: LD_INT 3
37043: NEG
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: LIST
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: LIST
37067: LIST
37068: LIST
37069: LIST
37070: LIST
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37080: LD_ADDR_VAR 0 45
37084: PUSH
37085: LD_INT 0
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 0
37097: PUSH
37098: LD_INT 1
37100: NEG
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: LD_INT 0
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: LD_INT 1
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 0
37128: PUSH
37129: LD_INT 1
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 1
37138: NEG
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 1
37149: NEG
37150: PUSH
37151: LD_INT 1
37153: NEG
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: NEG
37162: PUSH
37163: LD_INT 2
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 0
37173: PUSH
37174: LD_INT 2
37176: NEG
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 1
37184: PUSH
37185: LD_INT 1
37187: NEG
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 2
37195: PUSH
37196: LD_INT 1
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 2
37205: PUSH
37206: LD_INT 2
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 1
37215: PUSH
37216: LD_INT 2
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 0
37225: PUSH
37226: LD_INT 2
37228: PUSH
37229: EMPTY
37230: LIST
37231: LIST
37232: PUSH
37233: LD_INT 1
37235: NEG
37236: PUSH
37237: LD_INT 1
37239: PUSH
37240: EMPTY
37241: LIST
37242: LIST
37243: PUSH
37244: LD_INT 2
37246: NEG
37247: PUSH
37248: LD_INT 1
37250: NEG
37251: PUSH
37252: EMPTY
37253: LIST
37254: LIST
37255: PUSH
37256: LD_INT 2
37258: NEG
37259: PUSH
37260: LD_INT 2
37262: NEG
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 2
37270: NEG
37271: PUSH
37272: LD_INT 3
37274: NEG
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 1
37282: NEG
37283: PUSH
37284: LD_INT 3
37286: NEG
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: LD_INT 3
37297: NEG
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: LD_INT 2
37308: NEG
37309: PUSH
37310: EMPTY
37311: LIST
37312: LIST
37313: PUSH
37314: LD_INT 3
37316: PUSH
37317: LD_INT 2
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 3
37326: PUSH
37327: LD_INT 3
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 2
37336: PUSH
37337: LD_INT 3
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: LD_INT 1
37346: PUSH
37347: LD_INT 3
37349: PUSH
37350: EMPTY
37351: LIST
37352: LIST
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: LD_INT 3
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 1
37366: NEG
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 3
37377: NEG
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 3
37389: NEG
37390: PUSH
37391: LD_INT 3
37393: NEG
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: EMPTY
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: LIST
37413: LIST
37414: LIST
37415: LIST
37416: LIST
37417: LIST
37418: LIST
37419: LIST
37420: LIST
37421: LIST
37422: LIST
37423: LIST
37424: LIST
37425: LIST
37426: LIST
37427: LIST
37428: LIST
37429: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37430: LD_ADDR_VAR 0 46
37434: PUSH
37435: LD_INT 0
37437: PUSH
37438: LD_INT 0
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 0
37447: PUSH
37448: LD_INT 1
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: PUSH
37459: LD_INT 0
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 1
37468: PUSH
37469: LD_INT 1
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 0
37478: PUSH
37479: LD_INT 1
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: NEG
37489: PUSH
37490: LD_INT 0
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 1
37499: NEG
37500: PUSH
37501: LD_INT 1
37503: NEG
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: LD_INT 2
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 0
37523: PUSH
37524: LD_INT 2
37526: NEG
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: LD_INT 1
37537: NEG
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 2
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: LD_INT 2
37555: PUSH
37556: LD_INT 1
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: PUSH
37566: LD_INT 2
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: LD_INT 0
37575: PUSH
37576: LD_INT 2
37578: PUSH
37579: EMPTY
37580: LIST
37581: LIST
37582: PUSH
37583: LD_INT 1
37585: NEG
37586: PUSH
37587: LD_INT 1
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 2
37596: NEG
37597: PUSH
37598: LD_INT 0
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 2
37607: NEG
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: LD_INT 1
37619: NEG
37620: PUSH
37621: LD_INT 3
37623: NEG
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: PUSH
37629: LD_INT 0
37631: PUSH
37632: LD_INT 3
37634: NEG
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 1
37642: PUSH
37643: LD_INT 2
37645: NEG
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 2
37653: PUSH
37654: LD_INT 1
37656: NEG
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 3
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 3
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 3
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 3
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: LD_INT 2
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 2
37715: NEG
37716: PUSH
37717: LD_INT 1
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 3
37726: NEG
37727: PUSH
37728: LD_INT 0
37730: PUSH
37731: EMPTY
37732: LIST
37733: LIST
37734: PUSH
37735: LD_INT 3
37737: NEG
37738: PUSH
37739: LD_INT 1
37741: NEG
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: LIST
37751: LIST
37752: LIST
37753: LIST
37754: LIST
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: LIST
37760: LIST
37761: LIST
37762: LIST
37763: LIST
37764: LIST
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: LIST
37775: LIST
37776: LIST
37777: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37778: LD_ADDR_VAR 0 47
37782: PUSH
37783: LD_INT 0
37785: PUSH
37786: LD_INT 0
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 0
37795: PUSH
37796: LD_INT 1
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 1
37806: PUSH
37807: LD_INT 0
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: LD_INT 1
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 0
37826: PUSH
37827: LD_INT 1
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 1
37836: NEG
37837: PUSH
37838: LD_INT 0
37840: PUSH
37841: EMPTY
37842: LIST
37843: LIST
37844: PUSH
37845: LD_INT 1
37847: NEG
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: LD_INT 2
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 0
37871: PUSH
37872: LD_INT 2
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 1
37882: PUSH
37883: LD_INT 1
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 2
37893: NEG
37894: PUSH
37895: LD_INT 1
37897: NEG
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 2
37905: NEG
37906: PUSH
37907: LD_INT 2
37909: NEG
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37929: LD_ADDR_VAR 0 48
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: LD_INT 0
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 0
37946: PUSH
37947: LD_INT 1
37949: NEG
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 1
37957: PUSH
37958: LD_INT 0
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 1
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 0
37977: PUSH
37978: LD_INT 1
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: NEG
37988: PUSH
37989: LD_INT 0
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 1
37998: NEG
37999: PUSH
38000: LD_INT 1
38002: NEG
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: LD_INT 2
38014: NEG
38015: PUSH
38016: EMPTY
38017: LIST
38018: LIST
38019: PUSH
38020: LD_INT 0
38022: PUSH
38023: LD_INT 2
38025: NEG
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: PUSH
38031: LD_INT 1
38033: PUSH
38034: LD_INT 1
38036: NEG
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: PUSH
38042: LD_INT 2
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 2
38054: PUSH
38055: LD_INT 1
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38076: LD_ADDR_VAR 0 49
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 0
38093: PUSH
38094: LD_INT 1
38096: NEG
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 0
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 1
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 0
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 1
38134: NEG
38135: PUSH
38136: LD_INT 0
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: NEG
38146: PUSH
38147: LD_INT 1
38149: NEG
38150: PUSH
38151: EMPTY
38152: LIST
38153: LIST
38154: PUSH
38155: LD_INT 1
38157: PUSH
38158: LD_INT 1
38160: NEG
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 2
38168: PUSH
38169: LD_INT 0
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 2
38178: PUSH
38179: LD_INT 1
38181: PUSH
38182: EMPTY
38183: LIST
38184: LIST
38185: PUSH
38186: LD_INT 2
38188: PUSH
38189: LD_INT 2
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 1
38198: PUSH
38199: LD_INT 2
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: LIST
38211: LIST
38212: LIST
38213: LIST
38214: LIST
38215: LIST
38216: LIST
38217: LIST
38218: LIST
38219: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38220: LD_ADDR_VAR 0 50
38224: PUSH
38225: LD_INT 0
38227: PUSH
38228: LD_INT 0
38230: PUSH
38231: EMPTY
38232: LIST
38233: LIST
38234: PUSH
38235: LD_INT 0
38237: PUSH
38238: LD_INT 1
38240: NEG
38241: PUSH
38242: EMPTY
38243: LIST
38244: LIST
38245: PUSH
38246: LD_INT 1
38248: PUSH
38249: LD_INT 0
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: LD_INT 1
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: LD_INT 0
38268: PUSH
38269: LD_INT 1
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: LD_INT 0
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: LD_INT 1
38289: NEG
38290: PUSH
38291: LD_INT 1
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 2
38301: PUSH
38302: LD_INT 1
38304: PUSH
38305: EMPTY
38306: LIST
38307: LIST
38308: PUSH
38309: LD_INT 2
38311: PUSH
38312: LD_INT 2
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: PUSH
38322: LD_INT 2
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 0
38331: PUSH
38332: LD_INT 2
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 1
38341: NEG
38342: PUSH
38343: LD_INT 1
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: LIST
38362: LIST
38363: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38364: LD_ADDR_VAR 0 51
38368: PUSH
38369: LD_INT 0
38371: PUSH
38372: LD_INT 0
38374: PUSH
38375: EMPTY
38376: LIST
38377: LIST
38378: PUSH
38379: LD_INT 0
38381: PUSH
38382: LD_INT 1
38384: NEG
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 1
38392: PUSH
38393: LD_INT 0
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 1
38402: PUSH
38403: LD_INT 1
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 0
38412: PUSH
38413: LD_INT 1
38415: PUSH
38416: EMPTY
38417: LIST
38418: LIST
38419: PUSH
38420: LD_INT 1
38422: NEG
38423: PUSH
38424: LD_INT 0
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: NEG
38434: PUSH
38435: LD_INT 1
38437: NEG
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: LD_INT 2
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: LD_INT 1
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 2
38476: NEG
38477: PUSH
38478: LD_INT 0
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 2
38487: NEG
38488: PUSH
38489: LD_INT 1
38491: NEG
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38511: LD_ADDR_VAR 0 52
38515: PUSH
38516: LD_INT 0
38518: PUSH
38519: LD_INT 0
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 0
38528: PUSH
38529: LD_INT 1
38531: NEG
38532: PUSH
38533: EMPTY
38534: LIST
38535: LIST
38536: PUSH
38537: LD_INT 1
38539: PUSH
38540: LD_INT 0
38542: PUSH
38543: EMPTY
38544: LIST
38545: LIST
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: LD_INT 1
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: LD_INT 1
38569: NEG
38570: PUSH
38571: LD_INT 0
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: PUSH
38578: LD_INT 1
38580: NEG
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 1
38592: NEG
38593: PUSH
38594: LD_INT 2
38596: NEG
38597: PUSH
38598: EMPTY
38599: LIST
38600: LIST
38601: PUSH
38602: LD_INT 1
38604: NEG
38605: PUSH
38606: LD_INT 1
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 2
38615: NEG
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 2
38626: NEG
38627: PUSH
38628: LD_INT 1
38630: NEG
38631: PUSH
38632: EMPTY
38633: LIST
38634: LIST
38635: PUSH
38636: LD_INT 2
38638: NEG
38639: PUSH
38640: LD_INT 2
38642: NEG
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: LIST
38652: LIST
38653: LIST
38654: LIST
38655: LIST
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38662: LD_ADDR_VAR 0 53
38666: PUSH
38667: LD_INT 0
38669: PUSH
38670: LD_INT 0
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: PUSH
38677: LD_INT 0
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: PUSH
38691: LD_INT 0
38693: PUSH
38694: EMPTY
38695: LIST
38696: LIST
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: LD_INT 1
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 0
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: EMPTY
38715: LIST
38716: LIST
38717: PUSH
38718: LD_INT 1
38720: NEG
38721: PUSH
38722: LD_INT 0
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: LD_INT 1
38735: NEG
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PUSH
38741: LD_INT 1
38743: NEG
38744: PUSH
38745: LD_INT 2
38747: NEG
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: LD_INT 2
38758: NEG
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: PUSH
38764: LD_INT 1
38766: PUSH
38767: LD_INT 1
38769: NEG
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 2
38777: PUSH
38778: LD_INT 0
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 2
38787: PUSH
38788: LD_INT 1
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 2
38797: PUSH
38798: LD_INT 2
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 1
38807: PUSH
38808: LD_INT 2
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 0
38817: PUSH
38818: LD_INT 2
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 1
38827: NEG
38828: PUSH
38829: LD_INT 1
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 2
38838: NEG
38839: PUSH
38840: LD_INT 0
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: LD_INT 2
38849: NEG
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 2
38861: NEG
38862: PUSH
38863: LD_INT 2
38865: NEG
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38892: LD_ADDR_VAR 0 54
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: LD_INT 0
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 1
38930: PUSH
38931: LD_INT 1
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 0
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 1
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: LD_INT 2
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: LD_INT 2
38988: NEG
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PUSH
38994: LD_INT 1
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: EMPTY
39002: LIST
39003: LIST
39004: PUSH
39005: LD_INT 2
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: EMPTY
39012: LIST
39013: LIST
39014: PUSH
39015: LD_INT 2
39017: PUSH
39018: LD_INT 1
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: LD_INT 2
39027: PUSH
39028: LD_INT 2
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: LD_INT 2
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: LD_INT 2
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 1
39057: NEG
39058: PUSH
39059: LD_INT 1
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 2
39068: NEG
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: PUSH
39077: LD_INT 2
39079: NEG
39080: PUSH
39081: LD_INT 1
39083: NEG
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 2
39091: NEG
39092: PUSH
39093: LD_INT 2
39095: NEG
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: LIST
39105: LIST
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39122: LD_ADDR_VAR 0 55
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: LD_INT 1
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: PUSH
39151: LD_INT 0
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 1
39160: PUSH
39161: LD_INT 1
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 0
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 1
39180: NEG
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 1
39191: NEG
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 1
39203: NEG
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: LD_INT 2
39218: NEG
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: PUSH
39224: LD_INT 1
39226: PUSH
39227: LD_INT 1
39229: NEG
39230: PUSH
39231: EMPTY
39232: LIST
39233: LIST
39234: PUSH
39235: LD_INT 2
39237: PUSH
39238: LD_INT 0
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: PUSH
39245: LD_INT 2
39247: PUSH
39248: LD_INT 1
39250: PUSH
39251: EMPTY
39252: LIST
39253: LIST
39254: PUSH
39255: LD_INT 2
39257: PUSH
39258: LD_INT 2
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 1
39267: PUSH
39268: LD_INT 2
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: LD_INT 2
39280: PUSH
39281: EMPTY
39282: LIST
39283: LIST
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: LD_INT 1
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 2
39298: NEG
39299: PUSH
39300: LD_INT 0
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: LD_INT 2
39309: NEG
39310: PUSH
39311: LD_INT 1
39313: NEG
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 2
39321: NEG
39322: PUSH
39323: LD_INT 2
39325: NEG
39326: PUSH
39327: EMPTY
39328: LIST
39329: LIST
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: LIST
39335: LIST
39336: LIST
39337: LIST
39338: LIST
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39352: LD_ADDR_VAR 0 56
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: LD_INT 0
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 1
39390: PUSH
39391: LD_INT 1
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 0
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 1
39410: NEG
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 1
39421: NEG
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 1
39433: NEG
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 0
39445: PUSH
39446: LD_INT 2
39448: NEG
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 1
39456: PUSH
39457: LD_INT 1
39459: NEG
39460: PUSH
39461: EMPTY
39462: LIST
39463: LIST
39464: PUSH
39465: LD_INT 2
39467: PUSH
39468: LD_INT 0
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 2
39477: PUSH
39478: LD_INT 1
39480: PUSH
39481: EMPTY
39482: LIST
39483: LIST
39484: PUSH
39485: LD_INT 2
39487: PUSH
39488: LD_INT 2
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 1
39497: PUSH
39498: LD_INT 2
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: LD_INT 2
39510: PUSH
39511: EMPTY
39512: LIST
39513: LIST
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: LD_INT 1
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 2
39528: NEG
39529: PUSH
39530: LD_INT 0
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PUSH
39537: LD_INT 2
39539: NEG
39540: PUSH
39541: LD_INT 1
39543: NEG
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 2
39551: NEG
39552: PUSH
39553: LD_INT 2
39555: NEG
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39582: LD_ADDR_VAR 0 57
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: LD_INT 0
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 1
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: PUSH
39618: LD_INT 1
39620: PUSH
39621: LD_INT 1
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 0
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: LD_INT 1
39640: NEG
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 1
39651: NEG
39652: PUSH
39653: LD_INT 1
39655: NEG
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 1
39663: NEG
39664: PUSH
39665: LD_INT 2
39667: NEG
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: LD_INT 0
39675: PUSH
39676: LD_INT 2
39678: NEG
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: LD_INT 1
39689: NEG
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 2
39697: PUSH
39698: LD_INT 0
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 2
39707: PUSH
39708: LD_INT 1
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 2
39717: PUSH
39718: LD_INT 2
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 1
39727: PUSH
39728: LD_INT 2
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 0
39737: PUSH
39738: LD_INT 2
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 1
39747: NEG
39748: PUSH
39749: LD_INT 1
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 2
39758: NEG
39759: PUSH
39760: LD_INT 0
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 2
39769: NEG
39770: PUSH
39771: LD_INT 1
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: NEG
39782: PUSH
39783: LD_INT 2
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: LIST
39796: LIST
39797: LIST
39798: LIST
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: LIST
39809: LIST
39810: LIST
39811: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39812: LD_ADDR_VAR 0 58
39816: PUSH
39817: LD_INT 0
39819: PUSH
39820: LD_INT 0
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: LD_INT 1
39840: PUSH
39841: LD_INT 0
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 1
39850: PUSH
39851: LD_INT 1
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: LD_INT 0
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 1
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 1
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 1
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 0
39905: PUSH
39906: LD_INT 2
39908: NEG
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 2
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 2
39937: PUSH
39938: LD_INT 1
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 2
39947: PUSH
39948: LD_INT 2
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 1
39957: PUSH
39958: LD_INT 2
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 0
39967: PUSH
39968: LD_INT 2
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: LD_INT 1
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: PUSH
39986: LD_INT 2
39988: NEG
39989: PUSH
39990: LD_INT 0
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 2
39999: NEG
40000: PUSH
40001: LD_INT 1
40003: NEG
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 2
40011: NEG
40012: PUSH
40013: LD_INT 2
40015: NEG
40016: PUSH
40017: EMPTY
40018: LIST
40019: LIST
40020: PUSH
40021: EMPTY
40022: LIST
40023: LIST
40024: LIST
40025: LIST
40026: LIST
40027: LIST
40028: LIST
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40042: LD_ADDR_VAR 0 59
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: LD_INT 0
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: LD_INT 1
40062: NEG
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 1
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 1
40080: PUSH
40081: LD_INT 1
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: PUSH
40088: LD_INT 0
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 1
40100: NEG
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 1
40111: NEG
40112: PUSH
40113: LD_INT 1
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: LIST
40125: LIST
40126: LIST
40127: LIST
40128: LIST
40129: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40130: LD_ADDR_VAR 0 60
40134: PUSH
40135: LD_INT 0
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 0
40147: PUSH
40148: LD_INT 1
40150: NEG
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 1
40158: PUSH
40159: LD_INT 0
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 1
40168: PUSH
40169: LD_INT 1
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 0
40178: PUSH
40179: LD_INT 1
40181: PUSH
40182: EMPTY
40183: LIST
40184: LIST
40185: PUSH
40186: LD_INT 1
40188: NEG
40189: PUSH
40190: LD_INT 0
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: NEG
40200: PUSH
40201: LD_INT 1
40203: NEG
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40218: LD_ADDR_VAR 0 61
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 0
40235: PUSH
40236: LD_INT 1
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: NEG
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40306: LD_ADDR_VAR 0 62
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 0
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 0
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 1
40364: NEG
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 1
40375: NEG
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40394: LD_ADDR_VAR 0 63
40398: PUSH
40399: LD_INT 0
40401: PUSH
40402: LD_INT 0
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 0
40411: PUSH
40412: LD_INT 1
40414: NEG
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 1
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: LD_INT 1
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 1
40463: NEG
40464: PUSH
40465: LD_INT 1
40467: NEG
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40482: LD_ADDR_VAR 0 64
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 0
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 1
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 1
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: ST_TO_ADDR
// end ; 1 :
40570: GO 46467
40572: LD_INT 1
40574: DOUBLE
40575: EQUAL
40576: IFTRUE 40580
40578: GO 43203
40580: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40581: LD_ADDR_VAR 0 11
40585: PUSH
40586: LD_INT 1
40588: NEG
40589: PUSH
40590: LD_INT 3
40592: NEG
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: PUSH
40598: LD_INT 0
40600: PUSH
40601: LD_INT 3
40603: NEG
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: LD_INT 2
40614: NEG
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: LIST
40624: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40625: LD_ADDR_VAR 0 12
40629: PUSH
40630: LD_INT 2
40632: PUSH
40633: LD_INT 1
40635: NEG
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: PUSH
40641: LD_INT 3
40643: PUSH
40644: LD_INT 0
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: PUSH
40651: LD_INT 3
40653: PUSH
40654: LD_INT 1
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: LIST
40665: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40666: LD_ADDR_VAR 0 13
40670: PUSH
40671: LD_INT 3
40673: PUSH
40674: LD_INT 2
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 3
40683: PUSH
40684: LD_INT 3
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 2
40693: PUSH
40694: LD_INT 3
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: LIST
40705: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40706: LD_ADDR_VAR 0 14
40710: PUSH
40711: LD_INT 1
40713: PUSH
40714: LD_INT 3
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: LD_INT 3
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: LD_INT 2
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: PUSH
40742: EMPTY
40743: LIST
40744: LIST
40745: LIST
40746: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40747: LD_ADDR_VAR 0 15
40751: PUSH
40752: LD_INT 2
40754: NEG
40755: PUSH
40756: LD_INT 1
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 3
40765: NEG
40766: PUSH
40767: LD_INT 0
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 3
40776: NEG
40777: PUSH
40778: LD_INT 1
40780: NEG
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: LIST
40790: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40791: LD_ADDR_VAR 0 16
40795: PUSH
40796: LD_INT 2
40798: NEG
40799: PUSH
40800: LD_INT 3
40802: NEG
40803: PUSH
40804: EMPTY
40805: LIST
40806: LIST
40807: PUSH
40808: LD_INT 3
40810: NEG
40811: PUSH
40812: LD_INT 2
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: LD_INT 3
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: LIST
40836: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40837: LD_ADDR_VAR 0 17
40841: PUSH
40842: LD_INT 1
40844: NEG
40845: PUSH
40846: LD_INT 3
40848: NEG
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 3
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 1
40867: PUSH
40868: LD_INT 2
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: LIST
40880: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40881: LD_ADDR_VAR 0 18
40885: PUSH
40886: LD_INT 2
40888: PUSH
40889: LD_INT 1
40891: NEG
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 3
40899: PUSH
40900: LD_INT 0
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 3
40909: PUSH
40910: LD_INT 1
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: LIST
40921: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40922: LD_ADDR_VAR 0 19
40926: PUSH
40927: LD_INT 3
40929: PUSH
40930: LD_INT 2
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 3
40939: PUSH
40940: LD_INT 3
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 2
40949: PUSH
40950: LD_INT 3
40952: PUSH
40953: EMPTY
40954: LIST
40955: LIST
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: LIST
40961: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40962: LD_ADDR_VAR 0 20
40966: PUSH
40967: LD_INT 1
40969: PUSH
40970: LD_INT 3
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 0
40979: PUSH
40980: LD_INT 3
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: LD_INT 1
40989: NEG
40990: PUSH
40991: LD_INT 2
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: EMPTY
40999: LIST
41000: LIST
41001: LIST
41002: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41003: LD_ADDR_VAR 0 21
41007: PUSH
41008: LD_INT 2
41010: NEG
41011: PUSH
41012: LD_INT 1
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: NEG
41022: PUSH
41023: LD_INT 0
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 3
41032: NEG
41033: PUSH
41034: LD_INT 1
41036: NEG
41037: PUSH
41038: EMPTY
41039: LIST
41040: LIST
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: LIST
41046: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41047: LD_ADDR_VAR 0 22
41051: PUSH
41052: LD_INT 2
41054: NEG
41055: PUSH
41056: LD_INT 3
41058: NEG
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 3
41066: NEG
41067: PUSH
41068: LD_INT 2
41070: NEG
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 3
41078: NEG
41079: PUSH
41080: LD_INT 3
41082: NEG
41083: PUSH
41084: EMPTY
41085: LIST
41086: LIST
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: LIST
41092: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41093: LD_ADDR_VAR 0 23
41097: PUSH
41098: LD_INT 0
41100: PUSH
41101: LD_INT 3
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 1
41111: NEG
41112: PUSH
41113: LD_INT 4
41115: NEG
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 1
41123: PUSH
41124: LD_INT 3
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: LIST
41136: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41137: LD_ADDR_VAR 0 24
41141: PUSH
41142: LD_INT 3
41144: PUSH
41145: LD_INT 0
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 3
41154: PUSH
41155: LD_INT 1
41157: NEG
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 4
41165: PUSH
41166: LD_INT 1
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: LIST
41177: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41178: LD_ADDR_VAR 0 25
41182: PUSH
41183: LD_INT 3
41185: PUSH
41186: LD_INT 3
41188: PUSH
41189: EMPTY
41190: LIST
41191: LIST
41192: PUSH
41193: LD_INT 4
41195: PUSH
41196: LD_INT 3
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: LD_INT 3
41205: PUSH
41206: LD_INT 4
41208: PUSH
41209: EMPTY
41210: LIST
41211: LIST
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: LIST
41217: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41218: LD_ADDR_VAR 0 26
41222: PUSH
41223: LD_INT 0
41225: PUSH
41226: LD_INT 3
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: LD_INT 4
41238: PUSH
41239: EMPTY
41240: LIST
41241: LIST
41242: PUSH
41243: LD_INT 1
41245: NEG
41246: PUSH
41247: LD_INT 3
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: LIST
41258: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41259: LD_ADDR_VAR 0 27
41263: PUSH
41264: LD_INT 3
41266: NEG
41267: PUSH
41268: LD_INT 0
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 3
41277: NEG
41278: PUSH
41279: LD_INT 1
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 4
41288: NEG
41289: PUSH
41290: LD_INT 1
41292: NEG
41293: PUSH
41294: EMPTY
41295: LIST
41296: LIST
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: LIST
41302: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41303: LD_ADDR_VAR 0 28
41307: PUSH
41308: LD_INT 3
41310: NEG
41311: PUSH
41312: LD_INT 3
41314: NEG
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 3
41322: NEG
41323: PUSH
41324: LD_INT 4
41326: NEG
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: LD_INT 4
41334: NEG
41335: PUSH
41336: LD_INT 3
41338: NEG
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: LIST
41348: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41349: LD_ADDR_VAR 0 29
41353: PUSH
41354: LD_INT 1
41356: NEG
41357: PUSH
41358: LD_INT 3
41360: NEG
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: LD_INT 0
41368: PUSH
41369: LD_INT 3
41371: NEG
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: LD_INT 2
41382: NEG
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: LD_INT 4
41394: NEG
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 0
41402: PUSH
41403: LD_INT 4
41405: NEG
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 1
41413: PUSH
41414: LD_INT 3
41416: NEG
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 1
41424: NEG
41425: PUSH
41426: LD_INT 5
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 0
41436: PUSH
41437: LD_INT 5
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 1
41447: PUSH
41448: LD_INT 4
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 1
41458: NEG
41459: PUSH
41460: LD_INT 6
41462: NEG
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 0
41470: PUSH
41471: LD_INT 6
41473: NEG
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 1
41481: PUSH
41482: LD_INT 5
41484: NEG
41485: PUSH
41486: EMPTY
41487: LIST
41488: LIST
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: LIST
41503: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41504: LD_ADDR_VAR 0 30
41508: PUSH
41509: LD_INT 2
41511: PUSH
41512: LD_INT 1
41514: NEG
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 3
41532: PUSH
41533: LD_INT 1
41535: PUSH
41536: EMPTY
41537: LIST
41538: LIST
41539: PUSH
41540: LD_INT 3
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 4
41553: PUSH
41554: LD_INT 0
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: LD_INT 4
41563: PUSH
41564: LD_INT 1
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: PUSH
41571: LD_INT 4
41573: PUSH
41574: LD_INT 1
41576: NEG
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 5
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 5
41594: PUSH
41595: LD_INT 1
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 5
41604: PUSH
41605: LD_INT 1
41607: NEG
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 6
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 6
41625: PUSH
41626: LD_INT 1
41628: PUSH
41629: EMPTY
41630: LIST
41631: LIST
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: LIST
41646: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41647: LD_ADDR_VAR 0 31
41651: PUSH
41652: LD_INT 3
41654: PUSH
41655: LD_INT 2
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 3
41664: PUSH
41665: LD_INT 3
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PUSH
41672: LD_INT 2
41674: PUSH
41675: LD_INT 3
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 4
41684: PUSH
41685: LD_INT 3
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 4
41694: PUSH
41695: LD_INT 4
41697: PUSH
41698: EMPTY
41699: LIST
41700: LIST
41701: PUSH
41702: LD_INT 3
41704: PUSH
41705: LD_INT 4
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 5
41714: PUSH
41715: LD_INT 4
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 5
41724: PUSH
41725: LD_INT 5
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 4
41734: PUSH
41735: LD_INT 5
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 6
41744: PUSH
41745: LD_INT 5
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 6
41754: PUSH
41755: LD_INT 6
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 5
41764: PUSH
41765: LD_INT 6
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: LIST
41778: LIST
41779: LIST
41780: LIST
41781: LIST
41782: LIST
41783: LIST
41784: LIST
41785: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41786: LD_ADDR_VAR 0 32
41790: PUSH
41791: LD_INT 1
41793: PUSH
41794: LD_INT 3
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 0
41803: PUSH
41804: LD_INT 3
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 1
41813: NEG
41814: PUSH
41815: LD_INT 2
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: LD_INT 4
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 0
41834: PUSH
41835: LD_INT 4
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: LD_INT 3
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 1
41855: PUSH
41856: LD_INT 5
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 0
41865: PUSH
41866: LD_INT 5
41868: PUSH
41869: EMPTY
41870: LIST
41871: LIST
41872: PUSH
41873: LD_INT 1
41875: NEG
41876: PUSH
41877: LD_INT 4
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: LD_INT 1
41886: PUSH
41887: LD_INT 6
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 0
41896: PUSH
41897: LD_INT 6
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 1
41906: NEG
41907: PUSH
41908: LD_INT 5
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: LIST
41919: LIST
41920: LIST
41921: LIST
41922: LIST
41923: LIST
41924: LIST
41925: LIST
41926: LIST
41927: LIST
41928: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41929: LD_ADDR_VAR 0 33
41933: PUSH
41934: LD_INT 2
41936: NEG
41937: PUSH
41938: LD_INT 1
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 3
41947: NEG
41948: PUSH
41949: LD_INT 0
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 3
41958: NEG
41959: PUSH
41960: LD_INT 1
41962: NEG
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 3
41970: NEG
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 4
41981: NEG
41982: PUSH
41983: LD_INT 0
41985: PUSH
41986: EMPTY
41987: LIST
41988: LIST
41989: PUSH
41990: LD_INT 4
41992: NEG
41993: PUSH
41994: LD_INT 1
41996: NEG
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 4
42004: NEG
42005: PUSH
42006: LD_INT 1
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 5
42015: NEG
42016: PUSH
42017: LD_INT 0
42019: PUSH
42020: EMPTY
42021: LIST
42022: LIST
42023: PUSH
42024: LD_INT 5
42026: NEG
42027: PUSH
42028: LD_INT 1
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 5
42038: NEG
42039: PUSH
42040: LD_INT 1
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 6
42049: NEG
42050: PUSH
42051: LD_INT 0
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 6
42060: NEG
42061: PUSH
42062: LD_INT 1
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42084: LD_ADDR_VAR 0 34
42088: PUSH
42089: LD_INT 2
42091: NEG
42092: PUSH
42093: LD_INT 3
42095: NEG
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 3
42103: NEG
42104: PUSH
42105: LD_INT 2
42107: NEG
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 3
42115: NEG
42116: PUSH
42117: LD_INT 3
42119: NEG
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 3
42127: NEG
42128: PUSH
42129: LD_INT 4
42131: NEG
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 4
42139: NEG
42140: PUSH
42141: LD_INT 3
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: LD_INT 4
42151: NEG
42152: PUSH
42153: LD_INT 4
42155: NEG
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 4
42163: NEG
42164: PUSH
42165: LD_INT 5
42167: NEG
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: PUSH
42173: LD_INT 5
42175: NEG
42176: PUSH
42177: LD_INT 4
42179: NEG
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 5
42187: NEG
42188: PUSH
42189: LD_INT 5
42191: NEG
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 5
42199: NEG
42200: PUSH
42201: LD_INT 6
42203: NEG
42204: PUSH
42205: EMPTY
42206: LIST
42207: LIST
42208: PUSH
42209: LD_INT 6
42211: NEG
42212: PUSH
42213: LD_INT 5
42215: NEG
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 6
42223: NEG
42224: PUSH
42225: LD_INT 6
42227: NEG
42228: PUSH
42229: EMPTY
42230: LIST
42231: LIST
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: LIST
42246: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42247: LD_ADDR_VAR 0 41
42251: PUSH
42252: LD_INT 0
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 1
42265: NEG
42266: PUSH
42267: LD_INT 3
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 1
42277: PUSH
42278: LD_INT 2
42280: NEG
42281: PUSH
42282: EMPTY
42283: LIST
42284: LIST
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: LIST
42290: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42291: LD_ADDR_VAR 0 42
42295: PUSH
42296: LD_INT 2
42298: PUSH
42299: LD_INT 0
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 2
42308: PUSH
42309: LD_INT 1
42311: NEG
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 3
42319: PUSH
42320: LD_INT 1
42322: PUSH
42323: EMPTY
42324: LIST
42325: LIST
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: LIST
42331: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42332: LD_ADDR_VAR 0 43
42336: PUSH
42337: LD_INT 2
42339: PUSH
42340: LD_INT 2
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 3
42349: PUSH
42350: LD_INT 2
42352: PUSH
42353: EMPTY
42354: LIST
42355: LIST
42356: PUSH
42357: LD_INT 2
42359: PUSH
42360: LD_INT 3
42362: PUSH
42363: EMPTY
42364: LIST
42365: LIST
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: LIST
42371: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42372: LD_ADDR_VAR 0 44
42376: PUSH
42377: LD_INT 0
42379: PUSH
42380: LD_INT 2
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 1
42389: PUSH
42390: LD_INT 3
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 1
42399: NEG
42400: PUSH
42401: LD_INT 2
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: LIST
42412: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42413: LD_ADDR_VAR 0 45
42417: PUSH
42418: LD_INT 2
42420: NEG
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 2
42431: NEG
42432: PUSH
42433: LD_INT 1
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 3
42442: NEG
42443: PUSH
42444: LD_INT 1
42446: NEG
42447: PUSH
42448: EMPTY
42449: LIST
42450: LIST
42451: PUSH
42452: EMPTY
42453: LIST
42454: LIST
42455: LIST
42456: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42457: LD_ADDR_VAR 0 46
42461: PUSH
42462: LD_INT 2
42464: NEG
42465: PUSH
42466: LD_INT 2
42468: NEG
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: LD_INT 2
42476: NEG
42477: PUSH
42478: LD_INT 3
42480: NEG
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: LD_INT 3
42488: NEG
42489: PUSH
42490: LD_INT 2
42492: NEG
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: LIST
42502: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42503: LD_ADDR_VAR 0 47
42507: PUSH
42508: LD_INT 2
42510: NEG
42511: PUSH
42512: LD_INT 3
42514: NEG
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 1
42522: NEG
42523: PUSH
42524: LD_INT 3
42526: NEG
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42536: LD_ADDR_VAR 0 48
42540: PUSH
42541: LD_INT 1
42543: PUSH
42544: LD_INT 2
42546: NEG
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 2
42554: PUSH
42555: LD_INT 1
42557: NEG
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42567: LD_ADDR_VAR 0 49
42571: PUSH
42572: LD_INT 3
42574: PUSH
42575: LD_INT 1
42577: PUSH
42578: EMPTY
42579: LIST
42580: LIST
42581: PUSH
42582: LD_INT 3
42584: PUSH
42585: LD_INT 2
42587: PUSH
42588: EMPTY
42589: LIST
42590: LIST
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42596: LD_ADDR_VAR 0 50
42600: PUSH
42601: LD_INT 2
42603: PUSH
42604: LD_INT 3
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: PUSH
42614: LD_INT 3
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42625: LD_ADDR_VAR 0 51
42629: PUSH
42630: LD_INT 1
42632: NEG
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 2
42643: NEG
42644: PUSH
42645: LD_INT 1
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42656: LD_ADDR_VAR 0 52
42660: PUSH
42661: LD_INT 3
42663: NEG
42664: PUSH
42665: LD_INT 1
42667: NEG
42668: PUSH
42669: EMPTY
42670: LIST
42671: LIST
42672: PUSH
42673: LD_INT 3
42675: NEG
42676: PUSH
42677: LD_INT 2
42679: NEG
42680: PUSH
42681: EMPTY
42682: LIST
42683: LIST
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42689: LD_ADDR_VAR 0 53
42693: PUSH
42694: LD_INT 1
42696: NEG
42697: PUSH
42698: LD_INT 3
42700: NEG
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 0
42708: PUSH
42709: LD_INT 3
42711: NEG
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: LD_INT 2
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: LIST
42732: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42733: LD_ADDR_VAR 0 54
42737: PUSH
42738: LD_INT 2
42740: PUSH
42741: LD_INT 1
42743: NEG
42744: PUSH
42745: EMPTY
42746: LIST
42747: LIST
42748: PUSH
42749: LD_INT 3
42751: PUSH
42752: LD_INT 0
42754: PUSH
42755: EMPTY
42756: LIST
42757: LIST
42758: PUSH
42759: LD_INT 3
42761: PUSH
42762: LD_INT 1
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: LIST
42773: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42774: LD_ADDR_VAR 0 55
42778: PUSH
42779: LD_INT 3
42781: PUSH
42782: LD_INT 2
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 3
42791: PUSH
42792: LD_INT 3
42794: PUSH
42795: EMPTY
42796: LIST
42797: LIST
42798: PUSH
42799: LD_INT 2
42801: PUSH
42802: LD_INT 3
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: LIST
42813: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42814: LD_ADDR_VAR 0 56
42818: PUSH
42819: LD_INT 1
42821: PUSH
42822: LD_INT 3
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 0
42831: PUSH
42832: LD_INT 3
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 1
42841: NEG
42842: PUSH
42843: LD_INT 2
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: PUSH
42850: EMPTY
42851: LIST
42852: LIST
42853: LIST
42854: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42855: LD_ADDR_VAR 0 57
42859: PUSH
42860: LD_INT 2
42862: NEG
42863: PUSH
42864: LD_INT 1
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PUSH
42871: LD_INT 3
42873: NEG
42874: PUSH
42875: LD_INT 0
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PUSH
42882: LD_INT 3
42884: NEG
42885: PUSH
42886: LD_INT 1
42888: NEG
42889: PUSH
42890: EMPTY
42891: LIST
42892: LIST
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: LIST
42898: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42899: LD_ADDR_VAR 0 58
42903: PUSH
42904: LD_INT 2
42906: NEG
42907: PUSH
42908: LD_INT 3
42910: NEG
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: LD_INT 3
42918: NEG
42919: PUSH
42920: LD_INT 2
42922: NEG
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: LD_INT 3
42930: NEG
42931: PUSH
42932: LD_INT 3
42934: NEG
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: LIST
42944: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42945: LD_ADDR_VAR 0 59
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: LD_INT 2
42956: NEG
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: LD_INT 0
42964: PUSH
42965: LD_INT 2
42967: NEG
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: PUSH
42973: LD_INT 1
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: LIST
42988: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42989: LD_ADDR_VAR 0 60
42993: PUSH
42994: LD_INT 1
42996: PUSH
42997: LD_INT 1
42999: NEG
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 2
43007: PUSH
43008: LD_INT 0
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 2
43017: PUSH
43018: LD_INT 1
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: LIST
43029: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43030: LD_ADDR_VAR 0 61
43034: PUSH
43035: LD_INT 2
43037: PUSH
43038: LD_INT 1
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 2
43047: PUSH
43048: LD_INT 2
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 1
43057: PUSH
43058: LD_INT 2
43060: PUSH
43061: EMPTY
43062: LIST
43063: LIST
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: LIST
43069: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43070: LD_ADDR_VAR 0 62
43074: PUSH
43075: LD_INT 1
43077: PUSH
43078: LD_INT 2
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 0
43087: PUSH
43088: LD_INT 2
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 1
43097: NEG
43098: PUSH
43099: LD_INT 1
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: LIST
43110: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43111: LD_ADDR_VAR 0 63
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: LD_INT 1
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 2
43129: NEG
43130: PUSH
43131: LD_INT 0
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 2
43140: NEG
43141: PUSH
43142: LD_INT 1
43144: NEG
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: LIST
43154: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43155: LD_ADDR_VAR 0 64
43159: PUSH
43160: LD_INT 1
43162: NEG
43163: PUSH
43164: LD_INT 2
43166: NEG
43167: PUSH
43168: EMPTY
43169: LIST
43170: LIST
43171: PUSH
43172: LD_INT 2
43174: NEG
43175: PUSH
43176: LD_INT 1
43178: NEG
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: LD_INT 2
43186: NEG
43187: PUSH
43188: LD_INT 2
43190: NEG
43191: PUSH
43192: EMPTY
43193: LIST
43194: LIST
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: LIST
43200: ST_TO_ADDR
// end ; 2 :
43201: GO 46467
43203: LD_INT 2
43205: DOUBLE
43206: EQUAL
43207: IFTRUE 43211
43209: GO 46466
43211: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43212: LD_ADDR_VAR 0 29
43216: PUSH
43217: LD_INT 4
43219: PUSH
43220: LD_INT 0
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 4
43229: PUSH
43230: LD_INT 1
43232: NEG
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: LD_INT 5
43240: PUSH
43241: LD_INT 0
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 5
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: LD_INT 4
43260: PUSH
43261: LD_INT 1
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: LD_INT 3
43270: PUSH
43271: LD_INT 0
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: PUSH
43278: LD_INT 3
43280: PUSH
43281: LD_INT 1
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 3
43291: PUSH
43292: LD_INT 2
43294: NEG
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 5
43302: PUSH
43303: LD_INT 2
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 3
43312: PUSH
43313: LD_INT 3
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 3
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 4
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 4
43342: PUSH
43343: LD_INT 4
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 3
43352: PUSH
43353: LD_INT 4
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 2
43362: PUSH
43363: LD_INT 3
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 2
43372: PUSH
43373: LD_INT 2
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 4
43382: PUSH
43383: LD_INT 2
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 2
43392: PUSH
43393: LD_INT 4
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: LD_INT 4
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 3
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 1
43422: PUSH
43423: LD_INT 4
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 1
43432: PUSH
43433: LD_INT 5
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 0
43442: PUSH
43443: LD_INT 5
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PUSH
43450: LD_INT 1
43452: NEG
43453: PUSH
43454: LD_INT 4
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 1
43463: NEG
43464: PUSH
43465: LD_INT 3
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 5
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 2
43484: NEG
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 3
43495: NEG
43496: PUSH
43497: LD_INT 0
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 3
43506: NEG
43507: PUSH
43508: LD_INT 1
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 2
43518: NEG
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 2
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 3
43540: NEG
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 4
43551: NEG
43552: PUSH
43553: LD_INT 0
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: PUSH
43560: LD_INT 4
43562: NEG
43563: PUSH
43564: LD_INT 1
43566: NEG
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 4
43574: NEG
43575: PUSH
43576: LD_INT 2
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 2
43586: NEG
43587: PUSH
43588: LD_INT 2
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 4
43597: NEG
43598: PUSH
43599: LD_INT 4
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 4
43609: NEG
43610: PUSH
43611: LD_INT 5
43613: NEG
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 3
43621: NEG
43622: PUSH
43623: LD_INT 4
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 3
43633: NEG
43634: PUSH
43635: LD_INT 3
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 4
43645: NEG
43646: PUSH
43647: LD_INT 3
43649: NEG
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 5
43657: NEG
43658: PUSH
43659: LD_INT 4
43661: NEG
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 5
43669: NEG
43670: PUSH
43671: LD_INT 5
43673: NEG
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 3
43681: NEG
43682: PUSH
43683: LD_INT 5
43685: NEG
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 5
43693: NEG
43694: PUSH
43695: LD_INT 3
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: LIST
43724: LIST
43725: LIST
43726: LIST
43727: LIST
43728: LIST
43729: LIST
43730: LIST
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: LIST
43736: LIST
43737: LIST
43738: LIST
43739: LIST
43740: LIST
43741: LIST
43742: LIST
43743: LIST
43744: LIST
43745: LIST
43746: LIST
43747: LIST
43748: LIST
43749: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43750: LD_ADDR_VAR 0 30
43754: PUSH
43755: LD_INT 4
43757: PUSH
43758: LD_INT 4
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 4
43767: PUSH
43768: LD_INT 3
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 5
43777: PUSH
43778: LD_INT 4
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 5
43787: PUSH
43788: LD_INT 5
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 4
43797: PUSH
43798: LD_INT 5
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 3
43807: PUSH
43808: LD_INT 4
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 3
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 5
43827: PUSH
43828: LD_INT 3
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 3
43837: PUSH
43838: LD_INT 5
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 0
43847: PUSH
43848: LD_INT 3
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 0
43857: PUSH
43858: LD_INT 2
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 1
43867: PUSH
43868: LD_INT 3
43870: PUSH
43871: EMPTY
43872: LIST
43873: LIST
43874: PUSH
43875: LD_INT 1
43877: PUSH
43878: LD_INT 4
43880: PUSH
43881: EMPTY
43882: LIST
43883: LIST
43884: PUSH
43885: LD_INT 0
43887: PUSH
43888: LD_INT 4
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 1
43897: NEG
43898: PUSH
43899: LD_INT 3
43901: PUSH
43902: EMPTY
43903: LIST
43904: LIST
43905: PUSH
43906: LD_INT 1
43908: NEG
43909: PUSH
43910: LD_INT 2
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 2
43919: PUSH
43920: LD_INT 4
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 2
43929: NEG
43930: PUSH
43931: LD_INT 2
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: PUSH
43938: LD_INT 4
43940: NEG
43941: PUSH
43942: LD_INT 0
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 4
43951: NEG
43952: PUSH
43953: LD_INT 1
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 3
43963: NEG
43964: PUSH
43965: LD_INT 0
43967: PUSH
43968: EMPTY
43969: LIST
43970: LIST
43971: PUSH
43972: LD_INT 3
43974: NEG
43975: PUSH
43976: LD_INT 1
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 4
43985: NEG
43986: PUSH
43987: LD_INT 1
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 5
43996: NEG
43997: PUSH
43998: LD_INT 0
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 5
44007: NEG
44008: PUSH
44009: LD_INT 1
44011: NEG
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 5
44019: NEG
44020: PUSH
44021: LD_INT 2
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 3
44031: NEG
44032: PUSH
44033: LD_INT 2
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 3
44042: NEG
44043: PUSH
44044: LD_INT 3
44046: NEG
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 3
44054: NEG
44055: PUSH
44056: LD_INT 4
44058: NEG
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 2
44066: NEG
44067: PUSH
44068: LD_INT 3
44070: NEG
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 2
44078: NEG
44079: PUSH
44080: LD_INT 2
44082: NEG
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 3
44090: NEG
44091: PUSH
44092: LD_INT 2
44094: NEG
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: LD_INT 4
44102: NEG
44103: PUSH
44104: LD_INT 3
44106: NEG
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 4
44114: NEG
44115: PUSH
44116: LD_INT 4
44118: NEG
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 2
44126: NEG
44127: PUSH
44128: LD_INT 4
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 4
44138: NEG
44139: PUSH
44140: LD_INT 2
44142: NEG
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 0
44150: PUSH
44151: LD_INT 4
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 0
44161: PUSH
44162: LD_INT 5
44164: NEG
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 1
44172: PUSH
44173: LD_INT 4
44175: NEG
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 1
44183: PUSH
44184: LD_INT 3
44186: NEG
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 0
44194: PUSH
44195: LD_INT 3
44197: NEG
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 1
44205: NEG
44206: PUSH
44207: LD_INT 4
44209: NEG
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 1
44217: NEG
44218: PUSH
44219: LD_INT 5
44221: NEG
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: LD_INT 3
44232: NEG
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 2
44240: NEG
44241: PUSH
44242: LD_INT 5
44244: NEG
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: LIST
44286: LIST
44287: LIST
44288: LIST
44289: LIST
44290: LIST
44291: LIST
44292: LIST
44293: LIST
44294: LIST
44295: LIST
44296: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44297: LD_ADDR_VAR 0 31
44301: PUSH
44302: LD_INT 0
44304: PUSH
44305: LD_INT 4
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 0
44314: PUSH
44315: LD_INT 3
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 1
44324: PUSH
44325: LD_INT 4
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: PUSH
44332: LD_INT 1
44334: PUSH
44335: LD_INT 5
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PUSH
44342: LD_INT 0
44344: PUSH
44345: LD_INT 5
44347: PUSH
44348: EMPTY
44349: LIST
44350: LIST
44351: PUSH
44352: LD_INT 1
44354: NEG
44355: PUSH
44356: LD_INT 4
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 1
44365: NEG
44366: PUSH
44367: LD_INT 3
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 2
44376: PUSH
44377: LD_INT 5
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 2
44386: NEG
44387: PUSH
44388: LD_INT 3
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 3
44397: NEG
44398: PUSH
44399: LD_INT 0
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 3
44408: NEG
44409: PUSH
44410: LD_INT 1
44412: NEG
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 2
44420: NEG
44421: PUSH
44422: LD_INT 0
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 2
44431: NEG
44432: PUSH
44433: LD_INT 1
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 3
44442: NEG
44443: PUSH
44444: LD_INT 1
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 4
44453: NEG
44454: PUSH
44455: LD_INT 0
44457: PUSH
44458: EMPTY
44459: LIST
44460: LIST
44461: PUSH
44462: LD_INT 4
44464: NEG
44465: PUSH
44466: LD_INT 1
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 4
44476: NEG
44477: PUSH
44478: LD_INT 2
44480: NEG
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PUSH
44486: LD_INT 2
44488: NEG
44489: PUSH
44490: LD_INT 2
44492: PUSH
44493: EMPTY
44494: LIST
44495: LIST
44496: PUSH
44497: LD_INT 4
44499: NEG
44500: PUSH
44501: LD_INT 4
44503: NEG
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 4
44511: NEG
44512: PUSH
44513: LD_INT 5
44515: NEG
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 3
44523: NEG
44524: PUSH
44525: LD_INT 4
44527: NEG
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 3
44535: NEG
44536: PUSH
44537: LD_INT 3
44539: NEG
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 4
44547: NEG
44548: PUSH
44549: LD_INT 3
44551: NEG
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 5
44559: NEG
44560: PUSH
44561: LD_INT 4
44563: NEG
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 5
44571: NEG
44572: PUSH
44573: LD_INT 5
44575: NEG
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 3
44583: NEG
44584: PUSH
44585: LD_INT 5
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 5
44595: NEG
44596: PUSH
44597: LD_INT 3
44599: NEG
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 0
44607: PUSH
44608: LD_INT 3
44610: NEG
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 4
44621: NEG
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 1
44629: PUSH
44630: LD_INT 3
44632: NEG
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 1
44640: PUSH
44641: LD_INT 2
44643: NEG
44644: PUSH
44645: EMPTY
44646: LIST
44647: LIST
44648: PUSH
44649: LD_INT 0
44651: PUSH
44652: LD_INT 2
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 1
44662: NEG
44663: PUSH
44664: LD_INT 3
44666: NEG
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: LD_INT 4
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 2
44686: PUSH
44687: LD_INT 2
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 2
44697: NEG
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 4
44709: PUSH
44710: LD_INT 0
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 4
44719: PUSH
44720: LD_INT 1
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 5
44730: PUSH
44731: LD_INT 0
44733: PUSH
44734: EMPTY
44735: LIST
44736: LIST
44737: PUSH
44738: LD_INT 5
44740: PUSH
44741: LD_INT 1
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: PUSH
44748: LD_INT 4
44750: PUSH
44751: LD_INT 1
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 3
44760: PUSH
44761: LD_INT 0
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 3
44770: PUSH
44771: LD_INT 1
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 3
44781: PUSH
44782: LD_INT 2
44784: NEG
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 5
44792: PUSH
44793: LD_INT 2
44795: PUSH
44796: EMPTY
44797: LIST
44798: LIST
44799: PUSH
44800: EMPTY
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: LIST
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: LIST
44839: LIST
44840: LIST
44841: LIST
44842: LIST
44843: LIST
44844: LIST
44845: LIST
44846: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44847: LD_ADDR_VAR 0 32
44851: PUSH
44852: LD_INT 4
44854: NEG
44855: PUSH
44856: LD_INT 0
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: LD_INT 4
44865: NEG
44866: PUSH
44867: LD_INT 1
44869: NEG
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 3
44877: NEG
44878: PUSH
44879: LD_INT 0
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 3
44888: NEG
44889: PUSH
44890: LD_INT 1
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 4
44899: NEG
44900: PUSH
44901: LD_INT 1
44903: PUSH
44904: EMPTY
44905: LIST
44906: LIST
44907: PUSH
44908: LD_INT 5
44910: NEG
44911: PUSH
44912: LD_INT 0
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: LD_INT 5
44921: NEG
44922: PUSH
44923: LD_INT 1
44925: NEG
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 5
44933: NEG
44934: PUSH
44935: LD_INT 2
44937: NEG
44938: PUSH
44939: EMPTY
44940: LIST
44941: LIST
44942: PUSH
44943: LD_INT 3
44945: NEG
44946: PUSH
44947: LD_INT 2
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 3
44956: NEG
44957: PUSH
44958: LD_INT 3
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 3
44968: NEG
44969: PUSH
44970: LD_INT 4
44972: NEG
44973: PUSH
44974: EMPTY
44975: LIST
44976: LIST
44977: PUSH
44978: LD_INT 2
44980: NEG
44981: PUSH
44982: LD_INT 3
44984: NEG
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 2
44992: NEG
44993: PUSH
44994: LD_INT 2
44996: NEG
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: LD_INT 3
45004: NEG
45005: PUSH
45006: LD_INT 2
45008: NEG
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 4
45016: NEG
45017: PUSH
45018: LD_INT 3
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 4
45028: NEG
45029: PUSH
45030: LD_INT 4
45032: NEG
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 2
45040: NEG
45041: PUSH
45042: LD_INT 4
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 4
45052: NEG
45053: PUSH
45054: LD_INT 2
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 0
45064: PUSH
45065: LD_INT 4
45067: NEG
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 0
45075: PUSH
45076: LD_INT 5
45078: NEG
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 1
45086: PUSH
45087: LD_INT 4
45089: NEG
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 1
45097: PUSH
45098: LD_INT 3
45100: NEG
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: LD_INT 0
45108: PUSH
45109: LD_INT 3
45111: NEG
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 1
45119: NEG
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 1
45131: NEG
45132: PUSH
45133: LD_INT 5
45135: NEG
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PUSH
45141: LD_INT 2
45143: PUSH
45144: LD_INT 3
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 2
45154: NEG
45155: PUSH
45156: LD_INT 5
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 3
45166: PUSH
45167: LD_INT 0
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 3
45176: PUSH
45177: LD_INT 1
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 4
45187: PUSH
45188: LD_INT 0
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PUSH
45195: LD_INT 4
45197: PUSH
45198: LD_INT 1
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 3
45207: PUSH
45208: LD_INT 1
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 2
45217: PUSH
45218: LD_INT 0
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: PUSH
45225: LD_INT 2
45227: PUSH
45228: LD_INT 1
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 2
45238: PUSH
45239: LD_INT 2
45241: NEG
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 4
45249: PUSH
45250: LD_INT 2
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 4
45259: PUSH
45260: LD_INT 4
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 4
45269: PUSH
45270: LD_INT 3
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 5
45279: PUSH
45280: LD_INT 4
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 5
45289: PUSH
45290: LD_INT 5
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 4
45299: PUSH
45300: LD_INT 5
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 3
45309: PUSH
45310: LD_INT 4
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: LD_INT 3
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 5
45329: PUSH
45330: LD_INT 3
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 3
45339: PUSH
45340: LD_INT 5
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: EMPTY
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: LIST
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: LIST
45375: LIST
45376: LIST
45377: LIST
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: LIST
45383: LIST
45384: LIST
45385: LIST
45386: LIST
45387: LIST
45388: LIST
45389: LIST
45390: LIST
45391: LIST
45392: LIST
45393: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45394: LD_ADDR_VAR 0 33
45398: PUSH
45399: LD_INT 4
45401: NEG
45402: PUSH
45403: LD_INT 4
45405: NEG
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 4
45413: NEG
45414: PUSH
45415: LD_INT 5
45417: NEG
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: PUSH
45423: LD_INT 3
45425: NEG
45426: PUSH
45427: LD_INT 4
45429: NEG
45430: PUSH
45431: EMPTY
45432: LIST
45433: LIST
45434: PUSH
45435: LD_INT 3
45437: NEG
45438: PUSH
45439: LD_INT 3
45441: NEG
45442: PUSH
45443: EMPTY
45444: LIST
45445: LIST
45446: PUSH
45447: LD_INT 4
45449: NEG
45450: PUSH
45451: LD_INT 3
45453: NEG
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 5
45461: NEG
45462: PUSH
45463: LD_INT 4
45465: NEG
45466: PUSH
45467: EMPTY
45468: LIST
45469: LIST
45470: PUSH
45471: LD_INT 5
45473: NEG
45474: PUSH
45475: LD_INT 5
45477: NEG
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 3
45485: NEG
45486: PUSH
45487: LD_INT 5
45489: NEG
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 5
45497: NEG
45498: PUSH
45499: LD_INT 3
45501: NEG
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 0
45509: PUSH
45510: LD_INT 3
45512: NEG
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: LD_INT 4
45523: NEG
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 1
45531: PUSH
45532: LD_INT 3
45534: NEG
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: LD_INT 2
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 0
45553: PUSH
45554: LD_INT 2
45556: NEG
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: LD_INT 3
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 1
45576: NEG
45577: PUSH
45578: LD_INT 4
45580: NEG
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: LD_INT 2
45588: PUSH
45589: LD_INT 2
45591: NEG
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 2
45599: NEG
45600: PUSH
45601: LD_INT 4
45603: NEG
45604: PUSH
45605: EMPTY
45606: LIST
45607: LIST
45608: PUSH
45609: LD_INT 4
45611: PUSH
45612: LD_INT 0
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 4
45621: PUSH
45622: LD_INT 1
45624: NEG
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 5
45632: PUSH
45633: LD_INT 0
45635: PUSH
45636: EMPTY
45637: LIST
45638: LIST
45639: PUSH
45640: LD_INT 5
45642: PUSH
45643: LD_INT 1
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: LD_INT 4
45652: PUSH
45653: LD_INT 1
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PUSH
45660: LD_INT 3
45662: PUSH
45663: LD_INT 0
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 3
45672: PUSH
45673: LD_INT 1
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 3
45683: PUSH
45684: LD_INT 2
45686: NEG
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: LD_INT 5
45694: PUSH
45695: LD_INT 2
45697: PUSH
45698: EMPTY
45699: LIST
45700: LIST
45701: PUSH
45702: LD_INT 3
45704: PUSH
45705: LD_INT 3
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PUSH
45712: LD_INT 3
45714: PUSH
45715: LD_INT 2
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PUSH
45722: LD_INT 4
45724: PUSH
45725: LD_INT 3
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 4
45734: PUSH
45735: LD_INT 4
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 3
45744: PUSH
45745: LD_INT 4
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 2
45754: PUSH
45755: LD_INT 3
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: LD_INT 2
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 4
45774: PUSH
45775: LD_INT 2
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 2
45784: PUSH
45785: LD_INT 4
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 0
45794: PUSH
45795: LD_INT 4
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: PUSH
45802: LD_INT 0
45804: PUSH
45805: LD_INT 3
45807: PUSH
45808: EMPTY
45809: LIST
45810: LIST
45811: PUSH
45812: LD_INT 1
45814: PUSH
45815: LD_INT 4
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 1
45824: PUSH
45825: LD_INT 5
45827: PUSH
45828: EMPTY
45829: LIST
45830: LIST
45831: PUSH
45832: LD_INT 0
45834: PUSH
45835: LD_INT 5
45837: PUSH
45838: EMPTY
45839: LIST
45840: LIST
45841: PUSH
45842: LD_INT 1
45844: NEG
45845: PUSH
45846: LD_INT 4
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PUSH
45853: LD_INT 1
45855: NEG
45856: PUSH
45857: LD_INT 3
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 2
45866: PUSH
45867: LD_INT 5
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 2
45876: NEG
45877: PUSH
45878: LD_INT 3
45880: PUSH
45881: EMPTY
45882: LIST
45883: LIST
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: LIST
45904: LIST
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: LIST
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: LIST
45918: LIST
45919: LIST
45920: LIST
45921: LIST
45922: LIST
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: LIST
45930: LIST
45931: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45932: LD_ADDR_VAR 0 34
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: LD_INT 4
45942: NEG
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 0
45950: PUSH
45951: LD_INT 5
45953: NEG
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 1
45961: PUSH
45962: LD_INT 4
45964: NEG
45965: PUSH
45966: EMPTY
45967: LIST
45968: LIST
45969: PUSH
45970: LD_INT 1
45972: PUSH
45973: LD_INT 3
45975: NEG
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 0
45983: PUSH
45984: LD_INT 3
45986: NEG
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: LD_INT 1
45994: NEG
45995: PUSH
45996: LD_INT 4
45998: NEG
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: LD_INT 1
46006: NEG
46007: PUSH
46008: LD_INT 5
46010: NEG
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 2
46018: PUSH
46019: LD_INT 3
46021: NEG
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: PUSH
46027: LD_INT 2
46029: NEG
46030: PUSH
46031: LD_INT 5
46033: NEG
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 3
46041: PUSH
46042: LD_INT 0
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 3
46051: PUSH
46052: LD_INT 1
46054: NEG
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 4
46062: PUSH
46063: LD_INT 0
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 4
46072: PUSH
46073: LD_INT 1
46075: PUSH
46076: EMPTY
46077: LIST
46078: LIST
46079: PUSH
46080: LD_INT 3
46082: PUSH
46083: LD_INT 1
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: LD_INT 2
46092: PUSH
46093: LD_INT 0
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PUSH
46100: LD_INT 2
46102: PUSH
46103: LD_INT 1
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 2
46113: PUSH
46114: LD_INT 2
46116: NEG
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 4
46124: PUSH
46125: LD_INT 2
46127: PUSH
46128: EMPTY
46129: LIST
46130: LIST
46131: PUSH
46132: LD_INT 4
46134: PUSH
46135: LD_INT 4
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 4
46144: PUSH
46145: LD_INT 3
46147: PUSH
46148: EMPTY
46149: LIST
46150: LIST
46151: PUSH
46152: LD_INT 5
46154: PUSH
46155: LD_INT 4
46157: PUSH
46158: EMPTY
46159: LIST
46160: LIST
46161: PUSH
46162: LD_INT 5
46164: PUSH
46165: LD_INT 5
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 4
46174: PUSH
46175: LD_INT 5
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 3
46184: PUSH
46185: LD_INT 4
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 3
46194: PUSH
46195: LD_INT 3
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 5
46204: PUSH
46205: LD_INT 3
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 3
46214: PUSH
46215: LD_INT 5
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: PUSH
46222: LD_INT 0
46224: PUSH
46225: LD_INT 3
46227: PUSH
46228: EMPTY
46229: LIST
46230: LIST
46231: PUSH
46232: LD_INT 0
46234: PUSH
46235: LD_INT 2
46237: PUSH
46238: EMPTY
46239: LIST
46240: LIST
46241: PUSH
46242: LD_INT 1
46244: PUSH
46245: LD_INT 3
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 1
46254: PUSH
46255: LD_INT 4
46257: PUSH
46258: EMPTY
46259: LIST
46260: LIST
46261: PUSH
46262: LD_INT 0
46264: PUSH
46265: LD_INT 4
46267: PUSH
46268: EMPTY
46269: LIST
46270: LIST
46271: PUSH
46272: LD_INT 1
46274: NEG
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: EMPTY
46280: LIST
46281: LIST
46282: PUSH
46283: LD_INT 1
46285: NEG
46286: PUSH
46287: LD_INT 2
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 2
46296: PUSH
46297: LD_INT 4
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 2
46306: NEG
46307: PUSH
46308: LD_INT 2
46310: PUSH
46311: EMPTY
46312: LIST
46313: LIST
46314: PUSH
46315: LD_INT 4
46317: NEG
46318: PUSH
46319: LD_INT 0
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 4
46328: NEG
46329: PUSH
46330: LD_INT 1
46332: NEG
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 3
46340: NEG
46341: PUSH
46342: LD_INT 0
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 3
46351: NEG
46352: PUSH
46353: LD_INT 1
46355: PUSH
46356: EMPTY
46357: LIST
46358: LIST
46359: PUSH
46360: LD_INT 4
46362: NEG
46363: PUSH
46364: LD_INT 1
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 5
46373: NEG
46374: PUSH
46375: LD_INT 0
46377: PUSH
46378: EMPTY
46379: LIST
46380: LIST
46381: PUSH
46382: LD_INT 5
46384: NEG
46385: PUSH
46386: LD_INT 1
46388: NEG
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: PUSH
46394: LD_INT 5
46396: NEG
46397: PUSH
46398: LD_INT 2
46400: NEG
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 3
46408: NEG
46409: PUSH
46410: LD_INT 2
46412: PUSH
46413: EMPTY
46414: LIST
46415: LIST
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: LIST
46454: LIST
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: LIST
46462: LIST
46463: ST_TO_ADDR
// end ; end ;
46464: GO 46467
46466: POP
// case btype of b_depot , b_warehouse :
46467: LD_VAR 0 1
46471: PUSH
46472: LD_INT 0
46474: DOUBLE
46475: EQUAL
46476: IFTRUE 46486
46478: LD_INT 1
46480: DOUBLE
46481: EQUAL
46482: IFTRUE 46486
46484: GO 46687
46486: POP
// case nation of nation_american :
46487: LD_VAR 0 5
46491: PUSH
46492: LD_INT 1
46494: DOUBLE
46495: EQUAL
46496: IFTRUE 46500
46498: GO 46556
46500: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46501: LD_ADDR_VAR 0 9
46505: PUSH
46506: LD_VAR 0 11
46510: PUSH
46511: LD_VAR 0 12
46515: PUSH
46516: LD_VAR 0 13
46520: PUSH
46521: LD_VAR 0 14
46525: PUSH
46526: LD_VAR 0 15
46530: PUSH
46531: LD_VAR 0 16
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: PUSH
46544: LD_VAR 0 4
46548: PUSH
46549: LD_INT 1
46551: PLUS
46552: ARRAY
46553: ST_TO_ADDR
46554: GO 46685
46556: LD_INT 2
46558: DOUBLE
46559: EQUAL
46560: IFTRUE 46564
46562: GO 46620
46564: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46565: LD_ADDR_VAR 0 9
46569: PUSH
46570: LD_VAR 0 17
46574: PUSH
46575: LD_VAR 0 18
46579: PUSH
46580: LD_VAR 0 19
46584: PUSH
46585: LD_VAR 0 20
46589: PUSH
46590: LD_VAR 0 21
46594: PUSH
46595: LD_VAR 0 22
46599: PUSH
46600: EMPTY
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: PUSH
46608: LD_VAR 0 4
46612: PUSH
46613: LD_INT 1
46615: PLUS
46616: ARRAY
46617: ST_TO_ADDR
46618: GO 46685
46620: LD_INT 3
46622: DOUBLE
46623: EQUAL
46624: IFTRUE 46628
46626: GO 46684
46628: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46629: LD_ADDR_VAR 0 9
46633: PUSH
46634: LD_VAR 0 23
46638: PUSH
46639: LD_VAR 0 24
46643: PUSH
46644: LD_VAR 0 25
46648: PUSH
46649: LD_VAR 0 26
46653: PUSH
46654: LD_VAR 0 27
46658: PUSH
46659: LD_VAR 0 28
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: PUSH
46672: LD_VAR 0 4
46676: PUSH
46677: LD_INT 1
46679: PLUS
46680: ARRAY
46681: ST_TO_ADDR
46682: GO 46685
46684: POP
46685: GO 47234
46687: LD_INT 2
46689: DOUBLE
46690: EQUAL
46691: IFTRUE 46701
46693: LD_INT 3
46695: DOUBLE
46696: EQUAL
46697: IFTRUE 46701
46699: GO 46757
46701: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46702: LD_ADDR_VAR 0 9
46706: PUSH
46707: LD_VAR 0 29
46711: PUSH
46712: LD_VAR 0 30
46716: PUSH
46717: LD_VAR 0 31
46721: PUSH
46722: LD_VAR 0 32
46726: PUSH
46727: LD_VAR 0 33
46731: PUSH
46732: LD_VAR 0 34
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: PUSH
46745: LD_VAR 0 4
46749: PUSH
46750: LD_INT 1
46752: PLUS
46753: ARRAY
46754: ST_TO_ADDR
46755: GO 47234
46757: LD_INT 16
46759: DOUBLE
46760: EQUAL
46761: IFTRUE 46813
46763: LD_INT 17
46765: DOUBLE
46766: EQUAL
46767: IFTRUE 46813
46769: LD_INT 18
46771: DOUBLE
46772: EQUAL
46773: IFTRUE 46813
46775: LD_INT 19
46777: DOUBLE
46778: EQUAL
46779: IFTRUE 46813
46781: LD_INT 20
46783: DOUBLE
46784: EQUAL
46785: IFTRUE 46813
46787: LD_INT 21
46789: DOUBLE
46790: EQUAL
46791: IFTRUE 46813
46793: LD_INT 23
46795: DOUBLE
46796: EQUAL
46797: IFTRUE 46813
46799: LD_INT 24
46801: DOUBLE
46802: EQUAL
46803: IFTRUE 46813
46805: LD_INT 25
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46813
46811: GO 46869
46813: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46814: LD_ADDR_VAR 0 9
46818: PUSH
46819: LD_VAR 0 35
46823: PUSH
46824: LD_VAR 0 36
46828: PUSH
46829: LD_VAR 0 37
46833: PUSH
46834: LD_VAR 0 38
46838: PUSH
46839: LD_VAR 0 39
46843: PUSH
46844: LD_VAR 0 40
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: PUSH
46857: LD_VAR 0 4
46861: PUSH
46862: LD_INT 1
46864: PLUS
46865: ARRAY
46866: ST_TO_ADDR
46867: GO 47234
46869: LD_INT 6
46871: DOUBLE
46872: EQUAL
46873: IFTRUE 46925
46875: LD_INT 7
46877: DOUBLE
46878: EQUAL
46879: IFTRUE 46925
46881: LD_INT 8
46883: DOUBLE
46884: EQUAL
46885: IFTRUE 46925
46887: LD_INT 13
46889: DOUBLE
46890: EQUAL
46891: IFTRUE 46925
46893: LD_INT 12
46895: DOUBLE
46896: EQUAL
46897: IFTRUE 46925
46899: LD_INT 15
46901: DOUBLE
46902: EQUAL
46903: IFTRUE 46925
46905: LD_INT 11
46907: DOUBLE
46908: EQUAL
46909: IFTRUE 46925
46911: LD_INT 14
46913: DOUBLE
46914: EQUAL
46915: IFTRUE 46925
46917: LD_INT 10
46919: DOUBLE
46920: EQUAL
46921: IFTRUE 46925
46923: GO 46981
46925: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46926: LD_ADDR_VAR 0 9
46930: PUSH
46931: LD_VAR 0 41
46935: PUSH
46936: LD_VAR 0 42
46940: PUSH
46941: LD_VAR 0 43
46945: PUSH
46946: LD_VAR 0 44
46950: PUSH
46951: LD_VAR 0 45
46955: PUSH
46956: LD_VAR 0 46
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: PUSH
46969: LD_VAR 0 4
46973: PUSH
46974: LD_INT 1
46976: PLUS
46977: ARRAY
46978: ST_TO_ADDR
46979: GO 47234
46981: LD_INT 36
46983: DOUBLE
46984: EQUAL
46985: IFTRUE 46989
46987: GO 47045
46989: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46990: LD_ADDR_VAR 0 9
46994: PUSH
46995: LD_VAR 0 47
46999: PUSH
47000: LD_VAR 0 48
47004: PUSH
47005: LD_VAR 0 49
47009: PUSH
47010: LD_VAR 0 50
47014: PUSH
47015: LD_VAR 0 51
47019: PUSH
47020: LD_VAR 0 52
47024: PUSH
47025: EMPTY
47026: LIST
47027: LIST
47028: LIST
47029: LIST
47030: LIST
47031: LIST
47032: PUSH
47033: LD_VAR 0 4
47037: PUSH
47038: LD_INT 1
47040: PLUS
47041: ARRAY
47042: ST_TO_ADDR
47043: GO 47234
47045: LD_INT 4
47047: DOUBLE
47048: EQUAL
47049: IFTRUE 47071
47051: LD_INT 5
47053: DOUBLE
47054: EQUAL
47055: IFTRUE 47071
47057: LD_INT 34
47059: DOUBLE
47060: EQUAL
47061: IFTRUE 47071
47063: LD_INT 37
47065: DOUBLE
47066: EQUAL
47067: IFTRUE 47071
47069: GO 47127
47071: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47072: LD_ADDR_VAR 0 9
47076: PUSH
47077: LD_VAR 0 53
47081: PUSH
47082: LD_VAR 0 54
47086: PUSH
47087: LD_VAR 0 55
47091: PUSH
47092: LD_VAR 0 56
47096: PUSH
47097: LD_VAR 0 57
47101: PUSH
47102: LD_VAR 0 58
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: PUSH
47115: LD_VAR 0 4
47119: PUSH
47120: LD_INT 1
47122: PLUS
47123: ARRAY
47124: ST_TO_ADDR
47125: GO 47234
47127: LD_INT 31
47129: DOUBLE
47130: EQUAL
47131: IFTRUE 47177
47133: LD_INT 32
47135: DOUBLE
47136: EQUAL
47137: IFTRUE 47177
47139: LD_INT 33
47141: DOUBLE
47142: EQUAL
47143: IFTRUE 47177
47145: LD_INT 27
47147: DOUBLE
47148: EQUAL
47149: IFTRUE 47177
47151: LD_INT 26
47153: DOUBLE
47154: EQUAL
47155: IFTRUE 47177
47157: LD_INT 28
47159: DOUBLE
47160: EQUAL
47161: IFTRUE 47177
47163: LD_INT 29
47165: DOUBLE
47166: EQUAL
47167: IFTRUE 47177
47169: LD_INT 30
47171: DOUBLE
47172: EQUAL
47173: IFTRUE 47177
47175: GO 47233
47177: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47178: LD_ADDR_VAR 0 9
47182: PUSH
47183: LD_VAR 0 59
47187: PUSH
47188: LD_VAR 0 60
47192: PUSH
47193: LD_VAR 0 61
47197: PUSH
47198: LD_VAR 0 62
47202: PUSH
47203: LD_VAR 0 63
47207: PUSH
47208: LD_VAR 0 64
47212: PUSH
47213: EMPTY
47214: LIST
47215: LIST
47216: LIST
47217: LIST
47218: LIST
47219: LIST
47220: PUSH
47221: LD_VAR 0 4
47225: PUSH
47226: LD_INT 1
47228: PLUS
47229: ARRAY
47230: ST_TO_ADDR
47231: GO 47234
47233: POP
// temp_list2 = [ ] ;
47234: LD_ADDR_VAR 0 10
47238: PUSH
47239: EMPTY
47240: ST_TO_ADDR
// for i in temp_list do
47241: LD_ADDR_VAR 0 8
47245: PUSH
47246: LD_VAR 0 9
47250: PUSH
47251: FOR_IN
47252: IFFALSE 47304
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47254: LD_ADDR_VAR 0 10
47258: PUSH
47259: LD_VAR 0 10
47263: PUSH
47264: LD_VAR 0 8
47268: PUSH
47269: LD_INT 1
47271: ARRAY
47272: PUSH
47273: LD_VAR 0 2
47277: PLUS
47278: PUSH
47279: LD_VAR 0 8
47283: PUSH
47284: LD_INT 2
47286: ARRAY
47287: PUSH
47288: LD_VAR 0 3
47292: PLUS
47293: PUSH
47294: EMPTY
47295: LIST
47296: LIST
47297: PUSH
47298: EMPTY
47299: LIST
47300: ADD
47301: ST_TO_ADDR
47302: GO 47251
47304: POP
47305: POP
// result = temp_list2 ;
47306: LD_ADDR_VAR 0 7
47310: PUSH
47311: LD_VAR 0 10
47315: ST_TO_ADDR
// end ;
47316: LD_VAR 0 7
47320: RET
// export function EnemyInRange ( unit , dist ) ; begin
47321: LD_INT 0
47323: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47324: LD_ADDR_VAR 0 3
47328: PUSH
47329: LD_VAR 0 1
47333: PPUSH
47334: CALL_OW 255
47338: PPUSH
47339: LD_VAR 0 1
47343: PPUSH
47344: CALL_OW 250
47348: PPUSH
47349: LD_VAR 0 1
47353: PPUSH
47354: CALL_OW 251
47358: PPUSH
47359: LD_VAR 0 2
47363: PPUSH
47364: CALL 21449 0 4
47368: PUSH
47369: LD_INT 4
47371: ARRAY
47372: ST_TO_ADDR
// end ;
47373: LD_VAR 0 3
47377: RET
// export function PlayerSeeMe ( unit ) ; begin
47378: LD_INT 0
47380: PPUSH
// result := See ( your_side , unit ) ;
47381: LD_ADDR_VAR 0 2
47385: PUSH
47386: LD_OWVAR 2
47390: PPUSH
47391: LD_VAR 0 1
47395: PPUSH
47396: CALL_OW 292
47400: ST_TO_ADDR
// end ;
47401: LD_VAR 0 2
47405: RET
// export function ReverseDir ( unit ) ; begin
47406: LD_INT 0
47408: PPUSH
// if not unit then
47409: LD_VAR 0 1
47413: NOT
47414: IFFALSE 47418
// exit ;
47416: GO 47464
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47418: LD_ADDR_VAR 0 2
47422: PUSH
47423: LD_INT 3
47425: PUSH
47426: LD_INT 4
47428: PUSH
47429: LD_INT 5
47431: PUSH
47432: LD_INT 0
47434: PUSH
47435: LD_INT 1
47437: PUSH
47438: LD_INT 2
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: PUSH
47449: LD_VAR 0 1
47453: PPUSH
47454: CALL_OW 254
47458: PUSH
47459: LD_INT 1
47461: PLUS
47462: ARRAY
47463: ST_TO_ADDR
// end ;
47464: LD_VAR 0 2
47468: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47469: LD_INT 0
47471: PPUSH
47472: PPUSH
47473: PPUSH
47474: PPUSH
47475: PPUSH
// if not hexes then
47476: LD_VAR 0 2
47480: NOT
47481: IFFALSE 47485
// exit ;
47483: GO 47633
// dist := 9999 ;
47485: LD_ADDR_VAR 0 5
47489: PUSH
47490: LD_INT 9999
47492: ST_TO_ADDR
// for i = 1 to hexes do
47493: LD_ADDR_VAR 0 4
47497: PUSH
47498: DOUBLE
47499: LD_INT 1
47501: DEC
47502: ST_TO_ADDR
47503: LD_VAR 0 2
47507: PUSH
47508: FOR_TO
47509: IFFALSE 47621
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47511: LD_VAR 0 1
47515: PPUSH
47516: LD_VAR 0 2
47520: PUSH
47521: LD_VAR 0 4
47525: ARRAY
47526: PUSH
47527: LD_INT 1
47529: ARRAY
47530: PPUSH
47531: LD_VAR 0 2
47535: PUSH
47536: LD_VAR 0 4
47540: ARRAY
47541: PUSH
47542: LD_INT 2
47544: ARRAY
47545: PPUSH
47546: CALL_OW 297
47550: PUSH
47551: LD_VAR 0 5
47555: LESS
47556: IFFALSE 47619
// begin hex := hexes [ i ] ;
47558: LD_ADDR_VAR 0 7
47562: PUSH
47563: LD_VAR 0 2
47567: PUSH
47568: LD_VAR 0 4
47572: ARRAY
47573: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47574: LD_ADDR_VAR 0 5
47578: PUSH
47579: LD_VAR 0 1
47583: PPUSH
47584: LD_VAR 0 2
47588: PUSH
47589: LD_VAR 0 4
47593: ARRAY
47594: PUSH
47595: LD_INT 1
47597: ARRAY
47598: PPUSH
47599: LD_VAR 0 2
47603: PUSH
47604: LD_VAR 0 4
47608: ARRAY
47609: PUSH
47610: LD_INT 2
47612: ARRAY
47613: PPUSH
47614: CALL_OW 297
47618: ST_TO_ADDR
// end ; end ;
47619: GO 47508
47621: POP
47622: POP
// result := hex ;
47623: LD_ADDR_VAR 0 3
47627: PUSH
47628: LD_VAR 0 7
47632: ST_TO_ADDR
// end ;
47633: LD_VAR 0 3
47637: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47638: LD_INT 0
47640: PPUSH
47641: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47642: LD_VAR 0 1
47646: NOT
47647: PUSH
47648: LD_VAR 0 1
47652: PUSH
47653: LD_INT 21
47655: PUSH
47656: LD_INT 2
47658: PUSH
47659: EMPTY
47660: LIST
47661: LIST
47662: PUSH
47663: LD_INT 23
47665: PUSH
47666: LD_INT 2
47668: PUSH
47669: EMPTY
47670: LIST
47671: LIST
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PPUSH
47677: CALL_OW 69
47681: IN
47682: NOT
47683: OR
47684: IFFALSE 47688
// exit ;
47686: GO 47735
// for i = 1 to 3 do
47688: LD_ADDR_VAR 0 3
47692: PUSH
47693: DOUBLE
47694: LD_INT 1
47696: DEC
47697: ST_TO_ADDR
47698: LD_INT 3
47700: PUSH
47701: FOR_TO
47702: IFFALSE 47733
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47704: LD_VAR 0 1
47708: PPUSH
47709: CALL_OW 250
47713: PPUSH
47714: LD_VAR 0 1
47718: PPUSH
47719: CALL_OW 251
47723: PPUSH
47724: LD_INT 1
47726: PPUSH
47727: CALL_OW 453
47731: GO 47701
47733: POP
47734: POP
// end ;
47735: LD_VAR 0 2
47739: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47740: LD_INT 0
47742: PPUSH
47743: PPUSH
47744: PPUSH
47745: PPUSH
47746: PPUSH
47747: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47748: LD_VAR 0 1
47752: NOT
47753: PUSH
47754: LD_VAR 0 2
47758: NOT
47759: OR
47760: PUSH
47761: LD_VAR 0 1
47765: PPUSH
47766: CALL_OW 314
47770: OR
47771: IFFALSE 47775
// exit ;
47773: GO 48216
// x := GetX ( enemy_unit ) ;
47775: LD_ADDR_VAR 0 7
47779: PUSH
47780: LD_VAR 0 2
47784: PPUSH
47785: CALL_OW 250
47789: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47790: LD_ADDR_VAR 0 8
47794: PUSH
47795: LD_VAR 0 2
47799: PPUSH
47800: CALL_OW 251
47804: ST_TO_ADDR
// if not x or not y then
47805: LD_VAR 0 7
47809: NOT
47810: PUSH
47811: LD_VAR 0 8
47815: NOT
47816: OR
47817: IFFALSE 47821
// exit ;
47819: GO 48216
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47821: LD_ADDR_VAR 0 6
47825: PUSH
47826: LD_VAR 0 7
47830: PPUSH
47831: LD_INT 0
47833: PPUSH
47834: LD_INT 4
47836: PPUSH
47837: CALL_OW 272
47841: PUSH
47842: LD_VAR 0 8
47846: PPUSH
47847: LD_INT 0
47849: PPUSH
47850: LD_INT 4
47852: PPUSH
47853: CALL_OW 273
47857: PUSH
47858: EMPTY
47859: LIST
47860: LIST
47861: PUSH
47862: LD_VAR 0 7
47866: PPUSH
47867: LD_INT 1
47869: PPUSH
47870: LD_INT 4
47872: PPUSH
47873: CALL_OW 272
47877: PUSH
47878: LD_VAR 0 8
47882: PPUSH
47883: LD_INT 1
47885: PPUSH
47886: LD_INT 4
47888: PPUSH
47889: CALL_OW 273
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: PUSH
47898: LD_VAR 0 7
47902: PPUSH
47903: LD_INT 2
47905: PPUSH
47906: LD_INT 4
47908: PPUSH
47909: CALL_OW 272
47913: PUSH
47914: LD_VAR 0 8
47918: PPUSH
47919: LD_INT 2
47921: PPUSH
47922: LD_INT 4
47924: PPUSH
47925: CALL_OW 273
47929: PUSH
47930: EMPTY
47931: LIST
47932: LIST
47933: PUSH
47934: LD_VAR 0 7
47938: PPUSH
47939: LD_INT 3
47941: PPUSH
47942: LD_INT 4
47944: PPUSH
47945: CALL_OW 272
47949: PUSH
47950: LD_VAR 0 8
47954: PPUSH
47955: LD_INT 3
47957: PPUSH
47958: LD_INT 4
47960: PPUSH
47961: CALL_OW 273
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: PUSH
47970: LD_VAR 0 7
47974: PPUSH
47975: LD_INT 4
47977: PPUSH
47978: LD_INT 4
47980: PPUSH
47981: CALL_OW 272
47985: PUSH
47986: LD_VAR 0 8
47990: PPUSH
47991: LD_INT 4
47993: PPUSH
47994: LD_INT 4
47996: PPUSH
47997: CALL_OW 273
48001: PUSH
48002: EMPTY
48003: LIST
48004: LIST
48005: PUSH
48006: LD_VAR 0 7
48010: PPUSH
48011: LD_INT 5
48013: PPUSH
48014: LD_INT 4
48016: PPUSH
48017: CALL_OW 272
48021: PUSH
48022: LD_VAR 0 8
48026: PPUSH
48027: LD_INT 5
48029: PPUSH
48030: LD_INT 4
48032: PPUSH
48033: CALL_OW 273
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: ST_TO_ADDR
// for i = tmp downto 1 do
48050: LD_ADDR_VAR 0 4
48054: PUSH
48055: DOUBLE
48056: LD_VAR 0 6
48060: INC
48061: ST_TO_ADDR
48062: LD_INT 1
48064: PUSH
48065: FOR_DOWNTO
48066: IFFALSE 48167
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48068: LD_VAR 0 6
48072: PUSH
48073: LD_VAR 0 4
48077: ARRAY
48078: PUSH
48079: LD_INT 1
48081: ARRAY
48082: PPUSH
48083: LD_VAR 0 6
48087: PUSH
48088: LD_VAR 0 4
48092: ARRAY
48093: PUSH
48094: LD_INT 2
48096: ARRAY
48097: PPUSH
48098: CALL_OW 488
48102: NOT
48103: PUSH
48104: LD_VAR 0 6
48108: PUSH
48109: LD_VAR 0 4
48113: ARRAY
48114: PUSH
48115: LD_INT 1
48117: ARRAY
48118: PPUSH
48119: LD_VAR 0 6
48123: PUSH
48124: LD_VAR 0 4
48128: ARRAY
48129: PUSH
48130: LD_INT 2
48132: ARRAY
48133: PPUSH
48134: CALL_OW 428
48138: PUSH
48139: LD_INT 0
48141: NONEQUAL
48142: OR
48143: IFFALSE 48165
// tmp := Delete ( tmp , i ) ;
48145: LD_ADDR_VAR 0 6
48149: PUSH
48150: LD_VAR 0 6
48154: PPUSH
48155: LD_VAR 0 4
48159: PPUSH
48160: CALL_OW 3
48164: ST_TO_ADDR
48165: GO 48065
48167: POP
48168: POP
// j := GetClosestHex ( unit , tmp ) ;
48169: LD_ADDR_VAR 0 5
48173: PUSH
48174: LD_VAR 0 1
48178: PPUSH
48179: LD_VAR 0 6
48183: PPUSH
48184: CALL 47469 0 2
48188: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48189: LD_VAR 0 1
48193: PPUSH
48194: LD_VAR 0 5
48198: PUSH
48199: LD_INT 1
48201: ARRAY
48202: PPUSH
48203: LD_VAR 0 5
48207: PUSH
48208: LD_INT 2
48210: ARRAY
48211: PPUSH
48212: CALL_OW 111
// end ;
48216: LD_VAR 0 3
48220: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48221: LD_INT 0
48223: PPUSH
48224: PPUSH
48225: PPUSH
// uc_side = 0 ;
48226: LD_ADDR_OWVAR 20
48230: PUSH
48231: LD_INT 0
48233: ST_TO_ADDR
// uc_nation = 0 ;
48234: LD_ADDR_OWVAR 21
48238: PUSH
48239: LD_INT 0
48241: ST_TO_ADDR
// InitHc ;
48242: CALL_OW 19
// InitVc ;
48246: CALL_OW 20
// if mastodonts then
48250: LD_VAR 0 6
48254: IFFALSE 48321
// for i = 1 to mastodonts do
48256: LD_ADDR_VAR 0 11
48260: PUSH
48261: DOUBLE
48262: LD_INT 1
48264: DEC
48265: ST_TO_ADDR
48266: LD_VAR 0 6
48270: PUSH
48271: FOR_TO
48272: IFFALSE 48319
// begin vc_chassis := 31 ;
48274: LD_ADDR_OWVAR 37
48278: PUSH
48279: LD_INT 31
48281: ST_TO_ADDR
// vc_control := control_rider ;
48282: LD_ADDR_OWVAR 38
48286: PUSH
48287: LD_INT 4
48289: ST_TO_ADDR
// animal := CreateVehicle ;
48290: LD_ADDR_VAR 0 12
48294: PUSH
48295: CALL_OW 45
48299: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48300: LD_VAR 0 12
48304: PPUSH
48305: LD_VAR 0 8
48309: PPUSH
48310: LD_INT 0
48312: PPUSH
48313: CALL 55027 0 3
// end ;
48317: GO 48271
48319: POP
48320: POP
// if horses then
48321: LD_VAR 0 5
48325: IFFALSE 48392
// for i = 1 to horses do
48327: LD_ADDR_VAR 0 11
48331: PUSH
48332: DOUBLE
48333: LD_INT 1
48335: DEC
48336: ST_TO_ADDR
48337: LD_VAR 0 5
48341: PUSH
48342: FOR_TO
48343: IFFALSE 48390
// begin hc_class := 21 ;
48345: LD_ADDR_OWVAR 28
48349: PUSH
48350: LD_INT 21
48352: ST_TO_ADDR
// hc_gallery :=  ;
48353: LD_ADDR_OWVAR 33
48357: PUSH
48358: LD_STRING 
48360: ST_TO_ADDR
// animal := CreateHuman ;
48361: LD_ADDR_VAR 0 12
48365: PUSH
48366: CALL_OW 44
48370: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48371: LD_VAR 0 12
48375: PPUSH
48376: LD_VAR 0 8
48380: PPUSH
48381: LD_INT 0
48383: PPUSH
48384: CALL 55027 0 3
// end ;
48388: GO 48342
48390: POP
48391: POP
// if birds then
48392: LD_VAR 0 1
48396: IFFALSE 48463
// for i = 1 to birds do
48398: LD_ADDR_VAR 0 11
48402: PUSH
48403: DOUBLE
48404: LD_INT 1
48406: DEC
48407: ST_TO_ADDR
48408: LD_VAR 0 1
48412: PUSH
48413: FOR_TO
48414: IFFALSE 48461
// begin hc_class = 18 ;
48416: LD_ADDR_OWVAR 28
48420: PUSH
48421: LD_INT 18
48423: ST_TO_ADDR
// hc_gallery =  ;
48424: LD_ADDR_OWVAR 33
48428: PUSH
48429: LD_STRING 
48431: ST_TO_ADDR
// animal := CreateHuman ;
48432: LD_ADDR_VAR 0 12
48436: PUSH
48437: CALL_OW 44
48441: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48442: LD_VAR 0 12
48446: PPUSH
48447: LD_VAR 0 8
48451: PPUSH
48452: LD_INT 0
48454: PPUSH
48455: CALL 55027 0 3
// end ;
48459: GO 48413
48461: POP
48462: POP
// if tigers then
48463: LD_VAR 0 2
48467: IFFALSE 48551
// for i = 1 to tigers do
48469: LD_ADDR_VAR 0 11
48473: PUSH
48474: DOUBLE
48475: LD_INT 1
48477: DEC
48478: ST_TO_ADDR
48479: LD_VAR 0 2
48483: PUSH
48484: FOR_TO
48485: IFFALSE 48549
// begin hc_class = class_tiger ;
48487: LD_ADDR_OWVAR 28
48491: PUSH
48492: LD_INT 14
48494: ST_TO_ADDR
// hc_gallery =  ;
48495: LD_ADDR_OWVAR 33
48499: PUSH
48500: LD_STRING 
48502: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48503: LD_ADDR_OWVAR 35
48507: PUSH
48508: LD_INT 7
48510: NEG
48511: PPUSH
48512: LD_INT 7
48514: PPUSH
48515: CALL_OW 12
48519: ST_TO_ADDR
// animal := CreateHuman ;
48520: LD_ADDR_VAR 0 12
48524: PUSH
48525: CALL_OW 44
48529: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48530: LD_VAR 0 12
48534: PPUSH
48535: LD_VAR 0 8
48539: PPUSH
48540: LD_INT 0
48542: PPUSH
48543: CALL 55027 0 3
// end ;
48547: GO 48484
48549: POP
48550: POP
// if apemans then
48551: LD_VAR 0 3
48555: IFFALSE 48678
// for i = 1 to apemans do
48557: LD_ADDR_VAR 0 11
48561: PUSH
48562: DOUBLE
48563: LD_INT 1
48565: DEC
48566: ST_TO_ADDR
48567: LD_VAR 0 3
48571: PUSH
48572: FOR_TO
48573: IFFALSE 48676
// begin hc_class = class_apeman ;
48575: LD_ADDR_OWVAR 28
48579: PUSH
48580: LD_INT 12
48582: ST_TO_ADDR
// hc_gallery =  ;
48583: LD_ADDR_OWVAR 33
48587: PUSH
48588: LD_STRING 
48590: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48591: LD_ADDR_OWVAR 35
48595: PUSH
48596: LD_INT 5
48598: NEG
48599: PPUSH
48600: LD_INT 5
48602: PPUSH
48603: CALL_OW 12
48607: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48608: LD_ADDR_OWVAR 31
48612: PUSH
48613: LD_INT 1
48615: PPUSH
48616: LD_INT 3
48618: PPUSH
48619: CALL_OW 12
48623: PUSH
48624: LD_INT 1
48626: PPUSH
48627: LD_INT 3
48629: PPUSH
48630: CALL_OW 12
48634: PUSH
48635: LD_INT 0
48637: PUSH
48638: LD_INT 0
48640: PUSH
48641: EMPTY
48642: LIST
48643: LIST
48644: LIST
48645: LIST
48646: ST_TO_ADDR
// animal := CreateHuman ;
48647: LD_ADDR_VAR 0 12
48651: PUSH
48652: CALL_OW 44
48656: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48657: LD_VAR 0 12
48661: PPUSH
48662: LD_VAR 0 8
48666: PPUSH
48667: LD_INT 0
48669: PPUSH
48670: CALL 55027 0 3
// end ;
48674: GO 48572
48676: POP
48677: POP
// if enchidnas then
48678: LD_VAR 0 4
48682: IFFALSE 48749
// for i = 1 to enchidnas do
48684: LD_ADDR_VAR 0 11
48688: PUSH
48689: DOUBLE
48690: LD_INT 1
48692: DEC
48693: ST_TO_ADDR
48694: LD_VAR 0 4
48698: PUSH
48699: FOR_TO
48700: IFFALSE 48747
// begin hc_class = 13 ;
48702: LD_ADDR_OWVAR 28
48706: PUSH
48707: LD_INT 13
48709: ST_TO_ADDR
// hc_gallery =  ;
48710: LD_ADDR_OWVAR 33
48714: PUSH
48715: LD_STRING 
48717: ST_TO_ADDR
// animal := CreateHuman ;
48718: LD_ADDR_VAR 0 12
48722: PUSH
48723: CALL_OW 44
48727: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48728: LD_VAR 0 12
48732: PPUSH
48733: LD_VAR 0 8
48737: PPUSH
48738: LD_INT 0
48740: PPUSH
48741: CALL 55027 0 3
// end ;
48745: GO 48699
48747: POP
48748: POP
// if fishes then
48749: LD_VAR 0 7
48753: IFFALSE 48820
// for i = 1 to fishes do
48755: LD_ADDR_VAR 0 11
48759: PUSH
48760: DOUBLE
48761: LD_INT 1
48763: DEC
48764: ST_TO_ADDR
48765: LD_VAR 0 7
48769: PUSH
48770: FOR_TO
48771: IFFALSE 48818
// begin hc_class = 20 ;
48773: LD_ADDR_OWVAR 28
48777: PUSH
48778: LD_INT 20
48780: ST_TO_ADDR
// hc_gallery =  ;
48781: LD_ADDR_OWVAR 33
48785: PUSH
48786: LD_STRING 
48788: ST_TO_ADDR
// animal := CreateHuman ;
48789: LD_ADDR_VAR 0 12
48793: PUSH
48794: CALL_OW 44
48798: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48799: LD_VAR 0 12
48803: PPUSH
48804: LD_VAR 0 9
48808: PPUSH
48809: LD_INT 0
48811: PPUSH
48812: CALL 55027 0 3
// end ;
48816: GO 48770
48818: POP
48819: POP
// end ;
48820: LD_VAR 0 10
48824: RET
// export function WantHeal ( sci , unit ) ; begin
48825: LD_INT 0
48827: PPUSH
// if GetTaskList ( sci ) > 0 then
48828: LD_VAR 0 1
48832: PPUSH
48833: CALL_OW 437
48837: PUSH
48838: LD_INT 0
48840: GREATER
48841: IFFALSE 48911
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48843: LD_VAR 0 1
48847: PPUSH
48848: CALL_OW 437
48852: PUSH
48853: LD_INT 1
48855: ARRAY
48856: PUSH
48857: LD_INT 1
48859: ARRAY
48860: PUSH
48861: LD_STRING l
48863: EQUAL
48864: PUSH
48865: LD_VAR 0 1
48869: PPUSH
48870: CALL_OW 437
48874: PUSH
48875: LD_INT 1
48877: ARRAY
48878: PUSH
48879: LD_INT 4
48881: ARRAY
48882: PUSH
48883: LD_VAR 0 2
48887: EQUAL
48888: AND
48889: IFFALSE 48901
// result := true else
48891: LD_ADDR_VAR 0 3
48895: PUSH
48896: LD_INT 1
48898: ST_TO_ADDR
48899: GO 48909
// result := false ;
48901: LD_ADDR_VAR 0 3
48905: PUSH
48906: LD_INT 0
48908: ST_TO_ADDR
// end else
48909: GO 48919
// result := false ;
48911: LD_ADDR_VAR 0 3
48915: PUSH
48916: LD_INT 0
48918: ST_TO_ADDR
// end ;
48919: LD_VAR 0 3
48923: RET
// export function HealTarget ( sci ) ; begin
48924: LD_INT 0
48926: PPUSH
// if not sci then
48927: LD_VAR 0 1
48931: NOT
48932: IFFALSE 48936
// exit ;
48934: GO 49001
// result := 0 ;
48936: LD_ADDR_VAR 0 2
48940: PUSH
48941: LD_INT 0
48943: ST_TO_ADDR
// if GetTaskList ( sci ) then
48944: LD_VAR 0 1
48948: PPUSH
48949: CALL_OW 437
48953: IFFALSE 49001
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48955: LD_VAR 0 1
48959: PPUSH
48960: CALL_OW 437
48964: PUSH
48965: LD_INT 1
48967: ARRAY
48968: PUSH
48969: LD_INT 1
48971: ARRAY
48972: PUSH
48973: LD_STRING l
48975: EQUAL
48976: IFFALSE 49001
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48978: LD_ADDR_VAR 0 2
48982: PUSH
48983: LD_VAR 0 1
48987: PPUSH
48988: CALL_OW 437
48992: PUSH
48993: LD_INT 1
48995: ARRAY
48996: PUSH
48997: LD_INT 4
48999: ARRAY
49000: ST_TO_ADDR
// end ;
49001: LD_VAR 0 2
49005: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
49006: LD_INT 0
49008: PPUSH
49009: PPUSH
49010: PPUSH
49011: PPUSH
49012: PPUSH
49013: PPUSH
49014: PPUSH
49015: PPUSH
49016: PPUSH
49017: PPUSH
49018: PPUSH
49019: PPUSH
49020: PPUSH
49021: PPUSH
49022: PPUSH
49023: PPUSH
49024: PPUSH
49025: PPUSH
49026: PPUSH
49027: PPUSH
49028: PPUSH
49029: PPUSH
49030: PPUSH
49031: PPUSH
49032: PPUSH
49033: PPUSH
49034: PPUSH
49035: PPUSH
49036: PPUSH
49037: PPUSH
49038: PPUSH
49039: PPUSH
49040: PPUSH
// if not list then
49041: LD_VAR 0 1
49045: NOT
49046: IFFALSE 49050
// exit ;
49048: GO 53638
// base := list [ 1 ] ;
49050: LD_ADDR_VAR 0 3
49054: PUSH
49055: LD_VAR 0 1
49059: PUSH
49060: LD_INT 1
49062: ARRAY
49063: ST_TO_ADDR
// group := list [ 2 ] ;
49064: LD_ADDR_VAR 0 4
49068: PUSH
49069: LD_VAR 0 1
49073: PUSH
49074: LD_INT 2
49076: ARRAY
49077: ST_TO_ADDR
// path := list [ 3 ] ;
49078: LD_ADDR_VAR 0 5
49082: PUSH
49083: LD_VAR 0 1
49087: PUSH
49088: LD_INT 3
49090: ARRAY
49091: ST_TO_ADDR
// flags := list [ 4 ] ;
49092: LD_ADDR_VAR 0 6
49096: PUSH
49097: LD_VAR 0 1
49101: PUSH
49102: LD_INT 4
49104: ARRAY
49105: ST_TO_ADDR
// mined := [ ] ;
49106: LD_ADDR_VAR 0 27
49110: PUSH
49111: EMPTY
49112: ST_TO_ADDR
// bombed := [ ] ;
49113: LD_ADDR_VAR 0 28
49117: PUSH
49118: EMPTY
49119: ST_TO_ADDR
// healers := [ ] ;
49120: LD_ADDR_VAR 0 31
49124: PUSH
49125: EMPTY
49126: ST_TO_ADDR
// to_heal := [ ] ;
49127: LD_ADDR_VAR 0 30
49131: PUSH
49132: EMPTY
49133: ST_TO_ADDR
// repairs := [ ] ;
49134: LD_ADDR_VAR 0 33
49138: PUSH
49139: EMPTY
49140: ST_TO_ADDR
// to_repair := [ ] ;
49141: LD_ADDR_VAR 0 32
49145: PUSH
49146: EMPTY
49147: ST_TO_ADDR
// if not group or not path then
49148: LD_VAR 0 4
49152: NOT
49153: PUSH
49154: LD_VAR 0 5
49158: NOT
49159: OR
49160: IFFALSE 49164
// exit ;
49162: GO 53638
// if flags then
49164: LD_VAR 0 6
49168: IFFALSE 49312
// begin f_ignore_area := flags [ 1 ] ;
49170: LD_ADDR_VAR 0 17
49174: PUSH
49175: LD_VAR 0 6
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49184: LD_ADDR_VAR 0 18
49188: PUSH
49189: LD_VAR 0 6
49193: PUSH
49194: LD_INT 2
49196: ARRAY
49197: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49198: LD_ADDR_VAR 0 19
49202: PUSH
49203: LD_VAR 0 6
49207: PUSH
49208: LD_INT 3
49210: ARRAY
49211: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49212: LD_ADDR_VAR 0 20
49216: PUSH
49217: LD_VAR 0 6
49221: PUSH
49222: LD_INT 4
49224: ARRAY
49225: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49226: LD_ADDR_VAR 0 21
49230: PUSH
49231: LD_VAR 0 6
49235: PUSH
49236: LD_INT 5
49238: ARRAY
49239: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49240: LD_ADDR_VAR 0 22
49244: PUSH
49245: LD_VAR 0 6
49249: PUSH
49250: LD_INT 6
49252: ARRAY
49253: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49254: LD_ADDR_VAR 0 23
49258: PUSH
49259: LD_VAR 0 6
49263: PUSH
49264: LD_INT 7
49266: ARRAY
49267: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49268: LD_ADDR_VAR 0 24
49272: PUSH
49273: LD_VAR 0 6
49277: PUSH
49278: LD_INT 8
49280: ARRAY
49281: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49282: LD_ADDR_VAR 0 25
49286: PUSH
49287: LD_VAR 0 6
49291: PUSH
49292: LD_INT 9
49294: ARRAY
49295: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49296: LD_ADDR_VAR 0 26
49300: PUSH
49301: LD_VAR 0 6
49305: PUSH
49306: LD_INT 10
49308: ARRAY
49309: ST_TO_ADDR
// end else
49310: GO 49392
// begin f_ignore_area := false ;
49312: LD_ADDR_VAR 0 17
49316: PUSH
49317: LD_INT 0
49319: ST_TO_ADDR
// f_capture := false ;
49320: LD_ADDR_VAR 0 18
49324: PUSH
49325: LD_INT 0
49327: ST_TO_ADDR
// f_ignore_civ := false ;
49328: LD_ADDR_VAR 0 19
49332: PUSH
49333: LD_INT 0
49335: ST_TO_ADDR
// f_murder := false ;
49336: LD_ADDR_VAR 0 20
49340: PUSH
49341: LD_INT 0
49343: ST_TO_ADDR
// f_mines := false ;
49344: LD_ADDR_VAR 0 21
49348: PUSH
49349: LD_INT 0
49351: ST_TO_ADDR
// f_repair := false ;
49352: LD_ADDR_VAR 0 22
49356: PUSH
49357: LD_INT 0
49359: ST_TO_ADDR
// f_heal := false ;
49360: LD_ADDR_VAR 0 23
49364: PUSH
49365: LD_INT 0
49367: ST_TO_ADDR
// f_spacetime := false ;
49368: LD_ADDR_VAR 0 24
49372: PUSH
49373: LD_INT 0
49375: ST_TO_ADDR
// f_attack_depot := false ;
49376: LD_ADDR_VAR 0 25
49380: PUSH
49381: LD_INT 0
49383: ST_TO_ADDR
// f_crawl := false ;
49384: LD_ADDR_VAR 0 26
49388: PUSH
49389: LD_INT 0
49391: ST_TO_ADDR
// end ; if f_heal then
49392: LD_VAR 0 23
49396: IFFALSE 49423
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49398: LD_ADDR_VAR 0 31
49402: PUSH
49403: LD_VAR 0 4
49407: PPUSH
49408: LD_INT 25
49410: PUSH
49411: LD_INT 4
49413: PUSH
49414: EMPTY
49415: LIST
49416: LIST
49417: PPUSH
49418: CALL_OW 72
49422: ST_TO_ADDR
// if f_repair then
49423: LD_VAR 0 22
49427: IFFALSE 49454
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49429: LD_ADDR_VAR 0 33
49433: PUSH
49434: LD_VAR 0 4
49438: PPUSH
49439: LD_INT 25
49441: PUSH
49442: LD_INT 3
49444: PUSH
49445: EMPTY
49446: LIST
49447: LIST
49448: PPUSH
49449: CALL_OW 72
49453: ST_TO_ADDR
// units_path := [ ] ;
49454: LD_ADDR_VAR 0 16
49458: PUSH
49459: EMPTY
49460: ST_TO_ADDR
// for i = 1 to group do
49461: LD_ADDR_VAR 0 7
49465: PUSH
49466: DOUBLE
49467: LD_INT 1
49469: DEC
49470: ST_TO_ADDR
49471: LD_VAR 0 4
49475: PUSH
49476: FOR_TO
49477: IFFALSE 49506
// units_path := Replace ( units_path , i , path ) ;
49479: LD_ADDR_VAR 0 16
49483: PUSH
49484: LD_VAR 0 16
49488: PPUSH
49489: LD_VAR 0 7
49493: PPUSH
49494: LD_VAR 0 5
49498: PPUSH
49499: CALL_OW 1
49503: ST_TO_ADDR
49504: GO 49476
49506: POP
49507: POP
// repeat for i = group downto 1 do
49508: LD_ADDR_VAR 0 7
49512: PUSH
49513: DOUBLE
49514: LD_VAR 0 4
49518: INC
49519: ST_TO_ADDR
49520: LD_INT 1
49522: PUSH
49523: FOR_DOWNTO
49524: IFFALSE 53620
// begin wait ( 5 ) ;
49526: LD_INT 5
49528: PPUSH
49529: CALL_OW 67
// tmp := [ ] ;
49533: LD_ADDR_VAR 0 14
49537: PUSH
49538: EMPTY
49539: ST_TO_ADDR
// attacking := false ;
49540: LD_ADDR_VAR 0 29
49544: PUSH
49545: LD_INT 0
49547: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49548: LD_VAR 0 4
49552: PUSH
49553: LD_VAR 0 7
49557: ARRAY
49558: PPUSH
49559: CALL_OW 301
49563: PUSH
49564: LD_VAR 0 4
49568: PUSH
49569: LD_VAR 0 7
49573: ARRAY
49574: NOT
49575: OR
49576: IFFALSE 49685
// begin if GetType ( group [ i ] ) = unit_human then
49578: LD_VAR 0 4
49582: PUSH
49583: LD_VAR 0 7
49587: ARRAY
49588: PPUSH
49589: CALL_OW 247
49593: PUSH
49594: LD_INT 1
49596: EQUAL
49597: IFFALSE 49643
// begin to_heal := to_heal diff group [ i ] ;
49599: LD_ADDR_VAR 0 30
49603: PUSH
49604: LD_VAR 0 30
49608: PUSH
49609: LD_VAR 0 4
49613: PUSH
49614: LD_VAR 0 7
49618: ARRAY
49619: DIFF
49620: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49621: LD_ADDR_VAR 0 31
49625: PUSH
49626: LD_VAR 0 31
49630: PUSH
49631: LD_VAR 0 4
49635: PUSH
49636: LD_VAR 0 7
49640: ARRAY
49641: DIFF
49642: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49643: LD_ADDR_VAR 0 4
49647: PUSH
49648: LD_VAR 0 4
49652: PPUSH
49653: LD_VAR 0 7
49657: PPUSH
49658: CALL_OW 3
49662: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49663: LD_ADDR_VAR 0 16
49667: PUSH
49668: LD_VAR 0 16
49672: PPUSH
49673: LD_VAR 0 7
49677: PPUSH
49678: CALL_OW 3
49682: ST_TO_ADDR
// continue ;
49683: GO 49523
// end ; if f_repair then
49685: LD_VAR 0 22
49689: IFFALSE 50178
// begin if GetType ( group [ i ] ) = unit_vehicle then
49691: LD_VAR 0 4
49695: PUSH
49696: LD_VAR 0 7
49700: ARRAY
49701: PPUSH
49702: CALL_OW 247
49706: PUSH
49707: LD_INT 2
49709: EQUAL
49710: IFFALSE 49900
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49712: LD_VAR 0 4
49716: PUSH
49717: LD_VAR 0 7
49721: ARRAY
49722: PPUSH
49723: CALL_OW 256
49727: PUSH
49728: LD_INT 700
49730: LESS
49731: PUSH
49732: LD_VAR 0 4
49736: PUSH
49737: LD_VAR 0 7
49741: ARRAY
49742: PUSH
49743: LD_VAR 0 32
49747: IN
49748: NOT
49749: AND
49750: IFFALSE 49774
// to_repair := to_repair union group [ i ] ;
49752: LD_ADDR_VAR 0 32
49756: PUSH
49757: LD_VAR 0 32
49761: PUSH
49762: LD_VAR 0 4
49766: PUSH
49767: LD_VAR 0 7
49771: ARRAY
49772: UNION
49773: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49774: LD_VAR 0 4
49778: PUSH
49779: LD_VAR 0 7
49783: ARRAY
49784: PPUSH
49785: CALL_OW 256
49789: PUSH
49790: LD_INT 1000
49792: EQUAL
49793: PUSH
49794: LD_VAR 0 4
49798: PUSH
49799: LD_VAR 0 7
49803: ARRAY
49804: PUSH
49805: LD_VAR 0 32
49809: IN
49810: AND
49811: IFFALSE 49835
// to_repair := to_repair diff group [ i ] ;
49813: LD_ADDR_VAR 0 32
49817: PUSH
49818: LD_VAR 0 32
49822: PUSH
49823: LD_VAR 0 4
49827: PUSH
49828: LD_VAR 0 7
49832: ARRAY
49833: DIFF
49834: ST_TO_ADDR
// if group [ i ] in to_repair then
49835: LD_VAR 0 4
49839: PUSH
49840: LD_VAR 0 7
49844: ARRAY
49845: PUSH
49846: LD_VAR 0 32
49850: IN
49851: IFFALSE 49898
// begin if not IsInArea ( group [ i ] , f_repair ) then
49853: LD_VAR 0 4
49857: PUSH
49858: LD_VAR 0 7
49862: ARRAY
49863: PPUSH
49864: LD_VAR 0 22
49868: PPUSH
49869: CALL_OW 308
49873: NOT
49874: IFFALSE 49896
// ComMoveToArea ( group [ i ] , f_repair ) ;
49876: LD_VAR 0 4
49880: PUSH
49881: LD_VAR 0 7
49885: ARRAY
49886: PPUSH
49887: LD_VAR 0 22
49891: PPUSH
49892: CALL_OW 113
// continue ;
49896: GO 49523
// end ; end else
49898: GO 50178
// if group [ i ] in repairs then
49900: LD_VAR 0 4
49904: PUSH
49905: LD_VAR 0 7
49909: ARRAY
49910: PUSH
49911: LD_VAR 0 33
49915: IN
49916: IFFALSE 50178
// begin if IsInUnit ( group [ i ] ) then
49918: LD_VAR 0 4
49922: PUSH
49923: LD_VAR 0 7
49927: ARRAY
49928: PPUSH
49929: CALL_OW 310
49933: IFFALSE 50001
// begin z := IsInUnit ( group [ i ] ) ;
49935: LD_ADDR_VAR 0 13
49939: PUSH
49940: LD_VAR 0 4
49944: PUSH
49945: LD_VAR 0 7
49949: ARRAY
49950: PPUSH
49951: CALL_OW 310
49955: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49956: LD_VAR 0 13
49960: PUSH
49961: LD_VAR 0 32
49965: IN
49966: PUSH
49967: LD_VAR 0 13
49971: PPUSH
49972: LD_VAR 0 22
49976: PPUSH
49977: CALL_OW 308
49981: AND
49982: IFFALSE 49999
// ComExitVehicle ( group [ i ] ) ;
49984: LD_VAR 0 4
49988: PUSH
49989: LD_VAR 0 7
49993: ARRAY
49994: PPUSH
49995: CALL_OW 121
// end else
49999: GO 50178
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50001: LD_ADDR_VAR 0 13
50005: PUSH
50006: LD_VAR 0 4
50010: PPUSH
50011: LD_INT 95
50013: PUSH
50014: LD_VAR 0 22
50018: PUSH
50019: EMPTY
50020: LIST
50021: LIST
50022: PUSH
50023: LD_INT 58
50025: PUSH
50026: EMPTY
50027: LIST
50028: PUSH
50029: EMPTY
50030: LIST
50031: LIST
50032: PPUSH
50033: CALL_OW 72
50037: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50038: LD_VAR 0 4
50042: PUSH
50043: LD_VAR 0 7
50047: ARRAY
50048: PPUSH
50049: CALL_OW 314
50053: NOT
50054: IFFALSE 50176
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50056: LD_ADDR_VAR 0 10
50060: PUSH
50061: LD_VAR 0 13
50065: PPUSH
50066: LD_VAR 0 4
50070: PUSH
50071: LD_VAR 0 7
50075: ARRAY
50076: PPUSH
50077: CALL_OW 74
50081: ST_TO_ADDR
// if not x then
50082: LD_VAR 0 10
50086: NOT
50087: IFFALSE 50091
// continue ;
50089: GO 49523
// if GetLives ( x ) < 1000 then
50091: LD_VAR 0 10
50095: PPUSH
50096: CALL_OW 256
50100: PUSH
50101: LD_INT 1000
50103: LESS
50104: IFFALSE 50128
// ComRepairVehicle ( group [ i ] , x ) else
50106: LD_VAR 0 4
50110: PUSH
50111: LD_VAR 0 7
50115: ARRAY
50116: PPUSH
50117: LD_VAR 0 10
50121: PPUSH
50122: CALL_OW 129
50126: GO 50176
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50128: LD_VAR 0 23
50132: PUSH
50133: LD_VAR 0 4
50137: PUSH
50138: LD_VAR 0 7
50142: ARRAY
50143: PPUSH
50144: CALL_OW 256
50148: PUSH
50149: LD_INT 1000
50151: LESS
50152: AND
50153: NOT
50154: IFFALSE 50176
// ComEnterUnit ( group [ i ] , x ) ;
50156: LD_VAR 0 4
50160: PUSH
50161: LD_VAR 0 7
50165: ARRAY
50166: PPUSH
50167: LD_VAR 0 10
50171: PPUSH
50172: CALL_OW 120
// end ; continue ;
50176: GO 49523
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50178: LD_VAR 0 23
50182: PUSH
50183: LD_VAR 0 4
50187: PUSH
50188: LD_VAR 0 7
50192: ARRAY
50193: PPUSH
50194: CALL_OW 247
50198: PUSH
50199: LD_INT 1
50201: EQUAL
50202: AND
50203: IFFALSE 50681
// begin if group [ i ] in healers then
50205: LD_VAR 0 4
50209: PUSH
50210: LD_VAR 0 7
50214: ARRAY
50215: PUSH
50216: LD_VAR 0 31
50220: IN
50221: IFFALSE 50494
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50223: LD_VAR 0 4
50227: PUSH
50228: LD_VAR 0 7
50232: ARRAY
50233: PPUSH
50234: LD_VAR 0 23
50238: PPUSH
50239: CALL_OW 308
50243: NOT
50244: PUSH
50245: LD_VAR 0 4
50249: PUSH
50250: LD_VAR 0 7
50254: ARRAY
50255: PPUSH
50256: CALL_OW 314
50260: NOT
50261: AND
50262: IFFALSE 50286
// ComMoveToArea ( group [ i ] , f_heal ) else
50264: LD_VAR 0 4
50268: PUSH
50269: LD_VAR 0 7
50273: ARRAY
50274: PPUSH
50275: LD_VAR 0 23
50279: PPUSH
50280: CALL_OW 113
50284: GO 50492
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50286: LD_VAR 0 4
50290: PUSH
50291: LD_VAR 0 7
50295: ARRAY
50296: PPUSH
50297: CALL 48924 0 1
50301: PPUSH
50302: CALL_OW 256
50306: PUSH
50307: LD_INT 1000
50309: EQUAL
50310: IFFALSE 50329
// ComStop ( group [ i ] ) else
50312: LD_VAR 0 4
50316: PUSH
50317: LD_VAR 0 7
50321: ARRAY
50322: PPUSH
50323: CALL_OW 141
50327: GO 50492
// if not HasTask ( group [ i ] ) and to_heal then
50329: LD_VAR 0 4
50333: PUSH
50334: LD_VAR 0 7
50338: ARRAY
50339: PPUSH
50340: CALL_OW 314
50344: NOT
50345: PUSH
50346: LD_VAR 0 30
50350: AND
50351: IFFALSE 50492
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50353: LD_ADDR_VAR 0 13
50357: PUSH
50358: LD_VAR 0 30
50362: PPUSH
50363: LD_INT 3
50365: PUSH
50366: LD_INT 54
50368: PUSH
50369: EMPTY
50370: LIST
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: PPUSH
50376: CALL_OW 72
50380: PPUSH
50381: LD_VAR 0 4
50385: PUSH
50386: LD_VAR 0 7
50390: ARRAY
50391: PPUSH
50392: CALL_OW 74
50396: ST_TO_ADDR
// if z then
50397: LD_VAR 0 13
50401: IFFALSE 50492
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50403: LD_INT 91
50405: PUSH
50406: LD_VAR 0 13
50410: PUSH
50411: LD_INT 10
50413: PUSH
50414: EMPTY
50415: LIST
50416: LIST
50417: LIST
50418: PUSH
50419: LD_INT 81
50421: PUSH
50422: LD_VAR 0 13
50426: PPUSH
50427: CALL_OW 255
50431: PUSH
50432: EMPTY
50433: LIST
50434: LIST
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: PPUSH
50440: CALL_OW 69
50444: PUSH
50445: LD_INT 0
50447: EQUAL
50448: IFFALSE 50472
// ComHeal ( group [ i ] , z ) else
50450: LD_VAR 0 4
50454: PUSH
50455: LD_VAR 0 7
50459: ARRAY
50460: PPUSH
50461: LD_VAR 0 13
50465: PPUSH
50466: CALL_OW 128
50470: GO 50492
// ComMoveToArea ( group [ i ] , f_heal ) ;
50472: LD_VAR 0 4
50476: PUSH
50477: LD_VAR 0 7
50481: ARRAY
50482: PPUSH
50483: LD_VAR 0 23
50487: PPUSH
50488: CALL_OW 113
// end ; continue ;
50492: GO 49523
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50494: LD_VAR 0 4
50498: PUSH
50499: LD_VAR 0 7
50503: ARRAY
50504: PPUSH
50505: CALL_OW 256
50509: PUSH
50510: LD_INT 700
50512: LESS
50513: PUSH
50514: LD_VAR 0 4
50518: PUSH
50519: LD_VAR 0 7
50523: ARRAY
50524: PUSH
50525: LD_VAR 0 30
50529: IN
50530: NOT
50531: AND
50532: IFFALSE 50556
// to_heal := to_heal union group [ i ] ;
50534: LD_ADDR_VAR 0 30
50538: PUSH
50539: LD_VAR 0 30
50543: PUSH
50544: LD_VAR 0 4
50548: PUSH
50549: LD_VAR 0 7
50553: ARRAY
50554: UNION
50555: ST_TO_ADDR
// if group [ i ] in to_heal then
50556: LD_VAR 0 4
50560: PUSH
50561: LD_VAR 0 7
50565: ARRAY
50566: PUSH
50567: LD_VAR 0 30
50571: IN
50572: IFFALSE 50681
// begin if GetLives ( group [ i ] ) = 1000 then
50574: LD_VAR 0 4
50578: PUSH
50579: LD_VAR 0 7
50583: ARRAY
50584: PPUSH
50585: CALL_OW 256
50589: PUSH
50590: LD_INT 1000
50592: EQUAL
50593: IFFALSE 50619
// to_heal := to_heal diff group [ i ] else
50595: LD_ADDR_VAR 0 30
50599: PUSH
50600: LD_VAR 0 30
50604: PUSH
50605: LD_VAR 0 4
50609: PUSH
50610: LD_VAR 0 7
50614: ARRAY
50615: DIFF
50616: ST_TO_ADDR
50617: GO 50681
// begin if not IsInArea ( group [ i ] , to_heal ) then
50619: LD_VAR 0 4
50623: PUSH
50624: LD_VAR 0 7
50628: ARRAY
50629: PPUSH
50630: LD_VAR 0 30
50634: PPUSH
50635: CALL_OW 308
50639: NOT
50640: IFFALSE 50664
// ComMoveToArea ( group [ i ] , f_heal ) else
50642: LD_VAR 0 4
50646: PUSH
50647: LD_VAR 0 7
50651: ARRAY
50652: PPUSH
50653: LD_VAR 0 23
50657: PPUSH
50658: CALL_OW 113
50662: GO 50679
// ComHold ( group [ i ] ) ;
50664: LD_VAR 0 4
50668: PUSH
50669: LD_VAR 0 7
50673: ARRAY
50674: PPUSH
50675: CALL_OW 140
// continue ;
50679: GO 49523
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50681: LD_VAR 0 4
50685: PUSH
50686: LD_VAR 0 7
50690: ARRAY
50691: PPUSH
50692: LD_INT 10
50694: PPUSH
50695: CALL 47321 0 2
50699: NOT
50700: PUSH
50701: LD_VAR 0 16
50705: PUSH
50706: LD_VAR 0 7
50710: ARRAY
50711: PUSH
50712: EMPTY
50713: EQUAL
50714: NOT
50715: AND
50716: IFFALSE 50982
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50718: LD_VAR 0 4
50722: PUSH
50723: LD_VAR 0 7
50727: ARRAY
50728: PPUSH
50729: CALL_OW 262
50733: PUSH
50734: LD_INT 1
50736: PUSH
50737: LD_INT 2
50739: PUSH
50740: EMPTY
50741: LIST
50742: LIST
50743: IN
50744: IFFALSE 50785
// if GetFuel ( group [ i ] ) < 10 then
50746: LD_VAR 0 4
50750: PUSH
50751: LD_VAR 0 7
50755: ARRAY
50756: PPUSH
50757: CALL_OW 261
50761: PUSH
50762: LD_INT 10
50764: LESS
50765: IFFALSE 50785
// SetFuel ( group [ i ] , 12 ) ;
50767: LD_VAR 0 4
50771: PUSH
50772: LD_VAR 0 7
50776: ARRAY
50777: PPUSH
50778: LD_INT 12
50780: PPUSH
50781: CALL_OW 240
// if units_path [ i ] then
50785: LD_VAR 0 16
50789: PUSH
50790: LD_VAR 0 7
50794: ARRAY
50795: IFFALSE 50980
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50797: LD_VAR 0 4
50801: PUSH
50802: LD_VAR 0 7
50806: ARRAY
50807: PPUSH
50808: LD_VAR 0 16
50812: PUSH
50813: LD_VAR 0 7
50817: ARRAY
50818: PUSH
50819: LD_INT 1
50821: ARRAY
50822: PUSH
50823: LD_INT 1
50825: ARRAY
50826: PPUSH
50827: LD_VAR 0 16
50831: PUSH
50832: LD_VAR 0 7
50836: ARRAY
50837: PUSH
50838: LD_INT 1
50840: ARRAY
50841: PUSH
50842: LD_INT 2
50844: ARRAY
50845: PPUSH
50846: CALL_OW 297
50850: PUSH
50851: LD_INT 6
50853: GREATER
50854: IFFALSE 50929
// begin if not HasTask ( group [ i ] ) then
50856: LD_VAR 0 4
50860: PUSH
50861: LD_VAR 0 7
50865: ARRAY
50866: PPUSH
50867: CALL_OW 314
50871: NOT
50872: IFFALSE 50927
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50874: LD_VAR 0 4
50878: PUSH
50879: LD_VAR 0 7
50883: ARRAY
50884: PPUSH
50885: LD_VAR 0 16
50889: PUSH
50890: LD_VAR 0 7
50894: ARRAY
50895: PUSH
50896: LD_INT 1
50898: ARRAY
50899: PUSH
50900: LD_INT 1
50902: ARRAY
50903: PPUSH
50904: LD_VAR 0 16
50908: PUSH
50909: LD_VAR 0 7
50913: ARRAY
50914: PUSH
50915: LD_INT 1
50917: ARRAY
50918: PUSH
50919: LD_INT 2
50921: ARRAY
50922: PPUSH
50923: CALL_OW 114
// end else
50927: GO 50980
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50929: LD_ADDR_VAR 0 15
50933: PUSH
50934: LD_VAR 0 16
50938: PUSH
50939: LD_VAR 0 7
50943: ARRAY
50944: PPUSH
50945: LD_INT 1
50947: PPUSH
50948: CALL_OW 3
50952: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50953: LD_ADDR_VAR 0 16
50957: PUSH
50958: LD_VAR 0 16
50962: PPUSH
50963: LD_VAR 0 7
50967: PPUSH
50968: LD_VAR 0 15
50972: PPUSH
50973: CALL_OW 1
50977: ST_TO_ADDR
// continue ;
50978: GO 49523
// end ; end ; end else
50980: GO 53618
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50982: LD_ADDR_VAR 0 14
50986: PUSH
50987: LD_INT 81
50989: PUSH
50990: LD_VAR 0 4
50994: PUSH
50995: LD_VAR 0 7
50999: ARRAY
51000: PPUSH
51001: CALL_OW 255
51005: PUSH
51006: EMPTY
51007: LIST
51008: LIST
51009: PPUSH
51010: CALL_OW 69
51014: ST_TO_ADDR
// if not tmp then
51015: LD_VAR 0 14
51019: NOT
51020: IFFALSE 51024
// continue ;
51022: GO 49523
// if f_ignore_area then
51024: LD_VAR 0 17
51028: IFFALSE 51116
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51030: LD_ADDR_VAR 0 15
51034: PUSH
51035: LD_VAR 0 14
51039: PPUSH
51040: LD_INT 3
51042: PUSH
51043: LD_INT 92
51045: PUSH
51046: LD_VAR 0 17
51050: PUSH
51051: LD_INT 1
51053: ARRAY
51054: PUSH
51055: LD_VAR 0 17
51059: PUSH
51060: LD_INT 2
51062: ARRAY
51063: PUSH
51064: LD_VAR 0 17
51068: PUSH
51069: LD_INT 3
51071: ARRAY
51072: PUSH
51073: EMPTY
51074: LIST
51075: LIST
51076: LIST
51077: LIST
51078: PUSH
51079: EMPTY
51080: LIST
51081: LIST
51082: PPUSH
51083: CALL_OW 72
51087: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51088: LD_VAR 0 14
51092: PUSH
51093: LD_VAR 0 15
51097: DIFF
51098: IFFALSE 51116
// tmp := tmp diff tmp2 ;
51100: LD_ADDR_VAR 0 14
51104: PUSH
51105: LD_VAR 0 14
51109: PUSH
51110: LD_VAR 0 15
51114: DIFF
51115: ST_TO_ADDR
// end ; if not f_murder then
51116: LD_VAR 0 20
51120: NOT
51121: IFFALSE 51179
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51123: LD_ADDR_VAR 0 15
51127: PUSH
51128: LD_VAR 0 14
51132: PPUSH
51133: LD_INT 3
51135: PUSH
51136: LD_INT 50
51138: PUSH
51139: EMPTY
51140: LIST
51141: PUSH
51142: EMPTY
51143: LIST
51144: LIST
51145: PPUSH
51146: CALL_OW 72
51150: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51151: LD_VAR 0 14
51155: PUSH
51156: LD_VAR 0 15
51160: DIFF
51161: IFFALSE 51179
// tmp := tmp diff tmp2 ;
51163: LD_ADDR_VAR 0 14
51167: PUSH
51168: LD_VAR 0 14
51172: PUSH
51173: LD_VAR 0 15
51177: DIFF
51178: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51179: LD_ADDR_VAR 0 14
51183: PUSH
51184: LD_VAR 0 4
51188: PUSH
51189: LD_VAR 0 7
51193: ARRAY
51194: PPUSH
51195: LD_VAR 0 14
51199: PPUSH
51200: LD_INT 1
51202: PPUSH
51203: LD_INT 1
51205: PPUSH
51206: CALL 20988 0 4
51210: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51211: LD_VAR 0 4
51215: PUSH
51216: LD_VAR 0 7
51220: ARRAY
51221: PPUSH
51222: CALL_OW 257
51226: PUSH
51227: LD_INT 1
51229: EQUAL
51230: IFFALSE 51678
// begin if WantPlant ( group [ i ] ) then
51232: LD_VAR 0 4
51236: PUSH
51237: LD_VAR 0 7
51241: ARRAY
51242: PPUSH
51243: CALL 20489 0 1
51247: IFFALSE 51251
// continue ;
51249: GO 49523
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51251: LD_VAR 0 18
51255: PUSH
51256: LD_VAR 0 4
51260: PUSH
51261: LD_VAR 0 7
51265: ARRAY
51266: PPUSH
51267: CALL_OW 310
51271: NOT
51272: AND
51273: PUSH
51274: LD_VAR 0 14
51278: PUSH
51279: LD_INT 1
51281: ARRAY
51282: PUSH
51283: LD_VAR 0 14
51287: PPUSH
51288: LD_INT 21
51290: PUSH
51291: LD_INT 2
51293: PUSH
51294: EMPTY
51295: LIST
51296: LIST
51297: PUSH
51298: LD_INT 58
51300: PUSH
51301: EMPTY
51302: LIST
51303: PUSH
51304: EMPTY
51305: LIST
51306: LIST
51307: PPUSH
51308: CALL_OW 72
51312: IN
51313: AND
51314: IFFALSE 51350
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51316: LD_VAR 0 4
51320: PUSH
51321: LD_VAR 0 7
51325: ARRAY
51326: PPUSH
51327: LD_VAR 0 14
51331: PUSH
51332: LD_INT 1
51334: ARRAY
51335: PPUSH
51336: CALL_OW 120
// attacking := true ;
51340: LD_ADDR_VAR 0 29
51344: PUSH
51345: LD_INT 1
51347: ST_TO_ADDR
// continue ;
51348: GO 49523
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51350: LD_VAR 0 26
51354: PUSH
51355: LD_VAR 0 4
51359: PUSH
51360: LD_VAR 0 7
51364: ARRAY
51365: PPUSH
51366: CALL_OW 257
51370: PUSH
51371: LD_INT 1
51373: EQUAL
51374: AND
51375: PUSH
51376: LD_VAR 0 4
51380: PUSH
51381: LD_VAR 0 7
51385: ARRAY
51386: PPUSH
51387: CALL_OW 256
51391: PUSH
51392: LD_INT 800
51394: LESS
51395: AND
51396: PUSH
51397: LD_VAR 0 4
51401: PUSH
51402: LD_VAR 0 7
51406: ARRAY
51407: PPUSH
51408: CALL_OW 318
51412: NOT
51413: AND
51414: IFFALSE 51431
// ComCrawl ( group [ i ] ) ;
51416: LD_VAR 0 4
51420: PUSH
51421: LD_VAR 0 7
51425: ARRAY
51426: PPUSH
51427: CALL_OW 137
// if f_mines then
51431: LD_VAR 0 21
51435: IFFALSE 51678
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51437: LD_VAR 0 14
51441: PUSH
51442: LD_INT 1
51444: ARRAY
51445: PPUSH
51446: CALL_OW 247
51450: PUSH
51451: LD_INT 3
51453: EQUAL
51454: PUSH
51455: LD_VAR 0 14
51459: PUSH
51460: LD_INT 1
51462: ARRAY
51463: PUSH
51464: LD_VAR 0 27
51468: IN
51469: NOT
51470: AND
51471: IFFALSE 51678
// begin x := GetX ( tmp [ 1 ] ) ;
51473: LD_ADDR_VAR 0 10
51477: PUSH
51478: LD_VAR 0 14
51482: PUSH
51483: LD_INT 1
51485: ARRAY
51486: PPUSH
51487: CALL_OW 250
51491: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51492: LD_ADDR_VAR 0 11
51496: PUSH
51497: LD_VAR 0 14
51501: PUSH
51502: LD_INT 1
51504: ARRAY
51505: PPUSH
51506: CALL_OW 251
51510: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51511: LD_ADDR_VAR 0 12
51515: PUSH
51516: LD_VAR 0 4
51520: PUSH
51521: LD_VAR 0 7
51525: ARRAY
51526: PPUSH
51527: CALL 47406 0 1
51531: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51532: LD_VAR 0 4
51536: PUSH
51537: LD_VAR 0 7
51541: ARRAY
51542: PPUSH
51543: LD_VAR 0 10
51547: PPUSH
51548: LD_VAR 0 11
51552: PPUSH
51553: LD_VAR 0 14
51557: PUSH
51558: LD_INT 1
51560: ARRAY
51561: PPUSH
51562: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51566: LD_VAR 0 4
51570: PUSH
51571: LD_VAR 0 7
51575: ARRAY
51576: PPUSH
51577: LD_VAR 0 10
51581: PPUSH
51582: LD_VAR 0 12
51586: PPUSH
51587: LD_INT 7
51589: PPUSH
51590: CALL_OW 272
51594: PPUSH
51595: LD_VAR 0 11
51599: PPUSH
51600: LD_VAR 0 12
51604: PPUSH
51605: LD_INT 7
51607: PPUSH
51608: CALL_OW 273
51612: PPUSH
51613: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51617: LD_VAR 0 4
51621: PUSH
51622: LD_VAR 0 7
51626: ARRAY
51627: PPUSH
51628: LD_INT 71
51630: PPUSH
51631: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51635: LD_ADDR_VAR 0 27
51639: PUSH
51640: LD_VAR 0 27
51644: PPUSH
51645: LD_VAR 0 27
51649: PUSH
51650: LD_INT 1
51652: PLUS
51653: PPUSH
51654: LD_VAR 0 14
51658: PUSH
51659: LD_INT 1
51661: ARRAY
51662: PPUSH
51663: CALL_OW 1
51667: ST_TO_ADDR
// attacking := true ;
51668: LD_ADDR_VAR 0 29
51672: PUSH
51673: LD_INT 1
51675: ST_TO_ADDR
// continue ;
51676: GO 49523
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51678: LD_VAR 0 4
51682: PUSH
51683: LD_VAR 0 7
51687: ARRAY
51688: PPUSH
51689: CALL_OW 257
51693: PUSH
51694: LD_INT 17
51696: EQUAL
51697: PUSH
51698: LD_VAR 0 4
51702: PUSH
51703: LD_VAR 0 7
51707: ARRAY
51708: PPUSH
51709: CALL_OW 110
51713: PUSH
51714: LD_INT 71
51716: EQUAL
51717: NOT
51718: AND
51719: IFFALSE 51865
// begin attacking := false ;
51721: LD_ADDR_VAR 0 29
51725: PUSH
51726: LD_INT 0
51728: ST_TO_ADDR
// k := 5 ;
51729: LD_ADDR_VAR 0 9
51733: PUSH
51734: LD_INT 5
51736: ST_TO_ADDR
// if tmp < k then
51737: LD_VAR 0 14
51741: PUSH
51742: LD_VAR 0 9
51746: LESS
51747: IFFALSE 51759
// k := tmp ;
51749: LD_ADDR_VAR 0 9
51753: PUSH
51754: LD_VAR 0 14
51758: ST_TO_ADDR
// for j = 1 to k do
51759: LD_ADDR_VAR 0 8
51763: PUSH
51764: DOUBLE
51765: LD_INT 1
51767: DEC
51768: ST_TO_ADDR
51769: LD_VAR 0 9
51773: PUSH
51774: FOR_TO
51775: IFFALSE 51863
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51777: LD_VAR 0 14
51781: PUSH
51782: LD_VAR 0 8
51786: ARRAY
51787: PUSH
51788: LD_VAR 0 14
51792: PPUSH
51793: LD_INT 58
51795: PUSH
51796: EMPTY
51797: LIST
51798: PPUSH
51799: CALL_OW 72
51803: IN
51804: NOT
51805: IFFALSE 51861
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51807: LD_VAR 0 4
51811: PUSH
51812: LD_VAR 0 7
51816: ARRAY
51817: PPUSH
51818: LD_VAR 0 14
51822: PUSH
51823: LD_VAR 0 8
51827: ARRAY
51828: PPUSH
51829: CALL_OW 115
// attacking := true ;
51833: LD_ADDR_VAR 0 29
51837: PUSH
51838: LD_INT 1
51840: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51841: LD_VAR 0 4
51845: PUSH
51846: LD_VAR 0 7
51850: ARRAY
51851: PPUSH
51852: LD_INT 71
51854: PPUSH
51855: CALL_OW 109
// continue ;
51859: GO 51774
// end ; end ;
51861: GO 51774
51863: POP
51864: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51865: LD_VAR 0 4
51869: PUSH
51870: LD_VAR 0 7
51874: ARRAY
51875: PPUSH
51876: CALL_OW 257
51880: PUSH
51881: LD_INT 8
51883: EQUAL
51884: PUSH
51885: LD_VAR 0 4
51889: PUSH
51890: LD_VAR 0 7
51894: ARRAY
51895: PPUSH
51896: CALL_OW 264
51900: PUSH
51901: LD_INT 28
51903: PUSH
51904: LD_INT 45
51906: PUSH
51907: LD_INT 7
51909: PUSH
51910: LD_INT 47
51912: PUSH
51913: EMPTY
51914: LIST
51915: LIST
51916: LIST
51917: LIST
51918: IN
51919: OR
51920: IFFALSE 52150
// begin attacking := false ;
51922: LD_ADDR_VAR 0 29
51926: PUSH
51927: LD_INT 0
51929: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51930: LD_VAR 0 14
51934: PUSH
51935: LD_INT 1
51937: ARRAY
51938: PPUSH
51939: CALL_OW 266
51943: PUSH
51944: LD_INT 32
51946: PUSH
51947: LD_INT 31
51949: PUSH
51950: LD_INT 33
51952: PUSH
51953: LD_INT 4
51955: PUSH
51956: LD_INT 5
51958: PUSH
51959: EMPTY
51960: LIST
51961: LIST
51962: LIST
51963: LIST
51964: LIST
51965: IN
51966: IFFALSE 52150
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51968: LD_ADDR_VAR 0 9
51972: PUSH
51973: LD_VAR 0 14
51977: PUSH
51978: LD_INT 1
51980: ARRAY
51981: PPUSH
51982: CALL_OW 266
51986: PPUSH
51987: LD_VAR 0 14
51991: PUSH
51992: LD_INT 1
51994: ARRAY
51995: PPUSH
51996: CALL_OW 250
52000: PPUSH
52001: LD_VAR 0 14
52005: PUSH
52006: LD_INT 1
52008: ARRAY
52009: PPUSH
52010: CALL_OW 251
52014: PPUSH
52015: LD_VAR 0 14
52019: PUSH
52020: LD_INT 1
52022: ARRAY
52023: PPUSH
52024: CALL_OW 254
52028: PPUSH
52029: LD_VAR 0 14
52033: PUSH
52034: LD_INT 1
52036: ARRAY
52037: PPUSH
52038: CALL_OW 248
52042: PPUSH
52043: LD_INT 0
52045: PPUSH
52046: CALL 28782 0 6
52050: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52051: LD_ADDR_VAR 0 8
52055: PUSH
52056: LD_VAR 0 4
52060: PUSH
52061: LD_VAR 0 7
52065: ARRAY
52066: PPUSH
52067: LD_VAR 0 9
52071: PPUSH
52072: CALL 47469 0 2
52076: ST_TO_ADDR
// if j then
52077: LD_VAR 0 8
52081: IFFALSE 52150
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52083: LD_VAR 0 8
52087: PUSH
52088: LD_INT 1
52090: ARRAY
52091: PPUSH
52092: LD_VAR 0 8
52096: PUSH
52097: LD_INT 2
52099: ARRAY
52100: PPUSH
52101: CALL_OW 488
52105: IFFALSE 52150
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52107: LD_VAR 0 4
52111: PUSH
52112: LD_VAR 0 7
52116: ARRAY
52117: PPUSH
52118: LD_VAR 0 8
52122: PUSH
52123: LD_INT 1
52125: ARRAY
52126: PPUSH
52127: LD_VAR 0 8
52131: PUSH
52132: LD_INT 2
52134: ARRAY
52135: PPUSH
52136: CALL_OW 116
// attacking := true ;
52140: LD_ADDR_VAR 0 29
52144: PUSH
52145: LD_INT 1
52147: ST_TO_ADDR
// continue ;
52148: GO 49523
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52150: LD_VAR 0 4
52154: PUSH
52155: LD_VAR 0 7
52159: ARRAY
52160: PPUSH
52161: CALL_OW 265
52165: PUSH
52166: LD_INT 11
52168: EQUAL
52169: IFFALSE 52447
// begin k := 10 ;
52171: LD_ADDR_VAR 0 9
52175: PUSH
52176: LD_INT 10
52178: ST_TO_ADDR
// x := 0 ;
52179: LD_ADDR_VAR 0 10
52183: PUSH
52184: LD_INT 0
52186: ST_TO_ADDR
// if tmp < k then
52187: LD_VAR 0 14
52191: PUSH
52192: LD_VAR 0 9
52196: LESS
52197: IFFALSE 52209
// k := tmp ;
52199: LD_ADDR_VAR 0 9
52203: PUSH
52204: LD_VAR 0 14
52208: ST_TO_ADDR
// for j = k downto 1 do
52209: LD_ADDR_VAR 0 8
52213: PUSH
52214: DOUBLE
52215: LD_VAR 0 9
52219: INC
52220: ST_TO_ADDR
52221: LD_INT 1
52223: PUSH
52224: FOR_DOWNTO
52225: IFFALSE 52300
// begin if GetType ( tmp [ j ] ) = unit_human then
52227: LD_VAR 0 14
52231: PUSH
52232: LD_VAR 0 8
52236: ARRAY
52237: PPUSH
52238: CALL_OW 247
52242: PUSH
52243: LD_INT 1
52245: EQUAL
52246: IFFALSE 52298
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52248: LD_VAR 0 4
52252: PUSH
52253: LD_VAR 0 7
52257: ARRAY
52258: PPUSH
52259: LD_VAR 0 14
52263: PUSH
52264: LD_VAR 0 8
52268: ARRAY
52269: PPUSH
52270: CALL 47740 0 2
// x := tmp [ j ] ;
52274: LD_ADDR_VAR 0 10
52278: PUSH
52279: LD_VAR 0 14
52283: PUSH
52284: LD_VAR 0 8
52288: ARRAY
52289: ST_TO_ADDR
// attacking := true ;
52290: LD_ADDR_VAR 0 29
52294: PUSH
52295: LD_INT 1
52297: ST_TO_ADDR
// end ; end ;
52298: GO 52224
52300: POP
52301: POP
// if not x then
52302: LD_VAR 0 10
52306: NOT
52307: IFFALSE 52447
// begin attacking := true ;
52309: LD_ADDR_VAR 0 29
52313: PUSH
52314: LD_INT 1
52316: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52317: LD_VAR 0 4
52321: PUSH
52322: LD_VAR 0 7
52326: ARRAY
52327: PPUSH
52328: CALL_OW 250
52332: PPUSH
52333: LD_VAR 0 4
52337: PUSH
52338: LD_VAR 0 7
52342: ARRAY
52343: PPUSH
52344: CALL_OW 251
52348: PPUSH
52349: CALL_OW 546
52353: PUSH
52354: LD_INT 2
52356: ARRAY
52357: PUSH
52358: LD_VAR 0 14
52362: PUSH
52363: LD_INT 1
52365: ARRAY
52366: PPUSH
52367: CALL_OW 250
52371: PPUSH
52372: LD_VAR 0 14
52376: PUSH
52377: LD_INT 1
52379: ARRAY
52380: PPUSH
52381: CALL_OW 251
52385: PPUSH
52386: CALL_OW 546
52390: PUSH
52391: LD_INT 2
52393: ARRAY
52394: EQUAL
52395: IFFALSE 52423
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52397: LD_VAR 0 4
52401: PUSH
52402: LD_VAR 0 7
52406: ARRAY
52407: PPUSH
52408: LD_VAR 0 14
52412: PUSH
52413: LD_INT 1
52415: ARRAY
52416: PPUSH
52417: CALL 47740 0 2
52421: GO 52447
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52423: LD_VAR 0 4
52427: PUSH
52428: LD_VAR 0 7
52432: ARRAY
52433: PPUSH
52434: LD_VAR 0 14
52438: PUSH
52439: LD_INT 1
52441: ARRAY
52442: PPUSH
52443: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52447: LD_VAR 0 4
52451: PUSH
52452: LD_VAR 0 7
52456: ARRAY
52457: PPUSH
52458: CALL_OW 264
52462: PUSH
52463: LD_INT 29
52465: EQUAL
52466: IFFALSE 52832
// begin if WantsToAttack ( group [ i ] ) in bombed then
52468: LD_VAR 0 4
52472: PUSH
52473: LD_VAR 0 7
52477: ARRAY
52478: PPUSH
52479: CALL_OW 319
52483: PUSH
52484: LD_VAR 0 28
52488: IN
52489: IFFALSE 52493
// continue ;
52491: GO 49523
// k := 8 ;
52493: LD_ADDR_VAR 0 9
52497: PUSH
52498: LD_INT 8
52500: ST_TO_ADDR
// x := 0 ;
52501: LD_ADDR_VAR 0 10
52505: PUSH
52506: LD_INT 0
52508: ST_TO_ADDR
// if tmp < k then
52509: LD_VAR 0 14
52513: PUSH
52514: LD_VAR 0 9
52518: LESS
52519: IFFALSE 52531
// k := tmp ;
52521: LD_ADDR_VAR 0 9
52525: PUSH
52526: LD_VAR 0 14
52530: ST_TO_ADDR
// for j = 1 to k do
52531: LD_ADDR_VAR 0 8
52535: PUSH
52536: DOUBLE
52537: LD_INT 1
52539: DEC
52540: ST_TO_ADDR
52541: LD_VAR 0 9
52545: PUSH
52546: FOR_TO
52547: IFFALSE 52679
// begin if GetType ( tmp [ j ] ) = unit_building then
52549: LD_VAR 0 14
52553: PUSH
52554: LD_VAR 0 8
52558: ARRAY
52559: PPUSH
52560: CALL_OW 247
52564: PUSH
52565: LD_INT 3
52567: EQUAL
52568: IFFALSE 52677
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52570: LD_VAR 0 14
52574: PUSH
52575: LD_VAR 0 8
52579: ARRAY
52580: PUSH
52581: LD_VAR 0 28
52585: IN
52586: NOT
52587: PUSH
52588: LD_VAR 0 14
52592: PUSH
52593: LD_VAR 0 8
52597: ARRAY
52598: PPUSH
52599: CALL_OW 313
52603: AND
52604: IFFALSE 52677
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52606: LD_VAR 0 4
52610: PUSH
52611: LD_VAR 0 7
52615: ARRAY
52616: PPUSH
52617: LD_VAR 0 14
52621: PUSH
52622: LD_VAR 0 8
52626: ARRAY
52627: PPUSH
52628: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52632: LD_ADDR_VAR 0 28
52636: PUSH
52637: LD_VAR 0 28
52641: PPUSH
52642: LD_VAR 0 28
52646: PUSH
52647: LD_INT 1
52649: PLUS
52650: PPUSH
52651: LD_VAR 0 14
52655: PUSH
52656: LD_VAR 0 8
52660: ARRAY
52661: PPUSH
52662: CALL_OW 1
52666: ST_TO_ADDR
// attacking := true ;
52667: LD_ADDR_VAR 0 29
52671: PUSH
52672: LD_INT 1
52674: ST_TO_ADDR
// break ;
52675: GO 52679
// end ; end ;
52677: GO 52546
52679: POP
52680: POP
// if not attacking and f_attack_depot then
52681: LD_VAR 0 29
52685: NOT
52686: PUSH
52687: LD_VAR 0 25
52691: AND
52692: IFFALSE 52787
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52694: LD_ADDR_VAR 0 13
52698: PUSH
52699: LD_VAR 0 14
52703: PPUSH
52704: LD_INT 2
52706: PUSH
52707: LD_INT 30
52709: PUSH
52710: LD_INT 0
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: PUSH
52717: LD_INT 30
52719: PUSH
52720: LD_INT 1
52722: PUSH
52723: EMPTY
52724: LIST
52725: LIST
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: LIST
52731: PPUSH
52732: CALL_OW 72
52736: ST_TO_ADDR
// if z then
52737: LD_VAR 0 13
52741: IFFALSE 52787
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52743: LD_VAR 0 4
52747: PUSH
52748: LD_VAR 0 7
52752: ARRAY
52753: PPUSH
52754: LD_VAR 0 13
52758: PPUSH
52759: LD_VAR 0 4
52763: PUSH
52764: LD_VAR 0 7
52768: ARRAY
52769: PPUSH
52770: CALL_OW 74
52774: PPUSH
52775: CALL_OW 115
// attacking := true ;
52779: LD_ADDR_VAR 0 29
52783: PUSH
52784: LD_INT 1
52786: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52787: LD_VAR 0 4
52791: PUSH
52792: LD_VAR 0 7
52796: ARRAY
52797: PPUSH
52798: CALL_OW 256
52802: PUSH
52803: LD_INT 500
52805: LESS
52806: IFFALSE 52832
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52808: LD_VAR 0 4
52812: PUSH
52813: LD_VAR 0 7
52817: ARRAY
52818: PPUSH
52819: LD_VAR 0 14
52823: PUSH
52824: LD_INT 1
52826: ARRAY
52827: PPUSH
52828: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52832: LD_VAR 0 4
52836: PUSH
52837: LD_VAR 0 7
52841: ARRAY
52842: PPUSH
52843: CALL_OW 264
52847: PUSH
52848: LD_INT 49
52850: EQUAL
52851: IFFALSE 52972
// begin if not HasTask ( group [ i ] ) then
52853: LD_VAR 0 4
52857: PUSH
52858: LD_VAR 0 7
52862: ARRAY
52863: PPUSH
52864: CALL_OW 314
52868: NOT
52869: IFFALSE 52972
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52871: LD_ADDR_VAR 0 9
52875: PUSH
52876: LD_INT 81
52878: PUSH
52879: LD_VAR 0 4
52883: PUSH
52884: LD_VAR 0 7
52888: ARRAY
52889: PPUSH
52890: CALL_OW 255
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: PPUSH
52899: CALL_OW 69
52903: PPUSH
52904: LD_VAR 0 4
52908: PUSH
52909: LD_VAR 0 7
52913: ARRAY
52914: PPUSH
52915: CALL_OW 74
52919: ST_TO_ADDR
// if k then
52920: LD_VAR 0 9
52924: IFFALSE 52972
// if GetDistUnits ( group [ i ] , k ) > 10 then
52926: LD_VAR 0 4
52930: PUSH
52931: LD_VAR 0 7
52935: ARRAY
52936: PPUSH
52937: LD_VAR 0 9
52941: PPUSH
52942: CALL_OW 296
52946: PUSH
52947: LD_INT 10
52949: GREATER
52950: IFFALSE 52972
// ComMoveUnit ( group [ i ] , k ) ;
52952: LD_VAR 0 4
52956: PUSH
52957: LD_VAR 0 7
52961: ARRAY
52962: PPUSH
52963: LD_VAR 0 9
52967: PPUSH
52968: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52972: LD_VAR 0 4
52976: PUSH
52977: LD_VAR 0 7
52981: ARRAY
52982: PPUSH
52983: CALL_OW 256
52987: PUSH
52988: LD_INT 250
52990: LESS
52991: PUSH
52992: LD_VAR 0 4
52996: PUSH
52997: LD_VAR 0 7
53001: ARRAY
53002: PUSH
53003: LD_INT 21
53005: PUSH
53006: LD_INT 2
53008: PUSH
53009: EMPTY
53010: LIST
53011: LIST
53012: PUSH
53013: LD_INT 23
53015: PUSH
53016: LD_INT 2
53018: PUSH
53019: EMPTY
53020: LIST
53021: LIST
53022: PUSH
53023: EMPTY
53024: LIST
53025: LIST
53026: PPUSH
53027: CALL_OW 69
53031: IN
53032: AND
53033: IFFALSE 53158
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53035: LD_ADDR_VAR 0 9
53039: PUSH
53040: LD_OWVAR 3
53044: PUSH
53045: LD_VAR 0 4
53049: PUSH
53050: LD_VAR 0 7
53054: ARRAY
53055: DIFF
53056: PPUSH
53057: LD_VAR 0 4
53061: PUSH
53062: LD_VAR 0 7
53066: ARRAY
53067: PPUSH
53068: CALL_OW 74
53072: ST_TO_ADDR
// if not k then
53073: LD_VAR 0 9
53077: NOT
53078: IFFALSE 53082
// continue ;
53080: GO 49523
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53082: LD_VAR 0 9
53086: PUSH
53087: LD_INT 81
53089: PUSH
53090: LD_VAR 0 4
53094: PUSH
53095: LD_VAR 0 7
53099: ARRAY
53100: PPUSH
53101: CALL_OW 255
53105: PUSH
53106: EMPTY
53107: LIST
53108: LIST
53109: PPUSH
53110: CALL_OW 69
53114: IN
53115: PUSH
53116: LD_VAR 0 9
53120: PPUSH
53121: LD_VAR 0 4
53125: PUSH
53126: LD_VAR 0 7
53130: ARRAY
53131: PPUSH
53132: CALL_OW 296
53136: PUSH
53137: LD_INT 5
53139: LESS
53140: AND
53141: IFFALSE 53158
// ComAutodestruct ( group [ i ] ) ;
53143: LD_VAR 0 4
53147: PUSH
53148: LD_VAR 0 7
53152: ARRAY
53153: PPUSH
53154: CALL 47638 0 1
// end ; if f_attack_depot then
53158: LD_VAR 0 25
53162: IFFALSE 53274
// begin k := 6 ;
53164: LD_ADDR_VAR 0 9
53168: PUSH
53169: LD_INT 6
53171: ST_TO_ADDR
// if tmp < k then
53172: LD_VAR 0 14
53176: PUSH
53177: LD_VAR 0 9
53181: LESS
53182: IFFALSE 53194
// k := tmp ;
53184: LD_ADDR_VAR 0 9
53188: PUSH
53189: LD_VAR 0 14
53193: ST_TO_ADDR
// for j = 1 to k do
53194: LD_ADDR_VAR 0 8
53198: PUSH
53199: DOUBLE
53200: LD_INT 1
53202: DEC
53203: ST_TO_ADDR
53204: LD_VAR 0 9
53208: PUSH
53209: FOR_TO
53210: IFFALSE 53272
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53212: LD_VAR 0 8
53216: PPUSH
53217: CALL_OW 266
53221: PUSH
53222: LD_INT 0
53224: PUSH
53225: LD_INT 1
53227: PUSH
53228: EMPTY
53229: LIST
53230: LIST
53231: IN
53232: IFFALSE 53270
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53234: LD_VAR 0 4
53238: PUSH
53239: LD_VAR 0 7
53243: ARRAY
53244: PPUSH
53245: LD_VAR 0 14
53249: PUSH
53250: LD_VAR 0 8
53254: ARRAY
53255: PPUSH
53256: CALL_OW 115
// attacking := true ;
53260: LD_ADDR_VAR 0 29
53264: PUSH
53265: LD_INT 1
53267: ST_TO_ADDR
// break ;
53268: GO 53272
// end ;
53270: GO 53209
53272: POP
53273: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53274: LD_VAR 0 4
53278: PUSH
53279: LD_VAR 0 7
53283: ARRAY
53284: PPUSH
53285: CALL_OW 302
53289: PUSH
53290: LD_VAR 0 29
53294: NOT
53295: AND
53296: IFFALSE 53618
// begin if GetTag ( group [ i ] ) = 71 then
53298: LD_VAR 0 4
53302: PUSH
53303: LD_VAR 0 7
53307: ARRAY
53308: PPUSH
53309: CALL_OW 110
53313: PUSH
53314: LD_INT 71
53316: EQUAL
53317: IFFALSE 53358
// begin if HasTask ( group [ i ] ) then
53319: LD_VAR 0 4
53323: PUSH
53324: LD_VAR 0 7
53328: ARRAY
53329: PPUSH
53330: CALL_OW 314
53334: IFFALSE 53340
// continue else
53336: GO 49523
53338: GO 53358
// SetTag ( group [ i ] , 0 ) ;
53340: LD_VAR 0 4
53344: PUSH
53345: LD_VAR 0 7
53349: ARRAY
53350: PPUSH
53351: LD_INT 0
53353: PPUSH
53354: CALL_OW 109
// end ; k := 8 ;
53358: LD_ADDR_VAR 0 9
53362: PUSH
53363: LD_INT 8
53365: ST_TO_ADDR
// x := 0 ;
53366: LD_ADDR_VAR 0 10
53370: PUSH
53371: LD_INT 0
53373: ST_TO_ADDR
// if tmp < k then
53374: LD_VAR 0 14
53378: PUSH
53379: LD_VAR 0 9
53383: LESS
53384: IFFALSE 53396
// k := tmp ;
53386: LD_ADDR_VAR 0 9
53390: PUSH
53391: LD_VAR 0 14
53395: ST_TO_ADDR
// for j = 1 to k do
53396: LD_ADDR_VAR 0 8
53400: PUSH
53401: DOUBLE
53402: LD_INT 1
53404: DEC
53405: ST_TO_ADDR
53406: LD_VAR 0 9
53410: PUSH
53411: FOR_TO
53412: IFFALSE 53510
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53414: LD_VAR 0 14
53418: PUSH
53419: LD_VAR 0 8
53423: ARRAY
53424: PPUSH
53425: CALL_OW 247
53429: PUSH
53430: LD_INT 1
53432: EQUAL
53433: PUSH
53434: LD_VAR 0 14
53438: PUSH
53439: LD_VAR 0 8
53443: ARRAY
53444: PPUSH
53445: CALL_OW 256
53449: PUSH
53450: LD_INT 250
53452: LESS
53453: PUSH
53454: LD_VAR 0 20
53458: AND
53459: PUSH
53460: LD_VAR 0 20
53464: NOT
53465: PUSH
53466: LD_VAR 0 14
53470: PUSH
53471: LD_VAR 0 8
53475: ARRAY
53476: PPUSH
53477: CALL_OW 256
53481: PUSH
53482: LD_INT 250
53484: GREATEREQUAL
53485: AND
53486: OR
53487: AND
53488: IFFALSE 53508
// begin x := tmp [ j ] ;
53490: LD_ADDR_VAR 0 10
53494: PUSH
53495: LD_VAR 0 14
53499: PUSH
53500: LD_VAR 0 8
53504: ARRAY
53505: ST_TO_ADDR
// break ;
53506: GO 53510
// end ;
53508: GO 53411
53510: POP
53511: POP
// if x then
53512: LD_VAR 0 10
53516: IFFALSE 53540
// ComAttackUnit ( group [ i ] , x ) else
53518: LD_VAR 0 4
53522: PUSH
53523: LD_VAR 0 7
53527: ARRAY
53528: PPUSH
53529: LD_VAR 0 10
53533: PPUSH
53534: CALL_OW 115
53538: GO 53564
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53540: LD_VAR 0 4
53544: PUSH
53545: LD_VAR 0 7
53549: ARRAY
53550: PPUSH
53551: LD_VAR 0 14
53555: PUSH
53556: LD_INT 1
53558: ARRAY
53559: PPUSH
53560: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53564: LD_VAR 0 4
53568: PUSH
53569: LD_VAR 0 7
53573: ARRAY
53574: PPUSH
53575: CALL_OW 314
53579: NOT
53580: IFFALSE 53618
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53582: LD_VAR 0 4
53586: PUSH
53587: LD_VAR 0 7
53591: ARRAY
53592: PPUSH
53593: LD_VAR 0 14
53597: PPUSH
53598: LD_VAR 0 4
53602: PUSH
53603: LD_VAR 0 7
53607: ARRAY
53608: PPUSH
53609: CALL_OW 74
53613: PPUSH
53614: CALL_OW 115
// end ; end ; end ;
53618: GO 49523
53620: POP
53621: POP
// wait ( 0 0$1 ) ;
53622: LD_INT 35
53624: PPUSH
53625: CALL_OW 67
// until group = [ ] ;
53629: LD_VAR 0 4
53633: PUSH
53634: EMPTY
53635: EQUAL
53636: IFFALSE 49508
// end ;
53638: LD_VAR 0 2
53642: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53643: LD_INT 0
53645: PPUSH
53646: PPUSH
53647: PPUSH
53648: PPUSH
// if not base_units then
53649: LD_VAR 0 1
53653: NOT
53654: IFFALSE 53658
// exit ;
53656: GO 53745
// result := false ;
53658: LD_ADDR_VAR 0 2
53662: PUSH
53663: LD_INT 0
53665: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53666: LD_ADDR_VAR 0 5
53670: PUSH
53671: LD_VAR 0 1
53675: PPUSH
53676: LD_INT 21
53678: PUSH
53679: LD_INT 3
53681: PUSH
53682: EMPTY
53683: LIST
53684: LIST
53685: PPUSH
53686: CALL_OW 72
53690: ST_TO_ADDR
// if not tmp then
53691: LD_VAR 0 5
53695: NOT
53696: IFFALSE 53700
// exit ;
53698: GO 53745
// for i in tmp do
53700: LD_ADDR_VAR 0 3
53704: PUSH
53705: LD_VAR 0 5
53709: PUSH
53710: FOR_IN
53711: IFFALSE 53743
// begin result := EnemyInRange ( i , 22 ) ;
53713: LD_ADDR_VAR 0 2
53717: PUSH
53718: LD_VAR 0 3
53722: PPUSH
53723: LD_INT 22
53725: PPUSH
53726: CALL 47321 0 2
53730: ST_TO_ADDR
// if result then
53731: LD_VAR 0 2
53735: IFFALSE 53741
// exit ;
53737: POP
53738: POP
53739: GO 53745
// end ;
53741: GO 53710
53743: POP
53744: POP
// end ;
53745: LD_VAR 0 2
53749: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53750: LD_INT 0
53752: PPUSH
53753: PPUSH
// if not units then
53754: LD_VAR 0 1
53758: NOT
53759: IFFALSE 53763
// exit ;
53761: GO 53833
// result := [ ] ;
53763: LD_ADDR_VAR 0 3
53767: PUSH
53768: EMPTY
53769: ST_TO_ADDR
// for i in units do
53770: LD_ADDR_VAR 0 4
53774: PUSH
53775: LD_VAR 0 1
53779: PUSH
53780: FOR_IN
53781: IFFALSE 53831
// if GetTag ( i ) = tag then
53783: LD_VAR 0 4
53787: PPUSH
53788: CALL_OW 110
53792: PUSH
53793: LD_VAR 0 2
53797: EQUAL
53798: IFFALSE 53829
// result := Insert ( result , result + 1 , i ) ;
53800: LD_ADDR_VAR 0 3
53804: PUSH
53805: LD_VAR 0 3
53809: PPUSH
53810: LD_VAR 0 3
53814: PUSH
53815: LD_INT 1
53817: PLUS
53818: PPUSH
53819: LD_VAR 0 4
53823: PPUSH
53824: CALL_OW 2
53828: ST_TO_ADDR
53829: GO 53780
53831: POP
53832: POP
// end ;
53833: LD_VAR 0 3
53837: RET
// export function IsDriver ( un ) ; begin
53838: LD_INT 0
53840: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53841: LD_ADDR_VAR 0 2
53845: PUSH
53846: LD_VAR 0 1
53850: PUSH
53851: LD_INT 55
53853: PUSH
53854: EMPTY
53855: LIST
53856: PPUSH
53857: CALL_OW 69
53861: IN
53862: ST_TO_ADDR
// end ;
53863: LD_VAR 0 2
53867: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53868: LD_INT 0
53870: PPUSH
53871: PPUSH
// list := [ ] ;
53872: LD_ADDR_VAR 0 5
53876: PUSH
53877: EMPTY
53878: ST_TO_ADDR
// case d of 0 :
53879: LD_VAR 0 3
53883: PUSH
53884: LD_INT 0
53886: DOUBLE
53887: EQUAL
53888: IFTRUE 53892
53890: GO 54025
53892: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53893: LD_ADDR_VAR 0 5
53897: PUSH
53898: LD_VAR 0 1
53902: PUSH
53903: LD_INT 4
53905: MINUS
53906: PUSH
53907: LD_VAR 0 2
53911: PUSH
53912: LD_INT 4
53914: MINUS
53915: PUSH
53916: LD_INT 2
53918: PUSH
53919: EMPTY
53920: LIST
53921: LIST
53922: LIST
53923: PUSH
53924: LD_VAR 0 1
53928: PUSH
53929: LD_INT 3
53931: MINUS
53932: PUSH
53933: LD_VAR 0 2
53937: PUSH
53938: LD_INT 1
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: LIST
53945: PUSH
53946: LD_VAR 0 1
53950: PUSH
53951: LD_INT 4
53953: PLUS
53954: PUSH
53955: LD_VAR 0 2
53959: PUSH
53960: LD_INT 4
53962: PUSH
53963: EMPTY
53964: LIST
53965: LIST
53966: LIST
53967: PUSH
53968: LD_VAR 0 1
53972: PUSH
53973: LD_INT 3
53975: PLUS
53976: PUSH
53977: LD_VAR 0 2
53981: PUSH
53982: LD_INT 3
53984: PLUS
53985: PUSH
53986: LD_INT 5
53988: PUSH
53989: EMPTY
53990: LIST
53991: LIST
53992: LIST
53993: PUSH
53994: LD_VAR 0 1
53998: PUSH
53999: LD_VAR 0 2
54003: PUSH
54004: LD_INT 4
54006: PLUS
54007: PUSH
54008: LD_INT 0
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: LIST
54015: PUSH
54016: EMPTY
54017: LIST
54018: LIST
54019: LIST
54020: LIST
54021: LIST
54022: ST_TO_ADDR
// end ; 1 :
54023: GO 54723
54025: LD_INT 1
54027: DOUBLE
54028: EQUAL
54029: IFTRUE 54033
54031: GO 54166
54033: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54034: LD_ADDR_VAR 0 5
54038: PUSH
54039: LD_VAR 0 1
54043: PUSH
54044: LD_VAR 0 2
54048: PUSH
54049: LD_INT 4
54051: MINUS
54052: PUSH
54053: LD_INT 3
54055: PUSH
54056: EMPTY
54057: LIST
54058: LIST
54059: LIST
54060: PUSH
54061: LD_VAR 0 1
54065: PUSH
54066: LD_INT 3
54068: MINUS
54069: PUSH
54070: LD_VAR 0 2
54074: PUSH
54075: LD_INT 3
54077: MINUS
54078: PUSH
54079: LD_INT 2
54081: PUSH
54082: EMPTY
54083: LIST
54084: LIST
54085: LIST
54086: PUSH
54087: LD_VAR 0 1
54091: PUSH
54092: LD_INT 4
54094: MINUS
54095: PUSH
54096: LD_VAR 0 2
54100: PUSH
54101: LD_INT 1
54103: PUSH
54104: EMPTY
54105: LIST
54106: LIST
54107: LIST
54108: PUSH
54109: LD_VAR 0 1
54113: PUSH
54114: LD_VAR 0 2
54118: PUSH
54119: LD_INT 3
54121: PLUS
54122: PUSH
54123: LD_INT 0
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: LIST
54130: PUSH
54131: LD_VAR 0 1
54135: PUSH
54136: LD_INT 4
54138: PLUS
54139: PUSH
54140: LD_VAR 0 2
54144: PUSH
54145: LD_INT 4
54147: PLUS
54148: PUSH
54149: LD_INT 5
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: PUSH
54157: EMPTY
54158: LIST
54159: LIST
54160: LIST
54161: LIST
54162: LIST
54163: ST_TO_ADDR
// end ; 2 :
54164: GO 54723
54166: LD_INT 2
54168: DOUBLE
54169: EQUAL
54170: IFTRUE 54174
54172: GO 54303
54174: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54175: LD_ADDR_VAR 0 5
54179: PUSH
54180: LD_VAR 0 1
54184: PUSH
54185: LD_VAR 0 2
54189: PUSH
54190: LD_INT 3
54192: MINUS
54193: PUSH
54194: LD_INT 3
54196: PUSH
54197: EMPTY
54198: LIST
54199: LIST
54200: LIST
54201: PUSH
54202: LD_VAR 0 1
54206: PUSH
54207: LD_INT 4
54209: PLUS
54210: PUSH
54211: LD_VAR 0 2
54215: PUSH
54216: LD_INT 4
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: LIST
54223: PUSH
54224: LD_VAR 0 1
54228: PUSH
54229: LD_VAR 0 2
54233: PUSH
54234: LD_INT 4
54236: PLUS
54237: PUSH
54238: LD_INT 0
54240: PUSH
54241: EMPTY
54242: LIST
54243: LIST
54244: LIST
54245: PUSH
54246: LD_VAR 0 1
54250: PUSH
54251: LD_INT 3
54253: MINUS
54254: PUSH
54255: LD_VAR 0 2
54259: PUSH
54260: LD_INT 1
54262: PUSH
54263: EMPTY
54264: LIST
54265: LIST
54266: LIST
54267: PUSH
54268: LD_VAR 0 1
54272: PUSH
54273: LD_INT 4
54275: MINUS
54276: PUSH
54277: LD_VAR 0 2
54281: PUSH
54282: LD_INT 4
54284: MINUS
54285: PUSH
54286: LD_INT 2
54288: PUSH
54289: EMPTY
54290: LIST
54291: LIST
54292: LIST
54293: PUSH
54294: EMPTY
54295: LIST
54296: LIST
54297: LIST
54298: LIST
54299: LIST
54300: ST_TO_ADDR
// end ; 3 :
54301: GO 54723
54303: LD_INT 3
54305: DOUBLE
54306: EQUAL
54307: IFTRUE 54311
54309: GO 54444
54311: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54312: LD_ADDR_VAR 0 5
54316: PUSH
54317: LD_VAR 0 1
54321: PUSH
54322: LD_INT 3
54324: PLUS
54325: PUSH
54326: LD_VAR 0 2
54330: PUSH
54331: LD_INT 4
54333: PUSH
54334: EMPTY
54335: LIST
54336: LIST
54337: LIST
54338: PUSH
54339: LD_VAR 0 1
54343: PUSH
54344: LD_INT 4
54346: PLUS
54347: PUSH
54348: LD_VAR 0 2
54352: PUSH
54353: LD_INT 4
54355: PLUS
54356: PUSH
54357: LD_INT 5
54359: PUSH
54360: EMPTY
54361: LIST
54362: LIST
54363: LIST
54364: PUSH
54365: LD_VAR 0 1
54369: PUSH
54370: LD_INT 4
54372: MINUS
54373: PUSH
54374: LD_VAR 0 2
54378: PUSH
54379: LD_INT 1
54381: PUSH
54382: EMPTY
54383: LIST
54384: LIST
54385: LIST
54386: PUSH
54387: LD_VAR 0 1
54391: PUSH
54392: LD_VAR 0 2
54396: PUSH
54397: LD_INT 4
54399: MINUS
54400: PUSH
54401: LD_INT 3
54403: PUSH
54404: EMPTY
54405: LIST
54406: LIST
54407: LIST
54408: PUSH
54409: LD_VAR 0 1
54413: PUSH
54414: LD_INT 3
54416: MINUS
54417: PUSH
54418: LD_VAR 0 2
54422: PUSH
54423: LD_INT 3
54425: MINUS
54426: PUSH
54427: LD_INT 2
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: LIST
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: LIST
54439: LIST
54440: LIST
54441: ST_TO_ADDR
// end ; 4 :
54442: GO 54723
54444: LD_INT 4
54446: DOUBLE
54447: EQUAL
54448: IFTRUE 54452
54450: GO 54585
54452: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54453: LD_ADDR_VAR 0 5
54457: PUSH
54458: LD_VAR 0 1
54462: PUSH
54463: LD_VAR 0 2
54467: PUSH
54468: LD_INT 4
54470: PLUS
54471: PUSH
54472: LD_INT 0
54474: PUSH
54475: EMPTY
54476: LIST
54477: LIST
54478: LIST
54479: PUSH
54480: LD_VAR 0 1
54484: PUSH
54485: LD_INT 3
54487: PLUS
54488: PUSH
54489: LD_VAR 0 2
54493: PUSH
54494: LD_INT 3
54496: PLUS
54497: PUSH
54498: LD_INT 5
54500: PUSH
54501: EMPTY
54502: LIST
54503: LIST
54504: LIST
54505: PUSH
54506: LD_VAR 0 1
54510: PUSH
54511: LD_INT 4
54513: PLUS
54514: PUSH
54515: LD_VAR 0 2
54519: PUSH
54520: LD_INT 4
54522: PUSH
54523: EMPTY
54524: LIST
54525: LIST
54526: LIST
54527: PUSH
54528: LD_VAR 0 1
54532: PUSH
54533: LD_VAR 0 2
54537: PUSH
54538: LD_INT 3
54540: MINUS
54541: PUSH
54542: LD_INT 3
54544: PUSH
54545: EMPTY
54546: LIST
54547: LIST
54548: LIST
54549: PUSH
54550: LD_VAR 0 1
54554: PUSH
54555: LD_INT 4
54557: MINUS
54558: PUSH
54559: LD_VAR 0 2
54563: PUSH
54564: LD_INT 4
54566: MINUS
54567: PUSH
54568: LD_INT 2
54570: PUSH
54571: EMPTY
54572: LIST
54573: LIST
54574: LIST
54575: PUSH
54576: EMPTY
54577: LIST
54578: LIST
54579: LIST
54580: LIST
54581: LIST
54582: ST_TO_ADDR
// end ; 5 :
54583: GO 54723
54585: LD_INT 5
54587: DOUBLE
54588: EQUAL
54589: IFTRUE 54593
54591: GO 54722
54593: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54594: LD_ADDR_VAR 0 5
54598: PUSH
54599: LD_VAR 0 1
54603: PUSH
54604: LD_INT 4
54606: MINUS
54607: PUSH
54608: LD_VAR 0 2
54612: PUSH
54613: LD_INT 1
54615: PUSH
54616: EMPTY
54617: LIST
54618: LIST
54619: LIST
54620: PUSH
54621: LD_VAR 0 1
54625: PUSH
54626: LD_VAR 0 2
54630: PUSH
54631: LD_INT 4
54633: MINUS
54634: PUSH
54635: LD_INT 3
54637: PUSH
54638: EMPTY
54639: LIST
54640: LIST
54641: LIST
54642: PUSH
54643: LD_VAR 0 1
54647: PUSH
54648: LD_INT 4
54650: PLUS
54651: PUSH
54652: LD_VAR 0 2
54656: PUSH
54657: LD_INT 4
54659: PLUS
54660: PUSH
54661: LD_INT 5
54663: PUSH
54664: EMPTY
54665: LIST
54666: LIST
54667: LIST
54668: PUSH
54669: LD_VAR 0 1
54673: PUSH
54674: LD_INT 3
54676: PLUS
54677: PUSH
54678: LD_VAR 0 2
54682: PUSH
54683: LD_INT 4
54685: PUSH
54686: EMPTY
54687: LIST
54688: LIST
54689: LIST
54690: PUSH
54691: LD_VAR 0 1
54695: PUSH
54696: LD_VAR 0 2
54700: PUSH
54701: LD_INT 3
54703: PLUS
54704: PUSH
54705: LD_INT 0
54707: PUSH
54708: EMPTY
54709: LIST
54710: LIST
54711: LIST
54712: PUSH
54713: EMPTY
54714: LIST
54715: LIST
54716: LIST
54717: LIST
54718: LIST
54719: ST_TO_ADDR
// end ; end ;
54720: GO 54723
54722: POP
// result := list ;
54723: LD_ADDR_VAR 0 4
54727: PUSH
54728: LD_VAR 0 5
54732: ST_TO_ADDR
// end ;
54733: LD_VAR 0 4
54737: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54738: LD_INT 0
54740: PPUSH
54741: PPUSH
54742: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54743: LD_VAR 0 1
54747: NOT
54748: PUSH
54749: LD_VAR 0 2
54753: PUSH
54754: LD_INT 1
54756: PUSH
54757: LD_INT 2
54759: PUSH
54760: LD_INT 3
54762: PUSH
54763: LD_INT 4
54765: PUSH
54766: EMPTY
54767: LIST
54768: LIST
54769: LIST
54770: LIST
54771: IN
54772: NOT
54773: OR
54774: IFFALSE 54778
// exit ;
54776: GO 54870
// tmp := [ ] ;
54778: LD_ADDR_VAR 0 5
54782: PUSH
54783: EMPTY
54784: ST_TO_ADDR
// for i in units do
54785: LD_ADDR_VAR 0 4
54789: PUSH
54790: LD_VAR 0 1
54794: PUSH
54795: FOR_IN
54796: IFFALSE 54839
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54798: LD_ADDR_VAR 0 5
54802: PUSH
54803: LD_VAR 0 5
54807: PPUSH
54808: LD_VAR 0 5
54812: PUSH
54813: LD_INT 1
54815: PLUS
54816: PPUSH
54817: LD_VAR 0 4
54821: PPUSH
54822: LD_VAR 0 2
54826: PPUSH
54827: CALL_OW 259
54831: PPUSH
54832: CALL_OW 2
54836: ST_TO_ADDR
54837: GO 54795
54839: POP
54840: POP
// if not tmp then
54841: LD_VAR 0 5
54845: NOT
54846: IFFALSE 54850
// exit ;
54848: GO 54870
// result := SortListByListDesc ( units , tmp ) ;
54850: LD_ADDR_VAR 0 3
54854: PUSH
54855: LD_VAR 0 1
54859: PPUSH
54860: LD_VAR 0 5
54864: PPUSH
54865: CALL_OW 77
54869: ST_TO_ADDR
// end ;
54870: LD_VAR 0 3
54874: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54875: LD_INT 0
54877: PPUSH
54878: PPUSH
54879: PPUSH
// x := GetX ( building ) ;
54880: LD_ADDR_VAR 0 4
54884: PUSH
54885: LD_VAR 0 2
54889: PPUSH
54890: CALL_OW 250
54894: ST_TO_ADDR
// y := GetY ( building ) ;
54895: LD_ADDR_VAR 0 5
54899: PUSH
54900: LD_VAR 0 2
54904: PPUSH
54905: CALL_OW 251
54909: ST_TO_ADDR
// if GetTaskList ( unit ) then
54910: LD_VAR 0 1
54914: PPUSH
54915: CALL_OW 437
54919: IFFALSE 55014
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54921: LD_STRING e
54923: PUSH
54924: LD_VAR 0 1
54928: PPUSH
54929: CALL_OW 437
54933: PUSH
54934: LD_INT 1
54936: ARRAY
54937: PUSH
54938: LD_INT 1
54940: ARRAY
54941: EQUAL
54942: PUSH
54943: LD_VAR 0 4
54947: PUSH
54948: LD_VAR 0 1
54952: PPUSH
54953: CALL_OW 437
54957: PUSH
54958: LD_INT 1
54960: ARRAY
54961: PUSH
54962: LD_INT 2
54964: ARRAY
54965: EQUAL
54966: AND
54967: PUSH
54968: LD_VAR 0 5
54972: PUSH
54973: LD_VAR 0 1
54977: PPUSH
54978: CALL_OW 437
54982: PUSH
54983: LD_INT 1
54985: ARRAY
54986: PUSH
54987: LD_INT 3
54989: ARRAY
54990: EQUAL
54991: AND
54992: IFFALSE 55004
// result := true else
54994: LD_ADDR_VAR 0 3
54998: PUSH
54999: LD_INT 1
55001: ST_TO_ADDR
55002: GO 55012
// result := false ;
55004: LD_ADDR_VAR 0 3
55008: PUSH
55009: LD_INT 0
55011: ST_TO_ADDR
// end else
55012: GO 55022
// result := false ;
55014: LD_ADDR_VAR 0 3
55018: PUSH
55019: LD_INT 0
55021: ST_TO_ADDR
// end ;
55022: LD_VAR 0 3
55026: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55027: LD_INT 0
55029: PPUSH
55030: PPUSH
55031: PPUSH
55032: PPUSH
// if not unit or not area then
55033: LD_VAR 0 1
55037: NOT
55038: PUSH
55039: LD_VAR 0 2
55043: NOT
55044: OR
55045: IFFALSE 55049
// exit ;
55047: GO 55214
// tmp := AreaToList ( area , i ) ;
55049: LD_ADDR_VAR 0 6
55053: PUSH
55054: LD_VAR 0 2
55058: PPUSH
55059: LD_VAR 0 5
55063: PPUSH
55064: CALL_OW 517
55068: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55069: LD_ADDR_VAR 0 5
55073: PUSH
55074: DOUBLE
55075: LD_INT 1
55077: DEC
55078: ST_TO_ADDR
55079: LD_VAR 0 6
55083: PUSH
55084: LD_INT 1
55086: ARRAY
55087: PUSH
55088: FOR_TO
55089: IFFALSE 55204
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55091: LD_ADDR_VAR 0 7
55095: PUSH
55096: LD_VAR 0 6
55100: PUSH
55101: LD_INT 1
55103: ARRAY
55104: PUSH
55105: LD_VAR 0 5
55109: ARRAY
55110: PUSH
55111: LD_VAR 0 6
55115: PUSH
55116: LD_INT 2
55118: ARRAY
55119: PUSH
55120: LD_VAR 0 5
55124: ARRAY
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55130: LD_VAR 0 7
55134: PUSH
55135: LD_INT 1
55137: ARRAY
55138: PPUSH
55139: LD_VAR 0 7
55143: PUSH
55144: LD_INT 2
55146: ARRAY
55147: PPUSH
55148: CALL_OW 428
55152: PUSH
55153: LD_INT 0
55155: EQUAL
55156: IFFALSE 55202
// begin result := true ;
55158: LD_ADDR_VAR 0 4
55162: PUSH
55163: LD_INT 1
55165: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55166: LD_VAR 0 1
55170: PPUSH
55171: LD_VAR 0 7
55175: PUSH
55176: LD_INT 1
55178: ARRAY
55179: PPUSH
55180: LD_VAR 0 7
55184: PUSH
55185: LD_INT 2
55187: ARRAY
55188: PPUSH
55189: LD_VAR 0 3
55193: PPUSH
55194: CALL_OW 48
// exit ;
55198: POP
55199: POP
55200: GO 55214
// end ; end ;
55202: GO 55088
55204: POP
55205: POP
// result := false ;
55206: LD_ADDR_VAR 0 4
55210: PUSH
55211: LD_INT 0
55213: ST_TO_ADDR
// end ;
55214: LD_VAR 0 4
55218: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55219: LD_INT 0
55221: PPUSH
55222: PPUSH
55223: PPUSH
// if not side or side > 8 then
55224: LD_VAR 0 1
55228: NOT
55229: PUSH
55230: LD_VAR 0 1
55234: PUSH
55235: LD_INT 8
55237: GREATER
55238: OR
55239: IFFALSE 55243
// exit ;
55241: GO 55430
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55243: LD_ADDR_VAR 0 4
55247: PUSH
55248: LD_INT 22
55250: PUSH
55251: LD_VAR 0 1
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: PUSH
55260: LD_INT 21
55262: PUSH
55263: LD_INT 3
55265: PUSH
55266: EMPTY
55267: LIST
55268: LIST
55269: PUSH
55270: EMPTY
55271: LIST
55272: LIST
55273: PPUSH
55274: CALL_OW 69
55278: ST_TO_ADDR
// if not tmp then
55279: LD_VAR 0 4
55283: NOT
55284: IFFALSE 55288
// exit ;
55286: GO 55430
// enable_addtolog := true ;
55288: LD_ADDR_OWVAR 81
55292: PUSH
55293: LD_INT 1
55295: ST_TO_ADDR
// AddToLog ( [ ) ;
55296: LD_STRING [
55298: PPUSH
55299: CALL_OW 561
// for i in tmp do
55303: LD_ADDR_VAR 0 3
55307: PUSH
55308: LD_VAR 0 4
55312: PUSH
55313: FOR_IN
55314: IFFALSE 55421
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55316: LD_STRING [
55318: PUSH
55319: LD_VAR 0 3
55323: PPUSH
55324: CALL_OW 266
55328: STR
55329: PUSH
55330: LD_STRING , 
55332: STR
55333: PUSH
55334: LD_VAR 0 3
55338: PPUSH
55339: CALL_OW 250
55343: STR
55344: PUSH
55345: LD_STRING , 
55347: STR
55348: PUSH
55349: LD_VAR 0 3
55353: PPUSH
55354: CALL_OW 251
55358: STR
55359: PUSH
55360: LD_STRING , 
55362: STR
55363: PUSH
55364: LD_VAR 0 3
55368: PPUSH
55369: CALL_OW 254
55373: STR
55374: PUSH
55375: LD_STRING , 
55377: STR
55378: PUSH
55379: LD_VAR 0 3
55383: PPUSH
55384: LD_INT 1
55386: PPUSH
55387: CALL_OW 268
55391: STR
55392: PUSH
55393: LD_STRING , 
55395: STR
55396: PUSH
55397: LD_VAR 0 3
55401: PPUSH
55402: LD_INT 2
55404: PPUSH
55405: CALL_OW 268
55409: STR
55410: PUSH
55411: LD_STRING ],
55413: STR
55414: PPUSH
55415: CALL_OW 561
// end ;
55419: GO 55313
55421: POP
55422: POP
// AddToLog ( ]; ) ;
55423: LD_STRING ];
55425: PPUSH
55426: CALL_OW 561
// end ;
55430: LD_VAR 0 2
55434: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55435: LD_INT 0
55437: PPUSH
55438: PPUSH
55439: PPUSH
55440: PPUSH
55441: PPUSH
// if not area or not rate or not max then
55442: LD_VAR 0 1
55446: NOT
55447: PUSH
55448: LD_VAR 0 2
55452: NOT
55453: OR
55454: PUSH
55455: LD_VAR 0 4
55459: NOT
55460: OR
55461: IFFALSE 55465
// exit ;
55463: GO 55657
// while 1 do
55465: LD_INT 1
55467: IFFALSE 55657
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55469: LD_ADDR_VAR 0 9
55473: PUSH
55474: LD_VAR 0 1
55478: PPUSH
55479: LD_INT 1
55481: PPUSH
55482: CALL_OW 287
55486: PUSH
55487: LD_INT 10
55489: MUL
55490: ST_TO_ADDR
// r := rate / 10 ;
55491: LD_ADDR_VAR 0 7
55495: PUSH
55496: LD_VAR 0 2
55500: PUSH
55501: LD_INT 10
55503: DIVREAL
55504: ST_TO_ADDR
// time := 1 1$00 ;
55505: LD_ADDR_VAR 0 8
55509: PUSH
55510: LD_INT 2100
55512: ST_TO_ADDR
// if amount < min then
55513: LD_VAR 0 9
55517: PUSH
55518: LD_VAR 0 3
55522: LESS
55523: IFFALSE 55541
// r := r * 2 else
55525: LD_ADDR_VAR 0 7
55529: PUSH
55530: LD_VAR 0 7
55534: PUSH
55535: LD_INT 2
55537: MUL
55538: ST_TO_ADDR
55539: GO 55567
// if amount > max then
55541: LD_VAR 0 9
55545: PUSH
55546: LD_VAR 0 4
55550: GREATER
55551: IFFALSE 55567
// r := r / 2 ;
55553: LD_ADDR_VAR 0 7
55557: PUSH
55558: LD_VAR 0 7
55562: PUSH
55563: LD_INT 2
55565: DIVREAL
55566: ST_TO_ADDR
// time := time / r ;
55567: LD_ADDR_VAR 0 8
55571: PUSH
55572: LD_VAR 0 8
55576: PUSH
55577: LD_VAR 0 7
55581: DIVREAL
55582: ST_TO_ADDR
// if time < 0 then
55583: LD_VAR 0 8
55587: PUSH
55588: LD_INT 0
55590: LESS
55591: IFFALSE 55608
// time := time * - 1 ;
55593: LD_ADDR_VAR 0 8
55597: PUSH
55598: LD_VAR 0 8
55602: PUSH
55603: LD_INT 1
55605: NEG
55606: MUL
55607: ST_TO_ADDR
// wait ( time ) ;
55608: LD_VAR 0 8
55612: PPUSH
55613: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55617: LD_INT 35
55619: PPUSH
55620: LD_INT 875
55622: PPUSH
55623: CALL_OW 12
55627: PPUSH
55628: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55632: LD_INT 1
55634: PPUSH
55635: LD_INT 5
55637: PPUSH
55638: CALL_OW 12
55642: PPUSH
55643: LD_VAR 0 1
55647: PPUSH
55648: LD_INT 1
55650: PPUSH
55651: CALL_OW 55
// end ;
55655: GO 55465
// end ;
55657: LD_VAR 0 5
55661: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55662: LD_INT 0
55664: PPUSH
55665: PPUSH
55666: PPUSH
55667: PPUSH
55668: PPUSH
55669: PPUSH
55670: PPUSH
55671: PPUSH
// if not turrets or not factories then
55672: LD_VAR 0 1
55676: NOT
55677: PUSH
55678: LD_VAR 0 2
55682: NOT
55683: OR
55684: IFFALSE 55688
// exit ;
55686: GO 55995
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55688: LD_ADDR_VAR 0 10
55692: PUSH
55693: LD_INT 5
55695: PUSH
55696: LD_INT 6
55698: PUSH
55699: EMPTY
55700: LIST
55701: LIST
55702: PUSH
55703: LD_INT 2
55705: PUSH
55706: LD_INT 4
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: PUSH
55713: LD_INT 3
55715: PUSH
55716: LD_INT 5
55718: PUSH
55719: EMPTY
55720: LIST
55721: LIST
55722: PUSH
55723: EMPTY
55724: LIST
55725: LIST
55726: LIST
55727: PUSH
55728: LD_INT 24
55730: PUSH
55731: LD_INT 25
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: PUSH
55738: LD_INT 23
55740: PUSH
55741: LD_INT 27
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: PUSH
55748: EMPTY
55749: LIST
55750: LIST
55751: PUSH
55752: LD_INT 42
55754: PUSH
55755: LD_INT 43
55757: PUSH
55758: EMPTY
55759: LIST
55760: LIST
55761: PUSH
55762: LD_INT 44
55764: PUSH
55765: LD_INT 46
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: PUSH
55772: LD_INT 45
55774: PUSH
55775: LD_INT 47
55777: PUSH
55778: EMPTY
55779: LIST
55780: LIST
55781: PUSH
55782: EMPTY
55783: LIST
55784: LIST
55785: LIST
55786: PUSH
55787: EMPTY
55788: LIST
55789: LIST
55790: LIST
55791: ST_TO_ADDR
// result := [ ] ;
55792: LD_ADDR_VAR 0 3
55796: PUSH
55797: EMPTY
55798: ST_TO_ADDR
// for i in turrets do
55799: LD_ADDR_VAR 0 4
55803: PUSH
55804: LD_VAR 0 1
55808: PUSH
55809: FOR_IN
55810: IFFALSE 55993
// begin nat := GetNation ( i ) ;
55812: LD_ADDR_VAR 0 7
55816: PUSH
55817: LD_VAR 0 4
55821: PPUSH
55822: CALL_OW 248
55826: ST_TO_ADDR
// weapon := 0 ;
55827: LD_ADDR_VAR 0 8
55831: PUSH
55832: LD_INT 0
55834: ST_TO_ADDR
// if not nat then
55835: LD_VAR 0 7
55839: NOT
55840: IFFALSE 55844
// continue ;
55842: GO 55809
// for j in list [ nat ] do
55844: LD_ADDR_VAR 0 5
55848: PUSH
55849: LD_VAR 0 10
55853: PUSH
55854: LD_VAR 0 7
55858: ARRAY
55859: PUSH
55860: FOR_IN
55861: IFFALSE 55902
// if GetBWeapon ( i ) = j [ 1 ] then
55863: LD_VAR 0 4
55867: PPUSH
55868: CALL_OW 269
55872: PUSH
55873: LD_VAR 0 5
55877: PUSH
55878: LD_INT 1
55880: ARRAY
55881: EQUAL
55882: IFFALSE 55900
// begin weapon := j [ 2 ] ;
55884: LD_ADDR_VAR 0 8
55888: PUSH
55889: LD_VAR 0 5
55893: PUSH
55894: LD_INT 2
55896: ARRAY
55897: ST_TO_ADDR
// break ;
55898: GO 55902
// end ;
55900: GO 55860
55902: POP
55903: POP
// if not weapon then
55904: LD_VAR 0 8
55908: NOT
55909: IFFALSE 55913
// continue ;
55911: GO 55809
// for k in factories do
55913: LD_ADDR_VAR 0 6
55917: PUSH
55918: LD_VAR 0 2
55922: PUSH
55923: FOR_IN
55924: IFFALSE 55989
// begin weapons := AvailableWeaponList ( k ) ;
55926: LD_ADDR_VAR 0 9
55930: PUSH
55931: LD_VAR 0 6
55935: PPUSH
55936: CALL_OW 478
55940: ST_TO_ADDR
// if not weapons then
55941: LD_VAR 0 9
55945: NOT
55946: IFFALSE 55950
// continue ;
55948: GO 55923
// if weapon in weapons then
55950: LD_VAR 0 8
55954: PUSH
55955: LD_VAR 0 9
55959: IN
55960: IFFALSE 55987
// begin result := [ i , weapon ] ;
55962: LD_ADDR_VAR 0 3
55966: PUSH
55967: LD_VAR 0 4
55971: PUSH
55972: LD_VAR 0 8
55976: PUSH
55977: EMPTY
55978: LIST
55979: LIST
55980: ST_TO_ADDR
// exit ;
55981: POP
55982: POP
55983: POP
55984: POP
55985: GO 55995
// end ; end ;
55987: GO 55923
55989: POP
55990: POP
// end ;
55991: GO 55809
55993: POP
55994: POP
// end ;
55995: LD_VAR 0 3
55999: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56000: LD_INT 0
56002: PPUSH
// if not side or side > 8 then
56003: LD_VAR 0 3
56007: NOT
56008: PUSH
56009: LD_VAR 0 3
56013: PUSH
56014: LD_INT 8
56016: GREATER
56017: OR
56018: IFFALSE 56022
// exit ;
56020: GO 56081
// if not range then
56022: LD_VAR 0 4
56026: NOT
56027: IFFALSE 56038
// range := - 12 ;
56029: LD_ADDR_VAR 0 4
56033: PUSH
56034: LD_INT 12
56036: NEG
56037: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56038: LD_VAR 0 1
56042: PPUSH
56043: LD_VAR 0 2
56047: PPUSH
56048: LD_VAR 0 3
56052: PPUSH
56053: LD_VAR 0 4
56057: PPUSH
56058: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56062: LD_VAR 0 1
56066: PPUSH
56067: LD_VAR 0 2
56071: PPUSH
56072: LD_VAR 0 3
56076: PPUSH
56077: CALL_OW 331
// end ;
56081: LD_VAR 0 5
56085: RET
// export function Video ( mode ) ; begin
56086: LD_INT 0
56088: PPUSH
// ingame_video = mode ;
56089: LD_ADDR_OWVAR 52
56093: PUSH
56094: LD_VAR 0 1
56098: ST_TO_ADDR
// interface_hidden = mode ;
56099: LD_ADDR_OWVAR 54
56103: PUSH
56104: LD_VAR 0 1
56108: ST_TO_ADDR
// end ;
56109: LD_VAR 0 2
56113: RET
// export function Join ( array , element ) ; begin
56114: LD_INT 0
56116: PPUSH
// result := array ^ element ;
56117: LD_ADDR_VAR 0 3
56121: PUSH
56122: LD_VAR 0 1
56126: PUSH
56127: LD_VAR 0 2
56131: ADD
56132: ST_TO_ADDR
// end ;
56133: LD_VAR 0 3
56137: RET
// export function JoinUnion ( array , element ) ; begin
56138: LD_INT 0
56140: PPUSH
// result := array union element ;
56141: LD_ADDR_VAR 0 3
56145: PUSH
56146: LD_VAR 0 1
56150: PUSH
56151: LD_VAR 0 2
56155: UNION
56156: ST_TO_ADDR
// end ;
56157: LD_VAR 0 3
56161: RET
// export function GetBehemoths ( side ) ; begin
56162: LD_INT 0
56164: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56165: LD_ADDR_VAR 0 2
56169: PUSH
56170: LD_INT 22
56172: PUSH
56173: LD_VAR 0 1
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: PUSH
56182: LD_INT 31
56184: PUSH
56185: LD_INT 25
56187: PUSH
56188: EMPTY
56189: LIST
56190: LIST
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: PPUSH
56196: CALL_OW 69
56200: ST_TO_ADDR
// end ;
56201: LD_VAR 0 2
56205: RET
// export function Shuffle ( array ) ; var i , index ; begin
56206: LD_INT 0
56208: PPUSH
56209: PPUSH
56210: PPUSH
// result := [ ] ;
56211: LD_ADDR_VAR 0 2
56215: PUSH
56216: EMPTY
56217: ST_TO_ADDR
// if not array then
56218: LD_VAR 0 1
56222: NOT
56223: IFFALSE 56227
// exit ;
56225: GO 56326
// Randomize ;
56227: CALL_OW 10
// for i = array downto 1 do
56231: LD_ADDR_VAR 0 3
56235: PUSH
56236: DOUBLE
56237: LD_VAR 0 1
56241: INC
56242: ST_TO_ADDR
56243: LD_INT 1
56245: PUSH
56246: FOR_DOWNTO
56247: IFFALSE 56324
// begin index := rand ( 1 , array ) ;
56249: LD_ADDR_VAR 0 4
56253: PUSH
56254: LD_INT 1
56256: PPUSH
56257: LD_VAR 0 1
56261: PPUSH
56262: CALL_OW 12
56266: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56267: LD_ADDR_VAR 0 2
56271: PUSH
56272: LD_VAR 0 2
56276: PPUSH
56277: LD_VAR 0 2
56281: PUSH
56282: LD_INT 1
56284: PLUS
56285: PPUSH
56286: LD_VAR 0 1
56290: PUSH
56291: LD_VAR 0 4
56295: ARRAY
56296: PPUSH
56297: CALL_OW 2
56301: ST_TO_ADDR
// array := Delete ( array , index ) ;
56302: LD_ADDR_VAR 0 1
56306: PUSH
56307: LD_VAR 0 1
56311: PPUSH
56312: LD_VAR 0 4
56316: PPUSH
56317: CALL_OW 3
56321: ST_TO_ADDR
// end ;
56322: GO 56246
56324: POP
56325: POP
// end ; end_of_file
56326: LD_VAR 0 2
56330: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56331: LD_INT 0
56333: PPUSH
56334: PPUSH
// skirmish := false ;
56335: LD_ADDR_EXP 56
56339: PUSH
56340: LD_INT 0
56342: ST_TO_ADDR
// debug_mc := false ;
56343: LD_ADDR_EXP 57
56347: PUSH
56348: LD_INT 0
56350: ST_TO_ADDR
// mc_bases := [ ] ;
56351: LD_ADDR_EXP 58
56355: PUSH
56356: EMPTY
56357: ST_TO_ADDR
// mc_sides := [ ] ;
56358: LD_ADDR_EXP 84
56362: PUSH
56363: EMPTY
56364: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56365: LD_ADDR_EXP 59
56369: PUSH
56370: EMPTY
56371: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56372: LD_ADDR_EXP 60
56376: PUSH
56377: EMPTY
56378: ST_TO_ADDR
// mc_need_heal := [ ] ;
56379: LD_ADDR_EXP 61
56383: PUSH
56384: EMPTY
56385: ST_TO_ADDR
// mc_healers := [ ] ;
56386: LD_ADDR_EXP 62
56390: PUSH
56391: EMPTY
56392: ST_TO_ADDR
// mc_build_list := [ ] ;
56393: LD_ADDR_EXP 63
56397: PUSH
56398: EMPTY
56399: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56400: LD_ADDR_EXP 90
56404: PUSH
56405: EMPTY
56406: ST_TO_ADDR
// mc_builders := [ ] ;
56407: LD_ADDR_EXP 64
56411: PUSH
56412: EMPTY
56413: ST_TO_ADDR
// mc_construct_list := [ ] ;
56414: LD_ADDR_EXP 65
56418: PUSH
56419: EMPTY
56420: ST_TO_ADDR
// mc_turret_list := [ ] ;
56421: LD_ADDR_EXP 66
56425: PUSH
56426: EMPTY
56427: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56428: LD_ADDR_EXP 67
56432: PUSH
56433: EMPTY
56434: ST_TO_ADDR
// mc_miners := [ ] ;
56435: LD_ADDR_EXP 72
56439: PUSH
56440: EMPTY
56441: ST_TO_ADDR
// mc_mines := [ ] ;
56442: LD_ADDR_EXP 71
56446: PUSH
56447: EMPTY
56448: ST_TO_ADDR
// mc_minefields := [ ] ;
56449: LD_ADDR_EXP 73
56453: PUSH
56454: EMPTY
56455: ST_TO_ADDR
// mc_crates := [ ] ;
56456: LD_ADDR_EXP 74
56460: PUSH
56461: EMPTY
56462: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56463: LD_ADDR_EXP 75
56467: PUSH
56468: EMPTY
56469: ST_TO_ADDR
// mc_crates_area := [ ] ;
56470: LD_ADDR_EXP 76
56474: PUSH
56475: EMPTY
56476: ST_TO_ADDR
// mc_vehicles := [ ] ;
56477: LD_ADDR_EXP 77
56481: PUSH
56482: EMPTY
56483: ST_TO_ADDR
// mc_attack := [ ] ;
56484: LD_ADDR_EXP 78
56488: PUSH
56489: EMPTY
56490: ST_TO_ADDR
// mc_produce := [ ] ;
56491: LD_ADDR_EXP 79
56495: PUSH
56496: EMPTY
56497: ST_TO_ADDR
// mc_defender := [ ] ;
56498: LD_ADDR_EXP 80
56502: PUSH
56503: EMPTY
56504: ST_TO_ADDR
// mc_parking := [ ] ;
56505: LD_ADDR_EXP 82
56509: PUSH
56510: EMPTY
56511: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56512: LD_ADDR_EXP 68
56516: PUSH
56517: EMPTY
56518: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56519: LD_ADDR_EXP 70
56523: PUSH
56524: EMPTY
56525: ST_TO_ADDR
// mc_scan := [ ] ;
56526: LD_ADDR_EXP 81
56530: PUSH
56531: EMPTY
56532: ST_TO_ADDR
// mc_scan_area := [ ] ;
56533: LD_ADDR_EXP 83
56537: PUSH
56538: EMPTY
56539: ST_TO_ADDR
// mc_tech := [ ] ;
56540: LD_ADDR_EXP 85
56544: PUSH
56545: EMPTY
56546: ST_TO_ADDR
// mc_class := [ ] ;
56547: LD_ADDR_EXP 99
56551: PUSH
56552: EMPTY
56553: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56554: LD_ADDR_EXP 100
56558: PUSH
56559: EMPTY
56560: ST_TO_ADDR
// end ;
56561: LD_VAR 0 1
56565: RET
// export function MC_Kill ( base ) ; begin
56566: LD_INT 0
56568: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56569: LD_ADDR_EXP 58
56573: PUSH
56574: LD_EXP 58
56578: PPUSH
56579: LD_VAR 0 1
56583: PPUSH
56584: EMPTY
56585: PPUSH
56586: CALL_OW 1
56590: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56591: LD_ADDR_EXP 59
56595: PUSH
56596: LD_EXP 59
56600: PPUSH
56601: LD_VAR 0 1
56605: PPUSH
56606: EMPTY
56607: PPUSH
56608: CALL_OW 1
56612: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56613: LD_ADDR_EXP 60
56617: PUSH
56618: LD_EXP 60
56622: PPUSH
56623: LD_VAR 0 1
56627: PPUSH
56628: EMPTY
56629: PPUSH
56630: CALL_OW 1
56634: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56635: LD_ADDR_EXP 61
56639: PUSH
56640: LD_EXP 61
56644: PPUSH
56645: LD_VAR 0 1
56649: PPUSH
56650: EMPTY
56651: PPUSH
56652: CALL_OW 1
56656: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56657: LD_ADDR_EXP 62
56661: PUSH
56662: LD_EXP 62
56666: PPUSH
56667: LD_VAR 0 1
56671: PPUSH
56672: EMPTY
56673: PPUSH
56674: CALL_OW 1
56678: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56679: LD_ADDR_EXP 63
56683: PUSH
56684: LD_EXP 63
56688: PPUSH
56689: LD_VAR 0 1
56693: PPUSH
56694: EMPTY
56695: PPUSH
56696: CALL_OW 1
56700: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56701: LD_ADDR_EXP 64
56705: PUSH
56706: LD_EXP 64
56710: PPUSH
56711: LD_VAR 0 1
56715: PPUSH
56716: EMPTY
56717: PPUSH
56718: CALL_OW 1
56722: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56723: LD_ADDR_EXP 65
56727: PUSH
56728: LD_EXP 65
56732: PPUSH
56733: LD_VAR 0 1
56737: PPUSH
56738: EMPTY
56739: PPUSH
56740: CALL_OW 1
56744: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56745: LD_ADDR_EXP 66
56749: PUSH
56750: LD_EXP 66
56754: PPUSH
56755: LD_VAR 0 1
56759: PPUSH
56760: EMPTY
56761: PPUSH
56762: CALL_OW 1
56766: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56767: LD_ADDR_EXP 67
56771: PUSH
56772: LD_EXP 67
56776: PPUSH
56777: LD_VAR 0 1
56781: PPUSH
56782: EMPTY
56783: PPUSH
56784: CALL_OW 1
56788: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56789: LD_ADDR_EXP 68
56793: PUSH
56794: LD_EXP 68
56798: PPUSH
56799: LD_VAR 0 1
56803: PPUSH
56804: EMPTY
56805: PPUSH
56806: CALL_OW 1
56810: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56811: LD_ADDR_EXP 69
56815: PUSH
56816: LD_EXP 69
56820: PPUSH
56821: LD_VAR 0 1
56825: PPUSH
56826: LD_INT 0
56828: PPUSH
56829: CALL_OW 1
56833: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56834: LD_ADDR_EXP 70
56838: PUSH
56839: LD_EXP 70
56843: PPUSH
56844: LD_VAR 0 1
56848: PPUSH
56849: EMPTY
56850: PPUSH
56851: CALL_OW 1
56855: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56856: LD_ADDR_EXP 71
56860: PUSH
56861: LD_EXP 71
56865: PPUSH
56866: LD_VAR 0 1
56870: PPUSH
56871: EMPTY
56872: PPUSH
56873: CALL_OW 1
56877: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56878: LD_ADDR_EXP 72
56882: PUSH
56883: LD_EXP 72
56887: PPUSH
56888: LD_VAR 0 1
56892: PPUSH
56893: EMPTY
56894: PPUSH
56895: CALL_OW 1
56899: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56900: LD_ADDR_EXP 73
56904: PUSH
56905: LD_EXP 73
56909: PPUSH
56910: LD_VAR 0 1
56914: PPUSH
56915: EMPTY
56916: PPUSH
56917: CALL_OW 1
56921: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56922: LD_ADDR_EXP 74
56926: PUSH
56927: LD_EXP 74
56931: PPUSH
56932: LD_VAR 0 1
56936: PPUSH
56937: EMPTY
56938: PPUSH
56939: CALL_OW 1
56943: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56944: LD_ADDR_EXP 75
56948: PUSH
56949: LD_EXP 75
56953: PPUSH
56954: LD_VAR 0 1
56958: PPUSH
56959: EMPTY
56960: PPUSH
56961: CALL_OW 1
56965: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56966: LD_ADDR_EXP 76
56970: PUSH
56971: LD_EXP 76
56975: PPUSH
56976: LD_VAR 0 1
56980: PPUSH
56981: EMPTY
56982: PPUSH
56983: CALL_OW 1
56987: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56988: LD_ADDR_EXP 77
56992: PUSH
56993: LD_EXP 77
56997: PPUSH
56998: LD_VAR 0 1
57002: PPUSH
57003: EMPTY
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57010: LD_ADDR_EXP 78
57014: PUSH
57015: LD_EXP 78
57019: PPUSH
57020: LD_VAR 0 1
57024: PPUSH
57025: EMPTY
57026: PPUSH
57027: CALL_OW 1
57031: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57032: LD_ADDR_EXP 79
57036: PUSH
57037: LD_EXP 79
57041: PPUSH
57042: LD_VAR 0 1
57046: PPUSH
57047: EMPTY
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57054: LD_ADDR_EXP 80
57058: PUSH
57059: LD_EXP 80
57063: PPUSH
57064: LD_VAR 0 1
57068: PPUSH
57069: EMPTY
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57076: LD_ADDR_EXP 81
57080: PUSH
57081: LD_EXP 81
57085: PPUSH
57086: LD_VAR 0 1
57090: PPUSH
57091: EMPTY
57092: PPUSH
57093: CALL_OW 1
57097: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57098: LD_ADDR_EXP 82
57102: PUSH
57103: LD_EXP 82
57107: PPUSH
57108: LD_VAR 0 1
57112: PPUSH
57113: EMPTY
57114: PPUSH
57115: CALL_OW 1
57119: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57120: LD_ADDR_EXP 83
57124: PUSH
57125: LD_EXP 83
57129: PPUSH
57130: LD_VAR 0 1
57134: PPUSH
57135: EMPTY
57136: PPUSH
57137: CALL_OW 1
57141: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57142: LD_ADDR_EXP 85
57146: PUSH
57147: LD_EXP 85
57151: PPUSH
57152: LD_VAR 0 1
57156: PPUSH
57157: EMPTY
57158: PPUSH
57159: CALL_OW 1
57163: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57164: LD_ADDR_EXP 87
57168: PUSH
57169: LD_EXP 87
57173: PPUSH
57174: LD_VAR 0 1
57178: PPUSH
57179: EMPTY
57180: PPUSH
57181: CALL_OW 1
57185: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57186: LD_ADDR_EXP 88
57190: PUSH
57191: LD_EXP 88
57195: PPUSH
57196: LD_VAR 0 1
57200: PPUSH
57201: EMPTY
57202: PPUSH
57203: CALL_OW 1
57207: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57208: LD_ADDR_EXP 89
57212: PUSH
57213: LD_EXP 89
57217: PPUSH
57218: LD_VAR 0 1
57222: PPUSH
57223: EMPTY
57224: PPUSH
57225: CALL_OW 1
57229: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57230: LD_ADDR_EXP 90
57234: PUSH
57235: LD_EXP 90
57239: PPUSH
57240: LD_VAR 0 1
57244: PPUSH
57245: EMPTY
57246: PPUSH
57247: CALL_OW 1
57251: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57252: LD_ADDR_EXP 91
57256: PUSH
57257: LD_EXP 91
57261: PPUSH
57262: LD_VAR 0 1
57266: PPUSH
57267: EMPTY
57268: PPUSH
57269: CALL_OW 1
57273: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57274: LD_ADDR_EXP 92
57278: PUSH
57279: LD_EXP 92
57283: PPUSH
57284: LD_VAR 0 1
57288: PPUSH
57289: EMPTY
57290: PPUSH
57291: CALL_OW 1
57295: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57296: LD_ADDR_EXP 93
57300: PUSH
57301: LD_EXP 93
57305: PPUSH
57306: LD_VAR 0 1
57310: PPUSH
57311: EMPTY
57312: PPUSH
57313: CALL_OW 1
57317: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57318: LD_ADDR_EXP 94
57322: PUSH
57323: LD_EXP 94
57327: PPUSH
57328: LD_VAR 0 1
57332: PPUSH
57333: EMPTY
57334: PPUSH
57335: CALL_OW 1
57339: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57340: LD_ADDR_EXP 95
57344: PUSH
57345: LD_EXP 95
57349: PPUSH
57350: LD_VAR 0 1
57354: PPUSH
57355: EMPTY
57356: PPUSH
57357: CALL_OW 1
57361: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57362: LD_ADDR_EXP 96
57366: PUSH
57367: LD_EXP 96
57371: PPUSH
57372: LD_VAR 0 1
57376: PPUSH
57377: EMPTY
57378: PPUSH
57379: CALL_OW 1
57383: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57384: LD_ADDR_EXP 97
57388: PUSH
57389: LD_EXP 97
57393: PPUSH
57394: LD_VAR 0 1
57398: PPUSH
57399: EMPTY
57400: PPUSH
57401: CALL_OW 1
57405: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57406: LD_ADDR_EXP 98
57410: PUSH
57411: LD_EXP 98
57415: PPUSH
57416: LD_VAR 0 1
57420: PPUSH
57421: EMPTY
57422: PPUSH
57423: CALL_OW 1
57427: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57428: LD_ADDR_EXP 99
57432: PUSH
57433: LD_EXP 99
57437: PPUSH
57438: LD_VAR 0 1
57442: PPUSH
57443: EMPTY
57444: PPUSH
57445: CALL_OW 1
57449: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57450: LD_ADDR_EXP 100
57454: PUSH
57455: LD_EXP 100
57459: PPUSH
57460: LD_VAR 0 1
57464: PPUSH
57465: LD_INT 0
57467: PPUSH
57468: CALL_OW 1
57472: ST_TO_ADDR
// end ;
57473: LD_VAR 0 2
57477: RET
// export function MC_Start ( ) ; var i ; begin
57478: LD_INT 0
57480: PPUSH
57481: PPUSH
// for i = 1 to mc_bases do
57482: LD_ADDR_VAR 0 2
57486: PUSH
57487: DOUBLE
57488: LD_INT 1
57490: DEC
57491: ST_TO_ADDR
57492: LD_EXP 58
57496: PUSH
57497: FOR_TO
57498: IFFALSE 58575
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57500: LD_ADDR_EXP 58
57504: PUSH
57505: LD_EXP 58
57509: PPUSH
57510: LD_VAR 0 2
57514: PPUSH
57515: LD_EXP 58
57519: PUSH
57520: LD_VAR 0 2
57524: ARRAY
57525: PUSH
57526: LD_INT 0
57528: DIFF
57529: PPUSH
57530: CALL_OW 1
57534: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57535: LD_ADDR_EXP 59
57539: PUSH
57540: LD_EXP 59
57544: PPUSH
57545: LD_VAR 0 2
57549: PPUSH
57550: EMPTY
57551: PPUSH
57552: CALL_OW 1
57556: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57557: LD_ADDR_EXP 60
57561: PUSH
57562: LD_EXP 60
57566: PPUSH
57567: LD_VAR 0 2
57571: PPUSH
57572: EMPTY
57573: PPUSH
57574: CALL_OW 1
57578: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57579: LD_ADDR_EXP 61
57583: PUSH
57584: LD_EXP 61
57588: PPUSH
57589: LD_VAR 0 2
57593: PPUSH
57594: EMPTY
57595: PPUSH
57596: CALL_OW 1
57600: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57601: LD_ADDR_EXP 62
57605: PUSH
57606: LD_EXP 62
57610: PPUSH
57611: LD_VAR 0 2
57615: PPUSH
57616: EMPTY
57617: PUSH
57618: EMPTY
57619: PUSH
57620: EMPTY
57621: LIST
57622: LIST
57623: PPUSH
57624: CALL_OW 1
57628: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57629: LD_ADDR_EXP 63
57633: PUSH
57634: LD_EXP 63
57638: PPUSH
57639: LD_VAR 0 2
57643: PPUSH
57644: EMPTY
57645: PPUSH
57646: CALL_OW 1
57650: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57651: LD_ADDR_EXP 90
57655: PUSH
57656: LD_EXP 90
57660: PPUSH
57661: LD_VAR 0 2
57665: PPUSH
57666: EMPTY
57667: PPUSH
57668: CALL_OW 1
57672: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57673: LD_ADDR_EXP 64
57677: PUSH
57678: LD_EXP 64
57682: PPUSH
57683: LD_VAR 0 2
57687: PPUSH
57688: EMPTY
57689: PPUSH
57690: CALL_OW 1
57694: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57695: LD_ADDR_EXP 65
57699: PUSH
57700: LD_EXP 65
57704: PPUSH
57705: LD_VAR 0 2
57709: PPUSH
57710: EMPTY
57711: PPUSH
57712: CALL_OW 1
57716: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57717: LD_ADDR_EXP 66
57721: PUSH
57722: LD_EXP 66
57726: PPUSH
57727: LD_VAR 0 2
57731: PPUSH
57732: LD_EXP 58
57736: PUSH
57737: LD_VAR 0 2
57741: ARRAY
57742: PPUSH
57743: LD_INT 2
57745: PUSH
57746: LD_INT 30
57748: PUSH
57749: LD_INT 32
57751: PUSH
57752: EMPTY
57753: LIST
57754: LIST
57755: PUSH
57756: LD_INT 30
57758: PUSH
57759: LD_INT 33
57761: PUSH
57762: EMPTY
57763: LIST
57764: LIST
57765: PUSH
57766: EMPTY
57767: LIST
57768: LIST
57769: LIST
57770: PPUSH
57771: CALL_OW 72
57775: PPUSH
57776: CALL_OW 1
57780: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57781: LD_ADDR_EXP 67
57785: PUSH
57786: LD_EXP 67
57790: PPUSH
57791: LD_VAR 0 2
57795: PPUSH
57796: LD_EXP 58
57800: PUSH
57801: LD_VAR 0 2
57805: ARRAY
57806: PPUSH
57807: LD_INT 2
57809: PUSH
57810: LD_INT 30
57812: PUSH
57813: LD_INT 32
57815: PUSH
57816: EMPTY
57817: LIST
57818: LIST
57819: PUSH
57820: LD_INT 30
57822: PUSH
57823: LD_INT 31
57825: PUSH
57826: EMPTY
57827: LIST
57828: LIST
57829: PUSH
57830: EMPTY
57831: LIST
57832: LIST
57833: LIST
57834: PUSH
57835: LD_INT 58
57837: PUSH
57838: EMPTY
57839: LIST
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PPUSH
57845: CALL_OW 72
57849: PPUSH
57850: CALL_OW 1
57854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57855: LD_ADDR_EXP 68
57859: PUSH
57860: LD_EXP 68
57864: PPUSH
57865: LD_VAR 0 2
57869: PPUSH
57870: EMPTY
57871: PPUSH
57872: CALL_OW 1
57876: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57877: LD_ADDR_EXP 72
57881: PUSH
57882: LD_EXP 72
57886: PPUSH
57887: LD_VAR 0 2
57891: PPUSH
57892: EMPTY
57893: PPUSH
57894: CALL_OW 1
57898: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57899: LD_ADDR_EXP 71
57903: PUSH
57904: LD_EXP 71
57908: PPUSH
57909: LD_VAR 0 2
57913: PPUSH
57914: EMPTY
57915: PPUSH
57916: CALL_OW 1
57920: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57921: LD_ADDR_EXP 73
57925: PUSH
57926: LD_EXP 73
57930: PPUSH
57931: LD_VAR 0 2
57935: PPUSH
57936: EMPTY
57937: PPUSH
57938: CALL_OW 1
57942: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57943: LD_ADDR_EXP 74
57947: PUSH
57948: LD_EXP 74
57952: PPUSH
57953: LD_VAR 0 2
57957: PPUSH
57958: EMPTY
57959: PPUSH
57960: CALL_OW 1
57964: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57965: LD_ADDR_EXP 75
57969: PUSH
57970: LD_EXP 75
57974: PPUSH
57975: LD_VAR 0 2
57979: PPUSH
57980: EMPTY
57981: PPUSH
57982: CALL_OW 1
57986: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57987: LD_ADDR_EXP 76
57991: PUSH
57992: LD_EXP 76
57996: PPUSH
57997: LD_VAR 0 2
58001: PPUSH
58002: EMPTY
58003: PPUSH
58004: CALL_OW 1
58008: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
58009: LD_ADDR_EXP 77
58013: PUSH
58014: LD_EXP 77
58018: PPUSH
58019: LD_VAR 0 2
58023: PPUSH
58024: EMPTY
58025: PPUSH
58026: CALL_OW 1
58030: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
58031: LD_ADDR_EXP 78
58035: PUSH
58036: LD_EXP 78
58040: PPUSH
58041: LD_VAR 0 2
58045: PPUSH
58046: EMPTY
58047: PPUSH
58048: CALL_OW 1
58052: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
58053: LD_ADDR_EXP 79
58057: PUSH
58058: LD_EXP 79
58062: PPUSH
58063: LD_VAR 0 2
58067: PPUSH
58068: EMPTY
58069: PPUSH
58070: CALL_OW 1
58074: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58075: LD_ADDR_EXP 80
58079: PUSH
58080: LD_EXP 80
58084: PPUSH
58085: LD_VAR 0 2
58089: PPUSH
58090: EMPTY
58091: PPUSH
58092: CALL_OW 1
58096: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58097: LD_ADDR_EXP 69
58101: PUSH
58102: LD_EXP 69
58106: PPUSH
58107: LD_VAR 0 2
58111: PPUSH
58112: LD_INT 0
58114: PPUSH
58115: CALL_OW 1
58119: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58120: LD_ADDR_EXP 82
58124: PUSH
58125: LD_EXP 82
58129: PPUSH
58130: LD_VAR 0 2
58134: PPUSH
58135: LD_INT 0
58137: PPUSH
58138: CALL_OW 1
58142: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58143: LD_ADDR_EXP 70
58147: PUSH
58148: LD_EXP 70
58152: PPUSH
58153: LD_VAR 0 2
58157: PPUSH
58158: EMPTY
58159: PPUSH
58160: CALL_OW 1
58164: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58165: LD_ADDR_EXP 81
58169: PUSH
58170: LD_EXP 81
58174: PPUSH
58175: LD_VAR 0 2
58179: PPUSH
58180: LD_INT 0
58182: PPUSH
58183: CALL_OW 1
58187: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58188: LD_ADDR_EXP 83
58192: PUSH
58193: LD_EXP 83
58197: PPUSH
58198: LD_VAR 0 2
58202: PPUSH
58203: EMPTY
58204: PPUSH
58205: CALL_OW 1
58209: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58210: LD_ADDR_EXP 86
58214: PUSH
58215: LD_EXP 86
58219: PPUSH
58220: LD_VAR 0 2
58224: PPUSH
58225: LD_INT 0
58227: PPUSH
58228: CALL_OW 1
58232: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58233: LD_ADDR_EXP 87
58237: PUSH
58238: LD_EXP 87
58242: PPUSH
58243: LD_VAR 0 2
58247: PPUSH
58248: EMPTY
58249: PPUSH
58250: CALL_OW 1
58254: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58255: LD_ADDR_EXP 88
58259: PUSH
58260: LD_EXP 88
58264: PPUSH
58265: LD_VAR 0 2
58269: PPUSH
58270: EMPTY
58271: PPUSH
58272: CALL_OW 1
58276: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58277: LD_ADDR_EXP 89
58281: PUSH
58282: LD_EXP 89
58286: PPUSH
58287: LD_VAR 0 2
58291: PPUSH
58292: EMPTY
58293: PPUSH
58294: CALL_OW 1
58298: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58299: LD_ADDR_EXP 91
58303: PUSH
58304: LD_EXP 91
58308: PPUSH
58309: LD_VAR 0 2
58313: PPUSH
58314: LD_EXP 58
58318: PUSH
58319: LD_VAR 0 2
58323: ARRAY
58324: PPUSH
58325: LD_INT 2
58327: PUSH
58328: LD_INT 30
58330: PUSH
58331: LD_INT 6
58333: PUSH
58334: EMPTY
58335: LIST
58336: LIST
58337: PUSH
58338: LD_INT 30
58340: PUSH
58341: LD_INT 7
58343: PUSH
58344: EMPTY
58345: LIST
58346: LIST
58347: PUSH
58348: LD_INT 30
58350: PUSH
58351: LD_INT 8
58353: PUSH
58354: EMPTY
58355: LIST
58356: LIST
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: LIST
58362: LIST
58363: PPUSH
58364: CALL_OW 72
58368: PPUSH
58369: CALL_OW 1
58373: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58374: LD_ADDR_EXP 92
58378: PUSH
58379: LD_EXP 92
58383: PPUSH
58384: LD_VAR 0 2
58388: PPUSH
58389: EMPTY
58390: PPUSH
58391: CALL_OW 1
58395: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58396: LD_ADDR_EXP 93
58400: PUSH
58401: LD_EXP 93
58405: PPUSH
58406: LD_VAR 0 2
58410: PPUSH
58411: EMPTY
58412: PPUSH
58413: CALL_OW 1
58417: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58418: LD_ADDR_EXP 94
58422: PUSH
58423: LD_EXP 94
58427: PPUSH
58428: LD_VAR 0 2
58432: PPUSH
58433: EMPTY
58434: PPUSH
58435: CALL_OW 1
58439: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58440: LD_ADDR_EXP 95
58444: PUSH
58445: LD_EXP 95
58449: PPUSH
58450: LD_VAR 0 2
58454: PPUSH
58455: EMPTY
58456: PPUSH
58457: CALL_OW 1
58461: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58462: LD_ADDR_EXP 96
58466: PUSH
58467: LD_EXP 96
58471: PPUSH
58472: LD_VAR 0 2
58476: PPUSH
58477: EMPTY
58478: PPUSH
58479: CALL_OW 1
58483: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58484: LD_ADDR_EXP 97
58488: PUSH
58489: LD_EXP 97
58493: PPUSH
58494: LD_VAR 0 2
58498: PPUSH
58499: EMPTY
58500: PPUSH
58501: CALL_OW 1
58505: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58506: LD_ADDR_EXP 98
58510: PUSH
58511: LD_EXP 98
58515: PPUSH
58516: LD_VAR 0 2
58520: PPUSH
58521: EMPTY
58522: PPUSH
58523: CALL_OW 1
58527: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58528: LD_ADDR_EXP 99
58532: PUSH
58533: LD_EXP 99
58537: PPUSH
58538: LD_VAR 0 2
58542: PPUSH
58543: EMPTY
58544: PPUSH
58545: CALL_OW 1
58549: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58550: LD_ADDR_EXP 100
58554: PUSH
58555: LD_EXP 100
58559: PPUSH
58560: LD_VAR 0 2
58564: PPUSH
58565: LD_INT 0
58567: PPUSH
58568: CALL_OW 1
58572: ST_TO_ADDR
// end ;
58573: GO 57497
58575: POP
58576: POP
// MC_InitSides ( ) ;
58577: CALL 58863 0 0
// MC_InitResearch ( ) ;
58581: CALL 58602 0 0
// CustomInitMacro ( ) ;
58585: CALL 174 0 0
// skirmish := true ;
58589: LD_ADDR_EXP 56
58593: PUSH
58594: LD_INT 1
58596: ST_TO_ADDR
// end ;
58597: LD_VAR 0 1
58601: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58602: LD_INT 0
58604: PPUSH
58605: PPUSH
58606: PPUSH
58607: PPUSH
58608: PPUSH
58609: PPUSH
// if not mc_bases then
58610: LD_EXP 58
58614: NOT
58615: IFFALSE 58619
// exit ;
58617: GO 58858
// for i = 1 to 8 do
58619: LD_ADDR_VAR 0 2
58623: PUSH
58624: DOUBLE
58625: LD_INT 1
58627: DEC
58628: ST_TO_ADDR
58629: LD_INT 8
58631: PUSH
58632: FOR_TO
58633: IFFALSE 58659
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58635: LD_ADDR_EXP 85
58639: PUSH
58640: LD_EXP 85
58644: PPUSH
58645: LD_VAR 0 2
58649: PPUSH
58650: EMPTY
58651: PPUSH
58652: CALL_OW 1
58656: ST_TO_ADDR
58657: GO 58632
58659: POP
58660: POP
// tmp := [ ] ;
58661: LD_ADDR_VAR 0 5
58665: PUSH
58666: EMPTY
58667: ST_TO_ADDR
// for i = 1 to mc_sides do
58668: LD_ADDR_VAR 0 2
58672: PUSH
58673: DOUBLE
58674: LD_INT 1
58676: DEC
58677: ST_TO_ADDR
58678: LD_EXP 84
58682: PUSH
58683: FOR_TO
58684: IFFALSE 58742
// if not mc_sides [ i ] in tmp then
58686: LD_EXP 84
58690: PUSH
58691: LD_VAR 0 2
58695: ARRAY
58696: PUSH
58697: LD_VAR 0 5
58701: IN
58702: NOT
58703: IFFALSE 58740
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58705: LD_ADDR_VAR 0 5
58709: PUSH
58710: LD_VAR 0 5
58714: PPUSH
58715: LD_VAR 0 5
58719: PUSH
58720: LD_INT 1
58722: PLUS
58723: PPUSH
58724: LD_EXP 84
58728: PUSH
58729: LD_VAR 0 2
58733: ARRAY
58734: PPUSH
58735: CALL_OW 2
58739: ST_TO_ADDR
58740: GO 58683
58742: POP
58743: POP
// if not tmp then
58744: LD_VAR 0 5
58748: NOT
58749: IFFALSE 58753
// exit ;
58751: GO 58858
// for j in tmp do
58753: LD_ADDR_VAR 0 3
58757: PUSH
58758: LD_VAR 0 5
58762: PUSH
58763: FOR_IN
58764: IFFALSE 58856
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58766: LD_ADDR_VAR 0 6
58770: PUSH
58771: LD_INT 22
58773: PUSH
58774: LD_VAR 0 3
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: PPUSH
58783: CALL_OW 69
58787: ST_TO_ADDR
// if not un then
58788: LD_VAR 0 6
58792: NOT
58793: IFFALSE 58797
// continue ;
58795: GO 58763
// nation := GetNation ( un [ 1 ] ) ;
58797: LD_ADDR_VAR 0 4
58801: PUSH
58802: LD_VAR 0 6
58806: PUSH
58807: LD_INT 1
58809: ARRAY
58810: PPUSH
58811: CALL_OW 248
58815: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58816: LD_ADDR_EXP 85
58820: PUSH
58821: LD_EXP 85
58825: PPUSH
58826: LD_VAR 0 3
58830: PPUSH
58831: LD_VAR 0 3
58835: PPUSH
58836: LD_VAR 0 4
58840: PPUSH
58841: LD_INT 1
58843: PPUSH
58844: CALL 13861 0 3
58848: PPUSH
58849: CALL_OW 1
58853: ST_TO_ADDR
// end ;
58854: GO 58763
58856: POP
58857: POP
// end ;
58858: LD_VAR 0 1
58862: RET
// export function MC_InitSides ( ) ; var i ; begin
58863: LD_INT 0
58865: PPUSH
58866: PPUSH
// if not mc_bases then
58867: LD_EXP 58
58871: NOT
58872: IFFALSE 58876
// exit ;
58874: GO 58950
// for i = 1 to mc_bases do
58876: LD_ADDR_VAR 0 2
58880: PUSH
58881: DOUBLE
58882: LD_INT 1
58884: DEC
58885: ST_TO_ADDR
58886: LD_EXP 58
58890: PUSH
58891: FOR_TO
58892: IFFALSE 58948
// if mc_bases [ i ] then
58894: LD_EXP 58
58898: PUSH
58899: LD_VAR 0 2
58903: ARRAY
58904: IFFALSE 58946
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58906: LD_ADDR_EXP 84
58910: PUSH
58911: LD_EXP 84
58915: PPUSH
58916: LD_VAR 0 2
58920: PPUSH
58921: LD_EXP 58
58925: PUSH
58926: LD_VAR 0 2
58930: ARRAY
58931: PUSH
58932: LD_INT 1
58934: ARRAY
58935: PPUSH
58936: CALL_OW 255
58940: PPUSH
58941: CALL_OW 1
58945: ST_TO_ADDR
58946: GO 58891
58948: POP
58949: POP
// end ;
58950: LD_VAR 0 1
58954: RET
// every 0 0$01 trigger skirmish do
58955: LD_EXP 56
58959: IFFALSE 59113
58961: GO 58963
58963: DISABLE
// begin enable ;
58964: ENABLE
// MC_CheckBuildings ( ) ;
58965: CALL 63602 0 0
// MC_CheckPeopleLife ( ) ;
58969: CALL 63727 0 0
// RaiseSailEvent ( 100 ) ;
58973: LD_INT 100
58975: PPUSH
58976: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58980: LD_INT 103
58982: PPUSH
58983: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58987: LD_INT 104
58989: PPUSH
58990: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58994: LD_INT 105
58996: PPUSH
58997: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
59001: LD_INT 106
59003: PPUSH
59004: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
59008: LD_INT 107
59010: PPUSH
59011: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
59015: LD_INT 108
59017: PPUSH
59018: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
59022: LD_INT 109
59024: PPUSH
59025: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
59029: LD_INT 110
59031: PPUSH
59032: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
59036: LD_INT 111
59038: PPUSH
59039: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
59043: LD_INT 112
59045: PPUSH
59046: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
59050: LD_INT 113
59052: PPUSH
59053: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59057: LD_INT 120
59059: PPUSH
59060: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59064: LD_INT 121
59066: PPUSH
59067: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59071: LD_INT 122
59073: PPUSH
59074: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59078: LD_INT 123
59080: PPUSH
59081: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59085: LD_INT 124
59087: PPUSH
59088: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59092: LD_INT 125
59094: PPUSH
59095: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59099: LD_INT 126
59101: PPUSH
59102: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59106: LD_INT 200
59108: PPUSH
59109: CALL_OW 427
// end ;
59113: END
// on SailEvent ( event ) do begin if event < 100 then
59114: LD_VAR 0 1
59118: PUSH
59119: LD_INT 100
59121: LESS
59122: IFFALSE 59133
// CustomEvent ( event ) ;
59124: LD_VAR 0 1
59128: PPUSH
59129: CALL 12575 0 1
// if event = 100 then
59133: LD_VAR 0 1
59137: PUSH
59138: LD_INT 100
59140: EQUAL
59141: IFFALSE 59147
// MC_ClassManager ( ) ;
59143: CALL 59539 0 0
// if event = 101 then
59147: LD_VAR 0 1
59151: PUSH
59152: LD_INT 101
59154: EQUAL
59155: IFFALSE 59161
// MC_RepairBuildings ( ) ;
59157: CALL 64323 0 0
// if event = 102 then
59161: LD_VAR 0 1
59165: PUSH
59166: LD_INT 102
59168: EQUAL
59169: IFFALSE 59175
// MC_Heal ( ) ;
59171: CALL 64729 0 0
// if event = 103 then
59175: LD_VAR 0 1
59179: PUSH
59180: LD_INT 103
59182: EQUAL
59183: IFFALSE 59189
// MC_Build ( ) ;
59185: CALL 65151 0 0
// if event = 104 then
59189: LD_VAR 0 1
59193: PUSH
59194: LD_INT 104
59196: EQUAL
59197: IFFALSE 59203
// MC_TurretWeapon ( ) ;
59199: CALL 66764 0 0
// if event = 105 then
59203: LD_VAR 0 1
59207: PUSH
59208: LD_INT 105
59210: EQUAL
59211: IFFALSE 59217
// MC_BuildUpgrade ( ) ;
59213: CALL 66315 0 0
// if event = 106 then
59217: LD_VAR 0 1
59221: PUSH
59222: LD_INT 106
59224: EQUAL
59225: IFFALSE 59231
// MC_PlantMines ( ) ;
59227: CALL 67194 0 0
// if event = 107 then
59231: LD_VAR 0 1
59235: PUSH
59236: LD_INT 107
59238: EQUAL
59239: IFFALSE 59245
// MC_CollectCrates ( ) ;
59241: CALL 68228 0 0
// if event = 108 then
59245: LD_VAR 0 1
59249: PUSH
59250: LD_INT 108
59252: EQUAL
59253: IFFALSE 59259
// MC_LinkRemoteControl ( ) ;
59255: CALL 69985 0 0
// if event = 109 then
59259: LD_VAR 0 1
59263: PUSH
59264: LD_INT 109
59266: EQUAL
59267: IFFALSE 59273
// MC_ProduceVehicle ( ) ;
59269: CALL 70166 0 0
// if event = 110 then
59273: LD_VAR 0 1
59277: PUSH
59278: LD_INT 110
59280: EQUAL
59281: IFFALSE 59287
// MC_SendAttack ( ) ;
59283: CALL 70647 0 0
// if event = 111 then
59287: LD_VAR 0 1
59291: PUSH
59292: LD_INT 111
59294: EQUAL
59295: IFFALSE 59301
// MC_Defend ( ) ;
59297: CALL 70755 0 0
// if event = 112 then
59301: LD_VAR 0 1
59305: PUSH
59306: LD_INT 112
59308: EQUAL
59309: IFFALSE 59315
// MC_Research ( ) ;
59311: CALL 71382 0 0
// if event = 113 then
59315: LD_VAR 0 1
59319: PUSH
59320: LD_INT 113
59322: EQUAL
59323: IFFALSE 59329
// MC_MinesTrigger ( ) ;
59325: CALL 72496 0 0
// if event = 120 then
59329: LD_VAR 0 1
59333: PUSH
59334: LD_INT 120
59336: EQUAL
59337: IFFALSE 59343
// MC_RepairVehicle ( ) ;
59339: CALL 72595 0 0
// if event = 121 then
59343: LD_VAR 0 1
59347: PUSH
59348: LD_INT 121
59350: EQUAL
59351: IFFALSE 59357
// MC_TameApe ( ) ;
59353: CALL 73338 0 0
// if event = 122 then
59357: LD_VAR 0 1
59361: PUSH
59362: LD_INT 122
59364: EQUAL
59365: IFFALSE 59371
// MC_ChangeApeClass ( ) ;
59367: CALL 74167 0 0
// if event = 123 then
59371: LD_VAR 0 1
59375: PUSH
59376: LD_INT 123
59378: EQUAL
59379: IFFALSE 59385
// MC_Bazooka ( ) ;
59381: CALL 74817 0 0
// if event = 124 then
59385: LD_VAR 0 1
59389: PUSH
59390: LD_INT 124
59392: EQUAL
59393: IFFALSE 59399
// MC_TeleportExit ( ) ;
59395: CALL 75015 0 0
// if event = 125 then
59399: LD_VAR 0 1
59403: PUSH
59404: LD_INT 125
59406: EQUAL
59407: IFFALSE 59413
// MC_Deposits ( ) ;
59409: CALL 75662 0 0
// if event = 126 then
59413: LD_VAR 0 1
59417: PUSH
59418: LD_INT 126
59420: EQUAL
59421: IFFALSE 59427
// MC_RemoteDriver ( ) ;
59423: CALL 76287 0 0
// if event = 200 then
59427: LD_VAR 0 1
59431: PUSH
59432: LD_INT 200
59434: EQUAL
59435: IFFALSE 59441
// MC_Idle ( ) ;
59437: CALL 78020 0 0
// end ;
59441: PPOPN 1
59443: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59444: LD_INT 0
59446: PPUSH
59447: PPUSH
// if not mc_bases [ base ] or not tag then
59448: LD_EXP 58
59452: PUSH
59453: LD_VAR 0 1
59457: ARRAY
59458: NOT
59459: PUSH
59460: LD_VAR 0 2
59464: NOT
59465: OR
59466: IFFALSE 59470
// exit ;
59468: GO 59534
// for i in mc_bases [ base ] union mc_ape [ base ] do
59470: LD_ADDR_VAR 0 4
59474: PUSH
59475: LD_EXP 58
59479: PUSH
59480: LD_VAR 0 1
59484: ARRAY
59485: PUSH
59486: LD_EXP 87
59490: PUSH
59491: LD_VAR 0 1
59495: ARRAY
59496: UNION
59497: PUSH
59498: FOR_IN
59499: IFFALSE 59532
// if GetTag ( i ) = tag then
59501: LD_VAR 0 4
59505: PPUSH
59506: CALL_OW 110
59510: PUSH
59511: LD_VAR 0 2
59515: EQUAL
59516: IFFALSE 59530
// SetTag ( i , 0 ) ;
59518: LD_VAR 0 4
59522: PPUSH
59523: LD_INT 0
59525: PPUSH
59526: CALL_OW 109
59530: GO 59498
59532: POP
59533: POP
// end ;
59534: LD_VAR 0 3
59538: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59539: LD_INT 0
59541: PPUSH
59542: PPUSH
59543: PPUSH
59544: PPUSH
59545: PPUSH
59546: PPUSH
59547: PPUSH
59548: PPUSH
// if not mc_bases then
59549: LD_EXP 58
59553: NOT
59554: IFFALSE 59558
// exit ;
59556: GO 60016
// for i = 1 to mc_bases do
59558: LD_ADDR_VAR 0 2
59562: PUSH
59563: DOUBLE
59564: LD_INT 1
59566: DEC
59567: ST_TO_ADDR
59568: LD_EXP 58
59572: PUSH
59573: FOR_TO
59574: IFFALSE 60014
// begin tmp := MC_ClassCheckReq ( i ) ;
59576: LD_ADDR_VAR 0 4
59580: PUSH
59581: LD_VAR 0 2
59585: PPUSH
59586: CALL 60021 0 1
59590: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59591: LD_ADDR_EXP 99
59595: PUSH
59596: LD_EXP 99
59600: PPUSH
59601: LD_VAR 0 2
59605: PPUSH
59606: LD_VAR 0 4
59610: PPUSH
59611: CALL_OW 1
59615: ST_TO_ADDR
// if not tmp then
59616: LD_VAR 0 4
59620: NOT
59621: IFFALSE 59625
// continue ;
59623: GO 59573
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59625: LD_ADDR_VAR 0 6
59629: PUSH
59630: LD_EXP 58
59634: PUSH
59635: LD_VAR 0 2
59639: ARRAY
59640: PPUSH
59641: LD_INT 2
59643: PUSH
59644: LD_INT 30
59646: PUSH
59647: LD_INT 4
59649: PUSH
59650: EMPTY
59651: LIST
59652: LIST
59653: PUSH
59654: LD_INT 30
59656: PUSH
59657: LD_INT 5
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: PUSH
59664: EMPTY
59665: LIST
59666: LIST
59667: LIST
59668: PPUSH
59669: CALL_OW 72
59673: PUSH
59674: LD_EXP 58
59678: PUSH
59679: LD_VAR 0 2
59683: ARRAY
59684: PPUSH
59685: LD_INT 2
59687: PUSH
59688: LD_INT 30
59690: PUSH
59691: LD_INT 0
59693: PUSH
59694: EMPTY
59695: LIST
59696: LIST
59697: PUSH
59698: LD_INT 30
59700: PUSH
59701: LD_INT 1
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: LIST
59712: PPUSH
59713: CALL_OW 72
59717: PUSH
59718: LD_EXP 58
59722: PUSH
59723: LD_VAR 0 2
59727: ARRAY
59728: PPUSH
59729: LD_INT 30
59731: PUSH
59732: LD_INT 3
59734: PUSH
59735: EMPTY
59736: LIST
59737: LIST
59738: PPUSH
59739: CALL_OW 72
59743: PUSH
59744: LD_EXP 58
59748: PUSH
59749: LD_VAR 0 2
59753: ARRAY
59754: PPUSH
59755: LD_INT 2
59757: PUSH
59758: LD_INT 30
59760: PUSH
59761: LD_INT 6
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: PUSH
59768: LD_INT 30
59770: PUSH
59771: LD_INT 7
59773: PUSH
59774: EMPTY
59775: LIST
59776: LIST
59777: PUSH
59778: LD_INT 30
59780: PUSH
59781: LD_INT 8
59783: PUSH
59784: EMPTY
59785: LIST
59786: LIST
59787: PUSH
59788: EMPTY
59789: LIST
59790: LIST
59791: LIST
59792: LIST
59793: PPUSH
59794: CALL_OW 72
59798: PUSH
59799: EMPTY
59800: LIST
59801: LIST
59802: LIST
59803: LIST
59804: ST_TO_ADDR
// for j = 1 to 4 do
59805: LD_ADDR_VAR 0 3
59809: PUSH
59810: DOUBLE
59811: LD_INT 1
59813: DEC
59814: ST_TO_ADDR
59815: LD_INT 4
59817: PUSH
59818: FOR_TO
59819: IFFALSE 60010
// begin if not tmp [ j ] then
59821: LD_VAR 0 4
59825: PUSH
59826: LD_VAR 0 3
59830: ARRAY
59831: NOT
59832: IFFALSE 59836
// continue ;
59834: GO 59818
// for p in tmp [ j ] do
59836: LD_ADDR_VAR 0 5
59840: PUSH
59841: LD_VAR 0 4
59845: PUSH
59846: LD_VAR 0 3
59850: ARRAY
59851: PUSH
59852: FOR_IN
59853: IFFALSE 60006
// begin if not b [ j ] then
59855: LD_VAR 0 6
59859: PUSH
59860: LD_VAR 0 3
59864: ARRAY
59865: NOT
59866: IFFALSE 59870
// break ;
59868: GO 60006
// e := 0 ;
59870: LD_ADDR_VAR 0 7
59874: PUSH
59875: LD_INT 0
59877: ST_TO_ADDR
// for k in b [ j ] do
59878: LD_ADDR_VAR 0 8
59882: PUSH
59883: LD_VAR 0 6
59887: PUSH
59888: LD_VAR 0 3
59892: ARRAY
59893: PUSH
59894: FOR_IN
59895: IFFALSE 59922
// if IsNotFull ( k ) then
59897: LD_VAR 0 8
59901: PPUSH
59902: CALL 17887 0 1
59906: IFFALSE 59920
// begin e := k ;
59908: LD_ADDR_VAR 0 7
59912: PUSH
59913: LD_VAR 0 8
59917: ST_TO_ADDR
// break ;
59918: GO 59922
// end ;
59920: GO 59894
59922: POP
59923: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59924: LD_VAR 0 7
59928: PUSH
59929: LD_VAR 0 5
59933: PPUSH
59934: LD_VAR 0 7
59938: PPUSH
59939: CALL 54875 0 2
59943: NOT
59944: AND
59945: IFFALSE 60004
// begin if IsInUnit ( p ) then
59947: LD_VAR 0 5
59951: PPUSH
59952: CALL_OW 310
59956: IFFALSE 59967
// ComExitBuilding ( p ) ;
59958: LD_VAR 0 5
59962: PPUSH
59963: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59967: LD_VAR 0 5
59971: PPUSH
59972: LD_VAR 0 7
59976: PPUSH
59977: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59981: LD_VAR 0 5
59985: PPUSH
59986: LD_VAR 0 3
59990: PPUSH
59991: CALL_OW 183
// AddComExitBuilding ( p ) ;
59995: LD_VAR 0 5
59999: PPUSH
60000: CALL_OW 182
// end ; end ;
60004: GO 59852
60006: POP
60007: POP
// end ;
60008: GO 59818
60010: POP
60011: POP
// end ;
60012: GO 59573
60014: POP
60015: POP
// end ;
60016: LD_VAR 0 1
60020: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
60021: LD_INT 0
60023: PPUSH
60024: PPUSH
60025: PPUSH
60026: PPUSH
60027: PPUSH
60028: PPUSH
60029: PPUSH
60030: PPUSH
60031: PPUSH
60032: PPUSH
60033: PPUSH
60034: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60035: LD_VAR 0 1
60039: NOT
60040: PUSH
60041: LD_EXP 58
60045: PUSH
60046: LD_VAR 0 1
60050: ARRAY
60051: NOT
60052: OR
60053: PUSH
60054: LD_EXP 58
60058: PUSH
60059: LD_VAR 0 1
60063: ARRAY
60064: PPUSH
60065: LD_INT 2
60067: PUSH
60068: LD_INT 30
60070: PUSH
60071: LD_INT 0
60073: PUSH
60074: EMPTY
60075: LIST
60076: LIST
60077: PUSH
60078: LD_INT 30
60080: PUSH
60081: LD_INT 1
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: PUSH
60088: EMPTY
60089: LIST
60090: LIST
60091: LIST
60092: PPUSH
60093: CALL_OW 72
60097: NOT
60098: OR
60099: IFFALSE 60103
// exit ;
60101: GO 63597
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60103: LD_ADDR_VAR 0 4
60107: PUSH
60108: LD_EXP 58
60112: PUSH
60113: LD_VAR 0 1
60117: ARRAY
60118: PPUSH
60119: LD_INT 2
60121: PUSH
60122: LD_INT 25
60124: PUSH
60125: LD_INT 1
60127: PUSH
60128: EMPTY
60129: LIST
60130: LIST
60131: PUSH
60132: LD_INT 25
60134: PUSH
60135: LD_INT 2
60137: PUSH
60138: EMPTY
60139: LIST
60140: LIST
60141: PUSH
60142: LD_INT 25
60144: PUSH
60145: LD_INT 3
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: PUSH
60152: LD_INT 25
60154: PUSH
60155: LD_INT 4
60157: PUSH
60158: EMPTY
60159: LIST
60160: LIST
60161: PUSH
60162: LD_INT 25
60164: PUSH
60165: LD_INT 5
60167: PUSH
60168: EMPTY
60169: LIST
60170: LIST
60171: PUSH
60172: LD_INT 25
60174: PUSH
60175: LD_INT 8
60177: PUSH
60178: EMPTY
60179: LIST
60180: LIST
60181: PUSH
60182: LD_INT 25
60184: PUSH
60185: LD_INT 9
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: EMPTY
60193: LIST
60194: LIST
60195: LIST
60196: LIST
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: PPUSH
60202: CALL_OW 72
60206: ST_TO_ADDR
// for i in tmp do
60207: LD_ADDR_VAR 0 3
60211: PUSH
60212: LD_VAR 0 4
60216: PUSH
60217: FOR_IN
60218: IFFALSE 60249
// if GetTag ( i ) then
60220: LD_VAR 0 3
60224: PPUSH
60225: CALL_OW 110
60229: IFFALSE 60247
// tmp := tmp diff i ;
60231: LD_ADDR_VAR 0 4
60235: PUSH
60236: LD_VAR 0 4
60240: PUSH
60241: LD_VAR 0 3
60245: DIFF
60246: ST_TO_ADDR
60247: GO 60217
60249: POP
60250: POP
// if not tmp then
60251: LD_VAR 0 4
60255: NOT
60256: IFFALSE 60260
// exit ;
60258: GO 63597
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60260: LD_ADDR_VAR 0 5
60264: PUSH
60265: LD_EXP 58
60269: PUSH
60270: LD_VAR 0 1
60274: ARRAY
60275: PPUSH
60276: LD_INT 2
60278: PUSH
60279: LD_INT 25
60281: PUSH
60282: LD_INT 1
60284: PUSH
60285: EMPTY
60286: LIST
60287: LIST
60288: PUSH
60289: LD_INT 25
60291: PUSH
60292: LD_INT 5
60294: PUSH
60295: EMPTY
60296: LIST
60297: LIST
60298: PUSH
60299: LD_INT 25
60301: PUSH
60302: LD_INT 8
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: PUSH
60309: LD_INT 25
60311: PUSH
60312: LD_INT 9
60314: PUSH
60315: EMPTY
60316: LIST
60317: LIST
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: LIST
60323: LIST
60324: LIST
60325: PPUSH
60326: CALL_OW 72
60330: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60331: LD_ADDR_VAR 0 6
60335: PUSH
60336: LD_EXP 58
60340: PUSH
60341: LD_VAR 0 1
60345: ARRAY
60346: PPUSH
60347: LD_INT 25
60349: PUSH
60350: LD_INT 2
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: PPUSH
60357: CALL_OW 72
60361: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60362: LD_ADDR_VAR 0 7
60366: PUSH
60367: LD_EXP 58
60371: PUSH
60372: LD_VAR 0 1
60376: ARRAY
60377: PPUSH
60378: LD_INT 25
60380: PUSH
60381: LD_INT 3
60383: PUSH
60384: EMPTY
60385: LIST
60386: LIST
60387: PPUSH
60388: CALL_OW 72
60392: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60393: LD_ADDR_VAR 0 8
60397: PUSH
60398: LD_EXP 58
60402: PUSH
60403: LD_VAR 0 1
60407: ARRAY
60408: PPUSH
60409: LD_INT 25
60411: PUSH
60412: LD_INT 4
60414: PUSH
60415: EMPTY
60416: LIST
60417: LIST
60418: PUSH
60419: LD_INT 24
60421: PUSH
60422: LD_INT 251
60424: PUSH
60425: EMPTY
60426: LIST
60427: LIST
60428: PUSH
60429: EMPTY
60430: LIST
60431: LIST
60432: PPUSH
60433: CALL_OW 72
60437: ST_TO_ADDR
// if mc_scan [ base ] then
60438: LD_EXP 81
60442: PUSH
60443: LD_VAR 0 1
60447: ARRAY
60448: IFFALSE 60909
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60450: LD_ADDR_EXP 100
60454: PUSH
60455: LD_EXP 100
60459: PPUSH
60460: LD_VAR 0 1
60464: PPUSH
60465: LD_INT 4
60467: PPUSH
60468: CALL_OW 1
60472: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60473: LD_ADDR_VAR 0 12
60477: PUSH
60478: LD_EXP 58
60482: PUSH
60483: LD_VAR 0 1
60487: ARRAY
60488: PPUSH
60489: LD_INT 2
60491: PUSH
60492: LD_INT 30
60494: PUSH
60495: LD_INT 4
60497: PUSH
60498: EMPTY
60499: LIST
60500: LIST
60501: PUSH
60502: LD_INT 30
60504: PUSH
60505: LD_INT 5
60507: PUSH
60508: EMPTY
60509: LIST
60510: LIST
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: LIST
60516: PPUSH
60517: CALL_OW 72
60521: ST_TO_ADDR
// if not b then
60522: LD_VAR 0 12
60526: NOT
60527: IFFALSE 60531
// exit ;
60529: GO 63597
// p := [ ] ;
60531: LD_ADDR_VAR 0 11
60535: PUSH
60536: EMPTY
60537: ST_TO_ADDR
// if sci >= 2 then
60538: LD_VAR 0 8
60542: PUSH
60543: LD_INT 2
60545: GREATEREQUAL
60546: IFFALSE 60577
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60548: LD_ADDR_VAR 0 8
60552: PUSH
60553: LD_VAR 0 8
60557: PUSH
60558: LD_INT 1
60560: ARRAY
60561: PUSH
60562: LD_VAR 0 8
60566: PUSH
60567: LD_INT 2
60569: ARRAY
60570: PUSH
60571: EMPTY
60572: LIST
60573: LIST
60574: ST_TO_ADDR
60575: GO 60638
// if sci = 1 then
60577: LD_VAR 0 8
60581: PUSH
60582: LD_INT 1
60584: EQUAL
60585: IFFALSE 60606
// sci := [ sci [ 1 ] ] else
60587: LD_ADDR_VAR 0 8
60591: PUSH
60592: LD_VAR 0 8
60596: PUSH
60597: LD_INT 1
60599: ARRAY
60600: PUSH
60601: EMPTY
60602: LIST
60603: ST_TO_ADDR
60604: GO 60638
// if sci = 0 then
60606: LD_VAR 0 8
60610: PUSH
60611: LD_INT 0
60613: EQUAL
60614: IFFALSE 60638
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60616: LD_ADDR_VAR 0 11
60620: PUSH
60621: LD_VAR 0 4
60625: PPUSH
60626: LD_INT 4
60628: PPUSH
60629: CALL 54738 0 2
60633: PUSH
60634: LD_INT 1
60636: ARRAY
60637: ST_TO_ADDR
// if eng > 4 then
60638: LD_VAR 0 6
60642: PUSH
60643: LD_INT 4
60645: GREATER
60646: IFFALSE 60692
// for i = eng downto 4 do
60648: LD_ADDR_VAR 0 3
60652: PUSH
60653: DOUBLE
60654: LD_VAR 0 6
60658: INC
60659: ST_TO_ADDR
60660: LD_INT 4
60662: PUSH
60663: FOR_DOWNTO
60664: IFFALSE 60690
// eng := eng diff eng [ i ] ;
60666: LD_ADDR_VAR 0 6
60670: PUSH
60671: LD_VAR 0 6
60675: PUSH
60676: LD_VAR 0 6
60680: PUSH
60681: LD_VAR 0 3
60685: ARRAY
60686: DIFF
60687: ST_TO_ADDR
60688: GO 60663
60690: POP
60691: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60692: LD_ADDR_VAR 0 4
60696: PUSH
60697: LD_VAR 0 4
60701: PUSH
60702: LD_VAR 0 5
60706: PUSH
60707: LD_VAR 0 6
60711: UNION
60712: PUSH
60713: LD_VAR 0 7
60717: UNION
60718: PUSH
60719: LD_VAR 0 8
60723: UNION
60724: DIFF
60725: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60726: LD_ADDR_VAR 0 13
60730: PUSH
60731: LD_EXP 58
60735: PUSH
60736: LD_VAR 0 1
60740: ARRAY
60741: PPUSH
60742: LD_INT 2
60744: PUSH
60745: LD_INT 30
60747: PUSH
60748: LD_INT 32
60750: PUSH
60751: EMPTY
60752: LIST
60753: LIST
60754: PUSH
60755: LD_INT 30
60757: PUSH
60758: LD_INT 31
60760: PUSH
60761: EMPTY
60762: LIST
60763: LIST
60764: PUSH
60765: EMPTY
60766: LIST
60767: LIST
60768: LIST
60769: PPUSH
60770: CALL_OW 72
60774: PUSH
60775: LD_EXP 58
60779: PUSH
60780: LD_VAR 0 1
60784: ARRAY
60785: PPUSH
60786: LD_INT 2
60788: PUSH
60789: LD_INT 30
60791: PUSH
60792: LD_INT 4
60794: PUSH
60795: EMPTY
60796: LIST
60797: LIST
60798: PUSH
60799: LD_INT 30
60801: PUSH
60802: LD_INT 5
60804: PUSH
60805: EMPTY
60806: LIST
60807: LIST
60808: PUSH
60809: EMPTY
60810: LIST
60811: LIST
60812: LIST
60813: PPUSH
60814: CALL_OW 72
60818: PUSH
60819: LD_INT 6
60821: MUL
60822: PLUS
60823: ST_TO_ADDR
// if bcount < tmp then
60824: LD_VAR 0 13
60828: PUSH
60829: LD_VAR 0 4
60833: LESS
60834: IFFALSE 60880
// for i = tmp downto bcount do
60836: LD_ADDR_VAR 0 3
60840: PUSH
60841: DOUBLE
60842: LD_VAR 0 4
60846: INC
60847: ST_TO_ADDR
60848: LD_VAR 0 13
60852: PUSH
60853: FOR_DOWNTO
60854: IFFALSE 60878
// tmp := Delete ( tmp , tmp ) ;
60856: LD_ADDR_VAR 0 4
60860: PUSH
60861: LD_VAR 0 4
60865: PPUSH
60866: LD_VAR 0 4
60870: PPUSH
60871: CALL_OW 3
60875: ST_TO_ADDR
60876: GO 60853
60878: POP
60879: POP
// result := [ tmp , 0 , 0 , p ] ;
60880: LD_ADDR_VAR 0 2
60884: PUSH
60885: LD_VAR 0 4
60889: PUSH
60890: LD_INT 0
60892: PUSH
60893: LD_INT 0
60895: PUSH
60896: LD_VAR 0 11
60900: PUSH
60901: EMPTY
60902: LIST
60903: LIST
60904: LIST
60905: LIST
60906: ST_TO_ADDR
// exit ;
60907: GO 63597
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60909: LD_EXP 58
60913: PUSH
60914: LD_VAR 0 1
60918: ARRAY
60919: PPUSH
60920: LD_INT 2
60922: PUSH
60923: LD_INT 30
60925: PUSH
60926: LD_INT 6
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PUSH
60933: LD_INT 30
60935: PUSH
60936: LD_INT 7
60938: PUSH
60939: EMPTY
60940: LIST
60941: LIST
60942: PUSH
60943: LD_INT 30
60945: PUSH
60946: LD_INT 8
60948: PUSH
60949: EMPTY
60950: LIST
60951: LIST
60952: PUSH
60953: EMPTY
60954: LIST
60955: LIST
60956: LIST
60957: LIST
60958: PPUSH
60959: CALL_OW 72
60963: NOT
60964: PUSH
60965: LD_EXP 58
60969: PUSH
60970: LD_VAR 0 1
60974: ARRAY
60975: PPUSH
60976: LD_INT 30
60978: PUSH
60979: LD_INT 3
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: PPUSH
60986: CALL_OW 72
60990: NOT
60991: AND
60992: IFFALSE 61064
// begin if eng = tmp then
60994: LD_VAR 0 6
60998: PUSH
60999: LD_VAR 0 4
61003: EQUAL
61004: IFFALSE 61008
// exit ;
61006: GO 63597
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
61008: LD_ADDR_EXP 100
61012: PUSH
61013: LD_EXP 100
61017: PPUSH
61018: LD_VAR 0 1
61022: PPUSH
61023: LD_INT 1
61025: PPUSH
61026: CALL_OW 1
61030: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
61031: LD_ADDR_VAR 0 2
61035: PUSH
61036: LD_INT 0
61038: PUSH
61039: LD_VAR 0 4
61043: PUSH
61044: LD_VAR 0 6
61048: DIFF
61049: PUSH
61050: LD_INT 0
61052: PUSH
61053: LD_INT 0
61055: PUSH
61056: EMPTY
61057: LIST
61058: LIST
61059: LIST
61060: LIST
61061: ST_TO_ADDR
// exit ;
61062: GO 63597
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61064: LD_EXP 85
61068: PUSH
61069: LD_EXP 84
61073: PUSH
61074: LD_VAR 0 1
61078: ARRAY
61079: ARRAY
61080: PUSH
61081: LD_EXP 58
61085: PUSH
61086: LD_VAR 0 1
61090: ARRAY
61091: PPUSH
61092: LD_INT 2
61094: PUSH
61095: LD_INT 30
61097: PUSH
61098: LD_INT 6
61100: PUSH
61101: EMPTY
61102: LIST
61103: LIST
61104: PUSH
61105: LD_INT 30
61107: PUSH
61108: LD_INT 7
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: PUSH
61115: LD_INT 30
61117: PUSH
61118: LD_INT 8
61120: PUSH
61121: EMPTY
61122: LIST
61123: LIST
61124: PUSH
61125: EMPTY
61126: LIST
61127: LIST
61128: LIST
61129: LIST
61130: PPUSH
61131: CALL_OW 72
61135: AND
61136: PUSH
61137: LD_EXP 58
61141: PUSH
61142: LD_VAR 0 1
61146: ARRAY
61147: PPUSH
61148: LD_INT 30
61150: PUSH
61151: LD_INT 3
61153: PUSH
61154: EMPTY
61155: LIST
61156: LIST
61157: PPUSH
61158: CALL_OW 72
61162: NOT
61163: AND
61164: IFFALSE 61378
// begin if sci >= 6 then
61166: LD_VAR 0 8
61170: PUSH
61171: LD_INT 6
61173: GREATEREQUAL
61174: IFFALSE 61178
// exit ;
61176: GO 63597
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61178: LD_ADDR_EXP 100
61182: PUSH
61183: LD_EXP 100
61187: PPUSH
61188: LD_VAR 0 1
61192: PPUSH
61193: LD_INT 2
61195: PPUSH
61196: CALL_OW 1
61200: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61201: LD_ADDR_VAR 0 9
61205: PUSH
61206: LD_VAR 0 4
61210: PUSH
61211: LD_VAR 0 8
61215: DIFF
61216: PPUSH
61217: LD_INT 4
61219: PPUSH
61220: CALL 54738 0 2
61224: ST_TO_ADDR
// p := [ ] ;
61225: LD_ADDR_VAR 0 11
61229: PUSH
61230: EMPTY
61231: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61232: LD_VAR 0 8
61236: PUSH
61237: LD_INT 6
61239: LESS
61240: PUSH
61241: LD_VAR 0 9
61245: PUSH
61246: LD_INT 6
61248: GREATER
61249: AND
61250: IFFALSE 61331
// begin for i = 1 to 6 - sci do
61252: LD_ADDR_VAR 0 3
61256: PUSH
61257: DOUBLE
61258: LD_INT 1
61260: DEC
61261: ST_TO_ADDR
61262: LD_INT 6
61264: PUSH
61265: LD_VAR 0 8
61269: MINUS
61270: PUSH
61271: FOR_TO
61272: IFFALSE 61327
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61274: LD_ADDR_VAR 0 11
61278: PUSH
61279: LD_VAR 0 11
61283: PPUSH
61284: LD_VAR 0 11
61288: PUSH
61289: LD_INT 1
61291: PLUS
61292: PPUSH
61293: LD_VAR 0 9
61297: PUSH
61298: LD_INT 1
61300: ARRAY
61301: PPUSH
61302: CALL_OW 2
61306: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61307: LD_ADDR_VAR 0 9
61311: PUSH
61312: LD_VAR 0 9
61316: PPUSH
61317: LD_INT 1
61319: PPUSH
61320: CALL_OW 3
61324: ST_TO_ADDR
// end ;
61325: GO 61271
61327: POP
61328: POP
// end else
61329: GO 61351
// if sort then
61331: LD_VAR 0 9
61335: IFFALSE 61351
// p := sort [ 1 ] ;
61337: LD_ADDR_VAR 0 11
61341: PUSH
61342: LD_VAR 0 9
61346: PUSH
61347: LD_INT 1
61349: ARRAY
61350: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61351: LD_ADDR_VAR 0 2
61355: PUSH
61356: LD_INT 0
61358: PUSH
61359: LD_INT 0
61361: PUSH
61362: LD_INT 0
61364: PUSH
61365: LD_VAR 0 11
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: LIST
61374: LIST
61375: ST_TO_ADDR
// exit ;
61376: GO 63597
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61378: LD_EXP 85
61382: PUSH
61383: LD_EXP 84
61387: PUSH
61388: LD_VAR 0 1
61392: ARRAY
61393: ARRAY
61394: PUSH
61395: LD_EXP 58
61399: PUSH
61400: LD_VAR 0 1
61404: ARRAY
61405: PPUSH
61406: LD_INT 2
61408: PUSH
61409: LD_INT 30
61411: PUSH
61412: LD_INT 6
61414: PUSH
61415: EMPTY
61416: LIST
61417: LIST
61418: PUSH
61419: LD_INT 30
61421: PUSH
61422: LD_INT 7
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 30
61431: PUSH
61432: LD_INT 8
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: PUSH
61439: EMPTY
61440: LIST
61441: LIST
61442: LIST
61443: LIST
61444: PPUSH
61445: CALL_OW 72
61449: AND
61450: PUSH
61451: LD_EXP 58
61455: PUSH
61456: LD_VAR 0 1
61460: ARRAY
61461: PPUSH
61462: LD_INT 30
61464: PUSH
61465: LD_INT 3
61467: PUSH
61468: EMPTY
61469: LIST
61470: LIST
61471: PPUSH
61472: CALL_OW 72
61476: AND
61477: IFFALSE 62211
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61479: LD_ADDR_EXP 100
61483: PUSH
61484: LD_EXP 100
61488: PPUSH
61489: LD_VAR 0 1
61493: PPUSH
61494: LD_INT 3
61496: PPUSH
61497: CALL_OW 1
61501: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61502: LD_ADDR_VAR 0 2
61506: PUSH
61507: LD_INT 0
61509: PUSH
61510: LD_INT 0
61512: PUSH
61513: LD_INT 0
61515: PUSH
61516: LD_INT 0
61518: PUSH
61519: EMPTY
61520: LIST
61521: LIST
61522: LIST
61523: LIST
61524: ST_TO_ADDR
// if not eng then
61525: LD_VAR 0 6
61529: NOT
61530: IFFALSE 61593
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61532: LD_ADDR_VAR 0 11
61536: PUSH
61537: LD_VAR 0 4
61541: PPUSH
61542: LD_INT 2
61544: PPUSH
61545: CALL 54738 0 2
61549: PUSH
61550: LD_INT 1
61552: ARRAY
61553: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61554: LD_ADDR_VAR 0 2
61558: PUSH
61559: LD_VAR 0 2
61563: PPUSH
61564: LD_INT 2
61566: PPUSH
61567: LD_VAR 0 11
61571: PPUSH
61572: CALL_OW 1
61576: ST_TO_ADDR
// tmp := tmp diff p ;
61577: LD_ADDR_VAR 0 4
61581: PUSH
61582: LD_VAR 0 4
61586: PUSH
61587: LD_VAR 0 11
61591: DIFF
61592: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61593: LD_VAR 0 4
61597: PUSH
61598: LD_VAR 0 8
61602: PUSH
61603: LD_INT 6
61605: LESS
61606: AND
61607: IFFALSE 61795
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61609: LD_ADDR_VAR 0 9
61613: PUSH
61614: LD_VAR 0 4
61618: PUSH
61619: LD_VAR 0 8
61623: PUSH
61624: LD_VAR 0 7
61628: UNION
61629: DIFF
61630: PPUSH
61631: LD_INT 4
61633: PPUSH
61634: CALL 54738 0 2
61638: ST_TO_ADDR
// p := [ ] ;
61639: LD_ADDR_VAR 0 11
61643: PUSH
61644: EMPTY
61645: ST_TO_ADDR
// if sort then
61646: LD_VAR 0 9
61650: IFFALSE 61766
// for i = 1 to 6 - sci do
61652: LD_ADDR_VAR 0 3
61656: PUSH
61657: DOUBLE
61658: LD_INT 1
61660: DEC
61661: ST_TO_ADDR
61662: LD_INT 6
61664: PUSH
61665: LD_VAR 0 8
61669: MINUS
61670: PUSH
61671: FOR_TO
61672: IFFALSE 61764
// begin if i = sort then
61674: LD_VAR 0 3
61678: PUSH
61679: LD_VAR 0 9
61683: EQUAL
61684: IFFALSE 61688
// break ;
61686: GO 61764
// if GetClass ( i ) = 4 then
61688: LD_VAR 0 3
61692: PPUSH
61693: CALL_OW 257
61697: PUSH
61698: LD_INT 4
61700: EQUAL
61701: IFFALSE 61705
// continue ;
61703: GO 61671
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61705: LD_ADDR_VAR 0 11
61709: PUSH
61710: LD_VAR 0 11
61714: PPUSH
61715: LD_VAR 0 11
61719: PUSH
61720: LD_INT 1
61722: PLUS
61723: PPUSH
61724: LD_VAR 0 9
61728: PUSH
61729: LD_VAR 0 3
61733: ARRAY
61734: PPUSH
61735: CALL_OW 2
61739: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61740: LD_ADDR_VAR 0 4
61744: PUSH
61745: LD_VAR 0 4
61749: PUSH
61750: LD_VAR 0 9
61754: PUSH
61755: LD_VAR 0 3
61759: ARRAY
61760: DIFF
61761: ST_TO_ADDR
// end ;
61762: GO 61671
61764: POP
61765: POP
// if p then
61766: LD_VAR 0 11
61770: IFFALSE 61795
// result := Replace ( result , 4 , p ) ;
61772: LD_ADDR_VAR 0 2
61776: PUSH
61777: LD_VAR 0 2
61781: PPUSH
61782: LD_INT 4
61784: PPUSH
61785: LD_VAR 0 11
61789: PPUSH
61790: CALL_OW 1
61794: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61795: LD_VAR 0 4
61799: PUSH
61800: LD_VAR 0 7
61804: PUSH
61805: LD_INT 6
61807: LESS
61808: AND
61809: IFFALSE 61997
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61811: LD_ADDR_VAR 0 9
61815: PUSH
61816: LD_VAR 0 4
61820: PUSH
61821: LD_VAR 0 8
61825: PUSH
61826: LD_VAR 0 7
61830: UNION
61831: DIFF
61832: PPUSH
61833: LD_INT 3
61835: PPUSH
61836: CALL 54738 0 2
61840: ST_TO_ADDR
// p := [ ] ;
61841: LD_ADDR_VAR 0 11
61845: PUSH
61846: EMPTY
61847: ST_TO_ADDR
// if sort then
61848: LD_VAR 0 9
61852: IFFALSE 61968
// for i = 1 to 6 - mech do
61854: LD_ADDR_VAR 0 3
61858: PUSH
61859: DOUBLE
61860: LD_INT 1
61862: DEC
61863: ST_TO_ADDR
61864: LD_INT 6
61866: PUSH
61867: LD_VAR 0 7
61871: MINUS
61872: PUSH
61873: FOR_TO
61874: IFFALSE 61966
// begin if i = sort then
61876: LD_VAR 0 3
61880: PUSH
61881: LD_VAR 0 9
61885: EQUAL
61886: IFFALSE 61890
// break ;
61888: GO 61966
// if GetClass ( i ) = 3 then
61890: LD_VAR 0 3
61894: PPUSH
61895: CALL_OW 257
61899: PUSH
61900: LD_INT 3
61902: EQUAL
61903: IFFALSE 61907
// continue ;
61905: GO 61873
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61907: LD_ADDR_VAR 0 11
61911: PUSH
61912: LD_VAR 0 11
61916: PPUSH
61917: LD_VAR 0 11
61921: PUSH
61922: LD_INT 1
61924: PLUS
61925: PPUSH
61926: LD_VAR 0 9
61930: PUSH
61931: LD_VAR 0 3
61935: ARRAY
61936: PPUSH
61937: CALL_OW 2
61941: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61942: LD_ADDR_VAR 0 4
61946: PUSH
61947: LD_VAR 0 4
61951: PUSH
61952: LD_VAR 0 9
61956: PUSH
61957: LD_VAR 0 3
61961: ARRAY
61962: DIFF
61963: ST_TO_ADDR
// end ;
61964: GO 61873
61966: POP
61967: POP
// if p then
61968: LD_VAR 0 11
61972: IFFALSE 61997
// result := Replace ( result , 3 , p ) ;
61974: LD_ADDR_VAR 0 2
61978: PUSH
61979: LD_VAR 0 2
61983: PPUSH
61984: LD_INT 3
61986: PPUSH
61987: LD_VAR 0 11
61991: PPUSH
61992: CALL_OW 1
61996: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61997: LD_VAR 0 4
62001: PUSH
62002: LD_INT 6
62004: GREATER
62005: PUSH
62006: LD_VAR 0 6
62010: PUSH
62011: LD_INT 6
62013: LESS
62014: AND
62015: IFFALSE 62209
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62017: LD_ADDR_VAR 0 9
62021: PUSH
62022: LD_VAR 0 4
62026: PUSH
62027: LD_VAR 0 8
62031: PUSH
62032: LD_VAR 0 7
62036: UNION
62037: PUSH
62038: LD_VAR 0 6
62042: UNION
62043: DIFF
62044: PPUSH
62045: LD_INT 2
62047: PPUSH
62048: CALL 54738 0 2
62052: ST_TO_ADDR
// p := [ ] ;
62053: LD_ADDR_VAR 0 11
62057: PUSH
62058: EMPTY
62059: ST_TO_ADDR
// if sort then
62060: LD_VAR 0 9
62064: IFFALSE 62180
// for i = 1 to 6 - eng do
62066: LD_ADDR_VAR 0 3
62070: PUSH
62071: DOUBLE
62072: LD_INT 1
62074: DEC
62075: ST_TO_ADDR
62076: LD_INT 6
62078: PUSH
62079: LD_VAR 0 6
62083: MINUS
62084: PUSH
62085: FOR_TO
62086: IFFALSE 62178
// begin if i = sort then
62088: LD_VAR 0 3
62092: PUSH
62093: LD_VAR 0 9
62097: EQUAL
62098: IFFALSE 62102
// break ;
62100: GO 62178
// if GetClass ( i ) = 2 then
62102: LD_VAR 0 3
62106: PPUSH
62107: CALL_OW 257
62111: PUSH
62112: LD_INT 2
62114: EQUAL
62115: IFFALSE 62119
// continue ;
62117: GO 62085
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62119: LD_ADDR_VAR 0 11
62123: PUSH
62124: LD_VAR 0 11
62128: PPUSH
62129: LD_VAR 0 11
62133: PUSH
62134: LD_INT 1
62136: PLUS
62137: PPUSH
62138: LD_VAR 0 9
62142: PUSH
62143: LD_VAR 0 3
62147: ARRAY
62148: PPUSH
62149: CALL_OW 2
62153: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62154: LD_ADDR_VAR 0 4
62158: PUSH
62159: LD_VAR 0 4
62163: PUSH
62164: LD_VAR 0 9
62168: PUSH
62169: LD_VAR 0 3
62173: ARRAY
62174: DIFF
62175: ST_TO_ADDR
// end ;
62176: GO 62085
62178: POP
62179: POP
// if p then
62180: LD_VAR 0 11
62184: IFFALSE 62209
// result := Replace ( result , 2 , p ) ;
62186: LD_ADDR_VAR 0 2
62190: PUSH
62191: LD_VAR 0 2
62195: PPUSH
62196: LD_INT 2
62198: PPUSH
62199: LD_VAR 0 11
62203: PPUSH
62204: CALL_OW 1
62208: ST_TO_ADDR
// end ; exit ;
62209: GO 63597
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62211: LD_EXP 85
62215: PUSH
62216: LD_EXP 84
62220: PUSH
62221: LD_VAR 0 1
62225: ARRAY
62226: ARRAY
62227: NOT
62228: PUSH
62229: LD_EXP 58
62233: PUSH
62234: LD_VAR 0 1
62238: ARRAY
62239: PPUSH
62240: LD_INT 30
62242: PUSH
62243: LD_INT 3
62245: PUSH
62246: EMPTY
62247: LIST
62248: LIST
62249: PPUSH
62250: CALL_OW 72
62254: AND
62255: PUSH
62256: LD_EXP 63
62260: PUSH
62261: LD_VAR 0 1
62265: ARRAY
62266: AND
62267: IFFALSE 62875
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62269: LD_ADDR_EXP 100
62273: PUSH
62274: LD_EXP 100
62278: PPUSH
62279: LD_VAR 0 1
62283: PPUSH
62284: LD_INT 5
62286: PPUSH
62287: CALL_OW 1
62291: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62292: LD_ADDR_VAR 0 2
62296: PUSH
62297: LD_INT 0
62299: PUSH
62300: LD_INT 0
62302: PUSH
62303: LD_INT 0
62305: PUSH
62306: LD_INT 0
62308: PUSH
62309: EMPTY
62310: LIST
62311: LIST
62312: LIST
62313: LIST
62314: ST_TO_ADDR
// if sci > 1 then
62315: LD_VAR 0 8
62319: PUSH
62320: LD_INT 1
62322: GREATER
62323: IFFALSE 62351
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62325: LD_ADDR_VAR 0 4
62329: PUSH
62330: LD_VAR 0 4
62334: PUSH
62335: LD_VAR 0 8
62339: PUSH
62340: LD_VAR 0 8
62344: PUSH
62345: LD_INT 1
62347: ARRAY
62348: DIFF
62349: DIFF
62350: ST_TO_ADDR
// if tmp and not sci then
62351: LD_VAR 0 4
62355: PUSH
62356: LD_VAR 0 8
62360: NOT
62361: AND
62362: IFFALSE 62431
// begin sort := SortBySkill ( tmp , 4 ) ;
62364: LD_ADDR_VAR 0 9
62368: PUSH
62369: LD_VAR 0 4
62373: PPUSH
62374: LD_INT 4
62376: PPUSH
62377: CALL 54738 0 2
62381: ST_TO_ADDR
// if sort then
62382: LD_VAR 0 9
62386: IFFALSE 62402
// p := sort [ 1 ] ;
62388: LD_ADDR_VAR 0 11
62392: PUSH
62393: LD_VAR 0 9
62397: PUSH
62398: LD_INT 1
62400: ARRAY
62401: ST_TO_ADDR
// if p then
62402: LD_VAR 0 11
62406: IFFALSE 62431
// result := Replace ( result , 4 , p ) ;
62408: LD_ADDR_VAR 0 2
62412: PUSH
62413: LD_VAR 0 2
62417: PPUSH
62418: LD_INT 4
62420: PPUSH
62421: LD_VAR 0 11
62425: PPUSH
62426: CALL_OW 1
62430: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62431: LD_ADDR_VAR 0 4
62435: PUSH
62436: LD_VAR 0 4
62440: PUSH
62441: LD_VAR 0 7
62445: DIFF
62446: ST_TO_ADDR
// if tmp and mech < 6 then
62447: LD_VAR 0 4
62451: PUSH
62452: LD_VAR 0 7
62456: PUSH
62457: LD_INT 6
62459: LESS
62460: AND
62461: IFFALSE 62649
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62463: LD_ADDR_VAR 0 9
62467: PUSH
62468: LD_VAR 0 4
62472: PUSH
62473: LD_VAR 0 8
62477: PUSH
62478: LD_VAR 0 7
62482: UNION
62483: DIFF
62484: PPUSH
62485: LD_INT 3
62487: PPUSH
62488: CALL 54738 0 2
62492: ST_TO_ADDR
// p := [ ] ;
62493: LD_ADDR_VAR 0 11
62497: PUSH
62498: EMPTY
62499: ST_TO_ADDR
// if sort then
62500: LD_VAR 0 9
62504: IFFALSE 62620
// for i = 1 to 6 - mech do
62506: LD_ADDR_VAR 0 3
62510: PUSH
62511: DOUBLE
62512: LD_INT 1
62514: DEC
62515: ST_TO_ADDR
62516: LD_INT 6
62518: PUSH
62519: LD_VAR 0 7
62523: MINUS
62524: PUSH
62525: FOR_TO
62526: IFFALSE 62618
// begin if i = sort then
62528: LD_VAR 0 3
62532: PUSH
62533: LD_VAR 0 9
62537: EQUAL
62538: IFFALSE 62542
// break ;
62540: GO 62618
// if GetClass ( i ) = 3 then
62542: LD_VAR 0 3
62546: PPUSH
62547: CALL_OW 257
62551: PUSH
62552: LD_INT 3
62554: EQUAL
62555: IFFALSE 62559
// continue ;
62557: GO 62525
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62559: LD_ADDR_VAR 0 11
62563: PUSH
62564: LD_VAR 0 11
62568: PPUSH
62569: LD_VAR 0 11
62573: PUSH
62574: LD_INT 1
62576: PLUS
62577: PPUSH
62578: LD_VAR 0 9
62582: PUSH
62583: LD_VAR 0 3
62587: ARRAY
62588: PPUSH
62589: CALL_OW 2
62593: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62594: LD_ADDR_VAR 0 4
62598: PUSH
62599: LD_VAR 0 4
62603: PUSH
62604: LD_VAR 0 9
62608: PUSH
62609: LD_VAR 0 3
62613: ARRAY
62614: DIFF
62615: ST_TO_ADDR
// end ;
62616: GO 62525
62618: POP
62619: POP
// if p then
62620: LD_VAR 0 11
62624: IFFALSE 62649
// result := Replace ( result , 3 , p ) ;
62626: LD_ADDR_VAR 0 2
62630: PUSH
62631: LD_VAR 0 2
62635: PPUSH
62636: LD_INT 3
62638: PPUSH
62639: LD_VAR 0 11
62643: PPUSH
62644: CALL_OW 1
62648: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62649: LD_ADDR_VAR 0 4
62653: PUSH
62654: LD_VAR 0 4
62658: PUSH
62659: LD_VAR 0 6
62663: DIFF
62664: ST_TO_ADDR
// if tmp and eng < 6 then
62665: LD_VAR 0 4
62669: PUSH
62670: LD_VAR 0 6
62674: PUSH
62675: LD_INT 6
62677: LESS
62678: AND
62679: IFFALSE 62873
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62681: LD_ADDR_VAR 0 9
62685: PUSH
62686: LD_VAR 0 4
62690: PUSH
62691: LD_VAR 0 8
62695: PUSH
62696: LD_VAR 0 7
62700: UNION
62701: PUSH
62702: LD_VAR 0 6
62706: UNION
62707: DIFF
62708: PPUSH
62709: LD_INT 2
62711: PPUSH
62712: CALL 54738 0 2
62716: ST_TO_ADDR
// p := [ ] ;
62717: LD_ADDR_VAR 0 11
62721: PUSH
62722: EMPTY
62723: ST_TO_ADDR
// if sort then
62724: LD_VAR 0 9
62728: IFFALSE 62844
// for i = 1 to 6 - eng do
62730: LD_ADDR_VAR 0 3
62734: PUSH
62735: DOUBLE
62736: LD_INT 1
62738: DEC
62739: ST_TO_ADDR
62740: LD_INT 6
62742: PUSH
62743: LD_VAR 0 6
62747: MINUS
62748: PUSH
62749: FOR_TO
62750: IFFALSE 62842
// begin if i = sort then
62752: LD_VAR 0 3
62756: PUSH
62757: LD_VAR 0 9
62761: EQUAL
62762: IFFALSE 62766
// break ;
62764: GO 62842
// if GetClass ( i ) = 2 then
62766: LD_VAR 0 3
62770: PPUSH
62771: CALL_OW 257
62775: PUSH
62776: LD_INT 2
62778: EQUAL
62779: IFFALSE 62783
// continue ;
62781: GO 62749
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62783: LD_ADDR_VAR 0 11
62787: PUSH
62788: LD_VAR 0 11
62792: PPUSH
62793: LD_VAR 0 11
62797: PUSH
62798: LD_INT 1
62800: PLUS
62801: PPUSH
62802: LD_VAR 0 9
62806: PUSH
62807: LD_VAR 0 3
62811: ARRAY
62812: PPUSH
62813: CALL_OW 2
62817: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62818: LD_ADDR_VAR 0 4
62822: PUSH
62823: LD_VAR 0 4
62827: PUSH
62828: LD_VAR 0 9
62832: PUSH
62833: LD_VAR 0 3
62837: ARRAY
62838: DIFF
62839: ST_TO_ADDR
// end ;
62840: GO 62749
62842: POP
62843: POP
// if p then
62844: LD_VAR 0 11
62848: IFFALSE 62873
// result := Replace ( result , 2 , p ) ;
62850: LD_ADDR_VAR 0 2
62854: PUSH
62855: LD_VAR 0 2
62859: PPUSH
62860: LD_INT 2
62862: PPUSH
62863: LD_VAR 0 11
62867: PPUSH
62868: CALL_OW 1
62872: ST_TO_ADDR
// end ; exit ;
62873: GO 63597
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62875: LD_EXP 85
62879: PUSH
62880: LD_EXP 84
62884: PUSH
62885: LD_VAR 0 1
62889: ARRAY
62890: ARRAY
62891: NOT
62892: PUSH
62893: LD_EXP 58
62897: PUSH
62898: LD_VAR 0 1
62902: ARRAY
62903: PPUSH
62904: LD_INT 30
62906: PUSH
62907: LD_INT 3
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PPUSH
62914: CALL_OW 72
62918: AND
62919: PUSH
62920: LD_EXP 63
62924: PUSH
62925: LD_VAR 0 1
62929: ARRAY
62930: NOT
62931: AND
62932: IFFALSE 63597
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62934: LD_ADDR_EXP 100
62938: PUSH
62939: LD_EXP 100
62943: PPUSH
62944: LD_VAR 0 1
62948: PPUSH
62949: LD_INT 6
62951: PPUSH
62952: CALL_OW 1
62956: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62957: LD_ADDR_VAR 0 2
62961: PUSH
62962: LD_INT 0
62964: PUSH
62965: LD_INT 0
62967: PUSH
62968: LD_INT 0
62970: PUSH
62971: LD_INT 0
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: LIST
62978: LIST
62979: ST_TO_ADDR
// if sci >= 1 then
62980: LD_VAR 0 8
62984: PUSH
62985: LD_INT 1
62987: GREATEREQUAL
62988: IFFALSE 63010
// tmp := tmp diff sci [ 1 ] ;
62990: LD_ADDR_VAR 0 4
62994: PUSH
62995: LD_VAR 0 4
62999: PUSH
63000: LD_VAR 0 8
63004: PUSH
63005: LD_INT 1
63007: ARRAY
63008: DIFF
63009: ST_TO_ADDR
// if tmp and not sci then
63010: LD_VAR 0 4
63014: PUSH
63015: LD_VAR 0 8
63019: NOT
63020: AND
63021: IFFALSE 63090
// begin sort := SortBySkill ( tmp , 4 ) ;
63023: LD_ADDR_VAR 0 9
63027: PUSH
63028: LD_VAR 0 4
63032: PPUSH
63033: LD_INT 4
63035: PPUSH
63036: CALL 54738 0 2
63040: ST_TO_ADDR
// if sort then
63041: LD_VAR 0 9
63045: IFFALSE 63061
// p := sort [ 1 ] ;
63047: LD_ADDR_VAR 0 11
63051: PUSH
63052: LD_VAR 0 9
63056: PUSH
63057: LD_INT 1
63059: ARRAY
63060: ST_TO_ADDR
// if p then
63061: LD_VAR 0 11
63065: IFFALSE 63090
// result := Replace ( result , 4 , p ) ;
63067: LD_ADDR_VAR 0 2
63071: PUSH
63072: LD_VAR 0 2
63076: PPUSH
63077: LD_INT 4
63079: PPUSH
63080: LD_VAR 0 11
63084: PPUSH
63085: CALL_OW 1
63089: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63090: LD_ADDR_VAR 0 4
63094: PUSH
63095: LD_VAR 0 4
63099: PUSH
63100: LD_VAR 0 7
63104: DIFF
63105: ST_TO_ADDR
// if tmp and mech < 6 then
63106: LD_VAR 0 4
63110: PUSH
63111: LD_VAR 0 7
63115: PUSH
63116: LD_INT 6
63118: LESS
63119: AND
63120: IFFALSE 63302
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63122: LD_ADDR_VAR 0 9
63126: PUSH
63127: LD_VAR 0 4
63131: PUSH
63132: LD_VAR 0 7
63136: DIFF
63137: PPUSH
63138: LD_INT 3
63140: PPUSH
63141: CALL 54738 0 2
63145: ST_TO_ADDR
// p := [ ] ;
63146: LD_ADDR_VAR 0 11
63150: PUSH
63151: EMPTY
63152: ST_TO_ADDR
// if sort then
63153: LD_VAR 0 9
63157: IFFALSE 63273
// for i = 1 to 6 - mech do
63159: LD_ADDR_VAR 0 3
63163: PUSH
63164: DOUBLE
63165: LD_INT 1
63167: DEC
63168: ST_TO_ADDR
63169: LD_INT 6
63171: PUSH
63172: LD_VAR 0 7
63176: MINUS
63177: PUSH
63178: FOR_TO
63179: IFFALSE 63271
// begin if i = sort then
63181: LD_VAR 0 3
63185: PUSH
63186: LD_VAR 0 9
63190: EQUAL
63191: IFFALSE 63195
// break ;
63193: GO 63271
// if GetClass ( i ) = 3 then
63195: LD_VAR 0 3
63199: PPUSH
63200: CALL_OW 257
63204: PUSH
63205: LD_INT 3
63207: EQUAL
63208: IFFALSE 63212
// continue ;
63210: GO 63178
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63212: LD_ADDR_VAR 0 11
63216: PUSH
63217: LD_VAR 0 11
63221: PPUSH
63222: LD_VAR 0 11
63226: PUSH
63227: LD_INT 1
63229: PLUS
63230: PPUSH
63231: LD_VAR 0 9
63235: PUSH
63236: LD_VAR 0 3
63240: ARRAY
63241: PPUSH
63242: CALL_OW 2
63246: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63247: LD_ADDR_VAR 0 4
63251: PUSH
63252: LD_VAR 0 4
63256: PUSH
63257: LD_VAR 0 9
63261: PUSH
63262: LD_VAR 0 3
63266: ARRAY
63267: DIFF
63268: ST_TO_ADDR
// end ;
63269: GO 63178
63271: POP
63272: POP
// if p then
63273: LD_VAR 0 11
63277: IFFALSE 63302
// result := Replace ( result , 3 , p ) ;
63279: LD_ADDR_VAR 0 2
63283: PUSH
63284: LD_VAR 0 2
63288: PPUSH
63289: LD_INT 3
63291: PPUSH
63292: LD_VAR 0 11
63296: PPUSH
63297: CALL_OW 1
63301: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63302: LD_ADDR_VAR 0 4
63306: PUSH
63307: LD_VAR 0 4
63311: PUSH
63312: LD_VAR 0 6
63316: DIFF
63317: ST_TO_ADDR
// if tmp and eng < 4 then
63318: LD_VAR 0 4
63322: PUSH
63323: LD_VAR 0 6
63327: PUSH
63328: LD_INT 4
63330: LESS
63331: AND
63332: IFFALSE 63522
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63334: LD_ADDR_VAR 0 9
63338: PUSH
63339: LD_VAR 0 4
63343: PUSH
63344: LD_VAR 0 7
63348: PUSH
63349: LD_VAR 0 6
63353: UNION
63354: DIFF
63355: PPUSH
63356: LD_INT 2
63358: PPUSH
63359: CALL 54738 0 2
63363: ST_TO_ADDR
// p := [ ] ;
63364: LD_ADDR_VAR 0 11
63368: PUSH
63369: EMPTY
63370: ST_TO_ADDR
// if sort then
63371: LD_VAR 0 9
63375: IFFALSE 63491
// for i = 1 to 4 - eng do
63377: LD_ADDR_VAR 0 3
63381: PUSH
63382: DOUBLE
63383: LD_INT 1
63385: DEC
63386: ST_TO_ADDR
63387: LD_INT 4
63389: PUSH
63390: LD_VAR 0 6
63394: MINUS
63395: PUSH
63396: FOR_TO
63397: IFFALSE 63489
// begin if i = sort then
63399: LD_VAR 0 3
63403: PUSH
63404: LD_VAR 0 9
63408: EQUAL
63409: IFFALSE 63413
// break ;
63411: GO 63489
// if GetClass ( i ) = 2 then
63413: LD_VAR 0 3
63417: PPUSH
63418: CALL_OW 257
63422: PUSH
63423: LD_INT 2
63425: EQUAL
63426: IFFALSE 63430
// continue ;
63428: GO 63396
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63430: LD_ADDR_VAR 0 11
63434: PUSH
63435: LD_VAR 0 11
63439: PPUSH
63440: LD_VAR 0 11
63444: PUSH
63445: LD_INT 1
63447: PLUS
63448: PPUSH
63449: LD_VAR 0 9
63453: PUSH
63454: LD_VAR 0 3
63458: ARRAY
63459: PPUSH
63460: CALL_OW 2
63464: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63465: LD_ADDR_VAR 0 4
63469: PUSH
63470: LD_VAR 0 4
63474: PUSH
63475: LD_VAR 0 9
63479: PUSH
63480: LD_VAR 0 3
63484: ARRAY
63485: DIFF
63486: ST_TO_ADDR
// end ;
63487: GO 63396
63489: POP
63490: POP
// if p then
63491: LD_VAR 0 11
63495: IFFALSE 63520
// result := Replace ( result , 2 , p ) ;
63497: LD_ADDR_VAR 0 2
63501: PUSH
63502: LD_VAR 0 2
63506: PPUSH
63507: LD_INT 2
63509: PPUSH
63510: LD_VAR 0 11
63514: PPUSH
63515: CALL_OW 1
63519: ST_TO_ADDR
// end else
63520: GO 63566
// for i = eng downto 5 do
63522: LD_ADDR_VAR 0 3
63526: PUSH
63527: DOUBLE
63528: LD_VAR 0 6
63532: INC
63533: ST_TO_ADDR
63534: LD_INT 5
63536: PUSH
63537: FOR_DOWNTO
63538: IFFALSE 63564
// tmp := tmp union eng [ i ] ;
63540: LD_ADDR_VAR 0 4
63544: PUSH
63545: LD_VAR 0 4
63549: PUSH
63550: LD_VAR 0 6
63554: PUSH
63555: LD_VAR 0 3
63559: ARRAY
63560: UNION
63561: ST_TO_ADDR
63562: GO 63537
63564: POP
63565: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63566: LD_ADDR_VAR 0 2
63570: PUSH
63571: LD_VAR 0 2
63575: PPUSH
63576: LD_INT 1
63578: PPUSH
63579: LD_VAR 0 4
63583: PUSH
63584: LD_VAR 0 5
63588: DIFF
63589: PPUSH
63590: CALL_OW 1
63594: ST_TO_ADDR
// exit ;
63595: GO 63597
// end ; end ;
63597: LD_VAR 0 2
63601: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63602: LD_INT 0
63604: PPUSH
63605: PPUSH
63606: PPUSH
// if not mc_bases then
63607: LD_EXP 58
63611: NOT
63612: IFFALSE 63616
// exit ;
63614: GO 63722
// for i = 1 to mc_bases do
63616: LD_ADDR_VAR 0 2
63620: PUSH
63621: DOUBLE
63622: LD_INT 1
63624: DEC
63625: ST_TO_ADDR
63626: LD_EXP 58
63630: PUSH
63631: FOR_TO
63632: IFFALSE 63713
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63634: LD_ADDR_VAR 0 3
63638: PUSH
63639: LD_EXP 58
63643: PUSH
63644: LD_VAR 0 2
63648: ARRAY
63649: PPUSH
63650: LD_INT 21
63652: PUSH
63653: LD_INT 3
63655: PUSH
63656: EMPTY
63657: LIST
63658: LIST
63659: PUSH
63660: LD_INT 3
63662: PUSH
63663: LD_INT 24
63665: PUSH
63666: LD_INT 1000
63668: PUSH
63669: EMPTY
63670: LIST
63671: LIST
63672: PUSH
63673: EMPTY
63674: LIST
63675: LIST
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: PPUSH
63681: CALL_OW 72
63685: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63686: LD_ADDR_EXP 59
63690: PUSH
63691: LD_EXP 59
63695: PPUSH
63696: LD_VAR 0 2
63700: PPUSH
63701: LD_VAR 0 3
63705: PPUSH
63706: CALL_OW 1
63710: ST_TO_ADDR
// end ;
63711: GO 63631
63713: POP
63714: POP
// RaiseSailEvent ( 101 ) ;
63715: LD_INT 101
63717: PPUSH
63718: CALL_OW 427
// end ;
63722: LD_VAR 0 1
63726: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63727: LD_INT 0
63729: PPUSH
63730: PPUSH
63731: PPUSH
63732: PPUSH
63733: PPUSH
63734: PPUSH
63735: PPUSH
// if not mc_bases then
63736: LD_EXP 58
63740: NOT
63741: IFFALSE 63745
// exit ;
63743: GO 64318
// for i = 1 to mc_bases do
63745: LD_ADDR_VAR 0 2
63749: PUSH
63750: DOUBLE
63751: LD_INT 1
63753: DEC
63754: ST_TO_ADDR
63755: LD_EXP 58
63759: PUSH
63760: FOR_TO
63761: IFFALSE 64309
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
63763: LD_ADDR_VAR 0 5
63767: PUSH
63768: LD_EXP 58
63772: PUSH
63773: LD_VAR 0 2
63777: ARRAY
63778: PUSH
63779: LD_EXP 87
63783: PUSH
63784: LD_VAR 0 2
63788: ARRAY
63789: UNION
63790: PPUSH
63791: LD_INT 21
63793: PUSH
63794: LD_INT 1
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PUSH
63801: LD_INT 1
63803: PUSH
63804: LD_INT 3
63806: PUSH
63807: LD_INT 54
63809: PUSH
63810: EMPTY
63811: LIST
63812: PUSH
63813: EMPTY
63814: LIST
63815: LIST
63816: PUSH
63817: LD_INT 3
63819: PUSH
63820: LD_INT 24
63822: PUSH
63823: LD_INT 750
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: PUSH
63830: EMPTY
63831: LIST
63832: LIST
63833: PUSH
63834: EMPTY
63835: LIST
63836: LIST
63837: LIST
63838: PUSH
63839: EMPTY
63840: LIST
63841: LIST
63842: PPUSH
63843: CALL_OW 72
63847: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63848: LD_ADDR_VAR 0 6
63852: PUSH
63853: LD_EXP 58
63857: PUSH
63858: LD_VAR 0 2
63862: ARRAY
63863: PPUSH
63864: LD_INT 21
63866: PUSH
63867: LD_INT 1
63869: PUSH
63870: EMPTY
63871: LIST
63872: LIST
63873: PUSH
63874: LD_INT 1
63876: PUSH
63877: LD_INT 3
63879: PUSH
63880: LD_INT 54
63882: PUSH
63883: EMPTY
63884: LIST
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 3
63892: PUSH
63893: LD_INT 24
63895: PUSH
63896: LD_INT 250
63898: PUSH
63899: EMPTY
63900: LIST
63901: LIST
63902: PUSH
63903: EMPTY
63904: LIST
63905: LIST
63906: PUSH
63907: EMPTY
63908: LIST
63909: LIST
63910: LIST
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PPUSH
63916: CALL_OW 72
63920: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63921: LD_ADDR_VAR 0 7
63925: PUSH
63926: LD_VAR 0 5
63930: PUSH
63931: LD_VAR 0 6
63935: DIFF
63936: ST_TO_ADDR
// if not need_heal_1 then
63937: LD_VAR 0 6
63941: NOT
63942: IFFALSE 63975
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63944: LD_ADDR_EXP 61
63948: PUSH
63949: LD_EXP 61
63953: PPUSH
63954: LD_VAR 0 2
63958: PUSH
63959: LD_INT 1
63961: PUSH
63962: EMPTY
63963: LIST
63964: LIST
63965: PPUSH
63966: EMPTY
63967: PPUSH
63968: CALL 20553 0 3
63972: ST_TO_ADDR
63973: GO 64045
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63975: LD_ADDR_EXP 61
63979: PUSH
63980: LD_EXP 61
63984: PPUSH
63985: LD_VAR 0 2
63989: PUSH
63990: LD_INT 1
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PPUSH
63997: LD_EXP 61
64001: PUSH
64002: LD_VAR 0 2
64006: ARRAY
64007: PUSH
64008: LD_INT 1
64010: ARRAY
64011: PPUSH
64012: LD_INT 3
64014: PUSH
64015: LD_INT 24
64017: PUSH
64018: LD_INT 1000
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PPUSH
64029: CALL_OW 72
64033: PUSH
64034: LD_VAR 0 6
64038: UNION
64039: PPUSH
64040: CALL 20553 0 3
64044: ST_TO_ADDR
// if not need_heal_2 then
64045: LD_VAR 0 7
64049: NOT
64050: IFFALSE 64083
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
64052: LD_ADDR_EXP 61
64056: PUSH
64057: LD_EXP 61
64061: PPUSH
64062: LD_VAR 0 2
64066: PUSH
64067: LD_INT 2
64069: PUSH
64070: EMPTY
64071: LIST
64072: LIST
64073: PPUSH
64074: EMPTY
64075: PPUSH
64076: CALL 20553 0 3
64080: ST_TO_ADDR
64081: GO 64115
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64083: LD_ADDR_EXP 61
64087: PUSH
64088: LD_EXP 61
64092: PPUSH
64093: LD_VAR 0 2
64097: PUSH
64098: LD_INT 2
64100: PUSH
64101: EMPTY
64102: LIST
64103: LIST
64104: PPUSH
64105: LD_VAR 0 7
64109: PPUSH
64110: CALL 20553 0 3
64114: ST_TO_ADDR
// if need_heal_2 then
64115: LD_VAR 0 7
64119: IFFALSE 64291
// for j in need_heal_2 do
64121: LD_ADDR_VAR 0 3
64125: PUSH
64126: LD_VAR 0 7
64130: PUSH
64131: FOR_IN
64132: IFFALSE 64289
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
64134: LD_ADDR_VAR 0 5
64138: PUSH
64139: LD_EXP 58
64143: PUSH
64144: LD_VAR 0 2
64148: ARRAY
64149: PPUSH
64150: LD_INT 2
64152: PUSH
64153: LD_INT 30
64155: PUSH
64156: LD_INT 6
64158: PUSH
64159: EMPTY
64160: LIST
64161: LIST
64162: PUSH
64163: LD_INT 30
64165: PUSH
64166: LD_INT 7
64168: PUSH
64169: EMPTY
64170: LIST
64171: LIST
64172: PUSH
64173: LD_INT 30
64175: PUSH
64176: LD_INT 8
64178: PUSH
64179: EMPTY
64180: LIST
64181: LIST
64182: PUSH
64183: LD_INT 30
64185: PUSH
64186: LD_INT 0
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 30
64195: PUSH
64196: LD_INT 1
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: LD_INT 25
64205: PUSH
64206: LD_INT 4
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: PPUSH
64222: CALL_OW 72
64226: ST_TO_ADDR
// if tmp then
64227: LD_VAR 0 5
64231: IFFALSE 64287
// begin k := NearestUnitToUnit ( tmp , j ) ;
64233: LD_ADDR_VAR 0 4
64237: PUSH
64238: LD_VAR 0 5
64242: PPUSH
64243: LD_VAR 0 3
64247: PPUSH
64248: CALL_OW 74
64252: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
64253: LD_VAR 0 3
64257: PPUSH
64258: LD_VAR 0 4
64262: PPUSH
64263: CALL_OW 296
64267: PUSH
64268: LD_INT 7
64270: GREATER
64271: IFFALSE 64287
// ComMoveUnit ( j , k ) ;
64273: LD_VAR 0 3
64277: PPUSH
64278: LD_VAR 0 4
64282: PPUSH
64283: CALL_OW 112
// end ; end ;
64287: GO 64131
64289: POP
64290: POP
// if not need_heal_1 and not need_heal_2 then
64291: LD_VAR 0 6
64295: NOT
64296: PUSH
64297: LD_VAR 0 7
64301: NOT
64302: AND
64303: IFFALSE 64307
// continue ;
64305: GO 63760
// end ;
64307: GO 63760
64309: POP
64310: POP
// RaiseSailEvent ( 102 ) ;
64311: LD_INT 102
64313: PPUSH
64314: CALL_OW 427
// end ;
64318: LD_VAR 0 1
64322: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
64323: LD_INT 0
64325: PPUSH
64326: PPUSH
64327: PPUSH
64328: PPUSH
64329: PPUSH
// if not mc_bases then
64330: LD_EXP 58
64334: NOT
64335: IFFALSE 64339
// exit ;
64337: GO 64724
// for i = 1 to mc_bases do
64339: LD_ADDR_VAR 0 2
64343: PUSH
64344: DOUBLE
64345: LD_INT 1
64347: DEC
64348: ST_TO_ADDR
64349: LD_EXP 58
64353: PUSH
64354: FOR_TO
64355: IFFALSE 64722
// begin if not mc_building_need_repair [ i ] then
64357: LD_EXP 59
64361: PUSH
64362: LD_VAR 0 2
64366: ARRAY
64367: NOT
64368: IFFALSE 64406
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64370: LD_ADDR_EXP 60
64374: PUSH
64375: LD_EXP 60
64379: PPUSH
64380: LD_VAR 0 2
64384: PPUSH
64385: EMPTY
64386: PPUSH
64387: CALL_OW 1
64391: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64392: LD_VAR 0 2
64396: PPUSH
64397: LD_INT 101
64399: PPUSH
64400: CALL 59444 0 2
// continue ;
64404: GO 64354
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64406: LD_ADDR_EXP 64
64410: PUSH
64411: LD_EXP 64
64415: PPUSH
64416: LD_VAR 0 2
64420: PPUSH
64421: EMPTY
64422: PPUSH
64423: CALL_OW 1
64427: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64428: LD_VAR 0 2
64432: PPUSH
64433: LD_INT 103
64435: PPUSH
64436: CALL 59444 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64440: LD_ADDR_VAR 0 5
64444: PUSH
64445: LD_EXP 58
64449: PUSH
64450: LD_VAR 0 2
64454: ARRAY
64455: PUSH
64456: LD_EXP 87
64460: PUSH
64461: LD_VAR 0 2
64465: ARRAY
64466: UNION
64467: PPUSH
64468: LD_INT 2
64470: PUSH
64471: LD_INT 25
64473: PUSH
64474: LD_INT 2
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 25
64483: PUSH
64484: LD_INT 16
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: EMPTY
64492: LIST
64493: LIST
64494: LIST
64495: PUSH
64496: EMPTY
64497: LIST
64498: PPUSH
64499: CALL_OW 72
64503: ST_TO_ADDR
// if not tmp then
64504: LD_VAR 0 5
64508: NOT
64509: IFFALSE 64513
// continue ;
64511: GO 64354
// for j in tmp do
64513: LD_ADDR_VAR 0 3
64517: PUSH
64518: LD_VAR 0 5
64522: PUSH
64523: FOR_IN
64524: IFFALSE 64718
// begin if mc_need_heal [ i ] then
64526: LD_EXP 61
64530: PUSH
64531: LD_VAR 0 2
64535: ARRAY
64536: IFFALSE 64584
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
64538: LD_VAR 0 3
64542: PUSH
64543: LD_EXP 61
64547: PUSH
64548: LD_VAR 0 2
64552: ARRAY
64553: PUSH
64554: LD_INT 1
64556: ARRAY
64557: IN
64558: PUSH
64559: LD_VAR 0 3
64563: PUSH
64564: LD_EXP 61
64568: PUSH
64569: LD_VAR 0 2
64573: ARRAY
64574: PUSH
64575: LD_INT 2
64577: ARRAY
64578: IN
64579: OR
64580: IFFALSE 64584
// continue ;
64582: GO 64523
// if IsInUnit ( j ) then
64584: LD_VAR 0 3
64588: PPUSH
64589: CALL_OW 310
64593: IFFALSE 64604
// ComExitBuilding ( j ) ;
64595: LD_VAR 0 3
64599: PPUSH
64600: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64604: LD_VAR 0 3
64608: PUSH
64609: LD_EXP 60
64613: PUSH
64614: LD_VAR 0 2
64618: ARRAY
64619: IN
64620: NOT
64621: IFFALSE 64679
// begin SetTag ( j , 101 ) ;
64623: LD_VAR 0 3
64627: PPUSH
64628: LD_INT 101
64630: PPUSH
64631: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64635: LD_ADDR_EXP 60
64639: PUSH
64640: LD_EXP 60
64644: PPUSH
64645: LD_VAR 0 2
64649: PUSH
64650: LD_EXP 60
64654: PUSH
64655: LD_VAR 0 2
64659: ARRAY
64660: PUSH
64661: LD_INT 1
64663: PLUS
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PPUSH
64669: LD_VAR 0 3
64673: PPUSH
64674: CALL 20553 0 3
64678: ST_TO_ADDR
// end ; wait ( 1 ) ;
64679: LD_INT 1
64681: PPUSH
64682: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
64686: LD_VAR 0 3
64690: PPUSH
64691: LD_EXP 59
64695: PUSH
64696: LD_VAR 0 2
64700: ARRAY
64701: PPUSH
64702: LD_VAR 0 3
64706: PPUSH
64707: CALL_OW 74
64711: PPUSH
64712: CALL_OW 130
// end ;
64716: GO 64523
64718: POP
64719: POP
// end ;
64720: GO 64354
64722: POP
64723: POP
// end ;
64724: LD_VAR 0 1
64728: RET
// export function MC_Heal ; var i , j , tmp ; begin
64729: LD_INT 0
64731: PPUSH
64732: PPUSH
64733: PPUSH
64734: PPUSH
// if not mc_bases then
64735: LD_EXP 58
64739: NOT
64740: IFFALSE 64744
// exit ;
64742: GO 65146
// for i = 1 to mc_bases do
64744: LD_ADDR_VAR 0 2
64748: PUSH
64749: DOUBLE
64750: LD_INT 1
64752: DEC
64753: ST_TO_ADDR
64754: LD_EXP 58
64758: PUSH
64759: FOR_TO
64760: IFFALSE 65144
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64762: LD_EXP 61
64766: PUSH
64767: LD_VAR 0 2
64771: ARRAY
64772: PUSH
64773: LD_INT 1
64775: ARRAY
64776: NOT
64777: PUSH
64778: LD_EXP 61
64782: PUSH
64783: LD_VAR 0 2
64787: ARRAY
64788: PUSH
64789: LD_INT 2
64791: ARRAY
64792: NOT
64793: AND
64794: IFFALSE 64832
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64796: LD_ADDR_EXP 62
64800: PUSH
64801: LD_EXP 62
64805: PPUSH
64806: LD_VAR 0 2
64810: PPUSH
64811: EMPTY
64812: PPUSH
64813: CALL_OW 1
64817: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64818: LD_VAR 0 2
64822: PPUSH
64823: LD_INT 102
64825: PPUSH
64826: CALL 59444 0 2
// continue ;
64830: GO 64759
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64832: LD_ADDR_VAR 0 4
64836: PUSH
64837: LD_EXP 58
64841: PUSH
64842: LD_VAR 0 2
64846: ARRAY
64847: PPUSH
64848: LD_INT 25
64850: PUSH
64851: LD_INT 4
64853: PUSH
64854: EMPTY
64855: LIST
64856: LIST
64857: PPUSH
64858: CALL_OW 72
64862: ST_TO_ADDR
// if not tmp then
64863: LD_VAR 0 4
64867: NOT
64868: IFFALSE 64872
// continue ;
64870: GO 64759
// if mc_taming [ i ] then
64872: LD_EXP 89
64876: PUSH
64877: LD_VAR 0 2
64881: ARRAY
64882: IFFALSE 64906
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64884: LD_ADDR_EXP 89
64888: PUSH
64889: LD_EXP 89
64893: PPUSH
64894: LD_VAR 0 2
64898: PPUSH
64899: EMPTY
64900: PPUSH
64901: CALL_OW 1
64905: ST_TO_ADDR
// for j in tmp do
64906: LD_ADDR_VAR 0 3
64910: PUSH
64911: LD_VAR 0 4
64915: PUSH
64916: FOR_IN
64917: IFFALSE 65140
// begin if IsInUnit ( j ) then
64919: LD_VAR 0 3
64923: PPUSH
64924: CALL_OW 310
64928: IFFALSE 64939
// ComExitBuilding ( j ) ;
64930: LD_VAR 0 3
64934: PPUSH
64935: CALL_OW 122
// if not j in mc_healers [ i ] then
64939: LD_VAR 0 3
64943: PUSH
64944: LD_EXP 62
64948: PUSH
64949: LD_VAR 0 2
64953: ARRAY
64954: IN
64955: NOT
64956: IFFALSE 65002
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64958: LD_ADDR_EXP 62
64962: PUSH
64963: LD_EXP 62
64967: PPUSH
64968: LD_VAR 0 2
64972: PUSH
64973: LD_EXP 62
64977: PUSH
64978: LD_VAR 0 2
64982: ARRAY
64983: PUSH
64984: LD_INT 1
64986: PLUS
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PPUSH
64992: LD_VAR 0 3
64996: PPUSH
64997: CALL 20553 0 3
65001: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65002: LD_VAR 0 3
65006: PPUSH
65007: CALL_OW 110
65011: PUSH
65012: LD_INT 102
65014: NONEQUAL
65015: IFFALSE 65029
// SetTag ( j , 102 ) ;
65017: LD_VAR 0 3
65021: PPUSH
65022: LD_INT 102
65024: PPUSH
65025: CALL_OW 109
// Wait ( 3 ) ;
65029: LD_INT 3
65031: PPUSH
65032: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65036: LD_EXP 61
65040: PUSH
65041: LD_VAR 0 2
65045: ARRAY
65046: PUSH
65047: LD_INT 1
65049: ARRAY
65050: IFFALSE 65082
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65052: LD_VAR 0 3
65056: PPUSH
65057: LD_EXP 61
65061: PUSH
65062: LD_VAR 0 2
65066: ARRAY
65067: PUSH
65068: LD_INT 1
65070: ARRAY
65071: PUSH
65072: LD_INT 1
65074: ARRAY
65075: PPUSH
65076: CALL_OW 128
65080: GO 65138
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65082: LD_VAR 0 3
65086: PPUSH
65087: CALL_OW 314
65091: NOT
65092: PUSH
65093: LD_EXP 61
65097: PUSH
65098: LD_VAR 0 2
65102: ARRAY
65103: PUSH
65104: LD_INT 2
65106: ARRAY
65107: AND
65108: IFFALSE 65138
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65110: LD_VAR 0 3
65114: PPUSH
65115: LD_EXP 61
65119: PUSH
65120: LD_VAR 0 2
65124: ARRAY
65125: PUSH
65126: LD_INT 2
65128: ARRAY
65129: PUSH
65130: LD_INT 1
65132: ARRAY
65133: PPUSH
65134: CALL_OW 128
// end ;
65138: GO 64916
65140: POP
65141: POP
// end ;
65142: GO 64759
65144: POP
65145: POP
// end ;
65146: LD_VAR 0 1
65150: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65151: LD_INT 0
65153: PPUSH
65154: PPUSH
65155: PPUSH
65156: PPUSH
65157: PPUSH
// if not mc_bases then
65158: LD_EXP 58
65162: NOT
65163: IFFALSE 65167
// exit ;
65165: GO 66310
// for i = 1 to mc_bases do
65167: LD_ADDR_VAR 0 2
65171: PUSH
65172: DOUBLE
65173: LD_INT 1
65175: DEC
65176: ST_TO_ADDR
65177: LD_EXP 58
65181: PUSH
65182: FOR_TO
65183: IFFALSE 66308
// begin if mc_scan [ i ] then
65185: LD_EXP 81
65189: PUSH
65190: LD_VAR 0 2
65194: ARRAY
65195: IFFALSE 65199
// continue ;
65197: GO 65182
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65199: LD_EXP 63
65203: PUSH
65204: LD_VAR 0 2
65208: ARRAY
65209: NOT
65210: PUSH
65211: LD_EXP 65
65215: PUSH
65216: LD_VAR 0 2
65220: ARRAY
65221: NOT
65222: AND
65223: PUSH
65224: LD_EXP 64
65228: PUSH
65229: LD_VAR 0 2
65233: ARRAY
65234: AND
65235: IFFALSE 65273
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65237: LD_ADDR_EXP 64
65241: PUSH
65242: LD_EXP 64
65246: PPUSH
65247: LD_VAR 0 2
65251: PPUSH
65252: EMPTY
65253: PPUSH
65254: CALL_OW 1
65258: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65259: LD_VAR 0 2
65263: PPUSH
65264: LD_INT 103
65266: PPUSH
65267: CALL 59444 0 2
// continue ;
65271: GO 65182
// end ; if mc_construct_list [ i ] then
65273: LD_EXP 65
65277: PUSH
65278: LD_VAR 0 2
65282: ARRAY
65283: IFFALSE 65503
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65285: LD_ADDR_VAR 0 4
65289: PUSH
65290: LD_EXP 58
65294: PUSH
65295: LD_VAR 0 2
65299: ARRAY
65300: PPUSH
65301: LD_INT 25
65303: PUSH
65304: LD_INT 2
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PPUSH
65311: CALL_OW 72
65315: PUSH
65316: LD_EXP 60
65320: PUSH
65321: LD_VAR 0 2
65325: ARRAY
65326: DIFF
65327: ST_TO_ADDR
// if not tmp then
65328: LD_VAR 0 4
65332: NOT
65333: IFFALSE 65337
// continue ;
65335: GO 65182
// for j in tmp do
65337: LD_ADDR_VAR 0 3
65341: PUSH
65342: LD_VAR 0 4
65346: PUSH
65347: FOR_IN
65348: IFFALSE 65499
// begin if not mc_builders [ i ] then
65350: LD_EXP 64
65354: PUSH
65355: LD_VAR 0 2
65359: ARRAY
65360: NOT
65361: IFFALSE 65419
// begin SetTag ( j , 103 ) ;
65363: LD_VAR 0 3
65367: PPUSH
65368: LD_INT 103
65370: PPUSH
65371: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65375: LD_ADDR_EXP 64
65379: PUSH
65380: LD_EXP 64
65384: PPUSH
65385: LD_VAR 0 2
65389: PUSH
65390: LD_EXP 64
65394: PUSH
65395: LD_VAR 0 2
65399: ARRAY
65400: PUSH
65401: LD_INT 1
65403: PLUS
65404: PUSH
65405: EMPTY
65406: LIST
65407: LIST
65408: PPUSH
65409: LD_VAR 0 3
65413: PPUSH
65414: CALL 20553 0 3
65418: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65419: LD_VAR 0 3
65423: PPUSH
65424: CALL_OW 310
65428: IFFALSE 65439
// ComExitBuilding ( j ) ;
65430: LD_VAR 0 3
65434: PPUSH
65435: CALL_OW 122
// wait ( 3 ) ;
65439: LD_INT 3
65441: PPUSH
65442: CALL_OW 67
// if not mc_construct_list [ i ] then
65446: LD_EXP 65
65450: PUSH
65451: LD_VAR 0 2
65455: ARRAY
65456: NOT
65457: IFFALSE 65461
// break ;
65459: GO 65499
// if not HasTask ( j ) then
65461: LD_VAR 0 3
65465: PPUSH
65466: CALL_OW 314
65470: NOT
65471: IFFALSE 65497
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65473: LD_VAR 0 3
65477: PPUSH
65478: LD_EXP 65
65482: PUSH
65483: LD_VAR 0 2
65487: ARRAY
65488: PUSH
65489: LD_INT 1
65491: ARRAY
65492: PPUSH
65493: CALL 23404 0 2
// end ;
65497: GO 65347
65499: POP
65500: POP
// end else
65501: GO 66306
// if mc_build_list [ i ] then
65503: LD_EXP 63
65507: PUSH
65508: LD_VAR 0 2
65512: ARRAY
65513: IFFALSE 66306
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65515: LD_ADDR_VAR 0 5
65519: PUSH
65520: LD_EXP 58
65524: PUSH
65525: LD_VAR 0 2
65529: ARRAY
65530: PPUSH
65531: LD_INT 2
65533: PUSH
65534: LD_INT 30
65536: PUSH
65537: LD_INT 0
65539: PUSH
65540: EMPTY
65541: LIST
65542: LIST
65543: PUSH
65544: LD_INT 30
65546: PUSH
65547: LD_INT 1
65549: PUSH
65550: EMPTY
65551: LIST
65552: LIST
65553: PUSH
65554: EMPTY
65555: LIST
65556: LIST
65557: LIST
65558: PPUSH
65559: CALL_OW 72
65563: ST_TO_ADDR
// if depot then
65564: LD_VAR 0 5
65568: IFFALSE 65586
// depot := depot [ 1 ] else
65570: LD_ADDR_VAR 0 5
65574: PUSH
65575: LD_VAR 0 5
65579: PUSH
65580: LD_INT 1
65582: ARRAY
65583: ST_TO_ADDR
65584: GO 65594
// depot := 0 ;
65586: LD_ADDR_VAR 0 5
65590: PUSH
65591: LD_INT 0
65593: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65594: LD_EXP 63
65598: PUSH
65599: LD_VAR 0 2
65603: ARRAY
65604: PUSH
65605: LD_INT 1
65607: ARRAY
65608: PUSH
65609: LD_INT 1
65611: ARRAY
65612: PPUSH
65613: CALL 23234 0 1
65617: PUSH
65618: LD_EXP 58
65622: PUSH
65623: LD_VAR 0 2
65627: ARRAY
65628: PPUSH
65629: LD_INT 2
65631: PUSH
65632: LD_INT 30
65634: PUSH
65635: LD_INT 2
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: LD_INT 30
65644: PUSH
65645: LD_INT 3
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: LIST
65656: PPUSH
65657: CALL_OW 72
65661: NOT
65662: AND
65663: IFFALSE 65768
// begin for j = 1 to mc_build_list [ i ] do
65665: LD_ADDR_VAR 0 3
65669: PUSH
65670: DOUBLE
65671: LD_INT 1
65673: DEC
65674: ST_TO_ADDR
65675: LD_EXP 63
65679: PUSH
65680: LD_VAR 0 2
65684: ARRAY
65685: PUSH
65686: FOR_TO
65687: IFFALSE 65766
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65689: LD_EXP 63
65693: PUSH
65694: LD_VAR 0 2
65698: ARRAY
65699: PUSH
65700: LD_VAR 0 3
65704: ARRAY
65705: PUSH
65706: LD_INT 1
65708: ARRAY
65709: PUSH
65710: LD_INT 2
65712: EQUAL
65713: IFFALSE 65764
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65715: LD_ADDR_EXP 63
65719: PUSH
65720: LD_EXP 63
65724: PPUSH
65725: LD_VAR 0 2
65729: PPUSH
65730: LD_EXP 63
65734: PUSH
65735: LD_VAR 0 2
65739: ARRAY
65740: PPUSH
65741: LD_VAR 0 3
65745: PPUSH
65746: LD_INT 1
65748: PPUSH
65749: LD_INT 0
65751: PPUSH
65752: CALL 19971 0 4
65756: PPUSH
65757: CALL_OW 1
65761: ST_TO_ADDR
// break ;
65762: GO 65766
// end ;
65764: GO 65686
65766: POP
65767: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65768: LD_EXP 63
65772: PUSH
65773: LD_VAR 0 2
65777: ARRAY
65778: PUSH
65779: LD_INT 1
65781: ARRAY
65782: PUSH
65783: LD_INT 1
65785: ARRAY
65786: PUSH
65787: LD_INT 0
65789: EQUAL
65790: PUSH
65791: LD_VAR 0 5
65795: PUSH
65796: LD_VAR 0 5
65800: PPUSH
65801: LD_EXP 63
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_INT 1
65814: ARRAY
65815: PUSH
65816: LD_INT 1
65818: ARRAY
65819: PPUSH
65820: LD_EXP 63
65824: PUSH
65825: LD_VAR 0 2
65829: ARRAY
65830: PUSH
65831: LD_INT 1
65833: ARRAY
65834: PUSH
65835: LD_INT 2
65837: ARRAY
65838: PPUSH
65839: LD_EXP 63
65843: PUSH
65844: LD_VAR 0 2
65848: ARRAY
65849: PUSH
65850: LD_INT 1
65852: ARRAY
65853: PUSH
65854: LD_INT 3
65856: ARRAY
65857: PPUSH
65858: LD_EXP 63
65862: PUSH
65863: LD_VAR 0 2
65867: ARRAY
65868: PUSH
65869: LD_INT 1
65871: ARRAY
65872: PUSH
65873: LD_INT 4
65875: ARRAY
65876: PPUSH
65877: CALL 27950 0 5
65881: AND
65882: OR
65883: IFFALSE 66164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65885: LD_ADDR_VAR 0 4
65889: PUSH
65890: LD_EXP 58
65894: PUSH
65895: LD_VAR 0 2
65899: ARRAY
65900: PPUSH
65901: LD_INT 25
65903: PUSH
65904: LD_INT 2
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PPUSH
65911: CALL_OW 72
65915: PUSH
65916: LD_EXP 60
65920: PUSH
65921: LD_VAR 0 2
65925: ARRAY
65926: DIFF
65927: ST_TO_ADDR
// if not tmp then
65928: LD_VAR 0 4
65932: NOT
65933: IFFALSE 65937
// continue ;
65935: GO 65182
// for j in tmp do
65937: LD_ADDR_VAR 0 3
65941: PUSH
65942: LD_VAR 0 4
65946: PUSH
65947: FOR_IN
65948: IFFALSE 66160
// begin if not mc_builders [ i ] then
65950: LD_EXP 64
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: NOT
65961: IFFALSE 66019
// begin SetTag ( j , 103 ) ;
65963: LD_VAR 0 3
65967: PPUSH
65968: LD_INT 103
65970: PPUSH
65971: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65975: LD_ADDR_EXP 64
65979: PUSH
65980: LD_EXP 64
65984: PPUSH
65985: LD_VAR 0 2
65989: PUSH
65990: LD_EXP 64
65994: PUSH
65995: LD_VAR 0 2
65999: ARRAY
66000: PUSH
66001: LD_INT 1
66003: PLUS
66004: PUSH
66005: EMPTY
66006: LIST
66007: LIST
66008: PPUSH
66009: LD_VAR 0 3
66013: PPUSH
66014: CALL 20553 0 3
66018: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66019: LD_VAR 0 3
66023: PPUSH
66024: CALL_OW 310
66028: IFFALSE 66039
// ComExitBuilding ( j ) ;
66030: LD_VAR 0 3
66034: PPUSH
66035: CALL_OW 122
// wait ( 3 ) ;
66039: LD_INT 3
66041: PPUSH
66042: CALL_OW 67
// if not mc_build_list [ i ] then
66046: LD_EXP 63
66050: PUSH
66051: LD_VAR 0 2
66055: ARRAY
66056: NOT
66057: IFFALSE 66061
// break ;
66059: GO 66160
// if not HasTask ( j ) then
66061: LD_VAR 0 3
66065: PPUSH
66066: CALL_OW 314
66070: NOT
66071: IFFALSE 66158
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66073: LD_VAR 0 3
66077: PPUSH
66078: LD_EXP 63
66082: PUSH
66083: LD_VAR 0 2
66087: ARRAY
66088: PUSH
66089: LD_INT 1
66091: ARRAY
66092: PUSH
66093: LD_INT 1
66095: ARRAY
66096: PPUSH
66097: LD_EXP 63
66101: PUSH
66102: LD_VAR 0 2
66106: ARRAY
66107: PUSH
66108: LD_INT 1
66110: ARRAY
66111: PUSH
66112: LD_INT 2
66114: ARRAY
66115: PPUSH
66116: LD_EXP 63
66120: PUSH
66121: LD_VAR 0 2
66125: ARRAY
66126: PUSH
66127: LD_INT 1
66129: ARRAY
66130: PUSH
66131: LD_INT 3
66133: ARRAY
66134: PPUSH
66135: LD_EXP 63
66139: PUSH
66140: LD_VAR 0 2
66144: ARRAY
66145: PUSH
66146: LD_INT 1
66148: ARRAY
66149: PUSH
66150: LD_INT 4
66152: ARRAY
66153: PPUSH
66154: CALL_OW 145
// end ;
66158: GO 65947
66160: POP
66161: POP
// end else
66162: GO 66306
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
66164: LD_EXP 58
66168: PUSH
66169: LD_VAR 0 2
66173: ARRAY
66174: PPUSH
66175: LD_EXP 63
66179: PUSH
66180: LD_VAR 0 2
66184: ARRAY
66185: PUSH
66186: LD_INT 1
66188: ARRAY
66189: PUSH
66190: LD_INT 1
66192: ARRAY
66193: PPUSH
66194: LD_EXP 63
66198: PUSH
66199: LD_VAR 0 2
66203: ARRAY
66204: PUSH
66205: LD_INT 1
66207: ARRAY
66208: PUSH
66209: LD_INT 2
66211: ARRAY
66212: PPUSH
66213: LD_EXP 63
66217: PUSH
66218: LD_VAR 0 2
66222: ARRAY
66223: PUSH
66224: LD_INT 1
66226: ARRAY
66227: PUSH
66228: LD_INT 3
66230: ARRAY
66231: PPUSH
66232: LD_EXP 63
66236: PUSH
66237: LD_VAR 0 2
66241: ARRAY
66242: PUSH
66243: LD_INT 1
66245: ARRAY
66246: PUSH
66247: LD_INT 4
66249: ARRAY
66250: PPUSH
66251: CALL 27304 0 5
66255: NOT
66256: IFFALSE 66306
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66258: LD_ADDR_EXP 63
66262: PUSH
66263: LD_EXP 63
66267: PPUSH
66268: LD_VAR 0 2
66272: PPUSH
66273: LD_EXP 63
66277: PUSH
66278: LD_VAR 0 2
66282: ARRAY
66283: PPUSH
66284: LD_INT 1
66286: PPUSH
66287: LD_INT 1
66289: NEG
66290: PPUSH
66291: LD_INT 0
66293: PPUSH
66294: CALL 19971 0 4
66298: PPUSH
66299: CALL_OW 1
66303: ST_TO_ADDR
// continue ;
66304: GO 65182
// end ; end ; end ;
66306: GO 65182
66308: POP
66309: POP
// end ;
66310: LD_VAR 0 1
66314: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66315: LD_INT 0
66317: PPUSH
66318: PPUSH
66319: PPUSH
66320: PPUSH
66321: PPUSH
66322: PPUSH
// if not mc_bases then
66323: LD_EXP 58
66327: NOT
66328: IFFALSE 66332
// exit ;
66330: GO 66759
// for i = 1 to mc_bases do
66332: LD_ADDR_VAR 0 2
66336: PUSH
66337: DOUBLE
66338: LD_INT 1
66340: DEC
66341: ST_TO_ADDR
66342: LD_EXP 58
66346: PUSH
66347: FOR_TO
66348: IFFALSE 66757
// begin tmp := mc_build_upgrade [ i ] ;
66350: LD_ADDR_VAR 0 4
66354: PUSH
66355: LD_EXP 90
66359: PUSH
66360: LD_VAR 0 2
66364: ARRAY
66365: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66366: LD_ADDR_VAR 0 6
66370: PUSH
66371: LD_EXP 91
66375: PUSH
66376: LD_VAR 0 2
66380: ARRAY
66381: PPUSH
66382: LD_INT 2
66384: PUSH
66385: LD_INT 30
66387: PUSH
66388: LD_INT 6
66390: PUSH
66391: EMPTY
66392: LIST
66393: LIST
66394: PUSH
66395: LD_INT 30
66397: PUSH
66398: LD_INT 7
66400: PUSH
66401: EMPTY
66402: LIST
66403: LIST
66404: PUSH
66405: EMPTY
66406: LIST
66407: LIST
66408: LIST
66409: PPUSH
66410: CALL_OW 72
66414: ST_TO_ADDR
// if not tmp and not lab then
66415: LD_VAR 0 4
66419: NOT
66420: PUSH
66421: LD_VAR 0 6
66425: NOT
66426: AND
66427: IFFALSE 66431
// continue ;
66429: GO 66347
// if tmp then
66431: LD_VAR 0 4
66435: IFFALSE 66555
// for j in tmp do
66437: LD_ADDR_VAR 0 3
66441: PUSH
66442: LD_VAR 0 4
66446: PUSH
66447: FOR_IN
66448: IFFALSE 66553
// begin if UpgradeCost ( j ) then
66450: LD_VAR 0 3
66454: PPUSH
66455: CALL 26964 0 1
66459: IFFALSE 66551
// begin ComUpgrade ( j ) ;
66461: LD_VAR 0 3
66465: PPUSH
66466: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66470: LD_ADDR_EXP 90
66474: PUSH
66475: LD_EXP 90
66479: PPUSH
66480: LD_VAR 0 2
66484: PPUSH
66485: LD_EXP 90
66489: PUSH
66490: LD_VAR 0 2
66494: ARRAY
66495: PUSH
66496: LD_VAR 0 3
66500: DIFF
66501: PPUSH
66502: CALL_OW 1
66506: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66507: LD_ADDR_EXP 65
66511: PUSH
66512: LD_EXP 65
66516: PPUSH
66517: LD_VAR 0 2
66521: PUSH
66522: LD_EXP 65
66526: PUSH
66527: LD_VAR 0 2
66531: ARRAY
66532: PUSH
66533: LD_INT 1
66535: PLUS
66536: PUSH
66537: EMPTY
66538: LIST
66539: LIST
66540: PPUSH
66541: LD_VAR 0 3
66545: PPUSH
66546: CALL 20553 0 3
66550: ST_TO_ADDR
// end ; end ;
66551: GO 66447
66553: POP
66554: POP
// if not lab or not mc_lab_upgrade [ i ] then
66555: LD_VAR 0 6
66559: NOT
66560: PUSH
66561: LD_EXP 92
66565: PUSH
66566: LD_VAR 0 2
66570: ARRAY
66571: NOT
66572: OR
66573: IFFALSE 66577
// continue ;
66575: GO 66347
// for j in lab do
66577: LD_ADDR_VAR 0 3
66581: PUSH
66582: LD_VAR 0 6
66586: PUSH
66587: FOR_IN
66588: IFFALSE 66753
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66590: LD_VAR 0 3
66594: PPUSH
66595: CALL_OW 266
66599: PUSH
66600: LD_INT 6
66602: PUSH
66603: LD_INT 7
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: IN
66610: PUSH
66611: LD_VAR 0 3
66615: PPUSH
66616: CALL_OW 461
66620: PUSH
66621: LD_INT 1
66623: NONEQUAL
66624: AND
66625: IFFALSE 66751
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66627: LD_VAR 0 3
66631: PPUSH
66632: LD_EXP 92
66636: PUSH
66637: LD_VAR 0 2
66641: ARRAY
66642: PUSH
66643: LD_INT 1
66645: ARRAY
66646: PPUSH
66647: CALL 27169 0 2
66651: IFFALSE 66751
// begin ComCancel ( j ) ;
66653: LD_VAR 0 3
66657: PPUSH
66658: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66662: LD_VAR 0 3
66666: PPUSH
66667: LD_EXP 92
66671: PUSH
66672: LD_VAR 0 2
66676: ARRAY
66677: PUSH
66678: LD_INT 1
66680: ARRAY
66681: PPUSH
66682: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66686: LD_VAR 0 3
66690: PUSH
66691: LD_EXP 65
66695: PUSH
66696: LD_VAR 0 2
66700: ARRAY
66701: IN
66702: NOT
66703: IFFALSE 66749
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66705: LD_ADDR_EXP 65
66709: PUSH
66710: LD_EXP 65
66714: PPUSH
66715: LD_VAR 0 2
66719: PUSH
66720: LD_EXP 65
66724: PUSH
66725: LD_VAR 0 2
66729: ARRAY
66730: PUSH
66731: LD_INT 1
66733: PLUS
66734: PUSH
66735: EMPTY
66736: LIST
66737: LIST
66738: PPUSH
66739: LD_VAR 0 3
66743: PPUSH
66744: CALL 20553 0 3
66748: ST_TO_ADDR
// break ;
66749: GO 66753
// end ; end ; end ;
66751: GO 66587
66753: POP
66754: POP
// end ;
66755: GO 66347
66757: POP
66758: POP
// end ;
66759: LD_VAR 0 1
66763: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66764: LD_INT 0
66766: PPUSH
66767: PPUSH
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
66772: PPUSH
66773: PPUSH
66774: PPUSH
// if not mc_bases then
66775: LD_EXP 58
66779: NOT
66780: IFFALSE 66784
// exit ;
66782: GO 67189
// for i = 1 to mc_bases do
66784: LD_ADDR_VAR 0 2
66788: PUSH
66789: DOUBLE
66790: LD_INT 1
66792: DEC
66793: ST_TO_ADDR
66794: LD_EXP 58
66798: PUSH
66799: FOR_TO
66800: IFFALSE 67187
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66802: LD_EXP 66
66806: PUSH
66807: LD_VAR 0 2
66811: ARRAY
66812: NOT
66813: PUSH
66814: LD_EXP 58
66818: PUSH
66819: LD_VAR 0 2
66823: ARRAY
66824: PPUSH
66825: LD_INT 30
66827: PUSH
66828: LD_INT 3
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PPUSH
66835: CALL_OW 72
66839: NOT
66840: OR
66841: IFFALSE 66845
// continue ;
66843: GO 66799
// busy := false ;
66845: LD_ADDR_VAR 0 8
66849: PUSH
66850: LD_INT 0
66852: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66853: LD_ADDR_VAR 0 4
66857: PUSH
66858: LD_EXP 58
66862: PUSH
66863: LD_VAR 0 2
66867: ARRAY
66868: PPUSH
66869: LD_INT 30
66871: PUSH
66872: LD_INT 3
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PPUSH
66879: CALL_OW 72
66883: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66884: LD_ADDR_VAR 0 6
66888: PUSH
66889: LD_EXP 66
66893: PUSH
66894: LD_VAR 0 2
66898: ARRAY
66899: PPUSH
66900: LD_INT 2
66902: PUSH
66903: LD_INT 30
66905: PUSH
66906: LD_INT 32
66908: PUSH
66909: EMPTY
66910: LIST
66911: LIST
66912: PUSH
66913: LD_INT 30
66915: PUSH
66916: LD_INT 33
66918: PUSH
66919: EMPTY
66920: LIST
66921: LIST
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: LIST
66927: PPUSH
66928: CALL_OW 72
66932: ST_TO_ADDR
// if not t then
66933: LD_VAR 0 6
66937: NOT
66938: IFFALSE 66942
// continue ;
66940: GO 66799
// for j in tmp do
66942: LD_ADDR_VAR 0 3
66946: PUSH
66947: LD_VAR 0 4
66951: PUSH
66952: FOR_IN
66953: IFFALSE 66983
// if not BuildingStatus ( j ) = bs_idle then
66955: LD_VAR 0 3
66959: PPUSH
66960: CALL_OW 461
66964: PUSH
66965: LD_INT 2
66967: EQUAL
66968: NOT
66969: IFFALSE 66981
// begin busy := true ;
66971: LD_ADDR_VAR 0 8
66975: PUSH
66976: LD_INT 1
66978: ST_TO_ADDR
// break ;
66979: GO 66983
// end ;
66981: GO 66952
66983: POP
66984: POP
// if busy then
66985: LD_VAR 0 8
66989: IFFALSE 66993
// continue ;
66991: GO 66799
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66993: LD_ADDR_VAR 0 7
66997: PUSH
66998: LD_VAR 0 6
67002: PPUSH
67003: LD_INT 35
67005: PUSH
67006: LD_INT 0
67008: PUSH
67009: EMPTY
67010: LIST
67011: LIST
67012: PPUSH
67013: CALL_OW 72
67017: ST_TO_ADDR
// if tw then
67018: LD_VAR 0 7
67022: IFFALSE 67099
// begin tw := tw [ 1 ] ;
67024: LD_ADDR_VAR 0 7
67028: PUSH
67029: LD_VAR 0 7
67033: PUSH
67034: LD_INT 1
67036: ARRAY
67037: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67038: LD_ADDR_VAR 0 9
67042: PUSH
67043: LD_VAR 0 7
67047: PPUSH
67048: LD_EXP 83
67052: PUSH
67053: LD_VAR 0 2
67057: ARRAY
67058: PPUSH
67059: CALL 25523 0 2
67063: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67064: LD_EXP 97
67068: PUSH
67069: LD_VAR 0 2
67073: ARRAY
67074: IFFALSE 67097
// if not weapon in mc_allowed_tower_weapons [ i ] then
67076: LD_VAR 0 9
67080: PUSH
67081: LD_EXP 97
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: IN
67092: NOT
67093: IFFALSE 67097
// continue ;
67095: GO 66799
// end else
67097: GO 67162
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67099: LD_ADDR_VAR 0 5
67103: PUSH
67104: LD_EXP 66
67108: PUSH
67109: LD_VAR 0 2
67113: ARRAY
67114: PPUSH
67115: LD_VAR 0 4
67119: PPUSH
67120: CALL 55662 0 2
67124: ST_TO_ADDR
// if not tmp2 then
67125: LD_VAR 0 5
67129: NOT
67130: IFFALSE 67134
// continue ;
67132: GO 66799
// tw := tmp2 [ 1 ] ;
67134: LD_ADDR_VAR 0 7
67138: PUSH
67139: LD_VAR 0 5
67143: PUSH
67144: LD_INT 1
67146: ARRAY
67147: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67148: LD_ADDR_VAR 0 9
67152: PUSH
67153: LD_VAR 0 5
67157: PUSH
67158: LD_INT 2
67160: ARRAY
67161: ST_TO_ADDR
// end ; if not weapon then
67162: LD_VAR 0 9
67166: NOT
67167: IFFALSE 67171
// continue ;
67169: GO 66799
// ComPlaceWeapon ( tw , weapon ) ;
67171: LD_VAR 0 7
67175: PPUSH
67176: LD_VAR 0 9
67180: PPUSH
67181: CALL_OW 148
// end ;
67185: GO 66799
67187: POP
67188: POP
// end ;
67189: LD_VAR 0 1
67193: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
67194: LD_INT 0
67196: PPUSH
67197: PPUSH
67198: PPUSH
67199: PPUSH
67200: PPUSH
67201: PPUSH
// if not mc_bases then
67202: LD_EXP 58
67206: NOT
67207: IFFALSE 67211
// exit ;
67209: GO 68223
// for i = 1 to mc_bases do
67211: LD_ADDR_VAR 0 2
67215: PUSH
67216: DOUBLE
67217: LD_INT 1
67219: DEC
67220: ST_TO_ADDR
67221: LD_EXP 58
67225: PUSH
67226: FOR_TO
67227: IFFALSE 68221
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
67229: LD_EXP 71
67233: PUSH
67234: LD_VAR 0 2
67238: ARRAY
67239: NOT
67240: PUSH
67241: LD_EXP 71
67245: PUSH
67246: LD_VAR 0 2
67250: ARRAY
67251: PUSH
67252: LD_EXP 72
67256: PUSH
67257: LD_VAR 0 2
67261: ARRAY
67262: EQUAL
67263: OR
67264: IFFALSE 67268
// continue ;
67266: GO 67226
// if mc_miners [ i ] then
67268: LD_EXP 72
67272: PUSH
67273: LD_VAR 0 2
67277: ARRAY
67278: IFFALSE 67908
// begin k := 1 ;
67280: LD_ADDR_VAR 0 4
67284: PUSH
67285: LD_INT 1
67287: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
67288: LD_ADDR_VAR 0 3
67292: PUSH
67293: DOUBLE
67294: LD_EXP 72
67298: PUSH
67299: LD_VAR 0 2
67303: ARRAY
67304: INC
67305: ST_TO_ADDR
67306: LD_INT 1
67308: PUSH
67309: FOR_DOWNTO
67310: IFFALSE 67906
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67312: LD_EXP 72
67316: PUSH
67317: LD_VAR 0 2
67321: ARRAY
67322: PUSH
67323: LD_VAR 0 3
67327: ARRAY
67328: PPUSH
67329: CALL_OW 301
67333: PUSH
67334: LD_EXP 72
67338: PUSH
67339: LD_VAR 0 2
67343: ARRAY
67344: PUSH
67345: LD_VAR 0 3
67349: ARRAY
67350: PPUSH
67351: CALL_OW 257
67355: PUSH
67356: LD_INT 1
67358: NONEQUAL
67359: OR
67360: IFFALSE 67423
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67362: LD_ADDR_VAR 0 5
67366: PUSH
67367: LD_EXP 72
67371: PUSH
67372: LD_VAR 0 2
67376: ARRAY
67377: PUSH
67378: LD_EXP 72
67382: PUSH
67383: LD_VAR 0 2
67387: ARRAY
67388: PUSH
67389: LD_VAR 0 3
67393: ARRAY
67394: DIFF
67395: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67396: LD_ADDR_EXP 72
67400: PUSH
67401: LD_EXP 72
67405: PPUSH
67406: LD_VAR 0 2
67410: PPUSH
67411: LD_VAR 0 5
67415: PPUSH
67416: CALL_OW 1
67420: ST_TO_ADDR
// continue ;
67421: GO 67309
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
67423: LD_EXP 72
67427: PUSH
67428: LD_VAR 0 2
67432: ARRAY
67433: PUSH
67434: LD_VAR 0 3
67438: ARRAY
67439: PPUSH
67440: CALL 20489 0 1
67444: PUSH
67445: LD_EXP 72
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: PUSH
67456: LD_VAR 0 3
67460: ARRAY
67461: PPUSH
67462: CALL_OW 255
67466: PPUSH
67467: LD_EXP 71
67471: PUSH
67472: LD_VAR 0 2
67476: ARRAY
67477: PUSH
67478: LD_VAR 0 4
67482: ARRAY
67483: PUSH
67484: LD_INT 1
67486: ARRAY
67487: PPUSH
67488: LD_EXP 71
67492: PUSH
67493: LD_VAR 0 2
67497: ARRAY
67498: PUSH
67499: LD_VAR 0 4
67503: ARRAY
67504: PUSH
67505: LD_INT 2
67507: ARRAY
67508: PPUSH
67509: LD_INT 15
67511: PPUSH
67512: CALL 21449 0 4
67516: PUSH
67517: LD_INT 4
67519: ARRAY
67520: PUSH
67521: LD_EXP 72
67525: PUSH
67526: LD_VAR 0 2
67530: ARRAY
67531: PUSH
67532: LD_VAR 0 3
67536: ARRAY
67537: PPUSH
67538: LD_INT 10
67540: PPUSH
67541: CALL 23146 0 2
67545: PUSH
67546: LD_INT 4
67548: ARRAY
67549: OR
67550: AND
67551: IFFALSE 67574
// ComStop ( mc_miners [ i ] [ j ] ) ;
67553: LD_EXP 72
67557: PUSH
67558: LD_VAR 0 2
67562: ARRAY
67563: PUSH
67564: LD_VAR 0 3
67568: ARRAY
67569: PPUSH
67570: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
67574: LD_EXP 72
67578: PUSH
67579: LD_VAR 0 2
67583: ARRAY
67584: PUSH
67585: LD_VAR 0 3
67589: ARRAY
67590: PPUSH
67591: CALL_OW 257
67595: PUSH
67596: LD_INT 1
67598: EQUAL
67599: PUSH
67600: LD_EXP 72
67604: PUSH
67605: LD_VAR 0 2
67609: ARRAY
67610: PUSH
67611: LD_VAR 0 3
67615: ARRAY
67616: PPUSH
67617: CALL_OW 459
67621: NOT
67622: AND
67623: PUSH
67624: LD_EXP 72
67628: PUSH
67629: LD_VAR 0 2
67633: ARRAY
67634: PUSH
67635: LD_VAR 0 3
67639: ARRAY
67640: PPUSH
67641: CALL_OW 255
67645: PPUSH
67646: LD_EXP 71
67650: PUSH
67651: LD_VAR 0 2
67655: ARRAY
67656: PUSH
67657: LD_VAR 0 4
67661: ARRAY
67662: PUSH
67663: LD_INT 1
67665: ARRAY
67666: PPUSH
67667: LD_EXP 71
67671: PUSH
67672: LD_VAR 0 2
67676: ARRAY
67677: PUSH
67678: LD_VAR 0 4
67682: ARRAY
67683: PUSH
67684: LD_INT 2
67686: ARRAY
67687: PPUSH
67688: LD_INT 15
67690: PPUSH
67691: CALL 21449 0 4
67695: PUSH
67696: LD_INT 4
67698: ARRAY
67699: PUSH
67700: LD_INT 0
67702: EQUAL
67703: AND
67704: PUSH
67705: LD_EXP 72
67709: PUSH
67710: LD_VAR 0 2
67714: ARRAY
67715: PUSH
67716: LD_VAR 0 3
67720: ARRAY
67721: PPUSH
67722: CALL_OW 314
67726: NOT
67727: AND
67728: IFFALSE 67904
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67730: LD_EXP 72
67734: PUSH
67735: LD_VAR 0 2
67739: ARRAY
67740: PUSH
67741: LD_VAR 0 3
67745: ARRAY
67746: PPUSH
67747: CALL_OW 310
67751: IFFALSE 67774
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67753: LD_EXP 72
67757: PUSH
67758: LD_VAR 0 2
67762: ARRAY
67763: PUSH
67764: LD_VAR 0 3
67768: ARRAY
67769: PPUSH
67770: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67774: LD_EXP 72
67778: PUSH
67779: LD_VAR 0 2
67783: ARRAY
67784: PUSH
67785: LD_VAR 0 3
67789: ARRAY
67790: PPUSH
67791: CALL_OW 314
67795: NOT
67796: IFFALSE 67864
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
67798: LD_EXP 72
67802: PUSH
67803: LD_VAR 0 2
67807: ARRAY
67808: PUSH
67809: LD_VAR 0 3
67813: ARRAY
67814: PPUSH
67815: LD_EXP 71
67819: PUSH
67820: LD_VAR 0 2
67824: ARRAY
67825: PUSH
67826: LD_VAR 0 4
67830: ARRAY
67831: PUSH
67832: LD_INT 1
67834: ARRAY
67835: PPUSH
67836: LD_EXP 71
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: PUSH
67847: LD_VAR 0 4
67851: ARRAY
67852: PUSH
67853: LD_INT 2
67855: ARRAY
67856: PPUSH
67857: LD_INT 0
67859: PPUSH
67860: CALL_OW 193
// k := k + 1 ;
67864: LD_ADDR_VAR 0 4
67868: PUSH
67869: LD_VAR 0 4
67873: PUSH
67874: LD_INT 1
67876: PLUS
67877: ST_TO_ADDR
// if k > mc_mines [ i ] then
67878: LD_VAR 0 4
67882: PUSH
67883: LD_EXP 71
67887: PUSH
67888: LD_VAR 0 2
67892: ARRAY
67893: GREATER
67894: IFFALSE 67904
// k := 1 ;
67896: LD_ADDR_VAR 0 4
67900: PUSH
67901: LD_INT 1
67903: ST_TO_ADDR
// end ; end ;
67904: GO 67309
67906: POP
67907: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67908: LD_ADDR_VAR 0 5
67912: PUSH
67913: LD_EXP 58
67917: PUSH
67918: LD_VAR 0 2
67922: ARRAY
67923: PPUSH
67924: LD_INT 2
67926: PUSH
67927: LD_INT 30
67929: PUSH
67930: LD_INT 4
67932: PUSH
67933: EMPTY
67934: LIST
67935: LIST
67936: PUSH
67937: LD_INT 30
67939: PUSH
67940: LD_INT 5
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 30
67949: PUSH
67950: LD_INT 32
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PUSH
67957: EMPTY
67958: LIST
67959: LIST
67960: LIST
67961: LIST
67962: PPUSH
67963: CALL_OW 72
67967: ST_TO_ADDR
// if not tmp then
67968: LD_VAR 0 5
67972: NOT
67973: IFFALSE 67977
// continue ;
67975: GO 67226
// list := [ ] ;
67977: LD_ADDR_VAR 0 6
67981: PUSH
67982: EMPTY
67983: ST_TO_ADDR
// for j in tmp do
67984: LD_ADDR_VAR 0 3
67988: PUSH
67989: LD_VAR 0 5
67993: PUSH
67994: FOR_IN
67995: IFFALSE 68064
// begin for k in UnitsInside ( j ) do
67997: LD_ADDR_VAR 0 4
68001: PUSH
68002: LD_VAR 0 3
68006: PPUSH
68007: CALL_OW 313
68011: PUSH
68012: FOR_IN
68013: IFFALSE 68060
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68015: LD_VAR 0 4
68019: PPUSH
68020: CALL_OW 257
68024: PUSH
68025: LD_INT 1
68027: EQUAL
68028: PUSH
68029: LD_VAR 0 4
68033: PPUSH
68034: CALL_OW 459
68038: NOT
68039: AND
68040: IFFALSE 68058
// list := list ^ k ;
68042: LD_ADDR_VAR 0 6
68046: PUSH
68047: LD_VAR 0 6
68051: PUSH
68052: LD_VAR 0 4
68056: ADD
68057: ST_TO_ADDR
68058: GO 68012
68060: POP
68061: POP
// end ;
68062: GO 67994
68064: POP
68065: POP
// list := list diff mc_miners [ i ] ;
68066: LD_ADDR_VAR 0 6
68070: PUSH
68071: LD_VAR 0 6
68075: PUSH
68076: LD_EXP 72
68080: PUSH
68081: LD_VAR 0 2
68085: ARRAY
68086: DIFF
68087: ST_TO_ADDR
// if not list then
68088: LD_VAR 0 6
68092: NOT
68093: IFFALSE 68097
// continue ;
68095: GO 67226
// k := mc_mines [ i ] - mc_miners [ i ] ;
68097: LD_ADDR_VAR 0 4
68101: PUSH
68102: LD_EXP 71
68106: PUSH
68107: LD_VAR 0 2
68111: ARRAY
68112: PUSH
68113: LD_EXP 72
68117: PUSH
68118: LD_VAR 0 2
68122: ARRAY
68123: MINUS
68124: ST_TO_ADDR
// if k > list then
68125: LD_VAR 0 4
68129: PUSH
68130: LD_VAR 0 6
68134: GREATER
68135: IFFALSE 68147
// k := list ;
68137: LD_ADDR_VAR 0 4
68141: PUSH
68142: LD_VAR 0 6
68146: ST_TO_ADDR
// for j = 1 to k do
68147: LD_ADDR_VAR 0 3
68151: PUSH
68152: DOUBLE
68153: LD_INT 1
68155: DEC
68156: ST_TO_ADDR
68157: LD_VAR 0 4
68161: PUSH
68162: FOR_TO
68163: IFFALSE 68217
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68165: LD_ADDR_EXP 72
68169: PUSH
68170: LD_EXP 72
68174: PPUSH
68175: LD_VAR 0 2
68179: PUSH
68180: LD_EXP 72
68184: PUSH
68185: LD_VAR 0 2
68189: ARRAY
68190: PUSH
68191: LD_INT 1
68193: PLUS
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PPUSH
68199: LD_VAR 0 6
68203: PUSH
68204: LD_VAR 0 3
68208: ARRAY
68209: PPUSH
68210: CALL 20553 0 3
68214: ST_TO_ADDR
68215: GO 68162
68217: POP
68218: POP
// end ;
68219: GO 67226
68221: POP
68222: POP
// end ;
68223: LD_VAR 0 1
68227: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
68228: LD_INT 0
68230: PPUSH
68231: PPUSH
68232: PPUSH
68233: PPUSH
68234: PPUSH
68235: PPUSH
68236: PPUSH
68237: PPUSH
68238: PPUSH
68239: PPUSH
// if not mc_bases then
68240: LD_EXP 58
68244: NOT
68245: IFFALSE 68249
// exit ;
68247: GO 69980
// for i = 1 to mc_bases do
68249: LD_ADDR_VAR 0 2
68253: PUSH
68254: DOUBLE
68255: LD_INT 1
68257: DEC
68258: ST_TO_ADDR
68259: LD_EXP 58
68263: PUSH
68264: FOR_TO
68265: IFFALSE 69978
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68267: LD_EXP 58
68271: PUSH
68272: LD_VAR 0 2
68276: ARRAY
68277: NOT
68278: PUSH
68279: LD_EXP 65
68283: PUSH
68284: LD_VAR 0 2
68288: ARRAY
68289: OR
68290: IFFALSE 68294
// continue ;
68292: GO 68264
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68294: LD_EXP 74
68298: PUSH
68299: LD_VAR 0 2
68303: ARRAY
68304: NOT
68305: PUSH
68306: LD_EXP 75
68310: PUSH
68311: LD_VAR 0 2
68315: ARRAY
68316: AND
68317: IFFALSE 68355
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68319: LD_ADDR_EXP 75
68323: PUSH
68324: LD_EXP 75
68328: PPUSH
68329: LD_VAR 0 2
68333: PPUSH
68334: EMPTY
68335: PPUSH
68336: CALL_OW 1
68340: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68341: LD_VAR 0 2
68345: PPUSH
68346: LD_INT 107
68348: PPUSH
68349: CALL 59444 0 2
// continue ;
68353: GO 68264
// end ; target := [ ] ;
68355: LD_ADDR_VAR 0 6
68359: PUSH
68360: EMPTY
68361: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68362: LD_ADDR_VAR 0 3
68366: PUSH
68367: DOUBLE
68368: LD_EXP 74
68372: PUSH
68373: LD_VAR 0 2
68377: ARRAY
68378: INC
68379: ST_TO_ADDR
68380: LD_INT 1
68382: PUSH
68383: FOR_DOWNTO
68384: IFFALSE 68644
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68386: LD_EXP 74
68390: PUSH
68391: LD_VAR 0 2
68395: ARRAY
68396: PUSH
68397: LD_VAR 0 3
68401: ARRAY
68402: PUSH
68403: LD_INT 2
68405: ARRAY
68406: PPUSH
68407: LD_EXP 74
68411: PUSH
68412: LD_VAR 0 2
68416: ARRAY
68417: PUSH
68418: LD_VAR 0 3
68422: ARRAY
68423: PUSH
68424: LD_INT 3
68426: ARRAY
68427: PPUSH
68428: CALL_OW 488
68432: PUSH
68433: LD_EXP 74
68437: PUSH
68438: LD_VAR 0 2
68442: ARRAY
68443: PUSH
68444: LD_VAR 0 3
68448: ARRAY
68449: PUSH
68450: LD_INT 2
68452: ARRAY
68453: PPUSH
68454: LD_EXP 74
68458: PUSH
68459: LD_VAR 0 2
68463: ARRAY
68464: PUSH
68465: LD_VAR 0 3
68469: ARRAY
68470: PUSH
68471: LD_INT 3
68473: ARRAY
68474: PPUSH
68475: CALL_OW 284
68479: PUSH
68480: LD_INT 0
68482: EQUAL
68483: AND
68484: IFFALSE 68539
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68486: LD_ADDR_VAR 0 5
68490: PUSH
68491: LD_EXP 74
68495: PUSH
68496: LD_VAR 0 2
68500: ARRAY
68501: PPUSH
68502: LD_VAR 0 3
68506: PPUSH
68507: CALL_OW 3
68511: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68512: LD_ADDR_EXP 74
68516: PUSH
68517: LD_EXP 74
68521: PPUSH
68522: LD_VAR 0 2
68526: PPUSH
68527: LD_VAR 0 5
68531: PPUSH
68532: CALL_OW 1
68536: ST_TO_ADDR
// continue ;
68537: GO 68383
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68539: LD_EXP 58
68543: PUSH
68544: LD_VAR 0 2
68548: ARRAY
68549: PUSH
68550: LD_INT 1
68552: ARRAY
68553: PPUSH
68554: CALL_OW 255
68558: PPUSH
68559: LD_EXP 74
68563: PUSH
68564: LD_VAR 0 2
68568: ARRAY
68569: PUSH
68570: LD_VAR 0 3
68574: ARRAY
68575: PUSH
68576: LD_INT 2
68578: ARRAY
68579: PPUSH
68580: LD_EXP 74
68584: PUSH
68585: LD_VAR 0 2
68589: ARRAY
68590: PUSH
68591: LD_VAR 0 3
68595: ARRAY
68596: PUSH
68597: LD_INT 3
68599: ARRAY
68600: PPUSH
68601: LD_INT 30
68603: PPUSH
68604: CALL 21449 0 4
68608: PUSH
68609: LD_INT 4
68611: ARRAY
68612: PUSH
68613: LD_INT 0
68615: EQUAL
68616: IFFALSE 68642
// begin target := mc_crates [ i ] [ j ] ;
68618: LD_ADDR_VAR 0 6
68622: PUSH
68623: LD_EXP 74
68627: PUSH
68628: LD_VAR 0 2
68632: ARRAY
68633: PUSH
68634: LD_VAR 0 3
68638: ARRAY
68639: ST_TO_ADDR
// break ;
68640: GO 68644
// end ; end ;
68642: GO 68383
68644: POP
68645: POP
// if not target then
68646: LD_VAR 0 6
68650: NOT
68651: IFFALSE 68655
// continue ;
68653: GO 68264
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68655: LD_ADDR_VAR 0 7
68659: PUSH
68660: LD_EXP 77
68664: PUSH
68665: LD_VAR 0 2
68669: ARRAY
68670: PPUSH
68671: LD_INT 2
68673: PUSH
68674: LD_INT 3
68676: PUSH
68677: LD_INT 58
68679: PUSH
68680: EMPTY
68681: LIST
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 61
68689: PUSH
68690: EMPTY
68691: LIST
68692: PUSH
68693: LD_INT 33
68695: PUSH
68696: LD_INT 5
68698: PUSH
68699: EMPTY
68700: LIST
68701: LIST
68702: PUSH
68703: LD_INT 33
68705: PUSH
68706: LD_INT 3
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: PUSH
68720: LD_INT 2
68722: PUSH
68723: LD_INT 34
68725: PUSH
68726: LD_INT 32
68728: PUSH
68729: EMPTY
68730: LIST
68731: LIST
68732: PUSH
68733: LD_INT 34
68735: PUSH
68736: LD_INT 51
68738: PUSH
68739: EMPTY
68740: LIST
68741: LIST
68742: PUSH
68743: LD_INT 34
68745: PUSH
68746: LD_INT 12
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: LIST
68757: LIST
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PPUSH
68763: CALL_OW 72
68767: ST_TO_ADDR
// if not cargo then
68768: LD_VAR 0 7
68772: NOT
68773: IFFALSE 69416
// begin if mc_crates_collector [ i ] < 5 then
68775: LD_EXP 75
68779: PUSH
68780: LD_VAR 0 2
68784: ARRAY
68785: PUSH
68786: LD_INT 5
68788: LESS
68789: IFFALSE 69155
// begin if mc_ape [ i ] then
68791: LD_EXP 87
68795: PUSH
68796: LD_VAR 0 2
68800: ARRAY
68801: IFFALSE 68848
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68803: LD_ADDR_VAR 0 5
68807: PUSH
68808: LD_EXP 87
68812: PUSH
68813: LD_VAR 0 2
68817: ARRAY
68818: PPUSH
68819: LD_INT 25
68821: PUSH
68822: LD_INT 16
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 24
68831: PUSH
68832: LD_INT 750
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: EMPTY
68840: LIST
68841: LIST
68842: PPUSH
68843: CALL_OW 72
68847: ST_TO_ADDR
// if not tmp then
68848: LD_VAR 0 5
68852: NOT
68853: IFFALSE 68900
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68855: LD_ADDR_VAR 0 5
68859: PUSH
68860: LD_EXP 58
68864: PUSH
68865: LD_VAR 0 2
68869: ARRAY
68870: PPUSH
68871: LD_INT 25
68873: PUSH
68874: LD_INT 2
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PUSH
68881: LD_INT 24
68883: PUSH
68884: LD_INT 750
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: PPUSH
68895: CALL_OW 72
68899: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68900: LD_EXP 87
68904: PUSH
68905: LD_VAR 0 2
68909: ARRAY
68910: PUSH
68911: LD_EXP 58
68915: PUSH
68916: LD_VAR 0 2
68920: ARRAY
68921: PPUSH
68922: LD_INT 25
68924: PUSH
68925: LD_INT 2
68927: PUSH
68928: EMPTY
68929: LIST
68930: LIST
68931: PUSH
68932: LD_INT 24
68934: PUSH
68935: LD_INT 750
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PUSH
68942: EMPTY
68943: LIST
68944: LIST
68945: PPUSH
68946: CALL_OW 72
68950: AND
68951: PUSH
68952: LD_VAR 0 5
68956: PUSH
68957: LD_INT 5
68959: LESS
68960: AND
68961: IFFALSE 69043
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68963: LD_ADDR_VAR 0 3
68967: PUSH
68968: LD_EXP 58
68972: PUSH
68973: LD_VAR 0 2
68977: ARRAY
68978: PPUSH
68979: LD_INT 25
68981: PUSH
68982: LD_INT 2
68984: PUSH
68985: EMPTY
68986: LIST
68987: LIST
68988: PUSH
68989: LD_INT 24
68991: PUSH
68992: LD_INT 750
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PPUSH
69003: CALL_OW 72
69007: PUSH
69008: FOR_IN
69009: IFFALSE 69041
// begin tmp := tmp union j ;
69011: LD_ADDR_VAR 0 5
69015: PUSH
69016: LD_VAR 0 5
69020: PUSH
69021: LD_VAR 0 3
69025: UNION
69026: ST_TO_ADDR
// if tmp >= 5 then
69027: LD_VAR 0 5
69031: PUSH
69032: LD_INT 5
69034: GREATEREQUAL
69035: IFFALSE 69039
// break ;
69037: GO 69041
// end ;
69039: GO 69008
69041: POP
69042: POP
// end ; if not tmp then
69043: LD_VAR 0 5
69047: NOT
69048: IFFALSE 69052
// continue ;
69050: GO 68264
// for j in tmp do
69052: LD_ADDR_VAR 0 3
69056: PUSH
69057: LD_VAR 0 5
69061: PUSH
69062: FOR_IN
69063: IFFALSE 69153
// if not GetTag ( j ) then
69065: LD_VAR 0 3
69069: PPUSH
69070: CALL_OW 110
69074: NOT
69075: IFFALSE 69151
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69077: LD_ADDR_EXP 75
69081: PUSH
69082: LD_EXP 75
69086: PPUSH
69087: LD_VAR 0 2
69091: PUSH
69092: LD_EXP 75
69096: PUSH
69097: LD_VAR 0 2
69101: ARRAY
69102: PUSH
69103: LD_INT 1
69105: PLUS
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PPUSH
69111: LD_VAR 0 3
69115: PPUSH
69116: CALL 20553 0 3
69120: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69121: LD_VAR 0 3
69125: PPUSH
69126: LD_INT 107
69128: PPUSH
69129: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69133: LD_EXP 75
69137: PUSH
69138: LD_VAR 0 2
69142: ARRAY
69143: PUSH
69144: LD_INT 5
69146: GREATEREQUAL
69147: IFFALSE 69151
// break ;
69149: GO 69153
// end ;
69151: GO 69062
69153: POP
69154: POP
// end ; if mc_crates_collector [ i ] and target then
69155: LD_EXP 75
69159: PUSH
69160: LD_VAR 0 2
69164: ARRAY
69165: PUSH
69166: LD_VAR 0 6
69170: AND
69171: IFFALSE 69414
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69173: LD_EXP 75
69177: PUSH
69178: LD_VAR 0 2
69182: ARRAY
69183: PUSH
69184: LD_VAR 0 6
69188: PUSH
69189: LD_INT 1
69191: ARRAY
69192: LESS
69193: IFFALSE 69213
// tmp := mc_crates_collector [ i ] else
69195: LD_ADDR_VAR 0 5
69199: PUSH
69200: LD_EXP 75
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: ST_TO_ADDR
69211: GO 69227
// tmp := target [ 1 ] ;
69213: LD_ADDR_VAR 0 5
69217: PUSH
69218: LD_VAR 0 6
69222: PUSH
69223: LD_INT 1
69225: ARRAY
69226: ST_TO_ADDR
// k := 0 ;
69227: LD_ADDR_VAR 0 4
69231: PUSH
69232: LD_INT 0
69234: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69235: LD_ADDR_VAR 0 3
69239: PUSH
69240: LD_EXP 75
69244: PUSH
69245: LD_VAR 0 2
69249: ARRAY
69250: PUSH
69251: FOR_IN
69252: IFFALSE 69412
// begin k := k + 1 ;
69254: LD_ADDR_VAR 0 4
69258: PUSH
69259: LD_VAR 0 4
69263: PUSH
69264: LD_INT 1
69266: PLUS
69267: ST_TO_ADDR
// if k > tmp then
69268: LD_VAR 0 4
69272: PUSH
69273: LD_VAR 0 5
69277: GREATER
69278: IFFALSE 69282
// break ;
69280: GO 69412
// if not GetClass ( j ) in [ 2 , 16 ] then
69282: LD_VAR 0 3
69286: PPUSH
69287: CALL_OW 257
69291: PUSH
69292: LD_INT 2
69294: PUSH
69295: LD_INT 16
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: IN
69302: NOT
69303: IFFALSE 69356
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69305: LD_ADDR_EXP 75
69309: PUSH
69310: LD_EXP 75
69314: PPUSH
69315: LD_VAR 0 2
69319: PPUSH
69320: LD_EXP 75
69324: PUSH
69325: LD_VAR 0 2
69329: ARRAY
69330: PUSH
69331: LD_VAR 0 3
69335: DIFF
69336: PPUSH
69337: CALL_OW 1
69341: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69342: LD_VAR 0 3
69346: PPUSH
69347: LD_INT 0
69349: PPUSH
69350: CALL_OW 109
// continue ;
69354: GO 69251
// end ; if IsInUnit ( j ) then
69356: LD_VAR 0 3
69360: PPUSH
69361: CALL_OW 310
69365: IFFALSE 69376
// ComExitBuilding ( j ) ;
69367: LD_VAR 0 3
69371: PPUSH
69372: CALL_OW 122
// wait ( 3 ) ;
69376: LD_INT 3
69378: PPUSH
69379: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69383: LD_VAR 0 3
69387: PPUSH
69388: LD_VAR 0 6
69392: PUSH
69393: LD_INT 2
69395: ARRAY
69396: PPUSH
69397: LD_VAR 0 6
69401: PUSH
69402: LD_INT 3
69404: ARRAY
69405: PPUSH
69406: CALL_OW 117
// end ;
69410: GO 69251
69412: POP
69413: POP
// end ; end else
69414: GO 69976
// begin for j in cargo do
69416: LD_ADDR_VAR 0 3
69420: PUSH
69421: LD_VAR 0 7
69425: PUSH
69426: FOR_IN
69427: IFFALSE 69974
// begin if GetTag ( j ) <> 0 then
69429: LD_VAR 0 3
69433: PPUSH
69434: CALL_OW 110
69438: PUSH
69439: LD_INT 0
69441: NONEQUAL
69442: IFFALSE 69446
// continue ;
69444: GO 69426
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69446: LD_VAR 0 3
69450: PPUSH
69451: CALL_OW 256
69455: PUSH
69456: LD_INT 1000
69458: LESS
69459: PUSH
69460: LD_VAR 0 3
69464: PPUSH
69465: LD_EXP 82
69469: PUSH
69470: LD_VAR 0 2
69474: ARRAY
69475: PPUSH
69476: CALL_OW 308
69480: NOT
69481: AND
69482: IFFALSE 69504
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69484: LD_VAR 0 3
69488: PPUSH
69489: LD_EXP 82
69493: PUSH
69494: LD_VAR 0 2
69498: ARRAY
69499: PPUSH
69500: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69504: LD_VAR 0 3
69508: PPUSH
69509: CALL_OW 256
69513: PUSH
69514: LD_INT 1000
69516: LESS
69517: PUSH
69518: LD_VAR 0 3
69522: PPUSH
69523: LD_EXP 82
69527: PUSH
69528: LD_VAR 0 2
69532: ARRAY
69533: PPUSH
69534: CALL_OW 308
69538: AND
69539: IFFALSE 69543
// continue ;
69541: GO 69426
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69543: LD_VAR 0 3
69547: PPUSH
69548: CALL_OW 262
69552: PUSH
69553: LD_INT 2
69555: EQUAL
69556: PUSH
69557: LD_VAR 0 3
69561: PPUSH
69562: CALL_OW 261
69566: PUSH
69567: LD_INT 15
69569: LESS
69570: AND
69571: IFFALSE 69575
// continue ;
69573: GO 69426
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69575: LD_VAR 0 3
69579: PPUSH
69580: CALL_OW 262
69584: PUSH
69585: LD_INT 1
69587: EQUAL
69588: PUSH
69589: LD_VAR 0 3
69593: PPUSH
69594: CALL_OW 261
69598: PUSH
69599: LD_INT 10
69601: LESS
69602: AND
69603: IFFALSE 69913
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69605: LD_ADDR_VAR 0 8
69609: PUSH
69610: LD_EXP 58
69614: PUSH
69615: LD_VAR 0 2
69619: ARRAY
69620: PPUSH
69621: LD_INT 2
69623: PUSH
69624: LD_INT 30
69626: PUSH
69627: LD_INT 0
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: PUSH
69634: LD_INT 30
69636: PUSH
69637: LD_INT 1
69639: PUSH
69640: EMPTY
69641: LIST
69642: LIST
69643: PUSH
69644: EMPTY
69645: LIST
69646: LIST
69647: LIST
69648: PPUSH
69649: CALL_OW 72
69653: ST_TO_ADDR
// if not depot then
69654: LD_VAR 0 8
69658: NOT
69659: IFFALSE 69663
// continue ;
69661: GO 69426
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69663: LD_VAR 0 3
69667: PPUSH
69668: LD_VAR 0 8
69672: PPUSH
69673: LD_VAR 0 3
69677: PPUSH
69678: CALL_OW 74
69682: PPUSH
69683: CALL_OW 296
69687: PUSH
69688: LD_INT 6
69690: LESS
69691: IFFALSE 69707
// SetFuel ( j , 100 ) else
69693: LD_VAR 0 3
69697: PPUSH
69698: LD_INT 100
69700: PPUSH
69701: CALL_OW 240
69705: GO 69913
// if GetFuel ( j ) = 0 then
69707: LD_VAR 0 3
69711: PPUSH
69712: CALL_OW 261
69716: PUSH
69717: LD_INT 0
69719: EQUAL
69720: IFFALSE 69913
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69722: LD_ADDR_EXP 77
69726: PUSH
69727: LD_EXP 77
69731: PPUSH
69732: LD_VAR 0 2
69736: PPUSH
69737: LD_EXP 77
69741: PUSH
69742: LD_VAR 0 2
69746: ARRAY
69747: PUSH
69748: LD_VAR 0 3
69752: DIFF
69753: PPUSH
69754: CALL_OW 1
69758: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69759: LD_VAR 0 3
69763: PPUSH
69764: CALL_OW 263
69768: PUSH
69769: LD_INT 1
69771: EQUAL
69772: IFFALSE 69788
// ComExitVehicle ( IsInUnit ( j ) ) ;
69774: LD_VAR 0 3
69778: PPUSH
69779: CALL_OW 310
69783: PPUSH
69784: CALL_OW 121
// if GetControl ( j ) = control_remote then
69788: LD_VAR 0 3
69792: PPUSH
69793: CALL_OW 263
69797: PUSH
69798: LD_INT 2
69800: EQUAL
69801: IFFALSE 69812
// ComUnlink ( j ) ;
69803: LD_VAR 0 3
69807: PPUSH
69808: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
69812: LD_ADDR_VAR 0 9
69816: PUSH
69817: LD_VAR 0 2
69821: PPUSH
69822: LD_INT 3
69824: PPUSH
69825: CALL 79017 0 2
69829: ST_TO_ADDR
// if fac then
69830: LD_VAR 0 9
69834: IFFALSE 69911
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69836: LD_ADDR_VAR 0 10
69840: PUSH
69841: LD_VAR 0 9
69845: PPUSH
69846: LD_VAR 0 3
69850: PPUSH
69851: CALL_OW 265
69855: PPUSH
69856: LD_VAR 0 3
69860: PPUSH
69861: CALL_OW 262
69865: PPUSH
69866: LD_VAR 0 3
69870: PPUSH
69871: CALL_OW 263
69875: PPUSH
69876: LD_VAR 0 3
69880: PPUSH
69881: CALL_OW 264
69885: PPUSH
69886: CALL 18153 0 5
69890: ST_TO_ADDR
// if components then
69891: LD_VAR 0 10
69895: IFFALSE 69911
// MC_InsertProduceList ( i , components ) ;
69897: LD_VAR 0 2
69901: PPUSH
69902: LD_VAR 0 10
69906: PPUSH
69907: CALL 78645 0 2
// end ; continue ;
69911: GO 69426
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69913: LD_VAR 0 3
69917: PPUSH
69918: LD_INT 1
69920: PPUSH
69921: CALL_OW 289
69925: PUSH
69926: LD_INT 100
69928: LESS
69929: PUSH
69930: LD_VAR 0 3
69934: PPUSH
69935: CALL_OW 314
69939: NOT
69940: AND
69941: IFFALSE 69970
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69943: LD_VAR 0 3
69947: PPUSH
69948: LD_VAR 0 6
69952: PUSH
69953: LD_INT 2
69955: ARRAY
69956: PPUSH
69957: LD_VAR 0 6
69961: PUSH
69962: LD_INT 3
69964: ARRAY
69965: PPUSH
69966: CALL_OW 117
// break ;
69970: GO 69974
// end ;
69972: GO 69426
69974: POP
69975: POP
// end ; end ;
69976: GO 68264
69978: POP
69979: POP
// end ;
69980: LD_VAR 0 1
69984: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69985: LD_INT 0
69987: PPUSH
69988: PPUSH
69989: PPUSH
69990: PPUSH
// if not mc_bases then
69991: LD_EXP 58
69995: NOT
69996: IFFALSE 70000
// exit ;
69998: GO 70161
// for i = 1 to mc_bases do
70000: LD_ADDR_VAR 0 2
70004: PUSH
70005: DOUBLE
70006: LD_INT 1
70008: DEC
70009: ST_TO_ADDR
70010: LD_EXP 58
70014: PUSH
70015: FOR_TO
70016: IFFALSE 70159
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70018: LD_ADDR_VAR 0 4
70022: PUSH
70023: LD_EXP 77
70027: PUSH
70028: LD_VAR 0 2
70032: ARRAY
70033: PUSH
70034: LD_EXP 80
70038: PUSH
70039: LD_VAR 0 2
70043: ARRAY
70044: UNION
70045: PPUSH
70046: LD_INT 33
70048: PUSH
70049: LD_INT 2
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PPUSH
70056: CALL_OW 72
70060: ST_TO_ADDR
// if tmp then
70061: LD_VAR 0 4
70065: IFFALSE 70157
// for j in tmp do
70067: LD_ADDR_VAR 0 3
70071: PUSH
70072: LD_VAR 0 4
70076: PUSH
70077: FOR_IN
70078: IFFALSE 70155
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70080: LD_VAR 0 3
70084: PPUSH
70085: CALL_OW 312
70089: NOT
70090: PUSH
70091: LD_VAR 0 3
70095: PPUSH
70096: CALL_OW 256
70100: PUSH
70101: LD_INT 250
70103: GREATEREQUAL
70104: AND
70105: IFFALSE 70118
// Connect ( j ) else
70107: LD_VAR 0 3
70111: PPUSH
70112: CALL 23486 0 1
70116: GO 70153
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70118: LD_VAR 0 3
70122: PPUSH
70123: CALL_OW 256
70127: PUSH
70128: LD_INT 250
70130: LESS
70131: PUSH
70132: LD_VAR 0 3
70136: PPUSH
70137: CALL_OW 312
70141: AND
70142: IFFALSE 70153
// ComUnlink ( j ) ;
70144: LD_VAR 0 3
70148: PPUSH
70149: CALL_OW 136
70153: GO 70077
70155: POP
70156: POP
// end ;
70157: GO 70015
70159: POP
70160: POP
// end ;
70161: LD_VAR 0 1
70165: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70166: LD_INT 0
70168: PPUSH
70169: PPUSH
70170: PPUSH
70171: PPUSH
70172: PPUSH
// if not mc_bases then
70173: LD_EXP 58
70177: NOT
70178: IFFALSE 70182
// exit ;
70180: GO 70642
// for i = 1 to mc_bases do
70182: LD_ADDR_VAR 0 2
70186: PUSH
70187: DOUBLE
70188: LD_INT 1
70190: DEC
70191: ST_TO_ADDR
70192: LD_EXP 58
70196: PUSH
70197: FOR_TO
70198: IFFALSE 70640
// begin if not mc_produce [ i ] then
70200: LD_EXP 79
70204: PUSH
70205: LD_VAR 0 2
70209: ARRAY
70210: NOT
70211: IFFALSE 70215
// continue ;
70213: GO 70197
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70215: LD_ADDR_VAR 0 5
70219: PUSH
70220: LD_EXP 58
70224: PUSH
70225: LD_VAR 0 2
70229: ARRAY
70230: PPUSH
70231: LD_INT 30
70233: PUSH
70234: LD_INT 3
70236: PUSH
70237: EMPTY
70238: LIST
70239: LIST
70240: PPUSH
70241: CALL_OW 72
70245: ST_TO_ADDR
// if not fac then
70246: LD_VAR 0 5
70250: NOT
70251: IFFALSE 70255
// continue ;
70253: GO 70197
// for j in fac do
70255: LD_ADDR_VAR 0 3
70259: PUSH
70260: LD_VAR 0 5
70264: PUSH
70265: FOR_IN
70266: IFFALSE 70636
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
70268: LD_VAR 0 3
70272: PPUSH
70273: CALL_OW 461
70277: PUSH
70278: LD_INT 2
70280: NONEQUAL
70281: PUSH
70282: LD_VAR 0 3
70286: PPUSH
70287: LD_INT 15
70289: PPUSH
70290: CALL 23146 0 2
70294: PUSH
70295: LD_INT 4
70297: ARRAY
70298: OR
70299: PUSH
70300: LD_VAR 0 3
70304: PPUSH
70305: CALL_OW 313
70309: PUSH
70310: LD_INT 0
70312: EQUAL
70313: OR
70314: IFFALSE 70318
// continue ;
70316: GO 70265
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70318: LD_VAR 0 3
70322: PPUSH
70323: LD_EXP 79
70327: PUSH
70328: LD_VAR 0 2
70332: ARRAY
70333: PUSH
70334: LD_INT 1
70336: ARRAY
70337: PUSH
70338: LD_INT 1
70340: ARRAY
70341: PPUSH
70342: LD_EXP 79
70346: PUSH
70347: LD_VAR 0 2
70351: ARRAY
70352: PUSH
70353: LD_INT 1
70355: ARRAY
70356: PUSH
70357: LD_INT 2
70359: ARRAY
70360: PPUSH
70361: LD_EXP 79
70365: PUSH
70366: LD_VAR 0 2
70370: ARRAY
70371: PUSH
70372: LD_INT 1
70374: ARRAY
70375: PUSH
70376: LD_INT 3
70378: ARRAY
70379: PPUSH
70380: LD_EXP 79
70384: PUSH
70385: LD_VAR 0 2
70389: ARRAY
70390: PUSH
70391: LD_INT 1
70393: ARRAY
70394: PUSH
70395: LD_INT 4
70397: ARRAY
70398: PPUSH
70399: CALL_OW 448
70403: PUSH
70404: LD_VAR 0 3
70408: PPUSH
70409: LD_EXP 79
70413: PUSH
70414: LD_VAR 0 2
70418: ARRAY
70419: PUSH
70420: LD_INT 1
70422: ARRAY
70423: PUSH
70424: LD_INT 1
70426: ARRAY
70427: PUSH
70428: LD_EXP 79
70432: PUSH
70433: LD_VAR 0 2
70437: ARRAY
70438: PUSH
70439: LD_INT 1
70441: ARRAY
70442: PUSH
70443: LD_INT 2
70445: ARRAY
70446: PUSH
70447: LD_EXP 79
70451: PUSH
70452: LD_VAR 0 2
70456: ARRAY
70457: PUSH
70458: LD_INT 1
70460: ARRAY
70461: PUSH
70462: LD_INT 3
70464: ARRAY
70465: PUSH
70466: LD_EXP 79
70470: PUSH
70471: LD_VAR 0 2
70475: ARRAY
70476: PUSH
70477: LD_INT 1
70479: ARRAY
70480: PUSH
70481: LD_INT 4
70483: ARRAY
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: LIST
70489: LIST
70490: PPUSH
70491: CALL 26817 0 2
70495: AND
70496: IFFALSE 70634
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70498: LD_VAR 0 3
70502: PPUSH
70503: LD_EXP 79
70507: PUSH
70508: LD_VAR 0 2
70512: ARRAY
70513: PUSH
70514: LD_INT 1
70516: ARRAY
70517: PUSH
70518: LD_INT 1
70520: ARRAY
70521: PPUSH
70522: LD_EXP 79
70526: PUSH
70527: LD_VAR 0 2
70531: ARRAY
70532: PUSH
70533: LD_INT 1
70535: ARRAY
70536: PUSH
70537: LD_INT 2
70539: ARRAY
70540: PPUSH
70541: LD_EXP 79
70545: PUSH
70546: LD_VAR 0 2
70550: ARRAY
70551: PUSH
70552: LD_INT 1
70554: ARRAY
70555: PUSH
70556: LD_INT 3
70558: ARRAY
70559: PPUSH
70560: LD_EXP 79
70564: PUSH
70565: LD_VAR 0 2
70569: ARRAY
70570: PUSH
70571: LD_INT 1
70573: ARRAY
70574: PUSH
70575: LD_INT 4
70577: ARRAY
70578: PPUSH
70579: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70583: LD_ADDR_VAR 0 4
70587: PUSH
70588: LD_EXP 79
70592: PUSH
70593: LD_VAR 0 2
70597: ARRAY
70598: PPUSH
70599: LD_INT 1
70601: PPUSH
70602: CALL_OW 3
70606: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70607: LD_ADDR_EXP 79
70611: PUSH
70612: LD_EXP 79
70616: PPUSH
70617: LD_VAR 0 2
70621: PPUSH
70622: LD_VAR 0 4
70626: PPUSH
70627: CALL_OW 1
70631: ST_TO_ADDR
// break ;
70632: GO 70636
// end ; end ;
70634: GO 70265
70636: POP
70637: POP
// end ;
70638: GO 70197
70640: POP
70641: POP
// end ;
70642: LD_VAR 0 1
70646: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70647: LD_INT 0
70649: PPUSH
70650: PPUSH
70651: PPUSH
// if not mc_bases then
70652: LD_EXP 58
70656: NOT
70657: IFFALSE 70661
// exit ;
70659: GO 70750
// for i = 1 to mc_bases do
70661: LD_ADDR_VAR 0 2
70665: PUSH
70666: DOUBLE
70667: LD_INT 1
70669: DEC
70670: ST_TO_ADDR
70671: LD_EXP 58
70675: PUSH
70676: FOR_TO
70677: IFFALSE 70748
// begin if mc_attack [ i ] then
70679: LD_EXP 78
70683: PUSH
70684: LD_VAR 0 2
70688: ARRAY
70689: IFFALSE 70746
// begin tmp := mc_attack [ i ] [ 1 ] ;
70691: LD_ADDR_VAR 0 3
70695: PUSH
70696: LD_EXP 78
70700: PUSH
70701: LD_VAR 0 2
70705: ARRAY
70706: PUSH
70707: LD_INT 1
70709: ARRAY
70710: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70711: LD_ADDR_EXP 78
70715: PUSH
70716: LD_EXP 78
70720: PPUSH
70721: LD_VAR 0 2
70725: PPUSH
70726: EMPTY
70727: PPUSH
70728: CALL_OW 1
70732: ST_TO_ADDR
// Attack ( tmp ) ;
70733: LD_VAR 0 3
70737: PPUSH
70738: CALL 49006 0 1
// exit ;
70742: POP
70743: POP
70744: GO 70750
// end ; end ;
70746: GO 70676
70748: POP
70749: POP
// end ;
70750: LD_VAR 0 1
70754: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70755: LD_INT 0
70757: PPUSH
70758: PPUSH
70759: PPUSH
70760: PPUSH
70761: PPUSH
70762: PPUSH
70763: PPUSH
// if not mc_bases then
70764: LD_EXP 58
70768: NOT
70769: IFFALSE 70773
// exit ;
70771: GO 71377
// for i = 1 to mc_bases do
70773: LD_ADDR_VAR 0 2
70777: PUSH
70778: DOUBLE
70779: LD_INT 1
70781: DEC
70782: ST_TO_ADDR
70783: LD_EXP 58
70787: PUSH
70788: FOR_TO
70789: IFFALSE 71375
// begin if not mc_bases [ i ] then
70791: LD_EXP 58
70795: PUSH
70796: LD_VAR 0 2
70800: ARRAY
70801: NOT
70802: IFFALSE 70806
// continue ;
70804: GO 70788
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70806: LD_ADDR_VAR 0 7
70810: PUSH
70811: LD_EXP 58
70815: PUSH
70816: LD_VAR 0 2
70820: ARRAY
70821: PUSH
70822: LD_INT 1
70824: ARRAY
70825: PPUSH
70826: CALL 17457 0 1
70830: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70831: LD_ADDR_EXP 81
70835: PUSH
70836: LD_EXP 81
70840: PPUSH
70841: LD_VAR 0 2
70845: PPUSH
70846: LD_EXP 58
70850: PUSH
70851: LD_VAR 0 2
70855: ARRAY
70856: PUSH
70857: LD_INT 1
70859: ARRAY
70860: PPUSH
70861: CALL_OW 255
70865: PPUSH
70866: LD_EXP 83
70870: PUSH
70871: LD_VAR 0 2
70875: ARRAY
70876: PPUSH
70877: CALL 15417 0 2
70881: PPUSH
70882: CALL_OW 1
70886: ST_TO_ADDR
// if not mc_scan [ i ] then
70887: LD_EXP 81
70891: PUSH
70892: LD_VAR 0 2
70896: ARRAY
70897: NOT
70898: IFFALSE 71053
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70900: LD_ADDR_VAR 0 4
70904: PUSH
70905: LD_EXP 58
70909: PUSH
70910: LD_VAR 0 2
70914: ARRAY
70915: PPUSH
70916: LD_INT 2
70918: PUSH
70919: LD_INT 25
70921: PUSH
70922: LD_INT 5
70924: PUSH
70925: EMPTY
70926: LIST
70927: LIST
70928: PUSH
70929: LD_INT 25
70931: PUSH
70932: LD_INT 8
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 25
70941: PUSH
70942: LD_INT 9
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: LIST
70953: LIST
70954: PPUSH
70955: CALL_OW 72
70959: ST_TO_ADDR
// if not tmp then
70960: LD_VAR 0 4
70964: NOT
70965: IFFALSE 70969
// continue ;
70967: GO 70788
// for j in tmp do
70969: LD_ADDR_VAR 0 3
70973: PUSH
70974: LD_VAR 0 4
70978: PUSH
70979: FOR_IN
70980: IFFALSE 71051
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70982: LD_VAR 0 3
70986: PPUSH
70987: CALL_OW 310
70991: PPUSH
70992: CALL_OW 266
70996: PUSH
70997: LD_INT 5
70999: EQUAL
71000: PUSH
71001: LD_VAR 0 3
71005: PPUSH
71006: CALL_OW 257
71010: PUSH
71011: LD_INT 1
71013: EQUAL
71014: AND
71015: PUSH
71016: LD_VAR 0 3
71020: PPUSH
71021: CALL_OW 459
71025: NOT
71026: AND
71027: PUSH
71028: LD_VAR 0 7
71032: AND
71033: IFFALSE 71049
// ComChangeProfession ( j , class ) ;
71035: LD_VAR 0 3
71039: PPUSH
71040: LD_VAR 0 7
71044: PPUSH
71045: CALL_OW 123
71049: GO 70979
71051: POP
71052: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71053: LD_EXP 81
71057: PUSH
71058: LD_VAR 0 2
71062: ARRAY
71063: PUSH
71064: LD_EXP 80
71068: PUSH
71069: LD_VAR 0 2
71073: ARRAY
71074: NOT
71075: AND
71076: PUSH
71077: LD_EXP 58
71081: PUSH
71082: LD_VAR 0 2
71086: ARRAY
71087: PPUSH
71088: LD_INT 30
71090: PUSH
71091: LD_INT 32
71093: PUSH
71094: EMPTY
71095: LIST
71096: LIST
71097: PPUSH
71098: CALL_OW 72
71102: NOT
71103: AND
71104: PUSH
71105: LD_EXP 58
71109: PUSH
71110: LD_VAR 0 2
71114: ARRAY
71115: PPUSH
71116: LD_INT 2
71118: PUSH
71119: LD_INT 30
71121: PUSH
71122: LD_INT 4
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 30
71131: PUSH
71132: LD_INT 5
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: LIST
71143: PPUSH
71144: CALL_OW 72
71148: NOT
71149: AND
71150: IFFALSE 71282
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71152: LD_ADDR_VAR 0 4
71156: PUSH
71157: LD_EXP 58
71161: PUSH
71162: LD_VAR 0 2
71166: ARRAY
71167: PPUSH
71168: LD_INT 2
71170: PUSH
71171: LD_INT 25
71173: PUSH
71174: LD_INT 1
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 25
71183: PUSH
71184: LD_INT 5
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 25
71193: PUSH
71194: LD_INT 8
71196: PUSH
71197: EMPTY
71198: LIST
71199: LIST
71200: PUSH
71201: LD_INT 25
71203: PUSH
71204: LD_INT 9
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: EMPTY
71212: LIST
71213: LIST
71214: LIST
71215: LIST
71216: LIST
71217: PPUSH
71218: CALL_OW 72
71222: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71223: LD_ADDR_VAR 0 4
71227: PUSH
71228: LD_VAR 0 4
71232: PUSH
71233: LD_VAR 0 4
71237: PPUSH
71238: LD_INT 18
71240: PPUSH
71241: CALL 53750 0 2
71245: DIFF
71246: ST_TO_ADDR
// if tmp then
71247: LD_VAR 0 4
71251: IFFALSE 71282
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
71253: LD_VAR 0 2
71257: PPUSH
71258: LD_VAR 0 4
71262: PPUSH
71263: LD_EXP 83
71267: PUSH
71268: LD_VAR 0 2
71272: ARRAY
71273: PPUSH
71274: CALL 15452 0 3
// exit ;
71278: POP
71279: POP
71280: GO 71377
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
71282: LD_EXP 81
71286: PUSH
71287: LD_VAR 0 2
71291: ARRAY
71292: PUSH
71293: LD_EXP 80
71297: PUSH
71298: LD_VAR 0 2
71302: ARRAY
71303: AND
71304: IFFALSE 71373
// begin tmp := mc_defender [ i ] ;
71306: LD_ADDR_VAR 0 4
71310: PUSH
71311: LD_EXP 80
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71322: LD_ADDR_EXP 80
71326: PUSH
71327: LD_EXP 80
71331: PPUSH
71332: LD_VAR 0 2
71336: PPUSH
71337: EMPTY
71338: PPUSH
71339: CALL_OW 1
71343: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
71344: LD_VAR 0 2
71348: PPUSH
71349: LD_VAR 0 4
71353: PPUSH
71354: LD_EXP 81
71358: PUSH
71359: LD_VAR 0 2
71363: ARRAY
71364: PPUSH
71365: CALL 15950 0 3
// exit ;
71369: POP
71370: POP
71371: GO 71377
// end ; end ;
71373: GO 70788
71375: POP
71376: POP
// end ;
71377: LD_VAR 0 1
71381: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71382: LD_INT 0
71384: PPUSH
71385: PPUSH
71386: PPUSH
71387: PPUSH
71388: PPUSH
71389: PPUSH
71390: PPUSH
71391: PPUSH
71392: PPUSH
71393: PPUSH
71394: PPUSH
// if not mc_bases then
71395: LD_EXP 58
71399: NOT
71400: IFFALSE 71404
// exit ;
71402: GO 72491
// for i = 1 to mc_bases do
71404: LD_ADDR_VAR 0 2
71408: PUSH
71409: DOUBLE
71410: LD_INT 1
71412: DEC
71413: ST_TO_ADDR
71414: LD_EXP 58
71418: PUSH
71419: FOR_TO
71420: IFFALSE 72489
// begin tmp := mc_lab [ i ] ;
71422: LD_ADDR_VAR 0 6
71426: PUSH
71427: LD_EXP 91
71431: PUSH
71432: LD_VAR 0 2
71436: ARRAY
71437: ST_TO_ADDR
// if not tmp then
71438: LD_VAR 0 6
71442: NOT
71443: IFFALSE 71447
// continue ;
71445: GO 71419
// idle_lab := 0 ;
71447: LD_ADDR_VAR 0 11
71451: PUSH
71452: LD_INT 0
71454: ST_TO_ADDR
// for j in tmp do
71455: LD_ADDR_VAR 0 3
71459: PUSH
71460: LD_VAR 0 6
71464: PUSH
71465: FOR_IN
71466: IFFALSE 72485
// begin researching := false ;
71468: LD_ADDR_VAR 0 10
71472: PUSH
71473: LD_INT 0
71475: ST_TO_ADDR
// side := GetSide ( j ) ;
71476: LD_ADDR_VAR 0 4
71480: PUSH
71481: LD_VAR 0 3
71485: PPUSH
71486: CALL_OW 255
71490: ST_TO_ADDR
// if not mc_tech [ side ] then
71491: LD_EXP 85
71495: PUSH
71496: LD_VAR 0 4
71500: ARRAY
71501: NOT
71502: IFFALSE 71506
// continue ;
71504: GO 71465
// if BuildingStatus ( j ) = bs_idle then
71506: LD_VAR 0 3
71510: PPUSH
71511: CALL_OW 461
71515: PUSH
71516: LD_INT 2
71518: EQUAL
71519: IFFALSE 71707
// begin if idle_lab and UnitsInside ( j ) < 6 then
71521: LD_VAR 0 11
71525: PUSH
71526: LD_VAR 0 3
71530: PPUSH
71531: CALL_OW 313
71535: PUSH
71536: LD_INT 6
71538: LESS
71539: AND
71540: IFFALSE 71611
// begin tmp2 := UnitsInside ( idle_lab ) ;
71542: LD_ADDR_VAR 0 9
71546: PUSH
71547: LD_VAR 0 11
71551: PPUSH
71552: CALL_OW 313
71556: ST_TO_ADDR
// if tmp2 then
71557: LD_VAR 0 9
71561: IFFALSE 71603
// for x in tmp2 do
71563: LD_ADDR_VAR 0 7
71567: PUSH
71568: LD_VAR 0 9
71572: PUSH
71573: FOR_IN
71574: IFFALSE 71601
// begin ComExitBuilding ( x ) ;
71576: LD_VAR 0 7
71580: PPUSH
71581: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71585: LD_VAR 0 7
71589: PPUSH
71590: LD_VAR 0 3
71594: PPUSH
71595: CALL_OW 180
// end ;
71599: GO 71573
71601: POP
71602: POP
// idle_lab := 0 ;
71603: LD_ADDR_VAR 0 11
71607: PUSH
71608: LD_INT 0
71610: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71611: LD_ADDR_VAR 0 5
71615: PUSH
71616: LD_EXP 85
71620: PUSH
71621: LD_VAR 0 4
71625: ARRAY
71626: PUSH
71627: FOR_IN
71628: IFFALSE 71688
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71630: LD_VAR 0 3
71634: PPUSH
71635: LD_VAR 0 5
71639: PPUSH
71640: CALL_OW 430
71644: PUSH
71645: LD_VAR 0 4
71649: PPUSH
71650: LD_VAR 0 5
71654: PPUSH
71655: CALL 14522 0 2
71659: AND
71660: IFFALSE 71686
// begin researching := true ;
71662: LD_ADDR_VAR 0 10
71666: PUSH
71667: LD_INT 1
71669: ST_TO_ADDR
// ComResearch ( j , t ) ;
71670: LD_VAR 0 3
71674: PPUSH
71675: LD_VAR 0 5
71679: PPUSH
71680: CALL_OW 124
// break ;
71684: GO 71688
// end ;
71686: GO 71627
71688: POP
71689: POP
// if not researching then
71690: LD_VAR 0 10
71694: NOT
71695: IFFALSE 71707
// idle_lab := j ;
71697: LD_ADDR_VAR 0 11
71701: PUSH
71702: LD_VAR 0 3
71706: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71707: LD_VAR 0 3
71711: PPUSH
71712: CALL_OW 461
71716: PUSH
71717: LD_INT 10
71719: EQUAL
71720: IFFALSE 72308
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71722: LD_EXP 87
71726: PUSH
71727: LD_VAR 0 2
71731: ARRAY
71732: NOT
71733: PUSH
71734: LD_EXP 88
71738: PUSH
71739: LD_VAR 0 2
71743: ARRAY
71744: NOT
71745: AND
71746: PUSH
71747: LD_EXP 85
71751: PUSH
71752: LD_VAR 0 4
71756: ARRAY
71757: PUSH
71758: LD_INT 1
71760: GREATER
71761: AND
71762: IFFALSE 71893
// begin ComCancel ( j ) ;
71764: LD_VAR 0 3
71768: PPUSH
71769: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71773: LD_ADDR_EXP 85
71777: PUSH
71778: LD_EXP 85
71782: PPUSH
71783: LD_VAR 0 4
71787: PPUSH
71788: LD_EXP 85
71792: PUSH
71793: LD_VAR 0 4
71797: ARRAY
71798: PPUSH
71799: LD_EXP 85
71803: PUSH
71804: LD_VAR 0 4
71808: ARRAY
71809: PUSH
71810: LD_INT 1
71812: MINUS
71813: PPUSH
71814: LD_EXP 85
71818: PUSH
71819: LD_VAR 0 4
71823: ARRAY
71824: PPUSH
71825: LD_INT 0
71827: PPUSH
71828: CALL 19971 0 4
71832: PPUSH
71833: CALL_OW 1
71837: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71838: LD_ADDR_EXP 85
71842: PUSH
71843: LD_EXP 85
71847: PPUSH
71848: LD_VAR 0 4
71852: PPUSH
71853: LD_EXP 85
71857: PUSH
71858: LD_VAR 0 4
71862: ARRAY
71863: PPUSH
71864: LD_EXP 85
71868: PUSH
71869: LD_VAR 0 4
71873: ARRAY
71874: PPUSH
71875: LD_INT 1
71877: PPUSH
71878: LD_INT 0
71880: PPUSH
71881: CALL 19971 0 4
71885: PPUSH
71886: CALL_OW 1
71890: ST_TO_ADDR
// continue ;
71891: GO 71465
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71893: LD_EXP 87
71897: PUSH
71898: LD_VAR 0 2
71902: ARRAY
71903: PUSH
71904: LD_EXP 88
71908: PUSH
71909: LD_VAR 0 2
71913: ARRAY
71914: NOT
71915: AND
71916: IFFALSE 72043
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71918: LD_ADDR_EXP 88
71922: PUSH
71923: LD_EXP 88
71927: PPUSH
71928: LD_VAR 0 2
71932: PUSH
71933: LD_EXP 88
71937: PUSH
71938: LD_VAR 0 2
71942: ARRAY
71943: PUSH
71944: LD_INT 1
71946: PLUS
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PPUSH
71952: LD_EXP 87
71956: PUSH
71957: LD_VAR 0 2
71961: ARRAY
71962: PUSH
71963: LD_INT 1
71965: ARRAY
71966: PPUSH
71967: CALL 20553 0 3
71971: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71972: LD_EXP 87
71976: PUSH
71977: LD_VAR 0 2
71981: ARRAY
71982: PUSH
71983: LD_INT 1
71985: ARRAY
71986: PPUSH
71987: LD_INT 112
71989: PPUSH
71990: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71994: LD_ADDR_VAR 0 9
71998: PUSH
71999: LD_EXP 87
72003: PUSH
72004: LD_VAR 0 2
72008: ARRAY
72009: PPUSH
72010: LD_INT 1
72012: PPUSH
72013: CALL_OW 3
72017: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72018: LD_ADDR_EXP 87
72022: PUSH
72023: LD_EXP 87
72027: PPUSH
72028: LD_VAR 0 2
72032: PPUSH
72033: LD_VAR 0 9
72037: PPUSH
72038: CALL_OW 1
72042: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72043: LD_EXP 87
72047: PUSH
72048: LD_VAR 0 2
72052: ARRAY
72053: PUSH
72054: LD_EXP 88
72058: PUSH
72059: LD_VAR 0 2
72063: ARRAY
72064: AND
72065: PUSH
72066: LD_EXP 88
72070: PUSH
72071: LD_VAR 0 2
72075: ARRAY
72076: PUSH
72077: LD_INT 1
72079: ARRAY
72080: PPUSH
72081: CALL_OW 310
72085: NOT
72086: AND
72087: PUSH
72088: LD_VAR 0 3
72092: PPUSH
72093: CALL_OW 313
72097: PUSH
72098: LD_INT 6
72100: EQUAL
72101: AND
72102: IFFALSE 72158
// begin tmp2 := UnitsInside ( j ) ;
72104: LD_ADDR_VAR 0 9
72108: PUSH
72109: LD_VAR 0 3
72113: PPUSH
72114: CALL_OW 313
72118: ST_TO_ADDR
// if tmp2 = 6 then
72119: LD_VAR 0 9
72123: PUSH
72124: LD_INT 6
72126: EQUAL
72127: IFFALSE 72158
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72129: LD_VAR 0 9
72133: PUSH
72134: LD_INT 1
72136: ARRAY
72137: PPUSH
72138: LD_INT 112
72140: PPUSH
72141: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72145: LD_VAR 0 9
72149: PUSH
72150: LD_INT 1
72152: ARRAY
72153: PPUSH
72154: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72158: LD_EXP 88
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PUSH
72169: LD_EXP 88
72173: PUSH
72174: LD_VAR 0 2
72178: ARRAY
72179: PUSH
72180: LD_INT 1
72182: ARRAY
72183: PPUSH
72184: CALL_OW 314
72188: NOT
72189: AND
72190: PUSH
72191: LD_EXP 88
72195: PUSH
72196: LD_VAR 0 2
72200: ARRAY
72201: PUSH
72202: LD_INT 1
72204: ARRAY
72205: PPUSH
72206: CALL_OW 310
72210: NOT
72211: AND
72212: IFFALSE 72238
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72214: LD_EXP 88
72218: PUSH
72219: LD_VAR 0 2
72223: ARRAY
72224: PUSH
72225: LD_INT 1
72227: ARRAY
72228: PPUSH
72229: LD_VAR 0 3
72233: PPUSH
72234: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72238: LD_EXP 88
72242: PUSH
72243: LD_VAR 0 2
72247: ARRAY
72248: PUSH
72249: LD_INT 1
72251: ARRAY
72252: PPUSH
72253: CALL_OW 310
72257: PUSH
72258: LD_EXP 88
72262: PUSH
72263: LD_VAR 0 2
72267: ARRAY
72268: PUSH
72269: LD_INT 1
72271: ARRAY
72272: PPUSH
72273: CALL_OW 310
72277: PPUSH
72278: CALL_OW 461
72282: PUSH
72283: LD_INT 3
72285: NONEQUAL
72286: AND
72287: IFFALSE 72308
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72289: LD_EXP 88
72293: PUSH
72294: LD_VAR 0 2
72298: ARRAY
72299: PUSH
72300: LD_INT 1
72302: ARRAY
72303: PPUSH
72304: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72308: LD_VAR 0 3
72312: PPUSH
72313: CALL_OW 461
72317: PUSH
72318: LD_INT 6
72320: EQUAL
72321: PUSH
72322: LD_VAR 0 6
72326: PUSH
72327: LD_INT 1
72329: GREATER
72330: AND
72331: IFFALSE 72483
// begin sci := [ ] ;
72333: LD_ADDR_VAR 0 8
72337: PUSH
72338: EMPTY
72339: ST_TO_ADDR
// for x in ( tmp diff j ) do
72340: LD_ADDR_VAR 0 7
72344: PUSH
72345: LD_VAR 0 6
72349: PUSH
72350: LD_VAR 0 3
72354: DIFF
72355: PUSH
72356: FOR_IN
72357: IFFALSE 72409
// begin if sci = 6 then
72359: LD_VAR 0 8
72363: PUSH
72364: LD_INT 6
72366: EQUAL
72367: IFFALSE 72371
// break ;
72369: GO 72409
// if BuildingStatus ( x ) = bs_idle then
72371: LD_VAR 0 7
72375: PPUSH
72376: CALL_OW 461
72380: PUSH
72381: LD_INT 2
72383: EQUAL
72384: IFFALSE 72407
// sci := sci ^ UnitsInside ( x ) ;
72386: LD_ADDR_VAR 0 8
72390: PUSH
72391: LD_VAR 0 8
72395: PUSH
72396: LD_VAR 0 7
72400: PPUSH
72401: CALL_OW 313
72405: ADD
72406: ST_TO_ADDR
// end ;
72407: GO 72356
72409: POP
72410: POP
// if not sci then
72411: LD_VAR 0 8
72415: NOT
72416: IFFALSE 72420
// continue ;
72418: GO 71465
// for x in sci do
72420: LD_ADDR_VAR 0 7
72424: PUSH
72425: LD_VAR 0 8
72429: PUSH
72430: FOR_IN
72431: IFFALSE 72481
// if IsInUnit ( x ) and not HasTask ( x ) then
72433: LD_VAR 0 7
72437: PPUSH
72438: CALL_OW 310
72442: PUSH
72443: LD_VAR 0 7
72447: PPUSH
72448: CALL_OW 314
72452: NOT
72453: AND
72454: IFFALSE 72479
// begin ComExitBuilding ( x ) ;
72456: LD_VAR 0 7
72460: PPUSH
72461: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72465: LD_VAR 0 7
72469: PPUSH
72470: LD_VAR 0 3
72474: PPUSH
72475: CALL_OW 180
// end ;
72479: GO 72430
72481: POP
72482: POP
// end ; end ;
72483: GO 71465
72485: POP
72486: POP
// end ;
72487: GO 71419
72489: POP
72490: POP
// end ;
72491: LD_VAR 0 1
72495: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72496: LD_INT 0
72498: PPUSH
72499: PPUSH
// if not mc_bases then
72500: LD_EXP 58
72504: NOT
72505: IFFALSE 72509
// exit ;
72507: GO 72590
// for i = 1 to mc_bases do
72509: LD_ADDR_VAR 0 2
72513: PUSH
72514: DOUBLE
72515: LD_INT 1
72517: DEC
72518: ST_TO_ADDR
72519: LD_EXP 58
72523: PUSH
72524: FOR_TO
72525: IFFALSE 72588
// if mc_mines [ i ] and mc_miners [ i ] then
72527: LD_EXP 71
72531: PUSH
72532: LD_VAR 0 2
72536: ARRAY
72537: PUSH
72538: LD_EXP 72
72542: PUSH
72543: LD_VAR 0 2
72547: ARRAY
72548: AND
72549: IFFALSE 72586
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72551: LD_EXP 72
72555: PUSH
72556: LD_VAR 0 2
72560: ARRAY
72561: PUSH
72562: LD_INT 1
72564: ARRAY
72565: PPUSH
72566: CALL_OW 255
72570: PPUSH
72571: LD_EXP 71
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: PPUSH
72582: CALL 17610 0 2
72586: GO 72524
72588: POP
72589: POP
// end ;
72590: LD_VAR 0 1
72594: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72595: LD_INT 0
72597: PPUSH
72598: PPUSH
72599: PPUSH
72600: PPUSH
72601: PPUSH
72602: PPUSH
72603: PPUSH
72604: PPUSH
// if not mc_bases or not mc_parking then
72605: LD_EXP 58
72609: NOT
72610: PUSH
72611: LD_EXP 82
72615: NOT
72616: OR
72617: IFFALSE 72621
// exit ;
72619: GO 73333
// for i = 1 to mc_bases do
72621: LD_ADDR_VAR 0 2
72625: PUSH
72626: DOUBLE
72627: LD_INT 1
72629: DEC
72630: ST_TO_ADDR
72631: LD_EXP 58
72635: PUSH
72636: FOR_TO
72637: IFFALSE 73331
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72639: LD_EXP 58
72643: PUSH
72644: LD_VAR 0 2
72648: ARRAY
72649: NOT
72650: PUSH
72651: LD_EXP 82
72655: PUSH
72656: LD_VAR 0 2
72660: ARRAY
72661: NOT
72662: OR
72663: IFFALSE 72667
// continue ;
72665: GO 72636
// if mc_scan [ i ] then
72667: LD_EXP 81
72671: PUSH
72672: LD_VAR 0 2
72676: ARRAY
72677: IFFALSE 72703
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72679: LD_ADDR_EXP 70
72683: PUSH
72684: LD_EXP 70
72688: PPUSH
72689: LD_VAR 0 2
72693: PPUSH
72694: EMPTY
72695: PPUSH
72696: CALL_OW 1
72700: ST_TO_ADDR
// continue ;
72701: GO 72636
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72703: LD_ADDR_VAR 0 5
72707: PUSH
72708: LD_EXP 58
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: PUSH
72719: LD_INT 1
72721: ARRAY
72722: PPUSH
72723: CALL_OW 255
72727: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72728: LD_ADDR_VAR 0 6
72732: PUSH
72733: LD_EXP 58
72737: PUSH
72738: LD_VAR 0 2
72742: ARRAY
72743: PPUSH
72744: LD_INT 30
72746: PUSH
72747: LD_INT 3
72749: PUSH
72750: EMPTY
72751: LIST
72752: LIST
72753: PPUSH
72754: CALL_OW 72
72758: ST_TO_ADDR
// if not fac then
72759: LD_VAR 0 6
72763: NOT
72764: IFFALSE 72815
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72766: LD_ADDR_VAR 0 6
72770: PUSH
72771: LD_EXP 58
72775: PUSH
72776: LD_VAR 0 2
72780: ARRAY
72781: PPUSH
72782: LD_INT 2
72784: PUSH
72785: LD_INT 30
72787: PUSH
72788: LD_INT 0
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: PUSH
72795: LD_INT 30
72797: PUSH
72798: LD_INT 1
72800: PUSH
72801: EMPTY
72802: LIST
72803: LIST
72804: PUSH
72805: EMPTY
72806: LIST
72807: LIST
72808: LIST
72809: PPUSH
72810: CALL_OW 72
72814: ST_TO_ADDR
// if not fac then
72815: LD_VAR 0 6
72819: NOT
72820: IFFALSE 72824
// continue ;
72822: GO 72636
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72824: LD_ADDR_VAR 0 7
72828: PUSH
72829: LD_EXP 82
72833: PUSH
72834: LD_VAR 0 2
72838: ARRAY
72839: PPUSH
72840: LD_INT 22
72842: PUSH
72843: LD_VAR 0 5
72847: PUSH
72848: EMPTY
72849: LIST
72850: LIST
72851: PUSH
72852: LD_INT 21
72854: PUSH
72855: LD_INT 2
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 3
72864: PUSH
72865: LD_INT 24
72867: PUSH
72868: LD_INT 1000
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: EMPTY
72876: LIST
72877: LIST
72878: PUSH
72879: EMPTY
72880: LIST
72881: LIST
72882: LIST
72883: PPUSH
72884: CALL_OW 70
72888: PUSH
72889: LD_INT 22
72891: PUSH
72892: LD_VAR 0 5
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: LD_INT 91
72903: PUSH
72904: LD_VAR 0 6
72908: PUSH
72909: LD_INT 1
72911: ARRAY
72912: PUSH
72913: LD_INT 25
72915: PUSH
72916: EMPTY
72917: LIST
72918: LIST
72919: LIST
72920: PUSH
72921: LD_INT 21
72923: PUSH
72924: LD_INT 2
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: LD_INT 3
72933: PUSH
72934: LD_INT 24
72936: PUSH
72937: LD_INT 1000
72939: PUSH
72940: EMPTY
72941: LIST
72942: LIST
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: LIST
72952: LIST
72953: PPUSH
72954: CALL_OW 69
72958: UNION
72959: ST_TO_ADDR
// if not vehs then
72960: LD_VAR 0 7
72964: NOT
72965: IFFALSE 72991
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72967: LD_ADDR_EXP 70
72971: PUSH
72972: LD_EXP 70
72976: PPUSH
72977: LD_VAR 0 2
72981: PPUSH
72982: EMPTY
72983: PPUSH
72984: CALL_OW 1
72988: ST_TO_ADDR
// continue ;
72989: GO 72636
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72991: LD_ADDR_VAR 0 8
72995: PUSH
72996: LD_EXP 58
73000: PUSH
73001: LD_VAR 0 2
73005: ARRAY
73006: PPUSH
73007: LD_INT 30
73009: PUSH
73010: LD_INT 3
73012: PUSH
73013: EMPTY
73014: LIST
73015: LIST
73016: PPUSH
73017: CALL_OW 72
73021: ST_TO_ADDR
// if tmp then
73022: LD_VAR 0 8
73026: IFFALSE 73129
// begin for j in tmp do
73028: LD_ADDR_VAR 0 3
73032: PUSH
73033: LD_VAR 0 8
73037: PUSH
73038: FOR_IN
73039: IFFALSE 73127
// for k in UnitsInside ( j ) do
73041: LD_ADDR_VAR 0 4
73045: PUSH
73046: LD_VAR 0 3
73050: PPUSH
73051: CALL_OW 313
73055: PUSH
73056: FOR_IN
73057: IFFALSE 73123
// if k then
73059: LD_VAR 0 4
73063: IFFALSE 73121
// if not k in mc_repair_vehicle [ i ] then
73065: LD_VAR 0 4
73069: PUSH
73070: LD_EXP 70
73074: PUSH
73075: LD_VAR 0 2
73079: ARRAY
73080: IN
73081: NOT
73082: IFFALSE 73121
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73084: LD_ADDR_EXP 70
73088: PUSH
73089: LD_EXP 70
73093: PPUSH
73094: LD_VAR 0 2
73098: PPUSH
73099: LD_EXP 70
73103: PUSH
73104: LD_VAR 0 2
73108: ARRAY
73109: PUSH
73110: LD_VAR 0 4
73114: UNION
73115: PPUSH
73116: CALL_OW 1
73120: ST_TO_ADDR
73121: GO 73056
73123: POP
73124: POP
73125: GO 73038
73127: POP
73128: POP
// end ; if not mc_repair_vehicle [ i ] then
73129: LD_EXP 70
73133: PUSH
73134: LD_VAR 0 2
73138: ARRAY
73139: NOT
73140: IFFALSE 73144
// continue ;
73142: GO 72636
// for j in mc_repair_vehicle [ i ] do
73144: LD_ADDR_VAR 0 3
73148: PUSH
73149: LD_EXP 70
73153: PUSH
73154: LD_VAR 0 2
73158: ARRAY
73159: PUSH
73160: FOR_IN
73161: IFFALSE 73327
// begin if GetClass ( j ) <> 3 then
73163: LD_VAR 0 3
73167: PPUSH
73168: CALL_OW 257
73172: PUSH
73173: LD_INT 3
73175: NONEQUAL
73176: IFFALSE 73217
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73178: LD_ADDR_EXP 70
73182: PUSH
73183: LD_EXP 70
73187: PPUSH
73188: LD_VAR 0 2
73192: PPUSH
73193: LD_EXP 70
73197: PUSH
73198: LD_VAR 0 2
73202: ARRAY
73203: PUSH
73204: LD_VAR 0 3
73208: DIFF
73209: PPUSH
73210: CALL_OW 1
73214: ST_TO_ADDR
// continue ;
73215: GO 73160
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73217: LD_VAR 0 3
73221: PPUSH
73222: CALL_OW 311
73226: NOT
73227: PUSH
73228: LD_VAR 0 3
73232: PUSH
73233: LD_EXP 61
73237: PUSH
73238: LD_VAR 0 2
73242: ARRAY
73243: PUSH
73244: LD_INT 1
73246: ARRAY
73247: IN
73248: NOT
73249: AND
73250: PUSH
73251: LD_VAR 0 3
73255: PUSH
73256: LD_EXP 61
73260: PUSH
73261: LD_VAR 0 2
73265: ARRAY
73266: PUSH
73267: LD_INT 2
73269: ARRAY
73270: IN
73271: NOT
73272: AND
73273: IFFALSE 73325
// begin if IsInUnit ( j ) then
73275: LD_VAR 0 3
73279: PPUSH
73280: CALL_OW 310
73284: IFFALSE 73295
// ComExitBuilding ( j ) ;
73286: LD_VAR 0 3
73290: PPUSH
73291: CALL_OW 122
// if not HasTask ( j ) then
73295: LD_VAR 0 3
73299: PPUSH
73300: CALL_OW 314
73304: NOT
73305: IFFALSE 73325
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
73307: LD_VAR 0 3
73311: PPUSH
73312: LD_VAR 0 7
73316: PUSH
73317: LD_INT 1
73319: ARRAY
73320: PPUSH
73321: CALL_OW 189
// end ; end ;
73325: GO 73160
73327: POP
73328: POP
// end ;
73329: GO 72636
73331: POP
73332: POP
// end ;
73333: LD_VAR 0 1
73337: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73338: LD_INT 0
73340: PPUSH
73341: PPUSH
73342: PPUSH
73343: PPUSH
73344: PPUSH
73345: PPUSH
73346: PPUSH
73347: PPUSH
73348: PPUSH
73349: PPUSH
73350: PPUSH
// if not mc_bases then
73351: LD_EXP 58
73355: NOT
73356: IFFALSE 73360
// exit ;
73358: GO 74162
// for i = 1 to mc_bases do
73360: LD_ADDR_VAR 0 2
73364: PUSH
73365: DOUBLE
73366: LD_INT 1
73368: DEC
73369: ST_TO_ADDR
73370: LD_EXP 58
73374: PUSH
73375: FOR_TO
73376: IFFALSE 74160
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73378: LD_EXP 86
73382: PUSH
73383: LD_VAR 0 2
73387: ARRAY
73388: NOT
73389: PUSH
73390: LD_EXP 61
73394: PUSH
73395: LD_VAR 0 2
73399: ARRAY
73400: PUSH
73401: LD_INT 1
73403: ARRAY
73404: OR
73405: PUSH
73406: LD_EXP 61
73410: PUSH
73411: LD_VAR 0 2
73415: ARRAY
73416: PUSH
73417: LD_INT 2
73419: ARRAY
73420: OR
73421: PUSH
73422: LD_EXP 84
73426: PUSH
73427: LD_VAR 0 2
73431: ARRAY
73432: PPUSH
73433: LD_INT 1
73435: PPUSH
73436: CALL_OW 325
73440: NOT
73441: OR
73442: PUSH
73443: LD_EXP 81
73447: PUSH
73448: LD_VAR 0 2
73452: ARRAY
73453: OR
73454: IFFALSE 73458
// continue ;
73456: GO 73375
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73458: LD_ADDR_VAR 0 8
73462: PUSH
73463: LD_EXP 58
73467: PUSH
73468: LD_VAR 0 2
73472: ARRAY
73473: PPUSH
73474: LD_INT 25
73476: PUSH
73477: LD_INT 4
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 50
73486: PUSH
73487: EMPTY
73488: LIST
73489: PUSH
73490: LD_INT 3
73492: PUSH
73493: LD_INT 60
73495: PUSH
73496: EMPTY
73497: LIST
73498: PUSH
73499: EMPTY
73500: LIST
73501: LIST
73502: PUSH
73503: EMPTY
73504: LIST
73505: LIST
73506: LIST
73507: PPUSH
73508: CALL_OW 72
73512: PUSH
73513: LD_EXP 62
73517: PUSH
73518: LD_VAR 0 2
73522: ARRAY
73523: DIFF
73524: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73525: LD_ADDR_VAR 0 9
73529: PUSH
73530: LD_EXP 58
73534: PUSH
73535: LD_VAR 0 2
73539: ARRAY
73540: PPUSH
73541: LD_INT 2
73543: PUSH
73544: LD_INT 30
73546: PUSH
73547: LD_INT 0
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 30
73556: PUSH
73557: LD_INT 1
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: EMPTY
73565: LIST
73566: LIST
73567: LIST
73568: PPUSH
73569: CALL_OW 72
73573: ST_TO_ADDR
// if not tmp or not dep then
73574: LD_VAR 0 8
73578: NOT
73579: PUSH
73580: LD_VAR 0 9
73584: NOT
73585: OR
73586: IFFALSE 73590
// continue ;
73588: GO 73375
// side := GetSide ( tmp [ 1 ] ) ;
73590: LD_ADDR_VAR 0 11
73594: PUSH
73595: LD_VAR 0 8
73599: PUSH
73600: LD_INT 1
73602: ARRAY
73603: PPUSH
73604: CALL_OW 255
73608: ST_TO_ADDR
// dep := dep [ 1 ] ;
73609: LD_ADDR_VAR 0 9
73613: PUSH
73614: LD_VAR 0 9
73618: PUSH
73619: LD_INT 1
73621: ARRAY
73622: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73623: LD_ADDR_VAR 0 7
73627: PUSH
73628: LD_EXP 86
73632: PUSH
73633: LD_VAR 0 2
73637: ARRAY
73638: PPUSH
73639: LD_INT 22
73641: PUSH
73642: LD_INT 0
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 25
73651: PUSH
73652: LD_INT 12
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PPUSH
73663: CALL_OW 70
73667: PUSH
73668: LD_INT 22
73670: PUSH
73671: LD_INT 0
73673: PUSH
73674: EMPTY
73675: LIST
73676: LIST
73677: PUSH
73678: LD_INT 25
73680: PUSH
73681: LD_INT 12
73683: PUSH
73684: EMPTY
73685: LIST
73686: LIST
73687: PUSH
73688: LD_INT 91
73690: PUSH
73691: LD_VAR 0 9
73695: PUSH
73696: LD_INT 20
73698: PUSH
73699: EMPTY
73700: LIST
73701: LIST
73702: LIST
73703: PUSH
73704: EMPTY
73705: LIST
73706: LIST
73707: LIST
73708: PPUSH
73709: CALL_OW 69
73713: UNION
73714: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73715: LD_ADDR_VAR 0 10
73719: PUSH
73720: LD_EXP 86
73724: PUSH
73725: LD_VAR 0 2
73729: ARRAY
73730: PPUSH
73731: LD_INT 81
73733: PUSH
73734: LD_VAR 0 11
73738: PUSH
73739: EMPTY
73740: LIST
73741: LIST
73742: PPUSH
73743: CALL_OW 70
73747: ST_TO_ADDR
// if not apes or danger_at_area then
73748: LD_VAR 0 7
73752: NOT
73753: PUSH
73754: LD_VAR 0 10
73758: OR
73759: IFFALSE 73809
// begin if mc_taming [ i ] then
73761: LD_EXP 89
73765: PUSH
73766: LD_VAR 0 2
73770: ARRAY
73771: IFFALSE 73807
// begin MC_Reset ( i , 121 ) ;
73773: LD_VAR 0 2
73777: PPUSH
73778: LD_INT 121
73780: PPUSH
73781: CALL 59444 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73785: LD_ADDR_EXP 89
73789: PUSH
73790: LD_EXP 89
73794: PPUSH
73795: LD_VAR 0 2
73799: PPUSH
73800: EMPTY
73801: PPUSH
73802: CALL_OW 1
73806: ST_TO_ADDR
// end ; continue ;
73807: GO 73375
// end ; for j in tmp do
73809: LD_ADDR_VAR 0 3
73813: PUSH
73814: LD_VAR 0 8
73818: PUSH
73819: FOR_IN
73820: IFFALSE 74156
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73822: LD_VAR 0 3
73826: PUSH
73827: LD_EXP 89
73831: PUSH
73832: LD_VAR 0 2
73836: ARRAY
73837: IN
73838: NOT
73839: PUSH
73840: LD_EXP 89
73844: PUSH
73845: LD_VAR 0 2
73849: ARRAY
73850: PUSH
73851: LD_INT 3
73853: LESS
73854: AND
73855: IFFALSE 73913
// begin SetTag ( j , 121 ) ;
73857: LD_VAR 0 3
73861: PPUSH
73862: LD_INT 121
73864: PPUSH
73865: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73869: LD_ADDR_EXP 89
73873: PUSH
73874: LD_EXP 89
73878: PPUSH
73879: LD_VAR 0 2
73883: PUSH
73884: LD_EXP 89
73888: PUSH
73889: LD_VAR 0 2
73893: ARRAY
73894: PUSH
73895: LD_INT 1
73897: PLUS
73898: PUSH
73899: EMPTY
73900: LIST
73901: LIST
73902: PPUSH
73903: LD_VAR 0 3
73907: PPUSH
73908: CALL 20553 0 3
73912: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73913: LD_VAR 0 3
73917: PUSH
73918: LD_EXP 89
73922: PUSH
73923: LD_VAR 0 2
73927: ARRAY
73928: IN
73929: IFFALSE 74154
// begin if GetClass ( j ) <> 4 then
73931: LD_VAR 0 3
73935: PPUSH
73936: CALL_OW 257
73940: PUSH
73941: LD_INT 4
73943: NONEQUAL
73944: IFFALSE 73997
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73946: LD_ADDR_EXP 89
73950: PUSH
73951: LD_EXP 89
73955: PPUSH
73956: LD_VAR 0 2
73960: PPUSH
73961: LD_EXP 89
73965: PUSH
73966: LD_VAR 0 2
73970: ARRAY
73971: PUSH
73972: LD_VAR 0 3
73976: DIFF
73977: PPUSH
73978: CALL_OW 1
73982: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73983: LD_VAR 0 3
73987: PPUSH
73988: LD_INT 0
73990: PPUSH
73991: CALL_OW 109
// continue ;
73995: GO 73819
// end ; if IsInUnit ( j ) then
73997: LD_VAR 0 3
74001: PPUSH
74002: CALL_OW 310
74006: IFFALSE 74017
// ComExitBuilding ( j ) ;
74008: LD_VAR 0 3
74012: PPUSH
74013: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74017: LD_ADDR_VAR 0 6
74021: PUSH
74022: LD_VAR 0 7
74026: PPUSH
74027: LD_VAR 0 3
74031: PPUSH
74032: CALL_OW 74
74036: ST_TO_ADDR
// if not ape then
74037: LD_VAR 0 6
74041: NOT
74042: IFFALSE 74046
// break ;
74044: GO 74156
// x := GetX ( ape ) ;
74046: LD_ADDR_VAR 0 4
74050: PUSH
74051: LD_VAR 0 6
74055: PPUSH
74056: CALL_OW 250
74060: ST_TO_ADDR
// y := GetY ( ape ) ;
74061: LD_ADDR_VAR 0 5
74065: PUSH
74066: LD_VAR 0 6
74070: PPUSH
74071: CALL_OW 251
74075: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74076: LD_VAR 0 4
74080: PPUSH
74081: LD_VAR 0 5
74085: PPUSH
74086: CALL_OW 488
74090: NOT
74091: PUSH
74092: LD_VAR 0 11
74096: PPUSH
74097: LD_VAR 0 4
74101: PPUSH
74102: LD_VAR 0 5
74106: PPUSH
74107: LD_INT 20
74109: PPUSH
74110: CALL 21449 0 4
74114: PUSH
74115: LD_INT 4
74117: ARRAY
74118: OR
74119: IFFALSE 74123
// break ;
74121: GO 74156
// if not HasTask ( j ) then
74123: LD_VAR 0 3
74127: PPUSH
74128: CALL_OW 314
74132: NOT
74133: IFFALSE 74154
// ComTameXY ( j , x , y ) ;
74135: LD_VAR 0 3
74139: PPUSH
74140: LD_VAR 0 4
74144: PPUSH
74145: LD_VAR 0 5
74149: PPUSH
74150: CALL_OW 131
// end ; end ;
74154: GO 73819
74156: POP
74157: POP
// end ;
74158: GO 73375
74160: POP
74161: POP
// end ;
74162: LD_VAR 0 1
74166: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74167: LD_INT 0
74169: PPUSH
74170: PPUSH
74171: PPUSH
74172: PPUSH
74173: PPUSH
74174: PPUSH
74175: PPUSH
74176: PPUSH
// if not mc_bases then
74177: LD_EXP 58
74181: NOT
74182: IFFALSE 74186
// exit ;
74184: GO 74812
// for i = 1 to mc_bases do
74186: LD_ADDR_VAR 0 2
74190: PUSH
74191: DOUBLE
74192: LD_INT 1
74194: DEC
74195: ST_TO_ADDR
74196: LD_EXP 58
74200: PUSH
74201: FOR_TO
74202: IFFALSE 74810
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74204: LD_EXP 87
74208: PUSH
74209: LD_VAR 0 2
74213: ARRAY
74214: NOT
74215: PUSH
74216: LD_EXP 87
74220: PUSH
74221: LD_VAR 0 2
74225: ARRAY
74226: PPUSH
74227: LD_INT 25
74229: PUSH
74230: LD_INT 12
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PPUSH
74237: CALL_OW 72
74241: NOT
74242: OR
74243: IFFALSE 74247
// continue ;
74245: GO 74201
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74247: LD_ADDR_VAR 0 5
74251: PUSH
74252: LD_EXP 87
74256: PUSH
74257: LD_VAR 0 2
74261: ARRAY
74262: PUSH
74263: LD_INT 1
74265: ARRAY
74266: PPUSH
74267: CALL_OW 255
74271: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74272: LD_VAR 0 5
74276: PPUSH
74277: LD_INT 2
74279: PPUSH
74280: CALL_OW 325
74284: IFFALSE 74537
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74286: LD_ADDR_VAR 0 4
74290: PUSH
74291: LD_EXP 87
74295: PUSH
74296: LD_VAR 0 2
74300: ARRAY
74301: PPUSH
74302: LD_INT 25
74304: PUSH
74305: LD_INT 16
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PPUSH
74312: CALL_OW 72
74316: ST_TO_ADDR
// if tmp < 6 then
74317: LD_VAR 0 4
74321: PUSH
74322: LD_INT 6
74324: LESS
74325: IFFALSE 74537
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74327: LD_ADDR_VAR 0 6
74331: PUSH
74332: LD_EXP 58
74336: PUSH
74337: LD_VAR 0 2
74341: ARRAY
74342: PPUSH
74343: LD_INT 2
74345: PUSH
74346: LD_INT 30
74348: PUSH
74349: LD_INT 0
74351: PUSH
74352: EMPTY
74353: LIST
74354: LIST
74355: PUSH
74356: LD_INT 30
74358: PUSH
74359: LD_INT 1
74361: PUSH
74362: EMPTY
74363: LIST
74364: LIST
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: LIST
74370: PPUSH
74371: CALL_OW 72
74375: ST_TO_ADDR
// if depot then
74376: LD_VAR 0 6
74380: IFFALSE 74537
// begin selected := 0 ;
74382: LD_ADDR_VAR 0 7
74386: PUSH
74387: LD_INT 0
74389: ST_TO_ADDR
// for j in depot do
74390: LD_ADDR_VAR 0 3
74394: PUSH
74395: LD_VAR 0 6
74399: PUSH
74400: FOR_IN
74401: IFFALSE 74432
// begin if UnitsInside ( j ) < 6 then
74403: LD_VAR 0 3
74407: PPUSH
74408: CALL_OW 313
74412: PUSH
74413: LD_INT 6
74415: LESS
74416: IFFALSE 74430
// begin selected := j ;
74418: LD_ADDR_VAR 0 7
74422: PUSH
74423: LD_VAR 0 3
74427: ST_TO_ADDR
// break ;
74428: GO 74432
// end ; end ;
74430: GO 74400
74432: POP
74433: POP
// if selected then
74434: LD_VAR 0 7
74438: IFFALSE 74537
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74440: LD_ADDR_VAR 0 3
74444: PUSH
74445: LD_EXP 87
74449: PUSH
74450: LD_VAR 0 2
74454: ARRAY
74455: PPUSH
74456: LD_INT 25
74458: PUSH
74459: LD_INT 12
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: PPUSH
74466: CALL_OW 72
74470: PUSH
74471: FOR_IN
74472: IFFALSE 74535
// if not HasTask ( j ) then
74474: LD_VAR 0 3
74478: PPUSH
74479: CALL_OW 314
74483: NOT
74484: IFFALSE 74533
// begin if not IsInUnit ( j ) then
74486: LD_VAR 0 3
74490: PPUSH
74491: CALL_OW 310
74495: NOT
74496: IFFALSE 74512
// ComEnterUnit ( j , selected ) ;
74498: LD_VAR 0 3
74502: PPUSH
74503: LD_VAR 0 7
74507: PPUSH
74508: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74512: LD_VAR 0 3
74516: PPUSH
74517: LD_INT 16
74519: PPUSH
74520: CALL_OW 183
// AddComExitBuilding ( j ) ;
74524: LD_VAR 0 3
74528: PPUSH
74529: CALL_OW 182
// end ;
74533: GO 74471
74535: POP
74536: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74537: LD_VAR 0 5
74541: PPUSH
74542: LD_INT 11
74544: PPUSH
74545: CALL_OW 325
74549: IFFALSE 74808
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74551: LD_ADDR_VAR 0 4
74555: PUSH
74556: LD_EXP 87
74560: PUSH
74561: LD_VAR 0 2
74565: ARRAY
74566: PPUSH
74567: LD_INT 25
74569: PUSH
74570: LD_INT 16
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PPUSH
74577: CALL_OW 72
74581: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74582: LD_VAR 0 4
74586: PUSH
74587: LD_INT 6
74589: GREATEREQUAL
74590: PUSH
74591: LD_VAR 0 5
74595: PPUSH
74596: LD_INT 2
74598: PPUSH
74599: CALL_OW 325
74603: NOT
74604: OR
74605: IFFALSE 74808
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74607: LD_ADDR_VAR 0 8
74611: PUSH
74612: LD_EXP 58
74616: PUSH
74617: LD_VAR 0 2
74621: ARRAY
74622: PPUSH
74623: LD_INT 2
74625: PUSH
74626: LD_INT 30
74628: PUSH
74629: LD_INT 4
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 30
74638: PUSH
74639: LD_INT 5
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: LIST
74650: PPUSH
74651: CALL_OW 72
74655: ST_TO_ADDR
// if barracks then
74656: LD_VAR 0 8
74660: IFFALSE 74808
// begin selected := 0 ;
74662: LD_ADDR_VAR 0 7
74666: PUSH
74667: LD_INT 0
74669: ST_TO_ADDR
// for j in barracks do
74670: LD_ADDR_VAR 0 3
74674: PUSH
74675: LD_VAR 0 8
74679: PUSH
74680: FOR_IN
74681: IFFALSE 74712
// begin if UnitsInside ( j ) < 6 then
74683: LD_VAR 0 3
74687: PPUSH
74688: CALL_OW 313
74692: PUSH
74693: LD_INT 6
74695: LESS
74696: IFFALSE 74710
// begin selected := j ;
74698: LD_ADDR_VAR 0 7
74702: PUSH
74703: LD_VAR 0 3
74707: ST_TO_ADDR
// break ;
74708: GO 74712
// end ; end ;
74710: GO 74680
74712: POP
74713: POP
// if selected then
74714: LD_VAR 0 7
74718: IFFALSE 74808
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74720: LD_ADDR_VAR 0 3
74724: PUSH
74725: LD_EXP 87
74729: PUSH
74730: LD_VAR 0 2
74734: ARRAY
74735: PPUSH
74736: LD_INT 25
74738: PUSH
74739: LD_INT 12
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PPUSH
74746: CALL_OW 72
74750: PUSH
74751: FOR_IN
74752: IFFALSE 74806
// if not IsInUnit ( j ) and not HasTask ( j ) then
74754: LD_VAR 0 3
74758: PPUSH
74759: CALL_OW 310
74763: NOT
74764: PUSH
74765: LD_VAR 0 3
74769: PPUSH
74770: CALL_OW 314
74774: NOT
74775: AND
74776: IFFALSE 74804
// begin ComEnterUnit ( j , selected ) ;
74778: LD_VAR 0 3
74782: PPUSH
74783: LD_VAR 0 7
74787: PPUSH
74788: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74792: LD_VAR 0 3
74796: PPUSH
74797: LD_INT 15
74799: PPUSH
74800: CALL_OW 183
// end ;
74804: GO 74751
74806: POP
74807: POP
// end ; end ; end ; end ; end ;
74808: GO 74201
74810: POP
74811: POP
// end ;
74812: LD_VAR 0 1
74816: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74817: LD_INT 0
74819: PPUSH
74820: PPUSH
74821: PPUSH
74822: PPUSH
// if not mc_bases then
74823: LD_EXP 58
74827: NOT
74828: IFFALSE 74832
// exit ;
74830: GO 75010
// for i = 1 to mc_bases do
74832: LD_ADDR_VAR 0 2
74836: PUSH
74837: DOUBLE
74838: LD_INT 1
74840: DEC
74841: ST_TO_ADDR
74842: LD_EXP 58
74846: PUSH
74847: FOR_TO
74848: IFFALSE 75008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74850: LD_ADDR_VAR 0 4
74854: PUSH
74855: LD_EXP 58
74859: PUSH
74860: LD_VAR 0 2
74864: ARRAY
74865: PPUSH
74866: LD_INT 25
74868: PUSH
74869: LD_INT 9
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PPUSH
74876: CALL_OW 72
74880: ST_TO_ADDR
// if not tmp then
74881: LD_VAR 0 4
74885: NOT
74886: IFFALSE 74890
// continue ;
74888: GO 74847
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74890: LD_EXP 84
74894: PUSH
74895: LD_VAR 0 2
74899: ARRAY
74900: PPUSH
74901: LD_INT 29
74903: PPUSH
74904: CALL_OW 325
74908: NOT
74909: PUSH
74910: LD_EXP 84
74914: PUSH
74915: LD_VAR 0 2
74919: ARRAY
74920: PPUSH
74921: LD_INT 28
74923: PPUSH
74924: CALL_OW 325
74928: NOT
74929: AND
74930: IFFALSE 74934
// continue ;
74932: GO 74847
// for j in tmp do
74934: LD_ADDR_VAR 0 3
74938: PUSH
74939: LD_VAR 0 4
74943: PUSH
74944: FOR_IN
74945: IFFALSE 75004
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74947: LD_VAR 0 3
74951: PUSH
74952: LD_EXP 61
74956: PUSH
74957: LD_VAR 0 2
74961: ARRAY
74962: PUSH
74963: LD_INT 1
74965: ARRAY
74966: IN
74967: NOT
74968: PUSH
74969: LD_VAR 0 3
74973: PUSH
74974: LD_EXP 61
74978: PUSH
74979: LD_VAR 0 2
74983: ARRAY
74984: PUSH
74985: LD_INT 2
74987: ARRAY
74988: IN
74989: NOT
74990: AND
74991: IFFALSE 75002
// ComSpaceTimeShoot ( j ) ;
74993: LD_VAR 0 3
74997: PPUSH
74998: CALL 14613 0 1
75002: GO 74944
75004: POP
75005: POP
// end ;
75006: GO 74847
75008: POP
75009: POP
// end ;
75010: LD_VAR 0 1
75014: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75015: LD_INT 0
75017: PPUSH
75018: PPUSH
75019: PPUSH
75020: PPUSH
75021: PPUSH
75022: PPUSH
75023: PPUSH
75024: PPUSH
75025: PPUSH
// if not mc_bases then
75026: LD_EXP 58
75030: NOT
75031: IFFALSE 75035
// exit ;
75033: GO 75657
// for i = 1 to mc_bases do
75035: LD_ADDR_VAR 0 2
75039: PUSH
75040: DOUBLE
75041: LD_INT 1
75043: DEC
75044: ST_TO_ADDR
75045: LD_EXP 58
75049: PUSH
75050: FOR_TO
75051: IFFALSE 75655
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75053: LD_EXP 93
75057: PUSH
75058: LD_VAR 0 2
75062: ARRAY
75063: NOT
75064: PUSH
75065: LD_INT 38
75067: PPUSH
75068: LD_EXP 84
75072: PUSH
75073: LD_VAR 0 2
75077: ARRAY
75078: PPUSH
75079: CALL_OW 321
75083: PUSH
75084: LD_INT 2
75086: NONEQUAL
75087: OR
75088: IFFALSE 75092
// continue ;
75090: GO 75050
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75092: LD_ADDR_VAR 0 8
75096: PUSH
75097: LD_EXP 58
75101: PUSH
75102: LD_VAR 0 2
75106: ARRAY
75107: PPUSH
75108: LD_INT 30
75110: PUSH
75111: LD_INT 34
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PPUSH
75118: CALL_OW 72
75122: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75123: LD_ADDR_VAR 0 9
75127: PUSH
75128: LD_EXP 58
75132: PUSH
75133: LD_VAR 0 2
75137: ARRAY
75138: PPUSH
75139: LD_INT 25
75141: PUSH
75142: LD_INT 4
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PPUSH
75149: CALL_OW 72
75153: PPUSH
75154: LD_INT 0
75156: PPUSH
75157: CALL 53750 0 2
75161: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75162: LD_VAR 0 9
75166: NOT
75167: PUSH
75168: LD_VAR 0 8
75172: NOT
75173: OR
75174: PUSH
75175: LD_EXP 58
75179: PUSH
75180: LD_VAR 0 2
75184: ARRAY
75185: PPUSH
75186: LD_INT 124
75188: PPUSH
75189: CALL 53750 0 2
75193: OR
75194: IFFALSE 75198
// continue ;
75196: GO 75050
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75198: LD_EXP 94
75202: PUSH
75203: LD_VAR 0 2
75207: ARRAY
75208: PUSH
75209: LD_EXP 93
75213: PUSH
75214: LD_VAR 0 2
75218: ARRAY
75219: LESS
75220: PUSH
75221: LD_EXP 94
75225: PUSH
75226: LD_VAR 0 2
75230: ARRAY
75231: PUSH
75232: LD_VAR 0 8
75236: LESS
75237: AND
75238: IFFALSE 75653
// begin tmp := sci [ 1 ] ;
75240: LD_ADDR_VAR 0 7
75244: PUSH
75245: LD_VAR 0 9
75249: PUSH
75250: LD_INT 1
75252: ARRAY
75253: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75254: LD_VAR 0 7
75258: PPUSH
75259: LD_INT 124
75261: PPUSH
75262: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75266: LD_ADDR_VAR 0 3
75270: PUSH
75271: DOUBLE
75272: LD_EXP 93
75276: PUSH
75277: LD_VAR 0 2
75281: ARRAY
75282: INC
75283: ST_TO_ADDR
75284: LD_EXP 93
75288: PUSH
75289: LD_VAR 0 2
75293: ARRAY
75294: PUSH
75295: FOR_DOWNTO
75296: IFFALSE 75639
// begin if IsInUnit ( tmp ) then
75298: LD_VAR 0 7
75302: PPUSH
75303: CALL_OW 310
75307: IFFALSE 75318
// ComExitBuilding ( tmp ) ;
75309: LD_VAR 0 7
75313: PPUSH
75314: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75318: LD_INT 35
75320: PPUSH
75321: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75325: LD_VAR 0 7
75329: PPUSH
75330: CALL_OW 310
75334: NOT
75335: PUSH
75336: LD_VAR 0 7
75340: PPUSH
75341: CALL_OW 314
75345: NOT
75346: AND
75347: IFFALSE 75318
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75349: LD_ADDR_VAR 0 6
75353: PUSH
75354: LD_VAR 0 7
75358: PPUSH
75359: CALL_OW 250
75363: PUSH
75364: LD_VAR 0 7
75368: PPUSH
75369: CALL_OW 251
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75378: LD_INT 35
75380: PPUSH
75381: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75385: LD_ADDR_VAR 0 4
75389: PUSH
75390: LD_EXP 93
75394: PUSH
75395: LD_VAR 0 2
75399: ARRAY
75400: PUSH
75401: LD_VAR 0 3
75405: ARRAY
75406: PUSH
75407: LD_INT 1
75409: ARRAY
75410: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75411: LD_ADDR_VAR 0 5
75415: PUSH
75416: LD_EXP 93
75420: PUSH
75421: LD_VAR 0 2
75425: ARRAY
75426: PUSH
75427: LD_VAR 0 3
75431: ARRAY
75432: PUSH
75433: LD_INT 2
75435: ARRAY
75436: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75437: LD_VAR 0 7
75441: PPUSH
75442: LD_INT 10
75444: PPUSH
75445: CALL 23146 0 2
75449: PUSH
75450: LD_INT 4
75452: ARRAY
75453: IFFALSE 75491
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75455: LD_VAR 0 7
75459: PPUSH
75460: LD_VAR 0 6
75464: PUSH
75465: LD_INT 1
75467: ARRAY
75468: PPUSH
75469: LD_VAR 0 6
75473: PUSH
75474: LD_INT 2
75476: ARRAY
75477: PPUSH
75478: CALL_OW 111
// wait ( 0 0$10 ) ;
75482: LD_INT 350
75484: PPUSH
75485: CALL_OW 67
// end else
75489: GO 75517
// begin ComMoveXY ( tmp , x , y ) ;
75491: LD_VAR 0 7
75495: PPUSH
75496: LD_VAR 0 4
75500: PPUSH
75501: LD_VAR 0 5
75505: PPUSH
75506: CALL_OW 111
// wait ( 0 0$3 ) ;
75510: LD_INT 105
75512: PPUSH
75513: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75517: LD_VAR 0 7
75521: PPUSH
75522: LD_VAR 0 4
75526: PPUSH
75527: LD_VAR 0 5
75531: PPUSH
75532: CALL_OW 307
75536: IFFALSE 75378
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75538: LD_VAR 0 7
75542: PPUSH
75543: LD_VAR 0 4
75547: PPUSH
75548: LD_VAR 0 5
75552: PPUSH
75553: LD_VAR 0 8
75557: PUSH
75558: LD_VAR 0 3
75562: ARRAY
75563: PPUSH
75564: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75568: LD_INT 35
75570: PPUSH
75571: CALL_OW 67
// until not HasTask ( tmp ) ;
75575: LD_VAR 0 7
75579: PPUSH
75580: CALL_OW 314
75584: NOT
75585: IFFALSE 75568
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75587: LD_ADDR_EXP 94
75591: PUSH
75592: LD_EXP 94
75596: PPUSH
75597: LD_VAR 0 2
75601: PUSH
75602: LD_EXP 94
75606: PUSH
75607: LD_VAR 0 2
75611: ARRAY
75612: PUSH
75613: LD_INT 1
75615: PLUS
75616: PUSH
75617: EMPTY
75618: LIST
75619: LIST
75620: PPUSH
75621: LD_VAR 0 8
75625: PUSH
75626: LD_VAR 0 3
75630: ARRAY
75631: PPUSH
75632: CALL 20553 0 3
75636: ST_TO_ADDR
// end ;
75637: GO 75295
75639: POP
75640: POP
// MC_Reset ( i , 124 ) ;
75641: LD_VAR 0 2
75645: PPUSH
75646: LD_INT 124
75648: PPUSH
75649: CALL 59444 0 2
// end ; end ;
75653: GO 75050
75655: POP
75656: POP
// end ;
75657: LD_VAR 0 1
75661: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75662: LD_INT 0
75664: PPUSH
75665: PPUSH
75666: PPUSH
// if not mc_bases then
75667: LD_EXP 58
75671: NOT
75672: IFFALSE 75676
// exit ;
75674: GO 76282
// for i = 1 to mc_bases do
75676: LD_ADDR_VAR 0 2
75680: PUSH
75681: DOUBLE
75682: LD_INT 1
75684: DEC
75685: ST_TO_ADDR
75686: LD_EXP 58
75690: PUSH
75691: FOR_TO
75692: IFFALSE 76280
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75694: LD_ADDR_VAR 0 3
75698: PUSH
75699: LD_EXP 58
75703: PUSH
75704: LD_VAR 0 2
75708: ARRAY
75709: PPUSH
75710: LD_INT 25
75712: PUSH
75713: LD_INT 4
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PPUSH
75720: CALL_OW 72
75724: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75725: LD_VAR 0 3
75729: NOT
75730: PUSH
75731: LD_EXP 95
75735: PUSH
75736: LD_VAR 0 2
75740: ARRAY
75741: NOT
75742: OR
75743: PUSH
75744: LD_EXP 58
75748: PUSH
75749: LD_VAR 0 2
75753: ARRAY
75754: PPUSH
75755: LD_INT 2
75757: PUSH
75758: LD_INT 30
75760: PUSH
75761: LD_INT 0
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: LD_INT 30
75770: PUSH
75771: LD_INT 1
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: LIST
75782: PPUSH
75783: CALL_OW 72
75787: NOT
75788: OR
75789: IFFALSE 75839
// begin if mc_deposits_finder [ i ] then
75791: LD_EXP 96
75795: PUSH
75796: LD_VAR 0 2
75800: ARRAY
75801: IFFALSE 75837
// begin MC_Reset ( i , 125 ) ;
75803: LD_VAR 0 2
75807: PPUSH
75808: LD_INT 125
75810: PPUSH
75811: CALL 59444 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75815: LD_ADDR_EXP 96
75819: PUSH
75820: LD_EXP 96
75824: PPUSH
75825: LD_VAR 0 2
75829: PPUSH
75830: EMPTY
75831: PPUSH
75832: CALL_OW 1
75836: ST_TO_ADDR
// end ; continue ;
75837: GO 75691
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75839: LD_EXP 95
75843: PUSH
75844: LD_VAR 0 2
75848: ARRAY
75849: PUSH
75850: LD_INT 1
75852: ARRAY
75853: PUSH
75854: LD_INT 3
75856: ARRAY
75857: PUSH
75858: LD_INT 1
75860: EQUAL
75861: PUSH
75862: LD_INT 20
75864: PPUSH
75865: LD_EXP 84
75869: PUSH
75870: LD_VAR 0 2
75874: ARRAY
75875: PPUSH
75876: CALL_OW 321
75880: PUSH
75881: LD_INT 2
75883: NONEQUAL
75884: AND
75885: IFFALSE 75935
// begin if mc_deposits_finder [ i ] then
75887: LD_EXP 96
75891: PUSH
75892: LD_VAR 0 2
75896: ARRAY
75897: IFFALSE 75933
// begin MC_Reset ( i , 125 ) ;
75899: LD_VAR 0 2
75903: PPUSH
75904: LD_INT 125
75906: PPUSH
75907: CALL 59444 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75911: LD_ADDR_EXP 96
75915: PUSH
75916: LD_EXP 96
75920: PPUSH
75921: LD_VAR 0 2
75925: PPUSH
75926: EMPTY
75927: PPUSH
75928: CALL_OW 1
75932: ST_TO_ADDR
// end ; continue ;
75933: GO 75691
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75935: LD_EXP 95
75939: PUSH
75940: LD_VAR 0 2
75944: ARRAY
75945: PUSH
75946: LD_INT 1
75948: ARRAY
75949: PUSH
75950: LD_INT 1
75952: ARRAY
75953: PPUSH
75954: LD_EXP 95
75958: PUSH
75959: LD_VAR 0 2
75963: ARRAY
75964: PUSH
75965: LD_INT 1
75967: ARRAY
75968: PUSH
75969: LD_INT 2
75971: ARRAY
75972: PPUSH
75973: LD_EXP 84
75977: PUSH
75978: LD_VAR 0 2
75982: ARRAY
75983: PPUSH
75984: CALL_OW 440
75988: IFFALSE 76031
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75990: LD_ADDR_EXP 95
75994: PUSH
75995: LD_EXP 95
75999: PPUSH
76000: LD_VAR 0 2
76004: PPUSH
76005: LD_EXP 95
76009: PUSH
76010: LD_VAR 0 2
76014: ARRAY
76015: PPUSH
76016: LD_INT 1
76018: PPUSH
76019: CALL_OW 3
76023: PPUSH
76024: CALL_OW 1
76028: ST_TO_ADDR
76029: GO 76278
// begin if not mc_deposits_finder [ i ] then
76031: LD_EXP 96
76035: PUSH
76036: LD_VAR 0 2
76040: ARRAY
76041: NOT
76042: IFFALSE 76094
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76044: LD_ADDR_EXP 96
76048: PUSH
76049: LD_EXP 96
76053: PPUSH
76054: LD_VAR 0 2
76058: PPUSH
76059: LD_VAR 0 3
76063: PUSH
76064: LD_INT 1
76066: ARRAY
76067: PUSH
76068: EMPTY
76069: LIST
76070: PPUSH
76071: CALL_OW 1
76075: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76076: LD_VAR 0 3
76080: PUSH
76081: LD_INT 1
76083: ARRAY
76084: PPUSH
76085: LD_INT 125
76087: PPUSH
76088: CALL_OW 109
// end else
76092: GO 76278
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76094: LD_EXP 96
76098: PUSH
76099: LD_VAR 0 2
76103: ARRAY
76104: PUSH
76105: LD_INT 1
76107: ARRAY
76108: PPUSH
76109: CALL_OW 310
76113: IFFALSE 76136
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76115: LD_EXP 96
76119: PUSH
76120: LD_VAR 0 2
76124: ARRAY
76125: PUSH
76126: LD_INT 1
76128: ARRAY
76129: PPUSH
76130: CALL_OW 122
76134: GO 76278
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76136: LD_EXP 96
76140: PUSH
76141: LD_VAR 0 2
76145: ARRAY
76146: PUSH
76147: LD_INT 1
76149: ARRAY
76150: PPUSH
76151: CALL_OW 314
76155: NOT
76156: PUSH
76157: LD_EXP 96
76161: PUSH
76162: LD_VAR 0 2
76166: ARRAY
76167: PUSH
76168: LD_INT 1
76170: ARRAY
76171: PPUSH
76172: LD_EXP 95
76176: PUSH
76177: LD_VAR 0 2
76181: ARRAY
76182: PUSH
76183: LD_INT 1
76185: ARRAY
76186: PUSH
76187: LD_INT 1
76189: ARRAY
76190: PPUSH
76191: LD_EXP 95
76195: PUSH
76196: LD_VAR 0 2
76200: ARRAY
76201: PUSH
76202: LD_INT 1
76204: ARRAY
76205: PUSH
76206: LD_INT 2
76208: ARRAY
76209: PPUSH
76210: CALL_OW 297
76214: PUSH
76215: LD_INT 6
76217: GREATER
76218: AND
76219: IFFALSE 76278
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76221: LD_EXP 96
76225: PUSH
76226: LD_VAR 0 2
76230: ARRAY
76231: PUSH
76232: LD_INT 1
76234: ARRAY
76235: PPUSH
76236: LD_EXP 95
76240: PUSH
76241: LD_VAR 0 2
76245: ARRAY
76246: PUSH
76247: LD_INT 1
76249: ARRAY
76250: PUSH
76251: LD_INT 1
76253: ARRAY
76254: PPUSH
76255: LD_EXP 95
76259: PUSH
76260: LD_VAR 0 2
76264: ARRAY
76265: PUSH
76266: LD_INT 1
76268: ARRAY
76269: PUSH
76270: LD_INT 2
76272: ARRAY
76273: PPUSH
76274: CALL_OW 111
// end ; end ; end ;
76278: GO 75691
76280: POP
76281: POP
// end ;
76282: LD_VAR 0 1
76286: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76287: LD_INT 0
76289: PPUSH
76290: PPUSH
76291: PPUSH
76292: PPUSH
76293: PPUSH
76294: PPUSH
76295: PPUSH
76296: PPUSH
76297: PPUSH
76298: PPUSH
76299: PPUSH
// if not mc_bases then
76300: LD_EXP 58
76304: NOT
76305: IFFALSE 76309
// exit ;
76307: GO 77033
// for i = 1 to mc_bases do
76309: LD_ADDR_VAR 0 2
76313: PUSH
76314: DOUBLE
76315: LD_INT 1
76317: DEC
76318: ST_TO_ADDR
76319: LD_EXP 58
76323: PUSH
76324: FOR_TO
76325: IFFALSE 77031
// begin if not mc_bases [ i ] then
76327: LD_EXP 58
76331: PUSH
76332: LD_VAR 0 2
76336: ARRAY
76337: NOT
76338: IFFALSE 76342
// continue ;
76340: GO 76324
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76342: LD_ADDR_VAR 0 7
76346: PUSH
76347: LD_EXP 58
76351: PUSH
76352: LD_VAR 0 2
76356: ARRAY
76357: PUSH
76358: LD_INT 1
76360: ARRAY
76361: PPUSH
76362: CALL_OW 248
76366: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76367: LD_VAR 0 7
76371: PUSH
76372: LD_INT 3
76374: EQUAL
76375: PUSH
76376: LD_EXP 77
76380: PUSH
76381: LD_VAR 0 2
76385: ARRAY
76386: PUSH
76387: LD_EXP 80
76391: PUSH
76392: LD_VAR 0 2
76396: ARRAY
76397: UNION
76398: PPUSH
76399: LD_INT 33
76401: PUSH
76402: LD_INT 2
76404: PUSH
76405: EMPTY
76406: LIST
76407: LIST
76408: PPUSH
76409: CALL_OW 72
76413: NOT
76414: OR
76415: IFFALSE 76419
// continue ;
76417: GO 76324
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76419: LD_ADDR_VAR 0 9
76423: PUSH
76424: LD_EXP 58
76428: PUSH
76429: LD_VAR 0 2
76433: ARRAY
76434: PPUSH
76435: LD_INT 30
76437: PUSH
76438: LD_INT 36
76440: PUSH
76441: EMPTY
76442: LIST
76443: LIST
76444: PPUSH
76445: CALL_OW 72
76449: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76450: LD_ADDR_VAR 0 10
76454: PUSH
76455: LD_EXP 77
76459: PUSH
76460: LD_VAR 0 2
76464: ARRAY
76465: PPUSH
76466: LD_INT 34
76468: PUSH
76469: LD_INT 31
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PPUSH
76476: CALL_OW 72
76480: ST_TO_ADDR
// if not cts and not mcts then
76481: LD_VAR 0 9
76485: NOT
76486: PUSH
76487: LD_VAR 0 10
76491: NOT
76492: AND
76493: IFFALSE 76497
// continue ;
76495: GO 76324
// x := cts ;
76497: LD_ADDR_VAR 0 11
76501: PUSH
76502: LD_VAR 0 9
76506: ST_TO_ADDR
// if not x then
76507: LD_VAR 0 11
76511: NOT
76512: IFFALSE 76524
// x := mcts ;
76514: LD_ADDR_VAR 0 11
76518: PUSH
76519: LD_VAR 0 10
76523: ST_TO_ADDR
// if mc_remote_driver [ i ] then
76524: LD_EXP 98
76528: PUSH
76529: LD_VAR 0 2
76533: ARRAY
76534: IFFALSE 76803
// for j in mc_remote_driver [ i ] do
76536: LD_ADDR_VAR 0 3
76540: PUSH
76541: LD_EXP 98
76545: PUSH
76546: LD_VAR 0 2
76550: ARRAY
76551: PUSH
76552: FOR_IN
76553: IFFALSE 76801
// begin if GetClass ( j ) <> 3 then
76555: LD_VAR 0 3
76559: PPUSH
76560: CALL_OW 257
76564: PUSH
76565: LD_INT 3
76567: NONEQUAL
76568: IFFALSE 76621
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76570: LD_ADDR_EXP 98
76574: PUSH
76575: LD_EXP 98
76579: PPUSH
76580: LD_VAR 0 2
76584: PPUSH
76585: LD_EXP 98
76589: PUSH
76590: LD_VAR 0 2
76594: ARRAY
76595: PUSH
76596: LD_VAR 0 3
76600: DIFF
76601: PPUSH
76602: CALL_OW 1
76606: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76607: LD_VAR 0 3
76611: PPUSH
76612: LD_INT 0
76614: PPUSH
76615: CALL_OW 109
// continue ;
76619: GO 76552
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76621: LD_VAR 0 3
76625: PPUSH
76626: CALL_OW 310
76630: NOT
76631: PUSH
76632: LD_VAR 0 3
76636: PPUSH
76637: CALL_OW 310
76641: PPUSH
76642: CALL_OW 266
76646: PUSH
76647: LD_INT 36
76649: NONEQUAL
76650: PUSH
76651: LD_VAR 0 3
76655: PPUSH
76656: CALL 53838 0 1
76660: NOT
76661: AND
76662: OR
76663: IFFALSE 76799
// begin if IsInUnit ( j ) then
76665: LD_VAR 0 3
76669: PPUSH
76670: CALL_OW 310
76674: IFFALSE 76685
// ComExitBuilding ( j ) ;
76676: LD_VAR 0 3
76680: PPUSH
76681: CALL_OW 122
// ct := 0 ;
76685: LD_ADDR_VAR 0 8
76689: PUSH
76690: LD_INT 0
76692: ST_TO_ADDR
// for k in x do
76693: LD_ADDR_VAR 0 4
76697: PUSH
76698: LD_VAR 0 11
76702: PUSH
76703: FOR_IN
76704: IFFALSE 76777
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76706: LD_VAR 0 4
76710: PPUSH
76711: CALL_OW 264
76715: PUSH
76716: LD_INT 31
76718: EQUAL
76719: PUSH
76720: LD_VAR 0 4
76724: PPUSH
76725: CALL_OW 311
76729: NOT
76730: AND
76731: PUSH
76732: LD_VAR 0 4
76736: PPUSH
76737: CALL_OW 266
76741: PUSH
76742: LD_INT 36
76744: EQUAL
76745: PUSH
76746: LD_VAR 0 4
76750: PPUSH
76751: CALL_OW 313
76755: PUSH
76756: LD_INT 3
76758: LESS
76759: AND
76760: OR
76761: IFFALSE 76775
// begin ct := k ;
76763: LD_ADDR_VAR 0 8
76767: PUSH
76768: LD_VAR 0 4
76772: ST_TO_ADDR
// break ;
76773: GO 76777
// end ;
76775: GO 76703
76777: POP
76778: POP
// if ct then
76779: LD_VAR 0 8
76783: IFFALSE 76799
// ComEnterUnit ( j , ct ) ;
76785: LD_VAR 0 3
76789: PPUSH
76790: LD_VAR 0 8
76794: PPUSH
76795: CALL_OW 120
// end ; end ;
76799: GO 76552
76801: POP
76802: POP
// places := 0 ;
76803: LD_ADDR_VAR 0 5
76807: PUSH
76808: LD_INT 0
76810: ST_TO_ADDR
// for j = 1 to x do
76811: LD_ADDR_VAR 0 3
76815: PUSH
76816: DOUBLE
76817: LD_INT 1
76819: DEC
76820: ST_TO_ADDR
76821: LD_VAR 0 11
76825: PUSH
76826: FOR_TO
76827: IFFALSE 76882
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76829: LD_VAR 0 11
76833: PUSH
76834: LD_VAR 0 3
76838: ARRAY
76839: PPUSH
76840: CALL_OW 264
76844: PUSH
76845: LD_INT 31
76847: EQUAL
76848: IFFALSE 76866
// places := places + 1 else
76850: LD_ADDR_VAR 0 5
76854: PUSH
76855: LD_VAR 0 5
76859: PUSH
76860: LD_INT 1
76862: PLUS
76863: ST_TO_ADDR
76864: GO 76880
// places := places + 3 ;
76866: LD_ADDR_VAR 0 5
76870: PUSH
76871: LD_VAR 0 5
76875: PUSH
76876: LD_INT 3
76878: PLUS
76879: ST_TO_ADDR
76880: GO 76826
76882: POP
76883: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76884: LD_ADDR_VAR 0 6
76888: PUSH
76889: LD_EXP 58
76893: PUSH
76894: LD_VAR 0 2
76898: ARRAY
76899: PPUSH
76900: LD_INT 25
76902: PUSH
76903: LD_INT 3
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: PPUSH
76910: CALL_OW 72
76914: PUSH
76915: LD_EXP 98
76919: PUSH
76920: LD_VAR 0 2
76924: ARRAY
76925: DIFF
76926: PPUSH
76927: LD_INT 3
76929: PPUSH
76930: CALL 54738 0 2
76934: ST_TO_ADDR
// if not tmp then
76935: LD_VAR 0 6
76939: NOT
76940: IFFALSE 76944
// continue ;
76942: GO 76324
// places := places - mc_remote_driver [ i ] ;
76944: LD_ADDR_VAR 0 5
76948: PUSH
76949: LD_VAR 0 5
76953: PUSH
76954: LD_EXP 98
76958: PUSH
76959: LD_VAR 0 2
76963: ARRAY
76964: MINUS
76965: ST_TO_ADDR
// if places then
76966: LD_VAR 0 5
76970: IFFALSE 77029
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76972: LD_ADDR_EXP 98
76976: PUSH
76977: LD_EXP 98
76981: PPUSH
76982: LD_VAR 0 2
76986: PPUSH
76987: LD_EXP 98
76991: PUSH
76992: LD_VAR 0 2
76996: ARRAY
76997: PUSH
76998: LD_VAR 0 6
77002: PUSH
77003: LD_INT 1
77005: ARRAY
77006: UNION
77007: PPUSH
77008: CALL_OW 1
77012: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77013: LD_VAR 0 6
77017: PUSH
77018: LD_INT 1
77020: ARRAY
77021: PPUSH
77022: LD_INT 126
77024: PPUSH
77025: CALL_OW 109
// end ; end ;
77029: GO 76324
77031: POP
77032: POP
// end ;
77033: LD_VAR 0 1
77037: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77038: LD_INT 0
77040: PPUSH
77041: PPUSH
77042: PPUSH
77043: PPUSH
77044: PPUSH
77045: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77046: LD_VAR 0 1
77050: NOT
77051: PUSH
77052: LD_VAR 0 2
77056: NOT
77057: OR
77058: PUSH
77059: LD_VAR 0 3
77063: NOT
77064: OR
77065: PUSH
77066: LD_VAR 0 4
77070: PUSH
77071: LD_INT 1
77073: PUSH
77074: LD_INT 2
77076: PUSH
77077: LD_INT 3
77079: PUSH
77080: LD_INT 4
77082: PUSH
77083: LD_INT 5
77085: PUSH
77086: LD_INT 8
77088: PUSH
77089: LD_INT 9
77091: PUSH
77092: LD_INT 15
77094: PUSH
77095: LD_INT 16
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: IN
77109: NOT
77110: OR
77111: IFFALSE 77115
// exit ;
77113: GO 78015
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77115: LD_ADDR_VAR 0 2
77119: PUSH
77120: LD_VAR 0 2
77124: PPUSH
77125: LD_INT 21
77127: PUSH
77128: LD_INT 3
77130: PUSH
77131: EMPTY
77132: LIST
77133: LIST
77134: PUSH
77135: LD_INT 24
77137: PUSH
77138: LD_INT 250
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: EMPTY
77146: LIST
77147: LIST
77148: PPUSH
77149: CALL_OW 72
77153: ST_TO_ADDR
// case class of 1 , 15 :
77154: LD_VAR 0 4
77158: PUSH
77159: LD_INT 1
77161: DOUBLE
77162: EQUAL
77163: IFTRUE 77173
77165: LD_INT 15
77167: DOUBLE
77168: EQUAL
77169: IFTRUE 77173
77171: GO 77258
77173: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77174: LD_ADDR_VAR 0 8
77178: PUSH
77179: LD_VAR 0 2
77183: PPUSH
77184: LD_INT 2
77186: PUSH
77187: LD_INT 30
77189: PUSH
77190: LD_INT 32
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 30
77199: PUSH
77200: LD_INT 31
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: LIST
77211: PPUSH
77212: CALL_OW 72
77216: PUSH
77217: LD_VAR 0 2
77221: PPUSH
77222: LD_INT 2
77224: PUSH
77225: LD_INT 30
77227: PUSH
77228: LD_INT 4
77230: PUSH
77231: EMPTY
77232: LIST
77233: LIST
77234: PUSH
77235: LD_INT 30
77237: PUSH
77238: LD_INT 5
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: LIST
77249: PPUSH
77250: CALL_OW 72
77254: ADD
77255: ST_TO_ADDR
77256: GO 77504
77258: LD_INT 2
77260: DOUBLE
77261: EQUAL
77262: IFTRUE 77272
77264: LD_INT 16
77266: DOUBLE
77267: EQUAL
77268: IFTRUE 77272
77270: GO 77318
77272: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77273: LD_ADDR_VAR 0 8
77277: PUSH
77278: LD_VAR 0 2
77282: PPUSH
77283: LD_INT 2
77285: PUSH
77286: LD_INT 30
77288: PUSH
77289: LD_INT 0
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 30
77298: PUSH
77299: LD_INT 1
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: EMPTY
77307: LIST
77308: LIST
77309: LIST
77310: PPUSH
77311: CALL_OW 72
77315: ST_TO_ADDR
77316: GO 77504
77318: LD_INT 3
77320: DOUBLE
77321: EQUAL
77322: IFTRUE 77326
77324: GO 77372
77326: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77327: LD_ADDR_VAR 0 8
77331: PUSH
77332: LD_VAR 0 2
77336: PPUSH
77337: LD_INT 2
77339: PUSH
77340: LD_INT 30
77342: PUSH
77343: LD_INT 2
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 30
77352: PUSH
77353: LD_INT 3
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: LIST
77364: PPUSH
77365: CALL_OW 72
77369: ST_TO_ADDR
77370: GO 77504
77372: LD_INT 4
77374: DOUBLE
77375: EQUAL
77376: IFTRUE 77380
77378: GO 77437
77380: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77381: LD_ADDR_VAR 0 8
77385: PUSH
77386: LD_VAR 0 2
77390: PPUSH
77391: LD_INT 2
77393: PUSH
77394: LD_INT 30
77396: PUSH
77397: LD_INT 6
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 30
77406: PUSH
77407: LD_INT 7
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 30
77416: PUSH
77417: LD_INT 8
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: LIST
77428: LIST
77429: PPUSH
77430: CALL_OW 72
77434: ST_TO_ADDR
77435: GO 77504
77437: LD_INT 5
77439: DOUBLE
77440: EQUAL
77441: IFTRUE 77457
77443: LD_INT 8
77445: DOUBLE
77446: EQUAL
77447: IFTRUE 77457
77449: LD_INT 9
77451: DOUBLE
77452: EQUAL
77453: IFTRUE 77457
77455: GO 77503
77457: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77458: LD_ADDR_VAR 0 8
77462: PUSH
77463: LD_VAR 0 2
77467: PPUSH
77468: LD_INT 2
77470: PUSH
77471: LD_INT 30
77473: PUSH
77474: LD_INT 4
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 30
77483: PUSH
77484: LD_INT 5
77486: PUSH
77487: EMPTY
77488: LIST
77489: LIST
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: LIST
77495: PPUSH
77496: CALL_OW 72
77500: ST_TO_ADDR
77501: GO 77504
77503: POP
// if not tmp then
77504: LD_VAR 0 8
77508: NOT
77509: IFFALSE 77513
// exit ;
77511: GO 78015
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77513: LD_VAR 0 4
77517: PUSH
77518: LD_INT 1
77520: PUSH
77521: LD_INT 15
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: IN
77528: PUSH
77529: LD_EXP 67
77533: PUSH
77534: LD_VAR 0 1
77538: ARRAY
77539: AND
77540: IFFALSE 77696
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77542: LD_ADDR_VAR 0 9
77546: PUSH
77547: LD_EXP 67
77551: PUSH
77552: LD_VAR 0 1
77556: ARRAY
77557: PUSH
77558: LD_INT 1
77560: ARRAY
77561: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77562: LD_VAR 0 9
77566: PUSH
77567: LD_EXP 68
77571: PUSH
77572: LD_VAR 0 1
77576: ARRAY
77577: IN
77578: NOT
77579: IFFALSE 77694
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77581: LD_ADDR_EXP 68
77585: PUSH
77586: LD_EXP 68
77590: PPUSH
77591: LD_VAR 0 1
77595: PUSH
77596: LD_EXP 68
77600: PUSH
77601: LD_VAR 0 1
77605: ARRAY
77606: PUSH
77607: LD_INT 1
77609: PLUS
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PPUSH
77615: LD_VAR 0 9
77619: PPUSH
77620: CALL 20553 0 3
77624: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77625: LD_ADDR_EXP 67
77629: PUSH
77630: LD_EXP 67
77634: PPUSH
77635: LD_VAR 0 1
77639: PPUSH
77640: LD_EXP 67
77644: PUSH
77645: LD_VAR 0 1
77649: ARRAY
77650: PUSH
77651: LD_VAR 0 9
77655: DIFF
77656: PPUSH
77657: CALL_OW 1
77661: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77662: LD_VAR 0 3
77666: PPUSH
77667: LD_EXP 68
77671: PUSH
77672: LD_VAR 0 1
77676: ARRAY
77677: PUSH
77678: LD_EXP 68
77682: PUSH
77683: LD_VAR 0 1
77687: ARRAY
77688: ARRAY
77689: PPUSH
77690: CALL_OW 120
// end ; exit ;
77694: GO 78015
// end ; if tmp > 1 then
77696: LD_VAR 0 8
77700: PUSH
77701: LD_INT 1
77703: GREATER
77704: IFFALSE 77808
// for i = 2 to tmp do
77706: LD_ADDR_VAR 0 6
77710: PUSH
77711: DOUBLE
77712: LD_INT 2
77714: DEC
77715: ST_TO_ADDR
77716: LD_VAR 0 8
77720: PUSH
77721: FOR_TO
77722: IFFALSE 77806
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77724: LD_VAR 0 8
77728: PUSH
77729: LD_VAR 0 6
77733: ARRAY
77734: PPUSH
77735: CALL_OW 461
77739: PUSH
77740: LD_INT 6
77742: EQUAL
77743: IFFALSE 77804
// begin x := tmp [ i ] ;
77745: LD_ADDR_VAR 0 9
77749: PUSH
77750: LD_VAR 0 8
77754: PUSH
77755: LD_VAR 0 6
77759: ARRAY
77760: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77761: LD_ADDR_VAR 0 8
77765: PUSH
77766: LD_VAR 0 8
77770: PPUSH
77771: LD_VAR 0 6
77775: PPUSH
77776: CALL_OW 3
77780: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77781: LD_ADDR_VAR 0 8
77785: PUSH
77786: LD_VAR 0 8
77790: PPUSH
77791: LD_INT 1
77793: PPUSH
77794: LD_VAR 0 9
77798: PPUSH
77799: CALL_OW 2
77803: ST_TO_ADDR
// end ;
77804: GO 77721
77806: POP
77807: POP
// for i in tmp do
77808: LD_ADDR_VAR 0 6
77812: PUSH
77813: LD_VAR 0 8
77817: PUSH
77818: FOR_IN
77819: IFFALSE 77888
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77821: LD_VAR 0 6
77825: PPUSH
77826: CALL_OW 313
77830: PUSH
77831: LD_INT 6
77833: LESS
77834: PUSH
77835: LD_VAR 0 6
77839: PPUSH
77840: CALL_OW 266
77844: PUSH
77845: LD_INT 31
77847: PUSH
77848: LD_INT 32
77850: PUSH
77851: EMPTY
77852: LIST
77853: LIST
77854: IN
77855: NOT
77856: AND
77857: PUSH
77858: LD_VAR 0 6
77862: PPUSH
77863: CALL_OW 313
77867: PUSH
77868: LD_INT 0
77870: EQUAL
77871: OR
77872: IFFALSE 77886
// begin j := i ;
77874: LD_ADDR_VAR 0 7
77878: PUSH
77879: LD_VAR 0 6
77883: ST_TO_ADDR
// break ;
77884: GO 77888
// end ; end ;
77886: GO 77818
77888: POP
77889: POP
// if j then
77890: LD_VAR 0 7
77894: IFFALSE 77912
// ComEnterUnit ( unit , j ) else
77896: LD_VAR 0 3
77900: PPUSH
77901: LD_VAR 0 7
77905: PPUSH
77906: CALL_OW 120
77910: GO 78015
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77912: LD_ADDR_VAR 0 10
77916: PUSH
77917: LD_VAR 0 2
77921: PPUSH
77922: LD_INT 2
77924: PUSH
77925: LD_INT 30
77927: PUSH
77928: LD_INT 0
77930: PUSH
77931: EMPTY
77932: LIST
77933: LIST
77934: PUSH
77935: LD_INT 30
77937: PUSH
77938: LD_INT 1
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: LIST
77949: PPUSH
77950: CALL_OW 72
77954: ST_TO_ADDR
// if depot then
77955: LD_VAR 0 10
77959: IFFALSE 78015
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77961: LD_ADDR_VAR 0 10
77965: PUSH
77966: LD_VAR 0 10
77970: PPUSH
77971: LD_VAR 0 3
77975: PPUSH
77976: CALL_OW 74
77980: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77981: LD_VAR 0 3
77985: PPUSH
77986: LD_VAR 0 10
77990: PPUSH
77991: CALL_OW 296
77995: PUSH
77996: LD_INT 10
77998: GREATER
77999: IFFALSE 78015
// ComStandNearbyBuilding ( unit , depot ) ;
78001: LD_VAR 0 3
78005: PPUSH
78006: LD_VAR 0 10
78010: PPUSH
78011: CALL 15230 0 2
// end ; end ; end ;
78015: LD_VAR 0 5
78019: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78020: LD_INT 0
78022: PPUSH
78023: PPUSH
78024: PPUSH
78025: PPUSH
// if not mc_bases then
78026: LD_EXP 58
78030: NOT
78031: IFFALSE 78035
// exit ;
78033: GO 78274
// for i = 1 to mc_bases do
78035: LD_ADDR_VAR 0 2
78039: PUSH
78040: DOUBLE
78041: LD_INT 1
78043: DEC
78044: ST_TO_ADDR
78045: LD_EXP 58
78049: PUSH
78050: FOR_TO
78051: IFFALSE 78272
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78053: LD_ADDR_VAR 0 4
78057: PUSH
78058: LD_EXP 58
78062: PUSH
78063: LD_VAR 0 2
78067: ARRAY
78068: PPUSH
78069: LD_INT 21
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PPUSH
78079: CALL_OW 72
78083: PUSH
78084: LD_EXP 87
78088: PUSH
78089: LD_VAR 0 2
78093: ARRAY
78094: UNION
78095: ST_TO_ADDR
// if not tmp then
78096: LD_VAR 0 4
78100: NOT
78101: IFFALSE 78105
// continue ;
78103: GO 78050
// for j in tmp do
78105: LD_ADDR_VAR 0 3
78109: PUSH
78110: LD_VAR 0 4
78114: PUSH
78115: FOR_IN
78116: IFFALSE 78268
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78118: LD_VAR 0 3
78122: PPUSH
78123: CALL_OW 110
78127: NOT
78128: PUSH
78129: LD_VAR 0 3
78133: PPUSH
78134: CALL_OW 314
78138: NOT
78139: AND
78140: PUSH
78141: LD_VAR 0 3
78145: PPUSH
78146: CALL_OW 311
78150: NOT
78151: AND
78152: PUSH
78153: LD_VAR 0 3
78157: PPUSH
78158: CALL_OW 310
78162: NOT
78163: AND
78164: PUSH
78165: LD_VAR 0 3
78169: PUSH
78170: LD_EXP 61
78174: PUSH
78175: LD_VAR 0 2
78179: ARRAY
78180: PUSH
78181: LD_INT 1
78183: ARRAY
78184: IN
78185: NOT
78186: AND
78187: PUSH
78188: LD_VAR 0 3
78192: PUSH
78193: LD_EXP 61
78197: PUSH
78198: LD_VAR 0 2
78202: ARRAY
78203: PUSH
78204: LD_INT 2
78206: ARRAY
78207: IN
78208: NOT
78209: AND
78210: PUSH
78211: LD_VAR 0 3
78215: PUSH
78216: LD_EXP 70
78220: PUSH
78221: LD_VAR 0 2
78225: ARRAY
78226: IN
78227: NOT
78228: AND
78229: IFFALSE 78266
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78231: LD_VAR 0 2
78235: PPUSH
78236: LD_EXP 58
78240: PUSH
78241: LD_VAR 0 2
78245: ARRAY
78246: PPUSH
78247: LD_VAR 0 3
78251: PPUSH
78252: LD_VAR 0 3
78256: PPUSH
78257: CALL_OW 257
78261: PPUSH
78262: CALL 77038 0 4
// end ;
78266: GO 78115
78268: POP
78269: POP
// end ;
78270: GO 78050
78272: POP
78273: POP
// end ;
78274: LD_VAR 0 1
78278: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78279: LD_INT 0
78281: PPUSH
78282: PPUSH
78283: PPUSH
78284: PPUSH
78285: PPUSH
78286: PPUSH
// if not mc_bases [ base ] then
78287: LD_EXP 58
78291: PUSH
78292: LD_VAR 0 1
78296: ARRAY
78297: NOT
78298: IFFALSE 78302
// exit ;
78300: GO 78484
// tmp := [ ] ;
78302: LD_ADDR_VAR 0 6
78306: PUSH
78307: EMPTY
78308: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78309: LD_ADDR_VAR 0 7
78313: PUSH
78314: LD_VAR 0 3
78318: PPUSH
78319: LD_INT 0
78321: PPUSH
78322: CALL_OW 517
78326: ST_TO_ADDR
// if not list then
78327: LD_VAR 0 7
78331: NOT
78332: IFFALSE 78336
// exit ;
78334: GO 78484
// for i = 1 to amount do
78336: LD_ADDR_VAR 0 5
78340: PUSH
78341: DOUBLE
78342: LD_INT 1
78344: DEC
78345: ST_TO_ADDR
78346: LD_VAR 0 2
78350: PUSH
78351: FOR_TO
78352: IFFALSE 78432
// begin x := rand ( 1 , list [ 1 ] ) ;
78354: LD_ADDR_VAR 0 8
78358: PUSH
78359: LD_INT 1
78361: PPUSH
78362: LD_VAR 0 7
78366: PUSH
78367: LD_INT 1
78369: ARRAY
78370: PPUSH
78371: CALL_OW 12
78375: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78376: LD_ADDR_VAR 0 6
78380: PUSH
78381: LD_VAR 0 6
78385: PPUSH
78386: LD_VAR 0 5
78390: PPUSH
78391: LD_VAR 0 7
78395: PUSH
78396: LD_INT 1
78398: ARRAY
78399: PUSH
78400: LD_VAR 0 8
78404: ARRAY
78405: PUSH
78406: LD_VAR 0 7
78410: PUSH
78411: LD_INT 2
78413: ARRAY
78414: PUSH
78415: LD_VAR 0 8
78419: ARRAY
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PPUSH
78425: CALL_OW 1
78429: ST_TO_ADDR
// end ;
78430: GO 78351
78432: POP
78433: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78434: LD_ADDR_EXP 71
78438: PUSH
78439: LD_EXP 71
78443: PPUSH
78444: LD_VAR 0 1
78448: PPUSH
78449: LD_VAR 0 6
78453: PPUSH
78454: CALL_OW 1
78458: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78459: LD_ADDR_EXP 73
78463: PUSH
78464: LD_EXP 73
78468: PPUSH
78469: LD_VAR 0 1
78473: PPUSH
78474: LD_VAR 0 3
78478: PPUSH
78479: CALL_OW 1
78483: ST_TO_ADDR
// end ;
78484: LD_VAR 0 4
78488: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78489: LD_INT 0
78491: PPUSH
// if not mc_bases [ base ] then
78492: LD_EXP 58
78496: PUSH
78497: LD_VAR 0 1
78501: ARRAY
78502: NOT
78503: IFFALSE 78507
// exit ;
78505: GO 78532
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78507: LD_ADDR_EXP 63
78511: PUSH
78512: LD_EXP 63
78516: PPUSH
78517: LD_VAR 0 1
78521: PPUSH
78522: LD_VAR 0 2
78526: PPUSH
78527: CALL_OW 1
78531: ST_TO_ADDR
// end ;
78532: LD_VAR 0 3
78536: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78537: LD_INT 0
78539: PPUSH
// if not mc_bases [ base ] then
78540: LD_EXP 58
78544: PUSH
78545: LD_VAR 0 1
78549: ARRAY
78550: NOT
78551: IFFALSE 78555
// exit ;
78553: GO 78592
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78555: LD_ADDR_EXP 63
78559: PUSH
78560: LD_EXP 63
78564: PPUSH
78565: LD_VAR 0 1
78569: PPUSH
78570: LD_EXP 63
78574: PUSH
78575: LD_VAR 0 1
78579: ARRAY
78580: PUSH
78581: LD_VAR 0 2
78585: UNION
78586: PPUSH
78587: CALL_OW 1
78591: ST_TO_ADDR
// end ;
78592: LD_VAR 0 3
78596: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78597: LD_INT 0
78599: PPUSH
// if not mc_bases [ base ] then
78600: LD_EXP 58
78604: PUSH
78605: LD_VAR 0 1
78609: ARRAY
78610: NOT
78611: IFFALSE 78615
// exit ;
78613: GO 78640
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78615: LD_ADDR_EXP 79
78619: PUSH
78620: LD_EXP 79
78624: PPUSH
78625: LD_VAR 0 1
78629: PPUSH
78630: LD_VAR 0 2
78634: PPUSH
78635: CALL_OW 1
78639: ST_TO_ADDR
// end ;
78640: LD_VAR 0 3
78644: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78645: LD_INT 0
78647: PPUSH
// if not mc_bases [ base ] then
78648: LD_EXP 58
78652: PUSH
78653: LD_VAR 0 1
78657: ARRAY
78658: NOT
78659: IFFALSE 78663
// exit ;
78661: GO 78700
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78663: LD_ADDR_EXP 79
78667: PUSH
78668: LD_EXP 79
78672: PPUSH
78673: LD_VAR 0 1
78677: PPUSH
78678: LD_EXP 79
78682: PUSH
78683: LD_VAR 0 1
78687: ARRAY
78688: PUSH
78689: LD_VAR 0 2
78693: ADD
78694: PPUSH
78695: CALL_OW 1
78699: ST_TO_ADDR
// end ;
78700: LD_VAR 0 3
78704: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78705: LD_INT 0
78707: PPUSH
// if not mc_bases [ base ] then
78708: LD_EXP 58
78712: PUSH
78713: LD_VAR 0 1
78717: ARRAY
78718: NOT
78719: IFFALSE 78723
// exit ;
78721: GO 78777
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78723: LD_ADDR_EXP 80
78727: PUSH
78728: LD_EXP 80
78732: PPUSH
78733: LD_VAR 0 1
78737: PPUSH
78738: LD_VAR 0 2
78742: PPUSH
78743: CALL_OW 1
78747: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78748: LD_ADDR_EXP 69
78752: PUSH
78753: LD_EXP 69
78757: PPUSH
78758: LD_VAR 0 1
78762: PPUSH
78763: LD_VAR 0 2
78767: PUSH
78768: LD_INT 0
78770: PLUS
78771: PPUSH
78772: CALL_OW 1
78776: ST_TO_ADDR
// end ;
78777: LD_VAR 0 3
78781: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78782: LD_INT 0
78784: PPUSH
// if not mc_bases [ base ] then
78785: LD_EXP 58
78789: PUSH
78790: LD_VAR 0 1
78794: ARRAY
78795: NOT
78796: IFFALSE 78800
// exit ;
78798: GO 78825
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78800: LD_ADDR_EXP 69
78804: PUSH
78805: LD_EXP 69
78809: PPUSH
78810: LD_VAR 0 1
78814: PPUSH
78815: LD_VAR 0 2
78819: PPUSH
78820: CALL_OW 1
78824: ST_TO_ADDR
// end ;
78825: LD_VAR 0 3
78829: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78830: LD_INT 0
78832: PPUSH
78833: PPUSH
78834: PPUSH
78835: PPUSH
// if not mc_bases [ base ] then
78836: LD_EXP 58
78840: PUSH
78841: LD_VAR 0 1
78845: ARRAY
78846: NOT
78847: IFFALSE 78851
// exit ;
78849: GO 78916
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78851: LD_ADDR_EXP 78
78855: PUSH
78856: LD_EXP 78
78860: PPUSH
78861: LD_VAR 0 1
78865: PUSH
78866: LD_EXP 78
78870: PUSH
78871: LD_VAR 0 1
78875: ARRAY
78876: PUSH
78877: LD_INT 1
78879: PLUS
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PPUSH
78885: LD_VAR 0 1
78889: PUSH
78890: LD_VAR 0 2
78894: PUSH
78895: LD_VAR 0 3
78899: PUSH
78900: LD_VAR 0 4
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: LIST
78909: LIST
78910: PPUSH
78911: CALL 20553 0 3
78915: ST_TO_ADDR
// end ;
78916: LD_VAR 0 5
78920: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78921: LD_INT 0
78923: PPUSH
// if not mc_bases [ base ] then
78924: LD_EXP 58
78928: PUSH
78929: LD_VAR 0 1
78933: ARRAY
78934: NOT
78935: IFFALSE 78939
// exit ;
78937: GO 78964
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78939: LD_ADDR_EXP 95
78943: PUSH
78944: LD_EXP 95
78948: PPUSH
78949: LD_VAR 0 1
78953: PPUSH
78954: LD_VAR 0 2
78958: PPUSH
78959: CALL_OW 1
78963: ST_TO_ADDR
// end ;
78964: LD_VAR 0 3
78968: RET
// export function MC_GetMinesField ( base ) ; begin
78969: LD_INT 0
78971: PPUSH
// result := mc_mines [ base ] ;
78972: LD_ADDR_VAR 0 2
78976: PUSH
78977: LD_EXP 71
78981: PUSH
78982: LD_VAR 0 1
78986: ARRAY
78987: ST_TO_ADDR
// end ;
78988: LD_VAR 0 2
78992: RET
// export function MC_GetProduceList ( base ) ; begin
78993: LD_INT 0
78995: PPUSH
// result := mc_produce [ base ] ;
78996: LD_ADDR_VAR 0 2
79000: PUSH
79001: LD_EXP 79
79005: PUSH
79006: LD_VAR 0 1
79010: ARRAY
79011: ST_TO_ADDR
// end ;
79012: LD_VAR 0 2
79016: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79017: LD_INT 0
79019: PPUSH
79020: PPUSH
// if not mc_bases then
79021: LD_EXP 58
79025: NOT
79026: IFFALSE 79030
// exit ;
79028: GO 79095
// if mc_bases [ base ] then
79030: LD_EXP 58
79034: PUSH
79035: LD_VAR 0 1
79039: ARRAY
79040: IFFALSE 79095
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79042: LD_ADDR_VAR 0 3
79046: PUSH
79047: LD_EXP 58
79051: PUSH
79052: LD_VAR 0 1
79056: ARRAY
79057: PPUSH
79058: LD_INT 30
79060: PUSH
79061: LD_VAR 0 2
79065: PUSH
79066: EMPTY
79067: LIST
79068: LIST
79069: PPUSH
79070: CALL_OW 72
79074: ST_TO_ADDR
// if result then
79075: LD_VAR 0 3
79079: IFFALSE 79095
// result := result [ 1 ] ;
79081: LD_ADDR_VAR 0 3
79085: PUSH
79086: LD_VAR 0 3
79090: PUSH
79091: LD_INT 1
79093: ARRAY
79094: ST_TO_ADDR
// end ; end ;
79095: LD_VAR 0 3
79099: RET
// export function MC_SetTame ( base , area ) ; begin
79100: LD_INT 0
79102: PPUSH
// if not mc_bases or not base then
79103: LD_EXP 58
79107: NOT
79108: PUSH
79109: LD_VAR 0 1
79113: NOT
79114: OR
79115: IFFALSE 79119
// exit ;
79117: GO 79144
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79119: LD_ADDR_EXP 86
79123: PUSH
79124: LD_EXP 86
79128: PPUSH
79129: LD_VAR 0 1
79133: PPUSH
79134: LD_VAR 0 2
79138: PPUSH
79139: CALL_OW 1
79143: ST_TO_ADDR
// end ;
79144: LD_VAR 0 3
79148: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79149: LD_INT 0
79151: PPUSH
79152: PPUSH
// if not mc_bases or not base then
79153: LD_EXP 58
79157: NOT
79158: PUSH
79159: LD_VAR 0 1
79163: NOT
79164: OR
79165: IFFALSE 79169
// exit ;
79167: GO 79271
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79169: LD_ADDR_VAR 0 4
79173: PUSH
79174: LD_EXP 58
79178: PUSH
79179: LD_VAR 0 1
79183: ARRAY
79184: PPUSH
79185: LD_INT 30
79187: PUSH
79188: LD_VAR 0 2
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PPUSH
79197: CALL_OW 72
79201: ST_TO_ADDR
// if not tmp then
79202: LD_VAR 0 4
79206: NOT
79207: IFFALSE 79211
// exit ;
79209: GO 79271
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79211: LD_ADDR_EXP 90
79215: PUSH
79216: LD_EXP 90
79220: PPUSH
79221: LD_VAR 0 1
79225: PPUSH
79226: LD_EXP 90
79230: PUSH
79231: LD_VAR 0 1
79235: ARRAY
79236: PPUSH
79237: LD_EXP 90
79241: PUSH
79242: LD_VAR 0 1
79246: ARRAY
79247: PUSH
79248: LD_INT 1
79250: PLUS
79251: PPUSH
79252: LD_VAR 0 4
79256: PUSH
79257: LD_INT 1
79259: ARRAY
79260: PPUSH
79261: CALL_OW 2
79265: PPUSH
79266: CALL_OW 1
79270: ST_TO_ADDR
// end ;
79271: LD_VAR 0 3
79275: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79276: LD_INT 0
79278: PPUSH
79279: PPUSH
// if not mc_bases or not base or not kinds then
79280: LD_EXP 58
79284: NOT
79285: PUSH
79286: LD_VAR 0 1
79290: NOT
79291: OR
79292: PUSH
79293: LD_VAR 0 2
79297: NOT
79298: OR
79299: IFFALSE 79303
// exit ;
79301: GO 79364
// for i in kinds do
79303: LD_ADDR_VAR 0 4
79307: PUSH
79308: LD_VAR 0 2
79312: PUSH
79313: FOR_IN
79314: IFFALSE 79362
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79316: LD_ADDR_EXP 92
79320: PUSH
79321: LD_EXP 92
79325: PPUSH
79326: LD_VAR 0 1
79330: PUSH
79331: LD_EXP 92
79335: PUSH
79336: LD_VAR 0 1
79340: ARRAY
79341: PUSH
79342: LD_INT 1
79344: PLUS
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PPUSH
79350: LD_VAR 0 4
79354: PPUSH
79355: CALL 20553 0 3
79359: ST_TO_ADDR
79360: GO 79313
79362: POP
79363: POP
// end ;
79364: LD_VAR 0 3
79368: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79369: LD_INT 0
79371: PPUSH
// if not mc_bases or not base or not areas then
79372: LD_EXP 58
79376: NOT
79377: PUSH
79378: LD_VAR 0 1
79382: NOT
79383: OR
79384: PUSH
79385: LD_VAR 0 2
79389: NOT
79390: OR
79391: IFFALSE 79395
// exit ;
79393: GO 79420
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79395: LD_ADDR_EXP 76
79399: PUSH
79400: LD_EXP 76
79404: PPUSH
79405: LD_VAR 0 1
79409: PPUSH
79410: LD_VAR 0 2
79414: PPUSH
79415: CALL_OW 1
79419: ST_TO_ADDR
// end ;
79420: LD_VAR 0 3
79424: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79425: LD_INT 0
79427: PPUSH
// if not mc_bases or not base or not teleports_exit then
79428: LD_EXP 58
79432: NOT
79433: PUSH
79434: LD_VAR 0 1
79438: NOT
79439: OR
79440: PUSH
79441: LD_VAR 0 2
79445: NOT
79446: OR
79447: IFFALSE 79451
// exit ;
79449: GO 79476
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79451: LD_ADDR_EXP 93
79455: PUSH
79456: LD_EXP 93
79460: PPUSH
79461: LD_VAR 0 1
79465: PPUSH
79466: LD_VAR 0 2
79470: PPUSH
79471: CALL_OW 1
79475: ST_TO_ADDR
// end ;
79476: LD_VAR 0 3
79480: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79481: LD_INT 0
79483: PPUSH
79484: PPUSH
79485: PPUSH
// if not mc_bases or not base or not ext_list then
79486: LD_EXP 58
79490: NOT
79491: PUSH
79492: LD_VAR 0 1
79496: NOT
79497: OR
79498: PUSH
79499: LD_VAR 0 5
79503: NOT
79504: OR
79505: IFFALSE 79509
// exit ;
79507: GO 79682
// tmp := GetFacExtXYD ( x , y , d ) ;
79509: LD_ADDR_VAR 0 8
79513: PUSH
79514: LD_VAR 0 2
79518: PPUSH
79519: LD_VAR 0 3
79523: PPUSH
79524: LD_VAR 0 4
79528: PPUSH
79529: CALL 53868 0 3
79533: ST_TO_ADDR
// if not tmp then
79534: LD_VAR 0 8
79538: NOT
79539: IFFALSE 79543
// exit ;
79541: GO 79682
// for i in tmp do
79543: LD_ADDR_VAR 0 7
79547: PUSH
79548: LD_VAR 0 8
79552: PUSH
79553: FOR_IN
79554: IFFALSE 79680
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79556: LD_ADDR_EXP 63
79560: PUSH
79561: LD_EXP 63
79565: PPUSH
79566: LD_VAR 0 1
79570: PPUSH
79571: LD_EXP 63
79575: PUSH
79576: LD_VAR 0 1
79580: ARRAY
79581: PPUSH
79582: LD_EXP 63
79586: PUSH
79587: LD_VAR 0 1
79591: ARRAY
79592: PUSH
79593: LD_INT 1
79595: PLUS
79596: PPUSH
79597: LD_VAR 0 5
79601: PUSH
79602: LD_INT 1
79604: ARRAY
79605: PUSH
79606: LD_VAR 0 7
79610: PUSH
79611: LD_INT 1
79613: ARRAY
79614: PUSH
79615: LD_VAR 0 7
79619: PUSH
79620: LD_INT 2
79622: ARRAY
79623: PUSH
79624: LD_VAR 0 7
79628: PUSH
79629: LD_INT 3
79631: ARRAY
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: PPUSH
79639: CALL_OW 2
79643: PPUSH
79644: CALL_OW 1
79648: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79649: LD_ADDR_VAR 0 5
79653: PUSH
79654: LD_VAR 0 5
79658: PPUSH
79659: LD_INT 1
79661: PPUSH
79662: CALL_OW 3
79666: ST_TO_ADDR
// if not ext_list then
79667: LD_VAR 0 5
79671: NOT
79672: IFFALSE 79678
// exit ;
79674: POP
79675: POP
79676: GO 79682
// end ;
79678: GO 79553
79680: POP
79681: POP
// end ;
79682: LD_VAR 0 6
79686: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79687: LD_INT 0
79689: PPUSH
// if not mc_bases or not base or not weapon_list then
79690: LD_EXP 58
79694: NOT
79695: PUSH
79696: LD_VAR 0 1
79700: NOT
79701: OR
79702: PUSH
79703: LD_VAR 0 2
79707: NOT
79708: OR
79709: IFFALSE 79713
// exit ;
79711: GO 79738
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79713: LD_ADDR_EXP 97
79717: PUSH
79718: LD_EXP 97
79722: PPUSH
79723: LD_VAR 0 1
79727: PPUSH
79728: LD_VAR 0 2
79732: PPUSH
79733: CALL_OW 1
79737: ST_TO_ADDR
// end ;
79738: LD_VAR 0 3
79742: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79743: LD_INT 0
79745: PPUSH
// if not mc_bases or not base or not tech_list then
79746: LD_EXP 58
79750: NOT
79751: PUSH
79752: LD_VAR 0 1
79756: NOT
79757: OR
79758: PUSH
79759: LD_VAR 0 2
79763: NOT
79764: OR
79765: IFFALSE 79769
// exit ;
79767: GO 79794
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79769: LD_ADDR_EXP 85
79773: PUSH
79774: LD_EXP 85
79778: PPUSH
79779: LD_VAR 0 1
79783: PPUSH
79784: LD_VAR 0 2
79788: PPUSH
79789: CALL_OW 1
79793: ST_TO_ADDR
// end ;
79794: LD_VAR 0 3
79798: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79799: LD_INT 0
79801: PPUSH
// if not mc_bases or not parking_area or not base then
79802: LD_EXP 58
79806: NOT
79807: PUSH
79808: LD_VAR 0 2
79812: NOT
79813: OR
79814: PUSH
79815: LD_VAR 0 1
79819: NOT
79820: OR
79821: IFFALSE 79825
// exit ;
79823: GO 79850
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79825: LD_ADDR_EXP 82
79829: PUSH
79830: LD_EXP 82
79834: PPUSH
79835: LD_VAR 0 1
79839: PPUSH
79840: LD_VAR 0 2
79844: PPUSH
79845: CALL_OW 1
79849: ST_TO_ADDR
// end ;
79850: LD_VAR 0 3
79854: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79855: LD_INT 0
79857: PPUSH
// if not mc_bases or not base or not scan_area then
79858: LD_EXP 58
79862: NOT
79863: PUSH
79864: LD_VAR 0 1
79868: NOT
79869: OR
79870: PUSH
79871: LD_VAR 0 2
79875: NOT
79876: OR
79877: IFFALSE 79881
// exit ;
79879: GO 79906
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79881: LD_ADDR_EXP 83
79885: PUSH
79886: LD_EXP 83
79890: PPUSH
79891: LD_VAR 0 1
79895: PPUSH
79896: LD_VAR 0 2
79900: PPUSH
79901: CALL_OW 1
79905: ST_TO_ADDR
// end ;
79906: LD_VAR 0 3
79910: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79911: LD_INT 0
79913: PPUSH
79914: PPUSH
// if not mc_bases or not base then
79915: LD_EXP 58
79919: NOT
79920: PUSH
79921: LD_VAR 0 1
79925: NOT
79926: OR
79927: IFFALSE 79931
// exit ;
79929: GO 79995
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79931: LD_ADDR_VAR 0 3
79935: PUSH
79936: LD_INT 1
79938: PUSH
79939: LD_INT 2
79941: PUSH
79942: LD_INT 3
79944: PUSH
79945: LD_INT 4
79947: PUSH
79948: LD_INT 11
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79958: LD_ADDR_EXP 85
79962: PUSH
79963: LD_EXP 85
79967: PPUSH
79968: LD_VAR 0 1
79972: PPUSH
79973: LD_EXP 85
79977: PUSH
79978: LD_VAR 0 1
79982: ARRAY
79983: PUSH
79984: LD_VAR 0 3
79988: DIFF
79989: PPUSH
79990: CALL_OW 1
79994: ST_TO_ADDR
// end ;
79995: LD_VAR 0 2
79999: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80000: LD_INT 0
80002: PPUSH
// result := mc_vehicles [ base ] ;
80003: LD_ADDR_VAR 0 3
80007: PUSH
80008: LD_EXP 77
80012: PUSH
80013: LD_VAR 0 1
80017: ARRAY
80018: ST_TO_ADDR
// if onlyCombat then
80019: LD_VAR 0 2
80023: IFFALSE 80188
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80025: LD_ADDR_VAR 0 3
80029: PUSH
80030: LD_VAR 0 3
80034: PUSH
80035: LD_VAR 0 3
80039: PPUSH
80040: LD_INT 2
80042: PUSH
80043: LD_INT 34
80045: PUSH
80046: LD_INT 12
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 34
80055: PUSH
80056: LD_INT 51
80058: PUSH
80059: EMPTY
80060: LIST
80061: LIST
80062: PUSH
80063: LD_INT 34
80065: PUSH
80066: LD_EXP 102
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 34
80077: PUSH
80078: LD_INT 32
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 34
80087: PUSH
80088: LD_INT 13
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 34
80097: PUSH
80098: LD_INT 52
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 34
80107: PUSH
80108: LD_INT 14
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: PUSH
80115: LD_INT 34
80117: PUSH
80118: LD_INT 53
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 34
80127: PUSH
80128: LD_EXP 101
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 34
80139: PUSH
80140: LD_INT 31
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PUSH
80147: LD_INT 34
80149: PUSH
80150: LD_INT 48
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 34
80159: PUSH
80160: LD_INT 8
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: PPUSH
80182: CALL_OW 72
80186: DIFF
80187: ST_TO_ADDR
// end ; end_of_file
80188: LD_VAR 0 3
80192: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80193: LD_INT 0
80195: PPUSH
80196: PPUSH
80197: PPUSH
// if not mc_bases or not skirmish then
80198: LD_EXP 58
80202: NOT
80203: PUSH
80204: LD_EXP 56
80208: NOT
80209: OR
80210: IFFALSE 80214
// exit ;
80212: GO 80379
// for i = 1 to mc_bases do
80214: LD_ADDR_VAR 0 4
80218: PUSH
80219: DOUBLE
80220: LD_INT 1
80222: DEC
80223: ST_TO_ADDR
80224: LD_EXP 58
80228: PUSH
80229: FOR_TO
80230: IFFALSE 80377
// begin if sci in mc_bases [ i ] then
80232: LD_VAR 0 2
80236: PUSH
80237: LD_EXP 58
80241: PUSH
80242: LD_VAR 0 4
80246: ARRAY
80247: IN
80248: IFFALSE 80375
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80250: LD_ADDR_EXP 87
80254: PUSH
80255: LD_EXP 87
80259: PPUSH
80260: LD_VAR 0 4
80264: PUSH
80265: LD_EXP 87
80269: PUSH
80270: LD_VAR 0 4
80274: ARRAY
80275: PUSH
80276: LD_INT 1
80278: PLUS
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PPUSH
80284: LD_VAR 0 1
80288: PPUSH
80289: CALL 20553 0 3
80293: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80294: LD_ADDR_VAR 0 5
80298: PUSH
80299: LD_EXP 58
80303: PUSH
80304: LD_VAR 0 4
80308: ARRAY
80309: PPUSH
80310: LD_INT 2
80312: PUSH
80313: LD_INT 30
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 30
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: LIST
80337: PPUSH
80338: CALL_OW 72
80342: PPUSH
80343: LD_VAR 0 1
80347: PPUSH
80348: CALL_OW 74
80352: ST_TO_ADDR
// if tmp then
80353: LD_VAR 0 5
80357: IFFALSE 80373
// ComStandNearbyBuilding ( ape , tmp ) ;
80359: LD_VAR 0 1
80363: PPUSH
80364: LD_VAR 0 5
80368: PPUSH
80369: CALL 15230 0 2
// break ;
80373: GO 80377
// end ; end ;
80375: GO 80229
80377: POP
80378: POP
// end ;
80379: LD_VAR 0 3
80383: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80384: LD_INT 0
80386: PPUSH
80387: PPUSH
80388: PPUSH
// if not mc_bases or not skirmish then
80389: LD_EXP 58
80393: NOT
80394: PUSH
80395: LD_EXP 56
80399: NOT
80400: OR
80401: IFFALSE 80405
// exit ;
80403: GO 80494
// for i = 1 to mc_bases do
80405: LD_ADDR_VAR 0 4
80409: PUSH
80410: DOUBLE
80411: LD_INT 1
80413: DEC
80414: ST_TO_ADDR
80415: LD_EXP 58
80419: PUSH
80420: FOR_TO
80421: IFFALSE 80492
// begin if building in mc_busy_turret_list [ i ] then
80423: LD_VAR 0 1
80427: PUSH
80428: LD_EXP 68
80432: PUSH
80433: LD_VAR 0 4
80437: ARRAY
80438: IN
80439: IFFALSE 80490
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80441: LD_ADDR_VAR 0 5
80445: PUSH
80446: LD_EXP 68
80450: PUSH
80451: LD_VAR 0 4
80455: ARRAY
80456: PUSH
80457: LD_VAR 0 1
80461: DIFF
80462: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80463: LD_ADDR_EXP 68
80467: PUSH
80468: LD_EXP 68
80472: PPUSH
80473: LD_VAR 0 4
80477: PPUSH
80478: LD_VAR 0 5
80482: PPUSH
80483: CALL_OW 1
80487: ST_TO_ADDR
// break ;
80488: GO 80492
// end ; end ;
80490: GO 80420
80492: POP
80493: POP
// end ;
80494: LD_VAR 0 3
80498: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80499: LD_INT 0
80501: PPUSH
80502: PPUSH
80503: PPUSH
// if not mc_bases or not skirmish then
80504: LD_EXP 58
80508: NOT
80509: PUSH
80510: LD_EXP 56
80514: NOT
80515: OR
80516: IFFALSE 80520
// exit ;
80518: GO 80719
// for i = 1 to mc_bases do
80520: LD_ADDR_VAR 0 5
80524: PUSH
80525: DOUBLE
80526: LD_INT 1
80528: DEC
80529: ST_TO_ADDR
80530: LD_EXP 58
80534: PUSH
80535: FOR_TO
80536: IFFALSE 80717
// if building in mc_bases [ i ] then
80538: LD_VAR 0 1
80542: PUSH
80543: LD_EXP 58
80547: PUSH
80548: LD_VAR 0 5
80552: ARRAY
80553: IN
80554: IFFALSE 80715
// begin tmp := mc_bases [ i ] diff building ;
80556: LD_ADDR_VAR 0 6
80560: PUSH
80561: LD_EXP 58
80565: PUSH
80566: LD_VAR 0 5
80570: ARRAY
80571: PUSH
80572: LD_VAR 0 1
80576: DIFF
80577: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80578: LD_ADDR_EXP 58
80582: PUSH
80583: LD_EXP 58
80587: PPUSH
80588: LD_VAR 0 5
80592: PPUSH
80593: LD_VAR 0 6
80597: PPUSH
80598: CALL_OW 1
80602: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80603: LD_VAR 0 1
80607: PUSH
80608: LD_EXP 66
80612: PUSH
80613: LD_VAR 0 5
80617: ARRAY
80618: IN
80619: IFFALSE 80658
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80621: LD_ADDR_EXP 66
80625: PUSH
80626: LD_EXP 66
80630: PPUSH
80631: LD_VAR 0 5
80635: PPUSH
80636: LD_EXP 66
80640: PUSH
80641: LD_VAR 0 5
80645: ARRAY
80646: PUSH
80647: LD_VAR 0 1
80651: DIFF
80652: PPUSH
80653: CALL_OW 1
80657: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80658: LD_VAR 0 1
80662: PUSH
80663: LD_EXP 67
80667: PUSH
80668: LD_VAR 0 5
80672: ARRAY
80673: IN
80674: IFFALSE 80713
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80676: LD_ADDR_EXP 67
80680: PUSH
80681: LD_EXP 67
80685: PPUSH
80686: LD_VAR 0 5
80690: PPUSH
80691: LD_EXP 67
80695: PUSH
80696: LD_VAR 0 5
80700: ARRAY
80701: PUSH
80702: LD_VAR 0 1
80706: DIFF
80707: PPUSH
80708: CALL_OW 1
80712: ST_TO_ADDR
// break ;
80713: GO 80717
// end ;
80715: GO 80535
80717: POP
80718: POP
// end ;
80719: LD_VAR 0 4
80723: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80724: LD_INT 0
80726: PPUSH
80727: PPUSH
80728: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80729: LD_EXP 58
80733: NOT
80734: PUSH
80735: LD_EXP 56
80739: NOT
80740: OR
80741: PUSH
80742: LD_VAR 0 3
80746: PUSH
80747: LD_EXP 84
80751: IN
80752: NOT
80753: OR
80754: IFFALSE 80758
// exit ;
80756: GO 80881
// for i = 1 to mc_vehicles do
80758: LD_ADDR_VAR 0 6
80762: PUSH
80763: DOUBLE
80764: LD_INT 1
80766: DEC
80767: ST_TO_ADDR
80768: LD_EXP 77
80772: PUSH
80773: FOR_TO
80774: IFFALSE 80879
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80776: LD_VAR 0 2
80780: PUSH
80781: LD_EXP 77
80785: PUSH
80786: LD_VAR 0 6
80790: ARRAY
80791: IN
80792: PUSH
80793: LD_VAR 0 1
80797: PUSH
80798: LD_EXP 77
80802: PUSH
80803: LD_VAR 0 6
80807: ARRAY
80808: IN
80809: OR
80810: IFFALSE 80877
// begin tmp := mc_vehicles [ i ] diff old ;
80812: LD_ADDR_VAR 0 7
80816: PUSH
80817: LD_EXP 77
80821: PUSH
80822: LD_VAR 0 6
80826: ARRAY
80827: PUSH
80828: LD_VAR 0 2
80832: DIFF
80833: ST_TO_ADDR
// tmp := tmp diff new ;
80834: LD_ADDR_VAR 0 7
80838: PUSH
80839: LD_VAR 0 7
80843: PUSH
80844: LD_VAR 0 1
80848: DIFF
80849: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80850: LD_ADDR_EXP 77
80854: PUSH
80855: LD_EXP 77
80859: PPUSH
80860: LD_VAR 0 6
80864: PPUSH
80865: LD_VAR 0 7
80869: PPUSH
80870: CALL_OW 1
80874: ST_TO_ADDR
// break ;
80875: GO 80879
// end ;
80877: GO 80773
80879: POP
80880: POP
// end ;
80881: LD_VAR 0 5
80885: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80886: LD_INT 0
80888: PPUSH
80889: PPUSH
80890: PPUSH
80891: PPUSH
// if not mc_bases or not skirmish then
80892: LD_EXP 58
80896: NOT
80897: PUSH
80898: LD_EXP 56
80902: NOT
80903: OR
80904: IFFALSE 80908
// exit ;
80906: GO 81291
// side := GetSide ( vehicle ) ;
80908: LD_ADDR_VAR 0 5
80912: PUSH
80913: LD_VAR 0 1
80917: PPUSH
80918: CALL_OW 255
80922: ST_TO_ADDR
// for i = 1 to mc_bases do
80923: LD_ADDR_VAR 0 4
80927: PUSH
80928: DOUBLE
80929: LD_INT 1
80931: DEC
80932: ST_TO_ADDR
80933: LD_EXP 58
80937: PUSH
80938: FOR_TO
80939: IFFALSE 81289
// begin if factory in mc_bases [ i ] then
80941: LD_VAR 0 2
80945: PUSH
80946: LD_EXP 58
80950: PUSH
80951: LD_VAR 0 4
80955: ARRAY
80956: IN
80957: IFFALSE 81287
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
80959: LD_EXP 80
80963: PUSH
80964: LD_VAR 0 4
80968: ARRAY
80969: PUSH
80970: LD_EXP 69
80974: PUSH
80975: LD_VAR 0 4
80979: ARRAY
80980: LESS
80981: PUSH
80982: LD_VAR 0 1
80986: PPUSH
80987: CALL_OW 264
80991: PUSH
80992: LD_INT 31
80994: PUSH
80995: LD_INT 32
80997: PUSH
80998: LD_INT 51
81000: PUSH
81001: LD_EXP 102
81005: PUSH
81006: LD_INT 12
81008: PUSH
81009: LD_INT 30
81011: PUSH
81012: LD_EXP 101
81016: PUSH
81017: LD_INT 11
81019: PUSH
81020: LD_INT 53
81022: PUSH
81023: LD_INT 14
81025: PUSH
81026: LD_EXP 105
81030: PUSH
81031: LD_INT 29
81033: PUSH
81034: LD_EXP 103
81038: PUSH
81039: LD_INT 13
81041: PUSH
81042: LD_INT 52
81044: PUSH
81045: LD_INT 48
81047: PUSH
81048: LD_INT 8
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: LIST
81064: LIST
81065: LIST
81066: LIST
81067: LIST
81068: LIST
81069: IN
81070: NOT
81071: AND
81072: IFFALSE 81113
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
81074: LD_ADDR_EXP 80
81078: PUSH
81079: LD_EXP 80
81083: PPUSH
81084: LD_VAR 0 4
81088: PPUSH
81089: LD_EXP 80
81093: PUSH
81094: LD_VAR 0 4
81098: ARRAY
81099: PUSH
81100: LD_VAR 0 1
81104: ADD
81105: PPUSH
81106: CALL_OW 1
81110: ST_TO_ADDR
81111: GO 81157
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81113: LD_ADDR_EXP 77
81117: PUSH
81118: LD_EXP 77
81122: PPUSH
81123: LD_VAR 0 4
81127: PUSH
81128: LD_EXP 77
81132: PUSH
81133: LD_VAR 0 4
81137: ARRAY
81138: PUSH
81139: LD_INT 1
81141: PLUS
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PPUSH
81147: LD_VAR 0 1
81151: PPUSH
81152: CALL 20553 0 3
81156: ST_TO_ADDR
// if not mc_scan [ i ] then
81157: LD_EXP 81
81161: PUSH
81162: LD_VAR 0 4
81166: ARRAY
81167: NOT
81168: IFFALSE 81287
// begin if GetControl ( vehicle ) = control_remote then
81170: LD_VAR 0 1
81174: PPUSH
81175: CALL_OW 263
81179: PUSH
81180: LD_INT 2
81182: EQUAL
81183: IFFALSE 81203
// repeat wait ( 0 0$1 ) ;
81185: LD_INT 35
81187: PPUSH
81188: CALL_OW 67
// until IsControledBy ( vehicle ) ;
81192: LD_VAR 0 1
81196: PPUSH
81197: CALL_OW 312
81201: IFFALSE 81185
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81203: LD_VAR 0 1
81207: PPUSH
81208: LD_EXP 82
81212: PUSH
81213: LD_VAR 0 4
81217: ARRAY
81218: PPUSH
81219: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81223: LD_VAR 0 1
81227: PPUSH
81228: CALL_OW 263
81232: PUSH
81233: LD_INT 1
81235: NONEQUAL
81236: IFFALSE 81240
// break ;
81238: GO 81289
// repeat wait ( 0 0$1 ) ;
81240: LD_INT 35
81242: PPUSH
81243: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81247: LD_VAR 0 1
81251: PPUSH
81252: LD_EXP 82
81256: PUSH
81257: LD_VAR 0 4
81261: ARRAY
81262: PPUSH
81263: CALL_OW 308
81267: IFFALSE 81240
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81269: LD_VAR 0 1
81273: PPUSH
81274: CALL_OW 311
81278: PPUSH
81279: CALL_OW 121
// exit ;
81283: POP
81284: POP
81285: GO 81291
// end ; end ; end ;
81287: GO 80938
81289: POP
81290: POP
// end ;
81291: LD_VAR 0 3
81295: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81296: LD_INT 0
81298: PPUSH
81299: PPUSH
81300: PPUSH
81301: PPUSH
// if not mc_bases or not skirmish then
81302: LD_EXP 58
81306: NOT
81307: PUSH
81308: LD_EXP 56
81312: NOT
81313: OR
81314: IFFALSE 81318
// exit ;
81316: GO 81671
// repeat wait ( 0 0$1 ) ;
81318: LD_INT 35
81320: PPUSH
81321: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81325: LD_VAR 0 2
81329: PPUSH
81330: LD_VAR 0 3
81334: PPUSH
81335: CALL_OW 284
81339: IFFALSE 81318
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81341: LD_VAR 0 2
81345: PPUSH
81346: LD_VAR 0 3
81350: PPUSH
81351: CALL_OW 283
81355: PUSH
81356: LD_INT 4
81358: EQUAL
81359: IFFALSE 81363
// exit ;
81361: GO 81671
// for i = 1 to mc_bases do
81363: LD_ADDR_VAR 0 7
81367: PUSH
81368: DOUBLE
81369: LD_INT 1
81371: DEC
81372: ST_TO_ADDR
81373: LD_EXP 58
81377: PUSH
81378: FOR_TO
81379: IFFALSE 81669
// begin if mc_crates_area [ i ] then
81381: LD_EXP 76
81385: PUSH
81386: LD_VAR 0 7
81390: ARRAY
81391: IFFALSE 81502
// for j in mc_crates_area [ i ] do
81393: LD_ADDR_VAR 0 8
81397: PUSH
81398: LD_EXP 76
81402: PUSH
81403: LD_VAR 0 7
81407: ARRAY
81408: PUSH
81409: FOR_IN
81410: IFFALSE 81500
// if InArea ( x , y , j ) then
81412: LD_VAR 0 2
81416: PPUSH
81417: LD_VAR 0 3
81421: PPUSH
81422: LD_VAR 0 8
81426: PPUSH
81427: CALL_OW 309
81431: IFFALSE 81498
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81433: LD_ADDR_EXP 74
81437: PUSH
81438: LD_EXP 74
81442: PPUSH
81443: LD_VAR 0 7
81447: PUSH
81448: LD_EXP 74
81452: PUSH
81453: LD_VAR 0 7
81457: ARRAY
81458: PUSH
81459: LD_INT 1
81461: PLUS
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PPUSH
81467: LD_VAR 0 4
81471: PUSH
81472: LD_VAR 0 2
81476: PUSH
81477: LD_VAR 0 3
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: LIST
81486: PPUSH
81487: CALL 20553 0 3
81491: ST_TO_ADDR
// exit ;
81492: POP
81493: POP
81494: POP
81495: POP
81496: GO 81671
// end ;
81498: GO 81409
81500: POP
81501: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81502: LD_ADDR_VAR 0 9
81506: PUSH
81507: LD_EXP 58
81511: PUSH
81512: LD_VAR 0 7
81516: ARRAY
81517: PPUSH
81518: LD_INT 2
81520: PUSH
81521: LD_INT 30
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 30
81533: PUSH
81534: LD_INT 1
81536: PUSH
81537: EMPTY
81538: LIST
81539: LIST
81540: PUSH
81541: EMPTY
81542: LIST
81543: LIST
81544: LIST
81545: PPUSH
81546: CALL_OW 72
81550: ST_TO_ADDR
// if not depot then
81551: LD_VAR 0 9
81555: NOT
81556: IFFALSE 81560
// continue ;
81558: GO 81378
// for j in depot do
81560: LD_ADDR_VAR 0 8
81564: PUSH
81565: LD_VAR 0 9
81569: PUSH
81570: FOR_IN
81571: IFFALSE 81665
// if GetDistUnitXY ( j , x , y ) < 30 then
81573: LD_VAR 0 8
81577: PPUSH
81578: LD_VAR 0 2
81582: PPUSH
81583: LD_VAR 0 3
81587: PPUSH
81588: CALL_OW 297
81592: PUSH
81593: LD_INT 30
81595: LESS
81596: IFFALSE 81663
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81598: LD_ADDR_EXP 74
81602: PUSH
81603: LD_EXP 74
81607: PPUSH
81608: LD_VAR 0 7
81612: PUSH
81613: LD_EXP 74
81617: PUSH
81618: LD_VAR 0 7
81622: ARRAY
81623: PUSH
81624: LD_INT 1
81626: PLUS
81627: PUSH
81628: EMPTY
81629: LIST
81630: LIST
81631: PPUSH
81632: LD_VAR 0 4
81636: PUSH
81637: LD_VAR 0 2
81641: PUSH
81642: LD_VAR 0 3
81646: PUSH
81647: EMPTY
81648: LIST
81649: LIST
81650: LIST
81651: PPUSH
81652: CALL 20553 0 3
81656: ST_TO_ADDR
// exit ;
81657: POP
81658: POP
81659: POP
81660: POP
81661: GO 81671
// end ;
81663: GO 81570
81665: POP
81666: POP
// end ;
81667: GO 81378
81669: POP
81670: POP
// end ;
81671: LD_VAR 0 6
81675: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81676: LD_INT 0
81678: PPUSH
81679: PPUSH
81680: PPUSH
81681: PPUSH
// if not mc_bases or not skirmish then
81682: LD_EXP 58
81686: NOT
81687: PUSH
81688: LD_EXP 56
81692: NOT
81693: OR
81694: IFFALSE 81698
// exit ;
81696: GO 81975
// side := GetSide ( lab ) ;
81698: LD_ADDR_VAR 0 4
81702: PUSH
81703: LD_VAR 0 2
81707: PPUSH
81708: CALL_OW 255
81712: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81713: LD_VAR 0 4
81717: PUSH
81718: LD_EXP 84
81722: IN
81723: NOT
81724: PUSH
81725: LD_EXP 85
81729: NOT
81730: OR
81731: PUSH
81732: LD_EXP 58
81736: NOT
81737: OR
81738: IFFALSE 81742
// exit ;
81740: GO 81975
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81742: LD_ADDR_EXP 85
81746: PUSH
81747: LD_EXP 85
81751: PPUSH
81752: LD_VAR 0 4
81756: PPUSH
81757: LD_EXP 85
81761: PUSH
81762: LD_VAR 0 4
81766: ARRAY
81767: PUSH
81768: LD_VAR 0 1
81772: DIFF
81773: PPUSH
81774: CALL_OW 1
81778: ST_TO_ADDR
// for i = 1 to mc_bases do
81779: LD_ADDR_VAR 0 5
81783: PUSH
81784: DOUBLE
81785: LD_INT 1
81787: DEC
81788: ST_TO_ADDR
81789: LD_EXP 58
81793: PUSH
81794: FOR_TO
81795: IFFALSE 81973
// begin if lab in mc_bases [ i ] then
81797: LD_VAR 0 2
81801: PUSH
81802: LD_EXP 58
81806: PUSH
81807: LD_VAR 0 5
81811: ARRAY
81812: IN
81813: IFFALSE 81971
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81815: LD_VAR 0 1
81819: PUSH
81820: LD_INT 11
81822: PUSH
81823: LD_INT 4
81825: PUSH
81826: LD_INT 3
81828: PUSH
81829: LD_INT 2
81831: PUSH
81832: EMPTY
81833: LIST
81834: LIST
81835: LIST
81836: LIST
81837: IN
81838: PUSH
81839: LD_EXP 88
81843: PUSH
81844: LD_VAR 0 5
81848: ARRAY
81849: AND
81850: IFFALSE 81971
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81852: LD_ADDR_VAR 0 6
81856: PUSH
81857: LD_EXP 88
81861: PUSH
81862: LD_VAR 0 5
81866: ARRAY
81867: PUSH
81868: LD_INT 1
81870: ARRAY
81871: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81872: LD_ADDR_EXP 88
81876: PUSH
81877: LD_EXP 88
81881: PPUSH
81882: LD_VAR 0 5
81886: PPUSH
81887: EMPTY
81888: PPUSH
81889: CALL_OW 1
81893: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81894: LD_VAR 0 6
81898: PPUSH
81899: LD_INT 0
81901: PPUSH
81902: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81906: LD_VAR 0 6
81910: PPUSH
81911: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81915: LD_ADDR_EXP 87
81919: PUSH
81920: LD_EXP 87
81924: PPUSH
81925: LD_VAR 0 5
81929: PPUSH
81930: LD_EXP 87
81934: PUSH
81935: LD_VAR 0 5
81939: ARRAY
81940: PPUSH
81941: LD_INT 1
81943: PPUSH
81944: LD_VAR 0 6
81948: PPUSH
81949: CALL_OW 2
81953: PPUSH
81954: CALL_OW 1
81958: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81959: LD_VAR 0 5
81963: PPUSH
81964: LD_INT 112
81966: PPUSH
81967: CALL 59444 0 2
// end ; end ; end ;
81971: GO 81794
81973: POP
81974: POP
// end ;
81975: LD_VAR 0 3
81979: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81980: LD_INT 0
81982: PPUSH
81983: PPUSH
81984: PPUSH
81985: PPUSH
81986: PPUSH
81987: PPUSH
81988: PPUSH
81989: PPUSH
// if not mc_bases or not skirmish then
81990: LD_EXP 58
81994: NOT
81995: PUSH
81996: LD_EXP 56
82000: NOT
82001: OR
82002: IFFALSE 82006
// exit ;
82004: GO 83022
// for i = 1 to mc_bases do
82006: LD_ADDR_VAR 0 3
82010: PUSH
82011: DOUBLE
82012: LD_INT 1
82014: DEC
82015: ST_TO_ADDR
82016: LD_EXP 58
82020: PUSH
82021: FOR_TO
82022: IFFALSE 83020
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82024: LD_VAR 0 1
82028: PUSH
82029: LD_EXP 58
82033: PUSH
82034: LD_VAR 0 3
82038: ARRAY
82039: IN
82040: PUSH
82041: LD_VAR 0 1
82045: PUSH
82046: LD_EXP 65
82050: PUSH
82051: LD_VAR 0 3
82055: ARRAY
82056: IN
82057: OR
82058: PUSH
82059: LD_VAR 0 1
82063: PUSH
82064: LD_EXP 77
82068: PUSH
82069: LD_VAR 0 3
82073: ARRAY
82074: IN
82075: OR
82076: PUSH
82077: LD_VAR 0 1
82081: PUSH
82082: LD_EXP 87
82086: PUSH
82087: LD_VAR 0 3
82091: ARRAY
82092: IN
82093: OR
82094: PUSH
82095: LD_VAR 0 1
82099: PUSH
82100: LD_EXP 88
82104: PUSH
82105: LD_VAR 0 3
82109: ARRAY
82110: IN
82111: OR
82112: IFFALSE 83018
// begin if un in mc_ape [ i ] then
82114: LD_VAR 0 1
82118: PUSH
82119: LD_EXP 87
82123: PUSH
82124: LD_VAR 0 3
82128: ARRAY
82129: IN
82130: IFFALSE 82169
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82132: LD_ADDR_EXP 87
82136: PUSH
82137: LD_EXP 87
82141: PPUSH
82142: LD_VAR 0 3
82146: PPUSH
82147: LD_EXP 87
82151: PUSH
82152: LD_VAR 0 3
82156: ARRAY
82157: PUSH
82158: LD_VAR 0 1
82162: DIFF
82163: PPUSH
82164: CALL_OW 1
82168: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82169: LD_VAR 0 1
82173: PUSH
82174: LD_EXP 88
82178: PUSH
82179: LD_VAR 0 3
82183: ARRAY
82184: IN
82185: IFFALSE 82209
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82187: LD_ADDR_EXP 88
82191: PUSH
82192: LD_EXP 88
82196: PPUSH
82197: LD_VAR 0 3
82201: PPUSH
82202: EMPTY
82203: PPUSH
82204: CALL_OW 1
82208: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
82209: LD_VAR 0 1
82213: PPUSH
82214: CALL_OW 247
82218: PUSH
82219: LD_INT 2
82221: EQUAL
82222: PUSH
82223: LD_VAR 0 1
82227: PPUSH
82228: CALL_OW 110
82232: PUSH
82233: LD_INT 20
82235: EQUAL
82236: PUSH
82237: LD_VAR 0 1
82241: PUSH
82242: LD_EXP 80
82246: PUSH
82247: LD_VAR 0 3
82251: ARRAY
82252: IN
82253: OR
82254: AND
82255: IFFALSE 82358
// begin fac := MC_GetBuilding ( i , b_factory ) ;
82257: LD_ADDR_VAR 0 8
82261: PUSH
82262: LD_VAR 0 3
82266: PPUSH
82267: LD_INT 3
82269: PPUSH
82270: CALL 79017 0 2
82274: ST_TO_ADDR
// if fac then
82275: LD_VAR 0 8
82279: IFFALSE 82358
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82281: LD_ADDR_VAR 0 9
82285: PUSH
82286: LD_VAR 0 8
82290: PPUSH
82291: LD_VAR 0 1
82295: PPUSH
82296: CALL_OW 265
82300: PPUSH
82301: LD_VAR 0 1
82305: PPUSH
82306: CALL_OW 262
82310: PPUSH
82311: LD_VAR 0 1
82315: PPUSH
82316: CALL_OW 263
82320: PPUSH
82321: LD_VAR 0 1
82325: PPUSH
82326: CALL_OW 264
82330: PPUSH
82331: CALL 18153 0 5
82335: ST_TO_ADDR
// if components then
82336: LD_VAR 0 9
82340: IFFALSE 82356
// MC_InsertProduceList ( i , components ) ;
82342: LD_VAR 0 3
82346: PPUSH
82347: LD_VAR 0 9
82351: PPUSH
82352: CALL 78645 0 2
// break ;
82356: GO 83020
// end ; end ; if GetType ( un ) = unit_building then
82358: LD_VAR 0 1
82362: PPUSH
82363: CALL_OW 247
82367: PUSH
82368: LD_INT 3
82370: EQUAL
82371: IFFALSE 82686
// begin btype := GetBType ( un ) ;
82373: LD_ADDR_VAR 0 5
82377: PUSH
82378: LD_VAR 0 1
82382: PPUSH
82383: CALL_OW 266
82387: ST_TO_ADDR
// if btype = b_warehouse then
82388: LD_VAR 0 5
82392: PUSH
82393: LD_INT 1
82395: EQUAL
82396: IFFALSE 82414
// begin btype := b_depot ;
82398: LD_ADDR_VAR 0 5
82402: PUSH
82403: LD_INT 0
82405: ST_TO_ADDR
// pos := 1 ;
82406: LD_ADDR_VAR 0 6
82410: PUSH
82411: LD_INT 1
82413: ST_TO_ADDR
// end ; if btype = b_factory then
82414: LD_VAR 0 5
82418: PUSH
82419: LD_INT 3
82421: EQUAL
82422: IFFALSE 82440
// begin btype := b_workshop ;
82424: LD_ADDR_VAR 0 5
82428: PUSH
82429: LD_INT 2
82431: ST_TO_ADDR
// pos := 1 ;
82432: LD_ADDR_VAR 0 6
82436: PUSH
82437: LD_INT 1
82439: ST_TO_ADDR
// end ; if btype = b_barracks then
82440: LD_VAR 0 5
82444: PUSH
82445: LD_INT 5
82447: EQUAL
82448: IFFALSE 82458
// btype := b_armoury ;
82450: LD_ADDR_VAR 0 5
82454: PUSH
82455: LD_INT 4
82457: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82458: LD_VAR 0 5
82462: PUSH
82463: LD_INT 7
82465: PUSH
82466: LD_INT 8
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: IN
82473: IFFALSE 82483
// btype := b_lab ;
82475: LD_ADDR_VAR 0 5
82479: PUSH
82480: LD_INT 6
82482: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82483: LD_ADDR_EXP 63
82487: PUSH
82488: LD_EXP 63
82492: PPUSH
82493: LD_VAR 0 3
82497: PUSH
82498: LD_EXP 63
82502: PUSH
82503: LD_VAR 0 3
82507: ARRAY
82508: PUSH
82509: LD_INT 1
82511: PLUS
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PPUSH
82517: LD_VAR 0 5
82521: PUSH
82522: LD_VAR 0 1
82526: PPUSH
82527: CALL_OW 250
82531: PUSH
82532: LD_VAR 0 1
82536: PPUSH
82537: CALL_OW 251
82541: PUSH
82542: LD_VAR 0 1
82546: PPUSH
82547: CALL_OW 254
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: LIST
82556: LIST
82557: PPUSH
82558: CALL 20553 0 3
82562: ST_TO_ADDR
// if pos = 1 then
82563: LD_VAR 0 6
82567: PUSH
82568: LD_INT 1
82570: EQUAL
82571: IFFALSE 82686
// begin tmp := mc_build_list [ i ] ;
82573: LD_ADDR_VAR 0 7
82577: PUSH
82578: LD_EXP 63
82582: PUSH
82583: LD_VAR 0 3
82587: ARRAY
82588: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82589: LD_VAR 0 7
82593: PPUSH
82594: LD_INT 2
82596: PUSH
82597: LD_INT 30
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 30
82609: PUSH
82610: LD_INT 1
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: LIST
82621: PPUSH
82622: CALL_OW 72
82626: IFFALSE 82636
// pos := 2 ;
82628: LD_ADDR_VAR 0 6
82632: PUSH
82633: LD_INT 2
82635: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82636: LD_ADDR_VAR 0 7
82640: PUSH
82641: LD_VAR 0 7
82645: PPUSH
82646: LD_VAR 0 6
82650: PPUSH
82651: LD_VAR 0 7
82655: PPUSH
82656: CALL 20879 0 3
82660: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82661: LD_ADDR_EXP 63
82665: PUSH
82666: LD_EXP 63
82670: PPUSH
82671: LD_VAR 0 3
82675: PPUSH
82676: LD_VAR 0 7
82680: PPUSH
82681: CALL_OW 1
82685: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82686: LD_VAR 0 1
82690: PUSH
82691: LD_EXP 58
82695: PUSH
82696: LD_VAR 0 3
82700: ARRAY
82701: IN
82702: IFFALSE 82741
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82704: LD_ADDR_EXP 58
82708: PUSH
82709: LD_EXP 58
82713: PPUSH
82714: LD_VAR 0 3
82718: PPUSH
82719: LD_EXP 58
82723: PUSH
82724: LD_VAR 0 3
82728: ARRAY
82729: PUSH
82730: LD_VAR 0 1
82734: DIFF
82735: PPUSH
82736: CALL_OW 1
82740: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82741: LD_VAR 0 1
82745: PUSH
82746: LD_EXP 65
82750: PUSH
82751: LD_VAR 0 3
82755: ARRAY
82756: IN
82757: IFFALSE 82796
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82759: LD_ADDR_EXP 65
82763: PUSH
82764: LD_EXP 65
82768: PPUSH
82769: LD_VAR 0 3
82773: PPUSH
82774: LD_EXP 65
82778: PUSH
82779: LD_VAR 0 3
82783: ARRAY
82784: PUSH
82785: LD_VAR 0 1
82789: DIFF
82790: PPUSH
82791: CALL_OW 1
82795: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82796: LD_VAR 0 1
82800: PUSH
82801: LD_EXP 77
82805: PUSH
82806: LD_VAR 0 3
82810: ARRAY
82811: IN
82812: IFFALSE 82851
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82814: LD_ADDR_EXP 77
82818: PUSH
82819: LD_EXP 77
82823: PPUSH
82824: LD_VAR 0 3
82828: PPUSH
82829: LD_EXP 77
82833: PUSH
82834: LD_VAR 0 3
82838: ARRAY
82839: PUSH
82840: LD_VAR 0 1
82844: DIFF
82845: PPUSH
82846: CALL_OW 1
82850: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82851: LD_VAR 0 1
82855: PUSH
82856: LD_EXP 80
82860: PUSH
82861: LD_VAR 0 3
82865: ARRAY
82866: IN
82867: IFFALSE 82906
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82869: LD_ADDR_EXP 80
82873: PUSH
82874: LD_EXP 80
82878: PPUSH
82879: LD_VAR 0 3
82883: PPUSH
82884: LD_EXP 80
82888: PUSH
82889: LD_VAR 0 3
82893: ARRAY
82894: PUSH
82895: LD_VAR 0 1
82899: DIFF
82900: PPUSH
82901: CALL_OW 1
82905: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82906: LD_VAR 0 1
82910: PUSH
82911: LD_EXP 67
82915: PUSH
82916: LD_VAR 0 3
82920: ARRAY
82921: IN
82922: IFFALSE 82961
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82924: LD_ADDR_EXP 67
82928: PUSH
82929: LD_EXP 67
82933: PPUSH
82934: LD_VAR 0 3
82938: PPUSH
82939: LD_EXP 67
82943: PUSH
82944: LD_VAR 0 3
82948: ARRAY
82949: PUSH
82950: LD_VAR 0 1
82954: DIFF
82955: PPUSH
82956: CALL_OW 1
82960: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82961: LD_VAR 0 1
82965: PUSH
82966: LD_EXP 66
82970: PUSH
82971: LD_VAR 0 3
82975: ARRAY
82976: IN
82977: IFFALSE 83016
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82979: LD_ADDR_EXP 66
82983: PUSH
82984: LD_EXP 66
82988: PPUSH
82989: LD_VAR 0 3
82993: PPUSH
82994: LD_EXP 66
82998: PUSH
82999: LD_VAR 0 3
83003: ARRAY
83004: PUSH
83005: LD_VAR 0 1
83009: DIFF
83010: PPUSH
83011: CALL_OW 1
83015: ST_TO_ADDR
// end ; break ;
83016: GO 83020
// end ;
83018: GO 82021
83020: POP
83021: POP
// end ;
83022: LD_VAR 0 2
83026: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83027: LD_INT 0
83029: PPUSH
83030: PPUSH
83031: PPUSH
// if not mc_bases or not skirmish then
83032: LD_EXP 58
83036: NOT
83037: PUSH
83038: LD_EXP 56
83042: NOT
83043: OR
83044: IFFALSE 83048
// exit ;
83046: GO 83263
// for i = 1 to mc_bases do
83048: LD_ADDR_VAR 0 3
83052: PUSH
83053: DOUBLE
83054: LD_INT 1
83056: DEC
83057: ST_TO_ADDR
83058: LD_EXP 58
83062: PUSH
83063: FOR_TO
83064: IFFALSE 83261
// begin if building in mc_construct_list [ i ] then
83066: LD_VAR 0 1
83070: PUSH
83071: LD_EXP 65
83075: PUSH
83076: LD_VAR 0 3
83080: ARRAY
83081: IN
83082: IFFALSE 83259
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83084: LD_ADDR_EXP 65
83088: PUSH
83089: LD_EXP 65
83093: PPUSH
83094: LD_VAR 0 3
83098: PPUSH
83099: LD_EXP 65
83103: PUSH
83104: LD_VAR 0 3
83108: ARRAY
83109: PUSH
83110: LD_VAR 0 1
83114: DIFF
83115: PPUSH
83116: CALL_OW 1
83120: ST_TO_ADDR
// if building in mc_lab [ i ] then
83121: LD_VAR 0 1
83125: PUSH
83126: LD_EXP 91
83130: PUSH
83131: LD_VAR 0 3
83135: ARRAY
83136: IN
83137: IFFALSE 83192
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83139: LD_ADDR_EXP 92
83143: PUSH
83144: LD_EXP 92
83148: PPUSH
83149: LD_VAR 0 3
83153: PPUSH
83154: LD_EXP 92
83158: PUSH
83159: LD_VAR 0 3
83163: ARRAY
83164: PPUSH
83165: LD_INT 1
83167: PPUSH
83168: LD_EXP 92
83172: PUSH
83173: LD_VAR 0 3
83177: ARRAY
83178: PPUSH
83179: LD_INT 0
83181: PPUSH
83182: CALL 19971 0 4
83186: PPUSH
83187: CALL_OW 1
83191: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83192: LD_VAR 0 1
83196: PUSH
83197: LD_EXP 58
83201: PUSH
83202: LD_VAR 0 3
83206: ARRAY
83207: IN
83208: NOT
83209: IFFALSE 83255
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83211: LD_ADDR_EXP 58
83215: PUSH
83216: LD_EXP 58
83220: PPUSH
83221: LD_VAR 0 3
83225: PUSH
83226: LD_EXP 58
83230: PUSH
83231: LD_VAR 0 3
83235: ARRAY
83236: PUSH
83237: LD_INT 1
83239: PLUS
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PPUSH
83245: LD_VAR 0 1
83249: PPUSH
83250: CALL 20553 0 3
83254: ST_TO_ADDR
// exit ;
83255: POP
83256: POP
83257: GO 83263
// end ; end ;
83259: GO 83063
83261: POP
83262: POP
// end ;
83263: LD_VAR 0 2
83267: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83268: LD_INT 0
83270: PPUSH
83271: PPUSH
83272: PPUSH
83273: PPUSH
83274: PPUSH
83275: PPUSH
83276: PPUSH
// if not mc_bases or not skirmish then
83277: LD_EXP 58
83281: NOT
83282: PUSH
83283: LD_EXP 56
83287: NOT
83288: OR
83289: IFFALSE 83293
// exit ;
83291: GO 83954
// for i = 1 to mc_bases do
83293: LD_ADDR_VAR 0 3
83297: PUSH
83298: DOUBLE
83299: LD_INT 1
83301: DEC
83302: ST_TO_ADDR
83303: LD_EXP 58
83307: PUSH
83308: FOR_TO
83309: IFFALSE 83952
// begin if building in mc_construct_list [ i ] then
83311: LD_VAR 0 1
83315: PUSH
83316: LD_EXP 65
83320: PUSH
83321: LD_VAR 0 3
83325: ARRAY
83326: IN
83327: IFFALSE 83950
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83329: LD_ADDR_EXP 65
83333: PUSH
83334: LD_EXP 65
83338: PPUSH
83339: LD_VAR 0 3
83343: PPUSH
83344: LD_EXP 65
83348: PUSH
83349: LD_VAR 0 3
83353: ARRAY
83354: PUSH
83355: LD_VAR 0 1
83359: DIFF
83360: PPUSH
83361: CALL_OW 1
83365: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83366: LD_ADDR_EXP 58
83370: PUSH
83371: LD_EXP 58
83375: PPUSH
83376: LD_VAR 0 3
83380: PUSH
83381: LD_EXP 58
83385: PUSH
83386: LD_VAR 0 3
83390: ARRAY
83391: PUSH
83392: LD_INT 1
83394: PLUS
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PPUSH
83400: LD_VAR 0 1
83404: PPUSH
83405: CALL 20553 0 3
83409: ST_TO_ADDR
// btype := GetBType ( building ) ;
83410: LD_ADDR_VAR 0 5
83414: PUSH
83415: LD_VAR 0 1
83419: PPUSH
83420: CALL_OW 266
83424: ST_TO_ADDR
// side := GetSide ( building ) ;
83425: LD_ADDR_VAR 0 8
83429: PUSH
83430: LD_VAR 0 1
83434: PPUSH
83435: CALL_OW 255
83439: ST_TO_ADDR
// if btype = b_lab then
83440: LD_VAR 0 5
83444: PUSH
83445: LD_INT 6
83447: EQUAL
83448: IFFALSE 83498
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83450: LD_ADDR_EXP 91
83454: PUSH
83455: LD_EXP 91
83459: PPUSH
83460: LD_VAR 0 3
83464: PUSH
83465: LD_EXP 91
83469: PUSH
83470: LD_VAR 0 3
83474: ARRAY
83475: PUSH
83476: LD_INT 1
83478: PLUS
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PPUSH
83484: LD_VAR 0 1
83488: PPUSH
83489: CALL 20553 0 3
83493: ST_TO_ADDR
// exit ;
83494: POP
83495: POP
83496: GO 83954
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83498: LD_VAR 0 5
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: LD_INT 2
83508: PUSH
83509: LD_INT 4
83511: PUSH
83512: EMPTY
83513: LIST
83514: LIST
83515: LIST
83516: IN
83517: IFFALSE 83641
// begin if btype = b_armoury then
83519: LD_VAR 0 5
83523: PUSH
83524: LD_INT 4
83526: EQUAL
83527: IFFALSE 83537
// btype := b_barracks ;
83529: LD_ADDR_VAR 0 5
83533: PUSH
83534: LD_INT 5
83536: ST_TO_ADDR
// if btype = b_depot then
83537: LD_VAR 0 5
83541: PUSH
83542: LD_INT 0
83544: EQUAL
83545: IFFALSE 83555
// btype := b_warehouse ;
83547: LD_ADDR_VAR 0 5
83551: PUSH
83552: LD_INT 1
83554: ST_TO_ADDR
// if btype = b_workshop then
83555: LD_VAR 0 5
83559: PUSH
83560: LD_INT 2
83562: EQUAL
83563: IFFALSE 83573
// btype := b_factory ;
83565: LD_ADDR_VAR 0 5
83569: PUSH
83570: LD_INT 3
83572: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83573: LD_VAR 0 5
83577: PPUSH
83578: LD_VAR 0 8
83582: PPUSH
83583: CALL_OW 323
83587: PUSH
83588: LD_INT 1
83590: EQUAL
83591: IFFALSE 83637
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83593: LD_ADDR_EXP 90
83597: PUSH
83598: LD_EXP 90
83602: PPUSH
83603: LD_VAR 0 3
83607: PUSH
83608: LD_EXP 90
83612: PUSH
83613: LD_VAR 0 3
83617: ARRAY
83618: PUSH
83619: LD_INT 1
83621: PLUS
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PPUSH
83627: LD_VAR 0 1
83631: PPUSH
83632: CALL 20553 0 3
83636: ST_TO_ADDR
// exit ;
83637: POP
83638: POP
83639: GO 83954
// end ; if btype in [ b_bunker , b_turret ] then
83641: LD_VAR 0 5
83645: PUSH
83646: LD_INT 32
83648: PUSH
83649: LD_INT 33
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: IN
83656: IFFALSE 83946
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83658: LD_ADDR_EXP 66
83662: PUSH
83663: LD_EXP 66
83667: PPUSH
83668: LD_VAR 0 3
83672: PUSH
83673: LD_EXP 66
83677: PUSH
83678: LD_VAR 0 3
83682: ARRAY
83683: PUSH
83684: LD_INT 1
83686: PLUS
83687: PUSH
83688: EMPTY
83689: LIST
83690: LIST
83691: PPUSH
83692: LD_VAR 0 1
83696: PPUSH
83697: CALL 20553 0 3
83701: ST_TO_ADDR
// if btype = b_bunker then
83702: LD_VAR 0 5
83706: PUSH
83707: LD_INT 32
83709: EQUAL
83710: IFFALSE 83946
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83712: LD_ADDR_EXP 67
83716: PUSH
83717: LD_EXP 67
83721: PPUSH
83722: LD_VAR 0 3
83726: PUSH
83727: LD_EXP 67
83731: PUSH
83732: LD_VAR 0 3
83736: ARRAY
83737: PUSH
83738: LD_INT 1
83740: PLUS
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PPUSH
83746: LD_VAR 0 1
83750: PPUSH
83751: CALL 20553 0 3
83755: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83756: LD_ADDR_VAR 0 6
83760: PUSH
83761: LD_EXP 58
83765: PUSH
83766: LD_VAR 0 3
83770: ARRAY
83771: PPUSH
83772: LD_INT 25
83774: PUSH
83775: LD_INT 1
83777: PUSH
83778: EMPTY
83779: LIST
83780: LIST
83781: PUSH
83782: LD_INT 3
83784: PUSH
83785: LD_INT 54
83787: PUSH
83788: EMPTY
83789: LIST
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: PPUSH
83799: CALL_OW 72
83803: ST_TO_ADDR
// if tmp then
83804: LD_VAR 0 6
83808: IFFALSE 83814
// exit ;
83810: POP
83811: POP
83812: GO 83954
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83814: LD_ADDR_VAR 0 6
83818: PUSH
83819: LD_EXP 58
83823: PUSH
83824: LD_VAR 0 3
83828: ARRAY
83829: PPUSH
83830: LD_INT 2
83832: PUSH
83833: LD_INT 30
83835: PUSH
83836: LD_INT 4
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 30
83845: PUSH
83846: LD_INT 5
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: LIST
83857: PPUSH
83858: CALL_OW 72
83862: ST_TO_ADDR
// if not tmp then
83863: LD_VAR 0 6
83867: NOT
83868: IFFALSE 83874
// exit ;
83870: POP
83871: POP
83872: GO 83954
// for j in tmp do
83874: LD_ADDR_VAR 0 4
83878: PUSH
83879: LD_VAR 0 6
83883: PUSH
83884: FOR_IN
83885: IFFALSE 83944
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83887: LD_ADDR_VAR 0 7
83891: PUSH
83892: LD_VAR 0 4
83896: PPUSH
83897: CALL_OW 313
83901: PPUSH
83902: LD_INT 25
83904: PUSH
83905: LD_INT 1
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: PPUSH
83912: CALL_OW 72
83916: ST_TO_ADDR
// if units then
83917: LD_VAR 0 7
83921: IFFALSE 83942
// begin ComExitBuilding ( units [ 1 ] ) ;
83923: LD_VAR 0 7
83927: PUSH
83928: LD_INT 1
83930: ARRAY
83931: PPUSH
83932: CALL_OW 122
// exit ;
83936: POP
83937: POP
83938: POP
83939: POP
83940: GO 83954
// end ; end ;
83942: GO 83884
83944: POP
83945: POP
// end ; end ; exit ;
83946: POP
83947: POP
83948: GO 83954
// end ; end ;
83950: GO 83308
83952: POP
83953: POP
// end ;
83954: LD_VAR 0 2
83958: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83959: LD_INT 0
83961: PPUSH
83962: PPUSH
83963: PPUSH
83964: PPUSH
83965: PPUSH
83966: PPUSH
83967: PPUSH
// if not mc_bases or not skirmish then
83968: LD_EXP 58
83972: NOT
83973: PUSH
83974: LD_EXP 56
83978: NOT
83979: OR
83980: IFFALSE 83984
// exit ;
83982: GO 84215
// btype := GetBType ( building ) ;
83984: LD_ADDR_VAR 0 6
83988: PUSH
83989: LD_VAR 0 1
83993: PPUSH
83994: CALL_OW 266
83998: ST_TO_ADDR
// x := GetX ( building ) ;
83999: LD_ADDR_VAR 0 7
84003: PUSH
84004: LD_VAR 0 1
84008: PPUSH
84009: CALL_OW 250
84013: ST_TO_ADDR
// y := GetY ( building ) ;
84014: LD_ADDR_VAR 0 8
84018: PUSH
84019: LD_VAR 0 1
84023: PPUSH
84024: CALL_OW 251
84028: ST_TO_ADDR
// d := GetDir ( building ) ;
84029: LD_ADDR_VAR 0 9
84033: PUSH
84034: LD_VAR 0 1
84038: PPUSH
84039: CALL_OW 254
84043: ST_TO_ADDR
// for i = 1 to mc_bases do
84044: LD_ADDR_VAR 0 4
84048: PUSH
84049: DOUBLE
84050: LD_INT 1
84052: DEC
84053: ST_TO_ADDR
84054: LD_EXP 58
84058: PUSH
84059: FOR_TO
84060: IFFALSE 84213
// begin if not mc_build_list [ i ] then
84062: LD_EXP 63
84066: PUSH
84067: LD_VAR 0 4
84071: ARRAY
84072: NOT
84073: IFFALSE 84077
// continue ;
84075: GO 84059
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
84077: LD_VAR 0 6
84081: PUSH
84082: LD_VAR 0 7
84086: PUSH
84087: LD_VAR 0 8
84091: PUSH
84092: LD_VAR 0 9
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: LIST
84101: LIST
84102: PPUSH
84103: LD_EXP 63
84107: PUSH
84108: LD_VAR 0 4
84112: ARRAY
84113: PUSH
84114: LD_INT 1
84116: ARRAY
84117: PPUSH
84118: CALL 26722 0 2
84122: IFFALSE 84211
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
84124: LD_ADDR_EXP 63
84128: PUSH
84129: LD_EXP 63
84133: PPUSH
84134: LD_VAR 0 4
84138: PPUSH
84139: LD_EXP 63
84143: PUSH
84144: LD_VAR 0 4
84148: ARRAY
84149: PPUSH
84150: LD_INT 1
84152: PPUSH
84153: CALL_OW 3
84157: PPUSH
84158: CALL_OW 1
84162: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84163: LD_ADDR_EXP 65
84167: PUSH
84168: LD_EXP 65
84172: PPUSH
84173: LD_VAR 0 4
84177: PUSH
84178: LD_EXP 65
84182: PUSH
84183: LD_VAR 0 4
84187: ARRAY
84188: PUSH
84189: LD_INT 1
84191: PLUS
84192: PUSH
84193: EMPTY
84194: LIST
84195: LIST
84196: PPUSH
84197: LD_VAR 0 1
84201: PPUSH
84202: CALL 20553 0 3
84206: ST_TO_ADDR
// exit ;
84207: POP
84208: POP
84209: GO 84215
// end ; end ;
84211: GO 84059
84213: POP
84214: POP
// end ;
84215: LD_VAR 0 3
84219: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84220: LD_INT 0
84222: PPUSH
84223: PPUSH
84224: PPUSH
// if not mc_bases or not skirmish then
84225: LD_EXP 58
84229: NOT
84230: PUSH
84231: LD_EXP 56
84235: NOT
84236: OR
84237: IFFALSE 84241
// exit ;
84239: GO 84431
// for i = 1 to mc_bases do
84241: LD_ADDR_VAR 0 4
84245: PUSH
84246: DOUBLE
84247: LD_INT 1
84249: DEC
84250: ST_TO_ADDR
84251: LD_EXP 58
84255: PUSH
84256: FOR_TO
84257: IFFALSE 84344
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84259: LD_VAR 0 1
84263: PUSH
84264: LD_EXP 66
84268: PUSH
84269: LD_VAR 0 4
84273: ARRAY
84274: IN
84275: PUSH
84276: LD_VAR 0 1
84280: PUSH
84281: LD_EXP 67
84285: PUSH
84286: LD_VAR 0 4
84290: ARRAY
84291: IN
84292: NOT
84293: AND
84294: IFFALSE 84342
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84296: LD_ADDR_EXP 67
84300: PUSH
84301: LD_EXP 67
84305: PPUSH
84306: LD_VAR 0 4
84310: PUSH
84311: LD_EXP 67
84315: PUSH
84316: LD_VAR 0 4
84320: ARRAY
84321: PUSH
84322: LD_INT 1
84324: PLUS
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PPUSH
84330: LD_VAR 0 1
84334: PPUSH
84335: CALL 20553 0 3
84339: ST_TO_ADDR
// break ;
84340: GO 84344
// end ; end ;
84342: GO 84256
84344: POP
84345: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84346: LD_VAR 0 1
84350: PPUSH
84351: CALL_OW 257
84355: PUSH
84356: LD_EXP 84
84360: IN
84361: PUSH
84362: LD_VAR 0 1
84366: PPUSH
84367: CALL_OW 266
84371: PUSH
84372: LD_INT 5
84374: EQUAL
84375: AND
84376: PUSH
84377: LD_VAR 0 2
84381: PPUSH
84382: CALL_OW 110
84386: PUSH
84387: LD_INT 18
84389: NONEQUAL
84390: AND
84391: IFFALSE 84431
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84393: LD_VAR 0 2
84397: PPUSH
84398: CALL_OW 257
84402: PUSH
84403: LD_INT 5
84405: PUSH
84406: LD_INT 8
84408: PUSH
84409: LD_INT 9
84411: PUSH
84412: EMPTY
84413: LIST
84414: LIST
84415: LIST
84416: IN
84417: IFFALSE 84431
// SetClass ( unit , 1 ) ;
84419: LD_VAR 0 2
84423: PPUSH
84424: LD_INT 1
84426: PPUSH
84427: CALL_OW 336
// end ;
84431: LD_VAR 0 3
84435: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84436: LD_INT 0
84438: PPUSH
84439: PPUSH
// if not mc_bases or not skirmish then
84440: LD_EXP 58
84444: NOT
84445: PUSH
84446: LD_EXP 56
84450: NOT
84451: OR
84452: IFFALSE 84456
// exit ;
84454: GO 84572
// if GetLives ( abandoned_vehicle ) > 250 then
84456: LD_VAR 0 2
84460: PPUSH
84461: CALL_OW 256
84465: PUSH
84466: LD_INT 250
84468: GREATER
84469: IFFALSE 84473
// exit ;
84471: GO 84572
// for i = 1 to mc_bases do
84473: LD_ADDR_VAR 0 6
84477: PUSH
84478: DOUBLE
84479: LD_INT 1
84481: DEC
84482: ST_TO_ADDR
84483: LD_EXP 58
84487: PUSH
84488: FOR_TO
84489: IFFALSE 84570
// begin if driver in mc_bases [ i ] then
84491: LD_VAR 0 1
84495: PUSH
84496: LD_EXP 58
84500: PUSH
84501: LD_VAR 0 6
84505: ARRAY
84506: IN
84507: IFFALSE 84568
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84509: LD_VAR 0 1
84513: PPUSH
84514: LD_EXP 58
84518: PUSH
84519: LD_VAR 0 6
84523: ARRAY
84524: PPUSH
84525: LD_INT 2
84527: PUSH
84528: LD_INT 30
84530: PUSH
84531: LD_INT 0
84533: PUSH
84534: EMPTY
84535: LIST
84536: LIST
84537: PUSH
84538: LD_INT 30
84540: PUSH
84541: LD_INT 1
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: LIST
84552: PPUSH
84553: CALL_OW 72
84557: PUSH
84558: LD_INT 1
84560: ARRAY
84561: PPUSH
84562: CALL_OW 112
// break ;
84566: GO 84570
// end ; end ;
84568: GO 84488
84570: POP
84571: POP
// end ; end_of_file
84572: LD_VAR 0 5
84576: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
84577: GO 84579
84579: DISABLE
// begin ru_radar := 98 ;
84580: LD_ADDR_EXP 101
84584: PUSH
84585: LD_INT 98
84587: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84588: LD_ADDR_EXP 102
84592: PUSH
84593: LD_INT 89
84595: ST_TO_ADDR
// us_hack := 99 ;
84596: LD_ADDR_EXP 103
84600: PUSH
84601: LD_INT 99
84603: ST_TO_ADDR
// us_artillery := 97 ;
84604: LD_ADDR_EXP 104
84608: PUSH
84609: LD_INT 97
84611: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84612: LD_ADDR_EXP 105
84616: PUSH
84617: LD_INT 91
84619: ST_TO_ADDR
// end ;
84620: END
