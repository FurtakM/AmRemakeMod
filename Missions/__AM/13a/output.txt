// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 587 0 0
// InitMacro ;
  12: CALL 55515 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 47736 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 47736 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 47736 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 47736 0 9
// PrepareArabian ;
 140: CALL 3421 0 0
// PrepareRussian ;
 144: CALL 2548 0 0
// PrepareAlliance ;
 148: CALL 697 0 0
// MC_Start ( ) ;
 152: CALL 56662 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6615 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 77031 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 77457 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 77910 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 78179 0 2
// MC_InsertProduceList ( 1 , [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PPUSH
 294: CALL 77397 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 298: LD_INT 2
 300: PPUSH
 301: LD_INT 12
 303: PUSH
 304: LD_INT 14
 306: PUSH
 307: LD_INT 10
 309: PUSH
 310: LD_INT 11
 312: PUSH
 313: EMPTY
 314: LIST
 315: LIST
 316: LIST
 317: LIST
 318: PPUSH
 319: CALL 78086 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 323: LD_INT 2
 325: PPUSH
 326: LD_EXP 50
 330: PPUSH
 331: CALL 77457 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 335: LD_INT 2
 337: PPUSH
 338: LD_INT 8
 340: PPUSH
 341: CALL 77910 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 10
 350: PUSH
 351: EMPTY
 352: LIST
 353: PPUSH
 354: CALL 78179 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 6
 363: PUSH
 364: LD_INT 71
 366: PUSH
 367: LD_INT 116
 369: PUSH
 370: LD_INT 4
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 85
 384: PUSH
 385: LD_INT 116
 387: PUSH
 388: LD_INT 4
 390: PUSH
 391: EMPTY
 392: LIST
 393: LIST
 394: LIST
 395: LIST
 396: PUSH
 397: LD_INT 32
 399: PUSH
 400: LD_INT 83
 402: PUSH
 403: LD_INT 111
 405: PUSH
 406: LD_INT 4
 408: PUSH
 409: EMPTY
 410: LIST
 411: LIST
 412: LIST
 413: LIST
 414: PUSH
 415: LD_INT 32
 417: PUSH
 418: LD_INT 87
 420: PUSH
 421: LD_INT 121
 423: PUSH
 424: LD_INT 4
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 33
 435: PUSH
 436: LD_INT 88
 438: PUSH
 439: LD_INT 128
 441: PUSH
 442: LD_INT 4
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: PUSH
 451: LD_INT 32
 453: PUSH
 454: LD_INT 59
 456: PUSH
 457: LD_INT 89
 459: PUSH
 460: LD_INT 3
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 33
 471: PUSH
 472: LD_INT 69
 474: PUSH
 475: LD_INT 98
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_INT 33
 489: PUSH
 490: LD_INT 77
 492: PUSH
 493: LD_INT 103
 495: PUSH
 496: LD_INT 3
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 33
 507: PUSH
 508: LD_INT 83
 510: PUSH
 511: LD_INT 105
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 33
 525: PUSH
 526: LD_INT 71
 528: PUSH
 529: LD_INT 125
 531: PUSH
 532: LD_INT 5
 534: PUSH
 535: EMPTY
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: PPUSH
 553: CALL 77241 0 2
// MC_InsertProduceList ( 2 , [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ) ;
 557: LD_INT 2
 559: PPUSH
 560: LD_INT 21
 562: PUSH
 563: LD_INT 1
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 51
 571: PUSH
 572: EMPTY
 573: LIST
 574: LIST
 575: LIST
 576: LIST
 577: PPUSH
 578: CALL 77397 0 2
// end ;
 582: LD_VAR 0 1
 586: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 587: LD_INT 0
 589: PPUSH
// debug := false ;
 590: LD_ADDR_EXP 1
 594: PUSH
 595: LD_INT 0
 597: ST_TO_ADDR
// game := true ;
 598: LD_ADDR_EXP 2
 602: PUSH
 603: LD_INT 1
 605: ST_TO_ADDR
// gossudarov_arrive := false ;
 606: LD_ADDR_EXP 4
 610: PUSH
 611: LD_INT 0
 613: ST_TO_ADDR
// ru_lab_builded := false ;
 614: LD_ADDR_EXP 5
 618: PUSH
 619: LD_INT 0
 621: ST_TO_ADDR
// player_spotted := false ;
 622: LD_ADDR_EXP 6
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// first_attack := false ;
 630: LD_ADDR_EXP 7
 634: PUSH
 635: LD_INT 0
 637: ST_TO_ADDR
// ru_attackers := [ ] ;
 638: LD_ADDR_EXP 51
 642: PUSH
 643: EMPTY
 644: ST_TO_ADDR
// ar_base_spotted := false ;
 645: LD_ADDR_EXP 8
 649: PUSH
 650: LD_INT 0
 652: ST_TO_ADDR
// ar_active_attack := false ;
 653: LD_ADDR_EXP 9
 657: PUSH
 658: LD_INT 0
 660: ST_TO_ADDR
// ar_attackers := [ ] ;
 661: LD_ADDR_EXP 10
 665: PUSH
 666: EMPTY
 667: ST_TO_ADDR
// first_powell_attack := false ;
 668: LD_ADDR_EXP 11
 672: PUSH
 673: LD_INT 0
 675: ST_TO_ADDR
// abdul_escaped := true ;
 676: LD_ADDR_EXP 12
 680: PUSH
 681: LD_INT 1
 683: ST_TO_ADDR
// loss_counter := 0 ;
 684: LD_ADDR_EXP 13
 688: PUSH
 689: LD_INT 0
 691: ST_TO_ADDR
// end ; end_of_file
 692: LD_VAR 0 1
 696: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 697: LD_INT 0
 699: PPUSH
 700: PPUSH
 701: PPUSH
 702: PPUSH
// uc_side := 7 ;
 703: LD_ADDR_OWVAR 20
 707: PUSH
 708: LD_INT 7
 710: ST_TO_ADDR
// uc_nation := 1 ;
 711: LD_ADDR_OWVAR 21
 715: PUSH
 716: LD_INT 1
 718: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 719: LD_ADDR_EXP 14
 723: PUSH
 724: LD_STRING JMM
 726: PPUSH
 727: LD_EXP 1
 731: NOT
 732: PPUSH
 733: LD_STRING 12a_
 735: PPUSH
 736: CALL 13495 0 3
 740: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 741: LD_EXP 14
 745: PPUSH
 746: LD_INT 71
 748: PPUSH
 749: LD_INT 23
 751: PPUSH
 752: LD_INT 0
 754: PPUSH
 755: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 759: LD_EXP 14
 763: PPUSH
 764: LD_INT 2
 766: PPUSH
 767: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 771: LD_ADDR_EXP 15
 775: PUSH
 776: LD_STRING Roth
 778: PPUSH
 779: LD_EXP 1
 783: NOT
 784: PPUSH
 785: LD_STRING 12a_
 787: PPUSH
 788: CALL 13495 0 3
 792: ST_TO_ADDR
// if Roth then
 793: LD_EXP 15
 797: IFFALSE 817
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 799: LD_EXP 15
 803: PPUSH
 804: LD_INT 71
 806: PPUSH
 807: LD_INT 21
 809: PPUSH
 810: LD_INT 0
 812: PPUSH
 813: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 817: LD_ADDR_EXP 16
 821: PUSH
 822: LD_STRING Lisa
 824: PPUSH
 825: LD_EXP 1
 829: NOT
 830: PPUSH
 831: LD_STRING 12a_
 833: PPUSH
 834: CALL 13495 0 3
 838: ST_TO_ADDR
// if Lisa then
 839: LD_EXP 16
 843: IFFALSE 860
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 845: LD_EXP 16
 849: PPUSH
 850: LD_INT 13
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 860: LD_ADDR_EXP 17
 864: PUSH
 865: LD_STRING Donaldson
 867: PPUSH
 868: LD_EXP 1
 872: NOT
 873: PPUSH
 874: LD_STRING 12a_
 876: PPUSH
 877: CALL 13495 0 3
 881: ST_TO_ADDR
// if Donaldson then
 882: LD_EXP 17
 886: IFFALSE 903
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 888: LD_EXP 17
 892: PPUSH
 893: LD_INT 13
 895: PPUSH
 896: LD_INT 0
 898: PPUSH
 899: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 903: LD_ADDR_EXP 18
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_STRING 12a_
 919: PPUSH
 920: CALL 13495 0 3
 924: ST_TO_ADDR
// if Bobby then
 925: LD_EXP 18
 929: IFFALSE 946
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 931: LD_EXP 18
 935: PPUSH
 936: LD_INT 13
 938: PPUSH
 939: LD_INT 0
 941: PPUSH
 942: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 946: LD_ADDR_EXP 19
 950: PUSH
 951: LD_STRING Cyrus
 953: PPUSH
 954: LD_EXP 1
 958: NOT
 959: PPUSH
 960: LD_STRING 12a_
 962: PPUSH
 963: CALL 13495 0 3
 967: ST_TO_ADDR
// if Cyrus then
 968: LD_EXP 19
 972: IFFALSE 989
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 974: LD_EXP 19
 978: PPUSH
 979: LD_INT 13
 981: PPUSH
 982: LD_INT 0
 984: PPUSH
 985: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 989: LD_ADDR_EXP 20
 993: PUSH
 994: LD_STRING Denis
 996: PPUSH
 997: LD_EXP 1
1001: NOT
1002: PPUSH
1003: LD_STRING 12a_
1005: PPUSH
1006: CALL 13495 0 3
1010: ST_TO_ADDR
// if Denis then
1011: LD_EXP 20
1015: IFFALSE 1032
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1017: LD_EXP 20
1021: PPUSH
1022: LD_INT 13
1024: PPUSH
1025: LD_INT 0
1027: PPUSH
1028: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1032: LD_ADDR_EXP 21
1036: PUSH
1037: LD_STRING Brown
1039: PPUSH
1040: LD_EXP 1
1044: NOT
1045: PPUSH
1046: LD_STRING 12a_
1048: PPUSH
1049: CALL 13495 0 3
1053: ST_TO_ADDR
// if Brown then
1054: LD_EXP 21
1058: IFFALSE 1075
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1060: LD_EXP 21
1064: PPUSH
1065: LD_INT 13
1067: PPUSH
1068: LD_INT 0
1070: PPUSH
1071: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1075: LD_ADDR_EXP 22
1079: PUSH
1080: LD_STRING Gladstone
1082: PPUSH
1083: LD_EXP 1
1087: NOT
1088: PPUSH
1089: LD_STRING 12a_
1091: PPUSH
1092: CALL 13495 0 3
1096: ST_TO_ADDR
// if Gladstone then
1097: LD_EXP 22
1101: IFFALSE 1118
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1103: LD_EXP 22
1107: PPUSH
1108: LD_INT 13
1110: PPUSH
1111: LD_INT 0
1113: PPUSH
1114: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1118: LD_ADDR_EXP 23
1122: PUSH
1123: LD_STRING Houten
1125: PPUSH
1126: LD_EXP 1
1130: NOT
1131: PPUSH
1132: LD_STRING 12a_
1134: PPUSH
1135: CALL 13495 0 3
1139: ST_TO_ADDR
// if Houten then
1140: LD_EXP 23
1144: IFFALSE 1161
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1146: LD_EXP 23
1150: PPUSH
1151: LD_INT 13
1153: PPUSH
1154: LD_INT 0
1156: PPUSH
1157: CALL_OW 49
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12a_ ) ;
1161: LD_ADDR_EXP 24
1165: PUSH
1166: LD_STRING Cornel
1168: PPUSH
1169: LD_EXP 1
1173: NOT
1174: PPUSH
1175: LD_STRING 12a_
1177: PPUSH
1178: CALL 13495 0 3
1182: ST_TO_ADDR
// if Cornel then
1183: LD_EXP 24
1187: IFFALSE 1204
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1189: LD_EXP 24
1193: PPUSH
1194: LD_INT 13
1196: PPUSH
1197: LD_INT 0
1199: PPUSH
1200: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1204: LD_ADDR_EXP 25
1208: PUSH
1209: LD_STRING Gary
1211: PPUSH
1212: LD_EXP 1
1216: NOT
1217: PPUSH
1218: LD_STRING 12a_
1220: PPUSH
1221: CALL 13495 0 3
1225: ST_TO_ADDR
// if Gary then
1226: LD_EXP 25
1230: IFFALSE 1247
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1232: LD_EXP 25
1236: PPUSH
1237: LD_INT 13
1239: PPUSH
1240: LD_INT 0
1242: PPUSH
1243: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1247: LD_ADDR_EXP 26
1251: PUSH
1252: LD_STRING Frank
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_STRING 12a_
1263: PPUSH
1264: CALL 13495 0 3
1268: ST_TO_ADDR
// if Frank then
1269: LD_EXP 26
1273: IFFALSE 1290
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1275: LD_EXP 26
1279: PPUSH
1280: LD_INT 13
1282: PPUSH
1283: LD_INT 0
1285: PPUSH
1286: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1290: LD_ADDR_EXP 27
1294: PUSH
1295: LD_STRING Kikuchi
1297: PPUSH
1298: LD_EXP 1
1302: NOT
1303: PPUSH
1304: LD_STRING 12a_
1306: PPUSH
1307: CALL 13495 0 3
1311: ST_TO_ADDR
// if Kikuchi then
1312: LD_EXP 27
1316: IFFALSE 1333
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1318: LD_EXP 27
1322: PPUSH
1323: LD_INT 13
1325: PPUSH
1326: LD_INT 0
1328: PPUSH
1329: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1333: LD_ADDR_EXP 28
1337: PUSH
1338: LD_STRING Simms
1340: PPUSH
1341: LD_EXP 1
1345: NOT
1346: PPUSH
1347: LD_STRING 12a_
1349: PPUSH
1350: CALL 13495 0 3
1354: ST_TO_ADDR
// if Simms then
1355: LD_EXP 28
1359: IFFALSE 1376
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1361: LD_EXP 28
1365: PPUSH
1366: LD_INT 13
1368: PPUSH
1369: LD_INT 0
1371: PPUSH
1372: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1376: LD_ADDR_EXP 29
1380: PUSH
1381: LD_STRING Joan
1383: PPUSH
1384: LD_EXP 1
1388: NOT
1389: PPUSH
1390: LD_STRING 12a_
1392: PPUSH
1393: CALL 13495 0 3
1397: ST_TO_ADDR
// if Joan then
1398: LD_EXP 29
1402: IFFALSE 1419
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1404: LD_EXP 29
1408: PPUSH
1409: LD_INT 13
1411: PPUSH
1412: LD_INT 0
1414: PPUSH
1415: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1419: LD_ADDR_EXP 30
1423: PUSH
1424: LD_STRING DeltaDoctor
1426: PPUSH
1427: LD_EXP 1
1431: NOT
1432: PPUSH
1433: LD_STRING 12a_
1435: PPUSH
1436: CALL 13495 0 3
1440: ST_TO_ADDR
// if DeltaDoctor then
1441: LD_EXP 30
1445: IFFALSE 1462
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1447: LD_EXP 30
1451: PPUSH
1452: LD_INT 13
1454: PPUSH
1455: LD_INT 0
1457: PPUSH
1458: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1462: LD_ADDR_VAR 0 4
1466: PUSH
1467: LD_STRING 12a_others
1469: PPUSH
1470: CALL_OW 31
1474: ST_TO_ADDR
// if tmp then
1475: LD_VAR 0 4
1479: IFFALSE 1513
// for i in tmp do
1481: LD_ADDR_VAR 0 3
1485: PUSH
1486: LD_VAR 0 4
1490: PUSH
1491: FOR_IN
1492: IFFALSE 1511
// PlaceUnitArea ( i , alliance_start , false ) ;
1494: LD_VAR 0 3
1498: PPUSH
1499: LD_INT 13
1501: PPUSH
1502: LD_INT 0
1504: PPUSH
1505: CALL_OW 49
1509: GO 1491
1511: POP
1512: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1513: LD_INT 3
1515: PPUSH
1516: LD_INT 3
1518: PPUSH
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 12
1524: PPUSH
1525: LD_INT 100
1527: PPUSH
1528: CALL 20128 0 5
// veh := CreateVehicle ;
1532: LD_ADDR_VAR 0 2
1536: PUSH
1537: CALL_OW 45
1541: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1542: LD_VAR 0 2
1546: PPUSH
1547: LD_INT 2
1549: PPUSH
1550: CALL_OW 233
// PlaceUnitXY ( veh , 63 , 9 , false ) ;
1554: LD_VAR 0 2
1558: PPUSH
1559: LD_INT 63
1561: PPUSH
1562: LD_INT 9
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1572: LD_VAR 0 2
1576: PPUSH
1577: LD_INT 4
1579: PPUSH
1580: LD_INT 30
1582: PPUSH
1583: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1587: LD_STRING 11_artifact_captured
1589: PPUSH
1590: LD_INT 0
1592: PPUSH
1593: CALL_OW 30
1597: IFFALSE 1673
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1599: LD_INT 3
1601: PPUSH
1602: LD_INT 3
1604: PPUSH
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 12
1610: PPUSH
1611: LD_INT 100
1613: PPUSH
1614: CALL 20128 0 5
// veh := CreateVehicle ;
1618: LD_ADDR_VAR 0 2
1622: PUSH
1623: CALL_OW 45
1627: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1628: LD_VAR 0 2
1632: PPUSH
1633: LD_INT 2
1635: PPUSH
1636: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 4 , false ) ;
1640: LD_VAR 0 2
1644: PPUSH
1645: LD_INT 60
1647: PPUSH
1648: LD_INT 4
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1658: LD_VAR 0 2
1662: PPUSH
1663: LD_INT 4
1665: PPUSH
1666: LD_INT 50
1668: PPUSH
1669: CALL_OW 290
// end ; end ;
1673: LD_VAR 0 1
1677: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1678: LD_INT 0
1680: PPUSH
1681: PPUSH
1682: PPUSH
// uc_side := 6 ;
1683: LD_ADDR_OWVAR 20
1687: PUSH
1688: LD_INT 6
1690: ST_TO_ADDR
// uc_nation := 3 ;
1691: LD_ADDR_OWVAR 21
1695: PUSH
1696: LD_INT 3
1698: ST_TO_ADDR
// InitHc ;
1699: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1703: LD_ADDR_EXP 31
1707: PUSH
1708: LD_STRING Gossudarov
1710: PPUSH
1711: CALL_OW 25
1715: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1716: LD_ADDR_EXP 32
1720: PUSH
1721: LD_STRING Kirilenkova
1723: PPUSH
1724: CALL_OW 25
1728: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1729: LD_ADDR_EXP 33
1733: PUSH
1734: LD_STRING Titov
1736: PPUSH
1737: CALL_OW 25
1741: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1742: LD_ADDR_EXP 38
1746: PUSH
1747: LD_STRING Oblukov
1749: PPUSH
1750: CALL_OW 25
1754: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1755: LD_ADDR_EXP 35
1759: PUSH
1760: LD_STRING Dolgov
1762: PPUSH
1763: CALL_OW 25
1767: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1768: LD_ADDR_EXP 36
1772: PUSH
1773: LD_STRING Petrosyan
1775: PPUSH
1776: CALL_OW 25
1780: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1781: LD_ADDR_EXP 37
1785: PUSH
1786: LD_STRING Scholtze
1788: PPUSH
1789: CALL_OW 25
1793: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1794: LD_ADDR_EXP 39
1798: PUSH
1799: LD_STRING Kapitsova
1801: PPUSH
1802: CALL_OW 25
1806: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1807: LD_ADDR_VAR 0 2
1811: PUSH
1812: LD_EXP 31
1816: PUSH
1817: LD_EXP 32
1821: PUSH
1822: LD_EXP 33
1826: PUSH
1827: LD_EXP 38
1831: PUSH
1832: LD_EXP 35
1836: PUSH
1837: LD_EXP 36
1841: PUSH
1842: LD_EXP 37
1846: PUSH
1847: LD_EXP 39
1851: PUSH
1852: EMPTY
1853: LIST
1854: LIST
1855: LIST
1856: LIST
1857: LIST
1858: LIST
1859: LIST
1860: LIST
1861: ST_TO_ADDR
// for i in tmp do
1862: LD_ADDR_VAR 0 3
1866: PUSH
1867: LD_VAR 0 2
1871: PUSH
1872: FOR_IN
1873: IFFALSE 1892
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1875: LD_VAR 0 3
1879: PPUSH
1880: LD_INT 14
1882: PPUSH
1883: LD_INT 0
1885: PPUSH
1886: CALL_OW 49
1890: GO 1872
1892: POP
1893: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1894: LD_VAR 0 2
1898: PPUSH
1899: LD_EXP 3
1903: PPUSH
1904: CALL_OW 250
1908: PPUSH
1909: LD_EXP 3
1913: PPUSH
1914: CALL_OW 251
1918: PPUSH
1919: CALL_OW 111
// end ;
1923: LD_VAR 0 1
1927: RET
// export function PrepareBelkov ; begin
1928: LD_INT 0
1930: PPUSH
// uc_side := 4 ;
1931: LD_ADDR_OWVAR 20
1935: PUSH
1936: LD_INT 4
1938: ST_TO_ADDR
// uc_nation := 3 ;
1939: LD_ADDR_OWVAR 21
1943: PUSH
1944: LD_INT 3
1946: ST_TO_ADDR
// InitHc ;
1947: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1951: LD_ADDR_EXP 46
1955: PUSH
1956: LD_STRING Belkov
1958: PPUSH
1959: CALL_OW 25
1963: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1964: LD_EXP 46
1968: PPUSH
1969: LD_INT 14
1971: PPUSH
1972: LD_INT 0
1974: PPUSH
1975: CALL_OW 49
// end ;
1979: LD_VAR 0 1
1983: RET
// export function PrepareGnyevko ; begin
1984: LD_INT 0
1986: PPUSH
// uc_side := 4 ;
1987: LD_ADDR_OWVAR 20
1991: PUSH
1992: LD_INT 4
1994: ST_TO_ADDR
// uc_nation := 3 ;
1995: LD_ADDR_OWVAR 21
1999: PUSH
2000: LD_INT 3
2002: ST_TO_ADDR
// InitHc ;
2003: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2007: LD_ADDR_EXP 47
2011: PUSH
2012: LD_STRING Gnyevko
2014: PPUSH
2015: CALL_OW 25
2019: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2020: LD_EXP 47
2024: PPUSH
2025: LD_INT 14
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 49
// end ;
2035: LD_VAR 0 1
2039: RET
// export function PrepareBurlak ; var i , tmp ; begin
2040: LD_INT 0
2042: PPUSH
2043: PPUSH
2044: PPUSH
// uc_side := 4 ;
2045: LD_ADDR_OWVAR 20
2049: PUSH
2050: LD_INT 4
2052: ST_TO_ADDR
// uc_nation := 3 ;
2053: LD_ADDR_OWVAR 21
2057: PUSH
2058: LD_INT 3
2060: ST_TO_ADDR
// InitHc ;
2061: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2065: LD_ADDR_EXP 45
2069: PUSH
2070: LD_STRING Burlak
2072: PPUSH
2073: CALL_OW 25
2077: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2078: LD_INT 24
2080: PUSH
2081: LD_INT 23
2083: PUSH
2084: LD_INT 22
2086: PUSH
2087: EMPTY
2088: LIST
2089: LIST
2090: LIST
2091: PUSH
2092: LD_OWVAR 67
2096: ARRAY
2097: PPUSH
2098: LD_INT 1
2100: PPUSH
2101: LD_INT 1
2103: PPUSH
2104: LD_INT 45
2106: PUSH
2107: LD_INT 44
2109: PUSH
2110: LD_INT 43
2112: PUSH
2113: EMPTY
2114: LIST
2115: LIST
2116: LIST
2117: PUSH
2118: LD_OWVAR 67
2122: ARRAY
2123: PPUSH
2124: LD_INT 0
2126: PPUSH
2127: CALL 20128 0 5
// Masha := CreateVehicle ;
2131: LD_ADDR_EXP 48
2135: PUSH
2136: CALL_OW 45
2140: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2141: LD_EXP 48
2145: PUSH
2146: LD_EXP 45
2150: PUSH
2151: EMPTY
2152: LIST
2153: LIST
2154: PPUSH
2155: LD_INT 499
2157: PPUSH
2158: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2162: LD_EXP 48
2166: PPUSH
2167: LD_INT 3
2169: PPUSH
2170: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2174: LD_EXP 48
2178: PPUSH
2179: LD_INT 1
2181: PPUSH
2182: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2186: LD_EXP 48
2190: PPUSH
2191: LD_INT 18
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2201: LD_EXP 45
2205: PPUSH
2206: LD_INT 125
2208: PPUSH
2209: LD_INT 1
2211: PPUSH
2212: LD_INT 0
2214: PPUSH
2215: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2219: LD_EXP 45
2223: PPUSH
2224: LD_EXP 48
2228: PPUSH
2229: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2233: LD_INT 10
2235: PPUSH
2236: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2240: LD_EXP 48
2244: PPUSH
2245: LD_INT 110
2247: PPUSH
2248: LD_INT 10
2250: PPUSH
2251: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2255: LD_ADDR_EXP 41
2259: PUSH
2260: LD_STRING Petrovova
2262: PPUSH
2263: CALL_OW 25
2267: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2268: LD_ADDR_EXP 43
2272: PUSH
2273: LD_STRING Kuzmov
2275: PPUSH
2276: CALL_OW 25
2280: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2281: LD_ADDR_EXP 42
2285: PUSH
2286: LD_STRING Kovalyuk
2288: PPUSH
2289: CALL_OW 25
2293: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2294: LD_ADDR_EXP 40
2298: PUSH
2299: LD_STRING Lipshchin
2301: PPUSH
2302: CALL_OW 25
2306: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2307: LD_ADDR_EXP 44
2311: PUSH
2312: LD_STRING Karamazov
2314: PPUSH
2315: CALL_OW 25
2319: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2320: LD_ADDR_VAR 0 3
2324: PUSH
2325: LD_EXP 41
2329: PUSH
2330: LD_EXP 43
2334: PUSH
2335: LD_EXP 42
2339: PUSH
2340: LD_EXP 40
2344: PUSH
2345: LD_EXP 44
2349: PUSH
2350: EMPTY
2351: LIST
2352: LIST
2353: LIST
2354: LIST
2355: LIST
2356: ST_TO_ADDR
// for i in tmp do
2357: LD_ADDR_VAR 0 2
2361: PUSH
2362: LD_VAR 0 3
2366: PUSH
2367: FOR_IN
2368: IFFALSE 2407
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2370: LD_VAR 0 2
2374: PPUSH
2375: LD_INT 399
2377: PPUSH
2378: LD_INT 799
2380: PPUSH
2381: CALL_OW 12
2385: PPUSH
2386: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2390: LD_VAR 0 2
2394: PPUSH
2395: LD_INT 19
2397: PPUSH
2398: LD_INT 0
2400: PPUSH
2401: CALL_OW 49
// end ;
2405: GO 2367
2407: POP
2408: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2409: LD_VAR 0 3
2413: PPUSH
2414: LD_INT 116
2416: PPUSH
2417: LD_INT 8
2419: PPUSH
2420: CALL_OW 111
// AddComHold ( tmp ) ;
2424: LD_VAR 0 3
2428: PPUSH
2429: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2433: LD_ADDR_VAR 0 2
2437: PUSH
2438: LD_VAR 0 3
2442: PPUSH
2443: LD_INT 25
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: EMPTY
2450: LIST
2451: LIST
2452: PPUSH
2453: CALL_OW 72
2457: PUSH
2458: FOR_IN
2459: IFFALSE 2499
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2461: LD_VAR 0 2
2465: PPUSH
2466: LD_INT 20
2468: PPUSH
2469: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2473: LD_VAR 0 2
2477: PPUSH
2478: LD_INT 147
2480: PPUSH
2481: LD_INT 45
2483: PPUSH
2484: CALL_OW 178
// AddComCrawl ( i ) ;
2488: LD_VAR 0 2
2492: PPUSH
2493: CALL_OW 197
// end ;
2497: GO 2458
2499: POP
2500: POP
// repeat wait ( 0 0$1 ) ;
2501: LD_INT 35
2503: PPUSH
2504: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) ;
2508: LD_EXP 48
2512: PPUSH
2513: LD_INT 110
2515: PPUSH
2516: LD_INT 10
2518: PPUSH
2519: CALL_OW 307
2523: IFFALSE 2501
// ComStop ( Burlak ) ;
2525: LD_EXP 45
2529: PPUSH
2530: CALL_OW 141
// AddComHold ( Burlak ) ;
2534: LD_EXP 45
2538: PPUSH
2539: CALL_OW 200
// end ; end_of_file
2543: LD_VAR 0 1
2547: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2548: LD_INT 0
2550: PPUSH
2551: PPUSH
2552: PPUSH
2553: PPUSH
// uc_side := 3 ;
2554: LD_ADDR_OWVAR 20
2558: PUSH
2559: LD_INT 3
2561: ST_TO_ADDR
// uc_nation := 3 ;
2562: LD_ADDR_OWVAR 21
2566: PUSH
2567: LD_INT 3
2569: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2570: LD_ADDR_EXP 49
2574: PUSH
2575: LD_INT 47
2577: PPUSH
2578: LD_STRING 
2580: PPUSH
2581: LD_INT 7
2583: PUSH
2584: LD_INT 8
2586: PUSH
2587: LD_INT 9
2589: PUSH
2590: EMPTY
2591: LIST
2592: LIST
2593: LIST
2594: PUSH
2595: LD_OWVAR 67
2599: ARRAY
2600: PPUSH
2601: LD_INT 10000
2603: PUSH
2604: LD_INT 3000
2606: PUSH
2607: LD_INT 300
2609: PUSH
2610: EMPTY
2611: LIST
2612: LIST
2613: LIST
2614: PPUSH
2615: LD_INT 9
2617: PUSH
2618: LD_INT 5
2620: PUSH
2621: LD_INT 6
2623: PUSH
2624: LD_INT 6
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: LIST
2631: LIST
2632: PPUSH
2633: CALL 23557 0 5
2637: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2638: LD_ADDR_EXP 58
2642: PUSH
2643: LD_EXP 58
2647: PPUSH
2648: LD_INT 2
2650: PPUSH
2651: LD_EXP 49
2655: PPUSH
2656: CALL_OW 1
2660: ST_TO_ADDR
// tmp := [ ] ;
2661: LD_ADDR_VAR 0 4
2665: PUSH
2666: EMPTY
2667: ST_TO_ADDR
// for i = 1 to 4 do
2668: LD_ADDR_VAR 0 2
2672: PUSH
2673: DOUBLE
2674: LD_INT 1
2676: DEC
2677: ST_TO_ADDR
2678: LD_INT 4
2680: PUSH
2681: FOR_TO
2682: IFFALSE 2775
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2684: LD_INT 22
2686: PPUSH
2687: LD_INT 3
2689: PPUSH
2690: LD_INT 3
2692: PPUSH
2693: LD_INT 43
2695: PUSH
2696: LD_INT 45
2698: PUSH
2699: LD_INT 45
2701: PUSH
2702: LD_INT 44
2704: PUSH
2705: EMPTY
2706: LIST
2707: LIST
2708: LIST
2709: LIST
2710: PUSH
2711: LD_VAR 0 2
2715: PUSH
2716: LD_INT 4
2718: MOD
2719: PUSH
2720: LD_INT 1
2722: PLUS
2723: ARRAY
2724: PPUSH
2725: LD_INT 100
2727: PPUSH
2728: CALL 20128 0 5
// veh := CreateVehicle ;
2732: LD_ADDR_VAR 0 3
2736: PUSH
2737: CALL_OW 45
2741: ST_TO_ADDR
// tmp := tmp ^ veh ;
2742: LD_ADDR_VAR 0 4
2746: PUSH
2747: LD_VAR 0 4
2751: PUSH
2752: LD_VAR 0 3
2756: ADD
2757: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2758: LD_VAR 0 3
2762: PPUSH
2763: LD_INT 2
2765: PPUSH
2766: LD_INT 0
2768: PPUSH
2769: CALL_OW 49
// end ;
2773: GO 2681
2775: POP
2776: POP
// russian_guard := tmp ;
2777: LD_ADDR_EXP 50
2781: PUSH
2782: LD_VAR 0 4
2786: ST_TO_ADDR
// end ;
2787: LD_VAR 0 1
2791: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2792: LD_INT 47
2794: PPUSH
2795: CALL_OW 302
2799: PUSH
2800: LD_EXP 6
2804: AND
2805: IFFALSE 3418
2807: GO 2809
2809: DISABLE
2810: LD_INT 0
2812: PPUSH
2813: PPUSH
2814: PPUSH
2815: PPUSH
2816: PPUSH
2817: PPUSH
// begin enable ;
2818: ENABLE
// base := 2 ;
2819: LD_ADDR_VAR 0 2
2823: PUSH
2824: LD_INT 2
2826: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2827: LD_ADDR_VAR 0 4
2831: PUSH
2832: LD_INT 0
2834: PUSH
2835: LD_INT 0
2837: PUSH
2838: LD_INT 0
2840: PUSH
2841: LD_INT 0
2843: PUSH
2844: LD_INT 0
2846: PUSH
2847: LD_INT 0
2849: PUSH
2850: LD_INT 0
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 1
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: EMPTY
2863: LIST
2864: LIST
2865: LIST
2866: LIST
2867: LIST
2868: LIST
2869: LIST
2870: LIST
2871: LIST
2872: LIST
2873: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2874: LD_ADDR_VAR 0 3
2878: PUSH
2879: LD_INT 22
2881: PUSH
2882: LD_INT 1
2884: PUSH
2885: LD_INT 3
2887: PUSH
2888: LD_INT 45
2890: PUSH
2891: EMPTY
2892: LIST
2893: LIST
2894: LIST
2895: LIST
2896: PUSH
2897: LD_INT 21
2899: PUSH
2900: LD_INT 1
2902: PUSH
2903: LD_INT 3
2905: PUSH
2906: LD_INT 45
2908: PUSH
2909: EMPTY
2910: LIST
2911: LIST
2912: LIST
2913: LIST
2914: PUSH
2915: LD_INT 22
2917: PUSH
2918: LD_INT 1
2920: PUSH
2921: LD_INT 3
2923: PUSH
2924: LD_INT 45
2926: PUSH
2927: EMPTY
2928: LIST
2929: LIST
2930: LIST
2931: LIST
2932: PUSH
2933: LD_INT 23
2935: PUSH
2936: LD_INT 1
2938: PUSH
2939: LD_INT 3
2941: PUSH
2942: LD_INT 46
2944: PUSH
2945: EMPTY
2946: LIST
2947: LIST
2948: LIST
2949: LIST
2950: PUSH
2951: EMPTY
2952: LIST
2953: LIST
2954: LIST
2955: LIST
2956: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
2957: LD_ADDR_VAR 0 1
2961: PUSH
2962: DOUBLE
2963: LD_INT 1
2965: DEC
2966: ST_TO_ADDR
2967: LD_OWVAR 67
2971: PUSH
2972: LD_OWVAR 1
2976: PUSH
2977: LD_INT 21000
2979: DIV
2980: PLUS
2981: PUSH
2982: FOR_TO
2983: IFFALSE 3071
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
2985: LD_ADDR_VAR 0 3
2989: PUSH
2990: LD_VAR 0 3
2994: PPUSH
2995: LD_VAR 0 3
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: PPUSH
3004: LD_INT 23
3006: PUSH
3007: LD_INT 24
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: PUSH
3014: LD_INT 1
3016: PPUSH
3017: LD_INT 2
3019: PPUSH
3020: CALL_OW 12
3024: ARRAY
3025: PUSH
3026: LD_INT 1
3028: PUSH
3029: LD_INT 3
3031: PUSH
3032: LD_INT 46
3034: PUSH
3035: LD_INT 47
3037: PUSH
3038: LD_INT 45
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: PUSH
3046: LD_INT 1
3048: PPUSH
3049: LD_INT 3
3051: PPUSH
3052: CALL_OW 12
3056: ARRAY
3057: PUSH
3058: EMPTY
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: CALL_OW 2
3068: ST_TO_ADDR
3069: GO 2982
3071: POP
3072: POP
// MC_SetProduceList ( base , tmp ) ;
3073: LD_VAR 0 2
3077: PPUSH
3078: LD_VAR 0 3
3082: PPUSH
3083: CALL 77349 0 2
// repeat wait ( 0 0$1 ) ;
3087: LD_INT 35
3089: PPUSH
3090: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
3094: LD_VAR 0 2
3098: PPUSH
3099: CALL 77803 0 1
3103: PUSH
3104: LD_INT 0
3106: EQUAL
3107: IFFALSE 3087
// wait ( 0 0$20 ) ;
3109: LD_INT 700
3111: PPUSH
3112: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3116: LD_ADDR_VAR 0 5
3120: PUSH
3121: LD_INT 71
3123: PUSH
3124: LD_INT 19
3126: PUSH
3127: EMPTY
3128: LIST
3129: LIST
3130: PUSH
3131: LD_INT 91
3133: PUSH
3134: LD_INT 67
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: PUSH
3141: LD_INT 52
3143: PUSH
3144: LD_INT 44
3146: PUSH
3147: EMPTY
3148: LIST
3149: LIST
3150: PUSH
3151: LD_INT 68
3153: PUSH
3154: LD_INT 48
3156: PUSH
3157: EMPTY
3158: LIST
3159: LIST
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ) ;
3167: LD_ADDR_VAR 0 6
3171: PUSH
3172: LD_EXP 77
3176: PUSH
3177: LD_VAR 0 2
3181: ARRAY
3182: PUSH
3183: LD_EXP 80
3187: PUSH
3188: LD_VAR 0 2
3192: ARRAY
3193: PUSH
3194: LD_EXP 77
3198: PUSH
3199: LD_VAR 0 2
3203: ARRAY
3204: PPUSH
3205: LD_INT 2
3207: PUSH
3208: LD_INT 34
3210: PUSH
3211: LD_INT 51
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: PUSH
3218: LD_INT 34
3220: PUSH
3221: LD_INT 52
3223: PUSH
3224: EMPTY
3225: LIST
3226: LIST
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: LIST
3232: PPUSH
3233: CALL_OW 72
3237: UNION
3238: DIFF
3239: ST_TO_ADDR
// if not attackers then
3240: LD_VAR 0 6
3244: NOT
3245: IFFALSE 3249
// exit ;
3247: GO 3418
// ru_attackers := attackers ;
3249: LD_ADDR_EXP 51
3253: PUSH
3254: LD_VAR 0 6
3258: ST_TO_ADDR
// for i = 1 to attackers do
3259: LD_ADDR_VAR 0 1
3263: PUSH
3264: DOUBLE
3265: LD_INT 1
3267: DEC
3268: ST_TO_ADDR
3269: LD_VAR 0 6
3273: PUSH
3274: FOR_TO
3275: IFFALSE 3352
// begin case i mod 3 of 0 :
3277: LD_VAR 0 1
3281: PUSH
3282: LD_INT 3
3284: MOD
3285: PUSH
3286: LD_INT 0
3288: DOUBLE
3289: EQUAL
3290: IFTRUE 3294
3292: GO 3297
3294: POP
// ; 1 :
3295: GO 3350
3297: LD_INT 1
3299: DOUBLE
3300: EQUAL
3301: IFTRUE 3305
3303: GO 3323
3305: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3306: LD_VAR 0 1
3310: PPUSH
3311: LD_INT 32
3313: PPUSH
3314: LD_INT 49
3316: PPUSH
3317: CALL_OW 114
3321: GO 3350
3323: LD_INT 2
3325: DOUBLE
3326: EQUAL
3327: IFTRUE 3331
3329: GO 3349
3331: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3332: LD_VAR 0 1
3336: PPUSH
3337: LD_INT 117
3339: PPUSH
3340: LD_INT 107
3342: PPUSH
3343: CALL_OW 114
3347: GO 3350
3349: POP
// end ;
3350: GO 3274
3352: POP
3353: POP
// repeat wait ( 0 0$1 ) ;
3354: LD_INT 35
3356: PPUSH
3357: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3361: LD_VAR 0 6
3365: PPUSH
3366: LD_INT 60
3368: PUSH
3369: EMPTY
3370: LIST
3371: PPUSH
3372: CALL_OW 72
3376: NOT
3377: IFFALSE 3354
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3379: LD_VAR 0 2
3383: PPUSH
3384: LD_VAR 0 6
3388: PPUSH
3389: LD_VAR 0 5
3393: PPUSH
3394: LD_VAR 0 4
3398: PPUSH
3399: CALL 77640 0 4
// if not first_attack then
3403: LD_EXP 7
3407: NOT
3408: IFFALSE 3418
// first_attack := true ;
3410: LD_ADDR_EXP 7
3414: PUSH
3415: LD_INT 1
3417: ST_TO_ADDR
// end ; end_of_file
3418: PPOPN 6
3420: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3421: LD_INT 0
3423: PPUSH
3424: PPUSH
3425: PPUSH
3426: PPUSH
3427: PPUSH
3428: PPUSH
3429: PPUSH
// uc_side := 2 ;
3430: LD_ADDR_OWVAR 20
3434: PUSH
3435: LD_INT 2
3437: ST_TO_ADDR
// uc_nation := 2 ;
3438: LD_ADDR_OWVAR 21
3442: PUSH
3443: LD_INT 2
3445: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3446: LD_ADDR_EXP 54
3450: PUSH
3451: LD_STRING Abdul
3453: PPUSH
3454: CALL_OW 25
3458: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3459: LD_EXP 54
3463: PPUSH
3464: LD_INT 11
3466: PPUSH
3467: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3471: LD_EXP 54
3475: PPUSH
3476: LD_INT 1
3478: PPUSH
3479: CALL_OW 52
// vc_chassis := 31 ;
3483: LD_ADDR_OWVAR 37
3487: PUSH
3488: LD_INT 31
3490: ST_TO_ADDR
// vc_control := control_rider ;
3491: LD_ADDR_OWVAR 38
3495: PUSH
3496: LD_INT 4
3498: ST_TO_ADDR
// mastodont := CreateVehicle ;
3499: LD_ADDR_EXP 55
3503: PUSH
3504: CALL_OW 45
3508: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3509: LD_EXP 55
3513: PPUSH
3514: LD_INT 153
3516: PPUSH
3517: LD_INT 71
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// InitVc ;
3527: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3531: LD_ADDR_EXP 52
3535: PUSH
3536: LD_INT 1
3538: PPUSH
3539: LD_STRING 
3541: PPUSH
3542: LD_INT 7
3544: PUSH
3545: LD_INT 8
3547: PUSH
3548: LD_INT 9
3550: PUSH
3551: EMPTY
3552: LIST
3553: LIST
3554: LIST
3555: PUSH
3556: LD_OWVAR 67
3560: ARRAY
3561: PPUSH
3562: LD_INT 5000
3564: PUSH
3565: LD_INT 1000
3567: PUSH
3568: LD_INT 300
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: PPUSH
3576: LD_INT 22
3578: PUSH
3579: LD_INT 5
3581: PUSH
3582: LD_INT 6
3584: PUSH
3585: LD_INT 9
3587: PUSH
3588: EMPTY
3589: LIST
3590: LIST
3591: LIST
3592: LIST
3593: PPUSH
3594: CALL 23557 0 5
3598: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3599: LD_ADDR_EXP 58
3603: PUSH
3604: LD_EXP 58
3608: PPUSH
3609: LD_INT 1
3611: PPUSH
3612: LD_EXP 52
3616: PPUSH
3617: CALL_OW 1
3621: ST_TO_ADDR
// tmp := [ ] ;
3622: LD_ADDR_VAR 0 4
3626: PUSH
3627: EMPTY
3628: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3629: LD_ADDR_OWVAR 37
3633: PUSH
3634: LD_INT 14
3636: ST_TO_ADDR
// vc_engine := engine_siberite ;
3637: LD_ADDR_OWVAR 39
3641: PUSH
3642: LD_INT 3
3644: ST_TO_ADDR
// vc_control := control_manual ;
3645: LD_ADDR_OWVAR 38
3649: PUSH
3650: LD_INT 1
3652: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3653: LD_ADDR_OWVAR 40
3657: PUSH
3658: LD_INT 31
3660: ST_TO_ADDR
// for i = 1 to 3 do
3661: LD_ADDR_VAR 0 2
3665: PUSH
3666: DOUBLE
3667: LD_INT 1
3669: DEC
3670: ST_TO_ADDR
3671: LD_INT 3
3673: PUSH
3674: FOR_TO
3675: IFFALSE 3919
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3677: LD_ADDR_VAR 0 5
3681: PUSH
3682: LD_INT 153
3684: PUSH
3685: LD_INT 71
3687: PUSH
3688: EMPTY
3689: LIST
3690: LIST
3691: PUSH
3692: LD_INT 155
3694: PUSH
3695: LD_INT 81
3697: PUSH
3698: EMPTY
3699: LIST
3700: LIST
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: LD_VAR 0 2
3710: PUSH
3711: LD_INT 2
3713: MOD
3714: PUSH
3715: LD_INT 1
3717: PLUS
3718: ARRAY
3719: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3720: LD_INT 0
3722: PPUSH
3723: LD_INT 3
3725: PPUSH
3726: LD_INT 7
3728: PUSH
3729: LD_INT 8
3731: PUSH
3732: LD_INT 9
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PUSH
3740: LD_OWVAR 67
3744: ARRAY
3745: PPUSH
3746: CALL_OW 380
// un := CreateVehicle ;
3750: LD_ADDR_VAR 0 6
3754: PUSH
3755: CALL_OW 45
3759: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3760: LD_VAR 0 6
3764: PPUSH
3765: LD_INT 0
3767: PPUSH
3768: LD_INT 5
3770: PPUSH
3771: CALL_OW 12
3775: PPUSH
3776: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3780: LD_VAR 0 6
3784: PPUSH
3785: LD_VAR 0 5
3789: PUSH
3790: LD_INT 1
3792: ARRAY
3793: PPUSH
3794: LD_VAR 0 5
3798: PUSH
3799: LD_INT 2
3801: ARRAY
3802: PPUSH
3803: LD_INT 6
3805: PPUSH
3806: LD_INT 0
3808: PPUSH
3809: CALL_OW 50
// un2 := CreateHuman ;
3813: LD_ADDR_VAR 0 7
3817: PUSH
3818: CALL_OW 44
3822: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3823: LD_VAR 0 7
3827: PPUSH
3828: LD_VAR 0 6
3832: PPUSH
3833: CALL_OW 52
// mc_bases := Add ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3837: LD_ADDR_EXP 58
3841: PUSH
3842: LD_EXP 58
3846: PPUSH
3847: LD_INT 1
3849: PUSH
3850: LD_EXP 58
3854: PUSH
3855: LD_INT 1
3857: ARRAY
3858: PUSH
3859: LD_INT 1
3861: PLUS
3862: PUSH
3863: EMPTY
3864: LIST
3865: LIST
3866: PPUSH
3867: LD_VAR 0 6
3871: PPUSH
3872: CALL 20685 0 3
3876: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3877: LD_ADDR_EXP 58
3881: PUSH
3882: LD_EXP 58
3886: PPUSH
3887: LD_INT 1
3889: PUSH
3890: LD_EXP 58
3894: PUSH
3895: LD_INT 1
3897: ARRAY
3898: PUSH
3899: LD_INT 1
3901: PLUS
3902: PUSH
3903: EMPTY
3904: LIST
3905: LIST
3906: PPUSH
3907: LD_VAR 0 7
3911: PPUSH
3912: CALL 20685 0 3
3916: ST_TO_ADDR
// end ;
3917: GO 3674
3919: POP
3920: POP
// for i = 1 to 5 do
3921: LD_ADDR_VAR 0 2
3925: PUSH
3926: DOUBLE
3927: LD_INT 1
3929: DEC
3930: ST_TO_ADDR
3931: LD_INT 5
3933: PUSH
3934: FOR_TO
3935: IFFALSE 4028
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3937: LD_INT 14
3939: PPUSH
3940: LD_INT 3
3942: PPUSH
3943: LD_INT 1
3945: PPUSH
3946: LD_INT 25
3948: PUSH
3949: LD_INT 28
3951: PUSH
3952: LD_INT 28
3954: PUSH
3955: LD_INT 26
3957: PUSH
3958: EMPTY
3959: LIST
3960: LIST
3961: LIST
3962: LIST
3963: PUSH
3964: LD_VAR 0 2
3968: PUSH
3969: LD_INT 4
3971: MOD
3972: PUSH
3973: LD_INT 1
3975: PLUS
3976: ARRAY
3977: PPUSH
3978: LD_INT 100
3980: PPUSH
3981: CALL 20128 0 5
// veh := CreateVehicle ;
3985: LD_ADDR_VAR 0 3
3989: PUSH
3990: CALL_OW 45
3994: ST_TO_ADDR
// tmp := tmp ^ veh ;
3995: LD_ADDR_VAR 0 4
3999: PUSH
4000: LD_VAR 0 4
4004: PUSH
4005: LD_VAR 0 3
4009: ADD
4010: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4011: LD_VAR 0 3
4015: PPUSH
4016: LD_INT 1
4018: PPUSH
4019: LD_INT 0
4021: PPUSH
4022: CALL_OW 49
// end ;
4026: GO 3934
4028: POP
4029: POP
// arabian_guard := tmp ;
4030: LD_ADDR_EXP 53
4034: PUSH
4035: LD_VAR 0 4
4039: ST_TO_ADDR
// end ;
4040: LD_VAR 0 1
4044: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4045: LD_INT 22
4047: PUSH
4048: LD_INT 7
4050: PUSH
4051: EMPTY
4052: LIST
4053: LIST
4054: PUSH
4055: LD_INT 91
4057: PUSH
4058: LD_INT 1
4060: PUSH
4061: LD_INT 12
4063: PUSH
4064: EMPTY
4065: LIST
4066: LIST
4067: LIST
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: PPUSH
4073: CALL_OW 69
4077: PUSH
4078: LD_EXP 55
4082: PPUSH
4083: CALL_OW 256
4087: PUSH
4088: LD_INT 990
4090: LESS
4091: OR
4092: PUSH
4093: LD_EXP 54
4097: PPUSH
4098: CALL_OW 256
4102: PUSH
4103: LD_INT 990
4105: LESS
4106: OR
4107: IFFALSE 4250
4109: GO 4111
4111: DISABLE
// begin if IsInUnit ( Abdul ) then
4112: LD_EXP 54
4116: PPUSH
4117: CALL_OW 310
4121: IFFALSE 4132
// ComExitBuilding ( Abdul ) ;
4123: LD_EXP 54
4127: PPUSH
4128: CALL_OW 122
// if Mastodont then
4132: LD_EXP 55
4136: IFFALSE 4153
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4138: LD_EXP 55
4142: PPUSH
4143: LD_INT 205
4145: PPUSH
4146: LD_INT 132
4148: PPUSH
4149: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4153: LD_EXP 54
4157: PPUSH
4158: LD_INT 205
4160: PPUSH
4161: LD_INT 132
4163: PPUSH
4164: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4168: LD_INT 35
4170: PPUSH
4171: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4175: LD_EXP 54
4179: PPUSH
4180: LD_INT 21
4182: PPUSH
4183: CALL_OW 308
4187: IFFALSE 4168
// RemoveUnit ( Abdul ) ;
4189: LD_EXP 54
4193: PPUSH
4194: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4198: LD_INT 35
4200: PPUSH
4201: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4205: LD_EXP 55
4209: PPUSH
4210: LD_INT 21
4212: PPUSH
4213: CALL_OW 308
4217: PUSH
4218: LD_EXP 55
4222: PPUSH
4223: CALL_OW 301
4227: OR
4228: IFFALSE 4198
// if IsOk ( Mastodont ) then
4230: LD_EXP 55
4234: PPUSH
4235: CALL_OW 302
4239: IFFALSE 4250
// RemoveUnit ( Mastodont ) ;
4241: LD_EXP 55
4245: PPUSH
4246: CALL_OW 64
// end ;
4250: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4251: LD_EXP 54
4255: PPUSH
4256: CALL_OW 301
4260: PUSH
4261: LD_INT 22
4263: PUSH
4264: LD_INT 2
4266: PUSH
4267: EMPTY
4268: LIST
4269: LIST
4270: PUSH
4271: LD_INT 2
4273: PUSH
4274: LD_INT 25
4276: PUSH
4277: LD_INT 1
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: PUSH
4284: LD_INT 25
4286: PUSH
4287: LD_INT 2
4289: PUSH
4290: EMPTY
4291: LIST
4292: LIST
4293: PUSH
4294: LD_INT 25
4296: PUSH
4297: LD_INT 3
4299: PUSH
4300: EMPTY
4301: LIST
4302: LIST
4303: PUSH
4304: LD_INT 25
4306: PUSH
4307: LD_INT 4
4309: PUSH
4310: EMPTY
4311: LIST
4312: LIST
4313: PUSH
4314: LD_INT 25
4316: PUSH
4317: LD_INT 8
4319: PUSH
4320: EMPTY
4321: LIST
4322: LIST
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: LIST
4328: LIST
4329: LIST
4330: LIST
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PPUSH
4336: CALL_OW 69
4340: PUSH
4341: LD_INT 16
4343: PUSH
4344: LD_INT 19
4346: PUSH
4347: LD_INT 22
4349: PUSH
4350: EMPTY
4351: LIST
4352: LIST
4353: LIST
4354: PUSH
4355: LD_OWVAR 67
4359: ARRAY
4360: LESS
4361: OR
4362: IFFALSE 5035
4364: GO 4366
4366: DISABLE
4367: LD_INT 0
4369: PPUSH
4370: PPUSH
4371: PPUSH
4372: PPUSH
4373: PPUSH
4374: PPUSH
// begin MC_Kill ( 1 ) ;
4375: LD_INT 1
4377: PPUSH
4378: CALL 55750 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4382: LD_ADDR_VAR 0 2
4386: PUSH
4387: LD_INT 22
4389: PUSH
4390: LD_INT 2
4392: PUSH
4393: EMPTY
4394: LIST
4395: LIST
4396: PUSH
4397: LD_INT 2
4399: PUSH
4400: LD_INT 25
4402: PUSH
4403: LD_INT 1
4405: PUSH
4406: EMPTY
4407: LIST
4408: LIST
4409: PUSH
4410: LD_INT 25
4412: PUSH
4413: LD_INT 2
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: PUSH
4420: LD_INT 25
4422: PUSH
4423: LD_INT 3
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 25
4432: PUSH
4433: LD_INT 4
4435: PUSH
4436: EMPTY
4437: LIST
4438: LIST
4439: PUSH
4440: LD_INT 25
4442: PUSH
4443: LD_INT 8
4445: PUSH
4446: EMPTY
4447: LIST
4448: LIST
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: LIST
4454: LIST
4455: LIST
4456: LIST
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PPUSH
4462: CALL_OW 69
4466: ST_TO_ADDR
// for i in tmp do
4467: LD_ADDR_VAR 0 5
4471: PUSH
4472: LD_VAR 0 2
4476: PUSH
4477: FOR_IN
4478: IFFALSE 4494
// SetTag ( i , 10 ) ;
4480: LD_VAR 0 5
4484: PPUSH
4485: LD_INT 10
4487: PPUSH
4488: CALL_OW 109
4492: GO 4477
4494: POP
4495: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4496: LD_ADDR_VAR 0 3
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_INT 2
4506: PUSH
4507: EMPTY
4508: LIST
4509: LIST
4510: PUSH
4511: LD_INT 21
4513: PUSH
4514: LD_INT 1
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PPUSH
4525: CALL_OW 69
4529: PUSH
4530: LD_VAR 0 2
4534: DIFF
4535: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4536: LD_ADDR_VAR 0 1
4540: PUSH
4541: LD_INT 22
4543: PUSH
4544: LD_INT 2
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 21
4553: PUSH
4554: LD_INT 2
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: PUSH
4561: LD_INT 24
4563: PUSH
4564: LD_INT 300
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: PUSH
4571: EMPTY
4572: LIST
4573: LIST
4574: LIST
4575: PPUSH
4576: CALL_OW 69
4580: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4581: LD_ADDR_VAR 0 4
4585: PUSH
4586: LD_VAR 0 1
4590: PPUSH
4591: LD_INT 33
4593: PUSH
4594: LD_INT 1
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 58
4603: PUSH
4604: EMPTY
4605: LIST
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PPUSH
4611: CALL_OW 72
4615: ST_TO_ADDR
// for i in tmp do
4616: LD_ADDR_VAR 0 5
4620: PUSH
4621: LD_VAR 0 2
4625: PUSH
4626: FOR_IN
4627: IFFALSE 4811
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4629: LD_VAR 0 5
4633: PUSH
4634: LD_INT 55
4636: PUSH
4637: EMPTY
4638: LIST
4639: PPUSH
4640: CALL_OW 69
4644: IN
4645: IFFALSE 4664
// begin AddComMoveXY ( i , 209 , 132 ) ;
4647: LD_VAR 0 5
4651: PPUSH
4652: LD_INT 209
4654: PPUSH
4655: LD_INT 132
4657: PPUSH
4658: CALL_OW 171
// continue ;
4662: GO 4626
// end ; if IsInUnit ( i ) then
4664: LD_VAR 0 5
4668: PPUSH
4669: CALL_OW 310
4673: IFFALSE 4691
// begin ComExitBuilding ( i ) ;
4675: LD_VAR 0 5
4679: PPUSH
4680: CALL_OW 122
// wait ( 3 ) ;
4684: LD_INT 3
4686: PPUSH
4687: CALL_OW 67
// end ; if tmp_empty then
4691: LD_VAR 0 4
4695: IFFALSE 4794
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4697: LD_VAR 0 5
4701: PPUSH
4702: LD_VAR 0 4
4706: PPUSH
4707: LD_VAR 0 5
4711: PPUSH
4712: CALL_OW 74
4716: PPUSH
4717: CALL_OW 296
4721: PUSH
4722: LD_INT 25
4724: LESS
4725: IFFALSE 4794
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4727: LD_ADDR_VAR 0 6
4731: PUSH
4732: LD_VAR 0 4
4736: PPUSH
4737: LD_VAR 0 5
4741: PPUSH
4742: CALL_OW 74
4746: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4747: LD_VAR 0 5
4751: PPUSH
4752: LD_VAR 0 6
4756: PPUSH
4757: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4761: LD_VAR 0 5
4765: PPUSH
4766: LD_INT 209
4768: PPUSH
4769: LD_INT 132
4771: PPUSH
4772: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4776: LD_ADDR_VAR 0 4
4780: PUSH
4781: LD_VAR 0 4
4785: PUSH
4786: LD_VAR 0 6
4790: DIFF
4791: ST_TO_ADDR
// continue ;
4792: GO 4626
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4794: LD_VAR 0 5
4798: PPUSH
4799: LD_INT 201
4801: PPUSH
4802: LD_INT 132
4804: PPUSH
4805: CALL_OW 171
// end ;
4809: GO 4626
4811: POP
4812: POP
// for i in tmp_ape do
4813: LD_ADDR_VAR 0 5
4817: PUSH
4818: LD_VAR 0 3
4822: PUSH
4823: FOR_IN
4824: IFFALSE 4863
// begin if IsInUnit ( i ) then
4826: LD_VAR 0 5
4830: PPUSH
4831: CALL_OW 310
4835: IFFALSE 4846
// ComExitBuilding ( i ) ;
4837: LD_VAR 0 5
4841: PPUSH
4842: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4846: LD_VAR 0 5
4850: PPUSH
4851: LD_INT 201
4853: PPUSH
4854: LD_INT 132
4856: PPUSH
4857: CALL_OW 171
// end ;
4861: GO 4823
4863: POP
4864: POP
// repeat wait ( 0 0$1 ) ;
4865: LD_INT 35
4867: PPUSH
4868: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4872: LD_ADDR_VAR 0 5
4876: PUSH
4877: LD_VAR 0 2
4881: PUSH
4882: LD_VAR 0 3
4886: UNION
4887: PUSH
4888: LD_VAR 0 1
4892: UNION
4893: PUSH
4894: FOR_IN
4895: IFFALSE 4926
// if not HasTask ( i ) then
4897: LD_VAR 0 5
4901: PPUSH
4902: CALL_OW 314
4906: NOT
4907: IFFALSE 4924
// ComMoveXY ( i , 201 , 132 ) ;
4909: LD_VAR 0 5
4913: PPUSH
4914: LD_INT 201
4916: PPUSH
4917: LD_INT 132
4919: PPUSH
4920: CALL_OW 111
4924: GO 4894
4926: POP
4927: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4928: LD_INT 21
4930: PPUSH
4931: LD_INT 22
4933: PUSH
4934: LD_INT 2
4936: PUSH
4937: EMPTY
4938: LIST
4939: LIST
4940: PPUSH
4941: CALL_OW 70
4945: IFFALSE 4986
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4947: LD_ADDR_VAR 0 5
4951: PUSH
4952: LD_INT 21
4954: PPUSH
4955: LD_INT 22
4957: PUSH
4958: LD_INT 2
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: PPUSH
4965: CALL_OW 70
4969: PUSH
4970: FOR_IN
4971: IFFALSE 4984
// RemoveUnit ( i ) ;
4973: LD_VAR 0 5
4977: PPUSH
4978: CALL_OW 64
4982: GO 4970
4984: POP
4985: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
4986: LD_INT 22
4988: PUSH
4989: LD_INT 2
4991: PUSH
4992: EMPTY
4993: LIST
4994: LIST
4995: PUSH
4996: LD_INT 2
4998: PUSH
4999: LD_INT 21
5001: PUSH
5002: LD_INT 1
5004: PUSH
5005: EMPTY
5006: LIST
5007: LIST
5008: PUSH
5009: LD_INT 21
5011: PUSH
5012: LD_INT 2
5014: PUSH
5015: EMPTY
5016: LIST
5017: LIST
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: LIST
5023: PUSH
5024: EMPTY
5025: LIST
5026: LIST
5027: PPUSH
5028: CALL_OW 69
5032: NOT
5033: IFFALSE 4865
// end ;
5035: PPOPN 6
5037: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5038: LD_EXP 9
5042: PUSH
5043: LD_INT 92
5045: PPUSH
5046: LD_INT 40
5048: PPUSH
5049: CALL_OW 428
5053: PPUSH
5054: CALL_OW 266
5058: PUSH
5059: LD_INT 30
5061: EQUAL
5062: AND
5063: IFFALSE 5259
5065: GO 5067
5067: DISABLE
5068: LD_INT 0
5070: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5071: LD_ADDR_VAR 0 1
5075: PUSH
5076: LD_EXP 58
5080: PUSH
5081: LD_INT 1
5083: ARRAY
5084: PPUSH
5085: LD_INT 25
5087: PUSH
5088: LD_INT 4
5090: PUSH
5091: EMPTY
5092: LIST
5093: LIST
5094: PPUSH
5095: CALL_OW 72
5099: ST_TO_ADDR
// if not sci then
5100: LD_VAR 0 1
5104: NOT
5105: IFFALSE 5109
// exit ;
5107: GO 5259
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5109: LD_ADDR_EXP 58
5113: PUSH
5114: LD_EXP 58
5118: PPUSH
5119: LD_INT 1
5121: PPUSH
5122: LD_EXP 58
5126: PUSH
5127: LD_INT 1
5129: ARRAY
5130: PUSH
5131: LD_VAR 0 1
5135: PUSH
5136: LD_INT 1
5138: ARRAY
5139: DIFF
5140: PPUSH
5141: CALL_OW 1
5145: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5146: LD_VAR 0 1
5150: PUSH
5151: LD_INT 1
5153: ARRAY
5154: PPUSH
5155: CALL_OW 310
5159: IFFALSE 5174
// ComExitBuilding ( sci [ 1 ] ) ;
5161: LD_VAR 0 1
5165: PUSH
5166: LD_INT 1
5168: ARRAY
5169: PPUSH
5170: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5174: LD_INT 2
5176: PPUSH
5177: LD_INT 105
5179: PPUSH
5180: LD_INT 14
5182: PPUSH
5183: LD_INT 20
5185: PPUSH
5186: CALL 21179 0 4
5190: PUSH
5191: LD_INT 4
5193: ARRAY
5194: PUSH
5195: LD_INT 10
5197: LESS
5198: IFFALSE 5221
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5200: LD_VAR 0 1
5204: PUSH
5205: LD_INT 1
5207: ARRAY
5208: PPUSH
5209: LD_INT 105
5211: PPUSH
5212: LD_INT 14
5214: PPUSH
5215: CALL_OW 171
5219: GO 5240
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5221: LD_VAR 0 1
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: PPUSH
5230: LD_INT 118
5232: PPUSH
5233: LD_INT 77
5235: PPUSH
5236: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5240: LD_VAR 0 1
5244: PUSH
5245: LD_INT 1
5247: ARRAY
5248: PPUSH
5249: LD_INT 92
5251: PPUSH
5252: LD_INT 40
5254: PPUSH
5255: CALL_OW 218
// end ;
5259: PPOPN 1
5261: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5262: LD_INT 1
5264: PPUSH
5265: CALL_OW 302
5269: PUSH
5270: LD_EXP 9
5274: AND
5275: IFFALSE 5745
5277: GO 5279
5279: DISABLE
5280: LD_INT 0
5282: PPUSH
5283: PPUSH
5284: PPUSH
5285: PPUSH
5286: PPUSH
5287: PPUSH
// begin enable ;
5288: ENABLE
// base := 1 ;
5289: LD_ADDR_VAR 0 2
5293: PUSH
5294: LD_INT 1
5296: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5297: LD_ADDR_VAR 0 4
5301: PUSH
5302: LD_INT 0
5304: PUSH
5305: LD_INT 0
5307: PUSH
5308: LD_INT 0
5310: PUSH
5311: LD_INT 0
5313: PUSH
5314: LD_INT 0
5316: PUSH
5317: LD_INT 0
5319: PUSH
5320: LD_INT 0
5322: PUSH
5323: LD_INT 0
5325: PUSH
5326: LD_INT 1
5328: PUSH
5329: LD_INT 0
5331: PUSH
5332: EMPTY
5333: LIST
5334: LIST
5335: LIST
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: LIST
5341: LIST
5342: LIST
5343: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5344: LD_ADDR_VAR 0 3
5348: PUSH
5349: LD_INT 14
5351: PUSH
5352: LD_INT 1
5354: PUSH
5355: LD_INT 2
5357: PUSH
5358: LD_INT 26
5360: PUSH
5361: EMPTY
5362: LIST
5363: LIST
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 14
5369: PUSH
5370: LD_INT 1
5372: PUSH
5373: LD_INT 2
5375: PUSH
5376: LD_INT 28
5378: PUSH
5379: EMPTY
5380: LIST
5381: LIST
5382: LIST
5383: LIST
5384: PUSH
5385: LD_INT 13
5387: PUSH
5388: LD_INT 1
5390: PUSH
5391: LD_INT 2
5393: PUSH
5394: LD_INT 29
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: LIST
5401: LIST
5402: PUSH
5403: EMPTY
5404: LIST
5405: LIST
5406: LIST
5407: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5408: LD_ADDR_VAR 0 1
5412: PUSH
5413: DOUBLE
5414: LD_INT 1
5416: DEC
5417: ST_TO_ADDR
5418: LD_OWVAR 67
5422: PUSH
5423: LD_OWVAR 1
5427: PUSH
5428: LD_INT 21000
5430: DIV
5431: PLUS
5432: PUSH
5433: FOR_TO
5434: IFFALSE 5526
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5436: LD_ADDR_VAR 0 3
5440: PUSH
5441: LD_VAR 0 3
5445: PPUSH
5446: LD_VAR 0 3
5450: PUSH
5451: LD_INT 1
5453: PLUS
5454: PPUSH
5455: LD_INT 13
5457: PUSH
5458: LD_INT 14
5460: PUSH
5461: EMPTY
5462: LIST
5463: LIST
5464: PUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 2
5470: PPUSH
5471: CALL_OW 12
5475: ARRAY
5476: PUSH
5477: LD_INT 1
5479: PUSH
5480: LD_INT 2
5482: PUSH
5483: LD_INT 28
5485: PUSH
5486: LD_INT 29
5488: PUSH
5489: LD_INT 25
5491: PUSH
5492: LD_INT 26
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: LIST
5500: PUSH
5501: LD_INT 1
5503: PPUSH
5504: LD_INT 4
5506: PPUSH
5507: CALL_OW 12
5511: ARRAY
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: LIST
5517: LIST
5518: PPUSH
5519: CALL_OW 2
5523: ST_TO_ADDR
5524: GO 5433
5526: POP
5527: POP
// MC_SetProduceList ( base , tmp ) ;
5528: LD_VAR 0 2
5532: PPUSH
5533: LD_VAR 0 3
5537: PPUSH
5538: CALL 77349 0 2
// repeat wait ( 0 0$1 ) ;
5542: LD_INT 35
5544: PPUSH
5545: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5549: LD_VAR 0 2
5553: PPUSH
5554: CALL 77803 0 1
5558: PUSH
5559: LD_INT 0
5561: EQUAL
5562: IFFALSE 5542
// wait ( 0 0$20 ) ;
5564: LD_INT 700
5566: PPUSH
5567: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5571: LD_ADDR_VAR 0 5
5575: PUSH
5576: LD_INT 124
5578: PUSH
5579: LD_INT 85
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 90
5588: PUSH
5589: LD_INT 61
5591: PUSH
5592: EMPTY
5593: LIST
5594: LIST
5595: PUSH
5596: LD_INT 69
5598: PUSH
5599: LD_INT 48
5601: PUSH
5602: EMPTY
5603: LIST
5604: LIST
5605: PUSH
5606: LD_INT 68
5608: PUSH
5609: LD_INT 48
5611: PUSH
5612: EMPTY
5613: LIST
5614: LIST
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: LIST
5620: LIST
5621: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
5622: LD_ADDR_VAR 0 6
5626: PUSH
5627: LD_EXP 77
5631: PUSH
5632: LD_VAR 0 2
5636: ARRAY
5637: PUSH
5638: LD_EXP 80
5642: PUSH
5643: LD_VAR 0 2
5647: ARRAY
5648: PUSH
5649: LD_EXP 77
5653: PUSH
5654: LD_VAR 0 2
5658: ARRAY
5659: PPUSH
5660: LD_INT 34
5662: PUSH
5663: LD_INT 32
5665: PUSH
5666: EMPTY
5667: LIST
5668: LIST
5669: PPUSH
5670: CALL_OW 72
5674: UNION
5675: DIFF
5676: ST_TO_ADDR
// if not attackers then
5677: LD_VAR 0 6
5681: NOT
5682: IFFALSE 5686
// exit ;
5684: GO 5745
// ar_attackers := attackers ;
5686: LD_ADDR_EXP 10
5690: PUSH
5691: LD_VAR 0 6
5695: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5696: LD_INT 35
5698: PPUSH
5699: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5703: LD_VAR 0 6
5707: PPUSH
5708: LD_INT 60
5710: PUSH
5711: EMPTY
5712: LIST
5713: PPUSH
5714: CALL_OW 72
5718: NOT
5719: IFFALSE 5696
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5721: LD_VAR 0 2
5725: PPUSH
5726: LD_VAR 0 6
5730: PPUSH
5731: LD_VAR 0 5
5735: PPUSH
5736: LD_VAR 0 4
5740: PPUSH
5741: CALL 77640 0 4
// end ;
5745: PPOPN 6
5747: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5748: LD_INT 1
5750: PPUSH
5751: CALL_OW 302
5755: PUSH
5756: LD_EXP 9
5760: AND
5761: PUSH
5762: LD_EXP 48
5766: PPUSH
5767: LD_INT 22
5769: PPUSH
5770: CALL_OW 308
5774: AND
5775: PUSH
5776: LD_INT 1
5778: PPUSH
5779: CALL 77803 0 1
5783: PUSH
5784: LD_INT 0
5786: EQUAL
5787: AND
5788: PUSH
5789: LD_EXP 10
5793: NOT
5794: AND
5795: IFFALSE 6270
5797: GO 5799
5799: DISABLE
5800: LD_INT 0
5802: PPUSH
5803: PPUSH
5804: PPUSH
5805: PPUSH
5806: PPUSH
5807: PPUSH
5808: PPUSH
// begin base := 1 ;
5809: LD_ADDR_VAR 0 2
5813: PUSH
5814: LD_INT 1
5816: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5817: LD_ADDR_VAR 0 4
5821: PUSH
5822: LD_INT 0
5824: PUSH
5825: LD_INT 0
5827: PUSH
5828: LD_INT 0
5830: PUSH
5831: LD_INT 0
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 0
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: LD_INT 1
5848: PUSH
5849: LD_INT 0
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: LIST
5863: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5864: LD_ADDR_VAR 0 3
5868: PUSH
5869: LD_INT 13
5871: PUSH
5872: LD_INT 1
5874: PUSH
5875: LD_INT 2
5877: PUSH
5878: LD_INT 28
5880: PUSH
5881: EMPTY
5882: LIST
5883: LIST
5884: LIST
5885: LIST
5886: PUSH
5887: LD_INT 13
5889: PUSH
5890: LD_INT 1
5892: PUSH
5893: LD_INT 2
5895: PUSH
5896: LD_INT 27
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: PUSH
5905: LD_INT 13
5907: PUSH
5908: LD_INT 1
5910: PUSH
5911: LD_INT 2
5913: PUSH
5914: LD_INT 25
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: LIST
5922: PUSH
5923: LD_INT 11
5925: PUSH
5926: LD_INT 2
5928: PUSH
5929: LD_INT 2
5931: PUSH
5932: LD_INT 24
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_INT 11
5943: PUSH
5944: LD_INT 2
5946: PUSH
5947: LD_INT 2
5949: PUSH
5950: LD_INT 24
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: PUSH
5959: EMPTY
5960: LIST
5961: LIST
5962: LIST
5963: LIST
5964: LIST
5965: ST_TO_ADDR
// MC_SetProduceList ( base , tmp ) ;
5966: LD_VAR 0 2
5970: PPUSH
5971: LD_VAR 0 3
5975: PPUSH
5976: CALL 77349 0 2
// repeat wait ( 0 0$1 ) ;
5980: LD_INT 35
5982: PPUSH
5983: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5987: LD_VAR 0 2
5991: PPUSH
5992: CALL 77803 0 1
5996: PUSH
5997: LD_INT 0
5999: EQUAL
6000: IFFALSE 5980
// wait ( 0 0$20 ) ;
6002: LD_INT 700
6004: PPUSH
6005: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6009: LD_ADDR_VAR 0 5
6013: PUSH
6014: LD_INT 119
6016: PUSH
6017: LD_INT 9
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: PUSH
6024: EMPTY
6025: LIST
6026: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
6027: LD_ADDR_VAR 0 6
6031: PUSH
6032: LD_EXP 77
6036: PUSH
6037: LD_VAR 0 2
6041: ARRAY
6042: PUSH
6043: LD_EXP 80
6047: PUSH
6048: LD_VAR 0 2
6052: ARRAY
6053: PUSH
6054: LD_EXP 77
6058: PUSH
6059: LD_VAR 0 2
6063: ARRAY
6064: PPUSH
6065: LD_INT 34
6067: PUSH
6068: LD_INT 32
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: UNION
6080: DIFF
6081: ST_TO_ADDR
// if not attackers then
6082: LD_VAR 0 6
6086: NOT
6087: IFFALSE 6091
// exit ;
6089: GO 6270
// uc_side := 2 ;
6091: LD_ADDR_OWVAR 20
6095: PUSH
6096: LD_INT 2
6098: ST_TO_ADDR
// uc_nation := 2 ;
6099: LD_ADDR_OWVAR 21
6103: PUSH
6104: LD_INT 2
6106: ST_TO_ADDR
// InitHc ;
6107: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6111: LD_ADDR_VAR 0 1
6115: PUSH
6116: DOUBLE
6117: LD_INT 1
6119: DEC
6120: ST_TO_ADDR
6121: LD_INT 4
6123: PUSH
6124: LD_INT 5
6126: PUSH
6127: LD_INT 6
6129: PUSH
6130: EMPTY
6131: LIST
6132: LIST
6133: LIST
6134: PUSH
6135: LD_OWVAR 67
6139: ARRAY
6140: PUSH
6141: FOR_TO
6142: IFFALSE 6219
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6144: LD_INT 0
6146: PPUSH
6147: LD_INT 15
6149: PUSH
6150: LD_INT 17
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PUSH
6157: LD_INT 1
6159: PPUSH
6160: LD_INT 2
6162: PPUSH
6163: CALL_OW 12
6167: ARRAY
6168: PPUSH
6169: LD_INT 8
6171: PPUSH
6172: CALL_OW 380
// un := CreateHuman ;
6176: LD_ADDR_VAR 0 7
6180: PUSH
6181: CALL_OW 44
6185: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6186: LD_VAR 0 7
6190: PPUSH
6191: LD_INT 23
6193: PPUSH
6194: LD_INT 0
6196: PPUSH
6197: CALL_OW 49
// attackers := attackers union un ;
6201: LD_ADDR_VAR 0 6
6205: PUSH
6206: LD_VAR 0 6
6210: PUSH
6211: LD_VAR 0 7
6215: UNION
6216: ST_TO_ADDR
// end ;
6217: GO 6141
6219: POP
6220: POP
// repeat wait ( 0 0$1 ) ;
6221: LD_INT 35
6223: PPUSH
6224: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6228: LD_VAR 0 6
6232: PPUSH
6233: LD_INT 60
6235: PUSH
6236: EMPTY
6237: LIST
6238: PPUSH
6239: CALL_OW 72
6243: NOT
6244: IFFALSE 6221
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6246: LD_VAR 0 2
6250: PPUSH
6251: LD_VAR 0 6
6255: PPUSH
6256: LD_VAR 0 5
6260: PPUSH
6261: LD_VAR 0 4
6265: PPUSH
6266: CALL 77640 0 4
// end ; end_of_file
6270: PPOPN 7
6272: END
// export function PrepareAmericanAttack ; var i , tmp , veh , flags , _target ; begin
6273: LD_INT 0
6275: PPUSH
6276: PPUSH
6277: PPUSH
6278: PPUSH
6279: PPUSH
6280: PPUSH
// uc_side := 1 ;
6281: LD_ADDR_OWVAR 20
6285: PUSH
6286: LD_INT 1
6288: ST_TO_ADDR
// uc_nation := 1 ;
6289: LD_ADDR_OWVAR 21
6293: PUSH
6294: LD_INT 1
6296: ST_TO_ADDR
// InitHc ;
6297: CALL_OW 19
// InitVc ;
6301: CALL_OW 20
// tmp := [ ] ;
6305: LD_ADDR_VAR 0 3
6309: PUSH
6310: EMPTY
6311: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6312: LD_ADDR_VAR 0 5
6316: PUSH
6317: LD_INT 0
6319: PUSH
6320: LD_INT 0
6322: PUSH
6323: LD_INT 0
6325: PUSH
6326: LD_INT 0
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_INT 0
6334: PUSH
6335: LD_INT 0
6337: PUSH
6338: LD_INT 0
6340: PUSH
6341: LD_INT 1
6343: PUSH
6344: LD_INT 0
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: ST_TO_ADDR
// _target := [ [ 71 , 34 ] , [ 63 , 49 ] ] ;
6359: LD_ADDR_VAR 0 6
6363: PUSH
6364: LD_INT 71
6366: PUSH
6367: LD_INT 34
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: PUSH
6374: LD_INT 63
6376: PUSH
6377: LD_INT 49
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: PUSH
6384: EMPTY
6385: LIST
6386: LIST
6387: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6388: LD_ADDR_VAR 0 2
6392: PUSH
6393: DOUBLE
6394: LD_INT 1
6396: DEC
6397: ST_TO_ADDR
6398: LD_INT 5
6400: PUSH
6401: LD_INT 6
6403: PUSH
6404: LD_INT 6
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: LIST
6411: PUSH
6412: LD_OWVAR 67
6416: ARRAY
6417: PUSH
6418: FOR_TO
6419: IFFALSE 6556
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6421: LD_INT 2
6423: PUSH
6424: LD_INT 4
6426: PUSH
6427: LD_INT 5
6429: PUSH
6430: EMPTY
6431: LIST
6432: LIST
6433: LIST
6434: PUSH
6435: LD_INT 1
6437: PPUSH
6438: LD_INT 3
6440: PPUSH
6441: CALL_OW 12
6445: ARRAY
6446: PPUSH
6447: LD_INT 1
6449: PUSH
6450: LD_INT 3
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PUSH
6457: LD_INT 1
6459: PPUSH
6460: LD_INT 2
6462: PPUSH
6463: CALL_OW 12
6467: ARRAY
6468: PPUSH
6469: LD_INT 3
6471: PPUSH
6472: LD_INT 9
6474: PUSH
6475: LD_INT 7
6477: PUSH
6478: EMPTY
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 1
6484: PPUSH
6485: LD_INT 2
6487: PPUSH
6488: CALL_OW 12
6492: ARRAY
6493: PPUSH
6494: LD_INT 78
6496: PPUSH
6497: CALL 20128 0 5
// veh := CreateVehicle ;
6501: LD_ADDR_VAR 0 4
6505: PUSH
6506: CALL_OW 45
6510: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6511: LD_VAR 0 4
6515: PPUSH
6516: LD_INT 2
6518: PPUSH
6519: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 17
6530: PPUSH
6531: LD_INT 0
6533: PPUSH
6534: CALL_OW 49
// tmp := tmp ^ veh ;
6538: LD_ADDR_VAR 0 3
6542: PUSH
6543: LD_VAR 0 3
6547: PUSH
6548: LD_VAR 0 4
6552: ADD
6553: ST_TO_ADDR
// end ;
6554: GO 6418
6556: POP
6557: POP
// if not tmp then
6558: LD_VAR 0 3
6562: NOT
6563: IFFALSE 6567
// exit ;
6565: GO 6610
// if not first_powell_attack then
6567: LD_EXP 11
6571: NOT
6572: IFFALSE 6582
// first_powell_attack := true ;
6574: LD_ADDR_EXP 11
6578: PUSH
6579: LD_INT 1
6581: ST_TO_ADDR
// Attack ( [ 0 , tmp , _target , flags ] ) ;
6582: LD_INT 0
6584: PUSH
6585: LD_VAR 0 3
6589: PUSH
6590: LD_VAR 0 6
6594: PUSH
6595: LD_VAR 0 5
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PPUSH
6606: CALL 48521 0 1
// end ; end_of_file
6610: LD_VAR 0 1
6614: RET
// export function Action ; var tmp , i , un ; begin
6615: LD_INT 0
6617: PPUSH
6618: PPUSH
6619: PPUSH
6620: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6621: LD_INT 68
6623: PPUSH
6624: LD_INT 39
6626: PPUSH
6627: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: LD_INT 22
6638: PUSH
6639: LD_INT 7
6641: PUSH
6642: EMPTY
6643: LIST
6644: LIST
6645: PPUSH
6646: CALL_OW 69
6650: ST_TO_ADDR
// InGameOn ;
6651: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 71
6662: PPUSH
6663: LD_INT 49
6665: PPUSH
6666: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6670: LD_INT 35
6672: PPUSH
6673: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6677: LD_INT 7
6679: PPUSH
6680: LD_INT 71
6682: PPUSH
6683: LD_INT 51
6685: PPUSH
6686: CALL_OW 293
6690: IFFALSE 6670
// DialogueOn ;
6692: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6696: LD_EXP 14
6700: PPUSH
6701: LD_STRING D1-JMM-1
6703: PPUSH
6704: CALL_OW 88
// if Joan then
6708: LD_EXP 29
6712: IFFALSE 6726
// Say ( Joan , D1-Joan-1 ) ;
6714: LD_EXP 29
6718: PPUSH
6719: LD_STRING D1-Joan-1
6721: PPUSH
6722: CALL_OW 88
// if Lisa then
6726: LD_EXP 16
6730: IFFALSE 6744
// Say ( Lisa , D1-Lisa-1 ) ;
6732: LD_EXP 16
6736: PPUSH
6737: LD_STRING D1-Lisa-1
6739: PPUSH
6740: CALL_OW 88
// if Joan or Lisa then
6744: LD_EXP 29
6748: PUSH
6749: LD_EXP 16
6753: OR
6754: IFFALSE 6768
// Say ( JMM , D1-JMM-2 ) ;
6756: LD_EXP 14
6760: PPUSH
6761: LD_STRING D1-JMM-2
6763: PPUSH
6764: CALL_OW 88
// DialogueOff ;
6768: CALL_OW 7
// InGameOff ;
6772: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6776: LD_INT 71
6778: PPUSH
6779: LD_INT 50
6781: PPUSH
6782: LD_INT 7
6784: PPUSH
6785: LD_INT 30
6787: NEG
6788: PPUSH
6789: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6793: LD_INT 71
6795: PPUSH
6796: LD_INT 50
6798: PPUSH
6799: LD_INT 7
6801: PPUSH
6802: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6806: LD_STRING M1
6808: PPUSH
6809: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6813: LD_INT 35
6815: PPUSH
6816: CALL_OW 67
// until freedom ;
6820: LD_EXP 3
6824: IFFALSE 6813
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6826: LD_INT 350
6828: PPUSH
6829: LD_INT 700
6831: PPUSH
6832: CALL_OW 12
6836: PPUSH
6837: CALL_OW 67
// PrepareGossudarov ;
6841: CALL 1678 0 0
// repeat wait ( 0 0$1 ) ;
6845: LD_INT 35
6847: PPUSH
6848: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6852: LD_INT 22
6854: PUSH
6855: LD_INT 6
6857: PUSH
6858: EMPTY
6859: LIST
6860: LIST
6861: PUSH
6862: LD_INT 3
6864: PUSH
6865: LD_INT 24
6867: PUSH
6868: LD_INT 1000
6870: PUSH
6871: EMPTY
6872: LIST
6873: LIST
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PUSH
6879: EMPTY
6880: LIST
6881: LIST
6882: PPUSH
6883: CALL_OW 69
6887: IFFALSE 6845
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6889: LD_ADDR_VAR 0 2
6893: PUSH
6894: LD_INT 22
6896: PUSH
6897: LD_INT 6
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PPUSH
6904: CALL_OW 69
6908: ST_TO_ADDR
// for i in tmp do
6909: LD_ADDR_VAR 0 3
6913: PUSH
6914: LD_VAR 0 2
6918: PUSH
6919: FOR_IN
6920: IFFALSE 6936
// SetSide ( i , 7 ) ;
6922: LD_VAR 0 3
6926: PPUSH
6927: LD_INT 7
6929: PPUSH
6930: CALL_OW 235
6934: GO 6919
6936: POP
6937: POP
// DialogueOn ;
6938: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6942: LD_EXP 14
6946: PUSH
6947: LD_EXP 15
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PPUSH
6956: LD_EXP 31
6960: PPUSH
6961: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6965: LD_EXP 31
6969: PPUSH
6970: CALL_OW 87
// if not Roth then
6974: LD_EXP 15
6978: NOT
6979: IFFALSE 7043
// begin Say ( JMM , D2-JMM-1 ) ;
6981: LD_EXP 14
6985: PPUSH
6986: LD_STRING D2-JMM-1
6988: PPUSH
6989: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
6993: LD_EXP 14
6997: PPUSH
6998: LD_STRING D2-JMM-1b
7000: PPUSH
7001: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7005: LD_EXP 31
7009: PPUSH
7010: LD_STRING D2-Gos-1
7012: PPUSH
7013: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7017: LD_EXP 14
7021: PPUSH
7022: LD_STRING D2-JMM-2
7024: PPUSH
7025: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7029: LD_EXP 31
7033: PPUSH
7034: LD_STRING D2-Gos-2
7036: PPUSH
7037: CALL_OW 88
// end else
7041: GO 7139
// begin Say ( Roth , D2-Roth-2 ) ;
7043: LD_EXP 15
7047: PPUSH
7048: LD_STRING D2-Roth-2
7050: PPUSH
7051: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7055: LD_EXP 14
7059: PPUSH
7060: LD_STRING D2-JMM-1a
7062: PPUSH
7063: CALL_OW 88
// Say ( Roth , D2-Roth-2a ) ;
7067: LD_EXP 15
7071: PPUSH
7072: LD_STRING D2-Roth-2a
7074: PPUSH
7075: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7079: LD_EXP 15
7083: PPUSH
7084: LD_STRING D2-Roth-2b
7086: PPUSH
7087: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7091: LD_EXP 14
7095: PPUSH
7096: LD_STRING D2-JMM-3
7098: PPUSH
7099: CALL_OW 88
// Say ( Gossudarov , D2-Gos-3 ) ;
7103: LD_EXP 31
7107: PPUSH
7108: LD_STRING D2-Gos-3
7110: PPUSH
7111: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7115: LD_EXP 14
7119: PPUSH
7120: LD_STRING D2-JMM-4
7122: PPUSH
7123: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7127: LD_EXP 31
7131: PPUSH
7132: LD_STRING D2-Gos-4
7134: PPUSH
7135: CALL_OW 88
// end ; Say ( JMM , D2-JMM-5 ) ;
7139: LD_EXP 14
7143: PPUSH
7144: LD_STRING D2-JMM-5
7146: PPUSH
7147: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7151: LD_EXP 31
7155: PPUSH
7156: LD_STRING D2-Gos-5
7158: PPUSH
7159: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7163: LD_EXP 14
7167: PPUSH
7168: LD_STRING D2-JMM-6
7170: PPUSH
7171: CALL_OW 88
// DialogueOff ;
7175: CALL_OW 7
// wait ( 0 0$2 ) ;
7179: LD_INT 70
7181: PPUSH
7182: CALL_OW 67
// if Kirilenkova then
7186: LD_EXP 32
7190: IFFALSE 7204
// Say ( Kirilenkova , D3-Kir-1 ) ;
7192: LD_EXP 32
7196: PPUSH
7197: LD_STRING D3-Kir-1
7199: PPUSH
7200: CALL_OW 88
// gossudarov_arrive := true ;
7204: LD_ADDR_EXP 4
7208: PUSH
7209: LD_INT 1
7211: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7212: LD_INT 35
7214: PPUSH
7215: CALL_OW 67
// until ru_lab_builded ;
7219: LD_EXP 5
7223: IFFALSE 7212
// if Kirilenkova then
7225: LD_EXP 32
7229: IFFALSE 7245
// Say ( Kirilenkova , D3a-Kir-1 ) else
7231: LD_EXP 32
7235: PPUSH
7236: LD_STRING D3a-Kir-1
7238: PPUSH
7239: CALL_OW 88
7243: GO 7267
// begin un := SciRu ;
7245: LD_ADDR_VAR 0 4
7249: PUSH
7250: CALL 12034 0 0
7254: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7255: LD_VAR 0 4
7259: PPUSH
7260: LD_STRING D3a-Sci1-1
7262: PPUSH
7263: CALL_OW 88
// end ; if Kirilenkova or un then
7267: LD_EXP 32
7271: PUSH
7272: LD_VAR 0 4
7276: OR
7277: IFFALSE 7291
// Say ( JMM , D3a-JMM-1 ) ;
7279: LD_EXP 14
7283: PPUSH
7284: LD_STRING D3a-JMM-1
7286: PPUSH
7287: CALL_OW 88
// end ;
7291: LD_VAR 0 1
7295: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7296: LD_EXP 4
7300: PUSH
7301: LD_INT 22
7303: PUSH
7304: LD_INT 7
7306: PUSH
7307: EMPTY
7308: LIST
7309: LIST
7310: PUSH
7311: LD_INT 2
7313: PUSH
7314: LD_INT 25
7316: PUSH
7317: LD_INT 1
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: PUSH
7324: LD_INT 25
7326: PUSH
7327: LD_INT 2
7329: PUSH
7330: EMPTY
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 25
7336: PUSH
7337: LD_INT 3
7339: PUSH
7340: EMPTY
7341: LIST
7342: LIST
7343: PUSH
7344: LD_INT 25
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: PUSH
7354: LD_INT 25
7356: PUSH
7357: LD_INT 5
7359: PUSH
7360: EMPTY
7361: LIST
7362: LIST
7363: PUSH
7364: LD_INT 25
7366: PUSH
7367: LD_INT 8
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: PUSH
7374: LD_INT 25
7376: PUSH
7377: LD_INT 9
7379: PUSH
7380: EMPTY
7381: LIST
7382: LIST
7383: PUSH
7384: EMPTY
7385: LIST
7386: LIST
7387: LIST
7388: LIST
7389: LIST
7390: LIST
7391: LIST
7392: LIST
7393: PUSH
7394: EMPTY
7395: LIST
7396: LIST
7397: PPUSH
7398: CALL_OW 69
7402: PUSH
7403: LD_INT 6
7405: LESS
7406: AND
7407: IFFALSE 7419
7409: GO 7411
7411: DISABLE
// YouLost ( TooMany ) ;
7412: LD_STRING TooMany
7414: PPUSH
7415: CALL_OW 104
7419: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7420: LD_EXP 31
7424: PPUSH
7425: CALL_OW 255
7429: PUSH
7430: LD_INT 7
7432: EQUAL
7433: IFFALSE 7633
7435: GO 7437
7437: DISABLE
7438: LD_INT 0
7440: PPUSH
7441: PPUSH
7442: PPUSH
// begin uc_side := 3 ;
7443: LD_ADDR_OWVAR 20
7447: PUSH
7448: LD_INT 3
7450: ST_TO_ADDR
// uc_nation := 3 ;
7451: LD_ADDR_OWVAR 21
7455: PUSH
7456: LD_INT 3
7458: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7459: LD_INT 21
7461: PPUSH
7462: LD_INT 3
7464: PPUSH
7465: LD_INT 3
7467: PPUSH
7468: LD_INT 42
7470: PPUSH
7471: LD_INT 100
7473: PPUSH
7474: CALL 20128 0 5
// un := CreateVehicle ;
7478: LD_ADDR_VAR 0 3
7482: PUSH
7483: CALL_OW 45
7487: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7488: LD_VAR 0 3
7492: PPUSH
7493: LD_INT 15
7495: PPUSH
7496: LD_INT 0
7498: PPUSH
7499: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7503: LD_VAR 0 3
7507: PPUSH
7508: LD_INT 67
7510: PPUSH
7511: LD_INT 45
7513: PPUSH
7514: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7518: LD_VAR 0 3
7522: PPUSH
7523: LD_INT 70
7525: PPUSH
7526: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7530: LD_VAR 0 3
7534: PPUSH
7535: LD_INT 69
7537: PPUSH
7538: LD_INT 18
7540: PPUSH
7541: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7545: LD_VAR 0 3
7549: PPUSH
7550: LD_INT 60
7552: PPUSH
7553: LD_INT 2
7555: PPUSH
7556: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7560: LD_INT 35
7562: PPUSH
7563: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7567: LD_VAR 0 3
7571: PPUSH
7572: CALL_OW 302
7576: NOT
7577: PUSH
7578: LD_VAR 0 3
7582: PPUSH
7583: LD_INT 17
7585: PPUSH
7586: CALL_OW 308
7590: OR
7591: IFFALSE 7560
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7593: LD_VAR 0 3
7597: PPUSH
7598: LD_INT 17
7600: PPUSH
7601: CALL_OW 308
7605: PUSH
7606: LD_VAR 0 3
7610: PPUSH
7611: LD_INT 60
7613: PPUSH
7614: LD_INT 2
7616: PPUSH
7617: CALL_OW 307
7621: OR
7622: IFFALSE 7633
// RemoveUnit ( un ) ;
7624: LD_VAR 0 3
7628: PPUSH
7629: CALL_OW 64
// end ;
7633: PPOPN 3
7635: END
// every 0 0$2 do var i , un , tmp ;
7636: GO 7638
7638: DISABLE
7639: LD_INT 0
7641: PPUSH
7642: PPUSH
7643: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7644: LD_INT 70
7646: PPUSH
7647: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7651: LD_ADDR_VAR 0 3
7655: PUSH
7656: LD_INT 22
7658: PUSH
7659: LD_INT 7
7661: PUSH
7662: EMPTY
7663: LIST
7664: LIST
7665: PUSH
7666: LD_INT 101
7668: PUSH
7669: LD_INT 3
7671: PUSH
7672: EMPTY
7673: LIST
7674: LIST
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PPUSH
7680: CALL_OW 69
7684: ST_TO_ADDR
// until tmp ;
7685: LD_VAR 0 3
7689: IFFALSE 7644
// un := NearestUnitToUnit ( tmp , JMM ) ;
7691: LD_ADDR_VAR 0 2
7695: PUSH
7696: LD_VAR 0 3
7700: PPUSH
7701: LD_EXP 14
7705: PPUSH
7706: CALL_OW 74
7710: ST_TO_ADDR
// player_spotted := true ;
7711: LD_ADDR_EXP 6
7715: PUSH
7716: LD_INT 1
7718: ST_TO_ADDR
// tmp := SciRu ;
7719: LD_ADDR_VAR 0 3
7723: PUSH
7724: CALL 12034 0 0
7728: ST_TO_ADDR
// DialogueOn ;
7729: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7733: LD_VAR 0 2
7737: PPUSH
7738: CALL_OW 250
7742: PPUSH
7743: LD_VAR 0 2
7747: PPUSH
7748: CALL_OW 251
7752: PPUSH
7753: LD_INT 7
7755: PPUSH
7756: LD_INT 8
7758: NEG
7759: PPUSH
7760: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7764: LD_VAR 0 2
7768: PPUSH
7769: CALL_OW 87
// if tmp then
7773: LD_VAR 0 3
7777: IFFALSE 7791
// Say ( tmp , D4-RSci1-1 ) ;
7779: LD_VAR 0 3
7783: PPUSH
7784: LD_STRING D4-RSci1-1
7786: PPUSH
7787: CALL_OW 88
// if Gossudarov then
7791: LD_EXP 31
7795: IFFALSE 7821
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7797: LD_EXP 31
7801: PPUSH
7802: LD_STRING D4-Gos-1
7804: PPUSH
7805: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7809: LD_EXP 14
7813: PPUSH
7814: LD_STRING D4-JMM-1
7816: PPUSH
7817: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7821: LD_VAR 0 2
7825: PPUSH
7826: CALL_OW 250
7830: PPUSH
7831: LD_VAR 0 2
7835: PPUSH
7836: CALL_OW 251
7840: PPUSH
7841: LD_INT 7
7843: PPUSH
7844: CALL_OW 331
// DialogueOff ;
7848: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7852: LD_STRING M5
7854: PPUSH
7855: CALL_OW 337
// end ;
7859: PPOPN 3
7861: END
// every 0 0$30 + 2 2$30 trigger player_spotted do
7862: LD_EXP 6
7866: IFFALSE 8325
7868: GO 7870
7870: DISABLE
// begin PrepareBelkov ;
7871: CALL 1928 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7875: LD_EXP 46
7879: PPUSH
7880: LD_INT 118
7882: PPUSH
7883: LD_INT 106
7885: PPUSH
7886: CALL_OW 111
// AddComHold ( Belkov ) ;
7890: LD_EXP 46
7894: PPUSH
7895: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
7899: LD_INT 35
7901: PPUSH
7902: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
7906: LD_EXP 46
7910: PPUSH
7911: LD_INT 118
7913: PPUSH
7914: LD_INT 106
7916: PPUSH
7917: CALL_OW 307
7921: IFFALSE 7899
// ChangeSideFog ( 4 , 7 ) ;
7923: LD_INT 4
7925: PPUSH
7926: LD_INT 7
7928: PPUSH
7929: CALL_OW 343
// if IsOk ( Belkov ) then
7933: LD_EXP 46
7937: PPUSH
7938: CALL_OW 302
7942: IFFALSE 8026
// begin InGameOn ;
7944: CALL_OW 8
// DialogueOn ;
7948: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
7952: LD_EXP 46
7956: PPUSH
7957: LD_STRING D5-Bel-1
7959: PPUSH
7960: CALL_OW 94
// if Gossudarov then
7964: LD_EXP 31
7968: IFFALSE 8018
// begin Say ( Gossudarov , D5-Gos-1 ) ;
7970: LD_EXP 31
7974: PPUSH
7975: LD_STRING D5-Gos-1
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
7982: LD_EXP 14
7986: PPUSH
7987: LD_STRING D5-JMM-1
7989: PPUSH
7990: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
7994: LD_EXP 31
7998: PPUSH
7999: LD_STRING D5-Gos-2
8001: PPUSH
8002: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8006: LD_EXP 14
8010: PPUSH
8011: LD_STRING D5-JMM-2
8013: PPUSH
8014: CALL_OW 88
// end ; DialogueOff ;
8018: CALL_OW 7
// InGameOff ;
8022: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8026: LD_STRING QSaveBelkov
8028: PPUSH
8029: CALL_OW 97
8033: PUSH
8034: LD_INT 1
8036: DOUBLE
8037: EQUAL
8038: IFTRUE 8042
8040: GO 8092
8042: POP
// begin DialogueOn ;
8043: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8047: LD_EXP 14
8051: PPUSH
8052: LD_STRING D5a-JMM-1
8054: PPUSH
8055: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8059: LD_EXP 46
8063: PPUSH
8064: LD_STRING D5a-Bel-1
8066: PPUSH
8067: CALL_OW 94
// DialogueOff ;
8071: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8075: LD_EXP 46
8079: PPUSH
8080: LD_INT 83
8082: PPUSH
8083: LD_INT 49
8085: PPUSH
8086: CALL_OW 111
// end ; 2 :
8090: GO 8152
8092: LD_INT 2
8094: DOUBLE
8095: EQUAL
8096: IFTRUE 8100
8098: GO 8151
8100: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8101: LD_EXP 14
8105: PPUSH
8106: LD_STRING D5a-JMM-2
8108: PPUSH
8109: CALL_OW 88
// ComWait ( Belkov , 0 0$10 ) ;
8113: LD_EXP 46
8117: PPUSH
8118: LD_INT 350
8120: PPUSH
8121: CALL_OW 142
// AddComMoveXY ( Belkov , 107 , 109 ) ;
8125: LD_EXP 46
8129: PPUSH
8130: LD_INT 107
8132: PPUSH
8133: LD_INT 109
8135: PPUSH
8136: CALL_OW 171
// AddComHold ( Belkov ) ;
8140: LD_EXP 46
8144: PPUSH
8145: CALL_OW 200
// end ; end ;
8149: GO 8152
8151: POP
// repeat wait ( 0 0$1 ) ;
8152: LD_INT 35
8154: PPUSH
8155: CALL_OW 67
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8159: LD_EXP 46
8163: PPUSH
8164: CALL_OW 301
8168: PUSH
8169: LD_EXP 46
8173: PPUSH
8174: CALL_OW 255
8178: PUSH
8179: LD_INT 4
8181: EQUAL
8182: AND
8183: PUSH
8184: LD_INT 22
8186: PUSH
8187: LD_INT 7
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PPUSH
8194: CALL_OW 69
8198: PPUSH
8199: LD_EXP 46
8203: PPUSH
8204: CALL_OW 74
8208: PPUSH
8209: LD_EXP 46
8213: PPUSH
8214: CALL_OW 296
8218: PUSH
8219: LD_INT 10
8221: LESS
8222: OR
8223: IFFALSE 8152
// if IsDead ( Belkov ) then
8225: LD_EXP 46
8229: PPUSH
8230: CALL_OW 301
8234: IFFALSE 8259
// begin CenterNowOnUnits ( Belkov ) ;
8236: LD_EXP 46
8240: PPUSH
8241: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8245: LD_EXP 14
8249: PPUSH
8250: LD_STRING D5a-JMM-2a
8252: PPUSH
8253: CALL_OW 88
// exit ;
8257: GO 8325
// end ; if See ( 7 , Belkov ) then
8259: LD_INT 7
8261: PPUSH
8262: LD_EXP 46
8266: PPUSH
8267: CALL_OW 292
8271: IFFALSE 8285
// SetSide ( Belkov , 7 ) ;
8273: LD_EXP 46
8277: PPUSH
8278: LD_INT 7
8280: PPUSH
8281: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8285: LD_INT 35
8287: PPUSH
8288: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8292: LD_EXP 46
8296: PPUSH
8297: LD_INT 66
8299: PPUSH
8300: LD_INT 45
8302: PPUSH
8303: CALL_OW 297
8307: PUSH
8308: LD_INT 30
8310: LESS
8311: IFFALSE 8285
// Say ( Belkov , D6-Bel-1 ) ;
8313: LD_EXP 46
8317: PPUSH
8318: LD_STRING D6-Bel-1
8320: PPUSH
8321: CALL_OW 88
// end ;
8325: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8326: LD_EXP 46
8330: PPUSH
8331: CALL_OW 302
8335: PUSH
8336: LD_EXP 46
8340: PPUSH
8341: CALL_OW 504
8345: PUSH
8346: LD_INT 2
8348: PUSH
8349: LD_INT 34
8351: PUSH
8352: LD_INT 47
8354: PUSH
8355: EMPTY
8356: LIST
8357: LIST
8358: PUSH
8359: LD_INT 34
8361: PUSH
8362: LD_INT 45
8364: PUSH
8365: EMPTY
8366: LIST
8367: LIST
8368: PUSH
8369: EMPTY
8370: LIST
8371: LIST
8372: LIST
8373: PPUSH
8374: CALL_OW 69
8378: IN
8379: AND
8380: IFFALSE 8397
8382: GO 8384
8384: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8385: LD_EXP 46
8389: PPUSH
8390: LD_STRING D7-Bel-1
8392: PPUSH
8393: CALL_OW 88
8397: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8398: LD_INT 22
8400: PUSH
8401: LD_INT 7
8403: PUSH
8404: EMPTY
8405: LIST
8406: LIST
8407: PUSH
8408: LD_INT 101
8410: PUSH
8411: LD_INT 2
8413: PUSH
8414: EMPTY
8415: LIST
8416: LIST
8417: PUSH
8418: EMPTY
8419: LIST
8420: LIST
8421: PPUSH
8422: CALL_OW 69
8426: PUSH
8427: LD_EXP 8
8431: NOT
8432: AND
8433: PUSH
8434: LD_EXP 45
8438: PPUSH
8439: CALL_OW 305
8443: NOT
8444: AND
8445: IFFALSE 8915
8447: GO 8449
8449: DISABLE
8450: LD_INT 0
8452: PPUSH
// begin ar_base_spotted := true ;
8453: LD_ADDR_EXP 8
8457: PUSH
8458: LD_INT 1
8460: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8461: LD_ADDR_VAR 0 1
8465: PUSH
8466: LD_INT 22
8468: PUSH
8469: LD_INT 2
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: PUSH
8476: LD_INT 21
8478: PUSH
8479: LD_INT 3
8481: PUSH
8482: EMPTY
8483: LIST
8484: LIST
8485: PUSH
8486: EMPTY
8487: LIST
8488: LIST
8489: PPUSH
8490: CALL_OW 69
8494: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8495: LD_ADDR_VAR 0 1
8499: PUSH
8500: LD_VAR 0 1
8504: PPUSH
8505: LD_EXP 14
8509: PPUSH
8510: CALL_OW 74
8514: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8515: LD_INT 7
8517: PPUSH
8518: LD_INT 3
8520: PPUSH
8521: CALL_OW 332
// DialogueOn ;
8525: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8529: LD_VAR 0 1
8533: PPUSH
8534: CALL_OW 250
8538: PPUSH
8539: LD_VAR 0 1
8543: PPUSH
8544: CALL_OW 251
8548: PPUSH
8549: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8553: LD_ADDR_VAR 0 1
8557: PUSH
8558: LD_INT 22
8560: PUSH
8561: LD_INT 7
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 23
8570: PUSH
8571: LD_INT 1
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: PUSH
8578: LD_INT 26
8580: PUSH
8581: LD_INT 1
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PPUSH
8593: CALL_OW 69
8597: PUSH
8598: LD_EXP 14
8602: PUSH
8603: LD_EXP 18
8607: PUSH
8608: LD_EXP 19
8612: PUSH
8613: LD_EXP 26
8617: PUSH
8618: LD_EXP 15
8622: PUSH
8623: LD_EXP 24
8627: PUSH
8628: LD_EXP 20
8632: PUSH
8633: LD_EXP 22
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: LIST
8647: DIFF
8648: ST_TO_ADDR
// if not tmp then
8649: LD_VAR 0 1
8653: NOT
8654: IFFALSE 8728
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8656: LD_ADDR_VAR 0 1
8660: PUSH
8661: LD_INT 22
8663: PUSH
8664: LD_INT 7
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 23
8673: PUSH
8674: LD_INT 1
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PUSH
8681: LD_INT 26
8683: PUSH
8684: LD_INT 2
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PUSH
8691: EMPTY
8692: LIST
8693: LIST
8694: LIST
8695: PPUSH
8696: CALL_OW 69
8700: PUSH
8701: LD_EXP 29
8705: PUSH
8706: LD_EXP 16
8710: PUSH
8711: LD_EXP 27
8715: PUSH
8716: LD_EXP 28
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: LIST
8725: LIST
8726: DIFF
8727: ST_TO_ADDR
// if tmp then
8728: LD_VAR 0 1
8732: IFFALSE 8803
// case GetSex ( tmp [ 1 ] ) of sex_male :
8734: LD_VAR 0 1
8738: PUSH
8739: LD_INT 1
8741: ARRAY
8742: PPUSH
8743: CALL_OW 258
8747: PUSH
8748: LD_INT 1
8750: DOUBLE
8751: EQUAL
8752: IFTRUE 8756
8754: GO 8775
8756: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8757: LD_VAR 0 1
8761: PUSH
8762: LD_INT 1
8764: ARRAY
8765: PPUSH
8766: LD_STRING D9-Sol1-1
8768: PPUSH
8769: CALL_OW 88
8773: GO 8803
8775: LD_INT 2
8777: DOUBLE
8778: EQUAL
8779: IFTRUE 8783
8781: GO 8802
8783: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
8784: LD_VAR 0 1
8788: PUSH
8789: LD_INT 1
8791: ARRAY
8792: PPUSH
8793: LD_STRING D9-FSol1-1
8795: PPUSH
8796: CALL_OW 88
8800: GO 8803
8802: POP
// if Frank then
8803: LD_EXP 26
8807: IFFALSE 8911
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
8809: LD_EXP 55
8813: PPUSH
8814: CALL_OW 250
8818: PPUSH
8819: LD_EXP 55
8823: PPUSH
8824: CALL_OW 251
8828: PPUSH
8829: LD_INT 7
8831: PPUSH
8832: LD_INT 8
8834: PPUSH
8835: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
8839: LD_EXP 55
8843: PPUSH
8844: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
8848: LD_EXP 26
8852: PPUSH
8853: LD_STRING D9-Frank-1
8855: PPUSH
8856: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
8860: LD_EXP 14
8864: PPUSH
8865: LD_STRING D9-JMM-1
8867: PPUSH
8868: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
8872: LD_EXP 26
8876: PPUSH
8877: LD_STRING D9-Frank-2
8879: PPUSH
8880: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
8884: LD_EXP 55
8888: PPUSH
8889: CALL_OW 250
8893: PPUSH
8894: LD_EXP 55
8898: PPUSH
8899: CALL_OW 251
8903: PPUSH
8904: LD_INT 7
8906: PPUSH
8907: CALL_OW 331
// end ; DialogueOff ;
8911: CALL_OW 7
// end ;
8915: PPOPN 1
8917: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
8918: LD_EXP 7
8922: PUSH
8923: LD_OWVAR 1
8927: PUSH
8928: LD_INT 42000
8930: GREATEREQUAL
8931: OR
8932: IFFALSE 9959
8934: GO 8936
8936: DISABLE
8937: LD_INT 0
8939: PPUSH
8940: PPUSH
// begin selected_option := 1 ;
8941: LD_ADDR_VAR 0 2
8945: PUSH
8946: LD_INT 1
8948: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8949: LD_INT 10500
8951: PPUSH
8952: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8956: LD_INT 35
8958: PPUSH
8959: CALL_OW 67
// until not ru_attackers ;
8963: LD_EXP 51
8967: NOT
8968: IFFALSE 8956
// PrepareBurlak ;
8970: CALL 2040 0 0
// repeat wait ( 0 0$2 ) ;
8974: LD_INT 70
8976: PPUSH
8977: CALL_OW 67
// until not HasTask ( Burlak ) ;
8981: LD_EXP 45
8985: PPUSH
8986: CALL_OW 314
8990: NOT
8991: IFFALSE 8974
// InGameOn ;
8993: CALL_OW 8
// DialogueOn ;
8997: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9001: LD_EXP 48
9005: PPUSH
9006: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9010: LD_EXP 45
9014: PPUSH
9015: LD_STRING D10-Bur-1
9017: PPUSH
9018: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9022: LD_EXP 46
9026: PUSH
9027: LD_EXP 46
9031: PPUSH
9032: CALL_OW 255
9036: PUSH
9037: LD_INT 7
9039: EQUAL
9040: AND
9041: IFFALSE 9055
// Say ( Belkov , D10-Bel-1 ) ;
9043: LD_EXP 46
9047: PPUSH
9048: LD_STRING D10-Bel-1
9050: PPUSH
9051: CALL_OW 88
// if Gossudarov then
9055: LD_EXP 31
9059: IFFALSE 9073
// Say ( Gossudarov , D10-Gos-1 ) ;
9061: LD_EXP 31
9065: PPUSH
9066: LD_STRING D10-Gos-1
9068: PPUSH
9069: CALL_OW 88
// if Kirilenkova then
9073: LD_EXP 32
9077: IFFALSE 9091
// Say ( Kirilenkova , D10-Kir-1 ) ;
9079: LD_EXP 32
9083: PPUSH
9084: LD_STRING D10-Kir-1
9086: PPUSH
9087: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9091: CALL 12163 0 0
9095: PPUSH
9096: LD_STRING D10-RSol1-1
9098: PPUSH
9099: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9103: LD_EXP 45
9107: PPUSH
9108: LD_STRING D10-Bur-2
9110: PPUSH
9111: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9115: LD_EXP 14
9119: PPUSH
9120: LD_STRING D10-JMM-2
9122: PPUSH
9123: CALL_OW 88
// if Kirilenkova then
9127: LD_EXP 32
9131: IFFALSE 9147
// Say ( Kirilenkova , D10-Kir-2 ) else
9133: LD_EXP 32
9137: PPUSH
9138: LD_STRING D10-Kir-2
9140: PPUSH
9141: CALL_OW 88
9145: GO 9159
// Say ( SolRu , D10-RSol1-2 ) ;
9147: CALL 12163 0 0
9151: PPUSH
9152: LD_STRING D10-RSol1-2
9154: PPUSH
9155: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9159: LD_EXP 14
9163: PPUSH
9164: LD_STRING D10-JMM-3
9166: PPUSH
9167: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9171: LD_EXP 45
9175: PPUSH
9176: LD_STRING D10-Bur-3
9178: PPUSH
9179: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9183: LD_EXP 14
9187: PPUSH
9188: LD_STRING D10-JMM-4
9190: PPUSH
9191: CALL_OW 88
// DialogueOff ;
9195: CALL_OW 7
// InGameOff ;
9199: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9203: LD_STRING M2
9205: PPUSH
9206: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9210: LD_INT 35
9212: PPUSH
9213: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9217: LD_INT 22
9219: PUSH
9220: LD_INT 7
9222: PUSH
9223: EMPTY
9224: LIST
9225: LIST
9226: PUSH
9227: LD_INT 91
9229: PUSH
9230: LD_EXP 45
9234: PUSH
9235: LD_INT 8
9237: PUSH
9238: EMPTY
9239: LIST
9240: LIST
9241: LIST
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: PPUSH
9247: CALL_OW 69
9251: IFFALSE 9210
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9253: LD_ADDR_VAR 0 1
9257: PUSH
9258: LD_INT 22
9260: PUSH
9261: LD_INT 4
9263: PUSH
9264: EMPTY
9265: LIST
9266: LIST
9267: PPUSH
9268: CALL_OW 69
9272: PUSH
9273: FOR_IN
9274: IFFALSE 9290
// SetSide ( i , 7 ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_INT 7
9283: PPUSH
9284: CALL_OW 235
9288: GO 9273
9290: POP
9291: POP
// ChangeMissionObjectives ( M3 ) ;
9292: LD_STRING M3
9294: PPUSH
9295: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9299: LD_INT 35
9301: PPUSH
9302: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9306: LD_EXP 14
9310: PPUSH
9311: LD_EXP 45
9315: PPUSH
9316: CALL_OW 296
9320: PUSH
9321: LD_INT 8
9323: LESS
9324: IFFALSE 9299
// ComTurnUnit ( JMM , Burlak ) ;
9326: LD_EXP 14
9330: PPUSH
9331: LD_EXP 45
9335: PPUSH
9336: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9340: LD_EXP 45
9344: PPUSH
9345: LD_EXP 14
9349: PPUSH
9350: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9354: LD_INT 10
9356: PPUSH
9357: CALL_OW 67
// DialogueOn ;
9361: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9365: LD_EXP 14
9369: PPUSH
9370: LD_STRING D11-JMM-1
9372: PPUSH
9373: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9377: LD_EXP 45
9381: PPUSH
9382: LD_STRING D11-Bur-1
9384: PPUSH
9385: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9389: LD_EXP 14
9393: PPUSH
9394: LD_STRING D11-JMM-2
9396: PPUSH
9397: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9401: LD_EXP 45
9405: PPUSH
9406: LD_STRING D11-Bur-2
9408: PPUSH
9409: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9413: LD_EXP 14
9417: PPUSH
9418: LD_STRING D11-JMM-3
9420: PPUSH
9421: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9425: LD_EXP 45
9429: PPUSH
9430: LD_STRING D11-Bur-3
9432: PPUSH
9433: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9437: LD_EXP 14
9441: PPUSH
9442: LD_STRING D11-JMM-4
9444: PPUSH
9445: CALL_OW 88
// if ar_base_spotted then
9449: LD_EXP 8
9453: IFFALSE 9469
// Say ( Burlak , D12-Bur-1 ) else
9455: LD_EXP 45
9459: PPUSH
9460: LD_STRING D12-Bur-1
9462: PPUSH
9463: CALL_OW 88
9467: GO 9508
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9469: LD_INT 7
9471: PPUSH
9472: LD_INT 3
9474: PPUSH
9475: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9479: LD_INT 127
9481: PPUSH
9482: LD_INT 45
9484: PPUSH
9485: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9489: LD_EXP 45
9493: PPUSH
9494: LD_STRING D12-Bur-1a
9496: PPUSH
9497: CALL_OW 88
// dwait ( 0 0$2 ) ;
9501: LD_INT 70
9503: PPUSH
9504: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9508: LD_EXP 45
9512: PPUSH
9513: LD_STRING D12-Bur-1b
9515: PPUSH
9516: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9520: LD_EXP 14
9524: PPUSH
9525: LD_STRING D12-JMM-1
9527: PPUSH
9528: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9532: LD_EXP 45
9536: PPUSH
9537: LD_STRING D12-Bur-2
9539: PPUSH
9540: CALL_OW 88
// if Roth then
9544: LD_EXP 15
9548: IFFALSE 9564
// Say ( Roth , D12-Roth-2 ) else
9550: LD_EXP 15
9554: PPUSH
9555: LD_STRING D12-Roth-2
9557: PPUSH
9558: CALL_OW 88
9562: GO 9576
// Say ( SciRu , D12-RSci1-2 ) ;
9564: CALL 12034 0 0
9568: PPUSH
9569: LD_STRING D12-RSci1-2
9571: PPUSH
9572: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9576: LD_EXP 14
9580: PPUSH
9581: LD_STRING D12-JMM-2
9583: PPUSH
9584: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9588: LD_EXP 45
9592: PPUSH
9593: LD_STRING D12-Bur-3
9595: PPUSH
9596: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9600: LD_EXP 14
9604: PPUSH
9605: LD_STRING D12-JMM-3
9607: PPUSH
9608: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9612: LD_EXP 45
9616: PPUSH
9617: LD_STRING D12-Bur-4
9619: PPUSH
9620: CALL_OW 88
// case Query ( QBase ) of 1 :
9624: LD_STRING QBase
9626: PPUSH
9627: CALL_OW 97
9631: PUSH
9632: LD_INT 1
9634: DOUBLE
9635: EQUAL
9636: IFTRUE 9640
9638: GO 9758
9640: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9641: LD_EXP 14
9645: PPUSH
9646: LD_STRING D13a-JMM-1
9648: PPUSH
9649: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9653: LD_EXP 45
9657: PPUSH
9658: LD_STRING D13a-Bur-1
9660: PPUSH
9661: CALL_OW 88
// if Roth then
9665: LD_EXP 15
9669: IFFALSE 9685
// Say ( Roth , D13a-Roth-1 ) else
9671: LD_EXP 15
9675: PPUSH
9676: LD_STRING D13a-Roth-1
9678: PPUSH
9679: CALL_OW 88
9683: GO 9697
// Say ( SciRu , D13a-RSci1-1 ) ;
9685: CALL 12034 0 0
9689: PPUSH
9690: LD_STRING D13a-RSci1-1
9692: PPUSH
9693: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9697: LD_EXP 14
9701: PPUSH
9702: LD_STRING D13a-JMM-2
9704: PPUSH
9705: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9709: LD_STRING QBaseAgain
9711: PPUSH
9712: CALL_OW 97
9716: PUSH
9717: LD_INT 1
9719: DOUBLE
9720: EQUAL
9721: IFTRUE 9725
9723: GO 9736
9725: POP
// selected_option := 2 ; 2 :
9726: LD_ADDR_VAR 0 2
9730: PUSH
9731: LD_INT 2
9733: ST_TO_ADDR
9734: GO 9756
9736: LD_INT 2
9738: DOUBLE
9739: EQUAL
9740: IFTRUE 9744
9742: GO 9755
9744: POP
// selected_option := 3 ; end ;
9745: LD_ADDR_VAR 0 2
9749: PUSH
9750: LD_INT 3
9752: ST_TO_ADDR
9753: GO 9756
9755: POP
// end ; 2 :
9756: GO 9797
9758: LD_INT 2
9760: DOUBLE
9761: EQUAL
9762: IFTRUE 9766
9764: GO 9777
9766: POP
// selected_option := 2 ; 3 :
9767: LD_ADDR_VAR 0 2
9771: PUSH
9772: LD_INT 2
9774: ST_TO_ADDR
9775: GO 9797
9777: LD_INT 3
9779: DOUBLE
9780: EQUAL
9781: IFTRUE 9785
9783: GO 9796
9785: POP
// selected_option := 3 ; end ;
9786: LD_ADDR_VAR 0 2
9790: PUSH
9791: LD_INT 3
9793: ST_TO_ADDR
9794: GO 9797
9796: POP
// if selected_option = 2 then
9797: LD_VAR 0 2
9801: PUSH
9802: LD_INT 2
9804: EQUAL
9805: IFFALSE 9899
// begin Say ( JMM , D13b-JMM-1 ) ;
9807: LD_EXP 14
9811: PPUSH
9812: LD_STRING D13b-JMM-1
9814: PPUSH
9815: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
9819: LD_EXP 45
9823: PPUSH
9824: LD_STRING D13b-Bur-1
9826: PPUSH
9827: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
9831: LD_EXP 14
9835: PPUSH
9836: LD_STRING D13b-JMM-2
9838: PPUSH
9839: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
9843: LD_EXP 54
9847: PPUSH
9848: LD_STRING D13b-Abd-2
9850: PPUSH
9851: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
9855: LD_EXP 14
9859: PPUSH
9860: LD_STRING D13b-JMM-3
9862: PPUSH
9863: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
9867: LD_EXP 54
9871: PPUSH
9872: LD_STRING D13b-Abd-3
9874: PPUSH
9875: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
9879: LD_EXP 14
9883: PPUSH
9884: LD_STRING D13b-JMM-4
9886: PPUSH
9887: CALL_OW 88
// ar_active_attack := true ;
9891: LD_ADDR_EXP 9
9895: PUSH
9896: LD_INT 1
9898: ST_TO_ADDR
// end ; if selected_option = 3 then
9899: LD_VAR 0 2
9903: PUSH
9904: LD_INT 3
9906: EQUAL
9907: IFFALSE 9933
// begin Say ( JMM , D13c-JMM-1 ) ;
9909: LD_EXP 14
9913: PPUSH
9914: LD_STRING D13c-JMM-1
9916: PPUSH
9917: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
9921: LD_EXP 45
9925: PPUSH
9926: LD_STRING D13c-Bur-1
9928: PPUSH
9929: CALL_OW 88
// end ; DialogueOff ;
9933: CALL_OW 7
// if not ar_active_attack then
9937: LD_EXP 9
9941: NOT
9942: IFFALSE 9959
// begin wait ( 6 6$00 ) ;
9944: LD_INT 12600
9946: PPUSH
9947: CALL_OW 67
// ar_active_attack := true ;
9951: LD_ADDR_EXP 9
9955: PUSH
9956: LD_INT 1
9958: ST_TO_ADDR
// end ; end ;
9959: PPOPN 2
9961: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do
9962: LD_EXP 45
9966: PPUSH
9967: CALL_OW 305
9971: PUSH
9972: LD_EXP 45
9976: PPUSH
9977: CALL_OW 255
9981: PUSH
9982: LD_INT 7
9984: EQUAL
9985: AND
9986: IFFALSE 10147
9988: GO 9990
9990: DISABLE
// begin wait ( 4 4$40 ) ;
9991: LD_INT 9800
9993: PPUSH
9994: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9998: LD_INT 35
10000: PPUSH
10001: CALL_OW 67
// until not ru_attackers ;
10005: LD_EXP 51
10009: NOT
10010: IFFALSE 9998
// PrepareGnyevko ;
10012: CALL 1984 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10016: LD_EXP 47
10020: PPUSH
10021: LD_INT 124
10023: PPUSH
10024: LD_INT 118
10026: PPUSH
10027: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10031: LD_EXP 47
10035: PPUSH
10036: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10040: LD_INT 35
10042: PPUSH
10043: CALL_OW 67
// until IsAt ( Gnyevko , 124 , 118 ) ;
10047: LD_EXP 47
10051: PPUSH
10052: LD_INT 124
10054: PPUSH
10055: LD_INT 118
10057: PPUSH
10058: CALL_OW 307
10062: IFFALSE 10040
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10064: LD_EXP 47
10068: PPUSH
10069: LD_STRING DBelkov-Gny-1
10071: PPUSH
10072: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10076: LD_EXP 45
10080: PPUSH
10081: LD_STRING DBelkov-Bur-1a
10083: PPUSH
10084: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10088: LD_INT 35
10090: PPUSH
10091: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10095: LD_EXP 47
10099: PPUSH
10100: LD_INT 22
10102: PUSH
10103: LD_INT 7
10105: PUSH
10106: EMPTY
10107: LIST
10108: LIST
10109: PPUSH
10110: CALL_OW 69
10114: PPUSH
10115: LD_EXP 47
10119: PPUSH
10120: CALL_OW 74
10124: PPUSH
10125: CALL_OW 296
10129: PUSH
10130: LD_INT 8
10132: LESS
10133: IFFALSE 10088
// SetSide ( Gnyevko , 7 ) ;
10135: LD_EXP 47
10139: PPUSH
10140: LD_INT 7
10142: PPUSH
10143: CALL_OW 235
// end ;
10147: END
// every 10 10$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10148: LD_EXP 45
10152: PPUSH
10153: CALL_OW 255
10157: PUSH
10158: LD_INT 7
10160: EQUAL
10161: IFFALSE 10171
10163: GO 10165
10165: DISABLE
// begin enable ;
10166: ENABLE
// PrepareAmericanAttack ;
10167: CALL 6273 0 0
// end ;
10171: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10172: LD_INT 22
10174: PUSH
10175: LD_INT 1
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: PPUSH
10182: CALL_OW 69
10186: IFFALSE 10370
10188: GO 10190
10190: DISABLE
10191: LD_INT 0
10193: PPUSH
10194: PPUSH
// begin while true do
10195: LD_INT 1
10197: IFFALSE 10254
// begin wait ( 0 0$1 ) ;
10199: LD_INT 35
10201: PPUSH
10202: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_INT 22
10213: PUSH
10214: LD_INT 1
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PPUSH
10221: CALL_OW 69
10225: PPUSH
10226: LD_EXP 14
10230: PPUSH
10231: CALL_OW 74
10235: ST_TO_ADDR
// if See ( 7 , tmp ) then
10236: LD_INT 7
10238: PPUSH
10239: LD_VAR 0 2
10243: PPUSH
10244: CALL_OW 292
10248: IFFALSE 10252
// break ;
10250: GO 10254
// end ;
10252: GO 10195
// DialogueOn ;
10254: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10258: LD_VAR 0 2
10262: PPUSH
10263: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10267: LD_VAR 0 2
10271: PPUSH
10272: CALL_OW 250
10276: PPUSH
10277: LD_VAR 0 2
10281: PPUSH
10282: CALL_OW 251
10286: PPUSH
10287: LD_INT 7
10289: PPUSH
10290: LD_INT 8
10292: PPUSH
10293: CALL_OW 330
// if Denis then
10297: LD_EXP 20
10301: IFFALSE 10315
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10303: LD_EXP 20
10307: PPUSH
10308: LD_STRING DAmerAttack-Pet-1
10310: PPUSH
10311: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10315: LD_EXP 14
10319: PPUSH
10320: LD_STRING DAmerAttack-JMM-1
10322: PPUSH
10323: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10327: LD_EXP 45
10331: PPUSH
10332: LD_STRING DStop-Bur-1
10334: PPUSH
10335: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10339: LD_VAR 0 2
10343: PPUSH
10344: CALL_OW 250
10348: PPUSH
10349: LD_VAR 0 2
10353: PPUSH
10354: CALL_OW 251
10358: PPUSH
10359: LD_INT 7
10361: PPUSH
10362: CALL_OW 331
// DialogueOff ;
10366: CALL_OW 7
// end ;
10370: PPOPN 2
10372: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10373: LD_INT 22
10375: PUSH
10376: LD_INT 3
10378: PUSH
10379: EMPTY
10380: LIST
10381: LIST
10382: PUSH
10383: LD_INT 21
10385: PUSH
10386: LD_INT 1
10388: PUSH
10389: EMPTY
10390: LIST
10391: LIST
10392: PUSH
10393: EMPTY
10394: LIST
10395: LIST
10396: PPUSH
10397: CALL_OW 69
10401: PUSH
10402: LD_INT 0
10404: EQUAL
10405: IFFALSE 10447
10407: GO 10409
10409: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10410: LD_STRING M5a
10412: PPUSH
10413: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10417: LD_EXP 14
10421: PPUSH
10422: LD_STRING D8-JMM-1
10424: PPUSH
10425: CALL_OW 88
// if Gossudarov then
10429: LD_EXP 31
10433: IFFALSE 10447
// Say ( Gossudarov , D8-Gos-1 ) ;
10435: LD_EXP 31
10439: PPUSH
10440: LD_STRING D8-Gos-1
10442: PPUSH
10443: CALL_OW 88
// end ;
10447: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10448: LD_INT 22
10450: PUSH
10451: LD_INT 2
10453: PUSH
10454: EMPTY
10455: LIST
10456: LIST
10457: PUSH
10458: LD_INT 21
10460: PUSH
10461: LD_INT 1
10463: PUSH
10464: EMPTY
10465: LIST
10466: LIST
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PPUSH
10472: CALL_OW 69
10476: PUSH
10477: LD_INT 0
10479: EQUAL
10480: IFFALSE 10530
10482: GO 10484
10484: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10485: LD_STRING M4c
10487: PPUSH
10488: CALL_OW 337
// if Roth then
10492: LD_EXP 15
10496: IFFALSE 10512
// Say ( Roth , DStop-Roth-1 ) else
10498: LD_EXP 15
10502: PPUSH
10503: LD_STRING DStop-Roth-1
10505: PPUSH
10506: CALL_OW 88
10510: GO 10530
// if Gossudarov then
10512: LD_EXP 31
10516: IFFALSE 10530
// Say ( Gossudarov , D8-Gos-1a ) ;
10518: LD_EXP 31
10522: PPUSH
10523: LD_STRING D8-Gos-1a
10525: PPUSH
10526: CALL_OW 88
// end ;
10530: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10531: LD_INT 7
10533: PPUSH
10534: LD_INT 1
10536: PPUSH
10537: LD_INT 1
10539: PPUSH
10540: CALL 13558 0 3
10544: PUSH
10545: LD_INT 0
10547: EQUAL
10548: PUSH
10549: LD_INT 7
10551: PPUSH
10552: LD_INT 3
10554: PPUSH
10555: LD_INT 1
10557: PPUSH
10558: CALL 13558 0 3
10562: PUSH
10563: LD_INT 0
10565: EQUAL
10566: AND
10567: IFFALSE 10579
10569: GO 10571
10571: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10572: LD_STRING M1a
10574: PPUSH
10575: CALL_OW 337
// end ;
10579: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 3 ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10580: LD_INT 22
10582: PUSH
10583: LD_INT 2
10585: PUSH
10586: EMPTY
10587: LIST
10588: LIST
10589: PUSH
10590: LD_INT 21
10592: PUSH
10593: LD_INT 1
10595: PUSH
10596: EMPTY
10597: LIST
10598: LIST
10599: PUSH
10600: EMPTY
10601: LIST
10602: LIST
10603: PPUSH
10604: CALL_OW 69
10608: PUSH
10609: LD_INT 0
10611: EQUAL
10612: PUSH
10613: LD_INT 22
10615: PUSH
10616: LD_INT 3
10618: PUSH
10619: EMPTY
10620: LIST
10621: LIST
10622: PPUSH
10623: CALL_OW 69
10627: PUSH
10628: LD_INT 0
10630: EQUAL
10631: AND
10632: PUSH
10633: LD_INT 22
10635: PUSH
10636: LD_INT 1
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PPUSH
10643: CALL_OW 69
10647: PUSH
10648: LD_INT 0
10650: EQUAL
10651: AND
10652: PUSH
10653: LD_INT 7
10655: PPUSH
10656: LD_INT 1
10658: PPUSH
10659: LD_INT 1
10661: PPUSH
10662: CALL 13558 0 3
10666: PUSH
10667: LD_INT 0
10669: EQUAL
10670: AND
10671: PUSH
10672: LD_INT 7
10674: PPUSH
10675: LD_INT 3
10677: PPUSH
10678: LD_INT 1
10680: PPUSH
10681: CALL 13558 0 3
10685: PUSH
10686: LD_INT 0
10688: EQUAL
10689: AND
10690: IFFALSE 12031
10692: GO 10694
10694: DISABLE
10695: LD_INT 0
10697: PPUSH
10698: PPUSH
10699: PPUSH
// begin wait ( 0 0$3 ) ;
10700: LD_INT 105
10702: PPUSH
10703: CALL_OW 67
// if not IsDead ( Masha ) then
10707: LD_EXP 48
10711: PPUSH
10712: CALL_OW 301
10716: NOT
10717: IFFALSE 10731
// AddMedal ( Masha , 1 ) else
10719: LD_STRING Masha
10721: PPUSH
10722: LD_INT 1
10724: PPUSH
10725: CALL_OW 101
10729: GO 10742
// AddMedal ( Masha , - 1 ) ;
10731: LD_STRING Masha
10733: PPUSH
10734: LD_INT 1
10736: NEG
10737: PPUSH
10738: CALL_OW 101
// if abdul_escaped then
10742: LD_EXP 12
10746: IFFALSE 10761
// AddMedal ( Abdul , - 1 ) else
10748: LD_STRING Abdul
10750: PPUSH
10751: LD_INT 1
10753: NEG
10754: PPUSH
10755: CALL_OW 101
10759: GO 10771
// AddMedal ( Abdul , 1 ) ;
10761: LD_STRING Abdul
10763: PPUSH
10764: LD_INT 1
10766: PPUSH
10767: CALL_OW 101
// if loss_counter = 0 then
10771: LD_EXP 13
10775: PUSH
10776: LD_INT 0
10778: EQUAL
10779: IFFALSE 10793
// AddMedal ( People , 2 ) else
10781: LD_STRING People
10783: PPUSH
10784: LD_INT 2
10786: PPUSH
10787: CALL_OW 101
10791: GO 10843
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
10793: LD_EXP 13
10797: PUSH
10798: LD_INT 3
10800: PUSH
10801: LD_INT 2
10803: PUSH
10804: LD_INT 2
10806: PUSH
10807: EMPTY
10808: LIST
10809: LIST
10810: LIST
10811: PUSH
10812: LD_OWVAR 67
10816: ARRAY
10817: LESSEQUAL
10818: IFFALSE 10832
// AddMedal ( People , 1 ) else
10820: LD_STRING People
10822: PPUSH
10823: LD_INT 1
10825: PPUSH
10826: CALL_OW 101
10830: GO 10843
// AddMedal ( People , - 1 ) ;
10832: LD_STRING People
10834: PPUSH
10835: LD_INT 1
10837: NEG
10838: PPUSH
10839: CALL_OW 101
// GiveMedals ( MAIN ) ;
10843: LD_STRING MAIN
10845: PPUSH
10846: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
10850: LD_ADDR_VAR 0 2
10854: PUSH
10855: LD_INT 22
10857: PUSH
10858: LD_INT 7
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: PUSH
10865: LD_INT 2
10867: PUSH
10868: LD_INT 25
10870: PUSH
10871: LD_INT 1
10873: PUSH
10874: EMPTY
10875: LIST
10876: LIST
10877: PUSH
10878: LD_INT 25
10880: PUSH
10881: LD_INT 2
10883: PUSH
10884: EMPTY
10885: LIST
10886: LIST
10887: PUSH
10888: LD_INT 25
10890: PUSH
10891: LD_INT 3
10893: PUSH
10894: EMPTY
10895: LIST
10896: LIST
10897: PUSH
10898: LD_INT 25
10900: PUSH
10901: LD_INT 4
10903: PUSH
10904: EMPTY
10905: LIST
10906: LIST
10907: PUSH
10908: LD_INT 25
10910: PUSH
10911: LD_INT 5
10913: PUSH
10914: EMPTY
10915: LIST
10916: LIST
10917: PUSH
10918: LD_INT 25
10920: PUSH
10921: LD_INT 8
10923: PUSH
10924: EMPTY
10925: LIST
10926: LIST
10927: PUSH
10928: LD_INT 25
10930: PUSH
10931: LD_INT 9
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: LIST
10942: LIST
10943: LIST
10944: LIST
10945: LIST
10946: LIST
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: PPUSH
10952: CALL_OW 69
10956: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10957: LD_VAR 0 2
10961: PPUSH
10962: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
10966: LD_ADDR_VAR 0 3
10970: PUSH
10971: LD_EXP 14
10975: PUSH
10976: LD_EXP 15
10980: PUSH
10981: LD_EXP 16
10985: PUSH
10986: LD_EXP 17
10990: PUSH
10991: LD_EXP 18
10995: PUSH
10996: LD_EXP 19
11000: PUSH
11001: LD_EXP 20
11005: PUSH
11006: LD_EXP 21
11010: PUSH
11011: LD_EXP 22
11015: PUSH
11016: LD_EXP 23
11020: PUSH
11021: LD_EXP 24
11025: PUSH
11026: LD_EXP 25
11030: PUSH
11031: LD_EXP 26
11035: PUSH
11036: LD_EXP 27
11040: PUSH
11041: LD_EXP 28
11045: PUSH
11046: LD_EXP 29
11050: PUSH
11051: LD_EXP 30
11055: PUSH
11056: LD_EXP 31
11060: PUSH
11061: LD_EXP 32
11065: PUSH
11066: LD_EXP 33
11070: PUSH
11071: LD_EXP 35
11075: PUSH
11076: LD_EXP 36
11080: PUSH
11081: LD_EXP 37
11085: PUSH
11086: LD_EXP 38
11090: PUSH
11091: LD_EXP 39
11095: PUSH
11096: LD_EXP 40
11100: PUSH
11101: LD_EXP 41
11105: PUSH
11106: LD_EXP 42
11110: PUSH
11111: LD_EXP 43
11115: PUSH
11116: LD_EXP 44
11120: PUSH
11121: LD_EXP 45
11125: PUSH
11126: LD_EXP 46
11130: PUSH
11131: LD_EXP 47
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: LIST
11140: LIST
11141: LIST
11142: LIST
11143: LIST
11144: LIST
11145: LIST
11146: LIST
11147: LIST
11148: LIST
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: ST_TO_ADDR
// if tmp diff tmp2 then
11171: LD_VAR 0 2
11175: PUSH
11176: LD_VAR 0 3
11180: DIFF
11181: IFFALSE 11201
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11183: LD_VAR 0 2
11187: PUSH
11188: LD_VAR 0 3
11192: DIFF
11193: PPUSH
11194: LD_STRING 13a_others
11196: PPUSH
11197: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11201: LD_EXP 14
11205: PPUSH
11206: LD_STRING 13a_JMM
11208: PPUSH
11209: CALL_OW 38
// if Titov then
11213: LD_EXP 33
11217: IFFALSE 11231
// SaveCharacters ( Titov , 13a_Titov ) ;
11219: LD_EXP 33
11223: PPUSH
11224: LD_STRING 13a_Titov
11226: PPUSH
11227: CALL_OW 38
// if Dolgov then
11231: LD_EXP 35
11235: IFFALSE 11249
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11237: LD_EXP 35
11241: PPUSH
11242: LD_STRING 13a_Dolgov
11244: PPUSH
11245: CALL_OW 38
// if Petrosyan then
11249: LD_EXP 36
11253: IFFALSE 11267
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11255: LD_EXP 36
11259: PPUSH
11260: LD_STRING 13a_Petrosyan
11262: PPUSH
11263: CALL_OW 38
// if Scholtze then
11267: LD_EXP 37
11271: IFFALSE 11285
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11273: LD_EXP 37
11277: PPUSH
11278: LD_STRING 13a_Scholtze
11280: PPUSH
11281: CALL_OW 38
// if Oblukov then
11285: LD_EXP 38
11289: IFFALSE 11303
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11291: LD_EXP 38
11295: PPUSH
11296: LD_STRING 13a_Oblukov
11298: PPUSH
11299: CALL_OW 38
// if Kapitsova then
11303: LD_EXP 39
11307: IFFALSE 11321
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11309: LD_EXP 39
11313: PPUSH
11314: LD_STRING 13a_Kapitsova
11316: PPUSH
11317: CALL_OW 38
// if Lipshchin then
11321: LD_EXP 40
11325: IFFALSE 11339
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11327: LD_EXP 40
11331: PPUSH
11332: LD_STRING 13a_Lipshchin
11334: PPUSH
11335: CALL_OW 38
// if Petrovova then
11339: LD_EXP 41
11343: IFFALSE 11357
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11345: LD_EXP 41
11349: PPUSH
11350: LD_STRING 13a_Petrovova
11352: PPUSH
11353: CALL_OW 38
// if Kovalyuk then
11357: LD_EXP 42
11361: IFFALSE 11375
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11363: LD_EXP 42
11367: PPUSH
11368: LD_STRING 13a_Kovalyuk
11370: PPUSH
11371: CALL_OW 38
// if Kuzmov then
11375: LD_EXP 43
11379: IFFALSE 11393
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11381: LD_EXP 43
11385: PPUSH
11386: LD_STRING 13a_Kuzmov
11388: PPUSH
11389: CALL_OW 38
// if Karamazov then
11393: LD_EXP 44
11397: IFFALSE 11411
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11399: LD_EXP 44
11403: PPUSH
11404: LD_STRING 13a_Karamazov
11406: PPUSH
11407: CALL_OW 38
// if Burlak then
11411: LD_EXP 45
11415: IFFALSE 11429
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11417: LD_EXP 45
11421: PPUSH
11422: LD_STRING 13a_Burlak
11424: PPUSH
11425: CALL_OW 38
// if Belkov then
11429: LD_EXP 46
11433: IFFALSE 11447
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11435: LD_EXP 46
11439: PPUSH
11440: LD_STRING 13a_Belkov
11442: PPUSH
11443: CALL_OW 38
// if Gnyevko then
11447: LD_EXP 47
11451: IFFALSE 11465
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11453: LD_EXP 47
11457: PPUSH
11458: LD_STRING 13a_Gnyevko
11460: PPUSH
11461: CALL_OW 38
// if Lisa then
11465: LD_EXP 16
11469: IFFALSE 11483
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11471: LD_EXP 16
11475: PPUSH
11476: LD_STRING 13a_Lisa
11478: PPUSH
11479: CALL_OW 38
// if Donaldson then
11483: LD_EXP 17
11487: IFFALSE 11501
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11489: LD_EXP 17
11493: PPUSH
11494: LD_STRING 13a_Donaldson
11496: PPUSH
11497: CALL_OW 38
// if Bobby then
11501: LD_EXP 18
11505: IFFALSE 11519
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11507: LD_EXP 18
11511: PPUSH
11512: LD_STRING 13a_Bobby
11514: PPUSH
11515: CALL_OW 38
// if Cyrus then
11519: LD_EXP 19
11523: IFFALSE 11537
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11525: LD_EXP 19
11529: PPUSH
11530: LD_STRING 13a_Cyrus
11532: PPUSH
11533: CALL_OW 38
// if Denis then
11537: LD_EXP 20
11541: IFFALSE 11555
// SaveCharacters ( Denis , 13a_Denis ) ;
11543: LD_EXP 20
11547: PPUSH
11548: LD_STRING 13a_Denis
11550: PPUSH
11551: CALL_OW 38
// if Brown then
11555: LD_EXP 21
11559: IFFALSE 11573
// SaveCharacters ( Brown , 13a_Brown ) ;
11561: LD_EXP 21
11565: PPUSH
11566: LD_STRING 13a_Brown
11568: PPUSH
11569: CALL_OW 38
// if Gladstone then
11573: LD_EXP 22
11577: IFFALSE 11591
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11579: LD_EXP 22
11583: PPUSH
11584: LD_STRING 13a_Gladstone
11586: PPUSH
11587: CALL_OW 38
// if Houten then
11591: LD_EXP 23
11595: IFFALSE 11609
// SaveCharacters ( Houten , 13a_Houten ) ;
11597: LD_EXP 23
11601: PPUSH
11602: LD_STRING 13a_Houten
11604: PPUSH
11605: CALL_OW 38
// if Cornel then
11609: LD_EXP 24
11613: IFFALSE 11627
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11615: LD_EXP 24
11619: PPUSH
11620: LD_STRING 13a_Cornel
11622: PPUSH
11623: CALL_OW 38
// if Gary then
11627: LD_EXP 25
11631: IFFALSE 11645
// SaveCharacters ( Gary , 13a_Gary ) ;
11633: LD_EXP 25
11637: PPUSH
11638: LD_STRING 13a_Gary
11640: PPUSH
11641: CALL_OW 38
// if Frank then
11645: LD_EXP 26
11649: IFFALSE 11663
// SaveCharacters ( Frank , 13a_Frank ) ;
11651: LD_EXP 26
11655: PPUSH
11656: LD_STRING 13a_Frank
11658: PPUSH
11659: CALL_OW 38
// if Kikuchi then
11663: LD_EXP 27
11667: IFFALSE 11681
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11669: LD_EXP 27
11673: PPUSH
11674: LD_STRING 13a_Kikuchi
11676: PPUSH
11677: CALL_OW 38
// if Simms then
11681: LD_EXP 28
11685: IFFALSE 11699
// SaveCharacters ( Simms , 13a_Simms ) ;
11687: LD_EXP 28
11691: PPUSH
11692: LD_STRING 13a_Simms
11694: PPUSH
11695: CALL_OW 38
// if Joan then
11699: LD_EXP 29
11703: IFFALSE 11717
// SaveCharacters ( Joan , 13a_Joan ) ;
11705: LD_EXP 29
11709: PPUSH
11710: LD_STRING 13a_Joan
11712: PPUSH
11713: CALL_OW 38
// if DeltaDoctor then
11717: LD_EXP 30
11721: IFFALSE 11735
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
11723: LD_EXP 30
11727: PPUSH
11728: LD_STRING 13a_DeltaDoctor
11730: PPUSH
11731: CALL_OW 38
// if Gossudarov then
11735: LD_EXP 31
11739: IFFALSE 11753
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
11741: LD_EXP 31
11745: PPUSH
11746: LD_STRING 13a_Gossudarov
11748: PPUSH
11749: CALL_OW 38
// if Kirilenkova then
11753: LD_EXP 32
11757: IFFALSE 11771
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
11759: LD_EXP 32
11763: PPUSH
11764: LD_STRING 13a_Kirilenkova
11766: PPUSH
11767: CALL_OW 38
// if Masha then
11771: LD_EXP 48
11775: IFFALSE 11830
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
11777: LD_EXP 48
11781: PPUSH
11782: CALL_OW 265
11786: PUSH
11787: LD_EXP 48
11791: PPUSH
11792: CALL_OW 262
11796: PUSH
11797: LD_EXP 48
11801: PPUSH
11802: CALL_OW 263
11806: PUSH
11807: LD_EXP 48
11811: PPUSH
11812: CALL_OW 264
11816: PUSH
11817: EMPTY
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: PPUSH
11823: LD_STRING 13a_Masha
11825: PPUSH
11826: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
11830: LD_ADDR_VAR 0 2
11834: PUSH
11835: LD_INT 21
11837: PUSH
11838: LD_INT 3
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: PPUSH
11845: CALL_OW 69
11849: ST_TO_ADDR
// tmp2 := [ ] ;
11850: LD_ADDR_VAR 0 3
11854: PUSH
11855: EMPTY
11856: ST_TO_ADDR
// if tmp then
11857: LD_VAR 0 2
11861: IFFALSE 12009
// for i in tmp do
11863: LD_ADDR_VAR 0 1
11867: PUSH
11868: LD_VAR 0 2
11872: PUSH
11873: FOR_IN
11874: IFFALSE 12007
// tmp2 := tmp2 ^ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
11876: LD_ADDR_VAR 0 3
11880: PUSH
11881: LD_VAR 0 3
11885: PUSH
11886: LD_VAR 0 1
11890: PPUSH
11891: CALL_OW 255
11895: PUSH
11896: LD_VAR 0 1
11900: PPUSH
11901: CALL_OW 248
11905: PUSH
11906: LD_VAR 0 1
11910: PPUSH
11911: CALL_OW 266
11915: PUSH
11916: LD_VAR 0 1
11920: PPUSH
11921: CALL_OW 250
11925: PUSH
11926: LD_VAR 0 1
11930: PPUSH
11931: CALL_OW 251
11935: PUSH
11936: LD_VAR 0 1
11940: PPUSH
11941: CALL_OW 254
11945: PUSH
11946: LD_VAR 0 1
11950: PPUSH
11951: CALL_OW 267
11955: PUSH
11956: LD_VAR 0 1
11960: PPUSH
11961: LD_INT 1
11963: PPUSH
11964: CALL_OW 268
11968: PUSH
11969: LD_VAR 0 1
11973: PPUSH
11974: LD_INT 2
11976: PPUSH
11977: CALL_OW 268
11981: PUSH
11982: LD_VAR 0 1
11986: PPUSH
11987: CALL_OW 269
11991: PUSH
11992: EMPTY
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: LIST
12003: ADD
12004: ST_TO_ADDR
12005: GO 11873
12007: POP
12008: POP
// if tmp2 then
12009: LD_VAR 0 3
12013: IFFALSE 12027
// SaveVariable ( tmp2 , 13a_buildings ) ;
12015: LD_VAR 0 3
12019: PPUSH
12020: LD_STRING 13a_buildings
12022: PPUSH
12023: CALL_OW 39
// YouWin ;
12027: CALL_OW 103
// end ;
12031: PPOPN 3
12033: END
// export function SciRu ; var tmp , t ; begin
12034: LD_INT 0
12036: PPUSH
12037: PPUSH
12038: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12039: LD_ADDR_VAR 0 3
12043: PUSH
12044: LD_EXP 31
12048: PUSH
12049: LD_EXP 45
12053: PUSH
12054: LD_EXP 33
12058: PUSH
12059: LD_EXP 46
12063: PUSH
12064: LD_EXP 47
12068: PUSH
12069: EMPTY
12070: LIST
12071: LIST
12072: LIST
12073: LIST
12074: LIST
12075: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12076: LD_ADDR_VAR 0 2
12080: PUSH
12081: LD_INT 22
12083: PUSH
12084: LD_INT 7
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 23
12093: PUSH
12094: LD_INT 3
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 25
12103: PUSH
12104: LD_INT 4
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: LD_INT 26
12113: PUSH
12114: LD_INT 1
12116: PUSH
12117: EMPTY
12118: LIST
12119: LIST
12120: PUSH
12121: EMPTY
12122: LIST
12123: LIST
12124: LIST
12125: LIST
12126: PPUSH
12127: CALL_OW 69
12131: PUSH
12132: LD_VAR 0 3
12136: DIFF
12137: ST_TO_ADDR
// if tmp then
12138: LD_VAR 0 2
12142: IFFALSE 12158
// result := tmp [ 1 ] ;
12144: LD_ADDR_VAR 0 1
12148: PUSH
12149: LD_VAR 0 2
12153: PUSH
12154: LD_INT 1
12156: ARRAY
12157: ST_TO_ADDR
// end ;
12158: LD_VAR 0 1
12162: RET
// export function SolRu ; var tmp , t ; begin
12163: LD_INT 0
12165: PPUSH
12166: PPUSH
12167: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12168: LD_ADDR_VAR 0 3
12172: PUSH
12173: LD_EXP 46
12177: PUSH
12178: LD_EXP 45
12182: PUSH
12183: LD_EXP 31
12187: PUSH
12188: EMPTY
12189: LIST
12190: LIST
12191: LIST
12192: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 22
12200: PUSH
12201: LD_INT 7
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PUSH
12208: LD_INT 23
12210: PUSH
12211: LD_INT 3
12213: PUSH
12214: EMPTY
12215: LIST
12216: LIST
12217: PUSH
12218: LD_INT 25
12220: PUSH
12221: LD_INT 1
12223: PUSH
12224: EMPTY
12225: LIST
12226: LIST
12227: PUSH
12228: LD_INT 26
12230: PUSH
12231: LD_INT 1
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: LIST
12242: LIST
12243: PPUSH
12244: CALL_OW 69
12248: PUSH
12249: LD_VAR 0 3
12253: DIFF
12254: ST_TO_ADDR
// if tmp then
12255: LD_VAR 0 2
12259: IFFALSE 12275
// result := tmp [ 1 ] ;
12261: LD_ADDR_VAR 0 1
12265: PUSH
12266: LD_VAR 0 2
12270: PUSH
12271: LD_INT 1
12273: ARRAY
12274: ST_TO_ADDR
// end ; end_of_file
12275: LD_VAR 0 1
12279: RET
// on UnitDestroyed ( un ) do var i , side ;
12280: LD_INT 0
12282: PPUSH
12283: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12284: LD_VAR 0 1
12288: PUSH
12289: LD_INT 22
12291: PUSH
12292: LD_INT 7
12294: PUSH
12295: EMPTY
12296: LIST
12297: LIST
12298: PUSH
12299: LD_INT 2
12301: PUSH
12302: LD_INT 25
12304: PUSH
12305: LD_INT 1
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: PUSH
12312: LD_INT 25
12314: PUSH
12315: LD_INT 2
12317: PUSH
12318: EMPTY
12319: LIST
12320: LIST
12321: PUSH
12322: LD_INT 25
12324: PUSH
12325: LD_INT 3
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: LD_INT 25
12334: PUSH
12335: LD_INT 4
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PUSH
12342: LD_INT 25
12344: PUSH
12345: LD_INT 5
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: PUSH
12352: LD_INT 25
12354: PUSH
12355: LD_INT 8
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PUSH
12362: LD_INT 25
12364: PUSH
12365: LD_INT 9
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: EMPTY
12373: LIST
12374: LIST
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: PUSH
12382: EMPTY
12383: LIST
12384: LIST
12385: PPUSH
12386: CALL_OW 69
12390: IN
12391: IFFALSE 12407
// loss_counter := loss_counter + 1 ;
12393: LD_ADDR_EXP 13
12397: PUSH
12398: LD_EXP 13
12402: PUSH
12403: LD_INT 1
12405: PLUS
12406: ST_TO_ADDR
// if un = Abdul then
12407: LD_VAR 0 1
12411: PUSH
12412: LD_EXP 54
12416: EQUAL
12417: IFFALSE 12427
// abdul_escaped := false ;
12419: LD_ADDR_EXP 12
12423: PUSH
12424: LD_INT 0
12426: ST_TO_ADDR
// if un in ru_attackers then
12427: LD_VAR 0 1
12431: PUSH
12432: LD_EXP 51
12436: IN
12437: IFFALSE 12455
// ru_attackers := ru_attackers diff un ;
12439: LD_ADDR_EXP 51
12443: PUSH
12444: LD_EXP 51
12448: PUSH
12449: LD_VAR 0 1
12453: DIFF
12454: ST_TO_ADDR
// if un in ar_attackers then
12455: LD_VAR 0 1
12459: PUSH
12460: LD_EXP 10
12464: IN
12465: IFFALSE 12483
// ar_attackers := ar_attackers diff un ;
12467: LD_ADDR_EXP 10
12471: PUSH
12472: LD_EXP 10
12476: PUSH
12477: LD_VAR 0 1
12481: DIFF
12482: ST_TO_ADDR
// if un = JMM then
12483: LD_VAR 0 1
12487: PUSH
12488: LD_EXP 14
12492: EQUAL
12493: IFFALSE 12504
// begin YouLost ( JMM ) ;
12495: LD_STRING JMM
12497: PPUSH
12498: CALL_OW 104
// exit ;
12502: GO 12593
// end ; if un = Burlak then
12504: LD_VAR 0 1
12508: PUSH
12509: LD_EXP 45
12513: EQUAL
12514: IFFALSE 12525
// begin YouLost ( Burlak ) ;
12516: LD_STRING Burlak
12518: PPUSH
12519: CALL_OW 104
// exit ;
12523: GO 12593
// end ; if un = freedom then
12525: LD_VAR 0 1
12529: PUSH
12530: LD_EXP 3
12534: EQUAL
12535: IFFALSE 12546
// begin YouLost ( Destroyed ) ;
12537: LD_STRING Destroyed
12539: PPUSH
12540: CALL_OW 104
// exit ;
12544: GO 12593
// end ; if un = Masha then
12546: LD_VAR 0 1
12550: PUSH
12551: LD_EXP 48
12555: EQUAL
12556: IFFALSE 12565
// ChangeMissionObjectives ( M4b ) ;
12558: LD_STRING M4b
12560: PPUSH
12561: CALL_OW 337
// if un = Mastodont then
12565: LD_VAR 0 1
12569: PUSH
12570: LD_EXP 55
12574: EQUAL
12575: IFFALSE 12584
// ChangeMissionObjectives ( M4a ) ;
12577: LD_STRING M4a
12579: PPUSH
12580: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12584: LD_VAR 0 1
12588: PPUSH
12589: CALL 80539 0 1
// end ;
12593: PPOPN 3
12595: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12596: LD_VAR 0 1
12600: PPUSH
12601: LD_VAR 0 2
12605: PPUSH
12606: CALL 82424 0 2
// end ;
12610: PPOPN 2
12612: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12613: LD_VAR 0 1
12617: PPUSH
12618: CALL 81506 0 1
// end ;
12622: PPOPN 1
12624: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12625: LD_VAR 0 1
12629: PUSH
12630: LD_INT 22
12632: PUSH
12633: LD_INT 7
12635: PUSH
12636: EMPTY
12637: LIST
12638: LIST
12639: PUSH
12640: LD_INT 30
12642: PUSH
12643: LD_INT 0
12645: PUSH
12646: EMPTY
12647: LIST
12648: LIST
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: PPUSH
12654: CALL_OW 69
12658: IN
12659: IFFALSE 12698
// begin SetBName ( building , freedom ) ;
12661: LD_VAR 0 1
12665: PPUSH
12666: LD_STRING freedom
12668: PPUSH
12669: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12673: LD_INT 0
12675: PPUSH
12676: LD_INT 7
12678: PPUSH
12679: LD_INT 0
12681: PPUSH
12682: CALL_OW 324
// freedom := building ;
12686: LD_ADDR_EXP 3
12690: PUSH
12691: LD_VAR 0 1
12695: ST_TO_ADDR
// exit ;
12696: GO 12764
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
12698: LD_VAR 0 1
12702: PUSH
12703: LD_INT 22
12705: PUSH
12706: LD_INT 7
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PUSH
12713: LD_INT 23
12715: PUSH
12716: LD_INT 3
12718: PUSH
12719: EMPTY
12720: LIST
12721: LIST
12722: PUSH
12723: LD_INT 30
12725: PUSH
12726: LD_INT 6
12728: PUSH
12729: EMPTY
12730: LIST
12731: LIST
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: LIST
12737: PPUSH
12738: CALL_OW 69
12742: IN
12743: IFFALSE 12755
// begin ru_lab_builded := true ;
12745: LD_ADDR_EXP 5
12749: PUSH
12750: LD_INT 1
12752: ST_TO_ADDR
// exit ;
12753: GO 12764
// end ; MCE_BuildingComplete ( building ) ;
12755: LD_VAR 0 1
12759: PPUSH
12760: CALL 81740 0 1
// end ;
12764: PPOPN 1
12766: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12767: LD_VAR 0 1
12771: PPUSH
12772: LD_VAR 0 2
12776: PPUSH
12777: CALL 80251 0 2
// end ;
12781: PPOPN 2
12783: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12784: LD_VAR 0 1
12788: PPUSH
12789: LD_VAR 0 2
12793: PPUSH
12794: LD_VAR 0 3
12798: PPUSH
12799: LD_VAR 0 4
12803: PPUSH
12804: LD_VAR 0 5
12808: PPUSH
12809: CALL 79878 0 5
// end ;
12813: PPOPN 5
12815: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12816: LD_VAR 0 1
12820: PPUSH
12821: LD_VAR 0 2
12825: PPUSH
12826: CALL 79475 0 2
// end ;
12830: PPOPN 2
12832: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12833: LD_VAR 0 1
12837: PPUSH
12838: LD_VAR 0 2
12842: PPUSH
12843: LD_VAR 0 3
12847: PPUSH
12848: LD_VAR 0 4
12852: PPUSH
12853: CALL 79320 0 4
// end ;
12857: PPOPN 4
12859: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12860: LD_VAR 0 1
12864: PPUSH
12865: LD_VAR 0 2
12869: PPUSH
12870: LD_VAR 0 3
12874: PPUSH
12875: CALL 79102 0 3
// end ;
12879: PPOPN 3
12881: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12882: LD_VAR 0 1
12886: PPUSH
12887: LD_VAR 0 2
12891: PPUSH
12892: CALL 78994 0 2
// end ;
12896: PPOPN 2
12898: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12899: LD_VAR 0 1
12903: PPUSH
12904: LD_VAR 0 2
12908: PPUSH
12909: CALL 82678 0 2
// end ;
12913: PPOPN 2
12915: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12916: LD_VAR 0 1
12920: PPUSH
12921: LD_VAR 0 2
12925: PPUSH
12926: LD_VAR 0 3
12930: PPUSH
12931: LD_VAR 0 4
12935: PPUSH
12936: CALL 82887 0 4
// end ;
12940: PPOPN 4
12942: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12943: LD_VAR 0 1
12947: PPUSH
12948: LD_VAR 0 2
12952: PPUSH
12953: CALL 78810 0 2
// end ; end_of_file
12957: PPOPN 2
12959: END
// every 0 0$30 do var cr , time ;
12960: GO 12962
12962: DISABLE
12963: LD_INT 0
12965: PPUSH
12966: PPUSH
// begin time := 0 0$10 ;
12967: LD_ADDR_VAR 0 2
12971: PUSH
12972: LD_INT 350
12974: ST_TO_ADDR
// while game do
12975: LD_EXP 2
12979: IFFALSE 13078
// begin wait ( time ) ;
12981: LD_VAR 0 2
12985: PPUSH
12986: CALL_OW 67
// if tick > 2 2$00 then
12990: LD_OWVAR 1
12994: PUSH
12995: LD_INT 4200
12997: GREATER
12998: IFFALSE 13031
// time := time + [ 0 0$06 , 0 0$07 , 0 0$08 ] [ Difficulty ] ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_VAR 0 2
13009: PUSH
13010: LD_INT 210
13012: PUSH
13013: LD_INT 245
13015: PUSH
13016: LD_INT 280
13018: PUSH
13019: EMPTY
13020: LIST
13021: LIST
13022: LIST
13023: PUSH
13024: LD_OWVAR 67
13028: ARRAY
13029: PLUS
13030: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13031: LD_INT 1
13033: PPUSH
13034: LD_INT 5
13036: PPUSH
13037: CALL_OW 12
13041: PPUSH
13042: LD_INT 70
13044: PPUSH
13045: LD_INT 49
13047: PPUSH
13048: LD_INT 25
13050: PPUSH
13051: LD_INT 1
13053: PPUSH
13054: CALL_OW 56
// if time > 5 5$00 then
13058: LD_VAR 0 2
13062: PUSH
13063: LD_INT 10500
13065: GREATER
13066: IFFALSE 13076
// time := 0 0$30 ;
13068: LD_ADDR_VAR 0 2
13072: PUSH
13073: LD_INT 1050
13075: ST_TO_ADDR
// end ;
13076: GO 12975
// end ;
13078: PPOPN 2
13080: END
// every 0 0$30 do var cr , time ;
13081: GO 13083
13083: DISABLE
13084: LD_INT 0
13086: PPUSH
13087: PPUSH
// begin time := 0 0$01 ;
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: LD_INT 35
13095: ST_TO_ADDR
// while game do
13096: LD_EXP 2
13100: IFFALSE 13189
// begin wait ( time ) ;
13102: LD_VAR 0 2
13106: PPUSH
13107: CALL_OW 67
// time := time + [ 0 0$04 , 0 0$05 , 0 0$06 ] [ Difficulty ] ;
13111: LD_ADDR_VAR 0 2
13115: PUSH
13116: LD_VAR 0 2
13120: PUSH
13121: LD_INT 140
13123: PUSH
13124: LD_INT 175
13126: PUSH
13127: LD_INT 210
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: PUSH
13135: LD_OWVAR 67
13139: ARRAY
13140: PLUS
13141: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13142: LD_INT 3
13144: PPUSH
13145: LD_INT 5
13147: PPUSH
13148: CALL_OW 12
13152: PPUSH
13153: LD_INT 26
13155: PPUSH
13156: LD_INT 9
13158: PPUSH
13159: LD_INT 30
13161: PPUSH
13162: LD_INT 1
13164: PPUSH
13165: CALL_OW 56
// if time > 3 3$00 then
13169: LD_VAR 0 2
13173: PUSH
13174: LD_INT 6300
13176: GREATER
13177: IFFALSE 13187
// time := 0 0$20 ;
13179: LD_ADDR_VAR 0 2
13183: PUSH
13184: LD_INT 700
13186: ST_TO_ADDR
// end ;
13187: GO 13096
// end ;
13189: PPOPN 2
13191: END
// every 0 0$30 do var cr , time ;
13192: GO 13194
13194: DISABLE
13195: LD_INT 0
13197: PPUSH
13198: PPUSH
// begin time := 0 0$20 ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 700
13206: ST_TO_ADDR
// while game do
13207: LD_EXP 2
13211: IFFALSE 13336
// begin wait ( time ) ;
13213: LD_VAR 0 2
13217: PPUSH
13218: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13222: LD_ADDR_VAR 0 2
13226: PUSH
13227: LD_VAR 0 2
13231: PUSH
13232: LD_INT 175
13234: PUSH
13235: LD_INT 210
13237: PUSH
13238: LD_INT 280
13240: PUSH
13241: EMPTY
13242: LIST
13243: LIST
13244: LIST
13245: PUSH
13246: LD_OWVAR 67
13250: ARRAY
13251: PLUS
13252: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13253: LD_INT 1
13255: PPUSH
13256: LD_INT 5
13258: PPUSH
13259: CALL_OW 12
13263: PPUSH
13264: LD_INT 179
13266: PPUSH
13267: LD_INT 101
13269: PPUSH
13270: LD_INT 20
13272: PPUSH
13273: LD_INT 1
13275: PPUSH
13276: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13280: LD_INT 350
13282: PPUSH
13283: LD_INT 525
13285: PPUSH
13286: CALL_OW 12
13290: PPUSH
13291: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13295: LD_INT 1
13297: PPUSH
13298: LD_INT 5
13300: PPUSH
13301: CALL_OW 12
13305: PPUSH
13306: LD_INT 9
13308: PPUSH
13309: LD_INT 1
13311: PPUSH
13312: CALL_OW 55
// if time > 4 4$00 then
13316: LD_VAR 0 2
13320: PUSH
13321: LD_INT 8400
13323: GREATER
13324: IFFALSE 13334
// time := 0 0$30 ;
13326: LD_ADDR_VAR 0 2
13330: PUSH
13331: LD_INT 1050
13333: ST_TO_ADDR
// end ;
13334: GO 13207
// end ;
13336: PPOPN 2
13338: END
// every 0 0$30 do var cr , time ;
13339: GO 13341
13341: DISABLE
13342: LD_INT 0
13344: PPUSH
13345: PPUSH
// begin time := 0 0$10 ;
13346: LD_ADDR_VAR 0 2
13350: PUSH
13351: LD_INT 350
13353: ST_TO_ADDR
// while game do
13354: LD_EXP 2
13358: IFFALSE 13492
// begin wait ( time ) ;
13360: LD_VAR 0 2
13364: PPUSH
13365: CALL_OW 67
// time := time + 0 0$10 ;
13369: LD_ADDR_VAR 0 2
13373: PUSH
13374: LD_VAR 0 2
13378: PUSH
13379: LD_INT 350
13381: PLUS
13382: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13383: LD_INT 1
13385: PPUSH
13386: LD_INT 5
13388: PPUSH
13389: CALL_OW 12
13393: PPUSH
13394: LD_INT 11
13396: PPUSH
13397: LD_INT 1
13399: PPUSH
13400: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13404: LD_ADDR_VAR 0 1
13408: PUSH
13409: LD_INT 1
13411: PPUSH
13412: LD_INT 3
13414: PPUSH
13415: CALL_OW 12
13419: ST_TO_ADDR
// if cr = 1 then
13420: LD_VAR 0 1
13424: PUSH
13425: LD_INT 1
13427: EQUAL
13428: IFFALSE 13472
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13430: LD_INT 700
13432: PPUSH
13433: LD_INT 1575
13435: PPUSH
13436: CALL_OW 12
13440: PPUSH
13441: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13445: LD_INT 1
13447: PPUSH
13448: LD_INT 5
13450: PPUSH
13451: CALL_OW 12
13455: PPUSH
13456: LD_INT 34
13458: PPUSH
13459: LD_INT 50
13461: PPUSH
13462: LD_INT 7
13464: PPUSH
13465: LD_INT 1
13467: PPUSH
13468: CALL_OW 56
// end ; if time > 8 8$00 then
13472: LD_VAR 0 2
13476: PUSH
13477: LD_INT 16800
13479: GREATER
13480: IFFALSE 13490
// time := 0 0$40 ;
13482: LD_ADDR_VAR 0 2
13486: PUSH
13487: LD_INT 1400
13489: ST_TO_ADDR
// end ;
13490: GO 13354
// end ; end_of_file
13492: PPOPN 2
13494: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13495: LD_INT 0
13497: PPUSH
13498: PPUSH
// if exist_mode then
13499: LD_VAR 0 2
13503: IFFALSE 13528
// unit := CreateCharacter ( prefix & ident ) else
13505: LD_ADDR_VAR 0 5
13509: PUSH
13510: LD_VAR 0 3
13514: PUSH
13515: LD_VAR 0 1
13519: STR
13520: PPUSH
13521: CALL_OW 34
13525: ST_TO_ADDR
13526: GO 13543
// unit := NewCharacter ( ident ) ;
13528: LD_ADDR_VAR 0 5
13532: PUSH
13533: LD_VAR 0 1
13537: PPUSH
13538: CALL_OW 25
13542: ST_TO_ADDR
// result := unit ;
13543: LD_ADDR_VAR 0 4
13547: PUSH
13548: LD_VAR 0 5
13552: ST_TO_ADDR
// end ;
13553: LD_VAR 0 4
13557: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13558: LD_INT 0
13560: PPUSH
13561: PPUSH
// if not side or not nation then
13562: LD_VAR 0 1
13566: NOT
13567: PUSH
13568: LD_VAR 0 2
13572: NOT
13573: OR
13574: IFFALSE 13578
// exit ;
13576: GO 14214
// case nation of nation_american :
13578: LD_VAR 0 2
13582: PUSH
13583: LD_INT 1
13585: DOUBLE
13586: EQUAL
13587: IFTRUE 13591
13589: GO 13761
13591: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13592: LD_ADDR_VAR 0 4
13596: PUSH
13597: LD_INT 35
13599: PUSH
13600: LD_INT 45
13602: PUSH
13603: LD_INT 46
13605: PUSH
13606: LD_INT 47
13608: PUSH
13609: LD_INT 1
13611: PUSH
13612: LD_INT 2
13614: PUSH
13615: LD_INT 6
13617: PUSH
13618: LD_INT 15
13620: PUSH
13621: LD_INT 16
13623: PUSH
13624: LD_INT 7
13626: PUSH
13627: LD_INT 12
13629: PUSH
13630: LD_INT 13
13632: PUSH
13633: LD_INT 10
13635: PUSH
13636: LD_INT 14
13638: PUSH
13639: LD_INT 20
13641: PUSH
13642: LD_INT 21
13644: PUSH
13645: LD_INT 22
13647: PUSH
13648: LD_INT 25
13650: PUSH
13651: LD_INT 32
13653: PUSH
13654: LD_INT 27
13656: PUSH
13657: LD_INT 36
13659: PUSH
13660: LD_INT 69
13662: PUSH
13663: LD_INT 39
13665: PUSH
13666: LD_INT 34
13668: PUSH
13669: LD_INT 40
13671: PUSH
13672: LD_INT 48
13674: PUSH
13675: LD_INT 49
13677: PUSH
13678: LD_INT 50
13680: PUSH
13681: LD_INT 51
13683: PUSH
13684: LD_INT 52
13686: PUSH
13687: LD_INT 53
13689: PUSH
13690: LD_INT 54
13692: PUSH
13693: LD_INT 55
13695: PUSH
13696: LD_INT 56
13698: PUSH
13699: LD_INT 57
13701: PUSH
13702: LD_INT 58
13704: PUSH
13705: LD_INT 59
13707: PUSH
13708: LD_INT 60
13710: PUSH
13711: LD_INT 61
13713: PUSH
13714: LD_INT 62
13716: PUSH
13717: EMPTY
13718: LIST
13719: LIST
13720: LIST
13721: LIST
13722: LIST
13723: LIST
13724: LIST
13725: LIST
13726: LIST
13727: LIST
13728: LIST
13729: LIST
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: ST_TO_ADDR
13759: GO 14138
13761: LD_INT 2
13763: DOUBLE
13764: EQUAL
13765: IFTRUE 13769
13767: GO 13947
13769: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
13770: LD_ADDR_VAR 0 4
13774: PUSH
13775: LD_INT 35
13777: PUSH
13778: LD_INT 45
13780: PUSH
13781: LD_INT 46
13783: PUSH
13784: LD_INT 47
13786: PUSH
13787: LD_INT 70
13789: PUSH
13790: LD_INT 1
13792: PUSH
13793: LD_INT 11
13795: PUSH
13796: LD_INT 3
13798: PUSH
13799: LD_INT 4
13801: PUSH
13802: LD_INT 5
13804: PUSH
13805: LD_INT 6
13807: PUSH
13808: LD_INT 15
13810: PUSH
13811: LD_INT 18
13813: PUSH
13814: LD_INT 7
13816: PUSH
13817: LD_INT 17
13819: PUSH
13820: LD_INT 8
13822: PUSH
13823: LD_INT 20
13825: PUSH
13826: LD_INT 21
13828: PUSH
13829: LD_INT 22
13831: PUSH
13832: LD_INT 72
13834: PUSH
13835: LD_INT 26
13837: PUSH
13838: LD_INT 69
13840: PUSH
13841: LD_INT 39
13843: PUSH
13844: LD_INT 40
13846: PUSH
13847: LD_INT 41
13849: PUSH
13850: LD_INT 42
13852: PUSH
13853: LD_INT 43
13855: PUSH
13856: LD_INT 48
13858: PUSH
13859: LD_INT 49
13861: PUSH
13862: LD_INT 50
13864: PUSH
13865: LD_INT 51
13867: PUSH
13868: LD_INT 52
13870: PUSH
13871: LD_INT 53
13873: PUSH
13874: LD_INT 54
13876: PUSH
13877: LD_INT 55
13879: PUSH
13880: LD_INT 56
13882: PUSH
13883: LD_INT 60
13885: PUSH
13886: LD_INT 61
13888: PUSH
13889: LD_INT 62
13891: PUSH
13892: LD_INT 66
13894: PUSH
13895: LD_INT 67
13897: PUSH
13898: LD_INT 68
13900: PUSH
13901: EMPTY
13902: LIST
13903: LIST
13904: LIST
13905: LIST
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: ST_TO_ADDR
13945: GO 14138
13947: LD_INT 3
13949: DOUBLE
13950: EQUAL
13951: IFTRUE 13955
13953: GO 14137
13955: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
13956: LD_ADDR_VAR 0 4
13960: PUSH
13961: LD_INT 46
13963: PUSH
13964: LD_INT 47
13966: PUSH
13967: LD_INT 1
13969: PUSH
13970: LD_INT 2
13972: PUSH
13973: LD_INT 11
13975: PUSH
13976: LD_INT 9
13978: PUSH
13979: LD_INT 20
13981: PUSH
13982: LD_INT 19
13984: PUSH
13985: LD_INT 21
13987: PUSH
13988: LD_INT 24
13990: PUSH
13991: LD_INT 22
13993: PUSH
13994: LD_INT 25
13996: PUSH
13997: LD_INT 28
13999: PUSH
14000: LD_INT 29
14002: PUSH
14003: LD_INT 30
14005: PUSH
14006: LD_INT 31
14008: PUSH
14009: LD_INT 37
14011: PUSH
14012: LD_INT 38
14014: PUSH
14015: LD_INT 32
14017: PUSH
14018: LD_INT 27
14020: PUSH
14021: LD_INT 33
14023: PUSH
14024: LD_INT 69
14026: PUSH
14027: LD_INT 39
14029: PUSH
14030: LD_INT 34
14032: PUSH
14033: LD_INT 40
14035: PUSH
14036: LD_INT 71
14038: PUSH
14039: LD_INT 23
14041: PUSH
14042: LD_INT 44
14044: PUSH
14045: LD_INT 48
14047: PUSH
14048: LD_INT 49
14050: PUSH
14051: LD_INT 50
14053: PUSH
14054: LD_INT 51
14056: PUSH
14057: LD_INT 52
14059: PUSH
14060: LD_INT 53
14062: PUSH
14063: LD_INT 54
14065: PUSH
14066: LD_INT 55
14068: PUSH
14069: LD_INT 56
14071: PUSH
14072: LD_INT 57
14074: PUSH
14075: LD_INT 58
14077: PUSH
14078: LD_INT 59
14080: PUSH
14081: LD_INT 63
14083: PUSH
14084: LD_INT 64
14086: PUSH
14087: LD_INT 65
14089: PUSH
14090: EMPTY
14091: LIST
14092: LIST
14093: LIST
14094: LIST
14095: LIST
14096: LIST
14097: LIST
14098: LIST
14099: LIST
14100: LIST
14101: LIST
14102: LIST
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: ST_TO_ADDR
14135: GO 14138
14137: POP
// if state > - 1 and state < 3 then
14138: LD_VAR 0 3
14142: PUSH
14143: LD_INT 1
14145: NEG
14146: GREATER
14147: PUSH
14148: LD_VAR 0 3
14152: PUSH
14153: LD_INT 3
14155: LESS
14156: AND
14157: IFFALSE 14214
// for i in result do
14159: LD_ADDR_VAR 0 5
14163: PUSH
14164: LD_VAR 0 4
14168: PUSH
14169: FOR_IN
14170: IFFALSE 14212
// if GetTech ( i , side ) <> state then
14172: LD_VAR 0 5
14176: PPUSH
14177: LD_VAR 0 1
14181: PPUSH
14182: CALL_OW 321
14186: PUSH
14187: LD_VAR 0 3
14191: NONEQUAL
14192: IFFALSE 14210
// result := result diff i ;
14194: LD_ADDR_VAR 0 4
14198: PUSH
14199: LD_VAR 0 4
14203: PUSH
14204: LD_VAR 0 5
14208: DIFF
14209: ST_TO_ADDR
14210: GO 14169
14212: POP
14213: POP
// end ;
14214: LD_VAR 0 4
14218: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14219: LD_INT 0
14221: PPUSH
14222: PPUSH
14223: PPUSH
// result := true ;
14224: LD_ADDR_VAR 0 3
14228: PUSH
14229: LD_INT 1
14231: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14232: LD_ADDR_VAR 0 5
14236: PUSH
14237: LD_VAR 0 2
14241: PPUSH
14242: CALL_OW 480
14246: ST_TO_ADDR
// if not tmp then
14247: LD_VAR 0 5
14251: NOT
14252: IFFALSE 14256
// exit ;
14254: GO 14305
// for i in tmp do
14256: LD_ADDR_VAR 0 4
14260: PUSH
14261: LD_VAR 0 5
14265: PUSH
14266: FOR_IN
14267: IFFALSE 14303
// if GetTech ( i , side ) <> state_researched then
14269: LD_VAR 0 4
14273: PPUSH
14274: LD_VAR 0 1
14278: PPUSH
14279: CALL_OW 321
14283: PUSH
14284: LD_INT 2
14286: NONEQUAL
14287: IFFALSE 14301
// begin result := false ;
14289: LD_ADDR_VAR 0 3
14293: PUSH
14294: LD_INT 0
14296: ST_TO_ADDR
// exit ;
14297: POP
14298: POP
14299: GO 14305
// end ;
14301: GO 14266
14303: POP
14304: POP
// end ;
14305: LD_VAR 0 3
14309: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14310: LD_INT 0
14312: PPUSH
14313: PPUSH
14314: PPUSH
14315: PPUSH
14316: PPUSH
14317: PPUSH
14318: PPUSH
14319: PPUSH
14320: PPUSH
14321: PPUSH
14322: PPUSH
14323: PPUSH
14324: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14325: LD_VAR 0 1
14329: NOT
14330: PUSH
14331: LD_VAR 0 1
14335: PPUSH
14336: CALL_OW 257
14340: PUSH
14341: LD_INT 9
14343: NONEQUAL
14344: OR
14345: IFFALSE 14349
// exit ;
14347: GO 14922
// side := GetSide ( unit ) ;
14349: LD_ADDR_VAR 0 9
14353: PUSH
14354: LD_VAR 0 1
14358: PPUSH
14359: CALL_OW 255
14363: ST_TO_ADDR
// tech_space := tech_spacanom ;
14364: LD_ADDR_VAR 0 12
14368: PUSH
14369: LD_INT 29
14371: ST_TO_ADDR
// tech_time := tech_taurad ;
14372: LD_ADDR_VAR 0 13
14376: PUSH
14377: LD_INT 28
14379: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14380: LD_ADDR_VAR 0 11
14384: PUSH
14385: LD_VAR 0 1
14389: PPUSH
14390: CALL_OW 310
14394: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14395: LD_VAR 0 11
14399: PPUSH
14400: CALL_OW 247
14404: PUSH
14405: LD_INT 2
14407: EQUAL
14408: IFFALSE 14412
// exit ;
14410: GO 14922
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14412: LD_ADDR_VAR 0 8
14416: PUSH
14417: LD_INT 81
14419: PUSH
14420: LD_VAR 0 9
14424: PUSH
14425: EMPTY
14426: LIST
14427: LIST
14428: PUSH
14429: LD_INT 3
14431: PUSH
14432: LD_INT 21
14434: PUSH
14435: LD_INT 3
14437: PUSH
14438: EMPTY
14439: LIST
14440: LIST
14441: PUSH
14442: EMPTY
14443: LIST
14444: LIST
14445: PUSH
14446: EMPTY
14447: LIST
14448: LIST
14449: PPUSH
14450: CALL_OW 69
14454: ST_TO_ADDR
// if not tmp then
14455: LD_VAR 0 8
14459: NOT
14460: IFFALSE 14464
// exit ;
14462: GO 14922
// if in_unit then
14464: LD_VAR 0 11
14468: IFFALSE 14492
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14470: LD_ADDR_VAR 0 10
14474: PUSH
14475: LD_VAR 0 8
14479: PPUSH
14480: LD_VAR 0 11
14484: PPUSH
14485: CALL_OW 74
14489: ST_TO_ADDR
14490: GO 14512
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14492: LD_ADDR_VAR 0 10
14496: PUSH
14497: LD_VAR 0 8
14501: PPUSH
14502: LD_VAR 0 1
14506: PPUSH
14507: CALL_OW 74
14511: ST_TO_ADDR
// if not enemy then
14512: LD_VAR 0 10
14516: NOT
14517: IFFALSE 14521
// exit ;
14519: GO 14922
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14521: LD_VAR 0 11
14525: PUSH
14526: LD_VAR 0 11
14530: PPUSH
14531: LD_VAR 0 10
14535: PPUSH
14536: CALL_OW 296
14540: PUSH
14541: LD_INT 13
14543: GREATER
14544: AND
14545: PUSH
14546: LD_VAR 0 1
14550: PPUSH
14551: LD_VAR 0 10
14555: PPUSH
14556: CALL_OW 296
14560: PUSH
14561: LD_INT 12
14563: GREATER
14564: OR
14565: IFFALSE 14569
// exit ;
14567: GO 14922
// missile := [ 1 ] ;
14569: LD_ADDR_VAR 0 14
14573: PUSH
14574: LD_INT 1
14576: PUSH
14577: EMPTY
14578: LIST
14579: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14580: LD_VAR 0 9
14584: PPUSH
14585: LD_VAR 0 12
14589: PPUSH
14590: CALL_OW 325
14594: IFFALSE 14623
// missile := Insert ( missile , missile + 1 , 2 ) ;
14596: LD_ADDR_VAR 0 14
14600: PUSH
14601: LD_VAR 0 14
14605: PPUSH
14606: LD_VAR 0 14
14610: PUSH
14611: LD_INT 1
14613: PLUS
14614: PPUSH
14615: LD_INT 2
14617: PPUSH
14618: CALL_OW 2
14622: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14623: LD_VAR 0 9
14627: PPUSH
14628: LD_VAR 0 13
14632: PPUSH
14633: CALL_OW 325
14637: PUSH
14638: LD_VAR 0 10
14642: PPUSH
14643: CALL_OW 255
14647: PPUSH
14648: LD_VAR 0 13
14652: PPUSH
14653: CALL_OW 325
14657: NOT
14658: AND
14659: IFFALSE 14688
// missile := Insert ( missile , missile + 1 , 3 ) ;
14661: LD_ADDR_VAR 0 14
14665: PUSH
14666: LD_VAR 0 14
14670: PPUSH
14671: LD_VAR 0 14
14675: PUSH
14676: LD_INT 1
14678: PLUS
14679: PPUSH
14680: LD_INT 3
14682: PPUSH
14683: CALL_OW 2
14687: ST_TO_ADDR
// if missile < 2 then
14688: LD_VAR 0 14
14692: PUSH
14693: LD_INT 2
14695: LESS
14696: IFFALSE 14700
// exit ;
14698: GO 14922
// x := GetX ( enemy ) ;
14700: LD_ADDR_VAR 0 4
14704: PUSH
14705: LD_VAR 0 10
14709: PPUSH
14710: CALL_OW 250
14714: ST_TO_ADDR
// y := GetY ( enemy ) ;
14715: LD_ADDR_VAR 0 5
14719: PUSH
14720: LD_VAR 0 10
14724: PPUSH
14725: CALL_OW 251
14729: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14730: LD_ADDR_VAR 0 6
14734: PUSH
14735: LD_VAR 0 4
14739: PUSH
14740: LD_INT 1
14742: NEG
14743: PPUSH
14744: LD_INT 1
14746: PPUSH
14747: CALL_OW 12
14751: PLUS
14752: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14753: LD_ADDR_VAR 0 7
14757: PUSH
14758: LD_VAR 0 5
14762: PUSH
14763: LD_INT 1
14765: NEG
14766: PPUSH
14767: LD_INT 1
14769: PPUSH
14770: CALL_OW 12
14774: PLUS
14775: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
14776: LD_VAR 0 6
14780: PPUSH
14781: LD_VAR 0 7
14785: PPUSH
14786: CALL_OW 488
14790: NOT
14791: IFFALSE 14813
// begin _x := x ;
14793: LD_ADDR_VAR 0 6
14797: PUSH
14798: LD_VAR 0 4
14802: ST_TO_ADDR
// _y := y ;
14803: LD_ADDR_VAR 0 7
14807: PUSH
14808: LD_VAR 0 5
14812: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
14813: LD_ADDR_VAR 0 3
14817: PUSH
14818: LD_INT 1
14820: PPUSH
14821: LD_VAR 0 14
14825: PPUSH
14826: CALL_OW 12
14830: ST_TO_ADDR
// case i of 1 :
14831: LD_VAR 0 3
14835: PUSH
14836: LD_INT 1
14838: DOUBLE
14839: EQUAL
14840: IFTRUE 14844
14842: GO 14861
14844: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
14845: LD_VAR 0 1
14849: PPUSH
14850: LD_VAR 0 10
14854: PPUSH
14855: CALL_OW 115
14859: GO 14922
14861: LD_INT 2
14863: DOUBLE
14864: EQUAL
14865: IFTRUE 14869
14867: GO 14891
14869: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
14870: LD_VAR 0 1
14874: PPUSH
14875: LD_VAR 0 6
14879: PPUSH
14880: LD_VAR 0 7
14884: PPUSH
14885: CALL_OW 153
14889: GO 14922
14891: LD_INT 3
14893: DOUBLE
14894: EQUAL
14895: IFTRUE 14899
14897: GO 14921
14899: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
14900: LD_VAR 0 1
14904: PPUSH
14905: LD_VAR 0 6
14909: PPUSH
14910: LD_VAR 0 7
14914: PPUSH
14915: CALL_OW 154
14919: GO 14922
14921: POP
// end ;
14922: LD_VAR 0 2
14926: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
14931: PPUSH
14932: PPUSH
14933: PPUSH
14934: PPUSH
// if not unit or not building then
14935: LD_VAR 0 1
14939: NOT
14940: PUSH
14941: LD_VAR 0 2
14945: NOT
14946: OR
14947: IFFALSE 14951
// exit ;
14949: GO 15109
// x := GetX ( building ) ;
14951: LD_ADDR_VAR 0 5
14955: PUSH
14956: LD_VAR 0 2
14960: PPUSH
14961: CALL_OW 250
14965: ST_TO_ADDR
// y := GetY ( building ) ;
14966: LD_ADDR_VAR 0 6
14970: PUSH
14971: LD_VAR 0 2
14975: PPUSH
14976: CALL_OW 251
14980: ST_TO_ADDR
// for i = 0 to 5 do
14981: LD_ADDR_VAR 0 4
14985: PUSH
14986: DOUBLE
14987: LD_INT 0
14989: DEC
14990: ST_TO_ADDR
14991: LD_INT 5
14993: PUSH
14994: FOR_TO
14995: IFFALSE 15107
// begin _x := ShiftX ( x , i , 3 ) ;
14997: LD_ADDR_VAR 0 7
15001: PUSH
15002: LD_VAR 0 5
15006: PPUSH
15007: LD_VAR 0 4
15011: PPUSH
15012: LD_INT 3
15014: PPUSH
15015: CALL_OW 272
15019: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15020: LD_ADDR_VAR 0 8
15024: PUSH
15025: LD_VAR 0 6
15029: PPUSH
15030: LD_VAR 0 4
15034: PPUSH
15035: LD_INT 3
15037: PPUSH
15038: CALL_OW 273
15042: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15043: LD_VAR 0 7
15047: PPUSH
15048: LD_VAR 0 8
15052: PPUSH
15053: CALL_OW 488
15057: NOT
15058: IFFALSE 15062
// continue ;
15060: GO 14994
// if HexInfo ( _x , _y ) = 0 then
15062: LD_VAR 0 7
15066: PPUSH
15067: LD_VAR 0 8
15071: PPUSH
15072: CALL_OW 428
15076: PUSH
15077: LD_INT 0
15079: EQUAL
15080: IFFALSE 15105
// begin ComMoveXY ( unit , _x , _y ) ;
15082: LD_VAR 0 1
15086: PPUSH
15087: LD_VAR 0 7
15091: PPUSH
15092: LD_VAR 0 8
15096: PPUSH
15097: CALL_OW 111
// exit ;
15101: POP
15102: POP
15103: GO 15109
// end ; end ;
15105: GO 14994
15107: POP
15108: POP
// end ;
15109: LD_VAR 0 3
15113: RET
// export function ScanBase ( side , base_area ) ; begin
15114: LD_INT 0
15116: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15117: LD_ADDR_VAR 0 3
15121: PUSH
15122: LD_VAR 0 2
15126: PPUSH
15127: LD_INT 81
15129: PUSH
15130: LD_VAR 0 1
15134: PUSH
15135: EMPTY
15136: LIST
15137: LIST
15138: PPUSH
15139: CALL_OW 70
15143: ST_TO_ADDR
// end ;
15144: LD_VAR 0 3
15148: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15149: LD_INT 0
15151: PPUSH
15152: PPUSH
15153: PPUSH
15154: PPUSH
15155: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15156: LD_VAR 0 1
15160: NOT
15161: PUSH
15162: LD_EXP 58
15166: PUSH
15167: LD_VAR 0 1
15171: ARRAY
15172: NOT
15173: OR
15174: PUSH
15175: LD_VAR 0 2
15179: NOT
15180: OR
15181: PUSH
15182: LD_VAR 0 3
15186: NOT
15187: OR
15188: IFFALSE 15192
// exit ;
15190: GO 15642
// side := mc_sides [ base ] ;
15192: LD_ADDR_VAR 0 6
15196: PUSH
15197: LD_EXP 84
15201: PUSH
15202: LD_VAR 0 1
15206: ARRAY
15207: ST_TO_ADDR
// if not side then
15208: LD_VAR 0 6
15212: NOT
15213: IFFALSE 15217
// exit ;
15215: GO 15642
// for i in solds do
15217: LD_ADDR_VAR 0 7
15221: PUSH
15222: LD_VAR 0 2
15226: PUSH
15227: FOR_IN
15228: IFFALSE 15289
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15230: LD_VAR 0 7
15234: PPUSH
15235: CALL_OW 310
15239: PPUSH
15240: CALL_OW 266
15244: PUSH
15245: LD_INT 32
15247: PUSH
15248: LD_INT 31
15250: PUSH
15251: EMPTY
15252: LIST
15253: LIST
15254: IN
15255: IFFALSE 15275
// solds := solds diff i else
15257: LD_ADDR_VAR 0 2
15261: PUSH
15262: LD_VAR 0 2
15266: PUSH
15267: LD_VAR 0 7
15271: DIFF
15272: ST_TO_ADDR
15273: GO 15287
// SetTag ( i , 18 ) ;
15275: LD_VAR 0 7
15279: PPUSH
15280: LD_INT 18
15282: PPUSH
15283: CALL_OW 109
15287: GO 15227
15289: POP
15290: POP
// if not solds then
15291: LD_VAR 0 2
15295: NOT
15296: IFFALSE 15300
// exit ;
15298: GO 15642
// repeat wait ( 0 0$1 ) ;
15300: LD_INT 35
15302: PPUSH
15303: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15307: LD_ADDR_VAR 0 5
15311: PUSH
15312: LD_VAR 0 6
15316: PPUSH
15317: LD_VAR 0 3
15321: PPUSH
15322: CALL 15114 0 2
15326: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15327: LD_VAR 0 5
15331: NOT
15332: PUSH
15333: LD_VAR 0 5
15337: PUSH
15338: LD_INT 3
15340: GREATER
15341: OR
15342: PUSH
15343: LD_EXP 80
15347: PUSH
15348: LD_VAR 0 1
15352: ARRAY
15353: OR
15354: IFFALSE 15395
// begin for i in solds do
15356: LD_ADDR_VAR 0 7
15360: PUSH
15361: LD_VAR 0 2
15365: PUSH
15366: FOR_IN
15367: IFFALSE 15391
// if HasTask ( i ) then
15369: LD_VAR 0 7
15373: PPUSH
15374: CALL_OW 314
15378: IFFALSE 15389
// ComStop ( i ) ;
15380: LD_VAR 0 7
15384: PPUSH
15385: CALL_OW 141
15389: GO 15366
15391: POP
15392: POP
// break ;
15393: GO 15630
// end ; for i in solds do
15395: LD_ADDR_VAR 0 7
15399: PUSH
15400: LD_VAR 0 2
15404: PUSH
15405: FOR_IN
15406: IFFALSE 15622
// begin if IsInUnit ( i ) then
15408: LD_VAR 0 7
15412: PPUSH
15413: CALL_OW 310
15417: IFFALSE 15428
// ComExitBuilding ( i ) ;
15419: LD_VAR 0 7
15423: PPUSH
15424: CALL_OW 122
// if GetLives ( i ) > 333 then
15428: LD_VAR 0 7
15432: PPUSH
15433: CALL_OW 256
15437: PUSH
15438: LD_INT 333
15440: GREATER
15441: IFFALSE 15469
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15443: LD_VAR 0 7
15447: PPUSH
15448: LD_VAR 0 5
15452: PPUSH
15453: LD_VAR 0 7
15457: PPUSH
15458: CALL_OW 74
15462: PPUSH
15463: CALL_OW 115
15467: GO 15620
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15469: LD_ADDR_VAR 0 8
15473: PUSH
15474: LD_EXP 58
15478: PUSH
15479: LD_VAR 0 1
15483: ARRAY
15484: PPUSH
15485: LD_INT 2
15487: PUSH
15488: LD_INT 30
15490: PUSH
15491: LD_INT 0
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: LD_INT 30
15500: PUSH
15501: LD_INT 1
15503: PUSH
15504: EMPTY
15505: LIST
15506: LIST
15507: PUSH
15508: LD_INT 30
15510: PUSH
15511: LD_INT 6
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: EMPTY
15519: LIST
15520: LIST
15521: LIST
15522: LIST
15523: PPUSH
15524: CALL_OW 72
15528: PPUSH
15529: LD_VAR 0 7
15533: PPUSH
15534: CALL_OW 74
15538: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15539: LD_VAR 0 7
15543: PPUSH
15544: LD_VAR 0 8
15548: PPUSH
15549: CALL_OW 250
15553: PPUSH
15554: LD_INT 3
15556: PPUSH
15557: LD_INT 5
15559: PPUSH
15560: CALL_OW 272
15564: PPUSH
15565: LD_VAR 0 8
15569: PPUSH
15570: CALL_OW 251
15574: PPUSH
15575: LD_INT 3
15577: PPUSH
15578: LD_INT 5
15580: PPUSH
15581: CALL_OW 273
15585: PPUSH
15586: CALL_OW 111
// SetTag ( i , 0 ) ;
15590: LD_VAR 0 7
15594: PPUSH
15595: LD_INT 0
15597: PPUSH
15598: CALL_OW 109
// solds := solds diff i ;
15602: LD_ADDR_VAR 0 2
15606: PUSH
15607: LD_VAR 0 2
15611: PUSH
15612: LD_VAR 0 7
15616: DIFF
15617: ST_TO_ADDR
// continue ;
15618: GO 15405
// end ; end ;
15620: GO 15405
15622: POP
15623: POP
// until solds ;
15624: LD_VAR 0 2
15628: IFFALSE 15300
// MC_Reset ( base , 18 ) ;
15630: LD_VAR 0 1
15634: PPUSH
15635: LD_INT 18
15637: PPUSH
15638: CALL 58609 0 2
// end ;
15642: LD_VAR 0 4
15646: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15647: LD_INT 0
15649: PPUSH
15650: PPUSH
15651: PPUSH
15652: PPUSH
15653: PPUSH
15654: PPUSH
15655: PPUSH
15656: PPUSH
15657: PPUSH
15658: PPUSH
15659: PPUSH
15660: PPUSH
15661: PPUSH
15662: PPUSH
15663: PPUSH
15664: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15665: LD_ADDR_VAR 0 12
15669: PUSH
15670: LD_EXP 58
15674: PUSH
15675: LD_VAR 0 1
15679: ARRAY
15680: PPUSH
15681: LD_INT 25
15683: PUSH
15684: LD_INT 3
15686: PUSH
15687: EMPTY
15688: LIST
15689: LIST
15690: PPUSH
15691: CALL_OW 72
15695: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15696: LD_ADDR_VAR 0 8
15700: PUSH
15701: LD_EXP 58
15705: PUSH
15706: LD_VAR 0 1
15710: ARRAY
15711: PPUSH
15712: LD_INT 2
15714: PUSH
15715: LD_INT 25
15717: PUSH
15718: LD_INT 1
15720: PUSH
15721: EMPTY
15722: LIST
15723: LIST
15724: PUSH
15725: LD_INT 25
15727: PUSH
15728: LD_INT 5
15730: PUSH
15731: EMPTY
15732: LIST
15733: LIST
15734: PUSH
15735: LD_INT 25
15737: PUSH
15738: LD_INT 8
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 25
15747: PUSH
15748: LD_INT 9
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: EMPTY
15756: LIST
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: PPUSH
15762: CALL_OW 72
15766: ST_TO_ADDR
// if not defenders and not solds then
15767: LD_VAR 0 2
15771: NOT
15772: PUSH
15773: LD_VAR 0 8
15777: NOT
15778: AND
15779: IFFALSE 15783
// exit ;
15781: GO 17149
// depot_under_attack := false ;
15783: LD_ADDR_VAR 0 16
15787: PUSH
15788: LD_INT 0
15790: ST_TO_ADDR
// sold_defenders := [ ] ;
15791: LD_ADDR_VAR 0 17
15795: PUSH
15796: EMPTY
15797: ST_TO_ADDR
// if mechs then
15798: LD_VAR 0 12
15802: IFFALSE 15931
// for i in defenders do
15804: LD_ADDR_VAR 0 5
15808: PUSH
15809: LD_VAR 0 2
15813: PUSH
15814: FOR_IN
15815: IFFALSE 15929
// begin SetTag ( i , 20 ) ;
15817: LD_VAR 0 5
15821: PPUSH
15822: LD_INT 20
15824: PPUSH
15825: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
15829: LD_VAR 0 5
15833: PPUSH
15834: CALL_OW 263
15838: PUSH
15839: LD_INT 1
15841: EQUAL
15842: PUSH
15843: LD_VAR 0 5
15847: PPUSH
15848: CALL_OW 311
15852: NOT
15853: AND
15854: PUSH
15855: LD_VAR 0 12
15859: AND
15860: IFFALSE 15927
// begin un := mechs [ 1 ] ;
15862: LD_ADDR_VAR 0 10
15866: PUSH
15867: LD_VAR 0 12
15871: PUSH
15872: LD_INT 1
15874: ARRAY
15875: ST_TO_ADDR
// ComExitBuilding ( un ) ;
15876: LD_VAR 0 10
15880: PPUSH
15881: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
15885: LD_VAR 0 10
15889: PPUSH
15890: LD_VAR 0 5
15894: PPUSH
15895: CALL_OW 180
// SetTag ( un , 19 ) ;
15899: LD_VAR 0 10
15903: PPUSH
15904: LD_INT 19
15906: PPUSH
15907: CALL_OW 109
// mechs := mechs diff un ;
15911: LD_ADDR_VAR 0 12
15915: PUSH
15916: LD_VAR 0 12
15920: PUSH
15921: LD_VAR 0 10
15925: DIFF
15926: ST_TO_ADDR
// end ; end ;
15927: GO 15814
15929: POP
15930: POP
// if solds then
15931: LD_VAR 0 8
15935: IFFALSE 15994
// for i in solds do
15937: LD_ADDR_VAR 0 5
15941: PUSH
15942: LD_VAR 0 8
15946: PUSH
15947: FOR_IN
15948: IFFALSE 15992
// if not GetTag ( i ) then
15950: LD_VAR 0 5
15954: PPUSH
15955: CALL_OW 110
15959: NOT
15960: IFFALSE 15990
// begin defenders := defenders union i ;
15962: LD_ADDR_VAR 0 2
15966: PUSH
15967: LD_VAR 0 2
15971: PUSH
15972: LD_VAR 0 5
15976: UNION
15977: ST_TO_ADDR
// SetTag ( i , 18 ) ;
15978: LD_VAR 0 5
15982: PPUSH
15983: LD_INT 18
15985: PPUSH
15986: CALL_OW 109
// end ;
15990: GO 15947
15992: POP
15993: POP
// repeat wait ( 0 0$1 ) ;
15994: LD_INT 35
15996: PPUSH
15997: CALL_OW 67
// enemy := mc_scan [ base ] ;
16001: LD_ADDR_VAR 0 3
16005: PUSH
16006: LD_EXP 81
16010: PUSH
16011: LD_VAR 0 1
16015: ARRAY
16016: ST_TO_ADDR
// for i in defenders do
16017: LD_ADDR_VAR 0 5
16021: PUSH
16022: LD_VAR 0 2
16026: PUSH
16027: FOR_IN
16028: IFFALSE 16713
// begin e := NearestUnitToUnit ( enemy , i ) ;
16030: LD_ADDR_VAR 0 13
16034: PUSH
16035: LD_VAR 0 3
16039: PPUSH
16040: LD_VAR 0 5
16044: PPUSH
16045: CALL_OW 74
16049: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16050: LD_ADDR_VAR 0 16
16054: PUSH
16055: LD_EXP 58
16059: PUSH
16060: LD_VAR 0 1
16064: ARRAY
16065: PPUSH
16066: LD_INT 2
16068: PUSH
16069: LD_INT 30
16071: PUSH
16072: LD_INT 0
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: PUSH
16079: LD_INT 30
16081: PUSH
16082: LD_INT 1
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: LIST
16093: PPUSH
16094: CALL_OW 72
16098: NOT
16099: PUSH
16100: LD_EXP 58
16104: PUSH
16105: LD_VAR 0 1
16109: ARRAY
16110: PPUSH
16111: LD_INT 2
16113: PUSH
16114: LD_INT 30
16116: PUSH
16117: LD_INT 0
16119: PUSH
16120: EMPTY
16121: LIST
16122: LIST
16123: PUSH
16124: LD_INT 30
16126: PUSH
16127: LD_INT 1
16129: PUSH
16130: EMPTY
16131: LIST
16132: LIST
16133: PUSH
16134: EMPTY
16135: LIST
16136: LIST
16137: LIST
16138: PPUSH
16139: CALL_OW 72
16143: PPUSH
16144: CALL_OW 256
16148: PUSH
16149: LD_INT 600
16151: LESS
16152: OR
16153: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16154: LD_VAR 0 5
16158: PPUSH
16159: CALL_OW 247
16163: PUSH
16164: LD_INT 2
16166: DOUBLE
16167: EQUAL
16168: IFTRUE 16172
16170: GO 16419
16172: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16173: LD_VAR 0 5
16177: PPUSH
16178: CALL_OW 256
16182: PUSH
16183: LD_INT 650
16185: GREATER
16186: PUSH
16187: LD_VAR 0 5
16191: PPUSH
16192: LD_VAR 0 13
16196: PPUSH
16197: CALL_OW 296
16201: PUSH
16202: LD_INT 40
16204: LESS
16205: AND
16206: IFFALSE 16224
// ComAttackUnit ( i , e ) else
16208: LD_VAR 0 5
16212: PPUSH
16213: LD_VAR 0 13
16217: PPUSH
16218: CALL_OW 115
16222: GO 16302
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16224: LD_VAR 0 5
16228: PPUSH
16229: LD_VAR 0 13
16233: PPUSH
16234: CALL_OW 296
16238: PUSH
16239: LD_INT 30
16241: GREATEREQUAL
16242: PUSH
16243: LD_VAR 0 5
16247: PPUSH
16248: CALL_OW 256
16252: PUSH
16253: LD_INT 650
16255: LESSEQUAL
16256: OR
16257: PUSH
16258: LD_VAR 0 5
16262: PPUSH
16263: LD_EXP 82
16267: PUSH
16268: LD_VAR 0 1
16272: ARRAY
16273: PPUSH
16274: CALL_OW 308
16278: NOT
16279: AND
16280: IFFALSE 16302
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16282: LD_VAR 0 5
16286: PPUSH
16287: LD_EXP 82
16291: PUSH
16292: LD_VAR 0 1
16296: ARRAY
16297: PPUSH
16298: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16302: LD_VAR 0 5
16306: PPUSH
16307: CALL_OW 256
16311: PUSH
16312: LD_INT 998
16314: LESS
16315: PUSH
16316: LD_VAR 0 5
16320: PPUSH
16321: CALL_OW 263
16325: PUSH
16326: LD_INT 1
16328: EQUAL
16329: AND
16330: PUSH
16331: LD_VAR 0 5
16335: PPUSH
16336: CALL_OW 311
16340: AND
16341: PUSH
16342: LD_VAR 0 5
16346: PPUSH
16347: LD_EXP 82
16351: PUSH
16352: LD_VAR 0 1
16356: ARRAY
16357: PPUSH
16358: CALL_OW 308
16362: AND
16363: IFFALSE 16417
// begin mech := IsDrivenBy ( i ) ;
16365: LD_ADDR_VAR 0 9
16369: PUSH
16370: LD_VAR 0 5
16374: PPUSH
16375: CALL_OW 311
16379: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16380: LD_VAR 0 9
16384: PPUSH
16385: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16389: LD_VAR 0 9
16393: PPUSH
16394: LD_VAR 0 5
16398: PPUSH
16399: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16403: LD_VAR 0 9
16407: PPUSH
16408: LD_VAR 0 5
16412: PPUSH
16413: CALL_OW 180
// end ; end ; unit_human :
16417: GO 16684
16419: LD_INT 1
16421: DOUBLE
16422: EQUAL
16423: IFTRUE 16427
16425: GO 16683
16427: POP
// begin b := IsInUnit ( i ) ;
16428: LD_ADDR_VAR 0 18
16432: PUSH
16433: LD_VAR 0 5
16437: PPUSH
16438: CALL_OW 310
16442: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16443: LD_ADDR_VAR 0 19
16447: PUSH
16448: LD_VAR 0 18
16452: NOT
16453: PUSH
16454: LD_VAR 0 18
16458: PPUSH
16459: CALL_OW 266
16463: PUSH
16464: LD_INT 32
16466: PUSH
16467: LD_INT 31
16469: PUSH
16470: EMPTY
16471: LIST
16472: LIST
16473: IN
16474: OR
16475: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16476: LD_VAR 0 16
16480: PUSH
16481: LD_VAR 0 2
16485: PPUSH
16486: LD_INT 21
16488: PUSH
16489: LD_INT 2
16491: PUSH
16492: EMPTY
16493: LIST
16494: LIST
16495: PPUSH
16496: CALL_OW 72
16500: PUSH
16501: LD_INT 1
16503: LESSEQUAL
16504: OR
16505: PUSH
16506: LD_VAR 0 19
16510: AND
16511: PUSH
16512: LD_VAR 0 5
16516: PUSH
16517: LD_VAR 0 17
16521: IN
16522: NOT
16523: AND
16524: IFFALSE 16617
// begin if b then
16526: LD_VAR 0 18
16530: IFFALSE 16579
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16532: LD_VAR 0 18
16536: PPUSH
16537: LD_VAR 0 3
16541: PPUSH
16542: LD_VAR 0 18
16546: PPUSH
16547: CALL_OW 74
16551: PPUSH
16552: CALL_OW 296
16556: PUSH
16557: LD_INT 10
16559: LESS
16560: PUSH
16561: LD_VAR 0 18
16565: PPUSH
16566: CALL_OW 461
16570: PUSH
16571: LD_INT 7
16573: NONEQUAL
16574: AND
16575: IFFALSE 16579
// continue ;
16577: GO 16027
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16579: LD_ADDR_VAR 0 17
16583: PUSH
16584: LD_VAR 0 17
16588: PPUSH
16589: LD_VAR 0 17
16593: PUSH
16594: LD_INT 1
16596: PLUS
16597: PPUSH
16598: LD_VAR 0 5
16602: PPUSH
16603: CALL_OW 1
16607: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16608: LD_VAR 0 5
16612: PPUSH
16613: CALL_OW 122
// end ; if sold_defenders then
16617: LD_VAR 0 17
16621: IFFALSE 16681
// if i in sold_defenders then
16623: LD_VAR 0 5
16627: PUSH
16628: LD_VAR 0 17
16632: IN
16633: IFFALSE 16681
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16635: LD_VAR 0 5
16639: PPUSH
16640: CALL_OW 314
16644: NOT
16645: PUSH
16646: LD_VAR 0 5
16650: PPUSH
16651: LD_VAR 0 13
16655: PPUSH
16656: CALL_OW 296
16660: PUSH
16661: LD_INT 30
16663: LESS
16664: AND
16665: IFFALSE 16681
// ComAttackUnit ( i , e ) ;
16667: LD_VAR 0 5
16671: PPUSH
16672: LD_VAR 0 13
16676: PPUSH
16677: CALL_OW 115
// end ; end ; end ;
16681: GO 16684
16683: POP
// if IsDead ( i ) then
16684: LD_VAR 0 5
16688: PPUSH
16689: CALL_OW 301
16693: IFFALSE 16711
// defenders := defenders diff i ;
16695: LD_ADDR_VAR 0 2
16699: PUSH
16700: LD_VAR 0 2
16704: PUSH
16705: LD_VAR 0 5
16709: DIFF
16710: ST_TO_ADDR
// end ;
16711: GO 16027
16713: POP
16714: POP
// until not enemy or not defenders ;
16715: LD_VAR 0 3
16719: NOT
16720: PUSH
16721: LD_VAR 0 2
16725: NOT
16726: OR
16727: IFFALSE 15994
// MC_Reset ( base , 18 ) ;
16729: LD_VAR 0 1
16733: PPUSH
16734: LD_INT 18
16736: PPUSH
16737: CALL 58609 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16741: LD_ADDR_VAR 0 2
16745: PUSH
16746: LD_VAR 0 2
16750: PUSH
16751: LD_VAR 0 2
16755: PPUSH
16756: LD_INT 2
16758: PUSH
16759: LD_INT 25
16761: PUSH
16762: LD_INT 1
16764: PUSH
16765: EMPTY
16766: LIST
16767: LIST
16768: PUSH
16769: LD_INT 25
16771: PUSH
16772: LD_INT 5
16774: PUSH
16775: EMPTY
16776: LIST
16777: LIST
16778: PUSH
16779: LD_INT 25
16781: PUSH
16782: LD_INT 8
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 9
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: LIST
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 72
16810: DIFF
16811: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
16812: LD_VAR 0 3
16816: NOT
16817: PUSH
16818: LD_VAR 0 2
16822: PPUSH
16823: LD_INT 21
16825: PUSH
16826: LD_INT 2
16828: PUSH
16829: EMPTY
16830: LIST
16831: LIST
16832: PPUSH
16833: CALL_OW 72
16837: AND
16838: IFFALSE 17100
// begin tmp := FilterByTag ( defenders , 19 ) ;
16840: LD_ADDR_VAR 0 11
16844: PUSH
16845: LD_VAR 0 2
16849: PPUSH
16850: LD_INT 19
16852: PPUSH
16853: CALL 53265 0 2
16857: ST_TO_ADDR
// if tmp then
16858: LD_VAR 0 11
16862: IFFALSE 16932
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
16864: LD_ADDR_VAR 0 11
16868: PUSH
16869: LD_VAR 0 11
16873: PPUSH
16874: LD_INT 25
16876: PUSH
16877: LD_INT 3
16879: PUSH
16880: EMPTY
16881: LIST
16882: LIST
16883: PPUSH
16884: CALL_OW 72
16888: ST_TO_ADDR
// if tmp then
16889: LD_VAR 0 11
16893: IFFALSE 16932
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
16895: LD_ADDR_EXP 70
16899: PUSH
16900: LD_EXP 70
16904: PPUSH
16905: LD_VAR 0 1
16909: PPUSH
16910: LD_EXP 70
16914: PUSH
16915: LD_VAR 0 1
16919: ARRAY
16920: PUSH
16921: LD_VAR 0 11
16925: UNION
16926: PPUSH
16927: CALL_OW 1
16931: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
16932: LD_VAR 0 1
16936: PPUSH
16937: LD_INT 19
16939: PPUSH
16940: CALL 58609 0 2
// repeat wait ( 0 0$1 ) ;
16944: LD_INT 35
16946: PPUSH
16947: CALL_OW 67
// for i in defenders do
16951: LD_ADDR_VAR 0 5
16955: PUSH
16956: LD_VAR 0 2
16960: PUSH
16961: FOR_IN
16962: IFFALSE 17051
// begin if not IsInArea ( i , mc_parking [ base ] ) then
16964: LD_VAR 0 5
16968: PPUSH
16969: LD_EXP 82
16973: PUSH
16974: LD_VAR 0 1
16978: ARRAY
16979: PPUSH
16980: CALL_OW 308
16984: NOT
16985: IFFALSE 17009
// ComMoveToArea ( i , mc_parking [ base ] ) else
16987: LD_VAR 0 5
16991: PPUSH
16992: LD_EXP 82
16996: PUSH
16997: LD_VAR 0 1
17001: ARRAY
17002: PPUSH
17003: CALL_OW 113
17007: GO 17049
// if GetControl ( i ) = control_manual then
17009: LD_VAR 0 5
17013: PPUSH
17014: CALL_OW 263
17018: PUSH
17019: LD_INT 1
17021: EQUAL
17022: IFFALSE 17049
// if IsDrivenBy ( i ) then
17024: LD_VAR 0 5
17028: PPUSH
17029: CALL_OW 311
17033: IFFALSE 17049
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17035: LD_VAR 0 5
17039: PPUSH
17040: CALL_OW 311
17044: PPUSH
17045: CALL_OW 121
// end ;
17049: GO 16961
17051: POP
17052: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17053: LD_VAR 0 2
17057: PPUSH
17058: LD_INT 95
17060: PUSH
17061: LD_EXP 82
17065: PUSH
17066: LD_VAR 0 1
17070: ARRAY
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PPUSH
17076: CALL_OW 72
17080: PUSH
17081: LD_VAR 0 2
17085: EQUAL
17086: PUSH
17087: LD_EXP 81
17091: PUSH
17092: LD_VAR 0 1
17096: ARRAY
17097: OR
17098: IFFALSE 16944
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17100: LD_ADDR_EXP 80
17104: PUSH
17105: LD_EXP 80
17109: PPUSH
17110: LD_VAR 0 1
17114: PPUSH
17115: LD_EXP 80
17119: PUSH
17120: LD_VAR 0 1
17124: ARRAY
17125: PUSH
17126: LD_VAR 0 2
17130: UNION
17131: PPUSH
17132: CALL_OW 1
17136: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17137: LD_VAR 0 1
17141: PPUSH
17142: LD_INT 20
17144: PPUSH
17145: CALL 58609 0 2
// end ;
17149: LD_VAR 0 4
17153: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17154: LD_INT 0
17156: PPUSH
17157: PPUSH
17158: PPUSH
17159: PPUSH
// result := false ;
17160: LD_ADDR_VAR 0 2
17164: PUSH
17165: LD_INT 0
17167: ST_TO_ADDR
// side := GetSide ( unit ) ;
17168: LD_ADDR_VAR 0 3
17172: PUSH
17173: LD_VAR 0 1
17177: PPUSH
17178: CALL_OW 255
17182: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17183: LD_ADDR_VAR 0 4
17187: PUSH
17188: LD_VAR 0 1
17192: PPUSH
17193: CALL_OW 248
17197: ST_TO_ADDR
// case nat of 1 :
17198: LD_VAR 0 4
17202: PUSH
17203: LD_INT 1
17205: DOUBLE
17206: EQUAL
17207: IFTRUE 17211
17209: GO 17222
17211: POP
// tech := tech_lassight ; 2 :
17212: LD_ADDR_VAR 0 5
17216: PUSH
17217: LD_INT 12
17219: ST_TO_ADDR
17220: GO 17261
17222: LD_INT 2
17224: DOUBLE
17225: EQUAL
17226: IFTRUE 17230
17228: GO 17241
17230: POP
// tech := tech_mortar ; 3 :
17231: LD_ADDR_VAR 0 5
17235: PUSH
17236: LD_INT 41
17238: ST_TO_ADDR
17239: GO 17261
17241: LD_INT 3
17243: DOUBLE
17244: EQUAL
17245: IFTRUE 17249
17247: GO 17260
17249: POP
// tech := tech_bazooka ; end ;
17250: LD_ADDR_VAR 0 5
17254: PUSH
17255: LD_INT 44
17257: ST_TO_ADDR
17258: GO 17261
17260: POP
// if Researched ( side , tech ) then
17261: LD_VAR 0 3
17265: PPUSH
17266: LD_VAR 0 5
17270: PPUSH
17271: CALL_OW 325
17275: IFFALSE 17302
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17277: LD_ADDR_VAR 0 2
17281: PUSH
17282: LD_INT 5
17284: PUSH
17285: LD_INT 8
17287: PUSH
17288: LD_INT 9
17290: PUSH
17291: EMPTY
17292: LIST
17293: LIST
17294: LIST
17295: PUSH
17296: LD_VAR 0 4
17300: ARRAY
17301: ST_TO_ADDR
// end ;
17302: LD_VAR 0 2
17306: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17307: LD_INT 0
17309: PPUSH
17310: PPUSH
17311: PPUSH
// if not mines then
17312: LD_VAR 0 2
17316: NOT
17317: IFFALSE 17321
// exit ;
17319: GO 17465
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17321: LD_ADDR_VAR 0 5
17325: PUSH
17326: LD_INT 81
17328: PUSH
17329: LD_VAR 0 1
17333: PUSH
17334: EMPTY
17335: LIST
17336: LIST
17337: PUSH
17338: LD_INT 3
17340: PUSH
17341: LD_INT 21
17343: PUSH
17344: LD_INT 3
17346: PUSH
17347: EMPTY
17348: LIST
17349: LIST
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: PUSH
17355: EMPTY
17356: LIST
17357: LIST
17358: PPUSH
17359: CALL_OW 69
17363: ST_TO_ADDR
// for i in mines do
17364: LD_ADDR_VAR 0 4
17368: PUSH
17369: LD_VAR 0 2
17373: PUSH
17374: FOR_IN
17375: IFFALSE 17463
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17377: LD_VAR 0 4
17381: PUSH
17382: LD_INT 1
17384: ARRAY
17385: PPUSH
17386: LD_VAR 0 4
17390: PUSH
17391: LD_INT 2
17393: ARRAY
17394: PPUSH
17395: CALL_OW 458
17399: NOT
17400: IFFALSE 17404
// continue ;
17402: GO 17374
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17404: LD_VAR 0 4
17408: PUSH
17409: LD_INT 1
17411: ARRAY
17412: PPUSH
17413: LD_VAR 0 4
17417: PUSH
17418: LD_INT 2
17420: ARRAY
17421: PPUSH
17422: CALL_OW 428
17426: PUSH
17427: LD_VAR 0 5
17431: IN
17432: IFFALSE 17461
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17434: LD_VAR 0 4
17438: PUSH
17439: LD_INT 1
17441: ARRAY
17442: PPUSH
17443: LD_VAR 0 4
17447: PUSH
17448: LD_INT 2
17450: ARRAY
17451: PPUSH
17452: LD_VAR 0 1
17456: PPUSH
17457: CALL_OW 456
// end ;
17461: GO 17374
17463: POP
17464: POP
// end ;
17465: LD_VAR 0 3
17469: RET
// export function Count ( array ) ; var i ; begin
17470: LD_INT 0
17472: PPUSH
17473: PPUSH
// result := 0 ;
17474: LD_ADDR_VAR 0 2
17478: PUSH
17479: LD_INT 0
17481: ST_TO_ADDR
// for i in array do
17482: LD_ADDR_VAR 0 3
17486: PUSH
17487: LD_VAR 0 1
17491: PUSH
17492: FOR_IN
17493: IFFALSE 17517
// if i then
17495: LD_VAR 0 3
17499: IFFALSE 17515
// result := result + 1 ;
17501: LD_ADDR_VAR 0 2
17505: PUSH
17506: LD_VAR 0 2
17510: PUSH
17511: LD_INT 1
17513: PLUS
17514: ST_TO_ADDR
17515: GO 17492
17517: POP
17518: POP
// end ;
17519: LD_VAR 0 2
17523: RET
// export function IsEmpty ( building ) ; begin
17524: LD_INT 0
17526: PPUSH
// if not building then
17527: LD_VAR 0 1
17531: NOT
17532: IFFALSE 17536
// exit ;
17534: GO 17579
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17536: LD_ADDR_VAR 0 2
17540: PUSH
17541: LD_VAR 0 1
17545: PUSH
17546: LD_INT 22
17548: PUSH
17549: LD_VAR 0 1
17553: PPUSH
17554: CALL_OW 255
17558: PUSH
17559: EMPTY
17560: LIST
17561: LIST
17562: PUSH
17563: LD_INT 58
17565: PUSH
17566: EMPTY
17567: LIST
17568: PUSH
17569: EMPTY
17570: LIST
17571: LIST
17572: PPUSH
17573: CALL_OW 69
17577: IN
17578: ST_TO_ADDR
// end ;
17579: LD_VAR 0 2
17583: RET
// export function IsNotFull ( building ) ; begin
17584: LD_INT 0
17586: PPUSH
// if not building then
17587: LD_VAR 0 1
17591: NOT
17592: IFFALSE 17596
// exit ;
17594: GO 17615
// result := UnitsInside ( building ) < 6 ;
17596: LD_ADDR_VAR 0 2
17600: PUSH
17601: LD_VAR 0 1
17605: PPUSH
17606: CALL_OW 313
17610: PUSH
17611: LD_INT 6
17613: LESS
17614: ST_TO_ADDR
// end ;
17615: LD_VAR 0 2
17619: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17620: LD_INT 0
17622: PPUSH
17623: PPUSH
17624: PPUSH
17625: PPUSH
// tmp := [ ] ;
17626: LD_ADDR_VAR 0 3
17630: PUSH
17631: EMPTY
17632: ST_TO_ADDR
// list := [ ] ;
17633: LD_ADDR_VAR 0 5
17637: PUSH
17638: EMPTY
17639: ST_TO_ADDR
// for i = 16 to 25 do
17640: LD_ADDR_VAR 0 4
17644: PUSH
17645: DOUBLE
17646: LD_INT 16
17648: DEC
17649: ST_TO_ADDR
17650: LD_INT 25
17652: PUSH
17653: FOR_TO
17654: IFFALSE 17727
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17656: LD_ADDR_VAR 0 3
17660: PUSH
17661: LD_VAR 0 3
17665: PUSH
17666: LD_INT 22
17668: PUSH
17669: LD_VAR 0 1
17673: PPUSH
17674: CALL_OW 255
17678: PUSH
17679: EMPTY
17680: LIST
17681: LIST
17682: PUSH
17683: LD_INT 91
17685: PUSH
17686: LD_VAR 0 1
17690: PUSH
17691: LD_INT 6
17693: PUSH
17694: EMPTY
17695: LIST
17696: LIST
17697: LIST
17698: PUSH
17699: LD_INT 30
17701: PUSH
17702: LD_VAR 0 4
17706: PUSH
17707: EMPTY
17708: LIST
17709: LIST
17710: PUSH
17711: EMPTY
17712: LIST
17713: LIST
17714: LIST
17715: PUSH
17716: EMPTY
17717: LIST
17718: PPUSH
17719: CALL_OW 69
17723: ADD
17724: ST_TO_ADDR
17725: GO 17653
17727: POP
17728: POP
// for i = 1 to tmp do
17729: LD_ADDR_VAR 0 4
17733: PUSH
17734: DOUBLE
17735: LD_INT 1
17737: DEC
17738: ST_TO_ADDR
17739: LD_VAR 0 3
17743: PUSH
17744: FOR_TO
17745: IFFALSE 17833
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17747: LD_ADDR_VAR 0 5
17751: PUSH
17752: LD_VAR 0 5
17756: PUSH
17757: LD_VAR 0 3
17761: PUSH
17762: LD_VAR 0 4
17766: ARRAY
17767: PPUSH
17768: CALL_OW 266
17772: PUSH
17773: LD_VAR 0 3
17777: PUSH
17778: LD_VAR 0 4
17782: ARRAY
17783: PPUSH
17784: CALL_OW 250
17788: PUSH
17789: LD_VAR 0 3
17793: PUSH
17794: LD_VAR 0 4
17798: ARRAY
17799: PPUSH
17800: CALL_OW 251
17804: PUSH
17805: LD_VAR 0 3
17809: PUSH
17810: LD_VAR 0 4
17814: ARRAY
17815: PPUSH
17816: CALL_OW 254
17820: PUSH
17821: EMPTY
17822: LIST
17823: LIST
17824: LIST
17825: LIST
17826: PUSH
17827: EMPTY
17828: LIST
17829: ADD
17830: ST_TO_ADDR
17831: GO 17744
17833: POP
17834: POP
// result := list ;
17835: LD_ADDR_VAR 0 2
17839: PUSH
17840: LD_VAR 0 5
17844: ST_TO_ADDR
// end ;
17845: LD_VAR 0 2
17849: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17850: LD_INT 0
17852: PPUSH
17853: PPUSH
17854: PPUSH
17855: PPUSH
17856: PPUSH
17857: PPUSH
17858: PPUSH
// if not factory then
17859: LD_VAR 0 1
17863: NOT
17864: IFFALSE 17868
// exit ;
17866: GO 18393
// if control = control_apeman then
17868: LD_VAR 0 4
17872: PUSH
17873: LD_INT 5
17875: EQUAL
17876: IFFALSE 17985
// begin tmp := UnitsInside ( factory ) ;
17878: LD_ADDR_VAR 0 8
17882: PUSH
17883: LD_VAR 0 1
17887: PPUSH
17888: CALL_OW 313
17892: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17893: LD_VAR 0 8
17897: PPUSH
17898: LD_INT 25
17900: PUSH
17901: LD_INT 12
17903: PUSH
17904: EMPTY
17905: LIST
17906: LIST
17907: PPUSH
17908: CALL_OW 72
17912: NOT
17913: IFFALSE 17923
// control := control_manual ;
17915: LD_ADDR_VAR 0 4
17919: PUSH
17920: LD_INT 1
17922: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17923: LD_ADDR_VAR 0 8
17927: PUSH
17928: LD_VAR 0 1
17932: PPUSH
17933: CALL 17620 0 1
17937: ST_TO_ADDR
// if tmp then
17938: LD_VAR 0 8
17942: IFFALSE 17985
// begin for i in tmp do
17944: LD_ADDR_VAR 0 7
17948: PUSH
17949: LD_VAR 0 8
17953: PUSH
17954: FOR_IN
17955: IFFALSE 17983
// if i [ 1 ] = b_ext_radar then
17957: LD_VAR 0 7
17961: PUSH
17962: LD_INT 1
17964: ARRAY
17965: PUSH
17966: LD_INT 20
17968: EQUAL
17969: IFFALSE 17981
// begin control := control_remote ;
17971: LD_ADDR_VAR 0 4
17975: PUSH
17976: LD_INT 2
17978: ST_TO_ADDR
// break ;
17979: GO 17983
// end ;
17981: GO 17954
17983: POP
17984: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17985: LD_VAR 0 1
17989: PPUSH
17990: LD_VAR 0 2
17994: PPUSH
17995: LD_VAR 0 3
17999: PPUSH
18000: LD_VAR 0 4
18004: PPUSH
18005: LD_VAR 0 5
18009: PPUSH
18010: CALL_OW 448
18014: IFFALSE 18049
// begin result := [ chassis , engine , control , weapon ] ;
18016: LD_ADDR_VAR 0 6
18020: PUSH
18021: LD_VAR 0 2
18025: PUSH
18026: LD_VAR 0 3
18030: PUSH
18031: LD_VAR 0 4
18035: PUSH
18036: LD_VAR 0 5
18040: PUSH
18041: EMPTY
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: ST_TO_ADDR
// exit ;
18047: GO 18393
// end ; _chassis := AvailableChassisList ( factory ) ;
18049: LD_ADDR_VAR 0 9
18053: PUSH
18054: LD_VAR 0 1
18058: PPUSH
18059: CALL_OW 475
18063: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18064: LD_ADDR_VAR 0 11
18068: PUSH
18069: LD_VAR 0 1
18073: PPUSH
18074: CALL_OW 476
18078: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18079: LD_ADDR_VAR 0 12
18083: PUSH
18084: LD_VAR 0 1
18088: PPUSH
18089: CALL_OW 477
18093: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18094: LD_ADDR_VAR 0 10
18098: PUSH
18099: LD_VAR 0 1
18103: PPUSH
18104: CALL_OW 478
18108: ST_TO_ADDR
// if not chassis in _chassis then
18109: LD_VAR 0 2
18113: PUSH
18114: LD_VAR 0 9
18118: IN
18119: NOT
18120: IFFALSE 18146
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18122: LD_ADDR_VAR 0 2
18126: PUSH
18127: LD_VAR 0 9
18131: PUSH
18132: LD_INT 1
18134: PPUSH
18135: LD_VAR 0 9
18139: PPUSH
18140: CALL_OW 12
18144: ARRAY
18145: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18146: LD_VAR 0 2
18150: PPUSH
18151: LD_VAR 0 3
18155: PPUSH
18156: CALL 18398 0 2
18160: NOT
18161: IFFALSE 18220
// repeat engine := _engine [ 1 ] ;
18163: LD_ADDR_VAR 0 3
18167: PUSH
18168: LD_VAR 0 11
18172: PUSH
18173: LD_INT 1
18175: ARRAY
18176: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18177: LD_ADDR_VAR 0 11
18181: PUSH
18182: LD_VAR 0 11
18186: PPUSH
18187: LD_INT 1
18189: PPUSH
18190: CALL_OW 3
18194: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18195: LD_VAR 0 2
18199: PPUSH
18200: LD_VAR 0 3
18204: PPUSH
18205: CALL 18398 0 2
18209: PUSH
18210: LD_VAR 0 11
18214: PUSH
18215: EMPTY
18216: EQUAL
18217: OR
18218: IFFALSE 18163
// if not control in _control then
18220: LD_VAR 0 4
18224: PUSH
18225: LD_VAR 0 12
18229: IN
18230: NOT
18231: IFFALSE 18257
// control := _control [ rand ( 1 , _control ) ] ;
18233: LD_ADDR_VAR 0 4
18237: PUSH
18238: LD_VAR 0 12
18242: PUSH
18243: LD_INT 1
18245: PPUSH
18246: LD_VAR 0 12
18250: PPUSH
18251: CALL_OW 12
18255: ARRAY
18256: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18257: LD_VAR 0 2
18261: PPUSH
18262: LD_VAR 0 5
18266: PPUSH
18267: CALL 18618 0 2
18271: NOT
18272: IFFALSE 18331
// repeat weapon := _weapon [ 1 ] ;
18274: LD_ADDR_VAR 0 5
18278: PUSH
18279: LD_VAR 0 10
18283: PUSH
18284: LD_INT 1
18286: ARRAY
18287: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18288: LD_ADDR_VAR 0 10
18292: PUSH
18293: LD_VAR 0 10
18297: PPUSH
18298: LD_INT 1
18300: PPUSH
18301: CALL_OW 3
18305: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18306: LD_VAR 0 2
18310: PPUSH
18311: LD_VAR 0 5
18315: PPUSH
18316: CALL 18618 0 2
18320: PUSH
18321: LD_VAR 0 10
18325: PUSH
18326: EMPTY
18327: EQUAL
18328: OR
18329: IFFALSE 18274
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18331: LD_VAR 0 1
18335: PPUSH
18336: LD_VAR 0 2
18340: PPUSH
18341: LD_VAR 0 3
18345: PPUSH
18346: LD_VAR 0 4
18350: PPUSH
18351: LD_VAR 0 5
18355: PPUSH
18356: CALL_OW 448
18360: IFFALSE 18393
// result := [ chassis , engine , control , weapon ] ;
18362: LD_ADDR_VAR 0 6
18366: PUSH
18367: LD_VAR 0 2
18371: PUSH
18372: LD_VAR 0 3
18376: PUSH
18377: LD_VAR 0 4
18381: PUSH
18382: LD_VAR 0 5
18386: PUSH
18387: EMPTY
18388: LIST
18389: LIST
18390: LIST
18391: LIST
18392: ST_TO_ADDR
// end ;
18393: LD_VAR 0 6
18397: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18398: LD_INT 0
18400: PPUSH
// if not chassis or not engine then
18401: LD_VAR 0 1
18405: NOT
18406: PUSH
18407: LD_VAR 0 2
18411: NOT
18412: OR
18413: IFFALSE 18417
// exit ;
18415: GO 18613
// case engine of engine_solar :
18417: LD_VAR 0 2
18421: PUSH
18422: LD_INT 2
18424: DOUBLE
18425: EQUAL
18426: IFTRUE 18430
18428: GO 18468
18430: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18431: LD_ADDR_VAR 0 3
18435: PUSH
18436: LD_INT 11
18438: PUSH
18439: LD_INT 12
18441: PUSH
18442: LD_INT 13
18444: PUSH
18445: LD_INT 14
18447: PUSH
18448: LD_INT 1
18450: PUSH
18451: LD_INT 2
18453: PUSH
18454: LD_INT 3
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: LIST
18465: ST_TO_ADDR
18466: GO 18597
18468: LD_INT 1
18470: DOUBLE
18471: EQUAL
18472: IFTRUE 18476
18474: GO 18538
18476: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18477: LD_ADDR_VAR 0 3
18481: PUSH
18482: LD_INT 11
18484: PUSH
18485: LD_INT 12
18487: PUSH
18488: LD_INT 13
18490: PUSH
18491: LD_INT 14
18493: PUSH
18494: LD_INT 1
18496: PUSH
18497: LD_INT 2
18499: PUSH
18500: LD_INT 3
18502: PUSH
18503: LD_INT 4
18505: PUSH
18506: LD_INT 5
18508: PUSH
18509: LD_INT 21
18511: PUSH
18512: LD_INT 23
18514: PUSH
18515: LD_INT 22
18517: PUSH
18518: LD_INT 24
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: LIST
18525: LIST
18526: LIST
18527: LIST
18528: LIST
18529: LIST
18530: LIST
18531: LIST
18532: LIST
18533: LIST
18534: LIST
18535: ST_TO_ADDR
18536: GO 18597
18538: LD_INT 3
18540: DOUBLE
18541: EQUAL
18542: IFTRUE 18546
18544: GO 18596
18546: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18547: LD_ADDR_VAR 0 3
18551: PUSH
18552: LD_INT 13
18554: PUSH
18555: LD_INT 14
18557: PUSH
18558: LD_INT 2
18560: PUSH
18561: LD_INT 3
18563: PUSH
18564: LD_INT 4
18566: PUSH
18567: LD_INT 5
18569: PUSH
18570: LD_INT 21
18572: PUSH
18573: LD_INT 22
18575: PUSH
18576: LD_INT 23
18578: PUSH
18579: LD_INT 24
18581: PUSH
18582: EMPTY
18583: LIST
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: LIST
18589: LIST
18590: LIST
18591: LIST
18592: LIST
18593: ST_TO_ADDR
18594: GO 18597
18596: POP
// result := ( chassis in result ) ;
18597: LD_ADDR_VAR 0 3
18601: PUSH
18602: LD_VAR 0 1
18606: PUSH
18607: LD_VAR 0 3
18611: IN
18612: ST_TO_ADDR
// end ;
18613: LD_VAR 0 3
18617: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18618: LD_INT 0
18620: PPUSH
// if not chassis or not weapon then
18621: LD_VAR 0 1
18625: NOT
18626: PUSH
18627: LD_VAR 0 2
18631: NOT
18632: OR
18633: IFFALSE 18637
// exit ;
18635: GO 19663
// case weapon of us_machine_gun :
18637: LD_VAR 0 2
18641: PUSH
18642: LD_INT 2
18644: DOUBLE
18645: EQUAL
18646: IFTRUE 18650
18648: GO 18680
18650: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18651: LD_ADDR_VAR 0 3
18655: PUSH
18656: LD_INT 1
18658: PUSH
18659: LD_INT 2
18661: PUSH
18662: LD_INT 3
18664: PUSH
18665: LD_INT 4
18667: PUSH
18668: LD_INT 5
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: LIST
18675: LIST
18676: LIST
18677: ST_TO_ADDR
18678: GO 19647
18680: LD_INT 3
18682: DOUBLE
18683: EQUAL
18684: IFTRUE 18688
18686: GO 18718
18688: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18689: LD_ADDR_VAR 0 3
18693: PUSH
18694: LD_INT 1
18696: PUSH
18697: LD_INT 2
18699: PUSH
18700: LD_INT 3
18702: PUSH
18703: LD_INT 4
18705: PUSH
18706: LD_INT 5
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: LIST
18713: LIST
18714: LIST
18715: ST_TO_ADDR
18716: GO 19647
18718: LD_INT 11
18720: DOUBLE
18721: EQUAL
18722: IFTRUE 18726
18724: GO 18756
18726: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18727: LD_ADDR_VAR 0 3
18731: PUSH
18732: LD_INT 1
18734: PUSH
18735: LD_INT 2
18737: PUSH
18738: LD_INT 3
18740: PUSH
18741: LD_INT 4
18743: PUSH
18744: LD_INT 5
18746: PUSH
18747: EMPTY
18748: LIST
18749: LIST
18750: LIST
18751: LIST
18752: LIST
18753: ST_TO_ADDR
18754: GO 19647
18756: LD_INT 4
18758: DOUBLE
18759: EQUAL
18760: IFTRUE 18764
18762: GO 18790
18764: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18765: LD_ADDR_VAR 0 3
18769: PUSH
18770: LD_INT 2
18772: PUSH
18773: LD_INT 3
18775: PUSH
18776: LD_INT 4
18778: PUSH
18779: LD_INT 5
18781: PUSH
18782: EMPTY
18783: LIST
18784: LIST
18785: LIST
18786: LIST
18787: ST_TO_ADDR
18788: GO 19647
18790: LD_INT 5
18792: DOUBLE
18793: EQUAL
18794: IFTRUE 18798
18796: GO 18824
18798: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18799: LD_ADDR_VAR 0 3
18803: PUSH
18804: LD_INT 2
18806: PUSH
18807: LD_INT 3
18809: PUSH
18810: LD_INT 4
18812: PUSH
18813: LD_INT 5
18815: PUSH
18816: EMPTY
18817: LIST
18818: LIST
18819: LIST
18820: LIST
18821: ST_TO_ADDR
18822: GO 19647
18824: LD_INT 9
18826: DOUBLE
18827: EQUAL
18828: IFTRUE 18832
18830: GO 18858
18832: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18833: LD_ADDR_VAR 0 3
18837: PUSH
18838: LD_INT 2
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: LD_INT 4
18846: PUSH
18847: LD_INT 5
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: ST_TO_ADDR
18856: GO 19647
18858: LD_INT 7
18860: DOUBLE
18861: EQUAL
18862: IFTRUE 18866
18864: GO 18892
18866: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18867: LD_ADDR_VAR 0 3
18871: PUSH
18872: LD_INT 2
18874: PUSH
18875: LD_INT 3
18877: PUSH
18878: LD_INT 4
18880: PUSH
18881: LD_INT 5
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: ST_TO_ADDR
18890: GO 19647
18892: LD_INT 12
18894: DOUBLE
18895: EQUAL
18896: IFTRUE 18900
18898: GO 18926
18900: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18901: LD_ADDR_VAR 0 3
18905: PUSH
18906: LD_INT 2
18908: PUSH
18909: LD_INT 3
18911: PUSH
18912: LD_INT 4
18914: PUSH
18915: LD_INT 5
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: ST_TO_ADDR
18924: GO 19647
18926: LD_INT 13
18928: DOUBLE
18929: EQUAL
18930: IFTRUE 18934
18932: GO 18960
18934: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18935: LD_ADDR_VAR 0 3
18939: PUSH
18940: LD_INT 2
18942: PUSH
18943: LD_INT 3
18945: PUSH
18946: LD_INT 4
18948: PUSH
18949: LD_INT 5
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: LIST
18956: LIST
18957: ST_TO_ADDR
18958: GO 19647
18960: LD_INT 14
18962: DOUBLE
18963: EQUAL
18964: IFTRUE 18968
18966: GO 18986
18968: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18969: LD_ADDR_VAR 0 3
18973: PUSH
18974: LD_INT 4
18976: PUSH
18977: LD_INT 5
18979: PUSH
18980: EMPTY
18981: LIST
18982: LIST
18983: ST_TO_ADDR
18984: GO 19647
18986: LD_INT 6
18988: DOUBLE
18989: EQUAL
18990: IFTRUE 18994
18992: GO 19012
18994: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18995: LD_ADDR_VAR 0 3
18999: PUSH
19000: LD_INT 4
19002: PUSH
19003: LD_INT 5
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: ST_TO_ADDR
19010: GO 19647
19012: LD_INT 10
19014: DOUBLE
19015: EQUAL
19016: IFTRUE 19020
19018: GO 19038
19020: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19021: LD_ADDR_VAR 0 3
19025: PUSH
19026: LD_INT 4
19028: PUSH
19029: LD_INT 5
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: ST_TO_ADDR
19036: GO 19647
19038: LD_INT 22
19040: DOUBLE
19041: EQUAL
19042: IFTRUE 19046
19044: GO 19072
19046: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19047: LD_ADDR_VAR 0 3
19051: PUSH
19052: LD_INT 11
19054: PUSH
19055: LD_INT 12
19057: PUSH
19058: LD_INT 13
19060: PUSH
19061: LD_INT 14
19063: PUSH
19064: EMPTY
19065: LIST
19066: LIST
19067: LIST
19068: LIST
19069: ST_TO_ADDR
19070: GO 19647
19072: LD_INT 23
19074: DOUBLE
19075: EQUAL
19076: IFTRUE 19080
19078: GO 19106
19080: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_INT 11
19088: PUSH
19089: LD_INT 12
19091: PUSH
19092: LD_INT 13
19094: PUSH
19095: LD_INT 14
19097: PUSH
19098: EMPTY
19099: LIST
19100: LIST
19101: LIST
19102: LIST
19103: ST_TO_ADDR
19104: GO 19647
19106: LD_INT 24
19108: DOUBLE
19109: EQUAL
19110: IFTRUE 19114
19112: GO 19140
19114: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19115: LD_ADDR_VAR 0 3
19119: PUSH
19120: LD_INT 11
19122: PUSH
19123: LD_INT 12
19125: PUSH
19126: LD_INT 13
19128: PUSH
19129: LD_INT 14
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: LIST
19136: LIST
19137: ST_TO_ADDR
19138: GO 19647
19140: LD_INT 30
19142: DOUBLE
19143: EQUAL
19144: IFTRUE 19148
19146: GO 19174
19148: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19149: LD_ADDR_VAR 0 3
19153: PUSH
19154: LD_INT 11
19156: PUSH
19157: LD_INT 12
19159: PUSH
19160: LD_INT 13
19162: PUSH
19163: LD_INT 14
19165: PUSH
19166: EMPTY
19167: LIST
19168: LIST
19169: LIST
19170: LIST
19171: ST_TO_ADDR
19172: GO 19647
19174: LD_INT 25
19176: DOUBLE
19177: EQUAL
19178: IFTRUE 19182
19180: GO 19200
19182: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19183: LD_ADDR_VAR 0 3
19187: PUSH
19188: LD_INT 13
19190: PUSH
19191: LD_INT 14
19193: PUSH
19194: EMPTY
19195: LIST
19196: LIST
19197: ST_TO_ADDR
19198: GO 19647
19200: LD_INT 27
19202: DOUBLE
19203: EQUAL
19204: IFTRUE 19208
19206: GO 19226
19208: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19209: LD_ADDR_VAR 0 3
19213: PUSH
19214: LD_INT 13
19216: PUSH
19217: LD_INT 14
19219: PUSH
19220: EMPTY
19221: LIST
19222: LIST
19223: ST_TO_ADDR
19224: GO 19647
19226: LD_INT 28
19228: DOUBLE
19229: EQUAL
19230: IFTRUE 19234
19232: GO 19252
19234: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19235: LD_ADDR_VAR 0 3
19239: PUSH
19240: LD_INT 13
19242: PUSH
19243: LD_INT 14
19245: PUSH
19246: EMPTY
19247: LIST
19248: LIST
19249: ST_TO_ADDR
19250: GO 19647
19252: LD_INT 29
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19278
19260: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19261: LD_ADDR_VAR 0 3
19265: PUSH
19266: LD_INT 13
19268: PUSH
19269: LD_INT 14
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: ST_TO_ADDR
19276: GO 19647
19278: LD_INT 31
19280: DOUBLE
19281: EQUAL
19282: IFTRUE 19286
19284: GO 19304
19286: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19287: LD_ADDR_VAR 0 3
19291: PUSH
19292: LD_INT 13
19294: PUSH
19295: LD_INT 14
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: ST_TO_ADDR
19302: GO 19647
19304: LD_INT 26
19306: DOUBLE
19307: EQUAL
19308: IFTRUE 19312
19310: GO 19330
19312: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19313: LD_ADDR_VAR 0 3
19317: PUSH
19318: LD_INT 13
19320: PUSH
19321: LD_INT 14
19323: PUSH
19324: EMPTY
19325: LIST
19326: LIST
19327: ST_TO_ADDR
19328: GO 19647
19330: LD_INT 42
19332: DOUBLE
19333: EQUAL
19334: IFTRUE 19338
19336: GO 19364
19338: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19339: LD_ADDR_VAR 0 3
19343: PUSH
19344: LD_INT 21
19346: PUSH
19347: LD_INT 22
19349: PUSH
19350: LD_INT 23
19352: PUSH
19353: LD_INT 24
19355: PUSH
19356: EMPTY
19357: LIST
19358: LIST
19359: LIST
19360: LIST
19361: ST_TO_ADDR
19362: GO 19647
19364: LD_INT 43
19366: DOUBLE
19367: EQUAL
19368: IFTRUE 19372
19370: GO 19398
19372: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19373: LD_ADDR_VAR 0 3
19377: PUSH
19378: LD_INT 21
19380: PUSH
19381: LD_INT 22
19383: PUSH
19384: LD_INT 23
19386: PUSH
19387: LD_INT 24
19389: PUSH
19390: EMPTY
19391: LIST
19392: LIST
19393: LIST
19394: LIST
19395: ST_TO_ADDR
19396: GO 19647
19398: LD_INT 44
19400: DOUBLE
19401: EQUAL
19402: IFTRUE 19406
19404: GO 19432
19406: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19407: LD_ADDR_VAR 0 3
19411: PUSH
19412: LD_INT 21
19414: PUSH
19415: LD_INT 22
19417: PUSH
19418: LD_INT 23
19420: PUSH
19421: LD_INT 24
19423: PUSH
19424: EMPTY
19425: LIST
19426: LIST
19427: LIST
19428: LIST
19429: ST_TO_ADDR
19430: GO 19647
19432: LD_INT 45
19434: DOUBLE
19435: EQUAL
19436: IFTRUE 19440
19438: GO 19466
19440: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19441: LD_ADDR_VAR 0 3
19445: PUSH
19446: LD_INT 21
19448: PUSH
19449: LD_INT 22
19451: PUSH
19452: LD_INT 23
19454: PUSH
19455: LD_INT 24
19457: PUSH
19458: EMPTY
19459: LIST
19460: LIST
19461: LIST
19462: LIST
19463: ST_TO_ADDR
19464: GO 19647
19466: LD_INT 49
19468: DOUBLE
19469: EQUAL
19470: IFTRUE 19474
19472: GO 19500
19474: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19475: LD_ADDR_VAR 0 3
19479: PUSH
19480: LD_INT 21
19482: PUSH
19483: LD_INT 22
19485: PUSH
19486: LD_INT 23
19488: PUSH
19489: LD_INT 24
19491: PUSH
19492: EMPTY
19493: LIST
19494: LIST
19495: LIST
19496: LIST
19497: ST_TO_ADDR
19498: GO 19647
19500: LD_INT 51
19502: DOUBLE
19503: EQUAL
19504: IFTRUE 19508
19506: GO 19534
19508: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19509: LD_ADDR_VAR 0 3
19513: PUSH
19514: LD_INT 21
19516: PUSH
19517: LD_INT 22
19519: PUSH
19520: LD_INT 23
19522: PUSH
19523: LD_INT 24
19525: PUSH
19526: EMPTY
19527: LIST
19528: LIST
19529: LIST
19530: LIST
19531: ST_TO_ADDR
19532: GO 19647
19534: LD_INT 52
19536: DOUBLE
19537: EQUAL
19538: IFTRUE 19542
19540: GO 19568
19542: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19543: LD_ADDR_VAR 0 3
19547: PUSH
19548: LD_INT 21
19550: PUSH
19551: LD_INT 22
19553: PUSH
19554: LD_INT 23
19556: PUSH
19557: LD_INT 24
19559: PUSH
19560: EMPTY
19561: LIST
19562: LIST
19563: LIST
19564: LIST
19565: ST_TO_ADDR
19566: GO 19647
19568: LD_INT 53
19570: DOUBLE
19571: EQUAL
19572: IFTRUE 19576
19574: GO 19594
19576: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19577: LD_ADDR_VAR 0 3
19581: PUSH
19582: LD_INT 23
19584: PUSH
19585: LD_INT 24
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: ST_TO_ADDR
19592: GO 19647
19594: LD_INT 46
19596: DOUBLE
19597: EQUAL
19598: IFTRUE 19602
19600: GO 19620
19602: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19603: LD_ADDR_VAR 0 3
19607: PUSH
19608: LD_INT 23
19610: PUSH
19611: LD_INT 24
19613: PUSH
19614: EMPTY
19615: LIST
19616: LIST
19617: ST_TO_ADDR
19618: GO 19647
19620: LD_INT 47
19622: DOUBLE
19623: EQUAL
19624: IFTRUE 19628
19626: GO 19646
19628: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19629: LD_ADDR_VAR 0 3
19633: PUSH
19634: LD_INT 23
19636: PUSH
19637: LD_INT 24
19639: PUSH
19640: EMPTY
19641: LIST
19642: LIST
19643: ST_TO_ADDR
19644: GO 19647
19646: POP
// result := ( chassis in result ) ;
19647: LD_ADDR_VAR 0 3
19651: PUSH
19652: LD_VAR 0 1
19656: PUSH
19657: LD_VAR 0 3
19661: IN
19662: ST_TO_ADDR
// end ;
19663: LD_VAR 0 3
19667: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19668: LD_INT 0
19670: PPUSH
19671: PPUSH
19672: PPUSH
19673: PPUSH
19674: PPUSH
19675: PPUSH
19676: PPUSH
// result := array ;
19677: LD_ADDR_VAR 0 5
19681: PUSH
19682: LD_VAR 0 1
19686: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19687: LD_VAR 0 1
19691: NOT
19692: PUSH
19693: LD_VAR 0 2
19697: NOT
19698: OR
19699: PUSH
19700: LD_VAR 0 3
19704: NOT
19705: OR
19706: PUSH
19707: LD_VAR 0 2
19711: PUSH
19712: LD_VAR 0 1
19716: GREATER
19717: OR
19718: PUSH
19719: LD_VAR 0 3
19723: PUSH
19724: LD_VAR 0 1
19728: GREATER
19729: OR
19730: IFFALSE 19734
// exit ;
19732: GO 20030
// if direction then
19734: LD_VAR 0 4
19738: IFFALSE 19802
// begin d := 1 ;
19740: LD_ADDR_VAR 0 9
19744: PUSH
19745: LD_INT 1
19747: ST_TO_ADDR
// if i_from > i_to then
19748: LD_VAR 0 2
19752: PUSH
19753: LD_VAR 0 3
19757: GREATER
19758: IFFALSE 19784
// length := ( array - i_from ) + i_to else
19760: LD_ADDR_VAR 0 11
19764: PUSH
19765: LD_VAR 0 1
19769: PUSH
19770: LD_VAR 0 2
19774: MINUS
19775: PUSH
19776: LD_VAR 0 3
19780: PLUS
19781: ST_TO_ADDR
19782: GO 19800
// length := i_to - i_from ;
19784: LD_ADDR_VAR 0 11
19788: PUSH
19789: LD_VAR 0 3
19793: PUSH
19794: LD_VAR 0 2
19798: MINUS
19799: ST_TO_ADDR
// end else
19800: GO 19863
// begin d := - 1 ;
19802: LD_ADDR_VAR 0 9
19806: PUSH
19807: LD_INT 1
19809: NEG
19810: ST_TO_ADDR
// if i_from > i_to then
19811: LD_VAR 0 2
19815: PUSH
19816: LD_VAR 0 3
19820: GREATER
19821: IFFALSE 19841
// length := i_from - i_to else
19823: LD_ADDR_VAR 0 11
19827: PUSH
19828: LD_VAR 0 2
19832: PUSH
19833: LD_VAR 0 3
19837: MINUS
19838: ST_TO_ADDR
19839: GO 19863
// length := ( array - i_to ) + i_from ;
19841: LD_ADDR_VAR 0 11
19845: PUSH
19846: LD_VAR 0 1
19850: PUSH
19851: LD_VAR 0 3
19855: MINUS
19856: PUSH
19857: LD_VAR 0 2
19861: PLUS
19862: ST_TO_ADDR
// end ; if not length then
19863: LD_VAR 0 11
19867: NOT
19868: IFFALSE 19872
// exit ;
19870: GO 20030
// tmp := array ;
19872: LD_ADDR_VAR 0 10
19876: PUSH
19877: LD_VAR 0 1
19881: ST_TO_ADDR
// for i = 1 to length do
19882: LD_ADDR_VAR 0 6
19886: PUSH
19887: DOUBLE
19888: LD_INT 1
19890: DEC
19891: ST_TO_ADDR
19892: LD_VAR 0 11
19896: PUSH
19897: FOR_TO
19898: IFFALSE 20018
// begin for j = 1 to array do
19900: LD_ADDR_VAR 0 7
19904: PUSH
19905: DOUBLE
19906: LD_INT 1
19908: DEC
19909: ST_TO_ADDR
19910: LD_VAR 0 1
19914: PUSH
19915: FOR_TO
19916: IFFALSE 20004
// begin k := j + d ;
19918: LD_ADDR_VAR 0 8
19922: PUSH
19923: LD_VAR 0 7
19927: PUSH
19928: LD_VAR 0 9
19932: PLUS
19933: ST_TO_ADDR
// if k > array then
19934: LD_VAR 0 8
19938: PUSH
19939: LD_VAR 0 1
19943: GREATER
19944: IFFALSE 19954
// k := 1 ;
19946: LD_ADDR_VAR 0 8
19950: PUSH
19951: LD_INT 1
19953: ST_TO_ADDR
// if not k then
19954: LD_VAR 0 8
19958: NOT
19959: IFFALSE 19971
// k := array ;
19961: LD_ADDR_VAR 0 8
19965: PUSH
19966: LD_VAR 0 1
19970: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19971: LD_ADDR_VAR 0 10
19975: PUSH
19976: LD_VAR 0 10
19980: PPUSH
19981: LD_VAR 0 8
19985: PPUSH
19986: LD_VAR 0 1
19990: PUSH
19991: LD_VAR 0 7
19995: ARRAY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// end ;
20002: GO 19915
20004: POP
20005: POP
// array := tmp ;
20006: LD_ADDR_VAR 0 1
20010: PUSH
20011: LD_VAR 0 10
20015: ST_TO_ADDR
// end ;
20016: GO 19897
20018: POP
20019: POP
// result := array ;
20020: LD_ADDR_VAR 0 5
20024: PUSH
20025: LD_VAR 0 1
20029: ST_TO_ADDR
// end ;
20030: LD_VAR 0 5
20034: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20035: LD_INT 0
20037: PPUSH
20038: PPUSH
// result := 0 ;
20039: LD_ADDR_VAR 0 3
20043: PUSH
20044: LD_INT 0
20046: ST_TO_ADDR
// if not array or not value in array then
20047: LD_VAR 0 1
20051: NOT
20052: PUSH
20053: LD_VAR 0 2
20057: PUSH
20058: LD_VAR 0 1
20062: IN
20063: NOT
20064: OR
20065: IFFALSE 20069
// exit ;
20067: GO 20123
// for i = 1 to array do
20069: LD_ADDR_VAR 0 4
20073: PUSH
20074: DOUBLE
20075: LD_INT 1
20077: DEC
20078: ST_TO_ADDR
20079: LD_VAR 0 1
20083: PUSH
20084: FOR_TO
20085: IFFALSE 20121
// if value = array [ i ] then
20087: LD_VAR 0 2
20091: PUSH
20092: LD_VAR 0 1
20096: PUSH
20097: LD_VAR 0 4
20101: ARRAY
20102: EQUAL
20103: IFFALSE 20119
// begin result := i ;
20105: LD_ADDR_VAR 0 3
20109: PUSH
20110: LD_VAR 0 4
20114: ST_TO_ADDR
// exit ;
20115: POP
20116: POP
20117: GO 20123
// end ;
20119: GO 20084
20121: POP
20122: POP
// end ;
20123: LD_VAR 0 3
20127: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20128: LD_INT 0
20130: PPUSH
// vc_chassis := chassis ;
20131: LD_ADDR_OWVAR 37
20135: PUSH
20136: LD_VAR 0 1
20140: ST_TO_ADDR
// vc_engine := engine ;
20141: LD_ADDR_OWVAR 39
20145: PUSH
20146: LD_VAR 0 2
20150: ST_TO_ADDR
// vc_control := control ;
20151: LD_ADDR_OWVAR 38
20155: PUSH
20156: LD_VAR 0 3
20160: ST_TO_ADDR
// vc_weapon := weapon ;
20161: LD_ADDR_OWVAR 40
20165: PUSH
20166: LD_VAR 0 4
20170: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20171: LD_ADDR_OWVAR 41
20175: PUSH
20176: LD_VAR 0 5
20180: ST_TO_ADDR
// end ;
20181: LD_VAR 0 6
20185: RET
// export function WantPlant ( unit ) ; var task ; begin
20186: LD_INT 0
20188: PPUSH
20189: PPUSH
// result := false ;
20190: LD_ADDR_VAR 0 2
20194: PUSH
20195: LD_INT 0
20197: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20198: LD_ADDR_VAR 0 3
20202: PUSH
20203: LD_VAR 0 1
20207: PPUSH
20208: CALL_OW 437
20212: ST_TO_ADDR
// if task then
20213: LD_VAR 0 3
20217: IFFALSE 20245
// if task [ 1 ] [ 1 ] = p then
20219: LD_VAR 0 3
20223: PUSH
20224: LD_INT 1
20226: ARRAY
20227: PUSH
20228: LD_INT 1
20230: ARRAY
20231: PUSH
20232: LD_STRING p
20234: EQUAL
20235: IFFALSE 20245
// result := true ;
20237: LD_ADDR_VAR 0 2
20241: PUSH
20242: LD_INT 1
20244: ST_TO_ADDR
// end ;
20245: LD_VAR 0 2
20249: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20250: LD_INT 0
20252: PPUSH
20253: PPUSH
20254: PPUSH
20255: PPUSH
// if pos < 1 then
20256: LD_VAR 0 2
20260: PUSH
20261: LD_INT 1
20263: LESS
20264: IFFALSE 20268
// exit ;
20266: GO 20571
// if pos = 1 then
20268: LD_VAR 0 2
20272: PUSH
20273: LD_INT 1
20275: EQUAL
20276: IFFALSE 20309
// result := Replace ( arr , pos [ 1 ] , value ) else
20278: LD_ADDR_VAR 0 4
20282: PUSH
20283: LD_VAR 0 1
20287: PPUSH
20288: LD_VAR 0 2
20292: PUSH
20293: LD_INT 1
20295: ARRAY
20296: PPUSH
20297: LD_VAR 0 3
20301: PPUSH
20302: CALL_OW 1
20306: ST_TO_ADDR
20307: GO 20571
// begin tmp := arr ;
20309: LD_ADDR_VAR 0 6
20313: PUSH
20314: LD_VAR 0 1
20318: ST_TO_ADDR
// s_arr := [ tmp ] ;
20319: LD_ADDR_VAR 0 7
20323: PUSH
20324: LD_VAR 0 6
20328: PUSH
20329: EMPTY
20330: LIST
20331: ST_TO_ADDR
// for i = 1 to pos - 1 do
20332: LD_ADDR_VAR 0 5
20336: PUSH
20337: DOUBLE
20338: LD_INT 1
20340: DEC
20341: ST_TO_ADDR
20342: LD_VAR 0 2
20346: PUSH
20347: LD_INT 1
20349: MINUS
20350: PUSH
20351: FOR_TO
20352: IFFALSE 20397
// begin tmp := tmp [ pos [ i ] ] ;
20354: LD_ADDR_VAR 0 6
20358: PUSH
20359: LD_VAR 0 6
20363: PUSH
20364: LD_VAR 0 2
20368: PUSH
20369: LD_VAR 0 5
20373: ARRAY
20374: ARRAY
20375: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20376: LD_ADDR_VAR 0 7
20380: PUSH
20381: LD_VAR 0 7
20385: PUSH
20386: LD_VAR 0 6
20390: PUSH
20391: EMPTY
20392: LIST
20393: ADD
20394: ST_TO_ADDR
// end ;
20395: GO 20351
20397: POP
20398: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20399: LD_ADDR_VAR 0 6
20403: PUSH
20404: LD_VAR 0 6
20408: PPUSH
20409: LD_VAR 0 2
20413: PUSH
20414: LD_VAR 0 2
20418: ARRAY
20419: PPUSH
20420: LD_VAR 0 3
20424: PPUSH
20425: CALL_OW 1
20429: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20430: LD_ADDR_VAR 0 7
20434: PUSH
20435: LD_VAR 0 7
20439: PPUSH
20440: LD_VAR 0 7
20444: PPUSH
20445: LD_VAR 0 6
20449: PPUSH
20450: CALL_OW 1
20454: ST_TO_ADDR
// for i = s_arr downto 2 do
20455: LD_ADDR_VAR 0 5
20459: PUSH
20460: DOUBLE
20461: LD_VAR 0 7
20465: INC
20466: ST_TO_ADDR
20467: LD_INT 2
20469: PUSH
20470: FOR_DOWNTO
20471: IFFALSE 20555
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20473: LD_ADDR_VAR 0 6
20477: PUSH
20478: LD_VAR 0 7
20482: PUSH
20483: LD_VAR 0 5
20487: PUSH
20488: LD_INT 1
20490: MINUS
20491: ARRAY
20492: PPUSH
20493: LD_VAR 0 2
20497: PUSH
20498: LD_VAR 0 5
20502: PUSH
20503: LD_INT 1
20505: MINUS
20506: ARRAY
20507: PPUSH
20508: LD_VAR 0 7
20512: PUSH
20513: LD_VAR 0 5
20517: ARRAY
20518: PPUSH
20519: CALL_OW 1
20523: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20524: LD_ADDR_VAR 0 7
20528: PUSH
20529: LD_VAR 0 7
20533: PPUSH
20534: LD_VAR 0 5
20538: PUSH
20539: LD_INT 1
20541: MINUS
20542: PPUSH
20543: LD_VAR 0 6
20547: PPUSH
20548: CALL_OW 1
20552: ST_TO_ADDR
// end ;
20553: GO 20470
20555: POP
20556: POP
// result := s_arr [ 1 ] ;
20557: LD_ADDR_VAR 0 4
20561: PUSH
20562: LD_VAR 0 7
20566: PUSH
20567: LD_INT 1
20569: ARRAY
20570: ST_TO_ADDR
// end ; end ;
20571: LD_VAR 0 4
20575: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20576: LD_INT 0
20578: PPUSH
20579: PPUSH
// if not list then
20580: LD_VAR 0 1
20584: NOT
20585: IFFALSE 20589
// exit ;
20587: GO 20680
// i := list [ pos1 ] ;
20589: LD_ADDR_VAR 0 5
20593: PUSH
20594: LD_VAR 0 1
20598: PUSH
20599: LD_VAR 0 2
20603: ARRAY
20604: ST_TO_ADDR
// if not i then
20605: LD_VAR 0 5
20609: NOT
20610: IFFALSE 20614
// exit ;
20612: GO 20680
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20614: LD_ADDR_VAR 0 1
20618: PUSH
20619: LD_VAR 0 1
20623: PPUSH
20624: LD_VAR 0 2
20628: PPUSH
20629: LD_VAR 0 1
20633: PUSH
20634: LD_VAR 0 3
20638: ARRAY
20639: PPUSH
20640: CALL_OW 1
20644: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20645: LD_ADDR_VAR 0 1
20649: PUSH
20650: LD_VAR 0 1
20654: PPUSH
20655: LD_VAR 0 3
20659: PPUSH
20660: LD_VAR 0 5
20664: PPUSH
20665: CALL_OW 1
20669: ST_TO_ADDR
// result := list ;
20670: LD_ADDR_VAR 0 4
20674: PUSH
20675: LD_VAR 0 1
20679: ST_TO_ADDR
// end ;
20680: LD_VAR 0 4
20684: RET
// export function Add ( list , pos , val ) ; begin
20685: LD_INT 0
20687: PPUSH
// result := ReplaceIn ( list , pos , val ) end ;
20688: LD_ADDR_VAR 0 4
20692: PUSH
20693: LD_VAR 0 1
20697: PPUSH
20698: LD_VAR 0 2
20702: PPUSH
20703: LD_VAR 0 3
20707: PPUSH
20708: CALL 20250 0 3
20712: ST_TO_ADDR
20713: LD_VAR 0 4
20717: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20718: LD_INT 0
20720: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20721: LD_ADDR_VAR 0 5
20725: PUSH
20726: LD_VAR 0 1
20730: PPUSH
20731: CALL_OW 250
20735: PPUSH
20736: LD_VAR 0 1
20740: PPUSH
20741: CALL_OW 251
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: LD_VAR 0 3
20755: PPUSH
20756: LD_VAR 0 4
20760: PPUSH
20761: CALL 20771 0 5
20765: ST_TO_ADDR
// end ;
20766: LD_VAR 0 5
20770: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20771: LD_INT 0
20773: PPUSH
20774: PPUSH
20775: PPUSH
20776: PPUSH
// if not list then
20777: LD_VAR 0 3
20781: NOT
20782: IFFALSE 20786
// exit ;
20784: GO 21174
// result := [ ] ;
20786: LD_ADDR_VAR 0 6
20790: PUSH
20791: EMPTY
20792: ST_TO_ADDR
// for i in list do
20793: LD_ADDR_VAR 0 7
20797: PUSH
20798: LD_VAR 0 3
20802: PUSH
20803: FOR_IN
20804: IFFALSE 21006
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20806: LD_ADDR_VAR 0 9
20810: PUSH
20811: LD_VAR 0 7
20815: PPUSH
20816: LD_VAR 0 1
20820: PPUSH
20821: LD_VAR 0 2
20825: PPUSH
20826: CALL_OW 297
20830: ST_TO_ADDR
// if not result then
20831: LD_VAR 0 6
20835: NOT
20836: IFFALSE 20862
// result := [ [ i , tmp ] ] else
20838: LD_ADDR_VAR 0 6
20842: PUSH
20843: LD_VAR 0 7
20847: PUSH
20848: LD_VAR 0 9
20852: PUSH
20853: EMPTY
20854: LIST
20855: LIST
20856: PUSH
20857: EMPTY
20858: LIST
20859: ST_TO_ADDR
20860: GO 21004
// begin if result [ result ] [ 2 ] < tmp then
20862: LD_VAR 0 6
20866: PUSH
20867: LD_VAR 0 6
20871: ARRAY
20872: PUSH
20873: LD_INT 2
20875: ARRAY
20876: PUSH
20877: LD_VAR 0 9
20881: LESS
20882: IFFALSE 20924
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20884: LD_ADDR_VAR 0 6
20888: PUSH
20889: LD_VAR 0 6
20893: PPUSH
20894: LD_VAR 0 6
20898: PUSH
20899: LD_INT 1
20901: PLUS
20902: PPUSH
20903: LD_VAR 0 7
20907: PUSH
20908: LD_VAR 0 9
20912: PUSH
20913: EMPTY
20914: LIST
20915: LIST
20916: PPUSH
20917: CALL_OW 2
20921: ST_TO_ADDR
20922: GO 21004
// for j = 1 to result do
20924: LD_ADDR_VAR 0 8
20928: PUSH
20929: DOUBLE
20930: LD_INT 1
20932: DEC
20933: ST_TO_ADDR
20934: LD_VAR 0 6
20938: PUSH
20939: FOR_TO
20940: IFFALSE 21002
// begin if tmp < result [ j ] [ 2 ] then
20942: LD_VAR 0 9
20946: PUSH
20947: LD_VAR 0 6
20951: PUSH
20952: LD_VAR 0 8
20956: ARRAY
20957: PUSH
20958: LD_INT 2
20960: ARRAY
20961: LESS
20962: IFFALSE 21000
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20964: LD_ADDR_VAR 0 6
20968: PUSH
20969: LD_VAR 0 6
20973: PPUSH
20974: LD_VAR 0 8
20978: PPUSH
20979: LD_VAR 0 7
20983: PUSH
20984: LD_VAR 0 9
20988: PUSH
20989: EMPTY
20990: LIST
20991: LIST
20992: PPUSH
20993: CALL_OW 2
20997: ST_TO_ADDR
// break ;
20998: GO 21002
// end ; end ;
21000: GO 20939
21002: POP
21003: POP
// end ; end ;
21004: GO 20803
21006: POP
21007: POP
// if result and not asc then
21008: LD_VAR 0 6
21012: PUSH
21013: LD_VAR 0 4
21017: NOT
21018: AND
21019: IFFALSE 21094
// begin tmp := result ;
21021: LD_ADDR_VAR 0 9
21025: PUSH
21026: LD_VAR 0 6
21030: ST_TO_ADDR
// for i = tmp downto 1 do
21031: LD_ADDR_VAR 0 7
21035: PUSH
21036: DOUBLE
21037: LD_VAR 0 9
21041: INC
21042: ST_TO_ADDR
21043: LD_INT 1
21045: PUSH
21046: FOR_DOWNTO
21047: IFFALSE 21092
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21049: LD_ADDR_VAR 0 6
21053: PUSH
21054: LD_VAR 0 6
21058: PPUSH
21059: LD_VAR 0 9
21063: PUSH
21064: LD_VAR 0 7
21068: MINUS
21069: PUSH
21070: LD_INT 1
21072: PLUS
21073: PPUSH
21074: LD_VAR 0 9
21078: PUSH
21079: LD_VAR 0 7
21083: ARRAY
21084: PPUSH
21085: CALL_OW 1
21089: ST_TO_ADDR
21090: GO 21046
21092: POP
21093: POP
// end ; tmp := [ ] ;
21094: LD_ADDR_VAR 0 9
21098: PUSH
21099: EMPTY
21100: ST_TO_ADDR
// if mode then
21101: LD_VAR 0 5
21105: IFFALSE 21174
// begin for i = 1 to result do
21107: LD_ADDR_VAR 0 7
21111: PUSH
21112: DOUBLE
21113: LD_INT 1
21115: DEC
21116: ST_TO_ADDR
21117: LD_VAR 0 6
21121: PUSH
21122: FOR_TO
21123: IFFALSE 21162
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21125: LD_ADDR_VAR 0 9
21129: PUSH
21130: LD_VAR 0 9
21134: PPUSH
21135: LD_VAR 0 7
21139: PPUSH
21140: LD_VAR 0 6
21144: PUSH
21145: LD_VAR 0 7
21149: ARRAY
21150: PUSH
21151: LD_INT 1
21153: ARRAY
21154: PPUSH
21155: CALL_OW 1
21159: ST_TO_ADDR
21160: GO 21122
21162: POP
21163: POP
// result := tmp ;
21164: LD_ADDR_VAR 0 6
21168: PUSH
21169: LD_VAR 0 9
21173: ST_TO_ADDR
// end ; end ;
21174: LD_VAR 0 6
21178: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21179: LD_INT 0
21181: PPUSH
21182: PPUSH
21183: PPUSH
21184: PPUSH
21185: PPUSH
21186: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21187: LD_ADDR_VAR 0 5
21191: PUSH
21192: LD_INT 0
21194: PUSH
21195: LD_INT 0
21197: PUSH
21198: LD_INT 0
21200: PUSH
21201: EMPTY
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: LIST
21207: LIST
21208: ST_TO_ADDR
// if not x or not y then
21209: LD_VAR 0 2
21213: NOT
21214: PUSH
21215: LD_VAR 0 3
21219: NOT
21220: OR
21221: IFFALSE 21225
// exit ;
21223: GO 22871
// if not range then
21225: LD_VAR 0 4
21229: NOT
21230: IFFALSE 21240
// range := 10 ;
21232: LD_ADDR_VAR 0 4
21236: PUSH
21237: LD_INT 10
21239: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21240: LD_ADDR_VAR 0 8
21244: PUSH
21245: LD_INT 81
21247: PUSH
21248: LD_VAR 0 1
21252: PUSH
21253: EMPTY
21254: LIST
21255: LIST
21256: PUSH
21257: LD_INT 92
21259: PUSH
21260: LD_VAR 0 2
21264: PUSH
21265: LD_VAR 0 3
21269: PUSH
21270: LD_VAR 0 4
21274: PUSH
21275: EMPTY
21276: LIST
21277: LIST
21278: LIST
21279: LIST
21280: PUSH
21281: LD_INT 3
21283: PUSH
21284: LD_INT 21
21286: PUSH
21287: LD_INT 3
21289: PUSH
21290: EMPTY
21291: LIST
21292: LIST
21293: PUSH
21294: EMPTY
21295: LIST
21296: LIST
21297: PUSH
21298: EMPTY
21299: LIST
21300: LIST
21301: LIST
21302: PPUSH
21303: CALL_OW 69
21307: ST_TO_ADDR
// if not tmp then
21308: LD_VAR 0 8
21312: NOT
21313: IFFALSE 21317
// exit ;
21315: GO 22871
// for i in tmp do
21317: LD_ADDR_VAR 0 6
21321: PUSH
21322: LD_VAR 0 8
21326: PUSH
21327: FOR_IN
21328: IFFALSE 22846
// begin points := [ 0 , 0 , 0 ] ;
21330: LD_ADDR_VAR 0 9
21334: PUSH
21335: LD_INT 0
21337: PUSH
21338: LD_INT 0
21340: PUSH
21341: LD_INT 0
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: LIST
21348: ST_TO_ADDR
// bpoints := 1 ;
21349: LD_ADDR_VAR 0 10
21353: PUSH
21354: LD_INT 1
21356: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21357: LD_VAR 0 6
21361: PPUSH
21362: CALL_OW 247
21366: PUSH
21367: LD_INT 1
21369: DOUBLE
21370: EQUAL
21371: IFTRUE 21375
21373: GO 21953
21375: POP
// begin if GetClass ( i ) = 1 then
21376: LD_VAR 0 6
21380: PPUSH
21381: CALL_OW 257
21385: PUSH
21386: LD_INT 1
21388: EQUAL
21389: IFFALSE 21410
// points := [ 10 , 5 , 3 ] ;
21391: LD_ADDR_VAR 0 9
21395: PUSH
21396: LD_INT 10
21398: PUSH
21399: LD_INT 5
21401: PUSH
21402: LD_INT 3
21404: PUSH
21405: EMPTY
21406: LIST
21407: LIST
21408: LIST
21409: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21410: LD_VAR 0 6
21414: PPUSH
21415: CALL_OW 257
21419: PUSH
21420: LD_INT 2
21422: PUSH
21423: LD_INT 3
21425: PUSH
21426: LD_INT 4
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: LIST
21433: IN
21434: IFFALSE 21455
// points := [ 3 , 2 , 1 ] ;
21436: LD_ADDR_VAR 0 9
21440: PUSH
21441: LD_INT 3
21443: PUSH
21444: LD_INT 2
21446: PUSH
21447: LD_INT 1
21449: PUSH
21450: EMPTY
21451: LIST
21452: LIST
21453: LIST
21454: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21455: LD_VAR 0 6
21459: PPUSH
21460: CALL_OW 257
21464: PUSH
21465: LD_INT 5
21467: EQUAL
21468: IFFALSE 21489
// points := [ 130 , 5 , 2 ] ;
21470: LD_ADDR_VAR 0 9
21474: PUSH
21475: LD_INT 130
21477: PUSH
21478: LD_INT 5
21480: PUSH
21481: LD_INT 2
21483: PUSH
21484: EMPTY
21485: LIST
21486: LIST
21487: LIST
21488: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21489: LD_VAR 0 6
21493: PPUSH
21494: CALL_OW 257
21498: PUSH
21499: LD_INT 8
21501: EQUAL
21502: IFFALSE 21523
// points := [ 35 , 35 , 30 ] ;
21504: LD_ADDR_VAR 0 9
21508: PUSH
21509: LD_INT 35
21511: PUSH
21512: LD_INT 35
21514: PUSH
21515: LD_INT 30
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: LIST
21522: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21523: LD_VAR 0 6
21527: PPUSH
21528: CALL_OW 257
21532: PUSH
21533: LD_INT 9
21535: EQUAL
21536: IFFALSE 21557
// points := [ 20 , 55 , 40 ] ;
21538: LD_ADDR_VAR 0 9
21542: PUSH
21543: LD_INT 20
21545: PUSH
21546: LD_INT 55
21548: PUSH
21549: LD_INT 40
21551: PUSH
21552: EMPTY
21553: LIST
21554: LIST
21555: LIST
21556: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21557: LD_VAR 0 6
21561: PPUSH
21562: CALL_OW 257
21566: PUSH
21567: LD_INT 12
21569: PUSH
21570: LD_INT 16
21572: PUSH
21573: EMPTY
21574: LIST
21575: LIST
21576: IN
21577: IFFALSE 21598
// points := [ 5 , 3 , 2 ] ;
21579: LD_ADDR_VAR 0 9
21583: PUSH
21584: LD_INT 5
21586: PUSH
21587: LD_INT 3
21589: PUSH
21590: LD_INT 2
21592: PUSH
21593: EMPTY
21594: LIST
21595: LIST
21596: LIST
21597: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21598: LD_VAR 0 6
21602: PPUSH
21603: CALL_OW 257
21607: PUSH
21608: LD_INT 17
21610: EQUAL
21611: IFFALSE 21632
// points := [ 100 , 50 , 75 ] ;
21613: LD_ADDR_VAR 0 9
21617: PUSH
21618: LD_INT 100
21620: PUSH
21621: LD_INT 50
21623: PUSH
21624: LD_INT 75
21626: PUSH
21627: EMPTY
21628: LIST
21629: LIST
21630: LIST
21631: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21632: LD_VAR 0 6
21636: PPUSH
21637: CALL_OW 257
21641: PUSH
21642: LD_INT 15
21644: EQUAL
21645: IFFALSE 21666
// points := [ 10 , 5 , 3 ] ;
21647: LD_ADDR_VAR 0 9
21651: PUSH
21652: LD_INT 10
21654: PUSH
21655: LD_INT 5
21657: PUSH
21658: LD_INT 3
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: LIST
21665: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21666: LD_VAR 0 6
21670: PPUSH
21671: CALL_OW 257
21675: PUSH
21676: LD_INT 14
21678: EQUAL
21679: IFFALSE 21700
// points := [ 10 , 0 , 0 ] ;
21681: LD_ADDR_VAR 0 9
21685: PUSH
21686: LD_INT 10
21688: PUSH
21689: LD_INT 0
21691: PUSH
21692: LD_INT 0
21694: PUSH
21695: EMPTY
21696: LIST
21697: LIST
21698: LIST
21699: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21700: LD_VAR 0 6
21704: PPUSH
21705: CALL_OW 257
21709: PUSH
21710: LD_INT 11
21712: EQUAL
21713: IFFALSE 21734
// points := [ 30 , 10 , 5 ] ;
21715: LD_ADDR_VAR 0 9
21719: PUSH
21720: LD_INT 30
21722: PUSH
21723: LD_INT 10
21725: PUSH
21726: LD_INT 5
21728: PUSH
21729: EMPTY
21730: LIST
21731: LIST
21732: LIST
21733: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21734: LD_VAR 0 1
21738: PPUSH
21739: LD_INT 5
21741: PPUSH
21742: CALL_OW 321
21746: PUSH
21747: LD_INT 2
21749: EQUAL
21750: IFFALSE 21767
// bpoints := bpoints * 1.8 ;
21752: LD_ADDR_VAR 0 10
21756: PUSH
21757: LD_VAR 0 10
21761: PUSH
21762: LD_REAL  1.80000000000000E+0000
21765: MUL
21766: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21767: LD_VAR 0 6
21771: PPUSH
21772: CALL_OW 257
21776: PUSH
21777: LD_INT 1
21779: PUSH
21780: LD_INT 2
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: LD_INT 4
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: LIST
21794: IN
21795: PUSH
21796: LD_VAR 0 1
21800: PPUSH
21801: LD_INT 51
21803: PPUSH
21804: CALL_OW 321
21808: PUSH
21809: LD_INT 2
21811: EQUAL
21812: AND
21813: IFFALSE 21830
// bpoints := bpoints * 1.2 ;
21815: LD_ADDR_VAR 0 10
21819: PUSH
21820: LD_VAR 0 10
21824: PUSH
21825: LD_REAL  1.20000000000000E+0000
21828: MUL
21829: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21830: LD_VAR 0 6
21834: PPUSH
21835: CALL_OW 257
21839: PUSH
21840: LD_INT 5
21842: PUSH
21843: LD_INT 7
21845: PUSH
21846: LD_INT 9
21848: PUSH
21849: EMPTY
21850: LIST
21851: LIST
21852: LIST
21853: IN
21854: PUSH
21855: LD_VAR 0 1
21859: PPUSH
21860: LD_INT 52
21862: PPUSH
21863: CALL_OW 321
21867: PUSH
21868: LD_INT 2
21870: EQUAL
21871: AND
21872: IFFALSE 21889
// bpoints := bpoints * 1.5 ;
21874: LD_ADDR_VAR 0 10
21878: PUSH
21879: LD_VAR 0 10
21883: PUSH
21884: LD_REAL  1.50000000000000E+0000
21887: MUL
21888: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21889: LD_VAR 0 1
21893: PPUSH
21894: LD_INT 66
21896: PPUSH
21897: CALL_OW 321
21901: PUSH
21902: LD_INT 2
21904: EQUAL
21905: IFFALSE 21922
// bpoints := bpoints * 1.1 ;
21907: LD_ADDR_VAR 0 10
21911: PUSH
21912: LD_VAR 0 10
21916: PUSH
21917: LD_REAL  1.10000000000000E+0000
21920: MUL
21921: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21922: LD_ADDR_VAR 0 10
21926: PUSH
21927: LD_VAR 0 10
21931: PUSH
21932: LD_VAR 0 6
21936: PPUSH
21937: LD_INT 1
21939: PPUSH
21940: CALL_OW 259
21944: PUSH
21945: LD_REAL  1.15000000000000E+0000
21948: MUL
21949: MUL
21950: ST_TO_ADDR
// end ; unit_vehicle :
21951: GO 22775
21953: LD_INT 2
21955: DOUBLE
21956: EQUAL
21957: IFTRUE 21961
21959: GO 22763
21961: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21962: LD_VAR 0 6
21966: PPUSH
21967: CALL_OW 264
21971: PUSH
21972: LD_INT 2
21974: PUSH
21975: LD_INT 42
21977: PUSH
21978: LD_INT 24
21980: PUSH
21981: EMPTY
21982: LIST
21983: LIST
21984: LIST
21985: IN
21986: IFFALSE 22007
// points := [ 25 , 5 , 3 ] ;
21988: LD_ADDR_VAR 0 9
21992: PUSH
21993: LD_INT 25
21995: PUSH
21996: LD_INT 5
21998: PUSH
21999: LD_INT 3
22001: PUSH
22002: EMPTY
22003: LIST
22004: LIST
22005: LIST
22006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22007: LD_VAR 0 6
22011: PPUSH
22012: CALL_OW 264
22016: PUSH
22017: LD_INT 4
22019: PUSH
22020: LD_INT 43
22022: PUSH
22023: LD_INT 25
22025: PUSH
22026: EMPTY
22027: LIST
22028: LIST
22029: LIST
22030: IN
22031: IFFALSE 22052
// points := [ 40 , 15 , 5 ] ;
22033: LD_ADDR_VAR 0 9
22037: PUSH
22038: LD_INT 40
22040: PUSH
22041: LD_INT 15
22043: PUSH
22044: LD_INT 5
22046: PUSH
22047: EMPTY
22048: LIST
22049: LIST
22050: LIST
22051: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22052: LD_VAR 0 6
22056: PPUSH
22057: CALL_OW 264
22061: PUSH
22062: LD_INT 3
22064: PUSH
22065: LD_INT 23
22067: PUSH
22068: EMPTY
22069: LIST
22070: LIST
22071: IN
22072: IFFALSE 22093
// points := [ 7 , 25 , 8 ] ;
22074: LD_ADDR_VAR 0 9
22078: PUSH
22079: LD_INT 7
22081: PUSH
22082: LD_INT 25
22084: PUSH
22085: LD_INT 8
22087: PUSH
22088: EMPTY
22089: LIST
22090: LIST
22091: LIST
22092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22093: LD_VAR 0 6
22097: PPUSH
22098: CALL_OW 264
22102: PUSH
22103: LD_INT 5
22105: PUSH
22106: LD_INT 27
22108: PUSH
22109: LD_INT 44
22111: PUSH
22112: EMPTY
22113: LIST
22114: LIST
22115: LIST
22116: IN
22117: IFFALSE 22138
// points := [ 14 , 50 , 16 ] ;
22119: LD_ADDR_VAR 0 9
22123: PUSH
22124: LD_INT 14
22126: PUSH
22127: LD_INT 50
22129: PUSH
22130: LD_INT 16
22132: PUSH
22133: EMPTY
22134: LIST
22135: LIST
22136: LIST
22137: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22138: LD_VAR 0 6
22142: PPUSH
22143: CALL_OW 264
22147: PUSH
22148: LD_INT 6
22150: PUSH
22151: LD_INT 46
22153: PUSH
22154: EMPTY
22155: LIST
22156: LIST
22157: IN
22158: IFFALSE 22179
// points := [ 32 , 120 , 70 ] ;
22160: LD_ADDR_VAR 0 9
22164: PUSH
22165: LD_INT 32
22167: PUSH
22168: LD_INT 120
22170: PUSH
22171: LD_INT 70
22173: PUSH
22174: EMPTY
22175: LIST
22176: LIST
22177: LIST
22178: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22179: LD_VAR 0 6
22183: PPUSH
22184: CALL_OW 264
22188: PUSH
22189: LD_INT 7
22191: PUSH
22192: LD_INT 28
22194: PUSH
22195: LD_INT 45
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: LIST
22202: IN
22203: IFFALSE 22224
// points := [ 35 , 20 , 45 ] ;
22205: LD_ADDR_VAR 0 9
22209: PUSH
22210: LD_INT 35
22212: PUSH
22213: LD_INT 20
22215: PUSH
22216: LD_INT 45
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: LIST
22223: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22224: LD_VAR 0 6
22228: PPUSH
22229: CALL_OW 264
22233: PUSH
22234: LD_INT 47
22236: PUSH
22237: EMPTY
22238: LIST
22239: IN
22240: IFFALSE 22261
// points := [ 67 , 45 , 75 ] ;
22242: LD_ADDR_VAR 0 9
22246: PUSH
22247: LD_INT 67
22249: PUSH
22250: LD_INT 45
22252: PUSH
22253: LD_INT 75
22255: PUSH
22256: EMPTY
22257: LIST
22258: LIST
22259: LIST
22260: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22261: LD_VAR 0 6
22265: PPUSH
22266: CALL_OW 264
22270: PUSH
22271: LD_INT 26
22273: PUSH
22274: EMPTY
22275: LIST
22276: IN
22277: IFFALSE 22298
// points := [ 120 , 30 , 80 ] ;
22279: LD_ADDR_VAR 0 9
22283: PUSH
22284: LD_INT 120
22286: PUSH
22287: LD_INT 30
22289: PUSH
22290: LD_INT 80
22292: PUSH
22293: EMPTY
22294: LIST
22295: LIST
22296: LIST
22297: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22298: LD_VAR 0 6
22302: PPUSH
22303: CALL_OW 264
22307: PUSH
22308: LD_INT 22
22310: PUSH
22311: EMPTY
22312: LIST
22313: IN
22314: IFFALSE 22335
// points := [ 40 , 1 , 1 ] ;
22316: LD_ADDR_VAR 0 9
22320: PUSH
22321: LD_INT 40
22323: PUSH
22324: LD_INT 1
22326: PUSH
22327: LD_INT 1
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: LIST
22334: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22335: LD_VAR 0 6
22339: PPUSH
22340: CALL_OW 264
22344: PUSH
22345: LD_INT 29
22347: PUSH
22348: EMPTY
22349: LIST
22350: IN
22351: IFFALSE 22372
// points := [ 70 , 200 , 400 ] ;
22353: LD_ADDR_VAR 0 9
22357: PUSH
22358: LD_INT 70
22360: PUSH
22361: LD_INT 200
22363: PUSH
22364: LD_INT 400
22366: PUSH
22367: EMPTY
22368: LIST
22369: LIST
22370: LIST
22371: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22372: LD_VAR 0 6
22376: PPUSH
22377: CALL_OW 264
22381: PUSH
22382: LD_INT 14
22384: PUSH
22385: LD_INT 53
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: IN
22392: IFFALSE 22413
// points := [ 40 , 10 , 20 ] ;
22394: LD_ADDR_VAR 0 9
22398: PUSH
22399: LD_INT 40
22401: PUSH
22402: LD_INT 10
22404: PUSH
22405: LD_INT 20
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: LIST
22412: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22413: LD_VAR 0 6
22417: PPUSH
22418: CALL_OW 264
22422: PUSH
22423: LD_INT 9
22425: PUSH
22426: EMPTY
22427: LIST
22428: IN
22429: IFFALSE 22450
// points := [ 5 , 70 , 20 ] ;
22431: LD_ADDR_VAR 0 9
22435: PUSH
22436: LD_INT 5
22438: PUSH
22439: LD_INT 70
22441: PUSH
22442: LD_INT 20
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: LIST
22449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22450: LD_VAR 0 6
22454: PPUSH
22455: CALL_OW 264
22459: PUSH
22460: LD_INT 10
22462: PUSH
22463: EMPTY
22464: LIST
22465: IN
22466: IFFALSE 22487
// points := [ 35 , 110 , 70 ] ;
22468: LD_ADDR_VAR 0 9
22472: PUSH
22473: LD_INT 35
22475: PUSH
22476: LD_INT 110
22478: PUSH
22479: LD_INT 70
22481: PUSH
22482: EMPTY
22483: LIST
22484: LIST
22485: LIST
22486: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22487: LD_VAR 0 6
22491: PPUSH
22492: CALL_OW 265
22496: PUSH
22497: LD_INT 25
22499: EQUAL
22500: IFFALSE 22521
// points := [ 80 , 65 , 100 ] ;
22502: LD_ADDR_VAR 0 9
22506: PUSH
22507: LD_INT 80
22509: PUSH
22510: LD_INT 65
22512: PUSH
22513: LD_INT 100
22515: PUSH
22516: EMPTY
22517: LIST
22518: LIST
22519: LIST
22520: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22521: LD_VAR 0 6
22525: PPUSH
22526: CALL_OW 263
22530: PUSH
22531: LD_INT 1
22533: EQUAL
22534: IFFALSE 22569
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22536: LD_ADDR_VAR 0 10
22540: PUSH
22541: LD_VAR 0 10
22545: PUSH
22546: LD_VAR 0 6
22550: PPUSH
22551: CALL_OW 311
22555: PPUSH
22556: LD_INT 3
22558: PPUSH
22559: CALL_OW 259
22563: PUSH
22564: LD_INT 4
22566: MUL
22567: MUL
22568: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22569: LD_VAR 0 6
22573: PPUSH
22574: CALL_OW 263
22578: PUSH
22579: LD_INT 2
22581: EQUAL
22582: IFFALSE 22633
// begin j := IsControledBy ( i ) ;
22584: LD_ADDR_VAR 0 7
22588: PUSH
22589: LD_VAR 0 6
22593: PPUSH
22594: CALL_OW 312
22598: ST_TO_ADDR
// if j then
22599: LD_VAR 0 7
22603: IFFALSE 22633
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22605: LD_ADDR_VAR 0 10
22609: PUSH
22610: LD_VAR 0 10
22614: PUSH
22615: LD_VAR 0 7
22619: PPUSH
22620: LD_INT 3
22622: PPUSH
22623: CALL_OW 259
22627: PUSH
22628: LD_INT 3
22630: MUL
22631: MUL
22632: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22633: LD_VAR 0 6
22637: PPUSH
22638: CALL_OW 264
22642: PUSH
22643: LD_INT 5
22645: PUSH
22646: LD_INT 6
22648: PUSH
22649: LD_INT 46
22651: PUSH
22652: LD_INT 44
22654: PUSH
22655: LD_INT 47
22657: PUSH
22658: LD_INT 45
22660: PUSH
22661: LD_INT 28
22663: PUSH
22664: LD_INT 7
22666: PUSH
22667: LD_INT 27
22669: PUSH
22670: LD_INT 29
22672: PUSH
22673: EMPTY
22674: LIST
22675: LIST
22676: LIST
22677: LIST
22678: LIST
22679: LIST
22680: LIST
22681: LIST
22682: LIST
22683: LIST
22684: IN
22685: PUSH
22686: LD_VAR 0 1
22690: PPUSH
22691: LD_INT 52
22693: PPUSH
22694: CALL_OW 321
22698: PUSH
22699: LD_INT 2
22701: EQUAL
22702: AND
22703: IFFALSE 22720
// bpoints := bpoints * 1.2 ;
22705: LD_ADDR_VAR 0 10
22709: PUSH
22710: LD_VAR 0 10
22714: PUSH
22715: LD_REAL  1.20000000000000E+0000
22718: MUL
22719: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22720: LD_VAR 0 6
22724: PPUSH
22725: CALL_OW 264
22729: PUSH
22730: LD_INT 6
22732: PUSH
22733: LD_INT 46
22735: PUSH
22736: LD_INT 47
22738: PUSH
22739: EMPTY
22740: LIST
22741: LIST
22742: LIST
22743: IN
22744: IFFALSE 22761
// bpoints := bpoints * 1.2 ;
22746: LD_ADDR_VAR 0 10
22750: PUSH
22751: LD_VAR 0 10
22755: PUSH
22756: LD_REAL  1.20000000000000E+0000
22759: MUL
22760: ST_TO_ADDR
// end ; unit_building :
22761: GO 22775
22763: LD_INT 3
22765: DOUBLE
22766: EQUAL
22767: IFTRUE 22771
22769: GO 22774
22771: POP
// ; end ;
22772: GO 22775
22774: POP
// for j = 1 to 3 do
22775: LD_ADDR_VAR 0 7
22779: PUSH
22780: DOUBLE
22781: LD_INT 1
22783: DEC
22784: ST_TO_ADDR
22785: LD_INT 3
22787: PUSH
22788: FOR_TO
22789: IFFALSE 22842
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22791: LD_ADDR_VAR 0 5
22795: PUSH
22796: LD_VAR 0 5
22800: PPUSH
22801: LD_VAR 0 7
22805: PPUSH
22806: LD_VAR 0 5
22810: PUSH
22811: LD_VAR 0 7
22815: ARRAY
22816: PUSH
22817: LD_VAR 0 9
22821: PUSH
22822: LD_VAR 0 7
22826: ARRAY
22827: PUSH
22828: LD_VAR 0 10
22832: MUL
22833: PLUS
22834: PPUSH
22835: CALL_OW 1
22839: ST_TO_ADDR
22840: GO 22788
22842: POP
22843: POP
// end ;
22844: GO 21327
22846: POP
22847: POP
// result := Replace ( result , 4 , tmp ) ;
22848: LD_ADDR_VAR 0 5
22852: PUSH
22853: LD_VAR 0 5
22857: PPUSH
22858: LD_INT 4
22860: PPUSH
22861: LD_VAR 0 8
22865: PPUSH
22866: CALL_OW 1
22870: ST_TO_ADDR
// end ;
22871: LD_VAR 0 5
22875: RET
// export function DangerAtRange ( unit , range ) ; begin
22876: LD_INT 0
22878: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22879: LD_ADDR_VAR 0 3
22883: PUSH
22884: LD_VAR 0 1
22888: PPUSH
22889: CALL_OW 255
22893: PPUSH
22894: LD_VAR 0 1
22898: PPUSH
22899: CALL_OW 250
22903: PPUSH
22904: LD_VAR 0 1
22908: PPUSH
22909: CALL_OW 251
22913: PPUSH
22914: LD_VAR 0 2
22918: PPUSH
22919: CALL 21179 0 4
22923: ST_TO_ADDR
// end ;
22924: LD_VAR 0 3
22928: RET
// export function DangerInArea ( side , area ) ; begin
22929: LD_INT 0
22931: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22932: LD_ADDR_VAR 0 3
22936: PUSH
22937: LD_VAR 0 2
22941: PPUSH
22942: LD_INT 81
22944: PUSH
22945: LD_VAR 0 1
22949: PUSH
22950: EMPTY
22951: LIST
22952: LIST
22953: PPUSH
22954: CALL_OW 70
22958: ST_TO_ADDR
// end ;
22959: LD_VAR 0 3
22963: RET
// export function IsExtension ( b ) ; begin
22964: LD_INT 0
22966: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22967: LD_ADDR_VAR 0 2
22971: PUSH
22972: LD_VAR 0 1
22976: PUSH
22977: LD_INT 23
22979: PUSH
22980: LD_INT 20
22982: PUSH
22983: LD_INT 22
22985: PUSH
22986: LD_INT 17
22988: PUSH
22989: LD_INT 24
22991: PUSH
22992: LD_INT 21
22994: PUSH
22995: LD_INT 19
22997: PUSH
22998: LD_INT 16
23000: PUSH
23001: LD_INT 25
23003: PUSH
23004: LD_INT 18
23006: PUSH
23007: EMPTY
23008: LIST
23009: LIST
23010: LIST
23011: LIST
23012: LIST
23013: LIST
23014: LIST
23015: LIST
23016: LIST
23017: LIST
23018: IN
23019: ST_TO_ADDR
// end ;
23020: LD_VAR 0 2
23024: RET
// export function GetBaseBuildings ( base ) ; var tmp , i ; begin
23025: LD_INT 0
23027: PPUSH
23028: PPUSH
23029: PPUSH
// result := [ ] ;
23030: LD_ADDR_VAR 0 2
23034: PUSH
23035: EMPTY
23036: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
23037: LD_ADDR_VAR 0 3
23041: PUSH
23042: LD_INT 21
23044: PUSH
23045: LD_INT 3
23047: PUSH
23048: EMPTY
23049: LIST
23050: LIST
23051: PPUSH
23052: CALL_OW 69
23056: ST_TO_ADDR
// if not tmp then
23057: LD_VAR 0 3
23061: NOT
23062: IFFALSE 23066
// exit ;
23064: GO 23116
// for i in tmp do
23066: LD_ADDR_VAR 0 4
23070: PUSH
23071: LD_VAR 0 3
23075: PUSH
23076: FOR_IN
23077: IFFALSE 23114
// if GetBase ( i ) = base then
23079: LD_VAR 0 4
23083: PPUSH
23084: CALL_OW 274
23088: PUSH
23089: LD_VAR 0 1
23093: EQUAL
23094: IFFALSE 23112
// result := result ^ i ;
23096: LD_ADDR_VAR 0 2
23100: PUSH
23101: LD_VAR 0 2
23105: PUSH
23106: LD_VAR 0 4
23110: ADD
23111: ST_TO_ADDR
23112: GO 23076
23114: POP
23115: POP
// end ;
23116: LD_VAR 0 2
23120: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23121: LD_INT 0
23123: PPUSH
23124: PPUSH
// if BuildingStatus ( b ) = bs_build then
23125: LD_VAR 0 2
23129: PPUSH
23130: CALL_OW 461
23134: PUSH
23135: LD_INT 1
23137: EQUAL
23138: IFFALSE 23198
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23140: LD_VAR 0 1
23144: PPUSH
23145: LD_STRING h
23147: PUSH
23148: LD_VAR 0 2
23152: PPUSH
23153: CALL_OW 250
23157: PUSH
23158: LD_VAR 0 2
23162: PPUSH
23163: CALL_OW 251
23167: PUSH
23168: LD_VAR 0 2
23172: PUSH
23173: LD_INT 0
23175: PUSH
23176: LD_INT 0
23178: PUSH
23179: LD_INT 0
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: PPUSH
23194: CALL_OW 446
// end ;
23198: LD_VAR 0 3
23202: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23203: LD_INT 0
23205: PPUSH
23206: PPUSH
23207: PPUSH
23208: PPUSH
23209: PPUSH
23210: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23211: LD_VAR 0 1
23215: NOT
23216: PUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: CALL_OW 263
23226: PUSH
23227: LD_INT 2
23229: EQUAL
23230: NOT
23231: OR
23232: IFFALSE 23236
// exit ;
23234: GO 23552
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23236: LD_ADDR_VAR 0 6
23240: PUSH
23241: LD_INT 22
23243: PUSH
23244: LD_VAR 0 1
23248: PPUSH
23249: CALL_OW 255
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: LD_INT 2
23260: PUSH
23261: LD_INT 30
23263: PUSH
23264: LD_INT 36
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: PUSH
23271: LD_INT 34
23273: PUSH
23274: LD_INT 31
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PPUSH
23290: CALL_OW 69
23294: ST_TO_ADDR
// if not tmp then
23295: LD_VAR 0 6
23299: NOT
23300: IFFALSE 23304
// exit ;
23302: GO 23552
// result := [ ] ;
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: EMPTY
23310: ST_TO_ADDR
// for i in tmp do
23311: LD_ADDR_VAR 0 3
23315: PUSH
23316: LD_VAR 0 6
23320: PUSH
23321: FOR_IN
23322: IFFALSE 23393
// begin t := UnitsInside ( i ) ;
23324: LD_ADDR_VAR 0 4
23328: PUSH
23329: LD_VAR 0 3
23333: PPUSH
23334: CALL_OW 313
23338: ST_TO_ADDR
// if t then
23339: LD_VAR 0 4
23343: IFFALSE 23391
// for j in t do
23345: LD_ADDR_VAR 0 7
23349: PUSH
23350: LD_VAR 0 4
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23389
// result := Insert ( result , result + 1 , j ) ;
23358: LD_ADDR_VAR 0 2
23362: PUSH
23363: LD_VAR 0 2
23367: PPUSH
23368: LD_VAR 0 2
23372: PUSH
23373: LD_INT 1
23375: PLUS
23376: PPUSH
23377: LD_VAR 0 7
23381: PPUSH
23382: CALL_OW 2
23386: ST_TO_ADDR
23387: GO 23355
23389: POP
23390: POP
// end ;
23391: GO 23321
23393: POP
23394: POP
// if not result then
23395: LD_VAR 0 2
23399: NOT
23400: IFFALSE 23404
// exit ;
23402: GO 23552
// mech := result [ 1 ] ;
23404: LD_ADDR_VAR 0 5
23408: PUSH
23409: LD_VAR 0 2
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: ST_TO_ADDR
// if result > 1 then
23418: LD_VAR 0 2
23422: PUSH
23423: LD_INT 1
23425: GREATER
23426: IFFALSE 23538
// for i = 2 to result do
23428: LD_ADDR_VAR 0 3
23432: PUSH
23433: DOUBLE
23434: LD_INT 2
23436: DEC
23437: ST_TO_ADDR
23438: LD_VAR 0 2
23442: PUSH
23443: FOR_TO
23444: IFFALSE 23536
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23446: LD_ADDR_VAR 0 4
23450: PUSH
23451: LD_VAR 0 2
23455: PUSH
23456: LD_VAR 0 3
23460: ARRAY
23461: PPUSH
23462: LD_INT 3
23464: PPUSH
23465: CALL_OW 259
23469: PUSH
23470: LD_VAR 0 2
23474: PUSH
23475: LD_VAR 0 3
23479: ARRAY
23480: PPUSH
23481: CALL_OW 432
23485: MINUS
23486: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23487: LD_VAR 0 4
23491: PUSH
23492: LD_VAR 0 5
23496: PPUSH
23497: LD_INT 3
23499: PPUSH
23500: CALL_OW 259
23504: PUSH
23505: LD_VAR 0 5
23509: PPUSH
23510: CALL_OW 432
23514: MINUS
23515: GREATEREQUAL
23516: IFFALSE 23534
// mech := result [ i ] ;
23518: LD_ADDR_VAR 0 5
23522: PUSH
23523: LD_VAR 0 2
23527: PUSH
23528: LD_VAR 0 3
23532: ARRAY
23533: ST_TO_ADDR
// end ;
23534: GO 23443
23536: POP
23537: POP
// ComLinkTo ( vehicle , mech ) ;
23538: LD_VAR 0 1
23542: PPUSH
23543: LD_VAR 0 5
23547: PPUSH
23548: CALL_OW 135
// end ;
23552: LD_VAR 0 2
23556: RET
// export function PrepareBase ( base_dep , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23557: LD_INT 0
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
23567: PPUSH
23568: PPUSH
23569: PPUSH
23570: PPUSH
23571: PPUSH
// result := [ ] ;
23572: LD_ADDR_VAR 0 6
23576: PUSH
23577: EMPTY
23578: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23579: LD_VAR 0 1
23583: PPUSH
23584: CALL_OW 266
23588: PUSH
23589: LD_INT 0
23591: PUSH
23592: LD_INT 1
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: IN
23599: NOT
23600: IFFALSE 23604
// exit ;
23602: GO 25123
// if name then
23604: LD_VAR 0 2
23608: IFFALSE 23624
// SetBName ( base_dep , name ) ;
23610: LD_VAR 0 1
23614: PPUSH
23615: LD_VAR 0 2
23619: PPUSH
23620: CALL_OW 500
// base := GetBase ( base_dep ) ;
23624: LD_ADDR_VAR 0 14
23628: PUSH
23629: LD_VAR 0 1
23633: PPUSH
23634: CALL_OW 274
23638: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23639: LD_ADDR_VAR 0 15
23643: PUSH
23644: LD_VAR 0 1
23648: PPUSH
23649: CALL_OW 255
23653: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23654: LD_ADDR_VAR 0 16
23658: PUSH
23659: LD_VAR 0 1
23663: PPUSH
23664: CALL_OW 248
23668: ST_TO_ADDR
// if sources then
23669: LD_VAR 0 4
23673: IFFALSE 23720
// for i = 1 to 3 do
23675: LD_ADDR_VAR 0 7
23679: PUSH
23680: DOUBLE
23681: LD_INT 1
23683: DEC
23684: ST_TO_ADDR
23685: LD_INT 3
23687: PUSH
23688: FOR_TO
23689: IFFALSE 23718
// AddResourceType ( base , i , sources [ i ] ) ;
23691: LD_VAR 0 14
23695: PPUSH
23696: LD_VAR 0 7
23700: PPUSH
23701: LD_VAR 0 4
23705: PUSH
23706: LD_VAR 0 7
23710: ARRAY
23711: PPUSH
23712: CALL_OW 276
23716: GO 23688
23718: POP
23719: POP
// buildings := GetBaseBuildings ( base ) ;
23720: LD_ADDR_VAR 0 17
23724: PUSH
23725: LD_VAR 0 14
23729: PPUSH
23730: CALL 23025 0 1
23734: ST_TO_ADDR
// InitHc ;
23735: CALL_OW 19
// InitUc ;
23739: CALL_OW 18
// uc_side := side ;
23743: LD_ADDR_OWVAR 20
23747: PUSH
23748: LD_VAR 0 15
23752: ST_TO_ADDR
// uc_nation := nation ;
23753: LD_ADDR_OWVAR 21
23757: PUSH
23758: LD_VAR 0 16
23762: ST_TO_ADDR
// if buildings then
23763: LD_VAR 0 17
23767: IFFALSE 24982
// begin if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23769: LD_VAR 0 17
23773: PPUSH
23774: LD_INT 2
23776: PUSH
23777: LD_INT 30
23779: PUSH
23780: LD_INT 32
23782: PUSH
23783: EMPTY
23784: LIST
23785: LIST
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 33
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: LIST
23801: PPUSH
23802: CALL_OW 72
23806: IFFALSE 23889
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23808: LD_ADDR_VAR 0 7
23812: PUSH
23813: LD_VAR 0 17
23817: PPUSH
23818: LD_INT 2
23820: PUSH
23821: LD_INT 30
23823: PUSH
23824: LD_INT 32
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: PUSH
23831: LD_INT 30
23833: PUSH
23834: LD_INT 33
23836: PUSH
23837: EMPTY
23838: LIST
23839: LIST
23840: PUSH
23841: EMPTY
23842: LIST
23843: LIST
23844: LIST
23845: PPUSH
23846: CALL_OW 72
23850: PUSH
23851: FOR_IN
23852: IFFALSE 23887
// begin if not GetBWeapon ( i ) then
23854: LD_VAR 0 7
23858: PPUSH
23859: CALL_OW 269
23863: NOT
23864: IFFALSE 23885
// PlaceWeaponTurret ( i , GetTurretWeapon ( i ) ) ;
23866: LD_VAR 0 7
23870: PPUSH
23871: LD_VAR 0 7
23875: PPUSH
23876: CALL 25128 0 1
23880: PPUSH
23881: CALL_OW 431
// end ;
23885: GO 23851
23887: POP
23888: POP
// end ; for i = 1 to personel do
23889: LD_ADDR_VAR 0 7
23893: PUSH
23894: DOUBLE
23895: LD_INT 1
23897: DEC
23898: ST_TO_ADDR
23899: LD_VAR 0 5
23903: PUSH
23904: FOR_TO
23905: IFFALSE 24962
// begin if i > 4 then
23907: LD_VAR 0 7
23911: PUSH
23912: LD_INT 4
23914: GREATER
23915: IFFALSE 23919
// break ;
23917: GO 24962
// case i of 1 :
23919: LD_VAR 0 7
23923: PUSH
23924: LD_INT 1
23926: DOUBLE
23927: EQUAL
23928: IFTRUE 23932
23930: GO 24005
23932: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23933: LD_ADDR_VAR 0 11
23937: PUSH
23938: LD_VAR 0 17
23942: PPUSH
23943: LD_INT 22
23945: PUSH
23946: LD_VAR 0 15
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: PUSH
23955: LD_INT 2
23957: PUSH
23958: LD_INT 30
23960: PUSH
23961: LD_INT 32
23963: PUSH
23964: EMPTY
23965: LIST
23966: LIST
23967: PUSH
23968: LD_INT 30
23970: PUSH
23971: LD_INT 4
23973: PUSH
23974: EMPTY
23975: LIST
23976: LIST
23977: PUSH
23978: LD_INT 30
23980: PUSH
23981: LD_INT 5
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: PUSH
23988: EMPTY
23989: LIST
23990: LIST
23991: LIST
23992: LIST
23993: PUSH
23994: EMPTY
23995: LIST
23996: LIST
23997: PPUSH
23998: CALL_OW 72
24002: ST_TO_ADDR
24003: GO 24227
24005: LD_INT 2
24007: DOUBLE
24008: EQUAL
24009: IFTRUE 24013
24011: GO 24075
24013: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24014: LD_ADDR_VAR 0 11
24018: PUSH
24019: LD_VAR 0 17
24023: PPUSH
24024: LD_INT 22
24026: PUSH
24027: LD_VAR 0 15
24031: PUSH
24032: EMPTY
24033: LIST
24034: LIST
24035: PUSH
24036: LD_INT 2
24038: PUSH
24039: LD_INT 30
24041: PUSH
24042: LD_INT 0
24044: PUSH
24045: EMPTY
24046: LIST
24047: LIST
24048: PUSH
24049: LD_INT 30
24051: PUSH
24052: LD_INT 1
24054: PUSH
24055: EMPTY
24056: LIST
24057: LIST
24058: PUSH
24059: EMPTY
24060: LIST
24061: LIST
24062: LIST
24063: PUSH
24064: EMPTY
24065: LIST
24066: LIST
24067: PPUSH
24068: CALL_OW 72
24072: ST_TO_ADDR
24073: GO 24227
24075: LD_INT 3
24077: DOUBLE
24078: EQUAL
24079: IFTRUE 24083
24081: GO 24145
24083: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24084: LD_ADDR_VAR 0 11
24088: PUSH
24089: LD_VAR 0 17
24093: PPUSH
24094: LD_INT 22
24096: PUSH
24097: LD_VAR 0 15
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: PUSH
24106: LD_INT 2
24108: PUSH
24109: LD_INT 30
24111: PUSH
24112: LD_INT 2
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: PUSH
24119: LD_INT 30
24121: PUSH
24122: LD_INT 3
24124: PUSH
24125: EMPTY
24126: LIST
24127: LIST
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: LIST
24133: PUSH
24134: EMPTY
24135: LIST
24136: LIST
24137: PPUSH
24138: CALL_OW 72
24142: ST_TO_ADDR
24143: GO 24227
24145: LD_INT 4
24147: DOUBLE
24148: EQUAL
24149: IFTRUE 24153
24151: GO 24226
24153: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24154: LD_ADDR_VAR 0 11
24158: PUSH
24159: LD_VAR 0 17
24163: PPUSH
24164: LD_INT 22
24166: PUSH
24167: LD_VAR 0 15
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: PUSH
24176: LD_INT 2
24178: PUSH
24179: LD_INT 30
24181: PUSH
24182: LD_INT 6
24184: PUSH
24185: EMPTY
24186: LIST
24187: LIST
24188: PUSH
24189: LD_INT 30
24191: PUSH
24192: LD_INT 7
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: LD_INT 30
24201: PUSH
24202: LD_INT 8
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: EMPTY
24210: LIST
24211: LIST
24212: LIST
24213: LIST
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PPUSH
24219: CALL_OW 72
24223: ST_TO_ADDR
24224: GO 24227
24226: POP
// if i = 1 then
24227: LD_VAR 0 7
24231: PUSH
24232: LD_INT 1
24234: EQUAL
24235: IFFALSE 24346
// begin tmp := [ ] ;
24237: LD_ADDR_VAR 0 18
24241: PUSH
24242: EMPTY
24243: ST_TO_ADDR
// for j in f do
24244: LD_ADDR_VAR 0 8
24248: PUSH
24249: LD_VAR 0 11
24253: PUSH
24254: FOR_IN
24255: IFFALSE 24328
// if GetBType ( j ) = b_bunker then
24257: LD_VAR 0 8
24261: PPUSH
24262: CALL_OW 266
24266: PUSH
24267: LD_INT 32
24269: EQUAL
24270: IFFALSE 24297
// tmp := Insert ( tmp , 1 , j ) else
24272: LD_ADDR_VAR 0 18
24276: PUSH
24277: LD_VAR 0 18
24281: PPUSH
24282: LD_INT 1
24284: PPUSH
24285: LD_VAR 0 8
24289: PPUSH
24290: CALL_OW 2
24294: ST_TO_ADDR
24295: GO 24326
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24297: LD_ADDR_VAR 0 18
24301: PUSH
24302: LD_VAR 0 18
24306: PPUSH
24307: LD_VAR 0 18
24311: PUSH
24312: LD_INT 1
24314: PLUS
24315: PPUSH
24316: LD_VAR 0 8
24320: PPUSH
24321: CALL_OW 2
24325: ST_TO_ADDR
24326: GO 24254
24328: POP
24329: POP
// if tmp then
24330: LD_VAR 0 18
24334: IFFALSE 24346
// f := tmp ;
24336: LD_ADDR_VAR 0 11
24340: PUSH
24341: LD_VAR 0 18
24345: ST_TO_ADDR
// end ; x := personel [ i ] ;
24346: LD_ADDR_VAR 0 12
24350: PUSH
24351: LD_VAR 0 5
24355: PUSH
24356: LD_VAR 0 7
24360: ARRAY
24361: ST_TO_ADDR
// if x = - 1 then
24362: LD_VAR 0 12
24366: PUSH
24367: LD_INT 1
24369: NEG
24370: EQUAL
24371: IFFALSE 24580
// begin for j in f do
24373: LD_ADDR_VAR 0 8
24377: PUSH
24378: LD_VAR 0 11
24382: PUSH
24383: FOR_IN
24384: IFFALSE 24576
// repeat InitHc ;
24386: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24390: LD_VAR 0 8
24394: PPUSH
24395: CALL_OW 266
24399: PUSH
24400: LD_INT 5
24402: EQUAL
24403: IFFALSE 24473
// begin if UnitsInside ( j ) < 3 then
24405: LD_VAR 0 8
24409: PPUSH
24410: CALL_OW 313
24414: PUSH
24415: LD_INT 3
24417: LESS
24418: IFFALSE 24454
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24420: LD_INT 0
24422: PPUSH
24423: LD_INT 5
24425: PUSH
24426: LD_INT 8
24428: PUSH
24429: LD_INT 9
24431: PUSH
24432: EMPTY
24433: LIST
24434: LIST
24435: LIST
24436: PUSH
24437: LD_VAR 0 16
24441: ARRAY
24442: PPUSH
24443: LD_VAR 0 3
24447: PPUSH
24448: CALL_OW 380
24452: GO 24471
// PrepareHuman ( false , i , skill ) ;
24454: LD_INT 0
24456: PPUSH
24457: LD_VAR 0 7
24461: PPUSH
24462: LD_VAR 0 3
24466: PPUSH
24467: CALL_OW 380
// end else
24471: GO 24490
// PrepareHuman ( false , i , skill ) ;
24473: LD_INT 0
24475: PPUSH
24476: LD_VAR 0 7
24480: PPUSH
24481: LD_VAR 0 3
24485: PPUSH
24486: CALL_OW 380
// un := CreateHuman ;
24490: LD_ADDR_VAR 0 13
24494: PUSH
24495: CALL_OW 44
24499: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24500: LD_ADDR_VAR 0 6
24504: PUSH
24505: LD_VAR 0 6
24509: PPUSH
24510: LD_INT 1
24512: PPUSH
24513: LD_VAR 0 13
24517: PPUSH
24518: CALL_OW 2
24522: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24523: LD_VAR 0 13
24527: PPUSH
24528: LD_VAR 0 8
24532: PPUSH
24533: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24537: LD_VAR 0 8
24541: PPUSH
24542: CALL_OW 313
24546: PUSH
24547: LD_INT 6
24549: EQUAL
24550: PUSH
24551: LD_VAR 0 8
24555: PPUSH
24556: CALL_OW 266
24560: PUSH
24561: LD_INT 32
24563: PUSH
24564: LD_INT 31
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: IN
24571: OR
24572: IFFALSE 24386
24574: GO 24383
24576: POP
24577: POP
// end else
24578: GO 24960
// for j = 1 to x do
24580: LD_ADDR_VAR 0 8
24584: PUSH
24585: DOUBLE
24586: LD_INT 1
24588: DEC
24589: ST_TO_ADDR
24590: LD_VAR 0 12
24594: PUSH
24595: FOR_TO
24596: IFFALSE 24958
// begin InitHc ;
24598: CALL_OW 19
// if not f then
24602: LD_VAR 0 11
24606: NOT
24607: IFFALSE 24696
// begin PrepareHuman ( false , i , skill ) ;
24609: LD_INT 0
24611: PPUSH
24612: LD_VAR 0 7
24616: PPUSH
24617: LD_VAR 0 3
24621: PPUSH
24622: CALL_OW 380
// un := CreateHuman ;
24626: LD_ADDR_VAR 0 13
24630: PUSH
24631: CALL_OW 44
24635: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24636: LD_ADDR_VAR 0 6
24640: PUSH
24641: LD_VAR 0 6
24645: PPUSH
24646: LD_INT 1
24648: PPUSH
24649: LD_VAR 0 13
24653: PPUSH
24654: CALL_OW 2
24658: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24659: LD_VAR 0 13
24663: PPUSH
24664: LD_VAR 0 1
24668: PPUSH
24669: CALL_OW 250
24673: PPUSH
24674: LD_VAR 0 1
24678: PPUSH
24679: CALL_OW 251
24683: PPUSH
24684: LD_INT 10
24686: PPUSH
24687: LD_INT 0
24689: PPUSH
24690: CALL_OW 50
// continue ;
24694: GO 24595
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24696: LD_VAR 0 11
24700: PUSH
24701: LD_INT 1
24703: ARRAY
24704: PPUSH
24705: CALL_OW 313
24709: PUSH
24710: LD_VAR 0 11
24714: PUSH
24715: LD_INT 1
24717: ARRAY
24718: PPUSH
24719: CALL_OW 266
24723: PUSH
24724: LD_INT 32
24726: PUSH
24727: LD_INT 31
24729: PUSH
24730: EMPTY
24731: LIST
24732: LIST
24733: IN
24734: AND
24735: PUSH
24736: LD_VAR 0 11
24740: PUSH
24741: LD_INT 1
24743: ARRAY
24744: PPUSH
24745: CALL_OW 313
24749: PUSH
24750: LD_INT 6
24752: EQUAL
24753: OR
24754: IFFALSE 24774
// f := Delete ( f , 1 ) ;
24756: LD_ADDR_VAR 0 11
24760: PUSH
24761: LD_VAR 0 11
24765: PPUSH
24766: LD_INT 1
24768: PPUSH
24769: CALL_OW 3
24773: ST_TO_ADDR
// if not f then
24774: LD_VAR 0 11
24778: NOT
24779: IFFALSE 24797
// begin x := x + 2 ;
24781: LD_ADDR_VAR 0 12
24785: PUSH
24786: LD_VAR 0 12
24790: PUSH
24791: LD_INT 2
24793: PLUS
24794: ST_TO_ADDR
// continue ;
24795: GO 24595
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24797: LD_VAR 0 11
24801: PUSH
24802: LD_INT 1
24804: ARRAY
24805: PPUSH
24806: CALL_OW 266
24810: PUSH
24811: LD_INT 5
24813: EQUAL
24814: IFFALSE 24888
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24816: LD_VAR 0 11
24820: PUSH
24821: LD_INT 1
24823: ARRAY
24824: PPUSH
24825: CALL_OW 313
24829: PUSH
24830: LD_INT 3
24832: LESS
24833: IFFALSE 24869
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24835: LD_INT 0
24837: PPUSH
24838: LD_INT 5
24840: PUSH
24841: LD_INT 8
24843: PUSH
24844: LD_INT 9
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: LIST
24851: PUSH
24852: LD_VAR 0 16
24856: ARRAY
24857: PPUSH
24858: LD_VAR 0 3
24862: PPUSH
24863: CALL_OW 380
24867: GO 24886
// PrepareHuman ( false , i , skill ) ;
24869: LD_INT 0
24871: PPUSH
24872: LD_VAR 0 7
24876: PPUSH
24877: LD_VAR 0 3
24881: PPUSH
24882: CALL_OW 380
// end else
24886: GO 24905
// PrepareHuman ( false , i , skill ) ;
24888: LD_INT 0
24890: PPUSH
24891: LD_VAR 0 7
24895: PPUSH
24896: LD_VAR 0 3
24900: PPUSH
24901: CALL_OW 380
// un := CreateHuman ;
24905: LD_ADDR_VAR 0 13
24909: PUSH
24910: CALL_OW 44
24914: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24915: LD_ADDR_VAR 0 6
24919: PUSH
24920: LD_VAR 0 6
24924: PPUSH
24925: LD_INT 1
24927: PPUSH
24928: LD_VAR 0 13
24932: PPUSH
24933: CALL_OW 2
24937: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24938: LD_VAR 0 13
24942: PPUSH
24943: LD_VAR 0 11
24947: PUSH
24948: LD_INT 1
24950: ARRAY
24951: PPUSH
24952: CALL_OW 52
// end ;
24956: GO 24595
24958: POP
24959: POP
// end ;
24960: GO 23904
24962: POP
24963: POP
// result := result ^ buildings ;
24964: LD_ADDR_VAR 0 6
24968: PUSH
24969: LD_VAR 0 6
24973: PUSH
24974: LD_VAR 0 17
24978: ADD
24979: ST_TO_ADDR
// end else
24980: GO 25123
// begin for i = 1 to personel do
24982: LD_ADDR_VAR 0 7
24986: PUSH
24987: DOUBLE
24988: LD_INT 1
24990: DEC
24991: ST_TO_ADDR
24992: LD_VAR 0 5
24996: PUSH
24997: FOR_TO
24998: IFFALSE 25121
// begin if i > 4 then
25000: LD_VAR 0 7
25004: PUSH
25005: LD_INT 4
25007: GREATER
25008: IFFALSE 25012
// break ;
25010: GO 25121
// x := personel [ i ] ;
25012: LD_ADDR_VAR 0 12
25016: PUSH
25017: LD_VAR 0 5
25021: PUSH
25022: LD_VAR 0 7
25026: ARRAY
25027: ST_TO_ADDR
// if x = - 1 then
25028: LD_VAR 0 12
25032: PUSH
25033: LD_INT 1
25035: NEG
25036: EQUAL
25037: IFFALSE 25041
// continue ;
25039: GO 24997
// PrepareHuman ( false , i , skill ) ;
25041: LD_INT 0
25043: PPUSH
25044: LD_VAR 0 7
25048: PPUSH
25049: LD_VAR 0 3
25053: PPUSH
25054: CALL_OW 380
// un := CreateHuman ;
25058: LD_ADDR_VAR 0 13
25062: PUSH
25063: CALL_OW 44
25067: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25068: LD_VAR 0 13
25072: PPUSH
25073: LD_VAR 0 1
25077: PPUSH
25078: CALL_OW 250
25082: PPUSH
25083: LD_VAR 0 1
25087: PPUSH
25088: CALL_OW 251
25092: PPUSH
25093: LD_INT 10
25095: PPUSH
25096: LD_INT 0
25098: PPUSH
25099: CALL_OW 50
// result := result ^ un ;
25103: LD_ADDR_VAR 0 6
25107: PUSH
25108: LD_VAR 0 6
25112: PUSH
25113: LD_VAR 0 13
25117: ADD
25118: ST_TO_ADDR
// end ;
25119: GO 24997
25121: POP
25122: POP
// end ; end ;
25123: LD_VAR 0 6
25127: RET
// export function GetTurretWeapon ( tower ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25128: LD_INT 0
25130: PPUSH
25131: PPUSH
25132: PPUSH
25133: PPUSH
25134: PPUSH
25135: PPUSH
25136: PPUSH
25137: PPUSH
25138: PPUSH
25139: PPUSH
25140: PPUSH
25141: PPUSH
25142: PPUSH
25143: PPUSH
25144: PPUSH
25145: PPUSH
// result := false ;
25146: LD_ADDR_VAR 0 2
25150: PUSH
25151: LD_INT 0
25153: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25154: LD_VAR 0 1
25158: NOT
25159: PUSH
25160: LD_VAR 0 1
25164: PPUSH
25165: CALL_OW 266
25169: PUSH
25170: LD_INT 32
25172: PUSH
25173: LD_INT 33
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: IN
25180: NOT
25181: OR
25182: IFFALSE 25186
// exit ;
25184: GO 26317
// nat := GetNation ( tower ) ;
25186: LD_ADDR_VAR 0 11
25190: PUSH
25191: LD_VAR 0 1
25195: PPUSH
25196: CALL_OW 248
25200: ST_TO_ADDR
// side := GetSide ( tower ) ;
25201: LD_ADDR_VAR 0 15
25205: PUSH
25206: LD_VAR 0 1
25210: PPUSH
25211: CALL_OW 255
25215: ST_TO_ADDR
// x := GetX ( tower ) ;
25216: LD_ADDR_VAR 0 9
25220: PUSH
25221: LD_VAR 0 1
25225: PPUSH
25226: CALL_OW 250
25230: ST_TO_ADDR
// y := GetY ( tower ) ;
25231: LD_ADDR_VAR 0 10
25235: PUSH
25236: LD_VAR 0 1
25240: PPUSH
25241: CALL_OW 251
25245: ST_TO_ADDR
// if not x or not y then
25246: LD_VAR 0 9
25250: NOT
25251: PUSH
25252: LD_VAR 0 10
25256: NOT
25257: OR
25258: IFFALSE 25262
// exit ;
25260: GO 26317
// weapon := 0 ;
25262: LD_ADDR_VAR 0 17
25266: PUSH
25267: LD_INT 0
25269: ST_TO_ADDR
// fac_list := [ ] ;
25270: LD_ADDR_VAR 0 16
25274: PUSH
25275: EMPTY
25276: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) ) , [ f_btype , b_factory ] ) ;
25277: LD_ADDR_VAR 0 5
25281: PUSH
25282: LD_VAR 0 1
25286: PPUSH
25287: CALL_OW 274
25291: PPUSH
25292: CALL 23025 0 1
25296: PPUSH
25297: LD_INT 30
25299: PUSH
25300: LD_INT 3
25302: PUSH
25303: EMPTY
25304: LIST
25305: LIST
25306: PPUSH
25307: CALL_OW 72
25311: ST_TO_ADDR
// if not factories then
25312: LD_VAR 0 5
25316: NOT
25317: IFFALSE 25321
// exit ;
25319: GO 26317
// for i in factories do
25321: LD_ADDR_VAR 0 7
25325: PUSH
25326: LD_VAR 0 5
25330: PUSH
25331: FOR_IN
25332: IFFALSE 25357
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25334: LD_ADDR_VAR 0 16
25338: PUSH
25339: LD_VAR 0 16
25343: PUSH
25344: LD_VAR 0 7
25348: PPUSH
25349: CALL_OW 478
25353: UNION
25354: ST_TO_ADDR
25355: GO 25331
25357: POP
25358: POP
// if not fac_list then
25359: LD_VAR 0 16
25363: NOT
25364: IFFALSE 25368
// exit ;
25366: GO 26317
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25368: LD_ADDR_VAR 0 4
25372: PUSH
25373: LD_INT 4
25375: PUSH
25376: LD_INT 5
25378: PUSH
25379: LD_INT 9
25381: PUSH
25382: LD_INT 10
25384: PUSH
25385: LD_INT 6
25387: PUSH
25388: LD_INT 7
25390: PUSH
25391: LD_INT 11
25393: PUSH
25394: EMPTY
25395: LIST
25396: LIST
25397: LIST
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: PUSH
25403: LD_INT 27
25405: PUSH
25406: LD_INT 28
25408: PUSH
25409: LD_INT 26
25411: PUSH
25412: LD_INT 30
25414: PUSH
25415: EMPTY
25416: LIST
25417: LIST
25418: LIST
25419: LIST
25420: PUSH
25421: LD_INT 43
25423: PUSH
25424: LD_INT 44
25426: PUSH
25427: LD_INT 46
25429: PUSH
25430: LD_INT 45
25432: PUSH
25433: LD_INT 47
25435: PUSH
25436: LD_INT 49
25438: PUSH
25439: EMPTY
25440: LIST
25441: LIST
25442: LIST
25443: LIST
25444: LIST
25445: LIST
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: LIST
25451: PUSH
25452: LD_VAR 0 11
25456: ARRAY
25457: ST_TO_ADDR
// for i in list do
25458: LD_ADDR_VAR 0 7
25462: PUSH
25463: LD_VAR 0 4
25467: PUSH
25468: FOR_IN
25469: IFFALSE 25502
// if not i in fac_list then
25471: LD_VAR 0 7
25475: PUSH
25476: LD_VAR 0 16
25480: IN
25481: NOT
25482: IFFALSE 25500
// list := list diff i ;
25484: LD_ADDR_VAR 0 4
25488: PUSH
25489: LD_VAR 0 4
25493: PUSH
25494: LD_VAR 0 7
25498: DIFF
25499: ST_TO_ADDR
25500: GO 25468
25502: POP
25503: POP
// if not list then
25504: LD_VAR 0 4
25508: NOT
25509: IFFALSE 25513
// exit ;
25511: GO 26317
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25513: LD_VAR 0 11
25517: PUSH
25518: LD_INT 3
25520: EQUAL
25521: PUSH
25522: LD_INT 49
25524: PUSH
25525: LD_VAR 0 4
25529: IN
25530: AND
25531: PUSH
25532: LD_INT 31
25534: PPUSH
25535: LD_VAR 0 15
25539: PPUSH
25540: CALL_OW 321
25544: PUSH
25545: LD_INT 2
25547: EQUAL
25548: AND
25549: IFFALSE 25609
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25551: LD_INT 22
25553: PUSH
25554: LD_VAR 0 15
25558: PUSH
25559: EMPTY
25560: LIST
25561: LIST
25562: PUSH
25563: LD_INT 35
25565: PUSH
25566: LD_INT 49
25568: PUSH
25569: EMPTY
25570: LIST
25571: LIST
25572: PUSH
25573: LD_INT 91
25575: PUSH
25576: LD_VAR 0 1
25580: PUSH
25581: LD_INT 10
25583: PUSH
25584: EMPTY
25585: LIST
25586: LIST
25587: LIST
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: LIST
25593: PPUSH
25594: CALL_OW 69
25598: NOT
25599: IFFALSE 25609
// weapon := ru_time_lapser ;
25601: LD_ADDR_VAR 0 17
25605: PUSH
25606: LD_INT 49
25608: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25609: LD_VAR 0 11
25613: PUSH
25614: LD_INT 1
25616: PUSH
25617: LD_INT 2
25619: PUSH
25620: EMPTY
25621: LIST
25622: LIST
25623: IN
25624: PUSH
25625: LD_INT 11
25627: PUSH
25628: LD_VAR 0 4
25632: IN
25633: PUSH
25634: LD_INT 30
25636: PUSH
25637: LD_VAR 0 4
25641: IN
25642: OR
25643: AND
25644: PUSH
25645: LD_INT 6
25647: PPUSH
25648: LD_VAR 0 15
25652: PPUSH
25653: CALL_OW 321
25657: PUSH
25658: LD_INT 2
25660: EQUAL
25661: AND
25662: IFFALSE 25827
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25664: LD_INT 22
25666: PUSH
25667: LD_VAR 0 15
25671: PUSH
25672: EMPTY
25673: LIST
25674: LIST
25675: PUSH
25676: LD_INT 2
25678: PUSH
25679: LD_INT 35
25681: PUSH
25682: LD_INT 11
25684: PUSH
25685: EMPTY
25686: LIST
25687: LIST
25688: PUSH
25689: LD_INT 35
25691: PUSH
25692: LD_INT 30
25694: PUSH
25695: EMPTY
25696: LIST
25697: LIST
25698: PUSH
25699: EMPTY
25700: LIST
25701: LIST
25702: LIST
25703: PUSH
25704: LD_INT 91
25706: PUSH
25707: LD_VAR 0 1
25711: PUSH
25712: LD_INT 18
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: LIST
25719: PUSH
25720: EMPTY
25721: LIST
25722: LIST
25723: LIST
25724: PPUSH
25725: CALL_OW 69
25729: NOT
25730: PUSH
25731: LD_INT 22
25733: PUSH
25734: LD_VAR 0 15
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: PUSH
25743: LD_INT 2
25745: PUSH
25746: LD_INT 30
25748: PUSH
25749: LD_INT 32
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 30
25758: PUSH
25759: LD_INT 33
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: LIST
25770: PUSH
25771: LD_INT 91
25773: PUSH
25774: LD_VAR 0 1
25778: PUSH
25779: LD_INT 12
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: LIST
25786: PUSH
25787: EMPTY
25788: LIST
25789: LIST
25790: LIST
25791: PUSH
25792: EMPTY
25793: LIST
25794: PPUSH
25795: CALL_OW 69
25799: PUSH
25800: LD_INT 2
25802: GREATER
25803: AND
25804: IFFALSE 25827
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25806: LD_ADDR_VAR 0 17
25810: PUSH
25811: LD_INT 11
25813: PUSH
25814: LD_INT 30
25816: PUSH
25817: EMPTY
25818: LIST
25819: LIST
25820: PUSH
25821: LD_VAR 0 11
25825: ARRAY
25826: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25827: LD_VAR 0 17
25831: NOT
25832: PUSH
25833: LD_INT 40
25835: PPUSH
25836: LD_VAR 0 15
25840: PPUSH
25841: CALL_OW 321
25845: PUSH
25846: LD_INT 2
25848: EQUAL
25849: AND
25850: PUSH
25851: LD_INT 7
25853: PUSH
25854: LD_VAR 0 4
25858: IN
25859: PUSH
25860: LD_INT 28
25862: PUSH
25863: LD_VAR 0 4
25867: IN
25868: OR
25869: PUSH
25870: LD_INT 45
25872: PUSH
25873: LD_VAR 0 4
25877: IN
25878: OR
25879: AND
25880: IFFALSE 26134
// begin hex := GetHexInfo ( x , y ) ;
25882: LD_ADDR_VAR 0 3
25886: PUSH
25887: LD_VAR 0 9
25891: PPUSH
25892: LD_VAR 0 10
25896: PPUSH
25897: CALL_OW 546
25901: ST_TO_ADDR
// if hex [ 1 ] then
25902: LD_VAR 0 3
25906: PUSH
25907: LD_INT 1
25909: ARRAY
25910: IFFALSE 25914
// exit ;
25912: GO 26317
// height := hex [ 2 ] ;
25914: LD_ADDR_VAR 0 14
25918: PUSH
25919: LD_VAR 0 3
25923: PUSH
25924: LD_INT 2
25926: ARRAY
25927: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25928: LD_ADDR_VAR 0 13
25932: PUSH
25933: LD_INT 0
25935: PUSH
25936: LD_INT 2
25938: PUSH
25939: LD_INT 3
25941: PUSH
25942: LD_INT 5
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: LIST
25949: LIST
25950: ST_TO_ADDR
// for i in tmp do
25951: LD_ADDR_VAR 0 7
25955: PUSH
25956: LD_VAR 0 13
25960: PUSH
25961: FOR_IN
25962: IFFALSE 26132
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25964: LD_ADDR_VAR 0 8
25968: PUSH
25969: LD_VAR 0 9
25973: PPUSH
25974: LD_VAR 0 7
25978: PPUSH
25979: LD_INT 5
25981: PPUSH
25982: CALL_OW 272
25986: PUSH
25987: LD_VAR 0 10
25991: PPUSH
25992: LD_VAR 0 7
25996: PPUSH
25997: LD_INT 5
25999: PPUSH
26000: CALL_OW 273
26004: PUSH
26005: EMPTY
26006: LIST
26007: LIST
26008: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26009: LD_VAR 0 8
26013: PUSH
26014: LD_INT 1
26016: ARRAY
26017: PPUSH
26018: LD_VAR 0 8
26022: PUSH
26023: LD_INT 2
26025: ARRAY
26026: PPUSH
26027: CALL_OW 488
26031: IFFALSE 26130
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26033: LD_ADDR_VAR 0 3
26037: PUSH
26038: LD_VAR 0 8
26042: PUSH
26043: LD_INT 1
26045: ARRAY
26046: PPUSH
26047: LD_VAR 0 8
26051: PUSH
26052: LD_INT 2
26054: ARRAY
26055: PPUSH
26056: CALL_OW 546
26060: ST_TO_ADDR
// if hex [ 1 ] then
26061: LD_VAR 0 3
26065: PUSH
26066: LD_INT 1
26068: ARRAY
26069: IFFALSE 26073
// continue ;
26071: GO 25961
// h := hex [ 2 ] ;
26073: LD_ADDR_VAR 0 12
26077: PUSH
26078: LD_VAR 0 3
26082: PUSH
26083: LD_INT 2
26085: ARRAY
26086: ST_TO_ADDR
// if h + 7 < height then
26087: LD_VAR 0 12
26091: PUSH
26092: LD_INT 7
26094: PLUS
26095: PUSH
26096: LD_VAR 0 14
26100: LESS
26101: IFFALSE 26130
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26103: LD_ADDR_VAR 0 17
26107: PUSH
26108: LD_INT 7
26110: PUSH
26111: LD_INT 28
26113: PUSH
26114: LD_INT 45
26116: PUSH
26117: EMPTY
26118: LIST
26119: LIST
26120: LIST
26121: PUSH
26122: LD_VAR 0 11
26126: ARRAY
26127: ST_TO_ADDR
// break ;
26128: GO 26132
// end ; end ; end ;
26130: GO 25961
26132: POP
26133: POP
// end ; if not weapon then
26134: LD_VAR 0 17
26138: NOT
26139: IFFALSE 26199
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26141: LD_ADDR_VAR 0 4
26145: PUSH
26146: LD_VAR 0 4
26150: PUSH
26151: LD_INT 11
26153: PUSH
26154: LD_INT 30
26156: PUSH
26157: LD_INT 49
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: LIST
26164: DIFF
26165: ST_TO_ADDR
// if not list then
26166: LD_VAR 0 4
26170: NOT
26171: IFFALSE 26175
// exit ;
26173: GO 26317
// weapon := list [ rand ( 1 , list ) ] ;
26175: LD_ADDR_VAR 0 17
26179: PUSH
26180: LD_VAR 0 4
26184: PUSH
26185: LD_INT 1
26187: PPUSH
26188: LD_VAR 0 4
26192: PPUSH
26193: CALL_OW 12
26197: ARRAY
26198: ST_TO_ADDR
// end ; if weapon then
26199: LD_VAR 0 17
26203: IFFALSE 26317
// begin tmp := CostOfWeapon ( weapon ) ;
26205: LD_ADDR_VAR 0 13
26209: PUSH
26210: LD_VAR 0 17
26214: PPUSH
26215: CALL_OW 451
26219: ST_TO_ADDR
// j := GetBase ( tower ) ;
26220: LD_ADDR_VAR 0 8
26224: PUSH
26225: LD_VAR 0 1
26229: PPUSH
26230: CALL_OW 274
26234: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26235: LD_VAR 0 8
26239: PPUSH
26240: LD_INT 1
26242: PPUSH
26243: CALL_OW 275
26247: PUSH
26248: LD_VAR 0 13
26252: PUSH
26253: LD_INT 1
26255: ARRAY
26256: GREATEREQUAL
26257: PUSH
26258: LD_VAR 0 8
26262: PPUSH
26263: LD_INT 2
26265: PPUSH
26266: CALL_OW 275
26270: PUSH
26271: LD_VAR 0 13
26275: PUSH
26276: LD_INT 2
26278: ARRAY
26279: GREATEREQUAL
26280: AND
26281: PUSH
26282: LD_VAR 0 8
26286: PPUSH
26287: LD_INT 3
26289: PPUSH
26290: CALL_OW 275
26294: PUSH
26295: LD_VAR 0 13
26299: PUSH
26300: LD_INT 3
26302: ARRAY
26303: GREATEREQUAL
26304: AND
26305: IFFALSE 26317
// result := weapon ;
26307: LD_ADDR_VAR 0 2
26311: PUSH
26312: LD_VAR 0 17
26316: ST_TO_ADDR
// end ; end ;
26317: LD_VAR 0 2
26321: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26322: LD_INT 0
26324: PPUSH
26325: PPUSH
// result := true ;
26326: LD_ADDR_VAR 0 3
26330: PUSH
26331: LD_INT 1
26333: ST_TO_ADDR
// if array1 = array2 then
26334: LD_VAR 0 1
26338: PUSH
26339: LD_VAR 0 2
26343: EQUAL
26344: IFFALSE 26404
// begin for i = 1 to array1 do
26346: LD_ADDR_VAR 0 4
26350: PUSH
26351: DOUBLE
26352: LD_INT 1
26354: DEC
26355: ST_TO_ADDR
26356: LD_VAR 0 1
26360: PUSH
26361: FOR_TO
26362: IFFALSE 26400
// if array1 [ i ] <> array2 [ i ] then
26364: LD_VAR 0 1
26368: PUSH
26369: LD_VAR 0 4
26373: ARRAY
26374: PUSH
26375: LD_VAR 0 2
26379: PUSH
26380: LD_VAR 0 4
26384: ARRAY
26385: NONEQUAL
26386: IFFALSE 26398
// begin result := false ;
26388: LD_ADDR_VAR 0 3
26392: PUSH
26393: LD_INT 0
26395: ST_TO_ADDR
// break ;
26396: GO 26400
// end ;
26398: GO 26361
26400: POP
26401: POP
// end else
26402: GO 26412
// result := false ;
26404: LD_ADDR_VAR 0 3
26408: PUSH
26409: LD_INT 0
26411: ST_TO_ADDR
// end ;
26412: LD_VAR 0 3
26416: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26417: LD_INT 0
26419: PPUSH
26420: PPUSH
26421: PPUSH
// pom := GetBase ( fac ) ;
26422: LD_ADDR_VAR 0 5
26426: PUSH
26427: LD_VAR 0 1
26431: PPUSH
26432: CALL_OW 274
26436: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26437: LD_ADDR_VAR 0 4
26441: PUSH
26442: LD_VAR 0 2
26446: PUSH
26447: LD_INT 1
26449: ARRAY
26450: PPUSH
26451: LD_VAR 0 2
26455: PUSH
26456: LD_INT 2
26458: ARRAY
26459: PPUSH
26460: LD_VAR 0 2
26464: PUSH
26465: LD_INT 3
26467: ARRAY
26468: PPUSH
26469: LD_VAR 0 2
26473: PUSH
26474: LD_INT 4
26476: ARRAY
26477: PPUSH
26478: CALL_OW 449
26482: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26483: LD_ADDR_VAR 0 3
26487: PUSH
26488: LD_VAR 0 5
26492: PPUSH
26493: LD_INT 1
26495: PPUSH
26496: CALL_OW 275
26500: PUSH
26501: LD_VAR 0 4
26505: PUSH
26506: LD_INT 1
26508: ARRAY
26509: GREATEREQUAL
26510: PUSH
26511: LD_VAR 0 5
26515: PPUSH
26516: LD_INT 2
26518: PPUSH
26519: CALL_OW 275
26523: PUSH
26524: LD_VAR 0 4
26528: PUSH
26529: LD_INT 2
26531: ARRAY
26532: GREATEREQUAL
26533: AND
26534: PUSH
26535: LD_VAR 0 5
26539: PPUSH
26540: LD_INT 3
26542: PPUSH
26543: CALL_OW 275
26547: PUSH
26548: LD_VAR 0 4
26552: PUSH
26553: LD_INT 3
26555: ARRAY
26556: GREATEREQUAL
26557: AND
26558: ST_TO_ADDR
// end ;
26559: LD_VAR 0 3
26563: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26564: LD_INT 0
26566: PPUSH
26567: PPUSH
26568: PPUSH
26569: PPUSH
// pom := GetBase ( building ) ;
26570: LD_ADDR_VAR 0 3
26574: PUSH
26575: LD_VAR 0 1
26579: PPUSH
26580: CALL_OW 274
26584: ST_TO_ADDR
// if not pom then
26585: LD_VAR 0 3
26589: NOT
26590: IFFALSE 26594
// exit ;
26592: GO 26764
// btype := GetBType ( building ) ;
26594: LD_ADDR_VAR 0 5
26598: PUSH
26599: LD_VAR 0 1
26603: PPUSH
26604: CALL_OW 266
26608: ST_TO_ADDR
// if btype = b_armoury then
26609: LD_VAR 0 5
26613: PUSH
26614: LD_INT 4
26616: EQUAL
26617: IFFALSE 26627
// btype := b_barracks ;
26619: LD_ADDR_VAR 0 5
26623: PUSH
26624: LD_INT 5
26626: ST_TO_ADDR
// if btype = b_depot then
26627: LD_VAR 0 5
26631: PUSH
26632: LD_INT 0
26634: EQUAL
26635: IFFALSE 26645
// btype := b_warehouse ;
26637: LD_ADDR_VAR 0 5
26641: PUSH
26642: LD_INT 1
26644: ST_TO_ADDR
// if btype = b_workshop then
26645: LD_VAR 0 5
26649: PUSH
26650: LD_INT 2
26652: EQUAL
26653: IFFALSE 26663
// btype := b_factory ;
26655: LD_ADDR_VAR 0 5
26659: PUSH
26660: LD_INT 3
26662: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26663: LD_ADDR_VAR 0 4
26667: PUSH
26668: LD_VAR 0 5
26672: PPUSH
26673: LD_VAR 0 1
26677: PPUSH
26678: CALL_OW 248
26682: PPUSH
26683: CALL_OW 450
26687: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26688: LD_ADDR_VAR 0 2
26692: PUSH
26693: LD_VAR 0 3
26697: PPUSH
26698: LD_INT 1
26700: PPUSH
26701: CALL_OW 275
26705: PUSH
26706: LD_VAR 0 4
26710: PUSH
26711: LD_INT 1
26713: ARRAY
26714: GREATEREQUAL
26715: PUSH
26716: LD_VAR 0 3
26720: PPUSH
26721: LD_INT 2
26723: PPUSH
26724: CALL_OW 275
26728: PUSH
26729: LD_VAR 0 4
26733: PUSH
26734: LD_INT 2
26736: ARRAY
26737: GREATEREQUAL
26738: AND
26739: PUSH
26740: LD_VAR 0 3
26744: PPUSH
26745: LD_INT 3
26747: PPUSH
26748: CALL_OW 275
26752: PUSH
26753: LD_VAR 0 4
26757: PUSH
26758: LD_INT 3
26760: ARRAY
26761: GREATEREQUAL
26762: AND
26763: ST_TO_ADDR
// end ;
26764: LD_VAR 0 2
26768: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26769: LD_INT 0
26771: PPUSH
26772: PPUSH
26773: PPUSH
// pom := GetBase ( building ) ;
26774: LD_ADDR_VAR 0 4
26778: PUSH
26779: LD_VAR 0 1
26783: PPUSH
26784: CALL_OW 274
26788: ST_TO_ADDR
// if not pom then
26789: LD_VAR 0 4
26793: NOT
26794: IFFALSE 26798
// exit ;
26796: GO 26899
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26798: LD_ADDR_VAR 0 5
26802: PUSH
26803: LD_VAR 0 2
26807: PPUSH
26808: LD_VAR 0 1
26812: PPUSH
26813: CALL_OW 248
26817: PPUSH
26818: CALL_OW 450
26822: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26823: LD_ADDR_VAR 0 3
26827: PUSH
26828: LD_VAR 0 4
26832: PPUSH
26833: LD_INT 1
26835: PPUSH
26836: CALL_OW 275
26840: PUSH
26841: LD_VAR 0 5
26845: PUSH
26846: LD_INT 1
26848: ARRAY
26849: GREATEREQUAL
26850: PUSH
26851: LD_VAR 0 4
26855: PPUSH
26856: LD_INT 2
26858: PPUSH
26859: CALL_OW 275
26863: PUSH
26864: LD_VAR 0 5
26868: PUSH
26869: LD_INT 2
26871: ARRAY
26872: GREATEREQUAL
26873: AND
26874: PUSH
26875: LD_VAR 0 4
26879: PPUSH
26880: LD_INT 3
26882: PPUSH
26883: CALL_OW 275
26887: PUSH
26888: LD_VAR 0 5
26892: PUSH
26893: LD_INT 3
26895: ARRAY
26896: GREATEREQUAL
26897: AND
26898: ST_TO_ADDR
// end ;
26899: LD_VAR 0 3
26903: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
26904: LD_INT 0
26906: PPUSH
26907: PPUSH
26908: PPUSH
26909: PPUSH
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
26914: PPUSH
26915: PPUSH
// result := false ;
26916: LD_ADDR_VAR 0 6
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// if not base or not btype or not x or not y then
26924: LD_VAR 0 1
26928: NOT
26929: PUSH
26930: LD_VAR 0 2
26934: NOT
26935: OR
26936: PUSH
26937: LD_VAR 0 3
26941: NOT
26942: OR
26943: PUSH
26944: LD_VAR 0 4
26948: NOT
26949: OR
26950: IFFALSE 26954
// exit ;
26952: GO 27468
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26954: LD_ADDR_VAR 0 12
26958: PUSH
26959: LD_VAR 0 2
26963: PPUSH
26964: LD_VAR 0 3
26968: PPUSH
26969: LD_VAR 0 4
26973: PPUSH
26974: LD_VAR 0 5
26978: PPUSH
26979: LD_VAR 0 1
26983: PUSH
26984: LD_INT 1
26986: ARRAY
26987: PPUSH
26988: CALL_OW 248
26992: PPUSH
26993: LD_INT 0
26995: PPUSH
26996: CALL 28297 0 6
27000: ST_TO_ADDR
// if not hexes then
27001: LD_VAR 0 12
27005: NOT
27006: IFFALSE 27010
// exit ;
27008: GO 27468
// for i = 1 to hexes do
27010: LD_ADDR_VAR 0 7
27014: PUSH
27015: DOUBLE
27016: LD_INT 1
27018: DEC
27019: ST_TO_ADDR
27020: LD_VAR 0 12
27024: PUSH
27025: FOR_TO
27026: IFFALSE 27466
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27028: LD_ADDR_VAR 0 11
27032: PUSH
27033: LD_VAR 0 12
27037: PUSH
27038: LD_VAR 0 7
27042: ARRAY
27043: PUSH
27044: LD_INT 1
27046: ARRAY
27047: PPUSH
27048: LD_VAR 0 12
27052: PUSH
27053: LD_VAR 0 7
27057: ARRAY
27058: PUSH
27059: LD_INT 2
27061: ARRAY
27062: PPUSH
27063: CALL_OW 428
27067: ST_TO_ADDR
// if not tmp or GetType ( tmp ) = unit_building then
27068: LD_VAR 0 11
27072: NOT
27073: PUSH
27074: LD_VAR 0 11
27078: PPUSH
27079: CALL_OW 247
27083: PUSH
27084: LD_INT 3
27086: EQUAL
27087: OR
27088: IFFALSE 27092
// continue ;
27090: GO 27025
// result := true ;
27092: LD_ADDR_VAR 0 6
27096: PUSH
27097: LD_INT 1
27099: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27100: LD_ADDR_VAR 0 15
27104: PUSH
27105: LD_INT 22
27107: PUSH
27108: LD_VAR 0 11
27112: PPUSH
27113: CALL_OW 255
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PUSH
27122: LD_INT 2
27124: PUSH
27125: LD_INT 30
27127: PUSH
27128: LD_INT 0
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: PUSH
27135: LD_INT 30
27137: PUSH
27138: LD_INT 1
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: EMPTY
27146: LIST
27147: LIST
27148: LIST
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: PPUSH
27154: CALL_OW 69
27158: ST_TO_ADDR
// if dep then
27159: LD_VAR 0 15
27163: IFFALSE 27299
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27165: LD_ADDR_VAR 0 14
27169: PUSH
27170: LD_VAR 0 15
27174: PUSH
27175: LD_INT 1
27177: ARRAY
27178: PPUSH
27179: CALL_OW 250
27183: PPUSH
27184: LD_VAR 0 15
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: CALL_OW 254
27197: PPUSH
27198: LD_INT 5
27200: PPUSH
27201: CALL_OW 272
27205: PUSH
27206: LD_VAR 0 15
27210: PUSH
27211: LD_INT 1
27213: ARRAY
27214: PPUSH
27215: CALL_OW 251
27219: PPUSH
27220: LD_VAR 0 15
27224: PUSH
27225: LD_INT 1
27227: ARRAY
27228: PPUSH
27229: CALL_OW 254
27233: PPUSH
27234: LD_INT 5
27236: PPUSH
27237: CALL_OW 273
27241: PUSH
27242: EMPTY
27243: LIST
27244: LIST
27245: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27246: LD_VAR 0 14
27250: PUSH
27251: LD_INT 1
27253: ARRAY
27254: PPUSH
27255: LD_VAR 0 14
27259: PUSH
27260: LD_INT 2
27262: ARRAY
27263: PPUSH
27264: CALL_OW 488
27268: IFFALSE 27299
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27270: LD_VAR 0 11
27274: PPUSH
27275: LD_VAR 0 14
27279: PUSH
27280: LD_INT 1
27282: ARRAY
27283: PPUSH
27284: LD_VAR 0 14
27288: PUSH
27289: LD_INT 2
27291: ARRAY
27292: PPUSH
27293: CALL_OW 111
// continue ;
27297: GO 27025
// end ; end ; r := GetDir ( tmp ) ;
27299: LD_ADDR_VAR 0 13
27303: PUSH
27304: LD_VAR 0 11
27308: PPUSH
27309: CALL_OW 254
27313: ST_TO_ADDR
// if r = 5 then
27314: LD_VAR 0 13
27318: PUSH
27319: LD_INT 5
27321: EQUAL
27322: IFFALSE 27332
// r := 0 ;
27324: LD_ADDR_VAR 0 13
27328: PUSH
27329: LD_INT 0
27331: ST_TO_ADDR
// for j = r to 5 do
27332: LD_ADDR_VAR 0 8
27336: PUSH
27337: DOUBLE
27338: LD_VAR 0 13
27342: DEC
27343: ST_TO_ADDR
27344: LD_INT 5
27346: PUSH
27347: FOR_TO
27348: IFFALSE 27462
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27350: LD_ADDR_VAR 0 9
27354: PUSH
27355: LD_VAR 0 11
27359: PPUSH
27360: CALL_OW 250
27364: PPUSH
27365: LD_VAR 0 8
27369: PPUSH
27370: LD_INT 2
27372: PPUSH
27373: CALL_OW 272
27377: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27378: LD_ADDR_VAR 0 10
27382: PUSH
27383: LD_VAR 0 11
27387: PPUSH
27388: CALL_OW 251
27392: PPUSH
27393: LD_VAR 0 8
27397: PPUSH
27398: LD_INT 2
27400: PPUSH
27401: CALL_OW 273
27405: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27406: LD_VAR 0 9
27410: PPUSH
27411: LD_VAR 0 10
27415: PPUSH
27416: CALL_OW 488
27420: PUSH
27421: LD_VAR 0 9
27425: PPUSH
27426: LD_VAR 0 10
27430: PPUSH
27431: CALL_OW 428
27435: NOT
27436: AND
27437: IFFALSE 27460
// begin ComMoveXY ( tmp , _x , _y ) ;
27439: LD_VAR 0 11
27443: PPUSH
27444: LD_VAR 0 9
27448: PPUSH
27449: LD_VAR 0 10
27453: PPUSH
27454: CALL_OW 111
// break ;
27458: GO 27462
// end ; end ;
27460: GO 27347
27462: POP
27463: POP
// end ;
27464: GO 27025
27466: POP
27467: POP
// end ;
27468: LD_VAR 0 6
27472: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , pom , cost , hexes , height , dist , hex ; begin
27473: LD_INT 0
27475: PPUSH
27476: PPUSH
27477: PPUSH
27478: PPUSH
27479: PPUSH
27480: PPUSH
27481: PPUSH
27482: PPUSH
27483: PPUSH
// result := false ;
27484: LD_ADDR_VAR 0 6
27488: PUSH
27489: LD_INT 0
27491: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27492: LD_VAR 0 1
27496: NOT
27497: PUSH
27498: LD_VAR 0 1
27502: PPUSH
27503: CALL_OW 266
27507: PUSH
27508: LD_INT 0
27510: PUSH
27511: LD_INT 1
27513: PUSH
27514: EMPTY
27515: LIST
27516: LIST
27517: IN
27518: NOT
27519: OR
27520: PUSH
27521: LD_VAR 0 2
27525: NOT
27526: OR
27527: PUSH
27528: LD_VAR 0 5
27532: PUSH
27533: LD_INT 0
27535: PUSH
27536: LD_INT 1
27538: PUSH
27539: LD_INT 2
27541: PUSH
27542: LD_INT 3
27544: PUSH
27545: LD_INT 4
27547: PUSH
27548: LD_INT 5
27550: PUSH
27551: EMPTY
27552: LIST
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: LIST
27558: IN
27559: NOT
27560: OR
27561: PUSH
27562: LD_VAR 0 3
27566: PPUSH
27567: LD_VAR 0 4
27571: PPUSH
27572: CALL_OW 488
27576: NOT
27577: OR
27578: IFFALSE 27582
// exit ;
27580: GO 28292
// pom := GetBase ( bdepot ) ;
27582: LD_ADDR_VAR 0 9
27586: PUSH
27587: LD_VAR 0 1
27591: PPUSH
27592: CALL_OW 274
27596: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
27597: LD_ADDR_VAR 0 10
27601: PUSH
27602: LD_VAR 0 2
27606: PPUSH
27607: LD_VAR 0 1
27611: PPUSH
27612: CALL_OW 248
27616: PPUSH
27617: CALL_OW 450
27621: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27622: LD_VAR 0 9
27626: PPUSH
27627: LD_INT 1
27629: PPUSH
27630: CALL_OW 275
27634: PUSH
27635: LD_VAR 0 10
27639: PUSH
27640: LD_INT 1
27642: ARRAY
27643: GREATEREQUAL
27644: PUSH
27645: LD_VAR 0 9
27649: PPUSH
27650: LD_INT 2
27652: PPUSH
27653: CALL_OW 275
27657: PUSH
27658: LD_VAR 0 10
27662: PUSH
27663: LD_INT 2
27665: ARRAY
27666: GREATEREQUAL
27667: AND
27668: PUSH
27669: LD_VAR 0 9
27673: PPUSH
27674: LD_INT 3
27676: PPUSH
27677: CALL_OW 275
27681: PUSH
27682: LD_VAR 0 10
27686: PUSH
27687: LD_INT 3
27689: ARRAY
27690: GREATEREQUAL
27691: AND
27692: NOT
27693: IFFALSE 27697
// exit ;
27695: GO 28292
// if GetBType ( bdepot ) = b_depot then
27697: LD_VAR 0 1
27701: PPUSH
27702: CALL_OW 266
27706: PUSH
27707: LD_INT 0
27709: EQUAL
27710: IFFALSE 27722
// dist := 28 else
27712: LD_ADDR_VAR 0 13
27716: PUSH
27717: LD_INT 28
27719: ST_TO_ADDR
27720: GO 27730
// dist := 36 ;
27722: LD_ADDR_VAR 0 13
27726: PUSH
27727: LD_INT 36
27729: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
27730: LD_VAR 0 1
27734: PPUSH
27735: LD_VAR 0 3
27739: PPUSH
27740: LD_VAR 0 4
27744: PPUSH
27745: CALL_OW 297
27749: PUSH
27750: LD_VAR 0 13
27754: GREATER
27755: IFFALSE 27759
// exit ;
27757: GO 28292
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
27759: LD_ADDR_VAR 0 11
27763: PUSH
27764: LD_VAR 0 2
27768: PPUSH
27769: LD_VAR 0 3
27773: PPUSH
27774: LD_VAR 0 4
27778: PPUSH
27779: LD_VAR 0 5
27783: PPUSH
27784: LD_VAR 0 1
27788: PPUSH
27789: CALL_OW 248
27793: PPUSH
27794: LD_INT 0
27796: PPUSH
27797: CALL 28297 0 6
27801: ST_TO_ADDR
// if not hexes then
27802: LD_VAR 0 11
27806: NOT
27807: IFFALSE 27811
// exit ;
27809: GO 28292
// hex := GetHexInfo ( x , y ) ;
27811: LD_ADDR_VAR 0 14
27815: PUSH
27816: LD_VAR 0 3
27820: PPUSH
27821: LD_VAR 0 4
27825: PPUSH
27826: CALL_OW 546
27830: ST_TO_ADDR
// if hex [ 1 ] then
27831: LD_VAR 0 14
27835: PUSH
27836: LD_INT 1
27838: ARRAY
27839: IFFALSE 27843
// exit ;
27841: GO 28292
// height := hex [ 2 ] ;
27843: LD_ADDR_VAR 0 12
27847: PUSH
27848: LD_VAR 0 14
27852: PUSH
27853: LD_INT 2
27855: ARRAY
27856: ST_TO_ADDR
// for i = 1 to hexes do
27857: LD_ADDR_VAR 0 7
27861: PUSH
27862: DOUBLE
27863: LD_INT 1
27865: DEC
27866: ST_TO_ADDR
27867: LD_VAR 0 11
27871: PUSH
27872: FOR_TO
27873: IFFALSE 28201
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27875: LD_VAR 0 11
27879: PUSH
27880: LD_VAR 0 7
27884: ARRAY
27885: PUSH
27886: LD_INT 1
27888: ARRAY
27889: PPUSH
27890: LD_VAR 0 11
27894: PUSH
27895: LD_VAR 0 7
27899: ARRAY
27900: PUSH
27901: LD_INT 2
27903: ARRAY
27904: PPUSH
27905: CALL_OW 488
27909: NOT
27910: IFFALSE 27914
// continue ;
27912: GO 27872
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27914: LD_ADDR_VAR 0 8
27918: PUSH
27919: LD_VAR 0 11
27923: PUSH
27924: LD_VAR 0 7
27928: ARRAY
27929: PUSH
27930: LD_INT 1
27932: ARRAY
27933: PPUSH
27934: LD_VAR 0 11
27938: PUSH
27939: LD_VAR 0 7
27943: ARRAY
27944: PUSH
27945: LD_INT 2
27947: ARRAY
27948: PPUSH
27949: CALL_OW 546
27953: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27954: LD_VAR 0 8
27958: PUSH
27959: LD_INT 1
27961: ARRAY
27962: PUSH
27963: LD_VAR 0 8
27967: PUSH
27968: LD_INT 2
27970: ARRAY
27971: PUSH
27972: LD_VAR 0 12
27976: PUSH
27977: LD_INT 2
27979: PLUS
27980: GREATER
27981: OR
27982: PUSH
27983: LD_VAR 0 8
27987: PUSH
27988: LD_INT 2
27990: ARRAY
27991: PUSH
27992: LD_VAR 0 12
27996: PUSH
27997: LD_INT 2
27999: MINUS
28000: LESS
28001: OR
28002: PUSH
28003: LD_VAR 0 8
28007: PUSH
28008: LD_INT 3
28010: ARRAY
28011: PUSH
28012: LD_INT 0
28014: PUSH
28015: LD_INT 8
28017: PUSH
28018: LD_INT 9
28020: PUSH
28021: LD_INT 10
28023: PUSH
28024: LD_INT 11
28026: PUSH
28027: LD_INT 12
28029: PUSH
28030: LD_INT 13
28032: PUSH
28033: LD_INT 16
28035: PUSH
28036: LD_INT 17
28038: PUSH
28039: LD_INT 18
28041: PUSH
28042: LD_INT 19
28044: PUSH
28045: LD_INT 20
28047: PUSH
28048: LD_INT 21
28050: PUSH
28051: EMPTY
28052: LIST
28053: LIST
28054: LIST
28055: LIST
28056: LIST
28057: LIST
28058: LIST
28059: LIST
28060: LIST
28061: LIST
28062: LIST
28063: LIST
28064: LIST
28065: IN
28066: NOT
28067: OR
28068: PUSH
28069: LD_VAR 0 8
28073: PUSH
28074: LD_INT 5
28076: ARRAY
28077: NOT
28078: OR
28079: PUSH
28080: LD_VAR 0 8
28084: PUSH
28085: LD_INT 6
28087: ARRAY
28088: PUSH
28089: LD_INT 1
28091: PUSH
28092: LD_INT 2
28094: PUSH
28095: LD_INT 7
28097: PUSH
28098: LD_INT 9
28100: PUSH
28101: LD_INT 10
28103: PUSH
28104: LD_INT 11
28106: PUSH
28107: EMPTY
28108: LIST
28109: LIST
28110: LIST
28111: LIST
28112: LIST
28113: LIST
28114: IN
28115: NOT
28116: OR
28117: PUSH
28118: LD_VAR 0 11
28122: PUSH
28123: LD_VAR 0 7
28127: ARRAY
28128: PUSH
28129: LD_INT 1
28131: ARRAY
28132: PPUSH
28133: LD_VAR 0 11
28137: PUSH
28138: LD_VAR 0 7
28142: ARRAY
28143: PUSH
28144: LD_INT 2
28146: ARRAY
28147: PPUSH
28148: CALL_OW 428
28152: PUSH
28153: LD_INT 0
28155: GREATER
28156: OR
28157: PUSH
28158: LD_VAR 0 11
28162: PUSH
28163: LD_VAR 0 7
28167: ARRAY
28168: PUSH
28169: LD_INT 1
28171: ARRAY
28172: PPUSH
28173: LD_VAR 0 11
28177: PUSH
28178: LD_VAR 0 7
28182: ARRAY
28183: PUSH
28184: LD_INT 2
28186: ARRAY
28187: PPUSH
28188: CALL_OW 351
28192: OR
28193: IFFALSE 28199
// exit ;
28195: POP
28196: POP
28197: GO 28292
// end ;
28199: GO 27872
28201: POP
28202: POP
// if DangerAtRangeXY ( GetSide ( bdepot ) , x , y , 20 ) [ 4 ] then
28203: LD_VAR 0 1
28207: PPUSH
28208: CALL_OW 255
28212: PPUSH
28213: LD_VAR 0 3
28217: PPUSH
28218: LD_VAR 0 4
28222: PPUSH
28223: LD_INT 20
28225: PPUSH
28226: CALL 21179 0 4
28230: PUSH
28231: LD_INT 4
28233: ARRAY
28234: IFFALSE 28238
// exit ;
28236: GO 28292
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , GetSide ( bdepot ) ) then
28238: LD_VAR 0 2
28242: PUSH
28243: LD_INT 29
28245: PUSH
28246: LD_INT 30
28248: PUSH
28249: EMPTY
28250: LIST
28251: LIST
28252: IN
28253: PUSH
28254: LD_VAR 0 3
28258: PPUSH
28259: LD_VAR 0 4
28263: PPUSH
28264: LD_VAR 0 1
28268: PPUSH
28269: CALL_OW 255
28273: PPUSH
28274: CALL_OW 440
28278: NOT
28279: AND
28280: IFFALSE 28284
// exit ;
28282: GO 28292
// result := true ;
28284: LD_ADDR_VAR 0 6
28288: PUSH
28289: LD_INT 1
28291: ST_TO_ADDR
// end ;
28292: LD_VAR 0 6
28296: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28297: LD_INT 0
28299: PPUSH
28300: PPUSH
28301: PPUSH
28302: PPUSH
28303: PPUSH
28304: PPUSH
28305: PPUSH
28306: PPUSH
28307: PPUSH
28308: PPUSH
28309: PPUSH
28310: PPUSH
28311: PPUSH
28312: PPUSH
28313: PPUSH
28314: PPUSH
28315: PPUSH
28316: PPUSH
28317: PPUSH
28318: PPUSH
28319: PPUSH
28320: PPUSH
28321: PPUSH
28322: PPUSH
28323: PPUSH
28324: PPUSH
28325: PPUSH
28326: PPUSH
28327: PPUSH
28328: PPUSH
28329: PPUSH
28330: PPUSH
28331: PPUSH
28332: PPUSH
28333: PPUSH
28334: PPUSH
28335: PPUSH
28336: PPUSH
28337: PPUSH
28338: PPUSH
28339: PPUSH
28340: PPUSH
28341: PPUSH
28342: PPUSH
28343: PPUSH
28344: PPUSH
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
// result = [ ] ;
28357: LD_ADDR_VAR 0 7
28361: PUSH
28362: EMPTY
28363: ST_TO_ADDR
// temp_list = [ ] ;
28364: LD_ADDR_VAR 0 9
28368: PUSH
28369: EMPTY
28370: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28371: LD_VAR 0 4
28375: PUSH
28376: LD_INT 0
28378: PUSH
28379: LD_INT 1
28381: PUSH
28382: LD_INT 2
28384: PUSH
28385: LD_INT 3
28387: PUSH
28388: LD_INT 4
28390: PUSH
28391: LD_INT 5
28393: PUSH
28394: EMPTY
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: IN
28402: NOT
28403: PUSH
28404: LD_VAR 0 1
28408: PUSH
28409: LD_INT 0
28411: PUSH
28412: LD_INT 1
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: IN
28419: PUSH
28420: LD_VAR 0 5
28424: PUSH
28425: LD_INT 1
28427: PUSH
28428: LD_INT 2
28430: PUSH
28431: LD_INT 3
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: LIST
28438: IN
28439: NOT
28440: AND
28441: OR
28442: IFFALSE 28446
// exit ;
28444: GO 46831
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28446: LD_VAR 0 1
28450: PUSH
28451: LD_INT 6
28453: PUSH
28454: LD_INT 7
28456: PUSH
28457: LD_INT 8
28459: PUSH
28460: LD_INT 13
28462: PUSH
28463: LD_INT 12
28465: PUSH
28466: LD_INT 15
28468: PUSH
28469: LD_INT 11
28471: PUSH
28472: LD_INT 14
28474: PUSH
28475: LD_INT 10
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: LIST
28482: LIST
28483: LIST
28484: LIST
28485: LIST
28486: LIST
28487: LIST
28488: IN
28489: IFFALSE 28499
// btype = b_lab ;
28491: LD_ADDR_VAR 0 1
28495: PUSH
28496: LD_INT 6
28498: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28499: LD_VAR 0 6
28503: PUSH
28504: LD_INT 0
28506: PUSH
28507: LD_INT 1
28509: PUSH
28510: LD_INT 2
28512: PUSH
28513: EMPTY
28514: LIST
28515: LIST
28516: LIST
28517: IN
28518: NOT
28519: PUSH
28520: LD_VAR 0 1
28524: PUSH
28525: LD_INT 0
28527: PUSH
28528: LD_INT 1
28530: PUSH
28531: LD_INT 2
28533: PUSH
28534: LD_INT 3
28536: PUSH
28537: LD_INT 6
28539: PUSH
28540: LD_INT 36
28542: PUSH
28543: LD_INT 4
28545: PUSH
28546: LD_INT 5
28548: PUSH
28549: LD_INT 31
28551: PUSH
28552: LD_INT 32
28554: PUSH
28555: LD_INT 33
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: LIST
28562: LIST
28563: LIST
28564: LIST
28565: LIST
28566: LIST
28567: LIST
28568: LIST
28569: LIST
28570: IN
28571: NOT
28572: PUSH
28573: LD_VAR 0 6
28577: PUSH
28578: LD_INT 1
28580: EQUAL
28581: AND
28582: OR
28583: PUSH
28584: LD_VAR 0 1
28588: PUSH
28589: LD_INT 2
28591: PUSH
28592: LD_INT 3
28594: PUSH
28595: EMPTY
28596: LIST
28597: LIST
28598: IN
28599: NOT
28600: PUSH
28601: LD_VAR 0 6
28605: PUSH
28606: LD_INT 2
28608: EQUAL
28609: AND
28610: OR
28611: IFFALSE 28621
// mode = 0 ;
28613: LD_ADDR_VAR 0 6
28617: PUSH
28618: LD_INT 0
28620: ST_TO_ADDR
// case mode of 0 :
28621: LD_VAR 0 6
28625: PUSH
28626: LD_INT 0
28628: DOUBLE
28629: EQUAL
28630: IFTRUE 28634
28632: GO 40087
28634: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28635: LD_ADDR_VAR 0 11
28639: PUSH
28640: LD_INT 0
28642: PUSH
28643: LD_INT 0
28645: PUSH
28646: EMPTY
28647: LIST
28648: LIST
28649: PUSH
28650: LD_INT 0
28652: PUSH
28653: LD_INT 1
28655: NEG
28656: PUSH
28657: EMPTY
28658: LIST
28659: LIST
28660: PUSH
28661: LD_INT 1
28663: PUSH
28664: LD_INT 0
28666: PUSH
28667: EMPTY
28668: LIST
28669: LIST
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: LD_INT 1
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 0
28683: PUSH
28684: LD_INT 1
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PUSH
28691: LD_INT 1
28693: NEG
28694: PUSH
28695: LD_INT 0
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 1
28704: NEG
28705: PUSH
28706: LD_INT 1
28708: NEG
28709: PUSH
28710: EMPTY
28711: LIST
28712: LIST
28713: PUSH
28714: LD_INT 1
28716: NEG
28717: PUSH
28718: LD_INT 2
28720: NEG
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 0
28728: PUSH
28729: LD_INT 2
28731: NEG
28732: PUSH
28733: EMPTY
28734: LIST
28735: LIST
28736: PUSH
28737: LD_INT 1
28739: PUSH
28740: LD_INT 1
28742: NEG
28743: PUSH
28744: EMPTY
28745: LIST
28746: LIST
28747: PUSH
28748: LD_INT 1
28750: PUSH
28751: LD_INT 2
28753: PUSH
28754: EMPTY
28755: LIST
28756: LIST
28757: PUSH
28758: LD_INT 0
28760: PUSH
28761: LD_INT 2
28763: PUSH
28764: EMPTY
28765: LIST
28766: LIST
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: LD_INT 1
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: PUSH
28779: LD_INT 1
28781: PUSH
28782: LD_INT 3
28784: PUSH
28785: EMPTY
28786: LIST
28787: LIST
28788: PUSH
28789: LD_INT 0
28791: PUSH
28792: LD_INT 3
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: PUSH
28799: LD_INT 1
28801: NEG
28802: PUSH
28803: LD_INT 2
28805: PUSH
28806: EMPTY
28807: LIST
28808: LIST
28809: PUSH
28810: EMPTY
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: LIST
28825: LIST
28826: LIST
28827: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28828: LD_ADDR_VAR 0 12
28832: PUSH
28833: LD_INT 0
28835: PUSH
28836: LD_INT 0
28838: PUSH
28839: EMPTY
28840: LIST
28841: LIST
28842: PUSH
28843: LD_INT 0
28845: PUSH
28846: LD_INT 1
28848: NEG
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: PUSH
28854: LD_INT 1
28856: PUSH
28857: LD_INT 0
28859: PUSH
28860: EMPTY
28861: LIST
28862: LIST
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: LD_INT 1
28869: PUSH
28870: EMPTY
28871: LIST
28872: LIST
28873: PUSH
28874: LD_INT 0
28876: PUSH
28877: LD_INT 1
28879: PUSH
28880: EMPTY
28881: LIST
28882: LIST
28883: PUSH
28884: LD_INT 1
28886: NEG
28887: PUSH
28888: LD_INT 0
28890: PUSH
28891: EMPTY
28892: LIST
28893: LIST
28894: PUSH
28895: LD_INT 1
28897: NEG
28898: PUSH
28899: LD_INT 1
28901: NEG
28902: PUSH
28903: EMPTY
28904: LIST
28905: LIST
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: LD_INT 1
28912: NEG
28913: PUSH
28914: EMPTY
28915: LIST
28916: LIST
28917: PUSH
28918: LD_INT 2
28920: PUSH
28921: LD_INT 0
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 2
28930: PUSH
28931: LD_INT 1
28933: PUSH
28934: EMPTY
28935: LIST
28936: LIST
28937: PUSH
28938: LD_INT 1
28940: NEG
28941: PUSH
28942: LD_INT 1
28944: PUSH
28945: EMPTY
28946: LIST
28947: LIST
28948: PUSH
28949: LD_INT 2
28951: NEG
28952: PUSH
28953: LD_INT 0
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 2
28962: NEG
28963: PUSH
28964: LD_INT 1
28966: NEG
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 2
28974: NEG
28975: PUSH
28976: LD_INT 1
28978: PUSH
28979: EMPTY
28980: LIST
28981: LIST
28982: PUSH
28983: LD_INT 3
28985: NEG
28986: PUSH
28987: LD_INT 0
28989: PUSH
28990: EMPTY
28991: LIST
28992: LIST
28993: PUSH
28994: LD_INT 3
28996: NEG
28997: PUSH
28998: LD_INT 1
29000: NEG
29001: PUSH
29002: EMPTY
29003: LIST
29004: LIST
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29024: LD_ADDR_VAR 0 13
29028: PUSH
29029: LD_INT 0
29031: PUSH
29032: LD_INT 0
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: NEG
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: PUSH
29050: LD_INT 1
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: PUSH
29063: LD_INT 1
29065: PUSH
29066: EMPTY
29067: LIST
29068: LIST
29069: PUSH
29070: LD_INT 0
29072: PUSH
29073: LD_INT 1
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: PUSH
29080: LD_INT 1
29082: NEG
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: LD_INT 1
29097: NEG
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PUSH
29103: LD_INT 1
29105: NEG
29106: PUSH
29107: LD_INT 2
29109: NEG
29110: PUSH
29111: EMPTY
29112: LIST
29113: LIST
29114: PUSH
29115: LD_INT 2
29117: PUSH
29118: LD_INT 1
29120: PUSH
29121: EMPTY
29122: LIST
29123: LIST
29124: PUSH
29125: LD_INT 2
29127: PUSH
29128: LD_INT 2
29130: PUSH
29131: EMPTY
29132: LIST
29133: LIST
29134: PUSH
29135: LD_INT 1
29137: PUSH
29138: LD_INT 2
29140: PUSH
29141: EMPTY
29142: LIST
29143: LIST
29144: PUSH
29145: LD_INT 2
29147: NEG
29148: PUSH
29149: LD_INT 1
29151: NEG
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 2
29159: NEG
29160: PUSH
29161: LD_INT 2
29163: NEG
29164: PUSH
29165: EMPTY
29166: LIST
29167: LIST
29168: PUSH
29169: LD_INT 2
29171: NEG
29172: PUSH
29173: LD_INT 3
29175: NEG
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 3
29183: NEG
29184: PUSH
29185: LD_INT 2
29187: NEG
29188: PUSH
29189: EMPTY
29190: LIST
29191: LIST
29192: PUSH
29193: LD_INT 3
29195: NEG
29196: PUSH
29197: LD_INT 3
29199: NEG
29200: PUSH
29201: EMPTY
29202: LIST
29203: LIST
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 14
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: LD_INT 2
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 0
29348: PUSH
29349: LD_INT 2
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 1
29358: NEG
29359: PUSH
29360: LD_INT 1
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 1
29369: NEG
29370: PUSH
29371: LD_INT 3
29373: NEG
29374: PUSH
29375: EMPTY
29376: LIST
29377: LIST
29378: PUSH
29379: LD_INT 0
29381: PUSH
29382: LD_INT 3
29384: NEG
29385: PUSH
29386: EMPTY
29387: LIST
29388: LIST
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: LD_INT 2
29395: NEG
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: EMPTY
29402: LIST
29403: LIST
29404: LIST
29405: LIST
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29419: LD_ADDR_VAR 0 15
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: LD_INT 0
29429: PUSH
29430: EMPTY
29431: LIST
29432: LIST
29433: PUSH
29434: LD_INT 0
29436: PUSH
29437: LD_INT 1
29439: NEG
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: PUSH
29445: LD_INT 1
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: EMPTY
29452: LIST
29453: LIST
29454: PUSH
29455: LD_INT 1
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: LD_INT 0
29467: PUSH
29468: LD_INT 1
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: PUSH
29475: LD_INT 1
29477: NEG
29478: PUSH
29479: LD_INT 0
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 1
29488: NEG
29489: PUSH
29490: LD_INT 1
29492: NEG
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 1
29500: PUSH
29501: LD_INT 1
29503: NEG
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 2
29511: PUSH
29512: LD_INT 0
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 2
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 1
29531: NEG
29532: PUSH
29533: LD_INT 1
29535: PUSH
29536: EMPTY
29537: LIST
29538: LIST
29539: PUSH
29540: LD_INT 2
29542: NEG
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: PUSH
29551: LD_INT 2
29553: NEG
29554: PUSH
29555: LD_INT 1
29557: NEG
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: LD_INT 1
29568: NEG
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 3
29576: PUSH
29577: LD_INT 0
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 3
29586: PUSH
29587: LD_INT 1
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: LIST
29598: LIST
29599: LIST
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29612: LD_ADDR_VAR 0 16
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: LD_INT 0
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 0
29629: PUSH
29630: LD_INT 1
29632: NEG
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 1
29640: PUSH
29641: LD_INT 0
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: LD_INT 1
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: LD_INT 0
29660: PUSH
29661: LD_INT 1
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: PUSH
29668: LD_INT 1
29670: NEG
29671: PUSH
29672: LD_INT 0
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PUSH
29679: LD_INT 1
29681: NEG
29682: PUSH
29683: LD_INT 1
29685: NEG
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: PUSH
29691: LD_INT 1
29693: NEG
29694: PUSH
29695: LD_INT 2
29697: NEG
29698: PUSH
29699: EMPTY
29700: LIST
29701: LIST
29702: PUSH
29703: LD_INT 2
29705: PUSH
29706: LD_INT 1
29708: PUSH
29709: EMPTY
29710: LIST
29711: LIST
29712: PUSH
29713: LD_INT 2
29715: PUSH
29716: LD_INT 2
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 1
29725: PUSH
29726: LD_INT 2
29728: PUSH
29729: EMPTY
29730: LIST
29731: LIST
29732: PUSH
29733: LD_INT 2
29735: NEG
29736: PUSH
29737: LD_INT 1
29739: NEG
29740: PUSH
29741: EMPTY
29742: LIST
29743: LIST
29744: PUSH
29745: LD_INT 2
29747: NEG
29748: PUSH
29749: LD_INT 2
29751: NEG
29752: PUSH
29753: EMPTY
29754: LIST
29755: LIST
29756: PUSH
29757: LD_INT 3
29759: PUSH
29760: LD_INT 2
29762: PUSH
29763: EMPTY
29764: LIST
29765: LIST
29766: PUSH
29767: LD_INT 3
29769: PUSH
29770: LD_INT 3
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PUSH
29777: LD_INT 2
29779: PUSH
29780: LD_INT 3
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: EMPTY
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: LIST
29795: LIST
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29805: LD_ADDR_VAR 0 17
29809: PUSH
29810: LD_INT 0
29812: PUSH
29813: LD_INT 0
29815: PUSH
29816: EMPTY
29817: LIST
29818: LIST
29819: PUSH
29820: LD_INT 0
29822: PUSH
29823: LD_INT 1
29825: NEG
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 1
29833: PUSH
29834: LD_INT 0
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 1
29843: PUSH
29844: LD_INT 1
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 0
29853: PUSH
29854: LD_INT 1
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 1
29863: NEG
29864: PUSH
29865: LD_INT 0
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: LD_INT 1
29878: NEG
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 1
29886: NEG
29887: PUSH
29888: LD_INT 2
29890: NEG
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: LD_INT 2
29901: NEG
29902: PUSH
29903: EMPTY
29904: LIST
29905: LIST
29906: PUSH
29907: LD_INT 1
29909: PUSH
29910: LD_INT 1
29912: NEG
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 2
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 2
29930: PUSH
29931: LD_INT 1
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: PUSH
29941: LD_INT 2
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: LD_INT 2
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 0
29960: PUSH
29961: LD_INT 2
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 1
29970: NEG
29971: PUSH
29972: LD_INT 1
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 2
29981: NEG
29982: PUSH
29983: LD_INT 0
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PUSH
29990: LD_INT 2
29992: NEG
29993: PUSH
29994: LD_INT 1
29996: NEG
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: PUSH
30002: LD_INT 2
30004: NEG
30005: PUSH
30006: LD_INT 2
30008: NEG
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: LIST
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: LIST
30028: LIST
30029: LIST
30030: LIST
30031: LIST
30032: LIST
30033: LIST
30034: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30035: LD_ADDR_VAR 0 18
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: EMPTY
30047: LIST
30048: LIST
30049: PUSH
30050: LD_INT 0
30052: PUSH
30053: LD_INT 1
30055: NEG
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 1
30063: PUSH
30064: LD_INT 0
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 1
30073: PUSH
30074: LD_INT 1
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 0
30083: PUSH
30084: LD_INT 1
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: PUSH
30095: LD_INT 0
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: LD_INT 1
30108: NEG
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: NEG
30117: PUSH
30118: LD_INT 2
30120: NEG
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 0
30128: PUSH
30129: LD_INT 2
30131: NEG
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 1
30139: PUSH
30140: LD_INT 1
30142: NEG
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: PUSH
30151: LD_INT 0
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 2
30160: PUSH
30161: LD_INT 1
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 2
30170: PUSH
30171: LD_INT 2
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 1
30180: PUSH
30181: LD_INT 2
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 0
30190: PUSH
30191: LD_INT 2
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 1
30200: NEG
30201: PUSH
30202: LD_INT 1
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: LD_INT 2
30211: NEG
30212: PUSH
30213: LD_INT 0
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 2
30222: NEG
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: EMPTY
30229: LIST
30230: LIST
30231: PUSH
30232: LD_INT 2
30234: NEG
30235: PUSH
30236: LD_INT 2
30238: NEG
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: LIST
30264: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30265: LD_ADDR_VAR 0 19
30269: PUSH
30270: LD_INT 0
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 0
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 1
30293: PUSH
30294: LD_INT 0
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 1
30303: PUSH
30304: LD_INT 1
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: LD_INT 1
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 1
30323: NEG
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: LD_INT 1
30338: NEG
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: LD_INT 2
30350: NEG
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: PUSH
30356: LD_INT 0
30358: PUSH
30359: LD_INT 2
30361: NEG
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: LD_INT 1
30369: PUSH
30370: LD_INT 1
30372: NEG
30373: PUSH
30374: EMPTY
30375: LIST
30376: LIST
30377: PUSH
30378: LD_INT 2
30380: PUSH
30381: LD_INT 0
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 2
30390: PUSH
30391: LD_INT 1
30393: PUSH
30394: EMPTY
30395: LIST
30396: LIST
30397: PUSH
30398: LD_INT 2
30400: PUSH
30401: LD_INT 2
30403: PUSH
30404: EMPTY
30405: LIST
30406: LIST
30407: PUSH
30408: LD_INT 1
30410: PUSH
30411: LD_INT 2
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 0
30420: PUSH
30421: LD_INT 2
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 1
30430: NEG
30431: PUSH
30432: LD_INT 1
30434: PUSH
30435: EMPTY
30436: LIST
30437: LIST
30438: PUSH
30439: LD_INT 2
30441: NEG
30442: PUSH
30443: LD_INT 0
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 2
30452: NEG
30453: PUSH
30454: LD_INT 1
30456: NEG
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: LD_INT 2
30464: NEG
30465: PUSH
30466: LD_INT 2
30468: NEG
30469: PUSH
30470: EMPTY
30471: LIST
30472: LIST
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: LIST
30494: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30495: LD_ADDR_VAR 0 20
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: LD_INT 0
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: LD_INT 1
30515: NEG
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 1
30523: PUSH
30524: LD_INT 0
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 1
30533: PUSH
30534: LD_INT 1
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 1
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 1
30553: NEG
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: LD_INT 1
30568: NEG
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 1
30576: NEG
30577: PUSH
30578: LD_INT 2
30580: NEG
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: PUSH
30586: LD_INT 0
30588: PUSH
30589: LD_INT 2
30591: NEG
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: PUSH
30597: LD_INT 1
30599: PUSH
30600: LD_INT 1
30602: NEG
30603: PUSH
30604: EMPTY
30605: LIST
30606: LIST
30607: PUSH
30608: LD_INT 2
30610: PUSH
30611: LD_INT 0
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 2
30620: PUSH
30621: LD_INT 1
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: LD_INT 2
30630: PUSH
30631: LD_INT 2
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 1
30640: PUSH
30641: LD_INT 2
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 0
30650: PUSH
30651: LD_INT 2
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 1
30660: NEG
30661: PUSH
30662: LD_INT 1
30664: PUSH
30665: EMPTY
30666: LIST
30667: LIST
30668: PUSH
30669: LD_INT 2
30671: NEG
30672: PUSH
30673: LD_INT 0
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 2
30682: NEG
30683: PUSH
30684: LD_INT 1
30686: NEG
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: LD_INT 2
30694: NEG
30695: PUSH
30696: LD_INT 2
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30725: LD_ADDR_VAR 0 21
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 0
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 1
30745: NEG
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 1
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: PUSH
30764: LD_INT 1
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: LD_INT 1
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 1
30783: NEG
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: LD_INT 1
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 1
30806: NEG
30807: PUSH
30808: LD_INT 2
30810: NEG
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 0
30818: PUSH
30819: LD_INT 2
30821: NEG
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 1
30829: PUSH
30830: LD_INT 1
30832: NEG
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: PUSH
30841: LD_INT 0
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 2
30850: PUSH
30851: LD_INT 1
30853: PUSH
30854: EMPTY
30855: LIST
30856: LIST
30857: PUSH
30858: LD_INT 2
30860: PUSH
30861: LD_INT 2
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 1
30870: PUSH
30871: LD_INT 2
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: LD_INT 2
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: NEG
30891: PUSH
30892: LD_INT 1
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: PUSH
30899: LD_INT 2
30901: NEG
30902: PUSH
30903: LD_INT 0
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 2
30912: NEG
30913: PUSH
30914: LD_INT 1
30916: NEG
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 2
30924: NEG
30925: PUSH
30926: LD_INT 2
30928: NEG
30929: PUSH
30930: EMPTY
30931: LIST
30932: LIST
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: LIST
30954: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30955: LD_ADDR_VAR 0 22
30959: PUSH
30960: LD_INT 0
30962: PUSH
30963: LD_INT 0
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 0
30972: PUSH
30973: LD_INT 1
30975: NEG
30976: PUSH
30977: EMPTY
30978: LIST
30979: LIST
30980: PUSH
30981: LD_INT 1
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: EMPTY
30988: LIST
30989: LIST
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: LD_INT 1
30996: PUSH
30997: EMPTY
30998: LIST
30999: LIST
31000: PUSH
31001: LD_INT 0
31003: PUSH
31004: LD_INT 1
31006: PUSH
31007: EMPTY
31008: LIST
31009: LIST
31010: PUSH
31011: LD_INT 1
31013: NEG
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: LD_INT 1
31028: NEG
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: LD_INT 2
31040: NEG
31041: PUSH
31042: EMPTY
31043: LIST
31044: LIST
31045: PUSH
31046: LD_INT 0
31048: PUSH
31049: LD_INT 2
31051: NEG
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 1
31059: PUSH
31060: LD_INT 1
31062: NEG
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 2
31070: PUSH
31071: LD_INT 0
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 2
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 2
31090: PUSH
31091: LD_INT 2
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 1
31100: PUSH
31101: LD_INT 2
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 0
31110: PUSH
31111: LD_INT 2
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: LD_INT 1
31124: PUSH
31125: EMPTY
31126: LIST
31127: LIST
31128: PUSH
31129: LD_INT 2
31131: NEG
31132: PUSH
31133: LD_INT 0
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 2
31142: NEG
31143: PUSH
31144: LD_INT 1
31146: NEG
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 2
31154: NEG
31155: PUSH
31156: LD_INT 2
31158: NEG
31159: PUSH
31160: EMPTY
31161: LIST
31162: LIST
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31185: LD_ADDR_VAR 0 23
31189: PUSH
31190: LD_INT 0
31192: PUSH
31193: LD_INT 0
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 0
31202: PUSH
31203: LD_INT 1
31205: NEG
31206: PUSH
31207: EMPTY
31208: LIST
31209: LIST
31210: PUSH
31211: LD_INT 1
31213: PUSH
31214: LD_INT 0
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: PUSH
31221: LD_INT 1
31223: PUSH
31224: LD_INT 1
31226: PUSH
31227: EMPTY
31228: LIST
31229: LIST
31230: PUSH
31231: LD_INT 0
31233: PUSH
31234: LD_INT 1
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: LD_INT 1
31243: NEG
31244: PUSH
31245: LD_INT 0
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 1
31254: NEG
31255: PUSH
31256: LD_INT 1
31258: NEG
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 1
31266: NEG
31267: PUSH
31268: LD_INT 2
31270: NEG
31271: PUSH
31272: EMPTY
31273: LIST
31274: LIST
31275: PUSH
31276: LD_INT 0
31278: PUSH
31279: LD_INT 2
31281: NEG
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 1
31289: PUSH
31290: LD_INT 1
31292: NEG
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 2
31300: PUSH
31301: LD_INT 0
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 2
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 2
31320: PUSH
31321: LD_INT 2
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 1
31330: PUSH
31331: LD_INT 2
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 0
31340: PUSH
31341: LD_INT 2
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: LD_INT 1
31354: PUSH
31355: EMPTY
31356: LIST
31357: LIST
31358: PUSH
31359: LD_INT 2
31361: NEG
31362: PUSH
31363: LD_INT 0
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 2
31372: NEG
31373: PUSH
31374: LD_INT 1
31376: NEG
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: LD_INT 2
31384: NEG
31385: PUSH
31386: LD_INT 2
31388: NEG
31389: PUSH
31390: EMPTY
31391: LIST
31392: LIST
31393: PUSH
31394: LD_INT 2
31396: NEG
31397: PUSH
31398: LD_INT 3
31400: NEG
31401: PUSH
31402: EMPTY
31403: LIST
31404: LIST
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: LD_INT 3
31412: NEG
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 1
31420: PUSH
31421: LD_INT 2
31423: NEG
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 2
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: LIST
31447: LIST
31448: LIST
31449: LIST
31450: LIST
31451: LIST
31452: LIST
31453: LIST
31454: LIST
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31465: LD_ADDR_VAR 0 24
31469: PUSH
31470: LD_INT 0
31472: PUSH
31473: LD_INT 0
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 0
31482: PUSH
31483: LD_INT 1
31485: NEG
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 1
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 1
31503: PUSH
31504: LD_INT 1
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 0
31513: PUSH
31514: LD_INT 1
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: LD_INT 1
31523: NEG
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: NEG
31535: PUSH
31536: LD_INT 1
31538: NEG
31539: PUSH
31540: EMPTY
31541: LIST
31542: LIST
31543: PUSH
31544: LD_INT 1
31546: NEG
31547: PUSH
31548: LD_INT 2
31550: NEG
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 0
31558: PUSH
31559: LD_INT 2
31561: NEG
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 1
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 2
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 2
31600: PUSH
31601: LD_INT 2
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: LD_INT 2
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 0
31620: PUSH
31621: LD_INT 2
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 1
31630: NEG
31631: PUSH
31632: LD_INT 1
31634: PUSH
31635: EMPTY
31636: LIST
31637: LIST
31638: PUSH
31639: LD_INT 2
31641: NEG
31642: PUSH
31643: LD_INT 0
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 2
31652: NEG
31653: PUSH
31654: LD_INT 1
31656: NEG
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 2
31664: NEG
31665: PUSH
31666: LD_INT 2
31668: NEG
31669: PUSH
31670: EMPTY
31671: LIST
31672: LIST
31673: PUSH
31674: LD_INT 1
31676: PUSH
31677: LD_INT 2
31679: NEG
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 2
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: PUSH
31696: LD_INT 3
31698: PUSH
31699: LD_INT 1
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 3
31708: PUSH
31709: LD_INT 2
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: EMPTY
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31741: LD_ADDR_VAR 0 25
31745: PUSH
31746: LD_INT 0
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 0
31758: PUSH
31759: LD_INT 1
31761: NEG
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 1
31769: PUSH
31770: LD_INT 0
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 1
31779: PUSH
31780: LD_INT 1
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: LD_INT 1
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 1
31799: NEG
31800: PUSH
31801: LD_INT 0
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: NEG
31811: PUSH
31812: LD_INT 1
31814: NEG
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 1
31822: NEG
31823: PUSH
31824: LD_INT 2
31826: NEG
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: PUSH
31832: LD_INT 0
31834: PUSH
31835: LD_INT 2
31837: NEG
31838: PUSH
31839: EMPTY
31840: LIST
31841: LIST
31842: PUSH
31843: LD_INT 1
31845: PUSH
31846: LD_INT 1
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 2
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 2
31866: PUSH
31867: LD_INT 1
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 2
31876: PUSH
31877: LD_INT 2
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: LD_INT 2
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 1
31906: NEG
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 2
31917: NEG
31918: PUSH
31919: LD_INT 0
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 2
31928: NEG
31929: PUSH
31930: LD_INT 1
31932: NEG
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: LD_INT 2
31940: NEG
31941: PUSH
31942: LD_INT 2
31944: NEG
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 3
31952: PUSH
31953: LD_INT 1
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 3
31962: PUSH
31963: LD_INT 2
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 2
31972: PUSH
31973: LD_INT 3
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: PUSH
31983: LD_INT 3
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: LIST
31994: LIST
31995: LIST
31996: LIST
31997: LIST
31998: LIST
31999: LIST
32000: LIST
32001: LIST
32002: LIST
32003: LIST
32004: LIST
32005: LIST
32006: LIST
32007: LIST
32008: LIST
32009: LIST
32010: LIST
32011: LIST
32012: LIST
32013: LIST
32014: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32015: LD_ADDR_VAR 0 26
32019: PUSH
32020: LD_INT 0
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 0
32032: PUSH
32033: LD_INT 1
32035: NEG
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 1
32043: PUSH
32044: LD_INT 0
32046: PUSH
32047: EMPTY
32048: LIST
32049: LIST
32050: PUSH
32051: LD_INT 1
32053: PUSH
32054: LD_INT 1
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 0
32063: PUSH
32064: LD_INT 1
32066: PUSH
32067: EMPTY
32068: LIST
32069: LIST
32070: PUSH
32071: LD_INT 1
32073: NEG
32074: PUSH
32075: LD_INT 0
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: LD_INT 1
32084: NEG
32085: PUSH
32086: LD_INT 1
32088: NEG
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 1
32096: NEG
32097: PUSH
32098: LD_INT 2
32100: NEG
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 0
32108: PUSH
32109: LD_INT 2
32111: NEG
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: LD_INT 1
32122: NEG
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 2
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: EMPTY
32135: LIST
32136: LIST
32137: PUSH
32138: LD_INT 2
32140: PUSH
32141: LD_INT 1
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: PUSH
32151: LD_INT 2
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: LD_INT 2
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 0
32170: PUSH
32171: LD_INT 2
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: NEG
32192: PUSH
32193: LD_INT 0
32195: PUSH
32196: EMPTY
32197: LIST
32198: LIST
32199: PUSH
32200: LD_INT 2
32202: NEG
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 2
32214: NEG
32215: PUSH
32216: LD_INT 2
32218: NEG
32219: PUSH
32220: EMPTY
32221: LIST
32222: LIST
32223: PUSH
32224: LD_INT 2
32226: PUSH
32227: LD_INT 3
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: PUSH
32234: LD_INT 1
32236: PUSH
32237: LD_INT 3
32239: PUSH
32240: EMPTY
32241: LIST
32242: LIST
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: LD_INT 2
32250: PUSH
32251: EMPTY
32252: LIST
32253: LIST
32254: PUSH
32255: LD_INT 2
32257: NEG
32258: PUSH
32259: LD_INT 1
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: EMPTY
32267: LIST
32268: LIST
32269: LIST
32270: LIST
32271: LIST
32272: LIST
32273: LIST
32274: LIST
32275: LIST
32276: LIST
32277: LIST
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: LIST
32290: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32291: LD_ADDR_VAR 0 27
32295: PUSH
32296: LD_INT 0
32298: PUSH
32299: LD_INT 0
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: LD_INT 0
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: PUSH
32317: LD_INT 1
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 1
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: LD_INT 0
32339: PUSH
32340: LD_INT 1
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PUSH
32347: LD_INT 1
32349: NEG
32350: PUSH
32351: LD_INT 0
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 1
32360: NEG
32361: PUSH
32362: LD_INT 1
32364: NEG
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 1
32372: NEG
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 0
32384: PUSH
32385: LD_INT 2
32387: NEG
32388: PUSH
32389: EMPTY
32390: LIST
32391: LIST
32392: PUSH
32393: LD_INT 1
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: EMPTY
32401: LIST
32402: LIST
32403: PUSH
32404: LD_INT 2
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 2
32416: PUSH
32417: LD_INT 1
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 2
32426: PUSH
32427: LD_INT 2
32429: PUSH
32430: EMPTY
32431: LIST
32432: LIST
32433: PUSH
32434: LD_INT 1
32436: PUSH
32437: LD_INT 2
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: LD_INT 0
32446: PUSH
32447: LD_INT 2
32449: PUSH
32450: EMPTY
32451: LIST
32452: LIST
32453: PUSH
32454: LD_INT 1
32456: NEG
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: LD_INT 2
32467: NEG
32468: PUSH
32469: LD_INT 0
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 2
32478: NEG
32479: PUSH
32480: LD_INT 1
32482: NEG
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 2
32490: NEG
32491: PUSH
32492: LD_INT 2
32494: NEG
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: NEG
32503: PUSH
32504: LD_INT 2
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 2
32513: NEG
32514: PUSH
32515: LD_INT 1
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PUSH
32522: LD_INT 3
32524: NEG
32525: PUSH
32526: LD_INT 1
32528: NEG
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 3
32536: NEG
32537: PUSH
32538: LD_INT 2
32540: NEG
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: LIST
32553: LIST
32554: LIST
32555: LIST
32556: LIST
32557: LIST
32558: LIST
32559: LIST
32560: LIST
32561: LIST
32562: LIST
32563: LIST
32564: LIST
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32571: LD_ADDR_VAR 0 28
32575: PUSH
32576: LD_INT 0
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 0
32588: PUSH
32589: LD_INT 1
32591: NEG
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 1
32599: PUSH
32600: LD_INT 0
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 1
32609: PUSH
32610: LD_INT 1
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 0
32619: PUSH
32620: LD_INT 1
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 1
32629: NEG
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 1
32640: NEG
32641: PUSH
32642: LD_INT 1
32644: NEG
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: LD_INT 2
32656: NEG
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: PUSH
32662: LD_INT 0
32664: PUSH
32665: LD_INT 2
32667: NEG
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 1
32675: PUSH
32676: LD_INT 1
32678: NEG
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 2
32686: PUSH
32687: LD_INT 0
32689: PUSH
32690: EMPTY
32691: LIST
32692: LIST
32693: PUSH
32694: LD_INT 2
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 2
32706: PUSH
32707: LD_INT 2
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 2
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 0
32726: PUSH
32727: LD_INT 2
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 1
32736: NEG
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: NEG
32748: PUSH
32749: LD_INT 0
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 2
32758: NEG
32759: PUSH
32760: LD_INT 1
32762: NEG
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 2
32770: NEG
32771: PUSH
32772: LD_INT 2
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 2
32782: NEG
32783: PUSH
32784: LD_INT 3
32786: NEG
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 1
32794: NEG
32795: PUSH
32796: LD_INT 3
32798: NEG
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 3
32806: NEG
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 3
32818: NEG
32819: PUSH
32820: LD_INT 2
32822: NEG
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: LIST
32832: LIST
32833: LIST
32834: LIST
32835: LIST
32836: LIST
32837: LIST
32838: LIST
32839: LIST
32840: LIST
32841: LIST
32842: LIST
32843: LIST
32844: LIST
32845: LIST
32846: LIST
32847: LIST
32848: LIST
32849: LIST
32850: LIST
32851: LIST
32852: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32853: LD_ADDR_VAR 0 29
32857: PUSH
32858: LD_INT 0
32860: PUSH
32861: LD_INT 0
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 0
32870: PUSH
32871: LD_INT 1
32873: NEG
32874: PUSH
32875: EMPTY
32876: LIST
32877: LIST
32878: PUSH
32879: LD_INT 1
32881: PUSH
32882: LD_INT 0
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 1
32891: PUSH
32892: LD_INT 1
32894: PUSH
32895: EMPTY
32896: LIST
32897: LIST
32898: PUSH
32899: LD_INT 0
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 1
32911: NEG
32912: PUSH
32913: LD_INT 0
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PUSH
32920: LD_INT 1
32922: NEG
32923: PUSH
32924: LD_INT 1
32926: NEG
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 2
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 0
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: PUSH
32958: LD_INT 1
32960: NEG
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 2
32968: PUSH
32969: LD_INT 0
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: LD_INT 2
32978: PUSH
32979: LD_INT 1
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 1
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: EMPTY
32993: LIST
32994: LIST
32995: PUSH
32996: LD_INT 0
32998: PUSH
32999: LD_INT 2
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: PUSH
33013: EMPTY
33014: LIST
33015: LIST
33016: PUSH
33017: LD_INT 2
33019: NEG
33020: PUSH
33021: LD_INT 1
33023: NEG
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 2
33031: NEG
33032: PUSH
33033: LD_INT 2
33035: NEG
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 2
33043: NEG
33044: PUSH
33045: LD_INT 3
33047: NEG
33048: PUSH
33049: EMPTY
33050: LIST
33051: LIST
33052: PUSH
33053: LD_INT 2
33055: PUSH
33056: LD_INT 1
33058: NEG
33059: PUSH
33060: EMPTY
33061: LIST
33062: LIST
33063: PUSH
33064: LD_INT 3
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 1
33076: PUSH
33077: LD_INT 3
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 3
33097: NEG
33098: PUSH
33099: LD_INT 2
33101: NEG
33102: PUSH
33103: EMPTY
33104: LIST
33105: LIST
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: LIST
33117: LIST
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: LIST
33123: LIST
33124: LIST
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33132: LD_ADDR_VAR 0 30
33136: PUSH
33137: LD_INT 0
33139: PUSH
33140: LD_INT 0
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 0
33149: PUSH
33150: LD_INT 1
33152: NEG
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: LD_INT 1
33160: PUSH
33161: LD_INT 0
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 1
33170: PUSH
33171: LD_INT 1
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: NEG
33191: PUSH
33192: LD_INT 0
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 1
33201: NEG
33202: PUSH
33203: LD_INT 1
33205: NEG
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 1
33213: NEG
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: PUSH
33223: LD_INT 0
33225: PUSH
33226: LD_INT 2
33228: NEG
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: PUSH
33234: LD_INT 1
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 2
33247: PUSH
33248: LD_INT 0
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 2
33257: PUSH
33258: LD_INT 1
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: PUSH
33268: LD_INT 2
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 1
33277: PUSH
33278: LD_INT 2
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 1
33287: NEG
33288: PUSH
33289: LD_INT 1
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 2
33298: NEG
33299: PUSH
33300: LD_INT 0
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 2
33309: NEG
33310: PUSH
33311: LD_INT 1
33313: NEG
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 1
33321: NEG
33322: PUSH
33323: LD_INT 3
33325: NEG
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 1
33333: PUSH
33334: LD_INT 2
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 3
33344: PUSH
33345: LD_INT 2
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: LD_INT 2
33354: PUSH
33355: LD_INT 3
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: PUSH
33362: LD_INT 2
33364: NEG
33365: PUSH
33366: LD_INT 1
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 3
33375: NEG
33376: PUSH
33377: LD_INT 1
33379: NEG
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: LIST
33406: LIST
33407: LIST
33408: LIST
33409: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33410: LD_ADDR_VAR 0 31
33414: PUSH
33415: LD_INT 0
33417: PUSH
33418: LD_INT 0
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 1
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 0
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 1
33448: PUSH
33449: LD_INT 1
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 0
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: EMPTY
33463: LIST
33464: LIST
33465: PUSH
33466: LD_INT 1
33468: NEG
33469: PUSH
33470: LD_INT 0
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 1
33479: NEG
33480: PUSH
33481: LD_INT 1
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: LD_INT 2
33495: NEG
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 1
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 0
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 2
33524: PUSH
33525: LD_INT 1
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 2
33534: PUSH
33535: LD_INT 2
33537: PUSH
33538: EMPTY
33539: LIST
33540: LIST
33541: PUSH
33542: LD_INT 1
33544: PUSH
33545: LD_INT 2
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 0
33554: PUSH
33555: LD_INT 2
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 2
33575: NEG
33576: PUSH
33577: LD_INT 1
33579: NEG
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 2
33587: NEG
33588: PUSH
33589: LD_INT 2
33591: NEG
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: LD_INT 3
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 3
33622: PUSH
33623: LD_INT 1
33625: PUSH
33626: EMPTY
33627: LIST
33628: LIST
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: LD_INT 3
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: NEG
33643: PUSH
33644: LD_INT 2
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 3
33653: NEG
33654: PUSH
33655: LD_INT 2
33657: NEG
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: LIST
33667: LIST
33668: LIST
33669: LIST
33670: LIST
33671: LIST
33672: LIST
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33688: LD_ADDR_VAR 0 32
33692: PUSH
33693: LD_INT 0
33695: PUSH
33696: LD_INT 0
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 1
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 1
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: NEG
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: NEG
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: LD_INT 2
33773: NEG
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 0
33781: PUSH
33782: LD_INT 2
33784: NEG
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: LD_INT 1
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 2
33803: PUSH
33804: LD_INT 1
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 2
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 1
33823: PUSH
33824: LD_INT 2
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: LD_INT 2
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: LD_INT 1
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 2
33854: NEG
33855: PUSH
33856: LD_INT 0
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 2
33865: NEG
33866: PUSH
33867: LD_INT 1
33869: NEG
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: LD_INT 3
33881: NEG
33882: PUSH
33883: EMPTY
33884: LIST
33885: LIST
33886: PUSH
33887: LD_INT 1
33889: PUSH
33890: LD_INT 2
33892: NEG
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PUSH
33898: LD_INT 3
33900: PUSH
33901: LD_INT 2
33903: PUSH
33904: EMPTY
33905: LIST
33906: LIST
33907: PUSH
33908: LD_INT 2
33910: PUSH
33911: LD_INT 3
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 2
33920: NEG
33921: PUSH
33922: LD_INT 1
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 3
33931: NEG
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: LIST
33945: LIST
33946: LIST
33947: LIST
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33966: LD_ADDR_VAR 0 33
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: LD_INT 0
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 1
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 1
34004: PUSH
34005: LD_INT 1
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 1
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 1
34024: NEG
34025: PUSH
34026: LD_INT 0
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: LD_INT 1
34039: NEG
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 1
34047: NEG
34048: PUSH
34049: LD_INT 2
34051: NEG
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 1
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 2
34070: PUSH
34071: LD_INT 0
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 2
34080: PUSH
34081: LD_INT 1
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: LD_INT 2
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 0
34100: PUSH
34101: LD_INT 2
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: LD_INT 1
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 2
34121: NEG
34122: PUSH
34123: LD_INT 0
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 2
34132: NEG
34133: PUSH
34134: LD_INT 1
34136: NEG
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 2
34144: NEG
34145: PUSH
34146: LD_INT 2
34148: NEG
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: PUSH
34154: LD_INT 2
34156: NEG
34157: PUSH
34158: LD_INT 3
34160: NEG
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 2
34168: PUSH
34169: LD_INT 1
34171: NEG
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 3
34179: PUSH
34180: LD_INT 1
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: LD_INT 3
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 1
34199: NEG
34200: PUSH
34201: LD_INT 2
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 3
34210: NEG
34211: PUSH
34212: LD_INT 2
34214: NEG
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: LIST
34227: LIST
34228: LIST
34229: LIST
34230: LIST
34231: LIST
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34245: LD_ADDR_VAR 0 34
34249: PUSH
34250: LD_INT 0
34252: PUSH
34253: LD_INT 0
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 0
34262: PUSH
34263: LD_INT 1
34265: NEG
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 1
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: LD_INT 1
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 0
34293: PUSH
34294: LD_INT 1
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: NEG
34304: PUSH
34305: LD_INT 0
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 1
34314: NEG
34315: PUSH
34316: LD_INT 1
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 1
34326: NEG
34327: PUSH
34328: LD_INT 2
34330: NEG
34331: PUSH
34332: EMPTY
34333: LIST
34334: LIST
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: LD_INT 2
34341: NEG
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: LD_INT 1
34352: NEG
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 2
34360: PUSH
34361: LD_INT 1
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: LD_INT 2
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: LD_INT 2
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 2
34401: NEG
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 2
34412: NEG
34413: PUSH
34414: LD_INT 1
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: LD_INT 2
34424: NEG
34425: PUSH
34426: LD_INT 2
34428: NEG
34429: PUSH
34430: EMPTY
34431: LIST
34432: LIST
34433: PUSH
34434: LD_INT 1
34436: NEG
34437: PUSH
34438: LD_INT 3
34440: NEG
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: LD_INT 2
34451: NEG
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 3
34459: PUSH
34460: LD_INT 2
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 2
34469: PUSH
34470: LD_INT 3
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 2
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 3
34490: NEG
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: LIST
34504: LIST
34505: LIST
34506: LIST
34507: LIST
34508: LIST
34509: LIST
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34525: LD_ADDR_VAR 0 35
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: LD_INT 0
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 0
34542: PUSH
34543: LD_INT 1
34545: NEG
34546: PUSH
34547: EMPTY
34548: LIST
34549: LIST
34550: PUSH
34551: LD_INT 1
34553: PUSH
34554: LD_INT 0
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 1
34563: PUSH
34564: LD_INT 1
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: LD_INT 1
34576: PUSH
34577: EMPTY
34578: LIST
34579: LIST
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 1
34594: NEG
34595: PUSH
34596: LD_INT 1
34598: NEG
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 2
34606: PUSH
34607: LD_INT 1
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 2
34616: NEG
34617: PUSH
34618: LD_INT 1
34620: NEG
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34637: LD_ADDR_VAR 0 36
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 1
34718: NEG
34719: PUSH
34720: LD_INT 2
34722: NEG
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PUSH
34728: LD_INT 1
34730: PUSH
34731: LD_INT 2
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34749: LD_ADDR_VAR 0 37
34753: PUSH
34754: LD_INT 0
34756: PUSH
34757: LD_INT 0
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: LD_INT 1
34769: NEG
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 0
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 1
34787: PUSH
34788: LD_INT 1
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: LD_INT 1
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 1
34807: NEG
34808: PUSH
34809: LD_INT 0
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: NEG
34842: PUSH
34843: LD_INT 1
34845: PUSH
34846: EMPTY
34847: LIST
34848: LIST
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: LIST
34854: LIST
34855: LIST
34856: LIST
34857: LIST
34858: LIST
34859: LIST
34860: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34861: LD_ADDR_VAR 0 38
34865: PUSH
34866: LD_INT 0
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 0
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PUSH
34887: LD_INT 1
34889: PUSH
34890: LD_INT 0
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: PUSH
34900: LD_INT 1
34902: PUSH
34903: EMPTY
34904: LIST
34905: LIST
34906: PUSH
34907: LD_INT 0
34909: PUSH
34910: LD_INT 1
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 1
34919: NEG
34920: PUSH
34921: LD_INT 0
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: LD_INT 1
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 2
34942: PUSH
34943: LD_INT 1
34945: PUSH
34946: EMPTY
34947: LIST
34948: LIST
34949: PUSH
34950: LD_INT 2
34952: NEG
34953: PUSH
34954: LD_INT 1
34956: NEG
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34973: LD_ADDR_VAR 0 39
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: LD_INT 0
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 0
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: PUSH
35002: LD_INT 0
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: LD_INT 1
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 1
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 1
35031: NEG
35032: PUSH
35033: LD_INT 0
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: LD_INT 2
35058: NEG
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 1
35066: PUSH
35067: LD_INT 2
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35085: LD_ADDR_VAR 0 40
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: PUSH
35167: LD_INT 1
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 1
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35197: LD_ADDR_VAR 0 41
35201: PUSH
35202: LD_INT 0
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 1
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: NEG
35279: PUSH
35280: LD_INT 2
35282: NEG
35283: PUSH
35284: EMPTY
35285: LIST
35286: LIST
35287: PUSH
35288: LD_INT 1
35290: PUSH
35291: LD_INT 1
35293: NEG
35294: PUSH
35295: EMPTY
35296: LIST
35297: LIST
35298: PUSH
35299: LD_INT 2
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 2
35311: PUSH
35312: LD_INT 1
35314: PUSH
35315: EMPTY
35316: LIST
35317: LIST
35318: PUSH
35319: LD_INT 2
35321: PUSH
35322: LD_INT 2
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: LD_INT 2
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 1
35341: NEG
35342: PUSH
35343: LD_INT 1
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 2
35352: NEG
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 2
35363: NEG
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 2
35375: NEG
35376: PUSH
35377: LD_INT 2
35379: NEG
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 2
35387: NEG
35388: PUSH
35389: LD_INT 3
35391: NEG
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 2
35399: PUSH
35400: LD_INT 1
35402: NEG
35403: PUSH
35404: EMPTY
35405: LIST
35406: LIST
35407: PUSH
35408: LD_INT 3
35410: PUSH
35411: LD_INT 0
35413: PUSH
35414: EMPTY
35415: LIST
35416: LIST
35417: PUSH
35418: LD_INT 3
35420: PUSH
35421: LD_INT 1
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 3
35430: PUSH
35431: LD_INT 2
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 3
35440: PUSH
35441: LD_INT 3
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 2
35450: PUSH
35451: LD_INT 3
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 2
35460: NEG
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 3
35471: NEG
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 3
35482: NEG
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 3
35494: NEG
35495: PUSH
35496: LD_INT 2
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 3
35506: NEG
35507: PUSH
35508: LD_INT 3
35510: NEG
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: LIST
35541: LIST
35542: LIST
35543: LIST
35544: LIST
35545: LIST
35546: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35547: LD_ADDR_VAR 0 42
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: LD_INT 0
35557: PUSH
35558: EMPTY
35559: LIST
35560: LIST
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: LD_INT 1
35567: NEG
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: LD_INT 1
35575: PUSH
35576: LD_INT 0
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: LD_INT 1
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 1
35605: NEG
35606: PUSH
35607: LD_INT 0
35609: PUSH
35610: EMPTY
35611: LIST
35612: LIST
35613: PUSH
35614: LD_INT 1
35616: NEG
35617: PUSH
35618: LD_INT 1
35620: NEG
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 2
35632: NEG
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PUSH
35638: LD_INT 0
35640: PUSH
35641: LD_INT 2
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: PUSH
35652: LD_INT 1
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 2
35662: PUSH
35663: LD_INT 1
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 2
35672: PUSH
35673: LD_INT 2
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: LD_INT 2
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: LD_INT 2
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: LD_INT 1
35706: PUSH
35707: EMPTY
35708: LIST
35709: LIST
35710: PUSH
35711: LD_INT 2
35713: NEG
35714: PUSH
35715: LD_INT 1
35717: NEG
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 2
35725: NEG
35726: PUSH
35727: LD_INT 2
35729: NEG
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 2
35737: NEG
35738: PUSH
35739: LD_INT 3
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 1
35749: NEG
35750: PUSH
35751: LD_INT 3
35753: NEG
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 0
35761: PUSH
35762: LD_INT 3
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 1
35772: PUSH
35773: LD_INT 2
35775: NEG
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 3
35783: PUSH
35784: LD_INT 2
35786: PUSH
35787: EMPTY
35788: LIST
35789: LIST
35790: PUSH
35791: LD_INT 3
35793: PUSH
35794: LD_INT 3
35796: PUSH
35797: EMPTY
35798: LIST
35799: LIST
35800: PUSH
35801: LD_INT 2
35803: PUSH
35804: LD_INT 3
35806: PUSH
35807: EMPTY
35808: LIST
35809: LIST
35810: PUSH
35811: LD_INT 1
35813: PUSH
35814: LD_INT 3
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: LD_INT 3
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 1
35833: NEG
35834: PUSH
35835: LD_INT 2
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 3
35844: NEG
35845: PUSH
35846: LD_INT 2
35848: NEG
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 3
35856: NEG
35857: PUSH
35858: LD_INT 3
35860: NEG
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: EMPTY
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: LIST
35874: LIST
35875: LIST
35876: LIST
35877: LIST
35878: LIST
35879: LIST
35880: LIST
35881: LIST
35882: LIST
35883: LIST
35884: LIST
35885: LIST
35886: LIST
35887: LIST
35888: LIST
35889: LIST
35890: LIST
35891: LIST
35892: LIST
35893: LIST
35894: LIST
35895: LIST
35896: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35897: LD_ADDR_VAR 0 43
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: LD_INT 0
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: PUSH
35912: LD_INT 0
35914: PUSH
35915: LD_INT 1
35917: NEG
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 1
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 1
35935: PUSH
35936: LD_INT 1
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 0
35945: PUSH
35946: LD_INT 1
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 1
35955: NEG
35956: PUSH
35957: LD_INT 0
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: LD_INT 1
35970: NEG
35971: PUSH
35972: EMPTY
35973: LIST
35974: LIST
35975: PUSH
35976: LD_INT 1
35978: NEG
35979: PUSH
35980: LD_INT 2
35982: NEG
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 0
35990: PUSH
35991: LD_INT 2
35993: NEG
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 1
36001: PUSH
36002: LD_INT 1
36004: NEG
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 2
36012: PUSH
36013: LD_INT 0
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 2
36022: PUSH
36023: LD_INT 1
36025: PUSH
36026: EMPTY
36027: LIST
36028: LIST
36029: PUSH
36030: LD_INT 1
36032: PUSH
36033: LD_INT 2
36035: PUSH
36036: EMPTY
36037: LIST
36038: LIST
36039: PUSH
36040: LD_INT 0
36042: PUSH
36043: LD_INT 2
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 1
36052: NEG
36053: PUSH
36054: LD_INT 1
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 2
36063: NEG
36064: PUSH
36065: LD_INT 0
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 2
36074: NEG
36075: PUSH
36076: LD_INT 1
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 1
36086: NEG
36087: PUSH
36088: LD_INT 3
36090: NEG
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 0
36098: PUSH
36099: LD_INT 3
36101: NEG
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 1
36109: PUSH
36110: LD_INT 2
36112: NEG
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 2
36120: PUSH
36121: LD_INT 1
36123: NEG
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 3
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 3
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 1
36151: PUSH
36152: LD_INT 3
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: LD_INT 3
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 1
36171: NEG
36172: PUSH
36173: LD_INT 2
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 2
36182: NEG
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 3
36193: NEG
36194: PUSH
36195: LD_INT 0
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 3
36204: NEG
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36245: LD_ADDR_VAR 0 44
36249: PUSH
36250: LD_INT 0
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 0
36262: PUSH
36263: LD_INT 1
36265: NEG
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 1
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 1
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 0
36293: PUSH
36294: LD_INT 1
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 1
36303: NEG
36304: PUSH
36305: LD_INT 0
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: LD_INT 1
36318: NEG
36319: PUSH
36320: EMPTY
36321: LIST
36322: LIST
36323: PUSH
36324: LD_INT 1
36326: NEG
36327: PUSH
36328: LD_INT 2
36330: NEG
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 1
36338: PUSH
36339: LD_INT 1
36341: NEG
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 2
36349: PUSH
36350: LD_INT 0
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 2
36359: PUSH
36360: LD_INT 1
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 2
36369: PUSH
36370: LD_INT 2
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: PUSH
36380: LD_INT 2
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 1
36389: NEG
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: NEG
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 2
36411: NEG
36412: PUSH
36413: LD_INT 1
36415: NEG
36416: PUSH
36417: EMPTY
36418: LIST
36419: LIST
36420: PUSH
36421: LD_INT 2
36423: NEG
36424: PUSH
36425: LD_INT 2
36427: NEG
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 2
36435: NEG
36436: PUSH
36437: LD_INT 3
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: PUSH
36448: LD_INT 1
36450: NEG
36451: PUSH
36452: EMPTY
36453: LIST
36454: LIST
36455: PUSH
36456: LD_INT 3
36458: PUSH
36459: LD_INT 0
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 3
36468: PUSH
36469: LD_INT 1
36471: PUSH
36472: EMPTY
36473: LIST
36474: LIST
36475: PUSH
36476: LD_INT 3
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: EMPTY
36483: LIST
36484: LIST
36485: PUSH
36486: LD_INT 3
36488: PUSH
36489: LD_INT 3
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 2
36498: PUSH
36499: LD_INT 3
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 2
36508: NEG
36509: PUSH
36510: LD_INT 1
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 3
36519: NEG
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: EMPTY
36525: LIST
36526: LIST
36527: PUSH
36528: LD_INT 3
36530: NEG
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 3
36542: NEG
36543: PUSH
36544: LD_INT 2
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 3
36554: NEG
36555: PUSH
36556: LD_INT 3
36558: NEG
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: LIST
36568: LIST
36569: LIST
36570: LIST
36571: LIST
36572: LIST
36573: LIST
36574: LIST
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: LIST
36580: LIST
36581: LIST
36582: LIST
36583: LIST
36584: LIST
36585: LIST
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36595: LD_ADDR_VAR 0 45
36599: PUSH
36600: LD_INT 0
36602: PUSH
36603: LD_INT 0
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: LD_INT 1
36615: NEG
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 1
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 1
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 0
36643: PUSH
36644: LD_INT 1
36646: PUSH
36647: EMPTY
36648: LIST
36649: LIST
36650: PUSH
36651: LD_INT 1
36653: NEG
36654: PUSH
36655: LD_INT 0
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: LD_INT 1
36664: NEG
36665: PUSH
36666: LD_INT 1
36668: NEG
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 1
36676: NEG
36677: PUSH
36678: LD_INT 2
36680: NEG
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: LD_INT 2
36691: NEG
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: LD_INT 1
36702: NEG
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 2
36720: PUSH
36721: LD_INT 2
36723: PUSH
36724: EMPTY
36725: LIST
36726: LIST
36727: PUSH
36728: LD_INT 1
36730: PUSH
36731: LD_INT 2
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 0
36740: PUSH
36741: LD_INT 2
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 1
36750: NEG
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 2
36761: NEG
36762: PUSH
36763: LD_INT 1
36765: NEG
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 2
36773: NEG
36774: PUSH
36775: LD_INT 2
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 3
36789: NEG
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: NEG
36798: PUSH
36799: LD_INT 3
36801: NEG
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 0
36809: PUSH
36810: LD_INT 3
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: LD_INT 2
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 3
36831: PUSH
36832: LD_INT 2
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 3
36841: PUSH
36842: LD_INT 3
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: LD_INT 2
36851: PUSH
36852: LD_INT 3
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 1
36861: PUSH
36862: LD_INT 3
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 0
36871: PUSH
36872: LD_INT 3
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 1
36881: NEG
36882: PUSH
36883: LD_INT 2
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 3
36892: NEG
36893: PUSH
36894: LD_INT 2
36896: NEG
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 3
36904: NEG
36905: PUSH
36906: LD_INT 3
36908: NEG
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: LIST
36923: LIST
36924: LIST
36925: LIST
36926: LIST
36927: LIST
36928: LIST
36929: LIST
36930: LIST
36931: LIST
36932: LIST
36933: LIST
36934: LIST
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36945: LD_ADDR_VAR 0 46
36949: PUSH
36950: LD_INT 0
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: EMPTY
36957: LIST
36958: LIST
36959: PUSH
36960: LD_INT 0
36962: PUSH
36963: LD_INT 1
36965: NEG
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 1
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 1
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 0
36993: PUSH
36994: LD_INT 1
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: NEG
37004: PUSH
37005: LD_INT 0
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 1
37014: NEG
37015: PUSH
37016: LD_INT 1
37018: NEG
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 1
37026: NEG
37027: PUSH
37028: LD_INT 2
37030: NEG
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 2
37041: NEG
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: LD_INT 1
37052: NEG
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 2
37060: PUSH
37061: LD_INT 0
37063: PUSH
37064: EMPTY
37065: LIST
37066: LIST
37067: PUSH
37068: LD_INT 2
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: LD_INT 1
37080: PUSH
37081: LD_INT 2
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: LD_INT 2
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 1
37100: NEG
37101: PUSH
37102: LD_INT 1
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 2
37111: NEG
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 2
37122: NEG
37123: PUSH
37124: LD_INT 1
37126: NEG
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 1
37134: NEG
37135: PUSH
37136: LD_INT 3
37138: NEG
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 0
37146: PUSH
37147: LD_INT 3
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 1
37157: PUSH
37158: LD_INT 2
37160: NEG
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 2
37168: PUSH
37169: LD_INT 1
37171: NEG
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 3
37179: PUSH
37180: LD_INT 0
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 3
37189: PUSH
37190: LD_INT 1
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 1
37199: PUSH
37200: LD_INT 3
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: LD_INT 3
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: LD_INT 2
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 2
37230: NEG
37231: PUSH
37232: LD_INT 1
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 3
37252: NEG
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: LIST
37266: LIST
37267: LIST
37268: LIST
37269: LIST
37270: LIST
37271: LIST
37272: LIST
37273: LIST
37274: LIST
37275: LIST
37276: LIST
37277: LIST
37278: LIST
37279: LIST
37280: LIST
37281: LIST
37282: LIST
37283: LIST
37284: LIST
37285: LIST
37286: LIST
37287: LIST
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37293: LD_ADDR_VAR 0 47
37297: PUSH
37298: LD_INT 0
37300: PUSH
37301: LD_INT 0
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 1
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 1
37331: PUSH
37332: LD_INT 1
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 0
37341: PUSH
37342: LD_INT 1
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 1
37351: NEG
37352: PUSH
37353: LD_INT 0
37355: PUSH
37356: EMPTY
37357: LIST
37358: LIST
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: LD_INT 1
37366: NEG
37367: PUSH
37368: EMPTY
37369: LIST
37370: LIST
37371: PUSH
37372: LD_INT 1
37374: NEG
37375: PUSH
37376: LD_INT 2
37378: NEG
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 1
37397: PUSH
37398: LD_INT 1
37400: NEG
37401: PUSH
37402: EMPTY
37403: LIST
37404: LIST
37405: PUSH
37406: LD_INT 2
37408: NEG
37409: PUSH
37410: LD_INT 1
37412: NEG
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: LD_INT 2
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: LIST
37434: LIST
37435: LIST
37436: LIST
37437: LIST
37438: LIST
37439: LIST
37440: LIST
37441: LIST
37442: LIST
37443: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37444: LD_ADDR_VAR 0 48
37448: PUSH
37449: LD_INT 0
37451: PUSH
37452: LD_INT 0
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 0
37461: PUSH
37462: LD_INT 1
37464: NEG
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 1
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 0
37492: PUSH
37493: LD_INT 1
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 1
37502: NEG
37503: PUSH
37504: LD_INT 0
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 1
37513: NEG
37514: PUSH
37515: LD_INT 1
37517: NEG
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 1
37525: NEG
37526: PUSH
37527: LD_INT 2
37529: NEG
37530: PUSH
37531: EMPTY
37532: LIST
37533: LIST
37534: PUSH
37535: LD_INT 0
37537: PUSH
37538: LD_INT 2
37540: NEG
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 1
37548: PUSH
37549: LD_INT 1
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 2
37559: PUSH
37560: LD_INT 0
37562: PUSH
37563: EMPTY
37564: LIST
37565: LIST
37566: PUSH
37567: LD_INT 2
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37591: LD_ADDR_VAR 0 49
37595: PUSH
37596: LD_INT 0
37598: PUSH
37599: LD_INT 0
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 0
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: LD_INT 1
37619: PUSH
37620: LD_INT 0
37622: PUSH
37623: EMPTY
37624: LIST
37625: LIST
37626: PUSH
37627: LD_INT 1
37629: PUSH
37630: LD_INT 1
37632: PUSH
37633: EMPTY
37634: LIST
37635: LIST
37636: PUSH
37637: LD_INT 0
37639: PUSH
37640: LD_INT 1
37642: PUSH
37643: EMPTY
37644: LIST
37645: LIST
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 1
37660: NEG
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: PUSH
37670: LD_INT 1
37672: PUSH
37673: LD_INT 1
37675: NEG
37676: PUSH
37677: EMPTY
37678: LIST
37679: LIST
37680: PUSH
37681: LD_INT 2
37683: PUSH
37684: LD_INT 0
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: PUSH
37691: LD_INT 2
37693: PUSH
37694: LD_INT 1
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: LD_INT 2
37703: PUSH
37704: LD_INT 2
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: LD_INT 2
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37735: LD_ADDR_VAR 0 50
37739: PUSH
37740: LD_INT 0
37742: PUSH
37743: LD_INT 0
37745: PUSH
37746: EMPTY
37747: LIST
37748: LIST
37749: PUSH
37750: LD_INT 0
37752: PUSH
37753: LD_INT 1
37755: NEG
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: LD_INT 1
37763: PUSH
37764: LD_INT 0
37766: PUSH
37767: EMPTY
37768: LIST
37769: LIST
37770: PUSH
37771: LD_INT 1
37773: PUSH
37774: LD_INT 1
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: LD_INT 1
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 1
37793: NEG
37794: PUSH
37795: LD_INT 0
37797: PUSH
37798: EMPTY
37799: LIST
37800: LIST
37801: PUSH
37802: LD_INT 1
37804: NEG
37805: PUSH
37806: LD_INT 1
37808: NEG
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 2
37816: PUSH
37817: LD_INT 1
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 2
37826: PUSH
37827: LD_INT 2
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 1
37836: PUSH
37837: LD_INT 2
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 0
37846: PUSH
37847: LD_INT 2
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: NEG
37857: PUSH
37858: LD_INT 1
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37879: LD_ADDR_VAR 0 51
37883: PUSH
37884: LD_INT 0
37886: PUSH
37887: LD_INT 0
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 0
37896: PUSH
37897: LD_INT 1
37899: NEG
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 1
37907: PUSH
37908: LD_INT 0
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 1
37917: PUSH
37918: LD_INT 1
37920: PUSH
37921: EMPTY
37922: LIST
37923: LIST
37924: PUSH
37925: LD_INT 0
37927: PUSH
37928: LD_INT 1
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 1
37937: NEG
37938: PUSH
37939: LD_INT 0
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: LD_INT 1
37952: NEG
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 1
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 0
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: LD_INT 1
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 2
37991: NEG
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 2
38002: NEG
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: LIST
38019: LIST
38020: LIST
38021: LIST
38022: LIST
38023: LIST
38024: LIST
38025: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38026: LD_ADDR_VAR 0 52
38030: PUSH
38031: LD_INT 0
38033: PUSH
38034: LD_INT 0
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 0
38043: PUSH
38044: LD_INT 1
38046: NEG
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: LD_INT 1
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 1
38064: PUSH
38065: LD_INT 1
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 0
38074: PUSH
38075: LD_INT 1
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: LD_INT 0
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 1
38095: NEG
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: NEG
38108: PUSH
38109: LD_INT 2
38111: NEG
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: LD_INT 1
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: LD_INT 0
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 2
38141: NEG
38142: PUSH
38143: LD_INT 1
38145: NEG
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 2
38153: NEG
38154: PUSH
38155: LD_INT 2
38157: NEG
38158: PUSH
38159: EMPTY
38160: LIST
38161: LIST
38162: PUSH
38163: EMPTY
38164: LIST
38165: LIST
38166: LIST
38167: LIST
38168: LIST
38169: LIST
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38177: LD_ADDR_VAR 0 53
38181: PUSH
38182: LD_INT 0
38184: PUSH
38185: LD_INT 0
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 0
38194: PUSH
38195: LD_INT 1
38197: NEG
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: LD_INT 0
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 1
38215: PUSH
38216: LD_INT 1
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 1
38235: NEG
38236: PUSH
38237: LD_INT 0
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: LD_INT 1
38250: NEG
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: NEG
38259: PUSH
38260: LD_INT 2
38262: NEG
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: LD_INT 2
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 1
38281: PUSH
38282: LD_INT 1
38284: NEG
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 2
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 2
38302: PUSH
38303: LD_INT 1
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: PUSH
38313: LD_INT 2
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 1
38322: PUSH
38323: LD_INT 2
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 0
38332: PUSH
38333: LD_INT 2
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 1
38342: NEG
38343: PUSH
38344: LD_INT 1
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 2
38353: NEG
38354: PUSH
38355: LD_INT 0
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 2
38364: NEG
38365: PUSH
38366: LD_INT 1
38368: NEG
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 2
38376: NEG
38377: PUSH
38378: LD_INT 2
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38407: LD_ADDR_VAR 0 54
38411: PUSH
38412: LD_INT 0
38414: PUSH
38415: LD_INT 0
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: LD_INT 1
38427: NEG
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: LD_INT 0
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: LD_INT 1
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: LD_INT 1
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: LD_INT 0
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: LD_INT 1
38480: NEG
38481: PUSH
38482: EMPTY
38483: LIST
38484: LIST
38485: PUSH
38486: LD_INT 1
38488: NEG
38489: PUSH
38490: LD_INT 2
38492: NEG
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 0
38500: PUSH
38501: LD_INT 2
38503: NEG
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PUSH
38509: LD_INT 1
38511: PUSH
38512: LD_INT 1
38514: NEG
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 2
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 2
38532: PUSH
38533: LD_INT 1
38535: PUSH
38536: EMPTY
38537: LIST
38538: LIST
38539: PUSH
38540: LD_INT 2
38542: PUSH
38543: LD_INT 2
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 2
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 0
38562: PUSH
38563: LD_INT 2
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 1
38572: NEG
38573: PUSH
38574: LD_INT 1
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: LD_INT 2
38583: NEG
38584: PUSH
38585: LD_INT 0
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: LD_INT 2
38594: NEG
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 2
38606: NEG
38607: PUSH
38608: LD_INT 2
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: LIST
38636: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38637: LD_ADDR_VAR 0 55
38641: PUSH
38642: LD_INT 0
38644: PUSH
38645: LD_INT 0
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: LD_INT 1
38657: NEG
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 1
38665: PUSH
38666: LD_INT 0
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 1
38675: PUSH
38676: LD_INT 1
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 1
38695: NEG
38696: PUSH
38697: LD_INT 0
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: LD_INT 1
38710: NEG
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 1
38718: NEG
38719: PUSH
38720: LD_INT 2
38722: NEG
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: PUSH
38728: LD_INT 0
38730: PUSH
38731: LD_INT 2
38733: NEG
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 1
38741: PUSH
38742: LD_INT 1
38744: NEG
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 2
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 2
38762: PUSH
38763: LD_INT 1
38765: PUSH
38766: EMPTY
38767: LIST
38768: LIST
38769: PUSH
38770: LD_INT 2
38772: PUSH
38773: LD_INT 2
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 1
38782: PUSH
38783: LD_INT 2
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 0
38792: PUSH
38793: LD_INT 2
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 1
38802: NEG
38803: PUSH
38804: LD_INT 1
38806: PUSH
38807: EMPTY
38808: LIST
38809: LIST
38810: PUSH
38811: LD_INT 2
38813: NEG
38814: PUSH
38815: LD_INT 0
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 2
38824: NEG
38825: PUSH
38826: LD_INT 1
38828: NEG
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: LD_INT 2
38836: NEG
38837: PUSH
38838: LD_INT 2
38840: NEG
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: LIST
38866: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38867: LD_ADDR_VAR 0 56
38871: PUSH
38872: LD_INT 0
38874: PUSH
38875: LD_INT 0
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 0
38884: PUSH
38885: LD_INT 1
38887: NEG
38888: PUSH
38889: EMPTY
38890: LIST
38891: LIST
38892: PUSH
38893: LD_INT 1
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 1
38905: PUSH
38906: LD_INT 1
38908: PUSH
38909: EMPTY
38910: LIST
38911: LIST
38912: PUSH
38913: LD_INT 0
38915: PUSH
38916: LD_INT 1
38918: PUSH
38919: EMPTY
38920: LIST
38921: LIST
38922: PUSH
38923: LD_INT 1
38925: NEG
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: LD_INT 1
38940: NEG
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 1
38948: NEG
38949: PUSH
38950: LD_INT 2
38952: NEG
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 0
38960: PUSH
38961: LD_INT 2
38963: NEG
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 1
38971: PUSH
38972: LD_INT 1
38974: NEG
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 2
38982: PUSH
38983: LD_INT 0
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 2
38992: PUSH
38993: LD_INT 1
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: LD_INT 2
39002: PUSH
39003: LD_INT 2
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 1
39012: PUSH
39013: LD_INT 2
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 0
39022: PUSH
39023: LD_INT 2
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: NEG
39033: PUSH
39034: LD_INT 1
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: LD_INT 2
39043: NEG
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 2
39054: NEG
39055: PUSH
39056: LD_INT 1
39058: NEG
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: LD_INT 2
39066: NEG
39067: PUSH
39068: LD_INT 2
39070: NEG
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39097: LD_ADDR_VAR 0 57
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: NEG
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: NEG
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 1
39178: NEG
39179: PUSH
39180: LD_INT 2
39182: NEG
39183: PUSH
39184: EMPTY
39185: LIST
39186: LIST
39187: PUSH
39188: LD_INT 0
39190: PUSH
39191: LD_INT 2
39193: NEG
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 1
39201: PUSH
39202: LD_INT 1
39204: NEG
39205: PUSH
39206: EMPTY
39207: LIST
39208: LIST
39209: PUSH
39210: LD_INT 2
39212: PUSH
39213: LD_INT 0
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 2
39222: PUSH
39223: LD_INT 1
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: PUSH
39230: LD_INT 2
39232: PUSH
39233: LD_INT 2
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 1
39242: PUSH
39243: LD_INT 2
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 0
39252: PUSH
39253: LD_INT 2
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: NEG
39263: PUSH
39264: LD_INT 1
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 2
39273: NEG
39274: PUSH
39275: LD_INT 0
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: LD_INT 1
39288: NEG
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 2
39296: NEG
39297: PUSH
39298: LD_INT 2
39300: NEG
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: EMPTY
39307: LIST
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: LIST
39321: LIST
39322: LIST
39323: LIST
39324: LIST
39325: LIST
39326: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39327: LD_ADDR_VAR 0 58
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: LD_INT 0
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 0
39344: PUSH
39345: LD_INT 1
39347: NEG
39348: PUSH
39349: EMPTY
39350: LIST
39351: LIST
39352: PUSH
39353: LD_INT 1
39355: PUSH
39356: LD_INT 0
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 1
39365: PUSH
39366: LD_INT 1
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 0
39375: PUSH
39376: LD_INT 1
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: LD_INT 1
39385: NEG
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: LD_INT 1
39400: NEG
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 1
39408: NEG
39409: PUSH
39410: LD_INT 2
39412: NEG
39413: PUSH
39414: EMPTY
39415: LIST
39416: LIST
39417: PUSH
39418: LD_INT 0
39420: PUSH
39421: LD_INT 2
39423: NEG
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: LD_INT 1
39434: NEG
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 2
39442: PUSH
39443: LD_INT 0
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 2
39452: PUSH
39453: LD_INT 1
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 2
39462: PUSH
39463: LD_INT 2
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 1
39472: PUSH
39473: LD_INT 2
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 0
39482: PUSH
39483: LD_INT 2
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: NEG
39493: PUSH
39494: LD_INT 1
39496: PUSH
39497: EMPTY
39498: LIST
39499: LIST
39500: PUSH
39501: LD_INT 2
39503: NEG
39504: PUSH
39505: LD_INT 0
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 2
39514: NEG
39515: PUSH
39516: LD_INT 1
39518: NEG
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 2
39526: NEG
39527: PUSH
39528: LD_INT 2
39530: NEG
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: LIST
39553: LIST
39554: LIST
39555: LIST
39556: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39557: LD_ADDR_VAR 0 59
39561: PUSH
39562: LD_INT 0
39564: PUSH
39565: LD_INT 0
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 0
39574: PUSH
39575: LD_INT 1
39577: NEG
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: PUSH
39583: LD_INT 1
39585: PUSH
39586: LD_INT 0
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 1
39598: PUSH
39599: EMPTY
39600: LIST
39601: LIST
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: LD_INT 1
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: NEG
39616: PUSH
39617: LD_INT 0
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 1
39630: NEG
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39645: LD_ADDR_VAR 0 60
39649: PUSH
39650: LD_INT 0
39652: PUSH
39653: LD_INT 0
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: LD_INT 1
39665: NEG
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: LD_INT 0
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 1
39683: PUSH
39684: LD_INT 1
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 0
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 1
39703: NEG
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: LD_INT 1
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: LIST
39728: LIST
39729: LIST
39730: LIST
39731: LIST
39732: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39733: LD_ADDR_VAR 0 61
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: LD_INT 0
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 0
39750: PUSH
39751: LD_INT 1
39753: NEG
39754: PUSH
39755: EMPTY
39756: LIST
39757: LIST
39758: PUSH
39759: LD_INT 1
39761: PUSH
39762: LD_INT 0
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 1
39771: PUSH
39772: LD_INT 1
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 0
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 1
39791: NEG
39792: PUSH
39793: LD_INT 0
39795: PUSH
39796: EMPTY
39797: LIST
39798: LIST
39799: PUSH
39800: LD_INT 1
39802: NEG
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: LIST
39816: LIST
39817: LIST
39818: LIST
39819: LIST
39820: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39821: LD_ADDR_VAR 0 62
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: LD_INT 0
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: LD_INT 1
39841: NEG
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 1
39849: PUSH
39850: LD_INT 0
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 1
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 0
39869: PUSH
39870: LD_INT 1
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: NEG
39880: PUSH
39881: LD_INT 0
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 1
39890: NEG
39891: PUSH
39892: LD_INT 1
39894: NEG
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39909: LD_ADDR_VAR 0 63
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: LD_INT 0
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: LD_INT 1
39929: NEG
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: LD_INT 0
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: LD_INT 1
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 0
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: LD_INT 0
39971: PUSH
39972: EMPTY
39973: LIST
39974: LIST
39975: PUSH
39976: LD_INT 1
39978: NEG
39979: PUSH
39980: LD_INT 1
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39997: LD_ADDR_VAR 0 64
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: LD_INT 0
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 0
40014: PUSH
40015: LD_INT 1
40017: NEG
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 1
40025: PUSH
40026: LD_INT 0
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 1
40035: PUSH
40036: LD_INT 1
40038: PUSH
40039: EMPTY
40040: LIST
40041: LIST
40042: PUSH
40043: LD_INT 0
40045: PUSH
40046: LD_INT 1
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 1
40055: NEG
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 1
40066: NEG
40067: PUSH
40068: LD_INT 1
40070: NEG
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: LIST
40083: LIST
40084: ST_TO_ADDR
// end ; 1 :
40085: GO 45982
40087: LD_INT 1
40089: DOUBLE
40090: EQUAL
40091: IFTRUE 40095
40093: GO 42718
40095: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40096: LD_ADDR_VAR 0 11
40100: PUSH
40101: LD_INT 1
40103: NEG
40104: PUSH
40105: LD_INT 3
40107: NEG
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 0
40115: PUSH
40116: LD_INT 3
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 1
40126: PUSH
40127: LD_INT 2
40129: NEG
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: LIST
40139: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40140: LD_ADDR_VAR 0 12
40144: PUSH
40145: LD_INT 2
40147: PUSH
40148: LD_INT 1
40150: NEG
40151: PUSH
40152: EMPTY
40153: LIST
40154: LIST
40155: PUSH
40156: LD_INT 3
40158: PUSH
40159: LD_INT 0
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 3
40168: PUSH
40169: LD_INT 1
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: LIST
40180: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40181: LD_ADDR_VAR 0 13
40185: PUSH
40186: LD_INT 3
40188: PUSH
40189: LD_INT 2
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 3
40198: PUSH
40199: LD_INT 3
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 2
40208: PUSH
40209: LD_INT 3
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: LIST
40220: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40221: LD_ADDR_VAR 0 14
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: LD_INT 3
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: LD_INT 3
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 1
40248: NEG
40249: PUSH
40250: LD_INT 2
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: LIST
40261: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40262: LD_ADDR_VAR 0 15
40266: PUSH
40267: LD_INT 2
40269: NEG
40270: PUSH
40271: LD_INT 1
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 3
40280: NEG
40281: PUSH
40282: LD_INT 0
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 3
40291: NEG
40292: PUSH
40293: LD_INT 1
40295: NEG
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: LIST
40305: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40306: LD_ADDR_VAR 0 16
40310: PUSH
40311: LD_INT 2
40313: NEG
40314: PUSH
40315: LD_INT 3
40317: NEG
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 3
40325: NEG
40326: PUSH
40327: LD_INT 2
40329: NEG
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 3
40337: NEG
40338: PUSH
40339: LD_INT 3
40341: NEG
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: LIST
40351: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40352: LD_ADDR_VAR 0 17
40356: PUSH
40357: LD_INT 1
40359: NEG
40360: PUSH
40361: LD_INT 3
40363: NEG
40364: PUSH
40365: EMPTY
40366: LIST
40367: LIST
40368: PUSH
40369: LD_INT 0
40371: PUSH
40372: LD_INT 3
40374: NEG
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 1
40382: PUSH
40383: LD_INT 2
40385: NEG
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: LIST
40395: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40396: LD_ADDR_VAR 0 18
40400: PUSH
40401: LD_INT 2
40403: PUSH
40404: LD_INT 1
40406: NEG
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: LD_INT 3
40414: PUSH
40415: LD_INT 0
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 3
40424: PUSH
40425: LD_INT 1
40427: PUSH
40428: EMPTY
40429: LIST
40430: LIST
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: LIST
40436: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40437: LD_ADDR_VAR 0 19
40441: PUSH
40442: LD_INT 3
40444: PUSH
40445: LD_INT 2
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 3
40454: PUSH
40455: LD_INT 3
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 2
40464: PUSH
40465: LD_INT 3
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: LIST
40476: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40477: LD_ADDR_VAR 0 20
40481: PUSH
40482: LD_INT 1
40484: PUSH
40485: LD_INT 3
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 0
40494: PUSH
40495: LD_INT 3
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 1
40504: NEG
40505: PUSH
40506: LD_INT 2
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: LIST
40517: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40518: LD_ADDR_VAR 0 21
40522: PUSH
40523: LD_INT 2
40525: NEG
40526: PUSH
40527: LD_INT 1
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 3
40536: NEG
40537: PUSH
40538: LD_INT 0
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 3
40547: NEG
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: LIST
40561: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40562: LD_ADDR_VAR 0 22
40566: PUSH
40567: LD_INT 2
40569: NEG
40570: PUSH
40571: LD_INT 3
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 3
40581: NEG
40582: PUSH
40583: LD_INT 2
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 3
40593: NEG
40594: PUSH
40595: LD_INT 3
40597: NEG
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: LIST
40607: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40608: LD_ADDR_VAR 0 23
40612: PUSH
40613: LD_INT 0
40615: PUSH
40616: LD_INT 3
40618: NEG
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 1
40626: NEG
40627: PUSH
40628: LD_INT 4
40630: NEG
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 1
40638: PUSH
40639: LD_INT 3
40641: NEG
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: LIST
40651: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40652: LD_ADDR_VAR 0 24
40656: PUSH
40657: LD_INT 3
40659: PUSH
40660: LD_INT 0
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 3
40669: PUSH
40670: LD_INT 1
40672: NEG
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 4
40680: PUSH
40681: LD_INT 1
40683: PUSH
40684: EMPTY
40685: LIST
40686: LIST
40687: PUSH
40688: EMPTY
40689: LIST
40690: LIST
40691: LIST
40692: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40693: LD_ADDR_VAR 0 25
40697: PUSH
40698: LD_INT 3
40700: PUSH
40701: LD_INT 3
40703: PUSH
40704: EMPTY
40705: LIST
40706: LIST
40707: PUSH
40708: LD_INT 4
40710: PUSH
40711: LD_INT 3
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 3
40720: PUSH
40721: LD_INT 4
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: LIST
40732: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40733: LD_ADDR_VAR 0 26
40737: PUSH
40738: LD_INT 0
40740: PUSH
40741: LD_INT 3
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 1
40750: PUSH
40751: LD_INT 4
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 1
40760: NEG
40761: PUSH
40762: LD_INT 3
40764: PUSH
40765: EMPTY
40766: LIST
40767: LIST
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: LIST
40773: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40774: LD_ADDR_VAR 0 27
40778: PUSH
40779: LD_INT 3
40781: NEG
40782: PUSH
40783: LD_INT 0
40785: PUSH
40786: EMPTY
40787: LIST
40788: LIST
40789: PUSH
40790: LD_INT 3
40792: NEG
40793: PUSH
40794: LD_INT 1
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 4
40803: NEG
40804: PUSH
40805: LD_INT 1
40807: NEG
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40818: LD_ADDR_VAR 0 28
40822: PUSH
40823: LD_INT 3
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 3
40837: NEG
40838: PUSH
40839: LD_INT 4
40841: NEG
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 4
40849: NEG
40850: PUSH
40851: LD_INT 3
40853: NEG
40854: PUSH
40855: EMPTY
40856: LIST
40857: LIST
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: LIST
40863: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40864: LD_ADDR_VAR 0 29
40868: PUSH
40869: LD_INT 1
40871: NEG
40872: PUSH
40873: LD_INT 3
40875: NEG
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: LD_INT 3
40886: NEG
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 1
40894: PUSH
40895: LD_INT 2
40897: NEG
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 1
40905: NEG
40906: PUSH
40907: LD_INT 4
40909: NEG
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 0
40917: PUSH
40918: LD_INT 4
40920: NEG
40921: PUSH
40922: EMPTY
40923: LIST
40924: LIST
40925: PUSH
40926: LD_INT 1
40928: PUSH
40929: LD_INT 3
40931: NEG
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: LD_INT 5
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 0
40951: PUSH
40952: LD_INT 5
40954: NEG
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 1
40962: PUSH
40963: LD_INT 4
40965: NEG
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: LD_INT 1
40973: NEG
40974: PUSH
40975: LD_INT 6
40977: NEG
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: PUSH
40983: LD_INT 0
40985: PUSH
40986: LD_INT 6
40988: NEG
40989: PUSH
40990: EMPTY
40991: LIST
40992: LIST
40993: PUSH
40994: LD_INT 1
40996: PUSH
40997: LD_INT 5
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: LIST
41018: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41019: LD_ADDR_VAR 0 30
41023: PUSH
41024: LD_INT 2
41026: PUSH
41027: LD_INT 1
41029: NEG
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 3
41037: PUSH
41038: LD_INT 0
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: PUSH
41048: LD_INT 1
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: PUSH
41055: LD_INT 3
41057: PUSH
41058: LD_INT 1
41060: NEG
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PUSH
41066: LD_INT 4
41068: PUSH
41069: LD_INT 0
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: LD_INT 4
41078: PUSH
41079: LD_INT 1
41081: PUSH
41082: EMPTY
41083: LIST
41084: LIST
41085: PUSH
41086: LD_INT 4
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 5
41099: PUSH
41100: LD_INT 0
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 5
41109: PUSH
41110: LD_INT 1
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 5
41119: PUSH
41120: LD_INT 1
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 6
41130: PUSH
41131: LD_INT 0
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 6
41140: PUSH
41141: LD_INT 1
41143: PUSH
41144: EMPTY
41145: LIST
41146: LIST
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: LIST
41152: LIST
41153: LIST
41154: LIST
41155: LIST
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41162: LD_ADDR_VAR 0 31
41166: PUSH
41167: LD_INT 3
41169: PUSH
41170: LD_INT 2
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: PUSH
41180: LD_INT 3
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 2
41189: PUSH
41190: LD_INT 3
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 4
41199: PUSH
41200: LD_INT 3
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 4
41209: PUSH
41210: LD_INT 4
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 3
41219: PUSH
41220: LD_INT 4
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 5
41229: PUSH
41230: LD_INT 4
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 5
41239: PUSH
41240: LD_INT 5
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 4
41249: PUSH
41250: LD_INT 5
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 6
41259: PUSH
41260: LD_INT 5
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 6
41269: PUSH
41270: LD_INT 6
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 5
41279: PUSH
41280: LD_INT 6
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: LIST
41291: LIST
41292: LIST
41293: LIST
41294: LIST
41295: LIST
41296: LIST
41297: LIST
41298: LIST
41299: LIST
41300: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41301: LD_ADDR_VAR 0 32
41305: PUSH
41306: LD_INT 1
41308: PUSH
41309: LD_INT 3
41311: PUSH
41312: EMPTY
41313: LIST
41314: LIST
41315: PUSH
41316: LD_INT 0
41318: PUSH
41319: LD_INT 3
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 1
41328: NEG
41329: PUSH
41330: LD_INT 2
41332: PUSH
41333: EMPTY
41334: LIST
41335: LIST
41336: PUSH
41337: LD_INT 1
41339: PUSH
41340: LD_INT 4
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 0
41349: PUSH
41350: LD_INT 4
41352: PUSH
41353: EMPTY
41354: LIST
41355: LIST
41356: PUSH
41357: LD_INT 1
41359: NEG
41360: PUSH
41361: LD_INT 3
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 1
41370: PUSH
41371: LD_INT 5
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 0
41380: PUSH
41381: LD_INT 5
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 1
41390: NEG
41391: PUSH
41392: LD_INT 4
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 1
41401: PUSH
41402: LD_INT 6
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: LD_INT 6
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: LD_INT 5
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: LIST
41434: LIST
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41444: LD_ADDR_VAR 0 33
41448: PUSH
41449: LD_INT 2
41451: NEG
41452: PUSH
41453: LD_INT 1
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: PUSH
41460: LD_INT 3
41462: NEG
41463: PUSH
41464: LD_INT 0
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 3
41473: NEG
41474: PUSH
41475: LD_INT 1
41477: NEG
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 3
41485: NEG
41486: PUSH
41487: LD_INT 1
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 4
41496: NEG
41497: PUSH
41498: LD_INT 0
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 4
41507: NEG
41508: PUSH
41509: LD_INT 1
41511: NEG
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 4
41519: NEG
41520: PUSH
41521: LD_INT 1
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 5
41530: NEG
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 5
41541: NEG
41542: PUSH
41543: LD_INT 1
41545: NEG
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 5
41553: NEG
41554: PUSH
41555: LD_INT 1
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 6
41564: NEG
41565: PUSH
41566: LD_INT 0
41568: PUSH
41569: EMPTY
41570: LIST
41571: LIST
41572: PUSH
41573: LD_INT 6
41575: NEG
41576: PUSH
41577: LD_INT 1
41579: NEG
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: EMPTY
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: LIST
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41599: LD_ADDR_VAR 0 34
41603: PUSH
41604: LD_INT 2
41606: NEG
41607: PUSH
41608: LD_INT 3
41610: NEG
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 3
41618: NEG
41619: PUSH
41620: LD_INT 2
41622: NEG
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: LD_INT 3
41630: NEG
41631: PUSH
41632: LD_INT 3
41634: NEG
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 3
41642: NEG
41643: PUSH
41644: LD_INT 4
41646: NEG
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 4
41654: NEG
41655: PUSH
41656: LD_INT 3
41658: NEG
41659: PUSH
41660: EMPTY
41661: LIST
41662: LIST
41663: PUSH
41664: LD_INT 4
41666: NEG
41667: PUSH
41668: LD_INT 4
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 4
41678: NEG
41679: PUSH
41680: LD_INT 5
41682: NEG
41683: PUSH
41684: EMPTY
41685: LIST
41686: LIST
41687: PUSH
41688: LD_INT 5
41690: NEG
41691: PUSH
41692: LD_INT 4
41694: NEG
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: PUSH
41700: LD_INT 5
41702: NEG
41703: PUSH
41704: LD_INT 5
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 5
41714: NEG
41715: PUSH
41716: LD_INT 6
41718: NEG
41719: PUSH
41720: EMPTY
41721: LIST
41722: LIST
41723: PUSH
41724: LD_INT 6
41726: NEG
41727: PUSH
41728: LD_INT 5
41730: NEG
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 6
41738: NEG
41739: PUSH
41740: LD_INT 6
41742: NEG
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41762: LD_ADDR_VAR 0 41
41766: PUSH
41767: LD_INT 0
41769: PUSH
41770: LD_INT 2
41772: NEG
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 1
41780: NEG
41781: PUSH
41782: LD_INT 3
41784: NEG
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: LD_INT 1
41792: PUSH
41793: LD_INT 2
41795: NEG
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: LIST
41805: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41806: LD_ADDR_VAR 0 42
41810: PUSH
41811: LD_INT 2
41813: PUSH
41814: LD_INT 0
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: LD_INT 2
41823: PUSH
41824: LD_INT 1
41826: NEG
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 3
41834: PUSH
41835: LD_INT 1
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: EMPTY
41843: LIST
41844: LIST
41845: LIST
41846: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41847: LD_ADDR_VAR 0 43
41851: PUSH
41852: LD_INT 2
41854: PUSH
41855: LD_INT 2
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 3
41864: PUSH
41865: LD_INT 2
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 2
41874: PUSH
41875: LD_INT 3
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: LIST
41886: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41887: LD_ADDR_VAR 0 44
41891: PUSH
41892: LD_INT 0
41894: PUSH
41895: LD_INT 2
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 1
41904: PUSH
41905: LD_INT 3
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 1
41914: NEG
41915: PUSH
41916: LD_INT 2
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: LIST
41927: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41928: LD_ADDR_VAR 0 45
41932: PUSH
41933: LD_INT 2
41935: NEG
41936: PUSH
41937: LD_INT 0
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 2
41946: NEG
41947: PUSH
41948: LD_INT 1
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 3
41957: NEG
41958: PUSH
41959: LD_INT 1
41961: NEG
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: LIST
41971: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41972: LD_ADDR_VAR 0 46
41976: PUSH
41977: LD_INT 2
41979: NEG
41980: PUSH
41981: LD_INT 2
41983: NEG
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 2
41991: NEG
41992: PUSH
41993: LD_INT 3
41995: NEG
41996: PUSH
41997: EMPTY
41998: LIST
41999: LIST
42000: PUSH
42001: LD_INT 3
42003: NEG
42004: PUSH
42005: LD_INT 2
42007: NEG
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: LIST
42017: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42018: LD_ADDR_VAR 0 47
42022: PUSH
42023: LD_INT 2
42025: NEG
42026: PUSH
42027: LD_INT 3
42029: NEG
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 1
42037: NEG
42038: PUSH
42039: LD_INT 3
42041: NEG
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42051: LD_ADDR_VAR 0 48
42055: PUSH
42056: LD_INT 1
42058: PUSH
42059: LD_INT 2
42061: NEG
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: LD_INT 2
42069: PUSH
42070: LD_INT 1
42072: NEG
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: EMPTY
42079: LIST
42080: LIST
42081: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42082: LD_ADDR_VAR 0 49
42086: PUSH
42087: LD_INT 3
42089: PUSH
42090: LD_INT 1
42092: PUSH
42093: EMPTY
42094: LIST
42095: LIST
42096: PUSH
42097: LD_INT 3
42099: PUSH
42100: LD_INT 2
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42111: LD_ADDR_VAR 0 50
42115: PUSH
42116: LD_INT 2
42118: PUSH
42119: LD_INT 3
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 1
42128: PUSH
42129: LD_INT 3
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42140: LD_ADDR_VAR 0 51
42144: PUSH
42145: LD_INT 1
42147: NEG
42148: PUSH
42149: LD_INT 2
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: PUSH
42156: LD_INT 2
42158: NEG
42159: PUSH
42160: LD_INT 1
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42171: LD_ADDR_VAR 0 52
42175: PUSH
42176: LD_INT 3
42178: NEG
42179: PUSH
42180: LD_INT 1
42182: NEG
42183: PUSH
42184: EMPTY
42185: LIST
42186: LIST
42187: PUSH
42188: LD_INT 3
42190: NEG
42191: PUSH
42192: LD_INT 2
42194: NEG
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: EMPTY
42201: LIST
42202: LIST
42203: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42204: LD_ADDR_VAR 0 53
42208: PUSH
42209: LD_INT 1
42211: NEG
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 0
42223: PUSH
42224: LD_INT 3
42226: NEG
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 1
42234: PUSH
42235: LD_INT 2
42237: NEG
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: LIST
42247: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42248: LD_ADDR_VAR 0 54
42252: PUSH
42253: LD_INT 2
42255: PUSH
42256: LD_INT 1
42258: NEG
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PUSH
42264: LD_INT 3
42266: PUSH
42267: LD_INT 0
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 3
42276: PUSH
42277: LD_INT 1
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: LIST
42288: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42289: LD_ADDR_VAR 0 55
42293: PUSH
42294: LD_INT 3
42296: PUSH
42297: LD_INT 2
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 3
42306: PUSH
42307: LD_INT 3
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 2
42316: PUSH
42317: LD_INT 3
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: LIST
42328: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42329: LD_ADDR_VAR 0 56
42333: PUSH
42334: LD_INT 1
42336: PUSH
42337: LD_INT 3
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: LD_INT 0
42346: PUSH
42347: LD_INT 3
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 1
42356: NEG
42357: PUSH
42358: LD_INT 2
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: LIST
42369: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42370: LD_ADDR_VAR 0 57
42374: PUSH
42375: LD_INT 2
42377: NEG
42378: PUSH
42379: LD_INT 1
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: LD_INT 0
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 3
42399: NEG
42400: PUSH
42401: LD_INT 1
42403: NEG
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42414: LD_ADDR_VAR 0 58
42418: PUSH
42419: LD_INT 2
42421: NEG
42422: PUSH
42423: LD_INT 3
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: LD_INT 3
42433: NEG
42434: PUSH
42435: LD_INT 2
42437: NEG
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: PUSH
42443: LD_INT 3
42445: NEG
42446: PUSH
42447: LD_INT 3
42449: NEG
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: LIST
42459: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42460: LD_ADDR_VAR 0 59
42464: PUSH
42465: LD_INT 1
42467: NEG
42468: PUSH
42469: LD_INT 2
42471: NEG
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 0
42479: PUSH
42480: LD_INT 2
42482: NEG
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 1
42490: PUSH
42491: LD_INT 1
42493: NEG
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: LIST
42503: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42504: LD_ADDR_VAR 0 60
42508: PUSH
42509: LD_INT 1
42511: PUSH
42512: LD_INT 1
42514: NEG
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: LD_INT 2
42522: PUSH
42523: LD_INT 0
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: PUSH
42530: LD_INT 2
42532: PUSH
42533: LD_INT 1
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: PUSH
42540: EMPTY
42541: LIST
42542: LIST
42543: LIST
42544: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42545: LD_ADDR_VAR 0 61
42549: PUSH
42550: LD_INT 2
42552: PUSH
42553: LD_INT 1
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: LD_INT 2
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 2
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42585: LD_ADDR_VAR 0 62
42589: PUSH
42590: LD_INT 1
42592: PUSH
42593: LD_INT 2
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: PUSH
42600: LD_INT 0
42602: PUSH
42603: LD_INT 2
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: LD_INT 1
42612: NEG
42613: PUSH
42614: LD_INT 1
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: LIST
42625: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42626: LD_ADDR_VAR 0 63
42630: PUSH
42631: LD_INT 1
42633: NEG
42634: PUSH
42635: LD_INT 1
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 2
42644: NEG
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 2
42655: NEG
42656: PUSH
42657: LD_INT 1
42659: NEG
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: LIST
42669: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42670: LD_ADDR_VAR 0 64
42674: PUSH
42675: LD_INT 1
42677: NEG
42678: PUSH
42679: LD_INT 2
42681: NEG
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: LD_INT 2
42689: NEG
42690: PUSH
42691: LD_INT 1
42693: NEG
42694: PUSH
42695: EMPTY
42696: LIST
42697: LIST
42698: PUSH
42699: LD_INT 2
42701: NEG
42702: PUSH
42703: LD_INT 2
42705: NEG
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: LIST
42715: ST_TO_ADDR
// end ; 2 :
42716: GO 45982
42718: LD_INT 2
42720: DOUBLE
42721: EQUAL
42722: IFTRUE 42726
42724: GO 45981
42726: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42727: LD_ADDR_VAR 0 29
42731: PUSH
42732: LD_INT 4
42734: PUSH
42735: LD_INT 0
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: LD_INT 4
42744: PUSH
42745: LD_INT 1
42747: NEG
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 5
42755: PUSH
42756: LD_INT 0
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 5
42765: PUSH
42766: LD_INT 1
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 4
42775: PUSH
42776: LD_INT 1
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 3
42785: PUSH
42786: LD_INT 0
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 3
42795: PUSH
42796: LD_INT 1
42798: NEG
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 3
42806: PUSH
42807: LD_INT 2
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 5
42817: PUSH
42818: LD_INT 2
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 3
42827: PUSH
42828: LD_INT 3
42830: PUSH
42831: EMPTY
42832: LIST
42833: LIST
42834: PUSH
42835: LD_INT 3
42837: PUSH
42838: LD_INT 2
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 4
42847: PUSH
42848: LD_INT 3
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 4
42857: PUSH
42858: LD_INT 4
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 3
42867: PUSH
42868: LD_INT 4
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 2
42877: PUSH
42878: LD_INT 3
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 2
42887: PUSH
42888: LD_INT 2
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 4
42897: PUSH
42898: LD_INT 2
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: LD_INT 2
42907: PUSH
42908: LD_INT 4
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 0
42917: PUSH
42918: LD_INT 4
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: LD_INT 3
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 1
42937: PUSH
42938: LD_INT 4
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 1
42947: PUSH
42948: LD_INT 5
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 0
42957: PUSH
42958: LD_INT 5
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 1
42967: NEG
42968: PUSH
42969: LD_INT 4
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 1
42978: NEG
42979: PUSH
42980: LD_INT 3
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 2
42989: PUSH
42990: LD_INT 5
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 2
42999: NEG
43000: PUSH
43001: LD_INT 3
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: LD_INT 3
43010: NEG
43011: PUSH
43012: LD_INT 0
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 3
43021: NEG
43022: PUSH
43023: LD_INT 1
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: LD_INT 2
43033: NEG
43034: PUSH
43035: LD_INT 0
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 2
43044: NEG
43045: PUSH
43046: LD_INT 1
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 3
43055: NEG
43056: PUSH
43057: LD_INT 1
43059: PUSH
43060: EMPTY
43061: LIST
43062: LIST
43063: PUSH
43064: LD_INT 4
43066: NEG
43067: PUSH
43068: LD_INT 0
43070: PUSH
43071: EMPTY
43072: LIST
43073: LIST
43074: PUSH
43075: LD_INT 4
43077: NEG
43078: PUSH
43079: LD_INT 1
43081: NEG
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 4
43089: NEG
43090: PUSH
43091: LD_INT 2
43093: NEG
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 2
43101: NEG
43102: PUSH
43103: LD_INT 2
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_INT 4
43112: NEG
43113: PUSH
43114: LD_INT 4
43116: NEG
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: PUSH
43122: LD_INT 4
43124: NEG
43125: PUSH
43126: LD_INT 5
43128: NEG
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 3
43136: NEG
43137: PUSH
43138: LD_INT 4
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 3
43148: NEG
43149: PUSH
43150: LD_INT 3
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 4
43160: NEG
43161: PUSH
43162: LD_INT 3
43164: NEG
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: LD_INT 5
43172: NEG
43173: PUSH
43174: LD_INT 4
43176: NEG
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: LD_INT 5
43184: NEG
43185: PUSH
43186: LD_INT 5
43188: NEG
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: LD_INT 3
43196: NEG
43197: PUSH
43198: LD_INT 5
43200: NEG
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: PUSH
43206: LD_INT 5
43208: NEG
43209: PUSH
43210: LD_INT 3
43212: NEG
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: LIST
43233: LIST
43234: LIST
43235: LIST
43236: LIST
43237: LIST
43238: LIST
43239: LIST
43240: LIST
43241: LIST
43242: LIST
43243: LIST
43244: LIST
43245: LIST
43246: LIST
43247: LIST
43248: LIST
43249: LIST
43250: LIST
43251: LIST
43252: LIST
43253: LIST
43254: LIST
43255: LIST
43256: LIST
43257: LIST
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43265: LD_ADDR_VAR 0 30
43269: PUSH
43270: LD_INT 4
43272: PUSH
43273: LD_INT 4
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 4
43282: PUSH
43283: LD_INT 3
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 5
43292: PUSH
43293: LD_INT 4
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 5
43302: PUSH
43303: LD_INT 5
43305: PUSH
43306: EMPTY
43307: LIST
43308: LIST
43309: PUSH
43310: LD_INT 4
43312: PUSH
43313: LD_INT 5
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 3
43322: PUSH
43323: LD_INT 4
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 3
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 5
43342: PUSH
43343: LD_INT 3
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 3
43352: PUSH
43353: LD_INT 5
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 0
43362: PUSH
43363: LD_INT 3
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 0
43372: PUSH
43373: LD_INT 2
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 1
43382: PUSH
43383: LD_INT 3
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 1
43392: PUSH
43393: LD_INT 4
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: LD_INT 4
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 1
43412: NEG
43413: PUSH
43414: LD_INT 3
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 1
43423: NEG
43424: PUSH
43425: LD_INT 2
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 2
43434: PUSH
43435: LD_INT 4
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 2
43444: NEG
43445: PUSH
43446: LD_INT 2
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: PUSH
43453: LD_INT 4
43455: NEG
43456: PUSH
43457: LD_INT 0
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 4
43466: NEG
43467: PUSH
43468: LD_INT 1
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 3
43478: NEG
43479: PUSH
43480: LD_INT 0
43482: PUSH
43483: EMPTY
43484: LIST
43485: LIST
43486: PUSH
43487: LD_INT 3
43489: NEG
43490: PUSH
43491: LD_INT 1
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 4
43500: NEG
43501: PUSH
43502: LD_INT 1
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 5
43511: NEG
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: EMPTY
43517: LIST
43518: LIST
43519: PUSH
43520: LD_INT 5
43522: NEG
43523: PUSH
43524: LD_INT 1
43526: NEG
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 5
43534: NEG
43535: PUSH
43536: LD_INT 2
43538: NEG
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 3
43546: NEG
43547: PUSH
43548: LD_INT 2
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 3
43557: NEG
43558: PUSH
43559: LD_INT 3
43561: NEG
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 3
43569: NEG
43570: PUSH
43571: LD_INT 4
43573: NEG
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 2
43581: NEG
43582: PUSH
43583: LD_INT 3
43585: NEG
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 2
43593: NEG
43594: PUSH
43595: LD_INT 2
43597: NEG
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 3
43605: NEG
43606: PUSH
43607: LD_INT 2
43609: NEG
43610: PUSH
43611: EMPTY
43612: LIST
43613: LIST
43614: PUSH
43615: LD_INT 4
43617: NEG
43618: PUSH
43619: LD_INT 3
43621: NEG
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 4
43629: NEG
43630: PUSH
43631: LD_INT 4
43633: NEG
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 2
43641: NEG
43642: PUSH
43643: LD_INT 4
43645: NEG
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: PUSH
43651: LD_INT 4
43653: NEG
43654: PUSH
43655: LD_INT 2
43657: NEG
43658: PUSH
43659: EMPTY
43660: LIST
43661: LIST
43662: PUSH
43663: LD_INT 0
43665: PUSH
43666: LD_INT 4
43668: NEG
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 0
43676: PUSH
43677: LD_INT 5
43679: NEG
43680: PUSH
43681: EMPTY
43682: LIST
43683: LIST
43684: PUSH
43685: LD_INT 1
43687: PUSH
43688: LD_INT 4
43690: NEG
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 1
43698: PUSH
43699: LD_INT 3
43701: NEG
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 0
43709: PUSH
43710: LD_INT 3
43712: NEG
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 1
43720: NEG
43721: PUSH
43722: LD_INT 4
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 1
43732: NEG
43733: PUSH
43734: LD_INT 5
43736: NEG
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 2
43744: PUSH
43745: LD_INT 3
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 2
43755: NEG
43756: PUSH
43757: LD_INT 5
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: LIST
43769: LIST
43770: LIST
43771: LIST
43772: LIST
43773: LIST
43774: LIST
43775: LIST
43776: LIST
43777: LIST
43778: LIST
43779: LIST
43780: LIST
43781: LIST
43782: LIST
43783: LIST
43784: LIST
43785: LIST
43786: LIST
43787: LIST
43788: LIST
43789: LIST
43790: LIST
43791: LIST
43792: LIST
43793: LIST
43794: LIST
43795: LIST
43796: LIST
43797: LIST
43798: LIST
43799: LIST
43800: LIST
43801: LIST
43802: LIST
43803: LIST
43804: LIST
43805: LIST
43806: LIST
43807: LIST
43808: LIST
43809: LIST
43810: LIST
43811: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43812: LD_ADDR_VAR 0 31
43816: PUSH
43817: LD_INT 0
43819: PUSH
43820: LD_INT 4
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PUSH
43827: LD_INT 0
43829: PUSH
43830: LD_INT 3
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: PUSH
43840: LD_INT 4
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: PUSH
43847: LD_INT 1
43849: PUSH
43850: LD_INT 5
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 0
43859: PUSH
43860: LD_INT 5
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 1
43869: NEG
43870: PUSH
43871: LD_INT 4
43873: PUSH
43874: EMPTY
43875: LIST
43876: LIST
43877: PUSH
43878: LD_INT 1
43880: NEG
43881: PUSH
43882: LD_INT 3
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 2
43891: PUSH
43892: LD_INT 5
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 2
43901: NEG
43902: PUSH
43903: LD_INT 3
43905: PUSH
43906: EMPTY
43907: LIST
43908: LIST
43909: PUSH
43910: LD_INT 3
43912: NEG
43913: PUSH
43914: LD_INT 0
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 3
43923: NEG
43924: PUSH
43925: LD_INT 1
43927: NEG
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 2
43935: NEG
43936: PUSH
43937: LD_INT 0
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: LD_INT 1
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 3
43957: NEG
43958: PUSH
43959: LD_INT 1
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 4
43968: NEG
43969: PUSH
43970: LD_INT 0
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 4
43979: NEG
43980: PUSH
43981: LD_INT 1
43983: NEG
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 4
43991: NEG
43992: PUSH
43993: LD_INT 2
43995: NEG
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: NEG
44004: PUSH
44005: LD_INT 2
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 4
44014: NEG
44015: PUSH
44016: LD_INT 4
44018: NEG
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 4
44026: NEG
44027: PUSH
44028: LD_INT 5
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 3
44038: NEG
44039: PUSH
44040: LD_INT 4
44042: NEG
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 3
44050: NEG
44051: PUSH
44052: LD_INT 3
44054: NEG
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 4
44062: NEG
44063: PUSH
44064: LD_INT 3
44066: NEG
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 5
44074: NEG
44075: PUSH
44076: LD_INT 4
44078: NEG
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 5
44086: NEG
44087: PUSH
44088: LD_INT 5
44090: NEG
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PUSH
44096: LD_INT 3
44098: NEG
44099: PUSH
44100: LD_INT 5
44102: NEG
44103: PUSH
44104: EMPTY
44105: LIST
44106: LIST
44107: PUSH
44108: LD_INT 5
44110: NEG
44111: PUSH
44112: LD_INT 3
44114: NEG
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 0
44122: PUSH
44123: LD_INT 3
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 0
44133: PUSH
44134: LD_INT 4
44136: NEG
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: PUSH
44142: LD_INT 1
44144: PUSH
44145: LD_INT 3
44147: NEG
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: PUSH
44153: LD_INT 1
44155: PUSH
44156: LD_INT 2
44158: NEG
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 0
44166: PUSH
44167: LD_INT 2
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 1
44177: NEG
44178: PUSH
44179: LD_INT 3
44181: NEG
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 1
44189: NEG
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 2
44201: PUSH
44202: LD_INT 2
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 2
44212: NEG
44213: PUSH
44214: LD_INT 4
44216: NEG
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 4
44224: PUSH
44225: LD_INT 0
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 4
44234: PUSH
44235: LD_INT 1
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 5
44245: PUSH
44246: LD_INT 0
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: LD_INT 5
44255: PUSH
44256: LD_INT 1
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 4
44265: PUSH
44266: LD_INT 1
44268: PUSH
44269: EMPTY
44270: LIST
44271: LIST
44272: PUSH
44273: LD_INT 3
44275: PUSH
44276: LD_INT 0
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 3
44285: PUSH
44286: LD_INT 1
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 3
44296: PUSH
44297: LD_INT 2
44299: NEG
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 5
44307: PUSH
44308: LD_INT 2
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: EMPTY
44316: LIST
44317: LIST
44318: LIST
44319: LIST
44320: LIST
44321: LIST
44322: LIST
44323: LIST
44324: LIST
44325: LIST
44326: LIST
44327: LIST
44328: LIST
44329: LIST
44330: LIST
44331: LIST
44332: LIST
44333: LIST
44334: LIST
44335: LIST
44336: LIST
44337: LIST
44338: LIST
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44362: LD_ADDR_VAR 0 32
44366: PUSH
44367: LD_INT 4
44369: NEG
44370: PUSH
44371: LD_INT 0
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 4
44380: NEG
44381: PUSH
44382: LD_INT 1
44384: NEG
44385: PUSH
44386: EMPTY
44387: LIST
44388: LIST
44389: PUSH
44390: LD_INT 3
44392: NEG
44393: PUSH
44394: LD_INT 0
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 3
44403: NEG
44404: PUSH
44405: LD_INT 1
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 4
44414: NEG
44415: PUSH
44416: LD_INT 1
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 5
44425: NEG
44426: PUSH
44427: LD_INT 0
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 5
44436: NEG
44437: PUSH
44438: LD_INT 1
44440: NEG
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 5
44448: NEG
44449: PUSH
44450: LD_INT 2
44452: NEG
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: PUSH
44458: LD_INT 3
44460: NEG
44461: PUSH
44462: LD_INT 2
44464: PUSH
44465: EMPTY
44466: LIST
44467: LIST
44468: PUSH
44469: LD_INT 3
44471: NEG
44472: PUSH
44473: LD_INT 3
44475: NEG
44476: PUSH
44477: EMPTY
44478: LIST
44479: LIST
44480: PUSH
44481: LD_INT 3
44483: NEG
44484: PUSH
44485: LD_INT 4
44487: NEG
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 2
44495: NEG
44496: PUSH
44497: LD_INT 3
44499: NEG
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 2
44507: NEG
44508: PUSH
44509: LD_INT 2
44511: NEG
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 3
44519: NEG
44520: PUSH
44521: LD_INT 2
44523: NEG
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: PUSH
44529: LD_INT 4
44531: NEG
44532: PUSH
44533: LD_INT 3
44535: NEG
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 4
44543: NEG
44544: PUSH
44545: LD_INT 4
44547: NEG
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 2
44555: NEG
44556: PUSH
44557: LD_INT 4
44559: NEG
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 4
44567: NEG
44568: PUSH
44569: LD_INT 2
44571: NEG
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 0
44579: PUSH
44580: LD_INT 4
44582: NEG
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 0
44590: PUSH
44591: LD_INT 5
44593: NEG
44594: PUSH
44595: EMPTY
44596: LIST
44597: LIST
44598: PUSH
44599: LD_INT 1
44601: PUSH
44602: LD_INT 4
44604: NEG
44605: PUSH
44606: EMPTY
44607: LIST
44608: LIST
44609: PUSH
44610: LD_INT 1
44612: PUSH
44613: LD_INT 3
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 0
44623: PUSH
44624: LD_INT 3
44626: NEG
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 1
44634: NEG
44635: PUSH
44636: LD_INT 4
44638: NEG
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 1
44646: NEG
44647: PUSH
44648: LD_INT 5
44650: NEG
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 2
44658: PUSH
44659: LD_INT 3
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 2
44669: NEG
44670: PUSH
44671: LD_INT 5
44673: NEG
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 3
44681: PUSH
44682: LD_INT 0
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: LD_INT 3
44691: PUSH
44692: LD_INT 1
44694: NEG
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 4
44702: PUSH
44703: LD_INT 0
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: LD_INT 4
44712: PUSH
44713: LD_INT 1
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 3
44722: PUSH
44723: LD_INT 1
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 2
44732: PUSH
44733: LD_INT 0
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 2
44742: PUSH
44743: LD_INT 1
44745: NEG
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 2
44753: PUSH
44754: LD_INT 2
44756: NEG
44757: PUSH
44758: EMPTY
44759: LIST
44760: LIST
44761: PUSH
44762: LD_INT 4
44764: PUSH
44765: LD_INT 2
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 4
44774: PUSH
44775: LD_INT 4
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PUSH
44782: LD_INT 4
44784: PUSH
44785: LD_INT 3
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 5
44794: PUSH
44795: LD_INT 4
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 5
44804: PUSH
44805: LD_INT 5
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 4
44814: PUSH
44815: LD_INT 5
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: PUSH
44822: LD_INT 3
44824: PUSH
44825: LD_INT 4
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 3
44834: PUSH
44835: LD_INT 3
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 5
44844: PUSH
44845: LD_INT 3
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 3
44854: PUSH
44855: LD_INT 5
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: LIST
44866: LIST
44867: LIST
44868: LIST
44869: LIST
44870: LIST
44871: LIST
44872: LIST
44873: LIST
44874: LIST
44875: LIST
44876: LIST
44877: LIST
44878: LIST
44879: LIST
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: LIST
44886: LIST
44887: LIST
44888: LIST
44889: LIST
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44909: LD_ADDR_VAR 0 33
44913: PUSH
44914: LD_INT 4
44916: NEG
44917: PUSH
44918: LD_INT 4
44920: NEG
44921: PUSH
44922: EMPTY
44923: LIST
44924: LIST
44925: PUSH
44926: LD_INT 4
44928: NEG
44929: PUSH
44930: LD_INT 5
44932: NEG
44933: PUSH
44934: EMPTY
44935: LIST
44936: LIST
44937: PUSH
44938: LD_INT 3
44940: NEG
44941: PUSH
44942: LD_INT 4
44944: NEG
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 3
44952: NEG
44953: PUSH
44954: LD_INT 3
44956: NEG
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 4
44964: NEG
44965: PUSH
44966: LD_INT 3
44968: NEG
44969: PUSH
44970: EMPTY
44971: LIST
44972: LIST
44973: PUSH
44974: LD_INT 5
44976: NEG
44977: PUSH
44978: LD_INT 4
44980: NEG
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 5
44988: NEG
44989: PUSH
44990: LD_INT 5
44992: NEG
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 3
45000: NEG
45001: PUSH
45002: LD_INT 5
45004: NEG
45005: PUSH
45006: EMPTY
45007: LIST
45008: LIST
45009: PUSH
45010: LD_INT 5
45012: NEG
45013: PUSH
45014: LD_INT 3
45016: NEG
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 0
45024: PUSH
45025: LD_INT 3
45027: NEG
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 0
45035: PUSH
45036: LD_INT 4
45038: NEG
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 1
45046: PUSH
45047: LD_INT 3
45049: NEG
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 1
45057: PUSH
45058: LD_INT 2
45060: NEG
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 0
45068: PUSH
45069: LD_INT 2
45071: NEG
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 1
45079: NEG
45080: PUSH
45081: LD_INT 3
45083: NEG
45084: PUSH
45085: EMPTY
45086: LIST
45087: LIST
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: LD_INT 4
45095: NEG
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: LD_INT 2
45103: PUSH
45104: LD_INT 2
45106: NEG
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 2
45114: NEG
45115: PUSH
45116: LD_INT 4
45118: NEG
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 4
45126: PUSH
45127: LD_INT 0
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 4
45136: PUSH
45137: LD_INT 1
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 5
45147: PUSH
45148: LD_INT 0
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: LD_INT 5
45157: PUSH
45158: LD_INT 1
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 4
45167: PUSH
45168: LD_INT 1
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 3
45177: PUSH
45178: LD_INT 0
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 3
45187: PUSH
45188: LD_INT 1
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 3
45198: PUSH
45199: LD_INT 2
45201: NEG
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 5
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: PUSH
45217: LD_INT 3
45219: PUSH
45220: LD_INT 3
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 3
45229: PUSH
45230: LD_INT 2
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 4
45239: PUSH
45240: LD_INT 3
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 4
45249: PUSH
45250: LD_INT 4
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 3
45259: PUSH
45260: LD_INT 4
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 2
45269: PUSH
45270: LD_INT 3
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 2
45279: PUSH
45280: LD_INT 2
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 4
45289: PUSH
45290: LD_INT 2
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 2
45299: PUSH
45300: LD_INT 4
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 0
45309: PUSH
45310: LD_INT 4
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 0
45319: PUSH
45320: LD_INT 3
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 1
45329: PUSH
45330: LD_INT 4
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 1
45339: PUSH
45340: LD_INT 5
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: LD_INT 5
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 1
45359: NEG
45360: PUSH
45361: LD_INT 4
45363: PUSH
45364: EMPTY
45365: LIST
45366: LIST
45367: PUSH
45368: LD_INT 1
45370: NEG
45371: PUSH
45372: LD_INT 3
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PUSH
45379: LD_INT 2
45381: PUSH
45382: LD_INT 5
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 2
45391: NEG
45392: PUSH
45393: LD_INT 3
45395: PUSH
45396: EMPTY
45397: LIST
45398: LIST
45399: PUSH
45400: EMPTY
45401: LIST
45402: LIST
45403: LIST
45404: LIST
45405: LIST
45406: LIST
45407: LIST
45408: LIST
45409: LIST
45410: LIST
45411: LIST
45412: LIST
45413: LIST
45414: LIST
45415: LIST
45416: LIST
45417: LIST
45418: LIST
45419: LIST
45420: LIST
45421: LIST
45422: LIST
45423: LIST
45424: LIST
45425: LIST
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: LIST
45439: LIST
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45447: LD_ADDR_VAR 0 34
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: LD_INT 4
45457: NEG
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 0
45465: PUSH
45466: LD_INT 5
45468: NEG
45469: PUSH
45470: EMPTY
45471: LIST
45472: LIST
45473: PUSH
45474: LD_INT 1
45476: PUSH
45477: LD_INT 4
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 1
45487: PUSH
45488: LD_INT 3
45490: NEG
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PUSH
45496: LD_INT 0
45498: PUSH
45499: LD_INT 3
45501: NEG
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: LD_INT 1
45509: NEG
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 1
45521: NEG
45522: PUSH
45523: LD_INT 5
45525: NEG
45526: PUSH
45527: EMPTY
45528: LIST
45529: LIST
45530: PUSH
45531: LD_INT 2
45533: PUSH
45534: LD_INT 3
45536: NEG
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 2
45544: NEG
45545: PUSH
45546: LD_INT 5
45548: NEG
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 3
45556: PUSH
45557: LD_INT 0
45559: PUSH
45560: EMPTY
45561: LIST
45562: LIST
45563: PUSH
45564: LD_INT 3
45566: PUSH
45567: LD_INT 1
45569: NEG
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: PUSH
45575: LD_INT 4
45577: PUSH
45578: LD_INT 0
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 4
45587: PUSH
45588: LD_INT 1
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: LD_INT 3
45597: PUSH
45598: LD_INT 1
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: PUSH
45605: LD_INT 2
45607: PUSH
45608: LD_INT 0
45610: PUSH
45611: EMPTY
45612: LIST
45613: LIST
45614: PUSH
45615: LD_INT 2
45617: PUSH
45618: LD_INT 1
45620: NEG
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 2
45628: PUSH
45629: LD_INT 2
45631: NEG
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 4
45639: PUSH
45640: LD_INT 2
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 4
45649: PUSH
45650: LD_INT 4
45652: PUSH
45653: EMPTY
45654: LIST
45655: LIST
45656: PUSH
45657: LD_INT 4
45659: PUSH
45660: LD_INT 3
45662: PUSH
45663: EMPTY
45664: LIST
45665: LIST
45666: PUSH
45667: LD_INT 5
45669: PUSH
45670: LD_INT 4
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: PUSH
45677: LD_INT 5
45679: PUSH
45680: LD_INT 5
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 4
45689: PUSH
45690: LD_INT 5
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 3
45699: PUSH
45700: LD_INT 4
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 3
45709: PUSH
45710: LD_INT 3
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 5
45719: PUSH
45720: LD_INT 3
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 3
45729: PUSH
45730: LD_INT 5
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 0
45739: PUSH
45740: LD_INT 3
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 0
45749: PUSH
45750: LD_INT 2
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 1
45759: PUSH
45760: LD_INT 3
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 1
45769: PUSH
45770: LD_INT 4
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 0
45779: PUSH
45780: LD_INT 4
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 1
45789: NEG
45790: PUSH
45791: LD_INT 3
45793: PUSH
45794: EMPTY
45795: LIST
45796: LIST
45797: PUSH
45798: LD_INT 1
45800: NEG
45801: PUSH
45802: LD_INT 2
45804: PUSH
45805: EMPTY
45806: LIST
45807: LIST
45808: PUSH
45809: LD_INT 2
45811: PUSH
45812: LD_INT 4
45814: PUSH
45815: EMPTY
45816: LIST
45817: LIST
45818: PUSH
45819: LD_INT 2
45821: NEG
45822: PUSH
45823: LD_INT 2
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: PUSH
45830: LD_INT 4
45832: NEG
45833: PUSH
45834: LD_INT 0
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 4
45843: NEG
45844: PUSH
45845: LD_INT 1
45847: NEG
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PUSH
45853: LD_INT 3
45855: NEG
45856: PUSH
45857: LD_INT 0
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 3
45866: NEG
45867: PUSH
45868: LD_INT 1
45870: PUSH
45871: EMPTY
45872: LIST
45873: LIST
45874: PUSH
45875: LD_INT 4
45877: NEG
45878: PUSH
45879: LD_INT 1
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: PUSH
45886: LD_INT 5
45888: NEG
45889: PUSH
45890: LD_INT 0
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: LD_INT 5
45899: NEG
45900: PUSH
45901: LD_INT 1
45903: NEG
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 5
45911: NEG
45912: PUSH
45913: LD_INT 2
45915: NEG
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 3
45923: NEG
45924: PUSH
45925: LD_INT 2
45927: PUSH
45928: EMPTY
45929: LIST
45930: LIST
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: LIST
45936: LIST
45937: LIST
45938: LIST
45939: LIST
45940: LIST
45941: LIST
45942: LIST
45943: LIST
45944: LIST
45945: LIST
45946: LIST
45947: LIST
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: LIST
45954: LIST
45955: LIST
45956: LIST
45957: LIST
45958: LIST
45959: LIST
45960: LIST
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: LIST
45968: LIST
45969: LIST
45970: LIST
45971: LIST
45972: LIST
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: ST_TO_ADDR
// end ; end ;
45979: GO 45982
45981: POP
// case btype of b_depot , b_warehouse :
45982: LD_VAR 0 1
45986: PUSH
45987: LD_INT 0
45989: DOUBLE
45990: EQUAL
45991: IFTRUE 46001
45993: LD_INT 1
45995: DOUBLE
45996: EQUAL
45997: IFTRUE 46001
45999: GO 46202
46001: POP
// case nation of nation_american :
46002: LD_VAR 0 5
46006: PUSH
46007: LD_INT 1
46009: DOUBLE
46010: EQUAL
46011: IFTRUE 46015
46013: GO 46071
46015: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46016: LD_ADDR_VAR 0 9
46020: PUSH
46021: LD_VAR 0 11
46025: PUSH
46026: LD_VAR 0 12
46030: PUSH
46031: LD_VAR 0 13
46035: PUSH
46036: LD_VAR 0 14
46040: PUSH
46041: LD_VAR 0 15
46045: PUSH
46046: LD_VAR 0 16
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: PUSH
46059: LD_VAR 0 4
46063: PUSH
46064: LD_INT 1
46066: PLUS
46067: ARRAY
46068: ST_TO_ADDR
46069: GO 46200
46071: LD_INT 2
46073: DOUBLE
46074: EQUAL
46075: IFTRUE 46079
46077: GO 46135
46079: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46080: LD_ADDR_VAR 0 9
46084: PUSH
46085: LD_VAR 0 17
46089: PUSH
46090: LD_VAR 0 18
46094: PUSH
46095: LD_VAR 0 19
46099: PUSH
46100: LD_VAR 0 20
46104: PUSH
46105: LD_VAR 0 21
46109: PUSH
46110: LD_VAR 0 22
46114: PUSH
46115: EMPTY
46116: LIST
46117: LIST
46118: LIST
46119: LIST
46120: LIST
46121: LIST
46122: PUSH
46123: LD_VAR 0 4
46127: PUSH
46128: LD_INT 1
46130: PLUS
46131: ARRAY
46132: ST_TO_ADDR
46133: GO 46200
46135: LD_INT 3
46137: DOUBLE
46138: EQUAL
46139: IFTRUE 46143
46141: GO 46199
46143: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46144: LD_ADDR_VAR 0 9
46148: PUSH
46149: LD_VAR 0 23
46153: PUSH
46154: LD_VAR 0 24
46158: PUSH
46159: LD_VAR 0 25
46163: PUSH
46164: LD_VAR 0 26
46168: PUSH
46169: LD_VAR 0 27
46173: PUSH
46174: LD_VAR 0 28
46178: PUSH
46179: EMPTY
46180: LIST
46181: LIST
46182: LIST
46183: LIST
46184: LIST
46185: LIST
46186: PUSH
46187: LD_VAR 0 4
46191: PUSH
46192: LD_INT 1
46194: PLUS
46195: ARRAY
46196: ST_TO_ADDR
46197: GO 46200
46199: POP
46200: GO 46749
46202: LD_INT 2
46204: DOUBLE
46205: EQUAL
46206: IFTRUE 46216
46208: LD_INT 3
46210: DOUBLE
46211: EQUAL
46212: IFTRUE 46216
46214: GO 46272
46216: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46217: LD_ADDR_VAR 0 9
46221: PUSH
46222: LD_VAR 0 29
46226: PUSH
46227: LD_VAR 0 30
46231: PUSH
46232: LD_VAR 0 31
46236: PUSH
46237: LD_VAR 0 32
46241: PUSH
46242: LD_VAR 0 33
46246: PUSH
46247: LD_VAR 0 34
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: PUSH
46260: LD_VAR 0 4
46264: PUSH
46265: LD_INT 1
46267: PLUS
46268: ARRAY
46269: ST_TO_ADDR
46270: GO 46749
46272: LD_INT 16
46274: DOUBLE
46275: EQUAL
46276: IFTRUE 46328
46278: LD_INT 17
46280: DOUBLE
46281: EQUAL
46282: IFTRUE 46328
46284: LD_INT 18
46286: DOUBLE
46287: EQUAL
46288: IFTRUE 46328
46290: LD_INT 19
46292: DOUBLE
46293: EQUAL
46294: IFTRUE 46328
46296: LD_INT 20
46298: DOUBLE
46299: EQUAL
46300: IFTRUE 46328
46302: LD_INT 21
46304: DOUBLE
46305: EQUAL
46306: IFTRUE 46328
46308: LD_INT 23
46310: DOUBLE
46311: EQUAL
46312: IFTRUE 46328
46314: LD_INT 24
46316: DOUBLE
46317: EQUAL
46318: IFTRUE 46328
46320: LD_INT 25
46322: DOUBLE
46323: EQUAL
46324: IFTRUE 46328
46326: GO 46384
46328: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46329: LD_ADDR_VAR 0 9
46333: PUSH
46334: LD_VAR 0 35
46338: PUSH
46339: LD_VAR 0 36
46343: PUSH
46344: LD_VAR 0 37
46348: PUSH
46349: LD_VAR 0 38
46353: PUSH
46354: LD_VAR 0 39
46358: PUSH
46359: LD_VAR 0 40
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: PUSH
46372: LD_VAR 0 4
46376: PUSH
46377: LD_INT 1
46379: PLUS
46380: ARRAY
46381: ST_TO_ADDR
46382: GO 46749
46384: LD_INT 6
46386: DOUBLE
46387: EQUAL
46388: IFTRUE 46440
46390: LD_INT 7
46392: DOUBLE
46393: EQUAL
46394: IFTRUE 46440
46396: LD_INT 8
46398: DOUBLE
46399: EQUAL
46400: IFTRUE 46440
46402: LD_INT 13
46404: DOUBLE
46405: EQUAL
46406: IFTRUE 46440
46408: LD_INT 12
46410: DOUBLE
46411: EQUAL
46412: IFTRUE 46440
46414: LD_INT 15
46416: DOUBLE
46417: EQUAL
46418: IFTRUE 46440
46420: LD_INT 11
46422: DOUBLE
46423: EQUAL
46424: IFTRUE 46440
46426: LD_INT 14
46428: DOUBLE
46429: EQUAL
46430: IFTRUE 46440
46432: LD_INT 10
46434: DOUBLE
46435: EQUAL
46436: IFTRUE 46440
46438: GO 46496
46440: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46441: LD_ADDR_VAR 0 9
46445: PUSH
46446: LD_VAR 0 41
46450: PUSH
46451: LD_VAR 0 42
46455: PUSH
46456: LD_VAR 0 43
46460: PUSH
46461: LD_VAR 0 44
46465: PUSH
46466: LD_VAR 0 45
46470: PUSH
46471: LD_VAR 0 46
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: LIST
46480: LIST
46481: LIST
46482: LIST
46483: PUSH
46484: LD_VAR 0 4
46488: PUSH
46489: LD_INT 1
46491: PLUS
46492: ARRAY
46493: ST_TO_ADDR
46494: GO 46749
46496: LD_INT 36
46498: DOUBLE
46499: EQUAL
46500: IFTRUE 46504
46502: GO 46560
46504: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46505: LD_ADDR_VAR 0 9
46509: PUSH
46510: LD_VAR 0 47
46514: PUSH
46515: LD_VAR 0 48
46519: PUSH
46520: LD_VAR 0 49
46524: PUSH
46525: LD_VAR 0 50
46529: PUSH
46530: LD_VAR 0 51
46534: PUSH
46535: LD_VAR 0 52
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: PUSH
46548: LD_VAR 0 4
46552: PUSH
46553: LD_INT 1
46555: PLUS
46556: ARRAY
46557: ST_TO_ADDR
46558: GO 46749
46560: LD_INT 4
46562: DOUBLE
46563: EQUAL
46564: IFTRUE 46586
46566: LD_INT 5
46568: DOUBLE
46569: EQUAL
46570: IFTRUE 46586
46572: LD_INT 34
46574: DOUBLE
46575: EQUAL
46576: IFTRUE 46586
46578: LD_INT 37
46580: DOUBLE
46581: EQUAL
46582: IFTRUE 46586
46584: GO 46642
46586: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46587: LD_ADDR_VAR 0 9
46591: PUSH
46592: LD_VAR 0 53
46596: PUSH
46597: LD_VAR 0 54
46601: PUSH
46602: LD_VAR 0 55
46606: PUSH
46607: LD_VAR 0 56
46611: PUSH
46612: LD_VAR 0 57
46616: PUSH
46617: LD_VAR 0 58
46621: PUSH
46622: EMPTY
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: PUSH
46630: LD_VAR 0 4
46634: PUSH
46635: LD_INT 1
46637: PLUS
46638: ARRAY
46639: ST_TO_ADDR
46640: GO 46749
46642: LD_INT 31
46644: DOUBLE
46645: EQUAL
46646: IFTRUE 46692
46648: LD_INT 32
46650: DOUBLE
46651: EQUAL
46652: IFTRUE 46692
46654: LD_INT 33
46656: DOUBLE
46657: EQUAL
46658: IFTRUE 46692
46660: LD_INT 27
46662: DOUBLE
46663: EQUAL
46664: IFTRUE 46692
46666: LD_INT 26
46668: DOUBLE
46669: EQUAL
46670: IFTRUE 46692
46672: LD_INT 28
46674: DOUBLE
46675: EQUAL
46676: IFTRUE 46692
46678: LD_INT 29
46680: DOUBLE
46681: EQUAL
46682: IFTRUE 46692
46684: LD_INT 30
46686: DOUBLE
46687: EQUAL
46688: IFTRUE 46692
46690: GO 46748
46692: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
46693: LD_ADDR_VAR 0 9
46697: PUSH
46698: LD_VAR 0 59
46702: PUSH
46703: LD_VAR 0 60
46707: PUSH
46708: LD_VAR 0 61
46712: PUSH
46713: LD_VAR 0 62
46717: PUSH
46718: LD_VAR 0 63
46722: PUSH
46723: LD_VAR 0 64
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: PUSH
46736: LD_VAR 0 4
46740: PUSH
46741: LD_INT 1
46743: PLUS
46744: ARRAY
46745: ST_TO_ADDR
46746: GO 46749
46748: POP
// temp_list2 = [ ] ;
46749: LD_ADDR_VAR 0 10
46753: PUSH
46754: EMPTY
46755: ST_TO_ADDR
// for i in temp_list do
46756: LD_ADDR_VAR 0 8
46760: PUSH
46761: LD_VAR 0 9
46765: PUSH
46766: FOR_IN
46767: IFFALSE 46819
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46769: LD_ADDR_VAR 0 10
46773: PUSH
46774: LD_VAR 0 10
46778: PUSH
46779: LD_VAR 0 8
46783: PUSH
46784: LD_INT 1
46786: ARRAY
46787: PUSH
46788: LD_VAR 0 2
46792: PLUS
46793: PUSH
46794: LD_VAR 0 8
46798: PUSH
46799: LD_INT 2
46801: ARRAY
46802: PUSH
46803: LD_VAR 0 3
46807: PLUS
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: PUSH
46813: EMPTY
46814: LIST
46815: ADD
46816: ST_TO_ADDR
46817: GO 46766
46819: POP
46820: POP
// result = temp_list2 ;
46821: LD_ADDR_VAR 0 7
46825: PUSH
46826: LD_VAR 0 10
46830: ST_TO_ADDR
// end ;
46831: LD_VAR 0 7
46835: RET
// export function EnemyInRange ( unit , dist ) ; begin
46836: LD_INT 0
46838: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46839: LD_ADDR_VAR 0 3
46843: PUSH
46844: LD_VAR 0 1
46848: PPUSH
46849: CALL_OW 255
46853: PPUSH
46854: LD_VAR 0 1
46858: PPUSH
46859: CALL_OW 250
46863: PPUSH
46864: LD_VAR 0 1
46868: PPUSH
46869: CALL_OW 251
46873: PPUSH
46874: LD_VAR 0 2
46878: PPUSH
46879: CALL 21179 0 4
46883: PUSH
46884: LD_INT 4
46886: ARRAY
46887: ST_TO_ADDR
// end ;
46888: LD_VAR 0 3
46892: RET
// export function PlayerSeeMe ( unit ) ; begin
46893: LD_INT 0
46895: PPUSH
// result := See ( your_side , unit ) ;
46896: LD_ADDR_VAR 0 2
46900: PUSH
46901: LD_OWVAR 2
46905: PPUSH
46906: LD_VAR 0 1
46910: PPUSH
46911: CALL_OW 292
46915: ST_TO_ADDR
// end ;
46916: LD_VAR 0 2
46920: RET
// export function ReverseDir ( unit ) ; begin
46921: LD_INT 0
46923: PPUSH
// if not unit then
46924: LD_VAR 0 1
46928: NOT
46929: IFFALSE 46933
// exit ;
46931: GO 46979
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
46933: LD_ADDR_VAR 0 2
46937: PUSH
46938: LD_INT 3
46940: PUSH
46941: LD_INT 4
46943: PUSH
46944: LD_INT 5
46946: PUSH
46947: LD_INT 0
46949: PUSH
46950: LD_INT 1
46952: PUSH
46953: LD_INT 2
46955: PUSH
46956: EMPTY
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: PUSH
46964: LD_VAR 0 1
46968: PPUSH
46969: CALL_OW 254
46973: PUSH
46974: LD_INT 1
46976: PLUS
46977: ARRAY
46978: ST_TO_ADDR
// end ;
46979: LD_VAR 0 2
46983: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46984: LD_INT 0
46986: PPUSH
46987: PPUSH
46988: PPUSH
46989: PPUSH
46990: PPUSH
// if not hexes then
46991: LD_VAR 0 2
46995: NOT
46996: IFFALSE 47000
// exit ;
46998: GO 47148
// dist := 9999 ;
47000: LD_ADDR_VAR 0 5
47004: PUSH
47005: LD_INT 9999
47007: ST_TO_ADDR
// for i = 1 to hexes do
47008: LD_ADDR_VAR 0 4
47012: PUSH
47013: DOUBLE
47014: LD_INT 1
47016: DEC
47017: ST_TO_ADDR
47018: LD_VAR 0 2
47022: PUSH
47023: FOR_TO
47024: IFFALSE 47136
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47026: LD_VAR 0 1
47030: PPUSH
47031: LD_VAR 0 2
47035: PUSH
47036: LD_VAR 0 4
47040: ARRAY
47041: PUSH
47042: LD_INT 1
47044: ARRAY
47045: PPUSH
47046: LD_VAR 0 2
47050: PUSH
47051: LD_VAR 0 4
47055: ARRAY
47056: PUSH
47057: LD_INT 2
47059: ARRAY
47060: PPUSH
47061: CALL_OW 297
47065: PUSH
47066: LD_VAR 0 5
47070: LESS
47071: IFFALSE 47134
// begin hex := hexes [ i ] ;
47073: LD_ADDR_VAR 0 7
47077: PUSH
47078: LD_VAR 0 2
47082: PUSH
47083: LD_VAR 0 4
47087: ARRAY
47088: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47089: LD_ADDR_VAR 0 5
47093: PUSH
47094: LD_VAR 0 1
47098: PPUSH
47099: LD_VAR 0 2
47103: PUSH
47104: LD_VAR 0 4
47108: ARRAY
47109: PUSH
47110: LD_INT 1
47112: ARRAY
47113: PPUSH
47114: LD_VAR 0 2
47118: PUSH
47119: LD_VAR 0 4
47123: ARRAY
47124: PUSH
47125: LD_INT 2
47127: ARRAY
47128: PPUSH
47129: CALL_OW 297
47133: ST_TO_ADDR
// end ; end ;
47134: GO 47023
47136: POP
47137: POP
// result := hex ;
47138: LD_ADDR_VAR 0 3
47142: PUSH
47143: LD_VAR 0 7
47147: ST_TO_ADDR
// end ;
47148: LD_VAR 0 3
47152: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47153: LD_INT 0
47155: PPUSH
47156: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47157: LD_VAR 0 1
47161: NOT
47162: PUSH
47163: LD_VAR 0 1
47167: PUSH
47168: LD_INT 21
47170: PUSH
47171: LD_INT 2
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 23
47180: PUSH
47181: LD_INT 2
47183: PUSH
47184: EMPTY
47185: LIST
47186: LIST
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PPUSH
47192: CALL_OW 69
47196: IN
47197: NOT
47198: OR
47199: IFFALSE 47203
// exit ;
47201: GO 47250
// for i = 1 to 3 do
47203: LD_ADDR_VAR 0 3
47207: PUSH
47208: DOUBLE
47209: LD_INT 1
47211: DEC
47212: ST_TO_ADDR
47213: LD_INT 3
47215: PUSH
47216: FOR_TO
47217: IFFALSE 47248
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47219: LD_VAR 0 1
47223: PPUSH
47224: CALL_OW 250
47228: PPUSH
47229: LD_VAR 0 1
47233: PPUSH
47234: CALL_OW 251
47238: PPUSH
47239: LD_INT 1
47241: PPUSH
47242: CALL_OW 453
47246: GO 47216
47248: POP
47249: POP
// end ;
47250: LD_VAR 0 2
47254: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47255: LD_INT 0
47257: PPUSH
47258: PPUSH
47259: PPUSH
47260: PPUSH
47261: PPUSH
47262: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47263: LD_VAR 0 1
47267: NOT
47268: PUSH
47269: LD_VAR 0 2
47273: NOT
47274: OR
47275: PUSH
47276: LD_VAR 0 1
47280: PPUSH
47281: CALL_OW 314
47285: OR
47286: IFFALSE 47290
// exit ;
47288: GO 47731
// x := GetX ( enemy_unit ) ;
47290: LD_ADDR_VAR 0 7
47294: PUSH
47295: LD_VAR 0 2
47299: PPUSH
47300: CALL_OW 250
47304: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47305: LD_ADDR_VAR 0 8
47309: PUSH
47310: LD_VAR 0 2
47314: PPUSH
47315: CALL_OW 251
47319: ST_TO_ADDR
// if not x or not y then
47320: LD_VAR 0 7
47324: NOT
47325: PUSH
47326: LD_VAR 0 8
47330: NOT
47331: OR
47332: IFFALSE 47336
// exit ;
47334: GO 47731
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47336: LD_ADDR_VAR 0 6
47340: PUSH
47341: LD_VAR 0 7
47345: PPUSH
47346: LD_INT 0
47348: PPUSH
47349: LD_INT 4
47351: PPUSH
47352: CALL_OW 272
47356: PUSH
47357: LD_VAR 0 8
47361: PPUSH
47362: LD_INT 0
47364: PPUSH
47365: LD_INT 4
47367: PPUSH
47368: CALL_OW 273
47372: PUSH
47373: EMPTY
47374: LIST
47375: LIST
47376: PUSH
47377: LD_VAR 0 7
47381: PPUSH
47382: LD_INT 1
47384: PPUSH
47385: LD_INT 4
47387: PPUSH
47388: CALL_OW 272
47392: PUSH
47393: LD_VAR 0 8
47397: PPUSH
47398: LD_INT 1
47400: PPUSH
47401: LD_INT 4
47403: PPUSH
47404: CALL_OW 273
47408: PUSH
47409: EMPTY
47410: LIST
47411: LIST
47412: PUSH
47413: LD_VAR 0 7
47417: PPUSH
47418: LD_INT 2
47420: PPUSH
47421: LD_INT 4
47423: PPUSH
47424: CALL_OW 272
47428: PUSH
47429: LD_VAR 0 8
47433: PPUSH
47434: LD_INT 2
47436: PPUSH
47437: LD_INT 4
47439: PPUSH
47440: CALL_OW 273
47444: PUSH
47445: EMPTY
47446: LIST
47447: LIST
47448: PUSH
47449: LD_VAR 0 7
47453: PPUSH
47454: LD_INT 3
47456: PPUSH
47457: LD_INT 4
47459: PPUSH
47460: CALL_OW 272
47464: PUSH
47465: LD_VAR 0 8
47469: PPUSH
47470: LD_INT 3
47472: PPUSH
47473: LD_INT 4
47475: PPUSH
47476: CALL_OW 273
47480: PUSH
47481: EMPTY
47482: LIST
47483: LIST
47484: PUSH
47485: LD_VAR 0 7
47489: PPUSH
47490: LD_INT 4
47492: PPUSH
47493: LD_INT 4
47495: PPUSH
47496: CALL_OW 272
47500: PUSH
47501: LD_VAR 0 8
47505: PPUSH
47506: LD_INT 4
47508: PPUSH
47509: LD_INT 4
47511: PPUSH
47512: CALL_OW 273
47516: PUSH
47517: EMPTY
47518: LIST
47519: LIST
47520: PUSH
47521: LD_VAR 0 7
47525: PPUSH
47526: LD_INT 5
47528: PPUSH
47529: LD_INT 4
47531: PPUSH
47532: CALL_OW 272
47536: PUSH
47537: LD_VAR 0 8
47541: PPUSH
47542: LD_INT 5
47544: PPUSH
47545: LD_INT 4
47547: PPUSH
47548: CALL_OW 273
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: LIST
47561: LIST
47562: LIST
47563: LIST
47564: ST_TO_ADDR
// for i = tmp downto 1 do
47565: LD_ADDR_VAR 0 4
47569: PUSH
47570: DOUBLE
47571: LD_VAR 0 6
47575: INC
47576: ST_TO_ADDR
47577: LD_INT 1
47579: PUSH
47580: FOR_DOWNTO
47581: IFFALSE 47682
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47583: LD_VAR 0 6
47587: PUSH
47588: LD_VAR 0 4
47592: ARRAY
47593: PUSH
47594: LD_INT 1
47596: ARRAY
47597: PPUSH
47598: LD_VAR 0 6
47602: PUSH
47603: LD_VAR 0 4
47607: ARRAY
47608: PUSH
47609: LD_INT 2
47611: ARRAY
47612: PPUSH
47613: CALL_OW 488
47617: NOT
47618: PUSH
47619: LD_VAR 0 6
47623: PUSH
47624: LD_VAR 0 4
47628: ARRAY
47629: PUSH
47630: LD_INT 1
47632: ARRAY
47633: PPUSH
47634: LD_VAR 0 6
47638: PUSH
47639: LD_VAR 0 4
47643: ARRAY
47644: PUSH
47645: LD_INT 2
47647: ARRAY
47648: PPUSH
47649: CALL_OW 428
47653: PUSH
47654: LD_INT 0
47656: NONEQUAL
47657: OR
47658: IFFALSE 47680
// tmp := Delete ( tmp , i ) ;
47660: LD_ADDR_VAR 0 6
47664: PUSH
47665: LD_VAR 0 6
47669: PPUSH
47670: LD_VAR 0 4
47674: PPUSH
47675: CALL_OW 3
47679: ST_TO_ADDR
47680: GO 47580
47682: POP
47683: POP
// j := GetClosestHex ( unit , tmp ) ;
47684: LD_ADDR_VAR 0 5
47688: PUSH
47689: LD_VAR 0 1
47693: PPUSH
47694: LD_VAR 0 6
47698: PPUSH
47699: CALL 46984 0 2
47703: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47704: LD_VAR 0 1
47708: PPUSH
47709: LD_VAR 0 5
47713: PUSH
47714: LD_INT 1
47716: ARRAY
47717: PPUSH
47718: LD_VAR 0 5
47722: PUSH
47723: LD_INT 2
47725: ARRAY
47726: PPUSH
47727: CALL_OW 111
// end ;
47731: LD_VAR 0 3
47735: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47736: LD_INT 0
47738: PPUSH
47739: PPUSH
47740: PPUSH
// uc_side = 0 ;
47741: LD_ADDR_OWVAR 20
47745: PUSH
47746: LD_INT 0
47748: ST_TO_ADDR
// uc_nation = 0 ;
47749: LD_ADDR_OWVAR 21
47753: PUSH
47754: LD_INT 0
47756: ST_TO_ADDR
// InitHc ;
47757: CALL_OW 19
// InitVc ;
47761: CALL_OW 20
// if mastodonts then
47765: LD_VAR 0 6
47769: IFFALSE 47836
// for i = 1 to mastodonts do
47771: LD_ADDR_VAR 0 11
47775: PUSH
47776: DOUBLE
47777: LD_INT 1
47779: DEC
47780: ST_TO_ADDR
47781: LD_VAR 0 6
47785: PUSH
47786: FOR_TO
47787: IFFALSE 47834
// begin vc_chassis := 31 ;
47789: LD_ADDR_OWVAR 37
47793: PUSH
47794: LD_INT 31
47796: ST_TO_ADDR
// vc_control := control_rider ;
47797: LD_ADDR_OWVAR 38
47801: PUSH
47802: LD_INT 4
47804: ST_TO_ADDR
// animal := CreateVehicle ;
47805: LD_ADDR_VAR 0 12
47809: PUSH
47810: CALL_OW 45
47814: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47815: LD_VAR 0 12
47819: PPUSH
47820: LD_VAR 0 8
47824: PPUSH
47825: LD_INT 0
47827: PPUSH
47828: CALL 54542 0 3
// end ;
47832: GO 47786
47834: POP
47835: POP
// if horses then
47836: LD_VAR 0 5
47840: IFFALSE 47907
// for i = 1 to horses do
47842: LD_ADDR_VAR 0 11
47846: PUSH
47847: DOUBLE
47848: LD_INT 1
47850: DEC
47851: ST_TO_ADDR
47852: LD_VAR 0 5
47856: PUSH
47857: FOR_TO
47858: IFFALSE 47905
// begin hc_class := 21 ;
47860: LD_ADDR_OWVAR 28
47864: PUSH
47865: LD_INT 21
47867: ST_TO_ADDR
// hc_gallery :=  ;
47868: LD_ADDR_OWVAR 33
47872: PUSH
47873: LD_STRING 
47875: ST_TO_ADDR
// animal := CreateHuman ;
47876: LD_ADDR_VAR 0 12
47880: PUSH
47881: CALL_OW 44
47885: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47886: LD_VAR 0 12
47890: PPUSH
47891: LD_VAR 0 8
47895: PPUSH
47896: LD_INT 0
47898: PPUSH
47899: CALL 54542 0 3
// end ;
47903: GO 47857
47905: POP
47906: POP
// if birds then
47907: LD_VAR 0 1
47911: IFFALSE 47978
// for i = 1 to birds do
47913: LD_ADDR_VAR 0 11
47917: PUSH
47918: DOUBLE
47919: LD_INT 1
47921: DEC
47922: ST_TO_ADDR
47923: LD_VAR 0 1
47927: PUSH
47928: FOR_TO
47929: IFFALSE 47976
// begin hc_class = 18 ;
47931: LD_ADDR_OWVAR 28
47935: PUSH
47936: LD_INT 18
47938: ST_TO_ADDR
// hc_gallery =  ;
47939: LD_ADDR_OWVAR 33
47943: PUSH
47944: LD_STRING 
47946: ST_TO_ADDR
// animal := CreateHuman ;
47947: LD_ADDR_VAR 0 12
47951: PUSH
47952: CALL_OW 44
47956: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47957: LD_VAR 0 12
47961: PPUSH
47962: LD_VAR 0 8
47966: PPUSH
47967: LD_INT 0
47969: PPUSH
47970: CALL 54542 0 3
// end ;
47974: GO 47928
47976: POP
47977: POP
// if tigers then
47978: LD_VAR 0 2
47982: IFFALSE 48066
// for i = 1 to tigers do
47984: LD_ADDR_VAR 0 11
47988: PUSH
47989: DOUBLE
47990: LD_INT 1
47992: DEC
47993: ST_TO_ADDR
47994: LD_VAR 0 2
47998: PUSH
47999: FOR_TO
48000: IFFALSE 48064
// begin hc_class = class_tiger ;
48002: LD_ADDR_OWVAR 28
48006: PUSH
48007: LD_INT 14
48009: ST_TO_ADDR
// hc_gallery =  ;
48010: LD_ADDR_OWVAR 33
48014: PUSH
48015: LD_STRING 
48017: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48018: LD_ADDR_OWVAR 35
48022: PUSH
48023: LD_INT 7
48025: NEG
48026: PPUSH
48027: LD_INT 7
48029: PPUSH
48030: CALL_OW 12
48034: ST_TO_ADDR
// animal := CreateHuman ;
48035: LD_ADDR_VAR 0 12
48039: PUSH
48040: CALL_OW 44
48044: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48045: LD_VAR 0 12
48049: PPUSH
48050: LD_VAR 0 8
48054: PPUSH
48055: LD_INT 0
48057: PPUSH
48058: CALL 54542 0 3
// end ;
48062: GO 47999
48064: POP
48065: POP
// if apemans then
48066: LD_VAR 0 3
48070: IFFALSE 48193
// for i = 1 to apemans do
48072: LD_ADDR_VAR 0 11
48076: PUSH
48077: DOUBLE
48078: LD_INT 1
48080: DEC
48081: ST_TO_ADDR
48082: LD_VAR 0 3
48086: PUSH
48087: FOR_TO
48088: IFFALSE 48191
// begin hc_class = class_apeman ;
48090: LD_ADDR_OWVAR 28
48094: PUSH
48095: LD_INT 12
48097: ST_TO_ADDR
// hc_gallery =  ;
48098: LD_ADDR_OWVAR 33
48102: PUSH
48103: LD_STRING 
48105: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48106: LD_ADDR_OWVAR 35
48110: PUSH
48111: LD_INT 5
48113: NEG
48114: PPUSH
48115: LD_INT 5
48117: PPUSH
48118: CALL_OW 12
48122: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48123: LD_ADDR_OWVAR 31
48127: PUSH
48128: LD_INT 1
48130: PPUSH
48131: LD_INT 3
48133: PPUSH
48134: CALL_OW 12
48138: PUSH
48139: LD_INT 1
48141: PPUSH
48142: LD_INT 3
48144: PPUSH
48145: CALL_OW 12
48149: PUSH
48150: LD_INT 0
48152: PUSH
48153: LD_INT 0
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: ST_TO_ADDR
// animal := CreateHuman ;
48162: LD_ADDR_VAR 0 12
48166: PUSH
48167: CALL_OW 44
48171: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48172: LD_VAR 0 12
48176: PPUSH
48177: LD_VAR 0 8
48181: PPUSH
48182: LD_INT 0
48184: PPUSH
48185: CALL 54542 0 3
// end ;
48189: GO 48087
48191: POP
48192: POP
// if enchidnas then
48193: LD_VAR 0 4
48197: IFFALSE 48264
// for i = 1 to enchidnas do
48199: LD_ADDR_VAR 0 11
48203: PUSH
48204: DOUBLE
48205: LD_INT 1
48207: DEC
48208: ST_TO_ADDR
48209: LD_VAR 0 4
48213: PUSH
48214: FOR_TO
48215: IFFALSE 48262
// begin hc_class = 13 ;
48217: LD_ADDR_OWVAR 28
48221: PUSH
48222: LD_INT 13
48224: ST_TO_ADDR
// hc_gallery =  ;
48225: LD_ADDR_OWVAR 33
48229: PUSH
48230: LD_STRING 
48232: ST_TO_ADDR
// animal := CreateHuman ;
48233: LD_ADDR_VAR 0 12
48237: PUSH
48238: CALL_OW 44
48242: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48243: LD_VAR 0 12
48247: PPUSH
48248: LD_VAR 0 8
48252: PPUSH
48253: LD_INT 0
48255: PPUSH
48256: CALL 54542 0 3
// end ;
48260: GO 48214
48262: POP
48263: POP
// if fishes then
48264: LD_VAR 0 7
48268: IFFALSE 48335
// for i = 1 to fishes do
48270: LD_ADDR_VAR 0 11
48274: PUSH
48275: DOUBLE
48276: LD_INT 1
48278: DEC
48279: ST_TO_ADDR
48280: LD_VAR 0 7
48284: PUSH
48285: FOR_TO
48286: IFFALSE 48333
// begin hc_class = 20 ;
48288: LD_ADDR_OWVAR 28
48292: PUSH
48293: LD_INT 20
48295: ST_TO_ADDR
// hc_gallery =  ;
48296: LD_ADDR_OWVAR 33
48300: PUSH
48301: LD_STRING 
48303: ST_TO_ADDR
// animal := CreateHuman ;
48304: LD_ADDR_VAR 0 12
48308: PUSH
48309: CALL_OW 44
48313: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48314: LD_VAR 0 12
48318: PPUSH
48319: LD_VAR 0 9
48323: PPUSH
48324: LD_INT 0
48326: PPUSH
48327: CALL 54542 0 3
// end ;
48331: GO 48285
48333: POP
48334: POP
// end ;
48335: LD_VAR 0 10
48339: RET
// export function WantHeal ( sci , unit ) ; begin
48340: LD_INT 0
48342: PPUSH
// if GetTaskList ( sci ) > 0 then
48343: LD_VAR 0 1
48347: PPUSH
48348: CALL_OW 437
48352: PUSH
48353: LD_INT 0
48355: GREATER
48356: IFFALSE 48426
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48358: LD_VAR 0 1
48362: PPUSH
48363: CALL_OW 437
48367: PUSH
48368: LD_INT 1
48370: ARRAY
48371: PUSH
48372: LD_INT 1
48374: ARRAY
48375: PUSH
48376: LD_STRING l
48378: EQUAL
48379: PUSH
48380: LD_VAR 0 1
48384: PPUSH
48385: CALL_OW 437
48389: PUSH
48390: LD_INT 1
48392: ARRAY
48393: PUSH
48394: LD_INT 4
48396: ARRAY
48397: PUSH
48398: LD_VAR 0 2
48402: EQUAL
48403: AND
48404: IFFALSE 48416
// result := true else
48406: LD_ADDR_VAR 0 3
48410: PUSH
48411: LD_INT 1
48413: ST_TO_ADDR
48414: GO 48424
// result := false ;
48416: LD_ADDR_VAR 0 3
48420: PUSH
48421: LD_INT 0
48423: ST_TO_ADDR
// end else
48424: GO 48434
// result := false ;
48426: LD_ADDR_VAR 0 3
48430: PUSH
48431: LD_INT 0
48433: ST_TO_ADDR
// end ;
48434: LD_VAR 0 3
48438: RET
// export function HealTarget ( sci ) ; begin
48439: LD_INT 0
48441: PPUSH
// if not sci then
48442: LD_VAR 0 1
48446: NOT
48447: IFFALSE 48451
// exit ;
48449: GO 48516
// result := 0 ;
48451: LD_ADDR_VAR 0 2
48455: PUSH
48456: LD_INT 0
48458: ST_TO_ADDR
// if GetTaskList ( sci ) then
48459: LD_VAR 0 1
48463: PPUSH
48464: CALL_OW 437
48468: IFFALSE 48516
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48470: LD_VAR 0 1
48474: PPUSH
48475: CALL_OW 437
48479: PUSH
48480: LD_INT 1
48482: ARRAY
48483: PUSH
48484: LD_INT 1
48486: ARRAY
48487: PUSH
48488: LD_STRING l
48490: EQUAL
48491: IFFALSE 48516
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48493: LD_ADDR_VAR 0 2
48497: PUSH
48498: LD_VAR 0 1
48502: PPUSH
48503: CALL_OW 437
48507: PUSH
48508: LD_INT 1
48510: ARRAY
48511: PUSH
48512: LD_INT 4
48514: ARRAY
48515: ST_TO_ADDR
// end ;
48516: LD_VAR 0 2
48520: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
48521: LD_INT 0
48523: PPUSH
48524: PPUSH
48525: PPUSH
48526: PPUSH
48527: PPUSH
48528: PPUSH
48529: PPUSH
48530: PPUSH
48531: PPUSH
48532: PPUSH
48533: PPUSH
48534: PPUSH
48535: PPUSH
48536: PPUSH
48537: PPUSH
48538: PPUSH
48539: PPUSH
48540: PPUSH
48541: PPUSH
48542: PPUSH
48543: PPUSH
48544: PPUSH
48545: PPUSH
48546: PPUSH
48547: PPUSH
48548: PPUSH
48549: PPUSH
48550: PPUSH
48551: PPUSH
48552: PPUSH
48553: PPUSH
48554: PPUSH
48555: PPUSH
// if not list then
48556: LD_VAR 0 1
48560: NOT
48561: IFFALSE 48565
// exit ;
48563: GO 53153
// base := list [ 1 ] ;
48565: LD_ADDR_VAR 0 3
48569: PUSH
48570: LD_VAR 0 1
48574: PUSH
48575: LD_INT 1
48577: ARRAY
48578: ST_TO_ADDR
// group := list [ 2 ] ;
48579: LD_ADDR_VAR 0 4
48583: PUSH
48584: LD_VAR 0 1
48588: PUSH
48589: LD_INT 2
48591: ARRAY
48592: ST_TO_ADDR
// path := list [ 3 ] ;
48593: LD_ADDR_VAR 0 5
48597: PUSH
48598: LD_VAR 0 1
48602: PUSH
48603: LD_INT 3
48605: ARRAY
48606: ST_TO_ADDR
// flags := list [ 4 ] ;
48607: LD_ADDR_VAR 0 6
48611: PUSH
48612: LD_VAR 0 1
48616: PUSH
48617: LD_INT 4
48619: ARRAY
48620: ST_TO_ADDR
// mined := [ ] ;
48621: LD_ADDR_VAR 0 27
48625: PUSH
48626: EMPTY
48627: ST_TO_ADDR
// bombed := [ ] ;
48628: LD_ADDR_VAR 0 28
48632: PUSH
48633: EMPTY
48634: ST_TO_ADDR
// healers := [ ] ;
48635: LD_ADDR_VAR 0 31
48639: PUSH
48640: EMPTY
48641: ST_TO_ADDR
// to_heal := [ ] ;
48642: LD_ADDR_VAR 0 30
48646: PUSH
48647: EMPTY
48648: ST_TO_ADDR
// repairs := [ ] ;
48649: LD_ADDR_VAR 0 33
48653: PUSH
48654: EMPTY
48655: ST_TO_ADDR
// to_repair := [ ] ;
48656: LD_ADDR_VAR 0 32
48660: PUSH
48661: EMPTY
48662: ST_TO_ADDR
// if not group or not path then
48663: LD_VAR 0 4
48667: NOT
48668: PUSH
48669: LD_VAR 0 5
48673: NOT
48674: OR
48675: IFFALSE 48679
// exit ;
48677: GO 53153
// if flags then
48679: LD_VAR 0 6
48683: IFFALSE 48827
// begin f_ignore_area := flags [ 1 ] ;
48685: LD_ADDR_VAR 0 17
48689: PUSH
48690: LD_VAR 0 6
48694: PUSH
48695: LD_INT 1
48697: ARRAY
48698: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
48699: LD_ADDR_VAR 0 18
48703: PUSH
48704: LD_VAR 0 6
48708: PUSH
48709: LD_INT 2
48711: ARRAY
48712: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
48713: LD_ADDR_VAR 0 19
48717: PUSH
48718: LD_VAR 0 6
48722: PUSH
48723: LD_INT 3
48725: ARRAY
48726: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
48727: LD_ADDR_VAR 0 20
48731: PUSH
48732: LD_VAR 0 6
48736: PUSH
48737: LD_INT 4
48739: ARRAY
48740: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
48741: LD_ADDR_VAR 0 21
48745: PUSH
48746: LD_VAR 0 6
48750: PUSH
48751: LD_INT 5
48753: ARRAY
48754: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
48755: LD_ADDR_VAR 0 22
48759: PUSH
48760: LD_VAR 0 6
48764: PUSH
48765: LD_INT 6
48767: ARRAY
48768: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
48769: LD_ADDR_VAR 0 23
48773: PUSH
48774: LD_VAR 0 6
48778: PUSH
48779: LD_INT 7
48781: ARRAY
48782: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
48783: LD_ADDR_VAR 0 24
48787: PUSH
48788: LD_VAR 0 6
48792: PUSH
48793: LD_INT 8
48795: ARRAY
48796: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
48797: LD_ADDR_VAR 0 25
48801: PUSH
48802: LD_VAR 0 6
48806: PUSH
48807: LD_INT 9
48809: ARRAY
48810: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
48811: LD_ADDR_VAR 0 26
48815: PUSH
48816: LD_VAR 0 6
48820: PUSH
48821: LD_INT 10
48823: ARRAY
48824: ST_TO_ADDR
// end else
48825: GO 48907
// begin f_ignore_area := false ;
48827: LD_ADDR_VAR 0 17
48831: PUSH
48832: LD_INT 0
48834: ST_TO_ADDR
// f_capture := false ;
48835: LD_ADDR_VAR 0 18
48839: PUSH
48840: LD_INT 0
48842: ST_TO_ADDR
// f_ignore_civ := false ;
48843: LD_ADDR_VAR 0 19
48847: PUSH
48848: LD_INT 0
48850: ST_TO_ADDR
// f_murder := false ;
48851: LD_ADDR_VAR 0 20
48855: PUSH
48856: LD_INT 0
48858: ST_TO_ADDR
// f_mines := false ;
48859: LD_ADDR_VAR 0 21
48863: PUSH
48864: LD_INT 0
48866: ST_TO_ADDR
// f_repair := false ;
48867: LD_ADDR_VAR 0 22
48871: PUSH
48872: LD_INT 0
48874: ST_TO_ADDR
// f_heal := false ;
48875: LD_ADDR_VAR 0 23
48879: PUSH
48880: LD_INT 0
48882: ST_TO_ADDR
// f_spacetime := false ;
48883: LD_ADDR_VAR 0 24
48887: PUSH
48888: LD_INT 0
48890: ST_TO_ADDR
// f_attack_depot := false ;
48891: LD_ADDR_VAR 0 25
48895: PUSH
48896: LD_INT 0
48898: ST_TO_ADDR
// f_crawl := false ;
48899: LD_ADDR_VAR 0 26
48903: PUSH
48904: LD_INT 0
48906: ST_TO_ADDR
// end ; if f_heal then
48907: LD_VAR 0 23
48911: IFFALSE 48938
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
48913: LD_ADDR_VAR 0 31
48917: PUSH
48918: LD_VAR 0 4
48922: PPUSH
48923: LD_INT 25
48925: PUSH
48926: LD_INT 4
48928: PUSH
48929: EMPTY
48930: LIST
48931: LIST
48932: PPUSH
48933: CALL_OW 72
48937: ST_TO_ADDR
// if f_repair then
48938: LD_VAR 0 22
48942: IFFALSE 48969
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
48944: LD_ADDR_VAR 0 33
48948: PUSH
48949: LD_VAR 0 4
48953: PPUSH
48954: LD_INT 25
48956: PUSH
48957: LD_INT 3
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PPUSH
48964: CALL_OW 72
48968: ST_TO_ADDR
// units_path := [ ] ;
48969: LD_ADDR_VAR 0 16
48973: PUSH
48974: EMPTY
48975: ST_TO_ADDR
// for i = 1 to group do
48976: LD_ADDR_VAR 0 7
48980: PUSH
48981: DOUBLE
48982: LD_INT 1
48984: DEC
48985: ST_TO_ADDR
48986: LD_VAR 0 4
48990: PUSH
48991: FOR_TO
48992: IFFALSE 49021
// units_path := Replace ( units_path , i , path ) ;
48994: LD_ADDR_VAR 0 16
48998: PUSH
48999: LD_VAR 0 16
49003: PPUSH
49004: LD_VAR 0 7
49008: PPUSH
49009: LD_VAR 0 5
49013: PPUSH
49014: CALL_OW 1
49018: ST_TO_ADDR
49019: GO 48991
49021: POP
49022: POP
// repeat for i = group downto 1 do
49023: LD_ADDR_VAR 0 7
49027: PUSH
49028: DOUBLE
49029: LD_VAR 0 4
49033: INC
49034: ST_TO_ADDR
49035: LD_INT 1
49037: PUSH
49038: FOR_DOWNTO
49039: IFFALSE 53135
// begin wait ( 5 ) ;
49041: LD_INT 5
49043: PPUSH
49044: CALL_OW 67
// tmp := [ ] ;
49048: LD_ADDR_VAR 0 14
49052: PUSH
49053: EMPTY
49054: ST_TO_ADDR
// attacking := false ;
49055: LD_ADDR_VAR 0 29
49059: PUSH
49060: LD_INT 0
49062: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49063: LD_VAR 0 4
49067: PUSH
49068: LD_VAR 0 7
49072: ARRAY
49073: PPUSH
49074: CALL_OW 301
49078: PUSH
49079: LD_VAR 0 4
49083: PUSH
49084: LD_VAR 0 7
49088: ARRAY
49089: NOT
49090: OR
49091: IFFALSE 49200
// begin if GetType ( group [ i ] ) = unit_human then
49093: LD_VAR 0 4
49097: PUSH
49098: LD_VAR 0 7
49102: ARRAY
49103: PPUSH
49104: CALL_OW 247
49108: PUSH
49109: LD_INT 1
49111: EQUAL
49112: IFFALSE 49158
// begin to_heal := to_heal diff group [ i ] ;
49114: LD_ADDR_VAR 0 30
49118: PUSH
49119: LD_VAR 0 30
49123: PUSH
49124: LD_VAR 0 4
49128: PUSH
49129: LD_VAR 0 7
49133: ARRAY
49134: DIFF
49135: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49136: LD_ADDR_VAR 0 31
49140: PUSH
49141: LD_VAR 0 31
49145: PUSH
49146: LD_VAR 0 4
49150: PUSH
49151: LD_VAR 0 7
49155: ARRAY
49156: DIFF
49157: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49158: LD_ADDR_VAR 0 4
49162: PUSH
49163: LD_VAR 0 4
49167: PPUSH
49168: LD_VAR 0 7
49172: PPUSH
49173: CALL_OW 3
49177: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49178: LD_ADDR_VAR 0 16
49182: PUSH
49183: LD_VAR 0 16
49187: PPUSH
49188: LD_VAR 0 7
49192: PPUSH
49193: CALL_OW 3
49197: ST_TO_ADDR
// continue ;
49198: GO 49038
// end ; if f_repair then
49200: LD_VAR 0 22
49204: IFFALSE 49693
// begin if GetType ( group [ i ] ) = unit_vehicle then
49206: LD_VAR 0 4
49210: PUSH
49211: LD_VAR 0 7
49215: ARRAY
49216: PPUSH
49217: CALL_OW 247
49221: PUSH
49222: LD_INT 2
49224: EQUAL
49225: IFFALSE 49415
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49227: LD_VAR 0 4
49231: PUSH
49232: LD_VAR 0 7
49236: ARRAY
49237: PPUSH
49238: CALL_OW 256
49242: PUSH
49243: LD_INT 700
49245: LESS
49246: PUSH
49247: LD_VAR 0 4
49251: PUSH
49252: LD_VAR 0 7
49256: ARRAY
49257: PUSH
49258: LD_VAR 0 32
49262: IN
49263: NOT
49264: AND
49265: IFFALSE 49289
// to_repair := to_repair union group [ i ] ;
49267: LD_ADDR_VAR 0 32
49271: PUSH
49272: LD_VAR 0 32
49276: PUSH
49277: LD_VAR 0 4
49281: PUSH
49282: LD_VAR 0 7
49286: ARRAY
49287: UNION
49288: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49289: LD_VAR 0 4
49293: PUSH
49294: LD_VAR 0 7
49298: ARRAY
49299: PPUSH
49300: CALL_OW 256
49304: PUSH
49305: LD_INT 1000
49307: EQUAL
49308: PUSH
49309: LD_VAR 0 4
49313: PUSH
49314: LD_VAR 0 7
49318: ARRAY
49319: PUSH
49320: LD_VAR 0 32
49324: IN
49325: AND
49326: IFFALSE 49350
// to_repair := to_repair diff group [ i ] ;
49328: LD_ADDR_VAR 0 32
49332: PUSH
49333: LD_VAR 0 32
49337: PUSH
49338: LD_VAR 0 4
49342: PUSH
49343: LD_VAR 0 7
49347: ARRAY
49348: DIFF
49349: ST_TO_ADDR
// if group [ i ] in to_repair then
49350: LD_VAR 0 4
49354: PUSH
49355: LD_VAR 0 7
49359: ARRAY
49360: PUSH
49361: LD_VAR 0 32
49365: IN
49366: IFFALSE 49413
// begin if not IsInArea ( group [ i ] , f_repair ) then
49368: LD_VAR 0 4
49372: PUSH
49373: LD_VAR 0 7
49377: ARRAY
49378: PPUSH
49379: LD_VAR 0 22
49383: PPUSH
49384: CALL_OW 308
49388: NOT
49389: IFFALSE 49411
// ComMoveToArea ( group [ i ] , f_repair ) ;
49391: LD_VAR 0 4
49395: PUSH
49396: LD_VAR 0 7
49400: ARRAY
49401: PPUSH
49402: LD_VAR 0 22
49406: PPUSH
49407: CALL_OW 113
// continue ;
49411: GO 49038
// end ; end else
49413: GO 49693
// if group [ i ] in repairs then
49415: LD_VAR 0 4
49419: PUSH
49420: LD_VAR 0 7
49424: ARRAY
49425: PUSH
49426: LD_VAR 0 33
49430: IN
49431: IFFALSE 49693
// begin if IsInUnit ( group [ i ] ) then
49433: LD_VAR 0 4
49437: PUSH
49438: LD_VAR 0 7
49442: ARRAY
49443: PPUSH
49444: CALL_OW 310
49448: IFFALSE 49516
// begin z := IsInUnit ( group [ i ] ) ;
49450: LD_ADDR_VAR 0 13
49454: PUSH
49455: LD_VAR 0 4
49459: PUSH
49460: LD_VAR 0 7
49464: ARRAY
49465: PPUSH
49466: CALL_OW 310
49470: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49471: LD_VAR 0 13
49475: PUSH
49476: LD_VAR 0 32
49480: IN
49481: PUSH
49482: LD_VAR 0 13
49486: PPUSH
49487: LD_VAR 0 22
49491: PPUSH
49492: CALL_OW 308
49496: AND
49497: IFFALSE 49514
// ComExitVehicle ( group [ i ] ) ;
49499: LD_VAR 0 4
49503: PUSH
49504: LD_VAR 0 7
49508: ARRAY
49509: PPUSH
49510: CALL_OW 121
// end else
49514: GO 49693
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
49516: LD_ADDR_VAR 0 13
49520: PUSH
49521: LD_VAR 0 4
49525: PPUSH
49526: LD_INT 95
49528: PUSH
49529: LD_VAR 0 22
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: PUSH
49538: LD_INT 58
49540: PUSH
49541: EMPTY
49542: LIST
49543: PUSH
49544: EMPTY
49545: LIST
49546: LIST
49547: PPUSH
49548: CALL_OW 72
49552: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
49553: LD_VAR 0 4
49557: PUSH
49558: LD_VAR 0 7
49562: ARRAY
49563: PPUSH
49564: CALL_OW 314
49568: NOT
49569: IFFALSE 49691
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
49571: LD_ADDR_VAR 0 10
49575: PUSH
49576: LD_VAR 0 13
49580: PPUSH
49581: LD_VAR 0 4
49585: PUSH
49586: LD_VAR 0 7
49590: ARRAY
49591: PPUSH
49592: CALL_OW 74
49596: ST_TO_ADDR
// if not x then
49597: LD_VAR 0 10
49601: NOT
49602: IFFALSE 49606
// continue ;
49604: GO 49038
// if GetLives ( x ) < 1000 then
49606: LD_VAR 0 10
49610: PPUSH
49611: CALL_OW 256
49615: PUSH
49616: LD_INT 1000
49618: LESS
49619: IFFALSE 49643
// ComRepairVehicle ( group [ i ] , x ) else
49621: LD_VAR 0 4
49625: PUSH
49626: LD_VAR 0 7
49630: ARRAY
49631: PPUSH
49632: LD_VAR 0 10
49636: PPUSH
49637: CALL_OW 129
49641: GO 49691
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
49643: LD_VAR 0 23
49647: PUSH
49648: LD_VAR 0 4
49652: PUSH
49653: LD_VAR 0 7
49657: ARRAY
49658: PPUSH
49659: CALL_OW 256
49663: PUSH
49664: LD_INT 1000
49666: LESS
49667: AND
49668: NOT
49669: IFFALSE 49691
// ComEnterUnit ( group [ i ] , x ) ;
49671: LD_VAR 0 4
49675: PUSH
49676: LD_VAR 0 7
49680: ARRAY
49681: PPUSH
49682: LD_VAR 0 10
49686: PPUSH
49687: CALL_OW 120
// end ; continue ;
49691: GO 49038
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
49693: LD_VAR 0 23
49697: PUSH
49698: LD_VAR 0 4
49702: PUSH
49703: LD_VAR 0 7
49707: ARRAY
49708: PPUSH
49709: CALL_OW 247
49713: PUSH
49714: LD_INT 1
49716: EQUAL
49717: AND
49718: IFFALSE 50196
// begin if group [ i ] in healers then
49720: LD_VAR 0 4
49724: PUSH
49725: LD_VAR 0 7
49729: ARRAY
49730: PUSH
49731: LD_VAR 0 31
49735: IN
49736: IFFALSE 50009
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
49738: LD_VAR 0 4
49742: PUSH
49743: LD_VAR 0 7
49747: ARRAY
49748: PPUSH
49749: LD_VAR 0 23
49753: PPUSH
49754: CALL_OW 308
49758: NOT
49759: PUSH
49760: LD_VAR 0 4
49764: PUSH
49765: LD_VAR 0 7
49769: ARRAY
49770: PPUSH
49771: CALL_OW 314
49775: NOT
49776: AND
49777: IFFALSE 49801
// ComMoveToArea ( group [ i ] , f_heal ) else
49779: LD_VAR 0 4
49783: PUSH
49784: LD_VAR 0 7
49788: ARRAY
49789: PPUSH
49790: LD_VAR 0 23
49794: PPUSH
49795: CALL_OW 113
49799: GO 50007
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
49801: LD_VAR 0 4
49805: PUSH
49806: LD_VAR 0 7
49810: ARRAY
49811: PPUSH
49812: CALL 48439 0 1
49816: PPUSH
49817: CALL_OW 256
49821: PUSH
49822: LD_INT 1000
49824: EQUAL
49825: IFFALSE 49844
// ComStop ( group [ i ] ) else
49827: LD_VAR 0 4
49831: PUSH
49832: LD_VAR 0 7
49836: ARRAY
49837: PPUSH
49838: CALL_OW 141
49842: GO 50007
// if not HasTask ( group [ i ] ) and to_heal then
49844: LD_VAR 0 4
49848: PUSH
49849: LD_VAR 0 7
49853: ARRAY
49854: PPUSH
49855: CALL_OW 314
49859: NOT
49860: PUSH
49861: LD_VAR 0 30
49865: AND
49866: IFFALSE 50007
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
49868: LD_ADDR_VAR 0 13
49872: PUSH
49873: LD_VAR 0 30
49877: PPUSH
49878: LD_INT 3
49880: PUSH
49881: LD_INT 54
49883: PUSH
49884: EMPTY
49885: LIST
49886: PUSH
49887: EMPTY
49888: LIST
49889: LIST
49890: PPUSH
49891: CALL_OW 72
49895: PPUSH
49896: LD_VAR 0 4
49900: PUSH
49901: LD_VAR 0 7
49905: ARRAY
49906: PPUSH
49907: CALL_OW 74
49911: ST_TO_ADDR
// if z then
49912: LD_VAR 0 13
49916: IFFALSE 50007
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
49918: LD_INT 91
49920: PUSH
49921: LD_VAR 0 13
49925: PUSH
49926: LD_INT 10
49928: PUSH
49929: EMPTY
49930: LIST
49931: LIST
49932: LIST
49933: PUSH
49934: LD_INT 81
49936: PUSH
49937: LD_VAR 0 13
49941: PPUSH
49942: CALL_OW 255
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: PUSH
49951: EMPTY
49952: LIST
49953: LIST
49954: PPUSH
49955: CALL_OW 69
49959: PUSH
49960: LD_INT 0
49962: EQUAL
49963: IFFALSE 49987
// ComHeal ( group [ i ] , z ) else
49965: LD_VAR 0 4
49969: PUSH
49970: LD_VAR 0 7
49974: ARRAY
49975: PPUSH
49976: LD_VAR 0 13
49980: PPUSH
49981: CALL_OW 128
49985: GO 50007
// ComMoveToArea ( group [ i ] , f_heal ) ;
49987: LD_VAR 0 4
49991: PUSH
49992: LD_VAR 0 7
49996: ARRAY
49997: PPUSH
49998: LD_VAR 0 23
50002: PPUSH
50003: CALL_OW 113
// end ; continue ;
50007: GO 49038
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50009: LD_VAR 0 4
50013: PUSH
50014: LD_VAR 0 7
50018: ARRAY
50019: PPUSH
50020: CALL_OW 256
50024: PUSH
50025: LD_INT 700
50027: LESS
50028: PUSH
50029: LD_VAR 0 4
50033: PUSH
50034: LD_VAR 0 7
50038: ARRAY
50039: PUSH
50040: LD_VAR 0 30
50044: IN
50045: NOT
50046: AND
50047: IFFALSE 50071
// to_heal := to_heal union group [ i ] ;
50049: LD_ADDR_VAR 0 30
50053: PUSH
50054: LD_VAR 0 30
50058: PUSH
50059: LD_VAR 0 4
50063: PUSH
50064: LD_VAR 0 7
50068: ARRAY
50069: UNION
50070: ST_TO_ADDR
// if group [ i ] in to_heal then
50071: LD_VAR 0 4
50075: PUSH
50076: LD_VAR 0 7
50080: ARRAY
50081: PUSH
50082: LD_VAR 0 30
50086: IN
50087: IFFALSE 50196
// begin if GetLives ( group [ i ] ) = 1000 then
50089: LD_VAR 0 4
50093: PUSH
50094: LD_VAR 0 7
50098: ARRAY
50099: PPUSH
50100: CALL_OW 256
50104: PUSH
50105: LD_INT 1000
50107: EQUAL
50108: IFFALSE 50134
// to_heal := to_heal diff group [ i ] else
50110: LD_ADDR_VAR 0 30
50114: PUSH
50115: LD_VAR 0 30
50119: PUSH
50120: LD_VAR 0 4
50124: PUSH
50125: LD_VAR 0 7
50129: ARRAY
50130: DIFF
50131: ST_TO_ADDR
50132: GO 50196
// begin if not IsInArea ( group [ i ] , to_heal ) then
50134: LD_VAR 0 4
50138: PUSH
50139: LD_VAR 0 7
50143: ARRAY
50144: PPUSH
50145: LD_VAR 0 30
50149: PPUSH
50150: CALL_OW 308
50154: NOT
50155: IFFALSE 50179
// ComMoveToArea ( group [ i ] , f_heal ) else
50157: LD_VAR 0 4
50161: PUSH
50162: LD_VAR 0 7
50166: ARRAY
50167: PPUSH
50168: LD_VAR 0 23
50172: PPUSH
50173: CALL_OW 113
50177: GO 50194
// ComHold ( group [ i ] ) ;
50179: LD_VAR 0 4
50183: PUSH
50184: LD_VAR 0 7
50188: ARRAY
50189: PPUSH
50190: CALL_OW 140
// continue ;
50194: GO 49038
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50196: LD_VAR 0 4
50200: PUSH
50201: LD_VAR 0 7
50205: ARRAY
50206: PPUSH
50207: LD_INT 10
50209: PPUSH
50210: CALL 46836 0 2
50214: NOT
50215: PUSH
50216: LD_VAR 0 16
50220: PUSH
50221: LD_VAR 0 7
50225: ARRAY
50226: PUSH
50227: EMPTY
50228: EQUAL
50229: NOT
50230: AND
50231: IFFALSE 50497
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50233: LD_VAR 0 4
50237: PUSH
50238: LD_VAR 0 7
50242: ARRAY
50243: PPUSH
50244: CALL_OW 262
50248: PUSH
50249: LD_INT 1
50251: PUSH
50252: LD_INT 2
50254: PUSH
50255: EMPTY
50256: LIST
50257: LIST
50258: IN
50259: IFFALSE 50300
// if GetFuel ( group [ i ] ) < 10 then
50261: LD_VAR 0 4
50265: PUSH
50266: LD_VAR 0 7
50270: ARRAY
50271: PPUSH
50272: CALL_OW 261
50276: PUSH
50277: LD_INT 10
50279: LESS
50280: IFFALSE 50300
// SetFuel ( group [ i ] , 12 ) ;
50282: LD_VAR 0 4
50286: PUSH
50287: LD_VAR 0 7
50291: ARRAY
50292: PPUSH
50293: LD_INT 12
50295: PPUSH
50296: CALL_OW 240
// if units_path [ i ] then
50300: LD_VAR 0 16
50304: PUSH
50305: LD_VAR 0 7
50309: ARRAY
50310: IFFALSE 50495
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50312: LD_VAR 0 4
50316: PUSH
50317: LD_VAR 0 7
50321: ARRAY
50322: PPUSH
50323: LD_VAR 0 16
50327: PUSH
50328: LD_VAR 0 7
50332: ARRAY
50333: PUSH
50334: LD_INT 1
50336: ARRAY
50337: PUSH
50338: LD_INT 1
50340: ARRAY
50341: PPUSH
50342: LD_VAR 0 16
50346: PUSH
50347: LD_VAR 0 7
50351: ARRAY
50352: PUSH
50353: LD_INT 1
50355: ARRAY
50356: PUSH
50357: LD_INT 2
50359: ARRAY
50360: PPUSH
50361: CALL_OW 297
50365: PUSH
50366: LD_INT 6
50368: GREATER
50369: IFFALSE 50444
// begin if not HasTask ( group [ i ] ) then
50371: LD_VAR 0 4
50375: PUSH
50376: LD_VAR 0 7
50380: ARRAY
50381: PPUSH
50382: CALL_OW 314
50386: NOT
50387: IFFALSE 50442
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50389: LD_VAR 0 4
50393: PUSH
50394: LD_VAR 0 7
50398: ARRAY
50399: PPUSH
50400: LD_VAR 0 16
50404: PUSH
50405: LD_VAR 0 7
50409: ARRAY
50410: PUSH
50411: LD_INT 1
50413: ARRAY
50414: PUSH
50415: LD_INT 1
50417: ARRAY
50418: PPUSH
50419: LD_VAR 0 16
50423: PUSH
50424: LD_VAR 0 7
50428: ARRAY
50429: PUSH
50430: LD_INT 1
50432: ARRAY
50433: PUSH
50434: LD_INT 2
50436: ARRAY
50437: PPUSH
50438: CALL_OW 114
// end else
50442: GO 50495
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50444: LD_ADDR_VAR 0 15
50448: PUSH
50449: LD_VAR 0 16
50453: PUSH
50454: LD_VAR 0 7
50458: ARRAY
50459: PPUSH
50460: LD_INT 1
50462: PPUSH
50463: CALL_OW 3
50467: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50468: LD_ADDR_VAR 0 16
50472: PUSH
50473: LD_VAR 0 16
50477: PPUSH
50478: LD_VAR 0 7
50482: PPUSH
50483: LD_VAR 0 15
50487: PPUSH
50488: CALL_OW 1
50492: ST_TO_ADDR
// continue ;
50493: GO 49038
// end ; end ; end else
50495: GO 53133
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50497: LD_ADDR_VAR 0 14
50501: PUSH
50502: LD_INT 81
50504: PUSH
50505: LD_VAR 0 4
50509: PUSH
50510: LD_VAR 0 7
50514: ARRAY
50515: PPUSH
50516: CALL_OW 255
50520: PUSH
50521: EMPTY
50522: LIST
50523: LIST
50524: PPUSH
50525: CALL_OW 69
50529: ST_TO_ADDR
// if not tmp then
50530: LD_VAR 0 14
50534: NOT
50535: IFFALSE 50539
// continue ;
50537: GO 49038
// if f_ignore_area then
50539: LD_VAR 0 17
50543: IFFALSE 50631
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
50545: LD_ADDR_VAR 0 15
50549: PUSH
50550: LD_VAR 0 14
50554: PPUSH
50555: LD_INT 3
50557: PUSH
50558: LD_INT 92
50560: PUSH
50561: LD_VAR 0 17
50565: PUSH
50566: LD_INT 1
50568: ARRAY
50569: PUSH
50570: LD_VAR 0 17
50574: PUSH
50575: LD_INT 2
50577: ARRAY
50578: PUSH
50579: LD_VAR 0 17
50583: PUSH
50584: LD_INT 3
50586: ARRAY
50587: PUSH
50588: EMPTY
50589: LIST
50590: LIST
50591: LIST
50592: LIST
50593: PUSH
50594: EMPTY
50595: LIST
50596: LIST
50597: PPUSH
50598: CALL_OW 72
50602: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50603: LD_VAR 0 14
50607: PUSH
50608: LD_VAR 0 15
50612: DIFF
50613: IFFALSE 50631
// tmp := tmp diff tmp2 ;
50615: LD_ADDR_VAR 0 14
50619: PUSH
50620: LD_VAR 0 14
50624: PUSH
50625: LD_VAR 0 15
50629: DIFF
50630: ST_TO_ADDR
// end ; if not f_murder then
50631: LD_VAR 0 20
50635: NOT
50636: IFFALSE 50694
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
50638: LD_ADDR_VAR 0 15
50642: PUSH
50643: LD_VAR 0 14
50647: PPUSH
50648: LD_INT 3
50650: PUSH
50651: LD_INT 50
50653: PUSH
50654: EMPTY
50655: LIST
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: PPUSH
50661: CALL_OW 72
50665: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50666: LD_VAR 0 14
50670: PUSH
50671: LD_VAR 0 15
50675: DIFF
50676: IFFALSE 50694
// tmp := tmp diff tmp2 ;
50678: LD_ADDR_VAR 0 14
50682: PUSH
50683: LD_VAR 0 14
50687: PUSH
50688: LD_VAR 0 15
50692: DIFF
50693: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
50694: LD_ADDR_VAR 0 14
50698: PUSH
50699: LD_VAR 0 4
50703: PUSH
50704: LD_VAR 0 7
50708: ARRAY
50709: PPUSH
50710: LD_VAR 0 14
50714: PPUSH
50715: LD_INT 1
50717: PPUSH
50718: LD_INT 1
50720: PPUSH
50721: CALL 20718 0 4
50725: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
50726: LD_VAR 0 4
50730: PUSH
50731: LD_VAR 0 7
50735: ARRAY
50736: PPUSH
50737: CALL_OW 257
50741: PUSH
50742: LD_INT 1
50744: EQUAL
50745: IFFALSE 51193
// begin if WantPlant ( group [ i ] ) then
50747: LD_VAR 0 4
50751: PUSH
50752: LD_VAR 0 7
50756: ARRAY
50757: PPUSH
50758: CALL 20186 0 1
50762: IFFALSE 50766
// continue ;
50764: GO 49038
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
50766: LD_VAR 0 18
50770: PUSH
50771: LD_VAR 0 4
50775: PUSH
50776: LD_VAR 0 7
50780: ARRAY
50781: PPUSH
50782: CALL_OW 310
50786: NOT
50787: AND
50788: PUSH
50789: LD_VAR 0 14
50793: PUSH
50794: LD_INT 1
50796: ARRAY
50797: PUSH
50798: LD_VAR 0 14
50802: PPUSH
50803: LD_INT 21
50805: PUSH
50806: LD_INT 2
50808: PUSH
50809: EMPTY
50810: LIST
50811: LIST
50812: PUSH
50813: LD_INT 58
50815: PUSH
50816: EMPTY
50817: LIST
50818: PUSH
50819: EMPTY
50820: LIST
50821: LIST
50822: PPUSH
50823: CALL_OW 72
50827: IN
50828: AND
50829: IFFALSE 50865
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
50831: LD_VAR 0 4
50835: PUSH
50836: LD_VAR 0 7
50840: ARRAY
50841: PPUSH
50842: LD_VAR 0 14
50846: PUSH
50847: LD_INT 1
50849: ARRAY
50850: PPUSH
50851: CALL_OW 120
// attacking := true ;
50855: LD_ADDR_VAR 0 29
50859: PUSH
50860: LD_INT 1
50862: ST_TO_ADDR
// continue ;
50863: GO 49038
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
50865: LD_VAR 0 26
50869: PUSH
50870: LD_VAR 0 4
50874: PUSH
50875: LD_VAR 0 7
50879: ARRAY
50880: PPUSH
50881: CALL_OW 257
50885: PUSH
50886: LD_INT 1
50888: EQUAL
50889: AND
50890: PUSH
50891: LD_VAR 0 4
50895: PUSH
50896: LD_VAR 0 7
50900: ARRAY
50901: PPUSH
50902: CALL_OW 256
50906: PUSH
50907: LD_INT 800
50909: LESS
50910: AND
50911: PUSH
50912: LD_VAR 0 4
50916: PUSH
50917: LD_VAR 0 7
50921: ARRAY
50922: PPUSH
50923: CALL_OW 318
50927: NOT
50928: AND
50929: IFFALSE 50946
// ComCrawl ( group [ i ] ) ;
50931: LD_VAR 0 4
50935: PUSH
50936: LD_VAR 0 7
50940: ARRAY
50941: PPUSH
50942: CALL_OW 137
// if f_mines then
50946: LD_VAR 0 21
50950: IFFALSE 51193
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
50952: LD_VAR 0 14
50956: PUSH
50957: LD_INT 1
50959: ARRAY
50960: PPUSH
50961: CALL_OW 247
50965: PUSH
50966: LD_INT 3
50968: EQUAL
50969: PUSH
50970: LD_VAR 0 14
50974: PUSH
50975: LD_INT 1
50977: ARRAY
50978: PUSH
50979: LD_VAR 0 27
50983: IN
50984: NOT
50985: AND
50986: IFFALSE 51193
// begin x := GetX ( tmp [ 1 ] ) ;
50988: LD_ADDR_VAR 0 10
50992: PUSH
50993: LD_VAR 0 14
50997: PUSH
50998: LD_INT 1
51000: ARRAY
51001: PPUSH
51002: CALL_OW 250
51006: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51007: LD_ADDR_VAR 0 11
51011: PUSH
51012: LD_VAR 0 14
51016: PUSH
51017: LD_INT 1
51019: ARRAY
51020: PPUSH
51021: CALL_OW 251
51025: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51026: LD_ADDR_VAR 0 12
51030: PUSH
51031: LD_VAR 0 4
51035: PUSH
51036: LD_VAR 0 7
51040: ARRAY
51041: PPUSH
51042: CALL 46921 0 1
51046: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51047: LD_VAR 0 4
51051: PUSH
51052: LD_VAR 0 7
51056: ARRAY
51057: PPUSH
51058: LD_VAR 0 10
51062: PPUSH
51063: LD_VAR 0 11
51067: PPUSH
51068: LD_VAR 0 14
51072: PUSH
51073: LD_INT 1
51075: ARRAY
51076: PPUSH
51077: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51081: LD_VAR 0 4
51085: PUSH
51086: LD_VAR 0 7
51090: ARRAY
51091: PPUSH
51092: LD_VAR 0 10
51096: PPUSH
51097: LD_VAR 0 12
51101: PPUSH
51102: LD_INT 7
51104: PPUSH
51105: CALL_OW 272
51109: PPUSH
51110: LD_VAR 0 11
51114: PPUSH
51115: LD_VAR 0 12
51119: PPUSH
51120: LD_INT 7
51122: PPUSH
51123: CALL_OW 273
51127: PPUSH
51128: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51132: LD_VAR 0 4
51136: PUSH
51137: LD_VAR 0 7
51141: ARRAY
51142: PPUSH
51143: LD_INT 71
51145: PPUSH
51146: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51150: LD_ADDR_VAR 0 27
51154: PUSH
51155: LD_VAR 0 27
51159: PPUSH
51160: LD_VAR 0 27
51164: PUSH
51165: LD_INT 1
51167: PLUS
51168: PPUSH
51169: LD_VAR 0 14
51173: PUSH
51174: LD_INT 1
51176: ARRAY
51177: PPUSH
51178: CALL_OW 1
51182: ST_TO_ADDR
// attacking := true ;
51183: LD_ADDR_VAR 0 29
51187: PUSH
51188: LD_INT 1
51190: ST_TO_ADDR
// continue ;
51191: GO 49038
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51193: LD_VAR 0 4
51197: PUSH
51198: LD_VAR 0 7
51202: ARRAY
51203: PPUSH
51204: CALL_OW 257
51208: PUSH
51209: LD_INT 17
51211: EQUAL
51212: PUSH
51213: LD_VAR 0 4
51217: PUSH
51218: LD_VAR 0 7
51222: ARRAY
51223: PPUSH
51224: CALL_OW 110
51228: PUSH
51229: LD_INT 71
51231: EQUAL
51232: NOT
51233: AND
51234: IFFALSE 51380
// begin attacking := false ;
51236: LD_ADDR_VAR 0 29
51240: PUSH
51241: LD_INT 0
51243: ST_TO_ADDR
// k := 5 ;
51244: LD_ADDR_VAR 0 9
51248: PUSH
51249: LD_INT 5
51251: ST_TO_ADDR
// if tmp < k then
51252: LD_VAR 0 14
51256: PUSH
51257: LD_VAR 0 9
51261: LESS
51262: IFFALSE 51274
// k := tmp ;
51264: LD_ADDR_VAR 0 9
51268: PUSH
51269: LD_VAR 0 14
51273: ST_TO_ADDR
// for j = 1 to k do
51274: LD_ADDR_VAR 0 8
51278: PUSH
51279: DOUBLE
51280: LD_INT 1
51282: DEC
51283: ST_TO_ADDR
51284: LD_VAR 0 9
51288: PUSH
51289: FOR_TO
51290: IFFALSE 51378
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51292: LD_VAR 0 14
51296: PUSH
51297: LD_VAR 0 8
51301: ARRAY
51302: PUSH
51303: LD_VAR 0 14
51307: PPUSH
51308: LD_INT 58
51310: PUSH
51311: EMPTY
51312: LIST
51313: PPUSH
51314: CALL_OW 72
51318: IN
51319: NOT
51320: IFFALSE 51376
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51322: LD_VAR 0 4
51326: PUSH
51327: LD_VAR 0 7
51331: ARRAY
51332: PPUSH
51333: LD_VAR 0 14
51337: PUSH
51338: LD_VAR 0 8
51342: ARRAY
51343: PPUSH
51344: CALL_OW 115
// attacking := true ;
51348: LD_ADDR_VAR 0 29
51352: PUSH
51353: LD_INT 1
51355: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51356: LD_VAR 0 4
51360: PUSH
51361: LD_VAR 0 7
51365: ARRAY
51366: PPUSH
51367: LD_INT 71
51369: PPUSH
51370: CALL_OW 109
// continue ;
51374: GO 51289
// end ; end ;
51376: GO 51289
51378: POP
51379: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51380: LD_VAR 0 4
51384: PUSH
51385: LD_VAR 0 7
51389: ARRAY
51390: PPUSH
51391: CALL_OW 257
51395: PUSH
51396: LD_INT 8
51398: EQUAL
51399: PUSH
51400: LD_VAR 0 4
51404: PUSH
51405: LD_VAR 0 7
51409: ARRAY
51410: PPUSH
51411: CALL_OW 264
51415: PUSH
51416: LD_INT 28
51418: PUSH
51419: LD_INT 45
51421: PUSH
51422: LD_INT 7
51424: PUSH
51425: LD_INT 47
51427: PUSH
51428: EMPTY
51429: LIST
51430: LIST
51431: LIST
51432: LIST
51433: IN
51434: OR
51435: IFFALSE 51665
// begin attacking := false ;
51437: LD_ADDR_VAR 0 29
51441: PUSH
51442: LD_INT 0
51444: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51445: LD_VAR 0 14
51449: PUSH
51450: LD_INT 1
51452: ARRAY
51453: PPUSH
51454: CALL_OW 266
51458: PUSH
51459: LD_INT 32
51461: PUSH
51462: LD_INT 31
51464: PUSH
51465: LD_INT 33
51467: PUSH
51468: LD_INT 4
51470: PUSH
51471: LD_INT 5
51473: PUSH
51474: EMPTY
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: IN
51481: IFFALSE 51665
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51483: LD_ADDR_VAR 0 9
51487: PUSH
51488: LD_VAR 0 14
51492: PUSH
51493: LD_INT 1
51495: ARRAY
51496: PPUSH
51497: CALL_OW 266
51501: PPUSH
51502: LD_VAR 0 14
51506: PUSH
51507: LD_INT 1
51509: ARRAY
51510: PPUSH
51511: CALL_OW 250
51515: PPUSH
51516: LD_VAR 0 14
51520: PUSH
51521: LD_INT 1
51523: ARRAY
51524: PPUSH
51525: CALL_OW 251
51529: PPUSH
51530: LD_VAR 0 14
51534: PUSH
51535: LD_INT 1
51537: ARRAY
51538: PPUSH
51539: CALL_OW 254
51543: PPUSH
51544: LD_VAR 0 14
51548: PUSH
51549: LD_INT 1
51551: ARRAY
51552: PPUSH
51553: CALL_OW 248
51557: PPUSH
51558: LD_INT 0
51560: PPUSH
51561: CALL 28297 0 6
51565: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
51566: LD_ADDR_VAR 0 8
51570: PUSH
51571: LD_VAR 0 4
51575: PUSH
51576: LD_VAR 0 7
51580: ARRAY
51581: PPUSH
51582: LD_VAR 0 9
51586: PPUSH
51587: CALL 46984 0 2
51591: ST_TO_ADDR
// if j then
51592: LD_VAR 0 8
51596: IFFALSE 51665
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
51598: LD_VAR 0 8
51602: PUSH
51603: LD_INT 1
51605: ARRAY
51606: PPUSH
51607: LD_VAR 0 8
51611: PUSH
51612: LD_INT 2
51614: ARRAY
51615: PPUSH
51616: CALL_OW 488
51620: IFFALSE 51665
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
51622: LD_VAR 0 4
51626: PUSH
51627: LD_VAR 0 7
51631: ARRAY
51632: PPUSH
51633: LD_VAR 0 8
51637: PUSH
51638: LD_INT 1
51640: ARRAY
51641: PPUSH
51642: LD_VAR 0 8
51646: PUSH
51647: LD_INT 2
51649: ARRAY
51650: PPUSH
51651: CALL_OW 116
// attacking := true ;
51655: LD_ADDR_VAR 0 29
51659: PUSH
51660: LD_INT 1
51662: ST_TO_ADDR
// continue ;
51663: GO 49038
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
51665: LD_VAR 0 4
51669: PUSH
51670: LD_VAR 0 7
51674: ARRAY
51675: PPUSH
51676: CALL_OW 265
51680: PUSH
51681: LD_INT 11
51683: EQUAL
51684: IFFALSE 51962
// begin k := 10 ;
51686: LD_ADDR_VAR 0 9
51690: PUSH
51691: LD_INT 10
51693: ST_TO_ADDR
// x := 0 ;
51694: LD_ADDR_VAR 0 10
51698: PUSH
51699: LD_INT 0
51701: ST_TO_ADDR
// if tmp < k then
51702: LD_VAR 0 14
51706: PUSH
51707: LD_VAR 0 9
51711: LESS
51712: IFFALSE 51724
// k := tmp ;
51714: LD_ADDR_VAR 0 9
51718: PUSH
51719: LD_VAR 0 14
51723: ST_TO_ADDR
// for j = k downto 1 do
51724: LD_ADDR_VAR 0 8
51728: PUSH
51729: DOUBLE
51730: LD_VAR 0 9
51734: INC
51735: ST_TO_ADDR
51736: LD_INT 1
51738: PUSH
51739: FOR_DOWNTO
51740: IFFALSE 51815
// begin if GetType ( tmp [ j ] ) = unit_human then
51742: LD_VAR 0 14
51746: PUSH
51747: LD_VAR 0 8
51751: ARRAY
51752: PPUSH
51753: CALL_OW 247
51757: PUSH
51758: LD_INT 1
51760: EQUAL
51761: IFFALSE 51813
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
51763: LD_VAR 0 4
51767: PUSH
51768: LD_VAR 0 7
51772: ARRAY
51773: PPUSH
51774: LD_VAR 0 14
51778: PUSH
51779: LD_VAR 0 8
51783: ARRAY
51784: PPUSH
51785: CALL 47255 0 2
// x := tmp [ j ] ;
51789: LD_ADDR_VAR 0 10
51793: PUSH
51794: LD_VAR 0 14
51798: PUSH
51799: LD_VAR 0 8
51803: ARRAY
51804: ST_TO_ADDR
// attacking := true ;
51805: LD_ADDR_VAR 0 29
51809: PUSH
51810: LD_INT 1
51812: ST_TO_ADDR
// end ; end ;
51813: GO 51739
51815: POP
51816: POP
// if not x then
51817: LD_VAR 0 10
51821: NOT
51822: IFFALSE 51962
// begin attacking := true ;
51824: LD_ADDR_VAR 0 29
51828: PUSH
51829: LD_INT 1
51831: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
51832: LD_VAR 0 4
51836: PUSH
51837: LD_VAR 0 7
51841: ARRAY
51842: PPUSH
51843: CALL_OW 250
51847: PPUSH
51848: LD_VAR 0 4
51852: PUSH
51853: LD_VAR 0 7
51857: ARRAY
51858: PPUSH
51859: CALL_OW 251
51863: PPUSH
51864: CALL_OW 546
51868: PUSH
51869: LD_INT 2
51871: ARRAY
51872: PUSH
51873: LD_VAR 0 14
51877: PUSH
51878: LD_INT 1
51880: ARRAY
51881: PPUSH
51882: CALL_OW 250
51886: PPUSH
51887: LD_VAR 0 14
51891: PUSH
51892: LD_INT 1
51894: ARRAY
51895: PPUSH
51896: CALL_OW 251
51900: PPUSH
51901: CALL_OW 546
51905: PUSH
51906: LD_INT 2
51908: ARRAY
51909: EQUAL
51910: IFFALSE 51938
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
51912: LD_VAR 0 4
51916: PUSH
51917: LD_VAR 0 7
51921: ARRAY
51922: PPUSH
51923: LD_VAR 0 14
51927: PUSH
51928: LD_INT 1
51930: ARRAY
51931: PPUSH
51932: CALL 47255 0 2
51936: GO 51962
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
51938: LD_VAR 0 4
51942: PUSH
51943: LD_VAR 0 7
51947: ARRAY
51948: PPUSH
51949: LD_VAR 0 14
51953: PUSH
51954: LD_INT 1
51956: ARRAY
51957: PPUSH
51958: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
51962: LD_VAR 0 4
51966: PUSH
51967: LD_VAR 0 7
51971: ARRAY
51972: PPUSH
51973: CALL_OW 264
51977: PUSH
51978: LD_INT 29
51980: EQUAL
51981: IFFALSE 52347
// begin if WantsToAttack ( group [ i ] ) in bombed then
51983: LD_VAR 0 4
51987: PUSH
51988: LD_VAR 0 7
51992: ARRAY
51993: PPUSH
51994: CALL_OW 319
51998: PUSH
51999: LD_VAR 0 28
52003: IN
52004: IFFALSE 52008
// continue ;
52006: GO 49038
// k := 8 ;
52008: LD_ADDR_VAR 0 9
52012: PUSH
52013: LD_INT 8
52015: ST_TO_ADDR
// x := 0 ;
52016: LD_ADDR_VAR 0 10
52020: PUSH
52021: LD_INT 0
52023: ST_TO_ADDR
// if tmp < k then
52024: LD_VAR 0 14
52028: PUSH
52029: LD_VAR 0 9
52033: LESS
52034: IFFALSE 52046
// k := tmp ;
52036: LD_ADDR_VAR 0 9
52040: PUSH
52041: LD_VAR 0 14
52045: ST_TO_ADDR
// for j = 1 to k do
52046: LD_ADDR_VAR 0 8
52050: PUSH
52051: DOUBLE
52052: LD_INT 1
52054: DEC
52055: ST_TO_ADDR
52056: LD_VAR 0 9
52060: PUSH
52061: FOR_TO
52062: IFFALSE 52194
// begin if GetType ( tmp [ j ] ) = unit_building then
52064: LD_VAR 0 14
52068: PUSH
52069: LD_VAR 0 8
52073: ARRAY
52074: PPUSH
52075: CALL_OW 247
52079: PUSH
52080: LD_INT 3
52082: EQUAL
52083: IFFALSE 52192
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52085: LD_VAR 0 14
52089: PUSH
52090: LD_VAR 0 8
52094: ARRAY
52095: PUSH
52096: LD_VAR 0 28
52100: IN
52101: NOT
52102: PUSH
52103: LD_VAR 0 14
52107: PUSH
52108: LD_VAR 0 8
52112: ARRAY
52113: PPUSH
52114: CALL_OW 313
52118: AND
52119: IFFALSE 52192
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52121: LD_VAR 0 4
52125: PUSH
52126: LD_VAR 0 7
52130: ARRAY
52131: PPUSH
52132: LD_VAR 0 14
52136: PUSH
52137: LD_VAR 0 8
52141: ARRAY
52142: PPUSH
52143: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52147: LD_ADDR_VAR 0 28
52151: PUSH
52152: LD_VAR 0 28
52156: PPUSH
52157: LD_VAR 0 28
52161: PUSH
52162: LD_INT 1
52164: PLUS
52165: PPUSH
52166: LD_VAR 0 14
52170: PUSH
52171: LD_VAR 0 8
52175: ARRAY
52176: PPUSH
52177: CALL_OW 1
52181: ST_TO_ADDR
// attacking := true ;
52182: LD_ADDR_VAR 0 29
52186: PUSH
52187: LD_INT 1
52189: ST_TO_ADDR
// break ;
52190: GO 52194
// end ; end ;
52192: GO 52061
52194: POP
52195: POP
// if not attacking and f_attack_depot then
52196: LD_VAR 0 29
52200: NOT
52201: PUSH
52202: LD_VAR 0 25
52206: AND
52207: IFFALSE 52302
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52209: LD_ADDR_VAR 0 13
52213: PUSH
52214: LD_VAR 0 14
52218: PPUSH
52219: LD_INT 2
52221: PUSH
52222: LD_INT 30
52224: PUSH
52225: LD_INT 0
52227: PUSH
52228: EMPTY
52229: LIST
52230: LIST
52231: PUSH
52232: LD_INT 30
52234: PUSH
52235: LD_INT 1
52237: PUSH
52238: EMPTY
52239: LIST
52240: LIST
52241: PUSH
52242: EMPTY
52243: LIST
52244: LIST
52245: LIST
52246: PPUSH
52247: CALL_OW 72
52251: ST_TO_ADDR
// if z then
52252: LD_VAR 0 13
52256: IFFALSE 52302
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52258: LD_VAR 0 4
52262: PUSH
52263: LD_VAR 0 7
52267: ARRAY
52268: PPUSH
52269: LD_VAR 0 13
52273: PPUSH
52274: LD_VAR 0 4
52278: PUSH
52279: LD_VAR 0 7
52283: ARRAY
52284: PPUSH
52285: CALL_OW 74
52289: PPUSH
52290: CALL_OW 115
// attacking := true ;
52294: LD_ADDR_VAR 0 29
52298: PUSH
52299: LD_INT 1
52301: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52302: LD_VAR 0 4
52306: PUSH
52307: LD_VAR 0 7
52311: ARRAY
52312: PPUSH
52313: CALL_OW 256
52317: PUSH
52318: LD_INT 500
52320: LESS
52321: IFFALSE 52347
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52323: LD_VAR 0 4
52327: PUSH
52328: LD_VAR 0 7
52332: ARRAY
52333: PPUSH
52334: LD_VAR 0 14
52338: PUSH
52339: LD_INT 1
52341: ARRAY
52342: PPUSH
52343: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52347: LD_VAR 0 4
52351: PUSH
52352: LD_VAR 0 7
52356: ARRAY
52357: PPUSH
52358: CALL_OW 264
52362: PUSH
52363: LD_INT 49
52365: EQUAL
52366: IFFALSE 52487
// begin if not HasTask ( group [ i ] ) then
52368: LD_VAR 0 4
52372: PUSH
52373: LD_VAR 0 7
52377: ARRAY
52378: PPUSH
52379: CALL_OW 314
52383: NOT
52384: IFFALSE 52487
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52386: LD_ADDR_VAR 0 9
52390: PUSH
52391: LD_INT 81
52393: PUSH
52394: LD_VAR 0 4
52398: PUSH
52399: LD_VAR 0 7
52403: ARRAY
52404: PPUSH
52405: CALL_OW 255
52409: PUSH
52410: EMPTY
52411: LIST
52412: LIST
52413: PPUSH
52414: CALL_OW 69
52418: PPUSH
52419: LD_VAR 0 4
52423: PUSH
52424: LD_VAR 0 7
52428: ARRAY
52429: PPUSH
52430: CALL_OW 74
52434: ST_TO_ADDR
// if k then
52435: LD_VAR 0 9
52439: IFFALSE 52487
// if GetDistUnits ( group [ i ] , k ) > 10 then
52441: LD_VAR 0 4
52445: PUSH
52446: LD_VAR 0 7
52450: ARRAY
52451: PPUSH
52452: LD_VAR 0 9
52456: PPUSH
52457: CALL_OW 296
52461: PUSH
52462: LD_INT 10
52464: GREATER
52465: IFFALSE 52487
// ComMoveUnit ( group [ i ] , k ) ;
52467: LD_VAR 0 4
52471: PUSH
52472: LD_VAR 0 7
52476: ARRAY
52477: PPUSH
52478: LD_VAR 0 9
52482: PPUSH
52483: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52487: LD_VAR 0 4
52491: PUSH
52492: LD_VAR 0 7
52496: ARRAY
52497: PPUSH
52498: CALL_OW 256
52502: PUSH
52503: LD_INT 250
52505: LESS
52506: PUSH
52507: LD_VAR 0 4
52511: PUSH
52512: LD_VAR 0 7
52516: ARRAY
52517: PUSH
52518: LD_INT 21
52520: PUSH
52521: LD_INT 2
52523: PUSH
52524: EMPTY
52525: LIST
52526: LIST
52527: PUSH
52528: LD_INT 23
52530: PUSH
52531: LD_INT 2
52533: PUSH
52534: EMPTY
52535: LIST
52536: LIST
52537: PUSH
52538: EMPTY
52539: LIST
52540: LIST
52541: PPUSH
52542: CALL_OW 69
52546: IN
52547: AND
52548: IFFALSE 52673
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
52550: LD_ADDR_VAR 0 9
52554: PUSH
52555: LD_OWVAR 3
52559: PUSH
52560: LD_VAR 0 4
52564: PUSH
52565: LD_VAR 0 7
52569: ARRAY
52570: DIFF
52571: PPUSH
52572: LD_VAR 0 4
52576: PUSH
52577: LD_VAR 0 7
52581: ARRAY
52582: PPUSH
52583: CALL_OW 74
52587: ST_TO_ADDR
// if not k then
52588: LD_VAR 0 9
52592: NOT
52593: IFFALSE 52597
// continue ;
52595: GO 49038
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
52597: LD_VAR 0 9
52601: PUSH
52602: LD_INT 81
52604: PUSH
52605: LD_VAR 0 4
52609: PUSH
52610: LD_VAR 0 7
52614: ARRAY
52615: PPUSH
52616: CALL_OW 255
52620: PUSH
52621: EMPTY
52622: LIST
52623: LIST
52624: PPUSH
52625: CALL_OW 69
52629: IN
52630: PUSH
52631: LD_VAR 0 9
52635: PPUSH
52636: LD_VAR 0 4
52640: PUSH
52641: LD_VAR 0 7
52645: ARRAY
52646: PPUSH
52647: CALL_OW 296
52651: PUSH
52652: LD_INT 5
52654: LESS
52655: AND
52656: IFFALSE 52673
// ComAutodestruct ( group [ i ] ) ;
52658: LD_VAR 0 4
52662: PUSH
52663: LD_VAR 0 7
52667: ARRAY
52668: PPUSH
52669: CALL 47153 0 1
// end ; if f_attack_depot then
52673: LD_VAR 0 25
52677: IFFALSE 52789
// begin k := 6 ;
52679: LD_ADDR_VAR 0 9
52683: PUSH
52684: LD_INT 6
52686: ST_TO_ADDR
// if tmp < k then
52687: LD_VAR 0 14
52691: PUSH
52692: LD_VAR 0 9
52696: LESS
52697: IFFALSE 52709
// k := tmp ;
52699: LD_ADDR_VAR 0 9
52703: PUSH
52704: LD_VAR 0 14
52708: ST_TO_ADDR
// for j = 1 to k do
52709: LD_ADDR_VAR 0 8
52713: PUSH
52714: DOUBLE
52715: LD_INT 1
52717: DEC
52718: ST_TO_ADDR
52719: LD_VAR 0 9
52723: PUSH
52724: FOR_TO
52725: IFFALSE 52787
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
52727: LD_VAR 0 8
52731: PPUSH
52732: CALL_OW 266
52736: PUSH
52737: LD_INT 0
52739: PUSH
52740: LD_INT 1
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: IN
52747: IFFALSE 52785
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52749: LD_VAR 0 4
52753: PUSH
52754: LD_VAR 0 7
52758: ARRAY
52759: PPUSH
52760: LD_VAR 0 14
52764: PUSH
52765: LD_VAR 0 8
52769: ARRAY
52770: PPUSH
52771: CALL_OW 115
// attacking := true ;
52775: LD_ADDR_VAR 0 29
52779: PUSH
52780: LD_INT 1
52782: ST_TO_ADDR
// break ;
52783: GO 52787
// end ;
52785: GO 52724
52787: POP
52788: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
52789: LD_VAR 0 4
52793: PUSH
52794: LD_VAR 0 7
52798: ARRAY
52799: PPUSH
52800: CALL_OW 302
52804: PUSH
52805: LD_VAR 0 29
52809: NOT
52810: AND
52811: IFFALSE 53133
// begin if GetTag ( group [ i ] ) = 71 then
52813: LD_VAR 0 4
52817: PUSH
52818: LD_VAR 0 7
52822: ARRAY
52823: PPUSH
52824: CALL_OW 110
52828: PUSH
52829: LD_INT 71
52831: EQUAL
52832: IFFALSE 52873
// begin if HasTask ( group [ i ] ) then
52834: LD_VAR 0 4
52838: PUSH
52839: LD_VAR 0 7
52843: ARRAY
52844: PPUSH
52845: CALL_OW 314
52849: IFFALSE 52855
// continue else
52851: GO 49038
52853: GO 52873
// SetTag ( group [ i ] , 0 ) ;
52855: LD_VAR 0 4
52859: PUSH
52860: LD_VAR 0 7
52864: ARRAY
52865: PPUSH
52866: LD_INT 0
52868: PPUSH
52869: CALL_OW 109
// end ; k := 8 ;
52873: LD_ADDR_VAR 0 9
52877: PUSH
52878: LD_INT 8
52880: ST_TO_ADDR
// x := 0 ;
52881: LD_ADDR_VAR 0 10
52885: PUSH
52886: LD_INT 0
52888: ST_TO_ADDR
// if tmp < k then
52889: LD_VAR 0 14
52893: PUSH
52894: LD_VAR 0 9
52898: LESS
52899: IFFALSE 52911
// k := tmp ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_VAR 0 14
52910: ST_TO_ADDR
// for j = 1 to k do
52911: LD_ADDR_VAR 0 8
52915: PUSH
52916: DOUBLE
52917: LD_INT 1
52919: DEC
52920: ST_TO_ADDR
52921: LD_VAR 0 9
52925: PUSH
52926: FOR_TO
52927: IFFALSE 53025
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
52929: LD_VAR 0 14
52933: PUSH
52934: LD_VAR 0 8
52938: ARRAY
52939: PPUSH
52940: CALL_OW 247
52944: PUSH
52945: LD_INT 1
52947: EQUAL
52948: PUSH
52949: LD_VAR 0 14
52953: PUSH
52954: LD_VAR 0 8
52958: ARRAY
52959: PPUSH
52960: CALL_OW 256
52964: PUSH
52965: LD_INT 250
52967: LESS
52968: PUSH
52969: LD_VAR 0 20
52973: AND
52974: PUSH
52975: LD_VAR 0 20
52979: NOT
52980: PUSH
52981: LD_VAR 0 14
52985: PUSH
52986: LD_VAR 0 8
52990: ARRAY
52991: PPUSH
52992: CALL_OW 256
52996: PUSH
52997: LD_INT 250
52999: GREATEREQUAL
53000: AND
53001: OR
53002: AND
53003: IFFALSE 53023
// begin x := tmp [ j ] ;
53005: LD_ADDR_VAR 0 10
53009: PUSH
53010: LD_VAR 0 14
53014: PUSH
53015: LD_VAR 0 8
53019: ARRAY
53020: ST_TO_ADDR
// break ;
53021: GO 53025
// end ;
53023: GO 52926
53025: POP
53026: POP
// if x then
53027: LD_VAR 0 10
53031: IFFALSE 53055
// ComAttackUnit ( group [ i ] , x ) else
53033: LD_VAR 0 4
53037: PUSH
53038: LD_VAR 0 7
53042: ARRAY
53043: PPUSH
53044: LD_VAR 0 10
53048: PPUSH
53049: CALL_OW 115
53053: GO 53079
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53055: LD_VAR 0 4
53059: PUSH
53060: LD_VAR 0 7
53064: ARRAY
53065: PPUSH
53066: LD_VAR 0 14
53070: PUSH
53071: LD_INT 1
53073: ARRAY
53074: PPUSH
53075: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53079: LD_VAR 0 4
53083: PUSH
53084: LD_VAR 0 7
53088: ARRAY
53089: PPUSH
53090: CALL_OW 314
53094: NOT
53095: IFFALSE 53133
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53097: LD_VAR 0 4
53101: PUSH
53102: LD_VAR 0 7
53106: ARRAY
53107: PPUSH
53108: LD_VAR 0 14
53112: PPUSH
53113: LD_VAR 0 4
53117: PUSH
53118: LD_VAR 0 7
53122: ARRAY
53123: PPUSH
53124: CALL_OW 74
53128: PPUSH
53129: CALL_OW 115
// end ; end ; end ;
53133: GO 49038
53135: POP
53136: POP
// wait ( 0 0$1 ) ;
53137: LD_INT 35
53139: PPUSH
53140: CALL_OW 67
// until group = [ ] ;
53144: LD_VAR 0 4
53148: PUSH
53149: EMPTY
53150: EQUAL
53151: IFFALSE 49023
// end ;
53153: LD_VAR 0 2
53157: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53158: LD_INT 0
53160: PPUSH
53161: PPUSH
53162: PPUSH
53163: PPUSH
// if not base_units then
53164: LD_VAR 0 1
53168: NOT
53169: IFFALSE 53173
// exit ;
53171: GO 53260
// result := false ;
53173: LD_ADDR_VAR 0 2
53177: PUSH
53178: LD_INT 0
53180: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53181: LD_ADDR_VAR 0 5
53185: PUSH
53186: LD_VAR 0 1
53190: PPUSH
53191: LD_INT 21
53193: PUSH
53194: LD_INT 3
53196: PUSH
53197: EMPTY
53198: LIST
53199: LIST
53200: PPUSH
53201: CALL_OW 72
53205: ST_TO_ADDR
// if not tmp then
53206: LD_VAR 0 5
53210: NOT
53211: IFFALSE 53215
// exit ;
53213: GO 53260
// for i in tmp do
53215: LD_ADDR_VAR 0 3
53219: PUSH
53220: LD_VAR 0 5
53224: PUSH
53225: FOR_IN
53226: IFFALSE 53258
// begin result := EnemyInRange ( i , 22 ) ;
53228: LD_ADDR_VAR 0 2
53232: PUSH
53233: LD_VAR 0 3
53237: PPUSH
53238: LD_INT 22
53240: PPUSH
53241: CALL 46836 0 2
53245: ST_TO_ADDR
// if result then
53246: LD_VAR 0 2
53250: IFFALSE 53256
// exit ;
53252: POP
53253: POP
53254: GO 53260
// end ;
53256: GO 53225
53258: POP
53259: POP
// end ;
53260: LD_VAR 0 2
53264: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53265: LD_INT 0
53267: PPUSH
53268: PPUSH
// if not units then
53269: LD_VAR 0 1
53273: NOT
53274: IFFALSE 53278
// exit ;
53276: GO 53348
// result := [ ] ;
53278: LD_ADDR_VAR 0 3
53282: PUSH
53283: EMPTY
53284: ST_TO_ADDR
// for i in units do
53285: LD_ADDR_VAR 0 4
53289: PUSH
53290: LD_VAR 0 1
53294: PUSH
53295: FOR_IN
53296: IFFALSE 53346
// if GetTag ( i ) = tag then
53298: LD_VAR 0 4
53302: PPUSH
53303: CALL_OW 110
53307: PUSH
53308: LD_VAR 0 2
53312: EQUAL
53313: IFFALSE 53344
// result := Insert ( result , result + 1 , i ) ;
53315: LD_ADDR_VAR 0 3
53319: PUSH
53320: LD_VAR 0 3
53324: PPUSH
53325: LD_VAR 0 3
53329: PUSH
53330: LD_INT 1
53332: PLUS
53333: PPUSH
53334: LD_VAR 0 4
53338: PPUSH
53339: CALL_OW 2
53343: ST_TO_ADDR
53344: GO 53295
53346: POP
53347: POP
// end ;
53348: LD_VAR 0 3
53352: RET
// export function IsDriver ( un ) ; begin
53353: LD_INT 0
53355: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53356: LD_ADDR_VAR 0 2
53360: PUSH
53361: LD_VAR 0 1
53365: PUSH
53366: LD_INT 55
53368: PUSH
53369: EMPTY
53370: LIST
53371: PPUSH
53372: CALL_OW 69
53376: IN
53377: ST_TO_ADDR
// end ;
53378: LD_VAR 0 2
53382: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53383: LD_INT 0
53385: PPUSH
53386: PPUSH
// list := [ ] ;
53387: LD_ADDR_VAR 0 5
53391: PUSH
53392: EMPTY
53393: ST_TO_ADDR
// case d of 0 :
53394: LD_VAR 0 3
53398: PUSH
53399: LD_INT 0
53401: DOUBLE
53402: EQUAL
53403: IFTRUE 53407
53405: GO 53540
53407: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53408: LD_ADDR_VAR 0 5
53412: PUSH
53413: LD_VAR 0 1
53417: PUSH
53418: LD_INT 4
53420: MINUS
53421: PUSH
53422: LD_VAR 0 2
53426: PUSH
53427: LD_INT 4
53429: MINUS
53430: PUSH
53431: LD_INT 2
53433: PUSH
53434: EMPTY
53435: LIST
53436: LIST
53437: LIST
53438: PUSH
53439: LD_VAR 0 1
53443: PUSH
53444: LD_INT 3
53446: MINUS
53447: PUSH
53448: LD_VAR 0 2
53452: PUSH
53453: LD_INT 1
53455: PUSH
53456: EMPTY
53457: LIST
53458: LIST
53459: LIST
53460: PUSH
53461: LD_VAR 0 1
53465: PUSH
53466: LD_INT 4
53468: PLUS
53469: PUSH
53470: LD_VAR 0 2
53474: PUSH
53475: LD_INT 4
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: LIST
53482: PUSH
53483: LD_VAR 0 1
53487: PUSH
53488: LD_INT 3
53490: PLUS
53491: PUSH
53492: LD_VAR 0 2
53496: PUSH
53497: LD_INT 3
53499: PLUS
53500: PUSH
53501: LD_INT 5
53503: PUSH
53504: EMPTY
53505: LIST
53506: LIST
53507: LIST
53508: PUSH
53509: LD_VAR 0 1
53513: PUSH
53514: LD_VAR 0 2
53518: PUSH
53519: LD_INT 4
53521: PLUS
53522: PUSH
53523: LD_INT 0
53525: PUSH
53526: EMPTY
53527: LIST
53528: LIST
53529: LIST
53530: PUSH
53531: EMPTY
53532: LIST
53533: LIST
53534: LIST
53535: LIST
53536: LIST
53537: ST_TO_ADDR
// end ; 1 :
53538: GO 54238
53540: LD_INT 1
53542: DOUBLE
53543: EQUAL
53544: IFTRUE 53548
53546: GO 53681
53548: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53549: LD_ADDR_VAR 0 5
53553: PUSH
53554: LD_VAR 0 1
53558: PUSH
53559: LD_VAR 0 2
53563: PUSH
53564: LD_INT 4
53566: MINUS
53567: PUSH
53568: LD_INT 3
53570: PUSH
53571: EMPTY
53572: LIST
53573: LIST
53574: LIST
53575: PUSH
53576: LD_VAR 0 1
53580: PUSH
53581: LD_INT 3
53583: MINUS
53584: PUSH
53585: LD_VAR 0 2
53589: PUSH
53590: LD_INT 3
53592: MINUS
53593: PUSH
53594: LD_INT 2
53596: PUSH
53597: EMPTY
53598: LIST
53599: LIST
53600: LIST
53601: PUSH
53602: LD_VAR 0 1
53606: PUSH
53607: LD_INT 4
53609: MINUS
53610: PUSH
53611: LD_VAR 0 2
53615: PUSH
53616: LD_INT 1
53618: PUSH
53619: EMPTY
53620: LIST
53621: LIST
53622: LIST
53623: PUSH
53624: LD_VAR 0 1
53628: PUSH
53629: LD_VAR 0 2
53633: PUSH
53634: LD_INT 3
53636: PLUS
53637: PUSH
53638: LD_INT 0
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: LIST
53645: PUSH
53646: LD_VAR 0 1
53650: PUSH
53651: LD_INT 4
53653: PLUS
53654: PUSH
53655: LD_VAR 0 2
53659: PUSH
53660: LD_INT 4
53662: PLUS
53663: PUSH
53664: LD_INT 5
53666: PUSH
53667: EMPTY
53668: LIST
53669: LIST
53670: LIST
53671: PUSH
53672: EMPTY
53673: LIST
53674: LIST
53675: LIST
53676: LIST
53677: LIST
53678: ST_TO_ADDR
// end ; 2 :
53679: GO 54238
53681: LD_INT 2
53683: DOUBLE
53684: EQUAL
53685: IFTRUE 53689
53687: GO 53818
53689: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53690: LD_ADDR_VAR 0 5
53694: PUSH
53695: LD_VAR 0 1
53699: PUSH
53700: LD_VAR 0 2
53704: PUSH
53705: LD_INT 3
53707: MINUS
53708: PUSH
53709: LD_INT 3
53711: PUSH
53712: EMPTY
53713: LIST
53714: LIST
53715: LIST
53716: PUSH
53717: LD_VAR 0 1
53721: PUSH
53722: LD_INT 4
53724: PLUS
53725: PUSH
53726: LD_VAR 0 2
53730: PUSH
53731: LD_INT 4
53733: PUSH
53734: EMPTY
53735: LIST
53736: LIST
53737: LIST
53738: PUSH
53739: LD_VAR 0 1
53743: PUSH
53744: LD_VAR 0 2
53748: PUSH
53749: LD_INT 4
53751: PLUS
53752: PUSH
53753: LD_INT 0
53755: PUSH
53756: EMPTY
53757: LIST
53758: LIST
53759: LIST
53760: PUSH
53761: LD_VAR 0 1
53765: PUSH
53766: LD_INT 3
53768: MINUS
53769: PUSH
53770: LD_VAR 0 2
53774: PUSH
53775: LD_INT 1
53777: PUSH
53778: EMPTY
53779: LIST
53780: LIST
53781: LIST
53782: PUSH
53783: LD_VAR 0 1
53787: PUSH
53788: LD_INT 4
53790: MINUS
53791: PUSH
53792: LD_VAR 0 2
53796: PUSH
53797: LD_INT 4
53799: MINUS
53800: PUSH
53801: LD_INT 2
53803: PUSH
53804: EMPTY
53805: LIST
53806: LIST
53807: LIST
53808: PUSH
53809: EMPTY
53810: LIST
53811: LIST
53812: LIST
53813: LIST
53814: LIST
53815: ST_TO_ADDR
// end ; 3 :
53816: GO 54238
53818: LD_INT 3
53820: DOUBLE
53821: EQUAL
53822: IFTRUE 53826
53824: GO 53959
53826: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53827: LD_ADDR_VAR 0 5
53831: PUSH
53832: LD_VAR 0 1
53836: PUSH
53837: LD_INT 3
53839: PLUS
53840: PUSH
53841: LD_VAR 0 2
53845: PUSH
53846: LD_INT 4
53848: PUSH
53849: EMPTY
53850: LIST
53851: LIST
53852: LIST
53853: PUSH
53854: LD_VAR 0 1
53858: PUSH
53859: LD_INT 4
53861: PLUS
53862: PUSH
53863: LD_VAR 0 2
53867: PUSH
53868: LD_INT 4
53870: PLUS
53871: PUSH
53872: LD_INT 5
53874: PUSH
53875: EMPTY
53876: LIST
53877: LIST
53878: LIST
53879: PUSH
53880: LD_VAR 0 1
53884: PUSH
53885: LD_INT 4
53887: MINUS
53888: PUSH
53889: LD_VAR 0 2
53893: PUSH
53894: LD_INT 1
53896: PUSH
53897: EMPTY
53898: LIST
53899: LIST
53900: LIST
53901: PUSH
53902: LD_VAR 0 1
53906: PUSH
53907: LD_VAR 0 2
53911: PUSH
53912: LD_INT 4
53914: MINUS
53915: PUSH
53916: LD_INT 3
53918: PUSH
53919: EMPTY
53920: LIST
53921: LIST
53922: LIST
53923: PUSH
53924: LD_VAR 0 1
53928: PUSH
53929: LD_INT 3
53931: MINUS
53932: PUSH
53933: LD_VAR 0 2
53937: PUSH
53938: LD_INT 3
53940: MINUS
53941: PUSH
53942: LD_INT 2
53944: PUSH
53945: EMPTY
53946: LIST
53947: LIST
53948: LIST
53949: PUSH
53950: EMPTY
53951: LIST
53952: LIST
53953: LIST
53954: LIST
53955: LIST
53956: ST_TO_ADDR
// end ; 4 :
53957: GO 54238
53959: LD_INT 4
53961: DOUBLE
53962: EQUAL
53963: IFTRUE 53967
53965: GO 54100
53967: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53968: LD_ADDR_VAR 0 5
53972: PUSH
53973: LD_VAR 0 1
53977: PUSH
53978: LD_VAR 0 2
53982: PUSH
53983: LD_INT 4
53985: PLUS
53986: PUSH
53987: LD_INT 0
53989: PUSH
53990: EMPTY
53991: LIST
53992: LIST
53993: LIST
53994: PUSH
53995: LD_VAR 0 1
53999: PUSH
54000: LD_INT 3
54002: PLUS
54003: PUSH
54004: LD_VAR 0 2
54008: PUSH
54009: LD_INT 3
54011: PLUS
54012: PUSH
54013: LD_INT 5
54015: PUSH
54016: EMPTY
54017: LIST
54018: LIST
54019: LIST
54020: PUSH
54021: LD_VAR 0 1
54025: PUSH
54026: LD_INT 4
54028: PLUS
54029: PUSH
54030: LD_VAR 0 2
54034: PUSH
54035: LD_INT 4
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: LIST
54042: PUSH
54043: LD_VAR 0 1
54047: PUSH
54048: LD_VAR 0 2
54052: PUSH
54053: LD_INT 3
54055: MINUS
54056: PUSH
54057: LD_INT 3
54059: PUSH
54060: EMPTY
54061: LIST
54062: LIST
54063: LIST
54064: PUSH
54065: LD_VAR 0 1
54069: PUSH
54070: LD_INT 4
54072: MINUS
54073: PUSH
54074: LD_VAR 0 2
54078: PUSH
54079: LD_INT 4
54081: MINUS
54082: PUSH
54083: LD_INT 2
54085: PUSH
54086: EMPTY
54087: LIST
54088: LIST
54089: LIST
54090: PUSH
54091: EMPTY
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: ST_TO_ADDR
// end ; 5 :
54098: GO 54238
54100: LD_INT 5
54102: DOUBLE
54103: EQUAL
54104: IFTRUE 54108
54106: GO 54237
54108: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54109: LD_ADDR_VAR 0 5
54113: PUSH
54114: LD_VAR 0 1
54118: PUSH
54119: LD_INT 4
54121: MINUS
54122: PUSH
54123: LD_VAR 0 2
54127: PUSH
54128: LD_INT 1
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: LIST
54135: PUSH
54136: LD_VAR 0 1
54140: PUSH
54141: LD_VAR 0 2
54145: PUSH
54146: LD_INT 4
54148: MINUS
54149: PUSH
54150: LD_INT 3
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: LIST
54157: PUSH
54158: LD_VAR 0 1
54162: PUSH
54163: LD_INT 4
54165: PLUS
54166: PUSH
54167: LD_VAR 0 2
54171: PUSH
54172: LD_INT 4
54174: PLUS
54175: PUSH
54176: LD_INT 5
54178: PUSH
54179: EMPTY
54180: LIST
54181: LIST
54182: LIST
54183: PUSH
54184: LD_VAR 0 1
54188: PUSH
54189: LD_INT 3
54191: PLUS
54192: PUSH
54193: LD_VAR 0 2
54197: PUSH
54198: LD_INT 4
54200: PUSH
54201: EMPTY
54202: LIST
54203: LIST
54204: LIST
54205: PUSH
54206: LD_VAR 0 1
54210: PUSH
54211: LD_VAR 0 2
54215: PUSH
54216: LD_INT 3
54218: PLUS
54219: PUSH
54220: LD_INT 0
54222: PUSH
54223: EMPTY
54224: LIST
54225: LIST
54226: LIST
54227: PUSH
54228: EMPTY
54229: LIST
54230: LIST
54231: LIST
54232: LIST
54233: LIST
54234: ST_TO_ADDR
// end ; end ;
54235: GO 54238
54237: POP
// result := list ;
54238: LD_ADDR_VAR 0 4
54242: PUSH
54243: LD_VAR 0 5
54247: ST_TO_ADDR
// end ;
54248: LD_VAR 0 4
54252: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54253: LD_INT 0
54255: PPUSH
54256: PPUSH
54257: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54258: LD_VAR 0 1
54262: NOT
54263: PUSH
54264: LD_VAR 0 2
54268: PUSH
54269: LD_INT 1
54271: PUSH
54272: LD_INT 2
54274: PUSH
54275: LD_INT 3
54277: PUSH
54278: LD_INT 4
54280: PUSH
54281: EMPTY
54282: LIST
54283: LIST
54284: LIST
54285: LIST
54286: IN
54287: NOT
54288: OR
54289: IFFALSE 54293
// exit ;
54291: GO 54385
// tmp := [ ] ;
54293: LD_ADDR_VAR 0 5
54297: PUSH
54298: EMPTY
54299: ST_TO_ADDR
// for i in units do
54300: LD_ADDR_VAR 0 4
54304: PUSH
54305: LD_VAR 0 1
54309: PUSH
54310: FOR_IN
54311: IFFALSE 54354
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54313: LD_ADDR_VAR 0 5
54317: PUSH
54318: LD_VAR 0 5
54322: PPUSH
54323: LD_VAR 0 5
54327: PUSH
54328: LD_INT 1
54330: PLUS
54331: PPUSH
54332: LD_VAR 0 4
54336: PPUSH
54337: LD_VAR 0 2
54341: PPUSH
54342: CALL_OW 259
54346: PPUSH
54347: CALL_OW 2
54351: ST_TO_ADDR
54352: GO 54310
54354: POP
54355: POP
// if not tmp then
54356: LD_VAR 0 5
54360: NOT
54361: IFFALSE 54365
// exit ;
54363: GO 54385
// result := SortListByListDesc ( units , tmp ) ;
54365: LD_ADDR_VAR 0 3
54369: PUSH
54370: LD_VAR 0 1
54374: PPUSH
54375: LD_VAR 0 5
54379: PPUSH
54380: CALL_OW 77
54384: ST_TO_ADDR
// end ;
54385: LD_VAR 0 3
54389: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54390: LD_INT 0
54392: PPUSH
54393: PPUSH
54394: PPUSH
// x := GetX ( building ) ;
54395: LD_ADDR_VAR 0 4
54399: PUSH
54400: LD_VAR 0 2
54404: PPUSH
54405: CALL_OW 250
54409: ST_TO_ADDR
// y := GetY ( building ) ;
54410: LD_ADDR_VAR 0 5
54414: PUSH
54415: LD_VAR 0 2
54419: PPUSH
54420: CALL_OW 251
54424: ST_TO_ADDR
// if GetTaskList ( unit ) then
54425: LD_VAR 0 1
54429: PPUSH
54430: CALL_OW 437
54434: IFFALSE 54529
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54436: LD_STRING e
54438: PUSH
54439: LD_VAR 0 1
54443: PPUSH
54444: CALL_OW 437
54448: PUSH
54449: LD_INT 1
54451: ARRAY
54452: PUSH
54453: LD_INT 1
54455: ARRAY
54456: EQUAL
54457: PUSH
54458: LD_VAR 0 4
54462: PUSH
54463: LD_VAR 0 1
54467: PPUSH
54468: CALL_OW 437
54472: PUSH
54473: LD_INT 1
54475: ARRAY
54476: PUSH
54477: LD_INT 2
54479: ARRAY
54480: EQUAL
54481: AND
54482: PUSH
54483: LD_VAR 0 5
54487: PUSH
54488: LD_VAR 0 1
54492: PPUSH
54493: CALL_OW 437
54497: PUSH
54498: LD_INT 1
54500: ARRAY
54501: PUSH
54502: LD_INT 3
54504: ARRAY
54505: EQUAL
54506: AND
54507: IFFALSE 54519
// result := true else
54509: LD_ADDR_VAR 0 3
54513: PUSH
54514: LD_INT 1
54516: ST_TO_ADDR
54517: GO 54527
// result := false ;
54519: LD_ADDR_VAR 0 3
54523: PUSH
54524: LD_INT 0
54526: ST_TO_ADDR
// end else
54527: GO 54537
// result := false ;
54529: LD_ADDR_VAR 0 3
54533: PUSH
54534: LD_INT 0
54536: ST_TO_ADDR
// end ;
54537: LD_VAR 0 3
54541: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54542: LD_INT 0
54544: PPUSH
54545: PPUSH
54546: PPUSH
54547: PPUSH
// if not unit or not area then
54548: LD_VAR 0 1
54552: NOT
54553: PUSH
54554: LD_VAR 0 2
54558: NOT
54559: OR
54560: IFFALSE 54564
// exit ;
54562: GO 54729
// tmp := AreaToList ( area , i ) ;
54564: LD_ADDR_VAR 0 6
54568: PUSH
54569: LD_VAR 0 2
54573: PPUSH
54574: LD_VAR 0 5
54578: PPUSH
54579: CALL_OW 517
54583: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54584: LD_ADDR_VAR 0 5
54588: PUSH
54589: DOUBLE
54590: LD_INT 1
54592: DEC
54593: ST_TO_ADDR
54594: LD_VAR 0 6
54598: PUSH
54599: LD_INT 1
54601: ARRAY
54602: PUSH
54603: FOR_TO
54604: IFFALSE 54719
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54606: LD_ADDR_VAR 0 7
54610: PUSH
54611: LD_VAR 0 6
54615: PUSH
54616: LD_INT 1
54618: ARRAY
54619: PUSH
54620: LD_VAR 0 5
54624: ARRAY
54625: PUSH
54626: LD_VAR 0 6
54630: PUSH
54631: LD_INT 2
54633: ARRAY
54634: PUSH
54635: LD_VAR 0 5
54639: ARRAY
54640: PUSH
54641: EMPTY
54642: LIST
54643: LIST
54644: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54645: LD_VAR 0 7
54649: PUSH
54650: LD_INT 1
54652: ARRAY
54653: PPUSH
54654: LD_VAR 0 7
54658: PUSH
54659: LD_INT 2
54661: ARRAY
54662: PPUSH
54663: CALL_OW 428
54667: PUSH
54668: LD_INT 0
54670: EQUAL
54671: IFFALSE 54717
// begin result := true ;
54673: LD_ADDR_VAR 0 4
54677: PUSH
54678: LD_INT 1
54680: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54681: LD_VAR 0 1
54685: PPUSH
54686: LD_VAR 0 7
54690: PUSH
54691: LD_INT 1
54693: ARRAY
54694: PPUSH
54695: LD_VAR 0 7
54699: PUSH
54700: LD_INT 2
54702: ARRAY
54703: PPUSH
54704: LD_VAR 0 3
54708: PPUSH
54709: CALL_OW 48
// exit ;
54713: POP
54714: POP
54715: GO 54729
// end ; end ;
54717: GO 54603
54719: POP
54720: POP
// result := false ;
54721: LD_ADDR_VAR 0 4
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// end ;
54729: LD_VAR 0 4
54733: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54734: LD_INT 0
54736: PPUSH
54737: PPUSH
54738: PPUSH
// if not side or side > 8 then
54739: LD_VAR 0 1
54743: NOT
54744: PUSH
54745: LD_VAR 0 1
54749: PUSH
54750: LD_INT 8
54752: GREATER
54753: OR
54754: IFFALSE 54758
// exit ;
54756: GO 54945
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54758: LD_ADDR_VAR 0 4
54762: PUSH
54763: LD_INT 22
54765: PUSH
54766: LD_VAR 0 1
54770: PUSH
54771: EMPTY
54772: LIST
54773: LIST
54774: PUSH
54775: LD_INT 21
54777: PUSH
54778: LD_INT 3
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: PUSH
54785: EMPTY
54786: LIST
54787: LIST
54788: PPUSH
54789: CALL_OW 69
54793: ST_TO_ADDR
// if not tmp then
54794: LD_VAR 0 4
54798: NOT
54799: IFFALSE 54803
// exit ;
54801: GO 54945
// enable_addtolog := true ;
54803: LD_ADDR_OWVAR 81
54807: PUSH
54808: LD_INT 1
54810: ST_TO_ADDR
// AddToLog ( [ ) ;
54811: LD_STRING [
54813: PPUSH
54814: CALL_OW 561
// for i in tmp do
54818: LD_ADDR_VAR 0 3
54822: PUSH
54823: LD_VAR 0 4
54827: PUSH
54828: FOR_IN
54829: IFFALSE 54936
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54831: LD_STRING [
54833: PUSH
54834: LD_VAR 0 3
54838: PPUSH
54839: CALL_OW 266
54843: STR
54844: PUSH
54845: LD_STRING , 
54847: STR
54848: PUSH
54849: LD_VAR 0 3
54853: PPUSH
54854: CALL_OW 250
54858: STR
54859: PUSH
54860: LD_STRING , 
54862: STR
54863: PUSH
54864: LD_VAR 0 3
54868: PPUSH
54869: CALL_OW 251
54873: STR
54874: PUSH
54875: LD_STRING , 
54877: STR
54878: PUSH
54879: LD_VAR 0 3
54883: PPUSH
54884: CALL_OW 254
54888: STR
54889: PUSH
54890: LD_STRING , 
54892: STR
54893: PUSH
54894: LD_VAR 0 3
54898: PPUSH
54899: LD_INT 1
54901: PPUSH
54902: CALL_OW 268
54906: STR
54907: PUSH
54908: LD_STRING , 
54910: STR
54911: PUSH
54912: LD_VAR 0 3
54916: PPUSH
54917: LD_INT 2
54919: PPUSH
54920: CALL_OW 268
54924: STR
54925: PUSH
54926: LD_STRING ],
54928: STR
54929: PPUSH
54930: CALL_OW 561
// end ;
54934: GO 54828
54936: POP
54937: POP
// AddToLog ( ]; ) ;
54938: LD_STRING ];
54940: PPUSH
54941: CALL_OW 561
// end ;
54945: LD_VAR 0 2
54949: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54950: LD_INT 0
54952: PPUSH
54953: PPUSH
54954: PPUSH
54955: PPUSH
54956: PPUSH
// if not area or not rate or not max then
54957: LD_VAR 0 1
54961: NOT
54962: PUSH
54963: LD_VAR 0 2
54967: NOT
54968: OR
54969: PUSH
54970: LD_VAR 0 4
54974: NOT
54975: OR
54976: IFFALSE 54980
// exit ;
54978: GO 55172
// while 1 do
54980: LD_INT 1
54982: IFFALSE 55172
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54984: LD_ADDR_VAR 0 9
54988: PUSH
54989: LD_VAR 0 1
54993: PPUSH
54994: LD_INT 1
54996: PPUSH
54997: CALL_OW 287
55001: PUSH
55002: LD_INT 10
55004: MUL
55005: ST_TO_ADDR
// r := rate / 10 ;
55006: LD_ADDR_VAR 0 7
55010: PUSH
55011: LD_VAR 0 2
55015: PUSH
55016: LD_INT 10
55018: DIVREAL
55019: ST_TO_ADDR
// time := 1 1$00 ;
55020: LD_ADDR_VAR 0 8
55024: PUSH
55025: LD_INT 2100
55027: ST_TO_ADDR
// if amount < min then
55028: LD_VAR 0 9
55032: PUSH
55033: LD_VAR 0 3
55037: LESS
55038: IFFALSE 55056
// r := r * 2 else
55040: LD_ADDR_VAR 0 7
55044: PUSH
55045: LD_VAR 0 7
55049: PUSH
55050: LD_INT 2
55052: MUL
55053: ST_TO_ADDR
55054: GO 55082
// if amount > max then
55056: LD_VAR 0 9
55060: PUSH
55061: LD_VAR 0 4
55065: GREATER
55066: IFFALSE 55082
// r := r / 2 ;
55068: LD_ADDR_VAR 0 7
55072: PUSH
55073: LD_VAR 0 7
55077: PUSH
55078: LD_INT 2
55080: DIVREAL
55081: ST_TO_ADDR
// time := time / r ;
55082: LD_ADDR_VAR 0 8
55086: PUSH
55087: LD_VAR 0 8
55091: PUSH
55092: LD_VAR 0 7
55096: DIVREAL
55097: ST_TO_ADDR
// if time < 0 then
55098: LD_VAR 0 8
55102: PUSH
55103: LD_INT 0
55105: LESS
55106: IFFALSE 55123
// time := time * - 1 ;
55108: LD_ADDR_VAR 0 8
55112: PUSH
55113: LD_VAR 0 8
55117: PUSH
55118: LD_INT 1
55120: NEG
55121: MUL
55122: ST_TO_ADDR
// wait ( time ) ;
55123: LD_VAR 0 8
55127: PPUSH
55128: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55132: LD_INT 35
55134: PPUSH
55135: LD_INT 875
55137: PPUSH
55138: CALL_OW 12
55142: PPUSH
55143: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55147: LD_INT 1
55149: PPUSH
55150: LD_INT 5
55152: PPUSH
55153: CALL_OW 12
55157: PPUSH
55158: LD_VAR 0 1
55162: PPUSH
55163: LD_INT 1
55165: PPUSH
55166: CALL_OW 55
// end ;
55170: GO 54980
// end ;
55172: LD_VAR 0 5
55176: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55177: LD_INT 0
55179: PPUSH
55180: PPUSH
55181: PPUSH
55182: PPUSH
55183: PPUSH
55184: PPUSH
55185: PPUSH
55186: PPUSH
// if not turrets or not factories then
55187: LD_VAR 0 1
55191: NOT
55192: PUSH
55193: LD_VAR 0 2
55197: NOT
55198: OR
55199: IFFALSE 55203
// exit ;
55201: GO 55510
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55203: LD_ADDR_VAR 0 10
55207: PUSH
55208: LD_INT 5
55210: PUSH
55211: LD_INT 6
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: PUSH
55218: LD_INT 2
55220: PUSH
55221: LD_INT 4
55223: PUSH
55224: EMPTY
55225: LIST
55226: LIST
55227: PUSH
55228: LD_INT 3
55230: PUSH
55231: LD_INT 5
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: PUSH
55238: EMPTY
55239: LIST
55240: LIST
55241: LIST
55242: PUSH
55243: LD_INT 24
55245: PUSH
55246: LD_INT 25
55248: PUSH
55249: EMPTY
55250: LIST
55251: LIST
55252: PUSH
55253: LD_INT 23
55255: PUSH
55256: LD_INT 27
55258: PUSH
55259: EMPTY
55260: LIST
55261: LIST
55262: PUSH
55263: EMPTY
55264: LIST
55265: LIST
55266: PUSH
55267: LD_INT 42
55269: PUSH
55270: LD_INT 43
55272: PUSH
55273: EMPTY
55274: LIST
55275: LIST
55276: PUSH
55277: LD_INT 44
55279: PUSH
55280: LD_INT 46
55282: PUSH
55283: EMPTY
55284: LIST
55285: LIST
55286: PUSH
55287: LD_INT 45
55289: PUSH
55290: LD_INT 47
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: PUSH
55297: EMPTY
55298: LIST
55299: LIST
55300: LIST
55301: PUSH
55302: EMPTY
55303: LIST
55304: LIST
55305: LIST
55306: ST_TO_ADDR
// result := [ ] ;
55307: LD_ADDR_VAR 0 3
55311: PUSH
55312: EMPTY
55313: ST_TO_ADDR
// for i in turrets do
55314: LD_ADDR_VAR 0 4
55318: PUSH
55319: LD_VAR 0 1
55323: PUSH
55324: FOR_IN
55325: IFFALSE 55508
// begin nat := GetNation ( i ) ;
55327: LD_ADDR_VAR 0 7
55331: PUSH
55332: LD_VAR 0 4
55336: PPUSH
55337: CALL_OW 248
55341: ST_TO_ADDR
// weapon := 0 ;
55342: LD_ADDR_VAR 0 8
55346: PUSH
55347: LD_INT 0
55349: ST_TO_ADDR
// if not nat then
55350: LD_VAR 0 7
55354: NOT
55355: IFFALSE 55359
// continue ;
55357: GO 55324
// for j in list [ nat ] do
55359: LD_ADDR_VAR 0 5
55363: PUSH
55364: LD_VAR 0 10
55368: PUSH
55369: LD_VAR 0 7
55373: ARRAY
55374: PUSH
55375: FOR_IN
55376: IFFALSE 55417
// if GetBWeapon ( i ) = j [ 1 ] then
55378: LD_VAR 0 4
55382: PPUSH
55383: CALL_OW 269
55387: PUSH
55388: LD_VAR 0 5
55392: PUSH
55393: LD_INT 1
55395: ARRAY
55396: EQUAL
55397: IFFALSE 55415
// begin weapon := j [ 2 ] ;
55399: LD_ADDR_VAR 0 8
55403: PUSH
55404: LD_VAR 0 5
55408: PUSH
55409: LD_INT 2
55411: ARRAY
55412: ST_TO_ADDR
// break ;
55413: GO 55417
// end ;
55415: GO 55375
55417: POP
55418: POP
// if not weapon then
55419: LD_VAR 0 8
55423: NOT
55424: IFFALSE 55428
// continue ;
55426: GO 55324
// for k in factories do
55428: LD_ADDR_VAR 0 6
55432: PUSH
55433: LD_VAR 0 2
55437: PUSH
55438: FOR_IN
55439: IFFALSE 55504
// begin weapons := AvailableWeaponList ( k ) ;
55441: LD_ADDR_VAR 0 9
55445: PUSH
55446: LD_VAR 0 6
55450: PPUSH
55451: CALL_OW 478
55455: ST_TO_ADDR
// if not weapons then
55456: LD_VAR 0 9
55460: NOT
55461: IFFALSE 55465
// continue ;
55463: GO 55438
// if weapon in weapons then
55465: LD_VAR 0 8
55469: PUSH
55470: LD_VAR 0 9
55474: IN
55475: IFFALSE 55502
// begin result := [ i , weapon ] ;
55477: LD_ADDR_VAR 0 3
55481: PUSH
55482: LD_VAR 0 4
55486: PUSH
55487: LD_VAR 0 8
55491: PUSH
55492: EMPTY
55493: LIST
55494: LIST
55495: ST_TO_ADDR
// exit ;
55496: POP
55497: POP
55498: POP
55499: POP
55500: GO 55510
// end ; end ;
55502: GO 55438
55504: POP
55505: POP
// end ;
55506: GO 55324
55508: POP
55509: POP
// end ; end_of_file
55510: LD_VAR 0 3
55514: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
55515: LD_INT 0
55517: PPUSH
55518: PPUSH
// skirmish := false ;
55519: LD_ADDR_EXP 56
55523: PUSH
55524: LD_INT 0
55526: ST_TO_ADDR
// debug_mc := false ;
55527: LD_ADDR_EXP 57
55531: PUSH
55532: LD_INT 0
55534: ST_TO_ADDR
// mc_bases := [ ] ;
55535: LD_ADDR_EXP 58
55539: PUSH
55540: EMPTY
55541: ST_TO_ADDR
// mc_sides := [ ] ;
55542: LD_ADDR_EXP 84
55546: PUSH
55547: EMPTY
55548: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55549: LD_ADDR_EXP 59
55553: PUSH
55554: EMPTY
55555: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55556: LD_ADDR_EXP 60
55560: PUSH
55561: EMPTY
55562: ST_TO_ADDR
// mc_need_heal := [ ] ;
55563: LD_ADDR_EXP 61
55567: PUSH
55568: EMPTY
55569: ST_TO_ADDR
// mc_healers := [ ] ;
55570: LD_ADDR_EXP 62
55574: PUSH
55575: EMPTY
55576: ST_TO_ADDR
// mc_build_list := [ ] ;
55577: LD_ADDR_EXP 63
55581: PUSH
55582: EMPTY
55583: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55584: LD_ADDR_EXP 90
55588: PUSH
55589: EMPTY
55590: ST_TO_ADDR
// mc_builders := [ ] ;
55591: LD_ADDR_EXP 64
55595: PUSH
55596: EMPTY
55597: ST_TO_ADDR
// mc_construct_list := [ ] ;
55598: LD_ADDR_EXP 65
55602: PUSH
55603: EMPTY
55604: ST_TO_ADDR
// mc_turret_list := [ ] ;
55605: LD_ADDR_EXP 66
55609: PUSH
55610: EMPTY
55611: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55612: LD_ADDR_EXP 67
55616: PUSH
55617: EMPTY
55618: ST_TO_ADDR
// mc_miners := [ ] ;
55619: LD_ADDR_EXP 72
55623: PUSH
55624: EMPTY
55625: ST_TO_ADDR
// mc_mines := [ ] ;
55626: LD_ADDR_EXP 71
55630: PUSH
55631: EMPTY
55632: ST_TO_ADDR
// mc_minefields := [ ] ;
55633: LD_ADDR_EXP 73
55637: PUSH
55638: EMPTY
55639: ST_TO_ADDR
// mc_crates := [ ] ;
55640: LD_ADDR_EXP 74
55644: PUSH
55645: EMPTY
55646: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55647: LD_ADDR_EXP 75
55651: PUSH
55652: EMPTY
55653: ST_TO_ADDR
// mc_crates_area := [ ] ;
55654: LD_ADDR_EXP 76
55658: PUSH
55659: EMPTY
55660: ST_TO_ADDR
// mc_vehicles := [ ] ;
55661: LD_ADDR_EXP 77
55665: PUSH
55666: EMPTY
55667: ST_TO_ADDR
// mc_attack := [ ] ;
55668: LD_ADDR_EXP 78
55672: PUSH
55673: EMPTY
55674: ST_TO_ADDR
// mc_produce := [ ] ;
55675: LD_ADDR_EXP 79
55679: PUSH
55680: EMPTY
55681: ST_TO_ADDR
// mc_defender := [ ] ;
55682: LD_ADDR_EXP 80
55686: PUSH
55687: EMPTY
55688: ST_TO_ADDR
// mc_parking := [ ] ;
55689: LD_ADDR_EXP 82
55693: PUSH
55694: EMPTY
55695: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55696: LD_ADDR_EXP 68
55700: PUSH
55701: EMPTY
55702: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55703: LD_ADDR_EXP 70
55707: PUSH
55708: EMPTY
55709: ST_TO_ADDR
// mc_scan := [ ] ;
55710: LD_ADDR_EXP 81
55714: PUSH
55715: EMPTY
55716: ST_TO_ADDR
// mc_scan_area := [ ] ;
55717: LD_ADDR_EXP 83
55721: PUSH
55722: EMPTY
55723: ST_TO_ADDR
// mc_tech := [ ] ;
55724: LD_ADDR_EXP 85
55728: PUSH
55729: EMPTY
55730: ST_TO_ADDR
// mc_class := [ ] ;
55731: LD_ADDR_EXP 99
55735: PUSH
55736: EMPTY
55737: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55738: LD_ADDR_EXP 100
55742: PUSH
55743: EMPTY
55744: ST_TO_ADDR
// end ;
55745: LD_VAR 0 1
55749: RET
// export function MC_Kill ( base ) ; begin
55750: LD_INT 0
55752: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55753: LD_ADDR_EXP 58
55757: PUSH
55758: LD_EXP 58
55762: PPUSH
55763: LD_VAR 0 1
55767: PPUSH
55768: EMPTY
55769: PPUSH
55770: CALL_OW 1
55774: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55775: LD_ADDR_EXP 59
55779: PUSH
55780: LD_EXP 59
55784: PPUSH
55785: LD_VAR 0 1
55789: PPUSH
55790: EMPTY
55791: PPUSH
55792: CALL_OW 1
55796: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55797: LD_ADDR_EXP 60
55801: PUSH
55802: LD_EXP 60
55806: PPUSH
55807: LD_VAR 0 1
55811: PPUSH
55812: EMPTY
55813: PPUSH
55814: CALL_OW 1
55818: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55819: LD_ADDR_EXP 61
55823: PUSH
55824: LD_EXP 61
55828: PPUSH
55829: LD_VAR 0 1
55833: PPUSH
55834: EMPTY
55835: PPUSH
55836: CALL_OW 1
55840: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55841: LD_ADDR_EXP 62
55845: PUSH
55846: LD_EXP 62
55850: PPUSH
55851: LD_VAR 0 1
55855: PPUSH
55856: EMPTY
55857: PPUSH
55858: CALL_OW 1
55862: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55863: LD_ADDR_EXP 63
55867: PUSH
55868: LD_EXP 63
55872: PPUSH
55873: LD_VAR 0 1
55877: PPUSH
55878: EMPTY
55879: PPUSH
55880: CALL_OW 1
55884: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55885: LD_ADDR_EXP 64
55889: PUSH
55890: LD_EXP 64
55894: PPUSH
55895: LD_VAR 0 1
55899: PPUSH
55900: EMPTY
55901: PPUSH
55902: CALL_OW 1
55906: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55907: LD_ADDR_EXP 65
55911: PUSH
55912: LD_EXP 65
55916: PPUSH
55917: LD_VAR 0 1
55921: PPUSH
55922: EMPTY
55923: PPUSH
55924: CALL_OW 1
55928: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55929: LD_ADDR_EXP 66
55933: PUSH
55934: LD_EXP 66
55938: PPUSH
55939: LD_VAR 0 1
55943: PPUSH
55944: EMPTY
55945: PPUSH
55946: CALL_OW 1
55950: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55951: LD_ADDR_EXP 67
55955: PUSH
55956: LD_EXP 67
55960: PPUSH
55961: LD_VAR 0 1
55965: PPUSH
55966: EMPTY
55967: PPUSH
55968: CALL_OW 1
55972: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55973: LD_ADDR_EXP 68
55977: PUSH
55978: LD_EXP 68
55982: PPUSH
55983: LD_VAR 0 1
55987: PPUSH
55988: EMPTY
55989: PPUSH
55990: CALL_OW 1
55994: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55995: LD_ADDR_EXP 69
55999: PUSH
56000: LD_EXP 69
56004: PPUSH
56005: LD_VAR 0 1
56009: PPUSH
56010: LD_INT 0
56012: PPUSH
56013: CALL_OW 1
56017: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56018: LD_ADDR_EXP 70
56022: PUSH
56023: LD_EXP 70
56027: PPUSH
56028: LD_VAR 0 1
56032: PPUSH
56033: EMPTY
56034: PPUSH
56035: CALL_OW 1
56039: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56040: LD_ADDR_EXP 71
56044: PUSH
56045: LD_EXP 71
56049: PPUSH
56050: LD_VAR 0 1
56054: PPUSH
56055: EMPTY
56056: PPUSH
56057: CALL_OW 1
56061: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56062: LD_ADDR_EXP 72
56066: PUSH
56067: LD_EXP 72
56071: PPUSH
56072: LD_VAR 0 1
56076: PPUSH
56077: EMPTY
56078: PPUSH
56079: CALL_OW 1
56083: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56084: LD_ADDR_EXP 73
56088: PUSH
56089: LD_EXP 73
56093: PPUSH
56094: LD_VAR 0 1
56098: PPUSH
56099: EMPTY
56100: PPUSH
56101: CALL_OW 1
56105: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56106: LD_ADDR_EXP 74
56110: PUSH
56111: LD_EXP 74
56115: PPUSH
56116: LD_VAR 0 1
56120: PPUSH
56121: EMPTY
56122: PPUSH
56123: CALL_OW 1
56127: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56128: LD_ADDR_EXP 75
56132: PUSH
56133: LD_EXP 75
56137: PPUSH
56138: LD_VAR 0 1
56142: PPUSH
56143: EMPTY
56144: PPUSH
56145: CALL_OW 1
56149: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56150: LD_ADDR_EXP 76
56154: PUSH
56155: LD_EXP 76
56159: PPUSH
56160: LD_VAR 0 1
56164: PPUSH
56165: EMPTY
56166: PPUSH
56167: CALL_OW 1
56171: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56172: LD_ADDR_EXP 77
56176: PUSH
56177: LD_EXP 77
56181: PPUSH
56182: LD_VAR 0 1
56186: PPUSH
56187: EMPTY
56188: PPUSH
56189: CALL_OW 1
56193: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56194: LD_ADDR_EXP 78
56198: PUSH
56199: LD_EXP 78
56203: PPUSH
56204: LD_VAR 0 1
56208: PPUSH
56209: EMPTY
56210: PPUSH
56211: CALL_OW 1
56215: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56216: LD_ADDR_EXP 79
56220: PUSH
56221: LD_EXP 79
56225: PPUSH
56226: LD_VAR 0 1
56230: PPUSH
56231: EMPTY
56232: PPUSH
56233: CALL_OW 1
56237: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56238: LD_ADDR_EXP 80
56242: PUSH
56243: LD_EXP 80
56247: PPUSH
56248: LD_VAR 0 1
56252: PPUSH
56253: EMPTY
56254: PPUSH
56255: CALL_OW 1
56259: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56260: LD_ADDR_EXP 81
56264: PUSH
56265: LD_EXP 81
56269: PPUSH
56270: LD_VAR 0 1
56274: PPUSH
56275: EMPTY
56276: PPUSH
56277: CALL_OW 1
56281: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56282: LD_ADDR_EXP 82
56286: PUSH
56287: LD_EXP 82
56291: PPUSH
56292: LD_VAR 0 1
56296: PPUSH
56297: EMPTY
56298: PPUSH
56299: CALL_OW 1
56303: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56304: LD_ADDR_EXP 83
56308: PUSH
56309: LD_EXP 83
56313: PPUSH
56314: LD_VAR 0 1
56318: PPUSH
56319: EMPTY
56320: PPUSH
56321: CALL_OW 1
56325: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56326: LD_ADDR_EXP 85
56330: PUSH
56331: LD_EXP 85
56335: PPUSH
56336: LD_VAR 0 1
56340: PPUSH
56341: EMPTY
56342: PPUSH
56343: CALL_OW 1
56347: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56348: LD_ADDR_EXP 87
56352: PUSH
56353: LD_EXP 87
56357: PPUSH
56358: LD_VAR 0 1
56362: PPUSH
56363: EMPTY
56364: PPUSH
56365: CALL_OW 1
56369: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56370: LD_ADDR_EXP 88
56374: PUSH
56375: LD_EXP 88
56379: PPUSH
56380: LD_VAR 0 1
56384: PPUSH
56385: EMPTY
56386: PPUSH
56387: CALL_OW 1
56391: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56392: LD_ADDR_EXP 89
56396: PUSH
56397: LD_EXP 89
56401: PPUSH
56402: LD_VAR 0 1
56406: PPUSH
56407: EMPTY
56408: PPUSH
56409: CALL_OW 1
56413: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56414: LD_ADDR_EXP 90
56418: PUSH
56419: LD_EXP 90
56423: PPUSH
56424: LD_VAR 0 1
56428: PPUSH
56429: EMPTY
56430: PPUSH
56431: CALL_OW 1
56435: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56436: LD_ADDR_EXP 91
56440: PUSH
56441: LD_EXP 91
56445: PPUSH
56446: LD_VAR 0 1
56450: PPUSH
56451: EMPTY
56452: PPUSH
56453: CALL_OW 1
56457: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56458: LD_ADDR_EXP 92
56462: PUSH
56463: LD_EXP 92
56467: PPUSH
56468: LD_VAR 0 1
56472: PPUSH
56473: EMPTY
56474: PPUSH
56475: CALL_OW 1
56479: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56480: LD_ADDR_EXP 93
56484: PUSH
56485: LD_EXP 93
56489: PPUSH
56490: LD_VAR 0 1
56494: PPUSH
56495: EMPTY
56496: PPUSH
56497: CALL_OW 1
56501: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56502: LD_ADDR_EXP 94
56506: PUSH
56507: LD_EXP 94
56511: PPUSH
56512: LD_VAR 0 1
56516: PPUSH
56517: EMPTY
56518: PPUSH
56519: CALL_OW 1
56523: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56524: LD_ADDR_EXP 95
56528: PUSH
56529: LD_EXP 95
56533: PPUSH
56534: LD_VAR 0 1
56538: PPUSH
56539: EMPTY
56540: PPUSH
56541: CALL_OW 1
56545: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56546: LD_ADDR_EXP 96
56550: PUSH
56551: LD_EXP 96
56555: PPUSH
56556: LD_VAR 0 1
56560: PPUSH
56561: EMPTY
56562: PPUSH
56563: CALL_OW 1
56567: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56568: LD_ADDR_EXP 97
56572: PUSH
56573: LD_EXP 97
56577: PPUSH
56578: LD_VAR 0 1
56582: PPUSH
56583: EMPTY
56584: PPUSH
56585: CALL_OW 1
56589: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56590: LD_ADDR_EXP 98
56594: PUSH
56595: LD_EXP 98
56599: PPUSH
56600: LD_VAR 0 1
56604: PPUSH
56605: EMPTY
56606: PPUSH
56607: CALL_OW 1
56611: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56612: LD_ADDR_EXP 99
56616: PUSH
56617: LD_EXP 99
56621: PPUSH
56622: LD_VAR 0 1
56626: PPUSH
56627: EMPTY
56628: PPUSH
56629: CALL_OW 1
56633: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56634: LD_ADDR_EXP 100
56638: PUSH
56639: LD_EXP 100
56643: PPUSH
56644: LD_VAR 0 1
56648: PPUSH
56649: LD_INT 0
56651: PPUSH
56652: CALL_OW 1
56656: ST_TO_ADDR
// end ;
56657: LD_VAR 0 2
56661: RET
// export function MC_Start ( ) ; var i ; begin
56662: LD_INT 0
56664: PPUSH
56665: PPUSH
// for i = 1 to mc_bases do
56666: LD_ADDR_VAR 0 2
56670: PUSH
56671: DOUBLE
56672: LD_INT 1
56674: DEC
56675: ST_TO_ADDR
56676: LD_EXP 58
56680: PUSH
56681: FOR_TO
56682: IFFALSE 57759
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56684: LD_ADDR_EXP 58
56688: PUSH
56689: LD_EXP 58
56693: PPUSH
56694: LD_VAR 0 2
56698: PPUSH
56699: LD_EXP 58
56703: PUSH
56704: LD_VAR 0 2
56708: ARRAY
56709: PUSH
56710: LD_INT 0
56712: DIFF
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56719: LD_ADDR_EXP 59
56723: PUSH
56724: LD_EXP 59
56728: PPUSH
56729: LD_VAR 0 2
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56741: LD_ADDR_EXP 60
56745: PUSH
56746: LD_EXP 60
56750: PPUSH
56751: LD_VAR 0 2
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56763: LD_ADDR_EXP 61
56767: PUSH
56768: LD_EXP 61
56772: PPUSH
56773: LD_VAR 0 2
56777: PPUSH
56778: EMPTY
56779: PPUSH
56780: CALL_OW 1
56784: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56785: LD_ADDR_EXP 62
56789: PUSH
56790: LD_EXP 62
56794: PPUSH
56795: LD_VAR 0 2
56799: PPUSH
56800: EMPTY
56801: PUSH
56802: EMPTY
56803: PUSH
56804: EMPTY
56805: LIST
56806: LIST
56807: PPUSH
56808: CALL_OW 1
56812: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56813: LD_ADDR_EXP 63
56817: PUSH
56818: LD_EXP 63
56822: PPUSH
56823: LD_VAR 0 2
56827: PPUSH
56828: EMPTY
56829: PPUSH
56830: CALL_OW 1
56834: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56835: LD_ADDR_EXP 90
56839: PUSH
56840: LD_EXP 90
56844: PPUSH
56845: LD_VAR 0 2
56849: PPUSH
56850: EMPTY
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56857: LD_ADDR_EXP 64
56861: PUSH
56862: LD_EXP 64
56866: PPUSH
56867: LD_VAR 0 2
56871: PPUSH
56872: EMPTY
56873: PPUSH
56874: CALL_OW 1
56878: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56879: LD_ADDR_EXP 65
56883: PUSH
56884: LD_EXP 65
56888: PPUSH
56889: LD_VAR 0 2
56893: PPUSH
56894: EMPTY
56895: PPUSH
56896: CALL_OW 1
56900: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56901: LD_ADDR_EXP 66
56905: PUSH
56906: LD_EXP 66
56910: PPUSH
56911: LD_VAR 0 2
56915: PPUSH
56916: LD_EXP 58
56920: PUSH
56921: LD_VAR 0 2
56925: ARRAY
56926: PPUSH
56927: LD_INT 2
56929: PUSH
56930: LD_INT 30
56932: PUSH
56933: LD_INT 32
56935: PUSH
56936: EMPTY
56937: LIST
56938: LIST
56939: PUSH
56940: LD_INT 30
56942: PUSH
56943: LD_INT 33
56945: PUSH
56946: EMPTY
56947: LIST
56948: LIST
56949: PUSH
56950: EMPTY
56951: LIST
56952: LIST
56953: LIST
56954: PPUSH
56955: CALL_OW 72
56959: PPUSH
56960: CALL_OW 1
56964: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56965: LD_ADDR_EXP 67
56969: PUSH
56970: LD_EXP 67
56974: PPUSH
56975: LD_VAR 0 2
56979: PPUSH
56980: LD_EXP 58
56984: PUSH
56985: LD_VAR 0 2
56989: ARRAY
56990: PPUSH
56991: LD_INT 2
56993: PUSH
56994: LD_INT 30
56996: PUSH
56997: LD_INT 32
56999: PUSH
57000: EMPTY
57001: LIST
57002: LIST
57003: PUSH
57004: LD_INT 30
57006: PUSH
57007: LD_INT 31
57009: PUSH
57010: EMPTY
57011: LIST
57012: LIST
57013: PUSH
57014: EMPTY
57015: LIST
57016: LIST
57017: LIST
57018: PUSH
57019: LD_INT 58
57021: PUSH
57022: EMPTY
57023: LIST
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: PPUSH
57029: CALL_OW 72
57033: PPUSH
57034: CALL_OW 1
57038: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57039: LD_ADDR_EXP 68
57043: PUSH
57044: LD_EXP 68
57048: PPUSH
57049: LD_VAR 0 2
57053: PPUSH
57054: EMPTY
57055: PPUSH
57056: CALL_OW 1
57060: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57061: LD_ADDR_EXP 72
57065: PUSH
57066: LD_EXP 72
57070: PPUSH
57071: LD_VAR 0 2
57075: PPUSH
57076: EMPTY
57077: PPUSH
57078: CALL_OW 1
57082: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57083: LD_ADDR_EXP 71
57087: PUSH
57088: LD_EXP 71
57092: PPUSH
57093: LD_VAR 0 2
57097: PPUSH
57098: EMPTY
57099: PPUSH
57100: CALL_OW 1
57104: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57105: LD_ADDR_EXP 73
57109: PUSH
57110: LD_EXP 73
57114: PPUSH
57115: LD_VAR 0 2
57119: PPUSH
57120: EMPTY
57121: PPUSH
57122: CALL_OW 1
57126: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57127: LD_ADDR_EXP 74
57131: PUSH
57132: LD_EXP 74
57136: PPUSH
57137: LD_VAR 0 2
57141: PPUSH
57142: EMPTY
57143: PPUSH
57144: CALL_OW 1
57148: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57149: LD_ADDR_EXP 75
57153: PUSH
57154: LD_EXP 75
57158: PPUSH
57159: LD_VAR 0 2
57163: PPUSH
57164: EMPTY
57165: PPUSH
57166: CALL_OW 1
57170: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57171: LD_ADDR_EXP 76
57175: PUSH
57176: LD_EXP 76
57180: PPUSH
57181: LD_VAR 0 2
57185: PPUSH
57186: EMPTY
57187: PPUSH
57188: CALL_OW 1
57192: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57193: LD_ADDR_EXP 77
57197: PUSH
57198: LD_EXP 77
57202: PPUSH
57203: LD_VAR 0 2
57207: PPUSH
57208: EMPTY
57209: PPUSH
57210: CALL_OW 1
57214: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57215: LD_ADDR_EXP 78
57219: PUSH
57220: LD_EXP 78
57224: PPUSH
57225: LD_VAR 0 2
57229: PPUSH
57230: EMPTY
57231: PPUSH
57232: CALL_OW 1
57236: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57237: LD_ADDR_EXP 79
57241: PUSH
57242: LD_EXP 79
57246: PPUSH
57247: LD_VAR 0 2
57251: PPUSH
57252: EMPTY
57253: PPUSH
57254: CALL_OW 1
57258: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57259: LD_ADDR_EXP 80
57263: PUSH
57264: LD_EXP 80
57268: PPUSH
57269: LD_VAR 0 2
57273: PPUSH
57274: EMPTY
57275: PPUSH
57276: CALL_OW 1
57280: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57281: LD_ADDR_EXP 69
57285: PUSH
57286: LD_EXP 69
57290: PPUSH
57291: LD_VAR 0 2
57295: PPUSH
57296: LD_INT 0
57298: PPUSH
57299: CALL_OW 1
57303: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57304: LD_ADDR_EXP 82
57308: PUSH
57309: LD_EXP 82
57313: PPUSH
57314: LD_VAR 0 2
57318: PPUSH
57319: LD_INT 0
57321: PPUSH
57322: CALL_OW 1
57326: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57327: LD_ADDR_EXP 70
57331: PUSH
57332: LD_EXP 70
57336: PPUSH
57337: LD_VAR 0 2
57341: PPUSH
57342: EMPTY
57343: PPUSH
57344: CALL_OW 1
57348: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57349: LD_ADDR_EXP 81
57353: PUSH
57354: LD_EXP 81
57358: PPUSH
57359: LD_VAR 0 2
57363: PPUSH
57364: LD_INT 0
57366: PPUSH
57367: CALL_OW 1
57371: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57372: LD_ADDR_EXP 83
57376: PUSH
57377: LD_EXP 83
57381: PPUSH
57382: LD_VAR 0 2
57386: PPUSH
57387: EMPTY
57388: PPUSH
57389: CALL_OW 1
57393: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57394: LD_ADDR_EXP 86
57398: PUSH
57399: LD_EXP 86
57403: PPUSH
57404: LD_VAR 0 2
57408: PPUSH
57409: LD_INT 0
57411: PPUSH
57412: CALL_OW 1
57416: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57417: LD_ADDR_EXP 87
57421: PUSH
57422: LD_EXP 87
57426: PPUSH
57427: LD_VAR 0 2
57431: PPUSH
57432: EMPTY
57433: PPUSH
57434: CALL_OW 1
57438: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57439: LD_ADDR_EXP 88
57443: PUSH
57444: LD_EXP 88
57448: PPUSH
57449: LD_VAR 0 2
57453: PPUSH
57454: EMPTY
57455: PPUSH
57456: CALL_OW 1
57460: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57461: LD_ADDR_EXP 89
57465: PUSH
57466: LD_EXP 89
57470: PPUSH
57471: LD_VAR 0 2
57475: PPUSH
57476: EMPTY
57477: PPUSH
57478: CALL_OW 1
57482: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57483: LD_ADDR_EXP 91
57487: PUSH
57488: LD_EXP 91
57492: PPUSH
57493: LD_VAR 0 2
57497: PPUSH
57498: LD_EXP 58
57502: PUSH
57503: LD_VAR 0 2
57507: ARRAY
57508: PPUSH
57509: LD_INT 2
57511: PUSH
57512: LD_INT 30
57514: PUSH
57515: LD_INT 6
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: PUSH
57522: LD_INT 30
57524: PUSH
57525: LD_INT 7
57527: PUSH
57528: EMPTY
57529: LIST
57530: LIST
57531: PUSH
57532: LD_INT 30
57534: PUSH
57535: LD_INT 8
57537: PUSH
57538: EMPTY
57539: LIST
57540: LIST
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: LIST
57546: LIST
57547: PPUSH
57548: CALL_OW 72
57552: PPUSH
57553: CALL_OW 1
57557: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57558: LD_ADDR_EXP 92
57562: PUSH
57563: LD_EXP 92
57567: PPUSH
57568: LD_VAR 0 2
57572: PPUSH
57573: EMPTY
57574: PPUSH
57575: CALL_OW 1
57579: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57580: LD_ADDR_EXP 93
57584: PUSH
57585: LD_EXP 93
57589: PPUSH
57590: LD_VAR 0 2
57594: PPUSH
57595: EMPTY
57596: PPUSH
57597: CALL_OW 1
57601: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57602: LD_ADDR_EXP 94
57606: PUSH
57607: LD_EXP 94
57611: PPUSH
57612: LD_VAR 0 2
57616: PPUSH
57617: EMPTY
57618: PPUSH
57619: CALL_OW 1
57623: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57624: LD_ADDR_EXP 95
57628: PUSH
57629: LD_EXP 95
57633: PPUSH
57634: LD_VAR 0 2
57638: PPUSH
57639: EMPTY
57640: PPUSH
57641: CALL_OW 1
57645: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57646: LD_ADDR_EXP 96
57650: PUSH
57651: LD_EXP 96
57655: PPUSH
57656: LD_VAR 0 2
57660: PPUSH
57661: EMPTY
57662: PPUSH
57663: CALL_OW 1
57667: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57668: LD_ADDR_EXP 97
57672: PUSH
57673: LD_EXP 97
57677: PPUSH
57678: LD_VAR 0 2
57682: PPUSH
57683: EMPTY
57684: PPUSH
57685: CALL_OW 1
57689: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57690: LD_ADDR_EXP 98
57694: PUSH
57695: LD_EXP 98
57699: PPUSH
57700: LD_VAR 0 2
57704: PPUSH
57705: EMPTY
57706: PPUSH
57707: CALL_OW 1
57711: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57712: LD_ADDR_EXP 99
57716: PUSH
57717: LD_EXP 99
57721: PPUSH
57722: LD_VAR 0 2
57726: PPUSH
57727: EMPTY
57728: PPUSH
57729: CALL_OW 1
57733: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57734: LD_ADDR_EXP 100
57738: PUSH
57739: LD_EXP 100
57743: PPUSH
57744: LD_VAR 0 2
57748: PPUSH
57749: LD_INT 0
57751: PPUSH
57752: CALL_OW 1
57756: ST_TO_ADDR
// end ;
57757: GO 56681
57759: POP
57760: POP
// MC_InitSides ( ) ;
57761: CALL 58047 0 0
// MC_InitResearch ( ) ;
57765: CALL 57786 0 0
// CustomInitMacro ( ) ;
57769: CALL 174 0 0
// skirmish := true ;
57773: LD_ADDR_EXP 56
57777: PUSH
57778: LD_INT 1
57780: ST_TO_ADDR
// end ;
57781: LD_VAR 0 1
57785: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57786: LD_INT 0
57788: PPUSH
57789: PPUSH
57790: PPUSH
57791: PPUSH
57792: PPUSH
57793: PPUSH
// if not mc_bases then
57794: LD_EXP 58
57798: NOT
57799: IFFALSE 57803
// exit ;
57801: GO 58042
// for i = 1 to 8 do
57803: LD_ADDR_VAR 0 2
57807: PUSH
57808: DOUBLE
57809: LD_INT 1
57811: DEC
57812: ST_TO_ADDR
57813: LD_INT 8
57815: PUSH
57816: FOR_TO
57817: IFFALSE 57843
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57819: LD_ADDR_EXP 85
57823: PUSH
57824: LD_EXP 85
57828: PPUSH
57829: LD_VAR 0 2
57833: PPUSH
57834: EMPTY
57835: PPUSH
57836: CALL_OW 1
57840: ST_TO_ADDR
57841: GO 57816
57843: POP
57844: POP
// tmp := [ ] ;
57845: LD_ADDR_VAR 0 5
57849: PUSH
57850: EMPTY
57851: ST_TO_ADDR
// for i = 1 to mc_sides do
57852: LD_ADDR_VAR 0 2
57856: PUSH
57857: DOUBLE
57858: LD_INT 1
57860: DEC
57861: ST_TO_ADDR
57862: LD_EXP 84
57866: PUSH
57867: FOR_TO
57868: IFFALSE 57926
// if not mc_sides [ i ] in tmp then
57870: LD_EXP 84
57874: PUSH
57875: LD_VAR 0 2
57879: ARRAY
57880: PUSH
57881: LD_VAR 0 5
57885: IN
57886: NOT
57887: IFFALSE 57924
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57889: LD_ADDR_VAR 0 5
57893: PUSH
57894: LD_VAR 0 5
57898: PPUSH
57899: LD_VAR 0 5
57903: PUSH
57904: LD_INT 1
57906: PLUS
57907: PPUSH
57908: LD_EXP 84
57912: PUSH
57913: LD_VAR 0 2
57917: ARRAY
57918: PPUSH
57919: CALL_OW 2
57923: ST_TO_ADDR
57924: GO 57867
57926: POP
57927: POP
// if not tmp then
57928: LD_VAR 0 5
57932: NOT
57933: IFFALSE 57937
// exit ;
57935: GO 58042
// for j in tmp do
57937: LD_ADDR_VAR 0 3
57941: PUSH
57942: LD_VAR 0 5
57946: PUSH
57947: FOR_IN
57948: IFFALSE 58040
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57950: LD_ADDR_VAR 0 6
57954: PUSH
57955: LD_INT 22
57957: PUSH
57958: LD_VAR 0 3
57962: PUSH
57963: EMPTY
57964: LIST
57965: LIST
57966: PPUSH
57967: CALL_OW 69
57971: ST_TO_ADDR
// if not un then
57972: LD_VAR 0 6
57976: NOT
57977: IFFALSE 57981
// continue ;
57979: GO 57947
// nation := GetNation ( un [ 1 ] ) ;
57981: LD_ADDR_VAR 0 4
57985: PUSH
57986: LD_VAR 0 6
57990: PUSH
57991: LD_INT 1
57993: ARRAY
57994: PPUSH
57995: CALL_OW 248
57999: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58000: LD_ADDR_EXP 85
58004: PUSH
58005: LD_EXP 85
58009: PPUSH
58010: LD_VAR 0 3
58014: PPUSH
58015: LD_VAR 0 3
58019: PPUSH
58020: LD_VAR 0 4
58024: PPUSH
58025: LD_INT 1
58027: PPUSH
58028: CALL 13558 0 3
58032: PPUSH
58033: CALL_OW 1
58037: ST_TO_ADDR
// end ;
58038: GO 57947
58040: POP
58041: POP
// end ;
58042: LD_VAR 0 1
58046: RET
// export function MC_InitSides ( ) ; var i ; begin
58047: LD_INT 0
58049: PPUSH
58050: PPUSH
// if not mc_bases then
58051: LD_EXP 58
58055: NOT
58056: IFFALSE 58060
// exit ;
58058: GO 58134
// for i = 1 to mc_bases do
58060: LD_ADDR_VAR 0 2
58064: PUSH
58065: DOUBLE
58066: LD_INT 1
58068: DEC
58069: ST_TO_ADDR
58070: LD_EXP 58
58074: PUSH
58075: FOR_TO
58076: IFFALSE 58132
// if mc_bases [ i ] then
58078: LD_EXP 58
58082: PUSH
58083: LD_VAR 0 2
58087: ARRAY
58088: IFFALSE 58130
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58090: LD_ADDR_EXP 84
58094: PUSH
58095: LD_EXP 84
58099: PPUSH
58100: LD_VAR 0 2
58104: PPUSH
58105: LD_EXP 58
58109: PUSH
58110: LD_VAR 0 2
58114: ARRAY
58115: PUSH
58116: LD_INT 1
58118: ARRAY
58119: PPUSH
58120: CALL_OW 255
58124: PPUSH
58125: CALL_OW 1
58129: ST_TO_ADDR
58130: GO 58075
58132: POP
58133: POP
// end ;
58134: LD_VAR 0 1
58138: RET
// every 0 0$01 trigger skirmish do
58139: LD_EXP 56
58143: IFFALSE 58297
58145: GO 58147
58147: DISABLE
// begin enable ;
58148: ENABLE
// MC_CheckBuildings ( ) ;
58149: CALL 62430 0 0
// MC_CheckPeopleLife ( ) ;
58153: CALL 62555 0 0
// RaiseSailEvent ( 100 ) ;
58157: LD_INT 100
58159: PPUSH
58160: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58164: LD_INT 103
58166: PPUSH
58167: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58171: LD_INT 104
58173: PPUSH
58174: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58178: LD_INT 105
58180: PPUSH
58181: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58185: LD_INT 106
58187: PPUSH
58188: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58192: LD_INT 107
58194: PPUSH
58195: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58199: LD_INT 108
58201: PPUSH
58202: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58206: LD_INT 109
58208: PPUSH
58209: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58213: LD_INT 110
58215: PPUSH
58216: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58220: LD_INT 111
58222: PPUSH
58223: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58227: LD_INT 112
58229: PPUSH
58230: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58234: LD_INT 113
58236: PPUSH
58237: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58241: LD_INT 120
58243: PPUSH
58244: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58248: LD_INT 121
58250: PPUSH
58251: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58255: LD_INT 122
58257: PPUSH
58258: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58262: LD_INT 123
58264: PPUSH
58265: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58269: LD_INT 124
58271: PPUSH
58272: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58276: LD_INT 125
58278: PPUSH
58279: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58283: LD_INT 126
58285: PPUSH
58286: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58290: LD_INT 200
58292: PPUSH
58293: CALL_OW 427
// end ;
58297: END
// on SailEvent ( event ) do begin if event = 100 then
58298: LD_VAR 0 1
58302: PUSH
58303: LD_INT 100
58305: EQUAL
58306: IFFALSE 58312
// MC_ClassManager ( ) ;
58308: CALL 58704 0 0
// if event = 101 then
58312: LD_VAR 0 1
58316: PUSH
58317: LD_INT 101
58319: EQUAL
58320: IFFALSE 58326
// MC_RepairBuildings ( ) ;
58322: CALL 63113 0 0
// if event = 102 then
58326: LD_VAR 0 1
58330: PUSH
58331: LD_INT 102
58333: EQUAL
58334: IFFALSE 58340
// MC_Heal ( ) ;
58336: CALL 63519 0 0
// if event = 103 then
58340: LD_VAR 0 1
58344: PUSH
58345: LD_INT 103
58347: EQUAL
58348: IFFALSE 58354
// MC_Build ( ) ;
58350: CALL 63941 0 0
// if event = 104 then
58354: LD_VAR 0 1
58358: PUSH
58359: LD_INT 104
58361: EQUAL
58362: IFFALSE 58368
// MC_TurretWeapon ( ) ;
58364: CALL 65554 0 0
// if event = 105 then
58368: LD_VAR 0 1
58372: PUSH
58373: LD_INT 105
58375: EQUAL
58376: IFFALSE 58382
// MC_BuildUpgrade ( ) ;
58378: CALL 65105 0 0
// if event = 106 then
58382: LD_VAR 0 1
58386: PUSH
58387: LD_INT 106
58389: EQUAL
58390: IFFALSE 58396
// MC_PlantMines ( ) ;
58392: CALL 65973 0 0
// if event = 107 then
58396: LD_VAR 0 1
58400: PUSH
58401: LD_INT 107
58403: EQUAL
58404: IFFALSE 58410
// MC_CollectCrates ( ) ;
58406: CALL 67007 0 0
// if event = 108 then
58410: LD_VAR 0 1
58414: PUSH
58415: LD_INT 108
58417: EQUAL
58418: IFFALSE 58424
// MC_LinkRemoteControl ( ) ;
58420: CALL 68764 0 0
// if event = 109 then
58424: LD_VAR 0 1
58428: PUSH
58429: LD_INT 109
58431: EQUAL
58432: IFFALSE 58438
// MC_ProduceVehicle ( ) ;
58434: CALL 68945 0 0
// if event = 110 then
58438: LD_VAR 0 1
58442: PUSH
58443: LD_INT 110
58445: EQUAL
58446: IFFALSE 58452
// MC_SendAttack ( ) ;
58448: CALL 69426 0 0
// if event = 111 then
58452: LD_VAR 0 1
58456: PUSH
58457: LD_INT 111
58459: EQUAL
58460: IFFALSE 58466
// MC_Defend ( ) ;
58462: CALL 69534 0 0
// if event = 112 then
58466: LD_VAR 0 1
58470: PUSH
58471: LD_INT 112
58473: EQUAL
58474: IFFALSE 58480
// MC_Research ( ) ;
58476: CALL 70161 0 0
// if event = 113 then
58480: LD_VAR 0 1
58484: PUSH
58485: LD_INT 113
58487: EQUAL
58488: IFFALSE 58494
// MC_MinesTrigger ( ) ;
58490: CALL 71248 0 0
// if event = 120 then
58494: LD_VAR 0 1
58498: PUSH
58499: LD_INT 120
58501: EQUAL
58502: IFFALSE 58508
// MC_RepairVehicle ( ) ;
58504: CALL 71347 0 0
// if event = 121 then
58508: LD_VAR 0 1
58512: PUSH
58513: LD_INT 121
58515: EQUAL
58516: IFFALSE 58522
// MC_TameApe ( ) ;
58518: CALL 72090 0 0
// if event = 122 then
58522: LD_VAR 0 1
58526: PUSH
58527: LD_INT 122
58529: EQUAL
58530: IFFALSE 58536
// MC_ChangeApeClass ( ) ;
58532: CALL 72919 0 0
// if event = 123 then
58536: LD_VAR 0 1
58540: PUSH
58541: LD_INT 123
58543: EQUAL
58544: IFFALSE 58550
// MC_Bazooka ( ) ;
58546: CALL 73569 0 0
// if event = 124 then
58550: LD_VAR 0 1
58554: PUSH
58555: LD_INT 124
58557: EQUAL
58558: IFFALSE 58564
// MC_TeleportExit ( ) ;
58560: CALL 73767 0 0
// if event = 125 then
58564: LD_VAR 0 1
58568: PUSH
58569: LD_INT 125
58571: EQUAL
58572: IFFALSE 58578
// MC_Deposits ( ) ;
58574: CALL 74414 0 0
// if event = 126 then
58578: LD_VAR 0 1
58582: PUSH
58583: LD_INT 126
58585: EQUAL
58586: IFFALSE 58592
// MC_RemoteDriver ( ) ;
58588: CALL 75039 0 0
// if event = 200 then
58592: LD_VAR 0 1
58596: PUSH
58597: LD_INT 200
58599: EQUAL
58600: IFFALSE 58606
// MC_Idle ( ) ;
58602: CALL 76772 0 0
// end ;
58606: PPOPN 1
58608: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58609: LD_INT 0
58611: PPUSH
58612: PPUSH
// if not mc_bases [ base ] or not tag then
58613: LD_EXP 58
58617: PUSH
58618: LD_VAR 0 1
58622: ARRAY
58623: NOT
58624: PUSH
58625: LD_VAR 0 2
58629: NOT
58630: OR
58631: IFFALSE 58635
// exit ;
58633: GO 58699
// for i in mc_bases [ base ] union mc_ape [ base ] do
58635: LD_ADDR_VAR 0 4
58639: PUSH
58640: LD_EXP 58
58644: PUSH
58645: LD_VAR 0 1
58649: ARRAY
58650: PUSH
58651: LD_EXP 87
58655: PUSH
58656: LD_VAR 0 1
58660: ARRAY
58661: UNION
58662: PUSH
58663: FOR_IN
58664: IFFALSE 58697
// if GetTag ( i ) = tag then
58666: LD_VAR 0 4
58670: PPUSH
58671: CALL_OW 110
58675: PUSH
58676: LD_VAR 0 2
58680: EQUAL
58681: IFFALSE 58695
// SetTag ( i , 0 ) ;
58683: LD_VAR 0 4
58687: PPUSH
58688: LD_INT 0
58690: PPUSH
58691: CALL_OW 109
58695: GO 58663
58697: POP
58698: POP
// end ;
58699: LD_VAR 0 3
58703: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58704: LD_INT 0
58706: PPUSH
58707: PPUSH
58708: PPUSH
58709: PPUSH
58710: PPUSH
58711: PPUSH
58712: PPUSH
58713: PPUSH
// if not mc_bases then
58714: LD_EXP 58
58718: NOT
58719: IFFALSE 58723
// exit ;
58721: GO 59181
// for i = 1 to mc_bases do
58723: LD_ADDR_VAR 0 2
58727: PUSH
58728: DOUBLE
58729: LD_INT 1
58731: DEC
58732: ST_TO_ADDR
58733: LD_EXP 58
58737: PUSH
58738: FOR_TO
58739: IFFALSE 59179
// begin tmp := MC_ClassCheckReq ( i ) ;
58741: LD_ADDR_VAR 0 4
58745: PUSH
58746: LD_VAR 0 2
58750: PPUSH
58751: CALL 59186 0 1
58755: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58756: LD_ADDR_EXP 99
58760: PUSH
58761: LD_EXP 99
58765: PPUSH
58766: LD_VAR 0 2
58770: PPUSH
58771: LD_VAR 0 4
58775: PPUSH
58776: CALL_OW 1
58780: ST_TO_ADDR
// if not tmp then
58781: LD_VAR 0 4
58785: NOT
58786: IFFALSE 58790
// continue ;
58788: GO 58738
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58790: LD_ADDR_VAR 0 6
58794: PUSH
58795: LD_EXP 58
58799: PUSH
58800: LD_VAR 0 2
58804: ARRAY
58805: PPUSH
58806: LD_INT 2
58808: PUSH
58809: LD_INT 30
58811: PUSH
58812: LD_INT 4
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: PUSH
58819: LD_INT 30
58821: PUSH
58822: LD_INT 5
58824: PUSH
58825: EMPTY
58826: LIST
58827: LIST
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: LIST
58833: PPUSH
58834: CALL_OW 72
58838: PUSH
58839: LD_EXP 58
58843: PUSH
58844: LD_VAR 0 2
58848: ARRAY
58849: PPUSH
58850: LD_INT 2
58852: PUSH
58853: LD_INT 30
58855: PUSH
58856: LD_INT 0
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PUSH
58863: LD_INT 30
58865: PUSH
58866: LD_INT 1
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: PUSH
58873: EMPTY
58874: LIST
58875: LIST
58876: LIST
58877: PPUSH
58878: CALL_OW 72
58882: PUSH
58883: LD_EXP 58
58887: PUSH
58888: LD_VAR 0 2
58892: ARRAY
58893: PPUSH
58894: LD_INT 30
58896: PUSH
58897: LD_INT 3
58899: PUSH
58900: EMPTY
58901: LIST
58902: LIST
58903: PPUSH
58904: CALL_OW 72
58908: PUSH
58909: LD_EXP 58
58913: PUSH
58914: LD_VAR 0 2
58918: ARRAY
58919: PPUSH
58920: LD_INT 2
58922: PUSH
58923: LD_INT 30
58925: PUSH
58926: LD_INT 6
58928: PUSH
58929: EMPTY
58930: LIST
58931: LIST
58932: PUSH
58933: LD_INT 30
58935: PUSH
58936: LD_INT 7
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PUSH
58943: LD_INT 30
58945: PUSH
58946: LD_INT 8
58948: PUSH
58949: EMPTY
58950: LIST
58951: LIST
58952: PUSH
58953: EMPTY
58954: LIST
58955: LIST
58956: LIST
58957: LIST
58958: PPUSH
58959: CALL_OW 72
58963: PUSH
58964: EMPTY
58965: LIST
58966: LIST
58967: LIST
58968: LIST
58969: ST_TO_ADDR
// for j = 1 to 4 do
58970: LD_ADDR_VAR 0 3
58974: PUSH
58975: DOUBLE
58976: LD_INT 1
58978: DEC
58979: ST_TO_ADDR
58980: LD_INT 4
58982: PUSH
58983: FOR_TO
58984: IFFALSE 59175
// begin if not tmp [ j ] then
58986: LD_VAR 0 4
58990: PUSH
58991: LD_VAR 0 3
58995: ARRAY
58996: NOT
58997: IFFALSE 59001
// continue ;
58999: GO 58983
// for p in tmp [ j ] do
59001: LD_ADDR_VAR 0 5
59005: PUSH
59006: LD_VAR 0 4
59010: PUSH
59011: LD_VAR 0 3
59015: ARRAY
59016: PUSH
59017: FOR_IN
59018: IFFALSE 59171
// begin if not b [ j ] then
59020: LD_VAR 0 6
59024: PUSH
59025: LD_VAR 0 3
59029: ARRAY
59030: NOT
59031: IFFALSE 59035
// break ;
59033: GO 59171
// e := 0 ;
59035: LD_ADDR_VAR 0 7
59039: PUSH
59040: LD_INT 0
59042: ST_TO_ADDR
// for k in b [ j ] do
59043: LD_ADDR_VAR 0 8
59047: PUSH
59048: LD_VAR 0 6
59052: PUSH
59053: LD_VAR 0 3
59057: ARRAY
59058: PUSH
59059: FOR_IN
59060: IFFALSE 59087
// if IsNotFull ( k ) then
59062: LD_VAR 0 8
59066: PPUSH
59067: CALL 17584 0 1
59071: IFFALSE 59085
// begin e := k ;
59073: LD_ADDR_VAR 0 7
59077: PUSH
59078: LD_VAR 0 8
59082: ST_TO_ADDR
// break ;
59083: GO 59087
// end ;
59085: GO 59059
59087: POP
59088: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59089: LD_VAR 0 7
59093: PUSH
59094: LD_VAR 0 5
59098: PPUSH
59099: LD_VAR 0 7
59103: PPUSH
59104: CALL 54390 0 2
59108: NOT
59109: AND
59110: IFFALSE 59169
// begin if IsInUnit ( p ) then
59112: LD_VAR 0 5
59116: PPUSH
59117: CALL_OW 310
59121: IFFALSE 59132
// ComExitBuilding ( p ) ;
59123: LD_VAR 0 5
59127: PPUSH
59128: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59132: LD_VAR 0 5
59136: PPUSH
59137: LD_VAR 0 7
59141: PPUSH
59142: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59146: LD_VAR 0 5
59150: PPUSH
59151: LD_VAR 0 3
59155: PPUSH
59156: CALL_OW 183
// AddComExitBuilding ( p ) ;
59160: LD_VAR 0 5
59164: PPUSH
59165: CALL_OW 182
// end ; end ;
59169: GO 59017
59171: POP
59172: POP
// end ;
59173: GO 58983
59175: POP
59176: POP
// end ;
59177: GO 58738
59179: POP
59180: POP
// end ;
59181: LD_VAR 0 1
59185: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59186: LD_INT 0
59188: PPUSH
59189: PPUSH
59190: PPUSH
59191: PPUSH
59192: PPUSH
59193: PPUSH
59194: PPUSH
59195: PPUSH
59196: PPUSH
59197: PPUSH
59198: PPUSH
59199: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59200: LD_VAR 0 1
59204: NOT
59205: PUSH
59206: LD_EXP 58
59210: PUSH
59211: LD_VAR 0 1
59215: ARRAY
59216: NOT
59217: OR
59218: PUSH
59219: LD_EXP 58
59223: PUSH
59224: LD_VAR 0 1
59228: ARRAY
59229: PPUSH
59230: LD_INT 2
59232: PUSH
59233: LD_INT 30
59235: PUSH
59236: LD_INT 0
59238: PUSH
59239: EMPTY
59240: LIST
59241: LIST
59242: PUSH
59243: LD_INT 30
59245: PUSH
59246: LD_INT 1
59248: PUSH
59249: EMPTY
59250: LIST
59251: LIST
59252: PUSH
59253: EMPTY
59254: LIST
59255: LIST
59256: LIST
59257: PPUSH
59258: CALL_OW 72
59262: NOT
59263: OR
59264: IFFALSE 59268
// exit ;
59266: GO 62425
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59268: LD_ADDR_VAR 0 4
59272: PUSH
59273: LD_EXP 58
59277: PUSH
59278: LD_VAR 0 1
59282: ARRAY
59283: PPUSH
59284: LD_INT 2
59286: PUSH
59287: LD_INT 25
59289: PUSH
59290: LD_INT 1
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: PUSH
59297: LD_INT 25
59299: PUSH
59300: LD_INT 2
59302: PUSH
59303: EMPTY
59304: LIST
59305: LIST
59306: PUSH
59307: LD_INT 25
59309: PUSH
59310: LD_INT 3
59312: PUSH
59313: EMPTY
59314: LIST
59315: LIST
59316: PUSH
59317: LD_INT 25
59319: PUSH
59320: LD_INT 4
59322: PUSH
59323: EMPTY
59324: LIST
59325: LIST
59326: PUSH
59327: LD_INT 25
59329: PUSH
59330: LD_INT 5
59332: PUSH
59333: EMPTY
59334: LIST
59335: LIST
59336: PUSH
59337: LD_INT 25
59339: PUSH
59340: LD_INT 8
59342: PUSH
59343: EMPTY
59344: LIST
59345: LIST
59346: PUSH
59347: LD_INT 25
59349: PUSH
59350: LD_INT 9
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PUSH
59357: EMPTY
59358: LIST
59359: LIST
59360: LIST
59361: LIST
59362: LIST
59363: LIST
59364: LIST
59365: LIST
59366: PPUSH
59367: CALL_OW 72
59371: ST_TO_ADDR
// for i in tmp do
59372: LD_ADDR_VAR 0 3
59376: PUSH
59377: LD_VAR 0 4
59381: PUSH
59382: FOR_IN
59383: IFFALSE 59414
// if GetTag ( i ) then
59385: LD_VAR 0 3
59389: PPUSH
59390: CALL_OW 110
59394: IFFALSE 59412
// tmp := tmp diff i ;
59396: LD_ADDR_VAR 0 4
59400: PUSH
59401: LD_VAR 0 4
59405: PUSH
59406: LD_VAR 0 3
59410: DIFF
59411: ST_TO_ADDR
59412: GO 59382
59414: POP
59415: POP
// if not tmp then
59416: LD_VAR 0 4
59420: NOT
59421: IFFALSE 59425
// exit ;
59423: GO 62425
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59425: LD_ADDR_VAR 0 5
59429: PUSH
59430: LD_EXP 58
59434: PUSH
59435: LD_VAR 0 1
59439: ARRAY
59440: PPUSH
59441: LD_INT 2
59443: PUSH
59444: LD_INT 25
59446: PUSH
59447: LD_INT 1
59449: PUSH
59450: EMPTY
59451: LIST
59452: LIST
59453: PUSH
59454: LD_INT 25
59456: PUSH
59457: LD_INT 5
59459: PUSH
59460: EMPTY
59461: LIST
59462: LIST
59463: PUSH
59464: LD_INT 25
59466: PUSH
59467: LD_INT 8
59469: PUSH
59470: EMPTY
59471: LIST
59472: LIST
59473: PUSH
59474: LD_INT 25
59476: PUSH
59477: LD_INT 9
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: PUSH
59484: EMPTY
59485: LIST
59486: LIST
59487: LIST
59488: LIST
59489: LIST
59490: PPUSH
59491: CALL_OW 72
59495: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59496: LD_ADDR_VAR 0 6
59500: PUSH
59501: LD_EXP 58
59505: PUSH
59506: LD_VAR 0 1
59510: ARRAY
59511: PPUSH
59512: LD_INT 25
59514: PUSH
59515: LD_INT 2
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PPUSH
59522: CALL_OW 72
59526: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59527: LD_ADDR_VAR 0 7
59531: PUSH
59532: LD_EXP 58
59536: PUSH
59537: LD_VAR 0 1
59541: ARRAY
59542: PPUSH
59543: LD_INT 25
59545: PUSH
59546: LD_INT 3
59548: PUSH
59549: EMPTY
59550: LIST
59551: LIST
59552: PPUSH
59553: CALL_OW 72
59557: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ f_class , 4 ] ) ;
59558: LD_ADDR_VAR 0 8
59562: PUSH
59563: LD_EXP 58
59567: PUSH
59568: LD_VAR 0 1
59572: ARRAY
59573: PPUSH
59574: LD_INT 25
59576: PUSH
59577: LD_INT 4
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: PPUSH
59584: CALL_OW 72
59588: ST_TO_ADDR
// if mc_scan [ base ] then
59589: LD_EXP 81
59593: PUSH
59594: LD_VAR 0 1
59598: ARRAY
59599: IFFALSE 60060
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59601: LD_ADDR_EXP 100
59605: PUSH
59606: LD_EXP 100
59610: PPUSH
59611: LD_VAR 0 1
59615: PPUSH
59616: LD_INT 4
59618: PPUSH
59619: CALL_OW 1
59623: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59624: LD_ADDR_VAR 0 12
59628: PUSH
59629: LD_EXP 58
59633: PUSH
59634: LD_VAR 0 1
59638: ARRAY
59639: PPUSH
59640: LD_INT 2
59642: PUSH
59643: LD_INT 30
59645: PUSH
59646: LD_INT 4
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: PUSH
59653: LD_INT 30
59655: PUSH
59656: LD_INT 5
59658: PUSH
59659: EMPTY
59660: LIST
59661: LIST
59662: PUSH
59663: EMPTY
59664: LIST
59665: LIST
59666: LIST
59667: PPUSH
59668: CALL_OW 72
59672: ST_TO_ADDR
// if not b then
59673: LD_VAR 0 12
59677: NOT
59678: IFFALSE 59682
// exit ;
59680: GO 62425
// p := [ ] ;
59682: LD_ADDR_VAR 0 11
59686: PUSH
59687: EMPTY
59688: ST_TO_ADDR
// if sci >= 2 then
59689: LD_VAR 0 8
59693: PUSH
59694: LD_INT 2
59696: GREATEREQUAL
59697: IFFALSE 59728
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59699: LD_ADDR_VAR 0 8
59703: PUSH
59704: LD_VAR 0 8
59708: PUSH
59709: LD_INT 1
59711: ARRAY
59712: PUSH
59713: LD_VAR 0 8
59717: PUSH
59718: LD_INT 2
59720: ARRAY
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: ST_TO_ADDR
59726: GO 59789
// if sci = 1 then
59728: LD_VAR 0 8
59732: PUSH
59733: LD_INT 1
59735: EQUAL
59736: IFFALSE 59757
// sci := [ sci [ 1 ] ] else
59738: LD_ADDR_VAR 0 8
59742: PUSH
59743: LD_VAR 0 8
59747: PUSH
59748: LD_INT 1
59750: ARRAY
59751: PUSH
59752: EMPTY
59753: LIST
59754: ST_TO_ADDR
59755: GO 59789
// if sci = 0 then
59757: LD_VAR 0 8
59761: PUSH
59762: LD_INT 0
59764: EQUAL
59765: IFFALSE 59789
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59767: LD_ADDR_VAR 0 11
59771: PUSH
59772: LD_VAR 0 4
59776: PPUSH
59777: LD_INT 4
59779: PPUSH
59780: CALL 54253 0 2
59784: PUSH
59785: LD_INT 1
59787: ARRAY
59788: ST_TO_ADDR
// if eng > 4 then
59789: LD_VAR 0 6
59793: PUSH
59794: LD_INT 4
59796: GREATER
59797: IFFALSE 59843
// for i = eng downto 4 do
59799: LD_ADDR_VAR 0 3
59803: PUSH
59804: DOUBLE
59805: LD_VAR 0 6
59809: INC
59810: ST_TO_ADDR
59811: LD_INT 4
59813: PUSH
59814: FOR_DOWNTO
59815: IFFALSE 59841
// eng := eng diff eng [ i ] ;
59817: LD_ADDR_VAR 0 6
59821: PUSH
59822: LD_VAR 0 6
59826: PUSH
59827: LD_VAR 0 6
59831: PUSH
59832: LD_VAR 0 3
59836: ARRAY
59837: DIFF
59838: ST_TO_ADDR
59839: GO 59814
59841: POP
59842: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59843: LD_ADDR_VAR 0 4
59847: PUSH
59848: LD_VAR 0 4
59852: PUSH
59853: LD_VAR 0 5
59857: PUSH
59858: LD_VAR 0 6
59862: UNION
59863: PUSH
59864: LD_VAR 0 7
59868: UNION
59869: PUSH
59870: LD_VAR 0 8
59874: UNION
59875: DIFF
59876: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59877: LD_ADDR_VAR 0 13
59881: PUSH
59882: LD_EXP 58
59886: PUSH
59887: LD_VAR 0 1
59891: ARRAY
59892: PPUSH
59893: LD_INT 2
59895: PUSH
59896: LD_INT 30
59898: PUSH
59899: LD_INT 32
59901: PUSH
59902: EMPTY
59903: LIST
59904: LIST
59905: PUSH
59906: LD_INT 30
59908: PUSH
59909: LD_INT 31
59911: PUSH
59912: EMPTY
59913: LIST
59914: LIST
59915: PUSH
59916: EMPTY
59917: LIST
59918: LIST
59919: LIST
59920: PPUSH
59921: CALL_OW 72
59925: PUSH
59926: LD_EXP 58
59930: PUSH
59931: LD_VAR 0 1
59935: ARRAY
59936: PPUSH
59937: LD_INT 2
59939: PUSH
59940: LD_INT 30
59942: PUSH
59943: LD_INT 4
59945: PUSH
59946: EMPTY
59947: LIST
59948: LIST
59949: PUSH
59950: LD_INT 30
59952: PUSH
59953: LD_INT 5
59955: PUSH
59956: EMPTY
59957: LIST
59958: LIST
59959: PUSH
59960: EMPTY
59961: LIST
59962: LIST
59963: LIST
59964: PPUSH
59965: CALL_OW 72
59969: PUSH
59970: LD_INT 6
59972: MUL
59973: PLUS
59974: ST_TO_ADDR
// if bcount < tmp then
59975: LD_VAR 0 13
59979: PUSH
59980: LD_VAR 0 4
59984: LESS
59985: IFFALSE 60031
// for i = tmp downto bcount do
59987: LD_ADDR_VAR 0 3
59991: PUSH
59992: DOUBLE
59993: LD_VAR 0 4
59997: INC
59998: ST_TO_ADDR
59999: LD_VAR 0 13
60003: PUSH
60004: FOR_DOWNTO
60005: IFFALSE 60029
// tmp := Delete ( tmp , tmp ) ;
60007: LD_ADDR_VAR 0 4
60011: PUSH
60012: LD_VAR 0 4
60016: PPUSH
60017: LD_VAR 0 4
60021: PPUSH
60022: CALL_OW 3
60026: ST_TO_ADDR
60027: GO 60004
60029: POP
60030: POP
// result := [ tmp , 0 , 0 , p ] ;
60031: LD_ADDR_VAR 0 2
60035: PUSH
60036: LD_VAR 0 4
60040: PUSH
60041: LD_INT 0
60043: PUSH
60044: LD_INT 0
60046: PUSH
60047: LD_VAR 0 11
60051: PUSH
60052: EMPTY
60053: LIST
60054: LIST
60055: LIST
60056: LIST
60057: ST_TO_ADDR
// exit ;
60058: GO 62425
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60060: LD_EXP 58
60064: PUSH
60065: LD_VAR 0 1
60069: ARRAY
60070: PPUSH
60071: LD_INT 2
60073: PUSH
60074: LD_INT 30
60076: PUSH
60077: LD_INT 6
60079: PUSH
60080: EMPTY
60081: LIST
60082: LIST
60083: PUSH
60084: LD_INT 30
60086: PUSH
60087: LD_INT 7
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PUSH
60094: LD_INT 30
60096: PUSH
60097: LD_INT 8
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: LIST
60108: LIST
60109: PPUSH
60110: CALL_OW 72
60114: NOT
60115: PUSH
60116: LD_EXP 58
60120: PUSH
60121: LD_VAR 0 1
60125: ARRAY
60126: PPUSH
60127: LD_INT 30
60129: PUSH
60130: LD_INT 3
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PPUSH
60137: CALL_OW 72
60141: NOT
60142: AND
60143: IFFALSE 60215
// begin if eng = tmp then
60145: LD_VAR 0 6
60149: PUSH
60150: LD_VAR 0 4
60154: EQUAL
60155: IFFALSE 60159
// exit ;
60157: GO 62425
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60159: LD_ADDR_EXP 100
60163: PUSH
60164: LD_EXP 100
60168: PPUSH
60169: LD_VAR 0 1
60173: PPUSH
60174: LD_INT 1
60176: PPUSH
60177: CALL_OW 1
60181: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60182: LD_ADDR_VAR 0 2
60186: PUSH
60187: LD_INT 0
60189: PUSH
60190: LD_VAR 0 4
60194: PUSH
60195: LD_VAR 0 6
60199: DIFF
60200: PUSH
60201: LD_INT 0
60203: PUSH
60204: LD_INT 0
60206: PUSH
60207: EMPTY
60208: LIST
60209: LIST
60210: LIST
60211: LIST
60212: ST_TO_ADDR
// exit ;
60213: GO 62425
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60215: LD_EXP 85
60219: PUSH
60220: LD_EXP 84
60224: PUSH
60225: LD_VAR 0 1
60229: ARRAY
60230: ARRAY
60231: PUSH
60232: LD_EXP 58
60236: PUSH
60237: LD_VAR 0 1
60241: ARRAY
60242: PPUSH
60243: LD_INT 2
60245: PUSH
60246: LD_INT 30
60248: PUSH
60249: LD_INT 6
60251: PUSH
60252: EMPTY
60253: LIST
60254: LIST
60255: PUSH
60256: LD_INT 30
60258: PUSH
60259: LD_INT 7
60261: PUSH
60262: EMPTY
60263: LIST
60264: LIST
60265: PUSH
60266: LD_INT 30
60268: PUSH
60269: LD_INT 8
60271: PUSH
60272: EMPTY
60273: LIST
60274: LIST
60275: PUSH
60276: EMPTY
60277: LIST
60278: LIST
60279: LIST
60280: LIST
60281: PPUSH
60282: CALL_OW 72
60286: AND
60287: PUSH
60288: LD_EXP 58
60292: PUSH
60293: LD_VAR 0 1
60297: ARRAY
60298: PPUSH
60299: LD_INT 30
60301: PUSH
60302: LD_INT 3
60304: PUSH
60305: EMPTY
60306: LIST
60307: LIST
60308: PPUSH
60309: CALL_OW 72
60313: NOT
60314: AND
60315: IFFALSE 60529
// begin if sci >= 6 then
60317: LD_VAR 0 8
60321: PUSH
60322: LD_INT 6
60324: GREATEREQUAL
60325: IFFALSE 60329
// exit ;
60327: GO 62425
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60329: LD_ADDR_EXP 100
60333: PUSH
60334: LD_EXP 100
60338: PPUSH
60339: LD_VAR 0 1
60343: PPUSH
60344: LD_INT 2
60346: PPUSH
60347: CALL_OW 1
60351: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60352: LD_ADDR_VAR 0 9
60356: PUSH
60357: LD_VAR 0 4
60361: PUSH
60362: LD_VAR 0 8
60366: DIFF
60367: PPUSH
60368: LD_INT 4
60370: PPUSH
60371: CALL 54253 0 2
60375: ST_TO_ADDR
// p := [ ] ;
60376: LD_ADDR_VAR 0 11
60380: PUSH
60381: EMPTY
60382: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60383: LD_VAR 0 8
60387: PUSH
60388: LD_INT 6
60390: LESS
60391: PUSH
60392: LD_VAR 0 9
60396: PUSH
60397: LD_INT 6
60399: GREATER
60400: AND
60401: IFFALSE 60482
// begin for i = 1 to 6 - sci do
60403: LD_ADDR_VAR 0 3
60407: PUSH
60408: DOUBLE
60409: LD_INT 1
60411: DEC
60412: ST_TO_ADDR
60413: LD_INT 6
60415: PUSH
60416: LD_VAR 0 8
60420: MINUS
60421: PUSH
60422: FOR_TO
60423: IFFALSE 60478
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60425: LD_ADDR_VAR 0 11
60429: PUSH
60430: LD_VAR 0 11
60434: PPUSH
60435: LD_VAR 0 11
60439: PUSH
60440: LD_INT 1
60442: PLUS
60443: PPUSH
60444: LD_VAR 0 9
60448: PUSH
60449: LD_INT 1
60451: ARRAY
60452: PPUSH
60453: CALL_OW 2
60457: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60458: LD_ADDR_VAR 0 9
60462: PUSH
60463: LD_VAR 0 9
60467: PPUSH
60468: LD_INT 1
60470: PPUSH
60471: CALL_OW 3
60475: ST_TO_ADDR
// end ;
60476: GO 60422
60478: POP
60479: POP
// end else
60480: GO 60502
// if sort then
60482: LD_VAR 0 9
60486: IFFALSE 60502
// p := sort [ 1 ] ;
60488: LD_ADDR_VAR 0 11
60492: PUSH
60493: LD_VAR 0 9
60497: PUSH
60498: LD_INT 1
60500: ARRAY
60501: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60502: LD_ADDR_VAR 0 2
60506: PUSH
60507: LD_INT 0
60509: PUSH
60510: LD_INT 0
60512: PUSH
60513: LD_INT 0
60515: PUSH
60516: LD_VAR 0 11
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: LIST
60525: LIST
60526: ST_TO_ADDR
// exit ;
60527: GO 62425
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60529: LD_EXP 85
60533: PUSH
60534: LD_EXP 84
60538: PUSH
60539: LD_VAR 0 1
60543: ARRAY
60544: ARRAY
60545: PUSH
60546: LD_EXP 58
60550: PUSH
60551: LD_VAR 0 1
60555: ARRAY
60556: PPUSH
60557: LD_INT 2
60559: PUSH
60560: LD_INT 30
60562: PUSH
60563: LD_INT 6
60565: PUSH
60566: EMPTY
60567: LIST
60568: LIST
60569: PUSH
60570: LD_INT 30
60572: PUSH
60573: LD_INT 7
60575: PUSH
60576: EMPTY
60577: LIST
60578: LIST
60579: PUSH
60580: LD_INT 30
60582: PUSH
60583: LD_INT 8
60585: PUSH
60586: EMPTY
60587: LIST
60588: LIST
60589: PUSH
60590: EMPTY
60591: LIST
60592: LIST
60593: LIST
60594: LIST
60595: PPUSH
60596: CALL_OW 72
60600: AND
60601: PUSH
60602: LD_EXP 58
60606: PUSH
60607: LD_VAR 0 1
60611: ARRAY
60612: PPUSH
60613: LD_INT 30
60615: PUSH
60616: LD_INT 3
60618: PUSH
60619: EMPTY
60620: LIST
60621: LIST
60622: PPUSH
60623: CALL_OW 72
60627: AND
60628: IFFALSE 61155
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60630: LD_ADDR_EXP 100
60634: PUSH
60635: LD_EXP 100
60639: PPUSH
60640: LD_VAR 0 1
60644: PPUSH
60645: LD_INT 3
60647: PPUSH
60648: CALL_OW 1
60652: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60653: LD_ADDR_VAR 0 2
60657: PUSH
60658: LD_INT 0
60660: PUSH
60661: LD_INT 0
60663: PUSH
60664: LD_INT 0
60666: PUSH
60667: LD_INT 0
60669: PUSH
60670: EMPTY
60671: LIST
60672: LIST
60673: LIST
60674: LIST
60675: ST_TO_ADDR
// if not eng then
60676: LD_VAR 0 6
60680: NOT
60681: IFFALSE 60744
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60683: LD_ADDR_VAR 0 11
60687: PUSH
60688: LD_VAR 0 4
60692: PPUSH
60693: LD_INT 2
60695: PPUSH
60696: CALL 54253 0 2
60700: PUSH
60701: LD_INT 1
60703: ARRAY
60704: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60705: LD_ADDR_VAR 0 2
60709: PUSH
60710: LD_VAR 0 2
60714: PPUSH
60715: LD_INT 2
60717: PPUSH
60718: LD_VAR 0 11
60722: PPUSH
60723: CALL_OW 1
60727: ST_TO_ADDR
// tmp := tmp diff p ;
60728: LD_ADDR_VAR 0 4
60732: PUSH
60733: LD_VAR 0 4
60737: PUSH
60738: LD_VAR 0 11
60742: DIFF
60743: ST_TO_ADDR
// end ; if not eng then
60744: LD_VAR 0 6
60748: NOT
60749: IFFALSE 60775
// tmp := tmp diff ( mech union sci ) else
60751: LD_ADDR_VAR 0 4
60755: PUSH
60756: LD_VAR 0 4
60760: PUSH
60761: LD_VAR 0 7
60765: PUSH
60766: LD_VAR 0 8
60770: UNION
60771: DIFF
60772: ST_TO_ADDR
60773: GO 60807
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
60775: LD_ADDR_VAR 0 4
60779: PUSH
60780: LD_VAR 0 4
60784: PUSH
60785: LD_VAR 0 6
60789: PUSH
60790: LD_INT 1
60792: ARRAY
60793: PUSH
60794: LD_VAR 0 7
60798: UNION
60799: PUSH
60800: LD_VAR 0 8
60804: UNION
60805: DIFF
60806: ST_TO_ADDR
// if tmp and sci < 6 then
60807: LD_VAR 0 4
60811: PUSH
60812: LD_VAR 0 8
60816: PUSH
60817: LD_INT 6
60819: LESS
60820: AND
60821: IFFALSE 60980
// begin sort := SortBySkill ( tmp , 4 ) ;
60823: LD_ADDR_VAR 0 9
60827: PUSH
60828: LD_VAR 0 4
60832: PPUSH
60833: LD_INT 4
60835: PPUSH
60836: CALL 54253 0 2
60840: ST_TO_ADDR
// p := [ ] ;
60841: LD_ADDR_VAR 0 11
60845: PUSH
60846: EMPTY
60847: ST_TO_ADDR
// if sort then
60848: LD_VAR 0 9
60852: IFFALSE 60951
// for i = 1 to 6 - sci do
60854: LD_ADDR_VAR 0 3
60858: PUSH
60859: DOUBLE
60860: LD_INT 1
60862: DEC
60863: ST_TO_ADDR
60864: LD_INT 6
60866: PUSH
60867: LD_VAR 0 8
60871: MINUS
60872: PUSH
60873: FOR_TO
60874: IFFALSE 60949
// begin if i = sort then
60876: LD_VAR 0 3
60880: PUSH
60881: LD_VAR 0 9
60885: EQUAL
60886: IFFALSE 60890
// break ;
60888: GO 60949
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60890: LD_ADDR_VAR 0 11
60894: PUSH
60895: LD_VAR 0 11
60899: PPUSH
60900: LD_VAR 0 11
60904: PUSH
60905: LD_INT 1
60907: PLUS
60908: PPUSH
60909: LD_VAR 0 9
60913: PUSH
60914: LD_VAR 0 3
60918: ARRAY
60919: PPUSH
60920: CALL_OW 2
60924: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60925: LD_ADDR_VAR 0 4
60929: PUSH
60930: LD_VAR 0 4
60934: PUSH
60935: LD_VAR 0 9
60939: PUSH
60940: LD_VAR 0 3
60944: ARRAY
60945: DIFF
60946: ST_TO_ADDR
// end ;
60947: GO 60873
60949: POP
60950: POP
// if p then
60951: LD_VAR 0 11
60955: IFFALSE 60980
// result := Replace ( result , 4 , p ) ;
60957: LD_ADDR_VAR 0 2
60961: PUSH
60962: LD_VAR 0 2
60966: PPUSH
60967: LD_INT 4
60969: PPUSH
60970: LD_VAR 0 11
60974: PPUSH
60975: CALL_OW 1
60979: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60980: LD_VAR 0 4
60984: PUSH
60985: LD_VAR 0 7
60989: PUSH
60990: LD_INT 6
60992: LESS
60993: AND
60994: IFFALSE 61153
// begin sort := SortBySkill ( tmp , 3 ) ;
60996: LD_ADDR_VAR 0 9
61000: PUSH
61001: LD_VAR 0 4
61005: PPUSH
61006: LD_INT 3
61008: PPUSH
61009: CALL 54253 0 2
61013: ST_TO_ADDR
// p := [ ] ;
61014: LD_ADDR_VAR 0 11
61018: PUSH
61019: EMPTY
61020: ST_TO_ADDR
// if sort then
61021: LD_VAR 0 9
61025: IFFALSE 61124
// for i = 1 to 6 - mech do
61027: LD_ADDR_VAR 0 3
61031: PUSH
61032: DOUBLE
61033: LD_INT 1
61035: DEC
61036: ST_TO_ADDR
61037: LD_INT 6
61039: PUSH
61040: LD_VAR 0 7
61044: MINUS
61045: PUSH
61046: FOR_TO
61047: IFFALSE 61122
// begin if i = sort then
61049: LD_VAR 0 3
61053: PUSH
61054: LD_VAR 0 9
61058: EQUAL
61059: IFFALSE 61063
// break ;
61061: GO 61122
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61063: LD_ADDR_VAR 0 11
61067: PUSH
61068: LD_VAR 0 11
61072: PPUSH
61073: LD_VAR 0 11
61077: PUSH
61078: LD_INT 1
61080: PLUS
61081: PPUSH
61082: LD_VAR 0 9
61086: PUSH
61087: LD_VAR 0 3
61091: ARRAY
61092: PPUSH
61093: CALL_OW 2
61097: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61098: LD_ADDR_VAR 0 4
61102: PUSH
61103: LD_VAR 0 4
61107: PUSH
61108: LD_VAR 0 9
61112: PUSH
61113: LD_VAR 0 3
61117: ARRAY
61118: DIFF
61119: ST_TO_ADDR
// end ;
61120: GO 61046
61122: POP
61123: POP
// if p then
61124: LD_VAR 0 11
61128: IFFALSE 61153
// result := Replace ( result , 3 , p ) ;
61130: LD_ADDR_VAR 0 2
61134: PUSH
61135: LD_VAR 0 2
61139: PPUSH
61140: LD_INT 3
61142: PPUSH
61143: LD_VAR 0 11
61147: PPUSH
61148: CALL_OW 1
61152: ST_TO_ADDR
// end ; exit ;
61153: GO 62425
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61155: LD_EXP 85
61159: PUSH
61160: LD_EXP 84
61164: PUSH
61165: LD_VAR 0 1
61169: ARRAY
61170: ARRAY
61171: NOT
61172: PUSH
61173: LD_EXP 58
61177: PUSH
61178: LD_VAR 0 1
61182: ARRAY
61183: PPUSH
61184: LD_INT 30
61186: PUSH
61187: LD_INT 3
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PPUSH
61194: CALL_OW 72
61198: AND
61199: PUSH
61200: LD_EXP 63
61204: PUSH
61205: LD_VAR 0 1
61209: ARRAY
61210: AND
61211: IFFALSE 61755
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61213: LD_ADDR_EXP 100
61217: PUSH
61218: LD_EXP 100
61222: PPUSH
61223: LD_VAR 0 1
61227: PPUSH
61228: LD_INT 5
61230: PPUSH
61231: CALL_OW 1
61235: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61236: LD_ADDR_VAR 0 2
61240: PUSH
61241: LD_INT 0
61243: PUSH
61244: LD_INT 0
61246: PUSH
61247: LD_INT 0
61249: PUSH
61250: LD_INT 0
61252: PUSH
61253: EMPTY
61254: LIST
61255: LIST
61256: LIST
61257: LIST
61258: ST_TO_ADDR
// if sci > 1 then
61259: LD_VAR 0 8
61263: PUSH
61264: LD_INT 1
61266: GREATER
61267: IFFALSE 61295
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61269: LD_ADDR_VAR 0 4
61273: PUSH
61274: LD_VAR 0 4
61278: PUSH
61279: LD_VAR 0 8
61283: PUSH
61284: LD_VAR 0 8
61288: PUSH
61289: LD_INT 1
61291: ARRAY
61292: DIFF
61293: DIFF
61294: ST_TO_ADDR
// if tmp and not sci then
61295: LD_VAR 0 4
61299: PUSH
61300: LD_VAR 0 8
61304: NOT
61305: AND
61306: IFFALSE 61375
// begin sort := SortBySkill ( tmp , 4 ) ;
61308: LD_ADDR_VAR 0 9
61312: PUSH
61313: LD_VAR 0 4
61317: PPUSH
61318: LD_INT 4
61320: PPUSH
61321: CALL 54253 0 2
61325: ST_TO_ADDR
// if sort then
61326: LD_VAR 0 9
61330: IFFALSE 61346
// p := sort [ 1 ] ;
61332: LD_ADDR_VAR 0 11
61336: PUSH
61337: LD_VAR 0 9
61341: PUSH
61342: LD_INT 1
61344: ARRAY
61345: ST_TO_ADDR
// if p then
61346: LD_VAR 0 11
61350: IFFALSE 61375
// result := Replace ( result , 4 , p ) ;
61352: LD_ADDR_VAR 0 2
61356: PUSH
61357: LD_VAR 0 2
61361: PPUSH
61362: LD_INT 4
61364: PPUSH
61365: LD_VAR 0 11
61369: PPUSH
61370: CALL_OW 1
61374: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61375: LD_ADDR_VAR 0 4
61379: PUSH
61380: LD_VAR 0 4
61384: PUSH
61385: LD_VAR 0 7
61389: DIFF
61390: ST_TO_ADDR
// if tmp and mech < 6 then
61391: LD_VAR 0 4
61395: PUSH
61396: LD_VAR 0 7
61400: PUSH
61401: LD_INT 6
61403: LESS
61404: AND
61405: IFFALSE 61564
// begin sort := SortBySkill ( tmp , 3 ) ;
61407: LD_ADDR_VAR 0 9
61411: PUSH
61412: LD_VAR 0 4
61416: PPUSH
61417: LD_INT 3
61419: PPUSH
61420: CALL 54253 0 2
61424: ST_TO_ADDR
// p := [ ] ;
61425: LD_ADDR_VAR 0 11
61429: PUSH
61430: EMPTY
61431: ST_TO_ADDR
// if sort then
61432: LD_VAR 0 9
61436: IFFALSE 61535
// for i = 1 to 6 - mech do
61438: LD_ADDR_VAR 0 3
61442: PUSH
61443: DOUBLE
61444: LD_INT 1
61446: DEC
61447: ST_TO_ADDR
61448: LD_INT 6
61450: PUSH
61451: LD_VAR 0 7
61455: MINUS
61456: PUSH
61457: FOR_TO
61458: IFFALSE 61533
// begin if i = sort then
61460: LD_VAR 0 3
61464: PUSH
61465: LD_VAR 0 9
61469: EQUAL
61470: IFFALSE 61474
// break ;
61472: GO 61533
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61474: LD_ADDR_VAR 0 11
61478: PUSH
61479: LD_VAR 0 11
61483: PPUSH
61484: LD_VAR 0 11
61488: PUSH
61489: LD_INT 1
61491: PLUS
61492: PPUSH
61493: LD_VAR 0 9
61497: PUSH
61498: LD_VAR 0 3
61502: ARRAY
61503: PPUSH
61504: CALL_OW 2
61508: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61509: LD_ADDR_VAR 0 4
61513: PUSH
61514: LD_VAR 0 4
61518: PUSH
61519: LD_VAR 0 9
61523: PUSH
61524: LD_VAR 0 3
61528: ARRAY
61529: DIFF
61530: ST_TO_ADDR
// end ;
61531: GO 61457
61533: POP
61534: POP
// if p then
61535: LD_VAR 0 11
61539: IFFALSE 61564
// result := Replace ( result , 3 , p ) ;
61541: LD_ADDR_VAR 0 2
61545: PUSH
61546: LD_VAR 0 2
61550: PPUSH
61551: LD_INT 3
61553: PPUSH
61554: LD_VAR 0 11
61558: PPUSH
61559: CALL_OW 1
61563: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61564: LD_ADDR_VAR 0 4
61568: PUSH
61569: LD_VAR 0 4
61573: PUSH
61574: LD_VAR 0 6
61578: DIFF
61579: ST_TO_ADDR
// if tmp and eng < 6 then
61580: LD_VAR 0 4
61584: PUSH
61585: LD_VAR 0 6
61589: PUSH
61590: LD_INT 6
61592: LESS
61593: AND
61594: IFFALSE 61753
// begin sort := SortBySkill ( tmp , 2 ) ;
61596: LD_ADDR_VAR 0 9
61600: PUSH
61601: LD_VAR 0 4
61605: PPUSH
61606: LD_INT 2
61608: PPUSH
61609: CALL 54253 0 2
61613: ST_TO_ADDR
// p := [ ] ;
61614: LD_ADDR_VAR 0 11
61618: PUSH
61619: EMPTY
61620: ST_TO_ADDR
// if sort then
61621: LD_VAR 0 9
61625: IFFALSE 61724
// for i = 1 to 6 - eng do
61627: LD_ADDR_VAR 0 3
61631: PUSH
61632: DOUBLE
61633: LD_INT 1
61635: DEC
61636: ST_TO_ADDR
61637: LD_INT 6
61639: PUSH
61640: LD_VAR 0 6
61644: MINUS
61645: PUSH
61646: FOR_TO
61647: IFFALSE 61722
// begin if i = sort then
61649: LD_VAR 0 3
61653: PUSH
61654: LD_VAR 0 9
61658: EQUAL
61659: IFFALSE 61663
// break ;
61661: GO 61722
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61663: LD_ADDR_VAR 0 11
61667: PUSH
61668: LD_VAR 0 11
61672: PPUSH
61673: LD_VAR 0 11
61677: PUSH
61678: LD_INT 1
61680: PLUS
61681: PPUSH
61682: LD_VAR 0 9
61686: PUSH
61687: LD_VAR 0 3
61691: ARRAY
61692: PPUSH
61693: CALL_OW 2
61697: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61698: LD_ADDR_VAR 0 4
61702: PUSH
61703: LD_VAR 0 4
61707: PUSH
61708: LD_VAR 0 9
61712: PUSH
61713: LD_VAR 0 3
61717: ARRAY
61718: DIFF
61719: ST_TO_ADDR
// end ;
61720: GO 61646
61722: POP
61723: POP
// if p then
61724: LD_VAR 0 11
61728: IFFALSE 61753
// result := Replace ( result , 2 , p ) ;
61730: LD_ADDR_VAR 0 2
61734: PUSH
61735: LD_VAR 0 2
61739: PPUSH
61740: LD_INT 2
61742: PPUSH
61743: LD_VAR 0 11
61747: PPUSH
61748: CALL_OW 1
61752: ST_TO_ADDR
// end ; exit ;
61753: GO 62425
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61755: LD_EXP 85
61759: PUSH
61760: LD_EXP 84
61764: PUSH
61765: LD_VAR 0 1
61769: ARRAY
61770: ARRAY
61771: NOT
61772: PUSH
61773: LD_EXP 58
61777: PUSH
61778: LD_VAR 0 1
61782: ARRAY
61783: PPUSH
61784: LD_INT 30
61786: PUSH
61787: LD_INT 3
61789: PUSH
61790: EMPTY
61791: LIST
61792: LIST
61793: PPUSH
61794: CALL_OW 72
61798: AND
61799: PUSH
61800: LD_EXP 63
61804: PUSH
61805: LD_VAR 0 1
61809: ARRAY
61810: NOT
61811: AND
61812: IFFALSE 62425
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61814: LD_ADDR_EXP 100
61818: PUSH
61819: LD_EXP 100
61823: PPUSH
61824: LD_VAR 0 1
61828: PPUSH
61829: LD_INT 6
61831: PPUSH
61832: CALL_OW 1
61836: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61837: LD_ADDR_VAR 0 2
61841: PUSH
61842: LD_INT 0
61844: PUSH
61845: LD_INT 0
61847: PUSH
61848: LD_INT 0
61850: PUSH
61851: LD_INT 0
61853: PUSH
61854: EMPTY
61855: LIST
61856: LIST
61857: LIST
61858: LIST
61859: ST_TO_ADDR
// if sci >= 1 then
61860: LD_VAR 0 8
61864: PUSH
61865: LD_INT 1
61867: GREATEREQUAL
61868: IFFALSE 61890
// tmp := tmp diff sci [ 1 ] ;
61870: LD_ADDR_VAR 0 4
61874: PUSH
61875: LD_VAR 0 4
61879: PUSH
61880: LD_VAR 0 8
61884: PUSH
61885: LD_INT 1
61887: ARRAY
61888: DIFF
61889: ST_TO_ADDR
// if tmp and not sci then
61890: LD_VAR 0 4
61894: PUSH
61895: LD_VAR 0 8
61899: NOT
61900: AND
61901: IFFALSE 61970
// begin sort := SortBySkill ( tmp , 4 ) ;
61903: LD_ADDR_VAR 0 9
61907: PUSH
61908: LD_VAR 0 4
61912: PPUSH
61913: LD_INT 4
61915: PPUSH
61916: CALL 54253 0 2
61920: ST_TO_ADDR
// if sort then
61921: LD_VAR 0 9
61925: IFFALSE 61941
// p := sort [ 1 ] ;
61927: LD_ADDR_VAR 0 11
61931: PUSH
61932: LD_VAR 0 9
61936: PUSH
61937: LD_INT 1
61939: ARRAY
61940: ST_TO_ADDR
// if p then
61941: LD_VAR 0 11
61945: IFFALSE 61970
// result := Replace ( result , 4 , p ) ;
61947: LD_ADDR_VAR 0 2
61951: PUSH
61952: LD_VAR 0 2
61956: PPUSH
61957: LD_INT 4
61959: PPUSH
61960: LD_VAR 0 11
61964: PPUSH
61965: CALL_OW 1
61969: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61970: LD_ADDR_VAR 0 4
61974: PUSH
61975: LD_VAR 0 4
61979: PUSH
61980: LD_VAR 0 7
61984: DIFF
61985: ST_TO_ADDR
// if tmp and mech < 6 then
61986: LD_VAR 0 4
61990: PUSH
61991: LD_VAR 0 7
61995: PUSH
61996: LD_INT 6
61998: LESS
61999: AND
62000: IFFALSE 62159
// begin sort := SortBySkill ( tmp , 3 ) ;
62002: LD_ADDR_VAR 0 9
62006: PUSH
62007: LD_VAR 0 4
62011: PPUSH
62012: LD_INT 3
62014: PPUSH
62015: CALL 54253 0 2
62019: ST_TO_ADDR
// p := [ ] ;
62020: LD_ADDR_VAR 0 11
62024: PUSH
62025: EMPTY
62026: ST_TO_ADDR
// if sort then
62027: LD_VAR 0 9
62031: IFFALSE 62130
// for i = 1 to 6 - mech do
62033: LD_ADDR_VAR 0 3
62037: PUSH
62038: DOUBLE
62039: LD_INT 1
62041: DEC
62042: ST_TO_ADDR
62043: LD_INT 6
62045: PUSH
62046: LD_VAR 0 7
62050: MINUS
62051: PUSH
62052: FOR_TO
62053: IFFALSE 62128
// begin if i = sort then
62055: LD_VAR 0 3
62059: PUSH
62060: LD_VAR 0 9
62064: EQUAL
62065: IFFALSE 62069
// break ;
62067: GO 62128
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62069: LD_ADDR_VAR 0 11
62073: PUSH
62074: LD_VAR 0 11
62078: PPUSH
62079: LD_VAR 0 11
62083: PUSH
62084: LD_INT 1
62086: PLUS
62087: PPUSH
62088: LD_VAR 0 9
62092: PUSH
62093: LD_VAR 0 3
62097: ARRAY
62098: PPUSH
62099: CALL_OW 2
62103: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62104: LD_ADDR_VAR 0 4
62108: PUSH
62109: LD_VAR 0 4
62113: PUSH
62114: LD_VAR 0 9
62118: PUSH
62119: LD_VAR 0 3
62123: ARRAY
62124: DIFF
62125: ST_TO_ADDR
// end ;
62126: GO 62052
62128: POP
62129: POP
// if p then
62130: LD_VAR 0 11
62134: IFFALSE 62159
// result := Replace ( result , 3 , p ) ;
62136: LD_ADDR_VAR 0 2
62140: PUSH
62141: LD_VAR 0 2
62145: PPUSH
62146: LD_INT 3
62148: PPUSH
62149: LD_VAR 0 11
62153: PPUSH
62154: CALL_OW 1
62158: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62159: LD_ADDR_VAR 0 4
62163: PUSH
62164: LD_VAR 0 4
62168: PUSH
62169: LD_VAR 0 6
62173: DIFF
62174: ST_TO_ADDR
// if tmp and eng < 4 then
62175: LD_VAR 0 4
62179: PUSH
62180: LD_VAR 0 6
62184: PUSH
62185: LD_INT 4
62187: LESS
62188: AND
62189: IFFALSE 62350
// begin sort := SortBySkill ( tmp , 2 ) ;
62191: LD_ADDR_VAR 0 9
62195: PUSH
62196: LD_VAR 0 4
62200: PPUSH
62201: LD_INT 2
62203: PPUSH
62204: CALL 54253 0 2
62208: ST_TO_ADDR
// p := [ ] ;
62209: LD_ADDR_VAR 0 11
62213: PUSH
62214: EMPTY
62215: ST_TO_ADDR
// if sort then
62216: LD_VAR 0 9
62220: IFFALSE 62319
// for i = 1 to 4 - eng do
62222: LD_ADDR_VAR 0 3
62226: PUSH
62227: DOUBLE
62228: LD_INT 1
62230: DEC
62231: ST_TO_ADDR
62232: LD_INT 4
62234: PUSH
62235: LD_VAR 0 6
62239: MINUS
62240: PUSH
62241: FOR_TO
62242: IFFALSE 62317
// begin if i = sort then
62244: LD_VAR 0 3
62248: PUSH
62249: LD_VAR 0 9
62253: EQUAL
62254: IFFALSE 62258
// break ;
62256: GO 62317
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62258: LD_ADDR_VAR 0 11
62262: PUSH
62263: LD_VAR 0 11
62267: PPUSH
62268: LD_VAR 0 11
62272: PUSH
62273: LD_INT 1
62275: PLUS
62276: PPUSH
62277: LD_VAR 0 9
62281: PUSH
62282: LD_VAR 0 3
62286: ARRAY
62287: PPUSH
62288: CALL_OW 2
62292: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62293: LD_ADDR_VAR 0 4
62297: PUSH
62298: LD_VAR 0 4
62302: PUSH
62303: LD_VAR 0 9
62307: PUSH
62308: LD_VAR 0 3
62312: ARRAY
62313: DIFF
62314: ST_TO_ADDR
// end ;
62315: GO 62241
62317: POP
62318: POP
// if p then
62319: LD_VAR 0 11
62323: IFFALSE 62348
// result := Replace ( result , 2 , p ) ;
62325: LD_ADDR_VAR 0 2
62329: PUSH
62330: LD_VAR 0 2
62334: PPUSH
62335: LD_INT 2
62337: PPUSH
62338: LD_VAR 0 11
62342: PPUSH
62343: CALL_OW 1
62347: ST_TO_ADDR
// end else
62348: GO 62394
// for i = eng downto 5 do
62350: LD_ADDR_VAR 0 3
62354: PUSH
62355: DOUBLE
62356: LD_VAR 0 6
62360: INC
62361: ST_TO_ADDR
62362: LD_INT 5
62364: PUSH
62365: FOR_DOWNTO
62366: IFFALSE 62392
// tmp := tmp union eng [ i ] ;
62368: LD_ADDR_VAR 0 4
62372: PUSH
62373: LD_VAR 0 4
62377: PUSH
62378: LD_VAR 0 6
62382: PUSH
62383: LD_VAR 0 3
62387: ARRAY
62388: UNION
62389: ST_TO_ADDR
62390: GO 62365
62392: POP
62393: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62394: LD_ADDR_VAR 0 2
62398: PUSH
62399: LD_VAR 0 2
62403: PPUSH
62404: LD_INT 1
62406: PPUSH
62407: LD_VAR 0 4
62411: PUSH
62412: LD_VAR 0 5
62416: DIFF
62417: PPUSH
62418: CALL_OW 1
62422: ST_TO_ADDR
// exit ;
62423: GO 62425
// end ; end ;
62425: LD_VAR 0 2
62429: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62430: LD_INT 0
62432: PPUSH
62433: PPUSH
62434: PPUSH
// if not mc_bases then
62435: LD_EXP 58
62439: NOT
62440: IFFALSE 62444
// exit ;
62442: GO 62550
// for i = 1 to mc_bases do
62444: LD_ADDR_VAR 0 2
62448: PUSH
62449: DOUBLE
62450: LD_INT 1
62452: DEC
62453: ST_TO_ADDR
62454: LD_EXP 58
62458: PUSH
62459: FOR_TO
62460: IFFALSE 62541
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62462: LD_ADDR_VAR 0 3
62466: PUSH
62467: LD_EXP 58
62471: PUSH
62472: LD_VAR 0 2
62476: ARRAY
62477: PPUSH
62478: LD_INT 21
62480: PUSH
62481: LD_INT 3
62483: PUSH
62484: EMPTY
62485: LIST
62486: LIST
62487: PUSH
62488: LD_INT 3
62490: PUSH
62491: LD_INT 24
62493: PUSH
62494: LD_INT 1000
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: PUSH
62501: EMPTY
62502: LIST
62503: LIST
62504: PUSH
62505: EMPTY
62506: LIST
62507: LIST
62508: PPUSH
62509: CALL_OW 72
62513: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62514: LD_ADDR_EXP 59
62518: PUSH
62519: LD_EXP 59
62523: PPUSH
62524: LD_VAR 0 2
62528: PPUSH
62529: LD_VAR 0 3
62533: PPUSH
62534: CALL_OW 1
62538: ST_TO_ADDR
// end ;
62539: GO 62459
62541: POP
62542: POP
// RaiseSailEvent ( 101 ) ;
62543: LD_INT 101
62545: PPUSH
62546: CALL_OW 427
// end ;
62550: LD_VAR 0 1
62554: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62555: LD_INT 0
62557: PPUSH
62558: PPUSH
62559: PPUSH
62560: PPUSH
62561: PPUSH
62562: PPUSH
62563: PPUSH
// if not mc_bases then
62564: LD_EXP 58
62568: NOT
62569: IFFALSE 62573
// exit ;
62571: GO 63108
// for i = 1 to mc_bases do
62573: LD_ADDR_VAR 0 2
62577: PUSH
62578: DOUBLE
62579: LD_INT 1
62581: DEC
62582: ST_TO_ADDR
62583: LD_EXP 58
62587: PUSH
62588: FOR_TO
62589: IFFALSE 63099
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
62591: LD_ADDR_VAR 0 5
62595: PUSH
62596: LD_EXP 58
62600: PUSH
62601: LD_VAR 0 2
62605: ARRAY
62606: PUSH
62607: LD_EXP 87
62611: PUSH
62612: LD_VAR 0 2
62616: ARRAY
62617: UNION
62618: PPUSH
62619: LD_INT 21
62621: PUSH
62622: LD_INT 1
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: PUSH
62629: LD_INT 1
62631: PUSH
62632: LD_INT 3
62634: PUSH
62635: LD_INT 54
62637: PUSH
62638: EMPTY
62639: LIST
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: PUSH
62645: LD_INT 3
62647: PUSH
62648: LD_INT 24
62650: PUSH
62651: LD_INT 700
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: PUSH
62658: EMPTY
62659: LIST
62660: LIST
62661: PUSH
62662: EMPTY
62663: LIST
62664: LIST
62665: LIST
62666: PUSH
62667: EMPTY
62668: LIST
62669: LIST
62670: PPUSH
62671: CALL_OW 72
62675: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62676: LD_ADDR_VAR 0 6
62680: PUSH
62681: LD_EXP 58
62685: PUSH
62686: LD_VAR 0 2
62690: ARRAY
62691: PPUSH
62692: LD_INT 21
62694: PUSH
62695: LD_INT 1
62697: PUSH
62698: EMPTY
62699: LIST
62700: LIST
62701: PUSH
62702: LD_INT 1
62704: PUSH
62705: LD_INT 3
62707: PUSH
62708: LD_INT 54
62710: PUSH
62711: EMPTY
62712: LIST
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: LD_INT 3
62720: PUSH
62721: LD_INT 24
62723: PUSH
62724: LD_INT 250
62726: PUSH
62727: EMPTY
62728: LIST
62729: LIST
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: LIST
62739: PUSH
62740: EMPTY
62741: LIST
62742: LIST
62743: PPUSH
62744: CALL_OW 72
62748: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62749: LD_ADDR_VAR 0 7
62753: PUSH
62754: LD_VAR 0 5
62758: PUSH
62759: LD_VAR 0 6
62763: DIFF
62764: ST_TO_ADDR
// if not need_heal_1 then
62765: LD_VAR 0 6
62769: NOT
62770: IFFALSE 62803
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , [ ] ) else
62772: LD_ADDR_EXP 61
62776: PUSH
62777: LD_EXP 61
62781: PPUSH
62782: LD_VAR 0 2
62786: PUSH
62787: LD_INT 1
62789: PUSH
62790: EMPTY
62791: LIST
62792: LIST
62793: PPUSH
62794: EMPTY
62795: PPUSH
62796: CALL 20685 0 3
62800: ST_TO_ADDR
62801: GO 62835
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , need_heal_1 ) ;
62803: LD_ADDR_EXP 61
62807: PUSH
62808: LD_EXP 61
62812: PPUSH
62813: LD_VAR 0 2
62817: PUSH
62818: LD_INT 1
62820: PUSH
62821: EMPTY
62822: LIST
62823: LIST
62824: PPUSH
62825: LD_VAR 0 6
62829: PPUSH
62830: CALL 20685 0 3
62834: ST_TO_ADDR
// if not need_heal_2 then
62835: LD_VAR 0 7
62839: NOT
62840: IFFALSE 62873
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , [ ] ) else
62842: LD_ADDR_EXP 61
62846: PUSH
62847: LD_EXP 61
62851: PPUSH
62852: LD_VAR 0 2
62856: PUSH
62857: LD_INT 2
62859: PUSH
62860: EMPTY
62861: LIST
62862: LIST
62863: PPUSH
62864: EMPTY
62865: PPUSH
62866: CALL 20685 0 3
62870: ST_TO_ADDR
62871: GO 62905
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62873: LD_ADDR_EXP 61
62877: PUSH
62878: LD_EXP 61
62882: PPUSH
62883: LD_VAR 0 2
62887: PUSH
62888: LD_INT 2
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PPUSH
62895: LD_VAR 0 7
62899: PPUSH
62900: CALL 20685 0 3
62904: ST_TO_ADDR
// if need_heal_2 then
62905: LD_VAR 0 7
62909: IFFALSE 63081
// for j in need_heal_2 do
62911: LD_ADDR_VAR 0 3
62915: PUSH
62916: LD_VAR 0 7
62920: PUSH
62921: FOR_IN
62922: IFFALSE 63079
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
62924: LD_ADDR_VAR 0 5
62928: PUSH
62929: LD_EXP 58
62933: PUSH
62934: LD_VAR 0 2
62938: ARRAY
62939: PPUSH
62940: LD_INT 2
62942: PUSH
62943: LD_INT 30
62945: PUSH
62946: LD_INT 6
62948: PUSH
62949: EMPTY
62950: LIST
62951: LIST
62952: PUSH
62953: LD_INT 30
62955: PUSH
62956: LD_INT 7
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: PUSH
62963: LD_INT 30
62965: PUSH
62966: LD_INT 8
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: PUSH
62973: LD_INT 30
62975: PUSH
62976: LD_INT 0
62978: PUSH
62979: EMPTY
62980: LIST
62981: LIST
62982: PUSH
62983: LD_INT 30
62985: PUSH
62986: LD_INT 1
62988: PUSH
62989: EMPTY
62990: LIST
62991: LIST
62992: PUSH
62993: LD_INT 25
62995: PUSH
62996: LD_INT 4
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: PPUSH
63012: CALL_OW 72
63016: ST_TO_ADDR
// if tmp then
63017: LD_VAR 0 5
63021: IFFALSE 63077
// begin k := NearestUnitToUnit ( tmp , j ) ;
63023: LD_ADDR_VAR 0 4
63027: PUSH
63028: LD_VAR 0 5
63032: PPUSH
63033: LD_VAR 0 3
63037: PPUSH
63038: CALL_OW 74
63042: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63043: LD_VAR 0 3
63047: PPUSH
63048: LD_VAR 0 4
63052: PPUSH
63053: CALL_OW 296
63057: PUSH
63058: LD_INT 7
63060: GREATER
63061: IFFALSE 63077
// ComMoveUnit ( j , k ) ;
63063: LD_VAR 0 3
63067: PPUSH
63068: LD_VAR 0 4
63072: PPUSH
63073: CALL_OW 112
// end ; end ;
63077: GO 62921
63079: POP
63080: POP
// if not need_heal_1 and not need_heal_2 then
63081: LD_VAR 0 6
63085: NOT
63086: PUSH
63087: LD_VAR 0 7
63091: NOT
63092: AND
63093: IFFALSE 63097
// continue ;
63095: GO 62588
// end ;
63097: GO 62588
63099: POP
63100: POP
// RaiseSailEvent ( 102 ) ;
63101: LD_INT 102
63103: PPUSH
63104: CALL_OW 427
// end ;
63108: LD_VAR 0 1
63112: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
63113: LD_INT 0
63115: PPUSH
63116: PPUSH
63117: PPUSH
63118: PPUSH
63119: PPUSH
// if not mc_bases then
63120: LD_EXP 58
63124: NOT
63125: IFFALSE 63129
// exit ;
63127: GO 63514
// for i = 1 to mc_bases do
63129: LD_ADDR_VAR 0 2
63133: PUSH
63134: DOUBLE
63135: LD_INT 1
63137: DEC
63138: ST_TO_ADDR
63139: LD_EXP 58
63143: PUSH
63144: FOR_TO
63145: IFFALSE 63512
// begin if not mc_building_need_repair [ i ] then
63147: LD_EXP 59
63151: PUSH
63152: LD_VAR 0 2
63156: ARRAY
63157: NOT
63158: IFFALSE 63196
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63160: LD_ADDR_EXP 60
63164: PUSH
63165: LD_EXP 60
63169: PPUSH
63170: LD_VAR 0 2
63174: PPUSH
63175: EMPTY
63176: PPUSH
63177: CALL_OW 1
63181: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63182: LD_VAR 0 2
63186: PPUSH
63187: LD_INT 101
63189: PPUSH
63190: CALL 58609 0 2
// continue ;
63194: GO 63144
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63196: LD_ADDR_EXP 64
63200: PUSH
63201: LD_EXP 64
63205: PPUSH
63206: LD_VAR 0 2
63210: PPUSH
63211: EMPTY
63212: PPUSH
63213: CALL_OW 1
63217: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63218: LD_VAR 0 2
63222: PPUSH
63223: LD_INT 103
63225: PPUSH
63226: CALL 58609 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63230: LD_ADDR_VAR 0 5
63234: PUSH
63235: LD_EXP 58
63239: PUSH
63240: LD_VAR 0 2
63244: ARRAY
63245: PUSH
63246: LD_EXP 87
63250: PUSH
63251: LD_VAR 0 2
63255: ARRAY
63256: UNION
63257: PPUSH
63258: LD_INT 2
63260: PUSH
63261: LD_INT 25
63263: PUSH
63264: LD_INT 2
63266: PUSH
63267: EMPTY
63268: LIST
63269: LIST
63270: PUSH
63271: LD_INT 25
63273: PUSH
63274: LD_INT 16
63276: PUSH
63277: EMPTY
63278: LIST
63279: LIST
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: LIST
63285: PUSH
63286: EMPTY
63287: LIST
63288: PPUSH
63289: CALL_OW 72
63293: ST_TO_ADDR
// if not tmp then
63294: LD_VAR 0 5
63298: NOT
63299: IFFALSE 63303
// continue ;
63301: GO 63144
// for j in tmp do
63303: LD_ADDR_VAR 0 3
63307: PUSH
63308: LD_VAR 0 5
63312: PUSH
63313: FOR_IN
63314: IFFALSE 63508
// begin if mc_need_heal [ i ] then
63316: LD_EXP 61
63320: PUSH
63321: LD_VAR 0 2
63325: ARRAY
63326: IFFALSE 63374
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63328: LD_VAR 0 3
63332: PUSH
63333: LD_EXP 61
63337: PUSH
63338: LD_VAR 0 2
63342: ARRAY
63343: PUSH
63344: LD_INT 1
63346: ARRAY
63347: IN
63348: PUSH
63349: LD_VAR 0 3
63353: PUSH
63354: LD_EXP 61
63358: PUSH
63359: LD_VAR 0 2
63363: ARRAY
63364: PUSH
63365: LD_INT 2
63367: ARRAY
63368: IN
63369: OR
63370: IFFALSE 63374
// continue ;
63372: GO 63313
// if IsInUnit ( j ) then
63374: LD_VAR 0 3
63378: PPUSH
63379: CALL_OW 310
63383: IFFALSE 63394
// ComExitBuilding ( j ) ;
63385: LD_VAR 0 3
63389: PPUSH
63390: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63394: LD_VAR 0 3
63398: PUSH
63399: LD_EXP 60
63403: PUSH
63404: LD_VAR 0 2
63408: ARRAY
63409: IN
63410: NOT
63411: IFFALSE 63469
// begin SetTag ( j , 101 ) ;
63413: LD_VAR 0 3
63417: PPUSH
63418: LD_INT 101
63420: PPUSH
63421: CALL_OW 109
// mc_building_repairs := Add ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63425: LD_ADDR_EXP 60
63429: PUSH
63430: LD_EXP 60
63434: PPUSH
63435: LD_VAR 0 2
63439: PUSH
63440: LD_EXP 60
63444: PUSH
63445: LD_VAR 0 2
63449: ARRAY
63450: PUSH
63451: LD_INT 1
63453: PLUS
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: PPUSH
63459: LD_VAR 0 3
63463: PPUSH
63464: CALL 20685 0 3
63468: ST_TO_ADDR
// end ; Wait ( 3 ) ;
63469: LD_INT 3
63471: PPUSH
63472: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
63476: LD_VAR 0 3
63480: PPUSH
63481: LD_EXP 59
63485: PUSH
63486: LD_VAR 0 2
63490: ARRAY
63491: PPUSH
63492: LD_VAR 0 3
63496: PPUSH
63497: CALL_OW 74
63501: PPUSH
63502: CALL_OW 130
// end ;
63506: GO 63313
63508: POP
63509: POP
// end ;
63510: GO 63144
63512: POP
63513: POP
// end ;
63514: LD_VAR 0 1
63518: RET
// export function MC_Heal ; var i , j , tmp ; begin
63519: LD_INT 0
63521: PPUSH
63522: PPUSH
63523: PPUSH
63524: PPUSH
// if not mc_bases then
63525: LD_EXP 58
63529: NOT
63530: IFFALSE 63534
// exit ;
63532: GO 63936
// for i = 1 to mc_bases do
63534: LD_ADDR_VAR 0 2
63538: PUSH
63539: DOUBLE
63540: LD_INT 1
63542: DEC
63543: ST_TO_ADDR
63544: LD_EXP 58
63548: PUSH
63549: FOR_TO
63550: IFFALSE 63934
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63552: LD_EXP 61
63556: PUSH
63557: LD_VAR 0 2
63561: ARRAY
63562: PUSH
63563: LD_INT 1
63565: ARRAY
63566: NOT
63567: PUSH
63568: LD_EXP 61
63572: PUSH
63573: LD_VAR 0 2
63577: ARRAY
63578: PUSH
63579: LD_INT 2
63581: ARRAY
63582: NOT
63583: AND
63584: IFFALSE 63622
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63586: LD_ADDR_EXP 62
63590: PUSH
63591: LD_EXP 62
63595: PPUSH
63596: LD_VAR 0 2
63600: PPUSH
63601: EMPTY
63602: PPUSH
63603: CALL_OW 1
63607: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63608: LD_VAR 0 2
63612: PPUSH
63613: LD_INT 102
63615: PPUSH
63616: CALL 58609 0 2
// continue ;
63620: GO 63549
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63622: LD_ADDR_VAR 0 4
63626: PUSH
63627: LD_EXP 58
63631: PUSH
63632: LD_VAR 0 2
63636: ARRAY
63637: PPUSH
63638: LD_INT 25
63640: PUSH
63641: LD_INT 4
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PPUSH
63648: CALL_OW 72
63652: ST_TO_ADDR
// if not tmp then
63653: LD_VAR 0 4
63657: NOT
63658: IFFALSE 63662
// continue ;
63660: GO 63549
// if mc_taming [ i ] then
63662: LD_EXP 89
63666: PUSH
63667: LD_VAR 0 2
63671: ARRAY
63672: IFFALSE 63696
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63674: LD_ADDR_EXP 89
63678: PUSH
63679: LD_EXP 89
63683: PPUSH
63684: LD_VAR 0 2
63688: PPUSH
63689: EMPTY
63690: PPUSH
63691: CALL_OW 1
63695: ST_TO_ADDR
// for j in tmp do
63696: LD_ADDR_VAR 0 3
63700: PUSH
63701: LD_VAR 0 4
63705: PUSH
63706: FOR_IN
63707: IFFALSE 63930
// begin if IsInUnit ( j ) then
63709: LD_VAR 0 3
63713: PPUSH
63714: CALL_OW 310
63718: IFFALSE 63729
// ComExitBuilding ( j ) ;
63720: LD_VAR 0 3
63724: PPUSH
63725: CALL_OW 122
// if not j in mc_healers [ i ] then
63729: LD_VAR 0 3
63733: PUSH
63734: LD_EXP 62
63738: PUSH
63739: LD_VAR 0 2
63743: ARRAY
63744: IN
63745: NOT
63746: IFFALSE 63792
// mc_healers := Add ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63748: LD_ADDR_EXP 62
63752: PUSH
63753: LD_EXP 62
63757: PPUSH
63758: LD_VAR 0 2
63762: PUSH
63763: LD_EXP 62
63767: PUSH
63768: LD_VAR 0 2
63772: ARRAY
63773: PUSH
63774: LD_INT 1
63776: PLUS
63777: PUSH
63778: EMPTY
63779: LIST
63780: LIST
63781: PPUSH
63782: LD_VAR 0 3
63786: PPUSH
63787: CALL 20685 0 3
63791: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63792: LD_VAR 0 3
63796: PPUSH
63797: CALL_OW 110
63801: PUSH
63802: LD_INT 102
63804: NONEQUAL
63805: IFFALSE 63819
// SetTag ( j , 102 ) ;
63807: LD_VAR 0 3
63811: PPUSH
63812: LD_INT 102
63814: PPUSH
63815: CALL_OW 109
// Wait ( 3 ) ;
63819: LD_INT 3
63821: PPUSH
63822: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63826: LD_EXP 61
63830: PUSH
63831: LD_VAR 0 2
63835: ARRAY
63836: PUSH
63837: LD_INT 1
63839: ARRAY
63840: IFFALSE 63872
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63842: LD_VAR 0 3
63846: PPUSH
63847: LD_EXP 61
63851: PUSH
63852: LD_VAR 0 2
63856: ARRAY
63857: PUSH
63858: LD_INT 1
63860: ARRAY
63861: PUSH
63862: LD_INT 1
63864: ARRAY
63865: PPUSH
63866: CALL_OW 128
63870: GO 63928
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63872: LD_VAR 0 3
63876: PPUSH
63877: CALL_OW 314
63881: NOT
63882: PUSH
63883: LD_EXP 61
63887: PUSH
63888: LD_VAR 0 2
63892: ARRAY
63893: PUSH
63894: LD_INT 2
63896: ARRAY
63897: AND
63898: IFFALSE 63928
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63900: LD_VAR 0 3
63904: PPUSH
63905: LD_EXP 61
63909: PUSH
63910: LD_VAR 0 2
63914: ARRAY
63915: PUSH
63916: LD_INT 2
63918: ARRAY
63919: PUSH
63920: LD_INT 1
63922: ARRAY
63923: PPUSH
63924: CALL_OW 128
// end ;
63928: GO 63706
63930: POP
63931: POP
// end ;
63932: GO 63549
63934: POP
63935: POP
// end ;
63936: LD_VAR 0 1
63940: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
63941: LD_INT 0
63943: PPUSH
63944: PPUSH
63945: PPUSH
63946: PPUSH
63947: PPUSH
// if not mc_bases then
63948: LD_EXP 58
63952: NOT
63953: IFFALSE 63957
// exit ;
63955: GO 65100
// for i = 1 to mc_bases do
63957: LD_ADDR_VAR 0 2
63961: PUSH
63962: DOUBLE
63963: LD_INT 1
63965: DEC
63966: ST_TO_ADDR
63967: LD_EXP 58
63971: PUSH
63972: FOR_TO
63973: IFFALSE 65098
// begin if mc_scan [ i ] then
63975: LD_EXP 81
63979: PUSH
63980: LD_VAR 0 2
63984: ARRAY
63985: IFFALSE 63989
// continue ;
63987: GO 63972
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
63989: LD_EXP 63
63993: PUSH
63994: LD_VAR 0 2
63998: ARRAY
63999: NOT
64000: PUSH
64001: LD_EXP 65
64005: PUSH
64006: LD_VAR 0 2
64010: ARRAY
64011: NOT
64012: AND
64013: PUSH
64014: LD_EXP 64
64018: PUSH
64019: LD_VAR 0 2
64023: ARRAY
64024: AND
64025: IFFALSE 64063
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64027: LD_ADDR_EXP 64
64031: PUSH
64032: LD_EXP 64
64036: PPUSH
64037: LD_VAR 0 2
64041: PPUSH
64042: EMPTY
64043: PPUSH
64044: CALL_OW 1
64048: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64049: LD_VAR 0 2
64053: PPUSH
64054: LD_INT 103
64056: PPUSH
64057: CALL 58609 0 2
// continue ;
64061: GO 63972
// end ; if mc_construct_list [ i ] then
64063: LD_EXP 65
64067: PUSH
64068: LD_VAR 0 2
64072: ARRAY
64073: IFFALSE 64293
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64075: LD_ADDR_VAR 0 4
64079: PUSH
64080: LD_EXP 58
64084: PUSH
64085: LD_VAR 0 2
64089: ARRAY
64090: PPUSH
64091: LD_INT 25
64093: PUSH
64094: LD_INT 2
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PPUSH
64101: CALL_OW 72
64105: PUSH
64106: LD_EXP 60
64110: PUSH
64111: LD_VAR 0 2
64115: ARRAY
64116: DIFF
64117: ST_TO_ADDR
// if not tmp then
64118: LD_VAR 0 4
64122: NOT
64123: IFFALSE 64127
// continue ;
64125: GO 63972
// for j in tmp do
64127: LD_ADDR_VAR 0 3
64131: PUSH
64132: LD_VAR 0 4
64136: PUSH
64137: FOR_IN
64138: IFFALSE 64289
// begin if not mc_builders [ i ] then
64140: LD_EXP 64
64144: PUSH
64145: LD_VAR 0 2
64149: ARRAY
64150: NOT
64151: IFFALSE 64209
// begin SetTag ( j , 103 ) ;
64153: LD_VAR 0 3
64157: PPUSH
64158: LD_INT 103
64160: PPUSH
64161: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64165: LD_ADDR_EXP 64
64169: PUSH
64170: LD_EXP 64
64174: PPUSH
64175: LD_VAR 0 2
64179: PUSH
64180: LD_EXP 64
64184: PUSH
64185: LD_VAR 0 2
64189: ARRAY
64190: PUSH
64191: LD_INT 1
64193: PLUS
64194: PUSH
64195: EMPTY
64196: LIST
64197: LIST
64198: PPUSH
64199: LD_VAR 0 3
64203: PPUSH
64204: CALL 20685 0 3
64208: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64209: LD_VAR 0 3
64213: PPUSH
64214: CALL_OW 310
64218: IFFALSE 64229
// ComExitBuilding ( j ) ;
64220: LD_VAR 0 3
64224: PPUSH
64225: CALL_OW 122
// wait ( 3 ) ;
64229: LD_INT 3
64231: PPUSH
64232: CALL_OW 67
// if not mc_construct_list [ i ] then
64236: LD_EXP 65
64240: PUSH
64241: LD_VAR 0 2
64245: ARRAY
64246: NOT
64247: IFFALSE 64251
// break ;
64249: GO 64289
// if not HasTask ( j ) then
64251: LD_VAR 0 3
64255: PPUSH
64256: CALL_OW 314
64260: NOT
64261: IFFALSE 64287
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64263: LD_VAR 0 3
64267: PPUSH
64268: LD_EXP 65
64272: PUSH
64273: LD_VAR 0 2
64277: ARRAY
64278: PUSH
64279: LD_INT 1
64281: ARRAY
64282: PPUSH
64283: CALL 23121 0 2
// end ;
64287: GO 64137
64289: POP
64290: POP
// end else
64291: GO 65096
// if mc_build_list [ i ] then
64293: LD_EXP 63
64297: PUSH
64298: LD_VAR 0 2
64302: ARRAY
64303: IFFALSE 65096
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64305: LD_ADDR_VAR 0 5
64309: PUSH
64310: LD_EXP 58
64314: PUSH
64315: LD_VAR 0 2
64319: ARRAY
64320: PPUSH
64321: LD_INT 2
64323: PUSH
64324: LD_INT 30
64326: PUSH
64327: LD_INT 0
64329: PUSH
64330: EMPTY
64331: LIST
64332: LIST
64333: PUSH
64334: LD_INT 30
64336: PUSH
64337: LD_INT 1
64339: PUSH
64340: EMPTY
64341: LIST
64342: LIST
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: LIST
64348: PPUSH
64349: CALL_OW 72
64353: ST_TO_ADDR
// if depot then
64354: LD_VAR 0 5
64358: IFFALSE 64376
// depot := depot [ 1 ] else
64360: LD_ADDR_VAR 0 5
64364: PUSH
64365: LD_VAR 0 5
64369: PUSH
64370: LD_INT 1
64372: ARRAY
64373: ST_TO_ADDR
64374: GO 64384
// depot := 0 ;
64376: LD_ADDR_VAR 0 5
64380: PUSH
64381: LD_INT 0
64383: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64384: LD_EXP 63
64388: PUSH
64389: LD_VAR 0 2
64393: ARRAY
64394: PUSH
64395: LD_INT 1
64397: ARRAY
64398: PUSH
64399: LD_INT 1
64401: ARRAY
64402: PPUSH
64403: CALL 22964 0 1
64407: PUSH
64408: LD_EXP 58
64412: PUSH
64413: LD_VAR 0 2
64417: ARRAY
64418: PPUSH
64419: LD_INT 2
64421: PUSH
64422: LD_INT 30
64424: PUSH
64425: LD_INT 2
64427: PUSH
64428: EMPTY
64429: LIST
64430: LIST
64431: PUSH
64432: LD_INT 30
64434: PUSH
64435: LD_INT 3
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PUSH
64442: EMPTY
64443: LIST
64444: LIST
64445: LIST
64446: PPUSH
64447: CALL_OW 72
64451: NOT
64452: AND
64453: IFFALSE 64558
// begin for j = 1 to mc_build_list [ i ] do
64455: LD_ADDR_VAR 0 3
64459: PUSH
64460: DOUBLE
64461: LD_INT 1
64463: DEC
64464: ST_TO_ADDR
64465: LD_EXP 63
64469: PUSH
64470: LD_VAR 0 2
64474: ARRAY
64475: PUSH
64476: FOR_TO
64477: IFFALSE 64556
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64479: LD_EXP 63
64483: PUSH
64484: LD_VAR 0 2
64488: ARRAY
64489: PUSH
64490: LD_VAR 0 3
64494: ARRAY
64495: PUSH
64496: LD_INT 1
64498: ARRAY
64499: PUSH
64500: LD_INT 2
64502: EQUAL
64503: IFFALSE 64554
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64505: LD_ADDR_EXP 63
64509: PUSH
64510: LD_EXP 63
64514: PPUSH
64515: LD_VAR 0 2
64519: PPUSH
64520: LD_EXP 63
64524: PUSH
64525: LD_VAR 0 2
64529: ARRAY
64530: PPUSH
64531: LD_VAR 0 3
64535: PPUSH
64536: LD_INT 1
64538: PPUSH
64539: LD_INT 0
64541: PPUSH
64542: CALL 19668 0 4
64546: PPUSH
64547: CALL_OW 1
64551: ST_TO_ADDR
// break ;
64552: GO 64556
// end ;
64554: GO 64476
64556: POP
64557: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64558: LD_EXP 63
64562: PUSH
64563: LD_VAR 0 2
64567: ARRAY
64568: PUSH
64569: LD_INT 1
64571: ARRAY
64572: PUSH
64573: LD_INT 1
64575: ARRAY
64576: PUSH
64577: LD_INT 0
64579: EQUAL
64580: PUSH
64581: LD_VAR 0 5
64585: PUSH
64586: LD_VAR 0 5
64590: PPUSH
64591: LD_EXP 63
64595: PUSH
64596: LD_VAR 0 2
64600: ARRAY
64601: PUSH
64602: LD_INT 1
64604: ARRAY
64605: PUSH
64606: LD_INT 1
64608: ARRAY
64609: PPUSH
64610: LD_EXP 63
64614: PUSH
64615: LD_VAR 0 2
64619: ARRAY
64620: PUSH
64621: LD_INT 1
64623: ARRAY
64624: PUSH
64625: LD_INT 2
64627: ARRAY
64628: PPUSH
64629: LD_EXP 63
64633: PUSH
64634: LD_VAR 0 2
64638: ARRAY
64639: PUSH
64640: LD_INT 1
64642: ARRAY
64643: PUSH
64644: LD_INT 3
64646: ARRAY
64647: PPUSH
64648: LD_EXP 63
64652: PUSH
64653: LD_VAR 0 2
64657: ARRAY
64658: PUSH
64659: LD_INT 1
64661: ARRAY
64662: PUSH
64663: LD_INT 4
64665: ARRAY
64666: PPUSH
64667: CALL 27473 0 5
64671: AND
64672: OR
64673: IFFALSE 64954
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64675: LD_ADDR_VAR 0 4
64679: PUSH
64680: LD_EXP 58
64684: PUSH
64685: LD_VAR 0 2
64689: ARRAY
64690: PPUSH
64691: LD_INT 25
64693: PUSH
64694: LD_INT 2
64696: PUSH
64697: EMPTY
64698: LIST
64699: LIST
64700: PPUSH
64701: CALL_OW 72
64705: PUSH
64706: LD_EXP 60
64710: PUSH
64711: LD_VAR 0 2
64715: ARRAY
64716: DIFF
64717: ST_TO_ADDR
// if not tmp then
64718: LD_VAR 0 4
64722: NOT
64723: IFFALSE 64727
// continue ;
64725: GO 63972
// for j in tmp do
64727: LD_ADDR_VAR 0 3
64731: PUSH
64732: LD_VAR 0 4
64736: PUSH
64737: FOR_IN
64738: IFFALSE 64950
// begin if not mc_builders [ i ] then
64740: LD_EXP 64
64744: PUSH
64745: LD_VAR 0 2
64749: ARRAY
64750: NOT
64751: IFFALSE 64809
// begin SetTag ( j , 103 ) ;
64753: LD_VAR 0 3
64757: PPUSH
64758: LD_INT 103
64760: PPUSH
64761: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64765: LD_ADDR_EXP 64
64769: PUSH
64770: LD_EXP 64
64774: PPUSH
64775: LD_VAR 0 2
64779: PUSH
64780: LD_EXP 64
64784: PUSH
64785: LD_VAR 0 2
64789: ARRAY
64790: PUSH
64791: LD_INT 1
64793: PLUS
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: PPUSH
64799: LD_VAR 0 3
64803: PPUSH
64804: CALL 20685 0 3
64808: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64809: LD_VAR 0 3
64813: PPUSH
64814: CALL_OW 310
64818: IFFALSE 64829
// ComExitBuilding ( j ) ;
64820: LD_VAR 0 3
64824: PPUSH
64825: CALL_OW 122
// wait ( 3 ) ;
64829: LD_INT 3
64831: PPUSH
64832: CALL_OW 67
// if not mc_build_list [ i ] then
64836: LD_EXP 63
64840: PUSH
64841: LD_VAR 0 2
64845: ARRAY
64846: NOT
64847: IFFALSE 64851
// break ;
64849: GO 64950
// if not HasTask ( j ) then
64851: LD_VAR 0 3
64855: PPUSH
64856: CALL_OW 314
64860: NOT
64861: IFFALSE 64948
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64863: LD_VAR 0 3
64867: PPUSH
64868: LD_EXP 63
64872: PUSH
64873: LD_VAR 0 2
64877: ARRAY
64878: PUSH
64879: LD_INT 1
64881: ARRAY
64882: PUSH
64883: LD_INT 1
64885: ARRAY
64886: PPUSH
64887: LD_EXP 63
64891: PUSH
64892: LD_VAR 0 2
64896: ARRAY
64897: PUSH
64898: LD_INT 1
64900: ARRAY
64901: PUSH
64902: LD_INT 2
64904: ARRAY
64905: PPUSH
64906: LD_EXP 63
64910: PUSH
64911: LD_VAR 0 2
64915: ARRAY
64916: PUSH
64917: LD_INT 1
64919: ARRAY
64920: PUSH
64921: LD_INT 3
64923: ARRAY
64924: PPUSH
64925: LD_EXP 63
64929: PUSH
64930: LD_VAR 0 2
64934: ARRAY
64935: PUSH
64936: LD_INT 1
64938: ARRAY
64939: PUSH
64940: LD_INT 4
64942: ARRAY
64943: PPUSH
64944: CALL_OW 145
// end ;
64948: GO 64737
64950: POP
64951: POP
// end else
64952: GO 65096
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
64954: LD_EXP 58
64958: PUSH
64959: LD_VAR 0 2
64963: ARRAY
64964: PPUSH
64965: LD_EXP 63
64969: PUSH
64970: LD_VAR 0 2
64974: ARRAY
64975: PUSH
64976: LD_INT 1
64978: ARRAY
64979: PUSH
64980: LD_INT 1
64982: ARRAY
64983: PPUSH
64984: LD_EXP 63
64988: PUSH
64989: LD_VAR 0 2
64993: ARRAY
64994: PUSH
64995: LD_INT 1
64997: ARRAY
64998: PUSH
64999: LD_INT 2
65001: ARRAY
65002: PPUSH
65003: LD_EXP 63
65007: PUSH
65008: LD_VAR 0 2
65012: ARRAY
65013: PUSH
65014: LD_INT 1
65016: ARRAY
65017: PUSH
65018: LD_INT 3
65020: ARRAY
65021: PPUSH
65022: LD_EXP 63
65026: PUSH
65027: LD_VAR 0 2
65031: ARRAY
65032: PUSH
65033: LD_INT 1
65035: ARRAY
65036: PUSH
65037: LD_INT 4
65039: ARRAY
65040: PPUSH
65041: CALL 26904 0 5
65045: NOT
65046: IFFALSE 65096
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65048: LD_ADDR_EXP 63
65052: PUSH
65053: LD_EXP 63
65057: PPUSH
65058: LD_VAR 0 2
65062: PPUSH
65063: LD_EXP 63
65067: PUSH
65068: LD_VAR 0 2
65072: ARRAY
65073: PPUSH
65074: LD_INT 1
65076: PPUSH
65077: LD_INT 1
65079: NEG
65080: PPUSH
65081: LD_INT 0
65083: PPUSH
65084: CALL 19668 0 4
65088: PPUSH
65089: CALL_OW 1
65093: ST_TO_ADDR
// continue ;
65094: GO 63972
// end ; end ; end ;
65096: GO 63972
65098: POP
65099: POP
// end ;
65100: LD_VAR 0 1
65104: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65105: LD_INT 0
65107: PPUSH
65108: PPUSH
65109: PPUSH
65110: PPUSH
65111: PPUSH
65112: PPUSH
// if not mc_bases then
65113: LD_EXP 58
65117: NOT
65118: IFFALSE 65122
// exit ;
65120: GO 65549
// for i = 1 to mc_bases do
65122: LD_ADDR_VAR 0 2
65126: PUSH
65127: DOUBLE
65128: LD_INT 1
65130: DEC
65131: ST_TO_ADDR
65132: LD_EXP 58
65136: PUSH
65137: FOR_TO
65138: IFFALSE 65547
// begin tmp := mc_build_upgrade [ i ] ;
65140: LD_ADDR_VAR 0 4
65144: PUSH
65145: LD_EXP 90
65149: PUSH
65150: LD_VAR 0 2
65154: ARRAY
65155: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65156: LD_ADDR_VAR 0 6
65160: PUSH
65161: LD_EXP 91
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PPUSH
65172: LD_INT 2
65174: PUSH
65175: LD_INT 30
65177: PUSH
65178: LD_INT 6
65180: PUSH
65181: EMPTY
65182: LIST
65183: LIST
65184: PUSH
65185: LD_INT 30
65187: PUSH
65188: LD_INT 7
65190: PUSH
65191: EMPTY
65192: LIST
65193: LIST
65194: PUSH
65195: EMPTY
65196: LIST
65197: LIST
65198: LIST
65199: PPUSH
65200: CALL_OW 72
65204: ST_TO_ADDR
// if not tmp and not lab then
65205: LD_VAR 0 4
65209: NOT
65210: PUSH
65211: LD_VAR 0 6
65215: NOT
65216: AND
65217: IFFALSE 65221
// continue ;
65219: GO 65137
// if tmp then
65221: LD_VAR 0 4
65225: IFFALSE 65345
// for j in tmp do
65227: LD_ADDR_VAR 0 3
65231: PUSH
65232: LD_VAR 0 4
65236: PUSH
65237: FOR_IN
65238: IFFALSE 65343
// begin if UpgradeCost ( j ) then
65240: LD_VAR 0 3
65244: PPUSH
65245: CALL 26564 0 1
65249: IFFALSE 65341
// begin ComUpgrade ( j ) ;
65251: LD_VAR 0 3
65255: PPUSH
65256: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65260: LD_ADDR_EXP 90
65264: PUSH
65265: LD_EXP 90
65269: PPUSH
65270: LD_VAR 0 2
65274: PPUSH
65275: LD_EXP 90
65279: PUSH
65280: LD_VAR 0 2
65284: ARRAY
65285: PUSH
65286: LD_VAR 0 3
65290: DIFF
65291: PPUSH
65292: CALL_OW 1
65296: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65297: LD_ADDR_EXP 65
65301: PUSH
65302: LD_EXP 65
65306: PPUSH
65307: LD_VAR 0 2
65311: PUSH
65312: LD_EXP 65
65316: PUSH
65317: LD_VAR 0 2
65321: ARRAY
65322: PUSH
65323: LD_INT 1
65325: PLUS
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PPUSH
65331: LD_VAR 0 3
65335: PPUSH
65336: CALL 20685 0 3
65340: ST_TO_ADDR
// end ; end ;
65341: GO 65237
65343: POP
65344: POP
// if not lab or not mc_lab_upgrade [ i ] then
65345: LD_VAR 0 6
65349: NOT
65350: PUSH
65351: LD_EXP 92
65355: PUSH
65356: LD_VAR 0 2
65360: ARRAY
65361: NOT
65362: OR
65363: IFFALSE 65367
// continue ;
65365: GO 65137
// for j in lab do
65367: LD_ADDR_VAR 0 3
65371: PUSH
65372: LD_VAR 0 6
65376: PUSH
65377: FOR_IN
65378: IFFALSE 65543
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65380: LD_VAR 0 3
65384: PPUSH
65385: CALL_OW 266
65389: PUSH
65390: LD_INT 6
65392: PUSH
65393: LD_INT 7
65395: PUSH
65396: EMPTY
65397: LIST
65398: LIST
65399: IN
65400: PUSH
65401: LD_VAR 0 3
65405: PPUSH
65406: CALL_OW 461
65410: PUSH
65411: LD_INT 1
65413: NONEQUAL
65414: AND
65415: IFFALSE 65541
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65417: LD_VAR 0 3
65421: PPUSH
65422: LD_EXP 92
65426: PUSH
65427: LD_VAR 0 2
65431: ARRAY
65432: PUSH
65433: LD_INT 1
65435: ARRAY
65436: PPUSH
65437: CALL 26769 0 2
65441: IFFALSE 65541
// begin ComCancel ( j ) ;
65443: LD_VAR 0 3
65447: PPUSH
65448: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65452: LD_VAR 0 3
65456: PPUSH
65457: LD_EXP 92
65461: PUSH
65462: LD_VAR 0 2
65466: ARRAY
65467: PUSH
65468: LD_INT 1
65470: ARRAY
65471: PPUSH
65472: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65476: LD_VAR 0 3
65480: PUSH
65481: LD_EXP 65
65485: PUSH
65486: LD_VAR 0 2
65490: ARRAY
65491: IN
65492: NOT
65493: IFFALSE 65539
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65495: LD_ADDR_EXP 65
65499: PUSH
65500: LD_EXP 65
65504: PPUSH
65505: LD_VAR 0 2
65509: PUSH
65510: LD_EXP 65
65514: PUSH
65515: LD_VAR 0 2
65519: ARRAY
65520: PUSH
65521: LD_INT 1
65523: PLUS
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PPUSH
65529: LD_VAR 0 3
65533: PPUSH
65534: CALL 20685 0 3
65538: ST_TO_ADDR
// break ;
65539: GO 65543
// end ; end ; end ;
65541: GO 65377
65543: POP
65544: POP
// end ;
65545: GO 65137
65547: POP
65548: POP
// end ;
65549: LD_VAR 0 1
65553: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65554: LD_INT 0
65556: PPUSH
65557: PPUSH
65558: PPUSH
65559: PPUSH
65560: PPUSH
65561: PPUSH
65562: PPUSH
65563: PPUSH
65564: PPUSH
// if not mc_bases then
65565: LD_EXP 58
65569: NOT
65570: IFFALSE 65574
// exit ;
65572: GO 65968
// for i = 1 to mc_bases do
65574: LD_ADDR_VAR 0 2
65578: PUSH
65579: DOUBLE
65580: LD_INT 1
65582: DEC
65583: ST_TO_ADDR
65584: LD_EXP 58
65588: PUSH
65589: FOR_TO
65590: IFFALSE 65966
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65592: LD_EXP 66
65596: PUSH
65597: LD_VAR 0 2
65601: ARRAY
65602: NOT
65603: PUSH
65604: LD_EXP 58
65608: PUSH
65609: LD_VAR 0 2
65613: ARRAY
65614: PPUSH
65615: LD_INT 30
65617: PUSH
65618: LD_INT 3
65620: PUSH
65621: EMPTY
65622: LIST
65623: LIST
65624: PPUSH
65625: CALL_OW 72
65629: NOT
65630: OR
65631: IFFALSE 65635
// continue ;
65633: GO 65589
// busy := false ;
65635: LD_ADDR_VAR 0 8
65639: PUSH
65640: LD_INT 0
65642: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65643: LD_ADDR_VAR 0 4
65647: PUSH
65648: LD_EXP 58
65652: PUSH
65653: LD_VAR 0 2
65657: ARRAY
65658: PPUSH
65659: LD_INT 30
65661: PUSH
65662: LD_INT 3
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PPUSH
65669: CALL_OW 72
65673: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65674: LD_ADDR_VAR 0 6
65678: PUSH
65679: LD_EXP 66
65683: PUSH
65684: LD_VAR 0 2
65688: ARRAY
65689: PPUSH
65690: LD_INT 2
65692: PUSH
65693: LD_INT 30
65695: PUSH
65696: LD_INT 32
65698: PUSH
65699: EMPTY
65700: LIST
65701: LIST
65702: PUSH
65703: LD_INT 30
65705: PUSH
65706: LD_INT 33
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: LIST
65717: PPUSH
65718: CALL_OW 72
65722: ST_TO_ADDR
// if not t then
65723: LD_VAR 0 6
65727: NOT
65728: IFFALSE 65732
// continue ;
65730: GO 65589
// for j in tmp do
65732: LD_ADDR_VAR 0 3
65736: PUSH
65737: LD_VAR 0 4
65741: PUSH
65742: FOR_IN
65743: IFFALSE 65773
// if not BuildingStatus ( j ) = bs_idle then
65745: LD_VAR 0 3
65749: PPUSH
65750: CALL_OW 461
65754: PUSH
65755: LD_INT 2
65757: EQUAL
65758: NOT
65759: IFFALSE 65771
// begin busy := true ;
65761: LD_ADDR_VAR 0 8
65765: PUSH
65766: LD_INT 1
65768: ST_TO_ADDR
// break ;
65769: GO 65773
// end ;
65771: GO 65742
65773: POP
65774: POP
// if busy then
65775: LD_VAR 0 8
65779: IFFALSE 65783
// continue ;
65781: GO 65589
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65783: LD_ADDR_VAR 0 7
65787: PUSH
65788: LD_VAR 0 6
65792: PPUSH
65793: LD_INT 35
65795: PUSH
65796: LD_INT 0
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PPUSH
65803: CALL_OW 72
65807: ST_TO_ADDR
// if tw then
65808: LD_VAR 0 7
65812: IFFALSE 65878
// begin tw := tw [ 1 ] ;
65814: LD_ADDR_VAR 0 7
65818: PUSH
65819: LD_VAR 0 7
65823: PUSH
65824: LD_INT 1
65826: ARRAY
65827: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw ) ;
65828: LD_ADDR_VAR 0 9
65832: PUSH
65833: LD_VAR 0 7
65837: PPUSH
65838: CALL 25128 0 1
65842: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65843: LD_EXP 97
65847: PUSH
65848: LD_VAR 0 2
65852: ARRAY
65853: IFFALSE 65876
// if not weapon in mc_allowed_tower_weapons [ i ] then
65855: LD_VAR 0 9
65859: PUSH
65860: LD_EXP 97
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: IN
65871: NOT
65872: IFFALSE 65876
// continue ;
65874: GO 65589
// end else
65876: GO 65941
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65878: LD_ADDR_VAR 0 5
65882: PUSH
65883: LD_EXP 66
65887: PUSH
65888: LD_VAR 0 2
65892: ARRAY
65893: PPUSH
65894: LD_VAR 0 4
65898: PPUSH
65899: CALL 55177 0 2
65903: ST_TO_ADDR
// if not tmp2 then
65904: LD_VAR 0 5
65908: NOT
65909: IFFALSE 65913
// continue ;
65911: GO 65589
// tw := tmp2 [ 1 ] ;
65913: LD_ADDR_VAR 0 7
65917: PUSH
65918: LD_VAR 0 5
65922: PUSH
65923: LD_INT 1
65925: ARRAY
65926: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65927: LD_ADDR_VAR 0 9
65931: PUSH
65932: LD_VAR 0 5
65936: PUSH
65937: LD_INT 2
65939: ARRAY
65940: ST_TO_ADDR
// end ; if not weapon then
65941: LD_VAR 0 9
65945: NOT
65946: IFFALSE 65950
// continue ;
65948: GO 65589
// ComPlaceWeapon ( tw , weapon ) ;
65950: LD_VAR 0 7
65954: PPUSH
65955: LD_VAR 0 9
65959: PPUSH
65960: CALL_OW 148
// end ;
65964: GO 65589
65966: POP
65967: POP
// end ;
65968: LD_VAR 0 1
65972: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
65973: LD_INT 0
65975: PPUSH
65976: PPUSH
65977: PPUSH
65978: PPUSH
65979: PPUSH
65980: PPUSH
// if not mc_bases then
65981: LD_EXP 58
65985: NOT
65986: IFFALSE 65990
// exit ;
65988: GO 67002
// for i = 1 to mc_bases do
65990: LD_ADDR_VAR 0 2
65994: PUSH
65995: DOUBLE
65996: LD_INT 1
65998: DEC
65999: ST_TO_ADDR
66000: LD_EXP 58
66004: PUSH
66005: FOR_TO
66006: IFFALSE 67000
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
66008: LD_EXP 71
66012: PUSH
66013: LD_VAR 0 2
66017: ARRAY
66018: NOT
66019: PUSH
66020: LD_EXP 71
66024: PUSH
66025: LD_VAR 0 2
66029: ARRAY
66030: PUSH
66031: LD_EXP 72
66035: PUSH
66036: LD_VAR 0 2
66040: ARRAY
66041: EQUAL
66042: OR
66043: IFFALSE 66047
// continue ;
66045: GO 66005
// if mc_miners [ i ] then
66047: LD_EXP 72
66051: PUSH
66052: LD_VAR 0 2
66056: ARRAY
66057: IFFALSE 66687
// begin k := 1 ;
66059: LD_ADDR_VAR 0 4
66063: PUSH
66064: LD_INT 1
66066: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
66067: LD_ADDR_VAR 0 3
66071: PUSH
66072: DOUBLE
66073: LD_EXP 72
66077: PUSH
66078: LD_VAR 0 2
66082: ARRAY
66083: INC
66084: ST_TO_ADDR
66085: LD_INT 1
66087: PUSH
66088: FOR_DOWNTO
66089: IFFALSE 66685
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66091: LD_EXP 72
66095: PUSH
66096: LD_VAR 0 2
66100: ARRAY
66101: PUSH
66102: LD_VAR 0 3
66106: ARRAY
66107: PPUSH
66108: CALL_OW 301
66112: PUSH
66113: LD_EXP 72
66117: PUSH
66118: LD_VAR 0 2
66122: ARRAY
66123: PUSH
66124: LD_VAR 0 3
66128: ARRAY
66129: PPUSH
66130: CALL_OW 257
66134: PUSH
66135: LD_INT 1
66137: NONEQUAL
66138: OR
66139: IFFALSE 66202
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66141: LD_ADDR_VAR 0 5
66145: PUSH
66146: LD_EXP 72
66150: PUSH
66151: LD_VAR 0 2
66155: ARRAY
66156: PUSH
66157: LD_EXP 72
66161: PUSH
66162: LD_VAR 0 2
66166: ARRAY
66167: PUSH
66168: LD_VAR 0 3
66172: ARRAY
66173: DIFF
66174: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66175: LD_ADDR_EXP 72
66179: PUSH
66180: LD_EXP 72
66184: PPUSH
66185: LD_VAR 0 2
66189: PPUSH
66190: LD_VAR 0 5
66194: PPUSH
66195: CALL_OW 1
66199: ST_TO_ADDR
// continue ;
66200: GO 66088
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
66202: LD_EXP 72
66206: PUSH
66207: LD_VAR 0 2
66211: ARRAY
66212: PUSH
66213: LD_VAR 0 3
66217: ARRAY
66218: PPUSH
66219: CALL 20186 0 1
66223: PUSH
66224: LD_EXP 72
66228: PUSH
66229: LD_VAR 0 2
66233: ARRAY
66234: PUSH
66235: LD_VAR 0 3
66239: ARRAY
66240: PPUSH
66241: CALL_OW 255
66245: PPUSH
66246: LD_EXP 71
66250: PUSH
66251: LD_VAR 0 2
66255: ARRAY
66256: PUSH
66257: LD_VAR 0 4
66261: ARRAY
66262: PUSH
66263: LD_INT 1
66265: ARRAY
66266: PPUSH
66267: LD_EXP 71
66271: PUSH
66272: LD_VAR 0 2
66276: ARRAY
66277: PUSH
66278: LD_VAR 0 4
66282: ARRAY
66283: PUSH
66284: LD_INT 2
66286: ARRAY
66287: PPUSH
66288: LD_INT 15
66290: PPUSH
66291: CALL 21179 0 4
66295: PUSH
66296: LD_INT 4
66298: ARRAY
66299: PUSH
66300: LD_EXP 72
66304: PUSH
66305: LD_VAR 0 2
66309: ARRAY
66310: PUSH
66311: LD_VAR 0 3
66315: ARRAY
66316: PPUSH
66317: LD_INT 10
66319: PPUSH
66320: CALL 22876 0 2
66324: PUSH
66325: LD_INT 4
66327: ARRAY
66328: OR
66329: AND
66330: IFFALSE 66353
// ComStop ( mc_miners [ i ] [ j ] ) ;
66332: LD_EXP 72
66336: PUSH
66337: LD_VAR 0 2
66341: ARRAY
66342: PUSH
66343: LD_VAR 0 3
66347: ARRAY
66348: PPUSH
66349: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
66353: LD_EXP 72
66357: PUSH
66358: LD_VAR 0 2
66362: ARRAY
66363: PUSH
66364: LD_VAR 0 3
66368: ARRAY
66369: PPUSH
66370: CALL_OW 257
66374: PUSH
66375: LD_INT 1
66377: EQUAL
66378: PUSH
66379: LD_EXP 72
66383: PUSH
66384: LD_VAR 0 2
66388: ARRAY
66389: PUSH
66390: LD_VAR 0 3
66394: ARRAY
66395: PPUSH
66396: CALL_OW 459
66400: NOT
66401: AND
66402: PUSH
66403: LD_EXP 72
66407: PUSH
66408: LD_VAR 0 2
66412: ARRAY
66413: PUSH
66414: LD_VAR 0 3
66418: ARRAY
66419: PPUSH
66420: CALL_OW 255
66424: PPUSH
66425: LD_EXP 71
66429: PUSH
66430: LD_VAR 0 2
66434: ARRAY
66435: PUSH
66436: LD_VAR 0 4
66440: ARRAY
66441: PUSH
66442: LD_INT 1
66444: ARRAY
66445: PPUSH
66446: LD_EXP 71
66450: PUSH
66451: LD_VAR 0 2
66455: ARRAY
66456: PUSH
66457: LD_VAR 0 4
66461: ARRAY
66462: PUSH
66463: LD_INT 2
66465: ARRAY
66466: PPUSH
66467: LD_INT 15
66469: PPUSH
66470: CALL 21179 0 4
66474: PUSH
66475: LD_INT 4
66477: ARRAY
66478: PUSH
66479: LD_INT 0
66481: EQUAL
66482: AND
66483: PUSH
66484: LD_EXP 72
66488: PUSH
66489: LD_VAR 0 2
66493: ARRAY
66494: PUSH
66495: LD_VAR 0 3
66499: ARRAY
66500: PPUSH
66501: CALL_OW 314
66505: NOT
66506: AND
66507: IFFALSE 66683
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66509: LD_EXP 72
66513: PUSH
66514: LD_VAR 0 2
66518: ARRAY
66519: PUSH
66520: LD_VAR 0 3
66524: ARRAY
66525: PPUSH
66526: CALL_OW 310
66530: IFFALSE 66553
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66532: LD_EXP 72
66536: PUSH
66537: LD_VAR 0 2
66541: ARRAY
66542: PUSH
66543: LD_VAR 0 3
66547: ARRAY
66548: PPUSH
66549: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66553: LD_EXP 72
66557: PUSH
66558: LD_VAR 0 2
66562: ARRAY
66563: PUSH
66564: LD_VAR 0 3
66568: ARRAY
66569: PPUSH
66570: CALL_OW 314
66574: NOT
66575: IFFALSE 66643
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
66577: LD_EXP 72
66581: PUSH
66582: LD_VAR 0 2
66586: ARRAY
66587: PUSH
66588: LD_VAR 0 3
66592: ARRAY
66593: PPUSH
66594: LD_EXP 71
66598: PUSH
66599: LD_VAR 0 2
66603: ARRAY
66604: PUSH
66605: LD_VAR 0 4
66609: ARRAY
66610: PUSH
66611: LD_INT 1
66613: ARRAY
66614: PPUSH
66615: LD_EXP 71
66619: PUSH
66620: LD_VAR 0 2
66624: ARRAY
66625: PUSH
66626: LD_VAR 0 4
66630: ARRAY
66631: PUSH
66632: LD_INT 2
66634: ARRAY
66635: PPUSH
66636: LD_INT 0
66638: PPUSH
66639: CALL_OW 193
// k := k + 1 ;
66643: LD_ADDR_VAR 0 4
66647: PUSH
66648: LD_VAR 0 4
66652: PUSH
66653: LD_INT 1
66655: PLUS
66656: ST_TO_ADDR
// if k > mc_mines [ i ] then
66657: LD_VAR 0 4
66661: PUSH
66662: LD_EXP 71
66666: PUSH
66667: LD_VAR 0 2
66671: ARRAY
66672: GREATER
66673: IFFALSE 66683
// k := 1 ;
66675: LD_ADDR_VAR 0 4
66679: PUSH
66680: LD_INT 1
66682: ST_TO_ADDR
// end ; end ;
66683: GO 66088
66685: POP
66686: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66687: LD_ADDR_VAR 0 5
66691: PUSH
66692: LD_EXP 58
66696: PUSH
66697: LD_VAR 0 2
66701: ARRAY
66702: PPUSH
66703: LD_INT 2
66705: PUSH
66706: LD_INT 30
66708: PUSH
66709: LD_INT 4
66711: PUSH
66712: EMPTY
66713: LIST
66714: LIST
66715: PUSH
66716: LD_INT 30
66718: PUSH
66719: LD_INT 5
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: PUSH
66726: LD_INT 30
66728: PUSH
66729: LD_INT 32
66731: PUSH
66732: EMPTY
66733: LIST
66734: LIST
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: LIST
66740: LIST
66741: PPUSH
66742: CALL_OW 72
66746: ST_TO_ADDR
// if not tmp then
66747: LD_VAR 0 5
66751: NOT
66752: IFFALSE 66756
// continue ;
66754: GO 66005
// list := [ ] ;
66756: LD_ADDR_VAR 0 6
66760: PUSH
66761: EMPTY
66762: ST_TO_ADDR
// for j in tmp do
66763: LD_ADDR_VAR 0 3
66767: PUSH
66768: LD_VAR 0 5
66772: PUSH
66773: FOR_IN
66774: IFFALSE 66843
// begin for k in UnitsInside ( j ) do
66776: LD_ADDR_VAR 0 4
66780: PUSH
66781: LD_VAR 0 3
66785: PPUSH
66786: CALL_OW 313
66790: PUSH
66791: FOR_IN
66792: IFFALSE 66839
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66794: LD_VAR 0 4
66798: PPUSH
66799: CALL_OW 257
66803: PUSH
66804: LD_INT 1
66806: EQUAL
66807: PUSH
66808: LD_VAR 0 4
66812: PPUSH
66813: CALL_OW 459
66817: NOT
66818: AND
66819: IFFALSE 66837
// list := list ^ k ;
66821: LD_ADDR_VAR 0 6
66825: PUSH
66826: LD_VAR 0 6
66830: PUSH
66831: LD_VAR 0 4
66835: ADD
66836: ST_TO_ADDR
66837: GO 66791
66839: POP
66840: POP
// end ;
66841: GO 66773
66843: POP
66844: POP
// list := list diff mc_miners [ i ] ;
66845: LD_ADDR_VAR 0 6
66849: PUSH
66850: LD_VAR 0 6
66854: PUSH
66855: LD_EXP 72
66859: PUSH
66860: LD_VAR 0 2
66864: ARRAY
66865: DIFF
66866: ST_TO_ADDR
// if not list then
66867: LD_VAR 0 6
66871: NOT
66872: IFFALSE 66876
// continue ;
66874: GO 66005
// k := mc_mines [ i ] - mc_miners [ i ] ;
66876: LD_ADDR_VAR 0 4
66880: PUSH
66881: LD_EXP 71
66885: PUSH
66886: LD_VAR 0 2
66890: ARRAY
66891: PUSH
66892: LD_EXP 72
66896: PUSH
66897: LD_VAR 0 2
66901: ARRAY
66902: MINUS
66903: ST_TO_ADDR
// if k > list then
66904: LD_VAR 0 4
66908: PUSH
66909: LD_VAR 0 6
66913: GREATER
66914: IFFALSE 66926
// k := list ;
66916: LD_ADDR_VAR 0 4
66920: PUSH
66921: LD_VAR 0 6
66925: ST_TO_ADDR
// for j = 1 to k do
66926: LD_ADDR_VAR 0 3
66930: PUSH
66931: DOUBLE
66932: LD_INT 1
66934: DEC
66935: ST_TO_ADDR
66936: LD_VAR 0 4
66940: PUSH
66941: FOR_TO
66942: IFFALSE 66996
// mc_miners := Add ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
66944: LD_ADDR_EXP 72
66948: PUSH
66949: LD_EXP 72
66953: PPUSH
66954: LD_VAR 0 2
66958: PUSH
66959: LD_EXP 72
66963: PUSH
66964: LD_VAR 0 2
66968: ARRAY
66969: PUSH
66970: LD_INT 1
66972: PLUS
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PPUSH
66978: LD_VAR 0 6
66982: PUSH
66983: LD_VAR 0 3
66987: ARRAY
66988: PPUSH
66989: CALL 20685 0 3
66993: ST_TO_ADDR
66994: GO 66941
66996: POP
66997: POP
// end ;
66998: GO 66005
67000: POP
67001: POP
// end ;
67002: LD_VAR 0 1
67006: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67007: LD_INT 0
67009: PPUSH
67010: PPUSH
67011: PPUSH
67012: PPUSH
67013: PPUSH
67014: PPUSH
67015: PPUSH
67016: PPUSH
67017: PPUSH
67018: PPUSH
// if not mc_bases then
67019: LD_EXP 58
67023: NOT
67024: IFFALSE 67028
// exit ;
67026: GO 68759
// for i = 1 to mc_bases do
67028: LD_ADDR_VAR 0 2
67032: PUSH
67033: DOUBLE
67034: LD_INT 1
67036: DEC
67037: ST_TO_ADDR
67038: LD_EXP 58
67042: PUSH
67043: FOR_TO
67044: IFFALSE 68757
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67046: LD_EXP 58
67050: PUSH
67051: LD_VAR 0 2
67055: ARRAY
67056: NOT
67057: PUSH
67058: LD_EXP 65
67062: PUSH
67063: LD_VAR 0 2
67067: ARRAY
67068: OR
67069: IFFALSE 67073
// continue ;
67071: GO 67043
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67073: LD_EXP 74
67077: PUSH
67078: LD_VAR 0 2
67082: ARRAY
67083: NOT
67084: PUSH
67085: LD_EXP 75
67089: PUSH
67090: LD_VAR 0 2
67094: ARRAY
67095: AND
67096: IFFALSE 67134
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67098: LD_ADDR_EXP 75
67102: PUSH
67103: LD_EXP 75
67107: PPUSH
67108: LD_VAR 0 2
67112: PPUSH
67113: EMPTY
67114: PPUSH
67115: CALL_OW 1
67119: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67120: LD_VAR 0 2
67124: PPUSH
67125: LD_INT 107
67127: PPUSH
67128: CALL 58609 0 2
// continue ;
67132: GO 67043
// end ; target := [ ] ;
67134: LD_ADDR_VAR 0 6
67138: PUSH
67139: EMPTY
67140: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67141: LD_ADDR_VAR 0 3
67145: PUSH
67146: DOUBLE
67147: LD_EXP 74
67151: PUSH
67152: LD_VAR 0 2
67156: ARRAY
67157: INC
67158: ST_TO_ADDR
67159: LD_INT 1
67161: PUSH
67162: FOR_DOWNTO
67163: IFFALSE 67423
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67165: LD_EXP 74
67169: PUSH
67170: LD_VAR 0 2
67174: ARRAY
67175: PUSH
67176: LD_VAR 0 3
67180: ARRAY
67181: PUSH
67182: LD_INT 2
67184: ARRAY
67185: PPUSH
67186: LD_EXP 74
67190: PUSH
67191: LD_VAR 0 2
67195: ARRAY
67196: PUSH
67197: LD_VAR 0 3
67201: ARRAY
67202: PUSH
67203: LD_INT 3
67205: ARRAY
67206: PPUSH
67207: CALL_OW 488
67211: PUSH
67212: LD_EXP 74
67216: PUSH
67217: LD_VAR 0 2
67221: ARRAY
67222: PUSH
67223: LD_VAR 0 3
67227: ARRAY
67228: PUSH
67229: LD_INT 2
67231: ARRAY
67232: PPUSH
67233: LD_EXP 74
67237: PUSH
67238: LD_VAR 0 2
67242: ARRAY
67243: PUSH
67244: LD_VAR 0 3
67248: ARRAY
67249: PUSH
67250: LD_INT 3
67252: ARRAY
67253: PPUSH
67254: CALL_OW 284
67258: PUSH
67259: LD_INT 0
67261: EQUAL
67262: AND
67263: IFFALSE 67318
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67265: LD_ADDR_VAR 0 5
67269: PUSH
67270: LD_EXP 74
67274: PUSH
67275: LD_VAR 0 2
67279: ARRAY
67280: PPUSH
67281: LD_VAR 0 3
67285: PPUSH
67286: CALL_OW 3
67290: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67291: LD_ADDR_EXP 74
67295: PUSH
67296: LD_EXP 74
67300: PPUSH
67301: LD_VAR 0 2
67305: PPUSH
67306: LD_VAR 0 5
67310: PPUSH
67311: CALL_OW 1
67315: ST_TO_ADDR
// continue ;
67316: GO 67162
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67318: LD_EXP 58
67322: PUSH
67323: LD_VAR 0 2
67327: ARRAY
67328: PUSH
67329: LD_INT 1
67331: ARRAY
67332: PPUSH
67333: CALL_OW 255
67337: PPUSH
67338: LD_EXP 74
67342: PUSH
67343: LD_VAR 0 2
67347: ARRAY
67348: PUSH
67349: LD_VAR 0 3
67353: ARRAY
67354: PUSH
67355: LD_INT 2
67357: ARRAY
67358: PPUSH
67359: LD_EXP 74
67363: PUSH
67364: LD_VAR 0 2
67368: ARRAY
67369: PUSH
67370: LD_VAR 0 3
67374: ARRAY
67375: PUSH
67376: LD_INT 3
67378: ARRAY
67379: PPUSH
67380: LD_INT 30
67382: PPUSH
67383: CALL 21179 0 4
67387: PUSH
67388: LD_INT 4
67390: ARRAY
67391: PUSH
67392: LD_INT 0
67394: EQUAL
67395: IFFALSE 67421
// begin target := mc_crates [ i ] [ j ] ;
67397: LD_ADDR_VAR 0 6
67401: PUSH
67402: LD_EXP 74
67406: PUSH
67407: LD_VAR 0 2
67411: ARRAY
67412: PUSH
67413: LD_VAR 0 3
67417: ARRAY
67418: ST_TO_ADDR
// break ;
67419: GO 67423
// end ; end ;
67421: GO 67162
67423: POP
67424: POP
// if not target then
67425: LD_VAR 0 6
67429: NOT
67430: IFFALSE 67434
// continue ;
67432: GO 67043
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67434: LD_ADDR_VAR 0 7
67438: PUSH
67439: LD_EXP 77
67443: PUSH
67444: LD_VAR 0 2
67448: ARRAY
67449: PPUSH
67450: LD_INT 2
67452: PUSH
67453: LD_INT 3
67455: PUSH
67456: LD_INT 58
67458: PUSH
67459: EMPTY
67460: LIST
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 61
67468: PUSH
67469: EMPTY
67470: LIST
67471: PUSH
67472: LD_INT 33
67474: PUSH
67475: LD_INT 5
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 33
67484: PUSH
67485: LD_INT 3
67487: PUSH
67488: EMPTY
67489: LIST
67490: LIST
67491: PUSH
67492: EMPTY
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: PUSH
67499: LD_INT 2
67501: PUSH
67502: LD_INT 34
67504: PUSH
67505: LD_INT 32
67507: PUSH
67508: EMPTY
67509: LIST
67510: LIST
67511: PUSH
67512: LD_INT 34
67514: PUSH
67515: LD_INT 51
67517: PUSH
67518: EMPTY
67519: LIST
67520: LIST
67521: PUSH
67522: LD_INT 34
67524: PUSH
67525: LD_INT 12
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: LIST
67536: LIST
67537: PUSH
67538: EMPTY
67539: LIST
67540: LIST
67541: PPUSH
67542: CALL_OW 72
67546: ST_TO_ADDR
// if not cargo then
67547: LD_VAR 0 7
67551: NOT
67552: IFFALSE 68195
// begin if mc_crates_collector [ i ] < 5 then
67554: LD_EXP 75
67558: PUSH
67559: LD_VAR 0 2
67563: ARRAY
67564: PUSH
67565: LD_INT 5
67567: LESS
67568: IFFALSE 67934
// begin if mc_ape [ i ] then
67570: LD_EXP 87
67574: PUSH
67575: LD_VAR 0 2
67579: ARRAY
67580: IFFALSE 67627
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67582: LD_ADDR_VAR 0 5
67586: PUSH
67587: LD_EXP 87
67591: PUSH
67592: LD_VAR 0 2
67596: ARRAY
67597: PPUSH
67598: LD_INT 25
67600: PUSH
67601: LD_INT 16
67603: PUSH
67604: EMPTY
67605: LIST
67606: LIST
67607: PUSH
67608: LD_INT 24
67610: PUSH
67611: LD_INT 750
67613: PUSH
67614: EMPTY
67615: LIST
67616: LIST
67617: PUSH
67618: EMPTY
67619: LIST
67620: LIST
67621: PPUSH
67622: CALL_OW 72
67626: ST_TO_ADDR
// if not tmp then
67627: LD_VAR 0 5
67631: NOT
67632: IFFALSE 67679
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67634: LD_ADDR_VAR 0 5
67638: PUSH
67639: LD_EXP 58
67643: PUSH
67644: LD_VAR 0 2
67648: ARRAY
67649: PPUSH
67650: LD_INT 25
67652: PUSH
67653: LD_INT 2
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 24
67662: PUSH
67663: LD_INT 750
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: PUSH
67670: EMPTY
67671: LIST
67672: LIST
67673: PPUSH
67674: CALL_OW 72
67678: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67679: LD_EXP 87
67683: PUSH
67684: LD_VAR 0 2
67688: ARRAY
67689: PUSH
67690: LD_EXP 58
67694: PUSH
67695: LD_VAR 0 2
67699: ARRAY
67700: PPUSH
67701: LD_INT 25
67703: PUSH
67704: LD_INT 2
67706: PUSH
67707: EMPTY
67708: LIST
67709: LIST
67710: PUSH
67711: LD_INT 24
67713: PUSH
67714: LD_INT 750
67716: PUSH
67717: EMPTY
67718: LIST
67719: LIST
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PPUSH
67725: CALL_OW 72
67729: AND
67730: PUSH
67731: LD_VAR 0 5
67735: PUSH
67736: LD_INT 5
67738: LESS
67739: AND
67740: IFFALSE 67822
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67742: LD_ADDR_VAR 0 3
67746: PUSH
67747: LD_EXP 58
67751: PUSH
67752: LD_VAR 0 2
67756: ARRAY
67757: PPUSH
67758: LD_INT 25
67760: PUSH
67761: LD_INT 2
67763: PUSH
67764: EMPTY
67765: LIST
67766: LIST
67767: PUSH
67768: LD_INT 24
67770: PUSH
67771: LD_INT 750
67773: PUSH
67774: EMPTY
67775: LIST
67776: LIST
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PPUSH
67782: CALL_OW 72
67786: PUSH
67787: FOR_IN
67788: IFFALSE 67820
// begin tmp := tmp union j ;
67790: LD_ADDR_VAR 0 5
67794: PUSH
67795: LD_VAR 0 5
67799: PUSH
67800: LD_VAR 0 3
67804: UNION
67805: ST_TO_ADDR
// if tmp >= 5 then
67806: LD_VAR 0 5
67810: PUSH
67811: LD_INT 5
67813: GREATEREQUAL
67814: IFFALSE 67818
// break ;
67816: GO 67820
// end ;
67818: GO 67787
67820: POP
67821: POP
// end ; if not tmp then
67822: LD_VAR 0 5
67826: NOT
67827: IFFALSE 67831
// continue ;
67829: GO 67043
// for j in tmp do
67831: LD_ADDR_VAR 0 3
67835: PUSH
67836: LD_VAR 0 5
67840: PUSH
67841: FOR_IN
67842: IFFALSE 67932
// if not GetTag ( j ) then
67844: LD_VAR 0 3
67848: PPUSH
67849: CALL_OW 110
67853: NOT
67854: IFFALSE 67930
// begin mc_crates_collector := Add ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67856: LD_ADDR_EXP 75
67860: PUSH
67861: LD_EXP 75
67865: PPUSH
67866: LD_VAR 0 2
67870: PUSH
67871: LD_EXP 75
67875: PUSH
67876: LD_VAR 0 2
67880: ARRAY
67881: PUSH
67882: LD_INT 1
67884: PLUS
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PPUSH
67890: LD_VAR 0 3
67894: PPUSH
67895: CALL 20685 0 3
67899: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67900: LD_VAR 0 3
67904: PPUSH
67905: LD_INT 107
67907: PPUSH
67908: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67912: LD_EXP 75
67916: PUSH
67917: LD_VAR 0 2
67921: ARRAY
67922: PUSH
67923: LD_INT 5
67925: GREATEREQUAL
67926: IFFALSE 67930
// break ;
67928: GO 67932
// end ;
67930: GO 67841
67932: POP
67933: POP
// end ; if mc_crates_collector [ i ] and target then
67934: LD_EXP 75
67938: PUSH
67939: LD_VAR 0 2
67943: ARRAY
67944: PUSH
67945: LD_VAR 0 6
67949: AND
67950: IFFALSE 68193
// begin if mc_crates_collector [ i ] < target [ 1 ] then
67952: LD_EXP 75
67956: PUSH
67957: LD_VAR 0 2
67961: ARRAY
67962: PUSH
67963: LD_VAR 0 6
67967: PUSH
67968: LD_INT 1
67970: ARRAY
67971: LESS
67972: IFFALSE 67992
// tmp := mc_crates_collector [ i ] else
67974: LD_ADDR_VAR 0 5
67978: PUSH
67979: LD_EXP 75
67983: PUSH
67984: LD_VAR 0 2
67988: ARRAY
67989: ST_TO_ADDR
67990: GO 68006
// tmp := target [ 1 ] ;
67992: LD_ADDR_VAR 0 5
67996: PUSH
67997: LD_VAR 0 6
68001: PUSH
68002: LD_INT 1
68004: ARRAY
68005: ST_TO_ADDR
// k := 0 ;
68006: LD_ADDR_VAR 0 4
68010: PUSH
68011: LD_INT 0
68013: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68014: LD_ADDR_VAR 0 3
68018: PUSH
68019: LD_EXP 75
68023: PUSH
68024: LD_VAR 0 2
68028: ARRAY
68029: PUSH
68030: FOR_IN
68031: IFFALSE 68191
// begin k := k + 1 ;
68033: LD_ADDR_VAR 0 4
68037: PUSH
68038: LD_VAR 0 4
68042: PUSH
68043: LD_INT 1
68045: PLUS
68046: ST_TO_ADDR
// if k > tmp then
68047: LD_VAR 0 4
68051: PUSH
68052: LD_VAR 0 5
68056: GREATER
68057: IFFALSE 68061
// break ;
68059: GO 68191
// if not GetClass ( j ) in [ 2 , 16 ] then
68061: LD_VAR 0 3
68065: PPUSH
68066: CALL_OW 257
68070: PUSH
68071: LD_INT 2
68073: PUSH
68074: LD_INT 16
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: IN
68081: NOT
68082: IFFALSE 68135
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68084: LD_ADDR_EXP 75
68088: PUSH
68089: LD_EXP 75
68093: PPUSH
68094: LD_VAR 0 2
68098: PPUSH
68099: LD_EXP 75
68103: PUSH
68104: LD_VAR 0 2
68108: ARRAY
68109: PUSH
68110: LD_VAR 0 3
68114: DIFF
68115: PPUSH
68116: CALL_OW 1
68120: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68121: LD_VAR 0 3
68125: PPUSH
68126: LD_INT 0
68128: PPUSH
68129: CALL_OW 109
// continue ;
68133: GO 68030
// end ; if IsInUnit ( j ) then
68135: LD_VAR 0 3
68139: PPUSH
68140: CALL_OW 310
68144: IFFALSE 68155
// ComExitBuilding ( j ) ;
68146: LD_VAR 0 3
68150: PPUSH
68151: CALL_OW 122
// wait ( 3 ) ;
68155: LD_INT 3
68157: PPUSH
68158: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68162: LD_VAR 0 3
68166: PPUSH
68167: LD_VAR 0 6
68171: PUSH
68172: LD_INT 2
68174: ARRAY
68175: PPUSH
68176: LD_VAR 0 6
68180: PUSH
68181: LD_INT 3
68183: ARRAY
68184: PPUSH
68185: CALL_OW 117
// end ;
68189: GO 68030
68191: POP
68192: POP
// end ; end else
68193: GO 68755
// begin for j in cargo do
68195: LD_ADDR_VAR 0 3
68199: PUSH
68200: LD_VAR 0 7
68204: PUSH
68205: FOR_IN
68206: IFFALSE 68753
// begin if GetTag ( j ) <> 0 then
68208: LD_VAR 0 3
68212: PPUSH
68213: CALL_OW 110
68217: PUSH
68218: LD_INT 0
68220: NONEQUAL
68221: IFFALSE 68225
// continue ;
68223: GO 68205
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68225: LD_VAR 0 3
68229: PPUSH
68230: CALL_OW 256
68234: PUSH
68235: LD_INT 1000
68237: LESS
68238: PUSH
68239: LD_VAR 0 3
68243: PPUSH
68244: LD_EXP 82
68248: PUSH
68249: LD_VAR 0 2
68253: ARRAY
68254: PPUSH
68255: CALL_OW 308
68259: NOT
68260: AND
68261: IFFALSE 68283
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68263: LD_VAR 0 3
68267: PPUSH
68268: LD_EXP 82
68272: PUSH
68273: LD_VAR 0 2
68277: ARRAY
68278: PPUSH
68279: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68283: LD_VAR 0 3
68287: PPUSH
68288: CALL_OW 256
68292: PUSH
68293: LD_INT 1000
68295: LESS
68296: PUSH
68297: LD_VAR 0 3
68301: PPUSH
68302: LD_EXP 82
68306: PUSH
68307: LD_VAR 0 2
68311: ARRAY
68312: PPUSH
68313: CALL_OW 308
68317: AND
68318: IFFALSE 68322
// continue ;
68320: GO 68205
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68322: LD_VAR 0 3
68326: PPUSH
68327: CALL_OW 262
68331: PUSH
68332: LD_INT 2
68334: EQUAL
68335: PUSH
68336: LD_VAR 0 3
68340: PPUSH
68341: CALL_OW 261
68345: PUSH
68346: LD_INT 15
68348: LESS
68349: AND
68350: IFFALSE 68354
// continue ;
68352: GO 68205
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68354: LD_VAR 0 3
68358: PPUSH
68359: CALL_OW 262
68363: PUSH
68364: LD_INT 1
68366: EQUAL
68367: PUSH
68368: LD_VAR 0 3
68372: PPUSH
68373: CALL_OW 261
68377: PUSH
68378: LD_INT 10
68380: LESS
68381: AND
68382: IFFALSE 68692
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68384: LD_ADDR_VAR 0 8
68388: PUSH
68389: LD_EXP 58
68393: PUSH
68394: LD_VAR 0 2
68398: ARRAY
68399: PPUSH
68400: LD_INT 2
68402: PUSH
68403: LD_INT 30
68405: PUSH
68406: LD_INT 0
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 30
68415: PUSH
68416: LD_INT 1
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: EMPTY
68424: LIST
68425: LIST
68426: LIST
68427: PPUSH
68428: CALL_OW 72
68432: ST_TO_ADDR
// if not depot then
68433: LD_VAR 0 8
68437: NOT
68438: IFFALSE 68442
// continue ;
68440: GO 68205
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68442: LD_VAR 0 3
68446: PPUSH
68447: LD_VAR 0 8
68451: PPUSH
68452: LD_VAR 0 3
68456: PPUSH
68457: CALL_OW 74
68461: PPUSH
68462: CALL_OW 296
68466: PUSH
68467: LD_INT 6
68469: LESS
68470: IFFALSE 68486
// SetFuel ( j , 100 ) else
68472: LD_VAR 0 3
68476: PPUSH
68477: LD_INT 100
68479: PPUSH
68480: CALL_OW 240
68484: GO 68692
// if GetFuel ( j ) = 0 then
68486: LD_VAR 0 3
68490: PPUSH
68491: CALL_OW 261
68495: PUSH
68496: LD_INT 0
68498: EQUAL
68499: IFFALSE 68692
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68501: LD_ADDR_EXP 77
68505: PUSH
68506: LD_EXP 77
68510: PPUSH
68511: LD_VAR 0 2
68515: PPUSH
68516: LD_EXP 77
68520: PUSH
68521: LD_VAR 0 2
68525: ARRAY
68526: PUSH
68527: LD_VAR 0 3
68531: DIFF
68532: PPUSH
68533: CALL_OW 1
68537: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68538: LD_VAR 0 3
68542: PPUSH
68543: CALL_OW 263
68547: PUSH
68548: LD_INT 1
68550: EQUAL
68551: IFFALSE 68567
// ComExitVehicle ( IsInUnit ( j ) ) ;
68553: LD_VAR 0 3
68557: PPUSH
68558: CALL_OW 310
68562: PPUSH
68563: CALL_OW 121
// if GetControl ( j ) = control_remote then
68567: LD_VAR 0 3
68571: PPUSH
68572: CALL_OW 263
68576: PUSH
68577: LD_INT 2
68579: EQUAL
68580: IFFALSE 68591
// ComUnlink ( j ) ;
68582: LD_VAR 0 3
68586: PPUSH
68587: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
68591: LD_ADDR_VAR 0 9
68595: PUSH
68596: LD_VAR 0 2
68600: PPUSH
68601: LD_INT 3
68603: PPUSH
68604: CALL 77827 0 2
68608: ST_TO_ADDR
// if fac then
68609: LD_VAR 0 9
68613: IFFALSE 68690
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68615: LD_ADDR_VAR 0 10
68619: PUSH
68620: LD_VAR 0 9
68624: PPUSH
68625: LD_VAR 0 3
68629: PPUSH
68630: CALL_OW 265
68634: PPUSH
68635: LD_VAR 0 3
68639: PPUSH
68640: CALL_OW 262
68644: PPUSH
68645: LD_VAR 0 3
68649: PPUSH
68650: CALL_OW 263
68654: PPUSH
68655: LD_VAR 0 3
68659: PPUSH
68660: CALL_OW 264
68664: PPUSH
68665: CALL 17850 0 5
68669: ST_TO_ADDR
// if components then
68670: LD_VAR 0 10
68674: IFFALSE 68690
// MC_InsertProduceList ( i , components ) ;
68676: LD_VAR 0 2
68680: PPUSH
68681: LD_VAR 0 10
68685: PPUSH
68686: CALL 77397 0 2
// end ; continue ;
68690: GO 68205
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68692: LD_VAR 0 3
68696: PPUSH
68697: LD_INT 1
68699: PPUSH
68700: CALL_OW 289
68704: PUSH
68705: LD_INT 100
68707: LESS
68708: PUSH
68709: LD_VAR 0 3
68713: PPUSH
68714: CALL_OW 314
68718: NOT
68719: AND
68720: IFFALSE 68749
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68722: LD_VAR 0 3
68726: PPUSH
68727: LD_VAR 0 6
68731: PUSH
68732: LD_INT 2
68734: ARRAY
68735: PPUSH
68736: LD_VAR 0 6
68740: PUSH
68741: LD_INT 3
68743: ARRAY
68744: PPUSH
68745: CALL_OW 117
// break ;
68749: GO 68753
// end ;
68751: GO 68205
68753: POP
68754: POP
// end ; end ;
68755: GO 67043
68757: POP
68758: POP
// end ;
68759: LD_VAR 0 1
68763: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68764: LD_INT 0
68766: PPUSH
68767: PPUSH
68768: PPUSH
68769: PPUSH
// if not mc_bases then
68770: LD_EXP 58
68774: NOT
68775: IFFALSE 68779
// exit ;
68777: GO 68940
// for i = 1 to mc_bases do
68779: LD_ADDR_VAR 0 2
68783: PUSH
68784: DOUBLE
68785: LD_INT 1
68787: DEC
68788: ST_TO_ADDR
68789: LD_EXP 58
68793: PUSH
68794: FOR_TO
68795: IFFALSE 68938
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68797: LD_ADDR_VAR 0 4
68801: PUSH
68802: LD_EXP 77
68806: PUSH
68807: LD_VAR 0 2
68811: ARRAY
68812: PUSH
68813: LD_EXP 80
68817: PUSH
68818: LD_VAR 0 2
68822: ARRAY
68823: UNION
68824: PPUSH
68825: LD_INT 33
68827: PUSH
68828: LD_INT 2
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PPUSH
68835: CALL_OW 72
68839: ST_TO_ADDR
// if tmp then
68840: LD_VAR 0 4
68844: IFFALSE 68936
// for j in tmp do
68846: LD_ADDR_VAR 0 3
68850: PUSH
68851: LD_VAR 0 4
68855: PUSH
68856: FOR_IN
68857: IFFALSE 68934
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68859: LD_VAR 0 3
68863: PPUSH
68864: CALL_OW 312
68868: NOT
68869: PUSH
68870: LD_VAR 0 3
68874: PPUSH
68875: CALL_OW 256
68879: PUSH
68880: LD_INT 250
68882: GREATEREQUAL
68883: AND
68884: IFFALSE 68897
// Connect ( j ) else
68886: LD_VAR 0 3
68890: PPUSH
68891: CALL 23203 0 1
68895: GO 68932
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68897: LD_VAR 0 3
68901: PPUSH
68902: CALL_OW 256
68906: PUSH
68907: LD_INT 250
68909: LESS
68910: PUSH
68911: LD_VAR 0 3
68915: PPUSH
68916: CALL_OW 312
68920: AND
68921: IFFALSE 68932
// ComUnlink ( j ) ;
68923: LD_VAR 0 3
68927: PPUSH
68928: CALL_OW 136
68932: GO 68856
68934: POP
68935: POP
// end ;
68936: GO 68794
68938: POP
68939: POP
// end ;
68940: LD_VAR 0 1
68944: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
68945: LD_INT 0
68947: PPUSH
68948: PPUSH
68949: PPUSH
68950: PPUSH
68951: PPUSH
// if not mc_bases then
68952: LD_EXP 58
68956: NOT
68957: IFFALSE 68961
// exit ;
68959: GO 69421
// for i = 1 to mc_bases do
68961: LD_ADDR_VAR 0 2
68965: PUSH
68966: DOUBLE
68967: LD_INT 1
68969: DEC
68970: ST_TO_ADDR
68971: LD_EXP 58
68975: PUSH
68976: FOR_TO
68977: IFFALSE 69419
// begin if not mc_produce [ i ] then
68979: LD_EXP 79
68983: PUSH
68984: LD_VAR 0 2
68988: ARRAY
68989: NOT
68990: IFFALSE 68994
// continue ;
68992: GO 68976
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68994: LD_ADDR_VAR 0 5
68998: PUSH
68999: LD_EXP 58
69003: PUSH
69004: LD_VAR 0 2
69008: ARRAY
69009: PPUSH
69010: LD_INT 30
69012: PUSH
69013: LD_INT 3
69015: PUSH
69016: EMPTY
69017: LIST
69018: LIST
69019: PPUSH
69020: CALL_OW 72
69024: ST_TO_ADDR
// if not fac then
69025: LD_VAR 0 5
69029: NOT
69030: IFFALSE 69034
// continue ;
69032: GO 68976
// for j in fac do
69034: LD_ADDR_VAR 0 3
69038: PUSH
69039: LD_VAR 0 5
69043: PUSH
69044: FOR_IN
69045: IFFALSE 69415
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
69047: LD_VAR 0 3
69051: PPUSH
69052: CALL_OW 461
69056: PUSH
69057: LD_INT 2
69059: NONEQUAL
69060: PUSH
69061: LD_VAR 0 3
69065: PPUSH
69066: LD_INT 15
69068: PPUSH
69069: CALL 22876 0 2
69073: PUSH
69074: LD_INT 4
69076: ARRAY
69077: OR
69078: PUSH
69079: LD_VAR 0 3
69083: PPUSH
69084: CALL_OW 313
69088: PUSH
69089: LD_INT 0
69091: EQUAL
69092: OR
69093: IFFALSE 69097
// continue ;
69095: GO 69044
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69097: LD_VAR 0 3
69101: PPUSH
69102: LD_EXP 79
69106: PUSH
69107: LD_VAR 0 2
69111: ARRAY
69112: PUSH
69113: LD_INT 1
69115: ARRAY
69116: PUSH
69117: LD_INT 1
69119: ARRAY
69120: PPUSH
69121: LD_EXP 79
69125: PUSH
69126: LD_VAR 0 2
69130: ARRAY
69131: PUSH
69132: LD_INT 1
69134: ARRAY
69135: PUSH
69136: LD_INT 2
69138: ARRAY
69139: PPUSH
69140: LD_EXP 79
69144: PUSH
69145: LD_VAR 0 2
69149: ARRAY
69150: PUSH
69151: LD_INT 1
69153: ARRAY
69154: PUSH
69155: LD_INT 3
69157: ARRAY
69158: PPUSH
69159: LD_EXP 79
69163: PUSH
69164: LD_VAR 0 2
69168: ARRAY
69169: PUSH
69170: LD_INT 1
69172: ARRAY
69173: PUSH
69174: LD_INT 4
69176: ARRAY
69177: PPUSH
69178: CALL_OW 448
69182: PUSH
69183: LD_VAR 0 3
69187: PPUSH
69188: LD_EXP 79
69192: PUSH
69193: LD_VAR 0 2
69197: ARRAY
69198: PUSH
69199: LD_INT 1
69201: ARRAY
69202: PUSH
69203: LD_INT 1
69205: ARRAY
69206: PUSH
69207: LD_EXP 79
69211: PUSH
69212: LD_VAR 0 2
69216: ARRAY
69217: PUSH
69218: LD_INT 1
69220: ARRAY
69221: PUSH
69222: LD_INT 2
69224: ARRAY
69225: PUSH
69226: LD_EXP 79
69230: PUSH
69231: LD_VAR 0 2
69235: ARRAY
69236: PUSH
69237: LD_INT 1
69239: ARRAY
69240: PUSH
69241: LD_INT 3
69243: ARRAY
69244: PUSH
69245: LD_EXP 79
69249: PUSH
69250: LD_VAR 0 2
69254: ARRAY
69255: PUSH
69256: LD_INT 1
69258: ARRAY
69259: PUSH
69260: LD_INT 4
69262: ARRAY
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: PPUSH
69270: CALL 26417 0 2
69274: AND
69275: IFFALSE 69413
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69277: LD_VAR 0 3
69281: PPUSH
69282: LD_EXP 79
69286: PUSH
69287: LD_VAR 0 2
69291: ARRAY
69292: PUSH
69293: LD_INT 1
69295: ARRAY
69296: PUSH
69297: LD_INT 1
69299: ARRAY
69300: PPUSH
69301: LD_EXP 79
69305: PUSH
69306: LD_VAR 0 2
69310: ARRAY
69311: PUSH
69312: LD_INT 1
69314: ARRAY
69315: PUSH
69316: LD_INT 2
69318: ARRAY
69319: PPUSH
69320: LD_EXP 79
69324: PUSH
69325: LD_VAR 0 2
69329: ARRAY
69330: PUSH
69331: LD_INT 1
69333: ARRAY
69334: PUSH
69335: LD_INT 3
69337: ARRAY
69338: PPUSH
69339: LD_EXP 79
69343: PUSH
69344: LD_VAR 0 2
69348: ARRAY
69349: PUSH
69350: LD_INT 1
69352: ARRAY
69353: PUSH
69354: LD_INT 4
69356: ARRAY
69357: PPUSH
69358: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69362: LD_ADDR_VAR 0 4
69366: PUSH
69367: LD_EXP 79
69371: PUSH
69372: LD_VAR 0 2
69376: ARRAY
69377: PPUSH
69378: LD_INT 1
69380: PPUSH
69381: CALL_OW 3
69385: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69386: LD_ADDR_EXP 79
69390: PUSH
69391: LD_EXP 79
69395: PPUSH
69396: LD_VAR 0 2
69400: PPUSH
69401: LD_VAR 0 4
69405: PPUSH
69406: CALL_OW 1
69410: ST_TO_ADDR
// break ;
69411: GO 69415
// end ; end ;
69413: GO 69044
69415: POP
69416: POP
// end ;
69417: GO 68976
69419: POP
69420: POP
// end ;
69421: LD_VAR 0 1
69425: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69426: LD_INT 0
69428: PPUSH
69429: PPUSH
69430: PPUSH
// if not mc_bases then
69431: LD_EXP 58
69435: NOT
69436: IFFALSE 69440
// exit ;
69438: GO 69529
// for i = 1 to mc_bases do
69440: LD_ADDR_VAR 0 2
69444: PUSH
69445: DOUBLE
69446: LD_INT 1
69448: DEC
69449: ST_TO_ADDR
69450: LD_EXP 58
69454: PUSH
69455: FOR_TO
69456: IFFALSE 69527
// begin if mc_attack [ i ] then
69458: LD_EXP 78
69462: PUSH
69463: LD_VAR 0 2
69467: ARRAY
69468: IFFALSE 69525
// begin tmp := mc_attack [ i ] [ 1 ] ;
69470: LD_ADDR_VAR 0 3
69474: PUSH
69475: LD_EXP 78
69479: PUSH
69480: LD_VAR 0 2
69484: ARRAY
69485: PUSH
69486: LD_INT 1
69488: ARRAY
69489: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69490: LD_ADDR_EXP 78
69494: PUSH
69495: LD_EXP 78
69499: PPUSH
69500: LD_VAR 0 2
69504: PPUSH
69505: EMPTY
69506: PPUSH
69507: CALL_OW 1
69511: ST_TO_ADDR
// Attack ( tmp ) ;
69512: LD_VAR 0 3
69516: PPUSH
69517: CALL 48521 0 1
// exit ;
69521: POP
69522: POP
69523: GO 69529
// end ; end ;
69525: GO 69455
69527: POP
69528: POP
// end ;
69529: LD_VAR 0 1
69533: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69534: LD_INT 0
69536: PPUSH
69537: PPUSH
69538: PPUSH
69539: PPUSH
69540: PPUSH
69541: PPUSH
69542: PPUSH
// if not mc_bases then
69543: LD_EXP 58
69547: NOT
69548: IFFALSE 69552
// exit ;
69550: GO 70156
// for i = 1 to mc_bases do
69552: LD_ADDR_VAR 0 2
69556: PUSH
69557: DOUBLE
69558: LD_INT 1
69560: DEC
69561: ST_TO_ADDR
69562: LD_EXP 58
69566: PUSH
69567: FOR_TO
69568: IFFALSE 70154
// begin if not mc_bases [ i ] then
69570: LD_EXP 58
69574: PUSH
69575: LD_VAR 0 2
69579: ARRAY
69580: NOT
69581: IFFALSE 69585
// continue ;
69583: GO 69567
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69585: LD_ADDR_VAR 0 7
69589: PUSH
69590: LD_EXP 58
69594: PUSH
69595: LD_VAR 0 2
69599: ARRAY
69600: PUSH
69601: LD_INT 1
69603: ARRAY
69604: PPUSH
69605: CALL 17154 0 1
69609: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69610: LD_ADDR_EXP 81
69614: PUSH
69615: LD_EXP 81
69619: PPUSH
69620: LD_VAR 0 2
69624: PPUSH
69625: LD_EXP 58
69629: PUSH
69630: LD_VAR 0 2
69634: ARRAY
69635: PUSH
69636: LD_INT 1
69638: ARRAY
69639: PPUSH
69640: CALL_OW 255
69644: PPUSH
69645: LD_EXP 83
69649: PUSH
69650: LD_VAR 0 2
69654: ARRAY
69655: PPUSH
69656: CALL 15114 0 2
69660: PPUSH
69661: CALL_OW 1
69665: ST_TO_ADDR
// if not mc_scan [ i ] then
69666: LD_EXP 81
69670: PUSH
69671: LD_VAR 0 2
69675: ARRAY
69676: NOT
69677: IFFALSE 69832
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69679: LD_ADDR_VAR 0 4
69683: PUSH
69684: LD_EXP 58
69688: PUSH
69689: LD_VAR 0 2
69693: ARRAY
69694: PPUSH
69695: LD_INT 2
69697: PUSH
69698: LD_INT 25
69700: PUSH
69701: LD_INT 5
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PUSH
69708: LD_INT 25
69710: PUSH
69711: LD_INT 8
69713: PUSH
69714: EMPTY
69715: LIST
69716: LIST
69717: PUSH
69718: LD_INT 25
69720: PUSH
69721: LD_INT 9
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: PUSH
69728: EMPTY
69729: LIST
69730: LIST
69731: LIST
69732: LIST
69733: PPUSH
69734: CALL_OW 72
69738: ST_TO_ADDR
// if not tmp then
69739: LD_VAR 0 4
69743: NOT
69744: IFFALSE 69748
// continue ;
69746: GO 69567
// for j in tmp do
69748: LD_ADDR_VAR 0 3
69752: PUSH
69753: LD_VAR 0 4
69757: PUSH
69758: FOR_IN
69759: IFFALSE 69830
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69761: LD_VAR 0 3
69765: PPUSH
69766: CALL_OW 310
69770: PPUSH
69771: CALL_OW 266
69775: PUSH
69776: LD_INT 5
69778: EQUAL
69779: PUSH
69780: LD_VAR 0 3
69784: PPUSH
69785: CALL_OW 257
69789: PUSH
69790: LD_INT 1
69792: EQUAL
69793: AND
69794: PUSH
69795: LD_VAR 0 3
69799: PPUSH
69800: CALL_OW 459
69804: NOT
69805: AND
69806: PUSH
69807: LD_VAR 0 7
69811: AND
69812: IFFALSE 69828
// ComChangeProfession ( j , class ) ;
69814: LD_VAR 0 3
69818: PPUSH
69819: LD_VAR 0 7
69823: PPUSH
69824: CALL_OW 123
69828: GO 69758
69830: POP
69831: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69832: LD_EXP 81
69836: PUSH
69837: LD_VAR 0 2
69841: ARRAY
69842: PUSH
69843: LD_EXP 80
69847: PUSH
69848: LD_VAR 0 2
69852: ARRAY
69853: NOT
69854: AND
69855: PUSH
69856: LD_EXP 58
69860: PUSH
69861: LD_VAR 0 2
69865: ARRAY
69866: PPUSH
69867: LD_INT 30
69869: PUSH
69870: LD_INT 32
69872: PUSH
69873: EMPTY
69874: LIST
69875: LIST
69876: PPUSH
69877: CALL_OW 72
69881: NOT
69882: AND
69883: PUSH
69884: LD_EXP 58
69888: PUSH
69889: LD_VAR 0 2
69893: ARRAY
69894: PPUSH
69895: LD_INT 2
69897: PUSH
69898: LD_INT 30
69900: PUSH
69901: LD_INT 4
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 30
69910: PUSH
69911: LD_INT 5
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: EMPTY
69919: LIST
69920: LIST
69921: LIST
69922: PPUSH
69923: CALL_OW 72
69927: NOT
69928: AND
69929: IFFALSE 70061
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69931: LD_ADDR_VAR 0 4
69935: PUSH
69936: LD_EXP 58
69940: PUSH
69941: LD_VAR 0 2
69945: ARRAY
69946: PPUSH
69947: LD_INT 2
69949: PUSH
69950: LD_INT 25
69952: PUSH
69953: LD_INT 1
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 25
69962: PUSH
69963: LD_INT 5
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 25
69972: PUSH
69973: LD_INT 8
69975: PUSH
69976: EMPTY
69977: LIST
69978: LIST
69979: PUSH
69980: LD_INT 25
69982: PUSH
69983: LD_INT 9
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: EMPTY
69991: LIST
69992: LIST
69993: LIST
69994: LIST
69995: LIST
69996: PPUSH
69997: CALL_OW 72
70001: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70002: LD_ADDR_VAR 0 4
70006: PUSH
70007: LD_VAR 0 4
70011: PUSH
70012: LD_VAR 0 4
70016: PPUSH
70017: LD_INT 18
70019: PPUSH
70020: CALL 53265 0 2
70024: DIFF
70025: ST_TO_ADDR
// if tmp then
70026: LD_VAR 0 4
70030: IFFALSE 70061
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70032: LD_VAR 0 2
70036: PPUSH
70037: LD_VAR 0 4
70041: PPUSH
70042: LD_EXP 83
70046: PUSH
70047: LD_VAR 0 2
70051: ARRAY
70052: PPUSH
70053: CALL 15149 0 3
// exit ;
70057: POP
70058: POP
70059: GO 70156
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70061: LD_EXP 81
70065: PUSH
70066: LD_VAR 0 2
70070: ARRAY
70071: PUSH
70072: LD_EXP 80
70076: PUSH
70077: LD_VAR 0 2
70081: ARRAY
70082: AND
70083: IFFALSE 70152
// begin tmp := mc_defender [ i ] ;
70085: LD_ADDR_VAR 0 4
70089: PUSH
70090: LD_EXP 80
70094: PUSH
70095: LD_VAR 0 2
70099: ARRAY
70100: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70101: LD_ADDR_EXP 80
70105: PUSH
70106: LD_EXP 80
70110: PPUSH
70111: LD_VAR 0 2
70115: PPUSH
70116: EMPTY
70117: PPUSH
70118: CALL_OW 1
70122: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70123: LD_VAR 0 2
70127: PPUSH
70128: LD_VAR 0 4
70132: PPUSH
70133: LD_EXP 81
70137: PUSH
70138: LD_VAR 0 2
70142: ARRAY
70143: PPUSH
70144: CALL 15647 0 3
// exit ;
70148: POP
70149: POP
70150: GO 70156
// end ; end ;
70152: GO 69567
70154: POP
70155: POP
// end ;
70156: LD_VAR 0 1
70160: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70161: LD_INT 0
70163: PPUSH
70164: PPUSH
70165: PPUSH
70166: PPUSH
70167: PPUSH
70168: PPUSH
70169: PPUSH
70170: PPUSH
70171: PPUSH
70172: PPUSH
70173: PPUSH
// if not mc_bases then
70174: LD_EXP 58
70178: NOT
70179: IFFALSE 70183
// exit ;
70181: GO 71243
// for i = 1 to mc_bases do
70183: LD_ADDR_VAR 0 2
70187: PUSH
70188: DOUBLE
70189: LD_INT 1
70191: DEC
70192: ST_TO_ADDR
70193: LD_EXP 58
70197: PUSH
70198: FOR_TO
70199: IFFALSE 71241
// begin tmp := mc_lab [ i ] ;
70201: LD_ADDR_VAR 0 6
70205: PUSH
70206: LD_EXP 91
70210: PUSH
70211: LD_VAR 0 2
70215: ARRAY
70216: ST_TO_ADDR
// if not tmp then
70217: LD_VAR 0 6
70221: NOT
70222: IFFALSE 70226
// continue ;
70224: GO 70198
// idle_lab := 0 ;
70226: LD_ADDR_VAR 0 11
70230: PUSH
70231: LD_INT 0
70233: ST_TO_ADDR
// for j in tmp do
70234: LD_ADDR_VAR 0 3
70238: PUSH
70239: LD_VAR 0 6
70243: PUSH
70244: FOR_IN
70245: IFFALSE 71237
// begin researching := false ;
70247: LD_ADDR_VAR 0 10
70251: PUSH
70252: LD_INT 0
70254: ST_TO_ADDR
// side := GetSide ( j ) ;
70255: LD_ADDR_VAR 0 4
70259: PUSH
70260: LD_VAR 0 3
70264: PPUSH
70265: CALL_OW 255
70269: ST_TO_ADDR
// if not mc_tech [ side ] then
70270: LD_EXP 85
70274: PUSH
70275: LD_VAR 0 4
70279: ARRAY
70280: NOT
70281: IFFALSE 70285
// continue ;
70283: GO 70244
// if BuildingStatus ( j ) = bs_idle then
70285: LD_VAR 0 3
70289: PPUSH
70290: CALL_OW 461
70294: PUSH
70295: LD_INT 2
70297: EQUAL
70298: IFFALSE 70471
// begin if idle_lab then
70300: LD_VAR 0 11
70304: IFFALSE 70375
// begin tmp2 := UnitsInside ( idle_lab ) ;
70306: LD_ADDR_VAR 0 9
70310: PUSH
70311: LD_VAR 0 11
70315: PPUSH
70316: CALL_OW 313
70320: ST_TO_ADDR
// if tmp2 then
70321: LD_VAR 0 9
70325: IFFALSE 70367
// for x in tmp2 do
70327: LD_ADDR_VAR 0 7
70331: PUSH
70332: LD_VAR 0 9
70336: PUSH
70337: FOR_IN
70338: IFFALSE 70365
// begin ComExitBuilding ( x ) ;
70340: LD_VAR 0 7
70344: PPUSH
70345: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70349: LD_VAR 0 7
70353: PPUSH
70354: LD_VAR 0 3
70358: PPUSH
70359: CALL_OW 180
// end ;
70363: GO 70337
70365: POP
70366: POP
// idle_lab := 0 ;
70367: LD_ADDR_VAR 0 11
70371: PUSH
70372: LD_INT 0
70374: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70375: LD_ADDR_VAR 0 5
70379: PUSH
70380: LD_EXP 85
70384: PUSH
70385: LD_VAR 0 4
70389: ARRAY
70390: PUSH
70391: FOR_IN
70392: IFFALSE 70452
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70394: LD_VAR 0 3
70398: PPUSH
70399: LD_VAR 0 5
70403: PPUSH
70404: CALL_OW 430
70408: PUSH
70409: LD_VAR 0 4
70413: PPUSH
70414: LD_VAR 0 5
70418: PPUSH
70419: CALL 14219 0 2
70423: AND
70424: IFFALSE 70450
// begin researching := true ;
70426: LD_ADDR_VAR 0 10
70430: PUSH
70431: LD_INT 1
70433: ST_TO_ADDR
// ComResearch ( j , t ) ;
70434: LD_VAR 0 3
70438: PPUSH
70439: LD_VAR 0 5
70443: PPUSH
70444: CALL_OW 124
// break ;
70448: GO 70452
// end ;
70450: GO 70391
70452: POP
70453: POP
// if not researching then
70454: LD_VAR 0 10
70458: NOT
70459: IFFALSE 70471
// idle_lab := j ;
70461: LD_ADDR_VAR 0 11
70465: PUSH
70466: LD_VAR 0 3
70470: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70471: LD_VAR 0 3
70475: PPUSH
70476: CALL_OW 461
70480: PUSH
70481: LD_INT 10
70483: EQUAL
70484: IFFALSE 71072
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70486: LD_EXP 87
70490: PUSH
70491: LD_VAR 0 2
70495: ARRAY
70496: NOT
70497: PUSH
70498: LD_EXP 88
70502: PUSH
70503: LD_VAR 0 2
70507: ARRAY
70508: NOT
70509: AND
70510: PUSH
70511: LD_EXP 85
70515: PUSH
70516: LD_VAR 0 4
70520: ARRAY
70521: PUSH
70522: LD_INT 1
70524: GREATER
70525: AND
70526: IFFALSE 70657
// begin ComCancel ( j ) ;
70528: LD_VAR 0 3
70532: PPUSH
70533: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70537: LD_ADDR_EXP 85
70541: PUSH
70542: LD_EXP 85
70546: PPUSH
70547: LD_VAR 0 4
70551: PPUSH
70552: LD_EXP 85
70556: PUSH
70557: LD_VAR 0 4
70561: ARRAY
70562: PPUSH
70563: LD_EXP 85
70567: PUSH
70568: LD_VAR 0 4
70572: ARRAY
70573: PUSH
70574: LD_INT 1
70576: MINUS
70577: PPUSH
70578: LD_EXP 85
70582: PUSH
70583: LD_VAR 0 4
70587: ARRAY
70588: PPUSH
70589: LD_INT 0
70591: PPUSH
70592: CALL 19668 0 4
70596: PPUSH
70597: CALL_OW 1
70601: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70602: LD_ADDR_EXP 85
70606: PUSH
70607: LD_EXP 85
70611: PPUSH
70612: LD_VAR 0 4
70616: PPUSH
70617: LD_EXP 85
70621: PUSH
70622: LD_VAR 0 4
70626: ARRAY
70627: PPUSH
70628: LD_EXP 85
70632: PUSH
70633: LD_VAR 0 4
70637: ARRAY
70638: PPUSH
70639: LD_INT 1
70641: PPUSH
70642: LD_INT 0
70644: PPUSH
70645: CALL 19668 0 4
70649: PPUSH
70650: CALL_OW 1
70654: ST_TO_ADDR
// continue ;
70655: GO 70244
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70657: LD_EXP 87
70661: PUSH
70662: LD_VAR 0 2
70666: ARRAY
70667: PUSH
70668: LD_EXP 88
70672: PUSH
70673: LD_VAR 0 2
70677: ARRAY
70678: NOT
70679: AND
70680: IFFALSE 70807
// begin mc_ape_in_lab := Add ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70682: LD_ADDR_EXP 88
70686: PUSH
70687: LD_EXP 88
70691: PPUSH
70692: LD_VAR 0 2
70696: PUSH
70697: LD_EXP 88
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: PUSH
70708: LD_INT 1
70710: PLUS
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: PPUSH
70716: LD_EXP 87
70720: PUSH
70721: LD_VAR 0 2
70725: ARRAY
70726: PUSH
70727: LD_INT 1
70729: ARRAY
70730: PPUSH
70731: CALL 20685 0 3
70735: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70736: LD_EXP 87
70740: PUSH
70741: LD_VAR 0 2
70745: ARRAY
70746: PUSH
70747: LD_INT 1
70749: ARRAY
70750: PPUSH
70751: LD_INT 112
70753: PPUSH
70754: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70758: LD_ADDR_VAR 0 9
70762: PUSH
70763: LD_EXP 87
70767: PUSH
70768: LD_VAR 0 2
70772: ARRAY
70773: PPUSH
70774: LD_INT 1
70776: PPUSH
70777: CALL_OW 3
70781: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70782: LD_ADDR_EXP 87
70786: PUSH
70787: LD_EXP 87
70791: PPUSH
70792: LD_VAR 0 2
70796: PPUSH
70797: LD_VAR 0 9
70801: PPUSH
70802: CALL_OW 1
70806: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70807: LD_EXP 87
70811: PUSH
70812: LD_VAR 0 2
70816: ARRAY
70817: PUSH
70818: LD_EXP 88
70822: PUSH
70823: LD_VAR 0 2
70827: ARRAY
70828: AND
70829: PUSH
70830: LD_EXP 88
70834: PUSH
70835: LD_VAR 0 2
70839: ARRAY
70840: PUSH
70841: LD_INT 1
70843: ARRAY
70844: PPUSH
70845: CALL_OW 310
70849: NOT
70850: AND
70851: PUSH
70852: LD_VAR 0 3
70856: PPUSH
70857: CALL_OW 313
70861: PUSH
70862: LD_INT 6
70864: EQUAL
70865: AND
70866: IFFALSE 70922
// begin tmp2 := UnitsInside ( j ) ;
70868: LD_ADDR_VAR 0 9
70872: PUSH
70873: LD_VAR 0 3
70877: PPUSH
70878: CALL_OW 313
70882: ST_TO_ADDR
// if tmp2 = 6 then
70883: LD_VAR 0 9
70887: PUSH
70888: LD_INT 6
70890: EQUAL
70891: IFFALSE 70922
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70893: LD_VAR 0 9
70897: PUSH
70898: LD_INT 1
70900: ARRAY
70901: PPUSH
70902: LD_INT 112
70904: PPUSH
70905: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70909: LD_VAR 0 9
70913: PUSH
70914: LD_INT 1
70916: ARRAY
70917: PPUSH
70918: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70922: LD_EXP 88
70926: PUSH
70927: LD_VAR 0 2
70931: ARRAY
70932: PUSH
70933: LD_EXP 88
70937: PUSH
70938: LD_VAR 0 2
70942: ARRAY
70943: PUSH
70944: LD_INT 1
70946: ARRAY
70947: PPUSH
70948: CALL_OW 314
70952: NOT
70953: AND
70954: PUSH
70955: LD_EXP 88
70959: PUSH
70960: LD_VAR 0 2
70964: ARRAY
70965: PUSH
70966: LD_INT 1
70968: ARRAY
70969: PPUSH
70970: CALL_OW 310
70974: NOT
70975: AND
70976: IFFALSE 71002
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
70978: LD_EXP 88
70982: PUSH
70983: LD_VAR 0 2
70987: ARRAY
70988: PUSH
70989: LD_INT 1
70991: ARRAY
70992: PPUSH
70993: LD_VAR 0 3
70997: PPUSH
70998: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71002: LD_EXP 88
71006: PUSH
71007: LD_VAR 0 2
71011: ARRAY
71012: PUSH
71013: LD_INT 1
71015: ARRAY
71016: PPUSH
71017: CALL_OW 310
71021: PUSH
71022: LD_EXP 88
71026: PUSH
71027: LD_VAR 0 2
71031: ARRAY
71032: PUSH
71033: LD_INT 1
71035: ARRAY
71036: PPUSH
71037: CALL_OW 310
71041: PPUSH
71042: CALL_OW 461
71046: PUSH
71047: LD_INT 3
71049: NONEQUAL
71050: AND
71051: IFFALSE 71072
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71053: LD_EXP 88
71057: PUSH
71058: LD_VAR 0 2
71062: ARRAY
71063: PUSH
71064: LD_INT 1
71066: ARRAY
71067: PPUSH
71068: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71072: LD_VAR 0 3
71076: PPUSH
71077: CALL_OW 461
71081: PUSH
71082: LD_INT 6
71084: EQUAL
71085: PUSH
71086: LD_VAR 0 6
71090: PUSH
71091: LD_INT 1
71093: GREATER
71094: AND
71095: IFFALSE 71235
// begin sci := [ ] ;
71097: LD_ADDR_VAR 0 8
71101: PUSH
71102: EMPTY
71103: ST_TO_ADDR
// for x in tmp diff j do
71104: LD_ADDR_VAR 0 7
71108: PUSH
71109: LD_VAR 0 6
71113: PUSH
71114: LD_VAR 0 3
71118: DIFF
71119: PUSH
71120: FOR_IN
71121: IFFALSE 71161
// begin if BuildingStatus ( x ) = bs_idle then
71123: LD_VAR 0 7
71127: PPUSH
71128: CALL_OW 461
71132: PUSH
71133: LD_INT 2
71135: EQUAL
71136: IFFALSE 71159
// sci := sci ^ UnitsInside ( x ) ;
71138: LD_ADDR_VAR 0 8
71142: PUSH
71143: LD_VAR 0 8
71147: PUSH
71148: LD_VAR 0 7
71152: PPUSH
71153: CALL_OW 313
71157: ADD
71158: ST_TO_ADDR
// end ;
71159: GO 71120
71161: POP
71162: POP
// if not sci then
71163: LD_VAR 0 8
71167: NOT
71168: IFFALSE 71172
// continue ;
71170: GO 70244
// for x in sci do
71172: LD_ADDR_VAR 0 7
71176: PUSH
71177: LD_VAR 0 8
71181: PUSH
71182: FOR_IN
71183: IFFALSE 71233
// if IsInUnit ( x ) and not HasTask ( x ) then
71185: LD_VAR 0 7
71189: PPUSH
71190: CALL_OW 310
71194: PUSH
71195: LD_VAR 0 7
71199: PPUSH
71200: CALL_OW 314
71204: NOT
71205: AND
71206: IFFALSE 71231
// begin ComExitBuilding ( x ) ;
71208: LD_VAR 0 7
71212: PPUSH
71213: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71217: LD_VAR 0 7
71221: PPUSH
71222: LD_VAR 0 3
71226: PPUSH
71227: CALL_OW 180
// end ;
71231: GO 71182
71233: POP
71234: POP
// end ; end ;
71235: GO 70244
71237: POP
71238: POP
// end ;
71239: GO 70198
71241: POP
71242: POP
// end ;
71243: LD_VAR 0 1
71247: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71248: LD_INT 0
71250: PPUSH
71251: PPUSH
// if not mc_bases then
71252: LD_EXP 58
71256: NOT
71257: IFFALSE 71261
// exit ;
71259: GO 71342
// for i = 1 to mc_bases do
71261: LD_ADDR_VAR 0 2
71265: PUSH
71266: DOUBLE
71267: LD_INT 1
71269: DEC
71270: ST_TO_ADDR
71271: LD_EXP 58
71275: PUSH
71276: FOR_TO
71277: IFFALSE 71340
// if mc_mines [ i ] and mc_miners [ i ] then
71279: LD_EXP 71
71283: PUSH
71284: LD_VAR 0 2
71288: ARRAY
71289: PUSH
71290: LD_EXP 72
71294: PUSH
71295: LD_VAR 0 2
71299: ARRAY
71300: AND
71301: IFFALSE 71338
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71303: LD_EXP 72
71307: PUSH
71308: LD_VAR 0 2
71312: ARRAY
71313: PUSH
71314: LD_INT 1
71316: ARRAY
71317: PPUSH
71318: CALL_OW 255
71322: PPUSH
71323: LD_EXP 71
71327: PUSH
71328: LD_VAR 0 2
71332: ARRAY
71333: PPUSH
71334: CALL 17307 0 2
71338: GO 71276
71340: POP
71341: POP
// end ;
71342: LD_VAR 0 1
71346: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71347: LD_INT 0
71349: PPUSH
71350: PPUSH
71351: PPUSH
71352: PPUSH
71353: PPUSH
71354: PPUSH
71355: PPUSH
71356: PPUSH
// if not mc_bases or not mc_parking then
71357: LD_EXP 58
71361: NOT
71362: PUSH
71363: LD_EXP 82
71367: NOT
71368: OR
71369: IFFALSE 71373
// exit ;
71371: GO 72085
// for i = 1 to mc_bases do
71373: LD_ADDR_VAR 0 2
71377: PUSH
71378: DOUBLE
71379: LD_INT 1
71381: DEC
71382: ST_TO_ADDR
71383: LD_EXP 58
71387: PUSH
71388: FOR_TO
71389: IFFALSE 72083
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71391: LD_EXP 58
71395: PUSH
71396: LD_VAR 0 2
71400: ARRAY
71401: NOT
71402: PUSH
71403: LD_EXP 82
71407: PUSH
71408: LD_VAR 0 2
71412: ARRAY
71413: NOT
71414: OR
71415: IFFALSE 71419
// continue ;
71417: GO 71388
// if mc_scan [ i ] then
71419: LD_EXP 81
71423: PUSH
71424: LD_VAR 0 2
71428: ARRAY
71429: IFFALSE 71455
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71431: LD_ADDR_EXP 70
71435: PUSH
71436: LD_EXP 70
71440: PPUSH
71441: LD_VAR 0 2
71445: PPUSH
71446: EMPTY
71447: PPUSH
71448: CALL_OW 1
71452: ST_TO_ADDR
// continue ;
71453: GO 71388
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71455: LD_ADDR_VAR 0 5
71459: PUSH
71460: LD_EXP 58
71464: PUSH
71465: LD_VAR 0 2
71469: ARRAY
71470: PUSH
71471: LD_INT 1
71473: ARRAY
71474: PPUSH
71475: CALL_OW 255
71479: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71480: LD_ADDR_VAR 0 6
71484: PUSH
71485: LD_EXP 58
71489: PUSH
71490: LD_VAR 0 2
71494: ARRAY
71495: PPUSH
71496: LD_INT 30
71498: PUSH
71499: LD_INT 3
71501: PUSH
71502: EMPTY
71503: LIST
71504: LIST
71505: PPUSH
71506: CALL_OW 72
71510: ST_TO_ADDR
// if not fac then
71511: LD_VAR 0 6
71515: NOT
71516: IFFALSE 71567
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71518: LD_ADDR_VAR 0 6
71522: PUSH
71523: LD_EXP 58
71527: PUSH
71528: LD_VAR 0 2
71532: ARRAY
71533: PPUSH
71534: LD_INT 2
71536: PUSH
71537: LD_INT 30
71539: PUSH
71540: LD_INT 0
71542: PUSH
71543: EMPTY
71544: LIST
71545: LIST
71546: PUSH
71547: LD_INT 30
71549: PUSH
71550: LD_INT 1
71552: PUSH
71553: EMPTY
71554: LIST
71555: LIST
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: LIST
71561: PPUSH
71562: CALL_OW 72
71566: ST_TO_ADDR
// if not fac then
71567: LD_VAR 0 6
71571: NOT
71572: IFFALSE 71576
// continue ;
71574: GO 71388
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71576: LD_ADDR_VAR 0 7
71580: PUSH
71581: LD_EXP 82
71585: PUSH
71586: LD_VAR 0 2
71590: ARRAY
71591: PPUSH
71592: LD_INT 22
71594: PUSH
71595: LD_VAR 0 5
71599: PUSH
71600: EMPTY
71601: LIST
71602: LIST
71603: PUSH
71604: LD_INT 21
71606: PUSH
71607: LD_INT 2
71609: PUSH
71610: EMPTY
71611: LIST
71612: LIST
71613: PUSH
71614: LD_INT 3
71616: PUSH
71617: LD_INT 24
71619: PUSH
71620: LD_INT 1000
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: EMPTY
71628: LIST
71629: LIST
71630: PUSH
71631: EMPTY
71632: LIST
71633: LIST
71634: LIST
71635: PPUSH
71636: CALL_OW 70
71640: PUSH
71641: LD_INT 22
71643: PUSH
71644: LD_VAR 0 5
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: LD_INT 91
71655: PUSH
71656: LD_VAR 0 6
71660: PUSH
71661: LD_INT 1
71663: ARRAY
71664: PUSH
71665: LD_INT 25
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 21
71675: PUSH
71676: LD_INT 2
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 3
71685: PUSH
71686: LD_INT 24
71688: PUSH
71689: LD_INT 1000
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: PPUSH
71706: CALL_OW 69
71710: UNION
71711: ST_TO_ADDR
// if not vehs then
71712: LD_VAR 0 7
71716: NOT
71717: IFFALSE 71743
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71719: LD_ADDR_EXP 70
71723: PUSH
71724: LD_EXP 70
71728: PPUSH
71729: LD_VAR 0 2
71733: PPUSH
71734: EMPTY
71735: PPUSH
71736: CALL_OW 1
71740: ST_TO_ADDR
// continue ;
71741: GO 71388
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71743: LD_ADDR_VAR 0 8
71747: PUSH
71748: LD_EXP 58
71752: PUSH
71753: LD_VAR 0 2
71757: ARRAY
71758: PPUSH
71759: LD_INT 30
71761: PUSH
71762: LD_INT 3
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: PPUSH
71769: CALL_OW 72
71773: ST_TO_ADDR
// if tmp then
71774: LD_VAR 0 8
71778: IFFALSE 71881
// begin for j in tmp do
71780: LD_ADDR_VAR 0 3
71784: PUSH
71785: LD_VAR 0 8
71789: PUSH
71790: FOR_IN
71791: IFFALSE 71879
// for k in UnitsInside ( j ) do
71793: LD_ADDR_VAR 0 4
71797: PUSH
71798: LD_VAR 0 3
71802: PPUSH
71803: CALL_OW 313
71807: PUSH
71808: FOR_IN
71809: IFFALSE 71875
// if k then
71811: LD_VAR 0 4
71815: IFFALSE 71873
// if not k in mc_repair_vehicle [ i ] then
71817: LD_VAR 0 4
71821: PUSH
71822: LD_EXP 70
71826: PUSH
71827: LD_VAR 0 2
71831: ARRAY
71832: IN
71833: NOT
71834: IFFALSE 71873
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71836: LD_ADDR_EXP 70
71840: PUSH
71841: LD_EXP 70
71845: PPUSH
71846: LD_VAR 0 2
71850: PPUSH
71851: LD_EXP 70
71855: PUSH
71856: LD_VAR 0 2
71860: ARRAY
71861: PUSH
71862: LD_VAR 0 4
71866: UNION
71867: PPUSH
71868: CALL_OW 1
71872: ST_TO_ADDR
71873: GO 71808
71875: POP
71876: POP
71877: GO 71790
71879: POP
71880: POP
// end ; if not mc_repair_vehicle [ i ] then
71881: LD_EXP 70
71885: PUSH
71886: LD_VAR 0 2
71890: ARRAY
71891: NOT
71892: IFFALSE 71896
// continue ;
71894: GO 71388
// for j in mc_repair_vehicle [ i ] do
71896: LD_ADDR_VAR 0 3
71900: PUSH
71901: LD_EXP 70
71905: PUSH
71906: LD_VAR 0 2
71910: ARRAY
71911: PUSH
71912: FOR_IN
71913: IFFALSE 72079
// begin if GetClass ( j ) <> 3 then
71915: LD_VAR 0 3
71919: PPUSH
71920: CALL_OW 257
71924: PUSH
71925: LD_INT 3
71927: NONEQUAL
71928: IFFALSE 71969
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71930: LD_ADDR_EXP 70
71934: PUSH
71935: LD_EXP 70
71939: PPUSH
71940: LD_VAR 0 2
71944: PPUSH
71945: LD_EXP 70
71949: PUSH
71950: LD_VAR 0 2
71954: ARRAY
71955: PUSH
71956: LD_VAR 0 3
71960: DIFF
71961: PPUSH
71962: CALL_OW 1
71966: ST_TO_ADDR
// continue ;
71967: GO 71912
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71969: LD_VAR 0 3
71973: PPUSH
71974: CALL_OW 311
71978: NOT
71979: PUSH
71980: LD_VAR 0 3
71984: PUSH
71985: LD_EXP 61
71989: PUSH
71990: LD_VAR 0 2
71994: ARRAY
71995: PUSH
71996: LD_INT 1
71998: ARRAY
71999: IN
72000: NOT
72001: AND
72002: PUSH
72003: LD_VAR 0 3
72007: PUSH
72008: LD_EXP 61
72012: PUSH
72013: LD_VAR 0 2
72017: ARRAY
72018: PUSH
72019: LD_INT 2
72021: ARRAY
72022: IN
72023: NOT
72024: AND
72025: IFFALSE 72077
// begin if IsInUnit ( j ) then
72027: LD_VAR 0 3
72031: PPUSH
72032: CALL_OW 310
72036: IFFALSE 72047
// ComExitBuilding ( j ) ;
72038: LD_VAR 0 3
72042: PPUSH
72043: CALL_OW 122
// if not HasTask ( j ) then
72047: LD_VAR 0 3
72051: PPUSH
72052: CALL_OW 314
72056: NOT
72057: IFFALSE 72077
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72059: LD_VAR 0 3
72063: PPUSH
72064: LD_VAR 0 7
72068: PUSH
72069: LD_INT 1
72071: ARRAY
72072: PPUSH
72073: CALL_OW 189
// end ; end ;
72077: GO 71912
72079: POP
72080: POP
// end ;
72081: GO 71388
72083: POP
72084: POP
// end ;
72085: LD_VAR 0 1
72089: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72090: LD_INT 0
72092: PPUSH
72093: PPUSH
72094: PPUSH
72095: PPUSH
72096: PPUSH
72097: PPUSH
72098: PPUSH
72099: PPUSH
72100: PPUSH
72101: PPUSH
72102: PPUSH
// if not mc_bases then
72103: LD_EXP 58
72107: NOT
72108: IFFALSE 72112
// exit ;
72110: GO 72914
// for i = 1 to mc_bases do
72112: LD_ADDR_VAR 0 2
72116: PUSH
72117: DOUBLE
72118: LD_INT 1
72120: DEC
72121: ST_TO_ADDR
72122: LD_EXP 58
72126: PUSH
72127: FOR_TO
72128: IFFALSE 72912
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72130: LD_EXP 86
72134: PUSH
72135: LD_VAR 0 2
72139: ARRAY
72140: NOT
72141: PUSH
72142: LD_EXP 61
72146: PUSH
72147: LD_VAR 0 2
72151: ARRAY
72152: PUSH
72153: LD_INT 1
72155: ARRAY
72156: OR
72157: PUSH
72158: LD_EXP 61
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PUSH
72169: LD_INT 2
72171: ARRAY
72172: OR
72173: PUSH
72174: LD_EXP 84
72178: PUSH
72179: LD_VAR 0 2
72183: ARRAY
72184: PPUSH
72185: LD_INT 1
72187: PPUSH
72188: CALL_OW 325
72192: NOT
72193: OR
72194: PUSH
72195: LD_EXP 81
72199: PUSH
72200: LD_VAR 0 2
72204: ARRAY
72205: OR
72206: IFFALSE 72210
// continue ;
72208: GO 72127
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72210: LD_ADDR_VAR 0 8
72214: PUSH
72215: LD_EXP 58
72219: PUSH
72220: LD_VAR 0 2
72224: ARRAY
72225: PPUSH
72226: LD_INT 25
72228: PUSH
72229: LD_INT 4
72231: PUSH
72232: EMPTY
72233: LIST
72234: LIST
72235: PUSH
72236: LD_INT 50
72238: PUSH
72239: EMPTY
72240: LIST
72241: PUSH
72242: LD_INT 3
72244: PUSH
72245: LD_INT 60
72247: PUSH
72248: EMPTY
72249: LIST
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: LIST
72259: PPUSH
72260: CALL_OW 72
72264: PUSH
72265: LD_EXP 62
72269: PUSH
72270: LD_VAR 0 2
72274: ARRAY
72275: DIFF
72276: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72277: LD_ADDR_VAR 0 9
72281: PUSH
72282: LD_EXP 58
72286: PUSH
72287: LD_VAR 0 2
72291: ARRAY
72292: PPUSH
72293: LD_INT 2
72295: PUSH
72296: LD_INT 30
72298: PUSH
72299: LD_INT 0
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: LD_INT 30
72308: PUSH
72309: LD_INT 1
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: LIST
72320: PPUSH
72321: CALL_OW 72
72325: ST_TO_ADDR
// if not tmp or not dep then
72326: LD_VAR 0 8
72330: NOT
72331: PUSH
72332: LD_VAR 0 9
72336: NOT
72337: OR
72338: IFFALSE 72342
// continue ;
72340: GO 72127
// side := GetSide ( tmp [ 1 ] ) ;
72342: LD_ADDR_VAR 0 11
72346: PUSH
72347: LD_VAR 0 8
72351: PUSH
72352: LD_INT 1
72354: ARRAY
72355: PPUSH
72356: CALL_OW 255
72360: ST_TO_ADDR
// dep := dep [ 1 ] ;
72361: LD_ADDR_VAR 0 9
72365: PUSH
72366: LD_VAR 0 9
72370: PUSH
72371: LD_INT 1
72373: ARRAY
72374: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72375: LD_ADDR_VAR 0 7
72379: PUSH
72380: LD_EXP 86
72384: PUSH
72385: LD_VAR 0 2
72389: ARRAY
72390: PPUSH
72391: LD_INT 22
72393: PUSH
72394: LD_INT 0
72396: PUSH
72397: EMPTY
72398: LIST
72399: LIST
72400: PUSH
72401: LD_INT 25
72403: PUSH
72404: LD_INT 12
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PPUSH
72415: CALL_OW 70
72419: PUSH
72420: LD_INT 22
72422: PUSH
72423: LD_INT 0
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 25
72432: PUSH
72433: LD_INT 12
72435: PUSH
72436: EMPTY
72437: LIST
72438: LIST
72439: PUSH
72440: LD_INT 91
72442: PUSH
72443: LD_VAR 0 9
72447: PUSH
72448: LD_INT 20
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: LIST
72455: PUSH
72456: EMPTY
72457: LIST
72458: LIST
72459: LIST
72460: PPUSH
72461: CALL_OW 69
72465: UNION
72466: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72467: LD_ADDR_VAR 0 10
72471: PUSH
72472: LD_EXP 86
72476: PUSH
72477: LD_VAR 0 2
72481: ARRAY
72482: PPUSH
72483: LD_INT 81
72485: PUSH
72486: LD_VAR 0 11
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PPUSH
72495: CALL_OW 70
72499: ST_TO_ADDR
// if not apes or danger_at_area then
72500: LD_VAR 0 7
72504: NOT
72505: PUSH
72506: LD_VAR 0 10
72510: OR
72511: IFFALSE 72561
// begin if mc_taming [ i ] then
72513: LD_EXP 89
72517: PUSH
72518: LD_VAR 0 2
72522: ARRAY
72523: IFFALSE 72559
// begin MC_Reset ( i , 121 ) ;
72525: LD_VAR 0 2
72529: PPUSH
72530: LD_INT 121
72532: PPUSH
72533: CALL 58609 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72537: LD_ADDR_EXP 89
72541: PUSH
72542: LD_EXP 89
72546: PPUSH
72547: LD_VAR 0 2
72551: PPUSH
72552: EMPTY
72553: PPUSH
72554: CALL_OW 1
72558: ST_TO_ADDR
// end ; continue ;
72559: GO 72127
// end ; for j in tmp do
72561: LD_ADDR_VAR 0 3
72565: PUSH
72566: LD_VAR 0 8
72570: PUSH
72571: FOR_IN
72572: IFFALSE 72908
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72574: LD_VAR 0 3
72578: PUSH
72579: LD_EXP 89
72583: PUSH
72584: LD_VAR 0 2
72588: ARRAY
72589: IN
72590: NOT
72591: PUSH
72592: LD_EXP 89
72596: PUSH
72597: LD_VAR 0 2
72601: ARRAY
72602: PUSH
72603: LD_INT 3
72605: LESS
72606: AND
72607: IFFALSE 72665
// begin SetTag ( j , 121 ) ;
72609: LD_VAR 0 3
72613: PPUSH
72614: LD_INT 121
72616: PPUSH
72617: CALL_OW 109
// mc_taming := Add ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72621: LD_ADDR_EXP 89
72625: PUSH
72626: LD_EXP 89
72630: PPUSH
72631: LD_VAR 0 2
72635: PUSH
72636: LD_EXP 89
72640: PUSH
72641: LD_VAR 0 2
72645: ARRAY
72646: PUSH
72647: LD_INT 1
72649: PLUS
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PPUSH
72655: LD_VAR 0 3
72659: PPUSH
72660: CALL 20685 0 3
72664: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72665: LD_VAR 0 3
72669: PUSH
72670: LD_EXP 89
72674: PUSH
72675: LD_VAR 0 2
72679: ARRAY
72680: IN
72681: IFFALSE 72906
// begin if GetClass ( j ) <> 4 then
72683: LD_VAR 0 3
72687: PPUSH
72688: CALL_OW 257
72692: PUSH
72693: LD_INT 4
72695: NONEQUAL
72696: IFFALSE 72749
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72698: LD_ADDR_EXP 89
72702: PUSH
72703: LD_EXP 89
72707: PPUSH
72708: LD_VAR 0 2
72712: PPUSH
72713: LD_EXP 89
72717: PUSH
72718: LD_VAR 0 2
72722: ARRAY
72723: PUSH
72724: LD_VAR 0 3
72728: DIFF
72729: PPUSH
72730: CALL_OW 1
72734: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72735: LD_VAR 0 3
72739: PPUSH
72740: LD_INT 0
72742: PPUSH
72743: CALL_OW 109
// continue ;
72747: GO 72571
// end ; if IsInUnit ( j ) then
72749: LD_VAR 0 3
72753: PPUSH
72754: CALL_OW 310
72758: IFFALSE 72769
// ComExitBuilding ( j ) ;
72760: LD_VAR 0 3
72764: PPUSH
72765: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72769: LD_ADDR_VAR 0 6
72773: PUSH
72774: LD_VAR 0 7
72778: PPUSH
72779: LD_VAR 0 3
72783: PPUSH
72784: CALL_OW 74
72788: ST_TO_ADDR
// if not ape then
72789: LD_VAR 0 6
72793: NOT
72794: IFFALSE 72798
// break ;
72796: GO 72908
// x := GetX ( ape ) ;
72798: LD_ADDR_VAR 0 4
72802: PUSH
72803: LD_VAR 0 6
72807: PPUSH
72808: CALL_OW 250
72812: ST_TO_ADDR
// y := GetY ( ape ) ;
72813: LD_ADDR_VAR 0 5
72817: PUSH
72818: LD_VAR 0 6
72822: PPUSH
72823: CALL_OW 251
72827: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72828: LD_VAR 0 4
72832: PPUSH
72833: LD_VAR 0 5
72837: PPUSH
72838: CALL_OW 488
72842: NOT
72843: PUSH
72844: LD_VAR 0 11
72848: PPUSH
72849: LD_VAR 0 4
72853: PPUSH
72854: LD_VAR 0 5
72858: PPUSH
72859: LD_INT 20
72861: PPUSH
72862: CALL 21179 0 4
72866: PUSH
72867: LD_INT 4
72869: ARRAY
72870: OR
72871: IFFALSE 72875
// break ;
72873: GO 72908
// if not HasTask ( j ) then
72875: LD_VAR 0 3
72879: PPUSH
72880: CALL_OW 314
72884: NOT
72885: IFFALSE 72906
// ComTameXY ( j , x , y ) ;
72887: LD_VAR 0 3
72891: PPUSH
72892: LD_VAR 0 4
72896: PPUSH
72897: LD_VAR 0 5
72901: PPUSH
72902: CALL_OW 131
// end ; end ;
72906: GO 72571
72908: POP
72909: POP
// end ;
72910: GO 72127
72912: POP
72913: POP
// end ;
72914: LD_VAR 0 1
72918: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72919: LD_INT 0
72921: PPUSH
72922: PPUSH
72923: PPUSH
72924: PPUSH
72925: PPUSH
72926: PPUSH
72927: PPUSH
72928: PPUSH
// if not mc_bases then
72929: LD_EXP 58
72933: NOT
72934: IFFALSE 72938
// exit ;
72936: GO 73564
// for i = 1 to mc_bases do
72938: LD_ADDR_VAR 0 2
72942: PUSH
72943: DOUBLE
72944: LD_INT 1
72946: DEC
72947: ST_TO_ADDR
72948: LD_EXP 58
72952: PUSH
72953: FOR_TO
72954: IFFALSE 73562
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
72956: LD_EXP 87
72960: PUSH
72961: LD_VAR 0 2
72965: ARRAY
72966: NOT
72967: PUSH
72968: LD_EXP 87
72972: PUSH
72973: LD_VAR 0 2
72977: ARRAY
72978: PPUSH
72979: LD_INT 25
72981: PUSH
72982: LD_INT 12
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PPUSH
72989: CALL_OW 72
72993: NOT
72994: OR
72995: IFFALSE 72999
// continue ;
72997: GO 72953
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
72999: LD_ADDR_VAR 0 5
73003: PUSH
73004: LD_EXP 87
73008: PUSH
73009: LD_VAR 0 2
73013: ARRAY
73014: PUSH
73015: LD_INT 1
73017: ARRAY
73018: PPUSH
73019: CALL_OW 255
73023: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73024: LD_VAR 0 5
73028: PPUSH
73029: LD_INT 2
73031: PPUSH
73032: CALL_OW 325
73036: IFFALSE 73289
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73038: LD_ADDR_VAR 0 4
73042: PUSH
73043: LD_EXP 87
73047: PUSH
73048: LD_VAR 0 2
73052: ARRAY
73053: PPUSH
73054: LD_INT 25
73056: PUSH
73057: LD_INT 16
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: PPUSH
73064: CALL_OW 72
73068: ST_TO_ADDR
// if tmp < 6 then
73069: LD_VAR 0 4
73073: PUSH
73074: LD_INT 6
73076: LESS
73077: IFFALSE 73289
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73079: LD_ADDR_VAR 0 6
73083: PUSH
73084: LD_EXP 58
73088: PUSH
73089: LD_VAR 0 2
73093: ARRAY
73094: PPUSH
73095: LD_INT 2
73097: PUSH
73098: LD_INT 30
73100: PUSH
73101: LD_INT 0
73103: PUSH
73104: EMPTY
73105: LIST
73106: LIST
73107: PUSH
73108: LD_INT 30
73110: PUSH
73111: LD_INT 1
73113: PUSH
73114: EMPTY
73115: LIST
73116: LIST
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: LIST
73122: PPUSH
73123: CALL_OW 72
73127: ST_TO_ADDR
// if depot then
73128: LD_VAR 0 6
73132: IFFALSE 73289
// begin selected := 0 ;
73134: LD_ADDR_VAR 0 7
73138: PUSH
73139: LD_INT 0
73141: ST_TO_ADDR
// for j in depot do
73142: LD_ADDR_VAR 0 3
73146: PUSH
73147: LD_VAR 0 6
73151: PUSH
73152: FOR_IN
73153: IFFALSE 73184
// begin if UnitsInside ( j ) < 6 then
73155: LD_VAR 0 3
73159: PPUSH
73160: CALL_OW 313
73164: PUSH
73165: LD_INT 6
73167: LESS
73168: IFFALSE 73182
// begin selected := j ;
73170: LD_ADDR_VAR 0 7
73174: PUSH
73175: LD_VAR 0 3
73179: ST_TO_ADDR
// break ;
73180: GO 73184
// end ; end ;
73182: GO 73152
73184: POP
73185: POP
// if selected then
73186: LD_VAR 0 7
73190: IFFALSE 73289
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73192: LD_ADDR_VAR 0 3
73196: PUSH
73197: LD_EXP 87
73201: PUSH
73202: LD_VAR 0 2
73206: ARRAY
73207: PPUSH
73208: LD_INT 25
73210: PUSH
73211: LD_INT 12
73213: PUSH
73214: EMPTY
73215: LIST
73216: LIST
73217: PPUSH
73218: CALL_OW 72
73222: PUSH
73223: FOR_IN
73224: IFFALSE 73287
// if not HasTask ( j ) then
73226: LD_VAR 0 3
73230: PPUSH
73231: CALL_OW 314
73235: NOT
73236: IFFALSE 73285
// begin if not IsInUnit ( j ) then
73238: LD_VAR 0 3
73242: PPUSH
73243: CALL_OW 310
73247: NOT
73248: IFFALSE 73264
// ComEnterUnit ( j , selected ) ;
73250: LD_VAR 0 3
73254: PPUSH
73255: LD_VAR 0 7
73259: PPUSH
73260: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73264: LD_VAR 0 3
73268: PPUSH
73269: LD_INT 16
73271: PPUSH
73272: CALL_OW 183
// AddComExitBuilding ( j ) ;
73276: LD_VAR 0 3
73280: PPUSH
73281: CALL_OW 182
// end ;
73285: GO 73223
73287: POP
73288: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73289: LD_VAR 0 5
73293: PPUSH
73294: LD_INT 11
73296: PPUSH
73297: CALL_OW 325
73301: IFFALSE 73560
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73303: LD_ADDR_VAR 0 4
73307: PUSH
73308: LD_EXP 87
73312: PUSH
73313: LD_VAR 0 2
73317: ARRAY
73318: PPUSH
73319: LD_INT 25
73321: PUSH
73322: LD_INT 16
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PPUSH
73329: CALL_OW 72
73333: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73334: LD_VAR 0 4
73338: PUSH
73339: LD_INT 6
73341: GREATEREQUAL
73342: PUSH
73343: LD_VAR 0 5
73347: PPUSH
73348: LD_INT 2
73350: PPUSH
73351: CALL_OW 325
73355: NOT
73356: OR
73357: IFFALSE 73560
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73359: LD_ADDR_VAR 0 8
73363: PUSH
73364: LD_EXP 58
73368: PUSH
73369: LD_VAR 0 2
73373: ARRAY
73374: PPUSH
73375: LD_INT 2
73377: PUSH
73378: LD_INT 30
73380: PUSH
73381: LD_INT 4
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 30
73390: PUSH
73391: LD_INT 5
73393: PUSH
73394: EMPTY
73395: LIST
73396: LIST
73397: PUSH
73398: EMPTY
73399: LIST
73400: LIST
73401: LIST
73402: PPUSH
73403: CALL_OW 72
73407: ST_TO_ADDR
// if barracks then
73408: LD_VAR 0 8
73412: IFFALSE 73560
// begin selected := 0 ;
73414: LD_ADDR_VAR 0 7
73418: PUSH
73419: LD_INT 0
73421: ST_TO_ADDR
// for j in barracks do
73422: LD_ADDR_VAR 0 3
73426: PUSH
73427: LD_VAR 0 8
73431: PUSH
73432: FOR_IN
73433: IFFALSE 73464
// begin if UnitsInside ( j ) < 6 then
73435: LD_VAR 0 3
73439: PPUSH
73440: CALL_OW 313
73444: PUSH
73445: LD_INT 6
73447: LESS
73448: IFFALSE 73462
// begin selected := j ;
73450: LD_ADDR_VAR 0 7
73454: PUSH
73455: LD_VAR 0 3
73459: ST_TO_ADDR
// break ;
73460: GO 73464
// end ; end ;
73462: GO 73432
73464: POP
73465: POP
// if selected then
73466: LD_VAR 0 7
73470: IFFALSE 73560
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73472: LD_ADDR_VAR 0 3
73476: PUSH
73477: LD_EXP 87
73481: PUSH
73482: LD_VAR 0 2
73486: ARRAY
73487: PPUSH
73488: LD_INT 25
73490: PUSH
73491: LD_INT 12
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PPUSH
73498: CALL_OW 72
73502: PUSH
73503: FOR_IN
73504: IFFALSE 73558
// if not IsInUnit ( j ) and not HasTask ( j ) then
73506: LD_VAR 0 3
73510: PPUSH
73511: CALL_OW 310
73515: NOT
73516: PUSH
73517: LD_VAR 0 3
73521: PPUSH
73522: CALL_OW 314
73526: NOT
73527: AND
73528: IFFALSE 73556
// begin ComEnterUnit ( j , selected ) ;
73530: LD_VAR 0 3
73534: PPUSH
73535: LD_VAR 0 7
73539: PPUSH
73540: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73544: LD_VAR 0 3
73548: PPUSH
73549: LD_INT 15
73551: PPUSH
73552: CALL_OW 183
// end ;
73556: GO 73503
73558: POP
73559: POP
// end ; end ; end ; end ; end ;
73560: GO 72953
73562: POP
73563: POP
// end ;
73564: LD_VAR 0 1
73568: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73569: LD_INT 0
73571: PPUSH
73572: PPUSH
73573: PPUSH
73574: PPUSH
// if not mc_bases then
73575: LD_EXP 58
73579: NOT
73580: IFFALSE 73584
// exit ;
73582: GO 73762
// for i = 1 to mc_bases do
73584: LD_ADDR_VAR 0 2
73588: PUSH
73589: DOUBLE
73590: LD_INT 1
73592: DEC
73593: ST_TO_ADDR
73594: LD_EXP 58
73598: PUSH
73599: FOR_TO
73600: IFFALSE 73760
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73602: LD_ADDR_VAR 0 4
73606: PUSH
73607: LD_EXP 58
73611: PUSH
73612: LD_VAR 0 2
73616: ARRAY
73617: PPUSH
73618: LD_INT 25
73620: PUSH
73621: LD_INT 9
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PPUSH
73628: CALL_OW 72
73632: ST_TO_ADDR
// if not tmp then
73633: LD_VAR 0 4
73637: NOT
73638: IFFALSE 73642
// continue ;
73640: GO 73599
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73642: LD_EXP 84
73646: PUSH
73647: LD_VAR 0 2
73651: ARRAY
73652: PPUSH
73653: LD_INT 29
73655: PPUSH
73656: CALL_OW 325
73660: NOT
73661: PUSH
73662: LD_EXP 84
73666: PUSH
73667: LD_VAR 0 2
73671: ARRAY
73672: PPUSH
73673: LD_INT 28
73675: PPUSH
73676: CALL_OW 325
73680: NOT
73681: AND
73682: IFFALSE 73686
// continue ;
73684: GO 73599
// for j in tmp do
73686: LD_ADDR_VAR 0 3
73690: PUSH
73691: LD_VAR 0 4
73695: PUSH
73696: FOR_IN
73697: IFFALSE 73756
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73699: LD_VAR 0 3
73703: PUSH
73704: LD_EXP 61
73708: PUSH
73709: LD_VAR 0 2
73713: ARRAY
73714: PUSH
73715: LD_INT 1
73717: ARRAY
73718: IN
73719: NOT
73720: PUSH
73721: LD_VAR 0 3
73725: PUSH
73726: LD_EXP 61
73730: PUSH
73731: LD_VAR 0 2
73735: ARRAY
73736: PUSH
73737: LD_INT 2
73739: ARRAY
73740: IN
73741: NOT
73742: AND
73743: IFFALSE 73754
// ComSpaceTimeShoot ( j ) ;
73745: LD_VAR 0 3
73749: PPUSH
73750: CALL 14310 0 1
73754: GO 73696
73756: POP
73757: POP
// end ;
73758: GO 73599
73760: POP
73761: POP
// end ;
73762: LD_VAR 0 1
73766: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73767: LD_INT 0
73769: PPUSH
73770: PPUSH
73771: PPUSH
73772: PPUSH
73773: PPUSH
73774: PPUSH
73775: PPUSH
73776: PPUSH
73777: PPUSH
// if not mc_bases then
73778: LD_EXP 58
73782: NOT
73783: IFFALSE 73787
// exit ;
73785: GO 74409
// for i = 1 to mc_bases do
73787: LD_ADDR_VAR 0 2
73791: PUSH
73792: DOUBLE
73793: LD_INT 1
73795: DEC
73796: ST_TO_ADDR
73797: LD_EXP 58
73801: PUSH
73802: FOR_TO
73803: IFFALSE 74407
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73805: LD_EXP 93
73809: PUSH
73810: LD_VAR 0 2
73814: ARRAY
73815: NOT
73816: PUSH
73817: LD_INT 38
73819: PPUSH
73820: LD_EXP 84
73824: PUSH
73825: LD_VAR 0 2
73829: ARRAY
73830: PPUSH
73831: CALL_OW 321
73835: PUSH
73836: LD_INT 2
73838: NONEQUAL
73839: OR
73840: IFFALSE 73844
// continue ;
73842: GO 73802
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73844: LD_ADDR_VAR 0 8
73848: PUSH
73849: LD_EXP 58
73853: PUSH
73854: LD_VAR 0 2
73858: ARRAY
73859: PPUSH
73860: LD_INT 30
73862: PUSH
73863: LD_INT 34
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PPUSH
73870: CALL_OW 72
73874: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73875: LD_ADDR_VAR 0 9
73879: PUSH
73880: LD_EXP 58
73884: PUSH
73885: LD_VAR 0 2
73889: ARRAY
73890: PPUSH
73891: LD_INT 25
73893: PUSH
73894: LD_INT 4
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PPUSH
73901: CALL_OW 72
73905: PPUSH
73906: LD_INT 0
73908: PPUSH
73909: CALL 53265 0 2
73913: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73914: LD_VAR 0 9
73918: NOT
73919: PUSH
73920: LD_VAR 0 8
73924: NOT
73925: OR
73926: PUSH
73927: LD_EXP 58
73931: PUSH
73932: LD_VAR 0 2
73936: ARRAY
73937: PPUSH
73938: LD_INT 124
73940: PPUSH
73941: CALL 53265 0 2
73945: OR
73946: IFFALSE 73950
// continue ;
73948: GO 73802
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
73950: LD_EXP 94
73954: PUSH
73955: LD_VAR 0 2
73959: ARRAY
73960: PUSH
73961: LD_EXP 93
73965: PUSH
73966: LD_VAR 0 2
73970: ARRAY
73971: LESS
73972: PUSH
73973: LD_EXP 94
73977: PUSH
73978: LD_VAR 0 2
73982: ARRAY
73983: PUSH
73984: LD_VAR 0 8
73988: LESS
73989: AND
73990: IFFALSE 74405
// begin tmp := sci [ 1 ] ;
73992: LD_ADDR_VAR 0 7
73996: PUSH
73997: LD_VAR 0 9
74001: PUSH
74002: LD_INT 1
74004: ARRAY
74005: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74006: LD_VAR 0 7
74010: PPUSH
74011: LD_INT 124
74013: PPUSH
74014: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74018: LD_ADDR_VAR 0 3
74022: PUSH
74023: DOUBLE
74024: LD_EXP 93
74028: PUSH
74029: LD_VAR 0 2
74033: ARRAY
74034: INC
74035: ST_TO_ADDR
74036: LD_EXP 93
74040: PUSH
74041: LD_VAR 0 2
74045: ARRAY
74046: PUSH
74047: FOR_DOWNTO
74048: IFFALSE 74391
// begin if IsInUnit ( tmp ) then
74050: LD_VAR 0 7
74054: PPUSH
74055: CALL_OW 310
74059: IFFALSE 74070
// ComExitBuilding ( tmp ) ;
74061: LD_VAR 0 7
74065: PPUSH
74066: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74070: LD_INT 35
74072: PPUSH
74073: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74077: LD_VAR 0 7
74081: PPUSH
74082: CALL_OW 310
74086: NOT
74087: PUSH
74088: LD_VAR 0 7
74092: PPUSH
74093: CALL_OW 314
74097: NOT
74098: AND
74099: IFFALSE 74070
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74101: LD_ADDR_VAR 0 6
74105: PUSH
74106: LD_VAR 0 7
74110: PPUSH
74111: CALL_OW 250
74115: PUSH
74116: LD_VAR 0 7
74120: PPUSH
74121: CALL_OW 251
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74130: LD_INT 35
74132: PPUSH
74133: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74137: LD_ADDR_VAR 0 4
74141: PUSH
74142: LD_EXP 93
74146: PUSH
74147: LD_VAR 0 2
74151: ARRAY
74152: PUSH
74153: LD_VAR 0 3
74157: ARRAY
74158: PUSH
74159: LD_INT 1
74161: ARRAY
74162: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74163: LD_ADDR_VAR 0 5
74167: PUSH
74168: LD_EXP 93
74172: PUSH
74173: LD_VAR 0 2
74177: ARRAY
74178: PUSH
74179: LD_VAR 0 3
74183: ARRAY
74184: PUSH
74185: LD_INT 2
74187: ARRAY
74188: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74189: LD_VAR 0 7
74193: PPUSH
74194: LD_INT 10
74196: PPUSH
74197: CALL 22876 0 2
74201: PUSH
74202: LD_INT 4
74204: ARRAY
74205: IFFALSE 74243
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74207: LD_VAR 0 7
74211: PPUSH
74212: LD_VAR 0 6
74216: PUSH
74217: LD_INT 1
74219: ARRAY
74220: PPUSH
74221: LD_VAR 0 6
74225: PUSH
74226: LD_INT 2
74228: ARRAY
74229: PPUSH
74230: CALL_OW 111
// wait ( 0 0$10 ) ;
74234: LD_INT 350
74236: PPUSH
74237: CALL_OW 67
// end else
74241: GO 74269
// begin ComMoveXY ( tmp , x , y ) ;
74243: LD_VAR 0 7
74247: PPUSH
74248: LD_VAR 0 4
74252: PPUSH
74253: LD_VAR 0 5
74257: PPUSH
74258: CALL_OW 111
// wait ( 0 0$3 ) ;
74262: LD_INT 105
74264: PPUSH
74265: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74269: LD_VAR 0 7
74273: PPUSH
74274: LD_VAR 0 4
74278: PPUSH
74279: LD_VAR 0 5
74283: PPUSH
74284: CALL_OW 307
74288: IFFALSE 74130
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74290: LD_VAR 0 7
74294: PPUSH
74295: LD_VAR 0 4
74299: PPUSH
74300: LD_VAR 0 5
74304: PPUSH
74305: LD_VAR 0 8
74309: PUSH
74310: LD_VAR 0 3
74314: ARRAY
74315: PPUSH
74316: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74320: LD_INT 35
74322: PPUSH
74323: CALL_OW 67
// until not HasTask ( tmp ) ;
74327: LD_VAR 0 7
74331: PPUSH
74332: CALL_OW 314
74336: NOT
74337: IFFALSE 74320
// mc_teleport_exit_set := Add ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74339: LD_ADDR_EXP 94
74343: PUSH
74344: LD_EXP 94
74348: PPUSH
74349: LD_VAR 0 2
74353: PUSH
74354: LD_EXP 94
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: PUSH
74365: LD_INT 1
74367: PLUS
74368: PUSH
74369: EMPTY
74370: LIST
74371: LIST
74372: PPUSH
74373: LD_VAR 0 8
74377: PUSH
74378: LD_VAR 0 3
74382: ARRAY
74383: PPUSH
74384: CALL 20685 0 3
74388: ST_TO_ADDR
// end ;
74389: GO 74047
74391: POP
74392: POP
// MC_Reset ( i , 124 ) ;
74393: LD_VAR 0 2
74397: PPUSH
74398: LD_INT 124
74400: PPUSH
74401: CALL 58609 0 2
// end ; end ;
74405: GO 73802
74407: POP
74408: POP
// end ;
74409: LD_VAR 0 1
74413: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74414: LD_INT 0
74416: PPUSH
74417: PPUSH
74418: PPUSH
// if not mc_bases then
74419: LD_EXP 58
74423: NOT
74424: IFFALSE 74428
// exit ;
74426: GO 75034
// for i = 1 to mc_bases do
74428: LD_ADDR_VAR 0 2
74432: PUSH
74433: DOUBLE
74434: LD_INT 1
74436: DEC
74437: ST_TO_ADDR
74438: LD_EXP 58
74442: PUSH
74443: FOR_TO
74444: IFFALSE 75032
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74446: LD_ADDR_VAR 0 3
74450: PUSH
74451: LD_EXP 58
74455: PUSH
74456: LD_VAR 0 2
74460: ARRAY
74461: PPUSH
74462: LD_INT 25
74464: PUSH
74465: LD_INT 4
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PPUSH
74472: CALL_OW 72
74476: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74477: LD_VAR 0 3
74481: NOT
74482: PUSH
74483: LD_EXP 95
74487: PUSH
74488: LD_VAR 0 2
74492: ARRAY
74493: NOT
74494: OR
74495: PUSH
74496: LD_EXP 58
74500: PUSH
74501: LD_VAR 0 2
74505: ARRAY
74506: PPUSH
74507: LD_INT 2
74509: PUSH
74510: LD_INT 30
74512: PUSH
74513: LD_INT 0
74515: PUSH
74516: EMPTY
74517: LIST
74518: LIST
74519: PUSH
74520: LD_INT 30
74522: PUSH
74523: LD_INT 1
74525: PUSH
74526: EMPTY
74527: LIST
74528: LIST
74529: PUSH
74530: EMPTY
74531: LIST
74532: LIST
74533: LIST
74534: PPUSH
74535: CALL_OW 72
74539: NOT
74540: OR
74541: IFFALSE 74591
// begin if mc_deposits_finder [ i ] then
74543: LD_EXP 96
74547: PUSH
74548: LD_VAR 0 2
74552: ARRAY
74553: IFFALSE 74589
// begin MC_Reset ( i , 125 ) ;
74555: LD_VAR 0 2
74559: PPUSH
74560: LD_INT 125
74562: PPUSH
74563: CALL 58609 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74567: LD_ADDR_EXP 96
74571: PUSH
74572: LD_EXP 96
74576: PPUSH
74577: LD_VAR 0 2
74581: PPUSH
74582: EMPTY
74583: PPUSH
74584: CALL_OW 1
74588: ST_TO_ADDR
// end ; continue ;
74589: GO 74443
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74591: LD_EXP 95
74595: PUSH
74596: LD_VAR 0 2
74600: ARRAY
74601: PUSH
74602: LD_INT 1
74604: ARRAY
74605: PUSH
74606: LD_INT 3
74608: ARRAY
74609: PUSH
74610: LD_INT 1
74612: EQUAL
74613: PUSH
74614: LD_INT 20
74616: PPUSH
74617: LD_EXP 84
74621: PUSH
74622: LD_VAR 0 2
74626: ARRAY
74627: PPUSH
74628: CALL_OW 321
74632: PUSH
74633: LD_INT 2
74635: NONEQUAL
74636: AND
74637: IFFALSE 74687
// begin if mc_deposits_finder [ i ] then
74639: LD_EXP 96
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: IFFALSE 74685
// begin MC_Reset ( i , 125 ) ;
74651: LD_VAR 0 2
74655: PPUSH
74656: LD_INT 125
74658: PPUSH
74659: CALL 58609 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74663: LD_ADDR_EXP 96
74667: PUSH
74668: LD_EXP 96
74672: PPUSH
74673: LD_VAR 0 2
74677: PPUSH
74678: EMPTY
74679: PPUSH
74680: CALL_OW 1
74684: ST_TO_ADDR
// end ; continue ;
74685: GO 74443
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74687: LD_EXP 95
74691: PUSH
74692: LD_VAR 0 2
74696: ARRAY
74697: PUSH
74698: LD_INT 1
74700: ARRAY
74701: PUSH
74702: LD_INT 1
74704: ARRAY
74705: PPUSH
74706: LD_EXP 95
74710: PUSH
74711: LD_VAR 0 2
74715: ARRAY
74716: PUSH
74717: LD_INT 1
74719: ARRAY
74720: PUSH
74721: LD_INT 2
74723: ARRAY
74724: PPUSH
74725: LD_EXP 84
74729: PUSH
74730: LD_VAR 0 2
74734: ARRAY
74735: PPUSH
74736: CALL_OW 440
74740: IFFALSE 74783
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74742: LD_ADDR_EXP 95
74746: PUSH
74747: LD_EXP 95
74751: PPUSH
74752: LD_VAR 0 2
74756: PPUSH
74757: LD_EXP 95
74761: PUSH
74762: LD_VAR 0 2
74766: ARRAY
74767: PPUSH
74768: LD_INT 1
74770: PPUSH
74771: CALL_OW 3
74775: PPUSH
74776: CALL_OW 1
74780: ST_TO_ADDR
74781: GO 75030
// begin if not mc_deposits_finder [ i ] then
74783: LD_EXP 96
74787: PUSH
74788: LD_VAR 0 2
74792: ARRAY
74793: NOT
74794: IFFALSE 74846
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74796: LD_ADDR_EXP 96
74800: PUSH
74801: LD_EXP 96
74805: PPUSH
74806: LD_VAR 0 2
74810: PPUSH
74811: LD_VAR 0 3
74815: PUSH
74816: LD_INT 1
74818: ARRAY
74819: PUSH
74820: EMPTY
74821: LIST
74822: PPUSH
74823: CALL_OW 1
74827: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74828: LD_VAR 0 3
74832: PUSH
74833: LD_INT 1
74835: ARRAY
74836: PPUSH
74837: LD_INT 125
74839: PPUSH
74840: CALL_OW 109
// end else
74844: GO 75030
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74846: LD_EXP 96
74850: PUSH
74851: LD_VAR 0 2
74855: ARRAY
74856: PUSH
74857: LD_INT 1
74859: ARRAY
74860: PPUSH
74861: CALL_OW 310
74865: IFFALSE 74888
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74867: LD_EXP 96
74871: PUSH
74872: LD_VAR 0 2
74876: ARRAY
74877: PUSH
74878: LD_INT 1
74880: ARRAY
74881: PPUSH
74882: CALL_OW 122
74886: GO 75030
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74888: LD_EXP 96
74892: PUSH
74893: LD_VAR 0 2
74897: ARRAY
74898: PUSH
74899: LD_INT 1
74901: ARRAY
74902: PPUSH
74903: CALL_OW 314
74907: NOT
74908: PUSH
74909: LD_EXP 96
74913: PUSH
74914: LD_VAR 0 2
74918: ARRAY
74919: PUSH
74920: LD_INT 1
74922: ARRAY
74923: PPUSH
74924: LD_EXP 95
74928: PUSH
74929: LD_VAR 0 2
74933: ARRAY
74934: PUSH
74935: LD_INT 1
74937: ARRAY
74938: PUSH
74939: LD_INT 1
74941: ARRAY
74942: PPUSH
74943: LD_EXP 95
74947: PUSH
74948: LD_VAR 0 2
74952: ARRAY
74953: PUSH
74954: LD_INT 1
74956: ARRAY
74957: PUSH
74958: LD_INT 2
74960: ARRAY
74961: PPUSH
74962: CALL_OW 297
74966: PUSH
74967: LD_INT 6
74969: GREATER
74970: AND
74971: IFFALSE 75030
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
74973: LD_EXP 96
74977: PUSH
74978: LD_VAR 0 2
74982: ARRAY
74983: PUSH
74984: LD_INT 1
74986: ARRAY
74987: PPUSH
74988: LD_EXP 95
74992: PUSH
74993: LD_VAR 0 2
74997: ARRAY
74998: PUSH
74999: LD_INT 1
75001: ARRAY
75002: PUSH
75003: LD_INT 1
75005: ARRAY
75006: PPUSH
75007: LD_EXP 95
75011: PUSH
75012: LD_VAR 0 2
75016: ARRAY
75017: PUSH
75018: LD_INT 1
75020: ARRAY
75021: PUSH
75022: LD_INT 2
75024: ARRAY
75025: PPUSH
75026: CALL_OW 111
// end ; end ; end ;
75030: GO 74443
75032: POP
75033: POP
// end ;
75034: LD_VAR 0 1
75038: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75039: LD_INT 0
75041: PPUSH
75042: PPUSH
75043: PPUSH
75044: PPUSH
75045: PPUSH
75046: PPUSH
75047: PPUSH
75048: PPUSH
75049: PPUSH
75050: PPUSH
75051: PPUSH
// if not mc_bases then
75052: LD_EXP 58
75056: NOT
75057: IFFALSE 75061
// exit ;
75059: GO 75785
// for i = 1 to mc_bases do
75061: LD_ADDR_VAR 0 2
75065: PUSH
75066: DOUBLE
75067: LD_INT 1
75069: DEC
75070: ST_TO_ADDR
75071: LD_EXP 58
75075: PUSH
75076: FOR_TO
75077: IFFALSE 75783
// begin if not mc_bases [ i ] then
75079: LD_EXP 58
75083: PUSH
75084: LD_VAR 0 2
75088: ARRAY
75089: NOT
75090: IFFALSE 75094
// continue ;
75092: GO 75076
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75094: LD_ADDR_VAR 0 7
75098: PUSH
75099: LD_EXP 58
75103: PUSH
75104: LD_VAR 0 2
75108: ARRAY
75109: PUSH
75110: LD_INT 1
75112: ARRAY
75113: PPUSH
75114: CALL_OW 248
75118: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75119: LD_VAR 0 7
75123: PUSH
75124: LD_INT 3
75126: EQUAL
75127: PUSH
75128: LD_EXP 77
75132: PUSH
75133: LD_VAR 0 2
75137: ARRAY
75138: PUSH
75139: LD_EXP 80
75143: PUSH
75144: LD_VAR 0 2
75148: ARRAY
75149: UNION
75150: PPUSH
75151: LD_INT 33
75153: PUSH
75154: LD_INT 2
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PPUSH
75161: CALL_OW 72
75165: NOT
75166: OR
75167: IFFALSE 75171
// continue ;
75169: GO 75076
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75171: LD_ADDR_VAR 0 9
75175: PUSH
75176: LD_EXP 58
75180: PUSH
75181: LD_VAR 0 2
75185: ARRAY
75186: PPUSH
75187: LD_INT 30
75189: PUSH
75190: LD_INT 36
75192: PUSH
75193: EMPTY
75194: LIST
75195: LIST
75196: PPUSH
75197: CALL_OW 72
75201: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75202: LD_ADDR_VAR 0 10
75206: PUSH
75207: LD_EXP 77
75211: PUSH
75212: LD_VAR 0 2
75216: ARRAY
75217: PPUSH
75218: LD_INT 34
75220: PUSH
75221: LD_INT 31
75223: PUSH
75224: EMPTY
75225: LIST
75226: LIST
75227: PPUSH
75228: CALL_OW 72
75232: ST_TO_ADDR
// if not cts and not mcts then
75233: LD_VAR 0 9
75237: NOT
75238: PUSH
75239: LD_VAR 0 10
75243: NOT
75244: AND
75245: IFFALSE 75249
// continue ;
75247: GO 75076
// x := cts ;
75249: LD_ADDR_VAR 0 11
75253: PUSH
75254: LD_VAR 0 9
75258: ST_TO_ADDR
// if not x then
75259: LD_VAR 0 11
75263: NOT
75264: IFFALSE 75276
// x := mcts ;
75266: LD_ADDR_VAR 0 11
75270: PUSH
75271: LD_VAR 0 10
75275: ST_TO_ADDR
// if mc_remote_driver [ i ] then
75276: LD_EXP 98
75280: PUSH
75281: LD_VAR 0 2
75285: ARRAY
75286: IFFALSE 75555
// for j in mc_remote_driver [ i ] do
75288: LD_ADDR_VAR 0 3
75292: PUSH
75293: LD_EXP 98
75297: PUSH
75298: LD_VAR 0 2
75302: ARRAY
75303: PUSH
75304: FOR_IN
75305: IFFALSE 75553
// begin if GetClass ( j ) <> 3 then
75307: LD_VAR 0 3
75311: PPUSH
75312: CALL_OW 257
75316: PUSH
75317: LD_INT 3
75319: NONEQUAL
75320: IFFALSE 75373
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75322: LD_ADDR_EXP 98
75326: PUSH
75327: LD_EXP 98
75331: PPUSH
75332: LD_VAR 0 2
75336: PPUSH
75337: LD_EXP 98
75341: PUSH
75342: LD_VAR 0 2
75346: ARRAY
75347: PUSH
75348: LD_VAR 0 3
75352: DIFF
75353: PPUSH
75354: CALL_OW 1
75358: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75359: LD_VAR 0 3
75363: PPUSH
75364: LD_INT 0
75366: PPUSH
75367: CALL_OW 109
// continue ;
75371: GO 75304
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75373: LD_VAR 0 3
75377: PPUSH
75378: CALL_OW 310
75382: NOT
75383: PUSH
75384: LD_VAR 0 3
75388: PPUSH
75389: CALL_OW 310
75393: PPUSH
75394: CALL_OW 266
75398: PUSH
75399: LD_INT 36
75401: NONEQUAL
75402: PUSH
75403: LD_VAR 0 3
75407: PPUSH
75408: CALL 53353 0 1
75412: NOT
75413: AND
75414: OR
75415: IFFALSE 75551
// begin if IsInUnit ( j ) then
75417: LD_VAR 0 3
75421: PPUSH
75422: CALL_OW 310
75426: IFFALSE 75437
// ComExitBuilding ( j ) ;
75428: LD_VAR 0 3
75432: PPUSH
75433: CALL_OW 122
// ct := 0 ;
75437: LD_ADDR_VAR 0 8
75441: PUSH
75442: LD_INT 0
75444: ST_TO_ADDR
// for k in x do
75445: LD_ADDR_VAR 0 4
75449: PUSH
75450: LD_VAR 0 11
75454: PUSH
75455: FOR_IN
75456: IFFALSE 75529
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75458: LD_VAR 0 4
75462: PPUSH
75463: CALL_OW 264
75467: PUSH
75468: LD_INT 31
75470: EQUAL
75471: PUSH
75472: LD_VAR 0 4
75476: PPUSH
75477: CALL_OW 311
75481: NOT
75482: AND
75483: PUSH
75484: LD_VAR 0 4
75488: PPUSH
75489: CALL_OW 266
75493: PUSH
75494: LD_INT 36
75496: EQUAL
75497: PUSH
75498: LD_VAR 0 4
75502: PPUSH
75503: CALL_OW 313
75507: PUSH
75508: LD_INT 3
75510: LESS
75511: AND
75512: OR
75513: IFFALSE 75527
// begin ct := k ;
75515: LD_ADDR_VAR 0 8
75519: PUSH
75520: LD_VAR 0 4
75524: ST_TO_ADDR
// break ;
75525: GO 75529
// end ;
75527: GO 75455
75529: POP
75530: POP
// if ct then
75531: LD_VAR 0 8
75535: IFFALSE 75551
// ComEnterUnit ( j , ct ) ;
75537: LD_VAR 0 3
75541: PPUSH
75542: LD_VAR 0 8
75546: PPUSH
75547: CALL_OW 120
// end ; end ;
75551: GO 75304
75553: POP
75554: POP
// places := 0 ;
75555: LD_ADDR_VAR 0 5
75559: PUSH
75560: LD_INT 0
75562: ST_TO_ADDR
// for j = 1 to x do
75563: LD_ADDR_VAR 0 3
75567: PUSH
75568: DOUBLE
75569: LD_INT 1
75571: DEC
75572: ST_TO_ADDR
75573: LD_VAR 0 11
75577: PUSH
75578: FOR_TO
75579: IFFALSE 75634
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75581: LD_VAR 0 11
75585: PUSH
75586: LD_VAR 0 3
75590: ARRAY
75591: PPUSH
75592: CALL_OW 264
75596: PUSH
75597: LD_INT 31
75599: EQUAL
75600: IFFALSE 75618
// places := places + 1 else
75602: LD_ADDR_VAR 0 5
75606: PUSH
75607: LD_VAR 0 5
75611: PUSH
75612: LD_INT 1
75614: PLUS
75615: ST_TO_ADDR
75616: GO 75632
// places := places + 3 ;
75618: LD_ADDR_VAR 0 5
75622: PUSH
75623: LD_VAR 0 5
75627: PUSH
75628: LD_INT 3
75630: PLUS
75631: ST_TO_ADDR
75632: GO 75578
75634: POP
75635: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75636: LD_ADDR_VAR 0 6
75640: PUSH
75641: LD_EXP 58
75645: PUSH
75646: LD_VAR 0 2
75650: ARRAY
75651: PPUSH
75652: LD_INT 25
75654: PUSH
75655: LD_INT 3
75657: PUSH
75658: EMPTY
75659: LIST
75660: LIST
75661: PPUSH
75662: CALL_OW 72
75666: PUSH
75667: LD_EXP 98
75671: PUSH
75672: LD_VAR 0 2
75676: ARRAY
75677: DIFF
75678: PPUSH
75679: LD_INT 3
75681: PPUSH
75682: CALL 54253 0 2
75686: ST_TO_ADDR
// if not tmp then
75687: LD_VAR 0 6
75691: NOT
75692: IFFALSE 75696
// continue ;
75694: GO 75076
// places := places - mc_remote_driver [ i ] ;
75696: LD_ADDR_VAR 0 5
75700: PUSH
75701: LD_VAR 0 5
75705: PUSH
75706: LD_EXP 98
75710: PUSH
75711: LD_VAR 0 2
75715: ARRAY
75716: MINUS
75717: ST_TO_ADDR
// if places then
75718: LD_VAR 0 5
75722: IFFALSE 75781
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75724: LD_ADDR_EXP 98
75728: PUSH
75729: LD_EXP 98
75733: PPUSH
75734: LD_VAR 0 2
75738: PPUSH
75739: LD_EXP 98
75743: PUSH
75744: LD_VAR 0 2
75748: ARRAY
75749: PUSH
75750: LD_VAR 0 6
75754: PUSH
75755: LD_INT 1
75757: ARRAY
75758: UNION
75759: PPUSH
75760: CALL_OW 1
75764: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75765: LD_VAR 0 6
75769: PUSH
75770: LD_INT 1
75772: ARRAY
75773: PPUSH
75774: LD_INT 126
75776: PPUSH
75777: CALL_OW 109
// end ; end ;
75781: GO 75076
75783: POP
75784: POP
// end ;
75785: LD_VAR 0 1
75789: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75790: LD_INT 0
75792: PPUSH
75793: PPUSH
75794: PPUSH
75795: PPUSH
75796: PPUSH
75797: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75798: LD_VAR 0 1
75802: NOT
75803: PUSH
75804: LD_VAR 0 2
75808: NOT
75809: OR
75810: PUSH
75811: LD_VAR 0 3
75815: NOT
75816: OR
75817: PUSH
75818: LD_VAR 0 4
75822: PUSH
75823: LD_INT 1
75825: PUSH
75826: LD_INT 2
75828: PUSH
75829: LD_INT 3
75831: PUSH
75832: LD_INT 4
75834: PUSH
75835: LD_INT 5
75837: PUSH
75838: LD_INT 8
75840: PUSH
75841: LD_INT 9
75843: PUSH
75844: LD_INT 15
75846: PUSH
75847: LD_INT 16
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: LIST
75854: LIST
75855: LIST
75856: LIST
75857: LIST
75858: LIST
75859: LIST
75860: IN
75861: NOT
75862: OR
75863: IFFALSE 75867
// exit ;
75865: GO 76767
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75867: LD_ADDR_VAR 0 2
75871: PUSH
75872: LD_VAR 0 2
75876: PPUSH
75877: LD_INT 21
75879: PUSH
75880: LD_INT 3
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 24
75889: PUSH
75890: LD_INT 250
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: PPUSH
75901: CALL_OW 72
75905: ST_TO_ADDR
// case class of 1 , 15 :
75906: LD_VAR 0 4
75910: PUSH
75911: LD_INT 1
75913: DOUBLE
75914: EQUAL
75915: IFTRUE 75925
75917: LD_INT 15
75919: DOUBLE
75920: EQUAL
75921: IFTRUE 75925
75923: GO 76010
75925: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75926: LD_ADDR_VAR 0 8
75930: PUSH
75931: LD_VAR 0 2
75935: PPUSH
75936: LD_INT 2
75938: PUSH
75939: LD_INT 30
75941: PUSH
75942: LD_INT 32
75944: PUSH
75945: EMPTY
75946: LIST
75947: LIST
75948: PUSH
75949: LD_INT 30
75951: PUSH
75952: LD_INT 31
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: EMPTY
75960: LIST
75961: LIST
75962: LIST
75963: PPUSH
75964: CALL_OW 72
75968: PUSH
75969: LD_VAR 0 2
75973: PPUSH
75974: LD_INT 2
75976: PUSH
75977: LD_INT 30
75979: PUSH
75980: LD_INT 4
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PUSH
75987: LD_INT 30
75989: PUSH
75990: LD_INT 5
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: EMPTY
75998: LIST
75999: LIST
76000: LIST
76001: PPUSH
76002: CALL_OW 72
76006: ADD
76007: ST_TO_ADDR
76008: GO 76256
76010: LD_INT 2
76012: DOUBLE
76013: EQUAL
76014: IFTRUE 76024
76016: LD_INT 16
76018: DOUBLE
76019: EQUAL
76020: IFTRUE 76024
76022: GO 76070
76024: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76025: LD_ADDR_VAR 0 8
76029: PUSH
76030: LD_VAR 0 2
76034: PPUSH
76035: LD_INT 2
76037: PUSH
76038: LD_INT 30
76040: PUSH
76041: LD_INT 0
76043: PUSH
76044: EMPTY
76045: LIST
76046: LIST
76047: PUSH
76048: LD_INT 30
76050: PUSH
76051: LD_INT 1
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: LIST
76062: PPUSH
76063: CALL_OW 72
76067: ST_TO_ADDR
76068: GO 76256
76070: LD_INT 3
76072: DOUBLE
76073: EQUAL
76074: IFTRUE 76078
76076: GO 76124
76078: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76079: LD_ADDR_VAR 0 8
76083: PUSH
76084: LD_VAR 0 2
76088: PPUSH
76089: LD_INT 2
76091: PUSH
76092: LD_INT 30
76094: PUSH
76095: LD_INT 2
76097: PUSH
76098: EMPTY
76099: LIST
76100: LIST
76101: PUSH
76102: LD_INT 30
76104: PUSH
76105: LD_INT 3
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: LIST
76116: PPUSH
76117: CALL_OW 72
76121: ST_TO_ADDR
76122: GO 76256
76124: LD_INT 4
76126: DOUBLE
76127: EQUAL
76128: IFTRUE 76132
76130: GO 76189
76132: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76133: LD_ADDR_VAR 0 8
76137: PUSH
76138: LD_VAR 0 2
76142: PPUSH
76143: LD_INT 2
76145: PUSH
76146: LD_INT 30
76148: PUSH
76149: LD_INT 6
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 30
76158: PUSH
76159: LD_INT 7
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 30
76168: PUSH
76169: LD_INT 8
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: PPUSH
76182: CALL_OW 72
76186: ST_TO_ADDR
76187: GO 76256
76189: LD_INT 5
76191: DOUBLE
76192: EQUAL
76193: IFTRUE 76209
76195: LD_INT 8
76197: DOUBLE
76198: EQUAL
76199: IFTRUE 76209
76201: LD_INT 9
76203: DOUBLE
76204: EQUAL
76205: IFTRUE 76209
76207: GO 76255
76209: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76210: LD_ADDR_VAR 0 8
76214: PUSH
76215: LD_VAR 0 2
76219: PPUSH
76220: LD_INT 2
76222: PUSH
76223: LD_INT 30
76225: PUSH
76226: LD_INT 4
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 30
76235: PUSH
76236: LD_INT 5
76238: PUSH
76239: EMPTY
76240: LIST
76241: LIST
76242: PUSH
76243: EMPTY
76244: LIST
76245: LIST
76246: LIST
76247: PPUSH
76248: CALL_OW 72
76252: ST_TO_ADDR
76253: GO 76256
76255: POP
// if not tmp then
76256: LD_VAR 0 8
76260: NOT
76261: IFFALSE 76265
// exit ;
76263: GO 76767
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76265: LD_VAR 0 4
76269: PUSH
76270: LD_INT 1
76272: PUSH
76273: LD_INT 15
76275: PUSH
76276: EMPTY
76277: LIST
76278: LIST
76279: IN
76280: PUSH
76281: LD_EXP 67
76285: PUSH
76286: LD_VAR 0 1
76290: ARRAY
76291: AND
76292: IFFALSE 76448
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76294: LD_ADDR_VAR 0 9
76298: PUSH
76299: LD_EXP 67
76303: PUSH
76304: LD_VAR 0 1
76308: ARRAY
76309: PUSH
76310: LD_INT 1
76312: ARRAY
76313: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76314: LD_VAR 0 9
76318: PUSH
76319: LD_EXP 68
76323: PUSH
76324: LD_VAR 0 1
76328: ARRAY
76329: IN
76330: NOT
76331: IFFALSE 76446
// begin mc_busy_turret_list := Add ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76333: LD_ADDR_EXP 68
76337: PUSH
76338: LD_EXP 68
76342: PPUSH
76343: LD_VAR 0 1
76347: PUSH
76348: LD_EXP 68
76352: PUSH
76353: LD_VAR 0 1
76357: ARRAY
76358: PUSH
76359: LD_INT 1
76361: PLUS
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: PPUSH
76367: LD_VAR 0 9
76371: PPUSH
76372: CALL 20685 0 3
76376: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76377: LD_ADDR_EXP 67
76381: PUSH
76382: LD_EXP 67
76386: PPUSH
76387: LD_VAR 0 1
76391: PPUSH
76392: LD_EXP 67
76396: PUSH
76397: LD_VAR 0 1
76401: ARRAY
76402: PUSH
76403: LD_VAR 0 9
76407: DIFF
76408: PPUSH
76409: CALL_OW 1
76413: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76414: LD_VAR 0 3
76418: PPUSH
76419: LD_EXP 68
76423: PUSH
76424: LD_VAR 0 1
76428: ARRAY
76429: PUSH
76430: LD_EXP 68
76434: PUSH
76435: LD_VAR 0 1
76439: ARRAY
76440: ARRAY
76441: PPUSH
76442: CALL_OW 120
// end ; exit ;
76446: GO 76767
// end ; if tmp > 1 then
76448: LD_VAR 0 8
76452: PUSH
76453: LD_INT 1
76455: GREATER
76456: IFFALSE 76560
// for i = 2 to tmp do
76458: LD_ADDR_VAR 0 6
76462: PUSH
76463: DOUBLE
76464: LD_INT 2
76466: DEC
76467: ST_TO_ADDR
76468: LD_VAR 0 8
76472: PUSH
76473: FOR_TO
76474: IFFALSE 76558
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76476: LD_VAR 0 8
76480: PUSH
76481: LD_VAR 0 6
76485: ARRAY
76486: PPUSH
76487: CALL_OW 461
76491: PUSH
76492: LD_INT 6
76494: EQUAL
76495: IFFALSE 76556
// begin x := tmp [ i ] ;
76497: LD_ADDR_VAR 0 9
76501: PUSH
76502: LD_VAR 0 8
76506: PUSH
76507: LD_VAR 0 6
76511: ARRAY
76512: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76513: LD_ADDR_VAR 0 8
76517: PUSH
76518: LD_VAR 0 8
76522: PPUSH
76523: LD_VAR 0 6
76527: PPUSH
76528: CALL_OW 3
76532: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76533: LD_ADDR_VAR 0 8
76537: PUSH
76538: LD_VAR 0 8
76542: PPUSH
76543: LD_INT 1
76545: PPUSH
76546: LD_VAR 0 9
76550: PPUSH
76551: CALL_OW 2
76555: ST_TO_ADDR
// end ;
76556: GO 76473
76558: POP
76559: POP
// for i in tmp do
76560: LD_ADDR_VAR 0 6
76564: PUSH
76565: LD_VAR 0 8
76569: PUSH
76570: FOR_IN
76571: IFFALSE 76640
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76573: LD_VAR 0 6
76577: PPUSH
76578: CALL_OW 313
76582: PUSH
76583: LD_INT 6
76585: LESS
76586: PUSH
76587: LD_VAR 0 6
76591: PPUSH
76592: CALL_OW 266
76596: PUSH
76597: LD_INT 31
76599: PUSH
76600: LD_INT 32
76602: PUSH
76603: EMPTY
76604: LIST
76605: LIST
76606: IN
76607: NOT
76608: AND
76609: PUSH
76610: LD_VAR 0 6
76614: PPUSH
76615: CALL_OW 313
76619: PUSH
76620: LD_INT 0
76622: EQUAL
76623: OR
76624: IFFALSE 76638
// begin j := i ;
76626: LD_ADDR_VAR 0 7
76630: PUSH
76631: LD_VAR 0 6
76635: ST_TO_ADDR
// break ;
76636: GO 76640
// end ; end ;
76638: GO 76570
76640: POP
76641: POP
// if j then
76642: LD_VAR 0 7
76646: IFFALSE 76664
// ComEnterUnit ( unit , j ) else
76648: LD_VAR 0 3
76652: PPUSH
76653: LD_VAR 0 7
76657: PPUSH
76658: CALL_OW 120
76662: GO 76767
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76664: LD_ADDR_VAR 0 10
76668: PUSH
76669: LD_VAR 0 2
76673: PPUSH
76674: LD_INT 2
76676: PUSH
76677: LD_INT 30
76679: PUSH
76680: LD_INT 0
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: PUSH
76687: LD_INT 30
76689: PUSH
76690: LD_INT 1
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: LIST
76701: PPUSH
76702: CALL_OW 72
76706: ST_TO_ADDR
// if depot then
76707: LD_VAR 0 10
76711: IFFALSE 76767
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76713: LD_ADDR_VAR 0 10
76717: PUSH
76718: LD_VAR 0 10
76722: PPUSH
76723: LD_VAR 0 3
76727: PPUSH
76728: CALL_OW 74
76732: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76733: LD_VAR 0 3
76737: PPUSH
76738: LD_VAR 0 10
76742: PPUSH
76743: CALL_OW 296
76747: PUSH
76748: LD_INT 10
76750: GREATER
76751: IFFALSE 76767
// ComStandNearbyBuilding ( unit , depot ) ;
76753: LD_VAR 0 3
76757: PPUSH
76758: LD_VAR 0 10
76762: PPUSH
76763: CALL 14927 0 2
// end ; end ; end ;
76767: LD_VAR 0 5
76771: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76772: LD_INT 0
76774: PPUSH
76775: PPUSH
76776: PPUSH
76777: PPUSH
// if not mc_bases then
76778: LD_EXP 58
76782: NOT
76783: IFFALSE 76787
// exit ;
76785: GO 77026
// for i = 1 to mc_bases do
76787: LD_ADDR_VAR 0 2
76791: PUSH
76792: DOUBLE
76793: LD_INT 1
76795: DEC
76796: ST_TO_ADDR
76797: LD_EXP 58
76801: PUSH
76802: FOR_TO
76803: IFFALSE 77024
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76805: LD_ADDR_VAR 0 4
76809: PUSH
76810: LD_EXP 58
76814: PUSH
76815: LD_VAR 0 2
76819: ARRAY
76820: PPUSH
76821: LD_INT 21
76823: PUSH
76824: LD_INT 1
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: PPUSH
76831: CALL_OW 72
76835: PUSH
76836: LD_EXP 87
76840: PUSH
76841: LD_VAR 0 2
76845: ARRAY
76846: UNION
76847: ST_TO_ADDR
// if not tmp then
76848: LD_VAR 0 4
76852: NOT
76853: IFFALSE 76857
// continue ;
76855: GO 76802
// for j in tmp do
76857: LD_ADDR_VAR 0 3
76861: PUSH
76862: LD_VAR 0 4
76866: PUSH
76867: FOR_IN
76868: IFFALSE 77020
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76870: LD_VAR 0 3
76874: PPUSH
76875: CALL_OW 110
76879: NOT
76880: PUSH
76881: LD_VAR 0 3
76885: PPUSH
76886: CALL_OW 314
76890: NOT
76891: AND
76892: PUSH
76893: LD_VAR 0 3
76897: PPUSH
76898: CALL_OW 311
76902: NOT
76903: AND
76904: PUSH
76905: LD_VAR 0 3
76909: PPUSH
76910: CALL_OW 310
76914: NOT
76915: AND
76916: PUSH
76917: LD_VAR 0 3
76921: PUSH
76922: LD_EXP 61
76926: PUSH
76927: LD_VAR 0 2
76931: ARRAY
76932: PUSH
76933: LD_INT 1
76935: ARRAY
76936: IN
76937: NOT
76938: AND
76939: PUSH
76940: LD_VAR 0 3
76944: PUSH
76945: LD_EXP 61
76949: PUSH
76950: LD_VAR 0 2
76954: ARRAY
76955: PUSH
76956: LD_INT 2
76958: ARRAY
76959: IN
76960: NOT
76961: AND
76962: PUSH
76963: LD_VAR 0 3
76967: PUSH
76968: LD_EXP 70
76972: PUSH
76973: LD_VAR 0 2
76977: ARRAY
76978: IN
76979: NOT
76980: AND
76981: IFFALSE 77018
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
76983: LD_VAR 0 2
76987: PPUSH
76988: LD_EXP 58
76992: PUSH
76993: LD_VAR 0 2
76997: ARRAY
76998: PPUSH
76999: LD_VAR 0 3
77003: PPUSH
77004: LD_VAR 0 3
77008: PPUSH
77009: CALL_OW 257
77013: PPUSH
77014: CALL 75790 0 4
// end ;
77018: GO 76867
77020: POP
77021: POP
// end ;
77022: GO 76802
77024: POP
77025: POP
// end ;
77026: LD_VAR 0 1
77030: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77031: LD_INT 0
77033: PPUSH
77034: PPUSH
77035: PPUSH
77036: PPUSH
77037: PPUSH
77038: PPUSH
// if not mc_bases [ base ] then
77039: LD_EXP 58
77043: PUSH
77044: LD_VAR 0 1
77048: ARRAY
77049: NOT
77050: IFFALSE 77054
// exit ;
77052: GO 77236
// tmp := [ ] ;
77054: LD_ADDR_VAR 0 6
77058: PUSH
77059: EMPTY
77060: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77061: LD_ADDR_VAR 0 7
77065: PUSH
77066: LD_VAR 0 3
77070: PPUSH
77071: LD_INT 0
77073: PPUSH
77074: CALL_OW 517
77078: ST_TO_ADDR
// if not list then
77079: LD_VAR 0 7
77083: NOT
77084: IFFALSE 77088
// exit ;
77086: GO 77236
// for i = 1 to amount do
77088: LD_ADDR_VAR 0 5
77092: PUSH
77093: DOUBLE
77094: LD_INT 1
77096: DEC
77097: ST_TO_ADDR
77098: LD_VAR 0 2
77102: PUSH
77103: FOR_TO
77104: IFFALSE 77184
// begin x := rand ( 1 , list [ 1 ] ) ;
77106: LD_ADDR_VAR 0 8
77110: PUSH
77111: LD_INT 1
77113: PPUSH
77114: LD_VAR 0 7
77118: PUSH
77119: LD_INT 1
77121: ARRAY
77122: PPUSH
77123: CALL_OW 12
77127: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77128: LD_ADDR_VAR 0 6
77132: PUSH
77133: LD_VAR 0 6
77137: PPUSH
77138: LD_VAR 0 5
77142: PPUSH
77143: LD_VAR 0 7
77147: PUSH
77148: LD_INT 1
77150: ARRAY
77151: PUSH
77152: LD_VAR 0 8
77156: ARRAY
77157: PUSH
77158: LD_VAR 0 7
77162: PUSH
77163: LD_INT 2
77165: ARRAY
77166: PUSH
77167: LD_VAR 0 8
77171: ARRAY
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: PPUSH
77177: CALL_OW 1
77181: ST_TO_ADDR
// end ;
77182: GO 77103
77184: POP
77185: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77186: LD_ADDR_EXP 71
77190: PUSH
77191: LD_EXP 71
77195: PPUSH
77196: LD_VAR 0 1
77200: PPUSH
77201: LD_VAR 0 6
77205: PPUSH
77206: CALL_OW 1
77210: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77211: LD_ADDR_EXP 73
77215: PUSH
77216: LD_EXP 73
77220: PPUSH
77221: LD_VAR 0 1
77225: PPUSH
77226: LD_VAR 0 3
77230: PPUSH
77231: CALL_OW 1
77235: ST_TO_ADDR
// end ;
77236: LD_VAR 0 4
77240: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77241: LD_INT 0
77243: PPUSH
// if not mc_bases [ base ] then
77244: LD_EXP 58
77248: PUSH
77249: LD_VAR 0 1
77253: ARRAY
77254: NOT
77255: IFFALSE 77259
// exit ;
77257: GO 77284
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77259: LD_ADDR_EXP 63
77263: PUSH
77264: LD_EXP 63
77268: PPUSH
77269: LD_VAR 0 1
77273: PPUSH
77274: LD_VAR 0 2
77278: PPUSH
77279: CALL_OW 1
77283: ST_TO_ADDR
// end ;
77284: LD_VAR 0 3
77288: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77289: LD_INT 0
77291: PPUSH
// if not mc_bases [ base ] then
77292: LD_EXP 58
77296: PUSH
77297: LD_VAR 0 1
77301: ARRAY
77302: NOT
77303: IFFALSE 77307
// exit ;
77305: GO 77344
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77307: LD_ADDR_EXP 63
77311: PUSH
77312: LD_EXP 63
77316: PPUSH
77317: LD_VAR 0 1
77321: PPUSH
77322: LD_EXP 63
77326: PUSH
77327: LD_VAR 0 1
77331: ARRAY
77332: PUSH
77333: LD_VAR 0 2
77337: UNION
77338: PPUSH
77339: CALL_OW 1
77343: ST_TO_ADDR
// end ;
77344: LD_VAR 0 3
77348: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77349: LD_INT 0
77351: PPUSH
// if not mc_bases [ base ] then
77352: LD_EXP 58
77356: PUSH
77357: LD_VAR 0 1
77361: ARRAY
77362: NOT
77363: IFFALSE 77367
// exit ;
77365: GO 77392
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77367: LD_ADDR_EXP 79
77371: PUSH
77372: LD_EXP 79
77376: PPUSH
77377: LD_VAR 0 1
77381: PPUSH
77382: LD_VAR 0 2
77386: PPUSH
77387: CALL_OW 1
77391: ST_TO_ADDR
// end ;
77392: LD_VAR 0 3
77396: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
77397: LD_INT 0
77399: PPUSH
// if not mc_bases [ base ] then
77400: LD_EXP 58
77404: PUSH
77405: LD_VAR 0 1
77409: ARRAY
77410: NOT
77411: IFFALSE 77415
// exit ;
77413: GO 77452
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
77415: LD_ADDR_EXP 79
77419: PUSH
77420: LD_EXP 79
77424: PPUSH
77425: LD_VAR 0 1
77429: PPUSH
77430: LD_EXP 79
77434: PUSH
77435: LD_VAR 0 1
77439: ARRAY
77440: PUSH
77441: LD_VAR 0 2
77445: UNION
77446: PPUSH
77447: CALL_OW 1
77451: ST_TO_ADDR
// end ;
77452: LD_VAR 0 3
77456: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77457: LD_INT 0
77459: PPUSH
// if not mc_bases [ base ] then
77460: LD_EXP 58
77464: PUSH
77465: LD_VAR 0 1
77469: ARRAY
77470: NOT
77471: IFFALSE 77475
// exit ;
77473: GO 77587
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77475: LD_ADDR_EXP 80
77479: PUSH
77480: LD_EXP 80
77484: PPUSH
77485: LD_VAR 0 1
77489: PPUSH
77490: LD_VAR 0 2
77494: PPUSH
77495: CALL_OW 1
77499: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77500: LD_ADDR_EXP 69
77504: PUSH
77505: LD_EXP 69
77509: PPUSH
77510: LD_VAR 0 1
77514: PPUSH
77515: LD_VAR 0 2
77519: PUSH
77520: LD_INT 0
77522: PLUS
77523: PPUSH
77524: CALL_OW 1
77528: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
77529: LD_ADDR_EXP 77
77533: PUSH
77534: LD_EXP 77
77538: PPUSH
77539: LD_VAR 0 1
77543: PPUSH
77544: LD_EXP 77
77548: PUSH
77549: LD_VAR 0 1
77553: ARRAY
77554: PUSH
77555: LD_EXP 80
77559: PUSH
77560: LD_VAR 0 1
77564: ARRAY
77565: PPUSH
77566: LD_INT 21
77568: PUSH
77569: LD_INT 2
77571: PUSH
77572: EMPTY
77573: LIST
77574: LIST
77575: PPUSH
77576: CALL_OW 72
77580: UNION
77581: PPUSH
77582: CALL_OW 1
77586: ST_TO_ADDR
// end ;
77587: LD_VAR 0 3
77591: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77592: LD_INT 0
77594: PPUSH
// if not mc_bases [ base ] then
77595: LD_EXP 58
77599: PUSH
77600: LD_VAR 0 1
77604: ARRAY
77605: NOT
77606: IFFALSE 77610
// exit ;
77608: GO 77635
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77610: LD_ADDR_EXP 69
77614: PUSH
77615: LD_EXP 69
77619: PPUSH
77620: LD_VAR 0 1
77624: PPUSH
77625: LD_VAR 0 2
77629: PPUSH
77630: CALL_OW 1
77634: ST_TO_ADDR
// end ;
77635: LD_VAR 0 3
77639: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77640: LD_INT 0
77642: PPUSH
77643: PPUSH
77644: PPUSH
77645: PPUSH
// if not mc_bases [ base ] then
77646: LD_EXP 58
77650: PUSH
77651: LD_VAR 0 1
77655: ARRAY
77656: NOT
77657: IFFALSE 77661
// exit ;
77659: GO 77726
// mc_attack := Add ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77661: LD_ADDR_EXP 78
77665: PUSH
77666: LD_EXP 78
77670: PPUSH
77671: LD_VAR 0 1
77675: PUSH
77676: LD_EXP 78
77680: PUSH
77681: LD_VAR 0 1
77685: ARRAY
77686: PUSH
77687: LD_INT 1
77689: PLUS
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PPUSH
77695: LD_VAR 0 1
77699: PUSH
77700: LD_VAR 0 2
77704: PUSH
77705: LD_VAR 0 3
77709: PUSH
77710: LD_VAR 0 4
77714: PUSH
77715: EMPTY
77716: LIST
77717: LIST
77718: LIST
77719: LIST
77720: PPUSH
77721: CALL 20685 0 3
77725: ST_TO_ADDR
// end ;
77726: LD_VAR 0 5
77730: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77731: LD_INT 0
77733: PPUSH
// if not mc_bases [ base ] then
77734: LD_EXP 58
77738: PUSH
77739: LD_VAR 0 1
77743: ARRAY
77744: NOT
77745: IFFALSE 77749
// exit ;
77747: GO 77774
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77749: LD_ADDR_EXP 95
77753: PUSH
77754: LD_EXP 95
77758: PPUSH
77759: LD_VAR 0 1
77763: PPUSH
77764: LD_VAR 0 2
77768: PPUSH
77769: CALL_OW 1
77773: ST_TO_ADDR
// end ;
77774: LD_VAR 0 3
77778: RET
// export function MC_GetMinesField ( base ) ; begin
77779: LD_INT 0
77781: PPUSH
// result := mc_mines [ base ] ;
77782: LD_ADDR_VAR 0 2
77786: PUSH
77787: LD_EXP 71
77791: PUSH
77792: LD_VAR 0 1
77796: ARRAY
77797: ST_TO_ADDR
// end ;
77798: LD_VAR 0 2
77802: RET
// export function MC_GetProduceList ( base ) ; begin
77803: LD_INT 0
77805: PPUSH
// result := mc_produce [ base ] ;
77806: LD_ADDR_VAR 0 2
77810: PUSH
77811: LD_EXP 79
77815: PUSH
77816: LD_VAR 0 1
77820: ARRAY
77821: ST_TO_ADDR
// end ;
77822: LD_VAR 0 2
77826: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77827: LD_INT 0
77829: PPUSH
77830: PPUSH
// if not mc_bases then
77831: LD_EXP 58
77835: NOT
77836: IFFALSE 77840
// exit ;
77838: GO 77905
// if mc_bases [ base ] then
77840: LD_EXP 58
77844: PUSH
77845: LD_VAR 0 1
77849: ARRAY
77850: IFFALSE 77905
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77852: LD_ADDR_VAR 0 3
77856: PUSH
77857: LD_EXP 58
77861: PUSH
77862: LD_VAR 0 1
77866: ARRAY
77867: PPUSH
77868: LD_INT 30
77870: PUSH
77871: LD_VAR 0 2
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PPUSH
77880: CALL_OW 72
77884: ST_TO_ADDR
// if result then
77885: LD_VAR 0 3
77889: IFFALSE 77905
// result := result [ 1 ] ;
77891: LD_ADDR_VAR 0 3
77895: PUSH
77896: LD_VAR 0 3
77900: PUSH
77901: LD_INT 1
77903: ARRAY
77904: ST_TO_ADDR
// end ; end ;
77905: LD_VAR 0 3
77909: RET
// export function MC_SetTame ( base , area ) ; begin
77910: LD_INT 0
77912: PPUSH
// if not mc_bases or not base then
77913: LD_EXP 58
77917: NOT
77918: PUSH
77919: LD_VAR 0 1
77923: NOT
77924: OR
77925: IFFALSE 77929
// exit ;
77927: GO 77954
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77929: LD_ADDR_EXP 86
77933: PUSH
77934: LD_EXP 86
77938: PPUSH
77939: LD_VAR 0 1
77943: PPUSH
77944: LD_VAR 0 2
77948: PPUSH
77949: CALL_OW 1
77953: ST_TO_ADDR
// end ;
77954: LD_VAR 0 3
77958: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
77959: LD_INT 0
77961: PPUSH
77962: PPUSH
// if not mc_bases or not base then
77963: LD_EXP 58
77967: NOT
77968: PUSH
77969: LD_VAR 0 1
77973: NOT
77974: OR
77975: IFFALSE 77979
// exit ;
77977: GO 78081
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77979: LD_ADDR_VAR 0 4
77983: PUSH
77984: LD_EXP 58
77988: PUSH
77989: LD_VAR 0 1
77993: ARRAY
77994: PPUSH
77995: LD_INT 30
77997: PUSH
77998: LD_VAR 0 2
78002: PUSH
78003: EMPTY
78004: LIST
78005: LIST
78006: PPUSH
78007: CALL_OW 72
78011: ST_TO_ADDR
// if not tmp then
78012: LD_VAR 0 4
78016: NOT
78017: IFFALSE 78021
// exit ;
78019: GO 78081
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78021: LD_ADDR_EXP 90
78025: PUSH
78026: LD_EXP 90
78030: PPUSH
78031: LD_VAR 0 1
78035: PPUSH
78036: LD_EXP 90
78040: PUSH
78041: LD_VAR 0 1
78045: ARRAY
78046: PPUSH
78047: LD_EXP 90
78051: PUSH
78052: LD_VAR 0 1
78056: ARRAY
78057: PUSH
78058: LD_INT 1
78060: PLUS
78061: PPUSH
78062: LD_VAR 0 4
78066: PUSH
78067: LD_INT 1
78069: ARRAY
78070: PPUSH
78071: CALL_OW 2
78075: PPUSH
78076: CALL_OW 1
78080: ST_TO_ADDR
// end ;
78081: LD_VAR 0 3
78085: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78086: LD_INT 0
78088: PPUSH
78089: PPUSH
// if not mc_bases or not base or not kinds then
78090: LD_EXP 58
78094: NOT
78095: PUSH
78096: LD_VAR 0 1
78100: NOT
78101: OR
78102: PUSH
78103: LD_VAR 0 2
78107: NOT
78108: OR
78109: IFFALSE 78113
// exit ;
78111: GO 78174
// for i in kinds do
78113: LD_ADDR_VAR 0 4
78117: PUSH
78118: LD_VAR 0 2
78122: PUSH
78123: FOR_IN
78124: IFFALSE 78172
// mc_lab_upgrade := Add ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78126: LD_ADDR_EXP 92
78130: PUSH
78131: LD_EXP 92
78135: PPUSH
78136: LD_VAR 0 1
78140: PUSH
78141: LD_EXP 92
78145: PUSH
78146: LD_VAR 0 1
78150: ARRAY
78151: PUSH
78152: LD_INT 1
78154: PLUS
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PPUSH
78160: LD_VAR 0 4
78164: PPUSH
78165: CALL 20685 0 3
78169: ST_TO_ADDR
78170: GO 78123
78172: POP
78173: POP
// end ;
78174: LD_VAR 0 3
78178: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78179: LD_INT 0
78181: PPUSH
// if not mc_bases or not base or not areas then
78182: LD_EXP 58
78186: NOT
78187: PUSH
78188: LD_VAR 0 1
78192: NOT
78193: OR
78194: PUSH
78195: LD_VAR 0 2
78199: NOT
78200: OR
78201: IFFALSE 78205
// exit ;
78203: GO 78230
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78205: LD_ADDR_EXP 76
78209: PUSH
78210: LD_EXP 76
78214: PPUSH
78215: LD_VAR 0 1
78219: PPUSH
78220: LD_VAR 0 2
78224: PPUSH
78225: CALL_OW 1
78229: ST_TO_ADDR
// end ;
78230: LD_VAR 0 3
78234: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78235: LD_INT 0
78237: PPUSH
// if not mc_bases or not base or not teleports_exit then
78238: LD_EXP 58
78242: NOT
78243: PUSH
78244: LD_VAR 0 1
78248: NOT
78249: OR
78250: PUSH
78251: LD_VAR 0 2
78255: NOT
78256: OR
78257: IFFALSE 78261
// exit ;
78259: GO 78286
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78261: LD_ADDR_EXP 93
78265: PUSH
78266: LD_EXP 93
78270: PPUSH
78271: LD_VAR 0 1
78275: PPUSH
78276: LD_VAR 0 2
78280: PPUSH
78281: CALL_OW 1
78285: ST_TO_ADDR
// end ;
78286: LD_VAR 0 3
78290: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78291: LD_INT 0
78293: PPUSH
78294: PPUSH
78295: PPUSH
// if not mc_bases or not base or not ext_list then
78296: LD_EXP 58
78300: NOT
78301: PUSH
78302: LD_VAR 0 1
78306: NOT
78307: OR
78308: PUSH
78309: LD_VAR 0 5
78313: NOT
78314: OR
78315: IFFALSE 78319
// exit ;
78317: GO 78492
// tmp := GetFacExtXYD ( x , y , d ) ;
78319: LD_ADDR_VAR 0 8
78323: PUSH
78324: LD_VAR 0 2
78328: PPUSH
78329: LD_VAR 0 3
78333: PPUSH
78334: LD_VAR 0 4
78338: PPUSH
78339: CALL 53383 0 3
78343: ST_TO_ADDR
// if not tmp then
78344: LD_VAR 0 8
78348: NOT
78349: IFFALSE 78353
// exit ;
78351: GO 78492
// for i in tmp do
78353: LD_ADDR_VAR 0 7
78357: PUSH
78358: LD_VAR 0 8
78362: PUSH
78363: FOR_IN
78364: IFFALSE 78490
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78366: LD_ADDR_EXP 63
78370: PUSH
78371: LD_EXP 63
78375: PPUSH
78376: LD_VAR 0 1
78380: PPUSH
78381: LD_EXP 63
78385: PUSH
78386: LD_VAR 0 1
78390: ARRAY
78391: PPUSH
78392: LD_EXP 63
78396: PUSH
78397: LD_VAR 0 1
78401: ARRAY
78402: PUSH
78403: LD_INT 1
78405: PLUS
78406: PPUSH
78407: LD_VAR 0 5
78411: PUSH
78412: LD_INT 1
78414: ARRAY
78415: PUSH
78416: LD_VAR 0 7
78420: PUSH
78421: LD_INT 1
78423: ARRAY
78424: PUSH
78425: LD_VAR 0 7
78429: PUSH
78430: LD_INT 2
78432: ARRAY
78433: PUSH
78434: LD_VAR 0 7
78438: PUSH
78439: LD_INT 3
78441: ARRAY
78442: PUSH
78443: EMPTY
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: PPUSH
78449: CALL_OW 2
78453: PPUSH
78454: CALL_OW 1
78458: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78459: LD_ADDR_VAR 0 5
78463: PUSH
78464: LD_VAR 0 5
78468: PPUSH
78469: LD_INT 1
78471: PPUSH
78472: CALL_OW 3
78476: ST_TO_ADDR
// if not ext_list then
78477: LD_VAR 0 5
78481: NOT
78482: IFFALSE 78488
// exit ;
78484: POP
78485: POP
78486: GO 78492
// end ;
78488: GO 78363
78490: POP
78491: POP
// end ;
78492: LD_VAR 0 6
78496: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78497: LD_INT 0
78499: PPUSH
// if not mc_bases or not base or not weapon_list then
78500: LD_EXP 58
78504: NOT
78505: PUSH
78506: LD_VAR 0 1
78510: NOT
78511: OR
78512: PUSH
78513: LD_VAR 0 2
78517: NOT
78518: OR
78519: IFFALSE 78523
// exit ;
78521: GO 78548
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78523: LD_ADDR_EXP 97
78527: PUSH
78528: LD_EXP 97
78532: PPUSH
78533: LD_VAR 0 1
78537: PPUSH
78538: LD_VAR 0 2
78542: PPUSH
78543: CALL_OW 1
78547: ST_TO_ADDR
// end ;
78548: LD_VAR 0 3
78552: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78553: LD_INT 0
78555: PPUSH
// if not mc_bases or not base or not tech_list then
78556: LD_EXP 58
78560: NOT
78561: PUSH
78562: LD_VAR 0 1
78566: NOT
78567: OR
78568: PUSH
78569: LD_VAR 0 2
78573: NOT
78574: OR
78575: IFFALSE 78579
// exit ;
78577: GO 78604
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78579: LD_ADDR_EXP 85
78583: PUSH
78584: LD_EXP 85
78588: PPUSH
78589: LD_VAR 0 1
78593: PPUSH
78594: LD_VAR 0 2
78598: PPUSH
78599: CALL_OW 1
78603: ST_TO_ADDR
// end ;
78604: LD_VAR 0 3
78608: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78609: LD_INT 0
78611: PPUSH
// if not mc_bases or not parking_area or not base then
78612: LD_EXP 58
78616: NOT
78617: PUSH
78618: LD_VAR 0 2
78622: NOT
78623: OR
78624: PUSH
78625: LD_VAR 0 1
78629: NOT
78630: OR
78631: IFFALSE 78635
// exit ;
78633: GO 78660
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78635: LD_ADDR_EXP 82
78639: PUSH
78640: LD_EXP 82
78644: PPUSH
78645: LD_VAR 0 1
78649: PPUSH
78650: LD_VAR 0 2
78654: PPUSH
78655: CALL_OW 1
78659: ST_TO_ADDR
// end ;
78660: LD_VAR 0 3
78664: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78665: LD_INT 0
78667: PPUSH
// if not mc_bases or not base or not scan_area then
78668: LD_EXP 58
78672: NOT
78673: PUSH
78674: LD_VAR 0 1
78678: NOT
78679: OR
78680: PUSH
78681: LD_VAR 0 2
78685: NOT
78686: OR
78687: IFFALSE 78691
// exit ;
78689: GO 78716
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78691: LD_ADDR_EXP 83
78695: PUSH
78696: LD_EXP 83
78700: PPUSH
78701: LD_VAR 0 1
78705: PPUSH
78706: LD_VAR 0 2
78710: PPUSH
78711: CALL_OW 1
78715: ST_TO_ADDR
// end ;
78716: LD_VAR 0 3
78720: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78721: LD_INT 0
78723: PPUSH
78724: PPUSH
// if not mc_bases or not base then
78725: LD_EXP 58
78729: NOT
78730: PUSH
78731: LD_VAR 0 1
78735: NOT
78736: OR
78737: IFFALSE 78741
// exit ;
78739: GO 78805
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78741: LD_ADDR_VAR 0 3
78745: PUSH
78746: LD_INT 1
78748: PUSH
78749: LD_INT 2
78751: PUSH
78752: LD_INT 3
78754: PUSH
78755: LD_INT 4
78757: PUSH
78758: LD_INT 11
78760: PUSH
78761: EMPTY
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78768: LD_ADDR_EXP 85
78772: PUSH
78773: LD_EXP 85
78777: PPUSH
78778: LD_VAR 0 1
78782: PPUSH
78783: LD_EXP 85
78787: PUSH
78788: LD_VAR 0 1
78792: ARRAY
78793: PUSH
78794: LD_VAR 0 3
78798: DIFF
78799: PPUSH
78800: CALL_OW 1
78804: ST_TO_ADDR
// end ; end_of_file
78805: LD_VAR 0 2
78809: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78810: LD_INT 0
78812: PPUSH
78813: PPUSH
78814: PPUSH
// if not mc_bases then
78815: LD_EXP 58
78819: NOT
78820: IFFALSE 78824
// exit ;
78822: GO 78989
// for i = 1 to mc_bases do
78824: LD_ADDR_VAR 0 4
78828: PUSH
78829: DOUBLE
78830: LD_INT 1
78832: DEC
78833: ST_TO_ADDR
78834: LD_EXP 58
78838: PUSH
78839: FOR_TO
78840: IFFALSE 78987
// begin if sci in mc_bases [ i ] then
78842: LD_VAR 0 2
78846: PUSH
78847: LD_EXP 58
78851: PUSH
78852: LD_VAR 0 4
78856: ARRAY
78857: IN
78858: IFFALSE 78985
// begin mc_ape := Add ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78860: LD_ADDR_EXP 87
78864: PUSH
78865: LD_EXP 87
78869: PPUSH
78870: LD_VAR 0 4
78874: PUSH
78875: LD_EXP 87
78879: PUSH
78880: LD_VAR 0 4
78884: ARRAY
78885: PUSH
78886: LD_INT 1
78888: PLUS
78889: PUSH
78890: EMPTY
78891: LIST
78892: LIST
78893: PPUSH
78894: LD_VAR 0 1
78898: PPUSH
78899: CALL 20685 0 3
78903: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78904: LD_ADDR_VAR 0 5
78908: PUSH
78909: LD_EXP 58
78913: PUSH
78914: LD_VAR 0 4
78918: ARRAY
78919: PPUSH
78920: LD_INT 2
78922: PUSH
78923: LD_INT 30
78925: PUSH
78926: LD_INT 0
78928: PUSH
78929: EMPTY
78930: LIST
78931: LIST
78932: PUSH
78933: LD_INT 30
78935: PUSH
78936: LD_INT 1
78938: PUSH
78939: EMPTY
78940: LIST
78941: LIST
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: LIST
78947: PPUSH
78948: CALL_OW 72
78952: PPUSH
78953: LD_VAR 0 1
78957: PPUSH
78958: CALL_OW 74
78962: ST_TO_ADDR
// if tmp then
78963: LD_VAR 0 5
78967: IFFALSE 78983
// ComStandNearbyBuilding ( ape , tmp ) ;
78969: LD_VAR 0 1
78973: PPUSH
78974: LD_VAR 0 5
78978: PPUSH
78979: CALL 14927 0 2
// break ;
78983: GO 78987
// end ; end ;
78985: GO 78839
78987: POP
78988: POP
// end ;
78989: LD_VAR 0 3
78993: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
78994: LD_INT 0
78996: PPUSH
78997: PPUSH
78998: PPUSH
// if not mc_bases then
78999: LD_EXP 58
79003: NOT
79004: IFFALSE 79008
// exit ;
79006: GO 79097
// for i = 1 to mc_bases do
79008: LD_ADDR_VAR 0 4
79012: PUSH
79013: DOUBLE
79014: LD_INT 1
79016: DEC
79017: ST_TO_ADDR
79018: LD_EXP 58
79022: PUSH
79023: FOR_TO
79024: IFFALSE 79095
// begin if building in mc_busy_turret_list [ i ] then
79026: LD_VAR 0 1
79030: PUSH
79031: LD_EXP 68
79035: PUSH
79036: LD_VAR 0 4
79040: ARRAY
79041: IN
79042: IFFALSE 79093
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79044: LD_ADDR_VAR 0 5
79048: PUSH
79049: LD_EXP 68
79053: PUSH
79054: LD_VAR 0 4
79058: ARRAY
79059: PUSH
79060: LD_VAR 0 1
79064: DIFF
79065: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79066: LD_ADDR_EXP 68
79070: PUSH
79071: LD_EXP 68
79075: PPUSH
79076: LD_VAR 0 4
79080: PPUSH
79081: LD_VAR 0 5
79085: PPUSH
79086: CALL_OW 1
79090: ST_TO_ADDR
// break ;
79091: GO 79095
// end ; end ;
79093: GO 79023
79095: POP
79096: POP
// end ;
79097: LD_VAR 0 3
79101: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79102: LD_INT 0
79104: PPUSH
79105: PPUSH
79106: PPUSH
// if not mc_bases then
79107: LD_EXP 58
79111: NOT
79112: IFFALSE 79116
// exit ;
79114: GO 79315
// for i = 1 to mc_bases do
79116: LD_ADDR_VAR 0 5
79120: PUSH
79121: DOUBLE
79122: LD_INT 1
79124: DEC
79125: ST_TO_ADDR
79126: LD_EXP 58
79130: PUSH
79131: FOR_TO
79132: IFFALSE 79313
// if building in mc_bases [ i ] then
79134: LD_VAR 0 1
79138: PUSH
79139: LD_EXP 58
79143: PUSH
79144: LD_VAR 0 5
79148: ARRAY
79149: IN
79150: IFFALSE 79311
// begin tmp := mc_bases [ i ] diff building ;
79152: LD_ADDR_VAR 0 6
79156: PUSH
79157: LD_EXP 58
79161: PUSH
79162: LD_VAR 0 5
79166: ARRAY
79167: PUSH
79168: LD_VAR 0 1
79172: DIFF
79173: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79174: LD_ADDR_EXP 58
79178: PUSH
79179: LD_EXP 58
79183: PPUSH
79184: LD_VAR 0 5
79188: PPUSH
79189: LD_VAR 0 6
79193: PPUSH
79194: CALL_OW 1
79198: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79199: LD_VAR 0 1
79203: PUSH
79204: LD_EXP 66
79208: PUSH
79209: LD_VAR 0 5
79213: ARRAY
79214: IN
79215: IFFALSE 79254
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79217: LD_ADDR_EXP 66
79221: PUSH
79222: LD_EXP 66
79226: PPUSH
79227: LD_VAR 0 5
79231: PPUSH
79232: LD_EXP 66
79236: PUSH
79237: LD_VAR 0 5
79241: ARRAY
79242: PUSH
79243: LD_VAR 0 1
79247: DIFF
79248: PPUSH
79249: CALL_OW 1
79253: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79254: LD_VAR 0 1
79258: PUSH
79259: LD_EXP 67
79263: PUSH
79264: LD_VAR 0 5
79268: ARRAY
79269: IN
79270: IFFALSE 79309
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79272: LD_ADDR_EXP 67
79276: PUSH
79277: LD_EXP 67
79281: PPUSH
79282: LD_VAR 0 5
79286: PPUSH
79287: LD_EXP 67
79291: PUSH
79292: LD_VAR 0 5
79296: ARRAY
79297: PUSH
79298: LD_VAR 0 1
79302: DIFF
79303: PPUSH
79304: CALL_OW 1
79308: ST_TO_ADDR
// break ;
79309: GO 79313
// end ;
79311: GO 79131
79313: POP
79314: POP
// end ;
79315: LD_VAR 0 4
79319: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79320: LD_INT 0
79322: PPUSH
79323: PPUSH
79324: PPUSH
// if not mc_bases or not side in mc_sides then
79325: LD_EXP 58
79329: NOT
79330: PUSH
79331: LD_VAR 0 3
79335: PUSH
79336: LD_EXP 84
79340: IN
79341: NOT
79342: OR
79343: IFFALSE 79347
// exit ;
79345: GO 79470
// for i = 1 to mc_vehicles do
79347: LD_ADDR_VAR 0 6
79351: PUSH
79352: DOUBLE
79353: LD_INT 1
79355: DEC
79356: ST_TO_ADDR
79357: LD_EXP 77
79361: PUSH
79362: FOR_TO
79363: IFFALSE 79468
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79365: LD_VAR 0 2
79369: PUSH
79370: LD_EXP 77
79374: PUSH
79375: LD_VAR 0 6
79379: ARRAY
79380: IN
79381: PUSH
79382: LD_VAR 0 1
79386: PUSH
79387: LD_EXP 77
79391: PUSH
79392: LD_VAR 0 6
79396: ARRAY
79397: IN
79398: OR
79399: IFFALSE 79466
// begin tmp := mc_vehicles [ i ] diff old ;
79401: LD_ADDR_VAR 0 7
79405: PUSH
79406: LD_EXP 77
79410: PUSH
79411: LD_VAR 0 6
79415: ARRAY
79416: PUSH
79417: LD_VAR 0 2
79421: DIFF
79422: ST_TO_ADDR
// tmp := tmp diff new ;
79423: LD_ADDR_VAR 0 7
79427: PUSH
79428: LD_VAR 0 7
79432: PUSH
79433: LD_VAR 0 1
79437: DIFF
79438: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79439: LD_ADDR_EXP 77
79443: PUSH
79444: LD_EXP 77
79448: PPUSH
79449: LD_VAR 0 6
79453: PPUSH
79454: LD_VAR 0 7
79458: PPUSH
79459: CALL_OW 1
79463: ST_TO_ADDR
// break ;
79464: GO 79468
// end ;
79466: GO 79362
79468: POP
79469: POP
// end ;
79470: LD_VAR 0 5
79474: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79475: LD_INT 0
79477: PPUSH
79478: PPUSH
79479: PPUSH
79480: PPUSH
// if not mc_bases then
79481: LD_EXP 58
79485: NOT
79486: IFFALSE 79490
// exit ;
79488: GO 79873
// side := GetSide ( vehicle ) ;
79490: LD_ADDR_VAR 0 5
79494: PUSH
79495: LD_VAR 0 1
79499: PPUSH
79500: CALL_OW 255
79504: ST_TO_ADDR
// for i = 1 to mc_bases do
79505: LD_ADDR_VAR 0 4
79509: PUSH
79510: DOUBLE
79511: LD_INT 1
79513: DEC
79514: ST_TO_ADDR
79515: LD_EXP 58
79519: PUSH
79520: FOR_TO
79521: IFFALSE 79871
// begin if factory in mc_bases [ i ] then
79523: LD_VAR 0 2
79527: PUSH
79528: LD_EXP 58
79532: PUSH
79533: LD_VAR 0 4
79537: ARRAY
79538: IN
79539: IFFALSE 79869
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
79541: LD_EXP 80
79545: PUSH
79546: LD_VAR 0 4
79550: ARRAY
79551: PUSH
79552: LD_EXP 69
79556: PUSH
79557: LD_VAR 0 4
79561: ARRAY
79562: LESS
79563: PUSH
79564: LD_VAR 0 1
79568: PPUSH
79569: CALL_OW 264
79573: PUSH
79574: LD_INT 31
79576: PUSH
79577: LD_INT 32
79579: PUSH
79580: LD_INT 51
79582: PUSH
79583: LD_EXP 102
79587: PUSH
79588: LD_INT 12
79590: PUSH
79591: LD_INT 30
79593: PUSH
79594: LD_EXP 101
79598: PUSH
79599: LD_INT 11
79601: PUSH
79602: LD_INT 53
79604: PUSH
79605: LD_INT 14
79607: PUSH
79608: LD_EXP 105
79612: PUSH
79613: LD_INT 29
79615: PUSH
79616: LD_EXP 103
79620: PUSH
79621: LD_INT 13
79623: PUSH
79624: LD_INT 52
79626: PUSH
79627: LD_INT 48
79629: PUSH
79630: LD_INT 8
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: IN
79652: NOT
79653: AND
79654: IFFALSE 79695
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
79656: LD_ADDR_EXP 80
79660: PUSH
79661: LD_EXP 80
79665: PPUSH
79666: LD_VAR 0 4
79670: PPUSH
79671: LD_EXP 80
79675: PUSH
79676: LD_VAR 0 4
79680: ARRAY
79681: PUSH
79682: LD_VAR 0 1
79686: ADD
79687: PPUSH
79688: CALL_OW 1
79692: ST_TO_ADDR
79693: GO 79739
// mc_vehicles := Add ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79695: LD_ADDR_EXP 77
79699: PUSH
79700: LD_EXP 77
79704: PPUSH
79705: LD_VAR 0 4
79709: PUSH
79710: LD_EXP 77
79714: PUSH
79715: LD_VAR 0 4
79719: ARRAY
79720: PUSH
79721: LD_INT 1
79723: PLUS
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PPUSH
79729: LD_VAR 0 1
79733: PPUSH
79734: CALL 20685 0 3
79738: ST_TO_ADDR
// if not mc_scan [ i ] then
79739: LD_EXP 81
79743: PUSH
79744: LD_VAR 0 4
79748: ARRAY
79749: NOT
79750: IFFALSE 79869
// begin if GetControl ( vehicle ) = control_remote then
79752: LD_VAR 0 1
79756: PPUSH
79757: CALL_OW 263
79761: PUSH
79762: LD_INT 2
79764: EQUAL
79765: IFFALSE 79785
// repeat wait ( 0 0$1 ) ;
79767: LD_INT 35
79769: PPUSH
79770: CALL_OW 67
// until IsControledBy ( vehicle ) ;
79774: LD_VAR 0 1
79778: PPUSH
79779: CALL_OW 312
79783: IFFALSE 79767
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79785: LD_VAR 0 1
79789: PPUSH
79790: LD_EXP 82
79794: PUSH
79795: LD_VAR 0 4
79799: ARRAY
79800: PPUSH
79801: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79805: LD_VAR 0 1
79809: PPUSH
79810: CALL_OW 263
79814: PUSH
79815: LD_INT 1
79817: NONEQUAL
79818: IFFALSE 79822
// break ;
79820: GO 79871
// repeat wait ( 0 0$1 ) ;
79822: LD_INT 35
79824: PPUSH
79825: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79829: LD_VAR 0 1
79833: PPUSH
79834: LD_EXP 82
79838: PUSH
79839: LD_VAR 0 4
79843: ARRAY
79844: PPUSH
79845: CALL_OW 308
79849: IFFALSE 79822
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79851: LD_VAR 0 1
79855: PPUSH
79856: CALL_OW 311
79860: PPUSH
79861: CALL_OW 121
// exit ;
79865: POP
79866: POP
79867: GO 79873
// end ; end ; end ;
79869: GO 79520
79871: POP
79872: POP
// end ;
79873: LD_VAR 0 3
79877: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79878: LD_INT 0
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
// if not mc_bases then
79884: LD_EXP 58
79888: NOT
79889: IFFALSE 79893
// exit ;
79891: GO 80246
// repeat wait ( 0 0$1 ) ;
79893: LD_INT 35
79895: PPUSH
79896: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79900: LD_VAR 0 2
79904: PPUSH
79905: LD_VAR 0 3
79909: PPUSH
79910: CALL_OW 284
79914: IFFALSE 79893
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79916: LD_VAR 0 2
79920: PPUSH
79921: LD_VAR 0 3
79925: PPUSH
79926: CALL_OW 283
79930: PUSH
79931: LD_INT 4
79933: EQUAL
79934: IFFALSE 79938
// exit ;
79936: GO 80246
// for i = 1 to mc_bases do
79938: LD_ADDR_VAR 0 7
79942: PUSH
79943: DOUBLE
79944: LD_INT 1
79946: DEC
79947: ST_TO_ADDR
79948: LD_EXP 58
79952: PUSH
79953: FOR_TO
79954: IFFALSE 80244
// begin if mc_crates_area [ i ] then
79956: LD_EXP 76
79960: PUSH
79961: LD_VAR 0 7
79965: ARRAY
79966: IFFALSE 80077
// for j in mc_crates_area [ i ] do
79968: LD_ADDR_VAR 0 8
79972: PUSH
79973: LD_EXP 76
79977: PUSH
79978: LD_VAR 0 7
79982: ARRAY
79983: PUSH
79984: FOR_IN
79985: IFFALSE 80075
// if InArea ( x , y , j ) then
79987: LD_VAR 0 2
79991: PPUSH
79992: LD_VAR 0 3
79996: PPUSH
79997: LD_VAR 0 8
80001: PPUSH
80002: CALL_OW 309
80006: IFFALSE 80073
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80008: LD_ADDR_EXP 74
80012: PUSH
80013: LD_EXP 74
80017: PPUSH
80018: LD_VAR 0 7
80022: PUSH
80023: LD_EXP 74
80027: PUSH
80028: LD_VAR 0 7
80032: ARRAY
80033: PUSH
80034: LD_INT 1
80036: PLUS
80037: PUSH
80038: EMPTY
80039: LIST
80040: LIST
80041: PPUSH
80042: LD_VAR 0 4
80046: PUSH
80047: LD_VAR 0 2
80051: PUSH
80052: LD_VAR 0 3
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: LIST
80061: PPUSH
80062: CALL 20685 0 3
80066: ST_TO_ADDR
// exit ;
80067: POP
80068: POP
80069: POP
80070: POP
80071: GO 80246
// end ;
80073: GO 79984
80075: POP
80076: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80077: LD_ADDR_VAR 0 9
80081: PUSH
80082: LD_EXP 58
80086: PUSH
80087: LD_VAR 0 7
80091: ARRAY
80092: PPUSH
80093: LD_INT 2
80095: PUSH
80096: LD_INT 30
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 30
80108: PUSH
80109: LD_INT 1
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: LIST
80120: PPUSH
80121: CALL_OW 72
80125: ST_TO_ADDR
// if not depot then
80126: LD_VAR 0 9
80130: NOT
80131: IFFALSE 80135
// continue ;
80133: GO 79953
// for j in depot do
80135: LD_ADDR_VAR 0 8
80139: PUSH
80140: LD_VAR 0 9
80144: PUSH
80145: FOR_IN
80146: IFFALSE 80240
// if GetDistUnitXY ( j , x , y ) < 30 then
80148: LD_VAR 0 8
80152: PPUSH
80153: LD_VAR 0 2
80157: PPUSH
80158: LD_VAR 0 3
80162: PPUSH
80163: CALL_OW 297
80167: PUSH
80168: LD_INT 30
80170: LESS
80171: IFFALSE 80238
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80173: LD_ADDR_EXP 74
80177: PUSH
80178: LD_EXP 74
80182: PPUSH
80183: LD_VAR 0 7
80187: PUSH
80188: LD_EXP 74
80192: PUSH
80193: LD_VAR 0 7
80197: ARRAY
80198: PUSH
80199: LD_INT 1
80201: PLUS
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PPUSH
80207: LD_VAR 0 4
80211: PUSH
80212: LD_VAR 0 2
80216: PUSH
80217: LD_VAR 0 3
80221: PUSH
80222: EMPTY
80223: LIST
80224: LIST
80225: LIST
80226: PPUSH
80227: CALL 20685 0 3
80231: ST_TO_ADDR
// exit ;
80232: POP
80233: POP
80234: POP
80235: POP
80236: GO 80246
// end ;
80238: GO 80145
80240: POP
80241: POP
// end ;
80242: GO 79953
80244: POP
80245: POP
// end ;
80246: LD_VAR 0 6
80250: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80251: LD_INT 0
80253: PPUSH
80254: PPUSH
80255: PPUSH
80256: PPUSH
// side := GetSide ( lab ) ;
80257: LD_ADDR_VAR 0 4
80261: PUSH
80262: LD_VAR 0 2
80266: PPUSH
80267: CALL_OW 255
80271: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80272: LD_VAR 0 4
80276: PUSH
80277: LD_EXP 84
80281: IN
80282: NOT
80283: PUSH
80284: LD_EXP 85
80288: NOT
80289: OR
80290: PUSH
80291: LD_EXP 58
80295: NOT
80296: OR
80297: IFFALSE 80301
// exit ;
80299: GO 80534
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80301: LD_ADDR_EXP 85
80305: PUSH
80306: LD_EXP 85
80310: PPUSH
80311: LD_VAR 0 4
80315: PPUSH
80316: LD_EXP 85
80320: PUSH
80321: LD_VAR 0 4
80325: ARRAY
80326: PUSH
80327: LD_VAR 0 1
80331: DIFF
80332: PPUSH
80333: CALL_OW 1
80337: ST_TO_ADDR
// for i = 1 to mc_bases do
80338: LD_ADDR_VAR 0 5
80342: PUSH
80343: DOUBLE
80344: LD_INT 1
80346: DEC
80347: ST_TO_ADDR
80348: LD_EXP 58
80352: PUSH
80353: FOR_TO
80354: IFFALSE 80532
// begin if lab in mc_bases [ i ] then
80356: LD_VAR 0 2
80360: PUSH
80361: LD_EXP 58
80365: PUSH
80366: LD_VAR 0 5
80370: ARRAY
80371: IN
80372: IFFALSE 80530
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80374: LD_VAR 0 1
80378: PUSH
80379: LD_INT 11
80381: PUSH
80382: LD_INT 4
80384: PUSH
80385: LD_INT 3
80387: PUSH
80388: LD_INT 2
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: IN
80397: PUSH
80398: LD_EXP 88
80402: PUSH
80403: LD_VAR 0 5
80407: ARRAY
80408: AND
80409: IFFALSE 80530
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80411: LD_ADDR_VAR 0 6
80415: PUSH
80416: LD_EXP 88
80420: PUSH
80421: LD_VAR 0 5
80425: ARRAY
80426: PUSH
80427: LD_INT 1
80429: ARRAY
80430: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80431: LD_ADDR_EXP 88
80435: PUSH
80436: LD_EXP 88
80440: PPUSH
80441: LD_VAR 0 5
80445: PPUSH
80446: EMPTY
80447: PPUSH
80448: CALL_OW 1
80452: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80453: LD_VAR 0 6
80457: PPUSH
80458: LD_INT 0
80460: PPUSH
80461: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80465: LD_VAR 0 6
80469: PPUSH
80470: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80474: LD_ADDR_EXP 87
80478: PUSH
80479: LD_EXP 87
80483: PPUSH
80484: LD_VAR 0 5
80488: PPUSH
80489: LD_EXP 87
80493: PUSH
80494: LD_VAR 0 5
80498: ARRAY
80499: PPUSH
80500: LD_INT 1
80502: PPUSH
80503: LD_VAR 0 6
80507: PPUSH
80508: CALL_OW 2
80512: PPUSH
80513: CALL_OW 1
80517: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80518: LD_VAR 0 5
80522: PPUSH
80523: LD_INT 112
80525: PPUSH
80526: CALL 58609 0 2
// end ; end ; end ;
80530: GO 80353
80532: POP
80533: POP
// end ;
80534: LD_VAR 0 3
80538: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80539: LD_INT 0
80541: PPUSH
80542: PPUSH
80543: PPUSH
80544: PPUSH
80545: PPUSH
80546: PPUSH
80547: PPUSH
80548: PPUSH
// if not mc_bases then
80549: LD_EXP 58
80553: NOT
80554: IFFALSE 80558
// exit ;
80556: GO 81501
// for i = 1 to mc_bases do
80558: LD_ADDR_VAR 0 3
80562: PUSH
80563: DOUBLE
80564: LD_INT 1
80566: DEC
80567: ST_TO_ADDR
80568: LD_EXP 58
80572: PUSH
80573: FOR_TO
80574: IFFALSE 81499
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80576: LD_VAR 0 1
80580: PUSH
80581: LD_EXP 58
80585: PUSH
80586: LD_VAR 0 3
80590: ARRAY
80591: IN
80592: PUSH
80593: LD_VAR 0 1
80597: PUSH
80598: LD_EXP 65
80602: PUSH
80603: LD_VAR 0 3
80607: ARRAY
80608: IN
80609: OR
80610: PUSH
80611: LD_VAR 0 1
80615: PUSH
80616: LD_EXP 77
80620: PUSH
80621: LD_VAR 0 3
80625: ARRAY
80626: IN
80627: OR
80628: PUSH
80629: LD_VAR 0 1
80633: PUSH
80634: LD_EXP 87
80638: PUSH
80639: LD_VAR 0 3
80643: ARRAY
80644: IN
80645: OR
80646: PUSH
80647: LD_VAR 0 1
80651: PUSH
80652: LD_EXP 88
80656: PUSH
80657: LD_VAR 0 3
80661: ARRAY
80662: IN
80663: OR
80664: IFFALSE 81497
// begin if un in mc_ape [ i ] then
80666: LD_VAR 0 1
80670: PUSH
80671: LD_EXP 87
80675: PUSH
80676: LD_VAR 0 3
80680: ARRAY
80681: IN
80682: IFFALSE 80721
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80684: LD_ADDR_EXP 87
80688: PUSH
80689: LD_EXP 87
80693: PPUSH
80694: LD_VAR 0 3
80698: PPUSH
80699: LD_EXP 87
80703: PUSH
80704: LD_VAR 0 3
80708: ARRAY
80709: PUSH
80710: LD_VAR 0 1
80714: DIFF
80715: PPUSH
80716: CALL_OW 1
80720: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80721: LD_VAR 0 1
80725: PUSH
80726: LD_EXP 88
80730: PUSH
80731: LD_VAR 0 3
80735: ARRAY
80736: IN
80737: IFFALSE 80761
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80739: LD_ADDR_EXP 88
80743: PUSH
80744: LD_EXP 88
80748: PPUSH
80749: LD_VAR 0 3
80753: PPUSH
80754: EMPTY
80755: PPUSH
80756: CALL_OW 1
80760: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
80761: LD_VAR 0 1
80765: PPUSH
80766: CALL_OW 247
80770: PUSH
80771: LD_INT 2
80773: EQUAL
80774: PUSH
80775: LD_VAR 0 1
80779: PPUSH
80780: CALL_OW 110
80784: PUSH
80785: LD_INT 20
80787: EQUAL
80788: AND
80789: IFFALSE 80892
// begin fac := MC_GetBuilding ( i , b_factory ) ;
80791: LD_ADDR_VAR 0 8
80795: PUSH
80796: LD_VAR 0 3
80800: PPUSH
80801: LD_INT 3
80803: PPUSH
80804: CALL 77827 0 2
80808: ST_TO_ADDR
// if fac then
80809: LD_VAR 0 8
80813: IFFALSE 80892
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80815: LD_ADDR_VAR 0 9
80819: PUSH
80820: LD_VAR 0 8
80824: PPUSH
80825: LD_VAR 0 1
80829: PPUSH
80830: CALL_OW 265
80834: PPUSH
80835: LD_VAR 0 1
80839: PPUSH
80840: CALL_OW 262
80844: PPUSH
80845: LD_VAR 0 1
80849: PPUSH
80850: CALL_OW 263
80854: PPUSH
80855: LD_VAR 0 1
80859: PPUSH
80860: CALL_OW 264
80864: PPUSH
80865: CALL 17850 0 5
80869: ST_TO_ADDR
// if components then
80870: LD_VAR 0 9
80874: IFFALSE 80890
// MC_InsertProduceList ( i , components ) ;
80876: LD_VAR 0 3
80880: PPUSH
80881: LD_VAR 0 9
80885: PPUSH
80886: CALL 77397 0 2
// break ;
80890: GO 81499
// end ; end ; if GetType ( un ) = unit_building then
80892: LD_VAR 0 1
80896: PPUSH
80897: CALL_OW 247
80901: PUSH
80902: LD_INT 3
80904: EQUAL
80905: IFFALSE 81220
// begin btype := GetBType ( un ) ;
80907: LD_ADDR_VAR 0 5
80911: PUSH
80912: LD_VAR 0 1
80916: PPUSH
80917: CALL_OW 266
80921: ST_TO_ADDR
// if btype = b_warehouse then
80922: LD_VAR 0 5
80926: PUSH
80927: LD_INT 1
80929: EQUAL
80930: IFFALSE 80948
// begin btype := b_depot ;
80932: LD_ADDR_VAR 0 5
80936: PUSH
80937: LD_INT 0
80939: ST_TO_ADDR
// pos := 1 ;
80940: LD_ADDR_VAR 0 6
80944: PUSH
80945: LD_INT 1
80947: ST_TO_ADDR
// end ; if btype = b_factory then
80948: LD_VAR 0 5
80952: PUSH
80953: LD_INT 3
80955: EQUAL
80956: IFFALSE 80974
// begin btype := b_workshop ;
80958: LD_ADDR_VAR 0 5
80962: PUSH
80963: LD_INT 2
80965: ST_TO_ADDR
// pos := 1 ;
80966: LD_ADDR_VAR 0 6
80970: PUSH
80971: LD_INT 1
80973: ST_TO_ADDR
// end ; if btype = b_barracks then
80974: LD_VAR 0 5
80978: PUSH
80979: LD_INT 5
80981: EQUAL
80982: IFFALSE 80992
// btype := b_armoury ;
80984: LD_ADDR_VAR 0 5
80988: PUSH
80989: LD_INT 4
80991: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80992: LD_VAR 0 5
80996: PUSH
80997: LD_INT 7
80999: PUSH
81000: LD_INT 8
81002: PUSH
81003: EMPTY
81004: LIST
81005: LIST
81006: IN
81007: IFFALSE 81017
// btype := b_lab ;
81009: LD_ADDR_VAR 0 5
81013: PUSH
81014: LD_INT 6
81016: ST_TO_ADDR
// mc_build_list := Add ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81017: LD_ADDR_EXP 63
81021: PUSH
81022: LD_EXP 63
81026: PPUSH
81027: LD_VAR 0 3
81031: PUSH
81032: LD_EXP 63
81036: PUSH
81037: LD_VAR 0 3
81041: ARRAY
81042: PUSH
81043: LD_INT 1
81045: PLUS
81046: PUSH
81047: EMPTY
81048: LIST
81049: LIST
81050: PPUSH
81051: LD_VAR 0 5
81055: PUSH
81056: LD_VAR 0 1
81060: PPUSH
81061: CALL_OW 250
81065: PUSH
81066: LD_VAR 0 1
81070: PPUSH
81071: CALL_OW 251
81075: PUSH
81076: LD_VAR 0 1
81080: PPUSH
81081: CALL_OW 254
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: PPUSH
81092: CALL 20685 0 3
81096: ST_TO_ADDR
// if pos = 1 then
81097: LD_VAR 0 6
81101: PUSH
81102: LD_INT 1
81104: EQUAL
81105: IFFALSE 81220
// begin tmp := mc_build_list [ i ] ;
81107: LD_ADDR_VAR 0 7
81111: PUSH
81112: LD_EXP 63
81116: PUSH
81117: LD_VAR 0 3
81121: ARRAY
81122: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81123: LD_VAR 0 7
81127: PPUSH
81128: LD_INT 2
81130: PUSH
81131: LD_INT 30
81133: PUSH
81134: LD_INT 0
81136: PUSH
81137: EMPTY
81138: LIST
81139: LIST
81140: PUSH
81141: LD_INT 30
81143: PUSH
81144: LD_INT 1
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: LIST
81155: PPUSH
81156: CALL_OW 72
81160: IFFALSE 81170
// pos := 2 ;
81162: LD_ADDR_VAR 0 6
81166: PUSH
81167: LD_INT 2
81169: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81170: LD_ADDR_VAR 0 7
81174: PUSH
81175: LD_VAR 0 7
81179: PPUSH
81180: LD_VAR 0 6
81184: PPUSH
81185: LD_VAR 0 7
81189: PPUSH
81190: CALL 20576 0 3
81194: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81195: LD_ADDR_EXP 63
81199: PUSH
81200: LD_EXP 63
81204: PPUSH
81205: LD_VAR 0 3
81209: PPUSH
81210: LD_VAR 0 7
81214: PPUSH
81215: CALL_OW 1
81219: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81220: LD_VAR 0 1
81224: PUSH
81225: LD_EXP 58
81229: PUSH
81230: LD_VAR 0 3
81234: ARRAY
81235: IN
81236: IFFALSE 81275
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81238: LD_ADDR_EXP 58
81242: PUSH
81243: LD_EXP 58
81247: PPUSH
81248: LD_VAR 0 3
81252: PPUSH
81253: LD_EXP 58
81257: PUSH
81258: LD_VAR 0 3
81262: ARRAY
81263: PUSH
81264: LD_VAR 0 1
81268: DIFF
81269: PPUSH
81270: CALL_OW 1
81274: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81275: LD_VAR 0 1
81279: PUSH
81280: LD_EXP 65
81284: PUSH
81285: LD_VAR 0 3
81289: ARRAY
81290: IN
81291: IFFALSE 81330
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81293: LD_ADDR_EXP 65
81297: PUSH
81298: LD_EXP 65
81302: PPUSH
81303: LD_VAR 0 3
81307: PPUSH
81308: LD_EXP 65
81312: PUSH
81313: LD_VAR 0 3
81317: ARRAY
81318: PUSH
81319: LD_VAR 0 1
81323: DIFF
81324: PPUSH
81325: CALL_OW 1
81329: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81330: LD_VAR 0 1
81334: PUSH
81335: LD_EXP 77
81339: PUSH
81340: LD_VAR 0 3
81344: ARRAY
81345: IN
81346: IFFALSE 81385
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81348: LD_ADDR_EXP 77
81352: PUSH
81353: LD_EXP 77
81357: PPUSH
81358: LD_VAR 0 3
81362: PPUSH
81363: LD_EXP 77
81367: PUSH
81368: LD_VAR 0 3
81372: ARRAY
81373: PUSH
81374: LD_VAR 0 1
81378: DIFF
81379: PPUSH
81380: CALL_OW 1
81384: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81385: LD_VAR 0 1
81389: PUSH
81390: LD_EXP 67
81394: PUSH
81395: LD_VAR 0 3
81399: ARRAY
81400: IN
81401: IFFALSE 81440
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81403: LD_ADDR_EXP 67
81407: PUSH
81408: LD_EXP 67
81412: PPUSH
81413: LD_VAR 0 3
81417: PPUSH
81418: LD_EXP 67
81422: PUSH
81423: LD_VAR 0 3
81427: ARRAY
81428: PUSH
81429: LD_VAR 0 1
81433: DIFF
81434: PPUSH
81435: CALL_OW 1
81439: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81440: LD_VAR 0 1
81444: PUSH
81445: LD_EXP 66
81449: PUSH
81450: LD_VAR 0 3
81454: ARRAY
81455: IN
81456: IFFALSE 81495
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81458: LD_ADDR_EXP 66
81462: PUSH
81463: LD_EXP 66
81467: PPUSH
81468: LD_VAR 0 3
81472: PPUSH
81473: LD_EXP 66
81477: PUSH
81478: LD_VAR 0 3
81482: ARRAY
81483: PUSH
81484: LD_VAR 0 1
81488: DIFF
81489: PPUSH
81490: CALL_OW 1
81494: ST_TO_ADDR
// end ; break ;
81495: GO 81499
// end ;
81497: GO 80573
81499: POP
81500: POP
// end ;
81501: LD_VAR 0 2
81505: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81506: LD_INT 0
81508: PPUSH
81509: PPUSH
81510: PPUSH
// if not mc_bases then
81511: LD_EXP 58
81515: NOT
81516: IFFALSE 81520
// exit ;
81518: GO 81735
// for i = 1 to mc_bases do
81520: LD_ADDR_VAR 0 3
81524: PUSH
81525: DOUBLE
81526: LD_INT 1
81528: DEC
81529: ST_TO_ADDR
81530: LD_EXP 58
81534: PUSH
81535: FOR_TO
81536: IFFALSE 81733
// begin if building in mc_construct_list [ i ] then
81538: LD_VAR 0 1
81542: PUSH
81543: LD_EXP 65
81547: PUSH
81548: LD_VAR 0 3
81552: ARRAY
81553: IN
81554: IFFALSE 81731
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81556: LD_ADDR_EXP 65
81560: PUSH
81561: LD_EXP 65
81565: PPUSH
81566: LD_VAR 0 3
81570: PPUSH
81571: LD_EXP 65
81575: PUSH
81576: LD_VAR 0 3
81580: ARRAY
81581: PUSH
81582: LD_VAR 0 1
81586: DIFF
81587: PPUSH
81588: CALL_OW 1
81592: ST_TO_ADDR
// if building in mc_lab [ i ] then
81593: LD_VAR 0 1
81597: PUSH
81598: LD_EXP 91
81602: PUSH
81603: LD_VAR 0 3
81607: ARRAY
81608: IN
81609: IFFALSE 81664
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81611: LD_ADDR_EXP 92
81615: PUSH
81616: LD_EXP 92
81620: PPUSH
81621: LD_VAR 0 3
81625: PPUSH
81626: LD_EXP 92
81630: PUSH
81631: LD_VAR 0 3
81635: ARRAY
81636: PPUSH
81637: LD_INT 1
81639: PPUSH
81640: LD_EXP 92
81644: PUSH
81645: LD_VAR 0 3
81649: ARRAY
81650: PPUSH
81651: LD_INT 0
81653: PPUSH
81654: CALL 19668 0 4
81658: PPUSH
81659: CALL_OW 1
81663: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81664: LD_VAR 0 1
81668: PUSH
81669: LD_EXP 58
81673: PUSH
81674: LD_VAR 0 3
81678: ARRAY
81679: IN
81680: NOT
81681: IFFALSE 81727
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81683: LD_ADDR_EXP 58
81687: PUSH
81688: LD_EXP 58
81692: PPUSH
81693: LD_VAR 0 3
81697: PUSH
81698: LD_EXP 58
81702: PUSH
81703: LD_VAR 0 3
81707: ARRAY
81708: PUSH
81709: LD_INT 1
81711: PLUS
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PPUSH
81717: LD_VAR 0 1
81721: PPUSH
81722: CALL 20685 0 3
81726: ST_TO_ADDR
// exit ;
81727: POP
81728: POP
81729: GO 81735
// end ; end ;
81731: GO 81535
81733: POP
81734: POP
// end ;
81735: LD_VAR 0 2
81739: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81740: LD_INT 0
81742: PPUSH
81743: PPUSH
81744: PPUSH
81745: PPUSH
81746: PPUSH
81747: PPUSH
81748: PPUSH
// if not mc_bases then
81749: LD_EXP 58
81753: NOT
81754: IFFALSE 81758
// exit ;
81756: GO 82419
// for i = 1 to mc_bases do
81758: LD_ADDR_VAR 0 3
81762: PUSH
81763: DOUBLE
81764: LD_INT 1
81766: DEC
81767: ST_TO_ADDR
81768: LD_EXP 58
81772: PUSH
81773: FOR_TO
81774: IFFALSE 82417
// begin if building in mc_construct_list [ i ] then
81776: LD_VAR 0 1
81780: PUSH
81781: LD_EXP 65
81785: PUSH
81786: LD_VAR 0 3
81790: ARRAY
81791: IN
81792: IFFALSE 82415
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81794: LD_ADDR_EXP 65
81798: PUSH
81799: LD_EXP 65
81803: PPUSH
81804: LD_VAR 0 3
81808: PPUSH
81809: LD_EXP 65
81813: PUSH
81814: LD_VAR 0 3
81818: ARRAY
81819: PUSH
81820: LD_VAR 0 1
81824: DIFF
81825: PPUSH
81826: CALL_OW 1
81830: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81831: LD_ADDR_EXP 58
81835: PUSH
81836: LD_EXP 58
81840: PPUSH
81841: LD_VAR 0 3
81845: PUSH
81846: LD_EXP 58
81850: PUSH
81851: LD_VAR 0 3
81855: ARRAY
81856: PUSH
81857: LD_INT 1
81859: PLUS
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PPUSH
81865: LD_VAR 0 1
81869: PPUSH
81870: CALL 20685 0 3
81874: ST_TO_ADDR
// btype := GetBType ( building ) ;
81875: LD_ADDR_VAR 0 5
81879: PUSH
81880: LD_VAR 0 1
81884: PPUSH
81885: CALL_OW 266
81889: ST_TO_ADDR
// side := GetSide ( building ) ;
81890: LD_ADDR_VAR 0 8
81894: PUSH
81895: LD_VAR 0 1
81899: PPUSH
81900: CALL_OW 255
81904: ST_TO_ADDR
// if btype = b_lab then
81905: LD_VAR 0 5
81909: PUSH
81910: LD_INT 6
81912: EQUAL
81913: IFFALSE 81963
// begin mc_lab := Add ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81915: LD_ADDR_EXP 91
81919: PUSH
81920: LD_EXP 91
81924: PPUSH
81925: LD_VAR 0 3
81929: PUSH
81930: LD_EXP 91
81934: PUSH
81935: LD_VAR 0 3
81939: ARRAY
81940: PUSH
81941: LD_INT 1
81943: PLUS
81944: PUSH
81945: EMPTY
81946: LIST
81947: LIST
81948: PPUSH
81949: LD_VAR 0 1
81953: PPUSH
81954: CALL 20685 0 3
81958: ST_TO_ADDR
// exit ;
81959: POP
81960: POP
81961: GO 82419
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81963: LD_VAR 0 5
81967: PUSH
81968: LD_INT 0
81970: PUSH
81971: LD_INT 2
81973: PUSH
81974: LD_INT 4
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: LIST
81981: IN
81982: IFFALSE 82106
// begin if btype = b_armoury then
81984: LD_VAR 0 5
81988: PUSH
81989: LD_INT 4
81991: EQUAL
81992: IFFALSE 82002
// btype := b_barracks ;
81994: LD_ADDR_VAR 0 5
81998: PUSH
81999: LD_INT 5
82001: ST_TO_ADDR
// if btype = b_depot then
82002: LD_VAR 0 5
82006: PUSH
82007: LD_INT 0
82009: EQUAL
82010: IFFALSE 82020
// btype := b_warehouse ;
82012: LD_ADDR_VAR 0 5
82016: PUSH
82017: LD_INT 1
82019: ST_TO_ADDR
// if btype = b_workshop then
82020: LD_VAR 0 5
82024: PUSH
82025: LD_INT 2
82027: EQUAL
82028: IFFALSE 82038
// btype := b_factory ;
82030: LD_ADDR_VAR 0 5
82034: PUSH
82035: LD_INT 3
82037: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82038: LD_VAR 0 5
82042: PPUSH
82043: LD_VAR 0 8
82047: PPUSH
82048: CALL_OW 323
82052: PUSH
82053: LD_INT 1
82055: EQUAL
82056: IFFALSE 82102
// mc_build_upgrade := Add ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82058: LD_ADDR_EXP 90
82062: PUSH
82063: LD_EXP 90
82067: PPUSH
82068: LD_VAR 0 3
82072: PUSH
82073: LD_EXP 90
82077: PUSH
82078: LD_VAR 0 3
82082: ARRAY
82083: PUSH
82084: LD_INT 1
82086: PLUS
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PPUSH
82092: LD_VAR 0 1
82096: PPUSH
82097: CALL 20685 0 3
82101: ST_TO_ADDR
// exit ;
82102: POP
82103: POP
82104: GO 82419
// end ; if btype in [ b_bunker , b_turret ] then
82106: LD_VAR 0 5
82110: PUSH
82111: LD_INT 32
82113: PUSH
82114: LD_INT 33
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: IN
82121: IFFALSE 82411
// begin mc_turret_list := Add ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82123: LD_ADDR_EXP 66
82127: PUSH
82128: LD_EXP 66
82132: PPUSH
82133: LD_VAR 0 3
82137: PUSH
82138: LD_EXP 66
82142: PUSH
82143: LD_VAR 0 3
82147: ARRAY
82148: PUSH
82149: LD_INT 1
82151: PLUS
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PPUSH
82157: LD_VAR 0 1
82161: PPUSH
82162: CALL 20685 0 3
82166: ST_TO_ADDR
// if btype = b_bunker then
82167: LD_VAR 0 5
82171: PUSH
82172: LD_INT 32
82174: EQUAL
82175: IFFALSE 82411
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82177: LD_ADDR_EXP 67
82181: PUSH
82182: LD_EXP 67
82186: PPUSH
82187: LD_VAR 0 3
82191: PUSH
82192: LD_EXP 67
82196: PUSH
82197: LD_VAR 0 3
82201: ARRAY
82202: PUSH
82203: LD_INT 1
82205: PLUS
82206: PUSH
82207: EMPTY
82208: LIST
82209: LIST
82210: PPUSH
82211: LD_VAR 0 1
82215: PPUSH
82216: CALL 20685 0 3
82220: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82221: LD_ADDR_VAR 0 6
82225: PUSH
82226: LD_EXP 58
82230: PUSH
82231: LD_VAR 0 3
82235: ARRAY
82236: PPUSH
82237: LD_INT 25
82239: PUSH
82240: LD_INT 1
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 3
82249: PUSH
82250: LD_INT 54
82252: PUSH
82253: EMPTY
82254: LIST
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PPUSH
82264: CALL_OW 72
82268: ST_TO_ADDR
// if tmp then
82269: LD_VAR 0 6
82273: IFFALSE 82279
// exit ;
82275: POP
82276: POP
82277: GO 82419
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82279: LD_ADDR_VAR 0 6
82283: PUSH
82284: LD_EXP 58
82288: PUSH
82289: LD_VAR 0 3
82293: ARRAY
82294: PPUSH
82295: LD_INT 2
82297: PUSH
82298: LD_INT 30
82300: PUSH
82301: LD_INT 4
82303: PUSH
82304: EMPTY
82305: LIST
82306: LIST
82307: PUSH
82308: LD_INT 30
82310: PUSH
82311: LD_INT 5
82313: PUSH
82314: EMPTY
82315: LIST
82316: LIST
82317: PUSH
82318: EMPTY
82319: LIST
82320: LIST
82321: LIST
82322: PPUSH
82323: CALL_OW 72
82327: ST_TO_ADDR
// if not tmp then
82328: LD_VAR 0 6
82332: NOT
82333: IFFALSE 82339
// exit ;
82335: POP
82336: POP
82337: GO 82419
// for j in tmp do
82339: LD_ADDR_VAR 0 4
82343: PUSH
82344: LD_VAR 0 6
82348: PUSH
82349: FOR_IN
82350: IFFALSE 82409
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82352: LD_ADDR_VAR 0 7
82356: PUSH
82357: LD_VAR 0 4
82361: PPUSH
82362: CALL_OW 313
82366: PPUSH
82367: LD_INT 25
82369: PUSH
82370: LD_INT 1
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PPUSH
82377: CALL_OW 72
82381: ST_TO_ADDR
// if units then
82382: LD_VAR 0 7
82386: IFFALSE 82407
// begin ComExitBuilding ( units [ 1 ] ) ;
82388: LD_VAR 0 7
82392: PUSH
82393: LD_INT 1
82395: ARRAY
82396: PPUSH
82397: CALL_OW 122
// exit ;
82401: POP
82402: POP
82403: POP
82404: POP
82405: GO 82419
// end ; end ;
82407: GO 82349
82409: POP
82410: POP
// end ; end ; exit ;
82411: POP
82412: POP
82413: GO 82419
// end ; end ;
82415: GO 81773
82417: POP
82418: POP
// end ;
82419: LD_VAR 0 2
82423: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82424: LD_INT 0
82426: PPUSH
82427: PPUSH
82428: PPUSH
82429: PPUSH
82430: PPUSH
82431: PPUSH
82432: PPUSH
// if not mc_bases then
82433: LD_EXP 58
82437: NOT
82438: IFFALSE 82442
// exit ;
82440: GO 82673
// btype := GetBType ( building ) ;
82442: LD_ADDR_VAR 0 6
82446: PUSH
82447: LD_VAR 0 1
82451: PPUSH
82452: CALL_OW 266
82456: ST_TO_ADDR
// x := GetX ( building ) ;
82457: LD_ADDR_VAR 0 7
82461: PUSH
82462: LD_VAR 0 1
82466: PPUSH
82467: CALL_OW 250
82471: ST_TO_ADDR
// y := GetY ( building ) ;
82472: LD_ADDR_VAR 0 8
82476: PUSH
82477: LD_VAR 0 1
82481: PPUSH
82482: CALL_OW 251
82486: ST_TO_ADDR
// d := GetDir ( building ) ;
82487: LD_ADDR_VAR 0 9
82491: PUSH
82492: LD_VAR 0 1
82496: PPUSH
82497: CALL_OW 254
82501: ST_TO_ADDR
// for i = 1 to mc_bases do
82502: LD_ADDR_VAR 0 4
82506: PUSH
82507: DOUBLE
82508: LD_INT 1
82510: DEC
82511: ST_TO_ADDR
82512: LD_EXP 58
82516: PUSH
82517: FOR_TO
82518: IFFALSE 82671
// begin if not mc_build_list [ i ] then
82520: LD_EXP 63
82524: PUSH
82525: LD_VAR 0 4
82529: ARRAY
82530: NOT
82531: IFFALSE 82535
// continue ;
82533: GO 82517
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
82535: LD_VAR 0 6
82539: PUSH
82540: LD_VAR 0 7
82544: PUSH
82545: LD_VAR 0 8
82549: PUSH
82550: LD_VAR 0 9
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: LIST
82559: LIST
82560: PPUSH
82561: LD_EXP 63
82565: PUSH
82566: LD_VAR 0 4
82570: ARRAY
82571: PUSH
82572: LD_INT 1
82574: ARRAY
82575: PPUSH
82576: CALL 26322 0 2
82580: IFFALSE 82669
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
82582: LD_ADDR_EXP 63
82586: PUSH
82587: LD_EXP 63
82591: PPUSH
82592: LD_VAR 0 4
82596: PPUSH
82597: LD_EXP 63
82601: PUSH
82602: LD_VAR 0 4
82606: ARRAY
82607: PPUSH
82608: LD_INT 1
82610: PPUSH
82611: CALL_OW 3
82615: PPUSH
82616: CALL_OW 1
82620: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82621: LD_ADDR_EXP 65
82625: PUSH
82626: LD_EXP 65
82630: PPUSH
82631: LD_VAR 0 4
82635: PUSH
82636: LD_EXP 65
82640: PUSH
82641: LD_VAR 0 4
82645: ARRAY
82646: PUSH
82647: LD_INT 1
82649: PLUS
82650: PUSH
82651: EMPTY
82652: LIST
82653: LIST
82654: PPUSH
82655: LD_VAR 0 1
82659: PPUSH
82660: CALL 20685 0 3
82664: ST_TO_ADDR
// exit ;
82665: POP
82666: POP
82667: GO 82673
// end ; end ;
82669: GO 82517
82671: POP
82672: POP
// end ;
82673: LD_VAR 0 3
82677: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82678: LD_INT 0
82680: PPUSH
82681: PPUSH
82682: PPUSH
// if not mc_bases then
82683: LD_EXP 58
82687: NOT
82688: IFFALSE 82692
// exit ;
82690: GO 82882
// for i = 1 to mc_bases do
82692: LD_ADDR_VAR 0 4
82696: PUSH
82697: DOUBLE
82698: LD_INT 1
82700: DEC
82701: ST_TO_ADDR
82702: LD_EXP 58
82706: PUSH
82707: FOR_TO
82708: IFFALSE 82795
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82710: LD_VAR 0 1
82714: PUSH
82715: LD_EXP 66
82719: PUSH
82720: LD_VAR 0 4
82724: ARRAY
82725: IN
82726: PUSH
82727: LD_VAR 0 1
82731: PUSH
82732: LD_EXP 67
82736: PUSH
82737: LD_VAR 0 4
82741: ARRAY
82742: IN
82743: NOT
82744: AND
82745: IFFALSE 82793
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82747: LD_ADDR_EXP 67
82751: PUSH
82752: LD_EXP 67
82756: PPUSH
82757: LD_VAR 0 4
82761: PUSH
82762: LD_EXP 67
82766: PUSH
82767: LD_VAR 0 4
82771: ARRAY
82772: PUSH
82773: LD_INT 1
82775: PLUS
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PPUSH
82781: LD_VAR 0 1
82785: PPUSH
82786: CALL 20685 0 3
82790: ST_TO_ADDR
// break ;
82791: GO 82795
// end ; end ;
82793: GO 82707
82795: POP
82796: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82797: LD_VAR 0 1
82801: PPUSH
82802: CALL_OW 257
82806: PUSH
82807: LD_EXP 84
82811: IN
82812: PUSH
82813: LD_VAR 0 1
82817: PPUSH
82818: CALL_OW 266
82822: PUSH
82823: LD_INT 5
82825: EQUAL
82826: AND
82827: PUSH
82828: LD_VAR 0 2
82832: PPUSH
82833: CALL_OW 110
82837: PUSH
82838: LD_INT 18
82840: NONEQUAL
82841: AND
82842: IFFALSE 82882
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82844: LD_VAR 0 2
82848: PPUSH
82849: CALL_OW 257
82853: PUSH
82854: LD_INT 5
82856: PUSH
82857: LD_INT 8
82859: PUSH
82860: LD_INT 9
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: LIST
82867: IN
82868: IFFALSE 82882
// SetClass ( unit , 1 ) ;
82870: LD_VAR 0 2
82874: PPUSH
82875: LD_INT 1
82877: PPUSH
82878: CALL_OW 336
// end ;
82882: LD_VAR 0 3
82886: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82887: LD_INT 0
82889: PPUSH
82890: PPUSH
// if not mc_bases then
82891: LD_EXP 58
82895: NOT
82896: IFFALSE 82900
// exit ;
82898: GO 83016
// if GetLives ( abandoned_vehicle ) > 250 then
82900: LD_VAR 0 2
82904: PPUSH
82905: CALL_OW 256
82909: PUSH
82910: LD_INT 250
82912: GREATER
82913: IFFALSE 82917
// exit ;
82915: GO 83016
// for i = 1 to mc_bases do
82917: LD_ADDR_VAR 0 6
82921: PUSH
82922: DOUBLE
82923: LD_INT 1
82925: DEC
82926: ST_TO_ADDR
82927: LD_EXP 58
82931: PUSH
82932: FOR_TO
82933: IFFALSE 83014
// begin if driver in mc_bases [ i ] then
82935: LD_VAR 0 1
82939: PUSH
82940: LD_EXP 58
82944: PUSH
82945: LD_VAR 0 6
82949: ARRAY
82950: IN
82951: IFFALSE 83012
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82953: LD_VAR 0 1
82957: PPUSH
82958: LD_EXP 58
82962: PUSH
82963: LD_VAR 0 6
82967: ARRAY
82968: PPUSH
82969: LD_INT 2
82971: PUSH
82972: LD_INT 30
82974: PUSH
82975: LD_INT 0
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: PUSH
82982: LD_INT 30
82984: PUSH
82985: LD_INT 1
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: EMPTY
82993: LIST
82994: LIST
82995: LIST
82996: PPUSH
82997: CALL_OW 72
83001: PUSH
83002: LD_INT 1
83004: ARRAY
83005: PPUSH
83006: CALL_OW 112
// break ;
83010: GO 83014
// end ; end ;
83012: GO 82932
83014: POP
83015: POP
// end ; end_of_file
83016: LD_VAR 0 5
83020: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
83021: GO 83023
83023: DISABLE
// begin ru_radar := 98 ;
83024: LD_ADDR_EXP 101
83028: PUSH
83029: LD_INT 98
83031: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83032: LD_ADDR_EXP 102
83036: PUSH
83037: LD_INT 89
83039: ST_TO_ADDR
// us_hack := 99 ;
83040: LD_ADDR_EXP 103
83044: PUSH
83045: LD_INT 99
83047: ST_TO_ADDR
// us_artillery := 97 ;
83048: LD_ADDR_EXP 104
83052: PUSH
83053: LD_INT 97
83055: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83056: LD_ADDR_EXP 105
83060: PUSH
83061: LD_INT 91
83063: ST_TO_ADDR
// end ;
83064: END
