// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 56443 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 48333 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 48333 0 9
// PrepareArabian ;
 140: CALL 3503 0 0
// PrepareRussian ;
 144: CALL 2638 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 57590 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6666 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 78391 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 78817 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 79212 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 79481 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 78757 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 79388 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 78817 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 79212 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 79481 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 78601 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 78757 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := false ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13910 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13910 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13910 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13910 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13910 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13910 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13910 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13910 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13910 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13910 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornell
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13910 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13910 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13910 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13910 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13910 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13910 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13910 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20543 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 60
1567: PPUSH
1568: LD_INT 6
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20543 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 3
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 75
1653: PPUSH
1654: LD_INT 6
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
1689: PPUSH
// uc_side := 6 ;
1690: LD_ADDR_OWVAR 20
1694: PUSH
1695: LD_INT 6
1697: ST_TO_ADDR
// uc_nation := 3 ;
1698: LD_ADDR_OWVAR 21
1702: PUSH
1703: LD_INT 3
1705: ST_TO_ADDR
// InitHc ;
1706: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1710: LD_ADDR_EXP 31
1714: PUSH
1715: LD_STRING Gossudarov
1717: PPUSH
1718: CALL_OW 25
1722: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1723: LD_ADDR_EXP 32
1727: PUSH
1728: LD_STRING Kirilenkova
1730: PPUSH
1731: CALL_OW 25
1735: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1736: LD_ADDR_EXP 33
1740: PUSH
1741: LD_STRING Titov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1749: LD_ADDR_EXP 38
1753: PUSH
1754: LD_STRING Oblukov
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1762: LD_ADDR_EXP 35
1766: PUSH
1767: LD_STRING Dolgov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1775: LD_ADDR_EXP 36
1779: PUSH
1780: LD_STRING Petrosyan
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1788: LD_ADDR_EXP 37
1792: PUSH
1793: LD_STRING Scholtze
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1801: LD_ADDR_EXP 39
1805: PUSH
1806: LD_STRING Kapitsova
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1814: LD_ADDR_VAR 0 2
1818: PUSH
1819: LD_EXP 31
1823: PUSH
1824: LD_EXP 32
1828: PUSH
1829: LD_EXP 33
1833: PUSH
1834: LD_EXP 38
1838: PUSH
1839: LD_EXP 35
1843: PUSH
1844: LD_EXP 36
1848: PUSH
1849: LD_EXP 37
1853: PUSH
1854: LD_EXP 39
1858: PUSH
1859: EMPTY
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: LIST
1868: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1869: LD_INT 1
1871: PPUSH
1872: LD_INT 4
1874: PPUSH
1875: LD_INT 8
1877: PPUSH
1878: CALL_OW 380
// un := CreateHuman ;
1882: LD_ADDR_VAR 0 4
1886: PUSH
1887: CALL_OW 44
1891: ST_TO_ADDR
// tmp := tmp ^ un ;
1892: LD_ADDR_VAR 0 2
1896: PUSH
1897: LD_VAR 0 2
1901: PUSH
1902: LD_VAR 0 4
1906: ADD
1907: ST_TO_ADDR
// for i in tmp do
1908: LD_ADDR_VAR 0 3
1912: PUSH
1913: LD_VAR 0 2
1917: PUSH
1918: FOR_IN
1919: IFFALSE 1938
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1921: LD_VAR 0 3
1925: PPUSH
1926: LD_INT 14
1928: PPUSH
1929: LD_INT 0
1931: PPUSH
1932: CALL_OW 49
1936: GO 1918
1938: POP
1939: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1940: LD_VAR 0 2
1944: PPUSH
1945: LD_EXP 3
1949: PPUSH
1950: CALL_OW 250
1954: PPUSH
1955: LD_EXP 3
1959: PPUSH
1960: CALL_OW 251
1964: PPUSH
1965: CALL_OW 111
// end ;
1969: LD_VAR 0 1
1973: RET
// export function PrepareBelkov ; begin
1974: LD_INT 0
1976: PPUSH
// uc_side := 4 ;
1977: LD_ADDR_OWVAR 20
1981: PUSH
1982: LD_INT 4
1984: ST_TO_ADDR
// uc_nation := 3 ;
1985: LD_ADDR_OWVAR 21
1989: PUSH
1990: LD_INT 3
1992: ST_TO_ADDR
// InitHc ;
1993: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1997: LD_ADDR_EXP 46
2001: PUSH
2002: LD_STRING Belkov
2004: PPUSH
2005: CALL_OW 25
2009: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2010: LD_EXP 46
2014: PPUSH
2015: LD_INT 14
2017: PPUSH
2018: LD_INT 0
2020: PPUSH
2021: CALL_OW 49
// end ;
2025: LD_VAR 0 1
2029: RET
// export function PrepareGnyevko ; begin
2030: LD_INT 0
2032: PPUSH
// uc_side := 4 ;
2033: LD_ADDR_OWVAR 20
2037: PUSH
2038: LD_INT 4
2040: ST_TO_ADDR
// uc_nation := 3 ;
2041: LD_ADDR_OWVAR 21
2045: PUSH
2046: LD_INT 3
2048: ST_TO_ADDR
// InitHc ;
2049: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2053: LD_ADDR_EXP 47
2057: PUSH
2058: LD_STRING Gnyevko
2060: PPUSH
2061: CALL_OW 25
2065: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2066: LD_EXP 47
2070: PPUSH
2071: LD_INT 14
2073: PPUSH
2074: LD_INT 0
2076: PPUSH
2077: CALL_OW 49
// end ;
2081: LD_VAR 0 1
2085: RET
// export function PrepareBurlak ; var i , tmp ; begin
2086: LD_INT 0
2088: PPUSH
2089: PPUSH
2090: PPUSH
// uc_side := 4 ;
2091: LD_ADDR_OWVAR 20
2095: PUSH
2096: LD_INT 4
2098: ST_TO_ADDR
// uc_nation := 3 ;
2099: LD_ADDR_OWVAR 21
2103: PUSH
2104: LD_INT 3
2106: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2107: LD_INT 35
2109: PPUSH
2110: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2114: LD_INT 92
2116: PUSH
2117: LD_INT 123
2119: PUSH
2120: LD_INT 3
2122: PUSH
2123: LD_INT 3
2125: PUSH
2126: EMPTY
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: PPUSH
2132: CALL_OW 69
2136: NOT
2137: IFFALSE 2107
// InitHc ;
2139: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2143: LD_ADDR_EXP 45
2147: PUSH
2148: LD_STRING Burlak
2150: PPUSH
2151: CALL_OW 25
2155: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2156: LD_INT 24
2158: PUSH
2159: LD_INT 23
2161: PUSH
2162: LD_INT 22
2164: PUSH
2165: EMPTY
2166: LIST
2167: LIST
2168: LIST
2169: PUSH
2170: LD_OWVAR 67
2174: ARRAY
2175: PPUSH
2176: LD_INT 1
2178: PPUSH
2179: LD_INT 1
2181: PPUSH
2182: LD_INT 45
2184: PUSH
2185: LD_INT 44
2187: PUSH
2188: LD_INT 43
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 0
2204: PPUSH
2205: CALL 20543 0 5
// Masha := CreateVehicle ;
2209: LD_ADDR_EXP 48
2213: PUSH
2214: CALL_OW 45
2218: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2219: LD_EXP 48
2223: PUSH
2224: LD_EXP 45
2228: PUSH
2229: EMPTY
2230: LIST
2231: LIST
2232: PPUSH
2233: LD_INT 499
2235: PPUSH
2236: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2240: LD_EXP 48
2244: PPUSH
2245: LD_INT 3
2247: PPUSH
2248: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2252: LD_EXP 48
2256: PPUSH
2257: LD_INT 1
2259: PPUSH
2260: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2264: LD_EXP 48
2268: PPUSH
2269: LD_INT 18
2271: PPUSH
2272: LD_INT 0
2274: PPUSH
2275: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2279: LD_EXP 45
2283: PPUSH
2284: LD_INT 125
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 0
2292: PPUSH
2293: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2297: LD_EXP 45
2301: PPUSH
2302: LD_EXP 48
2306: PPUSH
2307: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2311: LD_INT 10
2313: PPUSH
2314: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2318: LD_EXP 48
2322: PPUSH
2323: LD_INT 110
2325: PPUSH
2326: LD_INT 10
2328: PPUSH
2329: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2333: LD_ADDR_EXP 41
2337: PUSH
2338: LD_STRING Petrovova
2340: PPUSH
2341: CALL_OW 25
2345: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2346: LD_ADDR_EXP 43
2350: PUSH
2351: LD_STRING Kuzmov
2353: PPUSH
2354: CALL_OW 25
2358: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Kovalyuk
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2372: LD_ADDR_EXP 40
2376: PUSH
2377: LD_STRING Lipshchin
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2385: LD_ADDR_EXP 44
2389: PUSH
2390: LD_STRING Karamazov
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2398: LD_ADDR_VAR 0 3
2402: PUSH
2403: LD_EXP 41
2407: PUSH
2408: LD_EXP 43
2412: PUSH
2413: LD_EXP 42
2417: PUSH
2418: LD_EXP 40
2422: PUSH
2423: LD_EXP 44
2427: PUSH
2428: EMPTY
2429: LIST
2430: LIST
2431: LIST
2432: LIST
2433: LIST
2434: ST_TO_ADDR
// for i in tmp do
2435: LD_ADDR_VAR 0 2
2439: PUSH
2440: LD_VAR 0 3
2444: PUSH
2445: FOR_IN
2446: IFFALSE 2485
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2448: LD_VAR 0 2
2452: PPUSH
2453: LD_INT 399
2455: PPUSH
2456: LD_INT 799
2458: PPUSH
2459: CALL_OW 12
2463: PPUSH
2464: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2468: LD_VAR 0 2
2472: PPUSH
2473: LD_INT 19
2475: PPUSH
2476: LD_INT 0
2478: PPUSH
2479: CALL_OW 49
// end ;
2483: GO 2445
2485: POP
2486: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2487: LD_VAR 0 3
2491: PPUSH
2492: LD_INT 116
2494: PPUSH
2495: LD_INT 8
2497: PPUSH
2498: CALL_OW 111
// AddComHold ( tmp ) ;
2502: LD_VAR 0 3
2506: PPUSH
2507: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 3
2520: PPUSH
2521: LD_INT 25
2523: PUSH
2524: LD_INT 1
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: PPUSH
2531: CALL_OW 72
2535: PUSH
2536: FOR_IN
2537: IFFALSE 2577
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2539: LD_VAR 0 2
2543: PPUSH
2544: LD_INT 20
2546: PPUSH
2547: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2551: LD_VAR 0 2
2555: PPUSH
2556: LD_INT 147
2558: PPUSH
2559: LD_INT 45
2561: PPUSH
2562: CALL_OW 178
// AddComCrawl ( i ) ;
2566: LD_VAR 0 2
2570: PPUSH
2571: CALL_OW 197
// end ;
2575: GO 2536
2577: POP
2578: POP
// repeat wait ( 0 0$1 ) ;
2579: LD_INT 35
2581: PPUSH
2582: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2586: LD_EXP 48
2590: PPUSH
2591: LD_INT 110
2593: PPUSH
2594: LD_INT 10
2596: PPUSH
2597: CALL_OW 307
2601: PUSH
2602: LD_EXP 48
2606: PPUSH
2607: CALL_OW 305
2611: NOT
2612: OR
2613: IFFALSE 2579
// ComStop ( Burlak ) ;
2615: LD_EXP 45
2619: PPUSH
2620: CALL_OW 141
// AddComHold ( Burlak ) ;
2624: LD_EXP 45
2628: PPUSH
2629: CALL_OW 200
// end ; end_of_file
2633: LD_VAR 0 1
2637: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2638: LD_INT 0
2640: PPUSH
2641: PPUSH
2642: PPUSH
2643: PPUSH
// uc_side := 3 ;
2644: LD_ADDR_OWVAR 20
2648: PUSH
2649: LD_INT 3
2651: ST_TO_ADDR
// uc_nation := 3 ;
2652: LD_ADDR_OWVAR 21
2656: PUSH
2657: LD_INT 3
2659: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2660: LD_ADDR_EXP 49
2664: PUSH
2665: LD_INT 47
2667: PPUSH
2668: LD_INT 4
2670: PPUSH
2671: LD_STRING 
2673: PPUSH
2674: LD_INT 7
2676: PUSH
2677: LD_INT 8
2679: PUSH
2680: LD_INT 9
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: LIST
2687: PUSH
2688: LD_OWVAR 67
2692: ARRAY
2693: PPUSH
2694: LD_INT 10000
2696: PUSH
2697: LD_INT 3000
2699: PUSH
2700: LD_INT 300
2702: PUSH
2703: EMPTY
2704: LIST
2705: LIST
2706: LIST
2707: PPUSH
2708: LD_INT 9
2710: PUSH
2711: LD_INT 5
2713: PUSH
2714: LD_INT 6
2716: PUSH
2717: LD_INT 6
2719: PUSH
2720: EMPTY
2721: LIST
2722: LIST
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL 23952 0 6
2730: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2731: LD_ADDR_EXP 58
2735: PUSH
2736: LD_EXP 58
2740: PPUSH
2741: LD_INT 2
2743: PPUSH
2744: LD_EXP 49
2748: PPUSH
2749: CALL_OW 1
2753: ST_TO_ADDR
// tmp := [ ] ;
2754: LD_ADDR_VAR 0 4
2758: PUSH
2759: EMPTY
2760: ST_TO_ADDR
// for i = 1 to 4 do
2761: LD_ADDR_VAR 0 2
2765: PUSH
2766: DOUBLE
2767: LD_INT 1
2769: DEC
2770: ST_TO_ADDR
2771: LD_INT 4
2773: PUSH
2774: FOR_TO
2775: IFFALSE 2868
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2777: LD_INT 22
2779: PPUSH
2780: LD_INT 3
2782: PPUSH
2783: LD_INT 3
2785: PPUSH
2786: LD_INT 43
2788: PUSH
2789: LD_INT 45
2791: PUSH
2792: LD_INT 45
2794: PUSH
2795: LD_INT 44
2797: PUSH
2798: EMPTY
2799: LIST
2800: LIST
2801: LIST
2802: LIST
2803: PUSH
2804: LD_VAR 0 2
2808: PUSH
2809: LD_INT 4
2811: MOD
2812: PUSH
2813: LD_INT 1
2815: PLUS
2816: ARRAY
2817: PPUSH
2818: LD_INT 100
2820: PPUSH
2821: CALL 20543 0 5
// veh := CreateVehicle ;
2825: LD_ADDR_VAR 0 3
2829: PUSH
2830: CALL_OW 45
2834: ST_TO_ADDR
// tmp := tmp ^ veh ;
2835: LD_ADDR_VAR 0 4
2839: PUSH
2840: LD_VAR 0 4
2844: PUSH
2845: LD_VAR 0 3
2849: ADD
2850: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2851: LD_VAR 0 3
2855: PPUSH
2856: LD_INT 2
2858: PPUSH
2859: LD_INT 0
2861: PPUSH
2862: CALL_OW 49
// end ;
2866: GO 2774
2868: POP
2869: POP
// russian_guard := tmp ;
2870: LD_ADDR_EXP 50
2874: PUSH
2875: LD_VAR 0 4
2879: ST_TO_ADDR
// end ;
2880: LD_VAR 0 1
2884: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2885: LD_INT 47
2887: PPUSH
2888: CALL_OW 302
2892: PUSH
2893: LD_EXP 6
2897: AND
2898: IFFALSE 3500
2900: GO 2902
2902: DISABLE
2903: LD_INT 0
2905: PPUSH
2906: PPUSH
2907: PPUSH
2908: PPUSH
2909: PPUSH
2910: PPUSH
// begin enable ;
2911: ENABLE
// base := 2 ;
2912: LD_ADDR_VAR 0 2
2916: PUSH
2917: LD_INT 2
2919: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2920: LD_ADDR_VAR 0 4
2924: PUSH
2925: LD_INT 0
2927: PUSH
2928: LD_INT 0
2930: PUSH
2931: LD_INT 0
2933: PUSH
2934: LD_INT 0
2936: PUSH
2937: LD_INT 0
2939: PUSH
2940: LD_INT 0
2942: PUSH
2943: LD_INT 0
2945: PUSH
2946: LD_INT 0
2948: PUSH
2949: LD_INT 1
2951: PUSH
2952: LD_INT 0
2954: PUSH
2955: EMPTY
2956: LIST
2957: LIST
2958: LIST
2959: LIST
2960: LIST
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: LIST
2966: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2967: LD_ADDR_VAR 0 3
2971: PUSH
2972: LD_INT 22
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 3
2980: PUSH
2981: LD_INT 45
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_INT 21
2992: PUSH
2993: LD_INT 1
2995: PUSH
2996: LD_INT 3
2998: PUSH
2999: LD_INT 45
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: LIST
3007: PUSH
3008: LD_INT 22
3010: PUSH
3011: LD_INT 1
3013: PUSH
3014: LD_INT 3
3016: PUSH
3017: LD_INT 45
3019: PUSH
3020: EMPTY
3021: LIST
3022: LIST
3023: LIST
3024: LIST
3025: PUSH
3026: LD_INT 23
3028: PUSH
3029: LD_INT 1
3031: PUSH
3032: LD_INT 3
3034: PUSH
3035: LD_INT 46
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: EMPTY
3045: LIST
3046: LIST
3047: LIST
3048: LIST
3049: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3050: LD_ADDR_VAR 0 1
3054: PUSH
3055: DOUBLE
3056: LD_INT 1
3058: DEC
3059: ST_TO_ADDR
3060: LD_OWVAR 67
3064: PUSH
3065: LD_OWVAR 1
3069: PUSH
3070: LD_INT 21000
3072: DIV
3073: PLUS
3074: PUSH
3075: FOR_TO
3076: IFFALSE 3164
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3078: LD_ADDR_VAR 0 3
3082: PUSH
3083: LD_VAR 0 3
3087: PPUSH
3088: LD_VAR 0 3
3092: PUSH
3093: LD_INT 1
3095: PLUS
3096: PPUSH
3097: LD_INT 23
3099: PUSH
3100: LD_INT 24
3102: PUSH
3103: EMPTY
3104: LIST
3105: LIST
3106: PUSH
3107: LD_INT 1
3109: PPUSH
3110: LD_INT 2
3112: PPUSH
3113: CALL_OW 12
3117: ARRAY
3118: PUSH
3119: LD_INT 1
3121: PUSH
3122: LD_INT 3
3124: PUSH
3125: LD_INT 46
3127: PUSH
3128: LD_INT 47
3130: PUSH
3131: LD_INT 45
3133: PUSH
3134: EMPTY
3135: LIST
3136: LIST
3137: LIST
3138: PUSH
3139: LD_INT 1
3141: PPUSH
3142: LD_INT 3
3144: PPUSH
3145: CALL_OW 12
3149: ARRAY
3150: PUSH
3151: EMPTY
3152: LIST
3153: LIST
3154: LIST
3155: LIST
3156: PPUSH
3157: CALL_OW 2
3161: ST_TO_ADDR
3162: GO 3075
3164: POP
3165: POP
// MC_InsertProduceList ( base , tmp ) ;
3166: LD_VAR 0 2
3170: PPUSH
3171: LD_VAR 0 3
3175: PPUSH
3176: CALL 78757 0 2
// repeat wait ( 0 0$1 ) ;
3180: LD_INT 35
3182: PPUSH
3183: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3187: LD_EXP 77
3191: PUSH
3192: LD_VAR 0 2
3196: ARRAY
3197: PUSH
3198: LD_INT 6
3200: GREATER
3201: IFFALSE 3180
// wait ( 0 0$20 ) ;
3203: LD_INT 700
3205: PPUSH
3206: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3210: LD_ADDR_VAR 0 5
3214: PUSH
3215: LD_INT 71
3217: PUSH
3218: LD_INT 19
3220: PUSH
3221: EMPTY
3222: LIST
3223: LIST
3224: PUSH
3225: LD_INT 91
3227: PUSH
3228: LD_INT 67
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: PUSH
3235: LD_INT 52
3237: PUSH
3238: LD_INT 44
3240: PUSH
3241: EMPTY
3242: LIST
3243: LIST
3244: PUSH
3245: LD_INT 68
3247: PUSH
3248: LD_INT 48
3250: PUSH
3251: EMPTY
3252: LIST
3253: LIST
3254: PUSH
3255: EMPTY
3256: LIST
3257: LIST
3258: LIST
3259: LIST
3260: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3261: LD_ADDR_VAR 0 6
3265: PUSH
3266: LD_EXP 77
3270: PUSH
3271: LD_VAR 0 2
3275: ARRAY
3276: PUSH
3277: LD_EXP 77
3281: PUSH
3282: LD_VAR 0 2
3286: ARRAY
3287: PPUSH
3288: LD_INT 2
3290: PUSH
3291: LD_INT 34
3293: PUSH
3294: LD_INT 51
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 34
3303: PUSH
3304: LD_INT 52
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: EMPTY
3312: LIST
3313: LIST
3314: LIST
3315: PPUSH
3316: CALL_OW 72
3320: DIFF
3321: ST_TO_ADDR
// if not attackers then
3322: LD_VAR 0 6
3326: NOT
3327: IFFALSE 3331
// exit ;
3329: GO 3500
// ru_attackers := attackers ;
3331: LD_ADDR_EXP 51
3335: PUSH
3336: LD_VAR 0 6
3340: ST_TO_ADDR
// for i = 1 to attackers do
3341: LD_ADDR_VAR 0 1
3345: PUSH
3346: DOUBLE
3347: LD_INT 1
3349: DEC
3350: ST_TO_ADDR
3351: LD_VAR 0 6
3355: PUSH
3356: FOR_TO
3357: IFFALSE 3434
// begin case i mod 3 of 0 :
3359: LD_VAR 0 1
3363: PUSH
3364: LD_INT 3
3366: MOD
3367: PUSH
3368: LD_INT 0
3370: DOUBLE
3371: EQUAL
3372: IFTRUE 3376
3374: GO 3379
3376: POP
// ; 1 :
3377: GO 3432
3379: LD_INT 1
3381: DOUBLE
3382: EQUAL
3383: IFTRUE 3387
3385: GO 3405
3387: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3388: LD_VAR 0 1
3392: PPUSH
3393: LD_INT 32
3395: PPUSH
3396: LD_INT 49
3398: PPUSH
3399: CALL_OW 114
3403: GO 3432
3405: LD_INT 2
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 117
3421: PPUSH
3422: LD_INT 107
3424: PPUSH
3425: CALL_OW 114
3429: GO 3432
3431: POP
// end ;
3432: GO 3356
3434: POP
3435: POP
// repeat wait ( 0 0$1 ) ;
3436: LD_INT 35
3438: PPUSH
3439: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3443: LD_VAR 0 6
3447: PPUSH
3448: LD_INT 60
3450: PUSH
3451: EMPTY
3452: LIST
3453: PPUSH
3454: CALL_OW 72
3458: NOT
3459: IFFALSE 3436
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3461: LD_VAR 0 2
3465: PPUSH
3466: LD_VAR 0 6
3470: PPUSH
3471: LD_VAR 0 5
3475: PPUSH
3476: LD_VAR 0 4
3480: PPUSH
3481: CALL 78942 0 4
// if not first_attack then
3485: LD_EXP 7
3489: NOT
3490: IFFALSE 3500
// first_attack := true ;
3492: LD_ADDR_EXP 7
3496: PUSH
3497: LD_INT 1
3499: ST_TO_ADDR
// end ; end_of_file
3500: PPOPN 6
3502: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3503: LD_INT 0
3505: PPUSH
3506: PPUSH
3507: PPUSH
3508: PPUSH
3509: PPUSH
3510: PPUSH
3511: PPUSH
// uc_side := 2 ;
3512: LD_ADDR_OWVAR 20
3516: PUSH
3517: LD_INT 2
3519: ST_TO_ADDR
// uc_nation := 2 ;
3520: LD_ADDR_OWVAR 21
3524: PUSH
3525: LD_INT 2
3527: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3528: LD_ADDR_EXP 54
3532: PUSH
3533: LD_STRING Abdul
3535: PPUSH
3536: CALL_OW 25
3540: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3541: LD_EXP 54
3545: PPUSH
3546: LD_INT 11
3548: PPUSH
3549: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3553: LD_EXP 54
3557: PPUSH
3558: LD_INT 1
3560: PPUSH
3561: CALL_OW 52
// vc_chassis := 31 ;
3565: LD_ADDR_OWVAR 37
3569: PUSH
3570: LD_INT 31
3572: ST_TO_ADDR
// vc_control := control_rider ;
3573: LD_ADDR_OWVAR 38
3577: PUSH
3578: LD_INT 4
3580: ST_TO_ADDR
// mastodont := CreateVehicle ;
3581: LD_ADDR_EXP 55
3585: PUSH
3586: CALL_OW 45
3590: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3591: LD_EXP 55
3595: PPUSH
3596: LD_INT 153
3598: PPUSH
3599: LD_INT 71
3601: PPUSH
3602: LD_INT 0
3604: PPUSH
3605: CALL_OW 48
// InitVc ;
3609: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3613: LD_ADDR_EXP 52
3617: PUSH
3618: LD_INT 1
3620: PPUSH
3621: LD_INT 3
3623: PPUSH
3624: LD_STRING 
3626: PPUSH
3627: LD_INT 7
3629: PUSH
3630: LD_INT 8
3632: PUSH
3633: LD_INT 9
3635: PUSH
3636: EMPTY
3637: LIST
3638: LIST
3639: LIST
3640: PUSH
3641: LD_OWVAR 67
3645: ARRAY
3646: PPUSH
3647: LD_INT 5000
3649: PUSH
3650: LD_INT 1000
3652: PUSH
3653: LD_INT 300
3655: PUSH
3656: EMPTY
3657: LIST
3658: LIST
3659: LIST
3660: PPUSH
3661: LD_INT 22
3663: PUSH
3664: LD_INT 5
3666: PUSH
3667: LD_INT 6
3669: PUSH
3670: LD_INT 9
3672: PUSH
3673: EMPTY
3674: LIST
3675: LIST
3676: LIST
3677: LIST
3678: PPUSH
3679: CALL 23952 0 6
3683: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3684: LD_ADDR_EXP 58
3688: PUSH
3689: LD_EXP 58
3693: PPUSH
3694: LD_INT 1
3696: PPUSH
3697: LD_EXP 52
3701: PPUSH
3702: CALL_OW 1
3706: ST_TO_ADDR
// tmp := [ ] ;
3707: LD_ADDR_VAR 0 4
3711: PUSH
3712: EMPTY
3713: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3714: LD_ADDR_OWVAR 37
3718: PUSH
3719: LD_INT 14
3721: ST_TO_ADDR
// vc_engine := engine_siberite ;
3722: LD_ADDR_OWVAR 39
3726: PUSH
3727: LD_INT 3
3729: ST_TO_ADDR
// vc_control := control_manual ;
3730: LD_ADDR_OWVAR 38
3734: PUSH
3735: LD_INT 1
3737: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3738: LD_ADDR_OWVAR 40
3742: PUSH
3743: LD_INT 31
3745: ST_TO_ADDR
// for i = 1 to 3 do
3746: LD_ADDR_VAR 0 2
3750: PUSH
3751: DOUBLE
3752: LD_INT 1
3754: DEC
3755: ST_TO_ADDR
3756: LD_INT 3
3758: PUSH
3759: FOR_TO
3760: IFFALSE 4004
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3762: LD_ADDR_VAR 0 5
3766: PUSH
3767: LD_INT 153
3769: PUSH
3770: LD_INT 71
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PUSH
3777: LD_INT 155
3779: PUSH
3780: LD_INT 81
3782: PUSH
3783: EMPTY
3784: LIST
3785: LIST
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: LD_VAR 0 2
3795: PUSH
3796: LD_INT 2
3798: MOD
3799: PUSH
3800: LD_INT 1
3802: PLUS
3803: ARRAY
3804: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3805: LD_INT 0
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_INT 7
3813: PUSH
3814: LD_INT 8
3816: PUSH
3817: LD_INT 9
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: LIST
3824: PUSH
3825: LD_OWVAR 67
3829: ARRAY
3830: PPUSH
3831: CALL_OW 380
// un := CreateVehicle ;
3835: LD_ADDR_VAR 0 6
3839: PUSH
3840: CALL_OW 45
3844: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3845: LD_VAR 0 6
3849: PPUSH
3850: LD_INT 0
3852: PPUSH
3853: LD_INT 5
3855: PPUSH
3856: CALL_OW 12
3860: PPUSH
3861: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3865: LD_VAR 0 6
3869: PPUSH
3870: LD_VAR 0 5
3874: PUSH
3875: LD_INT 1
3877: ARRAY
3878: PPUSH
3879: LD_VAR 0 5
3883: PUSH
3884: LD_INT 2
3886: ARRAY
3887: PPUSH
3888: LD_INT 6
3890: PPUSH
3891: LD_INT 0
3893: PPUSH
3894: CALL_OW 50
// un2 := CreateHuman ;
3898: LD_ADDR_VAR 0 7
3902: PUSH
3903: CALL_OW 44
3907: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3908: LD_VAR 0 7
3912: PPUSH
3913: LD_VAR 0 6
3917: PPUSH
3918: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3922: LD_ADDR_EXP 58
3926: PUSH
3927: LD_EXP 58
3931: PPUSH
3932: LD_INT 1
3934: PUSH
3935: LD_EXP 58
3939: PUSH
3940: LD_INT 1
3942: ARRAY
3943: PUSH
3944: LD_INT 1
3946: PLUS
3947: PUSH
3948: EMPTY
3949: LIST
3950: LIST
3951: PPUSH
3952: LD_VAR 0 6
3956: PPUSH
3957: CALL 20665 0 3
3961: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3962: LD_ADDR_EXP 58
3966: PUSH
3967: LD_EXP 58
3971: PPUSH
3972: LD_INT 1
3974: PUSH
3975: LD_EXP 58
3979: PUSH
3980: LD_INT 1
3982: ARRAY
3983: PUSH
3984: LD_INT 1
3986: PLUS
3987: PUSH
3988: EMPTY
3989: LIST
3990: LIST
3991: PPUSH
3992: LD_VAR 0 7
3996: PPUSH
3997: CALL 20665 0 3
4001: ST_TO_ADDR
// end ;
4002: GO 3759
4004: POP
4005: POP
// for i = 1 to 5 do
4006: LD_ADDR_VAR 0 2
4010: PUSH
4011: DOUBLE
4012: LD_INT 1
4014: DEC
4015: ST_TO_ADDR
4016: LD_INT 5
4018: PUSH
4019: FOR_TO
4020: IFFALSE 4113
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4022: LD_INT 14
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 25
4033: PUSH
4034: LD_INT 28
4036: PUSH
4037: LD_INT 28
4039: PUSH
4040: LD_INT 26
4042: PUSH
4043: EMPTY
4044: LIST
4045: LIST
4046: LIST
4047: LIST
4048: PUSH
4049: LD_VAR 0 2
4053: PUSH
4054: LD_INT 4
4056: MOD
4057: PUSH
4058: LD_INT 1
4060: PLUS
4061: ARRAY
4062: PPUSH
4063: LD_INT 100
4065: PPUSH
4066: CALL 20543 0 5
// veh := CreateVehicle ;
4070: LD_ADDR_VAR 0 3
4074: PUSH
4075: CALL_OW 45
4079: ST_TO_ADDR
// tmp := tmp ^ veh ;
4080: LD_ADDR_VAR 0 4
4084: PUSH
4085: LD_VAR 0 4
4089: PUSH
4090: LD_VAR 0 3
4094: ADD
4095: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4096: LD_VAR 0 3
4100: PPUSH
4101: LD_INT 1
4103: PPUSH
4104: LD_INT 0
4106: PPUSH
4107: CALL_OW 49
// end ;
4111: GO 4019
4113: POP
4114: POP
// arabian_guard := tmp ;
4115: LD_ADDR_EXP 53
4119: PUSH
4120: LD_VAR 0 4
4124: ST_TO_ADDR
// end ;
4125: LD_VAR 0 1
4129: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4130: LD_INT 22
4132: PUSH
4133: LD_INT 7
4135: PUSH
4136: EMPTY
4137: LIST
4138: LIST
4139: PUSH
4140: LD_INT 91
4142: PUSH
4143: LD_INT 1
4145: PUSH
4146: LD_INT 12
4148: PUSH
4149: EMPTY
4150: LIST
4151: LIST
4152: LIST
4153: PUSH
4154: EMPTY
4155: LIST
4156: LIST
4157: PPUSH
4158: CALL_OW 69
4162: PUSH
4163: LD_EXP 55
4167: PPUSH
4168: CALL_OW 256
4172: PUSH
4173: LD_INT 990
4175: LESS
4176: OR
4177: PUSH
4178: LD_EXP 54
4182: PPUSH
4183: CALL_OW 256
4187: PUSH
4188: LD_INT 990
4190: LESS
4191: OR
4192: IFFALSE 4335
4194: GO 4196
4196: DISABLE
// begin if IsInUnit ( Abdul ) then
4197: LD_EXP 54
4201: PPUSH
4202: CALL_OW 310
4206: IFFALSE 4217
// ComExitBuilding ( Abdul ) ;
4208: LD_EXP 54
4212: PPUSH
4213: CALL_OW 122
// if Mastodont then
4217: LD_EXP 55
4221: IFFALSE 4238
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4223: LD_EXP 55
4227: PPUSH
4228: LD_INT 205
4230: PPUSH
4231: LD_INT 132
4233: PPUSH
4234: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4238: LD_EXP 54
4242: PPUSH
4243: LD_INT 205
4245: PPUSH
4246: LD_INT 132
4248: PPUSH
4249: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4253: LD_INT 35
4255: PPUSH
4256: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4260: LD_EXP 54
4264: PPUSH
4265: LD_INT 21
4267: PPUSH
4268: CALL_OW 308
4272: IFFALSE 4253
// RemoveUnit ( Abdul ) ;
4274: LD_EXP 54
4278: PPUSH
4279: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4283: LD_INT 35
4285: PPUSH
4286: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4290: LD_EXP 55
4294: PPUSH
4295: LD_INT 21
4297: PPUSH
4298: CALL_OW 308
4302: PUSH
4303: LD_EXP 55
4307: PPUSH
4308: CALL_OW 301
4312: OR
4313: IFFALSE 4283
// if IsOk ( Mastodont ) then
4315: LD_EXP 55
4319: PPUSH
4320: CALL_OW 302
4324: IFFALSE 4335
// RemoveUnit ( Mastodont ) ;
4326: LD_EXP 55
4330: PPUSH
4331: CALL_OW 64
// end ;
4335: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4336: LD_EXP 54
4340: PPUSH
4341: CALL_OW 301
4345: PUSH
4346: LD_INT 22
4348: PUSH
4349: LD_INT 2
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: LD_INT 25
4361: PUSH
4362: LD_INT 1
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: PUSH
4369: LD_INT 25
4371: PUSH
4372: LD_INT 2
4374: PUSH
4375: EMPTY
4376: LIST
4377: LIST
4378: PUSH
4379: LD_INT 25
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: EMPTY
4386: LIST
4387: LIST
4388: PUSH
4389: LD_INT 25
4391: PUSH
4392: LD_INT 4
4394: PUSH
4395: EMPTY
4396: LIST
4397: LIST
4398: PUSH
4399: LD_INT 25
4401: PUSH
4402: LD_INT 8
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: LIST
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: CALL_OW 69
4425: PUSH
4426: LD_INT 16
4428: PUSH
4429: LD_INT 19
4431: PUSH
4432: LD_INT 22
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: PUSH
4440: LD_OWVAR 67
4444: ARRAY
4445: LESS
4446: OR
4447: IFFALSE 5120
4449: GO 4451
4451: DISABLE
4452: LD_INT 0
4454: PPUSH
4455: PPUSH
4456: PPUSH
4457: PPUSH
4458: PPUSH
4459: PPUSH
// begin MC_Kill ( 1 ) ;
4460: LD_INT 1
4462: PPUSH
4463: CALL 56678 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: LD_INT 22
4474: PUSH
4475: LD_INT 2
4477: PUSH
4478: EMPTY
4479: LIST
4480: LIST
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: LD_INT 25
4487: PUSH
4488: LD_INT 1
4490: PUSH
4491: EMPTY
4492: LIST
4493: LIST
4494: PUSH
4495: LD_INT 25
4497: PUSH
4498: LD_INT 2
4500: PUSH
4501: EMPTY
4502: LIST
4503: LIST
4504: PUSH
4505: LD_INT 25
4507: PUSH
4508: LD_INT 3
4510: PUSH
4511: EMPTY
4512: LIST
4513: LIST
4514: PUSH
4515: LD_INT 25
4517: PUSH
4518: LD_INT 4
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PUSH
4525: LD_INT 25
4527: PUSH
4528: LD_INT 8
4530: PUSH
4531: EMPTY
4532: LIST
4533: LIST
4534: PUSH
4535: EMPTY
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PPUSH
4547: CALL_OW 69
4551: ST_TO_ADDR
// for i in tmp do
4552: LD_ADDR_VAR 0 5
4556: PUSH
4557: LD_VAR 0 2
4561: PUSH
4562: FOR_IN
4563: IFFALSE 4579
// SetTag ( i , 10 ) ;
4565: LD_VAR 0 5
4569: PPUSH
4570: LD_INT 10
4572: PPUSH
4573: CALL_OW 109
4577: GO 4562
4579: POP
4580: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4581: LD_ADDR_VAR 0 3
4585: PUSH
4586: LD_INT 22
4588: PUSH
4589: LD_INT 2
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: LD_INT 21
4598: PUSH
4599: LD_INT 1
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: PUSH
4606: EMPTY
4607: LIST
4608: LIST
4609: PPUSH
4610: CALL_OW 69
4614: PUSH
4615: LD_VAR 0 2
4619: DIFF
4620: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4621: LD_ADDR_VAR 0 1
4625: PUSH
4626: LD_INT 22
4628: PUSH
4629: LD_INT 2
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PUSH
4636: LD_INT 21
4638: PUSH
4639: LD_INT 2
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 24
4648: PUSH
4649: LD_INT 300
4651: PUSH
4652: EMPTY
4653: LIST
4654: LIST
4655: PUSH
4656: EMPTY
4657: LIST
4658: LIST
4659: LIST
4660: PPUSH
4661: CALL_OW 69
4665: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4666: LD_ADDR_VAR 0 4
4670: PUSH
4671: LD_VAR 0 1
4675: PPUSH
4676: LD_INT 33
4678: PUSH
4679: LD_INT 1
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: PUSH
4686: LD_INT 58
4688: PUSH
4689: EMPTY
4690: LIST
4691: PUSH
4692: EMPTY
4693: LIST
4694: LIST
4695: PPUSH
4696: CALL_OW 72
4700: ST_TO_ADDR
// for i in tmp do
4701: LD_ADDR_VAR 0 5
4705: PUSH
4706: LD_VAR 0 2
4710: PUSH
4711: FOR_IN
4712: IFFALSE 4896
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4714: LD_VAR 0 5
4718: PUSH
4719: LD_INT 55
4721: PUSH
4722: EMPTY
4723: LIST
4724: PPUSH
4725: CALL_OW 69
4729: IN
4730: IFFALSE 4749
// begin AddComMoveXY ( i , 209 , 132 ) ;
4732: LD_VAR 0 5
4736: PPUSH
4737: LD_INT 209
4739: PPUSH
4740: LD_INT 132
4742: PPUSH
4743: CALL_OW 171
// continue ;
4747: GO 4711
// end ; if IsInUnit ( i ) then
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 310
4758: IFFALSE 4776
// begin ComExitBuilding ( i ) ;
4760: LD_VAR 0 5
4764: PPUSH
4765: CALL_OW 122
// wait ( 3 ) ;
4769: LD_INT 3
4771: PPUSH
4772: CALL_OW 67
// end ; if tmp_empty then
4776: LD_VAR 0 4
4780: IFFALSE 4879
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4782: LD_VAR 0 5
4786: PPUSH
4787: LD_VAR 0 4
4791: PPUSH
4792: LD_VAR 0 5
4796: PPUSH
4797: CALL_OW 74
4801: PPUSH
4802: CALL_OW 296
4806: PUSH
4807: LD_INT 25
4809: LESS
4810: IFFALSE 4879
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4812: LD_ADDR_VAR 0 6
4816: PUSH
4817: LD_VAR 0 4
4821: PPUSH
4822: LD_VAR 0 5
4826: PPUSH
4827: CALL_OW 74
4831: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4832: LD_VAR 0 5
4836: PPUSH
4837: LD_VAR 0 6
4841: PPUSH
4842: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4846: LD_VAR 0 5
4850: PPUSH
4851: LD_INT 209
4853: PPUSH
4854: LD_INT 132
4856: PPUSH
4857: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4861: LD_ADDR_VAR 0 4
4865: PUSH
4866: LD_VAR 0 4
4870: PUSH
4871: LD_VAR 0 6
4875: DIFF
4876: ST_TO_ADDR
// continue ;
4877: GO 4711
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4879: LD_VAR 0 5
4883: PPUSH
4884: LD_INT 201
4886: PPUSH
4887: LD_INT 132
4889: PPUSH
4890: CALL_OW 171
// end ;
4894: GO 4711
4896: POP
4897: POP
// for i in tmp_ape do
4898: LD_ADDR_VAR 0 5
4902: PUSH
4903: LD_VAR 0 3
4907: PUSH
4908: FOR_IN
4909: IFFALSE 4948
// begin if IsInUnit ( i ) then
4911: LD_VAR 0 5
4915: PPUSH
4916: CALL_OW 310
4920: IFFALSE 4931
// ComExitBuilding ( i ) ;
4922: LD_VAR 0 5
4926: PPUSH
4927: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_INT 201
4938: PPUSH
4939: LD_INT 132
4941: PPUSH
4942: CALL_OW 171
// end ;
4946: GO 4908
4948: POP
4949: POP
// repeat wait ( 0 0$1 ) ;
4950: LD_INT 35
4952: PPUSH
4953: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4957: LD_ADDR_VAR 0 5
4961: PUSH
4962: LD_VAR 0 2
4966: PUSH
4967: LD_VAR 0 3
4971: UNION
4972: PUSH
4973: LD_VAR 0 1
4977: UNION
4978: PUSH
4979: FOR_IN
4980: IFFALSE 5011
// if not HasTask ( i ) then
4982: LD_VAR 0 5
4986: PPUSH
4987: CALL_OW 314
4991: NOT
4992: IFFALSE 5009
// ComMoveXY ( i , 201 , 132 ) ;
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_INT 201
5001: PPUSH
5002: LD_INT 132
5004: PPUSH
5005: CALL_OW 111
5009: GO 4979
5011: POP
5012: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5013: LD_INT 21
5015: PPUSH
5016: LD_INT 22
5018: PUSH
5019: LD_INT 2
5021: PUSH
5022: EMPTY
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL_OW 70
5030: IFFALSE 5071
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5032: LD_ADDR_VAR 0 5
5036: PUSH
5037: LD_INT 21
5039: PPUSH
5040: LD_INT 22
5042: PUSH
5043: LD_INT 2
5045: PUSH
5046: EMPTY
5047: LIST
5048: LIST
5049: PPUSH
5050: CALL_OW 70
5054: PUSH
5055: FOR_IN
5056: IFFALSE 5069
// RemoveUnit ( i ) ;
5058: LD_VAR 0 5
5062: PPUSH
5063: CALL_OW 64
5067: GO 5055
5069: POP
5070: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5071: LD_INT 22
5073: PUSH
5074: LD_INT 2
5076: PUSH
5077: EMPTY
5078: LIST
5079: LIST
5080: PUSH
5081: LD_INT 2
5083: PUSH
5084: LD_INT 21
5086: PUSH
5087: LD_INT 1
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: PUSH
5094: LD_INT 21
5096: PUSH
5097: LD_INT 2
5099: PUSH
5100: EMPTY
5101: LIST
5102: LIST
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: PUSH
5109: EMPTY
5110: LIST
5111: LIST
5112: PPUSH
5113: CALL_OW 69
5117: NOT
5118: IFFALSE 4950
// end ;
5120: PPOPN 6
5122: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5123: LD_EXP 9
5127: PUSH
5128: LD_INT 92
5130: PPUSH
5131: LD_INT 40
5133: PPUSH
5134: CALL_OW 428
5138: PPUSH
5139: CALL_OW 266
5143: PUSH
5144: LD_INT 30
5146: EQUAL
5147: AND
5148: IFFALSE 5344
5150: GO 5152
5152: DISABLE
5153: LD_INT 0
5155: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5156: LD_ADDR_VAR 0 1
5160: PUSH
5161: LD_EXP 58
5165: PUSH
5166: LD_INT 1
5168: ARRAY
5169: PPUSH
5170: LD_INT 25
5172: PUSH
5173: LD_INT 4
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PPUSH
5180: CALL_OW 72
5184: ST_TO_ADDR
// if not sci then
5185: LD_VAR 0 1
5189: NOT
5190: IFFALSE 5194
// exit ;
5192: GO 5344
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5194: LD_ADDR_EXP 58
5198: PUSH
5199: LD_EXP 58
5203: PPUSH
5204: LD_INT 1
5206: PPUSH
5207: LD_EXP 58
5211: PUSH
5212: LD_INT 1
5214: ARRAY
5215: PUSH
5216: LD_VAR 0 1
5220: PUSH
5221: LD_INT 1
5223: ARRAY
5224: DIFF
5225: PPUSH
5226: CALL_OW 1
5230: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5231: LD_VAR 0 1
5235: PUSH
5236: LD_INT 1
5238: ARRAY
5239: PPUSH
5240: CALL_OW 310
5244: IFFALSE 5259
// ComExitBuilding ( sci [ 1 ] ) ;
5246: LD_VAR 0 1
5250: PUSH
5251: LD_INT 1
5253: ARRAY
5254: PPUSH
5255: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5259: LD_INT 2
5261: PPUSH
5262: LD_INT 105
5264: PPUSH
5265: LD_INT 14
5267: PPUSH
5268: LD_INT 20
5270: PPUSH
5271: CALL 21561 0 4
5275: PUSH
5276: LD_INT 4
5278: ARRAY
5279: PUSH
5280: LD_INT 10
5282: LESS
5283: IFFALSE 5306
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5285: LD_VAR 0 1
5289: PUSH
5290: LD_INT 1
5292: ARRAY
5293: PPUSH
5294: LD_INT 105
5296: PPUSH
5297: LD_INT 14
5299: PPUSH
5300: CALL_OW 171
5304: GO 5325
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5306: LD_VAR 0 1
5310: PUSH
5311: LD_INT 1
5313: ARRAY
5314: PPUSH
5315: LD_INT 118
5317: PPUSH
5318: LD_INT 77
5320: PPUSH
5321: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5325: LD_VAR 0 1
5329: PUSH
5330: LD_INT 1
5332: ARRAY
5333: PPUSH
5334: LD_INT 92
5336: PPUSH
5337: LD_INT 40
5339: PPUSH
5340: CALL_OW 218
// end ;
5344: PPOPN 1
5346: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5347: LD_INT 1
5349: PPUSH
5350: CALL_OW 302
5354: PUSH
5355: LD_EXP 9
5359: AND
5360: IFFALSE 5819
5362: GO 5364
5364: DISABLE
5365: LD_INT 0
5367: PPUSH
5368: PPUSH
5369: PPUSH
5370: PPUSH
5371: PPUSH
5372: PPUSH
// begin enable ;
5373: ENABLE
// base := 1 ;
5374: LD_ADDR_VAR 0 2
5378: PUSH
5379: LD_INT 1
5381: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5382: LD_ADDR_VAR 0 4
5386: PUSH
5387: LD_INT 0
5389: PUSH
5390: LD_INT 0
5392: PUSH
5393: LD_INT 0
5395: PUSH
5396: LD_INT 0
5398: PUSH
5399: LD_INT 0
5401: PUSH
5402: LD_INT 0
5404: PUSH
5405: LD_INT 0
5407: PUSH
5408: LD_INT 0
5410: PUSH
5411: LD_INT 1
5413: PUSH
5414: LD_INT 0
5416: PUSH
5417: EMPTY
5418: LIST
5419: LIST
5420: LIST
5421: LIST
5422: LIST
5423: LIST
5424: LIST
5425: LIST
5426: LIST
5427: LIST
5428: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5429: LD_ADDR_VAR 0 3
5433: PUSH
5434: LD_INT 14
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 2
5442: PUSH
5443: LD_INT 26
5445: PUSH
5446: EMPTY
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: PUSH
5452: LD_INT 14
5454: PUSH
5455: LD_INT 1
5457: PUSH
5458: LD_INT 2
5460: PUSH
5461: LD_INT 28
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: LIST
5468: LIST
5469: PUSH
5470: LD_INT 13
5472: PUSH
5473: LD_INT 1
5475: PUSH
5476: LD_INT 2
5478: PUSH
5479: LD_INT 29
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: LIST
5486: LIST
5487: PUSH
5488: EMPTY
5489: LIST
5490: LIST
5491: LIST
5492: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5493: LD_ADDR_VAR 0 1
5497: PUSH
5498: DOUBLE
5499: LD_INT 1
5501: DEC
5502: ST_TO_ADDR
5503: LD_OWVAR 67
5507: PUSH
5508: LD_OWVAR 1
5512: PUSH
5513: LD_INT 21000
5515: DIV
5516: PLUS
5517: PUSH
5518: FOR_TO
5519: IFFALSE 5611
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5521: LD_ADDR_VAR 0 3
5525: PUSH
5526: LD_VAR 0 3
5530: PPUSH
5531: LD_VAR 0 3
5535: PUSH
5536: LD_INT 1
5538: PLUS
5539: PPUSH
5540: LD_INT 13
5542: PUSH
5543: LD_INT 14
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 1
5552: PPUSH
5553: LD_INT 2
5555: PPUSH
5556: CALL_OW 12
5560: ARRAY
5561: PUSH
5562: LD_INT 1
5564: PUSH
5565: LD_INT 2
5567: PUSH
5568: LD_INT 28
5570: PUSH
5571: LD_INT 29
5573: PUSH
5574: LD_INT 25
5576: PUSH
5577: LD_INT 26
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: LIST
5584: LIST
5585: PUSH
5586: LD_INT 1
5588: PPUSH
5589: LD_INT 4
5591: PPUSH
5592: CALL_OW 12
5596: ARRAY
5597: PUSH
5598: EMPTY
5599: LIST
5600: LIST
5601: LIST
5602: LIST
5603: PPUSH
5604: CALL_OW 2
5608: ST_TO_ADDR
5609: GO 5518
5611: POP
5612: POP
// MC_InsertProduceList ( base , tmp ) ;
5613: LD_VAR 0 2
5617: PPUSH
5618: LD_VAR 0 3
5622: PPUSH
5623: CALL 78757 0 2
// repeat wait ( 0 0$1 ) ;
5627: LD_INT 35
5629: PPUSH
5630: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5634: LD_EXP 77
5638: PUSH
5639: LD_VAR 0 2
5643: ARRAY
5644: PUSH
5645: LD_INT 6
5647: GREATER
5648: IFFALSE 5627
// wait ( 0 0$20 ) ;
5650: LD_INT 700
5652: PPUSH
5653: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5657: LD_ADDR_VAR 0 5
5661: PUSH
5662: LD_INT 124
5664: PUSH
5665: LD_INT 85
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: LD_INT 90
5674: PUSH
5675: LD_INT 61
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 69
5684: PUSH
5685: LD_INT 48
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 68
5694: PUSH
5695: LD_INT 48
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5708: LD_ADDR_VAR 0 6
5712: PUSH
5713: LD_EXP 77
5717: PUSH
5718: LD_VAR 0 2
5722: ARRAY
5723: PUSH
5724: LD_EXP 77
5728: PUSH
5729: LD_VAR 0 2
5733: ARRAY
5734: PPUSH
5735: LD_INT 34
5737: PUSH
5738: LD_INT 32
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: PPUSH
5745: CALL_OW 72
5749: DIFF
5750: ST_TO_ADDR
// if not attackers then
5751: LD_VAR 0 6
5755: NOT
5756: IFFALSE 5760
// exit ;
5758: GO 5819
// ar_attackers := attackers ;
5760: LD_ADDR_EXP 10
5764: PUSH
5765: LD_VAR 0 6
5769: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5770: LD_INT 35
5772: PPUSH
5773: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5777: LD_VAR 0 6
5781: PPUSH
5782: LD_INT 60
5784: PUSH
5785: EMPTY
5786: LIST
5787: PPUSH
5788: CALL_OW 72
5792: NOT
5793: IFFALSE 5770
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5795: LD_VAR 0 2
5799: PPUSH
5800: LD_VAR 0 6
5804: PPUSH
5805: LD_VAR 0 5
5809: PPUSH
5810: LD_VAR 0 4
5814: PPUSH
5815: CALL 78942 0 4
// end ;
5819: PPOPN 6
5821: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5822: LD_INT 1
5824: PPUSH
5825: CALL_OW 302
5829: PUSH
5830: LD_EXP 9
5834: AND
5835: PUSH
5836: LD_EXP 48
5840: PPUSH
5841: LD_INT 22
5843: PPUSH
5844: CALL_OW 308
5848: AND
5849: PUSH
5850: LD_INT 1
5852: PPUSH
5853: CALL 79105 0 1
5857: PUSH
5858: LD_INT 0
5860: EQUAL
5861: AND
5862: PUSH
5863: LD_EXP 10
5867: NOT
5868: AND
5869: IFFALSE 6333
5871: GO 5873
5873: DISABLE
5874: LD_INT 0
5876: PPUSH
5877: PPUSH
5878: PPUSH
5879: PPUSH
5880: PPUSH
5881: PPUSH
5882: PPUSH
// begin base := 1 ;
5883: LD_ADDR_VAR 0 2
5887: PUSH
5888: LD_INT 1
5890: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5891: LD_ADDR_VAR 0 4
5895: PUSH
5896: LD_INT 0
5898: PUSH
5899: LD_INT 0
5901: PUSH
5902: LD_INT 0
5904: PUSH
5905: LD_INT 0
5907: PUSH
5908: LD_INT 0
5910: PUSH
5911: LD_INT 0
5913: PUSH
5914: LD_INT 0
5916: PUSH
5917: LD_INT 0
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 0
5925: PUSH
5926: EMPTY
5927: LIST
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5938: LD_ADDR_VAR 0 3
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 28
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: LD_INT 13
5963: PUSH
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 27
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 13
5981: PUSH
5982: LD_INT 1
5984: PUSH
5985: LD_INT 2
5987: PUSH
5988: LD_INT 25
5990: PUSH
5991: EMPTY
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PUSH
5997: LD_INT 11
5999: PUSH
6000: LD_INT 2
6002: PUSH
6003: LD_INT 2
6005: PUSH
6006: LD_INT 24
6008: PUSH
6009: EMPTY
6010: LIST
6011: LIST
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 11
6017: PUSH
6018: LD_INT 2
6020: PUSH
6021: LD_INT 2
6023: PUSH
6024: LD_INT 24
6026: PUSH
6027: EMPTY
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6040: LD_VAR 0 2
6044: PPUSH
6045: LD_VAR 0 3
6049: PPUSH
6050: CALL 78757 0 2
// repeat wait ( 0 0$1 ) ;
6054: LD_INT 35
6056: PPUSH
6057: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6061: LD_EXP 77
6065: PUSH
6066: LD_VAR 0 2
6070: ARRAY
6071: PUSH
6072: LD_INT 6
6074: GREATEREQUAL
6075: IFFALSE 6054
// wait ( 0 0$20 ) ;
6077: LD_INT 700
6079: PPUSH
6080: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6084: LD_ADDR_VAR 0 5
6088: PUSH
6089: LD_INT 119
6091: PUSH
6092: LD_INT 9
6094: PUSH
6095: EMPTY
6096: LIST
6097: LIST
6098: PUSH
6099: EMPTY
6100: LIST
6101: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6102: LD_ADDR_VAR 0 6
6106: PUSH
6107: LD_EXP 77
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_EXP 77
6122: PUSH
6123: LD_VAR 0 2
6127: ARRAY
6128: PPUSH
6129: LD_INT 34
6131: PUSH
6132: LD_INT 32
6134: PUSH
6135: EMPTY
6136: LIST
6137: LIST
6138: PPUSH
6139: CALL_OW 72
6143: DIFF
6144: ST_TO_ADDR
// if not attackers then
6145: LD_VAR 0 6
6149: NOT
6150: IFFALSE 6154
// exit ;
6152: GO 6333
// uc_side := 2 ;
6154: LD_ADDR_OWVAR 20
6158: PUSH
6159: LD_INT 2
6161: ST_TO_ADDR
// uc_nation := 2 ;
6162: LD_ADDR_OWVAR 21
6166: PUSH
6167: LD_INT 2
6169: ST_TO_ADDR
// InitHc ;
6170: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6174: LD_ADDR_VAR 0 1
6178: PUSH
6179: DOUBLE
6180: LD_INT 1
6182: DEC
6183: ST_TO_ADDR
6184: LD_INT 4
6186: PUSH
6187: LD_INT 5
6189: PUSH
6190: LD_INT 6
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: LIST
6197: PUSH
6198: LD_OWVAR 67
6202: ARRAY
6203: PUSH
6204: FOR_TO
6205: IFFALSE 6282
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6207: LD_INT 0
6209: PPUSH
6210: LD_INT 15
6212: PUSH
6213: LD_INT 17
6215: PUSH
6216: EMPTY
6217: LIST
6218: LIST
6219: PUSH
6220: LD_INT 1
6222: PPUSH
6223: LD_INT 2
6225: PPUSH
6226: CALL_OW 12
6230: ARRAY
6231: PPUSH
6232: LD_INT 8
6234: PPUSH
6235: CALL_OW 380
// un := CreateHuman ;
6239: LD_ADDR_VAR 0 7
6243: PUSH
6244: CALL_OW 44
6248: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6249: LD_VAR 0 7
6253: PPUSH
6254: LD_INT 23
6256: PPUSH
6257: LD_INT 0
6259: PPUSH
6260: CALL_OW 49
// attackers := attackers union un ;
6264: LD_ADDR_VAR 0 6
6268: PUSH
6269: LD_VAR 0 6
6273: PUSH
6274: LD_VAR 0 7
6278: UNION
6279: ST_TO_ADDR
// end ;
6280: GO 6204
6282: POP
6283: POP
// repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6291: LD_VAR 0 6
6295: PPUSH
6296: LD_INT 60
6298: PUSH
6299: EMPTY
6300: LIST
6301: PPUSH
6302: CALL_OW 72
6306: NOT
6307: IFFALSE 6284
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6309: LD_VAR 0 2
6313: PPUSH
6314: LD_VAR 0 6
6318: PPUSH
6319: LD_VAR 0 5
6323: PPUSH
6324: LD_VAR 0 4
6328: PPUSH
6329: CALL 78942 0 4
// end ; end_of_file
6333: PPOPN 7
6335: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6336: LD_INT 0
6338: PPUSH
6339: PPUSH
6340: PPUSH
6341: PPUSH
// uc_side := 1 ;
6342: LD_ADDR_OWVAR 20
6346: PUSH
6347: LD_INT 1
6349: ST_TO_ADDR
// uc_nation := 1 ;
6350: LD_ADDR_OWVAR 21
6354: PUSH
6355: LD_INT 1
6357: ST_TO_ADDR
// InitHc ;
6358: CALL_OW 19
// InitVc ;
6362: CALL_OW 20
// tmp := [ ] ;
6366: LD_ADDR_VAR 0 3
6370: PUSH
6371: EMPTY
6372: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6373: LD_ADDR_VAR 0 2
6377: PUSH
6378: DOUBLE
6379: LD_INT 1
6381: DEC
6382: ST_TO_ADDR
6383: LD_INT 5
6385: PUSH
6386: LD_INT 6
6388: PUSH
6389: LD_INT 6
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: LIST
6396: PUSH
6397: LD_OWVAR 67
6401: ARRAY
6402: PUSH
6403: FOR_TO
6404: IFFALSE 6541
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6406: LD_INT 2
6408: PUSH
6409: LD_INT 4
6411: PUSH
6412: LD_INT 5
6414: PUSH
6415: EMPTY
6416: LIST
6417: LIST
6418: LIST
6419: PUSH
6420: LD_INT 1
6422: PPUSH
6423: LD_INT 3
6425: PPUSH
6426: CALL_OW 12
6430: ARRAY
6431: PPUSH
6432: LD_INT 1
6434: PUSH
6435: LD_INT 3
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PUSH
6442: LD_INT 1
6444: PPUSH
6445: LD_INT 2
6447: PPUSH
6448: CALL_OW 12
6452: ARRAY
6453: PPUSH
6454: LD_INT 3
6456: PPUSH
6457: LD_INT 9
6459: PUSH
6460: LD_INT 7
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 2
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 78
6481: PPUSH
6482: CALL 20543 0 5
// veh := CreateVehicle ;
6486: LD_ADDR_VAR 0 4
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6496: LD_VAR 0 4
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6508: LD_VAR 0 4
6512: PPUSH
6513: LD_INT 17
6515: PPUSH
6516: LD_INT 0
6518: PPUSH
6519: CALL_OW 49
// tmp := tmp ^ veh ;
6523: LD_ADDR_VAR 0 3
6527: PUSH
6528: LD_VAR 0 3
6532: PUSH
6533: LD_VAR 0 4
6537: ADD
6538: ST_TO_ADDR
// end ;
6539: GO 6403
6541: POP
6542: POP
// if not tmp then
6543: LD_VAR 0 3
6547: NOT
6548: IFFALSE 6552
// exit ;
6550: GO 6661
// if not first_powell_attack then
6552: LD_EXP 11
6556: NOT
6557: IFFALSE 6567
// first_powell_attack := true ;
6559: LD_ADDR_EXP 11
6563: PUSH
6564: LD_INT 1
6566: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6567: LD_INT 70
6569: PPUSH
6570: CALL_OW 67
// for i in tmp do
6574: LD_ADDR_VAR 0 2
6578: PUSH
6579: LD_VAR 0 3
6583: PUSH
6584: FOR_IN
6585: IFFALSE 6652
// if IsOk ( i ) then
6587: LD_VAR 0 2
6591: PPUSH
6592: CALL_OW 302
6596: IFFALSE 6634
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6598: LD_VAR 0 2
6602: PPUSH
6603: LD_INT 81
6605: PUSH
6606: LD_INT 1
6608: PUSH
6609: EMPTY
6610: LIST
6611: LIST
6612: PPUSH
6613: CALL_OW 69
6617: PPUSH
6618: LD_VAR 0 2
6622: PPUSH
6623: CALL_OW 74
6627: PPUSH
6628: CALL_OW 115
6632: GO 6650
// tmp := tmp diff i ;
6634: LD_ADDR_VAR 0 3
6638: PUSH
6639: LD_VAR 0 3
6643: PUSH
6644: LD_VAR 0 2
6648: DIFF
6649: ST_TO_ADDR
6650: GO 6584
6652: POP
6653: POP
// until not tmp ;
6654: LD_VAR 0 3
6658: NOT
6659: IFFALSE 6567
// end ; end_of_file
6661: LD_VAR 0 1
6665: RET
// export function Action ; var tmp , i , un ; begin
6666: LD_INT 0
6668: PPUSH
6669: PPUSH
6670: PPUSH
6671: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6672: LD_INT 68
6674: PPUSH
6675: LD_INT 39
6677: PPUSH
6678: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6682: LD_ADDR_VAR 0 2
6686: PUSH
6687: LD_INT 22
6689: PUSH
6690: LD_INT 7
6692: PUSH
6693: EMPTY
6694: LIST
6695: LIST
6696: PPUSH
6697: CALL_OW 69
6701: ST_TO_ADDR
// InGameOn ;
6702: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6706: LD_VAR 0 2
6710: PPUSH
6711: LD_INT 71
6713: PPUSH
6714: LD_INT 49
6716: PPUSH
6717: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6721: LD_INT 35
6723: PPUSH
6724: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6728: LD_INT 7
6730: PPUSH
6731: LD_INT 71
6733: PPUSH
6734: LD_INT 51
6736: PPUSH
6737: CALL_OW 293
6741: IFFALSE 6721
// DialogueOn ;
6743: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6747: LD_EXP 14
6751: PPUSH
6752: LD_STRING D1-JMM-1
6754: PPUSH
6755: CALL_OW 88
// if Joan then
6759: LD_EXP 29
6763: IFFALSE 6777
// Say ( Joan , D1-Joan-1 ) ;
6765: LD_EXP 29
6769: PPUSH
6770: LD_STRING D1-Joan-1
6772: PPUSH
6773: CALL_OW 88
// if Lisa then
6777: LD_EXP 16
6781: IFFALSE 6795
// Say ( Lisa , D1-Lisa-1 ) ;
6783: LD_EXP 16
6787: PPUSH
6788: LD_STRING D1-Lisa-1
6790: PPUSH
6791: CALL_OW 88
// if Joan or Lisa then
6795: LD_EXP 29
6799: PUSH
6800: LD_EXP 16
6804: OR
6805: IFFALSE 6819
// Say ( JMM , D1-JMM-2 ) ;
6807: LD_EXP 14
6811: PPUSH
6812: LD_STRING D1-JMM-2
6814: PPUSH
6815: CALL_OW 88
// DialogueOff ;
6819: CALL_OW 7
// InGameOff ;
6823: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6827: LD_INT 71
6829: PPUSH
6830: LD_INT 50
6832: PPUSH
6833: LD_INT 7
6835: PPUSH
6836: LD_INT 30
6838: NEG
6839: PPUSH
6840: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6844: LD_INT 71
6846: PPUSH
6847: LD_INT 50
6849: PPUSH
6850: LD_INT 7
6852: PPUSH
6853: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6857: LD_STRING M1
6859: PPUSH
6860: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6864: LD_INT 35
6866: PPUSH
6867: CALL_OW 67
// until freedom ;
6871: LD_EXP 3
6875: IFFALSE 6864
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6877: LD_INT 350
6879: PPUSH
6880: LD_INT 700
6882: PPUSH
6883: CALL_OW 12
6887: PPUSH
6888: CALL_OW 67
// PrepareGossudarov ;
6892: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6896: LD_INT 35
6898: PPUSH
6899: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6903: LD_INT 22
6905: PUSH
6906: LD_INT 6
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PUSH
6913: LD_INT 3
6915: PUSH
6916: LD_INT 24
6918: PUSH
6919: LD_INT 1000
6921: PUSH
6922: EMPTY
6923: LIST
6924: LIST
6925: PUSH
6926: EMPTY
6927: LIST
6928: LIST
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: PPUSH
6934: CALL_OW 69
6938: PUSH
6939: LD_INT 7
6941: PPUSH
6942: LD_EXP 31
6946: PPUSH
6947: CALL_OW 292
6951: OR
6952: IFFALSE 6896
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6954: LD_ADDR_VAR 0 2
6958: PUSH
6959: LD_INT 22
6961: PUSH
6962: LD_INT 6
6964: PUSH
6965: EMPTY
6966: LIST
6967: LIST
6968: PPUSH
6969: CALL_OW 69
6973: ST_TO_ADDR
// for i in tmp do
6974: LD_ADDR_VAR 0 3
6978: PUSH
6979: LD_VAR 0 2
6983: PUSH
6984: FOR_IN
6985: IFFALSE 7001
// SetSide ( i , 7 ) ;
6987: LD_VAR 0 3
6991: PPUSH
6992: LD_INT 7
6994: PPUSH
6995: CALL_OW 235
6999: GO 6984
7001: POP
7002: POP
// DialogueOn ;
7003: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7007: LD_EXP 14
7011: PUSH
7012: LD_EXP 15
7016: PUSH
7017: EMPTY
7018: LIST
7019: LIST
7020: PPUSH
7021: LD_EXP 31
7025: PPUSH
7026: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7030: LD_EXP 31
7034: PPUSH
7035: CALL_OW 87
// if not Roth then
7039: LD_EXP 15
7043: NOT
7044: IFFALSE 7136
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7046: LD_VAR 0 2
7050: PPUSH
7051: LD_INT 3
7053: PUSH
7054: LD_INT 24
7056: PUSH
7057: LD_INT 1000
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: PPUSH
7068: CALL_OW 72
7072: IFFALSE 7086
// Say ( JMM , D2-JMM-1 ) ;
7074: LD_EXP 14
7078: PPUSH
7079: LD_STRING D2-JMM-1
7081: PPUSH
7082: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7086: LD_EXP 14
7090: PPUSH
7091: LD_STRING D2-JMM-1b
7093: PPUSH
7094: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7098: LD_EXP 31
7102: PPUSH
7103: LD_STRING D2-Gos-1
7105: PPUSH
7106: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7110: LD_EXP 14
7114: PPUSH
7115: LD_STRING D2-JMM-2
7117: PPUSH
7118: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7122: LD_EXP 31
7126: PPUSH
7127: LD_STRING D2-Gos-2
7129: PPUSH
7130: CALL_OW 88
// end else
7134: GO 7288
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7136: LD_VAR 0 2
7140: PPUSH
7141: LD_INT 3
7143: PUSH
7144: LD_INT 24
7146: PUSH
7147: LD_INT 1000
7149: PUSH
7150: EMPTY
7151: LIST
7152: LIST
7153: PUSH
7154: EMPTY
7155: LIST
7156: LIST
7157: PPUSH
7158: CALL_OW 72
7162: IFFALSE 7188
// begin Say ( Roth , D2-Roth-2 ) ;
7164: LD_EXP 15
7168: PPUSH
7169: LD_STRING D2-Roth-2
7171: PPUSH
7172: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7176: LD_EXP 14
7180: PPUSH
7181: LD_STRING D2-JMM-1a
7183: PPUSH
7184: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7188: LD_EXP 15
7192: PPUSH
7193: LD_STRING D2-Roth-2a
7195: PPUSH
7196: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7200: LD_EXP 15
7204: PPUSH
7205: LD_STRING D2-Roth-2b
7207: PPUSH
7208: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7212: LD_EXP 14
7216: PPUSH
7217: LD_STRING D2-JMM-3
7219: PPUSH
7220: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7224: LD_VAR 0 2
7228: PPUSH
7229: LD_INT 3
7231: PUSH
7232: LD_INT 24
7234: PUSH
7235: LD_INT 1000
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: PUSH
7242: EMPTY
7243: LIST
7244: LIST
7245: PPUSH
7246: CALL_OW 72
7250: IFFALSE 7288
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7252: LD_EXP 31
7256: PPUSH
7257: LD_STRING D2-Gos-3
7259: PPUSH
7260: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7264: LD_EXP 14
7268: PPUSH
7269: LD_STRING D2-JMM-4
7271: PPUSH
7272: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7276: LD_EXP 31
7280: PPUSH
7281: LD_STRING D2-Gos-4
7283: PPUSH
7284: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7288: LD_EXP 14
7292: PPUSH
7293: LD_STRING D2-JMM-5
7295: PPUSH
7296: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7300: LD_EXP 31
7304: PPUSH
7305: LD_STRING D2-Gos-5
7307: PPUSH
7308: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7312: LD_EXP 14
7316: PPUSH
7317: LD_STRING D2-JMM-6
7319: PPUSH
7320: CALL_OW 88
// DialogueOff ;
7324: CALL_OW 7
// wait ( 0 0$2 ) ;
7328: LD_INT 70
7330: PPUSH
7331: CALL_OW 67
// if Kirilenkova then
7335: LD_EXP 32
7339: IFFALSE 7353
// Say ( Kirilenkova , D3-Kir-1 ) ;
7341: LD_EXP 32
7345: PPUSH
7346: LD_STRING D3-Kir-1
7348: PPUSH
7349: CALL_OW 88
// gossudarov_arrive := true ;
7353: LD_ADDR_EXP 4
7357: PUSH
7358: LD_INT 1
7360: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7361: LD_STRING CombinedForces
7363: PPUSH
7364: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7368: LD_INT 35
7370: PPUSH
7371: CALL_OW 67
// until ru_lab_builded ;
7375: LD_EXP 5
7379: IFFALSE 7368
// if Kirilenkova then
7381: LD_EXP 32
7385: IFFALSE 7401
// Say ( Kirilenkova , D3a-Kir-1 ) else
7387: LD_EXP 32
7391: PPUSH
7392: LD_STRING D3a-Kir-1
7394: PPUSH
7395: CALL_OW 88
7399: GO 7423
// begin un := SciRu ;
7401: LD_ADDR_VAR 0 4
7405: PUSH
7406: CALL 12393 0 0
7410: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7411: LD_VAR 0 4
7415: PPUSH
7416: LD_STRING D3a-Sci1-1
7418: PPUSH
7419: CALL_OW 88
// end ; if Kirilenkova or un then
7423: LD_EXP 32
7427: PUSH
7428: LD_VAR 0 4
7432: OR
7433: IFFALSE 7447
// Say ( JMM , D3a-JMM-1 ) ;
7435: LD_EXP 14
7439: PPUSH
7440: LD_STRING D3a-JMM-1
7442: PPUSH
7443: CALL_OW 88
// end ;
7447: LD_VAR 0 1
7451: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7452: LD_EXP 4
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_INT 7
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: PUSH
7467: LD_INT 2
7469: PUSH
7470: LD_INT 25
7472: PUSH
7473: LD_INT 1
7475: PUSH
7476: EMPTY
7477: LIST
7478: LIST
7479: PUSH
7480: LD_INT 25
7482: PUSH
7483: LD_INT 2
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PUSH
7490: LD_INT 25
7492: PUSH
7493: LD_INT 3
7495: PUSH
7496: EMPTY
7497: LIST
7498: LIST
7499: PUSH
7500: LD_INT 25
7502: PUSH
7503: LD_INT 4
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 25
7512: PUSH
7513: LD_INT 5
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 25
7522: PUSH
7523: LD_INT 8
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 25
7532: PUSH
7533: LD_INT 9
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: LIST
7546: LIST
7547: LIST
7548: LIST
7549: PUSH
7550: EMPTY
7551: LIST
7552: LIST
7553: PPUSH
7554: CALL_OW 69
7558: PUSH
7559: LD_INT 7
7561: LESS
7562: AND
7563: IFFALSE 7575
7565: GO 7567
7567: DISABLE
// YouLost ( TooMany ) ;
7568: LD_STRING TooMany
7570: PPUSH
7571: CALL_OW 104
7575: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7576: LD_EXP 31
7580: PPUSH
7581: CALL_OW 255
7585: PUSH
7586: LD_INT 7
7588: EQUAL
7589: IFFALSE 7789
7591: GO 7593
7593: DISABLE
7594: LD_INT 0
7596: PPUSH
7597: PPUSH
7598: PPUSH
// begin uc_side := 3 ;
7599: LD_ADDR_OWVAR 20
7603: PUSH
7604: LD_INT 3
7606: ST_TO_ADDR
// uc_nation := 3 ;
7607: LD_ADDR_OWVAR 21
7611: PUSH
7612: LD_INT 3
7614: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7615: LD_INT 21
7617: PPUSH
7618: LD_INT 3
7620: PPUSH
7621: LD_INT 3
7623: PPUSH
7624: LD_INT 42
7626: PPUSH
7627: LD_INT 100
7629: PPUSH
7630: CALL 20543 0 5
// un := CreateVehicle ;
7634: LD_ADDR_VAR 0 3
7638: PUSH
7639: CALL_OW 45
7643: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7644: LD_VAR 0 3
7648: PPUSH
7649: LD_INT 15
7651: PPUSH
7652: LD_INT 0
7654: PPUSH
7655: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7659: LD_VAR 0 3
7663: PPUSH
7664: LD_INT 67
7666: PPUSH
7667: LD_INT 45
7669: PPUSH
7670: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7674: LD_VAR 0 3
7678: PPUSH
7679: LD_INT 70
7681: PPUSH
7682: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7686: LD_VAR 0 3
7690: PPUSH
7691: LD_INT 69
7693: PPUSH
7694: LD_INT 18
7696: PPUSH
7697: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7701: LD_VAR 0 3
7705: PPUSH
7706: LD_INT 60
7708: PPUSH
7709: LD_INT 2
7711: PPUSH
7712: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7716: LD_INT 35
7718: PPUSH
7719: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7723: LD_VAR 0 3
7727: PPUSH
7728: CALL_OW 302
7732: NOT
7733: PUSH
7734: LD_VAR 0 3
7738: PPUSH
7739: LD_INT 17
7741: PPUSH
7742: CALL_OW 308
7746: OR
7747: IFFALSE 7716
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7749: LD_VAR 0 3
7753: PPUSH
7754: LD_INT 17
7756: PPUSH
7757: CALL_OW 308
7761: PUSH
7762: LD_VAR 0 3
7766: PPUSH
7767: LD_INT 60
7769: PPUSH
7770: LD_INT 2
7772: PPUSH
7773: CALL_OW 307
7777: OR
7778: IFFALSE 7789
// RemoveUnit ( un ) ;
7780: LD_VAR 0 3
7784: PPUSH
7785: CALL_OW 64
// end ;
7789: PPOPN 3
7791: END
// every 0 0$2 do var i , un , tmp ;
7792: GO 7794
7794: DISABLE
7795: LD_INT 0
7797: PPUSH
7798: PPUSH
7799: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7800: LD_INT 70
7802: PPUSH
7803: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7807: LD_ADDR_VAR 0 3
7811: PUSH
7812: LD_INT 22
7814: PUSH
7815: LD_INT 7
7817: PUSH
7818: EMPTY
7819: LIST
7820: LIST
7821: PUSH
7822: LD_INT 101
7824: PUSH
7825: LD_INT 3
7827: PUSH
7828: EMPTY
7829: LIST
7830: LIST
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: PPUSH
7836: CALL_OW 69
7840: ST_TO_ADDR
// until tmp ;
7841: LD_VAR 0 3
7845: IFFALSE 7800
// un := NearestUnitToUnit ( tmp , JMM ) ;
7847: LD_ADDR_VAR 0 2
7851: PUSH
7852: LD_VAR 0 3
7856: PPUSH
7857: LD_EXP 14
7861: PPUSH
7862: CALL_OW 74
7866: ST_TO_ADDR
// player_spotted := true ;
7867: LD_ADDR_EXP 6
7871: PUSH
7872: LD_INT 1
7874: ST_TO_ADDR
// tmp := SciRu ;
7875: LD_ADDR_VAR 0 3
7879: PUSH
7880: CALL 12393 0 0
7884: ST_TO_ADDR
// if not tmp then
7885: LD_VAR 0 3
7889: NOT
7890: IFFALSE 7902
// tmp := SolRu ;
7892: LD_ADDR_VAR 0 3
7896: PUSH
7897: CALL 12540 0 0
7901: ST_TO_ADDR
// DialogueOn ;
7902: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7906: LD_VAR 0 2
7910: PPUSH
7911: CALL_OW 250
7915: PPUSH
7916: LD_VAR 0 2
7920: PPUSH
7921: CALL_OW 251
7925: PPUSH
7926: LD_INT 7
7928: PPUSH
7929: LD_INT 8
7931: NEG
7932: PPUSH
7933: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7937: LD_VAR 0 2
7941: PPUSH
7942: CALL_OW 87
// if tmp then
7946: LD_VAR 0 3
7950: IFFALSE 7964
// Say ( tmp , D4-RSci1-1 ) ;
7952: LD_VAR 0 3
7956: PPUSH
7957: LD_STRING D4-RSci1-1
7959: PPUSH
7960: CALL_OW 88
// if Gossudarov then
7964: LD_EXP 31
7968: IFFALSE 7994
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7970: LD_EXP 31
7974: PPUSH
7975: LD_STRING D4-Gos-1
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7982: LD_EXP 14
7986: PPUSH
7987: LD_STRING D4-JMM-1
7989: PPUSH
7990: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7994: LD_VAR 0 2
7998: PPUSH
7999: CALL_OW 250
8003: PPUSH
8004: LD_VAR 0 2
8008: PPUSH
8009: CALL_OW 251
8013: PPUSH
8014: LD_INT 7
8016: PPUSH
8017: CALL_OW 331
// DialogueOff ;
8021: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8025: LD_STRING M5
8027: PPUSH
8028: CALL_OW 337
// end ;
8032: PPOPN 3
8034: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8035: LD_EXP 6
8039: IFFALSE 8628
8041: GO 8043
8043: DISABLE
8044: LD_INT 0
8046: PPUSH
8047: PPUSH
8048: PPUSH
// begin PrepareBelkov ;
8049: CALL 1974 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8053: LD_EXP 46
8057: PPUSH
8058: LD_INT 118
8060: PPUSH
8061: LD_INT 106
8063: PPUSH
8064: CALL_OW 111
// AddComHold ( Belkov ) ;
8068: LD_EXP 46
8072: PPUSH
8073: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8077: LD_INT 35
8079: PPUSH
8080: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8084: LD_EXP 46
8088: PPUSH
8089: LD_INT 118
8091: PPUSH
8092: LD_INT 106
8094: PPUSH
8095: CALL_OW 307
8099: IFFALSE 8077
// ChangeSideFog ( 4 , 7 ) ;
8101: LD_INT 4
8103: PPUSH
8104: LD_INT 7
8106: PPUSH
8107: CALL_OW 343
// if IsOk ( Belkov ) then
8111: LD_EXP 46
8115: PPUSH
8116: CALL_OW 302
8120: IFFALSE 8204
// begin InGameOn ;
8122: CALL_OW 8
// DialogueOn ;
8126: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8130: LD_EXP 46
8134: PPUSH
8135: LD_STRING D5-Bel-1
8137: PPUSH
8138: CALL_OW 94
// if Gossudarov then
8142: LD_EXP 31
8146: IFFALSE 8196
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8148: LD_EXP 31
8152: PPUSH
8153: LD_STRING D5-Gos-1
8155: PPUSH
8156: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8160: LD_EXP 14
8164: PPUSH
8165: LD_STRING D5-JMM-1
8167: PPUSH
8168: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8172: LD_EXP 31
8176: PPUSH
8177: LD_STRING D5-Gos-2
8179: PPUSH
8180: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8184: LD_EXP 14
8188: PPUSH
8189: LD_STRING D5-JMM-2
8191: PPUSH
8192: CALL_OW 88
// end ; DialogueOff ;
8196: CALL_OW 7
// InGameOff ;
8200: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8204: LD_STRING QSaveBelkov
8206: PPUSH
8207: CALL_OW 97
8211: PUSH
8212: LD_INT 1
8214: DOUBLE
8215: EQUAL
8216: IFTRUE 8220
8218: GO 8270
8220: POP
// begin DialogueOn ;
8221: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8225: LD_EXP 14
8229: PPUSH
8230: LD_STRING D5a-JMM-1
8232: PPUSH
8233: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8237: LD_EXP 46
8241: PPUSH
8242: LD_STRING D5a-Bel-1
8244: PPUSH
8245: CALL_OW 94
// DialogueOff ;
8249: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8253: LD_EXP 46
8257: PPUSH
8258: LD_INT 83
8260: PPUSH
8261: LD_INT 49
8263: PPUSH
8264: CALL_OW 111
// end ; 2 :
8268: GO 8303
8270: LD_INT 2
8272: DOUBLE
8273: EQUAL
8274: IFTRUE 8278
8276: GO 8302
8278: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8279: LD_EXP 14
8283: PPUSH
8284: LD_STRING D5a-JMM-2
8286: PPUSH
8287: CALL_OW 88
// ComHold ( Belkov ) ;
8291: LD_EXP 46
8295: PPUSH
8296: CALL_OW 140
// end ; end ;
8300: GO 8303
8302: POP
// time := 0 0$00 ;
8303: LD_ADDR_VAR 0 1
8307: PUSH
8308: LD_INT 0
8310: ST_TO_ADDR
// vehSpawned := false ;
8311: LD_ADDR_VAR 0 3
8315: PUSH
8316: LD_INT 0
8318: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8319: LD_INT 35
8321: PPUSH
8322: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8326: LD_VAR 0 1
8330: PUSH
8331: LD_INT 350
8333: PUSH
8334: LD_INT 175
8336: PUSH
8337: LD_INT 70
8339: PUSH
8340: EMPTY
8341: LIST
8342: LIST
8343: LIST
8344: PUSH
8345: LD_OWVAR 67
8349: ARRAY
8350: GREATEREQUAL
8351: PUSH
8352: LD_VAR 0 3
8356: NOT
8357: AND
8358: IFFALSE 8448
// begin vehSpawned := true ;
8360: LD_ADDR_VAR 0 3
8364: PUSH
8365: LD_INT 1
8367: ST_TO_ADDR
// uc_side := 3 ;
8368: LD_ADDR_OWVAR 20
8372: PUSH
8373: LD_INT 3
8375: ST_TO_ADDR
// uc_nation := 3 ;
8376: LD_ADDR_OWVAR 21
8380: PUSH
8381: LD_INT 3
8383: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8384: LD_INT 22
8386: PPUSH
8387: LD_INT 3
8389: PPUSH
8390: LD_INT 3
8392: PPUSH
8393: LD_INT 43
8395: PPUSH
8396: LD_INT 100
8398: PPUSH
8399: CALL 20543 0 5
// veh := CreateVehicle ;
8403: LD_ADDR_VAR 0 2
8407: PUSH
8408: CALL_OW 45
8412: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8413: LD_VAR 0 2
8417: PPUSH
8418: LD_INT 130
8420: PPUSH
8421: LD_INT 131
8423: PPUSH
8424: LD_INT 0
8426: PPUSH
8427: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8431: LD_VAR 0 2
8435: PPUSH
8436: LD_INT 100
8438: PPUSH
8439: LD_INT 82
8441: PPUSH
8442: CALL_OW 114
// end else
8446: GO 8462
// time := time + 0 0$1 ;
8448: LD_ADDR_VAR 0 1
8452: PUSH
8453: LD_VAR 0 1
8457: PUSH
8458: LD_INT 35
8460: PLUS
8461: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8462: LD_EXP 46
8466: PPUSH
8467: CALL_OW 301
8471: PUSH
8472: LD_EXP 46
8476: PPUSH
8477: CALL_OW 255
8481: PUSH
8482: LD_INT 4
8484: EQUAL
8485: AND
8486: PUSH
8487: LD_INT 22
8489: PUSH
8490: LD_INT 7
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PPUSH
8497: CALL_OW 69
8501: PPUSH
8502: LD_EXP 46
8506: PPUSH
8507: CALL_OW 74
8511: PPUSH
8512: LD_EXP 46
8516: PPUSH
8517: CALL_OW 296
8521: PUSH
8522: LD_INT 10
8524: LESS
8525: OR
8526: IFFALSE 8319
// if IsDead ( Belkov ) then
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 301
8537: IFFALSE 8562
// begin CenterNowOnUnits ( Belkov ) ;
8539: LD_EXP 46
8543: PPUSH
8544: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8548: LD_EXP 14
8552: PPUSH
8553: LD_STRING D5a-JMM-2a
8555: PPUSH
8556: CALL_OW 88
// exit ;
8560: GO 8628
// end ; if See ( 7 , Belkov ) then
8562: LD_INT 7
8564: PPUSH
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 292
8574: IFFALSE 8588
// SetSide ( Belkov , 7 ) ;
8576: LD_EXP 46
8580: PPUSH
8581: LD_INT 7
8583: PPUSH
8584: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8588: LD_INT 35
8590: PPUSH
8591: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8595: LD_EXP 46
8599: PPUSH
8600: LD_INT 66
8602: PPUSH
8603: LD_INT 45
8605: PPUSH
8606: CALL_OW 297
8610: PUSH
8611: LD_INT 30
8613: LESS
8614: IFFALSE 8588
// Say ( Belkov , D6-Bel-1 ) ;
8616: LD_EXP 46
8620: PPUSH
8621: LD_STRING D6-Bel-1
8623: PPUSH
8624: CALL_OW 88
// end ;
8628: PPOPN 3
8630: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8631: LD_EXP 46
8635: PPUSH
8636: CALL_OW 302
8640: PUSH
8641: LD_EXP 46
8645: PPUSH
8646: CALL_OW 504
8650: PUSH
8651: LD_INT 2
8653: PUSH
8654: LD_INT 34
8656: PUSH
8657: LD_INT 47
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: PUSH
8664: LD_INT 34
8666: PUSH
8667: LD_INT 45
8669: PUSH
8670: EMPTY
8671: LIST
8672: LIST
8673: PUSH
8674: EMPTY
8675: LIST
8676: LIST
8677: LIST
8678: PPUSH
8679: CALL_OW 69
8683: IN
8684: AND
8685: IFFALSE 8702
8687: GO 8689
8689: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8690: LD_EXP 46
8694: PPUSH
8695: LD_STRING D7-Bel-1
8697: PPUSH
8698: CALL_OW 88
8702: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8703: LD_INT 22
8705: PUSH
8706: LD_INT 7
8708: PUSH
8709: EMPTY
8710: LIST
8711: LIST
8712: PUSH
8713: LD_INT 101
8715: PUSH
8716: LD_INT 2
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PUSH
8723: EMPTY
8724: LIST
8725: LIST
8726: PPUSH
8727: CALL_OW 69
8731: PUSH
8732: LD_EXP 8
8736: NOT
8737: AND
8738: PUSH
8739: LD_EXP 45
8743: PPUSH
8744: CALL_OW 305
8748: NOT
8749: AND
8750: IFFALSE 9220
8752: GO 8754
8754: DISABLE
8755: LD_INT 0
8757: PPUSH
// begin ar_base_spotted := true ;
8758: LD_ADDR_EXP 8
8762: PUSH
8763: LD_INT 1
8765: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8766: LD_ADDR_VAR 0 1
8770: PUSH
8771: LD_INT 22
8773: PUSH
8774: LD_INT 2
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 21
8783: PUSH
8784: LD_INT 3
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: EMPTY
8792: LIST
8793: LIST
8794: PPUSH
8795: CALL_OW 69
8799: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8800: LD_ADDR_VAR 0 1
8804: PUSH
8805: LD_VAR 0 1
8809: PPUSH
8810: LD_EXP 14
8814: PPUSH
8815: CALL_OW 74
8819: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8820: LD_INT 7
8822: PPUSH
8823: LD_INT 3
8825: PPUSH
8826: CALL_OW 332
// DialogueOn ;
8830: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8834: LD_VAR 0 1
8838: PPUSH
8839: CALL_OW 250
8843: PPUSH
8844: LD_VAR 0 1
8848: PPUSH
8849: CALL_OW 251
8853: PPUSH
8854: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8858: LD_ADDR_VAR 0 1
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 7
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 23
8875: PUSH
8876: LD_INT 1
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: LD_INT 26
8885: PUSH
8886: LD_INT 1
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: PPUSH
8898: CALL_OW 69
8902: PUSH
8903: LD_EXP 14
8907: PUSH
8908: LD_EXP 18
8912: PUSH
8913: LD_EXP 19
8917: PUSH
8918: LD_EXP 26
8922: PUSH
8923: LD_EXP 15
8927: PUSH
8928: LD_EXP 24
8932: PUSH
8933: LD_EXP 20
8937: PUSH
8938: LD_EXP 22
8942: PUSH
8943: EMPTY
8944: LIST
8945: LIST
8946: LIST
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: DIFF
8953: ST_TO_ADDR
// if not tmp then
8954: LD_VAR 0 1
8958: NOT
8959: IFFALSE 9033
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8961: LD_ADDR_VAR 0 1
8965: PUSH
8966: LD_INT 22
8968: PUSH
8969: LD_INT 7
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: PUSH
8976: LD_INT 23
8978: PUSH
8979: LD_INT 1
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: LD_INT 26
8988: PUSH
8989: LD_INT 2
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: LIST
9000: PPUSH
9001: CALL_OW 69
9005: PUSH
9006: LD_EXP 29
9010: PUSH
9011: LD_EXP 16
9015: PUSH
9016: LD_EXP 27
9020: PUSH
9021: LD_EXP 28
9025: PUSH
9026: EMPTY
9027: LIST
9028: LIST
9029: LIST
9030: LIST
9031: DIFF
9032: ST_TO_ADDR
// if tmp then
9033: LD_VAR 0 1
9037: IFFALSE 9108
// case GetSex ( tmp [ 1 ] ) of sex_male :
9039: LD_VAR 0 1
9043: PUSH
9044: LD_INT 1
9046: ARRAY
9047: PPUSH
9048: CALL_OW 258
9052: PUSH
9053: LD_INT 1
9055: DOUBLE
9056: EQUAL
9057: IFTRUE 9061
9059: GO 9080
9061: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9062: LD_VAR 0 1
9066: PUSH
9067: LD_INT 1
9069: ARRAY
9070: PPUSH
9071: LD_STRING D9-Sol1-1
9073: PPUSH
9074: CALL_OW 88
9078: GO 9108
9080: LD_INT 2
9082: DOUBLE
9083: EQUAL
9084: IFTRUE 9088
9086: GO 9107
9088: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9089: LD_VAR 0 1
9093: PUSH
9094: LD_INT 1
9096: ARRAY
9097: PPUSH
9098: LD_STRING D9-FSol1-1
9100: PPUSH
9101: CALL_OW 88
9105: GO 9108
9107: POP
// if Frank then
9108: LD_EXP 26
9112: IFFALSE 9216
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9114: LD_EXP 55
9118: PPUSH
9119: CALL_OW 250
9123: PPUSH
9124: LD_EXP 55
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: LD_INT 7
9136: PPUSH
9137: LD_INT 8
9139: PPUSH
9140: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9144: LD_EXP 55
9148: PPUSH
9149: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9153: LD_EXP 26
9157: PPUSH
9158: LD_STRING D9-Frank-1
9160: PPUSH
9161: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9165: LD_EXP 14
9169: PPUSH
9170: LD_STRING D9-JMM-1
9172: PPUSH
9173: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9177: LD_EXP 26
9181: PPUSH
9182: LD_STRING D9-Frank-2
9184: PPUSH
9185: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9189: LD_EXP 55
9193: PPUSH
9194: CALL_OW 250
9198: PPUSH
9199: LD_EXP 55
9203: PPUSH
9204: CALL_OW 251
9208: PPUSH
9209: LD_INT 7
9211: PPUSH
9212: CALL_OW 331
// end ; DialogueOff ;
9216: CALL_OW 7
// end ;
9220: PPOPN 1
9222: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9223: LD_EXP 7
9227: PUSH
9228: LD_OWVAR 1
9232: PUSH
9233: LD_INT 42000
9235: GREATEREQUAL
9236: OR
9237: IFFALSE 10264
9239: GO 9241
9241: DISABLE
9242: LD_INT 0
9244: PPUSH
9245: PPUSH
// begin selected_option := 1 ;
9246: LD_ADDR_VAR 0 2
9250: PUSH
9251: LD_INT 1
9253: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9254: LD_INT 10500
9256: PPUSH
9257: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9261: LD_INT 35
9263: PPUSH
9264: CALL_OW 67
// until not ru_attackers ;
9268: LD_EXP 51
9272: NOT
9273: IFFALSE 9261
// PrepareBurlak ;
9275: CALL 2086 0 0
// repeat wait ( 0 0$2 ) ;
9279: LD_INT 70
9281: PPUSH
9282: CALL_OW 67
// until not HasTask ( Burlak ) ;
9286: LD_EXP 45
9290: PPUSH
9291: CALL_OW 314
9295: NOT
9296: IFFALSE 9279
// InGameOn ;
9298: CALL_OW 8
// DialogueOn ;
9302: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9306: LD_EXP 48
9310: PPUSH
9311: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9315: LD_EXP 45
9319: PPUSH
9320: LD_STRING D10-Bur-1
9322: PPUSH
9323: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9327: LD_EXP 46
9331: PUSH
9332: LD_EXP 46
9336: PPUSH
9337: CALL_OW 255
9341: PUSH
9342: LD_INT 7
9344: EQUAL
9345: AND
9346: IFFALSE 9360
// Say ( Belkov , D10-Bel-1 ) ;
9348: LD_EXP 46
9352: PPUSH
9353: LD_STRING D10-Bel-1
9355: PPUSH
9356: CALL_OW 88
// if Gossudarov then
9360: LD_EXP 31
9364: IFFALSE 9378
// Say ( Gossudarov , D10-Gos-1 ) ;
9366: LD_EXP 31
9370: PPUSH
9371: LD_STRING D10-Gos-1
9373: PPUSH
9374: CALL_OW 88
// if Kirilenkova then
9378: LD_EXP 32
9382: IFFALSE 9396
// Say ( Kirilenkova , D10-Kir-1 ) ;
9384: LD_EXP 32
9388: PPUSH
9389: LD_STRING D10-Kir-1
9391: PPUSH
9392: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9396: CALL 12540 0 0
9400: PPUSH
9401: LD_STRING D10-RSol1-1
9403: PPUSH
9404: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9408: LD_EXP 45
9412: PPUSH
9413: LD_STRING D10-Bur-2
9415: PPUSH
9416: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9420: LD_EXP 14
9424: PPUSH
9425: LD_STRING D10-JMM-2
9427: PPUSH
9428: CALL_OW 88
// if Kirilenkova then
9432: LD_EXP 32
9436: IFFALSE 9452
// Say ( Kirilenkova , D10-Kir-2 ) else
9438: LD_EXP 32
9442: PPUSH
9443: LD_STRING D10-Kir-2
9445: PPUSH
9446: CALL_OW 88
9450: GO 9464
// Say ( SolRu , D10-RSol1-2 ) ;
9452: CALL 12540 0 0
9456: PPUSH
9457: LD_STRING D10-RSol1-2
9459: PPUSH
9460: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9464: LD_EXP 14
9468: PPUSH
9469: LD_STRING D10-JMM-3
9471: PPUSH
9472: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9476: LD_EXP 45
9480: PPUSH
9481: LD_STRING D10-Bur-3
9483: PPUSH
9484: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9488: LD_EXP 14
9492: PPUSH
9493: LD_STRING D10-JMM-4
9495: PPUSH
9496: CALL_OW 88
// DialogueOff ;
9500: CALL_OW 7
// InGameOff ;
9504: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9508: LD_STRING M2
9510: PPUSH
9511: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9515: LD_INT 35
9517: PPUSH
9518: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9522: LD_INT 22
9524: PUSH
9525: LD_INT 7
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: PUSH
9532: LD_INT 91
9534: PUSH
9535: LD_EXP 45
9539: PUSH
9540: LD_INT 8
9542: PUSH
9543: EMPTY
9544: LIST
9545: LIST
9546: LIST
9547: PUSH
9548: EMPTY
9549: LIST
9550: LIST
9551: PPUSH
9552: CALL_OW 69
9556: IFFALSE 9515
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9558: LD_ADDR_VAR 0 1
9562: PUSH
9563: LD_INT 22
9565: PUSH
9566: LD_INT 4
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PPUSH
9573: CALL_OW 69
9577: PUSH
9578: FOR_IN
9579: IFFALSE 9595
// SetSide ( i , 7 ) ;
9581: LD_VAR 0 1
9585: PPUSH
9586: LD_INT 7
9588: PPUSH
9589: CALL_OW 235
9593: GO 9578
9595: POP
9596: POP
// ChangeMissionObjectives ( M3 ) ;
9597: LD_STRING M3
9599: PPUSH
9600: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9604: LD_INT 35
9606: PPUSH
9607: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9611: LD_EXP 14
9615: PPUSH
9616: LD_EXP 45
9620: PPUSH
9621: CALL_OW 296
9625: PUSH
9626: LD_INT 8
9628: LESS
9629: IFFALSE 9604
// ComTurnUnit ( JMM , Burlak ) ;
9631: LD_EXP 14
9635: PPUSH
9636: LD_EXP 45
9640: PPUSH
9641: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9645: LD_EXP 45
9649: PPUSH
9650: LD_EXP 14
9654: PPUSH
9655: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9659: LD_INT 10
9661: PPUSH
9662: CALL_OW 67
// DialogueOn ;
9666: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9670: LD_EXP 14
9674: PPUSH
9675: LD_STRING D11-JMM-1
9677: PPUSH
9678: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9682: LD_EXP 45
9686: PPUSH
9687: LD_STRING D11-Bur-1
9689: PPUSH
9690: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9694: LD_EXP 14
9698: PPUSH
9699: LD_STRING D11-JMM-2
9701: PPUSH
9702: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9706: LD_EXP 45
9710: PPUSH
9711: LD_STRING D11-Bur-2
9713: PPUSH
9714: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9718: LD_EXP 14
9722: PPUSH
9723: LD_STRING D11-JMM-3
9725: PPUSH
9726: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9730: LD_EXP 45
9734: PPUSH
9735: LD_STRING D11-Bur-3
9737: PPUSH
9738: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9742: LD_EXP 14
9746: PPUSH
9747: LD_STRING D11-JMM-4
9749: PPUSH
9750: CALL_OW 88
// if ar_base_spotted then
9754: LD_EXP 8
9758: IFFALSE 9774
// Say ( Burlak , D12-Bur-1 ) else
9760: LD_EXP 45
9764: PPUSH
9765: LD_STRING D12-Bur-1
9767: PPUSH
9768: CALL_OW 88
9772: GO 9813
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9774: LD_INT 7
9776: PPUSH
9777: LD_INT 3
9779: PPUSH
9780: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9784: LD_INT 127
9786: PPUSH
9787: LD_INT 45
9789: PPUSH
9790: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9794: LD_EXP 45
9798: PPUSH
9799: LD_STRING D12-Bur-1a
9801: PPUSH
9802: CALL_OW 88
// dwait ( 0 0$2 ) ;
9806: LD_INT 70
9808: PPUSH
9809: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9813: LD_EXP 45
9817: PPUSH
9818: LD_STRING D12-Bur-1b
9820: PPUSH
9821: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9825: LD_EXP 14
9829: PPUSH
9830: LD_STRING D12-JMM-1
9832: PPUSH
9833: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9837: LD_EXP 45
9841: PPUSH
9842: LD_STRING D12-Bur-2
9844: PPUSH
9845: CALL_OW 88
// if Roth then
9849: LD_EXP 15
9853: IFFALSE 9869
// Say ( Roth , D12-Roth-2 ) else
9855: LD_EXP 15
9859: PPUSH
9860: LD_STRING D12-Roth-2
9862: PPUSH
9863: CALL_OW 88
9867: GO 9881
// Say ( SciRu , D12-RSci1-2 ) ;
9869: CALL 12393 0 0
9873: PPUSH
9874: LD_STRING D12-RSci1-2
9876: PPUSH
9877: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9881: LD_EXP 14
9885: PPUSH
9886: LD_STRING D12-JMM-2
9888: PPUSH
9889: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9893: LD_EXP 45
9897: PPUSH
9898: LD_STRING D12-Bur-3
9900: PPUSH
9901: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9905: LD_EXP 14
9909: PPUSH
9910: LD_STRING D12-JMM-3
9912: PPUSH
9913: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9917: LD_EXP 45
9921: PPUSH
9922: LD_STRING D12-Bur-4
9924: PPUSH
9925: CALL_OW 88
// case Query ( QBase ) of 1 :
9929: LD_STRING QBase
9931: PPUSH
9932: CALL_OW 97
9936: PUSH
9937: LD_INT 1
9939: DOUBLE
9940: EQUAL
9941: IFTRUE 9945
9943: GO 10063
9945: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9946: LD_EXP 14
9950: PPUSH
9951: LD_STRING D13a-JMM-1
9953: PPUSH
9954: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9958: LD_EXP 45
9962: PPUSH
9963: LD_STRING D13a-Bur-1
9965: PPUSH
9966: CALL_OW 88
// if Roth then
9970: LD_EXP 15
9974: IFFALSE 9990
// Say ( Roth , D13a-Roth-1 ) else
9976: LD_EXP 15
9980: PPUSH
9981: LD_STRING D13a-Roth-1
9983: PPUSH
9984: CALL_OW 88
9988: GO 10002
// Say ( SciRu , D13a-RSci1-1 ) ;
9990: CALL 12393 0 0
9994: PPUSH
9995: LD_STRING D13a-RSci1-1
9997: PPUSH
9998: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10002: LD_EXP 14
10006: PPUSH
10007: LD_STRING D13a-JMM-2
10009: PPUSH
10010: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10014: LD_STRING QBaseAgain
10016: PPUSH
10017: CALL_OW 97
10021: PUSH
10022: LD_INT 1
10024: DOUBLE
10025: EQUAL
10026: IFTRUE 10030
10028: GO 10041
10030: POP
// selected_option := 2 ; 2 :
10031: LD_ADDR_VAR 0 2
10035: PUSH
10036: LD_INT 2
10038: ST_TO_ADDR
10039: GO 10061
10041: LD_INT 2
10043: DOUBLE
10044: EQUAL
10045: IFTRUE 10049
10047: GO 10060
10049: POP
// selected_option := 3 ; end ;
10050: LD_ADDR_VAR 0 2
10054: PUSH
10055: LD_INT 3
10057: ST_TO_ADDR
10058: GO 10061
10060: POP
// end ; 2 :
10061: GO 10102
10063: LD_INT 2
10065: DOUBLE
10066: EQUAL
10067: IFTRUE 10071
10069: GO 10082
10071: POP
// selected_option := 2 ; 3 :
10072: LD_ADDR_VAR 0 2
10076: PUSH
10077: LD_INT 2
10079: ST_TO_ADDR
10080: GO 10102
10082: LD_INT 3
10084: DOUBLE
10085: EQUAL
10086: IFTRUE 10090
10088: GO 10101
10090: POP
// selected_option := 3 ; end ;
10091: LD_ADDR_VAR 0 2
10095: PUSH
10096: LD_INT 3
10098: ST_TO_ADDR
10099: GO 10102
10101: POP
// if selected_option = 2 then
10102: LD_VAR 0 2
10106: PUSH
10107: LD_INT 2
10109: EQUAL
10110: IFFALSE 10204
// begin Say ( JMM , D13b-JMM-1 ) ;
10112: LD_EXP 14
10116: PPUSH
10117: LD_STRING D13b-JMM-1
10119: PPUSH
10120: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10124: LD_EXP 45
10128: PPUSH
10129: LD_STRING D13b-Bur-1
10131: PPUSH
10132: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10136: LD_EXP 14
10140: PPUSH
10141: LD_STRING D13b-JMM-2
10143: PPUSH
10144: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10148: LD_EXP 54
10152: PPUSH
10153: LD_STRING D13b-Abd-2
10155: PPUSH
10156: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10160: LD_EXP 14
10164: PPUSH
10165: LD_STRING D13b-JMM-3
10167: PPUSH
10168: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10172: LD_EXP 54
10176: PPUSH
10177: LD_STRING D13b-Abd-3
10179: PPUSH
10180: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10184: LD_EXP 14
10188: PPUSH
10189: LD_STRING D13b-JMM-4
10191: PPUSH
10192: CALL_OW 88
// ar_active_attack := true ;
10196: LD_ADDR_EXP 9
10200: PUSH
10201: LD_INT 1
10203: ST_TO_ADDR
// end ; if selected_option = 3 then
10204: LD_VAR 0 2
10208: PUSH
10209: LD_INT 3
10211: EQUAL
10212: IFFALSE 10238
// begin Say ( JMM , D13c-JMM-1 ) ;
10214: LD_EXP 14
10218: PPUSH
10219: LD_STRING D13c-JMM-1
10221: PPUSH
10222: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10226: LD_EXP 45
10230: PPUSH
10231: LD_STRING D13c-Bur-1
10233: PPUSH
10234: CALL_OW 88
// end ; DialogueOff ;
10238: CALL_OW 7
// if not ar_active_attack then
10242: LD_EXP 9
10246: NOT
10247: IFFALSE 10264
// begin wait ( 6 6$00 ) ;
10249: LD_INT 12600
10251: PPUSH
10252: CALL_OW 67
// ar_active_attack := true ;
10256: LD_ADDR_EXP 9
10260: PUSH
10261: LD_INT 1
10263: ST_TO_ADDR
// end ; end ;
10264: PPOPN 2
10266: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10267: LD_EXP 45
10271: PPUSH
10272: CALL_OW 305
10276: PUSH
10277: LD_EXP 45
10281: PPUSH
10282: CALL_OW 255
10286: PUSH
10287: LD_INT 7
10289: EQUAL
10290: AND
10291: IFFALSE 10487
10293: GO 10295
10295: DISABLE
10296: LD_INT 0
10298: PPUSH
// begin wait ( 4 4$40 ) ;
10299: LD_INT 9800
10301: PPUSH
10302: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10306: LD_INT 35
10308: PPUSH
10309: CALL_OW 67
// until not ru_attackers ;
10313: LD_EXP 51
10317: NOT
10318: IFFALSE 10306
// PrepareGnyevko ;
10320: CALL 2030 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10324: LD_EXP 47
10328: PPUSH
10329: LD_INT 124
10331: PPUSH
10332: LD_INT 118
10334: PPUSH
10335: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10339: LD_EXP 47
10343: PPUSH
10344: CALL_OW 200
// time := 0 0$00 ;
10348: LD_ADDR_VAR 0 1
10352: PUSH
10353: LD_INT 0
10355: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10356: LD_INT 35
10358: PPUSH
10359: CALL_OW 67
// time := time + 0 0$1 ;
10363: LD_ADDR_VAR 0 1
10367: PUSH
10368: LD_VAR 0 1
10372: PUSH
10373: LD_INT 35
10375: PLUS
10376: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10377: LD_EXP 47
10381: PPUSH
10382: LD_INT 124
10384: PPUSH
10385: LD_INT 118
10387: PPUSH
10388: CALL_OW 307
10392: PUSH
10393: LD_VAR 0 1
10397: PUSH
10398: LD_INT 1050
10400: GREATEREQUAL
10401: OR
10402: IFFALSE 10356
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING DBelkov-Gny-1
10411: PPUSH
10412: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10416: LD_EXP 45
10420: PPUSH
10421: LD_STRING DBelkov-Bur-1a
10423: PPUSH
10424: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10428: LD_INT 35
10430: PPUSH
10431: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10435: LD_EXP 47
10439: PPUSH
10440: LD_INT 22
10442: PUSH
10443: LD_INT 7
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PPUSH
10450: CALL_OW 69
10454: PPUSH
10455: LD_EXP 47
10459: PPUSH
10460: CALL_OW 74
10464: PPUSH
10465: CALL_OW 296
10469: PUSH
10470: LD_INT 8
10472: LESS
10473: IFFALSE 10428
// SetSide ( Gnyevko , 7 ) ;
10475: LD_EXP 47
10479: PPUSH
10480: LD_INT 7
10482: PPUSH
10483: CALL_OW 235
// end ;
10487: PPOPN 1
10489: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10490: LD_EXP 45
10494: PPUSH
10495: CALL_OW 255
10499: PUSH
10500: LD_INT 7
10502: EQUAL
10503: IFFALSE 10513
10505: GO 10507
10507: DISABLE
// begin enable ;
10508: ENABLE
// PrepareAmericanAttack ;
10509: CALL 6336 0 0
// end ;
10513: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10514: LD_INT 22
10516: PUSH
10517: LD_INT 1
10519: PUSH
10520: EMPTY
10521: LIST
10522: LIST
10523: PPUSH
10524: CALL_OW 69
10528: IFFALSE 10712
10530: GO 10532
10532: DISABLE
10533: LD_INT 0
10535: PPUSH
10536: PPUSH
// begin while true do
10537: LD_INT 1
10539: IFFALSE 10596
// begin wait ( 0 0$1 ) ;
10541: LD_INT 35
10543: PPUSH
10544: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10548: LD_ADDR_VAR 0 2
10552: PUSH
10553: LD_INT 22
10555: PUSH
10556: LD_INT 1
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: PPUSH
10563: CALL_OW 69
10567: PPUSH
10568: LD_EXP 14
10572: PPUSH
10573: CALL_OW 74
10577: ST_TO_ADDR
// if See ( 7 , tmp ) then
10578: LD_INT 7
10580: PPUSH
10581: LD_VAR 0 2
10585: PPUSH
10586: CALL_OW 292
10590: IFFALSE 10594
// break ;
10592: GO 10596
// end ;
10594: GO 10537
// DialogueOn ;
10596: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10609: LD_VAR 0 2
10613: PPUSH
10614: CALL_OW 250
10618: PPUSH
10619: LD_VAR 0 2
10623: PPUSH
10624: CALL_OW 251
10628: PPUSH
10629: LD_INT 7
10631: PPUSH
10632: LD_INT 8
10634: PPUSH
10635: CALL_OW 330
// if Denis then
10639: LD_EXP 20
10643: IFFALSE 10657
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10645: LD_EXP 20
10649: PPUSH
10650: LD_STRING DAmerAttack-Pet-1
10652: PPUSH
10653: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10657: LD_EXP 14
10661: PPUSH
10662: LD_STRING DAmerAttack-JMM-1
10664: PPUSH
10665: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10669: LD_EXP 45
10673: PPUSH
10674: LD_STRING DStop-Bur-1
10676: PPUSH
10677: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10681: LD_VAR 0 2
10685: PPUSH
10686: CALL_OW 250
10690: PPUSH
10691: LD_VAR 0 2
10695: PPUSH
10696: CALL_OW 251
10700: PPUSH
10701: LD_INT 7
10703: PPUSH
10704: CALL_OW 331
// DialogueOff ;
10708: CALL_OW 7
// end ;
10712: PPOPN 2
10714: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10715: LD_INT 22
10717: PUSH
10718: LD_INT 3
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: LD_INT 21
10727: PUSH
10728: LD_INT 1
10730: PUSH
10731: EMPTY
10732: LIST
10733: LIST
10734: PUSH
10735: EMPTY
10736: LIST
10737: LIST
10738: PPUSH
10739: CALL_OW 69
10743: PUSH
10744: LD_INT 0
10746: EQUAL
10747: IFFALSE 10789
10749: GO 10751
10751: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10752: LD_STRING M5a
10754: PPUSH
10755: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10759: LD_EXP 14
10763: PPUSH
10764: LD_STRING D8-JMM-1
10766: PPUSH
10767: CALL_OW 88
// if Gossudarov then
10771: LD_EXP 31
10775: IFFALSE 10789
// Say ( Gossudarov , D8-Gos-1 ) ;
10777: LD_EXP 31
10781: PPUSH
10782: LD_STRING D8-Gos-1
10784: PPUSH
10785: CALL_OW 88
// end ;
10789: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10790: LD_INT 22
10792: PUSH
10793: LD_INT 2
10795: PUSH
10796: EMPTY
10797: LIST
10798: LIST
10799: PUSH
10800: LD_INT 21
10802: PUSH
10803: LD_INT 1
10805: PUSH
10806: EMPTY
10807: LIST
10808: LIST
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PPUSH
10814: CALL_OW 69
10818: PUSH
10819: LD_INT 0
10821: EQUAL
10822: IFFALSE 10872
10824: GO 10826
10826: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10827: LD_STRING M4c
10829: PPUSH
10830: CALL_OW 337
// if Roth then
10834: LD_EXP 15
10838: IFFALSE 10854
// Say ( Roth , DStop-Roth-1 ) else
10840: LD_EXP 15
10844: PPUSH
10845: LD_STRING DStop-Roth-1
10847: PPUSH
10848: CALL_OW 88
10852: GO 10872
// if Gossudarov then
10854: LD_EXP 31
10858: IFFALSE 10872
// Say ( Gossudarov , D8-Gos-1a ) ;
10860: LD_EXP 31
10864: PPUSH
10865: LD_STRING D8-Gos-1a
10867: PPUSH
10868: CALL_OW 88
// end ;
10872: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10873: LD_INT 7
10875: PPUSH
10876: LD_INT 1
10878: PPUSH
10879: LD_INT 1
10881: PPUSH
10882: CALL 13973 0 3
10886: PUSH
10887: LD_INT 0
10889: EQUAL
10890: PUSH
10891: LD_INT 7
10893: PPUSH
10894: LD_INT 3
10896: PPUSH
10897: LD_INT 1
10899: PPUSH
10900: CALL 13973 0 3
10904: PUSH
10905: LD_INT 0
10907: EQUAL
10908: AND
10909: IFFALSE 10921
10911: GO 10913
10913: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10914: LD_STRING M1a
10916: PPUSH
10917: CALL_OW 337
// end ;
10921: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10922: LD_INT 22
10924: PUSH
10925: LD_INT 2
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 1
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: LD_INT 0
10953: EQUAL
10954: PUSH
10955: LD_INT 22
10957: PUSH
10958: LD_INT 3
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: PUSH
10965: LD_INT 21
10967: PUSH
10968: LD_INT 1
10970: PUSH
10971: EMPTY
10972: LIST
10973: LIST
10974: PUSH
10975: EMPTY
10976: LIST
10977: LIST
10978: PPUSH
10979: CALL_OW 69
10983: PUSH
10984: LD_INT 0
10986: EQUAL
10987: AND
10988: PUSH
10989: LD_INT 22
10991: PUSH
10992: LD_INT 1
10994: PUSH
10995: EMPTY
10996: LIST
10997: LIST
10998: PPUSH
10999: CALL_OW 69
11003: PUSH
11004: LD_INT 0
11006: EQUAL
11007: AND
11008: PUSH
11009: LD_INT 7
11011: PPUSH
11012: LD_INT 1
11014: PPUSH
11015: LD_INT 1
11017: PPUSH
11018: CALL 13973 0 3
11022: PUSH
11023: LD_INT 0
11025: EQUAL
11026: AND
11027: PUSH
11028: LD_INT 7
11030: PPUSH
11031: LD_INT 3
11033: PPUSH
11034: LD_INT 1
11036: PPUSH
11037: CALL 13973 0 3
11041: PUSH
11042: LD_INT 0
11044: EQUAL
11045: AND
11046: IFFALSE 12390
11048: GO 11050
11050: DISABLE
11051: LD_INT 0
11053: PPUSH
11054: PPUSH
11055: PPUSH
// begin wait ( 0 0$3 ) ;
11056: LD_INT 105
11058: PPUSH
11059: CALL_OW 67
// if not IsDead ( Masha ) then
11063: LD_EXP 48
11067: PPUSH
11068: CALL_OW 301
11072: NOT
11073: IFFALSE 11087
// AddMedal ( Masha , 1 ) else
11075: LD_STRING Masha
11077: PPUSH
11078: LD_INT 1
11080: PPUSH
11081: CALL_OW 101
11085: GO 11098
// AddMedal ( Masha , - 1 ) ;
11087: LD_STRING Masha
11089: PPUSH
11090: LD_INT 1
11092: NEG
11093: PPUSH
11094: CALL_OW 101
// if abdul_escaped then
11098: LD_EXP 12
11102: IFFALSE 11117
// AddMedal ( Abdul , - 1 ) else
11104: LD_STRING Abdul
11106: PPUSH
11107: LD_INT 1
11109: NEG
11110: PPUSH
11111: CALL_OW 101
11115: GO 11127
// AddMedal ( Abdul , 1 ) ;
11117: LD_STRING Abdul
11119: PPUSH
11120: LD_INT 1
11122: PPUSH
11123: CALL_OW 101
// if loss_counter = 0 then
11127: LD_EXP 13
11131: PUSH
11132: LD_INT 0
11134: EQUAL
11135: IFFALSE 11149
// AddMedal ( People , 2 ) else
11137: LD_STRING People
11139: PPUSH
11140: LD_INT 2
11142: PPUSH
11143: CALL_OW 101
11147: GO 11199
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11149: LD_EXP 13
11153: PUSH
11154: LD_INT 3
11156: PUSH
11157: LD_INT 2
11159: PUSH
11160: LD_INT 2
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: LIST
11167: PUSH
11168: LD_OWVAR 67
11172: ARRAY
11173: LESSEQUAL
11174: IFFALSE 11188
// AddMedal ( People , 1 ) else
11176: LD_STRING People
11178: PPUSH
11179: LD_INT 1
11181: PPUSH
11182: CALL_OW 101
11186: GO 11199
// AddMedal ( People , - 1 ) ;
11188: LD_STRING People
11190: PPUSH
11191: LD_INT 1
11193: NEG
11194: PPUSH
11195: CALL_OW 101
// GiveMedals ( MAIN ) ;
11199: LD_STRING MAIN
11201: PPUSH
11202: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11206: LD_ADDR_VAR 0 2
11210: PUSH
11211: LD_INT 22
11213: PUSH
11214: LD_INT 7
11216: PUSH
11217: EMPTY
11218: LIST
11219: LIST
11220: PUSH
11221: LD_INT 2
11223: PUSH
11224: LD_INT 25
11226: PUSH
11227: LD_INT 1
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PUSH
11234: LD_INT 25
11236: PUSH
11237: LD_INT 2
11239: PUSH
11240: EMPTY
11241: LIST
11242: LIST
11243: PUSH
11244: LD_INT 25
11246: PUSH
11247: LD_INT 3
11249: PUSH
11250: EMPTY
11251: LIST
11252: LIST
11253: PUSH
11254: LD_INT 25
11256: PUSH
11257: LD_INT 4
11259: PUSH
11260: EMPTY
11261: LIST
11262: LIST
11263: PUSH
11264: LD_INT 25
11266: PUSH
11267: LD_INT 5
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 25
11276: PUSH
11277: LD_INT 8
11279: PUSH
11280: EMPTY
11281: LIST
11282: LIST
11283: PUSH
11284: LD_INT 25
11286: PUSH
11287: LD_INT 9
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: LIST
11302: LIST
11303: PUSH
11304: EMPTY
11305: LIST
11306: LIST
11307: PPUSH
11308: CALL_OW 69
11312: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11313: LD_VAR 0 2
11317: PPUSH
11318: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11322: LD_ADDR_VAR 0 3
11326: PUSH
11327: LD_EXP 14
11331: PUSH
11332: LD_EXP 15
11336: PUSH
11337: LD_EXP 16
11341: PUSH
11342: LD_EXP 17
11346: PUSH
11347: LD_EXP 18
11351: PUSH
11352: LD_EXP 19
11356: PUSH
11357: LD_EXP 20
11361: PUSH
11362: LD_EXP 21
11366: PUSH
11367: LD_EXP 22
11371: PUSH
11372: LD_EXP 23
11376: PUSH
11377: LD_EXP 24
11381: PUSH
11382: LD_EXP 25
11386: PUSH
11387: LD_EXP 26
11391: PUSH
11392: LD_EXP 27
11396: PUSH
11397: LD_EXP 28
11401: PUSH
11402: LD_EXP 29
11406: PUSH
11407: LD_EXP 30
11411: PUSH
11412: LD_EXP 31
11416: PUSH
11417: LD_EXP 32
11421: PUSH
11422: LD_EXP 33
11426: PUSH
11427: LD_EXP 35
11431: PUSH
11432: LD_EXP 36
11436: PUSH
11437: LD_EXP 37
11441: PUSH
11442: LD_EXP 38
11446: PUSH
11447: LD_EXP 39
11451: PUSH
11452: LD_EXP 40
11456: PUSH
11457: LD_EXP 41
11461: PUSH
11462: LD_EXP 42
11466: PUSH
11467: LD_EXP 43
11471: PUSH
11472: LD_EXP 44
11476: PUSH
11477: LD_EXP 45
11481: PUSH
11482: LD_EXP 46
11486: PUSH
11487: LD_EXP 47
11491: PUSH
11492: EMPTY
11493: LIST
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: ST_TO_ADDR
// if tmp diff tmp2 then
11527: LD_VAR 0 2
11531: PUSH
11532: LD_VAR 0 3
11536: DIFF
11537: IFFALSE 11557
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11539: LD_VAR 0 2
11543: PUSH
11544: LD_VAR 0 3
11548: DIFF
11549: PPUSH
11550: LD_STRING 13a_others
11552: PPUSH
11553: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11557: LD_EXP 14
11561: PPUSH
11562: LD_STRING 13a_JMM
11564: PPUSH
11565: CALL_OW 38
// if Titov then
11569: LD_EXP 33
11573: IFFALSE 11587
// SaveCharacters ( Titov , 13a_Titov ) ;
11575: LD_EXP 33
11579: PPUSH
11580: LD_STRING 13a_Titov
11582: PPUSH
11583: CALL_OW 38
// if Dolgov then
11587: LD_EXP 35
11591: IFFALSE 11605
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11593: LD_EXP 35
11597: PPUSH
11598: LD_STRING 13a_Dolgov
11600: PPUSH
11601: CALL_OW 38
// if Petrosyan then
11605: LD_EXP 36
11609: IFFALSE 11623
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11611: LD_EXP 36
11615: PPUSH
11616: LD_STRING 13a_Petrosyan
11618: PPUSH
11619: CALL_OW 38
// if Scholtze then
11623: LD_EXP 37
11627: IFFALSE 11641
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11629: LD_EXP 37
11633: PPUSH
11634: LD_STRING 13a_Scholtze
11636: PPUSH
11637: CALL_OW 38
// if Oblukov then
11641: LD_EXP 38
11645: IFFALSE 11659
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11647: LD_EXP 38
11651: PPUSH
11652: LD_STRING 13a_Oblukov
11654: PPUSH
11655: CALL_OW 38
// if Kapitsova then
11659: LD_EXP 39
11663: IFFALSE 11677
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11665: LD_EXP 39
11669: PPUSH
11670: LD_STRING 13a_Kapitsova
11672: PPUSH
11673: CALL_OW 38
// if Lipshchin then
11677: LD_EXP 40
11681: IFFALSE 11695
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11683: LD_EXP 40
11687: PPUSH
11688: LD_STRING 13a_Lipshchin
11690: PPUSH
11691: CALL_OW 38
// if Petrovova then
11695: LD_EXP 41
11699: IFFALSE 11713
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11701: LD_EXP 41
11705: PPUSH
11706: LD_STRING 13a_Petrovova
11708: PPUSH
11709: CALL_OW 38
// if Kovalyuk then
11713: LD_EXP 42
11717: IFFALSE 11731
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11719: LD_EXP 42
11723: PPUSH
11724: LD_STRING 13a_Kovalyuk
11726: PPUSH
11727: CALL_OW 38
// if Kuzmov then
11731: LD_EXP 43
11735: IFFALSE 11749
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11737: LD_EXP 43
11741: PPUSH
11742: LD_STRING 13a_Kuzmov
11744: PPUSH
11745: CALL_OW 38
// if Karamazov then
11749: LD_EXP 44
11753: IFFALSE 11767
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11755: LD_EXP 44
11759: PPUSH
11760: LD_STRING 13a_Karamazov
11762: PPUSH
11763: CALL_OW 38
// if Burlak then
11767: LD_EXP 45
11771: IFFALSE 11785
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11773: LD_EXP 45
11777: PPUSH
11778: LD_STRING 13a_Burlak
11780: PPUSH
11781: CALL_OW 38
// if Belkov then
11785: LD_EXP 46
11789: IFFALSE 11803
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11791: LD_EXP 46
11795: PPUSH
11796: LD_STRING 13a_Belkov
11798: PPUSH
11799: CALL_OW 38
// if Gnyevko then
11803: LD_EXP 47
11807: IFFALSE 11821
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11809: LD_EXP 47
11813: PPUSH
11814: LD_STRING 13a_Gnyevko
11816: PPUSH
11817: CALL_OW 38
// if Lisa then
11821: LD_EXP 16
11825: IFFALSE 11839
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11827: LD_EXP 16
11831: PPUSH
11832: LD_STRING 13a_Lisa
11834: PPUSH
11835: CALL_OW 38
// if Donaldson then
11839: LD_EXP 17
11843: IFFALSE 11857
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11845: LD_EXP 17
11849: PPUSH
11850: LD_STRING 13a_Donaldson
11852: PPUSH
11853: CALL_OW 38
// if Bobby then
11857: LD_EXP 18
11861: IFFALSE 11875
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11863: LD_EXP 18
11867: PPUSH
11868: LD_STRING 13a_Bobby
11870: PPUSH
11871: CALL_OW 38
// if Cyrus then
11875: LD_EXP 19
11879: IFFALSE 11893
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11881: LD_EXP 19
11885: PPUSH
11886: LD_STRING 13a_Cyrus
11888: PPUSH
11889: CALL_OW 38
// if Denis then
11893: LD_EXP 20
11897: IFFALSE 11911
// SaveCharacters ( Denis , 13a_Denis ) ;
11899: LD_EXP 20
11903: PPUSH
11904: LD_STRING 13a_Denis
11906: PPUSH
11907: CALL_OW 38
// if Brown then
11911: LD_EXP 21
11915: IFFALSE 11929
// SaveCharacters ( Brown , 13a_Brown ) ;
11917: LD_EXP 21
11921: PPUSH
11922: LD_STRING 13a_Brown
11924: PPUSH
11925: CALL_OW 38
// if Gladstone then
11929: LD_EXP 22
11933: IFFALSE 11947
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11935: LD_EXP 22
11939: PPUSH
11940: LD_STRING 13a_Gladstone
11942: PPUSH
11943: CALL_OW 38
// if Houten then
11947: LD_EXP 23
11951: IFFALSE 11965
// SaveCharacters ( Houten , 13a_Houten ) ;
11953: LD_EXP 23
11957: PPUSH
11958: LD_STRING 13a_Houten
11960: PPUSH
11961: CALL_OW 38
// if Cornel then
11965: LD_EXP 24
11969: IFFALSE 11983
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11971: LD_EXP 24
11975: PPUSH
11976: LD_STRING 13a_Cornel
11978: PPUSH
11979: CALL_OW 38
// if Gary then
11983: LD_EXP 25
11987: IFFALSE 12001
// SaveCharacters ( Gary , 13a_Gary ) ;
11989: LD_EXP 25
11993: PPUSH
11994: LD_STRING 13a_Gary
11996: PPUSH
11997: CALL_OW 38
// if Frank then
12001: LD_EXP 26
12005: IFFALSE 12019
// SaveCharacters ( Frank , 13a_Frank ) ;
12007: LD_EXP 26
12011: PPUSH
12012: LD_STRING 13a_Frank
12014: PPUSH
12015: CALL_OW 38
// if Kikuchi then
12019: LD_EXP 27
12023: IFFALSE 12037
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12025: LD_EXP 27
12029: PPUSH
12030: LD_STRING 13a_Kikuchi
12032: PPUSH
12033: CALL_OW 38
// if Simms then
12037: LD_EXP 28
12041: IFFALSE 12055
// SaveCharacters ( Simms , 13a_Simms ) ;
12043: LD_EXP 28
12047: PPUSH
12048: LD_STRING 13a_Simms
12050: PPUSH
12051: CALL_OW 38
// if Joan then
12055: LD_EXP 29
12059: IFFALSE 12073
// SaveCharacters ( Joan , 13a_Joan ) ;
12061: LD_EXP 29
12065: PPUSH
12066: LD_STRING 13a_Joan
12068: PPUSH
12069: CALL_OW 38
// if DeltaDoctor then
12073: LD_EXP 30
12077: IFFALSE 12091
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12079: LD_EXP 30
12083: PPUSH
12084: LD_STRING 13a_DeltaDoctor
12086: PPUSH
12087: CALL_OW 38
// if Gossudarov then
12091: LD_EXP 31
12095: IFFALSE 12109
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12097: LD_EXP 31
12101: PPUSH
12102: LD_STRING 13a_Gossudarov
12104: PPUSH
12105: CALL_OW 38
// if Kirilenkova then
12109: LD_EXP 32
12113: IFFALSE 12127
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12115: LD_EXP 32
12119: PPUSH
12120: LD_STRING 13a_Kirilenkova
12122: PPUSH
12123: CALL_OW 38
// if Masha then
12127: LD_EXP 48
12131: IFFALSE 12186
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12133: LD_EXP 48
12137: PPUSH
12138: CALL_OW 265
12142: PUSH
12143: LD_EXP 48
12147: PPUSH
12148: CALL_OW 262
12152: PUSH
12153: LD_EXP 48
12157: PPUSH
12158: CALL_OW 263
12162: PUSH
12163: LD_EXP 48
12167: PPUSH
12168: CALL_OW 264
12172: PUSH
12173: EMPTY
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: PPUSH
12179: LD_STRING 13a_Masha
12181: PPUSH
12182: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12186: LD_ADDR_VAR 0 2
12190: PUSH
12191: LD_INT 21
12193: PUSH
12194: LD_INT 3
12196: PUSH
12197: EMPTY
12198: LIST
12199: LIST
12200: PPUSH
12201: CALL_OW 69
12205: ST_TO_ADDR
// tmp2 := [ ] ;
12206: LD_ADDR_VAR 0 3
12210: PUSH
12211: EMPTY
12212: ST_TO_ADDR
// if tmp then
12213: LD_VAR 0 2
12217: IFFALSE 12368
// for i in tmp do
12219: LD_ADDR_VAR 0 1
12223: PUSH
12224: LD_VAR 0 2
12228: PUSH
12229: FOR_IN
12230: IFFALSE 12366
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12232: LD_ADDR_VAR 0 3
12236: PUSH
12237: LD_VAR 0 3
12241: PUSH
12242: LD_VAR 0 1
12246: PPUSH
12247: CALL_OW 255
12251: PUSH
12252: LD_VAR 0 1
12256: PPUSH
12257: CALL_OW 248
12261: PUSH
12262: LD_VAR 0 1
12266: PPUSH
12267: CALL_OW 266
12271: PUSH
12272: LD_VAR 0 1
12276: PPUSH
12277: CALL_OW 250
12281: PUSH
12282: LD_VAR 0 1
12286: PPUSH
12287: CALL_OW 251
12291: PUSH
12292: LD_VAR 0 1
12296: PPUSH
12297: CALL_OW 254
12301: PUSH
12302: LD_VAR 0 1
12306: PPUSH
12307: CALL_OW 267
12311: PUSH
12312: LD_VAR 0 1
12316: PPUSH
12317: LD_INT 1
12319: PPUSH
12320: CALL_OW 268
12324: PUSH
12325: LD_VAR 0 1
12329: PPUSH
12330: LD_INT 2
12332: PPUSH
12333: CALL_OW 268
12337: PUSH
12338: LD_VAR 0 1
12342: PPUSH
12343: CALL_OW 269
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: ADD
12363: ST_TO_ADDR
12364: GO 12229
12366: POP
12367: POP
// if tmp2 then
12368: LD_VAR 0 3
12372: IFFALSE 12386
// SaveVariable ( tmp2 , 13a_buildings ) ;
12374: LD_VAR 0 3
12378: PPUSH
12379: LD_STRING 13a_buildings
12381: PPUSH
12382: CALL_OW 39
// YouWin ;
12386: CALL_OW 103
// end ;
12390: PPOPN 3
12392: END
// export function SciRu ; var tmp , t ; begin
12393: LD_INT 0
12395: PPUSH
12396: PPUSH
12397: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12398: LD_ADDR_VAR 0 3
12402: PUSH
12403: LD_EXP 31
12407: PUSH
12408: LD_EXP 45
12412: PUSH
12413: LD_EXP 33
12417: PUSH
12418: LD_EXP 46
12422: PUSH
12423: LD_EXP 47
12427: PUSH
12428: LD_EXP 36
12432: PUSH
12433: LD_EXP 37
12437: PUSH
12438: LD_EXP 35
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: LIST
12447: LIST
12448: LIST
12449: LIST
12450: LIST
12451: LIST
12452: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12453: LD_ADDR_VAR 0 2
12457: PUSH
12458: LD_INT 22
12460: PUSH
12461: LD_INT 7
12463: PUSH
12464: EMPTY
12465: LIST
12466: LIST
12467: PUSH
12468: LD_INT 23
12470: PUSH
12471: LD_INT 3
12473: PUSH
12474: EMPTY
12475: LIST
12476: LIST
12477: PUSH
12478: LD_INT 25
12480: PUSH
12481: LD_INT 4
12483: PUSH
12484: EMPTY
12485: LIST
12486: LIST
12487: PUSH
12488: LD_INT 26
12490: PUSH
12491: LD_INT 1
12493: PUSH
12494: EMPTY
12495: LIST
12496: LIST
12497: PUSH
12498: EMPTY
12499: LIST
12500: LIST
12501: LIST
12502: LIST
12503: PPUSH
12504: CALL_OW 69
12508: PUSH
12509: LD_VAR 0 3
12513: DIFF
12514: ST_TO_ADDR
// if tmp then
12515: LD_VAR 0 2
12519: IFFALSE 12535
// result := tmp [ 1 ] ;
12521: LD_ADDR_VAR 0 1
12525: PUSH
12526: LD_VAR 0 2
12530: PUSH
12531: LD_INT 1
12533: ARRAY
12534: ST_TO_ADDR
// end ;
12535: LD_VAR 0 1
12539: RET
// export function SolRu ; var tmp , t ; begin
12540: LD_INT 0
12542: PPUSH
12543: PPUSH
12544: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12545: LD_ADDR_VAR 0 3
12549: PUSH
12550: LD_EXP 31
12554: PUSH
12555: LD_EXP 45
12559: PUSH
12560: LD_EXP 33
12564: PUSH
12565: LD_EXP 46
12569: PUSH
12570: LD_EXP 47
12574: PUSH
12575: LD_EXP 36
12579: PUSH
12580: LD_EXP 37
12584: PUSH
12585: LD_EXP 35
12589: PUSH
12590: EMPTY
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: LIST
12598: LIST
12599: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12600: LD_ADDR_VAR 0 2
12604: PUSH
12605: LD_INT 22
12607: PUSH
12608: LD_INT 7
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: LD_INT 23
12617: PUSH
12618: LD_INT 3
12620: PUSH
12621: EMPTY
12622: LIST
12623: LIST
12624: PUSH
12625: LD_INT 25
12627: PUSH
12628: LD_INT 1
12630: PUSH
12631: EMPTY
12632: LIST
12633: LIST
12634: PUSH
12635: LD_INT 26
12637: PUSH
12638: LD_INT 1
12640: PUSH
12641: EMPTY
12642: LIST
12643: LIST
12644: PUSH
12645: EMPTY
12646: LIST
12647: LIST
12648: LIST
12649: LIST
12650: PPUSH
12651: CALL_OW 69
12655: PUSH
12656: LD_VAR 0 3
12660: DIFF
12661: ST_TO_ADDR
// if tmp then
12662: LD_VAR 0 2
12666: IFFALSE 12682
// result := tmp [ 1 ] ;
12668: LD_ADDR_VAR 0 1
12672: PUSH
12673: LD_VAR 0 2
12677: PUSH
12678: LD_INT 1
12680: ARRAY
12681: ST_TO_ADDR
// end ; end_of_file
12682: LD_VAR 0 1
12686: RET
// export function CustomEvent ( event ) ; begin
12687: LD_INT 0
12689: PPUSH
// end ;
12690: LD_VAR 0 2
12694: RET
// on UnitDestroyed ( un ) do var i , side ;
12695: LD_INT 0
12697: PPUSH
12698: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12699: LD_VAR 0 1
12703: PUSH
12704: LD_INT 22
12706: PUSH
12707: LD_INT 7
12709: PUSH
12710: EMPTY
12711: LIST
12712: LIST
12713: PUSH
12714: LD_INT 2
12716: PUSH
12717: LD_INT 25
12719: PUSH
12720: LD_INT 1
12722: PUSH
12723: EMPTY
12724: LIST
12725: LIST
12726: PUSH
12727: LD_INT 25
12729: PUSH
12730: LD_INT 2
12732: PUSH
12733: EMPTY
12734: LIST
12735: LIST
12736: PUSH
12737: LD_INT 25
12739: PUSH
12740: LD_INT 3
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: PUSH
12747: LD_INT 25
12749: PUSH
12750: LD_INT 4
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: PUSH
12757: LD_INT 25
12759: PUSH
12760: LD_INT 5
12762: PUSH
12763: EMPTY
12764: LIST
12765: LIST
12766: PUSH
12767: LD_INT 25
12769: PUSH
12770: LD_INT 8
12772: PUSH
12773: EMPTY
12774: LIST
12775: LIST
12776: PUSH
12777: LD_INT 25
12779: PUSH
12780: LD_INT 9
12782: PUSH
12783: EMPTY
12784: LIST
12785: LIST
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PPUSH
12801: CALL_OW 69
12805: IN
12806: IFFALSE 12822
// loss_counter := loss_counter + 1 ;
12808: LD_ADDR_EXP 13
12812: PUSH
12813: LD_EXP 13
12817: PUSH
12818: LD_INT 1
12820: PLUS
12821: ST_TO_ADDR
// if un = Abdul then
12822: LD_VAR 0 1
12826: PUSH
12827: LD_EXP 54
12831: EQUAL
12832: IFFALSE 12842
// abdul_escaped := false ;
12834: LD_ADDR_EXP 12
12838: PUSH
12839: LD_INT 0
12841: ST_TO_ADDR
// if un in ru_attackers then
12842: LD_VAR 0 1
12846: PUSH
12847: LD_EXP 51
12851: IN
12852: IFFALSE 12870
// ru_attackers := ru_attackers diff un ;
12854: LD_ADDR_EXP 51
12858: PUSH
12859: LD_EXP 51
12863: PUSH
12864: LD_VAR 0 1
12868: DIFF
12869: ST_TO_ADDR
// if un in ar_attackers then
12870: LD_VAR 0 1
12874: PUSH
12875: LD_EXP 10
12879: IN
12880: IFFALSE 12898
// ar_attackers := ar_attackers diff un ;
12882: LD_ADDR_EXP 10
12886: PUSH
12887: LD_EXP 10
12891: PUSH
12892: LD_VAR 0 1
12896: DIFF
12897: ST_TO_ADDR
// if un = JMM then
12898: LD_VAR 0 1
12902: PUSH
12903: LD_EXP 14
12907: EQUAL
12908: IFFALSE 12919
// begin YouLost ( JMM ) ;
12910: LD_STRING JMM
12912: PPUSH
12913: CALL_OW 104
// exit ;
12917: GO 13008
// end ; if un = Burlak then
12919: LD_VAR 0 1
12923: PUSH
12924: LD_EXP 45
12928: EQUAL
12929: IFFALSE 12940
// begin YouLost ( Burlak ) ;
12931: LD_STRING Burlak
12933: PPUSH
12934: CALL_OW 104
// exit ;
12938: GO 13008
// end ; if un = freedom then
12940: LD_VAR 0 1
12944: PUSH
12945: LD_EXP 3
12949: EQUAL
12950: IFFALSE 12961
// begin YouLost ( Destroyed ) ;
12952: LD_STRING Destroyed
12954: PPUSH
12955: CALL_OW 104
// exit ;
12959: GO 13008
// end ; if un = Masha then
12961: LD_VAR 0 1
12965: PUSH
12966: LD_EXP 48
12970: EQUAL
12971: IFFALSE 12980
// ChangeMissionObjectives ( M4b ) ;
12973: LD_STRING M4b
12975: PPUSH
12976: CALL_OW 337
// if un = Mastodont then
12980: LD_VAR 0 1
12984: PUSH
12985: LD_EXP 55
12989: EQUAL
12990: IFFALSE 12999
// ChangeMissionObjectives ( M4a ) ;
12992: LD_STRING M4a
12994: PPUSH
12995: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12999: LD_VAR 0 1
13003: PPUSH
13004: CALL 82092 0 1
// end ;
13008: PPOPN 3
13010: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13011: LD_VAR 0 1
13015: PPUSH
13016: LD_VAR 0 2
13020: PPUSH
13021: CALL 84071 0 2
// end ;
13025: PPOPN 2
13027: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13028: LD_VAR 0 1
13032: PPUSH
13033: CALL 83139 0 1
// end ;
13037: PPOPN 1
13039: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13040: LD_VAR 0 1
13044: PUSH
13045: LD_INT 22
13047: PUSH
13048: LD_INT 7
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PUSH
13055: LD_INT 30
13057: PUSH
13058: LD_INT 0
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PPUSH
13069: CALL_OW 69
13073: IN
13074: IFFALSE 13113
// begin SetBName ( building , freedom ) ;
13076: LD_VAR 0 1
13080: PPUSH
13081: LD_STRING freedom
13083: PPUSH
13084: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13088: LD_INT 0
13090: PPUSH
13091: LD_INT 7
13093: PPUSH
13094: LD_INT 0
13096: PPUSH
13097: CALL_OW 324
// freedom := building ;
13101: LD_ADDR_EXP 3
13105: PUSH
13106: LD_VAR 0 1
13110: ST_TO_ADDR
// exit ;
13111: GO 13179
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13113: LD_VAR 0 1
13117: PUSH
13118: LD_INT 22
13120: PUSH
13121: LD_INT 7
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 23
13130: PUSH
13131: LD_INT 3
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: LD_INT 30
13140: PUSH
13141: LD_INT 6
13143: PUSH
13144: EMPTY
13145: LIST
13146: LIST
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: PPUSH
13153: CALL_OW 69
13157: IN
13158: IFFALSE 13170
// begin ru_lab_builded := true ;
13160: LD_ADDR_EXP 5
13164: PUSH
13165: LD_INT 1
13167: ST_TO_ADDR
// exit ;
13168: GO 13179
// end ; MCE_BuildingComplete ( building ) ;
13170: LD_VAR 0 1
13174: PPUSH
13175: CALL 83380 0 1
// end ;
13179: PPOPN 1
13181: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13182: LD_VAR 0 1
13186: PPUSH
13187: LD_VAR 0 2
13191: PPUSH
13192: CALL 81788 0 2
// end ;
13196: PPOPN 2
13198: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13199: LD_VAR 0 1
13203: PPUSH
13204: LD_VAR 0 2
13208: PPUSH
13209: LD_VAR 0 3
13213: PPUSH
13214: LD_VAR 0 4
13218: PPUSH
13219: LD_VAR 0 5
13223: PPUSH
13224: CALL 81408 0 5
// end ;
13228: PPOPN 5
13230: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13231: LD_VAR 0 1
13235: PPUSH
13236: LD_VAR 0 2
13240: PPUSH
13241: CALL 80998 0 2
// end ;
13245: PPOPN 2
13247: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13248: LD_VAR 0 1
13252: PPUSH
13253: LD_VAR 0 2
13257: PPUSH
13258: LD_VAR 0 3
13262: PPUSH
13263: LD_VAR 0 4
13267: PPUSH
13268: CALL 80836 0 4
// end ;
13272: PPOPN 4
13274: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: LD_VAR 0 2
13284: PPUSH
13285: LD_VAR 0 3
13289: PPUSH
13290: CALL 80611 0 3
// end ;
13294: PPOPN 3
13296: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13297: LD_VAR 0 1
13301: PPUSH
13302: LD_VAR 0 2
13306: PPUSH
13307: CALL 80496 0 2
// end ;
13311: PPOPN 2
13313: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13314: LD_VAR 0 1
13318: PPUSH
13319: LD_VAR 0 2
13323: PPUSH
13324: CALL 84332 0 2
// end ;
13328: PPOPN 2
13330: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13331: LD_VAR 0 1
13335: PPUSH
13336: LD_VAR 0 2
13340: PPUSH
13341: LD_VAR 0 3
13345: PPUSH
13346: LD_VAR 0 4
13350: PPUSH
13351: CALL 84548 0 4
// end ;
13355: PPOPN 4
13357: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13358: LD_VAR 0 1
13362: PPUSH
13363: LD_VAR 0 2
13367: PPUSH
13368: CALL 80305 0 2
// end ; end_of_file
13372: PPOPN 2
13374: END
// every 0 0$30 do var cr , time ;
13375: GO 13377
13377: DISABLE
13378: LD_INT 0
13380: PPUSH
13381: PPUSH
// begin time := 0 0$30 ;
13382: LD_ADDR_VAR 0 2
13386: PUSH
13387: LD_INT 1050
13389: ST_TO_ADDR
// while game do
13390: LD_EXP 2
13394: IFFALSE 13493
// begin wait ( time ) ;
13396: LD_VAR 0 2
13400: PPUSH
13401: CALL_OW 67
// if tick > 2 2$00 then
13405: LD_OWVAR 1
13409: PUSH
13410: LD_INT 4200
13412: GREATER
13413: IFFALSE 13446
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13415: LD_ADDR_VAR 0 2
13419: PUSH
13420: LD_VAR 0 2
13424: PUSH
13425: LD_INT 280
13427: PUSH
13428: LD_INT 420
13430: PUSH
13431: LD_INT 630
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: LIST
13438: PUSH
13439: LD_OWVAR 67
13443: ARRAY
13444: PLUS
13445: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13446: LD_INT 1
13448: PPUSH
13449: LD_INT 5
13451: PPUSH
13452: CALL_OW 12
13456: PPUSH
13457: LD_INT 70
13459: PPUSH
13460: LD_INT 49
13462: PPUSH
13463: LD_INT 25
13465: PPUSH
13466: LD_INT 1
13468: PPUSH
13469: CALL_OW 56
// if time > 5 5$00 then
13473: LD_VAR 0 2
13477: PUSH
13478: LD_INT 10500
13480: GREATER
13481: IFFALSE 13491
// time := 0 0$30 ;
13483: LD_ADDR_VAR 0 2
13487: PUSH
13488: LD_INT 1050
13490: ST_TO_ADDR
// end ;
13491: GO 13390
// end ;
13493: PPOPN 2
13495: END
// every 0 0$30 do var cr , time ;
13496: GO 13498
13498: DISABLE
13499: LD_INT 0
13501: PPUSH
13502: PPUSH
// begin time := 0 0$20 ;
13503: LD_ADDR_VAR 0 2
13507: PUSH
13508: LD_INT 700
13510: ST_TO_ADDR
// while game do
13511: LD_EXP 2
13515: IFFALSE 13604
// begin wait ( time ) ;
13517: LD_VAR 0 2
13521: PPUSH
13522: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13526: LD_ADDR_VAR 0 2
13530: PUSH
13531: LD_VAR 0 2
13535: PUSH
13536: LD_INT 490
13538: PUSH
13539: LD_INT 525
13541: PUSH
13542: LD_INT 560
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: LIST
13549: PUSH
13550: LD_OWVAR 67
13554: ARRAY
13555: PLUS
13556: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13557: LD_INT 3
13559: PPUSH
13560: LD_INT 5
13562: PPUSH
13563: CALL_OW 12
13567: PPUSH
13568: LD_INT 26
13570: PPUSH
13571: LD_INT 9
13573: PPUSH
13574: LD_INT 30
13576: PPUSH
13577: LD_INT 1
13579: PPUSH
13580: CALL_OW 56
// if time > 3 3$00 then
13584: LD_VAR 0 2
13588: PUSH
13589: LD_INT 6300
13591: GREATER
13592: IFFALSE 13602
// time := 0 0$20 ;
13594: LD_ADDR_VAR 0 2
13598: PUSH
13599: LD_INT 700
13601: ST_TO_ADDR
// end ;
13602: GO 13511
// end ;
13604: PPOPN 2
13606: END
// every 0 0$30 do var cr , time ;
13607: GO 13609
13609: DISABLE
13610: LD_INT 0
13612: PPUSH
13613: PPUSH
// begin time := 0 0$20 ;
13614: LD_ADDR_VAR 0 2
13618: PUSH
13619: LD_INT 700
13621: ST_TO_ADDR
// while game do
13622: LD_EXP 2
13626: IFFALSE 13751
// begin wait ( time ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13637: LD_ADDR_VAR 0 2
13641: PUSH
13642: LD_VAR 0 2
13646: PUSH
13647: LD_INT 175
13649: PUSH
13650: LD_INT 210
13652: PUSH
13653: LD_INT 280
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: LIST
13660: PUSH
13661: LD_OWVAR 67
13665: ARRAY
13666: PLUS
13667: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13668: LD_INT 1
13670: PPUSH
13671: LD_INT 5
13673: PPUSH
13674: CALL_OW 12
13678: PPUSH
13679: LD_INT 179
13681: PPUSH
13682: LD_INT 101
13684: PPUSH
13685: LD_INT 20
13687: PPUSH
13688: LD_INT 1
13690: PPUSH
13691: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13695: LD_INT 350
13697: PPUSH
13698: LD_INT 525
13700: PPUSH
13701: CALL_OW 12
13705: PPUSH
13706: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13710: LD_INT 1
13712: PPUSH
13713: LD_INT 5
13715: PPUSH
13716: CALL_OW 12
13720: PPUSH
13721: LD_INT 9
13723: PPUSH
13724: LD_INT 1
13726: PPUSH
13727: CALL_OW 55
// if time > 4 4$00 then
13731: LD_VAR 0 2
13735: PUSH
13736: LD_INT 8400
13738: GREATER
13739: IFFALSE 13749
// time := 0 0$30 ;
13741: LD_ADDR_VAR 0 2
13745: PUSH
13746: LD_INT 1050
13748: ST_TO_ADDR
// end ;
13749: GO 13622
// end ;
13751: PPOPN 2
13753: END
// every 0 0$30 do var cr , time ;
13754: GO 13756
13756: DISABLE
13757: LD_INT 0
13759: PPUSH
13760: PPUSH
// begin time := 0 0$10 ;
13761: LD_ADDR_VAR 0 2
13765: PUSH
13766: LD_INT 350
13768: ST_TO_ADDR
// while game do
13769: LD_EXP 2
13773: IFFALSE 13907
// begin wait ( time ) ;
13775: LD_VAR 0 2
13779: PPUSH
13780: CALL_OW 67
// time := time + 0 0$10 ;
13784: LD_ADDR_VAR 0 2
13788: PUSH
13789: LD_VAR 0 2
13793: PUSH
13794: LD_INT 350
13796: PLUS
13797: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13798: LD_INT 1
13800: PPUSH
13801: LD_INT 5
13803: PPUSH
13804: CALL_OW 12
13808: PPUSH
13809: LD_INT 11
13811: PPUSH
13812: LD_INT 1
13814: PPUSH
13815: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13819: LD_ADDR_VAR 0 1
13823: PUSH
13824: LD_INT 1
13826: PPUSH
13827: LD_INT 3
13829: PPUSH
13830: CALL_OW 12
13834: ST_TO_ADDR
// if cr = 1 then
13835: LD_VAR 0 1
13839: PUSH
13840: LD_INT 1
13842: EQUAL
13843: IFFALSE 13887
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13845: LD_INT 700
13847: PPUSH
13848: LD_INT 1575
13850: PPUSH
13851: CALL_OW 12
13855: PPUSH
13856: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13860: LD_INT 1
13862: PPUSH
13863: LD_INT 5
13865: PPUSH
13866: CALL_OW 12
13870: PPUSH
13871: LD_INT 34
13873: PPUSH
13874: LD_INT 50
13876: PPUSH
13877: LD_INT 7
13879: PPUSH
13880: LD_INT 1
13882: PPUSH
13883: CALL_OW 56
// end ; if time > 8 8$00 then
13887: LD_VAR 0 2
13891: PUSH
13892: LD_INT 16800
13894: GREATER
13895: IFFALSE 13905
// time := 0 0$40 ;
13897: LD_ADDR_VAR 0 2
13901: PUSH
13902: LD_INT 1400
13904: ST_TO_ADDR
// end ;
13905: GO 13769
// end ; end_of_file
13907: PPOPN 2
13909: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13910: LD_INT 0
13912: PPUSH
13913: PPUSH
// if exist_mode then
13914: LD_VAR 0 2
13918: IFFALSE 13943
// unit := CreateCharacter ( prefix & ident ) else
13920: LD_ADDR_VAR 0 5
13924: PUSH
13925: LD_VAR 0 3
13929: PUSH
13930: LD_VAR 0 1
13934: STR
13935: PPUSH
13936: CALL_OW 34
13940: ST_TO_ADDR
13941: GO 13958
// unit := NewCharacter ( ident ) ;
13943: LD_ADDR_VAR 0 5
13947: PUSH
13948: LD_VAR 0 1
13952: PPUSH
13953: CALL_OW 25
13957: ST_TO_ADDR
// result := unit ;
13958: LD_ADDR_VAR 0 4
13962: PUSH
13963: LD_VAR 0 5
13967: ST_TO_ADDR
// end ;
13968: LD_VAR 0 4
13972: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13973: LD_INT 0
13975: PPUSH
13976: PPUSH
// if not side or not nation then
13977: LD_VAR 0 1
13981: NOT
13982: PUSH
13983: LD_VAR 0 2
13987: NOT
13988: OR
13989: IFFALSE 13993
// exit ;
13991: GO 14629
// case nation of nation_american :
13993: LD_VAR 0 2
13997: PUSH
13998: LD_INT 1
14000: DOUBLE
14001: EQUAL
14002: IFTRUE 14006
14004: GO 14176
14006: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
14007: LD_ADDR_VAR 0 4
14011: PUSH
14012: LD_INT 35
14014: PUSH
14015: LD_INT 45
14017: PUSH
14018: LD_INT 46
14020: PUSH
14021: LD_INT 47
14023: PUSH
14024: LD_INT 1
14026: PUSH
14027: LD_INT 2
14029: PUSH
14030: LD_INT 6
14032: PUSH
14033: LD_INT 15
14035: PUSH
14036: LD_INT 16
14038: PUSH
14039: LD_INT 7
14041: PUSH
14042: LD_INT 12
14044: PUSH
14045: LD_INT 13
14047: PUSH
14048: LD_INT 10
14050: PUSH
14051: LD_INT 14
14053: PUSH
14054: LD_INT 20
14056: PUSH
14057: LD_INT 21
14059: PUSH
14060: LD_INT 22
14062: PUSH
14063: LD_INT 25
14065: PUSH
14066: LD_INT 32
14068: PUSH
14069: LD_INT 27
14071: PUSH
14072: LD_INT 36
14074: PUSH
14075: LD_INT 69
14077: PUSH
14078: LD_INT 39
14080: PUSH
14081: LD_INT 34
14083: PUSH
14084: LD_INT 40
14086: PUSH
14087: LD_INT 48
14089: PUSH
14090: LD_INT 49
14092: PUSH
14093: LD_INT 50
14095: PUSH
14096: LD_INT 51
14098: PUSH
14099: LD_INT 52
14101: PUSH
14102: LD_INT 53
14104: PUSH
14105: LD_INT 54
14107: PUSH
14108: LD_INT 55
14110: PUSH
14111: LD_INT 56
14113: PUSH
14114: LD_INT 57
14116: PUSH
14117: LD_INT 58
14119: PUSH
14120: LD_INT 59
14122: PUSH
14123: LD_INT 60
14125: PUSH
14126: LD_INT 61
14128: PUSH
14129: LD_INT 62
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: ST_TO_ADDR
14174: GO 14553
14176: LD_INT 2
14178: DOUBLE
14179: EQUAL
14180: IFTRUE 14184
14182: GO 14362
14184: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14185: LD_ADDR_VAR 0 4
14189: PUSH
14190: LD_INT 35
14192: PUSH
14193: LD_INT 45
14195: PUSH
14196: LD_INT 46
14198: PUSH
14199: LD_INT 47
14201: PUSH
14202: LD_INT 70
14204: PUSH
14205: LD_INT 1
14207: PUSH
14208: LD_INT 11
14210: PUSH
14211: LD_INT 3
14213: PUSH
14214: LD_INT 4
14216: PUSH
14217: LD_INT 5
14219: PUSH
14220: LD_INT 6
14222: PUSH
14223: LD_INT 15
14225: PUSH
14226: LD_INT 18
14228: PUSH
14229: LD_INT 7
14231: PUSH
14232: LD_INT 17
14234: PUSH
14235: LD_INT 8
14237: PUSH
14238: LD_INT 20
14240: PUSH
14241: LD_INT 21
14243: PUSH
14244: LD_INT 22
14246: PUSH
14247: LD_INT 72
14249: PUSH
14250: LD_INT 26
14252: PUSH
14253: LD_INT 69
14255: PUSH
14256: LD_INT 39
14258: PUSH
14259: LD_INT 40
14261: PUSH
14262: LD_INT 41
14264: PUSH
14265: LD_INT 42
14267: PUSH
14268: LD_INT 43
14270: PUSH
14271: LD_INT 48
14273: PUSH
14274: LD_INT 49
14276: PUSH
14277: LD_INT 50
14279: PUSH
14280: LD_INT 51
14282: PUSH
14283: LD_INT 52
14285: PUSH
14286: LD_INT 53
14288: PUSH
14289: LD_INT 54
14291: PUSH
14292: LD_INT 55
14294: PUSH
14295: LD_INT 56
14297: PUSH
14298: LD_INT 60
14300: PUSH
14301: LD_INT 61
14303: PUSH
14304: LD_INT 62
14306: PUSH
14307: LD_INT 66
14309: PUSH
14310: LD_INT 67
14312: PUSH
14313: LD_INT 68
14315: PUSH
14316: EMPTY
14317: LIST
14318: LIST
14319: LIST
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: ST_TO_ADDR
14360: GO 14553
14362: LD_INT 3
14364: DOUBLE
14365: EQUAL
14366: IFTRUE 14370
14368: GO 14552
14370: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14371: LD_ADDR_VAR 0 4
14375: PUSH
14376: LD_INT 46
14378: PUSH
14379: LD_INT 47
14381: PUSH
14382: LD_INT 1
14384: PUSH
14385: LD_INT 2
14387: PUSH
14388: LD_INT 11
14390: PUSH
14391: LD_INT 9
14393: PUSH
14394: LD_INT 20
14396: PUSH
14397: LD_INT 19
14399: PUSH
14400: LD_INT 21
14402: PUSH
14403: LD_INT 24
14405: PUSH
14406: LD_INT 22
14408: PUSH
14409: LD_INT 25
14411: PUSH
14412: LD_INT 28
14414: PUSH
14415: LD_INT 29
14417: PUSH
14418: LD_INT 30
14420: PUSH
14421: LD_INT 31
14423: PUSH
14424: LD_INT 37
14426: PUSH
14427: LD_INT 38
14429: PUSH
14430: LD_INT 32
14432: PUSH
14433: LD_INT 27
14435: PUSH
14436: LD_INT 33
14438: PUSH
14439: LD_INT 69
14441: PUSH
14442: LD_INT 39
14444: PUSH
14445: LD_INT 34
14447: PUSH
14448: LD_INT 40
14450: PUSH
14451: LD_INT 71
14453: PUSH
14454: LD_INT 23
14456: PUSH
14457: LD_INT 44
14459: PUSH
14460: LD_INT 48
14462: PUSH
14463: LD_INT 49
14465: PUSH
14466: LD_INT 50
14468: PUSH
14469: LD_INT 51
14471: PUSH
14472: LD_INT 52
14474: PUSH
14475: LD_INT 53
14477: PUSH
14478: LD_INT 54
14480: PUSH
14481: LD_INT 55
14483: PUSH
14484: LD_INT 56
14486: PUSH
14487: LD_INT 57
14489: PUSH
14490: LD_INT 58
14492: PUSH
14493: LD_INT 59
14495: PUSH
14496: LD_INT 63
14498: PUSH
14499: LD_INT 64
14501: PUSH
14502: LD_INT 65
14504: PUSH
14505: EMPTY
14506: LIST
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: ST_TO_ADDR
14550: GO 14553
14552: POP
// if state > - 1 and state < 3 then
14553: LD_VAR 0 3
14557: PUSH
14558: LD_INT 1
14560: NEG
14561: GREATER
14562: PUSH
14563: LD_VAR 0 3
14567: PUSH
14568: LD_INT 3
14570: LESS
14571: AND
14572: IFFALSE 14629
// for i in result do
14574: LD_ADDR_VAR 0 5
14578: PUSH
14579: LD_VAR 0 4
14583: PUSH
14584: FOR_IN
14585: IFFALSE 14627
// if GetTech ( i , side ) <> state then
14587: LD_VAR 0 5
14591: PPUSH
14592: LD_VAR 0 1
14596: PPUSH
14597: CALL_OW 321
14601: PUSH
14602: LD_VAR 0 3
14606: NONEQUAL
14607: IFFALSE 14625
// result := result diff i ;
14609: LD_ADDR_VAR 0 4
14613: PUSH
14614: LD_VAR 0 4
14618: PUSH
14619: LD_VAR 0 5
14623: DIFF
14624: ST_TO_ADDR
14625: GO 14584
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 4
14633: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14634: LD_INT 0
14636: PPUSH
14637: PPUSH
14638: PPUSH
// result := true ;
14639: LD_ADDR_VAR 0 3
14643: PUSH
14644: LD_INT 1
14646: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14647: LD_ADDR_VAR 0 5
14651: PUSH
14652: LD_VAR 0 2
14656: PPUSH
14657: CALL_OW 480
14661: ST_TO_ADDR
// if not tmp then
14662: LD_VAR 0 5
14666: NOT
14667: IFFALSE 14671
// exit ;
14669: GO 14720
// for i in tmp do
14671: LD_ADDR_VAR 0 4
14675: PUSH
14676: LD_VAR 0 5
14680: PUSH
14681: FOR_IN
14682: IFFALSE 14718
// if GetTech ( i , side ) <> state_researched then
14684: LD_VAR 0 4
14688: PPUSH
14689: LD_VAR 0 1
14693: PPUSH
14694: CALL_OW 321
14698: PUSH
14699: LD_INT 2
14701: NONEQUAL
14702: IFFALSE 14716
// begin result := false ;
14704: LD_ADDR_VAR 0 3
14708: PUSH
14709: LD_INT 0
14711: ST_TO_ADDR
// exit ;
14712: POP
14713: POP
14714: GO 14720
// end ;
14716: GO 14681
14718: POP
14719: POP
// end ;
14720: LD_VAR 0 3
14724: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14725: LD_INT 0
14727: PPUSH
14728: PPUSH
14729: PPUSH
14730: PPUSH
14731: PPUSH
14732: PPUSH
14733: PPUSH
14734: PPUSH
14735: PPUSH
14736: PPUSH
14737: PPUSH
14738: PPUSH
14739: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14740: LD_VAR 0 1
14744: NOT
14745: PUSH
14746: LD_VAR 0 1
14750: PPUSH
14751: CALL_OW 257
14755: PUSH
14756: LD_INT 9
14758: NONEQUAL
14759: OR
14760: IFFALSE 14764
// exit ;
14762: GO 15337
// side := GetSide ( unit ) ;
14764: LD_ADDR_VAR 0 9
14768: PUSH
14769: LD_VAR 0 1
14773: PPUSH
14774: CALL_OW 255
14778: ST_TO_ADDR
// tech_space := tech_spacanom ;
14779: LD_ADDR_VAR 0 12
14783: PUSH
14784: LD_INT 29
14786: ST_TO_ADDR
// tech_time := tech_taurad ;
14787: LD_ADDR_VAR 0 13
14791: PUSH
14792: LD_INT 28
14794: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14795: LD_ADDR_VAR 0 11
14799: PUSH
14800: LD_VAR 0 1
14804: PPUSH
14805: CALL_OW 310
14809: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14810: LD_VAR 0 11
14814: PPUSH
14815: CALL_OW 247
14819: PUSH
14820: LD_INT 2
14822: EQUAL
14823: IFFALSE 14827
// exit ;
14825: GO 15337
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14827: LD_ADDR_VAR 0 8
14831: PUSH
14832: LD_INT 81
14834: PUSH
14835: LD_VAR 0 9
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: PUSH
14844: LD_INT 3
14846: PUSH
14847: LD_INT 21
14849: PUSH
14850: LD_INT 3
14852: PUSH
14853: EMPTY
14854: LIST
14855: LIST
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PUSH
14861: EMPTY
14862: LIST
14863: LIST
14864: PPUSH
14865: CALL_OW 69
14869: ST_TO_ADDR
// if not tmp then
14870: LD_VAR 0 8
14874: NOT
14875: IFFALSE 14879
// exit ;
14877: GO 15337
// if in_unit then
14879: LD_VAR 0 11
14883: IFFALSE 14907
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14885: LD_ADDR_VAR 0 10
14889: PUSH
14890: LD_VAR 0 8
14894: PPUSH
14895: LD_VAR 0 11
14899: PPUSH
14900: CALL_OW 74
14904: ST_TO_ADDR
14905: GO 14927
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14907: LD_ADDR_VAR 0 10
14911: PUSH
14912: LD_VAR 0 8
14916: PPUSH
14917: LD_VAR 0 1
14921: PPUSH
14922: CALL_OW 74
14926: ST_TO_ADDR
// if not enemy then
14927: LD_VAR 0 10
14931: NOT
14932: IFFALSE 14936
// exit ;
14934: GO 15337
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14936: LD_VAR 0 11
14940: PUSH
14941: LD_VAR 0 11
14945: PPUSH
14946: LD_VAR 0 10
14950: PPUSH
14951: CALL_OW 296
14955: PUSH
14956: LD_INT 13
14958: GREATER
14959: AND
14960: PUSH
14961: LD_VAR 0 1
14965: PPUSH
14966: LD_VAR 0 10
14970: PPUSH
14971: CALL_OW 296
14975: PUSH
14976: LD_INT 12
14978: GREATER
14979: OR
14980: IFFALSE 14984
// exit ;
14982: GO 15337
// missile := [ 1 ] ;
14984: LD_ADDR_VAR 0 14
14988: PUSH
14989: LD_INT 1
14991: PUSH
14992: EMPTY
14993: LIST
14994: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14995: LD_VAR 0 9
14999: PPUSH
15000: LD_VAR 0 12
15004: PPUSH
15005: CALL_OW 325
15009: IFFALSE 15038
// missile := Insert ( missile , missile + 1 , 2 ) ;
15011: LD_ADDR_VAR 0 14
15015: PUSH
15016: LD_VAR 0 14
15020: PPUSH
15021: LD_VAR 0 14
15025: PUSH
15026: LD_INT 1
15028: PLUS
15029: PPUSH
15030: LD_INT 2
15032: PPUSH
15033: CALL_OW 2
15037: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15038: LD_VAR 0 9
15042: PPUSH
15043: LD_VAR 0 13
15047: PPUSH
15048: CALL_OW 325
15052: PUSH
15053: LD_VAR 0 10
15057: PPUSH
15058: CALL_OW 255
15062: PPUSH
15063: LD_VAR 0 13
15067: PPUSH
15068: CALL_OW 325
15072: NOT
15073: AND
15074: IFFALSE 15103
// missile := Insert ( missile , missile + 1 , 3 ) ;
15076: LD_ADDR_VAR 0 14
15080: PUSH
15081: LD_VAR 0 14
15085: PPUSH
15086: LD_VAR 0 14
15090: PUSH
15091: LD_INT 1
15093: PLUS
15094: PPUSH
15095: LD_INT 3
15097: PPUSH
15098: CALL_OW 2
15102: ST_TO_ADDR
// if missile < 2 then
15103: LD_VAR 0 14
15107: PUSH
15108: LD_INT 2
15110: LESS
15111: IFFALSE 15115
// exit ;
15113: GO 15337
// x := GetX ( enemy ) ;
15115: LD_ADDR_VAR 0 4
15119: PUSH
15120: LD_VAR 0 10
15124: PPUSH
15125: CALL_OW 250
15129: ST_TO_ADDR
// y := GetY ( enemy ) ;
15130: LD_ADDR_VAR 0 5
15134: PUSH
15135: LD_VAR 0 10
15139: PPUSH
15140: CALL_OW 251
15144: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15145: LD_ADDR_VAR 0 6
15149: PUSH
15150: LD_VAR 0 4
15154: PUSH
15155: LD_INT 1
15157: NEG
15158: PPUSH
15159: LD_INT 1
15161: PPUSH
15162: CALL_OW 12
15166: PLUS
15167: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15168: LD_ADDR_VAR 0 7
15172: PUSH
15173: LD_VAR 0 5
15177: PUSH
15178: LD_INT 1
15180: NEG
15181: PPUSH
15182: LD_INT 1
15184: PPUSH
15185: CALL_OW 12
15189: PLUS
15190: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15191: LD_VAR 0 6
15195: PPUSH
15196: LD_VAR 0 7
15200: PPUSH
15201: CALL_OW 488
15205: NOT
15206: IFFALSE 15228
// begin _x := x ;
15208: LD_ADDR_VAR 0 6
15212: PUSH
15213: LD_VAR 0 4
15217: ST_TO_ADDR
// _y := y ;
15218: LD_ADDR_VAR 0 7
15222: PUSH
15223: LD_VAR 0 5
15227: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15228: LD_ADDR_VAR 0 3
15232: PUSH
15233: LD_INT 1
15235: PPUSH
15236: LD_VAR 0 14
15240: PPUSH
15241: CALL_OW 12
15245: ST_TO_ADDR
// case i of 1 :
15246: LD_VAR 0 3
15250: PUSH
15251: LD_INT 1
15253: DOUBLE
15254: EQUAL
15255: IFTRUE 15259
15257: GO 15276
15259: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15260: LD_VAR 0 1
15264: PPUSH
15265: LD_VAR 0 10
15269: PPUSH
15270: CALL_OW 115
15274: GO 15337
15276: LD_INT 2
15278: DOUBLE
15279: EQUAL
15280: IFTRUE 15284
15282: GO 15306
15284: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15285: LD_VAR 0 1
15289: PPUSH
15290: LD_VAR 0 6
15294: PPUSH
15295: LD_VAR 0 7
15299: PPUSH
15300: CALL_OW 153
15304: GO 15337
15306: LD_INT 3
15308: DOUBLE
15309: EQUAL
15310: IFTRUE 15314
15312: GO 15336
15314: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15315: LD_VAR 0 1
15319: PPUSH
15320: LD_VAR 0 6
15324: PPUSH
15325: LD_VAR 0 7
15329: PPUSH
15330: CALL_OW 154
15334: GO 15337
15336: POP
// end ;
15337: LD_VAR 0 2
15341: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15342: LD_INT 0
15344: PPUSH
15345: PPUSH
15346: PPUSH
15347: PPUSH
15348: PPUSH
15349: PPUSH
// if not unit or not building then
15350: LD_VAR 0 1
15354: NOT
15355: PUSH
15356: LD_VAR 0 2
15360: NOT
15361: OR
15362: IFFALSE 15366
// exit ;
15364: GO 15524
// x := GetX ( building ) ;
15366: LD_ADDR_VAR 0 5
15370: PUSH
15371: LD_VAR 0 2
15375: PPUSH
15376: CALL_OW 250
15380: ST_TO_ADDR
// y := GetY ( building ) ;
15381: LD_ADDR_VAR 0 6
15385: PUSH
15386: LD_VAR 0 2
15390: PPUSH
15391: CALL_OW 251
15395: ST_TO_ADDR
// for i = 0 to 5 do
15396: LD_ADDR_VAR 0 4
15400: PUSH
15401: DOUBLE
15402: LD_INT 0
15404: DEC
15405: ST_TO_ADDR
15406: LD_INT 5
15408: PUSH
15409: FOR_TO
15410: IFFALSE 15522
// begin _x := ShiftX ( x , i , 3 ) ;
15412: LD_ADDR_VAR 0 7
15416: PUSH
15417: LD_VAR 0 5
15421: PPUSH
15422: LD_VAR 0 4
15426: PPUSH
15427: LD_INT 3
15429: PPUSH
15430: CALL_OW 272
15434: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15435: LD_ADDR_VAR 0 8
15439: PUSH
15440: LD_VAR 0 6
15444: PPUSH
15445: LD_VAR 0 4
15449: PPUSH
15450: LD_INT 3
15452: PPUSH
15453: CALL_OW 273
15457: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15458: LD_VAR 0 7
15462: PPUSH
15463: LD_VAR 0 8
15467: PPUSH
15468: CALL_OW 488
15472: NOT
15473: IFFALSE 15477
// continue ;
15475: GO 15409
// if HexInfo ( _x , _y ) = 0 then
15477: LD_VAR 0 7
15481: PPUSH
15482: LD_VAR 0 8
15486: PPUSH
15487: CALL_OW 428
15491: PUSH
15492: LD_INT 0
15494: EQUAL
15495: IFFALSE 15520
// begin ComMoveXY ( unit , _x , _y ) ;
15497: LD_VAR 0 1
15501: PPUSH
15502: LD_VAR 0 7
15506: PPUSH
15507: LD_VAR 0 8
15511: PPUSH
15512: CALL_OW 111
// exit ;
15516: POP
15517: POP
15518: GO 15524
// end ; end ;
15520: GO 15409
15522: POP
15523: POP
// end ;
15524: LD_VAR 0 3
15528: RET
// export function ScanBase ( side , base_area ) ; begin
15529: LD_INT 0
15531: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15532: LD_ADDR_VAR 0 3
15536: PUSH
15537: LD_VAR 0 2
15541: PPUSH
15542: LD_INT 81
15544: PUSH
15545: LD_VAR 0 1
15549: PUSH
15550: EMPTY
15551: LIST
15552: LIST
15553: PPUSH
15554: CALL_OW 70
15558: ST_TO_ADDR
// end ;
15559: LD_VAR 0 3
15563: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15564: LD_INT 0
15566: PPUSH
15567: PPUSH
15568: PPUSH
15569: PPUSH
15570: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15571: LD_VAR 0 1
15575: NOT
15576: PUSH
15577: LD_EXP 58
15581: PUSH
15582: LD_VAR 0 1
15586: ARRAY
15587: NOT
15588: OR
15589: PUSH
15590: LD_VAR 0 2
15594: NOT
15595: OR
15596: PUSH
15597: LD_VAR 0 3
15601: NOT
15602: OR
15603: IFFALSE 15607
// exit ;
15605: GO 16057
// side := mc_sides [ base ] ;
15607: LD_ADDR_VAR 0 6
15611: PUSH
15612: LD_EXP 84
15616: PUSH
15617: LD_VAR 0 1
15621: ARRAY
15622: ST_TO_ADDR
// if not side then
15623: LD_VAR 0 6
15627: NOT
15628: IFFALSE 15632
// exit ;
15630: GO 16057
// for i in solds do
15632: LD_ADDR_VAR 0 7
15636: PUSH
15637: LD_VAR 0 2
15641: PUSH
15642: FOR_IN
15643: IFFALSE 15704
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15645: LD_VAR 0 7
15649: PPUSH
15650: CALL_OW 310
15654: PPUSH
15655: CALL_OW 266
15659: PUSH
15660: LD_INT 32
15662: PUSH
15663: LD_INT 31
15665: PUSH
15666: EMPTY
15667: LIST
15668: LIST
15669: IN
15670: IFFALSE 15690
// solds := solds diff i else
15672: LD_ADDR_VAR 0 2
15676: PUSH
15677: LD_VAR 0 2
15681: PUSH
15682: LD_VAR 0 7
15686: DIFF
15687: ST_TO_ADDR
15688: GO 15702
// SetTag ( i , 18 ) ;
15690: LD_VAR 0 7
15694: PPUSH
15695: LD_INT 18
15697: PPUSH
15698: CALL_OW 109
15702: GO 15642
15704: POP
15705: POP
// if not solds then
15706: LD_VAR 0 2
15710: NOT
15711: IFFALSE 15715
// exit ;
15713: GO 16057
// repeat wait ( 0 0$1 ) ;
15715: LD_INT 35
15717: PPUSH
15718: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15722: LD_ADDR_VAR 0 5
15726: PUSH
15727: LD_VAR 0 6
15731: PPUSH
15732: LD_VAR 0 3
15736: PPUSH
15737: CALL 15529 0 2
15741: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15742: LD_VAR 0 5
15746: NOT
15747: PUSH
15748: LD_VAR 0 5
15752: PUSH
15753: LD_INT 3
15755: GREATER
15756: OR
15757: PUSH
15758: LD_EXP 80
15762: PUSH
15763: LD_VAR 0 1
15767: ARRAY
15768: OR
15769: IFFALSE 15810
// begin for i in solds do
15771: LD_ADDR_VAR 0 7
15775: PUSH
15776: LD_VAR 0 2
15780: PUSH
15781: FOR_IN
15782: IFFALSE 15806
// if HasTask ( i ) then
15784: LD_VAR 0 7
15788: PPUSH
15789: CALL_OW 314
15793: IFFALSE 15804
// ComStop ( i ) ;
15795: LD_VAR 0 7
15799: PPUSH
15800: CALL_OW 141
15804: GO 15781
15806: POP
15807: POP
// break ;
15808: GO 16045
// end ; for i in solds do
15810: LD_ADDR_VAR 0 7
15814: PUSH
15815: LD_VAR 0 2
15819: PUSH
15820: FOR_IN
15821: IFFALSE 16037
// begin if IsInUnit ( i ) then
15823: LD_VAR 0 7
15827: PPUSH
15828: CALL_OW 310
15832: IFFALSE 15843
// ComExitBuilding ( i ) ;
15834: LD_VAR 0 7
15838: PPUSH
15839: CALL_OW 122
// if GetLives ( i ) > 333 then
15843: LD_VAR 0 7
15847: PPUSH
15848: CALL_OW 256
15852: PUSH
15853: LD_INT 333
15855: GREATER
15856: IFFALSE 15884
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15858: LD_VAR 0 7
15862: PPUSH
15863: LD_VAR 0 5
15867: PPUSH
15868: LD_VAR 0 7
15872: PPUSH
15873: CALL_OW 74
15877: PPUSH
15878: CALL_OW 115
15882: GO 16035
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15884: LD_ADDR_VAR 0 8
15888: PUSH
15889: LD_EXP 58
15893: PUSH
15894: LD_VAR 0 1
15898: ARRAY
15899: PPUSH
15900: LD_INT 2
15902: PUSH
15903: LD_INT 30
15905: PUSH
15906: LD_INT 0
15908: PUSH
15909: EMPTY
15910: LIST
15911: LIST
15912: PUSH
15913: LD_INT 30
15915: PUSH
15916: LD_INT 1
15918: PUSH
15919: EMPTY
15920: LIST
15921: LIST
15922: PUSH
15923: LD_INT 30
15925: PUSH
15926: LD_INT 6
15928: PUSH
15929: EMPTY
15930: LIST
15931: LIST
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 72
15943: PPUSH
15944: LD_VAR 0 7
15948: PPUSH
15949: CALL_OW 74
15953: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15954: LD_VAR 0 7
15958: PPUSH
15959: LD_VAR 0 8
15963: PPUSH
15964: CALL_OW 250
15968: PPUSH
15969: LD_INT 3
15971: PPUSH
15972: LD_INT 5
15974: PPUSH
15975: CALL_OW 272
15979: PPUSH
15980: LD_VAR 0 8
15984: PPUSH
15985: CALL_OW 251
15989: PPUSH
15990: LD_INT 3
15992: PPUSH
15993: LD_INT 5
15995: PPUSH
15996: CALL_OW 273
16000: PPUSH
16001: CALL_OW 111
// SetTag ( i , 0 ) ;
16005: LD_VAR 0 7
16009: PPUSH
16010: LD_INT 0
16012: PPUSH
16013: CALL_OW 109
// solds := solds diff i ;
16017: LD_ADDR_VAR 0 2
16021: PUSH
16022: LD_VAR 0 2
16026: PUSH
16027: LD_VAR 0 7
16031: DIFF
16032: ST_TO_ADDR
// continue ;
16033: GO 15820
// end ; end ;
16035: GO 15820
16037: POP
16038: POP
// until solds ;
16039: LD_VAR 0 2
16043: IFFALSE 15715
// MC_Reset ( base , 18 ) ;
16045: LD_VAR 0 1
16049: PPUSH
16050: LD_INT 18
16052: PPUSH
16053: CALL 59556 0 2
// end ;
16057: LD_VAR 0 4
16061: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16062: LD_INT 0
16064: PPUSH
16065: PPUSH
16066: PPUSH
16067: PPUSH
16068: PPUSH
16069: PPUSH
16070: PPUSH
16071: PPUSH
16072: PPUSH
16073: PPUSH
16074: PPUSH
16075: PPUSH
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16080: LD_ADDR_VAR 0 12
16084: PUSH
16085: LD_EXP 58
16089: PUSH
16090: LD_VAR 0 1
16094: ARRAY
16095: PPUSH
16096: LD_INT 25
16098: PUSH
16099: LD_INT 3
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: PPUSH
16106: CALL_OW 72
16110: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16111: LD_ADDR_VAR 0 8
16115: PUSH
16116: LD_EXP 58
16120: PUSH
16121: LD_VAR 0 1
16125: ARRAY
16126: PPUSH
16127: LD_INT 2
16129: PUSH
16130: LD_INT 25
16132: PUSH
16133: LD_INT 1
16135: PUSH
16136: EMPTY
16137: LIST
16138: LIST
16139: PUSH
16140: LD_INT 25
16142: PUSH
16143: LD_INT 5
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: PUSH
16150: LD_INT 25
16152: PUSH
16153: LD_INT 8
16155: PUSH
16156: EMPTY
16157: LIST
16158: LIST
16159: PUSH
16160: LD_INT 25
16162: PUSH
16163: LD_INT 9
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: PUSH
16170: EMPTY
16171: LIST
16172: LIST
16173: LIST
16174: LIST
16175: LIST
16176: PPUSH
16177: CALL_OW 72
16181: ST_TO_ADDR
// if not defenders and not solds then
16182: LD_VAR 0 2
16186: NOT
16187: PUSH
16188: LD_VAR 0 8
16192: NOT
16193: AND
16194: IFFALSE 16198
// exit ;
16196: GO 17564
// depot_under_attack := false ;
16198: LD_ADDR_VAR 0 16
16202: PUSH
16203: LD_INT 0
16205: ST_TO_ADDR
// sold_defenders := [ ] ;
16206: LD_ADDR_VAR 0 17
16210: PUSH
16211: EMPTY
16212: ST_TO_ADDR
// if mechs then
16213: LD_VAR 0 12
16217: IFFALSE 16346
// for i in defenders do
16219: LD_ADDR_VAR 0 5
16223: PUSH
16224: LD_VAR 0 2
16228: PUSH
16229: FOR_IN
16230: IFFALSE 16344
// begin SetTag ( i , 20 ) ;
16232: LD_VAR 0 5
16236: PPUSH
16237: LD_INT 20
16239: PPUSH
16240: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16244: LD_VAR 0 5
16248: PPUSH
16249: CALL_OW 263
16253: PUSH
16254: LD_INT 1
16256: EQUAL
16257: PUSH
16258: LD_VAR 0 5
16262: PPUSH
16263: CALL_OW 311
16267: NOT
16268: AND
16269: PUSH
16270: LD_VAR 0 12
16274: AND
16275: IFFALSE 16342
// begin un := mechs [ 1 ] ;
16277: LD_ADDR_VAR 0 10
16281: PUSH
16282: LD_VAR 0 12
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16291: LD_VAR 0 10
16295: PPUSH
16296: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16300: LD_VAR 0 10
16304: PPUSH
16305: LD_VAR 0 5
16309: PPUSH
16310: CALL_OW 180
// SetTag ( un , 19 ) ;
16314: LD_VAR 0 10
16318: PPUSH
16319: LD_INT 19
16321: PPUSH
16322: CALL_OW 109
// mechs := mechs diff un ;
16326: LD_ADDR_VAR 0 12
16330: PUSH
16331: LD_VAR 0 12
16335: PUSH
16336: LD_VAR 0 10
16340: DIFF
16341: ST_TO_ADDR
// end ; end ;
16342: GO 16229
16344: POP
16345: POP
// if solds then
16346: LD_VAR 0 8
16350: IFFALSE 16409
// for i in solds do
16352: LD_ADDR_VAR 0 5
16356: PUSH
16357: LD_VAR 0 8
16361: PUSH
16362: FOR_IN
16363: IFFALSE 16407
// if not GetTag ( i ) then
16365: LD_VAR 0 5
16369: PPUSH
16370: CALL_OW 110
16374: NOT
16375: IFFALSE 16405
// begin defenders := defenders union i ;
16377: LD_ADDR_VAR 0 2
16381: PUSH
16382: LD_VAR 0 2
16386: PUSH
16387: LD_VAR 0 5
16391: UNION
16392: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16393: LD_VAR 0 5
16397: PPUSH
16398: LD_INT 18
16400: PPUSH
16401: CALL_OW 109
// end ;
16405: GO 16362
16407: POP
16408: POP
// repeat wait ( 0 0$1 ) ;
16409: LD_INT 35
16411: PPUSH
16412: CALL_OW 67
// enemy := mc_scan [ base ] ;
16416: LD_ADDR_VAR 0 3
16420: PUSH
16421: LD_EXP 81
16425: PUSH
16426: LD_VAR 0 1
16430: ARRAY
16431: ST_TO_ADDR
// for i in defenders do
16432: LD_ADDR_VAR 0 5
16436: PUSH
16437: LD_VAR 0 2
16441: PUSH
16442: FOR_IN
16443: IFFALSE 17128
// begin e := NearestUnitToUnit ( enemy , i ) ;
16445: LD_ADDR_VAR 0 13
16449: PUSH
16450: LD_VAR 0 3
16454: PPUSH
16455: LD_VAR 0 5
16459: PPUSH
16460: CALL_OW 74
16464: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16465: LD_ADDR_VAR 0 16
16469: PUSH
16470: LD_EXP 58
16474: PUSH
16475: LD_VAR 0 1
16479: ARRAY
16480: PPUSH
16481: LD_INT 2
16483: PUSH
16484: LD_INT 30
16486: PUSH
16487: LD_INT 0
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: PUSH
16494: LD_INT 30
16496: PUSH
16497: LD_INT 1
16499: PUSH
16500: EMPTY
16501: LIST
16502: LIST
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: LIST
16508: PPUSH
16509: CALL_OW 72
16513: NOT
16514: PUSH
16515: LD_EXP 58
16519: PUSH
16520: LD_VAR 0 1
16524: ARRAY
16525: PPUSH
16526: LD_INT 2
16528: PUSH
16529: LD_INT 30
16531: PUSH
16532: LD_INT 0
16534: PUSH
16535: EMPTY
16536: LIST
16537: LIST
16538: PUSH
16539: LD_INT 30
16541: PUSH
16542: LD_INT 1
16544: PUSH
16545: EMPTY
16546: LIST
16547: LIST
16548: PUSH
16549: EMPTY
16550: LIST
16551: LIST
16552: LIST
16553: PPUSH
16554: CALL_OW 72
16558: PPUSH
16559: CALL_OW 256
16563: PUSH
16564: LD_INT 600
16566: LESS
16567: OR
16568: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16569: LD_VAR 0 5
16573: PPUSH
16574: CALL_OW 247
16578: PUSH
16579: LD_INT 2
16581: DOUBLE
16582: EQUAL
16583: IFTRUE 16587
16585: GO 16834
16587: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16588: LD_VAR 0 5
16592: PPUSH
16593: CALL_OW 256
16597: PUSH
16598: LD_INT 650
16600: GREATER
16601: PUSH
16602: LD_VAR 0 5
16606: PPUSH
16607: LD_VAR 0 13
16611: PPUSH
16612: CALL_OW 296
16616: PUSH
16617: LD_INT 40
16619: LESS
16620: AND
16621: IFFALSE 16639
// ComAttackUnit ( i , e ) else
16623: LD_VAR 0 5
16627: PPUSH
16628: LD_VAR 0 13
16632: PPUSH
16633: CALL_OW 115
16637: GO 16717
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16639: LD_VAR 0 5
16643: PPUSH
16644: LD_VAR 0 13
16648: PPUSH
16649: CALL_OW 296
16653: PUSH
16654: LD_INT 30
16656: GREATEREQUAL
16657: PUSH
16658: LD_VAR 0 5
16662: PPUSH
16663: CALL_OW 256
16667: PUSH
16668: LD_INT 650
16670: LESSEQUAL
16671: OR
16672: PUSH
16673: LD_VAR 0 5
16677: PPUSH
16678: LD_EXP 82
16682: PUSH
16683: LD_VAR 0 1
16687: ARRAY
16688: PPUSH
16689: CALL_OW 308
16693: NOT
16694: AND
16695: IFFALSE 16717
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16697: LD_VAR 0 5
16701: PPUSH
16702: LD_EXP 82
16706: PUSH
16707: LD_VAR 0 1
16711: ARRAY
16712: PPUSH
16713: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16717: LD_VAR 0 5
16721: PPUSH
16722: CALL_OW 256
16726: PUSH
16727: LD_INT 998
16729: LESS
16730: PUSH
16731: LD_VAR 0 5
16735: PPUSH
16736: CALL_OW 263
16740: PUSH
16741: LD_INT 1
16743: EQUAL
16744: AND
16745: PUSH
16746: LD_VAR 0 5
16750: PPUSH
16751: CALL_OW 311
16755: AND
16756: PUSH
16757: LD_VAR 0 5
16761: PPUSH
16762: LD_EXP 82
16766: PUSH
16767: LD_VAR 0 1
16771: ARRAY
16772: PPUSH
16773: CALL_OW 308
16777: AND
16778: IFFALSE 16832
// begin mech := IsDrivenBy ( i ) ;
16780: LD_ADDR_VAR 0 9
16784: PUSH
16785: LD_VAR 0 5
16789: PPUSH
16790: CALL_OW 311
16794: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16795: LD_VAR 0 9
16799: PPUSH
16800: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16804: LD_VAR 0 9
16808: PPUSH
16809: LD_VAR 0 5
16813: PPUSH
16814: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16818: LD_VAR 0 9
16822: PPUSH
16823: LD_VAR 0 5
16827: PPUSH
16828: CALL_OW 180
// end ; end ; unit_human :
16832: GO 17099
16834: LD_INT 1
16836: DOUBLE
16837: EQUAL
16838: IFTRUE 16842
16840: GO 17098
16842: POP
// begin b := IsInUnit ( i ) ;
16843: LD_ADDR_VAR 0 18
16847: PUSH
16848: LD_VAR 0 5
16852: PPUSH
16853: CALL_OW 310
16857: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16858: LD_ADDR_VAR 0 19
16862: PUSH
16863: LD_VAR 0 18
16867: NOT
16868: PUSH
16869: LD_VAR 0 18
16873: PPUSH
16874: CALL_OW 266
16878: PUSH
16879: LD_INT 32
16881: PUSH
16882: LD_INT 31
16884: PUSH
16885: EMPTY
16886: LIST
16887: LIST
16888: IN
16889: OR
16890: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16891: LD_VAR 0 16
16895: PUSH
16896: LD_VAR 0 2
16900: PPUSH
16901: LD_INT 21
16903: PUSH
16904: LD_INT 2
16906: PUSH
16907: EMPTY
16908: LIST
16909: LIST
16910: PPUSH
16911: CALL_OW 72
16915: PUSH
16916: LD_INT 1
16918: LESSEQUAL
16919: OR
16920: PUSH
16921: LD_VAR 0 19
16925: AND
16926: PUSH
16927: LD_VAR 0 5
16931: PUSH
16932: LD_VAR 0 17
16936: IN
16937: NOT
16938: AND
16939: IFFALSE 17032
// begin if b then
16941: LD_VAR 0 18
16945: IFFALSE 16994
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16947: LD_VAR 0 18
16951: PPUSH
16952: LD_VAR 0 3
16956: PPUSH
16957: LD_VAR 0 18
16961: PPUSH
16962: CALL_OW 74
16966: PPUSH
16967: CALL_OW 296
16971: PUSH
16972: LD_INT 10
16974: LESS
16975: PUSH
16976: LD_VAR 0 18
16980: PPUSH
16981: CALL_OW 461
16985: PUSH
16986: LD_INT 7
16988: NONEQUAL
16989: AND
16990: IFFALSE 16994
// continue ;
16992: GO 16442
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16994: LD_ADDR_VAR 0 17
16998: PUSH
16999: LD_VAR 0 17
17003: PPUSH
17004: LD_VAR 0 17
17008: PUSH
17009: LD_INT 1
17011: PLUS
17012: PPUSH
17013: LD_VAR 0 5
17017: PPUSH
17018: CALL_OW 1
17022: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17023: LD_VAR 0 5
17027: PPUSH
17028: CALL_OW 122
// end ; if sold_defenders then
17032: LD_VAR 0 17
17036: IFFALSE 17096
// if i in sold_defenders then
17038: LD_VAR 0 5
17042: PUSH
17043: LD_VAR 0 17
17047: IN
17048: IFFALSE 17096
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17050: LD_VAR 0 5
17054: PPUSH
17055: CALL_OW 314
17059: NOT
17060: PUSH
17061: LD_VAR 0 5
17065: PPUSH
17066: LD_VAR 0 13
17070: PPUSH
17071: CALL_OW 296
17075: PUSH
17076: LD_INT 30
17078: LESS
17079: AND
17080: IFFALSE 17096
// ComAttackUnit ( i , e ) ;
17082: LD_VAR 0 5
17086: PPUSH
17087: LD_VAR 0 13
17091: PPUSH
17092: CALL_OW 115
// end ; end ; end ;
17096: GO 17099
17098: POP
// if IsDead ( i ) then
17099: LD_VAR 0 5
17103: PPUSH
17104: CALL_OW 301
17108: IFFALSE 17126
// defenders := defenders diff i ;
17110: LD_ADDR_VAR 0 2
17114: PUSH
17115: LD_VAR 0 2
17119: PUSH
17120: LD_VAR 0 5
17124: DIFF
17125: ST_TO_ADDR
// end ;
17126: GO 16442
17128: POP
17129: POP
// until not enemy or not defenders ;
17130: LD_VAR 0 3
17134: NOT
17135: PUSH
17136: LD_VAR 0 2
17140: NOT
17141: OR
17142: IFFALSE 16409
// MC_Reset ( base , 18 ) ;
17144: LD_VAR 0 1
17148: PPUSH
17149: LD_INT 18
17151: PPUSH
17152: CALL 59556 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17156: LD_ADDR_VAR 0 2
17160: PUSH
17161: LD_VAR 0 2
17165: PUSH
17166: LD_VAR 0 2
17170: PPUSH
17171: LD_INT 2
17173: PUSH
17174: LD_INT 25
17176: PUSH
17177: LD_INT 1
17179: PUSH
17180: EMPTY
17181: LIST
17182: LIST
17183: PUSH
17184: LD_INT 25
17186: PUSH
17187: LD_INT 5
17189: PUSH
17190: EMPTY
17191: LIST
17192: LIST
17193: PUSH
17194: LD_INT 25
17196: PUSH
17197: LD_INT 8
17199: PUSH
17200: EMPTY
17201: LIST
17202: LIST
17203: PUSH
17204: LD_INT 25
17206: PUSH
17207: LD_INT 9
17209: PUSH
17210: EMPTY
17211: LIST
17212: LIST
17213: PUSH
17214: EMPTY
17215: LIST
17216: LIST
17217: LIST
17218: LIST
17219: LIST
17220: PPUSH
17221: CALL_OW 72
17225: DIFF
17226: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17227: LD_VAR 0 3
17231: NOT
17232: PUSH
17233: LD_VAR 0 2
17237: PPUSH
17238: LD_INT 21
17240: PUSH
17241: LD_INT 2
17243: PUSH
17244: EMPTY
17245: LIST
17246: LIST
17247: PPUSH
17248: CALL_OW 72
17252: AND
17253: IFFALSE 17515
// begin tmp := FilterByTag ( defenders , 19 ) ;
17255: LD_ADDR_VAR 0 11
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_INT 19
17267: PPUSH
17268: CALL 53862 0 2
17272: ST_TO_ADDR
// if tmp then
17273: LD_VAR 0 11
17277: IFFALSE 17347
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17279: LD_ADDR_VAR 0 11
17283: PUSH
17284: LD_VAR 0 11
17288: PPUSH
17289: LD_INT 25
17291: PUSH
17292: LD_INT 3
17294: PUSH
17295: EMPTY
17296: LIST
17297: LIST
17298: PPUSH
17299: CALL_OW 72
17303: ST_TO_ADDR
// if tmp then
17304: LD_VAR 0 11
17308: IFFALSE 17347
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17310: LD_ADDR_EXP 70
17314: PUSH
17315: LD_EXP 70
17319: PPUSH
17320: LD_VAR 0 1
17324: PPUSH
17325: LD_EXP 70
17329: PUSH
17330: LD_VAR 0 1
17334: ARRAY
17335: PUSH
17336: LD_VAR 0 11
17340: UNION
17341: PPUSH
17342: CALL_OW 1
17346: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17347: LD_VAR 0 1
17351: PPUSH
17352: LD_INT 19
17354: PPUSH
17355: CALL 59556 0 2
// repeat wait ( 0 0$1 ) ;
17359: LD_INT 35
17361: PPUSH
17362: CALL_OW 67
// for i in defenders do
17366: LD_ADDR_VAR 0 5
17370: PUSH
17371: LD_VAR 0 2
17375: PUSH
17376: FOR_IN
17377: IFFALSE 17466
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17379: LD_VAR 0 5
17383: PPUSH
17384: LD_EXP 82
17388: PUSH
17389: LD_VAR 0 1
17393: ARRAY
17394: PPUSH
17395: CALL_OW 308
17399: NOT
17400: IFFALSE 17424
// ComMoveToArea ( i , mc_parking [ base ] ) else
17402: LD_VAR 0 5
17406: PPUSH
17407: LD_EXP 82
17411: PUSH
17412: LD_VAR 0 1
17416: ARRAY
17417: PPUSH
17418: CALL_OW 113
17422: GO 17464
// if GetControl ( i ) = control_manual then
17424: LD_VAR 0 5
17428: PPUSH
17429: CALL_OW 263
17433: PUSH
17434: LD_INT 1
17436: EQUAL
17437: IFFALSE 17464
// if IsDrivenBy ( i ) then
17439: LD_VAR 0 5
17443: PPUSH
17444: CALL_OW 311
17448: IFFALSE 17464
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17450: LD_VAR 0 5
17454: PPUSH
17455: CALL_OW 311
17459: PPUSH
17460: CALL_OW 121
// end ;
17464: GO 17376
17466: POP
17467: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17468: LD_VAR 0 2
17472: PPUSH
17473: LD_INT 95
17475: PUSH
17476: LD_EXP 82
17480: PUSH
17481: LD_VAR 0 1
17485: ARRAY
17486: PUSH
17487: EMPTY
17488: LIST
17489: LIST
17490: PPUSH
17491: CALL_OW 72
17495: PUSH
17496: LD_VAR 0 2
17500: EQUAL
17501: PUSH
17502: LD_EXP 81
17506: PUSH
17507: LD_VAR 0 1
17511: ARRAY
17512: OR
17513: IFFALSE 17359
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17515: LD_ADDR_EXP 80
17519: PUSH
17520: LD_EXP 80
17524: PPUSH
17525: LD_VAR 0 1
17529: PPUSH
17530: LD_EXP 80
17534: PUSH
17535: LD_VAR 0 1
17539: ARRAY
17540: PUSH
17541: LD_VAR 0 2
17545: UNION
17546: PPUSH
17547: CALL_OW 1
17551: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17552: LD_VAR 0 1
17556: PPUSH
17557: LD_INT 20
17559: PPUSH
17560: CALL 59556 0 2
// end ;
17564: LD_VAR 0 4
17568: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17569: LD_INT 0
17571: PPUSH
17572: PPUSH
17573: PPUSH
17574: PPUSH
// result := false ;
17575: LD_ADDR_VAR 0 2
17579: PUSH
17580: LD_INT 0
17582: ST_TO_ADDR
// side := GetSide ( unit ) ;
17583: LD_ADDR_VAR 0 3
17587: PUSH
17588: LD_VAR 0 1
17592: PPUSH
17593: CALL_OW 255
17597: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17598: LD_ADDR_VAR 0 4
17602: PUSH
17603: LD_VAR 0 1
17607: PPUSH
17608: CALL_OW 248
17612: ST_TO_ADDR
// case nat of 1 :
17613: LD_VAR 0 4
17617: PUSH
17618: LD_INT 1
17620: DOUBLE
17621: EQUAL
17622: IFTRUE 17626
17624: GO 17637
17626: POP
// tech := tech_lassight ; 2 :
17627: LD_ADDR_VAR 0 5
17631: PUSH
17632: LD_INT 12
17634: ST_TO_ADDR
17635: GO 17676
17637: LD_INT 2
17639: DOUBLE
17640: EQUAL
17641: IFTRUE 17645
17643: GO 17656
17645: POP
// tech := tech_mortar ; 3 :
17646: LD_ADDR_VAR 0 5
17650: PUSH
17651: LD_INT 41
17653: ST_TO_ADDR
17654: GO 17676
17656: LD_INT 3
17658: DOUBLE
17659: EQUAL
17660: IFTRUE 17664
17662: GO 17675
17664: POP
// tech := tech_bazooka ; end ;
17665: LD_ADDR_VAR 0 5
17669: PUSH
17670: LD_INT 44
17672: ST_TO_ADDR
17673: GO 17676
17675: POP
// if Researched ( side , tech ) then
17676: LD_VAR 0 3
17680: PPUSH
17681: LD_VAR 0 5
17685: PPUSH
17686: CALL_OW 325
17690: IFFALSE 17717
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17692: LD_ADDR_VAR 0 2
17696: PUSH
17697: LD_INT 5
17699: PUSH
17700: LD_INT 8
17702: PUSH
17703: LD_INT 9
17705: PUSH
17706: EMPTY
17707: LIST
17708: LIST
17709: LIST
17710: PUSH
17711: LD_VAR 0 4
17715: ARRAY
17716: ST_TO_ADDR
// end ;
17717: LD_VAR 0 2
17721: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17722: LD_INT 0
17724: PPUSH
17725: PPUSH
17726: PPUSH
// if not mines then
17727: LD_VAR 0 2
17731: NOT
17732: IFFALSE 17736
// exit ;
17734: GO 17880
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17736: LD_ADDR_VAR 0 5
17740: PUSH
17741: LD_INT 81
17743: PUSH
17744: LD_VAR 0 1
17748: PUSH
17749: EMPTY
17750: LIST
17751: LIST
17752: PUSH
17753: LD_INT 3
17755: PUSH
17756: LD_INT 21
17758: PUSH
17759: LD_INT 3
17761: PUSH
17762: EMPTY
17763: LIST
17764: LIST
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: PPUSH
17774: CALL_OW 69
17778: ST_TO_ADDR
// for i in mines do
17779: LD_ADDR_VAR 0 4
17783: PUSH
17784: LD_VAR 0 2
17788: PUSH
17789: FOR_IN
17790: IFFALSE 17878
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17792: LD_VAR 0 4
17796: PUSH
17797: LD_INT 1
17799: ARRAY
17800: PPUSH
17801: LD_VAR 0 4
17805: PUSH
17806: LD_INT 2
17808: ARRAY
17809: PPUSH
17810: CALL_OW 458
17814: NOT
17815: IFFALSE 17819
// continue ;
17817: GO 17789
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17819: LD_VAR 0 4
17823: PUSH
17824: LD_INT 1
17826: ARRAY
17827: PPUSH
17828: LD_VAR 0 4
17832: PUSH
17833: LD_INT 2
17835: ARRAY
17836: PPUSH
17837: CALL_OW 428
17841: PUSH
17842: LD_VAR 0 5
17846: IN
17847: IFFALSE 17876
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17849: LD_VAR 0 4
17853: PUSH
17854: LD_INT 1
17856: ARRAY
17857: PPUSH
17858: LD_VAR 0 4
17862: PUSH
17863: LD_INT 2
17865: ARRAY
17866: PPUSH
17867: LD_VAR 0 1
17871: PPUSH
17872: CALL_OW 456
// end ;
17876: GO 17789
17878: POP
17879: POP
// end ;
17880: LD_VAR 0 3
17884: RET
// export function Count ( array ) ; var i ; begin
17885: LD_INT 0
17887: PPUSH
17888: PPUSH
// result := 0 ;
17889: LD_ADDR_VAR 0 2
17893: PUSH
17894: LD_INT 0
17896: ST_TO_ADDR
// for i in array do
17897: LD_ADDR_VAR 0 3
17901: PUSH
17902: LD_VAR 0 1
17906: PUSH
17907: FOR_IN
17908: IFFALSE 17932
// if i then
17910: LD_VAR 0 3
17914: IFFALSE 17930
// result := result + 1 ;
17916: LD_ADDR_VAR 0 2
17920: PUSH
17921: LD_VAR 0 2
17925: PUSH
17926: LD_INT 1
17928: PLUS
17929: ST_TO_ADDR
17930: GO 17907
17932: POP
17933: POP
// end ;
17934: LD_VAR 0 2
17938: RET
// export function IsEmpty ( building ) ; begin
17939: LD_INT 0
17941: PPUSH
// if not building then
17942: LD_VAR 0 1
17946: NOT
17947: IFFALSE 17951
// exit ;
17949: GO 17994
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17951: LD_ADDR_VAR 0 2
17955: PUSH
17956: LD_VAR 0 1
17960: PUSH
17961: LD_INT 22
17963: PUSH
17964: LD_VAR 0 1
17968: PPUSH
17969: CALL_OW 255
17973: PUSH
17974: EMPTY
17975: LIST
17976: LIST
17977: PUSH
17978: LD_INT 58
17980: PUSH
17981: EMPTY
17982: LIST
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: PPUSH
17988: CALL_OW 69
17992: IN
17993: ST_TO_ADDR
// end ;
17994: LD_VAR 0 2
17998: RET
// export function IsNotFull ( building ) ; begin
17999: LD_INT 0
18001: PPUSH
// if not building then
18002: LD_VAR 0 1
18006: NOT
18007: IFFALSE 18011
// exit ;
18009: GO 18030
// result := UnitsInside ( building ) < 6 ;
18011: LD_ADDR_VAR 0 2
18015: PUSH
18016: LD_VAR 0 1
18020: PPUSH
18021: CALL_OW 313
18025: PUSH
18026: LD_INT 6
18028: LESS
18029: ST_TO_ADDR
// end ;
18030: LD_VAR 0 2
18034: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18035: LD_INT 0
18037: PPUSH
18038: PPUSH
18039: PPUSH
18040: PPUSH
// tmp := [ ] ;
18041: LD_ADDR_VAR 0 3
18045: PUSH
18046: EMPTY
18047: ST_TO_ADDR
// list := [ ] ;
18048: LD_ADDR_VAR 0 5
18052: PUSH
18053: EMPTY
18054: ST_TO_ADDR
// for i = 16 to 25 do
18055: LD_ADDR_VAR 0 4
18059: PUSH
18060: DOUBLE
18061: LD_INT 16
18063: DEC
18064: ST_TO_ADDR
18065: LD_INT 25
18067: PUSH
18068: FOR_TO
18069: IFFALSE 18142
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18071: LD_ADDR_VAR 0 3
18075: PUSH
18076: LD_VAR 0 3
18080: PUSH
18081: LD_INT 22
18083: PUSH
18084: LD_VAR 0 1
18088: PPUSH
18089: CALL_OW 255
18093: PUSH
18094: EMPTY
18095: LIST
18096: LIST
18097: PUSH
18098: LD_INT 91
18100: PUSH
18101: LD_VAR 0 1
18105: PUSH
18106: LD_INT 6
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PUSH
18114: LD_INT 30
18116: PUSH
18117: LD_VAR 0 4
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: PUSH
18126: EMPTY
18127: LIST
18128: LIST
18129: LIST
18130: PUSH
18131: EMPTY
18132: LIST
18133: PPUSH
18134: CALL_OW 69
18138: ADD
18139: ST_TO_ADDR
18140: GO 18068
18142: POP
18143: POP
// for i = 1 to tmp do
18144: LD_ADDR_VAR 0 4
18148: PUSH
18149: DOUBLE
18150: LD_INT 1
18152: DEC
18153: ST_TO_ADDR
18154: LD_VAR 0 3
18158: PUSH
18159: FOR_TO
18160: IFFALSE 18248
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18162: LD_ADDR_VAR 0 5
18166: PUSH
18167: LD_VAR 0 5
18171: PUSH
18172: LD_VAR 0 3
18176: PUSH
18177: LD_VAR 0 4
18181: ARRAY
18182: PPUSH
18183: CALL_OW 266
18187: PUSH
18188: LD_VAR 0 3
18192: PUSH
18193: LD_VAR 0 4
18197: ARRAY
18198: PPUSH
18199: CALL_OW 250
18203: PUSH
18204: LD_VAR 0 3
18208: PUSH
18209: LD_VAR 0 4
18213: ARRAY
18214: PPUSH
18215: CALL_OW 251
18219: PUSH
18220: LD_VAR 0 3
18224: PUSH
18225: LD_VAR 0 4
18229: ARRAY
18230: PPUSH
18231: CALL_OW 254
18235: PUSH
18236: EMPTY
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: PUSH
18242: EMPTY
18243: LIST
18244: ADD
18245: ST_TO_ADDR
18246: GO 18159
18248: POP
18249: POP
// result := list ;
18250: LD_ADDR_VAR 0 2
18254: PUSH
18255: LD_VAR 0 5
18259: ST_TO_ADDR
// end ;
18260: LD_VAR 0 2
18264: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18265: LD_INT 0
18267: PPUSH
18268: PPUSH
18269: PPUSH
18270: PPUSH
18271: PPUSH
18272: PPUSH
18273: PPUSH
// if not factory then
18274: LD_VAR 0 1
18278: NOT
18279: IFFALSE 18283
// exit ;
18281: GO 18808
// if control = control_apeman then
18283: LD_VAR 0 4
18287: PUSH
18288: LD_INT 5
18290: EQUAL
18291: IFFALSE 18400
// begin tmp := UnitsInside ( factory ) ;
18293: LD_ADDR_VAR 0 8
18297: PUSH
18298: LD_VAR 0 1
18302: PPUSH
18303: CALL_OW 313
18307: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18308: LD_VAR 0 8
18312: PPUSH
18313: LD_INT 25
18315: PUSH
18316: LD_INT 12
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PPUSH
18323: CALL_OW 72
18327: NOT
18328: IFFALSE 18338
// control := control_manual ;
18330: LD_ADDR_VAR 0 4
18334: PUSH
18335: LD_INT 1
18337: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18338: LD_ADDR_VAR 0 8
18342: PUSH
18343: LD_VAR 0 1
18347: PPUSH
18348: CALL 18035 0 1
18352: ST_TO_ADDR
// if tmp then
18353: LD_VAR 0 8
18357: IFFALSE 18400
// begin for i in tmp do
18359: LD_ADDR_VAR 0 7
18363: PUSH
18364: LD_VAR 0 8
18368: PUSH
18369: FOR_IN
18370: IFFALSE 18398
// if i [ 1 ] = b_ext_radar then
18372: LD_VAR 0 7
18376: PUSH
18377: LD_INT 1
18379: ARRAY
18380: PUSH
18381: LD_INT 20
18383: EQUAL
18384: IFFALSE 18396
// begin control := control_remote ;
18386: LD_ADDR_VAR 0 4
18390: PUSH
18391: LD_INT 2
18393: ST_TO_ADDR
// break ;
18394: GO 18398
// end ;
18396: GO 18369
18398: POP
18399: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18400: LD_VAR 0 1
18404: PPUSH
18405: LD_VAR 0 2
18409: PPUSH
18410: LD_VAR 0 3
18414: PPUSH
18415: LD_VAR 0 4
18419: PPUSH
18420: LD_VAR 0 5
18424: PPUSH
18425: CALL_OW 448
18429: IFFALSE 18464
// begin result := [ chassis , engine , control , weapon ] ;
18431: LD_ADDR_VAR 0 6
18435: PUSH
18436: LD_VAR 0 2
18440: PUSH
18441: LD_VAR 0 3
18445: PUSH
18446: LD_VAR 0 4
18450: PUSH
18451: LD_VAR 0 5
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: ST_TO_ADDR
// exit ;
18462: GO 18808
// end ; _chassis := AvailableChassisList ( factory ) ;
18464: LD_ADDR_VAR 0 9
18468: PUSH
18469: LD_VAR 0 1
18473: PPUSH
18474: CALL_OW 475
18478: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18479: LD_ADDR_VAR 0 11
18483: PUSH
18484: LD_VAR 0 1
18488: PPUSH
18489: CALL_OW 476
18493: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18494: LD_ADDR_VAR 0 12
18498: PUSH
18499: LD_VAR 0 1
18503: PPUSH
18504: CALL_OW 477
18508: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18509: LD_ADDR_VAR 0 10
18513: PUSH
18514: LD_VAR 0 1
18518: PPUSH
18519: CALL_OW 478
18523: ST_TO_ADDR
// if not chassis in _chassis then
18524: LD_VAR 0 2
18528: PUSH
18529: LD_VAR 0 9
18533: IN
18534: NOT
18535: IFFALSE 18561
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_VAR 0 9
18546: PUSH
18547: LD_INT 1
18549: PPUSH
18550: LD_VAR 0 9
18554: PPUSH
18555: CALL_OW 12
18559: ARRAY
18560: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18561: LD_VAR 0 2
18565: PPUSH
18566: LD_VAR 0 3
18570: PPUSH
18571: CALL 18813 0 2
18575: NOT
18576: IFFALSE 18635
// repeat engine := _engine [ 1 ] ;
18578: LD_ADDR_VAR 0 3
18582: PUSH
18583: LD_VAR 0 11
18587: PUSH
18588: LD_INT 1
18590: ARRAY
18591: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18592: LD_ADDR_VAR 0 11
18596: PUSH
18597: LD_VAR 0 11
18601: PPUSH
18602: LD_INT 1
18604: PPUSH
18605: CALL_OW 3
18609: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18610: LD_VAR 0 2
18614: PPUSH
18615: LD_VAR 0 3
18619: PPUSH
18620: CALL 18813 0 2
18624: PUSH
18625: LD_VAR 0 11
18629: PUSH
18630: EMPTY
18631: EQUAL
18632: OR
18633: IFFALSE 18578
// if not control in _control then
18635: LD_VAR 0 4
18639: PUSH
18640: LD_VAR 0 12
18644: IN
18645: NOT
18646: IFFALSE 18672
// control := _control [ rand ( 1 , _control ) ] ;
18648: LD_ADDR_VAR 0 4
18652: PUSH
18653: LD_VAR 0 12
18657: PUSH
18658: LD_INT 1
18660: PPUSH
18661: LD_VAR 0 12
18665: PPUSH
18666: CALL_OW 12
18670: ARRAY
18671: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18672: LD_VAR 0 2
18676: PPUSH
18677: LD_VAR 0 5
18681: PPUSH
18682: CALL 19033 0 2
18686: NOT
18687: IFFALSE 18746
// repeat weapon := _weapon [ 1 ] ;
18689: LD_ADDR_VAR 0 5
18693: PUSH
18694: LD_VAR 0 10
18698: PUSH
18699: LD_INT 1
18701: ARRAY
18702: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18703: LD_ADDR_VAR 0 10
18707: PUSH
18708: LD_VAR 0 10
18712: PPUSH
18713: LD_INT 1
18715: PPUSH
18716: CALL_OW 3
18720: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18721: LD_VAR 0 2
18725: PPUSH
18726: LD_VAR 0 5
18730: PPUSH
18731: CALL 19033 0 2
18735: PUSH
18736: LD_VAR 0 10
18740: PUSH
18741: EMPTY
18742: EQUAL
18743: OR
18744: IFFALSE 18689
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18746: LD_VAR 0 1
18750: PPUSH
18751: LD_VAR 0 2
18755: PPUSH
18756: LD_VAR 0 3
18760: PPUSH
18761: LD_VAR 0 4
18765: PPUSH
18766: LD_VAR 0 5
18770: PPUSH
18771: CALL_OW 448
18775: IFFALSE 18808
// result := [ chassis , engine , control , weapon ] ;
18777: LD_ADDR_VAR 0 6
18781: PUSH
18782: LD_VAR 0 2
18786: PUSH
18787: LD_VAR 0 3
18791: PUSH
18792: LD_VAR 0 4
18796: PUSH
18797: LD_VAR 0 5
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: ST_TO_ADDR
// end ;
18808: LD_VAR 0 6
18812: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18813: LD_INT 0
18815: PPUSH
// if not chassis or not engine then
18816: LD_VAR 0 1
18820: NOT
18821: PUSH
18822: LD_VAR 0 2
18826: NOT
18827: OR
18828: IFFALSE 18832
// exit ;
18830: GO 19028
// case engine of engine_solar :
18832: LD_VAR 0 2
18836: PUSH
18837: LD_INT 2
18839: DOUBLE
18840: EQUAL
18841: IFTRUE 18845
18843: GO 18883
18845: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18846: LD_ADDR_VAR 0 3
18850: PUSH
18851: LD_INT 11
18853: PUSH
18854: LD_INT 12
18856: PUSH
18857: LD_INT 13
18859: PUSH
18860: LD_INT 14
18862: PUSH
18863: LD_INT 1
18865: PUSH
18866: LD_INT 2
18868: PUSH
18869: LD_INT 3
18871: PUSH
18872: EMPTY
18873: LIST
18874: LIST
18875: LIST
18876: LIST
18877: LIST
18878: LIST
18879: LIST
18880: ST_TO_ADDR
18881: GO 19012
18883: LD_INT 1
18885: DOUBLE
18886: EQUAL
18887: IFTRUE 18891
18889: GO 18953
18891: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18892: LD_ADDR_VAR 0 3
18896: PUSH
18897: LD_INT 11
18899: PUSH
18900: LD_INT 12
18902: PUSH
18903: LD_INT 13
18905: PUSH
18906: LD_INT 14
18908: PUSH
18909: LD_INT 1
18911: PUSH
18912: LD_INT 2
18914: PUSH
18915: LD_INT 3
18917: PUSH
18918: LD_INT 4
18920: PUSH
18921: LD_INT 5
18923: PUSH
18924: LD_INT 21
18926: PUSH
18927: LD_INT 23
18929: PUSH
18930: LD_INT 22
18932: PUSH
18933: LD_INT 24
18935: PUSH
18936: EMPTY
18937: LIST
18938: LIST
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: LIST
18949: LIST
18950: ST_TO_ADDR
18951: GO 19012
18953: LD_INT 3
18955: DOUBLE
18956: EQUAL
18957: IFTRUE 18961
18959: GO 19011
18961: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18962: LD_ADDR_VAR 0 3
18966: PUSH
18967: LD_INT 13
18969: PUSH
18970: LD_INT 14
18972: PUSH
18973: LD_INT 2
18975: PUSH
18976: LD_INT 3
18978: PUSH
18979: LD_INT 4
18981: PUSH
18982: LD_INT 5
18984: PUSH
18985: LD_INT 21
18987: PUSH
18988: LD_INT 22
18990: PUSH
18991: LD_INT 23
18993: PUSH
18994: LD_INT 24
18996: PUSH
18997: EMPTY
18998: LIST
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: LIST
19004: LIST
19005: LIST
19006: LIST
19007: LIST
19008: ST_TO_ADDR
19009: GO 19012
19011: POP
// result := ( chassis in result ) ;
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_VAR 0 1
19021: PUSH
19022: LD_VAR 0 3
19026: IN
19027: ST_TO_ADDR
// end ;
19028: LD_VAR 0 3
19032: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19033: LD_INT 0
19035: PPUSH
// if not chassis or not weapon then
19036: LD_VAR 0 1
19040: NOT
19041: PUSH
19042: LD_VAR 0 2
19046: NOT
19047: OR
19048: IFFALSE 19052
// exit ;
19050: GO 20078
// case weapon of us_machine_gun :
19052: LD_VAR 0 2
19056: PUSH
19057: LD_INT 2
19059: DOUBLE
19060: EQUAL
19061: IFTRUE 19065
19063: GO 19095
19065: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_INT 1
19073: PUSH
19074: LD_INT 2
19076: PUSH
19077: LD_INT 3
19079: PUSH
19080: LD_INT 4
19082: PUSH
19083: LD_INT 5
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: LIST
19090: LIST
19091: LIST
19092: ST_TO_ADDR
19093: GO 20062
19095: LD_INT 3
19097: DOUBLE
19098: EQUAL
19099: IFTRUE 19103
19101: GO 19133
19103: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19104: LD_ADDR_VAR 0 3
19108: PUSH
19109: LD_INT 1
19111: PUSH
19112: LD_INT 2
19114: PUSH
19115: LD_INT 3
19117: PUSH
19118: LD_INT 4
19120: PUSH
19121: LD_INT 5
19123: PUSH
19124: EMPTY
19125: LIST
19126: LIST
19127: LIST
19128: LIST
19129: LIST
19130: ST_TO_ADDR
19131: GO 20062
19133: LD_INT 11
19135: DOUBLE
19136: EQUAL
19137: IFTRUE 19141
19139: GO 19171
19141: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19142: LD_ADDR_VAR 0 3
19146: PUSH
19147: LD_INT 1
19149: PUSH
19150: LD_INT 2
19152: PUSH
19153: LD_INT 3
19155: PUSH
19156: LD_INT 4
19158: PUSH
19159: LD_INT 5
19161: PUSH
19162: EMPTY
19163: LIST
19164: LIST
19165: LIST
19166: LIST
19167: LIST
19168: ST_TO_ADDR
19169: GO 20062
19171: LD_INT 4
19173: DOUBLE
19174: EQUAL
19175: IFTRUE 19179
19177: GO 19205
19179: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19180: LD_ADDR_VAR 0 3
19184: PUSH
19185: LD_INT 2
19187: PUSH
19188: LD_INT 3
19190: PUSH
19191: LD_INT 4
19193: PUSH
19194: LD_INT 5
19196: PUSH
19197: EMPTY
19198: LIST
19199: LIST
19200: LIST
19201: LIST
19202: ST_TO_ADDR
19203: GO 20062
19205: LD_INT 5
19207: DOUBLE
19208: EQUAL
19209: IFTRUE 19213
19211: GO 19239
19213: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19214: LD_ADDR_VAR 0 3
19218: PUSH
19219: LD_INT 2
19221: PUSH
19222: LD_INT 3
19224: PUSH
19225: LD_INT 4
19227: PUSH
19228: LD_INT 5
19230: PUSH
19231: EMPTY
19232: LIST
19233: LIST
19234: LIST
19235: LIST
19236: ST_TO_ADDR
19237: GO 20062
19239: LD_INT 9
19241: DOUBLE
19242: EQUAL
19243: IFTRUE 19247
19245: GO 19273
19247: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19248: LD_ADDR_VAR 0 3
19252: PUSH
19253: LD_INT 2
19255: PUSH
19256: LD_INT 3
19258: PUSH
19259: LD_INT 4
19261: PUSH
19262: LD_INT 5
19264: PUSH
19265: EMPTY
19266: LIST
19267: LIST
19268: LIST
19269: LIST
19270: ST_TO_ADDR
19271: GO 20062
19273: LD_INT 7
19275: DOUBLE
19276: EQUAL
19277: IFTRUE 19281
19279: GO 19307
19281: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19282: LD_ADDR_VAR 0 3
19286: PUSH
19287: LD_INT 2
19289: PUSH
19290: LD_INT 3
19292: PUSH
19293: LD_INT 4
19295: PUSH
19296: LD_INT 5
19298: PUSH
19299: EMPTY
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: ST_TO_ADDR
19305: GO 20062
19307: LD_INT 12
19309: DOUBLE
19310: EQUAL
19311: IFTRUE 19315
19313: GO 19341
19315: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19316: LD_ADDR_VAR 0 3
19320: PUSH
19321: LD_INT 2
19323: PUSH
19324: LD_INT 3
19326: PUSH
19327: LD_INT 4
19329: PUSH
19330: LD_INT 5
19332: PUSH
19333: EMPTY
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: ST_TO_ADDR
19339: GO 20062
19341: LD_INT 13
19343: DOUBLE
19344: EQUAL
19345: IFTRUE 19349
19347: GO 19375
19349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19350: LD_ADDR_VAR 0 3
19354: PUSH
19355: LD_INT 2
19357: PUSH
19358: LD_INT 3
19360: PUSH
19361: LD_INT 4
19363: PUSH
19364: LD_INT 5
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: LIST
19371: LIST
19372: ST_TO_ADDR
19373: GO 20062
19375: LD_INT 14
19377: DOUBLE
19378: EQUAL
19379: IFTRUE 19383
19381: GO 19401
19383: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19384: LD_ADDR_VAR 0 3
19388: PUSH
19389: LD_INT 4
19391: PUSH
19392: LD_INT 5
19394: PUSH
19395: EMPTY
19396: LIST
19397: LIST
19398: ST_TO_ADDR
19399: GO 20062
19401: LD_INT 6
19403: DOUBLE
19404: EQUAL
19405: IFTRUE 19409
19407: GO 19427
19409: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19410: LD_ADDR_VAR 0 3
19414: PUSH
19415: LD_INT 4
19417: PUSH
19418: LD_INT 5
19420: PUSH
19421: EMPTY
19422: LIST
19423: LIST
19424: ST_TO_ADDR
19425: GO 20062
19427: LD_INT 10
19429: DOUBLE
19430: EQUAL
19431: IFTRUE 19435
19433: GO 19453
19435: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19436: LD_ADDR_VAR 0 3
19440: PUSH
19441: LD_INT 4
19443: PUSH
19444: LD_INT 5
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: ST_TO_ADDR
19451: GO 20062
19453: LD_INT 22
19455: DOUBLE
19456: EQUAL
19457: IFTRUE 19461
19459: GO 19487
19461: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19462: LD_ADDR_VAR 0 3
19466: PUSH
19467: LD_INT 11
19469: PUSH
19470: LD_INT 12
19472: PUSH
19473: LD_INT 13
19475: PUSH
19476: LD_INT 14
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: LIST
19483: LIST
19484: ST_TO_ADDR
19485: GO 20062
19487: LD_INT 23
19489: DOUBLE
19490: EQUAL
19491: IFTRUE 19495
19493: GO 19521
19495: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19496: LD_ADDR_VAR 0 3
19500: PUSH
19501: LD_INT 11
19503: PUSH
19504: LD_INT 12
19506: PUSH
19507: LD_INT 13
19509: PUSH
19510: LD_INT 14
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: ST_TO_ADDR
19519: GO 20062
19521: LD_INT 24
19523: DOUBLE
19524: EQUAL
19525: IFTRUE 19529
19527: GO 19555
19529: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19530: LD_ADDR_VAR 0 3
19534: PUSH
19535: LD_INT 11
19537: PUSH
19538: LD_INT 12
19540: PUSH
19541: LD_INT 13
19543: PUSH
19544: LD_INT 14
19546: PUSH
19547: EMPTY
19548: LIST
19549: LIST
19550: LIST
19551: LIST
19552: ST_TO_ADDR
19553: GO 20062
19555: LD_INT 30
19557: DOUBLE
19558: EQUAL
19559: IFTRUE 19563
19561: GO 19589
19563: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19564: LD_ADDR_VAR 0 3
19568: PUSH
19569: LD_INT 11
19571: PUSH
19572: LD_INT 12
19574: PUSH
19575: LD_INT 13
19577: PUSH
19578: LD_INT 14
19580: PUSH
19581: EMPTY
19582: LIST
19583: LIST
19584: LIST
19585: LIST
19586: ST_TO_ADDR
19587: GO 20062
19589: LD_INT 25
19591: DOUBLE
19592: EQUAL
19593: IFTRUE 19597
19595: GO 19615
19597: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19598: LD_ADDR_VAR 0 3
19602: PUSH
19603: LD_INT 13
19605: PUSH
19606: LD_INT 14
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: ST_TO_ADDR
19613: GO 20062
19615: LD_INT 27
19617: DOUBLE
19618: EQUAL
19619: IFTRUE 19623
19621: GO 19641
19623: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19624: LD_ADDR_VAR 0 3
19628: PUSH
19629: LD_INT 13
19631: PUSH
19632: LD_INT 14
19634: PUSH
19635: EMPTY
19636: LIST
19637: LIST
19638: ST_TO_ADDR
19639: GO 20062
19641: LD_INT 28
19643: DOUBLE
19644: EQUAL
19645: IFTRUE 19649
19647: GO 19667
19649: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19650: LD_ADDR_VAR 0 3
19654: PUSH
19655: LD_INT 13
19657: PUSH
19658: LD_INT 14
19660: PUSH
19661: EMPTY
19662: LIST
19663: LIST
19664: ST_TO_ADDR
19665: GO 20062
19667: LD_INT 29
19669: DOUBLE
19670: EQUAL
19671: IFTRUE 19675
19673: GO 19693
19675: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19676: LD_ADDR_VAR 0 3
19680: PUSH
19681: LD_INT 13
19683: PUSH
19684: LD_INT 14
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: ST_TO_ADDR
19691: GO 20062
19693: LD_INT 31
19695: DOUBLE
19696: EQUAL
19697: IFTRUE 19701
19699: GO 19719
19701: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19702: LD_ADDR_VAR 0 3
19706: PUSH
19707: LD_INT 13
19709: PUSH
19710: LD_INT 14
19712: PUSH
19713: EMPTY
19714: LIST
19715: LIST
19716: ST_TO_ADDR
19717: GO 20062
19719: LD_INT 26
19721: DOUBLE
19722: EQUAL
19723: IFTRUE 19727
19725: GO 19745
19727: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19728: LD_ADDR_VAR 0 3
19732: PUSH
19733: LD_INT 13
19735: PUSH
19736: LD_INT 14
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: ST_TO_ADDR
19743: GO 20062
19745: LD_INT 42
19747: DOUBLE
19748: EQUAL
19749: IFTRUE 19753
19751: GO 19779
19753: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19754: LD_ADDR_VAR 0 3
19758: PUSH
19759: LD_INT 21
19761: PUSH
19762: LD_INT 22
19764: PUSH
19765: LD_INT 23
19767: PUSH
19768: LD_INT 24
19770: PUSH
19771: EMPTY
19772: LIST
19773: LIST
19774: LIST
19775: LIST
19776: ST_TO_ADDR
19777: GO 20062
19779: LD_INT 43
19781: DOUBLE
19782: EQUAL
19783: IFTRUE 19787
19785: GO 19813
19787: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19788: LD_ADDR_VAR 0 3
19792: PUSH
19793: LD_INT 21
19795: PUSH
19796: LD_INT 22
19798: PUSH
19799: LD_INT 23
19801: PUSH
19802: LD_INT 24
19804: PUSH
19805: EMPTY
19806: LIST
19807: LIST
19808: LIST
19809: LIST
19810: ST_TO_ADDR
19811: GO 20062
19813: LD_INT 44
19815: DOUBLE
19816: EQUAL
19817: IFTRUE 19821
19819: GO 19847
19821: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19822: LD_ADDR_VAR 0 3
19826: PUSH
19827: LD_INT 21
19829: PUSH
19830: LD_INT 22
19832: PUSH
19833: LD_INT 23
19835: PUSH
19836: LD_INT 24
19838: PUSH
19839: EMPTY
19840: LIST
19841: LIST
19842: LIST
19843: LIST
19844: ST_TO_ADDR
19845: GO 20062
19847: LD_INT 45
19849: DOUBLE
19850: EQUAL
19851: IFTRUE 19855
19853: GO 19881
19855: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19856: LD_ADDR_VAR 0 3
19860: PUSH
19861: LD_INT 21
19863: PUSH
19864: LD_INT 22
19866: PUSH
19867: LD_INT 23
19869: PUSH
19870: LD_INT 24
19872: PUSH
19873: EMPTY
19874: LIST
19875: LIST
19876: LIST
19877: LIST
19878: ST_TO_ADDR
19879: GO 20062
19881: LD_INT 49
19883: DOUBLE
19884: EQUAL
19885: IFTRUE 19889
19887: GO 19915
19889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19890: LD_ADDR_VAR 0 3
19894: PUSH
19895: LD_INT 21
19897: PUSH
19898: LD_INT 22
19900: PUSH
19901: LD_INT 23
19903: PUSH
19904: LD_INT 24
19906: PUSH
19907: EMPTY
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: ST_TO_ADDR
19913: GO 20062
19915: LD_INT 51
19917: DOUBLE
19918: EQUAL
19919: IFTRUE 19923
19921: GO 19949
19923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19924: LD_ADDR_VAR 0 3
19928: PUSH
19929: LD_INT 21
19931: PUSH
19932: LD_INT 22
19934: PUSH
19935: LD_INT 23
19937: PUSH
19938: LD_INT 24
19940: PUSH
19941: EMPTY
19942: LIST
19943: LIST
19944: LIST
19945: LIST
19946: ST_TO_ADDR
19947: GO 20062
19949: LD_INT 52
19951: DOUBLE
19952: EQUAL
19953: IFTRUE 19957
19955: GO 19983
19957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19958: LD_ADDR_VAR 0 3
19962: PUSH
19963: LD_INT 21
19965: PUSH
19966: LD_INT 22
19968: PUSH
19969: LD_INT 23
19971: PUSH
19972: LD_INT 24
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: ST_TO_ADDR
19981: GO 20062
19983: LD_INT 53
19985: DOUBLE
19986: EQUAL
19987: IFTRUE 19991
19989: GO 20009
19991: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19992: LD_ADDR_VAR 0 3
19996: PUSH
19997: LD_INT 23
19999: PUSH
20000: LD_INT 24
20002: PUSH
20003: EMPTY
20004: LIST
20005: LIST
20006: ST_TO_ADDR
20007: GO 20062
20009: LD_INT 46
20011: DOUBLE
20012: EQUAL
20013: IFTRUE 20017
20015: GO 20035
20017: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20018: LD_ADDR_VAR 0 3
20022: PUSH
20023: LD_INT 23
20025: PUSH
20026: LD_INT 24
20028: PUSH
20029: EMPTY
20030: LIST
20031: LIST
20032: ST_TO_ADDR
20033: GO 20062
20035: LD_INT 47
20037: DOUBLE
20038: EQUAL
20039: IFTRUE 20043
20041: GO 20061
20043: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20044: LD_ADDR_VAR 0 3
20048: PUSH
20049: LD_INT 23
20051: PUSH
20052: LD_INT 24
20054: PUSH
20055: EMPTY
20056: LIST
20057: LIST
20058: ST_TO_ADDR
20059: GO 20062
20061: POP
// result := ( chassis in result ) ;
20062: LD_ADDR_VAR 0 3
20066: PUSH
20067: LD_VAR 0 1
20071: PUSH
20072: LD_VAR 0 3
20076: IN
20077: ST_TO_ADDR
// end ;
20078: LD_VAR 0 3
20082: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20083: LD_INT 0
20085: PPUSH
20086: PPUSH
20087: PPUSH
20088: PPUSH
20089: PPUSH
20090: PPUSH
20091: PPUSH
// result := array ;
20092: LD_ADDR_VAR 0 5
20096: PUSH
20097: LD_VAR 0 1
20101: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20102: LD_VAR 0 1
20106: NOT
20107: PUSH
20108: LD_VAR 0 2
20112: NOT
20113: OR
20114: PUSH
20115: LD_VAR 0 3
20119: NOT
20120: OR
20121: PUSH
20122: LD_VAR 0 2
20126: PUSH
20127: LD_VAR 0 1
20131: GREATER
20132: OR
20133: PUSH
20134: LD_VAR 0 3
20138: PUSH
20139: LD_VAR 0 1
20143: GREATER
20144: OR
20145: IFFALSE 20149
// exit ;
20147: GO 20445
// if direction then
20149: LD_VAR 0 4
20153: IFFALSE 20217
// begin d := 1 ;
20155: LD_ADDR_VAR 0 9
20159: PUSH
20160: LD_INT 1
20162: ST_TO_ADDR
// if i_from > i_to then
20163: LD_VAR 0 2
20167: PUSH
20168: LD_VAR 0 3
20172: GREATER
20173: IFFALSE 20199
// length := ( array - i_from ) + i_to else
20175: LD_ADDR_VAR 0 11
20179: PUSH
20180: LD_VAR 0 1
20184: PUSH
20185: LD_VAR 0 2
20189: MINUS
20190: PUSH
20191: LD_VAR 0 3
20195: PLUS
20196: ST_TO_ADDR
20197: GO 20215
// length := i_to - i_from ;
20199: LD_ADDR_VAR 0 11
20203: PUSH
20204: LD_VAR 0 3
20208: PUSH
20209: LD_VAR 0 2
20213: MINUS
20214: ST_TO_ADDR
// end else
20215: GO 20278
// begin d := - 1 ;
20217: LD_ADDR_VAR 0 9
20221: PUSH
20222: LD_INT 1
20224: NEG
20225: ST_TO_ADDR
// if i_from > i_to then
20226: LD_VAR 0 2
20230: PUSH
20231: LD_VAR 0 3
20235: GREATER
20236: IFFALSE 20256
// length := i_from - i_to else
20238: LD_ADDR_VAR 0 11
20242: PUSH
20243: LD_VAR 0 2
20247: PUSH
20248: LD_VAR 0 3
20252: MINUS
20253: ST_TO_ADDR
20254: GO 20278
// length := ( array - i_to ) + i_from ;
20256: LD_ADDR_VAR 0 11
20260: PUSH
20261: LD_VAR 0 1
20265: PUSH
20266: LD_VAR 0 3
20270: MINUS
20271: PUSH
20272: LD_VAR 0 2
20276: PLUS
20277: ST_TO_ADDR
// end ; if not length then
20278: LD_VAR 0 11
20282: NOT
20283: IFFALSE 20287
// exit ;
20285: GO 20445
// tmp := array ;
20287: LD_ADDR_VAR 0 10
20291: PUSH
20292: LD_VAR 0 1
20296: ST_TO_ADDR
// for i = 1 to length do
20297: LD_ADDR_VAR 0 6
20301: PUSH
20302: DOUBLE
20303: LD_INT 1
20305: DEC
20306: ST_TO_ADDR
20307: LD_VAR 0 11
20311: PUSH
20312: FOR_TO
20313: IFFALSE 20433
// begin for j = 1 to array do
20315: LD_ADDR_VAR 0 7
20319: PUSH
20320: DOUBLE
20321: LD_INT 1
20323: DEC
20324: ST_TO_ADDR
20325: LD_VAR 0 1
20329: PUSH
20330: FOR_TO
20331: IFFALSE 20419
// begin k := j + d ;
20333: LD_ADDR_VAR 0 8
20337: PUSH
20338: LD_VAR 0 7
20342: PUSH
20343: LD_VAR 0 9
20347: PLUS
20348: ST_TO_ADDR
// if k > array then
20349: LD_VAR 0 8
20353: PUSH
20354: LD_VAR 0 1
20358: GREATER
20359: IFFALSE 20369
// k := 1 ;
20361: LD_ADDR_VAR 0 8
20365: PUSH
20366: LD_INT 1
20368: ST_TO_ADDR
// if not k then
20369: LD_VAR 0 8
20373: NOT
20374: IFFALSE 20386
// k := array ;
20376: LD_ADDR_VAR 0 8
20380: PUSH
20381: LD_VAR 0 1
20385: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20386: LD_ADDR_VAR 0 10
20390: PUSH
20391: LD_VAR 0 10
20395: PPUSH
20396: LD_VAR 0 8
20400: PPUSH
20401: LD_VAR 0 1
20405: PUSH
20406: LD_VAR 0 7
20410: ARRAY
20411: PPUSH
20412: CALL_OW 1
20416: ST_TO_ADDR
// end ;
20417: GO 20330
20419: POP
20420: POP
// array := tmp ;
20421: LD_ADDR_VAR 0 1
20425: PUSH
20426: LD_VAR 0 10
20430: ST_TO_ADDR
// end ;
20431: GO 20312
20433: POP
20434: POP
// result := array ;
20435: LD_ADDR_VAR 0 5
20439: PUSH
20440: LD_VAR 0 1
20444: ST_TO_ADDR
// end ;
20445: LD_VAR 0 5
20449: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20450: LD_INT 0
20452: PPUSH
20453: PPUSH
// result := 0 ;
20454: LD_ADDR_VAR 0 3
20458: PUSH
20459: LD_INT 0
20461: ST_TO_ADDR
// if not array or not value in array then
20462: LD_VAR 0 1
20466: NOT
20467: PUSH
20468: LD_VAR 0 2
20472: PUSH
20473: LD_VAR 0 1
20477: IN
20478: NOT
20479: OR
20480: IFFALSE 20484
// exit ;
20482: GO 20538
// for i = 1 to array do
20484: LD_ADDR_VAR 0 4
20488: PUSH
20489: DOUBLE
20490: LD_INT 1
20492: DEC
20493: ST_TO_ADDR
20494: LD_VAR 0 1
20498: PUSH
20499: FOR_TO
20500: IFFALSE 20536
// if value = array [ i ] then
20502: LD_VAR 0 2
20506: PUSH
20507: LD_VAR 0 1
20511: PUSH
20512: LD_VAR 0 4
20516: ARRAY
20517: EQUAL
20518: IFFALSE 20534
// begin result := i ;
20520: LD_ADDR_VAR 0 3
20524: PUSH
20525: LD_VAR 0 4
20529: ST_TO_ADDR
// exit ;
20530: POP
20531: POP
20532: GO 20538
// end ;
20534: GO 20499
20536: POP
20537: POP
// end ;
20538: LD_VAR 0 3
20542: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20543: LD_INT 0
20545: PPUSH
// vc_chassis := chassis ;
20546: LD_ADDR_OWVAR 37
20550: PUSH
20551: LD_VAR 0 1
20555: ST_TO_ADDR
// vc_engine := engine ;
20556: LD_ADDR_OWVAR 39
20560: PUSH
20561: LD_VAR 0 2
20565: ST_TO_ADDR
// vc_control := control ;
20566: LD_ADDR_OWVAR 38
20570: PUSH
20571: LD_VAR 0 3
20575: ST_TO_ADDR
// vc_weapon := weapon ;
20576: LD_ADDR_OWVAR 40
20580: PUSH
20581: LD_VAR 0 4
20585: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20586: LD_ADDR_OWVAR 41
20590: PUSH
20591: LD_VAR 0 5
20595: ST_TO_ADDR
// end ;
20596: LD_VAR 0 6
20600: RET
// export function WantPlant ( unit ) ; var task ; begin
20601: LD_INT 0
20603: PPUSH
20604: PPUSH
// result := false ;
20605: LD_ADDR_VAR 0 2
20609: PUSH
20610: LD_INT 0
20612: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20613: LD_ADDR_VAR 0 3
20617: PUSH
20618: LD_VAR 0 1
20622: PPUSH
20623: CALL_OW 437
20627: ST_TO_ADDR
// if task then
20628: LD_VAR 0 3
20632: IFFALSE 20660
// if task [ 1 ] [ 1 ] = p then
20634: LD_VAR 0 3
20638: PUSH
20639: LD_INT 1
20641: ARRAY
20642: PUSH
20643: LD_INT 1
20645: ARRAY
20646: PUSH
20647: LD_STRING p
20649: EQUAL
20650: IFFALSE 20660
// result := true ;
20652: LD_ADDR_VAR 0 2
20656: PUSH
20657: LD_INT 1
20659: ST_TO_ADDR
// end ;
20660: LD_VAR 0 2
20664: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20665: LD_INT 0
20667: PPUSH
20668: PPUSH
20669: PPUSH
20670: PPUSH
// if pos < 1 then
20671: LD_VAR 0 2
20675: PUSH
20676: LD_INT 1
20678: LESS
20679: IFFALSE 20683
// exit ;
20681: GO 20986
// if pos = 1 then
20683: LD_VAR 0 2
20687: PUSH
20688: LD_INT 1
20690: EQUAL
20691: IFFALSE 20724
// result := Replace ( arr , pos [ 1 ] , value ) else
20693: LD_ADDR_VAR 0 4
20697: PUSH
20698: LD_VAR 0 1
20702: PPUSH
20703: LD_VAR 0 2
20707: PUSH
20708: LD_INT 1
20710: ARRAY
20711: PPUSH
20712: LD_VAR 0 3
20716: PPUSH
20717: CALL_OW 1
20721: ST_TO_ADDR
20722: GO 20986
// begin tmp := arr ;
20724: LD_ADDR_VAR 0 6
20728: PUSH
20729: LD_VAR 0 1
20733: ST_TO_ADDR
// s_arr := [ tmp ] ;
20734: LD_ADDR_VAR 0 7
20738: PUSH
20739: LD_VAR 0 6
20743: PUSH
20744: EMPTY
20745: LIST
20746: ST_TO_ADDR
// for i = 1 to pos - 1 do
20747: LD_ADDR_VAR 0 5
20751: PUSH
20752: DOUBLE
20753: LD_INT 1
20755: DEC
20756: ST_TO_ADDR
20757: LD_VAR 0 2
20761: PUSH
20762: LD_INT 1
20764: MINUS
20765: PUSH
20766: FOR_TO
20767: IFFALSE 20812
// begin tmp := tmp [ pos [ i ] ] ;
20769: LD_ADDR_VAR 0 6
20773: PUSH
20774: LD_VAR 0 6
20778: PUSH
20779: LD_VAR 0 2
20783: PUSH
20784: LD_VAR 0 5
20788: ARRAY
20789: ARRAY
20790: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20791: LD_ADDR_VAR 0 7
20795: PUSH
20796: LD_VAR 0 7
20800: PUSH
20801: LD_VAR 0 6
20805: PUSH
20806: EMPTY
20807: LIST
20808: ADD
20809: ST_TO_ADDR
// end ;
20810: GO 20766
20812: POP
20813: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20814: LD_ADDR_VAR 0 6
20818: PUSH
20819: LD_VAR 0 6
20823: PPUSH
20824: LD_VAR 0 2
20828: PUSH
20829: LD_VAR 0 2
20833: ARRAY
20834: PPUSH
20835: LD_VAR 0 3
20839: PPUSH
20840: CALL_OW 1
20844: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20845: LD_ADDR_VAR 0 7
20849: PUSH
20850: LD_VAR 0 7
20854: PPUSH
20855: LD_VAR 0 7
20859: PPUSH
20860: LD_VAR 0 6
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// for i = s_arr downto 2 do
20870: LD_ADDR_VAR 0 5
20874: PUSH
20875: DOUBLE
20876: LD_VAR 0 7
20880: INC
20881: ST_TO_ADDR
20882: LD_INT 2
20884: PUSH
20885: FOR_DOWNTO
20886: IFFALSE 20970
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20888: LD_ADDR_VAR 0 6
20892: PUSH
20893: LD_VAR 0 7
20897: PUSH
20898: LD_VAR 0 5
20902: PUSH
20903: LD_INT 1
20905: MINUS
20906: ARRAY
20907: PPUSH
20908: LD_VAR 0 2
20912: PUSH
20913: LD_VAR 0 5
20917: PUSH
20918: LD_INT 1
20920: MINUS
20921: ARRAY
20922: PPUSH
20923: LD_VAR 0 7
20927: PUSH
20928: LD_VAR 0 5
20932: ARRAY
20933: PPUSH
20934: CALL_OW 1
20938: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20939: LD_ADDR_VAR 0 7
20943: PUSH
20944: LD_VAR 0 7
20948: PPUSH
20949: LD_VAR 0 5
20953: PUSH
20954: LD_INT 1
20956: MINUS
20957: PPUSH
20958: LD_VAR 0 6
20962: PPUSH
20963: CALL_OW 1
20967: ST_TO_ADDR
// end ;
20968: GO 20885
20970: POP
20971: POP
// result := s_arr [ 1 ] ;
20972: LD_ADDR_VAR 0 4
20976: PUSH
20977: LD_VAR 0 7
20981: PUSH
20982: LD_INT 1
20984: ARRAY
20985: ST_TO_ADDR
// end ; end ;
20986: LD_VAR 0 4
20990: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20991: LD_INT 0
20993: PPUSH
20994: PPUSH
// if not list then
20995: LD_VAR 0 1
20999: NOT
21000: IFFALSE 21004
// exit ;
21002: GO 21095
// i := list [ pos1 ] ;
21004: LD_ADDR_VAR 0 5
21008: PUSH
21009: LD_VAR 0 1
21013: PUSH
21014: LD_VAR 0 2
21018: ARRAY
21019: ST_TO_ADDR
// if not i then
21020: LD_VAR 0 5
21024: NOT
21025: IFFALSE 21029
// exit ;
21027: GO 21095
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21029: LD_ADDR_VAR 0 1
21033: PUSH
21034: LD_VAR 0 1
21038: PPUSH
21039: LD_VAR 0 2
21043: PPUSH
21044: LD_VAR 0 1
21048: PUSH
21049: LD_VAR 0 3
21053: ARRAY
21054: PPUSH
21055: CALL_OW 1
21059: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21060: LD_ADDR_VAR 0 1
21064: PUSH
21065: LD_VAR 0 1
21069: PPUSH
21070: LD_VAR 0 3
21074: PPUSH
21075: LD_VAR 0 5
21079: PPUSH
21080: CALL_OW 1
21084: ST_TO_ADDR
// result := list ;
21085: LD_ADDR_VAR 0 4
21089: PUSH
21090: LD_VAR 0 1
21094: ST_TO_ADDR
// end ;
21095: LD_VAR 0 4
21099: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21100: LD_INT 0
21102: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21103: LD_ADDR_VAR 0 5
21107: PUSH
21108: LD_VAR 0 1
21112: PPUSH
21113: CALL_OW 250
21117: PPUSH
21118: LD_VAR 0 1
21122: PPUSH
21123: CALL_OW 251
21127: PPUSH
21128: LD_VAR 0 2
21132: PPUSH
21133: LD_VAR 0 3
21137: PPUSH
21138: LD_VAR 0 4
21142: PPUSH
21143: CALL 21153 0 5
21147: ST_TO_ADDR
// end ;
21148: LD_VAR 0 5
21152: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21153: LD_INT 0
21155: PPUSH
21156: PPUSH
21157: PPUSH
21158: PPUSH
// if not list then
21159: LD_VAR 0 3
21163: NOT
21164: IFFALSE 21168
// exit ;
21166: GO 21556
// result := [ ] ;
21168: LD_ADDR_VAR 0 6
21172: PUSH
21173: EMPTY
21174: ST_TO_ADDR
// for i in list do
21175: LD_ADDR_VAR 0 7
21179: PUSH
21180: LD_VAR 0 3
21184: PUSH
21185: FOR_IN
21186: IFFALSE 21388
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21188: LD_ADDR_VAR 0 9
21192: PUSH
21193: LD_VAR 0 7
21197: PPUSH
21198: LD_VAR 0 1
21202: PPUSH
21203: LD_VAR 0 2
21207: PPUSH
21208: CALL_OW 297
21212: ST_TO_ADDR
// if not result then
21213: LD_VAR 0 6
21217: NOT
21218: IFFALSE 21244
// result := [ [ i , tmp ] ] else
21220: LD_ADDR_VAR 0 6
21224: PUSH
21225: LD_VAR 0 7
21229: PUSH
21230: LD_VAR 0 9
21234: PUSH
21235: EMPTY
21236: LIST
21237: LIST
21238: PUSH
21239: EMPTY
21240: LIST
21241: ST_TO_ADDR
21242: GO 21386
// begin if result [ result ] [ 2 ] < tmp then
21244: LD_VAR 0 6
21248: PUSH
21249: LD_VAR 0 6
21253: ARRAY
21254: PUSH
21255: LD_INT 2
21257: ARRAY
21258: PUSH
21259: LD_VAR 0 9
21263: LESS
21264: IFFALSE 21306
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21266: LD_ADDR_VAR 0 6
21270: PUSH
21271: LD_VAR 0 6
21275: PPUSH
21276: LD_VAR 0 6
21280: PUSH
21281: LD_INT 1
21283: PLUS
21284: PPUSH
21285: LD_VAR 0 7
21289: PUSH
21290: LD_VAR 0 9
21294: PUSH
21295: EMPTY
21296: LIST
21297: LIST
21298: PPUSH
21299: CALL_OW 2
21303: ST_TO_ADDR
21304: GO 21386
// for j = 1 to result do
21306: LD_ADDR_VAR 0 8
21310: PUSH
21311: DOUBLE
21312: LD_INT 1
21314: DEC
21315: ST_TO_ADDR
21316: LD_VAR 0 6
21320: PUSH
21321: FOR_TO
21322: IFFALSE 21384
// begin if tmp < result [ j ] [ 2 ] then
21324: LD_VAR 0 9
21328: PUSH
21329: LD_VAR 0 6
21333: PUSH
21334: LD_VAR 0 8
21338: ARRAY
21339: PUSH
21340: LD_INT 2
21342: ARRAY
21343: LESS
21344: IFFALSE 21382
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21346: LD_ADDR_VAR 0 6
21350: PUSH
21351: LD_VAR 0 6
21355: PPUSH
21356: LD_VAR 0 8
21360: PPUSH
21361: LD_VAR 0 7
21365: PUSH
21366: LD_VAR 0 9
21370: PUSH
21371: EMPTY
21372: LIST
21373: LIST
21374: PPUSH
21375: CALL_OW 2
21379: ST_TO_ADDR
// break ;
21380: GO 21384
// end ; end ;
21382: GO 21321
21384: POP
21385: POP
// end ; end ;
21386: GO 21185
21388: POP
21389: POP
// if result and not asc then
21390: LD_VAR 0 6
21394: PUSH
21395: LD_VAR 0 4
21399: NOT
21400: AND
21401: IFFALSE 21476
// begin tmp := result ;
21403: LD_ADDR_VAR 0 9
21407: PUSH
21408: LD_VAR 0 6
21412: ST_TO_ADDR
// for i = tmp downto 1 do
21413: LD_ADDR_VAR 0 7
21417: PUSH
21418: DOUBLE
21419: LD_VAR 0 9
21423: INC
21424: ST_TO_ADDR
21425: LD_INT 1
21427: PUSH
21428: FOR_DOWNTO
21429: IFFALSE 21474
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21431: LD_ADDR_VAR 0 6
21435: PUSH
21436: LD_VAR 0 6
21440: PPUSH
21441: LD_VAR 0 9
21445: PUSH
21446: LD_VAR 0 7
21450: MINUS
21451: PUSH
21452: LD_INT 1
21454: PLUS
21455: PPUSH
21456: LD_VAR 0 9
21460: PUSH
21461: LD_VAR 0 7
21465: ARRAY
21466: PPUSH
21467: CALL_OW 1
21471: ST_TO_ADDR
21472: GO 21428
21474: POP
21475: POP
// end ; tmp := [ ] ;
21476: LD_ADDR_VAR 0 9
21480: PUSH
21481: EMPTY
21482: ST_TO_ADDR
// if mode then
21483: LD_VAR 0 5
21487: IFFALSE 21556
// begin for i = 1 to result do
21489: LD_ADDR_VAR 0 7
21493: PUSH
21494: DOUBLE
21495: LD_INT 1
21497: DEC
21498: ST_TO_ADDR
21499: LD_VAR 0 6
21503: PUSH
21504: FOR_TO
21505: IFFALSE 21544
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21507: LD_ADDR_VAR 0 9
21511: PUSH
21512: LD_VAR 0 9
21516: PPUSH
21517: LD_VAR 0 7
21521: PPUSH
21522: LD_VAR 0 6
21526: PUSH
21527: LD_VAR 0 7
21531: ARRAY
21532: PUSH
21533: LD_INT 1
21535: ARRAY
21536: PPUSH
21537: CALL_OW 1
21541: ST_TO_ADDR
21542: GO 21504
21544: POP
21545: POP
// result := tmp ;
21546: LD_ADDR_VAR 0 6
21550: PUSH
21551: LD_VAR 0 9
21555: ST_TO_ADDR
// end ; end ;
21556: LD_VAR 0 6
21560: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21561: LD_INT 0
21563: PPUSH
21564: PPUSH
21565: PPUSH
21566: PPUSH
21567: PPUSH
21568: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21569: LD_ADDR_VAR 0 5
21573: PUSH
21574: LD_INT 0
21576: PUSH
21577: LD_INT 0
21579: PUSH
21580: LD_INT 0
21582: PUSH
21583: EMPTY
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: LIST
21589: LIST
21590: ST_TO_ADDR
// if not x or not y then
21591: LD_VAR 0 2
21595: NOT
21596: PUSH
21597: LD_VAR 0 3
21601: NOT
21602: OR
21603: IFFALSE 21607
// exit ;
21605: GO 23253
// if not range then
21607: LD_VAR 0 4
21611: NOT
21612: IFFALSE 21622
// range := 10 ;
21614: LD_ADDR_VAR 0 4
21618: PUSH
21619: LD_INT 10
21621: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21622: LD_ADDR_VAR 0 8
21626: PUSH
21627: LD_INT 81
21629: PUSH
21630: LD_VAR 0 1
21634: PUSH
21635: EMPTY
21636: LIST
21637: LIST
21638: PUSH
21639: LD_INT 92
21641: PUSH
21642: LD_VAR 0 2
21646: PUSH
21647: LD_VAR 0 3
21651: PUSH
21652: LD_VAR 0 4
21656: PUSH
21657: EMPTY
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: PUSH
21663: LD_INT 3
21665: PUSH
21666: LD_INT 21
21668: PUSH
21669: LD_INT 3
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: PUSH
21676: EMPTY
21677: LIST
21678: LIST
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: LIST
21684: PPUSH
21685: CALL_OW 69
21689: ST_TO_ADDR
// if not tmp then
21690: LD_VAR 0 8
21694: NOT
21695: IFFALSE 21699
// exit ;
21697: GO 23253
// for i in tmp do
21699: LD_ADDR_VAR 0 6
21703: PUSH
21704: LD_VAR 0 8
21708: PUSH
21709: FOR_IN
21710: IFFALSE 23228
// begin points := [ 0 , 0 , 0 ] ;
21712: LD_ADDR_VAR 0 9
21716: PUSH
21717: LD_INT 0
21719: PUSH
21720: LD_INT 0
21722: PUSH
21723: LD_INT 0
21725: PUSH
21726: EMPTY
21727: LIST
21728: LIST
21729: LIST
21730: ST_TO_ADDR
// bpoints := 1 ;
21731: LD_ADDR_VAR 0 10
21735: PUSH
21736: LD_INT 1
21738: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21739: LD_VAR 0 6
21743: PPUSH
21744: CALL_OW 247
21748: PUSH
21749: LD_INT 1
21751: DOUBLE
21752: EQUAL
21753: IFTRUE 21757
21755: GO 22335
21757: POP
// begin if GetClass ( i ) = 1 then
21758: LD_VAR 0 6
21762: PPUSH
21763: CALL_OW 257
21767: PUSH
21768: LD_INT 1
21770: EQUAL
21771: IFFALSE 21792
// points := [ 10 , 5 , 3 ] ;
21773: LD_ADDR_VAR 0 9
21777: PUSH
21778: LD_INT 10
21780: PUSH
21781: LD_INT 5
21783: PUSH
21784: LD_INT 3
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: LIST
21791: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21792: LD_VAR 0 6
21796: PPUSH
21797: CALL_OW 257
21801: PUSH
21802: LD_INT 2
21804: PUSH
21805: LD_INT 3
21807: PUSH
21808: LD_INT 4
21810: PUSH
21811: EMPTY
21812: LIST
21813: LIST
21814: LIST
21815: IN
21816: IFFALSE 21837
// points := [ 3 , 2 , 1 ] ;
21818: LD_ADDR_VAR 0 9
21822: PUSH
21823: LD_INT 3
21825: PUSH
21826: LD_INT 2
21828: PUSH
21829: LD_INT 1
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21837: LD_VAR 0 6
21841: PPUSH
21842: CALL_OW 257
21846: PUSH
21847: LD_INT 5
21849: EQUAL
21850: IFFALSE 21871
// points := [ 130 , 5 , 2 ] ;
21852: LD_ADDR_VAR 0 9
21856: PUSH
21857: LD_INT 130
21859: PUSH
21860: LD_INT 5
21862: PUSH
21863: LD_INT 2
21865: PUSH
21866: EMPTY
21867: LIST
21868: LIST
21869: LIST
21870: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21871: LD_VAR 0 6
21875: PPUSH
21876: CALL_OW 257
21880: PUSH
21881: LD_INT 8
21883: EQUAL
21884: IFFALSE 21905
// points := [ 35 , 35 , 30 ] ;
21886: LD_ADDR_VAR 0 9
21890: PUSH
21891: LD_INT 35
21893: PUSH
21894: LD_INT 35
21896: PUSH
21897: LD_INT 30
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21905: LD_VAR 0 6
21909: PPUSH
21910: CALL_OW 257
21914: PUSH
21915: LD_INT 9
21917: EQUAL
21918: IFFALSE 21939
// points := [ 20 , 55 , 40 ] ;
21920: LD_ADDR_VAR 0 9
21924: PUSH
21925: LD_INT 20
21927: PUSH
21928: LD_INT 55
21930: PUSH
21931: LD_INT 40
21933: PUSH
21934: EMPTY
21935: LIST
21936: LIST
21937: LIST
21938: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21939: LD_VAR 0 6
21943: PPUSH
21944: CALL_OW 257
21948: PUSH
21949: LD_INT 12
21951: PUSH
21952: LD_INT 16
21954: PUSH
21955: EMPTY
21956: LIST
21957: LIST
21958: IN
21959: IFFALSE 21980
// points := [ 5 , 3 , 2 ] ;
21961: LD_ADDR_VAR 0 9
21965: PUSH
21966: LD_INT 5
21968: PUSH
21969: LD_INT 3
21971: PUSH
21972: LD_INT 2
21974: PUSH
21975: EMPTY
21976: LIST
21977: LIST
21978: LIST
21979: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21980: LD_VAR 0 6
21984: PPUSH
21985: CALL_OW 257
21989: PUSH
21990: LD_INT 17
21992: EQUAL
21993: IFFALSE 22014
// points := [ 100 , 50 , 75 ] ;
21995: LD_ADDR_VAR 0 9
21999: PUSH
22000: LD_INT 100
22002: PUSH
22003: LD_INT 50
22005: PUSH
22006: LD_INT 75
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: LIST
22013: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22014: LD_VAR 0 6
22018: PPUSH
22019: CALL_OW 257
22023: PUSH
22024: LD_INT 15
22026: EQUAL
22027: IFFALSE 22048
// points := [ 10 , 5 , 3 ] ;
22029: LD_ADDR_VAR 0 9
22033: PUSH
22034: LD_INT 10
22036: PUSH
22037: LD_INT 5
22039: PUSH
22040: LD_INT 3
22042: PUSH
22043: EMPTY
22044: LIST
22045: LIST
22046: LIST
22047: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22048: LD_VAR 0 6
22052: PPUSH
22053: CALL_OW 257
22057: PUSH
22058: LD_INT 14
22060: EQUAL
22061: IFFALSE 22082
// points := [ 10 , 0 , 0 ] ;
22063: LD_ADDR_VAR 0 9
22067: PUSH
22068: LD_INT 10
22070: PUSH
22071: LD_INT 0
22073: PUSH
22074: LD_INT 0
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: LIST
22081: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 257
22091: PUSH
22092: LD_INT 11
22094: EQUAL
22095: IFFALSE 22116
// points := [ 30 , 10 , 5 ] ;
22097: LD_ADDR_VAR 0 9
22101: PUSH
22102: LD_INT 30
22104: PUSH
22105: LD_INT 10
22107: PUSH
22108: LD_INT 5
22110: PUSH
22111: EMPTY
22112: LIST
22113: LIST
22114: LIST
22115: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22116: LD_VAR 0 1
22120: PPUSH
22121: LD_INT 5
22123: PPUSH
22124: CALL_OW 321
22128: PUSH
22129: LD_INT 2
22131: EQUAL
22132: IFFALSE 22149
// bpoints := bpoints * 1.8 ;
22134: LD_ADDR_VAR 0 10
22138: PUSH
22139: LD_VAR 0 10
22143: PUSH
22144: LD_REAL  1.80000000000000E+0000
22147: MUL
22148: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22149: LD_VAR 0 6
22153: PPUSH
22154: CALL_OW 257
22158: PUSH
22159: LD_INT 1
22161: PUSH
22162: LD_INT 2
22164: PUSH
22165: LD_INT 3
22167: PUSH
22168: LD_INT 4
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: LIST
22176: IN
22177: PUSH
22178: LD_VAR 0 1
22182: PPUSH
22183: LD_INT 51
22185: PPUSH
22186: CALL_OW 321
22190: PUSH
22191: LD_INT 2
22193: EQUAL
22194: AND
22195: IFFALSE 22212
// bpoints := bpoints * 1.2 ;
22197: LD_ADDR_VAR 0 10
22201: PUSH
22202: LD_VAR 0 10
22206: PUSH
22207: LD_REAL  1.20000000000000E+0000
22210: MUL
22211: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22212: LD_VAR 0 6
22216: PPUSH
22217: CALL_OW 257
22221: PUSH
22222: LD_INT 5
22224: PUSH
22225: LD_INT 7
22227: PUSH
22228: LD_INT 9
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: LIST
22235: IN
22236: PUSH
22237: LD_VAR 0 1
22241: PPUSH
22242: LD_INT 52
22244: PPUSH
22245: CALL_OW 321
22249: PUSH
22250: LD_INT 2
22252: EQUAL
22253: AND
22254: IFFALSE 22271
// bpoints := bpoints * 1.5 ;
22256: LD_ADDR_VAR 0 10
22260: PUSH
22261: LD_VAR 0 10
22265: PUSH
22266: LD_REAL  1.50000000000000E+0000
22269: MUL
22270: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22271: LD_VAR 0 1
22275: PPUSH
22276: LD_INT 66
22278: PPUSH
22279: CALL_OW 321
22283: PUSH
22284: LD_INT 2
22286: EQUAL
22287: IFFALSE 22304
// bpoints := bpoints * 1.1 ;
22289: LD_ADDR_VAR 0 10
22293: PUSH
22294: LD_VAR 0 10
22298: PUSH
22299: LD_REAL  1.10000000000000E+0000
22302: MUL
22303: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22304: LD_ADDR_VAR 0 10
22308: PUSH
22309: LD_VAR 0 10
22313: PUSH
22314: LD_VAR 0 6
22318: PPUSH
22319: LD_INT 1
22321: PPUSH
22322: CALL_OW 259
22326: PUSH
22327: LD_REAL  1.15000000000000E+0000
22330: MUL
22331: MUL
22332: ST_TO_ADDR
// end ; unit_vehicle :
22333: GO 23157
22335: LD_INT 2
22337: DOUBLE
22338: EQUAL
22339: IFTRUE 22343
22341: GO 23145
22343: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22344: LD_VAR 0 6
22348: PPUSH
22349: CALL_OW 264
22353: PUSH
22354: LD_INT 2
22356: PUSH
22357: LD_INT 42
22359: PUSH
22360: LD_INT 24
22362: PUSH
22363: EMPTY
22364: LIST
22365: LIST
22366: LIST
22367: IN
22368: IFFALSE 22389
// points := [ 25 , 5 , 3 ] ;
22370: LD_ADDR_VAR 0 9
22374: PUSH
22375: LD_INT 25
22377: PUSH
22378: LD_INT 5
22380: PUSH
22381: LD_INT 3
22383: PUSH
22384: EMPTY
22385: LIST
22386: LIST
22387: LIST
22388: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22389: LD_VAR 0 6
22393: PPUSH
22394: CALL_OW 264
22398: PUSH
22399: LD_INT 4
22401: PUSH
22402: LD_INT 43
22404: PUSH
22405: LD_INT 25
22407: PUSH
22408: EMPTY
22409: LIST
22410: LIST
22411: LIST
22412: IN
22413: IFFALSE 22434
// points := [ 40 , 15 , 5 ] ;
22415: LD_ADDR_VAR 0 9
22419: PUSH
22420: LD_INT 40
22422: PUSH
22423: LD_INT 15
22425: PUSH
22426: LD_INT 5
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: LIST
22433: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22434: LD_VAR 0 6
22438: PPUSH
22439: CALL_OW 264
22443: PUSH
22444: LD_INT 3
22446: PUSH
22447: LD_INT 23
22449: PUSH
22450: EMPTY
22451: LIST
22452: LIST
22453: IN
22454: IFFALSE 22475
// points := [ 7 , 25 , 8 ] ;
22456: LD_ADDR_VAR 0 9
22460: PUSH
22461: LD_INT 7
22463: PUSH
22464: LD_INT 25
22466: PUSH
22467: LD_INT 8
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: LIST
22474: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22475: LD_VAR 0 6
22479: PPUSH
22480: CALL_OW 264
22484: PUSH
22485: LD_INT 5
22487: PUSH
22488: LD_INT 27
22490: PUSH
22491: LD_INT 44
22493: PUSH
22494: EMPTY
22495: LIST
22496: LIST
22497: LIST
22498: IN
22499: IFFALSE 22520
// points := [ 14 , 50 , 16 ] ;
22501: LD_ADDR_VAR 0 9
22505: PUSH
22506: LD_INT 14
22508: PUSH
22509: LD_INT 50
22511: PUSH
22512: LD_INT 16
22514: PUSH
22515: EMPTY
22516: LIST
22517: LIST
22518: LIST
22519: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22520: LD_VAR 0 6
22524: PPUSH
22525: CALL_OW 264
22529: PUSH
22530: LD_INT 6
22532: PUSH
22533: LD_INT 46
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: IN
22540: IFFALSE 22561
// points := [ 32 , 120 , 70 ] ;
22542: LD_ADDR_VAR 0 9
22546: PUSH
22547: LD_INT 32
22549: PUSH
22550: LD_INT 120
22552: PUSH
22553: LD_INT 70
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: LIST
22560: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22561: LD_VAR 0 6
22565: PPUSH
22566: CALL_OW 264
22570: PUSH
22571: LD_INT 7
22573: PUSH
22574: LD_INT 28
22576: PUSH
22577: LD_INT 45
22579: PUSH
22580: EMPTY
22581: LIST
22582: LIST
22583: LIST
22584: IN
22585: IFFALSE 22606
// points := [ 35 , 20 , 45 ] ;
22587: LD_ADDR_VAR 0 9
22591: PUSH
22592: LD_INT 35
22594: PUSH
22595: LD_INT 20
22597: PUSH
22598: LD_INT 45
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: LIST
22605: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22606: LD_VAR 0 6
22610: PPUSH
22611: CALL_OW 264
22615: PUSH
22616: LD_INT 47
22618: PUSH
22619: EMPTY
22620: LIST
22621: IN
22622: IFFALSE 22643
// points := [ 67 , 45 , 75 ] ;
22624: LD_ADDR_VAR 0 9
22628: PUSH
22629: LD_INT 67
22631: PUSH
22632: LD_INT 45
22634: PUSH
22635: LD_INT 75
22637: PUSH
22638: EMPTY
22639: LIST
22640: LIST
22641: LIST
22642: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22643: LD_VAR 0 6
22647: PPUSH
22648: CALL_OW 264
22652: PUSH
22653: LD_INT 26
22655: PUSH
22656: EMPTY
22657: LIST
22658: IN
22659: IFFALSE 22680
// points := [ 120 , 30 , 80 ] ;
22661: LD_ADDR_VAR 0 9
22665: PUSH
22666: LD_INT 120
22668: PUSH
22669: LD_INT 30
22671: PUSH
22672: LD_INT 80
22674: PUSH
22675: EMPTY
22676: LIST
22677: LIST
22678: LIST
22679: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22680: LD_VAR 0 6
22684: PPUSH
22685: CALL_OW 264
22689: PUSH
22690: LD_INT 22
22692: PUSH
22693: EMPTY
22694: LIST
22695: IN
22696: IFFALSE 22717
// points := [ 40 , 1 , 1 ] ;
22698: LD_ADDR_VAR 0 9
22702: PUSH
22703: LD_INT 40
22705: PUSH
22706: LD_INT 1
22708: PUSH
22709: LD_INT 1
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22717: LD_VAR 0 6
22721: PPUSH
22722: CALL_OW 264
22726: PUSH
22727: LD_INT 29
22729: PUSH
22730: EMPTY
22731: LIST
22732: IN
22733: IFFALSE 22754
// points := [ 70 , 200 , 400 ] ;
22735: LD_ADDR_VAR 0 9
22739: PUSH
22740: LD_INT 70
22742: PUSH
22743: LD_INT 200
22745: PUSH
22746: LD_INT 400
22748: PUSH
22749: EMPTY
22750: LIST
22751: LIST
22752: LIST
22753: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22754: LD_VAR 0 6
22758: PPUSH
22759: CALL_OW 264
22763: PUSH
22764: LD_INT 14
22766: PUSH
22767: LD_INT 53
22769: PUSH
22770: EMPTY
22771: LIST
22772: LIST
22773: IN
22774: IFFALSE 22795
// points := [ 40 , 10 , 20 ] ;
22776: LD_ADDR_VAR 0 9
22780: PUSH
22781: LD_INT 40
22783: PUSH
22784: LD_INT 10
22786: PUSH
22787: LD_INT 20
22789: PUSH
22790: EMPTY
22791: LIST
22792: LIST
22793: LIST
22794: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22795: LD_VAR 0 6
22799: PPUSH
22800: CALL_OW 264
22804: PUSH
22805: LD_INT 9
22807: PUSH
22808: EMPTY
22809: LIST
22810: IN
22811: IFFALSE 22832
// points := [ 5 , 70 , 20 ] ;
22813: LD_ADDR_VAR 0 9
22817: PUSH
22818: LD_INT 5
22820: PUSH
22821: LD_INT 70
22823: PUSH
22824: LD_INT 20
22826: PUSH
22827: EMPTY
22828: LIST
22829: LIST
22830: LIST
22831: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22832: LD_VAR 0 6
22836: PPUSH
22837: CALL_OW 264
22841: PUSH
22842: LD_INT 10
22844: PUSH
22845: EMPTY
22846: LIST
22847: IN
22848: IFFALSE 22869
// points := [ 35 , 110 , 70 ] ;
22850: LD_ADDR_VAR 0 9
22854: PUSH
22855: LD_INT 35
22857: PUSH
22858: LD_INT 110
22860: PUSH
22861: LD_INT 70
22863: PUSH
22864: EMPTY
22865: LIST
22866: LIST
22867: LIST
22868: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22869: LD_VAR 0 6
22873: PPUSH
22874: CALL_OW 265
22878: PUSH
22879: LD_INT 25
22881: EQUAL
22882: IFFALSE 22903
// points := [ 80 , 65 , 100 ] ;
22884: LD_ADDR_VAR 0 9
22888: PUSH
22889: LD_INT 80
22891: PUSH
22892: LD_INT 65
22894: PUSH
22895: LD_INT 100
22897: PUSH
22898: EMPTY
22899: LIST
22900: LIST
22901: LIST
22902: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22903: LD_VAR 0 6
22907: PPUSH
22908: CALL_OW 263
22912: PUSH
22913: LD_INT 1
22915: EQUAL
22916: IFFALSE 22951
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22918: LD_ADDR_VAR 0 10
22922: PUSH
22923: LD_VAR 0 10
22927: PUSH
22928: LD_VAR 0 6
22932: PPUSH
22933: CALL_OW 311
22937: PPUSH
22938: LD_INT 3
22940: PPUSH
22941: CALL_OW 259
22945: PUSH
22946: LD_INT 4
22948: MUL
22949: MUL
22950: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22951: LD_VAR 0 6
22955: PPUSH
22956: CALL_OW 263
22960: PUSH
22961: LD_INT 2
22963: EQUAL
22964: IFFALSE 23015
// begin j := IsControledBy ( i ) ;
22966: LD_ADDR_VAR 0 7
22970: PUSH
22971: LD_VAR 0 6
22975: PPUSH
22976: CALL_OW 312
22980: ST_TO_ADDR
// if j then
22981: LD_VAR 0 7
22985: IFFALSE 23015
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22987: LD_ADDR_VAR 0 10
22991: PUSH
22992: LD_VAR 0 10
22996: PUSH
22997: LD_VAR 0 7
23001: PPUSH
23002: LD_INT 3
23004: PPUSH
23005: CALL_OW 259
23009: PUSH
23010: LD_INT 3
23012: MUL
23013: MUL
23014: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23015: LD_VAR 0 6
23019: PPUSH
23020: CALL_OW 264
23024: PUSH
23025: LD_INT 5
23027: PUSH
23028: LD_INT 6
23030: PUSH
23031: LD_INT 46
23033: PUSH
23034: LD_INT 44
23036: PUSH
23037: LD_INT 47
23039: PUSH
23040: LD_INT 45
23042: PUSH
23043: LD_INT 28
23045: PUSH
23046: LD_INT 7
23048: PUSH
23049: LD_INT 27
23051: PUSH
23052: LD_INT 29
23054: PUSH
23055: EMPTY
23056: LIST
23057: LIST
23058: LIST
23059: LIST
23060: LIST
23061: LIST
23062: LIST
23063: LIST
23064: LIST
23065: LIST
23066: IN
23067: PUSH
23068: LD_VAR 0 1
23072: PPUSH
23073: LD_INT 52
23075: PPUSH
23076: CALL_OW 321
23080: PUSH
23081: LD_INT 2
23083: EQUAL
23084: AND
23085: IFFALSE 23102
// bpoints := bpoints * 1.2 ;
23087: LD_ADDR_VAR 0 10
23091: PUSH
23092: LD_VAR 0 10
23096: PUSH
23097: LD_REAL  1.20000000000000E+0000
23100: MUL
23101: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23102: LD_VAR 0 6
23106: PPUSH
23107: CALL_OW 264
23111: PUSH
23112: LD_INT 6
23114: PUSH
23115: LD_INT 46
23117: PUSH
23118: LD_INT 47
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: LIST
23125: IN
23126: IFFALSE 23143
// bpoints := bpoints * 1.2 ;
23128: LD_ADDR_VAR 0 10
23132: PUSH
23133: LD_VAR 0 10
23137: PUSH
23138: LD_REAL  1.20000000000000E+0000
23141: MUL
23142: ST_TO_ADDR
// end ; unit_building :
23143: GO 23157
23145: LD_INT 3
23147: DOUBLE
23148: EQUAL
23149: IFTRUE 23153
23151: GO 23156
23153: POP
// ; end ;
23154: GO 23157
23156: POP
// for j = 1 to 3 do
23157: LD_ADDR_VAR 0 7
23161: PUSH
23162: DOUBLE
23163: LD_INT 1
23165: DEC
23166: ST_TO_ADDR
23167: LD_INT 3
23169: PUSH
23170: FOR_TO
23171: IFFALSE 23224
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23173: LD_ADDR_VAR 0 5
23177: PUSH
23178: LD_VAR 0 5
23182: PPUSH
23183: LD_VAR 0 7
23187: PPUSH
23188: LD_VAR 0 5
23192: PUSH
23193: LD_VAR 0 7
23197: ARRAY
23198: PUSH
23199: LD_VAR 0 9
23203: PUSH
23204: LD_VAR 0 7
23208: ARRAY
23209: PUSH
23210: LD_VAR 0 10
23214: MUL
23215: PLUS
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
23222: GO 23170
23224: POP
23225: POP
// end ;
23226: GO 21709
23228: POP
23229: POP
// result := Replace ( result , 4 , tmp ) ;
23230: LD_ADDR_VAR 0 5
23234: PUSH
23235: LD_VAR 0 5
23239: PPUSH
23240: LD_INT 4
23242: PPUSH
23243: LD_VAR 0 8
23247: PPUSH
23248: CALL_OW 1
23252: ST_TO_ADDR
// end ;
23253: LD_VAR 0 5
23257: RET
// export function DangerAtRange ( unit , range ) ; begin
23258: LD_INT 0
23260: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23261: LD_ADDR_VAR 0 3
23265: PUSH
23266: LD_VAR 0 1
23270: PPUSH
23271: CALL_OW 255
23275: PPUSH
23276: LD_VAR 0 1
23280: PPUSH
23281: CALL_OW 250
23285: PPUSH
23286: LD_VAR 0 1
23290: PPUSH
23291: CALL_OW 251
23295: PPUSH
23296: LD_VAR 0 2
23300: PPUSH
23301: CALL 21561 0 4
23305: ST_TO_ADDR
// end ;
23306: LD_VAR 0 3
23310: RET
// export function DangerInArea ( side , area ) ; begin
23311: LD_INT 0
23313: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23314: LD_ADDR_VAR 0 3
23318: PUSH
23319: LD_VAR 0 2
23323: PPUSH
23324: LD_INT 81
23326: PUSH
23327: LD_VAR 0 1
23331: PUSH
23332: EMPTY
23333: LIST
23334: LIST
23335: PPUSH
23336: CALL_OW 70
23340: ST_TO_ADDR
// end ;
23341: LD_VAR 0 3
23345: RET
// export function IsExtension ( b ) ; begin
23346: LD_INT 0
23348: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23349: LD_ADDR_VAR 0 2
23353: PUSH
23354: LD_VAR 0 1
23358: PUSH
23359: LD_INT 23
23361: PUSH
23362: LD_INT 20
23364: PUSH
23365: LD_INT 22
23367: PUSH
23368: LD_INT 17
23370: PUSH
23371: LD_INT 24
23373: PUSH
23374: LD_INT 21
23376: PUSH
23377: LD_INT 19
23379: PUSH
23380: LD_INT 16
23382: PUSH
23383: LD_INT 25
23385: PUSH
23386: LD_INT 18
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: LIST
23393: LIST
23394: LIST
23395: LIST
23396: LIST
23397: LIST
23398: LIST
23399: LIST
23400: IN
23401: ST_TO_ADDR
// end ;
23402: LD_VAR 0 2
23406: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23407: LD_INT 0
23409: PPUSH
23410: PPUSH
23411: PPUSH
// result := [ ] ;
23412: LD_ADDR_VAR 0 3
23416: PUSH
23417: EMPTY
23418: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23419: LD_ADDR_VAR 0 4
23423: PUSH
23424: LD_VAR 0 2
23428: PPUSH
23429: LD_INT 21
23431: PUSH
23432: LD_INT 3
23434: PUSH
23435: EMPTY
23436: LIST
23437: LIST
23438: PPUSH
23439: CALL_OW 70
23443: ST_TO_ADDR
// if not tmp then
23444: LD_VAR 0 4
23448: NOT
23449: IFFALSE 23453
// exit ;
23451: GO 23511
// for i in tmp do
23453: LD_ADDR_VAR 0 5
23457: PUSH
23458: LD_VAR 0 4
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23499
// if GetBase ( i ) <> base then
23466: LD_VAR 0 5
23470: PPUSH
23471: CALL_OW 274
23475: PUSH
23476: LD_VAR 0 1
23480: NONEQUAL
23481: IFFALSE 23497
// ComLinkToBase ( base , i ) ;
23483: LD_VAR 0 1
23487: PPUSH
23488: LD_VAR 0 5
23492: PPUSH
23493: CALL_OW 169
23497: GO 23463
23499: POP
23500: POP
// result := tmp ;
23501: LD_ADDR_VAR 0 3
23505: PUSH
23506: LD_VAR 0 4
23510: ST_TO_ADDR
// end ;
23511: LD_VAR 0 3
23515: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23516: LD_INT 0
23518: PPUSH
23519: PPUSH
// if BuildingStatus ( b ) = bs_build then
23520: LD_VAR 0 2
23524: PPUSH
23525: CALL_OW 461
23529: PUSH
23530: LD_INT 1
23532: EQUAL
23533: IFFALSE 23593
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23535: LD_VAR 0 1
23539: PPUSH
23540: LD_STRING h
23542: PUSH
23543: LD_VAR 0 2
23547: PPUSH
23548: CALL_OW 250
23552: PUSH
23553: LD_VAR 0 2
23557: PPUSH
23558: CALL_OW 251
23562: PUSH
23563: LD_VAR 0 2
23567: PUSH
23568: LD_INT 0
23570: PUSH
23571: LD_INT 0
23573: PUSH
23574: LD_INT 0
23576: PUSH
23577: EMPTY
23578: LIST
23579: LIST
23580: LIST
23581: LIST
23582: LIST
23583: LIST
23584: LIST
23585: PUSH
23586: EMPTY
23587: LIST
23588: PPUSH
23589: CALL_OW 446
// end ;
23593: LD_VAR 0 3
23597: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23598: LD_INT 0
23600: PPUSH
23601: PPUSH
23602: PPUSH
23603: PPUSH
23604: PPUSH
23605: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23606: LD_VAR 0 1
23610: NOT
23611: PUSH
23612: LD_VAR 0 1
23616: PPUSH
23617: CALL_OW 263
23621: PUSH
23622: LD_INT 2
23624: EQUAL
23625: NOT
23626: OR
23627: IFFALSE 23631
// exit ;
23629: GO 23947
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23631: LD_ADDR_VAR 0 6
23635: PUSH
23636: LD_INT 22
23638: PUSH
23639: LD_VAR 0 1
23643: PPUSH
23644: CALL_OW 255
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: PUSH
23653: LD_INT 2
23655: PUSH
23656: LD_INT 30
23658: PUSH
23659: LD_INT 36
23661: PUSH
23662: EMPTY
23663: LIST
23664: LIST
23665: PUSH
23666: LD_INT 34
23668: PUSH
23669: LD_INT 31
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: LIST
23680: PUSH
23681: EMPTY
23682: LIST
23683: LIST
23684: PPUSH
23685: CALL_OW 69
23689: ST_TO_ADDR
// if not tmp then
23690: LD_VAR 0 6
23694: NOT
23695: IFFALSE 23699
// exit ;
23697: GO 23947
// result := [ ] ;
23699: LD_ADDR_VAR 0 2
23703: PUSH
23704: EMPTY
23705: ST_TO_ADDR
// for i in tmp do
23706: LD_ADDR_VAR 0 3
23710: PUSH
23711: LD_VAR 0 6
23715: PUSH
23716: FOR_IN
23717: IFFALSE 23788
// begin t := UnitsInside ( i ) ;
23719: LD_ADDR_VAR 0 4
23723: PUSH
23724: LD_VAR 0 3
23728: PPUSH
23729: CALL_OW 313
23733: ST_TO_ADDR
// if t then
23734: LD_VAR 0 4
23738: IFFALSE 23786
// for j in t do
23740: LD_ADDR_VAR 0 7
23744: PUSH
23745: LD_VAR 0 4
23749: PUSH
23750: FOR_IN
23751: IFFALSE 23784
// result := Insert ( result , result + 1 , j ) ;
23753: LD_ADDR_VAR 0 2
23757: PUSH
23758: LD_VAR 0 2
23762: PPUSH
23763: LD_VAR 0 2
23767: PUSH
23768: LD_INT 1
23770: PLUS
23771: PPUSH
23772: LD_VAR 0 7
23776: PPUSH
23777: CALL_OW 2
23781: ST_TO_ADDR
23782: GO 23750
23784: POP
23785: POP
// end ;
23786: GO 23716
23788: POP
23789: POP
// if not result then
23790: LD_VAR 0 2
23794: NOT
23795: IFFALSE 23799
// exit ;
23797: GO 23947
// mech := result [ 1 ] ;
23799: LD_ADDR_VAR 0 5
23803: PUSH
23804: LD_VAR 0 2
23808: PUSH
23809: LD_INT 1
23811: ARRAY
23812: ST_TO_ADDR
// if result > 1 then
23813: LD_VAR 0 2
23817: PUSH
23818: LD_INT 1
23820: GREATER
23821: IFFALSE 23933
// for i = 2 to result do
23823: LD_ADDR_VAR 0 3
23827: PUSH
23828: DOUBLE
23829: LD_INT 2
23831: DEC
23832: ST_TO_ADDR
23833: LD_VAR 0 2
23837: PUSH
23838: FOR_TO
23839: IFFALSE 23931
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23841: LD_ADDR_VAR 0 4
23845: PUSH
23846: LD_VAR 0 2
23850: PUSH
23851: LD_VAR 0 3
23855: ARRAY
23856: PPUSH
23857: LD_INT 3
23859: PPUSH
23860: CALL_OW 259
23864: PUSH
23865: LD_VAR 0 2
23869: PUSH
23870: LD_VAR 0 3
23874: ARRAY
23875: PPUSH
23876: CALL_OW 432
23880: MINUS
23881: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23882: LD_VAR 0 4
23886: PUSH
23887: LD_VAR 0 5
23891: PPUSH
23892: LD_INT 3
23894: PPUSH
23895: CALL_OW 259
23899: PUSH
23900: LD_VAR 0 5
23904: PPUSH
23905: CALL_OW 432
23909: MINUS
23910: GREATEREQUAL
23911: IFFALSE 23929
// mech := result [ i ] ;
23913: LD_ADDR_VAR 0 5
23917: PUSH
23918: LD_VAR 0 2
23922: PUSH
23923: LD_VAR 0 3
23927: ARRAY
23928: ST_TO_ADDR
// end ;
23929: GO 23838
23931: POP
23932: POP
// ComLinkTo ( vehicle , mech ) ;
23933: LD_VAR 0 1
23937: PPUSH
23938: LD_VAR 0 5
23942: PPUSH
23943: CALL_OW 135
// end ;
23947: LD_VAR 0 2
23951: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23952: LD_INT 0
23954: PPUSH
23955: PPUSH
23956: PPUSH
23957: PPUSH
23958: PPUSH
23959: PPUSH
23960: PPUSH
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
// result := [ ] ;
23967: LD_ADDR_VAR 0 7
23971: PUSH
23972: EMPTY
23973: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23974: LD_VAR 0 1
23978: PPUSH
23979: CALL_OW 266
23983: PUSH
23984: LD_INT 0
23986: PUSH
23987: LD_INT 1
23989: PUSH
23990: EMPTY
23991: LIST
23992: LIST
23993: IN
23994: NOT
23995: IFFALSE 23999
// exit ;
23997: GO 25630
// if name then
23999: LD_VAR 0 3
24003: IFFALSE 24019
// SetBName ( base_dep , name ) ;
24005: LD_VAR 0 1
24009: PPUSH
24010: LD_VAR 0 3
24014: PPUSH
24015: CALL_OW 500
// base := GetBase ( base_dep ) ;
24019: LD_ADDR_VAR 0 15
24023: PUSH
24024: LD_VAR 0 1
24028: PPUSH
24029: CALL_OW 274
24033: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24034: LD_ADDR_VAR 0 16
24038: PUSH
24039: LD_VAR 0 1
24043: PPUSH
24044: CALL_OW 255
24048: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24049: LD_ADDR_VAR 0 17
24053: PUSH
24054: LD_VAR 0 1
24058: PPUSH
24059: CALL_OW 248
24063: ST_TO_ADDR
// if sources then
24064: LD_VAR 0 5
24068: IFFALSE 24115
// for i = 1 to 3 do
24070: LD_ADDR_VAR 0 8
24074: PUSH
24075: DOUBLE
24076: LD_INT 1
24078: DEC
24079: ST_TO_ADDR
24080: LD_INT 3
24082: PUSH
24083: FOR_TO
24084: IFFALSE 24113
// AddResourceType ( base , i , sources [ i ] ) ;
24086: LD_VAR 0 15
24090: PPUSH
24091: LD_VAR 0 8
24095: PPUSH
24096: LD_VAR 0 5
24100: PUSH
24101: LD_VAR 0 8
24105: ARRAY
24106: PPUSH
24107: CALL_OW 276
24111: GO 24083
24113: POP
24114: POP
// buildings := GetBaseBuildings ( base , area ) ;
24115: LD_ADDR_VAR 0 18
24119: PUSH
24120: LD_VAR 0 15
24124: PPUSH
24125: LD_VAR 0 2
24129: PPUSH
24130: CALL 23407 0 2
24134: ST_TO_ADDR
// InitHc ;
24135: CALL_OW 19
// InitUc ;
24139: CALL_OW 18
// uc_side := side ;
24143: LD_ADDR_OWVAR 20
24147: PUSH
24148: LD_VAR 0 16
24152: ST_TO_ADDR
// uc_nation := nation ;
24153: LD_ADDR_OWVAR 21
24157: PUSH
24158: LD_VAR 0 17
24162: ST_TO_ADDR
// if buildings then
24163: LD_VAR 0 18
24167: IFFALSE 25489
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24169: LD_ADDR_VAR 0 19
24173: PUSH
24174: LD_VAR 0 18
24178: PPUSH
24179: LD_INT 2
24181: PUSH
24182: LD_INT 30
24184: PUSH
24185: LD_INT 29
24187: PUSH
24188: EMPTY
24189: LIST
24190: LIST
24191: PUSH
24192: LD_INT 30
24194: PUSH
24195: LD_INT 30
24197: PUSH
24198: EMPTY
24199: LIST
24200: LIST
24201: PUSH
24202: EMPTY
24203: LIST
24204: LIST
24205: LIST
24206: PPUSH
24207: CALL_OW 72
24211: ST_TO_ADDR
// if tmp then
24212: LD_VAR 0 19
24216: IFFALSE 24264
// for i in tmp do
24218: LD_ADDR_VAR 0 8
24222: PUSH
24223: LD_VAR 0 19
24227: PUSH
24228: FOR_IN
24229: IFFALSE 24262
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24231: LD_VAR 0 8
24235: PPUSH
24236: CALL_OW 250
24240: PPUSH
24241: LD_VAR 0 8
24245: PPUSH
24246: CALL_OW 251
24250: PPUSH
24251: LD_VAR 0 16
24255: PPUSH
24256: CALL_OW 441
24260: GO 24228
24262: POP
24263: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24264: LD_VAR 0 18
24268: PPUSH
24269: LD_INT 2
24271: PUSH
24272: LD_INT 30
24274: PUSH
24275: LD_INT 32
24277: PUSH
24278: EMPTY
24279: LIST
24280: LIST
24281: PUSH
24282: LD_INT 30
24284: PUSH
24285: LD_INT 33
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: PUSH
24292: EMPTY
24293: LIST
24294: LIST
24295: LIST
24296: PPUSH
24297: CALL_OW 72
24301: IFFALSE 24389
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24303: LD_ADDR_VAR 0 8
24307: PUSH
24308: LD_VAR 0 18
24312: PPUSH
24313: LD_INT 2
24315: PUSH
24316: LD_INT 30
24318: PUSH
24319: LD_INT 32
24321: PUSH
24322: EMPTY
24323: LIST
24324: LIST
24325: PUSH
24326: LD_INT 30
24328: PUSH
24329: LD_INT 33
24331: PUSH
24332: EMPTY
24333: LIST
24334: LIST
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: PPUSH
24341: CALL_OW 72
24345: PUSH
24346: FOR_IN
24347: IFFALSE 24387
// begin if not GetBWeapon ( i ) then
24349: LD_VAR 0 8
24353: PPUSH
24354: CALL_OW 269
24358: NOT
24359: IFFALSE 24385
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24361: LD_VAR 0 8
24365: PPUSH
24366: LD_VAR 0 8
24370: PPUSH
24371: LD_VAR 0 2
24375: PPUSH
24376: CALL 25635 0 2
24380: PPUSH
24381: CALL_OW 431
// end ;
24385: GO 24346
24387: POP
24388: POP
// end ; for i = 1 to personel do
24389: LD_ADDR_VAR 0 8
24393: PUSH
24394: DOUBLE
24395: LD_INT 1
24397: DEC
24398: ST_TO_ADDR
24399: LD_VAR 0 6
24403: PUSH
24404: FOR_TO
24405: IFFALSE 25469
// begin if i > 4 then
24407: LD_VAR 0 8
24411: PUSH
24412: LD_INT 4
24414: GREATER
24415: IFFALSE 24419
// break ;
24417: GO 25469
// case i of 1 :
24419: LD_VAR 0 8
24423: PUSH
24424: LD_INT 1
24426: DOUBLE
24427: EQUAL
24428: IFTRUE 24432
24430: GO 24512
24432: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24433: LD_ADDR_VAR 0 12
24437: PUSH
24438: LD_VAR 0 18
24442: PPUSH
24443: LD_INT 22
24445: PUSH
24446: LD_VAR 0 16
24450: PUSH
24451: EMPTY
24452: LIST
24453: LIST
24454: PUSH
24455: LD_INT 58
24457: PUSH
24458: EMPTY
24459: LIST
24460: PUSH
24461: LD_INT 2
24463: PUSH
24464: LD_INT 30
24466: PUSH
24467: LD_INT 32
24469: PUSH
24470: EMPTY
24471: LIST
24472: LIST
24473: PUSH
24474: LD_INT 30
24476: PUSH
24477: LD_INT 4
24479: PUSH
24480: EMPTY
24481: LIST
24482: LIST
24483: PUSH
24484: LD_INT 30
24486: PUSH
24487: LD_INT 5
24489: PUSH
24490: EMPTY
24491: LIST
24492: LIST
24493: PUSH
24494: EMPTY
24495: LIST
24496: LIST
24497: LIST
24498: LIST
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: PPUSH
24505: CALL_OW 72
24509: ST_TO_ADDR
24510: GO 24734
24512: LD_INT 2
24514: DOUBLE
24515: EQUAL
24516: IFTRUE 24520
24518: GO 24582
24520: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24521: LD_ADDR_VAR 0 12
24525: PUSH
24526: LD_VAR 0 18
24530: PPUSH
24531: LD_INT 22
24533: PUSH
24534: LD_VAR 0 16
24538: PUSH
24539: EMPTY
24540: LIST
24541: LIST
24542: PUSH
24543: LD_INT 2
24545: PUSH
24546: LD_INT 30
24548: PUSH
24549: LD_INT 0
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: PUSH
24556: LD_INT 30
24558: PUSH
24559: LD_INT 1
24561: PUSH
24562: EMPTY
24563: LIST
24564: LIST
24565: PUSH
24566: EMPTY
24567: LIST
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 72
24579: ST_TO_ADDR
24580: GO 24734
24582: LD_INT 3
24584: DOUBLE
24585: EQUAL
24586: IFTRUE 24590
24588: GO 24652
24590: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24591: LD_ADDR_VAR 0 12
24595: PUSH
24596: LD_VAR 0 18
24600: PPUSH
24601: LD_INT 22
24603: PUSH
24604: LD_VAR 0 16
24608: PUSH
24609: EMPTY
24610: LIST
24611: LIST
24612: PUSH
24613: LD_INT 2
24615: PUSH
24616: LD_INT 30
24618: PUSH
24619: LD_INT 2
24621: PUSH
24622: EMPTY
24623: LIST
24624: LIST
24625: PUSH
24626: LD_INT 30
24628: PUSH
24629: LD_INT 3
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: PUSH
24636: EMPTY
24637: LIST
24638: LIST
24639: LIST
24640: PUSH
24641: EMPTY
24642: LIST
24643: LIST
24644: PPUSH
24645: CALL_OW 72
24649: ST_TO_ADDR
24650: GO 24734
24652: LD_INT 4
24654: DOUBLE
24655: EQUAL
24656: IFTRUE 24660
24658: GO 24733
24660: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24661: LD_ADDR_VAR 0 12
24665: PUSH
24666: LD_VAR 0 18
24670: PPUSH
24671: LD_INT 22
24673: PUSH
24674: LD_VAR 0 16
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 2
24685: PUSH
24686: LD_INT 30
24688: PUSH
24689: LD_INT 6
24691: PUSH
24692: EMPTY
24693: LIST
24694: LIST
24695: PUSH
24696: LD_INT 30
24698: PUSH
24699: LD_INT 7
24701: PUSH
24702: EMPTY
24703: LIST
24704: LIST
24705: PUSH
24706: LD_INT 30
24708: PUSH
24709: LD_INT 8
24711: PUSH
24712: EMPTY
24713: LIST
24714: LIST
24715: PUSH
24716: EMPTY
24717: LIST
24718: LIST
24719: LIST
24720: LIST
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PPUSH
24726: CALL_OW 72
24730: ST_TO_ADDR
24731: GO 24734
24733: POP
// if i = 1 then
24734: LD_VAR 0 8
24738: PUSH
24739: LD_INT 1
24741: EQUAL
24742: IFFALSE 24853
// begin tmp := [ ] ;
24744: LD_ADDR_VAR 0 19
24748: PUSH
24749: EMPTY
24750: ST_TO_ADDR
// for j in f do
24751: LD_ADDR_VAR 0 9
24755: PUSH
24756: LD_VAR 0 12
24760: PUSH
24761: FOR_IN
24762: IFFALSE 24835
// if GetBType ( j ) = b_bunker then
24764: LD_VAR 0 9
24768: PPUSH
24769: CALL_OW 266
24773: PUSH
24774: LD_INT 32
24776: EQUAL
24777: IFFALSE 24804
// tmp := Insert ( tmp , 1 , j ) else
24779: LD_ADDR_VAR 0 19
24783: PUSH
24784: LD_VAR 0 19
24788: PPUSH
24789: LD_INT 1
24791: PPUSH
24792: LD_VAR 0 9
24796: PPUSH
24797: CALL_OW 2
24801: ST_TO_ADDR
24802: GO 24833
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24804: LD_ADDR_VAR 0 19
24808: PUSH
24809: LD_VAR 0 19
24813: PPUSH
24814: LD_VAR 0 19
24818: PUSH
24819: LD_INT 1
24821: PLUS
24822: PPUSH
24823: LD_VAR 0 9
24827: PPUSH
24828: CALL_OW 2
24832: ST_TO_ADDR
24833: GO 24761
24835: POP
24836: POP
// if tmp then
24837: LD_VAR 0 19
24841: IFFALSE 24853
// f := tmp ;
24843: LD_ADDR_VAR 0 12
24847: PUSH
24848: LD_VAR 0 19
24852: ST_TO_ADDR
// end ; x := personel [ i ] ;
24853: LD_ADDR_VAR 0 13
24857: PUSH
24858: LD_VAR 0 6
24862: PUSH
24863: LD_VAR 0 8
24867: ARRAY
24868: ST_TO_ADDR
// if x = - 1 then
24869: LD_VAR 0 13
24873: PUSH
24874: LD_INT 1
24876: NEG
24877: EQUAL
24878: IFFALSE 25087
// begin for j in f do
24880: LD_ADDR_VAR 0 9
24884: PUSH
24885: LD_VAR 0 12
24889: PUSH
24890: FOR_IN
24891: IFFALSE 25083
// repeat InitHc ;
24893: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24897: LD_VAR 0 9
24901: PPUSH
24902: CALL_OW 266
24906: PUSH
24907: LD_INT 5
24909: EQUAL
24910: IFFALSE 24980
// begin if UnitsInside ( j ) < 3 then
24912: LD_VAR 0 9
24916: PPUSH
24917: CALL_OW 313
24921: PUSH
24922: LD_INT 3
24924: LESS
24925: IFFALSE 24961
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24927: LD_INT 0
24929: PPUSH
24930: LD_INT 5
24932: PUSH
24933: LD_INT 8
24935: PUSH
24936: LD_INT 9
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: LIST
24943: PUSH
24944: LD_VAR 0 17
24948: ARRAY
24949: PPUSH
24950: LD_VAR 0 4
24954: PPUSH
24955: CALL_OW 380
24959: GO 24978
// PrepareHuman ( false , i , skill ) ;
24961: LD_INT 0
24963: PPUSH
24964: LD_VAR 0 8
24968: PPUSH
24969: LD_VAR 0 4
24973: PPUSH
24974: CALL_OW 380
// end else
24978: GO 24997
// PrepareHuman ( false , i , skill ) ;
24980: LD_INT 0
24982: PPUSH
24983: LD_VAR 0 8
24987: PPUSH
24988: LD_VAR 0 4
24992: PPUSH
24993: CALL_OW 380
// un := CreateHuman ;
24997: LD_ADDR_VAR 0 14
25001: PUSH
25002: CALL_OW 44
25006: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25007: LD_ADDR_VAR 0 7
25011: PUSH
25012: LD_VAR 0 7
25016: PPUSH
25017: LD_INT 1
25019: PPUSH
25020: LD_VAR 0 14
25024: PPUSH
25025: CALL_OW 2
25029: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25030: LD_VAR 0 14
25034: PPUSH
25035: LD_VAR 0 9
25039: PPUSH
25040: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25044: LD_VAR 0 9
25048: PPUSH
25049: CALL_OW 313
25053: PUSH
25054: LD_INT 6
25056: EQUAL
25057: PUSH
25058: LD_VAR 0 9
25062: PPUSH
25063: CALL_OW 266
25067: PUSH
25068: LD_INT 32
25070: PUSH
25071: LD_INT 31
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: IN
25078: OR
25079: IFFALSE 24893
25081: GO 24890
25083: POP
25084: POP
// end else
25085: GO 25467
// for j = 1 to x do
25087: LD_ADDR_VAR 0 9
25091: PUSH
25092: DOUBLE
25093: LD_INT 1
25095: DEC
25096: ST_TO_ADDR
25097: LD_VAR 0 13
25101: PUSH
25102: FOR_TO
25103: IFFALSE 25465
// begin InitHc ;
25105: CALL_OW 19
// if not f then
25109: LD_VAR 0 12
25113: NOT
25114: IFFALSE 25203
// begin PrepareHuman ( false , i , skill ) ;
25116: LD_INT 0
25118: PPUSH
25119: LD_VAR 0 8
25123: PPUSH
25124: LD_VAR 0 4
25128: PPUSH
25129: CALL_OW 380
// un := CreateHuman ;
25133: LD_ADDR_VAR 0 14
25137: PUSH
25138: CALL_OW 44
25142: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25143: LD_ADDR_VAR 0 7
25147: PUSH
25148: LD_VAR 0 7
25152: PPUSH
25153: LD_INT 1
25155: PPUSH
25156: LD_VAR 0 14
25160: PPUSH
25161: CALL_OW 2
25165: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25166: LD_VAR 0 14
25170: PPUSH
25171: LD_VAR 0 1
25175: PPUSH
25176: CALL_OW 250
25180: PPUSH
25181: LD_VAR 0 1
25185: PPUSH
25186: CALL_OW 251
25190: PPUSH
25191: LD_INT 10
25193: PPUSH
25194: LD_INT 0
25196: PPUSH
25197: CALL_OW 50
// continue ;
25201: GO 25102
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25203: LD_VAR 0 12
25207: PUSH
25208: LD_INT 1
25210: ARRAY
25211: PPUSH
25212: CALL_OW 313
25216: PUSH
25217: LD_VAR 0 12
25221: PUSH
25222: LD_INT 1
25224: ARRAY
25225: PPUSH
25226: CALL_OW 266
25230: PUSH
25231: LD_INT 32
25233: PUSH
25234: LD_INT 31
25236: PUSH
25237: EMPTY
25238: LIST
25239: LIST
25240: IN
25241: AND
25242: PUSH
25243: LD_VAR 0 12
25247: PUSH
25248: LD_INT 1
25250: ARRAY
25251: PPUSH
25252: CALL_OW 313
25256: PUSH
25257: LD_INT 6
25259: EQUAL
25260: OR
25261: IFFALSE 25281
// f := Delete ( f , 1 ) ;
25263: LD_ADDR_VAR 0 12
25267: PUSH
25268: LD_VAR 0 12
25272: PPUSH
25273: LD_INT 1
25275: PPUSH
25276: CALL_OW 3
25280: ST_TO_ADDR
// if not f then
25281: LD_VAR 0 12
25285: NOT
25286: IFFALSE 25304
// begin x := x + 2 ;
25288: LD_ADDR_VAR 0 13
25292: PUSH
25293: LD_VAR 0 13
25297: PUSH
25298: LD_INT 2
25300: PLUS
25301: ST_TO_ADDR
// continue ;
25302: GO 25102
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25304: LD_VAR 0 12
25308: PUSH
25309: LD_INT 1
25311: ARRAY
25312: PPUSH
25313: CALL_OW 266
25317: PUSH
25318: LD_INT 5
25320: EQUAL
25321: IFFALSE 25395
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25323: LD_VAR 0 12
25327: PUSH
25328: LD_INT 1
25330: ARRAY
25331: PPUSH
25332: CALL_OW 313
25336: PUSH
25337: LD_INT 3
25339: LESS
25340: IFFALSE 25376
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25342: LD_INT 0
25344: PPUSH
25345: LD_INT 5
25347: PUSH
25348: LD_INT 8
25350: PUSH
25351: LD_INT 9
25353: PUSH
25354: EMPTY
25355: LIST
25356: LIST
25357: LIST
25358: PUSH
25359: LD_VAR 0 17
25363: ARRAY
25364: PPUSH
25365: LD_VAR 0 4
25369: PPUSH
25370: CALL_OW 380
25374: GO 25393
// PrepareHuman ( false , i , skill ) ;
25376: LD_INT 0
25378: PPUSH
25379: LD_VAR 0 8
25383: PPUSH
25384: LD_VAR 0 4
25388: PPUSH
25389: CALL_OW 380
// end else
25393: GO 25412
// PrepareHuman ( false , i , skill ) ;
25395: LD_INT 0
25397: PPUSH
25398: LD_VAR 0 8
25402: PPUSH
25403: LD_VAR 0 4
25407: PPUSH
25408: CALL_OW 380
// un := CreateHuman ;
25412: LD_ADDR_VAR 0 14
25416: PUSH
25417: CALL_OW 44
25421: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25422: LD_ADDR_VAR 0 7
25426: PUSH
25427: LD_VAR 0 7
25431: PPUSH
25432: LD_INT 1
25434: PPUSH
25435: LD_VAR 0 14
25439: PPUSH
25440: CALL_OW 2
25444: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25445: LD_VAR 0 14
25449: PPUSH
25450: LD_VAR 0 12
25454: PUSH
25455: LD_INT 1
25457: ARRAY
25458: PPUSH
25459: CALL_OW 52
// end ;
25463: GO 25102
25465: POP
25466: POP
// end ;
25467: GO 24404
25469: POP
25470: POP
// result := result ^ buildings ;
25471: LD_ADDR_VAR 0 7
25475: PUSH
25476: LD_VAR 0 7
25480: PUSH
25481: LD_VAR 0 18
25485: ADD
25486: ST_TO_ADDR
// end else
25487: GO 25630
// begin for i = 1 to personel do
25489: LD_ADDR_VAR 0 8
25493: PUSH
25494: DOUBLE
25495: LD_INT 1
25497: DEC
25498: ST_TO_ADDR
25499: LD_VAR 0 6
25503: PUSH
25504: FOR_TO
25505: IFFALSE 25628
// begin if i > 4 then
25507: LD_VAR 0 8
25511: PUSH
25512: LD_INT 4
25514: GREATER
25515: IFFALSE 25519
// break ;
25517: GO 25628
// x := personel [ i ] ;
25519: LD_ADDR_VAR 0 13
25523: PUSH
25524: LD_VAR 0 6
25528: PUSH
25529: LD_VAR 0 8
25533: ARRAY
25534: ST_TO_ADDR
// if x = - 1 then
25535: LD_VAR 0 13
25539: PUSH
25540: LD_INT 1
25542: NEG
25543: EQUAL
25544: IFFALSE 25548
// continue ;
25546: GO 25504
// PrepareHuman ( false , i , skill ) ;
25548: LD_INT 0
25550: PPUSH
25551: LD_VAR 0 8
25555: PPUSH
25556: LD_VAR 0 4
25560: PPUSH
25561: CALL_OW 380
// un := CreateHuman ;
25565: LD_ADDR_VAR 0 14
25569: PUSH
25570: CALL_OW 44
25574: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25575: LD_VAR 0 14
25579: PPUSH
25580: LD_VAR 0 1
25584: PPUSH
25585: CALL_OW 250
25589: PPUSH
25590: LD_VAR 0 1
25594: PPUSH
25595: CALL_OW 251
25599: PPUSH
25600: LD_INT 10
25602: PPUSH
25603: LD_INT 0
25605: PPUSH
25606: CALL_OW 50
// result := result ^ un ;
25610: LD_ADDR_VAR 0 7
25614: PUSH
25615: LD_VAR 0 7
25619: PUSH
25620: LD_VAR 0 14
25624: ADD
25625: ST_TO_ADDR
// end ;
25626: GO 25504
25628: POP
25629: POP
// end ; end ;
25630: LD_VAR 0 7
25634: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25635: LD_INT 0
25637: PPUSH
25638: PPUSH
25639: PPUSH
25640: PPUSH
25641: PPUSH
25642: PPUSH
25643: PPUSH
25644: PPUSH
25645: PPUSH
25646: PPUSH
25647: PPUSH
25648: PPUSH
25649: PPUSH
25650: PPUSH
25651: PPUSH
25652: PPUSH
// result := false ;
25653: LD_ADDR_VAR 0 3
25657: PUSH
25658: LD_INT 0
25660: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25661: LD_VAR 0 1
25665: NOT
25666: PUSH
25667: LD_VAR 0 1
25671: PPUSH
25672: CALL_OW 266
25676: PUSH
25677: LD_INT 32
25679: PUSH
25680: LD_INT 33
25682: PUSH
25683: EMPTY
25684: LIST
25685: LIST
25686: IN
25687: NOT
25688: OR
25689: IFFALSE 25693
// exit ;
25691: GO 26829
// nat := GetNation ( tower ) ;
25693: LD_ADDR_VAR 0 12
25697: PUSH
25698: LD_VAR 0 1
25702: PPUSH
25703: CALL_OW 248
25707: ST_TO_ADDR
// side := GetSide ( tower ) ;
25708: LD_ADDR_VAR 0 16
25712: PUSH
25713: LD_VAR 0 1
25717: PPUSH
25718: CALL_OW 255
25722: ST_TO_ADDR
// x := GetX ( tower ) ;
25723: LD_ADDR_VAR 0 10
25727: PUSH
25728: LD_VAR 0 1
25732: PPUSH
25733: CALL_OW 250
25737: ST_TO_ADDR
// y := GetY ( tower ) ;
25738: LD_ADDR_VAR 0 11
25742: PUSH
25743: LD_VAR 0 1
25747: PPUSH
25748: CALL_OW 251
25752: ST_TO_ADDR
// if not x or not y then
25753: LD_VAR 0 10
25757: NOT
25758: PUSH
25759: LD_VAR 0 11
25763: NOT
25764: OR
25765: IFFALSE 25769
// exit ;
25767: GO 26829
// weapon := 0 ;
25769: LD_ADDR_VAR 0 18
25773: PUSH
25774: LD_INT 0
25776: ST_TO_ADDR
// fac_list := [ ] ;
25777: LD_ADDR_VAR 0 17
25781: PUSH
25782: EMPTY
25783: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25784: LD_ADDR_VAR 0 6
25788: PUSH
25789: LD_VAR 0 1
25793: PPUSH
25794: CALL_OW 274
25798: PPUSH
25799: LD_VAR 0 2
25803: PPUSH
25804: CALL 23407 0 2
25808: PPUSH
25809: LD_INT 30
25811: PUSH
25812: LD_INT 3
25814: PUSH
25815: EMPTY
25816: LIST
25817: LIST
25818: PPUSH
25819: CALL_OW 72
25823: ST_TO_ADDR
// if not factories then
25824: LD_VAR 0 6
25828: NOT
25829: IFFALSE 25833
// exit ;
25831: GO 26829
// for i in factories do
25833: LD_ADDR_VAR 0 8
25837: PUSH
25838: LD_VAR 0 6
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25869
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25846: LD_ADDR_VAR 0 17
25850: PUSH
25851: LD_VAR 0 17
25855: PUSH
25856: LD_VAR 0 8
25860: PPUSH
25861: CALL_OW 478
25865: UNION
25866: ST_TO_ADDR
25867: GO 25843
25869: POP
25870: POP
// if not fac_list then
25871: LD_VAR 0 17
25875: NOT
25876: IFFALSE 25880
// exit ;
25878: GO 26829
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25880: LD_ADDR_VAR 0 5
25884: PUSH
25885: LD_INT 4
25887: PUSH
25888: LD_INT 5
25890: PUSH
25891: LD_INT 9
25893: PUSH
25894: LD_INT 10
25896: PUSH
25897: LD_INT 6
25899: PUSH
25900: LD_INT 7
25902: PUSH
25903: LD_INT 11
25905: PUSH
25906: EMPTY
25907: LIST
25908: LIST
25909: LIST
25910: LIST
25911: LIST
25912: LIST
25913: LIST
25914: PUSH
25915: LD_INT 27
25917: PUSH
25918: LD_INT 28
25920: PUSH
25921: LD_INT 26
25923: PUSH
25924: LD_INT 30
25926: PUSH
25927: EMPTY
25928: LIST
25929: LIST
25930: LIST
25931: LIST
25932: PUSH
25933: LD_INT 43
25935: PUSH
25936: LD_INT 44
25938: PUSH
25939: LD_INT 46
25941: PUSH
25942: LD_INT 45
25944: PUSH
25945: LD_INT 47
25947: PUSH
25948: LD_INT 49
25950: PUSH
25951: EMPTY
25952: LIST
25953: LIST
25954: LIST
25955: LIST
25956: LIST
25957: LIST
25958: PUSH
25959: EMPTY
25960: LIST
25961: LIST
25962: LIST
25963: PUSH
25964: LD_VAR 0 12
25968: ARRAY
25969: ST_TO_ADDR
// for i in list do
25970: LD_ADDR_VAR 0 8
25974: PUSH
25975: LD_VAR 0 5
25979: PUSH
25980: FOR_IN
25981: IFFALSE 26014
// if not i in fac_list then
25983: LD_VAR 0 8
25987: PUSH
25988: LD_VAR 0 17
25992: IN
25993: NOT
25994: IFFALSE 26012
// list := list diff i ;
25996: LD_ADDR_VAR 0 5
26000: PUSH
26001: LD_VAR 0 5
26005: PUSH
26006: LD_VAR 0 8
26010: DIFF
26011: ST_TO_ADDR
26012: GO 25980
26014: POP
26015: POP
// if not list then
26016: LD_VAR 0 5
26020: NOT
26021: IFFALSE 26025
// exit ;
26023: GO 26829
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26025: LD_VAR 0 12
26029: PUSH
26030: LD_INT 3
26032: EQUAL
26033: PUSH
26034: LD_INT 49
26036: PUSH
26037: LD_VAR 0 5
26041: IN
26042: AND
26043: PUSH
26044: LD_INT 31
26046: PPUSH
26047: LD_VAR 0 16
26051: PPUSH
26052: CALL_OW 321
26056: PUSH
26057: LD_INT 2
26059: EQUAL
26060: AND
26061: IFFALSE 26121
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26063: LD_INT 22
26065: PUSH
26066: LD_VAR 0 16
26070: PUSH
26071: EMPTY
26072: LIST
26073: LIST
26074: PUSH
26075: LD_INT 35
26077: PUSH
26078: LD_INT 49
26080: PUSH
26081: EMPTY
26082: LIST
26083: LIST
26084: PUSH
26085: LD_INT 91
26087: PUSH
26088: LD_VAR 0 1
26092: PUSH
26093: LD_INT 10
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: LIST
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: PPUSH
26106: CALL_OW 69
26110: NOT
26111: IFFALSE 26121
// weapon := ru_time_lapser ;
26113: LD_ADDR_VAR 0 18
26117: PUSH
26118: LD_INT 49
26120: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26121: LD_VAR 0 12
26125: PUSH
26126: LD_INT 1
26128: PUSH
26129: LD_INT 2
26131: PUSH
26132: EMPTY
26133: LIST
26134: LIST
26135: IN
26136: PUSH
26137: LD_INT 11
26139: PUSH
26140: LD_VAR 0 5
26144: IN
26145: PUSH
26146: LD_INT 30
26148: PUSH
26149: LD_VAR 0 5
26153: IN
26154: OR
26155: AND
26156: PUSH
26157: LD_INT 6
26159: PPUSH
26160: LD_VAR 0 16
26164: PPUSH
26165: CALL_OW 321
26169: PUSH
26170: LD_INT 2
26172: EQUAL
26173: AND
26174: IFFALSE 26339
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26176: LD_INT 22
26178: PUSH
26179: LD_VAR 0 16
26183: PUSH
26184: EMPTY
26185: LIST
26186: LIST
26187: PUSH
26188: LD_INT 2
26190: PUSH
26191: LD_INT 35
26193: PUSH
26194: LD_INT 11
26196: PUSH
26197: EMPTY
26198: LIST
26199: LIST
26200: PUSH
26201: LD_INT 35
26203: PUSH
26204: LD_INT 30
26206: PUSH
26207: EMPTY
26208: LIST
26209: LIST
26210: PUSH
26211: EMPTY
26212: LIST
26213: LIST
26214: LIST
26215: PUSH
26216: LD_INT 91
26218: PUSH
26219: LD_VAR 0 1
26223: PUSH
26224: LD_INT 18
26226: PUSH
26227: EMPTY
26228: LIST
26229: LIST
26230: LIST
26231: PUSH
26232: EMPTY
26233: LIST
26234: LIST
26235: LIST
26236: PPUSH
26237: CALL_OW 69
26241: NOT
26242: PUSH
26243: LD_INT 22
26245: PUSH
26246: LD_VAR 0 16
26250: PUSH
26251: EMPTY
26252: LIST
26253: LIST
26254: PUSH
26255: LD_INT 2
26257: PUSH
26258: LD_INT 30
26260: PUSH
26261: LD_INT 32
26263: PUSH
26264: EMPTY
26265: LIST
26266: LIST
26267: PUSH
26268: LD_INT 30
26270: PUSH
26271: LD_INT 33
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: PUSH
26278: EMPTY
26279: LIST
26280: LIST
26281: LIST
26282: PUSH
26283: LD_INT 91
26285: PUSH
26286: LD_VAR 0 1
26290: PUSH
26291: LD_INT 12
26293: PUSH
26294: EMPTY
26295: LIST
26296: LIST
26297: LIST
26298: PUSH
26299: EMPTY
26300: LIST
26301: LIST
26302: LIST
26303: PUSH
26304: EMPTY
26305: LIST
26306: PPUSH
26307: CALL_OW 69
26311: PUSH
26312: LD_INT 2
26314: GREATER
26315: AND
26316: IFFALSE 26339
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26318: LD_ADDR_VAR 0 18
26322: PUSH
26323: LD_INT 11
26325: PUSH
26326: LD_INT 30
26328: PUSH
26329: EMPTY
26330: LIST
26331: LIST
26332: PUSH
26333: LD_VAR 0 12
26337: ARRAY
26338: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26339: LD_VAR 0 18
26343: NOT
26344: PUSH
26345: LD_INT 40
26347: PPUSH
26348: LD_VAR 0 16
26352: PPUSH
26353: CALL_OW 321
26357: PUSH
26358: LD_INT 2
26360: EQUAL
26361: AND
26362: PUSH
26363: LD_INT 7
26365: PUSH
26366: LD_VAR 0 5
26370: IN
26371: PUSH
26372: LD_INT 28
26374: PUSH
26375: LD_VAR 0 5
26379: IN
26380: OR
26381: PUSH
26382: LD_INT 45
26384: PUSH
26385: LD_VAR 0 5
26389: IN
26390: OR
26391: AND
26392: IFFALSE 26646
// begin hex := GetHexInfo ( x , y ) ;
26394: LD_ADDR_VAR 0 4
26398: PUSH
26399: LD_VAR 0 10
26403: PPUSH
26404: LD_VAR 0 11
26408: PPUSH
26409: CALL_OW 546
26413: ST_TO_ADDR
// if hex [ 1 ] then
26414: LD_VAR 0 4
26418: PUSH
26419: LD_INT 1
26421: ARRAY
26422: IFFALSE 26426
// exit ;
26424: GO 26829
// height := hex [ 2 ] ;
26426: LD_ADDR_VAR 0 15
26430: PUSH
26431: LD_VAR 0 4
26435: PUSH
26436: LD_INT 2
26438: ARRAY
26439: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26440: LD_ADDR_VAR 0 14
26444: PUSH
26445: LD_INT 0
26447: PUSH
26448: LD_INT 2
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 5
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: LIST
26462: ST_TO_ADDR
// for i in tmp do
26463: LD_ADDR_VAR 0 8
26467: PUSH
26468: LD_VAR 0 14
26472: PUSH
26473: FOR_IN
26474: IFFALSE 26644
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26476: LD_ADDR_VAR 0 9
26480: PUSH
26481: LD_VAR 0 10
26485: PPUSH
26486: LD_VAR 0 8
26490: PPUSH
26491: LD_INT 5
26493: PPUSH
26494: CALL_OW 272
26498: PUSH
26499: LD_VAR 0 11
26503: PPUSH
26504: LD_VAR 0 8
26508: PPUSH
26509: LD_INT 5
26511: PPUSH
26512: CALL_OW 273
26516: PUSH
26517: EMPTY
26518: LIST
26519: LIST
26520: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26521: LD_VAR 0 9
26525: PUSH
26526: LD_INT 1
26528: ARRAY
26529: PPUSH
26530: LD_VAR 0 9
26534: PUSH
26535: LD_INT 2
26537: ARRAY
26538: PPUSH
26539: CALL_OW 488
26543: IFFALSE 26642
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26545: LD_ADDR_VAR 0 4
26549: PUSH
26550: LD_VAR 0 9
26554: PUSH
26555: LD_INT 1
26557: ARRAY
26558: PPUSH
26559: LD_VAR 0 9
26563: PUSH
26564: LD_INT 2
26566: ARRAY
26567: PPUSH
26568: CALL_OW 546
26572: ST_TO_ADDR
// if hex [ 1 ] then
26573: LD_VAR 0 4
26577: PUSH
26578: LD_INT 1
26580: ARRAY
26581: IFFALSE 26585
// continue ;
26583: GO 26473
// h := hex [ 2 ] ;
26585: LD_ADDR_VAR 0 13
26589: PUSH
26590: LD_VAR 0 4
26594: PUSH
26595: LD_INT 2
26597: ARRAY
26598: ST_TO_ADDR
// if h + 7 < height then
26599: LD_VAR 0 13
26603: PUSH
26604: LD_INT 7
26606: PLUS
26607: PUSH
26608: LD_VAR 0 15
26612: LESS
26613: IFFALSE 26642
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26615: LD_ADDR_VAR 0 18
26619: PUSH
26620: LD_INT 7
26622: PUSH
26623: LD_INT 28
26625: PUSH
26626: LD_INT 45
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: LIST
26633: PUSH
26634: LD_VAR 0 12
26638: ARRAY
26639: ST_TO_ADDR
// break ;
26640: GO 26644
// end ; end ; end ;
26642: GO 26473
26644: POP
26645: POP
// end ; if not weapon then
26646: LD_VAR 0 18
26650: NOT
26651: IFFALSE 26711
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26653: LD_ADDR_VAR 0 5
26657: PUSH
26658: LD_VAR 0 5
26662: PUSH
26663: LD_INT 11
26665: PUSH
26666: LD_INT 30
26668: PUSH
26669: LD_INT 49
26671: PUSH
26672: EMPTY
26673: LIST
26674: LIST
26675: LIST
26676: DIFF
26677: ST_TO_ADDR
// if not list then
26678: LD_VAR 0 5
26682: NOT
26683: IFFALSE 26687
// exit ;
26685: GO 26829
// weapon := list [ rand ( 1 , list ) ] ;
26687: LD_ADDR_VAR 0 18
26691: PUSH
26692: LD_VAR 0 5
26696: PUSH
26697: LD_INT 1
26699: PPUSH
26700: LD_VAR 0 5
26704: PPUSH
26705: CALL_OW 12
26709: ARRAY
26710: ST_TO_ADDR
// end ; if weapon then
26711: LD_VAR 0 18
26715: IFFALSE 26829
// begin tmp := CostOfWeapon ( weapon ) ;
26717: LD_ADDR_VAR 0 14
26721: PUSH
26722: LD_VAR 0 18
26726: PPUSH
26727: CALL_OW 451
26731: ST_TO_ADDR
// j := GetBase ( tower ) ;
26732: LD_ADDR_VAR 0 9
26736: PUSH
26737: LD_VAR 0 1
26741: PPUSH
26742: CALL_OW 274
26746: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26747: LD_VAR 0 9
26751: PPUSH
26752: LD_INT 1
26754: PPUSH
26755: CALL_OW 275
26759: PUSH
26760: LD_VAR 0 14
26764: PUSH
26765: LD_INT 1
26767: ARRAY
26768: GREATEREQUAL
26769: PUSH
26770: LD_VAR 0 9
26774: PPUSH
26775: LD_INT 2
26777: PPUSH
26778: CALL_OW 275
26782: PUSH
26783: LD_VAR 0 14
26787: PUSH
26788: LD_INT 2
26790: ARRAY
26791: GREATEREQUAL
26792: AND
26793: PUSH
26794: LD_VAR 0 9
26798: PPUSH
26799: LD_INT 3
26801: PPUSH
26802: CALL_OW 275
26806: PUSH
26807: LD_VAR 0 14
26811: PUSH
26812: LD_INT 3
26814: ARRAY
26815: GREATEREQUAL
26816: AND
26817: IFFALSE 26829
// result := weapon ;
26819: LD_ADDR_VAR 0 3
26823: PUSH
26824: LD_VAR 0 18
26828: ST_TO_ADDR
// end ; end ;
26829: LD_VAR 0 3
26833: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26834: LD_INT 0
26836: PPUSH
26837: PPUSH
// result := true ;
26838: LD_ADDR_VAR 0 3
26842: PUSH
26843: LD_INT 1
26845: ST_TO_ADDR
// if array1 = array2 then
26846: LD_VAR 0 1
26850: PUSH
26851: LD_VAR 0 2
26855: EQUAL
26856: IFFALSE 26916
// begin for i = 1 to array1 do
26858: LD_ADDR_VAR 0 4
26862: PUSH
26863: DOUBLE
26864: LD_INT 1
26866: DEC
26867: ST_TO_ADDR
26868: LD_VAR 0 1
26872: PUSH
26873: FOR_TO
26874: IFFALSE 26912
// if array1 [ i ] <> array2 [ i ] then
26876: LD_VAR 0 1
26880: PUSH
26881: LD_VAR 0 4
26885: ARRAY
26886: PUSH
26887: LD_VAR 0 2
26891: PUSH
26892: LD_VAR 0 4
26896: ARRAY
26897: NONEQUAL
26898: IFFALSE 26910
// begin result := false ;
26900: LD_ADDR_VAR 0 3
26904: PUSH
26905: LD_INT 0
26907: ST_TO_ADDR
// break ;
26908: GO 26912
// end ;
26910: GO 26873
26912: POP
26913: POP
// end else
26914: GO 26924
// result := false ;
26916: LD_ADDR_VAR 0 3
26920: PUSH
26921: LD_INT 0
26923: ST_TO_ADDR
// end ;
26924: LD_VAR 0 3
26928: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26929: LD_INT 0
26931: PPUSH
26932: PPUSH
26933: PPUSH
// pom := GetBase ( fac ) ;
26934: LD_ADDR_VAR 0 5
26938: PUSH
26939: LD_VAR 0 1
26943: PPUSH
26944: CALL_OW 274
26948: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26949: LD_ADDR_VAR 0 4
26953: PUSH
26954: LD_VAR 0 2
26958: PUSH
26959: LD_INT 1
26961: ARRAY
26962: PPUSH
26963: LD_VAR 0 2
26967: PUSH
26968: LD_INT 2
26970: ARRAY
26971: PPUSH
26972: LD_VAR 0 2
26976: PUSH
26977: LD_INT 3
26979: ARRAY
26980: PPUSH
26981: LD_VAR 0 2
26985: PUSH
26986: LD_INT 4
26988: ARRAY
26989: PPUSH
26990: CALL_OW 449
26994: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26995: LD_ADDR_VAR 0 3
26999: PUSH
27000: LD_VAR 0 5
27004: PPUSH
27005: LD_INT 1
27007: PPUSH
27008: CALL_OW 275
27012: PUSH
27013: LD_VAR 0 4
27017: PUSH
27018: LD_INT 1
27020: ARRAY
27021: GREATEREQUAL
27022: PUSH
27023: LD_VAR 0 5
27027: PPUSH
27028: LD_INT 2
27030: PPUSH
27031: CALL_OW 275
27035: PUSH
27036: LD_VAR 0 4
27040: PUSH
27041: LD_INT 2
27043: ARRAY
27044: GREATEREQUAL
27045: AND
27046: PUSH
27047: LD_VAR 0 5
27051: PPUSH
27052: LD_INT 3
27054: PPUSH
27055: CALL_OW 275
27059: PUSH
27060: LD_VAR 0 4
27064: PUSH
27065: LD_INT 3
27067: ARRAY
27068: GREATEREQUAL
27069: AND
27070: ST_TO_ADDR
// end ;
27071: LD_VAR 0 3
27075: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27076: LD_INT 0
27078: PPUSH
27079: PPUSH
27080: PPUSH
27081: PPUSH
// pom := GetBase ( building ) ;
27082: LD_ADDR_VAR 0 3
27086: PUSH
27087: LD_VAR 0 1
27091: PPUSH
27092: CALL_OW 274
27096: ST_TO_ADDR
// if not pom then
27097: LD_VAR 0 3
27101: NOT
27102: IFFALSE 27106
// exit ;
27104: GO 27276
// btype := GetBType ( building ) ;
27106: LD_ADDR_VAR 0 5
27110: PUSH
27111: LD_VAR 0 1
27115: PPUSH
27116: CALL_OW 266
27120: ST_TO_ADDR
// if btype = b_armoury then
27121: LD_VAR 0 5
27125: PUSH
27126: LD_INT 4
27128: EQUAL
27129: IFFALSE 27139
// btype := b_barracks ;
27131: LD_ADDR_VAR 0 5
27135: PUSH
27136: LD_INT 5
27138: ST_TO_ADDR
// if btype = b_depot then
27139: LD_VAR 0 5
27143: PUSH
27144: LD_INT 0
27146: EQUAL
27147: IFFALSE 27157
// btype := b_warehouse ;
27149: LD_ADDR_VAR 0 5
27153: PUSH
27154: LD_INT 1
27156: ST_TO_ADDR
// if btype = b_workshop then
27157: LD_VAR 0 5
27161: PUSH
27162: LD_INT 2
27164: EQUAL
27165: IFFALSE 27175
// btype := b_factory ;
27167: LD_ADDR_VAR 0 5
27171: PUSH
27172: LD_INT 3
27174: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27175: LD_ADDR_VAR 0 4
27179: PUSH
27180: LD_VAR 0 5
27184: PPUSH
27185: LD_VAR 0 1
27189: PPUSH
27190: CALL_OW 248
27194: PPUSH
27195: CALL_OW 450
27199: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27200: LD_ADDR_VAR 0 2
27204: PUSH
27205: LD_VAR 0 3
27209: PPUSH
27210: LD_INT 1
27212: PPUSH
27213: CALL_OW 275
27217: PUSH
27218: LD_VAR 0 4
27222: PUSH
27223: LD_INT 1
27225: ARRAY
27226: GREATEREQUAL
27227: PUSH
27228: LD_VAR 0 3
27232: PPUSH
27233: LD_INT 2
27235: PPUSH
27236: CALL_OW 275
27240: PUSH
27241: LD_VAR 0 4
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: GREATEREQUAL
27250: AND
27251: PUSH
27252: LD_VAR 0 3
27256: PPUSH
27257: LD_INT 3
27259: PPUSH
27260: CALL_OW 275
27264: PUSH
27265: LD_VAR 0 4
27269: PUSH
27270: LD_INT 3
27272: ARRAY
27273: GREATEREQUAL
27274: AND
27275: ST_TO_ADDR
// end ;
27276: LD_VAR 0 2
27280: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27281: LD_INT 0
27283: PPUSH
27284: PPUSH
27285: PPUSH
// pom := GetBase ( building ) ;
27286: LD_ADDR_VAR 0 4
27290: PUSH
27291: LD_VAR 0 1
27295: PPUSH
27296: CALL_OW 274
27300: ST_TO_ADDR
// if not pom then
27301: LD_VAR 0 4
27305: NOT
27306: IFFALSE 27310
// exit ;
27308: GO 27411
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27310: LD_ADDR_VAR 0 5
27314: PUSH
27315: LD_VAR 0 2
27319: PPUSH
27320: LD_VAR 0 1
27324: PPUSH
27325: CALL_OW 248
27329: PPUSH
27330: CALL_OW 450
27334: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27335: LD_ADDR_VAR 0 3
27339: PUSH
27340: LD_VAR 0 4
27344: PPUSH
27345: LD_INT 1
27347: PPUSH
27348: CALL_OW 275
27352: PUSH
27353: LD_VAR 0 5
27357: PUSH
27358: LD_INT 1
27360: ARRAY
27361: GREATEREQUAL
27362: PUSH
27363: LD_VAR 0 4
27367: PPUSH
27368: LD_INT 2
27370: PPUSH
27371: CALL_OW 275
27375: PUSH
27376: LD_VAR 0 5
27380: PUSH
27381: LD_INT 2
27383: ARRAY
27384: GREATEREQUAL
27385: AND
27386: PUSH
27387: LD_VAR 0 4
27391: PPUSH
27392: LD_INT 3
27394: PPUSH
27395: CALL_OW 275
27399: PUSH
27400: LD_VAR 0 5
27404: PUSH
27405: LD_INT 3
27407: ARRAY
27408: GREATEREQUAL
27409: AND
27410: ST_TO_ADDR
// end ;
27411: LD_VAR 0 3
27415: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27416: LD_INT 0
27418: PPUSH
27419: PPUSH
27420: PPUSH
27421: PPUSH
27422: PPUSH
27423: PPUSH
27424: PPUSH
27425: PPUSH
27426: PPUSH
27427: PPUSH
// result := false ;
27428: LD_ADDR_VAR 0 6
27432: PUSH
27433: LD_INT 0
27435: ST_TO_ADDR
// if not base or not btype or not x or not y then
27436: LD_VAR 0 1
27440: NOT
27441: PUSH
27442: LD_VAR 0 2
27446: NOT
27447: OR
27448: PUSH
27449: LD_VAR 0 3
27453: NOT
27454: OR
27455: PUSH
27456: LD_VAR 0 4
27460: NOT
27461: OR
27462: IFFALSE 27466
// exit ;
27464: GO 28057
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27466: LD_ADDR_VAR 0 12
27470: PUSH
27471: LD_VAR 0 2
27475: PPUSH
27476: LD_VAR 0 3
27480: PPUSH
27481: LD_VAR 0 4
27485: PPUSH
27486: LD_VAR 0 5
27490: PPUSH
27491: LD_VAR 0 1
27495: PUSH
27496: LD_INT 1
27498: ARRAY
27499: PPUSH
27500: CALL_OW 248
27504: PPUSH
27505: LD_INT 0
27507: PPUSH
27508: CALL 28894 0 6
27512: ST_TO_ADDR
// if not hexes then
27513: LD_VAR 0 12
27517: NOT
27518: IFFALSE 27522
// exit ;
27520: GO 28057
// for i = 1 to hexes do
27522: LD_ADDR_VAR 0 7
27526: PUSH
27527: DOUBLE
27528: LD_INT 1
27530: DEC
27531: ST_TO_ADDR
27532: LD_VAR 0 12
27536: PUSH
27537: FOR_TO
27538: IFFALSE 28055
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27540: LD_ADDR_VAR 0 11
27544: PUSH
27545: LD_VAR 0 12
27549: PUSH
27550: LD_VAR 0 7
27554: ARRAY
27555: PUSH
27556: LD_INT 1
27558: ARRAY
27559: PPUSH
27560: LD_VAR 0 12
27564: PUSH
27565: LD_VAR 0 7
27569: ARRAY
27570: PUSH
27571: LD_INT 2
27573: ARRAY
27574: PPUSH
27575: CALL_OW 428
27579: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27580: LD_VAR 0 12
27584: PUSH
27585: LD_VAR 0 7
27589: ARRAY
27590: PUSH
27591: LD_INT 1
27593: ARRAY
27594: PPUSH
27595: LD_VAR 0 12
27599: PUSH
27600: LD_VAR 0 7
27604: ARRAY
27605: PUSH
27606: LD_INT 2
27608: ARRAY
27609: PPUSH
27610: CALL_OW 351
27614: PUSH
27615: LD_VAR 0 12
27619: PUSH
27620: LD_VAR 0 7
27624: ARRAY
27625: PUSH
27626: LD_INT 1
27628: ARRAY
27629: PPUSH
27630: LD_VAR 0 12
27634: PUSH
27635: LD_VAR 0 7
27639: ARRAY
27640: PUSH
27641: LD_INT 2
27643: ARRAY
27644: PPUSH
27645: CALL_OW 488
27649: NOT
27650: OR
27651: PUSH
27652: LD_VAR 0 11
27656: PPUSH
27657: CALL_OW 247
27661: PUSH
27662: LD_INT 3
27664: EQUAL
27665: OR
27666: IFFALSE 27672
// exit ;
27668: POP
27669: POP
27670: GO 28057
// if not tmp then
27672: LD_VAR 0 11
27676: NOT
27677: IFFALSE 27681
// continue ;
27679: GO 27537
// result := true ;
27681: LD_ADDR_VAR 0 6
27685: PUSH
27686: LD_INT 1
27688: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27689: LD_ADDR_VAR 0 15
27693: PUSH
27694: LD_INT 22
27696: PUSH
27697: LD_VAR 0 11
27701: PPUSH
27702: CALL_OW 255
27706: PUSH
27707: EMPTY
27708: LIST
27709: LIST
27710: PUSH
27711: LD_INT 2
27713: PUSH
27714: LD_INT 30
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 30
27726: PUSH
27727: LD_INT 1
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: LIST
27738: PUSH
27739: EMPTY
27740: LIST
27741: LIST
27742: PPUSH
27743: CALL_OW 69
27747: ST_TO_ADDR
// if dep then
27748: LD_VAR 0 15
27752: IFFALSE 27888
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27754: LD_ADDR_VAR 0 14
27758: PUSH
27759: LD_VAR 0 15
27763: PUSH
27764: LD_INT 1
27766: ARRAY
27767: PPUSH
27768: CALL_OW 250
27772: PPUSH
27773: LD_VAR 0 15
27777: PUSH
27778: LD_INT 1
27780: ARRAY
27781: PPUSH
27782: CALL_OW 254
27786: PPUSH
27787: LD_INT 5
27789: PPUSH
27790: CALL_OW 272
27794: PUSH
27795: LD_VAR 0 15
27799: PUSH
27800: LD_INT 1
27802: ARRAY
27803: PPUSH
27804: CALL_OW 251
27808: PPUSH
27809: LD_VAR 0 15
27813: PUSH
27814: LD_INT 1
27816: ARRAY
27817: PPUSH
27818: CALL_OW 254
27822: PPUSH
27823: LD_INT 5
27825: PPUSH
27826: CALL_OW 273
27830: PUSH
27831: EMPTY
27832: LIST
27833: LIST
27834: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27835: LD_VAR 0 14
27839: PUSH
27840: LD_INT 1
27842: ARRAY
27843: PPUSH
27844: LD_VAR 0 14
27848: PUSH
27849: LD_INT 2
27851: ARRAY
27852: PPUSH
27853: CALL_OW 488
27857: IFFALSE 27888
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27859: LD_VAR 0 11
27863: PPUSH
27864: LD_VAR 0 14
27868: PUSH
27869: LD_INT 1
27871: ARRAY
27872: PPUSH
27873: LD_VAR 0 14
27877: PUSH
27878: LD_INT 2
27880: ARRAY
27881: PPUSH
27882: CALL_OW 111
// continue ;
27886: GO 27537
// end ; end ; r := GetDir ( tmp ) ;
27888: LD_ADDR_VAR 0 13
27892: PUSH
27893: LD_VAR 0 11
27897: PPUSH
27898: CALL_OW 254
27902: ST_TO_ADDR
// if r = 5 then
27903: LD_VAR 0 13
27907: PUSH
27908: LD_INT 5
27910: EQUAL
27911: IFFALSE 27921
// r := 0 ;
27913: LD_ADDR_VAR 0 13
27917: PUSH
27918: LD_INT 0
27920: ST_TO_ADDR
// for j = r to 5 do
27921: LD_ADDR_VAR 0 8
27925: PUSH
27926: DOUBLE
27927: LD_VAR 0 13
27931: DEC
27932: ST_TO_ADDR
27933: LD_INT 5
27935: PUSH
27936: FOR_TO
27937: IFFALSE 28051
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27939: LD_ADDR_VAR 0 9
27943: PUSH
27944: LD_VAR 0 11
27948: PPUSH
27949: CALL_OW 250
27953: PPUSH
27954: LD_VAR 0 8
27958: PPUSH
27959: LD_INT 2
27961: PPUSH
27962: CALL_OW 272
27966: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27967: LD_ADDR_VAR 0 10
27971: PUSH
27972: LD_VAR 0 11
27976: PPUSH
27977: CALL_OW 251
27981: PPUSH
27982: LD_VAR 0 8
27986: PPUSH
27987: LD_INT 2
27989: PPUSH
27990: CALL_OW 273
27994: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27995: LD_VAR 0 9
27999: PPUSH
28000: LD_VAR 0 10
28004: PPUSH
28005: CALL_OW 488
28009: PUSH
28010: LD_VAR 0 9
28014: PPUSH
28015: LD_VAR 0 10
28019: PPUSH
28020: CALL_OW 428
28024: NOT
28025: AND
28026: IFFALSE 28049
// begin ComMoveXY ( tmp , _x , _y ) ;
28028: LD_VAR 0 11
28032: PPUSH
28033: LD_VAR 0 9
28037: PPUSH
28038: LD_VAR 0 10
28042: PPUSH
28043: CALL_OW 111
// break ;
28047: GO 28051
// end ; end ;
28049: GO 27936
28051: POP
28052: POP
// end ;
28053: GO 27537
28055: POP
28056: POP
// end ;
28057: LD_VAR 0 6
28061: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28062: LD_INT 0
28064: PPUSH
28065: PPUSH
28066: PPUSH
28067: PPUSH
28068: PPUSH
28069: PPUSH
28070: PPUSH
28071: PPUSH
28072: PPUSH
28073: PPUSH
// result := false ;
28074: LD_ADDR_VAR 0 6
28078: PUSH
28079: LD_INT 0
28081: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28082: LD_VAR 0 1
28086: NOT
28087: PUSH
28088: LD_VAR 0 1
28092: PPUSH
28093: CALL_OW 266
28097: PUSH
28098: LD_INT 0
28100: PUSH
28101: LD_INT 1
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: IN
28108: NOT
28109: OR
28110: PUSH
28111: LD_VAR 0 2
28115: NOT
28116: OR
28117: PUSH
28118: LD_VAR 0 5
28122: PUSH
28123: LD_INT 0
28125: PUSH
28126: LD_INT 1
28128: PUSH
28129: LD_INT 2
28131: PUSH
28132: LD_INT 3
28134: PUSH
28135: LD_INT 4
28137: PUSH
28138: LD_INT 5
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: LIST
28145: LIST
28146: LIST
28147: LIST
28148: IN
28149: NOT
28150: OR
28151: PUSH
28152: LD_VAR 0 3
28156: PPUSH
28157: LD_VAR 0 4
28161: PPUSH
28162: CALL_OW 488
28166: NOT
28167: OR
28168: IFFALSE 28172
// exit ;
28170: GO 28889
// pom := GetBase ( bdepot ) ;
28172: LD_ADDR_VAR 0 10
28176: PUSH
28177: LD_VAR 0 1
28181: PPUSH
28182: CALL_OW 274
28186: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
28187: LD_ADDR_VAR 0 11
28191: PUSH
28192: LD_VAR 0 2
28196: PPUSH
28197: LD_VAR 0 1
28201: PPUSH
28202: CALL_OW 248
28206: PPUSH
28207: CALL_OW 450
28211: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28212: LD_VAR 0 10
28216: PPUSH
28217: LD_INT 1
28219: PPUSH
28220: CALL_OW 275
28224: PUSH
28225: LD_VAR 0 11
28229: PUSH
28230: LD_INT 1
28232: ARRAY
28233: GREATEREQUAL
28234: PUSH
28235: LD_VAR 0 10
28239: PPUSH
28240: LD_INT 2
28242: PPUSH
28243: CALL_OW 275
28247: PUSH
28248: LD_VAR 0 11
28252: PUSH
28253: LD_INT 2
28255: ARRAY
28256: GREATEREQUAL
28257: AND
28258: PUSH
28259: LD_VAR 0 10
28263: PPUSH
28264: LD_INT 3
28266: PPUSH
28267: CALL_OW 275
28271: PUSH
28272: LD_VAR 0 11
28276: PUSH
28277: LD_INT 3
28279: ARRAY
28280: GREATEREQUAL
28281: AND
28282: NOT
28283: IFFALSE 28287
// exit ;
28285: GO 28889
// if GetBType ( bdepot ) = b_depot then
28287: LD_VAR 0 1
28291: PPUSH
28292: CALL_OW 266
28296: PUSH
28297: LD_INT 0
28299: EQUAL
28300: IFFALSE 28312
// dist := 28 else
28302: LD_ADDR_VAR 0 14
28306: PUSH
28307: LD_INT 28
28309: ST_TO_ADDR
28310: GO 28320
// dist := 36 ;
28312: LD_ADDR_VAR 0 14
28316: PUSH
28317: LD_INT 36
28319: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
28320: LD_VAR 0 1
28324: PPUSH
28325: LD_VAR 0 3
28329: PPUSH
28330: LD_VAR 0 4
28334: PPUSH
28335: CALL_OW 297
28339: PUSH
28340: LD_VAR 0 14
28344: GREATER
28345: IFFALSE 28349
// exit ;
28347: GO 28889
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
28349: LD_ADDR_VAR 0 12
28353: PUSH
28354: LD_VAR 0 2
28358: PPUSH
28359: LD_VAR 0 3
28363: PPUSH
28364: LD_VAR 0 4
28368: PPUSH
28369: LD_VAR 0 5
28373: PPUSH
28374: LD_VAR 0 1
28378: PPUSH
28379: CALL_OW 248
28383: PPUSH
28384: LD_INT 0
28386: PPUSH
28387: CALL 28894 0 6
28391: ST_TO_ADDR
// if not hexes then
28392: LD_VAR 0 12
28396: NOT
28397: IFFALSE 28401
// exit ;
28399: GO 28889
// hex := GetHexInfo ( x , y ) ;
28401: LD_ADDR_VAR 0 15
28405: PUSH
28406: LD_VAR 0 3
28410: PPUSH
28411: LD_VAR 0 4
28415: PPUSH
28416: CALL_OW 546
28420: ST_TO_ADDR
// if hex [ 1 ] then
28421: LD_VAR 0 15
28425: PUSH
28426: LD_INT 1
28428: ARRAY
28429: IFFALSE 28433
// exit ;
28431: GO 28889
// height := hex [ 2 ] ;
28433: LD_ADDR_VAR 0 13
28437: PUSH
28438: LD_VAR 0 15
28442: PUSH
28443: LD_INT 2
28445: ARRAY
28446: ST_TO_ADDR
// for i = 1 to hexes do
28447: LD_ADDR_VAR 0 7
28451: PUSH
28452: DOUBLE
28453: LD_INT 1
28455: DEC
28456: ST_TO_ADDR
28457: LD_VAR 0 12
28461: PUSH
28462: FOR_TO
28463: IFFALSE 28793
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28465: LD_VAR 0 12
28469: PUSH
28470: LD_VAR 0 7
28474: ARRAY
28475: PUSH
28476: LD_INT 1
28478: ARRAY
28479: PPUSH
28480: LD_VAR 0 12
28484: PUSH
28485: LD_VAR 0 7
28489: ARRAY
28490: PUSH
28491: LD_INT 2
28493: ARRAY
28494: PPUSH
28495: CALL_OW 488
28499: NOT
28500: PUSH
28501: LD_VAR 0 12
28505: PUSH
28506: LD_VAR 0 7
28510: ARRAY
28511: PUSH
28512: LD_INT 1
28514: ARRAY
28515: PPUSH
28516: LD_VAR 0 12
28520: PUSH
28521: LD_VAR 0 7
28525: ARRAY
28526: PUSH
28527: LD_INT 2
28529: ARRAY
28530: PPUSH
28531: CALL_OW 428
28535: PUSH
28536: LD_INT 0
28538: GREATER
28539: OR
28540: PUSH
28541: LD_VAR 0 12
28545: PUSH
28546: LD_VAR 0 7
28550: ARRAY
28551: PUSH
28552: LD_INT 1
28554: ARRAY
28555: PPUSH
28556: LD_VAR 0 12
28560: PUSH
28561: LD_VAR 0 7
28565: ARRAY
28566: PUSH
28567: LD_INT 2
28569: ARRAY
28570: PPUSH
28571: CALL_OW 351
28575: OR
28576: IFFALSE 28582
// exit ;
28578: POP
28579: POP
28580: GO 28889
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28582: LD_ADDR_VAR 0 8
28586: PUSH
28587: LD_VAR 0 12
28591: PUSH
28592: LD_VAR 0 7
28596: ARRAY
28597: PUSH
28598: LD_INT 1
28600: ARRAY
28601: PPUSH
28602: LD_VAR 0 12
28606: PUSH
28607: LD_VAR 0 7
28611: ARRAY
28612: PUSH
28613: LD_INT 2
28615: ARRAY
28616: PPUSH
28617: CALL_OW 546
28621: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28622: LD_VAR 0 8
28626: PUSH
28627: LD_INT 1
28629: ARRAY
28630: PUSH
28631: LD_VAR 0 8
28635: PUSH
28636: LD_INT 2
28638: ARRAY
28639: PUSH
28640: LD_VAR 0 13
28644: PUSH
28645: LD_INT 2
28647: PLUS
28648: GREATER
28649: OR
28650: PUSH
28651: LD_VAR 0 8
28655: PUSH
28656: LD_INT 2
28658: ARRAY
28659: PUSH
28660: LD_VAR 0 13
28664: PUSH
28665: LD_INT 2
28667: MINUS
28668: LESS
28669: OR
28670: PUSH
28671: LD_VAR 0 8
28675: PUSH
28676: LD_INT 3
28678: ARRAY
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 8
28685: PUSH
28686: LD_INT 9
28688: PUSH
28689: LD_INT 10
28691: PUSH
28692: LD_INT 11
28694: PUSH
28695: LD_INT 12
28697: PUSH
28698: LD_INT 13
28700: PUSH
28701: LD_INT 16
28703: PUSH
28704: LD_INT 17
28706: PUSH
28707: LD_INT 18
28709: PUSH
28710: LD_INT 19
28712: PUSH
28713: LD_INT 20
28715: PUSH
28716: LD_INT 21
28718: PUSH
28719: EMPTY
28720: LIST
28721: LIST
28722: LIST
28723: LIST
28724: LIST
28725: LIST
28726: LIST
28727: LIST
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: LIST
28733: IN
28734: NOT
28735: OR
28736: PUSH
28737: LD_VAR 0 8
28741: PUSH
28742: LD_INT 5
28744: ARRAY
28745: NOT
28746: OR
28747: PUSH
28748: LD_VAR 0 8
28752: PUSH
28753: LD_INT 6
28755: ARRAY
28756: PUSH
28757: LD_INT 1
28759: PUSH
28760: LD_INT 2
28762: PUSH
28763: LD_INT 7
28765: PUSH
28766: LD_INT 9
28768: PUSH
28769: LD_INT 10
28771: PUSH
28772: LD_INT 11
28774: PUSH
28775: EMPTY
28776: LIST
28777: LIST
28778: LIST
28779: LIST
28780: LIST
28781: LIST
28782: IN
28783: NOT
28784: OR
28785: IFFALSE 28791
// exit ;
28787: POP
28788: POP
28789: GO 28889
// end ;
28791: GO 28462
28793: POP
28794: POP
// side := GetSide ( bdepot ) ;
28795: LD_ADDR_VAR 0 9
28799: PUSH
28800: LD_VAR 0 1
28804: PPUSH
28805: CALL_OW 255
28809: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28810: LD_VAR 0 9
28814: PPUSH
28815: LD_VAR 0 3
28819: PPUSH
28820: LD_VAR 0 4
28824: PPUSH
28825: LD_INT 20
28827: PPUSH
28828: CALL 21561 0 4
28832: PUSH
28833: LD_INT 4
28835: ARRAY
28836: IFFALSE 28840
// exit ;
28838: GO 28889
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28840: LD_VAR 0 2
28844: PUSH
28845: LD_INT 29
28847: PUSH
28848: LD_INT 30
28850: PUSH
28851: EMPTY
28852: LIST
28853: LIST
28854: IN
28855: PUSH
28856: LD_VAR 0 3
28860: PPUSH
28861: LD_VAR 0 4
28865: PPUSH
28866: LD_VAR 0 9
28870: PPUSH
28871: CALL_OW 440
28875: NOT
28876: AND
28877: IFFALSE 28881
// exit ;
28879: GO 28889
// result := true ;
28881: LD_ADDR_VAR 0 6
28885: PUSH
28886: LD_INT 1
28888: ST_TO_ADDR
// end ;
28889: LD_VAR 0 6
28893: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28894: LD_INT 0
28896: PPUSH
28897: PPUSH
28898: PPUSH
28899: PPUSH
28900: PPUSH
28901: PPUSH
28902: PPUSH
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
28921: PPUSH
28922: PPUSH
28923: PPUSH
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
// result = [ ] ;
28954: LD_ADDR_VAR 0 7
28958: PUSH
28959: EMPTY
28960: ST_TO_ADDR
// temp_list = [ ] ;
28961: LD_ADDR_VAR 0 9
28965: PUSH
28966: EMPTY
28967: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28968: LD_VAR 0 4
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 1
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 4
28987: PUSH
28988: LD_INT 5
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: IN
28999: NOT
29000: PUSH
29001: LD_VAR 0 1
29005: PUSH
29006: LD_INT 0
29008: PUSH
29009: LD_INT 1
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: IN
29016: PUSH
29017: LD_VAR 0 5
29021: PUSH
29022: LD_INT 1
29024: PUSH
29025: LD_INT 2
29027: PUSH
29028: LD_INT 3
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: LIST
29035: IN
29036: NOT
29037: AND
29038: OR
29039: IFFALSE 29043
// exit ;
29041: GO 47428
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29043: LD_VAR 0 1
29047: PUSH
29048: LD_INT 6
29050: PUSH
29051: LD_INT 7
29053: PUSH
29054: LD_INT 8
29056: PUSH
29057: LD_INT 13
29059: PUSH
29060: LD_INT 12
29062: PUSH
29063: LD_INT 15
29065: PUSH
29066: LD_INT 11
29068: PUSH
29069: LD_INT 14
29071: PUSH
29072: LD_INT 10
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: LIST
29079: LIST
29080: LIST
29081: LIST
29082: LIST
29083: LIST
29084: LIST
29085: IN
29086: IFFALSE 29096
// btype = b_lab ;
29088: LD_ADDR_VAR 0 1
29092: PUSH
29093: LD_INT 6
29095: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29096: LD_VAR 0 6
29100: PUSH
29101: LD_INT 0
29103: PUSH
29104: LD_INT 1
29106: PUSH
29107: LD_INT 2
29109: PUSH
29110: EMPTY
29111: LIST
29112: LIST
29113: LIST
29114: IN
29115: NOT
29116: PUSH
29117: LD_VAR 0 1
29121: PUSH
29122: LD_INT 0
29124: PUSH
29125: LD_INT 1
29127: PUSH
29128: LD_INT 2
29130: PUSH
29131: LD_INT 3
29133: PUSH
29134: LD_INT 6
29136: PUSH
29137: LD_INT 36
29139: PUSH
29140: LD_INT 4
29142: PUSH
29143: LD_INT 5
29145: PUSH
29146: LD_INT 31
29148: PUSH
29149: LD_INT 32
29151: PUSH
29152: LD_INT 33
29154: PUSH
29155: EMPTY
29156: LIST
29157: LIST
29158: LIST
29159: LIST
29160: LIST
29161: LIST
29162: LIST
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: IN
29168: NOT
29169: PUSH
29170: LD_VAR 0 6
29174: PUSH
29175: LD_INT 1
29177: EQUAL
29178: AND
29179: OR
29180: PUSH
29181: LD_VAR 0 1
29185: PUSH
29186: LD_INT 2
29188: PUSH
29189: LD_INT 3
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: IN
29196: NOT
29197: PUSH
29198: LD_VAR 0 6
29202: PUSH
29203: LD_INT 2
29205: EQUAL
29206: AND
29207: OR
29208: IFFALSE 29218
// mode = 0 ;
29210: LD_ADDR_VAR 0 6
29214: PUSH
29215: LD_INT 0
29217: ST_TO_ADDR
// case mode of 0 :
29218: LD_VAR 0 6
29222: PUSH
29223: LD_INT 0
29225: DOUBLE
29226: EQUAL
29227: IFTRUE 29231
29229: GO 40684
29231: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29232: LD_ADDR_VAR 0 11
29236: PUSH
29237: LD_INT 0
29239: PUSH
29240: LD_INT 0
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 1
29252: NEG
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: PUSH
29261: LD_INT 0
29263: PUSH
29264: EMPTY
29265: LIST
29266: LIST
29267: PUSH
29268: LD_INT 1
29270: PUSH
29271: LD_INT 1
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 0
29280: PUSH
29281: LD_INT 1
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: LD_INT 1
29290: NEG
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 1
29301: NEG
29302: PUSH
29303: LD_INT 1
29305: NEG
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 1
29313: NEG
29314: PUSH
29315: LD_INT 2
29317: NEG
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 0
29325: PUSH
29326: LD_INT 2
29328: NEG
29329: PUSH
29330: EMPTY
29331: LIST
29332: LIST
29333: PUSH
29334: LD_INT 1
29336: PUSH
29337: LD_INT 1
29339: NEG
29340: PUSH
29341: EMPTY
29342: LIST
29343: LIST
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: LD_INT 2
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 0
29357: PUSH
29358: LD_INT 2
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 1
29367: NEG
29368: PUSH
29369: LD_INT 1
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: LD_INT 3
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: LD_INT 3
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: LD_INT 2
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29425: LD_ADDR_VAR 0 12
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 0
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 1
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 2
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 1
29537: NEG
29538: PUSH
29539: LD_INT 1
29541: PUSH
29542: EMPTY
29543: LIST
29544: LIST
29545: PUSH
29546: LD_INT 2
29548: NEG
29549: PUSH
29550: LD_INT 0
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 2
29559: NEG
29560: PUSH
29561: LD_INT 1
29563: NEG
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 3
29582: NEG
29583: PUSH
29584: LD_INT 0
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 3
29593: NEG
29594: PUSH
29595: LD_INT 1
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29621: LD_ADDR_VAR 0 13
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 0
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: LD_INT 2
29706: NEG
29707: PUSH
29708: EMPTY
29709: LIST
29710: LIST
29711: PUSH
29712: LD_INT 2
29714: PUSH
29715: LD_INT 1
29717: PUSH
29718: EMPTY
29719: LIST
29720: LIST
29721: PUSH
29722: LD_INT 2
29724: PUSH
29725: LD_INT 2
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: LD_INT 2
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 2
29744: NEG
29745: PUSH
29746: LD_INT 1
29748: NEG
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 2
29756: NEG
29757: PUSH
29758: LD_INT 2
29760: NEG
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: LD_INT 3
29772: NEG
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 3
29780: NEG
29781: PUSH
29782: LD_INT 2
29784: NEG
29785: PUSH
29786: EMPTY
29787: LIST
29788: LIST
29789: PUSH
29790: LD_INT 3
29792: NEG
29793: PUSH
29794: LD_INT 3
29796: NEG
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29820: LD_ADDR_VAR 0 14
29824: PUSH
29825: LD_INT 0
29827: PUSH
29828: LD_INT 0
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: LD_INT 1
29840: NEG
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: PUSH
29849: LD_INT 0
29851: PUSH
29852: EMPTY
29853: LIST
29854: LIST
29855: PUSH
29856: LD_INT 1
29858: PUSH
29859: LD_INT 1
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: LD_INT 0
29868: PUSH
29869: LD_INT 1
29871: PUSH
29872: EMPTY
29873: LIST
29874: LIST
29875: PUSH
29876: LD_INT 1
29878: NEG
29879: PUSH
29880: LD_INT 0
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: PUSH
29887: LD_INT 1
29889: NEG
29890: PUSH
29891: LD_INT 1
29893: NEG
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 1
29901: NEG
29902: PUSH
29903: LD_INT 2
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 0
29913: PUSH
29914: LD_INT 2
29916: NEG
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 1
29924: PUSH
29925: LD_INT 1
29927: NEG
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: LD_INT 2
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 2
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 1
29955: NEG
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: NEG
29967: PUSH
29968: LD_INT 3
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 0
29978: PUSH
29979: LD_INT 3
29981: NEG
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: LD_INT 2
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: EMPTY
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30016: LD_ADDR_VAR 0 15
30020: PUSH
30021: LD_INT 0
30023: PUSH
30024: LD_INT 0
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 1
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 1
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 0
30064: PUSH
30065: LD_INT 1
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 1
30074: NEG
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: PUSH
30083: LD_INT 1
30085: NEG
30086: PUSH
30087: LD_INT 1
30089: NEG
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 2
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 2
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 1
30128: NEG
30129: PUSH
30130: LD_INT 1
30132: PUSH
30133: EMPTY
30134: LIST
30135: LIST
30136: PUSH
30137: LD_INT 2
30139: NEG
30140: PUSH
30141: LD_INT 0
30143: PUSH
30144: EMPTY
30145: LIST
30146: LIST
30147: PUSH
30148: LD_INT 2
30150: NEG
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 2
30162: PUSH
30163: LD_INT 1
30165: NEG
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 3
30173: PUSH
30174: LD_INT 0
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 3
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: EMPTY
30188: LIST
30189: LIST
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30209: LD_ADDR_VAR 0 16
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 0
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: LD_INT 0
30257: PUSH
30258: LD_INT 1
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 1
30267: NEG
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 1
30278: NEG
30279: PUSH
30280: LD_INT 1
30282: NEG
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: LD_INT 2
30294: NEG
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 2
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: LD_INT 2
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: PUSH
30323: LD_INT 2
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 2
30332: NEG
30333: PUSH
30334: LD_INT 1
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: NEG
30345: PUSH
30346: LD_INT 2
30348: NEG
30349: PUSH
30350: EMPTY
30351: LIST
30352: LIST
30353: PUSH
30354: LD_INT 3
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 3
30366: PUSH
30367: LD_INT 3
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 2
30376: PUSH
30377: LD_INT 3
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30402: LD_ADDR_VAR 0 17
30406: PUSH
30407: LD_INT 0
30409: PUSH
30410: LD_INT 0
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: LD_INT 1
30422: NEG
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: LD_INT 0
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 1
30440: PUSH
30441: LD_INT 1
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 0
30450: PUSH
30451: LD_INT 1
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: NEG
30461: PUSH
30462: LD_INT 0
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: LD_INT 1
30475: NEG
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 1
30483: NEG
30484: PUSH
30485: LD_INT 2
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: LD_INT 2
30498: NEG
30499: PUSH
30500: EMPTY
30501: LIST
30502: LIST
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: LD_INT 1
30509: NEG
30510: PUSH
30511: EMPTY
30512: LIST
30513: LIST
30514: PUSH
30515: LD_INT 2
30517: PUSH
30518: LD_INT 0
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: LD_INT 2
30527: PUSH
30528: LD_INT 1
30530: PUSH
30531: EMPTY
30532: LIST
30533: LIST
30534: PUSH
30535: LD_INT 2
30537: PUSH
30538: LD_INT 2
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: PUSH
30548: LD_INT 2
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 2
30560: PUSH
30561: EMPTY
30562: LIST
30563: LIST
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 2
30578: NEG
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 2
30589: NEG
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 2
30601: NEG
30602: PUSH
30603: LD_INT 2
30605: NEG
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: EMPTY
30612: LIST
30613: LIST
30614: LIST
30615: LIST
30616: LIST
30617: LIST
30618: LIST
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30632: LD_ADDR_VAR 0 18
30636: PUSH
30637: LD_INT 0
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: LD_INT 1
30652: NEG
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 1
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 1
30670: PUSH
30671: LD_INT 1
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 0
30680: PUSH
30681: LD_INT 1
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: NEG
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 1
30701: NEG
30702: PUSH
30703: LD_INT 1
30705: NEG
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 1
30713: NEG
30714: PUSH
30715: LD_INT 2
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: LD_INT 2
30728: NEG
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: PUSH
30737: LD_INT 1
30739: NEG
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 2
30747: PUSH
30748: LD_INT 0
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 2
30757: PUSH
30758: LD_INT 1
30760: PUSH
30761: EMPTY
30762: LIST
30763: LIST
30764: PUSH
30765: LD_INT 2
30767: PUSH
30768: LD_INT 2
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 1
30777: PUSH
30778: LD_INT 2
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 2
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 2
30808: NEG
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 2
30819: NEG
30820: PUSH
30821: LD_INT 1
30823: NEG
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: NEG
30832: PUSH
30833: LD_INT 2
30835: NEG
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: LIST
30845: LIST
30846: LIST
30847: LIST
30848: LIST
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30862: LD_ADDR_VAR 0 19
30866: PUSH
30867: LD_INT 0
30869: PUSH
30870: LD_INT 0
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 1
30900: PUSH
30901: LD_INT 1
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 0
30910: PUSH
30911: LD_INT 1
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 1
30920: NEG
30921: PUSH
30922: LD_INT 0
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: LD_INT 1
30935: NEG
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: LD_INT 1
30943: NEG
30944: PUSH
30945: LD_INT 2
30947: NEG
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: LD_INT 2
30958: NEG
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 1
30966: PUSH
30967: LD_INT 1
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 2
30977: PUSH
30978: LD_INT 0
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 2
30987: PUSH
30988: LD_INT 1
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 2
30997: PUSH
30998: LD_INT 2
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: PUSH
31008: LD_INT 2
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: LD_INT 2
31020: PUSH
31021: EMPTY
31022: LIST
31023: LIST
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: EMPTY
31033: LIST
31034: LIST
31035: PUSH
31036: LD_INT 2
31038: NEG
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: NEG
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 2
31061: NEG
31062: PUSH
31063: LD_INT 2
31065: NEG
31066: PUSH
31067: EMPTY
31068: LIST
31069: LIST
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: LIST
31075: LIST
31076: LIST
31077: LIST
31078: LIST
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31092: LD_ADDR_VAR 0 20
31096: PUSH
31097: LD_INT 0
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 1
31130: PUSH
31131: LD_INT 1
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 0
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 1
31150: NEG
31151: PUSH
31152: LD_INT 0
31154: PUSH
31155: EMPTY
31156: LIST
31157: LIST
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: LD_INT 1
31165: NEG
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 1
31173: NEG
31174: PUSH
31175: LD_INT 2
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 0
31185: PUSH
31186: LD_INT 2
31188: NEG
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 1
31196: PUSH
31197: LD_INT 1
31199: NEG
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 2
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 2
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 2
31227: PUSH
31228: LD_INT 2
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: PUSH
31238: LD_INT 2
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 0
31247: PUSH
31248: LD_INT 2
31250: PUSH
31251: EMPTY
31252: LIST
31253: LIST
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: EMPTY
31263: LIST
31264: LIST
31265: PUSH
31266: LD_INT 2
31268: NEG
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 2
31279: NEG
31280: PUSH
31281: LD_INT 1
31283: NEG
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: NEG
31292: PUSH
31293: LD_INT 2
31295: NEG
31296: PUSH
31297: EMPTY
31298: LIST
31299: LIST
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: LIST
31305: LIST
31306: LIST
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31322: LD_ADDR_VAR 0 21
31326: PUSH
31327: LD_INT 0
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: PUSH
31351: LD_INT 0
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 1
31360: PUSH
31361: LD_INT 1
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 0
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 1
31380: NEG
31381: PUSH
31382: LD_INT 0
31384: PUSH
31385: EMPTY
31386: LIST
31387: LIST
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: LD_INT 1
31395: NEG
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 1
31403: NEG
31404: PUSH
31405: LD_INT 2
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 0
31415: PUSH
31416: LD_INT 2
31418: NEG
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 1
31426: PUSH
31427: LD_INT 1
31429: NEG
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 2
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 2
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 2
31457: PUSH
31458: LD_INT 2
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: PUSH
31468: LD_INT 2
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 2
31480: PUSH
31481: EMPTY
31482: LIST
31483: LIST
31484: PUSH
31485: LD_INT 1
31487: NEG
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: EMPTY
31493: LIST
31494: LIST
31495: PUSH
31496: LD_INT 2
31498: NEG
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 2
31509: NEG
31510: PUSH
31511: LD_INT 1
31513: NEG
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 2
31521: NEG
31522: PUSH
31523: LD_INT 2
31525: NEG
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: LIST
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31552: LD_ADDR_VAR 0 22
31556: PUSH
31557: LD_INT 0
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 1
31590: PUSH
31591: LD_INT 1
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: LD_INT 0
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 0
31614: PUSH
31615: EMPTY
31616: LIST
31617: LIST
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 1
31633: NEG
31634: PUSH
31635: LD_INT 2
31637: NEG
31638: PUSH
31639: EMPTY
31640: LIST
31641: LIST
31642: PUSH
31643: LD_INT 0
31645: PUSH
31646: LD_INT 2
31648: NEG
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 2
31667: PUSH
31668: LD_INT 0
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 2
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 2
31687: PUSH
31688: LD_INT 2
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: PUSH
31698: LD_INT 2
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: LD_INT 2
31710: PUSH
31711: EMPTY
31712: LIST
31713: LIST
31714: PUSH
31715: LD_INT 1
31717: NEG
31718: PUSH
31719: LD_INT 1
31721: PUSH
31722: EMPTY
31723: LIST
31724: LIST
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 2
31739: NEG
31740: PUSH
31741: LD_INT 1
31743: NEG
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 2
31751: NEG
31752: PUSH
31753: LD_INT 2
31755: NEG
31756: PUSH
31757: EMPTY
31758: LIST
31759: LIST
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31782: LD_ADDR_VAR 0 23
31786: PUSH
31787: LD_INT 0
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 1
31820: PUSH
31821: LD_INT 1
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: LD_INT 0
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 0
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 1
31851: NEG
31852: PUSH
31853: LD_INT 1
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: NEG
31864: PUSH
31865: LD_INT 2
31867: NEG
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: PUSH
31873: LD_INT 0
31875: PUSH
31876: LD_INT 2
31878: NEG
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 1
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: LD_INT 2
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: PUSH
31928: LD_INT 2
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 0
31937: PUSH
31938: LD_INT 2
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: LD_INT 1
31947: NEG
31948: PUSH
31949: LD_INT 1
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 2
31969: NEG
31970: PUSH
31971: LD_INT 1
31973: NEG
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 2
31981: NEG
31982: PUSH
31983: LD_INT 2
31985: NEG
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 2
31993: NEG
31994: PUSH
31995: LD_INT 3
31997: NEG
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 3
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32062: LD_ADDR_VAR 0 24
32066: PUSH
32067: LD_INT 0
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: LD_INT 1
32082: NEG
32083: PUSH
32084: EMPTY
32085: LIST
32086: LIST
32087: PUSH
32088: LD_INT 1
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 1
32100: PUSH
32101: LD_INT 1
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: LD_INT 1
32113: PUSH
32114: EMPTY
32115: LIST
32116: LIST
32117: PUSH
32118: LD_INT 1
32120: NEG
32121: PUSH
32122: LD_INT 0
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 1
32131: NEG
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 1
32143: NEG
32144: PUSH
32145: LD_INT 2
32147: NEG
32148: PUSH
32149: EMPTY
32150: LIST
32151: LIST
32152: PUSH
32153: LD_INT 0
32155: PUSH
32156: LD_INT 2
32158: NEG
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 1
32166: PUSH
32167: LD_INT 1
32169: NEG
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: LD_INT 2
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: PUSH
32185: LD_INT 2
32187: PUSH
32188: LD_INT 1
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: LD_INT 2
32197: PUSH
32198: LD_INT 2
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: PUSH
32208: LD_INT 2
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 2
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: NEG
32228: PUSH
32229: LD_INT 1
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 2
32238: NEG
32239: PUSH
32240: LD_INT 0
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 2
32249: NEG
32250: PUSH
32251: LD_INT 1
32253: NEG
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: NEG
32262: PUSH
32263: LD_INT 2
32265: NEG
32266: PUSH
32267: EMPTY
32268: LIST
32269: LIST
32270: PUSH
32271: LD_INT 1
32273: PUSH
32274: LD_INT 2
32276: NEG
32277: PUSH
32278: EMPTY
32279: LIST
32280: LIST
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: LD_INT 1
32287: NEG
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 3
32295: PUSH
32296: LD_INT 1
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 3
32305: PUSH
32306: LD_INT 2
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: EMPTY
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32338: LD_ADDR_VAR 0 25
32342: PUSH
32343: LD_INT 0
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 1
32358: NEG
32359: PUSH
32360: EMPTY
32361: LIST
32362: LIST
32363: PUSH
32364: LD_INT 1
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 1
32376: PUSH
32377: LD_INT 1
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 0
32386: PUSH
32387: LD_INT 1
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 1
32396: NEG
32397: PUSH
32398: LD_INT 0
32400: PUSH
32401: EMPTY
32402: LIST
32403: LIST
32404: PUSH
32405: LD_INT 1
32407: NEG
32408: PUSH
32409: LD_INT 1
32411: NEG
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: LD_INT 2
32423: NEG
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 0
32431: PUSH
32432: LD_INT 2
32434: NEG
32435: PUSH
32436: EMPTY
32437: LIST
32438: LIST
32439: PUSH
32440: LD_INT 1
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 2
32453: PUSH
32454: LD_INT 0
32456: PUSH
32457: EMPTY
32458: LIST
32459: LIST
32460: PUSH
32461: LD_INT 2
32463: PUSH
32464: LD_INT 1
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 2
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 1
32483: PUSH
32484: LD_INT 2
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 0
32493: PUSH
32494: LD_INT 2
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 1
32503: NEG
32504: PUSH
32505: LD_INT 1
32507: PUSH
32508: EMPTY
32509: LIST
32510: LIST
32511: PUSH
32512: LD_INT 2
32514: NEG
32515: PUSH
32516: LD_INT 0
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 2
32525: NEG
32526: PUSH
32527: LD_INT 1
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: NEG
32538: PUSH
32539: LD_INT 2
32541: NEG
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PUSH
32547: LD_INT 3
32549: PUSH
32550: LD_INT 1
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 3
32559: PUSH
32560: LD_INT 2
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: LD_INT 3
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 1
32579: PUSH
32580: LD_INT 3
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: EMPTY
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32612: LD_ADDR_VAR 0 26
32616: PUSH
32617: LD_INT 0
32619: PUSH
32620: LD_INT 0
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: LD_INT 1
32632: NEG
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 1
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: LD_INT 1
32653: PUSH
32654: EMPTY
32655: LIST
32656: LIST
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: LD_INT 1
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 1
32670: NEG
32671: PUSH
32672: LD_INT 0
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: NEG
32682: PUSH
32683: LD_INT 1
32685: NEG
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 1
32693: NEG
32694: PUSH
32695: LD_INT 2
32697: NEG
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: LD_INT 2
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: LD_INT 0
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: NEG
32800: PUSH
32801: LD_INT 1
32803: NEG
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: NEG
32812: PUSH
32813: LD_INT 2
32815: NEG
32816: PUSH
32817: EMPTY
32818: LIST
32819: LIST
32820: PUSH
32821: LD_INT 2
32823: PUSH
32824: LD_INT 3
32826: PUSH
32827: EMPTY
32828: LIST
32829: LIST
32830: PUSH
32831: LD_INT 1
32833: PUSH
32834: LD_INT 3
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: NEG
32844: PUSH
32845: LD_INT 2
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 2
32854: NEG
32855: PUSH
32856: LD_INT 1
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32888: LD_ADDR_VAR 0 27
32892: PUSH
32893: LD_INT 0
32895: PUSH
32896: LD_INT 0
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: LD_INT 1
32908: NEG
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: PUSH
32914: LD_INT 1
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 1
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 0
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: LD_INT 2
32973: NEG
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 0
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: EMPTY
32987: LIST
32988: LIST
32989: PUSH
32990: LD_INT 1
32992: PUSH
32993: LD_INT 1
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 2
33003: PUSH
33004: LD_INT 0
33006: PUSH
33007: EMPTY
33008: LIST
33009: LIST
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: LD_INT 1
33016: PUSH
33017: EMPTY
33018: LIST
33019: LIST
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: LD_INT 2
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 1
33033: PUSH
33034: LD_INT 2
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 0
33043: PUSH
33044: LD_INT 2
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 1
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: LD_INT 0
33068: PUSH
33069: EMPTY
33070: LIST
33071: LIST
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: LD_INT 1
33079: NEG
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: NEG
33088: PUSH
33089: LD_INT 2
33091: NEG
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: EMPTY
33105: LIST
33106: LIST
33107: PUSH
33108: LD_INT 2
33110: NEG
33111: PUSH
33112: LD_INT 1
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: PUSH
33119: LD_INT 3
33121: NEG
33122: PUSH
33123: LD_INT 1
33125: NEG
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 3
33133: NEG
33134: PUSH
33135: LD_INT 2
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33168: LD_ADDR_VAR 0 28
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: LD_INT 0
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 1
33188: NEG
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 1
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 1
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: EMPTY
33211: LIST
33212: LIST
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: LD_INT 1
33219: PUSH
33220: EMPTY
33221: LIST
33222: LIST
33223: PUSH
33224: LD_INT 1
33226: NEG
33227: PUSH
33228: LD_INT 0
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 1
33237: NEG
33238: PUSH
33239: LD_INT 1
33241: NEG
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: LD_INT 2
33253: NEG
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: LD_INT 1
33275: NEG
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: LD_INT 1
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 2
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 1
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 0
33323: PUSH
33324: LD_INT 2
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 1
33333: NEG
33334: PUSH
33335: LD_INT 1
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 0
33348: PUSH
33349: EMPTY
33350: LIST
33351: LIST
33352: PUSH
33353: LD_INT 2
33355: NEG
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: LD_INT 2
33371: NEG
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: PUSH
33377: LD_INT 2
33379: NEG
33380: PUSH
33381: LD_INT 3
33383: NEG
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: PUSH
33389: LD_INT 1
33391: NEG
33392: PUSH
33393: LD_INT 3
33395: NEG
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 3
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33450: LD_ADDR_VAR 0 29
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 1
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: NEG
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 0
33543: PUSH
33544: LD_INT 2
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 1
33554: PUSH
33555: LD_INT 1
33557: NEG
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 2
33565: PUSH
33566: LD_INT 0
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 2
33575: PUSH
33576: LD_INT 1
33578: PUSH
33579: EMPTY
33580: LIST
33581: LIST
33582: PUSH
33583: LD_INT 1
33585: PUSH
33586: LD_INT 2
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 0
33595: PUSH
33596: LD_INT 2
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 1
33605: NEG
33606: PUSH
33607: LD_INT 1
33609: PUSH
33610: EMPTY
33611: LIST
33612: LIST
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: LD_INT 1
33620: NEG
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 2
33628: NEG
33629: PUSH
33630: LD_INT 2
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 2
33640: NEG
33641: PUSH
33642: LD_INT 3
33644: NEG
33645: PUSH
33646: EMPTY
33647: LIST
33648: LIST
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: LD_INT 1
33655: NEG
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 3
33663: PUSH
33664: LD_INT 1
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: LD_INT 3
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 2
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 3
33694: NEG
33695: PUSH
33696: LD_INT 2
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33729: LD_ADDR_VAR 0 30
33733: PUSH
33734: LD_INT 0
33736: PUSH
33737: LD_INT 0
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: LD_INT 1
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 1
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 1
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: LD_INT 1
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 1
33787: NEG
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 1
33810: NEG
33811: PUSH
33812: LD_INT 2
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 0
33822: PUSH
33823: LD_INT 2
33825: NEG
33826: PUSH
33827: EMPTY
33828: LIST
33829: LIST
33830: PUSH
33831: LD_INT 1
33833: PUSH
33834: LD_INT 1
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 2
33844: PUSH
33845: LD_INT 0
33847: PUSH
33848: EMPTY
33849: LIST
33850: LIST
33851: PUSH
33852: LD_INT 2
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 2
33864: PUSH
33865: LD_INT 2
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: PUSH
33875: LD_INT 2
33877: PUSH
33878: EMPTY
33879: LIST
33880: LIST
33881: PUSH
33882: LD_INT 1
33884: NEG
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: NEG
33896: PUSH
33897: LD_INT 0
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 2
33906: NEG
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 3
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 1
33930: PUSH
33931: LD_INT 2
33933: NEG
33934: PUSH
33935: EMPTY
33936: LIST
33937: LIST
33938: PUSH
33939: LD_INT 3
33941: PUSH
33942: LD_INT 2
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: LD_INT 3
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 2
33961: NEG
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 3
33972: NEG
33973: PUSH
33974: LD_INT 1
33976: NEG
33977: PUSH
33978: EMPTY
33979: LIST
33980: LIST
33981: PUSH
33982: EMPTY
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34007: LD_ADDR_VAR 0 31
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 0
34017: PUSH
34018: EMPTY
34019: LIST
34020: LIST
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: PUSH
34046: LD_INT 1
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 0
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 1
34065: NEG
34066: PUSH
34067: LD_INT 0
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: NEG
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 1
34088: NEG
34089: PUSH
34090: LD_INT 2
34092: NEG
34093: PUSH
34094: EMPTY
34095: LIST
34096: LIST
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: LD_INT 1
34103: NEG
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: PUSH
34109: LD_INT 2
34111: PUSH
34112: LD_INT 0
34114: PUSH
34115: EMPTY
34116: LIST
34117: LIST
34118: PUSH
34119: LD_INT 2
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: EMPTY
34126: LIST
34127: LIST
34128: PUSH
34129: LD_INT 2
34131: PUSH
34132: LD_INT 2
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 1
34141: PUSH
34142: LD_INT 2
34144: PUSH
34145: EMPTY
34146: LIST
34147: LIST
34148: PUSH
34149: LD_INT 0
34151: PUSH
34152: LD_INT 2
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 1
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: NEG
34197: PUSH
34198: LD_INT 3
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: LD_INT 3
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 2
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 3
34250: NEG
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34285: LD_ADDR_VAR 0 32
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: LD_INT 2
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 2
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 0
34430: PUSH
34431: LD_INT 2
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 1
34440: NEG
34441: PUSH
34442: LD_INT 1
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 2
34451: NEG
34452: PUSH
34453: LD_INT 0
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 2
34462: NEG
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 1
34474: NEG
34475: PUSH
34476: LD_INT 3
34478: NEG
34479: PUSH
34480: EMPTY
34481: LIST
34482: LIST
34483: PUSH
34484: LD_INT 1
34486: PUSH
34487: LD_INT 2
34489: NEG
34490: PUSH
34491: EMPTY
34492: LIST
34493: LIST
34494: PUSH
34495: LD_INT 3
34497: PUSH
34498: LD_INT 2
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: LD_INT 3
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: NEG
34518: PUSH
34519: LD_INT 1
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 3
34528: NEG
34529: PUSH
34530: LD_INT 1
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34563: LD_ADDR_VAR 0 33
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: LD_INT 0
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 1
34601: PUSH
34602: LD_INT 1
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: LD_INT 1
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: LD_INT 1
34636: NEG
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: NEG
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: LD_INT 1
34659: NEG
34660: PUSH
34661: EMPTY
34662: LIST
34663: LIST
34664: PUSH
34665: LD_INT 2
34667: PUSH
34668: LD_INT 0
34670: PUSH
34671: EMPTY
34672: LIST
34673: LIST
34674: PUSH
34675: LD_INT 2
34677: PUSH
34678: LD_INT 1
34680: PUSH
34681: EMPTY
34682: LIST
34683: LIST
34684: PUSH
34685: LD_INT 1
34687: PUSH
34688: LD_INT 2
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: LD_INT 2
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 1
34707: NEG
34708: PUSH
34709: LD_INT 1
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 2
34718: NEG
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: EMPTY
34724: LIST
34725: LIST
34726: PUSH
34727: LD_INT 2
34729: NEG
34730: PUSH
34731: LD_INT 1
34733: NEG
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 2
34741: NEG
34742: PUSH
34743: LD_INT 2
34745: NEG
34746: PUSH
34747: EMPTY
34748: LIST
34749: LIST
34750: PUSH
34751: LD_INT 2
34753: NEG
34754: PUSH
34755: LD_INT 3
34757: NEG
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 2
34765: PUSH
34766: LD_INT 1
34768: NEG
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 3
34776: PUSH
34777: LD_INT 1
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: LD_INT 3
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 2
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 3
34807: NEG
34808: PUSH
34809: LD_INT 2
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: EMPTY
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34842: LD_ADDR_VAR 0 34
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: LD_INT 0
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 0
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 0
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: LD_INT 1
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 0
34890: PUSH
34891: LD_INT 1
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 1
34900: NEG
34901: PUSH
34902: LD_INT 0
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: NEG
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: LD_INT 2
34927: NEG
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: LD_INT 0
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: PUSH
34944: LD_INT 1
34946: PUSH
34947: LD_INT 1
34949: NEG
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 2
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 1
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: LD_INT 3
35037: NEG
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 1
35045: PUSH
35046: LD_INT 2
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: LD_INT 3
35056: PUSH
35057: LD_INT 2
35059: PUSH
35060: EMPTY
35061: LIST
35062: LIST
35063: PUSH
35064: LD_INT 2
35066: PUSH
35067: LD_INT 3
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: LD_INT 2
35076: NEG
35077: PUSH
35078: LD_INT 1
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: LD_INT 3
35087: NEG
35088: PUSH
35089: LD_INT 1
35091: NEG
35092: PUSH
35093: EMPTY
35094: LIST
35095: LIST
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35122: LD_ADDR_VAR 0 35
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: LD_INT 0
35132: PUSH
35133: EMPTY
35134: LIST
35135: LIST
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: LD_INT 1
35142: NEG
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: LD_INT 0
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 1
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 0
35170: PUSH
35171: LD_INT 1
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: NEG
35181: PUSH
35182: LD_INT 0
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 2
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 2
35213: NEG
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: EMPTY
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35234: LD_ADDR_VAR 0 36
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: LD_INT 1
35254: NEG
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 1
35262: PUSH
35263: LD_INT 0
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 0
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 1
35303: NEG
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: LD_INT 2
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 1
35327: PUSH
35328: LD_INT 2
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: LIST
35339: LIST
35340: LIST
35341: LIST
35342: LIST
35343: LIST
35344: LIST
35345: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35346: LD_ADDR_VAR 0 37
35350: PUSH
35351: LD_INT 0
35353: PUSH
35354: LD_INT 0
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: LD_INT 1
35366: NEG
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: LD_INT 0
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 0
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: LD_INT 0
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: LD_INT 1
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35458: LD_ADDR_VAR 0 38
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 2
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: EMPTY
35544: LIST
35545: LIST
35546: PUSH
35547: LD_INT 2
35549: NEG
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35570: LD_ADDR_VAR 0 39
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: LD_INT 1
35590: NEG
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: PUSH
35599: LD_INT 0
35601: PUSH
35602: EMPTY
35603: LIST
35604: LIST
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: EMPTY
35613: LIST
35614: LIST
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 1
35639: NEG
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 1
35651: NEG
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: PUSH
35664: LD_INT 2
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35682: LD_ADDR_VAR 0 40
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 0
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: LD_INT 1
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: LD_INT 0
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 0
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 1
35740: NEG
35741: PUSH
35742: LD_INT 0
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 1
35751: NEG
35752: PUSH
35753: LD_INT 1
35755: NEG
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 1
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: NEG
35775: PUSH
35776: LD_INT 1
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35794: LD_ADDR_VAR 0 41
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 0
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: LD_INT 1
35814: NEG
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: EMPTY
35827: LIST
35828: LIST
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 1
35863: NEG
35864: PUSH
35865: LD_INT 1
35867: NEG
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 1
35875: NEG
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 1
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 2
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: EMPTY
35955: LIST
35956: LIST
35957: PUSH
35958: LD_INT 2
35960: NEG
35961: PUSH
35962: LD_INT 1
35964: NEG
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 2
35972: NEG
35973: PUSH
35974: LD_INT 2
35976: NEG
35977: PUSH
35978: EMPTY
35979: LIST
35980: LIST
35981: PUSH
35982: LD_INT 2
35984: NEG
35985: PUSH
35986: LD_INT 3
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 2
35996: PUSH
35997: LD_INT 1
35999: NEG
36000: PUSH
36001: EMPTY
36002: LIST
36003: LIST
36004: PUSH
36005: LD_INT 3
36007: PUSH
36008: LD_INT 0
36010: PUSH
36011: EMPTY
36012: LIST
36013: LIST
36014: PUSH
36015: LD_INT 3
36017: PUSH
36018: LD_INT 1
36020: PUSH
36021: EMPTY
36022: LIST
36023: LIST
36024: PUSH
36025: LD_INT 3
36027: PUSH
36028: LD_INT 2
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 3
36037: PUSH
36038: LD_INT 3
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: LD_INT 3
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: NEG
36058: PUSH
36059: LD_INT 1
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: NEG
36069: PUSH
36070: LD_INT 0
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 3
36079: NEG
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 3
36091: NEG
36092: PUSH
36093: LD_INT 2
36095: NEG
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 3
36103: NEG
36104: PUSH
36105: LD_INT 3
36107: NEG
36108: PUSH
36109: EMPTY
36110: LIST
36111: LIST
36112: PUSH
36113: EMPTY
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36144: LD_ADDR_VAR 0 42
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 0
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: LD_INT 1
36164: NEG
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 1
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 1
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 1
36213: NEG
36214: PUSH
36215: LD_INT 1
36217: NEG
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 1
36225: NEG
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: LD_INT 2
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 1
36248: PUSH
36249: LD_INT 1
36251: NEG
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 2
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 2
36269: PUSH
36270: LD_INT 2
36272: PUSH
36273: EMPTY
36274: LIST
36275: LIST
36276: PUSH
36277: LD_INT 1
36279: PUSH
36280: LD_INT 2
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 0
36289: PUSH
36290: LD_INT 2
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 1
36299: NEG
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: NEG
36323: PUSH
36324: LD_INT 2
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 2
36334: NEG
36335: PUSH
36336: LD_INT 3
36338: NEG
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: LD_INT 3
36350: NEG
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: LD_INT 3
36361: NEG
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: LD_INT 2
36372: NEG
36373: PUSH
36374: EMPTY
36375: LIST
36376: LIST
36377: PUSH
36378: LD_INT 3
36380: PUSH
36381: LD_INT 2
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: LD_INT 3
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 2
36400: PUSH
36401: LD_INT 3
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 3
36413: PUSH
36414: EMPTY
36415: LIST
36416: LIST
36417: PUSH
36418: LD_INT 0
36420: PUSH
36421: LD_INT 3
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 1
36430: NEG
36431: PUSH
36432: LD_INT 2
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 3
36441: NEG
36442: PUSH
36443: LD_INT 2
36445: NEG
36446: PUSH
36447: EMPTY
36448: LIST
36449: LIST
36450: PUSH
36451: LD_INT 3
36453: NEG
36454: PUSH
36455: LD_INT 3
36457: NEG
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: EMPTY
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36494: LD_ADDR_VAR 0 43
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 0
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: LD_INT 1
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: LD_INT 0
36525: PUSH
36526: EMPTY
36527: LIST
36528: LIST
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: EMPTY
36537: LIST
36538: LIST
36539: PUSH
36540: LD_INT 0
36542: PUSH
36543: LD_INT 1
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 1
36552: NEG
36553: PUSH
36554: LD_INT 0
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: NEG
36564: PUSH
36565: LD_INT 1
36567: NEG
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 2
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 0
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: EMPTY
36593: LIST
36594: LIST
36595: PUSH
36596: LD_INT 1
36598: PUSH
36599: LD_INT 1
36601: NEG
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 2
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 2
36619: PUSH
36620: LD_INT 1
36622: PUSH
36623: EMPTY
36624: LIST
36625: LIST
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: LD_INT 2
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 2
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 1
36649: NEG
36650: PUSH
36651: LD_INT 1
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 2
36660: NEG
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PUSH
36669: LD_INT 2
36671: NEG
36672: PUSH
36673: LD_INT 1
36675: NEG
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 1
36683: NEG
36684: PUSH
36685: LD_INT 3
36687: NEG
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 0
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: LD_INT 2
36709: NEG
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 2
36717: PUSH
36718: LD_INT 1
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 3
36728: PUSH
36729: LD_INT 0
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 3
36738: PUSH
36739: LD_INT 1
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: LD_INT 3
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 0
36758: PUSH
36759: LD_INT 3
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 1
36768: NEG
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 2
36779: NEG
36780: PUSH
36781: LD_INT 1
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 3
36790: NEG
36791: PUSH
36792: LD_INT 0
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 3
36801: NEG
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: LIST
36815: LIST
36816: LIST
36817: LIST
36818: LIST
36819: LIST
36820: LIST
36821: LIST
36822: LIST
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36842: LD_ADDR_VAR 0 44
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 1
36870: PUSH
36871: LD_INT 0
36873: PUSH
36874: EMPTY
36875: LIST
36876: LIST
36877: PUSH
36878: LD_INT 1
36880: PUSH
36881: LD_INT 1
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 1
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 1
36900: NEG
36901: PUSH
36902: LD_INT 0
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: NEG
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 1
36923: NEG
36924: PUSH
36925: LD_INT 2
36927: NEG
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 1
36935: PUSH
36936: LD_INT 1
36938: NEG
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 2
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 2
36956: PUSH
36957: LD_INT 1
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PUSH
36964: LD_INT 2
36966: PUSH
36967: LD_INT 2
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: LD_INT 2
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: NEG
36987: PUSH
36988: LD_INT 1
36990: PUSH
36991: EMPTY
36992: LIST
36993: LIST
36994: PUSH
36995: LD_INT 2
36997: NEG
36998: PUSH
36999: LD_INT 0
37001: PUSH
37002: EMPTY
37003: LIST
37004: LIST
37005: PUSH
37006: LD_INT 2
37008: NEG
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: NEG
37021: PUSH
37022: LD_INT 2
37024: NEG
37025: PUSH
37026: EMPTY
37027: LIST
37028: LIST
37029: PUSH
37030: LD_INT 2
37032: NEG
37033: PUSH
37034: LD_INT 3
37036: NEG
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 2
37044: PUSH
37045: LD_INT 1
37047: NEG
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: LD_INT 3
37055: PUSH
37056: LD_INT 0
37058: PUSH
37059: EMPTY
37060: LIST
37061: LIST
37062: PUSH
37063: LD_INT 3
37065: PUSH
37066: LD_INT 1
37068: PUSH
37069: EMPTY
37070: LIST
37071: LIST
37072: PUSH
37073: LD_INT 3
37075: PUSH
37076: LD_INT 2
37078: PUSH
37079: EMPTY
37080: LIST
37081: LIST
37082: PUSH
37083: LD_INT 3
37085: PUSH
37086: LD_INT 3
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 2
37095: PUSH
37096: LD_INT 3
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 2
37105: NEG
37106: PUSH
37107: LD_INT 1
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: PUSH
37114: LD_INT 3
37116: NEG
37117: PUSH
37118: LD_INT 0
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 3
37127: NEG
37128: PUSH
37129: LD_INT 1
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 3
37139: NEG
37140: PUSH
37141: LD_INT 2
37143: NEG
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 3
37151: NEG
37152: PUSH
37153: LD_INT 3
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: EMPTY
37162: LIST
37163: LIST
37164: LIST
37165: LIST
37166: LIST
37167: LIST
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37192: LD_ADDR_VAR 0 45
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 0
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 1
37220: PUSH
37221: LD_INT 0
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 1
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 1
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 1
37250: NEG
37251: PUSH
37252: LD_INT 0
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: PUSH
37259: LD_INT 1
37261: NEG
37262: PUSH
37263: LD_INT 1
37265: NEG
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 1
37273: NEG
37274: PUSH
37275: LD_INT 2
37277: NEG
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: LD_INT 2
37288: NEG
37289: PUSH
37290: EMPTY
37291: LIST
37292: LIST
37293: PUSH
37294: LD_INT 1
37296: PUSH
37297: LD_INT 1
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 2
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 2
37317: PUSH
37318: LD_INT 2
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 1
37327: PUSH
37328: LD_INT 2
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 0
37337: PUSH
37338: LD_INT 2
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 1
37347: NEG
37348: PUSH
37349: LD_INT 1
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 2
37358: NEG
37359: PUSH
37360: LD_INT 1
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: NEG
37371: PUSH
37372: LD_INT 2
37374: NEG
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 2
37382: NEG
37383: PUSH
37384: LD_INT 3
37386: NEG
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: LD_INT 3
37398: NEG
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 0
37406: PUSH
37407: LD_INT 3
37409: NEG
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: LD_INT 2
37420: NEG
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 3
37428: PUSH
37429: LD_INT 2
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 3
37438: PUSH
37439: LD_INT 3
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: PUSH
37449: LD_INT 3
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: PUSH
37459: LD_INT 3
37461: PUSH
37462: EMPTY
37463: LIST
37464: LIST
37465: PUSH
37466: LD_INT 0
37468: PUSH
37469: LD_INT 3
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 1
37478: NEG
37479: PUSH
37480: LD_INT 2
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 3
37489: NEG
37490: PUSH
37491: LD_INT 2
37493: NEG
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 3
37501: NEG
37502: PUSH
37503: LD_INT 3
37505: NEG
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: LIST
37515: LIST
37516: LIST
37517: LIST
37518: LIST
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37542: LD_ADDR_VAR 0 46
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 0
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: LD_INT 1
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: PUSH
37571: LD_INT 0
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: PUSH
37578: LD_INT 1
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 0
37590: PUSH
37591: LD_INT 1
37593: PUSH
37594: EMPTY
37595: LIST
37596: LIST
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: LD_INT 0
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 1
37611: NEG
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: NEG
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 0
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: EMPTY
37641: LIST
37642: LIST
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: LD_INT 1
37649: NEG
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 2
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 2
37667: PUSH
37668: LD_INT 1
37670: PUSH
37671: EMPTY
37672: LIST
37673: LIST
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: LD_INT 2
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 0
37687: PUSH
37688: LD_INT 2
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 1
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 2
37708: NEG
37709: PUSH
37710: LD_INT 0
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 2
37719: NEG
37720: PUSH
37721: LD_INT 1
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 1
37731: NEG
37732: PUSH
37733: LD_INT 3
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 0
37743: PUSH
37744: LD_INT 3
37746: NEG
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: PUSH
37755: LD_INT 2
37757: NEG
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 2
37765: PUSH
37766: LD_INT 1
37768: NEG
37769: PUSH
37770: EMPTY
37771: LIST
37772: LIST
37773: PUSH
37774: LD_INT 3
37776: PUSH
37777: LD_INT 0
37779: PUSH
37780: EMPTY
37781: LIST
37782: LIST
37783: PUSH
37784: LD_INT 3
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 1
37796: PUSH
37797: LD_INT 3
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: LD_INT 3
37809: PUSH
37810: EMPTY
37811: LIST
37812: LIST
37813: PUSH
37814: LD_INT 1
37816: NEG
37817: PUSH
37818: LD_INT 2
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 2
37827: NEG
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 3
37838: NEG
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 3
37849: NEG
37850: PUSH
37851: LD_INT 1
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37890: LD_ADDR_VAR 0 47
37894: PUSH
37895: LD_INT 0
37897: PUSH
37898: LD_INT 0
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: LD_INT 0
37907: PUSH
37908: LD_INT 1
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 1
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: EMPTY
37923: LIST
37924: LIST
37925: PUSH
37926: LD_INT 1
37928: PUSH
37929: LD_INT 1
37931: PUSH
37932: EMPTY
37933: LIST
37934: LIST
37935: PUSH
37936: LD_INT 0
37938: PUSH
37939: LD_INT 1
37941: PUSH
37942: EMPTY
37943: LIST
37944: LIST
37945: PUSH
37946: LD_INT 1
37948: NEG
37949: PUSH
37950: LD_INT 0
37952: PUSH
37953: EMPTY
37954: LIST
37955: LIST
37956: PUSH
37957: LD_INT 1
37959: NEG
37960: PUSH
37961: LD_INT 1
37963: NEG
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 1
37971: NEG
37972: PUSH
37973: LD_INT 2
37975: NEG
37976: PUSH
37977: EMPTY
37978: LIST
37979: LIST
37980: PUSH
37981: LD_INT 0
37983: PUSH
37984: LD_INT 2
37986: NEG
37987: PUSH
37988: EMPTY
37989: LIST
37990: LIST
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: LD_INT 1
37997: NEG
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 2
38005: NEG
38006: PUSH
38007: LD_INT 1
38009: NEG
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: NEG
38018: PUSH
38019: LD_INT 2
38021: NEG
38022: PUSH
38023: EMPTY
38024: LIST
38025: LIST
38026: PUSH
38027: EMPTY
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38041: LD_ADDR_VAR 0 48
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 0
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 1
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: EMPTY
38074: LIST
38075: LIST
38076: PUSH
38077: LD_INT 1
38079: PUSH
38080: LD_INT 1
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 0
38089: PUSH
38090: LD_INT 1
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 1
38099: NEG
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 1
38110: NEG
38111: PUSH
38112: LD_INT 1
38114: NEG
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: LD_INT 2
38126: NEG
38127: PUSH
38128: EMPTY
38129: LIST
38130: LIST
38131: PUSH
38132: LD_INT 0
38134: PUSH
38135: LD_INT 2
38137: NEG
38138: PUSH
38139: EMPTY
38140: LIST
38141: LIST
38142: PUSH
38143: LD_INT 1
38145: PUSH
38146: LD_INT 1
38148: NEG
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 2
38156: PUSH
38157: LD_INT 0
38159: PUSH
38160: EMPTY
38161: LIST
38162: LIST
38163: PUSH
38164: LD_INT 2
38166: PUSH
38167: LD_INT 1
38169: PUSH
38170: EMPTY
38171: LIST
38172: LIST
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38188: LD_ADDR_VAR 0 49
38192: PUSH
38193: LD_INT 0
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: LD_INT 1
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: EMPTY
38221: LIST
38222: LIST
38223: PUSH
38224: LD_INT 1
38226: PUSH
38227: LD_INT 1
38229: PUSH
38230: EMPTY
38231: LIST
38232: LIST
38233: PUSH
38234: LD_INT 0
38236: PUSH
38237: LD_INT 1
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: EMPTY
38252: LIST
38253: LIST
38254: PUSH
38255: LD_INT 1
38257: NEG
38258: PUSH
38259: LD_INT 1
38261: NEG
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 2
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 2
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 2
38300: PUSH
38301: LD_INT 2
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 1
38310: PUSH
38311: LD_INT 2
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: EMPTY
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38332: LD_ADDR_VAR 0 50
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 0
38349: PUSH
38350: LD_INT 1
38352: NEG
38353: PUSH
38354: EMPTY
38355: LIST
38356: LIST
38357: PUSH
38358: LD_INT 1
38360: PUSH
38361: LD_INT 0
38363: PUSH
38364: EMPTY
38365: LIST
38366: LIST
38367: PUSH
38368: LD_INT 1
38370: PUSH
38371: LD_INT 1
38373: PUSH
38374: EMPTY
38375: LIST
38376: LIST
38377: PUSH
38378: LD_INT 0
38380: PUSH
38381: LD_INT 1
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 1
38390: NEG
38391: PUSH
38392: LD_INT 0
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: NEG
38402: PUSH
38403: LD_INT 1
38405: NEG
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 2
38413: PUSH
38414: LD_INT 1
38416: PUSH
38417: EMPTY
38418: LIST
38419: LIST
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: LD_INT 2
38426: PUSH
38427: EMPTY
38428: LIST
38429: LIST
38430: PUSH
38431: LD_INT 1
38433: PUSH
38434: LD_INT 2
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 0
38443: PUSH
38444: LD_INT 2
38446: PUSH
38447: EMPTY
38448: LIST
38449: LIST
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: LD_INT 1
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38476: LD_ADDR_VAR 0 51
38480: PUSH
38481: LD_INT 0
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: LD_INT 1
38496: NEG
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 1
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: PUSH
38515: LD_INT 1
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 0
38524: PUSH
38525: LD_INT 1
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 1
38534: NEG
38535: PUSH
38536: LD_INT 0
38538: PUSH
38539: EMPTY
38540: LIST
38541: LIST
38542: PUSH
38543: LD_INT 1
38545: NEG
38546: PUSH
38547: LD_INT 1
38549: NEG
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 1
38557: PUSH
38558: LD_INT 2
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 0
38567: PUSH
38568: LD_INT 2
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: LD_INT 1
38577: NEG
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 2
38588: NEG
38589: PUSH
38590: LD_INT 0
38592: PUSH
38593: EMPTY
38594: LIST
38595: LIST
38596: PUSH
38597: LD_INT 2
38599: NEG
38600: PUSH
38601: LD_INT 1
38603: NEG
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38623: LD_ADDR_VAR 0 52
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: LD_INT 1
38643: NEG
38644: PUSH
38645: EMPTY
38646: LIST
38647: LIST
38648: PUSH
38649: LD_INT 1
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: EMPTY
38666: LIST
38667: LIST
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 1
38692: NEG
38693: PUSH
38694: LD_INT 1
38696: NEG
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 1
38704: NEG
38705: PUSH
38706: LD_INT 2
38708: NEG
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: LD_INT 1
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 2
38727: NEG
38728: PUSH
38729: LD_INT 0
38731: PUSH
38732: EMPTY
38733: LIST
38734: LIST
38735: PUSH
38736: LD_INT 2
38738: NEG
38739: PUSH
38740: LD_INT 1
38742: NEG
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: LD_INT 2
38754: NEG
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: LIST
38770: LIST
38771: LIST
38772: LIST
38773: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38774: LD_ADDR_VAR 0 53
38778: PUSH
38779: LD_INT 0
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: LD_INT 1
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 1
38802: PUSH
38803: LD_INT 0
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 1
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 1
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 1
38832: NEG
38833: PUSH
38834: LD_INT 0
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: NEG
38844: PUSH
38845: LD_INT 1
38847: NEG
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 1
38855: NEG
38856: PUSH
38857: LD_INT 2
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: LD_INT 2
38870: NEG
38871: PUSH
38872: EMPTY
38873: LIST
38874: LIST
38875: PUSH
38876: LD_INT 1
38878: PUSH
38879: LD_INT 1
38881: NEG
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: LD_INT 2
38889: PUSH
38890: LD_INT 0
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 2
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: EMPTY
38904: LIST
38905: LIST
38906: PUSH
38907: LD_INT 2
38909: PUSH
38910: LD_INT 2
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: PUSH
38920: LD_INT 2
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: LD_INT 2
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 2
38950: NEG
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 2
38961: NEG
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 2
38973: NEG
38974: PUSH
38975: LD_INT 2
38977: NEG
38978: PUSH
38979: EMPTY
38980: LIST
38981: LIST
38982: PUSH
38983: EMPTY
38984: LIST
38985: LIST
38986: LIST
38987: LIST
38988: LIST
38989: LIST
38990: LIST
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39004: LD_ADDR_VAR 0 54
39008: PUSH
39009: LD_INT 0
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: LD_INT 1
39024: NEG
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 1
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 1
39042: PUSH
39043: LD_INT 1
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 0
39052: PUSH
39053: LD_INT 1
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: NEG
39063: PUSH
39064: LD_INT 0
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: LD_INT 1
39077: NEG
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 1
39085: NEG
39086: PUSH
39087: LD_INT 2
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: LD_INT 1
39111: NEG
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: PUSH
39117: LD_INT 2
39119: PUSH
39120: LD_INT 0
39122: PUSH
39123: EMPTY
39124: LIST
39125: LIST
39126: PUSH
39127: LD_INT 2
39129: PUSH
39130: LD_INT 1
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 2
39139: PUSH
39140: LD_INT 2
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 1
39149: PUSH
39150: LD_INT 2
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: LD_INT 2
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: LD_INT 1
39169: NEG
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 2
39180: NEG
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 2
39191: NEG
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 2
39203: NEG
39204: PUSH
39205: LD_INT 2
39207: NEG
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: LIST
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39234: LD_ADDR_VAR 0 55
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: LD_INT 0
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 1
39272: PUSH
39273: LD_INT 1
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 1
39292: NEG
39293: PUSH
39294: LD_INT 0
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 1
39303: NEG
39304: PUSH
39305: LD_INT 1
39307: NEG
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 1
39315: NEG
39316: PUSH
39317: LD_INT 2
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: LD_INT 2
39330: NEG
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 1
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 0
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 2
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 2
39369: PUSH
39370: LD_INT 2
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: PUSH
39380: LD_INT 2
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: LD_INT 2
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: PUSH
39397: LD_INT 1
39399: NEG
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: PUSH
39408: LD_INT 2
39410: NEG
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: NEG
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: NEG
39434: PUSH
39435: LD_INT 2
39437: NEG
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: LIST
39447: LIST
39448: LIST
39449: LIST
39450: LIST
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39464: LD_ADDR_VAR 0 56
39468: PUSH
39469: LD_INT 0
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 1
39502: PUSH
39503: LD_INT 1
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 0
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: NEG
39523: PUSH
39524: LD_INT 0
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: LD_INT 1
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 1
39545: NEG
39546: PUSH
39547: LD_INT 2
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 0
39557: PUSH
39558: LD_INT 2
39560: NEG
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 1
39568: PUSH
39569: LD_INT 1
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 2
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 2
39589: PUSH
39590: LD_INT 1
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 2
39599: PUSH
39600: LD_INT 2
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 1
39609: PUSH
39610: LD_INT 2
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 0
39619: PUSH
39620: LD_INT 2
39622: PUSH
39623: EMPTY
39624: LIST
39625: LIST
39626: PUSH
39627: LD_INT 1
39629: NEG
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: EMPTY
39635: LIST
39636: LIST
39637: PUSH
39638: LD_INT 2
39640: NEG
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 2
39651: NEG
39652: PUSH
39653: LD_INT 1
39655: NEG
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: NEG
39664: PUSH
39665: LD_INT 2
39667: NEG
39668: PUSH
39669: EMPTY
39670: LIST
39671: LIST
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: LIST
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39694: LD_ADDR_VAR 0 57
39698: PUSH
39699: LD_INT 0
39701: PUSH
39702: LD_INT 0
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 1
39722: PUSH
39723: LD_INT 0
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 1
39732: PUSH
39733: LD_INT 1
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: LD_INT 0
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PUSH
39750: LD_INT 1
39752: NEG
39753: PUSH
39754: LD_INT 0
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: LD_INT 1
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 1
39775: NEG
39776: PUSH
39777: LD_INT 2
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: LD_INT 2
39790: NEG
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 1
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 2
39809: PUSH
39810: LD_INT 0
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 2
39819: PUSH
39820: LD_INT 1
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 2
39829: PUSH
39830: LD_INT 2
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: PUSH
39840: LD_INT 2
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 0
39849: PUSH
39850: LD_INT 2
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 1
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 2
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 2
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 2
39893: NEG
39894: PUSH
39895: LD_INT 2
39897: NEG
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39924: LD_ADDR_VAR 0 58
39928: PUSH
39929: LD_INT 0
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 1
39952: PUSH
39953: LD_INT 0
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 1
39962: PUSH
39963: LD_INT 1
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 0
39972: PUSH
39973: LD_INT 1
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 1
39982: NEG
39983: PUSH
39984: LD_INT 0
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: LD_INT 1
39997: NEG
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 1
40005: NEG
40006: PUSH
40007: LD_INT 2
40009: NEG
40010: PUSH
40011: EMPTY
40012: LIST
40013: LIST
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: LD_INT 2
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 1
40028: PUSH
40029: LD_INT 1
40031: NEG
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 2
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 2
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 2
40059: PUSH
40060: LD_INT 2
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: PUSH
40070: LD_INT 2
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: PUSH
40077: LD_INT 0
40079: PUSH
40080: LD_INT 2
40082: PUSH
40083: EMPTY
40084: LIST
40085: LIST
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: LD_INT 1
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: NEG
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 2
40111: NEG
40112: PUSH
40113: LD_INT 1
40115: NEG
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 2
40123: NEG
40124: PUSH
40125: LD_INT 2
40127: NEG
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: LIST
40137: LIST
40138: LIST
40139: LIST
40140: LIST
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40154: LD_ADDR_VAR 0 59
40158: PUSH
40159: LD_INT 0
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 1
40182: PUSH
40183: LD_INT 0
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: LD_INT 1
40192: PUSH
40193: LD_INT 1
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: LD_INT 1
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 1
40212: NEG
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 1
40223: NEG
40224: PUSH
40225: LD_INT 1
40227: NEG
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: LIST
40241: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40242: LD_ADDR_VAR 0 60
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: LD_INT 1
40262: NEG
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 1
40270: PUSH
40271: LD_INT 0
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: LD_INT 1
40280: PUSH
40281: LD_INT 1
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: LD_INT 1
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 1
40300: NEG
40301: PUSH
40302: LD_INT 0
40304: PUSH
40305: EMPTY
40306: LIST
40307: LIST
40308: PUSH
40309: LD_INT 1
40311: NEG
40312: PUSH
40313: LD_INT 1
40315: NEG
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40330: LD_ADDR_VAR 0 61
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: LD_INT 0
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: LD_INT 1
40350: NEG
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 0
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 1
40368: PUSH
40369: LD_INT 1
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: LD_INT 1
40381: PUSH
40382: EMPTY
40383: LIST
40384: LIST
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: LD_INT 0
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 1
40399: NEG
40400: PUSH
40401: LD_INT 1
40403: NEG
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: LIST
40413: LIST
40414: LIST
40415: LIST
40416: LIST
40417: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40418: LD_ADDR_VAR 0 62
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: LD_INT 0
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: LD_INT 1
40438: NEG
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 1
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 1
40456: PUSH
40457: LD_INT 1
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 0
40466: PUSH
40467: LD_INT 1
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 1
40476: NEG
40477: PUSH
40478: LD_INT 0
40480: PUSH
40481: EMPTY
40482: LIST
40483: LIST
40484: PUSH
40485: LD_INT 1
40487: NEG
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: LIST
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40506: LD_ADDR_VAR 0 63
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: LD_INT 0
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: LD_INT 1
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 1
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 1
40544: PUSH
40545: LD_INT 1
40547: PUSH
40548: EMPTY
40549: LIST
40550: LIST
40551: PUSH
40552: LD_INT 0
40554: PUSH
40555: LD_INT 1
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 1
40564: NEG
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 1
40575: NEG
40576: PUSH
40577: LD_INT 1
40579: NEG
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: LIST
40589: LIST
40590: LIST
40591: LIST
40592: LIST
40593: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40594: LD_ADDR_VAR 0 64
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: LD_INT 0
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: LD_INT 1
40614: NEG
40615: PUSH
40616: EMPTY
40617: LIST
40618: LIST
40619: PUSH
40620: LD_INT 1
40622: PUSH
40623: LD_INT 0
40625: PUSH
40626: EMPTY
40627: LIST
40628: LIST
40629: PUSH
40630: LD_INT 1
40632: PUSH
40633: LD_INT 1
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: LD_INT 0
40642: PUSH
40643: LD_INT 1
40645: PUSH
40646: EMPTY
40647: LIST
40648: LIST
40649: PUSH
40650: LD_INT 1
40652: NEG
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: EMPTY
40658: LIST
40659: LIST
40660: PUSH
40661: LD_INT 1
40663: NEG
40664: PUSH
40665: LD_INT 1
40667: NEG
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: LIST
40681: ST_TO_ADDR
// end ; 1 :
40682: GO 46579
40684: LD_INT 1
40686: DOUBLE
40687: EQUAL
40688: IFTRUE 40692
40690: GO 43315
40692: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40693: LD_ADDR_VAR 0 11
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: LD_INT 3
40704: NEG
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: LD_INT 3
40715: NEG
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: LD_INT 2
40726: NEG
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: LIST
40736: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40737: LD_ADDR_VAR 0 12
40741: PUSH
40742: LD_INT 2
40744: PUSH
40745: LD_INT 1
40747: NEG
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: PUSH
40753: LD_INT 3
40755: PUSH
40756: LD_INT 0
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 3
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40778: LD_ADDR_VAR 0 13
40782: PUSH
40783: LD_INT 3
40785: PUSH
40786: LD_INT 2
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: PUSH
40796: LD_INT 3
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 2
40805: PUSH
40806: LD_INT 3
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: LIST
40817: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40818: LD_ADDR_VAR 0 14
40822: PUSH
40823: LD_INT 1
40825: PUSH
40826: LD_INT 3
40828: PUSH
40829: EMPTY
40830: LIST
40831: LIST
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: LD_INT 3
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 1
40845: NEG
40846: PUSH
40847: LD_INT 2
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: EMPTY
40855: LIST
40856: LIST
40857: LIST
40858: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40859: LD_ADDR_VAR 0 15
40863: PUSH
40864: LD_INT 2
40866: NEG
40867: PUSH
40868: LD_INT 1
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: NEG
40878: PUSH
40879: LD_INT 0
40881: PUSH
40882: EMPTY
40883: LIST
40884: LIST
40885: PUSH
40886: LD_INT 3
40888: NEG
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40903: LD_ADDR_VAR 0 16
40907: PUSH
40908: LD_INT 2
40910: NEG
40911: PUSH
40912: LD_INT 3
40914: NEG
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: NEG
40923: PUSH
40924: LD_INT 2
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 3
40934: NEG
40935: PUSH
40936: LD_INT 3
40938: NEG
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: LIST
40948: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40949: LD_ADDR_VAR 0 17
40953: PUSH
40954: LD_INT 1
40956: NEG
40957: PUSH
40958: LD_INT 3
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 0
40968: PUSH
40969: LD_INT 3
40971: NEG
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: PUSH
40980: LD_INT 2
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: LIST
40992: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40993: LD_ADDR_VAR 0 18
40997: PUSH
40998: LD_INT 2
41000: PUSH
41001: LD_INT 1
41003: NEG
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 3
41011: PUSH
41012: LD_INT 0
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: PUSH
41019: LD_INT 3
41021: PUSH
41022: LD_INT 1
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: LIST
41033: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41034: LD_ADDR_VAR 0 19
41038: PUSH
41039: LD_INT 3
41041: PUSH
41042: LD_INT 2
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 3
41051: PUSH
41052: LD_INT 3
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 2
41061: PUSH
41062: LD_INT 3
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41074: LD_ADDR_VAR 0 20
41078: PUSH
41079: LD_INT 1
41081: PUSH
41082: LD_INT 3
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: LD_INT 3
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: LD_INT 2
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: LIST
41114: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41115: LD_ADDR_VAR 0 21
41119: PUSH
41120: LD_INT 2
41122: NEG
41123: PUSH
41124: LD_INT 1
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 3
41133: NEG
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 3
41144: NEG
41145: PUSH
41146: LD_INT 1
41148: NEG
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41159: LD_ADDR_VAR 0 22
41163: PUSH
41164: LD_INT 2
41166: NEG
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: LD_INT 3
41178: NEG
41179: PUSH
41180: LD_INT 2
41182: NEG
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 3
41190: NEG
41191: PUSH
41192: LD_INT 3
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41205: LD_ADDR_VAR 0 23
41209: PUSH
41210: LD_INT 0
41212: PUSH
41213: LD_INT 3
41215: NEG
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: LD_INT 1
41223: NEG
41224: PUSH
41225: LD_INT 4
41227: NEG
41228: PUSH
41229: EMPTY
41230: LIST
41231: LIST
41232: PUSH
41233: LD_INT 1
41235: PUSH
41236: LD_INT 3
41238: NEG
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: LIST
41248: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41249: LD_ADDR_VAR 0 24
41253: PUSH
41254: LD_INT 3
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 3
41266: PUSH
41267: LD_INT 1
41269: NEG
41270: PUSH
41271: EMPTY
41272: LIST
41273: LIST
41274: PUSH
41275: LD_INT 4
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: EMPTY
41286: LIST
41287: LIST
41288: LIST
41289: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41290: LD_ADDR_VAR 0 25
41294: PUSH
41295: LD_INT 3
41297: PUSH
41298: LD_INT 3
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: LD_INT 4
41307: PUSH
41308: LD_INT 3
41310: PUSH
41311: EMPTY
41312: LIST
41313: LIST
41314: PUSH
41315: LD_INT 3
41317: PUSH
41318: LD_INT 4
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: LIST
41329: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41330: LD_ADDR_VAR 0 26
41334: PUSH
41335: LD_INT 0
41337: PUSH
41338: LD_INT 3
41340: PUSH
41341: EMPTY
41342: LIST
41343: LIST
41344: PUSH
41345: LD_INT 1
41347: PUSH
41348: LD_INT 4
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 1
41357: NEG
41358: PUSH
41359: LD_INT 3
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: LIST
41370: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41371: LD_ADDR_VAR 0 27
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 3
41389: NEG
41390: PUSH
41391: LD_INT 1
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: LD_INT 4
41400: NEG
41401: PUSH
41402: LD_INT 1
41404: NEG
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41415: LD_ADDR_VAR 0 28
41419: PUSH
41420: LD_INT 3
41422: NEG
41423: PUSH
41424: LD_INT 3
41426: NEG
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: LD_INT 3
41434: NEG
41435: PUSH
41436: LD_INT 4
41438: NEG
41439: PUSH
41440: EMPTY
41441: LIST
41442: LIST
41443: PUSH
41444: LD_INT 4
41446: NEG
41447: PUSH
41448: LD_INT 3
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: LIST
41460: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41461: LD_ADDR_VAR 0 29
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: LD_INT 3
41472: NEG
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: PUSH
41478: LD_INT 0
41480: PUSH
41481: LD_INT 3
41483: NEG
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: LD_INT 1
41491: PUSH
41492: LD_INT 2
41494: NEG
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 1
41502: NEG
41503: PUSH
41504: LD_INT 4
41506: NEG
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 0
41514: PUSH
41515: LD_INT 4
41517: NEG
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 1
41525: PUSH
41526: LD_INT 3
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 1
41536: NEG
41537: PUSH
41538: LD_INT 5
41540: NEG
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 0
41548: PUSH
41549: LD_INT 5
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: LD_INT 4
41562: NEG
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: LD_INT 6
41574: NEG
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 6
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 1
41593: PUSH
41594: LD_INT 5
41596: NEG
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41616: LD_ADDR_VAR 0 30
41620: PUSH
41621: LD_INT 2
41623: PUSH
41624: LD_INT 1
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 3
41634: PUSH
41635: LD_INT 0
41637: PUSH
41638: EMPTY
41639: LIST
41640: LIST
41641: PUSH
41642: LD_INT 3
41644: PUSH
41645: LD_INT 1
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: PUSH
41652: LD_INT 3
41654: PUSH
41655: LD_INT 1
41657: NEG
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: PUSH
41663: LD_INT 4
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 4
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 4
41685: PUSH
41686: LD_INT 1
41688: NEG
41689: PUSH
41690: EMPTY
41691: LIST
41692: LIST
41693: PUSH
41694: LD_INT 5
41696: PUSH
41697: LD_INT 0
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 5
41706: PUSH
41707: LD_INT 1
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 5
41716: PUSH
41717: LD_INT 1
41719: NEG
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 6
41727: PUSH
41728: LD_INT 0
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 6
41737: PUSH
41738: LD_INT 1
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41759: LD_ADDR_VAR 0 31
41763: PUSH
41764: LD_INT 3
41766: PUSH
41767: LD_INT 2
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 3
41776: PUSH
41777: LD_INT 3
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: LD_INT 2
41786: PUSH
41787: LD_INT 3
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 4
41796: PUSH
41797: LD_INT 3
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 4
41806: PUSH
41807: LD_INT 4
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 3
41816: PUSH
41817: LD_INT 4
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 5
41826: PUSH
41827: LD_INT 4
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 5
41836: PUSH
41837: LD_INT 5
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 4
41846: PUSH
41847: LD_INT 5
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 6
41856: PUSH
41857: LD_INT 5
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 6
41866: PUSH
41867: LD_INT 6
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: LD_INT 5
41876: PUSH
41877: LD_INT 6
41879: PUSH
41880: EMPTY
41881: LIST
41882: LIST
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: LIST
41888: LIST
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41898: LD_ADDR_VAR 0 32
41902: PUSH
41903: LD_INT 1
41905: PUSH
41906: LD_INT 3
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: LD_INT 0
41915: PUSH
41916: LD_INT 3
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 1
41925: NEG
41926: PUSH
41927: LD_INT 2
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 1
41936: PUSH
41937: LD_INT 4
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: LD_INT 4
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: PUSH
41954: LD_INT 1
41956: NEG
41957: PUSH
41958: LD_INT 3
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 1
41967: PUSH
41968: LD_INT 5
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 0
41977: PUSH
41978: LD_INT 5
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 4
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 1
41998: PUSH
41999: LD_INT 6
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 0
42008: PUSH
42009: LD_INT 6
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: NEG
42019: PUSH
42020: LD_INT 5
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: EMPTY
42028: LIST
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: LIST
42034: LIST
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: LIST
42040: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42041: LD_ADDR_VAR 0 33
42045: PUSH
42046: LD_INT 2
42048: NEG
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: LD_INT 0
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 3
42070: NEG
42071: PUSH
42072: LD_INT 1
42074: NEG
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 3
42082: NEG
42083: PUSH
42084: LD_INT 1
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: LD_INT 4
42093: NEG
42094: PUSH
42095: LD_INT 0
42097: PUSH
42098: EMPTY
42099: LIST
42100: LIST
42101: PUSH
42102: LD_INT 4
42104: NEG
42105: PUSH
42106: LD_INT 1
42108: NEG
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 4
42116: NEG
42117: PUSH
42118: LD_INT 1
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: LD_INT 5
42127: NEG
42128: PUSH
42129: LD_INT 0
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 5
42138: NEG
42139: PUSH
42140: LD_INT 1
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 5
42150: NEG
42151: PUSH
42152: LD_INT 1
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 6
42161: NEG
42162: PUSH
42163: LD_INT 0
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: LD_INT 6
42172: NEG
42173: PUSH
42174: LD_INT 1
42176: NEG
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42196: LD_ADDR_VAR 0 34
42200: PUSH
42201: LD_INT 2
42203: NEG
42204: PUSH
42205: LD_INT 3
42207: NEG
42208: PUSH
42209: EMPTY
42210: LIST
42211: LIST
42212: PUSH
42213: LD_INT 3
42215: NEG
42216: PUSH
42217: LD_INT 2
42219: NEG
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 3
42239: NEG
42240: PUSH
42241: LD_INT 4
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 4
42251: NEG
42252: PUSH
42253: LD_INT 3
42255: NEG
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 4
42263: NEG
42264: PUSH
42265: LD_INT 4
42267: NEG
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 4
42275: NEG
42276: PUSH
42277: LD_INT 5
42279: NEG
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 5
42287: NEG
42288: PUSH
42289: LD_INT 4
42291: NEG
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: PUSH
42297: LD_INT 5
42299: NEG
42300: PUSH
42301: LD_INT 5
42303: NEG
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: LD_INT 5
42311: NEG
42312: PUSH
42313: LD_INT 6
42315: NEG
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 6
42323: NEG
42324: PUSH
42325: LD_INT 5
42327: NEG
42328: PUSH
42329: EMPTY
42330: LIST
42331: LIST
42332: PUSH
42333: LD_INT 6
42335: NEG
42336: PUSH
42337: LD_INT 6
42339: NEG
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42359: LD_ADDR_VAR 0 41
42363: PUSH
42364: LD_INT 0
42366: PUSH
42367: LD_INT 2
42369: NEG
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: LD_INT 1
42377: NEG
42378: PUSH
42379: LD_INT 3
42381: NEG
42382: PUSH
42383: EMPTY
42384: LIST
42385: LIST
42386: PUSH
42387: LD_INT 1
42389: PUSH
42390: LD_INT 2
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: LIST
42402: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42403: LD_ADDR_VAR 0 42
42407: PUSH
42408: LD_INT 2
42410: PUSH
42411: LD_INT 0
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 2
42420: PUSH
42421: LD_INT 1
42423: NEG
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 3
42431: PUSH
42432: LD_INT 1
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: EMPTY
42440: LIST
42441: LIST
42442: LIST
42443: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42444: LD_ADDR_VAR 0 43
42448: PUSH
42449: LD_INT 2
42451: PUSH
42452: LD_INT 2
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PUSH
42459: LD_INT 3
42461: PUSH
42462: LD_INT 2
42464: PUSH
42465: EMPTY
42466: LIST
42467: LIST
42468: PUSH
42469: LD_INT 2
42471: PUSH
42472: LD_INT 3
42474: PUSH
42475: EMPTY
42476: LIST
42477: LIST
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: LIST
42483: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42484: LD_ADDR_VAR 0 44
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 2
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 1
42501: PUSH
42502: LD_INT 3
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 1
42511: NEG
42512: PUSH
42513: LD_INT 2
42515: PUSH
42516: EMPTY
42517: LIST
42518: LIST
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: LIST
42524: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42525: LD_ADDR_VAR 0 45
42529: PUSH
42530: LD_INT 2
42532: NEG
42533: PUSH
42534: LD_INT 0
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: PUSH
42541: LD_INT 2
42543: NEG
42544: PUSH
42545: LD_INT 1
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: PUSH
42552: LD_INT 3
42554: NEG
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: LIST
42568: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42569: LD_ADDR_VAR 0 46
42573: PUSH
42574: LD_INT 2
42576: NEG
42577: PUSH
42578: LD_INT 2
42580: NEG
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: LD_INT 2
42588: NEG
42589: PUSH
42590: LD_INT 3
42592: NEG
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 3
42600: NEG
42601: PUSH
42602: LD_INT 2
42604: NEG
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: EMPTY
42611: LIST
42612: LIST
42613: LIST
42614: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42615: LD_ADDR_VAR 0 47
42619: PUSH
42620: LD_INT 2
42622: NEG
42623: PUSH
42624: LD_INT 3
42626: NEG
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 1
42634: NEG
42635: PUSH
42636: LD_INT 3
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42648: LD_ADDR_VAR 0 48
42652: PUSH
42653: LD_INT 1
42655: PUSH
42656: LD_INT 2
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 2
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42679: LD_ADDR_VAR 0 49
42683: PUSH
42684: LD_INT 3
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 3
42696: PUSH
42697: LD_INT 2
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42708: LD_ADDR_VAR 0 50
42712: PUSH
42713: LD_INT 2
42715: PUSH
42716: LD_INT 3
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 1
42725: PUSH
42726: LD_INT 3
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: EMPTY
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42737: LD_ADDR_VAR 0 51
42741: PUSH
42742: LD_INT 1
42744: NEG
42745: PUSH
42746: LD_INT 2
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: LD_INT 2
42755: NEG
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42768: LD_ADDR_VAR 0 52
42772: PUSH
42773: LD_INT 3
42775: NEG
42776: PUSH
42777: LD_INT 1
42779: NEG
42780: PUSH
42781: EMPTY
42782: LIST
42783: LIST
42784: PUSH
42785: LD_INT 3
42787: NEG
42788: PUSH
42789: LD_INT 2
42791: NEG
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42801: LD_ADDR_VAR 0 53
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 3
42812: NEG
42813: PUSH
42814: EMPTY
42815: LIST
42816: LIST
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: LD_INT 3
42823: NEG
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 1
42831: PUSH
42832: LD_INT 2
42834: NEG
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: LIST
42844: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42845: LD_ADDR_VAR 0 54
42849: PUSH
42850: LD_INT 2
42852: PUSH
42853: LD_INT 1
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 3
42863: PUSH
42864: LD_INT 0
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: PUSH
42871: LD_INT 3
42873: PUSH
42874: LD_INT 1
42876: PUSH
42877: EMPTY
42878: LIST
42879: LIST
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: LIST
42885: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42886: LD_ADDR_VAR 0 55
42890: PUSH
42891: LD_INT 3
42893: PUSH
42894: LD_INT 2
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 3
42903: PUSH
42904: LD_INT 3
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: PUSH
42911: LD_INT 2
42913: PUSH
42914: LD_INT 3
42916: PUSH
42917: EMPTY
42918: LIST
42919: LIST
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: LIST
42925: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42926: LD_ADDR_VAR 0 56
42930: PUSH
42931: LD_INT 1
42933: PUSH
42934: LD_INT 3
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 0
42943: PUSH
42944: LD_INT 3
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 1
42953: NEG
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: LIST
42966: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42967: LD_ADDR_VAR 0 57
42971: PUSH
42972: LD_INT 2
42974: NEG
42975: PUSH
42976: LD_INT 1
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: LD_INT 3
42985: NEG
42986: PUSH
42987: LD_INT 0
42989: PUSH
42990: EMPTY
42991: LIST
42992: LIST
42993: PUSH
42994: LD_INT 3
42996: NEG
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43011: LD_ADDR_VAR 0 58
43015: PUSH
43016: LD_INT 2
43018: NEG
43019: PUSH
43020: LD_INT 3
43022: NEG
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: LD_INT 3
43030: NEG
43031: PUSH
43032: LD_INT 2
43034: NEG
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 3
43042: NEG
43043: PUSH
43044: LD_INT 3
43046: NEG
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: LIST
43056: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43057: LD_ADDR_VAR 0 59
43061: PUSH
43062: LD_INT 1
43064: NEG
43065: PUSH
43066: LD_INT 2
43068: NEG
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: PUSH
43074: LD_INT 0
43076: PUSH
43077: LD_INT 2
43079: NEG
43080: PUSH
43081: EMPTY
43082: LIST
43083: LIST
43084: PUSH
43085: LD_INT 1
43087: PUSH
43088: LD_INT 1
43090: NEG
43091: PUSH
43092: EMPTY
43093: LIST
43094: LIST
43095: PUSH
43096: EMPTY
43097: LIST
43098: LIST
43099: LIST
43100: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43101: LD_ADDR_VAR 0 60
43105: PUSH
43106: LD_INT 1
43108: PUSH
43109: LD_INT 1
43111: NEG
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 2
43119: PUSH
43120: LD_INT 0
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 2
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: LIST
43141: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43142: LD_ADDR_VAR 0 61
43146: PUSH
43147: LD_INT 2
43149: PUSH
43150: LD_INT 1
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: PUSH
43160: LD_INT 2
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: PUSH
43170: LD_INT 2
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43182: LD_ADDR_VAR 0 62
43186: PUSH
43187: LD_INT 1
43189: PUSH
43190: LD_INT 2
43192: PUSH
43193: EMPTY
43194: LIST
43195: LIST
43196: PUSH
43197: LD_INT 0
43199: PUSH
43200: LD_INT 2
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 1
43209: NEG
43210: PUSH
43211: LD_INT 1
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: LIST
43222: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43223: LD_ADDR_VAR 0 63
43227: PUSH
43228: LD_INT 1
43230: NEG
43231: PUSH
43232: LD_INT 1
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: LD_INT 0
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: LD_INT 2
43252: NEG
43253: PUSH
43254: LD_INT 1
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43267: LD_ADDR_VAR 0 64
43271: PUSH
43272: LD_INT 1
43274: NEG
43275: PUSH
43276: LD_INT 2
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 2
43286: NEG
43287: PUSH
43288: LD_INT 1
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 2
43298: NEG
43299: PUSH
43300: LD_INT 2
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: LIST
43312: ST_TO_ADDR
// end ; 2 :
43313: GO 46579
43315: LD_INT 2
43317: DOUBLE
43318: EQUAL
43319: IFTRUE 43323
43321: GO 46578
43323: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43324: LD_ADDR_VAR 0 29
43328: PUSH
43329: LD_INT 4
43331: PUSH
43332: LD_INT 0
43334: PUSH
43335: EMPTY
43336: LIST
43337: LIST
43338: PUSH
43339: LD_INT 4
43341: PUSH
43342: LD_INT 1
43344: NEG
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 5
43352: PUSH
43353: LD_INT 0
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 5
43362: PUSH
43363: LD_INT 1
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 4
43372: PUSH
43373: LD_INT 1
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 3
43382: PUSH
43383: LD_INT 0
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 3
43392: PUSH
43393: LD_INT 1
43395: NEG
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: PUSH
43404: LD_INT 2
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 5
43414: PUSH
43415: LD_INT 2
43417: PUSH
43418: EMPTY
43419: LIST
43420: LIST
43421: PUSH
43422: LD_INT 3
43424: PUSH
43425: LD_INT 3
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: PUSH
43432: LD_INT 3
43434: PUSH
43435: LD_INT 2
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 4
43444: PUSH
43445: LD_INT 3
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: PUSH
43452: LD_INT 4
43454: PUSH
43455: LD_INT 4
43457: PUSH
43458: EMPTY
43459: LIST
43460: LIST
43461: PUSH
43462: LD_INT 3
43464: PUSH
43465: LD_INT 4
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 3
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 2
43484: PUSH
43485: LD_INT 2
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 4
43494: PUSH
43495: LD_INT 2
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 2
43504: PUSH
43505: LD_INT 4
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 0
43514: PUSH
43515: LD_INT 4
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 0
43524: PUSH
43525: LD_INT 3
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 1
43534: PUSH
43535: LD_INT 4
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: LD_INT 5
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 0
43554: PUSH
43555: LD_INT 5
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 1
43564: NEG
43565: PUSH
43566: LD_INT 4
43568: PUSH
43569: EMPTY
43570: LIST
43571: LIST
43572: PUSH
43573: LD_INT 1
43575: NEG
43576: PUSH
43577: LD_INT 3
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 2
43586: PUSH
43587: LD_INT 5
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 2
43596: NEG
43597: PUSH
43598: LD_INT 3
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 3
43607: NEG
43608: PUSH
43609: LD_INT 0
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 3
43618: NEG
43619: PUSH
43620: LD_INT 1
43622: NEG
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: LD_INT 2
43630: NEG
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: EMPTY
43636: LIST
43637: LIST
43638: PUSH
43639: LD_INT 2
43641: NEG
43642: PUSH
43643: LD_INT 1
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 3
43652: NEG
43653: PUSH
43654: LD_INT 1
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 4
43663: NEG
43664: PUSH
43665: LD_INT 0
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: LD_INT 4
43674: NEG
43675: PUSH
43676: LD_INT 1
43678: NEG
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 4
43686: NEG
43687: PUSH
43688: LD_INT 2
43690: NEG
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: LD_INT 2
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: PUSH
43707: LD_INT 4
43709: NEG
43710: PUSH
43711: LD_INT 4
43713: NEG
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 4
43721: NEG
43722: PUSH
43723: LD_INT 5
43725: NEG
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: LD_INT 3
43733: NEG
43734: PUSH
43735: LD_INT 4
43737: NEG
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: LD_INT 3
43749: NEG
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 4
43757: NEG
43758: PUSH
43759: LD_INT 3
43761: NEG
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: LD_INT 5
43769: NEG
43770: PUSH
43771: LD_INT 4
43773: NEG
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: LD_INT 5
43785: NEG
43786: PUSH
43787: EMPTY
43788: LIST
43789: LIST
43790: PUSH
43791: LD_INT 3
43793: NEG
43794: PUSH
43795: LD_INT 5
43797: NEG
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: LD_INT 5
43805: NEG
43806: PUSH
43807: LD_INT 3
43809: NEG
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43862: LD_ADDR_VAR 0 30
43866: PUSH
43867: LD_INT 4
43869: PUSH
43870: LD_INT 4
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 4
43879: PUSH
43880: LD_INT 3
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 5
43889: PUSH
43890: LD_INT 4
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 5
43899: PUSH
43900: LD_INT 5
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 4
43909: PUSH
43910: LD_INT 5
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: PUSH
43920: LD_INT 4
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 3
43929: PUSH
43930: LD_INT 3
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 5
43939: PUSH
43940: LD_INT 3
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 3
43949: PUSH
43950: LD_INT 5
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 0
43959: PUSH
43960: LD_INT 3
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: LD_INT 0
43969: PUSH
43970: LD_INT 2
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 1
43979: PUSH
43980: LD_INT 3
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PUSH
43987: LD_INT 1
43989: PUSH
43990: LD_INT 4
43992: PUSH
43993: EMPTY
43994: LIST
43995: LIST
43996: PUSH
43997: LD_INT 0
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: NEG
44010: PUSH
44011: LD_INT 3
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: LD_INT 1
44020: NEG
44021: PUSH
44022: LD_INT 2
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 2
44041: NEG
44042: PUSH
44043: LD_INT 2
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 4
44052: NEG
44053: PUSH
44054: LD_INT 0
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 4
44063: NEG
44064: PUSH
44065: LD_INT 1
44067: NEG
44068: PUSH
44069: EMPTY
44070: LIST
44071: LIST
44072: PUSH
44073: LD_INT 3
44075: NEG
44076: PUSH
44077: LD_INT 0
44079: PUSH
44080: EMPTY
44081: LIST
44082: LIST
44083: PUSH
44084: LD_INT 3
44086: NEG
44087: PUSH
44088: LD_INT 1
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 4
44097: NEG
44098: PUSH
44099: LD_INT 1
44101: PUSH
44102: EMPTY
44103: LIST
44104: LIST
44105: PUSH
44106: LD_INT 5
44108: NEG
44109: PUSH
44110: LD_INT 0
44112: PUSH
44113: EMPTY
44114: LIST
44115: LIST
44116: PUSH
44117: LD_INT 5
44119: NEG
44120: PUSH
44121: LD_INT 1
44123: NEG
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 5
44131: NEG
44132: PUSH
44133: LD_INT 2
44135: NEG
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 3
44143: NEG
44144: PUSH
44145: LD_INT 2
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 3
44154: NEG
44155: PUSH
44156: LD_INT 3
44158: NEG
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 3
44166: NEG
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: EMPTY
44173: LIST
44174: LIST
44175: PUSH
44176: LD_INT 2
44178: NEG
44179: PUSH
44180: LD_INT 3
44182: NEG
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 2
44190: NEG
44191: PUSH
44192: LD_INT 2
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 3
44202: NEG
44203: PUSH
44204: LD_INT 2
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 4
44214: NEG
44215: PUSH
44216: LD_INT 3
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: LD_INT 4
44230: NEG
44231: PUSH
44232: EMPTY
44233: LIST
44234: LIST
44235: PUSH
44236: LD_INT 2
44238: NEG
44239: PUSH
44240: LD_INT 4
44242: NEG
44243: PUSH
44244: EMPTY
44245: LIST
44246: LIST
44247: PUSH
44248: LD_INT 4
44250: NEG
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 0
44262: PUSH
44263: LD_INT 4
44265: NEG
44266: PUSH
44267: EMPTY
44268: LIST
44269: LIST
44270: PUSH
44271: LD_INT 0
44273: PUSH
44274: LD_INT 5
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 1
44284: PUSH
44285: LD_INT 4
44287: NEG
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 1
44295: PUSH
44296: LD_INT 3
44298: NEG
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 0
44306: PUSH
44307: LD_INT 3
44309: NEG
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 1
44317: NEG
44318: PUSH
44319: LD_INT 4
44321: NEG
44322: PUSH
44323: EMPTY
44324: LIST
44325: LIST
44326: PUSH
44327: LD_INT 1
44329: NEG
44330: PUSH
44331: LD_INT 5
44333: NEG
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 2
44341: PUSH
44342: LD_INT 3
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 2
44352: NEG
44353: PUSH
44354: LD_INT 5
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44409: LD_ADDR_VAR 0 31
44413: PUSH
44414: LD_INT 0
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: LD_INT 3
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 1
44436: PUSH
44437: LD_INT 4
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 1
44446: PUSH
44447: LD_INT 5
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: LD_INT 5
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 1
44466: NEG
44467: PUSH
44468: LD_INT 4
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 1
44477: NEG
44478: PUSH
44479: LD_INT 3
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PUSH
44486: LD_INT 2
44488: PUSH
44489: LD_INT 5
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 2
44498: NEG
44499: PUSH
44500: LD_INT 3
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 3
44509: NEG
44510: PUSH
44511: LD_INT 0
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 3
44520: NEG
44521: PUSH
44522: LD_INT 1
44524: NEG
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 2
44532: NEG
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: LD_INT 1
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 3
44554: NEG
44555: PUSH
44556: LD_INT 1
44558: PUSH
44559: EMPTY
44560: LIST
44561: LIST
44562: PUSH
44563: LD_INT 4
44565: NEG
44566: PUSH
44567: LD_INT 0
44569: PUSH
44570: EMPTY
44571: LIST
44572: LIST
44573: PUSH
44574: LD_INT 4
44576: NEG
44577: PUSH
44578: LD_INT 1
44580: NEG
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 4
44588: NEG
44589: PUSH
44590: LD_INT 2
44592: NEG
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 2
44600: NEG
44601: PUSH
44602: LD_INT 2
44604: PUSH
44605: EMPTY
44606: LIST
44607: LIST
44608: PUSH
44609: LD_INT 4
44611: NEG
44612: PUSH
44613: LD_INT 4
44615: NEG
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 4
44623: NEG
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 3
44635: NEG
44636: PUSH
44637: LD_INT 4
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 3
44647: NEG
44648: PUSH
44649: LD_INT 3
44651: NEG
44652: PUSH
44653: EMPTY
44654: LIST
44655: LIST
44656: PUSH
44657: LD_INT 4
44659: NEG
44660: PUSH
44661: LD_INT 3
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 5
44671: NEG
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 5
44683: NEG
44684: PUSH
44685: LD_INT 5
44687: NEG
44688: PUSH
44689: EMPTY
44690: LIST
44691: LIST
44692: PUSH
44693: LD_INT 3
44695: NEG
44696: PUSH
44697: LD_INT 5
44699: NEG
44700: PUSH
44701: EMPTY
44702: LIST
44703: LIST
44704: PUSH
44705: LD_INT 5
44707: NEG
44708: PUSH
44709: LD_INT 3
44711: NEG
44712: PUSH
44713: EMPTY
44714: LIST
44715: LIST
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: LD_INT 3
44722: NEG
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 0
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 1
44741: PUSH
44742: LD_INT 3
44744: NEG
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 1
44752: PUSH
44753: LD_INT 2
44755: NEG
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: PUSH
44761: LD_INT 0
44763: PUSH
44764: LD_INT 2
44766: NEG
44767: PUSH
44768: EMPTY
44769: LIST
44770: LIST
44771: PUSH
44772: LD_INT 1
44774: NEG
44775: PUSH
44776: LD_INT 3
44778: NEG
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: LD_INT 1
44786: NEG
44787: PUSH
44788: LD_INT 4
44790: NEG
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 2
44798: PUSH
44799: LD_INT 2
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 2
44809: NEG
44810: PUSH
44811: LD_INT 4
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 4
44821: PUSH
44822: LD_INT 0
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 4
44831: PUSH
44832: LD_INT 1
44834: NEG
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 5
44842: PUSH
44843: LD_INT 0
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 5
44852: PUSH
44853: LD_INT 1
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: PUSH
44863: LD_INT 1
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 3
44872: PUSH
44873: LD_INT 0
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 3
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 2
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 5
44904: PUSH
44905: LD_INT 2
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: EMPTY
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44959: LD_ADDR_VAR 0 32
44963: PUSH
44964: LD_INT 4
44966: NEG
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 4
44977: NEG
44978: PUSH
44979: LD_INT 1
44981: NEG
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 3
44989: NEG
44990: PUSH
44991: LD_INT 0
44993: PUSH
44994: EMPTY
44995: LIST
44996: LIST
44997: PUSH
44998: LD_INT 3
45000: NEG
45001: PUSH
45002: LD_INT 1
45004: PUSH
45005: EMPTY
45006: LIST
45007: LIST
45008: PUSH
45009: LD_INT 4
45011: NEG
45012: PUSH
45013: LD_INT 1
45015: PUSH
45016: EMPTY
45017: LIST
45018: LIST
45019: PUSH
45020: LD_INT 5
45022: NEG
45023: PUSH
45024: LD_INT 0
45026: PUSH
45027: EMPTY
45028: LIST
45029: LIST
45030: PUSH
45031: LD_INT 5
45033: NEG
45034: PUSH
45035: LD_INT 1
45037: NEG
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_INT 5
45045: NEG
45046: PUSH
45047: LD_INT 2
45049: NEG
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 3
45057: NEG
45058: PUSH
45059: LD_INT 2
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 3
45068: NEG
45069: PUSH
45070: LD_INT 3
45072: NEG
45073: PUSH
45074: EMPTY
45075: LIST
45076: LIST
45077: PUSH
45078: LD_INT 3
45080: NEG
45081: PUSH
45082: LD_INT 4
45084: NEG
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 2
45092: NEG
45093: PUSH
45094: LD_INT 3
45096: NEG
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 2
45104: NEG
45105: PUSH
45106: LD_INT 2
45108: NEG
45109: PUSH
45110: EMPTY
45111: LIST
45112: LIST
45113: PUSH
45114: LD_INT 3
45116: NEG
45117: PUSH
45118: LD_INT 2
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 4
45128: NEG
45129: PUSH
45130: LD_INT 3
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 4
45140: NEG
45141: PUSH
45142: LD_INT 4
45144: NEG
45145: PUSH
45146: EMPTY
45147: LIST
45148: LIST
45149: PUSH
45150: LD_INT 2
45152: NEG
45153: PUSH
45154: LD_INT 4
45156: NEG
45157: PUSH
45158: EMPTY
45159: LIST
45160: LIST
45161: PUSH
45162: LD_INT 4
45164: NEG
45165: PUSH
45166: LD_INT 2
45168: NEG
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 0
45176: PUSH
45177: LD_INT 4
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: LD_INT 5
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 1
45198: PUSH
45199: LD_INT 4
45201: NEG
45202: PUSH
45203: EMPTY
45204: LIST
45205: LIST
45206: PUSH
45207: LD_INT 1
45209: PUSH
45210: LD_INT 3
45212: NEG
45213: PUSH
45214: EMPTY
45215: LIST
45216: LIST
45217: PUSH
45218: LD_INT 0
45220: PUSH
45221: LD_INT 3
45223: NEG
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: LD_INT 1
45231: NEG
45232: PUSH
45233: LD_INT 4
45235: NEG
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 1
45243: NEG
45244: PUSH
45245: LD_INT 5
45247: NEG
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 2
45255: PUSH
45256: LD_INT 3
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 2
45266: NEG
45267: PUSH
45268: LD_INT 5
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 3
45278: PUSH
45279: LD_INT 0
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 3
45288: PUSH
45289: LD_INT 1
45291: NEG
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 4
45299: PUSH
45300: LD_INT 0
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 4
45309: PUSH
45310: LD_INT 1
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: LD_INT 1
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 2
45329: PUSH
45330: LD_INT 0
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 2
45339: PUSH
45340: LD_INT 1
45342: NEG
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PUSH
45348: LD_INT 2
45350: PUSH
45351: LD_INT 2
45353: NEG
45354: PUSH
45355: EMPTY
45356: LIST
45357: LIST
45358: PUSH
45359: LD_INT 4
45361: PUSH
45362: LD_INT 2
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 4
45371: PUSH
45372: LD_INT 4
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: LD_INT 3
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 5
45391: PUSH
45392: LD_INT 4
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 5
45401: PUSH
45402: LD_INT 5
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 4
45411: PUSH
45412: LD_INT 5
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: PUSH
45422: LD_INT 4
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: LD_INT 3
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 5
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 3
45451: PUSH
45452: LD_INT 5
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45506: LD_ADDR_VAR 0 33
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: LD_INT 4
45517: NEG
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: LD_INT 4
45525: NEG
45526: PUSH
45527: LD_INT 5
45529: NEG
45530: PUSH
45531: EMPTY
45532: LIST
45533: LIST
45534: PUSH
45535: LD_INT 3
45537: NEG
45538: PUSH
45539: LD_INT 4
45541: NEG
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 3
45549: NEG
45550: PUSH
45551: LD_INT 3
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 4
45561: NEG
45562: PUSH
45563: LD_INT 3
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 5
45573: NEG
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 5
45585: NEG
45586: PUSH
45587: LD_INT 5
45589: NEG
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: PUSH
45595: LD_INT 3
45597: NEG
45598: PUSH
45599: LD_INT 5
45601: NEG
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: LD_INT 5
45609: NEG
45610: PUSH
45611: LD_INT 3
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 0
45621: PUSH
45622: LD_INT 3
45624: NEG
45625: PUSH
45626: EMPTY
45627: LIST
45628: LIST
45629: PUSH
45630: LD_INT 0
45632: PUSH
45633: LD_INT 4
45635: NEG
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 1
45643: PUSH
45644: LD_INT 3
45646: NEG
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: PUSH
45652: LD_INT 1
45654: PUSH
45655: LD_INT 2
45657: NEG
45658: PUSH
45659: EMPTY
45660: LIST
45661: LIST
45662: PUSH
45663: LD_INT 0
45665: PUSH
45666: LD_INT 2
45668: NEG
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: PUSH
45674: LD_INT 1
45676: NEG
45677: PUSH
45678: LD_INT 3
45680: NEG
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 1
45688: NEG
45689: PUSH
45690: LD_INT 4
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 2
45700: PUSH
45701: LD_INT 2
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 2
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 4
45723: PUSH
45724: LD_INT 0
45726: PUSH
45727: EMPTY
45728: LIST
45729: LIST
45730: PUSH
45731: LD_INT 4
45733: PUSH
45734: LD_INT 1
45736: NEG
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 5
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 5
45754: PUSH
45755: LD_INT 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 4
45764: PUSH
45765: LD_INT 1
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 3
45774: PUSH
45775: LD_INT 0
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 3
45784: PUSH
45785: LD_INT 1
45787: NEG
45788: PUSH
45789: EMPTY
45790: LIST
45791: LIST
45792: PUSH
45793: LD_INT 3
45795: PUSH
45796: LD_INT 2
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 5
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 3
45816: PUSH
45817: LD_INT 3
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: LD_INT 3
45826: PUSH
45827: LD_INT 2
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 4
45836: PUSH
45837: LD_INT 3
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 4
45846: PUSH
45847: LD_INT 4
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: LD_INT 4
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 2
45866: PUSH
45867: LD_INT 3
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 2
45876: PUSH
45877: LD_INT 2
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 4
45886: PUSH
45887: LD_INT 2
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 2
45896: PUSH
45897: LD_INT 4
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 0
45906: PUSH
45907: LD_INT 4
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 0
45916: PUSH
45917: LD_INT 3
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: PUSH
45924: LD_INT 1
45926: PUSH
45927: LD_INT 4
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 1
45936: PUSH
45937: LD_INT 5
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 0
45946: PUSH
45947: LD_INT 5
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 1
45956: NEG
45957: PUSH
45958: LD_INT 4
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PUSH
45965: LD_INT 1
45967: NEG
45968: PUSH
45969: LD_INT 3
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 2
45978: PUSH
45979: LD_INT 5
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 2
45988: NEG
45989: PUSH
45990: LD_INT 3
45992: PUSH
45993: EMPTY
45994: LIST
45995: LIST
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46044: LD_ADDR_VAR 0 34
46048: PUSH
46049: LD_INT 0
46051: PUSH
46052: LD_INT 4
46054: NEG
46055: PUSH
46056: EMPTY
46057: LIST
46058: LIST
46059: PUSH
46060: LD_INT 0
46062: PUSH
46063: LD_INT 5
46065: NEG
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PUSH
46071: LD_INT 1
46073: PUSH
46074: LD_INT 4
46076: NEG
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 1
46084: PUSH
46085: LD_INT 3
46087: NEG
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 0
46095: PUSH
46096: LD_INT 3
46098: NEG
46099: PUSH
46100: EMPTY
46101: LIST
46102: LIST
46103: PUSH
46104: LD_INT 1
46106: NEG
46107: PUSH
46108: LD_INT 4
46110: NEG
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 1
46118: NEG
46119: PUSH
46120: LD_INT 5
46122: NEG
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 2
46130: PUSH
46131: LD_INT 3
46133: NEG
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 2
46141: NEG
46142: PUSH
46143: LD_INT 5
46145: NEG
46146: PUSH
46147: EMPTY
46148: LIST
46149: LIST
46150: PUSH
46151: LD_INT 3
46153: PUSH
46154: LD_INT 0
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 3
46163: PUSH
46164: LD_INT 1
46166: NEG
46167: PUSH
46168: EMPTY
46169: LIST
46170: LIST
46171: PUSH
46172: LD_INT 4
46174: PUSH
46175: LD_INT 0
46177: PUSH
46178: EMPTY
46179: LIST
46180: LIST
46181: PUSH
46182: LD_INT 4
46184: PUSH
46185: LD_INT 1
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 3
46194: PUSH
46195: LD_INT 1
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 2
46204: PUSH
46205: LD_INT 0
46207: PUSH
46208: EMPTY
46209: LIST
46210: LIST
46211: PUSH
46212: LD_INT 2
46214: PUSH
46215: LD_INT 1
46217: NEG
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: PUSH
46223: LD_INT 2
46225: PUSH
46226: LD_INT 2
46228: NEG
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PUSH
46234: LD_INT 4
46236: PUSH
46237: LD_INT 2
46239: PUSH
46240: EMPTY
46241: LIST
46242: LIST
46243: PUSH
46244: LD_INT 4
46246: PUSH
46247: LD_INT 4
46249: PUSH
46250: EMPTY
46251: LIST
46252: LIST
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 5
46266: PUSH
46267: LD_INT 4
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 5
46276: PUSH
46277: LD_INT 5
46279: PUSH
46280: EMPTY
46281: LIST
46282: LIST
46283: PUSH
46284: LD_INT 4
46286: PUSH
46287: LD_INT 5
46289: PUSH
46290: EMPTY
46291: LIST
46292: LIST
46293: PUSH
46294: LD_INT 3
46296: PUSH
46297: LD_INT 4
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 3
46306: PUSH
46307: LD_INT 3
46309: PUSH
46310: EMPTY
46311: LIST
46312: LIST
46313: PUSH
46314: LD_INT 5
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: LD_INT 5
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 0
46336: PUSH
46337: LD_INT 3
46339: PUSH
46340: EMPTY
46341: LIST
46342: LIST
46343: PUSH
46344: LD_INT 0
46346: PUSH
46347: LD_INT 2
46349: PUSH
46350: EMPTY
46351: LIST
46352: LIST
46353: PUSH
46354: LD_INT 1
46356: PUSH
46357: LD_INT 3
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: LD_INT 1
46366: PUSH
46367: LD_INT 4
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 0
46376: PUSH
46377: LD_INT 4
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 1
46386: NEG
46387: PUSH
46388: LD_INT 3
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: PUSH
46395: LD_INT 1
46397: NEG
46398: PUSH
46399: LD_INT 2
46401: PUSH
46402: EMPTY
46403: LIST
46404: LIST
46405: PUSH
46406: LD_INT 2
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: EMPTY
46413: LIST
46414: LIST
46415: PUSH
46416: LD_INT 2
46418: NEG
46419: PUSH
46420: LD_INT 2
46422: PUSH
46423: EMPTY
46424: LIST
46425: LIST
46426: PUSH
46427: LD_INT 4
46429: NEG
46430: PUSH
46431: LD_INT 0
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 4
46440: NEG
46441: PUSH
46442: LD_INT 1
46444: NEG
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 3
46452: NEG
46453: PUSH
46454: LD_INT 0
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 3
46463: NEG
46464: PUSH
46465: LD_INT 1
46467: PUSH
46468: EMPTY
46469: LIST
46470: LIST
46471: PUSH
46472: LD_INT 4
46474: NEG
46475: PUSH
46476: LD_INT 1
46478: PUSH
46479: EMPTY
46480: LIST
46481: LIST
46482: PUSH
46483: LD_INT 5
46485: NEG
46486: PUSH
46487: LD_INT 0
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 5
46496: NEG
46497: PUSH
46498: LD_INT 1
46500: NEG
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 5
46508: NEG
46509: PUSH
46510: LD_INT 2
46512: NEG
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 3
46520: NEG
46521: PUSH
46522: LD_INT 2
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: ST_TO_ADDR
// end ; end ;
46576: GO 46579
46578: POP
// case btype of b_depot , b_warehouse :
46579: LD_VAR 0 1
46583: PUSH
46584: LD_INT 0
46586: DOUBLE
46587: EQUAL
46588: IFTRUE 46598
46590: LD_INT 1
46592: DOUBLE
46593: EQUAL
46594: IFTRUE 46598
46596: GO 46799
46598: POP
// case nation of nation_american :
46599: LD_VAR 0 5
46603: PUSH
46604: LD_INT 1
46606: DOUBLE
46607: EQUAL
46608: IFTRUE 46612
46610: GO 46668
46612: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46613: LD_ADDR_VAR 0 9
46617: PUSH
46618: LD_VAR 0 11
46622: PUSH
46623: LD_VAR 0 12
46627: PUSH
46628: LD_VAR 0 13
46632: PUSH
46633: LD_VAR 0 14
46637: PUSH
46638: LD_VAR 0 15
46642: PUSH
46643: LD_VAR 0 16
46647: PUSH
46648: EMPTY
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 4
46660: PUSH
46661: LD_INT 1
46663: PLUS
46664: ARRAY
46665: ST_TO_ADDR
46666: GO 46797
46668: LD_INT 2
46670: DOUBLE
46671: EQUAL
46672: IFTRUE 46676
46674: GO 46732
46676: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 17
46686: PUSH
46687: LD_VAR 0 18
46691: PUSH
46692: LD_VAR 0 19
46696: PUSH
46697: LD_VAR 0 20
46701: PUSH
46702: LD_VAR 0 21
46706: PUSH
46707: LD_VAR 0 22
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: PUSH
46720: LD_VAR 0 4
46724: PUSH
46725: LD_INT 1
46727: PLUS
46728: ARRAY
46729: ST_TO_ADDR
46730: GO 46797
46732: LD_INT 3
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46740
46738: GO 46796
46740: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46741: LD_ADDR_VAR 0 9
46745: PUSH
46746: LD_VAR 0 23
46750: PUSH
46751: LD_VAR 0 24
46755: PUSH
46756: LD_VAR 0 25
46760: PUSH
46761: LD_VAR 0 26
46765: PUSH
46766: LD_VAR 0 27
46770: PUSH
46771: LD_VAR 0 28
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: PUSH
46784: LD_VAR 0 4
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: ARRAY
46793: ST_TO_ADDR
46794: GO 46797
46796: POP
46797: GO 47346
46799: LD_INT 2
46801: DOUBLE
46802: EQUAL
46803: IFTRUE 46813
46805: LD_INT 3
46807: DOUBLE
46808: EQUAL
46809: IFTRUE 46813
46811: GO 46869
46813: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46814: LD_ADDR_VAR 0 9
46818: PUSH
46819: LD_VAR 0 29
46823: PUSH
46824: LD_VAR 0 30
46828: PUSH
46829: LD_VAR 0 31
46833: PUSH
46834: LD_VAR 0 32
46838: PUSH
46839: LD_VAR 0 33
46843: PUSH
46844: LD_VAR 0 34
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: LIST
46853: LIST
46854: LIST
46855: LIST
46856: PUSH
46857: LD_VAR 0 4
46861: PUSH
46862: LD_INT 1
46864: PLUS
46865: ARRAY
46866: ST_TO_ADDR
46867: GO 47346
46869: LD_INT 16
46871: DOUBLE
46872: EQUAL
46873: IFTRUE 46925
46875: LD_INT 17
46877: DOUBLE
46878: EQUAL
46879: IFTRUE 46925
46881: LD_INT 18
46883: DOUBLE
46884: EQUAL
46885: IFTRUE 46925
46887: LD_INT 19
46889: DOUBLE
46890: EQUAL
46891: IFTRUE 46925
46893: LD_INT 20
46895: DOUBLE
46896: EQUAL
46897: IFTRUE 46925
46899: LD_INT 21
46901: DOUBLE
46902: EQUAL
46903: IFTRUE 46925
46905: LD_INT 23
46907: DOUBLE
46908: EQUAL
46909: IFTRUE 46925
46911: LD_INT 24
46913: DOUBLE
46914: EQUAL
46915: IFTRUE 46925
46917: LD_INT 25
46919: DOUBLE
46920: EQUAL
46921: IFTRUE 46925
46923: GO 46981
46925: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46926: LD_ADDR_VAR 0 9
46930: PUSH
46931: LD_VAR 0 35
46935: PUSH
46936: LD_VAR 0 36
46940: PUSH
46941: LD_VAR 0 37
46945: PUSH
46946: LD_VAR 0 38
46950: PUSH
46951: LD_VAR 0 39
46955: PUSH
46956: LD_VAR 0 40
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: PUSH
46969: LD_VAR 0 4
46973: PUSH
46974: LD_INT 1
46976: PLUS
46977: ARRAY
46978: ST_TO_ADDR
46979: GO 47346
46981: LD_INT 6
46983: DOUBLE
46984: EQUAL
46985: IFTRUE 47037
46987: LD_INT 7
46989: DOUBLE
46990: EQUAL
46991: IFTRUE 47037
46993: LD_INT 8
46995: DOUBLE
46996: EQUAL
46997: IFTRUE 47037
46999: LD_INT 13
47001: DOUBLE
47002: EQUAL
47003: IFTRUE 47037
47005: LD_INT 12
47007: DOUBLE
47008: EQUAL
47009: IFTRUE 47037
47011: LD_INT 15
47013: DOUBLE
47014: EQUAL
47015: IFTRUE 47037
47017: LD_INT 11
47019: DOUBLE
47020: EQUAL
47021: IFTRUE 47037
47023: LD_INT 14
47025: DOUBLE
47026: EQUAL
47027: IFTRUE 47037
47029: LD_INT 10
47031: DOUBLE
47032: EQUAL
47033: IFTRUE 47037
47035: GO 47093
47037: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47038: LD_ADDR_VAR 0 9
47042: PUSH
47043: LD_VAR 0 41
47047: PUSH
47048: LD_VAR 0 42
47052: PUSH
47053: LD_VAR 0 43
47057: PUSH
47058: LD_VAR 0 44
47062: PUSH
47063: LD_VAR 0 45
47067: PUSH
47068: LD_VAR 0 46
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: PUSH
47081: LD_VAR 0 4
47085: PUSH
47086: LD_INT 1
47088: PLUS
47089: ARRAY
47090: ST_TO_ADDR
47091: GO 47346
47093: LD_INT 36
47095: DOUBLE
47096: EQUAL
47097: IFTRUE 47101
47099: GO 47157
47101: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47102: LD_ADDR_VAR 0 9
47106: PUSH
47107: LD_VAR 0 47
47111: PUSH
47112: LD_VAR 0 48
47116: PUSH
47117: LD_VAR 0 49
47121: PUSH
47122: LD_VAR 0 50
47126: PUSH
47127: LD_VAR 0 51
47131: PUSH
47132: LD_VAR 0 52
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: PUSH
47145: LD_VAR 0 4
47149: PUSH
47150: LD_INT 1
47152: PLUS
47153: ARRAY
47154: ST_TO_ADDR
47155: GO 47346
47157: LD_INT 4
47159: DOUBLE
47160: EQUAL
47161: IFTRUE 47183
47163: LD_INT 5
47165: DOUBLE
47166: EQUAL
47167: IFTRUE 47183
47169: LD_INT 34
47171: DOUBLE
47172: EQUAL
47173: IFTRUE 47183
47175: LD_INT 37
47177: DOUBLE
47178: EQUAL
47179: IFTRUE 47183
47181: GO 47239
47183: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47184: LD_ADDR_VAR 0 9
47188: PUSH
47189: LD_VAR 0 53
47193: PUSH
47194: LD_VAR 0 54
47198: PUSH
47199: LD_VAR 0 55
47203: PUSH
47204: LD_VAR 0 56
47208: PUSH
47209: LD_VAR 0 57
47213: PUSH
47214: LD_VAR 0 58
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: LIST
47223: LIST
47224: LIST
47225: LIST
47226: PUSH
47227: LD_VAR 0 4
47231: PUSH
47232: LD_INT 1
47234: PLUS
47235: ARRAY
47236: ST_TO_ADDR
47237: GO 47346
47239: LD_INT 31
47241: DOUBLE
47242: EQUAL
47243: IFTRUE 47289
47245: LD_INT 32
47247: DOUBLE
47248: EQUAL
47249: IFTRUE 47289
47251: LD_INT 33
47253: DOUBLE
47254: EQUAL
47255: IFTRUE 47289
47257: LD_INT 27
47259: DOUBLE
47260: EQUAL
47261: IFTRUE 47289
47263: LD_INT 26
47265: DOUBLE
47266: EQUAL
47267: IFTRUE 47289
47269: LD_INT 28
47271: DOUBLE
47272: EQUAL
47273: IFTRUE 47289
47275: LD_INT 29
47277: DOUBLE
47278: EQUAL
47279: IFTRUE 47289
47281: LD_INT 30
47283: DOUBLE
47284: EQUAL
47285: IFTRUE 47289
47287: GO 47345
47289: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47290: LD_ADDR_VAR 0 9
47294: PUSH
47295: LD_VAR 0 59
47299: PUSH
47300: LD_VAR 0 60
47304: PUSH
47305: LD_VAR 0 61
47309: PUSH
47310: LD_VAR 0 62
47314: PUSH
47315: LD_VAR 0 63
47319: PUSH
47320: LD_VAR 0 64
47324: PUSH
47325: EMPTY
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: PUSH
47333: LD_VAR 0 4
47337: PUSH
47338: LD_INT 1
47340: PLUS
47341: ARRAY
47342: ST_TO_ADDR
47343: GO 47346
47345: POP
// temp_list2 = [ ] ;
47346: LD_ADDR_VAR 0 10
47350: PUSH
47351: EMPTY
47352: ST_TO_ADDR
// for i in temp_list do
47353: LD_ADDR_VAR 0 8
47357: PUSH
47358: LD_VAR 0 9
47362: PUSH
47363: FOR_IN
47364: IFFALSE 47416
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47366: LD_ADDR_VAR 0 10
47370: PUSH
47371: LD_VAR 0 10
47375: PUSH
47376: LD_VAR 0 8
47380: PUSH
47381: LD_INT 1
47383: ARRAY
47384: PUSH
47385: LD_VAR 0 2
47389: PLUS
47390: PUSH
47391: LD_VAR 0 8
47395: PUSH
47396: LD_INT 2
47398: ARRAY
47399: PUSH
47400: LD_VAR 0 3
47404: PLUS
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: EMPTY
47411: LIST
47412: ADD
47413: ST_TO_ADDR
47414: GO 47363
47416: POP
47417: POP
// result = temp_list2 ;
47418: LD_ADDR_VAR 0 7
47422: PUSH
47423: LD_VAR 0 10
47427: ST_TO_ADDR
// end ;
47428: LD_VAR 0 7
47432: RET
// export function EnemyInRange ( unit , dist ) ; begin
47433: LD_INT 0
47435: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47436: LD_ADDR_VAR 0 3
47440: PUSH
47441: LD_VAR 0 1
47445: PPUSH
47446: CALL_OW 255
47450: PPUSH
47451: LD_VAR 0 1
47455: PPUSH
47456: CALL_OW 250
47460: PPUSH
47461: LD_VAR 0 1
47465: PPUSH
47466: CALL_OW 251
47470: PPUSH
47471: LD_VAR 0 2
47475: PPUSH
47476: CALL 21561 0 4
47480: PUSH
47481: LD_INT 4
47483: ARRAY
47484: ST_TO_ADDR
// end ;
47485: LD_VAR 0 3
47489: RET
// export function PlayerSeeMe ( unit ) ; begin
47490: LD_INT 0
47492: PPUSH
// result := See ( your_side , unit ) ;
47493: LD_ADDR_VAR 0 2
47497: PUSH
47498: LD_OWVAR 2
47502: PPUSH
47503: LD_VAR 0 1
47507: PPUSH
47508: CALL_OW 292
47512: ST_TO_ADDR
// end ;
47513: LD_VAR 0 2
47517: RET
// export function ReverseDir ( unit ) ; begin
47518: LD_INT 0
47520: PPUSH
// if not unit then
47521: LD_VAR 0 1
47525: NOT
47526: IFFALSE 47530
// exit ;
47528: GO 47576
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47530: LD_ADDR_VAR 0 2
47534: PUSH
47535: LD_INT 3
47537: PUSH
47538: LD_INT 4
47540: PUSH
47541: LD_INT 5
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: LD_INT 1
47549: PUSH
47550: LD_INT 2
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: LIST
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 1
47565: PPUSH
47566: CALL_OW 254
47570: PUSH
47571: LD_INT 1
47573: PLUS
47574: ARRAY
47575: ST_TO_ADDR
// end ;
47576: LD_VAR 0 2
47580: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47581: LD_INT 0
47583: PPUSH
47584: PPUSH
47585: PPUSH
47586: PPUSH
47587: PPUSH
// if not hexes then
47588: LD_VAR 0 2
47592: NOT
47593: IFFALSE 47597
// exit ;
47595: GO 47745
// dist := 9999 ;
47597: LD_ADDR_VAR 0 5
47601: PUSH
47602: LD_INT 9999
47604: ST_TO_ADDR
// for i = 1 to hexes do
47605: LD_ADDR_VAR 0 4
47609: PUSH
47610: DOUBLE
47611: LD_INT 1
47613: DEC
47614: ST_TO_ADDR
47615: LD_VAR 0 2
47619: PUSH
47620: FOR_TO
47621: IFFALSE 47733
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47623: LD_VAR 0 1
47627: PPUSH
47628: LD_VAR 0 2
47632: PUSH
47633: LD_VAR 0 4
47637: ARRAY
47638: PUSH
47639: LD_INT 1
47641: ARRAY
47642: PPUSH
47643: LD_VAR 0 2
47647: PUSH
47648: LD_VAR 0 4
47652: ARRAY
47653: PUSH
47654: LD_INT 2
47656: ARRAY
47657: PPUSH
47658: CALL_OW 297
47662: PUSH
47663: LD_VAR 0 5
47667: LESS
47668: IFFALSE 47731
// begin hex := hexes [ i ] ;
47670: LD_ADDR_VAR 0 7
47674: PUSH
47675: LD_VAR 0 2
47679: PUSH
47680: LD_VAR 0 4
47684: ARRAY
47685: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47686: LD_ADDR_VAR 0 5
47690: PUSH
47691: LD_VAR 0 1
47695: PPUSH
47696: LD_VAR 0 2
47700: PUSH
47701: LD_VAR 0 4
47705: ARRAY
47706: PUSH
47707: LD_INT 1
47709: ARRAY
47710: PPUSH
47711: LD_VAR 0 2
47715: PUSH
47716: LD_VAR 0 4
47720: ARRAY
47721: PUSH
47722: LD_INT 2
47724: ARRAY
47725: PPUSH
47726: CALL_OW 297
47730: ST_TO_ADDR
// end ; end ;
47731: GO 47620
47733: POP
47734: POP
// result := hex ;
47735: LD_ADDR_VAR 0 3
47739: PUSH
47740: LD_VAR 0 7
47744: ST_TO_ADDR
// end ;
47745: LD_VAR 0 3
47749: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47750: LD_INT 0
47752: PPUSH
47753: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47754: LD_VAR 0 1
47758: NOT
47759: PUSH
47760: LD_VAR 0 1
47764: PUSH
47765: LD_INT 21
47767: PUSH
47768: LD_INT 2
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: PUSH
47775: LD_INT 23
47777: PUSH
47778: LD_INT 2
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: EMPTY
47786: LIST
47787: LIST
47788: PPUSH
47789: CALL_OW 69
47793: IN
47794: NOT
47795: OR
47796: IFFALSE 47800
// exit ;
47798: GO 47847
// for i = 1 to 3 do
47800: LD_ADDR_VAR 0 3
47804: PUSH
47805: DOUBLE
47806: LD_INT 1
47808: DEC
47809: ST_TO_ADDR
47810: LD_INT 3
47812: PUSH
47813: FOR_TO
47814: IFFALSE 47845
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47816: LD_VAR 0 1
47820: PPUSH
47821: CALL_OW 250
47825: PPUSH
47826: LD_VAR 0 1
47830: PPUSH
47831: CALL_OW 251
47835: PPUSH
47836: LD_INT 1
47838: PPUSH
47839: CALL_OW 453
47843: GO 47813
47845: POP
47846: POP
// end ;
47847: LD_VAR 0 2
47851: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47852: LD_INT 0
47854: PPUSH
47855: PPUSH
47856: PPUSH
47857: PPUSH
47858: PPUSH
47859: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47860: LD_VAR 0 1
47864: NOT
47865: PUSH
47866: LD_VAR 0 2
47870: NOT
47871: OR
47872: PUSH
47873: LD_VAR 0 1
47877: PPUSH
47878: CALL_OW 314
47882: OR
47883: IFFALSE 47887
// exit ;
47885: GO 48328
// x := GetX ( enemy_unit ) ;
47887: LD_ADDR_VAR 0 7
47891: PUSH
47892: LD_VAR 0 2
47896: PPUSH
47897: CALL_OW 250
47901: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47902: LD_ADDR_VAR 0 8
47906: PUSH
47907: LD_VAR 0 2
47911: PPUSH
47912: CALL_OW 251
47916: ST_TO_ADDR
// if not x or not y then
47917: LD_VAR 0 7
47921: NOT
47922: PUSH
47923: LD_VAR 0 8
47927: NOT
47928: OR
47929: IFFALSE 47933
// exit ;
47931: GO 48328
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47933: LD_ADDR_VAR 0 6
47937: PUSH
47938: LD_VAR 0 7
47942: PPUSH
47943: LD_INT 0
47945: PPUSH
47946: LD_INT 4
47948: PPUSH
47949: CALL_OW 272
47953: PUSH
47954: LD_VAR 0 8
47958: PPUSH
47959: LD_INT 0
47961: PPUSH
47962: LD_INT 4
47964: PPUSH
47965: CALL_OW 273
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PUSH
47974: LD_VAR 0 7
47978: PPUSH
47979: LD_INT 1
47981: PPUSH
47982: LD_INT 4
47984: PPUSH
47985: CALL_OW 272
47989: PUSH
47990: LD_VAR 0 8
47994: PPUSH
47995: LD_INT 1
47997: PPUSH
47998: LD_INT 4
48000: PPUSH
48001: CALL_OW 273
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: PUSH
48010: LD_VAR 0 7
48014: PPUSH
48015: LD_INT 2
48017: PPUSH
48018: LD_INT 4
48020: PPUSH
48021: CALL_OW 272
48025: PUSH
48026: LD_VAR 0 8
48030: PPUSH
48031: LD_INT 2
48033: PPUSH
48034: LD_INT 4
48036: PPUSH
48037: CALL_OW 273
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: LD_VAR 0 7
48050: PPUSH
48051: LD_INT 3
48053: PPUSH
48054: LD_INT 4
48056: PPUSH
48057: CALL_OW 272
48061: PUSH
48062: LD_VAR 0 8
48066: PPUSH
48067: LD_INT 3
48069: PPUSH
48070: LD_INT 4
48072: PPUSH
48073: CALL_OW 273
48077: PUSH
48078: EMPTY
48079: LIST
48080: LIST
48081: PUSH
48082: LD_VAR 0 7
48086: PPUSH
48087: LD_INT 4
48089: PPUSH
48090: LD_INT 4
48092: PPUSH
48093: CALL_OW 272
48097: PUSH
48098: LD_VAR 0 8
48102: PPUSH
48103: LD_INT 4
48105: PPUSH
48106: LD_INT 4
48108: PPUSH
48109: CALL_OW 273
48113: PUSH
48114: EMPTY
48115: LIST
48116: LIST
48117: PUSH
48118: LD_VAR 0 7
48122: PPUSH
48123: LD_INT 5
48125: PPUSH
48126: LD_INT 4
48128: PPUSH
48129: CALL_OW 272
48133: PUSH
48134: LD_VAR 0 8
48138: PPUSH
48139: LD_INT 5
48141: PPUSH
48142: LD_INT 4
48144: PPUSH
48145: CALL_OW 273
48149: PUSH
48150: EMPTY
48151: LIST
48152: LIST
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: ST_TO_ADDR
// for i = tmp downto 1 do
48162: LD_ADDR_VAR 0 4
48166: PUSH
48167: DOUBLE
48168: LD_VAR 0 6
48172: INC
48173: ST_TO_ADDR
48174: LD_INT 1
48176: PUSH
48177: FOR_DOWNTO
48178: IFFALSE 48279
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48180: LD_VAR 0 6
48184: PUSH
48185: LD_VAR 0 4
48189: ARRAY
48190: PUSH
48191: LD_INT 1
48193: ARRAY
48194: PPUSH
48195: LD_VAR 0 6
48199: PUSH
48200: LD_VAR 0 4
48204: ARRAY
48205: PUSH
48206: LD_INT 2
48208: ARRAY
48209: PPUSH
48210: CALL_OW 488
48214: NOT
48215: PUSH
48216: LD_VAR 0 6
48220: PUSH
48221: LD_VAR 0 4
48225: ARRAY
48226: PUSH
48227: LD_INT 1
48229: ARRAY
48230: PPUSH
48231: LD_VAR 0 6
48235: PUSH
48236: LD_VAR 0 4
48240: ARRAY
48241: PUSH
48242: LD_INT 2
48244: ARRAY
48245: PPUSH
48246: CALL_OW 428
48250: PUSH
48251: LD_INT 0
48253: NONEQUAL
48254: OR
48255: IFFALSE 48277
// tmp := Delete ( tmp , i ) ;
48257: LD_ADDR_VAR 0 6
48261: PUSH
48262: LD_VAR 0 6
48266: PPUSH
48267: LD_VAR 0 4
48271: PPUSH
48272: CALL_OW 3
48276: ST_TO_ADDR
48277: GO 48177
48279: POP
48280: POP
// j := GetClosestHex ( unit , tmp ) ;
48281: LD_ADDR_VAR 0 5
48285: PUSH
48286: LD_VAR 0 1
48290: PPUSH
48291: LD_VAR 0 6
48295: PPUSH
48296: CALL 47581 0 2
48300: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48301: LD_VAR 0 1
48305: PPUSH
48306: LD_VAR 0 5
48310: PUSH
48311: LD_INT 1
48313: ARRAY
48314: PPUSH
48315: LD_VAR 0 5
48319: PUSH
48320: LD_INT 2
48322: ARRAY
48323: PPUSH
48324: CALL_OW 111
// end ;
48328: LD_VAR 0 3
48332: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48333: LD_INT 0
48335: PPUSH
48336: PPUSH
48337: PPUSH
// uc_side = 0 ;
48338: LD_ADDR_OWVAR 20
48342: PUSH
48343: LD_INT 0
48345: ST_TO_ADDR
// uc_nation = 0 ;
48346: LD_ADDR_OWVAR 21
48350: PUSH
48351: LD_INT 0
48353: ST_TO_ADDR
// InitHc ;
48354: CALL_OW 19
// InitVc ;
48358: CALL_OW 20
// if mastodonts then
48362: LD_VAR 0 6
48366: IFFALSE 48433
// for i = 1 to mastodonts do
48368: LD_ADDR_VAR 0 11
48372: PUSH
48373: DOUBLE
48374: LD_INT 1
48376: DEC
48377: ST_TO_ADDR
48378: LD_VAR 0 6
48382: PUSH
48383: FOR_TO
48384: IFFALSE 48431
// begin vc_chassis := 31 ;
48386: LD_ADDR_OWVAR 37
48390: PUSH
48391: LD_INT 31
48393: ST_TO_ADDR
// vc_control := control_rider ;
48394: LD_ADDR_OWVAR 38
48398: PUSH
48399: LD_INT 4
48401: ST_TO_ADDR
// animal := CreateVehicle ;
48402: LD_ADDR_VAR 0 12
48406: PUSH
48407: CALL_OW 45
48411: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48412: LD_VAR 0 12
48416: PPUSH
48417: LD_VAR 0 8
48421: PPUSH
48422: LD_INT 0
48424: PPUSH
48425: CALL 55139 0 3
// end ;
48429: GO 48383
48431: POP
48432: POP
// if horses then
48433: LD_VAR 0 5
48437: IFFALSE 48504
// for i = 1 to horses do
48439: LD_ADDR_VAR 0 11
48443: PUSH
48444: DOUBLE
48445: LD_INT 1
48447: DEC
48448: ST_TO_ADDR
48449: LD_VAR 0 5
48453: PUSH
48454: FOR_TO
48455: IFFALSE 48502
// begin hc_class := 21 ;
48457: LD_ADDR_OWVAR 28
48461: PUSH
48462: LD_INT 21
48464: ST_TO_ADDR
// hc_gallery :=  ;
48465: LD_ADDR_OWVAR 33
48469: PUSH
48470: LD_STRING 
48472: ST_TO_ADDR
// animal := CreateHuman ;
48473: LD_ADDR_VAR 0 12
48477: PUSH
48478: CALL_OW 44
48482: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48483: LD_VAR 0 12
48487: PPUSH
48488: LD_VAR 0 8
48492: PPUSH
48493: LD_INT 0
48495: PPUSH
48496: CALL 55139 0 3
// end ;
48500: GO 48454
48502: POP
48503: POP
// if birds then
48504: LD_VAR 0 1
48508: IFFALSE 48575
// for i = 1 to birds do
48510: LD_ADDR_VAR 0 11
48514: PUSH
48515: DOUBLE
48516: LD_INT 1
48518: DEC
48519: ST_TO_ADDR
48520: LD_VAR 0 1
48524: PUSH
48525: FOR_TO
48526: IFFALSE 48573
// begin hc_class = 18 ;
48528: LD_ADDR_OWVAR 28
48532: PUSH
48533: LD_INT 18
48535: ST_TO_ADDR
// hc_gallery =  ;
48536: LD_ADDR_OWVAR 33
48540: PUSH
48541: LD_STRING 
48543: ST_TO_ADDR
// animal := CreateHuman ;
48544: LD_ADDR_VAR 0 12
48548: PUSH
48549: CALL_OW 44
48553: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48554: LD_VAR 0 12
48558: PPUSH
48559: LD_VAR 0 8
48563: PPUSH
48564: LD_INT 0
48566: PPUSH
48567: CALL 55139 0 3
// end ;
48571: GO 48525
48573: POP
48574: POP
// if tigers then
48575: LD_VAR 0 2
48579: IFFALSE 48663
// for i = 1 to tigers do
48581: LD_ADDR_VAR 0 11
48585: PUSH
48586: DOUBLE
48587: LD_INT 1
48589: DEC
48590: ST_TO_ADDR
48591: LD_VAR 0 2
48595: PUSH
48596: FOR_TO
48597: IFFALSE 48661
// begin hc_class = class_tiger ;
48599: LD_ADDR_OWVAR 28
48603: PUSH
48604: LD_INT 14
48606: ST_TO_ADDR
// hc_gallery =  ;
48607: LD_ADDR_OWVAR 33
48611: PUSH
48612: LD_STRING 
48614: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48615: LD_ADDR_OWVAR 35
48619: PUSH
48620: LD_INT 7
48622: NEG
48623: PPUSH
48624: LD_INT 7
48626: PPUSH
48627: CALL_OW 12
48631: ST_TO_ADDR
// animal := CreateHuman ;
48632: LD_ADDR_VAR 0 12
48636: PUSH
48637: CALL_OW 44
48641: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48642: LD_VAR 0 12
48646: PPUSH
48647: LD_VAR 0 8
48651: PPUSH
48652: LD_INT 0
48654: PPUSH
48655: CALL 55139 0 3
// end ;
48659: GO 48596
48661: POP
48662: POP
// if apemans then
48663: LD_VAR 0 3
48667: IFFALSE 48790
// for i = 1 to apemans do
48669: LD_ADDR_VAR 0 11
48673: PUSH
48674: DOUBLE
48675: LD_INT 1
48677: DEC
48678: ST_TO_ADDR
48679: LD_VAR 0 3
48683: PUSH
48684: FOR_TO
48685: IFFALSE 48788
// begin hc_class = class_apeman ;
48687: LD_ADDR_OWVAR 28
48691: PUSH
48692: LD_INT 12
48694: ST_TO_ADDR
// hc_gallery =  ;
48695: LD_ADDR_OWVAR 33
48699: PUSH
48700: LD_STRING 
48702: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48703: LD_ADDR_OWVAR 35
48707: PUSH
48708: LD_INT 5
48710: NEG
48711: PPUSH
48712: LD_INT 5
48714: PPUSH
48715: CALL_OW 12
48719: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48720: LD_ADDR_OWVAR 31
48724: PUSH
48725: LD_INT 1
48727: PPUSH
48728: LD_INT 3
48730: PPUSH
48731: CALL_OW 12
48735: PUSH
48736: LD_INT 1
48738: PPUSH
48739: LD_INT 3
48741: PPUSH
48742: CALL_OW 12
48746: PUSH
48747: LD_INT 0
48749: PUSH
48750: LD_INT 0
48752: PUSH
48753: EMPTY
48754: LIST
48755: LIST
48756: LIST
48757: LIST
48758: ST_TO_ADDR
// animal := CreateHuman ;
48759: LD_ADDR_VAR 0 12
48763: PUSH
48764: CALL_OW 44
48768: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48769: LD_VAR 0 12
48773: PPUSH
48774: LD_VAR 0 8
48778: PPUSH
48779: LD_INT 0
48781: PPUSH
48782: CALL 55139 0 3
// end ;
48786: GO 48684
48788: POP
48789: POP
// if enchidnas then
48790: LD_VAR 0 4
48794: IFFALSE 48861
// for i = 1 to enchidnas do
48796: LD_ADDR_VAR 0 11
48800: PUSH
48801: DOUBLE
48802: LD_INT 1
48804: DEC
48805: ST_TO_ADDR
48806: LD_VAR 0 4
48810: PUSH
48811: FOR_TO
48812: IFFALSE 48859
// begin hc_class = 13 ;
48814: LD_ADDR_OWVAR 28
48818: PUSH
48819: LD_INT 13
48821: ST_TO_ADDR
// hc_gallery =  ;
48822: LD_ADDR_OWVAR 33
48826: PUSH
48827: LD_STRING 
48829: ST_TO_ADDR
// animal := CreateHuman ;
48830: LD_ADDR_VAR 0 12
48834: PUSH
48835: CALL_OW 44
48839: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48840: LD_VAR 0 12
48844: PPUSH
48845: LD_VAR 0 8
48849: PPUSH
48850: LD_INT 0
48852: PPUSH
48853: CALL 55139 0 3
// end ;
48857: GO 48811
48859: POP
48860: POP
// if fishes then
48861: LD_VAR 0 7
48865: IFFALSE 48932
// for i = 1 to fishes do
48867: LD_ADDR_VAR 0 11
48871: PUSH
48872: DOUBLE
48873: LD_INT 1
48875: DEC
48876: ST_TO_ADDR
48877: LD_VAR 0 7
48881: PUSH
48882: FOR_TO
48883: IFFALSE 48930
// begin hc_class = 20 ;
48885: LD_ADDR_OWVAR 28
48889: PUSH
48890: LD_INT 20
48892: ST_TO_ADDR
// hc_gallery =  ;
48893: LD_ADDR_OWVAR 33
48897: PUSH
48898: LD_STRING 
48900: ST_TO_ADDR
// animal := CreateHuman ;
48901: LD_ADDR_VAR 0 12
48905: PUSH
48906: CALL_OW 44
48910: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48911: LD_VAR 0 12
48915: PPUSH
48916: LD_VAR 0 9
48920: PPUSH
48921: LD_INT 0
48923: PPUSH
48924: CALL 55139 0 3
// end ;
48928: GO 48882
48930: POP
48931: POP
// end ;
48932: LD_VAR 0 10
48936: RET
// export function WantHeal ( sci , unit ) ; begin
48937: LD_INT 0
48939: PPUSH
// if GetTaskList ( sci ) > 0 then
48940: LD_VAR 0 1
48944: PPUSH
48945: CALL_OW 437
48949: PUSH
48950: LD_INT 0
48952: GREATER
48953: IFFALSE 49023
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48955: LD_VAR 0 1
48959: PPUSH
48960: CALL_OW 437
48964: PUSH
48965: LD_INT 1
48967: ARRAY
48968: PUSH
48969: LD_INT 1
48971: ARRAY
48972: PUSH
48973: LD_STRING l
48975: EQUAL
48976: PUSH
48977: LD_VAR 0 1
48981: PPUSH
48982: CALL_OW 437
48986: PUSH
48987: LD_INT 1
48989: ARRAY
48990: PUSH
48991: LD_INT 4
48993: ARRAY
48994: PUSH
48995: LD_VAR 0 2
48999: EQUAL
49000: AND
49001: IFFALSE 49013
// result := true else
49003: LD_ADDR_VAR 0 3
49007: PUSH
49008: LD_INT 1
49010: ST_TO_ADDR
49011: GO 49021
// result := false ;
49013: LD_ADDR_VAR 0 3
49017: PUSH
49018: LD_INT 0
49020: ST_TO_ADDR
// end else
49021: GO 49031
// result := false ;
49023: LD_ADDR_VAR 0 3
49027: PUSH
49028: LD_INT 0
49030: ST_TO_ADDR
// end ;
49031: LD_VAR 0 3
49035: RET
// export function HealTarget ( sci ) ; begin
49036: LD_INT 0
49038: PPUSH
// if not sci then
49039: LD_VAR 0 1
49043: NOT
49044: IFFALSE 49048
// exit ;
49046: GO 49113
// result := 0 ;
49048: LD_ADDR_VAR 0 2
49052: PUSH
49053: LD_INT 0
49055: ST_TO_ADDR
// if GetTaskList ( sci ) then
49056: LD_VAR 0 1
49060: PPUSH
49061: CALL_OW 437
49065: IFFALSE 49113
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49067: LD_VAR 0 1
49071: PPUSH
49072: CALL_OW 437
49076: PUSH
49077: LD_INT 1
49079: ARRAY
49080: PUSH
49081: LD_INT 1
49083: ARRAY
49084: PUSH
49085: LD_STRING l
49087: EQUAL
49088: IFFALSE 49113
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49090: LD_ADDR_VAR 0 2
49094: PUSH
49095: LD_VAR 0 1
49099: PPUSH
49100: CALL_OW 437
49104: PUSH
49105: LD_INT 1
49107: ARRAY
49108: PUSH
49109: LD_INT 4
49111: ARRAY
49112: ST_TO_ADDR
// end ;
49113: LD_VAR 0 2
49117: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
49118: LD_INT 0
49120: PPUSH
49121: PPUSH
49122: PPUSH
49123: PPUSH
49124: PPUSH
49125: PPUSH
49126: PPUSH
49127: PPUSH
49128: PPUSH
49129: PPUSH
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
49150: PPUSH
49151: PPUSH
49152: PPUSH
// if not list then
49153: LD_VAR 0 1
49157: NOT
49158: IFFALSE 49162
// exit ;
49160: GO 53750
// base := list [ 1 ] ;
49162: LD_ADDR_VAR 0 3
49166: PUSH
49167: LD_VAR 0 1
49171: PUSH
49172: LD_INT 1
49174: ARRAY
49175: ST_TO_ADDR
// group := list [ 2 ] ;
49176: LD_ADDR_VAR 0 4
49180: PUSH
49181: LD_VAR 0 1
49185: PUSH
49186: LD_INT 2
49188: ARRAY
49189: ST_TO_ADDR
// path := list [ 3 ] ;
49190: LD_ADDR_VAR 0 5
49194: PUSH
49195: LD_VAR 0 1
49199: PUSH
49200: LD_INT 3
49202: ARRAY
49203: ST_TO_ADDR
// flags := list [ 4 ] ;
49204: LD_ADDR_VAR 0 6
49208: PUSH
49209: LD_VAR 0 1
49213: PUSH
49214: LD_INT 4
49216: ARRAY
49217: ST_TO_ADDR
// mined := [ ] ;
49218: LD_ADDR_VAR 0 27
49222: PUSH
49223: EMPTY
49224: ST_TO_ADDR
// bombed := [ ] ;
49225: LD_ADDR_VAR 0 28
49229: PUSH
49230: EMPTY
49231: ST_TO_ADDR
// healers := [ ] ;
49232: LD_ADDR_VAR 0 31
49236: PUSH
49237: EMPTY
49238: ST_TO_ADDR
// to_heal := [ ] ;
49239: LD_ADDR_VAR 0 30
49243: PUSH
49244: EMPTY
49245: ST_TO_ADDR
// repairs := [ ] ;
49246: LD_ADDR_VAR 0 33
49250: PUSH
49251: EMPTY
49252: ST_TO_ADDR
// to_repair := [ ] ;
49253: LD_ADDR_VAR 0 32
49257: PUSH
49258: EMPTY
49259: ST_TO_ADDR
// if not group or not path then
49260: LD_VAR 0 4
49264: NOT
49265: PUSH
49266: LD_VAR 0 5
49270: NOT
49271: OR
49272: IFFALSE 49276
// exit ;
49274: GO 53750
// if flags then
49276: LD_VAR 0 6
49280: IFFALSE 49424
// begin f_ignore_area := flags [ 1 ] ;
49282: LD_ADDR_VAR 0 17
49286: PUSH
49287: LD_VAR 0 6
49291: PUSH
49292: LD_INT 1
49294: ARRAY
49295: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49296: LD_ADDR_VAR 0 18
49300: PUSH
49301: LD_VAR 0 6
49305: PUSH
49306: LD_INT 2
49308: ARRAY
49309: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49310: LD_ADDR_VAR 0 19
49314: PUSH
49315: LD_VAR 0 6
49319: PUSH
49320: LD_INT 3
49322: ARRAY
49323: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49324: LD_ADDR_VAR 0 20
49328: PUSH
49329: LD_VAR 0 6
49333: PUSH
49334: LD_INT 4
49336: ARRAY
49337: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49338: LD_ADDR_VAR 0 21
49342: PUSH
49343: LD_VAR 0 6
49347: PUSH
49348: LD_INT 5
49350: ARRAY
49351: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49352: LD_ADDR_VAR 0 22
49356: PUSH
49357: LD_VAR 0 6
49361: PUSH
49362: LD_INT 6
49364: ARRAY
49365: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49366: LD_ADDR_VAR 0 23
49370: PUSH
49371: LD_VAR 0 6
49375: PUSH
49376: LD_INT 7
49378: ARRAY
49379: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49380: LD_ADDR_VAR 0 24
49384: PUSH
49385: LD_VAR 0 6
49389: PUSH
49390: LD_INT 8
49392: ARRAY
49393: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49394: LD_ADDR_VAR 0 25
49398: PUSH
49399: LD_VAR 0 6
49403: PUSH
49404: LD_INT 9
49406: ARRAY
49407: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49408: LD_ADDR_VAR 0 26
49412: PUSH
49413: LD_VAR 0 6
49417: PUSH
49418: LD_INT 10
49420: ARRAY
49421: ST_TO_ADDR
// end else
49422: GO 49504
// begin f_ignore_area := false ;
49424: LD_ADDR_VAR 0 17
49428: PUSH
49429: LD_INT 0
49431: ST_TO_ADDR
// f_capture := false ;
49432: LD_ADDR_VAR 0 18
49436: PUSH
49437: LD_INT 0
49439: ST_TO_ADDR
// f_ignore_civ := false ;
49440: LD_ADDR_VAR 0 19
49444: PUSH
49445: LD_INT 0
49447: ST_TO_ADDR
// f_murder := false ;
49448: LD_ADDR_VAR 0 20
49452: PUSH
49453: LD_INT 0
49455: ST_TO_ADDR
// f_mines := false ;
49456: LD_ADDR_VAR 0 21
49460: PUSH
49461: LD_INT 0
49463: ST_TO_ADDR
// f_repair := false ;
49464: LD_ADDR_VAR 0 22
49468: PUSH
49469: LD_INT 0
49471: ST_TO_ADDR
// f_heal := false ;
49472: LD_ADDR_VAR 0 23
49476: PUSH
49477: LD_INT 0
49479: ST_TO_ADDR
// f_spacetime := false ;
49480: LD_ADDR_VAR 0 24
49484: PUSH
49485: LD_INT 0
49487: ST_TO_ADDR
// f_attack_depot := false ;
49488: LD_ADDR_VAR 0 25
49492: PUSH
49493: LD_INT 0
49495: ST_TO_ADDR
// f_crawl := false ;
49496: LD_ADDR_VAR 0 26
49500: PUSH
49501: LD_INT 0
49503: ST_TO_ADDR
// end ; if f_heal then
49504: LD_VAR 0 23
49508: IFFALSE 49535
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49510: LD_ADDR_VAR 0 31
49514: PUSH
49515: LD_VAR 0 4
49519: PPUSH
49520: LD_INT 25
49522: PUSH
49523: LD_INT 4
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PPUSH
49530: CALL_OW 72
49534: ST_TO_ADDR
// if f_repair then
49535: LD_VAR 0 22
49539: IFFALSE 49566
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49541: LD_ADDR_VAR 0 33
49545: PUSH
49546: LD_VAR 0 4
49550: PPUSH
49551: LD_INT 25
49553: PUSH
49554: LD_INT 3
49556: PUSH
49557: EMPTY
49558: LIST
49559: LIST
49560: PPUSH
49561: CALL_OW 72
49565: ST_TO_ADDR
// units_path := [ ] ;
49566: LD_ADDR_VAR 0 16
49570: PUSH
49571: EMPTY
49572: ST_TO_ADDR
// for i = 1 to group do
49573: LD_ADDR_VAR 0 7
49577: PUSH
49578: DOUBLE
49579: LD_INT 1
49581: DEC
49582: ST_TO_ADDR
49583: LD_VAR 0 4
49587: PUSH
49588: FOR_TO
49589: IFFALSE 49618
// units_path := Replace ( units_path , i , path ) ;
49591: LD_ADDR_VAR 0 16
49595: PUSH
49596: LD_VAR 0 16
49600: PPUSH
49601: LD_VAR 0 7
49605: PPUSH
49606: LD_VAR 0 5
49610: PPUSH
49611: CALL_OW 1
49615: ST_TO_ADDR
49616: GO 49588
49618: POP
49619: POP
// repeat for i = group downto 1 do
49620: LD_ADDR_VAR 0 7
49624: PUSH
49625: DOUBLE
49626: LD_VAR 0 4
49630: INC
49631: ST_TO_ADDR
49632: LD_INT 1
49634: PUSH
49635: FOR_DOWNTO
49636: IFFALSE 53732
// begin wait ( 5 ) ;
49638: LD_INT 5
49640: PPUSH
49641: CALL_OW 67
// tmp := [ ] ;
49645: LD_ADDR_VAR 0 14
49649: PUSH
49650: EMPTY
49651: ST_TO_ADDR
// attacking := false ;
49652: LD_ADDR_VAR 0 29
49656: PUSH
49657: LD_INT 0
49659: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49660: LD_VAR 0 4
49664: PUSH
49665: LD_VAR 0 7
49669: ARRAY
49670: PPUSH
49671: CALL_OW 301
49675: PUSH
49676: LD_VAR 0 4
49680: PUSH
49681: LD_VAR 0 7
49685: ARRAY
49686: NOT
49687: OR
49688: IFFALSE 49797
// begin if GetType ( group [ i ] ) = unit_human then
49690: LD_VAR 0 4
49694: PUSH
49695: LD_VAR 0 7
49699: ARRAY
49700: PPUSH
49701: CALL_OW 247
49705: PUSH
49706: LD_INT 1
49708: EQUAL
49709: IFFALSE 49755
// begin to_heal := to_heal diff group [ i ] ;
49711: LD_ADDR_VAR 0 30
49715: PUSH
49716: LD_VAR 0 30
49720: PUSH
49721: LD_VAR 0 4
49725: PUSH
49726: LD_VAR 0 7
49730: ARRAY
49731: DIFF
49732: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49733: LD_ADDR_VAR 0 31
49737: PUSH
49738: LD_VAR 0 31
49742: PUSH
49743: LD_VAR 0 4
49747: PUSH
49748: LD_VAR 0 7
49752: ARRAY
49753: DIFF
49754: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49755: LD_ADDR_VAR 0 4
49759: PUSH
49760: LD_VAR 0 4
49764: PPUSH
49765: LD_VAR 0 7
49769: PPUSH
49770: CALL_OW 3
49774: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49775: LD_ADDR_VAR 0 16
49779: PUSH
49780: LD_VAR 0 16
49784: PPUSH
49785: LD_VAR 0 7
49789: PPUSH
49790: CALL_OW 3
49794: ST_TO_ADDR
// continue ;
49795: GO 49635
// end ; if f_repair then
49797: LD_VAR 0 22
49801: IFFALSE 50290
// begin if GetType ( group [ i ] ) = unit_vehicle then
49803: LD_VAR 0 4
49807: PUSH
49808: LD_VAR 0 7
49812: ARRAY
49813: PPUSH
49814: CALL_OW 247
49818: PUSH
49819: LD_INT 2
49821: EQUAL
49822: IFFALSE 50012
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49824: LD_VAR 0 4
49828: PUSH
49829: LD_VAR 0 7
49833: ARRAY
49834: PPUSH
49835: CALL_OW 256
49839: PUSH
49840: LD_INT 700
49842: LESS
49843: PUSH
49844: LD_VAR 0 4
49848: PUSH
49849: LD_VAR 0 7
49853: ARRAY
49854: PUSH
49855: LD_VAR 0 32
49859: IN
49860: NOT
49861: AND
49862: IFFALSE 49886
// to_repair := to_repair union group [ i ] ;
49864: LD_ADDR_VAR 0 32
49868: PUSH
49869: LD_VAR 0 32
49873: PUSH
49874: LD_VAR 0 4
49878: PUSH
49879: LD_VAR 0 7
49883: ARRAY
49884: UNION
49885: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49886: LD_VAR 0 4
49890: PUSH
49891: LD_VAR 0 7
49895: ARRAY
49896: PPUSH
49897: CALL_OW 256
49901: PUSH
49902: LD_INT 1000
49904: EQUAL
49905: PUSH
49906: LD_VAR 0 4
49910: PUSH
49911: LD_VAR 0 7
49915: ARRAY
49916: PUSH
49917: LD_VAR 0 32
49921: IN
49922: AND
49923: IFFALSE 49947
// to_repair := to_repair diff group [ i ] ;
49925: LD_ADDR_VAR 0 32
49929: PUSH
49930: LD_VAR 0 32
49934: PUSH
49935: LD_VAR 0 4
49939: PUSH
49940: LD_VAR 0 7
49944: ARRAY
49945: DIFF
49946: ST_TO_ADDR
// if group [ i ] in to_repair then
49947: LD_VAR 0 4
49951: PUSH
49952: LD_VAR 0 7
49956: ARRAY
49957: PUSH
49958: LD_VAR 0 32
49962: IN
49963: IFFALSE 50010
// begin if not IsInArea ( group [ i ] , f_repair ) then
49965: LD_VAR 0 4
49969: PUSH
49970: LD_VAR 0 7
49974: ARRAY
49975: PPUSH
49976: LD_VAR 0 22
49980: PPUSH
49981: CALL_OW 308
49985: NOT
49986: IFFALSE 50008
// ComMoveToArea ( group [ i ] , f_repair ) ;
49988: LD_VAR 0 4
49992: PUSH
49993: LD_VAR 0 7
49997: ARRAY
49998: PPUSH
49999: LD_VAR 0 22
50003: PPUSH
50004: CALL_OW 113
// continue ;
50008: GO 49635
// end ; end else
50010: GO 50290
// if group [ i ] in repairs then
50012: LD_VAR 0 4
50016: PUSH
50017: LD_VAR 0 7
50021: ARRAY
50022: PUSH
50023: LD_VAR 0 33
50027: IN
50028: IFFALSE 50290
// begin if IsInUnit ( group [ i ] ) then
50030: LD_VAR 0 4
50034: PUSH
50035: LD_VAR 0 7
50039: ARRAY
50040: PPUSH
50041: CALL_OW 310
50045: IFFALSE 50113
// begin z := IsInUnit ( group [ i ] ) ;
50047: LD_ADDR_VAR 0 13
50051: PUSH
50052: LD_VAR 0 4
50056: PUSH
50057: LD_VAR 0 7
50061: ARRAY
50062: PPUSH
50063: CALL_OW 310
50067: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50068: LD_VAR 0 13
50072: PUSH
50073: LD_VAR 0 32
50077: IN
50078: PUSH
50079: LD_VAR 0 13
50083: PPUSH
50084: LD_VAR 0 22
50088: PPUSH
50089: CALL_OW 308
50093: AND
50094: IFFALSE 50111
// ComExitVehicle ( group [ i ] ) ;
50096: LD_VAR 0 4
50100: PUSH
50101: LD_VAR 0 7
50105: ARRAY
50106: PPUSH
50107: CALL_OW 121
// end else
50111: GO 50290
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50113: LD_ADDR_VAR 0 13
50117: PUSH
50118: LD_VAR 0 4
50122: PPUSH
50123: LD_INT 95
50125: PUSH
50126: LD_VAR 0 22
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 58
50137: PUSH
50138: EMPTY
50139: LIST
50140: PUSH
50141: EMPTY
50142: LIST
50143: LIST
50144: PPUSH
50145: CALL_OW 72
50149: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50150: LD_VAR 0 4
50154: PUSH
50155: LD_VAR 0 7
50159: ARRAY
50160: PPUSH
50161: CALL_OW 314
50165: NOT
50166: IFFALSE 50288
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50168: LD_ADDR_VAR 0 10
50172: PUSH
50173: LD_VAR 0 13
50177: PPUSH
50178: LD_VAR 0 4
50182: PUSH
50183: LD_VAR 0 7
50187: ARRAY
50188: PPUSH
50189: CALL_OW 74
50193: ST_TO_ADDR
// if not x then
50194: LD_VAR 0 10
50198: NOT
50199: IFFALSE 50203
// continue ;
50201: GO 49635
// if GetLives ( x ) < 1000 then
50203: LD_VAR 0 10
50207: PPUSH
50208: CALL_OW 256
50212: PUSH
50213: LD_INT 1000
50215: LESS
50216: IFFALSE 50240
// ComRepairVehicle ( group [ i ] , x ) else
50218: LD_VAR 0 4
50222: PUSH
50223: LD_VAR 0 7
50227: ARRAY
50228: PPUSH
50229: LD_VAR 0 10
50233: PPUSH
50234: CALL_OW 129
50238: GO 50288
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50240: LD_VAR 0 23
50244: PUSH
50245: LD_VAR 0 4
50249: PUSH
50250: LD_VAR 0 7
50254: ARRAY
50255: PPUSH
50256: CALL_OW 256
50260: PUSH
50261: LD_INT 1000
50263: LESS
50264: AND
50265: NOT
50266: IFFALSE 50288
// ComEnterUnit ( group [ i ] , x ) ;
50268: LD_VAR 0 4
50272: PUSH
50273: LD_VAR 0 7
50277: ARRAY
50278: PPUSH
50279: LD_VAR 0 10
50283: PPUSH
50284: CALL_OW 120
// end ; continue ;
50288: GO 49635
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50290: LD_VAR 0 23
50294: PUSH
50295: LD_VAR 0 4
50299: PUSH
50300: LD_VAR 0 7
50304: ARRAY
50305: PPUSH
50306: CALL_OW 247
50310: PUSH
50311: LD_INT 1
50313: EQUAL
50314: AND
50315: IFFALSE 50793
// begin if group [ i ] in healers then
50317: LD_VAR 0 4
50321: PUSH
50322: LD_VAR 0 7
50326: ARRAY
50327: PUSH
50328: LD_VAR 0 31
50332: IN
50333: IFFALSE 50606
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50335: LD_VAR 0 4
50339: PUSH
50340: LD_VAR 0 7
50344: ARRAY
50345: PPUSH
50346: LD_VAR 0 23
50350: PPUSH
50351: CALL_OW 308
50355: NOT
50356: PUSH
50357: LD_VAR 0 4
50361: PUSH
50362: LD_VAR 0 7
50366: ARRAY
50367: PPUSH
50368: CALL_OW 314
50372: NOT
50373: AND
50374: IFFALSE 50398
// ComMoveToArea ( group [ i ] , f_heal ) else
50376: LD_VAR 0 4
50380: PUSH
50381: LD_VAR 0 7
50385: ARRAY
50386: PPUSH
50387: LD_VAR 0 23
50391: PPUSH
50392: CALL_OW 113
50396: GO 50604
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50398: LD_VAR 0 4
50402: PUSH
50403: LD_VAR 0 7
50407: ARRAY
50408: PPUSH
50409: CALL 49036 0 1
50413: PPUSH
50414: CALL_OW 256
50418: PUSH
50419: LD_INT 1000
50421: EQUAL
50422: IFFALSE 50441
// ComStop ( group [ i ] ) else
50424: LD_VAR 0 4
50428: PUSH
50429: LD_VAR 0 7
50433: ARRAY
50434: PPUSH
50435: CALL_OW 141
50439: GO 50604
// if not HasTask ( group [ i ] ) and to_heal then
50441: LD_VAR 0 4
50445: PUSH
50446: LD_VAR 0 7
50450: ARRAY
50451: PPUSH
50452: CALL_OW 314
50456: NOT
50457: PUSH
50458: LD_VAR 0 30
50462: AND
50463: IFFALSE 50604
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50465: LD_ADDR_VAR 0 13
50469: PUSH
50470: LD_VAR 0 30
50474: PPUSH
50475: LD_INT 3
50477: PUSH
50478: LD_INT 54
50480: PUSH
50481: EMPTY
50482: LIST
50483: PUSH
50484: EMPTY
50485: LIST
50486: LIST
50487: PPUSH
50488: CALL_OW 72
50492: PPUSH
50493: LD_VAR 0 4
50497: PUSH
50498: LD_VAR 0 7
50502: ARRAY
50503: PPUSH
50504: CALL_OW 74
50508: ST_TO_ADDR
// if z then
50509: LD_VAR 0 13
50513: IFFALSE 50604
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50515: LD_INT 91
50517: PUSH
50518: LD_VAR 0 13
50522: PUSH
50523: LD_INT 10
50525: PUSH
50526: EMPTY
50527: LIST
50528: LIST
50529: LIST
50530: PUSH
50531: LD_INT 81
50533: PUSH
50534: LD_VAR 0 13
50538: PPUSH
50539: CALL_OW 255
50543: PUSH
50544: EMPTY
50545: LIST
50546: LIST
50547: PUSH
50548: EMPTY
50549: LIST
50550: LIST
50551: PPUSH
50552: CALL_OW 69
50556: PUSH
50557: LD_INT 0
50559: EQUAL
50560: IFFALSE 50584
// ComHeal ( group [ i ] , z ) else
50562: LD_VAR 0 4
50566: PUSH
50567: LD_VAR 0 7
50571: ARRAY
50572: PPUSH
50573: LD_VAR 0 13
50577: PPUSH
50578: CALL_OW 128
50582: GO 50604
// ComMoveToArea ( group [ i ] , f_heal ) ;
50584: LD_VAR 0 4
50588: PUSH
50589: LD_VAR 0 7
50593: ARRAY
50594: PPUSH
50595: LD_VAR 0 23
50599: PPUSH
50600: CALL_OW 113
// end ; continue ;
50604: GO 49635
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50606: LD_VAR 0 4
50610: PUSH
50611: LD_VAR 0 7
50615: ARRAY
50616: PPUSH
50617: CALL_OW 256
50621: PUSH
50622: LD_INT 700
50624: LESS
50625: PUSH
50626: LD_VAR 0 4
50630: PUSH
50631: LD_VAR 0 7
50635: ARRAY
50636: PUSH
50637: LD_VAR 0 30
50641: IN
50642: NOT
50643: AND
50644: IFFALSE 50668
// to_heal := to_heal union group [ i ] ;
50646: LD_ADDR_VAR 0 30
50650: PUSH
50651: LD_VAR 0 30
50655: PUSH
50656: LD_VAR 0 4
50660: PUSH
50661: LD_VAR 0 7
50665: ARRAY
50666: UNION
50667: ST_TO_ADDR
// if group [ i ] in to_heal then
50668: LD_VAR 0 4
50672: PUSH
50673: LD_VAR 0 7
50677: ARRAY
50678: PUSH
50679: LD_VAR 0 30
50683: IN
50684: IFFALSE 50793
// begin if GetLives ( group [ i ] ) = 1000 then
50686: LD_VAR 0 4
50690: PUSH
50691: LD_VAR 0 7
50695: ARRAY
50696: PPUSH
50697: CALL_OW 256
50701: PUSH
50702: LD_INT 1000
50704: EQUAL
50705: IFFALSE 50731
// to_heal := to_heal diff group [ i ] else
50707: LD_ADDR_VAR 0 30
50711: PUSH
50712: LD_VAR 0 30
50716: PUSH
50717: LD_VAR 0 4
50721: PUSH
50722: LD_VAR 0 7
50726: ARRAY
50727: DIFF
50728: ST_TO_ADDR
50729: GO 50793
// begin if not IsInArea ( group [ i ] , to_heal ) then
50731: LD_VAR 0 4
50735: PUSH
50736: LD_VAR 0 7
50740: ARRAY
50741: PPUSH
50742: LD_VAR 0 30
50746: PPUSH
50747: CALL_OW 308
50751: NOT
50752: IFFALSE 50776
// ComMoveToArea ( group [ i ] , f_heal ) else
50754: LD_VAR 0 4
50758: PUSH
50759: LD_VAR 0 7
50763: ARRAY
50764: PPUSH
50765: LD_VAR 0 23
50769: PPUSH
50770: CALL_OW 113
50774: GO 50791
// ComHold ( group [ i ] ) ;
50776: LD_VAR 0 4
50780: PUSH
50781: LD_VAR 0 7
50785: ARRAY
50786: PPUSH
50787: CALL_OW 140
// continue ;
50791: GO 49635
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50793: LD_VAR 0 4
50797: PUSH
50798: LD_VAR 0 7
50802: ARRAY
50803: PPUSH
50804: LD_INT 10
50806: PPUSH
50807: CALL 47433 0 2
50811: NOT
50812: PUSH
50813: LD_VAR 0 16
50817: PUSH
50818: LD_VAR 0 7
50822: ARRAY
50823: PUSH
50824: EMPTY
50825: EQUAL
50826: NOT
50827: AND
50828: IFFALSE 51094
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50830: LD_VAR 0 4
50834: PUSH
50835: LD_VAR 0 7
50839: ARRAY
50840: PPUSH
50841: CALL_OW 262
50845: PUSH
50846: LD_INT 1
50848: PUSH
50849: LD_INT 2
50851: PUSH
50852: EMPTY
50853: LIST
50854: LIST
50855: IN
50856: IFFALSE 50897
// if GetFuel ( group [ i ] ) < 10 then
50858: LD_VAR 0 4
50862: PUSH
50863: LD_VAR 0 7
50867: ARRAY
50868: PPUSH
50869: CALL_OW 261
50873: PUSH
50874: LD_INT 10
50876: LESS
50877: IFFALSE 50897
// SetFuel ( group [ i ] , 12 ) ;
50879: LD_VAR 0 4
50883: PUSH
50884: LD_VAR 0 7
50888: ARRAY
50889: PPUSH
50890: LD_INT 12
50892: PPUSH
50893: CALL_OW 240
// if units_path [ i ] then
50897: LD_VAR 0 16
50901: PUSH
50902: LD_VAR 0 7
50906: ARRAY
50907: IFFALSE 51092
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50909: LD_VAR 0 4
50913: PUSH
50914: LD_VAR 0 7
50918: ARRAY
50919: PPUSH
50920: LD_VAR 0 16
50924: PUSH
50925: LD_VAR 0 7
50929: ARRAY
50930: PUSH
50931: LD_INT 1
50933: ARRAY
50934: PUSH
50935: LD_INT 1
50937: ARRAY
50938: PPUSH
50939: LD_VAR 0 16
50943: PUSH
50944: LD_VAR 0 7
50948: ARRAY
50949: PUSH
50950: LD_INT 1
50952: ARRAY
50953: PUSH
50954: LD_INT 2
50956: ARRAY
50957: PPUSH
50958: CALL_OW 297
50962: PUSH
50963: LD_INT 6
50965: GREATER
50966: IFFALSE 51041
// begin if not HasTask ( group [ i ] ) then
50968: LD_VAR 0 4
50972: PUSH
50973: LD_VAR 0 7
50977: ARRAY
50978: PPUSH
50979: CALL_OW 314
50983: NOT
50984: IFFALSE 51039
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50986: LD_VAR 0 4
50990: PUSH
50991: LD_VAR 0 7
50995: ARRAY
50996: PPUSH
50997: LD_VAR 0 16
51001: PUSH
51002: LD_VAR 0 7
51006: ARRAY
51007: PUSH
51008: LD_INT 1
51010: ARRAY
51011: PUSH
51012: LD_INT 1
51014: ARRAY
51015: PPUSH
51016: LD_VAR 0 16
51020: PUSH
51021: LD_VAR 0 7
51025: ARRAY
51026: PUSH
51027: LD_INT 1
51029: ARRAY
51030: PUSH
51031: LD_INT 2
51033: ARRAY
51034: PPUSH
51035: CALL_OW 114
// end else
51039: GO 51092
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51041: LD_ADDR_VAR 0 15
51045: PUSH
51046: LD_VAR 0 16
51050: PUSH
51051: LD_VAR 0 7
51055: ARRAY
51056: PPUSH
51057: LD_INT 1
51059: PPUSH
51060: CALL_OW 3
51064: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51065: LD_ADDR_VAR 0 16
51069: PUSH
51070: LD_VAR 0 16
51074: PPUSH
51075: LD_VAR 0 7
51079: PPUSH
51080: LD_VAR 0 15
51084: PPUSH
51085: CALL_OW 1
51089: ST_TO_ADDR
// continue ;
51090: GO 49635
// end ; end ; end else
51092: GO 53730
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51094: LD_ADDR_VAR 0 14
51098: PUSH
51099: LD_INT 81
51101: PUSH
51102: LD_VAR 0 4
51106: PUSH
51107: LD_VAR 0 7
51111: ARRAY
51112: PPUSH
51113: CALL_OW 255
51117: PUSH
51118: EMPTY
51119: LIST
51120: LIST
51121: PPUSH
51122: CALL_OW 69
51126: ST_TO_ADDR
// if not tmp then
51127: LD_VAR 0 14
51131: NOT
51132: IFFALSE 51136
// continue ;
51134: GO 49635
// if f_ignore_area then
51136: LD_VAR 0 17
51140: IFFALSE 51228
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51142: LD_ADDR_VAR 0 15
51146: PUSH
51147: LD_VAR 0 14
51151: PPUSH
51152: LD_INT 3
51154: PUSH
51155: LD_INT 92
51157: PUSH
51158: LD_VAR 0 17
51162: PUSH
51163: LD_INT 1
51165: ARRAY
51166: PUSH
51167: LD_VAR 0 17
51171: PUSH
51172: LD_INT 2
51174: ARRAY
51175: PUSH
51176: LD_VAR 0 17
51180: PUSH
51181: LD_INT 3
51183: ARRAY
51184: PUSH
51185: EMPTY
51186: LIST
51187: LIST
51188: LIST
51189: LIST
51190: PUSH
51191: EMPTY
51192: LIST
51193: LIST
51194: PPUSH
51195: CALL_OW 72
51199: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51200: LD_VAR 0 14
51204: PUSH
51205: LD_VAR 0 15
51209: DIFF
51210: IFFALSE 51228
// tmp := tmp diff tmp2 ;
51212: LD_ADDR_VAR 0 14
51216: PUSH
51217: LD_VAR 0 14
51221: PUSH
51222: LD_VAR 0 15
51226: DIFF
51227: ST_TO_ADDR
// end ; if not f_murder then
51228: LD_VAR 0 20
51232: NOT
51233: IFFALSE 51291
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51235: LD_ADDR_VAR 0 15
51239: PUSH
51240: LD_VAR 0 14
51244: PPUSH
51245: LD_INT 3
51247: PUSH
51248: LD_INT 50
51250: PUSH
51251: EMPTY
51252: LIST
51253: PUSH
51254: EMPTY
51255: LIST
51256: LIST
51257: PPUSH
51258: CALL_OW 72
51262: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51263: LD_VAR 0 14
51267: PUSH
51268: LD_VAR 0 15
51272: DIFF
51273: IFFALSE 51291
// tmp := tmp diff tmp2 ;
51275: LD_ADDR_VAR 0 14
51279: PUSH
51280: LD_VAR 0 14
51284: PUSH
51285: LD_VAR 0 15
51289: DIFF
51290: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51291: LD_ADDR_VAR 0 14
51295: PUSH
51296: LD_VAR 0 4
51300: PUSH
51301: LD_VAR 0 7
51305: ARRAY
51306: PPUSH
51307: LD_VAR 0 14
51311: PPUSH
51312: LD_INT 1
51314: PPUSH
51315: LD_INT 1
51317: PPUSH
51318: CALL 21100 0 4
51322: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51323: LD_VAR 0 4
51327: PUSH
51328: LD_VAR 0 7
51332: ARRAY
51333: PPUSH
51334: CALL_OW 257
51338: PUSH
51339: LD_INT 1
51341: EQUAL
51342: IFFALSE 51790
// begin if WantPlant ( group [ i ] ) then
51344: LD_VAR 0 4
51348: PUSH
51349: LD_VAR 0 7
51353: ARRAY
51354: PPUSH
51355: CALL 20601 0 1
51359: IFFALSE 51363
// continue ;
51361: GO 49635
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51363: LD_VAR 0 18
51367: PUSH
51368: LD_VAR 0 4
51372: PUSH
51373: LD_VAR 0 7
51377: ARRAY
51378: PPUSH
51379: CALL_OW 310
51383: NOT
51384: AND
51385: PUSH
51386: LD_VAR 0 14
51390: PUSH
51391: LD_INT 1
51393: ARRAY
51394: PUSH
51395: LD_VAR 0 14
51399: PPUSH
51400: LD_INT 21
51402: PUSH
51403: LD_INT 2
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 58
51412: PUSH
51413: EMPTY
51414: LIST
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PPUSH
51420: CALL_OW 72
51424: IN
51425: AND
51426: IFFALSE 51462
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51428: LD_VAR 0 4
51432: PUSH
51433: LD_VAR 0 7
51437: ARRAY
51438: PPUSH
51439: LD_VAR 0 14
51443: PUSH
51444: LD_INT 1
51446: ARRAY
51447: PPUSH
51448: CALL_OW 120
// attacking := true ;
51452: LD_ADDR_VAR 0 29
51456: PUSH
51457: LD_INT 1
51459: ST_TO_ADDR
// continue ;
51460: GO 49635
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51462: LD_VAR 0 26
51466: PUSH
51467: LD_VAR 0 4
51471: PUSH
51472: LD_VAR 0 7
51476: ARRAY
51477: PPUSH
51478: CALL_OW 257
51482: PUSH
51483: LD_INT 1
51485: EQUAL
51486: AND
51487: PUSH
51488: LD_VAR 0 4
51492: PUSH
51493: LD_VAR 0 7
51497: ARRAY
51498: PPUSH
51499: CALL_OW 256
51503: PUSH
51504: LD_INT 800
51506: LESS
51507: AND
51508: PUSH
51509: LD_VAR 0 4
51513: PUSH
51514: LD_VAR 0 7
51518: ARRAY
51519: PPUSH
51520: CALL_OW 318
51524: NOT
51525: AND
51526: IFFALSE 51543
// ComCrawl ( group [ i ] ) ;
51528: LD_VAR 0 4
51532: PUSH
51533: LD_VAR 0 7
51537: ARRAY
51538: PPUSH
51539: CALL_OW 137
// if f_mines then
51543: LD_VAR 0 21
51547: IFFALSE 51790
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51549: LD_VAR 0 14
51553: PUSH
51554: LD_INT 1
51556: ARRAY
51557: PPUSH
51558: CALL_OW 247
51562: PUSH
51563: LD_INT 3
51565: EQUAL
51566: PUSH
51567: LD_VAR 0 14
51571: PUSH
51572: LD_INT 1
51574: ARRAY
51575: PUSH
51576: LD_VAR 0 27
51580: IN
51581: NOT
51582: AND
51583: IFFALSE 51790
// begin x := GetX ( tmp [ 1 ] ) ;
51585: LD_ADDR_VAR 0 10
51589: PUSH
51590: LD_VAR 0 14
51594: PUSH
51595: LD_INT 1
51597: ARRAY
51598: PPUSH
51599: CALL_OW 250
51603: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51604: LD_ADDR_VAR 0 11
51608: PUSH
51609: LD_VAR 0 14
51613: PUSH
51614: LD_INT 1
51616: ARRAY
51617: PPUSH
51618: CALL_OW 251
51622: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51623: LD_ADDR_VAR 0 12
51627: PUSH
51628: LD_VAR 0 4
51632: PUSH
51633: LD_VAR 0 7
51637: ARRAY
51638: PPUSH
51639: CALL 47518 0 1
51643: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51644: LD_VAR 0 4
51648: PUSH
51649: LD_VAR 0 7
51653: ARRAY
51654: PPUSH
51655: LD_VAR 0 10
51659: PPUSH
51660: LD_VAR 0 11
51664: PPUSH
51665: LD_VAR 0 14
51669: PUSH
51670: LD_INT 1
51672: ARRAY
51673: PPUSH
51674: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51678: LD_VAR 0 4
51682: PUSH
51683: LD_VAR 0 7
51687: ARRAY
51688: PPUSH
51689: LD_VAR 0 10
51693: PPUSH
51694: LD_VAR 0 12
51698: PPUSH
51699: LD_INT 7
51701: PPUSH
51702: CALL_OW 272
51706: PPUSH
51707: LD_VAR 0 11
51711: PPUSH
51712: LD_VAR 0 12
51716: PPUSH
51717: LD_INT 7
51719: PPUSH
51720: CALL_OW 273
51724: PPUSH
51725: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51729: LD_VAR 0 4
51733: PUSH
51734: LD_VAR 0 7
51738: ARRAY
51739: PPUSH
51740: LD_INT 71
51742: PPUSH
51743: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51747: LD_ADDR_VAR 0 27
51751: PUSH
51752: LD_VAR 0 27
51756: PPUSH
51757: LD_VAR 0 27
51761: PUSH
51762: LD_INT 1
51764: PLUS
51765: PPUSH
51766: LD_VAR 0 14
51770: PUSH
51771: LD_INT 1
51773: ARRAY
51774: PPUSH
51775: CALL_OW 1
51779: ST_TO_ADDR
// attacking := true ;
51780: LD_ADDR_VAR 0 29
51784: PUSH
51785: LD_INT 1
51787: ST_TO_ADDR
// continue ;
51788: GO 49635
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51790: LD_VAR 0 4
51794: PUSH
51795: LD_VAR 0 7
51799: ARRAY
51800: PPUSH
51801: CALL_OW 257
51805: PUSH
51806: LD_INT 17
51808: EQUAL
51809: PUSH
51810: LD_VAR 0 4
51814: PUSH
51815: LD_VAR 0 7
51819: ARRAY
51820: PPUSH
51821: CALL_OW 110
51825: PUSH
51826: LD_INT 71
51828: EQUAL
51829: NOT
51830: AND
51831: IFFALSE 51977
// begin attacking := false ;
51833: LD_ADDR_VAR 0 29
51837: PUSH
51838: LD_INT 0
51840: ST_TO_ADDR
// k := 5 ;
51841: LD_ADDR_VAR 0 9
51845: PUSH
51846: LD_INT 5
51848: ST_TO_ADDR
// if tmp < k then
51849: LD_VAR 0 14
51853: PUSH
51854: LD_VAR 0 9
51858: LESS
51859: IFFALSE 51871
// k := tmp ;
51861: LD_ADDR_VAR 0 9
51865: PUSH
51866: LD_VAR 0 14
51870: ST_TO_ADDR
// for j = 1 to k do
51871: LD_ADDR_VAR 0 8
51875: PUSH
51876: DOUBLE
51877: LD_INT 1
51879: DEC
51880: ST_TO_ADDR
51881: LD_VAR 0 9
51885: PUSH
51886: FOR_TO
51887: IFFALSE 51975
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51889: LD_VAR 0 14
51893: PUSH
51894: LD_VAR 0 8
51898: ARRAY
51899: PUSH
51900: LD_VAR 0 14
51904: PPUSH
51905: LD_INT 58
51907: PUSH
51908: EMPTY
51909: LIST
51910: PPUSH
51911: CALL_OW 72
51915: IN
51916: NOT
51917: IFFALSE 51973
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51919: LD_VAR 0 4
51923: PUSH
51924: LD_VAR 0 7
51928: ARRAY
51929: PPUSH
51930: LD_VAR 0 14
51934: PUSH
51935: LD_VAR 0 8
51939: ARRAY
51940: PPUSH
51941: CALL_OW 115
// attacking := true ;
51945: LD_ADDR_VAR 0 29
51949: PUSH
51950: LD_INT 1
51952: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51953: LD_VAR 0 4
51957: PUSH
51958: LD_VAR 0 7
51962: ARRAY
51963: PPUSH
51964: LD_INT 71
51966: PPUSH
51967: CALL_OW 109
// continue ;
51971: GO 51886
// end ; end ;
51973: GO 51886
51975: POP
51976: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51977: LD_VAR 0 4
51981: PUSH
51982: LD_VAR 0 7
51986: ARRAY
51987: PPUSH
51988: CALL_OW 257
51992: PUSH
51993: LD_INT 8
51995: EQUAL
51996: PUSH
51997: LD_VAR 0 4
52001: PUSH
52002: LD_VAR 0 7
52006: ARRAY
52007: PPUSH
52008: CALL_OW 264
52012: PUSH
52013: LD_INT 28
52015: PUSH
52016: LD_INT 45
52018: PUSH
52019: LD_INT 7
52021: PUSH
52022: LD_INT 47
52024: PUSH
52025: EMPTY
52026: LIST
52027: LIST
52028: LIST
52029: LIST
52030: IN
52031: OR
52032: IFFALSE 52262
// begin attacking := false ;
52034: LD_ADDR_VAR 0 29
52038: PUSH
52039: LD_INT 0
52041: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52042: LD_VAR 0 14
52046: PUSH
52047: LD_INT 1
52049: ARRAY
52050: PPUSH
52051: CALL_OW 266
52055: PUSH
52056: LD_INT 32
52058: PUSH
52059: LD_INT 31
52061: PUSH
52062: LD_INT 33
52064: PUSH
52065: LD_INT 4
52067: PUSH
52068: LD_INT 5
52070: PUSH
52071: EMPTY
52072: LIST
52073: LIST
52074: LIST
52075: LIST
52076: LIST
52077: IN
52078: IFFALSE 52262
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52080: LD_ADDR_VAR 0 9
52084: PUSH
52085: LD_VAR 0 14
52089: PUSH
52090: LD_INT 1
52092: ARRAY
52093: PPUSH
52094: CALL_OW 266
52098: PPUSH
52099: LD_VAR 0 14
52103: PUSH
52104: LD_INT 1
52106: ARRAY
52107: PPUSH
52108: CALL_OW 250
52112: PPUSH
52113: LD_VAR 0 14
52117: PUSH
52118: LD_INT 1
52120: ARRAY
52121: PPUSH
52122: CALL_OW 251
52126: PPUSH
52127: LD_VAR 0 14
52131: PUSH
52132: LD_INT 1
52134: ARRAY
52135: PPUSH
52136: CALL_OW 254
52140: PPUSH
52141: LD_VAR 0 14
52145: PUSH
52146: LD_INT 1
52148: ARRAY
52149: PPUSH
52150: CALL_OW 248
52154: PPUSH
52155: LD_INT 0
52157: PPUSH
52158: CALL 28894 0 6
52162: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52163: LD_ADDR_VAR 0 8
52167: PUSH
52168: LD_VAR 0 4
52172: PUSH
52173: LD_VAR 0 7
52177: ARRAY
52178: PPUSH
52179: LD_VAR 0 9
52183: PPUSH
52184: CALL 47581 0 2
52188: ST_TO_ADDR
// if j then
52189: LD_VAR 0 8
52193: IFFALSE 52262
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52195: LD_VAR 0 8
52199: PUSH
52200: LD_INT 1
52202: ARRAY
52203: PPUSH
52204: LD_VAR 0 8
52208: PUSH
52209: LD_INT 2
52211: ARRAY
52212: PPUSH
52213: CALL_OW 488
52217: IFFALSE 52262
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52219: LD_VAR 0 4
52223: PUSH
52224: LD_VAR 0 7
52228: ARRAY
52229: PPUSH
52230: LD_VAR 0 8
52234: PUSH
52235: LD_INT 1
52237: ARRAY
52238: PPUSH
52239: LD_VAR 0 8
52243: PUSH
52244: LD_INT 2
52246: ARRAY
52247: PPUSH
52248: CALL_OW 116
// attacking := true ;
52252: LD_ADDR_VAR 0 29
52256: PUSH
52257: LD_INT 1
52259: ST_TO_ADDR
// continue ;
52260: GO 49635
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52262: LD_VAR 0 4
52266: PUSH
52267: LD_VAR 0 7
52271: ARRAY
52272: PPUSH
52273: CALL_OW 265
52277: PUSH
52278: LD_INT 11
52280: EQUAL
52281: IFFALSE 52559
// begin k := 10 ;
52283: LD_ADDR_VAR 0 9
52287: PUSH
52288: LD_INT 10
52290: ST_TO_ADDR
// x := 0 ;
52291: LD_ADDR_VAR 0 10
52295: PUSH
52296: LD_INT 0
52298: ST_TO_ADDR
// if tmp < k then
52299: LD_VAR 0 14
52303: PUSH
52304: LD_VAR 0 9
52308: LESS
52309: IFFALSE 52321
// k := tmp ;
52311: LD_ADDR_VAR 0 9
52315: PUSH
52316: LD_VAR 0 14
52320: ST_TO_ADDR
// for j = k downto 1 do
52321: LD_ADDR_VAR 0 8
52325: PUSH
52326: DOUBLE
52327: LD_VAR 0 9
52331: INC
52332: ST_TO_ADDR
52333: LD_INT 1
52335: PUSH
52336: FOR_DOWNTO
52337: IFFALSE 52412
// begin if GetType ( tmp [ j ] ) = unit_human then
52339: LD_VAR 0 14
52343: PUSH
52344: LD_VAR 0 8
52348: ARRAY
52349: PPUSH
52350: CALL_OW 247
52354: PUSH
52355: LD_INT 1
52357: EQUAL
52358: IFFALSE 52410
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52360: LD_VAR 0 4
52364: PUSH
52365: LD_VAR 0 7
52369: ARRAY
52370: PPUSH
52371: LD_VAR 0 14
52375: PUSH
52376: LD_VAR 0 8
52380: ARRAY
52381: PPUSH
52382: CALL 47852 0 2
// x := tmp [ j ] ;
52386: LD_ADDR_VAR 0 10
52390: PUSH
52391: LD_VAR 0 14
52395: PUSH
52396: LD_VAR 0 8
52400: ARRAY
52401: ST_TO_ADDR
// attacking := true ;
52402: LD_ADDR_VAR 0 29
52406: PUSH
52407: LD_INT 1
52409: ST_TO_ADDR
// end ; end ;
52410: GO 52336
52412: POP
52413: POP
// if not x then
52414: LD_VAR 0 10
52418: NOT
52419: IFFALSE 52559
// begin attacking := true ;
52421: LD_ADDR_VAR 0 29
52425: PUSH
52426: LD_INT 1
52428: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52429: LD_VAR 0 4
52433: PUSH
52434: LD_VAR 0 7
52438: ARRAY
52439: PPUSH
52440: CALL_OW 250
52444: PPUSH
52445: LD_VAR 0 4
52449: PUSH
52450: LD_VAR 0 7
52454: ARRAY
52455: PPUSH
52456: CALL_OW 251
52460: PPUSH
52461: CALL_OW 546
52465: PUSH
52466: LD_INT 2
52468: ARRAY
52469: PUSH
52470: LD_VAR 0 14
52474: PUSH
52475: LD_INT 1
52477: ARRAY
52478: PPUSH
52479: CALL_OW 250
52483: PPUSH
52484: LD_VAR 0 14
52488: PUSH
52489: LD_INT 1
52491: ARRAY
52492: PPUSH
52493: CALL_OW 251
52497: PPUSH
52498: CALL_OW 546
52502: PUSH
52503: LD_INT 2
52505: ARRAY
52506: EQUAL
52507: IFFALSE 52535
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52509: LD_VAR 0 4
52513: PUSH
52514: LD_VAR 0 7
52518: ARRAY
52519: PPUSH
52520: LD_VAR 0 14
52524: PUSH
52525: LD_INT 1
52527: ARRAY
52528: PPUSH
52529: CALL 47852 0 2
52533: GO 52559
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52535: LD_VAR 0 4
52539: PUSH
52540: LD_VAR 0 7
52544: ARRAY
52545: PPUSH
52546: LD_VAR 0 14
52550: PUSH
52551: LD_INT 1
52553: ARRAY
52554: PPUSH
52555: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52559: LD_VAR 0 4
52563: PUSH
52564: LD_VAR 0 7
52568: ARRAY
52569: PPUSH
52570: CALL_OW 264
52574: PUSH
52575: LD_INT 29
52577: EQUAL
52578: IFFALSE 52944
// begin if WantsToAttack ( group [ i ] ) in bombed then
52580: LD_VAR 0 4
52584: PUSH
52585: LD_VAR 0 7
52589: ARRAY
52590: PPUSH
52591: CALL_OW 319
52595: PUSH
52596: LD_VAR 0 28
52600: IN
52601: IFFALSE 52605
// continue ;
52603: GO 49635
// k := 8 ;
52605: LD_ADDR_VAR 0 9
52609: PUSH
52610: LD_INT 8
52612: ST_TO_ADDR
// x := 0 ;
52613: LD_ADDR_VAR 0 10
52617: PUSH
52618: LD_INT 0
52620: ST_TO_ADDR
// if tmp < k then
52621: LD_VAR 0 14
52625: PUSH
52626: LD_VAR 0 9
52630: LESS
52631: IFFALSE 52643
// k := tmp ;
52633: LD_ADDR_VAR 0 9
52637: PUSH
52638: LD_VAR 0 14
52642: ST_TO_ADDR
// for j = 1 to k do
52643: LD_ADDR_VAR 0 8
52647: PUSH
52648: DOUBLE
52649: LD_INT 1
52651: DEC
52652: ST_TO_ADDR
52653: LD_VAR 0 9
52657: PUSH
52658: FOR_TO
52659: IFFALSE 52791
// begin if GetType ( tmp [ j ] ) = unit_building then
52661: LD_VAR 0 14
52665: PUSH
52666: LD_VAR 0 8
52670: ARRAY
52671: PPUSH
52672: CALL_OW 247
52676: PUSH
52677: LD_INT 3
52679: EQUAL
52680: IFFALSE 52789
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52682: LD_VAR 0 14
52686: PUSH
52687: LD_VAR 0 8
52691: ARRAY
52692: PUSH
52693: LD_VAR 0 28
52697: IN
52698: NOT
52699: PUSH
52700: LD_VAR 0 14
52704: PUSH
52705: LD_VAR 0 8
52709: ARRAY
52710: PPUSH
52711: CALL_OW 313
52715: AND
52716: IFFALSE 52789
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52718: LD_VAR 0 4
52722: PUSH
52723: LD_VAR 0 7
52727: ARRAY
52728: PPUSH
52729: LD_VAR 0 14
52733: PUSH
52734: LD_VAR 0 8
52738: ARRAY
52739: PPUSH
52740: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52744: LD_ADDR_VAR 0 28
52748: PUSH
52749: LD_VAR 0 28
52753: PPUSH
52754: LD_VAR 0 28
52758: PUSH
52759: LD_INT 1
52761: PLUS
52762: PPUSH
52763: LD_VAR 0 14
52767: PUSH
52768: LD_VAR 0 8
52772: ARRAY
52773: PPUSH
52774: CALL_OW 1
52778: ST_TO_ADDR
// attacking := true ;
52779: LD_ADDR_VAR 0 29
52783: PUSH
52784: LD_INT 1
52786: ST_TO_ADDR
// break ;
52787: GO 52791
// end ; end ;
52789: GO 52658
52791: POP
52792: POP
// if not attacking and f_attack_depot then
52793: LD_VAR 0 29
52797: NOT
52798: PUSH
52799: LD_VAR 0 25
52803: AND
52804: IFFALSE 52899
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52806: LD_ADDR_VAR 0 13
52810: PUSH
52811: LD_VAR 0 14
52815: PPUSH
52816: LD_INT 2
52818: PUSH
52819: LD_INT 30
52821: PUSH
52822: LD_INT 0
52824: PUSH
52825: EMPTY
52826: LIST
52827: LIST
52828: PUSH
52829: LD_INT 30
52831: PUSH
52832: LD_INT 1
52834: PUSH
52835: EMPTY
52836: LIST
52837: LIST
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: LIST
52843: PPUSH
52844: CALL_OW 72
52848: ST_TO_ADDR
// if z then
52849: LD_VAR 0 13
52853: IFFALSE 52899
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52855: LD_VAR 0 4
52859: PUSH
52860: LD_VAR 0 7
52864: ARRAY
52865: PPUSH
52866: LD_VAR 0 13
52870: PPUSH
52871: LD_VAR 0 4
52875: PUSH
52876: LD_VAR 0 7
52880: ARRAY
52881: PPUSH
52882: CALL_OW 74
52886: PPUSH
52887: CALL_OW 115
// attacking := true ;
52891: LD_ADDR_VAR 0 29
52895: PUSH
52896: LD_INT 1
52898: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52899: LD_VAR 0 4
52903: PUSH
52904: LD_VAR 0 7
52908: ARRAY
52909: PPUSH
52910: CALL_OW 256
52914: PUSH
52915: LD_INT 500
52917: LESS
52918: IFFALSE 52944
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52920: LD_VAR 0 4
52924: PUSH
52925: LD_VAR 0 7
52929: ARRAY
52930: PPUSH
52931: LD_VAR 0 14
52935: PUSH
52936: LD_INT 1
52938: ARRAY
52939: PPUSH
52940: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52944: LD_VAR 0 4
52948: PUSH
52949: LD_VAR 0 7
52953: ARRAY
52954: PPUSH
52955: CALL_OW 264
52959: PUSH
52960: LD_INT 49
52962: EQUAL
52963: IFFALSE 53084
// begin if not HasTask ( group [ i ] ) then
52965: LD_VAR 0 4
52969: PUSH
52970: LD_VAR 0 7
52974: ARRAY
52975: PPUSH
52976: CALL_OW 314
52980: NOT
52981: IFFALSE 53084
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52983: LD_ADDR_VAR 0 9
52987: PUSH
52988: LD_INT 81
52990: PUSH
52991: LD_VAR 0 4
52995: PUSH
52996: LD_VAR 0 7
53000: ARRAY
53001: PPUSH
53002: CALL_OW 255
53006: PUSH
53007: EMPTY
53008: LIST
53009: LIST
53010: PPUSH
53011: CALL_OW 69
53015: PPUSH
53016: LD_VAR 0 4
53020: PUSH
53021: LD_VAR 0 7
53025: ARRAY
53026: PPUSH
53027: CALL_OW 74
53031: ST_TO_ADDR
// if k then
53032: LD_VAR 0 9
53036: IFFALSE 53084
// if GetDistUnits ( group [ i ] , k ) > 10 then
53038: LD_VAR 0 4
53042: PUSH
53043: LD_VAR 0 7
53047: ARRAY
53048: PPUSH
53049: LD_VAR 0 9
53053: PPUSH
53054: CALL_OW 296
53058: PUSH
53059: LD_INT 10
53061: GREATER
53062: IFFALSE 53084
// ComMoveUnit ( group [ i ] , k ) ;
53064: LD_VAR 0 4
53068: PUSH
53069: LD_VAR 0 7
53073: ARRAY
53074: PPUSH
53075: LD_VAR 0 9
53079: PPUSH
53080: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53084: LD_VAR 0 4
53088: PUSH
53089: LD_VAR 0 7
53093: ARRAY
53094: PPUSH
53095: CALL_OW 256
53099: PUSH
53100: LD_INT 250
53102: LESS
53103: PUSH
53104: LD_VAR 0 4
53108: PUSH
53109: LD_VAR 0 7
53113: ARRAY
53114: PUSH
53115: LD_INT 21
53117: PUSH
53118: LD_INT 2
53120: PUSH
53121: EMPTY
53122: LIST
53123: LIST
53124: PUSH
53125: LD_INT 23
53127: PUSH
53128: LD_INT 2
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: PUSH
53135: EMPTY
53136: LIST
53137: LIST
53138: PPUSH
53139: CALL_OW 69
53143: IN
53144: AND
53145: IFFALSE 53270
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53147: LD_ADDR_VAR 0 9
53151: PUSH
53152: LD_OWVAR 3
53156: PUSH
53157: LD_VAR 0 4
53161: PUSH
53162: LD_VAR 0 7
53166: ARRAY
53167: DIFF
53168: PPUSH
53169: LD_VAR 0 4
53173: PUSH
53174: LD_VAR 0 7
53178: ARRAY
53179: PPUSH
53180: CALL_OW 74
53184: ST_TO_ADDR
// if not k then
53185: LD_VAR 0 9
53189: NOT
53190: IFFALSE 53194
// continue ;
53192: GO 49635
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53194: LD_VAR 0 9
53198: PUSH
53199: LD_INT 81
53201: PUSH
53202: LD_VAR 0 4
53206: PUSH
53207: LD_VAR 0 7
53211: ARRAY
53212: PPUSH
53213: CALL_OW 255
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PPUSH
53222: CALL_OW 69
53226: IN
53227: PUSH
53228: LD_VAR 0 9
53232: PPUSH
53233: LD_VAR 0 4
53237: PUSH
53238: LD_VAR 0 7
53242: ARRAY
53243: PPUSH
53244: CALL_OW 296
53248: PUSH
53249: LD_INT 5
53251: LESS
53252: AND
53253: IFFALSE 53270
// ComAutodestruct ( group [ i ] ) ;
53255: LD_VAR 0 4
53259: PUSH
53260: LD_VAR 0 7
53264: ARRAY
53265: PPUSH
53266: CALL 47750 0 1
// end ; if f_attack_depot then
53270: LD_VAR 0 25
53274: IFFALSE 53386
// begin k := 6 ;
53276: LD_ADDR_VAR 0 9
53280: PUSH
53281: LD_INT 6
53283: ST_TO_ADDR
// if tmp < k then
53284: LD_VAR 0 14
53288: PUSH
53289: LD_VAR 0 9
53293: LESS
53294: IFFALSE 53306
// k := tmp ;
53296: LD_ADDR_VAR 0 9
53300: PUSH
53301: LD_VAR 0 14
53305: ST_TO_ADDR
// for j = 1 to k do
53306: LD_ADDR_VAR 0 8
53310: PUSH
53311: DOUBLE
53312: LD_INT 1
53314: DEC
53315: ST_TO_ADDR
53316: LD_VAR 0 9
53320: PUSH
53321: FOR_TO
53322: IFFALSE 53384
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53324: LD_VAR 0 8
53328: PPUSH
53329: CALL_OW 266
53333: PUSH
53334: LD_INT 0
53336: PUSH
53337: LD_INT 1
53339: PUSH
53340: EMPTY
53341: LIST
53342: LIST
53343: IN
53344: IFFALSE 53382
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53346: LD_VAR 0 4
53350: PUSH
53351: LD_VAR 0 7
53355: ARRAY
53356: PPUSH
53357: LD_VAR 0 14
53361: PUSH
53362: LD_VAR 0 8
53366: ARRAY
53367: PPUSH
53368: CALL_OW 115
// attacking := true ;
53372: LD_ADDR_VAR 0 29
53376: PUSH
53377: LD_INT 1
53379: ST_TO_ADDR
// break ;
53380: GO 53384
// end ;
53382: GO 53321
53384: POP
53385: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53386: LD_VAR 0 4
53390: PUSH
53391: LD_VAR 0 7
53395: ARRAY
53396: PPUSH
53397: CALL_OW 302
53401: PUSH
53402: LD_VAR 0 29
53406: NOT
53407: AND
53408: IFFALSE 53730
// begin if GetTag ( group [ i ] ) = 71 then
53410: LD_VAR 0 4
53414: PUSH
53415: LD_VAR 0 7
53419: ARRAY
53420: PPUSH
53421: CALL_OW 110
53425: PUSH
53426: LD_INT 71
53428: EQUAL
53429: IFFALSE 53470
// begin if HasTask ( group [ i ] ) then
53431: LD_VAR 0 4
53435: PUSH
53436: LD_VAR 0 7
53440: ARRAY
53441: PPUSH
53442: CALL_OW 314
53446: IFFALSE 53452
// continue else
53448: GO 49635
53450: GO 53470
// SetTag ( group [ i ] , 0 ) ;
53452: LD_VAR 0 4
53456: PUSH
53457: LD_VAR 0 7
53461: ARRAY
53462: PPUSH
53463: LD_INT 0
53465: PPUSH
53466: CALL_OW 109
// end ; k := 8 ;
53470: LD_ADDR_VAR 0 9
53474: PUSH
53475: LD_INT 8
53477: ST_TO_ADDR
// x := 0 ;
53478: LD_ADDR_VAR 0 10
53482: PUSH
53483: LD_INT 0
53485: ST_TO_ADDR
// if tmp < k then
53486: LD_VAR 0 14
53490: PUSH
53491: LD_VAR 0 9
53495: LESS
53496: IFFALSE 53508
// k := tmp ;
53498: LD_ADDR_VAR 0 9
53502: PUSH
53503: LD_VAR 0 14
53507: ST_TO_ADDR
// for j = 1 to k do
53508: LD_ADDR_VAR 0 8
53512: PUSH
53513: DOUBLE
53514: LD_INT 1
53516: DEC
53517: ST_TO_ADDR
53518: LD_VAR 0 9
53522: PUSH
53523: FOR_TO
53524: IFFALSE 53622
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53526: LD_VAR 0 14
53530: PUSH
53531: LD_VAR 0 8
53535: ARRAY
53536: PPUSH
53537: CALL_OW 247
53541: PUSH
53542: LD_INT 1
53544: EQUAL
53545: PUSH
53546: LD_VAR 0 14
53550: PUSH
53551: LD_VAR 0 8
53555: ARRAY
53556: PPUSH
53557: CALL_OW 256
53561: PUSH
53562: LD_INT 250
53564: LESS
53565: PUSH
53566: LD_VAR 0 20
53570: AND
53571: PUSH
53572: LD_VAR 0 20
53576: NOT
53577: PUSH
53578: LD_VAR 0 14
53582: PUSH
53583: LD_VAR 0 8
53587: ARRAY
53588: PPUSH
53589: CALL_OW 256
53593: PUSH
53594: LD_INT 250
53596: GREATEREQUAL
53597: AND
53598: OR
53599: AND
53600: IFFALSE 53620
// begin x := tmp [ j ] ;
53602: LD_ADDR_VAR 0 10
53606: PUSH
53607: LD_VAR 0 14
53611: PUSH
53612: LD_VAR 0 8
53616: ARRAY
53617: ST_TO_ADDR
// break ;
53618: GO 53622
// end ;
53620: GO 53523
53622: POP
53623: POP
// if x then
53624: LD_VAR 0 10
53628: IFFALSE 53652
// ComAttackUnit ( group [ i ] , x ) else
53630: LD_VAR 0 4
53634: PUSH
53635: LD_VAR 0 7
53639: ARRAY
53640: PPUSH
53641: LD_VAR 0 10
53645: PPUSH
53646: CALL_OW 115
53650: GO 53676
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53652: LD_VAR 0 4
53656: PUSH
53657: LD_VAR 0 7
53661: ARRAY
53662: PPUSH
53663: LD_VAR 0 14
53667: PUSH
53668: LD_INT 1
53670: ARRAY
53671: PPUSH
53672: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53676: LD_VAR 0 4
53680: PUSH
53681: LD_VAR 0 7
53685: ARRAY
53686: PPUSH
53687: CALL_OW 314
53691: NOT
53692: IFFALSE 53730
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53694: LD_VAR 0 4
53698: PUSH
53699: LD_VAR 0 7
53703: ARRAY
53704: PPUSH
53705: LD_VAR 0 14
53709: PPUSH
53710: LD_VAR 0 4
53714: PUSH
53715: LD_VAR 0 7
53719: ARRAY
53720: PPUSH
53721: CALL_OW 74
53725: PPUSH
53726: CALL_OW 115
// end ; end ; end ;
53730: GO 49635
53732: POP
53733: POP
// wait ( 0 0$1 ) ;
53734: LD_INT 35
53736: PPUSH
53737: CALL_OW 67
// until group = [ ] ;
53741: LD_VAR 0 4
53745: PUSH
53746: EMPTY
53747: EQUAL
53748: IFFALSE 49620
// end ;
53750: LD_VAR 0 2
53754: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53755: LD_INT 0
53757: PPUSH
53758: PPUSH
53759: PPUSH
53760: PPUSH
// if not base_units then
53761: LD_VAR 0 1
53765: NOT
53766: IFFALSE 53770
// exit ;
53768: GO 53857
// result := false ;
53770: LD_ADDR_VAR 0 2
53774: PUSH
53775: LD_INT 0
53777: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53778: LD_ADDR_VAR 0 5
53782: PUSH
53783: LD_VAR 0 1
53787: PPUSH
53788: LD_INT 21
53790: PUSH
53791: LD_INT 3
53793: PUSH
53794: EMPTY
53795: LIST
53796: LIST
53797: PPUSH
53798: CALL_OW 72
53802: ST_TO_ADDR
// if not tmp then
53803: LD_VAR 0 5
53807: NOT
53808: IFFALSE 53812
// exit ;
53810: GO 53857
// for i in tmp do
53812: LD_ADDR_VAR 0 3
53816: PUSH
53817: LD_VAR 0 5
53821: PUSH
53822: FOR_IN
53823: IFFALSE 53855
// begin result := EnemyInRange ( i , 22 ) ;
53825: LD_ADDR_VAR 0 2
53829: PUSH
53830: LD_VAR 0 3
53834: PPUSH
53835: LD_INT 22
53837: PPUSH
53838: CALL 47433 0 2
53842: ST_TO_ADDR
// if result then
53843: LD_VAR 0 2
53847: IFFALSE 53853
// exit ;
53849: POP
53850: POP
53851: GO 53857
// end ;
53853: GO 53822
53855: POP
53856: POP
// end ;
53857: LD_VAR 0 2
53861: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53862: LD_INT 0
53864: PPUSH
53865: PPUSH
// if not units then
53866: LD_VAR 0 1
53870: NOT
53871: IFFALSE 53875
// exit ;
53873: GO 53945
// result := [ ] ;
53875: LD_ADDR_VAR 0 3
53879: PUSH
53880: EMPTY
53881: ST_TO_ADDR
// for i in units do
53882: LD_ADDR_VAR 0 4
53886: PUSH
53887: LD_VAR 0 1
53891: PUSH
53892: FOR_IN
53893: IFFALSE 53943
// if GetTag ( i ) = tag then
53895: LD_VAR 0 4
53899: PPUSH
53900: CALL_OW 110
53904: PUSH
53905: LD_VAR 0 2
53909: EQUAL
53910: IFFALSE 53941
// result := Insert ( result , result + 1 , i ) ;
53912: LD_ADDR_VAR 0 3
53916: PUSH
53917: LD_VAR 0 3
53921: PPUSH
53922: LD_VAR 0 3
53926: PUSH
53927: LD_INT 1
53929: PLUS
53930: PPUSH
53931: LD_VAR 0 4
53935: PPUSH
53936: CALL_OW 2
53940: ST_TO_ADDR
53941: GO 53892
53943: POP
53944: POP
// end ;
53945: LD_VAR 0 3
53949: RET
// export function IsDriver ( un ) ; begin
53950: LD_INT 0
53952: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53953: LD_ADDR_VAR 0 2
53957: PUSH
53958: LD_VAR 0 1
53962: PUSH
53963: LD_INT 55
53965: PUSH
53966: EMPTY
53967: LIST
53968: PPUSH
53969: CALL_OW 69
53973: IN
53974: ST_TO_ADDR
// end ;
53975: LD_VAR 0 2
53979: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53980: LD_INT 0
53982: PPUSH
53983: PPUSH
// list := [ ] ;
53984: LD_ADDR_VAR 0 5
53988: PUSH
53989: EMPTY
53990: ST_TO_ADDR
// case d of 0 :
53991: LD_VAR 0 3
53995: PUSH
53996: LD_INT 0
53998: DOUBLE
53999: EQUAL
54000: IFTRUE 54004
54002: GO 54137
54004: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54005: LD_ADDR_VAR 0 5
54009: PUSH
54010: LD_VAR 0 1
54014: PUSH
54015: LD_INT 4
54017: MINUS
54018: PUSH
54019: LD_VAR 0 2
54023: PUSH
54024: LD_INT 4
54026: MINUS
54027: PUSH
54028: LD_INT 2
54030: PUSH
54031: EMPTY
54032: LIST
54033: LIST
54034: LIST
54035: PUSH
54036: LD_VAR 0 1
54040: PUSH
54041: LD_INT 3
54043: MINUS
54044: PUSH
54045: LD_VAR 0 2
54049: PUSH
54050: LD_INT 1
54052: PUSH
54053: EMPTY
54054: LIST
54055: LIST
54056: LIST
54057: PUSH
54058: LD_VAR 0 1
54062: PUSH
54063: LD_INT 4
54065: PLUS
54066: PUSH
54067: LD_VAR 0 2
54071: PUSH
54072: LD_INT 4
54074: PUSH
54075: EMPTY
54076: LIST
54077: LIST
54078: LIST
54079: PUSH
54080: LD_VAR 0 1
54084: PUSH
54085: LD_INT 3
54087: PLUS
54088: PUSH
54089: LD_VAR 0 2
54093: PUSH
54094: LD_INT 3
54096: PLUS
54097: PUSH
54098: LD_INT 5
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: LIST
54105: PUSH
54106: LD_VAR 0 1
54110: PUSH
54111: LD_VAR 0 2
54115: PUSH
54116: LD_INT 4
54118: PLUS
54119: PUSH
54120: LD_INT 0
54122: PUSH
54123: EMPTY
54124: LIST
54125: LIST
54126: LIST
54127: PUSH
54128: EMPTY
54129: LIST
54130: LIST
54131: LIST
54132: LIST
54133: LIST
54134: ST_TO_ADDR
// end ; 1 :
54135: GO 54835
54137: LD_INT 1
54139: DOUBLE
54140: EQUAL
54141: IFTRUE 54145
54143: GO 54278
54145: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54146: LD_ADDR_VAR 0 5
54150: PUSH
54151: LD_VAR 0 1
54155: PUSH
54156: LD_VAR 0 2
54160: PUSH
54161: LD_INT 4
54163: MINUS
54164: PUSH
54165: LD_INT 3
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: LIST
54172: PUSH
54173: LD_VAR 0 1
54177: PUSH
54178: LD_INT 3
54180: MINUS
54181: PUSH
54182: LD_VAR 0 2
54186: PUSH
54187: LD_INT 3
54189: MINUS
54190: PUSH
54191: LD_INT 2
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: LIST
54198: PUSH
54199: LD_VAR 0 1
54203: PUSH
54204: LD_INT 4
54206: MINUS
54207: PUSH
54208: LD_VAR 0 2
54212: PUSH
54213: LD_INT 1
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: LIST
54220: PUSH
54221: LD_VAR 0 1
54225: PUSH
54226: LD_VAR 0 2
54230: PUSH
54231: LD_INT 3
54233: PLUS
54234: PUSH
54235: LD_INT 0
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: LIST
54242: PUSH
54243: LD_VAR 0 1
54247: PUSH
54248: LD_INT 4
54250: PLUS
54251: PUSH
54252: LD_VAR 0 2
54256: PUSH
54257: LD_INT 4
54259: PLUS
54260: PUSH
54261: LD_INT 5
54263: PUSH
54264: EMPTY
54265: LIST
54266: LIST
54267: LIST
54268: PUSH
54269: EMPTY
54270: LIST
54271: LIST
54272: LIST
54273: LIST
54274: LIST
54275: ST_TO_ADDR
// end ; 2 :
54276: GO 54835
54278: LD_INT 2
54280: DOUBLE
54281: EQUAL
54282: IFTRUE 54286
54284: GO 54415
54286: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54287: LD_ADDR_VAR 0 5
54291: PUSH
54292: LD_VAR 0 1
54296: PUSH
54297: LD_VAR 0 2
54301: PUSH
54302: LD_INT 3
54304: MINUS
54305: PUSH
54306: LD_INT 3
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: PUSH
54314: LD_VAR 0 1
54318: PUSH
54319: LD_INT 4
54321: PLUS
54322: PUSH
54323: LD_VAR 0 2
54327: PUSH
54328: LD_INT 4
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: LIST
54335: PUSH
54336: LD_VAR 0 1
54340: PUSH
54341: LD_VAR 0 2
54345: PUSH
54346: LD_INT 4
54348: PLUS
54349: PUSH
54350: LD_INT 0
54352: PUSH
54353: EMPTY
54354: LIST
54355: LIST
54356: LIST
54357: PUSH
54358: LD_VAR 0 1
54362: PUSH
54363: LD_INT 3
54365: MINUS
54366: PUSH
54367: LD_VAR 0 2
54371: PUSH
54372: LD_INT 1
54374: PUSH
54375: EMPTY
54376: LIST
54377: LIST
54378: LIST
54379: PUSH
54380: LD_VAR 0 1
54384: PUSH
54385: LD_INT 4
54387: MINUS
54388: PUSH
54389: LD_VAR 0 2
54393: PUSH
54394: LD_INT 4
54396: MINUS
54397: PUSH
54398: LD_INT 2
54400: PUSH
54401: EMPTY
54402: LIST
54403: LIST
54404: LIST
54405: PUSH
54406: EMPTY
54407: LIST
54408: LIST
54409: LIST
54410: LIST
54411: LIST
54412: ST_TO_ADDR
// end ; 3 :
54413: GO 54835
54415: LD_INT 3
54417: DOUBLE
54418: EQUAL
54419: IFTRUE 54423
54421: GO 54556
54423: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54424: LD_ADDR_VAR 0 5
54428: PUSH
54429: LD_VAR 0 1
54433: PUSH
54434: LD_INT 3
54436: PLUS
54437: PUSH
54438: LD_VAR 0 2
54442: PUSH
54443: LD_INT 4
54445: PUSH
54446: EMPTY
54447: LIST
54448: LIST
54449: LIST
54450: PUSH
54451: LD_VAR 0 1
54455: PUSH
54456: LD_INT 4
54458: PLUS
54459: PUSH
54460: LD_VAR 0 2
54464: PUSH
54465: LD_INT 4
54467: PLUS
54468: PUSH
54469: LD_INT 5
54471: PUSH
54472: EMPTY
54473: LIST
54474: LIST
54475: LIST
54476: PUSH
54477: LD_VAR 0 1
54481: PUSH
54482: LD_INT 4
54484: MINUS
54485: PUSH
54486: LD_VAR 0 2
54490: PUSH
54491: LD_INT 1
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: LIST
54498: PUSH
54499: LD_VAR 0 1
54503: PUSH
54504: LD_VAR 0 2
54508: PUSH
54509: LD_INT 4
54511: MINUS
54512: PUSH
54513: LD_INT 3
54515: PUSH
54516: EMPTY
54517: LIST
54518: LIST
54519: LIST
54520: PUSH
54521: LD_VAR 0 1
54525: PUSH
54526: LD_INT 3
54528: MINUS
54529: PUSH
54530: LD_VAR 0 2
54534: PUSH
54535: LD_INT 3
54537: MINUS
54538: PUSH
54539: LD_INT 2
54541: PUSH
54542: EMPTY
54543: LIST
54544: LIST
54545: LIST
54546: PUSH
54547: EMPTY
54548: LIST
54549: LIST
54550: LIST
54551: LIST
54552: LIST
54553: ST_TO_ADDR
// end ; 4 :
54554: GO 54835
54556: LD_INT 4
54558: DOUBLE
54559: EQUAL
54560: IFTRUE 54564
54562: GO 54697
54564: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54565: LD_ADDR_VAR 0 5
54569: PUSH
54570: LD_VAR 0 1
54574: PUSH
54575: LD_VAR 0 2
54579: PUSH
54580: LD_INT 4
54582: PLUS
54583: PUSH
54584: LD_INT 0
54586: PUSH
54587: EMPTY
54588: LIST
54589: LIST
54590: LIST
54591: PUSH
54592: LD_VAR 0 1
54596: PUSH
54597: LD_INT 3
54599: PLUS
54600: PUSH
54601: LD_VAR 0 2
54605: PUSH
54606: LD_INT 3
54608: PLUS
54609: PUSH
54610: LD_INT 5
54612: PUSH
54613: EMPTY
54614: LIST
54615: LIST
54616: LIST
54617: PUSH
54618: LD_VAR 0 1
54622: PUSH
54623: LD_INT 4
54625: PLUS
54626: PUSH
54627: LD_VAR 0 2
54631: PUSH
54632: LD_INT 4
54634: PUSH
54635: EMPTY
54636: LIST
54637: LIST
54638: LIST
54639: PUSH
54640: LD_VAR 0 1
54644: PUSH
54645: LD_VAR 0 2
54649: PUSH
54650: LD_INT 3
54652: MINUS
54653: PUSH
54654: LD_INT 3
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: PUSH
54662: LD_VAR 0 1
54666: PUSH
54667: LD_INT 4
54669: MINUS
54670: PUSH
54671: LD_VAR 0 2
54675: PUSH
54676: LD_INT 4
54678: MINUS
54679: PUSH
54680: LD_INT 2
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: LIST
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: LIST
54692: LIST
54693: LIST
54694: ST_TO_ADDR
// end ; 5 :
54695: GO 54835
54697: LD_INT 5
54699: DOUBLE
54700: EQUAL
54701: IFTRUE 54705
54703: GO 54834
54705: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54706: LD_ADDR_VAR 0 5
54710: PUSH
54711: LD_VAR 0 1
54715: PUSH
54716: LD_INT 4
54718: MINUS
54719: PUSH
54720: LD_VAR 0 2
54724: PUSH
54725: LD_INT 1
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: PUSH
54733: LD_VAR 0 1
54737: PUSH
54738: LD_VAR 0 2
54742: PUSH
54743: LD_INT 4
54745: MINUS
54746: PUSH
54747: LD_INT 3
54749: PUSH
54750: EMPTY
54751: LIST
54752: LIST
54753: LIST
54754: PUSH
54755: LD_VAR 0 1
54759: PUSH
54760: LD_INT 4
54762: PLUS
54763: PUSH
54764: LD_VAR 0 2
54768: PUSH
54769: LD_INT 4
54771: PLUS
54772: PUSH
54773: LD_INT 5
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: PUSH
54781: LD_VAR 0 1
54785: PUSH
54786: LD_INT 3
54788: PLUS
54789: PUSH
54790: LD_VAR 0 2
54794: PUSH
54795: LD_INT 4
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: LIST
54802: PUSH
54803: LD_VAR 0 1
54807: PUSH
54808: LD_VAR 0 2
54812: PUSH
54813: LD_INT 3
54815: PLUS
54816: PUSH
54817: LD_INT 0
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: LIST
54829: LIST
54830: LIST
54831: ST_TO_ADDR
// end ; end ;
54832: GO 54835
54834: POP
// result := list ;
54835: LD_ADDR_VAR 0 4
54839: PUSH
54840: LD_VAR 0 5
54844: ST_TO_ADDR
// end ;
54845: LD_VAR 0 4
54849: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54850: LD_INT 0
54852: PPUSH
54853: PPUSH
54854: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54855: LD_VAR 0 1
54859: NOT
54860: PUSH
54861: LD_VAR 0 2
54865: PUSH
54866: LD_INT 1
54868: PUSH
54869: LD_INT 2
54871: PUSH
54872: LD_INT 3
54874: PUSH
54875: LD_INT 4
54877: PUSH
54878: EMPTY
54879: LIST
54880: LIST
54881: LIST
54882: LIST
54883: IN
54884: NOT
54885: OR
54886: IFFALSE 54890
// exit ;
54888: GO 54982
// tmp := [ ] ;
54890: LD_ADDR_VAR 0 5
54894: PUSH
54895: EMPTY
54896: ST_TO_ADDR
// for i in units do
54897: LD_ADDR_VAR 0 4
54901: PUSH
54902: LD_VAR 0 1
54906: PUSH
54907: FOR_IN
54908: IFFALSE 54951
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54910: LD_ADDR_VAR 0 5
54914: PUSH
54915: LD_VAR 0 5
54919: PPUSH
54920: LD_VAR 0 5
54924: PUSH
54925: LD_INT 1
54927: PLUS
54928: PPUSH
54929: LD_VAR 0 4
54933: PPUSH
54934: LD_VAR 0 2
54938: PPUSH
54939: CALL_OW 259
54943: PPUSH
54944: CALL_OW 2
54948: ST_TO_ADDR
54949: GO 54907
54951: POP
54952: POP
// if not tmp then
54953: LD_VAR 0 5
54957: NOT
54958: IFFALSE 54962
// exit ;
54960: GO 54982
// result := SortListByListDesc ( units , tmp ) ;
54962: LD_ADDR_VAR 0 3
54966: PUSH
54967: LD_VAR 0 1
54971: PPUSH
54972: LD_VAR 0 5
54976: PPUSH
54977: CALL_OW 77
54981: ST_TO_ADDR
// end ;
54982: LD_VAR 0 3
54986: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54987: LD_INT 0
54989: PPUSH
54990: PPUSH
54991: PPUSH
// x := GetX ( building ) ;
54992: LD_ADDR_VAR 0 4
54996: PUSH
54997: LD_VAR 0 2
55001: PPUSH
55002: CALL_OW 250
55006: ST_TO_ADDR
// y := GetY ( building ) ;
55007: LD_ADDR_VAR 0 5
55011: PUSH
55012: LD_VAR 0 2
55016: PPUSH
55017: CALL_OW 251
55021: ST_TO_ADDR
// if GetTaskList ( unit ) then
55022: LD_VAR 0 1
55026: PPUSH
55027: CALL_OW 437
55031: IFFALSE 55126
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55033: LD_STRING e
55035: PUSH
55036: LD_VAR 0 1
55040: PPUSH
55041: CALL_OW 437
55045: PUSH
55046: LD_INT 1
55048: ARRAY
55049: PUSH
55050: LD_INT 1
55052: ARRAY
55053: EQUAL
55054: PUSH
55055: LD_VAR 0 4
55059: PUSH
55060: LD_VAR 0 1
55064: PPUSH
55065: CALL_OW 437
55069: PUSH
55070: LD_INT 1
55072: ARRAY
55073: PUSH
55074: LD_INT 2
55076: ARRAY
55077: EQUAL
55078: AND
55079: PUSH
55080: LD_VAR 0 5
55084: PUSH
55085: LD_VAR 0 1
55089: PPUSH
55090: CALL_OW 437
55094: PUSH
55095: LD_INT 1
55097: ARRAY
55098: PUSH
55099: LD_INT 3
55101: ARRAY
55102: EQUAL
55103: AND
55104: IFFALSE 55116
// result := true else
55106: LD_ADDR_VAR 0 3
55110: PUSH
55111: LD_INT 1
55113: ST_TO_ADDR
55114: GO 55124
// result := false ;
55116: LD_ADDR_VAR 0 3
55120: PUSH
55121: LD_INT 0
55123: ST_TO_ADDR
// end else
55124: GO 55134
// result := false ;
55126: LD_ADDR_VAR 0 3
55130: PUSH
55131: LD_INT 0
55133: ST_TO_ADDR
// end ;
55134: LD_VAR 0 3
55138: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55139: LD_INT 0
55141: PPUSH
55142: PPUSH
55143: PPUSH
55144: PPUSH
// if not unit or not area then
55145: LD_VAR 0 1
55149: NOT
55150: PUSH
55151: LD_VAR 0 2
55155: NOT
55156: OR
55157: IFFALSE 55161
// exit ;
55159: GO 55326
// tmp := AreaToList ( area , i ) ;
55161: LD_ADDR_VAR 0 6
55165: PUSH
55166: LD_VAR 0 2
55170: PPUSH
55171: LD_VAR 0 5
55175: PPUSH
55176: CALL_OW 517
55180: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55181: LD_ADDR_VAR 0 5
55185: PUSH
55186: DOUBLE
55187: LD_INT 1
55189: DEC
55190: ST_TO_ADDR
55191: LD_VAR 0 6
55195: PUSH
55196: LD_INT 1
55198: ARRAY
55199: PUSH
55200: FOR_TO
55201: IFFALSE 55316
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55203: LD_ADDR_VAR 0 7
55207: PUSH
55208: LD_VAR 0 6
55212: PUSH
55213: LD_INT 1
55215: ARRAY
55216: PUSH
55217: LD_VAR 0 5
55221: ARRAY
55222: PUSH
55223: LD_VAR 0 6
55227: PUSH
55228: LD_INT 2
55230: ARRAY
55231: PUSH
55232: LD_VAR 0 5
55236: ARRAY
55237: PUSH
55238: EMPTY
55239: LIST
55240: LIST
55241: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55242: LD_VAR 0 7
55246: PUSH
55247: LD_INT 1
55249: ARRAY
55250: PPUSH
55251: LD_VAR 0 7
55255: PUSH
55256: LD_INT 2
55258: ARRAY
55259: PPUSH
55260: CALL_OW 428
55264: PUSH
55265: LD_INT 0
55267: EQUAL
55268: IFFALSE 55314
// begin result := true ;
55270: LD_ADDR_VAR 0 4
55274: PUSH
55275: LD_INT 1
55277: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55278: LD_VAR 0 1
55282: PPUSH
55283: LD_VAR 0 7
55287: PUSH
55288: LD_INT 1
55290: ARRAY
55291: PPUSH
55292: LD_VAR 0 7
55296: PUSH
55297: LD_INT 2
55299: ARRAY
55300: PPUSH
55301: LD_VAR 0 3
55305: PPUSH
55306: CALL_OW 48
// exit ;
55310: POP
55311: POP
55312: GO 55326
// end ; end ;
55314: GO 55200
55316: POP
55317: POP
// result := false ;
55318: LD_ADDR_VAR 0 4
55322: PUSH
55323: LD_INT 0
55325: ST_TO_ADDR
// end ;
55326: LD_VAR 0 4
55330: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55331: LD_INT 0
55333: PPUSH
55334: PPUSH
55335: PPUSH
// if not side or side > 8 then
55336: LD_VAR 0 1
55340: NOT
55341: PUSH
55342: LD_VAR 0 1
55346: PUSH
55347: LD_INT 8
55349: GREATER
55350: OR
55351: IFFALSE 55355
// exit ;
55353: GO 55542
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55355: LD_ADDR_VAR 0 4
55359: PUSH
55360: LD_INT 22
55362: PUSH
55363: LD_VAR 0 1
55367: PUSH
55368: EMPTY
55369: LIST
55370: LIST
55371: PUSH
55372: LD_INT 21
55374: PUSH
55375: LD_INT 3
55377: PUSH
55378: EMPTY
55379: LIST
55380: LIST
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: PPUSH
55386: CALL_OW 69
55390: ST_TO_ADDR
// if not tmp then
55391: LD_VAR 0 4
55395: NOT
55396: IFFALSE 55400
// exit ;
55398: GO 55542
// enable_addtolog := true ;
55400: LD_ADDR_OWVAR 81
55404: PUSH
55405: LD_INT 1
55407: ST_TO_ADDR
// AddToLog ( [ ) ;
55408: LD_STRING [
55410: PPUSH
55411: CALL_OW 561
// for i in tmp do
55415: LD_ADDR_VAR 0 3
55419: PUSH
55420: LD_VAR 0 4
55424: PUSH
55425: FOR_IN
55426: IFFALSE 55533
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55428: LD_STRING [
55430: PUSH
55431: LD_VAR 0 3
55435: PPUSH
55436: CALL_OW 266
55440: STR
55441: PUSH
55442: LD_STRING , 
55444: STR
55445: PUSH
55446: LD_VAR 0 3
55450: PPUSH
55451: CALL_OW 250
55455: STR
55456: PUSH
55457: LD_STRING , 
55459: STR
55460: PUSH
55461: LD_VAR 0 3
55465: PPUSH
55466: CALL_OW 251
55470: STR
55471: PUSH
55472: LD_STRING , 
55474: STR
55475: PUSH
55476: LD_VAR 0 3
55480: PPUSH
55481: CALL_OW 254
55485: STR
55486: PUSH
55487: LD_STRING , 
55489: STR
55490: PUSH
55491: LD_VAR 0 3
55495: PPUSH
55496: LD_INT 1
55498: PPUSH
55499: CALL_OW 268
55503: STR
55504: PUSH
55505: LD_STRING , 
55507: STR
55508: PUSH
55509: LD_VAR 0 3
55513: PPUSH
55514: LD_INT 2
55516: PPUSH
55517: CALL_OW 268
55521: STR
55522: PUSH
55523: LD_STRING ],
55525: STR
55526: PPUSH
55527: CALL_OW 561
// end ;
55531: GO 55425
55533: POP
55534: POP
// AddToLog ( ]; ) ;
55535: LD_STRING ];
55537: PPUSH
55538: CALL_OW 561
// end ;
55542: LD_VAR 0 2
55546: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55547: LD_INT 0
55549: PPUSH
55550: PPUSH
55551: PPUSH
55552: PPUSH
55553: PPUSH
// if not area or not rate or not max then
55554: LD_VAR 0 1
55558: NOT
55559: PUSH
55560: LD_VAR 0 2
55564: NOT
55565: OR
55566: PUSH
55567: LD_VAR 0 4
55571: NOT
55572: OR
55573: IFFALSE 55577
// exit ;
55575: GO 55769
// while 1 do
55577: LD_INT 1
55579: IFFALSE 55769
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55581: LD_ADDR_VAR 0 9
55585: PUSH
55586: LD_VAR 0 1
55590: PPUSH
55591: LD_INT 1
55593: PPUSH
55594: CALL_OW 287
55598: PUSH
55599: LD_INT 10
55601: MUL
55602: ST_TO_ADDR
// r := rate / 10 ;
55603: LD_ADDR_VAR 0 7
55607: PUSH
55608: LD_VAR 0 2
55612: PUSH
55613: LD_INT 10
55615: DIVREAL
55616: ST_TO_ADDR
// time := 1 1$00 ;
55617: LD_ADDR_VAR 0 8
55621: PUSH
55622: LD_INT 2100
55624: ST_TO_ADDR
// if amount < min then
55625: LD_VAR 0 9
55629: PUSH
55630: LD_VAR 0 3
55634: LESS
55635: IFFALSE 55653
// r := r * 2 else
55637: LD_ADDR_VAR 0 7
55641: PUSH
55642: LD_VAR 0 7
55646: PUSH
55647: LD_INT 2
55649: MUL
55650: ST_TO_ADDR
55651: GO 55679
// if amount > max then
55653: LD_VAR 0 9
55657: PUSH
55658: LD_VAR 0 4
55662: GREATER
55663: IFFALSE 55679
// r := r / 2 ;
55665: LD_ADDR_VAR 0 7
55669: PUSH
55670: LD_VAR 0 7
55674: PUSH
55675: LD_INT 2
55677: DIVREAL
55678: ST_TO_ADDR
// time := time / r ;
55679: LD_ADDR_VAR 0 8
55683: PUSH
55684: LD_VAR 0 8
55688: PUSH
55689: LD_VAR 0 7
55693: DIVREAL
55694: ST_TO_ADDR
// if time < 0 then
55695: LD_VAR 0 8
55699: PUSH
55700: LD_INT 0
55702: LESS
55703: IFFALSE 55720
// time := time * - 1 ;
55705: LD_ADDR_VAR 0 8
55709: PUSH
55710: LD_VAR 0 8
55714: PUSH
55715: LD_INT 1
55717: NEG
55718: MUL
55719: ST_TO_ADDR
// wait ( time ) ;
55720: LD_VAR 0 8
55724: PPUSH
55725: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55729: LD_INT 35
55731: PPUSH
55732: LD_INT 875
55734: PPUSH
55735: CALL_OW 12
55739: PPUSH
55740: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55744: LD_INT 1
55746: PPUSH
55747: LD_INT 5
55749: PPUSH
55750: CALL_OW 12
55754: PPUSH
55755: LD_VAR 0 1
55759: PPUSH
55760: LD_INT 1
55762: PPUSH
55763: CALL_OW 55
// end ;
55767: GO 55577
// end ;
55769: LD_VAR 0 5
55773: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55774: LD_INT 0
55776: PPUSH
55777: PPUSH
55778: PPUSH
55779: PPUSH
55780: PPUSH
55781: PPUSH
55782: PPUSH
55783: PPUSH
// if not turrets or not factories then
55784: LD_VAR 0 1
55788: NOT
55789: PUSH
55790: LD_VAR 0 2
55794: NOT
55795: OR
55796: IFFALSE 55800
// exit ;
55798: GO 56107
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55800: LD_ADDR_VAR 0 10
55804: PUSH
55805: LD_INT 5
55807: PUSH
55808: LD_INT 6
55810: PUSH
55811: EMPTY
55812: LIST
55813: LIST
55814: PUSH
55815: LD_INT 2
55817: PUSH
55818: LD_INT 4
55820: PUSH
55821: EMPTY
55822: LIST
55823: LIST
55824: PUSH
55825: LD_INT 3
55827: PUSH
55828: LD_INT 5
55830: PUSH
55831: EMPTY
55832: LIST
55833: LIST
55834: PUSH
55835: EMPTY
55836: LIST
55837: LIST
55838: LIST
55839: PUSH
55840: LD_INT 24
55842: PUSH
55843: LD_INT 25
55845: PUSH
55846: EMPTY
55847: LIST
55848: LIST
55849: PUSH
55850: LD_INT 23
55852: PUSH
55853: LD_INT 27
55855: PUSH
55856: EMPTY
55857: LIST
55858: LIST
55859: PUSH
55860: EMPTY
55861: LIST
55862: LIST
55863: PUSH
55864: LD_INT 42
55866: PUSH
55867: LD_INT 43
55869: PUSH
55870: EMPTY
55871: LIST
55872: LIST
55873: PUSH
55874: LD_INT 44
55876: PUSH
55877: LD_INT 46
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: PUSH
55884: LD_INT 45
55886: PUSH
55887: LD_INT 47
55889: PUSH
55890: EMPTY
55891: LIST
55892: LIST
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: LIST
55898: PUSH
55899: EMPTY
55900: LIST
55901: LIST
55902: LIST
55903: ST_TO_ADDR
// result := [ ] ;
55904: LD_ADDR_VAR 0 3
55908: PUSH
55909: EMPTY
55910: ST_TO_ADDR
// for i in turrets do
55911: LD_ADDR_VAR 0 4
55915: PUSH
55916: LD_VAR 0 1
55920: PUSH
55921: FOR_IN
55922: IFFALSE 56105
// begin nat := GetNation ( i ) ;
55924: LD_ADDR_VAR 0 7
55928: PUSH
55929: LD_VAR 0 4
55933: PPUSH
55934: CALL_OW 248
55938: ST_TO_ADDR
// weapon := 0 ;
55939: LD_ADDR_VAR 0 8
55943: PUSH
55944: LD_INT 0
55946: ST_TO_ADDR
// if not nat then
55947: LD_VAR 0 7
55951: NOT
55952: IFFALSE 55956
// continue ;
55954: GO 55921
// for j in list [ nat ] do
55956: LD_ADDR_VAR 0 5
55960: PUSH
55961: LD_VAR 0 10
55965: PUSH
55966: LD_VAR 0 7
55970: ARRAY
55971: PUSH
55972: FOR_IN
55973: IFFALSE 56014
// if GetBWeapon ( i ) = j [ 1 ] then
55975: LD_VAR 0 4
55979: PPUSH
55980: CALL_OW 269
55984: PUSH
55985: LD_VAR 0 5
55989: PUSH
55990: LD_INT 1
55992: ARRAY
55993: EQUAL
55994: IFFALSE 56012
// begin weapon := j [ 2 ] ;
55996: LD_ADDR_VAR 0 8
56000: PUSH
56001: LD_VAR 0 5
56005: PUSH
56006: LD_INT 2
56008: ARRAY
56009: ST_TO_ADDR
// break ;
56010: GO 56014
// end ;
56012: GO 55972
56014: POP
56015: POP
// if not weapon then
56016: LD_VAR 0 8
56020: NOT
56021: IFFALSE 56025
// continue ;
56023: GO 55921
// for k in factories do
56025: LD_ADDR_VAR 0 6
56029: PUSH
56030: LD_VAR 0 2
56034: PUSH
56035: FOR_IN
56036: IFFALSE 56101
// begin weapons := AvailableWeaponList ( k ) ;
56038: LD_ADDR_VAR 0 9
56042: PUSH
56043: LD_VAR 0 6
56047: PPUSH
56048: CALL_OW 478
56052: ST_TO_ADDR
// if not weapons then
56053: LD_VAR 0 9
56057: NOT
56058: IFFALSE 56062
// continue ;
56060: GO 56035
// if weapon in weapons then
56062: LD_VAR 0 8
56066: PUSH
56067: LD_VAR 0 9
56071: IN
56072: IFFALSE 56099
// begin result := [ i , weapon ] ;
56074: LD_ADDR_VAR 0 3
56078: PUSH
56079: LD_VAR 0 4
56083: PUSH
56084: LD_VAR 0 8
56088: PUSH
56089: EMPTY
56090: LIST
56091: LIST
56092: ST_TO_ADDR
// exit ;
56093: POP
56094: POP
56095: POP
56096: POP
56097: GO 56107
// end ; end ;
56099: GO 56035
56101: POP
56102: POP
// end ;
56103: GO 55921
56105: POP
56106: POP
// end ;
56107: LD_VAR 0 3
56111: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56112: LD_INT 0
56114: PPUSH
// if not side or side > 8 then
56115: LD_VAR 0 3
56119: NOT
56120: PUSH
56121: LD_VAR 0 3
56125: PUSH
56126: LD_INT 8
56128: GREATER
56129: OR
56130: IFFALSE 56134
// exit ;
56132: GO 56193
// if not range then
56134: LD_VAR 0 4
56138: NOT
56139: IFFALSE 56150
// range := - 12 ;
56141: LD_ADDR_VAR 0 4
56145: PUSH
56146: LD_INT 12
56148: NEG
56149: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56150: LD_VAR 0 1
56154: PPUSH
56155: LD_VAR 0 2
56159: PPUSH
56160: LD_VAR 0 3
56164: PPUSH
56165: LD_VAR 0 4
56169: PPUSH
56170: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56174: LD_VAR 0 1
56178: PPUSH
56179: LD_VAR 0 2
56183: PPUSH
56184: LD_VAR 0 3
56188: PPUSH
56189: CALL_OW 331
// end ;
56193: LD_VAR 0 5
56197: RET
// export function Video ( mode ) ; begin
56198: LD_INT 0
56200: PPUSH
// ingame_video = mode ;
56201: LD_ADDR_OWVAR 52
56205: PUSH
56206: LD_VAR 0 1
56210: ST_TO_ADDR
// interface_hidden = mode ;
56211: LD_ADDR_OWVAR 54
56215: PUSH
56216: LD_VAR 0 1
56220: ST_TO_ADDR
// end ;
56221: LD_VAR 0 2
56225: RET
// export function Join ( array , element ) ; begin
56226: LD_INT 0
56228: PPUSH
// result := array ^ element ;
56229: LD_ADDR_VAR 0 3
56233: PUSH
56234: LD_VAR 0 1
56238: PUSH
56239: LD_VAR 0 2
56243: ADD
56244: ST_TO_ADDR
// end ;
56245: LD_VAR 0 3
56249: RET
// export function JoinUnion ( array , element ) ; begin
56250: LD_INT 0
56252: PPUSH
// result := array union element ;
56253: LD_ADDR_VAR 0 3
56257: PUSH
56258: LD_VAR 0 1
56262: PUSH
56263: LD_VAR 0 2
56267: UNION
56268: ST_TO_ADDR
// end ;
56269: LD_VAR 0 3
56273: RET
// export function GetBehemoths ( side ) ; begin
56274: LD_INT 0
56276: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56277: LD_ADDR_VAR 0 2
56281: PUSH
56282: LD_INT 22
56284: PUSH
56285: LD_VAR 0 1
56289: PUSH
56290: EMPTY
56291: LIST
56292: LIST
56293: PUSH
56294: LD_INT 31
56296: PUSH
56297: LD_INT 25
56299: PUSH
56300: EMPTY
56301: LIST
56302: LIST
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: PPUSH
56308: CALL_OW 69
56312: ST_TO_ADDR
// end ;
56313: LD_VAR 0 2
56317: RET
// export function Shuffle ( array ) ; var i , index ; begin
56318: LD_INT 0
56320: PPUSH
56321: PPUSH
56322: PPUSH
// result := [ ] ;
56323: LD_ADDR_VAR 0 2
56327: PUSH
56328: EMPTY
56329: ST_TO_ADDR
// if not array then
56330: LD_VAR 0 1
56334: NOT
56335: IFFALSE 56339
// exit ;
56337: GO 56438
// Randomize ;
56339: CALL_OW 10
// for i = array downto 1 do
56343: LD_ADDR_VAR 0 3
56347: PUSH
56348: DOUBLE
56349: LD_VAR 0 1
56353: INC
56354: ST_TO_ADDR
56355: LD_INT 1
56357: PUSH
56358: FOR_DOWNTO
56359: IFFALSE 56436
// begin index := rand ( 1 , array ) ;
56361: LD_ADDR_VAR 0 4
56365: PUSH
56366: LD_INT 1
56368: PPUSH
56369: LD_VAR 0 1
56373: PPUSH
56374: CALL_OW 12
56378: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56379: LD_ADDR_VAR 0 2
56383: PUSH
56384: LD_VAR 0 2
56388: PPUSH
56389: LD_VAR 0 2
56393: PUSH
56394: LD_INT 1
56396: PLUS
56397: PPUSH
56398: LD_VAR 0 1
56402: PUSH
56403: LD_VAR 0 4
56407: ARRAY
56408: PPUSH
56409: CALL_OW 2
56413: ST_TO_ADDR
// array := Delete ( array , index ) ;
56414: LD_ADDR_VAR 0 1
56418: PUSH
56419: LD_VAR 0 1
56423: PPUSH
56424: LD_VAR 0 4
56428: PPUSH
56429: CALL_OW 3
56433: ST_TO_ADDR
// end ;
56434: GO 56358
56436: POP
56437: POP
// end ; end_of_file
56438: LD_VAR 0 2
56442: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56443: LD_INT 0
56445: PPUSH
56446: PPUSH
// skirmish := false ;
56447: LD_ADDR_EXP 56
56451: PUSH
56452: LD_INT 0
56454: ST_TO_ADDR
// debug_mc := false ;
56455: LD_ADDR_EXP 57
56459: PUSH
56460: LD_INT 0
56462: ST_TO_ADDR
// mc_bases := [ ] ;
56463: LD_ADDR_EXP 58
56467: PUSH
56468: EMPTY
56469: ST_TO_ADDR
// mc_sides := [ ] ;
56470: LD_ADDR_EXP 84
56474: PUSH
56475: EMPTY
56476: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56477: LD_ADDR_EXP 59
56481: PUSH
56482: EMPTY
56483: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56484: LD_ADDR_EXP 60
56488: PUSH
56489: EMPTY
56490: ST_TO_ADDR
// mc_need_heal := [ ] ;
56491: LD_ADDR_EXP 61
56495: PUSH
56496: EMPTY
56497: ST_TO_ADDR
// mc_healers := [ ] ;
56498: LD_ADDR_EXP 62
56502: PUSH
56503: EMPTY
56504: ST_TO_ADDR
// mc_build_list := [ ] ;
56505: LD_ADDR_EXP 63
56509: PUSH
56510: EMPTY
56511: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56512: LD_ADDR_EXP 90
56516: PUSH
56517: EMPTY
56518: ST_TO_ADDR
// mc_builders := [ ] ;
56519: LD_ADDR_EXP 64
56523: PUSH
56524: EMPTY
56525: ST_TO_ADDR
// mc_construct_list := [ ] ;
56526: LD_ADDR_EXP 65
56530: PUSH
56531: EMPTY
56532: ST_TO_ADDR
// mc_turret_list := [ ] ;
56533: LD_ADDR_EXP 66
56537: PUSH
56538: EMPTY
56539: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56540: LD_ADDR_EXP 67
56544: PUSH
56545: EMPTY
56546: ST_TO_ADDR
// mc_miners := [ ] ;
56547: LD_ADDR_EXP 72
56551: PUSH
56552: EMPTY
56553: ST_TO_ADDR
// mc_mines := [ ] ;
56554: LD_ADDR_EXP 71
56558: PUSH
56559: EMPTY
56560: ST_TO_ADDR
// mc_minefields := [ ] ;
56561: LD_ADDR_EXP 73
56565: PUSH
56566: EMPTY
56567: ST_TO_ADDR
// mc_crates := [ ] ;
56568: LD_ADDR_EXP 74
56572: PUSH
56573: EMPTY
56574: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56575: LD_ADDR_EXP 75
56579: PUSH
56580: EMPTY
56581: ST_TO_ADDR
// mc_crates_area := [ ] ;
56582: LD_ADDR_EXP 76
56586: PUSH
56587: EMPTY
56588: ST_TO_ADDR
// mc_vehicles := [ ] ;
56589: LD_ADDR_EXP 77
56593: PUSH
56594: EMPTY
56595: ST_TO_ADDR
// mc_attack := [ ] ;
56596: LD_ADDR_EXP 78
56600: PUSH
56601: EMPTY
56602: ST_TO_ADDR
// mc_produce := [ ] ;
56603: LD_ADDR_EXP 79
56607: PUSH
56608: EMPTY
56609: ST_TO_ADDR
// mc_defender := [ ] ;
56610: LD_ADDR_EXP 80
56614: PUSH
56615: EMPTY
56616: ST_TO_ADDR
// mc_parking := [ ] ;
56617: LD_ADDR_EXP 82
56621: PUSH
56622: EMPTY
56623: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56624: LD_ADDR_EXP 68
56628: PUSH
56629: EMPTY
56630: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56631: LD_ADDR_EXP 70
56635: PUSH
56636: EMPTY
56637: ST_TO_ADDR
// mc_scan := [ ] ;
56638: LD_ADDR_EXP 81
56642: PUSH
56643: EMPTY
56644: ST_TO_ADDR
// mc_scan_area := [ ] ;
56645: LD_ADDR_EXP 83
56649: PUSH
56650: EMPTY
56651: ST_TO_ADDR
// mc_tech := [ ] ;
56652: LD_ADDR_EXP 85
56656: PUSH
56657: EMPTY
56658: ST_TO_ADDR
// mc_class := [ ] ;
56659: LD_ADDR_EXP 99
56663: PUSH
56664: EMPTY
56665: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56666: LD_ADDR_EXP 100
56670: PUSH
56671: EMPTY
56672: ST_TO_ADDR
// end ;
56673: LD_VAR 0 1
56677: RET
// export function MC_Kill ( base ) ; begin
56678: LD_INT 0
56680: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56681: LD_ADDR_EXP 58
56685: PUSH
56686: LD_EXP 58
56690: PPUSH
56691: LD_VAR 0 1
56695: PPUSH
56696: EMPTY
56697: PPUSH
56698: CALL_OW 1
56702: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56703: LD_ADDR_EXP 59
56707: PUSH
56708: LD_EXP 59
56712: PPUSH
56713: LD_VAR 0 1
56717: PPUSH
56718: EMPTY
56719: PPUSH
56720: CALL_OW 1
56724: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56725: LD_ADDR_EXP 60
56729: PUSH
56730: LD_EXP 60
56734: PPUSH
56735: LD_VAR 0 1
56739: PPUSH
56740: EMPTY
56741: PPUSH
56742: CALL_OW 1
56746: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56747: LD_ADDR_EXP 61
56751: PUSH
56752: LD_EXP 61
56756: PPUSH
56757: LD_VAR 0 1
56761: PPUSH
56762: EMPTY
56763: PPUSH
56764: CALL_OW 1
56768: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56769: LD_ADDR_EXP 62
56773: PUSH
56774: LD_EXP 62
56778: PPUSH
56779: LD_VAR 0 1
56783: PPUSH
56784: EMPTY
56785: PPUSH
56786: CALL_OW 1
56790: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56791: LD_ADDR_EXP 63
56795: PUSH
56796: LD_EXP 63
56800: PPUSH
56801: LD_VAR 0 1
56805: PPUSH
56806: EMPTY
56807: PPUSH
56808: CALL_OW 1
56812: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56813: LD_ADDR_EXP 64
56817: PUSH
56818: LD_EXP 64
56822: PPUSH
56823: LD_VAR 0 1
56827: PPUSH
56828: EMPTY
56829: PPUSH
56830: CALL_OW 1
56834: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56835: LD_ADDR_EXP 65
56839: PUSH
56840: LD_EXP 65
56844: PPUSH
56845: LD_VAR 0 1
56849: PPUSH
56850: EMPTY
56851: PPUSH
56852: CALL_OW 1
56856: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56857: LD_ADDR_EXP 66
56861: PUSH
56862: LD_EXP 66
56866: PPUSH
56867: LD_VAR 0 1
56871: PPUSH
56872: EMPTY
56873: PPUSH
56874: CALL_OW 1
56878: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56879: LD_ADDR_EXP 67
56883: PUSH
56884: LD_EXP 67
56888: PPUSH
56889: LD_VAR 0 1
56893: PPUSH
56894: EMPTY
56895: PPUSH
56896: CALL_OW 1
56900: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56901: LD_ADDR_EXP 68
56905: PUSH
56906: LD_EXP 68
56910: PPUSH
56911: LD_VAR 0 1
56915: PPUSH
56916: EMPTY
56917: PPUSH
56918: CALL_OW 1
56922: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56923: LD_ADDR_EXP 69
56927: PUSH
56928: LD_EXP 69
56932: PPUSH
56933: LD_VAR 0 1
56937: PPUSH
56938: LD_INT 0
56940: PPUSH
56941: CALL_OW 1
56945: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56946: LD_ADDR_EXP 70
56950: PUSH
56951: LD_EXP 70
56955: PPUSH
56956: LD_VAR 0 1
56960: PPUSH
56961: EMPTY
56962: PPUSH
56963: CALL_OW 1
56967: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56968: LD_ADDR_EXP 71
56972: PUSH
56973: LD_EXP 71
56977: PPUSH
56978: LD_VAR 0 1
56982: PPUSH
56983: EMPTY
56984: PPUSH
56985: CALL_OW 1
56989: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56990: LD_ADDR_EXP 72
56994: PUSH
56995: LD_EXP 72
56999: PPUSH
57000: LD_VAR 0 1
57004: PPUSH
57005: EMPTY
57006: PPUSH
57007: CALL_OW 1
57011: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57012: LD_ADDR_EXP 73
57016: PUSH
57017: LD_EXP 73
57021: PPUSH
57022: LD_VAR 0 1
57026: PPUSH
57027: EMPTY
57028: PPUSH
57029: CALL_OW 1
57033: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57034: LD_ADDR_EXP 74
57038: PUSH
57039: LD_EXP 74
57043: PPUSH
57044: LD_VAR 0 1
57048: PPUSH
57049: EMPTY
57050: PPUSH
57051: CALL_OW 1
57055: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57056: LD_ADDR_EXP 75
57060: PUSH
57061: LD_EXP 75
57065: PPUSH
57066: LD_VAR 0 1
57070: PPUSH
57071: EMPTY
57072: PPUSH
57073: CALL_OW 1
57077: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57078: LD_ADDR_EXP 76
57082: PUSH
57083: LD_EXP 76
57087: PPUSH
57088: LD_VAR 0 1
57092: PPUSH
57093: EMPTY
57094: PPUSH
57095: CALL_OW 1
57099: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57100: LD_ADDR_EXP 77
57104: PUSH
57105: LD_EXP 77
57109: PPUSH
57110: LD_VAR 0 1
57114: PPUSH
57115: EMPTY
57116: PPUSH
57117: CALL_OW 1
57121: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57122: LD_ADDR_EXP 78
57126: PUSH
57127: LD_EXP 78
57131: PPUSH
57132: LD_VAR 0 1
57136: PPUSH
57137: EMPTY
57138: PPUSH
57139: CALL_OW 1
57143: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57144: LD_ADDR_EXP 79
57148: PUSH
57149: LD_EXP 79
57153: PPUSH
57154: LD_VAR 0 1
57158: PPUSH
57159: EMPTY
57160: PPUSH
57161: CALL_OW 1
57165: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57166: LD_ADDR_EXP 80
57170: PUSH
57171: LD_EXP 80
57175: PPUSH
57176: LD_VAR 0 1
57180: PPUSH
57181: EMPTY
57182: PPUSH
57183: CALL_OW 1
57187: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57188: LD_ADDR_EXP 81
57192: PUSH
57193: LD_EXP 81
57197: PPUSH
57198: LD_VAR 0 1
57202: PPUSH
57203: EMPTY
57204: PPUSH
57205: CALL_OW 1
57209: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57210: LD_ADDR_EXP 82
57214: PUSH
57215: LD_EXP 82
57219: PPUSH
57220: LD_VAR 0 1
57224: PPUSH
57225: EMPTY
57226: PPUSH
57227: CALL_OW 1
57231: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57232: LD_ADDR_EXP 83
57236: PUSH
57237: LD_EXP 83
57241: PPUSH
57242: LD_VAR 0 1
57246: PPUSH
57247: EMPTY
57248: PPUSH
57249: CALL_OW 1
57253: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57254: LD_ADDR_EXP 85
57258: PUSH
57259: LD_EXP 85
57263: PPUSH
57264: LD_VAR 0 1
57268: PPUSH
57269: EMPTY
57270: PPUSH
57271: CALL_OW 1
57275: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57276: LD_ADDR_EXP 87
57280: PUSH
57281: LD_EXP 87
57285: PPUSH
57286: LD_VAR 0 1
57290: PPUSH
57291: EMPTY
57292: PPUSH
57293: CALL_OW 1
57297: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57298: LD_ADDR_EXP 88
57302: PUSH
57303: LD_EXP 88
57307: PPUSH
57308: LD_VAR 0 1
57312: PPUSH
57313: EMPTY
57314: PPUSH
57315: CALL_OW 1
57319: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57320: LD_ADDR_EXP 89
57324: PUSH
57325: LD_EXP 89
57329: PPUSH
57330: LD_VAR 0 1
57334: PPUSH
57335: EMPTY
57336: PPUSH
57337: CALL_OW 1
57341: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57342: LD_ADDR_EXP 90
57346: PUSH
57347: LD_EXP 90
57351: PPUSH
57352: LD_VAR 0 1
57356: PPUSH
57357: EMPTY
57358: PPUSH
57359: CALL_OW 1
57363: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57364: LD_ADDR_EXP 91
57368: PUSH
57369: LD_EXP 91
57373: PPUSH
57374: LD_VAR 0 1
57378: PPUSH
57379: EMPTY
57380: PPUSH
57381: CALL_OW 1
57385: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57386: LD_ADDR_EXP 92
57390: PUSH
57391: LD_EXP 92
57395: PPUSH
57396: LD_VAR 0 1
57400: PPUSH
57401: EMPTY
57402: PPUSH
57403: CALL_OW 1
57407: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57408: LD_ADDR_EXP 93
57412: PUSH
57413: LD_EXP 93
57417: PPUSH
57418: LD_VAR 0 1
57422: PPUSH
57423: EMPTY
57424: PPUSH
57425: CALL_OW 1
57429: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57430: LD_ADDR_EXP 94
57434: PUSH
57435: LD_EXP 94
57439: PPUSH
57440: LD_VAR 0 1
57444: PPUSH
57445: EMPTY
57446: PPUSH
57447: CALL_OW 1
57451: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57452: LD_ADDR_EXP 95
57456: PUSH
57457: LD_EXP 95
57461: PPUSH
57462: LD_VAR 0 1
57466: PPUSH
57467: EMPTY
57468: PPUSH
57469: CALL_OW 1
57473: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57474: LD_ADDR_EXP 96
57478: PUSH
57479: LD_EXP 96
57483: PPUSH
57484: LD_VAR 0 1
57488: PPUSH
57489: EMPTY
57490: PPUSH
57491: CALL_OW 1
57495: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57496: LD_ADDR_EXP 97
57500: PUSH
57501: LD_EXP 97
57505: PPUSH
57506: LD_VAR 0 1
57510: PPUSH
57511: EMPTY
57512: PPUSH
57513: CALL_OW 1
57517: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57518: LD_ADDR_EXP 98
57522: PUSH
57523: LD_EXP 98
57527: PPUSH
57528: LD_VAR 0 1
57532: PPUSH
57533: EMPTY
57534: PPUSH
57535: CALL_OW 1
57539: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57540: LD_ADDR_EXP 99
57544: PUSH
57545: LD_EXP 99
57549: PPUSH
57550: LD_VAR 0 1
57554: PPUSH
57555: EMPTY
57556: PPUSH
57557: CALL_OW 1
57561: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57562: LD_ADDR_EXP 100
57566: PUSH
57567: LD_EXP 100
57571: PPUSH
57572: LD_VAR 0 1
57576: PPUSH
57577: LD_INT 0
57579: PPUSH
57580: CALL_OW 1
57584: ST_TO_ADDR
// end ;
57585: LD_VAR 0 2
57589: RET
// export function MC_Start ( ) ; var i ; begin
57590: LD_INT 0
57592: PPUSH
57593: PPUSH
// for i = 1 to mc_bases do
57594: LD_ADDR_VAR 0 2
57598: PUSH
57599: DOUBLE
57600: LD_INT 1
57602: DEC
57603: ST_TO_ADDR
57604: LD_EXP 58
57608: PUSH
57609: FOR_TO
57610: IFFALSE 58687
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57612: LD_ADDR_EXP 58
57616: PUSH
57617: LD_EXP 58
57621: PPUSH
57622: LD_VAR 0 2
57626: PPUSH
57627: LD_EXP 58
57631: PUSH
57632: LD_VAR 0 2
57636: ARRAY
57637: PUSH
57638: LD_INT 0
57640: DIFF
57641: PPUSH
57642: CALL_OW 1
57646: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57647: LD_ADDR_EXP 59
57651: PUSH
57652: LD_EXP 59
57656: PPUSH
57657: LD_VAR 0 2
57661: PPUSH
57662: EMPTY
57663: PPUSH
57664: CALL_OW 1
57668: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57669: LD_ADDR_EXP 60
57673: PUSH
57674: LD_EXP 60
57678: PPUSH
57679: LD_VAR 0 2
57683: PPUSH
57684: EMPTY
57685: PPUSH
57686: CALL_OW 1
57690: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57691: LD_ADDR_EXP 61
57695: PUSH
57696: LD_EXP 61
57700: PPUSH
57701: LD_VAR 0 2
57705: PPUSH
57706: EMPTY
57707: PPUSH
57708: CALL_OW 1
57712: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57713: LD_ADDR_EXP 62
57717: PUSH
57718: LD_EXP 62
57722: PPUSH
57723: LD_VAR 0 2
57727: PPUSH
57728: EMPTY
57729: PUSH
57730: EMPTY
57731: PUSH
57732: EMPTY
57733: LIST
57734: LIST
57735: PPUSH
57736: CALL_OW 1
57740: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57741: LD_ADDR_EXP 63
57745: PUSH
57746: LD_EXP 63
57750: PPUSH
57751: LD_VAR 0 2
57755: PPUSH
57756: EMPTY
57757: PPUSH
57758: CALL_OW 1
57762: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57763: LD_ADDR_EXP 90
57767: PUSH
57768: LD_EXP 90
57772: PPUSH
57773: LD_VAR 0 2
57777: PPUSH
57778: EMPTY
57779: PPUSH
57780: CALL_OW 1
57784: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57785: LD_ADDR_EXP 64
57789: PUSH
57790: LD_EXP 64
57794: PPUSH
57795: LD_VAR 0 2
57799: PPUSH
57800: EMPTY
57801: PPUSH
57802: CALL_OW 1
57806: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57807: LD_ADDR_EXP 65
57811: PUSH
57812: LD_EXP 65
57816: PPUSH
57817: LD_VAR 0 2
57821: PPUSH
57822: EMPTY
57823: PPUSH
57824: CALL_OW 1
57828: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57829: LD_ADDR_EXP 66
57833: PUSH
57834: LD_EXP 66
57838: PPUSH
57839: LD_VAR 0 2
57843: PPUSH
57844: LD_EXP 58
57848: PUSH
57849: LD_VAR 0 2
57853: ARRAY
57854: PPUSH
57855: LD_INT 2
57857: PUSH
57858: LD_INT 30
57860: PUSH
57861: LD_INT 32
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PUSH
57868: LD_INT 30
57870: PUSH
57871: LD_INT 33
57873: PUSH
57874: EMPTY
57875: LIST
57876: LIST
57877: PUSH
57878: EMPTY
57879: LIST
57880: LIST
57881: LIST
57882: PPUSH
57883: CALL_OW 72
57887: PPUSH
57888: CALL_OW 1
57892: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57893: LD_ADDR_EXP 67
57897: PUSH
57898: LD_EXP 67
57902: PPUSH
57903: LD_VAR 0 2
57907: PPUSH
57908: LD_EXP 58
57912: PUSH
57913: LD_VAR 0 2
57917: ARRAY
57918: PPUSH
57919: LD_INT 2
57921: PUSH
57922: LD_INT 30
57924: PUSH
57925: LD_INT 32
57927: PUSH
57928: EMPTY
57929: LIST
57930: LIST
57931: PUSH
57932: LD_INT 30
57934: PUSH
57935: LD_INT 31
57937: PUSH
57938: EMPTY
57939: LIST
57940: LIST
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: LIST
57946: PUSH
57947: LD_INT 58
57949: PUSH
57950: EMPTY
57951: LIST
57952: PUSH
57953: EMPTY
57954: LIST
57955: LIST
57956: PPUSH
57957: CALL_OW 72
57961: PPUSH
57962: CALL_OW 1
57966: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57967: LD_ADDR_EXP 68
57971: PUSH
57972: LD_EXP 68
57976: PPUSH
57977: LD_VAR 0 2
57981: PPUSH
57982: EMPTY
57983: PPUSH
57984: CALL_OW 1
57988: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57989: LD_ADDR_EXP 72
57993: PUSH
57994: LD_EXP 72
57998: PPUSH
57999: LD_VAR 0 2
58003: PPUSH
58004: EMPTY
58005: PPUSH
58006: CALL_OW 1
58010: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58011: LD_ADDR_EXP 71
58015: PUSH
58016: LD_EXP 71
58020: PPUSH
58021: LD_VAR 0 2
58025: PPUSH
58026: EMPTY
58027: PPUSH
58028: CALL_OW 1
58032: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58033: LD_ADDR_EXP 73
58037: PUSH
58038: LD_EXP 73
58042: PPUSH
58043: LD_VAR 0 2
58047: PPUSH
58048: EMPTY
58049: PPUSH
58050: CALL_OW 1
58054: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58055: LD_ADDR_EXP 74
58059: PUSH
58060: LD_EXP 74
58064: PPUSH
58065: LD_VAR 0 2
58069: PPUSH
58070: EMPTY
58071: PPUSH
58072: CALL_OW 1
58076: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58077: LD_ADDR_EXP 75
58081: PUSH
58082: LD_EXP 75
58086: PPUSH
58087: LD_VAR 0 2
58091: PPUSH
58092: EMPTY
58093: PPUSH
58094: CALL_OW 1
58098: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
58099: LD_ADDR_EXP 76
58103: PUSH
58104: LD_EXP 76
58108: PPUSH
58109: LD_VAR 0 2
58113: PPUSH
58114: EMPTY
58115: PPUSH
58116: CALL_OW 1
58120: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
58121: LD_ADDR_EXP 77
58125: PUSH
58126: LD_EXP 77
58130: PPUSH
58131: LD_VAR 0 2
58135: PPUSH
58136: EMPTY
58137: PPUSH
58138: CALL_OW 1
58142: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
58143: LD_ADDR_EXP 78
58147: PUSH
58148: LD_EXP 78
58152: PPUSH
58153: LD_VAR 0 2
58157: PPUSH
58158: EMPTY
58159: PPUSH
58160: CALL_OW 1
58164: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
58165: LD_ADDR_EXP 79
58169: PUSH
58170: LD_EXP 79
58174: PPUSH
58175: LD_VAR 0 2
58179: PPUSH
58180: EMPTY
58181: PPUSH
58182: CALL_OW 1
58186: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58187: LD_ADDR_EXP 80
58191: PUSH
58192: LD_EXP 80
58196: PPUSH
58197: LD_VAR 0 2
58201: PPUSH
58202: EMPTY
58203: PPUSH
58204: CALL_OW 1
58208: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58209: LD_ADDR_EXP 69
58213: PUSH
58214: LD_EXP 69
58218: PPUSH
58219: LD_VAR 0 2
58223: PPUSH
58224: LD_INT 0
58226: PPUSH
58227: CALL_OW 1
58231: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58232: LD_ADDR_EXP 82
58236: PUSH
58237: LD_EXP 82
58241: PPUSH
58242: LD_VAR 0 2
58246: PPUSH
58247: LD_INT 0
58249: PPUSH
58250: CALL_OW 1
58254: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58255: LD_ADDR_EXP 70
58259: PUSH
58260: LD_EXP 70
58264: PPUSH
58265: LD_VAR 0 2
58269: PPUSH
58270: EMPTY
58271: PPUSH
58272: CALL_OW 1
58276: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58277: LD_ADDR_EXP 81
58281: PUSH
58282: LD_EXP 81
58286: PPUSH
58287: LD_VAR 0 2
58291: PPUSH
58292: LD_INT 0
58294: PPUSH
58295: CALL_OW 1
58299: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58300: LD_ADDR_EXP 83
58304: PUSH
58305: LD_EXP 83
58309: PPUSH
58310: LD_VAR 0 2
58314: PPUSH
58315: EMPTY
58316: PPUSH
58317: CALL_OW 1
58321: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58322: LD_ADDR_EXP 86
58326: PUSH
58327: LD_EXP 86
58331: PPUSH
58332: LD_VAR 0 2
58336: PPUSH
58337: LD_INT 0
58339: PPUSH
58340: CALL_OW 1
58344: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58345: LD_ADDR_EXP 87
58349: PUSH
58350: LD_EXP 87
58354: PPUSH
58355: LD_VAR 0 2
58359: PPUSH
58360: EMPTY
58361: PPUSH
58362: CALL_OW 1
58366: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58367: LD_ADDR_EXP 88
58371: PUSH
58372: LD_EXP 88
58376: PPUSH
58377: LD_VAR 0 2
58381: PPUSH
58382: EMPTY
58383: PPUSH
58384: CALL_OW 1
58388: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58389: LD_ADDR_EXP 89
58393: PUSH
58394: LD_EXP 89
58398: PPUSH
58399: LD_VAR 0 2
58403: PPUSH
58404: EMPTY
58405: PPUSH
58406: CALL_OW 1
58410: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58411: LD_ADDR_EXP 91
58415: PUSH
58416: LD_EXP 91
58420: PPUSH
58421: LD_VAR 0 2
58425: PPUSH
58426: LD_EXP 58
58430: PUSH
58431: LD_VAR 0 2
58435: ARRAY
58436: PPUSH
58437: LD_INT 2
58439: PUSH
58440: LD_INT 30
58442: PUSH
58443: LD_INT 6
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: PUSH
58450: LD_INT 30
58452: PUSH
58453: LD_INT 7
58455: PUSH
58456: EMPTY
58457: LIST
58458: LIST
58459: PUSH
58460: LD_INT 30
58462: PUSH
58463: LD_INT 8
58465: PUSH
58466: EMPTY
58467: LIST
58468: LIST
58469: PUSH
58470: EMPTY
58471: LIST
58472: LIST
58473: LIST
58474: LIST
58475: PPUSH
58476: CALL_OW 72
58480: PPUSH
58481: CALL_OW 1
58485: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58486: LD_ADDR_EXP 92
58490: PUSH
58491: LD_EXP 92
58495: PPUSH
58496: LD_VAR 0 2
58500: PPUSH
58501: EMPTY
58502: PPUSH
58503: CALL_OW 1
58507: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58508: LD_ADDR_EXP 93
58512: PUSH
58513: LD_EXP 93
58517: PPUSH
58518: LD_VAR 0 2
58522: PPUSH
58523: EMPTY
58524: PPUSH
58525: CALL_OW 1
58529: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58530: LD_ADDR_EXP 94
58534: PUSH
58535: LD_EXP 94
58539: PPUSH
58540: LD_VAR 0 2
58544: PPUSH
58545: EMPTY
58546: PPUSH
58547: CALL_OW 1
58551: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58552: LD_ADDR_EXP 95
58556: PUSH
58557: LD_EXP 95
58561: PPUSH
58562: LD_VAR 0 2
58566: PPUSH
58567: EMPTY
58568: PPUSH
58569: CALL_OW 1
58573: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58574: LD_ADDR_EXP 96
58578: PUSH
58579: LD_EXP 96
58583: PPUSH
58584: LD_VAR 0 2
58588: PPUSH
58589: EMPTY
58590: PPUSH
58591: CALL_OW 1
58595: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58596: LD_ADDR_EXP 97
58600: PUSH
58601: LD_EXP 97
58605: PPUSH
58606: LD_VAR 0 2
58610: PPUSH
58611: EMPTY
58612: PPUSH
58613: CALL_OW 1
58617: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58618: LD_ADDR_EXP 98
58622: PUSH
58623: LD_EXP 98
58627: PPUSH
58628: LD_VAR 0 2
58632: PPUSH
58633: EMPTY
58634: PPUSH
58635: CALL_OW 1
58639: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58640: LD_ADDR_EXP 99
58644: PUSH
58645: LD_EXP 99
58649: PPUSH
58650: LD_VAR 0 2
58654: PPUSH
58655: EMPTY
58656: PPUSH
58657: CALL_OW 1
58661: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58662: LD_ADDR_EXP 100
58666: PUSH
58667: LD_EXP 100
58671: PPUSH
58672: LD_VAR 0 2
58676: PPUSH
58677: LD_INT 0
58679: PPUSH
58680: CALL_OW 1
58684: ST_TO_ADDR
// end ;
58685: GO 57609
58687: POP
58688: POP
// MC_InitSides ( ) ;
58689: CALL 58975 0 0
// MC_InitResearch ( ) ;
58693: CALL 58714 0 0
// CustomInitMacro ( ) ;
58697: CALL 174 0 0
// skirmish := true ;
58701: LD_ADDR_EXP 56
58705: PUSH
58706: LD_INT 1
58708: ST_TO_ADDR
// end ;
58709: LD_VAR 0 1
58713: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58714: LD_INT 0
58716: PPUSH
58717: PPUSH
58718: PPUSH
58719: PPUSH
58720: PPUSH
58721: PPUSH
// if not mc_bases then
58722: LD_EXP 58
58726: NOT
58727: IFFALSE 58731
// exit ;
58729: GO 58970
// for i = 1 to 8 do
58731: LD_ADDR_VAR 0 2
58735: PUSH
58736: DOUBLE
58737: LD_INT 1
58739: DEC
58740: ST_TO_ADDR
58741: LD_INT 8
58743: PUSH
58744: FOR_TO
58745: IFFALSE 58771
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58747: LD_ADDR_EXP 85
58751: PUSH
58752: LD_EXP 85
58756: PPUSH
58757: LD_VAR 0 2
58761: PPUSH
58762: EMPTY
58763: PPUSH
58764: CALL_OW 1
58768: ST_TO_ADDR
58769: GO 58744
58771: POP
58772: POP
// tmp := [ ] ;
58773: LD_ADDR_VAR 0 5
58777: PUSH
58778: EMPTY
58779: ST_TO_ADDR
// for i = 1 to mc_sides do
58780: LD_ADDR_VAR 0 2
58784: PUSH
58785: DOUBLE
58786: LD_INT 1
58788: DEC
58789: ST_TO_ADDR
58790: LD_EXP 84
58794: PUSH
58795: FOR_TO
58796: IFFALSE 58854
// if not mc_sides [ i ] in tmp then
58798: LD_EXP 84
58802: PUSH
58803: LD_VAR 0 2
58807: ARRAY
58808: PUSH
58809: LD_VAR 0 5
58813: IN
58814: NOT
58815: IFFALSE 58852
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58817: LD_ADDR_VAR 0 5
58821: PUSH
58822: LD_VAR 0 5
58826: PPUSH
58827: LD_VAR 0 5
58831: PUSH
58832: LD_INT 1
58834: PLUS
58835: PPUSH
58836: LD_EXP 84
58840: PUSH
58841: LD_VAR 0 2
58845: ARRAY
58846: PPUSH
58847: CALL_OW 2
58851: ST_TO_ADDR
58852: GO 58795
58854: POP
58855: POP
// if not tmp then
58856: LD_VAR 0 5
58860: NOT
58861: IFFALSE 58865
// exit ;
58863: GO 58970
// for j in tmp do
58865: LD_ADDR_VAR 0 3
58869: PUSH
58870: LD_VAR 0 5
58874: PUSH
58875: FOR_IN
58876: IFFALSE 58968
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58878: LD_ADDR_VAR 0 6
58882: PUSH
58883: LD_INT 22
58885: PUSH
58886: LD_VAR 0 3
58890: PUSH
58891: EMPTY
58892: LIST
58893: LIST
58894: PPUSH
58895: CALL_OW 69
58899: ST_TO_ADDR
// if not un then
58900: LD_VAR 0 6
58904: NOT
58905: IFFALSE 58909
// continue ;
58907: GO 58875
// nation := GetNation ( un [ 1 ] ) ;
58909: LD_ADDR_VAR 0 4
58913: PUSH
58914: LD_VAR 0 6
58918: PUSH
58919: LD_INT 1
58921: ARRAY
58922: PPUSH
58923: CALL_OW 248
58927: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58928: LD_ADDR_EXP 85
58932: PUSH
58933: LD_EXP 85
58937: PPUSH
58938: LD_VAR 0 3
58942: PPUSH
58943: LD_VAR 0 3
58947: PPUSH
58948: LD_VAR 0 4
58952: PPUSH
58953: LD_INT 1
58955: PPUSH
58956: CALL 13973 0 3
58960: PPUSH
58961: CALL_OW 1
58965: ST_TO_ADDR
// end ;
58966: GO 58875
58968: POP
58969: POP
// end ;
58970: LD_VAR 0 1
58974: RET
// export function MC_InitSides ( ) ; var i ; begin
58975: LD_INT 0
58977: PPUSH
58978: PPUSH
// if not mc_bases then
58979: LD_EXP 58
58983: NOT
58984: IFFALSE 58988
// exit ;
58986: GO 59062
// for i = 1 to mc_bases do
58988: LD_ADDR_VAR 0 2
58992: PUSH
58993: DOUBLE
58994: LD_INT 1
58996: DEC
58997: ST_TO_ADDR
58998: LD_EXP 58
59002: PUSH
59003: FOR_TO
59004: IFFALSE 59060
// if mc_bases [ i ] then
59006: LD_EXP 58
59010: PUSH
59011: LD_VAR 0 2
59015: ARRAY
59016: IFFALSE 59058
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59018: LD_ADDR_EXP 84
59022: PUSH
59023: LD_EXP 84
59027: PPUSH
59028: LD_VAR 0 2
59032: PPUSH
59033: LD_EXP 58
59037: PUSH
59038: LD_VAR 0 2
59042: ARRAY
59043: PUSH
59044: LD_INT 1
59046: ARRAY
59047: PPUSH
59048: CALL_OW 255
59052: PPUSH
59053: CALL_OW 1
59057: ST_TO_ADDR
59058: GO 59003
59060: POP
59061: POP
// end ;
59062: LD_VAR 0 1
59066: RET
// every 0 0$01 trigger skirmish do
59067: LD_EXP 56
59071: IFFALSE 59225
59073: GO 59075
59075: DISABLE
// begin enable ;
59076: ENABLE
// MC_CheckBuildings ( ) ;
59077: CALL 63714 0 0
// MC_CheckPeopleLife ( ) ;
59081: CALL 63839 0 0
// RaiseSailEvent ( 100 ) ;
59085: LD_INT 100
59087: PPUSH
59088: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
59092: LD_INT 103
59094: PPUSH
59095: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
59099: LD_INT 104
59101: PPUSH
59102: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
59106: LD_INT 105
59108: PPUSH
59109: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
59113: LD_INT 106
59115: PPUSH
59116: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
59120: LD_INT 107
59122: PPUSH
59123: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
59127: LD_INT 108
59129: PPUSH
59130: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
59134: LD_INT 109
59136: PPUSH
59137: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
59141: LD_INT 110
59143: PPUSH
59144: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
59148: LD_INT 111
59150: PPUSH
59151: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
59155: LD_INT 112
59157: PPUSH
59158: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
59162: LD_INT 113
59164: PPUSH
59165: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59169: LD_INT 120
59171: PPUSH
59172: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59176: LD_INT 121
59178: PPUSH
59179: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59183: LD_INT 122
59185: PPUSH
59186: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59190: LD_INT 123
59192: PPUSH
59193: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59197: LD_INT 124
59199: PPUSH
59200: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59204: LD_INT 125
59206: PPUSH
59207: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59211: LD_INT 126
59213: PPUSH
59214: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59218: LD_INT 200
59220: PPUSH
59221: CALL_OW 427
// end ;
59225: END
// on SailEvent ( event ) do begin if event < 100 then
59226: LD_VAR 0 1
59230: PUSH
59231: LD_INT 100
59233: LESS
59234: IFFALSE 59245
// CustomEvent ( event ) ;
59236: LD_VAR 0 1
59240: PPUSH
59241: CALL 12687 0 1
// if event = 100 then
59245: LD_VAR 0 1
59249: PUSH
59250: LD_INT 100
59252: EQUAL
59253: IFFALSE 59259
// MC_ClassManager ( ) ;
59255: CALL 59651 0 0
// if event = 101 then
59259: LD_VAR 0 1
59263: PUSH
59264: LD_INT 101
59266: EQUAL
59267: IFFALSE 59273
// MC_RepairBuildings ( ) ;
59269: CALL 64435 0 0
// if event = 102 then
59273: LD_VAR 0 1
59277: PUSH
59278: LD_INT 102
59280: EQUAL
59281: IFFALSE 59287
// MC_Heal ( ) ;
59283: CALL 64841 0 0
// if event = 103 then
59287: LD_VAR 0 1
59291: PUSH
59292: LD_INT 103
59294: EQUAL
59295: IFFALSE 59301
// MC_Build ( ) ;
59297: CALL 65263 0 0
// if event = 104 then
59301: LD_VAR 0 1
59305: PUSH
59306: LD_INT 104
59308: EQUAL
59309: IFFALSE 59315
// MC_TurretWeapon ( ) ;
59311: CALL 66876 0 0
// if event = 105 then
59315: LD_VAR 0 1
59319: PUSH
59320: LD_INT 105
59322: EQUAL
59323: IFFALSE 59329
// MC_BuildUpgrade ( ) ;
59325: CALL 66427 0 0
// if event = 106 then
59329: LD_VAR 0 1
59333: PUSH
59334: LD_INT 106
59336: EQUAL
59337: IFFALSE 59343
// MC_PlantMines ( ) ;
59339: CALL 67306 0 0
// if event = 107 then
59343: LD_VAR 0 1
59347: PUSH
59348: LD_INT 107
59350: EQUAL
59351: IFFALSE 59357
// MC_CollectCrates ( ) ;
59353: CALL 68340 0 0
// if event = 108 then
59357: LD_VAR 0 1
59361: PUSH
59362: LD_INT 108
59364: EQUAL
59365: IFFALSE 59371
// MC_LinkRemoteControl ( ) ;
59367: CALL 70097 0 0
// if event = 109 then
59371: LD_VAR 0 1
59375: PUSH
59376: LD_INT 109
59378: EQUAL
59379: IFFALSE 59385
// MC_ProduceVehicle ( ) ;
59381: CALL 70278 0 0
// if event = 110 then
59385: LD_VAR 0 1
59389: PUSH
59390: LD_INT 110
59392: EQUAL
59393: IFFALSE 59399
// MC_SendAttack ( ) ;
59395: CALL 70759 0 0
// if event = 111 then
59399: LD_VAR 0 1
59403: PUSH
59404: LD_INT 111
59406: EQUAL
59407: IFFALSE 59413
// MC_Defend ( ) ;
59409: CALL 70867 0 0
// if event = 112 then
59413: LD_VAR 0 1
59417: PUSH
59418: LD_INT 112
59420: EQUAL
59421: IFFALSE 59427
// MC_Research ( ) ;
59423: CALL 71494 0 0
// if event = 113 then
59427: LD_VAR 0 1
59431: PUSH
59432: LD_INT 113
59434: EQUAL
59435: IFFALSE 59441
// MC_MinesTrigger ( ) ;
59437: CALL 72608 0 0
// if event = 120 then
59441: LD_VAR 0 1
59445: PUSH
59446: LD_INT 120
59448: EQUAL
59449: IFFALSE 59455
// MC_RepairVehicle ( ) ;
59451: CALL 72707 0 0
// if event = 121 then
59455: LD_VAR 0 1
59459: PUSH
59460: LD_INT 121
59462: EQUAL
59463: IFFALSE 59469
// MC_TameApe ( ) ;
59465: CALL 73450 0 0
// if event = 122 then
59469: LD_VAR 0 1
59473: PUSH
59474: LD_INT 122
59476: EQUAL
59477: IFFALSE 59483
// MC_ChangeApeClass ( ) ;
59479: CALL 74279 0 0
// if event = 123 then
59483: LD_VAR 0 1
59487: PUSH
59488: LD_INT 123
59490: EQUAL
59491: IFFALSE 59497
// MC_Bazooka ( ) ;
59493: CALL 74929 0 0
// if event = 124 then
59497: LD_VAR 0 1
59501: PUSH
59502: LD_INT 124
59504: EQUAL
59505: IFFALSE 59511
// MC_TeleportExit ( ) ;
59507: CALL 75127 0 0
// if event = 125 then
59511: LD_VAR 0 1
59515: PUSH
59516: LD_INT 125
59518: EQUAL
59519: IFFALSE 59525
// MC_Deposits ( ) ;
59521: CALL 75774 0 0
// if event = 126 then
59525: LD_VAR 0 1
59529: PUSH
59530: LD_INT 126
59532: EQUAL
59533: IFFALSE 59539
// MC_RemoteDriver ( ) ;
59535: CALL 76399 0 0
// if event = 200 then
59539: LD_VAR 0 1
59543: PUSH
59544: LD_INT 200
59546: EQUAL
59547: IFFALSE 59553
// MC_Idle ( ) ;
59549: CALL 78132 0 0
// end ;
59553: PPOPN 1
59555: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59556: LD_INT 0
59558: PPUSH
59559: PPUSH
// if not mc_bases [ base ] or not tag then
59560: LD_EXP 58
59564: PUSH
59565: LD_VAR 0 1
59569: ARRAY
59570: NOT
59571: PUSH
59572: LD_VAR 0 2
59576: NOT
59577: OR
59578: IFFALSE 59582
// exit ;
59580: GO 59646
// for i in mc_bases [ base ] union mc_ape [ base ] do
59582: LD_ADDR_VAR 0 4
59586: PUSH
59587: LD_EXP 58
59591: PUSH
59592: LD_VAR 0 1
59596: ARRAY
59597: PUSH
59598: LD_EXP 87
59602: PUSH
59603: LD_VAR 0 1
59607: ARRAY
59608: UNION
59609: PUSH
59610: FOR_IN
59611: IFFALSE 59644
// if GetTag ( i ) = tag then
59613: LD_VAR 0 4
59617: PPUSH
59618: CALL_OW 110
59622: PUSH
59623: LD_VAR 0 2
59627: EQUAL
59628: IFFALSE 59642
// SetTag ( i , 0 ) ;
59630: LD_VAR 0 4
59634: PPUSH
59635: LD_INT 0
59637: PPUSH
59638: CALL_OW 109
59642: GO 59610
59644: POP
59645: POP
// end ;
59646: LD_VAR 0 3
59650: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59651: LD_INT 0
59653: PPUSH
59654: PPUSH
59655: PPUSH
59656: PPUSH
59657: PPUSH
59658: PPUSH
59659: PPUSH
59660: PPUSH
// if not mc_bases then
59661: LD_EXP 58
59665: NOT
59666: IFFALSE 59670
// exit ;
59668: GO 60128
// for i = 1 to mc_bases do
59670: LD_ADDR_VAR 0 2
59674: PUSH
59675: DOUBLE
59676: LD_INT 1
59678: DEC
59679: ST_TO_ADDR
59680: LD_EXP 58
59684: PUSH
59685: FOR_TO
59686: IFFALSE 60126
// begin tmp := MC_ClassCheckReq ( i ) ;
59688: LD_ADDR_VAR 0 4
59692: PUSH
59693: LD_VAR 0 2
59697: PPUSH
59698: CALL 60133 0 1
59702: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59703: LD_ADDR_EXP 99
59707: PUSH
59708: LD_EXP 99
59712: PPUSH
59713: LD_VAR 0 2
59717: PPUSH
59718: LD_VAR 0 4
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// if not tmp then
59728: LD_VAR 0 4
59732: NOT
59733: IFFALSE 59737
// continue ;
59735: GO 59685
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59737: LD_ADDR_VAR 0 6
59741: PUSH
59742: LD_EXP 58
59746: PUSH
59747: LD_VAR 0 2
59751: ARRAY
59752: PPUSH
59753: LD_INT 2
59755: PUSH
59756: LD_INT 30
59758: PUSH
59759: LD_INT 4
59761: PUSH
59762: EMPTY
59763: LIST
59764: LIST
59765: PUSH
59766: LD_INT 30
59768: PUSH
59769: LD_INT 5
59771: PUSH
59772: EMPTY
59773: LIST
59774: LIST
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: LIST
59780: PPUSH
59781: CALL_OW 72
59785: PUSH
59786: LD_EXP 58
59790: PUSH
59791: LD_VAR 0 2
59795: ARRAY
59796: PPUSH
59797: LD_INT 2
59799: PUSH
59800: LD_INT 30
59802: PUSH
59803: LD_INT 0
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: PUSH
59810: LD_INT 30
59812: PUSH
59813: LD_INT 1
59815: PUSH
59816: EMPTY
59817: LIST
59818: LIST
59819: PUSH
59820: EMPTY
59821: LIST
59822: LIST
59823: LIST
59824: PPUSH
59825: CALL_OW 72
59829: PUSH
59830: LD_EXP 58
59834: PUSH
59835: LD_VAR 0 2
59839: ARRAY
59840: PPUSH
59841: LD_INT 30
59843: PUSH
59844: LD_INT 3
59846: PUSH
59847: EMPTY
59848: LIST
59849: LIST
59850: PPUSH
59851: CALL_OW 72
59855: PUSH
59856: LD_EXP 58
59860: PUSH
59861: LD_VAR 0 2
59865: ARRAY
59866: PPUSH
59867: LD_INT 2
59869: PUSH
59870: LD_INT 30
59872: PUSH
59873: LD_INT 6
59875: PUSH
59876: EMPTY
59877: LIST
59878: LIST
59879: PUSH
59880: LD_INT 30
59882: PUSH
59883: LD_INT 7
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: PUSH
59890: LD_INT 30
59892: PUSH
59893: LD_INT 8
59895: PUSH
59896: EMPTY
59897: LIST
59898: LIST
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: LIST
59904: LIST
59905: PPUSH
59906: CALL_OW 72
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: LIST
59915: LIST
59916: ST_TO_ADDR
// for j = 1 to 4 do
59917: LD_ADDR_VAR 0 3
59921: PUSH
59922: DOUBLE
59923: LD_INT 1
59925: DEC
59926: ST_TO_ADDR
59927: LD_INT 4
59929: PUSH
59930: FOR_TO
59931: IFFALSE 60122
// begin if not tmp [ j ] then
59933: LD_VAR 0 4
59937: PUSH
59938: LD_VAR 0 3
59942: ARRAY
59943: NOT
59944: IFFALSE 59948
// continue ;
59946: GO 59930
// for p in tmp [ j ] do
59948: LD_ADDR_VAR 0 5
59952: PUSH
59953: LD_VAR 0 4
59957: PUSH
59958: LD_VAR 0 3
59962: ARRAY
59963: PUSH
59964: FOR_IN
59965: IFFALSE 60118
// begin if not b [ j ] then
59967: LD_VAR 0 6
59971: PUSH
59972: LD_VAR 0 3
59976: ARRAY
59977: NOT
59978: IFFALSE 59982
// break ;
59980: GO 60118
// e := 0 ;
59982: LD_ADDR_VAR 0 7
59986: PUSH
59987: LD_INT 0
59989: ST_TO_ADDR
// for k in b [ j ] do
59990: LD_ADDR_VAR 0 8
59994: PUSH
59995: LD_VAR 0 6
59999: PUSH
60000: LD_VAR 0 3
60004: ARRAY
60005: PUSH
60006: FOR_IN
60007: IFFALSE 60034
// if IsNotFull ( k ) then
60009: LD_VAR 0 8
60013: PPUSH
60014: CALL 17999 0 1
60018: IFFALSE 60032
// begin e := k ;
60020: LD_ADDR_VAR 0 7
60024: PUSH
60025: LD_VAR 0 8
60029: ST_TO_ADDR
// break ;
60030: GO 60034
// end ;
60032: GO 60006
60034: POP
60035: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60036: LD_VAR 0 7
60040: PUSH
60041: LD_VAR 0 5
60045: PPUSH
60046: LD_VAR 0 7
60050: PPUSH
60051: CALL 54987 0 2
60055: NOT
60056: AND
60057: IFFALSE 60116
// begin if IsInUnit ( p ) then
60059: LD_VAR 0 5
60063: PPUSH
60064: CALL_OW 310
60068: IFFALSE 60079
// ComExitBuilding ( p ) ;
60070: LD_VAR 0 5
60074: PPUSH
60075: CALL_OW 122
// ComEnterUnit ( p , e ) ;
60079: LD_VAR 0 5
60083: PPUSH
60084: LD_VAR 0 7
60088: PPUSH
60089: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
60093: LD_VAR 0 5
60097: PPUSH
60098: LD_VAR 0 3
60102: PPUSH
60103: CALL_OW 183
// AddComExitBuilding ( p ) ;
60107: LD_VAR 0 5
60111: PPUSH
60112: CALL_OW 182
// end ; end ;
60116: GO 59964
60118: POP
60119: POP
// end ;
60120: GO 59930
60122: POP
60123: POP
// end ;
60124: GO 59685
60126: POP
60127: POP
// end ;
60128: LD_VAR 0 1
60132: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
60133: LD_INT 0
60135: PPUSH
60136: PPUSH
60137: PPUSH
60138: PPUSH
60139: PPUSH
60140: PPUSH
60141: PPUSH
60142: PPUSH
60143: PPUSH
60144: PPUSH
60145: PPUSH
60146: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60147: LD_VAR 0 1
60151: NOT
60152: PUSH
60153: LD_EXP 58
60157: PUSH
60158: LD_VAR 0 1
60162: ARRAY
60163: NOT
60164: OR
60165: PUSH
60166: LD_EXP 58
60170: PUSH
60171: LD_VAR 0 1
60175: ARRAY
60176: PPUSH
60177: LD_INT 2
60179: PUSH
60180: LD_INT 30
60182: PUSH
60183: LD_INT 0
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: PUSH
60190: LD_INT 30
60192: PUSH
60193: LD_INT 1
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: LIST
60204: PPUSH
60205: CALL_OW 72
60209: NOT
60210: OR
60211: IFFALSE 60215
// exit ;
60213: GO 63709
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60215: LD_ADDR_VAR 0 4
60219: PUSH
60220: LD_EXP 58
60224: PUSH
60225: LD_VAR 0 1
60229: ARRAY
60230: PPUSH
60231: LD_INT 2
60233: PUSH
60234: LD_INT 25
60236: PUSH
60237: LD_INT 1
60239: PUSH
60240: EMPTY
60241: LIST
60242: LIST
60243: PUSH
60244: LD_INT 25
60246: PUSH
60247: LD_INT 2
60249: PUSH
60250: EMPTY
60251: LIST
60252: LIST
60253: PUSH
60254: LD_INT 25
60256: PUSH
60257: LD_INT 3
60259: PUSH
60260: EMPTY
60261: LIST
60262: LIST
60263: PUSH
60264: LD_INT 25
60266: PUSH
60267: LD_INT 4
60269: PUSH
60270: EMPTY
60271: LIST
60272: LIST
60273: PUSH
60274: LD_INT 25
60276: PUSH
60277: LD_INT 5
60279: PUSH
60280: EMPTY
60281: LIST
60282: LIST
60283: PUSH
60284: LD_INT 25
60286: PUSH
60287: LD_INT 8
60289: PUSH
60290: EMPTY
60291: LIST
60292: LIST
60293: PUSH
60294: LD_INT 25
60296: PUSH
60297: LD_INT 9
60299: PUSH
60300: EMPTY
60301: LIST
60302: LIST
60303: PUSH
60304: EMPTY
60305: LIST
60306: LIST
60307: LIST
60308: LIST
60309: LIST
60310: LIST
60311: LIST
60312: LIST
60313: PPUSH
60314: CALL_OW 72
60318: ST_TO_ADDR
// for i in tmp do
60319: LD_ADDR_VAR 0 3
60323: PUSH
60324: LD_VAR 0 4
60328: PUSH
60329: FOR_IN
60330: IFFALSE 60361
// if GetTag ( i ) then
60332: LD_VAR 0 3
60336: PPUSH
60337: CALL_OW 110
60341: IFFALSE 60359
// tmp := tmp diff i ;
60343: LD_ADDR_VAR 0 4
60347: PUSH
60348: LD_VAR 0 4
60352: PUSH
60353: LD_VAR 0 3
60357: DIFF
60358: ST_TO_ADDR
60359: GO 60329
60361: POP
60362: POP
// if not tmp then
60363: LD_VAR 0 4
60367: NOT
60368: IFFALSE 60372
// exit ;
60370: GO 63709
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60372: LD_ADDR_VAR 0 5
60376: PUSH
60377: LD_EXP 58
60381: PUSH
60382: LD_VAR 0 1
60386: ARRAY
60387: PPUSH
60388: LD_INT 2
60390: PUSH
60391: LD_INT 25
60393: PUSH
60394: LD_INT 1
60396: PUSH
60397: EMPTY
60398: LIST
60399: LIST
60400: PUSH
60401: LD_INT 25
60403: PUSH
60404: LD_INT 5
60406: PUSH
60407: EMPTY
60408: LIST
60409: LIST
60410: PUSH
60411: LD_INT 25
60413: PUSH
60414: LD_INT 8
60416: PUSH
60417: EMPTY
60418: LIST
60419: LIST
60420: PUSH
60421: LD_INT 25
60423: PUSH
60424: LD_INT 9
60426: PUSH
60427: EMPTY
60428: LIST
60429: LIST
60430: PUSH
60431: EMPTY
60432: LIST
60433: LIST
60434: LIST
60435: LIST
60436: LIST
60437: PPUSH
60438: CALL_OW 72
60442: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60443: LD_ADDR_VAR 0 6
60447: PUSH
60448: LD_EXP 58
60452: PUSH
60453: LD_VAR 0 1
60457: ARRAY
60458: PPUSH
60459: LD_INT 25
60461: PUSH
60462: LD_INT 2
60464: PUSH
60465: EMPTY
60466: LIST
60467: LIST
60468: PPUSH
60469: CALL_OW 72
60473: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60474: LD_ADDR_VAR 0 7
60478: PUSH
60479: LD_EXP 58
60483: PUSH
60484: LD_VAR 0 1
60488: ARRAY
60489: PPUSH
60490: LD_INT 25
60492: PUSH
60493: LD_INT 3
60495: PUSH
60496: EMPTY
60497: LIST
60498: LIST
60499: PPUSH
60500: CALL_OW 72
60504: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60505: LD_ADDR_VAR 0 8
60509: PUSH
60510: LD_EXP 58
60514: PUSH
60515: LD_VAR 0 1
60519: ARRAY
60520: PPUSH
60521: LD_INT 25
60523: PUSH
60524: LD_INT 4
60526: PUSH
60527: EMPTY
60528: LIST
60529: LIST
60530: PUSH
60531: LD_INT 24
60533: PUSH
60534: LD_INT 251
60536: PUSH
60537: EMPTY
60538: LIST
60539: LIST
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PPUSH
60545: CALL_OW 72
60549: ST_TO_ADDR
// if mc_scan [ base ] then
60550: LD_EXP 81
60554: PUSH
60555: LD_VAR 0 1
60559: ARRAY
60560: IFFALSE 61021
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60562: LD_ADDR_EXP 100
60566: PUSH
60567: LD_EXP 100
60571: PPUSH
60572: LD_VAR 0 1
60576: PPUSH
60577: LD_INT 4
60579: PPUSH
60580: CALL_OW 1
60584: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60585: LD_ADDR_VAR 0 12
60589: PUSH
60590: LD_EXP 58
60594: PUSH
60595: LD_VAR 0 1
60599: ARRAY
60600: PPUSH
60601: LD_INT 2
60603: PUSH
60604: LD_INT 30
60606: PUSH
60607: LD_INT 4
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PUSH
60614: LD_INT 30
60616: PUSH
60617: LD_INT 5
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: PUSH
60624: EMPTY
60625: LIST
60626: LIST
60627: LIST
60628: PPUSH
60629: CALL_OW 72
60633: ST_TO_ADDR
// if not b then
60634: LD_VAR 0 12
60638: NOT
60639: IFFALSE 60643
// exit ;
60641: GO 63709
// p := [ ] ;
60643: LD_ADDR_VAR 0 11
60647: PUSH
60648: EMPTY
60649: ST_TO_ADDR
// if sci >= 2 then
60650: LD_VAR 0 8
60654: PUSH
60655: LD_INT 2
60657: GREATEREQUAL
60658: IFFALSE 60689
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60660: LD_ADDR_VAR 0 8
60664: PUSH
60665: LD_VAR 0 8
60669: PUSH
60670: LD_INT 1
60672: ARRAY
60673: PUSH
60674: LD_VAR 0 8
60678: PUSH
60679: LD_INT 2
60681: ARRAY
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: ST_TO_ADDR
60687: GO 60750
// if sci = 1 then
60689: LD_VAR 0 8
60693: PUSH
60694: LD_INT 1
60696: EQUAL
60697: IFFALSE 60718
// sci := [ sci [ 1 ] ] else
60699: LD_ADDR_VAR 0 8
60703: PUSH
60704: LD_VAR 0 8
60708: PUSH
60709: LD_INT 1
60711: ARRAY
60712: PUSH
60713: EMPTY
60714: LIST
60715: ST_TO_ADDR
60716: GO 60750
// if sci = 0 then
60718: LD_VAR 0 8
60722: PUSH
60723: LD_INT 0
60725: EQUAL
60726: IFFALSE 60750
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60728: LD_ADDR_VAR 0 11
60732: PUSH
60733: LD_VAR 0 4
60737: PPUSH
60738: LD_INT 4
60740: PPUSH
60741: CALL 54850 0 2
60745: PUSH
60746: LD_INT 1
60748: ARRAY
60749: ST_TO_ADDR
// if eng > 4 then
60750: LD_VAR 0 6
60754: PUSH
60755: LD_INT 4
60757: GREATER
60758: IFFALSE 60804
// for i = eng downto 4 do
60760: LD_ADDR_VAR 0 3
60764: PUSH
60765: DOUBLE
60766: LD_VAR 0 6
60770: INC
60771: ST_TO_ADDR
60772: LD_INT 4
60774: PUSH
60775: FOR_DOWNTO
60776: IFFALSE 60802
// eng := eng diff eng [ i ] ;
60778: LD_ADDR_VAR 0 6
60782: PUSH
60783: LD_VAR 0 6
60787: PUSH
60788: LD_VAR 0 6
60792: PUSH
60793: LD_VAR 0 3
60797: ARRAY
60798: DIFF
60799: ST_TO_ADDR
60800: GO 60775
60802: POP
60803: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60804: LD_ADDR_VAR 0 4
60808: PUSH
60809: LD_VAR 0 4
60813: PUSH
60814: LD_VAR 0 5
60818: PUSH
60819: LD_VAR 0 6
60823: UNION
60824: PUSH
60825: LD_VAR 0 7
60829: UNION
60830: PUSH
60831: LD_VAR 0 8
60835: UNION
60836: DIFF
60837: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60838: LD_ADDR_VAR 0 13
60842: PUSH
60843: LD_EXP 58
60847: PUSH
60848: LD_VAR 0 1
60852: ARRAY
60853: PPUSH
60854: LD_INT 2
60856: PUSH
60857: LD_INT 30
60859: PUSH
60860: LD_INT 32
60862: PUSH
60863: EMPTY
60864: LIST
60865: LIST
60866: PUSH
60867: LD_INT 30
60869: PUSH
60870: LD_INT 31
60872: PUSH
60873: EMPTY
60874: LIST
60875: LIST
60876: PUSH
60877: EMPTY
60878: LIST
60879: LIST
60880: LIST
60881: PPUSH
60882: CALL_OW 72
60886: PUSH
60887: LD_EXP 58
60891: PUSH
60892: LD_VAR 0 1
60896: ARRAY
60897: PPUSH
60898: LD_INT 2
60900: PUSH
60901: LD_INT 30
60903: PUSH
60904: LD_INT 4
60906: PUSH
60907: EMPTY
60908: LIST
60909: LIST
60910: PUSH
60911: LD_INT 30
60913: PUSH
60914: LD_INT 5
60916: PUSH
60917: EMPTY
60918: LIST
60919: LIST
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: LIST
60925: PPUSH
60926: CALL_OW 72
60930: PUSH
60931: LD_INT 6
60933: MUL
60934: PLUS
60935: ST_TO_ADDR
// if bcount < tmp then
60936: LD_VAR 0 13
60940: PUSH
60941: LD_VAR 0 4
60945: LESS
60946: IFFALSE 60992
// for i = tmp downto bcount do
60948: LD_ADDR_VAR 0 3
60952: PUSH
60953: DOUBLE
60954: LD_VAR 0 4
60958: INC
60959: ST_TO_ADDR
60960: LD_VAR 0 13
60964: PUSH
60965: FOR_DOWNTO
60966: IFFALSE 60990
// tmp := Delete ( tmp , tmp ) ;
60968: LD_ADDR_VAR 0 4
60972: PUSH
60973: LD_VAR 0 4
60977: PPUSH
60978: LD_VAR 0 4
60982: PPUSH
60983: CALL_OW 3
60987: ST_TO_ADDR
60988: GO 60965
60990: POP
60991: POP
// result := [ tmp , 0 , 0 , p ] ;
60992: LD_ADDR_VAR 0 2
60996: PUSH
60997: LD_VAR 0 4
61001: PUSH
61002: LD_INT 0
61004: PUSH
61005: LD_INT 0
61007: PUSH
61008: LD_VAR 0 11
61012: PUSH
61013: EMPTY
61014: LIST
61015: LIST
61016: LIST
61017: LIST
61018: ST_TO_ADDR
// exit ;
61019: GO 63709
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61021: LD_EXP 58
61025: PUSH
61026: LD_VAR 0 1
61030: ARRAY
61031: PPUSH
61032: LD_INT 2
61034: PUSH
61035: LD_INT 30
61037: PUSH
61038: LD_INT 6
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: PUSH
61045: LD_INT 30
61047: PUSH
61048: LD_INT 7
61050: PUSH
61051: EMPTY
61052: LIST
61053: LIST
61054: PUSH
61055: LD_INT 30
61057: PUSH
61058: LD_INT 8
61060: PUSH
61061: EMPTY
61062: LIST
61063: LIST
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: LIST
61069: LIST
61070: PPUSH
61071: CALL_OW 72
61075: NOT
61076: PUSH
61077: LD_EXP 58
61081: PUSH
61082: LD_VAR 0 1
61086: ARRAY
61087: PPUSH
61088: LD_INT 30
61090: PUSH
61091: LD_INT 3
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: PPUSH
61098: CALL_OW 72
61102: NOT
61103: AND
61104: IFFALSE 61176
// begin if eng = tmp then
61106: LD_VAR 0 6
61110: PUSH
61111: LD_VAR 0 4
61115: EQUAL
61116: IFFALSE 61120
// exit ;
61118: GO 63709
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
61120: LD_ADDR_EXP 100
61124: PUSH
61125: LD_EXP 100
61129: PPUSH
61130: LD_VAR 0 1
61134: PPUSH
61135: LD_INT 1
61137: PPUSH
61138: CALL_OW 1
61142: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
61143: LD_ADDR_VAR 0 2
61147: PUSH
61148: LD_INT 0
61150: PUSH
61151: LD_VAR 0 4
61155: PUSH
61156: LD_VAR 0 6
61160: DIFF
61161: PUSH
61162: LD_INT 0
61164: PUSH
61165: LD_INT 0
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: LIST
61172: LIST
61173: ST_TO_ADDR
// exit ;
61174: GO 63709
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61176: LD_EXP 85
61180: PUSH
61181: LD_EXP 84
61185: PUSH
61186: LD_VAR 0 1
61190: ARRAY
61191: ARRAY
61192: PUSH
61193: LD_EXP 58
61197: PUSH
61198: LD_VAR 0 1
61202: ARRAY
61203: PPUSH
61204: LD_INT 2
61206: PUSH
61207: LD_INT 30
61209: PUSH
61210: LD_INT 6
61212: PUSH
61213: EMPTY
61214: LIST
61215: LIST
61216: PUSH
61217: LD_INT 30
61219: PUSH
61220: LD_INT 7
61222: PUSH
61223: EMPTY
61224: LIST
61225: LIST
61226: PUSH
61227: LD_INT 30
61229: PUSH
61230: LD_INT 8
61232: PUSH
61233: EMPTY
61234: LIST
61235: LIST
61236: PUSH
61237: EMPTY
61238: LIST
61239: LIST
61240: LIST
61241: LIST
61242: PPUSH
61243: CALL_OW 72
61247: AND
61248: PUSH
61249: LD_EXP 58
61253: PUSH
61254: LD_VAR 0 1
61258: ARRAY
61259: PPUSH
61260: LD_INT 30
61262: PUSH
61263: LD_INT 3
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: PPUSH
61270: CALL_OW 72
61274: NOT
61275: AND
61276: IFFALSE 61490
// begin if sci >= 6 then
61278: LD_VAR 0 8
61282: PUSH
61283: LD_INT 6
61285: GREATEREQUAL
61286: IFFALSE 61290
// exit ;
61288: GO 63709
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61290: LD_ADDR_EXP 100
61294: PUSH
61295: LD_EXP 100
61299: PPUSH
61300: LD_VAR 0 1
61304: PPUSH
61305: LD_INT 2
61307: PPUSH
61308: CALL_OW 1
61312: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61313: LD_ADDR_VAR 0 9
61317: PUSH
61318: LD_VAR 0 4
61322: PUSH
61323: LD_VAR 0 8
61327: DIFF
61328: PPUSH
61329: LD_INT 4
61331: PPUSH
61332: CALL 54850 0 2
61336: ST_TO_ADDR
// p := [ ] ;
61337: LD_ADDR_VAR 0 11
61341: PUSH
61342: EMPTY
61343: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61344: LD_VAR 0 8
61348: PUSH
61349: LD_INT 6
61351: LESS
61352: PUSH
61353: LD_VAR 0 9
61357: PUSH
61358: LD_INT 6
61360: GREATER
61361: AND
61362: IFFALSE 61443
// begin for i = 1 to 6 - sci do
61364: LD_ADDR_VAR 0 3
61368: PUSH
61369: DOUBLE
61370: LD_INT 1
61372: DEC
61373: ST_TO_ADDR
61374: LD_INT 6
61376: PUSH
61377: LD_VAR 0 8
61381: MINUS
61382: PUSH
61383: FOR_TO
61384: IFFALSE 61439
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61386: LD_ADDR_VAR 0 11
61390: PUSH
61391: LD_VAR 0 11
61395: PPUSH
61396: LD_VAR 0 11
61400: PUSH
61401: LD_INT 1
61403: PLUS
61404: PPUSH
61405: LD_VAR 0 9
61409: PUSH
61410: LD_INT 1
61412: ARRAY
61413: PPUSH
61414: CALL_OW 2
61418: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61419: LD_ADDR_VAR 0 9
61423: PUSH
61424: LD_VAR 0 9
61428: PPUSH
61429: LD_INT 1
61431: PPUSH
61432: CALL_OW 3
61436: ST_TO_ADDR
// end ;
61437: GO 61383
61439: POP
61440: POP
// end else
61441: GO 61463
// if sort then
61443: LD_VAR 0 9
61447: IFFALSE 61463
// p := sort [ 1 ] ;
61449: LD_ADDR_VAR 0 11
61453: PUSH
61454: LD_VAR 0 9
61458: PUSH
61459: LD_INT 1
61461: ARRAY
61462: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61463: LD_ADDR_VAR 0 2
61467: PUSH
61468: LD_INT 0
61470: PUSH
61471: LD_INT 0
61473: PUSH
61474: LD_INT 0
61476: PUSH
61477: LD_VAR 0 11
61481: PUSH
61482: EMPTY
61483: LIST
61484: LIST
61485: LIST
61486: LIST
61487: ST_TO_ADDR
// exit ;
61488: GO 63709
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61490: LD_EXP 85
61494: PUSH
61495: LD_EXP 84
61499: PUSH
61500: LD_VAR 0 1
61504: ARRAY
61505: ARRAY
61506: PUSH
61507: LD_EXP 58
61511: PUSH
61512: LD_VAR 0 1
61516: ARRAY
61517: PPUSH
61518: LD_INT 2
61520: PUSH
61521: LD_INT 30
61523: PUSH
61524: LD_INT 6
61526: PUSH
61527: EMPTY
61528: LIST
61529: LIST
61530: PUSH
61531: LD_INT 30
61533: PUSH
61534: LD_INT 7
61536: PUSH
61537: EMPTY
61538: LIST
61539: LIST
61540: PUSH
61541: LD_INT 30
61543: PUSH
61544: LD_INT 8
61546: PUSH
61547: EMPTY
61548: LIST
61549: LIST
61550: PUSH
61551: EMPTY
61552: LIST
61553: LIST
61554: LIST
61555: LIST
61556: PPUSH
61557: CALL_OW 72
61561: AND
61562: PUSH
61563: LD_EXP 58
61567: PUSH
61568: LD_VAR 0 1
61572: ARRAY
61573: PPUSH
61574: LD_INT 30
61576: PUSH
61577: LD_INT 3
61579: PUSH
61580: EMPTY
61581: LIST
61582: LIST
61583: PPUSH
61584: CALL_OW 72
61588: AND
61589: IFFALSE 62323
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61591: LD_ADDR_EXP 100
61595: PUSH
61596: LD_EXP 100
61600: PPUSH
61601: LD_VAR 0 1
61605: PPUSH
61606: LD_INT 3
61608: PPUSH
61609: CALL_OW 1
61613: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61614: LD_ADDR_VAR 0 2
61618: PUSH
61619: LD_INT 0
61621: PUSH
61622: LD_INT 0
61624: PUSH
61625: LD_INT 0
61627: PUSH
61628: LD_INT 0
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: LIST
61635: LIST
61636: ST_TO_ADDR
// if not eng then
61637: LD_VAR 0 6
61641: NOT
61642: IFFALSE 61705
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61644: LD_ADDR_VAR 0 11
61648: PUSH
61649: LD_VAR 0 4
61653: PPUSH
61654: LD_INT 2
61656: PPUSH
61657: CALL 54850 0 2
61661: PUSH
61662: LD_INT 1
61664: ARRAY
61665: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61666: LD_ADDR_VAR 0 2
61670: PUSH
61671: LD_VAR 0 2
61675: PPUSH
61676: LD_INT 2
61678: PPUSH
61679: LD_VAR 0 11
61683: PPUSH
61684: CALL_OW 1
61688: ST_TO_ADDR
// tmp := tmp diff p ;
61689: LD_ADDR_VAR 0 4
61693: PUSH
61694: LD_VAR 0 4
61698: PUSH
61699: LD_VAR 0 11
61703: DIFF
61704: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61705: LD_VAR 0 4
61709: PUSH
61710: LD_VAR 0 8
61714: PUSH
61715: LD_INT 6
61717: LESS
61718: AND
61719: IFFALSE 61907
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61721: LD_ADDR_VAR 0 9
61725: PUSH
61726: LD_VAR 0 4
61730: PUSH
61731: LD_VAR 0 8
61735: PUSH
61736: LD_VAR 0 7
61740: UNION
61741: DIFF
61742: PPUSH
61743: LD_INT 4
61745: PPUSH
61746: CALL 54850 0 2
61750: ST_TO_ADDR
// p := [ ] ;
61751: LD_ADDR_VAR 0 11
61755: PUSH
61756: EMPTY
61757: ST_TO_ADDR
// if sort then
61758: LD_VAR 0 9
61762: IFFALSE 61878
// for i = 1 to 6 - sci do
61764: LD_ADDR_VAR 0 3
61768: PUSH
61769: DOUBLE
61770: LD_INT 1
61772: DEC
61773: ST_TO_ADDR
61774: LD_INT 6
61776: PUSH
61777: LD_VAR 0 8
61781: MINUS
61782: PUSH
61783: FOR_TO
61784: IFFALSE 61876
// begin if i = sort then
61786: LD_VAR 0 3
61790: PUSH
61791: LD_VAR 0 9
61795: EQUAL
61796: IFFALSE 61800
// break ;
61798: GO 61876
// if GetClass ( i ) = 4 then
61800: LD_VAR 0 3
61804: PPUSH
61805: CALL_OW 257
61809: PUSH
61810: LD_INT 4
61812: EQUAL
61813: IFFALSE 61817
// continue ;
61815: GO 61783
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61817: LD_ADDR_VAR 0 11
61821: PUSH
61822: LD_VAR 0 11
61826: PPUSH
61827: LD_VAR 0 11
61831: PUSH
61832: LD_INT 1
61834: PLUS
61835: PPUSH
61836: LD_VAR 0 9
61840: PUSH
61841: LD_VAR 0 3
61845: ARRAY
61846: PPUSH
61847: CALL_OW 2
61851: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61852: LD_ADDR_VAR 0 4
61856: PUSH
61857: LD_VAR 0 4
61861: PUSH
61862: LD_VAR 0 9
61866: PUSH
61867: LD_VAR 0 3
61871: ARRAY
61872: DIFF
61873: ST_TO_ADDR
// end ;
61874: GO 61783
61876: POP
61877: POP
// if p then
61878: LD_VAR 0 11
61882: IFFALSE 61907
// result := Replace ( result , 4 , p ) ;
61884: LD_ADDR_VAR 0 2
61888: PUSH
61889: LD_VAR 0 2
61893: PPUSH
61894: LD_INT 4
61896: PPUSH
61897: LD_VAR 0 11
61901: PPUSH
61902: CALL_OW 1
61906: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61907: LD_VAR 0 4
61911: PUSH
61912: LD_VAR 0 7
61916: PUSH
61917: LD_INT 6
61919: LESS
61920: AND
61921: IFFALSE 62109
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61923: LD_ADDR_VAR 0 9
61927: PUSH
61928: LD_VAR 0 4
61932: PUSH
61933: LD_VAR 0 8
61937: PUSH
61938: LD_VAR 0 7
61942: UNION
61943: DIFF
61944: PPUSH
61945: LD_INT 3
61947: PPUSH
61948: CALL 54850 0 2
61952: ST_TO_ADDR
// p := [ ] ;
61953: LD_ADDR_VAR 0 11
61957: PUSH
61958: EMPTY
61959: ST_TO_ADDR
// if sort then
61960: LD_VAR 0 9
61964: IFFALSE 62080
// for i = 1 to 6 - mech do
61966: LD_ADDR_VAR 0 3
61970: PUSH
61971: DOUBLE
61972: LD_INT 1
61974: DEC
61975: ST_TO_ADDR
61976: LD_INT 6
61978: PUSH
61979: LD_VAR 0 7
61983: MINUS
61984: PUSH
61985: FOR_TO
61986: IFFALSE 62078
// begin if i = sort then
61988: LD_VAR 0 3
61992: PUSH
61993: LD_VAR 0 9
61997: EQUAL
61998: IFFALSE 62002
// break ;
62000: GO 62078
// if GetClass ( i ) = 3 then
62002: LD_VAR 0 3
62006: PPUSH
62007: CALL_OW 257
62011: PUSH
62012: LD_INT 3
62014: EQUAL
62015: IFFALSE 62019
// continue ;
62017: GO 61985
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62019: LD_ADDR_VAR 0 11
62023: PUSH
62024: LD_VAR 0 11
62028: PPUSH
62029: LD_VAR 0 11
62033: PUSH
62034: LD_INT 1
62036: PLUS
62037: PPUSH
62038: LD_VAR 0 9
62042: PUSH
62043: LD_VAR 0 3
62047: ARRAY
62048: PPUSH
62049: CALL_OW 2
62053: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62054: LD_ADDR_VAR 0 4
62058: PUSH
62059: LD_VAR 0 4
62063: PUSH
62064: LD_VAR 0 9
62068: PUSH
62069: LD_VAR 0 3
62073: ARRAY
62074: DIFF
62075: ST_TO_ADDR
// end ;
62076: GO 61985
62078: POP
62079: POP
// if p then
62080: LD_VAR 0 11
62084: IFFALSE 62109
// result := Replace ( result , 3 , p ) ;
62086: LD_ADDR_VAR 0 2
62090: PUSH
62091: LD_VAR 0 2
62095: PPUSH
62096: LD_INT 3
62098: PPUSH
62099: LD_VAR 0 11
62103: PPUSH
62104: CALL_OW 1
62108: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
62109: LD_VAR 0 4
62113: PUSH
62114: LD_INT 6
62116: GREATER
62117: PUSH
62118: LD_VAR 0 6
62122: PUSH
62123: LD_INT 6
62125: LESS
62126: AND
62127: IFFALSE 62321
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62129: LD_ADDR_VAR 0 9
62133: PUSH
62134: LD_VAR 0 4
62138: PUSH
62139: LD_VAR 0 8
62143: PUSH
62144: LD_VAR 0 7
62148: UNION
62149: PUSH
62150: LD_VAR 0 6
62154: UNION
62155: DIFF
62156: PPUSH
62157: LD_INT 2
62159: PPUSH
62160: CALL 54850 0 2
62164: ST_TO_ADDR
// p := [ ] ;
62165: LD_ADDR_VAR 0 11
62169: PUSH
62170: EMPTY
62171: ST_TO_ADDR
// if sort then
62172: LD_VAR 0 9
62176: IFFALSE 62292
// for i = 1 to 6 - eng do
62178: LD_ADDR_VAR 0 3
62182: PUSH
62183: DOUBLE
62184: LD_INT 1
62186: DEC
62187: ST_TO_ADDR
62188: LD_INT 6
62190: PUSH
62191: LD_VAR 0 6
62195: MINUS
62196: PUSH
62197: FOR_TO
62198: IFFALSE 62290
// begin if i = sort then
62200: LD_VAR 0 3
62204: PUSH
62205: LD_VAR 0 9
62209: EQUAL
62210: IFFALSE 62214
// break ;
62212: GO 62290
// if GetClass ( i ) = 2 then
62214: LD_VAR 0 3
62218: PPUSH
62219: CALL_OW 257
62223: PUSH
62224: LD_INT 2
62226: EQUAL
62227: IFFALSE 62231
// continue ;
62229: GO 62197
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62231: LD_ADDR_VAR 0 11
62235: PUSH
62236: LD_VAR 0 11
62240: PPUSH
62241: LD_VAR 0 11
62245: PUSH
62246: LD_INT 1
62248: PLUS
62249: PPUSH
62250: LD_VAR 0 9
62254: PUSH
62255: LD_VAR 0 3
62259: ARRAY
62260: PPUSH
62261: CALL_OW 2
62265: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62266: LD_ADDR_VAR 0 4
62270: PUSH
62271: LD_VAR 0 4
62275: PUSH
62276: LD_VAR 0 9
62280: PUSH
62281: LD_VAR 0 3
62285: ARRAY
62286: DIFF
62287: ST_TO_ADDR
// end ;
62288: GO 62197
62290: POP
62291: POP
// if p then
62292: LD_VAR 0 11
62296: IFFALSE 62321
// result := Replace ( result , 2 , p ) ;
62298: LD_ADDR_VAR 0 2
62302: PUSH
62303: LD_VAR 0 2
62307: PPUSH
62308: LD_INT 2
62310: PPUSH
62311: LD_VAR 0 11
62315: PPUSH
62316: CALL_OW 1
62320: ST_TO_ADDR
// end ; exit ;
62321: GO 63709
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62323: LD_EXP 85
62327: PUSH
62328: LD_EXP 84
62332: PUSH
62333: LD_VAR 0 1
62337: ARRAY
62338: ARRAY
62339: NOT
62340: PUSH
62341: LD_EXP 58
62345: PUSH
62346: LD_VAR 0 1
62350: ARRAY
62351: PPUSH
62352: LD_INT 30
62354: PUSH
62355: LD_INT 3
62357: PUSH
62358: EMPTY
62359: LIST
62360: LIST
62361: PPUSH
62362: CALL_OW 72
62366: AND
62367: PUSH
62368: LD_EXP 63
62372: PUSH
62373: LD_VAR 0 1
62377: ARRAY
62378: AND
62379: IFFALSE 62987
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62381: LD_ADDR_EXP 100
62385: PUSH
62386: LD_EXP 100
62390: PPUSH
62391: LD_VAR 0 1
62395: PPUSH
62396: LD_INT 5
62398: PPUSH
62399: CALL_OW 1
62403: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62404: LD_ADDR_VAR 0 2
62408: PUSH
62409: LD_INT 0
62411: PUSH
62412: LD_INT 0
62414: PUSH
62415: LD_INT 0
62417: PUSH
62418: LD_INT 0
62420: PUSH
62421: EMPTY
62422: LIST
62423: LIST
62424: LIST
62425: LIST
62426: ST_TO_ADDR
// if sci > 1 then
62427: LD_VAR 0 8
62431: PUSH
62432: LD_INT 1
62434: GREATER
62435: IFFALSE 62463
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62437: LD_ADDR_VAR 0 4
62441: PUSH
62442: LD_VAR 0 4
62446: PUSH
62447: LD_VAR 0 8
62451: PUSH
62452: LD_VAR 0 8
62456: PUSH
62457: LD_INT 1
62459: ARRAY
62460: DIFF
62461: DIFF
62462: ST_TO_ADDR
// if tmp and not sci then
62463: LD_VAR 0 4
62467: PUSH
62468: LD_VAR 0 8
62472: NOT
62473: AND
62474: IFFALSE 62543
// begin sort := SortBySkill ( tmp , 4 ) ;
62476: LD_ADDR_VAR 0 9
62480: PUSH
62481: LD_VAR 0 4
62485: PPUSH
62486: LD_INT 4
62488: PPUSH
62489: CALL 54850 0 2
62493: ST_TO_ADDR
// if sort then
62494: LD_VAR 0 9
62498: IFFALSE 62514
// p := sort [ 1 ] ;
62500: LD_ADDR_VAR 0 11
62504: PUSH
62505: LD_VAR 0 9
62509: PUSH
62510: LD_INT 1
62512: ARRAY
62513: ST_TO_ADDR
// if p then
62514: LD_VAR 0 11
62518: IFFALSE 62543
// result := Replace ( result , 4 , p ) ;
62520: LD_ADDR_VAR 0 2
62524: PUSH
62525: LD_VAR 0 2
62529: PPUSH
62530: LD_INT 4
62532: PPUSH
62533: LD_VAR 0 11
62537: PPUSH
62538: CALL_OW 1
62542: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62543: LD_ADDR_VAR 0 4
62547: PUSH
62548: LD_VAR 0 4
62552: PUSH
62553: LD_VAR 0 7
62557: DIFF
62558: ST_TO_ADDR
// if tmp and mech < 6 then
62559: LD_VAR 0 4
62563: PUSH
62564: LD_VAR 0 7
62568: PUSH
62569: LD_INT 6
62571: LESS
62572: AND
62573: IFFALSE 62761
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62575: LD_ADDR_VAR 0 9
62579: PUSH
62580: LD_VAR 0 4
62584: PUSH
62585: LD_VAR 0 8
62589: PUSH
62590: LD_VAR 0 7
62594: UNION
62595: DIFF
62596: PPUSH
62597: LD_INT 3
62599: PPUSH
62600: CALL 54850 0 2
62604: ST_TO_ADDR
// p := [ ] ;
62605: LD_ADDR_VAR 0 11
62609: PUSH
62610: EMPTY
62611: ST_TO_ADDR
// if sort then
62612: LD_VAR 0 9
62616: IFFALSE 62732
// for i = 1 to 6 - mech do
62618: LD_ADDR_VAR 0 3
62622: PUSH
62623: DOUBLE
62624: LD_INT 1
62626: DEC
62627: ST_TO_ADDR
62628: LD_INT 6
62630: PUSH
62631: LD_VAR 0 7
62635: MINUS
62636: PUSH
62637: FOR_TO
62638: IFFALSE 62730
// begin if i = sort then
62640: LD_VAR 0 3
62644: PUSH
62645: LD_VAR 0 9
62649: EQUAL
62650: IFFALSE 62654
// break ;
62652: GO 62730
// if GetClass ( i ) = 3 then
62654: LD_VAR 0 3
62658: PPUSH
62659: CALL_OW 257
62663: PUSH
62664: LD_INT 3
62666: EQUAL
62667: IFFALSE 62671
// continue ;
62669: GO 62637
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62671: LD_ADDR_VAR 0 11
62675: PUSH
62676: LD_VAR 0 11
62680: PPUSH
62681: LD_VAR 0 11
62685: PUSH
62686: LD_INT 1
62688: PLUS
62689: PPUSH
62690: LD_VAR 0 9
62694: PUSH
62695: LD_VAR 0 3
62699: ARRAY
62700: PPUSH
62701: CALL_OW 2
62705: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62706: LD_ADDR_VAR 0 4
62710: PUSH
62711: LD_VAR 0 4
62715: PUSH
62716: LD_VAR 0 9
62720: PUSH
62721: LD_VAR 0 3
62725: ARRAY
62726: DIFF
62727: ST_TO_ADDR
// end ;
62728: GO 62637
62730: POP
62731: POP
// if p then
62732: LD_VAR 0 11
62736: IFFALSE 62761
// result := Replace ( result , 3 , p ) ;
62738: LD_ADDR_VAR 0 2
62742: PUSH
62743: LD_VAR 0 2
62747: PPUSH
62748: LD_INT 3
62750: PPUSH
62751: LD_VAR 0 11
62755: PPUSH
62756: CALL_OW 1
62760: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62761: LD_ADDR_VAR 0 4
62765: PUSH
62766: LD_VAR 0 4
62770: PUSH
62771: LD_VAR 0 6
62775: DIFF
62776: ST_TO_ADDR
// if tmp and eng < 6 then
62777: LD_VAR 0 4
62781: PUSH
62782: LD_VAR 0 6
62786: PUSH
62787: LD_INT 6
62789: LESS
62790: AND
62791: IFFALSE 62985
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62793: LD_ADDR_VAR 0 9
62797: PUSH
62798: LD_VAR 0 4
62802: PUSH
62803: LD_VAR 0 8
62807: PUSH
62808: LD_VAR 0 7
62812: UNION
62813: PUSH
62814: LD_VAR 0 6
62818: UNION
62819: DIFF
62820: PPUSH
62821: LD_INT 2
62823: PPUSH
62824: CALL 54850 0 2
62828: ST_TO_ADDR
// p := [ ] ;
62829: LD_ADDR_VAR 0 11
62833: PUSH
62834: EMPTY
62835: ST_TO_ADDR
// if sort then
62836: LD_VAR 0 9
62840: IFFALSE 62956
// for i = 1 to 6 - eng do
62842: LD_ADDR_VAR 0 3
62846: PUSH
62847: DOUBLE
62848: LD_INT 1
62850: DEC
62851: ST_TO_ADDR
62852: LD_INT 6
62854: PUSH
62855: LD_VAR 0 6
62859: MINUS
62860: PUSH
62861: FOR_TO
62862: IFFALSE 62954
// begin if i = sort then
62864: LD_VAR 0 3
62868: PUSH
62869: LD_VAR 0 9
62873: EQUAL
62874: IFFALSE 62878
// break ;
62876: GO 62954
// if GetClass ( i ) = 2 then
62878: LD_VAR 0 3
62882: PPUSH
62883: CALL_OW 257
62887: PUSH
62888: LD_INT 2
62890: EQUAL
62891: IFFALSE 62895
// continue ;
62893: GO 62861
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62895: LD_ADDR_VAR 0 11
62899: PUSH
62900: LD_VAR 0 11
62904: PPUSH
62905: LD_VAR 0 11
62909: PUSH
62910: LD_INT 1
62912: PLUS
62913: PPUSH
62914: LD_VAR 0 9
62918: PUSH
62919: LD_VAR 0 3
62923: ARRAY
62924: PPUSH
62925: CALL_OW 2
62929: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62930: LD_ADDR_VAR 0 4
62934: PUSH
62935: LD_VAR 0 4
62939: PUSH
62940: LD_VAR 0 9
62944: PUSH
62945: LD_VAR 0 3
62949: ARRAY
62950: DIFF
62951: ST_TO_ADDR
// end ;
62952: GO 62861
62954: POP
62955: POP
// if p then
62956: LD_VAR 0 11
62960: IFFALSE 62985
// result := Replace ( result , 2 , p ) ;
62962: LD_ADDR_VAR 0 2
62966: PUSH
62967: LD_VAR 0 2
62971: PPUSH
62972: LD_INT 2
62974: PPUSH
62975: LD_VAR 0 11
62979: PPUSH
62980: CALL_OW 1
62984: ST_TO_ADDR
// end ; exit ;
62985: GO 63709
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62987: LD_EXP 85
62991: PUSH
62992: LD_EXP 84
62996: PUSH
62997: LD_VAR 0 1
63001: ARRAY
63002: ARRAY
63003: NOT
63004: PUSH
63005: LD_EXP 58
63009: PUSH
63010: LD_VAR 0 1
63014: ARRAY
63015: PPUSH
63016: LD_INT 30
63018: PUSH
63019: LD_INT 3
63021: PUSH
63022: EMPTY
63023: LIST
63024: LIST
63025: PPUSH
63026: CALL_OW 72
63030: AND
63031: PUSH
63032: LD_EXP 63
63036: PUSH
63037: LD_VAR 0 1
63041: ARRAY
63042: NOT
63043: AND
63044: IFFALSE 63709
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63046: LD_ADDR_EXP 100
63050: PUSH
63051: LD_EXP 100
63055: PPUSH
63056: LD_VAR 0 1
63060: PPUSH
63061: LD_INT 6
63063: PPUSH
63064: CALL_OW 1
63068: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63069: LD_ADDR_VAR 0 2
63073: PUSH
63074: LD_INT 0
63076: PUSH
63077: LD_INT 0
63079: PUSH
63080: LD_INT 0
63082: PUSH
63083: LD_INT 0
63085: PUSH
63086: EMPTY
63087: LIST
63088: LIST
63089: LIST
63090: LIST
63091: ST_TO_ADDR
// if sci >= 1 then
63092: LD_VAR 0 8
63096: PUSH
63097: LD_INT 1
63099: GREATEREQUAL
63100: IFFALSE 63122
// tmp := tmp diff sci [ 1 ] ;
63102: LD_ADDR_VAR 0 4
63106: PUSH
63107: LD_VAR 0 4
63111: PUSH
63112: LD_VAR 0 8
63116: PUSH
63117: LD_INT 1
63119: ARRAY
63120: DIFF
63121: ST_TO_ADDR
// if tmp and not sci then
63122: LD_VAR 0 4
63126: PUSH
63127: LD_VAR 0 8
63131: NOT
63132: AND
63133: IFFALSE 63202
// begin sort := SortBySkill ( tmp , 4 ) ;
63135: LD_ADDR_VAR 0 9
63139: PUSH
63140: LD_VAR 0 4
63144: PPUSH
63145: LD_INT 4
63147: PPUSH
63148: CALL 54850 0 2
63152: ST_TO_ADDR
// if sort then
63153: LD_VAR 0 9
63157: IFFALSE 63173
// p := sort [ 1 ] ;
63159: LD_ADDR_VAR 0 11
63163: PUSH
63164: LD_VAR 0 9
63168: PUSH
63169: LD_INT 1
63171: ARRAY
63172: ST_TO_ADDR
// if p then
63173: LD_VAR 0 11
63177: IFFALSE 63202
// result := Replace ( result , 4 , p ) ;
63179: LD_ADDR_VAR 0 2
63183: PUSH
63184: LD_VAR 0 2
63188: PPUSH
63189: LD_INT 4
63191: PPUSH
63192: LD_VAR 0 11
63196: PPUSH
63197: CALL_OW 1
63201: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63202: LD_ADDR_VAR 0 4
63206: PUSH
63207: LD_VAR 0 4
63211: PUSH
63212: LD_VAR 0 7
63216: DIFF
63217: ST_TO_ADDR
// if tmp and mech < 6 then
63218: LD_VAR 0 4
63222: PUSH
63223: LD_VAR 0 7
63227: PUSH
63228: LD_INT 6
63230: LESS
63231: AND
63232: IFFALSE 63414
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63234: LD_ADDR_VAR 0 9
63238: PUSH
63239: LD_VAR 0 4
63243: PUSH
63244: LD_VAR 0 7
63248: DIFF
63249: PPUSH
63250: LD_INT 3
63252: PPUSH
63253: CALL 54850 0 2
63257: ST_TO_ADDR
// p := [ ] ;
63258: LD_ADDR_VAR 0 11
63262: PUSH
63263: EMPTY
63264: ST_TO_ADDR
// if sort then
63265: LD_VAR 0 9
63269: IFFALSE 63385
// for i = 1 to 6 - mech do
63271: LD_ADDR_VAR 0 3
63275: PUSH
63276: DOUBLE
63277: LD_INT 1
63279: DEC
63280: ST_TO_ADDR
63281: LD_INT 6
63283: PUSH
63284: LD_VAR 0 7
63288: MINUS
63289: PUSH
63290: FOR_TO
63291: IFFALSE 63383
// begin if i = sort then
63293: LD_VAR 0 3
63297: PUSH
63298: LD_VAR 0 9
63302: EQUAL
63303: IFFALSE 63307
// break ;
63305: GO 63383
// if GetClass ( i ) = 3 then
63307: LD_VAR 0 3
63311: PPUSH
63312: CALL_OW 257
63316: PUSH
63317: LD_INT 3
63319: EQUAL
63320: IFFALSE 63324
// continue ;
63322: GO 63290
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63324: LD_ADDR_VAR 0 11
63328: PUSH
63329: LD_VAR 0 11
63333: PPUSH
63334: LD_VAR 0 11
63338: PUSH
63339: LD_INT 1
63341: PLUS
63342: PPUSH
63343: LD_VAR 0 9
63347: PUSH
63348: LD_VAR 0 3
63352: ARRAY
63353: PPUSH
63354: CALL_OW 2
63358: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63359: LD_ADDR_VAR 0 4
63363: PUSH
63364: LD_VAR 0 4
63368: PUSH
63369: LD_VAR 0 9
63373: PUSH
63374: LD_VAR 0 3
63378: ARRAY
63379: DIFF
63380: ST_TO_ADDR
// end ;
63381: GO 63290
63383: POP
63384: POP
// if p then
63385: LD_VAR 0 11
63389: IFFALSE 63414
// result := Replace ( result , 3 , p ) ;
63391: LD_ADDR_VAR 0 2
63395: PUSH
63396: LD_VAR 0 2
63400: PPUSH
63401: LD_INT 3
63403: PPUSH
63404: LD_VAR 0 11
63408: PPUSH
63409: CALL_OW 1
63413: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63414: LD_ADDR_VAR 0 4
63418: PUSH
63419: LD_VAR 0 4
63423: PUSH
63424: LD_VAR 0 6
63428: DIFF
63429: ST_TO_ADDR
// if tmp and eng < 4 then
63430: LD_VAR 0 4
63434: PUSH
63435: LD_VAR 0 6
63439: PUSH
63440: LD_INT 4
63442: LESS
63443: AND
63444: IFFALSE 63634
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63446: LD_ADDR_VAR 0 9
63450: PUSH
63451: LD_VAR 0 4
63455: PUSH
63456: LD_VAR 0 7
63460: PUSH
63461: LD_VAR 0 6
63465: UNION
63466: DIFF
63467: PPUSH
63468: LD_INT 2
63470: PPUSH
63471: CALL 54850 0 2
63475: ST_TO_ADDR
// p := [ ] ;
63476: LD_ADDR_VAR 0 11
63480: PUSH
63481: EMPTY
63482: ST_TO_ADDR
// if sort then
63483: LD_VAR 0 9
63487: IFFALSE 63603
// for i = 1 to 4 - eng do
63489: LD_ADDR_VAR 0 3
63493: PUSH
63494: DOUBLE
63495: LD_INT 1
63497: DEC
63498: ST_TO_ADDR
63499: LD_INT 4
63501: PUSH
63502: LD_VAR 0 6
63506: MINUS
63507: PUSH
63508: FOR_TO
63509: IFFALSE 63601
// begin if i = sort then
63511: LD_VAR 0 3
63515: PUSH
63516: LD_VAR 0 9
63520: EQUAL
63521: IFFALSE 63525
// break ;
63523: GO 63601
// if GetClass ( i ) = 2 then
63525: LD_VAR 0 3
63529: PPUSH
63530: CALL_OW 257
63534: PUSH
63535: LD_INT 2
63537: EQUAL
63538: IFFALSE 63542
// continue ;
63540: GO 63508
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63542: LD_ADDR_VAR 0 11
63546: PUSH
63547: LD_VAR 0 11
63551: PPUSH
63552: LD_VAR 0 11
63556: PUSH
63557: LD_INT 1
63559: PLUS
63560: PPUSH
63561: LD_VAR 0 9
63565: PUSH
63566: LD_VAR 0 3
63570: ARRAY
63571: PPUSH
63572: CALL_OW 2
63576: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63577: LD_ADDR_VAR 0 4
63581: PUSH
63582: LD_VAR 0 4
63586: PUSH
63587: LD_VAR 0 9
63591: PUSH
63592: LD_VAR 0 3
63596: ARRAY
63597: DIFF
63598: ST_TO_ADDR
// end ;
63599: GO 63508
63601: POP
63602: POP
// if p then
63603: LD_VAR 0 11
63607: IFFALSE 63632
// result := Replace ( result , 2 , p ) ;
63609: LD_ADDR_VAR 0 2
63613: PUSH
63614: LD_VAR 0 2
63618: PPUSH
63619: LD_INT 2
63621: PPUSH
63622: LD_VAR 0 11
63626: PPUSH
63627: CALL_OW 1
63631: ST_TO_ADDR
// end else
63632: GO 63678
// for i = eng downto 5 do
63634: LD_ADDR_VAR 0 3
63638: PUSH
63639: DOUBLE
63640: LD_VAR 0 6
63644: INC
63645: ST_TO_ADDR
63646: LD_INT 5
63648: PUSH
63649: FOR_DOWNTO
63650: IFFALSE 63676
// tmp := tmp union eng [ i ] ;
63652: LD_ADDR_VAR 0 4
63656: PUSH
63657: LD_VAR 0 4
63661: PUSH
63662: LD_VAR 0 6
63666: PUSH
63667: LD_VAR 0 3
63671: ARRAY
63672: UNION
63673: ST_TO_ADDR
63674: GO 63649
63676: POP
63677: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63678: LD_ADDR_VAR 0 2
63682: PUSH
63683: LD_VAR 0 2
63687: PPUSH
63688: LD_INT 1
63690: PPUSH
63691: LD_VAR 0 4
63695: PUSH
63696: LD_VAR 0 5
63700: DIFF
63701: PPUSH
63702: CALL_OW 1
63706: ST_TO_ADDR
// exit ;
63707: GO 63709
// end ; end ;
63709: LD_VAR 0 2
63713: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63714: LD_INT 0
63716: PPUSH
63717: PPUSH
63718: PPUSH
// if not mc_bases then
63719: LD_EXP 58
63723: NOT
63724: IFFALSE 63728
// exit ;
63726: GO 63834
// for i = 1 to mc_bases do
63728: LD_ADDR_VAR 0 2
63732: PUSH
63733: DOUBLE
63734: LD_INT 1
63736: DEC
63737: ST_TO_ADDR
63738: LD_EXP 58
63742: PUSH
63743: FOR_TO
63744: IFFALSE 63825
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63746: LD_ADDR_VAR 0 3
63750: PUSH
63751: LD_EXP 58
63755: PUSH
63756: LD_VAR 0 2
63760: ARRAY
63761: PPUSH
63762: LD_INT 21
63764: PUSH
63765: LD_INT 3
63767: PUSH
63768: EMPTY
63769: LIST
63770: LIST
63771: PUSH
63772: LD_INT 3
63774: PUSH
63775: LD_INT 24
63777: PUSH
63778: LD_INT 1000
63780: PUSH
63781: EMPTY
63782: LIST
63783: LIST
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: PUSH
63789: EMPTY
63790: LIST
63791: LIST
63792: PPUSH
63793: CALL_OW 72
63797: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63798: LD_ADDR_EXP 59
63802: PUSH
63803: LD_EXP 59
63807: PPUSH
63808: LD_VAR 0 2
63812: PPUSH
63813: LD_VAR 0 3
63817: PPUSH
63818: CALL_OW 1
63822: ST_TO_ADDR
// end ;
63823: GO 63743
63825: POP
63826: POP
// RaiseSailEvent ( 101 ) ;
63827: LD_INT 101
63829: PPUSH
63830: CALL_OW 427
// end ;
63834: LD_VAR 0 1
63838: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63839: LD_INT 0
63841: PPUSH
63842: PPUSH
63843: PPUSH
63844: PPUSH
63845: PPUSH
63846: PPUSH
63847: PPUSH
// if not mc_bases then
63848: LD_EXP 58
63852: NOT
63853: IFFALSE 63857
// exit ;
63855: GO 64430
// for i = 1 to mc_bases do
63857: LD_ADDR_VAR 0 2
63861: PUSH
63862: DOUBLE
63863: LD_INT 1
63865: DEC
63866: ST_TO_ADDR
63867: LD_EXP 58
63871: PUSH
63872: FOR_TO
63873: IFFALSE 64421
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
63875: LD_ADDR_VAR 0 5
63879: PUSH
63880: LD_EXP 58
63884: PUSH
63885: LD_VAR 0 2
63889: ARRAY
63890: PUSH
63891: LD_EXP 87
63895: PUSH
63896: LD_VAR 0 2
63900: ARRAY
63901: UNION
63902: PPUSH
63903: LD_INT 21
63905: PUSH
63906: LD_INT 1
63908: PUSH
63909: EMPTY
63910: LIST
63911: LIST
63912: PUSH
63913: LD_INT 1
63915: PUSH
63916: LD_INT 3
63918: PUSH
63919: LD_INT 54
63921: PUSH
63922: EMPTY
63923: LIST
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 3
63931: PUSH
63932: LD_INT 24
63934: PUSH
63935: LD_INT 750
63937: PUSH
63938: EMPTY
63939: LIST
63940: LIST
63941: PUSH
63942: EMPTY
63943: LIST
63944: LIST
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: LIST
63950: PUSH
63951: EMPTY
63952: LIST
63953: LIST
63954: PPUSH
63955: CALL_OW 72
63959: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63960: LD_ADDR_VAR 0 6
63964: PUSH
63965: LD_EXP 58
63969: PUSH
63970: LD_VAR 0 2
63974: ARRAY
63975: PPUSH
63976: LD_INT 21
63978: PUSH
63979: LD_INT 1
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: LD_INT 1
63988: PUSH
63989: LD_INT 3
63991: PUSH
63992: LD_INT 54
63994: PUSH
63995: EMPTY
63996: LIST
63997: PUSH
63998: EMPTY
63999: LIST
64000: LIST
64001: PUSH
64002: LD_INT 3
64004: PUSH
64005: LD_INT 24
64007: PUSH
64008: LD_INT 250
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: LIST
64023: PUSH
64024: EMPTY
64025: LIST
64026: LIST
64027: PPUSH
64028: CALL_OW 72
64032: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
64033: LD_ADDR_VAR 0 7
64037: PUSH
64038: LD_VAR 0 5
64042: PUSH
64043: LD_VAR 0 6
64047: DIFF
64048: ST_TO_ADDR
// if not need_heal_1 then
64049: LD_VAR 0 6
64053: NOT
64054: IFFALSE 64087
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
64056: LD_ADDR_EXP 61
64060: PUSH
64061: LD_EXP 61
64065: PPUSH
64066: LD_VAR 0 2
64070: PUSH
64071: LD_INT 1
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: PPUSH
64078: EMPTY
64079: PPUSH
64080: CALL 20665 0 3
64084: ST_TO_ADDR
64085: GO 64157
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
64087: LD_ADDR_EXP 61
64091: PUSH
64092: LD_EXP 61
64096: PPUSH
64097: LD_VAR 0 2
64101: PUSH
64102: LD_INT 1
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PPUSH
64109: LD_EXP 61
64113: PUSH
64114: LD_VAR 0 2
64118: ARRAY
64119: PUSH
64120: LD_INT 1
64122: ARRAY
64123: PPUSH
64124: LD_INT 3
64126: PUSH
64127: LD_INT 24
64129: PUSH
64130: LD_INT 1000
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: EMPTY
64138: LIST
64139: LIST
64140: PPUSH
64141: CALL_OW 72
64145: PUSH
64146: LD_VAR 0 6
64150: UNION
64151: PPUSH
64152: CALL 20665 0 3
64156: ST_TO_ADDR
// if not need_heal_2 then
64157: LD_VAR 0 7
64161: NOT
64162: IFFALSE 64195
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
64164: LD_ADDR_EXP 61
64168: PUSH
64169: LD_EXP 61
64173: PPUSH
64174: LD_VAR 0 2
64178: PUSH
64179: LD_INT 2
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PPUSH
64186: EMPTY
64187: PPUSH
64188: CALL 20665 0 3
64192: ST_TO_ADDR
64193: GO 64227
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64195: LD_ADDR_EXP 61
64199: PUSH
64200: LD_EXP 61
64204: PPUSH
64205: LD_VAR 0 2
64209: PUSH
64210: LD_INT 2
64212: PUSH
64213: EMPTY
64214: LIST
64215: LIST
64216: PPUSH
64217: LD_VAR 0 7
64221: PPUSH
64222: CALL 20665 0 3
64226: ST_TO_ADDR
// if need_heal_2 then
64227: LD_VAR 0 7
64231: IFFALSE 64403
// for j in need_heal_2 do
64233: LD_ADDR_VAR 0 3
64237: PUSH
64238: LD_VAR 0 7
64242: PUSH
64243: FOR_IN
64244: IFFALSE 64401
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
64246: LD_ADDR_VAR 0 5
64250: PUSH
64251: LD_EXP 58
64255: PUSH
64256: LD_VAR 0 2
64260: ARRAY
64261: PPUSH
64262: LD_INT 2
64264: PUSH
64265: LD_INT 30
64267: PUSH
64268: LD_INT 6
64270: PUSH
64271: EMPTY
64272: LIST
64273: LIST
64274: PUSH
64275: LD_INT 30
64277: PUSH
64278: LD_INT 7
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 30
64287: PUSH
64288: LD_INT 8
64290: PUSH
64291: EMPTY
64292: LIST
64293: LIST
64294: PUSH
64295: LD_INT 30
64297: PUSH
64298: LD_INT 0
64300: PUSH
64301: EMPTY
64302: LIST
64303: LIST
64304: PUSH
64305: LD_INT 30
64307: PUSH
64308: LD_INT 1
64310: PUSH
64311: EMPTY
64312: LIST
64313: LIST
64314: PUSH
64315: LD_INT 25
64317: PUSH
64318: LD_INT 4
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: EMPTY
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: PPUSH
64334: CALL_OW 72
64338: ST_TO_ADDR
// if tmp then
64339: LD_VAR 0 5
64343: IFFALSE 64399
// begin k := NearestUnitToUnit ( tmp , j ) ;
64345: LD_ADDR_VAR 0 4
64349: PUSH
64350: LD_VAR 0 5
64354: PPUSH
64355: LD_VAR 0 3
64359: PPUSH
64360: CALL_OW 74
64364: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
64365: LD_VAR 0 3
64369: PPUSH
64370: LD_VAR 0 4
64374: PPUSH
64375: CALL_OW 296
64379: PUSH
64380: LD_INT 7
64382: GREATER
64383: IFFALSE 64399
// ComMoveUnit ( j , k ) ;
64385: LD_VAR 0 3
64389: PPUSH
64390: LD_VAR 0 4
64394: PPUSH
64395: CALL_OW 112
// end ; end ;
64399: GO 64243
64401: POP
64402: POP
// if not need_heal_1 and not need_heal_2 then
64403: LD_VAR 0 6
64407: NOT
64408: PUSH
64409: LD_VAR 0 7
64413: NOT
64414: AND
64415: IFFALSE 64419
// continue ;
64417: GO 63872
// end ;
64419: GO 63872
64421: POP
64422: POP
// RaiseSailEvent ( 102 ) ;
64423: LD_INT 102
64425: PPUSH
64426: CALL_OW 427
// end ;
64430: LD_VAR 0 1
64434: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
64435: LD_INT 0
64437: PPUSH
64438: PPUSH
64439: PPUSH
64440: PPUSH
64441: PPUSH
// if not mc_bases then
64442: LD_EXP 58
64446: NOT
64447: IFFALSE 64451
// exit ;
64449: GO 64836
// for i = 1 to mc_bases do
64451: LD_ADDR_VAR 0 2
64455: PUSH
64456: DOUBLE
64457: LD_INT 1
64459: DEC
64460: ST_TO_ADDR
64461: LD_EXP 58
64465: PUSH
64466: FOR_TO
64467: IFFALSE 64834
// begin if not mc_building_need_repair [ i ] then
64469: LD_EXP 59
64473: PUSH
64474: LD_VAR 0 2
64478: ARRAY
64479: NOT
64480: IFFALSE 64518
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64482: LD_ADDR_EXP 60
64486: PUSH
64487: LD_EXP 60
64491: PPUSH
64492: LD_VAR 0 2
64496: PPUSH
64497: EMPTY
64498: PPUSH
64499: CALL_OW 1
64503: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64504: LD_VAR 0 2
64508: PPUSH
64509: LD_INT 101
64511: PPUSH
64512: CALL 59556 0 2
// continue ;
64516: GO 64466
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64518: LD_ADDR_EXP 64
64522: PUSH
64523: LD_EXP 64
64527: PPUSH
64528: LD_VAR 0 2
64532: PPUSH
64533: EMPTY
64534: PPUSH
64535: CALL_OW 1
64539: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64540: LD_VAR 0 2
64544: PPUSH
64545: LD_INT 103
64547: PPUSH
64548: CALL 59556 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64552: LD_ADDR_VAR 0 5
64556: PUSH
64557: LD_EXP 58
64561: PUSH
64562: LD_VAR 0 2
64566: ARRAY
64567: PUSH
64568: LD_EXP 87
64572: PUSH
64573: LD_VAR 0 2
64577: ARRAY
64578: UNION
64579: PPUSH
64580: LD_INT 2
64582: PUSH
64583: LD_INT 25
64585: PUSH
64586: LD_INT 2
64588: PUSH
64589: EMPTY
64590: LIST
64591: LIST
64592: PUSH
64593: LD_INT 25
64595: PUSH
64596: LD_INT 16
64598: PUSH
64599: EMPTY
64600: LIST
64601: LIST
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: LIST
64607: PUSH
64608: EMPTY
64609: LIST
64610: PPUSH
64611: CALL_OW 72
64615: ST_TO_ADDR
// if not tmp then
64616: LD_VAR 0 5
64620: NOT
64621: IFFALSE 64625
// continue ;
64623: GO 64466
// for j in tmp do
64625: LD_ADDR_VAR 0 3
64629: PUSH
64630: LD_VAR 0 5
64634: PUSH
64635: FOR_IN
64636: IFFALSE 64830
// begin if mc_need_heal [ i ] then
64638: LD_EXP 61
64642: PUSH
64643: LD_VAR 0 2
64647: ARRAY
64648: IFFALSE 64696
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
64650: LD_VAR 0 3
64654: PUSH
64655: LD_EXP 61
64659: PUSH
64660: LD_VAR 0 2
64664: ARRAY
64665: PUSH
64666: LD_INT 1
64668: ARRAY
64669: IN
64670: PUSH
64671: LD_VAR 0 3
64675: PUSH
64676: LD_EXP 61
64680: PUSH
64681: LD_VAR 0 2
64685: ARRAY
64686: PUSH
64687: LD_INT 2
64689: ARRAY
64690: IN
64691: OR
64692: IFFALSE 64696
// continue ;
64694: GO 64635
// if IsInUnit ( j ) then
64696: LD_VAR 0 3
64700: PPUSH
64701: CALL_OW 310
64705: IFFALSE 64716
// ComExitBuilding ( j ) ;
64707: LD_VAR 0 3
64711: PPUSH
64712: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64716: LD_VAR 0 3
64720: PUSH
64721: LD_EXP 60
64725: PUSH
64726: LD_VAR 0 2
64730: ARRAY
64731: IN
64732: NOT
64733: IFFALSE 64791
// begin SetTag ( j , 101 ) ;
64735: LD_VAR 0 3
64739: PPUSH
64740: LD_INT 101
64742: PPUSH
64743: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64747: LD_ADDR_EXP 60
64751: PUSH
64752: LD_EXP 60
64756: PPUSH
64757: LD_VAR 0 2
64761: PUSH
64762: LD_EXP 60
64766: PUSH
64767: LD_VAR 0 2
64771: ARRAY
64772: PUSH
64773: LD_INT 1
64775: PLUS
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PPUSH
64781: LD_VAR 0 3
64785: PPUSH
64786: CALL 20665 0 3
64790: ST_TO_ADDR
// end ; wait ( 1 ) ;
64791: LD_INT 1
64793: PPUSH
64794: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
64798: LD_VAR 0 3
64802: PPUSH
64803: LD_EXP 59
64807: PUSH
64808: LD_VAR 0 2
64812: ARRAY
64813: PPUSH
64814: LD_VAR 0 3
64818: PPUSH
64819: CALL_OW 74
64823: PPUSH
64824: CALL_OW 130
// end ;
64828: GO 64635
64830: POP
64831: POP
// end ;
64832: GO 64466
64834: POP
64835: POP
// end ;
64836: LD_VAR 0 1
64840: RET
// export function MC_Heal ; var i , j , tmp ; begin
64841: LD_INT 0
64843: PPUSH
64844: PPUSH
64845: PPUSH
64846: PPUSH
// if not mc_bases then
64847: LD_EXP 58
64851: NOT
64852: IFFALSE 64856
// exit ;
64854: GO 65258
// for i = 1 to mc_bases do
64856: LD_ADDR_VAR 0 2
64860: PUSH
64861: DOUBLE
64862: LD_INT 1
64864: DEC
64865: ST_TO_ADDR
64866: LD_EXP 58
64870: PUSH
64871: FOR_TO
64872: IFFALSE 65256
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64874: LD_EXP 61
64878: PUSH
64879: LD_VAR 0 2
64883: ARRAY
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: NOT
64889: PUSH
64890: LD_EXP 61
64894: PUSH
64895: LD_VAR 0 2
64899: ARRAY
64900: PUSH
64901: LD_INT 2
64903: ARRAY
64904: NOT
64905: AND
64906: IFFALSE 64944
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64908: LD_ADDR_EXP 62
64912: PUSH
64913: LD_EXP 62
64917: PPUSH
64918: LD_VAR 0 2
64922: PPUSH
64923: EMPTY
64924: PPUSH
64925: CALL_OW 1
64929: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64930: LD_VAR 0 2
64934: PPUSH
64935: LD_INT 102
64937: PPUSH
64938: CALL 59556 0 2
// continue ;
64942: GO 64871
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64944: LD_ADDR_VAR 0 4
64948: PUSH
64949: LD_EXP 58
64953: PUSH
64954: LD_VAR 0 2
64958: ARRAY
64959: PPUSH
64960: LD_INT 25
64962: PUSH
64963: LD_INT 4
64965: PUSH
64966: EMPTY
64967: LIST
64968: LIST
64969: PPUSH
64970: CALL_OW 72
64974: ST_TO_ADDR
// if not tmp then
64975: LD_VAR 0 4
64979: NOT
64980: IFFALSE 64984
// continue ;
64982: GO 64871
// if mc_taming [ i ] then
64984: LD_EXP 89
64988: PUSH
64989: LD_VAR 0 2
64993: ARRAY
64994: IFFALSE 65018
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64996: LD_ADDR_EXP 89
65000: PUSH
65001: LD_EXP 89
65005: PPUSH
65006: LD_VAR 0 2
65010: PPUSH
65011: EMPTY
65012: PPUSH
65013: CALL_OW 1
65017: ST_TO_ADDR
// for j in tmp do
65018: LD_ADDR_VAR 0 3
65022: PUSH
65023: LD_VAR 0 4
65027: PUSH
65028: FOR_IN
65029: IFFALSE 65252
// begin if IsInUnit ( j ) then
65031: LD_VAR 0 3
65035: PPUSH
65036: CALL_OW 310
65040: IFFALSE 65051
// ComExitBuilding ( j ) ;
65042: LD_VAR 0 3
65046: PPUSH
65047: CALL_OW 122
// if not j in mc_healers [ i ] then
65051: LD_VAR 0 3
65055: PUSH
65056: LD_EXP 62
65060: PUSH
65061: LD_VAR 0 2
65065: ARRAY
65066: IN
65067: NOT
65068: IFFALSE 65114
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65070: LD_ADDR_EXP 62
65074: PUSH
65075: LD_EXP 62
65079: PPUSH
65080: LD_VAR 0 2
65084: PUSH
65085: LD_EXP 62
65089: PUSH
65090: LD_VAR 0 2
65094: ARRAY
65095: PUSH
65096: LD_INT 1
65098: PLUS
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PPUSH
65104: LD_VAR 0 3
65108: PPUSH
65109: CALL 20665 0 3
65113: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65114: LD_VAR 0 3
65118: PPUSH
65119: CALL_OW 110
65123: PUSH
65124: LD_INT 102
65126: NONEQUAL
65127: IFFALSE 65141
// SetTag ( j , 102 ) ;
65129: LD_VAR 0 3
65133: PPUSH
65134: LD_INT 102
65136: PPUSH
65137: CALL_OW 109
// Wait ( 3 ) ;
65141: LD_INT 3
65143: PPUSH
65144: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65148: LD_EXP 61
65152: PUSH
65153: LD_VAR 0 2
65157: ARRAY
65158: PUSH
65159: LD_INT 1
65161: ARRAY
65162: IFFALSE 65194
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65164: LD_VAR 0 3
65168: PPUSH
65169: LD_EXP 61
65173: PUSH
65174: LD_VAR 0 2
65178: ARRAY
65179: PUSH
65180: LD_INT 1
65182: ARRAY
65183: PUSH
65184: LD_INT 1
65186: ARRAY
65187: PPUSH
65188: CALL_OW 128
65192: GO 65250
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65194: LD_VAR 0 3
65198: PPUSH
65199: CALL_OW 314
65203: NOT
65204: PUSH
65205: LD_EXP 61
65209: PUSH
65210: LD_VAR 0 2
65214: ARRAY
65215: PUSH
65216: LD_INT 2
65218: ARRAY
65219: AND
65220: IFFALSE 65250
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65222: LD_VAR 0 3
65226: PPUSH
65227: LD_EXP 61
65231: PUSH
65232: LD_VAR 0 2
65236: ARRAY
65237: PUSH
65238: LD_INT 2
65240: ARRAY
65241: PUSH
65242: LD_INT 1
65244: ARRAY
65245: PPUSH
65246: CALL_OW 128
// end ;
65250: GO 65028
65252: POP
65253: POP
// end ;
65254: GO 64871
65256: POP
65257: POP
// end ;
65258: LD_VAR 0 1
65262: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65263: LD_INT 0
65265: PPUSH
65266: PPUSH
65267: PPUSH
65268: PPUSH
65269: PPUSH
// if not mc_bases then
65270: LD_EXP 58
65274: NOT
65275: IFFALSE 65279
// exit ;
65277: GO 66422
// for i = 1 to mc_bases do
65279: LD_ADDR_VAR 0 2
65283: PUSH
65284: DOUBLE
65285: LD_INT 1
65287: DEC
65288: ST_TO_ADDR
65289: LD_EXP 58
65293: PUSH
65294: FOR_TO
65295: IFFALSE 66420
// begin if mc_scan [ i ] then
65297: LD_EXP 81
65301: PUSH
65302: LD_VAR 0 2
65306: ARRAY
65307: IFFALSE 65311
// continue ;
65309: GO 65294
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65311: LD_EXP 63
65315: PUSH
65316: LD_VAR 0 2
65320: ARRAY
65321: NOT
65322: PUSH
65323: LD_EXP 65
65327: PUSH
65328: LD_VAR 0 2
65332: ARRAY
65333: NOT
65334: AND
65335: PUSH
65336: LD_EXP 64
65340: PUSH
65341: LD_VAR 0 2
65345: ARRAY
65346: AND
65347: IFFALSE 65385
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65349: LD_ADDR_EXP 64
65353: PUSH
65354: LD_EXP 64
65358: PPUSH
65359: LD_VAR 0 2
65363: PPUSH
65364: EMPTY
65365: PPUSH
65366: CALL_OW 1
65370: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65371: LD_VAR 0 2
65375: PPUSH
65376: LD_INT 103
65378: PPUSH
65379: CALL 59556 0 2
// continue ;
65383: GO 65294
// end ; if mc_construct_list [ i ] then
65385: LD_EXP 65
65389: PUSH
65390: LD_VAR 0 2
65394: ARRAY
65395: IFFALSE 65615
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65397: LD_ADDR_VAR 0 4
65401: PUSH
65402: LD_EXP 58
65406: PUSH
65407: LD_VAR 0 2
65411: ARRAY
65412: PPUSH
65413: LD_INT 25
65415: PUSH
65416: LD_INT 2
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PPUSH
65423: CALL_OW 72
65427: PUSH
65428: LD_EXP 60
65432: PUSH
65433: LD_VAR 0 2
65437: ARRAY
65438: DIFF
65439: ST_TO_ADDR
// if not tmp then
65440: LD_VAR 0 4
65444: NOT
65445: IFFALSE 65449
// continue ;
65447: GO 65294
// for j in tmp do
65449: LD_ADDR_VAR 0 3
65453: PUSH
65454: LD_VAR 0 4
65458: PUSH
65459: FOR_IN
65460: IFFALSE 65611
// begin if not mc_builders [ i ] then
65462: LD_EXP 64
65466: PUSH
65467: LD_VAR 0 2
65471: ARRAY
65472: NOT
65473: IFFALSE 65531
// begin SetTag ( j , 103 ) ;
65475: LD_VAR 0 3
65479: PPUSH
65480: LD_INT 103
65482: PPUSH
65483: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65487: LD_ADDR_EXP 64
65491: PUSH
65492: LD_EXP 64
65496: PPUSH
65497: LD_VAR 0 2
65501: PUSH
65502: LD_EXP 64
65506: PUSH
65507: LD_VAR 0 2
65511: ARRAY
65512: PUSH
65513: LD_INT 1
65515: PLUS
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PPUSH
65521: LD_VAR 0 3
65525: PPUSH
65526: CALL 20665 0 3
65530: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65531: LD_VAR 0 3
65535: PPUSH
65536: CALL_OW 310
65540: IFFALSE 65551
// ComExitBuilding ( j ) ;
65542: LD_VAR 0 3
65546: PPUSH
65547: CALL_OW 122
// wait ( 3 ) ;
65551: LD_INT 3
65553: PPUSH
65554: CALL_OW 67
// if not mc_construct_list [ i ] then
65558: LD_EXP 65
65562: PUSH
65563: LD_VAR 0 2
65567: ARRAY
65568: NOT
65569: IFFALSE 65573
// break ;
65571: GO 65611
// if not HasTask ( j ) then
65573: LD_VAR 0 3
65577: PPUSH
65578: CALL_OW 314
65582: NOT
65583: IFFALSE 65609
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65585: LD_VAR 0 3
65589: PPUSH
65590: LD_EXP 65
65594: PUSH
65595: LD_VAR 0 2
65599: ARRAY
65600: PUSH
65601: LD_INT 1
65603: ARRAY
65604: PPUSH
65605: CALL 23516 0 2
// end ;
65609: GO 65459
65611: POP
65612: POP
// end else
65613: GO 66418
// if mc_build_list [ i ] then
65615: LD_EXP 63
65619: PUSH
65620: LD_VAR 0 2
65624: ARRAY
65625: IFFALSE 66418
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65627: LD_ADDR_VAR 0 5
65631: PUSH
65632: LD_EXP 58
65636: PUSH
65637: LD_VAR 0 2
65641: ARRAY
65642: PPUSH
65643: LD_INT 2
65645: PUSH
65646: LD_INT 30
65648: PUSH
65649: LD_INT 0
65651: PUSH
65652: EMPTY
65653: LIST
65654: LIST
65655: PUSH
65656: LD_INT 30
65658: PUSH
65659: LD_INT 1
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: LIST
65670: PPUSH
65671: CALL_OW 72
65675: ST_TO_ADDR
// if depot then
65676: LD_VAR 0 5
65680: IFFALSE 65698
// depot := depot [ 1 ] else
65682: LD_ADDR_VAR 0 5
65686: PUSH
65687: LD_VAR 0 5
65691: PUSH
65692: LD_INT 1
65694: ARRAY
65695: ST_TO_ADDR
65696: GO 65706
// depot := 0 ;
65698: LD_ADDR_VAR 0 5
65702: PUSH
65703: LD_INT 0
65705: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65706: LD_EXP 63
65710: PUSH
65711: LD_VAR 0 2
65715: ARRAY
65716: PUSH
65717: LD_INT 1
65719: ARRAY
65720: PUSH
65721: LD_INT 1
65723: ARRAY
65724: PPUSH
65725: CALL 23346 0 1
65729: PUSH
65730: LD_EXP 58
65734: PUSH
65735: LD_VAR 0 2
65739: ARRAY
65740: PPUSH
65741: LD_INT 2
65743: PUSH
65744: LD_INT 30
65746: PUSH
65747: LD_INT 2
65749: PUSH
65750: EMPTY
65751: LIST
65752: LIST
65753: PUSH
65754: LD_INT 30
65756: PUSH
65757: LD_INT 3
65759: PUSH
65760: EMPTY
65761: LIST
65762: LIST
65763: PUSH
65764: EMPTY
65765: LIST
65766: LIST
65767: LIST
65768: PPUSH
65769: CALL_OW 72
65773: NOT
65774: AND
65775: IFFALSE 65880
// begin for j = 1 to mc_build_list [ i ] do
65777: LD_ADDR_VAR 0 3
65781: PUSH
65782: DOUBLE
65783: LD_INT 1
65785: DEC
65786: ST_TO_ADDR
65787: LD_EXP 63
65791: PUSH
65792: LD_VAR 0 2
65796: ARRAY
65797: PUSH
65798: FOR_TO
65799: IFFALSE 65878
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65801: LD_EXP 63
65805: PUSH
65806: LD_VAR 0 2
65810: ARRAY
65811: PUSH
65812: LD_VAR 0 3
65816: ARRAY
65817: PUSH
65818: LD_INT 1
65820: ARRAY
65821: PUSH
65822: LD_INT 2
65824: EQUAL
65825: IFFALSE 65876
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65827: LD_ADDR_EXP 63
65831: PUSH
65832: LD_EXP 63
65836: PPUSH
65837: LD_VAR 0 2
65841: PPUSH
65842: LD_EXP 63
65846: PUSH
65847: LD_VAR 0 2
65851: ARRAY
65852: PPUSH
65853: LD_VAR 0 3
65857: PPUSH
65858: LD_INT 1
65860: PPUSH
65861: LD_INT 0
65863: PPUSH
65864: CALL 20083 0 4
65868: PPUSH
65869: CALL_OW 1
65873: ST_TO_ADDR
// break ;
65874: GO 65878
// end ;
65876: GO 65798
65878: POP
65879: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65880: LD_EXP 63
65884: PUSH
65885: LD_VAR 0 2
65889: ARRAY
65890: PUSH
65891: LD_INT 1
65893: ARRAY
65894: PUSH
65895: LD_INT 1
65897: ARRAY
65898: PUSH
65899: LD_INT 0
65901: EQUAL
65902: PUSH
65903: LD_VAR 0 5
65907: PUSH
65908: LD_VAR 0 5
65912: PPUSH
65913: LD_EXP 63
65917: PUSH
65918: LD_VAR 0 2
65922: ARRAY
65923: PUSH
65924: LD_INT 1
65926: ARRAY
65927: PUSH
65928: LD_INT 1
65930: ARRAY
65931: PPUSH
65932: LD_EXP 63
65936: PUSH
65937: LD_VAR 0 2
65941: ARRAY
65942: PUSH
65943: LD_INT 1
65945: ARRAY
65946: PUSH
65947: LD_INT 2
65949: ARRAY
65950: PPUSH
65951: LD_EXP 63
65955: PUSH
65956: LD_VAR 0 2
65960: ARRAY
65961: PUSH
65962: LD_INT 1
65964: ARRAY
65965: PUSH
65966: LD_INT 3
65968: ARRAY
65969: PPUSH
65970: LD_EXP 63
65974: PUSH
65975: LD_VAR 0 2
65979: ARRAY
65980: PUSH
65981: LD_INT 1
65983: ARRAY
65984: PUSH
65985: LD_INT 4
65987: ARRAY
65988: PPUSH
65989: CALL 28062 0 5
65993: AND
65994: OR
65995: IFFALSE 66276
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65997: LD_ADDR_VAR 0 4
66001: PUSH
66002: LD_EXP 58
66006: PUSH
66007: LD_VAR 0 2
66011: ARRAY
66012: PPUSH
66013: LD_INT 25
66015: PUSH
66016: LD_INT 2
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PPUSH
66023: CALL_OW 72
66027: PUSH
66028: LD_EXP 60
66032: PUSH
66033: LD_VAR 0 2
66037: ARRAY
66038: DIFF
66039: ST_TO_ADDR
// if not tmp then
66040: LD_VAR 0 4
66044: NOT
66045: IFFALSE 66049
// continue ;
66047: GO 65294
// for j in tmp do
66049: LD_ADDR_VAR 0 3
66053: PUSH
66054: LD_VAR 0 4
66058: PUSH
66059: FOR_IN
66060: IFFALSE 66272
// begin if not mc_builders [ i ] then
66062: LD_EXP 64
66066: PUSH
66067: LD_VAR 0 2
66071: ARRAY
66072: NOT
66073: IFFALSE 66131
// begin SetTag ( j , 103 ) ;
66075: LD_VAR 0 3
66079: PPUSH
66080: LD_INT 103
66082: PPUSH
66083: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66087: LD_ADDR_EXP 64
66091: PUSH
66092: LD_EXP 64
66096: PPUSH
66097: LD_VAR 0 2
66101: PUSH
66102: LD_EXP 64
66106: PUSH
66107: LD_VAR 0 2
66111: ARRAY
66112: PUSH
66113: LD_INT 1
66115: PLUS
66116: PUSH
66117: EMPTY
66118: LIST
66119: LIST
66120: PPUSH
66121: LD_VAR 0 3
66125: PPUSH
66126: CALL 20665 0 3
66130: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66131: LD_VAR 0 3
66135: PPUSH
66136: CALL_OW 310
66140: IFFALSE 66151
// ComExitBuilding ( j ) ;
66142: LD_VAR 0 3
66146: PPUSH
66147: CALL_OW 122
// wait ( 3 ) ;
66151: LD_INT 3
66153: PPUSH
66154: CALL_OW 67
// if not mc_build_list [ i ] then
66158: LD_EXP 63
66162: PUSH
66163: LD_VAR 0 2
66167: ARRAY
66168: NOT
66169: IFFALSE 66173
// break ;
66171: GO 66272
// if not HasTask ( j ) then
66173: LD_VAR 0 3
66177: PPUSH
66178: CALL_OW 314
66182: NOT
66183: IFFALSE 66270
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66185: LD_VAR 0 3
66189: PPUSH
66190: LD_EXP 63
66194: PUSH
66195: LD_VAR 0 2
66199: ARRAY
66200: PUSH
66201: LD_INT 1
66203: ARRAY
66204: PUSH
66205: LD_INT 1
66207: ARRAY
66208: PPUSH
66209: LD_EXP 63
66213: PUSH
66214: LD_VAR 0 2
66218: ARRAY
66219: PUSH
66220: LD_INT 1
66222: ARRAY
66223: PUSH
66224: LD_INT 2
66226: ARRAY
66227: PPUSH
66228: LD_EXP 63
66232: PUSH
66233: LD_VAR 0 2
66237: ARRAY
66238: PUSH
66239: LD_INT 1
66241: ARRAY
66242: PUSH
66243: LD_INT 3
66245: ARRAY
66246: PPUSH
66247: LD_EXP 63
66251: PUSH
66252: LD_VAR 0 2
66256: ARRAY
66257: PUSH
66258: LD_INT 1
66260: ARRAY
66261: PUSH
66262: LD_INT 4
66264: ARRAY
66265: PPUSH
66266: CALL_OW 145
// end ;
66270: GO 66059
66272: POP
66273: POP
// end else
66274: GO 66418
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
66276: LD_EXP 58
66280: PUSH
66281: LD_VAR 0 2
66285: ARRAY
66286: PPUSH
66287: LD_EXP 63
66291: PUSH
66292: LD_VAR 0 2
66296: ARRAY
66297: PUSH
66298: LD_INT 1
66300: ARRAY
66301: PUSH
66302: LD_INT 1
66304: ARRAY
66305: PPUSH
66306: LD_EXP 63
66310: PUSH
66311: LD_VAR 0 2
66315: ARRAY
66316: PUSH
66317: LD_INT 1
66319: ARRAY
66320: PUSH
66321: LD_INT 2
66323: ARRAY
66324: PPUSH
66325: LD_EXP 63
66329: PUSH
66330: LD_VAR 0 2
66334: ARRAY
66335: PUSH
66336: LD_INT 1
66338: ARRAY
66339: PUSH
66340: LD_INT 3
66342: ARRAY
66343: PPUSH
66344: LD_EXP 63
66348: PUSH
66349: LD_VAR 0 2
66353: ARRAY
66354: PUSH
66355: LD_INT 1
66357: ARRAY
66358: PUSH
66359: LD_INT 4
66361: ARRAY
66362: PPUSH
66363: CALL 27416 0 5
66367: NOT
66368: IFFALSE 66418
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66370: LD_ADDR_EXP 63
66374: PUSH
66375: LD_EXP 63
66379: PPUSH
66380: LD_VAR 0 2
66384: PPUSH
66385: LD_EXP 63
66389: PUSH
66390: LD_VAR 0 2
66394: ARRAY
66395: PPUSH
66396: LD_INT 1
66398: PPUSH
66399: LD_INT 1
66401: NEG
66402: PPUSH
66403: LD_INT 0
66405: PPUSH
66406: CALL 20083 0 4
66410: PPUSH
66411: CALL_OW 1
66415: ST_TO_ADDR
// continue ;
66416: GO 65294
// end ; end ; end ;
66418: GO 65294
66420: POP
66421: POP
// end ;
66422: LD_VAR 0 1
66426: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66427: LD_INT 0
66429: PPUSH
66430: PPUSH
66431: PPUSH
66432: PPUSH
66433: PPUSH
66434: PPUSH
// if not mc_bases then
66435: LD_EXP 58
66439: NOT
66440: IFFALSE 66444
// exit ;
66442: GO 66871
// for i = 1 to mc_bases do
66444: LD_ADDR_VAR 0 2
66448: PUSH
66449: DOUBLE
66450: LD_INT 1
66452: DEC
66453: ST_TO_ADDR
66454: LD_EXP 58
66458: PUSH
66459: FOR_TO
66460: IFFALSE 66869
// begin tmp := mc_build_upgrade [ i ] ;
66462: LD_ADDR_VAR 0 4
66466: PUSH
66467: LD_EXP 90
66471: PUSH
66472: LD_VAR 0 2
66476: ARRAY
66477: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66478: LD_ADDR_VAR 0 6
66482: PUSH
66483: LD_EXP 91
66487: PUSH
66488: LD_VAR 0 2
66492: ARRAY
66493: PPUSH
66494: LD_INT 2
66496: PUSH
66497: LD_INT 30
66499: PUSH
66500: LD_INT 6
66502: PUSH
66503: EMPTY
66504: LIST
66505: LIST
66506: PUSH
66507: LD_INT 30
66509: PUSH
66510: LD_INT 7
66512: PUSH
66513: EMPTY
66514: LIST
66515: LIST
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: LIST
66521: PPUSH
66522: CALL_OW 72
66526: ST_TO_ADDR
// if not tmp and not lab then
66527: LD_VAR 0 4
66531: NOT
66532: PUSH
66533: LD_VAR 0 6
66537: NOT
66538: AND
66539: IFFALSE 66543
// continue ;
66541: GO 66459
// if tmp then
66543: LD_VAR 0 4
66547: IFFALSE 66667
// for j in tmp do
66549: LD_ADDR_VAR 0 3
66553: PUSH
66554: LD_VAR 0 4
66558: PUSH
66559: FOR_IN
66560: IFFALSE 66665
// begin if UpgradeCost ( j ) then
66562: LD_VAR 0 3
66566: PPUSH
66567: CALL 27076 0 1
66571: IFFALSE 66663
// begin ComUpgrade ( j ) ;
66573: LD_VAR 0 3
66577: PPUSH
66578: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66582: LD_ADDR_EXP 90
66586: PUSH
66587: LD_EXP 90
66591: PPUSH
66592: LD_VAR 0 2
66596: PPUSH
66597: LD_EXP 90
66601: PUSH
66602: LD_VAR 0 2
66606: ARRAY
66607: PUSH
66608: LD_VAR 0 3
66612: DIFF
66613: PPUSH
66614: CALL_OW 1
66618: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66619: LD_ADDR_EXP 65
66623: PUSH
66624: LD_EXP 65
66628: PPUSH
66629: LD_VAR 0 2
66633: PUSH
66634: LD_EXP 65
66638: PUSH
66639: LD_VAR 0 2
66643: ARRAY
66644: PUSH
66645: LD_INT 1
66647: PLUS
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PPUSH
66653: LD_VAR 0 3
66657: PPUSH
66658: CALL 20665 0 3
66662: ST_TO_ADDR
// end ; end ;
66663: GO 66559
66665: POP
66666: POP
// if not lab or not mc_lab_upgrade [ i ] then
66667: LD_VAR 0 6
66671: NOT
66672: PUSH
66673: LD_EXP 92
66677: PUSH
66678: LD_VAR 0 2
66682: ARRAY
66683: NOT
66684: OR
66685: IFFALSE 66689
// continue ;
66687: GO 66459
// for j in lab do
66689: LD_ADDR_VAR 0 3
66693: PUSH
66694: LD_VAR 0 6
66698: PUSH
66699: FOR_IN
66700: IFFALSE 66865
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66702: LD_VAR 0 3
66706: PPUSH
66707: CALL_OW 266
66711: PUSH
66712: LD_INT 6
66714: PUSH
66715: LD_INT 7
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: IN
66722: PUSH
66723: LD_VAR 0 3
66727: PPUSH
66728: CALL_OW 461
66732: PUSH
66733: LD_INT 1
66735: NONEQUAL
66736: AND
66737: IFFALSE 66863
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66739: LD_VAR 0 3
66743: PPUSH
66744: LD_EXP 92
66748: PUSH
66749: LD_VAR 0 2
66753: ARRAY
66754: PUSH
66755: LD_INT 1
66757: ARRAY
66758: PPUSH
66759: CALL 27281 0 2
66763: IFFALSE 66863
// begin ComCancel ( j ) ;
66765: LD_VAR 0 3
66769: PPUSH
66770: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66774: LD_VAR 0 3
66778: PPUSH
66779: LD_EXP 92
66783: PUSH
66784: LD_VAR 0 2
66788: ARRAY
66789: PUSH
66790: LD_INT 1
66792: ARRAY
66793: PPUSH
66794: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66798: LD_VAR 0 3
66802: PUSH
66803: LD_EXP 65
66807: PUSH
66808: LD_VAR 0 2
66812: ARRAY
66813: IN
66814: NOT
66815: IFFALSE 66861
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66817: LD_ADDR_EXP 65
66821: PUSH
66822: LD_EXP 65
66826: PPUSH
66827: LD_VAR 0 2
66831: PUSH
66832: LD_EXP 65
66836: PUSH
66837: LD_VAR 0 2
66841: ARRAY
66842: PUSH
66843: LD_INT 1
66845: PLUS
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PPUSH
66851: LD_VAR 0 3
66855: PPUSH
66856: CALL 20665 0 3
66860: ST_TO_ADDR
// break ;
66861: GO 66865
// end ; end ; end ;
66863: GO 66699
66865: POP
66866: POP
// end ;
66867: GO 66459
66869: POP
66870: POP
// end ;
66871: LD_VAR 0 1
66875: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66876: LD_INT 0
66878: PPUSH
66879: PPUSH
66880: PPUSH
66881: PPUSH
66882: PPUSH
66883: PPUSH
66884: PPUSH
66885: PPUSH
66886: PPUSH
// if not mc_bases then
66887: LD_EXP 58
66891: NOT
66892: IFFALSE 66896
// exit ;
66894: GO 67301
// for i = 1 to mc_bases do
66896: LD_ADDR_VAR 0 2
66900: PUSH
66901: DOUBLE
66902: LD_INT 1
66904: DEC
66905: ST_TO_ADDR
66906: LD_EXP 58
66910: PUSH
66911: FOR_TO
66912: IFFALSE 67299
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66914: LD_EXP 66
66918: PUSH
66919: LD_VAR 0 2
66923: ARRAY
66924: NOT
66925: PUSH
66926: LD_EXP 58
66930: PUSH
66931: LD_VAR 0 2
66935: ARRAY
66936: PPUSH
66937: LD_INT 30
66939: PUSH
66940: LD_INT 3
66942: PUSH
66943: EMPTY
66944: LIST
66945: LIST
66946: PPUSH
66947: CALL_OW 72
66951: NOT
66952: OR
66953: IFFALSE 66957
// continue ;
66955: GO 66911
// busy := false ;
66957: LD_ADDR_VAR 0 8
66961: PUSH
66962: LD_INT 0
66964: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66965: LD_ADDR_VAR 0 4
66969: PUSH
66970: LD_EXP 58
66974: PUSH
66975: LD_VAR 0 2
66979: ARRAY
66980: PPUSH
66981: LD_INT 30
66983: PUSH
66984: LD_INT 3
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: PPUSH
66991: CALL_OW 72
66995: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66996: LD_ADDR_VAR 0 6
67000: PUSH
67001: LD_EXP 66
67005: PUSH
67006: LD_VAR 0 2
67010: ARRAY
67011: PPUSH
67012: LD_INT 2
67014: PUSH
67015: LD_INT 30
67017: PUSH
67018: LD_INT 32
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 30
67027: PUSH
67028: LD_INT 33
67030: PUSH
67031: EMPTY
67032: LIST
67033: LIST
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: LIST
67039: PPUSH
67040: CALL_OW 72
67044: ST_TO_ADDR
// if not t then
67045: LD_VAR 0 6
67049: NOT
67050: IFFALSE 67054
// continue ;
67052: GO 66911
// for j in tmp do
67054: LD_ADDR_VAR 0 3
67058: PUSH
67059: LD_VAR 0 4
67063: PUSH
67064: FOR_IN
67065: IFFALSE 67095
// if not BuildingStatus ( j ) = bs_idle then
67067: LD_VAR 0 3
67071: PPUSH
67072: CALL_OW 461
67076: PUSH
67077: LD_INT 2
67079: EQUAL
67080: NOT
67081: IFFALSE 67093
// begin busy := true ;
67083: LD_ADDR_VAR 0 8
67087: PUSH
67088: LD_INT 1
67090: ST_TO_ADDR
// break ;
67091: GO 67095
// end ;
67093: GO 67064
67095: POP
67096: POP
// if busy then
67097: LD_VAR 0 8
67101: IFFALSE 67105
// continue ;
67103: GO 66911
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67105: LD_ADDR_VAR 0 7
67109: PUSH
67110: LD_VAR 0 6
67114: PPUSH
67115: LD_INT 35
67117: PUSH
67118: LD_INT 0
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PPUSH
67125: CALL_OW 72
67129: ST_TO_ADDR
// if tw then
67130: LD_VAR 0 7
67134: IFFALSE 67211
// begin tw := tw [ 1 ] ;
67136: LD_ADDR_VAR 0 7
67140: PUSH
67141: LD_VAR 0 7
67145: PUSH
67146: LD_INT 1
67148: ARRAY
67149: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67150: LD_ADDR_VAR 0 9
67154: PUSH
67155: LD_VAR 0 7
67159: PPUSH
67160: LD_EXP 83
67164: PUSH
67165: LD_VAR 0 2
67169: ARRAY
67170: PPUSH
67171: CALL 25635 0 2
67175: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67176: LD_EXP 97
67180: PUSH
67181: LD_VAR 0 2
67185: ARRAY
67186: IFFALSE 67209
// if not weapon in mc_allowed_tower_weapons [ i ] then
67188: LD_VAR 0 9
67192: PUSH
67193: LD_EXP 97
67197: PUSH
67198: LD_VAR 0 2
67202: ARRAY
67203: IN
67204: NOT
67205: IFFALSE 67209
// continue ;
67207: GO 66911
// end else
67209: GO 67274
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67211: LD_ADDR_VAR 0 5
67215: PUSH
67216: LD_EXP 66
67220: PUSH
67221: LD_VAR 0 2
67225: ARRAY
67226: PPUSH
67227: LD_VAR 0 4
67231: PPUSH
67232: CALL 55774 0 2
67236: ST_TO_ADDR
// if not tmp2 then
67237: LD_VAR 0 5
67241: NOT
67242: IFFALSE 67246
// continue ;
67244: GO 66911
// tw := tmp2 [ 1 ] ;
67246: LD_ADDR_VAR 0 7
67250: PUSH
67251: LD_VAR 0 5
67255: PUSH
67256: LD_INT 1
67258: ARRAY
67259: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67260: LD_ADDR_VAR 0 9
67264: PUSH
67265: LD_VAR 0 5
67269: PUSH
67270: LD_INT 2
67272: ARRAY
67273: ST_TO_ADDR
// end ; if not weapon then
67274: LD_VAR 0 9
67278: NOT
67279: IFFALSE 67283
// continue ;
67281: GO 66911
// ComPlaceWeapon ( tw , weapon ) ;
67283: LD_VAR 0 7
67287: PPUSH
67288: LD_VAR 0 9
67292: PPUSH
67293: CALL_OW 148
// end ;
67297: GO 66911
67299: POP
67300: POP
// end ;
67301: LD_VAR 0 1
67305: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
67306: LD_INT 0
67308: PPUSH
67309: PPUSH
67310: PPUSH
67311: PPUSH
67312: PPUSH
67313: PPUSH
// if not mc_bases then
67314: LD_EXP 58
67318: NOT
67319: IFFALSE 67323
// exit ;
67321: GO 68335
// for i = 1 to mc_bases do
67323: LD_ADDR_VAR 0 2
67327: PUSH
67328: DOUBLE
67329: LD_INT 1
67331: DEC
67332: ST_TO_ADDR
67333: LD_EXP 58
67337: PUSH
67338: FOR_TO
67339: IFFALSE 68333
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
67341: LD_EXP 71
67345: PUSH
67346: LD_VAR 0 2
67350: ARRAY
67351: NOT
67352: PUSH
67353: LD_EXP 71
67357: PUSH
67358: LD_VAR 0 2
67362: ARRAY
67363: PUSH
67364: LD_EXP 72
67368: PUSH
67369: LD_VAR 0 2
67373: ARRAY
67374: EQUAL
67375: OR
67376: IFFALSE 67380
// continue ;
67378: GO 67338
// if mc_miners [ i ] then
67380: LD_EXP 72
67384: PUSH
67385: LD_VAR 0 2
67389: ARRAY
67390: IFFALSE 68020
// begin k := 1 ;
67392: LD_ADDR_VAR 0 4
67396: PUSH
67397: LD_INT 1
67399: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
67400: LD_ADDR_VAR 0 3
67404: PUSH
67405: DOUBLE
67406: LD_EXP 72
67410: PUSH
67411: LD_VAR 0 2
67415: ARRAY
67416: INC
67417: ST_TO_ADDR
67418: LD_INT 1
67420: PUSH
67421: FOR_DOWNTO
67422: IFFALSE 68018
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67424: LD_EXP 72
67428: PUSH
67429: LD_VAR 0 2
67433: ARRAY
67434: PUSH
67435: LD_VAR 0 3
67439: ARRAY
67440: PPUSH
67441: CALL_OW 301
67445: PUSH
67446: LD_EXP 72
67450: PUSH
67451: LD_VAR 0 2
67455: ARRAY
67456: PUSH
67457: LD_VAR 0 3
67461: ARRAY
67462: PPUSH
67463: CALL_OW 257
67467: PUSH
67468: LD_INT 1
67470: NONEQUAL
67471: OR
67472: IFFALSE 67535
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67474: LD_ADDR_VAR 0 5
67478: PUSH
67479: LD_EXP 72
67483: PUSH
67484: LD_VAR 0 2
67488: ARRAY
67489: PUSH
67490: LD_EXP 72
67494: PUSH
67495: LD_VAR 0 2
67499: ARRAY
67500: PUSH
67501: LD_VAR 0 3
67505: ARRAY
67506: DIFF
67507: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67508: LD_ADDR_EXP 72
67512: PUSH
67513: LD_EXP 72
67517: PPUSH
67518: LD_VAR 0 2
67522: PPUSH
67523: LD_VAR 0 5
67527: PPUSH
67528: CALL_OW 1
67532: ST_TO_ADDR
// continue ;
67533: GO 67421
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
67535: LD_EXP 72
67539: PUSH
67540: LD_VAR 0 2
67544: ARRAY
67545: PUSH
67546: LD_VAR 0 3
67550: ARRAY
67551: PPUSH
67552: CALL 20601 0 1
67556: PUSH
67557: LD_EXP 72
67561: PUSH
67562: LD_VAR 0 2
67566: ARRAY
67567: PUSH
67568: LD_VAR 0 3
67572: ARRAY
67573: PPUSH
67574: CALL_OW 255
67578: PPUSH
67579: LD_EXP 71
67583: PUSH
67584: LD_VAR 0 2
67588: ARRAY
67589: PUSH
67590: LD_VAR 0 4
67594: ARRAY
67595: PUSH
67596: LD_INT 1
67598: ARRAY
67599: PPUSH
67600: LD_EXP 71
67604: PUSH
67605: LD_VAR 0 2
67609: ARRAY
67610: PUSH
67611: LD_VAR 0 4
67615: ARRAY
67616: PUSH
67617: LD_INT 2
67619: ARRAY
67620: PPUSH
67621: LD_INT 15
67623: PPUSH
67624: CALL 21561 0 4
67628: PUSH
67629: LD_INT 4
67631: ARRAY
67632: PUSH
67633: LD_EXP 72
67637: PUSH
67638: LD_VAR 0 2
67642: ARRAY
67643: PUSH
67644: LD_VAR 0 3
67648: ARRAY
67649: PPUSH
67650: LD_INT 10
67652: PPUSH
67653: CALL 23258 0 2
67657: PUSH
67658: LD_INT 4
67660: ARRAY
67661: OR
67662: AND
67663: IFFALSE 67686
// ComStop ( mc_miners [ i ] [ j ] ) ;
67665: LD_EXP 72
67669: PUSH
67670: LD_VAR 0 2
67674: ARRAY
67675: PUSH
67676: LD_VAR 0 3
67680: ARRAY
67681: PPUSH
67682: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
67686: LD_EXP 72
67690: PUSH
67691: LD_VAR 0 2
67695: ARRAY
67696: PUSH
67697: LD_VAR 0 3
67701: ARRAY
67702: PPUSH
67703: CALL_OW 257
67707: PUSH
67708: LD_INT 1
67710: EQUAL
67711: PUSH
67712: LD_EXP 72
67716: PUSH
67717: LD_VAR 0 2
67721: ARRAY
67722: PUSH
67723: LD_VAR 0 3
67727: ARRAY
67728: PPUSH
67729: CALL_OW 459
67733: NOT
67734: AND
67735: PUSH
67736: LD_EXP 72
67740: PUSH
67741: LD_VAR 0 2
67745: ARRAY
67746: PUSH
67747: LD_VAR 0 3
67751: ARRAY
67752: PPUSH
67753: CALL_OW 255
67757: PPUSH
67758: LD_EXP 71
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: PUSH
67769: LD_VAR 0 4
67773: ARRAY
67774: PUSH
67775: LD_INT 1
67777: ARRAY
67778: PPUSH
67779: LD_EXP 71
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: PUSH
67790: LD_VAR 0 4
67794: ARRAY
67795: PUSH
67796: LD_INT 2
67798: ARRAY
67799: PPUSH
67800: LD_INT 15
67802: PPUSH
67803: CALL 21561 0 4
67807: PUSH
67808: LD_INT 4
67810: ARRAY
67811: PUSH
67812: LD_INT 0
67814: EQUAL
67815: AND
67816: PUSH
67817: LD_EXP 72
67821: PUSH
67822: LD_VAR 0 2
67826: ARRAY
67827: PUSH
67828: LD_VAR 0 3
67832: ARRAY
67833: PPUSH
67834: CALL_OW 314
67838: NOT
67839: AND
67840: IFFALSE 68016
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67842: LD_EXP 72
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PUSH
67853: LD_VAR 0 3
67857: ARRAY
67858: PPUSH
67859: CALL_OW 310
67863: IFFALSE 67886
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67865: LD_EXP 72
67869: PUSH
67870: LD_VAR 0 2
67874: ARRAY
67875: PUSH
67876: LD_VAR 0 3
67880: ARRAY
67881: PPUSH
67882: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67886: LD_EXP 72
67890: PUSH
67891: LD_VAR 0 2
67895: ARRAY
67896: PUSH
67897: LD_VAR 0 3
67901: ARRAY
67902: PPUSH
67903: CALL_OW 314
67907: NOT
67908: IFFALSE 67976
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
67910: LD_EXP 72
67914: PUSH
67915: LD_VAR 0 2
67919: ARRAY
67920: PUSH
67921: LD_VAR 0 3
67925: ARRAY
67926: PPUSH
67927: LD_EXP 71
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: PUSH
67938: LD_VAR 0 4
67942: ARRAY
67943: PUSH
67944: LD_INT 1
67946: ARRAY
67947: PPUSH
67948: LD_EXP 71
67952: PUSH
67953: LD_VAR 0 2
67957: ARRAY
67958: PUSH
67959: LD_VAR 0 4
67963: ARRAY
67964: PUSH
67965: LD_INT 2
67967: ARRAY
67968: PPUSH
67969: LD_INT 0
67971: PPUSH
67972: CALL_OW 193
// k := k + 1 ;
67976: LD_ADDR_VAR 0 4
67980: PUSH
67981: LD_VAR 0 4
67985: PUSH
67986: LD_INT 1
67988: PLUS
67989: ST_TO_ADDR
// if k > mc_mines [ i ] then
67990: LD_VAR 0 4
67994: PUSH
67995: LD_EXP 71
67999: PUSH
68000: LD_VAR 0 2
68004: ARRAY
68005: GREATER
68006: IFFALSE 68016
// k := 1 ;
68008: LD_ADDR_VAR 0 4
68012: PUSH
68013: LD_INT 1
68015: ST_TO_ADDR
// end ; end ;
68016: GO 67421
68018: POP
68019: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
68020: LD_ADDR_VAR 0 5
68024: PUSH
68025: LD_EXP 58
68029: PUSH
68030: LD_VAR 0 2
68034: ARRAY
68035: PPUSH
68036: LD_INT 2
68038: PUSH
68039: LD_INT 30
68041: PUSH
68042: LD_INT 4
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: PUSH
68049: LD_INT 30
68051: PUSH
68052: LD_INT 5
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: PUSH
68059: LD_INT 30
68061: PUSH
68062: LD_INT 32
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: EMPTY
68070: LIST
68071: LIST
68072: LIST
68073: LIST
68074: PPUSH
68075: CALL_OW 72
68079: ST_TO_ADDR
// if not tmp then
68080: LD_VAR 0 5
68084: NOT
68085: IFFALSE 68089
// continue ;
68087: GO 67338
// list := [ ] ;
68089: LD_ADDR_VAR 0 6
68093: PUSH
68094: EMPTY
68095: ST_TO_ADDR
// for j in tmp do
68096: LD_ADDR_VAR 0 3
68100: PUSH
68101: LD_VAR 0 5
68105: PUSH
68106: FOR_IN
68107: IFFALSE 68176
// begin for k in UnitsInside ( j ) do
68109: LD_ADDR_VAR 0 4
68113: PUSH
68114: LD_VAR 0 3
68118: PPUSH
68119: CALL_OW 313
68123: PUSH
68124: FOR_IN
68125: IFFALSE 68172
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
68127: LD_VAR 0 4
68131: PPUSH
68132: CALL_OW 257
68136: PUSH
68137: LD_INT 1
68139: EQUAL
68140: PUSH
68141: LD_VAR 0 4
68145: PPUSH
68146: CALL_OW 459
68150: NOT
68151: AND
68152: IFFALSE 68170
// list := list ^ k ;
68154: LD_ADDR_VAR 0 6
68158: PUSH
68159: LD_VAR 0 6
68163: PUSH
68164: LD_VAR 0 4
68168: ADD
68169: ST_TO_ADDR
68170: GO 68124
68172: POP
68173: POP
// end ;
68174: GO 68106
68176: POP
68177: POP
// list := list diff mc_miners [ i ] ;
68178: LD_ADDR_VAR 0 6
68182: PUSH
68183: LD_VAR 0 6
68187: PUSH
68188: LD_EXP 72
68192: PUSH
68193: LD_VAR 0 2
68197: ARRAY
68198: DIFF
68199: ST_TO_ADDR
// if not list then
68200: LD_VAR 0 6
68204: NOT
68205: IFFALSE 68209
// continue ;
68207: GO 67338
// k := mc_mines [ i ] - mc_miners [ i ] ;
68209: LD_ADDR_VAR 0 4
68213: PUSH
68214: LD_EXP 71
68218: PUSH
68219: LD_VAR 0 2
68223: ARRAY
68224: PUSH
68225: LD_EXP 72
68229: PUSH
68230: LD_VAR 0 2
68234: ARRAY
68235: MINUS
68236: ST_TO_ADDR
// if k > list then
68237: LD_VAR 0 4
68241: PUSH
68242: LD_VAR 0 6
68246: GREATER
68247: IFFALSE 68259
// k := list ;
68249: LD_ADDR_VAR 0 4
68253: PUSH
68254: LD_VAR 0 6
68258: ST_TO_ADDR
// for j = 1 to k do
68259: LD_ADDR_VAR 0 3
68263: PUSH
68264: DOUBLE
68265: LD_INT 1
68267: DEC
68268: ST_TO_ADDR
68269: LD_VAR 0 4
68273: PUSH
68274: FOR_TO
68275: IFFALSE 68329
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68277: LD_ADDR_EXP 72
68281: PUSH
68282: LD_EXP 72
68286: PPUSH
68287: LD_VAR 0 2
68291: PUSH
68292: LD_EXP 72
68296: PUSH
68297: LD_VAR 0 2
68301: ARRAY
68302: PUSH
68303: LD_INT 1
68305: PLUS
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: PPUSH
68311: LD_VAR 0 6
68315: PUSH
68316: LD_VAR 0 3
68320: ARRAY
68321: PPUSH
68322: CALL 20665 0 3
68326: ST_TO_ADDR
68327: GO 68274
68329: POP
68330: POP
// end ;
68331: GO 67338
68333: POP
68334: POP
// end ;
68335: LD_VAR 0 1
68339: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
68340: LD_INT 0
68342: PPUSH
68343: PPUSH
68344: PPUSH
68345: PPUSH
68346: PPUSH
68347: PPUSH
68348: PPUSH
68349: PPUSH
68350: PPUSH
68351: PPUSH
// if not mc_bases then
68352: LD_EXP 58
68356: NOT
68357: IFFALSE 68361
// exit ;
68359: GO 70092
// for i = 1 to mc_bases do
68361: LD_ADDR_VAR 0 2
68365: PUSH
68366: DOUBLE
68367: LD_INT 1
68369: DEC
68370: ST_TO_ADDR
68371: LD_EXP 58
68375: PUSH
68376: FOR_TO
68377: IFFALSE 70090
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68379: LD_EXP 58
68383: PUSH
68384: LD_VAR 0 2
68388: ARRAY
68389: NOT
68390: PUSH
68391: LD_EXP 65
68395: PUSH
68396: LD_VAR 0 2
68400: ARRAY
68401: OR
68402: IFFALSE 68406
// continue ;
68404: GO 68376
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68406: LD_EXP 74
68410: PUSH
68411: LD_VAR 0 2
68415: ARRAY
68416: NOT
68417: PUSH
68418: LD_EXP 75
68422: PUSH
68423: LD_VAR 0 2
68427: ARRAY
68428: AND
68429: IFFALSE 68467
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68431: LD_ADDR_EXP 75
68435: PUSH
68436: LD_EXP 75
68440: PPUSH
68441: LD_VAR 0 2
68445: PPUSH
68446: EMPTY
68447: PPUSH
68448: CALL_OW 1
68452: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68453: LD_VAR 0 2
68457: PPUSH
68458: LD_INT 107
68460: PPUSH
68461: CALL 59556 0 2
// continue ;
68465: GO 68376
// end ; target := [ ] ;
68467: LD_ADDR_VAR 0 6
68471: PUSH
68472: EMPTY
68473: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68474: LD_ADDR_VAR 0 3
68478: PUSH
68479: DOUBLE
68480: LD_EXP 74
68484: PUSH
68485: LD_VAR 0 2
68489: ARRAY
68490: INC
68491: ST_TO_ADDR
68492: LD_INT 1
68494: PUSH
68495: FOR_DOWNTO
68496: IFFALSE 68756
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68498: LD_EXP 74
68502: PUSH
68503: LD_VAR 0 2
68507: ARRAY
68508: PUSH
68509: LD_VAR 0 3
68513: ARRAY
68514: PUSH
68515: LD_INT 2
68517: ARRAY
68518: PPUSH
68519: LD_EXP 74
68523: PUSH
68524: LD_VAR 0 2
68528: ARRAY
68529: PUSH
68530: LD_VAR 0 3
68534: ARRAY
68535: PUSH
68536: LD_INT 3
68538: ARRAY
68539: PPUSH
68540: CALL_OW 488
68544: PUSH
68545: LD_EXP 74
68549: PUSH
68550: LD_VAR 0 2
68554: ARRAY
68555: PUSH
68556: LD_VAR 0 3
68560: ARRAY
68561: PUSH
68562: LD_INT 2
68564: ARRAY
68565: PPUSH
68566: LD_EXP 74
68570: PUSH
68571: LD_VAR 0 2
68575: ARRAY
68576: PUSH
68577: LD_VAR 0 3
68581: ARRAY
68582: PUSH
68583: LD_INT 3
68585: ARRAY
68586: PPUSH
68587: CALL_OW 284
68591: PUSH
68592: LD_INT 0
68594: EQUAL
68595: AND
68596: IFFALSE 68651
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68598: LD_ADDR_VAR 0 5
68602: PUSH
68603: LD_EXP 74
68607: PUSH
68608: LD_VAR 0 2
68612: ARRAY
68613: PPUSH
68614: LD_VAR 0 3
68618: PPUSH
68619: CALL_OW 3
68623: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68624: LD_ADDR_EXP 74
68628: PUSH
68629: LD_EXP 74
68633: PPUSH
68634: LD_VAR 0 2
68638: PPUSH
68639: LD_VAR 0 5
68643: PPUSH
68644: CALL_OW 1
68648: ST_TO_ADDR
// continue ;
68649: GO 68495
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68651: LD_EXP 58
68655: PUSH
68656: LD_VAR 0 2
68660: ARRAY
68661: PUSH
68662: LD_INT 1
68664: ARRAY
68665: PPUSH
68666: CALL_OW 255
68670: PPUSH
68671: LD_EXP 74
68675: PUSH
68676: LD_VAR 0 2
68680: ARRAY
68681: PUSH
68682: LD_VAR 0 3
68686: ARRAY
68687: PUSH
68688: LD_INT 2
68690: ARRAY
68691: PPUSH
68692: LD_EXP 74
68696: PUSH
68697: LD_VAR 0 2
68701: ARRAY
68702: PUSH
68703: LD_VAR 0 3
68707: ARRAY
68708: PUSH
68709: LD_INT 3
68711: ARRAY
68712: PPUSH
68713: LD_INT 30
68715: PPUSH
68716: CALL 21561 0 4
68720: PUSH
68721: LD_INT 4
68723: ARRAY
68724: PUSH
68725: LD_INT 0
68727: EQUAL
68728: IFFALSE 68754
// begin target := mc_crates [ i ] [ j ] ;
68730: LD_ADDR_VAR 0 6
68734: PUSH
68735: LD_EXP 74
68739: PUSH
68740: LD_VAR 0 2
68744: ARRAY
68745: PUSH
68746: LD_VAR 0 3
68750: ARRAY
68751: ST_TO_ADDR
// break ;
68752: GO 68756
// end ; end ;
68754: GO 68495
68756: POP
68757: POP
// if not target then
68758: LD_VAR 0 6
68762: NOT
68763: IFFALSE 68767
// continue ;
68765: GO 68376
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68767: LD_ADDR_VAR 0 7
68771: PUSH
68772: LD_EXP 77
68776: PUSH
68777: LD_VAR 0 2
68781: ARRAY
68782: PPUSH
68783: LD_INT 2
68785: PUSH
68786: LD_INT 3
68788: PUSH
68789: LD_INT 58
68791: PUSH
68792: EMPTY
68793: LIST
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 61
68801: PUSH
68802: EMPTY
68803: LIST
68804: PUSH
68805: LD_INT 33
68807: PUSH
68808: LD_INT 5
68810: PUSH
68811: EMPTY
68812: LIST
68813: LIST
68814: PUSH
68815: LD_INT 33
68817: PUSH
68818: LD_INT 3
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: PUSH
68832: LD_INT 2
68834: PUSH
68835: LD_INT 34
68837: PUSH
68838: LD_INT 32
68840: PUSH
68841: EMPTY
68842: LIST
68843: LIST
68844: PUSH
68845: LD_INT 34
68847: PUSH
68848: LD_INT 51
68850: PUSH
68851: EMPTY
68852: LIST
68853: LIST
68854: PUSH
68855: LD_INT 34
68857: PUSH
68858: LD_INT 12
68860: PUSH
68861: EMPTY
68862: LIST
68863: LIST
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PPUSH
68875: CALL_OW 72
68879: ST_TO_ADDR
// if not cargo then
68880: LD_VAR 0 7
68884: NOT
68885: IFFALSE 69528
// begin if mc_crates_collector [ i ] < 5 then
68887: LD_EXP 75
68891: PUSH
68892: LD_VAR 0 2
68896: ARRAY
68897: PUSH
68898: LD_INT 5
68900: LESS
68901: IFFALSE 69267
// begin if mc_ape [ i ] then
68903: LD_EXP 87
68907: PUSH
68908: LD_VAR 0 2
68912: ARRAY
68913: IFFALSE 68960
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68915: LD_ADDR_VAR 0 5
68919: PUSH
68920: LD_EXP 87
68924: PUSH
68925: LD_VAR 0 2
68929: ARRAY
68930: PPUSH
68931: LD_INT 25
68933: PUSH
68934: LD_INT 16
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 24
68943: PUSH
68944: LD_INT 750
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PPUSH
68955: CALL_OW 72
68959: ST_TO_ADDR
// if not tmp then
68960: LD_VAR 0 5
68964: NOT
68965: IFFALSE 69012
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68967: LD_ADDR_VAR 0 5
68971: PUSH
68972: LD_EXP 58
68976: PUSH
68977: LD_VAR 0 2
68981: ARRAY
68982: PPUSH
68983: LD_INT 25
68985: PUSH
68986: LD_INT 2
68988: PUSH
68989: EMPTY
68990: LIST
68991: LIST
68992: PUSH
68993: LD_INT 24
68995: PUSH
68996: LD_INT 750
68998: PUSH
68999: EMPTY
69000: LIST
69001: LIST
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PPUSH
69007: CALL_OW 72
69011: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
69012: LD_EXP 87
69016: PUSH
69017: LD_VAR 0 2
69021: ARRAY
69022: PUSH
69023: LD_EXP 58
69027: PUSH
69028: LD_VAR 0 2
69032: ARRAY
69033: PPUSH
69034: LD_INT 25
69036: PUSH
69037: LD_INT 2
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 24
69046: PUSH
69047: LD_INT 750
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: PPUSH
69058: CALL_OW 72
69062: AND
69063: PUSH
69064: LD_VAR 0 5
69068: PUSH
69069: LD_INT 5
69071: LESS
69072: AND
69073: IFFALSE 69155
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
69075: LD_ADDR_VAR 0 3
69079: PUSH
69080: LD_EXP 58
69084: PUSH
69085: LD_VAR 0 2
69089: ARRAY
69090: PPUSH
69091: LD_INT 25
69093: PUSH
69094: LD_INT 2
69096: PUSH
69097: EMPTY
69098: LIST
69099: LIST
69100: PUSH
69101: LD_INT 24
69103: PUSH
69104: LD_INT 750
69106: PUSH
69107: EMPTY
69108: LIST
69109: LIST
69110: PUSH
69111: EMPTY
69112: LIST
69113: LIST
69114: PPUSH
69115: CALL_OW 72
69119: PUSH
69120: FOR_IN
69121: IFFALSE 69153
// begin tmp := tmp union j ;
69123: LD_ADDR_VAR 0 5
69127: PUSH
69128: LD_VAR 0 5
69132: PUSH
69133: LD_VAR 0 3
69137: UNION
69138: ST_TO_ADDR
// if tmp >= 5 then
69139: LD_VAR 0 5
69143: PUSH
69144: LD_INT 5
69146: GREATEREQUAL
69147: IFFALSE 69151
// break ;
69149: GO 69153
// end ;
69151: GO 69120
69153: POP
69154: POP
// end ; if not tmp then
69155: LD_VAR 0 5
69159: NOT
69160: IFFALSE 69164
// continue ;
69162: GO 68376
// for j in tmp do
69164: LD_ADDR_VAR 0 3
69168: PUSH
69169: LD_VAR 0 5
69173: PUSH
69174: FOR_IN
69175: IFFALSE 69265
// if not GetTag ( j ) then
69177: LD_VAR 0 3
69181: PPUSH
69182: CALL_OW 110
69186: NOT
69187: IFFALSE 69263
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69189: LD_ADDR_EXP 75
69193: PUSH
69194: LD_EXP 75
69198: PPUSH
69199: LD_VAR 0 2
69203: PUSH
69204: LD_EXP 75
69208: PUSH
69209: LD_VAR 0 2
69213: ARRAY
69214: PUSH
69215: LD_INT 1
69217: PLUS
69218: PUSH
69219: EMPTY
69220: LIST
69221: LIST
69222: PPUSH
69223: LD_VAR 0 3
69227: PPUSH
69228: CALL 20665 0 3
69232: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69233: LD_VAR 0 3
69237: PPUSH
69238: LD_INT 107
69240: PPUSH
69241: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69245: LD_EXP 75
69249: PUSH
69250: LD_VAR 0 2
69254: ARRAY
69255: PUSH
69256: LD_INT 5
69258: GREATEREQUAL
69259: IFFALSE 69263
// break ;
69261: GO 69265
// end ;
69263: GO 69174
69265: POP
69266: POP
// end ; if mc_crates_collector [ i ] and target then
69267: LD_EXP 75
69271: PUSH
69272: LD_VAR 0 2
69276: ARRAY
69277: PUSH
69278: LD_VAR 0 6
69282: AND
69283: IFFALSE 69526
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69285: LD_EXP 75
69289: PUSH
69290: LD_VAR 0 2
69294: ARRAY
69295: PUSH
69296: LD_VAR 0 6
69300: PUSH
69301: LD_INT 1
69303: ARRAY
69304: LESS
69305: IFFALSE 69325
// tmp := mc_crates_collector [ i ] else
69307: LD_ADDR_VAR 0 5
69311: PUSH
69312: LD_EXP 75
69316: PUSH
69317: LD_VAR 0 2
69321: ARRAY
69322: ST_TO_ADDR
69323: GO 69339
// tmp := target [ 1 ] ;
69325: LD_ADDR_VAR 0 5
69329: PUSH
69330: LD_VAR 0 6
69334: PUSH
69335: LD_INT 1
69337: ARRAY
69338: ST_TO_ADDR
// k := 0 ;
69339: LD_ADDR_VAR 0 4
69343: PUSH
69344: LD_INT 0
69346: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69347: LD_ADDR_VAR 0 3
69351: PUSH
69352: LD_EXP 75
69356: PUSH
69357: LD_VAR 0 2
69361: ARRAY
69362: PUSH
69363: FOR_IN
69364: IFFALSE 69524
// begin k := k + 1 ;
69366: LD_ADDR_VAR 0 4
69370: PUSH
69371: LD_VAR 0 4
69375: PUSH
69376: LD_INT 1
69378: PLUS
69379: ST_TO_ADDR
// if k > tmp then
69380: LD_VAR 0 4
69384: PUSH
69385: LD_VAR 0 5
69389: GREATER
69390: IFFALSE 69394
// break ;
69392: GO 69524
// if not GetClass ( j ) in [ 2 , 16 ] then
69394: LD_VAR 0 3
69398: PPUSH
69399: CALL_OW 257
69403: PUSH
69404: LD_INT 2
69406: PUSH
69407: LD_INT 16
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: IN
69414: NOT
69415: IFFALSE 69468
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69417: LD_ADDR_EXP 75
69421: PUSH
69422: LD_EXP 75
69426: PPUSH
69427: LD_VAR 0 2
69431: PPUSH
69432: LD_EXP 75
69436: PUSH
69437: LD_VAR 0 2
69441: ARRAY
69442: PUSH
69443: LD_VAR 0 3
69447: DIFF
69448: PPUSH
69449: CALL_OW 1
69453: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69454: LD_VAR 0 3
69458: PPUSH
69459: LD_INT 0
69461: PPUSH
69462: CALL_OW 109
// continue ;
69466: GO 69363
// end ; if IsInUnit ( j ) then
69468: LD_VAR 0 3
69472: PPUSH
69473: CALL_OW 310
69477: IFFALSE 69488
// ComExitBuilding ( j ) ;
69479: LD_VAR 0 3
69483: PPUSH
69484: CALL_OW 122
// wait ( 3 ) ;
69488: LD_INT 3
69490: PPUSH
69491: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69495: LD_VAR 0 3
69499: PPUSH
69500: LD_VAR 0 6
69504: PUSH
69505: LD_INT 2
69507: ARRAY
69508: PPUSH
69509: LD_VAR 0 6
69513: PUSH
69514: LD_INT 3
69516: ARRAY
69517: PPUSH
69518: CALL_OW 117
// end ;
69522: GO 69363
69524: POP
69525: POP
// end ; end else
69526: GO 70088
// begin for j in cargo do
69528: LD_ADDR_VAR 0 3
69532: PUSH
69533: LD_VAR 0 7
69537: PUSH
69538: FOR_IN
69539: IFFALSE 70086
// begin if GetTag ( j ) <> 0 then
69541: LD_VAR 0 3
69545: PPUSH
69546: CALL_OW 110
69550: PUSH
69551: LD_INT 0
69553: NONEQUAL
69554: IFFALSE 69558
// continue ;
69556: GO 69538
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69558: LD_VAR 0 3
69562: PPUSH
69563: CALL_OW 256
69567: PUSH
69568: LD_INT 1000
69570: LESS
69571: PUSH
69572: LD_VAR 0 3
69576: PPUSH
69577: LD_EXP 82
69581: PUSH
69582: LD_VAR 0 2
69586: ARRAY
69587: PPUSH
69588: CALL_OW 308
69592: NOT
69593: AND
69594: IFFALSE 69616
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69596: LD_VAR 0 3
69600: PPUSH
69601: LD_EXP 82
69605: PUSH
69606: LD_VAR 0 2
69610: ARRAY
69611: PPUSH
69612: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69616: LD_VAR 0 3
69620: PPUSH
69621: CALL_OW 256
69625: PUSH
69626: LD_INT 1000
69628: LESS
69629: PUSH
69630: LD_VAR 0 3
69634: PPUSH
69635: LD_EXP 82
69639: PUSH
69640: LD_VAR 0 2
69644: ARRAY
69645: PPUSH
69646: CALL_OW 308
69650: AND
69651: IFFALSE 69655
// continue ;
69653: GO 69538
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69655: LD_VAR 0 3
69659: PPUSH
69660: CALL_OW 262
69664: PUSH
69665: LD_INT 2
69667: EQUAL
69668: PUSH
69669: LD_VAR 0 3
69673: PPUSH
69674: CALL_OW 261
69678: PUSH
69679: LD_INT 15
69681: LESS
69682: AND
69683: IFFALSE 69687
// continue ;
69685: GO 69538
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69687: LD_VAR 0 3
69691: PPUSH
69692: CALL_OW 262
69696: PUSH
69697: LD_INT 1
69699: EQUAL
69700: PUSH
69701: LD_VAR 0 3
69705: PPUSH
69706: CALL_OW 261
69710: PUSH
69711: LD_INT 10
69713: LESS
69714: AND
69715: IFFALSE 70025
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69717: LD_ADDR_VAR 0 8
69721: PUSH
69722: LD_EXP 58
69726: PUSH
69727: LD_VAR 0 2
69731: ARRAY
69732: PPUSH
69733: LD_INT 2
69735: PUSH
69736: LD_INT 30
69738: PUSH
69739: LD_INT 0
69741: PUSH
69742: EMPTY
69743: LIST
69744: LIST
69745: PUSH
69746: LD_INT 30
69748: PUSH
69749: LD_INT 1
69751: PUSH
69752: EMPTY
69753: LIST
69754: LIST
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: LIST
69760: PPUSH
69761: CALL_OW 72
69765: ST_TO_ADDR
// if not depot then
69766: LD_VAR 0 8
69770: NOT
69771: IFFALSE 69775
// continue ;
69773: GO 69538
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69775: LD_VAR 0 3
69779: PPUSH
69780: LD_VAR 0 8
69784: PPUSH
69785: LD_VAR 0 3
69789: PPUSH
69790: CALL_OW 74
69794: PPUSH
69795: CALL_OW 296
69799: PUSH
69800: LD_INT 6
69802: LESS
69803: IFFALSE 69819
// SetFuel ( j , 100 ) else
69805: LD_VAR 0 3
69809: PPUSH
69810: LD_INT 100
69812: PPUSH
69813: CALL_OW 240
69817: GO 70025
// if GetFuel ( j ) = 0 then
69819: LD_VAR 0 3
69823: PPUSH
69824: CALL_OW 261
69828: PUSH
69829: LD_INT 0
69831: EQUAL
69832: IFFALSE 70025
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69834: LD_ADDR_EXP 77
69838: PUSH
69839: LD_EXP 77
69843: PPUSH
69844: LD_VAR 0 2
69848: PPUSH
69849: LD_EXP 77
69853: PUSH
69854: LD_VAR 0 2
69858: ARRAY
69859: PUSH
69860: LD_VAR 0 3
69864: DIFF
69865: PPUSH
69866: CALL_OW 1
69870: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69871: LD_VAR 0 3
69875: PPUSH
69876: CALL_OW 263
69880: PUSH
69881: LD_INT 1
69883: EQUAL
69884: IFFALSE 69900
// ComExitVehicle ( IsInUnit ( j ) ) ;
69886: LD_VAR 0 3
69890: PPUSH
69891: CALL_OW 310
69895: PPUSH
69896: CALL_OW 121
// if GetControl ( j ) = control_remote then
69900: LD_VAR 0 3
69904: PPUSH
69905: CALL_OW 263
69909: PUSH
69910: LD_INT 2
69912: EQUAL
69913: IFFALSE 69924
// ComUnlink ( j ) ;
69915: LD_VAR 0 3
69919: PPUSH
69920: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
69924: LD_ADDR_VAR 0 9
69928: PUSH
69929: LD_VAR 0 2
69933: PPUSH
69934: LD_INT 3
69936: PPUSH
69937: CALL 79129 0 2
69941: ST_TO_ADDR
// if fac then
69942: LD_VAR 0 9
69946: IFFALSE 70023
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69948: LD_ADDR_VAR 0 10
69952: PUSH
69953: LD_VAR 0 9
69957: PPUSH
69958: LD_VAR 0 3
69962: PPUSH
69963: CALL_OW 265
69967: PPUSH
69968: LD_VAR 0 3
69972: PPUSH
69973: CALL_OW 262
69977: PPUSH
69978: LD_VAR 0 3
69982: PPUSH
69983: CALL_OW 263
69987: PPUSH
69988: LD_VAR 0 3
69992: PPUSH
69993: CALL_OW 264
69997: PPUSH
69998: CALL 18265 0 5
70002: ST_TO_ADDR
// if components then
70003: LD_VAR 0 10
70007: IFFALSE 70023
// MC_InsertProduceList ( i , components ) ;
70009: LD_VAR 0 2
70013: PPUSH
70014: LD_VAR 0 10
70018: PPUSH
70019: CALL 78757 0 2
// end ; continue ;
70023: GO 69538
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
70025: LD_VAR 0 3
70029: PPUSH
70030: LD_INT 1
70032: PPUSH
70033: CALL_OW 289
70037: PUSH
70038: LD_INT 100
70040: LESS
70041: PUSH
70042: LD_VAR 0 3
70046: PPUSH
70047: CALL_OW 314
70051: NOT
70052: AND
70053: IFFALSE 70082
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70055: LD_VAR 0 3
70059: PPUSH
70060: LD_VAR 0 6
70064: PUSH
70065: LD_INT 2
70067: ARRAY
70068: PPUSH
70069: LD_VAR 0 6
70073: PUSH
70074: LD_INT 3
70076: ARRAY
70077: PPUSH
70078: CALL_OW 117
// break ;
70082: GO 70086
// end ;
70084: GO 69538
70086: POP
70087: POP
// end ; end ;
70088: GO 68376
70090: POP
70091: POP
// end ;
70092: LD_VAR 0 1
70096: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70097: LD_INT 0
70099: PPUSH
70100: PPUSH
70101: PPUSH
70102: PPUSH
// if not mc_bases then
70103: LD_EXP 58
70107: NOT
70108: IFFALSE 70112
// exit ;
70110: GO 70273
// for i = 1 to mc_bases do
70112: LD_ADDR_VAR 0 2
70116: PUSH
70117: DOUBLE
70118: LD_INT 1
70120: DEC
70121: ST_TO_ADDR
70122: LD_EXP 58
70126: PUSH
70127: FOR_TO
70128: IFFALSE 70271
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70130: LD_ADDR_VAR 0 4
70134: PUSH
70135: LD_EXP 77
70139: PUSH
70140: LD_VAR 0 2
70144: ARRAY
70145: PUSH
70146: LD_EXP 80
70150: PUSH
70151: LD_VAR 0 2
70155: ARRAY
70156: UNION
70157: PPUSH
70158: LD_INT 33
70160: PUSH
70161: LD_INT 2
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PPUSH
70168: CALL_OW 72
70172: ST_TO_ADDR
// if tmp then
70173: LD_VAR 0 4
70177: IFFALSE 70269
// for j in tmp do
70179: LD_ADDR_VAR 0 3
70183: PUSH
70184: LD_VAR 0 4
70188: PUSH
70189: FOR_IN
70190: IFFALSE 70267
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70192: LD_VAR 0 3
70196: PPUSH
70197: CALL_OW 312
70201: NOT
70202: PUSH
70203: LD_VAR 0 3
70207: PPUSH
70208: CALL_OW 256
70212: PUSH
70213: LD_INT 250
70215: GREATEREQUAL
70216: AND
70217: IFFALSE 70230
// Connect ( j ) else
70219: LD_VAR 0 3
70223: PPUSH
70224: CALL 23598 0 1
70228: GO 70265
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70230: LD_VAR 0 3
70234: PPUSH
70235: CALL_OW 256
70239: PUSH
70240: LD_INT 250
70242: LESS
70243: PUSH
70244: LD_VAR 0 3
70248: PPUSH
70249: CALL_OW 312
70253: AND
70254: IFFALSE 70265
// ComUnlink ( j ) ;
70256: LD_VAR 0 3
70260: PPUSH
70261: CALL_OW 136
70265: GO 70189
70267: POP
70268: POP
// end ;
70269: GO 70127
70271: POP
70272: POP
// end ;
70273: LD_VAR 0 1
70277: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70278: LD_INT 0
70280: PPUSH
70281: PPUSH
70282: PPUSH
70283: PPUSH
70284: PPUSH
// if not mc_bases then
70285: LD_EXP 58
70289: NOT
70290: IFFALSE 70294
// exit ;
70292: GO 70754
// for i = 1 to mc_bases do
70294: LD_ADDR_VAR 0 2
70298: PUSH
70299: DOUBLE
70300: LD_INT 1
70302: DEC
70303: ST_TO_ADDR
70304: LD_EXP 58
70308: PUSH
70309: FOR_TO
70310: IFFALSE 70752
// begin if not mc_produce [ i ] then
70312: LD_EXP 79
70316: PUSH
70317: LD_VAR 0 2
70321: ARRAY
70322: NOT
70323: IFFALSE 70327
// continue ;
70325: GO 70309
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70327: LD_ADDR_VAR 0 5
70331: PUSH
70332: LD_EXP 58
70336: PUSH
70337: LD_VAR 0 2
70341: ARRAY
70342: PPUSH
70343: LD_INT 30
70345: PUSH
70346: LD_INT 3
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PPUSH
70353: CALL_OW 72
70357: ST_TO_ADDR
// if not fac then
70358: LD_VAR 0 5
70362: NOT
70363: IFFALSE 70367
// continue ;
70365: GO 70309
// for j in fac do
70367: LD_ADDR_VAR 0 3
70371: PUSH
70372: LD_VAR 0 5
70376: PUSH
70377: FOR_IN
70378: IFFALSE 70748
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
70380: LD_VAR 0 3
70384: PPUSH
70385: CALL_OW 461
70389: PUSH
70390: LD_INT 2
70392: NONEQUAL
70393: PUSH
70394: LD_VAR 0 3
70398: PPUSH
70399: LD_INT 15
70401: PPUSH
70402: CALL 23258 0 2
70406: PUSH
70407: LD_INT 4
70409: ARRAY
70410: OR
70411: PUSH
70412: LD_VAR 0 3
70416: PPUSH
70417: CALL_OW 313
70421: PUSH
70422: LD_INT 0
70424: EQUAL
70425: OR
70426: IFFALSE 70430
// continue ;
70428: GO 70377
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70430: LD_VAR 0 3
70434: PPUSH
70435: LD_EXP 79
70439: PUSH
70440: LD_VAR 0 2
70444: ARRAY
70445: PUSH
70446: LD_INT 1
70448: ARRAY
70449: PUSH
70450: LD_INT 1
70452: ARRAY
70453: PPUSH
70454: LD_EXP 79
70458: PUSH
70459: LD_VAR 0 2
70463: ARRAY
70464: PUSH
70465: LD_INT 1
70467: ARRAY
70468: PUSH
70469: LD_INT 2
70471: ARRAY
70472: PPUSH
70473: LD_EXP 79
70477: PUSH
70478: LD_VAR 0 2
70482: ARRAY
70483: PUSH
70484: LD_INT 1
70486: ARRAY
70487: PUSH
70488: LD_INT 3
70490: ARRAY
70491: PPUSH
70492: LD_EXP 79
70496: PUSH
70497: LD_VAR 0 2
70501: ARRAY
70502: PUSH
70503: LD_INT 1
70505: ARRAY
70506: PUSH
70507: LD_INT 4
70509: ARRAY
70510: PPUSH
70511: CALL_OW 448
70515: PUSH
70516: LD_VAR 0 3
70520: PPUSH
70521: LD_EXP 79
70525: PUSH
70526: LD_VAR 0 2
70530: ARRAY
70531: PUSH
70532: LD_INT 1
70534: ARRAY
70535: PUSH
70536: LD_INT 1
70538: ARRAY
70539: PUSH
70540: LD_EXP 79
70544: PUSH
70545: LD_VAR 0 2
70549: ARRAY
70550: PUSH
70551: LD_INT 1
70553: ARRAY
70554: PUSH
70555: LD_INT 2
70557: ARRAY
70558: PUSH
70559: LD_EXP 79
70563: PUSH
70564: LD_VAR 0 2
70568: ARRAY
70569: PUSH
70570: LD_INT 1
70572: ARRAY
70573: PUSH
70574: LD_INT 3
70576: ARRAY
70577: PUSH
70578: LD_EXP 79
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: PUSH
70589: LD_INT 1
70591: ARRAY
70592: PUSH
70593: LD_INT 4
70595: ARRAY
70596: PUSH
70597: EMPTY
70598: LIST
70599: LIST
70600: LIST
70601: LIST
70602: PPUSH
70603: CALL 26929 0 2
70607: AND
70608: IFFALSE 70746
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70610: LD_VAR 0 3
70614: PPUSH
70615: LD_EXP 79
70619: PUSH
70620: LD_VAR 0 2
70624: ARRAY
70625: PUSH
70626: LD_INT 1
70628: ARRAY
70629: PUSH
70630: LD_INT 1
70632: ARRAY
70633: PPUSH
70634: LD_EXP 79
70638: PUSH
70639: LD_VAR 0 2
70643: ARRAY
70644: PUSH
70645: LD_INT 1
70647: ARRAY
70648: PUSH
70649: LD_INT 2
70651: ARRAY
70652: PPUSH
70653: LD_EXP 79
70657: PUSH
70658: LD_VAR 0 2
70662: ARRAY
70663: PUSH
70664: LD_INT 1
70666: ARRAY
70667: PUSH
70668: LD_INT 3
70670: ARRAY
70671: PPUSH
70672: LD_EXP 79
70676: PUSH
70677: LD_VAR 0 2
70681: ARRAY
70682: PUSH
70683: LD_INT 1
70685: ARRAY
70686: PUSH
70687: LD_INT 4
70689: ARRAY
70690: PPUSH
70691: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70695: LD_ADDR_VAR 0 4
70699: PUSH
70700: LD_EXP 79
70704: PUSH
70705: LD_VAR 0 2
70709: ARRAY
70710: PPUSH
70711: LD_INT 1
70713: PPUSH
70714: CALL_OW 3
70718: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70719: LD_ADDR_EXP 79
70723: PUSH
70724: LD_EXP 79
70728: PPUSH
70729: LD_VAR 0 2
70733: PPUSH
70734: LD_VAR 0 4
70738: PPUSH
70739: CALL_OW 1
70743: ST_TO_ADDR
// break ;
70744: GO 70748
// end ; end ;
70746: GO 70377
70748: POP
70749: POP
// end ;
70750: GO 70309
70752: POP
70753: POP
// end ;
70754: LD_VAR 0 1
70758: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70759: LD_INT 0
70761: PPUSH
70762: PPUSH
70763: PPUSH
// if not mc_bases then
70764: LD_EXP 58
70768: NOT
70769: IFFALSE 70773
// exit ;
70771: GO 70862
// for i = 1 to mc_bases do
70773: LD_ADDR_VAR 0 2
70777: PUSH
70778: DOUBLE
70779: LD_INT 1
70781: DEC
70782: ST_TO_ADDR
70783: LD_EXP 58
70787: PUSH
70788: FOR_TO
70789: IFFALSE 70860
// begin if mc_attack [ i ] then
70791: LD_EXP 78
70795: PUSH
70796: LD_VAR 0 2
70800: ARRAY
70801: IFFALSE 70858
// begin tmp := mc_attack [ i ] [ 1 ] ;
70803: LD_ADDR_VAR 0 3
70807: PUSH
70808: LD_EXP 78
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PUSH
70819: LD_INT 1
70821: ARRAY
70822: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70823: LD_ADDR_EXP 78
70827: PUSH
70828: LD_EXP 78
70832: PPUSH
70833: LD_VAR 0 2
70837: PPUSH
70838: EMPTY
70839: PPUSH
70840: CALL_OW 1
70844: ST_TO_ADDR
// Attack ( tmp ) ;
70845: LD_VAR 0 3
70849: PPUSH
70850: CALL 49118 0 1
// exit ;
70854: POP
70855: POP
70856: GO 70862
// end ; end ;
70858: GO 70788
70860: POP
70861: POP
// end ;
70862: LD_VAR 0 1
70866: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70867: LD_INT 0
70869: PPUSH
70870: PPUSH
70871: PPUSH
70872: PPUSH
70873: PPUSH
70874: PPUSH
70875: PPUSH
// if not mc_bases then
70876: LD_EXP 58
70880: NOT
70881: IFFALSE 70885
// exit ;
70883: GO 71489
// for i = 1 to mc_bases do
70885: LD_ADDR_VAR 0 2
70889: PUSH
70890: DOUBLE
70891: LD_INT 1
70893: DEC
70894: ST_TO_ADDR
70895: LD_EXP 58
70899: PUSH
70900: FOR_TO
70901: IFFALSE 71487
// begin if not mc_bases [ i ] then
70903: LD_EXP 58
70907: PUSH
70908: LD_VAR 0 2
70912: ARRAY
70913: NOT
70914: IFFALSE 70918
// continue ;
70916: GO 70900
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70918: LD_ADDR_VAR 0 7
70922: PUSH
70923: LD_EXP 58
70927: PUSH
70928: LD_VAR 0 2
70932: ARRAY
70933: PUSH
70934: LD_INT 1
70936: ARRAY
70937: PPUSH
70938: CALL 17569 0 1
70942: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70943: LD_ADDR_EXP 81
70947: PUSH
70948: LD_EXP 81
70952: PPUSH
70953: LD_VAR 0 2
70957: PPUSH
70958: LD_EXP 58
70962: PUSH
70963: LD_VAR 0 2
70967: ARRAY
70968: PUSH
70969: LD_INT 1
70971: ARRAY
70972: PPUSH
70973: CALL_OW 255
70977: PPUSH
70978: LD_EXP 83
70982: PUSH
70983: LD_VAR 0 2
70987: ARRAY
70988: PPUSH
70989: CALL 15529 0 2
70993: PPUSH
70994: CALL_OW 1
70998: ST_TO_ADDR
// if not mc_scan [ i ] then
70999: LD_EXP 81
71003: PUSH
71004: LD_VAR 0 2
71008: ARRAY
71009: NOT
71010: IFFALSE 71165
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71012: LD_ADDR_VAR 0 4
71016: PUSH
71017: LD_EXP 58
71021: PUSH
71022: LD_VAR 0 2
71026: ARRAY
71027: PPUSH
71028: LD_INT 2
71030: PUSH
71031: LD_INT 25
71033: PUSH
71034: LD_INT 5
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: PUSH
71041: LD_INT 25
71043: PUSH
71044: LD_INT 8
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 25
71053: PUSH
71054: LD_INT 9
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: LIST
71065: LIST
71066: PPUSH
71067: CALL_OW 72
71071: ST_TO_ADDR
// if not tmp then
71072: LD_VAR 0 4
71076: NOT
71077: IFFALSE 71081
// continue ;
71079: GO 70900
// for j in tmp do
71081: LD_ADDR_VAR 0 3
71085: PUSH
71086: LD_VAR 0 4
71090: PUSH
71091: FOR_IN
71092: IFFALSE 71163
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71094: LD_VAR 0 3
71098: PPUSH
71099: CALL_OW 310
71103: PPUSH
71104: CALL_OW 266
71108: PUSH
71109: LD_INT 5
71111: EQUAL
71112: PUSH
71113: LD_VAR 0 3
71117: PPUSH
71118: CALL_OW 257
71122: PUSH
71123: LD_INT 1
71125: EQUAL
71126: AND
71127: PUSH
71128: LD_VAR 0 3
71132: PPUSH
71133: CALL_OW 459
71137: NOT
71138: AND
71139: PUSH
71140: LD_VAR 0 7
71144: AND
71145: IFFALSE 71161
// ComChangeProfession ( j , class ) ;
71147: LD_VAR 0 3
71151: PPUSH
71152: LD_VAR 0 7
71156: PPUSH
71157: CALL_OW 123
71161: GO 71091
71163: POP
71164: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71165: LD_EXP 81
71169: PUSH
71170: LD_VAR 0 2
71174: ARRAY
71175: PUSH
71176: LD_EXP 80
71180: PUSH
71181: LD_VAR 0 2
71185: ARRAY
71186: NOT
71187: AND
71188: PUSH
71189: LD_EXP 58
71193: PUSH
71194: LD_VAR 0 2
71198: ARRAY
71199: PPUSH
71200: LD_INT 30
71202: PUSH
71203: LD_INT 32
71205: PUSH
71206: EMPTY
71207: LIST
71208: LIST
71209: PPUSH
71210: CALL_OW 72
71214: NOT
71215: AND
71216: PUSH
71217: LD_EXP 58
71221: PUSH
71222: LD_VAR 0 2
71226: ARRAY
71227: PPUSH
71228: LD_INT 2
71230: PUSH
71231: LD_INT 30
71233: PUSH
71234: LD_INT 4
71236: PUSH
71237: EMPTY
71238: LIST
71239: LIST
71240: PUSH
71241: LD_INT 30
71243: PUSH
71244: LD_INT 5
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: EMPTY
71252: LIST
71253: LIST
71254: LIST
71255: PPUSH
71256: CALL_OW 72
71260: NOT
71261: AND
71262: IFFALSE 71394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71264: LD_ADDR_VAR 0 4
71268: PUSH
71269: LD_EXP 58
71273: PUSH
71274: LD_VAR 0 2
71278: ARRAY
71279: PPUSH
71280: LD_INT 2
71282: PUSH
71283: LD_INT 25
71285: PUSH
71286: LD_INT 1
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 25
71295: PUSH
71296: LD_INT 5
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 25
71305: PUSH
71306: LD_INT 8
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 25
71315: PUSH
71316: LD_INT 9
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: PPUSH
71330: CALL_OW 72
71334: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71335: LD_ADDR_VAR 0 4
71339: PUSH
71340: LD_VAR 0 4
71344: PUSH
71345: LD_VAR 0 4
71349: PPUSH
71350: LD_INT 18
71352: PPUSH
71353: CALL 53862 0 2
71357: DIFF
71358: ST_TO_ADDR
// if tmp then
71359: LD_VAR 0 4
71363: IFFALSE 71394
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
71365: LD_VAR 0 2
71369: PPUSH
71370: LD_VAR 0 4
71374: PPUSH
71375: LD_EXP 83
71379: PUSH
71380: LD_VAR 0 2
71384: ARRAY
71385: PPUSH
71386: CALL 15564 0 3
// exit ;
71390: POP
71391: POP
71392: GO 71489
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
71394: LD_EXP 81
71398: PUSH
71399: LD_VAR 0 2
71403: ARRAY
71404: PUSH
71405: LD_EXP 80
71409: PUSH
71410: LD_VAR 0 2
71414: ARRAY
71415: AND
71416: IFFALSE 71485
// begin tmp := mc_defender [ i ] ;
71418: LD_ADDR_VAR 0 4
71422: PUSH
71423: LD_EXP 80
71427: PUSH
71428: LD_VAR 0 2
71432: ARRAY
71433: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71434: LD_ADDR_EXP 80
71438: PUSH
71439: LD_EXP 80
71443: PPUSH
71444: LD_VAR 0 2
71448: PPUSH
71449: EMPTY
71450: PPUSH
71451: CALL_OW 1
71455: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
71456: LD_VAR 0 2
71460: PPUSH
71461: LD_VAR 0 4
71465: PPUSH
71466: LD_EXP 81
71470: PUSH
71471: LD_VAR 0 2
71475: ARRAY
71476: PPUSH
71477: CALL 16062 0 3
// exit ;
71481: POP
71482: POP
71483: GO 71489
// end ; end ;
71485: GO 70900
71487: POP
71488: POP
// end ;
71489: LD_VAR 0 1
71493: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71494: LD_INT 0
71496: PPUSH
71497: PPUSH
71498: PPUSH
71499: PPUSH
71500: PPUSH
71501: PPUSH
71502: PPUSH
71503: PPUSH
71504: PPUSH
71505: PPUSH
71506: PPUSH
// if not mc_bases then
71507: LD_EXP 58
71511: NOT
71512: IFFALSE 71516
// exit ;
71514: GO 72603
// for i = 1 to mc_bases do
71516: LD_ADDR_VAR 0 2
71520: PUSH
71521: DOUBLE
71522: LD_INT 1
71524: DEC
71525: ST_TO_ADDR
71526: LD_EXP 58
71530: PUSH
71531: FOR_TO
71532: IFFALSE 72601
// begin tmp := mc_lab [ i ] ;
71534: LD_ADDR_VAR 0 6
71538: PUSH
71539: LD_EXP 91
71543: PUSH
71544: LD_VAR 0 2
71548: ARRAY
71549: ST_TO_ADDR
// if not tmp then
71550: LD_VAR 0 6
71554: NOT
71555: IFFALSE 71559
// continue ;
71557: GO 71531
// idle_lab := 0 ;
71559: LD_ADDR_VAR 0 11
71563: PUSH
71564: LD_INT 0
71566: ST_TO_ADDR
// for j in tmp do
71567: LD_ADDR_VAR 0 3
71571: PUSH
71572: LD_VAR 0 6
71576: PUSH
71577: FOR_IN
71578: IFFALSE 72597
// begin researching := false ;
71580: LD_ADDR_VAR 0 10
71584: PUSH
71585: LD_INT 0
71587: ST_TO_ADDR
// side := GetSide ( j ) ;
71588: LD_ADDR_VAR 0 4
71592: PUSH
71593: LD_VAR 0 3
71597: PPUSH
71598: CALL_OW 255
71602: ST_TO_ADDR
// if not mc_tech [ side ] then
71603: LD_EXP 85
71607: PUSH
71608: LD_VAR 0 4
71612: ARRAY
71613: NOT
71614: IFFALSE 71618
// continue ;
71616: GO 71577
// if BuildingStatus ( j ) = bs_idle then
71618: LD_VAR 0 3
71622: PPUSH
71623: CALL_OW 461
71627: PUSH
71628: LD_INT 2
71630: EQUAL
71631: IFFALSE 71819
// begin if idle_lab and UnitsInside ( j ) < 6 then
71633: LD_VAR 0 11
71637: PUSH
71638: LD_VAR 0 3
71642: PPUSH
71643: CALL_OW 313
71647: PUSH
71648: LD_INT 6
71650: LESS
71651: AND
71652: IFFALSE 71723
// begin tmp2 := UnitsInside ( idle_lab ) ;
71654: LD_ADDR_VAR 0 9
71658: PUSH
71659: LD_VAR 0 11
71663: PPUSH
71664: CALL_OW 313
71668: ST_TO_ADDR
// if tmp2 then
71669: LD_VAR 0 9
71673: IFFALSE 71715
// for x in tmp2 do
71675: LD_ADDR_VAR 0 7
71679: PUSH
71680: LD_VAR 0 9
71684: PUSH
71685: FOR_IN
71686: IFFALSE 71713
// begin ComExitBuilding ( x ) ;
71688: LD_VAR 0 7
71692: PPUSH
71693: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71697: LD_VAR 0 7
71701: PPUSH
71702: LD_VAR 0 3
71706: PPUSH
71707: CALL_OW 180
// end ;
71711: GO 71685
71713: POP
71714: POP
// idle_lab := 0 ;
71715: LD_ADDR_VAR 0 11
71719: PUSH
71720: LD_INT 0
71722: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71723: LD_ADDR_VAR 0 5
71727: PUSH
71728: LD_EXP 85
71732: PUSH
71733: LD_VAR 0 4
71737: ARRAY
71738: PUSH
71739: FOR_IN
71740: IFFALSE 71800
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71742: LD_VAR 0 3
71746: PPUSH
71747: LD_VAR 0 5
71751: PPUSH
71752: CALL_OW 430
71756: PUSH
71757: LD_VAR 0 4
71761: PPUSH
71762: LD_VAR 0 5
71766: PPUSH
71767: CALL 14634 0 2
71771: AND
71772: IFFALSE 71798
// begin researching := true ;
71774: LD_ADDR_VAR 0 10
71778: PUSH
71779: LD_INT 1
71781: ST_TO_ADDR
// ComResearch ( j , t ) ;
71782: LD_VAR 0 3
71786: PPUSH
71787: LD_VAR 0 5
71791: PPUSH
71792: CALL_OW 124
// break ;
71796: GO 71800
// end ;
71798: GO 71739
71800: POP
71801: POP
// if not researching then
71802: LD_VAR 0 10
71806: NOT
71807: IFFALSE 71819
// idle_lab := j ;
71809: LD_ADDR_VAR 0 11
71813: PUSH
71814: LD_VAR 0 3
71818: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71819: LD_VAR 0 3
71823: PPUSH
71824: CALL_OW 461
71828: PUSH
71829: LD_INT 10
71831: EQUAL
71832: IFFALSE 72420
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71834: LD_EXP 87
71838: PUSH
71839: LD_VAR 0 2
71843: ARRAY
71844: NOT
71845: PUSH
71846: LD_EXP 88
71850: PUSH
71851: LD_VAR 0 2
71855: ARRAY
71856: NOT
71857: AND
71858: PUSH
71859: LD_EXP 85
71863: PUSH
71864: LD_VAR 0 4
71868: ARRAY
71869: PUSH
71870: LD_INT 1
71872: GREATER
71873: AND
71874: IFFALSE 72005
// begin ComCancel ( j ) ;
71876: LD_VAR 0 3
71880: PPUSH
71881: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71885: LD_ADDR_EXP 85
71889: PUSH
71890: LD_EXP 85
71894: PPUSH
71895: LD_VAR 0 4
71899: PPUSH
71900: LD_EXP 85
71904: PUSH
71905: LD_VAR 0 4
71909: ARRAY
71910: PPUSH
71911: LD_EXP 85
71915: PUSH
71916: LD_VAR 0 4
71920: ARRAY
71921: PUSH
71922: LD_INT 1
71924: MINUS
71925: PPUSH
71926: LD_EXP 85
71930: PUSH
71931: LD_VAR 0 4
71935: ARRAY
71936: PPUSH
71937: LD_INT 0
71939: PPUSH
71940: CALL 20083 0 4
71944: PPUSH
71945: CALL_OW 1
71949: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71950: LD_ADDR_EXP 85
71954: PUSH
71955: LD_EXP 85
71959: PPUSH
71960: LD_VAR 0 4
71964: PPUSH
71965: LD_EXP 85
71969: PUSH
71970: LD_VAR 0 4
71974: ARRAY
71975: PPUSH
71976: LD_EXP 85
71980: PUSH
71981: LD_VAR 0 4
71985: ARRAY
71986: PPUSH
71987: LD_INT 1
71989: PPUSH
71990: LD_INT 0
71992: PPUSH
71993: CALL 20083 0 4
71997: PPUSH
71998: CALL_OW 1
72002: ST_TO_ADDR
// continue ;
72003: GO 71577
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72005: LD_EXP 87
72009: PUSH
72010: LD_VAR 0 2
72014: ARRAY
72015: PUSH
72016: LD_EXP 88
72020: PUSH
72021: LD_VAR 0 2
72025: ARRAY
72026: NOT
72027: AND
72028: IFFALSE 72155
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72030: LD_ADDR_EXP 88
72034: PUSH
72035: LD_EXP 88
72039: PPUSH
72040: LD_VAR 0 2
72044: PUSH
72045: LD_EXP 88
72049: PUSH
72050: LD_VAR 0 2
72054: ARRAY
72055: PUSH
72056: LD_INT 1
72058: PLUS
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PPUSH
72064: LD_EXP 87
72068: PUSH
72069: LD_VAR 0 2
72073: ARRAY
72074: PUSH
72075: LD_INT 1
72077: ARRAY
72078: PPUSH
72079: CALL 20665 0 3
72083: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72084: LD_EXP 87
72088: PUSH
72089: LD_VAR 0 2
72093: ARRAY
72094: PUSH
72095: LD_INT 1
72097: ARRAY
72098: PPUSH
72099: LD_INT 112
72101: PPUSH
72102: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72106: LD_ADDR_VAR 0 9
72110: PUSH
72111: LD_EXP 87
72115: PUSH
72116: LD_VAR 0 2
72120: ARRAY
72121: PPUSH
72122: LD_INT 1
72124: PPUSH
72125: CALL_OW 3
72129: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72130: LD_ADDR_EXP 87
72134: PUSH
72135: LD_EXP 87
72139: PPUSH
72140: LD_VAR 0 2
72144: PPUSH
72145: LD_VAR 0 9
72149: PPUSH
72150: CALL_OW 1
72154: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72155: LD_EXP 87
72159: PUSH
72160: LD_VAR 0 2
72164: ARRAY
72165: PUSH
72166: LD_EXP 88
72170: PUSH
72171: LD_VAR 0 2
72175: ARRAY
72176: AND
72177: PUSH
72178: LD_EXP 88
72182: PUSH
72183: LD_VAR 0 2
72187: ARRAY
72188: PUSH
72189: LD_INT 1
72191: ARRAY
72192: PPUSH
72193: CALL_OW 310
72197: NOT
72198: AND
72199: PUSH
72200: LD_VAR 0 3
72204: PPUSH
72205: CALL_OW 313
72209: PUSH
72210: LD_INT 6
72212: EQUAL
72213: AND
72214: IFFALSE 72270
// begin tmp2 := UnitsInside ( j ) ;
72216: LD_ADDR_VAR 0 9
72220: PUSH
72221: LD_VAR 0 3
72225: PPUSH
72226: CALL_OW 313
72230: ST_TO_ADDR
// if tmp2 = 6 then
72231: LD_VAR 0 9
72235: PUSH
72236: LD_INT 6
72238: EQUAL
72239: IFFALSE 72270
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72241: LD_VAR 0 9
72245: PUSH
72246: LD_INT 1
72248: ARRAY
72249: PPUSH
72250: LD_INT 112
72252: PPUSH
72253: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72257: LD_VAR 0 9
72261: PUSH
72262: LD_INT 1
72264: ARRAY
72265: PPUSH
72266: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72270: LD_EXP 88
72274: PUSH
72275: LD_VAR 0 2
72279: ARRAY
72280: PUSH
72281: LD_EXP 88
72285: PUSH
72286: LD_VAR 0 2
72290: ARRAY
72291: PUSH
72292: LD_INT 1
72294: ARRAY
72295: PPUSH
72296: CALL_OW 314
72300: NOT
72301: AND
72302: PUSH
72303: LD_EXP 88
72307: PUSH
72308: LD_VAR 0 2
72312: ARRAY
72313: PUSH
72314: LD_INT 1
72316: ARRAY
72317: PPUSH
72318: CALL_OW 310
72322: NOT
72323: AND
72324: IFFALSE 72350
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72326: LD_EXP 88
72330: PUSH
72331: LD_VAR 0 2
72335: ARRAY
72336: PUSH
72337: LD_INT 1
72339: ARRAY
72340: PPUSH
72341: LD_VAR 0 3
72345: PPUSH
72346: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72350: LD_EXP 88
72354: PUSH
72355: LD_VAR 0 2
72359: ARRAY
72360: PUSH
72361: LD_INT 1
72363: ARRAY
72364: PPUSH
72365: CALL_OW 310
72369: PUSH
72370: LD_EXP 88
72374: PUSH
72375: LD_VAR 0 2
72379: ARRAY
72380: PUSH
72381: LD_INT 1
72383: ARRAY
72384: PPUSH
72385: CALL_OW 310
72389: PPUSH
72390: CALL_OW 461
72394: PUSH
72395: LD_INT 3
72397: NONEQUAL
72398: AND
72399: IFFALSE 72420
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72401: LD_EXP 88
72405: PUSH
72406: LD_VAR 0 2
72410: ARRAY
72411: PUSH
72412: LD_INT 1
72414: ARRAY
72415: PPUSH
72416: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72420: LD_VAR 0 3
72424: PPUSH
72425: CALL_OW 461
72429: PUSH
72430: LD_INT 6
72432: EQUAL
72433: PUSH
72434: LD_VAR 0 6
72438: PUSH
72439: LD_INT 1
72441: GREATER
72442: AND
72443: IFFALSE 72595
// begin sci := [ ] ;
72445: LD_ADDR_VAR 0 8
72449: PUSH
72450: EMPTY
72451: ST_TO_ADDR
// for x in ( tmp diff j ) do
72452: LD_ADDR_VAR 0 7
72456: PUSH
72457: LD_VAR 0 6
72461: PUSH
72462: LD_VAR 0 3
72466: DIFF
72467: PUSH
72468: FOR_IN
72469: IFFALSE 72521
// begin if sci = 6 then
72471: LD_VAR 0 8
72475: PUSH
72476: LD_INT 6
72478: EQUAL
72479: IFFALSE 72483
// break ;
72481: GO 72521
// if BuildingStatus ( x ) = bs_idle then
72483: LD_VAR 0 7
72487: PPUSH
72488: CALL_OW 461
72492: PUSH
72493: LD_INT 2
72495: EQUAL
72496: IFFALSE 72519
// sci := sci ^ UnitsInside ( x ) ;
72498: LD_ADDR_VAR 0 8
72502: PUSH
72503: LD_VAR 0 8
72507: PUSH
72508: LD_VAR 0 7
72512: PPUSH
72513: CALL_OW 313
72517: ADD
72518: ST_TO_ADDR
// end ;
72519: GO 72468
72521: POP
72522: POP
// if not sci then
72523: LD_VAR 0 8
72527: NOT
72528: IFFALSE 72532
// continue ;
72530: GO 71577
// for x in sci do
72532: LD_ADDR_VAR 0 7
72536: PUSH
72537: LD_VAR 0 8
72541: PUSH
72542: FOR_IN
72543: IFFALSE 72593
// if IsInUnit ( x ) and not HasTask ( x ) then
72545: LD_VAR 0 7
72549: PPUSH
72550: CALL_OW 310
72554: PUSH
72555: LD_VAR 0 7
72559: PPUSH
72560: CALL_OW 314
72564: NOT
72565: AND
72566: IFFALSE 72591
// begin ComExitBuilding ( x ) ;
72568: LD_VAR 0 7
72572: PPUSH
72573: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72577: LD_VAR 0 7
72581: PPUSH
72582: LD_VAR 0 3
72586: PPUSH
72587: CALL_OW 180
// end ;
72591: GO 72542
72593: POP
72594: POP
// end ; end ;
72595: GO 71577
72597: POP
72598: POP
// end ;
72599: GO 71531
72601: POP
72602: POP
// end ;
72603: LD_VAR 0 1
72607: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72608: LD_INT 0
72610: PPUSH
72611: PPUSH
// if not mc_bases then
72612: LD_EXP 58
72616: NOT
72617: IFFALSE 72621
// exit ;
72619: GO 72702
// for i = 1 to mc_bases do
72621: LD_ADDR_VAR 0 2
72625: PUSH
72626: DOUBLE
72627: LD_INT 1
72629: DEC
72630: ST_TO_ADDR
72631: LD_EXP 58
72635: PUSH
72636: FOR_TO
72637: IFFALSE 72700
// if mc_mines [ i ] and mc_miners [ i ] then
72639: LD_EXP 71
72643: PUSH
72644: LD_VAR 0 2
72648: ARRAY
72649: PUSH
72650: LD_EXP 72
72654: PUSH
72655: LD_VAR 0 2
72659: ARRAY
72660: AND
72661: IFFALSE 72698
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72663: LD_EXP 72
72667: PUSH
72668: LD_VAR 0 2
72672: ARRAY
72673: PUSH
72674: LD_INT 1
72676: ARRAY
72677: PPUSH
72678: CALL_OW 255
72682: PPUSH
72683: LD_EXP 71
72687: PUSH
72688: LD_VAR 0 2
72692: ARRAY
72693: PPUSH
72694: CALL 17722 0 2
72698: GO 72636
72700: POP
72701: POP
// end ;
72702: LD_VAR 0 1
72706: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72707: LD_INT 0
72709: PPUSH
72710: PPUSH
72711: PPUSH
72712: PPUSH
72713: PPUSH
72714: PPUSH
72715: PPUSH
72716: PPUSH
// if not mc_bases or not mc_parking then
72717: LD_EXP 58
72721: NOT
72722: PUSH
72723: LD_EXP 82
72727: NOT
72728: OR
72729: IFFALSE 72733
// exit ;
72731: GO 73445
// for i = 1 to mc_bases do
72733: LD_ADDR_VAR 0 2
72737: PUSH
72738: DOUBLE
72739: LD_INT 1
72741: DEC
72742: ST_TO_ADDR
72743: LD_EXP 58
72747: PUSH
72748: FOR_TO
72749: IFFALSE 73443
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72751: LD_EXP 58
72755: PUSH
72756: LD_VAR 0 2
72760: ARRAY
72761: NOT
72762: PUSH
72763: LD_EXP 82
72767: PUSH
72768: LD_VAR 0 2
72772: ARRAY
72773: NOT
72774: OR
72775: IFFALSE 72779
// continue ;
72777: GO 72748
// if mc_scan [ i ] then
72779: LD_EXP 81
72783: PUSH
72784: LD_VAR 0 2
72788: ARRAY
72789: IFFALSE 72815
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72791: LD_ADDR_EXP 70
72795: PUSH
72796: LD_EXP 70
72800: PPUSH
72801: LD_VAR 0 2
72805: PPUSH
72806: EMPTY
72807: PPUSH
72808: CALL_OW 1
72812: ST_TO_ADDR
// continue ;
72813: GO 72748
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72815: LD_ADDR_VAR 0 5
72819: PUSH
72820: LD_EXP 58
72824: PUSH
72825: LD_VAR 0 2
72829: ARRAY
72830: PUSH
72831: LD_INT 1
72833: ARRAY
72834: PPUSH
72835: CALL_OW 255
72839: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72840: LD_ADDR_VAR 0 6
72844: PUSH
72845: LD_EXP 58
72849: PUSH
72850: LD_VAR 0 2
72854: ARRAY
72855: PPUSH
72856: LD_INT 30
72858: PUSH
72859: LD_INT 3
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PPUSH
72866: CALL_OW 72
72870: ST_TO_ADDR
// if not fac then
72871: LD_VAR 0 6
72875: NOT
72876: IFFALSE 72927
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72878: LD_ADDR_VAR 0 6
72882: PUSH
72883: LD_EXP 58
72887: PUSH
72888: LD_VAR 0 2
72892: ARRAY
72893: PPUSH
72894: LD_INT 2
72896: PUSH
72897: LD_INT 30
72899: PUSH
72900: LD_INT 0
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 30
72909: PUSH
72910: LD_INT 1
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: LIST
72921: PPUSH
72922: CALL_OW 72
72926: ST_TO_ADDR
// if not fac then
72927: LD_VAR 0 6
72931: NOT
72932: IFFALSE 72936
// continue ;
72934: GO 72748
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72936: LD_ADDR_VAR 0 7
72940: PUSH
72941: LD_EXP 82
72945: PUSH
72946: LD_VAR 0 2
72950: ARRAY
72951: PPUSH
72952: LD_INT 22
72954: PUSH
72955: LD_VAR 0 5
72959: PUSH
72960: EMPTY
72961: LIST
72962: LIST
72963: PUSH
72964: LD_INT 21
72966: PUSH
72967: LD_INT 2
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 3
72976: PUSH
72977: LD_INT 24
72979: PUSH
72980: LD_INT 1000
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: LIST
72995: PPUSH
72996: CALL_OW 70
73000: PUSH
73001: LD_INT 22
73003: PUSH
73004: LD_VAR 0 5
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 91
73015: PUSH
73016: LD_VAR 0 6
73020: PUSH
73021: LD_INT 1
73023: ARRAY
73024: PUSH
73025: LD_INT 25
73027: PUSH
73028: EMPTY
73029: LIST
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 21
73035: PUSH
73036: LD_INT 2
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 3
73045: PUSH
73046: LD_INT 24
73048: PUSH
73049: LD_INT 1000
73051: PUSH
73052: EMPTY
73053: LIST
73054: LIST
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: EMPTY
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: PPUSH
73066: CALL_OW 69
73070: UNION
73071: ST_TO_ADDR
// if not vehs then
73072: LD_VAR 0 7
73076: NOT
73077: IFFALSE 73103
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73079: LD_ADDR_EXP 70
73083: PUSH
73084: LD_EXP 70
73088: PPUSH
73089: LD_VAR 0 2
73093: PPUSH
73094: EMPTY
73095: PPUSH
73096: CALL_OW 1
73100: ST_TO_ADDR
// continue ;
73101: GO 72748
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73103: LD_ADDR_VAR 0 8
73107: PUSH
73108: LD_EXP 58
73112: PUSH
73113: LD_VAR 0 2
73117: ARRAY
73118: PPUSH
73119: LD_INT 30
73121: PUSH
73122: LD_INT 3
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PPUSH
73129: CALL_OW 72
73133: ST_TO_ADDR
// if tmp then
73134: LD_VAR 0 8
73138: IFFALSE 73241
// begin for j in tmp do
73140: LD_ADDR_VAR 0 3
73144: PUSH
73145: LD_VAR 0 8
73149: PUSH
73150: FOR_IN
73151: IFFALSE 73239
// for k in UnitsInside ( j ) do
73153: LD_ADDR_VAR 0 4
73157: PUSH
73158: LD_VAR 0 3
73162: PPUSH
73163: CALL_OW 313
73167: PUSH
73168: FOR_IN
73169: IFFALSE 73235
// if k then
73171: LD_VAR 0 4
73175: IFFALSE 73233
// if not k in mc_repair_vehicle [ i ] then
73177: LD_VAR 0 4
73181: PUSH
73182: LD_EXP 70
73186: PUSH
73187: LD_VAR 0 2
73191: ARRAY
73192: IN
73193: NOT
73194: IFFALSE 73233
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73196: LD_ADDR_EXP 70
73200: PUSH
73201: LD_EXP 70
73205: PPUSH
73206: LD_VAR 0 2
73210: PPUSH
73211: LD_EXP 70
73215: PUSH
73216: LD_VAR 0 2
73220: ARRAY
73221: PUSH
73222: LD_VAR 0 4
73226: UNION
73227: PPUSH
73228: CALL_OW 1
73232: ST_TO_ADDR
73233: GO 73168
73235: POP
73236: POP
73237: GO 73150
73239: POP
73240: POP
// end ; if not mc_repair_vehicle [ i ] then
73241: LD_EXP 70
73245: PUSH
73246: LD_VAR 0 2
73250: ARRAY
73251: NOT
73252: IFFALSE 73256
// continue ;
73254: GO 72748
// for j in mc_repair_vehicle [ i ] do
73256: LD_ADDR_VAR 0 3
73260: PUSH
73261: LD_EXP 70
73265: PUSH
73266: LD_VAR 0 2
73270: ARRAY
73271: PUSH
73272: FOR_IN
73273: IFFALSE 73439
// begin if GetClass ( j ) <> 3 then
73275: LD_VAR 0 3
73279: PPUSH
73280: CALL_OW 257
73284: PUSH
73285: LD_INT 3
73287: NONEQUAL
73288: IFFALSE 73329
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73290: LD_ADDR_EXP 70
73294: PUSH
73295: LD_EXP 70
73299: PPUSH
73300: LD_VAR 0 2
73304: PPUSH
73305: LD_EXP 70
73309: PUSH
73310: LD_VAR 0 2
73314: ARRAY
73315: PUSH
73316: LD_VAR 0 3
73320: DIFF
73321: PPUSH
73322: CALL_OW 1
73326: ST_TO_ADDR
// continue ;
73327: GO 73272
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73329: LD_VAR 0 3
73333: PPUSH
73334: CALL_OW 311
73338: NOT
73339: PUSH
73340: LD_VAR 0 3
73344: PUSH
73345: LD_EXP 61
73349: PUSH
73350: LD_VAR 0 2
73354: ARRAY
73355: PUSH
73356: LD_INT 1
73358: ARRAY
73359: IN
73360: NOT
73361: AND
73362: PUSH
73363: LD_VAR 0 3
73367: PUSH
73368: LD_EXP 61
73372: PUSH
73373: LD_VAR 0 2
73377: ARRAY
73378: PUSH
73379: LD_INT 2
73381: ARRAY
73382: IN
73383: NOT
73384: AND
73385: IFFALSE 73437
// begin if IsInUnit ( j ) then
73387: LD_VAR 0 3
73391: PPUSH
73392: CALL_OW 310
73396: IFFALSE 73407
// ComExitBuilding ( j ) ;
73398: LD_VAR 0 3
73402: PPUSH
73403: CALL_OW 122
// if not HasTask ( j ) then
73407: LD_VAR 0 3
73411: PPUSH
73412: CALL_OW 314
73416: NOT
73417: IFFALSE 73437
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
73419: LD_VAR 0 3
73423: PPUSH
73424: LD_VAR 0 7
73428: PUSH
73429: LD_INT 1
73431: ARRAY
73432: PPUSH
73433: CALL_OW 189
// end ; end ;
73437: GO 73272
73439: POP
73440: POP
// end ;
73441: GO 72748
73443: POP
73444: POP
// end ;
73445: LD_VAR 0 1
73449: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73450: LD_INT 0
73452: PPUSH
73453: PPUSH
73454: PPUSH
73455: PPUSH
73456: PPUSH
73457: PPUSH
73458: PPUSH
73459: PPUSH
73460: PPUSH
73461: PPUSH
73462: PPUSH
// if not mc_bases then
73463: LD_EXP 58
73467: NOT
73468: IFFALSE 73472
// exit ;
73470: GO 74274
// for i = 1 to mc_bases do
73472: LD_ADDR_VAR 0 2
73476: PUSH
73477: DOUBLE
73478: LD_INT 1
73480: DEC
73481: ST_TO_ADDR
73482: LD_EXP 58
73486: PUSH
73487: FOR_TO
73488: IFFALSE 74272
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73490: LD_EXP 86
73494: PUSH
73495: LD_VAR 0 2
73499: ARRAY
73500: NOT
73501: PUSH
73502: LD_EXP 61
73506: PUSH
73507: LD_VAR 0 2
73511: ARRAY
73512: PUSH
73513: LD_INT 1
73515: ARRAY
73516: OR
73517: PUSH
73518: LD_EXP 61
73522: PUSH
73523: LD_VAR 0 2
73527: ARRAY
73528: PUSH
73529: LD_INT 2
73531: ARRAY
73532: OR
73533: PUSH
73534: LD_EXP 84
73538: PUSH
73539: LD_VAR 0 2
73543: ARRAY
73544: PPUSH
73545: LD_INT 1
73547: PPUSH
73548: CALL_OW 325
73552: NOT
73553: OR
73554: PUSH
73555: LD_EXP 81
73559: PUSH
73560: LD_VAR 0 2
73564: ARRAY
73565: OR
73566: IFFALSE 73570
// continue ;
73568: GO 73487
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73570: LD_ADDR_VAR 0 8
73574: PUSH
73575: LD_EXP 58
73579: PUSH
73580: LD_VAR 0 2
73584: ARRAY
73585: PPUSH
73586: LD_INT 25
73588: PUSH
73589: LD_INT 4
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 50
73598: PUSH
73599: EMPTY
73600: LIST
73601: PUSH
73602: LD_INT 3
73604: PUSH
73605: LD_INT 60
73607: PUSH
73608: EMPTY
73609: LIST
73610: PUSH
73611: EMPTY
73612: LIST
73613: LIST
73614: PUSH
73615: EMPTY
73616: LIST
73617: LIST
73618: LIST
73619: PPUSH
73620: CALL_OW 72
73624: PUSH
73625: LD_EXP 62
73629: PUSH
73630: LD_VAR 0 2
73634: ARRAY
73635: DIFF
73636: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73637: LD_ADDR_VAR 0 9
73641: PUSH
73642: LD_EXP 58
73646: PUSH
73647: LD_VAR 0 2
73651: ARRAY
73652: PPUSH
73653: LD_INT 2
73655: PUSH
73656: LD_INT 30
73658: PUSH
73659: LD_INT 0
73661: PUSH
73662: EMPTY
73663: LIST
73664: LIST
73665: PUSH
73666: LD_INT 30
73668: PUSH
73669: LD_INT 1
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: LIST
73680: PPUSH
73681: CALL_OW 72
73685: ST_TO_ADDR
// if not tmp or not dep then
73686: LD_VAR 0 8
73690: NOT
73691: PUSH
73692: LD_VAR 0 9
73696: NOT
73697: OR
73698: IFFALSE 73702
// continue ;
73700: GO 73487
// side := GetSide ( tmp [ 1 ] ) ;
73702: LD_ADDR_VAR 0 11
73706: PUSH
73707: LD_VAR 0 8
73711: PUSH
73712: LD_INT 1
73714: ARRAY
73715: PPUSH
73716: CALL_OW 255
73720: ST_TO_ADDR
// dep := dep [ 1 ] ;
73721: LD_ADDR_VAR 0 9
73725: PUSH
73726: LD_VAR 0 9
73730: PUSH
73731: LD_INT 1
73733: ARRAY
73734: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73735: LD_ADDR_VAR 0 7
73739: PUSH
73740: LD_EXP 86
73744: PUSH
73745: LD_VAR 0 2
73749: ARRAY
73750: PPUSH
73751: LD_INT 22
73753: PUSH
73754: LD_INT 0
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 25
73763: PUSH
73764: LD_INT 12
73766: PUSH
73767: EMPTY
73768: LIST
73769: LIST
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PPUSH
73775: CALL_OW 70
73779: PUSH
73780: LD_INT 22
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 25
73792: PUSH
73793: LD_INT 12
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 91
73802: PUSH
73803: LD_VAR 0 9
73807: PUSH
73808: LD_INT 20
73810: PUSH
73811: EMPTY
73812: LIST
73813: LIST
73814: LIST
73815: PUSH
73816: EMPTY
73817: LIST
73818: LIST
73819: LIST
73820: PPUSH
73821: CALL_OW 69
73825: UNION
73826: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73827: LD_ADDR_VAR 0 10
73831: PUSH
73832: LD_EXP 86
73836: PUSH
73837: LD_VAR 0 2
73841: ARRAY
73842: PPUSH
73843: LD_INT 81
73845: PUSH
73846: LD_VAR 0 11
73850: PUSH
73851: EMPTY
73852: LIST
73853: LIST
73854: PPUSH
73855: CALL_OW 70
73859: ST_TO_ADDR
// if not apes or danger_at_area then
73860: LD_VAR 0 7
73864: NOT
73865: PUSH
73866: LD_VAR 0 10
73870: OR
73871: IFFALSE 73921
// begin if mc_taming [ i ] then
73873: LD_EXP 89
73877: PUSH
73878: LD_VAR 0 2
73882: ARRAY
73883: IFFALSE 73919
// begin MC_Reset ( i , 121 ) ;
73885: LD_VAR 0 2
73889: PPUSH
73890: LD_INT 121
73892: PPUSH
73893: CALL 59556 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73897: LD_ADDR_EXP 89
73901: PUSH
73902: LD_EXP 89
73906: PPUSH
73907: LD_VAR 0 2
73911: PPUSH
73912: EMPTY
73913: PPUSH
73914: CALL_OW 1
73918: ST_TO_ADDR
// end ; continue ;
73919: GO 73487
// end ; for j in tmp do
73921: LD_ADDR_VAR 0 3
73925: PUSH
73926: LD_VAR 0 8
73930: PUSH
73931: FOR_IN
73932: IFFALSE 74268
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73934: LD_VAR 0 3
73938: PUSH
73939: LD_EXP 89
73943: PUSH
73944: LD_VAR 0 2
73948: ARRAY
73949: IN
73950: NOT
73951: PUSH
73952: LD_EXP 89
73956: PUSH
73957: LD_VAR 0 2
73961: ARRAY
73962: PUSH
73963: LD_INT 3
73965: LESS
73966: AND
73967: IFFALSE 74025
// begin SetTag ( j , 121 ) ;
73969: LD_VAR 0 3
73973: PPUSH
73974: LD_INT 121
73976: PPUSH
73977: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73981: LD_ADDR_EXP 89
73985: PUSH
73986: LD_EXP 89
73990: PPUSH
73991: LD_VAR 0 2
73995: PUSH
73996: LD_EXP 89
74000: PUSH
74001: LD_VAR 0 2
74005: ARRAY
74006: PUSH
74007: LD_INT 1
74009: PLUS
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PPUSH
74015: LD_VAR 0 3
74019: PPUSH
74020: CALL 20665 0 3
74024: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74025: LD_VAR 0 3
74029: PUSH
74030: LD_EXP 89
74034: PUSH
74035: LD_VAR 0 2
74039: ARRAY
74040: IN
74041: IFFALSE 74266
// begin if GetClass ( j ) <> 4 then
74043: LD_VAR 0 3
74047: PPUSH
74048: CALL_OW 257
74052: PUSH
74053: LD_INT 4
74055: NONEQUAL
74056: IFFALSE 74109
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74058: LD_ADDR_EXP 89
74062: PUSH
74063: LD_EXP 89
74067: PPUSH
74068: LD_VAR 0 2
74072: PPUSH
74073: LD_EXP 89
74077: PUSH
74078: LD_VAR 0 2
74082: ARRAY
74083: PUSH
74084: LD_VAR 0 3
74088: DIFF
74089: PPUSH
74090: CALL_OW 1
74094: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74095: LD_VAR 0 3
74099: PPUSH
74100: LD_INT 0
74102: PPUSH
74103: CALL_OW 109
// continue ;
74107: GO 73931
// end ; if IsInUnit ( j ) then
74109: LD_VAR 0 3
74113: PPUSH
74114: CALL_OW 310
74118: IFFALSE 74129
// ComExitBuilding ( j ) ;
74120: LD_VAR 0 3
74124: PPUSH
74125: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74129: LD_ADDR_VAR 0 6
74133: PUSH
74134: LD_VAR 0 7
74138: PPUSH
74139: LD_VAR 0 3
74143: PPUSH
74144: CALL_OW 74
74148: ST_TO_ADDR
// if not ape then
74149: LD_VAR 0 6
74153: NOT
74154: IFFALSE 74158
// break ;
74156: GO 74268
// x := GetX ( ape ) ;
74158: LD_ADDR_VAR 0 4
74162: PUSH
74163: LD_VAR 0 6
74167: PPUSH
74168: CALL_OW 250
74172: ST_TO_ADDR
// y := GetY ( ape ) ;
74173: LD_ADDR_VAR 0 5
74177: PUSH
74178: LD_VAR 0 6
74182: PPUSH
74183: CALL_OW 251
74187: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74188: LD_VAR 0 4
74192: PPUSH
74193: LD_VAR 0 5
74197: PPUSH
74198: CALL_OW 488
74202: NOT
74203: PUSH
74204: LD_VAR 0 11
74208: PPUSH
74209: LD_VAR 0 4
74213: PPUSH
74214: LD_VAR 0 5
74218: PPUSH
74219: LD_INT 20
74221: PPUSH
74222: CALL 21561 0 4
74226: PUSH
74227: LD_INT 4
74229: ARRAY
74230: OR
74231: IFFALSE 74235
// break ;
74233: GO 74268
// if not HasTask ( j ) then
74235: LD_VAR 0 3
74239: PPUSH
74240: CALL_OW 314
74244: NOT
74245: IFFALSE 74266
// ComTameXY ( j , x , y ) ;
74247: LD_VAR 0 3
74251: PPUSH
74252: LD_VAR 0 4
74256: PPUSH
74257: LD_VAR 0 5
74261: PPUSH
74262: CALL_OW 131
// end ; end ;
74266: GO 73931
74268: POP
74269: POP
// end ;
74270: GO 73487
74272: POP
74273: POP
// end ;
74274: LD_VAR 0 1
74278: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74279: LD_INT 0
74281: PPUSH
74282: PPUSH
74283: PPUSH
74284: PPUSH
74285: PPUSH
74286: PPUSH
74287: PPUSH
74288: PPUSH
// if not mc_bases then
74289: LD_EXP 58
74293: NOT
74294: IFFALSE 74298
// exit ;
74296: GO 74924
// for i = 1 to mc_bases do
74298: LD_ADDR_VAR 0 2
74302: PUSH
74303: DOUBLE
74304: LD_INT 1
74306: DEC
74307: ST_TO_ADDR
74308: LD_EXP 58
74312: PUSH
74313: FOR_TO
74314: IFFALSE 74922
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74316: LD_EXP 87
74320: PUSH
74321: LD_VAR 0 2
74325: ARRAY
74326: NOT
74327: PUSH
74328: LD_EXP 87
74332: PUSH
74333: LD_VAR 0 2
74337: ARRAY
74338: PPUSH
74339: LD_INT 25
74341: PUSH
74342: LD_INT 12
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PPUSH
74349: CALL_OW 72
74353: NOT
74354: OR
74355: IFFALSE 74359
// continue ;
74357: GO 74313
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74359: LD_ADDR_VAR 0 5
74363: PUSH
74364: LD_EXP 87
74368: PUSH
74369: LD_VAR 0 2
74373: ARRAY
74374: PUSH
74375: LD_INT 1
74377: ARRAY
74378: PPUSH
74379: CALL_OW 255
74383: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74384: LD_VAR 0 5
74388: PPUSH
74389: LD_INT 2
74391: PPUSH
74392: CALL_OW 325
74396: IFFALSE 74649
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74398: LD_ADDR_VAR 0 4
74402: PUSH
74403: LD_EXP 87
74407: PUSH
74408: LD_VAR 0 2
74412: ARRAY
74413: PPUSH
74414: LD_INT 25
74416: PUSH
74417: LD_INT 16
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PPUSH
74424: CALL_OW 72
74428: ST_TO_ADDR
// if tmp < 6 then
74429: LD_VAR 0 4
74433: PUSH
74434: LD_INT 6
74436: LESS
74437: IFFALSE 74649
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74439: LD_ADDR_VAR 0 6
74443: PUSH
74444: LD_EXP 58
74448: PUSH
74449: LD_VAR 0 2
74453: ARRAY
74454: PPUSH
74455: LD_INT 2
74457: PUSH
74458: LD_INT 30
74460: PUSH
74461: LD_INT 0
74463: PUSH
74464: EMPTY
74465: LIST
74466: LIST
74467: PUSH
74468: LD_INT 30
74470: PUSH
74471: LD_INT 1
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: EMPTY
74479: LIST
74480: LIST
74481: LIST
74482: PPUSH
74483: CALL_OW 72
74487: ST_TO_ADDR
// if depot then
74488: LD_VAR 0 6
74492: IFFALSE 74649
// begin selected := 0 ;
74494: LD_ADDR_VAR 0 7
74498: PUSH
74499: LD_INT 0
74501: ST_TO_ADDR
// for j in depot do
74502: LD_ADDR_VAR 0 3
74506: PUSH
74507: LD_VAR 0 6
74511: PUSH
74512: FOR_IN
74513: IFFALSE 74544
// begin if UnitsInside ( j ) < 6 then
74515: LD_VAR 0 3
74519: PPUSH
74520: CALL_OW 313
74524: PUSH
74525: LD_INT 6
74527: LESS
74528: IFFALSE 74542
// begin selected := j ;
74530: LD_ADDR_VAR 0 7
74534: PUSH
74535: LD_VAR 0 3
74539: ST_TO_ADDR
// break ;
74540: GO 74544
// end ; end ;
74542: GO 74512
74544: POP
74545: POP
// if selected then
74546: LD_VAR 0 7
74550: IFFALSE 74649
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74552: LD_ADDR_VAR 0 3
74556: PUSH
74557: LD_EXP 87
74561: PUSH
74562: LD_VAR 0 2
74566: ARRAY
74567: PPUSH
74568: LD_INT 25
74570: PUSH
74571: LD_INT 12
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: PPUSH
74578: CALL_OW 72
74582: PUSH
74583: FOR_IN
74584: IFFALSE 74647
// if not HasTask ( j ) then
74586: LD_VAR 0 3
74590: PPUSH
74591: CALL_OW 314
74595: NOT
74596: IFFALSE 74645
// begin if not IsInUnit ( j ) then
74598: LD_VAR 0 3
74602: PPUSH
74603: CALL_OW 310
74607: NOT
74608: IFFALSE 74624
// ComEnterUnit ( j , selected ) ;
74610: LD_VAR 0 3
74614: PPUSH
74615: LD_VAR 0 7
74619: PPUSH
74620: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74624: LD_VAR 0 3
74628: PPUSH
74629: LD_INT 16
74631: PPUSH
74632: CALL_OW 183
// AddComExitBuilding ( j ) ;
74636: LD_VAR 0 3
74640: PPUSH
74641: CALL_OW 182
// end ;
74645: GO 74583
74647: POP
74648: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74649: LD_VAR 0 5
74653: PPUSH
74654: LD_INT 11
74656: PPUSH
74657: CALL_OW 325
74661: IFFALSE 74920
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74663: LD_ADDR_VAR 0 4
74667: PUSH
74668: LD_EXP 87
74672: PUSH
74673: LD_VAR 0 2
74677: ARRAY
74678: PPUSH
74679: LD_INT 25
74681: PUSH
74682: LD_INT 16
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PPUSH
74689: CALL_OW 72
74693: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74694: LD_VAR 0 4
74698: PUSH
74699: LD_INT 6
74701: GREATEREQUAL
74702: PUSH
74703: LD_VAR 0 5
74707: PPUSH
74708: LD_INT 2
74710: PPUSH
74711: CALL_OW 325
74715: NOT
74716: OR
74717: IFFALSE 74920
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74719: LD_ADDR_VAR 0 8
74723: PUSH
74724: LD_EXP 58
74728: PUSH
74729: LD_VAR 0 2
74733: ARRAY
74734: PPUSH
74735: LD_INT 2
74737: PUSH
74738: LD_INT 30
74740: PUSH
74741: LD_INT 4
74743: PUSH
74744: EMPTY
74745: LIST
74746: LIST
74747: PUSH
74748: LD_INT 30
74750: PUSH
74751: LD_INT 5
74753: PUSH
74754: EMPTY
74755: LIST
74756: LIST
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: LIST
74762: PPUSH
74763: CALL_OW 72
74767: ST_TO_ADDR
// if barracks then
74768: LD_VAR 0 8
74772: IFFALSE 74920
// begin selected := 0 ;
74774: LD_ADDR_VAR 0 7
74778: PUSH
74779: LD_INT 0
74781: ST_TO_ADDR
// for j in barracks do
74782: LD_ADDR_VAR 0 3
74786: PUSH
74787: LD_VAR 0 8
74791: PUSH
74792: FOR_IN
74793: IFFALSE 74824
// begin if UnitsInside ( j ) < 6 then
74795: LD_VAR 0 3
74799: PPUSH
74800: CALL_OW 313
74804: PUSH
74805: LD_INT 6
74807: LESS
74808: IFFALSE 74822
// begin selected := j ;
74810: LD_ADDR_VAR 0 7
74814: PUSH
74815: LD_VAR 0 3
74819: ST_TO_ADDR
// break ;
74820: GO 74824
// end ; end ;
74822: GO 74792
74824: POP
74825: POP
// if selected then
74826: LD_VAR 0 7
74830: IFFALSE 74920
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74832: LD_ADDR_VAR 0 3
74836: PUSH
74837: LD_EXP 87
74841: PUSH
74842: LD_VAR 0 2
74846: ARRAY
74847: PPUSH
74848: LD_INT 25
74850: PUSH
74851: LD_INT 12
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PPUSH
74858: CALL_OW 72
74862: PUSH
74863: FOR_IN
74864: IFFALSE 74918
// if not IsInUnit ( j ) and not HasTask ( j ) then
74866: LD_VAR 0 3
74870: PPUSH
74871: CALL_OW 310
74875: NOT
74876: PUSH
74877: LD_VAR 0 3
74881: PPUSH
74882: CALL_OW 314
74886: NOT
74887: AND
74888: IFFALSE 74916
// begin ComEnterUnit ( j , selected ) ;
74890: LD_VAR 0 3
74894: PPUSH
74895: LD_VAR 0 7
74899: PPUSH
74900: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74904: LD_VAR 0 3
74908: PPUSH
74909: LD_INT 15
74911: PPUSH
74912: CALL_OW 183
// end ;
74916: GO 74863
74918: POP
74919: POP
// end ; end ; end ; end ; end ;
74920: GO 74313
74922: POP
74923: POP
// end ;
74924: LD_VAR 0 1
74928: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74929: LD_INT 0
74931: PPUSH
74932: PPUSH
74933: PPUSH
74934: PPUSH
// if not mc_bases then
74935: LD_EXP 58
74939: NOT
74940: IFFALSE 74944
// exit ;
74942: GO 75122
// for i = 1 to mc_bases do
74944: LD_ADDR_VAR 0 2
74948: PUSH
74949: DOUBLE
74950: LD_INT 1
74952: DEC
74953: ST_TO_ADDR
74954: LD_EXP 58
74958: PUSH
74959: FOR_TO
74960: IFFALSE 75120
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74962: LD_ADDR_VAR 0 4
74966: PUSH
74967: LD_EXP 58
74971: PUSH
74972: LD_VAR 0 2
74976: ARRAY
74977: PPUSH
74978: LD_INT 25
74980: PUSH
74981: LD_INT 9
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PPUSH
74988: CALL_OW 72
74992: ST_TO_ADDR
// if not tmp then
74993: LD_VAR 0 4
74997: NOT
74998: IFFALSE 75002
// continue ;
75000: GO 74959
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75002: LD_EXP 84
75006: PUSH
75007: LD_VAR 0 2
75011: ARRAY
75012: PPUSH
75013: LD_INT 29
75015: PPUSH
75016: CALL_OW 325
75020: NOT
75021: PUSH
75022: LD_EXP 84
75026: PUSH
75027: LD_VAR 0 2
75031: ARRAY
75032: PPUSH
75033: LD_INT 28
75035: PPUSH
75036: CALL_OW 325
75040: NOT
75041: AND
75042: IFFALSE 75046
// continue ;
75044: GO 74959
// for j in tmp do
75046: LD_ADDR_VAR 0 3
75050: PUSH
75051: LD_VAR 0 4
75055: PUSH
75056: FOR_IN
75057: IFFALSE 75116
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75059: LD_VAR 0 3
75063: PUSH
75064: LD_EXP 61
75068: PUSH
75069: LD_VAR 0 2
75073: ARRAY
75074: PUSH
75075: LD_INT 1
75077: ARRAY
75078: IN
75079: NOT
75080: PUSH
75081: LD_VAR 0 3
75085: PUSH
75086: LD_EXP 61
75090: PUSH
75091: LD_VAR 0 2
75095: ARRAY
75096: PUSH
75097: LD_INT 2
75099: ARRAY
75100: IN
75101: NOT
75102: AND
75103: IFFALSE 75114
// ComSpaceTimeShoot ( j ) ;
75105: LD_VAR 0 3
75109: PPUSH
75110: CALL 14725 0 1
75114: GO 75056
75116: POP
75117: POP
// end ;
75118: GO 74959
75120: POP
75121: POP
// end ;
75122: LD_VAR 0 1
75126: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75127: LD_INT 0
75129: PPUSH
75130: PPUSH
75131: PPUSH
75132: PPUSH
75133: PPUSH
75134: PPUSH
75135: PPUSH
75136: PPUSH
75137: PPUSH
// if not mc_bases then
75138: LD_EXP 58
75142: NOT
75143: IFFALSE 75147
// exit ;
75145: GO 75769
// for i = 1 to mc_bases do
75147: LD_ADDR_VAR 0 2
75151: PUSH
75152: DOUBLE
75153: LD_INT 1
75155: DEC
75156: ST_TO_ADDR
75157: LD_EXP 58
75161: PUSH
75162: FOR_TO
75163: IFFALSE 75767
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75165: LD_EXP 93
75169: PUSH
75170: LD_VAR 0 2
75174: ARRAY
75175: NOT
75176: PUSH
75177: LD_INT 38
75179: PPUSH
75180: LD_EXP 84
75184: PUSH
75185: LD_VAR 0 2
75189: ARRAY
75190: PPUSH
75191: CALL_OW 321
75195: PUSH
75196: LD_INT 2
75198: NONEQUAL
75199: OR
75200: IFFALSE 75204
// continue ;
75202: GO 75162
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75204: LD_ADDR_VAR 0 8
75208: PUSH
75209: LD_EXP 58
75213: PUSH
75214: LD_VAR 0 2
75218: ARRAY
75219: PPUSH
75220: LD_INT 30
75222: PUSH
75223: LD_INT 34
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PPUSH
75230: CALL_OW 72
75234: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75235: LD_ADDR_VAR 0 9
75239: PUSH
75240: LD_EXP 58
75244: PUSH
75245: LD_VAR 0 2
75249: ARRAY
75250: PPUSH
75251: LD_INT 25
75253: PUSH
75254: LD_INT 4
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PPUSH
75261: CALL_OW 72
75265: PPUSH
75266: LD_INT 0
75268: PPUSH
75269: CALL 53862 0 2
75273: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75274: LD_VAR 0 9
75278: NOT
75279: PUSH
75280: LD_VAR 0 8
75284: NOT
75285: OR
75286: PUSH
75287: LD_EXP 58
75291: PUSH
75292: LD_VAR 0 2
75296: ARRAY
75297: PPUSH
75298: LD_INT 124
75300: PPUSH
75301: CALL 53862 0 2
75305: OR
75306: IFFALSE 75310
// continue ;
75308: GO 75162
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75310: LD_EXP 94
75314: PUSH
75315: LD_VAR 0 2
75319: ARRAY
75320: PUSH
75321: LD_EXP 93
75325: PUSH
75326: LD_VAR 0 2
75330: ARRAY
75331: LESS
75332: PUSH
75333: LD_EXP 94
75337: PUSH
75338: LD_VAR 0 2
75342: ARRAY
75343: PUSH
75344: LD_VAR 0 8
75348: LESS
75349: AND
75350: IFFALSE 75765
// begin tmp := sci [ 1 ] ;
75352: LD_ADDR_VAR 0 7
75356: PUSH
75357: LD_VAR 0 9
75361: PUSH
75362: LD_INT 1
75364: ARRAY
75365: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75366: LD_VAR 0 7
75370: PPUSH
75371: LD_INT 124
75373: PPUSH
75374: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75378: LD_ADDR_VAR 0 3
75382: PUSH
75383: DOUBLE
75384: LD_EXP 93
75388: PUSH
75389: LD_VAR 0 2
75393: ARRAY
75394: INC
75395: ST_TO_ADDR
75396: LD_EXP 93
75400: PUSH
75401: LD_VAR 0 2
75405: ARRAY
75406: PUSH
75407: FOR_DOWNTO
75408: IFFALSE 75751
// begin if IsInUnit ( tmp ) then
75410: LD_VAR 0 7
75414: PPUSH
75415: CALL_OW 310
75419: IFFALSE 75430
// ComExitBuilding ( tmp ) ;
75421: LD_VAR 0 7
75425: PPUSH
75426: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75430: LD_INT 35
75432: PPUSH
75433: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75437: LD_VAR 0 7
75441: PPUSH
75442: CALL_OW 310
75446: NOT
75447: PUSH
75448: LD_VAR 0 7
75452: PPUSH
75453: CALL_OW 314
75457: NOT
75458: AND
75459: IFFALSE 75430
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75461: LD_ADDR_VAR 0 6
75465: PUSH
75466: LD_VAR 0 7
75470: PPUSH
75471: CALL_OW 250
75475: PUSH
75476: LD_VAR 0 7
75480: PPUSH
75481: CALL_OW 251
75485: PUSH
75486: EMPTY
75487: LIST
75488: LIST
75489: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75490: LD_INT 35
75492: PPUSH
75493: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75497: LD_ADDR_VAR 0 4
75501: PUSH
75502: LD_EXP 93
75506: PUSH
75507: LD_VAR 0 2
75511: ARRAY
75512: PUSH
75513: LD_VAR 0 3
75517: ARRAY
75518: PUSH
75519: LD_INT 1
75521: ARRAY
75522: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75523: LD_ADDR_VAR 0 5
75527: PUSH
75528: LD_EXP 93
75532: PUSH
75533: LD_VAR 0 2
75537: ARRAY
75538: PUSH
75539: LD_VAR 0 3
75543: ARRAY
75544: PUSH
75545: LD_INT 2
75547: ARRAY
75548: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75549: LD_VAR 0 7
75553: PPUSH
75554: LD_INT 10
75556: PPUSH
75557: CALL 23258 0 2
75561: PUSH
75562: LD_INT 4
75564: ARRAY
75565: IFFALSE 75603
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75567: LD_VAR 0 7
75571: PPUSH
75572: LD_VAR 0 6
75576: PUSH
75577: LD_INT 1
75579: ARRAY
75580: PPUSH
75581: LD_VAR 0 6
75585: PUSH
75586: LD_INT 2
75588: ARRAY
75589: PPUSH
75590: CALL_OW 111
// wait ( 0 0$10 ) ;
75594: LD_INT 350
75596: PPUSH
75597: CALL_OW 67
// end else
75601: GO 75629
// begin ComMoveXY ( tmp , x , y ) ;
75603: LD_VAR 0 7
75607: PPUSH
75608: LD_VAR 0 4
75612: PPUSH
75613: LD_VAR 0 5
75617: PPUSH
75618: CALL_OW 111
// wait ( 0 0$3 ) ;
75622: LD_INT 105
75624: PPUSH
75625: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75629: LD_VAR 0 7
75633: PPUSH
75634: LD_VAR 0 4
75638: PPUSH
75639: LD_VAR 0 5
75643: PPUSH
75644: CALL_OW 307
75648: IFFALSE 75490
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75650: LD_VAR 0 7
75654: PPUSH
75655: LD_VAR 0 4
75659: PPUSH
75660: LD_VAR 0 5
75664: PPUSH
75665: LD_VAR 0 8
75669: PUSH
75670: LD_VAR 0 3
75674: ARRAY
75675: PPUSH
75676: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75680: LD_INT 35
75682: PPUSH
75683: CALL_OW 67
// until not HasTask ( tmp ) ;
75687: LD_VAR 0 7
75691: PPUSH
75692: CALL_OW 314
75696: NOT
75697: IFFALSE 75680
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75699: LD_ADDR_EXP 94
75703: PUSH
75704: LD_EXP 94
75708: PPUSH
75709: LD_VAR 0 2
75713: PUSH
75714: LD_EXP 94
75718: PUSH
75719: LD_VAR 0 2
75723: ARRAY
75724: PUSH
75725: LD_INT 1
75727: PLUS
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PPUSH
75733: LD_VAR 0 8
75737: PUSH
75738: LD_VAR 0 3
75742: ARRAY
75743: PPUSH
75744: CALL 20665 0 3
75748: ST_TO_ADDR
// end ;
75749: GO 75407
75751: POP
75752: POP
// MC_Reset ( i , 124 ) ;
75753: LD_VAR 0 2
75757: PPUSH
75758: LD_INT 124
75760: PPUSH
75761: CALL 59556 0 2
// end ; end ;
75765: GO 75162
75767: POP
75768: POP
// end ;
75769: LD_VAR 0 1
75773: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75774: LD_INT 0
75776: PPUSH
75777: PPUSH
75778: PPUSH
// if not mc_bases then
75779: LD_EXP 58
75783: NOT
75784: IFFALSE 75788
// exit ;
75786: GO 76394
// for i = 1 to mc_bases do
75788: LD_ADDR_VAR 0 2
75792: PUSH
75793: DOUBLE
75794: LD_INT 1
75796: DEC
75797: ST_TO_ADDR
75798: LD_EXP 58
75802: PUSH
75803: FOR_TO
75804: IFFALSE 76392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75806: LD_ADDR_VAR 0 3
75810: PUSH
75811: LD_EXP 58
75815: PUSH
75816: LD_VAR 0 2
75820: ARRAY
75821: PPUSH
75822: LD_INT 25
75824: PUSH
75825: LD_INT 4
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PPUSH
75832: CALL_OW 72
75836: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75837: LD_VAR 0 3
75841: NOT
75842: PUSH
75843: LD_EXP 95
75847: PUSH
75848: LD_VAR 0 2
75852: ARRAY
75853: NOT
75854: OR
75855: PUSH
75856: LD_EXP 58
75860: PUSH
75861: LD_VAR 0 2
75865: ARRAY
75866: PPUSH
75867: LD_INT 2
75869: PUSH
75870: LD_INT 30
75872: PUSH
75873: LD_INT 0
75875: PUSH
75876: EMPTY
75877: LIST
75878: LIST
75879: PUSH
75880: LD_INT 30
75882: PUSH
75883: LD_INT 1
75885: PUSH
75886: EMPTY
75887: LIST
75888: LIST
75889: PUSH
75890: EMPTY
75891: LIST
75892: LIST
75893: LIST
75894: PPUSH
75895: CALL_OW 72
75899: NOT
75900: OR
75901: IFFALSE 75951
// begin if mc_deposits_finder [ i ] then
75903: LD_EXP 96
75907: PUSH
75908: LD_VAR 0 2
75912: ARRAY
75913: IFFALSE 75949
// begin MC_Reset ( i , 125 ) ;
75915: LD_VAR 0 2
75919: PPUSH
75920: LD_INT 125
75922: PPUSH
75923: CALL 59556 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75927: LD_ADDR_EXP 96
75931: PUSH
75932: LD_EXP 96
75936: PPUSH
75937: LD_VAR 0 2
75941: PPUSH
75942: EMPTY
75943: PPUSH
75944: CALL_OW 1
75948: ST_TO_ADDR
// end ; continue ;
75949: GO 75803
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75951: LD_EXP 95
75955: PUSH
75956: LD_VAR 0 2
75960: ARRAY
75961: PUSH
75962: LD_INT 1
75964: ARRAY
75965: PUSH
75966: LD_INT 3
75968: ARRAY
75969: PUSH
75970: LD_INT 1
75972: EQUAL
75973: PUSH
75974: LD_INT 20
75976: PPUSH
75977: LD_EXP 84
75981: PUSH
75982: LD_VAR 0 2
75986: ARRAY
75987: PPUSH
75988: CALL_OW 321
75992: PUSH
75993: LD_INT 2
75995: NONEQUAL
75996: AND
75997: IFFALSE 76047
// begin if mc_deposits_finder [ i ] then
75999: LD_EXP 96
76003: PUSH
76004: LD_VAR 0 2
76008: ARRAY
76009: IFFALSE 76045
// begin MC_Reset ( i , 125 ) ;
76011: LD_VAR 0 2
76015: PPUSH
76016: LD_INT 125
76018: PPUSH
76019: CALL 59556 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76023: LD_ADDR_EXP 96
76027: PUSH
76028: LD_EXP 96
76032: PPUSH
76033: LD_VAR 0 2
76037: PPUSH
76038: EMPTY
76039: PPUSH
76040: CALL_OW 1
76044: ST_TO_ADDR
// end ; continue ;
76045: GO 75803
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76047: LD_EXP 95
76051: PUSH
76052: LD_VAR 0 2
76056: ARRAY
76057: PUSH
76058: LD_INT 1
76060: ARRAY
76061: PUSH
76062: LD_INT 1
76064: ARRAY
76065: PPUSH
76066: LD_EXP 95
76070: PUSH
76071: LD_VAR 0 2
76075: ARRAY
76076: PUSH
76077: LD_INT 1
76079: ARRAY
76080: PUSH
76081: LD_INT 2
76083: ARRAY
76084: PPUSH
76085: LD_EXP 84
76089: PUSH
76090: LD_VAR 0 2
76094: ARRAY
76095: PPUSH
76096: CALL_OW 440
76100: IFFALSE 76143
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76102: LD_ADDR_EXP 95
76106: PUSH
76107: LD_EXP 95
76111: PPUSH
76112: LD_VAR 0 2
76116: PPUSH
76117: LD_EXP 95
76121: PUSH
76122: LD_VAR 0 2
76126: ARRAY
76127: PPUSH
76128: LD_INT 1
76130: PPUSH
76131: CALL_OW 3
76135: PPUSH
76136: CALL_OW 1
76140: ST_TO_ADDR
76141: GO 76390
// begin if not mc_deposits_finder [ i ] then
76143: LD_EXP 96
76147: PUSH
76148: LD_VAR 0 2
76152: ARRAY
76153: NOT
76154: IFFALSE 76206
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76156: LD_ADDR_EXP 96
76160: PUSH
76161: LD_EXP 96
76165: PPUSH
76166: LD_VAR 0 2
76170: PPUSH
76171: LD_VAR 0 3
76175: PUSH
76176: LD_INT 1
76178: ARRAY
76179: PUSH
76180: EMPTY
76181: LIST
76182: PPUSH
76183: CALL_OW 1
76187: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76188: LD_VAR 0 3
76192: PUSH
76193: LD_INT 1
76195: ARRAY
76196: PPUSH
76197: LD_INT 125
76199: PPUSH
76200: CALL_OW 109
// end else
76204: GO 76390
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76206: LD_EXP 96
76210: PUSH
76211: LD_VAR 0 2
76215: ARRAY
76216: PUSH
76217: LD_INT 1
76219: ARRAY
76220: PPUSH
76221: CALL_OW 310
76225: IFFALSE 76248
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76227: LD_EXP 96
76231: PUSH
76232: LD_VAR 0 2
76236: ARRAY
76237: PUSH
76238: LD_INT 1
76240: ARRAY
76241: PPUSH
76242: CALL_OW 122
76246: GO 76390
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76248: LD_EXP 96
76252: PUSH
76253: LD_VAR 0 2
76257: ARRAY
76258: PUSH
76259: LD_INT 1
76261: ARRAY
76262: PPUSH
76263: CALL_OW 314
76267: NOT
76268: PUSH
76269: LD_EXP 96
76273: PUSH
76274: LD_VAR 0 2
76278: ARRAY
76279: PUSH
76280: LD_INT 1
76282: ARRAY
76283: PPUSH
76284: LD_EXP 95
76288: PUSH
76289: LD_VAR 0 2
76293: ARRAY
76294: PUSH
76295: LD_INT 1
76297: ARRAY
76298: PUSH
76299: LD_INT 1
76301: ARRAY
76302: PPUSH
76303: LD_EXP 95
76307: PUSH
76308: LD_VAR 0 2
76312: ARRAY
76313: PUSH
76314: LD_INT 1
76316: ARRAY
76317: PUSH
76318: LD_INT 2
76320: ARRAY
76321: PPUSH
76322: CALL_OW 297
76326: PUSH
76327: LD_INT 6
76329: GREATER
76330: AND
76331: IFFALSE 76390
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76333: LD_EXP 96
76337: PUSH
76338: LD_VAR 0 2
76342: ARRAY
76343: PUSH
76344: LD_INT 1
76346: ARRAY
76347: PPUSH
76348: LD_EXP 95
76352: PUSH
76353: LD_VAR 0 2
76357: ARRAY
76358: PUSH
76359: LD_INT 1
76361: ARRAY
76362: PUSH
76363: LD_INT 1
76365: ARRAY
76366: PPUSH
76367: LD_EXP 95
76371: PUSH
76372: LD_VAR 0 2
76376: ARRAY
76377: PUSH
76378: LD_INT 1
76380: ARRAY
76381: PUSH
76382: LD_INT 2
76384: ARRAY
76385: PPUSH
76386: CALL_OW 111
// end ; end ; end ;
76390: GO 75803
76392: POP
76393: POP
// end ;
76394: LD_VAR 0 1
76398: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76399: LD_INT 0
76401: PPUSH
76402: PPUSH
76403: PPUSH
76404: PPUSH
76405: PPUSH
76406: PPUSH
76407: PPUSH
76408: PPUSH
76409: PPUSH
76410: PPUSH
76411: PPUSH
// if not mc_bases then
76412: LD_EXP 58
76416: NOT
76417: IFFALSE 76421
// exit ;
76419: GO 77145
// for i = 1 to mc_bases do
76421: LD_ADDR_VAR 0 2
76425: PUSH
76426: DOUBLE
76427: LD_INT 1
76429: DEC
76430: ST_TO_ADDR
76431: LD_EXP 58
76435: PUSH
76436: FOR_TO
76437: IFFALSE 77143
// begin if not mc_bases [ i ] then
76439: LD_EXP 58
76443: PUSH
76444: LD_VAR 0 2
76448: ARRAY
76449: NOT
76450: IFFALSE 76454
// continue ;
76452: GO 76436
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76454: LD_ADDR_VAR 0 7
76458: PUSH
76459: LD_EXP 58
76463: PUSH
76464: LD_VAR 0 2
76468: ARRAY
76469: PUSH
76470: LD_INT 1
76472: ARRAY
76473: PPUSH
76474: CALL_OW 248
76478: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76479: LD_VAR 0 7
76483: PUSH
76484: LD_INT 3
76486: EQUAL
76487: PUSH
76488: LD_EXP 77
76492: PUSH
76493: LD_VAR 0 2
76497: ARRAY
76498: PUSH
76499: LD_EXP 80
76503: PUSH
76504: LD_VAR 0 2
76508: ARRAY
76509: UNION
76510: PPUSH
76511: LD_INT 33
76513: PUSH
76514: LD_INT 2
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: PPUSH
76521: CALL_OW 72
76525: NOT
76526: OR
76527: IFFALSE 76531
// continue ;
76529: GO 76436
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76531: LD_ADDR_VAR 0 9
76535: PUSH
76536: LD_EXP 58
76540: PUSH
76541: LD_VAR 0 2
76545: ARRAY
76546: PPUSH
76547: LD_INT 30
76549: PUSH
76550: LD_INT 36
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PPUSH
76557: CALL_OW 72
76561: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76562: LD_ADDR_VAR 0 10
76566: PUSH
76567: LD_EXP 77
76571: PUSH
76572: LD_VAR 0 2
76576: ARRAY
76577: PPUSH
76578: LD_INT 34
76580: PUSH
76581: LD_INT 31
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PPUSH
76588: CALL_OW 72
76592: ST_TO_ADDR
// if not cts and not mcts then
76593: LD_VAR 0 9
76597: NOT
76598: PUSH
76599: LD_VAR 0 10
76603: NOT
76604: AND
76605: IFFALSE 76609
// continue ;
76607: GO 76436
// x := cts ;
76609: LD_ADDR_VAR 0 11
76613: PUSH
76614: LD_VAR 0 9
76618: ST_TO_ADDR
// if not x then
76619: LD_VAR 0 11
76623: NOT
76624: IFFALSE 76636
// x := mcts ;
76626: LD_ADDR_VAR 0 11
76630: PUSH
76631: LD_VAR 0 10
76635: ST_TO_ADDR
// if mc_remote_driver [ i ] then
76636: LD_EXP 98
76640: PUSH
76641: LD_VAR 0 2
76645: ARRAY
76646: IFFALSE 76915
// for j in mc_remote_driver [ i ] do
76648: LD_ADDR_VAR 0 3
76652: PUSH
76653: LD_EXP 98
76657: PUSH
76658: LD_VAR 0 2
76662: ARRAY
76663: PUSH
76664: FOR_IN
76665: IFFALSE 76913
// begin if GetClass ( j ) <> 3 then
76667: LD_VAR 0 3
76671: PPUSH
76672: CALL_OW 257
76676: PUSH
76677: LD_INT 3
76679: NONEQUAL
76680: IFFALSE 76733
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76682: LD_ADDR_EXP 98
76686: PUSH
76687: LD_EXP 98
76691: PPUSH
76692: LD_VAR 0 2
76696: PPUSH
76697: LD_EXP 98
76701: PUSH
76702: LD_VAR 0 2
76706: ARRAY
76707: PUSH
76708: LD_VAR 0 3
76712: DIFF
76713: PPUSH
76714: CALL_OW 1
76718: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76719: LD_VAR 0 3
76723: PPUSH
76724: LD_INT 0
76726: PPUSH
76727: CALL_OW 109
// continue ;
76731: GO 76664
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76733: LD_VAR 0 3
76737: PPUSH
76738: CALL_OW 310
76742: NOT
76743: PUSH
76744: LD_VAR 0 3
76748: PPUSH
76749: CALL_OW 310
76753: PPUSH
76754: CALL_OW 266
76758: PUSH
76759: LD_INT 36
76761: NONEQUAL
76762: PUSH
76763: LD_VAR 0 3
76767: PPUSH
76768: CALL 53950 0 1
76772: NOT
76773: AND
76774: OR
76775: IFFALSE 76911
// begin if IsInUnit ( j ) then
76777: LD_VAR 0 3
76781: PPUSH
76782: CALL_OW 310
76786: IFFALSE 76797
// ComExitBuilding ( j ) ;
76788: LD_VAR 0 3
76792: PPUSH
76793: CALL_OW 122
// ct := 0 ;
76797: LD_ADDR_VAR 0 8
76801: PUSH
76802: LD_INT 0
76804: ST_TO_ADDR
// for k in x do
76805: LD_ADDR_VAR 0 4
76809: PUSH
76810: LD_VAR 0 11
76814: PUSH
76815: FOR_IN
76816: IFFALSE 76889
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76818: LD_VAR 0 4
76822: PPUSH
76823: CALL_OW 264
76827: PUSH
76828: LD_INT 31
76830: EQUAL
76831: PUSH
76832: LD_VAR 0 4
76836: PPUSH
76837: CALL_OW 311
76841: NOT
76842: AND
76843: PUSH
76844: LD_VAR 0 4
76848: PPUSH
76849: CALL_OW 266
76853: PUSH
76854: LD_INT 36
76856: EQUAL
76857: PUSH
76858: LD_VAR 0 4
76862: PPUSH
76863: CALL_OW 313
76867: PUSH
76868: LD_INT 3
76870: LESS
76871: AND
76872: OR
76873: IFFALSE 76887
// begin ct := k ;
76875: LD_ADDR_VAR 0 8
76879: PUSH
76880: LD_VAR 0 4
76884: ST_TO_ADDR
// break ;
76885: GO 76889
// end ;
76887: GO 76815
76889: POP
76890: POP
// if ct then
76891: LD_VAR 0 8
76895: IFFALSE 76911
// ComEnterUnit ( j , ct ) ;
76897: LD_VAR 0 3
76901: PPUSH
76902: LD_VAR 0 8
76906: PPUSH
76907: CALL_OW 120
// end ; end ;
76911: GO 76664
76913: POP
76914: POP
// places := 0 ;
76915: LD_ADDR_VAR 0 5
76919: PUSH
76920: LD_INT 0
76922: ST_TO_ADDR
// for j = 1 to x do
76923: LD_ADDR_VAR 0 3
76927: PUSH
76928: DOUBLE
76929: LD_INT 1
76931: DEC
76932: ST_TO_ADDR
76933: LD_VAR 0 11
76937: PUSH
76938: FOR_TO
76939: IFFALSE 76994
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76941: LD_VAR 0 11
76945: PUSH
76946: LD_VAR 0 3
76950: ARRAY
76951: PPUSH
76952: CALL_OW 264
76956: PUSH
76957: LD_INT 31
76959: EQUAL
76960: IFFALSE 76978
// places := places + 1 else
76962: LD_ADDR_VAR 0 5
76966: PUSH
76967: LD_VAR 0 5
76971: PUSH
76972: LD_INT 1
76974: PLUS
76975: ST_TO_ADDR
76976: GO 76992
// places := places + 3 ;
76978: LD_ADDR_VAR 0 5
76982: PUSH
76983: LD_VAR 0 5
76987: PUSH
76988: LD_INT 3
76990: PLUS
76991: ST_TO_ADDR
76992: GO 76938
76994: POP
76995: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76996: LD_ADDR_VAR 0 6
77000: PUSH
77001: LD_EXP 58
77005: PUSH
77006: LD_VAR 0 2
77010: ARRAY
77011: PPUSH
77012: LD_INT 25
77014: PUSH
77015: LD_INT 3
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PPUSH
77022: CALL_OW 72
77026: PUSH
77027: LD_EXP 98
77031: PUSH
77032: LD_VAR 0 2
77036: ARRAY
77037: DIFF
77038: PPUSH
77039: LD_INT 3
77041: PPUSH
77042: CALL 54850 0 2
77046: ST_TO_ADDR
// if not tmp then
77047: LD_VAR 0 6
77051: NOT
77052: IFFALSE 77056
// continue ;
77054: GO 76436
// places := places - mc_remote_driver [ i ] ;
77056: LD_ADDR_VAR 0 5
77060: PUSH
77061: LD_VAR 0 5
77065: PUSH
77066: LD_EXP 98
77070: PUSH
77071: LD_VAR 0 2
77075: ARRAY
77076: MINUS
77077: ST_TO_ADDR
// if places then
77078: LD_VAR 0 5
77082: IFFALSE 77141
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77084: LD_ADDR_EXP 98
77088: PUSH
77089: LD_EXP 98
77093: PPUSH
77094: LD_VAR 0 2
77098: PPUSH
77099: LD_EXP 98
77103: PUSH
77104: LD_VAR 0 2
77108: ARRAY
77109: PUSH
77110: LD_VAR 0 6
77114: PUSH
77115: LD_INT 1
77117: ARRAY
77118: UNION
77119: PPUSH
77120: CALL_OW 1
77124: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77125: LD_VAR 0 6
77129: PUSH
77130: LD_INT 1
77132: ARRAY
77133: PPUSH
77134: LD_INT 126
77136: PPUSH
77137: CALL_OW 109
// end ; end ;
77141: GO 76436
77143: POP
77144: POP
// end ;
77145: LD_VAR 0 1
77149: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77150: LD_INT 0
77152: PPUSH
77153: PPUSH
77154: PPUSH
77155: PPUSH
77156: PPUSH
77157: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77158: LD_VAR 0 1
77162: NOT
77163: PUSH
77164: LD_VAR 0 2
77168: NOT
77169: OR
77170: PUSH
77171: LD_VAR 0 3
77175: NOT
77176: OR
77177: PUSH
77178: LD_VAR 0 4
77182: PUSH
77183: LD_INT 1
77185: PUSH
77186: LD_INT 2
77188: PUSH
77189: LD_INT 3
77191: PUSH
77192: LD_INT 4
77194: PUSH
77195: LD_INT 5
77197: PUSH
77198: LD_INT 8
77200: PUSH
77201: LD_INT 9
77203: PUSH
77204: LD_INT 15
77206: PUSH
77207: LD_INT 16
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: IN
77221: NOT
77222: OR
77223: IFFALSE 77227
// exit ;
77225: GO 78127
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77227: LD_ADDR_VAR 0 2
77231: PUSH
77232: LD_VAR 0 2
77236: PPUSH
77237: LD_INT 21
77239: PUSH
77240: LD_INT 3
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: LD_INT 24
77249: PUSH
77250: LD_INT 250
77252: PUSH
77253: EMPTY
77254: LIST
77255: LIST
77256: PUSH
77257: EMPTY
77258: LIST
77259: LIST
77260: PPUSH
77261: CALL_OW 72
77265: ST_TO_ADDR
// case class of 1 , 15 :
77266: LD_VAR 0 4
77270: PUSH
77271: LD_INT 1
77273: DOUBLE
77274: EQUAL
77275: IFTRUE 77285
77277: LD_INT 15
77279: DOUBLE
77280: EQUAL
77281: IFTRUE 77285
77283: GO 77370
77285: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77286: LD_ADDR_VAR 0 8
77290: PUSH
77291: LD_VAR 0 2
77295: PPUSH
77296: LD_INT 2
77298: PUSH
77299: LD_INT 30
77301: PUSH
77302: LD_INT 32
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: PUSH
77309: LD_INT 30
77311: PUSH
77312: LD_INT 31
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: LIST
77323: PPUSH
77324: CALL_OW 72
77328: PUSH
77329: LD_VAR 0 2
77333: PPUSH
77334: LD_INT 2
77336: PUSH
77337: LD_INT 30
77339: PUSH
77340: LD_INT 4
77342: PUSH
77343: EMPTY
77344: LIST
77345: LIST
77346: PUSH
77347: LD_INT 30
77349: PUSH
77350: LD_INT 5
77352: PUSH
77353: EMPTY
77354: LIST
77355: LIST
77356: PUSH
77357: EMPTY
77358: LIST
77359: LIST
77360: LIST
77361: PPUSH
77362: CALL_OW 72
77366: ADD
77367: ST_TO_ADDR
77368: GO 77616
77370: LD_INT 2
77372: DOUBLE
77373: EQUAL
77374: IFTRUE 77384
77376: LD_INT 16
77378: DOUBLE
77379: EQUAL
77380: IFTRUE 77384
77382: GO 77430
77384: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77385: LD_ADDR_VAR 0 8
77389: PUSH
77390: LD_VAR 0 2
77394: PPUSH
77395: LD_INT 2
77397: PUSH
77398: LD_INT 30
77400: PUSH
77401: LD_INT 0
77403: PUSH
77404: EMPTY
77405: LIST
77406: LIST
77407: PUSH
77408: LD_INT 30
77410: PUSH
77411: LD_INT 1
77413: PUSH
77414: EMPTY
77415: LIST
77416: LIST
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: LIST
77422: PPUSH
77423: CALL_OW 72
77427: ST_TO_ADDR
77428: GO 77616
77430: LD_INT 3
77432: DOUBLE
77433: EQUAL
77434: IFTRUE 77438
77436: GO 77484
77438: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77439: LD_ADDR_VAR 0 8
77443: PUSH
77444: LD_VAR 0 2
77448: PPUSH
77449: LD_INT 2
77451: PUSH
77452: LD_INT 30
77454: PUSH
77455: LD_INT 2
77457: PUSH
77458: EMPTY
77459: LIST
77460: LIST
77461: PUSH
77462: LD_INT 30
77464: PUSH
77465: LD_INT 3
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: LIST
77476: PPUSH
77477: CALL_OW 72
77481: ST_TO_ADDR
77482: GO 77616
77484: LD_INT 4
77486: DOUBLE
77487: EQUAL
77488: IFTRUE 77492
77490: GO 77549
77492: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77493: LD_ADDR_VAR 0 8
77497: PUSH
77498: LD_VAR 0 2
77502: PPUSH
77503: LD_INT 2
77505: PUSH
77506: LD_INT 30
77508: PUSH
77509: LD_INT 6
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 30
77518: PUSH
77519: LD_INT 7
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 30
77528: PUSH
77529: LD_INT 8
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: LIST
77540: LIST
77541: PPUSH
77542: CALL_OW 72
77546: ST_TO_ADDR
77547: GO 77616
77549: LD_INT 5
77551: DOUBLE
77552: EQUAL
77553: IFTRUE 77569
77555: LD_INT 8
77557: DOUBLE
77558: EQUAL
77559: IFTRUE 77569
77561: LD_INT 9
77563: DOUBLE
77564: EQUAL
77565: IFTRUE 77569
77567: GO 77615
77569: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77570: LD_ADDR_VAR 0 8
77574: PUSH
77575: LD_VAR 0 2
77579: PPUSH
77580: LD_INT 2
77582: PUSH
77583: LD_INT 30
77585: PUSH
77586: LD_INT 4
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 30
77595: PUSH
77596: LD_INT 5
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: LIST
77607: PPUSH
77608: CALL_OW 72
77612: ST_TO_ADDR
77613: GO 77616
77615: POP
// if not tmp then
77616: LD_VAR 0 8
77620: NOT
77621: IFFALSE 77625
// exit ;
77623: GO 78127
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77625: LD_VAR 0 4
77629: PUSH
77630: LD_INT 1
77632: PUSH
77633: LD_INT 15
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: IN
77640: PUSH
77641: LD_EXP 67
77645: PUSH
77646: LD_VAR 0 1
77650: ARRAY
77651: AND
77652: IFFALSE 77808
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77654: LD_ADDR_VAR 0 9
77658: PUSH
77659: LD_EXP 67
77663: PUSH
77664: LD_VAR 0 1
77668: ARRAY
77669: PUSH
77670: LD_INT 1
77672: ARRAY
77673: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77674: LD_VAR 0 9
77678: PUSH
77679: LD_EXP 68
77683: PUSH
77684: LD_VAR 0 1
77688: ARRAY
77689: IN
77690: NOT
77691: IFFALSE 77806
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77693: LD_ADDR_EXP 68
77697: PUSH
77698: LD_EXP 68
77702: PPUSH
77703: LD_VAR 0 1
77707: PUSH
77708: LD_EXP 68
77712: PUSH
77713: LD_VAR 0 1
77717: ARRAY
77718: PUSH
77719: LD_INT 1
77721: PLUS
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PPUSH
77727: LD_VAR 0 9
77731: PPUSH
77732: CALL 20665 0 3
77736: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77737: LD_ADDR_EXP 67
77741: PUSH
77742: LD_EXP 67
77746: PPUSH
77747: LD_VAR 0 1
77751: PPUSH
77752: LD_EXP 67
77756: PUSH
77757: LD_VAR 0 1
77761: ARRAY
77762: PUSH
77763: LD_VAR 0 9
77767: DIFF
77768: PPUSH
77769: CALL_OW 1
77773: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77774: LD_VAR 0 3
77778: PPUSH
77779: LD_EXP 68
77783: PUSH
77784: LD_VAR 0 1
77788: ARRAY
77789: PUSH
77790: LD_EXP 68
77794: PUSH
77795: LD_VAR 0 1
77799: ARRAY
77800: ARRAY
77801: PPUSH
77802: CALL_OW 120
// end ; exit ;
77806: GO 78127
// end ; if tmp > 1 then
77808: LD_VAR 0 8
77812: PUSH
77813: LD_INT 1
77815: GREATER
77816: IFFALSE 77920
// for i = 2 to tmp do
77818: LD_ADDR_VAR 0 6
77822: PUSH
77823: DOUBLE
77824: LD_INT 2
77826: DEC
77827: ST_TO_ADDR
77828: LD_VAR 0 8
77832: PUSH
77833: FOR_TO
77834: IFFALSE 77918
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77836: LD_VAR 0 8
77840: PUSH
77841: LD_VAR 0 6
77845: ARRAY
77846: PPUSH
77847: CALL_OW 461
77851: PUSH
77852: LD_INT 6
77854: EQUAL
77855: IFFALSE 77916
// begin x := tmp [ i ] ;
77857: LD_ADDR_VAR 0 9
77861: PUSH
77862: LD_VAR 0 8
77866: PUSH
77867: LD_VAR 0 6
77871: ARRAY
77872: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77873: LD_ADDR_VAR 0 8
77877: PUSH
77878: LD_VAR 0 8
77882: PPUSH
77883: LD_VAR 0 6
77887: PPUSH
77888: CALL_OW 3
77892: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77893: LD_ADDR_VAR 0 8
77897: PUSH
77898: LD_VAR 0 8
77902: PPUSH
77903: LD_INT 1
77905: PPUSH
77906: LD_VAR 0 9
77910: PPUSH
77911: CALL_OW 2
77915: ST_TO_ADDR
// end ;
77916: GO 77833
77918: POP
77919: POP
// for i in tmp do
77920: LD_ADDR_VAR 0 6
77924: PUSH
77925: LD_VAR 0 8
77929: PUSH
77930: FOR_IN
77931: IFFALSE 78000
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77933: LD_VAR 0 6
77937: PPUSH
77938: CALL_OW 313
77942: PUSH
77943: LD_INT 6
77945: LESS
77946: PUSH
77947: LD_VAR 0 6
77951: PPUSH
77952: CALL_OW 266
77956: PUSH
77957: LD_INT 31
77959: PUSH
77960: LD_INT 32
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: IN
77967: NOT
77968: AND
77969: PUSH
77970: LD_VAR 0 6
77974: PPUSH
77975: CALL_OW 313
77979: PUSH
77980: LD_INT 0
77982: EQUAL
77983: OR
77984: IFFALSE 77998
// begin j := i ;
77986: LD_ADDR_VAR 0 7
77990: PUSH
77991: LD_VAR 0 6
77995: ST_TO_ADDR
// break ;
77996: GO 78000
// end ; end ;
77998: GO 77930
78000: POP
78001: POP
// if j then
78002: LD_VAR 0 7
78006: IFFALSE 78024
// ComEnterUnit ( unit , j ) else
78008: LD_VAR 0 3
78012: PPUSH
78013: LD_VAR 0 7
78017: PPUSH
78018: CALL_OW 120
78022: GO 78127
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78024: LD_ADDR_VAR 0 10
78028: PUSH
78029: LD_VAR 0 2
78033: PPUSH
78034: LD_INT 2
78036: PUSH
78037: LD_INT 30
78039: PUSH
78040: LD_INT 0
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: PUSH
78047: LD_INT 30
78049: PUSH
78050: LD_INT 1
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: LIST
78061: PPUSH
78062: CALL_OW 72
78066: ST_TO_ADDR
// if depot then
78067: LD_VAR 0 10
78071: IFFALSE 78127
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78073: LD_ADDR_VAR 0 10
78077: PUSH
78078: LD_VAR 0 10
78082: PPUSH
78083: LD_VAR 0 3
78087: PPUSH
78088: CALL_OW 74
78092: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78093: LD_VAR 0 3
78097: PPUSH
78098: LD_VAR 0 10
78102: PPUSH
78103: CALL_OW 296
78107: PUSH
78108: LD_INT 10
78110: GREATER
78111: IFFALSE 78127
// ComStandNearbyBuilding ( unit , depot ) ;
78113: LD_VAR 0 3
78117: PPUSH
78118: LD_VAR 0 10
78122: PPUSH
78123: CALL 15342 0 2
// end ; end ; end ;
78127: LD_VAR 0 5
78131: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78132: LD_INT 0
78134: PPUSH
78135: PPUSH
78136: PPUSH
78137: PPUSH
// if not mc_bases then
78138: LD_EXP 58
78142: NOT
78143: IFFALSE 78147
// exit ;
78145: GO 78386
// for i = 1 to mc_bases do
78147: LD_ADDR_VAR 0 2
78151: PUSH
78152: DOUBLE
78153: LD_INT 1
78155: DEC
78156: ST_TO_ADDR
78157: LD_EXP 58
78161: PUSH
78162: FOR_TO
78163: IFFALSE 78384
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78165: LD_ADDR_VAR 0 4
78169: PUSH
78170: LD_EXP 58
78174: PUSH
78175: LD_VAR 0 2
78179: ARRAY
78180: PPUSH
78181: LD_INT 21
78183: PUSH
78184: LD_INT 1
78186: PUSH
78187: EMPTY
78188: LIST
78189: LIST
78190: PPUSH
78191: CALL_OW 72
78195: PUSH
78196: LD_EXP 87
78200: PUSH
78201: LD_VAR 0 2
78205: ARRAY
78206: UNION
78207: ST_TO_ADDR
// if not tmp then
78208: LD_VAR 0 4
78212: NOT
78213: IFFALSE 78217
// continue ;
78215: GO 78162
// for j in tmp do
78217: LD_ADDR_VAR 0 3
78221: PUSH
78222: LD_VAR 0 4
78226: PUSH
78227: FOR_IN
78228: IFFALSE 78380
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78230: LD_VAR 0 3
78234: PPUSH
78235: CALL_OW 110
78239: NOT
78240: PUSH
78241: LD_VAR 0 3
78245: PPUSH
78246: CALL_OW 314
78250: NOT
78251: AND
78252: PUSH
78253: LD_VAR 0 3
78257: PPUSH
78258: CALL_OW 311
78262: NOT
78263: AND
78264: PUSH
78265: LD_VAR 0 3
78269: PPUSH
78270: CALL_OW 310
78274: NOT
78275: AND
78276: PUSH
78277: LD_VAR 0 3
78281: PUSH
78282: LD_EXP 61
78286: PUSH
78287: LD_VAR 0 2
78291: ARRAY
78292: PUSH
78293: LD_INT 1
78295: ARRAY
78296: IN
78297: NOT
78298: AND
78299: PUSH
78300: LD_VAR 0 3
78304: PUSH
78305: LD_EXP 61
78309: PUSH
78310: LD_VAR 0 2
78314: ARRAY
78315: PUSH
78316: LD_INT 2
78318: ARRAY
78319: IN
78320: NOT
78321: AND
78322: PUSH
78323: LD_VAR 0 3
78327: PUSH
78328: LD_EXP 70
78332: PUSH
78333: LD_VAR 0 2
78337: ARRAY
78338: IN
78339: NOT
78340: AND
78341: IFFALSE 78378
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78343: LD_VAR 0 2
78347: PPUSH
78348: LD_EXP 58
78352: PUSH
78353: LD_VAR 0 2
78357: ARRAY
78358: PPUSH
78359: LD_VAR 0 3
78363: PPUSH
78364: LD_VAR 0 3
78368: PPUSH
78369: CALL_OW 257
78373: PPUSH
78374: CALL 77150 0 4
// end ;
78378: GO 78227
78380: POP
78381: POP
// end ;
78382: GO 78162
78384: POP
78385: POP
// end ;
78386: LD_VAR 0 1
78390: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78391: LD_INT 0
78393: PPUSH
78394: PPUSH
78395: PPUSH
78396: PPUSH
78397: PPUSH
78398: PPUSH
// if not mc_bases [ base ] then
78399: LD_EXP 58
78403: PUSH
78404: LD_VAR 0 1
78408: ARRAY
78409: NOT
78410: IFFALSE 78414
// exit ;
78412: GO 78596
// tmp := [ ] ;
78414: LD_ADDR_VAR 0 6
78418: PUSH
78419: EMPTY
78420: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78421: LD_ADDR_VAR 0 7
78425: PUSH
78426: LD_VAR 0 3
78430: PPUSH
78431: LD_INT 0
78433: PPUSH
78434: CALL_OW 517
78438: ST_TO_ADDR
// if not list then
78439: LD_VAR 0 7
78443: NOT
78444: IFFALSE 78448
// exit ;
78446: GO 78596
// for i = 1 to amount do
78448: LD_ADDR_VAR 0 5
78452: PUSH
78453: DOUBLE
78454: LD_INT 1
78456: DEC
78457: ST_TO_ADDR
78458: LD_VAR 0 2
78462: PUSH
78463: FOR_TO
78464: IFFALSE 78544
// begin x := rand ( 1 , list [ 1 ] ) ;
78466: LD_ADDR_VAR 0 8
78470: PUSH
78471: LD_INT 1
78473: PPUSH
78474: LD_VAR 0 7
78478: PUSH
78479: LD_INT 1
78481: ARRAY
78482: PPUSH
78483: CALL_OW 12
78487: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78488: LD_ADDR_VAR 0 6
78492: PUSH
78493: LD_VAR 0 6
78497: PPUSH
78498: LD_VAR 0 5
78502: PPUSH
78503: LD_VAR 0 7
78507: PUSH
78508: LD_INT 1
78510: ARRAY
78511: PUSH
78512: LD_VAR 0 8
78516: ARRAY
78517: PUSH
78518: LD_VAR 0 7
78522: PUSH
78523: LD_INT 2
78525: ARRAY
78526: PUSH
78527: LD_VAR 0 8
78531: ARRAY
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PPUSH
78537: CALL_OW 1
78541: ST_TO_ADDR
// end ;
78542: GO 78463
78544: POP
78545: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78546: LD_ADDR_EXP 71
78550: PUSH
78551: LD_EXP 71
78555: PPUSH
78556: LD_VAR 0 1
78560: PPUSH
78561: LD_VAR 0 6
78565: PPUSH
78566: CALL_OW 1
78570: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78571: LD_ADDR_EXP 73
78575: PUSH
78576: LD_EXP 73
78580: PPUSH
78581: LD_VAR 0 1
78585: PPUSH
78586: LD_VAR 0 3
78590: PPUSH
78591: CALL_OW 1
78595: ST_TO_ADDR
// end ;
78596: LD_VAR 0 4
78600: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78601: LD_INT 0
78603: PPUSH
// if not mc_bases [ base ] then
78604: LD_EXP 58
78608: PUSH
78609: LD_VAR 0 1
78613: ARRAY
78614: NOT
78615: IFFALSE 78619
// exit ;
78617: GO 78644
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78619: LD_ADDR_EXP 63
78623: PUSH
78624: LD_EXP 63
78628: PPUSH
78629: LD_VAR 0 1
78633: PPUSH
78634: LD_VAR 0 2
78638: PPUSH
78639: CALL_OW 1
78643: ST_TO_ADDR
// end ;
78644: LD_VAR 0 3
78648: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78649: LD_INT 0
78651: PPUSH
// if not mc_bases [ base ] then
78652: LD_EXP 58
78656: PUSH
78657: LD_VAR 0 1
78661: ARRAY
78662: NOT
78663: IFFALSE 78667
// exit ;
78665: GO 78704
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78667: LD_ADDR_EXP 63
78671: PUSH
78672: LD_EXP 63
78676: PPUSH
78677: LD_VAR 0 1
78681: PPUSH
78682: LD_EXP 63
78686: PUSH
78687: LD_VAR 0 1
78691: ARRAY
78692: PUSH
78693: LD_VAR 0 2
78697: UNION
78698: PPUSH
78699: CALL_OW 1
78703: ST_TO_ADDR
// end ;
78704: LD_VAR 0 3
78708: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78709: LD_INT 0
78711: PPUSH
// if not mc_bases [ base ] then
78712: LD_EXP 58
78716: PUSH
78717: LD_VAR 0 1
78721: ARRAY
78722: NOT
78723: IFFALSE 78727
// exit ;
78725: GO 78752
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78727: LD_ADDR_EXP 79
78731: PUSH
78732: LD_EXP 79
78736: PPUSH
78737: LD_VAR 0 1
78741: PPUSH
78742: LD_VAR 0 2
78746: PPUSH
78747: CALL_OW 1
78751: ST_TO_ADDR
// end ;
78752: LD_VAR 0 3
78756: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78757: LD_INT 0
78759: PPUSH
// if not mc_bases [ base ] then
78760: LD_EXP 58
78764: PUSH
78765: LD_VAR 0 1
78769: ARRAY
78770: NOT
78771: IFFALSE 78775
// exit ;
78773: GO 78812
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78775: LD_ADDR_EXP 79
78779: PUSH
78780: LD_EXP 79
78784: PPUSH
78785: LD_VAR 0 1
78789: PPUSH
78790: LD_EXP 79
78794: PUSH
78795: LD_VAR 0 1
78799: ARRAY
78800: PUSH
78801: LD_VAR 0 2
78805: ADD
78806: PPUSH
78807: CALL_OW 1
78811: ST_TO_ADDR
// end ;
78812: LD_VAR 0 3
78816: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78817: LD_INT 0
78819: PPUSH
// if not mc_bases [ base ] then
78820: LD_EXP 58
78824: PUSH
78825: LD_VAR 0 1
78829: ARRAY
78830: NOT
78831: IFFALSE 78835
// exit ;
78833: GO 78889
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78835: LD_ADDR_EXP 80
78839: PUSH
78840: LD_EXP 80
78844: PPUSH
78845: LD_VAR 0 1
78849: PPUSH
78850: LD_VAR 0 2
78854: PPUSH
78855: CALL_OW 1
78859: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78860: LD_ADDR_EXP 69
78864: PUSH
78865: LD_EXP 69
78869: PPUSH
78870: LD_VAR 0 1
78874: PPUSH
78875: LD_VAR 0 2
78879: PUSH
78880: LD_INT 0
78882: PLUS
78883: PPUSH
78884: CALL_OW 1
78888: ST_TO_ADDR
// end ;
78889: LD_VAR 0 3
78893: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78894: LD_INT 0
78896: PPUSH
// if not mc_bases [ base ] then
78897: LD_EXP 58
78901: PUSH
78902: LD_VAR 0 1
78906: ARRAY
78907: NOT
78908: IFFALSE 78912
// exit ;
78910: GO 78937
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78912: LD_ADDR_EXP 69
78916: PUSH
78917: LD_EXP 69
78921: PPUSH
78922: LD_VAR 0 1
78926: PPUSH
78927: LD_VAR 0 2
78931: PPUSH
78932: CALL_OW 1
78936: ST_TO_ADDR
// end ;
78937: LD_VAR 0 3
78941: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78942: LD_INT 0
78944: PPUSH
78945: PPUSH
78946: PPUSH
78947: PPUSH
// if not mc_bases [ base ] then
78948: LD_EXP 58
78952: PUSH
78953: LD_VAR 0 1
78957: ARRAY
78958: NOT
78959: IFFALSE 78963
// exit ;
78961: GO 79028
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78963: LD_ADDR_EXP 78
78967: PUSH
78968: LD_EXP 78
78972: PPUSH
78973: LD_VAR 0 1
78977: PUSH
78978: LD_EXP 78
78982: PUSH
78983: LD_VAR 0 1
78987: ARRAY
78988: PUSH
78989: LD_INT 1
78991: PLUS
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: PPUSH
78997: LD_VAR 0 1
79001: PUSH
79002: LD_VAR 0 2
79006: PUSH
79007: LD_VAR 0 3
79011: PUSH
79012: LD_VAR 0 4
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: PPUSH
79023: CALL 20665 0 3
79027: ST_TO_ADDR
// end ;
79028: LD_VAR 0 5
79032: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79033: LD_INT 0
79035: PPUSH
// if not mc_bases [ base ] then
79036: LD_EXP 58
79040: PUSH
79041: LD_VAR 0 1
79045: ARRAY
79046: NOT
79047: IFFALSE 79051
// exit ;
79049: GO 79076
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79051: LD_ADDR_EXP 95
79055: PUSH
79056: LD_EXP 95
79060: PPUSH
79061: LD_VAR 0 1
79065: PPUSH
79066: LD_VAR 0 2
79070: PPUSH
79071: CALL_OW 1
79075: ST_TO_ADDR
// end ;
79076: LD_VAR 0 3
79080: RET
// export function MC_GetMinesField ( base ) ; begin
79081: LD_INT 0
79083: PPUSH
// result := mc_mines [ base ] ;
79084: LD_ADDR_VAR 0 2
79088: PUSH
79089: LD_EXP 71
79093: PUSH
79094: LD_VAR 0 1
79098: ARRAY
79099: ST_TO_ADDR
// end ;
79100: LD_VAR 0 2
79104: RET
// export function MC_GetProduceList ( base ) ; begin
79105: LD_INT 0
79107: PPUSH
// result := mc_produce [ base ] ;
79108: LD_ADDR_VAR 0 2
79112: PUSH
79113: LD_EXP 79
79117: PUSH
79118: LD_VAR 0 1
79122: ARRAY
79123: ST_TO_ADDR
// end ;
79124: LD_VAR 0 2
79128: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79129: LD_INT 0
79131: PPUSH
79132: PPUSH
// if not mc_bases then
79133: LD_EXP 58
79137: NOT
79138: IFFALSE 79142
// exit ;
79140: GO 79207
// if mc_bases [ base ] then
79142: LD_EXP 58
79146: PUSH
79147: LD_VAR 0 1
79151: ARRAY
79152: IFFALSE 79207
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79154: LD_ADDR_VAR 0 3
79158: PUSH
79159: LD_EXP 58
79163: PUSH
79164: LD_VAR 0 1
79168: ARRAY
79169: PPUSH
79170: LD_INT 30
79172: PUSH
79173: LD_VAR 0 2
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PPUSH
79182: CALL_OW 72
79186: ST_TO_ADDR
// if result then
79187: LD_VAR 0 3
79191: IFFALSE 79207
// result := result [ 1 ] ;
79193: LD_ADDR_VAR 0 3
79197: PUSH
79198: LD_VAR 0 3
79202: PUSH
79203: LD_INT 1
79205: ARRAY
79206: ST_TO_ADDR
// end ; end ;
79207: LD_VAR 0 3
79211: RET
// export function MC_SetTame ( base , area ) ; begin
79212: LD_INT 0
79214: PPUSH
// if not mc_bases or not base then
79215: LD_EXP 58
79219: NOT
79220: PUSH
79221: LD_VAR 0 1
79225: NOT
79226: OR
79227: IFFALSE 79231
// exit ;
79229: GO 79256
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79231: LD_ADDR_EXP 86
79235: PUSH
79236: LD_EXP 86
79240: PPUSH
79241: LD_VAR 0 1
79245: PPUSH
79246: LD_VAR 0 2
79250: PPUSH
79251: CALL_OW 1
79255: ST_TO_ADDR
// end ;
79256: LD_VAR 0 3
79260: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79261: LD_INT 0
79263: PPUSH
79264: PPUSH
// if not mc_bases or not base then
79265: LD_EXP 58
79269: NOT
79270: PUSH
79271: LD_VAR 0 1
79275: NOT
79276: OR
79277: IFFALSE 79281
// exit ;
79279: GO 79383
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79281: LD_ADDR_VAR 0 4
79285: PUSH
79286: LD_EXP 58
79290: PUSH
79291: LD_VAR 0 1
79295: ARRAY
79296: PPUSH
79297: LD_INT 30
79299: PUSH
79300: LD_VAR 0 2
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PPUSH
79309: CALL_OW 72
79313: ST_TO_ADDR
// if not tmp then
79314: LD_VAR 0 4
79318: NOT
79319: IFFALSE 79323
// exit ;
79321: GO 79383
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79323: LD_ADDR_EXP 90
79327: PUSH
79328: LD_EXP 90
79332: PPUSH
79333: LD_VAR 0 1
79337: PPUSH
79338: LD_EXP 90
79342: PUSH
79343: LD_VAR 0 1
79347: ARRAY
79348: PPUSH
79349: LD_EXP 90
79353: PUSH
79354: LD_VAR 0 1
79358: ARRAY
79359: PUSH
79360: LD_INT 1
79362: PLUS
79363: PPUSH
79364: LD_VAR 0 4
79368: PUSH
79369: LD_INT 1
79371: ARRAY
79372: PPUSH
79373: CALL_OW 2
79377: PPUSH
79378: CALL_OW 1
79382: ST_TO_ADDR
// end ;
79383: LD_VAR 0 3
79387: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79388: LD_INT 0
79390: PPUSH
79391: PPUSH
// if not mc_bases or not base or not kinds then
79392: LD_EXP 58
79396: NOT
79397: PUSH
79398: LD_VAR 0 1
79402: NOT
79403: OR
79404: PUSH
79405: LD_VAR 0 2
79409: NOT
79410: OR
79411: IFFALSE 79415
// exit ;
79413: GO 79476
// for i in kinds do
79415: LD_ADDR_VAR 0 4
79419: PUSH
79420: LD_VAR 0 2
79424: PUSH
79425: FOR_IN
79426: IFFALSE 79474
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79428: LD_ADDR_EXP 92
79432: PUSH
79433: LD_EXP 92
79437: PPUSH
79438: LD_VAR 0 1
79442: PUSH
79443: LD_EXP 92
79447: PUSH
79448: LD_VAR 0 1
79452: ARRAY
79453: PUSH
79454: LD_INT 1
79456: PLUS
79457: PUSH
79458: EMPTY
79459: LIST
79460: LIST
79461: PPUSH
79462: LD_VAR 0 4
79466: PPUSH
79467: CALL 20665 0 3
79471: ST_TO_ADDR
79472: GO 79425
79474: POP
79475: POP
// end ;
79476: LD_VAR 0 3
79480: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79481: LD_INT 0
79483: PPUSH
// if not mc_bases or not base or not areas then
79484: LD_EXP 58
79488: NOT
79489: PUSH
79490: LD_VAR 0 1
79494: NOT
79495: OR
79496: PUSH
79497: LD_VAR 0 2
79501: NOT
79502: OR
79503: IFFALSE 79507
// exit ;
79505: GO 79532
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79507: LD_ADDR_EXP 76
79511: PUSH
79512: LD_EXP 76
79516: PPUSH
79517: LD_VAR 0 1
79521: PPUSH
79522: LD_VAR 0 2
79526: PPUSH
79527: CALL_OW 1
79531: ST_TO_ADDR
// end ;
79532: LD_VAR 0 3
79536: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79537: LD_INT 0
79539: PPUSH
// if not mc_bases or not base or not teleports_exit then
79540: LD_EXP 58
79544: NOT
79545: PUSH
79546: LD_VAR 0 1
79550: NOT
79551: OR
79552: PUSH
79553: LD_VAR 0 2
79557: NOT
79558: OR
79559: IFFALSE 79563
// exit ;
79561: GO 79588
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79563: LD_ADDR_EXP 93
79567: PUSH
79568: LD_EXP 93
79572: PPUSH
79573: LD_VAR 0 1
79577: PPUSH
79578: LD_VAR 0 2
79582: PPUSH
79583: CALL_OW 1
79587: ST_TO_ADDR
// end ;
79588: LD_VAR 0 3
79592: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79593: LD_INT 0
79595: PPUSH
79596: PPUSH
79597: PPUSH
// if not mc_bases or not base or not ext_list then
79598: LD_EXP 58
79602: NOT
79603: PUSH
79604: LD_VAR 0 1
79608: NOT
79609: OR
79610: PUSH
79611: LD_VAR 0 5
79615: NOT
79616: OR
79617: IFFALSE 79621
// exit ;
79619: GO 79794
// tmp := GetFacExtXYD ( x , y , d ) ;
79621: LD_ADDR_VAR 0 8
79625: PUSH
79626: LD_VAR 0 2
79630: PPUSH
79631: LD_VAR 0 3
79635: PPUSH
79636: LD_VAR 0 4
79640: PPUSH
79641: CALL 53980 0 3
79645: ST_TO_ADDR
// if not tmp then
79646: LD_VAR 0 8
79650: NOT
79651: IFFALSE 79655
// exit ;
79653: GO 79794
// for i in tmp do
79655: LD_ADDR_VAR 0 7
79659: PUSH
79660: LD_VAR 0 8
79664: PUSH
79665: FOR_IN
79666: IFFALSE 79792
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79668: LD_ADDR_EXP 63
79672: PUSH
79673: LD_EXP 63
79677: PPUSH
79678: LD_VAR 0 1
79682: PPUSH
79683: LD_EXP 63
79687: PUSH
79688: LD_VAR 0 1
79692: ARRAY
79693: PPUSH
79694: LD_EXP 63
79698: PUSH
79699: LD_VAR 0 1
79703: ARRAY
79704: PUSH
79705: LD_INT 1
79707: PLUS
79708: PPUSH
79709: LD_VAR 0 5
79713: PUSH
79714: LD_INT 1
79716: ARRAY
79717: PUSH
79718: LD_VAR 0 7
79722: PUSH
79723: LD_INT 1
79725: ARRAY
79726: PUSH
79727: LD_VAR 0 7
79731: PUSH
79732: LD_INT 2
79734: ARRAY
79735: PUSH
79736: LD_VAR 0 7
79740: PUSH
79741: LD_INT 3
79743: ARRAY
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: PPUSH
79751: CALL_OW 2
79755: PPUSH
79756: CALL_OW 1
79760: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79761: LD_ADDR_VAR 0 5
79765: PUSH
79766: LD_VAR 0 5
79770: PPUSH
79771: LD_INT 1
79773: PPUSH
79774: CALL_OW 3
79778: ST_TO_ADDR
// if not ext_list then
79779: LD_VAR 0 5
79783: NOT
79784: IFFALSE 79790
// exit ;
79786: POP
79787: POP
79788: GO 79794
// end ;
79790: GO 79665
79792: POP
79793: POP
// end ;
79794: LD_VAR 0 6
79798: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79799: LD_INT 0
79801: PPUSH
// if not mc_bases or not base or not weapon_list then
79802: LD_EXP 58
79806: NOT
79807: PUSH
79808: LD_VAR 0 1
79812: NOT
79813: OR
79814: PUSH
79815: LD_VAR 0 2
79819: NOT
79820: OR
79821: IFFALSE 79825
// exit ;
79823: GO 79850
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79825: LD_ADDR_EXP 97
79829: PUSH
79830: LD_EXP 97
79834: PPUSH
79835: LD_VAR 0 1
79839: PPUSH
79840: LD_VAR 0 2
79844: PPUSH
79845: CALL_OW 1
79849: ST_TO_ADDR
// end ;
79850: LD_VAR 0 3
79854: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79855: LD_INT 0
79857: PPUSH
// if not mc_bases or not base or not tech_list then
79858: LD_EXP 58
79862: NOT
79863: PUSH
79864: LD_VAR 0 1
79868: NOT
79869: OR
79870: PUSH
79871: LD_VAR 0 2
79875: NOT
79876: OR
79877: IFFALSE 79881
// exit ;
79879: GO 79906
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79881: LD_ADDR_EXP 85
79885: PUSH
79886: LD_EXP 85
79890: PPUSH
79891: LD_VAR 0 1
79895: PPUSH
79896: LD_VAR 0 2
79900: PPUSH
79901: CALL_OW 1
79905: ST_TO_ADDR
// end ;
79906: LD_VAR 0 3
79910: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79911: LD_INT 0
79913: PPUSH
// if not mc_bases or not parking_area or not base then
79914: LD_EXP 58
79918: NOT
79919: PUSH
79920: LD_VAR 0 2
79924: NOT
79925: OR
79926: PUSH
79927: LD_VAR 0 1
79931: NOT
79932: OR
79933: IFFALSE 79937
// exit ;
79935: GO 79962
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79937: LD_ADDR_EXP 82
79941: PUSH
79942: LD_EXP 82
79946: PPUSH
79947: LD_VAR 0 1
79951: PPUSH
79952: LD_VAR 0 2
79956: PPUSH
79957: CALL_OW 1
79961: ST_TO_ADDR
// end ;
79962: LD_VAR 0 3
79966: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79967: LD_INT 0
79969: PPUSH
// if not mc_bases or not base or not scan_area then
79970: LD_EXP 58
79974: NOT
79975: PUSH
79976: LD_VAR 0 1
79980: NOT
79981: OR
79982: PUSH
79983: LD_VAR 0 2
79987: NOT
79988: OR
79989: IFFALSE 79993
// exit ;
79991: GO 80018
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79993: LD_ADDR_EXP 83
79997: PUSH
79998: LD_EXP 83
80002: PPUSH
80003: LD_VAR 0 1
80007: PPUSH
80008: LD_VAR 0 2
80012: PPUSH
80013: CALL_OW 1
80017: ST_TO_ADDR
// end ;
80018: LD_VAR 0 3
80022: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80023: LD_INT 0
80025: PPUSH
80026: PPUSH
// if not mc_bases or not base then
80027: LD_EXP 58
80031: NOT
80032: PUSH
80033: LD_VAR 0 1
80037: NOT
80038: OR
80039: IFFALSE 80043
// exit ;
80041: GO 80107
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80043: LD_ADDR_VAR 0 3
80047: PUSH
80048: LD_INT 1
80050: PUSH
80051: LD_INT 2
80053: PUSH
80054: LD_INT 3
80056: PUSH
80057: LD_INT 4
80059: PUSH
80060: LD_INT 11
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80070: LD_ADDR_EXP 85
80074: PUSH
80075: LD_EXP 85
80079: PPUSH
80080: LD_VAR 0 1
80084: PPUSH
80085: LD_EXP 85
80089: PUSH
80090: LD_VAR 0 1
80094: ARRAY
80095: PUSH
80096: LD_VAR 0 3
80100: DIFF
80101: PPUSH
80102: CALL_OW 1
80106: ST_TO_ADDR
// end ;
80107: LD_VAR 0 2
80111: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80112: LD_INT 0
80114: PPUSH
// result := mc_vehicles [ base ] ;
80115: LD_ADDR_VAR 0 3
80119: PUSH
80120: LD_EXP 77
80124: PUSH
80125: LD_VAR 0 1
80129: ARRAY
80130: ST_TO_ADDR
// if onlyCombat then
80131: LD_VAR 0 2
80135: IFFALSE 80300
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80137: LD_ADDR_VAR 0 3
80141: PUSH
80142: LD_VAR 0 3
80146: PUSH
80147: LD_VAR 0 3
80151: PPUSH
80152: LD_INT 2
80154: PUSH
80155: LD_INT 34
80157: PUSH
80158: LD_INT 12
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: LD_INT 34
80167: PUSH
80168: LD_INT 51
80170: PUSH
80171: EMPTY
80172: LIST
80173: LIST
80174: PUSH
80175: LD_INT 34
80177: PUSH
80178: LD_EXP 102
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 34
80189: PUSH
80190: LD_INT 32
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 34
80199: PUSH
80200: LD_INT 13
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 34
80209: PUSH
80210: LD_INT 52
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 34
80219: PUSH
80220: LD_INT 14
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 34
80229: PUSH
80230: LD_INT 53
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 34
80239: PUSH
80240: LD_EXP 101
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 34
80251: PUSH
80252: LD_INT 31
80254: PUSH
80255: EMPTY
80256: LIST
80257: LIST
80258: PUSH
80259: LD_INT 34
80261: PUSH
80262: LD_INT 48
80264: PUSH
80265: EMPTY
80266: LIST
80267: LIST
80268: PUSH
80269: LD_INT 34
80271: PUSH
80272: LD_INT 8
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: EMPTY
80280: LIST
80281: LIST
80282: LIST
80283: LIST
80284: LIST
80285: LIST
80286: LIST
80287: LIST
80288: LIST
80289: LIST
80290: LIST
80291: LIST
80292: LIST
80293: PPUSH
80294: CALL_OW 72
80298: DIFF
80299: ST_TO_ADDR
// end ; end_of_file
80300: LD_VAR 0 3
80304: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80305: LD_INT 0
80307: PPUSH
80308: PPUSH
80309: PPUSH
// if not mc_bases or not skirmish then
80310: LD_EXP 58
80314: NOT
80315: PUSH
80316: LD_EXP 56
80320: NOT
80321: OR
80322: IFFALSE 80326
// exit ;
80324: GO 80491
// for i = 1 to mc_bases do
80326: LD_ADDR_VAR 0 4
80330: PUSH
80331: DOUBLE
80332: LD_INT 1
80334: DEC
80335: ST_TO_ADDR
80336: LD_EXP 58
80340: PUSH
80341: FOR_TO
80342: IFFALSE 80489
// begin if sci in mc_bases [ i ] then
80344: LD_VAR 0 2
80348: PUSH
80349: LD_EXP 58
80353: PUSH
80354: LD_VAR 0 4
80358: ARRAY
80359: IN
80360: IFFALSE 80487
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80362: LD_ADDR_EXP 87
80366: PUSH
80367: LD_EXP 87
80371: PPUSH
80372: LD_VAR 0 4
80376: PUSH
80377: LD_EXP 87
80381: PUSH
80382: LD_VAR 0 4
80386: ARRAY
80387: PUSH
80388: LD_INT 1
80390: PLUS
80391: PUSH
80392: EMPTY
80393: LIST
80394: LIST
80395: PPUSH
80396: LD_VAR 0 1
80400: PPUSH
80401: CALL 20665 0 3
80405: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80406: LD_ADDR_VAR 0 5
80410: PUSH
80411: LD_EXP 58
80415: PUSH
80416: LD_VAR 0 4
80420: ARRAY
80421: PPUSH
80422: LD_INT 2
80424: PUSH
80425: LD_INT 30
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 30
80437: PUSH
80438: LD_INT 1
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: LIST
80449: PPUSH
80450: CALL_OW 72
80454: PPUSH
80455: LD_VAR 0 1
80459: PPUSH
80460: CALL_OW 74
80464: ST_TO_ADDR
// if tmp then
80465: LD_VAR 0 5
80469: IFFALSE 80485
// ComStandNearbyBuilding ( ape , tmp ) ;
80471: LD_VAR 0 1
80475: PPUSH
80476: LD_VAR 0 5
80480: PPUSH
80481: CALL 15342 0 2
// break ;
80485: GO 80489
// end ; end ;
80487: GO 80341
80489: POP
80490: POP
// end ;
80491: LD_VAR 0 3
80495: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80496: LD_INT 0
80498: PPUSH
80499: PPUSH
80500: PPUSH
// if not mc_bases or not skirmish then
80501: LD_EXP 58
80505: NOT
80506: PUSH
80507: LD_EXP 56
80511: NOT
80512: OR
80513: IFFALSE 80517
// exit ;
80515: GO 80606
// for i = 1 to mc_bases do
80517: LD_ADDR_VAR 0 4
80521: PUSH
80522: DOUBLE
80523: LD_INT 1
80525: DEC
80526: ST_TO_ADDR
80527: LD_EXP 58
80531: PUSH
80532: FOR_TO
80533: IFFALSE 80604
// begin if building in mc_busy_turret_list [ i ] then
80535: LD_VAR 0 1
80539: PUSH
80540: LD_EXP 68
80544: PUSH
80545: LD_VAR 0 4
80549: ARRAY
80550: IN
80551: IFFALSE 80602
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80553: LD_ADDR_VAR 0 5
80557: PUSH
80558: LD_EXP 68
80562: PUSH
80563: LD_VAR 0 4
80567: ARRAY
80568: PUSH
80569: LD_VAR 0 1
80573: DIFF
80574: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80575: LD_ADDR_EXP 68
80579: PUSH
80580: LD_EXP 68
80584: PPUSH
80585: LD_VAR 0 4
80589: PPUSH
80590: LD_VAR 0 5
80594: PPUSH
80595: CALL_OW 1
80599: ST_TO_ADDR
// break ;
80600: GO 80604
// end ; end ;
80602: GO 80532
80604: POP
80605: POP
// end ;
80606: LD_VAR 0 3
80610: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80611: LD_INT 0
80613: PPUSH
80614: PPUSH
80615: PPUSH
// if not mc_bases or not skirmish then
80616: LD_EXP 58
80620: NOT
80621: PUSH
80622: LD_EXP 56
80626: NOT
80627: OR
80628: IFFALSE 80632
// exit ;
80630: GO 80831
// for i = 1 to mc_bases do
80632: LD_ADDR_VAR 0 5
80636: PUSH
80637: DOUBLE
80638: LD_INT 1
80640: DEC
80641: ST_TO_ADDR
80642: LD_EXP 58
80646: PUSH
80647: FOR_TO
80648: IFFALSE 80829
// if building in mc_bases [ i ] then
80650: LD_VAR 0 1
80654: PUSH
80655: LD_EXP 58
80659: PUSH
80660: LD_VAR 0 5
80664: ARRAY
80665: IN
80666: IFFALSE 80827
// begin tmp := mc_bases [ i ] diff building ;
80668: LD_ADDR_VAR 0 6
80672: PUSH
80673: LD_EXP 58
80677: PUSH
80678: LD_VAR 0 5
80682: ARRAY
80683: PUSH
80684: LD_VAR 0 1
80688: DIFF
80689: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80690: LD_ADDR_EXP 58
80694: PUSH
80695: LD_EXP 58
80699: PPUSH
80700: LD_VAR 0 5
80704: PPUSH
80705: LD_VAR 0 6
80709: PPUSH
80710: CALL_OW 1
80714: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80715: LD_VAR 0 1
80719: PUSH
80720: LD_EXP 66
80724: PUSH
80725: LD_VAR 0 5
80729: ARRAY
80730: IN
80731: IFFALSE 80770
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80733: LD_ADDR_EXP 66
80737: PUSH
80738: LD_EXP 66
80742: PPUSH
80743: LD_VAR 0 5
80747: PPUSH
80748: LD_EXP 66
80752: PUSH
80753: LD_VAR 0 5
80757: ARRAY
80758: PUSH
80759: LD_VAR 0 1
80763: DIFF
80764: PPUSH
80765: CALL_OW 1
80769: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80770: LD_VAR 0 1
80774: PUSH
80775: LD_EXP 67
80779: PUSH
80780: LD_VAR 0 5
80784: ARRAY
80785: IN
80786: IFFALSE 80825
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80788: LD_ADDR_EXP 67
80792: PUSH
80793: LD_EXP 67
80797: PPUSH
80798: LD_VAR 0 5
80802: PPUSH
80803: LD_EXP 67
80807: PUSH
80808: LD_VAR 0 5
80812: ARRAY
80813: PUSH
80814: LD_VAR 0 1
80818: DIFF
80819: PPUSH
80820: CALL_OW 1
80824: ST_TO_ADDR
// break ;
80825: GO 80829
// end ;
80827: GO 80647
80829: POP
80830: POP
// end ;
80831: LD_VAR 0 4
80835: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80836: LD_INT 0
80838: PPUSH
80839: PPUSH
80840: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80841: LD_EXP 58
80845: NOT
80846: PUSH
80847: LD_EXP 56
80851: NOT
80852: OR
80853: PUSH
80854: LD_VAR 0 3
80858: PUSH
80859: LD_EXP 84
80863: IN
80864: NOT
80865: OR
80866: IFFALSE 80870
// exit ;
80868: GO 80993
// for i = 1 to mc_vehicles do
80870: LD_ADDR_VAR 0 6
80874: PUSH
80875: DOUBLE
80876: LD_INT 1
80878: DEC
80879: ST_TO_ADDR
80880: LD_EXP 77
80884: PUSH
80885: FOR_TO
80886: IFFALSE 80991
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80888: LD_VAR 0 2
80892: PUSH
80893: LD_EXP 77
80897: PUSH
80898: LD_VAR 0 6
80902: ARRAY
80903: IN
80904: PUSH
80905: LD_VAR 0 1
80909: PUSH
80910: LD_EXP 77
80914: PUSH
80915: LD_VAR 0 6
80919: ARRAY
80920: IN
80921: OR
80922: IFFALSE 80989
// begin tmp := mc_vehicles [ i ] diff old ;
80924: LD_ADDR_VAR 0 7
80928: PUSH
80929: LD_EXP 77
80933: PUSH
80934: LD_VAR 0 6
80938: ARRAY
80939: PUSH
80940: LD_VAR 0 2
80944: DIFF
80945: ST_TO_ADDR
// tmp := tmp diff new ;
80946: LD_ADDR_VAR 0 7
80950: PUSH
80951: LD_VAR 0 7
80955: PUSH
80956: LD_VAR 0 1
80960: DIFF
80961: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80962: LD_ADDR_EXP 77
80966: PUSH
80967: LD_EXP 77
80971: PPUSH
80972: LD_VAR 0 6
80976: PPUSH
80977: LD_VAR 0 7
80981: PPUSH
80982: CALL_OW 1
80986: ST_TO_ADDR
// break ;
80987: GO 80991
// end ;
80989: GO 80885
80991: POP
80992: POP
// end ;
80993: LD_VAR 0 5
80997: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80998: LD_INT 0
81000: PPUSH
81001: PPUSH
81002: PPUSH
81003: PPUSH
// if not mc_bases or not skirmish then
81004: LD_EXP 58
81008: NOT
81009: PUSH
81010: LD_EXP 56
81014: NOT
81015: OR
81016: IFFALSE 81020
// exit ;
81018: GO 81403
// side := GetSide ( vehicle ) ;
81020: LD_ADDR_VAR 0 5
81024: PUSH
81025: LD_VAR 0 1
81029: PPUSH
81030: CALL_OW 255
81034: ST_TO_ADDR
// for i = 1 to mc_bases do
81035: LD_ADDR_VAR 0 4
81039: PUSH
81040: DOUBLE
81041: LD_INT 1
81043: DEC
81044: ST_TO_ADDR
81045: LD_EXP 58
81049: PUSH
81050: FOR_TO
81051: IFFALSE 81401
// begin if factory in mc_bases [ i ] then
81053: LD_VAR 0 2
81057: PUSH
81058: LD_EXP 58
81062: PUSH
81063: LD_VAR 0 4
81067: ARRAY
81068: IN
81069: IFFALSE 81399
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
81071: LD_EXP 80
81075: PUSH
81076: LD_VAR 0 4
81080: ARRAY
81081: PUSH
81082: LD_EXP 69
81086: PUSH
81087: LD_VAR 0 4
81091: ARRAY
81092: LESS
81093: PUSH
81094: LD_VAR 0 1
81098: PPUSH
81099: CALL_OW 264
81103: PUSH
81104: LD_INT 31
81106: PUSH
81107: LD_INT 32
81109: PUSH
81110: LD_INT 51
81112: PUSH
81113: LD_EXP 102
81117: PUSH
81118: LD_INT 12
81120: PUSH
81121: LD_INT 30
81123: PUSH
81124: LD_EXP 101
81128: PUSH
81129: LD_INT 11
81131: PUSH
81132: LD_INT 53
81134: PUSH
81135: LD_INT 14
81137: PUSH
81138: LD_EXP 105
81142: PUSH
81143: LD_INT 29
81145: PUSH
81146: LD_EXP 103
81150: PUSH
81151: LD_INT 13
81153: PUSH
81154: LD_INT 52
81156: PUSH
81157: LD_INT 48
81159: PUSH
81160: LD_INT 8
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: IN
81182: NOT
81183: AND
81184: IFFALSE 81225
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
81186: LD_ADDR_EXP 80
81190: PUSH
81191: LD_EXP 80
81195: PPUSH
81196: LD_VAR 0 4
81200: PPUSH
81201: LD_EXP 80
81205: PUSH
81206: LD_VAR 0 4
81210: ARRAY
81211: PUSH
81212: LD_VAR 0 1
81216: ADD
81217: PPUSH
81218: CALL_OW 1
81222: ST_TO_ADDR
81223: GO 81269
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81225: LD_ADDR_EXP 77
81229: PUSH
81230: LD_EXP 77
81234: PPUSH
81235: LD_VAR 0 4
81239: PUSH
81240: LD_EXP 77
81244: PUSH
81245: LD_VAR 0 4
81249: ARRAY
81250: PUSH
81251: LD_INT 1
81253: PLUS
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PPUSH
81259: LD_VAR 0 1
81263: PPUSH
81264: CALL 20665 0 3
81268: ST_TO_ADDR
// if not mc_scan [ i ] then
81269: LD_EXP 81
81273: PUSH
81274: LD_VAR 0 4
81278: ARRAY
81279: NOT
81280: IFFALSE 81399
// begin if GetControl ( vehicle ) = control_remote then
81282: LD_VAR 0 1
81286: PPUSH
81287: CALL_OW 263
81291: PUSH
81292: LD_INT 2
81294: EQUAL
81295: IFFALSE 81315
// repeat wait ( 0 0$1 ) ;
81297: LD_INT 35
81299: PPUSH
81300: CALL_OW 67
// until IsControledBy ( vehicle ) ;
81304: LD_VAR 0 1
81308: PPUSH
81309: CALL_OW 312
81313: IFFALSE 81297
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81315: LD_VAR 0 1
81319: PPUSH
81320: LD_EXP 82
81324: PUSH
81325: LD_VAR 0 4
81329: ARRAY
81330: PPUSH
81331: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81335: LD_VAR 0 1
81339: PPUSH
81340: CALL_OW 263
81344: PUSH
81345: LD_INT 1
81347: NONEQUAL
81348: IFFALSE 81352
// break ;
81350: GO 81401
// repeat wait ( 0 0$1 ) ;
81352: LD_INT 35
81354: PPUSH
81355: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81359: LD_VAR 0 1
81363: PPUSH
81364: LD_EXP 82
81368: PUSH
81369: LD_VAR 0 4
81373: ARRAY
81374: PPUSH
81375: CALL_OW 308
81379: IFFALSE 81352
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81381: LD_VAR 0 1
81385: PPUSH
81386: CALL_OW 311
81390: PPUSH
81391: CALL_OW 121
// exit ;
81395: POP
81396: POP
81397: GO 81403
// end ; end ; end ;
81399: GO 81050
81401: POP
81402: POP
// end ;
81403: LD_VAR 0 3
81407: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81408: LD_INT 0
81410: PPUSH
81411: PPUSH
81412: PPUSH
81413: PPUSH
// if not mc_bases or not skirmish then
81414: LD_EXP 58
81418: NOT
81419: PUSH
81420: LD_EXP 56
81424: NOT
81425: OR
81426: IFFALSE 81430
// exit ;
81428: GO 81783
// repeat wait ( 0 0$1 ) ;
81430: LD_INT 35
81432: PPUSH
81433: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81437: LD_VAR 0 2
81441: PPUSH
81442: LD_VAR 0 3
81446: PPUSH
81447: CALL_OW 284
81451: IFFALSE 81430
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81453: LD_VAR 0 2
81457: PPUSH
81458: LD_VAR 0 3
81462: PPUSH
81463: CALL_OW 283
81467: PUSH
81468: LD_INT 4
81470: EQUAL
81471: IFFALSE 81475
// exit ;
81473: GO 81783
// for i = 1 to mc_bases do
81475: LD_ADDR_VAR 0 7
81479: PUSH
81480: DOUBLE
81481: LD_INT 1
81483: DEC
81484: ST_TO_ADDR
81485: LD_EXP 58
81489: PUSH
81490: FOR_TO
81491: IFFALSE 81781
// begin if mc_crates_area [ i ] then
81493: LD_EXP 76
81497: PUSH
81498: LD_VAR 0 7
81502: ARRAY
81503: IFFALSE 81614
// for j in mc_crates_area [ i ] do
81505: LD_ADDR_VAR 0 8
81509: PUSH
81510: LD_EXP 76
81514: PUSH
81515: LD_VAR 0 7
81519: ARRAY
81520: PUSH
81521: FOR_IN
81522: IFFALSE 81612
// if InArea ( x , y , j ) then
81524: LD_VAR 0 2
81528: PPUSH
81529: LD_VAR 0 3
81533: PPUSH
81534: LD_VAR 0 8
81538: PPUSH
81539: CALL_OW 309
81543: IFFALSE 81610
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81545: LD_ADDR_EXP 74
81549: PUSH
81550: LD_EXP 74
81554: PPUSH
81555: LD_VAR 0 7
81559: PUSH
81560: LD_EXP 74
81564: PUSH
81565: LD_VAR 0 7
81569: ARRAY
81570: PUSH
81571: LD_INT 1
81573: PLUS
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PPUSH
81579: LD_VAR 0 4
81583: PUSH
81584: LD_VAR 0 2
81588: PUSH
81589: LD_VAR 0 3
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: LIST
81598: PPUSH
81599: CALL 20665 0 3
81603: ST_TO_ADDR
// exit ;
81604: POP
81605: POP
81606: POP
81607: POP
81608: GO 81783
// end ;
81610: GO 81521
81612: POP
81613: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81614: LD_ADDR_VAR 0 9
81618: PUSH
81619: LD_EXP 58
81623: PUSH
81624: LD_VAR 0 7
81628: ARRAY
81629: PPUSH
81630: LD_INT 2
81632: PUSH
81633: LD_INT 30
81635: PUSH
81636: LD_INT 0
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 30
81645: PUSH
81646: LD_INT 1
81648: PUSH
81649: EMPTY
81650: LIST
81651: LIST
81652: PUSH
81653: EMPTY
81654: LIST
81655: LIST
81656: LIST
81657: PPUSH
81658: CALL_OW 72
81662: ST_TO_ADDR
// if not depot then
81663: LD_VAR 0 9
81667: NOT
81668: IFFALSE 81672
// continue ;
81670: GO 81490
// for j in depot do
81672: LD_ADDR_VAR 0 8
81676: PUSH
81677: LD_VAR 0 9
81681: PUSH
81682: FOR_IN
81683: IFFALSE 81777
// if GetDistUnitXY ( j , x , y ) < 30 then
81685: LD_VAR 0 8
81689: PPUSH
81690: LD_VAR 0 2
81694: PPUSH
81695: LD_VAR 0 3
81699: PPUSH
81700: CALL_OW 297
81704: PUSH
81705: LD_INT 30
81707: LESS
81708: IFFALSE 81775
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81710: LD_ADDR_EXP 74
81714: PUSH
81715: LD_EXP 74
81719: PPUSH
81720: LD_VAR 0 7
81724: PUSH
81725: LD_EXP 74
81729: PUSH
81730: LD_VAR 0 7
81734: ARRAY
81735: PUSH
81736: LD_INT 1
81738: PLUS
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: PPUSH
81744: LD_VAR 0 4
81748: PUSH
81749: LD_VAR 0 2
81753: PUSH
81754: LD_VAR 0 3
81758: PUSH
81759: EMPTY
81760: LIST
81761: LIST
81762: LIST
81763: PPUSH
81764: CALL 20665 0 3
81768: ST_TO_ADDR
// exit ;
81769: POP
81770: POP
81771: POP
81772: POP
81773: GO 81783
// end ;
81775: GO 81682
81777: POP
81778: POP
// end ;
81779: GO 81490
81781: POP
81782: POP
// end ;
81783: LD_VAR 0 6
81787: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81788: LD_INT 0
81790: PPUSH
81791: PPUSH
81792: PPUSH
81793: PPUSH
// if not mc_bases or not skirmish then
81794: LD_EXP 58
81798: NOT
81799: PUSH
81800: LD_EXP 56
81804: NOT
81805: OR
81806: IFFALSE 81810
// exit ;
81808: GO 82087
// side := GetSide ( lab ) ;
81810: LD_ADDR_VAR 0 4
81814: PUSH
81815: LD_VAR 0 2
81819: PPUSH
81820: CALL_OW 255
81824: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81825: LD_VAR 0 4
81829: PUSH
81830: LD_EXP 84
81834: IN
81835: NOT
81836: PUSH
81837: LD_EXP 85
81841: NOT
81842: OR
81843: PUSH
81844: LD_EXP 58
81848: NOT
81849: OR
81850: IFFALSE 81854
// exit ;
81852: GO 82087
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81854: LD_ADDR_EXP 85
81858: PUSH
81859: LD_EXP 85
81863: PPUSH
81864: LD_VAR 0 4
81868: PPUSH
81869: LD_EXP 85
81873: PUSH
81874: LD_VAR 0 4
81878: ARRAY
81879: PUSH
81880: LD_VAR 0 1
81884: DIFF
81885: PPUSH
81886: CALL_OW 1
81890: ST_TO_ADDR
// for i = 1 to mc_bases do
81891: LD_ADDR_VAR 0 5
81895: PUSH
81896: DOUBLE
81897: LD_INT 1
81899: DEC
81900: ST_TO_ADDR
81901: LD_EXP 58
81905: PUSH
81906: FOR_TO
81907: IFFALSE 82085
// begin if lab in mc_bases [ i ] then
81909: LD_VAR 0 2
81913: PUSH
81914: LD_EXP 58
81918: PUSH
81919: LD_VAR 0 5
81923: ARRAY
81924: IN
81925: IFFALSE 82083
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81927: LD_VAR 0 1
81931: PUSH
81932: LD_INT 11
81934: PUSH
81935: LD_INT 4
81937: PUSH
81938: LD_INT 3
81940: PUSH
81941: LD_INT 2
81943: PUSH
81944: EMPTY
81945: LIST
81946: LIST
81947: LIST
81948: LIST
81949: IN
81950: PUSH
81951: LD_EXP 88
81955: PUSH
81956: LD_VAR 0 5
81960: ARRAY
81961: AND
81962: IFFALSE 82083
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81964: LD_ADDR_VAR 0 6
81968: PUSH
81969: LD_EXP 88
81973: PUSH
81974: LD_VAR 0 5
81978: ARRAY
81979: PUSH
81980: LD_INT 1
81982: ARRAY
81983: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81984: LD_ADDR_EXP 88
81988: PUSH
81989: LD_EXP 88
81993: PPUSH
81994: LD_VAR 0 5
81998: PPUSH
81999: EMPTY
82000: PPUSH
82001: CALL_OW 1
82005: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82006: LD_VAR 0 6
82010: PPUSH
82011: LD_INT 0
82013: PPUSH
82014: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82018: LD_VAR 0 6
82022: PPUSH
82023: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82027: LD_ADDR_EXP 87
82031: PUSH
82032: LD_EXP 87
82036: PPUSH
82037: LD_VAR 0 5
82041: PPUSH
82042: LD_EXP 87
82046: PUSH
82047: LD_VAR 0 5
82051: ARRAY
82052: PPUSH
82053: LD_INT 1
82055: PPUSH
82056: LD_VAR 0 6
82060: PPUSH
82061: CALL_OW 2
82065: PPUSH
82066: CALL_OW 1
82070: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82071: LD_VAR 0 5
82075: PPUSH
82076: LD_INT 112
82078: PPUSH
82079: CALL 59556 0 2
// end ; end ; end ;
82083: GO 81906
82085: POP
82086: POP
// end ;
82087: LD_VAR 0 3
82091: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82092: LD_INT 0
82094: PPUSH
82095: PPUSH
82096: PPUSH
82097: PPUSH
82098: PPUSH
82099: PPUSH
82100: PPUSH
82101: PPUSH
// if not mc_bases or not skirmish then
82102: LD_EXP 58
82106: NOT
82107: PUSH
82108: LD_EXP 56
82112: NOT
82113: OR
82114: IFFALSE 82118
// exit ;
82116: GO 83134
// for i = 1 to mc_bases do
82118: LD_ADDR_VAR 0 3
82122: PUSH
82123: DOUBLE
82124: LD_INT 1
82126: DEC
82127: ST_TO_ADDR
82128: LD_EXP 58
82132: PUSH
82133: FOR_TO
82134: IFFALSE 83132
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82136: LD_VAR 0 1
82140: PUSH
82141: LD_EXP 58
82145: PUSH
82146: LD_VAR 0 3
82150: ARRAY
82151: IN
82152: PUSH
82153: LD_VAR 0 1
82157: PUSH
82158: LD_EXP 65
82162: PUSH
82163: LD_VAR 0 3
82167: ARRAY
82168: IN
82169: OR
82170: PUSH
82171: LD_VAR 0 1
82175: PUSH
82176: LD_EXP 77
82180: PUSH
82181: LD_VAR 0 3
82185: ARRAY
82186: IN
82187: OR
82188: PUSH
82189: LD_VAR 0 1
82193: PUSH
82194: LD_EXP 87
82198: PUSH
82199: LD_VAR 0 3
82203: ARRAY
82204: IN
82205: OR
82206: PUSH
82207: LD_VAR 0 1
82211: PUSH
82212: LD_EXP 88
82216: PUSH
82217: LD_VAR 0 3
82221: ARRAY
82222: IN
82223: OR
82224: IFFALSE 83130
// begin if un in mc_ape [ i ] then
82226: LD_VAR 0 1
82230: PUSH
82231: LD_EXP 87
82235: PUSH
82236: LD_VAR 0 3
82240: ARRAY
82241: IN
82242: IFFALSE 82281
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82244: LD_ADDR_EXP 87
82248: PUSH
82249: LD_EXP 87
82253: PPUSH
82254: LD_VAR 0 3
82258: PPUSH
82259: LD_EXP 87
82263: PUSH
82264: LD_VAR 0 3
82268: ARRAY
82269: PUSH
82270: LD_VAR 0 1
82274: DIFF
82275: PPUSH
82276: CALL_OW 1
82280: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82281: LD_VAR 0 1
82285: PUSH
82286: LD_EXP 88
82290: PUSH
82291: LD_VAR 0 3
82295: ARRAY
82296: IN
82297: IFFALSE 82321
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82299: LD_ADDR_EXP 88
82303: PUSH
82304: LD_EXP 88
82308: PPUSH
82309: LD_VAR 0 3
82313: PPUSH
82314: EMPTY
82315: PPUSH
82316: CALL_OW 1
82320: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
82321: LD_VAR 0 1
82325: PPUSH
82326: CALL_OW 247
82330: PUSH
82331: LD_INT 2
82333: EQUAL
82334: PUSH
82335: LD_VAR 0 1
82339: PPUSH
82340: CALL_OW 110
82344: PUSH
82345: LD_INT 20
82347: EQUAL
82348: PUSH
82349: LD_VAR 0 1
82353: PUSH
82354: LD_EXP 80
82358: PUSH
82359: LD_VAR 0 3
82363: ARRAY
82364: IN
82365: OR
82366: AND
82367: IFFALSE 82470
// begin fac := MC_GetBuilding ( i , b_factory ) ;
82369: LD_ADDR_VAR 0 8
82373: PUSH
82374: LD_VAR 0 3
82378: PPUSH
82379: LD_INT 3
82381: PPUSH
82382: CALL 79129 0 2
82386: ST_TO_ADDR
// if fac then
82387: LD_VAR 0 8
82391: IFFALSE 82470
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82393: LD_ADDR_VAR 0 9
82397: PUSH
82398: LD_VAR 0 8
82402: PPUSH
82403: LD_VAR 0 1
82407: PPUSH
82408: CALL_OW 265
82412: PPUSH
82413: LD_VAR 0 1
82417: PPUSH
82418: CALL_OW 262
82422: PPUSH
82423: LD_VAR 0 1
82427: PPUSH
82428: CALL_OW 263
82432: PPUSH
82433: LD_VAR 0 1
82437: PPUSH
82438: CALL_OW 264
82442: PPUSH
82443: CALL 18265 0 5
82447: ST_TO_ADDR
// if components then
82448: LD_VAR 0 9
82452: IFFALSE 82468
// MC_InsertProduceList ( i , components ) ;
82454: LD_VAR 0 3
82458: PPUSH
82459: LD_VAR 0 9
82463: PPUSH
82464: CALL 78757 0 2
// break ;
82468: GO 83132
// end ; end ; if GetType ( un ) = unit_building then
82470: LD_VAR 0 1
82474: PPUSH
82475: CALL_OW 247
82479: PUSH
82480: LD_INT 3
82482: EQUAL
82483: IFFALSE 82798
// begin btype := GetBType ( un ) ;
82485: LD_ADDR_VAR 0 5
82489: PUSH
82490: LD_VAR 0 1
82494: PPUSH
82495: CALL_OW 266
82499: ST_TO_ADDR
// if btype = b_warehouse then
82500: LD_VAR 0 5
82504: PUSH
82505: LD_INT 1
82507: EQUAL
82508: IFFALSE 82526
// begin btype := b_depot ;
82510: LD_ADDR_VAR 0 5
82514: PUSH
82515: LD_INT 0
82517: ST_TO_ADDR
// pos := 1 ;
82518: LD_ADDR_VAR 0 6
82522: PUSH
82523: LD_INT 1
82525: ST_TO_ADDR
// end ; if btype = b_factory then
82526: LD_VAR 0 5
82530: PUSH
82531: LD_INT 3
82533: EQUAL
82534: IFFALSE 82552
// begin btype := b_workshop ;
82536: LD_ADDR_VAR 0 5
82540: PUSH
82541: LD_INT 2
82543: ST_TO_ADDR
// pos := 1 ;
82544: LD_ADDR_VAR 0 6
82548: PUSH
82549: LD_INT 1
82551: ST_TO_ADDR
// end ; if btype = b_barracks then
82552: LD_VAR 0 5
82556: PUSH
82557: LD_INT 5
82559: EQUAL
82560: IFFALSE 82570
// btype := b_armoury ;
82562: LD_ADDR_VAR 0 5
82566: PUSH
82567: LD_INT 4
82569: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82570: LD_VAR 0 5
82574: PUSH
82575: LD_INT 7
82577: PUSH
82578: LD_INT 8
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: IN
82585: IFFALSE 82595
// btype := b_lab ;
82587: LD_ADDR_VAR 0 5
82591: PUSH
82592: LD_INT 6
82594: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82595: LD_ADDR_EXP 63
82599: PUSH
82600: LD_EXP 63
82604: PPUSH
82605: LD_VAR 0 3
82609: PUSH
82610: LD_EXP 63
82614: PUSH
82615: LD_VAR 0 3
82619: ARRAY
82620: PUSH
82621: LD_INT 1
82623: PLUS
82624: PUSH
82625: EMPTY
82626: LIST
82627: LIST
82628: PPUSH
82629: LD_VAR 0 5
82633: PUSH
82634: LD_VAR 0 1
82638: PPUSH
82639: CALL_OW 250
82643: PUSH
82644: LD_VAR 0 1
82648: PPUSH
82649: CALL_OW 251
82653: PUSH
82654: LD_VAR 0 1
82658: PPUSH
82659: CALL_OW 254
82663: PUSH
82664: EMPTY
82665: LIST
82666: LIST
82667: LIST
82668: LIST
82669: PPUSH
82670: CALL 20665 0 3
82674: ST_TO_ADDR
// if pos = 1 then
82675: LD_VAR 0 6
82679: PUSH
82680: LD_INT 1
82682: EQUAL
82683: IFFALSE 82798
// begin tmp := mc_build_list [ i ] ;
82685: LD_ADDR_VAR 0 7
82689: PUSH
82690: LD_EXP 63
82694: PUSH
82695: LD_VAR 0 3
82699: ARRAY
82700: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82701: LD_VAR 0 7
82705: PPUSH
82706: LD_INT 2
82708: PUSH
82709: LD_INT 30
82711: PUSH
82712: LD_INT 0
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 30
82721: PUSH
82722: LD_INT 1
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: LIST
82733: PPUSH
82734: CALL_OW 72
82738: IFFALSE 82748
// pos := 2 ;
82740: LD_ADDR_VAR 0 6
82744: PUSH
82745: LD_INT 2
82747: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82748: LD_ADDR_VAR 0 7
82752: PUSH
82753: LD_VAR 0 7
82757: PPUSH
82758: LD_VAR 0 6
82762: PPUSH
82763: LD_VAR 0 7
82767: PPUSH
82768: CALL 20991 0 3
82772: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82773: LD_ADDR_EXP 63
82777: PUSH
82778: LD_EXP 63
82782: PPUSH
82783: LD_VAR 0 3
82787: PPUSH
82788: LD_VAR 0 7
82792: PPUSH
82793: CALL_OW 1
82797: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82798: LD_VAR 0 1
82802: PUSH
82803: LD_EXP 58
82807: PUSH
82808: LD_VAR 0 3
82812: ARRAY
82813: IN
82814: IFFALSE 82853
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82816: LD_ADDR_EXP 58
82820: PUSH
82821: LD_EXP 58
82825: PPUSH
82826: LD_VAR 0 3
82830: PPUSH
82831: LD_EXP 58
82835: PUSH
82836: LD_VAR 0 3
82840: ARRAY
82841: PUSH
82842: LD_VAR 0 1
82846: DIFF
82847: PPUSH
82848: CALL_OW 1
82852: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82853: LD_VAR 0 1
82857: PUSH
82858: LD_EXP 65
82862: PUSH
82863: LD_VAR 0 3
82867: ARRAY
82868: IN
82869: IFFALSE 82908
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82871: LD_ADDR_EXP 65
82875: PUSH
82876: LD_EXP 65
82880: PPUSH
82881: LD_VAR 0 3
82885: PPUSH
82886: LD_EXP 65
82890: PUSH
82891: LD_VAR 0 3
82895: ARRAY
82896: PUSH
82897: LD_VAR 0 1
82901: DIFF
82902: PPUSH
82903: CALL_OW 1
82907: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82908: LD_VAR 0 1
82912: PUSH
82913: LD_EXP 77
82917: PUSH
82918: LD_VAR 0 3
82922: ARRAY
82923: IN
82924: IFFALSE 82963
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82926: LD_ADDR_EXP 77
82930: PUSH
82931: LD_EXP 77
82935: PPUSH
82936: LD_VAR 0 3
82940: PPUSH
82941: LD_EXP 77
82945: PUSH
82946: LD_VAR 0 3
82950: ARRAY
82951: PUSH
82952: LD_VAR 0 1
82956: DIFF
82957: PPUSH
82958: CALL_OW 1
82962: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82963: LD_VAR 0 1
82967: PUSH
82968: LD_EXP 80
82972: PUSH
82973: LD_VAR 0 3
82977: ARRAY
82978: IN
82979: IFFALSE 83018
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82981: LD_ADDR_EXP 80
82985: PUSH
82986: LD_EXP 80
82990: PPUSH
82991: LD_VAR 0 3
82995: PPUSH
82996: LD_EXP 80
83000: PUSH
83001: LD_VAR 0 3
83005: ARRAY
83006: PUSH
83007: LD_VAR 0 1
83011: DIFF
83012: PPUSH
83013: CALL_OW 1
83017: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83018: LD_VAR 0 1
83022: PUSH
83023: LD_EXP 67
83027: PUSH
83028: LD_VAR 0 3
83032: ARRAY
83033: IN
83034: IFFALSE 83073
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83036: LD_ADDR_EXP 67
83040: PUSH
83041: LD_EXP 67
83045: PPUSH
83046: LD_VAR 0 3
83050: PPUSH
83051: LD_EXP 67
83055: PUSH
83056: LD_VAR 0 3
83060: ARRAY
83061: PUSH
83062: LD_VAR 0 1
83066: DIFF
83067: PPUSH
83068: CALL_OW 1
83072: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83073: LD_VAR 0 1
83077: PUSH
83078: LD_EXP 66
83082: PUSH
83083: LD_VAR 0 3
83087: ARRAY
83088: IN
83089: IFFALSE 83128
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83091: LD_ADDR_EXP 66
83095: PUSH
83096: LD_EXP 66
83100: PPUSH
83101: LD_VAR 0 3
83105: PPUSH
83106: LD_EXP 66
83110: PUSH
83111: LD_VAR 0 3
83115: ARRAY
83116: PUSH
83117: LD_VAR 0 1
83121: DIFF
83122: PPUSH
83123: CALL_OW 1
83127: ST_TO_ADDR
// end ; break ;
83128: GO 83132
// end ;
83130: GO 82133
83132: POP
83133: POP
// end ;
83134: LD_VAR 0 2
83138: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83139: LD_INT 0
83141: PPUSH
83142: PPUSH
83143: PPUSH
// if not mc_bases or not skirmish then
83144: LD_EXP 58
83148: NOT
83149: PUSH
83150: LD_EXP 56
83154: NOT
83155: OR
83156: IFFALSE 83160
// exit ;
83158: GO 83375
// for i = 1 to mc_bases do
83160: LD_ADDR_VAR 0 3
83164: PUSH
83165: DOUBLE
83166: LD_INT 1
83168: DEC
83169: ST_TO_ADDR
83170: LD_EXP 58
83174: PUSH
83175: FOR_TO
83176: IFFALSE 83373
// begin if building in mc_construct_list [ i ] then
83178: LD_VAR 0 1
83182: PUSH
83183: LD_EXP 65
83187: PUSH
83188: LD_VAR 0 3
83192: ARRAY
83193: IN
83194: IFFALSE 83371
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83196: LD_ADDR_EXP 65
83200: PUSH
83201: LD_EXP 65
83205: PPUSH
83206: LD_VAR 0 3
83210: PPUSH
83211: LD_EXP 65
83215: PUSH
83216: LD_VAR 0 3
83220: ARRAY
83221: PUSH
83222: LD_VAR 0 1
83226: DIFF
83227: PPUSH
83228: CALL_OW 1
83232: ST_TO_ADDR
// if building in mc_lab [ i ] then
83233: LD_VAR 0 1
83237: PUSH
83238: LD_EXP 91
83242: PUSH
83243: LD_VAR 0 3
83247: ARRAY
83248: IN
83249: IFFALSE 83304
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83251: LD_ADDR_EXP 92
83255: PUSH
83256: LD_EXP 92
83260: PPUSH
83261: LD_VAR 0 3
83265: PPUSH
83266: LD_EXP 92
83270: PUSH
83271: LD_VAR 0 3
83275: ARRAY
83276: PPUSH
83277: LD_INT 1
83279: PPUSH
83280: LD_EXP 92
83284: PUSH
83285: LD_VAR 0 3
83289: ARRAY
83290: PPUSH
83291: LD_INT 0
83293: PPUSH
83294: CALL 20083 0 4
83298: PPUSH
83299: CALL_OW 1
83303: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83304: LD_VAR 0 1
83308: PUSH
83309: LD_EXP 58
83313: PUSH
83314: LD_VAR 0 3
83318: ARRAY
83319: IN
83320: NOT
83321: IFFALSE 83367
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83323: LD_ADDR_EXP 58
83327: PUSH
83328: LD_EXP 58
83332: PPUSH
83333: LD_VAR 0 3
83337: PUSH
83338: LD_EXP 58
83342: PUSH
83343: LD_VAR 0 3
83347: ARRAY
83348: PUSH
83349: LD_INT 1
83351: PLUS
83352: PUSH
83353: EMPTY
83354: LIST
83355: LIST
83356: PPUSH
83357: LD_VAR 0 1
83361: PPUSH
83362: CALL 20665 0 3
83366: ST_TO_ADDR
// exit ;
83367: POP
83368: POP
83369: GO 83375
// end ; end ;
83371: GO 83175
83373: POP
83374: POP
// end ;
83375: LD_VAR 0 2
83379: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83380: LD_INT 0
83382: PPUSH
83383: PPUSH
83384: PPUSH
83385: PPUSH
83386: PPUSH
83387: PPUSH
83388: PPUSH
// if not mc_bases or not skirmish then
83389: LD_EXP 58
83393: NOT
83394: PUSH
83395: LD_EXP 56
83399: NOT
83400: OR
83401: IFFALSE 83405
// exit ;
83403: GO 84066
// for i = 1 to mc_bases do
83405: LD_ADDR_VAR 0 3
83409: PUSH
83410: DOUBLE
83411: LD_INT 1
83413: DEC
83414: ST_TO_ADDR
83415: LD_EXP 58
83419: PUSH
83420: FOR_TO
83421: IFFALSE 84064
// begin if building in mc_construct_list [ i ] then
83423: LD_VAR 0 1
83427: PUSH
83428: LD_EXP 65
83432: PUSH
83433: LD_VAR 0 3
83437: ARRAY
83438: IN
83439: IFFALSE 84062
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83441: LD_ADDR_EXP 65
83445: PUSH
83446: LD_EXP 65
83450: PPUSH
83451: LD_VAR 0 3
83455: PPUSH
83456: LD_EXP 65
83460: PUSH
83461: LD_VAR 0 3
83465: ARRAY
83466: PUSH
83467: LD_VAR 0 1
83471: DIFF
83472: PPUSH
83473: CALL_OW 1
83477: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83478: LD_ADDR_EXP 58
83482: PUSH
83483: LD_EXP 58
83487: PPUSH
83488: LD_VAR 0 3
83492: PUSH
83493: LD_EXP 58
83497: PUSH
83498: LD_VAR 0 3
83502: ARRAY
83503: PUSH
83504: LD_INT 1
83506: PLUS
83507: PUSH
83508: EMPTY
83509: LIST
83510: LIST
83511: PPUSH
83512: LD_VAR 0 1
83516: PPUSH
83517: CALL 20665 0 3
83521: ST_TO_ADDR
// btype := GetBType ( building ) ;
83522: LD_ADDR_VAR 0 5
83526: PUSH
83527: LD_VAR 0 1
83531: PPUSH
83532: CALL_OW 266
83536: ST_TO_ADDR
// side := GetSide ( building ) ;
83537: LD_ADDR_VAR 0 8
83541: PUSH
83542: LD_VAR 0 1
83546: PPUSH
83547: CALL_OW 255
83551: ST_TO_ADDR
// if btype = b_lab then
83552: LD_VAR 0 5
83556: PUSH
83557: LD_INT 6
83559: EQUAL
83560: IFFALSE 83610
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83562: LD_ADDR_EXP 91
83566: PUSH
83567: LD_EXP 91
83571: PPUSH
83572: LD_VAR 0 3
83576: PUSH
83577: LD_EXP 91
83581: PUSH
83582: LD_VAR 0 3
83586: ARRAY
83587: PUSH
83588: LD_INT 1
83590: PLUS
83591: PUSH
83592: EMPTY
83593: LIST
83594: LIST
83595: PPUSH
83596: LD_VAR 0 1
83600: PPUSH
83601: CALL 20665 0 3
83605: ST_TO_ADDR
// exit ;
83606: POP
83607: POP
83608: GO 84066
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83610: LD_VAR 0 5
83614: PUSH
83615: LD_INT 0
83617: PUSH
83618: LD_INT 2
83620: PUSH
83621: LD_INT 4
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: LIST
83628: IN
83629: IFFALSE 83753
// begin if btype = b_armoury then
83631: LD_VAR 0 5
83635: PUSH
83636: LD_INT 4
83638: EQUAL
83639: IFFALSE 83649
// btype := b_barracks ;
83641: LD_ADDR_VAR 0 5
83645: PUSH
83646: LD_INT 5
83648: ST_TO_ADDR
// if btype = b_depot then
83649: LD_VAR 0 5
83653: PUSH
83654: LD_INT 0
83656: EQUAL
83657: IFFALSE 83667
// btype := b_warehouse ;
83659: LD_ADDR_VAR 0 5
83663: PUSH
83664: LD_INT 1
83666: ST_TO_ADDR
// if btype = b_workshop then
83667: LD_VAR 0 5
83671: PUSH
83672: LD_INT 2
83674: EQUAL
83675: IFFALSE 83685
// btype := b_factory ;
83677: LD_ADDR_VAR 0 5
83681: PUSH
83682: LD_INT 3
83684: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83685: LD_VAR 0 5
83689: PPUSH
83690: LD_VAR 0 8
83694: PPUSH
83695: CALL_OW 323
83699: PUSH
83700: LD_INT 1
83702: EQUAL
83703: IFFALSE 83749
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83705: LD_ADDR_EXP 90
83709: PUSH
83710: LD_EXP 90
83714: PPUSH
83715: LD_VAR 0 3
83719: PUSH
83720: LD_EXP 90
83724: PUSH
83725: LD_VAR 0 3
83729: ARRAY
83730: PUSH
83731: LD_INT 1
83733: PLUS
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PPUSH
83739: LD_VAR 0 1
83743: PPUSH
83744: CALL 20665 0 3
83748: ST_TO_ADDR
// exit ;
83749: POP
83750: POP
83751: GO 84066
// end ; if btype in [ b_bunker , b_turret ] then
83753: LD_VAR 0 5
83757: PUSH
83758: LD_INT 32
83760: PUSH
83761: LD_INT 33
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: IN
83768: IFFALSE 84058
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83770: LD_ADDR_EXP 66
83774: PUSH
83775: LD_EXP 66
83779: PPUSH
83780: LD_VAR 0 3
83784: PUSH
83785: LD_EXP 66
83789: PUSH
83790: LD_VAR 0 3
83794: ARRAY
83795: PUSH
83796: LD_INT 1
83798: PLUS
83799: PUSH
83800: EMPTY
83801: LIST
83802: LIST
83803: PPUSH
83804: LD_VAR 0 1
83808: PPUSH
83809: CALL 20665 0 3
83813: ST_TO_ADDR
// if btype = b_bunker then
83814: LD_VAR 0 5
83818: PUSH
83819: LD_INT 32
83821: EQUAL
83822: IFFALSE 84058
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83824: LD_ADDR_EXP 67
83828: PUSH
83829: LD_EXP 67
83833: PPUSH
83834: LD_VAR 0 3
83838: PUSH
83839: LD_EXP 67
83843: PUSH
83844: LD_VAR 0 3
83848: ARRAY
83849: PUSH
83850: LD_INT 1
83852: PLUS
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PPUSH
83858: LD_VAR 0 1
83862: PPUSH
83863: CALL 20665 0 3
83867: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83868: LD_ADDR_VAR 0 6
83872: PUSH
83873: LD_EXP 58
83877: PUSH
83878: LD_VAR 0 3
83882: ARRAY
83883: PPUSH
83884: LD_INT 25
83886: PUSH
83887: LD_INT 1
83889: PUSH
83890: EMPTY
83891: LIST
83892: LIST
83893: PUSH
83894: LD_INT 3
83896: PUSH
83897: LD_INT 54
83899: PUSH
83900: EMPTY
83901: LIST
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PPUSH
83911: CALL_OW 72
83915: ST_TO_ADDR
// if tmp then
83916: LD_VAR 0 6
83920: IFFALSE 83926
// exit ;
83922: POP
83923: POP
83924: GO 84066
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83926: LD_ADDR_VAR 0 6
83930: PUSH
83931: LD_EXP 58
83935: PUSH
83936: LD_VAR 0 3
83940: ARRAY
83941: PPUSH
83942: LD_INT 2
83944: PUSH
83945: LD_INT 30
83947: PUSH
83948: LD_INT 4
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: LD_INT 30
83957: PUSH
83958: LD_INT 5
83960: PUSH
83961: EMPTY
83962: LIST
83963: LIST
83964: PUSH
83965: EMPTY
83966: LIST
83967: LIST
83968: LIST
83969: PPUSH
83970: CALL_OW 72
83974: ST_TO_ADDR
// if not tmp then
83975: LD_VAR 0 6
83979: NOT
83980: IFFALSE 83986
// exit ;
83982: POP
83983: POP
83984: GO 84066
// for j in tmp do
83986: LD_ADDR_VAR 0 4
83990: PUSH
83991: LD_VAR 0 6
83995: PUSH
83996: FOR_IN
83997: IFFALSE 84056
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83999: LD_ADDR_VAR 0 7
84003: PUSH
84004: LD_VAR 0 4
84008: PPUSH
84009: CALL_OW 313
84013: PPUSH
84014: LD_INT 25
84016: PUSH
84017: LD_INT 1
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PPUSH
84024: CALL_OW 72
84028: ST_TO_ADDR
// if units then
84029: LD_VAR 0 7
84033: IFFALSE 84054
// begin ComExitBuilding ( units [ 1 ] ) ;
84035: LD_VAR 0 7
84039: PUSH
84040: LD_INT 1
84042: ARRAY
84043: PPUSH
84044: CALL_OW 122
// exit ;
84048: POP
84049: POP
84050: POP
84051: POP
84052: GO 84066
// end ; end ;
84054: GO 83996
84056: POP
84057: POP
// end ; end ; exit ;
84058: POP
84059: POP
84060: GO 84066
// end ; end ;
84062: GO 83420
84064: POP
84065: POP
// end ;
84066: LD_VAR 0 2
84070: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84071: LD_INT 0
84073: PPUSH
84074: PPUSH
84075: PPUSH
84076: PPUSH
84077: PPUSH
84078: PPUSH
84079: PPUSH
// if not mc_bases or not skirmish then
84080: LD_EXP 58
84084: NOT
84085: PUSH
84086: LD_EXP 56
84090: NOT
84091: OR
84092: IFFALSE 84096
// exit ;
84094: GO 84327
// btype := GetBType ( building ) ;
84096: LD_ADDR_VAR 0 6
84100: PUSH
84101: LD_VAR 0 1
84105: PPUSH
84106: CALL_OW 266
84110: ST_TO_ADDR
// x := GetX ( building ) ;
84111: LD_ADDR_VAR 0 7
84115: PUSH
84116: LD_VAR 0 1
84120: PPUSH
84121: CALL_OW 250
84125: ST_TO_ADDR
// y := GetY ( building ) ;
84126: LD_ADDR_VAR 0 8
84130: PUSH
84131: LD_VAR 0 1
84135: PPUSH
84136: CALL_OW 251
84140: ST_TO_ADDR
// d := GetDir ( building ) ;
84141: LD_ADDR_VAR 0 9
84145: PUSH
84146: LD_VAR 0 1
84150: PPUSH
84151: CALL_OW 254
84155: ST_TO_ADDR
// for i = 1 to mc_bases do
84156: LD_ADDR_VAR 0 4
84160: PUSH
84161: DOUBLE
84162: LD_INT 1
84164: DEC
84165: ST_TO_ADDR
84166: LD_EXP 58
84170: PUSH
84171: FOR_TO
84172: IFFALSE 84325
// begin if not mc_build_list [ i ] then
84174: LD_EXP 63
84178: PUSH
84179: LD_VAR 0 4
84183: ARRAY
84184: NOT
84185: IFFALSE 84189
// continue ;
84187: GO 84171
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
84189: LD_VAR 0 6
84193: PUSH
84194: LD_VAR 0 7
84198: PUSH
84199: LD_VAR 0 8
84203: PUSH
84204: LD_VAR 0 9
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: PPUSH
84215: LD_EXP 63
84219: PUSH
84220: LD_VAR 0 4
84224: ARRAY
84225: PUSH
84226: LD_INT 1
84228: ARRAY
84229: PPUSH
84230: CALL 26834 0 2
84234: IFFALSE 84323
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
84236: LD_ADDR_EXP 63
84240: PUSH
84241: LD_EXP 63
84245: PPUSH
84246: LD_VAR 0 4
84250: PPUSH
84251: LD_EXP 63
84255: PUSH
84256: LD_VAR 0 4
84260: ARRAY
84261: PPUSH
84262: LD_INT 1
84264: PPUSH
84265: CALL_OW 3
84269: PPUSH
84270: CALL_OW 1
84274: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84275: LD_ADDR_EXP 65
84279: PUSH
84280: LD_EXP 65
84284: PPUSH
84285: LD_VAR 0 4
84289: PUSH
84290: LD_EXP 65
84294: PUSH
84295: LD_VAR 0 4
84299: ARRAY
84300: PUSH
84301: LD_INT 1
84303: PLUS
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PPUSH
84309: LD_VAR 0 1
84313: PPUSH
84314: CALL 20665 0 3
84318: ST_TO_ADDR
// exit ;
84319: POP
84320: POP
84321: GO 84327
// end ; end ;
84323: GO 84171
84325: POP
84326: POP
// end ;
84327: LD_VAR 0 3
84331: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84332: LD_INT 0
84334: PPUSH
84335: PPUSH
84336: PPUSH
// if not mc_bases or not skirmish then
84337: LD_EXP 58
84341: NOT
84342: PUSH
84343: LD_EXP 56
84347: NOT
84348: OR
84349: IFFALSE 84353
// exit ;
84351: GO 84543
// for i = 1 to mc_bases do
84353: LD_ADDR_VAR 0 4
84357: PUSH
84358: DOUBLE
84359: LD_INT 1
84361: DEC
84362: ST_TO_ADDR
84363: LD_EXP 58
84367: PUSH
84368: FOR_TO
84369: IFFALSE 84456
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84371: LD_VAR 0 1
84375: PUSH
84376: LD_EXP 66
84380: PUSH
84381: LD_VAR 0 4
84385: ARRAY
84386: IN
84387: PUSH
84388: LD_VAR 0 1
84392: PUSH
84393: LD_EXP 67
84397: PUSH
84398: LD_VAR 0 4
84402: ARRAY
84403: IN
84404: NOT
84405: AND
84406: IFFALSE 84454
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84408: LD_ADDR_EXP 67
84412: PUSH
84413: LD_EXP 67
84417: PPUSH
84418: LD_VAR 0 4
84422: PUSH
84423: LD_EXP 67
84427: PUSH
84428: LD_VAR 0 4
84432: ARRAY
84433: PUSH
84434: LD_INT 1
84436: PLUS
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PPUSH
84442: LD_VAR 0 1
84446: PPUSH
84447: CALL 20665 0 3
84451: ST_TO_ADDR
// break ;
84452: GO 84456
// end ; end ;
84454: GO 84368
84456: POP
84457: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84458: LD_VAR 0 1
84462: PPUSH
84463: CALL_OW 257
84467: PUSH
84468: LD_EXP 84
84472: IN
84473: PUSH
84474: LD_VAR 0 1
84478: PPUSH
84479: CALL_OW 266
84483: PUSH
84484: LD_INT 5
84486: EQUAL
84487: AND
84488: PUSH
84489: LD_VAR 0 2
84493: PPUSH
84494: CALL_OW 110
84498: PUSH
84499: LD_INT 18
84501: NONEQUAL
84502: AND
84503: IFFALSE 84543
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84505: LD_VAR 0 2
84509: PPUSH
84510: CALL_OW 257
84514: PUSH
84515: LD_INT 5
84517: PUSH
84518: LD_INT 8
84520: PUSH
84521: LD_INT 9
84523: PUSH
84524: EMPTY
84525: LIST
84526: LIST
84527: LIST
84528: IN
84529: IFFALSE 84543
// SetClass ( unit , 1 ) ;
84531: LD_VAR 0 2
84535: PPUSH
84536: LD_INT 1
84538: PPUSH
84539: CALL_OW 336
// end ;
84543: LD_VAR 0 3
84547: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84548: LD_INT 0
84550: PPUSH
84551: PPUSH
// if not mc_bases or not skirmish then
84552: LD_EXP 58
84556: NOT
84557: PUSH
84558: LD_EXP 56
84562: NOT
84563: OR
84564: IFFALSE 84568
// exit ;
84566: GO 84684
// if GetLives ( abandoned_vehicle ) > 250 then
84568: LD_VAR 0 2
84572: PPUSH
84573: CALL_OW 256
84577: PUSH
84578: LD_INT 250
84580: GREATER
84581: IFFALSE 84585
// exit ;
84583: GO 84684
// for i = 1 to mc_bases do
84585: LD_ADDR_VAR 0 6
84589: PUSH
84590: DOUBLE
84591: LD_INT 1
84593: DEC
84594: ST_TO_ADDR
84595: LD_EXP 58
84599: PUSH
84600: FOR_TO
84601: IFFALSE 84682
// begin if driver in mc_bases [ i ] then
84603: LD_VAR 0 1
84607: PUSH
84608: LD_EXP 58
84612: PUSH
84613: LD_VAR 0 6
84617: ARRAY
84618: IN
84619: IFFALSE 84680
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84621: LD_VAR 0 1
84625: PPUSH
84626: LD_EXP 58
84630: PUSH
84631: LD_VAR 0 6
84635: ARRAY
84636: PPUSH
84637: LD_INT 2
84639: PUSH
84640: LD_INT 30
84642: PUSH
84643: LD_INT 0
84645: PUSH
84646: EMPTY
84647: LIST
84648: LIST
84649: PUSH
84650: LD_INT 30
84652: PUSH
84653: LD_INT 1
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: LIST
84664: PPUSH
84665: CALL_OW 72
84669: PUSH
84670: LD_INT 1
84672: ARRAY
84673: PPUSH
84674: CALL_OW 112
// break ;
84678: GO 84682
// end ; end ;
84680: GO 84600
84682: POP
84683: POP
// end ; end_of_file
84684: LD_VAR 0 5
84688: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
84689: GO 84691
84691: DISABLE
// begin ru_radar := 98 ;
84692: LD_ADDR_EXP 101
84696: PUSH
84697: LD_INT 98
84699: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84700: LD_ADDR_EXP 102
84704: PUSH
84705: LD_INT 89
84707: ST_TO_ADDR
// us_hack := 99 ;
84708: LD_ADDR_EXP 103
84712: PUSH
84713: LD_INT 99
84715: ST_TO_ADDR
// us_artillery := 97 ;
84716: LD_ADDR_EXP 104
84720: PUSH
84721: LD_INT 97
84723: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84724: LD_ADDR_EXP 105
84728: PUSH
84729: LD_INT 91
84731: ST_TO_ADDR
// end ;
84732: END
