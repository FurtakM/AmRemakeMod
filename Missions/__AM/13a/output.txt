// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 56275 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 48165 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 48165 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 48165 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 48165 0 9
// PrepareArabian ;
 140: CALL 3430 0 0
// PrepareRussian ;
 144: CALL 2554 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 57422 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6610 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 78223 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 78649 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 79044 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 79313 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 78589 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 79220 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 78649 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 79044 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 79313 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 78433 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 78589 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := false ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13742 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13742 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13742 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13742 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13742 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13742 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13742 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13742 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13742 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13742 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornell
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13742 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13742 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13742 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13742 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13742 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13742 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13742 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20375 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 60
1567: PPUSH
1568: LD_INT 6
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20375 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 3
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 75
1653: PPUSH
1654: LD_INT 6
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
// uc_side := 6 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 6
1696: ST_TO_ADDR
// uc_nation := 3 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// InitHc ;
1705: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1709: LD_ADDR_EXP 31
1713: PUSH
1714: LD_STRING Gossudarov
1716: PPUSH
1717: CALL_OW 25
1721: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1722: LD_ADDR_EXP 32
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: CALL_OW 25
1734: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1735: LD_ADDR_EXP 33
1739: PUSH
1740: LD_STRING Titov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Oblukov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1761: LD_ADDR_EXP 35
1765: PUSH
1766: LD_STRING Dolgov
1768: PPUSH
1769: CALL_OW 25
1773: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1774: LD_ADDR_EXP 36
1778: PUSH
1779: LD_STRING Petrosyan
1781: PPUSH
1782: CALL_OW 25
1786: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1787: LD_ADDR_EXP 37
1791: PUSH
1792: LD_STRING Scholtze
1794: PPUSH
1795: CALL_OW 25
1799: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1800: LD_ADDR_EXP 39
1804: PUSH
1805: LD_STRING Kapitsova
1807: PPUSH
1808: CALL_OW 25
1812: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_EXP 31
1822: PUSH
1823: LD_EXP 32
1827: PUSH
1828: LD_EXP 33
1832: PUSH
1833: LD_EXP 38
1837: PUSH
1838: LD_EXP 35
1842: PUSH
1843: LD_EXP 36
1847: PUSH
1848: LD_EXP 37
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1898
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1881: LD_VAR 0 3
1885: PPUSH
1886: LD_INT 14
1888: PPUSH
1889: LD_INT 0
1891: PPUSH
1892: CALL_OW 49
1896: GO 1878
1898: POP
1899: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1900: LD_VAR 0 2
1904: PPUSH
1905: LD_EXP 3
1909: PPUSH
1910: CALL_OW 250
1914: PPUSH
1915: LD_EXP 3
1919: PPUSH
1920: CALL_OW 251
1924: PPUSH
1925: CALL_OW 111
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareBelkov ; begin
1934: LD_INT 0
1936: PPUSH
// uc_side := 4 ;
1937: LD_ADDR_OWVAR 20
1941: PUSH
1942: LD_INT 4
1944: ST_TO_ADDR
// uc_nation := 3 ;
1945: LD_ADDR_OWVAR 21
1949: PUSH
1950: LD_INT 3
1952: ST_TO_ADDR
// InitHc ;
1953: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1957: LD_ADDR_EXP 46
1961: PUSH
1962: LD_STRING Belkov
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1970: LD_EXP 46
1974: PPUSH
1975: LD_INT 14
1977: PPUSH
1978: LD_INT 0
1980: PPUSH
1981: CALL_OW 49
// end ;
1985: LD_VAR 0 1
1989: RET
// export function PrepareGnyevko ; begin
1990: LD_INT 0
1992: PPUSH
// uc_side := 4 ;
1993: LD_ADDR_OWVAR 20
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// uc_nation := 3 ;
2001: LD_ADDR_OWVAR 21
2005: PUSH
2006: LD_INT 3
2008: ST_TO_ADDR
// InitHc ;
2009: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2013: LD_ADDR_EXP 47
2017: PUSH
2018: LD_STRING Gnyevko
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2026: LD_EXP 47
2030: PPUSH
2031: LD_INT 14
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 49
// end ;
2041: LD_VAR 0 1
2045: RET
// export function PrepareBurlak ; var i , tmp ; begin
2046: LD_INT 0
2048: PPUSH
2049: PPUSH
2050: PPUSH
// uc_side := 4 ;
2051: LD_ADDR_OWVAR 20
2055: PUSH
2056: LD_INT 4
2058: ST_TO_ADDR
// uc_nation := 3 ;
2059: LD_ADDR_OWVAR 21
2063: PUSH
2064: LD_INT 3
2066: ST_TO_ADDR
// InitHc ;
2067: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2071: LD_ADDR_EXP 45
2075: PUSH
2076: LD_STRING Burlak
2078: PPUSH
2079: CALL_OW 25
2083: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2084: LD_INT 24
2086: PUSH
2087: LD_INT 23
2089: PUSH
2090: LD_INT 22
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_OWVAR 67
2102: ARRAY
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: LD_INT 45
2112: PUSH
2113: LD_INT 44
2115: PUSH
2116: LD_INT 43
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: LIST
2123: PUSH
2124: LD_OWVAR 67
2128: ARRAY
2129: PPUSH
2130: LD_INT 0
2132: PPUSH
2133: CALL 20375 0 5
// Masha := CreateVehicle ;
2137: LD_ADDR_EXP 48
2141: PUSH
2142: CALL_OW 45
2146: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2147: LD_EXP 48
2151: PUSH
2152: LD_EXP 45
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PPUSH
2161: LD_INT 499
2163: PPUSH
2164: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2168: LD_EXP 48
2172: PPUSH
2173: LD_INT 3
2175: PPUSH
2176: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2180: LD_EXP 48
2184: PPUSH
2185: LD_INT 1
2187: PPUSH
2188: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2192: LD_EXP 48
2196: PPUSH
2197: LD_INT 18
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2207: LD_EXP 45
2211: PPUSH
2212: LD_INT 125
2214: PPUSH
2215: LD_INT 1
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2225: LD_EXP 45
2229: PPUSH
2230: LD_EXP 48
2234: PPUSH
2235: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2239: LD_INT 10
2241: PPUSH
2242: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2246: LD_EXP 48
2250: PPUSH
2251: LD_INT 110
2253: PPUSH
2254: LD_INT 10
2256: PPUSH
2257: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2261: LD_ADDR_EXP 41
2265: PUSH
2266: LD_STRING Petrovova
2268: PPUSH
2269: CALL_OW 25
2273: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2274: LD_ADDR_EXP 43
2278: PUSH
2279: LD_STRING Kuzmov
2281: PPUSH
2282: CALL_OW 25
2286: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2287: LD_ADDR_EXP 42
2291: PUSH
2292: LD_STRING Kovalyuk
2294: PPUSH
2295: CALL_OW 25
2299: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2300: LD_ADDR_EXP 40
2304: PUSH
2305: LD_STRING Lipshchin
2307: PPUSH
2308: CALL_OW 25
2312: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2313: LD_ADDR_EXP 44
2317: PUSH
2318: LD_STRING Karamazov
2320: PPUSH
2321: CALL_OW 25
2325: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: LD_EXP 41
2335: PUSH
2336: LD_EXP 43
2340: PUSH
2341: LD_EXP 42
2345: PUSH
2346: LD_EXP 40
2350: PUSH
2351: LD_EXP 44
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: ST_TO_ADDR
// for i in tmp do
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_IN
2374: IFFALSE 2413
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 399
2383: PPUSH
2384: LD_INT 799
2386: PPUSH
2387: CALL_OW 12
2391: PPUSH
2392: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2396: LD_VAR 0 2
2400: PPUSH
2401: LD_INT 19
2403: PPUSH
2404: LD_INT 0
2406: PPUSH
2407: CALL_OW 49
// end ;
2411: GO 2373
2413: POP
2414: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2415: LD_VAR 0 3
2419: PPUSH
2420: LD_INT 116
2422: PPUSH
2423: LD_INT 8
2425: PPUSH
2426: CALL_OW 111
// AddComHold ( tmp ) ;
2430: LD_VAR 0 3
2434: PPUSH
2435: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2439: LD_ADDR_VAR 0 2
2443: PUSH
2444: LD_VAR 0 3
2448: PPUSH
2449: LD_INT 25
2451: PUSH
2452: LD_INT 1
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PPUSH
2459: CALL_OW 72
2463: PUSH
2464: FOR_IN
2465: IFFALSE 2505
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2467: LD_VAR 0 2
2471: PPUSH
2472: LD_INT 20
2474: PPUSH
2475: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2479: LD_VAR 0 2
2483: PPUSH
2484: LD_INT 147
2486: PPUSH
2487: LD_INT 45
2489: PPUSH
2490: CALL_OW 178
// AddComCrawl ( i ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: CALL_OW 197
// end ;
2503: GO 2464
2505: POP
2506: POP
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) ;
2514: LD_EXP 48
2518: PPUSH
2519: LD_INT 110
2521: PPUSH
2522: LD_INT 10
2524: PPUSH
2525: CALL_OW 307
2529: IFFALSE 2507
// ComStop ( Burlak ) ;
2531: LD_EXP 45
2535: PPUSH
2536: CALL_OW 141
// AddComHold ( Burlak ) ;
2540: LD_EXP 45
2544: PPUSH
2545: CALL_OW 200
// end ; end_of_file
2549: LD_VAR 0 1
2553: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// uc_side := 3 ;
2560: LD_ADDR_OWVAR 20
2564: PUSH
2565: LD_INT 3
2567: ST_TO_ADDR
// uc_nation := 3 ;
2568: LD_ADDR_OWVAR 21
2572: PUSH
2573: LD_INT 3
2575: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2576: LD_ADDR_EXP 49
2580: PUSH
2581: LD_INT 47
2583: PPUSH
2584: LD_INT 4
2586: PPUSH
2587: LD_STRING 
2589: PPUSH
2590: LD_INT 7
2592: PUSH
2593: LD_INT 8
2595: PUSH
2596: LD_INT 9
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: PUSH
2604: LD_OWVAR 67
2608: ARRAY
2609: PPUSH
2610: LD_INT 10000
2612: PUSH
2613: LD_INT 3000
2615: PUSH
2616: LD_INT 300
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: PPUSH
2624: LD_INT 9
2626: PUSH
2627: LD_INT 5
2629: PUSH
2630: LD_INT 6
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: PPUSH
2642: CALL 23784 0 6
2646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2647: LD_ADDR_EXP 58
2651: PUSH
2652: LD_EXP 58
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: LD_EXP 49
2664: PPUSH
2665: CALL_OW 1
2669: ST_TO_ADDR
// tmp := [ ] ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: EMPTY
2676: ST_TO_ADDR
// for i = 1 to 4 do
2677: LD_ADDR_VAR 0 2
2681: PUSH
2682: DOUBLE
2683: LD_INT 1
2685: DEC
2686: ST_TO_ADDR
2687: LD_INT 4
2689: PUSH
2690: FOR_TO
2691: IFFALSE 2784
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2693: LD_INT 22
2695: PPUSH
2696: LD_INT 3
2698: PPUSH
2699: LD_INT 3
2701: PPUSH
2702: LD_INT 43
2704: PUSH
2705: LD_INT 45
2707: PUSH
2708: LD_INT 45
2710: PUSH
2711: LD_INT 44
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_INT 4
2727: MOD
2728: PUSH
2729: LD_INT 1
2731: PLUS
2732: ARRAY
2733: PPUSH
2734: LD_INT 100
2736: PPUSH
2737: CALL 20375 0 5
// veh := CreateVehicle ;
2741: LD_ADDR_VAR 0 3
2745: PUSH
2746: CALL_OW 45
2750: ST_TO_ADDR
// tmp := tmp ^ veh ;
2751: LD_ADDR_VAR 0 4
2755: PUSH
2756: LD_VAR 0 4
2760: PUSH
2761: LD_VAR 0 3
2765: ADD
2766: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 2
2774: PPUSH
2775: LD_INT 0
2777: PPUSH
2778: CALL_OW 49
// end ;
2782: GO 2690
2784: POP
2785: POP
// russian_guard := tmp ;
2786: LD_ADDR_EXP 50
2790: PUSH
2791: LD_VAR 0 4
2795: ST_TO_ADDR
// end ;
2796: LD_VAR 0 1
2800: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2801: LD_INT 47
2803: PPUSH
2804: CALL_OW 302
2808: PUSH
2809: LD_EXP 6
2813: AND
2814: IFFALSE 3427
2816: GO 2818
2818: DISABLE
2819: LD_INT 0
2821: PPUSH
2822: PPUSH
2823: PPUSH
2824: PPUSH
2825: PPUSH
2826: PPUSH
// begin enable ;
2827: ENABLE
// base := 2 ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 2
2835: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2836: LD_ADDR_VAR 0 4
2840: PUSH
2841: LD_INT 0
2843: PUSH
2844: LD_INT 0
2846: PUSH
2847: LD_INT 0
2849: PUSH
2850: LD_INT 0
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 0
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: LD_INT 0
2864: PUSH
2865: LD_INT 1
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2883: LD_ADDR_VAR 0 3
2887: PUSH
2888: LD_INT 22
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: LD_INT 45
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: LD_INT 21
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: LD_INT 3
2914: PUSH
2915: LD_INT 45
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: PUSH
2924: LD_INT 22
2926: PUSH
2927: LD_INT 1
2929: PUSH
2930: LD_INT 3
2932: PUSH
2933: LD_INT 45
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 23
2944: PUSH
2945: LD_INT 1
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: LD_INT 46
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
2966: LD_ADDR_VAR 0 1
2970: PUSH
2971: DOUBLE
2972: LD_INT 1
2974: DEC
2975: ST_TO_ADDR
2976: LD_OWVAR 67
2980: PUSH
2981: LD_OWVAR 1
2985: PUSH
2986: LD_INT 21000
2988: DIV
2989: PLUS
2990: PUSH
2991: FOR_TO
2992: IFFALSE 3080
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_VAR 0 3
3003: PPUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_INT 1
3011: PLUS
3012: PPUSH
3013: LD_INT 23
3015: PUSH
3016: LD_INT 24
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 1
3025: PPUSH
3026: LD_INT 2
3028: PPUSH
3029: CALL_OW 12
3033: ARRAY
3034: PUSH
3035: LD_INT 1
3037: PUSH
3038: LD_INT 3
3040: PUSH
3041: LD_INT 46
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 45
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 3
3060: PPUSH
3061: CALL_OW 12
3065: ARRAY
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 2
3077: ST_TO_ADDR
3078: GO 2991
3080: POP
3081: POP
// MC_SetProduceList ( base , tmp ) ;
3082: LD_VAR 0 2
3086: PPUSH
3087: LD_VAR 0 3
3091: PPUSH
3092: CALL 78541 0 2
// repeat wait ( 0 0$1 ) ;
3096: LD_INT 35
3098: PPUSH
3099: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
3103: LD_VAR 0 2
3107: PPUSH
3108: CALL 78937 0 1
3112: PUSH
3113: LD_INT 0
3115: EQUAL
3116: IFFALSE 3096
// wait ( 0 0$20 ) ;
3118: LD_INT 700
3120: PPUSH
3121: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3125: LD_ADDR_VAR 0 5
3129: PUSH
3130: LD_INT 71
3132: PUSH
3133: LD_INT 19
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: PUSH
3140: LD_INT 91
3142: PUSH
3143: LD_INT 67
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 52
3152: PUSH
3153: LD_INT 44
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: LD_INT 68
3162: PUSH
3163: LD_INT 48
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ) ;
3176: LD_ADDR_VAR 0 6
3180: PUSH
3181: LD_EXP 77
3185: PUSH
3186: LD_VAR 0 2
3190: ARRAY
3191: PUSH
3192: LD_EXP 80
3196: PUSH
3197: LD_VAR 0 2
3201: ARRAY
3202: PUSH
3203: LD_EXP 77
3207: PUSH
3208: LD_VAR 0 2
3212: ARRAY
3213: PPUSH
3214: LD_INT 2
3216: PUSH
3217: LD_INT 34
3219: PUSH
3220: LD_INT 51
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 34
3229: PUSH
3230: LD_INT 52
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 72
3246: UNION
3247: DIFF
3248: ST_TO_ADDR
// if not attackers then
3249: LD_VAR 0 6
3253: NOT
3254: IFFALSE 3258
// exit ;
3256: GO 3427
// ru_attackers := attackers ;
3258: LD_ADDR_EXP 51
3262: PUSH
3263: LD_VAR 0 6
3267: ST_TO_ADDR
// for i = 1 to attackers do
3268: LD_ADDR_VAR 0 1
3272: PUSH
3273: DOUBLE
3274: LD_INT 1
3276: DEC
3277: ST_TO_ADDR
3278: LD_VAR 0 6
3282: PUSH
3283: FOR_TO
3284: IFFALSE 3361
// begin case i mod 3 of 0 :
3286: LD_VAR 0 1
3290: PUSH
3291: LD_INT 3
3293: MOD
3294: PUSH
3295: LD_INT 0
3297: DOUBLE
3298: EQUAL
3299: IFTRUE 3303
3301: GO 3306
3303: POP
// ; 1 :
3304: GO 3359
3306: LD_INT 1
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3332
3314: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3315: LD_VAR 0 1
3319: PPUSH
3320: LD_INT 32
3322: PPUSH
3323: LD_INT 49
3325: PPUSH
3326: CALL_OW 114
3330: GO 3359
3332: LD_INT 2
3334: DOUBLE
3335: EQUAL
3336: IFTRUE 3340
3338: GO 3358
3340: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3341: LD_VAR 0 1
3345: PPUSH
3346: LD_INT 117
3348: PPUSH
3349: LD_INT 107
3351: PPUSH
3352: CALL_OW 114
3356: GO 3359
3358: POP
// end ;
3359: GO 3283
3361: POP
3362: POP
// repeat wait ( 0 0$1 ) ;
3363: LD_INT 35
3365: PPUSH
3366: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3370: LD_VAR 0 6
3374: PPUSH
3375: LD_INT 60
3377: PUSH
3378: EMPTY
3379: LIST
3380: PPUSH
3381: CALL_OW 72
3385: NOT
3386: IFFALSE 3363
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3388: LD_VAR 0 2
3392: PPUSH
3393: LD_VAR 0 6
3397: PPUSH
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_VAR 0 4
3407: PPUSH
3408: CALL 78774 0 4
// if not first_attack then
3412: LD_EXP 7
3416: NOT
3417: IFFALSE 3427
// first_attack := true ;
3419: LD_ADDR_EXP 7
3423: PUSH
3424: LD_INT 1
3426: ST_TO_ADDR
// end ; end_of_file
3427: PPOPN 6
3429: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3430: LD_INT 0
3432: PPUSH
3433: PPUSH
3434: PPUSH
3435: PPUSH
3436: PPUSH
3437: PPUSH
3438: PPUSH
// uc_side := 2 ;
3439: LD_ADDR_OWVAR 20
3443: PUSH
3444: LD_INT 2
3446: ST_TO_ADDR
// uc_nation := 2 ;
3447: LD_ADDR_OWVAR 21
3451: PUSH
3452: LD_INT 2
3454: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3455: LD_ADDR_EXP 54
3459: PUSH
3460: LD_STRING Abdul
3462: PPUSH
3463: CALL_OW 25
3467: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3468: LD_EXP 54
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3480: LD_EXP 54
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: CALL_OW 52
// vc_chassis := 31 ;
3492: LD_ADDR_OWVAR 37
3496: PUSH
3497: LD_INT 31
3499: ST_TO_ADDR
// vc_control := control_rider ;
3500: LD_ADDR_OWVAR 38
3504: PUSH
3505: LD_INT 4
3507: ST_TO_ADDR
// mastodont := CreateVehicle ;
3508: LD_ADDR_EXP 55
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3518: LD_EXP 55
3522: PPUSH
3523: LD_INT 153
3525: PPUSH
3526: LD_INT 71
3528: PPUSH
3529: LD_INT 0
3531: PPUSH
3532: CALL_OW 48
// InitVc ;
3536: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3540: LD_ADDR_EXP 52
3544: PUSH
3545: LD_INT 1
3547: PPUSH
3548: LD_INT 3
3550: PPUSH
3551: LD_STRING 
3553: PPUSH
3554: LD_INT 7
3556: PUSH
3557: LD_INT 8
3559: PUSH
3560: LD_INT 9
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: PUSH
3568: LD_OWVAR 67
3572: ARRAY
3573: PPUSH
3574: LD_INT 5000
3576: PUSH
3577: LD_INT 1000
3579: PUSH
3580: LD_INT 300
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: PPUSH
3588: LD_INT 22
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 6
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PPUSH
3606: CALL 23784 0 6
3610: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3611: LD_ADDR_EXP 58
3615: PUSH
3616: LD_EXP 58
3620: PPUSH
3621: LD_INT 1
3623: PPUSH
3624: LD_EXP 52
3628: PPUSH
3629: CALL_OW 1
3633: ST_TO_ADDR
// tmp := [ ] ;
3634: LD_ADDR_VAR 0 4
3638: PUSH
3639: EMPTY
3640: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3641: LD_ADDR_OWVAR 37
3645: PUSH
3646: LD_INT 14
3648: ST_TO_ADDR
// vc_engine := engine_siberite ;
3649: LD_ADDR_OWVAR 39
3653: PUSH
3654: LD_INT 3
3656: ST_TO_ADDR
// vc_control := control_manual ;
3657: LD_ADDR_OWVAR 38
3661: PUSH
3662: LD_INT 1
3664: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3665: LD_ADDR_OWVAR 40
3669: PUSH
3670: LD_INT 31
3672: ST_TO_ADDR
// for i = 1 to 3 do
3673: LD_ADDR_VAR 0 2
3677: PUSH
3678: DOUBLE
3679: LD_INT 1
3681: DEC
3682: ST_TO_ADDR
3683: LD_INT 3
3685: PUSH
3686: FOR_TO
3687: IFFALSE 3931
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3689: LD_ADDR_VAR 0 5
3693: PUSH
3694: LD_INT 153
3696: PUSH
3697: LD_INT 71
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 155
3706: PUSH
3707: LD_INT 81
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_VAR 0 2
3722: PUSH
3723: LD_INT 2
3725: MOD
3726: PUSH
3727: LD_INT 1
3729: PLUS
3730: ARRAY
3731: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3732: LD_INT 0
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 7
3740: PUSH
3741: LD_INT 8
3743: PUSH
3744: LD_INT 9
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: PUSH
3752: LD_OWVAR 67
3756: ARRAY
3757: PPUSH
3758: CALL_OW 380
// un := CreateVehicle ;
3762: LD_ADDR_VAR 0 6
3766: PUSH
3767: CALL_OW 45
3771: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3772: LD_VAR 0 6
3776: PPUSH
3777: LD_INT 0
3779: PPUSH
3780: LD_INT 5
3782: PPUSH
3783: CALL_OW 12
3787: PPUSH
3788: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3792: LD_VAR 0 6
3796: PPUSH
3797: LD_VAR 0 5
3801: PUSH
3802: LD_INT 1
3804: ARRAY
3805: PPUSH
3806: LD_VAR 0 5
3810: PUSH
3811: LD_INT 2
3813: ARRAY
3814: PPUSH
3815: LD_INT 6
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 50
// un2 := CreateHuman ;
3825: LD_ADDR_VAR 0 7
3829: PUSH
3830: CALL_OW 44
3834: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3835: LD_VAR 0 7
3839: PPUSH
3840: LD_VAR 0 6
3844: PPUSH
3845: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3849: LD_ADDR_EXP 58
3853: PUSH
3854: LD_EXP 58
3858: PPUSH
3859: LD_INT 1
3861: PUSH
3862: LD_EXP 58
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PUSH
3871: LD_INT 1
3873: PLUS
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: LD_VAR 0 6
3883: PPUSH
3884: CALL 20497 0 3
3888: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3889: LD_ADDR_EXP 58
3893: PUSH
3894: LD_EXP 58
3898: PPUSH
3899: LD_INT 1
3901: PUSH
3902: LD_EXP 58
3906: PUSH
3907: LD_INT 1
3909: ARRAY
3910: PUSH
3911: LD_INT 1
3913: PLUS
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: PPUSH
3919: LD_VAR 0 7
3923: PPUSH
3924: CALL 20497 0 3
3928: ST_TO_ADDR
// end ;
3929: GO 3686
3931: POP
3932: POP
// for i = 1 to 5 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 5
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4040
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3949: LD_INT 14
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 25
3960: PUSH
3961: LD_INT 28
3963: PUSH
3964: LD_INT 28
3966: PUSH
3967: LD_INT 26
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: PUSH
3976: LD_VAR 0 2
3980: PUSH
3981: LD_INT 4
3983: MOD
3984: PUSH
3985: LD_INT 1
3987: PLUS
3988: ARRAY
3989: PPUSH
3990: LD_INT 100
3992: PPUSH
3993: CALL 20375 0 5
// veh := CreateVehicle ;
3997: LD_ADDR_VAR 0 3
4001: PUSH
4002: CALL_OW 45
4006: ST_TO_ADDR
// tmp := tmp ^ veh ;
4007: LD_ADDR_VAR 0 4
4011: PUSH
4012: LD_VAR 0 4
4016: PUSH
4017: LD_VAR 0 3
4021: ADD
4022: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4023: LD_VAR 0 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 49
// end ;
4038: GO 3946
4040: POP
4041: POP
// arabian_guard := tmp ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_VAR 0 4
4051: ST_TO_ADDR
// end ;
4052: LD_VAR 0 1
4056: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4057: LD_INT 22
4059: PUSH
4060: LD_INT 7
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 91
4069: PUSH
4070: LD_INT 1
4072: PUSH
4073: LD_INT 12
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: LIST
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PPUSH
4085: CALL_OW 69
4089: PUSH
4090: LD_EXP 55
4094: PPUSH
4095: CALL_OW 256
4099: PUSH
4100: LD_INT 990
4102: LESS
4103: OR
4104: PUSH
4105: LD_EXP 54
4109: PPUSH
4110: CALL_OW 256
4114: PUSH
4115: LD_INT 990
4117: LESS
4118: OR
4119: IFFALSE 4262
4121: GO 4123
4123: DISABLE
// begin if IsInUnit ( Abdul ) then
4124: LD_EXP 54
4128: PPUSH
4129: CALL_OW 310
4133: IFFALSE 4144
// ComExitBuilding ( Abdul ) ;
4135: LD_EXP 54
4139: PPUSH
4140: CALL_OW 122
// if Mastodont then
4144: LD_EXP 55
4148: IFFALSE 4165
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4150: LD_EXP 55
4154: PPUSH
4155: LD_INT 205
4157: PPUSH
4158: LD_INT 132
4160: PPUSH
4161: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4165: LD_EXP 54
4169: PPUSH
4170: LD_INT 205
4172: PPUSH
4173: LD_INT 132
4175: PPUSH
4176: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4187: LD_EXP 54
4191: PPUSH
4192: LD_INT 21
4194: PPUSH
4195: CALL_OW 308
4199: IFFALSE 4180
// RemoveUnit ( Abdul ) ;
4201: LD_EXP 54
4205: PPUSH
4206: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4210: LD_INT 35
4212: PPUSH
4213: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4217: LD_EXP 55
4221: PPUSH
4222: LD_INT 21
4224: PPUSH
4225: CALL_OW 308
4229: PUSH
4230: LD_EXP 55
4234: PPUSH
4235: CALL_OW 301
4239: OR
4240: IFFALSE 4210
// if IsOk ( Mastodont ) then
4242: LD_EXP 55
4246: PPUSH
4247: CALL_OW 302
4251: IFFALSE 4262
// RemoveUnit ( Mastodont ) ;
4253: LD_EXP 55
4257: PPUSH
4258: CALL_OW 64
// end ;
4262: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4263: LD_EXP 54
4267: PPUSH
4268: CALL_OW 301
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 2
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 2
4285: PUSH
4286: LD_INT 25
4288: PUSH
4289: LD_INT 1
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 25
4298: PUSH
4299: LD_INT 2
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 25
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 25
4318: PUSH
4319: LD_INT 4
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 25
4328: PUSH
4329: LD_INT 8
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL_OW 69
4352: PUSH
4353: LD_INT 16
4355: PUSH
4356: LD_INT 19
4358: PUSH
4359: LD_INT 22
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PUSH
4367: LD_OWVAR 67
4371: ARRAY
4372: LESS
4373: OR
4374: IFFALSE 5047
4376: GO 4378
4378: DISABLE
4379: LD_INT 0
4381: PPUSH
4382: PPUSH
4383: PPUSH
4384: PPUSH
4385: PPUSH
4386: PPUSH
// begin MC_Kill ( 1 ) ;
4387: LD_INT 1
4389: PPUSH
4390: CALL 56510 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4394: LD_ADDR_VAR 0 2
4398: PUSH
4399: LD_INT 22
4401: PUSH
4402: LD_INT 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 25
4414: PUSH
4415: LD_INT 1
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 25
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 25
4434: PUSH
4435: LD_INT 3
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 4
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 25
4454: PUSH
4455: LD_INT 8
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 69
4478: ST_TO_ADDR
// for i in tmp do
4479: LD_ADDR_VAR 0 5
4483: PUSH
4484: LD_VAR 0 2
4488: PUSH
4489: FOR_IN
4490: IFFALSE 4506
// SetTag ( i , 10 ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_INT 10
4499: PPUSH
4500: CALL_OW 109
4504: GO 4489
4506: POP
4507: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: LD_INT 22
4515: PUSH
4516: LD_INT 2
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 21
4525: PUSH
4526: LD_INT 1
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PPUSH
4537: CALL_OW 69
4541: PUSH
4542: LD_VAR 0 2
4546: DIFF
4547: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4548: LD_ADDR_VAR 0 1
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 2
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 21
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: LD_INT 24
4575: PUSH
4576: LD_INT 300
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4593: LD_ADDR_VAR 0 4
4597: PUSH
4598: LD_VAR 0 1
4602: PPUSH
4603: LD_INT 33
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: LD_INT 58
4615: PUSH
4616: EMPTY
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 72
4627: ST_TO_ADDR
// for i in tmp do
4628: LD_ADDR_VAR 0 5
4632: PUSH
4633: LD_VAR 0 2
4637: PUSH
4638: FOR_IN
4639: IFFALSE 4823
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4641: LD_VAR 0 5
4645: PUSH
4646: LD_INT 55
4648: PUSH
4649: EMPTY
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: IN
4657: IFFALSE 4676
// begin AddComMoveXY ( i , 209 , 132 ) ;
4659: LD_VAR 0 5
4663: PPUSH
4664: LD_INT 209
4666: PPUSH
4667: LD_INT 132
4669: PPUSH
4670: CALL_OW 171
// continue ;
4674: GO 4638
// end ; if IsInUnit ( i ) then
4676: LD_VAR 0 5
4680: PPUSH
4681: CALL_OW 310
4685: IFFALSE 4703
// begin ComExitBuilding ( i ) ;
4687: LD_VAR 0 5
4691: PPUSH
4692: CALL_OW 122
// wait ( 3 ) ;
4696: LD_INT 3
4698: PPUSH
4699: CALL_OW 67
// end ; if tmp_empty then
4703: LD_VAR 0 4
4707: IFFALSE 4806
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_VAR 0 4
4718: PPUSH
4719: LD_VAR 0 5
4723: PPUSH
4724: CALL_OW 74
4728: PPUSH
4729: CALL_OW 296
4733: PUSH
4734: LD_INT 25
4736: LESS
4737: IFFALSE 4806
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4739: LD_ADDR_VAR 0 6
4743: PUSH
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 74
4758: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4759: LD_VAR 0 5
4763: PPUSH
4764: LD_VAR 0 6
4768: PPUSH
4769: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4773: LD_VAR 0 5
4777: PPUSH
4778: LD_INT 209
4780: PPUSH
4781: LD_INT 132
4783: PPUSH
4784: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4788: LD_ADDR_VAR 0 4
4792: PUSH
4793: LD_VAR 0 4
4797: PUSH
4798: LD_VAR 0 6
4802: DIFF
4803: ST_TO_ADDR
// continue ;
4804: GO 4638
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4806: LD_VAR 0 5
4810: PPUSH
4811: LD_INT 201
4813: PPUSH
4814: LD_INT 132
4816: PPUSH
4817: CALL_OW 171
// end ;
4821: GO 4638
4823: POP
4824: POP
// for i in tmp_ape do
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_VAR 0 3
4834: PUSH
4835: FOR_IN
4836: IFFALSE 4875
// begin if IsInUnit ( i ) then
4838: LD_VAR 0 5
4842: PPUSH
4843: CALL_OW 310
4847: IFFALSE 4858
// ComExitBuilding ( i ) ;
4849: LD_VAR 0 5
4853: PPUSH
4854: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_INT 201
4865: PPUSH
4866: LD_INT 132
4868: PPUSH
4869: CALL_OW 171
// end ;
4873: GO 4835
4875: POP
4876: POP
// repeat wait ( 0 0$1 ) ;
4877: LD_INT 35
4879: PPUSH
4880: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4884: LD_ADDR_VAR 0 5
4888: PUSH
4889: LD_VAR 0 2
4893: PUSH
4894: LD_VAR 0 3
4898: UNION
4899: PUSH
4900: LD_VAR 0 1
4904: UNION
4905: PUSH
4906: FOR_IN
4907: IFFALSE 4938
// if not HasTask ( i ) then
4909: LD_VAR 0 5
4913: PPUSH
4914: CALL_OW 314
4918: NOT
4919: IFFALSE 4936
// ComMoveXY ( i , 201 , 132 ) ;
4921: LD_VAR 0 5
4925: PPUSH
4926: LD_INT 201
4928: PPUSH
4929: LD_INT 132
4931: PPUSH
4932: CALL_OW 111
4936: GO 4906
4938: POP
4939: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4940: LD_INT 21
4942: PPUSH
4943: LD_INT 22
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 70
4957: IFFALSE 4998
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4959: LD_ADDR_VAR 0 5
4963: PUSH
4964: LD_INT 21
4966: PPUSH
4967: LD_INT 22
4969: PUSH
4970: LD_INT 2
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PPUSH
4977: CALL_OW 70
4981: PUSH
4982: FOR_IN
4983: IFFALSE 4996
// RemoveUnit ( i ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: CALL_OW 64
4994: GO 4982
4996: POP
4997: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
4998: LD_INT 22
5000: PUSH
5001: LD_INT 2
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: LD_INT 21
5013: PUSH
5014: LD_INT 1
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 21
5023: PUSH
5024: LD_INT 2
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: NOT
5045: IFFALSE 4877
// end ;
5047: PPOPN 6
5049: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5050: LD_EXP 9
5054: PUSH
5055: LD_INT 92
5057: PPUSH
5058: LD_INT 40
5060: PPUSH
5061: CALL_OW 428
5065: PPUSH
5066: CALL_OW 266
5070: PUSH
5071: LD_INT 30
5073: EQUAL
5074: AND
5075: IFFALSE 5271
5077: GO 5079
5079: DISABLE
5080: LD_INT 0
5082: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5083: LD_ADDR_VAR 0 1
5087: PUSH
5088: LD_EXP 58
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: PPUSH
5097: LD_INT 25
5099: PUSH
5100: LD_INT 4
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 72
5111: ST_TO_ADDR
// if not sci then
5112: LD_VAR 0 1
5116: NOT
5117: IFFALSE 5121
// exit ;
5119: GO 5271
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5121: LD_ADDR_EXP 58
5125: PUSH
5126: LD_EXP 58
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_EXP 58
5138: PUSH
5139: LD_INT 1
5141: ARRAY
5142: PUSH
5143: LD_VAR 0 1
5147: PUSH
5148: LD_INT 1
5150: ARRAY
5151: DIFF
5152: PPUSH
5153: CALL_OW 1
5157: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5158: LD_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ARRAY
5166: PPUSH
5167: CALL_OW 310
5171: IFFALSE 5186
// ComExitBuilding ( sci [ 1 ] ) ;
5173: LD_VAR 0 1
5177: PUSH
5178: LD_INT 1
5180: ARRAY
5181: PPUSH
5182: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5186: LD_INT 2
5188: PPUSH
5189: LD_INT 105
5191: PPUSH
5192: LD_INT 14
5194: PPUSH
5195: LD_INT 20
5197: PPUSH
5198: CALL 21393 0 4
5202: PUSH
5203: LD_INT 4
5205: ARRAY
5206: PUSH
5207: LD_INT 10
5209: LESS
5210: IFFALSE 5233
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5212: LD_VAR 0 1
5216: PUSH
5217: LD_INT 1
5219: ARRAY
5220: PPUSH
5221: LD_INT 105
5223: PPUSH
5224: LD_INT 14
5226: PPUSH
5227: CALL_OW 171
5231: GO 5252
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5233: LD_VAR 0 1
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PPUSH
5242: LD_INT 118
5244: PPUSH
5245: LD_INT 77
5247: PPUSH
5248: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5252: LD_VAR 0 1
5256: PUSH
5257: LD_INT 1
5259: ARRAY
5260: PPUSH
5261: LD_INT 92
5263: PPUSH
5264: LD_INT 40
5266: PPUSH
5267: CALL_OW 218
// end ;
5271: PPOPN 1
5273: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5274: LD_INT 1
5276: PPUSH
5277: CALL_OW 302
5281: PUSH
5282: LD_EXP 9
5286: AND
5287: IFFALSE 5757
5289: GO 5291
5291: DISABLE
5292: LD_INT 0
5294: PPUSH
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
5299: PPUSH
// begin enable ;
5300: ENABLE
// base := 1 ;
5301: LD_ADDR_VAR 0 2
5305: PUSH
5306: LD_INT 1
5308: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5309: LD_ADDR_VAR 0 4
5313: PUSH
5314: LD_INT 0
5316: PUSH
5317: LD_INT 0
5319: PUSH
5320: LD_INT 0
5322: PUSH
5323: LD_INT 0
5325: PUSH
5326: LD_INT 0
5328: PUSH
5329: LD_INT 0
5331: PUSH
5332: LD_INT 0
5334: PUSH
5335: LD_INT 0
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: LD_INT 0
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: LIST
5355: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5356: LD_ADDR_VAR 0 3
5360: PUSH
5361: LD_INT 14
5363: PUSH
5364: LD_INT 1
5366: PUSH
5367: LD_INT 2
5369: PUSH
5370: LD_INT 26
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 14
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: LD_INT 2
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 13
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 2
5405: PUSH
5406: LD_INT 29
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5420: LD_ADDR_VAR 0 1
5424: PUSH
5425: DOUBLE
5426: LD_INT 1
5428: DEC
5429: ST_TO_ADDR
5430: LD_OWVAR 67
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 21000
5442: DIV
5443: PLUS
5444: PUSH
5445: FOR_TO
5446: IFFALSE 5538
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5448: LD_ADDR_VAR 0 3
5452: PUSH
5453: LD_VAR 0 3
5457: PPUSH
5458: LD_VAR 0 3
5462: PUSH
5463: LD_INT 1
5465: PLUS
5466: PPUSH
5467: LD_INT 13
5469: PUSH
5470: LD_INT 14
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 1
5479: PPUSH
5480: LD_INT 2
5482: PPUSH
5483: CALL_OW 12
5487: ARRAY
5488: PUSH
5489: LD_INT 1
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: LD_INT 28
5497: PUSH
5498: LD_INT 29
5500: PUSH
5501: LD_INT 25
5503: PUSH
5504: LD_INT 26
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 1
5515: PPUSH
5516: LD_INT 4
5518: PPUSH
5519: CALL_OW 12
5523: ARRAY
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PPUSH
5531: CALL_OW 2
5535: ST_TO_ADDR
5536: GO 5445
5538: POP
5539: POP
// MC_SetProduceList ( base , tmp ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_VAR 0 3
5549: PPUSH
5550: CALL 78541 0 2
// repeat wait ( 0 0$1 ) ;
5554: LD_INT 35
5556: PPUSH
5557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL 78937 0 1
5570: PUSH
5571: LD_INT 0
5573: EQUAL
5574: IFFALSE 5554
// wait ( 0 0$20 ) ;
5576: LD_INT 700
5578: PPUSH
5579: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5583: LD_ADDR_VAR 0 5
5587: PUSH
5588: LD_INT 124
5590: PUSH
5591: LD_INT 85
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 90
5600: PUSH
5601: LD_INT 61
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 69
5610: PUSH
5611: LD_INT 48
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 68
5620: PUSH
5621: LD_INT 48
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
5634: LD_ADDR_VAR 0 6
5638: PUSH
5639: LD_EXP 77
5643: PUSH
5644: LD_VAR 0 2
5648: ARRAY
5649: PUSH
5650: LD_EXP 80
5654: PUSH
5655: LD_VAR 0 2
5659: ARRAY
5660: PUSH
5661: LD_EXP 77
5665: PUSH
5666: LD_VAR 0 2
5670: ARRAY
5671: PPUSH
5672: LD_INT 34
5674: PUSH
5675: LD_INT 32
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PPUSH
5682: CALL_OW 72
5686: UNION
5687: DIFF
5688: ST_TO_ADDR
// if not attackers then
5689: LD_VAR 0 6
5693: NOT
5694: IFFALSE 5698
// exit ;
5696: GO 5757
// ar_attackers := attackers ;
5698: LD_ADDR_EXP 10
5702: PUSH
5703: LD_VAR 0 6
5707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5715: LD_VAR 0 6
5719: PPUSH
5720: LD_INT 60
5722: PUSH
5723: EMPTY
5724: LIST
5725: PPUSH
5726: CALL_OW 72
5730: NOT
5731: IFFALSE 5708
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5733: LD_VAR 0 2
5737: PPUSH
5738: LD_VAR 0 6
5742: PPUSH
5743: LD_VAR 0 5
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL 78774 0 4
// end ;
5757: PPOPN 6
5759: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5760: LD_INT 1
5762: PPUSH
5763: CALL_OW 302
5767: PUSH
5768: LD_EXP 9
5772: AND
5773: PUSH
5774: LD_EXP 48
5778: PPUSH
5779: LD_INT 22
5781: PPUSH
5782: CALL_OW 308
5786: AND
5787: PUSH
5788: LD_INT 1
5790: PPUSH
5791: CALL 78937 0 1
5795: PUSH
5796: LD_INT 0
5798: EQUAL
5799: AND
5800: PUSH
5801: LD_EXP 10
5805: NOT
5806: AND
5807: IFFALSE 6282
5809: GO 5811
5811: DISABLE
5812: LD_INT 0
5814: PPUSH
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
// begin base := 1 ;
5821: LD_ADDR_VAR 0 2
5825: PUSH
5826: LD_INT 1
5828: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 0
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: LD_INT 0
5848: PUSH
5849: LD_INT 0
5851: PUSH
5852: LD_INT 0
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 0
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 13
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 27
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 13
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: LD_INT 25
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 11
5937: PUSH
5938: LD_INT 2
5940: PUSH
5941: LD_INT 2
5943: PUSH
5944: LD_INT 24
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 11
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 24
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// MC_SetProduceList ( base , tmp ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL 78541 0 2
// repeat wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 78937 0 1
6008: PUSH
6009: LD_INT 0
6011: EQUAL
6012: IFFALSE 5992
// wait ( 0 0$20 ) ;
6014: LD_INT 700
6016: PPUSH
6017: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6021: LD_ADDR_VAR 0 5
6025: PUSH
6026: LD_INT 119
6028: PUSH
6029: LD_INT 9
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PUSH
6036: EMPTY
6037: LIST
6038: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
6039: LD_ADDR_VAR 0 6
6043: PUSH
6044: LD_EXP 77
6048: PUSH
6049: LD_VAR 0 2
6053: ARRAY
6054: PUSH
6055: LD_EXP 80
6059: PUSH
6060: LD_VAR 0 2
6064: ARRAY
6065: PUSH
6066: LD_EXP 77
6070: PUSH
6071: LD_VAR 0 2
6075: ARRAY
6076: PPUSH
6077: LD_INT 34
6079: PUSH
6080: LD_INT 32
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: UNION
6092: DIFF
6093: ST_TO_ADDR
// if not attackers then
6094: LD_VAR 0 6
6098: NOT
6099: IFFALSE 6103
// exit ;
6101: GO 6282
// uc_side := 2 ;
6103: LD_ADDR_OWVAR 20
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// uc_nation := 2 ;
6111: LD_ADDR_OWVAR 21
6115: PUSH
6116: LD_INT 2
6118: ST_TO_ADDR
// InitHc ;
6119: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: DOUBLE
6129: LD_INT 1
6131: DEC
6132: ST_TO_ADDR
6133: LD_INT 4
6135: PUSH
6136: LD_INT 5
6138: PUSH
6139: LD_INT 6
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_OWVAR 67
6151: ARRAY
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6231
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6156: LD_INT 0
6158: PPUSH
6159: LD_INT 15
6161: PUSH
6162: LD_INT 17
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: PPUSH
6181: LD_INT 8
6183: PPUSH
6184: CALL_OW 380
// un := CreateHuman ;
6188: LD_ADDR_VAR 0 7
6192: PUSH
6193: CALL_OW 44
6197: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6198: LD_VAR 0 7
6202: PPUSH
6203: LD_INT 23
6205: PPUSH
6206: LD_INT 0
6208: PPUSH
6209: CALL_OW 49
// attackers := attackers union un ;
6213: LD_ADDR_VAR 0 6
6217: PUSH
6218: LD_VAR 0 6
6222: PUSH
6223: LD_VAR 0 7
6227: UNION
6228: ST_TO_ADDR
// end ;
6229: GO 6153
6231: POP
6232: POP
// repeat wait ( 0 0$1 ) ;
6233: LD_INT 35
6235: PPUSH
6236: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6240: LD_VAR 0 6
6244: PPUSH
6245: LD_INT 60
6247: PUSH
6248: EMPTY
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: NOT
6256: IFFALSE 6233
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6258: LD_VAR 0 2
6262: PPUSH
6263: LD_VAR 0 6
6267: PPUSH
6268: LD_VAR 0 5
6272: PPUSH
6273: LD_VAR 0 4
6277: PPUSH
6278: CALL 78774 0 4
// end ; end_of_file
6282: PPOPN 7
6284: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6285: LD_INT 0
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
// uc_side := 1 ;
6291: LD_ADDR_OWVAR 20
6295: PUSH
6296: LD_INT 1
6298: ST_TO_ADDR
// uc_nation := 1 ;
6299: LD_ADDR_OWVAR 21
6303: PUSH
6304: LD_INT 1
6306: ST_TO_ADDR
// InitHc ;
6307: CALL_OW 19
// InitVc ;
6311: CALL_OW 20
// tmp := [ ] ;
6315: LD_ADDR_VAR 0 3
6319: PUSH
6320: EMPTY
6321: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6322: LD_ADDR_VAR 0 2
6326: PUSH
6327: DOUBLE
6328: LD_INT 1
6330: DEC
6331: ST_TO_ADDR
6332: LD_INT 5
6334: PUSH
6335: LD_INT 6
6337: PUSH
6338: LD_INT 6
6340: PUSH
6341: EMPTY
6342: LIST
6343: LIST
6344: LIST
6345: PUSH
6346: LD_OWVAR 67
6350: ARRAY
6351: PUSH
6352: FOR_TO
6353: IFFALSE 6490
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6355: LD_INT 2
6357: PUSH
6358: LD_INT 4
6360: PUSH
6361: LD_INT 5
6363: PUSH
6364: EMPTY
6365: LIST
6366: LIST
6367: LIST
6368: PUSH
6369: LD_INT 1
6371: PPUSH
6372: LD_INT 3
6374: PPUSH
6375: CALL_OW 12
6379: ARRAY
6380: PPUSH
6381: LD_INT 1
6383: PUSH
6384: LD_INT 3
6386: PUSH
6387: EMPTY
6388: LIST
6389: LIST
6390: PUSH
6391: LD_INT 1
6393: PPUSH
6394: LD_INT 2
6396: PPUSH
6397: CALL_OW 12
6401: ARRAY
6402: PPUSH
6403: LD_INT 3
6405: PPUSH
6406: LD_INT 9
6408: PUSH
6409: LD_INT 7
6411: PUSH
6412: EMPTY
6413: LIST
6414: LIST
6415: PUSH
6416: LD_INT 1
6418: PPUSH
6419: LD_INT 2
6421: PPUSH
6422: CALL_OW 12
6426: ARRAY
6427: PPUSH
6428: LD_INT 78
6430: PPUSH
6431: CALL 20375 0 5
// veh := CreateVehicle ;
6435: LD_ADDR_VAR 0 4
6439: PUSH
6440: CALL_OW 45
6444: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6445: LD_VAR 0 4
6449: PPUSH
6450: LD_INT 2
6452: PPUSH
6453: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6457: LD_VAR 0 4
6461: PPUSH
6462: LD_INT 17
6464: PPUSH
6465: LD_INT 0
6467: PPUSH
6468: CALL_OW 49
// tmp := tmp ^ veh ;
6472: LD_ADDR_VAR 0 3
6476: PUSH
6477: LD_VAR 0 3
6481: PUSH
6482: LD_VAR 0 4
6486: ADD
6487: ST_TO_ADDR
// end ;
6488: GO 6352
6490: POP
6491: POP
// if not tmp then
6492: LD_VAR 0 3
6496: NOT
6497: IFFALSE 6501
// exit ;
6499: GO 6605
// if not first_powell_attack then
6501: LD_EXP 11
6505: NOT
6506: IFFALSE 6516
// first_powell_attack := true ;
6508: LD_ADDR_EXP 11
6512: PUSH
6513: LD_INT 1
6515: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6516: LD_INT 70
6518: PPUSH
6519: CALL_OW 67
// for i in tmp do
6523: LD_ADDR_VAR 0 2
6527: PUSH
6528: LD_VAR 0 3
6532: PUSH
6533: FOR_IN
6534: IFFALSE 6596
// if IsOk ( i ) then
6536: LD_VAR 0 2
6540: PPUSH
6541: CALL_OW 302
6545: IFFALSE 6578
// ComAttackUnit ( i , NearestUnitToUnit ( [ f_enemy , 1 ] , i ) ) else
6547: LD_VAR 0 2
6551: PPUSH
6552: LD_INT 81
6554: PUSH
6555: LD_INT 1
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: PPUSH
6562: LD_VAR 0 2
6566: PPUSH
6567: CALL_OW 74
6571: PPUSH
6572: CALL_OW 115
6576: GO 6594
// tmp := tmp diff i ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: LD_VAR 0 3
6587: PUSH
6588: LD_VAR 0 2
6592: DIFF
6593: ST_TO_ADDR
6594: GO 6533
6596: POP
6597: POP
// until not tmp ;
6598: LD_VAR 0 3
6602: NOT
6603: IFFALSE 6516
// end ; end_of_file
6605: LD_VAR 0 1
6609: RET
// export function Action ; var tmp , i , un ; begin
6610: LD_INT 0
6612: PPUSH
6613: PPUSH
6614: PPUSH
6615: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6616: LD_INT 68
6618: PPUSH
6619: LD_INT 39
6621: PPUSH
6622: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6626: LD_ADDR_VAR 0 2
6630: PUSH
6631: LD_INT 22
6633: PUSH
6634: LD_INT 7
6636: PUSH
6637: EMPTY
6638: LIST
6639: LIST
6640: PPUSH
6641: CALL_OW 69
6645: ST_TO_ADDR
// InGameOn ;
6646: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6650: LD_VAR 0 2
6654: PPUSH
6655: LD_INT 71
6657: PPUSH
6658: LD_INT 49
6660: PPUSH
6661: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6665: LD_INT 35
6667: PPUSH
6668: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6672: LD_INT 7
6674: PPUSH
6675: LD_INT 71
6677: PPUSH
6678: LD_INT 51
6680: PPUSH
6681: CALL_OW 293
6685: IFFALSE 6665
// DialogueOn ;
6687: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6691: LD_EXP 14
6695: PPUSH
6696: LD_STRING D1-JMM-1
6698: PPUSH
6699: CALL_OW 88
// if Joan then
6703: LD_EXP 29
6707: IFFALSE 6721
// Say ( Joan , D1-Joan-1 ) ;
6709: LD_EXP 29
6713: PPUSH
6714: LD_STRING D1-Joan-1
6716: PPUSH
6717: CALL_OW 88
// if Lisa then
6721: LD_EXP 16
6725: IFFALSE 6739
// Say ( Lisa , D1-Lisa-1 ) ;
6727: LD_EXP 16
6731: PPUSH
6732: LD_STRING D1-Lisa-1
6734: PPUSH
6735: CALL_OW 88
// if Joan or Lisa then
6739: LD_EXP 29
6743: PUSH
6744: LD_EXP 16
6748: OR
6749: IFFALSE 6763
// Say ( JMM , D1-JMM-2 ) ;
6751: LD_EXP 14
6755: PPUSH
6756: LD_STRING D1-JMM-2
6758: PPUSH
6759: CALL_OW 88
// DialogueOff ;
6763: CALL_OW 7
// InGameOff ;
6767: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6771: LD_INT 71
6773: PPUSH
6774: LD_INT 50
6776: PPUSH
6777: LD_INT 7
6779: PPUSH
6780: LD_INT 30
6782: NEG
6783: PPUSH
6784: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6788: LD_INT 71
6790: PPUSH
6791: LD_INT 50
6793: PPUSH
6794: LD_INT 7
6796: PPUSH
6797: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6801: LD_STRING M1
6803: PPUSH
6804: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6808: LD_INT 35
6810: PPUSH
6811: CALL_OW 67
// until freedom ;
6815: LD_EXP 3
6819: IFFALSE 6808
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6821: LD_INT 350
6823: PPUSH
6824: LD_INT 700
6826: PPUSH
6827: CALL_OW 12
6831: PPUSH
6832: CALL_OW 67
// PrepareGossudarov ;
6836: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6840: LD_INT 35
6842: PPUSH
6843: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6847: LD_INT 22
6849: PUSH
6850: LD_INT 6
6852: PUSH
6853: EMPTY
6854: LIST
6855: LIST
6856: PUSH
6857: LD_INT 3
6859: PUSH
6860: LD_INT 24
6862: PUSH
6863: LD_INT 1000
6865: PUSH
6866: EMPTY
6867: LIST
6868: LIST
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: EMPTY
6875: LIST
6876: LIST
6877: PPUSH
6878: CALL_OW 69
6882: PUSH
6883: LD_INT 7
6885: PPUSH
6886: LD_EXP 31
6890: PPUSH
6891: CALL_OW 292
6895: OR
6896: IFFALSE 6840
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6898: LD_ADDR_VAR 0 2
6902: PUSH
6903: LD_INT 22
6905: PUSH
6906: LD_INT 6
6908: PUSH
6909: EMPTY
6910: LIST
6911: LIST
6912: PPUSH
6913: CALL_OW 69
6917: ST_TO_ADDR
// for i in tmp do
6918: LD_ADDR_VAR 0 3
6922: PUSH
6923: LD_VAR 0 2
6927: PUSH
6928: FOR_IN
6929: IFFALSE 6945
// SetSide ( i , 7 ) ;
6931: LD_VAR 0 3
6935: PPUSH
6936: LD_INT 7
6938: PPUSH
6939: CALL_OW 235
6943: GO 6928
6945: POP
6946: POP
// DialogueOn ;
6947: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6951: LD_EXP 14
6955: PUSH
6956: LD_EXP 15
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: PPUSH
6965: LD_EXP 31
6969: PPUSH
6970: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6974: LD_EXP 31
6978: PPUSH
6979: CALL_OW 87
// if not Roth then
6983: LD_EXP 15
6987: NOT
6988: IFFALSE 7080
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
6990: LD_VAR 0 2
6994: PPUSH
6995: LD_INT 3
6997: PUSH
6998: LD_INT 24
7000: PUSH
7001: LD_INT 1000
7003: PUSH
7004: EMPTY
7005: LIST
7006: LIST
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PPUSH
7012: CALL_OW 72
7016: IFFALSE 7030
// Say ( JMM , D2-JMM-1 ) ;
7018: LD_EXP 14
7022: PPUSH
7023: LD_STRING D2-JMM-1
7025: PPUSH
7026: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7030: LD_EXP 14
7034: PPUSH
7035: LD_STRING D2-JMM-1b
7037: PPUSH
7038: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7042: LD_EXP 31
7046: PPUSH
7047: LD_STRING D2-Gos-1
7049: PPUSH
7050: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7054: LD_EXP 14
7058: PPUSH
7059: LD_STRING D2-JMM-2
7061: PPUSH
7062: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7066: LD_EXP 31
7070: PPUSH
7071: LD_STRING D2-Gos-2
7073: PPUSH
7074: CALL_OW 88
// end else
7078: GO 7232
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7080: LD_VAR 0 2
7084: PPUSH
7085: LD_INT 3
7087: PUSH
7088: LD_INT 24
7090: PUSH
7091: LD_INT 1000
7093: PUSH
7094: EMPTY
7095: LIST
7096: LIST
7097: PUSH
7098: EMPTY
7099: LIST
7100: LIST
7101: PPUSH
7102: CALL_OW 72
7106: IFFALSE 7132
// begin Say ( Roth , D2-Roth-2 ) ;
7108: LD_EXP 15
7112: PPUSH
7113: LD_STRING D2-Roth-2
7115: PPUSH
7116: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7120: LD_EXP 14
7124: PPUSH
7125: LD_STRING D2-JMM-1a
7127: PPUSH
7128: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7132: LD_EXP 15
7136: PPUSH
7137: LD_STRING D2-Roth-2a
7139: PPUSH
7140: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7144: LD_EXP 15
7148: PPUSH
7149: LD_STRING D2-Roth-2b
7151: PPUSH
7152: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7156: LD_EXP 14
7160: PPUSH
7161: LD_STRING D2-JMM-3
7163: PPUSH
7164: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7168: LD_VAR 0 2
7172: PPUSH
7173: LD_INT 3
7175: PUSH
7176: LD_INT 24
7178: PUSH
7179: LD_INT 1000
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PPUSH
7190: CALL_OW 72
7194: IFFALSE 7232
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7196: LD_EXP 31
7200: PPUSH
7201: LD_STRING D2-Gos-3
7203: PPUSH
7204: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7208: LD_EXP 14
7212: PPUSH
7213: LD_STRING D2-JMM-4
7215: PPUSH
7216: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7220: LD_EXP 31
7224: PPUSH
7225: LD_STRING D2-Gos-4
7227: PPUSH
7228: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7232: LD_EXP 14
7236: PPUSH
7237: LD_STRING D2-JMM-5
7239: PPUSH
7240: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7244: LD_EXP 31
7248: PPUSH
7249: LD_STRING D2-Gos-5
7251: PPUSH
7252: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7256: LD_EXP 14
7260: PPUSH
7261: LD_STRING D2-JMM-6
7263: PPUSH
7264: CALL_OW 88
// DialogueOff ;
7268: CALL_OW 7
// wait ( 0 0$2 ) ;
7272: LD_INT 70
7274: PPUSH
7275: CALL_OW 67
// if Kirilenkova then
7279: LD_EXP 32
7283: IFFALSE 7297
// Say ( Kirilenkova , D3-Kir-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D3-Kir-1
7292: PPUSH
7293: CALL_OW 88
// gossudarov_arrive := true ;
7297: LD_ADDR_EXP 4
7301: PUSH
7302: LD_INT 1
7304: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7305: LD_INT 35
7307: PPUSH
7308: CALL_OW 67
// until ru_lab_builded ;
7312: LD_EXP 5
7316: IFFALSE 7305
// if Kirilenkova then
7318: LD_EXP 32
7322: IFFALSE 7338
// Say ( Kirilenkova , D3a-Kir-1 ) else
7324: LD_EXP 32
7328: PPUSH
7329: LD_STRING D3a-Kir-1
7331: PPUSH
7332: CALL_OW 88
7336: GO 7360
// begin un := SciRu ;
7338: LD_ADDR_VAR 0 4
7342: PUSH
7343: CALL 12273 0 0
7347: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_STRING D3a-Sci1-1
7355: PPUSH
7356: CALL_OW 88
// end ; if Kirilenkova or un then
7360: LD_EXP 32
7364: PUSH
7365: LD_VAR 0 4
7369: OR
7370: IFFALSE 7384
// Say ( JMM , D3a-JMM-1 ) ;
7372: LD_EXP 14
7376: PPUSH
7377: LD_STRING D3a-JMM-1
7379: PPUSH
7380: CALL_OW 88
// end ;
7384: LD_VAR 0 1
7388: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7389: LD_EXP 4
7393: PUSH
7394: LD_INT 22
7396: PUSH
7397: LD_INT 7
7399: PUSH
7400: EMPTY
7401: LIST
7402: LIST
7403: PUSH
7404: LD_INT 2
7406: PUSH
7407: LD_INT 25
7409: PUSH
7410: LD_INT 1
7412: PUSH
7413: EMPTY
7414: LIST
7415: LIST
7416: PUSH
7417: LD_INT 25
7419: PUSH
7420: LD_INT 2
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: PUSH
7427: LD_INT 25
7429: PUSH
7430: LD_INT 3
7432: PUSH
7433: EMPTY
7434: LIST
7435: LIST
7436: PUSH
7437: LD_INT 25
7439: PUSH
7440: LD_INT 4
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PUSH
7447: LD_INT 25
7449: PUSH
7450: LD_INT 5
7452: PUSH
7453: EMPTY
7454: LIST
7455: LIST
7456: PUSH
7457: LD_INT 25
7459: PUSH
7460: LD_INT 8
7462: PUSH
7463: EMPTY
7464: LIST
7465: LIST
7466: PUSH
7467: LD_INT 25
7469: PUSH
7470: LD_INT 9
7472: PUSH
7473: EMPTY
7474: LIST
7475: LIST
7476: PUSH
7477: EMPTY
7478: LIST
7479: LIST
7480: LIST
7481: LIST
7482: LIST
7483: LIST
7484: LIST
7485: LIST
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PPUSH
7491: CALL_OW 69
7495: PUSH
7496: LD_INT 6
7498: LESS
7499: AND
7500: IFFALSE 7512
7502: GO 7504
7504: DISABLE
// YouLost ( TooMany ) ;
7505: LD_STRING TooMany
7507: PPUSH
7508: CALL_OW 104
7512: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7513: LD_EXP 31
7517: PPUSH
7518: CALL_OW 255
7522: PUSH
7523: LD_INT 7
7525: EQUAL
7526: IFFALSE 7726
7528: GO 7530
7530: DISABLE
7531: LD_INT 0
7533: PPUSH
7534: PPUSH
7535: PPUSH
// begin uc_side := 3 ;
7536: LD_ADDR_OWVAR 20
7540: PUSH
7541: LD_INT 3
7543: ST_TO_ADDR
// uc_nation := 3 ;
7544: LD_ADDR_OWVAR 21
7548: PUSH
7549: LD_INT 3
7551: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7552: LD_INT 21
7554: PPUSH
7555: LD_INT 3
7557: PPUSH
7558: LD_INT 3
7560: PPUSH
7561: LD_INT 42
7563: PPUSH
7564: LD_INT 100
7566: PPUSH
7567: CALL 20375 0 5
// un := CreateVehicle ;
7571: LD_ADDR_VAR 0 3
7575: PUSH
7576: CALL_OW 45
7580: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7581: LD_VAR 0 3
7585: PPUSH
7586: LD_INT 15
7588: PPUSH
7589: LD_INT 0
7591: PPUSH
7592: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7596: LD_VAR 0 3
7600: PPUSH
7601: LD_INT 67
7603: PPUSH
7604: LD_INT 45
7606: PPUSH
7607: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7611: LD_VAR 0 3
7615: PPUSH
7616: LD_INT 70
7618: PPUSH
7619: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7623: LD_VAR 0 3
7627: PPUSH
7628: LD_INT 69
7630: PPUSH
7631: LD_INT 18
7633: PPUSH
7634: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7638: LD_VAR 0 3
7642: PPUSH
7643: LD_INT 60
7645: PPUSH
7646: LD_INT 2
7648: PPUSH
7649: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7653: LD_INT 35
7655: PPUSH
7656: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7660: LD_VAR 0 3
7664: PPUSH
7665: CALL_OW 302
7669: NOT
7670: PUSH
7671: LD_VAR 0 3
7675: PPUSH
7676: LD_INT 17
7678: PPUSH
7679: CALL_OW 308
7683: OR
7684: IFFALSE 7653
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7686: LD_VAR 0 3
7690: PPUSH
7691: LD_INT 17
7693: PPUSH
7694: CALL_OW 308
7698: PUSH
7699: LD_VAR 0 3
7703: PPUSH
7704: LD_INT 60
7706: PPUSH
7707: LD_INT 2
7709: PPUSH
7710: CALL_OW 307
7714: OR
7715: IFFALSE 7726
// RemoveUnit ( un ) ;
7717: LD_VAR 0 3
7721: PPUSH
7722: CALL_OW 64
// end ;
7726: PPOPN 3
7728: END
// every 0 0$2 do var i , un , tmp ;
7729: GO 7731
7731: DISABLE
7732: LD_INT 0
7734: PPUSH
7735: PPUSH
7736: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7737: LD_INT 70
7739: PPUSH
7740: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7744: LD_ADDR_VAR 0 3
7748: PUSH
7749: LD_INT 22
7751: PUSH
7752: LD_INT 7
7754: PUSH
7755: EMPTY
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 101
7761: PUSH
7762: LD_INT 3
7764: PUSH
7765: EMPTY
7766: LIST
7767: LIST
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PPUSH
7773: CALL_OW 69
7777: ST_TO_ADDR
// until tmp ;
7778: LD_VAR 0 3
7782: IFFALSE 7737
// un := NearestUnitToUnit ( tmp , JMM ) ;
7784: LD_ADDR_VAR 0 2
7788: PUSH
7789: LD_VAR 0 3
7793: PPUSH
7794: LD_EXP 14
7798: PPUSH
7799: CALL_OW 74
7803: ST_TO_ADDR
// player_spotted := true ;
7804: LD_ADDR_EXP 6
7808: PUSH
7809: LD_INT 1
7811: ST_TO_ADDR
// tmp := SciRu ;
7812: LD_ADDR_VAR 0 3
7816: PUSH
7817: CALL 12273 0 0
7821: ST_TO_ADDR
// DialogueOn ;
7822: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7826: LD_VAR 0 2
7830: PPUSH
7831: CALL_OW 250
7835: PPUSH
7836: LD_VAR 0 2
7840: PPUSH
7841: CALL_OW 251
7845: PPUSH
7846: LD_INT 7
7848: PPUSH
7849: LD_INT 8
7851: NEG
7852: PPUSH
7853: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7857: LD_VAR 0 2
7861: PPUSH
7862: CALL_OW 87
// if tmp then
7866: LD_VAR 0 3
7870: IFFALSE 7884
// Say ( tmp , D4-RSci1-1 ) ;
7872: LD_VAR 0 3
7876: PPUSH
7877: LD_STRING D4-RSci1-1
7879: PPUSH
7880: CALL_OW 88
// if Gossudarov then
7884: LD_EXP 31
7888: IFFALSE 7914
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7890: LD_EXP 31
7894: PPUSH
7895: LD_STRING D4-Gos-1
7897: PPUSH
7898: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7902: LD_EXP 14
7906: PPUSH
7907: LD_STRING D4-JMM-1
7909: PPUSH
7910: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7914: LD_VAR 0 2
7918: PPUSH
7919: CALL_OW 250
7923: PPUSH
7924: LD_VAR 0 2
7928: PPUSH
7929: CALL_OW 251
7933: PPUSH
7934: LD_INT 7
7936: PPUSH
7937: CALL_OW 331
// DialogueOff ;
7941: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7945: LD_STRING M5
7947: PPUSH
7948: CALL_OW 337
// end ;
7952: PPOPN 3
7954: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
7955: LD_EXP 6
7959: IFFALSE 8548
7961: GO 7963
7963: DISABLE
7964: LD_INT 0
7966: PPUSH
7967: PPUSH
7968: PPUSH
// begin PrepareBelkov ;
7969: CALL 1934 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7973: LD_EXP 46
7977: PPUSH
7978: LD_INT 118
7980: PPUSH
7981: LD_INT 106
7983: PPUSH
7984: CALL_OW 111
// AddComHold ( Belkov ) ;
7988: LD_EXP 46
7992: PPUSH
7993: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
7997: LD_INT 35
7999: PPUSH
8000: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8004: LD_EXP 46
8008: PPUSH
8009: LD_INT 118
8011: PPUSH
8012: LD_INT 106
8014: PPUSH
8015: CALL_OW 307
8019: IFFALSE 7997
// ChangeSideFog ( 4 , 7 ) ;
8021: LD_INT 4
8023: PPUSH
8024: LD_INT 7
8026: PPUSH
8027: CALL_OW 343
// if IsOk ( Belkov ) then
8031: LD_EXP 46
8035: PPUSH
8036: CALL_OW 302
8040: IFFALSE 8124
// begin InGameOn ;
8042: CALL_OW 8
// DialogueOn ;
8046: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8050: LD_EXP 46
8054: PPUSH
8055: LD_STRING D5-Bel-1
8057: PPUSH
8058: CALL_OW 94
// if Gossudarov then
8062: LD_EXP 31
8066: IFFALSE 8116
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8068: LD_EXP 31
8072: PPUSH
8073: LD_STRING D5-Gos-1
8075: PPUSH
8076: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8080: LD_EXP 14
8084: PPUSH
8085: LD_STRING D5-JMM-1
8087: PPUSH
8088: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8092: LD_EXP 31
8096: PPUSH
8097: LD_STRING D5-Gos-2
8099: PPUSH
8100: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8104: LD_EXP 14
8108: PPUSH
8109: LD_STRING D5-JMM-2
8111: PPUSH
8112: CALL_OW 88
// end ; DialogueOff ;
8116: CALL_OW 7
// InGameOff ;
8120: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8124: LD_STRING QSaveBelkov
8126: PPUSH
8127: CALL_OW 97
8131: PUSH
8132: LD_INT 1
8134: DOUBLE
8135: EQUAL
8136: IFTRUE 8140
8138: GO 8190
8140: POP
// begin DialogueOn ;
8141: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8145: LD_EXP 14
8149: PPUSH
8150: LD_STRING D5a-JMM-1
8152: PPUSH
8153: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8157: LD_EXP 46
8161: PPUSH
8162: LD_STRING D5a-Bel-1
8164: PPUSH
8165: CALL_OW 94
// DialogueOff ;
8169: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8173: LD_EXP 46
8177: PPUSH
8178: LD_INT 83
8180: PPUSH
8181: LD_INT 49
8183: PPUSH
8184: CALL_OW 111
// end ; 2 :
8188: GO 8223
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8222
8198: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8199: LD_EXP 14
8203: PPUSH
8204: LD_STRING D5a-JMM-2
8206: PPUSH
8207: CALL_OW 88
// ComHold ( Belkov ) ;
8211: LD_EXP 46
8215: PPUSH
8216: CALL_OW 140
// end ; end ;
8220: GO 8223
8222: POP
// time := 0 0$00 ;
8223: LD_ADDR_VAR 0 1
8227: PUSH
8228: LD_INT 0
8230: ST_TO_ADDR
// vehSpawned := false ;
8231: LD_ADDR_VAR 0 3
8235: PUSH
8236: LD_INT 0
8238: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8239: LD_INT 35
8241: PPUSH
8242: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8246: LD_VAR 0 1
8250: PUSH
8251: LD_INT 350
8253: PUSH
8254: LD_INT 175
8256: PUSH
8257: LD_INT 70
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: LIST
8264: PUSH
8265: LD_OWVAR 67
8269: ARRAY
8270: GREATEREQUAL
8271: PUSH
8272: LD_VAR 0 3
8276: NOT
8277: AND
8278: IFFALSE 8368
// begin vehSpawned := true ;
8280: LD_ADDR_VAR 0 3
8284: PUSH
8285: LD_INT 1
8287: ST_TO_ADDR
// uc_side := 3 ;
8288: LD_ADDR_OWVAR 20
8292: PUSH
8293: LD_INT 3
8295: ST_TO_ADDR
// uc_nation := 3 ;
8296: LD_ADDR_OWVAR 21
8300: PUSH
8301: LD_INT 3
8303: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8304: LD_INT 22
8306: PPUSH
8307: LD_INT 3
8309: PPUSH
8310: LD_INT 3
8312: PPUSH
8313: LD_INT 43
8315: PPUSH
8316: LD_INT 100
8318: PPUSH
8319: CALL 20375 0 5
// veh := CreateVehicle ;
8323: LD_ADDR_VAR 0 2
8327: PUSH
8328: CALL_OW 45
8332: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8333: LD_VAR 0 2
8337: PPUSH
8338: LD_INT 130
8340: PPUSH
8341: LD_INT 131
8343: PPUSH
8344: LD_INT 0
8346: PPUSH
8347: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8351: LD_VAR 0 2
8355: PPUSH
8356: LD_INT 100
8358: PPUSH
8359: LD_INT 82
8361: PPUSH
8362: CALL_OW 114
// end else
8366: GO 8382
// time := time + 0 0$1 ;
8368: LD_ADDR_VAR 0 1
8372: PUSH
8373: LD_VAR 0 1
8377: PUSH
8378: LD_INT 35
8380: PLUS
8381: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8382: LD_EXP 46
8386: PPUSH
8387: CALL_OW 301
8391: PUSH
8392: LD_EXP 46
8396: PPUSH
8397: CALL_OW 255
8401: PUSH
8402: LD_INT 4
8404: EQUAL
8405: AND
8406: PUSH
8407: LD_INT 22
8409: PUSH
8410: LD_INT 7
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: PPUSH
8417: CALL_OW 69
8421: PPUSH
8422: LD_EXP 46
8426: PPUSH
8427: CALL_OW 74
8431: PPUSH
8432: LD_EXP 46
8436: PPUSH
8437: CALL_OW 296
8441: PUSH
8442: LD_INT 10
8444: LESS
8445: OR
8446: IFFALSE 8239
// if IsDead ( Belkov ) then
8448: LD_EXP 46
8452: PPUSH
8453: CALL_OW 301
8457: IFFALSE 8482
// begin CenterNowOnUnits ( Belkov ) ;
8459: LD_EXP 46
8463: PPUSH
8464: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8468: LD_EXP 14
8472: PPUSH
8473: LD_STRING D5a-JMM-2a
8475: PPUSH
8476: CALL_OW 88
// exit ;
8480: GO 8548
// end ; if See ( 7 , Belkov ) then
8482: LD_INT 7
8484: PPUSH
8485: LD_EXP 46
8489: PPUSH
8490: CALL_OW 292
8494: IFFALSE 8508
// SetSide ( Belkov , 7 ) ;
8496: LD_EXP 46
8500: PPUSH
8501: LD_INT 7
8503: PPUSH
8504: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8508: LD_INT 35
8510: PPUSH
8511: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8515: LD_EXP 46
8519: PPUSH
8520: LD_INT 66
8522: PPUSH
8523: LD_INT 45
8525: PPUSH
8526: CALL_OW 297
8530: PUSH
8531: LD_INT 30
8533: LESS
8534: IFFALSE 8508
// Say ( Belkov , D6-Bel-1 ) ;
8536: LD_EXP 46
8540: PPUSH
8541: LD_STRING D6-Bel-1
8543: PPUSH
8544: CALL_OW 88
// end ;
8548: PPOPN 3
8550: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8551: LD_EXP 46
8555: PPUSH
8556: CALL_OW 302
8560: PUSH
8561: LD_EXP 46
8565: PPUSH
8566: CALL_OW 504
8570: PUSH
8571: LD_INT 2
8573: PUSH
8574: LD_INT 34
8576: PUSH
8577: LD_INT 47
8579: PUSH
8580: EMPTY
8581: LIST
8582: LIST
8583: PUSH
8584: LD_INT 34
8586: PUSH
8587: LD_INT 45
8589: PUSH
8590: EMPTY
8591: LIST
8592: LIST
8593: PUSH
8594: EMPTY
8595: LIST
8596: LIST
8597: LIST
8598: PPUSH
8599: CALL_OW 69
8603: IN
8604: AND
8605: IFFALSE 8622
8607: GO 8609
8609: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8610: LD_EXP 46
8614: PPUSH
8615: LD_STRING D7-Bel-1
8617: PPUSH
8618: CALL_OW 88
8622: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8623: LD_INT 22
8625: PUSH
8626: LD_INT 7
8628: PUSH
8629: EMPTY
8630: LIST
8631: LIST
8632: PUSH
8633: LD_INT 101
8635: PUSH
8636: LD_INT 2
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: PPUSH
8647: CALL_OW 69
8651: PUSH
8652: LD_EXP 8
8656: NOT
8657: AND
8658: PUSH
8659: LD_EXP 45
8663: PPUSH
8664: CALL_OW 305
8668: NOT
8669: AND
8670: IFFALSE 9140
8672: GO 8674
8674: DISABLE
8675: LD_INT 0
8677: PPUSH
// begin ar_base_spotted := true ;
8678: LD_ADDR_EXP 8
8682: PUSH
8683: LD_INT 1
8685: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8686: LD_ADDR_VAR 0 1
8690: PUSH
8691: LD_INT 22
8693: PUSH
8694: LD_INT 2
8696: PUSH
8697: EMPTY
8698: LIST
8699: LIST
8700: PUSH
8701: LD_INT 21
8703: PUSH
8704: LD_INT 3
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PUSH
8711: EMPTY
8712: LIST
8713: LIST
8714: PPUSH
8715: CALL_OW 69
8719: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8720: LD_ADDR_VAR 0 1
8724: PUSH
8725: LD_VAR 0 1
8729: PPUSH
8730: LD_EXP 14
8734: PPUSH
8735: CALL_OW 74
8739: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8740: LD_INT 7
8742: PPUSH
8743: LD_INT 3
8745: PPUSH
8746: CALL_OW 332
// DialogueOn ;
8750: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8754: LD_VAR 0 1
8758: PPUSH
8759: CALL_OW 250
8763: PPUSH
8764: LD_VAR 0 1
8768: PPUSH
8769: CALL_OW 251
8773: PPUSH
8774: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8778: LD_ADDR_VAR 0 1
8782: PUSH
8783: LD_INT 22
8785: PUSH
8786: LD_INT 7
8788: PUSH
8789: EMPTY
8790: LIST
8791: LIST
8792: PUSH
8793: LD_INT 23
8795: PUSH
8796: LD_INT 1
8798: PUSH
8799: EMPTY
8800: LIST
8801: LIST
8802: PUSH
8803: LD_INT 26
8805: PUSH
8806: LD_INT 1
8808: PUSH
8809: EMPTY
8810: LIST
8811: LIST
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: LIST
8817: PPUSH
8818: CALL_OW 69
8822: PUSH
8823: LD_EXP 14
8827: PUSH
8828: LD_EXP 18
8832: PUSH
8833: LD_EXP 19
8837: PUSH
8838: LD_EXP 26
8842: PUSH
8843: LD_EXP 15
8847: PUSH
8848: LD_EXP 24
8852: PUSH
8853: LD_EXP 20
8857: PUSH
8858: LD_EXP 22
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: DIFF
8873: ST_TO_ADDR
// if not tmp then
8874: LD_VAR 0 1
8878: NOT
8879: IFFALSE 8953
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8881: LD_ADDR_VAR 0 1
8885: PUSH
8886: LD_INT 22
8888: PUSH
8889: LD_INT 7
8891: PUSH
8892: EMPTY
8893: LIST
8894: LIST
8895: PUSH
8896: LD_INT 23
8898: PUSH
8899: LD_INT 1
8901: PUSH
8902: EMPTY
8903: LIST
8904: LIST
8905: PUSH
8906: LD_INT 26
8908: PUSH
8909: LD_INT 2
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 29
8930: PUSH
8931: LD_EXP 16
8935: PUSH
8936: LD_EXP 27
8940: PUSH
8941: LD_EXP 28
8945: PUSH
8946: EMPTY
8947: LIST
8948: LIST
8949: LIST
8950: LIST
8951: DIFF
8952: ST_TO_ADDR
// if tmp then
8953: LD_VAR 0 1
8957: IFFALSE 9028
// case GetSex ( tmp [ 1 ] ) of sex_male :
8959: LD_VAR 0 1
8963: PUSH
8964: LD_INT 1
8966: ARRAY
8967: PPUSH
8968: CALL_OW 258
8972: PUSH
8973: LD_INT 1
8975: DOUBLE
8976: EQUAL
8977: IFTRUE 8981
8979: GO 9000
8981: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8982: LD_VAR 0 1
8986: PUSH
8987: LD_INT 1
8989: ARRAY
8990: PPUSH
8991: LD_STRING D9-Sol1-1
8993: PPUSH
8994: CALL_OW 88
8998: GO 9028
9000: LD_INT 2
9002: DOUBLE
9003: EQUAL
9004: IFTRUE 9008
9006: GO 9027
9008: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9009: LD_VAR 0 1
9013: PUSH
9014: LD_INT 1
9016: ARRAY
9017: PPUSH
9018: LD_STRING D9-FSol1-1
9020: PPUSH
9021: CALL_OW 88
9025: GO 9028
9027: POP
// if Frank then
9028: LD_EXP 26
9032: IFFALSE 9136
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9034: LD_EXP 55
9038: PPUSH
9039: CALL_OW 250
9043: PPUSH
9044: LD_EXP 55
9048: PPUSH
9049: CALL_OW 251
9053: PPUSH
9054: LD_INT 7
9056: PPUSH
9057: LD_INT 8
9059: PPUSH
9060: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9064: LD_EXP 55
9068: PPUSH
9069: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9073: LD_EXP 26
9077: PPUSH
9078: LD_STRING D9-Frank-1
9080: PPUSH
9081: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9085: LD_EXP 14
9089: PPUSH
9090: LD_STRING D9-JMM-1
9092: PPUSH
9093: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9097: LD_EXP 26
9101: PPUSH
9102: LD_STRING D9-Frank-2
9104: PPUSH
9105: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9109: LD_EXP 55
9113: PPUSH
9114: CALL_OW 250
9118: PPUSH
9119: LD_EXP 55
9123: PPUSH
9124: CALL_OW 251
9128: PPUSH
9129: LD_INT 7
9131: PPUSH
9132: CALL_OW 331
// end ; DialogueOff ;
9136: CALL_OW 7
// end ;
9140: PPOPN 1
9142: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9143: LD_EXP 7
9147: PUSH
9148: LD_OWVAR 1
9152: PUSH
9153: LD_INT 42000
9155: GREATEREQUAL
9156: OR
9157: IFFALSE 10184
9159: GO 9161
9161: DISABLE
9162: LD_INT 0
9164: PPUSH
9165: PPUSH
// begin selected_option := 1 ;
9166: LD_ADDR_VAR 0 2
9170: PUSH
9171: LD_INT 1
9173: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9174: LD_INT 10500
9176: PPUSH
9177: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9181: LD_INT 35
9183: PPUSH
9184: CALL_OW 67
// until not ru_attackers ;
9188: LD_EXP 51
9192: NOT
9193: IFFALSE 9181
// PrepareBurlak ;
9195: CALL 2046 0 0
// repeat wait ( 0 0$2 ) ;
9199: LD_INT 70
9201: PPUSH
9202: CALL_OW 67
// until not HasTask ( Burlak ) ;
9206: LD_EXP 45
9210: PPUSH
9211: CALL_OW 314
9215: NOT
9216: IFFALSE 9199
// InGameOn ;
9218: CALL_OW 8
// DialogueOn ;
9222: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9226: LD_EXP 48
9230: PPUSH
9231: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9235: LD_EXP 45
9239: PPUSH
9240: LD_STRING D10-Bur-1
9242: PPUSH
9243: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9247: LD_EXP 46
9251: PUSH
9252: LD_EXP 46
9256: PPUSH
9257: CALL_OW 255
9261: PUSH
9262: LD_INT 7
9264: EQUAL
9265: AND
9266: IFFALSE 9280
// Say ( Belkov , D10-Bel-1 ) ;
9268: LD_EXP 46
9272: PPUSH
9273: LD_STRING D10-Bel-1
9275: PPUSH
9276: CALL_OW 88
// if Gossudarov then
9280: LD_EXP 31
9284: IFFALSE 9298
// Say ( Gossudarov , D10-Gos-1 ) ;
9286: LD_EXP 31
9290: PPUSH
9291: LD_STRING D10-Gos-1
9293: PPUSH
9294: CALL_OW 88
// if Kirilenkova then
9298: LD_EXP 32
9302: IFFALSE 9316
// Say ( Kirilenkova , D10-Kir-1 ) ;
9304: LD_EXP 32
9308: PPUSH
9309: LD_STRING D10-Kir-1
9311: PPUSH
9312: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9316: CALL 12402 0 0
9320: PPUSH
9321: LD_STRING D10-RSol1-1
9323: PPUSH
9324: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9328: LD_EXP 45
9332: PPUSH
9333: LD_STRING D10-Bur-2
9335: PPUSH
9336: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9340: LD_EXP 14
9344: PPUSH
9345: LD_STRING D10-JMM-2
9347: PPUSH
9348: CALL_OW 88
// if Kirilenkova then
9352: LD_EXP 32
9356: IFFALSE 9372
// Say ( Kirilenkova , D10-Kir-2 ) else
9358: LD_EXP 32
9362: PPUSH
9363: LD_STRING D10-Kir-2
9365: PPUSH
9366: CALL_OW 88
9370: GO 9384
// Say ( SolRu , D10-RSol1-2 ) ;
9372: CALL 12402 0 0
9376: PPUSH
9377: LD_STRING D10-RSol1-2
9379: PPUSH
9380: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9384: LD_EXP 14
9388: PPUSH
9389: LD_STRING D10-JMM-3
9391: PPUSH
9392: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9396: LD_EXP 45
9400: PPUSH
9401: LD_STRING D10-Bur-3
9403: PPUSH
9404: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9408: LD_EXP 14
9412: PPUSH
9413: LD_STRING D10-JMM-4
9415: PPUSH
9416: CALL_OW 88
// DialogueOff ;
9420: CALL_OW 7
// InGameOff ;
9424: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9428: LD_STRING M2
9430: PPUSH
9431: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9435: LD_INT 35
9437: PPUSH
9438: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9442: LD_INT 22
9444: PUSH
9445: LD_INT 7
9447: PUSH
9448: EMPTY
9449: LIST
9450: LIST
9451: PUSH
9452: LD_INT 91
9454: PUSH
9455: LD_EXP 45
9459: PUSH
9460: LD_INT 8
9462: PUSH
9463: EMPTY
9464: LIST
9465: LIST
9466: LIST
9467: PUSH
9468: EMPTY
9469: LIST
9470: LIST
9471: PPUSH
9472: CALL_OW 69
9476: IFFALSE 9435
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9478: LD_ADDR_VAR 0 1
9482: PUSH
9483: LD_INT 22
9485: PUSH
9486: LD_INT 4
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: PUSH
9498: FOR_IN
9499: IFFALSE 9515
// SetSide ( i , 7 ) ;
9501: LD_VAR 0 1
9505: PPUSH
9506: LD_INT 7
9508: PPUSH
9509: CALL_OW 235
9513: GO 9498
9515: POP
9516: POP
// ChangeMissionObjectives ( M3 ) ;
9517: LD_STRING M3
9519: PPUSH
9520: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9524: LD_INT 35
9526: PPUSH
9527: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9531: LD_EXP 14
9535: PPUSH
9536: LD_EXP 45
9540: PPUSH
9541: CALL_OW 296
9545: PUSH
9546: LD_INT 8
9548: LESS
9549: IFFALSE 9524
// ComTurnUnit ( JMM , Burlak ) ;
9551: LD_EXP 14
9555: PPUSH
9556: LD_EXP 45
9560: PPUSH
9561: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9565: LD_EXP 45
9569: PPUSH
9570: LD_EXP 14
9574: PPUSH
9575: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9579: LD_INT 10
9581: PPUSH
9582: CALL_OW 67
// DialogueOn ;
9586: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9590: LD_EXP 14
9594: PPUSH
9595: LD_STRING D11-JMM-1
9597: PPUSH
9598: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9602: LD_EXP 45
9606: PPUSH
9607: LD_STRING D11-Bur-1
9609: PPUSH
9610: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9614: LD_EXP 14
9618: PPUSH
9619: LD_STRING D11-JMM-2
9621: PPUSH
9622: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9626: LD_EXP 45
9630: PPUSH
9631: LD_STRING D11-Bur-2
9633: PPUSH
9634: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9638: LD_EXP 14
9642: PPUSH
9643: LD_STRING D11-JMM-3
9645: PPUSH
9646: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9650: LD_EXP 45
9654: PPUSH
9655: LD_STRING D11-Bur-3
9657: PPUSH
9658: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9662: LD_EXP 14
9666: PPUSH
9667: LD_STRING D11-JMM-4
9669: PPUSH
9670: CALL_OW 88
// if ar_base_spotted then
9674: LD_EXP 8
9678: IFFALSE 9694
// Say ( Burlak , D12-Bur-1 ) else
9680: LD_EXP 45
9684: PPUSH
9685: LD_STRING D12-Bur-1
9687: PPUSH
9688: CALL_OW 88
9692: GO 9733
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9694: LD_INT 7
9696: PPUSH
9697: LD_INT 3
9699: PPUSH
9700: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9704: LD_INT 127
9706: PPUSH
9707: LD_INT 45
9709: PPUSH
9710: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9714: LD_EXP 45
9718: PPUSH
9719: LD_STRING D12-Bur-1a
9721: PPUSH
9722: CALL_OW 88
// dwait ( 0 0$2 ) ;
9726: LD_INT 70
9728: PPUSH
9729: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9733: LD_EXP 45
9737: PPUSH
9738: LD_STRING D12-Bur-1b
9740: PPUSH
9741: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9745: LD_EXP 14
9749: PPUSH
9750: LD_STRING D12-JMM-1
9752: PPUSH
9753: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9757: LD_EXP 45
9761: PPUSH
9762: LD_STRING D12-Bur-2
9764: PPUSH
9765: CALL_OW 88
// if Roth then
9769: LD_EXP 15
9773: IFFALSE 9789
// Say ( Roth , D12-Roth-2 ) else
9775: LD_EXP 15
9779: PPUSH
9780: LD_STRING D12-Roth-2
9782: PPUSH
9783: CALL_OW 88
9787: GO 9801
// Say ( SciRu , D12-RSci1-2 ) ;
9789: CALL 12273 0 0
9793: PPUSH
9794: LD_STRING D12-RSci1-2
9796: PPUSH
9797: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9801: LD_EXP 14
9805: PPUSH
9806: LD_STRING D12-JMM-2
9808: PPUSH
9809: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9813: LD_EXP 45
9817: PPUSH
9818: LD_STRING D12-Bur-3
9820: PPUSH
9821: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9825: LD_EXP 14
9829: PPUSH
9830: LD_STRING D12-JMM-3
9832: PPUSH
9833: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9837: LD_EXP 45
9841: PPUSH
9842: LD_STRING D12-Bur-4
9844: PPUSH
9845: CALL_OW 88
// case Query ( QBase ) of 1 :
9849: LD_STRING QBase
9851: PPUSH
9852: CALL_OW 97
9856: PUSH
9857: LD_INT 1
9859: DOUBLE
9860: EQUAL
9861: IFTRUE 9865
9863: GO 9983
9865: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9866: LD_EXP 14
9870: PPUSH
9871: LD_STRING D13a-JMM-1
9873: PPUSH
9874: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9878: LD_EXP 45
9882: PPUSH
9883: LD_STRING D13a-Bur-1
9885: PPUSH
9886: CALL_OW 88
// if Roth then
9890: LD_EXP 15
9894: IFFALSE 9910
// Say ( Roth , D13a-Roth-1 ) else
9896: LD_EXP 15
9900: PPUSH
9901: LD_STRING D13a-Roth-1
9903: PPUSH
9904: CALL_OW 88
9908: GO 9922
// Say ( SciRu , D13a-RSci1-1 ) ;
9910: CALL 12273 0 0
9914: PPUSH
9915: LD_STRING D13a-RSci1-1
9917: PPUSH
9918: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9922: LD_EXP 14
9926: PPUSH
9927: LD_STRING D13a-JMM-2
9929: PPUSH
9930: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9934: LD_STRING QBaseAgain
9936: PPUSH
9937: CALL_OW 97
9941: PUSH
9942: LD_INT 1
9944: DOUBLE
9945: EQUAL
9946: IFTRUE 9950
9948: GO 9961
9950: POP
// selected_option := 2 ; 2 :
9951: LD_ADDR_VAR 0 2
9955: PUSH
9956: LD_INT 2
9958: ST_TO_ADDR
9959: GO 9981
9961: LD_INT 2
9963: DOUBLE
9964: EQUAL
9965: IFTRUE 9969
9967: GO 9980
9969: POP
// selected_option := 3 ; end ;
9970: LD_ADDR_VAR 0 2
9974: PUSH
9975: LD_INT 3
9977: ST_TO_ADDR
9978: GO 9981
9980: POP
// end ; 2 :
9981: GO 10022
9983: LD_INT 2
9985: DOUBLE
9986: EQUAL
9987: IFTRUE 9991
9989: GO 10002
9991: POP
// selected_option := 2 ; 3 :
9992: LD_ADDR_VAR 0 2
9996: PUSH
9997: LD_INT 2
9999: ST_TO_ADDR
10000: GO 10022
10002: LD_INT 3
10004: DOUBLE
10005: EQUAL
10006: IFTRUE 10010
10008: GO 10021
10010: POP
// selected_option := 3 ; end ;
10011: LD_ADDR_VAR 0 2
10015: PUSH
10016: LD_INT 3
10018: ST_TO_ADDR
10019: GO 10022
10021: POP
// if selected_option = 2 then
10022: LD_VAR 0 2
10026: PUSH
10027: LD_INT 2
10029: EQUAL
10030: IFFALSE 10124
// begin Say ( JMM , D13b-JMM-1 ) ;
10032: LD_EXP 14
10036: PPUSH
10037: LD_STRING D13b-JMM-1
10039: PPUSH
10040: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10044: LD_EXP 45
10048: PPUSH
10049: LD_STRING D13b-Bur-1
10051: PPUSH
10052: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10056: LD_EXP 14
10060: PPUSH
10061: LD_STRING D13b-JMM-2
10063: PPUSH
10064: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10068: LD_EXP 54
10072: PPUSH
10073: LD_STRING D13b-Abd-2
10075: PPUSH
10076: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10080: LD_EXP 14
10084: PPUSH
10085: LD_STRING D13b-JMM-3
10087: PPUSH
10088: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10092: LD_EXP 54
10096: PPUSH
10097: LD_STRING D13b-Abd-3
10099: PPUSH
10100: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10104: LD_EXP 14
10108: PPUSH
10109: LD_STRING D13b-JMM-4
10111: PPUSH
10112: CALL_OW 88
// ar_active_attack := true ;
10116: LD_ADDR_EXP 9
10120: PUSH
10121: LD_INT 1
10123: ST_TO_ADDR
// end ; if selected_option = 3 then
10124: LD_VAR 0 2
10128: PUSH
10129: LD_INT 3
10131: EQUAL
10132: IFFALSE 10158
// begin Say ( JMM , D13c-JMM-1 ) ;
10134: LD_EXP 14
10138: PPUSH
10139: LD_STRING D13c-JMM-1
10141: PPUSH
10142: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10146: LD_EXP 45
10150: PPUSH
10151: LD_STRING D13c-Bur-1
10153: PPUSH
10154: CALL_OW 88
// end ; DialogueOff ;
10158: CALL_OW 7
// if not ar_active_attack then
10162: LD_EXP 9
10166: NOT
10167: IFFALSE 10184
// begin wait ( 6 6$00 ) ;
10169: LD_INT 12600
10171: PPUSH
10172: CALL_OW 67
// ar_active_attack := true ;
10176: LD_ADDR_EXP 9
10180: PUSH
10181: LD_INT 1
10183: ST_TO_ADDR
// end ; end ;
10184: PPOPN 2
10186: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do
10187: LD_EXP 45
10191: PPUSH
10192: CALL_OW 305
10196: PUSH
10197: LD_EXP 45
10201: PPUSH
10202: CALL_OW 255
10206: PUSH
10207: LD_INT 7
10209: EQUAL
10210: AND
10211: IFFALSE 10372
10213: GO 10215
10215: DISABLE
// begin wait ( 4 4$40 ) ;
10216: LD_INT 9800
10218: PPUSH
10219: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10223: LD_INT 35
10225: PPUSH
10226: CALL_OW 67
// until not ru_attackers ;
10230: LD_EXP 51
10234: NOT
10235: IFFALSE 10223
// PrepareGnyevko ;
10237: CALL 1990 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10241: LD_EXP 47
10245: PPUSH
10246: LD_INT 124
10248: PPUSH
10249: LD_INT 118
10251: PPUSH
10252: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10256: LD_EXP 47
10260: PPUSH
10261: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10265: LD_INT 35
10267: PPUSH
10268: CALL_OW 67
// until IsAt ( Gnyevko , 124 , 118 ) ;
10272: LD_EXP 47
10276: PPUSH
10277: LD_INT 124
10279: PPUSH
10280: LD_INT 118
10282: PPUSH
10283: CALL_OW 307
10287: IFFALSE 10265
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10289: LD_EXP 47
10293: PPUSH
10294: LD_STRING DBelkov-Gny-1
10296: PPUSH
10297: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10301: LD_EXP 45
10305: PPUSH
10306: LD_STRING DBelkov-Bur-1a
10308: PPUSH
10309: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10313: LD_INT 35
10315: PPUSH
10316: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10320: LD_EXP 47
10324: PPUSH
10325: LD_INT 22
10327: PUSH
10328: LD_INT 7
10330: PUSH
10331: EMPTY
10332: LIST
10333: LIST
10334: PPUSH
10335: CALL_OW 69
10339: PPUSH
10340: LD_EXP 47
10344: PPUSH
10345: CALL_OW 74
10349: PPUSH
10350: CALL_OW 296
10354: PUSH
10355: LD_INT 8
10357: LESS
10358: IFFALSE 10313
// SetSide ( Gnyevko , 7 ) ;
10360: LD_EXP 47
10364: PPUSH
10365: LD_INT 7
10367: PPUSH
10368: CALL_OW 235
// end ;
10372: END
// every 10 10$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10373: LD_EXP 45
10377: PPUSH
10378: CALL_OW 255
10382: PUSH
10383: LD_INT 7
10385: EQUAL
10386: IFFALSE 10396
10388: GO 10390
10390: DISABLE
// begin enable ;
10391: ENABLE
// PrepareAmericanAttack ;
10392: CALL 6285 0 0
// end ;
10396: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10397: LD_INT 22
10399: PUSH
10400: LD_INT 1
10402: PUSH
10403: EMPTY
10404: LIST
10405: LIST
10406: PPUSH
10407: CALL_OW 69
10411: IFFALSE 10595
10413: GO 10415
10415: DISABLE
10416: LD_INT 0
10418: PPUSH
10419: PPUSH
// begin while true do
10420: LD_INT 1
10422: IFFALSE 10479
// begin wait ( 0 0$1 ) ;
10424: LD_INT 35
10426: PPUSH
10427: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10431: LD_ADDR_VAR 0 2
10435: PUSH
10436: LD_INT 22
10438: PUSH
10439: LD_INT 1
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: PPUSH
10446: CALL_OW 69
10450: PPUSH
10451: LD_EXP 14
10455: PPUSH
10456: CALL_OW 74
10460: ST_TO_ADDR
// if See ( 7 , tmp ) then
10461: LD_INT 7
10463: PPUSH
10464: LD_VAR 0 2
10468: PPUSH
10469: CALL_OW 292
10473: IFFALSE 10477
// break ;
10475: GO 10479
// end ;
10477: GO 10420
// DialogueOn ;
10479: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10483: LD_VAR 0 2
10487: PPUSH
10488: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10492: LD_VAR 0 2
10496: PPUSH
10497: CALL_OW 250
10501: PPUSH
10502: LD_VAR 0 2
10506: PPUSH
10507: CALL_OW 251
10511: PPUSH
10512: LD_INT 7
10514: PPUSH
10515: LD_INT 8
10517: PPUSH
10518: CALL_OW 330
// if Denis then
10522: LD_EXP 20
10526: IFFALSE 10540
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10528: LD_EXP 20
10532: PPUSH
10533: LD_STRING DAmerAttack-Pet-1
10535: PPUSH
10536: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10540: LD_EXP 14
10544: PPUSH
10545: LD_STRING DAmerAttack-JMM-1
10547: PPUSH
10548: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10552: LD_EXP 45
10556: PPUSH
10557: LD_STRING DStop-Bur-1
10559: PPUSH
10560: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10564: LD_VAR 0 2
10568: PPUSH
10569: CALL_OW 250
10573: PPUSH
10574: LD_VAR 0 2
10578: PPUSH
10579: CALL_OW 251
10583: PPUSH
10584: LD_INT 7
10586: PPUSH
10587: CALL_OW 331
// DialogueOff ;
10591: CALL_OW 7
// end ;
10595: PPOPN 2
10597: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10598: LD_INT 22
10600: PUSH
10601: LD_INT 3
10603: PUSH
10604: EMPTY
10605: LIST
10606: LIST
10607: PUSH
10608: LD_INT 21
10610: PUSH
10611: LD_INT 1
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: EMPTY
10619: LIST
10620: LIST
10621: PPUSH
10622: CALL_OW 69
10626: PUSH
10627: LD_INT 0
10629: EQUAL
10630: IFFALSE 10672
10632: GO 10634
10634: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10635: LD_STRING M5a
10637: PPUSH
10638: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10642: LD_EXP 14
10646: PPUSH
10647: LD_STRING D8-JMM-1
10649: PPUSH
10650: CALL_OW 88
// if Gossudarov then
10654: LD_EXP 31
10658: IFFALSE 10672
// Say ( Gossudarov , D8-Gos-1 ) ;
10660: LD_EXP 31
10664: PPUSH
10665: LD_STRING D8-Gos-1
10667: PPUSH
10668: CALL_OW 88
// end ;
10672: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10673: LD_INT 22
10675: PUSH
10676: LD_INT 2
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 21
10685: PUSH
10686: LD_INT 1
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: EMPTY
10694: LIST
10695: LIST
10696: PPUSH
10697: CALL_OW 69
10701: PUSH
10702: LD_INT 0
10704: EQUAL
10705: IFFALSE 10755
10707: GO 10709
10709: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10710: LD_STRING M4c
10712: PPUSH
10713: CALL_OW 337
// if Roth then
10717: LD_EXP 15
10721: IFFALSE 10737
// Say ( Roth , DStop-Roth-1 ) else
10723: LD_EXP 15
10727: PPUSH
10728: LD_STRING DStop-Roth-1
10730: PPUSH
10731: CALL_OW 88
10735: GO 10755
// if Gossudarov then
10737: LD_EXP 31
10741: IFFALSE 10755
// Say ( Gossudarov , D8-Gos-1a ) ;
10743: LD_EXP 31
10747: PPUSH
10748: LD_STRING D8-Gos-1a
10750: PPUSH
10751: CALL_OW 88
// end ;
10755: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10756: LD_INT 7
10758: PPUSH
10759: LD_INT 1
10761: PPUSH
10762: LD_INT 1
10764: PPUSH
10765: CALL 13805 0 3
10769: PUSH
10770: LD_INT 0
10772: EQUAL
10773: PUSH
10774: LD_INT 7
10776: PPUSH
10777: LD_INT 3
10779: PPUSH
10780: LD_INT 1
10782: PPUSH
10783: CALL 13805 0 3
10787: PUSH
10788: LD_INT 0
10790: EQUAL
10791: AND
10792: IFFALSE 10804
10794: GO 10796
10796: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10797: LD_STRING M1a
10799: PPUSH
10800: CALL_OW 337
// end ;
10804: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10805: LD_INT 22
10807: PUSH
10808: LD_INT 2
10810: PUSH
10811: EMPTY
10812: LIST
10813: LIST
10814: PUSH
10815: LD_INT 21
10817: PUSH
10818: LD_INT 1
10820: PUSH
10821: EMPTY
10822: LIST
10823: LIST
10824: PUSH
10825: EMPTY
10826: LIST
10827: LIST
10828: PPUSH
10829: CALL_OW 69
10833: PUSH
10834: LD_INT 0
10836: EQUAL
10837: PUSH
10838: LD_INT 22
10840: PUSH
10841: LD_INT 3
10843: PUSH
10844: EMPTY
10845: LIST
10846: LIST
10847: PUSH
10848: LD_INT 21
10850: PUSH
10851: LD_INT 1
10853: PUSH
10854: EMPTY
10855: LIST
10856: LIST
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: PPUSH
10862: CALL_OW 69
10866: PUSH
10867: LD_INT 0
10869: EQUAL
10870: AND
10871: PUSH
10872: LD_INT 22
10874: PUSH
10875: LD_INT 1
10877: PUSH
10878: EMPTY
10879: LIST
10880: LIST
10881: PPUSH
10882: CALL_OW 69
10886: PUSH
10887: LD_INT 0
10889: EQUAL
10890: AND
10891: PUSH
10892: LD_INT 7
10894: PPUSH
10895: LD_INT 1
10897: PPUSH
10898: LD_INT 1
10900: PPUSH
10901: CALL 13805 0 3
10905: PUSH
10906: LD_INT 0
10908: EQUAL
10909: AND
10910: PUSH
10911: LD_INT 7
10913: PPUSH
10914: LD_INT 3
10916: PPUSH
10917: LD_INT 1
10919: PPUSH
10920: CALL 13805 0 3
10924: PUSH
10925: LD_INT 0
10927: EQUAL
10928: AND
10929: IFFALSE 12270
10931: GO 10933
10933: DISABLE
10934: LD_INT 0
10936: PPUSH
10937: PPUSH
10938: PPUSH
// begin wait ( 0 0$3 ) ;
10939: LD_INT 105
10941: PPUSH
10942: CALL_OW 67
// if not IsDead ( Masha ) then
10946: LD_EXP 48
10950: PPUSH
10951: CALL_OW 301
10955: NOT
10956: IFFALSE 10970
// AddMedal ( Masha , 1 ) else
10958: LD_STRING Masha
10960: PPUSH
10961: LD_INT 1
10963: PPUSH
10964: CALL_OW 101
10968: GO 10981
// AddMedal ( Masha , - 1 ) ;
10970: LD_STRING Masha
10972: PPUSH
10973: LD_INT 1
10975: NEG
10976: PPUSH
10977: CALL_OW 101
// if abdul_escaped then
10981: LD_EXP 12
10985: IFFALSE 11000
// AddMedal ( Abdul , - 1 ) else
10987: LD_STRING Abdul
10989: PPUSH
10990: LD_INT 1
10992: NEG
10993: PPUSH
10994: CALL_OW 101
10998: GO 11010
// AddMedal ( Abdul , 1 ) ;
11000: LD_STRING Abdul
11002: PPUSH
11003: LD_INT 1
11005: PPUSH
11006: CALL_OW 101
// if loss_counter = 0 then
11010: LD_EXP 13
11014: PUSH
11015: LD_INT 0
11017: EQUAL
11018: IFFALSE 11032
// AddMedal ( People , 2 ) else
11020: LD_STRING People
11022: PPUSH
11023: LD_INT 2
11025: PPUSH
11026: CALL_OW 101
11030: GO 11082
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11032: LD_EXP 13
11036: PUSH
11037: LD_INT 3
11039: PUSH
11040: LD_INT 2
11042: PUSH
11043: LD_INT 2
11045: PUSH
11046: EMPTY
11047: LIST
11048: LIST
11049: LIST
11050: PUSH
11051: LD_OWVAR 67
11055: ARRAY
11056: LESSEQUAL
11057: IFFALSE 11071
// AddMedal ( People , 1 ) else
11059: LD_STRING People
11061: PPUSH
11062: LD_INT 1
11064: PPUSH
11065: CALL_OW 101
11069: GO 11082
// AddMedal ( People , - 1 ) ;
11071: LD_STRING People
11073: PPUSH
11074: LD_INT 1
11076: NEG
11077: PPUSH
11078: CALL_OW 101
// GiveMedals ( MAIN ) ;
11082: LD_STRING MAIN
11084: PPUSH
11085: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11089: LD_ADDR_VAR 0 2
11093: PUSH
11094: LD_INT 22
11096: PUSH
11097: LD_INT 7
11099: PUSH
11100: EMPTY
11101: LIST
11102: LIST
11103: PUSH
11104: LD_INT 2
11106: PUSH
11107: LD_INT 25
11109: PUSH
11110: LD_INT 1
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: PUSH
11117: LD_INT 25
11119: PUSH
11120: LD_INT 2
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: PUSH
11127: LD_INT 25
11129: PUSH
11130: LD_INT 3
11132: PUSH
11133: EMPTY
11134: LIST
11135: LIST
11136: PUSH
11137: LD_INT 25
11139: PUSH
11140: LD_INT 4
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: PUSH
11147: LD_INT 25
11149: PUSH
11150: LD_INT 5
11152: PUSH
11153: EMPTY
11154: LIST
11155: LIST
11156: PUSH
11157: LD_INT 25
11159: PUSH
11160: LD_INT 8
11162: PUSH
11163: EMPTY
11164: LIST
11165: LIST
11166: PUSH
11167: LD_INT 25
11169: PUSH
11170: LD_INT 9
11172: PUSH
11173: EMPTY
11174: LIST
11175: LIST
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: LIST
11183: LIST
11184: LIST
11185: LIST
11186: PUSH
11187: EMPTY
11188: LIST
11189: LIST
11190: PPUSH
11191: CALL_OW 69
11195: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11196: LD_VAR 0 2
11200: PPUSH
11201: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11205: LD_ADDR_VAR 0 3
11209: PUSH
11210: LD_EXP 14
11214: PUSH
11215: LD_EXP 15
11219: PUSH
11220: LD_EXP 16
11224: PUSH
11225: LD_EXP 17
11229: PUSH
11230: LD_EXP 18
11234: PUSH
11235: LD_EXP 19
11239: PUSH
11240: LD_EXP 20
11244: PUSH
11245: LD_EXP 21
11249: PUSH
11250: LD_EXP 22
11254: PUSH
11255: LD_EXP 23
11259: PUSH
11260: LD_EXP 24
11264: PUSH
11265: LD_EXP 25
11269: PUSH
11270: LD_EXP 26
11274: PUSH
11275: LD_EXP 27
11279: PUSH
11280: LD_EXP 28
11284: PUSH
11285: LD_EXP 29
11289: PUSH
11290: LD_EXP 30
11294: PUSH
11295: LD_EXP 31
11299: PUSH
11300: LD_EXP 32
11304: PUSH
11305: LD_EXP 33
11309: PUSH
11310: LD_EXP 35
11314: PUSH
11315: LD_EXP 36
11319: PUSH
11320: LD_EXP 37
11324: PUSH
11325: LD_EXP 38
11329: PUSH
11330: LD_EXP 39
11334: PUSH
11335: LD_EXP 40
11339: PUSH
11340: LD_EXP 41
11344: PUSH
11345: LD_EXP 42
11349: PUSH
11350: LD_EXP 43
11354: PUSH
11355: LD_EXP 44
11359: PUSH
11360: LD_EXP 45
11364: PUSH
11365: LD_EXP 46
11369: PUSH
11370: LD_EXP 47
11374: PUSH
11375: EMPTY
11376: LIST
11377: LIST
11378: LIST
11379: LIST
11380: LIST
11381: LIST
11382: LIST
11383: LIST
11384: LIST
11385: LIST
11386: LIST
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: LIST
11392: LIST
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: LIST
11407: LIST
11408: LIST
11409: ST_TO_ADDR
// if tmp diff tmp2 then
11410: LD_VAR 0 2
11414: PUSH
11415: LD_VAR 0 3
11419: DIFF
11420: IFFALSE 11440
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11422: LD_VAR 0 2
11426: PUSH
11427: LD_VAR 0 3
11431: DIFF
11432: PPUSH
11433: LD_STRING 13a_others
11435: PPUSH
11436: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11440: LD_EXP 14
11444: PPUSH
11445: LD_STRING 13a_JMM
11447: PPUSH
11448: CALL_OW 38
// if Titov then
11452: LD_EXP 33
11456: IFFALSE 11470
// SaveCharacters ( Titov , 13a_Titov ) ;
11458: LD_EXP 33
11462: PPUSH
11463: LD_STRING 13a_Titov
11465: PPUSH
11466: CALL_OW 38
// if Dolgov then
11470: LD_EXP 35
11474: IFFALSE 11488
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11476: LD_EXP 35
11480: PPUSH
11481: LD_STRING 13a_Dolgov
11483: PPUSH
11484: CALL_OW 38
// if Petrosyan then
11488: LD_EXP 36
11492: IFFALSE 11506
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11494: LD_EXP 36
11498: PPUSH
11499: LD_STRING 13a_Petrosyan
11501: PPUSH
11502: CALL_OW 38
// if Scholtze then
11506: LD_EXP 37
11510: IFFALSE 11524
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11512: LD_EXP 37
11516: PPUSH
11517: LD_STRING 13a_Scholtze
11519: PPUSH
11520: CALL_OW 38
// if Oblukov then
11524: LD_EXP 38
11528: IFFALSE 11542
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11530: LD_EXP 38
11534: PPUSH
11535: LD_STRING 13a_Oblukov
11537: PPUSH
11538: CALL_OW 38
// if Kapitsova then
11542: LD_EXP 39
11546: IFFALSE 11560
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11548: LD_EXP 39
11552: PPUSH
11553: LD_STRING 13a_Kapitsova
11555: PPUSH
11556: CALL_OW 38
// if Lipshchin then
11560: LD_EXP 40
11564: IFFALSE 11578
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11566: LD_EXP 40
11570: PPUSH
11571: LD_STRING 13a_Lipshchin
11573: PPUSH
11574: CALL_OW 38
// if Petrovova then
11578: LD_EXP 41
11582: IFFALSE 11596
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11584: LD_EXP 41
11588: PPUSH
11589: LD_STRING 13a_Petrovova
11591: PPUSH
11592: CALL_OW 38
// if Kovalyuk then
11596: LD_EXP 42
11600: IFFALSE 11614
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11602: LD_EXP 42
11606: PPUSH
11607: LD_STRING 13a_Kovalyuk
11609: PPUSH
11610: CALL_OW 38
// if Kuzmov then
11614: LD_EXP 43
11618: IFFALSE 11632
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11620: LD_EXP 43
11624: PPUSH
11625: LD_STRING 13a_Kuzmov
11627: PPUSH
11628: CALL_OW 38
// if Karamazov then
11632: LD_EXP 44
11636: IFFALSE 11650
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11638: LD_EXP 44
11642: PPUSH
11643: LD_STRING 13a_Karamazov
11645: PPUSH
11646: CALL_OW 38
// if Burlak then
11650: LD_EXP 45
11654: IFFALSE 11668
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11656: LD_EXP 45
11660: PPUSH
11661: LD_STRING 13a_Burlak
11663: PPUSH
11664: CALL_OW 38
// if Belkov then
11668: LD_EXP 46
11672: IFFALSE 11686
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11674: LD_EXP 46
11678: PPUSH
11679: LD_STRING 13a_Belkov
11681: PPUSH
11682: CALL_OW 38
// if Gnyevko then
11686: LD_EXP 47
11690: IFFALSE 11704
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11692: LD_EXP 47
11696: PPUSH
11697: LD_STRING 13a_Gnyevko
11699: PPUSH
11700: CALL_OW 38
// if Lisa then
11704: LD_EXP 16
11708: IFFALSE 11722
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11710: LD_EXP 16
11714: PPUSH
11715: LD_STRING 13a_Lisa
11717: PPUSH
11718: CALL_OW 38
// if Donaldson then
11722: LD_EXP 17
11726: IFFALSE 11740
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11728: LD_EXP 17
11732: PPUSH
11733: LD_STRING 13a_Donaldson
11735: PPUSH
11736: CALL_OW 38
// if Bobby then
11740: LD_EXP 18
11744: IFFALSE 11758
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11746: LD_EXP 18
11750: PPUSH
11751: LD_STRING 13a_Bobby
11753: PPUSH
11754: CALL_OW 38
// if Cyrus then
11758: LD_EXP 19
11762: IFFALSE 11776
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11764: LD_EXP 19
11768: PPUSH
11769: LD_STRING 13a_Cyrus
11771: PPUSH
11772: CALL_OW 38
// if Denis then
11776: LD_EXP 20
11780: IFFALSE 11794
// SaveCharacters ( Denis , 13a_Denis ) ;
11782: LD_EXP 20
11786: PPUSH
11787: LD_STRING 13a_Denis
11789: PPUSH
11790: CALL_OW 38
// if Brown then
11794: LD_EXP 21
11798: IFFALSE 11812
// SaveCharacters ( Brown , 13a_Brown ) ;
11800: LD_EXP 21
11804: PPUSH
11805: LD_STRING 13a_Brown
11807: PPUSH
11808: CALL_OW 38
// if Gladstone then
11812: LD_EXP 22
11816: IFFALSE 11830
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11818: LD_EXP 22
11822: PPUSH
11823: LD_STRING 13a_Gladstone
11825: PPUSH
11826: CALL_OW 38
// if Houten then
11830: LD_EXP 23
11834: IFFALSE 11848
// SaveCharacters ( Houten , 13a_Houten ) ;
11836: LD_EXP 23
11840: PPUSH
11841: LD_STRING 13a_Houten
11843: PPUSH
11844: CALL_OW 38
// if Cornel then
11848: LD_EXP 24
11852: IFFALSE 11866
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11854: LD_EXP 24
11858: PPUSH
11859: LD_STRING 13a_Cornel
11861: PPUSH
11862: CALL_OW 38
// if Gary then
11866: LD_EXP 25
11870: IFFALSE 11884
// SaveCharacters ( Gary , 13a_Gary ) ;
11872: LD_EXP 25
11876: PPUSH
11877: LD_STRING 13a_Gary
11879: PPUSH
11880: CALL_OW 38
// if Frank then
11884: LD_EXP 26
11888: IFFALSE 11902
// SaveCharacters ( Frank , 13a_Frank ) ;
11890: LD_EXP 26
11894: PPUSH
11895: LD_STRING 13a_Frank
11897: PPUSH
11898: CALL_OW 38
// if Kikuchi then
11902: LD_EXP 27
11906: IFFALSE 11920
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11908: LD_EXP 27
11912: PPUSH
11913: LD_STRING 13a_Kikuchi
11915: PPUSH
11916: CALL_OW 38
// if Simms then
11920: LD_EXP 28
11924: IFFALSE 11938
// SaveCharacters ( Simms , 13a_Simms ) ;
11926: LD_EXP 28
11930: PPUSH
11931: LD_STRING 13a_Simms
11933: PPUSH
11934: CALL_OW 38
// if Joan then
11938: LD_EXP 29
11942: IFFALSE 11956
// SaveCharacters ( Joan , 13a_Joan ) ;
11944: LD_EXP 29
11948: PPUSH
11949: LD_STRING 13a_Joan
11951: PPUSH
11952: CALL_OW 38
// if DeltaDoctor then
11956: LD_EXP 30
11960: IFFALSE 11974
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
11962: LD_EXP 30
11966: PPUSH
11967: LD_STRING 13a_DeltaDoctor
11969: PPUSH
11970: CALL_OW 38
// if Gossudarov then
11974: LD_EXP 31
11978: IFFALSE 11992
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
11980: LD_EXP 31
11984: PPUSH
11985: LD_STRING 13a_Gossudarov
11987: PPUSH
11988: CALL_OW 38
// if Kirilenkova then
11992: LD_EXP 32
11996: IFFALSE 12010
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
11998: LD_EXP 32
12002: PPUSH
12003: LD_STRING 13a_Kirilenkova
12005: PPUSH
12006: CALL_OW 38
// if Masha then
12010: LD_EXP 48
12014: IFFALSE 12069
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12016: LD_EXP 48
12020: PPUSH
12021: CALL_OW 265
12025: PUSH
12026: LD_EXP 48
12030: PPUSH
12031: CALL_OW 262
12035: PUSH
12036: LD_EXP 48
12040: PPUSH
12041: CALL_OW 263
12045: PUSH
12046: LD_EXP 48
12050: PPUSH
12051: CALL_OW 264
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: LIST
12060: LIST
12061: PPUSH
12062: LD_STRING 13a_Masha
12064: PPUSH
12065: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12069: LD_ADDR_VAR 0 2
12073: PUSH
12074: LD_INT 21
12076: PUSH
12077: LD_INT 3
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: PPUSH
12084: CALL_OW 69
12088: ST_TO_ADDR
// tmp2 := [ ] ;
12089: LD_ADDR_VAR 0 3
12093: PUSH
12094: EMPTY
12095: ST_TO_ADDR
// if tmp then
12096: LD_VAR 0 2
12100: IFFALSE 12248
// for i in tmp do
12102: LD_ADDR_VAR 0 1
12106: PUSH
12107: LD_VAR 0 2
12111: PUSH
12112: FOR_IN
12113: IFFALSE 12246
// tmp2 := tmp2 ^ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
12115: LD_ADDR_VAR 0 3
12119: PUSH
12120: LD_VAR 0 3
12124: PUSH
12125: LD_VAR 0 1
12129: PPUSH
12130: CALL_OW 255
12134: PUSH
12135: LD_VAR 0 1
12139: PPUSH
12140: CALL_OW 248
12144: PUSH
12145: LD_VAR 0 1
12149: PPUSH
12150: CALL_OW 266
12154: PUSH
12155: LD_VAR 0 1
12159: PPUSH
12160: CALL_OW 250
12164: PUSH
12165: LD_VAR 0 1
12169: PPUSH
12170: CALL_OW 251
12174: PUSH
12175: LD_VAR 0 1
12179: PPUSH
12180: CALL_OW 254
12184: PUSH
12185: LD_VAR 0 1
12189: PPUSH
12190: CALL_OW 267
12194: PUSH
12195: LD_VAR 0 1
12199: PPUSH
12200: LD_INT 1
12202: PPUSH
12203: CALL_OW 268
12207: PUSH
12208: LD_VAR 0 1
12212: PPUSH
12213: LD_INT 2
12215: PPUSH
12216: CALL_OW 268
12220: PUSH
12221: LD_VAR 0 1
12225: PPUSH
12226: CALL_OW 269
12230: PUSH
12231: EMPTY
12232: LIST
12233: LIST
12234: LIST
12235: LIST
12236: LIST
12237: LIST
12238: LIST
12239: LIST
12240: LIST
12241: LIST
12242: ADD
12243: ST_TO_ADDR
12244: GO 12112
12246: POP
12247: POP
// if tmp2 then
12248: LD_VAR 0 3
12252: IFFALSE 12266
// SaveVariable ( tmp2 , 13a_buildings ) ;
12254: LD_VAR 0 3
12258: PPUSH
12259: LD_STRING 13a_buildings
12261: PPUSH
12262: CALL_OW 39
// YouWin ;
12266: CALL_OW 103
// end ;
12270: PPOPN 3
12272: END
// export function SciRu ; var tmp , t ; begin
12273: LD_INT 0
12275: PPUSH
12276: PPUSH
12277: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12278: LD_ADDR_VAR 0 3
12282: PUSH
12283: LD_EXP 31
12287: PUSH
12288: LD_EXP 45
12292: PUSH
12293: LD_EXP 33
12297: PUSH
12298: LD_EXP 46
12302: PUSH
12303: LD_EXP 47
12307: PUSH
12308: EMPTY
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12315: LD_ADDR_VAR 0 2
12319: PUSH
12320: LD_INT 22
12322: PUSH
12323: LD_INT 7
12325: PUSH
12326: EMPTY
12327: LIST
12328: LIST
12329: PUSH
12330: LD_INT 23
12332: PUSH
12333: LD_INT 3
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PUSH
12340: LD_INT 25
12342: PUSH
12343: LD_INT 4
12345: PUSH
12346: EMPTY
12347: LIST
12348: LIST
12349: PUSH
12350: LD_INT 26
12352: PUSH
12353: LD_INT 1
12355: PUSH
12356: EMPTY
12357: LIST
12358: LIST
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: PPUSH
12366: CALL_OW 69
12370: PUSH
12371: LD_VAR 0 3
12375: DIFF
12376: ST_TO_ADDR
// if tmp then
12377: LD_VAR 0 2
12381: IFFALSE 12397
// result := tmp [ 1 ] ;
12383: LD_ADDR_VAR 0 1
12387: PUSH
12388: LD_VAR 0 2
12392: PUSH
12393: LD_INT 1
12395: ARRAY
12396: ST_TO_ADDR
// end ;
12397: LD_VAR 0 1
12401: RET
// export function SolRu ; var tmp , t ; begin
12402: LD_INT 0
12404: PPUSH
12405: PPUSH
12406: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12407: LD_ADDR_VAR 0 3
12411: PUSH
12412: LD_EXP 46
12416: PUSH
12417: LD_EXP 45
12421: PUSH
12422: LD_EXP 31
12426: PUSH
12427: EMPTY
12428: LIST
12429: LIST
12430: LIST
12431: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12432: LD_ADDR_VAR 0 2
12436: PUSH
12437: LD_INT 22
12439: PUSH
12440: LD_INT 7
12442: PUSH
12443: EMPTY
12444: LIST
12445: LIST
12446: PUSH
12447: LD_INT 23
12449: PUSH
12450: LD_INT 3
12452: PUSH
12453: EMPTY
12454: LIST
12455: LIST
12456: PUSH
12457: LD_INT 25
12459: PUSH
12460: LD_INT 1
12462: PUSH
12463: EMPTY
12464: LIST
12465: LIST
12466: PUSH
12467: LD_INT 26
12469: PUSH
12470: LD_INT 1
12472: PUSH
12473: EMPTY
12474: LIST
12475: LIST
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: LIST
12481: LIST
12482: PPUSH
12483: CALL_OW 69
12487: PUSH
12488: LD_VAR 0 3
12492: DIFF
12493: ST_TO_ADDR
// if tmp then
12494: LD_VAR 0 2
12498: IFFALSE 12514
// result := tmp [ 1 ] ;
12500: LD_ADDR_VAR 0 1
12504: PUSH
12505: LD_VAR 0 2
12509: PUSH
12510: LD_INT 1
12512: ARRAY
12513: ST_TO_ADDR
// end ; end_of_file
12514: LD_VAR 0 1
12518: RET
// export function CustomEvent ( event ) ; begin
12519: LD_INT 0
12521: PPUSH
// end ;
12522: LD_VAR 0 2
12526: RET
// on UnitDestroyed ( un ) do var i , side ;
12527: LD_INT 0
12529: PPUSH
12530: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12531: LD_VAR 0 1
12535: PUSH
12536: LD_INT 22
12538: PUSH
12539: LD_INT 7
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 2
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 1
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 2
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 3
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 4
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: LD_INT 25
12591: PUSH
12592: LD_INT 5
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: LD_INT 25
12601: PUSH
12602: LD_INT 8
12604: PUSH
12605: EMPTY
12606: LIST
12607: LIST
12608: PUSH
12609: LD_INT 25
12611: PUSH
12612: LD_INT 9
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PUSH
12619: EMPTY
12620: LIST
12621: LIST
12622: LIST
12623: LIST
12624: LIST
12625: LIST
12626: LIST
12627: LIST
12628: PUSH
12629: EMPTY
12630: LIST
12631: LIST
12632: PPUSH
12633: CALL_OW 69
12637: IN
12638: IFFALSE 12654
// loss_counter := loss_counter + 1 ;
12640: LD_ADDR_EXP 13
12644: PUSH
12645: LD_EXP 13
12649: PUSH
12650: LD_INT 1
12652: PLUS
12653: ST_TO_ADDR
// if un = Abdul then
12654: LD_VAR 0 1
12658: PUSH
12659: LD_EXP 54
12663: EQUAL
12664: IFFALSE 12674
// abdul_escaped := false ;
12666: LD_ADDR_EXP 12
12670: PUSH
12671: LD_INT 0
12673: ST_TO_ADDR
// if un in ru_attackers then
12674: LD_VAR 0 1
12678: PUSH
12679: LD_EXP 51
12683: IN
12684: IFFALSE 12702
// ru_attackers := ru_attackers diff un ;
12686: LD_ADDR_EXP 51
12690: PUSH
12691: LD_EXP 51
12695: PUSH
12696: LD_VAR 0 1
12700: DIFF
12701: ST_TO_ADDR
// if un in ar_attackers then
12702: LD_VAR 0 1
12706: PUSH
12707: LD_EXP 10
12711: IN
12712: IFFALSE 12730
// ar_attackers := ar_attackers diff un ;
12714: LD_ADDR_EXP 10
12718: PUSH
12719: LD_EXP 10
12723: PUSH
12724: LD_VAR 0 1
12728: DIFF
12729: ST_TO_ADDR
// if un = JMM then
12730: LD_VAR 0 1
12734: PUSH
12735: LD_EXP 14
12739: EQUAL
12740: IFFALSE 12751
// begin YouLost ( JMM ) ;
12742: LD_STRING JMM
12744: PPUSH
12745: CALL_OW 104
// exit ;
12749: GO 12840
// end ; if un = Burlak then
12751: LD_VAR 0 1
12755: PUSH
12756: LD_EXP 45
12760: EQUAL
12761: IFFALSE 12772
// begin YouLost ( Burlak ) ;
12763: LD_STRING Burlak
12765: PPUSH
12766: CALL_OW 104
// exit ;
12770: GO 12840
// end ; if un = freedom then
12772: LD_VAR 0 1
12776: PUSH
12777: LD_EXP 3
12781: EQUAL
12782: IFFALSE 12793
// begin YouLost ( Destroyed ) ;
12784: LD_STRING Destroyed
12786: PPUSH
12787: CALL_OW 104
// exit ;
12791: GO 12840
// end ; if un = Masha then
12793: LD_VAR 0 1
12797: PUSH
12798: LD_EXP 48
12802: EQUAL
12803: IFFALSE 12812
// ChangeMissionObjectives ( M4b ) ;
12805: LD_STRING M4b
12807: PPUSH
12808: CALL_OW 337
// if un = Mastodont then
12812: LD_VAR 0 1
12816: PUSH
12817: LD_EXP 55
12821: EQUAL
12822: IFFALSE 12831
// ChangeMissionObjectives ( M4a ) ;
12824: LD_STRING M4a
12826: PPUSH
12827: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12831: LD_VAR 0 1
12835: PPUSH
12836: CALL 81924 0 1
// end ;
12840: PPOPN 3
12842: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12843: LD_VAR 0 1
12847: PPUSH
12848: LD_VAR 0 2
12852: PPUSH
12853: CALL 83903 0 2
// end ;
12857: PPOPN 2
12859: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12860: LD_VAR 0 1
12864: PPUSH
12865: CALL 82971 0 1
// end ;
12869: PPOPN 1
12871: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12872: LD_VAR 0 1
12876: PUSH
12877: LD_INT 22
12879: PUSH
12880: LD_INT 7
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PUSH
12887: LD_INT 30
12889: PUSH
12890: LD_INT 0
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: PPUSH
12901: CALL_OW 69
12905: IN
12906: IFFALSE 12945
// begin SetBName ( building , freedom ) ;
12908: LD_VAR 0 1
12912: PPUSH
12913: LD_STRING freedom
12915: PPUSH
12916: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12920: LD_INT 0
12922: PPUSH
12923: LD_INT 7
12925: PPUSH
12926: LD_INT 0
12928: PPUSH
12929: CALL_OW 324
// freedom := building ;
12933: LD_ADDR_EXP 3
12937: PUSH
12938: LD_VAR 0 1
12942: ST_TO_ADDR
// exit ;
12943: GO 13011
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
12945: LD_VAR 0 1
12949: PUSH
12950: LD_INT 22
12952: PUSH
12953: LD_INT 7
12955: PUSH
12956: EMPTY
12957: LIST
12958: LIST
12959: PUSH
12960: LD_INT 23
12962: PUSH
12963: LD_INT 3
12965: PUSH
12966: EMPTY
12967: LIST
12968: LIST
12969: PUSH
12970: LD_INT 30
12972: PUSH
12973: LD_INT 6
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: LIST
12984: PPUSH
12985: CALL_OW 69
12989: IN
12990: IFFALSE 13002
// begin ru_lab_builded := true ;
12992: LD_ADDR_EXP 5
12996: PUSH
12997: LD_INT 1
12999: ST_TO_ADDR
// exit ;
13000: GO 13011
// end ; MCE_BuildingComplete ( building ) ;
13002: LD_VAR 0 1
13006: PPUSH
13007: CALL 83212 0 1
// end ;
13011: PPOPN 1
13013: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13014: LD_VAR 0 1
13018: PPUSH
13019: LD_VAR 0 2
13023: PPUSH
13024: CALL 81620 0 2
// end ;
13028: PPOPN 2
13030: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13031: LD_VAR 0 1
13035: PPUSH
13036: LD_VAR 0 2
13040: PPUSH
13041: LD_VAR 0 3
13045: PPUSH
13046: LD_VAR 0 4
13050: PPUSH
13051: LD_VAR 0 5
13055: PPUSH
13056: CALL 81240 0 5
// end ;
13060: PPOPN 5
13062: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13063: LD_VAR 0 1
13067: PPUSH
13068: LD_VAR 0 2
13072: PPUSH
13073: CALL 80830 0 2
// end ;
13077: PPOPN 2
13079: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13080: LD_VAR 0 1
13084: PPUSH
13085: LD_VAR 0 2
13089: PPUSH
13090: LD_VAR 0 3
13094: PPUSH
13095: LD_VAR 0 4
13099: PPUSH
13100: CALL 80668 0 4
// end ;
13104: PPOPN 4
13106: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13107: LD_VAR 0 1
13111: PPUSH
13112: LD_VAR 0 2
13116: PPUSH
13117: LD_VAR 0 3
13121: PPUSH
13122: CALL 80443 0 3
// end ;
13126: PPOPN 3
13128: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13129: LD_VAR 0 1
13133: PPUSH
13134: LD_VAR 0 2
13138: PPUSH
13139: CALL 80328 0 2
// end ;
13143: PPOPN 2
13145: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13146: LD_VAR 0 1
13150: PPUSH
13151: LD_VAR 0 2
13155: PPUSH
13156: CALL 84164 0 2
// end ;
13160: PPOPN 2
13162: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13163: LD_VAR 0 1
13167: PPUSH
13168: LD_VAR 0 2
13172: PPUSH
13173: LD_VAR 0 3
13177: PPUSH
13178: LD_VAR 0 4
13182: PPUSH
13183: CALL 84380 0 4
// end ;
13187: PPOPN 4
13189: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13190: LD_VAR 0 1
13194: PPUSH
13195: LD_VAR 0 2
13199: PPUSH
13200: CALL 80137 0 2
// end ; end_of_file
13204: PPOPN 2
13206: END
// every 0 0$30 do var cr , time ;
13207: GO 13209
13209: DISABLE
13210: LD_INT 0
13212: PPUSH
13213: PPUSH
// begin time := 0 0$30 ;
13214: LD_ADDR_VAR 0 2
13218: PUSH
13219: LD_INT 1050
13221: ST_TO_ADDR
// while game do
13222: LD_EXP 2
13226: IFFALSE 13325
// begin wait ( time ) ;
13228: LD_VAR 0 2
13232: PPUSH
13233: CALL_OW 67
// if tick > 2 2$00 then
13237: LD_OWVAR 1
13241: PUSH
13242: LD_INT 4200
13244: GREATER
13245: IFFALSE 13278
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13247: LD_ADDR_VAR 0 2
13251: PUSH
13252: LD_VAR 0 2
13256: PUSH
13257: LD_INT 280
13259: PUSH
13260: LD_INT 420
13262: PUSH
13263: LD_INT 630
13265: PUSH
13266: EMPTY
13267: LIST
13268: LIST
13269: LIST
13270: PUSH
13271: LD_OWVAR 67
13275: ARRAY
13276: PLUS
13277: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13278: LD_INT 1
13280: PPUSH
13281: LD_INT 5
13283: PPUSH
13284: CALL_OW 12
13288: PPUSH
13289: LD_INT 70
13291: PPUSH
13292: LD_INT 49
13294: PPUSH
13295: LD_INT 25
13297: PPUSH
13298: LD_INT 1
13300: PPUSH
13301: CALL_OW 56
// if time > 5 5$00 then
13305: LD_VAR 0 2
13309: PUSH
13310: LD_INT 10500
13312: GREATER
13313: IFFALSE 13323
// time := 0 0$30 ;
13315: LD_ADDR_VAR 0 2
13319: PUSH
13320: LD_INT 1050
13322: ST_TO_ADDR
// end ;
13323: GO 13222
// end ;
13325: PPOPN 2
13327: END
// every 0 0$30 do var cr , time ;
13328: GO 13330
13330: DISABLE
13331: LD_INT 0
13333: PPUSH
13334: PPUSH
// begin time := 0 0$20 ;
13335: LD_ADDR_VAR 0 2
13339: PUSH
13340: LD_INT 700
13342: ST_TO_ADDR
// while game do
13343: LD_EXP 2
13347: IFFALSE 13436
// begin wait ( time ) ;
13349: LD_VAR 0 2
13353: PPUSH
13354: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13358: LD_ADDR_VAR 0 2
13362: PUSH
13363: LD_VAR 0 2
13367: PUSH
13368: LD_INT 490
13370: PUSH
13371: LD_INT 525
13373: PUSH
13374: LD_INT 560
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: LIST
13381: PUSH
13382: LD_OWVAR 67
13386: ARRAY
13387: PLUS
13388: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13389: LD_INT 3
13391: PPUSH
13392: LD_INT 5
13394: PPUSH
13395: CALL_OW 12
13399: PPUSH
13400: LD_INT 26
13402: PPUSH
13403: LD_INT 9
13405: PPUSH
13406: LD_INT 30
13408: PPUSH
13409: LD_INT 1
13411: PPUSH
13412: CALL_OW 56
// if time > 3 3$00 then
13416: LD_VAR 0 2
13420: PUSH
13421: LD_INT 6300
13423: GREATER
13424: IFFALSE 13434
// time := 0 0$20 ;
13426: LD_ADDR_VAR 0 2
13430: PUSH
13431: LD_INT 700
13433: ST_TO_ADDR
// end ;
13434: GO 13343
// end ;
13436: PPOPN 2
13438: END
// every 0 0$30 do var cr , time ;
13439: GO 13441
13441: DISABLE
13442: LD_INT 0
13444: PPUSH
13445: PPUSH
// begin time := 0 0$20 ;
13446: LD_ADDR_VAR 0 2
13450: PUSH
13451: LD_INT 700
13453: ST_TO_ADDR
// while game do
13454: LD_EXP 2
13458: IFFALSE 13583
// begin wait ( time ) ;
13460: LD_VAR 0 2
13464: PPUSH
13465: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13469: LD_ADDR_VAR 0 2
13473: PUSH
13474: LD_VAR 0 2
13478: PUSH
13479: LD_INT 175
13481: PUSH
13482: LD_INT 210
13484: PUSH
13485: LD_INT 280
13487: PUSH
13488: EMPTY
13489: LIST
13490: LIST
13491: LIST
13492: PUSH
13493: LD_OWVAR 67
13497: ARRAY
13498: PLUS
13499: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13500: LD_INT 1
13502: PPUSH
13503: LD_INT 5
13505: PPUSH
13506: CALL_OW 12
13510: PPUSH
13511: LD_INT 179
13513: PPUSH
13514: LD_INT 101
13516: PPUSH
13517: LD_INT 20
13519: PPUSH
13520: LD_INT 1
13522: PPUSH
13523: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13527: LD_INT 350
13529: PPUSH
13530: LD_INT 525
13532: PPUSH
13533: CALL_OW 12
13537: PPUSH
13538: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13542: LD_INT 1
13544: PPUSH
13545: LD_INT 5
13547: PPUSH
13548: CALL_OW 12
13552: PPUSH
13553: LD_INT 9
13555: PPUSH
13556: LD_INT 1
13558: PPUSH
13559: CALL_OW 55
// if time > 4 4$00 then
13563: LD_VAR 0 2
13567: PUSH
13568: LD_INT 8400
13570: GREATER
13571: IFFALSE 13581
// time := 0 0$30 ;
13573: LD_ADDR_VAR 0 2
13577: PUSH
13578: LD_INT 1050
13580: ST_TO_ADDR
// end ;
13581: GO 13454
// end ;
13583: PPOPN 2
13585: END
// every 0 0$30 do var cr , time ;
13586: GO 13588
13588: DISABLE
13589: LD_INT 0
13591: PPUSH
13592: PPUSH
// begin time := 0 0$10 ;
13593: LD_ADDR_VAR 0 2
13597: PUSH
13598: LD_INT 350
13600: ST_TO_ADDR
// while game do
13601: LD_EXP 2
13605: IFFALSE 13739
// begin wait ( time ) ;
13607: LD_VAR 0 2
13611: PPUSH
13612: CALL_OW 67
// time := time + 0 0$10 ;
13616: LD_ADDR_VAR 0 2
13620: PUSH
13621: LD_VAR 0 2
13625: PUSH
13626: LD_INT 350
13628: PLUS
13629: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13630: LD_INT 1
13632: PPUSH
13633: LD_INT 5
13635: PPUSH
13636: CALL_OW 12
13640: PPUSH
13641: LD_INT 11
13643: PPUSH
13644: LD_INT 1
13646: PPUSH
13647: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13651: LD_ADDR_VAR 0 1
13655: PUSH
13656: LD_INT 1
13658: PPUSH
13659: LD_INT 3
13661: PPUSH
13662: CALL_OW 12
13666: ST_TO_ADDR
// if cr = 1 then
13667: LD_VAR 0 1
13671: PUSH
13672: LD_INT 1
13674: EQUAL
13675: IFFALSE 13719
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13677: LD_INT 700
13679: PPUSH
13680: LD_INT 1575
13682: PPUSH
13683: CALL_OW 12
13687: PPUSH
13688: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13692: LD_INT 1
13694: PPUSH
13695: LD_INT 5
13697: PPUSH
13698: CALL_OW 12
13702: PPUSH
13703: LD_INT 34
13705: PPUSH
13706: LD_INT 50
13708: PPUSH
13709: LD_INT 7
13711: PPUSH
13712: LD_INT 1
13714: PPUSH
13715: CALL_OW 56
// end ; if time > 8 8$00 then
13719: LD_VAR 0 2
13723: PUSH
13724: LD_INT 16800
13726: GREATER
13727: IFFALSE 13737
// time := 0 0$40 ;
13729: LD_ADDR_VAR 0 2
13733: PUSH
13734: LD_INT 1400
13736: ST_TO_ADDR
// end ;
13737: GO 13601
// end ; end_of_file
13739: PPOPN 2
13741: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13742: LD_INT 0
13744: PPUSH
13745: PPUSH
// if exist_mode then
13746: LD_VAR 0 2
13750: IFFALSE 13775
// unit := CreateCharacter ( prefix & ident ) else
13752: LD_ADDR_VAR 0 5
13756: PUSH
13757: LD_VAR 0 3
13761: PUSH
13762: LD_VAR 0 1
13766: STR
13767: PPUSH
13768: CALL_OW 34
13772: ST_TO_ADDR
13773: GO 13790
// unit := NewCharacter ( ident ) ;
13775: LD_ADDR_VAR 0 5
13779: PUSH
13780: LD_VAR 0 1
13784: PPUSH
13785: CALL_OW 25
13789: ST_TO_ADDR
// result := unit ;
13790: LD_ADDR_VAR 0 4
13794: PUSH
13795: LD_VAR 0 5
13799: ST_TO_ADDR
// end ;
13800: LD_VAR 0 4
13804: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13805: LD_INT 0
13807: PPUSH
13808: PPUSH
// if not side or not nation then
13809: LD_VAR 0 1
13813: NOT
13814: PUSH
13815: LD_VAR 0 2
13819: NOT
13820: OR
13821: IFFALSE 13825
// exit ;
13823: GO 14461
// case nation of nation_american :
13825: LD_VAR 0 2
13829: PUSH
13830: LD_INT 1
13832: DOUBLE
13833: EQUAL
13834: IFTRUE 13838
13836: GO 14008
13838: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13839: LD_ADDR_VAR 0 4
13843: PUSH
13844: LD_INT 35
13846: PUSH
13847: LD_INT 45
13849: PUSH
13850: LD_INT 46
13852: PUSH
13853: LD_INT 47
13855: PUSH
13856: LD_INT 1
13858: PUSH
13859: LD_INT 2
13861: PUSH
13862: LD_INT 6
13864: PUSH
13865: LD_INT 15
13867: PUSH
13868: LD_INT 16
13870: PUSH
13871: LD_INT 7
13873: PUSH
13874: LD_INT 12
13876: PUSH
13877: LD_INT 13
13879: PUSH
13880: LD_INT 10
13882: PUSH
13883: LD_INT 14
13885: PUSH
13886: LD_INT 20
13888: PUSH
13889: LD_INT 21
13891: PUSH
13892: LD_INT 22
13894: PUSH
13895: LD_INT 25
13897: PUSH
13898: LD_INT 32
13900: PUSH
13901: LD_INT 27
13903: PUSH
13904: LD_INT 36
13906: PUSH
13907: LD_INT 69
13909: PUSH
13910: LD_INT 39
13912: PUSH
13913: LD_INT 34
13915: PUSH
13916: LD_INT 40
13918: PUSH
13919: LD_INT 48
13921: PUSH
13922: LD_INT 49
13924: PUSH
13925: LD_INT 50
13927: PUSH
13928: LD_INT 51
13930: PUSH
13931: LD_INT 52
13933: PUSH
13934: LD_INT 53
13936: PUSH
13937: LD_INT 54
13939: PUSH
13940: LD_INT 55
13942: PUSH
13943: LD_INT 56
13945: PUSH
13946: LD_INT 57
13948: PUSH
13949: LD_INT 58
13951: PUSH
13952: LD_INT 59
13954: PUSH
13955: LD_INT 60
13957: PUSH
13958: LD_INT 61
13960: PUSH
13961: LD_INT 62
13963: PUSH
13964: EMPTY
13965: LIST
13966: LIST
13967: LIST
13968: LIST
13969: LIST
13970: LIST
13971: LIST
13972: LIST
13973: LIST
13974: LIST
13975: LIST
13976: LIST
13977: LIST
13978: LIST
13979: LIST
13980: LIST
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: LIST
13988: LIST
13989: LIST
13990: LIST
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: LIST
13996: LIST
13997: LIST
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: ST_TO_ADDR
14006: GO 14385
14008: LD_INT 2
14010: DOUBLE
14011: EQUAL
14012: IFTRUE 14016
14014: GO 14194
14016: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14017: LD_ADDR_VAR 0 4
14021: PUSH
14022: LD_INT 35
14024: PUSH
14025: LD_INT 45
14027: PUSH
14028: LD_INT 46
14030: PUSH
14031: LD_INT 47
14033: PUSH
14034: LD_INT 70
14036: PUSH
14037: LD_INT 1
14039: PUSH
14040: LD_INT 11
14042: PUSH
14043: LD_INT 3
14045: PUSH
14046: LD_INT 4
14048: PUSH
14049: LD_INT 5
14051: PUSH
14052: LD_INT 6
14054: PUSH
14055: LD_INT 15
14057: PUSH
14058: LD_INT 18
14060: PUSH
14061: LD_INT 7
14063: PUSH
14064: LD_INT 17
14066: PUSH
14067: LD_INT 8
14069: PUSH
14070: LD_INT 20
14072: PUSH
14073: LD_INT 21
14075: PUSH
14076: LD_INT 22
14078: PUSH
14079: LD_INT 72
14081: PUSH
14082: LD_INT 26
14084: PUSH
14085: LD_INT 69
14087: PUSH
14088: LD_INT 39
14090: PUSH
14091: LD_INT 40
14093: PUSH
14094: LD_INT 41
14096: PUSH
14097: LD_INT 42
14099: PUSH
14100: LD_INT 43
14102: PUSH
14103: LD_INT 48
14105: PUSH
14106: LD_INT 49
14108: PUSH
14109: LD_INT 50
14111: PUSH
14112: LD_INT 51
14114: PUSH
14115: LD_INT 52
14117: PUSH
14118: LD_INT 53
14120: PUSH
14121: LD_INT 54
14123: PUSH
14124: LD_INT 55
14126: PUSH
14127: LD_INT 56
14129: PUSH
14130: LD_INT 60
14132: PUSH
14133: LD_INT 61
14135: PUSH
14136: LD_INT 62
14138: PUSH
14139: LD_INT 66
14141: PUSH
14142: LD_INT 67
14144: PUSH
14145: LD_INT 68
14147: PUSH
14148: EMPTY
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: LIST
14181: LIST
14182: LIST
14183: LIST
14184: LIST
14185: LIST
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: LIST
14191: ST_TO_ADDR
14192: GO 14385
14194: LD_INT 3
14196: DOUBLE
14197: EQUAL
14198: IFTRUE 14202
14200: GO 14384
14202: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14203: LD_ADDR_VAR 0 4
14207: PUSH
14208: LD_INT 46
14210: PUSH
14211: LD_INT 47
14213: PUSH
14214: LD_INT 1
14216: PUSH
14217: LD_INT 2
14219: PUSH
14220: LD_INT 11
14222: PUSH
14223: LD_INT 9
14225: PUSH
14226: LD_INT 20
14228: PUSH
14229: LD_INT 19
14231: PUSH
14232: LD_INT 21
14234: PUSH
14235: LD_INT 24
14237: PUSH
14238: LD_INT 22
14240: PUSH
14241: LD_INT 25
14243: PUSH
14244: LD_INT 28
14246: PUSH
14247: LD_INT 29
14249: PUSH
14250: LD_INT 30
14252: PUSH
14253: LD_INT 31
14255: PUSH
14256: LD_INT 37
14258: PUSH
14259: LD_INT 38
14261: PUSH
14262: LD_INT 32
14264: PUSH
14265: LD_INT 27
14267: PUSH
14268: LD_INT 33
14270: PUSH
14271: LD_INT 69
14273: PUSH
14274: LD_INT 39
14276: PUSH
14277: LD_INT 34
14279: PUSH
14280: LD_INT 40
14282: PUSH
14283: LD_INT 71
14285: PUSH
14286: LD_INT 23
14288: PUSH
14289: LD_INT 44
14291: PUSH
14292: LD_INT 48
14294: PUSH
14295: LD_INT 49
14297: PUSH
14298: LD_INT 50
14300: PUSH
14301: LD_INT 51
14303: PUSH
14304: LD_INT 52
14306: PUSH
14307: LD_INT 53
14309: PUSH
14310: LD_INT 54
14312: PUSH
14313: LD_INT 55
14315: PUSH
14316: LD_INT 56
14318: PUSH
14319: LD_INT 57
14321: PUSH
14322: LD_INT 58
14324: PUSH
14325: LD_INT 59
14327: PUSH
14328: LD_INT 63
14330: PUSH
14331: LD_INT 64
14333: PUSH
14334: LD_INT 65
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: ST_TO_ADDR
14382: GO 14385
14384: POP
// if state > - 1 and state < 3 then
14385: LD_VAR 0 3
14389: PUSH
14390: LD_INT 1
14392: NEG
14393: GREATER
14394: PUSH
14395: LD_VAR 0 3
14399: PUSH
14400: LD_INT 3
14402: LESS
14403: AND
14404: IFFALSE 14461
// for i in result do
14406: LD_ADDR_VAR 0 5
14410: PUSH
14411: LD_VAR 0 4
14415: PUSH
14416: FOR_IN
14417: IFFALSE 14459
// if GetTech ( i , side ) <> state then
14419: LD_VAR 0 5
14423: PPUSH
14424: LD_VAR 0 1
14428: PPUSH
14429: CALL_OW 321
14433: PUSH
14434: LD_VAR 0 3
14438: NONEQUAL
14439: IFFALSE 14457
// result := result diff i ;
14441: LD_ADDR_VAR 0 4
14445: PUSH
14446: LD_VAR 0 4
14450: PUSH
14451: LD_VAR 0 5
14455: DIFF
14456: ST_TO_ADDR
14457: GO 14416
14459: POP
14460: POP
// end ;
14461: LD_VAR 0 4
14465: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14466: LD_INT 0
14468: PPUSH
14469: PPUSH
14470: PPUSH
// result := true ;
14471: LD_ADDR_VAR 0 3
14475: PUSH
14476: LD_INT 1
14478: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14479: LD_ADDR_VAR 0 5
14483: PUSH
14484: LD_VAR 0 2
14488: PPUSH
14489: CALL_OW 480
14493: ST_TO_ADDR
// if not tmp then
14494: LD_VAR 0 5
14498: NOT
14499: IFFALSE 14503
// exit ;
14501: GO 14552
// for i in tmp do
14503: LD_ADDR_VAR 0 4
14507: PUSH
14508: LD_VAR 0 5
14512: PUSH
14513: FOR_IN
14514: IFFALSE 14550
// if GetTech ( i , side ) <> state_researched then
14516: LD_VAR 0 4
14520: PPUSH
14521: LD_VAR 0 1
14525: PPUSH
14526: CALL_OW 321
14530: PUSH
14531: LD_INT 2
14533: NONEQUAL
14534: IFFALSE 14548
// begin result := false ;
14536: LD_ADDR_VAR 0 3
14540: PUSH
14541: LD_INT 0
14543: ST_TO_ADDR
// exit ;
14544: POP
14545: POP
14546: GO 14552
// end ;
14548: GO 14513
14550: POP
14551: POP
// end ;
14552: LD_VAR 0 3
14556: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14557: LD_INT 0
14559: PPUSH
14560: PPUSH
14561: PPUSH
14562: PPUSH
14563: PPUSH
14564: PPUSH
14565: PPUSH
14566: PPUSH
14567: PPUSH
14568: PPUSH
14569: PPUSH
14570: PPUSH
14571: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14572: LD_VAR 0 1
14576: NOT
14577: PUSH
14578: LD_VAR 0 1
14582: PPUSH
14583: CALL_OW 257
14587: PUSH
14588: LD_INT 9
14590: NONEQUAL
14591: OR
14592: IFFALSE 14596
// exit ;
14594: GO 15169
// side := GetSide ( unit ) ;
14596: LD_ADDR_VAR 0 9
14600: PUSH
14601: LD_VAR 0 1
14605: PPUSH
14606: CALL_OW 255
14610: ST_TO_ADDR
// tech_space := tech_spacanom ;
14611: LD_ADDR_VAR 0 12
14615: PUSH
14616: LD_INT 29
14618: ST_TO_ADDR
// tech_time := tech_taurad ;
14619: LD_ADDR_VAR 0 13
14623: PUSH
14624: LD_INT 28
14626: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14627: LD_ADDR_VAR 0 11
14631: PUSH
14632: LD_VAR 0 1
14636: PPUSH
14637: CALL_OW 310
14641: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14642: LD_VAR 0 11
14646: PPUSH
14647: CALL_OW 247
14651: PUSH
14652: LD_INT 2
14654: EQUAL
14655: IFFALSE 14659
// exit ;
14657: GO 15169
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14659: LD_ADDR_VAR 0 8
14663: PUSH
14664: LD_INT 81
14666: PUSH
14667: LD_VAR 0 9
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PUSH
14676: LD_INT 3
14678: PUSH
14679: LD_INT 21
14681: PUSH
14682: LD_INT 3
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PUSH
14689: EMPTY
14690: LIST
14691: LIST
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PPUSH
14697: CALL_OW 69
14701: ST_TO_ADDR
// if not tmp then
14702: LD_VAR 0 8
14706: NOT
14707: IFFALSE 14711
// exit ;
14709: GO 15169
// if in_unit then
14711: LD_VAR 0 11
14715: IFFALSE 14739
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14717: LD_ADDR_VAR 0 10
14721: PUSH
14722: LD_VAR 0 8
14726: PPUSH
14727: LD_VAR 0 11
14731: PPUSH
14732: CALL_OW 74
14736: ST_TO_ADDR
14737: GO 14759
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14739: LD_ADDR_VAR 0 10
14743: PUSH
14744: LD_VAR 0 8
14748: PPUSH
14749: LD_VAR 0 1
14753: PPUSH
14754: CALL_OW 74
14758: ST_TO_ADDR
// if not enemy then
14759: LD_VAR 0 10
14763: NOT
14764: IFFALSE 14768
// exit ;
14766: GO 15169
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14768: LD_VAR 0 11
14772: PUSH
14773: LD_VAR 0 11
14777: PPUSH
14778: LD_VAR 0 10
14782: PPUSH
14783: CALL_OW 296
14787: PUSH
14788: LD_INT 13
14790: GREATER
14791: AND
14792: PUSH
14793: LD_VAR 0 1
14797: PPUSH
14798: LD_VAR 0 10
14802: PPUSH
14803: CALL_OW 296
14807: PUSH
14808: LD_INT 12
14810: GREATER
14811: OR
14812: IFFALSE 14816
// exit ;
14814: GO 15169
// missile := [ 1 ] ;
14816: LD_ADDR_VAR 0 14
14820: PUSH
14821: LD_INT 1
14823: PUSH
14824: EMPTY
14825: LIST
14826: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14827: LD_VAR 0 9
14831: PPUSH
14832: LD_VAR 0 12
14836: PPUSH
14837: CALL_OW 325
14841: IFFALSE 14870
// missile := Insert ( missile , missile + 1 , 2 ) ;
14843: LD_ADDR_VAR 0 14
14847: PUSH
14848: LD_VAR 0 14
14852: PPUSH
14853: LD_VAR 0 14
14857: PUSH
14858: LD_INT 1
14860: PLUS
14861: PPUSH
14862: LD_INT 2
14864: PPUSH
14865: CALL_OW 2
14869: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14870: LD_VAR 0 9
14874: PPUSH
14875: LD_VAR 0 13
14879: PPUSH
14880: CALL_OW 325
14884: PUSH
14885: LD_VAR 0 10
14889: PPUSH
14890: CALL_OW 255
14894: PPUSH
14895: LD_VAR 0 13
14899: PPUSH
14900: CALL_OW 325
14904: NOT
14905: AND
14906: IFFALSE 14935
// missile := Insert ( missile , missile + 1 , 3 ) ;
14908: LD_ADDR_VAR 0 14
14912: PUSH
14913: LD_VAR 0 14
14917: PPUSH
14918: LD_VAR 0 14
14922: PUSH
14923: LD_INT 1
14925: PLUS
14926: PPUSH
14927: LD_INT 3
14929: PPUSH
14930: CALL_OW 2
14934: ST_TO_ADDR
// if missile < 2 then
14935: LD_VAR 0 14
14939: PUSH
14940: LD_INT 2
14942: LESS
14943: IFFALSE 14947
// exit ;
14945: GO 15169
// x := GetX ( enemy ) ;
14947: LD_ADDR_VAR 0 4
14951: PUSH
14952: LD_VAR 0 10
14956: PPUSH
14957: CALL_OW 250
14961: ST_TO_ADDR
// y := GetY ( enemy ) ;
14962: LD_ADDR_VAR 0 5
14966: PUSH
14967: LD_VAR 0 10
14971: PPUSH
14972: CALL_OW 251
14976: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14977: LD_ADDR_VAR 0 6
14981: PUSH
14982: LD_VAR 0 4
14986: PUSH
14987: LD_INT 1
14989: NEG
14990: PPUSH
14991: LD_INT 1
14993: PPUSH
14994: CALL_OW 12
14998: PLUS
14999: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15000: LD_ADDR_VAR 0 7
15004: PUSH
15005: LD_VAR 0 5
15009: PUSH
15010: LD_INT 1
15012: NEG
15013: PPUSH
15014: LD_INT 1
15016: PPUSH
15017: CALL_OW 12
15021: PLUS
15022: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15023: LD_VAR 0 6
15027: PPUSH
15028: LD_VAR 0 7
15032: PPUSH
15033: CALL_OW 488
15037: NOT
15038: IFFALSE 15060
// begin _x := x ;
15040: LD_ADDR_VAR 0 6
15044: PUSH
15045: LD_VAR 0 4
15049: ST_TO_ADDR
// _y := y ;
15050: LD_ADDR_VAR 0 7
15054: PUSH
15055: LD_VAR 0 5
15059: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15060: LD_ADDR_VAR 0 3
15064: PUSH
15065: LD_INT 1
15067: PPUSH
15068: LD_VAR 0 14
15072: PPUSH
15073: CALL_OW 12
15077: ST_TO_ADDR
// case i of 1 :
15078: LD_VAR 0 3
15082: PUSH
15083: LD_INT 1
15085: DOUBLE
15086: EQUAL
15087: IFTRUE 15091
15089: GO 15108
15091: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15092: LD_VAR 0 1
15096: PPUSH
15097: LD_VAR 0 10
15101: PPUSH
15102: CALL_OW 115
15106: GO 15169
15108: LD_INT 2
15110: DOUBLE
15111: EQUAL
15112: IFTRUE 15116
15114: GO 15138
15116: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15117: LD_VAR 0 1
15121: PPUSH
15122: LD_VAR 0 6
15126: PPUSH
15127: LD_VAR 0 7
15131: PPUSH
15132: CALL_OW 153
15136: GO 15169
15138: LD_INT 3
15140: DOUBLE
15141: EQUAL
15142: IFTRUE 15146
15144: GO 15168
15146: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15147: LD_VAR 0 1
15151: PPUSH
15152: LD_VAR 0 6
15156: PPUSH
15157: LD_VAR 0 7
15161: PPUSH
15162: CALL_OW 154
15166: GO 15169
15168: POP
// end ;
15169: LD_VAR 0 2
15173: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15174: LD_INT 0
15176: PPUSH
15177: PPUSH
15178: PPUSH
15179: PPUSH
15180: PPUSH
15181: PPUSH
// if not unit or not building then
15182: LD_VAR 0 1
15186: NOT
15187: PUSH
15188: LD_VAR 0 2
15192: NOT
15193: OR
15194: IFFALSE 15198
// exit ;
15196: GO 15356
// x := GetX ( building ) ;
15198: LD_ADDR_VAR 0 5
15202: PUSH
15203: LD_VAR 0 2
15207: PPUSH
15208: CALL_OW 250
15212: ST_TO_ADDR
// y := GetY ( building ) ;
15213: LD_ADDR_VAR 0 6
15217: PUSH
15218: LD_VAR 0 2
15222: PPUSH
15223: CALL_OW 251
15227: ST_TO_ADDR
// for i = 0 to 5 do
15228: LD_ADDR_VAR 0 4
15232: PUSH
15233: DOUBLE
15234: LD_INT 0
15236: DEC
15237: ST_TO_ADDR
15238: LD_INT 5
15240: PUSH
15241: FOR_TO
15242: IFFALSE 15354
// begin _x := ShiftX ( x , i , 3 ) ;
15244: LD_ADDR_VAR 0 7
15248: PUSH
15249: LD_VAR 0 5
15253: PPUSH
15254: LD_VAR 0 4
15258: PPUSH
15259: LD_INT 3
15261: PPUSH
15262: CALL_OW 272
15266: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15267: LD_ADDR_VAR 0 8
15271: PUSH
15272: LD_VAR 0 6
15276: PPUSH
15277: LD_VAR 0 4
15281: PPUSH
15282: LD_INT 3
15284: PPUSH
15285: CALL_OW 273
15289: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15290: LD_VAR 0 7
15294: PPUSH
15295: LD_VAR 0 8
15299: PPUSH
15300: CALL_OW 488
15304: NOT
15305: IFFALSE 15309
// continue ;
15307: GO 15241
// if HexInfo ( _x , _y ) = 0 then
15309: LD_VAR 0 7
15313: PPUSH
15314: LD_VAR 0 8
15318: PPUSH
15319: CALL_OW 428
15323: PUSH
15324: LD_INT 0
15326: EQUAL
15327: IFFALSE 15352
// begin ComMoveXY ( unit , _x , _y ) ;
15329: LD_VAR 0 1
15333: PPUSH
15334: LD_VAR 0 7
15338: PPUSH
15339: LD_VAR 0 8
15343: PPUSH
15344: CALL_OW 111
// exit ;
15348: POP
15349: POP
15350: GO 15356
// end ; end ;
15352: GO 15241
15354: POP
15355: POP
// end ;
15356: LD_VAR 0 3
15360: RET
// export function ScanBase ( side , base_area ) ; begin
15361: LD_INT 0
15363: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15364: LD_ADDR_VAR 0 3
15368: PUSH
15369: LD_VAR 0 2
15373: PPUSH
15374: LD_INT 81
15376: PUSH
15377: LD_VAR 0 1
15381: PUSH
15382: EMPTY
15383: LIST
15384: LIST
15385: PPUSH
15386: CALL_OW 70
15390: ST_TO_ADDR
// end ;
15391: LD_VAR 0 3
15395: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15396: LD_INT 0
15398: PPUSH
15399: PPUSH
15400: PPUSH
15401: PPUSH
15402: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15403: LD_VAR 0 1
15407: NOT
15408: PUSH
15409: LD_EXP 58
15413: PUSH
15414: LD_VAR 0 1
15418: ARRAY
15419: NOT
15420: OR
15421: PUSH
15422: LD_VAR 0 2
15426: NOT
15427: OR
15428: PUSH
15429: LD_VAR 0 3
15433: NOT
15434: OR
15435: IFFALSE 15439
// exit ;
15437: GO 15889
// side := mc_sides [ base ] ;
15439: LD_ADDR_VAR 0 6
15443: PUSH
15444: LD_EXP 84
15448: PUSH
15449: LD_VAR 0 1
15453: ARRAY
15454: ST_TO_ADDR
// if not side then
15455: LD_VAR 0 6
15459: NOT
15460: IFFALSE 15464
// exit ;
15462: GO 15889
// for i in solds do
15464: LD_ADDR_VAR 0 7
15468: PUSH
15469: LD_VAR 0 2
15473: PUSH
15474: FOR_IN
15475: IFFALSE 15536
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15477: LD_VAR 0 7
15481: PPUSH
15482: CALL_OW 310
15486: PPUSH
15487: CALL_OW 266
15491: PUSH
15492: LD_INT 32
15494: PUSH
15495: LD_INT 31
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: IN
15502: IFFALSE 15522
// solds := solds diff i else
15504: LD_ADDR_VAR 0 2
15508: PUSH
15509: LD_VAR 0 2
15513: PUSH
15514: LD_VAR 0 7
15518: DIFF
15519: ST_TO_ADDR
15520: GO 15534
// SetTag ( i , 18 ) ;
15522: LD_VAR 0 7
15526: PPUSH
15527: LD_INT 18
15529: PPUSH
15530: CALL_OW 109
15534: GO 15474
15536: POP
15537: POP
// if not solds then
15538: LD_VAR 0 2
15542: NOT
15543: IFFALSE 15547
// exit ;
15545: GO 15889
// repeat wait ( 0 0$1 ) ;
15547: LD_INT 35
15549: PPUSH
15550: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15554: LD_ADDR_VAR 0 5
15558: PUSH
15559: LD_VAR 0 6
15563: PPUSH
15564: LD_VAR 0 3
15568: PPUSH
15569: CALL 15361 0 2
15573: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15574: LD_VAR 0 5
15578: NOT
15579: PUSH
15580: LD_VAR 0 5
15584: PUSH
15585: LD_INT 3
15587: GREATER
15588: OR
15589: PUSH
15590: LD_EXP 80
15594: PUSH
15595: LD_VAR 0 1
15599: ARRAY
15600: OR
15601: IFFALSE 15642
// begin for i in solds do
15603: LD_ADDR_VAR 0 7
15607: PUSH
15608: LD_VAR 0 2
15612: PUSH
15613: FOR_IN
15614: IFFALSE 15638
// if HasTask ( i ) then
15616: LD_VAR 0 7
15620: PPUSH
15621: CALL_OW 314
15625: IFFALSE 15636
// ComStop ( i ) ;
15627: LD_VAR 0 7
15631: PPUSH
15632: CALL_OW 141
15636: GO 15613
15638: POP
15639: POP
// break ;
15640: GO 15877
// end ; for i in solds do
15642: LD_ADDR_VAR 0 7
15646: PUSH
15647: LD_VAR 0 2
15651: PUSH
15652: FOR_IN
15653: IFFALSE 15869
// begin if IsInUnit ( i ) then
15655: LD_VAR 0 7
15659: PPUSH
15660: CALL_OW 310
15664: IFFALSE 15675
// ComExitBuilding ( i ) ;
15666: LD_VAR 0 7
15670: PPUSH
15671: CALL_OW 122
// if GetLives ( i ) > 333 then
15675: LD_VAR 0 7
15679: PPUSH
15680: CALL_OW 256
15684: PUSH
15685: LD_INT 333
15687: GREATER
15688: IFFALSE 15716
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15690: LD_VAR 0 7
15694: PPUSH
15695: LD_VAR 0 5
15699: PPUSH
15700: LD_VAR 0 7
15704: PPUSH
15705: CALL_OW 74
15709: PPUSH
15710: CALL_OW 115
15714: GO 15867
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15716: LD_ADDR_VAR 0 8
15720: PUSH
15721: LD_EXP 58
15725: PUSH
15726: LD_VAR 0 1
15730: ARRAY
15731: PPUSH
15732: LD_INT 2
15734: PUSH
15735: LD_INT 30
15737: PUSH
15738: LD_INT 0
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 30
15747: PUSH
15748: LD_INT 1
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 30
15757: PUSH
15758: LD_INT 6
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: EMPTY
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: PPUSH
15771: CALL_OW 72
15775: PPUSH
15776: LD_VAR 0 7
15780: PPUSH
15781: CALL_OW 74
15785: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15786: LD_VAR 0 7
15790: PPUSH
15791: LD_VAR 0 8
15795: PPUSH
15796: CALL_OW 250
15800: PPUSH
15801: LD_INT 3
15803: PPUSH
15804: LD_INT 5
15806: PPUSH
15807: CALL_OW 272
15811: PPUSH
15812: LD_VAR 0 8
15816: PPUSH
15817: CALL_OW 251
15821: PPUSH
15822: LD_INT 3
15824: PPUSH
15825: LD_INT 5
15827: PPUSH
15828: CALL_OW 273
15832: PPUSH
15833: CALL_OW 111
// SetTag ( i , 0 ) ;
15837: LD_VAR 0 7
15841: PPUSH
15842: LD_INT 0
15844: PPUSH
15845: CALL_OW 109
// solds := solds diff i ;
15849: LD_ADDR_VAR 0 2
15853: PUSH
15854: LD_VAR 0 2
15858: PUSH
15859: LD_VAR 0 7
15863: DIFF
15864: ST_TO_ADDR
// continue ;
15865: GO 15652
// end ; end ;
15867: GO 15652
15869: POP
15870: POP
// until solds ;
15871: LD_VAR 0 2
15875: IFFALSE 15547
// MC_Reset ( base , 18 ) ;
15877: LD_VAR 0 1
15881: PPUSH
15882: LD_INT 18
15884: PPUSH
15885: CALL 59388 0 2
// end ;
15889: LD_VAR 0 4
15893: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15894: LD_INT 0
15896: PPUSH
15897: PPUSH
15898: PPUSH
15899: PPUSH
15900: PPUSH
15901: PPUSH
15902: PPUSH
15903: PPUSH
15904: PPUSH
15905: PPUSH
15906: PPUSH
15907: PPUSH
15908: PPUSH
15909: PPUSH
15910: PPUSH
15911: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15912: LD_ADDR_VAR 0 12
15916: PUSH
15917: LD_EXP 58
15921: PUSH
15922: LD_VAR 0 1
15926: ARRAY
15927: PPUSH
15928: LD_INT 25
15930: PUSH
15931: LD_INT 3
15933: PUSH
15934: EMPTY
15935: LIST
15936: LIST
15937: PPUSH
15938: CALL_OW 72
15942: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15943: LD_ADDR_VAR 0 8
15947: PUSH
15948: LD_EXP 58
15952: PUSH
15953: LD_VAR 0 1
15957: ARRAY
15958: PPUSH
15959: LD_INT 2
15961: PUSH
15962: LD_INT 25
15964: PUSH
15965: LD_INT 1
15967: PUSH
15968: EMPTY
15969: LIST
15970: LIST
15971: PUSH
15972: LD_INT 25
15974: PUSH
15975: LD_INT 5
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: PUSH
15982: LD_INT 25
15984: PUSH
15985: LD_INT 8
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: PUSH
15992: LD_INT 25
15994: PUSH
15995: LD_INT 9
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: LIST
16008: PPUSH
16009: CALL_OW 72
16013: ST_TO_ADDR
// if not defenders and not solds then
16014: LD_VAR 0 2
16018: NOT
16019: PUSH
16020: LD_VAR 0 8
16024: NOT
16025: AND
16026: IFFALSE 16030
// exit ;
16028: GO 17396
// depot_under_attack := false ;
16030: LD_ADDR_VAR 0 16
16034: PUSH
16035: LD_INT 0
16037: ST_TO_ADDR
// sold_defenders := [ ] ;
16038: LD_ADDR_VAR 0 17
16042: PUSH
16043: EMPTY
16044: ST_TO_ADDR
// if mechs then
16045: LD_VAR 0 12
16049: IFFALSE 16178
// for i in defenders do
16051: LD_ADDR_VAR 0 5
16055: PUSH
16056: LD_VAR 0 2
16060: PUSH
16061: FOR_IN
16062: IFFALSE 16176
// begin SetTag ( i , 20 ) ;
16064: LD_VAR 0 5
16068: PPUSH
16069: LD_INT 20
16071: PPUSH
16072: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16076: LD_VAR 0 5
16080: PPUSH
16081: CALL_OW 263
16085: PUSH
16086: LD_INT 1
16088: EQUAL
16089: PUSH
16090: LD_VAR 0 5
16094: PPUSH
16095: CALL_OW 311
16099: NOT
16100: AND
16101: PUSH
16102: LD_VAR 0 12
16106: AND
16107: IFFALSE 16174
// begin un := mechs [ 1 ] ;
16109: LD_ADDR_VAR 0 10
16113: PUSH
16114: LD_VAR 0 12
16118: PUSH
16119: LD_INT 1
16121: ARRAY
16122: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16123: LD_VAR 0 10
16127: PPUSH
16128: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16132: LD_VAR 0 10
16136: PPUSH
16137: LD_VAR 0 5
16141: PPUSH
16142: CALL_OW 180
// SetTag ( un , 19 ) ;
16146: LD_VAR 0 10
16150: PPUSH
16151: LD_INT 19
16153: PPUSH
16154: CALL_OW 109
// mechs := mechs diff un ;
16158: LD_ADDR_VAR 0 12
16162: PUSH
16163: LD_VAR 0 12
16167: PUSH
16168: LD_VAR 0 10
16172: DIFF
16173: ST_TO_ADDR
// end ; end ;
16174: GO 16061
16176: POP
16177: POP
// if solds then
16178: LD_VAR 0 8
16182: IFFALSE 16241
// for i in solds do
16184: LD_ADDR_VAR 0 5
16188: PUSH
16189: LD_VAR 0 8
16193: PUSH
16194: FOR_IN
16195: IFFALSE 16239
// if not GetTag ( i ) then
16197: LD_VAR 0 5
16201: PPUSH
16202: CALL_OW 110
16206: NOT
16207: IFFALSE 16237
// begin defenders := defenders union i ;
16209: LD_ADDR_VAR 0 2
16213: PUSH
16214: LD_VAR 0 2
16218: PUSH
16219: LD_VAR 0 5
16223: UNION
16224: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16225: LD_VAR 0 5
16229: PPUSH
16230: LD_INT 18
16232: PPUSH
16233: CALL_OW 109
// end ;
16237: GO 16194
16239: POP
16240: POP
// repeat wait ( 0 0$1 ) ;
16241: LD_INT 35
16243: PPUSH
16244: CALL_OW 67
// enemy := mc_scan [ base ] ;
16248: LD_ADDR_VAR 0 3
16252: PUSH
16253: LD_EXP 81
16257: PUSH
16258: LD_VAR 0 1
16262: ARRAY
16263: ST_TO_ADDR
// for i in defenders do
16264: LD_ADDR_VAR 0 5
16268: PUSH
16269: LD_VAR 0 2
16273: PUSH
16274: FOR_IN
16275: IFFALSE 16960
// begin e := NearestUnitToUnit ( enemy , i ) ;
16277: LD_ADDR_VAR 0 13
16281: PUSH
16282: LD_VAR 0 3
16286: PPUSH
16287: LD_VAR 0 5
16291: PPUSH
16292: CALL_OW 74
16296: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16297: LD_ADDR_VAR 0 16
16301: PUSH
16302: LD_EXP 58
16306: PUSH
16307: LD_VAR 0 1
16311: ARRAY
16312: PPUSH
16313: LD_INT 2
16315: PUSH
16316: LD_INT 30
16318: PUSH
16319: LD_INT 0
16321: PUSH
16322: EMPTY
16323: LIST
16324: LIST
16325: PUSH
16326: LD_INT 30
16328: PUSH
16329: LD_INT 1
16331: PUSH
16332: EMPTY
16333: LIST
16334: LIST
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: LIST
16340: PPUSH
16341: CALL_OW 72
16345: NOT
16346: PUSH
16347: LD_EXP 58
16351: PUSH
16352: LD_VAR 0 1
16356: ARRAY
16357: PPUSH
16358: LD_INT 2
16360: PUSH
16361: LD_INT 30
16363: PUSH
16364: LD_INT 0
16366: PUSH
16367: EMPTY
16368: LIST
16369: LIST
16370: PUSH
16371: LD_INT 30
16373: PUSH
16374: LD_INT 1
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PUSH
16381: EMPTY
16382: LIST
16383: LIST
16384: LIST
16385: PPUSH
16386: CALL_OW 72
16390: PPUSH
16391: CALL_OW 256
16395: PUSH
16396: LD_INT 600
16398: LESS
16399: OR
16400: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16401: LD_VAR 0 5
16405: PPUSH
16406: CALL_OW 247
16410: PUSH
16411: LD_INT 2
16413: DOUBLE
16414: EQUAL
16415: IFTRUE 16419
16417: GO 16666
16419: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16420: LD_VAR 0 5
16424: PPUSH
16425: CALL_OW 256
16429: PUSH
16430: LD_INT 650
16432: GREATER
16433: PUSH
16434: LD_VAR 0 5
16438: PPUSH
16439: LD_VAR 0 13
16443: PPUSH
16444: CALL_OW 296
16448: PUSH
16449: LD_INT 40
16451: LESS
16452: AND
16453: IFFALSE 16471
// ComAttackUnit ( i , e ) else
16455: LD_VAR 0 5
16459: PPUSH
16460: LD_VAR 0 13
16464: PPUSH
16465: CALL_OW 115
16469: GO 16549
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16471: LD_VAR 0 5
16475: PPUSH
16476: LD_VAR 0 13
16480: PPUSH
16481: CALL_OW 296
16485: PUSH
16486: LD_INT 30
16488: GREATEREQUAL
16489: PUSH
16490: LD_VAR 0 5
16494: PPUSH
16495: CALL_OW 256
16499: PUSH
16500: LD_INT 650
16502: LESSEQUAL
16503: OR
16504: PUSH
16505: LD_VAR 0 5
16509: PPUSH
16510: LD_EXP 82
16514: PUSH
16515: LD_VAR 0 1
16519: ARRAY
16520: PPUSH
16521: CALL_OW 308
16525: NOT
16526: AND
16527: IFFALSE 16549
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16529: LD_VAR 0 5
16533: PPUSH
16534: LD_EXP 82
16538: PUSH
16539: LD_VAR 0 1
16543: ARRAY
16544: PPUSH
16545: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16549: LD_VAR 0 5
16553: PPUSH
16554: CALL_OW 256
16558: PUSH
16559: LD_INT 998
16561: LESS
16562: PUSH
16563: LD_VAR 0 5
16567: PPUSH
16568: CALL_OW 263
16572: PUSH
16573: LD_INT 1
16575: EQUAL
16576: AND
16577: PUSH
16578: LD_VAR 0 5
16582: PPUSH
16583: CALL_OW 311
16587: AND
16588: PUSH
16589: LD_VAR 0 5
16593: PPUSH
16594: LD_EXP 82
16598: PUSH
16599: LD_VAR 0 1
16603: ARRAY
16604: PPUSH
16605: CALL_OW 308
16609: AND
16610: IFFALSE 16664
// begin mech := IsDrivenBy ( i ) ;
16612: LD_ADDR_VAR 0 9
16616: PUSH
16617: LD_VAR 0 5
16621: PPUSH
16622: CALL_OW 311
16626: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16627: LD_VAR 0 9
16631: PPUSH
16632: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16636: LD_VAR 0 9
16640: PPUSH
16641: LD_VAR 0 5
16645: PPUSH
16646: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16650: LD_VAR 0 9
16654: PPUSH
16655: LD_VAR 0 5
16659: PPUSH
16660: CALL_OW 180
// end ; end ; unit_human :
16664: GO 16931
16666: LD_INT 1
16668: DOUBLE
16669: EQUAL
16670: IFTRUE 16674
16672: GO 16930
16674: POP
// begin b := IsInUnit ( i ) ;
16675: LD_ADDR_VAR 0 18
16679: PUSH
16680: LD_VAR 0 5
16684: PPUSH
16685: CALL_OW 310
16689: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16690: LD_ADDR_VAR 0 19
16694: PUSH
16695: LD_VAR 0 18
16699: NOT
16700: PUSH
16701: LD_VAR 0 18
16705: PPUSH
16706: CALL_OW 266
16710: PUSH
16711: LD_INT 32
16713: PUSH
16714: LD_INT 31
16716: PUSH
16717: EMPTY
16718: LIST
16719: LIST
16720: IN
16721: OR
16722: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16723: LD_VAR 0 16
16727: PUSH
16728: LD_VAR 0 2
16732: PPUSH
16733: LD_INT 21
16735: PUSH
16736: LD_INT 2
16738: PUSH
16739: EMPTY
16740: LIST
16741: LIST
16742: PPUSH
16743: CALL_OW 72
16747: PUSH
16748: LD_INT 1
16750: LESSEQUAL
16751: OR
16752: PUSH
16753: LD_VAR 0 19
16757: AND
16758: PUSH
16759: LD_VAR 0 5
16763: PUSH
16764: LD_VAR 0 17
16768: IN
16769: NOT
16770: AND
16771: IFFALSE 16864
// begin if b then
16773: LD_VAR 0 18
16777: IFFALSE 16826
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16779: LD_VAR 0 18
16783: PPUSH
16784: LD_VAR 0 3
16788: PPUSH
16789: LD_VAR 0 18
16793: PPUSH
16794: CALL_OW 74
16798: PPUSH
16799: CALL_OW 296
16803: PUSH
16804: LD_INT 10
16806: LESS
16807: PUSH
16808: LD_VAR 0 18
16812: PPUSH
16813: CALL_OW 461
16817: PUSH
16818: LD_INT 7
16820: NONEQUAL
16821: AND
16822: IFFALSE 16826
// continue ;
16824: GO 16274
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16826: LD_ADDR_VAR 0 17
16830: PUSH
16831: LD_VAR 0 17
16835: PPUSH
16836: LD_VAR 0 17
16840: PUSH
16841: LD_INT 1
16843: PLUS
16844: PPUSH
16845: LD_VAR 0 5
16849: PPUSH
16850: CALL_OW 1
16854: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16855: LD_VAR 0 5
16859: PPUSH
16860: CALL_OW 122
// end ; if sold_defenders then
16864: LD_VAR 0 17
16868: IFFALSE 16928
// if i in sold_defenders then
16870: LD_VAR 0 5
16874: PUSH
16875: LD_VAR 0 17
16879: IN
16880: IFFALSE 16928
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16882: LD_VAR 0 5
16886: PPUSH
16887: CALL_OW 314
16891: NOT
16892: PUSH
16893: LD_VAR 0 5
16897: PPUSH
16898: LD_VAR 0 13
16902: PPUSH
16903: CALL_OW 296
16907: PUSH
16908: LD_INT 30
16910: LESS
16911: AND
16912: IFFALSE 16928
// ComAttackUnit ( i , e ) ;
16914: LD_VAR 0 5
16918: PPUSH
16919: LD_VAR 0 13
16923: PPUSH
16924: CALL_OW 115
// end ; end ; end ;
16928: GO 16931
16930: POP
// if IsDead ( i ) then
16931: LD_VAR 0 5
16935: PPUSH
16936: CALL_OW 301
16940: IFFALSE 16958
// defenders := defenders diff i ;
16942: LD_ADDR_VAR 0 2
16946: PUSH
16947: LD_VAR 0 2
16951: PUSH
16952: LD_VAR 0 5
16956: DIFF
16957: ST_TO_ADDR
// end ;
16958: GO 16274
16960: POP
16961: POP
// until not enemy or not defenders ;
16962: LD_VAR 0 3
16966: NOT
16967: PUSH
16968: LD_VAR 0 2
16972: NOT
16973: OR
16974: IFFALSE 16241
// MC_Reset ( base , 18 ) ;
16976: LD_VAR 0 1
16980: PPUSH
16981: LD_INT 18
16983: PPUSH
16984: CALL 59388 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16988: LD_ADDR_VAR 0 2
16992: PUSH
16993: LD_VAR 0 2
16997: PUSH
16998: LD_VAR 0 2
17002: PPUSH
17003: LD_INT 2
17005: PUSH
17006: LD_INT 25
17008: PUSH
17009: LD_INT 1
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: LD_INT 25
17018: PUSH
17019: LD_INT 5
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: PUSH
17026: LD_INT 25
17028: PUSH
17029: LD_INT 8
17031: PUSH
17032: EMPTY
17033: LIST
17034: LIST
17035: PUSH
17036: LD_INT 25
17038: PUSH
17039: LD_INT 9
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: PUSH
17046: EMPTY
17047: LIST
17048: LIST
17049: LIST
17050: LIST
17051: LIST
17052: PPUSH
17053: CALL_OW 72
17057: DIFF
17058: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17059: LD_VAR 0 3
17063: NOT
17064: PUSH
17065: LD_VAR 0 2
17069: PPUSH
17070: LD_INT 21
17072: PUSH
17073: LD_INT 2
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PPUSH
17080: CALL_OW 72
17084: AND
17085: IFFALSE 17347
// begin tmp := FilterByTag ( defenders , 19 ) ;
17087: LD_ADDR_VAR 0 11
17091: PUSH
17092: LD_VAR 0 2
17096: PPUSH
17097: LD_INT 19
17099: PPUSH
17100: CALL 53694 0 2
17104: ST_TO_ADDR
// if tmp then
17105: LD_VAR 0 11
17109: IFFALSE 17179
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17111: LD_ADDR_VAR 0 11
17115: PUSH
17116: LD_VAR 0 11
17120: PPUSH
17121: LD_INT 25
17123: PUSH
17124: LD_INT 3
17126: PUSH
17127: EMPTY
17128: LIST
17129: LIST
17130: PPUSH
17131: CALL_OW 72
17135: ST_TO_ADDR
// if tmp then
17136: LD_VAR 0 11
17140: IFFALSE 17179
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17142: LD_ADDR_EXP 70
17146: PUSH
17147: LD_EXP 70
17151: PPUSH
17152: LD_VAR 0 1
17156: PPUSH
17157: LD_EXP 70
17161: PUSH
17162: LD_VAR 0 1
17166: ARRAY
17167: PUSH
17168: LD_VAR 0 11
17172: UNION
17173: PPUSH
17174: CALL_OW 1
17178: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17179: LD_VAR 0 1
17183: PPUSH
17184: LD_INT 19
17186: PPUSH
17187: CALL 59388 0 2
// repeat wait ( 0 0$1 ) ;
17191: LD_INT 35
17193: PPUSH
17194: CALL_OW 67
// for i in defenders do
17198: LD_ADDR_VAR 0 5
17202: PUSH
17203: LD_VAR 0 2
17207: PUSH
17208: FOR_IN
17209: IFFALSE 17298
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17211: LD_VAR 0 5
17215: PPUSH
17216: LD_EXP 82
17220: PUSH
17221: LD_VAR 0 1
17225: ARRAY
17226: PPUSH
17227: CALL_OW 308
17231: NOT
17232: IFFALSE 17256
// ComMoveToArea ( i , mc_parking [ base ] ) else
17234: LD_VAR 0 5
17238: PPUSH
17239: LD_EXP 82
17243: PUSH
17244: LD_VAR 0 1
17248: ARRAY
17249: PPUSH
17250: CALL_OW 113
17254: GO 17296
// if GetControl ( i ) = control_manual then
17256: LD_VAR 0 5
17260: PPUSH
17261: CALL_OW 263
17265: PUSH
17266: LD_INT 1
17268: EQUAL
17269: IFFALSE 17296
// if IsDrivenBy ( i ) then
17271: LD_VAR 0 5
17275: PPUSH
17276: CALL_OW 311
17280: IFFALSE 17296
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17282: LD_VAR 0 5
17286: PPUSH
17287: CALL_OW 311
17291: PPUSH
17292: CALL_OW 121
// end ;
17296: GO 17208
17298: POP
17299: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17300: LD_VAR 0 2
17304: PPUSH
17305: LD_INT 95
17307: PUSH
17308: LD_EXP 82
17312: PUSH
17313: LD_VAR 0 1
17317: ARRAY
17318: PUSH
17319: EMPTY
17320: LIST
17321: LIST
17322: PPUSH
17323: CALL_OW 72
17327: PUSH
17328: LD_VAR 0 2
17332: EQUAL
17333: PUSH
17334: LD_EXP 81
17338: PUSH
17339: LD_VAR 0 1
17343: ARRAY
17344: OR
17345: IFFALSE 17191
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17347: LD_ADDR_EXP 80
17351: PUSH
17352: LD_EXP 80
17356: PPUSH
17357: LD_VAR 0 1
17361: PPUSH
17362: LD_EXP 80
17366: PUSH
17367: LD_VAR 0 1
17371: ARRAY
17372: PUSH
17373: LD_VAR 0 2
17377: UNION
17378: PPUSH
17379: CALL_OW 1
17383: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17384: LD_VAR 0 1
17388: PPUSH
17389: LD_INT 20
17391: PPUSH
17392: CALL 59388 0 2
// end ;
17396: LD_VAR 0 4
17400: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17401: LD_INT 0
17403: PPUSH
17404: PPUSH
17405: PPUSH
17406: PPUSH
// result := false ;
17407: LD_ADDR_VAR 0 2
17411: PUSH
17412: LD_INT 0
17414: ST_TO_ADDR
// side := GetSide ( unit ) ;
17415: LD_ADDR_VAR 0 3
17419: PUSH
17420: LD_VAR 0 1
17424: PPUSH
17425: CALL_OW 255
17429: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17430: LD_ADDR_VAR 0 4
17434: PUSH
17435: LD_VAR 0 1
17439: PPUSH
17440: CALL_OW 248
17444: ST_TO_ADDR
// case nat of 1 :
17445: LD_VAR 0 4
17449: PUSH
17450: LD_INT 1
17452: DOUBLE
17453: EQUAL
17454: IFTRUE 17458
17456: GO 17469
17458: POP
// tech := tech_lassight ; 2 :
17459: LD_ADDR_VAR 0 5
17463: PUSH
17464: LD_INT 12
17466: ST_TO_ADDR
17467: GO 17508
17469: LD_INT 2
17471: DOUBLE
17472: EQUAL
17473: IFTRUE 17477
17475: GO 17488
17477: POP
// tech := tech_mortar ; 3 :
17478: LD_ADDR_VAR 0 5
17482: PUSH
17483: LD_INT 41
17485: ST_TO_ADDR
17486: GO 17508
17488: LD_INT 3
17490: DOUBLE
17491: EQUAL
17492: IFTRUE 17496
17494: GO 17507
17496: POP
// tech := tech_bazooka ; end ;
17497: LD_ADDR_VAR 0 5
17501: PUSH
17502: LD_INT 44
17504: ST_TO_ADDR
17505: GO 17508
17507: POP
// if Researched ( side , tech ) then
17508: LD_VAR 0 3
17512: PPUSH
17513: LD_VAR 0 5
17517: PPUSH
17518: CALL_OW 325
17522: IFFALSE 17549
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17524: LD_ADDR_VAR 0 2
17528: PUSH
17529: LD_INT 5
17531: PUSH
17532: LD_INT 8
17534: PUSH
17535: LD_INT 9
17537: PUSH
17538: EMPTY
17539: LIST
17540: LIST
17541: LIST
17542: PUSH
17543: LD_VAR 0 4
17547: ARRAY
17548: ST_TO_ADDR
// end ;
17549: LD_VAR 0 2
17553: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17554: LD_INT 0
17556: PPUSH
17557: PPUSH
17558: PPUSH
// if not mines then
17559: LD_VAR 0 2
17563: NOT
17564: IFFALSE 17568
// exit ;
17566: GO 17712
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17568: LD_ADDR_VAR 0 5
17572: PUSH
17573: LD_INT 81
17575: PUSH
17576: LD_VAR 0 1
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: PUSH
17585: LD_INT 3
17587: PUSH
17588: LD_INT 21
17590: PUSH
17591: LD_INT 3
17593: PUSH
17594: EMPTY
17595: LIST
17596: LIST
17597: PUSH
17598: EMPTY
17599: LIST
17600: LIST
17601: PUSH
17602: EMPTY
17603: LIST
17604: LIST
17605: PPUSH
17606: CALL_OW 69
17610: ST_TO_ADDR
// for i in mines do
17611: LD_ADDR_VAR 0 4
17615: PUSH
17616: LD_VAR 0 2
17620: PUSH
17621: FOR_IN
17622: IFFALSE 17710
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17624: LD_VAR 0 4
17628: PUSH
17629: LD_INT 1
17631: ARRAY
17632: PPUSH
17633: LD_VAR 0 4
17637: PUSH
17638: LD_INT 2
17640: ARRAY
17641: PPUSH
17642: CALL_OW 458
17646: NOT
17647: IFFALSE 17651
// continue ;
17649: GO 17621
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17651: LD_VAR 0 4
17655: PUSH
17656: LD_INT 1
17658: ARRAY
17659: PPUSH
17660: LD_VAR 0 4
17664: PUSH
17665: LD_INT 2
17667: ARRAY
17668: PPUSH
17669: CALL_OW 428
17673: PUSH
17674: LD_VAR 0 5
17678: IN
17679: IFFALSE 17708
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17681: LD_VAR 0 4
17685: PUSH
17686: LD_INT 1
17688: ARRAY
17689: PPUSH
17690: LD_VAR 0 4
17694: PUSH
17695: LD_INT 2
17697: ARRAY
17698: PPUSH
17699: LD_VAR 0 1
17703: PPUSH
17704: CALL_OW 456
// end ;
17708: GO 17621
17710: POP
17711: POP
// end ;
17712: LD_VAR 0 3
17716: RET
// export function Count ( array ) ; var i ; begin
17717: LD_INT 0
17719: PPUSH
17720: PPUSH
// result := 0 ;
17721: LD_ADDR_VAR 0 2
17725: PUSH
17726: LD_INT 0
17728: ST_TO_ADDR
// for i in array do
17729: LD_ADDR_VAR 0 3
17733: PUSH
17734: LD_VAR 0 1
17738: PUSH
17739: FOR_IN
17740: IFFALSE 17764
// if i then
17742: LD_VAR 0 3
17746: IFFALSE 17762
// result := result + 1 ;
17748: LD_ADDR_VAR 0 2
17752: PUSH
17753: LD_VAR 0 2
17757: PUSH
17758: LD_INT 1
17760: PLUS
17761: ST_TO_ADDR
17762: GO 17739
17764: POP
17765: POP
// end ;
17766: LD_VAR 0 2
17770: RET
// export function IsEmpty ( building ) ; begin
17771: LD_INT 0
17773: PPUSH
// if not building then
17774: LD_VAR 0 1
17778: NOT
17779: IFFALSE 17783
// exit ;
17781: GO 17826
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17783: LD_ADDR_VAR 0 2
17787: PUSH
17788: LD_VAR 0 1
17792: PUSH
17793: LD_INT 22
17795: PUSH
17796: LD_VAR 0 1
17800: PPUSH
17801: CALL_OW 255
17805: PUSH
17806: EMPTY
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 58
17812: PUSH
17813: EMPTY
17814: LIST
17815: PUSH
17816: EMPTY
17817: LIST
17818: LIST
17819: PPUSH
17820: CALL_OW 69
17824: IN
17825: ST_TO_ADDR
// end ;
17826: LD_VAR 0 2
17830: RET
// export function IsNotFull ( building ) ; begin
17831: LD_INT 0
17833: PPUSH
// if not building then
17834: LD_VAR 0 1
17838: NOT
17839: IFFALSE 17843
// exit ;
17841: GO 17862
// result := UnitsInside ( building ) < 6 ;
17843: LD_ADDR_VAR 0 2
17847: PUSH
17848: LD_VAR 0 1
17852: PPUSH
17853: CALL_OW 313
17857: PUSH
17858: LD_INT 6
17860: LESS
17861: ST_TO_ADDR
// end ;
17862: LD_VAR 0 2
17866: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17867: LD_INT 0
17869: PPUSH
17870: PPUSH
17871: PPUSH
17872: PPUSH
// tmp := [ ] ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: EMPTY
17879: ST_TO_ADDR
// list := [ ] ;
17880: LD_ADDR_VAR 0 5
17884: PUSH
17885: EMPTY
17886: ST_TO_ADDR
// for i = 16 to 25 do
17887: LD_ADDR_VAR 0 4
17891: PUSH
17892: DOUBLE
17893: LD_INT 16
17895: DEC
17896: ST_TO_ADDR
17897: LD_INT 25
17899: PUSH
17900: FOR_TO
17901: IFFALSE 17974
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17903: LD_ADDR_VAR 0 3
17907: PUSH
17908: LD_VAR 0 3
17912: PUSH
17913: LD_INT 22
17915: PUSH
17916: LD_VAR 0 1
17920: PPUSH
17921: CALL_OW 255
17925: PUSH
17926: EMPTY
17927: LIST
17928: LIST
17929: PUSH
17930: LD_INT 91
17932: PUSH
17933: LD_VAR 0 1
17937: PUSH
17938: LD_INT 6
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: PUSH
17946: LD_INT 30
17948: PUSH
17949: LD_VAR 0 4
17953: PUSH
17954: EMPTY
17955: LIST
17956: LIST
17957: PUSH
17958: EMPTY
17959: LIST
17960: LIST
17961: LIST
17962: PUSH
17963: EMPTY
17964: LIST
17965: PPUSH
17966: CALL_OW 69
17970: ADD
17971: ST_TO_ADDR
17972: GO 17900
17974: POP
17975: POP
// for i = 1 to tmp do
17976: LD_ADDR_VAR 0 4
17980: PUSH
17981: DOUBLE
17982: LD_INT 1
17984: DEC
17985: ST_TO_ADDR
17986: LD_VAR 0 3
17990: PUSH
17991: FOR_TO
17992: IFFALSE 18080
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17994: LD_ADDR_VAR 0 5
17998: PUSH
17999: LD_VAR 0 5
18003: PUSH
18004: LD_VAR 0 3
18008: PUSH
18009: LD_VAR 0 4
18013: ARRAY
18014: PPUSH
18015: CALL_OW 266
18019: PUSH
18020: LD_VAR 0 3
18024: PUSH
18025: LD_VAR 0 4
18029: ARRAY
18030: PPUSH
18031: CALL_OW 250
18035: PUSH
18036: LD_VAR 0 3
18040: PUSH
18041: LD_VAR 0 4
18045: ARRAY
18046: PPUSH
18047: CALL_OW 251
18051: PUSH
18052: LD_VAR 0 3
18056: PUSH
18057: LD_VAR 0 4
18061: ARRAY
18062: PPUSH
18063: CALL_OW 254
18067: PUSH
18068: EMPTY
18069: LIST
18070: LIST
18071: LIST
18072: LIST
18073: PUSH
18074: EMPTY
18075: LIST
18076: ADD
18077: ST_TO_ADDR
18078: GO 17991
18080: POP
18081: POP
// result := list ;
18082: LD_ADDR_VAR 0 2
18086: PUSH
18087: LD_VAR 0 5
18091: ST_TO_ADDR
// end ;
18092: LD_VAR 0 2
18096: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18097: LD_INT 0
18099: PPUSH
18100: PPUSH
18101: PPUSH
18102: PPUSH
18103: PPUSH
18104: PPUSH
18105: PPUSH
// if not factory then
18106: LD_VAR 0 1
18110: NOT
18111: IFFALSE 18115
// exit ;
18113: GO 18640
// if control = control_apeman then
18115: LD_VAR 0 4
18119: PUSH
18120: LD_INT 5
18122: EQUAL
18123: IFFALSE 18232
// begin tmp := UnitsInside ( factory ) ;
18125: LD_ADDR_VAR 0 8
18129: PUSH
18130: LD_VAR 0 1
18134: PPUSH
18135: CALL_OW 313
18139: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18140: LD_VAR 0 8
18144: PPUSH
18145: LD_INT 25
18147: PUSH
18148: LD_INT 12
18150: PUSH
18151: EMPTY
18152: LIST
18153: LIST
18154: PPUSH
18155: CALL_OW 72
18159: NOT
18160: IFFALSE 18170
// control := control_manual ;
18162: LD_ADDR_VAR 0 4
18166: PUSH
18167: LD_INT 1
18169: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18170: LD_ADDR_VAR 0 8
18174: PUSH
18175: LD_VAR 0 1
18179: PPUSH
18180: CALL 17867 0 1
18184: ST_TO_ADDR
// if tmp then
18185: LD_VAR 0 8
18189: IFFALSE 18232
// begin for i in tmp do
18191: LD_ADDR_VAR 0 7
18195: PUSH
18196: LD_VAR 0 8
18200: PUSH
18201: FOR_IN
18202: IFFALSE 18230
// if i [ 1 ] = b_ext_radar then
18204: LD_VAR 0 7
18208: PUSH
18209: LD_INT 1
18211: ARRAY
18212: PUSH
18213: LD_INT 20
18215: EQUAL
18216: IFFALSE 18228
// begin control := control_remote ;
18218: LD_ADDR_VAR 0 4
18222: PUSH
18223: LD_INT 2
18225: ST_TO_ADDR
// break ;
18226: GO 18230
// end ;
18228: GO 18201
18230: POP
18231: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18232: LD_VAR 0 1
18236: PPUSH
18237: LD_VAR 0 2
18241: PPUSH
18242: LD_VAR 0 3
18246: PPUSH
18247: LD_VAR 0 4
18251: PPUSH
18252: LD_VAR 0 5
18256: PPUSH
18257: CALL_OW 448
18261: IFFALSE 18296
// begin result := [ chassis , engine , control , weapon ] ;
18263: LD_ADDR_VAR 0 6
18267: PUSH
18268: LD_VAR 0 2
18272: PUSH
18273: LD_VAR 0 3
18277: PUSH
18278: LD_VAR 0 4
18282: PUSH
18283: LD_VAR 0 5
18287: PUSH
18288: EMPTY
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: ST_TO_ADDR
// exit ;
18294: GO 18640
// end ; _chassis := AvailableChassisList ( factory ) ;
18296: LD_ADDR_VAR 0 9
18300: PUSH
18301: LD_VAR 0 1
18305: PPUSH
18306: CALL_OW 475
18310: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18311: LD_ADDR_VAR 0 11
18315: PUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: CALL_OW 476
18325: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18326: LD_ADDR_VAR 0 12
18330: PUSH
18331: LD_VAR 0 1
18335: PPUSH
18336: CALL_OW 477
18340: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18341: LD_ADDR_VAR 0 10
18345: PUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: CALL_OW 478
18355: ST_TO_ADDR
// if not chassis in _chassis then
18356: LD_VAR 0 2
18360: PUSH
18361: LD_VAR 0 9
18365: IN
18366: NOT
18367: IFFALSE 18393
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18369: LD_ADDR_VAR 0 2
18373: PUSH
18374: LD_VAR 0 9
18378: PUSH
18379: LD_INT 1
18381: PPUSH
18382: LD_VAR 0 9
18386: PPUSH
18387: CALL_OW 12
18391: ARRAY
18392: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18393: LD_VAR 0 2
18397: PPUSH
18398: LD_VAR 0 3
18402: PPUSH
18403: CALL 18645 0 2
18407: NOT
18408: IFFALSE 18467
// repeat engine := _engine [ 1 ] ;
18410: LD_ADDR_VAR 0 3
18414: PUSH
18415: LD_VAR 0 11
18419: PUSH
18420: LD_INT 1
18422: ARRAY
18423: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18424: LD_ADDR_VAR 0 11
18428: PUSH
18429: LD_VAR 0 11
18433: PPUSH
18434: LD_INT 1
18436: PPUSH
18437: CALL_OW 3
18441: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18442: LD_VAR 0 2
18446: PPUSH
18447: LD_VAR 0 3
18451: PPUSH
18452: CALL 18645 0 2
18456: PUSH
18457: LD_VAR 0 11
18461: PUSH
18462: EMPTY
18463: EQUAL
18464: OR
18465: IFFALSE 18410
// if not control in _control then
18467: LD_VAR 0 4
18471: PUSH
18472: LD_VAR 0 12
18476: IN
18477: NOT
18478: IFFALSE 18504
// control := _control [ rand ( 1 , _control ) ] ;
18480: LD_ADDR_VAR 0 4
18484: PUSH
18485: LD_VAR 0 12
18489: PUSH
18490: LD_INT 1
18492: PPUSH
18493: LD_VAR 0 12
18497: PPUSH
18498: CALL_OW 12
18502: ARRAY
18503: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18504: LD_VAR 0 2
18508: PPUSH
18509: LD_VAR 0 5
18513: PPUSH
18514: CALL 18865 0 2
18518: NOT
18519: IFFALSE 18578
// repeat weapon := _weapon [ 1 ] ;
18521: LD_ADDR_VAR 0 5
18525: PUSH
18526: LD_VAR 0 10
18530: PUSH
18531: LD_INT 1
18533: ARRAY
18534: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18535: LD_ADDR_VAR 0 10
18539: PUSH
18540: LD_VAR 0 10
18544: PPUSH
18545: LD_INT 1
18547: PPUSH
18548: CALL_OW 3
18552: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18553: LD_VAR 0 2
18557: PPUSH
18558: LD_VAR 0 5
18562: PPUSH
18563: CALL 18865 0 2
18567: PUSH
18568: LD_VAR 0 10
18572: PUSH
18573: EMPTY
18574: EQUAL
18575: OR
18576: IFFALSE 18521
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18578: LD_VAR 0 1
18582: PPUSH
18583: LD_VAR 0 2
18587: PPUSH
18588: LD_VAR 0 3
18592: PPUSH
18593: LD_VAR 0 4
18597: PPUSH
18598: LD_VAR 0 5
18602: PPUSH
18603: CALL_OW 448
18607: IFFALSE 18640
// result := [ chassis , engine , control , weapon ] ;
18609: LD_ADDR_VAR 0 6
18613: PUSH
18614: LD_VAR 0 2
18618: PUSH
18619: LD_VAR 0 3
18623: PUSH
18624: LD_VAR 0 4
18628: PUSH
18629: LD_VAR 0 5
18633: PUSH
18634: EMPTY
18635: LIST
18636: LIST
18637: LIST
18638: LIST
18639: ST_TO_ADDR
// end ;
18640: LD_VAR 0 6
18644: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18645: LD_INT 0
18647: PPUSH
// if not chassis or not engine then
18648: LD_VAR 0 1
18652: NOT
18653: PUSH
18654: LD_VAR 0 2
18658: NOT
18659: OR
18660: IFFALSE 18664
// exit ;
18662: GO 18860
// case engine of engine_solar :
18664: LD_VAR 0 2
18668: PUSH
18669: LD_INT 2
18671: DOUBLE
18672: EQUAL
18673: IFTRUE 18677
18675: GO 18715
18677: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18678: LD_ADDR_VAR 0 3
18682: PUSH
18683: LD_INT 11
18685: PUSH
18686: LD_INT 12
18688: PUSH
18689: LD_INT 13
18691: PUSH
18692: LD_INT 14
18694: PUSH
18695: LD_INT 1
18697: PUSH
18698: LD_INT 2
18700: PUSH
18701: LD_INT 3
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: ST_TO_ADDR
18713: GO 18844
18715: LD_INT 1
18717: DOUBLE
18718: EQUAL
18719: IFTRUE 18723
18721: GO 18785
18723: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18724: LD_ADDR_VAR 0 3
18728: PUSH
18729: LD_INT 11
18731: PUSH
18732: LD_INT 12
18734: PUSH
18735: LD_INT 13
18737: PUSH
18738: LD_INT 14
18740: PUSH
18741: LD_INT 1
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: LD_INT 3
18749: PUSH
18750: LD_INT 4
18752: PUSH
18753: LD_INT 5
18755: PUSH
18756: LD_INT 21
18758: PUSH
18759: LD_INT 23
18761: PUSH
18762: LD_INT 22
18764: PUSH
18765: LD_INT 24
18767: PUSH
18768: EMPTY
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: LIST
18775: LIST
18776: LIST
18777: LIST
18778: LIST
18779: LIST
18780: LIST
18781: LIST
18782: ST_TO_ADDR
18783: GO 18844
18785: LD_INT 3
18787: DOUBLE
18788: EQUAL
18789: IFTRUE 18793
18791: GO 18843
18793: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18794: LD_ADDR_VAR 0 3
18798: PUSH
18799: LD_INT 13
18801: PUSH
18802: LD_INT 14
18804: PUSH
18805: LD_INT 2
18807: PUSH
18808: LD_INT 3
18810: PUSH
18811: LD_INT 4
18813: PUSH
18814: LD_INT 5
18816: PUSH
18817: LD_INT 21
18819: PUSH
18820: LD_INT 22
18822: PUSH
18823: LD_INT 23
18825: PUSH
18826: LD_INT 24
18828: PUSH
18829: EMPTY
18830: LIST
18831: LIST
18832: LIST
18833: LIST
18834: LIST
18835: LIST
18836: LIST
18837: LIST
18838: LIST
18839: LIST
18840: ST_TO_ADDR
18841: GO 18844
18843: POP
// result := ( chassis in result ) ;
18844: LD_ADDR_VAR 0 3
18848: PUSH
18849: LD_VAR 0 1
18853: PUSH
18854: LD_VAR 0 3
18858: IN
18859: ST_TO_ADDR
// end ;
18860: LD_VAR 0 3
18864: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18865: LD_INT 0
18867: PPUSH
// if not chassis or not weapon then
18868: LD_VAR 0 1
18872: NOT
18873: PUSH
18874: LD_VAR 0 2
18878: NOT
18879: OR
18880: IFFALSE 18884
// exit ;
18882: GO 19910
// case weapon of us_machine_gun :
18884: LD_VAR 0 2
18888: PUSH
18889: LD_INT 2
18891: DOUBLE
18892: EQUAL
18893: IFTRUE 18897
18895: GO 18927
18897: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18898: LD_ADDR_VAR 0 3
18902: PUSH
18903: LD_INT 1
18905: PUSH
18906: LD_INT 2
18908: PUSH
18909: LD_INT 3
18911: PUSH
18912: LD_INT 4
18914: PUSH
18915: LD_INT 5
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: ST_TO_ADDR
18925: GO 19894
18927: LD_INT 3
18929: DOUBLE
18930: EQUAL
18931: IFTRUE 18935
18933: GO 18965
18935: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18936: LD_ADDR_VAR 0 3
18940: PUSH
18941: LD_INT 1
18943: PUSH
18944: LD_INT 2
18946: PUSH
18947: LD_INT 3
18949: PUSH
18950: LD_INT 4
18952: PUSH
18953: LD_INT 5
18955: PUSH
18956: EMPTY
18957: LIST
18958: LIST
18959: LIST
18960: LIST
18961: LIST
18962: ST_TO_ADDR
18963: GO 19894
18965: LD_INT 11
18967: DOUBLE
18968: EQUAL
18969: IFTRUE 18973
18971: GO 19003
18973: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18974: LD_ADDR_VAR 0 3
18978: PUSH
18979: LD_INT 1
18981: PUSH
18982: LD_INT 2
18984: PUSH
18985: LD_INT 3
18987: PUSH
18988: LD_INT 4
18990: PUSH
18991: LD_INT 5
18993: PUSH
18994: EMPTY
18995: LIST
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: ST_TO_ADDR
19001: GO 19894
19003: LD_INT 4
19005: DOUBLE
19006: EQUAL
19007: IFTRUE 19011
19009: GO 19037
19011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_INT 2
19019: PUSH
19020: LD_INT 3
19022: PUSH
19023: LD_INT 4
19025: PUSH
19026: LD_INT 5
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: ST_TO_ADDR
19035: GO 19894
19037: LD_INT 5
19039: DOUBLE
19040: EQUAL
19041: IFTRUE 19045
19043: GO 19071
19045: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19046: LD_ADDR_VAR 0 3
19050: PUSH
19051: LD_INT 2
19053: PUSH
19054: LD_INT 3
19056: PUSH
19057: LD_INT 4
19059: PUSH
19060: LD_INT 5
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: ST_TO_ADDR
19069: GO 19894
19071: LD_INT 9
19073: DOUBLE
19074: EQUAL
19075: IFTRUE 19079
19077: GO 19105
19079: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19080: LD_ADDR_VAR 0 3
19084: PUSH
19085: LD_INT 2
19087: PUSH
19088: LD_INT 3
19090: PUSH
19091: LD_INT 4
19093: PUSH
19094: LD_INT 5
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: ST_TO_ADDR
19103: GO 19894
19105: LD_INT 7
19107: DOUBLE
19108: EQUAL
19109: IFTRUE 19113
19111: GO 19139
19113: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_INT 2
19121: PUSH
19122: LD_INT 3
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: ST_TO_ADDR
19137: GO 19894
19139: LD_INT 12
19141: DOUBLE
19142: EQUAL
19143: IFTRUE 19147
19145: GO 19173
19147: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: LD_INT 2
19155: PUSH
19156: LD_INT 3
19158: PUSH
19159: LD_INT 4
19161: PUSH
19162: LD_INT 5
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: LIST
19169: LIST
19170: ST_TO_ADDR
19171: GO 19894
19173: LD_INT 13
19175: DOUBLE
19176: EQUAL
19177: IFTRUE 19181
19179: GO 19207
19181: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19182: LD_ADDR_VAR 0 3
19186: PUSH
19187: LD_INT 2
19189: PUSH
19190: LD_INT 3
19192: PUSH
19193: LD_INT 4
19195: PUSH
19196: LD_INT 5
19198: PUSH
19199: EMPTY
19200: LIST
19201: LIST
19202: LIST
19203: LIST
19204: ST_TO_ADDR
19205: GO 19894
19207: LD_INT 14
19209: DOUBLE
19210: EQUAL
19211: IFTRUE 19215
19213: GO 19233
19215: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19216: LD_ADDR_VAR 0 3
19220: PUSH
19221: LD_INT 4
19223: PUSH
19224: LD_INT 5
19226: PUSH
19227: EMPTY
19228: LIST
19229: LIST
19230: ST_TO_ADDR
19231: GO 19894
19233: LD_INT 6
19235: DOUBLE
19236: EQUAL
19237: IFTRUE 19241
19239: GO 19259
19241: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19242: LD_ADDR_VAR 0 3
19246: PUSH
19247: LD_INT 4
19249: PUSH
19250: LD_INT 5
19252: PUSH
19253: EMPTY
19254: LIST
19255: LIST
19256: ST_TO_ADDR
19257: GO 19894
19259: LD_INT 10
19261: DOUBLE
19262: EQUAL
19263: IFTRUE 19267
19265: GO 19285
19267: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19268: LD_ADDR_VAR 0 3
19272: PUSH
19273: LD_INT 4
19275: PUSH
19276: LD_INT 5
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: ST_TO_ADDR
19283: GO 19894
19285: LD_INT 22
19287: DOUBLE
19288: EQUAL
19289: IFTRUE 19293
19291: GO 19319
19293: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_INT 11
19301: PUSH
19302: LD_INT 12
19304: PUSH
19305: LD_INT 13
19307: PUSH
19308: LD_INT 14
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: ST_TO_ADDR
19317: GO 19894
19319: LD_INT 23
19321: DOUBLE
19322: EQUAL
19323: IFTRUE 19327
19325: GO 19353
19327: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19328: LD_ADDR_VAR 0 3
19332: PUSH
19333: LD_INT 11
19335: PUSH
19336: LD_INT 12
19338: PUSH
19339: LD_INT 13
19341: PUSH
19342: LD_INT 14
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: ST_TO_ADDR
19351: GO 19894
19353: LD_INT 24
19355: DOUBLE
19356: EQUAL
19357: IFTRUE 19361
19359: GO 19387
19361: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19362: LD_ADDR_VAR 0 3
19366: PUSH
19367: LD_INT 11
19369: PUSH
19370: LD_INT 12
19372: PUSH
19373: LD_INT 13
19375: PUSH
19376: LD_INT 14
19378: PUSH
19379: EMPTY
19380: LIST
19381: LIST
19382: LIST
19383: LIST
19384: ST_TO_ADDR
19385: GO 19894
19387: LD_INT 30
19389: DOUBLE
19390: EQUAL
19391: IFTRUE 19395
19393: GO 19421
19395: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19396: LD_ADDR_VAR 0 3
19400: PUSH
19401: LD_INT 11
19403: PUSH
19404: LD_INT 12
19406: PUSH
19407: LD_INT 13
19409: PUSH
19410: LD_INT 14
19412: PUSH
19413: EMPTY
19414: LIST
19415: LIST
19416: LIST
19417: LIST
19418: ST_TO_ADDR
19419: GO 19894
19421: LD_INT 25
19423: DOUBLE
19424: EQUAL
19425: IFTRUE 19429
19427: GO 19447
19429: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19430: LD_ADDR_VAR 0 3
19434: PUSH
19435: LD_INT 13
19437: PUSH
19438: LD_INT 14
19440: PUSH
19441: EMPTY
19442: LIST
19443: LIST
19444: ST_TO_ADDR
19445: GO 19894
19447: LD_INT 27
19449: DOUBLE
19450: EQUAL
19451: IFTRUE 19455
19453: GO 19473
19455: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19456: LD_ADDR_VAR 0 3
19460: PUSH
19461: LD_INT 13
19463: PUSH
19464: LD_INT 14
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: ST_TO_ADDR
19471: GO 19894
19473: LD_INT 28
19475: DOUBLE
19476: EQUAL
19477: IFTRUE 19481
19479: GO 19499
19481: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19482: LD_ADDR_VAR 0 3
19486: PUSH
19487: LD_INT 13
19489: PUSH
19490: LD_INT 14
19492: PUSH
19493: EMPTY
19494: LIST
19495: LIST
19496: ST_TO_ADDR
19497: GO 19894
19499: LD_INT 29
19501: DOUBLE
19502: EQUAL
19503: IFTRUE 19507
19505: GO 19525
19507: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19508: LD_ADDR_VAR 0 3
19512: PUSH
19513: LD_INT 13
19515: PUSH
19516: LD_INT 14
19518: PUSH
19519: EMPTY
19520: LIST
19521: LIST
19522: ST_TO_ADDR
19523: GO 19894
19525: LD_INT 31
19527: DOUBLE
19528: EQUAL
19529: IFTRUE 19533
19531: GO 19551
19533: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19534: LD_ADDR_VAR 0 3
19538: PUSH
19539: LD_INT 13
19541: PUSH
19542: LD_INT 14
19544: PUSH
19545: EMPTY
19546: LIST
19547: LIST
19548: ST_TO_ADDR
19549: GO 19894
19551: LD_INT 26
19553: DOUBLE
19554: EQUAL
19555: IFTRUE 19559
19557: GO 19577
19559: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19560: LD_ADDR_VAR 0 3
19564: PUSH
19565: LD_INT 13
19567: PUSH
19568: LD_INT 14
19570: PUSH
19571: EMPTY
19572: LIST
19573: LIST
19574: ST_TO_ADDR
19575: GO 19894
19577: LD_INT 42
19579: DOUBLE
19580: EQUAL
19581: IFTRUE 19585
19583: GO 19611
19585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19586: LD_ADDR_VAR 0 3
19590: PUSH
19591: LD_INT 21
19593: PUSH
19594: LD_INT 22
19596: PUSH
19597: LD_INT 23
19599: PUSH
19600: LD_INT 24
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: ST_TO_ADDR
19609: GO 19894
19611: LD_INT 43
19613: DOUBLE
19614: EQUAL
19615: IFTRUE 19619
19617: GO 19645
19619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19620: LD_ADDR_VAR 0 3
19624: PUSH
19625: LD_INT 21
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 23
19633: PUSH
19634: LD_INT 24
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: ST_TO_ADDR
19643: GO 19894
19645: LD_INT 44
19647: DOUBLE
19648: EQUAL
19649: IFTRUE 19653
19651: GO 19679
19653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19654: LD_ADDR_VAR 0 3
19658: PUSH
19659: LD_INT 21
19661: PUSH
19662: LD_INT 22
19664: PUSH
19665: LD_INT 23
19667: PUSH
19668: LD_INT 24
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: ST_TO_ADDR
19677: GO 19894
19679: LD_INT 45
19681: DOUBLE
19682: EQUAL
19683: IFTRUE 19687
19685: GO 19713
19687: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: LD_INT 21
19695: PUSH
19696: LD_INT 22
19698: PUSH
19699: LD_INT 23
19701: PUSH
19702: LD_INT 24
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: ST_TO_ADDR
19711: GO 19894
19713: LD_INT 49
19715: DOUBLE
19716: EQUAL
19717: IFTRUE 19721
19719: GO 19747
19721: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19722: LD_ADDR_VAR 0 3
19726: PUSH
19727: LD_INT 21
19729: PUSH
19730: LD_INT 22
19732: PUSH
19733: LD_INT 23
19735: PUSH
19736: LD_INT 24
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
19745: GO 19894
19747: LD_INT 51
19749: DOUBLE
19750: EQUAL
19751: IFTRUE 19755
19753: GO 19781
19755: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: LD_INT 21
19763: PUSH
19764: LD_INT 22
19766: PUSH
19767: LD_INT 23
19769: PUSH
19770: LD_INT 24
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: ST_TO_ADDR
19779: GO 19894
19781: LD_INT 52
19783: DOUBLE
19784: EQUAL
19785: IFTRUE 19789
19787: GO 19815
19789: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19790: LD_ADDR_VAR 0 3
19794: PUSH
19795: LD_INT 21
19797: PUSH
19798: LD_INT 22
19800: PUSH
19801: LD_INT 23
19803: PUSH
19804: LD_INT 24
19806: PUSH
19807: EMPTY
19808: LIST
19809: LIST
19810: LIST
19811: LIST
19812: ST_TO_ADDR
19813: GO 19894
19815: LD_INT 53
19817: DOUBLE
19818: EQUAL
19819: IFTRUE 19823
19821: GO 19841
19823: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19824: LD_ADDR_VAR 0 3
19828: PUSH
19829: LD_INT 23
19831: PUSH
19832: LD_INT 24
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: ST_TO_ADDR
19839: GO 19894
19841: LD_INT 46
19843: DOUBLE
19844: EQUAL
19845: IFTRUE 19849
19847: GO 19867
19849: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19850: LD_ADDR_VAR 0 3
19854: PUSH
19855: LD_INT 23
19857: PUSH
19858: LD_INT 24
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: ST_TO_ADDR
19865: GO 19894
19867: LD_INT 47
19869: DOUBLE
19870: EQUAL
19871: IFTRUE 19875
19873: GO 19893
19875: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19876: LD_ADDR_VAR 0 3
19880: PUSH
19881: LD_INT 23
19883: PUSH
19884: LD_INT 24
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: ST_TO_ADDR
19891: GO 19894
19893: POP
// result := ( chassis in result ) ;
19894: LD_ADDR_VAR 0 3
19898: PUSH
19899: LD_VAR 0 1
19903: PUSH
19904: LD_VAR 0 3
19908: IN
19909: ST_TO_ADDR
// end ;
19910: LD_VAR 0 3
19914: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19915: LD_INT 0
19917: PPUSH
19918: PPUSH
19919: PPUSH
19920: PPUSH
19921: PPUSH
19922: PPUSH
19923: PPUSH
// result := array ;
19924: LD_ADDR_VAR 0 5
19928: PUSH
19929: LD_VAR 0 1
19933: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19934: LD_VAR 0 1
19938: NOT
19939: PUSH
19940: LD_VAR 0 2
19944: NOT
19945: OR
19946: PUSH
19947: LD_VAR 0 3
19951: NOT
19952: OR
19953: PUSH
19954: LD_VAR 0 2
19958: PUSH
19959: LD_VAR 0 1
19963: GREATER
19964: OR
19965: PUSH
19966: LD_VAR 0 3
19970: PUSH
19971: LD_VAR 0 1
19975: GREATER
19976: OR
19977: IFFALSE 19981
// exit ;
19979: GO 20277
// if direction then
19981: LD_VAR 0 4
19985: IFFALSE 20049
// begin d := 1 ;
19987: LD_ADDR_VAR 0 9
19991: PUSH
19992: LD_INT 1
19994: ST_TO_ADDR
// if i_from > i_to then
19995: LD_VAR 0 2
19999: PUSH
20000: LD_VAR 0 3
20004: GREATER
20005: IFFALSE 20031
// length := ( array - i_from ) + i_to else
20007: LD_ADDR_VAR 0 11
20011: PUSH
20012: LD_VAR 0 1
20016: PUSH
20017: LD_VAR 0 2
20021: MINUS
20022: PUSH
20023: LD_VAR 0 3
20027: PLUS
20028: ST_TO_ADDR
20029: GO 20047
// length := i_to - i_from ;
20031: LD_ADDR_VAR 0 11
20035: PUSH
20036: LD_VAR 0 3
20040: PUSH
20041: LD_VAR 0 2
20045: MINUS
20046: ST_TO_ADDR
// end else
20047: GO 20110
// begin d := - 1 ;
20049: LD_ADDR_VAR 0 9
20053: PUSH
20054: LD_INT 1
20056: NEG
20057: ST_TO_ADDR
// if i_from > i_to then
20058: LD_VAR 0 2
20062: PUSH
20063: LD_VAR 0 3
20067: GREATER
20068: IFFALSE 20088
// length := i_from - i_to else
20070: LD_ADDR_VAR 0 11
20074: PUSH
20075: LD_VAR 0 2
20079: PUSH
20080: LD_VAR 0 3
20084: MINUS
20085: ST_TO_ADDR
20086: GO 20110
// length := ( array - i_to ) + i_from ;
20088: LD_ADDR_VAR 0 11
20092: PUSH
20093: LD_VAR 0 1
20097: PUSH
20098: LD_VAR 0 3
20102: MINUS
20103: PUSH
20104: LD_VAR 0 2
20108: PLUS
20109: ST_TO_ADDR
// end ; if not length then
20110: LD_VAR 0 11
20114: NOT
20115: IFFALSE 20119
// exit ;
20117: GO 20277
// tmp := array ;
20119: LD_ADDR_VAR 0 10
20123: PUSH
20124: LD_VAR 0 1
20128: ST_TO_ADDR
// for i = 1 to length do
20129: LD_ADDR_VAR 0 6
20133: PUSH
20134: DOUBLE
20135: LD_INT 1
20137: DEC
20138: ST_TO_ADDR
20139: LD_VAR 0 11
20143: PUSH
20144: FOR_TO
20145: IFFALSE 20265
// begin for j = 1 to array do
20147: LD_ADDR_VAR 0 7
20151: PUSH
20152: DOUBLE
20153: LD_INT 1
20155: DEC
20156: ST_TO_ADDR
20157: LD_VAR 0 1
20161: PUSH
20162: FOR_TO
20163: IFFALSE 20251
// begin k := j + d ;
20165: LD_ADDR_VAR 0 8
20169: PUSH
20170: LD_VAR 0 7
20174: PUSH
20175: LD_VAR 0 9
20179: PLUS
20180: ST_TO_ADDR
// if k > array then
20181: LD_VAR 0 8
20185: PUSH
20186: LD_VAR 0 1
20190: GREATER
20191: IFFALSE 20201
// k := 1 ;
20193: LD_ADDR_VAR 0 8
20197: PUSH
20198: LD_INT 1
20200: ST_TO_ADDR
// if not k then
20201: LD_VAR 0 8
20205: NOT
20206: IFFALSE 20218
// k := array ;
20208: LD_ADDR_VAR 0 8
20212: PUSH
20213: LD_VAR 0 1
20217: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20218: LD_ADDR_VAR 0 10
20222: PUSH
20223: LD_VAR 0 10
20227: PPUSH
20228: LD_VAR 0 8
20232: PPUSH
20233: LD_VAR 0 1
20237: PUSH
20238: LD_VAR 0 7
20242: ARRAY
20243: PPUSH
20244: CALL_OW 1
20248: ST_TO_ADDR
// end ;
20249: GO 20162
20251: POP
20252: POP
// array := tmp ;
20253: LD_ADDR_VAR 0 1
20257: PUSH
20258: LD_VAR 0 10
20262: ST_TO_ADDR
// end ;
20263: GO 20144
20265: POP
20266: POP
// result := array ;
20267: LD_ADDR_VAR 0 5
20271: PUSH
20272: LD_VAR 0 1
20276: ST_TO_ADDR
// end ;
20277: LD_VAR 0 5
20281: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20282: LD_INT 0
20284: PPUSH
20285: PPUSH
// result := 0 ;
20286: LD_ADDR_VAR 0 3
20290: PUSH
20291: LD_INT 0
20293: ST_TO_ADDR
// if not array or not value in array then
20294: LD_VAR 0 1
20298: NOT
20299: PUSH
20300: LD_VAR 0 2
20304: PUSH
20305: LD_VAR 0 1
20309: IN
20310: NOT
20311: OR
20312: IFFALSE 20316
// exit ;
20314: GO 20370
// for i = 1 to array do
20316: LD_ADDR_VAR 0 4
20320: PUSH
20321: DOUBLE
20322: LD_INT 1
20324: DEC
20325: ST_TO_ADDR
20326: LD_VAR 0 1
20330: PUSH
20331: FOR_TO
20332: IFFALSE 20368
// if value = array [ i ] then
20334: LD_VAR 0 2
20338: PUSH
20339: LD_VAR 0 1
20343: PUSH
20344: LD_VAR 0 4
20348: ARRAY
20349: EQUAL
20350: IFFALSE 20366
// begin result := i ;
20352: LD_ADDR_VAR 0 3
20356: PUSH
20357: LD_VAR 0 4
20361: ST_TO_ADDR
// exit ;
20362: POP
20363: POP
20364: GO 20370
// end ;
20366: GO 20331
20368: POP
20369: POP
// end ;
20370: LD_VAR 0 3
20374: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20375: LD_INT 0
20377: PPUSH
// vc_chassis := chassis ;
20378: LD_ADDR_OWVAR 37
20382: PUSH
20383: LD_VAR 0 1
20387: ST_TO_ADDR
// vc_engine := engine ;
20388: LD_ADDR_OWVAR 39
20392: PUSH
20393: LD_VAR 0 2
20397: ST_TO_ADDR
// vc_control := control ;
20398: LD_ADDR_OWVAR 38
20402: PUSH
20403: LD_VAR 0 3
20407: ST_TO_ADDR
// vc_weapon := weapon ;
20408: LD_ADDR_OWVAR 40
20412: PUSH
20413: LD_VAR 0 4
20417: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20418: LD_ADDR_OWVAR 41
20422: PUSH
20423: LD_VAR 0 5
20427: ST_TO_ADDR
// end ;
20428: LD_VAR 0 6
20432: RET
// export function WantPlant ( unit ) ; var task ; begin
20433: LD_INT 0
20435: PPUSH
20436: PPUSH
// result := false ;
20437: LD_ADDR_VAR 0 2
20441: PUSH
20442: LD_INT 0
20444: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20445: LD_ADDR_VAR 0 3
20449: PUSH
20450: LD_VAR 0 1
20454: PPUSH
20455: CALL_OW 437
20459: ST_TO_ADDR
// if task then
20460: LD_VAR 0 3
20464: IFFALSE 20492
// if task [ 1 ] [ 1 ] = p then
20466: LD_VAR 0 3
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PUSH
20475: LD_INT 1
20477: ARRAY
20478: PUSH
20479: LD_STRING p
20481: EQUAL
20482: IFFALSE 20492
// result := true ;
20484: LD_ADDR_VAR 0 2
20488: PUSH
20489: LD_INT 1
20491: ST_TO_ADDR
// end ;
20492: LD_VAR 0 2
20496: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20497: LD_INT 0
20499: PPUSH
20500: PPUSH
20501: PPUSH
20502: PPUSH
// if pos < 1 then
20503: LD_VAR 0 2
20507: PUSH
20508: LD_INT 1
20510: LESS
20511: IFFALSE 20515
// exit ;
20513: GO 20818
// if pos = 1 then
20515: LD_VAR 0 2
20519: PUSH
20520: LD_INT 1
20522: EQUAL
20523: IFFALSE 20556
// result := Replace ( arr , pos [ 1 ] , value ) else
20525: LD_ADDR_VAR 0 4
20529: PUSH
20530: LD_VAR 0 1
20534: PPUSH
20535: LD_VAR 0 2
20539: PUSH
20540: LD_INT 1
20542: ARRAY
20543: PPUSH
20544: LD_VAR 0 3
20548: PPUSH
20549: CALL_OW 1
20553: ST_TO_ADDR
20554: GO 20818
// begin tmp := arr ;
20556: LD_ADDR_VAR 0 6
20560: PUSH
20561: LD_VAR 0 1
20565: ST_TO_ADDR
// s_arr := [ tmp ] ;
20566: LD_ADDR_VAR 0 7
20570: PUSH
20571: LD_VAR 0 6
20575: PUSH
20576: EMPTY
20577: LIST
20578: ST_TO_ADDR
// for i = 1 to pos - 1 do
20579: LD_ADDR_VAR 0 5
20583: PUSH
20584: DOUBLE
20585: LD_INT 1
20587: DEC
20588: ST_TO_ADDR
20589: LD_VAR 0 2
20593: PUSH
20594: LD_INT 1
20596: MINUS
20597: PUSH
20598: FOR_TO
20599: IFFALSE 20644
// begin tmp := tmp [ pos [ i ] ] ;
20601: LD_ADDR_VAR 0 6
20605: PUSH
20606: LD_VAR 0 6
20610: PUSH
20611: LD_VAR 0 2
20615: PUSH
20616: LD_VAR 0 5
20620: ARRAY
20621: ARRAY
20622: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20623: LD_ADDR_VAR 0 7
20627: PUSH
20628: LD_VAR 0 7
20632: PUSH
20633: LD_VAR 0 6
20637: PUSH
20638: EMPTY
20639: LIST
20640: ADD
20641: ST_TO_ADDR
// end ;
20642: GO 20598
20644: POP
20645: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20646: LD_ADDR_VAR 0 6
20650: PUSH
20651: LD_VAR 0 6
20655: PPUSH
20656: LD_VAR 0 2
20660: PUSH
20661: LD_VAR 0 2
20665: ARRAY
20666: PPUSH
20667: LD_VAR 0 3
20671: PPUSH
20672: CALL_OW 1
20676: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20677: LD_ADDR_VAR 0 7
20681: PUSH
20682: LD_VAR 0 7
20686: PPUSH
20687: LD_VAR 0 7
20691: PPUSH
20692: LD_VAR 0 6
20696: PPUSH
20697: CALL_OW 1
20701: ST_TO_ADDR
// for i = s_arr downto 2 do
20702: LD_ADDR_VAR 0 5
20706: PUSH
20707: DOUBLE
20708: LD_VAR 0 7
20712: INC
20713: ST_TO_ADDR
20714: LD_INT 2
20716: PUSH
20717: FOR_DOWNTO
20718: IFFALSE 20802
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20720: LD_ADDR_VAR 0 6
20724: PUSH
20725: LD_VAR 0 7
20729: PUSH
20730: LD_VAR 0 5
20734: PUSH
20735: LD_INT 1
20737: MINUS
20738: ARRAY
20739: PPUSH
20740: LD_VAR 0 2
20744: PUSH
20745: LD_VAR 0 5
20749: PUSH
20750: LD_INT 1
20752: MINUS
20753: ARRAY
20754: PPUSH
20755: LD_VAR 0 7
20759: PUSH
20760: LD_VAR 0 5
20764: ARRAY
20765: PPUSH
20766: CALL_OW 1
20770: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20771: LD_ADDR_VAR 0 7
20775: PUSH
20776: LD_VAR 0 7
20780: PPUSH
20781: LD_VAR 0 5
20785: PUSH
20786: LD_INT 1
20788: MINUS
20789: PPUSH
20790: LD_VAR 0 6
20794: PPUSH
20795: CALL_OW 1
20799: ST_TO_ADDR
// end ;
20800: GO 20717
20802: POP
20803: POP
// result := s_arr [ 1 ] ;
20804: LD_ADDR_VAR 0 4
20808: PUSH
20809: LD_VAR 0 7
20813: PUSH
20814: LD_INT 1
20816: ARRAY
20817: ST_TO_ADDR
// end ; end ;
20818: LD_VAR 0 4
20822: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20823: LD_INT 0
20825: PPUSH
20826: PPUSH
// if not list then
20827: LD_VAR 0 1
20831: NOT
20832: IFFALSE 20836
// exit ;
20834: GO 20927
// i := list [ pos1 ] ;
20836: LD_ADDR_VAR 0 5
20840: PUSH
20841: LD_VAR 0 1
20845: PUSH
20846: LD_VAR 0 2
20850: ARRAY
20851: ST_TO_ADDR
// if not i then
20852: LD_VAR 0 5
20856: NOT
20857: IFFALSE 20861
// exit ;
20859: GO 20927
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20861: LD_ADDR_VAR 0 1
20865: PUSH
20866: LD_VAR 0 1
20870: PPUSH
20871: LD_VAR 0 2
20875: PPUSH
20876: LD_VAR 0 1
20880: PUSH
20881: LD_VAR 0 3
20885: ARRAY
20886: PPUSH
20887: CALL_OW 1
20891: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20892: LD_ADDR_VAR 0 1
20896: PUSH
20897: LD_VAR 0 1
20901: PPUSH
20902: LD_VAR 0 3
20906: PPUSH
20907: LD_VAR 0 5
20911: PPUSH
20912: CALL_OW 1
20916: ST_TO_ADDR
// result := list ;
20917: LD_ADDR_VAR 0 4
20921: PUSH
20922: LD_VAR 0 1
20926: ST_TO_ADDR
// end ;
20927: LD_VAR 0 4
20931: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20932: LD_INT 0
20934: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20935: LD_ADDR_VAR 0 5
20939: PUSH
20940: LD_VAR 0 1
20944: PPUSH
20945: CALL_OW 250
20949: PPUSH
20950: LD_VAR 0 1
20954: PPUSH
20955: CALL_OW 251
20959: PPUSH
20960: LD_VAR 0 2
20964: PPUSH
20965: LD_VAR 0 3
20969: PPUSH
20970: LD_VAR 0 4
20974: PPUSH
20975: CALL 20985 0 5
20979: ST_TO_ADDR
// end ;
20980: LD_VAR 0 5
20984: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20985: LD_INT 0
20987: PPUSH
20988: PPUSH
20989: PPUSH
20990: PPUSH
// if not list then
20991: LD_VAR 0 3
20995: NOT
20996: IFFALSE 21000
// exit ;
20998: GO 21388
// result := [ ] ;
21000: LD_ADDR_VAR 0 6
21004: PUSH
21005: EMPTY
21006: ST_TO_ADDR
// for i in list do
21007: LD_ADDR_VAR 0 7
21011: PUSH
21012: LD_VAR 0 3
21016: PUSH
21017: FOR_IN
21018: IFFALSE 21220
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21020: LD_ADDR_VAR 0 9
21024: PUSH
21025: LD_VAR 0 7
21029: PPUSH
21030: LD_VAR 0 1
21034: PPUSH
21035: LD_VAR 0 2
21039: PPUSH
21040: CALL_OW 297
21044: ST_TO_ADDR
// if not result then
21045: LD_VAR 0 6
21049: NOT
21050: IFFALSE 21076
// result := [ [ i , tmp ] ] else
21052: LD_ADDR_VAR 0 6
21056: PUSH
21057: LD_VAR 0 7
21061: PUSH
21062: LD_VAR 0 9
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: PUSH
21071: EMPTY
21072: LIST
21073: ST_TO_ADDR
21074: GO 21218
// begin if result [ result ] [ 2 ] < tmp then
21076: LD_VAR 0 6
21080: PUSH
21081: LD_VAR 0 6
21085: ARRAY
21086: PUSH
21087: LD_INT 2
21089: ARRAY
21090: PUSH
21091: LD_VAR 0 9
21095: LESS
21096: IFFALSE 21138
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21098: LD_ADDR_VAR 0 6
21102: PUSH
21103: LD_VAR 0 6
21107: PPUSH
21108: LD_VAR 0 6
21112: PUSH
21113: LD_INT 1
21115: PLUS
21116: PPUSH
21117: LD_VAR 0 7
21121: PUSH
21122: LD_VAR 0 9
21126: PUSH
21127: EMPTY
21128: LIST
21129: LIST
21130: PPUSH
21131: CALL_OW 2
21135: ST_TO_ADDR
21136: GO 21218
// for j = 1 to result do
21138: LD_ADDR_VAR 0 8
21142: PUSH
21143: DOUBLE
21144: LD_INT 1
21146: DEC
21147: ST_TO_ADDR
21148: LD_VAR 0 6
21152: PUSH
21153: FOR_TO
21154: IFFALSE 21216
// begin if tmp < result [ j ] [ 2 ] then
21156: LD_VAR 0 9
21160: PUSH
21161: LD_VAR 0 6
21165: PUSH
21166: LD_VAR 0 8
21170: ARRAY
21171: PUSH
21172: LD_INT 2
21174: ARRAY
21175: LESS
21176: IFFALSE 21214
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21178: LD_ADDR_VAR 0 6
21182: PUSH
21183: LD_VAR 0 6
21187: PPUSH
21188: LD_VAR 0 8
21192: PPUSH
21193: LD_VAR 0 7
21197: PUSH
21198: LD_VAR 0 9
21202: PUSH
21203: EMPTY
21204: LIST
21205: LIST
21206: PPUSH
21207: CALL_OW 2
21211: ST_TO_ADDR
// break ;
21212: GO 21216
// end ; end ;
21214: GO 21153
21216: POP
21217: POP
// end ; end ;
21218: GO 21017
21220: POP
21221: POP
// if result and not asc then
21222: LD_VAR 0 6
21226: PUSH
21227: LD_VAR 0 4
21231: NOT
21232: AND
21233: IFFALSE 21308
// begin tmp := result ;
21235: LD_ADDR_VAR 0 9
21239: PUSH
21240: LD_VAR 0 6
21244: ST_TO_ADDR
// for i = tmp downto 1 do
21245: LD_ADDR_VAR 0 7
21249: PUSH
21250: DOUBLE
21251: LD_VAR 0 9
21255: INC
21256: ST_TO_ADDR
21257: LD_INT 1
21259: PUSH
21260: FOR_DOWNTO
21261: IFFALSE 21306
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21263: LD_ADDR_VAR 0 6
21267: PUSH
21268: LD_VAR 0 6
21272: PPUSH
21273: LD_VAR 0 9
21277: PUSH
21278: LD_VAR 0 7
21282: MINUS
21283: PUSH
21284: LD_INT 1
21286: PLUS
21287: PPUSH
21288: LD_VAR 0 9
21292: PUSH
21293: LD_VAR 0 7
21297: ARRAY
21298: PPUSH
21299: CALL_OW 1
21303: ST_TO_ADDR
21304: GO 21260
21306: POP
21307: POP
// end ; tmp := [ ] ;
21308: LD_ADDR_VAR 0 9
21312: PUSH
21313: EMPTY
21314: ST_TO_ADDR
// if mode then
21315: LD_VAR 0 5
21319: IFFALSE 21388
// begin for i = 1 to result do
21321: LD_ADDR_VAR 0 7
21325: PUSH
21326: DOUBLE
21327: LD_INT 1
21329: DEC
21330: ST_TO_ADDR
21331: LD_VAR 0 6
21335: PUSH
21336: FOR_TO
21337: IFFALSE 21376
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21339: LD_ADDR_VAR 0 9
21343: PUSH
21344: LD_VAR 0 9
21348: PPUSH
21349: LD_VAR 0 7
21353: PPUSH
21354: LD_VAR 0 6
21358: PUSH
21359: LD_VAR 0 7
21363: ARRAY
21364: PUSH
21365: LD_INT 1
21367: ARRAY
21368: PPUSH
21369: CALL_OW 1
21373: ST_TO_ADDR
21374: GO 21336
21376: POP
21377: POP
// result := tmp ;
21378: LD_ADDR_VAR 0 6
21382: PUSH
21383: LD_VAR 0 9
21387: ST_TO_ADDR
// end ; end ;
21388: LD_VAR 0 6
21392: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21393: LD_INT 0
21395: PPUSH
21396: PPUSH
21397: PPUSH
21398: PPUSH
21399: PPUSH
21400: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21401: LD_ADDR_VAR 0 5
21405: PUSH
21406: LD_INT 0
21408: PUSH
21409: LD_INT 0
21411: PUSH
21412: LD_INT 0
21414: PUSH
21415: EMPTY
21416: PUSH
21417: EMPTY
21418: LIST
21419: LIST
21420: LIST
21421: LIST
21422: ST_TO_ADDR
// if not x or not y then
21423: LD_VAR 0 2
21427: NOT
21428: PUSH
21429: LD_VAR 0 3
21433: NOT
21434: OR
21435: IFFALSE 21439
// exit ;
21437: GO 23085
// if not range then
21439: LD_VAR 0 4
21443: NOT
21444: IFFALSE 21454
// range := 10 ;
21446: LD_ADDR_VAR 0 4
21450: PUSH
21451: LD_INT 10
21453: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21454: LD_ADDR_VAR 0 8
21458: PUSH
21459: LD_INT 81
21461: PUSH
21462: LD_VAR 0 1
21466: PUSH
21467: EMPTY
21468: LIST
21469: LIST
21470: PUSH
21471: LD_INT 92
21473: PUSH
21474: LD_VAR 0 2
21478: PUSH
21479: LD_VAR 0 3
21483: PUSH
21484: LD_VAR 0 4
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: LIST
21493: LIST
21494: PUSH
21495: LD_INT 3
21497: PUSH
21498: LD_INT 21
21500: PUSH
21501: LD_INT 3
21503: PUSH
21504: EMPTY
21505: LIST
21506: LIST
21507: PUSH
21508: EMPTY
21509: LIST
21510: LIST
21511: PUSH
21512: EMPTY
21513: LIST
21514: LIST
21515: LIST
21516: PPUSH
21517: CALL_OW 69
21521: ST_TO_ADDR
// if not tmp then
21522: LD_VAR 0 8
21526: NOT
21527: IFFALSE 21531
// exit ;
21529: GO 23085
// for i in tmp do
21531: LD_ADDR_VAR 0 6
21535: PUSH
21536: LD_VAR 0 8
21540: PUSH
21541: FOR_IN
21542: IFFALSE 23060
// begin points := [ 0 , 0 , 0 ] ;
21544: LD_ADDR_VAR 0 9
21548: PUSH
21549: LD_INT 0
21551: PUSH
21552: LD_INT 0
21554: PUSH
21555: LD_INT 0
21557: PUSH
21558: EMPTY
21559: LIST
21560: LIST
21561: LIST
21562: ST_TO_ADDR
// bpoints := 1 ;
21563: LD_ADDR_VAR 0 10
21567: PUSH
21568: LD_INT 1
21570: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21571: LD_VAR 0 6
21575: PPUSH
21576: CALL_OW 247
21580: PUSH
21581: LD_INT 1
21583: DOUBLE
21584: EQUAL
21585: IFTRUE 21589
21587: GO 22167
21589: POP
// begin if GetClass ( i ) = 1 then
21590: LD_VAR 0 6
21594: PPUSH
21595: CALL_OW 257
21599: PUSH
21600: LD_INT 1
21602: EQUAL
21603: IFFALSE 21624
// points := [ 10 , 5 , 3 ] ;
21605: LD_ADDR_VAR 0 9
21609: PUSH
21610: LD_INT 10
21612: PUSH
21613: LD_INT 5
21615: PUSH
21616: LD_INT 3
21618: PUSH
21619: EMPTY
21620: LIST
21621: LIST
21622: LIST
21623: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21624: LD_VAR 0 6
21628: PPUSH
21629: CALL_OW 257
21633: PUSH
21634: LD_INT 2
21636: PUSH
21637: LD_INT 3
21639: PUSH
21640: LD_INT 4
21642: PUSH
21643: EMPTY
21644: LIST
21645: LIST
21646: LIST
21647: IN
21648: IFFALSE 21669
// points := [ 3 , 2 , 1 ] ;
21650: LD_ADDR_VAR 0 9
21654: PUSH
21655: LD_INT 3
21657: PUSH
21658: LD_INT 2
21660: PUSH
21661: LD_INT 1
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: LIST
21668: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21669: LD_VAR 0 6
21673: PPUSH
21674: CALL_OW 257
21678: PUSH
21679: LD_INT 5
21681: EQUAL
21682: IFFALSE 21703
// points := [ 130 , 5 , 2 ] ;
21684: LD_ADDR_VAR 0 9
21688: PUSH
21689: LD_INT 130
21691: PUSH
21692: LD_INT 5
21694: PUSH
21695: LD_INT 2
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: LIST
21702: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21703: LD_VAR 0 6
21707: PPUSH
21708: CALL_OW 257
21712: PUSH
21713: LD_INT 8
21715: EQUAL
21716: IFFALSE 21737
// points := [ 35 , 35 , 30 ] ;
21718: LD_ADDR_VAR 0 9
21722: PUSH
21723: LD_INT 35
21725: PUSH
21726: LD_INT 35
21728: PUSH
21729: LD_INT 30
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: LIST
21736: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21737: LD_VAR 0 6
21741: PPUSH
21742: CALL_OW 257
21746: PUSH
21747: LD_INT 9
21749: EQUAL
21750: IFFALSE 21771
// points := [ 20 , 55 , 40 ] ;
21752: LD_ADDR_VAR 0 9
21756: PUSH
21757: LD_INT 20
21759: PUSH
21760: LD_INT 55
21762: PUSH
21763: LD_INT 40
21765: PUSH
21766: EMPTY
21767: LIST
21768: LIST
21769: LIST
21770: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21771: LD_VAR 0 6
21775: PPUSH
21776: CALL_OW 257
21780: PUSH
21781: LD_INT 12
21783: PUSH
21784: LD_INT 16
21786: PUSH
21787: EMPTY
21788: LIST
21789: LIST
21790: IN
21791: IFFALSE 21812
// points := [ 5 , 3 , 2 ] ;
21793: LD_ADDR_VAR 0 9
21797: PUSH
21798: LD_INT 5
21800: PUSH
21801: LD_INT 3
21803: PUSH
21804: LD_INT 2
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21812: LD_VAR 0 6
21816: PPUSH
21817: CALL_OW 257
21821: PUSH
21822: LD_INT 17
21824: EQUAL
21825: IFFALSE 21846
// points := [ 100 , 50 , 75 ] ;
21827: LD_ADDR_VAR 0 9
21831: PUSH
21832: LD_INT 100
21834: PUSH
21835: LD_INT 50
21837: PUSH
21838: LD_INT 75
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: LIST
21845: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21846: LD_VAR 0 6
21850: PPUSH
21851: CALL_OW 257
21855: PUSH
21856: LD_INT 15
21858: EQUAL
21859: IFFALSE 21880
// points := [ 10 , 5 , 3 ] ;
21861: LD_ADDR_VAR 0 9
21865: PUSH
21866: LD_INT 10
21868: PUSH
21869: LD_INT 5
21871: PUSH
21872: LD_INT 3
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: LIST
21879: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21880: LD_VAR 0 6
21884: PPUSH
21885: CALL_OW 257
21889: PUSH
21890: LD_INT 14
21892: EQUAL
21893: IFFALSE 21914
// points := [ 10 , 0 , 0 ] ;
21895: LD_ADDR_VAR 0 9
21899: PUSH
21900: LD_INT 10
21902: PUSH
21903: LD_INT 0
21905: PUSH
21906: LD_INT 0
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: LIST
21913: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21914: LD_VAR 0 6
21918: PPUSH
21919: CALL_OW 257
21923: PUSH
21924: LD_INT 11
21926: EQUAL
21927: IFFALSE 21948
// points := [ 30 , 10 , 5 ] ;
21929: LD_ADDR_VAR 0 9
21933: PUSH
21934: LD_INT 30
21936: PUSH
21937: LD_INT 10
21939: PUSH
21940: LD_INT 5
21942: PUSH
21943: EMPTY
21944: LIST
21945: LIST
21946: LIST
21947: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21948: LD_VAR 0 1
21952: PPUSH
21953: LD_INT 5
21955: PPUSH
21956: CALL_OW 321
21960: PUSH
21961: LD_INT 2
21963: EQUAL
21964: IFFALSE 21981
// bpoints := bpoints * 1.8 ;
21966: LD_ADDR_VAR 0 10
21970: PUSH
21971: LD_VAR 0 10
21975: PUSH
21976: LD_REAL  1.80000000000000E+0000
21979: MUL
21980: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21981: LD_VAR 0 6
21985: PPUSH
21986: CALL_OW 257
21990: PUSH
21991: LD_INT 1
21993: PUSH
21994: LD_INT 2
21996: PUSH
21997: LD_INT 3
21999: PUSH
22000: LD_INT 4
22002: PUSH
22003: EMPTY
22004: LIST
22005: LIST
22006: LIST
22007: LIST
22008: IN
22009: PUSH
22010: LD_VAR 0 1
22014: PPUSH
22015: LD_INT 51
22017: PPUSH
22018: CALL_OW 321
22022: PUSH
22023: LD_INT 2
22025: EQUAL
22026: AND
22027: IFFALSE 22044
// bpoints := bpoints * 1.2 ;
22029: LD_ADDR_VAR 0 10
22033: PUSH
22034: LD_VAR 0 10
22038: PUSH
22039: LD_REAL  1.20000000000000E+0000
22042: MUL
22043: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22044: LD_VAR 0 6
22048: PPUSH
22049: CALL_OW 257
22053: PUSH
22054: LD_INT 5
22056: PUSH
22057: LD_INT 7
22059: PUSH
22060: LD_INT 9
22062: PUSH
22063: EMPTY
22064: LIST
22065: LIST
22066: LIST
22067: IN
22068: PUSH
22069: LD_VAR 0 1
22073: PPUSH
22074: LD_INT 52
22076: PPUSH
22077: CALL_OW 321
22081: PUSH
22082: LD_INT 2
22084: EQUAL
22085: AND
22086: IFFALSE 22103
// bpoints := bpoints * 1.5 ;
22088: LD_ADDR_VAR 0 10
22092: PUSH
22093: LD_VAR 0 10
22097: PUSH
22098: LD_REAL  1.50000000000000E+0000
22101: MUL
22102: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22103: LD_VAR 0 1
22107: PPUSH
22108: LD_INT 66
22110: PPUSH
22111: CALL_OW 321
22115: PUSH
22116: LD_INT 2
22118: EQUAL
22119: IFFALSE 22136
// bpoints := bpoints * 1.1 ;
22121: LD_ADDR_VAR 0 10
22125: PUSH
22126: LD_VAR 0 10
22130: PUSH
22131: LD_REAL  1.10000000000000E+0000
22134: MUL
22135: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22136: LD_ADDR_VAR 0 10
22140: PUSH
22141: LD_VAR 0 10
22145: PUSH
22146: LD_VAR 0 6
22150: PPUSH
22151: LD_INT 1
22153: PPUSH
22154: CALL_OW 259
22158: PUSH
22159: LD_REAL  1.15000000000000E+0000
22162: MUL
22163: MUL
22164: ST_TO_ADDR
// end ; unit_vehicle :
22165: GO 22989
22167: LD_INT 2
22169: DOUBLE
22170: EQUAL
22171: IFTRUE 22175
22173: GO 22977
22175: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22176: LD_VAR 0 6
22180: PPUSH
22181: CALL_OW 264
22185: PUSH
22186: LD_INT 2
22188: PUSH
22189: LD_INT 42
22191: PUSH
22192: LD_INT 24
22194: PUSH
22195: EMPTY
22196: LIST
22197: LIST
22198: LIST
22199: IN
22200: IFFALSE 22221
// points := [ 25 , 5 , 3 ] ;
22202: LD_ADDR_VAR 0 9
22206: PUSH
22207: LD_INT 25
22209: PUSH
22210: LD_INT 5
22212: PUSH
22213: LD_INT 3
22215: PUSH
22216: EMPTY
22217: LIST
22218: LIST
22219: LIST
22220: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22221: LD_VAR 0 6
22225: PPUSH
22226: CALL_OW 264
22230: PUSH
22231: LD_INT 4
22233: PUSH
22234: LD_INT 43
22236: PUSH
22237: LD_INT 25
22239: PUSH
22240: EMPTY
22241: LIST
22242: LIST
22243: LIST
22244: IN
22245: IFFALSE 22266
// points := [ 40 , 15 , 5 ] ;
22247: LD_ADDR_VAR 0 9
22251: PUSH
22252: LD_INT 40
22254: PUSH
22255: LD_INT 15
22257: PUSH
22258: LD_INT 5
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: LIST
22265: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22266: LD_VAR 0 6
22270: PPUSH
22271: CALL_OW 264
22275: PUSH
22276: LD_INT 3
22278: PUSH
22279: LD_INT 23
22281: PUSH
22282: EMPTY
22283: LIST
22284: LIST
22285: IN
22286: IFFALSE 22307
// points := [ 7 , 25 , 8 ] ;
22288: LD_ADDR_VAR 0 9
22292: PUSH
22293: LD_INT 7
22295: PUSH
22296: LD_INT 25
22298: PUSH
22299: LD_INT 8
22301: PUSH
22302: EMPTY
22303: LIST
22304: LIST
22305: LIST
22306: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22307: LD_VAR 0 6
22311: PPUSH
22312: CALL_OW 264
22316: PUSH
22317: LD_INT 5
22319: PUSH
22320: LD_INT 27
22322: PUSH
22323: LD_INT 44
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: LIST
22330: IN
22331: IFFALSE 22352
// points := [ 14 , 50 , 16 ] ;
22333: LD_ADDR_VAR 0 9
22337: PUSH
22338: LD_INT 14
22340: PUSH
22341: LD_INT 50
22343: PUSH
22344: LD_INT 16
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22352: LD_VAR 0 6
22356: PPUSH
22357: CALL_OW 264
22361: PUSH
22362: LD_INT 6
22364: PUSH
22365: LD_INT 46
22367: PUSH
22368: EMPTY
22369: LIST
22370: LIST
22371: IN
22372: IFFALSE 22393
// points := [ 32 , 120 , 70 ] ;
22374: LD_ADDR_VAR 0 9
22378: PUSH
22379: LD_INT 32
22381: PUSH
22382: LD_INT 120
22384: PUSH
22385: LD_INT 70
22387: PUSH
22388: EMPTY
22389: LIST
22390: LIST
22391: LIST
22392: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22393: LD_VAR 0 6
22397: PPUSH
22398: CALL_OW 264
22402: PUSH
22403: LD_INT 7
22405: PUSH
22406: LD_INT 28
22408: PUSH
22409: LD_INT 45
22411: PUSH
22412: EMPTY
22413: LIST
22414: LIST
22415: LIST
22416: IN
22417: IFFALSE 22438
// points := [ 35 , 20 , 45 ] ;
22419: LD_ADDR_VAR 0 9
22423: PUSH
22424: LD_INT 35
22426: PUSH
22427: LD_INT 20
22429: PUSH
22430: LD_INT 45
22432: PUSH
22433: EMPTY
22434: LIST
22435: LIST
22436: LIST
22437: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22438: LD_VAR 0 6
22442: PPUSH
22443: CALL_OW 264
22447: PUSH
22448: LD_INT 47
22450: PUSH
22451: EMPTY
22452: LIST
22453: IN
22454: IFFALSE 22475
// points := [ 67 , 45 , 75 ] ;
22456: LD_ADDR_VAR 0 9
22460: PUSH
22461: LD_INT 67
22463: PUSH
22464: LD_INT 45
22466: PUSH
22467: LD_INT 75
22469: PUSH
22470: EMPTY
22471: LIST
22472: LIST
22473: LIST
22474: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22475: LD_VAR 0 6
22479: PPUSH
22480: CALL_OW 264
22484: PUSH
22485: LD_INT 26
22487: PUSH
22488: EMPTY
22489: LIST
22490: IN
22491: IFFALSE 22512
// points := [ 120 , 30 , 80 ] ;
22493: LD_ADDR_VAR 0 9
22497: PUSH
22498: LD_INT 120
22500: PUSH
22501: LD_INT 30
22503: PUSH
22504: LD_INT 80
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: LIST
22511: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22512: LD_VAR 0 6
22516: PPUSH
22517: CALL_OW 264
22521: PUSH
22522: LD_INT 22
22524: PUSH
22525: EMPTY
22526: LIST
22527: IN
22528: IFFALSE 22549
// points := [ 40 , 1 , 1 ] ;
22530: LD_ADDR_VAR 0 9
22534: PUSH
22535: LD_INT 40
22537: PUSH
22538: LD_INT 1
22540: PUSH
22541: LD_INT 1
22543: PUSH
22544: EMPTY
22545: LIST
22546: LIST
22547: LIST
22548: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22549: LD_VAR 0 6
22553: PPUSH
22554: CALL_OW 264
22558: PUSH
22559: LD_INT 29
22561: PUSH
22562: EMPTY
22563: LIST
22564: IN
22565: IFFALSE 22586
// points := [ 70 , 200 , 400 ] ;
22567: LD_ADDR_VAR 0 9
22571: PUSH
22572: LD_INT 70
22574: PUSH
22575: LD_INT 200
22577: PUSH
22578: LD_INT 400
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: LIST
22585: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22586: LD_VAR 0 6
22590: PPUSH
22591: CALL_OW 264
22595: PUSH
22596: LD_INT 14
22598: PUSH
22599: LD_INT 53
22601: PUSH
22602: EMPTY
22603: LIST
22604: LIST
22605: IN
22606: IFFALSE 22627
// points := [ 40 , 10 , 20 ] ;
22608: LD_ADDR_VAR 0 9
22612: PUSH
22613: LD_INT 40
22615: PUSH
22616: LD_INT 10
22618: PUSH
22619: LD_INT 20
22621: PUSH
22622: EMPTY
22623: LIST
22624: LIST
22625: LIST
22626: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22627: LD_VAR 0 6
22631: PPUSH
22632: CALL_OW 264
22636: PUSH
22637: LD_INT 9
22639: PUSH
22640: EMPTY
22641: LIST
22642: IN
22643: IFFALSE 22664
// points := [ 5 , 70 , 20 ] ;
22645: LD_ADDR_VAR 0 9
22649: PUSH
22650: LD_INT 5
22652: PUSH
22653: LD_INT 70
22655: PUSH
22656: LD_INT 20
22658: PUSH
22659: EMPTY
22660: LIST
22661: LIST
22662: LIST
22663: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22664: LD_VAR 0 6
22668: PPUSH
22669: CALL_OW 264
22673: PUSH
22674: LD_INT 10
22676: PUSH
22677: EMPTY
22678: LIST
22679: IN
22680: IFFALSE 22701
// points := [ 35 , 110 , 70 ] ;
22682: LD_ADDR_VAR 0 9
22686: PUSH
22687: LD_INT 35
22689: PUSH
22690: LD_INT 110
22692: PUSH
22693: LD_INT 70
22695: PUSH
22696: EMPTY
22697: LIST
22698: LIST
22699: LIST
22700: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22701: LD_VAR 0 6
22705: PPUSH
22706: CALL_OW 265
22710: PUSH
22711: LD_INT 25
22713: EQUAL
22714: IFFALSE 22735
// points := [ 80 , 65 , 100 ] ;
22716: LD_ADDR_VAR 0 9
22720: PUSH
22721: LD_INT 80
22723: PUSH
22724: LD_INT 65
22726: PUSH
22727: LD_INT 100
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22735: LD_VAR 0 6
22739: PPUSH
22740: CALL_OW 263
22744: PUSH
22745: LD_INT 1
22747: EQUAL
22748: IFFALSE 22783
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22750: LD_ADDR_VAR 0 10
22754: PUSH
22755: LD_VAR 0 10
22759: PUSH
22760: LD_VAR 0 6
22764: PPUSH
22765: CALL_OW 311
22769: PPUSH
22770: LD_INT 3
22772: PPUSH
22773: CALL_OW 259
22777: PUSH
22778: LD_INT 4
22780: MUL
22781: MUL
22782: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22783: LD_VAR 0 6
22787: PPUSH
22788: CALL_OW 263
22792: PUSH
22793: LD_INT 2
22795: EQUAL
22796: IFFALSE 22847
// begin j := IsControledBy ( i ) ;
22798: LD_ADDR_VAR 0 7
22802: PUSH
22803: LD_VAR 0 6
22807: PPUSH
22808: CALL_OW 312
22812: ST_TO_ADDR
// if j then
22813: LD_VAR 0 7
22817: IFFALSE 22847
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22819: LD_ADDR_VAR 0 10
22823: PUSH
22824: LD_VAR 0 10
22828: PUSH
22829: LD_VAR 0 7
22833: PPUSH
22834: LD_INT 3
22836: PPUSH
22837: CALL_OW 259
22841: PUSH
22842: LD_INT 3
22844: MUL
22845: MUL
22846: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22847: LD_VAR 0 6
22851: PPUSH
22852: CALL_OW 264
22856: PUSH
22857: LD_INT 5
22859: PUSH
22860: LD_INT 6
22862: PUSH
22863: LD_INT 46
22865: PUSH
22866: LD_INT 44
22868: PUSH
22869: LD_INT 47
22871: PUSH
22872: LD_INT 45
22874: PUSH
22875: LD_INT 28
22877: PUSH
22878: LD_INT 7
22880: PUSH
22881: LD_INT 27
22883: PUSH
22884: LD_INT 29
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: LIST
22892: LIST
22893: LIST
22894: LIST
22895: LIST
22896: LIST
22897: LIST
22898: IN
22899: PUSH
22900: LD_VAR 0 1
22904: PPUSH
22905: LD_INT 52
22907: PPUSH
22908: CALL_OW 321
22912: PUSH
22913: LD_INT 2
22915: EQUAL
22916: AND
22917: IFFALSE 22934
// bpoints := bpoints * 1.2 ;
22919: LD_ADDR_VAR 0 10
22923: PUSH
22924: LD_VAR 0 10
22928: PUSH
22929: LD_REAL  1.20000000000000E+0000
22932: MUL
22933: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22934: LD_VAR 0 6
22938: PPUSH
22939: CALL_OW 264
22943: PUSH
22944: LD_INT 6
22946: PUSH
22947: LD_INT 46
22949: PUSH
22950: LD_INT 47
22952: PUSH
22953: EMPTY
22954: LIST
22955: LIST
22956: LIST
22957: IN
22958: IFFALSE 22975
// bpoints := bpoints * 1.2 ;
22960: LD_ADDR_VAR 0 10
22964: PUSH
22965: LD_VAR 0 10
22969: PUSH
22970: LD_REAL  1.20000000000000E+0000
22973: MUL
22974: ST_TO_ADDR
// end ; unit_building :
22975: GO 22989
22977: LD_INT 3
22979: DOUBLE
22980: EQUAL
22981: IFTRUE 22985
22983: GO 22988
22985: POP
// ; end ;
22986: GO 22989
22988: POP
// for j = 1 to 3 do
22989: LD_ADDR_VAR 0 7
22993: PUSH
22994: DOUBLE
22995: LD_INT 1
22997: DEC
22998: ST_TO_ADDR
22999: LD_INT 3
23001: PUSH
23002: FOR_TO
23003: IFFALSE 23056
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23005: LD_ADDR_VAR 0 5
23009: PUSH
23010: LD_VAR 0 5
23014: PPUSH
23015: LD_VAR 0 7
23019: PPUSH
23020: LD_VAR 0 5
23024: PUSH
23025: LD_VAR 0 7
23029: ARRAY
23030: PUSH
23031: LD_VAR 0 9
23035: PUSH
23036: LD_VAR 0 7
23040: ARRAY
23041: PUSH
23042: LD_VAR 0 10
23046: MUL
23047: PLUS
23048: PPUSH
23049: CALL_OW 1
23053: ST_TO_ADDR
23054: GO 23002
23056: POP
23057: POP
// end ;
23058: GO 21541
23060: POP
23061: POP
// result := Replace ( result , 4 , tmp ) ;
23062: LD_ADDR_VAR 0 5
23066: PUSH
23067: LD_VAR 0 5
23071: PPUSH
23072: LD_INT 4
23074: PPUSH
23075: LD_VAR 0 8
23079: PPUSH
23080: CALL_OW 1
23084: ST_TO_ADDR
// end ;
23085: LD_VAR 0 5
23089: RET
// export function DangerAtRange ( unit , range ) ; begin
23090: LD_INT 0
23092: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23093: LD_ADDR_VAR 0 3
23097: PUSH
23098: LD_VAR 0 1
23102: PPUSH
23103: CALL_OW 255
23107: PPUSH
23108: LD_VAR 0 1
23112: PPUSH
23113: CALL_OW 250
23117: PPUSH
23118: LD_VAR 0 1
23122: PPUSH
23123: CALL_OW 251
23127: PPUSH
23128: LD_VAR 0 2
23132: PPUSH
23133: CALL 21393 0 4
23137: ST_TO_ADDR
// end ;
23138: LD_VAR 0 3
23142: RET
// export function DangerInArea ( side , area ) ; begin
23143: LD_INT 0
23145: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23146: LD_ADDR_VAR 0 3
23150: PUSH
23151: LD_VAR 0 2
23155: PPUSH
23156: LD_INT 81
23158: PUSH
23159: LD_VAR 0 1
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: PPUSH
23168: CALL_OW 70
23172: ST_TO_ADDR
// end ;
23173: LD_VAR 0 3
23177: RET
// export function IsExtension ( b ) ; begin
23178: LD_INT 0
23180: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23181: LD_ADDR_VAR 0 2
23185: PUSH
23186: LD_VAR 0 1
23190: PUSH
23191: LD_INT 23
23193: PUSH
23194: LD_INT 20
23196: PUSH
23197: LD_INT 22
23199: PUSH
23200: LD_INT 17
23202: PUSH
23203: LD_INT 24
23205: PUSH
23206: LD_INT 21
23208: PUSH
23209: LD_INT 19
23211: PUSH
23212: LD_INT 16
23214: PUSH
23215: LD_INT 25
23217: PUSH
23218: LD_INT 18
23220: PUSH
23221: EMPTY
23222: LIST
23223: LIST
23224: LIST
23225: LIST
23226: LIST
23227: LIST
23228: LIST
23229: LIST
23230: LIST
23231: LIST
23232: IN
23233: ST_TO_ADDR
// end ;
23234: LD_VAR 0 2
23238: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23239: LD_INT 0
23241: PPUSH
23242: PPUSH
23243: PPUSH
// result := [ ] ;
23244: LD_ADDR_VAR 0 3
23248: PUSH
23249: EMPTY
23250: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23251: LD_ADDR_VAR 0 4
23255: PUSH
23256: LD_VAR 0 2
23260: PPUSH
23261: LD_INT 21
23263: PUSH
23264: LD_INT 3
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: PPUSH
23271: CALL_OW 70
23275: ST_TO_ADDR
// if not tmp then
23276: LD_VAR 0 4
23280: NOT
23281: IFFALSE 23285
// exit ;
23283: GO 23343
// for i in tmp do
23285: LD_ADDR_VAR 0 5
23289: PUSH
23290: LD_VAR 0 4
23294: PUSH
23295: FOR_IN
23296: IFFALSE 23331
// if GetBase ( i ) <> base then
23298: LD_VAR 0 5
23302: PPUSH
23303: CALL_OW 274
23307: PUSH
23308: LD_VAR 0 1
23312: NONEQUAL
23313: IFFALSE 23329
// ComLinkToBase ( base , i ) ;
23315: LD_VAR 0 1
23319: PPUSH
23320: LD_VAR 0 5
23324: PPUSH
23325: CALL_OW 169
23329: GO 23295
23331: POP
23332: POP
// result := tmp ;
23333: LD_ADDR_VAR 0 3
23337: PUSH
23338: LD_VAR 0 4
23342: ST_TO_ADDR
// end ;
23343: LD_VAR 0 3
23347: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23348: LD_INT 0
23350: PPUSH
23351: PPUSH
// if BuildingStatus ( b ) = bs_build then
23352: LD_VAR 0 2
23356: PPUSH
23357: CALL_OW 461
23361: PUSH
23362: LD_INT 1
23364: EQUAL
23365: IFFALSE 23425
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23367: LD_VAR 0 1
23371: PPUSH
23372: LD_STRING h
23374: PUSH
23375: LD_VAR 0 2
23379: PPUSH
23380: CALL_OW 250
23384: PUSH
23385: LD_VAR 0 2
23389: PPUSH
23390: CALL_OW 251
23394: PUSH
23395: LD_VAR 0 2
23399: PUSH
23400: LD_INT 0
23402: PUSH
23403: LD_INT 0
23405: PUSH
23406: LD_INT 0
23408: PUSH
23409: EMPTY
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: PUSH
23418: EMPTY
23419: LIST
23420: PPUSH
23421: CALL_OW 446
// end ;
23425: LD_VAR 0 3
23429: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23430: LD_INT 0
23432: PPUSH
23433: PPUSH
23434: PPUSH
23435: PPUSH
23436: PPUSH
23437: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23438: LD_VAR 0 1
23442: NOT
23443: PUSH
23444: LD_VAR 0 1
23448: PPUSH
23449: CALL_OW 263
23453: PUSH
23454: LD_INT 2
23456: EQUAL
23457: NOT
23458: OR
23459: IFFALSE 23463
// exit ;
23461: GO 23779
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23463: LD_ADDR_VAR 0 6
23467: PUSH
23468: LD_INT 22
23470: PUSH
23471: LD_VAR 0 1
23475: PPUSH
23476: CALL_OW 255
23480: PUSH
23481: EMPTY
23482: LIST
23483: LIST
23484: PUSH
23485: LD_INT 2
23487: PUSH
23488: LD_INT 30
23490: PUSH
23491: LD_INT 36
23493: PUSH
23494: EMPTY
23495: LIST
23496: LIST
23497: PUSH
23498: LD_INT 34
23500: PUSH
23501: LD_INT 31
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: LIST
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PPUSH
23517: CALL_OW 69
23521: ST_TO_ADDR
// if not tmp then
23522: LD_VAR 0 6
23526: NOT
23527: IFFALSE 23531
// exit ;
23529: GO 23779
// result := [ ] ;
23531: LD_ADDR_VAR 0 2
23535: PUSH
23536: EMPTY
23537: ST_TO_ADDR
// for i in tmp do
23538: LD_ADDR_VAR 0 3
23542: PUSH
23543: LD_VAR 0 6
23547: PUSH
23548: FOR_IN
23549: IFFALSE 23620
// begin t := UnitsInside ( i ) ;
23551: LD_ADDR_VAR 0 4
23555: PUSH
23556: LD_VAR 0 3
23560: PPUSH
23561: CALL_OW 313
23565: ST_TO_ADDR
// if t then
23566: LD_VAR 0 4
23570: IFFALSE 23618
// for j in t do
23572: LD_ADDR_VAR 0 7
23576: PUSH
23577: LD_VAR 0 4
23581: PUSH
23582: FOR_IN
23583: IFFALSE 23616
// result := Insert ( result , result + 1 , j ) ;
23585: LD_ADDR_VAR 0 2
23589: PUSH
23590: LD_VAR 0 2
23594: PPUSH
23595: LD_VAR 0 2
23599: PUSH
23600: LD_INT 1
23602: PLUS
23603: PPUSH
23604: LD_VAR 0 7
23608: PPUSH
23609: CALL_OW 2
23613: ST_TO_ADDR
23614: GO 23582
23616: POP
23617: POP
// end ;
23618: GO 23548
23620: POP
23621: POP
// if not result then
23622: LD_VAR 0 2
23626: NOT
23627: IFFALSE 23631
// exit ;
23629: GO 23779
// mech := result [ 1 ] ;
23631: LD_ADDR_VAR 0 5
23635: PUSH
23636: LD_VAR 0 2
23640: PUSH
23641: LD_INT 1
23643: ARRAY
23644: ST_TO_ADDR
// if result > 1 then
23645: LD_VAR 0 2
23649: PUSH
23650: LD_INT 1
23652: GREATER
23653: IFFALSE 23765
// for i = 2 to result do
23655: LD_ADDR_VAR 0 3
23659: PUSH
23660: DOUBLE
23661: LD_INT 2
23663: DEC
23664: ST_TO_ADDR
23665: LD_VAR 0 2
23669: PUSH
23670: FOR_TO
23671: IFFALSE 23763
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23673: LD_ADDR_VAR 0 4
23677: PUSH
23678: LD_VAR 0 2
23682: PUSH
23683: LD_VAR 0 3
23687: ARRAY
23688: PPUSH
23689: LD_INT 3
23691: PPUSH
23692: CALL_OW 259
23696: PUSH
23697: LD_VAR 0 2
23701: PUSH
23702: LD_VAR 0 3
23706: ARRAY
23707: PPUSH
23708: CALL_OW 432
23712: MINUS
23713: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23714: LD_VAR 0 4
23718: PUSH
23719: LD_VAR 0 5
23723: PPUSH
23724: LD_INT 3
23726: PPUSH
23727: CALL_OW 259
23731: PUSH
23732: LD_VAR 0 5
23736: PPUSH
23737: CALL_OW 432
23741: MINUS
23742: GREATEREQUAL
23743: IFFALSE 23761
// mech := result [ i ] ;
23745: LD_ADDR_VAR 0 5
23749: PUSH
23750: LD_VAR 0 2
23754: PUSH
23755: LD_VAR 0 3
23759: ARRAY
23760: ST_TO_ADDR
// end ;
23761: GO 23670
23763: POP
23764: POP
// ComLinkTo ( vehicle , mech ) ;
23765: LD_VAR 0 1
23769: PPUSH
23770: LD_VAR 0 5
23774: PPUSH
23775: CALL_OW 135
// end ;
23779: LD_VAR 0 2
23783: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23784: LD_INT 0
23786: PPUSH
23787: PPUSH
23788: PPUSH
23789: PPUSH
23790: PPUSH
23791: PPUSH
23792: PPUSH
23793: PPUSH
23794: PPUSH
23795: PPUSH
23796: PPUSH
23797: PPUSH
23798: PPUSH
// result := [ ] ;
23799: LD_ADDR_VAR 0 7
23803: PUSH
23804: EMPTY
23805: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23806: LD_VAR 0 1
23810: PPUSH
23811: CALL_OW 266
23815: PUSH
23816: LD_INT 0
23818: PUSH
23819: LD_INT 1
23821: PUSH
23822: EMPTY
23823: LIST
23824: LIST
23825: IN
23826: NOT
23827: IFFALSE 23831
// exit ;
23829: GO 25462
// if name then
23831: LD_VAR 0 3
23835: IFFALSE 23851
// SetBName ( base_dep , name ) ;
23837: LD_VAR 0 1
23841: PPUSH
23842: LD_VAR 0 3
23846: PPUSH
23847: CALL_OW 500
// base := GetBase ( base_dep ) ;
23851: LD_ADDR_VAR 0 15
23855: PUSH
23856: LD_VAR 0 1
23860: PPUSH
23861: CALL_OW 274
23865: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23866: LD_ADDR_VAR 0 16
23870: PUSH
23871: LD_VAR 0 1
23875: PPUSH
23876: CALL_OW 255
23880: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23881: LD_ADDR_VAR 0 17
23885: PUSH
23886: LD_VAR 0 1
23890: PPUSH
23891: CALL_OW 248
23895: ST_TO_ADDR
// if sources then
23896: LD_VAR 0 5
23900: IFFALSE 23947
// for i = 1 to 3 do
23902: LD_ADDR_VAR 0 8
23906: PUSH
23907: DOUBLE
23908: LD_INT 1
23910: DEC
23911: ST_TO_ADDR
23912: LD_INT 3
23914: PUSH
23915: FOR_TO
23916: IFFALSE 23945
// AddResourceType ( base , i , sources [ i ] ) ;
23918: LD_VAR 0 15
23922: PPUSH
23923: LD_VAR 0 8
23927: PPUSH
23928: LD_VAR 0 5
23932: PUSH
23933: LD_VAR 0 8
23937: ARRAY
23938: PPUSH
23939: CALL_OW 276
23943: GO 23915
23945: POP
23946: POP
// buildings := GetBaseBuildings ( base , area ) ;
23947: LD_ADDR_VAR 0 18
23951: PUSH
23952: LD_VAR 0 15
23956: PPUSH
23957: LD_VAR 0 2
23961: PPUSH
23962: CALL 23239 0 2
23966: ST_TO_ADDR
// InitHc ;
23967: CALL_OW 19
// InitUc ;
23971: CALL_OW 18
// uc_side := side ;
23975: LD_ADDR_OWVAR 20
23979: PUSH
23980: LD_VAR 0 16
23984: ST_TO_ADDR
// uc_nation := nation ;
23985: LD_ADDR_OWVAR 21
23989: PUSH
23990: LD_VAR 0 17
23994: ST_TO_ADDR
// if buildings then
23995: LD_VAR 0 18
23999: IFFALSE 25321
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24001: LD_ADDR_VAR 0 19
24005: PUSH
24006: LD_VAR 0 18
24010: PPUSH
24011: LD_INT 2
24013: PUSH
24014: LD_INT 30
24016: PUSH
24017: LD_INT 29
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: LD_INT 30
24026: PUSH
24027: LD_INT 30
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: PPUSH
24039: CALL_OW 72
24043: ST_TO_ADDR
// if tmp then
24044: LD_VAR 0 19
24048: IFFALSE 24096
// for i in tmp do
24050: LD_ADDR_VAR 0 8
24054: PUSH
24055: LD_VAR 0 19
24059: PUSH
24060: FOR_IN
24061: IFFALSE 24094
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24063: LD_VAR 0 8
24067: PPUSH
24068: CALL_OW 250
24072: PPUSH
24073: LD_VAR 0 8
24077: PPUSH
24078: CALL_OW 251
24082: PPUSH
24083: LD_VAR 0 16
24087: PPUSH
24088: CALL_OW 441
24092: GO 24060
24094: POP
24095: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24096: LD_VAR 0 18
24100: PPUSH
24101: LD_INT 2
24103: PUSH
24104: LD_INT 30
24106: PUSH
24107: LD_INT 32
24109: PUSH
24110: EMPTY
24111: LIST
24112: LIST
24113: PUSH
24114: LD_INT 30
24116: PUSH
24117: LD_INT 33
24119: PUSH
24120: EMPTY
24121: LIST
24122: LIST
24123: PUSH
24124: EMPTY
24125: LIST
24126: LIST
24127: LIST
24128: PPUSH
24129: CALL_OW 72
24133: IFFALSE 24221
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24135: LD_ADDR_VAR 0 8
24139: PUSH
24140: LD_VAR 0 18
24144: PPUSH
24145: LD_INT 2
24147: PUSH
24148: LD_INT 30
24150: PUSH
24151: LD_INT 32
24153: PUSH
24154: EMPTY
24155: LIST
24156: LIST
24157: PUSH
24158: LD_INT 30
24160: PUSH
24161: LD_INT 33
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: PUSH
24168: EMPTY
24169: LIST
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 72
24177: PUSH
24178: FOR_IN
24179: IFFALSE 24219
// begin if not GetBWeapon ( i ) then
24181: LD_VAR 0 8
24185: PPUSH
24186: CALL_OW 269
24190: NOT
24191: IFFALSE 24217
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24193: LD_VAR 0 8
24197: PPUSH
24198: LD_VAR 0 8
24202: PPUSH
24203: LD_VAR 0 2
24207: PPUSH
24208: CALL 25467 0 2
24212: PPUSH
24213: CALL_OW 431
// end ;
24217: GO 24178
24219: POP
24220: POP
// end ; for i = 1 to personel do
24221: LD_ADDR_VAR 0 8
24225: PUSH
24226: DOUBLE
24227: LD_INT 1
24229: DEC
24230: ST_TO_ADDR
24231: LD_VAR 0 6
24235: PUSH
24236: FOR_TO
24237: IFFALSE 25301
// begin if i > 4 then
24239: LD_VAR 0 8
24243: PUSH
24244: LD_INT 4
24246: GREATER
24247: IFFALSE 24251
// break ;
24249: GO 25301
// case i of 1 :
24251: LD_VAR 0 8
24255: PUSH
24256: LD_INT 1
24258: DOUBLE
24259: EQUAL
24260: IFTRUE 24264
24262: GO 24344
24264: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24265: LD_ADDR_VAR 0 12
24269: PUSH
24270: LD_VAR 0 18
24274: PPUSH
24275: LD_INT 22
24277: PUSH
24278: LD_VAR 0 16
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: PUSH
24287: LD_INT 58
24289: PUSH
24290: EMPTY
24291: LIST
24292: PUSH
24293: LD_INT 2
24295: PUSH
24296: LD_INT 30
24298: PUSH
24299: LD_INT 32
24301: PUSH
24302: EMPTY
24303: LIST
24304: LIST
24305: PUSH
24306: LD_INT 30
24308: PUSH
24309: LD_INT 4
24311: PUSH
24312: EMPTY
24313: LIST
24314: LIST
24315: PUSH
24316: LD_INT 30
24318: PUSH
24319: LD_INT 5
24321: PUSH
24322: EMPTY
24323: LIST
24324: LIST
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: LIST
24330: LIST
24331: PUSH
24332: EMPTY
24333: LIST
24334: LIST
24335: LIST
24336: PPUSH
24337: CALL_OW 72
24341: ST_TO_ADDR
24342: GO 24566
24344: LD_INT 2
24346: DOUBLE
24347: EQUAL
24348: IFTRUE 24352
24350: GO 24414
24352: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24353: LD_ADDR_VAR 0 12
24357: PUSH
24358: LD_VAR 0 18
24362: PPUSH
24363: LD_INT 22
24365: PUSH
24366: LD_VAR 0 16
24370: PUSH
24371: EMPTY
24372: LIST
24373: LIST
24374: PUSH
24375: LD_INT 2
24377: PUSH
24378: LD_INT 30
24380: PUSH
24381: LD_INT 0
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: LD_INT 30
24390: PUSH
24391: LD_INT 1
24393: PUSH
24394: EMPTY
24395: LIST
24396: LIST
24397: PUSH
24398: EMPTY
24399: LIST
24400: LIST
24401: LIST
24402: PUSH
24403: EMPTY
24404: LIST
24405: LIST
24406: PPUSH
24407: CALL_OW 72
24411: ST_TO_ADDR
24412: GO 24566
24414: LD_INT 3
24416: DOUBLE
24417: EQUAL
24418: IFTRUE 24422
24420: GO 24484
24422: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24423: LD_ADDR_VAR 0 12
24427: PUSH
24428: LD_VAR 0 18
24432: PPUSH
24433: LD_INT 22
24435: PUSH
24436: LD_VAR 0 16
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: PUSH
24445: LD_INT 2
24447: PUSH
24448: LD_INT 30
24450: PUSH
24451: LD_INT 2
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PUSH
24458: LD_INT 30
24460: PUSH
24461: LD_INT 3
24463: PUSH
24464: EMPTY
24465: LIST
24466: LIST
24467: PUSH
24468: EMPTY
24469: LIST
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PPUSH
24477: CALL_OW 72
24481: ST_TO_ADDR
24482: GO 24566
24484: LD_INT 4
24486: DOUBLE
24487: EQUAL
24488: IFTRUE 24492
24490: GO 24565
24492: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24493: LD_ADDR_VAR 0 12
24497: PUSH
24498: LD_VAR 0 18
24502: PPUSH
24503: LD_INT 22
24505: PUSH
24506: LD_VAR 0 16
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: LD_INT 2
24517: PUSH
24518: LD_INT 30
24520: PUSH
24521: LD_INT 6
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: PUSH
24528: LD_INT 30
24530: PUSH
24531: LD_INT 7
24533: PUSH
24534: EMPTY
24535: LIST
24536: LIST
24537: PUSH
24538: LD_INT 30
24540: PUSH
24541: LD_INT 8
24543: PUSH
24544: EMPTY
24545: LIST
24546: LIST
24547: PUSH
24548: EMPTY
24549: LIST
24550: LIST
24551: LIST
24552: LIST
24553: PUSH
24554: EMPTY
24555: LIST
24556: LIST
24557: PPUSH
24558: CALL_OW 72
24562: ST_TO_ADDR
24563: GO 24566
24565: POP
// if i = 1 then
24566: LD_VAR 0 8
24570: PUSH
24571: LD_INT 1
24573: EQUAL
24574: IFFALSE 24685
// begin tmp := [ ] ;
24576: LD_ADDR_VAR 0 19
24580: PUSH
24581: EMPTY
24582: ST_TO_ADDR
// for j in f do
24583: LD_ADDR_VAR 0 9
24587: PUSH
24588: LD_VAR 0 12
24592: PUSH
24593: FOR_IN
24594: IFFALSE 24667
// if GetBType ( j ) = b_bunker then
24596: LD_VAR 0 9
24600: PPUSH
24601: CALL_OW 266
24605: PUSH
24606: LD_INT 32
24608: EQUAL
24609: IFFALSE 24636
// tmp := Insert ( tmp , 1 , j ) else
24611: LD_ADDR_VAR 0 19
24615: PUSH
24616: LD_VAR 0 19
24620: PPUSH
24621: LD_INT 1
24623: PPUSH
24624: LD_VAR 0 9
24628: PPUSH
24629: CALL_OW 2
24633: ST_TO_ADDR
24634: GO 24665
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24636: LD_ADDR_VAR 0 19
24640: PUSH
24641: LD_VAR 0 19
24645: PPUSH
24646: LD_VAR 0 19
24650: PUSH
24651: LD_INT 1
24653: PLUS
24654: PPUSH
24655: LD_VAR 0 9
24659: PPUSH
24660: CALL_OW 2
24664: ST_TO_ADDR
24665: GO 24593
24667: POP
24668: POP
// if tmp then
24669: LD_VAR 0 19
24673: IFFALSE 24685
// f := tmp ;
24675: LD_ADDR_VAR 0 12
24679: PUSH
24680: LD_VAR 0 19
24684: ST_TO_ADDR
// end ; x := personel [ i ] ;
24685: LD_ADDR_VAR 0 13
24689: PUSH
24690: LD_VAR 0 6
24694: PUSH
24695: LD_VAR 0 8
24699: ARRAY
24700: ST_TO_ADDR
// if x = - 1 then
24701: LD_VAR 0 13
24705: PUSH
24706: LD_INT 1
24708: NEG
24709: EQUAL
24710: IFFALSE 24919
// begin for j in f do
24712: LD_ADDR_VAR 0 9
24716: PUSH
24717: LD_VAR 0 12
24721: PUSH
24722: FOR_IN
24723: IFFALSE 24915
// repeat InitHc ;
24725: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24729: LD_VAR 0 9
24733: PPUSH
24734: CALL_OW 266
24738: PUSH
24739: LD_INT 5
24741: EQUAL
24742: IFFALSE 24812
// begin if UnitsInside ( j ) < 3 then
24744: LD_VAR 0 9
24748: PPUSH
24749: CALL_OW 313
24753: PUSH
24754: LD_INT 3
24756: LESS
24757: IFFALSE 24793
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24759: LD_INT 0
24761: PPUSH
24762: LD_INT 5
24764: PUSH
24765: LD_INT 8
24767: PUSH
24768: LD_INT 9
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: LIST
24775: PUSH
24776: LD_VAR 0 17
24780: ARRAY
24781: PPUSH
24782: LD_VAR 0 4
24786: PPUSH
24787: CALL_OW 380
24791: GO 24810
// PrepareHuman ( false , i , skill ) ;
24793: LD_INT 0
24795: PPUSH
24796: LD_VAR 0 8
24800: PPUSH
24801: LD_VAR 0 4
24805: PPUSH
24806: CALL_OW 380
// end else
24810: GO 24829
// PrepareHuman ( false , i , skill ) ;
24812: LD_INT 0
24814: PPUSH
24815: LD_VAR 0 8
24819: PPUSH
24820: LD_VAR 0 4
24824: PPUSH
24825: CALL_OW 380
// un := CreateHuman ;
24829: LD_ADDR_VAR 0 14
24833: PUSH
24834: CALL_OW 44
24838: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24839: LD_ADDR_VAR 0 7
24843: PUSH
24844: LD_VAR 0 7
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: LD_VAR 0 14
24856: PPUSH
24857: CALL_OW 2
24861: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24862: LD_VAR 0 14
24866: PPUSH
24867: LD_VAR 0 9
24871: PPUSH
24872: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24876: LD_VAR 0 9
24880: PPUSH
24881: CALL_OW 313
24885: PUSH
24886: LD_INT 6
24888: EQUAL
24889: PUSH
24890: LD_VAR 0 9
24894: PPUSH
24895: CALL_OW 266
24899: PUSH
24900: LD_INT 32
24902: PUSH
24903: LD_INT 31
24905: PUSH
24906: EMPTY
24907: LIST
24908: LIST
24909: IN
24910: OR
24911: IFFALSE 24725
24913: GO 24722
24915: POP
24916: POP
// end else
24917: GO 25299
// for j = 1 to x do
24919: LD_ADDR_VAR 0 9
24923: PUSH
24924: DOUBLE
24925: LD_INT 1
24927: DEC
24928: ST_TO_ADDR
24929: LD_VAR 0 13
24933: PUSH
24934: FOR_TO
24935: IFFALSE 25297
// begin InitHc ;
24937: CALL_OW 19
// if not f then
24941: LD_VAR 0 12
24945: NOT
24946: IFFALSE 25035
// begin PrepareHuman ( false , i , skill ) ;
24948: LD_INT 0
24950: PPUSH
24951: LD_VAR 0 8
24955: PPUSH
24956: LD_VAR 0 4
24960: PPUSH
24961: CALL_OW 380
// un := CreateHuman ;
24965: LD_ADDR_VAR 0 14
24969: PUSH
24970: CALL_OW 44
24974: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24975: LD_ADDR_VAR 0 7
24979: PUSH
24980: LD_VAR 0 7
24984: PPUSH
24985: LD_INT 1
24987: PPUSH
24988: LD_VAR 0 14
24992: PPUSH
24993: CALL_OW 2
24997: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24998: LD_VAR 0 14
25002: PPUSH
25003: LD_VAR 0 1
25007: PPUSH
25008: CALL_OW 250
25012: PPUSH
25013: LD_VAR 0 1
25017: PPUSH
25018: CALL_OW 251
25022: PPUSH
25023: LD_INT 10
25025: PPUSH
25026: LD_INT 0
25028: PPUSH
25029: CALL_OW 50
// continue ;
25033: GO 24934
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25035: LD_VAR 0 12
25039: PUSH
25040: LD_INT 1
25042: ARRAY
25043: PPUSH
25044: CALL_OW 313
25048: PUSH
25049: LD_VAR 0 12
25053: PUSH
25054: LD_INT 1
25056: ARRAY
25057: PPUSH
25058: CALL_OW 266
25062: PUSH
25063: LD_INT 32
25065: PUSH
25066: LD_INT 31
25068: PUSH
25069: EMPTY
25070: LIST
25071: LIST
25072: IN
25073: AND
25074: PUSH
25075: LD_VAR 0 12
25079: PUSH
25080: LD_INT 1
25082: ARRAY
25083: PPUSH
25084: CALL_OW 313
25088: PUSH
25089: LD_INT 6
25091: EQUAL
25092: OR
25093: IFFALSE 25113
// f := Delete ( f , 1 ) ;
25095: LD_ADDR_VAR 0 12
25099: PUSH
25100: LD_VAR 0 12
25104: PPUSH
25105: LD_INT 1
25107: PPUSH
25108: CALL_OW 3
25112: ST_TO_ADDR
// if not f then
25113: LD_VAR 0 12
25117: NOT
25118: IFFALSE 25136
// begin x := x + 2 ;
25120: LD_ADDR_VAR 0 13
25124: PUSH
25125: LD_VAR 0 13
25129: PUSH
25130: LD_INT 2
25132: PLUS
25133: ST_TO_ADDR
// continue ;
25134: GO 24934
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25136: LD_VAR 0 12
25140: PUSH
25141: LD_INT 1
25143: ARRAY
25144: PPUSH
25145: CALL_OW 266
25149: PUSH
25150: LD_INT 5
25152: EQUAL
25153: IFFALSE 25227
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25155: LD_VAR 0 12
25159: PUSH
25160: LD_INT 1
25162: ARRAY
25163: PPUSH
25164: CALL_OW 313
25168: PUSH
25169: LD_INT 3
25171: LESS
25172: IFFALSE 25208
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25174: LD_INT 0
25176: PPUSH
25177: LD_INT 5
25179: PUSH
25180: LD_INT 8
25182: PUSH
25183: LD_INT 9
25185: PUSH
25186: EMPTY
25187: LIST
25188: LIST
25189: LIST
25190: PUSH
25191: LD_VAR 0 17
25195: ARRAY
25196: PPUSH
25197: LD_VAR 0 4
25201: PPUSH
25202: CALL_OW 380
25206: GO 25225
// PrepareHuman ( false , i , skill ) ;
25208: LD_INT 0
25210: PPUSH
25211: LD_VAR 0 8
25215: PPUSH
25216: LD_VAR 0 4
25220: PPUSH
25221: CALL_OW 380
// end else
25225: GO 25244
// PrepareHuman ( false , i , skill ) ;
25227: LD_INT 0
25229: PPUSH
25230: LD_VAR 0 8
25234: PPUSH
25235: LD_VAR 0 4
25239: PPUSH
25240: CALL_OW 380
// un := CreateHuman ;
25244: LD_ADDR_VAR 0 14
25248: PUSH
25249: CALL_OW 44
25253: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25254: LD_ADDR_VAR 0 7
25258: PUSH
25259: LD_VAR 0 7
25263: PPUSH
25264: LD_INT 1
25266: PPUSH
25267: LD_VAR 0 14
25271: PPUSH
25272: CALL_OW 2
25276: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25277: LD_VAR 0 14
25281: PPUSH
25282: LD_VAR 0 12
25286: PUSH
25287: LD_INT 1
25289: ARRAY
25290: PPUSH
25291: CALL_OW 52
// end ;
25295: GO 24934
25297: POP
25298: POP
// end ;
25299: GO 24236
25301: POP
25302: POP
// result := result ^ buildings ;
25303: LD_ADDR_VAR 0 7
25307: PUSH
25308: LD_VAR 0 7
25312: PUSH
25313: LD_VAR 0 18
25317: ADD
25318: ST_TO_ADDR
// end else
25319: GO 25462
// begin for i = 1 to personel do
25321: LD_ADDR_VAR 0 8
25325: PUSH
25326: DOUBLE
25327: LD_INT 1
25329: DEC
25330: ST_TO_ADDR
25331: LD_VAR 0 6
25335: PUSH
25336: FOR_TO
25337: IFFALSE 25460
// begin if i > 4 then
25339: LD_VAR 0 8
25343: PUSH
25344: LD_INT 4
25346: GREATER
25347: IFFALSE 25351
// break ;
25349: GO 25460
// x := personel [ i ] ;
25351: LD_ADDR_VAR 0 13
25355: PUSH
25356: LD_VAR 0 6
25360: PUSH
25361: LD_VAR 0 8
25365: ARRAY
25366: ST_TO_ADDR
// if x = - 1 then
25367: LD_VAR 0 13
25371: PUSH
25372: LD_INT 1
25374: NEG
25375: EQUAL
25376: IFFALSE 25380
// continue ;
25378: GO 25336
// PrepareHuman ( false , i , skill ) ;
25380: LD_INT 0
25382: PPUSH
25383: LD_VAR 0 8
25387: PPUSH
25388: LD_VAR 0 4
25392: PPUSH
25393: CALL_OW 380
// un := CreateHuman ;
25397: LD_ADDR_VAR 0 14
25401: PUSH
25402: CALL_OW 44
25406: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25407: LD_VAR 0 14
25411: PPUSH
25412: LD_VAR 0 1
25416: PPUSH
25417: CALL_OW 250
25421: PPUSH
25422: LD_VAR 0 1
25426: PPUSH
25427: CALL_OW 251
25431: PPUSH
25432: LD_INT 10
25434: PPUSH
25435: LD_INT 0
25437: PPUSH
25438: CALL_OW 50
// result := result ^ un ;
25442: LD_ADDR_VAR 0 7
25446: PUSH
25447: LD_VAR 0 7
25451: PUSH
25452: LD_VAR 0 14
25456: ADD
25457: ST_TO_ADDR
// end ;
25458: GO 25336
25460: POP
25461: POP
// end ; end ;
25462: LD_VAR 0 7
25466: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25467: LD_INT 0
25469: PPUSH
25470: PPUSH
25471: PPUSH
25472: PPUSH
25473: PPUSH
25474: PPUSH
25475: PPUSH
25476: PPUSH
25477: PPUSH
25478: PPUSH
25479: PPUSH
25480: PPUSH
25481: PPUSH
25482: PPUSH
25483: PPUSH
25484: PPUSH
// result := false ;
25485: LD_ADDR_VAR 0 3
25489: PUSH
25490: LD_INT 0
25492: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25493: LD_VAR 0 1
25497: NOT
25498: PUSH
25499: LD_VAR 0 1
25503: PPUSH
25504: CALL_OW 266
25508: PUSH
25509: LD_INT 32
25511: PUSH
25512: LD_INT 33
25514: PUSH
25515: EMPTY
25516: LIST
25517: LIST
25518: IN
25519: NOT
25520: OR
25521: IFFALSE 25525
// exit ;
25523: GO 26661
// nat := GetNation ( tower ) ;
25525: LD_ADDR_VAR 0 12
25529: PUSH
25530: LD_VAR 0 1
25534: PPUSH
25535: CALL_OW 248
25539: ST_TO_ADDR
// side := GetSide ( tower ) ;
25540: LD_ADDR_VAR 0 16
25544: PUSH
25545: LD_VAR 0 1
25549: PPUSH
25550: CALL_OW 255
25554: ST_TO_ADDR
// x := GetX ( tower ) ;
25555: LD_ADDR_VAR 0 10
25559: PUSH
25560: LD_VAR 0 1
25564: PPUSH
25565: CALL_OW 250
25569: ST_TO_ADDR
// y := GetY ( tower ) ;
25570: LD_ADDR_VAR 0 11
25574: PUSH
25575: LD_VAR 0 1
25579: PPUSH
25580: CALL_OW 251
25584: ST_TO_ADDR
// if not x or not y then
25585: LD_VAR 0 10
25589: NOT
25590: PUSH
25591: LD_VAR 0 11
25595: NOT
25596: OR
25597: IFFALSE 25601
// exit ;
25599: GO 26661
// weapon := 0 ;
25601: LD_ADDR_VAR 0 18
25605: PUSH
25606: LD_INT 0
25608: ST_TO_ADDR
// fac_list := [ ] ;
25609: LD_ADDR_VAR 0 17
25613: PUSH
25614: EMPTY
25615: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25616: LD_ADDR_VAR 0 6
25620: PUSH
25621: LD_VAR 0 1
25625: PPUSH
25626: CALL_OW 274
25630: PPUSH
25631: LD_VAR 0 2
25635: PPUSH
25636: CALL 23239 0 2
25640: PPUSH
25641: LD_INT 30
25643: PUSH
25644: LD_INT 3
25646: PUSH
25647: EMPTY
25648: LIST
25649: LIST
25650: PPUSH
25651: CALL_OW 72
25655: ST_TO_ADDR
// if not factories then
25656: LD_VAR 0 6
25660: NOT
25661: IFFALSE 25665
// exit ;
25663: GO 26661
// for i in factories do
25665: LD_ADDR_VAR 0 8
25669: PUSH
25670: LD_VAR 0 6
25674: PUSH
25675: FOR_IN
25676: IFFALSE 25701
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25678: LD_ADDR_VAR 0 17
25682: PUSH
25683: LD_VAR 0 17
25687: PUSH
25688: LD_VAR 0 8
25692: PPUSH
25693: CALL_OW 478
25697: UNION
25698: ST_TO_ADDR
25699: GO 25675
25701: POP
25702: POP
// if not fac_list then
25703: LD_VAR 0 17
25707: NOT
25708: IFFALSE 25712
// exit ;
25710: GO 26661
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25712: LD_ADDR_VAR 0 5
25716: PUSH
25717: LD_INT 4
25719: PUSH
25720: LD_INT 5
25722: PUSH
25723: LD_INT 9
25725: PUSH
25726: LD_INT 10
25728: PUSH
25729: LD_INT 6
25731: PUSH
25732: LD_INT 7
25734: PUSH
25735: LD_INT 11
25737: PUSH
25738: EMPTY
25739: LIST
25740: LIST
25741: LIST
25742: LIST
25743: LIST
25744: LIST
25745: LIST
25746: PUSH
25747: LD_INT 27
25749: PUSH
25750: LD_INT 28
25752: PUSH
25753: LD_INT 26
25755: PUSH
25756: LD_INT 30
25758: PUSH
25759: EMPTY
25760: LIST
25761: LIST
25762: LIST
25763: LIST
25764: PUSH
25765: LD_INT 43
25767: PUSH
25768: LD_INT 44
25770: PUSH
25771: LD_INT 46
25773: PUSH
25774: LD_INT 45
25776: PUSH
25777: LD_INT 47
25779: PUSH
25780: LD_INT 49
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: LIST
25787: LIST
25788: LIST
25789: LIST
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: LIST
25795: PUSH
25796: LD_VAR 0 12
25800: ARRAY
25801: ST_TO_ADDR
// for i in list do
25802: LD_ADDR_VAR 0 8
25806: PUSH
25807: LD_VAR 0 5
25811: PUSH
25812: FOR_IN
25813: IFFALSE 25846
// if not i in fac_list then
25815: LD_VAR 0 8
25819: PUSH
25820: LD_VAR 0 17
25824: IN
25825: NOT
25826: IFFALSE 25844
// list := list diff i ;
25828: LD_ADDR_VAR 0 5
25832: PUSH
25833: LD_VAR 0 5
25837: PUSH
25838: LD_VAR 0 8
25842: DIFF
25843: ST_TO_ADDR
25844: GO 25812
25846: POP
25847: POP
// if not list then
25848: LD_VAR 0 5
25852: NOT
25853: IFFALSE 25857
// exit ;
25855: GO 26661
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25857: LD_VAR 0 12
25861: PUSH
25862: LD_INT 3
25864: EQUAL
25865: PUSH
25866: LD_INT 49
25868: PUSH
25869: LD_VAR 0 5
25873: IN
25874: AND
25875: PUSH
25876: LD_INT 31
25878: PPUSH
25879: LD_VAR 0 16
25883: PPUSH
25884: CALL_OW 321
25888: PUSH
25889: LD_INT 2
25891: EQUAL
25892: AND
25893: IFFALSE 25953
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25895: LD_INT 22
25897: PUSH
25898: LD_VAR 0 16
25902: PUSH
25903: EMPTY
25904: LIST
25905: LIST
25906: PUSH
25907: LD_INT 35
25909: PUSH
25910: LD_INT 49
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: PUSH
25917: LD_INT 91
25919: PUSH
25920: LD_VAR 0 1
25924: PUSH
25925: LD_INT 10
25927: PUSH
25928: EMPTY
25929: LIST
25930: LIST
25931: LIST
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: LIST
25937: PPUSH
25938: CALL_OW 69
25942: NOT
25943: IFFALSE 25953
// weapon := ru_time_lapser ;
25945: LD_ADDR_VAR 0 18
25949: PUSH
25950: LD_INT 49
25952: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25953: LD_VAR 0 12
25957: PUSH
25958: LD_INT 1
25960: PUSH
25961: LD_INT 2
25963: PUSH
25964: EMPTY
25965: LIST
25966: LIST
25967: IN
25968: PUSH
25969: LD_INT 11
25971: PUSH
25972: LD_VAR 0 5
25976: IN
25977: PUSH
25978: LD_INT 30
25980: PUSH
25981: LD_VAR 0 5
25985: IN
25986: OR
25987: AND
25988: PUSH
25989: LD_INT 6
25991: PPUSH
25992: LD_VAR 0 16
25996: PPUSH
25997: CALL_OW 321
26001: PUSH
26002: LD_INT 2
26004: EQUAL
26005: AND
26006: IFFALSE 26171
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26008: LD_INT 22
26010: PUSH
26011: LD_VAR 0 16
26015: PUSH
26016: EMPTY
26017: LIST
26018: LIST
26019: PUSH
26020: LD_INT 2
26022: PUSH
26023: LD_INT 35
26025: PUSH
26026: LD_INT 11
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: PUSH
26033: LD_INT 35
26035: PUSH
26036: LD_INT 30
26038: PUSH
26039: EMPTY
26040: LIST
26041: LIST
26042: PUSH
26043: EMPTY
26044: LIST
26045: LIST
26046: LIST
26047: PUSH
26048: LD_INT 91
26050: PUSH
26051: LD_VAR 0 1
26055: PUSH
26056: LD_INT 18
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: LIST
26063: PUSH
26064: EMPTY
26065: LIST
26066: LIST
26067: LIST
26068: PPUSH
26069: CALL_OW 69
26073: NOT
26074: PUSH
26075: LD_INT 22
26077: PUSH
26078: LD_VAR 0 16
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: PUSH
26087: LD_INT 2
26089: PUSH
26090: LD_INT 30
26092: PUSH
26093: LD_INT 32
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: PUSH
26100: LD_INT 30
26102: PUSH
26103: LD_INT 33
26105: PUSH
26106: EMPTY
26107: LIST
26108: LIST
26109: PUSH
26110: EMPTY
26111: LIST
26112: LIST
26113: LIST
26114: PUSH
26115: LD_INT 91
26117: PUSH
26118: LD_VAR 0 1
26122: PUSH
26123: LD_INT 12
26125: PUSH
26126: EMPTY
26127: LIST
26128: LIST
26129: LIST
26130: PUSH
26131: EMPTY
26132: LIST
26133: LIST
26134: LIST
26135: PUSH
26136: EMPTY
26137: LIST
26138: PPUSH
26139: CALL_OW 69
26143: PUSH
26144: LD_INT 2
26146: GREATER
26147: AND
26148: IFFALSE 26171
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26150: LD_ADDR_VAR 0 18
26154: PUSH
26155: LD_INT 11
26157: PUSH
26158: LD_INT 30
26160: PUSH
26161: EMPTY
26162: LIST
26163: LIST
26164: PUSH
26165: LD_VAR 0 12
26169: ARRAY
26170: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26171: LD_VAR 0 18
26175: NOT
26176: PUSH
26177: LD_INT 40
26179: PPUSH
26180: LD_VAR 0 16
26184: PPUSH
26185: CALL_OW 321
26189: PUSH
26190: LD_INT 2
26192: EQUAL
26193: AND
26194: PUSH
26195: LD_INT 7
26197: PUSH
26198: LD_VAR 0 5
26202: IN
26203: PUSH
26204: LD_INT 28
26206: PUSH
26207: LD_VAR 0 5
26211: IN
26212: OR
26213: PUSH
26214: LD_INT 45
26216: PUSH
26217: LD_VAR 0 5
26221: IN
26222: OR
26223: AND
26224: IFFALSE 26478
// begin hex := GetHexInfo ( x , y ) ;
26226: LD_ADDR_VAR 0 4
26230: PUSH
26231: LD_VAR 0 10
26235: PPUSH
26236: LD_VAR 0 11
26240: PPUSH
26241: CALL_OW 546
26245: ST_TO_ADDR
// if hex [ 1 ] then
26246: LD_VAR 0 4
26250: PUSH
26251: LD_INT 1
26253: ARRAY
26254: IFFALSE 26258
// exit ;
26256: GO 26661
// height := hex [ 2 ] ;
26258: LD_ADDR_VAR 0 15
26262: PUSH
26263: LD_VAR 0 4
26267: PUSH
26268: LD_INT 2
26270: ARRAY
26271: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26272: LD_ADDR_VAR 0 14
26276: PUSH
26277: LD_INT 0
26279: PUSH
26280: LD_INT 2
26282: PUSH
26283: LD_INT 3
26285: PUSH
26286: LD_INT 5
26288: PUSH
26289: EMPTY
26290: LIST
26291: LIST
26292: LIST
26293: LIST
26294: ST_TO_ADDR
// for i in tmp do
26295: LD_ADDR_VAR 0 8
26299: PUSH
26300: LD_VAR 0 14
26304: PUSH
26305: FOR_IN
26306: IFFALSE 26476
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26308: LD_ADDR_VAR 0 9
26312: PUSH
26313: LD_VAR 0 10
26317: PPUSH
26318: LD_VAR 0 8
26322: PPUSH
26323: LD_INT 5
26325: PPUSH
26326: CALL_OW 272
26330: PUSH
26331: LD_VAR 0 11
26335: PPUSH
26336: LD_VAR 0 8
26340: PPUSH
26341: LD_INT 5
26343: PPUSH
26344: CALL_OW 273
26348: PUSH
26349: EMPTY
26350: LIST
26351: LIST
26352: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26353: LD_VAR 0 9
26357: PUSH
26358: LD_INT 1
26360: ARRAY
26361: PPUSH
26362: LD_VAR 0 9
26366: PUSH
26367: LD_INT 2
26369: ARRAY
26370: PPUSH
26371: CALL_OW 488
26375: IFFALSE 26474
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26377: LD_ADDR_VAR 0 4
26381: PUSH
26382: LD_VAR 0 9
26386: PUSH
26387: LD_INT 1
26389: ARRAY
26390: PPUSH
26391: LD_VAR 0 9
26395: PUSH
26396: LD_INT 2
26398: ARRAY
26399: PPUSH
26400: CALL_OW 546
26404: ST_TO_ADDR
// if hex [ 1 ] then
26405: LD_VAR 0 4
26409: PUSH
26410: LD_INT 1
26412: ARRAY
26413: IFFALSE 26417
// continue ;
26415: GO 26305
// h := hex [ 2 ] ;
26417: LD_ADDR_VAR 0 13
26421: PUSH
26422: LD_VAR 0 4
26426: PUSH
26427: LD_INT 2
26429: ARRAY
26430: ST_TO_ADDR
// if h + 7 < height then
26431: LD_VAR 0 13
26435: PUSH
26436: LD_INT 7
26438: PLUS
26439: PUSH
26440: LD_VAR 0 15
26444: LESS
26445: IFFALSE 26474
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26447: LD_ADDR_VAR 0 18
26451: PUSH
26452: LD_INT 7
26454: PUSH
26455: LD_INT 28
26457: PUSH
26458: LD_INT 45
26460: PUSH
26461: EMPTY
26462: LIST
26463: LIST
26464: LIST
26465: PUSH
26466: LD_VAR 0 12
26470: ARRAY
26471: ST_TO_ADDR
// break ;
26472: GO 26476
// end ; end ; end ;
26474: GO 26305
26476: POP
26477: POP
// end ; if not weapon then
26478: LD_VAR 0 18
26482: NOT
26483: IFFALSE 26543
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26485: LD_ADDR_VAR 0 5
26489: PUSH
26490: LD_VAR 0 5
26494: PUSH
26495: LD_INT 11
26497: PUSH
26498: LD_INT 30
26500: PUSH
26501: LD_INT 49
26503: PUSH
26504: EMPTY
26505: LIST
26506: LIST
26507: LIST
26508: DIFF
26509: ST_TO_ADDR
// if not list then
26510: LD_VAR 0 5
26514: NOT
26515: IFFALSE 26519
// exit ;
26517: GO 26661
// weapon := list [ rand ( 1 , list ) ] ;
26519: LD_ADDR_VAR 0 18
26523: PUSH
26524: LD_VAR 0 5
26528: PUSH
26529: LD_INT 1
26531: PPUSH
26532: LD_VAR 0 5
26536: PPUSH
26537: CALL_OW 12
26541: ARRAY
26542: ST_TO_ADDR
// end ; if weapon then
26543: LD_VAR 0 18
26547: IFFALSE 26661
// begin tmp := CostOfWeapon ( weapon ) ;
26549: LD_ADDR_VAR 0 14
26553: PUSH
26554: LD_VAR 0 18
26558: PPUSH
26559: CALL_OW 451
26563: ST_TO_ADDR
// j := GetBase ( tower ) ;
26564: LD_ADDR_VAR 0 9
26568: PUSH
26569: LD_VAR 0 1
26573: PPUSH
26574: CALL_OW 274
26578: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26579: LD_VAR 0 9
26583: PPUSH
26584: LD_INT 1
26586: PPUSH
26587: CALL_OW 275
26591: PUSH
26592: LD_VAR 0 14
26596: PUSH
26597: LD_INT 1
26599: ARRAY
26600: GREATEREQUAL
26601: PUSH
26602: LD_VAR 0 9
26606: PPUSH
26607: LD_INT 2
26609: PPUSH
26610: CALL_OW 275
26614: PUSH
26615: LD_VAR 0 14
26619: PUSH
26620: LD_INT 2
26622: ARRAY
26623: GREATEREQUAL
26624: AND
26625: PUSH
26626: LD_VAR 0 9
26630: PPUSH
26631: LD_INT 3
26633: PPUSH
26634: CALL_OW 275
26638: PUSH
26639: LD_VAR 0 14
26643: PUSH
26644: LD_INT 3
26646: ARRAY
26647: GREATEREQUAL
26648: AND
26649: IFFALSE 26661
// result := weapon ;
26651: LD_ADDR_VAR 0 3
26655: PUSH
26656: LD_VAR 0 18
26660: ST_TO_ADDR
// end ; end ;
26661: LD_VAR 0 3
26665: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26666: LD_INT 0
26668: PPUSH
26669: PPUSH
// result := true ;
26670: LD_ADDR_VAR 0 3
26674: PUSH
26675: LD_INT 1
26677: ST_TO_ADDR
// if array1 = array2 then
26678: LD_VAR 0 1
26682: PUSH
26683: LD_VAR 0 2
26687: EQUAL
26688: IFFALSE 26748
// begin for i = 1 to array1 do
26690: LD_ADDR_VAR 0 4
26694: PUSH
26695: DOUBLE
26696: LD_INT 1
26698: DEC
26699: ST_TO_ADDR
26700: LD_VAR 0 1
26704: PUSH
26705: FOR_TO
26706: IFFALSE 26744
// if array1 [ i ] <> array2 [ i ] then
26708: LD_VAR 0 1
26712: PUSH
26713: LD_VAR 0 4
26717: ARRAY
26718: PUSH
26719: LD_VAR 0 2
26723: PUSH
26724: LD_VAR 0 4
26728: ARRAY
26729: NONEQUAL
26730: IFFALSE 26742
// begin result := false ;
26732: LD_ADDR_VAR 0 3
26736: PUSH
26737: LD_INT 0
26739: ST_TO_ADDR
// break ;
26740: GO 26744
// end ;
26742: GO 26705
26744: POP
26745: POP
// end else
26746: GO 26756
// result := false ;
26748: LD_ADDR_VAR 0 3
26752: PUSH
26753: LD_INT 0
26755: ST_TO_ADDR
// end ;
26756: LD_VAR 0 3
26760: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26761: LD_INT 0
26763: PPUSH
26764: PPUSH
26765: PPUSH
// pom := GetBase ( fac ) ;
26766: LD_ADDR_VAR 0 5
26770: PUSH
26771: LD_VAR 0 1
26775: PPUSH
26776: CALL_OW 274
26780: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26781: LD_ADDR_VAR 0 4
26785: PUSH
26786: LD_VAR 0 2
26790: PUSH
26791: LD_INT 1
26793: ARRAY
26794: PPUSH
26795: LD_VAR 0 2
26799: PUSH
26800: LD_INT 2
26802: ARRAY
26803: PPUSH
26804: LD_VAR 0 2
26808: PUSH
26809: LD_INT 3
26811: ARRAY
26812: PPUSH
26813: LD_VAR 0 2
26817: PUSH
26818: LD_INT 4
26820: ARRAY
26821: PPUSH
26822: CALL_OW 449
26826: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26827: LD_ADDR_VAR 0 3
26831: PUSH
26832: LD_VAR 0 5
26836: PPUSH
26837: LD_INT 1
26839: PPUSH
26840: CALL_OW 275
26844: PUSH
26845: LD_VAR 0 4
26849: PUSH
26850: LD_INT 1
26852: ARRAY
26853: GREATEREQUAL
26854: PUSH
26855: LD_VAR 0 5
26859: PPUSH
26860: LD_INT 2
26862: PPUSH
26863: CALL_OW 275
26867: PUSH
26868: LD_VAR 0 4
26872: PUSH
26873: LD_INT 2
26875: ARRAY
26876: GREATEREQUAL
26877: AND
26878: PUSH
26879: LD_VAR 0 5
26883: PPUSH
26884: LD_INT 3
26886: PPUSH
26887: CALL_OW 275
26891: PUSH
26892: LD_VAR 0 4
26896: PUSH
26897: LD_INT 3
26899: ARRAY
26900: GREATEREQUAL
26901: AND
26902: ST_TO_ADDR
// end ;
26903: LD_VAR 0 3
26907: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26908: LD_INT 0
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
// pom := GetBase ( building ) ;
26914: LD_ADDR_VAR 0 3
26918: PUSH
26919: LD_VAR 0 1
26923: PPUSH
26924: CALL_OW 274
26928: ST_TO_ADDR
// if not pom then
26929: LD_VAR 0 3
26933: NOT
26934: IFFALSE 26938
// exit ;
26936: GO 27108
// btype := GetBType ( building ) ;
26938: LD_ADDR_VAR 0 5
26942: PUSH
26943: LD_VAR 0 1
26947: PPUSH
26948: CALL_OW 266
26952: ST_TO_ADDR
// if btype = b_armoury then
26953: LD_VAR 0 5
26957: PUSH
26958: LD_INT 4
26960: EQUAL
26961: IFFALSE 26971
// btype := b_barracks ;
26963: LD_ADDR_VAR 0 5
26967: PUSH
26968: LD_INT 5
26970: ST_TO_ADDR
// if btype = b_depot then
26971: LD_VAR 0 5
26975: PUSH
26976: LD_INT 0
26978: EQUAL
26979: IFFALSE 26989
// btype := b_warehouse ;
26981: LD_ADDR_VAR 0 5
26985: PUSH
26986: LD_INT 1
26988: ST_TO_ADDR
// if btype = b_workshop then
26989: LD_VAR 0 5
26993: PUSH
26994: LD_INT 2
26996: EQUAL
26997: IFFALSE 27007
// btype := b_factory ;
26999: LD_ADDR_VAR 0 5
27003: PUSH
27004: LD_INT 3
27006: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27007: LD_ADDR_VAR 0 4
27011: PUSH
27012: LD_VAR 0 5
27016: PPUSH
27017: LD_VAR 0 1
27021: PPUSH
27022: CALL_OW 248
27026: PPUSH
27027: CALL_OW 450
27031: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27032: LD_ADDR_VAR 0 2
27036: PUSH
27037: LD_VAR 0 3
27041: PPUSH
27042: LD_INT 1
27044: PPUSH
27045: CALL_OW 275
27049: PUSH
27050: LD_VAR 0 4
27054: PUSH
27055: LD_INT 1
27057: ARRAY
27058: GREATEREQUAL
27059: PUSH
27060: LD_VAR 0 3
27064: PPUSH
27065: LD_INT 2
27067: PPUSH
27068: CALL_OW 275
27072: PUSH
27073: LD_VAR 0 4
27077: PUSH
27078: LD_INT 2
27080: ARRAY
27081: GREATEREQUAL
27082: AND
27083: PUSH
27084: LD_VAR 0 3
27088: PPUSH
27089: LD_INT 3
27091: PPUSH
27092: CALL_OW 275
27096: PUSH
27097: LD_VAR 0 4
27101: PUSH
27102: LD_INT 3
27104: ARRAY
27105: GREATEREQUAL
27106: AND
27107: ST_TO_ADDR
// end ;
27108: LD_VAR 0 2
27112: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27113: LD_INT 0
27115: PPUSH
27116: PPUSH
27117: PPUSH
// pom := GetBase ( building ) ;
27118: LD_ADDR_VAR 0 4
27122: PUSH
27123: LD_VAR 0 1
27127: PPUSH
27128: CALL_OW 274
27132: ST_TO_ADDR
// if not pom then
27133: LD_VAR 0 4
27137: NOT
27138: IFFALSE 27142
// exit ;
27140: GO 27243
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27142: LD_ADDR_VAR 0 5
27146: PUSH
27147: LD_VAR 0 2
27151: PPUSH
27152: LD_VAR 0 1
27156: PPUSH
27157: CALL_OW 248
27161: PPUSH
27162: CALL_OW 450
27166: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27167: LD_ADDR_VAR 0 3
27171: PUSH
27172: LD_VAR 0 4
27176: PPUSH
27177: LD_INT 1
27179: PPUSH
27180: CALL_OW 275
27184: PUSH
27185: LD_VAR 0 5
27189: PUSH
27190: LD_INT 1
27192: ARRAY
27193: GREATEREQUAL
27194: PUSH
27195: LD_VAR 0 4
27199: PPUSH
27200: LD_INT 2
27202: PPUSH
27203: CALL_OW 275
27207: PUSH
27208: LD_VAR 0 5
27212: PUSH
27213: LD_INT 2
27215: ARRAY
27216: GREATEREQUAL
27217: AND
27218: PUSH
27219: LD_VAR 0 4
27223: PPUSH
27224: LD_INT 3
27226: PPUSH
27227: CALL_OW 275
27231: PUSH
27232: LD_VAR 0 5
27236: PUSH
27237: LD_INT 3
27239: ARRAY
27240: GREATEREQUAL
27241: AND
27242: ST_TO_ADDR
// end ;
27243: LD_VAR 0 3
27247: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27248: LD_INT 0
27250: PPUSH
27251: PPUSH
27252: PPUSH
27253: PPUSH
27254: PPUSH
27255: PPUSH
27256: PPUSH
27257: PPUSH
27258: PPUSH
27259: PPUSH
// result := false ;
27260: LD_ADDR_VAR 0 6
27264: PUSH
27265: LD_INT 0
27267: ST_TO_ADDR
// if not base or not btype or not x or not y then
27268: LD_VAR 0 1
27272: NOT
27273: PUSH
27274: LD_VAR 0 2
27278: NOT
27279: OR
27280: PUSH
27281: LD_VAR 0 3
27285: NOT
27286: OR
27287: PUSH
27288: LD_VAR 0 4
27292: NOT
27293: OR
27294: IFFALSE 27298
// exit ;
27296: GO 27889
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27298: LD_ADDR_VAR 0 12
27302: PUSH
27303: LD_VAR 0 2
27307: PPUSH
27308: LD_VAR 0 3
27312: PPUSH
27313: LD_VAR 0 4
27317: PPUSH
27318: LD_VAR 0 5
27322: PPUSH
27323: LD_VAR 0 1
27327: PUSH
27328: LD_INT 1
27330: ARRAY
27331: PPUSH
27332: CALL_OW 248
27336: PPUSH
27337: LD_INT 0
27339: PPUSH
27340: CALL 28726 0 6
27344: ST_TO_ADDR
// if not hexes then
27345: LD_VAR 0 12
27349: NOT
27350: IFFALSE 27354
// exit ;
27352: GO 27889
// for i = 1 to hexes do
27354: LD_ADDR_VAR 0 7
27358: PUSH
27359: DOUBLE
27360: LD_INT 1
27362: DEC
27363: ST_TO_ADDR
27364: LD_VAR 0 12
27368: PUSH
27369: FOR_TO
27370: IFFALSE 27887
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27372: LD_ADDR_VAR 0 11
27376: PUSH
27377: LD_VAR 0 12
27381: PUSH
27382: LD_VAR 0 7
27386: ARRAY
27387: PUSH
27388: LD_INT 1
27390: ARRAY
27391: PPUSH
27392: LD_VAR 0 12
27396: PUSH
27397: LD_VAR 0 7
27401: ARRAY
27402: PUSH
27403: LD_INT 2
27405: ARRAY
27406: PPUSH
27407: CALL_OW 428
27411: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27412: LD_VAR 0 12
27416: PUSH
27417: LD_VAR 0 7
27421: ARRAY
27422: PUSH
27423: LD_INT 1
27425: ARRAY
27426: PPUSH
27427: LD_VAR 0 12
27431: PUSH
27432: LD_VAR 0 7
27436: ARRAY
27437: PUSH
27438: LD_INT 2
27440: ARRAY
27441: PPUSH
27442: CALL_OW 351
27446: PUSH
27447: LD_VAR 0 12
27451: PUSH
27452: LD_VAR 0 7
27456: ARRAY
27457: PUSH
27458: LD_INT 1
27460: ARRAY
27461: PPUSH
27462: LD_VAR 0 12
27466: PUSH
27467: LD_VAR 0 7
27471: ARRAY
27472: PUSH
27473: LD_INT 2
27475: ARRAY
27476: PPUSH
27477: CALL_OW 488
27481: NOT
27482: OR
27483: PUSH
27484: LD_VAR 0 11
27488: PPUSH
27489: CALL_OW 247
27493: PUSH
27494: LD_INT 3
27496: EQUAL
27497: OR
27498: IFFALSE 27504
// exit ;
27500: POP
27501: POP
27502: GO 27889
// if not tmp then
27504: LD_VAR 0 11
27508: NOT
27509: IFFALSE 27513
// continue ;
27511: GO 27369
// result := true ;
27513: LD_ADDR_VAR 0 6
27517: PUSH
27518: LD_INT 1
27520: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27521: LD_ADDR_VAR 0 15
27525: PUSH
27526: LD_INT 22
27528: PUSH
27529: LD_VAR 0 11
27533: PPUSH
27534: CALL_OW 255
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 2
27545: PUSH
27546: LD_INT 30
27548: PUSH
27549: LD_INT 0
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: PUSH
27556: LD_INT 30
27558: PUSH
27559: LD_INT 1
27561: PUSH
27562: EMPTY
27563: LIST
27564: LIST
27565: PUSH
27566: EMPTY
27567: LIST
27568: LIST
27569: LIST
27570: PUSH
27571: EMPTY
27572: LIST
27573: LIST
27574: PPUSH
27575: CALL_OW 69
27579: ST_TO_ADDR
// if dep then
27580: LD_VAR 0 15
27584: IFFALSE 27720
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27586: LD_ADDR_VAR 0 14
27590: PUSH
27591: LD_VAR 0 15
27595: PUSH
27596: LD_INT 1
27598: ARRAY
27599: PPUSH
27600: CALL_OW 250
27604: PPUSH
27605: LD_VAR 0 15
27609: PUSH
27610: LD_INT 1
27612: ARRAY
27613: PPUSH
27614: CALL_OW 254
27618: PPUSH
27619: LD_INT 5
27621: PPUSH
27622: CALL_OW 272
27626: PUSH
27627: LD_VAR 0 15
27631: PUSH
27632: LD_INT 1
27634: ARRAY
27635: PPUSH
27636: CALL_OW 251
27640: PPUSH
27641: LD_VAR 0 15
27645: PUSH
27646: LD_INT 1
27648: ARRAY
27649: PPUSH
27650: CALL_OW 254
27654: PPUSH
27655: LD_INT 5
27657: PPUSH
27658: CALL_OW 273
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27667: LD_VAR 0 14
27671: PUSH
27672: LD_INT 1
27674: ARRAY
27675: PPUSH
27676: LD_VAR 0 14
27680: PUSH
27681: LD_INT 2
27683: ARRAY
27684: PPUSH
27685: CALL_OW 488
27689: IFFALSE 27720
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27691: LD_VAR 0 11
27695: PPUSH
27696: LD_VAR 0 14
27700: PUSH
27701: LD_INT 1
27703: ARRAY
27704: PPUSH
27705: LD_VAR 0 14
27709: PUSH
27710: LD_INT 2
27712: ARRAY
27713: PPUSH
27714: CALL_OW 111
// continue ;
27718: GO 27369
// end ; end ; r := GetDir ( tmp ) ;
27720: LD_ADDR_VAR 0 13
27724: PUSH
27725: LD_VAR 0 11
27729: PPUSH
27730: CALL_OW 254
27734: ST_TO_ADDR
// if r = 5 then
27735: LD_VAR 0 13
27739: PUSH
27740: LD_INT 5
27742: EQUAL
27743: IFFALSE 27753
// r := 0 ;
27745: LD_ADDR_VAR 0 13
27749: PUSH
27750: LD_INT 0
27752: ST_TO_ADDR
// for j = r to 5 do
27753: LD_ADDR_VAR 0 8
27757: PUSH
27758: DOUBLE
27759: LD_VAR 0 13
27763: DEC
27764: ST_TO_ADDR
27765: LD_INT 5
27767: PUSH
27768: FOR_TO
27769: IFFALSE 27883
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27771: LD_ADDR_VAR 0 9
27775: PUSH
27776: LD_VAR 0 11
27780: PPUSH
27781: CALL_OW 250
27785: PPUSH
27786: LD_VAR 0 8
27790: PPUSH
27791: LD_INT 2
27793: PPUSH
27794: CALL_OW 272
27798: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27799: LD_ADDR_VAR 0 10
27803: PUSH
27804: LD_VAR 0 11
27808: PPUSH
27809: CALL_OW 251
27813: PPUSH
27814: LD_VAR 0 8
27818: PPUSH
27819: LD_INT 2
27821: PPUSH
27822: CALL_OW 273
27826: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27827: LD_VAR 0 9
27831: PPUSH
27832: LD_VAR 0 10
27836: PPUSH
27837: CALL_OW 488
27841: PUSH
27842: LD_VAR 0 9
27846: PPUSH
27847: LD_VAR 0 10
27851: PPUSH
27852: CALL_OW 428
27856: NOT
27857: AND
27858: IFFALSE 27881
// begin ComMoveXY ( tmp , _x , _y ) ;
27860: LD_VAR 0 11
27864: PPUSH
27865: LD_VAR 0 9
27869: PPUSH
27870: LD_VAR 0 10
27874: PPUSH
27875: CALL_OW 111
// break ;
27879: GO 27883
// end ; end ;
27881: GO 27768
27883: POP
27884: POP
// end ;
27885: GO 27369
27887: POP
27888: POP
// end ;
27889: LD_VAR 0 6
27893: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27894: LD_INT 0
27896: PPUSH
27897: PPUSH
27898: PPUSH
27899: PPUSH
27900: PPUSH
27901: PPUSH
27902: PPUSH
27903: PPUSH
27904: PPUSH
27905: PPUSH
// result := false ;
27906: LD_ADDR_VAR 0 6
27910: PUSH
27911: LD_INT 0
27913: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27914: LD_VAR 0 1
27918: NOT
27919: PUSH
27920: LD_VAR 0 1
27924: PPUSH
27925: CALL_OW 266
27929: PUSH
27930: LD_INT 0
27932: PUSH
27933: LD_INT 1
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: IN
27940: NOT
27941: OR
27942: PUSH
27943: LD_VAR 0 2
27947: NOT
27948: OR
27949: PUSH
27950: LD_VAR 0 5
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: LD_INT 1
27960: PUSH
27961: LD_INT 2
27963: PUSH
27964: LD_INT 3
27966: PUSH
27967: LD_INT 4
27969: PUSH
27970: LD_INT 5
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: LIST
27980: IN
27981: NOT
27982: OR
27983: PUSH
27984: LD_VAR 0 3
27988: PPUSH
27989: LD_VAR 0 4
27993: PPUSH
27994: CALL_OW 488
27998: NOT
27999: OR
28000: IFFALSE 28004
// exit ;
28002: GO 28721
// pom := GetBase ( bdepot ) ;
28004: LD_ADDR_VAR 0 10
28008: PUSH
28009: LD_VAR 0 1
28013: PPUSH
28014: CALL_OW 274
28018: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
28019: LD_ADDR_VAR 0 11
28023: PUSH
28024: LD_VAR 0 2
28028: PPUSH
28029: LD_VAR 0 1
28033: PPUSH
28034: CALL_OW 248
28038: PPUSH
28039: CALL_OW 450
28043: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28044: LD_VAR 0 10
28048: PPUSH
28049: LD_INT 1
28051: PPUSH
28052: CALL_OW 275
28056: PUSH
28057: LD_VAR 0 11
28061: PUSH
28062: LD_INT 1
28064: ARRAY
28065: GREATEREQUAL
28066: PUSH
28067: LD_VAR 0 10
28071: PPUSH
28072: LD_INT 2
28074: PPUSH
28075: CALL_OW 275
28079: PUSH
28080: LD_VAR 0 11
28084: PUSH
28085: LD_INT 2
28087: ARRAY
28088: GREATEREQUAL
28089: AND
28090: PUSH
28091: LD_VAR 0 10
28095: PPUSH
28096: LD_INT 3
28098: PPUSH
28099: CALL_OW 275
28103: PUSH
28104: LD_VAR 0 11
28108: PUSH
28109: LD_INT 3
28111: ARRAY
28112: GREATEREQUAL
28113: AND
28114: NOT
28115: IFFALSE 28119
// exit ;
28117: GO 28721
// if GetBType ( bdepot ) = b_depot then
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 266
28128: PUSH
28129: LD_INT 0
28131: EQUAL
28132: IFFALSE 28144
// dist := 28 else
28134: LD_ADDR_VAR 0 14
28138: PUSH
28139: LD_INT 28
28141: ST_TO_ADDR
28142: GO 28152
// dist := 36 ;
28144: LD_ADDR_VAR 0 14
28148: PUSH
28149: LD_INT 36
28151: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
28152: LD_VAR 0 1
28156: PPUSH
28157: LD_VAR 0 3
28161: PPUSH
28162: LD_VAR 0 4
28166: PPUSH
28167: CALL_OW 297
28171: PUSH
28172: LD_VAR 0 14
28176: GREATER
28177: IFFALSE 28181
// exit ;
28179: GO 28721
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
28181: LD_ADDR_VAR 0 12
28185: PUSH
28186: LD_VAR 0 2
28190: PPUSH
28191: LD_VAR 0 3
28195: PPUSH
28196: LD_VAR 0 4
28200: PPUSH
28201: LD_VAR 0 5
28205: PPUSH
28206: LD_VAR 0 1
28210: PPUSH
28211: CALL_OW 248
28215: PPUSH
28216: LD_INT 0
28218: PPUSH
28219: CALL 28726 0 6
28223: ST_TO_ADDR
// if not hexes then
28224: LD_VAR 0 12
28228: NOT
28229: IFFALSE 28233
// exit ;
28231: GO 28721
// hex := GetHexInfo ( x , y ) ;
28233: LD_ADDR_VAR 0 15
28237: PUSH
28238: LD_VAR 0 3
28242: PPUSH
28243: LD_VAR 0 4
28247: PPUSH
28248: CALL_OW 546
28252: ST_TO_ADDR
// if hex [ 1 ] then
28253: LD_VAR 0 15
28257: PUSH
28258: LD_INT 1
28260: ARRAY
28261: IFFALSE 28265
// exit ;
28263: GO 28721
// height := hex [ 2 ] ;
28265: LD_ADDR_VAR 0 13
28269: PUSH
28270: LD_VAR 0 15
28274: PUSH
28275: LD_INT 2
28277: ARRAY
28278: ST_TO_ADDR
// for i = 1 to hexes do
28279: LD_ADDR_VAR 0 7
28283: PUSH
28284: DOUBLE
28285: LD_INT 1
28287: DEC
28288: ST_TO_ADDR
28289: LD_VAR 0 12
28293: PUSH
28294: FOR_TO
28295: IFFALSE 28625
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28297: LD_VAR 0 12
28301: PUSH
28302: LD_VAR 0 7
28306: ARRAY
28307: PUSH
28308: LD_INT 1
28310: ARRAY
28311: PPUSH
28312: LD_VAR 0 12
28316: PUSH
28317: LD_VAR 0 7
28321: ARRAY
28322: PUSH
28323: LD_INT 2
28325: ARRAY
28326: PPUSH
28327: CALL_OW 488
28331: NOT
28332: PUSH
28333: LD_VAR 0 12
28337: PUSH
28338: LD_VAR 0 7
28342: ARRAY
28343: PUSH
28344: LD_INT 1
28346: ARRAY
28347: PPUSH
28348: LD_VAR 0 12
28352: PUSH
28353: LD_VAR 0 7
28357: ARRAY
28358: PUSH
28359: LD_INT 2
28361: ARRAY
28362: PPUSH
28363: CALL_OW 428
28367: PUSH
28368: LD_INT 0
28370: GREATER
28371: OR
28372: PUSH
28373: LD_VAR 0 12
28377: PUSH
28378: LD_VAR 0 7
28382: ARRAY
28383: PUSH
28384: LD_INT 1
28386: ARRAY
28387: PPUSH
28388: LD_VAR 0 12
28392: PUSH
28393: LD_VAR 0 7
28397: ARRAY
28398: PUSH
28399: LD_INT 2
28401: ARRAY
28402: PPUSH
28403: CALL_OW 351
28407: OR
28408: IFFALSE 28414
// exit ;
28410: POP
28411: POP
28412: GO 28721
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28414: LD_ADDR_VAR 0 8
28418: PUSH
28419: LD_VAR 0 12
28423: PUSH
28424: LD_VAR 0 7
28428: ARRAY
28429: PUSH
28430: LD_INT 1
28432: ARRAY
28433: PPUSH
28434: LD_VAR 0 12
28438: PUSH
28439: LD_VAR 0 7
28443: ARRAY
28444: PUSH
28445: LD_INT 2
28447: ARRAY
28448: PPUSH
28449: CALL_OW 546
28453: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28454: LD_VAR 0 8
28458: PUSH
28459: LD_INT 1
28461: ARRAY
28462: PUSH
28463: LD_VAR 0 8
28467: PUSH
28468: LD_INT 2
28470: ARRAY
28471: PUSH
28472: LD_VAR 0 13
28476: PUSH
28477: LD_INT 2
28479: PLUS
28480: GREATER
28481: OR
28482: PUSH
28483: LD_VAR 0 8
28487: PUSH
28488: LD_INT 2
28490: ARRAY
28491: PUSH
28492: LD_VAR 0 13
28496: PUSH
28497: LD_INT 2
28499: MINUS
28500: LESS
28501: OR
28502: PUSH
28503: LD_VAR 0 8
28507: PUSH
28508: LD_INT 3
28510: ARRAY
28511: PUSH
28512: LD_INT 0
28514: PUSH
28515: LD_INT 8
28517: PUSH
28518: LD_INT 9
28520: PUSH
28521: LD_INT 10
28523: PUSH
28524: LD_INT 11
28526: PUSH
28527: LD_INT 12
28529: PUSH
28530: LD_INT 13
28532: PUSH
28533: LD_INT 16
28535: PUSH
28536: LD_INT 17
28538: PUSH
28539: LD_INT 18
28541: PUSH
28542: LD_INT 19
28544: PUSH
28545: LD_INT 20
28547: PUSH
28548: LD_INT 21
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: LIST
28555: LIST
28556: LIST
28557: LIST
28558: LIST
28559: LIST
28560: LIST
28561: LIST
28562: LIST
28563: LIST
28564: LIST
28565: IN
28566: NOT
28567: OR
28568: PUSH
28569: LD_VAR 0 8
28573: PUSH
28574: LD_INT 5
28576: ARRAY
28577: NOT
28578: OR
28579: PUSH
28580: LD_VAR 0 8
28584: PUSH
28585: LD_INT 6
28587: ARRAY
28588: PUSH
28589: LD_INT 1
28591: PUSH
28592: LD_INT 2
28594: PUSH
28595: LD_INT 7
28597: PUSH
28598: LD_INT 9
28600: PUSH
28601: LD_INT 10
28603: PUSH
28604: LD_INT 11
28606: PUSH
28607: EMPTY
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: LIST
28614: IN
28615: NOT
28616: OR
28617: IFFALSE 28623
// exit ;
28619: POP
28620: POP
28621: GO 28721
// end ;
28623: GO 28294
28625: POP
28626: POP
// side := GetSide ( bdepot ) ;
28627: LD_ADDR_VAR 0 9
28631: PUSH
28632: LD_VAR 0 1
28636: PPUSH
28637: CALL_OW 255
28641: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28642: LD_VAR 0 9
28646: PPUSH
28647: LD_VAR 0 3
28651: PPUSH
28652: LD_VAR 0 4
28656: PPUSH
28657: LD_INT 20
28659: PPUSH
28660: CALL 21393 0 4
28664: PUSH
28665: LD_INT 4
28667: ARRAY
28668: IFFALSE 28672
// exit ;
28670: GO 28721
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28672: LD_VAR 0 2
28676: PUSH
28677: LD_INT 29
28679: PUSH
28680: LD_INT 30
28682: PUSH
28683: EMPTY
28684: LIST
28685: LIST
28686: IN
28687: PUSH
28688: LD_VAR 0 3
28692: PPUSH
28693: LD_VAR 0 4
28697: PPUSH
28698: LD_VAR 0 9
28702: PPUSH
28703: CALL_OW 440
28707: NOT
28708: AND
28709: IFFALSE 28713
// exit ;
28711: GO 28721
// result := true ;
28713: LD_ADDR_VAR 0 6
28717: PUSH
28718: LD_INT 1
28720: ST_TO_ADDR
// end ;
28721: LD_VAR 0 6
28725: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28726: LD_INT 0
28728: PPUSH
28729: PPUSH
28730: PPUSH
28731: PPUSH
28732: PPUSH
28733: PPUSH
28734: PPUSH
28735: PPUSH
28736: PPUSH
28737: PPUSH
28738: PPUSH
28739: PPUSH
28740: PPUSH
28741: PPUSH
28742: PPUSH
28743: PPUSH
28744: PPUSH
28745: PPUSH
28746: PPUSH
28747: PPUSH
28748: PPUSH
28749: PPUSH
28750: PPUSH
28751: PPUSH
28752: PPUSH
28753: PPUSH
28754: PPUSH
28755: PPUSH
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
28760: PPUSH
28761: PPUSH
28762: PPUSH
28763: PPUSH
28764: PPUSH
28765: PPUSH
28766: PPUSH
28767: PPUSH
28768: PPUSH
28769: PPUSH
28770: PPUSH
28771: PPUSH
28772: PPUSH
28773: PPUSH
28774: PPUSH
28775: PPUSH
28776: PPUSH
28777: PPUSH
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
28782: PPUSH
28783: PPUSH
28784: PPUSH
28785: PPUSH
// result = [ ] ;
28786: LD_ADDR_VAR 0 7
28790: PUSH
28791: EMPTY
28792: ST_TO_ADDR
// temp_list = [ ] ;
28793: LD_ADDR_VAR 0 9
28797: PUSH
28798: EMPTY
28799: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28800: LD_VAR 0 4
28804: PUSH
28805: LD_INT 0
28807: PUSH
28808: LD_INT 1
28810: PUSH
28811: LD_INT 2
28813: PUSH
28814: LD_INT 3
28816: PUSH
28817: LD_INT 4
28819: PUSH
28820: LD_INT 5
28822: PUSH
28823: EMPTY
28824: LIST
28825: LIST
28826: LIST
28827: LIST
28828: LIST
28829: LIST
28830: IN
28831: NOT
28832: PUSH
28833: LD_VAR 0 1
28837: PUSH
28838: LD_INT 0
28840: PUSH
28841: LD_INT 1
28843: PUSH
28844: EMPTY
28845: LIST
28846: LIST
28847: IN
28848: PUSH
28849: LD_VAR 0 5
28853: PUSH
28854: LD_INT 1
28856: PUSH
28857: LD_INT 2
28859: PUSH
28860: LD_INT 3
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: LIST
28867: IN
28868: NOT
28869: AND
28870: OR
28871: IFFALSE 28875
// exit ;
28873: GO 47260
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28875: LD_VAR 0 1
28879: PUSH
28880: LD_INT 6
28882: PUSH
28883: LD_INT 7
28885: PUSH
28886: LD_INT 8
28888: PUSH
28889: LD_INT 13
28891: PUSH
28892: LD_INT 12
28894: PUSH
28895: LD_INT 15
28897: PUSH
28898: LD_INT 11
28900: PUSH
28901: LD_INT 14
28903: PUSH
28904: LD_INT 10
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: LIST
28911: LIST
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: IN
28918: IFFALSE 28928
// btype = b_lab ;
28920: LD_ADDR_VAR 0 1
28924: PUSH
28925: LD_INT 6
28927: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28928: LD_VAR 0 6
28932: PUSH
28933: LD_INT 0
28935: PUSH
28936: LD_INT 1
28938: PUSH
28939: LD_INT 2
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: LIST
28946: IN
28947: NOT
28948: PUSH
28949: LD_VAR 0 1
28953: PUSH
28954: LD_INT 0
28956: PUSH
28957: LD_INT 1
28959: PUSH
28960: LD_INT 2
28962: PUSH
28963: LD_INT 3
28965: PUSH
28966: LD_INT 6
28968: PUSH
28969: LD_INT 36
28971: PUSH
28972: LD_INT 4
28974: PUSH
28975: LD_INT 5
28977: PUSH
28978: LD_INT 31
28980: PUSH
28981: LD_INT 32
28983: PUSH
28984: LD_INT 33
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: LIST
28999: IN
29000: NOT
29001: PUSH
29002: LD_VAR 0 6
29006: PUSH
29007: LD_INT 1
29009: EQUAL
29010: AND
29011: OR
29012: PUSH
29013: LD_VAR 0 1
29017: PUSH
29018: LD_INT 2
29020: PUSH
29021: LD_INT 3
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: IN
29028: NOT
29029: PUSH
29030: LD_VAR 0 6
29034: PUSH
29035: LD_INT 2
29037: EQUAL
29038: AND
29039: OR
29040: IFFALSE 29050
// mode = 0 ;
29042: LD_ADDR_VAR 0 6
29046: PUSH
29047: LD_INT 0
29049: ST_TO_ADDR
// case mode of 0 :
29050: LD_VAR 0 6
29054: PUSH
29055: LD_INT 0
29057: DOUBLE
29058: EQUAL
29059: IFTRUE 29063
29061: GO 40516
29063: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29064: LD_ADDR_VAR 0 11
29068: PUSH
29069: LD_INT 0
29071: PUSH
29072: LD_INT 0
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 0
29081: PUSH
29082: LD_INT 1
29084: NEG
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 1
29092: PUSH
29093: LD_INT 0
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: LD_INT 1
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: LD_INT 1
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: NEG
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: NEG
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 1
29145: NEG
29146: PUSH
29147: LD_INT 2
29149: NEG
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: LD_INT 2
29160: NEG
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: PUSH
29166: LD_INT 1
29168: PUSH
29169: LD_INT 1
29171: NEG
29172: PUSH
29173: EMPTY
29174: LIST
29175: LIST
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: LD_INT 2
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: PUSH
29187: LD_INT 0
29189: PUSH
29190: LD_INT 2
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 1
29199: NEG
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: LD_INT 1
29210: PUSH
29211: LD_INT 3
29213: PUSH
29214: EMPTY
29215: LIST
29216: LIST
29217: PUSH
29218: LD_INT 0
29220: PUSH
29221: LD_INT 3
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 1
29230: NEG
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: PUSH
29239: EMPTY
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29257: LD_ADDR_VAR 0 12
29261: PUSH
29262: LD_INT 0
29264: PUSH
29265: LD_INT 0
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 1
29277: NEG
29278: PUSH
29279: EMPTY
29280: LIST
29281: LIST
29282: PUSH
29283: LD_INT 1
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: PUSH
29296: LD_INT 1
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 0
29305: PUSH
29306: LD_INT 1
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 1
29315: NEG
29316: PUSH
29317: LD_INT 0
29319: PUSH
29320: EMPTY
29321: LIST
29322: LIST
29323: PUSH
29324: LD_INT 1
29326: NEG
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: LD_INT 1
29341: NEG
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: PUSH
29350: LD_INT 0
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: LD_INT 2
29359: PUSH
29360: LD_INT 1
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 1
29369: NEG
29370: PUSH
29371: LD_INT 1
29373: PUSH
29374: EMPTY
29375: LIST
29376: LIST
29377: PUSH
29378: LD_INT 2
29380: NEG
29381: PUSH
29382: LD_INT 0
29384: PUSH
29385: EMPTY
29386: LIST
29387: LIST
29388: PUSH
29389: LD_INT 2
29391: NEG
29392: PUSH
29393: LD_INT 1
29395: NEG
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 2
29403: NEG
29404: PUSH
29405: LD_INT 1
29407: PUSH
29408: EMPTY
29409: LIST
29410: LIST
29411: PUSH
29412: LD_INT 3
29414: NEG
29415: PUSH
29416: LD_INT 0
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: PUSH
29423: LD_INT 3
29425: NEG
29426: PUSH
29427: LD_INT 1
29429: NEG
29430: PUSH
29431: EMPTY
29432: LIST
29433: LIST
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29453: LD_ADDR_VAR 0 13
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 2
29546: PUSH
29547: LD_INT 1
29549: PUSH
29550: EMPTY
29551: LIST
29552: LIST
29553: PUSH
29554: LD_INT 2
29556: PUSH
29557: LD_INT 2
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 1
29566: PUSH
29567: LD_INT 2
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 2
29576: NEG
29577: PUSH
29578: LD_INT 1
29580: NEG
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: NEG
29589: PUSH
29590: LD_INT 2
29592: NEG
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 2
29600: NEG
29601: PUSH
29602: LD_INT 3
29604: NEG
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: LD_INT 3
29612: NEG
29613: PUSH
29614: LD_INT 2
29616: NEG
29617: PUSH
29618: EMPTY
29619: LIST
29620: LIST
29621: PUSH
29622: LD_INT 3
29624: NEG
29625: PUSH
29626: LD_INT 3
29628: NEG
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: LIST
29638: LIST
29639: LIST
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29652: LD_ADDR_VAR 0 14
29656: PUSH
29657: LD_INT 0
29659: PUSH
29660: LD_INT 0
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: PUSH
29691: LD_INT 1
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: NEG
29722: PUSH
29723: LD_INT 1
29725: NEG
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 1
29733: NEG
29734: PUSH
29735: LD_INT 2
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: LD_INT 2
29748: NEG
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 1
29756: PUSH
29757: LD_INT 1
29759: NEG
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 1
29767: PUSH
29768: LD_INT 2
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 0
29777: PUSH
29778: LD_INT 2
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: NEG
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: NEG
29799: PUSH
29800: LD_INT 3
29802: NEG
29803: PUSH
29804: EMPTY
29805: LIST
29806: LIST
29807: PUSH
29808: LD_INT 0
29810: PUSH
29811: LD_INT 3
29813: NEG
29814: PUSH
29815: EMPTY
29816: LIST
29817: LIST
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: LD_INT 2
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: LIST
29834: LIST
29835: LIST
29836: LIST
29837: LIST
29838: LIST
29839: LIST
29840: LIST
29841: LIST
29842: LIST
29843: LIST
29844: LIST
29845: LIST
29846: LIST
29847: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29848: LD_ADDR_VAR 0 15
29852: PUSH
29853: LD_INT 0
29855: PUSH
29856: LD_INT 0
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 0
29865: PUSH
29866: LD_INT 1
29868: NEG
29869: PUSH
29870: EMPTY
29871: LIST
29872: LIST
29873: PUSH
29874: LD_INT 1
29876: PUSH
29877: LD_INT 0
29879: PUSH
29880: EMPTY
29881: LIST
29882: LIST
29883: PUSH
29884: LD_INT 1
29886: PUSH
29887: LD_INT 1
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 0
29896: PUSH
29897: LD_INT 1
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: NEG
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 1
29917: NEG
29918: PUSH
29919: LD_INT 1
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: LD_INT 1
29929: PUSH
29930: LD_INT 1
29932: NEG
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: PUSH
29941: LD_INT 0
29943: PUSH
29944: EMPTY
29945: LIST
29946: LIST
29947: PUSH
29948: LD_INT 2
29950: PUSH
29951: LD_INT 1
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 1
29960: NEG
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 2
29971: NEG
29972: PUSH
29973: LD_INT 0
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 2
29982: NEG
29983: PUSH
29984: LD_INT 1
29986: NEG
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 2
29994: PUSH
29995: LD_INT 1
29997: NEG
29998: PUSH
29999: EMPTY
30000: LIST
30001: LIST
30002: PUSH
30003: LD_INT 3
30005: PUSH
30006: LD_INT 0
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: PUSH
30013: LD_INT 3
30015: PUSH
30016: LD_INT 1
30018: PUSH
30019: EMPTY
30020: LIST
30021: LIST
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: LIST
30027: LIST
30028: LIST
30029: LIST
30030: LIST
30031: LIST
30032: LIST
30033: LIST
30034: LIST
30035: LIST
30036: LIST
30037: LIST
30038: LIST
30039: LIST
30040: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30041: LD_ADDR_VAR 0 16
30045: PUSH
30046: LD_INT 0
30048: PUSH
30049: LD_INT 0
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 0
30058: PUSH
30059: LD_INT 1
30061: NEG
30062: PUSH
30063: EMPTY
30064: LIST
30065: LIST
30066: PUSH
30067: LD_INT 1
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PUSH
30077: LD_INT 1
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 0
30089: PUSH
30090: LD_INT 1
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 1
30099: NEG
30100: PUSH
30101: LD_INT 0
30103: PUSH
30104: EMPTY
30105: LIST
30106: LIST
30107: PUSH
30108: LD_INT 1
30110: NEG
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 1
30122: NEG
30123: PUSH
30124: LD_INT 2
30126: NEG
30127: PUSH
30128: EMPTY
30129: LIST
30130: LIST
30131: PUSH
30132: LD_INT 2
30134: PUSH
30135: LD_INT 1
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 2
30144: PUSH
30145: LD_INT 2
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 1
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 2
30164: NEG
30165: PUSH
30166: LD_INT 1
30168: NEG
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: LD_INT 2
30176: NEG
30177: PUSH
30178: LD_INT 2
30180: NEG
30181: PUSH
30182: EMPTY
30183: LIST
30184: LIST
30185: PUSH
30186: LD_INT 3
30188: PUSH
30189: LD_INT 2
30191: PUSH
30192: EMPTY
30193: LIST
30194: LIST
30195: PUSH
30196: LD_INT 3
30198: PUSH
30199: LD_INT 3
30201: PUSH
30202: EMPTY
30203: LIST
30204: LIST
30205: PUSH
30206: LD_INT 2
30208: PUSH
30209: LD_INT 3
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30234: LD_ADDR_VAR 0 17
30238: PUSH
30239: LD_INT 0
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 0
30251: PUSH
30252: LD_INT 1
30254: NEG
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 1
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PUSH
30280: LD_INT 0
30282: PUSH
30283: LD_INT 1
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 1
30292: NEG
30293: PUSH
30294: LD_INT 0
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 1
30303: NEG
30304: PUSH
30305: LD_INT 1
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 1
30315: NEG
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 0
30327: PUSH
30328: LD_INT 2
30330: NEG
30331: PUSH
30332: EMPTY
30333: LIST
30334: LIST
30335: PUSH
30336: LD_INT 1
30338: PUSH
30339: LD_INT 1
30341: NEG
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 2
30349: PUSH
30350: LD_INT 0
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: LD_INT 2
30359: PUSH
30360: LD_INT 1
30362: PUSH
30363: EMPTY
30364: LIST
30365: LIST
30366: PUSH
30367: LD_INT 2
30369: PUSH
30370: LD_INT 2
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 1
30379: PUSH
30380: LD_INT 2
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 0
30389: PUSH
30390: LD_INT 2
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 1
30399: NEG
30400: PUSH
30401: LD_INT 1
30403: PUSH
30404: EMPTY
30405: LIST
30406: LIST
30407: PUSH
30408: LD_INT 2
30410: NEG
30411: PUSH
30412: LD_INT 0
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 2
30421: NEG
30422: PUSH
30423: LD_INT 1
30425: NEG
30426: PUSH
30427: EMPTY
30428: LIST
30429: LIST
30430: PUSH
30431: LD_INT 2
30433: NEG
30434: PUSH
30435: LD_INT 2
30437: NEG
30438: PUSH
30439: EMPTY
30440: LIST
30441: LIST
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: LIST
30447: LIST
30448: LIST
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30464: LD_ADDR_VAR 0 18
30468: PUSH
30469: LD_INT 0
30471: PUSH
30472: LD_INT 0
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: LD_INT 1
30484: NEG
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 1
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 1
30502: PUSH
30503: LD_INT 1
30505: PUSH
30506: EMPTY
30507: LIST
30508: LIST
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: LD_INT 1
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: PUSH
30520: LD_INT 1
30522: NEG
30523: PUSH
30524: LD_INT 0
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 1
30533: NEG
30534: PUSH
30535: LD_INT 1
30537: NEG
30538: PUSH
30539: EMPTY
30540: LIST
30541: LIST
30542: PUSH
30543: LD_INT 1
30545: NEG
30546: PUSH
30547: LD_INT 2
30549: NEG
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 0
30557: PUSH
30558: LD_INT 2
30560: NEG
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: LD_INT 1
30571: NEG
30572: PUSH
30573: EMPTY
30574: LIST
30575: LIST
30576: PUSH
30577: LD_INT 2
30579: PUSH
30580: LD_INT 0
30582: PUSH
30583: EMPTY
30584: LIST
30585: LIST
30586: PUSH
30587: LD_INT 2
30589: PUSH
30590: LD_INT 1
30592: PUSH
30593: EMPTY
30594: LIST
30595: LIST
30596: PUSH
30597: LD_INT 2
30599: PUSH
30600: LD_INT 2
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 1
30609: PUSH
30610: LD_INT 2
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 0
30619: PUSH
30620: LD_INT 2
30622: PUSH
30623: EMPTY
30624: LIST
30625: LIST
30626: PUSH
30627: LD_INT 1
30629: NEG
30630: PUSH
30631: LD_INT 1
30633: PUSH
30634: EMPTY
30635: LIST
30636: LIST
30637: PUSH
30638: LD_INT 2
30640: NEG
30641: PUSH
30642: LD_INT 0
30644: PUSH
30645: EMPTY
30646: LIST
30647: LIST
30648: PUSH
30649: LD_INT 2
30651: NEG
30652: PUSH
30653: LD_INT 1
30655: NEG
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: LD_INT 2
30663: NEG
30664: PUSH
30665: LD_INT 2
30667: NEG
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: EMPTY
30674: LIST
30675: LIST
30676: LIST
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30694: LD_ADDR_VAR 0 19
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 0
30711: PUSH
30712: LD_INT 1
30714: NEG
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 1
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: PUSH
30740: LD_INT 0
30742: PUSH
30743: LD_INT 1
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: NEG
30753: PUSH
30754: LD_INT 0
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 1
30763: NEG
30764: PUSH
30765: LD_INT 1
30767: NEG
30768: PUSH
30769: EMPTY
30770: LIST
30771: LIST
30772: PUSH
30773: LD_INT 1
30775: NEG
30776: PUSH
30777: LD_INT 2
30779: NEG
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: LD_INT 2
30790: NEG
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 1
30801: NEG
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: PUSH
30807: LD_INT 2
30809: PUSH
30810: LD_INT 0
30812: PUSH
30813: EMPTY
30814: LIST
30815: LIST
30816: PUSH
30817: LD_INT 2
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 2
30829: PUSH
30830: LD_INT 2
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 1
30839: PUSH
30840: LD_INT 2
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 0
30849: PUSH
30850: LD_INT 2
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 1
30859: NEG
30860: PUSH
30861: LD_INT 1
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PUSH
30868: LD_INT 2
30870: NEG
30871: PUSH
30872: LD_INT 0
30874: PUSH
30875: EMPTY
30876: LIST
30877: LIST
30878: PUSH
30879: LD_INT 2
30881: NEG
30882: PUSH
30883: LD_INT 1
30885: NEG
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 2
30893: NEG
30894: PUSH
30895: LD_INT 2
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: EMPTY
30904: LIST
30905: LIST
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30924: LD_ADDR_VAR 0 20
30928: PUSH
30929: LD_INT 0
30931: PUSH
30932: LD_INT 0
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 0
30941: PUSH
30942: LD_INT 1
30944: NEG
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 1
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 1
30962: PUSH
30963: LD_INT 1
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: PUSH
30970: LD_INT 0
30972: PUSH
30973: LD_INT 1
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 1
30982: NEG
30983: PUSH
30984: LD_INT 0
30986: PUSH
30987: EMPTY
30988: LIST
30989: LIST
30990: PUSH
30991: LD_INT 1
30993: NEG
30994: PUSH
30995: LD_INT 1
30997: NEG
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: LD_INT 1
31005: NEG
31006: PUSH
31007: LD_INT 2
31009: NEG
31010: PUSH
31011: EMPTY
31012: LIST
31013: LIST
31014: PUSH
31015: LD_INT 0
31017: PUSH
31018: LD_INT 2
31020: NEG
31021: PUSH
31022: EMPTY
31023: LIST
31024: LIST
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: LD_INT 1
31031: NEG
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: PUSH
31037: LD_INT 2
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 2
31049: PUSH
31050: LD_INT 1
31052: PUSH
31053: EMPTY
31054: LIST
31055: LIST
31056: PUSH
31057: LD_INT 2
31059: PUSH
31060: LD_INT 2
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 1
31069: PUSH
31070: LD_INT 2
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 0
31079: PUSH
31080: LD_INT 2
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 1
31089: NEG
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: EMPTY
31095: LIST
31096: LIST
31097: PUSH
31098: LD_INT 2
31100: NEG
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: EMPTY
31106: LIST
31107: LIST
31108: PUSH
31109: LD_INT 2
31111: NEG
31112: PUSH
31113: LD_INT 1
31115: NEG
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 2
31123: NEG
31124: PUSH
31125: LD_INT 2
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: EMPTY
31134: LIST
31135: LIST
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31154: LD_ADDR_VAR 0 21
31158: PUSH
31159: LD_INT 0
31161: PUSH
31162: LD_INT 0
31164: PUSH
31165: EMPTY
31166: LIST
31167: LIST
31168: PUSH
31169: LD_INT 0
31171: PUSH
31172: LD_INT 1
31174: NEG
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 1
31182: PUSH
31183: LD_INT 0
31185: PUSH
31186: EMPTY
31187: LIST
31188: LIST
31189: PUSH
31190: LD_INT 1
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: PUSH
31200: LD_INT 0
31202: PUSH
31203: LD_INT 1
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 1
31212: NEG
31213: PUSH
31214: LD_INT 0
31216: PUSH
31217: EMPTY
31218: LIST
31219: LIST
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: LD_INT 1
31227: NEG
31228: PUSH
31229: EMPTY
31230: LIST
31231: LIST
31232: PUSH
31233: LD_INT 1
31235: NEG
31236: PUSH
31237: LD_INT 2
31239: NEG
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PUSH
31245: LD_INT 0
31247: PUSH
31248: LD_INT 2
31250: NEG
31251: PUSH
31252: EMPTY
31253: LIST
31254: LIST
31255: PUSH
31256: LD_INT 1
31258: PUSH
31259: LD_INT 1
31261: NEG
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: PUSH
31267: LD_INT 2
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 2
31279: PUSH
31280: LD_INT 1
31282: PUSH
31283: EMPTY
31284: LIST
31285: LIST
31286: PUSH
31287: LD_INT 2
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 1
31299: PUSH
31300: LD_INT 2
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 0
31309: PUSH
31310: LD_INT 2
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 1
31319: NEG
31320: PUSH
31321: LD_INT 1
31323: PUSH
31324: EMPTY
31325: LIST
31326: LIST
31327: PUSH
31328: LD_INT 2
31330: NEG
31331: PUSH
31332: LD_INT 0
31334: PUSH
31335: EMPTY
31336: LIST
31337: LIST
31338: PUSH
31339: LD_INT 2
31341: NEG
31342: PUSH
31343: LD_INT 1
31345: NEG
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: NEG
31354: PUSH
31355: LD_INT 2
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31384: LD_ADDR_VAR 0 22
31388: PUSH
31389: LD_INT 0
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 0
31401: PUSH
31402: LD_INT 1
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: LD_INT 0
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 1
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: PUSH
31430: LD_INT 0
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: NEG
31443: PUSH
31444: LD_INT 0
31446: PUSH
31447: EMPTY
31448: LIST
31449: LIST
31450: PUSH
31451: LD_INT 1
31453: NEG
31454: PUSH
31455: LD_INT 1
31457: NEG
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 1
31465: NEG
31466: PUSH
31467: LD_INT 2
31469: NEG
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: PUSH
31475: LD_INT 0
31477: PUSH
31478: LD_INT 2
31480: NEG
31481: PUSH
31482: EMPTY
31483: LIST
31484: LIST
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: LD_INT 1
31491: NEG
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: PUSH
31497: LD_INT 2
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 2
31509: PUSH
31510: LD_INT 1
31512: PUSH
31513: EMPTY
31514: LIST
31515: LIST
31516: PUSH
31517: LD_INT 2
31519: PUSH
31520: LD_INT 2
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 1
31529: PUSH
31530: LD_INT 2
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 0
31539: PUSH
31540: LD_INT 2
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 1
31549: NEG
31550: PUSH
31551: LD_INT 1
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 2
31560: NEG
31561: PUSH
31562: LD_INT 0
31564: PUSH
31565: EMPTY
31566: LIST
31567: LIST
31568: PUSH
31569: LD_INT 2
31571: NEG
31572: PUSH
31573: LD_INT 1
31575: NEG
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 2
31583: NEG
31584: PUSH
31585: LD_INT 2
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: EMPTY
31594: LIST
31595: LIST
31596: LIST
31597: LIST
31598: LIST
31599: LIST
31600: LIST
31601: LIST
31602: LIST
31603: LIST
31604: LIST
31605: LIST
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31614: LD_ADDR_VAR 0 23
31618: PUSH
31619: LD_INT 0
31621: PUSH
31622: LD_INT 0
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: PUSH
31629: LD_INT 0
31631: PUSH
31632: LD_INT 1
31634: NEG
31635: PUSH
31636: EMPTY
31637: LIST
31638: LIST
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: LD_INT 0
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 1
31652: PUSH
31653: LD_INT 1
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: LD_INT 0
31662: PUSH
31663: LD_INT 1
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: NEG
31673: PUSH
31674: LD_INT 0
31676: PUSH
31677: EMPTY
31678: LIST
31679: LIST
31680: PUSH
31681: LD_INT 1
31683: NEG
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 1
31695: NEG
31696: PUSH
31697: LD_INT 2
31699: NEG
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: PUSH
31705: LD_INT 0
31707: PUSH
31708: LD_INT 2
31710: NEG
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: LD_INT 1
31721: NEG
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: PUSH
31727: LD_INT 2
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 2
31739: PUSH
31740: LD_INT 1
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 2
31749: PUSH
31750: LD_INT 2
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 1
31759: PUSH
31760: LD_INT 2
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: LD_INT 2
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 1
31779: NEG
31780: PUSH
31781: LD_INT 1
31783: PUSH
31784: EMPTY
31785: LIST
31786: LIST
31787: PUSH
31788: LD_INT 2
31790: NEG
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 2
31801: NEG
31802: PUSH
31803: LD_INT 1
31805: NEG
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 2
31813: NEG
31814: PUSH
31815: LD_INT 2
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 2
31825: NEG
31826: PUSH
31827: LD_INT 3
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 1
31837: NEG
31838: PUSH
31839: LD_INT 3
31841: NEG
31842: PUSH
31843: EMPTY
31844: LIST
31845: LIST
31846: PUSH
31847: LD_INT 1
31849: PUSH
31850: LD_INT 2
31852: NEG
31853: PUSH
31854: EMPTY
31855: LIST
31856: LIST
31857: PUSH
31858: LD_INT 2
31860: PUSH
31861: LD_INT 1
31863: NEG
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PUSH
31869: EMPTY
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: LIST
31881: LIST
31882: LIST
31883: LIST
31884: LIST
31885: LIST
31886: LIST
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31894: LD_ADDR_VAR 0 24
31898: PUSH
31899: LD_INT 0
31901: PUSH
31902: LD_INT 0
31904: PUSH
31905: EMPTY
31906: LIST
31907: LIST
31908: PUSH
31909: LD_INT 0
31911: PUSH
31912: LD_INT 1
31914: NEG
31915: PUSH
31916: EMPTY
31917: LIST
31918: LIST
31919: PUSH
31920: LD_INT 1
31922: PUSH
31923: LD_INT 0
31925: PUSH
31926: EMPTY
31927: LIST
31928: LIST
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: LD_INT 1
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 0
31942: PUSH
31943: LD_INT 1
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 1
31952: NEG
31953: PUSH
31954: LD_INT 0
31956: PUSH
31957: EMPTY
31958: LIST
31959: LIST
31960: PUSH
31961: LD_INT 1
31963: NEG
31964: PUSH
31965: LD_INT 1
31967: NEG
31968: PUSH
31969: EMPTY
31970: LIST
31971: LIST
31972: PUSH
31973: LD_INT 1
31975: NEG
31976: PUSH
31977: LD_INT 2
31979: NEG
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 0
31987: PUSH
31988: LD_INT 2
31990: NEG
31991: PUSH
31992: EMPTY
31993: LIST
31994: LIST
31995: PUSH
31996: LD_INT 1
31998: PUSH
31999: LD_INT 1
32001: NEG
32002: PUSH
32003: EMPTY
32004: LIST
32005: LIST
32006: PUSH
32007: LD_INT 2
32009: PUSH
32010: LD_INT 0
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 2
32019: PUSH
32020: LD_INT 1
32022: PUSH
32023: EMPTY
32024: LIST
32025: LIST
32026: PUSH
32027: LD_INT 2
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 1
32039: PUSH
32040: LD_INT 2
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: LD_INT 2
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 1
32059: NEG
32060: PUSH
32061: LD_INT 1
32063: PUSH
32064: EMPTY
32065: LIST
32066: LIST
32067: PUSH
32068: LD_INT 2
32070: NEG
32071: PUSH
32072: LD_INT 0
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 2
32081: NEG
32082: PUSH
32083: LD_INT 1
32085: NEG
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 2
32093: NEG
32094: PUSH
32095: LD_INT 2
32097: NEG
32098: PUSH
32099: EMPTY
32100: LIST
32101: LIST
32102: PUSH
32103: LD_INT 1
32105: PUSH
32106: LD_INT 2
32108: NEG
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 2
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 3
32127: PUSH
32128: LD_INT 1
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 3
32137: PUSH
32138: LD_INT 2
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: LIST
32161: LIST
32162: LIST
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32170: LD_ADDR_VAR 0 25
32174: PUSH
32175: LD_INT 0
32177: PUSH
32178: LD_INT 0
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: LD_INT 1
32190: NEG
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: PUSH
32196: LD_INT 1
32198: PUSH
32199: LD_INT 0
32201: PUSH
32202: EMPTY
32203: LIST
32204: LIST
32205: PUSH
32206: LD_INT 1
32208: PUSH
32209: LD_INT 1
32211: PUSH
32212: EMPTY
32213: LIST
32214: LIST
32215: PUSH
32216: LD_INT 0
32218: PUSH
32219: LD_INT 1
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 1
32228: NEG
32229: PUSH
32230: LD_INT 0
32232: PUSH
32233: EMPTY
32234: LIST
32235: LIST
32236: PUSH
32237: LD_INT 1
32239: NEG
32240: PUSH
32241: LD_INT 1
32243: NEG
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 1
32251: NEG
32252: PUSH
32253: LD_INT 2
32255: NEG
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 0
32263: PUSH
32264: LD_INT 2
32266: NEG
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 1
32274: PUSH
32275: LD_INT 1
32277: NEG
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 2
32285: PUSH
32286: LD_INT 0
32288: PUSH
32289: EMPTY
32290: LIST
32291: LIST
32292: PUSH
32293: LD_INT 2
32295: PUSH
32296: LD_INT 1
32298: PUSH
32299: EMPTY
32300: LIST
32301: LIST
32302: PUSH
32303: LD_INT 2
32305: PUSH
32306: LD_INT 2
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: LD_INT 2
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 0
32325: PUSH
32326: LD_INT 2
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 1
32335: NEG
32336: PUSH
32337: LD_INT 1
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 2
32346: NEG
32347: PUSH
32348: LD_INT 0
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 2
32357: NEG
32358: PUSH
32359: LD_INT 1
32361: NEG
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 2
32369: NEG
32370: PUSH
32371: LD_INT 2
32373: NEG
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 3
32381: PUSH
32382: LD_INT 1
32384: PUSH
32385: EMPTY
32386: LIST
32387: LIST
32388: PUSH
32389: LD_INT 3
32391: PUSH
32392: LD_INT 2
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 2
32401: PUSH
32402: LD_INT 3
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 1
32411: PUSH
32412: LD_INT 3
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: LIST
32440: LIST
32441: LIST
32442: LIST
32443: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32444: LD_ADDR_VAR 0 26
32448: PUSH
32449: LD_INT 0
32451: PUSH
32452: LD_INT 0
32454: PUSH
32455: EMPTY
32456: LIST
32457: LIST
32458: PUSH
32459: LD_INT 0
32461: PUSH
32462: LD_INT 1
32464: NEG
32465: PUSH
32466: EMPTY
32467: LIST
32468: LIST
32469: PUSH
32470: LD_INT 1
32472: PUSH
32473: LD_INT 0
32475: PUSH
32476: EMPTY
32477: LIST
32478: LIST
32479: PUSH
32480: LD_INT 1
32482: PUSH
32483: LD_INT 1
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PUSH
32490: LD_INT 0
32492: PUSH
32493: LD_INT 1
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: NEG
32503: PUSH
32504: LD_INT 0
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: LD_INT 1
32517: NEG
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 1
32525: NEG
32526: PUSH
32527: LD_INT 2
32529: NEG
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 0
32537: PUSH
32538: LD_INT 2
32540: NEG
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 1
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: EMPTY
32554: LIST
32555: LIST
32556: PUSH
32557: LD_INT 2
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: LD_INT 1
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: PUSH
32577: LD_INT 2
32579: PUSH
32580: LD_INT 2
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 1
32589: PUSH
32590: LD_INT 2
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 0
32599: PUSH
32600: LD_INT 2
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 1
32609: NEG
32610: PUSH
32611: LD_INT 1
32613: PUSH
32614: EMPTY
32615: LIST
32616: LIST
32617: PUSH
32618: LD_INT 2
32620: NEG
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: EMPTY
32626: LIST
32627: LIST
32628: PUSH
32629: LD_INT 2
32631: NEG
32632: PUSH
32633: LD_INT 1
32635: NEG
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 2
32643: NEG
32644: PUSH
32645: LD_INT 2
32647: NEG
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 2
32655: PUSH
32656: LD_INT 3
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: PUSH
32666: LD_INT 3
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 1
32675: NEG
32676: PUSH
32677: LD_INT 2
32679: PUSH
32680: EMPTY
32681: LIST
32682: LIST
32683: PUSH
32684: LD_INT 2
32686: NEG
32687: PUSH
32688: LD_INT 1
32690: PUSH
32691: EMPTY
32692: LIST
32693: LIST
32694: PUSH
32695: EMPTY
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: LIST
32711: LIST
32712: LIST
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32720: LD_ADDR_VAR 0 27
32724: PUSH
32725: LD_INT 0
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: LD_INT 1
32748: PUSH
32749: LD_INT 0
32751: PUSH
32752: EMPTY
32753: LIST
32754: LIST
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: LD_INT 1
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 0
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 1
32778: NEG
32779: PUSH
32780: LD_INT 0
32782: PUSH
32783: EMPTY
32784: LIST
32785: LIST
32786: PUSH
32787: LD_INT 1
32789: NEG
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: NEG
32802: PUSH
32803: LD_INT 2
32805: NEG
32806: PUSH
32807: EMPTY
32808: LIST
32809: LIST
32810: PUSH
32811: LD_INT 0
32813: PUSH
32814: LD_INT 2
32816: NEG
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: LD_INT 1
32827: NEG
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 2
32835: PUSH
32836: LD_INT 0
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 2
32845: PUSH
32846: LD_INT 1
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 2
32855: PUSH
32856: LD_INT 2
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 1
32865: PUSH
32866: LD_INT 2
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 0
32875: PUSH
32876: LD_INT 2
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 1
32885: NEG
32886: PUSH
32887: LD_INT 1
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 2
32896: NEG
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 2
32907: NEG
32908: PUSH
32909: LD_INT 1
32911: NEG
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 2
32919: NEG
32920: PUSH
32921: LD_INT 2
32923: NEG
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: NEG
32932: PUSH
32933: LD_INT 2
32935: PUSH
32936: EMPTY
32937: LIST
32938: LIST
32939: PUSH
32940: LD_INT 2
32942: NEG
32943: PUSH
32944: LD_INT 1
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 3
32953: NEG
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 3
32965: NEG
32966: PUSH
32967: LD_INT 2
32969: NEG
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33000: LD_ADDR_VAR 0 28
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: LD_INT 0
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: LD_INT 0
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 0
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 1
33058: NEG
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: NEG
33070: PUSH
33071: LD_INT 1
33073: NEG
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: NEG
33082: PUSH
33083: LD_INT 2
33085: NEG
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 0
33093: PUSH
33094: LD_INT 2
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 1
33104: PUSH
33105: LD_INT 1
33107: NEG
33108: PUSH
33109: EMPTY
33110: LIST
33111: LIST
33112: PUSH
33113: LD_INT 2
33115: PUSH
33116: LD_INT 0
33118: PUSH
33119: EMPTY
33120: LIST
33121: LIST
33122: PUSH
33123: LD_INT 2
33125: PUSH
33126: LD_INT 1
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: PUSH
33133: LD_INT 2
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 1
33145: PUSH
33146: LD_INT 2
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 0
33155: PUSH
33156: LD_INT 2
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 1
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 2
33176: NEG
33177: PUSH
33178: LD_INT 0
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 2
33187: NEG
33188: PUSH
33189: LD_INT 1
33191: NEG
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 2
33199: NEG
33200: PUSH
33201: LD_INT 2
33203: NEG
33204: PUSH
33205: EMPTY
33206: LIST
33207: LIST
33208: PUSH
33209: LD_INT 2
33211: NEG
33212: PUSH
33213: LD_INT 3
33215: NEG
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 3
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 3
33235: NEG
33236: PUSH
33237: LD_INT 1
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 3
33247: NEG
33248: PUSH
33249: LD_INT 2
33251: NEG
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33282: LD_ADDR_VAR 0 29
33286: PUSH
33287: LD_INT 0
33289: PUSH
33290: LD_INT 0
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 0
33299: PUSH
33300: LD_INT 1
33302: NEG
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 1
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: LD_INT 1
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: LD_INT 1
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: NEG
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: LD_INT 1
33355: NEG
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 1
33363: NEG
33364: PUSH
33365: LD_INT 2
33367: NEG
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 0
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 1
33386: PUSH
33387: LD_INT 1
33389: NEG
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 2
33397: PUSH
33398: LD_INT 0
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 2
33407: PUSH
33408: LD_INT 1
33410: PUSH
33411: EMPTY
33412: LIST
33413: LIST
33414: PUSH
33415: LD_INT 1
33417: PUSH
33418: LD_INT 2
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 2
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 1
33437: NEG
33438: PUSH
33439: LD_INT 1
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 2
33448: NEG
33449: PUSH
33450: LD_INT 1
33452: NEG
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: LD_INT 2
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 2
33472: NEG
33473: PUSH
33474: LD_INT 3
33476: NEG
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 2
33484: PUSH
33485: LD_INT 1
33487: NEG
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 3
33495: PUSH
33496: LD_INT 1
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 3
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: LD_INT 2
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 3
33526: NEG
33527: PUSH
33528: LD_INT 2
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: LIST
33540: LIST
33541: LIST
33542: LIST
33543: LIST
33544: LIST
33545: LIST
33546: LIST
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33561: LD_ADDR_VAR 0 30
33565: PUSH
33566: LD_INT 0
33568: PUSH
33569: LD_INT 0
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 0
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 1
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 1
33599: PUSH
33600: LD_INT 1
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 0
33609: PUSH
33610: LD_INT 1
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 1
33619: NEG
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: EMPTY
33625: LIST
33626: LIST
33627: PUSH
33628: LD_INT 1
33630: NEG
33631: PUSH
33632: LD_INT 1
33634: NEG
33635: PUSH
33636: EMPTY
33637: LIST
33638: LIST
33639: PUSH
33640: LD_INT 1
33642: NEG
33643: PUSH
33644: LD_INT 2
33646: NEG
33647: PUSH
33648: EMPTY
33649: LIST
33650: LIST
33651: PUSH
33652: LD_INT 0
33654: PUSH
33655: LD_INT 2
33657: NEG
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: LD_INT 1
33668: NEG
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: PUSH
33674: LD_INT 2
33676: PUSH
33677: LD_INT 0
33679: PUSH
33680: EMPTY
33681: LIST
33682: LIST
33683: PUSH
33684: LD_INT 2
33686: PUSH
33687: LD_INT 1
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: PUSH
33694: LD_INT 2
33696: PUSH
33697: LD_INT 2
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 1
33706: PUSH
33707: LD_INT 2
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 1
33716: NEG
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: LD_INT 0
33731: PUSH
33732: EMPTY
33733: LIST
33734: LIST
33735: PUSH
33736: LD_INT 2
33738: NEG
33739: PUSH
33740: LD_INT 1
33742: NEG
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PUSH
33748: LD_INT 1
33750: NEG
33751: PUSH
33752: LD_INT 3
33754: NEG
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 1
33762: PUSH
33763: LD_INT 2
33765: NEG
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 3
33773: PUSH
33774: LD_INT 2
33776: PUSH
33777: EMPTY
33778: LIST
33779: LIST
33780: PUSH
33781: LD_INT 2
33783: PUSH
33784: LD_INT 3
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 3
33804: NEG
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33839: LD_ADDR_VAR 0 31
33843: PUSH
33844: LD_INT 0
33846: PUSH
33847: LD_INT 0
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: LD_INT 1
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: PUSH
33868: LD_INT 0
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: PUSH
33878: LD_INT 1
33880: PUSH
33881: EMPTY
33882: LIST
33883: LIST
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: LD_INT 1
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: NEG
33898: PUSH
33899: LD_INT 0
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: EMPTY
33915: LIST
33916: LIST
33917: PUSH
33918: LD_INT 1
33920: NEG
33921: PUSH
33922: LD_INT 2
33924: NEG
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: PUSH
33930: LD_INT 1
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 2
33943: PUSH
33944: LD_INT 0
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 2
33953: PUSH
33954: LD_INT 1
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 2
33963: PUSH
33964: LD_INT 2
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 1
33973: PUSH
33974: LD_INT 2
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 2
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 1
33993: NEG
33994: PUSH
33995: LD_INT 1
33997: PUSH
33998: EMPTY
33999: LIST
34000: LIST
34001: PUSH
34002: LD_INT 2
34004: NEG
34005: PUSH
34006: LD_INT 1
34008: NEG
34009: PUSH
34010: EMPTY
34011: LIST
34012: LIST
34013: PUSH
34014: LD_INT 2
34016: NEG
34017: PUSH
34018: LD_INT 2
34020: NEG
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 2
34028: NEG
34029: PUSH
34030: LD_INT 3
34032: NEG
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: LD_INT 2
34040: PUSH
34041: LD_INT 1
34043: NEG
34044: PUSH
34045: EMPTY
34046: LIST
34047: LIST
34048: PUSH
34049: LD_INT 3
34051: PUSH
34052: LD_INT 1
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: PUSH
34059: LD_INT 1
34061: PUSH
34062: LD_INT 3
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: LD_INT 2
34075: PUSH
34076: EMPTY
34077: LIST
34078: LIST
34079: PUSH
34080: LD_INT 3
34082: NEG
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: LIST
34107: LIST
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34117: LD_ADDR_VAR 0 32
34121: PUSH
34122: LD_INT 0
34124: PUSH
34125: LD_INT 0
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 0
34134: PUSH
34135: LD_INT 1
34137: NEG
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 1
34145: PUSH
34146: LD_INT 0
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: LD_INT 1
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 1
34175: NEG
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: EMPTY
34181: LIST
34182: LIST
34183: PUSH
34184: LD_INT 1
34186: NEG
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: EMPTY
34193: LIST
34194: LIST
34195: PUSH
34196: LD_INT 1
34198: NEG
34199: PUSH
34200: LD_INT 2
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 0
34210: PUSH
34211: LD_INT 2
34213: NEG
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 1
34221: PUSH
34222: LD_INT 1
34224: NEG
34225: PUSH
34226: EMPTY
34227: LIST
34228: LIST
34229: PUSH
34230: LD_INT 2
34232: PUSH
34233: LD_INT 1
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 2
34242: PUSH
34243: LD_INT 2
34245: PUSH
34246: EMPTY
34247: LIST
34248: LIST
34249: PUSH
34250: LD_INT 1
34252: PUSH
34253: LD_INT 2
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 0
34262: PUSH
34263: LD_INT 2
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 2
34283: NEG
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 2
34294: NEG
34295: PUSH
34296: LD_INT 1
34298: NEG
34299: PUSH
34300: EMPTY
34301: LIST
34302: LIST
34303: PUSH
34304: LD_INT 1
34306: NEG
34307: PUSH
34308: LD_INT 3
34310: NEG
34311: PUSH
34312: EMPTY
34313: LIST
34314: LIST
34315: PUSH
34316: LD_INT 1
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: EMPTY
34324: LIST
34325: LIST
34326: PUSH
34327: LD_INT 3
34329: PUSH
34330: LD_INT 2
34332: PUSH
34333: EMPTY
34334: LIST
34335: LIST
34336: PUSH
34337: LD_INT 2
34339: PUSH
34340: LD_INT 3
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 2
34349: NEG
34350: PUSH
34351: LD_INT 1
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 3
34360: NEG
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: EMPTY
34367: LIST
34368: LIST
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: LIST
34374: LIST
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34395: LD_ADDR_VAR 0 33
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 0
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: LD_INT 1
34415: NEG
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 1
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 0
34443: PUSH
34444: LD_INT 1
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: NEG
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 1
34464: NEG
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 2
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: LD_INT 0
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: LD_INT 1
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 0
34529: PUSH
34530: LD_INT 2
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 1
34539: NEG
34540: PUSH
34541: LD_INT 1
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 2
34550: NEG
34551: PUSH
34552: LD_INT 0
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 2
34561: NEG
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 2
34573: NEG
34574: PUSH
34575: LD_INT 2
34577: NEG
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 2
34585: NEG
34586: PUSH
34587: LD_INT 3
34589: NEG
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 2
34597: PUSH
34598: LD_INT 1
34600: NEG
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 3
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: LD_INT 3
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 2
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 3
34639: NEG
34640: PUSH
34641: LD_INT 2
34643: NEG
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: LIST
34653: LIST
34654: LIST
34655: LIST
34656: LIST
34657: LIST
34658: LIST
34659: LIST
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34674: LD_ADDR_VAR 0 34
34678: PUSH
34679: LD_INT 0
34681: PUSH
34682: LD_INT 0
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 0
34691: PUSH
34692: LD_INT 1
34694: NEG
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: PUSH
34700: LD_INT 1
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: EMPTY
34707: LIST
34708: LIST
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: EMPTY
34717: LIST
34718: LIST
34719: PUSH
34720: LD_INT 0
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: NEG
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 1
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: LD_INT 2
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 0
34767: PUSH
34768: LD_INT 2
34770: NEG
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: LD_INT 1
34781: NEG
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: LD_INT 2
34789: PUSH
34790: LD_INT 1
34792: PUSH
34793: EMPTY
34794: LIST
34795: LIST
34796: PUSH
34797: LD_INT 2
34799: PUSH
34800: LD_INT 2
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: LD_INT 1
34809: PUSH
34810: LD_INT 2
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 1
34819: NEG
34820: PUSH
34821: LD_INT 1
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: LD_INT 2
34830: NEG
34831: PUSH
34832: LD_INT 0
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 2
34841: NEG
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 2
34853: NEG
34854: PUSH
34855: LD_INT 2
34857: NEG
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 1
34865: NEG
34866: PUSH
34867: LD_INT 3
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 2
34880: NEG
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: LD_INT 3
34888: PUSH
34889: LD_INT 2
34891: PUSH
34892: EMPTY
34893: LIST
34894: LIST
34895: PUSH
34896: LD_INT 2
34898: PUSH
34899: LD_INT 3
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 2
34908: NEG
34909: PUSH
34910: LD_INT 1
34912: PUSH
34913: EMPTY
34914: LIST
34915: LIST
34916: PUSH
34917: LD_INT 3
34919: NEG
34920: PUSH
34921: LD_INT 1
34923: NEG
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: LIST
34933: LIST
34934: LIST
34935: LIST
34936: LIST
34937: LIST
34938: LIST
34939: LIST
34940: LIST
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34954: LD_ADDR_VAR 0 35
34958: PUSH
34959: LD_INT 0
34961: PUSH
34962: LD_INT 0
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 0
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 1
34982: PUSH
34983: LD_INT 0
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: EMPTY
34997: LIST
34998: LIST
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 1
35012: NEG
35013: PUSH
35014: LD_INT 0
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 1
35023: NEG
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 2
35035: PUSH
35036: LD_INT 1
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 2
35045: NEG
35046: PUSH
35047: LD_INT 1
35049: NEG
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35066: LD_ADDR_VAR 0 36
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: LD_INT 0
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 0
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 1
35094: PUSH
35095: LD_INT 0
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: LD_INT 1
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 0
35114: PUSH
35115: LD_INT 1
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: NEG
35125: PUSH
35126: LD_INT 0
35128: PUSH
35129: EMPTY
35130: LIST
35131: LIST
35132: PUSH
35133: LD_INT 1
35135: NEG
35136: PUSH
35137: LD_INT 1
35139: NEG
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: LD_INT 1
35147: NEG
35148: PUSH
35149: LD_INT 2
35151: NEG
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: LIST
35175: LIST
35176: LIST
35177: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35178: LD_ADDR_VAR 0 37
35182: PUSH
35183: LD_INT 0
35185: PUSH
35186: LD_INT 0
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 0
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: LD_INT 0
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: LD_INT 1
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: LD_INT 0
35226: PUSH
35227: LD_INT 1
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: NEG
35237: PUSH
35238: LD_INT 0
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 1
35247: NEG
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: LD_INT 1
35262: NEG
35263: PUSH
35264: EMPTY
35265: LIST
35266: LIST
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: LD_INT 1
35274: PUSH
35275: EMPTY
35276: LIST
35277: LIST
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: LIST
35287: LIST
35288: LIST
35289: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35290: LD_ADDR_VAR 0 38
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: LD_INT 0
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 0
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: LD_INT 0
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 0
35338: PUSH
35339: LD_INT 1
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: LD_INT 1
35348: NEG
35349: PUSH
35350: LD_INT 0
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 2
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 2
35381: NEG
35382: PUSH
35383: LD_INT 1
35385: NEG
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35402: LD_ADDR_VAR 0 39
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: LD_INT 0
35412: PUSH
35413: EMPTY
35414: LIST
35415: LIST
35416: PUSH
35417: LD_INT 0
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: EMPTY
35425: LIST
35426: LIST
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: LD_INT 0
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: LD_INT 1
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 1
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: NEG
35461: PUSH
35462: LD_INT 0
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: NEG
35472: PUSH
35473: LD_INT 1
35475: NEG
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: LD_INT 2
35487: NEG
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: PUSH
35496: LD_INT 2
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35514: LD_ADDR_VAR 0 40
35518: PUSH
35519: LD_INT 0
35521: PUSH
35522: LD_INT 0
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 0
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: EMPTY
35537: LIST
35538: LIST
35539: PUSH
35540: LD_INT 1
35542: PUSH
35543: LD_INT 0
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: LD_INT 1
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 0
35562: PUSH
35563: LD_INT 1
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: NEG
35573: PUSH
35574: LD_INT 0
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: PUSH
35581: LD_INT 1
35583: NEG
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: EMPTY
35590: LIST
35591: LIST
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: EMPTY
35601: LIST
35602: LIST
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: LD_INT 1
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: LIST
35619: LIST
35620: LIST
35621: LIST
35622: LIST
35623: LIST
35624: LIST
35625: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35626: LD_ADDR_VAR 0 41
35630: PUSH
35631: LD_INT 0
35633: PUSH
35634: LD_INT 0
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: PUSH
35641: LD_INT 0
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: EMPTY
35649: LIST
35650: LIST
35651: PUSH
35652: LD_INT 1
35654: PUSH
35655: LD_INT 0
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 1
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 0
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 1
35684: NEG
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: PUSH
35693: LD_INT 1
35695: NEG
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: LD_INT 2
35711: NEG
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 1
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 2
35730: PUSH
35731: LD_INT 0
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 2
35740: PUSH
35741: LD_INT 1
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 2
35750: PUSH
35751: LD_INT 2
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 1
35760: PUSH
35761: LD_INT 2
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: NEG
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 2
35781: NEG
35782: PUSH
35783: LD_INT 0
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: LD_INT 2
35792: NEG
35793: PUSH
35794: LD_INT 1
35796: NEG
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 2
35804: NEG
35805: PUSH
35806: LD_INT 2
35808: NEG
35809: PUSH
35810: EMPTY
35811: LIST
35812: LIST
35813: PUSH
35814: LD_INT 2
35816: NEG
35817: PUSH
35818: LD_INT 3
35820: NEG
35821: PUSH
35822: EMPTY
35823: LIST
35824: LIST
35825: PUSH
35826: LD_INT 2
35828: PUSH
35829: LD_INT 1
35831: NEG
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 3
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 3
35849: PUSH
35850: LD_INT 1
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 3
35859: PUSH
35860: LD_INT 2
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 3
35869: PUSH
35870: LD_INT 3
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 2
35879: PUSH
35880: LD_INT 3
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 2
35889: NEG
35890: PUSH
35891: LD_INT 1
35893: PUSH
35894: EMPTY
35895: LIST
35896: LIST
35897: PUSH
35898: LD_INT 3
35900: NEG
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 3
35911: NEG
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 3
35923: NEG
35924: PUSH
35925: LD_INT 2
35927: NEG
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 3
35935: NEG
35936: PUSH
35937: LD_INT 3
35939: NEG
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35976: LD_ADDR_VAR 0 42
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: LD_INT 0
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: LD_INT 1
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: NEG
36035: PUSH
36036: LD_INT 0
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 1
36057: NEG
36058: PUSH
36059: LD_INT 2
36061: NEG
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 0
36069: PUSH
36070: LD_INT 2
36072: NEG
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 1
36080: PUSH
36081: LD_INT 1
36083: NEG
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 2
36091: PUSH
36092: LD_INT 1
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 2
36101: PUSH
36102: LD_INT 2
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 1
36111: PUSH
36112: LD_INT 2
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 0
36121: PUSH
36122: LD_INT 2
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 1
36131: NEG
36132: PUSH
36133: LD_INT 1
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 2
36142: NEG
36143: PUSH
36144: LD_INT 1
36146: NEG
36147: PUSH
36148: EMPTY
36149: LIST
36150: LIST
36151: PUSH
36152: LD_INT 2
36154: NEG
36155: PUSH
36156: LD_INT 2
36158: NEG
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 2
36166: NEG
36167: PUSH
36168: LD_INT 3
36170: NEG
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: LD_INT 3
36182: NEG
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: PUSH
36188: LD_INT 0
36190: PUSH
36191: LD_INT 3
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 1
36201: PUSH
36202: LD_INT 2
36204: NEG
36205: PUSH
36206: EMPTY
36207: LIST
36208: LIST
36209: PUSH
36210: LD_INT 3
36212: PUSH
36213: LD_INT 2
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 3
36222: PUSH
36223: LD_INT 3
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 2
36232: PUSH
36233: LD_INT 3
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: LD_INT 3
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 0
36252: PUSH
36253: LD_INT 3
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: NEG
36263: PUSH
36264: LD_INT 2
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 3
36273: NEG
36274: PUSH
36275: LD_INT 2
36277: NEG
36278: PUSH
36279: EMPTY
36280: LIST
36281: LIST
36282: PUSH
36283: LD_INT 3
36285: NEG
36286: PUSH
36287: LD_INT 3
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: LIST
36299: LIST
36300: LIST
36301: LIST
36302: LIST
36303: LIST
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36326: LD_ADDR_VAR 0 43
36330: PUSH
36331: LD_INT 0
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: LD_INT 1
36346: NEG
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: PUSH
36355: LD_INT 0
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 1
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 0
36374: PUSH
36375: LD_INT 1
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 1
36384: NEG
36385: PUSH
36386: LD_INT 0
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 1
36395: NEG
36396: PUSH
36397: LD_INT 1
36399: NEG
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: NEG
36408: PUSH
36409: LD_INT 2
36411: NEG
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 0
36419: PUSH
36420: LD_INT 2
36422: NEG
36423: PUSH
36424: EMPTY
36425: LIST
36426: LIST
36427: PUSH
36428: LD_INT 1
36430: PUSH
36431: LD_INT 1
36433: NEG
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 2
36441: PUSH
36442: LD_INT 0
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 2
36451: PUSH
36452: LD_INT 1
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 1
36461: PUSH
36462: LD_INT 2
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 0
36471: PUSH
36472: LD_INT 2
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 1
36481: NEG
36482: PUSH
36483: LD_INT 1
36485: PUSH
36486: EMPTY
36487: LIST
36488: LIST
36489: PUSH
36490: LD_INT 2
36492: NEG
36493: PUSH
36494: LD_INT 0
36496: PUSH
36497: EMPTY
36498: LIST
36499: LIST
36500: PUSH
36501: LD_INT 2
36503: NEG
36504: PUSH
36505: LD_INT 1
36507: NEG
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 1
36515: NEG
36516: PUSH
36517: LD_INT 3
36519: NEG
36520: PUSH
36521: EMPTY
36522: LIST
36523: LIST
36524: PUSH
36525: LD_INT 0
36527: PUSH
36528: LD_INT 3
36530: NEG
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: PUSH
36539: LD_INT 2
36541: NEG
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 2
36549: PUSH
36550: LD_INT 1
36552: NEG
36553: PUSH
36554: EMPTY
36555: LIST
36556: LIST
36557: PUSH
36558: LD_INT 3
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 3
36570: PUSH
36571: LD_INT 1
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: PUSH
36578: LD_INT 1
36580: PUSH
36581: LD_INT 3
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 0
36590: PUSH
36591: LD_INT 3
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: LD_INT 2
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 2
36611: NEG
36612: PUSH
36613: LD_INT 1
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: PUSH
36620: LD_INT 3
36622: NEG
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 3
36633: NEG
36634: PUSH
36635: LD_INT 1
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36674: LD_ADDR_VAR 0 44
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: LD_INT 0
36684: PUSH
36685: EMPTY
36686: LIST
36687: LIST
36688: PUSH
36689: LD_INT 0
36691: PUSH
36692: LD_INT 1
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 1
36702: PUSH
36703: LD_INT 0
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: LD_INT 1
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: LD_INT 0
36722: PUSH
36723: LD_INT 1
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: NEG
36733: PUSH
36734: LD_INT 0
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 1
36743: NEG
36744: PUSH
36745: LD_INT 1
36747: NEG
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: NEG
36756: PUSH
36757: LD_INT 2
36759: NEG
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 1
36767: PUSH
36768: LD_INT 1
36770: NEG
36771: PUSH
36772: EMPTY
36773: LIST
36774: LIST
36775: PUSH
36776: LD_INT 2
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: EMPTY
36783: LIST
36784: LIST
36785: PUSH
36786: LD_INT 2
36788: PUSH
36789: LD_INT 1
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 2
36798: PUSH
36799: LD_INT 2
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 1
36808: PUSH
36809: LD_INT 2
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 1
36818: NEG
36819: PUSH
36820: LD_INT 1
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 2
36829: NEG
36830: PUSH
36831: LD_INT 0
36833: PUSH
36834: EMPTY
36835: LIST
36836: LIST
36837: PUSH
36838: LD_INT 2
36840: NEG
36841: PUSH
36842: LD_INT 1
36844: NEG
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 2
36852: NEG
36853: PUSH
36854: LD_INT 2
36856: NEG
36857: PUSH
36858: EMPTY
36859: LIST
36860: LIST
36861: PUSH
36862: LD_INT 2
36864: NEG
36865: PUSH
36866: LD_INT 3
36868: NEG
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: PUSH
36874: LD_INT 2
36876: PUSH
36877: LD_INT 1
36879: NEG
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 3
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 3
36897: PUSH
36898: LD_INT 1
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 3
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 3
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 2
36927: PUSH
36928: LD_INT 3
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 2
36937: NEG
36938: PUSH
36939: LD_INT 1
36941: PUSH
36942: EMPTY
36943: LIST
36944: LIST
36945: PUSH
36946: LD_INT 3
36948: NEG
36949: PUSH
36950: LD_INT 0
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 3
36959: NEG
36960: PUSH
36961: LD_INT 1
36963: NEG
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 3
36971: NEG
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 3
36983: NEG
36984: PUSH
36985: LD_INT 3
36987: NEG
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37024: LD_ADDR_VAR 0 45
37028: PUSH
37029: LD_INT 0
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 1
37052: PUSH
37053: LD_INT 0
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 1
37062: PUSH
37063: LD_INT 1
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 0
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: NEG
37083: PUSH
37084: LD_INT 0
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 1
37093: NEG
37094: PUSH
37095: LD_INT 1
37097: NEG
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: NEG
37106: PUSH
37107: LD_INT 2
37109: NEG
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 0
37117: PUSH
37118: LD_INT 2
37120: NEG
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: LD_INT 1
37131: NEG
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 2
37139: PUSH
37140: LD_INT 1
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 2
37149: PUSH
37150: LD_INT 2
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 1
37159: PUSH
37160: LD_INT 2
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 0
37169: PUSH
37170: LD_INT 2
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 1
37179: NEG
37180: PUSH
37181: LD_INT 1
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 2
37190: NEG
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: LD_INT 2
37202: NEG
37203: PUSH
37204: LD_INT 2
37206: NEG
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 2
37214: NEG
37215: PUSH
37216: LD_INT 3
37218: NEG
37219: PUSH
37220: EMPTY
37221: LIST
37222: LIST
37223: PUSH
37224: LD_INT 1
37226: NEG
37227: PUSH
37228: LD_INT 3
37230: NEG
37231: PUSH
37232: EMPTY
37233: LIST
37234: LIST
37235: PUSH
37236: LD_INT 0
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 1
37249: PUSH
37250: LD_INT 2
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 3
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 3
37270: PUSH
37271: LD_INT 3
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 2
37280: PUSH
37281: LD_INT 3
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 1
37290: PUSH
37291: LD_INT 3
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 0
37300: PUSH
37301: LD_INT 3
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 1
37310: NEG
37311: PUSH
37312: LD_INT 2
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: LD_INT 3
37321: NEG
37322: PUSH
37323: LD_INT 2
37325: NEG
37326: PUSH
37327: EMPTY
37328: LIST
37329: LIST
37330: PUSH
37331: LD_INT 3
37333: NEG
37334: PUSH
37335: LD_INT 3
37337: NEG
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37374: LD_ADDR_VAR 0 46
37378: PUSH
37379: LD_INT 0
37381: PUSH
37382: LD_INT 0
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 0
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 1
37402: PUSH
37403: LD_INT 0
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 1
37412: PUSH
37413: LD_INT 1
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 0
37422: PUSH
37423: LD_INT 1
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 1
37432: NEG
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 1
37443: NEG
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 1
37455: NEG
37456: PUSH
37457: LD_INT 2
37459: NEG
37460: PUSH
37461: EMPTY
37462: LIST
37463: LIST
37464: PUSH
37465: LD_INT 0
37467: PUSH
37468: LD_INT 2
37470: NEG
37471: PUSH
37472: EMPTY
37473: LIST
37474: LIST
37475: PUSH
37476: LD_INT 1
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 2
37489: PUSH
37490: LD_INT 0
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 2
37499: PUSH
37500: LD_INT 1
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 1
37509: PUSH
37510: LD_INT 2
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 0
37519: PUSH
37520: LD_INT 2
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 1
37529: NEG
37530: PUSH
37531: LD_INT 1
37533: PUSH
37534: EMPTY
37535: LIST
37536: LIST
37537: PUSH
37538: LD_INT 2
37540: NEG
37541: PUSH
37542: LD_INT 0
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: PUSH
37549: LD_INT 2
37551: NEG
37552: PUSH
37553: LD_INT 1
37555: NEG
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 1
37563: NEG
37564: PUSH
37565: LD_INT 3
37567: NEG
37568: PUSH
37569: EMPTY
37570: LIST
37571: LIST
37572: PUSH
37573: LD_INT 0
37575: PUSH
37576: LD_INT 3
37578: NEG
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 1
37586: PUSH
37587: LD_INT 2
37589: NEG
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 2
37597: PUSH
37598: LD_INT 1
37600: NEG
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 3
37608: PUSH
37609: LD_INT 0
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 3
37618: PUSH
37619: LD_INT 1
37621: PUSH
37622: EMPTY
37623: LIST
37624: LIST
37625: PUSH
37626: LD_INT 1
37628: PUSH
37629: LD_INT 3
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 0
37638: PUSH
37639: LD_INT 3
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 1
37648: NEG
37649: PUSH
37650: LD_INT 2
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: LD_INT 2
37659: NEG
37660: PUSH
37661: LD_INT 1
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 3
37670: NEG
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 3
37681: NEG
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37722: LD_ADDR_VAR 0 47
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: LD_INT 0
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 1
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: PUSH
37751: LD_INT 0
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: LD_INT 1
37763: PUSH
37764: EMPTY
37765: LIST
37766: LIST
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: LD_INT 1
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 1
37780: NEG
37781: PUSH
37782: LD_INT 0
37784: PUSH
37785: EMPTY
37786: LIST
37787: LIST
37788: PUSH
37789: LD_INT 1
37791: NEG
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: NEG
37804: PUSH
37805: LD_INT 2
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 0
37815: PUSH
37816: LD_INT 2
37818: NEG
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: LD_INT 1
37829: NEG
37830: PUSH
37831: EMPTY
37832: LIST
37833: LIST
37834: PUSH
37835: LD_INT 2
37837: NEG
37838: PUSH
37839: LD_INT 1
37841: NEG
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 2
37849: NEG
37850: PUSH
37851: LD_INT 2
37853: NEG
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: LIST
37863: LIST
37864: LIST
37865: LIST
37866: LIST
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37873: LD_ADDR_VAR 0 48
37877: PUSH
37878: LD_INT 0
37880: PUSH
37881: LD_INT 0
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 0
37890: PUSH
37891: LD_INT 1
37893: NEG
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PUSH
37899: LD_INT 1
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 1
37911: PUSH
37912: LD_INT 1
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 0
37921: PUSH
37922: LD_INT 1
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 1
37931: NEG
37932: PUSH
37933: LD_INT 0
37935: PUSH
37936: EMPTY
37937: LIST
37938: LIST
37939: PUSH
37940: LD_INT 1
37942: NEG
37943: PUSH
37944: LD_INT 1
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 2
37958: NEG
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: LD_INT 2
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 2
37988: PUSH
37989: LD_INT 0
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 2
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: LIST
38015: LIST
38016: LIST
38017: LIST
38018: LIST
38019: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38020: LD_ADDR_VAR 0 49
38024: PUSH
38025: LD_INT 0
38027: PUSH
38028: LD_INT 0
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 0
38037: PUSH
38038: LD_INT 1
38040: NEG
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 1
38048: PUSH
38049: LD_INT 0
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: PUSH
38059: LD_INT 1
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 0
38068: PUSH
38069: LD_INT 1
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: NEG
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: NEG
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 1
38104: NEG
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: LD_INT 0
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 2
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 1
38142: PUSH
38143: LD_INT 2
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: LIST
38154: LIST
38155: LIST
38156: LIST
38157: LIST
38158: LIST
38159: LIST
38160: LIST
38161: LIST
38162: LIST
38163: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38164: LD_ADDR_VAR 0 50
38168: PUSH
38169: LD_INT 0
38171: PUSH
38172: LD_INT 0
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 0
38181: PUSH
38182: LD_INT 1
38184: NEG
38185: PUSH
38186: EMPTY
38187: LIST
38188: LIST
38189: PUSH
38190: LD_INT 1
38192: PUSH
38193: LD_INT 0
38195: PUSH
38196: EMPTY
38197: LIST
38198: LIST
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: LD_INT 1
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 0
38212: PUSH
38213: LD_INT 1
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: NEG
38223: PUSH
38224: LD_INT 0
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PUSH
38231: LD_INT 1
38233: NEG
38234: PUSH
38235: LD_INT 1
38237: NEG
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 2
38245: PUSH
38246: LD_INT 1
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: LD_INT 2
38255: PUSH
38256: LD_INT 2
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 1
38265: PUSH
38266: LD_INT 2
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: LD_INT 2
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 1
38285: NEG
38286: PUSH
38287: LD_INT 1
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: LIST
38298: LIST
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38308: LD_ADDR_VAR 0 51
38312: PUSH
38313: LD_INT 0
38315: PUSH
38316: LD_INT 0
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 0
38325: PUSH
38326: LD_INT 1
38328: NEG
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: LD_INT 0
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: PUSH
38344: LD_INT 1
38346: PUSH
38347: LD_INT 1
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 0
38356: PUSH
38357: LD_INT 1
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 1
38377: NEG
38378: PUSH
38379: LD_INT 1
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 2
38392: PUSH
38393: EMPTY
38394: LIST
38395: LIST
38396: PUSH
38397: LD_INT 0
38399: PUSH
38400: LD_INT 2
38402: PUSH
38403: EMPTY
38404: LIST
38405: LIST
38406: PUSH
38407: LD_INT 1
38409: NEG
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 2
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38455: LD_ADDR_VAR 0 52
38459: PUSH
38460: LD_INT 0
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: LD_INT 1
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 1
38483: PUSH
38484: LD_INT 0
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: PUSH
38491: LD_INT 1
38493: PUSH
38494: LD_INT 1
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 0
38503: PUSH
38504: LD_INT 1
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 1
38513: NEG
38514: PUSH
38515: LD_INT 0
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: LD_INT 1
38528: NEG
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: LD_INT 1
38536: NEG
38537: PUSH
38538: LD_INT 2
38540: NEG
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 1
38548: NEG
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 2
38559: NEG
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: EMPTY
38565: LIST
38566: LIST
38567: PUSH
38568: LD_INT 2
38570: NEG
38571: PUSH
38572: LD_INT 1
38574: NEG
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: LD_INT 2
38586: NEG
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38606: LD_ADDR_VAR 0 53
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 0
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 1
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 1
38644: PUSH
38645: LD_INT 1
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 0
38654: PUSH
38655: LD_INT 1
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: LD_INT 1
38664: NEG
38665: PUSH
38666: LD_INT 0
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 1
38675: NEG
38676: PUSH
38677: LD_INT 1
38679: NEG
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 1
38687: NEG
38688: PUSH
38689: LD_INT 2
38691: NEG
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 0
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: EMPTY
38705: LIST
38706: LIST
38707: PUSH
38708: LD_INT 1
38710: PUSH
38711: LD_INT 1
38713: NEG
38714: PUSH
38715: EMPTY
38716: LIST
38717: LIST
38718: PUSH
38719: LD_INT 2
38721: PUSH
38722: LD_INT 0
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 2
38731: PUSH
38732: LD_INT 1
38734: PUSH
38735: EMPTY
38736: LIST
38737: LIST
38738: PUSH
38739: LD_INT 2
38741: PUSH
38742: LD_INT 2
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 1
38751: PUSH
38752: LD_INT 2
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 0
38761: PUSH
38762: LD_INT 2
38764: PUSH
38765: EMPTY
38766: LIST
38767: LIST
38768: PUSH
38769: LD_INT 1
38771: NEG
38772: PUSH
38773: LD_INT 1
38775: PUSH
38776: EMPTY
38777: LIST
38778: LIST
38779: PUSH
38780: LD_INT 2
38782: NEG
38783: PUSH
38784: LD_INT 0
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 2
38793: NEG
38794: PUSH
38795: LD_INT 1
38797: NEG
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: PUSH
38803: LD_INT 2
38805: NEG
38806: PUSH
38807: LD_INT 2
38809: NEG
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: LIST
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38836: LD_ADDR_VAR 0 54
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 0
38853: PUSH
38854: LD_INT 1
38856: NEG
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 1
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 0
38884: PUSH
38885: LD_INT 1
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 1
38894: NEG
38895: PUSH
38896: LD_INT 0
38898: PUSH
38899: EMPTY
38900: LIST
38901: LIST
38902: PUSH
38903: LD_INT 1
38905: NEG
38906: PUSH
38907: LD_INT 1
38909: NEG
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 1
38917: NEG
38918: PUSH
38919: LD_INT 2
38921: NEG
38922: PUSH
38923: EMPTY
38924: LIST
38925: LIST
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: LD_INT 2
38932: NEG
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 1
38940: PUSH
38941: LD_INT 1
38943: NEG
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PUSH
38949: LD_INT 2
38951: PUSH
38952: LD_INT 0
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PUSH
38959: LD_INT 2
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: EMPTY
38966: LIST
38967: LIST
38968: PUSH
38969: LD_INT 2
38971: PUSH
38972: LD_INT 2
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 1
38981: PUSH
38982: LD_INT 2
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: LD_INT 0
38991: PUSH
38992: LD_INT 2
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 1
39001: NEG
39002: PUSH
39003: LD_INT 1
39005: PUSH
39006: EMPTY
39007: LIST
39008: LIST
39009: PUSH
39010: LD_INT 2
39012: NEG
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: EMPTY
39018: LIST
39019: LIST
39020: PUSH
39021: LD_INT 2
39023: NEG
39024: PUSH
39025: LD_INT 1
39027: NEG
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 2
39035: NEG
39036: PUSH
39037: LD_INT 2
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39066: LD_ADDR_VAR 0 55
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 0
39083: PUSH
39084: LD_INT 1
39086: NEG
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: LD_INT 1
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: NEG
39136: PUSH
39137: LD_INT 1
39139: NEG
39140: PUSH
39141: EMPTY
39142: LIST
39143: LIST
39144: PUSH
39145: LD_INT 1
39147: NEG
39148: PUSH
39149: LD_INT 2
39151: NEG
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: LD_INT 2
39162: NEG
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 1
39170: PUSH
39171: LD_INT 1
39173: NEG
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: PUSH
39179: LD_INT 2
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 2
39191: PUSH
39192: LD_INT 1
39194: PUSH
39195: EMPTY
39196: LIST
39197: LIST
39198: PUSH
39199: LD_INT 2
39201: PUSH
39202: LD_INT 2
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 1
39211: PUSH
39212: LD_INT 2
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 0
39221: PUSH
39222: LD_INT 2
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 1
39231: NEG
39232: PUSH
39233: LD_INT 1
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: PUSH
39240: LD_INT 2
39242: NEG
39243: PUSH
39244: LD_INT 0
39246: PUSH
39247: EMPTY
39248: LIST
39249: LIST
39250: PUSH
39251: LD_INT 2
39253: NEG
39254: PUSH
39255: LD_INT 1
39257: NEG
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 2
39265: NEG
39266: PUSH
39267: LD_INT 2
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39296: LD_ADDR_VAR 0 56
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 0
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 1
39324: PUSH
39325: LD_INT 0
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: PUSH
39342: LD_INT 0
39344: PUSH
39345: LD_INT 1
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 1
39354: NEG
39355: PUSH
39356: LD_INT 0
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 1
39365: NEG
39366: PUSH
39367: LD_INT 1
39369: NEG
39370: PUSH
39371: EMPTY
39372: LIST
39373: LIST
39374: PUSH
39375: LD_INT 1
39377: NEG
39378: PUSH
39379: LD_INT 2
39381: NEG
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: PUSH
39387: LD_INT 0
39389: PUSH
39390: LD_INT 2
39392: NEG
39393: PUSH
39394: EMPTY
39395: LIST
39396: LIST
39397: PUSH
39398: LD_INT 1
39400: PUSH
39401: LD_INT 1
39403: NEG
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 2
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: PUSH
39422: LD_INT 1
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: LD_INT 2
39431: PUSH
39432: LD_INT 2
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 1
39441: PUSH
39442: LD_INT 2
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 0
39451: PUSH
39452: LD_INT 2
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 1
39461: NEG
39462: PUSH
39463: LD_INT 1
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: LD_INT 2
39472: NEG
39473: PUSH
39474: LD_INT 0
39476: PUSH
39477: EMPTY
39478: LIST
39479: LIST
39480: PUSH
39481: LD_INT 2
39483: NEG
39484: PUSH
39485: LD_INT 1
39487: NEG
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 2
39495: NEG
39496: PUSH
39497: LD_INT 2
39499: NEG
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: EMPTY
39506: LIST
39507: LIST
39508: LIST
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39526: LD_ADDR_VAR 0 57
39530: PUSH
39531: LD_INT 0
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 0
39543: PUSH
39544: LD_INT 1
39546: NEG
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 1
39554: PUSH
39555: LD_INT 0
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: LD_INT 1
39564: PUSH
39565: LD_INT 1
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: PUSH
39572: LD_INT 0
39574: PUSH
39575: LD_INT 1
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 1
39584: NEG
39585: PUSH
39586: LD_INT 0
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: NEG
39596: PUSH
39597: LD_INT 1
39599: NEG
39600: PUSH
39601: EMPTY
39602: LIST
39603: LIST
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: LD_INT 2
39611: NEG
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: PUSH
39617: LD_INT 0
39619: PUSH
39620: LD_INT 2
39622: NEG
39623: PUSH
39624: EMPTY
39625: LIST
39626: LIST
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: LD_INT 1
39633: NEG
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: PUSH
39639: LD_INT 2
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 2
39651: PUSH
39652: LD_INT 1
39654: PUSH
39655: EMPTY
39656: LIST
39657: LIST
39658: PUSH
39659: LD_INT 2
39661: PUSH
39662: LD_INT 2
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 1
39671: PUSH
39672: LD_INT 2
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 0
39681: PUSH
39682: LD_INT 2
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 1
39691: NEG
39692: PUSH
39693: LD_INT 1
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 2
39702: NEG
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: LD_INT 1
39717: NEG
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 2
39725: NEG
39726: PUSH
39727: LD_INT 2
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: EMPTY
39736: LIST
39737: LIST
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39756: LD_ADDR_VAR 0 58
39760: PUSH
39761: LD_INT 0
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: EMPTY
39768: LIST
39769: LIST
39770: PUSH
39771: LD_INT 0
39773: PUSH
39774: LD_INT 1
39776: NEG
39777: PUSH
39778: EMPTY
39779: LIST
39780: LIST
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: LD_INT 0
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 1
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: PUSH
39802: LD_INT 0
39804: PUSH
39805: LD_INT 1
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: LD_INT 0
39818: PUSH
39819: EMPTY
39820: LIST
39821: LIST
39822: PUSH
39823: LD_INT 1
39825: NEG
39826: PUSH
39827: LD_INT 1
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: LD_INT 1
39837: NEG
39838: PUSH
39839: LD_INT 2
39841: NEG
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 0
39849: PUSH
39850: LD_INT 2
39852: NEG
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PUSH
39858: LD_INT 1
39860: PUSH
39861: LD_INT 1
39863: NEG
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: PUSH
39869: LD_INT 2
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 2
39881: PUSH
39882: LD_INT 1
39884: PUSH
39885: EMPTY
39886: LIST
39887: LIST
39888: PUSH
39889: LD_INT 2
39891: PUSH
39892: LD_INT 2
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 1
39901: PUSH
39902: LD_INT 2
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 0
39911: PUSH
39912: LD_INT 2
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 1
39921: NEG
39922: PUSH
39923: LD_INT 1
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: PUSH
39930: LD_INT 2
39932: NEG
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: LD_INT 2
39943: NEG
39944: PUSH
39945: LD_INT 1
39947: NEG
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 2
39955: NEG
39956: PUSH
39957: LD_INT 2
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: EMPTY
39966: LIST
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39986: LD_ADDR_VAR 0 59
39990: PUSH
39991: LD_INT 0
39993: PUSH
39994: LD_INT 0
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 0
40003: PUSH
40004: LD_INT 1
40006: NEG
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: LD_INT 0
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 1
40024: PUSH
40025: LD_INT 1
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: PUSH
40032: LD_INT 0
40034: PUSH
40035: LD_INT 1
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: NEG
40045: PUSH
40046: LD_INT 0
40048: PUSH
40049: EMPTY
40050: LIST
40051: LIST
40052: PUSH
40053: LD_INT 1
40055: NEG
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: EMPTY
40062: LIST
40063: LIST
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: LIST
40069: LIST
40070: LIST
40071: LIST
40072: LIST
40073: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40074: LD_ADDR_VAR 0 60
40078: PUSH
40079: LD_INT 0
40081: PUSH
40082: LD_INT 0
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PUSH
40089: LD_INT 0
40091: PUSH
40092: LD_INT 1
40094: NEG
40095: PUSH
40096: EMPTY
40097: LIST
40098: LIST
40099: PUSH
40100: LD_INT 1
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 1
40112: PUSH
40113: LD_INT 1
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 0
40122: PUSH
40123: LD_INT 1
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 1
40132: NEG
40133: PUSH
40134: LD_INT 0
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 1
40143: NEG
40144: PUSH
40145: LD_INT 1
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: LIST
40161: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40162: LD_ADDR_VAR 0 61
40166: PUSH
40167: LD_INT 0
40169: PUSH
40170: LD_INT 0
40172: PUSH
40173: EMPTY
40174: LIST
40175: LIST
40176: PUSH
40177: LD_INT 0
40179: PUSH
40180: LD_INT 1
40182: NEG
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 1
40190: PUSH
40191: LD_INT 0
40193: PUSH
40194: EMPTY
40195: LIST
40196: LIST
40197: PUSH
40198: LD_INT 1
40200: PUSH
40201: LD_INT 1
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 0
40210: PUSH
40211: LD_INT 1
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: NEG
40221: PUSH
40222: LD_INT 0
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 1
40231: NEG
40232: PUSH
40233: LD_INT 1
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: LIST
40249: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40250: LD_ADDR_VAR 0 62
40254: PUSH
40255: LD_INT 0
40257: PUSH
40258: LD_INT 0
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 0
40267: PUSH
40268: LD_INT 1
40270: NEG
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 1
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 1
40288: PUSH
40289: LD_INT 1
40291: PUSH
40292: EMPTY
40293: LIST
40294: LIST
40295: PUSH
40296: LD_INT 0
40298: PUSH
40299: LD_INT 1
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 1
40308: NEG
40309: PUSH
40310: LD_INT 0
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: LD_INT 1
40319: NEG
40320: PUSH
40321: LD_INT 1
40323: NEG
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: EMPTY
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40338: LD_ADDR_VAR 0 63
40342: PUSH
40343: LD_INT 0
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: EMPTY
40350: LIST
40351: LIST
40352: PUSH
40353: LD_INT 0
40355: PUSH
40356: LD_INT 1
40358: NEG
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: LD_INT 0
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: LD_INT 1
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: LD_INT 1
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 1
40396: NEG
40397: PUSH
40398: LD_INT 0
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: NEG
40408: PUSH
40409: LD_INT 1
40411: NEG
40412: PUSH
40413: EMPTY
40414: LIST
40415: LIST
40416: PUSH
40417: EMPTY
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: LIST
40425: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40426: LD_ADDR_VAR 0 64
40430: PUSH
40431: LD_INT 0
40433: PUSH
40434: LD_INT 0
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 0
40443: PUSH
40444: LD_INT 1
40446: NEG
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 1
40454: PUSH
40455: LD_INT 0
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 1
40464: PUSH
40465: LD_INT 1
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 0
40474: PUSH
40475: LD_INT 1
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: NEG
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: LD_INT 1
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: ST_TO_ADDR
// end ; 1 :
40514: GO 46411
40516: LD_INT 1
40518: DOUBLE
40519: EQUAL
40520: IFTRUE 40524
40522: GO 43147
40524: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40525: LD_ADDR_VAR 0 11
40529: PUSH
40530: LD_INT 1
40532: NEG
40533: PUSH
40534: LD_INT 3
40536: NEG
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: LD_INT 3
40547: NEG
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: LD_INT 1
40555: PUSH
40556: LD_INT 2
40558: NEG
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: LIST
40568: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40569: LD_ADDR_VAR 0 12
40573: PUSH
40574: LD_INT 2
40576: PUSH
40577: LD_INT 1
40579: NEG
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 3
40587: PUSH
40588: LD_INT 0
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: LD_INT 3
40597: PUSH
40598: LD_INT 1
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: PUSH
40605: EMPTY
40606: LIST
40607: LIST
40608: LIST
40609: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40610: LD_ADDR_VAR 0 13
40614: PUSH
40615: LD_INT 3
40617: PUSH
40618: LD_INT 2
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 3
40627: PUSH
40628: LD_INT 3
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 2
40637: PUSH
40638: LD_INT 3
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: LIST
40649: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40650: LD_ADDR_VAR 0 14
40654: PUSH
40655: LD_INT 1
40657: PUSH
40658: LD_INT 3
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 0
40667: PUSH
40668: LD_INT 3
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 1
40677: NEG
40678: PUSH
40679: LD_INT 2
40681: PUSH
40682: EMPTY
40683: LIST
40684: LIST
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: LIST
40690: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40691: LD_ADDR_VAR 0 15
40695: PUSH
40696: LD_INT 2
40698: NEG
40699: PUSH
40700: LD_INT 1
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 3
40709: NEG
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 3
40720: NEG
40721: PUSH
40722: LD_INT 1
40724: NEG
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: LIST
40734: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40735: LD_ADDR_VAR 0 16
40739: PUSH
40740: LD_INT 2
40742: NEG
40743: PUSH
40744: LD_INT 3
40746: NEG
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 3
40754: NEG
40755: PUSH
40756: LD_INT 2
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 3
40766: NEG
40767: PUSH
40768: LD_INT 3
40770: NEG
40771: PUSH
40772: EMPTY
40773: LIST
40774: LIST
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: LIST
40780: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40781: LD_ADDR_VAR 0 17
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: LD_INT 3
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 0
40800: PUSH
40801: LD_INT 3
40803: NEG
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 1
40811: PUSH
40812: LD_INT 2
40814: NEG
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: LIST
40824: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40825: LD_ADDR_VAR 0 18
40829: PUSH
40830: LD_INT 2
40832: PUSH
40833: LD_INT 1
40835: NEG
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 3
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 3
40853: PUSH
40854: LD_INT 1
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: LIST
40865: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40866: LD_ADDR_VAR 0 19
40870: PUSH
40871: LD_INT 3
40873: PUSH
40874: LD_INT 2
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 3
40883: PUSH
40884: LD_INT 3
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 2
40893: PUSH
40894: LD_INT 3
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: LIST
40905: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40906: LD_ADDR_VAR 0 20
40910: PUSH
40911: LD_INT 1
40913: PUSH
40914: LD_INT 3
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 0
40923: PUSH
40924: LD_INT 3
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: LD_INT 1
40933: NEG
40934: PUSH
40935: LD_INT 2
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: EMPTY
40943: LIST
40944: LIST
40945: LIST
40946: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40947: LD_ADDR_VAR 0 21
40951: PUSH
40952: LD_INT 2
40954: NEG
40955: PUSH
40956: LD_INT 1
40958: PUSH
40959: EMPTY
40960: LIST
40961: LIST
40962: PUSH
40963: LD_INT 3
40965: NEG
40966: PUSH
40967: LD_INT 0
40969: PUSH
40970: EMPTY
40971: LIST
40972: LIST
40973: PUSH
40974: LD_INT 3
40976: NEG
40977: PUSH
40978: LD_INT 1
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: EMPTY
40987: LIST
40988: LIST
40989: LIST
40990: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40991: LD_ADDR_VAR 0 22
40995: PUSH
40996: LD_INT 2
40998: NEG
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 3
41010: NEG
41011: PUSH
41012: LD_INT 2
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 3
41022: NEG
41023: PUSH
41024: LD_INT 3
41026: NEG
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: LIST
41036: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41037: LD_ADDR_VAR 0 23
41041: PUSH
41042: LD_INT 0
41044: PUSH
41045: LD_INT 3
41047: NEG
41048: PUSH
41049: EMPTY
41050: LIST
41051: LIST
41052: PUSH
41053: LD_INT 1
41055: NEG
41056: PUSH
41057: LD_INT 4
41059: NEG
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: PUSH
41065: LD_INT 1
41067: PUSH
41068: LD_INT 3
41070: NEG
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: LIST
41080: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41081: LD_ADDR_VAR 0 24
41085: PUSH
41086: LD_INT 3
41088: PUSH
41089: LD_INT 0
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 3
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 4
41109: PUSH
41110: LD_INT 1
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: LIST
41121: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41122: LD_ADDR_VAR 0 25
41126: PUSH
41127: LD_INT 3
41129: PUSH
41130: LD_INT 3
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 3
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 3
41149: PUSH
41150: LD_INT 4
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: LIST
41161: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41162: LD_ADDR_VAR 0 26
41166: PUSH
41167: LD_INT 0
41169: PUSH
41170: LD_INT 3
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 1
41179: PUSH
41180: LD_INT 4
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: LD_INT 3
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: LIST
41202: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41203: LD_ADDR_VAR 0 27
41207: PUSH
41208: LD_INT 3
41210: NEG
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: PUSH
41219: LD_INT 3
41221: NEG
41222: PUSH
41223: LD_INT 1
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 4
41232: NEG
41233: PUSH
41234: LD_INT 1
41236: NEG
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: EMPTY
41243: LIST
41244: LIST
41245: LIST
41246: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41247: LD_ADDR_VAR 0 28
41251: PUSH
41252: LD_INT 3
41254: NEG
41255: PUSH
41256: LD_INT 3
41258: NEG
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: LD_INT 3
41266: NEG
41267: PUSH
41268: LD_INT 4
41270: NEG
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 4
41278: NEG
41279: PUSH
41280: LD_INT 3
41282: NEG
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: LIST
41292: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41293: LD_ADDR_VAR 0 29
41297: PUSH
41298: LD_INT 1
41300: NEG
41301: PUSH
41302: LD_INT 3
41304: NEG
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 0
41312: PUSH
41313: LD_INT 3
41315: NEG
41316: PUSH
41317: EMPTY
41318: LIST
41319: LIST
41320: PUSH
41321: LD_INT 1
41323: PUSH
41324: LD_INT 2
41326: NEG
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: LD_INT 1
41334: NEG
41335: PUSH
41336: LD_INT 4
41338: NEG
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 0
41346: PUSH
41347: LD_INT 4
41349: NEG
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: LD_INT 1
41357: PUSH
41358: LD_INT 3
41360: NEG
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: LD_INT 1
41368: NEG
41369: PUSH
41370: LD_INT 5
41372: NEG
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 0
41380: PUSH
41381: LD_INT 5
41383: NEG
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 1
41391: PUSH
41392: LD_INT 4
41394: NEG
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 1
41402: NEG
41403: PUSH
41404: LD_INT 6
41406: NEG
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: LD_INT 0
41414: PUSH
41415: LD_INT 6
41417: NEG
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 1
41425: PUSH
41426: LD_INT 5
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: LIST
41438: LIST
41439: LIST
41440: LIST
41441: LIST
41442: LIST
41443: LIST
41444: LIST
41445: LIST
41446: LIST
41447: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41448: LD_ADDR_VAR 0 30
41452: PUSH
41453: LD_INT 2
41455: PUSH
41456: LD_INT 1
41458: NEG
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 3
41466: PUSH
41467: LD_INT 0
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: LD_INT 3
41476: PUSH
41477: LD_INT 1
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: LD_INT 3
41486: PUSH
41487: LD_INT 1
41489: NEG
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: PUSH
41495: LD_INT 4
41497: PUSH
41498: LD_INT 0
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 4
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: LD_INT 4
41517: PUSH
41518: LD_INT 1
41520: NEG
41521: PUSH
41522: EMPTY
41523: LIST
41524: LIST
41525: PUSH
41526: LD_INT 5
41528: PUSH
41529: LD_INT 0
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: LD_INT 5
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 5
41548: PUSH
41549: LD_INT 1
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 6
41559: PUSH
41560: LD_INT 0
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 6
41569: PUSH
41570: LD_INT 1
41572: PUSH
41573: EMPTY
41574: LIST
41575: LIST
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: LIST
41581: LIST
41582: LIST
41583: LIST
41584: LIST
41585: LIST
41586: LIST
41587: LIST
41588: LIST
41589: LIST
41590: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41591: LD_ADDR_VAR 0 31
41595: PUSH
41596: LD_INT 3
41598: PUSH
41599: LD_INT 2
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 3
41608: PUSH
41609: LD_INT 3
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 2
41618: PUSH
41619: LD_INT 3
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 4
41628: PUSH
41629: LD_INT 3
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 4
41638: PUSH
41639: LD_INT 4
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 3
41648: PUSH
41649: LD_INT 4
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 5
41658: PUSH
41659: LD_INT 4
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 5
41668: PUSH
41669: LD_INT 5
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 4
41678: PUSH
41679: LD_INT 5
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 6
41688: PUSH
41689: LD_INT 5
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 6
41698: PUSH
41699: LD_INT 6
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 5
41708: PUSH
41709: LD_INT 6
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: EMPTY
41717: LIST
41718: LIST
41719: LIST
41720: LIST
41721: LIST
41722: LIST
41723: LIST
41724: LIST
41725: LIST
41726: LIST
41727: LIST
41728: LIST
41729: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41730: LD_ADDR_VAR 0 32
41734: PUSH
41735: LD_INT 1
41737: PUSH
41738: LD_INT 3
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 0
41747: PUSH
41748: LD_INT 3
41750: PUSH
41751: EMPTY
41752: LIST
41753: LIST
41754: PUSH
41755: LD_INT 1
41757: NEG
41758: PUSH
41759: LD_INT 2
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 1
41768: PUSH
41769: LD_INT 4
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 0
41778: PUSH
41779: LD_INT 4
41781: PUSH
41782: EMPTY
41783: LIST
41784: LIST
41785: PUSH
41786: LD_INT 1
41788: NEG
41789: PUSH
41790: LD_INT 3
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 1
41799: PUSH
41800: LD_INT 5
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 0
41809: PUSH
41810: LD_INT 5
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: LD_INT 1
41819: NEG
41820: PUSH
41821: LD_INT 4
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 1
41830: PUSH
41831: LD_INT 6
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 0
41840: PUSH
41841: LD_INT 6
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 1
41850: NEG
41851: PUSH
41852: LD_INT 5
41854: PUSH
41855: EMPTY
41856: LIST
41857: LIST
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: LIST
41863: LIST
41864: LIST
41865: LIST
41866: LIST
41867: LIST
41868: LIST
41869: LIST
41870: LIST
41871: LIST
41872: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41873: LD_ADDR_VAR 0 33
41877: PUSH
41878: LD_INT 2
41880: NEG
41881: PUSH
41882: LD_INT 1
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: LD_INT 3
41891: NEG
41892: PUSH
41893: LD_INT 0
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 3
41902: NEG
41903: PUSH
41904: LD_INT 1
41906: NEG
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 3
41914: NEG
41915: PUSH
41916: LD_INT 1
41918: PUSH
41919: EMPTY
41920: LIST
41921: LIST
41922: PUSH
41923: LD_INT 4
41925: NEG
41926: PUSH
41927: LD_INT 0
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 4
41936: NEG
41937: PUSH
41938: LD_INT 1
41940: NEG
41941: PUSH
41942: EMPTY
41943: LIST
41944: LIST
41945: PUSH
41946: LD_INT 4
41948: NEG
41949: PUSH
41950: LD_INT 1
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: LD_INT 5
41959: NEG
41960: PUSH
41961: LD_INT 0
41963: PUSH
41964: EMPTY
41965: LIST
41966: LIST
41967: PUSH
41968: LD_INT 5
41970: NEG
41971: PUSH
41972: LD_INT 1
41974: NEG
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 5
41982: NEG
41983: PUSH
41984: LD_INT 1
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 6
41993: NEG
41994: PUSH
41995: LD_INT 0
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PUSH
42002: LD_INT 6
42004: NEG
42005: PUSH
42006: LD_INT 1
42008: NEG
42009: PUSH
42010: EMPTY
42011: LIST
42012: LIST
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: LIST
42020: LIST
42021: LIST
42022: LIST
42023: LIST
42024: LIST
42025: LIST
42026: LIST
42027: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42028: LD_ADDR_VAR 0 34
42032: PUSH
42033: LD_INT 2
42035: NEG
42036: PUSH
42037: LD_INT 3
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 3
42047: NEG
42048: PUSH
42049: LD_INT 2
42051: NEG
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: PUSH
42057: LD_INT 3
42059: NEG
42060: PUSH
42061: LD_INT 3
42063: NEG
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 3
42071: NEG
42072: PUSH
42073: LD_INT 4
42075: NEG
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 4
42083: NEG
42084: PUSH
42085: LD_INT 3
42087: NEG
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 4
42095: NEG
42096: PUSH
42097: LD_INT 4
42099: NEG
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 4
42107: NEG
42108: PUSH
42109: LD_INT 5
42111: NEG
42112: PUSH
42113: EMPTY
42114: LIST
42115: LIST
42116: PUSH
42117: LD_INT 5
42119: NEG
42120: PUSH
42121: LD_INT 4
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: LD_INT 5
42131: NEG
42132: PUSH
42133: LD_INT 5
42135: NEG
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 5
42143: NEG
42144: PUSH
42145: LD_INT 6
42147: NEG
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 6
42155: NEG
42156: PUSH
42157: LD_INT 5
42159: NEG
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: LD_INT 6
42167: NEG
42168: PUSH
42169: LD_INT 6
42171: NEG
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: LIST
42181: LIST
42182: LIST
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: LIST
42188: LIST
42189: LIST
42190: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42191: LD_ADDR_VAR 0 41
42195: PUSH
42196: LD_INT 0
42198: PUSH
42199: LD_INT 2
42201: NEG
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 1
42209: NEG
42210: PUSH
42211: LD_INT 3
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 1
42221: PUSH
42222: LD_INT 2
42224: NEG
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: LIST
42234: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42235: LD_ADDR_VAR 0 42
42239: PUSH
42240: LD_INT 2
42242: PUSH
42243: LD_INT 0
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PUSH
42250: LD_INT 2
42252: PUSH
42253: LD_INT 1
42255: NEG
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 3
42263: PUSH
42264: LD_INT 1
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: LIST
42275: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42276: LD_ADDR_VAR 0 43
42280: PUSH
42281: LD_INT 2
42283: PUSH
42284: LD_INT 2
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: LD_INT 2
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 2
42303: PUSH
42304: LD_INT 3
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: EMPTY
42312: LIST
42313: LIST
42314: LIST
42315: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42316: LD_ADDR_VAR 0 44
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: LD_INT 2
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 1
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: LD_INT 1
42343: NEG
42344: PUSH
42345: LD_INT 2
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: LIST
42356: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42357: LD_ADDR_VAR 0 45
42361: PUSH
42362: LD_INT 2
42364: NEG
42365: PUSH
42366: LD_INT 0
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 2
42375: NEG
42376: PUSH
42377: LD_INT 1
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 3
42386: NEG
42387: PUSH
42388: LD_INT 1
42390: NEG
42391: PUSH
42392: EMPTY
42393: LIST
42394: LIST
42395: PUSH
42396: EMPTY
42397: LIST
42398: LIST
42399: LIST
42400: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42401: LD_ADDR_VAR 0 46
42405: PUSH
42406: LD_INT 2
42408: NEG
42409: PUSH
42410: LD_INT 2
42412: NEG
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 2
42420: NEG
42421: PUSH
42422: LD_INT 3
42424: NEG
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PUSH
42430: LD_INT 3
42432: NEG
42433: PUSH
42434: LD_INT 2
42436: NEG
42437: PUSH
42438: EMPTY
42439: LIST
42440: LIST
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: LIST
42446: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42447: LD_ADDR_VAR 0 47
42451: PUSH
42452: LD_INT 2
42454: NEG
42455: PUSH
42456: LD_INT 3
42458: NEG
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 1
42466: NEG
42467: PUSH
42468: LD_INT 3
42470: NEG
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: EMPTY
42477: LIST
42478: LIST
42479: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42480: LD_ADDR_VAR 0 48
42484: PUSH
42485: LD_INT 1
42487: PUSH
42488: LD_INT 2
42490: NEG
42491: PUSH
42492: EMPTY
42493: LIST
42494: LIST
42495: PUSH
42496: LD_INT 2
42498: PUSH
42499: LD_INT 1
42501: NEG
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42511: LD_ADDR_VAR 0 49
42515: PUSH
42516: LD_INT 3
42518: PUSH
42519: LD_INT 1
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 3
42528: PUSH
42529: LD_INT 2
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: EMPTY
42537: LIST
42538: LIST
42539: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42540: LD_ADDR_VAR 0 50
42544: PUSH
42545: LD_INT 2
42547: PUSH
42548: LD_INT 3
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 1
42557: PUSH
42558: LD_INT 3
42560: PUSH
42561: EMPTY
42562: LIST
42563: LIST
42564: PUSH
42565: EMPTY
42566: LIST
42567: LIST
42568: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42569: LD_ADDR_VAR 0 51
42573: PUSH
42574: LD_INT 1
42576: NEG
42577: PUSH
42578: LD_INT 2
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 2
42587: NEG
42588: PUSH
42589: LD_INT 1
42591: PUSH
42592: EMPTY
42593: LIST
42594: LIST
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42600: LD_ADDR_VAR 0 52
42604: PUSH
42605: LD_INT 3
42607: NEG
42608: PUSH
42609: LD_INT 1
42611: NEG
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: LD_INT 3
42619: NEG
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42633: LD_ADDR_VAR 0 53
42637: PUSH
42638: LD_INT 1
42640: NEG
42641: PUSH
42642: LD_INT 3
42644: NEG
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 0
42652: PUSH
42653: LD_INT 3
42655: NEG
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 1
42663: PUSH
42664: LD_INT 2
42666: NEG
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PUSH
42672: EMPTY
42673: LIST
42674: LIST
42675: LIST
42676: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42677: LD_ADDR_VAR 0 54
42681: PUSH
42682: LD_INT 2
42684: PUSH
42685: LD_INT 1
42687: NEG
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 3
42695: PUSH
42696: LD_INT 0
42698: PUSH
42699: EMPTY
42700: LIST
42701: LIST
42702: PUSH
42703: LD_INT 3
42705: PUSH
42706: LD_INT 1
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: LIST
42717: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42718: LD_ADDR_VAR 0 55
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: LD_INT 2
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: LD_INT 3
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 2
42745: PUSH
42746: LD_INT 3
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: LIST
42757: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42758: LD_ADDR_VAR 0 56
42762: PUSH
42763: LD_INT 1
42765: PUSH
42766: LD_INT 3
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 0
42775: PUSH
42776: LD_INT 3
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: LD_INT 1
42785: NEG
42786: PUSH
42787: LD_INT 2
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: EMPTY
42795: LIST
42796: LIST
42797: LIST
42798: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42799: LD_ADDR_VAR 0 57
42803: PUSH
42804: LD_INT 2
42806: NEG
42807: PUSH
42808: LD_INT 1
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 3
42817: NEG
42818: PUSH
42819: LD_INT 0
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: LD_INT 3
42828: NEG
42829: PUSH
42830: LD_INT 1
42832: NEG
42833: PUSH
42834: EMPTY
42835: LIST
42836: LIST
42837: PUSH
42838: EMPTY
42839: LIST
42840: LIST
42841: LIST
42842: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42843: LD_ADDR_VAR 0 58
42847: PUSH
42848: LD_INT 2
42850: NEG
42851: PUSH
42852: LD_INT 3
42854: NEG
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 3
42862: NEG
42863: PUSH
42864: LD_INT 2
42866: NEG
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: PUSH
42872: LD_INT 3
42874: NEG
42875: PUSH
42876: LD_INT 3
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: LIST
42888: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42889: LD_ADDR_VAR 0 59
42893: PUSH
42894: LD_INT 1
42896: NEG
42897: PUSH
42898: LD_INT 2
42900: NEG
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 0
42908: PUSH
42909: LD_INT 2
42911: NEG
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 1
42919: PUSH
42920: LD_INT 1
42922: NEG
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42933: LD_ADDR_VAR 0 60
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: LD_INT 1
42943: NEG
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: PUSH
42949: LD_INT 2
42951: PUSH
42952: LD_INT 0
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 2
42961: PUSH
42962: LD_INT 1
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: LIST
42973: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42974: LD_ADDR_VAR 0 61
42978: PUSH
42979: LD_INT 2
42981: PUSH
42982: LD_INT 1
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 2
42991: PUSH
42992: LD_INT 2
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: LD_INT 1
43001: PUSH
43002: LD_INT 2
43004: PUSH
43005: EMPTY
43006: LIST
43007: LIST
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: LIST
43013: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43014: LD_ADDR_VAR 0 62
43018: PUSH
43019: LD_INT 1
43021: PUSH
43022: LD_INT 2
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 0
43031: PUSH
43032: LD_INT 2
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 1
43041: NEG
43042: PUSH
43043: LD_INT 1
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: LIST
43054: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43055: LD_ADDR_VAR 0 63
43059: PUSH
43060: LD_INT 1
43062: NEG
43063: PUSH
43064: LD_INT 1
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 2
43073: NEG
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 2
43084: NEG
43085: PUSH
43086: LD_INT 1
43088: NEG
43089: PUSH
43090: EMPTY
43091: LIST
43092: LIST
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: LIST
43098: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43099: LD_ADDR_VAR 0 64
43103: PUSH
43104: LD_INT 1
43106: NEG
43107: PUSH
43108: LD_INT 2
43110: NEG
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: LD_INT 2
43118: NEG
43119: PUSH
43120: LD_INT 1
43122: NEG
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: PUSH
43128: LD_INT 2
43130: NEG
43131: PUSH
43132: LD_INT 2
43134: NEG
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: LIST
43144: ST_TO_ADDR
// end ; 2 :
43145: GO 46411
43147: LD_INT 2
43149: DOUBLE
43150: EQUAL
43151: IFTRUE 43155
43153: GO 46410
43155: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43156: LD_ADDR_VAR 0 29
43160: PUSH
43161: LD_INT 4
43163: PUSH
43164: LD_INT 0
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: LD_INT 4
43173: PUSH
43174: LD_INT 1
43176: NEG
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: LD_INT 5
43184: PUSH
43185: LD_INT 0
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: PUSH
43192: LD_INT 5
43194: PUSH
43195: LD_INT 1
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: LD_INT 4
43204: PUSH
43205: LD_INT 1
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 3
43214: PUSH
43215: LD_INT 0
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 3
43224: PUSH
43225: LD_INT 1
43227: NEG
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: PUSH
43233: LD_INT 3
43235: PUSH
43236: LD_INT 2
43238: NEG
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 5
43246: PUSH
43247: LD_INT 2
43249: PUSH
43250: EMPTY
43251: LIST
43252: LIST
43253: PUSH
43254: LD_INT 3
43256: PUSH
43257: LD_INT 3
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: PUSH
43264: LD_INT 3
43266: PUSH
43267: LD_INT 2
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: PUSH
43274: LD_INT 4
43276: PUSH
43277: LD_INT 3
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 4
43286: PUSH
43287: LD_INT 4
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 3
43296: PUSH
43297: LD_INT 4
43299: PUSH
43300: EMPTY
43301: LIST
43302: LIST
43303: PUSH
43304: LD_INT 2
43306: PUSH
43307: LD_INT 3
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 2
43316: PUSH
43317: LD_INT 2
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 4
43326: PUSH
43327: LD_INT 2
43329: PUSH
43330: EMPTY
43331: LIST
43332: LIST
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: LD_INT 4
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: LD_INT 4
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 0
43356: PUSH
43357: LD_INT 3
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 1
43366: PUSH
43367: LD_INT 4
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 1
43376: PUSH
43377: LD_INT 5
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 0
43386: PUSH
43387: LD_INT 5
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 1
43396: NEG
43397: PUSH
43398: LD_INT 4
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: LD_INT 1
43407: NEG
43408: PUSH
43409: LD_INT 3
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: PUSH
43416: LD_INT 2
43418: PUSH
43419: LD_INT 5
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 2
43428: NEG
43429: PUSH
43430: LD_INT 3
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 3
43439: NEG
43440: PUSH
43441: LD_INT 0
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 3
43450: NEG
43451: PUSH
43452: LD_INT 1
43454: NEG
43455: PUSH
43456: EMPTY
43457: LIST
43458: LIST
43459: PUSH
43460: LD_INT 2
43462: NEG
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 2
43473: NEG
43474: PUSH
43475: LD_INT 1
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 3
43484: NEG
43485: PUSH
43486: LD_INT 1
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 4
43495: NEG
43496: PUSH
43497: LD_INT 0
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 4
43506: NEG
43507: PUSH
43508: LD_INT 1
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 4
43518: NEG
43519: PUSH
43520: LD_INT 2
43522: NEG
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: LD_INT 2
43530: NEG
43531: PUSH
43532: LD_INT 2
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 4
43541: NEG
43542: PUSH
43543: LD_INT 4
43545: NEG
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: LD_INT 4
43553: NEG
43554: PUSH
43555: LD_INT 5
43557: NEG
43558: PUSH
43559: EMPTY
43560: LIST
43561: LIST
43562: PUSH
43563: LD_INT 3
43565: NEG
43566: PUSH
43567: LD_INT 4
43569: NEG
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 3
43577: NEG
43578: PUSH
43579: LD_INT 3
43581: NEG
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 4
43589: NEG
43590: PUSH
43591: LD_INT 3
43593: NEG
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: LD_INT 5
43601: NEG
43602: PUSH
43603: LD_INT 4
43605: NEG
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 5
43613: NEG
43614: PUSH
43615: LD_INT 5
43617: NEG
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 3
43625: NEG
43626: PUSH
43627: LD_INT 5
43629: NEG
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 5
43637: NEG
43638: PUSH
43639: LD_INT 3
43641: NEG
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: EMPTY
43648: LIST
43649: LIST
43650: LIST
43651: LIST
43652: LIST
43653: LIST
43654: LIST
43655: LIST
43656: LIST
43657: LIST
43658: LIST
43659: LIST
43660: LIST
43661: LIST
43662: LIST
43663: LIST
43664: LIST
43665: LIST
43666: LIST
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: LIST
43674: LIST
43675: LIST
43676: LIST
43677: LIST
43678: LIST
43679: LIST
43680: LIST
43681: LIST
43682: LIST
43683: LIST
43684: LIST
43685: LIST
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43694: LD_ADDR_VAR 0 30
43698: PUSH
43699: LD_INT 4
43701: PUSH
43702: LD_INT 4
43704: PUSH
43705: EMPTY
43706: LIST
43707: LIST
43708: PUSH
43709: LD_INT 4
43711: PUSH
43712: LD_INT 3
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 5
43721: PUSH
43722: LD_INT 4
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 5
43731: PUSH
43732: LD_INT 5
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 4
43741: PUSH
43742: LD_INT 5
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 3
43751: PUSH
43752: LD_INT 4
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 3
43761: PUSH
43762: LD_INT 3
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 5
43771: PUSH
43772: LD_INT 3
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 3
43781: PUSH
43782: LD_INT 5
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 0
43791: PUSH
43792: LD_INT 3
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 0
43801: PUSH
43802: LD_INT 2
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 1
43811: PUSH
43812: LD_INT 3
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 1
43821: PUSH
43822: LD_INT 4
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 0
43831: PUSH
43832: LD_INT 4
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 1
43841: NEG
43842: PUSH
43843: LD_INT 3
43845: PUSH
43846: EMPTY
43847: LIST
43848: LIST
43849: PUSH
43850: LD_INT 1
43852: NEG
43853: PUSH
43854: LD_INT 2
43856: PUSH
43857: EMPTY
43858: LIST
43859: LIST
43860: PUSH
43861: LD_INT 2
43863: PUSH
43864: LD_INT 4
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PUSH
43871: LD_INT 2
43873: NEG
43874: PUSH
43875: LD_INT 2
43877: PUSH
43878: EMPTY
43879: LIST
43880: LIST
43881: PUSH
43882: LD_INT 4
43884: NEG
43885: PUSH
43886: LD_INT 0
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: LD_INT 4
43895: NEG
43896: PUSH
43897: LD_INT 1
43899: NEG
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 3
43918: NEG
43919: PUSH
43920: LD_INT 1
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 4
43929: NEG
43930: PUSH
43931: LD_INT 1
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: PUSH
43938: LD_INT 5
43940: NEG
43941: PUSH
43942: LD_INT 0
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 5
43951: NEG
43952: PUSH
43953: LD_INT 1
43955: NEG
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 5
43963: NEG
43964: PUSH
43965: LD_INT 2
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 3
43975: NEG
43976: PUSH
43977: LD_INT 2
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 3
43986: NEG
43987: PUSH
43988: LD_INT 3
43990: NEG
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 3
43998: NEG
43999: PUSH
44000: LD_INT 4
44002: NEG
44003: PUSH
44004: EMPTY
44005: LIST
44006: LIST
44007: PUSH
44008: LD_INT 2
44010: NEG
44011: PUSH
44012: LD_INT 3
44014: NEG
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 2
44022: NEG
44023: PUSH
44024: LD_INT 2
44026: NEG
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 3
44034: NEG
44035: PUSH
44036: LD_INT 2
44038: NEG
44039: PUSH
44040: EMPTY
44041: LIST
44042: LIST
44043: PUSH
44044: LD_INT 4
44046: NEG
44047: PUSH
44048: LD_INT 3
44050: NEG
44051: PUSH
44052: EMPTY
44053: LIST
44054: LIST
44055: PUSH
44056: LD_INT 4
44058: NEG
44059: PUSH
44060: LD_INT 4
44062: NEG
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 2
44070: NEG
44071: PUSH
44072: LD_INT 4
44074: NEG
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 4
44082: NEG
44083: PUSH
44084: LD_INT 2
44086: NEG
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 0
44094: PUSH
44095: LD_INT 4
44097: NEG
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 0
44105: PUSH
44106: LD_INT 5
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 1
44116: PUSH
44117: LD_INT 4
44119: NEG
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: LD_INT 1
44127: PUSH
44128: LD_INT 3
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 0
44138: PUSH
44139: LD_INT 3
44141: NEG
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: LD_INT 4
44153: NEG
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 1
44161: NEG
44162: PUSH
44163: LD_INT 5
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 2
44173: PUSH
44174: LD_INT 3
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 2
44184: NEG
44185: PUSH
44186: LD_INT 5
44188: NEG
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: LIST
44198: LIST
44199: LIST
44200: LIST
44201: LIST
44202: LIST
44203: LIST
44204: LIST
44205: LIST
44206: LIST
44207: LIST
44208: LIST
44209: LIST
44210: LIST
44211: LIST
44212: LIST
44213: LIST
44214: LIST
44215: LIST
44216: LIST
44217: LIST
44218: LIST
44219: LIST
44220: LIST
44221: LIST
44222: LIST
44223: LIST
44224: LIST
44225: LIST
44226: LIST
44227: LIST
44228: LIST
44229: LIST
44230: LIST
44231: LIST
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44241: LD_ADDR_VAR 0 31
44245: PUSH
44246: LD_INT 0
44248: PUSH
44249: LD_INT 4
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 0
44258: PUSH
44259: LD_INT 3
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 1
44268: PUSH
44269: LD_INT 4
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 1
44278: PUSH
44279: LD_INT 5
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 5
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: NEG
44299: PUSH
44300: LD_INT 4
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: PUSH
44307: LD_INT 1
44309: NEG
44310: PUSH
44311: LD_INT 3
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 2
44320: PUSH
44321: LD_INT 5
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: NEG
44331: PUSH
44332: LD_INT 3
44334: PUSH
44335: EMPTY
44336: LIST
44337: LIST
44338: PUSH
44339: LD_INT 3
44341: NEG
44342: PUSH
44343: LD_INT 0
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 3
44352: NEG
44353: PUSH
44354: LD_INT 1
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 2
44364: NEG
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 2
44375: NEG
44376: PUSH
44377: LD_INT 1
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 3
44386: NEG
44387: PUSH
44388: LD_INT 1
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 4
44397: NEG
44398: PUSH
44399: LD_INT 0
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 4
44408: NEG
44409: PUSH
44410: LD_INT 1
44412: NEG
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 4
44420: NEG
44421: PUSH
44422: LD_INT 2
44424: NEG
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 2
44432: NEG
44433: PUSH
44434: LD_INT 2
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 4
44443: NEG
44444: PUSH
44445: LD_INT 4
44447: NEG
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: LD_INT 4
44455: NEG
44456: PUSH
44457: LD_INT 5
44459: NEG
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 3
44467: NEG
44468: PUSH
44469: LD_INT 4
44471: NEG
44472: PUSH
44473: EMPTY
44474: LIST
44475: LIST
44476: PUSH
44477: LD_INT 3
44479: NEG
44480: PUSH
44481: LD_INT 3
44483: NEG
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: PUSH
44489: LD_INT 4
44491: NEG
44492: PUSH
44493: LD_INT 3
44495: NEG
44496: PUSH
44497: EMPTY
44498: LIST
44499: LIST
44500: PUSH
44501: LD_INT 5
44503: NEG
44504: PUSH
44505: LD_INT 4
44507: NEG
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 5
44515: NEG
44516: PUSH
44517: LD_INT 5
44519: NEG
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 3
44527: NEG
44528: PUSH
44529: LD_INT 5
44531: NEG
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 5
44539: NEG
44540: PUSH
44541: LD_INT 3
44543: NEG
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 0
44551: PUSH
44552: LD_INT 3
44554: NEG
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 0
44562: PUSH
44563: LD_INT 4
44565: NEG
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 1
44573: PUSH
44574: LD_INT 3
44576: NEG
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 1
44584: PUSH
44585: LD_INT 2
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 0
44595: PUSH
44596: LD_INT 2
44598: NEG
44599: PUSH
44600: EMPTY
44601: LIST
44602: LIST
44603: PUSH
44604: LD_INT 1
44606: NEG
44607: PUSH
44608: LD_INT 3
44610: NEG
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 1
44618: NEG
44619: PUSH
44620: LD_INT 4
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 2
44630: PUSH
44631: LD_INT 2
44633: NEG
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 2
44641: NEG
44642: PUSH
44643: LD_INT 4
44645: NEG
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 4
44653: PUSH
44654: LD_INT 0
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 4
44663: PUSH
44664: LD_INT 1
44666: NEG
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 5
44674: PUSH
44675: LD_INT 0
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: PUSH
44682: LD_INT 5
44684: PUSH
44685: LD_INT 1
44687: PUSH
44688: EMPTY
44689: LIST
44690: LIST
44691: PUSH
44692: LD_INT 4
44694: PUSH
44695: LD_INT 1
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 3
44704: PUSH
44705: LD_INT 0
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 3
44714: PUSH
44715: LD_INT 1
44717: NEG
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 3
44725: PUSH
44726: LD_INT 2
44728: NEG
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 5
44736: PUSH
44737: LD_INT 2
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: EMPTY
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: LIST
44755: LIST
44756: LIST
44757: LIST
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: LIST
44763: LIST
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44791: LD_ADDR_VAR 0 32
44795: PUSH
44796: LD_INT 4
44798: NEG
44799: PUSH
44800: LD_INT 0
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 4
44809: NEG
44810: PUSH
44811: LD_INT 1
44813: NEG
44814: PUSH
44815: EMPTY
44816: LIST
44817: LIST
44818: PUSH
44819: LD_INT 3
44821: NEG
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 3
44832: NEG
44833: PUSH
44834: LD_INT 1
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 4
44843: NEG
44844: PUSH
44845: LD_INT 1
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 5
44854: NEG
44855: PUSH
44856: LD_INT 0
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: LD_INT 5
44865: NEG
44866: PUSH
44867: LD_INT 1
44869: NEG
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 5
44877: NEG
44878: PUSH
44879: LD_INT 2
44881: NEG
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PUSH
44887: LD_INT 3
44889: NEG
44890: PUSH
44891: LD_INT 2
44893: PUSH
44894: EMPTY
44895: LIST
44896: LIST
44897: PUSH
44898: LD_INT 3
44900: NEG
44901: PUSH
44902: LD_INT 3
44904: NEG
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 3
44912: NEG
44913: PUSH
44914: LD_INT 4
44916: NEG
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 2
44924: NEG
44925: PUSH
44926: LD_INT 3
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 2
44936: NEG
44937: PUSH
44938: LD_INT 2
44940: NEG
44941: PUSH
44942: EMPTY
44943: LIST
44944: LIST
44945: PUSH
44946: LD_INT 3
44948: NEG
44949: PUSH
44950: LD_INT 2
44952: NEG
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 4
44960: NEG
44961: PUSH
44962: LD_INT 3
44964: NEG
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 4
44972: NEG
44973: PUSH
44974: LD_INT 4
44976: NEG
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 2
44984: NEG
44985: PUSH
44986: LD_INT 4
44988: NEG
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 4
44996: NEG
44997: PUSH
44998: LD_INT 2
45000: NEG
45001: PUSH
45002: EMPTY
45003: LIST
45004: LIST
45005: PUSH
45006: LD_INT 0
45008: PUSH
45009: LD_INT 4
45011: NEG
45012: PUSH
45013: EMPTY
45014: LIST
45015: LIST
45016: PUSH
45017: LD_INT 0
45019: PUSH
45020: LD_INT 5
45022: NEG
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 1
45030: PUSH
45031: LD_INT 4
45033: NEG
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: PUSH
45039: LD_INT 1
45041: PUSH
45042: LD_INT 3
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 0
45052: PUSH
45053: LD_INT 3
45055: NEG
45056: PUSH
45057: EMPTY
45058: LIST
45059: LIST
45060: PUSH
45061: LD_INT 1
45063: NEG
45064: PUSH
45065: LD_INT 4
45067: NEG
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 1
45075: NEG
45076: PUSH
45077: LD_INT 5
45079: NEG
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 2
45087: PUSH
45088: LD_INT 3
45090: NEG
45091: PUSH
45092: EMPTY
45093: LIST
45094: LIST
45095: PUSH
45096: LD_INT 2
45098: NEG
45099: PUSH
45100: LD_INT 5
45102: NEG
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: PUSH
45108: LD_INT 3
45110: PUSH
45111: LD_INT 0
45113: PUSH
45114: EMPTY
45115: LIST
45116: LIST
45117: PUSH
45118: LD_INT 3
45120: PUSH
45121: LD_INT 1
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 4
45131: PUSH
45132: LD_INT 0
45134: PUSH
45135: EMPTY
45136: LIST
45137: LIST
45138: PUSH
45139: LD_INT 4
45141: PUSH
45142: LD_INT 1
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 3
45151: PUSH
45152: LD_INT 1
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 2
45161: PUSH
45162: LD_INT 0
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 2
45171: PUSH
45172: LD_INT 1
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 2
45182: PUSH
45183: LD_INT 2
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 4
45193: PUSH
45194: LD_INT 2
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 4
45203: PUSH
45204: LD_INT 4
45206: PUSH
45207: EMPTY
45208: LIST
45209: LIST
45210: PUSH
45211: LD_INT 4
45213: PUSH
45214: LD_INT 3
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 5
45223: PUSH
45224: LD_INT 4
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 5
45233: PUSH
45234: LD_INT 5
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 4
45243: PUSH
45244: LD_INT 5
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: LD_INT 3
45253: PUSH
45254: LD_INT 4
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 3
45263: PUSH
45264: LD_INT 3
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 5
45273: PUSH
45274: LD_INT 3
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 5
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: EMPTY
45292: LIST
45293: LIST
45294: LIST
45295: LIST
45296: LIST
45297: LIST
45298: LIST
45299: LIST
45300: LIST
45301: LIST
45302: LIST
45303: LIST
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: LIST
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45338: LD_ADDR_VAR 0 33
45342: PUSH
45343: LD_INT 4
45345: NEG
45346: PUSH
45347: LD_INT 4
45349: NEG
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 4
45357: NEG
45358: PUSH
45359: LD_INT 5
45361: NEG
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 3
45369: NEG
45370: PUSH
45371: LD_INT 4
45373: NEG
45374: PUSH
45375: EMPTY
45376: LIST
45377: LIST
45378: PUSH
45379: LD_INT 3
45381: NEG
45382: PUSH
45383: LD_INT 3
45385: NEG
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 4
45393: NEG
45394: PUSH
45395: LD_INT 3
45397: NEG
45398: PUSH
45399: EMPTY
45400: LIST
45401: LIST
45402: PUSH
45403: LD_INT 5
45405: NEG
45406: PUSH
45407: LD_INT 4
45409: NEG
45410: PUSH
45411: EMPTY
45412: LIST
45413: LIST
45414: PUSH
45415: LD_INT 5
45417: NEG
45418: PUSH
45419: LD_INT 5
45421: NEG
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 3
45429: NEG
45430: PUSH
45431: LD_INT 5
45433: NEG
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 5
45441: NEG
45442: PUSH
45443: LD_INT 3
45445: NEG
45446: PUSH
45447: EMPTY
45448: LIST
45449: LIST
45450: PUSH
45451: LD_INT 0
45453: PUSH
45454: LD_INT 3
45456: NEG
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 0
45464: PUSH
45465: LD_INT 4
45467: NEG
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 1
45475: PUSH
45476: LD_INT 3
45478: NEG
45479: PUSH
45480: EMPTY
45481: LIST
45482: LIST
45483: PUSH
45484: LD_INT 1
45486: PUSH
45487: LD_INT 2
45489: NEG
45490: PUSH
45491: EMPTY
45492: LIST
45493: LIST
45494: PUSH
45495: LD_INT 0
45497: PUSH
45498: LD_INT 2
45500: NEG
45501: PUSH
45502: EMPTY
45503: LIST
45504: LIST
45505: PUSH
45506: LD_INT 1
45508: NEG
45509: PUSH
45510: LD_INT 3
45512: NEG
45513: PUSH
45514: EMPTY
45515: LIST
45516: LIST
45517: PUSH
45518: LD_INT 1
45520: NEG
45521: PUSH
45522: LD_INT 4
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 2
45532: PUSH
45533: LD_INT 2
45535: NEG
45536: PUSH
45537: EMPTY
45538: LIST
45539: LIST
45540: PUSH
45541: LD_INT 2
45543: NEG
45544: PUSH
45545: LD_INT 4
45547: NEG
45548: PUSH
45549: EMPTY
45550: LIST
45551: LIST
45552: PUSH
45553: LD_INT 4
45555: PUSH
45556: LD_INT 0
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: PUSH
45563: LD_INT 4
45565: PUSH
45566: LD_INT 1
45568: NEG
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 5
45576: PUSH
45577: LD_INT 0
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: PUSH
45584: LD_INT 5
45586: PUSH
45587: LD_INT 1
45589: PUSH
45590: EMPTY
45591: LIST
45592: LIST
45593: PUSH
45594: LD_INT 4
45596: PUSH
45597: LD_INT 1
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 3
45606: PUSH
45607: LD_INT 0
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 3
45616: PUSH
45617: LD_INT 1
45619: NEG
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 3
45627: PUSH
45628: LD_INT 2
45630: NEG
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: LD_INT 5
45638: PUSH
45639: LD_INT 2
45641: PUSH
45642: EMPTY
45643: LIST
45644: LIST
45645: PUSH
45646: LD_INT 3
45648: PUSH
45649: LD_INT 3
45651: PUSH
45652: EMPTY
45653: LIST
45654: LIST
45655: PUSH
45656: LD_INT 3
45658: PUSH
45659: LD_INT 2
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 4
45668: PUSH
45669: LD_INT 3
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 4
45678: PUSH
45679: LD_INT 4
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 3
45688: PUSH
45689: LD_INT 4
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 2
45698: PUSH
45699: LD_INT 3
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 2
45708: PUSH
45709: LD_INT 2
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 4
45718: PUSH
45719: LD_INT 2
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 2
45728: PUSH
45729: LD_INT 4
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 0
45738: PUSH
45739: LD_INT 4
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 0
45748: PUSH
45749: LD_INT 3
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 1
45758: PUSH
45759: LD_INT 4
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 1
45768: PUSH
45769: LD_INT 5
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 0
45778: PUSH
45779: LD_INT 5
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 1
45788: NEG
45789: PUSH
45790: LD_INT 4
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: NEG
45800: PUSH
45801: LD_INT 3
45803: PUSH
45804: EMPTY
45805: LIST
45806: LIST
45807: PUSH
45808: LD_INT 2
45810: PUSH
45811: LD_INT 5
45813: PUSH
45814: EMPTY
45815: LIST
45816: LIST
45817: PUSH
45818: LD_INT 2
45820: NEG
45821: PUSH
45822: LD_INT 3
45824: PUSH
45825: EMPTY
45826: LIST
45827: LIST
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: LIST
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: LIST
45838: LIST
45839: LIST
45840: LIST
45841: LIST
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45876: LD_ADDR_VAR 0 34
45880: PUSH
45881: LD_INT 0
45883: PUSH
45884: LD_INT 4
45886: NEG
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: LD_INT 0
45894: PUSH
45895: LD_INT 5
45897: NEG
45898: PUSH
45899: EMPTY
45900: LIST
45901: LIST
45902: PUSH
45903: LD_INT 1
45905: PUSH
45906: LD_INT 4
45908: NEG
45909: PUSH
45910: EMPTY
45911: LIST
45912: LIST
45913: PUSH
45914: LD_INT 1
45916: PUSH
45917: LD_INT 3
45919: NEG
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: LD_INT 0
45927: PUSH
45928: LD_INT 3
45930: NEG
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 1
45938: NEG
45939: PUSH
45940: LD_INT 4
45942: NEG
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 1
45950: NEG
45951: PUSH
45952: LD_INT 5
45954: NEG
45955: PUSH
45956: EMPTY
45957: LIST
45958: LIST
45959: PUSH
45960: LD_INT 2
45962: PUSH
45963: LD_INT 3
45965: NEG
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PUSH
45971: LD_INT 2
45973: NEG
45974: PUSH
45975: LD_INT 5
45977: NEG
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PUSH
45983: LD_INT 3
45985: PUSH
45986: LD_INT 0
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: PUSH
45993: LD_INT 3
45995: PUSH
45996: LD_INT 1
45998: NEG
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: LD_INT 4
46006: PUSH
46007: LD_INT 0
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: PUSH
46014: LD_INT 4
46016: PUSH
46017: LD_INT 1
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 3
46026: PUSH
46027: LD_INT 1
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: LD_INT 2
46036: PUSH
46037: LD_INT 0
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 2
46046: PUSH
46047: LD_INT 1
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 2
46057: PUSH
46058: LD_INT 2
46060: NEG
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 4
46068: PUSH
46069: LD_INT 2
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: PUSH
46076: LD_INT 4
46078: PUSH
46079: LD_INT 4
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: PUSH
46086: LD_INT 4
46088: PUSH
46089: LD_INT 3
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 5
46098: PUSH
46099: LD_INT 4
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 5
46108: PUSH
46109: LD_INT 5
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 4
46118: PUSH
46119: LD_INT 5
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 3
46128: PUSH
46129: LD_INT 4
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 3
46138: PUSH
46139: LD_INT 3
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 5
46148: PUSH
46149: LD_INT 3
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 3
46158: PUSH
46159: LD_INT 5
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PUSH
46166: LD_INT 0
46168: PUSH
46169: LD_INT 3
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 0
46178: PUSH
46179: LD_INT 2
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: LD_INT 1
46188: PUSH
46189: LD_INT 3
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 1
46198: PUSH
46199: LD_INT 4
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: PUSH
46206: LD_INT 0
46208: PUSH
46209: LD_INT 4
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PUSH
46216: LD_INT 1
46218: NEG
46219: PUSH
46220: LD_INT 3
46222: PUSH
46223: EMPTY
46224: LIST
46225: LIST
46226: PUSH
46227: LD_INT 1
46229: NEG
46230: PUSH
46231: LD_INT 2
46233: PUSH
46234: EMPTY
46235: LIST
46236: LIST
46237: PUSH
46238: LD_INT 2
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 2
46250: NEG
46251: PUSH
46252: LD_INT 2
46254: PUSH
46255: EMPTY
46256: LIST
46257: LIST
46258: PUSH
46259: LD_INT 4
46261: NEG
46262: PUSH
46263: LD_INT 0
46265: PUSH
46266: EMPTY
46267: LIST
46268: LIST
46269: PUSH
46270: LD_INT 4
46272: NEG
46273: PUSH
46274: LD_INT 1
46276: NEG
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: PUSH
46282: LD_INT 3
46284: NEG
46285: PUSH
46286: LD_INT 0
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 3
46295: NEG
46296: PUSH
46297: LD_INT 1
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 4
46306: NEG
46307: PUSH
46308: LD_INT 1
46310: PUSH
46311: EMPTY
46312: LIST
46313: LIST
46314: PUSH
46315: LD_INT 5
46317: NEG
46318: PUSH
46319: LD_INT 0
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 5
46328: NEG
46329: PUSH
46330: LD_INT 1
46332: NEG
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 5
46340: NEG
46341: PUSH
46342: LD_INT 2
46344: NEG
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: PUSH
46350: LD_INT 3
46352: NEG
46353: PUSH
46354: LD_INT 2
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: LIST
46366: LIST
46367: LIST
46368: LIST
46369: LIST
46370: LIST
46371: LIST
46372: LIST
46373: LIST
46374: LIST
46375: LIST
46376: LIST
46377: LIST
46378: LIST
46379: LIST
46380: LIST
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: ST_TO_ADDR
// end ; end ;
46408: GO 46411
46410: POP
// case btype of b_depot , b_warehouse :
46411: LD_VAR 0 1
46415: PUSH
46416: LD_INT 0
46418: DOUBLE
46419: EQUAL
46420: IFTRUE 46430
46422: LD_INT 1
46424: DOUBLE
46425: EQUAL
46426: IFTRUE 46430
46428: GO 46631
46430: POP
// case nation of nation_american :
46431: LD_VAR 0 5
46435: PUSH
46436: LD_INT 1
46438: DOUBLE
46439: EQUAL
46440: IFTRUE 46444
46442: GO 46500
46444: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46445: LD_ADDR_VAR 0 9
46449: PUSH
46450: LD_VAR 0 11
46454: PUSH
46455: LD_VAR 0 12
46459: PUSH
46460: LD_VAR 0 13
46464: PUSH
46465: LD_VAR 0 14
46469: PUSH
46470: LD_VAR 0 15
46474: PUSH
46475: LD_VAR 0 16
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: LIST
46484: LIST
46485: LIST
46486: LIST
46487: PUSH
46488: LD_VAR 0 4
46492: PUSH
46493: LD_INT 1
46495: PLUS
46496: ARRAY
46497: ST_TO_ADDR
46498: GO 46629
46500: LD_INT 2
46502: DOUBLE
46503: EQUAL
46504: IFTRUE 46508
46506: GO 46564
46508: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46509: LD_ADDR_VAR 0 9
46513: PUSH
46514: LD_VAR 0 17
46518: PUSH
46519: LD_VAR 0 18
46523: PUSH
46524: LD_VAR 0 19
46528: PUSH
46529: LD_VAR 0 20
46533: PUSH
46534: LD_VAR 0 21
46538: PUSH
46539: LD_VAR 0 22
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: PUSH
46552: LD_VAR 0 4
46556: PUSH
46557: LD_INT 1
46559: PLUS
46560: ARRAY
46561: ST_TO_ADDR
46562: GO 46629
46564: LD_INT 3
46566: DOUBLE
46567: EQUAL
46568: IFTRUE 46572
46570: GO 46628
46572: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46573: LD_ADDR_VAR 0 9
46577: PUSH
46578: LD_VAR 0 23
46582: PUSH
46583: LD_VAR 0 24
46587: PUSH
46588: LD_VAR 0 25
46592: PUSH
46593: LD_VAR 0 26
46597: PUSH
46598: LD_VAR 0 27
46602: PUSH
46603: LD_VAR 0 28
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: PUSH
46616: LD_VAR 0 4
46620: PUSH
46621: LD_INT 1
46623: PLUS
46624: ARRAY
46625: ST_TO_ADDR
46626: GO 46629
46628: POP
46629: GO 47178
46631: LD_INT 2
46633: DOUBLE
46634: EQUAL
46635: IFTRUE 46645
46637: LD_INT 3
46639: DOUBLE
46640: EQUAL
46641: IFTRUE 46645
46643: GO 46701
46645: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46646: LD_ADDR_VAR 0 9
46650: PUSH
46651: LD_VAR 0 29
46655: PUSH
46656: LD_VAR 0 30
46660: PUSH
46661: LD_VAR 0 31
46665: PUSH
46666: LD_VAR 0 32
46670: PUSH
46671: LD_VAR 0 33
46675: PUSH
46676: LD_VAR 0 34
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: PUSH
46689: LD_VAR 0 4
46693: PUSH
46694: LD_INT 1
46696: PLUS
46697: ARRAY
46698: ST_TO_ADDR
46699: GO 47178
46701: LD_INT 16
46703: DOUBLE
46704: EQUAL
46705: IFTRUE 46757
46707: LD_INT 17
46709: DOUBLE
46710: EQUAL
46711: IFTRUE 46757
46713: LD_INT 18
46715: DOUBLE
46716: EQUAL
46717: IFTRUE 46757
46719: LD_INT 19
46721: DOUBLE
46722: EQUAL
46723: IFTRUE 46757
46725: LD_INT 20
46727: DOUBLE
46728: EQUAL
46729: IFTRUE 46757
46731: LD_INT 21
46733: DOUBLE
46734: EQUAL
46735: IFTRUE 46757
46737: LD_INT 23
46739: DOUBLE
46740: EQUAL
46741: IFTRUE 46757
46743: LD_INT 24
46745: DOUBLE
46746: EQUAL
46747: IFTRUE 46757
46749: LD_INT 25
46751: DOUBLE
46752: EQUAL
46753: IFTRUE 46757
46755: GO 46813
46757: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46758: LD_ADDR_VAR 0 9
46762: PUSH
46763: LD_VAR 0 35
46767: PUSH
46768: LD_VAR 0 36
46772: PUSH
46773: LD_VAR 0 37
46777: PUSH
46778: LD_VAR 0 38
46782: PUSH
46783: LD_VAR 0 39
46787: PUSH
46788: LD_VAR 0 40
46792: PUSH
46793: EMPTY
46794: LIST
46795: LIST
46796: LIST
46797: LIST
46798: LIST
46799: LIST
46800: PUSH
46801: LD_VAR 0 4
46805: PUSH
46806: LD_INT 1
46808: PLUS
46809: ARRAY
46810: ST_TO_ADDR
46811: GO 47178
46813: LD_INT 6
46815: DOUBLE
46816: EQUAL
46817: IFTRUE 46869
46819: LD_INT 7
46821: DOUBLE
46822: EQUAL
46823: IFTRUE 46869
46825: LD_INT 8
46827: DOUBLE
46828: EQUAL
46829: IFTRUE 46869
46831: LD_INT 13
46833: DOUBLE
46834: EQUAL
46835: IFTRUE 46869
46837: LD_INT 12
46839: DOUBLE
46840: EQUAL
46841: IFTRUE 46869
46843: LD_INT 15
46845: DOUBLE
46846: EQUAL
46847: IFTRUE 46869
46849: LD_INT 11
46851: DOUBLE
46852: EQUAL
46853: IFTRUE 46869
46855: LD_INT 14
46857: DOUBLE
46858: EQUAL
46859: IFTRUE 46869
46861: LD_INT 10
46863: DOUBLE
46864: EQUAL
46865: IFTRUE 46869
46867: GO 46925
46869: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46870: LD_ADDR_VAR 0 9
46874: PUSH
46875: LD_VAR 0 41
46879: PUSH
46880: LD_VAR 0 42
46884: PUSH
46885: LD_VAR 0 43
46889: PUSH
46890: LD_VAR 0 44
46894: PUSH
46895: LD_VAR 0 45
46899: PUSH
46900: LD_VAR 0 46
46904: PUSH
46905: EMPTY
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: PUSH
46913: LD_VAR 0 4
46917: PUSH
46918: LD_INT 1
46920: PLUS
46921: ARRAY
46922: ST_TO_ADDR
46923: GO 47178
46925: LD_INT 36
46927: DOUBLE
46928: EQUAL
46929: IFTRUE 46933
46931: GO 46989
46933: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46934: LD_ADDR_VAR 0 9
46938: PUSH
46939: LD_VAR 0 47
46943: PUSH
46944: LD_VAR 0 48
46948: PUSH
46949: LD_VAR 0 49
46953: PUSH
46954: LD_VAR 0 50
46958: PUSH
46959: LD_VAR 0 51
46963: PUSH
46964: LD_VAR 0 52
46968: PUSH
46969: EMPTY
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: PUSH
46977: LD_VAR 0 4
46981: PUSH
46982: LD_INT 1
46984: PLUS
46985: ARRAY
46986: ST_TO_ADDR
46987: GO 47178
46989: LD_INT 4
46991: DOUBLE
46992: EQUAL
46993: IFTRUE 47015
46995: LD_INT 5
46997: DOUBLE
46998: EQUAL
46999: IFTRUE 47015
47001: LD_INT 34
47003: DOUBLE
47004: EQUAL
47005: IFTRUE 47015
47007: LD_INT 37
47009: DOUBLE
47010: EQUAL
47011: IFTRUE 47015
47013: GO 47071
47015: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47016: LD_ADDR_VAR 0 9
47020: PUSH
47021: LD_VAR 0 53
47025: PUSH
47026: LD_VAR 0 54
47030: PUSH
47031: LD_VAR 0 55
47035: PUSH
47036: LD_VAR 0 56
47040: PUSH
47041: LD_VAR 0 57
47045: PUSH
47046: LD_VAR 0 58
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: LIST
47055: LIST
47056: LIST
47057: LIST
47058: PUSH
47059: LD_VAR 0 4
47063: PUSH
47064: LD_INT 1
47066: PLUS
47067: ARRAY
47068: ST_TO_ADDR
47069: GO 47178
47071: LD_INT 31
47073: DOUBLE
47074: EQUAL
47075: IFTRUE 47121
47077: LD_INT 32
47079: DOUBLE
47080: EQUAL
47081: IFTRUE 47121
47083: LD_INT 33
47085: DOUBLE
47086: EQUAL
47087: IFTRUE 47121
47089: LD_INT 27
47091: DOUBLE
47092: EQUAL
47093: IFTRUE 47121
47095: LD_INT 26
47097: DOUBLE
47098: EQUAL
47099: IFTRUE 47121
47101: LD_INT 28
47103: DOUBLE
47104: EQUAL
47105: IFTRUE 47121
47107: LD_INT 29
47109: DOUBLE
47110: EQUAL
47111: IFTRUE 47121
47113: LD_INT 30
47115: DOUBLE
47116: EQUAL
47117: IFTRUE 47121
47119: GO 47177
47121: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47122: LD_ADDR_VAR 0 9
47126: PUSH
47127: LD_VAR 0 59
47131: PUSH
47132: LD_VAR 0 60
47136: PUSH
47137: LD_VAR 0 61
47141: PUSH
47142: LD_VAR 0 62
47146: PUSH
47147: LD_VAR 0 63
47151: PUSH
47152: LD_VAR 0 64
47156: PUSH
47157: EMPTY
47158: LIST
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: PUSH
47165: LD_VAR 0 4
47169: PUSH
47170: LD_INT 1
47172: PLUS
47173: ARRAY
47174: ST_TO_ADDR
47175: GO 47178
47177: POP
// temp_list2 = [ ] ;
47178: LD_ADDR_VAR 0 10
47182: PUSH
47183: EMPTY
47184: ST_TO_ADDR
// for i in temp_list do
47185: LD_ADDR_VAR 0 8
47189: PUSH
47190: LD_VAR 0 9
47194: PUSH
47195: FOR_IN
47196: IFFALSE 47248
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47198: LD_ADDR_VAR 0 10
47202: PUSH
47203: LD_VAR 0 10
47207: PUSH
47208: LD_VAR 0 8
47212: PUSH
47213: LD_INT 1
47215: ARRAY
47216: PUSH
47217: LD_VAR 0 2
47221: PLUS
47222: PUSH
47223: LD_VAR 0 8
47227: PUSH
47228: LD_INT 2
47230: ARRAY
47231: PUSH
47232: LD_VAR 0 3
47236: PLUS
47237: PUSH
47238: EMPTY
47239: LIST
47240: LIST
47241: PUSH
47242: EMPTY
47243: LIST
47244: ADD
47245: ST_TO_ADDR
47246: GO 47195
47248: POP
47249: POP
// result = temp_list2 ;
47250: LD_ADDR_VAR 0 7
47254: PUSH
47255: LD_VAR 0 10
47259: ST_TO_ADDR
// end ;
47260: LD_VAR 0 7
47264: RET
// export function EnemyInRange ( unit , dist ) ; begin
47265: LD_INT 0
47267: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47268: LD_ADDR_VAR 0 3
47272: PUSH
47273: LD_VAR 0 1
47277: PPUSH
47278: CALL_OW 255
47282: PPUSH
47283: LD_VAR 0 1
47287: PPUSH
47288: CALL_OW 250
47292: PPUSH
47293: LD_VAR 0 1
47297: PPUSH
47298: CALL_OW 251
47302: PPUSH
47303: LD_VAR 0 2
47307: PPUSH
47308: CALL 21393 0 4
47312: PUSH
47313: LD_INT 4
47315: ARRAY
47316: ST_TO_ADDR
// end ;
47317: LD_VAR 0 3
47321: RET
// export function PlayerSeeMe ( unit ) ; begin
47322: LD_INT 0
47324: PPUSH
// result := See ( your_side , unit ) ;
47325: LD_ADDR_VAR 0 2
47329: PUSH
47330: LD_OWVAR 2
47334: PPUSH
47335: LD_VAR 0 1
47339: PPUSH
47340: CALL_OW 292
47344: ST_TO_ADDR
// end ;
47345: LD_VAR 0 2
47349: RET
// export function ReverseDir ( unit ) ; begin
47350: LD_INT 0
47352: PPUSH
// if not unit then
47353: LD_VAR 0 1
47357: NOT
47358: IFFALSE 47362
// exit ;
47360: GO 47408
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47362: LD_ADDR_VAR 0 2
47366: PUSH
47367: LD_INT 3
47369: PUSH
47370: LD_INT 4
47372: PUSH
47373: LD_INT 5
47375: PUSH
47376: LD_INT 0
47378: PUSH
47379: LD_INT 1
47381: PUSH
47382: LD_INT 2
47384: PUSH
47385: EMPTY
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: PUSH
47393: LD_VAR 0 1
47397: PPUSH
47398: CALL_OW 254
47402: PUSH
47403: LD_INT 1
47405: PLUS
47406: ARRAY
47407: ST_TO_ADDR
// end ;
47408: LD_VAR 0 2
47412: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47413: LD_INT 0
47415: PPUSH
47416: PPUSH
47417: PPUSH
47418: PPUSH
47419: PPUSH
// if not hexes then
47420: LD_VAR 0 2
47424: NOT
47425: IFFALSE 47429
// exit ;
47427: GO 47577
// dist := 9999 ;
47429: LD_ADDR_VAR 0 5
47433: PUSH
47434: LD_INT 9999
47436: ST_TO_ADDR
// for i = 1 to hexes do
47437: LD_ADDR_VAR 0 4
47441: PUSH
47442: DOUBLE
47443: LD_INT 1
47445: DEC
47446: ST_TO_ADDR
47447: LD_VAR 0 2
47451: PUSH
47452: FOR_TO
47453: IFFALSE 47565
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47455: LD_VAR 0 1
47459: PPUSH
47460: LD_VAR 0 2
47464: PUSH
47465: LD_VAR 0 4
47469: ARRAY
47470: PUSH
47471: LD_INT 1
47473: ARRAY
47474: PPUSH
47475: LD_VAR 0 2
47479: PUSH
47480: LD_VAR 0 4
47484: ARRAY
47485: PUSH
47486: LD_INT 2
47488: ARRAY
47489: PPUSH
47490: CALL_OW 297
47494: PUSH
47495: LD_VAR 0 5
47499: LESS
47500: IFFALSE 47563
// begin hex := hexes [ i ] ;
47502: LD_ADDR_VAR 0 7
47506: PUSH
47507: LD_VAR 0 2
47511: PUSH
47512: LD_VAR 0 4
47516: ARRAY
47517: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47518: LD_ADDR_VAR 0 5
47522: PUSH
47523: LD_VAR 0 1
47527: PPUSH
47528: LD_VAR 0 2
47532: PUSH
47533: LD_VAR 0 4
47537: ARRAY
47538: PUSH
47539: LD_INT 1
47541: ARRAY
47542: PPUSH
47543: LD_VAR 0 2
47547: PUSH
47548: LD_VAR 0 4
47552: ARRAY
47553: PUSH
47554: LD_INT 2
47556: ARRAY
47557: PPUSH
47558: CALL_OW 297
47562: ST_TO_ADDR
// end ; end ;
47563: GO 47452
47565: POP
47566: POP
// result := hex ;
47567: LD_ADDR_VAR 0 3
47571: PUSH
47572: LD_VAR 0 7
47576: ST_TO_ADDR
// end ;
47577: LD_VAR 0 3
47581: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47582: LD_INT 0
47584: PPUSH
47585: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47586: LD_VAR 0 1
47590: NOT
47591: PUSH
47592: LD_VAR 0 1
47596: PUSH
47597: LD_INT 21
47599: PUSH
47600: LD_INT 2
47602: PUSH
47603: EMPTY
47604: LIST
47605: LIST
47606: PUSH
47607: LD_INT 23
47609: PUSH
47610: LD_INT 2
47612: PUSH
47613: EMPTY
47614: LIST
47615: LIST
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PPUSH
47621: CALL_OW 69
47625: IN
47626: NOT
47627: OR
47628: IFFALSE 47632
// exit ;
47630: GO 47679
// for i = 1 to 3 do
47632: LD_ADDR_VAR 0 3
47636: PUSH
47637: DOUBLE
47638: LD_INT 1
47640: DEC
47641: ST_TO_ADDR
47642: LD_INT 3
47644: PUSH
47645: FOR_TO
47646: IFFALSE 47677
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47648: LD_VAR 0 1
47652: PPUSH
47653: CALL_OW 250
47657: PPUSH
47658: LD_VAR 0 1
47662: PPUSH
47663: CALL_OW 251
47667: PPUSH
47668: LD_INT 1
47670: PPUSH
47671: CALL_OW 453
47675: GO 47645
47677: POP
47678: POP
// end ;
47679: LD_VAR 0 2
47683: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47684: LD_INT 0
47686: PPUSH
47687: PPUSH
47688: PPUSH
47689: PPUSH
47690: PPUSH
47691: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47692: LD_VAR 0 1
47696: NOT
47697: PUSH
47698: LD_VAR 0 2
47702: NOT
47703: OR
47704: PUSH
47705: LD_VAR 0 1
47709: PPUSH
47710: CALL_OW 314
47714: OR
47715: IFFALSE 47719
// exit ;
47717: GO 48160
// x := GetX ( enemy_unit ) ;
47719: LD_ADDR_VAR 0 7
47723: PUSH
47724: LD_VAR 0 2
47728: PPUSH
47729: CALL_OW 250
47733: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47734: LD_ADDR_VAR 0 8
47738: PUSH
47739: LD_VAR 0 2
47743: PPUSH
47744: CALL_OW 251
47748: ST_TO_ADDR
// if not x or not y then
47749: LD_VAR 0 7
47753: NOT
47754: PUSH
47755: LD_VAR 0 8
47759: NOT
47760: OR
47761: IFFALSE 47765
// exit ;
47763: GO 48160
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47765: LD_ADDR_VAR 0 6
47769: PUSH
47770: LD_VAR 0 7
47774: PPUSH
47775: LD_INT 0
47777: PPUSH
47778: LD_INT 4
47780: PPUSH
47781: CALL_OW 272
47785: PUSH
47786: LD_VAR 0 8
47790: PPUSH
47791: LD_INT 0
47793: PPUSH
47794: LD_INT 4
47796: PPUSH
47797: CALL_OW 273
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: PUSH
47806: LD_VAR 0 7
47810: PPUSH
47811: LD_INT 1
47813: PPUSH
47814: LD_INT 4
47816: PPUSH
47817: CALL_OW 272
47821: PUSH
47822: LD_VAR 0 8
47826: PPUSH
47827: LD_INT 1
47829: PPUSH
47830: LD_INT 4
47832: PPUSH
47833: CALL_OW 273
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: PUSH
47842: LD_VAR 0 7
47846: PPUSH
47847: LD_INT 2
47849: PPUSH
47850: LD_INT 4
47852: PPUSH
47853: CALL_OW 272
47857: PUSH
47858: LD_VAR 0 8
47862: PPUSH
47863: LD_INT 2
47865: PPUSH
47866: LD_INT 4
47868: PPUSH
47869: CALL_OW 273
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: LD_VAR 0 7
47882: PPUSH
47883: LD_INT 3
47885: PPUSH
47886: LD_INT 4
47888: PPUSH
47889: CALL_OW 272
47893: PUSH
47894: LD_VAR 0 8
47898: PPUSH
47899: LD_INT 3
47901: PPUSH
47902: LD_INT 4
47904: PPUSH
47905: CALL_OW 273
47909: PUSH
47910: EMPTY
47911: LIST
47912: LIST
47913: PUSH
47914: LD_VAR 0 7
47918: PPUSH
47919: LD_INT 4
47921: PPUSH
47922: LD_INT 4
47924: PPUSH
47925: CALL_OW 272
47929: PUSH
47930: LD_VAR 0 8
47934: PPUSH
47935: LD_INT 4
47937: PPUSH
47938: LD_INT 4
47940: PPUSH
47941: CALL_OW 273
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: PUSH
47950: LD_VAR 0 7
47954: PPUSH
47955: LD_INT 5
47957: PPUSH
47958: LD_INT 4
47960: PPUSH
47961: CALL_OW 272
47965: PUSH
47966: LD_VAR 0 8
47970: PPUSH
47971: LD_INT 5
47973: PPUSH
47974: LD_INT 4
47976: PPUSH
47977: CALL_OW 273
47981: PUSH
47982: EMPTY
47983: LIST
47984: LIST
47985: PUSH
47986: EMPTY
47987: LIST
47988: LIST
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: ST_TO_ADDR
// for i = tmp downto 1 do
47994: LD_ADDR_VAR 0 4
47998: PUSH
47999: DOUBLE
48000: LD_VAR 0 6
48004: INC
48005: ST_TO_ADDR
48006: LD_INT 1
48008: PUSH
48009: FOR_DOWNTO
48010: IFFALSE 48111
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48012: LD_VAR 0 6
48016: PUSH
48017: LD_VAR 0 4
48021: ARRAY
48022: PUSH
48023: LD_INT 1
48025: ARRAY
48026: PPUSH
48027: LD_VAR 0 6
48031: PUSH
48032: LD_VAR 0 4
48036: ARRAY
48037: PUSH
48038: LD_INT 2
48040: ARRAY
48041: PPUSH
48042: CALL_OW 488
48046: NOT
48047: PUSH
48048: LD_VAR 0 6
48052: PUSH
48053: LD_VAR 0 4
48057: ARRAY
48058: PUSH
48059: LD_INT 1
48061: ARRAY
48062: PPUSH
48063: LD_VAR 0 6
48067: PUSH
48068: LD_VAR 0 4
48072: ARRAY
48073: PUSH
48074: LD_INT 2
48076: ARRAY
48077: PPUSH
48078: CALL_OW 428
48082: PUSH
48083: LD_INT 0
48085: NONEQUAL
48086: OR
48087: IFFALSE 48109
// tmp := Delete ( tmp , i ) ;
48089: LD_ADDR_VAR 0 6
48093: PUSH
48094: LD_VAR 0 6
48098: PPUSH
48099: LD_VAR 0 4
48103: PPUSH
48104: CALL_OW 3
48108: ST_TO_ADDR
48109: GO 48009
48111: POP
48112: POP
// j := GetClosestHex ( unit , tmp ) ;
48113: LD_ADDR_VAR 0 5
48117: PUSH
48118: LD_VAR 0 1
48122: PPUSH
48123: LD_VAR 0 6
48127: PPUSH
48128: CALL 47413 0 2
48132: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48133: LD_VAR 0 1
48137: PPUSH
48138: LD_VAR 0 5
48142: PUSH
48143: LD_INT 1
48145: ARRAY
48146: PPUSH
48147: LD_VAR 0 5
48151: PUSH
48152: LD_INT 2
48154: ARRAY
48155: PPUSH
48156: CALL_OW 111
// end ;
48160: LD_VAR 0 3
48164: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48165: LD_INT 0
48167: PPUSH
48168: PPUSH
48169: PPUSH
// uc_side = 0 ;
48170: LD_ADDR_OWVAR 20
48174: PUSH
48175: LD_INT 0
48177: ST_TO_ADDR
// uc_nation = 0 ;
48178: LD_ADDR_OWVAR 21
48182: PUSH
48183: LD_INT 0
48185: ST_TO_ADDR
// InitHc ;
48186: CALL_OW 19
// InitVc ;
48190: CALL_OW 20
// if mastodonts then
48194: LD_VAR 0 6
48198: IFFALSE 48265
// for i = 1 to mastodonts do
48200: LD_ADDR_VAR 0 11
48204: PUSH
48205: DOUBLE
48206: LD_INT 1
48208: DEC
48209: ST_TO_ADDR
48210: LD_VAR 0 6
48214: PUSH
48215: FOR_TO
48216: IFFALSE 48263
// begin vc_chassis := 31 ;
48218: LD_ADDR_OWVAR 37
48222: PUSH
48223: LD_INT 31
48225: ST_TO_ADDR
// vc_control := control_rider ;
48226: LD_ADDR_OWVAR 38
48230: PUSH
48231: LD_INT 4
48233: ST_TO_ADDR
// animal := CreateVehicle ;
48234: LD_ADDR_VAR 0 12
48238: PUSH
48239: CALL_OW 45
48243: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48244: LD_VAR 0 12
48248: PPUSH
48249: LD_VAR 0 8
48253: PPUSH
48254: LD_INT 0
48256: PPUSH
48257: CALL 54971 0 3
// end ;
48261: GO 48215
48263: POP
48264: POP
// if horses then
48265: LD_VAR 0 5
48269: IFFALSE 48336
// for i = 1 to horses do
48271: LD_ADDR_VAR 0 11
48275: PUSH
48276: DOUBLE
48277: LD_INT 1
48279: DEC
48280: ST_TO_ADDR
48281: LD_VAR 0 5
48285: PUSH
48286: FOR_TO
48287: IFFALSE 48334
// begin hc_class := 21 ;
48289: LD_ADDR_OWVAR 28
48293: PUSH
48294: LD_INT 21
48296: ST_TO_ADDR
// hc_gallery :=  ;
48297: LD_ADDR_OWVAR 33
48301: PUSH
48302: LD_STRING 
48304: ST_TO_ADDR
// animal := CreateHuman ;
48305: LD_ADDR_VAR 0 12
48309: PUSH
48310: CALL_OW 44
48314: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48315: LD_VAR 0 12
48319: PPUSH
48320: LD_VAR 0 8
48324: PPUSH
48325: LD_INT 0
48327: PPUSH
48328: CALL 54971 0 3
// end ;
48332: GO 48286
48334: POP
48335: POP
// if birds then
48336: LD_VAR 0 1
48340: IFFALSE 48407
// for i = 1 to birds do
48342: LD_ADDR_VAR 0 11
48346: PUSH
48347: DOUBLE
48348: LD_INT 1
48350: DEC
48351: ST_TO_ADDR
48352: LD_VAR 0 1
48356: PUSH
48357: FOR_TO
48358: IFFALSE 48405
// begin hc_class = 18 ;
48360: LD_ADDR_OWVAR 28
48364: PUSH
48365: LD_INT 18
48367: ST_TO_ADDR
// hc_gallery =  ;
48368: LD_ADDR_OWVAR 33
48372: PUSH
48373: LD_STRING 
48375: ST_TO_ADDR
// animal := CreateHuman ;
48376: LD_ADDR_VAR 0 12
48380: PUSH
48381: CALL_OW 44
48385: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48386: LD_VAR 0 12
48390: PPUSH
48391: LD_VAR 0 8
48395: PPUSH
48396: LD_INT 0
48398: PPUSH
48399: CALL 54971 0 3
// end ;
48403: GO 48357
48405: POP
48406: POP
// if tigers then
48407: LD_VAR 0 2
48411: IFFALSE 48495
// for i = 1 to tigers do
48413: LD_ADDR_VAR 0 11
48417: PUSH
48418: DOUBLE
48419: LD_INT 1
48421: DEC
48422: ST_TO_ADDR
48423: LD_VAR 0 2
48427: PUSH
48428: FOR_TO
48429: IFFALSE 48493
// begin hc_class = class_tiger ;
48431: LD_ADDR_OWVAR 28
48435: PUSH
48436: LD_INT 14
48438: ST_TO_ADDR
// hc_gallery =  ;
48439: LD_ADDR_OWVAR 33
48443: PUSH
48444: LD_STRING 
48446: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48447: LD_ADDR_OWVAR 35
48451: PUSH
48452: LD_INT 7
48454: NEG
48455: PPUSH
48456: LD_INT 7
48458: PPUSH
48459: CALL_OW 12
48463: ST_TO_ADDR
// animal := CreateHuman ;
48464: LD_ADDR_VAR 0 12
48468: PUSH
48469: CALL_OW 44
48473: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48474: LD_VAR 0 12
48478: PPUSH
48479: LD_VAR 0 8
48483: PPUSH
48484: LD_INT 0
48486: PPUSH
48487: CALL 54971 0 3
// end ;
48491: GO 48428
48493: POP
48494: POP
// if apemans then
48495: LD_VAR 0 3
48499: IFFALSE 48622
// for i = 1 to apemans do
48501: LD_ADDR_VAR 0 11
48505: PUSH
48506: DOUBLE
48507: LD_INT 1
48509: DEC
48510: ST_TO_ADDR
48511: LD_VAR 0 3
48515: PUSH
48516: FOR_TO
48517: IFFALSE 48620
// begin hc_class = class_apeman ;
48519: LD_ADDR_OWVAR 28
48523: PUSH
48524: LD_INT 12
48526: ST_TO_ADDR
// hc_gallery =  ;
48527: LD_ADDR_OWVAR 33
48531: PUSH
48532: LD_STRING 
48534: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48535: LD_ADDR_OWVAR 35
48539: PUSH
48540: LD_INT 5
48542: NEG
48543: PPUSH
48544: LD_INT 5
48546: PPUSH
48547: CALL_OW 12
48551: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48552: LD_ADDR_OWVAR 31
48556: PUSH
48557: LD_INT 1
48559: PPUSH
48560: LD_INT 3
48562: PPUSH
48563: CALL_OW 12
48567: PUSH
48568: LD_INT 1
48570: PPUSH
48571: LD_INT 3
48573: PPUSH
48574: CALL_OW 12
48578: PUSH
48579: LD_INT 0
48581: PUSH
48582: LD_INT 0
48584: PUSH
48585: EMPTY
48586: LIST
48587: LIST
48588: LIST
48589: LIST
48590: ST_TO_ADDR
// animal := CreateHuman ;
48591: LD_ADDR_VAR 0 12
48595: PUSH
48596: CALL_OW 44
48600: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48601: LD_VAR 0 12
48605: PPUSH
48606: LD_VAR 0 8
48610: PPUSH
48611: LD_INT 0
48613: PPUSH
48614: CALL 54971 0 3
// end ;
48618: GO 48516
48620: POP
48621: POP
// if enchidnas then
48622: LD_VAR 0 4
48626: IFFALSE 48693
// for i = 1 to enchidnas do
48628: LD_ADDR_VAR 0 11
48632: PUSH
48633: DOUBLE
48634: LD_INT 1
48636: DEC
48637: ST_TO_ADDR
48638: LD_VAR 0 4
48642: PUSH
48643: FOR_TO
48644: IFFALSE 48691
// begin hc_class = 13 ;
48646: LD_ADDR_OWVAR 28
48650: PUSH
48651: LD_INT 13
48653: ST_TO_ADDR
// hc_gallery =  ;
48654: LD_ADDR_OWVAR 33
48658: PUSH
48659: LD_STRING 
48661: ST_TO_ADDR
// animal := CreateHuman ;
48662: LD_ADDR_VAR 0 12
48666: PUSH
48667: CALL_OW 44
48671: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48672: LD_VAR 0 12
48676: PPUSH
48677: LD_VAR 0 8
48681: PPUSH
48682: LD_INT 0
48684: PPUSH
48685: CALL 54971 0 3
// end ;
48689: GO 48643
48691: POP
48692: POP
// if fishes then
48693: LD_VAR 0 7
48697: IFFALSE 48764
// for i = 1 to fishes do
48699: LD_ADDR_VAR 0 11
48703: PUSH
48704: DOUBLE
48705: LD_INT 1
48707: DEC
48708: ST_TO_ADDR
48709: LD_VAR 0 7
48713: PUSH
48714: FOR_TO
48715: IFFALSE 48762
// begin hc_class = 20 ;
48717: LD_ADDR_OWVAR 28
48721: PUSH
48722: LD_INT 20
48724: ST_TO_ADDR
// hc_gallery =  ;
48725: LD_ADDR_OWVAR 33
48729: PUSH
48730: LD_STRING 
48732: ST_TO_ADDR
// animal := CreateHuman ;
48733: LD_ADDR_VAR 0 12
48737: PUSH
48738: CALL_OW 44
48742: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48743: LD_VAR 0 12
48747: PPUSH
48748: LD_VAR 0 9
48752: PPUSH
48753: LD_INT 0
48755: PPUSH
48756: CALL 54971 0 3
// end ;
48760: GO 48714
48762: POP
48763: POP
// end ;
48764: LD_VAR 0 10
48768: RET
// export function WantHeal ( sci , unit ) ; begin
48769: LD_INT 0
48771: PPUSH
// if GetTaskList ( sci ) > 0 then
48772: LD_VAR 0 1
48776: PPUSH
48777: CALL_OW 437
48781: PUSH
48782: LD_INT 0
48784: GREATER
48785: IFFALSE 48855
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48787: LD_VAR 0 1
48791: PPUSH
48792: CALL_OW 437
48796: PUSH
48797: LD_INT 1
48799: ARRAY
48800: PUSH
48801: LD_INT 1
48803: ARRAY
48804: PUSH
48805: LD_STRING l
48807: EQUAL
48808: PUSH
48809: LD_VAR 0 1
48813: PPUSH
48814: CALL_OW 437
48818: PUSH
48819: LD_INT 1
48821: ARRAY
48822: PUSH
48823: LD_INT 4
48825: ARRAY
48826: PUSH
48827: LD_VAR 0 2
48831: EQUAL
48832: AND
48833: IFFALSE 48845
// result := true else
48835: LD_ADDR_VAR 0 3
48839: PUSH
48840: LD_INT 1
48842: ST_TO_ADDR
48843: GO 48853
// result := false ;
48845: LD_ADDR_VAR 0 3
48849: PUSH
48850: LD_INT 0
48852: ST_TO_ADDR
// end else
48853: GO 48863
// result := false ;
48855: LD_ADDR_VAR 0 3
48859: PUSH
48860: LD_INT 0
48862: ST_TO_ADDR
// end ;
48863: LD_VAR 0 3
48867: RET
// export function HealTarget ( sci ) ; begin
48868: LD_INT 0
48870: PPUSH
// if not sci then
48871: LD_VAR 0 1
48875: NOT
48876: IFFALSE 48880
// exit ;
48878: GO 48945
// result := 0 ;
48880: LD_ADDR_VAR 0 2
48884: PUSH
48885: LD_INT 0
48887: ST_TO_ADDR
// if GetTaskList ( sci ) then
48888: LD_VAR 0 1
48892: PPUSH
48893: CALL_OW 437
48897: IFFALSE 48945
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48899: LD_VAR 0 1
48903: PPUSH
48904: CALL_OW 437
48908: PUSH
48909: LD_INT 1
48911: ARRAY
48912: PUSH
48913: LD_INT 1
48915: ARRAY
48916: PUSH
48917: LD_STRING l
48919: EQUAL
48920: IFFALSE 48945
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48922: LD_ADDR_VAR 0 2
48926: PUSH
48927: LD_VAR 0 1
48931: PPUSH
48932: CALL_OW 437
48936: PUSH
48937: LD_INT 1
48939: ARRAY
48940: PUSH
48941: LD_INT 4
48943: ARRAY
48944: ST_TO_ADDR
// end ;
48945: LD_VAR 0 2
48949: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
48950: LD_INT 0
48952: PPUSH
48953: PPUSH
48954: PPUSH
48955: PPUSH
48956: PPUSH
48957: PPUSH
48958: PPUSH
48959: PPUSH
48960: PPUSH
48961: PPUSH
48962: PPUSH
48963: PPUSH
48964: PPUSH
48965: PPUSH
48966: PPUSH
48967: PPUSH
48968: PPUSH
48969: PPUSH
48970: PPUSH
48971: PPUSH
48972: PPUSH
48973: PPUSH
48974: PPUSH
48975: PPUSH
48976: PPUSH
48977: PPUSH
48978: PPUSH
48979: PPUSH
48980: PPUSH
48981: PPUSH
48982: PPUSH
48983: PPUSH
48984: PPUSH
// if not list then
48985: LD_VAR 0 1
48989: NOT
48990: IFFALSE 48994
// exit ;
48992: GO 53582
// base := list [ 1 ] ;
48994: LD_ADDR_VAR 0 3
48998: PUSH
48999: LD_VAR 0 1
49003: PUSH
49004: LD_INT 1
49006: ARRAY
49007: ST_TO_ADDR
// group := list [ 2 ] ;
49008: LD_ADDR_VAR 0 4
49012: PUSH
49013: LD_VAR 0 1
49017: PUSH
49018: LD_INT 2
49020: ARRAY
49021: ST_TO_ADDR
// path := list [ 3 ] ;
49022: LD_ADDR_VAR 0 5
49026: PUSH
49027: LD_VAR 0 1
49031: PUSH
49032: LD_INT 3
49034: ARRAY
49035: ST_TO_ADDR
// flags := list [ 4 ] ;
49036: LD_ADDR_VAR 0 6
49040: PUSH
49041: LD_VAR 0 1
49045: PUSH
49046: LD_INT 4
49048: ARRAY
49049: ST_TO_ADDR
// mined := [ ] ;
49050: LD_ADDR_VAR 0 27
49054: PUSH
49055: EMPTY
49056: ST_TO_ADDR
// bombed := [ ] ;
49057: LD_ADDR_VAR 0 28
49061: PUSH
49062: EMPTY
49063: ST_TO_ADDR
// healers := [ ] ;
49064: LD_ADDR_VAR 0 31
49068: PUSH
49069: EMPTY
49070: ST_TO_ADDR
// to_heal := [ ] ;
49071: LD_ADDR_VAR 0 30
49075: PUSH
49076: EMPTY
49077: ST_TO_ADDR
// repairs := [ ] ;
49078: LD_ADDR_VAR 0 33
49082: PUSH
49083: EMPTY
49084: ST_TO_ADDR
// to_repair := [ ] ;
49085: LD_ADDR_VAR 0 32
49089: PUSH
49090: EMPTY
49091: ST_TO_ADDR
// if not group or not path then
49092: LD_VAR 0 4
49096: NOT
49097: PUSH
49098: LD_VAR 0 5
49102: NOT
49103: OR
49104: IFFALSE 49108
// exit ;
49106: GO 53582
// if flags then
49108: LD_VAR 0 6
49112: IFFALSE 49256
// begin f_ignore_area := flags [ 1 ] ;
49114: LD_ADDR_VAR 0 17
49118: PUSH
49119: LD_VAR 0 6
49123: PUSH
49124: LD_INT 1
49126: ARRAY
49127: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49128: LD_ADDR_VAR 0 18
49132: PUSH
49133: LD_VAR 0 6
49137: PUSH
49138: LD_INT 2
49140: ARRAY
49141: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49142: LD_ADDR_VAR 0 19
49146: PUSH
49147: LD_VAR 0 6
49151: PUSH
49152: LD_INT 3
49154: ARRAY
49155: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49156: LD_ADDR_VAR 0 20
49160: PUSH
49161: LD_VAR 0 6
49165: PUSH
49166: LD_INT 4
49168: ARRAY
49169: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49170: LD_ADDR_VAR 0 21
49174: PUSH
49175: LD_VAR 0 6
49179: PUSH
49180: LD_INT 5
49182: ARRAY
49183: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49184: LD_ADDR_VAR 0 22
49188: PUSH
49189: LD_VAR 0 6
49193: PUSH
49194: LD_INT 6
49196: ARRAY
49197: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49198: LD_ADDR_VAR 0 23
49202: PUSH
49203: LD_VAR 0 6
49207: PUSH
49208: LD_INT 7
49210: ARRAY
49211: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49212: LD_ADDR_VAR 0 24
49216: PUSH
49217: LD_VAR 0 6
49221: PUSH
49222: LD_INT 8
49224: ARRAY
49225: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49226: LD_ADDR_VAR 0 25
49230: PUSH
49231: LD_VAR 0 6
49235: PUSH
49236: LD_INT 9
49238: ARRAY
49239: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49240: LD_ADDR_VAR 0 26
49244: PUSH
49245: LD_VAR 0 6
49249: PUSH
49250: LD_INT 10
49252: ARRAY
49253: ST_TO_ADDR
// end else
49254: GO 49336
// begin f_ignore_area := false ;
49256: LD_ADDR_VAR 0 17
49260: PUSH
49261: LD_INT 0
49263: ST_TO_ADDR
// f_capture := false ;
49264: LD_ADDR_VAR 0 18
49268: PUSH
49269: LD_INT 0
49271: ST_TO_ADDR
// f_ignore_civ := false ;
49272: LD_ADDR_VAR 0 19
49276: PUSH
49277: LD_INT 0
49279: ST_TO_ADDR
// f_murder := false ;
49280: LD_ADDR_VAR 0 20
49284: PUSH
49285: LD_INT 0
49287: ST_TO_ADDR
// f_mines := false ;
49288: LD_ADDR_VAR 0 21
49292: PUSH
49293: LD_INT 0
49295: ST_TO_ADDR
// f_repair := false ;
49296: LD_ADDR_VAR 0 22
49300: PUSH
49301: LD_INT 0
49303: ST_TO_ADDR
// f_heal := false ;
49304: LD_ADDR_VAR 0 23
49308: PUSH
49309: LD_INT 0
49311: ST_TO_ADDR
// f_spacetime := false ;
49312: LD_ADDR_VAR 0 24
49316: PUSH
49317: LD_INT 0
49319: ST_TO_ADDR
// f_attack_depot := false ;
49320: LD_ADDR_VAR 0 25
49324: PUSH
49325: LD_INT 0
49327: ST_TO_ADDR
// f_crawl := false ;
49328: LD_ADDR_VAR 0 26
49332: PUSH
49333: LD_INT 0
49335: ST_TO_ADDR
// end ; if f_heal then
49336: LD_VAR 0 23
49340: IFFALSE 49367
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49342: LD_ADDR_VAR 0 31
49346: PUSH
49347: LD_VAR 0 4
49351: PPUSH
49352: LD_INT 25
49354: PUSH
49355: LD_INT 4
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: PPUSH
49362: CALL_OW 72
49366: ST_TO_ADDR
// if f_repair then
49367: LD_VAR 0 22
49371: IFFALSE 49398
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49373: LD_ADDR_VAR 0 33
49377: PUSH
49378: LD_VAR 0 4
49382: PPUSH
49383: LD_INT 25
49385: PUSH
49386: LD_INT 3
49388: PUSH
49389: EMPTY
49390: LIST
49391: LIST
49392: PPUSH
49393: CALL_OW 72
49397: ST_TO_ADDR
// units_path := [ ] ;
49398: LD_ADDR_VAR 0 16
49402: PUSH
49403: EMPTY
49404: ST_TO_ADDR
// for i = 1 to group do
49405: LD_ADDR_VAR 0 7
49409: PUSH
49410: DOUBLE
49411: LD_INT 1
49413: DEC
49414: ST_TO_ADDR
49415: LD_VAR 0 4
49419: PUSH
49420: FOR_TO
49421: IFFALSE 49450
// units_path := Replace ( units_path , i , path ) ;
49423: LD_ADDR_VAR 0 16
49427: PUSH
49428: LD_VAR 0 16
49432: PPUSH
49433: LD_VAR 0 7
49437: PPUSH
49438: LD_VAR 0 5
49442: PPUSH
49443: CALL_OW 1
49447: ST_TO_ADDR
49448: GO 49420
49450: POP
49451: POP
// repeat for i = group downto 1 do
49452: LD_ADDR_VAR 0 7
49456: PUSH
49457: DOUBLE
49458: LD_VAR 0 4
49462: INC
49463: ST_TO_ADDR
49464: LD_INT 1
49466: PUSH
49467: FOR_DOWNTO
49468: IFFALSE 53564
// begin wait ( 5 ) ;
49470: LD_INT 5
49472: PPUSH
49473: CALL_OW 67
// tmp := [ ] ;
49477: LD_ADDR_VAR 0 14
49481: PUSH
49482: EMPTY
49483: ST_TO_ADDR
// attacking := false ;
49484: LD_ADDR_VAR 0 29
49488: PUSH
49489: LD_INT 0
49491: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49492: LD_VAR 0 4
49496: PUSH
49497: LD_VAR 0 7
49501: ARRAY
49502: PPUSH
49503: CALL_OW 301
49507: PUSH
49508: LD_VAR 0 4
49512: PUSH
49513: LD_VAR 0 7
49517: ARRAY
49518: NOT
49519: OR
49520: IFFALSE 49629
// begin if GetType ( group [ i ] ) = unit_human then
49522: LD_VAR 0 4
49526: PUSH
49527: LD_VAR 0 7
49531: ARRAY
49532: PPUSH
49533: CALL_OW 247
49537: PUSH
49538: LD_INT 1
49540: EQUAL
49541: IFFALSE 49587
// begin to_heal := to_heal diff group [ i ] ;
49543: LD_ADDR_VAR 0 30
49547: PUSH
49548: LD_VAR 0 30
49552: PUSH
49553: LD_VAR 0 4
49557: PUSH
49558: LD_VAR 0 7
49562: ARRAY
49563: DIFF
49564: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49565: LD_ADDR_VAR 0 31
49569: PUSH
49570: LD_VAR 0 31
49574: PUSH
49575: LD_VAR 0 4
49579: PUSH
49580: LD_VAR 0 7
49584: ARRAY
49585: DIFF
49586: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49587: LD_ADDR_VAR 0 4
49591: PUSH
49592: LD_VAR 0 4
49596: PPUSH
49597: LD_VAR 0 7
49601: PPUSH
49602: CALL_OW 3
49606: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49607: LD_ADDR_VAR 0 16
49611: PUSH
49612: LD_VAR 0 16
49616: PPUSH
49617: LD_VAR 0 7
49621: PPUSH
49622: CALL_OW 3
49626: ST_TO_ADDR
// continue ;
49627: GO 49467
// end ; if f_repair then
49629: LD_VAR 0 22
49633: IFFALSE 50122
// begin if GetType ( group [ i ] ) = unit_vehicle then
49635: LD_VAR 0 4
49639: PUSH
49640: LD_VAR 0 7
49644: ARRAY
49645: PPUSH
49646: CALL_OW 247
49650: PUSH
49651: LD_INT 2
49653: EQUAL
49654: IFFALSE 49844
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49656: LD_VAR 0 4
49660: PUSH
49661: LD_VAR 0 7
49665: ARRAY
49666: PPUSH
49667: CALL_OW 256
49671: PUSH
49672: LD_INT 700
49674: LESS
49675: PUSH
49676: LD_VAR 0 4
49680: PUSH
49681: LD_VAR 0 7
49685: ARRAY
49686: PUSH
49687: LD_VAR 0 32
49691: IN
49692: NOT
49693: AND
49694: IFFALSE 49718
// to_repair := to_repair union group [ i ] ;
49696: LD_ADDR_VAR 0 32
49700: PUSH
49701: LD_VAR 0 32
49705: PUSH
49706: LD_VAR 0 4
49710: PUSH
49711: LD_VAR 0 7
49715: ARRAY
49716: UNION
49717: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49718: LD_VAR 0 4
49722: PUSH
49723: LD_VAR 0 7
49727: ARRAY
49728: PPUSH
49729: CALL_OW 256
49733: PUSH
49734: LD_INT 1000
49736: EQUAL
49737: PUSH
49738: LD_VAR 0 4
49742: PUSH
49743: LD_VAR 0 7
49747: ARRAY
49748: PUSH
49749: LD_VAR 0 32
49753: IN
49754: AND
49755: IFFALSE 49779
// to_repair := to_repair diff group [ i ] ;
49757: LD_ADDR_VAR 0 32
49761: PUSH
49762: LD_VAR 0 32
49766: PUSH
49767: LD_VAR 0 4
49771: PUSH
49772: LD_VAR 0 7
49776: ARRAY
49777: DIFF
49778: ST_TO_ADDR
// if group [ i ] in to_repair then
49779: LD_VAR 0 4
49783: PUSH
49784: LD_VAR 0 7
49788: ARRAY
49789: PUSH
49790: LD_VAR 0 32
49794: IN
49795: IFFALSE 49842
// begin if not IsInArea ( group [ i ] , f_repair ) then
49797: LD_VAR 0 4
49801: PUSH
49802: LD_VAR 0 7
49806: ARRAY
49807: PPUSH
49808: LD_VAR 0 22
49812: PPUSH
49813: CALL_OW 308
49817: NOT
49818: IFFALSE 49840
// ComMoveToArea ( group [ i ] , f_repair ) ;
49820: LD_VAR 0 4
49824: PUSH
49825: LD_VAR 0 7
49829: ARRAY
49830: PPUSH
49831: LD_VAR 0 22
49835: PPUSH
49836: CALL_OW 113
// continue ;
49840: GO 49467
// end ; end else
49842: GO 50122
// if group [ i ] in repairs then
49844: LD_VAR 0 4
49848: PUSH
49849: LD_VAR 0 7
49853: ARRAY
49854: PUSH
49855: LD_VAR 0 33
49859: IN
49860: IFFALSE 50122
// begin if IsInUnit ( group [ i ] ) then
49862: LD_VAR 0 4
49866: PUSH
49867: LD_VAR 0 7
49871: ARRAY
49872: PPUSH
49873: CALL_OW 310
49877: IFFALSE 49945
// begin z := IsInUnit ( group [ i ] ) ;
49879: LD_ADDR_VAR 0 13
49883: PUSH
49884: LD_VAR 0 4
49888: PUSH
49889: LD_VAR 0 7
49893: ARRAY
49894: PPUSH
49895: CALL_OW 310
49899: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49900: LD_VAR 0 13
49904: PUSH
49905: LD_VAR 0 32
49909: IN
49910: PUSH
49911: LD_VAR 0 13
49915: PPUSH
49916: LD_VAR 0 22
49920: PPUSH
49921: CALL_OW 308
49925: AND
49926: IFFALSE 49943
// ComExitVehicle ( group [ i ] ) ;
49928: LD_VAR 0 4
49932: PUSH
49933: LD_VAR 0 7
49937: ARRAY
49938: PPUSH
49939: CALL_OW 121
// end else
49943: GO 50122
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
49945: LD_ADDR_VAR 0 13
49949: PUSH
49950: LD_VAR 0 4
49954: PPUSH
49955: LD_INT 95
49957: PUSH
49958: LD_VAR 0 22
49962: PUSH
49963: EMPTY
49964: LIST
49965: LIST
49966: PUSH
49967: LD_INT 58
49969: PUSH
49970: EMPTY
49971: LIST
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: PPUSH
49977: CALL_OW 72
49981: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
49982: LD_VAR 0 4
49986: PUSH
49987: LD_VAR 0 7
49991: ARRAY
49992: PPUSH
49993: CALL_OW 314
49997: NOT
49998: IFFALSE 50120
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50000: LD_ADDR_VAR 0 10
50004: PUSH
50005: LD_VAR 0 13
50009: PPUSH
50010: LD_VAR 0 4
50014: PUSH
50015: LD_VAR 0 7
50019: ARRAY
50020: PPUSH
50021: CALL_OW 74
50025: ST_TO_ADDR
// if not x then
50026: LD_VAR 0 10
50030: NOT
50031: IFFALSE 50035
// continue ;
50033: GO 49467
// if GetLives ( x ) < 1000 then
50035: LD_VAR 0 10
50039: PPUSH
50040: CALL_OW 256
50044: PUSH
50045: LD_INT 1000
50047: LESS
50048: IFFALSE 50072
// ComRepairVehicle ( group [ i ] , x ) else
50050: LD_VAR 0 4
50054: PUSH
50055: LD_VAR 0 7
50059: ARRAY
50060: PPUSH
50061: LD_VAR 0 10
50065: PPUSH
50066: CALL_OW 129
50070: GO 50120
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50072: LD_VAR 0 23
50076: PUSH
50077: LD_VAR 0 4
50081: PUSH
50082: LD_VAR 0 7
50086: ARRAY
50087: PPUSH
50088: CALL_OW 256
50092: PUSH
50093: LD_INT 1000
50095: LESS
50096: AND
50097: NOT
50098: IFFALSE 50120
// ComEnterUnit ( group [ i ] , x ) ;
50100: LD_VAR 0 4
50104: PUSH
50105: LD_VAR 0 7
50109: ARRAY
50110: PPUSH
50111: LD_VAR 0 10
50115: PPUSH
50116: CALL_OW 120
// end ; continue ;
50120: GO 49467
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50122: LD_VAR 0 23
50126: PUSH
50127: LD_VAR 0 4
50131: PUSH
50132: LD_VAR 0 7
50136: ARRAY
50137: PPUSH
50138: CALL_OW 247
50142: PUSH
50143: LD_INT 1
50145: EQUAL
50146: AND
50147: IFFALSE 50625
// begin if group [ i ] in healers then
50149: LD_VAR 0 4
50153: PUSH
50154: LD_VAR 0 7
50158: ARRAY
50159: PUSH
50160: LD_VAR 0 31
50164: IN
50165: IFFALSE 50438
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50167: LD_VAR 0 4
50171: PUSH
50172: LD_VAR 0 7
50176: ARRAY
50177: PPUSH
50178: LD_VAR 0 23
50182: PPUSH
50183: CALL_OW 308
50187: NOT
50188: PUSH
50189: LD_VAR 0 4
50193: PUSH
50194: LD_VAR 0 7
50198: ARRAY
50199: PPUSH
50200: CALL_OW 314
50204: NOT
50205: AND
50206: IFFALSE 50230
// ComMoveToArea ( group [ i ] , f_heal ) else
50208: LD_VAR 0 4
50212: PUSH
50213: LD_VAR 0 7
50217: ARRAY
50218: PPUSH
50219: LD_VAR 0 23
50223: PPUSH
50224: CALL_OW 113
50228: GO 50436
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50230: LD_VAR 0 4
50234: PUSH
50235: LD_VAR 0 7
50239: ARRAY
50240: PPUSH
50241: CALL 48868 0 1
50245: PPUSH
50246: CALL_OW 256
50250: PUSH
50251: LD_INT 1000
50253: EQUAL
50254: IFFALSE 50273
// ComStop ( group [ i ] ) else
50256: LD_VAR 0 4
50260: PUSH
50261: LD_VAR 0 7
50265: ARRAY
50266: PPUSH
50267: CALL_OW 141
50271: GO 50436
// if not HasTask ( group [ i ] ) and to_heal then
50273: LD_VAR 0 4
50277: PUSH
50278: LD_VAR 0 7
50282: ARRAY
50283: PPUSH
50284: CALL_OW 314
50288: NOT
50289: PUSH
50290: LD_VAR 0 30
50294: AND
50295: IFFALSE 50436
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50297: LD_ADDR_VAR 0 13
50301: PUSH
50302: LD_VAR 0 30
50306: PPUSH
50307: LD_INT 3
50309: PUSH
50310: LD_INT 54
50312: PUSH
50313: EMPTY
50314: LIST
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PPUSH
50320: CALL_OW 72
50324: PPUSH
50325: LD_VAR 0 4
50329: PUSH
50330: LD_VAR 0 7
50334: ARRAY
50335: PPUSH
50336: CALL_OW 74
50340: ST_TO_ADDR
// if z then
50341: LD_VAR 0 13
50345: IFFALSE 50436
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50347: LD_INT 91
50349: PUSH
50350: LD_VAR 0 13
50354: PUSH
50355: LD_INT 10
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: LIST
50362: PUSH
50363: LD_INT 81
50365: PUSH
50366: LD_VAR 0 13
50370: PPUSH
50371: CALL_OW 255
50375: PUSH
50376: EMPTY
50377: LIST
50378: LIST
50379: PUSH
50380: EMPTY
50381: LIST
50382: LIST
50383: PPUSH
50384: CALL_OW 69
50388: PUSH
50389: LD_INT 0
50391: EQUAL
50392: IFFALSE 50416
// ComHeal ( group [ i ] , z ) else
50394: LD_VAR 0 4
50398: PUSH
50399: LD_VAR 0 7
50403: ARRAY
50404: PPUSH
50405: LD_VAR 0 13
50409: PPUSH
50410: CALL_OW 128
50414: GO 50436
// ComMoveToArea ( group [ i ] , f_heal ) ;
50416: LD_VAR 0 4
50420: PUSH
50421: LD_VAR 0 7
50425: ARRAY
50426: PPUSH
50427: LD_VAR 0 23
50431: PPUSH
50432: CALL_OW 113
// end ; continue ;
50436: GO 49467
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50438: LD_VAR 0 4
50442: PUSH
50443: LD_VAR 0 7
50447: ARRAY
50448: PPUSH
50449: CALL_OW 256
50453: PUSH
50454: LD_INT 700
50456: LESS
50457: PUSH
50458: LD_VAR 0 4
50462: PUSH
50463: LD_VAR 0 7
50467: ARRAY
50468: PUSH
50469: LD_VAR 0 30
50473: IN
50474: NOT
50475: AND
50476: IFFALSE 50500
// to_heal := to_heal union group [ i ] ;
50478: LD_ADDR_VAR 0 30
50482: PUSH
50483: LD_VAR 0 30
50487: PUSH
50488: LD_VAR 0 4
50492: PUSH
50493: LD_VAR 0 7
50497: ARRAY
50498: UNION
50499: ST_TO_ADDR
// if group [ i ] in to_heal then
50500: LD_VAR 0 4
50504: PUSH
50505: LD_VAR 0 7
50509: ARRAY
50510: PUSH
50511: LD_VAR 0 30
50515: IN
50516: IFFALSE 50625
// begin if GetLives ( group [ i ] ) = 1000 then
50518: LD_VAR 0 4
50522: PUSH
50523: LD_VAR 0 7
50527: ARRAY
50528: PPUSH
50529: CALL_OW 256
50533: PUSH
50534: LD_INT 1000
50536: EQUAL
50537: IFFALSE 50563
// to_heal := to_heal diff group [ i ] else
50539: LD_ADDR_VAR 0 30
50543: PUSH
50544: LD_VAR 0 30
50548: PUSH
50549: LD_VAR 0 4
50553: PUSH
50554: LD_VAR 0 7
50558: ARRAY
50559: DIFF
50560: ST_TO_ADDR
50561: GO 50625
// begin if not IsInArea ( group [ i ] , to_heal ) then
50563: LD_VAR 0 4
50567: PUSH
50568: LD_VAR 0 7
50572: ARRAY
50573: PPUSH
50574: LD_VAR 0 30
50578: PPUSH
50579: CALL_OW 308
50583: NOT
50584: IFFALSE 50608
// ComMoveToArea ( group [ i ] , f_heal ) else
50586: LD_VAR 0 4
50590: PUSH
50591: LD_VAR 0 7
50595: ARRAY
50596: PPUSH
50597: LD_VAR 0 23
50601: PPUSH
50602: CALL_OW 113
50606: GO 50623
// ComHold ( group [ i ] ) ;
50608: LD_VAR 0 4
50612: PUSH
50613: LD_VAR 0 7
50617: ARRAY
50618: PPUSH
50619: CALL_OW 140
// continue ;
50623: GO 49467
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50625: LD_VAR 0 4
50629: PUSH
50630: LD_VAR 0 7
50634: ARRAY
50635: PPUSH
50636: LD_INT 10
50638: PPUSH
50639: CALL 47265 0 2
50643: NOT
50644: PUSH
50645: LD_VAR 0 16
50649: PUSH
50650: LD_VAR 0 7
50654: ARRAY
50655: PUSH
50656: EMPTY
50657: EQUAL
50658: NOT
50659: AND
50660: IFFALSE 50926
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50662: LD_VAR 0 4
50666: PUSH
50667: LD_VAR 0 7
50671: ARRAY
50672: PPUSH
50673: CALL_OW 262
50677: PUSH
50678: LD_INT 1
50680: PUSH
50681: LD_INT 2
50683: PUSH
50684: EMPTY
50685: LIST
50686: LIST
50687: IN
50688: IFFALSE 50729
// if GetFuel ( group [ i ] ) < 10 then
50690: LD_VAR 0 4
50694: PUSH
50695: LD_VAR 0 7
50699: ARRAY
50700: PPUSH
50701: CALL_OW 261
50705: PUSH
50706: LD_INT 10
50708: LESS
50709: IFFALSE 50729
// SetFuel ( group [ i ] , 12 ) ;
50711: LD_VAR 0 4
50715: PUSH
50716: LD_VAR 0 7
50720: ARRAY
50721: PPUSH
50722: LD_INT 12
50724: PPUSH
50725: CALL_OW 240
// if units_path [ i ] then
50729: LD_VAR 0 16
50733: PUSH
50734: LD_VAR 0 7
50738: ARRAY
50739: IFFALSE 50924
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50741: LD_VAR 0 4
50745: PUSH
50746: LD_VAR 0 7
50750: ARRAY
50751: PPUSH
50752: LD_VAR 0 16
50756: PUSH
50757: LD_VAR 0 7
50761: ARRAY
50762: PUSH
50763: LD_INT 1
50765: ARRAY
50766: PUSH
50767: LD_INT 1
50769: ARRAY
50770: PPUSH
50771: LD_VAR 0 16
50775: PUSH
50776: LD_VAR 0 7
50780: ARRAY
50781: PUSH
50782: LD_INT 1
50784: ARRAY
50785: PUSH
50786: LD_INT 2
50788: ARRAY
50789: PPUSH
50790: CALL_OW 297
50794: PUSH
50795: LD_INT 6
50797: GREATER
50798: IFFALSE 50873
// begin if not HasTask ( group [ i ] ) then
50800: LD_VAR 0 4
50804: PUSH
50805: LD_VAR 0 7
50809: ARRAY
50810: PPUSH
50811: CALL_OW 314
50815: NOT
50816: IFFALSE 50871
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50818: LD_VAR 0 4
50822: PUSH
50823: LD_VAR 0 7
50827: ARRAY
50828: PPUSH
50829: LD_VAR 0 16
50833: PUSH
50834: LD_VAR 0 7
50838: ARRAY
50839: PUSH
50840: LD_INT 1
50842: ARRAY
50843: PUSH
50844: LD_INT 1
50846: ARRAY
50847: PPUSH
50848: LD_VAR 0 16
50852: PUSH
50853: LD_VAR 0 7
50857: ARRAY
50858: PUSH
50859: LD_INT 1
50861: ARRAY
50862: PUSH
50863: LD_INT 2
50865: ARRAY
50866: PPUSH
50867: CALL_OW 114
// end else
50871: GO 50924
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50873: LD_ADDR_VAR 0 15
50877: PUSH
50878: LD_VAR 0 16
50882: PUSH
50883: LD_VAR 0 7
50887: ARRAY
50888: PPUSH
50889: LD_INT 1
50891: PPUSH
50892: CALL_OW 3
50896: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50897: LD_ADDR_VAR 0 16
50901: PUSH
50902: LD_VAR 0 16
50906: PPUSH
50907: LD_VAR 0 7
50911: PPUSH
50912: LD_VAR 0 15
50916: PPUSH
50917: CALL_OW 1
50921: ST_TO_ADDR
// continue ;
50922: GO 49467
// end ; end ; end else
50924: GO 53562
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50926: LD_ADDR_VAR 0 14
50930: PUSH
50931: LD_INT 81
50933: PUSH
50934: LD_VAR 0 4
50938: PUSH
50939: LD_VAR 0 7
50943: ARRAY
50944: PPUSH
50945: CALL_OW 255
50949: PUSH
50950: EMPTY
50951: LIST
50952: LIST
50953: PPUSH
50954: CALL_OW 69
50958: ST_TO_ADDR
// if not tmp then
50959: LD_VAR 0 14
50963: NOT
50964: IFFALSE 50968
// continue ;
50966: GO 49467
// if f_ignore_area then
50968: LD_VAR 0 17
50972: IFFALSE 51060
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
50974: LD_ADDR_VAR 0 15
50978: PUSH
50979: LD_VAR 0 14
50983: PPUSH
50984: LD_INT 3
50986: PUSH
50987: LD_INT 92
50989: PUSH
50990: LD_VAR 0 17
50994: PUSH
50995: LD_INT 1
50997: ARRAY
50998: PUSH
50999: LD_VAR 0 17
51003: PUSH
51004: LD_INT 2
51006: ARRAY
51007: PUSH
51008: LD_VAR 0 17
51012: PUSH
51013: LD_INT 3
51015: ARRAY
51016: PUSH
51017: EMPTY
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: PUSH
51023: EMPTY
51024: LIST
51025: LIST
51026: PPUSH
51027: CALL_OW 72
51031: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51032: LD_VAR 0 14
51036: PUSH
51037: LD_VAR 0 15
51041: DIFF
51042: IFFALSE 51060
// tmp := tmp diff tmp2 ;
51044: LD_ADDR_VAR 0 14
51048: PUSH
51049: LD_VAR 0 14
51053: PUSH
51054: LD_VAR 0 15
51058: DIFF
51059: ST_TO_ADDR
// end ; if not f_murder then
51060: LD_VAR 0 20
51064: NOT
51065: IFFALSE 51123
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51067: LD_ADDR_VAR 0 15
51071: PUSH
51072: LD_VAR 0 14
51076: PPUSH
51077: LD_INT 3
51079: PUSH
51080: LD_INT 50
51082: PUSH
51083: EMPTY
51084: LIST
51085: PUSH
51086: EMPTY
51087: LIST
51088: LIST
51089: PPUSH
51090: CALL_OW 72
51094: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51095: LD_VAR 0 14
51099: PUSH
51100: LD_VAR 0 15
51104: DIFF
51105: IFFALSE 51123
// tmp := tmp diff tmp2 ;
51107: LD_ADDR_VAR 0 14
51111: PUSH
51112: LD_VAR 0 14
51116: PUSH
51117: LD_VAR 0 15
51121: DIFF
51122: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51123: LD_ADDR_VAR 0 14
51127: PUSH
51128: LD_VAR 0 4
51132: PUSH
51133: LD_VAR 0 7
51137: ARRAY
51138: PPUSH
51139: LD_VAR 0 14
51143: PPUSH
51144: LD_INT 1
51146: PPUSH
51147: LD_INT 1
51149: PPUSH
51150: CALL 20932 0 4
51154: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51155: LD_VAR 0 4
51159: PUSH
51160: LD_VAR 0 7
51164: ARRAY
51165: PPUSH
51166: CALL_OW 257
51170: PUSH
51171: LD_INT 1
51173: EQUAL
51174: IFFALSE 51622
// begin if WantPlant ( group [ i ] ) then
51176: LD_VAR 0 4
51180: PUSH
51181: LD_VAR 0 7
51185: ARRAY
51186: PPUSH
51187: CALL 20433 0 1
51191: IFFALSE 51195
// continue ;
51193: GO 49467
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51195: LD_VAR 0 18
51199: PUSH
51200: LD_VAR 0 4
51204: PUSH
51205: LD_VAR 0 7
51209: ARRAY
51210: PPUSH
51211: CALL_OW 310
51215: NOT
51216: AND
51217: PUSH
51218: LD_VAR 0 14
51222: PUSH
51223: LD_INT 1
51225: ARRAY
51226: PUSH
51227: LD_VAR 0 14
51231: PPUSH
51232: LD_INT 21
51234: PUSH
51235: LD_INT 2
51237: PUSH
51238: EMPTY
51239: LIST
51240: LIST
51241: PUSH
51242: LD_INT 58
51244: PUSH
51245: EMPTY
51246: LIST
51247: PUSH
51248: EMPTY
51249: LIST
51250: LIST
51251: PPUSH
51252: CALL_OW 72
51256: IN
51257: AND
51258: IFFALSE 51294
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51260: LD_VAR 0 4
51264: PUSH
51265: LD_VAR 0 7
51269: ARRAY
51270: PPUSH
51271: LD_VAR 0 14
51275: PUSH
51276: LD_INT 1
51278: ARRAY
51279: PPUSH
51280: CALL_OW 120
// attacking := true ;
51284: LD_ADDR_VAR 0 29
51288: PUSH
51289: LD_INT 1
51291: ST_TO_ADDR
// continue ;
51292: GO 49467
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51294: LD_VAR 0 26
51298: PUSH
51299: LD_VAR 0 4
51303: PUSH
51304: LD_VAR 0 7
51308: ARRAY
51309: PPUSH
51310: CALL_OW 257
51314: PUSH
51315: LD_INT 1
51317: EQUAL
51318: AND
51319: PUSH
51320: LD_VAR 0 4
51324: PUSH
51325: LD_VAR 0 7
51329: ARRAY
51330: PPUSH
51331: CALL_OW 256
51335: PUSH
51336: LD_INT 800
51338: LESS
51339: AND
51340: PUSH
51341: LD_VAR 0 4
51345: PUSH
51346: LD_VAR 0 7
51350: ARRAY
51351: PPUSH
51352: CALL_OW 318
51356: NOT
51357: AND
51358: IFFALSE 51375
// ComCrawl ( group [ i ] ) ;
51360: LD_VAR 0 4
51364: PUSH
51365: LD_VAR 0 7
51369: ARRAY
51370: PPUSH
51371: CALL_OW 137
// if f_mines then
51375: LD_VAR 0 21
51379: IFFALSE 51622
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51381: LD_VAR 0 14
51385: PUSH
51386: LD_INT 1
51388: ARRAY
51389: PPUSH
51390: CALL_OW 247
51394: PUSH
51395: LD_INT 3
51397: EQUAL
51398: PUSH
51399: LD_VAR 0 14
51403: PUSH
51404: LD_INT 1
51406: ARRAY
51407: PUSH
51408: LD_VAR 0 27
51412: IN
51413: NOT
51414: AND
51415: IFFALSE 51622
// begin x := GetX ( tmp [ 1 ] ) ;
51417: LD_ADDR_VAR 0 10
51421: PUSH
51422: LD_VAR 0 14
51426: PUSH
51427: LD_INT 1
51429: ARRAY
51430: PPUSH
51431: CALL_OW 250
51435: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51436: LD_ADDR_VAR 0 11
51440: PUSH
51441: LD_VAR 0 14
51445: PUSH
51446: LD_INT 1
51448: ARRAY
51449: PPUSH
51450: CALL_OW 251
51454: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51455: LD_ADDR_VAR 0 12
51459: PUSH
51460: LD_VAR 0 4
51464: PUSH
51465: LD_VAR 0 7
51469: ARRAY
51470: PPUSH
51471: CALL 47350 0 1
51475: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51476: LD_VAR 0 4
51480: PUSH
51481: LD_VAR 0 7
51485: ARRAY
51486: PPUSH
51487: LD_VAR 0 10
51491: PPUSH
51492: LD_VAR 0 11
51496: PPUSH
51497: LD_VAR 0 14
51501: PUSH
51502: LD_INT 1
51504: ARRAY
51505: PPUSH
51506: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51510: LD_VAR 0 4
51514: PUSH
51515: LD_VAR 0 7
51519: ARRAY
51520: PPUSH
51521: LD_VAR 0 10
51525: PPUSH
51526: LD_VAR 0 12
51530: PPUSH
51531: LD_INT 7
51533: PPUSH
51534: CALL_OW 272
51538: PPUSH
51539: LD_VAR 0 11
51543: PPUSH
51544: LD_VAR 0 12
51548: PPUSH
51549: LD_INT 7
51551: PPUSH
51552: CALL_OW 273
51556: PPUSH
51557: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51561: LD_VAR 0 4
51565: PUSH
51566: LD_VAR 0 7
51570: ARRAY
51571: PPUSH
51572: LD_INT 71
51574: PPUSH
51575: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51579: LD_ADDR_VAR 0 27
51583: PUSH
51584: LD_VAR 0 27
51588: PPUSH
51589: LD_VAR 0 27
51593: PUSH
51594: LD_INT 1
51596: PLUS
51597: PPUSH
51598: LD_VAR 0 14
51602: PUSH
51603: LD_INT 1
51605: ARRAY
51606: PPUSH
51607: CALL_OW 1
51611: ST_TO_ADDR
// attacking := true ;
51612: LD_ADDR_VAR 0 29
51616: PUSH
51617: LD_INT 1
51619: ST_TO_ADDR
// continue ;
51620: GO 49467
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51622: LD_VAR 0 4
51626: PUSH
51627: LD_VAR 0 7
51631: ARRAY
51632: PPUSH
51633: CALL_OW 257
51637: PUSH
51638: LD_INT 17
51640: EQUAL
51641: PUSH
51642: LD_VAR 0 4
51646: PUSH
51647: LD_VAR 0 7
51651: ARRAY
51652: PPUSH
51653: CALL_OW 110
51657: PUSH
51658: LD_INT 71
51660: EQUAL
51661: NOT
51662: AND
51663: IFFALSE 51809
// begin attacking := false ;
51665: LD_ADDR_VAR 0 29
51669: PUSH
51670: LD_INT 0
51672: ST_TO_ADDR
// k := 5 ;
51673: LD_ADDR_VAR 0 9
51677: PUSH
51678: LD_INT 5
51680: ST_TO_ADDR
// if tmp < k then
51681: LD_VAR 0 14
51685: PUSH
51686: LD_VAR 0 9
51690: LESS
51691: IFFALSE 51703
// k := tmp ;
51693: LD_ADDR_VAR 0 9
51697: PUSH
51698: LD_VAR 0 14
51702: ST_TO_ADDR
// for j = 1 to k do
51703: LD_ADDR_VAR 0 8
51707: PUSH
51708: DOUBLE
51709: LD_INT 1
51711: DEC
51712: ST_TO_ADDR
51713: LD_VAR 0 9
51717: PUSH
51718: FOR_TO
51719: IFFALSE 51807
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51721: LD_VAR 0 14
51725: PUSH
51726: LD_VAR 0 8
51730: ARRAY
51731: PUSH
51732: LD_VAR 0 14
51736: PPUSH
51737: LD_INT 58
51739: PUSH
51740: EMPTY
51741: LIST
51742: PPUSH
51743: CALL_OW 72
51747: IN
51748: NOT
51749: IFFALSE 51805
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51751: LD_VAR 0 4
51755: PUSH
51756: LD_VAR 0 7
51760: ARRAY
51761: PPUSH
51762: LD_VAR 0 14
51766: PUSH
51767: LD_VAR 0 8
51771: ARRAY
51772: PPUSH
51773: CALL_OW 115
// attacking := true ;
51777: LD_ADDR_VAR 0 29
51781: PUSH
51782: LD_INT 1
51784: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51785: LD_VAR 0 4
51789: PUSH
51790: LD_VAR 0 7
51794: ARRAY
51795: PPUSH
51796: LD_INT 71
51798: PPUSH
51799: CALL_OW 109
// continue ;
51803: GO 51718
// end ; end ;
51805: GO 51718
51807: POP
51808: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51809: LD_VAR 0 4
51813: PUSH
51814: LD_VAR 0 7
51818: ARRAY
51819: PPUSH
51820: CALL_OW 257
51824: PUSH
51825: LD_INT 8
51827: EQUAL
51828: PUSH
51829: LD_VAR 0 4
51833: PUSH
51834: LD_VAR 0 7
51838: ARRAY
51839: PPUSH
51840: CALL_OW 264
51844: PUSH
51845: LD_INT 28
51847: PUSH
51848: LD_INT 45
51850: PUSH
51851: LD_INT 7
51853: PUSH
51854: LD_INT 47
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: LIST
51861: LIST
51862: IN
51863: OR
51864: IFFALSE 52094
// begin attacking := false ;
51866: LD_ADDR_VAR 0 29
51870: PUSH
51871: LD_INT 0
51873: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51874: LD_VAR 0 14
51878: PUSH
51879: LD_INT 1
51881: ARRAY
51882: PPUSH
51883: CALL_OW 266
51887: PUSH
51888: LD_INT 32
51890: PUSH
51891: LD_INT 31
51893: PUSH
51894: LD_INT 33
51896: PUSH
51897: LD_INT 4
51899: PUSH
51900: LD_INT 5
51902: PUSH
51903: EMPTY
51904: LIST
51905: LIST
51906: LIST
51907: LIST
51908: LIST
51909: IN
51910: IFFALSE 52094
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51912: LD_ADDR_VAR 0 9
51916: PUSH
51917: LD_VAR 0 14
51921: PUSH
51922: LD_INT 1
51924: ARRAY
51925: PPUSH
51926: CALL_OW 266
51930: PPUSH
51931: LD_VAR 0 14
51935: PUSH
51936: LD_INT 1
51938: ARRAY
51939: PPUSH
51940: CALL_OW 250
51944: PPUSH
51945: LD_VAR 0 14
51949: PUSH
51950: LD_INT 1
51952: ARRAY
51953: PPUSH
51954: CALL_OW 251
51958: PPUSH
51959: LD_VAR 0 14
51963: PUSH
51964: LD_INT 1
51966: ARRAY
51967: PPUSH
51968: CALL_OW 254
51972: PPUSH
51973: LD_VAR 0 14
51977: PUSH
51978: LD_INT 1
51980: ARRAY
51981: PPUSH
51982: CALL_OW 248
51986: PPUSH
51987: LD_INT 0
51989: PPUSH
51990: CALL 28726 0 6
51994: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
51995: LD_ADDR_VAR 0 8
51999: PUSH
52000: LD_VAR 0 4
52004: PUSH
52005: LD_VAR 0 7
52009: ARRAY
52010: PPUSH
52011: LD_VAR 0 9
52015: PPUSH
52016: CALL 47413 0 2
52020: ST_TO_ADDR
// if j then
52021: LD_VAR 0 8
52025: IFFALSE 52094
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52027: LD_VAR 0 8
52031: PUSH
52032: LD_INT 1
52034: ARRAY
52035: PPUSH
52036: LD_VAR 0 8
52040: PUSH
52041: LD_INT 2
52043: ARRAY
52044: PPUSH
52045: CALL_OW 488
52049: IFFALSE 52094
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52051: LD_VAR 0 4
52055: PUSH
52056: LD_VAR 0 7
52060: ARRAY
52061: PPUSH
52062: LD_VAR 0 8
52066: PUSH
52067: LD_INT 1
52069: ARRAY
52070: PPUSH
52071: LD_VAR 0 8
52075: PUSH
52076: LD_INT 2
52078: ARRAY
52079: PPUSH
52080: CALL_OW 116
// attacking := true ;
52084: LD_ADDR_VAR 0 29
52088: PUSH
52089: LD_INT 1
52091: ST_TO_ADDR
// continue ;
52092: GO 49467
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52094: LD_VAR 0 4
52098: PUSH
52099: LD_VAR 0 7
52103: ARRAY
52104: PPUSH
52105: CALL_OW 265
52109: PUSH
52110: LD_INT 11
52112: EQUAL
52113: IFFALSE 52391
// begin k := 10 ;
52115: LD_ADDR_VAR 0 9
52119: PUSH
52120: LD_INT 10
52122: ST_TO_ADDR
// x := 0 ;
52123: LD_ADDR_VAR 0 10
52127: PUSH
52128: LD_INT 0
52130: ST_TO_ADDR
// if tmp < k then
52131: LD_VAR 0 14
52135: PUSH
52136: LD_VAR 0 9
52140: LESS
52141: IFFALSE 52153
// k := tmp ;
52143: LD_ADDR_VAR 0 9
52147: PUSH
52148: LD_VAR 0 14
52152: ST_TO_ADDR
// for j = k downto 1 do
52153: LD_ADDR_VAR 0 8
52157: PUSH
52158: DOUBLE
52159: LD_VAR 0 9
52163: INC
52164: ST_TO_ADDR
52165: LD_INT 1
52167: PUSH
52168: FOR_DOWNTO
52169: IFFALSE 52244
// begin if GetType ( tmp [ j ] ) = unit_human then
52171: LD_VAR 0 14
52175: PUSH
52176: LD_VAR 0 8
52180: ARRAY
52181: PPUSH
52182: CALL_OW 247
52186: PUSH
52187: LD_INT 1
52189: EQUAL
52190: IFFALSE 52242
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52192: LD_VAR 0 4
52196: PUSH
52197: LD_VAR 0 7
52201: ARRAY
52202: PPUSH
52203: LD_VAR 0 14
52207: PUSH
52208: LD_VAR 0 8
52212: ARRAY
52213: PPUSH
52214: CALL 47684 0 2
// x := tmp [ j ] ;
52218: LD_ADDR_VAR 0 10
52222: PUSH
52223: LD_VAR 0 14
52227: PUSH
52228: LD_VAR 0 8
52232: ARRAY
52233: ST_TO_ADDR
// attacking := true ;
52234: LD_ADDR_VAR 0 29
52238: PUSH
52239: LD_INT 1
52241: ST_TO_ADDR
// end ; end ;
52242: GO 52168
52244: POP
52245: POP
// if not x then
52246: LD_VAR 0 10
52250: NOT
52251: IFFALSE 52391
// begin attacking := true ;
52253: LD_ADDR_VAR 0 29
52257: PUSH
52258: LD_INT 1
52260: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52261: LD_VAR 0 4
52265: PUSH
52266: LD_VAR 0 7
52270: ARRAY
52271: PPUSH
52272: CALL_OW 250
52276: PPUSH
52277: LD_VAR 0 4
52281: PUSH
52282: LD_VAR 0 7
52286: ARRAY
52287: PPUSH
52288: CALL_OW 251
52292: PPUSH
52293: CALL_OW 546
52297: PUSH
52298: LD_INT 2
52300: ARRAY
52301: PUSH
52302: LD_VAR 0 14
52306: PUSH
52307: LD_INT 1
52309: ARRAY
52310: PPUSH
52311: CALL_OW 250
52315: PPUSH
52316: LD_VAR 0 14
52320: PUSH
52321: LD_INT 1
52323: ARRAY
52324: PPUSH
52325: CALL_OW 251
52329: PPUSH
52330: CALL_OW 546
52334: PUSH
52335: LD_INT 2
52337: ARRAY
52338: EQUAL
52339: IFFALSE 52367
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52341: LD_VAR 0 4
52345: PUSH
52346: LD_VAR 0 7
52350: ARRAY
52351: PPUSH
52352: LD_VAR 0 14
52356: PUSH
52357: LD_INT 1
52359: ARRAY
52360: PPUSH
52361: CALL 47684 0 2
52365: GO 52391
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52367: LD_VAR 0 4
52371: PUSH
52372: LD_VAR 0 7
52376: ARRAY
52377: PPUSH
52378: LD_VAR 0 14
52382: PUSH
52383: LD_INT 1
52385: ARRAY
52386: PPUSH
52387: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52391: LD_VAR 0 4
52395: PUSH
52396: LD_VAR 0 7
52400: ARRAY
52401: PPUSH
52402: CALL_OW 264
52406: PUSH
52407: LD_INT 29
52409: EQUAL
52410: IFFALSE 52776
// begin if WantsToAttack ( group [ i ] ) in bombed then
52412: LD_VAR 0 4
52416: PUSH
52417: LD_VAR 0 7
52421: ARRAY
52422: PPUSH
52423: CALL_OW 319
52427: PUSH
52428: LD_VAR 0 28
52432: IN
52433: IFFALSE 52437
// continue ;
52435: GO 49467
// k := 8 ;
52437: LD_ADDR_VAR 0 9
52441: PUSH
52442: LD_INT 8
52444: ST_TO_ADDR
// x := 0 ;
52445: LD_ADDR_VAR 0 10
52449: PUSH
52450: LD_INT 0
52452: ST_TO_ADDR
// if tmp < k then
52453: LD_VAR 0 14
52457: PUSH
52458: LD_VAR 0 9
52462: LESS
52463: IFFALSE 52475
// k := tmp ;
52465: LD_ADDR_VAR 0 9
52469: PUSH
52470: LD_VAR 0 14
52474: ST_TO_ADDR
// for j = 1 to k do
52475: LD_ADDR_VAR 0 8
52479: PUSH
52480: DOUBLE
52481: LD_INT 1
52483: DEC
52484: ST_TO_ADDR
52485: LD_VAR 0 9
52489: PUSH
52490: FOR_TO
52491: IFFALSE 52623
// begin if GetType ( tmp [ j ] ) = unit_building then
52493: LD_VAR 0 14
52497: PUSH
52498: LD_VAR 0 8
52502: ARRAY
52503: PPUSH
52504: CALL_OW 247
52508: PUSH
52509: LD_INT 3
52511: EQUAL
52512: IFFALSE 52621
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52514: LD_VAR 0 14
52518: PUSH
52519: LD_VAR 0 8
52523: ARRAY
52524: PUSH
52525: LD_VAR 0 28
52529: IN
52530: NOT
52531: PUSH
52532: LD_VAR 0 14
52536: PUSH
52537: LD_VAR 0 8
52541: ARRAY
52542: PPUSH
52543: CALL_OW 313
52547: AND
52548: IFFALSE 52621
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52550: LD_VAR 0 4
52554: PUSH
52555: LD_VAR 0 7
52559: ARRAY
52560: PPUSH
52561: LD_VAR 0 14
52565: PUSH
52566: LD_VAR 0 8
52570: ARRAY
52571: PPUSH
52572: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52576: LD_ADDR_VAR 0 28
52580: PUSH
52581: LD_VAR 0 28
52585: PPUSH
52586: LD_VAR 0 28
52590: PUSH
52591: LD_INT 1
52593: PLUS
52594: PPUSH
52595: LD_VAR 0 14
52599: PUSH
52600: LD_VAR 0 8
52604: ARRAY
52605: PPUSH
52606: CALL_OW 1
52610: ST_TO_ADDR
// attacking := true ;
52611: LD_ADDR_VAR 0 29
52615: PUSH
52616: LD_INT 1
52618: ST_TO_ADDR
// break ;
52619: GO 52623
// end ; end ;
52621: GO 52490
52623: POP
52624: POP
// if not attacking and f_attack_depot then
52625: LD_VAR 0 29
52629: NOT
52630: PUSH
52631: LD_VAR 0 25
52635: AND
52636: IFFALSE 52731
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52638: LD_ADDR_VAR 0 13
52642: PUSH
52643: LD_VAR 0 14
52647: PPUSH
52648: LD_INT 2
52650: PUSH
52651: LD_INT 30
52653: PUSH
52654: LD_INT 0
52656: PUSH
52657: EMPTY
52658: LIST
52659: LIST
52660: PUSH
52661: LD_INT 30
52663: PUSH
52664: LD_INT 1
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: PUSH
52671: EMPTY
52672: LIST
52673: LIST
52674: LIST
52675: PPUSH
52676: CALL_OW 72
52680: ST_TO_ADDR
// if z then
52681: LD_VAR 0 13
52685: IFFALSE 52731
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52687: LD_VAR 0 4
52691: PUSH
52692: LD_VAR 0 7
52696: ARRAY
52697: PPUSH
52698: LD_VAR 0 13
52702: PPUSH
52703: LD_VAR 0 4
52707: PUSH
52708: LD_VAR 0 7
52712: ARRAY
52713: PPUSH
52714: CALL_OW 74
52718: PPUSH
52719: CALL_OW 115
// attacking := true ;
52723: LD_ADDR_VAR 0 29
52727: PUSH
52728: LD_INT 1
52730: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52731: LD_VAR 0 4
52735: PUSH
52736: LD_VAR 0 7
52740: ARRAY
52741: PPUSH
52742: CALL_OW 256
52746: PUSH
52747: LD_INT 500
52749: LESS
52750: IFFALSE 52776
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52752: LD_VAR 0 4
52756: PUSH
52757: LD_VAR 0 7
52761: ARRAY
52762: PPUSH
52763: LD_VAR 0 14
52767: PUSH
52768: LD_INT 1
52770: ARRAY
52771: PPUSH
52772: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52776: LD_VAR 0 4
52780: PUSH
52781: LD_VAR 0 7
52785: ARRAY
52786: PPUSH
52787: CALL_OW 264
52791: PUSH
52792: LD_INT 49
52794: EQUAL
52795: IFFALSE 52916
// begin if not HasTask ( group [ i ] ) then
52797: LD_VAR 0 4
52801: PUSH
52802: LD_VAR 0 7
52806: ARRAY
52807: PPUSH
52808: CALL_OW 314
52812: NOT
52813: IFFALSE 52916
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52815: LD_ADDR_VAR 0 9
52819: PUSH
52820: LD_INT 81
52822: PUSH
52823: LD_VAR 0 4
52827: PUSH
52828: LD_VAR 0 7
52832: ARRAY
52833: PPUSH
52834: CALL_OW 255
52838: PUSH
52839: EMPTY
52840: LIST
52841: LIST
52842: PPUSH
52843: CALL_OW 69
52847: PPUSH
52848: LD_VAR 0 4
52852: PUSH
52853: LD_VAR 0 7
52857: ARRAY
52858: PPUSH
52859: CALL_OW 74
52863: ST_TO_ADDR
// if k then
52864: LD_VAR 0 9
52868: IFFALSE 52916
// if GetDistUnits ( group [ i ] , k ) > 10 then
52870: LD_VAR 0 4
52874: PUSH
52875: LD_VAR 0 7
52879: ARRAY
52880: PPUSH
52881: LD_VAR 0 9
52885: PPUSH
52886: CALL_OW 296
52890: PUSH
52891: LD_INT 10
52893: GREATER
52894: IFFALSE 52916
// ComMoveUnit ( group [ i ] , k ) ;
52896: LD_VAR 0 4
52900: PUSH
52901: LD_VAR 0 7
52905: ARRAY
52906: PPUSH
52907: LD_VAR 0 9
52911: PPUSH
52912: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52916: LD_VAR 0 4
52920: PUSH
52921: LD_VAR 0 7
52925: ARRAY
52926: PPUSH
52927: CALL_OW 256
52931: PUSH
52932: LD_INT 250
52934: LESS
52935: PUSH
52936: LD_VAR 0 4
52940: PUSH
52941: LD_VAR 0 7
52945: ARRAY
52946: PUSH
52947: LD_INT 21
52949: PUSH
52950: LD_INT 2
52952: PUSH
52953: EMPTY
52954: LIST
52955: LIST
52956: PUSH
52957: LD_INT 23
52959: PUSH
52960: LD_INT 2
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: PUSH
52967: EMPTY
52968: LIST
52969: LIST
52970: PPUSH
52971: CALL_OW 69
52975: IN
52976: AND
52977: IFFALSE 53102
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
52979: LD_ADDR_VAR 0 9
52983: PUSH
52984: LD_OWVAR 3
52988: PUSH
52989: LD_VAR 0 4
52993: PUSH
52994: LD_VAR 0 7
52998: ARRAY
52999: DIFF
53000: PPUSH
53001: LD_VAR 0 4
53005: PUSH
53006: LD_VAR 0 7
53010: ARRAY
53011: PPUSH
53012: CALL_OW 74
53016: ST_TO_ADDR
// if not k then
53017: LD_VAR 0 9
53021: NOT
53022: IFFALSE 53026
// continue ;
53024: GO 49467
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53026: LD_VAR 0 9
53030: PUSH
53031: LD_INT 81
53033: PUSH
53034: LD_VAR 0 4
53038: PUSH
53039: LD_VAR 0 7
53043: ARRAY
53044: PPUSH
53045: CALL_OW 255
53049: PUSH
53050: EMPTY
53051: LIST
53052: LIST
53053: PPUSH
53054: CALL_OW 69
53058: IN
53059: PUSH
53060: LD_VAR 0 9
53064: PPUSH
53065: LD_VAR 0 4
53069: PUSH
53070: LD_VAR 0 7
53074: ARRAY
53075: PPUSH
53076: CALL_OW 296
53080: PUSH
53081: LD_INT 5
53083: LESS
53084: AND
53085: IFFALSE 53102
// ComAutodestruct ( group [ i ] ) ;
53087: LD_VAR 0 4
53091: PUSH
53092: LD_VAR 0 7
53096: ARRAY
53097: PPUSH
53098: CALL 47582 0 1
// end ; if f_attack_depot then
53102: LD_VAR 0 25
53106: IFFALSE 53218
// begin k := 6 ;
53108: LD_ADDR_VAR 0 9
53112: PUSH
53113: LD_INT 6
53115: ST_TO_ADDR
// if tmp < k then
53116: LD_VAR 0 14
53120: PUSH
53121: LD_VAR 0 9
53125: LESS
53126: IFFALSE 53138
// k := tmp ;
53128: LD_ADDR_VAR 0 9
53132: PUSH
53133: LD_VAR 0 14
53137: ST_TO_ADDR
// for j = 1 to k do
53138: LD_ADDR_VAR 0 8
53142: PUSH
53143: DOUBLE
53144: LD_INT 1
53146: DEC
53147: ST_TO_ADDR
53148: LD_VAR 0 9
53152: PUSH
53153: FOR_TO
53154: IFFALSE 53216
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53156: LD_VAR 0 8
53160: PPUSH
53161: CALL_OW 266
53165: PUSH
53166: LD_INT 0
53168: PUSH
53169: LD_INT 1
53171: PUSH
53172: EMPTY
53173: LIST
53174: LIST
53175: IN
53176: IFFALSE 53214
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53178: LD_VAR 0 4
53182: PUSH
53183: LD_VAR 0 7
53187: ARRAY
53188: PPUSH
53189: LD_VAR 0 14
53193: PUSH
53194: LD_VAR 0 8
53198: ARRAY
53199: PPUSH
53200: CALL_OW 115
// attacking := true ;
53204: LD_ADDR_VAR 0 29
53208: PUSH
53209: LD_INT 1
53211: ST_TO_ADDR
// break ;
53212: GO 53216
// end ;
53214: GO 53153
53216: POP
53217: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53218: LD_VAR 0 4
53222: PUSH
53223: LD_VAR 0 7
53227: ARRAY
53228: PPUSH
53229: CALL_OW 302
53233: PUSH
53234: LD_VAR 0 29
53238: NOT
53239: AND
53240: IFFALSE 53562
// begin if GetTag ( group [ i ] ) = 71 then
53242: LD_VAR 0 4
53246: PUSH
53247: LD_VAR 0 7
53251: ARRAY
53252: PPUSH
53253: CALL_OW 110
53257: PUSH
53258: LD_INT 71
53260: EQUAL
53261: IFFALSE 53302
// begin if HasTask ( group [ i ] ) then
53263: LD_VAR 0 4
53267: PUSH
53268: LD_VAR 0 7
53272: ARRAY
53273: PPUSH
53274: CALL_OW 314
53278: IFFALSE 53284
// continue else
53280: GO 49467
53282: GO 53302
// SetTag ( group [ i ] , 0 ) ;
53284: LD_VAR 0 4
53288: PUSH
53289: LD_VAR 0 7
53293: ARRAY
53294: PPUSH
53295: LD_INT 0
53297: PPUSH
53298: CALL_OW 109
// end ; k := 8 ;
53302: LD_ADDR_VAR 0 9
53306: PUSH
53307: LD_INT 8
53309: ST_TO_ADDR
// x := 0 ;
53310: LD_ADDR_VAR 0 10
53314: PUSH
53315: LD_INT 0
53317: ST_TO_ADDR
// if tmp < k then
53318: LD_VAR 0 14
53322: PUSH
53323: LD_VAR 0 9
53327: LESS
53328: IFFALSE 53340
// k := tmp ;
53330: LD_ADDR_VAR 0 9
53334: PUSH
53335: LD_VAR 0 14
53339: ST_TO_ADDR
// for j = 1 to k do
53340: LD_ADDR_VAR 0 8
53344: PUSH
53345: DOUBLE
53346: LD_INT 1
53348: DEC
53349: ST_TO_ADDR
53350: LD_VAR 0 9
53354: PUSH
53355: FOR_TO
53356: IFFALSE 53454
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53358: LD_VAR 0 14
53362: PUSH
53363: LD_VAR 0 8
53367: ARRAY
53368: PPUSH
53369: CALL_OW 247
53373: PUSH
53374: LD_INT 1
53376: EQUAL
53377: PUSH
53378: LD_VAR 0 14
53382: PUSH
53383: LD_VAR 0 8
53387: ARRAY
53388: PPUSH
53389: CALL_OW 256
53393: PUSH
53394: LD_INT 250
53396: LESS
53397: PUSH
53398: LD_VAR 0 20
53402: AND
53403: PUSH
53404: LD_VAR 0 20
53408: NOT
53409: PUSH
53410: LD_VAR 0 14
53414: PUSH
53415: LD_VAR 0 8
53419: ARRAY
53420: PPUSH
53421: CALL_OW 256
53425: PUSH
53426: LD_INT 250
53428: GREATEREQUAL
53429: AND
53430: OR
53431: AND
53432: IFFALSE 53452
// begin x := tmp [ j ] ;
53434: LD_ADDR_VAR 0 10
53438: PUSH
53439: LD_VAR 0 14
53443: PUSH
53444: LD_VAR 0 8
53448: ARRAY
53449: ST_TO_ADDR
// break ;
53450: GO 53454
// end ;
53452: GO 53355
53454: POP
53455: POP
// if x then
53456: LD_VAR 0 10
53460: IFFALSE 53484
// ComAttackUnit ( group [ i ] , x ) else
53462: LD_VAR 0 4
53466: PUSH
53467: LD_VAR 0 7
53471: ARRAY
53472: PPUSH
53473: LD_VAR 0 10
53477: PPUSH
53478: CALL_OW 115
53482: GO 53508
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53484: LD_VAR 0 4
53488: PUSH
53489: LD_VAR 0 7
53493: ARRAY
53494: PPUSH
53495: LD_VAR 0 14
53499: PUSH
53500: LD_INT 1
53502: ARRAY
53503: PPUSH
53504: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53508: LD_VAR 0 4
53512: PUSH
53513: LD_VAR 0 7
53517: ARRAY
53518: PPUSH
53519: CALL_OW 314
53523: NOT
53524: IFFALSE 53562
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53526: LD_VAR 0 4
53530: PUSH
53531: LD_VAR 0 7
53535: ARRAY
53536: PPUSH
53537: LD_VAR 0 14
53541: PPUSH
53542: LD_VAR 0 4
53546: PUSH
53547: LD_VAR 0 7
53551: ARRAY
53552: PPUSH
53553: CALL_OW 74
53557: PPUSH
53558: CALL_OW 115
// end ; end ; end ;
53562: GO 49467
53564: POP
53565: POP
// wait ( 0 0$1 ) ;
53566: LD_INT 35
53568: PPUSH
53569: CALL_OW 67
// until group = [ ] ;
53573: LD_VAR 0 4
53577: PUSH
53578: EMPTY
53579: EQUAL
53580: IFFALSE 49452
// end ;
53582: LD_VAR 0 2
53586: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53587: LD_INT 0
53589: PPUSH
53590: PPUSH
53591: PPUSH
53592: PPUSH
// if not base_units then
53593: LD_VAR 0 1
53597: NOT
53598: IFFALSE 53602
// exit ;
53600: GO 53689
// result := false ;
53602: LD_ADDR_VAR 0 2
53606: PUSH
53607: LD_INT 0
53609: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53610: LD_ADDR_VAR 0 5
53614: PUSH
53615: LD_VAR 0 1
53619: PPUSH
53620: LD_INT 21
53622: PUSH
53623: LD_INT 3
53625: PUSH
53626: EMPTY
53627: LIST
53628: LIST
53629: PPUSH
53630: CALL_OW 72
53634: ST_TO_ADDR
// if not tmp then
53635: LD_VAR 0 5
53639: NOT
53640: IFFALSE 53644
// exit ;
53642: GO 53689
// for i in tmp do
53644: LD_ADDR_VAR 0 3
53648: PUSH
53649: LD_VAR 0 5
53653: PUSH
53654: FOR_IN
53655: IFFALSE 53687
// begin result := EnemyInRange ( i , 22 ) ;
53657: LD_ADDR_VAR 0 2
53661: PUSH
53662: LD_VAR 0 3
53666: PPUSH
53667: LD_INT 22
53669: PPUSH
53670: CALL 47265 0 2
53674: ST_TO_ADDR
// if result then
53675: LD_VAR 0 2
53679: IFFALSE 53685
// exit ;
53681: POP
53682: POP
53683: GO 53689
// end ;
53685: GO 53654
53687: POP
53688: POP
// end ;
53689: LD_VAR 0 2
53693: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53694: LD_INT 0
53696: PPUSH
53697: PPUSH
// if not units then
53698: LD_VAR 0 1
53702: NOT
53703: IFFALSE 53707
// exit ;
53705: GO 53777
// result := [ ] ;
53707: LD_ADDR_VAR 0 3
53711: PUSH
53712: EMPTY
53713: ST_TO_ADDR
// for i in units do
53714: LD_ADDR_VAR 0 4
53718: PUSH
53719: LD_VAR 0 1
53723: PUSH
53724: FOR_IN
53725: IFFALSE 53775
// if GetTag ( i ) = tag then
53727: LD_VAR 0 4
53731: PPUSH
53732: CALL_OW 110
53736: PUSH
53737: LD_VAR 0 2
53741: EQUAL
53742: IFFALSE 53773
// result := Insert ( result , result + 1 , i ) ;
53744: LD_ADDR_VAR 0 3
53748: PUSH
53749: LD_VAR 0 3
53753: PPUSH
53754: LD_VAR 0 3
53758: PUSH
53759: LD_INT 1
53761: PLUS
53762: PPUSH
53763: LD_VAR 0 4
53767: PPUSH
53768: CALL_OW 2
53772: ST_TO_ADDR
53773: GO 53724
53775: POP
53776: POP
// end ;
53777: LD_VAR 0 3
53781: RET
// export function IsDriver ( un ) ; begin
53782: LD_INT 0
53784: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53785: LD_ADDR_VAR 0 2
53789: PUSH
53790: LD_VAR 0 1
53794: PUSH
53795: LD_INT 55
53797: PUSH
53798: EMPTY
53799: LIST
53800: PPUSH
53801: CALL_OW 69
53805: IN
53806: ST_TO_ADDR
// end ;
53807: LD_VAR 0 2
53811: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53812: LD_INT 0
53814: PPUSH
53815: PPUSH
// list := [ ] ;
53816: LD_ADDR_VAR 0 5
53820: PUSH
53821: EMPTY
53822: ST_TO_ADDR
// case d of 0 :
53823: LD_VAR 0 3
53827: PUSH
53828: LD_INT 0
53830: DOUBLE
53831: EQUAL
53832: IFTRUE 53836
53834: GO 53969
53836: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53837: LD_ADDR_VAR 0 5
53841: PUSH
53842: LD_VAR 0 1
53846: PUSH
53847: LD_INT 4
53849: MINUS
53850: PUSH
53851: LD_VAR 0 2
53855: PUSH
53856: LD_INT 4
53858: MINUS
53859: PUSH
53860: LD_INT 2
53862: PUSH
53863: EMPTY
53864: LIST
53865: LIST
53866: LIST
53867: PUSH
53868: LD_VAR 0 1
53872: PUSH
53873: LD_INT 3
53875: MINUS
53876: PUSH
53877: LD_VAR 0 2
53881: PUSH
53882: LD_INT 1
53884: PUSH
53885: EMPTY
53886: LIST
53887: LIST
53888: LIST
53889: PUSH
53890: LD_VAR 0 1
53894: PUSH
53895: LD_INT 4
53897: PLUS
53898: PUSH
53899: LD_VAR 0 2
53903: PUSH
53904: LD_INT 4
53906: PUSH
53907: EMPTY
53908: LIST
53909: LIST
53910: LIST
53911: PUSH
53912: LD_VAR 0 1
53916: PUSH
53917: LD_INT 3
53919: PLUS
53920: PUSH
53921: LD_VAR 0 2
53925: PUSH
53926: LD_INT 3
53928: PLUS
53929: PUSH
53930: LD_INT 5
53932: PUSH
53933: EMPTY
53934: LIST
53935: LIST
53936: LIST
53937: PUSH
53938: LD_VAR 0 1
53942: PUSH
53943: LD_VAR 0 2
53947: PUSH
53948: LD_INT 4
53950: PLUS
53951: PUSH
53952: LD_INT 0
53954: PUSH
53955: EMPTY
53956: LIST
53957: LIST
53958: LIST
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: LIST
53964: LIST
53965: LIST
53966: ST_TO_ADDR
// end ; 1 :
53967: GO 54667
53969: LD_INT 1
53971: DOUBLE
53972: EQUAL
53973: IFTRUE 53977
53975: GO 54110
53977: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53978: LD_ADDR_VAR 0 5
53982: PUSH
53983: LD_VAR 0 1
53987: PUSH
53988: LD_VAR 0 2
53992: PUSH
53993: LD_INT 4
53995: MINUS
53996: PUSH
53997: LD_INT 3
53999: PUSH
54000: EMPTY
54001: LIST
54002: LIST
54003: LIST
54004: PUSH
54005: LD_VAR 0 1
54009: PUSH
54010: LD_INT 3
54012: MINUS
54013: PUSH
54014: LD_VAR 0 2
54018: PUSH
54019: LD_INT 3
54021: MINUS
54022: PUSH
54023: LD_INT 2
54025: PUSH
54026: EMPTY
54027: LIST
54028: LIST
54029: LIST
54030: PUSH
54031: LD_VAR 0 1
54035: PUSH
54036: LD_INT 4
54038: MINUS
54039: PUSH
54040: LD_VAR 0 2
54044: PUSH
54045: LD_INT 1
54047: PUSH
54048: EMPTY
54049: LIST
54050: LIST
54051: LIST
54052: PUSH
54053: LD_VAR 0 1
54057: PUSH
54058: LD_VAR 0 2
54062: PUSH
54063: LD_INT 3
54065: PLUS
54066: PUSH
54067: LD_INT 0
54069: PUSH
54070: EMPTY
54071: LIST
54072: LIST
54073: LIST
54074: PUSH
54075: LD_VAR 0 1
54079: PUSH
54080: LD_INT 4
54082: PLUS
54083: PUSH
54084: LD_VAR 0 2
54088: PUSH
54089: LD_INT 4
54091: PLUS
54092: PUSH
54093: LD_INT 5
54095: PUSH
54096: EMPTY
54097: LIST
54098: LIST
54099: LIST
54100: PUSH
54101: EMPTY
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: LIST
54107: ST_TO_ADDR
// end ; 2 :
54108: GO 54667
54110: LD_INT 2
54112: DOUBLE
54113: EQUAL
54114: IFTRUE 54118
54116: GO 54247
54118: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54119: LD_ADDR_VAR 0 5
54123: PUSH
54124: LD_VAR 0 1
54128: PUSH
54129: LD_VAR 0 2
54133: PUSH
54134: LD_INT 3
54136: MINUS
54137: PUSH
54138: LD_INT 3
54140: PUSH
54141: EMPTY
54142: LIST
54143: LIST
54144: LIST
54145: PUSH
54146: LD_VAR 0 1
54150: PUSH
54151: LD_INT 4
54153: PLUS
54154: PUSH
54155: LD_VAR 0 2
54159: PUSH
54160: LD_INT 4
54162: PUSH
54163: EMPTY
54164: LIST
54165: LIST
54166: LIST
54167: PUSH
54168: LD_VAR 0 1
54172: PUSH
54173: LD_VAR 0 2
54177: PUSH
54178: LD_INT 4
54180: PLUS
54181: PUSH
54182: LD_INT 0
54184: PUSH
54185: EMPTY
54186: LIST
54187: LIST
54188: LIST
54189: PUSH
54190: LD_VAR 0 1
54194: PUSH
54195: LD_INT 3
54197: MINUS
54198: PUSH
54199: LD_VAR 0 2
54203: PUSH
54204: LD_INT 1
54206: PUSH
54207: EMPTY
54208: LIST
54209: LIST
54210: LIST
54211: PUSH
54212: LD_VAR 0 1
54216: PUSH
54217: LD_INT 4
54219: MINUS
54220: PUSH
54221: LD_VAR 0 2
54225: PUSH
54226: LD_INT 4
54228: MINUS
54229: PUSH
54230: LD_INT 2
54232: PUSH
54233: EMPTY
54234: LIST
54235: LIST
54236: LIST
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: LIST
54242: LIST
54243: LIST
54244: ST_TO_ADDR
// end ; 3 :
54245: GO 54667
54247: LD_INT 3
54249: DOUBLE
54250: EQUAL
54251: IFTRUE 54255
54253: GO 54388
54255: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54256: LD_ADDR_VAR 0 5
54260: PUSH
54261: LD_VAR 0 1
54265: PUSH
54266: LD_INT 3
54268: PLUS
54269: PUSH
54270: LD_VAR 0 2
54274: PUSH
54275: LD_INT 4
54277: PUSH
54278: EMPTY
54279: LIST
54280: LIST
54281: LIST
54282: PUSH
54283: LD_VAR 0 1
54287: PUSH
54288: LD_INT 4
54290: PLUS
54291: PUSH
54292: LD_VAR 0 2
54296: PUSH
54297: LD_INT 4
54299: PLUS
54300: PUSH
54301: LD_INT 5
54303: PUSH
54304: EMPTY
54305: LIST
54306: LIST
54307: LIST
54308: PUSH
54309: LD_VAR 0 1
54313: PUSH
54314: LD_INT 4
54316: MINUS
54317: PUSH
54318: LD_VAR 0 2
54322: PUSH
54323: LD_INT 1
54325: PUSH
54326: EMPTY
54327: LIST
54328: LIST
54329: LIST
54330: PUSH
54331: LD_VAR 0 1
54335: PUSH
54336: LD_VAR 0 2
54340: PUSH
54341: LD_INT 4
54343: MINUS
54344: PUSH
54345: LD_INT 3
54347: PUSH
54348: EMPTY
54349: LIST
54350: LIST
54351: LIST
54352: PUSH
54353: LD_VAR 0 1
54357: PUSH
54358: LD_INT 3
54360: MINUS
54361: PUSH
54362: LD_VAR 0 2
54366: PUSH
54367: LD_INT 3
54369: MINUS
54370: PUSH
54371: LD_INT 2
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: LIST
54378: PUSH
54379: EMPTY
54380: LIST
54381: LIST
54382: LIST
54383: LIST
54384: LIST
54385: ST_TO_ADDR
// end ; 4 :
54386: GO 54667
54388: LD_INT 4
54390: DOUBLE
54391: EQUAL
54392: IFTRUE 54396
54394: GO 54529
54396: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54397: LD_ADDR_VAR 0 5
54401: PUSH
54402: LD_VAR 0 1
54406: PUSH
54407: LD_VAR 0 2
54411: PUSH
54412: LD_INT 4
54414: PLUS
54415: PUSH
54416: LD_INT 0
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: LIST
54423: PUSH
54424: LD_VAR 0 1
54428: PUSH
54429: LD_INT 3
54431: PLUS
54432: PUSH
54433: LD_VAR 0 2
54437: PUSH
54438: LD_INT 3
54440: PLUS
54441: PUSH
54442: LD_INT 5
54444: PUSH
54445: EMPTY
54446: LIST
54447: LIST
54448: LIST
54449: PUSH
54450: LD_VAR 0 1
54454: PUSH
54455: LD_INT 4
54457: PLUS
54458: PUSH
54459: LD_VAR 0 2
54463: PUSH
54464: LD_INT 4
54466: PUSH
54467: EMPTY
54468: LIST
54469: LIST
54470: LIST
54471: PUSH
54472: LD_VAR 0 1
54476: PUSH
54477: LD_VAR 0 2
54481: PUSH
54482: LD_INT 3
54484: MINUS
54485: PUSH
54486: LD_INT 3
54488: PUSH
54489: EMPTY
54490: LIST
54491: LIST
54492: LIST
54493: PUSH
54494: LD_VAR 0 1
54498: PUSH
54499: LD_INT 4
54501: MINUS
54502: PUSH
54503: LD_VAR 0 2
54507: PUSH
54508: LD_INT 4
54510: MINUS
54511: PUSH
54512: LD_INT 2
54514: PUSH
54515: EMPTY
54516: LIST
54517: LIST
54518: LIST
54519: PUSH
54520: EMPTY
54521: LIST
54522: LIST
54523: LIST
54524: LIST
54525: LIST
54526: ST_TO_ADDR
// end ; 5 :
54527: GO 54667
54529: LD_INT 5
54531: DOUBLE
54532: EQUAL
54533: IFTRUE 54537
54535: GO 54666
54537: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54538: LD_ADDR_VAR 0 5
54542: PUSH
54543: LD_VAR 0 1
54547: PUSH
54548: LD_INT 4
54550: MINUS
54551: PUSH
54552: LD_VAR 0 2
54556: PUSH
54557: LD_INT 1
54559: PUSH
54560: EMPTY
54561: LIST
54562: LIST
54563: LIST
54564: PUSH
54565: LD_VAR 0 1
54569: PUSH
54570: LD_VAR 0 2
54574: PUSH
54575: LD_INT 4
54577: MINUS
54578: PUSH
54579: LD_INT 3
54581: PUSH
54582: EMPTY
54583: LIST
54584: LIST
54585: LIST
54586: PUSH
54587: LD_VAR 0 1
54591: PUSH
54592: LD_INT 4
54594: PLUS
54595: PUSH
54596: LD_VAR 0 2
54600: PUSH
54601: LD_INT 4
54603: PLUS
54604: PUSH
54605: LD_INT 5
54607: PUSH
54608: EMPTY
54609: LIST
54610: LIST
54611: LIST
54612: PUSH
54613: LD_VAR 0 1
54617: PUSH
54618: LD_INT 3
54620: PLUS
54621: PUSH
54622: LD_VAR 0 2
54626: PUSH
54627: LD_INT 4
54629: PUSH
54630: EMPTY
54631: LIST
54632: LIST
54633: LIST
54634: PUSH
54635: LD_VAR 0 1
54639: PUSH
54640: LD_VAR 0 2
54644: PUSH
54645: LD_INT 3
54647: PLUS
54648: PUSH
54649: LD_INT 0
54651: PUSH
54652: EMPTY
54653: LIST
54654: LIST
54655: LIST
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: LIST
54662: LIST
54663: ST_TO_ADDR
// end ; end ;
54664: GO 54667
54666: POP
// result := list ;
54667: LD_ADDR_VAR 0 4
54671: PUSH
54672: LD_VAR 0 5
54676: ST_TO_ADDR
// end ;
54677: LD_VAR 0 4
54681: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54682: LD_INT 0
54684: PPUSH
54685: PPUSH
54686: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54687: LD_VAR 0 1
54691: NOT
54692: PUSH
54693: LD_VAR 0 2
54697: PUSH
54698: LD_INT 1
54700: PUSH
54701: LD_INT 2
54703: PUSH
54704: LD_INT 3
54706: PUSH
54707: LD_INT 4
54709: PUSH
54710: EMPTY
54711: LIST
54712: LIST
54713: LIST
54714: LIST
54715: IN
54716: NOT
54717: OR
54718: IFFALSE 54722
// exit ;
54720: GO 54814
// tmp := [ ] ;
54722: LD_ADDR_VAR 0 5
54726: PUSH
54727: EMPTY
54728: ST_TO_ADDR
// for i in units do
54729: LD_ADDR_VAR 0 4
54733: PUSH
54734: LD_VAR 0 1
54738: PUSH
54739: FOR_IN
54740: IFFALSE 54783
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54742: LD_ADDR_VAR 0 5
54746: PUSH
54747: LD_VAR 0 5
54751: PPUSH
54752: LD_VAR 0 5
54756: PUSH
54757: LD_INT 1
54759: PLUS
54760: PPUSH
54761: LD_VAR 0 4
54765: PPUSH
54766: LD_VAR 0 2
54770: PPUSH
54771: CALL_OW 259
54775: PPUSH
54776: CALL_OW 2
54780: ST_TO_ADDR
54781: GO 54739
54783: POP
54784: POP
// if not tmp then
54785: LD_VAR 0 5
54789: NOT
54790: IFFALSE 54794
// exit ;
54792: GO 54814
// result := SortListByListDesc ( units , tmp ) ;
54794: LD_ADDR_VAR 0 3
54798: PUSH
54799: LD_VAR 0 1
54803: PPUSH
54804: LD_VAR 0 5
54808: PPUSH
54809: CALL_OW 77
54813: ST_TO_ADDR
// end ;
54814: LD_VAR 0 3
54818: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54819: LD_INT 0
54821: PPUSH
54822: PPUSH
54823: PPUSH
// x := GetX ( building ) ;
54824: LD_ADDR_VAR 0 4
54828: PUSH
54829: LD_VAR 0 2
54833: PPUSH
54834: CALL_OW 250
54838: ST_TO_ADDR
// y := GetY ( building ) ;
54839: LD_ADDR_VAR 0 5
54843: PUSH
54844: LD_VAR 0 2
54848: PPUSH
54849: CALL_OW 251
54853: ST_TO_ADDR
// if GetTaskList ( unit ) then
54854: LD_VAR 0 1
54858: PPUSH
54859: CALL_OW 437
54863: IFFALSE 54958
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54865: LD_STRING e
54867: PUSH
54868: LD_VAR 0 1
54872: PPUSH
54873: CALL_OW 437
54877: PUSH
54878: LD_INT 1
54880: ARRAY
54881: PUSH
54882: LD_INT 1
54884: ARRAY
54885: EQUAL
54886: PUSH
54887: LD_VAR 0 4
54891: PUSH
54892: LD_VAR 0 1
54896: PPUSH
54897: CALL_OW 437
54901: PUSH
54902: LD_INT 1
54904: ARRAY
54905: PUSH
54906: LD_INT 2
54908: ARRAY
54909: EQUAL
54910: AND
54911: PUSH
54912: LD_VAR 0 5
54916: PUSH
54917: LD_VAR 0 1
54921: PPUSH
54922: CALL_OW 437
54926: PUSH
54927: LD_INT 1
54929: ARRAY
54930: PUSH
54931: LD_INT 3
54933: ARRAY
54934: EQUAL
54935: AND
54936: IFFALSE 54948
// result := true else
54938: LD_ADDR_VAR 0 3
54942: PUSH
54943: LD_INT 1
54945: ST_TO_ADDR
54946: GO 54956
// result := false ;
54948: LD_ADDR_VAR 0 3
54952: PUSH
54953: LD_INT 0
54955: ST_TO_ADDR
// end else
54956: GO 54966
// result := false ;
54958: LD_ADDR_VAR 0 3
54962: PUSH
54963: LD_INT 0
54965: ST_TO_ADDR
// end ;
54966: LD_VAR 0 3
54970: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54971: LD_INT 0
54973: PPUSH
54974: PPUSH
54975: PPUSH
54976: PPUSH
// if not unit or not area then
54977: LD_VAR 0 1
54981: NOT
54982: PUSH
54983: LD_VAR 0 2
54987: NOT
54988: OR
54989: IFFALSE 54993
// exit ;
54991: GO 55158
// tmp := AreaToList ( area , i ) ;
54993: LD_ADDR_VAR 0 6
54997: PUSH
54998: LD_VAR 0 2
55002: PPUSH
55003: LD_VAR 0 5
55007: PPUSH
55008: CALL_OW 517
55012: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55013: LD_ADDR_VAR 0 5
55017: PUSH
55018: DOUBLE
55019: LD_INT 1
55021: DEC
55022: ST_TO_ADDR
55023: LD_VAR 0 6
55027: PUSH
55028: LD_INT 1
55030: ARRAY
55031: PUSH
55032: FOR_TO
55033: IFFALSE 55148
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55035: LD_ADDR_VAR 0 7
55039: PUSH
55040: LD_VAR 0 6
55044: PUSH
55045: LD_INT 1
55047: ARRAY
55048: PUSH
55049: LD_VAR 0 5
55053: ARRAY
55054: PUSH
55055: LD_VAR 0 6
55059: PUSH
55060: LD_INT 2
55062: ARRAY
55063: PUSH
55064: LD_VAR 0 5
55068: ARRAY
55069: PUSH
55070: EMPTY
55071: LIST
55072: LIST
55073: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55074: LD_VAR 0 7
55078: PUSH
55079: LD_INT 1
55081: ARRAY
55082: PPUSH
55083: LD_VAR 0 7
55087: PUSH
55088: LD_INT 2
55090: ARRAY
55091: PPUSH
55092: CALL_OW 428
55096: PUSH
55097: LD_INT 0
55099: EQUAL
55100: IFFALSE 55146
// begin result := true ;
55102: LD_ADDR_VAR 0 4
55106: PUSH
55107: LD_INT 1
55109: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55110: LD_VAR 0 1
55114: PPUSH
55115: LD_VAR 0 7
55119: PUSH
55120: LD_INT 1
55122: ARRAY
55123: PPUSH
55124: LD_VAR 0 7
55128: PUSH
55129: LD_INT 2
55131: ARRAY
55132: PPUSH
55133: LD_VAR 0 3
55137: PPUSH
55138: CALL_OW 48
// exit ;
55142: POP
55143: POP
55144: GO 55158
// end ; end ;
55146: GO 55032
55148: POP
55149: POP
// result := false ;
55150: LD_ADDR_VAR 0 4
55154: PUSH
55155: LD_INT 0
55157: ST_TO_ADDR
// end ;
55158: LD_VAR 0 4
55162: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55163: LD_INT 0
55165: PPUSH
55166: PPUSH
55167: PPUSH
// if not side or side > 8 then
55168: LD_VAR 0 1
55172: NOT
55173: PUSH
55174: LD_VAR 0 1
55178: PUSH
55179: LD_INT 8
55181: GREATER
55182: OR
55183: IFFALSE 55187
// exit ;
55185: GO 55374
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55187: LD_ADDR_VAR 0 4
55191: PUSH
55192: LD_INT 22
55194: PUSH
55195: LD_VAR 0 1
55199: PUSH
55200: EMPTY
55201: LIST
55202: LIST
55203: PUSH
55204: LD_INT 21
55206: PUSH
55207: LD_INT 3
55209: PUSH
55210: EMPTY
55211: LIST
55212: LIST
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: PPUSH
55218: CALL_OW 69
55222: ST_TO_ADDR
// if not tmp then
55223: LD_VAR 0 4
55227: NOT
55228: IFFALSE 55232
// exit ;
55230: GO 55374
// enable_addtolog := true ;
55232: LD_ADDR_OWVAR 81
55236: PUSH
55237: LD_INT 1
55239: ST_TO_ADDR
// AddToLog ( [ ) ;
55240: LD_STRING [
55242: PPUSH
55243: CALL_OW 561
// for i in tmp do
55247: LD_ADDR_VAR 0 3
55251: PUSH
55252: LD_VAR 0 4
55256: PUSH
55257: FOR_IN
55258: IFFALSE 55365
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55260: LD_STRING [
55262: PUSH
55263: LD_VAR 0 3
55267: PPUSH
55268: CALL_OW 266
55272: STR
55273: PUSH
55274: LD_STRING , 
55276: STR
55277: PUSH
55278: LD_VAR 0 3
55282: PPUSH
55283: CALL_OW 250
55287: STR
55288: PUSH
55289: LD_STRING , 
55291: STR
55292: PUSH
55293: LD_VAR 0 3
55297: PPUSH
55298: CALL_OW 251
55302: STR
55303: PUSH
55304: LD_STRING , 
55306: STR
55307: PUSH
55308: LD_VAR 0 3
55312: PPUSH
55313: CALL_OW 254
55317: STR
55318: PUSH
55319: LD_STRING , 
55321: STR
55322: PUSH
55323: LD_VAR 0 3
55327: PPUSH
55328: LD_INT 1
55330: PPUSH
55331: CALL_OW 268
55335: STR
55336: PUSH
55337: LD_STRING , 
55339: STR
55340: PUSH
55341: LD_VAR 0 3
55345: PPUSH
55346: LD_INT 2
55348: PPUSH
55349: CALL_OW 268
55353: STR
55354: PUSH
55355: LD_STRING ],
55357: STR
55358: PPUSH
55359: CALL_OW 561
// end ;
55363: GO 55257
55365: POP
55366: POP
// AddToLog ( ]; ) ;
55367: LD_STRING ];
55369: PPUSH
55370: CALL_OW 561
// end ;
55374: LD_VAR 0 2
55378: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55379: LD_INT 0
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
55385: PPUSH
// if not area or not rate or not max then
55386: LD_VAR 0 1
55390: NOT
55391: PUSH
55392: LD_VAR 0 2
55396: NOT
55397: OR
55398: PUSH
55399: LD_VAR 0 4
55403: NOT
55404: OR
55405: IFFALSE 55409
// exit ;
55407: GO 55601
// while 1 do
55409: LD_INT 1
55411: IFFALSE 55601
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55413: LD_ADDR_VAR 0 9
55417: PUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: LD_INT 1
55425: PPUSH
55426: CALL_OW 287
55430: PUSH
55431: LD_INT 10
55433: MUL
55434: ST_TO_ADDR
// r := rate / 10 ;
55435: LD_ADDR_VAR 0 7
55439: PUSH
55440: LD_VAR 0 2
55444: PUSH
55445: LD_INT 10
55447: DIVREAL
55448: ST_TO_ADDR
// time := 1 1$00 ;
55449: LD_ADDR_VAR 0 8
55453: PUSH
55454: LD_INT 2100
55456: ST_TO_ADDR
// if amount < min then
55457: LD_VAR 0 9
55461: PUSH
55462: LD_VAR 0 3
55466: LESS
55467: IFFALSE 55485
// r := r * 2 else
55469: LD_ADDR_VAR 0 7
55473: PUSH
55474: LD_VAR 0 7
55478: PUSH
55479: LD_INT 2
55481: MUL
55482: ST_TO_ADDR
55483: GO 55511
// if amount > max then
55485: LD_VAR 0 9
55489: PUSH
55490: LD_VAR 0 4
55494: GREATER
55495: IFFALSE 55511
// r := r / 2 ;
55497: LD_ADDR_VAR 0 7
55501: PUSH
55502: LD_VAR 0 7
55506: PUSH
55507: LD_INT 2
55509: DIVREAL
55510: ST_TO_ADDR
// time := time / r ;
55511: LD_ADDR_VAR 0 8
55515: PUSH
55516: LD_VAR 0 8
55520: PUSH
55521: LD_VAR 0 7
55525: DIVREAL
55526: ST_TO_ADDR
// if time < 0 then
55527: LD_VAR 0 8
55531: PUSH
55532: LD_INT 0
55534: LESS
55535: IFFALSE 55552
// time := time * - 1 ;
55537: LD_ADDR_VAR 0 8
55541: PUSH
55542: LD_VAR 0 8
55546: PUSH
55547: LD_INT 1
55549: NEG
55550: MUL
55551: ST_TO_ADDR
// wait ( time ) ;
55552: LD_VAR 0 8
55556: PPUSH
55557: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55561: LD_INT 35
55563: PPUSH
55564: LD_INT 875
55566: PPUSH
55567: CALL_OW 12
55571: PPUSH
55572: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55576: LD_INT 1
55578: PPUSH
55579: LD_INT 5
55581: PPUSH
55582: CALL_OW 12
55586: PPUSH
55587: LD_VAR 0 1
55591: PPUSH
55592: LD_INT 1
55594: PPUSH
55595: CALL_OW 55
// end ;
55599: GO 55409
// end ;
55601: LD_VAR 0 5
55605: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55606: LD_INT 0
55608: PPUSH
55609: PPUSH
55610: PPUSH
55611: PPUSH
55612: PPUSH
55613: PPUSH
55614: PPUSH
55615: PPUSH
// if not turrets or not factories then
55616: LD_VAR 0 1
55620: NOT
55621: PUSH
55622: LD_VAR 0 2
55626: NOT
55627: OR
55628: IFFALSE 55632
// exit ;
55630: GO 55939
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55632: LD_ADDR_VAR 0 10
55636: PUSH
55637: LD_INT 5
55639: PUSH
55640: LD_INT 6
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: PUSH
55647: LD_INT 2
55649: PUSH
55650: LD_INT 4
55652: PUSH
55653: EMPTY
55654: LIST
55655: LIST
55656: PUSH
55657: LD_INT 3
55659: PUSH
55660: LD_INT 5
55662: PUSH
55663: EMPTY
55664: LIST
55665: LIST
55666: PUSH
55667: EMPTY
55668: LIST
55669: LIST
55670: LIST
55671: PUSH
55672: LD_INT 24
55674: PUSH
55675: LD_INT 25
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: PUSH
55682: LD_INT 23
55684: PUSH
55685: LD_INT 27
55687: PUSH
55688: EMPTY
55689: LIST
55690: LIST
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: PUSH
55696: LD_INT 42
55698: PUSH
55699: LD_INT 43
55701: PUSH
55702: EMPTY
55703: LIST
55704: LIST
55705: PUSH
55706: LD_INT 44
55708: PUSH
55709: LD_INT 46
55711: PUSH
55712: EMPTY
55713: LIST
55714: LIST
55715: PUSH
55716: LD_INT 45
55718: PUSH
55719: LD_INT 47
55721: PUSH
55722: EMPTY
55723: LIST
55724: LIST
55725: PUSH
55726: EMPTY
55727: LIST
55728: LIST
55729: LIST
55730: PUSH
55731: EMPTY
55732: LIST
55733: LIST
55734: LIST
55735: ST_TO_ADDR
// result := [ ] ;
55736: LD_ADDR_VAR 0 3
55740: PUSH
55741: EMPTY
55742: ST_TO_ADDR
// for i in turrets do
55743: LD_ADDR_VAR 0 4
55747: PUSH
55748: LD_VAR 0 1
55752: PUSH
55753: FOR_IN
55754: IFFALSE 55937
// begin nat := GetNation ( i ) ;
55756: LD_ADDR_VAR 0 7
55760: PUSH
55761: LD_VAR 0 4
55765: PPUSH
55766: CALL_OW 248
55770: ST_TO_ADDR
// weapon := 0 ;
55771: LD_ADDR_VAR 0 8
55775: PUSH
55776: LD_INT 0
55778: ST_TO_ADDR
// if not nat then
55779: LD_VAR 0 7
55783: NOT
55784: IFFALSE 55788
// continue ;
55786: GO 55753
// for j in list [ nat ] do
55788: LD_ADDR_VAR 0 5
55792: PUSH
55793: LD_VAR 0 10
55797: PUSH
55798: LD_VAR 0 7
55802: ARRAY
55803: PUSH
55804: FOR_IN
55805: IFFALSE 55846
// if GetBWeapon ( i ) = j [ 1 ] then
55807: LD_VAR 0 4
55811: PPUSH
55812: CALL_OW 269
55816: PUSH
55817: LD_VAR 0 5
55821: PUSH
55822: LD_INT 1
55824: ARRAY
55825: EQUAL
55826: IFFALSE 55844
// begin weapon := j [ 2 ] ;
55828: LD_ADDR_VAR 0 8
55832: PUSH
55833: LD_VAR 0 5
55837: PUSH
55838: LD_INT 2
55840: ARRAY
55841: ST_TO_ADDR
// break ;
55842: GO 55846
// end ;
55844: GO 55804
55846: POP
55847: POP
// if not weapon then
55848: LD_VAR 0 8
55852: NOT
55853: IFFALSE 55857
// continue ;
55855: GO 55753
// for k in factories do
55857: LD_ADDR_VAR 0 6
55861: PUSH
55862: LD_VAR 0 2
55866: PUSH
55867: FOR_IN
55868: IFFALSE 55933
// begin weapons := AvailableWeaponList ( k ) ;
55870: LD_ADDR_VAR 0 9
55874: PUSH
55875: LD_VAR 0 6
55879: PPUSH
55880: CALL_OW 478
55884: ST_TO_ADDR
// if not weapons then
55885: LD_VAR 0 9
55889: NOT
55890: IFFALSE 55894
// continue ;
55892: GO 55867
// if weapon in weapons then
55894: LD_VAR 0 8
55898: PUSH
55899: LD_VAR 0 9
55903: IN
55904: IFFALSE 55931
// begin result := [ i , weapon ] ;
55906: LD_ADDR_VAR 0 3
55910: PUSH
55911: LD_VAR 0 4
55915: PUSH
55916: LD_VAR 0 8
55920: PUSH
55921: EMPTY
55922: LIST
55923: LIST
55924: ST_TO_ADDR
// exit ;
55925: POP
55926: POP
55927: POP
55928: POP
55929: GO 55939
// end ; end ;
55931: GO 55867
55933: POP
55934: POP
// end ;
55935: GO 55753
55937: POP
55938: POP
// end ;
55939: LD_VAR 0 3
55943: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55944: LD_INT 0
55946: PPUSH
// if not side or side > 8 then
55947: LD_VAR 0 3
55951: NOT
55952: PUSH
55953: LD_VAR 0 3
55957: PUSH
55958: LD_INT 8
55960: GREATER
55961: OR
55962: IFFALSE 55966
// exit ;
55964: GO 56025
// if not range then
55966: LD_VAR 0 4
55970: NOT
55971: IFFALSE 55982
// range := - 12 ;
55973: LD_ADDR_VAR 0 4
55977: PUSH
55978: LD_INT 12
55980: NEG
55981: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55982: LD_VAR 0 1
55986: PPUSH
55987: LD_VAR 0 2
55991: PPUSH
55992: LD_VAR 0 3
55996: PPUSH
55997: LD_VAR 0 4
56001: PPUSH
56002: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56006: LD_VAR 0 1
56010: PPUSH
56011: LD_VAR 0 2
56015: PPUSH
56016: LD_VAR 0 3
56020: PPUSH
56021: CALL_OW 331
// end ;
56025: LD_VAR 0 5
56029: RET
// export function Video ( mode ) ; begin
56030: LD_INT 0
56032: PPUSH
// ingame_video = mode ;
56033: LD_ADDR_OWVAR 52
56037: PUSH
56038: LD_VAR 0 1
56042: ST_TO_ADDR
// interface_hidden = mode ;
56043: LD_ADDR_OWVAR 54
56047: PUSH
56048: LD_VAR 0 1
56052: ST_TO_ADDR
// end ;
56053: LD_VAR 0 2
56057: RET
// export function Join ( array , element ) ; begin
56058: LD_INT 0
56060: PPUSH
// result := array ^ element ;
56061: LD_ADDR_VAR 0 3
56065: PUSH
56066: LD_VAR 0 1
56070: PUSH
56071: LD_VAR 0 2
56075: ADD
56076: ST_TO_ADDR
// end ;
56077: LD_VAR 0 3
56081: RET
// export function JoinUnion ( array , element ) ; begin
56082: LD_INT 0
56084: PPUSH
// result := array union element ;
56085: LD_ADDR_VAR 0 3
56089: PUSH
56090: LD_VAR 0 1
56094: PUSH
56095: LD_VAR 0 2
56099: UNION
56100: ST_TO_ADDR
// end ;
56101: LD_VAR 0 3
56105: RET
// export function GetBehemoths ( side ) ; begin
56106: LD_INT 0
56108: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56109: LD_ADDR_VAR 0 2
56113: PUSH
56114: LD_INT 22
56116: PUSH
56117: LD_VAR 0 1
56121: PUSH
56122: EMPTY
56123: LIST
56124: LIST
56125: PUSH
56126: LD_INT 31
56128: PUSH
56129: LD_INT 25
56131: PUSH
56132: EMPTY
56133: LIST
56134: LIST
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: PPUSH
56140: CALL_OW 69
56144: ST_TO_ADDR
// end ;
56145: LD_VAR 0 2
56149: RET
// export function Shuffle ( array ) ; var i , index ; begin
56150: LD_INT 0
56152: PPUSH
56153: PPUSH
56154: PPUSH
// result := [ ] ;
56155: LD_ADDR_VAR 0 2
56159: PUSH
56160: EMPTY
56161: ST_TO_ADDR
// if not array then
56162: LD_VAR 0 1
56166: NOT
56167: IFFALSE 56171
// exit ;
56169: GO 56270
// Randomize ;
56171: CALL_OW 10
// for i = array downto 1 do
56175: LD_ADDR_VAR 0 3
56179: PUSH
56180: DOUBLE
56181: LD_VAR 0 1
56185: INC
56186: ST_TO_ADDR
56187: LD_INT 1
56189: PUSH
56190: FOR_DOWNTO
56191: IFFALSE 56268
// begin index := rand ( 1 , array ) ;
56193: LD_ADDR_VAR 0 4
56197: PUSH
56198: LD_INT 1
56200: PPUSH
56201: LD_VAR 0 1
56205: PPUSH
56206: CALL_OW 12
56210: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56211: LD_ADDR_VAR 0 2
56215: PUSH
56216: LD_VAR 0 2
56220: PPUSH
56221: LD_VAR 0 2
56225: PUSH
56226: LD_INT 1
56228: PLUS
56229: PPUSH
56230: LD_VAR 0 1
56234: PUSH
56235: LD_VAR 0 4
56239: ARRAY
56240: PPUSH
56241: CALL_OW 2
56245: ST_TO_ADDR
// array := Delete ( array , index ) ;
56246: LD_ADDR_VAR 0 1
56250: PUSH
56251: LD_VAR 0 1
56255: PPUSH
56256: LD_VAR 0 4
56260: PPUSH
56261: CALL_OW 3
56265: ST_TO_ADDR
// end ;
56266: GO 56190
56268: POP
56269: POP
// end ; end_of_file
56270: LD_VAR 0 2
56274: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56275: LD_INT 0
56277: PPUSH
56278: PPUSH
// skirmish := false ;
56279: LD_ADDR_EXP 56
56283: PUSH
56284: LD_INT 0
56286: ST_TO_ADDR
// debug_mc := false ;
56287: LD_ADDR_EXP 57
56291: PUSH
56292: LD_INT 0
56294: ST_TO_ADDR
// mc_bases := [ ] ;
56295: LD_ADDR_EXP 58
56299: PUSH
56300: EMPTY
56301: ST_TO_ADDR
// mc_sides := [ ] ;
56302: LD_ADDR_EXP 84
56306: PUSH
56307: EMPTY
56308: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56309: LD_ADDR_EXP 59
56313: PUSH
56314: EMPTY
56315: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56316: LD_ADDR_EXP 60
56320: PUSH
56321: EMPTY
56322: ST_TO_ADDR
// mc_need_heal := [ ] ;
56323: LD_ADDR_EXP 61
56327: PUSH
56328: EMPTY
56329: ST_TO_ADDR
// mc_healers := [ ] ;
56330: LD_ADDR_EXP 62
56334: PUSH
56335: EMPTY
56336: ST_TO_ADDR
// mc_build_list := [ ] ;
56337: LD_ADDR_EXP 63
56341: PUSH
56342: EMPTY
56343: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56344: LD_ADDR_EXP 90
56348: PUSH
56349: EMPTY
56350: ST_TO_ADDR
// mc_builders := [ ] ;
56351: LD_ADDR_EXP 64
56355: PUSH
56356: EMPTY
56357: ST_TO_ADDR
// mc_construct_list := [ ] ;
56358: LD_ADDR_EXP 65
56362: PUSH
56363: EMPTY
56364: ST_TO_ADDR
// mc_turret_list := [ ] ;
56365: LD_ADDR_EXP 66
56369: PUSH
56370: EMPTY
56371: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56372: LD_ADDR_EXP 67
56376: PUSH
56377: EMPTY
56378: ST_TO_ADDR
// mc_miners := [ ] ;
56379: LD_ADDR_EXP 72
56383: PUSH
56384: EMPTY
56385: ST_TO_ADDR
// mc_mines := [ ] ;
56386: LD_ADDR_EXP 71
56390: PUSH
56391: EMPTY
56392: ST_TO_ADDR
// mc_minefields := [ ] ;
56393: LD_ADDR_EXP 73
56397: PUSH
56398: EMPTY
56399: ST_TO_ADDR
// mc_crates := [ ] ;
56400: LD_ADDR_EXP 74
56404: PUSH
56405: EMPTY
56406: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56407: LD_ADDR_EXP 75
56411: PUSH
56412: EMPTY
56413: ST_TO_ADDR
// mc_crates_area := [ ] ;
56414: LD_ADDR_EXP 76
56418: PUSH
56419: EMPTY
56420: ST_TO_ADDR
// mc_vehicles := [ ] ;
56421: LD_ADDR_EXP 77
56425: PUSH
56426: EMPTY
56427: ST_TO_ADDR
// mc_attack := [ ] ;
56428: LD_ADDR_EXP 78
56432: PUSH
56433: EMPTY
56434: ST_TO_ADDR
// mc_produce := [ ] ;
56435: LD_ADDR_EXP 79
56439: PUSH
56440: EMPTY
56441: ST_TO_ADDR
// mc_defender := [ ] ;
56442: LD_ADDR_EXP 80
56446: PUSH
56447: EMPTY
56448: ST_TO_ADDR
// mc_parking := [ ] ;
56449: LD_ADDR_EXP 82
56453: PUSH
56454: EMPTY
56455: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56456: LD_ADDR_EXP 68
56460: PUSH
56461: EMPTY
56462: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56463: LD_ADDR_EXP 70
56467: PUSH
56468: EMPTY
56469: ST_TO_ADDR
// mc_scan := [ ] ;
56470: LD_ADDR_EXP 81
56474: PUSH
56475: EMPTY
56476: ST_TO_ADDR
// mc_scan_area := [ ] ;
56477: LD_ADDR_EXP 83
56481: PUSH
56482: EMPTY
56483: ST_TO_ADDR
// mc_tech := [ ] ;
56484: LD_ADDR_EXP 85
56488: PUSH
56489: EMPTY
56490: ST_TO_ADDR
// mc_class := [ ] ;
56491: LD_ADDR_EXP 99
56495: PUSH
56496: EMPTY
56497: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56498: LD_ADDR_EXP 100
56502: PUSH
56503: EMPTY
56504: ST_TO_ADDR
// end ;
56505: LD_VAR 0 1
56509: RET
// export function MC_Kill ( base ) ; begin
56510: LD_INT 0
56512: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56513: LD_ADDR_EXP 58
56517: PUSH
56518: LD_EXP 58
56522: PPUSH
56523: LD_VAR 0 1
56527: PPUSH
56528: EMPTY
56529: PPUSH
56530: CALL_OW 1
56534: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56535: LD_ADDR_EXP 59
56539: PUSH
56540: LD_EXP 59
56544: PPUSH
56545: LD_VAR 0 1
56549: PPUSH
56550: EMPTY
56551: PPUSH
56552: CALL_OW 1
56556: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56557: LD_ADDR_EXP 60
56561: PUSH
56562: LD_EXP 60
56566: PPUSH
56567: LD_VAR 0 1
56571: PPUSH
56572: EMPTY
56573: PPUSH
56574: CALL_OW 1
56578: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56579: LD_ADDR_EXP 61
56583: PUSH
56584: LD_EXP 61
56588: PPUSH
56589: LD_VAR 0 1
56593: PPUSH
56594: EMPTY
56595: PPUSH
56596: CALL_OW 1
56600: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56601: LD_ADDR_EXP 62
56605: PUSH
56606: LD_EXP 62
56610: PPUSH
56611: LD_VAR 0 1
56615: PPUSH
56616: EMPTY
56617: PPUSH
56618: CALL_OW 1
56622: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56623: LD_ADDR_EXP 63
56627: PUSH
56628: LD_EXP 63
56632: PPUSH
56633: LD_VAR 0 1
56637: PPUSH
56638: EMPTY
56639: PPUSH
56640: CALL_OW 1
56644: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56645: LD_ADDR_EXP 64
56649: PUSH
56650: LD_EXP 64
56654: PPUSH
56655: LD_VAR 0 1
56659: PPUSH
56660: EMPTY
56661: PPUSH
56662: CALL_OW 1
56666: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56667: LD_ADDR_EXP 65
56671: PUSH
56672: LD_EXP 65
56676: PPUSH
56677: LD_VAR 0 1
56681: PPUSH
56682: EMPTY
56683: PPUSH
56684: CALL_OW 1
56688: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56689: LD_ADDR_EXP 66
56693: PUSH
56694: LD_EXP 66
56698: PPUSH
56699: LD_VAR 0 1
56703: PPUSH
56704: EMPTY
56705: PPUSH
56706: CALL_OW 1
56710: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56711: LD_ADDR_EXP 67
56715: PUSH
56716: LD_EXP 67
56720: PPUSH
56721: LD_VAR 0 1
56725: PPUSH
56726: EMPTY
56727: PPUSH
56728: CALL_OW 1
56732: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56733: LD_ADDR_EXP 68
56737: PUSH
56738: LD_EXP 68
56742: PPUSH
56743: LD_VAR 0 1
56747: PPUSH
56748: EMPTY
56749: PPUSH
56750: CALL_OW 1
56754: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56755: LD_ADDR_EXP 69
56759: PUSH
56760: LD_EXP 69
56764: PPUSH
56765: LD_VAR 0 1
56769: PPUSH
56770: LD_INT 0
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56778: LD_ADDR_EXP 70
56782: PUSH
56783: LD_EXP 70
56787: PPUSH
56788: LD_VAR 0 1
56792: PPUSH
56793: EMPTY
56794: PPUSH
56795: CALL_OW 1
56799: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56800: LD_ADDR_EXP 71
56804: PUSH
56805: LD_EXP 71
56809: PPUSH
56810: LD_VAR 0 1
56814: PPUSH
56815: EMPTY
56816: PPUSH
56817: CALL_OW 1
56821: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56822: LD_ADDR_EXP 72
56826: PUSH
56827: LD_EXP 72
56831: PPUSH
56832: LD_VAR 0 1
56836: PPUSH
56837: EMPTY
56838: PPUSH
56839: CALL_OW 1
56843: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56844: LD_ADDR_EXP 73
56848: PUSH
56849: LD_EXP 73
56853: PPUSH
56854: LD_VAR 0 1
56858: PPUSH
56859: EMPTY
56860: PPUSH
56861: CALL_OW 1
56865: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56866: LD_ADDR_EXP 74
56870: PUSH
56871: LD_EXP 74
56875: PPUSH
56876: LD_VAR 0 1
56880: PPUSH
56881: EMPTY
56882: PPUSH
56883: CALL_OW 1
56887: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56888: LD_ADDR_EXP 75
56892: PUSH
56893: LD_EXP 75
56897: PPUSH
56898: LD_VAR 0 1
56902: PPUSH
56903: EMPTY
56904: PPUSH
56905: CALL_OW 1
56909: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56910: LD_ADDR_EXP 76
56914: PUSH
56915: LD_EXP 76
56919: PPUSH
56920: LD_VAR 0 1
56924: PPUSH
56925: EMPTY
56926: PPUSH
56927: CALL_OW 1
56931: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56932: LD_ADDR_EXP 77
56936: PUSH
56937: LD_EXP 77
56941: PPUSH
56942: LD_VAR 0 1
56946: PPUSH
56947: EMPTY
56948: PPUSH
56949: CALL_OW 1
56953: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56954: LD_ADDR_EXP 78
56958: PUSH
56959: LD_EXP 78
56963: PPUSH
56964: LD_VAR 0 1
56968: PPUSH
56969: EMPTY
56970: PPUSH
56971: CALL_OW 1
56975: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56976: LD_ADDR_EXP 79
56980: PUSH
56981: LD_EXP 79
56985: PPUSH
56986: LD_VAR 0 1
56990: PPUSH
56991: EMPTY
56992: PPUSH
56993: CALL_OW 1
56997: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56998: LD_ADDR_EXP 80
57002: PUSH
57003: LD_EXP 80
57007: PPUSH
57008: LD_VAR 0 1
57012: PPUSH
57013: EMPTY
57014: PPUSH
57015: CALL_OW 1
57019: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57020: LD_ADDR_EXP 81
57024: PUSH
57025: LD_EXP 81
57029: PPUSH
57030: LD_VAR 0 1
57034: PPUSH
57035: EMPTY
57036: PPUSH
57037: CALL_OW 1
57041: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57042: LD_ADDR_EXP 82
57046: PUSH
57047: LD_EXP 82
57051: PPUSH
57052: LD_VAR 0 1
57056: PPUSH
57057: EMPTY
57058: PPUSH
57059: CALL_OW 1
57063: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57064: LD_ADDR_EXP 83
57068: PUSH
57069: LD_EXP 83
57073: PPUSH
57074: LD_VAR 0 1
57078: PPUSH
57079: EMPTY
57080: PPUSH
57081: CALL_OW 1
57085: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57086: LD_ADDR_EXP 85
57090: PUSH
57091: LD_EXP 85
57095: PPUSH
57096: LD_VAR 0 1
57100: PPUSH
57101: EMPTY
57102: PPUSH
57103: CALL_OW 1
57107: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57108: LD_ADDR_EXP 87
57112: PUSH
57113: LD_EXP 87
57117: PPUSH
57118: LD_VAR 0 1
57122: PPUSH
57123: EMPTY
57124: PPUSH
57125: CALL_OW 1
57129: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57130: LD_ADDR_EXP 88
57134: PUSH
57135: LD_EXP 88
57139: PPUSH
57140: LD_VAR 0 1
57144: PPUSH
57145: EMPTY
57146: PPUSH
57147: CALL_OW 1
57151: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57152: LD_ADDR_EXP 89
57156: PUSH
57157: LD_EXP 89
57161: PPUSH
57162: LD_VAR 0 1
57166: PPUSH
57167: EMPTY
57168: PPUSH
57169: CALL_OW 1
57173: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57174: LD_ADDR_EXP 90
57178: PUSH
57179: LD_EXP 90
57183: PPUSH
57184: LD_VAR 0 1
57188: PPUSH
57189: EMPTY
57190: PPUSH
57191: CALL_OW 1
57195: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57196: LD_ADDR_EXP 91
57200: PUSH
57201: LD_EXP 91
57205: PPUSH
57206: LD_VAR 0 1
57210: PPUSH
57211: EMPTY
57212: PPUSH
57213: CALL_OW 1
57217: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57218: LD_ADDR_EXP 92
57222: PUSH
57223: LD_EXP 92
57227: PPUSH
57228: LD_VAR 0 1
57232: PPUSH
57233: EMPTY
57234: PPUSH
57235: CALL_OW 1
57239: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57240: LD_ADDR_EXP 93
57244: PUSH
57245: LD_EXP 93
57249: PPUSH
57250: LD_VAR 0 1
57254: PPUSH
57255: EMPTY
57256: PPUSH
57257: CALL_OW 1
57261: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57262: LD_ADDR_EXP 94
57266: PUSH
57267: LD_EXP 94
57271: PPUSH
57272: LD_VAR 0 1
57276: PPUSH
57277: EMPTY
57278: PPUSH
57279: CALL_OW 1
57283: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57284: LD_ADDR_EXP 95
57288: PUSH
57289: LD_EXP 95
57293: PPUSH
57294: LD_VAR 0 1
57298: PPUSH
57299: EMPTY
57300: PPUSH
57301: CALL_OW 1
57305: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57306: LD_ADDR_EXP 96
57310: PUSH
57311: LD_EXP 96
57315: PPUSH
57316: LD_VAR 0 1
57320: PPUSH
57321: EMPTY
57322: PPUSH
57323: CALL_OW 1
57327: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57328: LD_ADDR_EXP 97
57332: PUSH
57333: LD_EXP 97
57337: PPUSH
57338: LD_VAR 0 1
57342: PPUSH
57343: EMPTY
57344: PPUSH
57345: CALL_OW 1
57349: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57350: LD_ADDR_EXP 98
57354: PUSH
57355: LD_EXP 98
57359: PPUSH
57360: LD_VAR 0 1
57364: PPUSH
57365: EMPTY
57366: PPUSH
57367: CALL_OW 1
57371: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57372: LD_ADDR_EXP 99
57376: PUSH
57377: LD_EXP 99
57381: PPUSH
57382: LD_VAR 0 1
57386: PPUSH
57387: EMPTY
57388: PPUSH
57389: CALL_OW 1
57393: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57394: LD_ADDR_EXP 100
57398: PUSH
57399: LD_EXP 100
57403: PPUSH
57404: LD_VAR 0 1
57408: PPUSH
57409: LD_INT 0
57411: PPUSH
57412: CALL_OW 1
57416: ST_TO_ADDR
// end ;
57417: LD_VAR 0 2
57421: RET
// export function MC_Start ( ) ; var i ; begin
57422: LD_INT 0
57424: PPUSH
57425: PPUSH
// for i = 1 to mc_bases do
57426: LD_ADDR_VAR 0 2
57430: PUSH
57431: DOUBLE
57432: LD_INT 1
57434: DEC
57435: ST_TO_ADDR
57436: LD_EXP 58
57440: PUSH
57441: FOR_TO
57442: IFFALSE 58519
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57444: LD_ADDR_EXP 58
57448: PUSH
57449: LD_EXP 58
57453: PPUSH
57454: LD_VAR 0 2
57458: PPUSH
57459: LD_EXP 58
57463: PUSH
57464: LD_VAR 0 2
57468: ARRAY
57469: PUSH
57470: LD_INT 0
57472: DIFF
57473: PPUSH
57474: CALL_OW 1
57478: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57479: LD_ADDR_EXP 59
57483: PUSH
57484: LD_EXP 59
57488: PPUSH
57489: LD_VAR 0 2
57493: PPUSH
57494: EMPTY
57495: PPUSH
57496: CALL_OW 1
57500: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57501: LD_ADDR_EXP 60
57505: PUSH
57506: LD_EXP 60
57510: PPUSH
57511: LD_VAR 0 2
57515: PPUSH
57516: EMPTY
57517: PPUSH
57518: CALL_OW 1
57522: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57523: LD_ADDR_EXP 61
57527: PUSH
57528: LD_EXP 61
57532: PPUSH
57533: LD_VAR 0 2
57537: PPUSH
57538: EMPTY
57539: PPUSH
57540: CALL_OW 1
57544: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57545: LD_ADDR_EXP 62
57549: PUSH
57550: LD_EXP 62
57554: PPUSH
57555: LD_VAR 0 2
57559: PPUSH
57560: EMPTY
57561: PUSH
57562: EMPTY
57563: PUSH
57564: EMPTY
57565: LIST
57566: LIST
57567: PPUSH
57568: CALL_OW 1
57572: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57573: LD_ADDR_EXP 63
57577: PUSH
57578: LD_EXP 63
57582: PPUSH
57583: LD_VAR 0 2
57587: PPUSH
57588: EMPTY
57589: PPUSH
57590: CALL_OW 1
57594: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57595: LD_ADDR_EXP 90
57599: PUSH
57600: LD_EXP 90
57604: PPUSH
57605: LD_VAR 0 2
57609: PPUSH
57610: EMPTY
57611: PPUSH
57612: CALL_OW 1
57616: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57617: LD_ADDR_EXP 64
57621: PUSH
57622: LD_EXP 64
57626: PPUSH
57627: LD_VAR 0 2
57631: PPUSH
57632: EMPTY
57633: PPUSH
57634: CALL_OW 1
57638: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57639: LD_ADDR_EXP 65
57643: PUSH
57644: LD_EXP 65
57648: PPUSH
57649: LD_VAR 0 2
57653: PPUSH
57654: EMPTY
57655: PPUSH
57656: CALL_OW 1
57660: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57661: LD_ADDR_EXP 66
57665: PUSH
57666: LD_EXP 66
57670: PPUSH
57671: LD_VAR 0 2
57675: PPUSH
57676: LD_EXP 58
57680: PUSH
57681: LD_VAR 0 2
57685: ARRAY
57686: PPUSH
57687: LD_INT 2
57689: PUSH
57690: LD_INT 30
57692: PUSH
57693: LD_INT 32
57695: PUSH
57696: EMPTY
57697: LIST
57698: LIST
57699: PUSH
57700: LD_INT 30
57702: PUSH
57703: LD_INT 33
57705: PUSH
57706: EMPTY
57707: LIST
57708: LIST
57709: PUSH
57710: EMPTY
57711: LIST
57712: LIST
57713: LIST
57714: PPUSH
57715: CALL_OW 72
57719: PPUSH
57720: CALL_OW 1
57724: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57725: LD_ADDR_EXP 67
57729: PUSH
57730: LD_EXP 67
57734: PPUSH
57735: LD_VAR 0 2
57739: PPUSH
57740: LD_EXP 58
57744: PUSH
57745: LD_VAR 0 2
57749: ARRAY
57750: PPUSH
57751: LD_INT 2
57753: PUSH
57754: LD_INT 30
57756: PUSH
57757: LD_INT 32
57759: PUSH
57760: EMPTY
57761: LIST
57762: LIST
57763: PUSH
57764: LD_INT 30
57766: PUSH
57767: LD_INT 31
57769: PUSH
57770: EMPTY
57771: LIST
57772: LIST
57773: PUSH
57774: EMPTY
57775: LIST
57776: LIST
57777: LIST
57778: PUSH
57779: LD_INT 58
57781: PUSH
57782: EMPTY
57783: LIST
57784: PUSH
57785: EMPTY
57786: LIST
57787: LIST
57788: PPUSH
57789: CALL_OW 72
57793: PPUSH
57794: CALL_OW 1
57798: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57799: LD_ADDR_EXP 68
57803: PUSH
57804: LD_EXP 68
57808: PPUSH
57809: LD_VAR 0 2
57813: PPUSH
57814: EMPTY
57815: PPUSH
57816: CALL_OW 1
57820: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57821: LD_ADDR_EXP 72
57825: PUSH
57826: LD_EXP 72
57830: PPUSH
57831: LD_VAR 0 2
57835: PPUSH
57836: EMPTY
57837: PPUSH
57838: CALL_OW 1
57842: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57843: LD_ADDR_EXP 71
57847: PUSH
57848: LD_EXP 71
57852: PPUSH
57853: LD_VAR 0 2
57857: PPUSH
57858: EMPTY
57859: PPUSH
57860: CALL_OW 1
57864: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57865: LD_ADDR_EXP 73
57869: PUSH
57870: LD_EXP 73
57874: PPUSH
57875: LD_VAR 0 2
57879: PPUSH
57880: EMPTY
57881: PPUSH
57882: CALL_OW 1
57886: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57887: LD_ADDR_EXP 74
57891: PUSH
57892: LD_EXP 74
57896: PPUSH
57897: LD_VAR 0 2
57901: PPUSH
57902: EMPTY
57903: PPUSH
57904: CALL_OW 1
57908: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57909: LD_ADDR_EXP 75
57913: PUSH
57914: LD_EXP 75
57918: PPUSH
57919: LD_VAR 0 2
57923: PPUSH
57924: EMPTY
57925: PPUSH
57926: CALL_OW 1
57930: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57931: LD_ADDR_EXP 76
57935: PUSH
57936: LD_EXP 76
57940: PPUSH
57941: LD_VAR 0 2
57945: PPUSH
57946: EMPTY
57947: PPUSH
57948: CALL_OW 1
57952: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57953: LD_ADDR_EXP 77
57957: PUSH
57958: LD_EXP 77
57962: PPUSH
57963: LD_VAR 0 2
57967: PPUSH
57968: EMPTY
57969: PPUSH
57970: CALL_OW 1
57974: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57975: LD_ADDR_EXP 78
57979: PUSH
57980: LD_EXP 78
57984: PPUSH
57985: LD_VAR 0 2
57989: PPUSH
57990: EMPTY
57991: PPUSH
57992: CALL_OW 1
57996: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57997: LD_ADDR_EXP 79
58001: PUSH
58002: LD_EXP 79
58006: PPUSH
58007: LD_VAR 0 2
58011: PPUSH
58012: EMPTY
58013: PPUSH
58014: CALL_OW 1
58018: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58019: LD_ADDR_EXP 80
58023: PUSH
58024: LD_EXP 80
58028: PPUSH
58029: LD_VAR 0 2
58033: PPUSH
58034: EMPTY
58035: PPUSH
58036: CALL_OW 1
58040: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58041: LD_ADDR_EXP 69
58045: PUSH
58046: LD_EXP 69
58050: PPUSH
58051: LD_VAR 0 2
58055: PPUSH
58056: LD_INT 0
58058: PPUSH
58059: CALL_OW 1
58063: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58064: LD_ADDR_EXP 82
58068: PUSH
58069: LD_EXP 82
58073: PPUSH
58074: LD_VAR 0 2
58078: PPUSH
58079: LD_INT 0
58081: PPUSH
58082: CALL_OW 1
58086: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58087: LD_ADDR_EXP 70
58091: PUSH
58092: LD_EXP 70
58096: PPUSH
58097: LD_VAR 0 2
58101: PPUSH
58102: EMPTY
58103: PPUSH
58104: CALL_OW 1
58108: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58109: LD_ADDR_EXP 81
58113: PUSH
58114: LD_EXP 81
58118: PPUSH
58119: LD_VAR 0 2
58123: PPUSH
58124: LD_INT 0
58126: PPUSH
58127: CALL_OW 1
58131: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58132: LD_ADDR_EXP 83
58136: PUSH
58137: LD_EXP 83
58141: PPUSH
58142: LD_VAR 0 2
58146: PPUSH
58147: EMPTY
58148: PPUSH
58149: CALL_OW 1
58153: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58154: LD_ADDR_EXP 86
58158: PUSH
58159: LD_EXP 86
58163: PPUSH
58164: LD_VAR 0 2
58168: PPUSH
58169: LD_INT 0
58171: PPUSH
58172: CALL_OW 1
58176: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
58177: LD_ADDR_EXP 87
58181: PUSH
58182: LD_EXP 87
58186: PPUSH
58187: LD_VAR 0 2
58191: PPUSH
58192: EMPTY
58193: PPUSH
58194: CALL_OW 1
58198: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
58199: LD_ADDR_EXP 88
58203: PUSH
58204: LD_EXP 88
58208: PPUSH
58209: LD_VAR 0 2
58213: PPUSH
58214: EMPTY
58215: PPUSH
58216: CALL_OW 1
58220: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
58221: LD_ADDR_EXP 89
58225: PUSH
58226: LD_EXP 89
58230: PPUSH
58231: LD_VAR 0 2
58235: PPUSH
58236: EMPTY
58237: PPUSH
58238: CALL_OW 1
58242: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58243: LD_ADDR_EXP 91
58247: PUSH
58248: LD_EXP 91
58252: PPUSH
58253: LD_VAR 0 2
58257: PPUSH
58258: LD_EXP 58
58262: PUSH
58263: LD_VAR 0 2
58267: ARRAY
58268: PPUSH
58269: LD_INT 2
58271: PUSH
58272: LD_INT 30
58274: PUSH
58275: LD_INT 6
58277: PUSH
58278: EMPTY
58279: LIST
58280: LIST
58281: PUSH
58282: LD_INT 30
58284: PUSH
58285: LD_INT 7
58287: PUSH
58288: EMPTY
58289: LIST
58290: LIST
58291: PUSH
58292: LD_INT 30
58294: PUSH
58295: LD_INT 8
58297: PUSH
58298: EMPTY
58299: LIST
58300: LIST
58301: PUSH
58302: EMPTY
58303: LIST
58304: LIST
58305: LIST
58306: LIST
58307: PPUSH
58308: CALL_OW 72
58312: PPUSH
58313: CALL_OW 1
58317: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58318: LD_ADDR_EXP 92
58322: PUSH
58323: LD_EXP 92
58327: PPUSH
58328: LD_VAR 0 2
58332: PPUSH
58333: EMPTY
58334: PPUSH
58335: CALL_OW 1
58339: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58340: LD_ADDR_EXP 93
58344: PUSH
58345: LD_EXP 93
58349: PPUSH
58350: LD_VAR 0 2
58354: PPUSH
58355: EMPTY
58356: PPUSH
58357: CALL_OW 1
58361: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58362: LD_ADDR_EXP 94
58366: PUSH
58367: LD_EXP 94
58371: PPUSH
58372: LD_VAR 0 2
58376: PPUSH
58377: EMPTY
58378: PPUSH
58379: CALL_OW 1
58383: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58384: LD_ADDR_EXP 95
58388: PUSH
58389: LD_EXP 95
58393: PPUSH
58394: LD_VAR 0 2
58398: PPUSH
58399: EMPTY
58400: PPUSH
58401: CALL_OW 1
58405: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58406: LD_ADDR_EXP 96
58410: PUSH
58411: LD_EXP 96
58415: PPUSH
58416: LD_VAR 0 2
58420: PPUSH
58421: EMPTY
58422: PPUSH
58423: CALL_OW 1
58427: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58428: LD_ADDR_EXP 97
58432: PUSH
58433: LD_EXP 97
58437: PPUSH
58438: LD_VAR 0 2
58442: PPUSH
58443: EMPTY
58444: PPUSH
58445: CALL_OW 1
58449: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58450: LD_ADDR_EXP 98
58454: PUSH
58455: LD_EXP 98
58459: PPUSH
58460: LD_VAR 0 2
58464: PPUSH
58465: EMPTY
58466: PPUSH
58467: CALL_OW 1
58471: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58472: LD_ADDR_EXP 99
58476: PUSH
58477: LD_EXP 99
58481: PPUSH
58482: LD_VAR 0 2
58486: PPUSH
58487: EMPTY
58488: PPUSH
58489: CALL_OW 1
58493: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58494: LD_ADDR_EXP 100
58498: PUSH
58499: LD_EXP 100
58503: PPUSH
58504: LD_VAR 0 2
58508: PPUSH
58509: LD_INT 0
58511: PPUSH
58512: CALL_OW 1
58516: ST_TO_ADDR
// end ;
58517: GO 57441
58519: POP
58520: POP
// MC_InitSides ( ) ;
58521: CALL 58807 0 0
// MC_InitResearch ( ) ;
58525: CALL 58546 0 0
// CustomInitMacro ( ) ;
58529: CALL 174 0 0
// skirmish := true ;
58533: LD_ADDR_EXP 56
58537: PUSH
58538: LD_INT 1
58540: ST_TO_ADDR
// end ;
58541: LD_VAR 0 1
58545: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58546: LD_INT 0
58548: PPUSH
58549: PPUSH
58550: PPUSH
58551: PPUSH
58552: PPUSH
58553: PPUSH
// if not mc_bases then
58554: LD_EXP 58
58558: NOT
58559: IFFALSE 58563
// exit ;
58561: GO 58802
// for i = 1 to 8 do
58563: LD_ADDR_VAR 0 2
58567: PUSH
58568: DOUBLE
58569: LD_INT 1
58571: DEC
58572: ST_TO_ADDR
58573: LD_INT 8
58575: PUSH
58576: FOR_TO
58577: IFFALSE 58603
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58579: LD_ADDR_EXP 85
58583: PUSH
58584: LD_EXP 85
58588: PPUSH
58589: LD_VAR 0 2
58593: PPUSH
58594: EMPTY
58595: PPUSH
58596: CALL_OW 1
58600: ST_TO_ADDR
58601: GO 58576
58603: POP
58604: POP
// tmp := [ ] ;
58605: LD_ADDR_VAR 0 5
58609: PUSH
58610: EMPTY
58611: ST_TO_ADDR
// for i = 1 to mc_sides do
58612: LD_ADDR_VAR 0 2
58616: PUSH
58617: DOUBLE
58618: LD_INT 1
58620: DEC
58621: ST_TO_ADDR
58622: LD_EXP 84
58626: PUSH
58627: FOR_TO
58628: IFFALSE 58686
// if not mc_sides [ i ] in tmp then
58630: LD_EXP 84
58634: PUSH
58635: LD_VAR 0 2
58639: ARRAY
58640: PUSH
58641: LD_VAR 0 5
58645: IN
58646: NOT
58647: IFFALSE 58684
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58649: LD_ADDR_VAR 0 5
58653: PUSH
58654: LD_VAR 0 5
58658: PPUSH
58659: LD_VAR 0 5
58663: PUSH
58664: LD_INT 1
58666: PLUS
58667: PPUSH
58668: LD_EXP 84
58672: PUSH
58673: LD_VAR 0 2
58677: ARRAY
58678: PPUSH
58679: CALL_OW 2
58683: ST_TO_ADDR
58684: GO 58627
58686: POP
58687: POP
// if not tmp then
58688: LD_VAR 0 5
58692: NOT
58693: IFFALSE 58697
// exit ;
58695: GO 58802
// for j in tmp do
58697: LD_ADDR_VAR 0 3
58701: PUSH
58702: LD_VAR 0 5
58706: PUSH
58707: FOR_IN
58708: IFFALSE 58800
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58710: LD_ADDR_VAR 0 6
58714: PUSH
58715: LD_INT 22
58717: PUSH
58718: LD_VAR 0 3
58722: PUSH
58723: EMPTY
58724: LIST
58725: LIST
58726: PPUSH
58727: CALL_OW 69
58731: ST_TO_ADDR
// if not un then
58732: LD_VAR 0 6
58736: NOT
58737: IFFALSE 58741
// continue ;
58739: GO 58707
// nation := GetNation ( un [ 1 ] ) ;
58741: LD_ADDR_VAR 0 4
58745: PUSH
58746: LD_VAR 0 6
58750: PUSH
58751: LD_INT 1
58753: ARRAY
58754: PPUSH
58755: CALL_OW 248
58759: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58760: LD_ADDR_EXP 85
58764: PUSH
58765: LD_EXP 85
58769: PPUSH
58770: LD_VAR 0 3
58774: PPUSH
58775: LD_VAR 0 3
58779: PPUSH
58780: LD_VAR 0 4
58784: PPUSH
58785: LD_INT 1
58787: PPUSH
58788: CALL 13805 0 3
58792: PPUSH
58793: CALL_OW 1
58797: ST_TO_ADDR
// end ;
58798: GO 58707
58800: POP
58801: POP
// end ;
58802: LD_VAR 0 1
58806: RET
// export function MC_InitSides ( ) ; var i ; begin
58807: LD_INT 0
58809: PPUSH
58810: PPUSH
// if not mc_bases then
58811: LD_EXP 58
58815: NOT
58816: IFFALSE 58820
// exit ;
58818: GO 58894
// for i = 1 to mc_bases do
58820: LD_ADDR_VAR 0 2
58824: PUSH
58825: DOUBLE
58826: LD_INT 1
58828: DEC
58829: ST_TO_ADDR
58830: LD_EXP 58
58834: PUSH
58835: FOR_TO
58836: IFFALSE 58892
// if mc_bases [ i ] then
58838: LD_EXP 58
58842: PUSH
58843: LD_VAR 0 2
58847: ARRAY
58848: IFFALSE 58890
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58850: LD_ADDR_EXP 84
58854: PUSH
58855: LD_EXP 84
58859: PPUSH
58860: LD_VAR 0 2
58864: PPUSH
58865: LD_EXP 58
58869: PUSH
58870: LD_VAR 0 2
58874: ARRAY
58875: PUSH
58876: LD_INT 1
58878: ARRAY
58879: PPUSH
58880: CALL_OW 255
58884: PPUSH
58885: CALL_OW 1
58889: ST_TO_ADDR
58890: GO 58835
58892: POP
58893: POP
// end ;
58894: LD_VAR 0 1
58898: RET
// every 0 0$01 trigger skirmish do
58899: LD_EXP 56
58903: IFFALSE 59057
58905: GO 58907
58907: DISABLE
// begin enable ;
58908: ENABLE
// MC_CheckBuildings ( ) ;
58909: CALL 63546 0 0
// MC_CheckPeopleLife ( ) ;
58913: CALL 63671 0 0
// RaiseSailEvent ( 100 ) ;
58917: LD_INT 100
58919: PPUSH
58920: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58924: LD_INT 103
58926: PPUSH
58927: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58931: LD_INT 104
58933: PPUSH
58934: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58938: LD_INT 105
58940: PPUSH
58941: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58945: LD_INT 106
58947: PPUSH
58948: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58952: LD_INT 107
58954: PPUSH
58955: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58959: LD_INT 108
58961: PPUSH
58962: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58966: LD_INT 109
58968: PPUSH
58969: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58973: LD_INT 110
58975: PPUSH
58976: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58980: LD_INT 111
58982: PPUSH
58983: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58987: LD_INT 112
58989: PPUSH
58990: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58994: LD_INT 113
58996: PPUSH
58997: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59001: LD_INT 120
59003: PPUSH
59004: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59008: LD_INT 121
59010: PPUSH
59011: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59015: LD_INT 122
59017: PPUSH
59018: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59022: LD_INT 123
59024: PPUSH
59025: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59029: LD_INT 124
59031: PPUSH
59032: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59036: LD_INT 125
59038: PPUSH
59039: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59043: LD_INT 126
59045: PPUSH
59046: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59050: LD_INT 200
59052: PPUSH
59053: CALL_OW 427
// end ;
59057: END
// on SailEvent ( event ) do begin if event < 100 then
59058: LD_VAR 0 1
59062: PUSH
59063: LD_INT 100
59065: LESS
59066: IFFALSE 59077
// CustomEvent ( event ) ;
59068: LD_VAR 0 1
59072: PPUSH
59073: CALL 12519 0 1
// if event = 100 then
59077: LD_VAR 0 1
59081: PUSH
59082: LD_INT 100
59084: EQUAL
59085: IFFALSE 59091
// MC_ClassManager ( ) ;
59087: CALL 59483 0 0
// if event = 101 then
59091: LD_VAR 0 1
59095: PUSH
59096: LD_INT 101
59098: EQUAL
59099: IFFALSE 59105
// MC_RepairBuildings ( ) ;
59101: CALL 64267 0 0
// if event = 102 then
59105: LD_VAR 0 1
59109: PUSH
59110: LD_INT 102
59112: EQUAL
59113: IFFALSE 59119
// MC_Heal ( ) ;
59115: CALL 64673 0 0
// if event = 103 then
59119: LD_VAR 0 1
59123: PUSH
59124: LD_INT 103
59126: EQUAL
59127: IFFALSE 59133
// MC_Build ( ) ;
59129: CALL 65095 0 0
// if event = 104 then
59133: LD_VAR 0 1
59137: PUSH
59138: LD_INT 104
59140: EQUAL
59141: IFFALSE 59147
// MC_TurretWeapon ( ) ;
59143: CALL 66708 0 0
// if event = 105 then
59147: LD_VAR 0 1
59151: PUSH
59152: LD_INT 105
59154: EQUAL
59155: IFFALSE 59161
// MC_BuildUpgrade ( ) ;
59157: CALL 66259 0 0
// if event = 106 then
59161: LD_VAR 0 1
59165: PUSH
59166: LD_INT 106
59168: EQUAL
59169: IFFALSE 59175
// MC_PlantMines ( ) ;
59171: CALL 67138 0 0
// if event = 107 then
59175: LD_VAR 0 1
59179: PUSH
59180: LD_INT 107
59182: EQUAL
59183: IFFALSE 59189
// MC_CollectCrates ( ) ;
59185: CALL 68172 0 0
// if event = 108 then
59189: LD_VAR 0 1
59193: PUSH
59194: LD_INT 108
59196: EQUAL
59197: IFFALSE 59203
// MC_LinkRemoteControl ( ) ;
59199: CALL 69929 0 0
// if event = 109 then
59203: LD_VAR 0 1
59207: PUSH
59208: LD_INT 109
59210: EQUAL
59211: IFFALSE 59217
// MC_ProduceVehicle ( ) ;
59213: CALL 70110 0 0
// if event = 110 then
59217: LD_VAR 0 1
59221: PUSH
59222: LD_INT 110
59224: EQUAL
59225: IFFALSE 59231
// MC_SendAttack ( ) ;
59227: CALL 70591 0 0
// if event = 111 then
59231: LD_VAR 0 1
59235: PUSH
59236: LD_INT 111
59238: EQUAL
59239: IFFALSE 59245
// MC_Defend ( ) ;
59241: CALL 70699 0 0
// if event = 112 then
59245: LD_VAR 0 1
59249: PUSH
59250: LD_INT 112
59252: EQUAL
59253: IFFALSE 59259
// MC_Research ( ) ;
59255: CALL 71326 0 0
// if event = 113 then
59259: LD_VAR 0 1
59263: PUSH
59264: LD_INT 113
59266: EQUAL
59267: IFFALSE 59273
// MC_MinesTrigger ( ) ;
59269: CALL 72440 0 0
// if event = 120 then
59273: LD_VAR 0 1
59277: PUSH
59278: LD_INT 120
59280: EQUAL
59281: IFFALSE 59287
// MC_RepairVehicle ( ) ;
59283: CALL 72539 0 0
// if event = 121 then
59287: LD_VAR 0 1
59291: PUSH
59292: LD_INT 121
59294: EQUAL
59295: IFFALSE 59301
// MC_TameApe ( ) ;
59297: CALL 73282 0 0
// if event = 122 then
59301: LD_VAR 0 1
59305: PUSH
59306: LD_INT 122
59308: EQUAL
59309: IFFALSE 59315
// MC_ChangeApeClass ( ) ;
59311: CALL 74111 0 0
// if event = 123 then
59315: LD_VAR 0 1
59319: PUSH
59320: LD_INT 123
59322: EQUAL
59323: IFFALSE 59329
// MC_Bazooka ( ) ;
59325: CALL 74761 0 0
// if event = 124 then
59329: LD_VAR 0 1
59333: PUSH
59334: LD_INT 124
59336: EQUAL
59337: IFFALSE 59343
// MC_TeleportExit ( ) ;
59339: CALL 74959 0 0
// if event = 125 then
59343: LD_VAR 0 1
59347: PUSH
59348: LD_INT 125
59350: EQUAL
59351: IFFALSE 59357
// MC_Deposits ( ) ;
59353: CALL 75606 0 0
// if event = 126 then
59357: LD_VAR 0 1
59361: PUSH
59362: LD_INT 126
59364: EQUAL
59365: IFFALSE 59371
// MC_RemoteDriver ( ) ;
59367: CALL 76231 0 0
// if event = 200 then
59371: LD_VAR 0 1
59375: PUSH
59376: LD_INT 200
59378: EQUAL
59379: IFFALSE 59385
// MC_Idle ( ) ;
59381: CALL 77964 0 0
// end ;
59385: PPOPN 1
59387: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59388: LD_INT 0
59390: PPUSH
59391: PPUSH
// if not mc_bases [ base ] or not tag then
59392: LD_EXP 58
59396: PUSH
59397: LD_VAR 0 1
59401: ARRAY
59402: NOT
59403: PUSH
59404: LD_VAR 0 2
59408: NOT
59409: OR
59410: IFFALSE 59414
// exit ;
59412: GO 59478
// for i in mc_bases [ base ] union mc_ape [ base ] do
59414: LD_ADDR_VAR 0 4
59418: PUSH
59419: LD_EXP 58
59423: PUSH
59424: LD_VAR 0 1
59428: ARRAY
59429: PUSH
59430: LD_EXP 87
59434: PUSH
59435: LD_VAR 0 1
59439: ARRAY
59440: UNION
59441: PUSH
59442: FOR_IN
59443: IFFALSE 59476
// if GetTag ( i ) = tag then
59445: LD_VAR 0 4
59449: PPUSH
59450: CALL_OW 110
59454: PUSH
59455: LD_VAR 0 2
59459: EQUAL
59460: IFFALSE 59474
// SetTag ( i , 0 ) ;
59462: LD_VAR 0 4
59466: PPUSH
59467: LD_INT 0
59469: PPUSH
59470: CALL_OW 109
59474: GO 59442
59476: POP
59477: POP
// end ;
59478: LD_VAR 0 3
59482: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59483: LD_INT 0
59485: PPUSH
59486: PPUSH
59487: PPUSH
59488: PPUSH
59489: PPUSH
59490: PPUSH
59491: PPUSH
59492: PPUSH
// if not mc_bases then
59493: LD_EXP 58
59497: NOT
59498: IFFALSE 59502
// exit ;
59500: GO 59960
// for i = 1 to mc_bases do
59502: LD_ADDR_VAR 0 2
59506: PUSH
59507: DOUBLE
59508: LD_INT 1
59510: DEC
59511: ST_TO_ADDR
59512: LD_EXP 58
59516: PUSH
59517: FOR_TO
59518: IFFALSE 59958
// begin tmp := MC_ClassCheckReq ( i ) ;
59520: LD_ADDR_VAR 0 4
59524: PUSH
59525: LD_VAR 0 2
59529: PPUSH
59530: CALL 59965 0 1
59534: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59535: LD_ADDR_EXP 99
59539: PUSH
59540: LD_EXP 99
59544: PPUSH
59545: LD_VAR 0 2
59549: PPUSH
59550: LD_VAR 0 4
59554: PPUSH
59555: CALL_OW 1
59559: ST_TO_ADDR
// if not tmp then
59560: LD_VAR 0 4
59564: NOT
59565: IFFALSE 59569
// continue ;
59567: GO 59517
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59569: LD_ADDR_VAR 0 6
59573: PUSH
59574: LD_EXP 58
59578: PUSH
59579: LD_VAR 0 2
59583: ARRAY
59584: PPUSH
59585: LD_INT 2
59587: PUSH
59588: LD_INT 30
59590: PUSH
59591: LD_INT 4
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: PUSH
59598: LD_INT 30
59600: PUSH
59601: LD_INT 5
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: PUSH
59608: EMPTY
59609: LIST
59610: LIST
59611: LIST
59612: PPUSH
59613: CALL_OW 72
59617: PUSH
59618: LD_EXP 58
59622: PUSH
59623: LD_VAR 0 2
59627: ARRAY
59628: PPUSH
59629: LD_INT 2
59631: PUSH
59632: LD_INT 30
59634: PUSH
59635: LD_INT 0
59637: PUSH
59638: EMPTY
59639: LIST
59640: LIST
59641: PUSH
59642: LD_INT 30
59644: PUSH
59645: LD_INT 1
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: LIST
59656: PPUSH
59657: CALL_OW 72
59661: PUSH
59662: LD_EXP 58
59666: PUSH
59667: LD_VAR 0 2
59671: ARRAY
59672: PPUSH
59673: LD_INT 30
59675: PUSH
59676: LD_INT 3
59678: PUSH
59679: EMPTY
59680: LIST
59681: LIST
59682: PPUSH
59683: CALL_OW 72
59687: PUSH
59688: LD_EXP 58
59692: PUSH
59693: LD_VAR 0 2
59697: ARRAY
59698: PPUSH
59699: LD_INT 2
59701: PUSH
59702: LD_INT 30
59704: PUSH
59705: LD_INT 6
59707: PUSH
59708: EMPTY
59709: LIST
59710: LIST
59711: PUSH
59712: LD_INT 30
59714: PUSH
59715: LD_INT 7
59717: PUSH
59718: EMPTY
59719: LIST
59720: LIST
59721: PUSH
59722: LD_INT 30
59724: PUSH
59725: LD_INT 8
59727: PUSH
59728: EMPTY
59729: LIST
59730: LIST
59731: PUSH
59732: EMPTY
59733: LIST
59734: LIST
59735: LIST
59736: LIST
59737: PPUSH
59738: CALL_OW 72
59742: PUSH
59743: EMPTY
59744: LIST
59745: LIST
59746: LIST
59747: LIST
59748: ST_TO_ADDR
// for j = 1 to 4 do
59749: LD_ADDR_VAR 0 3
59753: PUSH
59754: DOUBLE
59755: LD_INT 1
59757: DEC
59758: ST_TO_ADDR
59759: LD_INT 4
59761: PUSH
59762: FOR_TO
59763: IFFALSE 59954
// begin if not tmp [ j ] then
59765: LD_VAR 0 4
59769: PUSH
59770: LD_VAR 0 3
59774: ARRAY
59775: NOT
59776: IFFALSE 59780
// continue ;
59778: GO 59762
// for p in tmp [ j ] do
59780: LD_ADDR_VAR 0 5
59784: PUSH
59785: LD_VAR 0 4
59789: PUSH
59790: LD_VAR 0 3
59794: ARRAY
59795: PUSH
59796: FOR_IN
59797: IFFALSE 59950
// begin if not b [ j ] then
59799: LD_VAR 0 6
59803: PUSH
59804: LD_VAR 0 3
59808: ARRAY
59809: NOT
59810: IFFALSE 59814
// break ;
59812: GO 59950
// e := 0 ;
59814: LD_ADDR_VAR 0 7
59818: PUSH
59819: LD_INT 0
59821: ST_TO_ADDR
// for k in b [ j ] do
59822: LD_ADDR_VAR 0 8
59826: PUSH
59827: LD_VAR 0 6
59831: PUSH
59832: LD_VAR 0 3
59836: ARRAY
59837: PUSH
59838: FOR_IN
59839: IFFALSE 59866
// if IsNotFull ( k ) then
59841: LD_VAR 0 8
59845: PPUSH
59846: CALL 17831 0 1
59850: IFFALSE 59864
// begin e := k ;
59852: LD_ADDR_VAR 0 7
59856: PUSH
59857: LD_VAR 0 8
59861: ST_TO_ADDR
// break ;
59862: GO 59866
// end ;
59864: GO 59838
59866: POP
59867: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59868: LD_VAR 0 7
59872: PUSH
59873: LD_VAR 0 5
59877: PPUSH
59878: LD_VAR 0 7
59882: PPUSH
59883: CALL 54819 0 2
59887: NOT
59888: AND
59889: IFFALSE 59948
// begin if IsInUnit ( p ) then
59891: LD_VAR 0 5
59895: PPUSH
59896: CALL_OW 310
59900: IFFALSE 59911
// ComExitBuilding ( p ) ;
59902: LD_VAR 0 5
59906: PPUSH
59907: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59911: LD_VAR 0 5
59915: PPUSH
59916: LD_VAR 0 7
59920: PPUSH
59921: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59925: LD_VAR 0 5
59929: PPUSH
59930: LD_VAR 0 3
59934: PPUSH
59935: CALL_OW 183
// AddComExitBuilding ( p ) ;
59939: LD_VAR 0 5
59943: PPUSH
59944: CALL_OW 182
// end ; end ;
59948: GO 59796
59950: POP
59951: POP
// end ;
59952: GO 59762
59954: POP
59955: POP
// end ;
59956: GO 59517
59958: POP
59959: POP
// end ;
59960: LD_VAR 0 1
59964: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59965: LD_INT 0
59967: PPUSH
59968: PPUSH
59969: PPUSH
59970: PPUSH
59971: PPUSH
59972: PPUSH
59973: PPUSH
59974: PPUSH
59975: PPUSH
59976: PPUSH
59977: PPUSH
59978: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59979: LD_VAR 0 1
59983: NOT
59984: PUSH
59985: LD_EXP 58
59989: PUSH
59990: LD_VAR 0 1
59994: ARRAY
59995: NOT
59996: OR
59997: PUSH
59998: LD_EXP 58
60002: PUSH
60003: LD_VAR 0 1
60007: ARRAY
60008: PPUSH
60009: LD_INT 2
60011: PUSH
60012: LD_INT 30
60014: PUSH
60015: LD_INT 0
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: PUSH
60022: LD_INT 30
60024: PUSH
60025: LD_INT 1
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: LIST
60036: PPUSH
60037: CALL_OW 72
60041: NOT
60042: OR
60043: IFFALSE 60047
// exit ;
60045: GO 63541
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60047: LD_ADDR_VAR 0 4
60051: PUSH
60052: LD_EXP 58
60056: PUSH
60057: LD_VAR 0 1
60061: ARRAY
60062: PPUSH
60063: LD_INT 2
60065: PUSH
60066: LD_INT 25
60068: PUSH
60069: LD_INT 1
60071: PUSH
60072: EMPTY
60073: LIST
60074: LIST
60075: PUSH
60076: LD_INT 25
60078: PUSH
60079: LD_INT 2
60081: PUSH
60082: EMPTY
60083: LIST
60084: LIST
60085: PUSH
60086: LD_INT 25
60088: PUSH
60089: LD_INT 3
60091: PUSH
60092: EMPTY
60093: LIST
60094: LIST
60095: PUSH
60096: LD_INT 25
60098: PUSH
60099: LD_INT 4
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: PUSH
60106: LD_INT 25
60108: PUSH
60109: LD_INT 5
60111: PUSH
60112: EMPTY
60113: LIST
60114: LIST
60115: PUSH
60116: LD_INT 25
60118: PUSH
60119: LD_INT 8
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PUSH
60126: LD_INT 25
60128: PUSH
60129: LD_INT 9
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PUSH
60136: EMPTY
60137: LIST
60138: LIST
60139: LIST
60140: LIST
60141: LIST
60142: LIST
60143: LIST
60144: LIST
60145: PPUSH
60146: CALL_OW 72
60150: ST_TO_ADDR
// for i in tmp do
60151: LD_ADDR_VAR 0 3
60155: PUSH
60156: LD_VAR 0 4
60160: PUSH
60161: FOR_IN
60162: IFFALSE 60193
// if GetTag ( i ) then
60164: LD_VAR 0 3
60168: PPUSH
60169: CALL_OW 110
60173: IFFALSE 60191
// tmp := tmp diff i ;
60175: LD_ADDR_VAR 0 4
60179: PUSH
60180: LD_VAR 0 4
60184: PUSH
60185: LD_VAR 0 3
60189: DIFF
60190: ST_TO_ADDR
60191: GO 60161
60193: POP
60194: POP
// if not tmp then
60195: LD_VAR 0 4
60199: NOT
60200: IFFALSE 60204
// exit ;
60202: GO 63541
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60204: LD_ADDR_VAR 0 5
60208: PUSH
60209: LD_EXP 58
60213: PUSH
60214: LD_VAR 0 1
60218: ARRAY
60219: PPUSH
60220: LD_INT 2
60222: PUSH
60223: LD_INT 25
60225: PUSH
60226: LD_INT 1
60228: PUSH
60229: EMPTY
60230: LIST
60231: LIST
60232: PUSH
60233: LD_INT 25
60235: PUSH
60236: LD_INT 5
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: PUSH
60243: LD_INT 25
60245: PUSH
60246: LD_INT 8
60248: PUSH
60249: EMPTY
60250: LIST
60251: LIST
60252: PUSH
60253: LD_INT 25
60255: PUSH
60256: LD_INT 9
60258: PUSH
60259: EMPTY
60260: LIST
60261: LIST
60262: PUSH
60263: EMPTY
60264: LIST
60265: LIST
60266: LIST
60267: LIST
60268: LIST
60269: PPUSH
60270: CALL_OW 72
60274: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60275: LD_ADDR_VAR 0 6
60279: PUSH
60280: LD_EXP 58
60284: PUSH
60285: LD_VAR 0 1
60289: ARRAY
60290: PPUSH
60291: LD_INT 25
60293: PUSH
60294: LD_INT 2
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PPUSH
60301: CALL_OW 72
60305: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60306: LD_ADDR_VAR 0 7
60310: PUSH
60311: LD_EXP 58
60315: PUSH
60316: LD_VAR 0 1
60320: ARRAY
60321: PPUSH
60322: LD_INT 25
60324: PUSH
60325: LD_INT 3
60327: PUSH
60328: EMPTY
60329: LIST
60330: LIST
60331: PPUSH
60332: CALL_OW 72
60336: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60337: LD_ADDR_VAR 0 8
60341: PUSH
60342: LD_EXP 58
60346: PUSH
60347: LD_VAR 0 1
60351: ARRAY
60352: PPUSH
60353: LD_INT 25
60355: PUSH
60356: LD_INT 4
60358: PUSH
60359: EMPTY
60360: LIST
60361: LIST
60362: PUSH
60363: LD_INT 24
60365: PUSH
60366: LD_INT 251
60368: PUSH
60369: EMPTY
60370: LIST
60371: LIST
60372: PUSH
60373: EMPTY
60374: LIST
60375: LIST
60376: PPUSH
60377: CALL_OW 72
60381: ST_TO_ADDR
// if mc_scan [ base ] then
60382: LD_EXP 81
60386: PUSH
60387: LD_VAR 0 1
60391: ARRAY
60392: IFFALSE 60853
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60394: LD_ADDR_EXP 100
60398: PUSH
60399: LD_EXP 100
60403: PPUSH
60404: LD_VAR 0 1
60408: PPUSH
60409: LD_INT 4
60411: PPUSH
60412: CALL_OW 1
60416: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60417: LD_ADDR_VAR 0 12
60421: PUSH
60422: LD_EXP 58
60426: PUSH
60427: LD_VAR 0 1
60431: ARRAY
60432: PPUSH
60433: LD_INT 2
60435: PUSH
60436: LD_INT 30
60438: PUSH
60439: LD_INT 4
60441: PUSH
60442: EMPTY
60443: LIST
60444: LIST
60445: PUSH
60446: LD_INT 30
60448: PUSH
60449: LD_INT 5
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: LIST
60460: PPUSH
60461: CALL_OW 72
60465: ST_TO_ADDR
// if not b then
60466: LD_VAR 0 12
60470: NOT
60471: IFFALSE 60475
// exit ;
60473: GO 63541
// p := [ ] ;
60475: LD_ADDR_VAR 0 11
60479: PUSH
60480: EMPTY
60481: ST_TO_ADDR
// if sci >= 2 then
60482: LD_VAR 0 8
60486: PUSH
60487: LD_INT 2
60489: GREATEREQUAL
60490: IFFALSE 60521
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60492: LD_ADDR_VAR 0 8
60496: PUSH
60497: LD_VAR 0 8
60501: PUSH
60502: LD_INT 1
60504: ARRAY
60505: PUSH
60506: LD_VAR 0 8
60510: PUSH
60511: LD_INT 2
60513: ARRAY
60514: PUSH
60515: EMPTY
60516: LIST
60517: LIST
60518: ST_TO_ADDR
60519: GO 60582
// if sci = 1 then
60521: LD_VAR 0 8
60525: PUSH
60526: LD_INT 1
60528: EQUAL
60529: IFFALSE 60550
// sci := [ sci [ 1 ] ] else
60531: LD_ADDR_VAR 0 8
60535: PUSH
60536: LD_VAR 0 8
60540: PUSH
60541: LD_INT 1
60543: ARRAY
60544: PUSH
60545: EMPTY
60546: LIST
60547: ST_TO_ADDR
60548: GO 60582
// if sci = 0 then
60550: LD_VAR 0 8
60554: PUSH
60555: LD_INT 0
60557: EQUAL
60558: IFFALSE 60582
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60560: LD_ADDR_VAR 0 11
60564: PUSH
60565: LD_VAR 0 4
60569: PPUSH
60570: LD_INT 4
60572: PPUSH
60573: CALL 54682 0 2
60577: PUSH
60578: LD_INT 1
60580: ARRAY
60581: ST_TO_ADDR
// if eng > 4 then
60582: LD_VAR 0 6
60586: PUSH
60587: LD_INT 4
60589: GREATER
60590: IFFALSE 60636
// for i = eng downto 4 do
60592: LD_ADDR_VAR 0 3
60596: PUSH
60597: DOUBLE
60598: LD_VAR 0 6
60602: INC
60603: ST_TO_ADDR
60604: LD_INT 4
60606: PUSH
60607: FOR_DOWNTO
60608: IFFALSE 60634
// eng := eng diff eng [ i ] ;
60610: LD_ADDR_VAR 0 6
60614: PUSH
60615: LD_VAR 0 6
60619: PUSH
60620: LD_VAR 0 6
60624: PUSH
60625: LD_VAR 0 3
60629: ARRAY
60630: DIFF
60631: ST_TO_ADDR
60632: GO 60607
60634: POP
60635: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60636: LD_ADDR_VAR 0 4
60640: PUSH
60641: LD_VAR 0 4
60645: PUSH
60646: LD_VAR 0 5
60650: PUSH
60651: LD_VAR 0 6
60655: UNION
60656: PUSH
60657: LD_VAR 0 7
60661: UNION
60662: PUSH
60663: LD_VAR 0 8
60667: UNION
60668: DIFF
60669: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60670: LD_ADDR_VAR 0 13
60674: PUSH
60675: LD_EXP 58
60679: PUSH
60680: LD_VAR 0 1
60684: ARRAY
60685: PPUSH
60686: LD_INT 2
60688: PUSH
60689: LD_INT 30
60691: PUSH
60692: LD_INT 32
60694: PUSH
60695: EMPTY
60696: LIST
60697: LIST
60698: PUSH
60699: LD_INT 30
60701: PUSH
60702: LD_INT 31
60704: PUSH
60705: EMPTY
60706: LIST
60707: LIST
60708: PUSH
60709: EMPTY
60710: LIST
60711: LIST
60712: LIST
60713: PPUSH
60714: CALL_OW 72
60718: PUSH
60719: LD_EXP 58
60723: PUSH
60724: LD_VAR 0 1
60728: ARRAY
60729: PPUSH
60730: LD_INT 2
60732: PUSH
60733: LD_INT 30
60735: PUSH
60736: LD_INT 4
60738: PUSH
60739: EMPTY
60740: LIST
60741: LIST
60742: PUSH
60743: LD_INT 30
60745: PUSH
60746: LD_INT 5
60748: PUSH
60749: EMPTY
60750: LIST
60751: LIST
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: LIST
60757: PPUSH
60758: CALL_OW 72
60762: PUSH
60763: LD_INT 6
60765: MUL
60766: PLUS
60767: ST_TO_ADDR
// if bcount < tmp then
60768: LD_VAR 0 13
60772: PUSH
60773: LD_VAR 0 4
60777: LESS
60778: IFFALSE 60824
// for i = tmp downto bcount do
60780: LD_ADDR_VAR 0 3
60784: PUSH
60785: DOUBLE
60786: LD_VAR 0 4
60790: INC
60791: ST_TO_ADDR
60792: LD_VAR 0 13
60796: PUSH
60797: FOR_DOWNTO
60798: IFFALSE 60822
// tmp := Delete ( tmp , tmp ) ;
60800: LD_ADDR_VAR 0 4
60804: PUSH
60805: LD_VAR 0 4
60809: PPUSH
60810: LD_VAR 0 4
60814: PPUSH
60815: CALL_OW 3
60819: ST_TO_ADDR
60820: GO 60797
60822: POP
60823: POP
// result := [ tmp , 0 , 0 , p ] ;
60824: LD_ADDR_VAR 0 2
60828: PUSH
60829: LD_VAR 0 4
60833: PUSH
60834: LD_INT 0
60836: PUSH
60837: LD_INT 0
60839: PUSH
60840: LD_VAR 0 11
60844: PUSH
60845: EMPTY
60846: LIST
60847: LIST
60848: LIST
60849: LIST
60850: ST_TO_ADDR
// exit ;
60851: GO 63541
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60853: LD_EXP 58
60857: PUSH
60858: LD_VAR 0 1
60862: ARRAY
60863: PPUSH
60864: LD_INT 2
60866: PUSH
60867: LD_INT 30
60869: PUSH
60870: LD_INT 6
60872: PUSH
60873: EMPTY
60874: LIST
60875: LIST
60876: PUSH
60877: LD_INT 30
60879: PUSH
60880: LD_INT 7
60882: PUSH
60883: EMPTY
60884: LIST
60885: LIST
60886: PUSH
60887: LD_INT 30
60889: PUSH
60890: LD_INT 8
60892: PUSH
60893: EMPTY
60894: LIST
60895: LIST
60896: PUSH
60897: EMPTY
60898: LIST
60899: LIST
60900: LIST
60901: LIST
60902: PPUSH
60903: CALL_OW 72
60907: NOT
60908: PUSH
60909: LD_EXP 58
60913: PUSH
60914: LD_VAR 0 1
60918: ARRAY
60919: PPUSH
60920: LD_INT 30
60922: PUSH
60923: LD_INT 3
60925: PUSH
60926: EMPTY
60927: LIST
60928: LIST
60929: PPUSH
60930: CALL_OW 72
60934: NOT
60935: AND
60936: IFFALSE 61008
// begin if eng = tmp then
60938: LD_VAR 0 6
60942: PUSH
60943: LD_VAR 0 4
60947: EQUAL
60948: IFFALSE 60952
// exit ;
60950: GO 63541
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60952: LD_ADDR_EXP 100
60956: PUSH
60957: LD_EXP 100
60961: PPUSH
60962: LD_VAR 0 1
60966: PPUSH
60967: LD_INT 1
60969: PPUSH
60970: CALL_OW 1
60974: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60975: LD_ADDR_VAR 0 2
60979: PUSH
60980: LD_INT 0
60982: PUSH
60983: LD_VAR 0 4
60987: PUSH
60988: LD_VAR 0 6
60992: DIFF
60993: PUSH
60994: LD_INT 0
60996: PUSH
60997: LD_INT 0
60999: PUSH
61000: EMPTY
61001: LIST
61002: LIST
61003: LIST
61004: LIST
61005: ST_TO_ADDR
// exit ;
61006: GO 63541
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61008: LD_EXP 85
61012: PUSH
61013: LD_EXP 84
61017: PUSH
61018: LD_VAR 0 1
61022: ARRAY
61023: ARRAY
61024: PUSH
61025: LD_EXP 58
61029: PUSH
61030: LD_VAR 0 1
61034: ARRAY
61035: PPUSH
61036: LD_INT 2
61038: PUSH
61039: LD_INT 30
61041: PUSH
61042: LD_INT 6
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: PUSH
61049: LD_INT 30
61051: PUSH
61052: LD_INT 7
61054: PUSH
61055: EMPTY
61056: LIST
61057: LIST
61058: PUSH
61059: LD_INT 30
61061: PUSH
61062: LD_INT 8
61064: PUSH
61065: EMPTY
61066: LIST
61067: LIST
61068: PUSH
61069: EMPTY
61070: LIST
61071: LIST
61072: LIST
61073: LIST
61074: PPUSH
61075: CALL_OW 72
61079: AND
61080: PUSH
61081: LD_EXP 58
61085: PUSH
61086: LD_VAR 0 1
61090: ARRAY
61091: PPUSH
61092: LD_INT 30
61094: PUSH
61095: LD_INT 3
61097: PUSH
61098: EMPTY
61099: LIST
61100: LIST
61101: PPUSH
61102: CALL_OW 72
61106: NOT
61107: AND
61108: IFFALSE 61322
// begin if sci >= 6 then
61110: LD_VAR 0 8
61114: PUSH
61115: LD_INT 6
61117: GREATEREQUAL
61118: IFFALSE 61122
// exit ;
61120: GO 63541
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61122: LD_ADDR_EXP 100
61126: PUSH
61127: LD_EXP 100
61131: PPUSH
61132: LD_VAR 0 1
61136: PPUSH
61137: LD_INT 2
61139: PPUSH
61140: CALL_OW 1
61144: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
61145: LD_ADDR_VAR 0 9
61149: PUSH
61150: LD_VAR 0 4
61154: PUSH
61155: LD_VAR 0 8
61159: DIFF
61160: PPUSH
61161: LD_INT 4
61163: PPUSH
61164: CALL 54682 0 2
61168: ST_TO_ADDR
// p := [ ] ;
61169: LD_ADDR_VAR 0 11
61173: PUSH
61174: EMPTY
61175: ST_TO_ADDR
// if sci < 6 and sort > 6 then
61176: LD_VAR 0 8
61180: PUSH
61181: LD_INT 6
61183: LESS
61184: PUSH
61185: LD_VAR 0 9
61189: PUSH
61190: LD_INT 6
61192: GREATER
61193: AND
61194: IFFALSE 61275
// begin for i = 1 to 6 - sci do
61196: LD_ADDR_VAR 0 3
61200: PUSH
61201: DOUBLE
61202: LD_INT 1
61204: DEC
61205: ST_TO_ADDR
61206: LD_INT 6
61208: PUSH
61209: LD_VAR 0 8
61213: MINUS
61214: PUSH
61215: FOR_TO
61216: IFFALSE 61271
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
61218: LD_ADDR_VAR 0 11
61222: PUSH
61223: LD_VAR 0 11
61227: PPUSH
61228: LD_VAR 0 11
61232: PUSH
61233: LD_INT 1
61235: PLUS
61236: PPUSH
61237: LD_VAR 0 9
61241: PUSH
61242: LD_INT 1
61244: ARRAY
61245: PPUSH
61246: CALL_OW 2
61250: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61251: LD_ADDR_VAR 0 9
61255: PUSH
61256: LD_VAR 0 9
61260: PPUSH
61261: LD_INT 1
61263: PPUSH
61264: CALL_OW 3
61268: ST_TO_ADDR
// end ;
61269: GO 61215
61271: POP
61272: POP
// end else
61273: GO 61295
// if sort then
61275: LD_VAR 0 9
61279: IFFALSE 61295
// p := sort [ 1 ] ;
61281: LD_ADDR_VAR 0 11
61285: PUSH
61286: LD_VAR 0 9
61290: PUSH
61291: LD_INT 1
61293: ARRAY
61294: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61295: LD_ADDR_VAR 0 2
61299: PUSH
61300: LD_INT 0
61302: PUSH
61303: LD_INT 0
61305: PUSH
61306: LD_INT 0
61308: PUSH
61309: LD_VAR 0 11
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: LIST
61318: LIST
61319: ST_TO_ADDR
// exit ;
61320: GO 63541
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61322: LD_EXP 85
61326: PUSH
61327: LD_EXP 84
61331: PUSH
61332: LD_VAR 0 1
61336: ARRAY
61337: ARRAY
61338: PUSH
61339: LD_EXP 58
61343: PUSH
61344: LD_VAR 0 1
61348: ARRAY
61349: PPUSH
61350: LD_INT 2
61352: PUSH
61353: LD_INT 30
61355: PUSH
61356: LD_INT 6
61358: PUSH
61359: EMPTY
61360: LIST
61361: LIST
61362: PUSH
61363: LD_INT 30
61365: PUSH
61366: LD_INT 7
61368: PUSH
61369: EMPTY
61370: LIST
61371: LIST
61372: PUSH
61373: LD_INT 30
61375: PUSH
61376: LD_INT 8
61378: PUSH
61379: EMPTY
61380: LIST
61381: LIST
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: LIST
61387: LIST
61388: PPUSH
61389: CALL_OW 72
61393: AND
61394: PUSH
61395: LD_EXP 58
61399: PUSH
61400: LD_VAR 0 1
61404: ARRAY
61405: PPUSH
61406: LD_INT 30
61408: PUSH
61409: LD_INT 3
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: PPUSH
61416: CALL_OW 72
61420: AND
61421: IFFALSE 62155
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61423: LD_ADDR_EXP 100
61427: PUSH
61428: LD_EXP 100
61432: PPUSH
61433: LD_VAR 0 1
61437: PPUSH
61438: LD_INT 3
61440: PPUSH
61441: CALL_OW 1
61445: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61446: LD_ADDR_VAR 0 2
61450: PUSH
61451: LD_INT 0
61453: PUSH
61454: LD_INT 0
61456: PUSH
61457: LD_INT 0
61459: PUSH
61460: LD_INT 0
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: LIST
61467: LIST
61468: ST_TO_ADDR
// if not eng then
61469: LD_VAR 0 6
61473: NOT
61474: IFFALSE 61537
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61476: LD_ADDR_VAR 0 11
61480: PUSH
61481: LD_VAR 0 4
61485: PPUSH
61486: LD_INT 2
61488: PPUSH
61489: CALL 54682 0 2
61493: PUSH
61494: LD_INT 1
61496: ARRAY
61497: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61498: LD_ADDR_VAR 0 2
61502: PUSH
61503: LD_VAR 0 2
61507: PPUSH
61508: LD_INT 2
61510: PPUSH
61511: LD_VAR 0 11
61515: PPUSH
61516: CALL_OW 1
61520: ST_TO_ADDR
// tmp := tmp diff p ;
61521: LD_ADDR_VAR 0 4
61525: PUSH
61526: LD_VAR 0 4
61530: PUSH
61531: LD_VAR 0 11
61535: DIFF
61536: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61537: LD_VAR 0 4
61541: PUSH
61542: LD_VAR 0 8
61546: PUSH
61547: LD_INT 6
61549: LESS
61550: AND
61551: IFFALSE 61739
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61553: LD_ADDR_VAR 0 9
61557: PUSH
61558: LD_VAR 0 4
61562: PUSH
61563: LD_VAR 0 8
61567: PUSH
61568: LD_VAR 0 7
61572: UNION
61573: DIFF
61574: PPUSH
61575: LD_INT 4
61577: PPUSH
61578: CALL 54682 0 2
61582: ST_TO_ADDR
// p := [ ] ;
61583: LD_ADDR_VAR 0 11
61587: PUSH
61588: EMPTY
61589: ST_TO_ADDR
// if sort then
61590: LD_VAR 0 9
61594: IFFALSE 61710
// for i = 1 to 6 - sci do
61596: LD_ADDR_VAR 0 3
61600: PUSH
61601: DOUBLE
61602: LD_INT 1
61604: DEC
61605: ST_TO_ADDR
61606: LD_INT 6
61608: PUSH
61609: LD_VAR 0 8
61613: MINUS
61614: PUSH
61615: FOR_TO
61616: IFFALSE 61708
// begin if i = sort then
61618: LD_VAR 0 3
61622: PUSH
61623: LD_VAR 0 9
61627: EQUAL
61628: IFFALSE 61632
// break ;
61630: GO 61708
// if GetClass ( i ) = 4 then
61632: LD_VAR 0 3
61636: PPUSH
61637: CALL_OW 257
61641: PUSH
61642: LD_INT 4
61644: EQUAL
61645: IFFALSE 61649
// continue ;
61647: GO 61615
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61649: LD_ADDR_VAR 0 11
61653: PUSH
61654: LD_VAR 0 11
61658: PPUSH
61659: LD_VAR 0 11
61663: PUSH
61664: LD_INT 1
61666: PLUS
61667: PPUSH
61668: LD_VAR 0 9
61672: PUSH
61673: LD_VAR 0 3
61677: ARRAY
61678: PPUSH
61679: CALL_OW 2
61683: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61684: LD_ADDR_VAR 0 4
61688: PUSH
61689: LD_VAR 0 4
61693: PUSH
61694: LD_VAR 0 9
61698: PUSH
61699: LD_VAR 0 3
61703: ARRAY
61704: DIFF
61705: ST_TO_ADDR
// end ;
61706: GO 61615
61708: POP
61709: POP
// if p then
61710: LD_VAR 0 11
61714: IFFALSE 61739
// result := Replace ( result , 4 , p ) ;
61716: LD_ADDR_VAR 0 2
61720: PUSH
61721: LD_VAR 0 2
61725: PPUSH
61726: LD_INT 4
61728: PPUSH
61729: LD_VAR 0 11
61733: PPUSH
61734: CALL_OW 1
61738: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61739: LD_VAR 0 4
61743: PUSH
61744: LD_VAR 0 7
61748: PUSH
61749: LD_INT 6
61751: LESS
61752: AND
61753: IFFALSE 61941
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61755: LD_ADDR_VAR 0 9
61759: PUSH
61760: LD_VAR 0 4
61764: PUSH
61765: LD_VAR 0 8
61769: PUSH
61770: LD_VAR 0 7
61774: UNION
61775: DIFF
61776: PPUSH
61777: LD_INT 3
61779: PPUSH
61780: CALL 54682 0 2
61784: ST_TO_ADDR
// p := [ ] ;
61785: LD_ADDR_VAR 0 11
61789: PUSH
61790: EMPTY
61791: ST_TO_ADDR
// if sort then
61792: LD_VAR 0 9
61796: IFFALSE 61912
// for i = 1 to 6 - mech do
61798: LD_ADDR_VAR 0 3
61802: PUSH
61803: DOUBLE
61804: LD_INT 1
61806: DEC
61807: ST_TO_ADDR
61808: LD_INT 6
61810: PUSH
61811: LD_VAR 0 7
61815: MINUS
61816: PUSH
61817: FOR_TO
61818: IFFALSE 61910
// begin if i = sort then
61820: LD_VAR 0 3
61824: PUSH
61825: LD_VAR 0 9
61829: EQUAL
61830: IFFALSE 61834
// break ;
61832: GO 61910
// if GetClass ( i ) = 3 then
61834: LD_VAR 0 3
61838: PPUSH
61839: CALL_OW 257
61843: PUSH
61844: LD_INT 3
61846: EQUAL
61847: IFFALSE 61851
// continue ;
61849: GO 61817
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61851: LD_ADDR_VAR 0 11
61855: PUSH
61856: LD_VAR 0 11
61860: PPUSH
61861: LD_VAR 0 11
61865: PUSH
61866: LD_INT 1
61868: PLUS
61869: PPUSH
61870: LD_VAR 0 9
61874: PUSH
61875: LD_VAR 0 3
61879: ARRAY
61880: PPUSH
61881: CALL_OW 2
61885: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61886: LD_ADDR_VAR 0 4
61890: PUSH
61891: LD_VAR 0 4
61895: PUSH
61896: LD_VAR 0 9
61900: PUSH
61901: LD_VAR 0 3
61905: ARRAY
61906: DIFF
61907: ST_TO_ADDR
// end ;
61908: GO 61817
61910: POP
61911: POP
// if p then
61912: LD_VAR 0 11
61916: IFFALSE 61941
// result := Replace ( result , 3 , p ) ;
61918: LD_ADDR_VAR 0 2
61922: PUSH
61923: LD_VAR 0 2
61927: PPUSH
61928: LD_INT 3
61930: PPUSH
61931: LD_VAR 0 11
61935: PPUSH
61936: CALL_OW 1
61940: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61941: LD_VAR 0 4
61945: PUSH
61946: LD_INT 6
61948: GREATER
61949: PUSH
61950: LD_VAR 0 6
61954: PUSH
61955: LD_INT 6
61957: LESS
61958: AND
61959: IFFALSE 62153
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61961: LD_ADDR_VAR 0 9
61965: PUSH
61966: LD_VAR 0 4
61970: PUSH
61971: LD_VAR 0 8
61975: PUSH
61976: LD_VAR 0 7
61980: UNION
61981: PUSH
61982: LD_VAR 0 6
61986: UNION
61987: DIFF
61988: PPUSH
61989: LD_INT 2
61991: PPUSH
61992: CALL 54682 0 2
61996: ST_TO_ADDR
// p := [ ] ;
61997: LD_ADDR_VAR 0 11
62001: PUSH
62002: EMPTY
62003: ST_TO_ADDR
// if sort then
62004: LD_VAR 0 9
62008: IFFALSE 62124
// for i = 1 to 6 - eng do
62010: LD_ADDR_VAR 0 3
62014: PUSH
62015: DOUBLE
62016: LD_INT 1
62018: DEC
62019: ST_TO_ADDR
62020: LD_INT 6
62022: PUSH
62023: LD_VAR 0 6
62027: MINUS
62028: PUSH
62029: FOR_TO
62030: IFFALSE 62122
// begin if i = sort then
62032: LD_VAR 0 3
62036: PUSH
62037: LD_VAR 0 9
62041: EQUAL
62042: IFFALSE 62046
// break ;
62044: GO 62122
// if GetClass ( i ) = 2 then
62046: LD_VAR 0 3
62050: PPUSH
62051: CALL_OW 257
62055: PUSH
62056: LD_INT 2
62058: EQUAL
62059: IFFALSE 62063
// continue ;
62061: GO 62029
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62063: LD_ADDR_VAR 0 11
62067: PUSH
62068: LD_VAR 0 11
62072: PPUSH
62073: LD_VAR 0 11
62077: PUSH
62078: LD_INT 1
62080: PLUS
62081: PPUSH
62082: LD_VAR 0 9
62086: PUSH
62087: LD_VAR 0 3
62091: ARRAY
62092: PPUSH
62093: CALL_OW 2
62097: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62098: LD_ADDR_VAR 0 4
62102: PUSH
62103: LD_VAR 0 4
62107: PUSH
62108: LD_VAR 0 9
62112: PUSH
62113: LD_VAR 0 3
62117: ARRAY
62118: DIFF
62119: ST_TO_ADDR
// end ;
62120: GO 62029
62122: POP
62123: POP
// if p then
62124: LD_VAR 0 11
62128: IFFALSE 62153
// result := Replace ( result , 2 , p ) ;
62130: LD_ADDR_VAR 0 2
62134: PUSH
62135: LD_VAR 0 2
62139: PPUSH
62140: LD_INT 2
62142: PPUSH
62143: LD_VAR 0 11
62147: PPUSH
62148: CALL_OW 1
62152: ST_TO_ADDR
// end ; exit ;
62153: GO 63541
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
62155: LD_EXP 85
62159: PUSH
62160: LD_EXP 84
62164: PUSH
62165: LD_VAR 0 1
62169: ARRAY
62170: ARRAY
62171: NOT
62172: PUSH
62173: LD_EXP 58
62177: PUSH
62178: LD_VAR 0 1
62182: ARRAY
62183: PPUSH
62184: LD_INT 30
62186: PUSH
62187: LD_INT 3
62189: PUSH
62190: EMPTY
62191: LIST
62192: LIST
62193: PPUSH
62194: CALL_OW 72
62198: AND
62199: PUSH
62200: LD_EXP 63
62204: PUSH
62205: LD_VAR 0 1
62209: ARRAY
62210: AND
62211: IFFALSE 62819
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
62213: LD_ADDR_EXP 100
62217: PUSH
62218: LD_EXP 100
62222: PPUSH
62223: LD_VAR 0 1
62227: PPUSH
62228: LD_INT 5
62230: PPUSH
62231: CALL_OW 1
62235: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62236: LD_ADDR_VAR 0 2
62240: PUSH
62241: LD_INT 0
62243: PUSH
62244: LD_INT 0
62246: PUSH
62247: LD_INT 0
62249: PUSH
62250: LD_INT 0
62252: PUSH
62253: EMPTY
62254: LIST
62255: LIST
62256: LIST
62257: LIST
62258: ST_TO_ADDR
// if sci > 1 then
62259: LD_VAR 0 8
62263: PUSH
62264: LD_INT 1
62266: GREATER
62267: IFFALSE 62295
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
62269: LD_ADDR_VAR 0 4
62273: PUSH
62274: LD_VAR 0 4
62278: PUSH
62279: LD_VAR 0 8
62283: PUSH
62284: LD_VAR 0 8
62288: PUSH
62289: LD_INT 1
62291: ARRAY
62292: DIFF
62293: DIFF
62294: ST_TO_ADDR
// if tmp and not sci then
62295: LD_VAR 0 4
62299: PUSH
62300: LD_VAR 0 8
62304: NOT
62305: AND
62306: IFFALSE 62375
// begin sort := SortBySkill ( tmp , 4 ) ;
62308: LD_ADDR_VAR 0 9
62312: PUSH
62313: LD_VAR 0 4
62317: PPUSH
62318: LD_INT 4
62320: PPUSH
62321: CALL 54682 0 2
62325: ST_TO_ADDR
// if sort then
62326: LD_VAR 0 9
62330: IFFALSE 62346
// p := sort [ 1 ] ;
62332: LD_ADDR_VAR 0 11
62336: PUSH
62337: LD_VAR 0 9
62341: PUSH
62342: LD_INT 1
62344: ARRAY
62345: ST_TO_ADDR
// if p then
62346: LD_VAR 0 11
62350: IFFALSE 62375
// result := Replace ( result , 4 , p ) ;
62352: LD_ADDR_VAR 0 2
62356: PUSH
62357: LD_VAR 0 2
62361: PPUSH
62362: LD_INT 4
62364: PPUSH
62365: LD_VAR 0 11
62369: PPUSH
62370: CALL_OW 1
62374: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62375: LD_ADDR_VAR 0 4
62379: PUSH
62380: LD_VAR 0 4
62384: PUSH
62385: LD_VAR 0 7
62389: DIFF
62390: ST_TO_ADDR
// if tmp and mech < 6 then
62391: LD_VAR 0 4
62395: PUSH
62396: LD_VAR 0 7
62400: PUSH
62401: LD_INT 6
62403: LESS
62404: AND
62405: IFFALSE 62593
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62407: LD_ADDR_VAR 0 9
62411: PUSH
62412: LD_VAR 0 4
62416: PUSH
62417: LD_VAR 0 8
62421: PUSH
62422: LD_VAR 0 7
62426: UNION
62427: DIFF
62428: PPUSH
62429: LD_INT 3
62431: PPUSH
62432: CALL 54682 0 2
62436: ST_TO_ADDR
// p := [ ] ;
62437: LD_ADDR_VAR 0 11
62441: PUSH
62442: EMPTY
62443: ST_TO_ADDR
// if sort then
62444: LD_VAR 0 9
62448: IFFALSE 62564
// for i = 1 to 6 - mech do
62450: LD_ADDR_VAR 0 3
62454: PUSH
62455: DOUBLE
62456: LD_INT 1
62458: DEC
62459: ST_TO_ADDR
62460: LD_INT 6
62462: PUSH
62463: LD_VAR 0 7
62467: MINUS
62468: PUSH
62469: FOR_TO
62470: IFFALSE 62562
// begin if i = sort then
62472: LD_VAR 0 3
62476: PUSH
62477: LD_VAR 0 9
62481: EQUAL
62482: IFFALSE 62486
// break ;
62484: GO 62562
// if GetClass ( i ) = 3 then
62486: LD_VAR 0 3
62490: PPUSH
62491: CALL_OW 257
62495: PUSH
62496: LD_INT 3
62498: EQUAL
62499: IFFALSE 62503
// continue ;
62501: GO 62469
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62503: LD_ADDR_VAR 0 11
62507: PUSH
62508: LD_VAR 0 11
62512: PPUSH
62513: LD_VAR 0 11
62517: PUSH
62518: LD_INT 1
62520: PLUS
62521: PPUSH
62522: LD_VAR 0 9
62526: PUSH
62527: LD_VAR 0 3
62531: ARRAY
62532: PPUSH
62533: CALL_OW 2
62537: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62538: LD_ADDR_VAR 0 4
62542: PUSH
62543: LD_VAR 0 4
62547: PUSH
62548: LD_VAR 0 9
62552: PUSH
62553: LD_VAR 0 3
62557: ARRAY
62558: DIFF
62559: ST_TO_ADDR
// end ;
62560: GO 62469
62562: POP
62563: POP
// if p then
62564: LD_VAR 0 11
62568: IFFALSE 62593
// result := Replace ( result , 3 , p ) ;
62570: LD_ADDR_VAR 0 2
62574: PUSH
62575: LD_VAR 0 2
62579: PPUSH
62580: LD_INT 3
62582: PPUSH
62583: LD_VAR 0 11
62587: PPUSH
62588: CALL_OW 1
62592: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62593: LD_ADDR_VAR 0 4
62597: PUSH
62598: LD_VAR 0 4
62602: PUSH
62603: LD_VAR 0 6
62607: DIFF
62608: ST_TO_ADDR
// if tmp and eng < 6 then
62609: LD_VAR 0 4
62613: PUSH
62614: LD_VAR 0 6
62618: PUSH
62619: LD_INT 6
62621: LESS
62622: AND
62623: IFFALSE 62817
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62625: LD_ADDR_VAR 0 9
62629: PUSH
62630: LD_VAR 0 4
62634: PUSH
62635: LD_VAR 0 8
62639: PUSH
62640: LD_VAR 0 7
62644: UNION
62645: PUSH
62646: LD_VAR 0 6
62650: UNION
62651: DIFF
62652: PPUSH
62653: LD_INT 2
62655: PPUSH
62656: CALL 54682 0 2
62660: ST_TO_ADDR
// p := [ ] ;
62661: LD_ADDR_VAR 0 11
62665: PUSH
62666: EMPTY
62667: ST_TO_ADDR
// if sort then
62668: LD_VAR 0 9
62672: IFFALSE 62788
// for i = 1 to 6 - eng do
62674: LD_ADDR_VAR 0 3
62678: PUSH
62679: DOUBLE
62680: LD_INT 1
62682: DEC
62683: ST_TO_ADDR
62684: LD_INT 6
62686: PUSH
62687: LD_VAR 0 6
62691: MINUS
62692: PUSH
62693: FOR_TO
62694: IFFALSE 62786
// begin if i = sort then
62696: LD_VAR 0 3
62700: PUSH
62701: LD_VAR 0 9
62705: EQUAL
62706: IFFALSE 62710
// break ;
62708: GO 62786
// if GetClass ( i ) = 2 then
62710: LD_VAR 0 3
62714: PPUSH
62715: CALL_OW 257
62719: PUSH
62720: LD_INT 2
62722: EQUAL
62723: IFFALSE 62727
// continue ;
62725: GO 62693
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62727: LD_ADDR_VAR 0 11
62731: PUSH
62732: LD_VAR 0 11
62736: PPUSH
62737: LD_VAR 0 11
62741: PUSH
62742: LD_INT 1
62744: PLUS
62745: PPUSH
62746: LD_VAR 0 9
62750: PUSH
62751: LD_VAR 0 3
62755: ARRAY
62756: PPUSH
62757: CALL_OW 2
62761: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62762: LD_ADDR_VAR 0 4
62766: PUSH
62767: LD_VAR 0 4
62771: PUSH
62772: LD_VAR 0 9
62776: PUSH
62777: LD_VAR 0 3
62781: ARRAY
62782: DIFF
62783: ST_TO_ADDR
// end ;
62784: GO 62693
62786: POP
62787: POP
// if p then
62788: LD_VAR 0 11
62792: IFFALSE 62817
// result := Replace ( result , 2 , p ) ;
62794: LD_ADDR_VAR 0 2
62798: PUSH
62799: LD_VAR 0 2
62803: PPUSH
62804: LD_INT 2
62806: PPUSH
62807: LD_VAR 0 11
62811: PPUSH
62812: CALL_OW 1
62816: ST_TO_ADDR
// end ; exit ;
62817: GO 63541
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62819: LD_EXP 85
62823: PUSH
62824: LD_EXP 84
62828: PUSH
62829: LD_VAR 0 1
62833: ARRAY
62834: ARRAY
62835: NOT
62836: PUSH
62837: LD_EXP 58
62841: PUSH
62842: LD_VAR 0 1
62846: ARRAY
62847: PPUSH
62848: LD_INT 30
62850: PUSH
62851: LD_INT 3
62853: PUSH
62854: EMPTY
62855: LIST
62856: LIST
62857: PPUSH
62858: CALL_OW 72
62862: AND
62863: PUSH
62864: LD_EXP 63
62868: PUSH
62869: LD_VAR 0 1
62873: ARRAY
62874: NOT
62875: AND
62876: IFFALSE 63541
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62878: LD_ADDR_EXP 100
62882: PUSH
62883: LD_EXP 100
62887: PPUSH
62888: LD_VAR 0 1
62892: PPUSH
62893: LD_INT 6
62895: PPUSH
62896: CALL_OW 1
62900: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62901: LD_ADDR_VAR 0 2
62905: PUSH
62906: LD_INT 0
62908: PUSH
62909: LD_INT 0
62911: PUSH
62912: LD_INT 0
62914: PUSH
62915: LD_INT 0
62917: PUSH
62918: EMPTY
62919: LIST
62920: LIST
62921: LIST
62922: LIST
62923: ST_TO_ADDR
// if sci >= 1 then
62924: LD_VAR 0 8
62928: PUSH
62929: LD_INT 1
62931: GREATEREQUAL
62932: IFFALSE 62954
// tmp := tmp diff sci [ 1 ] ;
62934: LD_ADDR_VAR 0 4
62938: PUSH
62939: LD_VAR 0 4
62943: PUSH
62944: LD_VAR 0 8
62948: PUSH
62949: LD_INT 1
62951: ARRAY
62952: DIFF
62953: ST_TO_ADDR
// if tmp and not sci then
62954: LD_VAR 0 4
62958: PUSH
62959: LD_VAR 0 8
62963: NOT
62964: AND
62965: IFFALSE 63034
// begin sort := SortBySkill ( tmp , 4 ) ;
62967: LD_ADDR_VAR 0 9
62971: PUSH
62972: LD_VAR 0 4
62976: PPUSH
62977: LD_INT 4
62979: PPUSH
62980: CALL 54682 0 2
62984: ST_TO_ADDR
// if sort then
62985: LD_VAR 0 9
62989: IFFALSE 63005
// p := sort [ 1 ] ;
62991: LD_ADDR_VAR 0 11
62995: PUSH
62996: LD_VAR 0 9
63000: PUSH
63001: LD_INT 1
63003: ARRAY
63004: ST_TO_ADDR
// if p then
63005: LD_VAR 0 11
63009: IFFALSE 63034
// result := Replace ( result , 4 , p ) ;
63011: LD_ADDR_VAR 0 2
63015: PUSH
63016: LD_VAR 0 2
63020: PPUSH
63021: LD_INT 4
63023: PPUSH
63024: LD_VAR 0 11
63028: PPUSH
63029: CALL_OW 1
63033: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63034: LD_ADDR_VAR 0 4
63038: PUSH
63039: LD_VAR 0 4
63043: PUSH
63044: LD_VAR 0 7
63048: DIFF
63049: ST_TO_ADDR
// if tmp and mech < 6 then
63050: LD_VAR 0 4
63054: PUSH
63055: LD_VAR 0 7
63059: PUSH
63060: LD_INT 6
63062: LESS
63063: AND
63064: IFFALSE 63246
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63066: LD_ADDR_VAR 0 9
63070: PUSH
63071: LD_VAR 0 4
63075: PUSH
63076: LD_VAR 0 7
63080: DIFF
63081: PPUSH
63082: LD_INT 3
63084: PPUSH
63085: CALL 54682 0 2
63089: ST_TO_ADDR
// p := [ ] ;
63090: LD_ADDR_VAR 0 11
63094: PUSH
63095: EMPTY
63096: ST_TO_ADDR
// if sort then
63097: LD_VAR 0 9
63101: IFFALSE 63217
// for i = 1 to 6 - mech do
63103: LD_ADDR_VAR 0 3
63107: PUSH
63108: DOUBLE
63109: LD_INT 1
63111: DEC
63112: ST_TO_ADDR
63113: LD_INT 6
63115: PUSH
63116: LD_VAR 0 7
63120: MINUS
63121: PUSH
63122: FOR_TO
63123: IFFALSE 63215
// begin if i = sort then
63125: LD_VAR 0 3
63129: PUSH
63130: LD_VAR 0 9
63134: EQUAL
63135: IFFALSE 63139
// break ;
63137: GO 63215
// if GetClass ( i ) = 3 then
63139: LD_VAR 0 3
63143: PPUSH
63144: CALL_OW 257
63148: PUSH
63149: LD_INT 3
63151: EQUAL
63152: IFFALSE 63156
// continue ;
63154: GO 63122
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63156: LD_ADDR_VAR 0 11
63160: PUSH
63161: LD_VAR 0 11
63165: PPUSH
63166: LD_VAR 0 11
63170: PUSH
63171: LD_INT 1
63173: PLUS
63174: PPUSH
63175: LD_VAR 0 9
63179: PUSH
63180: LD_VAR 0 3
63184: ARRAY
63185: PPUSH
63186: CALL_OW 2
63190: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63191: LD_ADDR_VAR 0 4
63195: PUSH
63196: LD_VAR 0 4
63200: PUSH
63201: LD_VAR 0 9
63205: PUSH
63206: LD_VAR 0 3
63210: ARRAY
63211: DIFF
63212: ST_TO_ADDR
// end ;
63213: GO 63122
63215: POP
63216: POP
// if p then
63217: LD_VAR 0 11
63221: IFFALSE 63246
// result := Replace ( result , 3 , p ) ;
63223: LD_ADDR_VAR 0 2
63227: PUSH
63228: LD_VAR 0 2
63232: PPUSH
63233: LD_INT 3
63235: PPUSH
63236: LD_VAR 0 11
63240: PPUSH
63241: CALL_OW 1
63245: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63246: LD_ADDR_VAR 0 4
63250: PUSH
63251: LD_VAR 0 4
63255: PUSH
63256: LD_VAR 0 6
63260: DIFF
63261: ST_TO_ADDR
// if tmp and eng < 4 then
63262: LD_VAR 0 4
63266: PUSH
63267: LD_VAR 0 6
63271: PUSH
63272: LD_INT 4
63274: LESS
63275: AND
63276: IFFALSE 63466
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
63278: LD_ADDR_VAR 0 9
63282: PUSH
63283: LD_VAR 0 4
63287: PUSH
63288: LD_VAR 0 7
63292: PUSH
63293: LD_VAR 0 6
63297: UNION
63298: DIFF
63299: PPUSH
63300: LD_INT 2
63302: PPUSH
63303: CALL 54682 0 2
63307: ST_TO_ADDR
// p := [ ] ;
63308: LD_ADDR_VAR 0 11
63312: PUSH
63313: EMPTY
63314: ST_TO_ADDR
// if sort then
63315: LD_VAR 0 9
63319: IFFALSE 63435
// for i = 1 to 4 - eng do
63321: LD_ADDR_VAR 0 3
63325: PUSH
63326: DOUBLE
63327: LD_INT 1
63329: DEC
63330: ST_TO_ADDR
63331: LD_INT 4
63333: PUSH
63334: LD_VAR 0 6
63338: MINUS
63339: PUSH
63340: FOR_TO
63341: IFFALSE 63433
// begin if i = sort then
63343: LD_VAR 0 3
63347: PUSH
63348: LD_VAR 0 9
63352: EQUAL
63353: IFFALSE 63357
// break ;
63355: GO 63433
// if GetClass ( i ) = 2 then
63357: LD_VAR 0 3
63361: PPUSH
63362: CALL_OW 257
63366: PUSH
63367: LD_INT 2
63369: EQUAL
63370: IFFALSE 63374
// continue ;
63372: GO 63340
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63374: LD_ADDR_VAR 0 11
63378: PUSH
63379: LD_VAR 0 11
63383: PPUSH
63384: LD_VAR 0 11
63388: PUSH
63389: LD_INT 1
63391: PLUS
63392: PPUSH
63393: LD_VAR 0 9
63397: PUSH
63398: LD_VAR 0 3
63402: ARRAY
63403: PPUSH
63404: CALL_OW 2
63408: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63409: LD_ADDR_VAR 0 4
63413: PUSH
63414: LD_VAR 0 4
63418: PUSH
63419: LD_VAR 0 9
63423: PUSH
63424: LD_VAR 0 3
63428: ARRAY
63429: DIFF
63430: ST_TO_ADDR
// end ;
63431: GO 63340
63433: POP
63434: POP
// if p then
63435: LD_VAR 0 11
63439: IFFALSE 63464
// result := Replace ( result , 2 , p ) ;
63441: LD_ADDR_VAR 0 2
63445: PUSH
63446: LD_VAR 0 2
63450: PPUSH
63451: LD_INT 2
63453: PPUSH
63454: LD_VAR 0 11
63458: PPUSH
63459: CALL_OW 1
63463: ST_TO_ADDR
// end else
63464: GO 63510
// for i = eng downto 5 do
63466: LD_ADDR_VAR 0 3
63470: PUSH
63471: DOUBLE
63472: LD_VAR 0 6
63476: INC
63477: ST_TO_ADDR
63478: LD_INT 5
63480: PUSH
63481: FOR_DOWNTO
63482: IFFALSE 63508
// tmp := tmp union eng [ i ] ;
63484: LD_ADDR_VAR 0 4
63488: PUSH
63489: LD_VAR 0 4
63493: PUSH
63494: LD_VAR 0 6
63498: PUSH
63499: LD_VAR 0 3
63503: ARRAY
63504: UNION
63505: ST_TO_ADDR
63506: GO 63481
63508: POP
63509: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63510: LD_ADDR_VAR 0 2
63514: PUSH
63515: LD_VAR 0 2
63519: PPUSH
63520: LD_INT 1
63522: PPUSH
63523: LD_VAR 0 4
63527: PUSH
63528: LD_VAR 0 5
63532: DIFF
63533: PPUSH
63534: CALL_OW 1
63538: ST_TO_ADDR
// exit ;
63539: GO 63541
// end ; end ;
63541: LD_VAR 0 2
63545: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63546: LD_INT 0
63548: PPUSH
63549: PPUSH
63550: PPUSH
// if not mc_bases then
63551: LD_EXP 58
63555: NOT
63556: IFFALSE 63560
// exit ;
63558: GO 63666
// for i = 1 to mc_bases do
63560: LD_ADDR_VAR 0 2
63564: PUSH
63565: DOUBLE
63566: LD_INT 1
63568: DEC
63569: ST_TO_ADDR
63570: LD_EXP 58
63574: PUSH
63575: FOR_TO
63576: IFFALSE 63657
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63578: LD_ADDR_VAR 0 3
63582: PUSH
63583: LD_EXP 58
63587: PUSH
63588: LD_VAR 0 2
63592: ARRAY
63593: PPUSH
63594: LD_INT 21
63596: PUSH
63597: LD_INT 3
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: PUSH
63604: LD_INT 3
63606: PUSH
63607: LD_INT 24
63609: PUSH
63610: LD_INT 1000
63612: PUSH
63613: EMPTY
63614: LIST
63615: LIST
63616: PUSH
63617: EMPTY
63618: LIST
63619: LIST
63620: PUSH
63621: EMPTY
63622: LIST
63623: LIST
63624: PPUSH
63625: CALL_OW 72
63629: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63630: LD_ADDR_EXP 59
63634: PUSH
63635: LD_EXP 59
63639: PPUSH
63640: LD_VAR 0 2
63644: PPUSH
63645: LD_VAR 0 3
63649: PPUSH
63650: CALL_OW 1
63654: ST_TO_ADDR
// end ;
63655: GO 63575
63657: POP
63658: POP
// RaiseSailEvent ( 101 ) ;
63659: LD_INT 101
63661: PPUSH
63662: CALL_OW 427
// end ;
63666: LD_VAR 0 1
63670: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63671: LD_INT 0
63673: PPUSH
63674: PPUSH
63675: PPUSH
63676: PPUSH
63677: PPUSH
63678: PPUSH
63679: PPUSH
// if not mc_bases then
63680: LD_EXP 58
63684: NOT
63685: IFFALSE 63689
// exit ;
63687: GO 64262
// for i = 1 to mc_bases do
63689: LD_ADDR_VAR 0 2
63693: PUSH
63694: DOUBLE
63695: LD_INT 1
63697: DEC
63698: ST_TO_ADDR
63699: LD_EXP 58
63703: PUSH
63704: FOR_TO
63705: IFFALSE 64253
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
63707: LD_ADDR_VAR 0 5
63711: PUSH
63712: LD_EXP 58
63716: PUSH
63717: LD_VAR 0 2
63721: ARRAY
63722: PUSH
63723: LD_EXP 87
63727: PUSH
63728: LD_VAR 0 2
63732: ARRAY
63733: UNION
63734: PPUSH
63735: LD_INT 21
63737: PUSH
63738: LD_INT 1
63740: PUSH
63741: EMPTY
63742: LIST
63743: LIST
63744: PUSH
63745: LD_INT 1
63747: PUSH
63748: LD_INT 3
63750: PUSH
63751: LD_INT 54
63753: PUSH
63754: EMPTY
63755: LIST
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: PUSH
63761: LD_INT 3
63763: PUSH
63764: LD_INT 24
63766: PUSH
63767: LD_INT 750
63769: PUSH
63770: EMPTY
63771: LIST
63772: LIST
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: PUSH
63778: EMPTY
63779: LIST
63780: LIST
63781: LIST
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PPUSH
63787: CALL_OW 72
63791: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63792: LD_ADDR_VAR 0 6
63796: PUSH
63797: LD_EXP 58
63801: PUSH
63802: LD_VAR 0 2
63806: ARRAY
63807: PPUSH
63808: LD_INT 21
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 1
63820: PUSH
63821: LD_INT 3
63823: PUSH
63824: LD_INT 54
63826: PUSH
63827: EMPTY
63828: LIST
63829: PUSH
63830: EMPTY
63831: LIST
63832: LIST
63833: PUSH
63834: LD_INT 3
63836: PUSH
63837: LD_INT 24
63839: PUSH
63840: LD_INT 250
63842: PUSH
63843: EMPTY
63844: LIST
63845: LIST
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: EMPTY
63852: LIST
63853: LIST
63854: LIST
63855: PUSH
63856: EMPTY
63857: LIST
63858: LIST
63859: PPUSH
63860: CALL_OW 72
63864: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63865: LD_ADDR_VAR 0 7
63869: PUSH
63870: LD_VAR 0 5
63874: PUSH
63875: LD_VAR 0 6
63879: DIFF
63880: ST_TO_ADDR
// if not need_heal_1 then
63881: LD_VAR 0 6
63885: NOT
63886: IFFALSE 63919
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63888: LD_ADDR_EXP 61
63892: PUSH
63893: LD_EXP 61
63897: PPUSH
63898: LD_VAR 0 2
63902: PUSH
63903: LD_INT 1
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PPUSH
63910: EMPTY
63911: PPUSH
63912: CALL 20497 0 3
63916: ST_TO_ADDR
63917: GO 63989
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63919: LD_ADDR_EXP 61
63923: PUSH
63924: LD_EXP 61
63928: PPUSH
63929: LD_VAR 0 2
63933: PUSH
63934: LD_INT 1
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PPUSH
63941: LD_EXP 61
63945: PUSH
63946: LD_VAR 0 2
63950: ARRAY
63951: PUSH
63952: LD_INT 1
63954: ARRAY
63955: PPUSH
63956: LD_INT 3
63958: PUSH
63959: LD_INT 24
63961: PUSH
63962: LD_INT 1000
63964: PUSH
63965: EMPTY
63966: LIST
63967: LIST
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PPUSH
63973: CALL_OW 72
63977: PUSH
63978: LD_VAR 0 6
63982: UNION
63983: PPUSH
63984: CALL 20497 0 3
63988: ST_TO_ADDR
// if not need_heal_2 then
63989: LD_VAR 0 7
63993: NOT
63994: IFFALSE 64027
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63996: LD_ADDR_EXP 61
64000: PUSH
64001: LD_EXP 61
64005: PPUSH
64006: LD_VAR 0 2
64010: PUSH
64011: LD_INT 2
64013: PUSH
64014: EMPTY
64015: LIST
64016: LIST
64017: PPUSH
64018: EMPTY
64019: PPUSH
64020: CALL 20497 0 3
64024: ST_TO_ADDR
64025: GO 64059
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64027: LD_ADDR_EXP 61
64031: PUSH
64032: LD_EXP 61
64036: PPUSH
64037: LD_VAR 0 2
64041: PUSH
64042: LD_INT 2
64044: PUSH
64045: EMPTY
64046: LIST
64047: LIST
64048: PPUSH
64049: LD_VAR 0 7
64053: PPUSH
64054: CALL 20497 0 3
64058: ST_TO_ADDR
// if need_heal_2 then
64059: LD_VAR 0 7
64063: IFFALSE 64235
// for j in need_heal_2 do
64065: LD_ADDR_VAR 0 3
64069: PUSH
64070: LD_VAR 0 7
64074: PUSH
64075: FOR_IN
64076: IFFALSE 64233
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
64078: LD_ADDR_VAR 0 5
64082: PUSH
64083: LD_EXP 58
64087: PUSH
64088: LD_VAR 0 2
64092: ARRAY
64093: PPUSH
64094: LD_INT 2
64096: PUSH
64097: LD_INT 30
64099: PUSH
64100: LD_INT 6
64102: PUSH
64103: EMPTY
64104: LIST
64105: LIST
64106: PUSH
64107: LD_INT 30
64109: PUSH
64110: LD_INT 7
64112: PUSH
64113: EMPTY
64114: LIST
64115: LIST
64116: PUSH
64117: LD_INT 30
64119: PUSH
64120: LD_INT 8
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 30
64129: PUSH
64130: LD_INT 0
64132: PUSH
64133: EMPTY
64134: LIST
64135: LIST
64136: PUSH
64137: LD_INT 30
64139: PUSH
64140: LD_INT 1
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: LD_INT 25
64149: PUSH
64150: LD_INT 4
64152: PUSH
64153: EMPTY
64154: LIST
64155: LIST
64156: PUSH
64157: EMPTY
64158: LIST
64159: LIST
64160: LIST
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: PPUSH
64166: CALL_OW 72
64170: ST_TO_ADDR
// if tmp then
64171: LD_VAR 0 5
64175: IFFALSE 64231
// begin k := NearestUnitToUnit ( tmp , j ) ;
64177: LD_ADDR_VAR 0 4
64181: PUSH
64182: LD_VAR 0 5
64186: PPUSH
64187: LD_VAR 0 3
64191: PPUSH
64192: CALL_OW 74
64196: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
64197: LD_VAR 0 3
64201: PPUSH
64202: LD_VAR 0 4
64206: PPUSH
64207: CALL_OW 296
64211: PUSH
64212: LD_INT 7
64214: GREATER
64215: IFFALSE 64231
// ComMoveUnit ( j , k ) ;
64217: LD_VAR 0 3
64221: PPUSH
64222: LD_VAR 0 4
64226: PPUSH
64227: CALL_OW 112
// end ; end ;
64231: GO 64075
64233: POP
64234: POP
// if not need_heal_1 and not need_heal_2 then
64235: LD_VAR 0 6
64239: NOT
64240: PUSH
64241: LD_VAR 0 7
64245: NOT
64246: AND
64247: IFFALSE 64251
// continue ;
64249: GO 63704
// end ;
64251: GO 63704
64253: POP
64254: POP
// RaiseSailEvent ( 102 ) ;
64255: LD_INT 102
64257: PPUSH
64258: CALL_OW 427
// end ;
64262: LD_VAR 0 1
64266: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
64267: LD_INT 0
64269: PPUSH
64270: PPUSH
64271: PPUSH
64272: PPUSH
64273: PPUSH
// if not mc_bases then
64274: LD_EXP 58
64278: NOT
64279: IFFALSE 64283
// exit ;
64281: GO 64668
// for i = 1 to mc_bases do
64283: LD_ADDR_VAR 0 2
64287: PUSH
64288: DOUBLE
64289: LD_INT 1
64291: DEC
64292: ST_TO_ADDR
64293: LD_EXP 58
64297: PUSH
64298: FOR_TO
64299: IFFALSE 64666
// begin if not mc_building_need_repair [ i ] then
64301: LD_EXP 59
64305: PUSH
64306: LD_VAR 0 2
64310: ARRAY
64311: NOT
64312: IFFALSE 64350
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64314: LD_ADDR_EXP 60
64318: PUSH
64319: LD_EXP 60
64323: PPUSH
64324: LD_VAR 0 2
64328: PPUSH
64329: EMPTY
64330: PPUSH
64331: CALL_OW 1
64335: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64336: LD_VAR 0 2
64340: PPUSH
64341: LD_INT 101
64343: PPUSH
64344: CALL 59388 0 2
// continue ;
64348: GO 64298
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64350: LD_ADDR_EXP 64
64354: PUSH
64355: LD_EXP 64
64359: PPUSH
64360: LD_VAR 0 2
64364: PPUSH
64365: EMPTY
64366: PPUSH
64367: CALL_OW 1
64371: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64372: LD_VAR 0 2
64376: PPUSH
64377: LD_INT 103
64379: PPUSH
64380: CALL 59388 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64384: LD_ADDR_VAR 0 5
64388: PUSH
64389: LD_EXP 58
64393: PUSH
64394: LD_VAR 0 2
64398: ARRAY
64399: PUSH
64400: LD_EXP 87
64404: PUSH
64405: LD_VAR 0 2
64409: ARRAY
64410: UNION
64411: PPUSH
64412: LD_INT 2
64414: PUSH
64415: LD_INT 25
64417: PUSH
64418: LD_INT 2
64420: PUSH
64421: EMPTY
64422: LIST
64423: LIST
64424: PUSH
64425: LD_INT 25
64427: PUSH
64428: LD_INT 16
64430: PUSH
64431: EMPTY
64432: LIST
64433: LIST
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: LIST
64439: PUSH
64440: EMPTY
64441: LIST
64442: PPUSH
64443: CALL_OW 72
64447: ST_TO_ADDR
// if not tmp then
64448: LD_VAR 0 5
64452: NOT
64453: IFFALSE 64457
// continue ;
64455: GO 64298
// for j in tmp do
64457: LD_ADDR_VAR 0 3
64461: PUSH
64462: LD_VAR 0 5
64466: PUSH
64467: FOR_IN
64468: IFFALSE 64662
// begin if mc_need_heal [ i ] then
64470: LD_EXP 61
64474: PUSH
64475: LD_VAR 0 2
64479: ARRAY
64480: IFFALSE 64528
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
64482: LD_VAR 0 3
64486: PUSH
64487: LD_EXP 61
64491: PUSH
64492: LD_VAR 0 2
64496: ARRAY
64497: PUSH
64498: LD_INT 1
64500: ARRAY
64501: IN
64502: PUSH
64503: LD_VAR 0 3
64507: PUSH
64508: LD_EXP 61
64512: PUSH
64513: LD_VAR 0 2
64517: ARRAY
64518: PUSH
64519: LD_INT 2
64521: ARRAY
64522: IN
64523: OR
64524: IFFALSE 64528
// continue ;
64526: GO 64467
// if IsInUnit ( j ) then
64528: LD_VAR 0 3
64532: PPUSH
64533: CALL_OW 310
64537: IFFALSE 64548
// ComExitBuilding ( j ) ;
64539: LD_VAR 0 3
64543: PPUSH
64544: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64548: LD_VAR 0 3
64552: PUSH
64553: LD_EXP 60
64557: PUSH
64558: LD_VAR 0 2
64562: ARRAY
64563: IN
64564: NOT
64565: IFFALSE 64623
// begin SetTag ( j , 101 ) ;
64567: LD_VAR 0 3
64571: PPUSH
64572: LD_INT 101
64574: PPUSH
64575: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64579: LD_ADDR_EXP 60
64583: PUSH
64584: LD_EXP 60
64588: PPUSH
64589: LD_VAR 0 2
64593: PUSH
64594: LD_EXP 60
64598: PUSH
64599: LD_VAR 0 2
64603: ARRAY
64604: PUSH
64605: LD_INT 1
64607: PLUS
64608: PUSH
64609: EMPTY
64610: LIST
64611: LIST
64612: PPUSH
64613: LD_VAR 0 3
64617: PPUSH
64618: CALL 20497 0 3
64622: ST_TO_ADDR
// end ; wait ( 1 ) ;
64623: LD_INT 1
64625: PPUSH
64626: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
64630: LD_VAR 0 3
64634: PPUSH
64635: LD_EXP 59
64639: PUSH
64640: LD_VAR 0 2
64644: ARRAY
64645: PPUSH
64646: LD_VAR 0 3
64650: PPUSH
64651: CALL_OW 74
64655: PPUSH
64656: CALL_OW 130
// end ;
64660: GO 64467
64662: POP
64663: POP
// end ;
64664: GO 64298
64666: POP
64667: POP
// end ;
64668: LD_VAR 0 1
64672: RET
// export function MC_Heal ; var i , j , tmp ; begin
64673: LD_INT 0
64675: PPUSH
64676: PPUSH
64677: PPUSH
64678: PPUSH
// if not mc_bases then
64679: LD_EXP 58
64683: NOT
64684: IFFALSE 64688
// exit ;
64686: GO 65090
// for i = 1 to mc_bases do
64688: LD_ADDR_VAR 0 2
64692: PUSH
64693: DOUBLE
64694: LD_INT 1
64696: DEC
64697: ST_TO_ADDR
64698: LD_EXP 58
64702: PUSH
64703: FOR_TO
64704: IFFALSE 65088
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64706: LD_EXP 61
64710: PUSH
64711: LD_VAR 0 2
64715: ARRAY
64716: PUSH
64717: LD_INT 1
64719: ARRAY
64720: NOT
64721: PUSH
64722: LD_EXP 61
64726: PUSH
64727: LD_VAR 0 2
64731: ARRAY
64732: PUSH
64733: LD_INT 2
64735: ARRAY
64736: NOT
64737: AND
64738: IFFALSE 64776
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64740: LD_ADDR_EXP 62
64744: PUSH
64745: LD_EXP 62
64749: PPUSH
64750: LD_VAR 0 2
64754: PPUSH
64755: EMPTY
64756: PPUSH
64757: CALL_OW 1
64761: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64762: LD_VAR 0 2
64766: PPUSH
64767: LD_INT 102
64769: PPUSH
64770: CALL 59388 0 2
// continue ;
64774: GO 64703
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64776: LD_ADDR_VAR 0 4
64780: PUSH
64781: LD_EXP 58
64785: PUSH
64786: LD_VAR 0 2
64790: ARRAY
64791: PPUSH
64792: LD_INT 25
64794: PUSH
64795: LD_INT 4
64797: PUSH
64798: EMPTY
64799: LIST
64800: LIST
64801: PPUSH
64802: CALL_OW 72
64806: ST_TO_ADDR
// if not tmp then
64807: LD_VAR 0 4
64811: NOT
64812: IFFALSE 64816
// continue ;
64814: GO 64703
// if mc_taming [ i ] then
64816: LD_EXP 89
64820: PUSH
64821: LD_VAR 0 2
64825: ARRAY
64826: IFFALSE 64850
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64828: LD_ADDR_EXP 89
64832: PUSH
64833: LD_EXP 89
64837: PPUSH
64838: LD_VAR 0 2
64842: PPUSH
64843: EMPTY
64844: PPUSH
64845: CALL_OW 1
64849: ST_TO_ADDR
// for j in tmp do
64850: LD_ADDR_VAR 0 3
64854: PUSH
64855: LD_VAR 0 4
64859: PUSH
64860: FOR_IN
64861: IFFALSE 65084
// begin if IsInUnit ( j ) then
64863: LD_VAR 0 3
64867: PPUSH
64868: CALL_OW 310
64872: IFFALSE 64883
// ComExitBuilding ( j ) ;
64874: LD_VAR 0 3
64878: PPUSH
64879: CALL_OW 122
// if not j in mc_healers [ i ] then
64883: LD_VAR 0 3
64887: PUSH
64888: LD_EXP 62
64892: PUSH
64893: LD_VAR 0 2
64897: ARRAY
64898: IN
64899: NOT
64900: IFFALSE 64946
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64902: LD_ADDR_EXP 62
64906: PUSH
64907: LD_EXP 62
64911: PPUSH
64912: LD_VAR 0 2
64916: PUSH
64917: LD_EXP 62
64921: PUSH
64922: LD_VAR 0 2
64926: ARRAY
64927: PUSH
64928: LD_INT 1
64930: PLUS
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PPUSH
64936: LD_VAR 0 3
64940: PPUSH
64941: CALL 20497 0 3
64945: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64946: LD_VAR 0 3
64950: PPUSH
64951: CALL_OW 110
64955: PUSH
64956: LD_INT 102
64958: NONEQUAL
64959: IFFALSE 64973
// SetTag ( j , 102 ) ;
64961: LD_VAR 0 3
64965: PPUSH
64966: LD_INT 102
64968: PPUSH
64969: CALL_OW 109
// Wait ( 3 ) ;
64973: LD_INT 3
64975: PPUSH
64976: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64980: LD_EXP 61
64984: PUSH
64985: LD_VAR 0 2
64989: ARRAY
64990: PUSH
64991: LD_INT 1
64993: ARRAY
64994: IFFALSE 65026
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64996: LD_VAR 0 3
65000: PPUSH
65001: LD_EXP 61
65005: PUSH
65006: LD_VAR 0 2
65010: ARRAY
65011: PUSH
65012: LD_INT 1
65014: ARRAY
65015: PUSH
65016: LD_INT 1
65018: ARRAY
65019: PPUSH
65020: CALL_OW 128
65024: GO 65082
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65026: LD_VAR 0 3
65030: PPUSH
65031: CALL_OW 314
65035: NOT
65036: PUSH
65037: LD_EXP 61
65041: PUSH
65042: LD_VAR 0 2
65046: ARRAY
65047: PUSH
65048: LD_INT 2
65050: ARRAY
65051: AND
65052: IFFALSE 65082
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65054: LD_VAR 0 3
65058: PPUSH
65059: LD_EXP 61
65063: PUSH
65064: LD_VAR 0 2
65068: ARRAY
65069: PUSH
65070: LD_INT 2
65072: ARRAY
65073: PUSH
65074: LD_INT 1
65076: ARRAY
65077: PPUSH
65078: CALL_OW 128
// end ;
65082: GO 64860
65084: POP
65085: POP
// end ;
65086: GO 64703
65088: POP
65089: POP
// end ;
65090: LD_VAR 0 1
65094: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65095: LD_INT 0
65097: PPUSH
65098: PPUSH
65099: PPUSH
65100: PPUSH
65101: PPUSH
// if not mc_bases then
65102: LD_EXP 58
65106: NOT
65107: IFFALSE 65111
// exit ;
65109: GO 66254
// for i = 1 to mc_bases do
65111: LD_ADDR_VAR 0 2
65115: PUSH
65116: DOUBLE
65117: LD_INT 1
65119: DEC
65120: ST_TO_ADDR
65121: LD_EXP 58
65125: PUSH
65126: FOR_TO
65127: IFFALSE 66252
// begin if mc_scan [ i ] then
65129: LD_EXP 81
65133: PUSH
65134: LD_VAR 0 2
65138: ARRAY
65139: IFFALSE 65143
// continue ;
65141: GO 65126
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65143: LD_EXP 63
65147: PUSH
65148: LD_VAR 0 2
65152: ARRAY
65153: NOT
65154: PUSH
65155: LD_EXP 65
65159: PUSH
65160: LD_VAR 0 2
65164: ARRAY
65165: NOT
65166: AND
65167: PUSH
65168: LD_EXP 64
65172: PUSH
65173: LD_VAR 0 2
65177: ARRAY
65178: AND
65179: IFFALSE 65217
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65181: LD_ADDR_EXP 64
65185: PUSH
65186: LD_EXP 64
65190: PPUSH
65191: LD_VAR 0 2
65195: PPUSH
65196: EMPTY
65197: PPUSH
65198: CALL_OW 1
65202: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65203: LD_VAR 0 2
65207: PPUSH
65208: LD_INT 103
65210: PPUSH
65211: CALL 59388 0 2
// continue ;
65215: GO 65126
// end ; if mc_construct_list [ i ] then
65217: LD_EXP 65
65221: PUSH
65222: LD_VAR 0 2
65226: ARRAY
65227: IFFALSE 65447
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65229: LD_ADDR_VAR 0 4
65233: PUSH
65234: LD_EXP 58
65238: PUSH
65239: LD_VAR 0 2
65243: ARRAY
65244: PPUSH
65245: LD_INT 25
65247: PUSH
65248: LD_INT 2
65250: PUSH
65251: EMPTY
65252: LIST
65253: LIST
65254: PPUSH
65255: CALL_OW 72
65259: PUSH
65260: LD_EXP 60
65264: PUSH
65265: LD_VAR 0 2
65269: ARRAY
65270: DIFF
65271: ST_TO_ADDR
// if not tmp then
65272: LD_VAR 0 4
65276: NOT
65277: IFFALSE 65281
// continue ;
65279: GO 65126
// for j in tmp do
65281: LD_ADDR_VAR 0 3
65285: PUSH
65286: LD_VAR 0 4
65290: PUSH
65291: FOR_IN
65292: IFFALSE 65443
// begin if not mc_builders [ i ] then
65294: LD_EXP 64
65298: PUSH
65299: LD_VAR 0 2
65303: ARRAY
65304: NOT
65305: IFFALSE 65363
// begin SetTag ( j , 103 ) ;
65307: LD_VAR 0 3
65311: PPUSH
65312: LD_INT 103
65314: PPUSH
65315: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65319: LD_ADDR_EXP 64
65323: PUSH
65324: LD_EXP 64
65328: PPUSH
65329: LD_VAR 0 2
65333: PUSH
65334: LD_EXP 64
65338: PUSH
65339: LD_VAR 0 2
65343: ARRAY
65344: PUSH
65345: LD_INT 1
65347: PLUS
65348: PUSH
65349: EMPTY
65350: LIST
65351: LIST
65352: PPUSH
65353: LD_VAR 0 3
65357: PPUSH
65358: CALL 20497 0 3
65362: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65363: LD_VAR 0 3
65367: PPUSH
65368: CALL_OW 310
65372: IFFALSE 65383
// ComExitBuilding ( j ) ;
65374: LD_VAR 0 3
65378: PPUSH
65379: CALL_OW 122
// wait ( 3 ) ;
65383: LD_INT 3
65385: PPUSH
65386: CALL_OW 67
// if not mc_construct_list [ i ] then
65390: LD_EXP 65
65394: PUSH
65395: LD_VAR 0 2
65399: ARRAY
65400: NOT
65401: IFFALSE 65405
// break ;
65403: GO 65443
// if not HasTask ( j ) then
65405: LD_VAR 0 3
65409: PPUSH
65410: CALL_OW 314
65414: NOT
65415: IFFALSE 65441
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65417: LD_VAR 0 3
65421: PPUSH
65422: LD_EXP 65
65426: PUSH
65427: LD_VAR 0 2
65431: ARRAY
65432: PUSH
65433: LD_INT 1
65435: ARRAY
65436: PPUSH
65437: CALL 23348 0 2
// end ;
65441: GO 65291
65443: POP
65444: POP
// end else
65445: GO 66250
// if mc_build_list [ i ] then
65447: LD_EXP 63
65451: PUSH
65452: LD_VAR 0 2
65456: ARRAY
65457: IFFALSE 66250
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65459: LD_ADDR_VAR 0 5
65463: PUSH
65464: LD_EXP 58
65468: PUSH
65469: LD_VAR 0 2
65473: ARRAY
65474: PPUSH
65475: LD_INT 2
65477: PUSH
65478: LD_INT 30
65480: PUSH
65481: LD_INT 0
65483: PUSH
65484: EMPTY
65485: LIST
65486: LIST
65487: PUSH
65488: LD_INT 30
65490: PUSH
65491: LD_INT 1
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: EMPTY
65499: LIST
65500: LIST
65501: LIST
65502: PPUSH
65503: CALL_OW 72
65507: ST_TO_ADDR
// if depot then
65508: LD_VAR 0 5
65512: IFFALSE 65530
// depot := depot [ 1 ] else
65514: LD_ADDR_VAR 0 5
65518: PUSH
65519: LD_VAR 0 5
65523: PUSH
65524: LD_INT 1
65526: ARRAY
65527: ST_TO_ADDR
65528: GO 65538
// depot := 0 ;
65530: LD_ADDR_VAR 0 5
65534: PUSH
65535: LD_INT 0
65537: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65538: LD_EXP 63
65542: PUSH
65543: LD_VAR 0 2
65547: ARRAY
65548: PUSH
65549: LD_INT 1
65551: ARRAY
65552: PUSH
65553: LD_INT 1
65555: ARRAY
65556: PPUSH
65557: CALL 23178 0 1
65561: PUSH
65562: LD_EXP 58
65566: PUSH
65567: LD_VAR 0 2
65571: ARRAY
65572: PPUSH
65573: LD_INT 2
65575: PUSH
65576: LD_INT 30
65578: PUSH
65579: LD_INT 2
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 30
65588: PUSH
65589: LD_INT 3
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: LIST
65600: PPUSH
65601: CALL_OW 72
65605: NOT
65606: AND
65607: IFFALSE 65712
// begin for j = 1 to mc_build_list [ i ] do
65609: LD_ADDR_VAR 0 3
65613: PUSH
65614: DOUBLE
65615: LD_INT 1
65617: DEC
65618: ST_TO_ADDR
65619: LD_EXP 63
65623: PUSH
65624: LD_VAR 0 2
65628: ARRAY
65629: PUSH
65630: FOR_TO
65631: IFFALSE 65710
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65633: LD_EXP 63
65637: PUSH
65638: LD_VAR 0 2
65642: ARRAY
65643: PUSH
65644: LD_VAR 0 3
65648: ARRAY
65649: PUSH
65650: LD_INT 1
65652: ARRAY
65653: PUSH
65654: LD_INT 2
65656: EQUAL
65657: IFFALSE 65708
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65659: LD_ADDR_EXP 63
65663: PUSH
65664: LD_EXP 63
65668: PPUSH
65669: LD_VAR 0 2
65673: PPUSH
65674: LD_EXP 63
65678: PUSH
65679: LD_VAR 0 2
65683: ARRAY
65684: PPUSH
65685: LD_VAR 0 3
65689: PPUSH
65690: LD_INT 1
65692: PPUSH
65693: LD_INT 0
65695: PPUSH
65696: CALL 19915 0 4
65700: PPUSH
65701: CALL_OW 1
65705: ST_TO_ADDR
// break ;
65706: GO 65710
// end ;
65708: GO 65630
65710: POP
65711: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65712: LD_EXP 63
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: PUSH
65727: LD_INT 1
65729: ARRAY
65730: PUSH
65731: LD_INT 0
65733: EQUAL
65734: PUSH
65735: LD_VAR 0 5
65739: PUSH
65740: LD_VAR 0 5
65744: PPUSH
65745: LD_EXP 63
65749: PUSH
65750: LD_VAR 0 2
65754: ARRAY
65755: PUSH
65756: LD_INT 1
65758: ARRAY
65759: PUSH
65760: LD_INT 1
65762: ARRAY
65763: PPUSH
65764: LD_EXP 63
65768: PUSH
65769: LD_VAR 0 2
65773: ARRAY
65774: PUSH
65775: LD_INT 1
65777: ARRAY
65778: PUSH
65779: LD_INT 2
65781: ARRAY
65782: PPUSH
65783: LD_EXP 63
65787: PUSH
65788: LD_VAR 0 2
65792: ARRAY
65793: PUSH
65794: LD_INT 1
65796: ARRAY
65797: PUSH
65798: LD_INT 3
65800: ARRAY
65801: PPUSH
65802: LD_EXP 63
65806: PUSH
65807: LD_VAR 0 2
65811: ARRAY
65812: PUSH
65813: LD_INT 1
65815: ARRAY
65816: PUSH
65817: LD_INT 4
65819: ARRAY
65820: PPUSH
65821: CALL 27894 0 5
65825: AND
65826: OR
65827: IFFALSE 66108
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65829: LD_ADDR_VAR 0 4
65833: PUSH
65834: LD_EXP 58
65838: PUSH
65839: LD_VAR 0 2
65843: ARRAY
65844: PPUSH
65845: LD_INT 25
65847: PUSH
65848: LD_INT 2
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PPUSH
65855: CALL_OW 72
65859: PUSH
65860: LD_EXP 60
65864: PUSH
65865: LD_VAR 0 2
65869: ARRAY
65870: DIFF
65871: ST_TO_ADDR
// if not tmp then
65872: LD_VAR 0 4
65876: NOT
65877: IFFALSE 65881
// continue ;
65879: GO 65126
// for j in tmp do
65881: LD_ADDR_VAR 0 3
65885: PUSH
65886: LD_VAR 0 4
65890: PUSH
65891: FOR_IN
65892: IFFALSE 66104
// begin if not mc_builders [ i ] then
65894: LD_EXP 64
65898: PUSH
65899: LD_VAR 0 2
65903: ARRAY
65904: NOT
65905: IFFALSE 65963
// begin SetTag ( j , 103 ) ;
65907: LD_VAR 0 3
65911: PPUSH
65912: LD_INT 103
65914: PPUSH
65915: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65919: LD_ADDR_EXP 64
65923: PUSH
65924: LD_EXP 64
65928: PPUSH
65929: LD_VAR 0 2
65933: PUSH
65934: LD_EXP 64
65938: PUSH
65939: LD_VAR 0 2
65943: ARRAY
65944: PUSH
65945: LD_INT 1
65947: PLUS
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: PPUSH
65953: LD_VAR 0 3
65957: PPUSH
65958: CALL 20497 0 3
65962: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65963: LD_VAR 0 3
65967: PPUSH
65968: CALL_OW 310
65972: IFFALSE 65983
// ComExitBuilding ( j ) ;
65974: LD_VAR 0 3
65978: PPUSH
65979: CALL_OW 122
// wait ( 3 ) ;
65983: LD_INT 3
65985: PPUSH
65986: CALL_OW 67
// if not mc_build_list [ i ] then
65990: LD_EXP 63
65994: PUSH
65995: LD_VAR 0 2
65999: ARRAY
66000: NOT
66001: IFFALSE 66005
// break ;
66003: GO 66104
// if not HasTask ( j ) then
66005: LD_VAR 0 3
66009: PPUSH
66010: CALL_OW 314
66014: NOT
66015: IFFALSE 66102
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66017: LD_VAR 0 3
66021: PPUSH
66022: LD_EXP 63
66026: PUSH
66027: LD_VAR 0 2
66031: ARRAY
66032: PUSH
66033: LD_INT 1
66035: ARRAY
66036: PUSH
66037: LD_INT 1
66039: ARRAY
66040: PPUSH
66041: LD_EXP 63
66045: PUSH
66046: LD_VAR 0 2
66050: ARRAY
66051: PUSH
66052: LD_INT 1
66054: ARRAY
66055: PUSH
66056: LD_INT 2
66058: ARRAY
66059: PPUSH
66060: LD_EXP 63
66064: PUSH
66065: LD_VAR 0 2
66069: ARRAY
66070: PUSH
66071: LD_INT 1
66073: ARRAY
66074: PUSH
66075: LD_INT 3
66077: ARRAY
66078: PPUSH
66079: LD_EXP 63
66083: PUSH
66084: LD_VAR 0 2
66088: ARRAY
66089: PUSH
66090: LD_INT 1
66092: ARRAY
66093: PUSH
66094: LD_INT 4
66096: ARRAY
66097: PPUSH
66098: CALL_OW 145
// end ;
66102: GO 65891
66104: POP
66105: POP
// end else
66106: GO 66250
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
66108: LD_EXP 58
66112: PUSH
66113: LD_VAR 0 2
66117: ARRAY
66118: PPUSH
66119: LD_EXP 63
66123: PUSH
66124: LD_VAR 0 2
66128: ARRAY
66129: PUSH
66130: LD_INT 1
66132: ARRAY
66133: PUSH
66134: LD_INT 1
66136: ARRAY
66137: PPUSH
66138: LD_EXP 63
66142: PUSH
66143: LD_VAR 0 2
66147: ARRAY
66148: PUSH
66149: LD_INT 1
66151: ARRAY
66152: PUSH
66153: LD_INT 2
66155: ARRAY
66156: PPUSH
66157: LD_EXP 63
66161: PUSH
66162: LD_VAR 0 2
66166: ARRAY
66167: PUSH
66168: LD_INT 1
66170: ARRAY
66171: PUSH
66172: LD_INT 3
66174: ARRAY
66175: PPUSH
66176: LD_EXP 63
66180: PUSH
66181: LD_VAR 0 2
66185: ARRAY
66186: PUSH
66187: LD_INT 1
66189: ARRAY
66190: PUSH
66191: LD_INT 4
66193: ARRAY
66194: PPUSH
66195: CALL 27248 0 5
66199: NOT
66200: IFFALSE 66250
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66202: LD_ADDR_EXP 63
66206: PUSH
66207: LD_EXP 63
66211: PPUSH
66212: LD_VAR 0 2
66216: PPUSH
66217: LD_EXP 63
66221: PUSH
66222: LD_VAR 0 2
66226: ARRAY
66227: PPUSH
66228: LD_INT 1
66230: PPUSH
66231: LD_INT 1
66233: NEG
66234: PPUSH
66235: LD_INT 0
66237: PPUSH
66238: CALL 19915 0 4
66242: PPUSH
66243: CALL_OW 1
66247: ST_TO_ADDR
// continue ;
66248: GO 65126
// end ; end ; end ;
66250: GO 65126
66252: POP
66253: POP
// end ;
66254: LD_VAR 0 1
66258: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66259: LD_INT 0
66261: PPUSH
66262: PPUSH
66263: PPUSH
66264: PPUSH
66265: PPUSH
66266: PPUSH
// if not mc_bases then
66267: LD_EXP 58
66271: NOT
66272: IFFALSE 66276
// exit ;
66274: GO 66703
// for i = 1 to mc_bases do
66276: LD_ADDR_VAR 0 2
66280: PUSH
66281: DOUBLE
66282: LD_INT 1
66284: DEC
66285: ST_TO_ADDR
66286: LD_EXP 58
66290: PUSH
66291: FOR_TO
66292: IFFALSE 66701
// begin tmp := mc_build_upgrade [ i ] ;
66294: LD_ADDR_VAR 0 4
66298: PUSH
66299: LD_EXP 90
66303: PUSH
66304: LD_VAR 0 2
66308: ARRAY
66309: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66310: LD_ADDR_VAR 0 6
66314: PUSH
66315: LD_EXP 91
66319: PUSH
66320: LD_VAR 0 2
66324: ARRAY
66325: PPUSH
66326: LD_INT 2
66328: PUSH
66329: LD_INT 30
66331: PUSH
66332: LD_INT 6
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: LD_INT 30
66341: PUSH
66342: LD_INT 7
66344: PUSH
66345: EMPTY
66346: LIST
66347: LIST
66348: PUSH
66349: EMPTY
66350: LIST
66351: LIST
66352: LIST
66353: PPUSH
66354: CALL_OW 72
66358: ST_TO_ADDR
// if not tmp and not lab then
66359: LD_VAR 0 4
66363: NOT
66364: PUSH
66365: LD_VAR 0 6
66369: NOT
66370: AND
66371: IFFALSE 66375
// continue ;
66373: GO 66291
// if tmp then
66375: LD_VAR 0 4
66379: IFFALSE 66499
// for j in tmp do
66381: LD_ADDR_VAR 0 3
66385: PUSH
66386: LD_VAR 0 4
66390: PUSH
66391: FOR_IN
66392: IFFALSE 66497
// begin if UpgradeCost ( j ) then
66394: LD_VAR 0 3
66398: PPUSH
66399: CALL 26908 0 1
66403: IFFALSE 66495
// begin ComUpgrade ( j ) ;
66405: LD_VAR 0 3
66409: PPUSH
66410: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66414: LD_ADDR_EXP 90
66418: PUSH
66419: LD_EXP 90
66423: PPUSH
66424: LD_VAR 0 2
66428: PPUSH
66429: LD_EXP 90
66433: PUSH
66434: LD_VAR 0 2
66438: ARRAY
66439: PUSH
66440: LD_VAR 0 3
66444: DIFF
66445: PPUSH
66446: CALL_OW 1
66450: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66451: LD_ADDR_EXP 65
66455: PUSH
66456: LD_EXP 65
66460: PPUSH
66461: LD_VAR 0 2
66465: PUSH
66466: LD_EXP 65
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: PUSH
66477: LD_INT 1
66479: PLUS
66480: PUSH
66481: EMPTY
66482: LIST
66483: LIST
66484: PPUSH
66485: LD_VAR 0 3
66489: PPUSH
66490: CALL 20497 0 3
66494: ST_TO_ADDR
// end ; end ;
66495: GO 66391
66497: POP
66498: POP
// if not lab or not mc_lab_upgrade [ i ] then
66499: LD_VAR 0 6
66503: NOT
66504: PUSH
66505: LD_EXP 92
66509: PUSH
66510: LD_VAR 0 2
66514: ARRAY
66515: NOT
66516: OR
66517: IFFALSE 66521
// continue ;
66519: GO 66291
// for j in lab do
66521: LD_ADDR_VAR 0 3
66525: PUSH
66526: LD_VAR 0 6
66530: PUSH
66531: FOR_IN
66532: IFFALSE 66697
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66534: LD_VAR 0 3
66538: PPUSH
66539: CALL_OW 266
66543: PUSH
66544: LD_INT 6
66546: PUSH
66547: LD_INT 7
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: IN
66554: PUSH
66555: LD_VAR 0 3
66559: PPUSH
66560: CALL_OW 461
66564: PUSH
66565: LD_INT 1
66567: NONEQUAL
66568: AND
66569: IFFALSE 66695
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66571: LD_VAR 0 3
66575: PPUSH
66576: LD_EXP 92
66580: PUSH
66581: LD_VAR 0 2
66585: ARRAY
66586: PUSH
66587: LD_INT 1
66589: ARRAY
66590: PPUSH
66591: CALL 27113 0 2
66595: IFFALSE 66695
// begin ComCancel ( j ) ;
66597: LD_VAR 0 3
66601: PPUSH
66602: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66606: LD_VAR 0 3
66610: PPUSH
66611: LD_EXP 92
66615: PUSH
66616: LD_VAR 0 2
66620: ARRAY
66621: PUSH
66622: LD_INT 1
66624: ARRAY
66625: PPUSH
66626: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66630: LD_VAR 0 3
66634: PUSH
66635: LD_EXP 65
66639: PUSH
66640: LD_VAR 0 2
66644: ARRAY
66645: IN
66646: NOT
66647: IFFALSE 66693
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66649: LD_ADDR_EXP 65
66653: PUSH
66654: LD_EXP 65
66658: PPUSH
66659: LD_VAR 0 2
66663: PUSH
66664: LD_EXP 65
66668: PUSH
66669: LD_VAR 0 2
66673: ARRAY
66674: PUSH
66675: LD_INT 1
66677: PLUS
66678: PUSH
66679: EMPTY
66680: LIST
66681: LIST
66682: PPUSH
66683: LD_VAR 0 3
66687: PPUSH
66688: CALL 20497 0 3
66692: ST_TO_ADDR
// break ;
66693: GO 66697
// end ; end ; end ;
66695: GO 66531
66697: POP
66698: POP
// end ;
66699: GO 66291
66701: POP
66702: POP
// end ;
66703: LD_VAR 0 1
66707: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66708: LD_INT 0
66710: PPUSH
66711: PPUSH
66712: PPUSH
66713: PPUSH
66714: PPUSH
66715: PPUSH
66716: PPUSH
66717: PPUSH
66718: PPUSH
// if not mc_bases then
66719: LD_EXP 58
66723: NOT
66724: IFFALSE 66728
// exit ;
66726: GO 67133
// for i = 1 to mc_bases do
66728: LD_ADDR_VAR 0 2
66732: PUSH
66733: DOUBLE
66734: LD_INT 1
66736: DEC
66737: ST_TO_ADDR
66738: LD_EXP 58
66742: PUSH
66743: FOR_TO
66744: IFFALSE 67131
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66746: LD_EXP 66
66750: PUSH
66751: LD_VAR 0 2
66755: ARRAY
66756: NOT
66757: PUSH
66758: LD_EXP 58
66762: PUSH
66763: LD_VAR 0 2
66767: ARRAY
66768: PPUSH
66769: LD_INT 30
66771: PUSH
66772: LD_INT 3
66774: PUSH
66775: EMPTY
66776: LIST
66777: LIST
66778: PPUSH
66779: CALL_OW 72
66783: NOT
66784: OR
66785: IFFALSE 66789
// continue ;
66787: GO 66743
// busy := false ;
66789: LD_ADDR_VAR 0 8
66793: PUSH
66794: LD_INT 0
66796: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66797: LD_ADDR_VAR 0 4
66801: PUSH
66802: LD_EXP 58
66806: PUSH
66807: LD_VAR 0 2
66811: ARRAY
66812: PPUSH
66813: LD_INT 30
66815: PUSH
66816: LD_INT 3
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PPUSH
66823: CALL_OW 72
66827: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66828: LD_ADDR_VAR 0 6
66832: PUSH
66833: LD_EXP 66
66837: PUSH
66838: LD_VAR 0 2
66842: ARRAY
66843: PPUSH
66844: LD_INT 2
66846: PUSH
66847: LD_INT 30
66849: PUSH
66850: LD_INT 32
66852: PUSH
66853: EMPTY
66854: LIST
66855: LIST
66856: PUSH
66857: LD_INT 30
66859: PUSH
66860: LD_INT 33
66862: PUSH
66863: EMPTY
66864: LIST
66865: LIST
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: LIST
66871: PPUSH
66872: CALL_OW 72
66876: ST_TO_ADDR
// if not t then
66877: LD_VAR 0 6
66881: NOT
66882: IFFALSE 66886
// continue ;
66884: GO 66743
// for j in tmp do
66886: LD_ADDR_VAR 0 3
66890: PUSH
66891: LD_VAR 0 4
66895: PUSH
66896: FOR_IN
66897: IFFALSE 66927
// if not BuildingStatus ( j ) = bs_idle then
66899: LD_VAR 0 3
66903: PPUSH
66904: CALL_OW 461
66908: PUSH
66909: LD_INT 2
66911: EQUAL
66912: NOT
66913: IFFALSE 66925
// begin busy := true ;
66915: LD_ADDR_VAR 0 8
66919: PUSH
66920: LD_INT 1
66922: ST_TO_ADDR
// break ;
66923: GO 66927
// end ;
66925: GO 66896
66927: POP
66928: POP
// if busy then
66929: LD_VAR 0 8
66933: IFFALSE 66937
// continue ;
66935: GO 66743
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66937: LD_ADDR_VAR 0 7
66941: PUSH
66942: LD_VAR 0 6
66946: PPUSH
66947: LD_INT 35
66949: PUSH
66950: LD_INT 0
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PPUSH
66957: CALL_OW 72
66961: ST_TO_ADDR
// if tw then
66962: LD_VAR 0 7
66966: IFFALSE 67043
// begin tw := tw [ 1 ] ;
66968: LD_ADDR_VAR 0 7
66972: PUSH
66973: LD_VAR 0 7
66977: PUSH
66978: LD_INT 1
66980: ARRAY
66981: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66982: LD_ADDR_VAR 0 9
66986: PUSH
66987: LD_VAR 0 7
66991: PPUSH
66992: LD_EXP 83
66996: PUSH
66997: LD_VAR 0 2
67001: ARRAY
67002: PPUSH
67003: CALL 25467 0 2
67007: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67008: LD_EXP 97
67012: PUSH
67013: LD_VAR 0 2
67017: ARRAY
67018: IFFALSE 67041
// if not weapon in mc_allowed_tower_weapons [ i ] then
67020: LD_VAR 0 9
67024: PUSH
67025: LD_EXP 97
67029: PUSH
67030: LD_VAR 0 2
67034: ARRAY
67035: IN
67036: NOT
67037: IFFALSE 67041
// continue ;
67039: GO 66743
// end else
67041: GO 67106
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67043: LD_ADDR_VAR 0 5
67047: PUSH
67048: LD_EXP 66
67052: PUSH
67053: LD_VAR 0 2
67057: ARRAY
67058: PPUSH
67059: LD_VAR 0 4
67063: PPUSH
67064: CALL 55606 0 2
67068: ST_TO_ADDR
// if not tmp2 then
67069: LD_VAR 0 5
67073: NOT
67074: IFFALSE 67078
// continue ;
67076: GO 66743
// tw := tmp2 [ 1 ] ;
67078: LD_ADDR_VAR 0 7
67082: PUSH
67083: LD_VAR 0 5
67087: PUSH
67088: LD_INT 1
67090: ARRAY
67091: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67092: LD_ADDR_VAR 0 9
67096: PUSH
67097: LD_VAR 0 5
67101: PUSH
67102: LD_INT 2
67104: ARRAY
67105: ST_TO_ADDR
// end ; if not weapon then
67106: LD_VAR 0 9
67110: NOT
67111: IFFALSE 67115
// continue ;
67113: GO 66743
// ComPlaceWeapon ( tw , weapon ) ;
67115: LD_VAR 0 7
67119: PPUSH
67120: LD_VAR 0 9
67124: PPUSH
67125: CALL_OW 148
// end ;
67129: GO 66743
67131: POP
67132: POP
// end ;
67133: LD_VAR 0 1
67137: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
67138: LD_INT 0
67140: PPUSH
67141: PPUSH
67142: PPUSH
67143: PPUSH
67144: PPUSH
67145: PPUSH
// if not mc_bases then
67146: LD_EXP 58
67150: NOT
67151: IFFALSE 67155
// exit ;
67153: GO 68167
// for i = 1 to mc_bases do
67155: LD_ADDR_VAR 0 2
67159: PUSH
67160: DOUBLE
67161: LD_INT 1
67163: DEC
67164: ST_TO_ADDR
67165: LD_EXP 58
67169: PUSH
67170: FOR_TO
67171: IFFALSE 68165
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
67173: LD_EXP 71
67177: PUSH
67178: LD_VAR 0 2
67182: ARRAY
67183: NOT
67184: PUSH
67185: LD_EXP 71
67189: PUSH
67190: LD_VAR 0 2
67194: ARRAY
67195: PUSH
67196: LD_EXP 72
67200: PUSH
67201: LD_VAR 0 2
67205: ARRAY
67206: EQUAL
67207: OR
67208: IFFALSE 67212
// continue ;
67210: GO 67170
// if mc_miners [ i ] then
67212: LD_EXP 72
67216: PUSH
67217: LD_VAR 0 2
67221: ARRAY
67222: IFFALSE 67852
// begin k := 1 ;
67224: LD_ADDR_VAR 0 4
67228: PUSH
67229: LD_INT 1
67231: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
67232: LD_ADDR_VAR 0 3
67236: PUSH
67237: DOUBLE
67238: LD_EXP 72
67242: PUSH
67243: LD_VAR 0 2
67247: ARRAY
67248: INC
67249: ST_TO_ADDR
67250: LD_INT 1
67252: PUSH
67253: FOR_DOWNTO
67254: IFFALSE 67850
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67256: LD_EXP 72
67260: PUSH
67261: LD_VAR 0 2
67265: ARRAY
67266: PUSH
67267: LD_VAR 0 3
67271: ARRAY
67272: PPUSH
67273: CALL_OW 301
67277: PUSH
67278: LD_EXP 72
67282: PUSH
67283: LD_VAR 0 2
67287: ARRAY
67288: PUSH
67289: LD_VAR 0 3
67293: ARRAY
67294: PPUSH
67295: CALL_OW 257
67299: PUSH
67300: LD_INT 1
67302: NONEQUAL
67303: OR
67304: IFFALSE 67367
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67306: LD_ADDR_VAR 0 5
67310: PUSH
67311: LD_EXP 72
67315: PUSH
67316: LD_VAR 0 2
67320: ARRAY
67321: PUSH
67322: LD_EXP 72
67326: PUSH
67327: LD_VAR 0 2
67331: ARRAY
67332: PUSH
67333: LD_VAR 0 3
67337: ARRAY
67338: DIFF
67339: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67340: LD_ADDR_EXP 72
67344: PUSH
67345: LD_EXP 72
67349: PPUSH
67350: LD_VAR 0 2
67354: PPUSH
67355: LD_VAR 0 5
67359: PPUSH
67360: CALL_OW 1
67364: ST_TO_ADDR
// continue ;
67365: GO 67253
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
67367: LD_EXP 72
67371: PUSH
67372: LD_VAR 0 2
67376: ARRAY
67377: PUSH
67378: LD_VAR 0 3
67382: ARRAY
67383: PPUSH
67384: CALL 20433 0 1
67388: PUSH
67389: LD_EXP 72
67393: PUSH
67394: LD_VAR 0 2
67398: ARRAY
67399: PUSH
67400: LD_VAR 0 3
67404: ARRAY
67405: PPUSH
67406: CALL_OW 255
67410: PPUSH
67411: LD_EXP 71
67415: PUSH
67416: LD_VAR 0 2
67420: ARRAY
67421: PUSH
67422: LD_VAR 0 4
67426: ARRAY
67427: PUSH
67428: LD_INT 1
67430: ARRAY
67431: PPUSH
67432: LD_EXP 71
67436: PUSH
67437: LD_VAR 0 2
67441: ARRAY
67442: PUSH
67443: LD_VAR 0 4
67447: ARRAY
67448: PUSH
67449: LD_INT 2
67451: ARRAY
67452: PPUSH
67453: LD_INT 15
67455: PPUSH
67456: CALL 21393 0 4
67460: PUSH
67461: LD_INT 4
67463: ARRAY
67464: PUSH
67465: LD_EXP 72
67469: PUSH
67470: LD_VAR 0 2
67474: ARRAY
67475: PUSH
67476: LD_VAR 0 3
67480: ARRAY
67481: PPUSH
67482: LD_INT 10
67484: PPUSH
67485: CALL 23090 0 2
67489: PUSH
67490: LD_INT 4
67492: ARRAY
67493: OR
67494: AND
67495: IFFALSE 67518
// ComStop ( mc_miners [ i ] [ j ] ) ;
67497: LD_EXP 72
67501: PUSH
67502: LD_VAR 0 2
67506: ARRAY
67507: PUSH
67508: LD_VAR 0 3
67512: ARRAY
67513: PPUSH
67514: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
67518: LD_EXP 72
67522: PUSH
67523: LD_VAR 0 2
67527: ARRAY
67528: PUSH
67529: LD_VAR 0 3
67533: ARRAY
67534: PPUSH
67535: CALL_OW 257
67539: PUSH
67540: LD_INT 1
67542: EQUAL
67543: PUSH
67544: LD_EXP 72
67548: PUSH
67549: LD_VAR 0 2
67553: ARRAY
67554: PUSH
67555: LD_VAR 0 3
67559: ARRAY
67560: PPUSH
67561: CALL_OW 459
67565: NOT
67566: AND
67567: PUSH
67568: LD_EXP 72
67572: PUSH
67573: LD_VAR 0 2
67577: ARRAY
67578: PUSH
67579: LD_VAR 0 3
67583: ARRAY
67584: PPUSH
67585: CALL_OW 255
67589: PPUSH
67590: LD_EXP 71
67594: PUSH
67595: LD_VAR 0 2
67599: ARRAY
67600: PUSH
67601: LD_VAR 0 4
67605: ARRAY
67606: PUSH
67607: LD_INT 1
67609: ARRAY
67610: PPUSH
67611: LD_EXP 71
67615: PUSH
67616: LD_VAR 0 2
67620: ARRAY
67621: PUSH
67622: LD_VAR 0 4
67626: ARRAY
67627: PUSH
67628: LD_INT 2
67630: ARRAY
67631: PPUSH
67632: LD_INT 15
67634: PPUSH
67635: CALL 21393 0 4
67639: PUSH
67640: LD_INT 4
67642: ARRAY
67643: PUSH
67644: LD_INT 0
67646: EQUAL
67647: AND
67648: PUSH
67649: LD_EXP 72
67653: PUSH
67654: LD_VAR 0 2
67658: ARRAY
67659: PUSH
67660: LD_VAR 0 3
67664: ARRAY
67665: PPUSH
67666: CALL_OW 314
67670: NOT
67671: AND
67672: IFFALSE 67848
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67674: LD_EXP 72
67678: PUSH
67679: LD_VAR 0 2
67683: ARRAY
67684: PUSH
67685: LD_VAR 0 3
67689: ARRAY
67690: PPUSH
67691: CALL_OW 310
67695: IFFALSE 67718
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67697: LD_EXP 72
67701: PUSH
67702: LD_VAR 0 2
67706: ARRAY
67707: PUSH
67708: LD_VAR 0 3
67712: ARRAY
67713: PPUSH
67714: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67718: LD_EXP 72
67722: PUSH
67723: LD_VAR 0 2
67727: ARRAY
67728: PUSH
67729: LD_VAR 0 3
67733: ARRAY
67734: PPUSH
67735: CALL_OW 314
67739: NOT
67740: IFFALSE 67808
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
67742: LD_EXP 72
67746: PUSH
67747: LD_VAR 0 2
67751: ARRAY
67752: PUSH
67753: LD_VAR 0 3
67757: ARRAY
67758: PPUSH
67759: LD_EXP 71
67763: PUSH
67764: LD_VAR 0 2
67768: ARRAY
67769: PUSH
67770: LD_VAR 0 4
67774: ARRAY
67775: PUSH
67776: LD_INT 1
67778: ARRAY
67779: PPUSH
67780: LD_EXP 71
67784: PUSH
67785: LD_VAR 0 2
67789: ARRAY
67790: PUSH
67791: LD_VAR 0 4
67795: ARRAY
67796: PUSH
67797: LD_INT 2
67799: ARRAY
67800: PPUSH
67801: LD_INT 0
67803: PPUSH
67804: CALL_OW 193
// k := k + 1 ;
67808: LD_ADDR_VAR 0 4
67812: PUSH
67813: LD_VAR 0 4
67817: PUSH
67818: LD_INT 1
67820: PLUS
67821: ST_TO_ADDR
// if k > mc_mines [ i ] then
67822: LD_VAR 0 4
67826: PUSH
67827: LD_EXP 71
67831: PUSH
67832: LD_VAR 0 2
67836: ARRAY
67837: GREATER
67838: IFFALSE 67848
// k := 1 ;
67840: LD_ADDR_VAR 0 4
67844: PUSH
67845: LD_INT 1
67847: ST_TO_ADDR
// end ; end ;
67848: GO 67253
67850: POP
67851: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67852: LD_ADDR_VAR 0 5
67856: PUSH
67857: LD_EXP 58
67861: PUSH
67862: LD_VAR 0 2
67866: ARRAY
67867: PPUSH
67868: LD_INT 2
67870: PUSH
67871: LD_INT 30
67873: PUSH
67874: LD_INT 4
67876: PUSH
67877: EMPTY
67878: LIST
67879: LIST
67880: PUSH
67881: LD_INT 30
67883: PUSH
67884: LD_INT 5
67886: PUSH
67887: EMPTY
67888: LIST
67889: LIST
67890: PUSH
67891: LD_INT 30
67893: PUSH
67894: LD_INT 32
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: LIST
67905: LIST
67906: PPUSH
67907: CALL_OW 72
67911: ST_TO_ADDR
// if not tmp then
67912: LD_VAR 0 5
67916: NOT
67917: IFFALSE 67921
// continue ;
67919: GO 67170
// list := [ ] ;
67921: LD_ADDR_VAR 0 6
67925: PUSH
67926: EMPTY
67927: ST_TO_ADDR
// for j in tmp do
67928: LD_ADDR_VAR 0 3
67932: PUSH
67933: LD_VAR 0 5
67937: PUSH
67938: FOR_IN
67939: IFFALSE 68008
// begin for k in UnitsInside ( j ) do
67941: LD_ADDR_VAR 0 4
67945: PUSH
67946: LD_VAR 0 3
67950: PPUSH
67951: CALL_OW 313
67955: PUSH
67956: FOR_IN
67957: IFFALSE 68004
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67959: LD_VAR 0 4
67963: PPUSH
67964: CALL_OW 257
67968: PUSH
67969: LD_INT 1
67971: EQUAL
67972: PUSH
67973: LD_VAR 0 4
67977: PPUSH
67978: CALL_OW 459
67982: NOT
67983: AND
67984: IFFALSE 68002
// list := list ^ k ;
67986: LD_ADDR_VAR 0 6
67990: PUSH
67991: LD_VAR 0 6
67995: PUSH
67996: LD_VAR 0 4
68000: ADD
68001: ST_TO_ADDR
68002: GO 67956
68004: POP
68005: POP
// end ;
68006: GO 67938
68008: POP
68009: POP
// list := list diff mc_miners [ i ] ;
68010: LD_ADDR_VAR 0 6
68014: PUSH
68015: LD_VAR 0 6
68019: PUSH
68020: LD_EXP 72
68024: PUSH
68025: LD_VAR 0 2
68029: ARRAY
68030: DIFF
68031: ST_TO_ADDR
// if not list then
68032: LD_VAR 0 6
68036: NOT
68037: IFFALSE 68041
// continue ;
68039: GO 67170
// k := mc_mines [ i ] - mc_miners [ i ] ;
68041: LD_ADDR_VAR 0 4
68045: PUSH
68046: LD_EXP 71
68050: PUSH
68051: LD_VAR 0 2
68055: ARRAY
68056: PUSH
68057: LD_EXP 72
68061: PUSH
68062: LD_VAR 0 2
68066: ARRAY
68067: MINUS
68068: ST_TO_ADDR
// if k > list then
68069: LD_VAR 0 4
68073: PUSH
68074: LD_VAR 0 6
68078: GREATER
68079: IFFALSE 68091
// k := list ;
68081: LD_ADDR_VAR 0 4
68085: PUSH
68086: LD_VAR 0 6
68090: ST_TO_ADDR
// for j = 1 to k do
68091: LD_ADDR_VAR 0 3
68095: PUSH
68096: DOUBLE
68097: LD_INT 1
68099: DEC
68100: ST_TO_ADDR
68101: LD_VAR 0 4
68105: PUSH
68106: FOR_TO
68107: IFFALSE 68161
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68109: LD_ADDR_EXP 72
68113: PUSH
68114: LD_EXP 72
68118: PPUSH
68119: LD_VAR 0 2
68123: PUSH
68124: LD_EXP 72
68128: PUSH
68129: LD_VAR 0 2
68133: ARRAY
68134: PUSH
68135: LD_INT 1
68137: PLUS
68138: PUSH
68139: EMPTY
68140: LIST
68141: LIST
68142: PPUSH
68143: LD_VAR 0 6
68147: PUSH
68148: LD_VAR 0 3
68152: ARRAY
68153: PPUSH
68154: CALL 20497 0 3
68158: ST_TO_ADDR
68159: GO 68106
68161: POP
68162: POP
// end ;
68163: GO 67170
68165: POP
68166: POP
// end ;
68167: LD_VAR 0 1
68171: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
68172: LD_INT 0
68174: PPUSH
68175: PPUSH
68176: PPUSH
68177: PPUSH
68178: PPUSH
68179: PPUSH
68180: PPUSH
68181: PPUSH
68182: PPUSH
68183: PPUSH
// if not mc_bases then
68184: LD_EXP 58
68188: NOT
68189: IFFALSE 68193
// exit ;
68191: GO 69924
// for i = 1 to mc_bases do
68193: LD_ADDR_VAR 0 2
68197: PUSH
68198: DOUBLE
68199: LD_INT 1
68201: DEC
68202: ST_TO_ADDR
68203: LD_EXP 58
68207: PUSH
68208: FOR_TO
68209: IFFALSE 69922
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68211: LD_EXP 58
68215: PUSH
68216: LD_VAR 0 2
68220: ARRAY
68221: NOT
68222: PUSH
68223: LD_EXP 65
68227: PUSH
68228: LD_VAR 0 2
68232: ARRAY
68233: OR
68234: IFFALSE 68238
// continue ;
68236: GO 68208
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68238: LD_EXP 74
68242: PUSH
68243: LD_VAR 0 2
68247: ARRAY
68248: NOT
68249: PUSH
68250: LD_EXP 75
68254: PUSH
68255: LD_VAR 0 2
68259: ARRAY
68260: AND
68261: IFFALSE 68299
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68263: LD_ADDR_EXP 75
68267: PUSH
68268: LD_EXP 75
68272: PPUSH
68273: LD_VAR 0 2
68277: PPUSH
68278: EMPTY
68279: PPUSH
68280: CALL_OW 1
68284: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68285: LD_VAR 0 2
68289: PPUSH
68290: LD_INT 107
68292: PPUSH
68293: CALL 59388 0 2
// continue ;
68297: GO 68208
// end ; target := [ ] ;
68299: LD_ADDR_VAR 0 6
68303: PUSH
68304: EMPTY
68305: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68306: LD_ADDR_VAR 0 3
68310: PUSH
68311: DOUBLE
68312: LD_EXP 74
68316: PUSH
68317: LD_VAR 0 2
68321: ARRAY
68322: INC
68323: ST_TO_ADDR
68324: LD_INT 1
68326: PUSH
68327: FOR_DOWNTO
68328: IFFALSE 68588
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68330: LD_EXP 74
68334: PUSH
68335: LD_VAR 0 2
68339: ARRAY
68340: PUSH
68341: LD_VAR 0 3
68345: ARRAY
68346: PUSH
68347: LD_INT 2
68349: ARRAY
68350: PPUSH
68351: LD_EXP 74
68355: PUSH
68356: LD_VAR 0 2
68360: ARRAY
68361: PUSH
68362: LD_VAR 0 3
68366: ARRAY
68367: PUSH
68368: LD_INT 3
68370: ARRAY
68371: PPUSH
68372: CALL_OW 488
68376: PUSH
68377: LD_EXP 74
68381: PUSH
68382: LD_VAR 0 2
68386: ARRAY
68387: PUSH
68388: LD_VAR 0 3
68392: ARRAY
68393: PUSH
68394: LD_INT 2
68396: ARRAY
68397: PPUSH
68398: LD_EXP 74
68402: PUSH
68403: LD_VAR 0 2
68407: ARRAY
68408: PUSH
68409: LD_VAR 0 3
68413: ARRAY
68414: PUSH
68415: LD_INT 3
68417: ARRAY
68418: PPUSH
68419: CALL_OW 284
68423: PUSH
68424: LD_INT 0
68426: EQUAL
68427: AND
68428: IFFALSE 68483
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68430: LD_ADDR_VAR 0 5
68434: PUSH
68435: LD_EXP 74
68439: PUSH
68440: LD_VAR 0 2
68444: ARRAY
68445: PPUSH
68446: LD_VAR 0 3
68450: PPUSH
68451: CALL_OW 3
68455: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68456: LD_ADDR_EXP 74
68460: PUSH
68461: LD_EXP 74
68465: PPUSH
68466: LD_VAR 0 2
68470: PPUSH
68471: LD_VAR 0 5
68475: PPUSH
68476: CALL_OW 1
68480: ST_TO_ADDR
// continue ;
68481: GO 68327
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68483: LD_EXP 58
68487: PUSH
68488: LD_VAR 0 2
68492: ARRAY
68493: PUSH
68494: LD_INT 1
68496: ARRAY
68497: PPUSH
68498: CALL_OW 255
68502: PPUSH
68503: LD_EXP 74
68507: PUSH
68508: LD_VAR 0 2
68512: ARRAY
68513: PUSH
68514: LD_VAR 0 3
68518: ARRAY
68519: PUSH
68520: LD_INT 2
68522: ARRAY
68523: PPUSH
68524: LD_EXP 74
68528: PUSH
68529: LD_VAR 0 2
68533: ARRAY
68534: PUSH
68535: LD_VAR 0 3
68539: ARRAY
68540: PUSH
68541: LD_INT 3
68543: ARRAY
68544: PPUSH
68545: LD_INT 30
68547: PPUSH
68548: CALL 21393 0 4
68552: PUSH
68553: LD_INT 4
68555: ARRAY
68556: PUSH
68557: LD_INT 0
68559: EQUAL
68560: IFFALSE 68586
// begin target := mc_crates [ i ] [ j ] ;
68562: LD_ADDR_VAR 0 6
68566: PUSH
68567: LD_EXP 74
68571: PUSH
68572: LD_VAR 0 2
68576: ARRAY
68577: PUSH
68578: LD_VAR 0 3
68582: ARRAY
68583: ST_TO_ADDR
// break ;
68584: GO 68588
// end ; end ;
68586: GO 68327
68588: POP
68589: POP
// if not target then
68590: LD_VAR 0 6
68594: NOT
68595: IFFALSE 68599
// continue ;
68597: GO 68208
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68599: LD_ADDR_VAR 0 7
68603: PUSH
68604: LD_EXP 77
68608: PUSH
68609: LD_VAR 0 2
68613: ARRAY
68614: PPUSH
68615: LD_INT 2
68617: PUSH
68618: LD_INT 3
68620: PUSH
68621: LD_INT 58
68623: PUSH
68624: EMPTY
68625: LIST
68626: PUSH
68627: EMPTY
68628: LIST
68629: LIST
68630: PUSH
68631: LD_INT 61
68633: PUSH
68634: EMPTY
68635: LIST
68636: PUSH
68637: LD_INT 33
68639: PUSH
68640: LD_INT 5
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: PUSH
68647: LD_INT 33
68649: PUSH
68650: LD_INT 3
68652: PUSH
68653: EMPTY
68654: LIST
68655: LIST
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: LIST
68661: LIST
68662: LIST
68663: PUSH
68664: LD_INT 2
68666: PUSH
68667: LD_INT 34
68669: PUSH
68670: LD_INT 32
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 34
68679: PUSH
68680: LD_INT 51
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PUSH
68687: LD_INT 34
68689: PUSH
68690: LD_INT 12
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: PPUSH
68707: CALL_OW 72
68711: ST_TO_ADDR
// if not cargo then
68712: LD_VAR 0 7
68716: NOT
68717: IFFALSE 69360
// begin if mc_crates_collector [ i ] < 5 then
68719: LD_EXP 75
68723: PUSH
68724: LD_VAR 0 2
68728: ARRAY
68729: PUSH
68730: LD_INT 5
68732: LESS
68733: IFFALSE 69099
// begin if mc_ape [ i ] then
68735: LD_EXP 87
68739: PUSH
68740: LD_VAR 0 2
68744: ARRAY
68745: IFFALSE 68792
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68747: LD_ADDR_VAR 0 5
68751: PUSH
68752: LD_EXP 87
68756: PUSH
68757: LD_VAR 0 2
68761: ARRAY
68762: PPUSH
68763: LD_INT 25
68765: PUSH
68766: LD_INT 16
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 24
68775: PUSH
68776: LD_INT 750
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: EMPTY
68784: LIST
68785: LIST
68786: PPUSH
68787: CALL_OW 72
68791: ST_TO_ADDR
// if not tmp then
68792: LD_VAR 0 5
68796: NOT
68797: IFFALSE 68844
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68799: LD_ADDR_VAR 0 5
68803: PUSH
68804: LD_EXP 58
68808: PUSH
68809: LD_VAR 0 2
68813: ARRAY
68814: PPUSH
68815: LD_INT 25
68817: PUSH
68818: LD_INT 2
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 24
68827: PUSH
68828: LD_INT 750
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PPUSH
68839: CALL_OW 72
68843: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68844: LD_EXP 87
68848: PUSH
68849: LD_VAR 0 2
68853: ARRAY
68854: PUSH
68855: LD_EXP 58
68859: PUSH
68860: LD_VAR 0 2
68864: ARRAY
68865: PPUSH
68866: LD_INT 25
68868: PUSH
68869: LD_INT 2
68871: PUSH
68872: EMPTY
68873: LIST
68874: LIST
68875: PUSH
68876: LD_INT 24
68878: PUSH
68879: LD_INT 750
68881: PUSH
68882: EMPTY
68883: LIST
68884: LIST
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PPUSH
68890: CALL_OW 72
68894: AND
68895: PUSH
68896: LD_VAR 0 5
68900: PUSH
68901: LD_INT 5
68903: LESS
68904: AND
68905: IFFALSE 68987
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68907: LD_ADDR_VAR 0 3
68911: PUSH
68912: LD_EXP 58
68916: PUSH
68917: LD_VAR 0 2
68921: ARRAY
68922: PPUSH
68923: LD_INT 25
68925: PUSH
68926: LD_INT 2
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 24
68935: PUSH
68936: LD_INT 750
68938: PUSH
68939: EMPTY
68940: LIST
68941: LIST
68942: PUSH
68943: EMPTY
68944: LIST
68945: LIST
68946: PPUSH
68947: CALL_OW 72
68951: PUSH
68952: FOR_IN
68953: IFFALSE 68985
// begin tmp := tmp union j ;
68955: LD_ADDR_VAR 0 5
68959: PUSH
68960: LD_VAR 0 5
68964: PUSH
68965: LD_VAR 0 3
68969: UNION
68970: ST_TO_ADDR
// if tmp >= 5 then
68971: LD_VAR 0 5
68975: PUSH
68976: LD_INT 5
68978: GREATEREQUAL
68979: IFFALSE 68983
// break ;
68981: GO 68985
// end ;
68983: GO 68952
68985: POP
68986: POP
// end ; if not tmp then
68987: LD_VAR 0 5
68991: NOT
68992: IFFALSE 68996
// continue ;
68994: GO 68208
// for j in tmp do
68996: LD_ADDR_VAR 0 3
69000: PUSH
69001: LD_VAR 0 5
69005: PUSH
69006: FOR_IN
69007: IFFALSE 69097
// if not GetTag ( j ) then
69009: LD_VAR 0 3
69013: PPUSH
69014: CALL_OW 110
69018: NOT
69019: IFFALSE 69095
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69021: LD_ADDR_EXP 75
69025: PUSH
69026: LD_EXP 75
69030: PPUSH
69031: LD_VAR 0 2
69035: PUSH
69036: LD_EXP 75
69040: PUSH
69041: LD_VAR 0 2
69045: ARRAY
69046: PUSH
69047: LD_INT 1
69049: PLUS
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PPUSH
69055: LD_VAR 0 3
69059: PPUSH
69060: CALL 20497 0 3
69064: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69065: LD_VAR 0 3
69069: PPUSH
69070: LD_INT 107
69072: PPUSH
69073: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69077: LD_EXP 75
69081: PUSH
69082: LD_VAR 0 2
69086: ARRAY
69087: PUSH
69088: LD_INT 5
69090: GREATEREQUAL
69091: IFFALSE 69095
// break ;
69093: GO 69097
// end ;
69095: GO 69006
69097: POP
69098: POP
// end ; if mc_crates_collector [ i ] and target then
69099: LD_EXP 75
69103: PUSH
69104: LD_VAR 0 2
69108: ARRAY
69109: PUSH
69110: LD_VAR 0 6
69114: AND
69115: IFFALSE 69358
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69117: LD_EXP 75
69121: PUSH
69122: LD_VAR 0 2
69126: ARRAY
69127: PUSH
69128: LD_VAR 0 6
69132: PUSH
69133: LD_INT 1
69135: ARRAY
69136: LESS
69137: IFFALSE 69157
// tmp := mc_crates_collector [ i ] else
69139: LD_ADDR_VAR 0 5
69143: PUSH
69144: LD_EXP 75
69148: PUSH
69149: LD_VAR 0 2
69153: ARRAY
69154: ST_TO_ADDR
69155: GO 69171
// tmp := target [ 1 ] ;
69157: LD_ADDR_VAR 0 5
69161: PUSH
69162: LD_VAR 0 6
69166: PUSH
69167: LD_INT 1
69169: ARRAY
69170: ST_TO_ADDR
// k := 0 ;
69171: LD_ADDR_VAR 0 4
69175: PUSH
69176: LD_INT 0
69178: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69179: LD_ADDR_VAR 0 3
69183: PUSH
69184: LD_EXP 75
69188: PUSH
69189: LD_VAR 0 2
69193: ARRAY
69194: PUSH
69195: FOR_IN
69196: IFFALSE 69356
// begin k := k + 1 ;
69198: LD_ADDR_VAR 0 4
69202: PUSH
69203: LD_VAR 0 4
69207: PUSH
69208: LD_INT 1
69210: PLUS
69211: ST_TO_ADDR
// if k > tmp then
69212: LD_VAR 0 4
69216: PUSH
69217: LD_VAR 0 5
69221: GREATER
69222: IFFALSE 69226
// break ;
69224: GO 69356
// if not GetClass ( j ) in [ 2 , 16 ] then
69226: LD_VAR 0 3
69230: PPUSH
69231: CALL_OW 257
69235: PUSH
69236: LD_INT 2
69238: PUSH
69239: LD_INT 16
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: IN
69246: NOT
69247: IFFALSE 69300
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69249: LD_ADDR_EXP 75
69253: PUSH
69254: LD_EXP 75
69258: PPUSH
69259: LD_VAR 0 2
69263: PPUSH
69264: LD_EXP 75
69268: PUSH
69269: LD_VAR 0 2
69273: ARRAY
69274: PUSH
69275: LD_VAR 0 3
69279: DIFF
69280: PPUSH
69281: CALL_OW 1
69285: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69286: LD_VAR 0 3
69290: PPUSH
69291: LD_INT 0
69293: PPUSH
69294: CALL_OW 109
// continue ;
69298: GO 69195
// end ; if IsInUnit ( j ) then
69300: LD_VAR 0 3
69304: PPUSH
69305: CALL_OW 310
69309: IFFALSE 69320
// ComExitBuilding ( j ) ;
69311: LD_VAR 0 3
69315: PPUSH
69316: CALL_OW 122
// wait ( 3 ) ;
69320: LD_INT 3
69322: PPUSH
69323: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69327: LD_VAR 0 3
69331: PPUSH
69332: LD_VAR 0 6
69336: PUSH
69337: LD_INT 2
69339: ARRAY
69340: PPUSH
69341: LD_VAR 0 6
69345: PUSH
69346: LD_INT 3
69348: ARRAY
69349: PPUSH
69350: CALL_OW 117
// end ;
69354: GO 69195
69356: POP
69357: POP
// end ; end else
69358: GO 69920
// begin for j in cargo do
69360: LD_ADDR_VAR 0 3
69364: PUSH
69365: LD_VAR 0 7
69369: PUSH
69370: FOR_IN
69371: IFFALSE 69918
// begin if GetTag ( j ) <> 0 then
69373: LD_VAR 0 3
69377: PPUSH
69378: CALL_OW 110
69382: PUSH
69383: LD_INT 0
69385: NONEQUAL
69386: IFFALSE 69390
// continue ;
69388: GO 69370
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69390: LD_VAR 0 3
69394: PPUSH
69395: CALL_OW 256
69399: PUSH
69400: LD_INT 1000
69402: LESS
69403: PUSH
69404: LD_VAR 0 3
69408: PPUSH
69409: LD_EXP 82
69413: PUSH
69414: LD_VAR 0 2
69418: ARRAY
69419: PPUSH
69420: CALL_OW 308
69424: NOT
69425: AND
69426: IFFALSE 69448
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69428: LD_VAR 0 3
69432: PPUSH
69433: LD_EXP 82
69437: PUSH
69438: LD_VAR 0 2
69442: ARRAY
69443: PPUSH
69444: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69448: LD_VAR 0 3
69452: PPUSH
69453: CALL_OW 256
69457: PUSH
69458: LD_INT 1000
69460: LESS
69461: PUSH
69462: LD_VAR 0 3
69466: PPUSH
69467: LD_EXP 82
69471: PUSH
69472: LD_VAR 0 2
69476: ARRAY
69477: PPUSH
69478: CALL_OW 308
69482: AND
69483: IFFALSE 69487
// continue ;
69485: GO 69370
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69487: LD_VAR 0 3
69491: PPUSH
69492: CALL_OW 262
69496: PUSH
69497: LD_INT 2
69499: EQUAL
69500: PUSH
69501: LD_VAR 0 3
69505: PPUSH
69506: CALL_OW 261
69510: PUSH
69511: LD_INT 15
69513: LESS
69514: AND
69515: IFFALSE 69519
// continue ;
69517: GO 69370
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69519: LD_VAR 0 3
69523: PPUSH
69524: CALL_OW 262
69528: PUSH
69529: LD_INT 1
69531: EQUAL
69532: PUSH
69533: LD_VAR 0 3
69537: PPUSH
69538: CALL_OW 261
69542: PUSH
69543: LD_INT 10
69545: LESS
69546: AND
69547: IFFALSE 69857
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69549: LD_ADDR_VAR 0 8
69553: PUSH
69554: LD_EXP 58
69558: PUSH
69559: LD_VAR 0 2
69563: ARRAY
69564: PPUSH
69565: LD_INT 2
69567: PUSH
69568: LD_INT 30
69570: PUSH
69571: LD_INT 0
69573: PUSH
69574: EMPTY
69575: LIST
69576: LIST
69577: PUSH
69578: LD_INT 30
69580: PUSH
69581: LD_INT 1
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: LIST
69592: PPUSH
69593: CALL_OW 72
69597: ST_TO_ADDR
// if not depot then
69598: LD_VAR 0 8
69602: NOT
69603: IFFALSE 69607
// continue ;
69605: GO 69370
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69607: LD_VAR 0 3
69611: PPUSH
69612: LD_VAR 0 8
69616: PPUSH
69617: LD_VAR 0 3
69621: PPUSH
69622: CALL_OW 74
69626: PPUSH
69627: CALL_OW 296
69631: PUSH
69632: LD_INT 6
69634: LESS
69635: IFFALSE 69651
// SetFuel ( j , 100 ) else
69637: LD_VAR 0 3
69641: PPUSH
69642: LD_INT 100
69644: PPUSH
69645: CALL_OW 240
69649: GO 69857
// if GetFuel ( j ) = 0 then
69651: LD_VAR 0 3
69655: PPUSH
69656: CALL_OW 261
69660: PUSH
69661: LD_INT 0
69663: EQUAL
69664: IFFALSE 69857
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69666: LD_ADDR_EXP 77
69670: PUSH
69671: LD_EXP 77
69675: PPUSH
69676: LD_VAR 0 2
69680: PPUSH
69681: LD_EXP 77
69685: PUSH
69686: LD_VAR 0 2
69690: ARRAY
69691: PUSH
69692: LD_VAR 0 3
69696: DIFF
69697: PPUSH
69698: CALL_OW 1
69702: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69703: LD_VAR 0 3
69707: PPUSH
69708: CALL_OW 263
69712: PUSH
69713: LD_INT 1
69715: EQUAL
69716: IFFALSE 69732
// ComExitVehicle ( IsInUnit ( j ) ) ;
69718: LD_VAR 0 3
69722: PPUSH
69723: CALL_OW 310
69727: PPUSH
69728: CALL_OW 121
// if GetControl ( j ) = control_remote then
69732: LD_VAR 0 3
69736: PPUSH
69737: CALL_OW 263
69741: PUSH
69742: LD_INT 2
69744: EQUAL
69745: IFFALSE 69756
// ComUnlink ( j ) ;
69747: LD_VAR 0 3
69751: PPUSH
69752: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
69756: LD_ADDR_VAR 0 9
69760: PUSH
69761: LD_VAR 0 2
69765: PPUSH
69766: LD_INT 3
69768: PPUSH
69769: CALL 78961 0 2
69773: ST_TO_ADDR
// if fac then
69774: LD_VAR 0 9
69778: IFFALSE 69855
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69780: LD_ADDR_VAR 0 10
69784: PUSH
69785: LD_VAR 0 9
69789: PPUSH
69790: LD_VAR 0 3
69794: PPUSH
69795: CALL_OW 265
69799: PPUSH
69800: LD_VAR 0 3
69804: PPUSH
69805: CALL_OW 262
69809: PPUSH
69810: LD_VAR 0 3
69814: PPUSH
69815: CALL_OW 263
69819: PPUSH
69820: LD_VAR 0 3
69824: PPUSH
69825: CALL_OW 264
69829: PPUSH
69830: CALL 18097 0 5
69834: ST_TO_ADDR
// if components then
69835: LD_VAR 0 10
69839: IFFALSE 69855
// MC_InsertProduceList ( i , components ) ;
69841: LD_VAR 0 2
69845: PPUSH
69846: LD_VAR 0 10
69850: PPUSH
69851: CALL 78589 0 2
// end ; continue ;
69855: GO 69370
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69857: LD_VAR 0 3
69861: PPUSH
69862: LD_INT 1
69864: PPUSH
69865: CALL_OW 289
69869: PUSH
69870: LD_INT 100
69872: LESS
69873: PUSH
69874: LD_VAR 0 3
69878: PPUSH
69879: CALL_OW 314
69883: NOT
69884: AND
69885: IFFALSE 69914
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69887: LD_VAR 0 3
69891: PPUSH
69892: LD_VAR 0 6
69896: PUSH
69897: LD_INT 2
69899: ARRAY
69900: PPUSH
69901: LD_VAR 0 6
69905: PUSH
69906: LD_INT 3
69908: ARRAY
69909: PPUSH
69910: CALL_OW 117
// break ;
69914: GO 69918
// end ;
69916: GO 69370
69918: POP
69919: POP
// end ; end ;
69920: GO 68208
69922: POP
69923: POP
// end ;
69924: LD_VAR 0 1
69928: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69929: LD_INT 0
69931: PPUSH
69932: PPUSH
69933: PPUSH
69934: PPUSH
// if not mc_bases then
69935: LD_EXP 58
69939: NOT
69940: IFFALSE 69944
// exit ;
69942: GO 70105
// for i = 1 to mc_bases do
69944: LD_ADDR_VAR 0 2
69948: PUSH
69949: DOUBLE
69950: LD_INT 1
69952: DEC
69953: ST_TO_ADDR
69954: LD_EXP 58
69958: PUSH
69959: FOR_TO
69960: IFFALSE 70103
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69962: LD_ADDR_VAR 0 4
69966: PUSH
69967: LD_EXP 77
69971: PUSH
69972: LD_VAR 0 2
69976: ARRAY
69977: PUSH
69978: LD_EXP 80
69982: PUSH
69983: LD_VAR 0 2
69987: ARRAY
69988: UNION
69989: PPUSH
69990: LD_INT 33
69992: PUSH
69993: LD_INT 2
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: PPUSH
70000: CALL_OW 72
70004: ST_TO_ADDR
// if tmp then
70005: LD_VAR 0 4
70009: IFFALSE 70101
// for j in tmp do
70011: LD_ADDR_VAR 0 3
70015: PUSH
70016: LD_VAR 0 4
70020: PUSH
70021: FOR_IN
70022: IFFALSE 70099
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70024: LD_VAR 0 3
70028: PPUSH
70029: CALL_OW 312
70033: NOT
70034: PUSH
70035: LD_VAR 0 3
70039: PPUSH
70040: CALL_OW 256
70044: PUSH
70045: LD_INT 250
70047: GREATEREQUAL
70048: AND
70049: IFFALSE 70062
// Connect ( j ) else
70051: LD_VAR 0 3
70055: PPUSH
70056: CALL 23430 0 1
70060: GO 70097
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70062: LD_VAR 0 3
70066: PPUSH
70067: CALL_OW 256
70071: PUSH
70072: LD_INT 250
70074: LESS
70075: PUSH
70076: LD_VAR 0 3
70080: PPUSH
70081: CALL_OW 312
70085: AND
70086: IFFALSE 70097
// ComUnlink ( j ) ;
70088: LD_VAR 0 3
70092: PPUSH
70093: CALL_OW 136
70097: GO 70021
70099: POP
70100: POP
// end ;
70101: GO 69959
70103: POP
70104: POP
// end ;
70105: LD_VAR 0 1
70109: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70110: LD_INT 0
70112: PPUSH
70113: PPUSH
70114: PPUSH
70115: PPUSH
70116: PPUSH
// if not mc_bases then
70117: LD_EXP 58
70121: NOT
70122: IFFALSE 70126
// exit ;
70124: GO 70586
// for i = 1 to mc_bases do
70126: LD_ADDR_VAR 0 2
70130: PUSH
70131: DOUBLE
70132: LD_INT 1
70134: DEC
70135: ST_TO_ADDR
70136: LD_EXP 58
70140: PUSH
70141: FOR_TO
70142: IFFALSE 70584
// begin if not mc_produce [ i ] then
70144: LD_EXP 79
70148: PUSH
70149: LD_VAR 0 2
70153: ARRAY
70154: NOT
70155: IFFALSE 70159
// continue ;
70157: GO 70141
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70159: LD_ADDR_VAR 0 5
70163: PUSH
70164: LD_EXP 58
70168: PUSH
70169: LD_VAR 0 2
70173: ARRAY
70174: PPUSH
70175: LD_INT 30
70177: PUSH
70178: LD_INT 3
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: PPUSH
70185: CALL_OW 72
70189: ST_TO_ADDR
// if not fac then
70190: LD_VAR 0 5
70194: NOT
70195: IFFALSE 70199
// continue ;
70197: GO 70141
// for j in fac do
70199: LD_ADDR_VAR 0 3
70203: PUSH
70204: LD_VAR 0 5
70208: PUSH
70209: FOR_IN
70210: IFFALSE 70580
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
70212: LD_VAR 0 3
70216: PPUSH
70217: CALL_OW 461
70221: PUSH
70222: LD_INT 2
70224: NONEQUAL
70225: PUSH
70226: LD_VAR 0 3
70230: PPUSH
70231: LD_INT 15
70233: PPUSH
70234: CALL 23090 0 2
70238: PUSH
70239: LD_INT 4
70241: ARRAY
70242: OR
70243: PUSH
70244: LD_VAR 0 3
70248: PPUSH
70249: CALL_OW 313
70253: PUSH
70254: LD_INT 0
70256: EQUAL
70257: OR
70258: IFFALSE 70262
// continue ;
70260: GO 70209
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70262: LD_VAR 0 3
70266: PPUSH
70267: LD_EXP 79
70271: PUSH
70272: LD_VAR 0 2
70276: ARRAY
70277: PUSH
70278: LD_INT 1
70280: ARRAY
70281: PUSH
70282: LD_INT 1
70284: ARRAY
70285: PPUSH
70286: LD_EXP 79
70290: PUSH
70291: LD_VAR 0 2
70295: ARRAY
70296: PUSH
70297: LD_INT 1
70299: ARRAY
70300: PUSH
70301: LD_INT 2
70303: ARRAY
70304: PPUSH
70305: LD_EXP 79
70309: PUSH
70310: LD_VAR 0 2
70314: ARRAY
70315: PUSH
70316: LD_INT 1
70318: ARRAY
70319: PUSH
70320: LD_INT 3
70322: ARRAY
70323: PPUSH
70324: LD_EXP 79
70328: PUSH
70329: LD_VAR 0 2
70333: ARRAY
70334: PUSH
70335: LD_INT 1
70337: ARRAY
70338: PUSH
70339: LD_INT 4
70341: ARRAY
70342: PPUSH
70343: CALL_OW 448
70347: PUSH
70348: LD_VAR 0 3
70352: PPUSH
70353: LD_EXP 79
70357: PUSH
70358: LD_VAR 0 2
70362: ARRAY
70363: PUSH
70364: LD_INT 1
70366: ARRAY
70367: PUSH
70368: LD_INT 1
70370: ARRAY
70371: PUSH
70372: LD_EXP 79
70376: PUSH
70377: LD_VAR 0 2
70381: ARRAY
70382: PUSH
70383: LD_INT 1
70385: ARRAY
70386: PUSH
70387: LD_INT 2
70389: ARRAY
70390: PUSH
70391: LD_EXP 79
70395: PUSH
70396: LD_VAR 0 2
70400: ARRAY
70401: PUSH
70402: LD_INT 1
70404: ARRAY
70405: PUSH
70406: LD_INT 3
70408: ARRAY
70409: PUSH
70410: LD_EXP 79
70414: PUSH
70415: LD_VAR 0 2
70419: ARRAY
70420: PUSH
70421: LD_INT 1
70423: ARRAY
70424: PUSH
70425: LD_INT 4
70427: ARRAY
70428: PUSH
70429: EMPTY
70430: LIST
70431: LIST
70432: LIST
70433: LIST
70434: PPUSH
70435: CALL 26761 0 2
70439: AND
70440: IFFALSE 70578
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70442: LD_VAR 0 3
70446: PPUSH
70447: LD_EXP 79
70451: PUSH
70452: LD_VAR 0 2
70456: ARRAY
70457: PUSH
70458: LD_INT 1
70460: ARRAY
70461: PUSH
70462: LD_INT 1
70464: ARRAY
70465: PPUSH
70466: LD_EXP 79
70470: PUSH
70471: LD_VAR 0 2
70475: ARRAY
70476: PUSH
70477: LD_INT 1
70479: ARRAY
70480: PUSH
70481: LD_INT 2
70483: ARRAY
70484: PPUSH
70485: LD_EXP 79
70489: PUSH
70490: LD_VAR 0 2
70494: ARRAY
70495: PUSH
70496: LD_INT 1
70498: ARRAY
70499: PUSH
70500: LD_INT 3
70502: ARRAY
70503: PPUSH
70504: LD_EXP 79
70508: PUSH
70509: LD_VAR 0 2
70513: ARRAY
70514: PUSH
70515: LD_INT 1
70517: ARRAY
70518: PUSH
70519: LD_INT 4
70521: ARRAY
70522: PPUSH
70523: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70527: LD_ADDR_VAR 0 4
70531: PUSH
70532: LD_EXP 79
70536: PUSH
70537: LD_VAR 0 2
70541: ARRAY
70542: PPUSH
70543: LD_INT 1
70545: PPUSH
70546: CALL_OW 3
70550: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70551: LD_ADDR_EXP 79
70555: PUSH
70556: LD_EXP 79
70560: PPUSH
70561: LD_VAR 0 2
70565: PPUSH
70566: LD_VAR 0 4
70570: PPUSH
70571: CALL_OW 1
70575: ST_TO_ADDR
// break ;
70576: GO 70580
// end ; end ;
70578: GO 70209
70580: POP
70581: POP
// end ;
70582: GO 70141
70584: POP
70585: POP
// end ;
70586: LD_VAR 0 1
70590: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70591: LD_INT 0
70593: PPUSH
70594: PPUSH
70595: PPUSH
// if not mc_bases then
70596: LD_EXP 58
70600: NOT
70601: IFFALSE 70605
// exit ;
70603: GO 70694
// for i = 1 to mc_bases do
70605: LD_ADDR_VAR 0 2
70609: PUSH
70610: DOUBLE
70611: LD_INT 1
70613: DEC
70614: ST_TO_ADDR
70615: LD_EXP 58
70619: PUSH
70620: FOR_TO
70621: IFFALSE 70692
// begin if mc_attack [ i ] then
70623: LD_EXP 78
70627: PUSH
70628: LD_VAR 0 2
70632: ARRAY
70633: IFFALSE 70690
// begin tmp := mc_attack [ i ] [ 1 ] ;
70635: LD_ADDR_VAR 0 3
70639: PUSH
70640: LD_EXP 78
70644: PUSH
70645: LD_VAR 0 2
70649: ARRAY
70650: PUSH
70651: LD_INT 1
70653: ARRAY
70654: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70655: LD_ADDR_EXP 78
70659: PUSH
70660: LD_EXP 78
70664: PPUSH
70665: LD_VAR 0 2
70669: PPUSH
70670: EMPTY
70671: PPUSH
70672: CALL_OW 1
70676: ST_TO_ADDR
// Attack ( tmp ) ;
70677: LD_VAR 0 3
70681: PPUSH
70682: CALL 48950 0 1
// exit ;
70686: POP
70687: POP
70688: GO 70694
// end ; end ;
70690: GO 70620
70692: POP
70693: POP
// end ;
70694: LD_VAR 0 1
70698: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70699: LD_INT 0
70701: PPUSH
70702: PPUSH
70703: PPUSH
70704: PPUSH
70705: PPUSH
70706: PPUSH
70707: PPUSH
// if not mc_bases then
70708: LD_EXP 58
70712: NOT
70713: IFFALSE 70717
// exit ;
70715: GO 71321
// for i = 1 to mc_bases do
70717: LD_ADDR_VAR 0 2
70721: PUSH
70722: DOUBLE
70723: LD_INT 1
70725: DEC
70726: ST_TO_ADDR
70727: LD_EXP 58
70731: PUSH
70732: FOR_TO
70733: IFFALSE 71319
// begin if not mc_bases [ i ] then
70735: LD_EXP 58
70739: PUSH
70740: LD_VAR 0 2
70744: ARRAY
70745: NOT
70746: IFFALSE 70750
// continue ;
70748: GO 70732
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70750: LD_ADDR_VAR 0 7
70754: PUSH
70755: LD_EXP 58
70759: PUSH
70760: LD_VAR 0 2
70764: ARRAY
70765: PUSH
70766: LD_INT 1
70768: ARRAY
70769: PPUSH
70770: CALL 17401 0 1
70774: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70775: LD_ADDR_EXP 81
70779: PUSH
70780: LD_EXP 81
70784: PPUSH
70785: LD_VAR 0 2
70789: PPUSH
70790: LD_EXP 58
70794: PUSH
70795: LD_VAR 0 2
70799: ARRAY
70800: PUSH
70801: LD_INT 1
70803: ARRAY
70804: PPUSH
70805: CALL_OW 255
70809: PPUSH
70810: LD_EXP 83
70814: PUSH
70815: LD_VAR 0 2
70819: ARRAY
70820: PPUSH
70821: CALL 15361 0 2
70825: PPUSH
70826: CALL_OW 1
70830: ST_TO_ADDR
// if not mc_scan [ i ] then
70831: LD_EXP 81
70835: PUSH
70836: LD_VAR 0 2
70840: ARRAY
70841: NOT
70842: IFFALSE 70997
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70844: LD_ADDR_VAR 0 4
70848: PUSH
70849: LD_EXP 58
70853: PUSH
70854: LD_VAR 0 2
70858: ARRAY
70859: PPUSH
70860: LD_INT 2
70862: PUSH
70863: LD_INT 25
70865: PUSH
70866: LD_INT 5
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PUSH
70873: LD_INT 25
70875: PUSH
70876: LD_INT 8
70878: PUSH
70879: EMPTY
70880: LIST
70881: LIST
70882: PUSH
70883: LD_INT 25
70885: PUSH
70886: LD_INT 9
70888: PUSH
70889: EMPTY
70890: LIST
70891: LIST
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: PPUSH
70899: CALL_OW 72
70903: ST_TO_ADDR
// if not tmp then
70904: LD_VAR 0 4
70908: NOT
70909: IFFALSE 70913
// continue ;
70911: GO 70732
// for j in tmp do
70913: LD_ADDR_VAR 0 3
70917: PUSH
70918: LD_VAR 0 4
70922: PUSH
70923: FOR_IN
70924: IFFALSE 70995
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70926: LD_VAR 0 3
70930: PPUSH
70931: CALL_OW 310
70935: PPUSH
70936: CALL_OW 266
70940: PUSH
70941: LD_INT 5
70943: EQUAL
70944: PUSH
70945: LD_VAR 0 3
70949: PPUSH
70950: CALL_OW 257
70954: PUSH
70955: LD_INT 1
70957: EQUAL
70958: AND
70959: PUSH
70960: LD_VAR 0 3
70964: PPUSH
70965: CALL_OW 459
70969: NOT
70970: AND
70971: PUSH
70972: LD_VAR 0 7
70976: AND
70977: IFFALSE 70993
// ComChangeProfession ( j , class ) ;
70979: LD_VAR 0 3
70983: PPUSH
70984: LD_VAR 0 7
70988: PPUSH
70989: CALL_OW 123
70993: GO 70923
70995: POP
70996: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70997: LD_EXP 81
71001: PUSH
71002: LD_VAR 0 2
71006: ARRAY
71007: PUSH
71008: LD_EXP 80
71012: PUSH
71013: LD_VAR 0 2
71017: ARRAY
71018: NOT
71019: AND
71020: PUSH
71021: LD_EXP 58
71025: PUSH
71026: LD_VAR 0 2
71030: ARRAY
71031: PPUSH
71032: LD_INT 30
71034: PUSH
71035: LD_INT 32
71037: PUSH
71038: EMPTY
71039: LIST
71040: LIST
71041: PPUSH
71042: CALL_OW 72
71046: NOT
71047: AND
71048: PUSH
71049: LD_EXP 58
71053: PUSH
71054: LD_VAR 0 2
71058: ARRAY
71059: PPUSH
71060: LD_INT 2
71062: PUSH
71063: LD_INT 30
71065: PUSH
71066: LD_INT 4
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 30
71075: PUSH
71076: LD_INT 5
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: EMPTY
71084: LIST
71085: LIST
71086: LIST
71087: PPUSH
71088: CALL_OW 72
71092: NOT
71093: AND
71094: IFFALSE 71226
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71096: LD_ADDR_VAR 0 4
71100: PUSH
71101: LD_EXP 58
71105: PUSH
71106: LD_VAR 0 2
71110: ARRAY
71111: PPUSH
71112: LD_INT 2
71114: PUSH
71115: LD_INT 25
71117: PUSH
71118: LD_INT 1
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 25
71127: PUSH
71128: LD_INT 5
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 25
71137: PUSH
71138: LD_INT 8
71140: PUSH
71141: EMPTY
71142: LIST
71143: LIST
71144: PUSH
71145: LD_INT 25
71147: PUSH
71148: LD_INT 9
71150: PUSH
71151: EMPTY
71152: LIST
71153: LIST
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: LIST
71161: PPUSH
71162: CALL_OW 72
71166: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71167: LD_ADDR_VAR 0 4
71171: PUSH
71172: LD_VAR 0 4
71176: PUSH
71177: LD_VAR 0 4
71181: PPUSH
71182: LD_INT 18
71184: PPUSH
71185: CALL 53694 0 2
71189: DIFF
71190: ST_TO_ADDR
// if tmp then
71191: LD_VAR 0 4
71195: IFFALSE 71226
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
71197: LD_VAR 0 2
71201: PPUSH
71202: LD_VAR 0 4
71206: PPUSH
71207: LD_EXP 83
71211: PUSH
71212: LD_VAR 0 2
71216: ARRAY
71217: PPUSH
71218: CALL 15396 0 3
// exit ;
71222: POP
71223: POP
71224: GO 71321
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
71226: LD_EXP 81
71230: PUSH
71231: LD_VAR 0 2
71235: ARRAY
71236: PUSH
71237: LD_EXP 80
71241: PUSH
71242: LD_VAR 0 2
71246: ARRAY
71247: AND
71248: IFFALSE 71317
// begin tmp := mc_defender [ i ] ;
71250: LD_ADDR_VAR 0 4
71254: PUSH
71255: LD_EXP 80
71259: PUSH
71260: LD_VAR 0 2
71264: ARRAY
71265: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71266: LD_ADDR_EXP 80
71270: PUSH
71271: LD_EXP 80
71275: PPUSH
71276: LD_VAR 0 2
71280: PPUSH
71281: EMPTY
71282: PPUSH
71283: CALL_OW 1
71287: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
71288: LD_VAR 0 2
71292: PPUSH
71293: LD_VAR 0 4
71297: PPUSH
71298: LD_EXP 81
71302: PUSH
71303: LD_VAR 0 2
71307: ARRAY
71308: PPUSH
71309: CALL 15894 0 3
// exit ;
71313: POP
71314: POP
71315: GO 71321
// end ; end ;
71317: GO 70732
71319: POP
71320: POP
// end ;
71321: LD_VAR 0 1
71325: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71326: LD_INT 0
71328: PPUSH
71329: PPUSH
71330: PPUSH
71331: PPUSH
71332: PPUSH
71333: PPUSH
71334: PPUSH
71335: PPUSH
71336: PPUSH
71337: PPUSH
71338: PPUSH
// if not mc_bases then
71339: LD_EXP 58
71343: NOT
71344: IFFALSE 71348
// exit ;
71346: GO 72435
// for i = 1 to mc_bases do
71348: LD_ADDR_VAR 0 2
71352: PUSH
71353: DOUBLE
71354: LD_INT 1
71356: DEC
71357: ST_TO_ADDR
71358: LD_EXP 58
71362: PUSH
71363: FOR_TO
71364: IFFALSE 72433
// begin tmp := mc_lab [ i ] ;
71366: LD_ADDR_VAR 0 6
71370: PUSH
71371: LD_EXP 91
71375: PUSH
71376: LD_VAR 0 2
71380: ARRAY
71381: ST_TO_ADDR
// if not tmp then
71382: LD_VAR 0 6
71386: NOT
71387: IFFALSE 71391
// continue ;
71389: GO 71363
// idle_lab := 0 ;
71391: LD_ADDR_VAR 0 11
71395: PUSH
71396: LD_INT 0
71398: ST_TO_ADDR
// for j in tmp do
71399: LD_ADDR_VAR 0 3
71403: PUSH
71404: LD_VAR 0 6
71408: PUSH
71409: FOR_IN
71410: IFFALSE 72429
// begin researching := false ;
71412: LD_ADDR_VAR 0 10
71416: PUSH
71417: LD_INT 0
71419: ST_TO_ADDR
// side := GetSide ( j ) ;
71420: LD_ADDR_VAR 0 4
71424: PUSH
71425: LD_VAR 0 3
71429: PPUSH
71430: CALL_OW 255
71434: ST_TO_ADDR
// if not mc_tech [ side ] then
71435: LD_EXP 85
71439: PUSH
71440: LD_VAR 0 4
71444: ARRAY
71445: NOT
71446: IFFALSE 71450
// continue ;
71448: GO 71409
// if BuildingStatus ( j ) = bs_idle then
71450: LD_VAR 0 3
71454: PPUSH
71455: CALL_OW 461
71459: PUSH
71460: LD_INT 2
71462: EQUAL
71463: IFFALSE 71651
// begin if idle_lab and UnitsInside ( j ) < 6 then
71465: LD_VAR 0 11
71469: PUSH
71470: LD_VAR 0 3
71474: PPUSH
71475: CALL_OW 313
71479: PUSH
71480: LD_INT 6
71482: LESS
71483: AND
71484: IFFALSE 71555
// begin tmp2 := UnitsInside ( idle_lab ) ;
71486: LD_ADDR_VAR 0 9
71490: PUSH
71491: LD_VAR 0 11
71495: PPUSH
71496: CALL_OW 313
71500: ST_TO_ADDR
// if tmp2 then
71501: LD_VAR 0 9
71505: IFFALSE 71547
// for x in tmp2 do
71507: LD_ADDR_VAR 0 7
71511: PUSH
71512: LD_VAR 0 9
71516: PUSH
71517: FOR_IN
71518: IFFALSE 71545
// begin ComExitBuilding ( x ) ;
71520: LD_VAR 0 7
71524: PPUSH
71525: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71529: LD_VAR 0 7
71533: PPUSH
71534: LD_VAR 0 3
71538: PPUSH
71539: CALL_OW 180
// end ;
71543: GO 71517
71545: POP
71546: POP
// idle_lab := 0 ;
71547: LD_ADDR_VAR 0 11
71551: PUSH
71552: LD_INT 0
71554: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71555: LD_ADDR_VAR 0 5
71559: PUSH
71560: LD_EXP 85
71564: PUSH
71565: LD_VAR 0 4
71569: ARRAY
71570: PUSH
71571: FOR_IN
71572: IFFALSE 71632
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71574: LD_VAR 0 3
71578: PPUSH
71579: LD_VAR 0 5
71583: PPUSH
71584: CALL_OW 430
71588: PUSH
71589: LD_VAR 0 4
71593: PPUSH
71594: LD_VAR 0 5
71598: PPUSH
71599: CALL 14466 0 2
71603: AND
71604: IFFALSE 71630
// begin researching := true ;
71606: LD_ADDR_VAR 0 10
71610: PUSH
71611: LD_INT 1
71613: ST_TO_ADDR
// ComResearch ( j , t ) ;
71614: LD_VAR 0 3
71618: PPUSH
71619: LD_VAR 0 5
71623: PPUSH
71624: CALL_OW 124
// break ;
71628: GO 71632
// end ;
71630: GO 71571
71632: POP
71633: POP
// if not researching then
71634: LD_VAR 0 10
71638: NOT
71639: IFFALSE 71651
// idle_lab := j ;
71641: LD_ADDR_VAR 0 11
71645: PUSH
71646: LD_VAR 0 3
71650: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71651: LD_VAR 0 3
71655: PPUSH
71656: CALL_OW 461
71660: PUSH
71661: LD_INT 10
71663: EQUAL
71664: IFFALSE 72252
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71666: LD_EXP 87
71670: PUSH
71671: LD_VAR 0 2
71675: ARRAY
71676: NOT
71677: PUSH
71678: LD_EXP 88
71682: PUSH
71683: LD_VAR 0 2
71687: ARRAY
71688: NOT
71689: AND
71690: PUSH
71691: LD_EXP 85
71695: PUSH
71696: LD_VAR 0 4
71700: ARRAY
71701: PUSH
71702: LD_INT 1
71704: GREATER
71705: AND
71706: IFFALSE 71837
// begin ComCancel ( j ) ;
71708: LD_VAR 0 3
71712: PPUSH
71713: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71717: LD_ADDR_EXP 85
71721: PUSH
71722: LD_EXP 85
71726: PPUSH
71727: LD_VAR 0 4
71731: PPUSH
71732: LD_EXP 85
71736: PUSH
71737: LD_VAR 0 4
71741: ARRAY
71742: PPUSH
71743: LD_EXP 85
71747: PUSH
71748: LD_VAR 0 4
71752: ARRAY
71753: PUSH
71754: LD_INT 1
71756: MINUS
71757: PPUSH
71758: LD_EXP 85
71762: PUSH
71763: LD_VAR 0 4
71767: ARRAY
71768: PPUSH
71769: LD_INT 0
71771: PPUSH
71772: CALL 19915 0 4
71776: PPUSH
71777: CALL_OW 1
71781: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71782: LD_ADDR_EXP 85
71786: PUSH
71787: LD_EXP 85
71791: PPUSH
71792: LD_VAR 0 4
71796: PPUSH
71797: LD_EXP 85
71801: PUSH
71802: LD_VAR 0 4
71806: ARRAY
71807: PPUSH
71808: LD_EXP 85
71812: PUSH
71813: LD_VAR 0 4
71817: ARRAY
71818: PPUSH
71819: LD_INT 1
71821: PPUSH
71822: LD_INT 0
71824: PPUSH
71825: CALL 19915 0 4
71829: PPUSH
71830: CALL_OW 1
71834: ST_TO_ADDR
// continue ;
71835: GO 71409
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71837: LD_EXP 87
71841: PUSH
71842: LD_VAR 0 2
71846: ARRAY
71847: PUSH
71848: LD_EXP 88
71852: PUSH
71853: LD_VAR 0 2
71857: ARRAY
71858: NOT
71859: AND
71860: IFFALSE 71987
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71862: LD_ADDR_EXP 88
71866: PUSH
71867: LD_EXP 88
71871: PPUSH
71872: LD_VAR 0 2
71876: PUSH
71877: LD_EXP 88
71881: PUSH
71882: LD_VAR 0 2
71886: ARRAY
71887: PUSH
71888: LD_INT 1
71890: PLUS
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PPUSH
71896: LD_EXP 87
71900: PUSH
71901: LD_VAR 0 2
71905: ARRAY
71906: PUSH
71907: LD_INT 1
71909: ARRAY
71910: PPUSH
71911: CALL 20497 0 3
71915: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71916: LD_EXP 87
71920: PUSH
71921: LD_VAR 0 2
71925: ARRAY
71926: PUSH
71927: LD_INT 1
71929: ARRAY
71930: PPUSH
71931: LD_INT 112
71933: PPUSH
71934: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71938: LD_ADDR_VAR 0 9
71942: PUSH
71943: LD_EXP 87
71947: PUSH
71948: LD_VAR 0 2
71952: ARRAY
71953: PPUSH
71954: LD_INT 1
71956: PPUSH
71957: CALL_OW 3
71961: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71962: LD_ADDR_EXP 87
71966: PUSH
71967: LD_EXP 87
71971: PPUSH
71972: LD_VAR 0 2
71976: PPUSH
71977: LD_VAR 0 9
71981: PPUSH
71982: CALL_OW 1
71986: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71987: LD_EXP 87
71991: PUSH
71992: LD_VAR 0 2
71996: ARRAY
71997: PUSH
71998: LD_EXP 88
72002: PUSH
72003: LD_VAR 0 2
72007: ARRAY
72008: AND
72009: PUSH
72010: LD_EXP 88
72014: PUSH
72015: LD_VAR 0 2
72019: ARRAY
72020: PUSH
72021: LD_INT 1
72023: ARRAY
72024: PPUSH
72025: CALL_OW 310
72029: NOT
72030: AND
72031: PUSH
72032: LD_VAR 0 3
72036: PPUSH
72037: CALL_OW 313
72041: PUSH
72042: LD_INT 6
72044: EQUAL
72045: AND
72046: IFFALSE 72102
// begin tmp2 := UnitsInside ( j ) ;
72048: LD_ADDR_VAR 0 9
72052: PUSH
72053: LD_VAR 0 3
72057: PPUSH
72058: CALL_OW 313
72062: ST_TO_ADDR
// if tmp2 = 6 then
72063: LD_VAR 0 9
72067: PUSH
72068: LD_INT 6
72070: EQUAL
72071: IFFALSE 72102
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72073: LD_VAR 0 9
72077: PUSH
72078: LD_INT 1
72080: ARRAY
72081: PPUSH
72082: LD_INT 112
72084: PPUSH
72085: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72089: LD_VAR 0 9
72093: PUSH
72094: LD_INT 1
72096: ARRAY
72097: PPUSH
72098: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72102: LD_EXP 88
72106: PUSH
72107: LD_VAR 0 2
72111: ARRAY
72112: PUSH
72113: LD_EXP 88
72117: PUSH
72118: LD_VAR 0 2
72122: ARRAY
72123: PUSH
72124: LD_INT 1
72126: ARRAY
72127: PPUSH
72128: CALL_OW 314
72132: NOT
72133: AND
72134: PUSH
72135: LD_EXP 88
72139: PUSH
72140: LD_VAR 0 2
72144: ARRAY
72145: PUSH
72146: LD_INT 1
72148: ARRAY
72149: PPUSH
72150: CALL_OW 310
72154: NOT
72155: AND
72156: IFFALSE 72182
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72158: LD_EXP 88
72162: PUSH
72163: LD_VAR 0 2
72167: ARRAY
72168: PUSH
72169: LD_INT 1
72171: ARRAY
72172: PPUSH
72173: LD_VAR 0 3
72177: PPUSH
72178: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72182: LD_EXP 88
72186: PUSH
72187: LD_VAR 0 2
72191: ARRAY
72192: PUSH
72193: LD_INT 1
72195: ARRAY
72196: PPUSH
72197: CALL_OW 310
72201: PUSH
72202: LD_EXP 88
72206: PUSH
72207: LD_VAR 0 2
72211: ARRAY
72212: PUSH
72213: LD_INT 1
72215: ARRAY
72216: PPUSH
72217: CALL_OW 310
72221: PPUSH
72222: CALL_OW 461
72226: PUSH
72227: LD_INT 3
72229: NONEQUAL
72230: AND
72231: IFFALSE 72252
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72233: LD_EXP 88
72237: PUSH
72238: LD_VAR 0 2
72242: ARRAY
72243: PUSH
72244: LD_INT 1
72246: ARRAY
72247: PPUSH
72248: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72252: LD_VAR 0 3
72256: PPUSH
72257: CALL_OW 461
72261: PUSH
72262: LD_INT 6
72264: EQUAL
72265: PUSH
72266: LD_VAR 0 6
72270: PUSH
72271: LD_INT 1
72273: GREATER
72274: AND
72275: IFFALSE 72427
// begin sci := [ ] ;
72277: LD_ADDR_VAR 0 8
72281: PUSH
72282: EMPTY
72283: ST_TO_ADDR
// for x in ( tmp diff j ) do
72284: LD_ADDR_VAR 0 7
72288: PUSH
72289: LD_VAR 0 6
72293: PUSH
72294: LD_VAR 0 3
72298: DIFF
72299: PUSH
72300: FOR_IN
72301: IFFALSE 72353
// begin if sci = 6 then
72303: LD_VAR 0 8
72307: PUSH
72308: LD_INT 6
72310: EQUAL
72311: IFFALSE 72315
// break ;
72313: GO 72353
// if BuildingStatus ( x ) = bs_idle then
72315: LD_VAR 0 7
72319: PPUSH
72320: CALL_OW 461
72324: PUSH
72325: LD_INT 2
72327: EQUAL
72328: IFFALSE 72351
// sci := sci ^ UnitsInside ( x ) ;
72330: LD_ADDR_VAR 0 8
72334: PUSH
72335: LD_VAR 0 8
72339: PUSH
72340: LD_VAR 0 7
72344: PPUSH
72345: CALL_OW 313
72349: ADD
72350: ST_TO_ADDR
// end ;
72351: GO 72300
72353: POP
72354: POP
// if not sci then
72355: LD_VAR 0 8
72359: NOT
72360: IFFALSE 72364
// continue ;
72362: GO 71409
// for x in sci do
72364: LD_ADDR_VAR 0 7
72368: PUSH
72369: LD_VAR 0 8
72373: PUSH
72374: FOR_IN
72375: IFFALSE 72425
// if IsInUnit ( x ) and not HasTask ( x ) then
72377: LD_VAR 0 7
72381: PPUSH
72382: CALL_OW 310
72386: PUSH
72387: LD_VAR 0 7
72391: PPUSH
72392: CALL_OW 314
72396: NOT
72397: AND
72398: IFFALSE 72423
// begin ComExitBuilding ( x ) ;
72400: LD_VAR 0 7
72404: PPUSH
72405: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72409: LD_VAR 0 7
72413: PPUSH
72414: LD_VAR 0 3
72418: PPUSH
72419: CALL_OW 180
// end ;
72423: GO 72374
72425: POP
72426: POP
// end ; end ;
72427: GO 71409
72429: POP
72430: POP
// end ;
72431: GO 71363
72433: POP
72434: POP
// end ;
72435: LD_VAR 0 1
72439: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72440: LD_INT 0
72442: PPUSH
72443: PPUSH
// if not mc_bases then
72444: LD_EXP 58
72448: NOT
72449: IFFALSE 72453
// exit ;
72451: GO 72534
// for i = 1 to mc_bases do
72453: LD_ADDR_VAR 0 2
72457: PUSH
72458: DOUBLE
72459: LD_INT 1
72461: DEC
72462: ST_TO_ADDR
72463: LD_EXP 58
72467: PUSH
72468: FOR_TO
72469: IFFALSE 72532
// if mc_mines [ i ] and mc_miners [ i ] then
72471: LD_EXP 71
72475: PUSH
72476: LD_VAR 0 2
72480: ARRAY
72481: PUSH
72482: LD_EXP 72
72486: PUSH
72487: LD_VAR 0 2
72491: ARRAY
72492: AND
72493: IFFALSE 72530
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72495: LD_EXP 72
72499: PUSH
72500: LD_VAR 0 2
72504: ARRAY
72505: PUSH
72506: LD_INT 1
72508: ARRAY
72509: PPUSH
72510: CALL_OW 255
72514: PPUSH
72515: LD_EXP 71
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: PPUSH
72526: CALL 17554 0 2
72530: GO 72468
72532: POP
72533: POP
// end ;
72534: LD_VAR 0 1
72538: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72539: LD_INT 0
72541: PPUSH
72542: PPUSH
72543: PPUSH
72544: PPUSH
72545: PPUSH
72546: PPUSH
72547: PPUSH
72548: PPUSH
// if not mc_bases or not mc_parking then
72549: LD_EXP 58
72553: NOT
72554: PUSH
72555: LD_EXP 82
72559: NOT
72560: OR
72561: IFFALSE 72565
// exit ;
72563: GO 73277
// for i = 1 to mc_bases do
72565: LD_ADDR_VAR 0 2
72569: PUSH
72570: DOUBLE
72571: LD_INT 1
72573: DEC
72574: ST_TO_ADDR
72575: LD_EXP 58
72579: PUSH
72580: FOR_TO
72581: IFFALSE 73275
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72583: LD_EXP 58
72587: PUSH
72588: LD_VAR 0 2
72592: ARRAY
72593: NOT
72594: PUSH
72595: LD_EXP 82
72599: PUSH
72600: LD_VAR 0 2
72604: ARRAY
72605: NOT
72606: OR
72607: IFFALSE 72611
// continue ;
72609: GO 72580
// if mc_scan [ i ] then
72611: LD_EXP 81
72615: PUSH
72616: LD_VAR 0 2
72620: ARRAY
72621: IFFALSE 72647
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72623: LD_ADDR_EXP 70
72627: PUSH
72628: LD_EXP 70
72632: PPUSH
72633: LD_VAR 0 2
72637: PPUSH
72638: EMPTY
72639: PPUSH
72640: CALL_OW 1
72644: ST_TO_ADDR
// continue ;
72645: GO 72580
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72647: LD_ADDR_VAR 0 5
72651: PUSH
72652: LD_EXP 58
72656: PUSH
72657: LD_VAR 0 2
72661: ARRAY
72662: PUSH
72663: LD_INT 1
72665: ARRAY
72666: PPUSH
72667: CALL_OW 255
72671: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72672: LD_ADDR_VAR 0 6
72676: PUSH
72677: LD_EXP 58
72681: PUSH
72682: LD_VAR 0 2
72686: ARRAY
72687: PPUSH
72688: LD_INT 30
72690: PUSH
72691: LD_INT 3
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PPUSH
72698: CALL_OW 72
72702: ST_TO_ADDR
// if not fac then
72703: LD_VAR 0 6
72707: NOT
72708: IFFALSE 72759
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72710: LD_ADDR_VAR 0 6
72714: PUSH
72715: LD_EXP 58
72719: PUSH
72720: LD_VAR 0 2
72724: ARRAY
72725: PPUSH
72726: LD_INT 2
72728: PUSH
72729: LD_INT 30
72731: PUSH
72732: LD_INT 0
72734: PUSH
72735: EMPTY
72736: LIST
72737: LIST
72738: PUSH
72739: LD_INT 30
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: EMPTY
72746: LIST
72747: LIST
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: LIST
72753: PPUSH
72754: CALL_OW 72
72758: ST_TO_ADDR
// if not fac then
72759: LD_VAR 0 6
72763: NOT
72764: IFFALSE 72768
// continue ;
72766: GO 72580
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72768: LD_ADDR_VAR 0 7
72772: PUSH
72773: LD_EXP 82
72777: PUSH
72778: LD_VAR 0 2
72782: ARRAY
72783: PPUSH
72784: LD_INT 22
72786: PUSH
72787: LD_VAR 0 5
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 21
72798: PUSH
72799: LD_INT 2
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 3
72808: PUSH
72809: LD_INT 24
72811: PUSH
72812: LD_INT 1000
72814: PUSH
72815: EMPTY
72816: LIST
72817: LIST
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: LIST
72827: PPUSH
72828: CALL_OW 70
72832: PUSH
72833: LD_INT 22
72835: PUSH
72836: LD_VAR 0 5
72840: PUSH
72841: EMPTY
72842: LIST
72843: LIST
72844: PUSH
72845: LD_INT 91
72847: PUSH
72848: LD_VAR 0 6
72852: PUSH
72853: LD_INT 1
72855: ARRAY
72856: PUSH
72857: LD_INT 25
72859: PUSH
72860: EMPTY
72861: LIST
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 21
72867: PUSH
72868: LD_INT 2
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 3
72877: PUSH
72878: LD_INT 24
72880: PUSH
72881: LD_INT 1000
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: LIST
72896: LIST
72897: PPUSH
72898: CALL_OW 69
72902: UNION
72903: ST_TO_ADDR
// if not vehs then
72904: LD_VAR 0 7
72908: NOT
72909: IFFALSE 72935
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72911: LD_ADDR_EXP 70
72915: PUSH
72916: LD_EXP 70
72920: PPUSH
72921: LD_VAR 0 2
72925: PPUSH
72926: EMPTY
72927: PPUSH
72928: CALL_OW 1
72932: ST_TO_ADDR
// continue ;
72933: GO 72580
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72935: LD_ADDR_VAR 0 8
72939: PUSH
72940: LD_EXP 58
72944: PUSH
72945: LD_VAR 0 2
72949: ARRAY
72950: PPUSH
72951: LD_INT 30
72953: PUSH
72954: LD_INT 3
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PPUSH
72961: CALL_OW 72
72965: ST_TO_ADDR
// if tmp then
72966: LD_VAR 0 8
72970: IFFALSE 73073
// begin for j in tmp do
72972: LD_ADDR_VAR 0 3
72976: PUSH
72977: LD_VAR 0 8
72981: PUSH
72982: FOR_IN
72983: IFFALSE 73071
// for k in UnitsInside ( j ) do
72985: LD_ADDR_VAR 0 4
72989: PUSH
72990: LD_VAR 0 3
72994: PPUSH
72995: CALL_OW 313
72999: PUSH
73000: FOR_IN
73001: IFFALSE 73067
// if k then
73003: LD_VAR 0 4
73007: IFFALSE 73065
// if not k in mc_repair_vehicle [ i ] then
73009: LD_VAR 0 4
73013: PUSH
73014: LD_EXP 70
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: IN
73025: NOT
73026: IFFALSE 73065
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73028: LD_ADDR_EXP 70
73032: PUSH
73033: LD_EXP 70
73037: PPUSH
73038: LD_VAR 0 2
73042: PPUSH
73043: LD_EXP 70
73047: PUSH
73048: LD_VAR 0 2
73052: ARRAY
73053: PUSH
73054: LD_VAR 0 4
73058: UNION
73059: PPUSH
73060: CALL_OW 1
73064: ST_TO_ADDR
73065: GO 73000
73067: POP
73068: POP
73069: GO 72982
73071: POP
73072: POP
// end ; if not mc_repair_vehicle [ i ] then
73073: LD_EXP 70
73077: PUSH
73078: LD_VAR 0 2
73082: ARRAY
73083: NOT
73084: IFFALSE 73088
// continue ;
73086: GO 72580
// for j in mc_repair_vehicle [ i ] do
73088: LD_ADDR_VAR 0 3
73092: PUSH
73093: LD_EXP 70
73097: PUSH
73098: LD_VAR 0 2
73102: ARRAY
73103: PUSH
73104: FOR_IN
73105: IFFALSE 73271
// begin if GetClass ( j ) <> 3 then
73107: LD_VAR 0 3
73111: PPUSH
73112: CALL_OW 257
73116: PUSH
73117: LD_INT 3
73119: NONEQUAL
73120: IFFALSE 73161
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73122: LD_ADDR_EXP 70
73126: PUSH
73127: LD_EXP 70
73131: PPUSH
73132: LD_VAR 0 2
73136: PPUSH
73137: LD_EXP 70
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: PUSH
73148: LD_VAR 0 3
73152: DIFF
73153: PPUSH
73154: CALL_OW 1
73158: ST_TO_ADDR
// continue ;
73159: GO 73104
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73161: LD_VAR 0 3
73165: PPUSH
73166: CALL_OW 311
73170: NOT
73171: PUSH
73172: LD_VAR 0 3
73176: PUSH
73177: LD_EXP 61
73181: PUSH
73182: LD_VAR 0 2
73186: ARRAY
73187: PUSH
73188: LD_INT 1
73190: ARRAY
73191: IN
73192: NOT
73193: AND
73194: PUSH
73195: LD_VAR 0 3
73199: PUSH
73200: LD_EXP 61
73204: PUSH
73205: LD_VAR 0 2
73209: ARRAY
73210: PUSH
73211: LD_INT 2
73213: ARRAY
73214: IN
73215: NOT
73216: AND
73217: IFFALSE 73269
// begin if IsInUnit ( j ) then
73219: LD_VAR 0 3
73223: PPUSH
73224: CALL_OW 310
73228: IFFALSE 73239
// ComExitBuilding ( j ) ;
73230: LD_VAR 0 3
73234: PPUSH
73235: CALL_OW 122
// if not HasTask ( j ) then
73239: LD_VAR 0 3
73243: PPUSH
73244: CALL_OW 314
73248: NOT
73249: IFFALSE 73269
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
73251: LD_VAR 0 3
73255: PPUSH
73256: LD_VAR 0 7
73260: PUSH
73261: LD_INT 1
73263: ARRAY
73264: PPUSH
73265: CALL_OW 189
// end ; end ;
73269: GO 73104
73271: POP
73272: POP
// end ;
73273: GO 72580
73275: POP
73276: POP
// end ;
73277: LD_VAR 0 1
73281: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73282: LD_INT 0
73284: PPUSH
73285: PPUSH
73286: PPUSH
73287: PPUSH
73288: PPUSH
73289: PPUSH
73290: PPUSH
73291: PPUSH
73292: PPUSH
73293: PPUSH
73294: PPUSH
// if not mc_bases then
73295: LD_EXP 58
73299: NOT
73300: IFFALSE 73304
// exit ;
73302: GO 74106
// for i = 1 to mc_bases do
73304: LD_ADDR_VAR 0 2
73308: PUSH
73309: DOUBLE
73310: LD_INT 1
73312: DEC
73313: ST_TO_ADDR
73314: LD_EXP 58
73318: PUSH
73319: FOR_TO
73320: IFFALSE 74104
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73322: LD_EXP 86
73326: PUSH
73327: LD_VAR 0 2
73331: ARRAY
73332: NOT
73333: PUSH
73334: LD_EXP 61
73338: PUSH
73339: LD_VAR 0 2
73343: ARRAY
73344: PUSH
73345: LD_INT 1
73347: ARRAY
73348: OR
73349: PUSH
73350: LD_EXP 61
73354: PUSH
73355: LD_VAR 0 2
73359: ARRAY
73360: PUSH
73361: LD_INT 2
73363: ARRAY
73364: OR
73365: PUSH
73366: LD_EXP 84
73370: PUSH
73371: LD_VAR 0 2
73375: ARRAY
73376: PPUSH
73377: LD_INT 1
73379: PPUSH
73380: CALL_OW 325
73384: NOT
73385: OR
73386: PUSH
73387: LD_EXP 81
73391: PUSH
73392: LD_VAR 0 2
73396: ARRAY
73397: OR
73398: IFFALSE 73402
// continue ;
73400: GO 73319
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73402: LD_ADDR_VAR 0 8
73406: PUSH
73407: LD_EXP 58
73411: PUSH
73412: LD_VAR 0 2
73416: ARRAY
73417: PPUSH
73418: LD_INT 25
73420: PUSH
73421: LD_INT 4
73423: PUSH
73424: EMPTY
73425: LIST
73426: LIST
73427: PUSH
73428: LD_INT 50
73430: PUSH
73431: EMPTY
73432: LIST
73433: PUSH
73434: LD_INT 3
73436: PUSH
73437: LD_INT 60
73439: PUSH
73440: EMPTY
73441: LIST
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: LIST
73451: PPUSH
73452: CALL_OW 72
73456: PUSH
73457: LD_EXP 62
73461: PUSH
73462: LD_VAR 0 2
73466: ARRAY
73467: DIFF
73468: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73469: LD_ADDR_VAR 0 9
73473: PUSH
73474: LD_EXP 58
73478: PUSH
73479: LD_VAR 0 2
73483: ARRAY
73484: PPUSH
73485: LD_INT 2
73487: PUSH
73488: LD_INT 30
73490: PUSH
73491: LD_INT 0
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 30
73500: PUSH
73501: LD_INT 1
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: LIST
73512: PPUSH
73513: CALL_OW 72
73517: ST_TO_ADDR
// if not tmp or not dep then
73518: LD_VAR 0 8
73522: NOT
73523: PUSH
73524: LD_VAR 0 9
73528: NOT
73529: OR
73530: IFFALSE 73534
// continue ;
73532: GO 73319
// side := GetSide ( tmp [ 1 ] ) ;
73534: LD_ADDR_VAR 0 11
73538: PUSH
73539: LD_VAR 0 8
73543: PUSH
73544: LD_INT 1
73546: ARRAY
73547: PPUSH
73548: CALL_OW 255
73552: ST_TO_ADDR
// dep := dep [ 1 ] ;
73553: LD_ADDR_VAR 0 9
73557: PUSH
73558: LD_VAR 0 9
73562: PUSH
73563: LD_INT 1
73565: ARRAY
73566: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73567: LD_ADDR_VAR 0 7
73571: PUSH
73572: LD_EXP 86
73576: PUSH
73577: LD_VAR 0 2
73581: ARRAY
73582: PPUSH
73583: LD_INT 22
73585: PUSH
73586: LD_INT 0
73588: PUSH
73589: EMPTY
73590: LIST
73591: LIST
73592: PUSH
73593: LD_INT 25
73595: PUSH
73596: LD_INT 12
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: PPUSH
73607: CALL_OW 70
73611: PUSH
73612: LD_INT 22
73614: PUSH
73615: LD_INT 0
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: PUSH
73622: LD_INT 25
73624: PUSH
73625: LD_INT 12
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 91
73634: PUSH
73635: LD_VAR 0 9
73639: PUSH
73640: LD_INT 20
73642: PUSH
73643: EMPTY
73644: LIST
73645: LIST
73646: LIST
73647: PUSH
73648: EMPTY
73649: LIST
73650: LIST
73651: LIST
73652: PPUSH
73653: CALL_OW 69
73657: UNION
73658: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73659: LD_ADDR_VAR 0 10
73663: PUSH
73664: LD_EXP 86
73668: PUSH
73669: LD_VAR 0 2
73673: ARRAY
73674: PPUSH
73675: LD_INT 81
73677: PUSH
73678: LD_VAR 0 11
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PPUSH
73687: CALL_OW 70
73691: ST_TO_ADDR
// if not apes or danger_at_area then
73692: LD_VAR 0 7
73696: NOT
73697: PUSH
73698: LD_VAR 0 10
73702: OR
73703: IFFALSE 73753
// begin if mc_taming [ i ] then
73705: LD_EXP 89
73709: PUSH
73710: LD_VAR 0 2
73714: ARRAY
73715: IFFALSE 73751
// begin MC_Reset ( i , 121 ) ;
73717: LD_VAR 0 2
73721: PPUSH
73722: LD_INT 121
73724: PPUSH
73725: CALL 59388 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73729: LD_ADDR_EXP 89
73733: PUSH
73734: LD_EXP 89
73738: PPUSH
73739: LD_VAR 0 2
73743: PPUSH
73744: EMPTY
73745: PPUSH
73746: CALL_OW 1
73750: ST_TO_ADDR
// end ; continue ;
73751: GO 73319
// end ; for j in tmp do
73753: LD_ADDR_VAR 0 3
73757: PUSH
73758: LD_VAR 0 8
73762: PUSH
73763: FOR_IN
73764: IFFALSE 74100
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73766: LD_VAR 0 3
73770: PUSH
73771: LD_EXP 89
73775: PUSH
73776: LD_VAR 0 2
73780: ARRAY
73781: IN
73782: NOT
73783: PUSH
73784: LD_EXP 89
73788: PUSH
73789: LD_VAR 0 2
73793: ARRAY
73794: PUSH
73795: LD_INT 3
73797: LESS
73798: AND
73799: IFFALSE 73857
// begin SetTag ( j , 121 ) ;
73801: LD_VAR 0 3
73805: PPUSH
73806: LD_INT 121
73808: PPUSH
73809: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73813: LD_ADDR_EXP 89
73817: PUSH
73818: LD_EXP 89
73822: PPUSH
73823: LD_VAR 0 2
73827: PUSH
73828: LD_EXP 89
73832: PUSH
73833: LD_VAR 0 2
73837: ARRAY
73838: PUSH
73839: LD_INT 1
73841: PLUS
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PPUSH
73847: LD_VAR 0 3
73851: PPUSH
73852: CALL 20497 0 3
73856: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73857: LD_VAR 0 3
73861: PUSH
73862: LD_EXP 89
73866: PUSH
73867: LD_VAR 0 2
73871: ARRAY
73872: IN
73873: IFFALSE 74098
// begin if GetClass ( j ) <> 4 then
73875: LD_VAR 0 3
73879: PPUSH
73880: CALL_OW 257
73884: PUSH
73885: LD_INT 4
73887: NONEQUAL
73888: IFFALSE 73941
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73890: LD_ADDR_EXP 89
73894: PUSH
73895: LD_EXP 89
73899: PPUSH
73900: LD_VAR 0 2
73904: PPUSH
73905: LD_EXP 89
73909: PUSH
73910: LD_VAR 0 2
73914: ARRAY
73915: PUSH
73916: LD_VAR 0 3
73920: DIFF
73921: PPUSH
73922: CALL_OW 1
73926: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73927: LD_VAR 0 3
73931: PPUSH
73932: LD_INT 0
73934: PPUSH
73935: CALL_OW 109
// continue ;
73939: GO 73763
// end ; if IsInUnit ( j ) then
73941: LD_VAR 0 3
73945: PPUSH
73946: CALL_OW 310
73950: IFFALSE 73961
// ComExitBuilding ( j ) ;
73952: LD_VAR 0 3
73956: PPUSH
73957: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73961: LD_ADDR_VAR 0 6
73965: PUSH
73966: LD_VAR 0 7
73970: PPUSH
73971: LD_VAR 0 3
73975: PPUSH
73976: CALL_OW 74
73980: ST_TO_ADDR
// if not ape then
73981: LD_VAR 0 6
73985: NOT
73986: IFFALSE 73990
// break ;
73988: GO 74100
// x := GetX ( ape ) ;
73990: LD_ADDR_VAR 0 4
73994: PUSH
73995: LD_VAR 0 6
73999: PPUSH
74000: CALL_OW 250
74004: ST_TO_ADDR
// y := GetY ( ape ) ;
74005: LD_ADDR_VAR 0 5
74009: PUSH
74010: LD_VAR 0 6
74014: PPUSH
74015: CALL_OW 251
74019: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74020: LD_VAR 0 4
74024: PPUSH
74025: LD_VAR 0 5
74029: PPUSH
74030: CALL_OW 488
74034: NOT
74035: PUSH
74036: LD_VAR 0 11
74040: PPUSH
74041: LD_VAR 0 4
74045: PPUSH
74046: LD_VAR 0 5
74050: PPUSH
74051: LD_INT 20
74053: PPUSH
74054: CALL 21393 0 4
74058: PUSH
74059: LD_INT 4
74061: ARRAY
74062: OR
74063: IFFALSE 74067
// break ;
74065: GO 74100
// if not HasTask ( j ) then
74067: LD_VAR 0 3
74071: PPUSH
74072: CALL_OW 314
74076: NOT
74077: IFFALSE 74098
// ComTameXY ( j , x , y ) ;
74079: LD_VAR 0 3
74083: PPUSH
74084: LD_VAR 0 4
74088: PPUSH
74089: LD_VAR 0 5
74093: PPUSH
74094: CALL_OW 131
// end ; end ;
74098: GO 73763
74100: POP
74101: POP
// end ;
74102: GO 73319
74104: POP
74105: POP
// end ;
74106: LD_VAR 0 1
74110: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74111: LD_INT 0
74113: PPUSH
74114: PPUSH
74115: PPUSH
74116: PPUSH
74117: PPUSH
74118: PPUSH
74119: PPUSH
74120: PPUSH
// if not mc_bases then
74121: LD_EXP 58
74125: NOT
74126: IFFALSE 74130
// exit ;
74128: GO 74756
// for i = 1 to mc_bases do
74130: LD_ADDR_VAR 0 2
74134: PUSH
74135: DOUBLE
74136: LD_INT 1
74138: DEC
74139: ST_TO_ADDR
74140: LD_EXP 58
74144: PUSH
74145: FOR_TO
74146: IFFALSE 74754
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74148: LD_EXP 87
74152: PUSH
74153: LD_VAR 0 2
74157: ARRAY
74158: NOT
74159: PUSH
74160: LD_EXP 87
74164: PUSH
74165: LD_VAR 0 2
74169: ARRAY
74170: PPUSH
74171: LD_INT 25
74173: PUSH
74174: LD_INT 12
74176: PUSH
74177: EMPTY
74178: LIST
74179: LIST
74180: PPUSH
74181: CALL_OW 72
74185: NOT
74186: OR
74187: IFFALSE 74191
// continue ;
74189: GO 74145
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74191: LD_ADDR_VAR 0 5
74195: PUSH
74196: LD_EXP 87
74200: PUSH
74201: LD_VAR 0 2
74205: ARRAY
74206: PUSH
74207: LD_INT 1
74209: ARRAY
74210: PPUSH
74211: CALL_OW 255
74215: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74216: LD_VAR 0 5
74220: PPUSH
74221: LD_INT 2
74223: PPUSH
74224: CALL_OW 325
74228: IFFALSE 74481
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74230: LD_ADDR_VAR 0 4
74234: PUSH
74235: LD_EXP 87
74239: PUSH
74240: LD_VAR 0 2
74244: ARRAY
74245: PPUSH
74246: LD_INT 25
74248: PUSH
74249: LD_INT 16
74251: PUSH
74252: EMPTY
74253: LIST
74254: LIST
74255: PPUSH
74256: CALL_OW 72
74260: ST_TO_ADDR
// if tmp < 6 then
74261: LD_VAR 0 4
74265: PUSH
74266: LD_INT 6
74268: LESS
74269: IFFALSE 74481
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74271: LD_ADDR_VAR 0 6
74275: PUSH
74276: LD_EXP 58
74280: PUSH
74281: LD_VAR 0 2
74285: ARRAY
74286: PPUSH
74287: LD_INT 2
74289: PUSH
74290: LD_INT 30
74292: PUSH
74293: LD_INT 0
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: PUSH
74300: LD_INT 30
74302: PUSH
74303: LD_INT 1
74305: PUSH
74306: EMPTY
74307: LIST
74308: LIST
74309: PUSH
74310: EMPTY
74311: LIST
74312: LIST
74313: LIST
74314: PPUSH
74315: CALL_OW 72
74319: ST_TO_ADDR
// if depot then
74320: LD_VAR 0 6
74324: IFFALSE 74481
// begin selected := 0 ;
74326: LD_ADDR_VAR 0 7
74330: PUSH
74331: LD_INT 0
74333: ST_TO_ADDR
// for j in depot do
74334: LD_ADDR_VAR 0 3
74338: PUSH
74339: LD_VAR 0 6
74343: PUSH
74344: FOR_IN
74345: IFFALSE 74376
// begin if UnitsInside ( j ) < 6 then
74347: LD_VAR 0 3
74351: PPUSH
74352: CALL_OW 313
74356: PUSH
74357: LD_INT 6
74359: LESS
74360: IFFALSE 74374
// begin selected := j ;
74362: LD_ADDR_VAR 0 7
74366: PUSH
74367: LD_VAR 0 3
74371: ST_TO_ADDR
// break ;
74372: GO 74376
// end ; end ;
74374: GO 74344
74376: POP
74377: POP
// if selected then
74378: LD_VAR 0 7
74382: IFFALSE 74481
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74384: LD_ADDR_VAR 0 3
74388: PUSH
74389: LD_EXP 87
74393: PUSH
74394: LD_VAR 0 2
74398: ARRAY
74399: PPUSH
74400: LD_INT 25
74402: PUSH
74403: LD_INT 12
74405: PUSH
74406: EMPTY
74407: LIST
74408: LIST
74409: PPUSH
74410: CALL_OW 72
74414: PUSH
74415: FOR_IN
74416: IFFALSE 74479
// if not HasTask ( j ) then
74418: LD_VAR 0 3
74422: PPUSH
74423: CALL_OW 314
74427: NOT
74428: IFFALSE 74477
// begin if not IsInUnit ( j ) then
74430: LD_VAR 0 3
74434: PPUSH
74435: CALL_OW 310
74439: NOT
74440: IFFALSE 74456
// ComEnterUnit ( j , selected ) ;
74442: LD_VAR 0 3
74446: PPUSH
74447: LD_VAR 0 7
74451: PPUSH
74452: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74456: LD_VAR 0 3
74460: PPUSH
74461: LD_INT 16
74463: PPUSH
74464: CALL_OW 183
// AddComExitBuilding ( j ) ;
74468: LD_VAR 0 3
74472: PPUSH
74473: CALL_OW 182
// end ;
74477: GO 74415
74479: POP
74480: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74481: LD_VAR 0 5
74485: PPUSH
74486: LD_INT 11
74488: PPUSH
74489: CALL_OW 325
74493: IFFALSE 74752
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74495: LD_ADDR_VAR 0 4
74499: PUSH
74500: LD_EXP 87
74504: PUSH
74505: LD_VAR 0 2
74509: ARRAY
74510: PPUSH
74511: LD_INT 25
74513: PUSH
74514: LD_INT 16
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: PPUSH
74521: CALL_OW 72
74525: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74526: LD_VAR 0 4
74530: PUSH
74531: LD_INT 6
74533: GREATEREQUAL
74534: PUSH
74535: LD_VAR 0 5
74539: PPUSH
74540: LD_INT 2
74542: PPUSH
74543: CALL_OW 325
74547: NOT
74548: OR
74549: IFFALSE 74752
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74551: LD_ADDR_VAR 0 8
74555: PUSH
74556: LD_EXP 58
74560: PUSH
74561: LD_VAR 0 2
74565: ARRAY
74566: PPUSH
74567: LD_INT 2
74569: PUSH
74570: LD_INT 30
74572: PUSH
74573: LD_INT 4
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: LD_INT 30
74582: PUSH
74583: LD_INT 5
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: EMPTY
74591: LIST
74592: LIST
74593: LIST
74594: PPUSH
74595: CALL_OW 72
74599: ST_TO_ADDR
// if barracks then
74600: LD_VAR 0 8
74604: IFFALSE 74752
// begin selected := 0 ;
74606: LD_ADDR_VAR 0 7
74610: PUSH
74611: LD_INT 0
74613: ST_TO_ADDR
// for j in barracks do
74614: LD_ADDR_VAR 0 3
74618: PUSH
74619: LD_VAR 0 8
74623: PUSH
74624: FOR_IN
74625: IFFALSE 74656
// begin if UnitsInside ( j ) < 6 then
74627: LD_VAR 0 3
74631: PPUSH
74632: CALL_OW 313
74636: PUSH
74637: LD_INT 6
74639: LESS
74640: IFFALSE 74654
// begin selected := j ;
74642: LD_ADDR_VAR 0 7
74646: PUSH
74647: LD_VAR 0 3
74651: ST_TO_ADDR
// break ;
74652: GO 74656
// end ; end ;
74654: GO 74624
74656: POP
74657: POP
// if selected then
74658: LD_VAR 0 7
74662: IFFALSE 74752
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74664: LD_ADDR_VAR 0 3
74668: PUSH
74669: LD_EXP 87
74673: PUSH
74674: LD_VAR 0 2
74678: ARRAY
74679: PPUSH
74680: LD_INT 25
74682: PUSH
74683: LD_INT 12
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PPUSH
74690: CALL_OW 72
74694: PUSH
74695: FOR_IN
74696: IFFALSE 74750
// if not IsInUnit ( j ) and not HasTask ( j ) then
74698: LD_VAR 0 3
74702: PPUSH
74703: CALL_OW 310
74707: NOT
74708: PUSH
74709: LD_VAR 0 3
74713: PPUSH
74714: CALL_OW 314
74718: NOT
74719: AND
74720: IFFALSE 74748
// begin ComEnterUnit ( j , selected ) ;
74722: LD_VAR 0 3
74726: PPUSH
74727: LD_VAR 0 7
74731: PPUSH
74732: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74736: LD_VAR 0 3
74740: PPUSH
74741: LD_INT 15
74743: PPUSH
74744: CALL_OW 183
// end ;
74748: GO 74695
74750: POP
74751: POP
// end ; end ; end ; end ; end ;
74752: GO 74145
74754: POP
74755: POP
// end ;
74756: LD_VAR 0 1
74760: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74761: LD_INT 0
74763: PPUSH
74764: PPUSH
74765: PPUSH
74766: PPUSH
// if not mc_bases then
74767: LD_EXP 58
74771: NOT
74772: IFFALSE 74776
// exit ;
74774: GO 74954
// for i = 1 to mc_bases do
74776: LD_ADDR_VAR 0 2
74780: PUSH
74781: DOUBLE
74782: LD_INT 1
74784: DEC
74785: ST_TO_ADDR
74786: LD_EXP 58
74790: PUSH
74791: FOR_TO
74792: IFFALSE 74952
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74794: LD_ADDR_VAR 0 4
74798: PUSH
74799: LD_EXP 58
74803: PUSH
74804: LD_VAR 0 2
74808: ARRAY
74809: PPUSH
74810: LD_INT 25
74812: PUSH
74813: LD_INT 9
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PPUSH
74820: CALL_OW 72
74824: ST_TO_ADDR
// if not tmp then
74825: LD_VAR 0 4
74829: NOT
74830: IFFALSE 74834
// continue ;
74832: GO 74791
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74834: LD_EXP 84
74838: PUSH
74839: LD_VAR 0 2
74843: ARRAY
74844: PPUSH
74845: LD_INT 29
74847: PPUSH
74848: CALL_OW 325
74852: NOT
74853: PUSH
74854: LD_EXP 84
74858: PUSH
74859: LD_VAR 0 2
74863: ARRAY
74864: PPUSH
74865: LD_INT 28
74867: PPUSH
74868: CALL_OW 325
74872: NOT
74873: AND
74874: IFFALSE 74878
// continue ;
74876: GO 74791
// for j in tmp do
74878: LD_ADDR_VAR 0 3
74882: PUSH
74883: LD_VAR 0 4
74887: PUSH
74888: FOR_IN
74889: IFFALSE 74948
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74891: LD_VAR 0 3
74895: PUSH
74896: LD_EXP 61
74900: PUSH
74901: LD_VAR 0 2
74905: ARRAY
74906: PUSH
74907: LD_INT 1
74909: ARRAY
74910: IN
74911: NOT
74912: PUSH
74913: LD_VAR 0 3
74917: PUSH
74918: LD_EXP 61
74922: PUSH
74923: LD_VAR 0 2
74927: ARRAY
74928: PUSH
74929: LD_INT 2
74931: ARRAY
74932: IN
74933: NOT
74934: AND
74935: IFFALSE 74946
// ComSpaceTimeShoot ( j ) ;
74937: LD_VAR 0 3
74941: PPUSH
74942: CALL 14557 0 1
74946: GO 74888
74948: POP
74949: POP
// end ;
74950: GO 74791
74952: POP
74953: POP
// end ;
74954: LD_VAR 0 1
74958: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74959: LD_INT 0
74961: PPUSH
74962: PPUSH
74963: PPUSH
74964: PPUSH
74965: PPUSH
74966: PPUSH
74967: PPUSH
74968: PPUSH
74969: PPUSH
// if not mc_bases then
74970: LD_EXP 58
74974: NOT
74975: IFFALSE 74979
// exit ;
74977: GO 75601
// for i = 1 to mc_bases do
74979: LD_ADDR_VAR 0 2
74983: PUSH
74984: DOUBLE
74985: LD_INT 1
74987: DEC
74988: ST_TO_ADDR
74989: LD_EXP 58
74993: PUSH
74994: FOR_TO
74995: IFFALSE 75599
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74997: LD_EXP 93
75001: PUSH
75002: LD_VAR 0 2
75006: ARRAY
75007: NOT
75008: PUSH
75009: LD_INT 38
75011: PPUSH
75012: LD_EXP 84
75016: PUSH
75017: LD_VAR 0 2
75021: ARRAY
75022: PPUSH
75023: CALL_OW 321
75027: PUSH
75028: LD_INT 2
75030: NONEQUAL
75031: OR
75032: IFFALSE 75036
// continue ;
75034: GO 74994
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75036: LD_ADDR_VAR 0 8
75040: PUSH
75041: LD_EXP 58
75045: PUSH
75046: LD_VAR 0 2
75050: ARRAY
75051: PPUSH
75052: LD_INT 30
75054: PUSH
75055: LD_INT 34
75057: PUSH
75058: EMPTY
75059: LIST
75060: LIST
75061: PPUSH
75062: CALL_OW 72
75066: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75067: LD_ADDR_VAR 0 9
75071: PUSH
75072: LD_EXP 58
75076: PUSH
75077: LD_VAR 0 2
75081: ARRAY
75082: PPUSH
75083: LD_INT 25
75085: PUSH
75086: LD_INT 4
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PPUSH
75093: CALL_OW 72
75097: PPUSH
75098: LD_INT 0
75100: PPUSH
75101: CALL 53694 0 2
75105: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75106: LD_VAR 0 9
75110: NOT
75111: PUSH
75112: LD_VAR 0 8
75116: NOT
75117: OR
75118: PUSH
75119: LD_EXP 58
75123: PUSH
75124: LD_VAR 0 2
75128: ARRAY
75129: PPUSH
75130: LD_INT 124
75132: PPUSH
75133: CALL 53694 0 2
75137: OR
75138: IFFALSE 75142
// continue ;
75140: GO 74994
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75142: LD_EXP 94
75146: PUSH
75147: LD_VAR 0 2
75151: ARRAY
75152: PUSH
75153: LD_EXP 93
75157: PUSH
75158: LD_VAR 0 2
75162: ARRAY
75163: LESS
75164: PUSH
75165: LD_EXP 94
75169: PUSH
75170: LD_VAR 0 2
75174: ARRAY
75175: PUSH
75176: LD_VAR 0 8
75180: LESS
75181: AND
75182: IFFALSE 75597
// begin tmp := sci [ 1 ] ;
75184: LD_ADDR_VAR 0 7
75188: PUSH
75189: LD_VAR 0 9
75193: PUSH
75194: LD_INT 1
75196: ARRAY
75197: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75198: LD_VAR 0 7
75202: PPUSH
75203: LD_INT 124
75205: PPUSH
75206: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75210: LD_ADDR_VAR 0 3
75214: PUSH
75215: DOUBLE
75216: LD_EXP 93
75220: PUSH
75221: LD_VAR 0 2
75225: ARRAY
75226: INC
75227: ST_TO_ADDR
75228: LD_EXP 93
75232: PUSH
75233: LD_VAR 0 2
75237: ARRAY
75238: PUSH
75239: FOR_DOWNTO
75240: IFFALSE 75583
// begin if IsInUnit ( tmp ) then
75242: LD_VAR 0 7
75246: PPUSH
75247: CALL_OW 310
75251: IFFALSE 75262
// ComExitBuilding ( tmp ) ;
75253: LD_VAR 0 7
75257: PPUSH
75258: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75262: LD_INT 35
75264: PPUSH
75265: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75269: LD_VAR 0 7
75273: PPUSH
75274: CALL_OW 310
75278: NOT
75279: PUSH
75280: LD_VAR 0 7
75284: PPUSH
75285: CALL_OW 314
75289: NOT
75290: AND
75291: IFFALSE 75262
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75293: LD_ADDR_VAR 0 6
75297: PUSH
75298: LD_VAR 0 7
75302: PPUSH
75303: CALL_OW 250
75307: PUSH
75308: LD_VAR 0 7
75312: PPUSH
75313: CALL_OW 251
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75322: LD_INT 35
75324: PPUSH
75325: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75329: LD_ADDR_VAR 0 4
75333: PUSH
75334: LD_EXP 93
75338: PUSH
75339: LD_VAR 0 2
75343: ARRAY
75344: PUSH
75345: LD_VAR 0 3
75349: ARRAY
75350: PUSH
75351: LD_INT 1
75353: ARRAY
75354: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75355: LD_ADDR_VAR 0 5
75359: PUSH
75360: LD_EXP 93
75364: PUSH
75365: LD_VAR 0 2
75369: ARRAY
75370: PUSH
75371: LD_VAR 0 3
75375: ARRAY
75376: PUSH
75377: LD_INT 2
75379: ARRAY
75380: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75381: LD_VAR 0 7
75385: PPUSH
75386: LD_INT 10
75388: PPUSH
75389: CALL 23090 0 2
75393: PUSH
75394: LD_INT 4
75396: ARRAY
75397: IFFALSE 75435
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75399: LD_VAR 0 7
75403: PPUSH
75404: LD_VAR 0 6
75408: PUSH
75409: LD_INT 1
75411: ARRAY
75412: PPUSH
75413: LD_VAR 0 6
75417: PUSH
75418: LD_INT 2
75420: ARRAY
75421: PPUSH
75422: CALL_OW 111
// wait ( 0 0$10 ) ;
75426: LD_INT 350
75428: PPUSH
75429: CALL_OW 67
// end else
75433: GO 75461
// begin ComMoveXY ( tmp , x , y ) ;
75435: LD_VAR 0 7
75439: PPUSH
75440: LD_VAR 0 4
75444: PPUSH
75445: LD_VAR 0 5
75449: PPUSH
75450: CALL_OW 111
// wait ( 0 0$3 ) ;
75454: LD_INT 105
75456: PPUSH
75457: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75461: LD_VAR 0 7
75465: PPUSH
75466: LD_VAR 0 4
75470: PPUSH
75471: LD_VAR 0 5
75475: PPUSH
75476: CALL_OW 307
75480: IFFALSE 75322
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75482: LD_VAR 0 7
75486: PPUSH
75487: LD_VAR 0 4
75491: PPUSH
75492: LD_VAR 0 5
75496: PPUSH
75497: LD_VAR 0 8
75501: PUSH
75502: LD_VAR 0 3
75506: ARRAY
75507: PPUSH
75508: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75512: LD_INT 35
75514: PPUSH
75515: CALL_OW 67
// until not HasTask ( tmp ) ;
75519: LD_VAR 0 7
75523: PPUSH
75524: CALL_OW 314
75528: NOT
75529: IFFALSE 75512
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75531: LD_ADDR_EXP 94
75535: PUSH
75536: LD_EXP 94
75540: PPUSH
75541: LD_VAR 0 2
75545: PUSH
75546: LD_EXP 94
75550: PUSH
75551: LD_VAR 0 2
75555: ARRAY
75556: PUSH
75557: LD_INT 1
75559: PLUS
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PPUSH
75565: LD_VAR 0 8
75569: PUSH
75570: LD_VAR 0 3
75574: ARRAY
75575: PPUSH
75576: CALL 20497 0 3
75580: ST_TO_ADDR
// end ;
75581: GO 75239
75583: POP
75584: POP
// MC_Reset ( i , 124 ) ;
75585: LD_VAR 0 2
75589: PPUSH
75590: LD_INT 124
75592: PPUSH
75593: CALL 59388 0 2
// end ; end ;
75597: GO 74994
75599: POP
75600: POP
// end ;
75601: LD_VAR 0 1
75605: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75606: LD_INT 0
75608: PPUSH
75609: PPUSH
75610: PPUSH
// if not mc_bases then
75611: LD_EXP 58
75615: NOT
75616: IFFALSE 75620
// exit ;
75618: GO 76226
// for i = 1 to mc_bases do
75620: LD_ADDR_VAR 0 2
75624: PUSH
75625: DOUBLE
75626: LD_INT 1
75628: DEC
75629: ST_TO_ADDR
75630: LD_EXP 58
75634: PUSH
75635: FOR_TO
75636: IFFALSE 76224
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75638: LD_ADDR_VAR 0 3
75642: PUSH
75643: LD_EXP 58
75647: PUSH
75648: LD_VAR 0 2
75652: ARRAY
75653: PPUSH
75654: LD_INT 25
75656: PUSH
75657: LD_INT 4
75659: PUSH
75660: EMPTY
75661: LIST
75662: LIST
75663: PPUSH
75664: CALL_OW 72
75668: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75669: LD_VAR 0 3
75673: NOT
75674: PUSH
75675: LD_EXP 95
75679: PUSH
75680: LD_VAR 0 2
75684: ARRAY
75685: NOT
75686: OR
75687: PUSH
75688: LD_EXP 58
75692: PUSH
75693: LD_VAR 0 2
75697: ARRAY
75698: PPUSH
75699: LD_INT 2
75701: PUSH
75702: LD_INT 30
75704: PUSH
75705: LD_INT 0
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 30
75714: PUSH
75715: LD_INT 1
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: EMPTY
75723: LIST
75724: LIST
75725: LIST
75726: PPUSH
75727: CALL_OW 72
75731: NOT
75732: OR
75733: IFFALSE 75783
// begin if mc_deposits_finder [ i ] then
75735: LD_EXP 96
75739: PUSH
75740: LD_VAR 0 2
75744: ARRAY
75745: IFFALSE 75781
// begin MC_Reset ( i , 125 ) ;
75747: LD_VAR 0 2
75751: PPUSH
75752: LD_INT 125
75754: PPUSH
75755: CALL 59388 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75759: LD_ADDR_EXP 96
75763: PUSH
75764: LD_EXP 96
75768: PPUSH
75769: LD_VAR 0 2
75773: PPUSH
75774: EMPTY
75775: PPUSH
75776: CALL_OW 1
75780: ST_TO_ADDR
// end ; continue ;
75781: GO 75635
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75783: LD_EXP 95
75787: PUSH
75788: LD_VAR 0 2
75792: ARRAY
75793: PUSH
75794: LD_INT 1
75796: ARRAY
75797: PUSH
75798: LD_INT 3
75800: ARRAY
75801: PUSH
75802: LD_INT 1
75804: EQUAL
75805: PUSH
75806: LD_INT 20
75808: PPUSH
75809: LD_EXP 84
75813: PUSH
75814: LD_VAR 0 2
75818: ARRAY
75819: PPUSH
75820: CALL_OW 321
75824: PUSH
75825: LD_INT 2
75827: NONEQUAL
75828: AND
75829: IFFALSE 75879
// begin if mc_deposits_finder [ i ] then
75831: LD_EXP 96
75835: PUSH
75836: LD_VAR 0 2
75840: ARRAY
75841: IFFALSE 75877
// begin MC_Reset ( i , 125 ) ;
75843: LD_VAR 0 2
75847: PPUSH
75848: LD_INT 125
75850: PPUSH
75851: CALL 59388 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75855: LD_ADDR_EXP 96
75859: PUSH
75860: LD_EXP 96
75864: PPUSH
75865: LD_VAR 0 2
75869: PPUSH
75870: EMPTY
75871: PPUSH
75872: CALL_OW 1
75876: ST_TO_ADDR
// end ; continue ;
75877: GO 75635
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75879: LD_EXP 95
75883: PUSH
75884: LD_VAR 0 2
75888: ARRAY
75889: PUSH
75890: LD_INT 1
75892: ARRAY
75893: PUSH
75894: LD_INT 1
75896: ARRAY
75897: PPUSH
75898: LD_EXP 95
75902: PUSH
75903: LD_VAR 0 2
75907: ARRAY
75908: PUSH
75909: LD_INT 1
75911: ARRAY
75912: PUSH
75913: LD_INT 2
75915: ARRAY
75916: PPUSH
75917: LD_EXP 84
75921: PUSH
75922: LD_VAR 0 2
75926: ARRAY
75927: PPUSH
75928: CALL_OW 440
75932: IFFALSE 75975
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75934: LD_ADDR_EXP 95
75938: PUSH
75939: LD_EXP 95
75943: PPUSH
75944: LD_VAR 0 2
75948: PPUSH
75949: LD_EXP 95
75953: PUSH
75954: LD_VAR 0 2
75958: ARRAY
75959: PPUSH
75960: LD_INT 1
75962: PPUSH
75963: CALL_OW 3
75967: PPUSH
75968: CALL_OW 1
75972: ST_TO_ADDR
75973: GO 76222
// begin if not mc_deposits_finder [ i ] then
75975: LD_EXP 96
75979: PUSH
75980: LD_VAR 0 2
75984: ARRAY
75985: NOT
75986: IFFALSE 76038
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75988: LD_ADDR_EXP 96
75992: PUSH
75993: LD_EXP 96
75997: PPUSH
75998: LD_VAR 0 2
76002: PPUSH
76003: LD_VAR 0 3
76007: PUSH
76008: LD_INT 1
76010: ARRAY
76011: PUSH
76012: EMPTY
76013: LIST
76014: PPUSH
76015: CALL_OW 1
76019: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76020: LD_VAR 0 3
76024: PUSH
76025: LD_INT 1
76027: ARRAY
76028: PPUSH
76029: LD_INT 125
76031: PPUSH
76032: CALL_OW 109
// end else
76036: GO 76222
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76038: LD_EXP 96
76042: PUSH
76043: LD_VAR 0 2
76047: ARRAY
76048: PUSH
76049: LD_INT 1
76051: ARRAY
76052: PPUSH
76053: CALL_OW 310
76057: IFFALSE 76080
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76059: LD_EXP 96
76063: PUSH
76064: LD_VAR 0 2
76068: ARRAY
76069: PUSH
76070: LD_INT 1
76072: ARRAY
76073: PPUSH
76074: CALL_OW 122
76078: GO 76222
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76080: LD_EXP 96
76084: PUSH
76085: LD_VAR 0 2
76089: ARRAY
76090: PUSH
76091: LD_INT 1
76093: ARRAY
76094: PPUSH
76095: CALL_OW 314
76099: NOT
76100: PUSH
76101: LD_EXP 96
76105: PUSH
76106: LD_VAR 0 2
76110: ARRAY
76111: PUSH
76112: LD_INT 1
76114: ARRAY
76115: PPUSH
76116: LD_EXP 95
76120: PUSH
76121: LD_VAR 0 2
76125: ARRAY
76126: PUSH
76127: LD_INT 1
76129: ARRAY
76130: PUSH
76131: LD_INT 1
76133: ARRAY
76134: PPUSH
76135: LD_EXP 95
76139: PUSH
76140: LD_VAR 0 2
76144: ARRAY
76145: PUSH
76146: LD_INT 1
76148: ARRAY
76149: PUSH
76150: LD_INT 2
76152: ARRAY
76153: PPUSH
76154: CALL_OW 297
76158: PUSH
76159: LD_INT 6
76161: GREATER
76162: AND
76163: IFFALSE 76222
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76165: LD_EXP 96
76169: PUSH
76170: LD_VAR 0 2
76174: ARRAY
76175: PUSH
76176: LD_INT 1
76178: ARRAY
76179: PPUSH
76180: LD_EXP 95
76184: PUSH
76185: LD_VAR 0 2
76189: ARRAY
76190: PUSH
76191: LD_INT 1
76193: ARRAY
76194: PUSH
76195: LD_INT 1
76197: ARRAY
76198: PPUSH
76199: LD_EXP 95
76203: PUSH
76204: LD_VAR 0 2
76208: ARRAY
76209: PUSH
76210: LD_INT 1
76212: ARRAY
76213: PUSH
76214: LD_INT 2
76216: ARRAY
76217: PPUSH
76218: CALL_OW 111
// end ; end ; end ;
76222: GO 75635
76224: POP
76225: POP
// end ;
76226: LD_VAR 0 1
76230: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76231: LD_INT 0
76233: PPUSH
76234: PPUSH
76235: PPUSH
76236: PPUSH
76237: PPUSH
76238: PPUSH
76239: PPUSH
76240: PPUSH
76241: PPUSH
76242: PPUSH
76243: PPUSH
// if not mc_bases then
76244: LD_EXP 58
76248: NOT
76249: IFFALSE 76253
// exit ;
76251: GO 76977
// for i = 1 to mc_bases do
76253: LD_ADDR_VAR 0 2
76257: PUSH
76258: DOUBLE
76259: LD_INT 1
76261: DEC
76262: ST_TO_ADDR
76263: LD_EXP 58
76267: PUSH
76268: FOR_TO
76269: IFFALSE 76975
// begin if not mc_bases [ i ] then
76271: LD_EXP 58
76275: PUSH
76276: LD_VAR 0 2
76280: ARRAY
76281: NOT
76282: IFFALSE 76286
// continue ;
76284: GO 76268
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76286: LD_ADDR_VAR 0 7
76290: PUSH
76291: LD_EXP 58
76295: PUSH
76296: LD_VAR 0 2
76300: ARRAY
76301: PUSH
76302: LD_INT 1
76304: ARRAY
76305: PPUSH
76306: CALL_OW 248
76310: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76311: LD_VAR 0 7
76315: PUSH
76316: LD_INT 3
76318: EQUAL
76319: PUSH
76320: LD_EXP 77
76324: PUSH
76325: LD_VAR 0 2
76329: ARRAY
76330: PUSH
76331: LD_EXP 80
76335: PUSH
76336: LD_VAR 0 2
76340: ARRAY
76341: UNION
76342: PPUSH
76343: LD_INT 33
76345: PUSH
76346: LD_INT 2
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PPUSH
76353: CALL_OW 72
76357: NOT
76358: OR
76359: IFFALSE 76363
// continue ;
76361: GO 76268
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76363: LD_ADDR_VAR 0 9
76367: PUSH
76368: LD_EXP 58
76372: PUSH
76373: LD_VAR 0 2
76377: ARRAY
76378: PPUSH
76379: LD_INT 30
76381: PUSH
76382: LD_INT 36
76384: PUSH
76385: EMPTY
76386: LIST
76387: LIST
76388: PPUSH
76389: CALL_OW 72
76393: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76394: LD_ADDR_VAR 0 10
76398: PUSH
76399: LD_EXP 77
76403: PUSH
76404: LD_VAR 0 2
76408: ARRAY
76409: PPUSH
76410: LD_INT 34
76412: PUSH
76413: LD_INT 31
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PPUSH
76420: CALL_OW 72
76424: ST_TO_ADDR
// if not cts and not mcts then
76425: LD_VAR 0 9
76429: NOT
76430: PUSH
76431: LD_VAR 0 10
76435: NOT
76436: AND
76437: IFFALSE 76441
// continue ;
76439: GO 76268
// x := cts ;
76441: LD_ADDR_VAR 0 11
76445: PUSH
76446: LD_VAR 0 9
76450: ST_TO_ADDR
// if not x then
76451: LD_VAR 0 11
76455: NOT
76456: IFFALSE 76468
// x := mcts ;
76458: LD_ADDR_VAR 0 11
76462: PUSH
76463: LD_VAR 0 10
76467: ST_TO_ADDR
// if mc_remote_driver [ i ] then
76468: LD_EXP 98
76472: PUSH
76473: LD_VAR 0 2
76477: ARRAY
76478: IFFALSE 76747
// for j in mc_remote_driver [ i ] do
76480: LD_ADDR_VAR 0 3
76484: PUSH
76485: LD_EXP 98
76489: PUSH
76490: LD_VAR 0 2
76494: ARRAY
76495: PUSH
76496: FOR_IN
76497: IFFALSE 76745
// begin if GetClass ( j ) <> 3 then
76499: LD_VAR 0 3
76503: PPUSH
76504: CALL_OW 257
76508: PUSH
76509: LD_INT 3
76511: NONEQUAL
76512: IFFALSE 76565
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76514: LD_ADDR_EXP 98
76518: PUSH
76519: LD_EXP 98
76523: PPUSH
76524: LD_VAR 0 2
76528: PPUSH
76529: LD_EXP 98
76533: PUSH
76534: LD_VAR 0 2
76538: ARRAY
76539: PUSH
76540: LD_VAR 0 3
76544: DIFF
76545: PPUSH
76546: CALL_OW 1
76550: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76551: LD_VAR 0 3
76555: PPUSH
76556: LD_INT 0
76558: PPUSH
76559: CALL_OW 109
// continue ;
76563: GO 76496
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76565: LD_VAR 0 3
76569: PPUSH
76570: CALL_OW 310
76574: NOT
76575: PUSH
76576: LD_VAR 0 3
76580: PPUSH
76581: CALL_OW 310
76585: PPUSH
76586: CALL_OW 266
76590: PUSH
76591: LD_INT 36
76593: NONEQUAL
76594: PUSH
76595: LD_VAR 0 3
76599: PPUSH
76600: CALL 53782 0 1
76604: NOT
76605: AND
76606: OR
76607: IFFALSE 76743
// begin if IsInUnit ( j ) then
76609: LD_VAR 0 3
76613: PPUSH
76614: CALL_OW 310
76618: IFFALSE 76629
// ComExitBuilding ( j ) ;
76620: LD_VAR 0 3
76624: PPUSH
76625: CALL_OW 122
// ct := 0 ;
76629: LD_ADDR_VAR 0 8
76633: PUSH
76634: LD_INT 0
76636: ST_TO_ADDR
// for k in x do
76637: LD_ADDR_VAR 0 4
76641: PUSH
76642: LD_VAR 0 11
76646: PUSH
76647: FOR_IN
76648: IFFALSE 76721
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76650: LD_VAR 0 4
76654: PPUSH
76655: CALL_OW 264
76659: PUSH
76660: LD_INT 31
76662: EQUAL
76663: PUSH
76664: LD_VAR 0 4
76668: PPUSH
76669: CALL_OW 311
76673: NOT
76674: AND
76675: PUSH
76676: LD_VAR 0 4
76680: PPUSH
76681: CALL_OW 266
76685: PUSH
76686: LD_INT 36
76688: EQUAL
76689: PUSH
76690: LD_VAR 0 4
76694: PPUSH
76695: CALL_OW 313
76699: PUSH
76700: LD_INT 3
76702: LESS
76703: AND
76704: OR
76705: IFFALSE 76719
// begin ct := k ;
76707: LD_ADDR_VAR 0 8
76711: PUSH
76712: LD_VAR 0 4
76716: ST_TO_ADDR
// break ;
76717: GO 76721
// end ;
76719: GO 76647
76721: POP
76722: POP
// if ct then
76723: LD_VAR 0 8
76727: IFFALSE 76743
// ComEnterUnit ( j , ct ) ;
76729: LD_VAR 0 3
76733: PPUSH
76734: LD_VAR 0 8
76738: PPUSH
76739: CALL_OW 120
// end ; end ;
76743: GO 76496
76745: POP
76746: POP
// places := 0 ;
76747: LD_ADDR_VAR 0 5
76751: PUSH
76752: LD_INT 0
76754: ST_TO_ADDR
// for j = 1 to x do
76755: LD_ADDR_VAR 0 3
76759: PUSH
76760: DOUBLE
76761: LD_INT 1
76763: DEC
76764: ST_TO_ADDR
76765: LD_VAR 0 11
76769: PUSH
76770: FOR_TO
76771: IFFALSE 76826
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76773: LD_VAR 0 11
76777: PUSH
76778: LD_VAR 0 3
76782: ARRAY
76783: PPUSH
76784: CALL_OW 264
76788: PUSH
76789: LD_INT 31
76791: EQUAL
76792: IFFALSE 76810
// places := places + 1 else
76794: LD_ADDR_VAR 0 5
76798: PUSH
76799: LD_VAR 0 5
76803: PUSH
76804: LD_INT 1
76806: PLUS
76807: ST_TO_ADDR
76808: GO 76824
// places := places + 3 ;
76810: LD_ADDR_VAR 0 5
76814: PUSH
76815: LD_VAR 0 5
76819: PUSH
76820: LD_INT 3
76822: PLUS
76823: ST_TO_ADDR
76824: GO 76770
76826: POP
76827: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76828: LD_ADDR_VAR 0 6
76832: PUSH
76833: LD_EXP 58
76837: PUSH
76838: LD_VAR 0 2
76842: ARRAY
76843: PPUSH
76844: LD_INT 25
76846: PUSH
76847: LD_INT 3
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PPUSH
76854: CALL_OW 72
76858: PUSH
76859: LD_EXP 98
76863: PUSH
76864: LD_VAR 0 2
76868: ARRAY
76869: DIFF
76870: PPUSH
76871: LD_INT 3
76873: PPUSH
76874: CALL 54682 0 2
76878: ST_TO_ADDR
// if not tmp then
76879: LD_VAR 0 6
76883: NOT
76884: IFFALSE 76888
// continue ;
76886: GO 76268
// places := places - mc_remote_driver [ i ] ;
76888: LD_ADDR_VAR 0 5
76892: PUSH
76893: LD_VAR 0 5
76897: PUSH
76898: LD_EXP 98
76902: PUSH
76903: LD_VAR 0 2
76907: ARRAY
76908: MINUS
76909: ST_TO_ADDR
// if places then
76910: LD_VAR 0 5
76914: IFFALSE 76973
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76916: LD_ADDR_EXP 98
76920: PUSH
76921: LD_EXP 98
76925: PPUSH
76926: LD_VAR 0 2
76930: PPUSH
76931: LD_EXP 98
76935: PUSH
76936: LD_VAR 0 2
76940: ARRAY
76941: PUSH
76942: LD_VAR 0 6
76946: PUSH
76947: LD_INT 1
76949: ARRAY
76950: UNION
76951: PPUSH
76952: CALL_OW 1
76956: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76957: LD_VAR 0 6
76961: PUSH
76962: LD_INT 1
76964: ARRAY
76965: PPUSH
76966: LD_INT 126
76968: PPUSH
76969: CALL_OW 109
// end ; end ;
76973: GO 76268
76975: POP
76976: POP
// end ;
76977: LD_VAR 0 1
76981: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76982: LD_INT 0
76984: PPUSH
76985: PPUSH
76986: PPUSH
76987: PPUSH
76988: PPUSH
76989: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76990: LD_VAR 0 1
76994: NOT
76995: PUSH
76996: LD_VAR 0 2
77000: NOT
77001: OR
77002: PUSH
77003: LD_VAR 0 3
77007: NOT
77008: OR
77009: PUSH
77010: LD_VAR 0 4
77014: PUSH
77015: LD_INT 1
77017: PUSH
77018: LD_INT 2
77020: PUSH
77021: LD_INT 3
77023: PUSH
77024: LD_INT 4
77026: PUSH
77027: LD_INT 5
77029: PUSH
77030: LD_INT 8
77032: PUSH
77033: LD_INT 9
77035: PUSH
77036: LD_INT 15
77038: PUSH
77039: LD_INT 16
77041: PUSH
77042: EMPTY
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: IN
77053: NOT
77054: OR
77055: IFFALSE 77059
// exit ;
77057: GO 77959
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77059: LD_ADDR_VAR 0 2
77063: PUSH
77064: LD_VAR 0 2
77068: PPUSH
77069: LD_INT 21
77071: PUSH
77072: LD_INT 3
77074: PUSH
77075: EMPTY
77076: LIST
77077: LIST
77078: PUSH
77079: LD_INT 24
77081: PUSH
77082: LD_INT 250
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PPUSH
77093: CALL_OW 72
77097: ST_TO_ADDR
// case class of 1 , 15 :
77098: LD_VAR 0 4
77102: PUSH
77103: LD_INT 1
77105: DOUBLE
77106: EQUAL
77107: IFTRUE 77117
77109: LD_INT 15
77111: DOUBLE
77112: EQUAL
77113: IFTRUE 77117
77115: GO 77202
77117: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77118: LD_ADDR_VAR 0 8
77122: PUSH
77123: LD_VAR 0 2
77127: PPUSH
77128: LD_INT 2
77130: PUSH
77131: LD_INT 30
77133: PUSH
77134: LD_INT 32
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 30
77143: PUSH
77144: LD_INT 31
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: EMPTY
77152: LIST
77153: LIST
77154: LIST
77155: PPUSH
77156: CALL_OW 72
77160: PUSH
77161: LD_VAR 0 2
77165: PPUSH
77166: LD_INT 2
77168: PUSH
77169: LD_INT 30
77171: PUSH
77172: LD_INT 4
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 30
77181: PUSH
77182: LD_INT 5
77184: PUSH
77185: EMPTY
77186: LIST
77187: LIST
77188: PUSH
77189: EMPTY
77190: LIST
77191: LIST
77192: LIST
77193: PPUSH
77194: CALL_OW 72
77198: ADD
77199: ST_TO_ADDR
77200: GO 77448
77202: LD_INT 2
77204: DOUBLE
77205: EQUAL
77206: IFTRUE 77216
77208: LD_INT 16
77210: DOUBLE
77211: EQUAL
77212: IFTRUE 77216
77214: GO 77262
77216: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77217: LD_ADDR_VAR 0 8
77221: PUSH
77222: LD_VAR 0 2
77226: PPUSH
77227: LD_INT 2
77229: PUSH
77230: LD_INT 30
77232: PUSH
77233: LD_INT 0
77235: PUSH
77236: EMPTY
77237: LIST
77238: LIST
77239: PUSH
77240: LD_INT 30
77242: PUSH
77243: LD_INT 1
77245: PUSH
77246: EMPTY
77247: LIST
77248: LIST
77249: PUSH
77250: EMPTY
77251: LIST
77252: LIST
77253: LIST
77254: PPUSH
77255: CALL_OW 72
77259: ST_TO_ADDR
77260: GO 77448
77262: LD_INT 3
77264: DOUBLE
77265: EQUAL
77266: IFTRUE 77270
77268: GO 77316
77270: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77271: LD_ADDR_VAR 0 8
77275: PUSH
77276: LD_VAR 0 2
77280: PPUSH
77281: LD_INT 2
77283: PUSH
77284: LD_INT 30
77286: PUSH
77287: LD_INT 2
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 30
77296: PUSH
77297: LD_INT 3
77299: PUSH
77300: EMPTY
77301: LIST
77302: LIST
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: LIST
77308: PPUSH
77309: CALL_OW 72
77313: ST_TO_ADDR
77314: GO 77448
77316: LD_INT 4
77318: DOUBLE
77319: EQUAL
77320: IFTRUE 77324
77322: GO 77381
77324: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77325: LD_ADDR_VAR 0 8
77329: PUSH
77330: LD_VAR 0 2
77334: PPUSH
77335: LD_INT 2
77337: PUSH
77338: LD_INT 30
77340: PUSH
77341: LD_INT 6
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 30
77350: PUSH
77351: LD_INT 7
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 30
77360: PUSH
77361: LD_INT 8
77363: PUSH
77364: EMPTY
77365: LIST
77366: LIST
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: LIST
77372: LIST
77373: PPUSH
77374: CALL_OW 72
77378: ST_TO_ADDR
77379: GO 77448
77381: LD_INT 5
77383: DOUBLE
77384: EQUAL
77385: IFTRUE 77401
77387: LD_INT 8
77389: DOUBLE
77390: EQUAL
77391: IFTRUE 77401
77393: LD_INT 9
77395: DOUBLE
77396: EQUAL
77397: IFTRUE 77401
77399: GO 77447
77401: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77402: LD_ADDR_VAR 0 8
77406: PUSH
77407: LD_VAR 0 2
77411: PPUSH
77412: LD_INT 2
77414: PUSH
77415: LD_INT 30
77417: PUSH
77418: LD_INT 4
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 30
77427: PUSH
77428: LD_INT 5
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: LIST
77439: PPUSH
77440: CALL_OW 72
77444: ST_TO_ADDR
77445: GO 77448
77447: POP
// if not tmp then
77448: LD_VAR 0 8
77452: NOT
77453: IFFALSE 77457
// exit ;
77455: GO 77959
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77457: LD_VAR 0 4
77461: PUSH
77462: LD_INT 1
77464: PUSH
77465: LD_INT 15
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: IN
77472: PUSH
77473: LD_EXP 67
77477: PUSH
77478: LD_VAR 0 1
77482: ARRAY
77483: AND
77484: IFFALSE 77640
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77486: LD_ADDR_VAR 0 9
77490: PUSH
77491: LD_EXP 67
77495: PUSH
77496: LD_VAR 0 1
77500: ARRAY
77501: PUSH
77502: LD_INT 1
77504: ARRAY
77505: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77506: LD_VAR 0 9
77510: PUSH
77511: LD_EXP 68
77515: PUSH
77516: LD_VAR 0 1
77520: ARRAY
77521: IN
77522: NOT
77523: IFFALSE 77638
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77525: LD_ADDR_EXP 68
77529: PUSH
77530: LD_EXP 68
77534: PPUSH
77535: LD_VAR 0 1
77539: PUSH
77540: LD_EXP 68
77544: PUSH
77545: LD_VAR 0 1
77549: ARRAY
77550: PUSH
77551: LD_INT 1
77553: PLUS
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PPUSH
77559: LD_VAR 0 9
77563: PPUSH
77564: CALL 20497 0 3
77568: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77569: LD_ADDR_EXP 67
77573: PUSH
77574: LD_EXP 67
77578: PPUSH
77579: LD_VAR 0 1
77583: PPUSH
77584: LD_EXP 67
77588: PUSH
77589: LD_VAR 0 1
77593: ARRAY
77594: PUSH
77595: LD_VAR 0 9
77599: DIFF
77600: PPUSH
77601: CALL_OW 1
77605: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77606: LD_VAR 0 3
77610: PPUSH
77611: LD_EXP 68
77615: PUSH
77616: LD_VAR 0 1
77620: ARRAY
77621: PUSH
77622: LD_EXP 68
77626: PUSH
77627: LD_VAR 0 1
77631: ARRAY
77632: ARRAY
77633: PPUSH
77634: CALL_OW 120
// end ; exit ;
77638: GO 77959
// end ; if tmp > 1 then
77640: LD_VAR 0 8
77644: PUSH
77645: LD_INT 1
77647: GREATER
77648: IFFALSE 77752
// for i = 2 to tmp do
77650: LD_ADDR_VAR 0 6
77654: PUSH
77655: DOUBLE
77656: LD_INT 2
77658: DEC
77659: ST_TO_ADDR
77660: LD_VAR 0 8
77664: PUSH
77665: FOR_TO
77666: IFFALSE 77750
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77668: LD_VAR 0 8
77672: PUSH
77673: LD_VAR 0 6
77677: ARRAY
77678: PPUSH
77679: CALL_OW 461
77683: PUSH
77684: LD_INT 6
77686: EQUAL
77687: IFFALSE 77748
// begin x := tmp [ i ] ;
77689: LD_ADDR_VAR 0 9
77693: PUSH
77694: LD_VAR 0 8
77698: PUSH
77699: LD_VAR 0 6
77703: ARRAY
77704: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77705: LD_ADDR_VAR 0 8
77709: PUSH
77710: LD_VAR 0 8
77714: PPUSH
77715: LD_VAR 0 6
77719: PPUSH
77720: CALL_OW 3
77724: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77725: LD_ADDR_VAR 0 8
77729: PUSH
77730: LD_VAR 0 8
77734: PPUSH
77735: LD_INT 1
77737: PPUSH
77738: LD_VAR 0 9
77742: PPUSH
77743: CALL_OW 2
77747: ST_TO_ADDR
// end ;
77748: GO 77665
77750: POP
77751: POP
// for i in tmp do
77752: LD_ADDR_VAR 0 6
77756: PUSH
77757: LD_VAR 0 8
77761: PUSH
77762: FOR_IN
77763: IFFALSE 77832
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77765: LD_VAR 0 6
77769: PPUSH
77770: CALL_OW 313
77774: PUSH
77775: LD_INT 6
77777: LESS
77778: PUSH
77779: LD_VAR 0 6
77783: PPUSH
77784: CALL_OW 266
77788: PUSH
77789: LD_INT 31
77791: PUSH
77792: LD_INT 32
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: IN
77799: NOT
77800: AND
77801: PUSH
77802: LD_VAR 0 6
77806: PPUSH
77807: CALL_OW 313
77811: PUSH
77812: LD_INT 0
77814: EQUAL
77815: OR
77816: IFFALSE 77830
// begin j := i ;
77818: LD_ADDR_VAR 0 7
77822: PUSH
77823: LD_VAR 0 6
77827: ST_TO_ADDR
// break ;
77828: GO 77832
// end ; end ;
77830: GO 77762
77832: POP
77833: POP
// if j then
77834: LD_VAR 0 7
77838: IFFALSE 77856
// ComEnterUnit ( unit , j ) else
77840: LD_VAR 0 3
77844: PPUSH
77845: LD_VAR 0 7
77849: PPUSH
77850: CALL_OW 120
77854: GO 77959
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77856: LD_ADDR_VAR 0 10
77860: PUSH
77861: LD_VAR 0 2
77865: PPUSH
77866: LD_INT 2
77868: PUSH
77869: LD_INT 30
77871: PUSH
77872: LD_INT 0
77874: PUSH
77875: EMPTY
77876: LIST
77877: LIST
77878: PUSH
77879: LD_INT 30
77881: PUSH
77882: LD_INT 1
77884: PUSH
77885: EMPTY
77886: LIST
77887: LIST
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: LIST
77893: PPUSH
77894: CALL_OW 72
77898: ST_TO_ADDR
// if depot then
77899: LD_VAR 0 10
77903: IFFALSE 77959
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77905: LD_ADDR_VAR 0 10
77909: PUSH
77910: LD_VAR 0 10
77914: PPUSH
77915: LD_VAR 0 3
77919: PPUSH
77920: CALL_OW 74
77924: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77925: LD_VAR 0 3
77929: PPUSH
77930: LD_VAR 0 10
77934: PPUSH
77935: CALL_OW 296
77939: PUSH
77940: LD_INT 10
77942: GREATER
77943: IFFALSE 77959
// ComStandNearbyBuilding ( unit , depot ) ;
77945: LD_VAR 0 3
77949: PPUSH
77950: LD_VAR 0 10
77954: PPUSH
77955: CALL 15174 0 2
// end ; end ; end ;
77959: LD_VAR 0 5
77963: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77964: LD_INT 0
77966: PPUSH
77967: PPUSH
77968: PPUSH
77969: PPUSH
// if not mc_bases then
77970: LD_EXP 58
77974: NOT
77975: IFFALSE 77979
// exit ;
77977: GO 78218
// for i = 1 to mc_bases do
77979: LD_ADDR_VAR 0 2
77983: PUSH
77984: DOUBLE
77985: LD_INT 1
77987: DEC
77988: ST_TO_ADDR
77989: LD_EXP 58
77993: PUSH
77994: FOR_TO
77995: IFFALSE 78216
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77997: LD_ADDR_VAR 0 4
78001: PUSH
78002: LD_EXP 58
78006: PUSH
78007: LD_VAR 0 2
78011: ARRAY
78012: PPUSH
78013: LD_INT 21
78015: PUSH
78016: LD_INT 1
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PPUSH
78023: CALL_OW 72
78027: PUSH
78028: LD_EXP 87
78032: PUSH
78033: LD_VAR 0 2
78037: ARRAY
78038: UNION
78039: ST_TO_ADDR
// if not tmp then
78040: LD_VAR 0 4
78044: NOT
78045: IFFALSE 78049
// continue ;
78047: GO 77994
// for j in tmp do
78049: LD_ADDR_VAR 0 3
78053: PUSH
78054: LD_VAR 0 4
78058: PUSH
78059: FOR_IN
78060: IFFALSE 78212
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78062: LD_VAR 0 3
78066: PPUSH
78067: CALL_OW 110
78071: NOT
78072: PUSH
78073: LD_VAR 0 3
78077: PPUSH
78078: CALL_OW 314
78082: NOT
78083: AND
78084: PUSH
78085: LD_VAR 0 3
78089: PPUSH
78090: CALL_OW 311
78094: NOT
78095: AND
78096: PUSH
78097: LD_VAR 0 3
78101: PPUSH
78102: CALL_OW 310
78106: NOT
78107: AND
78108: PUSH
78109: LD_VAR 0 3
78113: PUSH
78114: LD_EXP 61
78118: PUSH
78119: LD_VAR 0 2
78123: ARRAY
78124: PUSH
78125: LD_INT 1
78127: ARRAY
78128: IN
78129: NOT
78130: AND
78131: PUSH
78132: LD_VAR 0 3
78136: PUSH
78137: LD_EXP 61
78141: PUSH
78142: LD_VAR 0 2
78146: ARRAY
78147: PUSH
78148: LD_INT 2
78150: ARRAY
78151: IN
78152: NOT
78153: AND
78154: PUSH
78155: LD_VAR 0 3
78159: PUSH
78160: LD_EXP 70
78164: PUSH
78165: LD_VAR 0 2
78169: ARRAY
78170: IN
78171: NOT
78172: AND
78173: IFFALSE 78210
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78175: LD_VAR 0 2
78179: PPUSH
78180: LD_EXP 58
78184: PUSH
78185: LD_VAR 0 2
78189: ARRAY
78190: PPUSH
78191: LD_VAR 0 3
78195: PPUSH
78196: LD_VAR 0 3
78200: PPUSH
78201: CALL_OW 257
78205: PPUSH
78206: CALL 76982 0 4
// end ;
78210: GO 78059
78212: POP
78213: POP
// end ;
78214: GO 77994
78216: POP
78217: POP
// end ;
78218: LD_VAR 0 1
78222: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78223: LD_INT 0
78225: PPUSH
78226: PPUSH
78227: PPUSH
78228: PPUSH
78229: PPUSH
78230: PPUSH
// if not mc_bases [ base ] then
78231: LD_EXP 58
78235: PUSH
78236: LD_VAR 0 1
78240: ARRAY
78241: NOT
78242: IFFALSE 78246
// exit ;
78244: GO 78428
// tmp := [ ] ;
78246: LD_ADDR_VAR 0 6
78250: PUSH
78251: EMPTY
78252: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78253: LD_ADDR_VAR 0 7
78257: PUSH
78258: LD_VAR 0 3
78262: PPUSH
78263: LD_INT 0
78265: PPUSH
78266: CALL_OW 517
78270: ST_TO_ADDR
// if not list then
78271: LD_VAR 0 7
78275: NOT
78276: IFFALSE 78280
// exit ;
78278: GO 78428
// for i = 1 to amount do
78280: LD_ADDR_VAR 0 5
78284: PUSH
78285: DOUBLE
78286: LD_INT 1
78288: DEC
78289: ST_TO_ADDR
78290: LD_VAR 0 2
78294: PUSH
78295: FOR_TO
78296: IFFALSE 78376
// begin x := rand ( 1 , list [ 1 ] ) ;
78298: LD_ADDR_VAR 0 8
78302: PUSH
78303: LD_INT 1
78305: PPUSH
78306: LD_VAR 0 7
78310: PUSH
78311: LD_INT 1
78313: ARRAY
78314: PPUSH
78315: CALL_OW 12
78319: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78320: LD_ADDR_VAR 0 6
78324: PUSH
78325: LD_VAR 0 6
78329: PPUSH
78330: LD_VAR 0 5
78334: PPUSH
78335: LD_VAR 0 7
78339: PUSH
78340: LD_INT 1
78342: ARRAY
78343: PUSH
78344: LD_VAR 0 8
78348: ARRAY
78349: PUSH
78350: LD_VAR 0 7
78354: PUSH
78355: LD_INT 2
78357: ARRAY
78358: PUSH
78359: LD_VAR 0 8
78363: ARRAY
78364: PUSH
78365: EMPTY
78366: LIST
78367: LIST
78368: PPUSH
78369: CALL_OW 1
78373: ST_TO_ADDR
// end ;
78374: GO 78295
78376: POP
78377: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78378: LD_ADDR_EXP 71
78382: PUSH
78383: LD_EXP 71
78387: PPUSH
78388: LD_VAR 0 1
78392: PPUSH
78393: LD_VAR 0 6
78397: PPUSH
78398: CALL_OW 1
78402: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78403: LD_ADDR_EXP 73
78407: PUSH
78408: LD_EXP 73
78412: PPUSH
78413: LD_VAR 0 1
78417: PPUSH
78418: LD_VAR 0 3
78422: PPUSH
78423: CALL_OW 1
78427: ST_TO_ADDR
// end ;
78428: LD_VAR 0 4
78432: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78433: LD_INT 0
78435: PPUSH
// if not mc_bases [ base ] then
78436: LD_EXP 58
78440: PUSH
78441: LD_VAR 0 1
78445: ARRAY
78446: NOT
78447: IFFALSE 78451
// exit ;
78449: GO 78476
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78451: LD_ADDR_EXP 63
78455: PUSH
78456: LD_EXP 63
78460: PPUSH
78461: LD_VAR 0 1
78465: PPUSH
78466: LD_VAR 0 2
78470: PPUSH
78471: CALL_OW 1
78475: ST_TO_ADDR
// end ;
78476: LD_VAR 0 3
78480: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78481: LD_INT 0
78483: PPUSH
// if not mc_bases [ base ] then
78484: LD_EXP 58
78488: PUSH
78489: LD_VAR 0 1
78493: ARRAY
78494: NOT
78495: IFFALSE 78499
// exit ;
78497: GO 78536
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78499: LD_ADDR_EXP 63
78503: PUSH
78504: LD_EXP 63
78508: PPUSH
78509: LD_VAR 0 1
78513: PPUSH
78514: LD_EXP 63
78518: PUSH
78519: LD_VAR 0 1
78523: ARRAY
78524: PUSH
78525: LD_VAR 0 2
78529: UNION
78530: PPUSH
78531: CALL_OW 1
78535: ST_TO_ADDR
// end ;
78536: LD_VAR 0 3
78540: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78541: LD_INT 0
78543: PPUSH
// if not mc_bases [ base ] then
78544: LD_EXP 58
78548: PUSH
78549: LD_VAR 0 1
78553: ARRAY
78554: NOT
78555: IFFALSE 78559
// exit ;
78557: GO 78584
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78559: LD_ADDR_EXP 79
78563: PUSH
78564: LD_EXP 79
78568: PPUSH
78569: LD_VAR 0 1
78573: PPUSH
78574: LD_VAR 0 2
78578: PPUSH
78579: CALL_OW 1
78583: ST_TO_ADDR
// end ;
78584: LD_VAR 0 3
78588: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78589: LD_INT 0
78591: PPUSH
// if not mc_bases [ base ] then
78592: LD_EXP 58
78596: PUSH
78597: LD_VAR 0 1
78601: ARRAY
78602: NOT
78603: IFFALSE 78607
// exit ;
78605: GO 78644
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78607: LD_ADDR_EXP 79
78611: PUSH
78612: LD_EXP 79
78616: PPUSH
78617: LD_VAR 0 1
78621: PPUSH
78622: LD_EXP 79
78626: PUSH
78627: LD_VAR 0 1
78631: ARRAY
78632: PUSH
78633: LD_VAR 0 2
78637: ADD
78638: PPUSH
78639: CALL_OW 1
78643: ST_TO_ADDR
// end ;
78644: LD_VAR 0 3
78648: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78649: LD_INT 0
78651: PPUSH
// if not mc_bases [ base ] then
78652: LD_EXP 58
78656: PUSH
78657: LD_VAR 0 1
78661: ARRAY
78662: NOT
78663: IFFALSE 78667
// exit ;
78665: GO 78721
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78667: LD_ADDR_EXP 80
78671: PUSH
78672: LD_EXP 80
78676: PPUSH
78677: LD_VAR 0 1
78681: PPUSH
78682: LD_VAR 0 2
78686: PPUSH
78687: CALL_OW 1
78691: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78692: LD_ADDR_EXP 69
78696: PUSH
78697: LD_EXP 69
78701: PPUSH
78702: LD_VAR 0 1
78706: PPUSH
78707: LD_VAR 0 2
78711: PUSH
78712: LD_INT 0
78714: PLUS
78715: PPUSH
78716: CALL_OW 1
78720: ST_TO_ADDR
// end ;
78721: LD_VAR 0 3
78725: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78726: LD_INT 0
78728: PPUSH
// if not mc_bases [ base ] then
78729: LD_EXP 58
78733: PUSH
78734: LD_VAR 0 1
78738: ARRAY
78739: NOT
78740: IFFALSE 78744
// exit ;
78742: GO 78769
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78744: LD_ADDR_EXP 69
78748: PUSH
78749: LD_EXP 69
78753: PPUSH
78754: LD_VAR 0 1
78758: PPUSH
78759: LD_VAR 0 2
78763: PPUSH
78764: CALL_OW 1
78768: ST_TO_ADDR
// end ;
78769: LD_VAR 0 3
78773: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78774: LD_INT 0
78776: PPUSH
78777: PPUSH
78778: PPUSH
78779: PPUSH
// if not mc_bases [ base ] then
78780: LD_EXP 58
78784: PUSH
78785: LD_VAR 0 1
78789: ARRAY
78790: NOT
78791: IFFALSE 78795
// exit ;
78793: GO 78860
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78795: LD_ADDR_EXP 78
78799: PUSH
78800: LD_EXP 78
78804: PPUSH
78805: LD_VAR 0 1
78809: PUSH
78810: LD_EXP 78
78814: PUSH
78815: LD_VAR 0 1
78819: ARRAY
78820: PUSH
78821: LD_INT 1
78823: PLUS
78824: PUSH
78825: EMPTY
78826: LIST
78827: LIST
78828: PPUSH
78829: LD_VAR 0 1
78833: PUSH
78834: LD_VAR 0 2
78838: PUSH
78839: LD_VAR 0 3
78843: PUSH
78844: LD_VAR 0 4
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: PPUSH
78855: CALL 20497 0 3
78859: ST_TO_ADDR
// end ;
78860: LD_VAR 0 5
78864: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78865: LD_INT 0
78867: PPUSH
// if not mc_bases [ base ] then
78868: LD_EXP 58
78872: PUSH
78873: LD_VAR 0 1
78877: ARRAY
78878: NOT
78879: IFFALSE 78883
// exit ;
78881: GO 78908
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78883: LD_ADDR_EXP 95
78887: PUSH
78888: LD_EXP 95
78892: PPUSH
78893: LD_VAR 0 1
78897: PPUSH
78898: LD_VAR 0 2
78902: PPUSH
78903: CALL_OW 1
78907: ST_TO_ADDR
// end ;
78908: LD_VAR 0 3
78912: RET
// export function MC_GetMinesField ( base ) ; begin
78913: LD_INT 0
78915: PPUSH
// result := mc_mines [ base ] ;
78916: LD_ADDR_VAR 0 2
78920: PUSH
78921: LD_EXP 71
78925: PUSH
78926: LD_VAR 0 1
78930: ARRAY
78931: ST_TO_ADDR
// end ;
78932: LD_VAR 0 2
78936: RET
// export function MC_GetProduceList ( base ) ; begin
78937: LD_INT 0
78939: PPUSH
// result := mc_produce [ base ] ;
78940: LD_ADDR_VAR 0 2
78944: PUSH
78945: LD_EXP 79
78949: PUSH
78950: LD_VAR 0 1
78954: ARRAY
78955: ST_TO_ADDR
// end ;
78956: LD_VAR 0 2
78960: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78961: LD_INT 0
78963: PPUSH
78964: PPUSH
// if not mc_bases then
78965: LD_EXP 58
78969: NOT
78970: IFFALSE 78974
// exit ;
78972: GO 79039
// if mc_bases [ base ] then
78974: LD_EXP 58
78978: PUSH
78979: LD_VAR 0 1
78983: ARRAY
78984: IFFALSE 79039
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78986: LD_ADDR_VAR 0 3
78990: PUSH
78991: LD_EXP 58
78995: PUSH
78996: LD_VAR 0 1
79000: ARRAY
79001: PPUSH
79002: LD_INT 30
79004: PUSH
79005: LD_VAR 0 2
79009: PUSH
79010: EMPTY
79011: LIST
79012: LIST
79013: PPUSH
79014: CALL_OW 72
79018: ST_TO_ADDR
// if result then
79019: LD_VAR 0 3
79023: IFFALSE 79039
// result := result [ 1 ] ;
79025: LD_ADDR_VAR 0 3
79029: PUSH
79030: LD_VAR 0 3
79034: PUSH
79035: LD_INT 1
79037: ARRAY
79038: ST_TO_ADDR
// end ; end ;
79039: LD_VAR 0 3
79043: RET
// export function MC_SetTame ( base , area ) ; begin
79044: LD_INT 0
79046: PPUSH
// if not mc_bases or not base then
79047: LD_EXP 58
79051: NOT
79052: PUSH
79053: LD_VAR 0 1
79057: NOT
79058: OR
79059: IFFALSE 79063
// exit ;
79061: GO 79088
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79063: LD_ADDR_EXP 86
79067: PUSH
79068: LD_EXP 86
79072: PPUSH
79073: LD_VAR 0 1
79077: PPUSH
79078: LD_VAR 0 2
79082: PPUSH
79083: CALL_OW 1
79087: ST_TO_ADDR
// end ;
79088: LD_VAR 0 3
79092: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79093: LD_INT 0
79095: PPUSH
79096: PPUSH
// if not mc_bases or not base then
79097: LD_EXP 58
79101: NOT
79102: PUSH
79103: LD_VAR 0 1
79107: NOT
79108: OR
79109: IFFALSE 79113
// exit ;
79111: GO 79215
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79113: LD_ADDR_VAR 0 4
79117: PUSH
79118: LD_EXP 58
79122: PUSH
79123: LD_VAR 0 1
79127: ARRAY
79128: PPUSH
79129: LD_INT 30
79131: PUSH
79132: LD_VAR 0 2
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PPUSH
79141: CALL_OW 72
79145: ST_TO_ADDR
// if not tmp then
79146: LD_VAR 0 4
79150: NOT
79151: IFFALSE 79155
// exit ;
79153: GO 79215
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79155: LD_ADDR_EXP 90
79159: PUSH
79160: LD_EXP 90
79164: PPUSH
79165: LD_VAR 0 1
79169: PPUSH
79170: LD_EXP 90
79174: PUSH
79175: LD_VAR 0 1
79179: ARRAY
79180: PPUSH
79181: LD_EXP 90
79185: PUSH
79186: LD_VAR 0 1
79190: ARRAY
79191: PUSH
79192: LD_INT 1
79194: PLUS
79195: PPUSH
79196: LD_VAR 0 4
79200: PUSH
79201: LD_INT 1
79203: ARRAY
79204: PPUSH
79205: CALL_OW 2
79209: PPUSH
79210: CALL_OW 1
79214: ST_TO_ADDR
// end ;
79215: LD_VAR 0 3
79219: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79220: LD_INT 0
79222: PPUSH
79223: PPUSH
// if not mc_bases or not base or not kinds then
79224: LD_EXP 58
79228: NOT
79229: PUSH
79230: LD_VAR 0 1
79234: NOT
79235: OR
79236: PUSH
79237: LD_VAR 0 2
79241: NOT
79242: OR
79243: IFFALSE 79247
// exit ;
79245: GO 79308
// for i in kinds do
79247: LD_ADDR_VAR 0 4
79251: PUSH
79252: LD_VAR 0 2
79256: PUSH
79257: FOR_IN
79258: IFFALSE 79306
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79260: LD_ADDR_EXP 92
79264: PUSH
79265: LD_EXP 92
79269: PPUSH
79270: LD_VAR 0 1
79274: PUSH
79275: LD_EXP 92
79279: PUSH
79280: LD_VAR 0 1
79284: ARRAY
79285: PUSH
79286: LD_INT 1
79288: PLUS
79289: PUSH
79290: EMPTY
79291: LIST
79292: LIST
79293: PPUSH
79294: LD_VAR 0 4
79298: PPUSH
79299: CALL 20497 0 3
79303: ST_TO_ADDR
79304: GO 79257
79306: POP
79307: POP
// end ;
79308: LD_VAR 0 3
79312: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79313: LD_INT 0
79315: PPUSH
// if not mc_bases or not base or not areas then
79316: LD_EXP 58
79320: NOT
79321: PUSH
79322: LD_VAR 0 1
79326: NOT
79327: OR
79328: PUSH
79329: LD_VAR 0 2
79333: NOT
79334: OR
79335: IFFALSE 79339
// exit ;
79337: GO 79364
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79339: LD_ADDR_EXP 76
79343: PUSH
79344: LD_EXP 76
79348: PPUSH
79349: LD_VAR 0 1
79353: PPUSH
79354: LD_VAR 0 2
79358: PPUSH
79359: CALL_OW 1
79363: ST_TO_ADDR
// end ;
79364: LD_VAR 0 3
79368: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79369: LD_INT 0
79371: PPUSH
// if not mc_bases or not base or not teleports_exit then
79372: LD_EXP 58
79376: NOT
79377: PUSH
79378: LD_VAR 0 1
79382: NOT
79383: OR
79384: PUSH
79385: LD_VAR 0 2
79389: NOT
79390: OR
79391: IFFALSE 79395
// exit ;
79393: GO 79420
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79395: LD_ADDR_EXP 93
79399: PUSH
79400: LD_EXP 93
79404: PPUSH
79405: LD_VAR 0 1
79409: PPUSH
79410: LD_VAR 0 2
79414: PPUSH
79415: CALL_OW 1
79419: ST_TO_ADDR
// end ;
79420: LD_VAR 0 3
79424: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79425: LD_INT 0
79427: PPUSH
79428: PPUSH
79429: PPUSH
// if not mc_bases or not base or not ext_list then
79430: LD_EXP 58
79434: NOT
79435: PUSH
79436: LD_VAR 0 1
79440: NOT
79441: OR
79442: PUSH
79443: LD_VAR 0 5
79447: NOT
79448: OR
79449: IFFALSE 79453
// exit ;
79451: GO 79626
// tmp := GetFacExtXYD ( x , y , d ) ;
79453: LD_ADDR_VAR 0 8
79457: PUSH
79458: LD_VAR 0 2
79462: PPUSH
79463: LD_VAR 0 3
79467: PPUSH
79468: LD_VAR 0 4
79472: PPUSH
79473: CALL 53812 0 3
79477: ST_TO_ADDR
// if not tmp then
79478: LD_VAR 0 8
79482: NOT
79483: IFFALSE 79487
// exit ;
79485: GO 79626
// for i in tmp do
79487: LD_ADDR_VAR 0 7
79491: PUSH
79492: LD_VAR 0 8
79496: PUSH
79497: FOR_IN
79498: IFFALSE 79624
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79500: LD_ADDR_EXP 63
79504: PUSH
79505: LD_EXP 63
79509: PPUSH
79510: LD_VAR 0 1
79514: PPUSH
79515: LD_EXP 63
79519: PUSH
79520: LD_VAR 0 1
79524: ARRAY
79525: PPUSH
79526: LD_EXP 63
79530: PUSH
79531: LD_VAR 0 1
79535: ARRAY
79536: PUSH
79537: LD_INT 1
79539: PLUS
79540: PPUSH
79541: LD_VAR 0 5
79545: PUSH
79546: LD_INT 1
79548: ARRAY
79549: PUSH
79550: LD_VAR 0 7
79554: PUSH
79555: LD_INT 1
79557: ARRAY
79558: PUSH
79559: LD_VAR 0 7
79563: PUSH
79564: LD_INT 2
79566: ARRAY
79567: PUSH
79568: LD_VAR 0 7
79572: PUSH
79573: LD_INT 3
79575: ARRAY
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: LIST
79581: LIST
79582: PPUSH
79583: CALL_OW 2
79587: PPUSH
79588: CALL_OW 1
79592: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79593: LD_ADDR_VAR 0 5
79597: PUSH
79598: LD_VAR 0 5
79602: PPUSH
79603: LD_INT 1
79605: PPUSH
79606: CALL_OW 3
79610: ST_TO_ADDR
// if not ext_list then
79611: LD_VAR 0 5
79615: NOT
79616: IFFALSE 79622
// exit ;
79618: POP
79619: POP
79620: GO 79626
// end ;
79622: GO 79497
79624: POP
79625: POP
// end ;
79626: LD_VAR 0 6
79630: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79631: LD_INT 0
79633: PPUSH
// if not mc_bases or not base or not weapon_list then
79634: LD_EXP 58
79638: NOT
79639: PUSH
79640: LD_VAR 0 1
79644: NOT
79645: OR
79646: PUSH
79647: LD_VAR 0 2
79651: NOT
79652: OR
79653: IFFALSE 79657
// exit ;
79655: GO 79682
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79657: LD_ADDR_EXP 97
79661: PUSH
79662: LD_EXP 97
79666: PPUSH
79667: LD_VAR 0 1
79671: PPUSH
79672: LD_VAR 0 2
79676: PPUSH
79677: CALL_OW 1
79681: ST_TO_ADDR
// end ;
79682: LD_VAR 0 3
79686: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79687: LD_INT 0
79689: PPUSH
// if not mc_bases or not base or not tech_list then
79690: LD_EXP 58
79694: NOT
79695: PUSH
79696: LD_VAR 0 1
79700: NOT
79701: OR
79702: PUSH
79703: LD_VAR 0 2
79707: NOT
79708: OR
79709: IFFALSE 79713
// exit ;
79711: GO 79738
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79713: LD_ADDR_EXP 85
79717: PUSH
79718: LD_EXP 85
79722: PPUSH
79723: LD_VAR 0 1
79727: PPUSH
79728: LD_VAR 0 2
79732: PPUSH
79733: CALL_OW 1
79737: ST_TO_ADDR
// end ;
79738: LD_VAR 0 3
79742: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79743: LD_INT 0
79745: PPUSH
// if not mc_bases or not parking_area or not base then
79746: LD_EXP 58
79750: NOT
79751: PUSH
79752: LD_VAR 0 2
79756: NOT
79757: OR
79758: PUSH
79759: LD_VAR 0 1
79763: NOT
79764: OR
79765: IFFALSE 79769
// exit ;
79767: GO 79794
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79769: LD_ADDR_EXP 82
79773: PUSH
79774: LD_EXP 82
79778: PPUSH
79779: LD_VAR 0 1
79783: PPUSH
79784: LD_VAR 0 2
79788: PPUSH
79789: CALL_OW 1
79793: ST_TO_ADDR
// end ;
79794: LD_VAR 0 3
79798: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79799: LD_INT 0
79801: PPUSH
// if not mc_bases or not base or not scan_area then
79802: LD_EXP 58
79806: NOT
79807: PUSH
79808: LD_VAR 0 1
79812: NOT
79813: OR
79814: PUSH
79815: LD_VAR 0 2
79819: NOT
79820: OR
79821: IFFALSE 79825
// exit ;
79823: GO 79850
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79825: LD_ADDR_EXP 83
79829: PUSH
79830: LD_EXP 83
79834: PPUSH
79835: LD_VAR 0 1
79839: PPUSH
79840: LD_VAR 0 2
79844: PPUSH
79845: CALL_OW 1
79849: ST_TO_ADDR
// end ;
79850: LD_VAR 0 3
79854: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79855: LD_INT 0
79857: PPUSH
79858: PPUSH
// if not mc_bases or not base then
79859: LD_EXP 58
79863: NOT
79864: PUSH
79865: LD_VAR 0 1
79869: NOT
79870: OR
79871: IFFALSE 79875
// exit ;
79873: GO 79939
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79875: LD_ADDR_VAR 0 3
79879: PUSH
79880: LD_INT 1
79882: PUSH
79883: LD_INT 2
79885: PUSH
79886: LD_INT 3
79888: PUSH
79889: LD_INT 4
79891: PUSH
79892: LD_INT 11
79894: PUSH
79895: EMPTY
79896: LIST
79897: LIST
79898: LIST
79899: LIST
79900: LIST
79901: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79902: LD_ADDR_EXP 85
79906: PUSH
79907: LD_EXP 85
79911: PPUSH
79912: LD_VAR 0 1
79916: PPUSH
79917: LD_EXP 85
79921: PUSH
79922: LD_VAR 0 1
79926: ARRAY
79927: PUSH
79928: LD_VAR 0 3
79932: DIFF
79933: PPUSH
79934: CALL_OW 1
79938: ST_TO_ADDR
// end ;
79939: LD_VAR 0 2
79943: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79944: LD_INT 0
79946: PPUSH
// result := mc_vehicles [ base ] ;
79947: LD_ADDR_VAR 0 3
79951: PUSH
79952: LD_EXP 77
79956: PUSH
79957: LD_VAR 0 1
79961: ARRAY
79962: ST_TO_ADDR
// if onlyCombat then
79963: LD_VAR 0 2
79967: IFFALSE 80132
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79969: LD_ADDR_VAR 0 3
79973: PUSH
79974: LD_VAR 0 3
79978: PUSH
79979: LD_VAR 0 3
79983: PPUSH
79984: LD_INT 2
79986: PUSH
79987: LD_INT 34
79989: PUSH
79990: LD_INT 12
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 34
79999: PUSH
80000: LD_INT 51
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 34
80009: PUSH
80010: LD_EXP 102
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 34
80021: PUSH
80022: LD_INT 32
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 34
80031: PUSH
80032: LD_INT 13
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 34
80041: PUSH
80042: LD_INT 52
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 34
80051: PUSH
80052: LD_INT 14
80054: PUSH
80055: EMPTY
80056: LIST
80057: LIST
80058: PUSH
80059: LD_INT 34
80061: PUSH
80062: LD_INT 53
80064: PUSH
80065: EMPTY
80066: LIST
80067: LIST
80068: PUSH
80069: LD_INT 34
80071: PUSH
80072: LD_EXP 101
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 34
80083: PUSH
80084: LD_INT 31
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 34
80093: PUSH
80094: LD_INT 48
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: LD_INT 34
80103: PUSH
80104: LD_INT 8
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: EMPTY
80112: LIST
80113: LIST
80114: LIST
80115: LIST
80116: LIST
80117: LIST
80118: LIST
80119: LIST
80120: LIST
80121: LIST
80122: LIST
80123: LIST
80124: LIST
80125: PPUSH
80126: CALL_OW 72
80130: DIFF
80131: ST_TO_ADDR
// end ; end_of_file
80132: LD_VAR 0 3
80136: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80137: LD_INT 0
80139: PPUSH
80140: PPUSH
80141: PPUSH
// if not mc_bases or not skirmish then
80142: LD_EXP 58
80146: NOT
80147: PUSH
80148: LD_EXP 56
80152: NOT
80153: OR
80154: IFFALSE 80158
// exit ;
80156: GO 80323
// for i = 1 to mc_bases do
80158: LD_ADDR_VAR 0 4
80162: PUSH
80163: DOUBLE
80164: LD_INT 1
80166: DEC
80167: ST_TO_ADDR
80168: LD_EXP 58
80172: PUSH
80173: FOR_TO
80174: IFFALSE 80321
// begin if sci in mc_bases [ i ] then
80176: LD_VAR 0 2
80180: PUSH
80181: LD_EXP 58
80185: PUSH
80186: LD_VAR 0 4
80190: ARRAY
80191: IN
80192: IFFALSE 80319
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80194: LD_ADDR_EXP 87
80198: PUSH
80199: LD_EXP 87
80203: PPUSH
80204: LD_VAR 0 4
80208: PUSH
80209: LD_EXP 87
80213: PUSH
80214: LD_VAR 0 4
80218: ARRAY
80219: PUSH
80220: LD_INT 1
80222: PLUS
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PPUSH
80228: LD_VAR 0 1
80232: PPUSH
80233: CALL 20497 0 3
80237: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80238: LD_ADDR_VAR 0 5
80242: PUSH
80243: LD_EXP 58
80247: PUSH
80248: LD_VAR 0 4
80252: ARRAY
80253: PPUSH
80254: LD_INT 2
80256: PUSH
80257: LD_INT 30
80259: PUSH
80260: LD_INT 0
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 30
80269: PUSH
80270: LD_INT 1
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: LIST
80281: PPUSH
80282: CALL_OW 72
80286: PPUSH
80287: LD_VAR 0 1
80291: PPUSH
80292: CALL_OW 74
80296: ST_TO_ADDR
// if tmp then
80297: LD_VAR 0 5
80301: IFFALSE 80317
// ComStandNearbyBuilding ( ape , tmp ) ;
80303: LD_VAR 0 1
80307: PPUSH
80308: LD_VAR 0 5
80312: PPUSH
80313: CALL 15174 0 2
// break ;
80317: GO 80321
// end ; end ;
80319: GO 80173
80321: POP
80322: POP
// end ;
80323: LD_VAR 0 3
80327: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80328: LD_INT 0
80330: PPUSH
80331: PPUSH
80332: PPUSH
// if not mc_bases or not skirmish then
80333: LD_EXP 58
80337: NOT
80338: PUSH
80339: LD_EXP 56
80343: NOT
80344: OR
80345: IFFALSE 80349
// exit ;
80347: GO 80438
// for i = 1 to mc_bases do
80349: LD_ADDR_VAR 0 4
80353: PUSH
80354: DOUBLE
80355: LD_INT 1
80357: DEC
80358: ST_TO_ADDR
80359: LD_EXP 58
80363: PUSH
80364: FOR_TO
80365: IFFALSE 80436
// begin if building in mc_busy_turret_list [ i ] then
80367: LD_VAR 0 1
80371: PUSH
80372: LD_EXP 68
80376: PUSH
80377: LD_VAR 0 4
80381: ARRAY
80382: IN
80383: IFFALSE 80434
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80385: LD_ADDR_VAR 0 5
80389: PUSH
80390: LD_EXP 68
80394: PUSH
80395: LD_VAR 0 4
80399: ARRAY
80400: PUSH
80401: LD_VAR 0 1
80405: DIFF
80406: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80407: LD_ADDR_EXP 68
80411: PUSH
80412: LD_EXP 68
80416: PPUSH
80417: LD_VAR 0 4
80421: PPUSH
80422: LD_VAR 0 5
80426: PPUSH
80427: CALL_OW 1
80431: ST_TO_ADDR
// break ;
80432: GO 80436
// end ; end ;
80434: GO 80364
80436: POP
80437: POP
// end ;
80438: LD_VAR 0 3
80442: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80443: LD_INT 0
80445: PPUSH
80446: PPUSH
80447: PPUSH
// if not mc_bases or not skirmish then
80448: LD_EXP 58
80452: NOT
80453: PUSH
80454: LD_EXP 56
80458: NOT
80459: OR
80460: IFFALSE 80464
// exit ;
80462: GO 80663
// for i = 1 to mc_bases do
80464: LD_ADDR_VAR 0 5
80468: PUSH
80469: DOUBLE
80470: LD_INT 1
80472: DEC
80473: ST_TO_ADDR
80474: LD_EXP 58
80478: PUSH
80479: FOR_TO
80480: IFFALSE 80661
// if building in mc_bases [ i ] then
80482: LD_VAR 0 1
80486: PUSH
80487: LD_EXP 58
80491: PUSH
80492: LD_VAR 0 5
80496: ARRAY
80497: IN
80498: IFFALSE 80659
// begin tmp := mc_bases [ i ] diff building ;
80500: LD_ADDR_VAR 0 6
80504: PUSH
80505: LD_EXP 58
80509: PUSH
80510: LD_VAR 0 5
80514: ARRAY
80515: PUSH
80516: LD_VAR 0 1
80520: DIFF
80521: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80522: LD_ADDR_EXP 58
80526: PUSH
80527: LD_EXP 58
80531: PPUSH
80532: LD_VAR 0 5
80536: PPUSH
80537: LD_VAR 0 6
80541: PPUSH
80542: CALL_OW 1
80546: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80547: LD_VAR 0 1
80551: PUSH
80552: LD_EXP 66
80556: PUSH
80557: LD_VAR 0 5
80561: ARRAY
80562: IN
80563: IFFALSE 80602
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80565: LD_ADDR_EXP 66
80569: PUSH
80570: LD_EXP 66
80574: PPUSH
80575: LD_VAR 0 5
80579: PPUSH
80580: LD_EXP 66
80584: PUSH
80585: LD_VAR 0 5
80589: ARRAY
80590: PUSH
80591: LD_VAR 0 1
80595: DIFF
80596: PPUSH
80597: CALL_OW 1
80601: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80602: LD_VAR 0 1
80606: PUSH
80607: LD_EXP 67
80611: PUSH
80612: LD_VAR 0 5
80616: ARRAY
80617: IN
80618: IFFALSE 80657
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80620: LD_ADDR_EXP 67
80624: PUSH
80625: LD_EXP 67
80629: PPUSH
80630: LD_VAR 0 5
80634: PPUSH
80635: LD_EXP 67
80639: PUSH
80640: LD_VAR 0 5
80644: ARRAY
80645: PUSH
80646: LD_VAR 0 1
80650: DIFF
80651: PPUSH
80652: CALL_OW 1
80656: ST_TO_ADDR
// break ;
80657: GO 80661
// end ;
80659: GO 80479
80661: POP
80662: POP
// end ;
80663: LD_VAR 0 4
80667: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80668: LD_INT 0
80670: PPUSH
80671: PPUSH
80672: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80673: LD_EXP 58
80677: NOT
80678: PUSH
80679: LD_EXP 56
80683: NOT
80684: OR
80685: PUSH
80686: LD_VAR 0 3
80690: PUSH
80691: LD_EXP 84
80695: IN
80696: NOT
80697: OR
80698: IFFALSE 80702
// exit ;
80700: GO 80825
// for i = 1 to mc_vehicles do
80702: LD_ADDR_VAR 0 6
80706: PUSH
80707: DOUBLE
80708: LD_INT 1
80710: DEC
80711: ST_TO_ADDR
80712: LD_EXP 77
80716: PUSH
80717: FOR_TO
80718: IFFALSE 80823
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80720: LD_VAR 0 2
80724: PUSH
80725: LD_EXP 77
80729: PUSH
80730: LD_VAR 0 6
80734: ARRAY
80735: IN
80736: PUSH
80737: LD_VAR 0 1
80741: PUSH
80742: LD_EXP 77
80746: PUSH
80747: LD_VAR 0 6
80751: ARRAY
80752: IN
80753: OR
80754: IFFALSE 80821
// begin tmp := mc_vehicles [ i ] diff old ;
80756: LD_ADDR_VAR 0 7
80760: PUSH
80761: LD_EXP 77
80765: PUSH
80766: LD_VAR 0 6
80770: ARRAY
80771: PUSH
80772: LD_VAR 0 2
80776: DIFF
80777: ST_TO_ADDR
// tmp := tmp diff new ;
80778: LD_ADDR_VAR 0 7
80782: PUSH
80783: LD_VAR 0 7
80787: PUSH
80788: LD_VAR 0 1
80792: DIFF
80793: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80794: LD_ADDR_EXP 77
80798: PUSH
80799: LD_EXP 77
80803: PPUSH
80804: LD_VAR 0 6
80808: PPUSH
80809: LD_VAR 0 7
80813: PPUSH
80814: CALL_OW 1
80818: ST_TO_ADDR
// break ;
80819: GO 80823
// end ;
80821: GO 80717
80823: POP
80824: POP
// end ;
80825: LD_VAR 0 5
80829: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80830: LD_INT 0
80832: PPUSH
80833: PPUSH
80834: PPUSH
80835: PPUSH
// if not mc_bases or not skirmish then
80836: LD_EXP 58
80840: NOT
80841: PUSH
80842: LD_EXP 56
80846: NOT
80847: OR
80848: IFFALSE 80852
// exit ;
80850: GO 81235
// side := GetSide ( vehicle ) ;
80852: LD_ADDR_VAR 0 5
80856: PUSH
80857: LD_VAR 0 1
80861: PPUSH
80862: CALL_OW 255
80866: ST_TO_ADDR
// for i = 1 to mc_bases do
80867: LD_ADDR_VAR 0 4
80871: PUSH
80872: DOUBLE
80873: LD_INT 1
80875: DEC
80876: ST_TO_ADDR
80877: LD_EXP 58
80881: PUSH
80882: FOR_TO
80883: IFFALSE 81233
// begin if factory in mc_bases [ i ] then
80885: LD_VAR 0 2
80889: PUSH
80890: LD_EXP 58
80894: PUSH
80895: LD_VAR 0 4
80899: ARRAY
80900: IN
80901: IFFALSE 81231
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
80903: LD_EXP 80
80907: PUSH
80908: LD_VAR 0 4
80912: ARRAY
80913: PUSH
80914: LD_EXP 69
80918: PUSH
80919: LD_VAR 0 4
80923: ARRAY
80924: LESS
80925: PUSH
80926: LD_VAR 0 1
80930: PPUSH
80931: CALL_OW 264
80935: PUSH
80936: LD_INT 31
80938: PUSH
80939: LD_INT 32
80941: PUSH
80942: LD_INT 51
80944: PUSH
80945: LD_EXP 102
80949: PUSH
80950: LD_INT 12
80952: PUSH
80953: LD_INT 30
80955: PUSH
80956: LD_EXP 101
80960: PUSH
80961: LD_INT 11
80963: PUSH
80964: LD_INT 53
80966: PUSH
80967: LD_INT 14
80969: PUSH
80970: LD_EXP 105
80974: PUSH
80975: LD_INT 29
80977: PUSH
80978: LD_EXP 103
80982: PUSH
80983: LD_INT 13
80985: PUSH
80986: LD_INT 52
80988: PUSH
80989: LD_INT 48
80991: PUSH
80992: LD_INT 8
80994: PUSH
80995: EMPTY
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: LIST
81008: LIST
81009: LIST
81010: LIST
81011: LIST
81012: LIST
81013: IN
81014: NOT
81015: AND
81016: IFFALSE 81057
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
81018: LD_ADDR_EXP 80
81022: PUSH
81023: LD_EXP 80
81027: PPUSH
81028: LD_VAR 0 4
81032: PPUSH
81033: LD_EXP 80
81037: PUSH
81038: LD_VAR 0 4
81042: ARRAY
81043: PUSH
81044: LD_VAR 0 1
81048: ADD
81049: PPUSH
81050: CALL_OW 1
81054: ST_TO_ADDR
81055: GO 81101
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81057: LD_ADDR_EXP 77
81061: PUSH
81062: LD_EXP 77
81066: PPUSH
81067: LD_VAR 0 4
81071: PUSH
81072: LD_EXP 77
81076: PUSH
81077: LD_VAR 0 4
81081: ARRAY
81082: PUSH
81083: LD_INT 1
81085: PLUS
81086: PUSH
81087: EMPTY
81088: LIST
81089: LIST
81090: PPUSH
81091: LD_VAR 0 1
81095: PPUSH
81096: CALL 20497 0 3
81100: ST_TO_ADDR
// if not mc_scan [ i ] then
81101: LD_EXP 81
81105: PUSH
81106: LD_VAR 0 4
81110: ARRAY
81111: NOT
81112: IFFALSE 81231
// begin if GetControl ( vehicle ) = control_remote then
81114: LD_VAR 0 1
81118: PPUSH
81119: CALL_OW 263
81123: PUSH
81124: LD_INT 2
81126: EQUAL
81127: IFFALSE 81147
// repeat wait ( 0 0$1 ) ;
81129: LD_INT 35
81131: PPUSH
81132: CALL_OW 67
// until IsControledBy ( vehicle ) ;
81136: LD_VAR 0 1
81140: PPUSH
81141: CALL_OW 312
81145: IFFALSE 81129
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81147: LD_VAR 0 1
81151: PPUSH
81152: LD_EXP 82
81156: PUSH
81157: LD_VAR 0 4
81161: ARRAY
81162: PPUSH
81163: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81167: LD_VAR 0 1
81171: PPUSH
81172: CALL_OW 263
81176: PUSH
81177: LD_INT 1
81179: NONEQUAL
81180: IFFALSE 81184
// break ;
81182: GO 81233
// repeat wait ( 0 0$1 ) ;
81184: LD_INT 35
81186: PPUSH
81187: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81191: LD_VAR 0 1
81195: PPUSH
81196: LD_EXP 82
81200: PUSH
81201: LD_VAR 0 4
81205: ARRAY
81206: PPUSH
81207: CALL_OW 308
81211: IFFALSE 81184
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81213: LD_VAR 0 1
81217: PPUSH
81218: CALL_OW 311
81222: PPUSH
81223: CALL_OW 121
// exit ;
81227: POP
81228: POP
81229: GO 81235
// end ; end ; end ;
81231: GO 80882
81233: POP
81234: POP
// end ;
81235: LD_VAR 0 3
81239: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81240: LD_INT 0
81242: PPUSH
81243: PPUSH
81244: PPUSH
81245: PPUSH
// if not mc_bases or not skirmish then
81246: LD_EXP 58
81250: NOT
81251: PUSH
81252: LD_EXP 56
81256: NOT
81257: OR
81258: IFFALSE 81262
// exit ;
81260: GO 81615
// repeat wait ( 0 0$1 ) ;
81262: LD_INT 35
81264: PPUSH
81265: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81269: LD_VAR 0 2
81273: PPUSH
81274: LD_VAR 0 3
81278: PPUSH
81279: CALL_OW 284
81283: IFFALSE 81262
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81285: LD_VAR 0 2
81289: PPUSH
81290: LD_VAR 0 3
81294: PPUSH
81295: CALL_OW 283
81299: PUSH
81300: LD_INT 4
81302: EQUAL
81303: IFFALSE 81307
// exit ;
81305: GO 81615
// for i = 1 to mc_bases do
81307: LD_ADDR_VAR 0 7
81311: PUSH
81312: DOUBLE
81313: LD_INT 1
81315: DEC
81316: ST_TO_ADDR
81317: LD_EXP 58
81321: PUSH
81322: FOR_TO
81323: IFFALSE 81613
// begin if mc_crates_area [ i ] then
81325: LD_EXP 76
81329: PUSH
81330: LD_VAR 0 7
81334: ARRAY
81335: IFFALSE 81446
// for j in mc_crates_area [ i ] do
81337: LD_ADDR_VAR 0 8
81341: PUSH
81342: LD_EXP 76
81346: PUSH
81347: LD_VAR 0 7
81351: ARRAY
81352: PUSH
81353: FOR_IN
81354: IFFALSE 81444
// if InArea ( x , y , j ) then
81356: LD_VAR 0 2
81360: PPUSH
81361: LD_VAR 0 3
81365: PPUSH
81366: LD_VAR 0 8
81370: PPUSH
81371: CALL_OW 309
81375: IFFALSE 81442
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81377: LD_ADDR_EXP 74
81381: PUSH
81382: LD_EXP 74
81386: PPUSH
81387: LD_VAR 0 7
81391: PUSH
81392: LD_EXP 74
81396: PUSH
81397: LD_VAR 0 7
81401: ARRAY
81402: PUSH
81403: LD_INT 1
81405: PLUS
81406: PUSH
81407: EMPTY
81408: LIST
81409: LIST
81410: PPUSH
81411: LD_VAR 0 4
81415: PUSH
81416: LD_VAR 0 2
81420: PUSH
81421: LD_VAR 0 3
81425: PUSH
81426: EMPTY
81427: LIST
81428: LIST
81429: LIST
81430: PPUSH
81431: CALL 20497 0 3
81435: ST_TO_ADDR
// exit ;
81436: POP
81437: POP
81438: POP
81439: POP
81440: GO 81615
// end ;
81442: GO 81353
81444: POP
81445: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81446: LD_ADDR_VAR 0 9
81450: PUSH
81451: LD_EXP 58
81455: PUSH
81456: LD_VAR 0 7
81460: ARRAY
81461: PPUSH
81462: LD_INT 2
81464: PUSH
81465: LD_INT 30
81467: PUSH
81468: LD_INT 0
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: PUSH
81475: LD_INT 30
81477: PUSH
81478: LD_INT 1
81480: PUSH
81481: EMPTY
81482: LIST
81483: LIST
81484: PUSH
81485: EMPTY
81486: LIST
81487: LIST
81488: LIST
81489: PPUSH
81490: CALL_OW 72
81494: ST_TO_ADDR
// if not depot then
81495: LD_VAR 0 9
81499: NOT
81500: IFFALSE 81504
// continue ;
81502: GO 81322
// for j in depot do
81504: LD_ADDR_VAR 0 8
81508: PUSH
81509: LD_VAR 0 9
81513: PUSH
81514: FOR_IN
81515: IFFALSE 81609
// if GetDistUnitXY ( j , x , y ) < 30 then
81517: LD_VAR 0 8
81521: PPUSH
81522: LD_VAR 0 2
81526: PPUSH
81527: LD_VAR 0 3
81531: PPUSH
81532: CALL_OW 297
81536: PUSH
81537: LD_INT 30
81539: LESS
81540: IFFALSE 81607
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81542: LD_ADDR_EXP 74
81546: PUSH
81547: LD_EXP 74
81551: PPUSH
81552: LD_VAR 0 7
81556: PUSH
81557: LD_EXP 74
81561: PUSH
81562: LD_VAR 0 7
81566: ARRAY
81567: PUSH
81568: LD_INT 1
81570: PLUS
81571: PUSH
81572: EMPTY
81573: LIST
81574: LIST
81575: PPUSH
81576: LD_VAR 0 4
81580: PUSH
81581: LD_VAR 0 2
81585: PUSH
81586: LD_VAR 0 3
81590: PUSH
81591: EMPTY
81592: LIST
81593: LIST
81594: LIST
81595: PPUSH
81596: CALL 20497 0 3
81600: ST_TO_ADDR
// exit ;
81601: POP
81602: POP
81603: POP
81604: POP
81605: GO 81615
// end ;
81607: GO 81514
81609: POP
81610: POP
// end ;
81611: GO 81322
81613: POP
81614: POP
// end ;
81615: LD_VAR 0 6
81619: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81620: LD_INT 0
81622: PPUSH
81623: PPUSH
81624: PPUSH
81625: PPUSH
// if not mc_bases or not skirmish then
81626: LD_EXP 58
81630: NOT
81631: PUSH
81632: LD_EXP 56
81636: NOT
81637: OR
81638: IFFALSE 81642
// exit ;
81640: GO 81919
// side := GetSide ( lab ) ;
81642: LD_ADDR_VAR 0 4
81646: PUSH
81647: LD_VAR 0 2
81651: PPUSH
81652: CALL_OW 255
81656: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81657: LD_VAR 0 4
81661: PUSH
81662: LD_EXP 84
81666: IN
81667: NOT
81668: PUSH
81669: LD_EXP 85
81673: NOT
81674: OR
81675: PUSH
81676: LD_EXP 58
81680: NOT
81681: OR
81682: IFFALSE 81686
// exit ;
81684: GO 81919
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81686: LD_ADDR_EXP 85
81690: PUSH
81691: LD_EXP 85
81695: PPUSH
81696: LD_VAR 0 4
81700: PPUSH
81701: LD_EXP 85
81705: PUSH
81706: LD_VAR 0 4
81710: ARRAY
81711: PUSH
81712: LD_VAR 0 1
81716: DIFF
81717: PPUSH
81718: CALL_OW 1
81722: ST_TO_ADDR
// for i = 1 to mc_bases do
81723: LD_ADDR_VAR 0 5
81727: PUSH
81728: DOUBLE
81729: LD_INT 1
81731: DEC
81732: ST_TO_ADDR
81733: LD_EXP 58
81737: PUSH
81738: FOR_TO
81739: IFFALSE 81917
// begin if lab in mc_bases [ i ] then
81741: LD_VAR 0 2
81745: PUSH
81746: LD_EXP 58
81750: PUSH
81751: LD_VAR 0 5
81755: ARRAY
81756: IN
81757: IFFALSE 81915
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81759: LD_VAR 0 1
81763: PUSH
81764: LD_INT 11
81766: PUSH
81767: LD_INT 4
81769: PUSH
81770: LD_INT 3
81772: PUSH
81773: LD_INT 2
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: IN
81782: PUSH
81783: LD_EXP 88
81787: PUSH
81788: LD_VAR 0 5
81792: ARRAY
81793: AND
81794: IFFALSE 81915
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81796: LD_ADDR_VAR 0 6
81800: PUSH
81801: LD_EXP 88
81805: PUSH
81806: LD_VAR 0 5
81810: ARRAY
81811: PUSH
81812: LD_INT 1
81814: ARRAY
81815: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81816: LD_ADDR_EXP 88
81820: PUSH
81821: LD_EXP 88
81825: PPUSH
81826: LD_VAR 0 5
81830: PPUSH
81831: EMPTY
81832: PPUSH
81833: CALL_OW 1
81837: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81838: LD_VAR 0 6
81842: PPUSH
81843: LD_INT 0
81845: PPUSH
81846: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81850: LD_VAR 0 6
81854: PPUSH
81855: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81859: LD_ADDR_EXP 87
81863: PUSH
81864: LD_EXP 87
81868: PPUSH
81869: LD_VAR 0 5
81873: PPUSH
81874: LD_EXP 87
81878: PUSH
81879: LD_VAR 0 5
81883: ARRAY
81884: PPUSH
81885: LD_INT 1
81887: PPUSH
81888: LD_VAR 0 6
81892: PPUSH
81893: CALL_OW 2
81897: PPUSH
81898: CALL_OW 1
81902: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81903: LD_VAR 0 5
81907: PPUSH
81908: LD_INT 112
81910: PPUSH
81911: CALL 59388 0 2
// end ; end ; end ;
81915: GO 81738
81917: POP
81918: POP
// end ;
81919: LD_VAR 0 3
81923: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81924: LD_INT 0
81926: PPUSH
81927: PPUSH
81928: PPUSH
81929: PPUSH
81930: PPUSH
81931: PPUSH
81932: PPUSH
81933: PPUSH
// if not mc_bases or not skirmish then
81934: LD_EXP 58
81938: NOT
81939: PUSH
81940: LD_EXP 56
81944: NOT
81945: OR
81946: IFFALSE 81950
// exit ;
81948: GO 82966
// for i = 1 to mc_bases do
81950: LD_ADDR_VAR 0 3
81954: PUSH
81955: DOUBLE
81956: LD_INT 1
81958: DEC
81959: ST_TO_ADDR
81960: LD_EXP 58
81964: PUSH
81965: FOR_TO
81966: IFFALSE 82964
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81968: LD_VAR 0 1
81972: PUSH
81973: LD_EXP 58
81977: PUSH
81978: LD_VAR 0 3
81982: ARRAY
81983: IN
81984: PUSH
81985: LD_VAR 0 1
81989: PUSH
81990: LD_EXP 65
81994: PUSH
81995: LD_VAR 0 3
81999: ARRAY
82000: IN
82001: OR
82002: PUSH
82003: LD_VAR 0 1
82007: PUSH
82008: LD_EXP 77
82012: PUSH
82013: LD_VAR 0 3
82017: ARRAY
82018: IN
82019: OR
82020: PUSH
82021: LD_VAR 0 1
82025: PUSH
82026: LD_EXP 87
82030: PUSH
82031: LD_VAR 0 3
82035: ARRAY
82036: IN
82037: OR
82038: PUSH
82039: LD_VAR 0 1
82043: PUSH
82044: LD_EXP 88
82048: PUSH
82049: LD_VAR 0 3
82053: ARRAY
82054: IN
82055: OR
82056: IFFALSE 82962
// begin if un in mc_ape [ i ] then
82058: LD_VAR 0 1
82062: PUSH
82063: LD_EXP 87
82067: PUSH
82068: LD_VAR 0 3
82072: ARRAY
82073: IN
82074: IFFALSE 82113
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82076: LD_ADDR_EXP 87
82080: PUSH
82081: LD_EXP 87
82085: PPUSH
82086: LD_VAR 0 3
82090: PPUSH
82091: LD_EXP 87
82095: PUSH
82096: LD_VAR 0 3
82100: ARRAY
82101: PUSH
82102: LD_VAR 0 1
82106: DIFF
82107: PPUSH
82108: CALL_OW 1
82112: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82113: LD_VAR 0 1
82117: PUSH
82118: LD_EXP 88
82122: PUSH
82123: LD_VAR 0 3
82127: ARRAY
82128: IN
82129: IFFALSE 82153
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82131: LD_ADDR_EXP 88
82135: PUSH
82136: LD_EXP 88
82140: PPUSH
82141: LD_VAR 0 3
82145: PPUSH
82146: EMPTY
82147: PPUSH
82148: CALL_OW 1
82152: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
82153: LD_VAR 0 1
82157: PPUSH
82158: CALL_OW 247
82162: PUSH
82163: LD_INT 2
82165: EQUAL
82166: PUSH
82167: LD_VAR 0 1
82171: PPUSH
82172: CALL_OW 110
82176: PUSH
82177: LD_INT 20
82179: EQUAL
82180: PUSH
82181: LD_VAR 0 1
82185: PUSH
82186: LD_EXP 80
82190: PUSH
82191: LD_VAR 0 3
82195: ARRAY
82196: IN
82197: OR
82198: AND
82199: IFFALSE 82302
// begin fac := MC_GetBuilding ( i , b_factory ) ;
82201: LD_ADDR_VAR 0 8
82205: PUSH
82206: LD_VAR 0 3
82210: PPUSH
82211: LD_INT 3
82213: PPUSH
82214: CALL 78961 0 2
82218: ST_TO_ADDR
// if fac then
82219: LD_VAR 0 8
82223: IFFALSE 82302
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82225: LD_ADDR_VAR 0 9
82229: PUSH
82230: LD_VAR 0 8
82234: PPUSH
82235: LD_VAR 0 1
82239: PPUSH
82240: CALL_OW 265
82244: PPUSH
82245: LD_VAR 0 1
82249: PPUSH
82250: CALL_OW 262
82254: PPUSH
82255: LD_VAR 0 1
82259: PPUSH
82260: CALL_OW 263
82264: PPUSH
82265: LD_VAR 0 1
82269: PPUSH
82270: CALL_OW 264
82274: PPUSH
82275: CALL 18097 0 5
82279: ST_TO_ADDR
// if components then
82280: LD_VAR 0 9
82284: IFFALSE 82300
// MC_InsertProduceList ( i , components ) ;
82286: LD_VAR 0 3
82290: PPUSH
82291: LD_VAR 0 9
82295: PPUSH
82296: CALL 78589 0 2
// break ;
82300: GO 82964
// end ; end ; if GetType ( un ) = unit_building then
82302: LD_VAR 0 1
82306: PPUSH
82307: CALL_OW 247
82311: PUSH
82312: LD_INT 3
82314: EQUAL
82315: IFFALSE 82630
// begin btype := GetBType ( un ) ;
82317: LD_ADDR_VAR 0 5
82321: PUSH
82322: LD_VAR 0 1
82326: PPUSH
82327: CALL_OW 266
82331: ST_TO_ADDR
// if btype = b_warehouse then
82332: LD_VAR 0 5
82336: PUSH
82337: LD_INT 1
82339: EQUAL
82340: IFFALSE 82358
// begin btype := b_depot ;
82342: LD_ADDR_VAR 0 5
82346: PUSH
82347: LD_INT 0
82349: ST_TO_ADDR
// pos := 1 ;
82350: LD_ADDR_VAR 0 6
82354: PUSH
82355: LD_INT 1
82357: ST_TO_ADDR
// end ; if btype = b_factory then
82358: LD_VAR 0 5
82362: PUSH
82363: LD_INT 3
82365: EQUAL
82366: IFFALSE 82384
// begin btype := b_workshop ;
82368: LD_ADDR_VAR 0 5
82372: PUSH
82373: LD_INT 2
82375: ST_TO_ADDR
// pos := 1 ;
82376: LD_ADDR_VAR 0 6
82380: PUSH
82381: LD_INT 1
82383: ST_TO_ADDR
// end ; if btype = b_barracks then
82384: LD_VAR 0 5
82388: PUSH
82389: LD_INT 5
82391: EQUAL
82392: IFFALSE 82402
// btype := b_armoury ;
82394: LD_ADDR_VAR 0 5
82398: PUSH
82399: LD_INT 4
82401: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82402: LD_VAR 0 5
82406: PUSH
82407: LD_INT 7
82409: PUSH
82410: LD_INT 8
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: IN
82417: IFFALSE 82427
// btype := b_lab ;
82419: LD_ADDR_VAR 0 5
82423: PUSH
82424: LD_INT 6
82426: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82427: LD_ADDR_EXP 63
82431: PUSH
82432: LD_EXP 63
82436: PPUSH
82437: LD_VAR 0 3
82441: PUSH
82442: LD_EXP 63
82446: PUSH
82447: LD_VAR 0 3
82451: ARRAY
82452: PUSH
82453: LD_INT 1
82455: PLUS
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PPUSH
82461: LD_VAR 0 5
82465: PUSH
82466: LD_VAR 0 1
82470: PPUSH
82471: CALL_OW 250
82475: PUSH
82476: LD_VAR 0 1
82480: PPUSH
82481: CALL_OW 251
82485: PUSH
82486: LD_VAR 0 1
82490: PPUSH
82491: CALL_OW 254
82495: PUSH
82496: EMPTY
82497: LIST
82498: LIST
82499: LIST
82500: LIST
82501: PPUSH
82502: CALL 20497 0 3
82506: ST_TO_ADDR
// if pos = 1 then
82507: LD_VAR 0 6
82511: PUSH
82512: LD_INT 1
82514: EQUAL
82515: IFFALSE 82630
// begin tmp := mc_build_list [ i ] ;
82517: LD_ADDR_VAR 0 7
82521: PUSH
82522: LD_EXP 63
82526: PUSH
82527: LD_VAR 0 3
82531: ARRAY
82532: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82533: LD_VAR 0 7
82537: PPUSH
82538: LD_INT 2
82540: PUSH
82541: LD_INT 30
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 30
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: EMPTY
82558: LIST
82559: LIST
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: LIST
82565: PPUSH
82566: CALL_OW 72
82570: IFFALSE 82580
// pos := 2 ;
82572: LD_ADDR_VAR 0 6
82576: PUSH
82577: LD_INT 2
82579: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82580: LD_ADDR_VAR 0 7
82584: PUSH
82585: LD_VAR 0 7
82589: PPUSH
82590: LD_VAR 0 6
82594: PPUSH
82595: LD_VAR 0 7
82599: PPUSH
82600: CALL 20823 0 3
82604: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82605: LD_ADDR_EXP 63
82609: PUSH
82610: LD_EXP 63
82614: PPUSH
82615: LD_VAR 0 3
82619: PPUSH
82620: LD_VAR 0 7
82624: PPUSH
82625: CALL_OW 1
82629: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82630: LD_VAR 0 1
82634: PUSH
82635: LD_EXP 58
82639: PUSH
82640: LD_VAR 0 3
82644: ARRAY
82645: IN
82646: IFFALSE 82685
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82648: LD_ADDR_EXP 58
82652: PUSH
82653: LD_EXP 58
82657: PPUSH
82658: LD_VAR 0 3
82662: PPUSH
82663: LD_EXP 58
82667: PUSH
82668: LD_VAR 0 3
82672: ARRAY
82673: PUSH
82674: LD_VAR 0 1
82678: DIFF
82679: PPUSH
82680: CALL_OW 1
82684: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82685: LD_VAR 0 1
82689: PUSH
82690: LD_EXP 65
82694: PUSH
82695: LD_VAR 0 3
82699: ARRAY
82700: IN
82701: IFFALSE 82740
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82703: LD_ADDR_EXP 65
82707: PUSH
82708: LD_EXP 65
82712: PPUSH
82713: LD_VAR 0 3
82717: PPUSH
82718: LD_EXP 65
82722: PUSH
82723: LD_VAR 0 3
82727: ARRAY
82728: PUSH
82729: LD_VAR 0 1
82733: DIFF
82734: PPUSH
82735: CALL_OW 1
82739: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82740: LD_VAR 0 1
82744: PUSH
82745: LD_EXP 77
82749: PUSH
82750: LD_VAR 0 3
82754: ARRAY
82755: IN
82756: IFFALSE 82795
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82758: LD_ADDR_EXP 77
82762: PUSH
82763: LD_EXP 77
82767: PPUSH
82768: LD_VAR 0 3
82772: PPUSH
82773: LD_EXP 77
82777: PUSH
82778: LD_VAR 0 3
82782: ARRAY
82783: PUSH
82784: LD_VAR 0 1
82788: DIFF
82789: PPUSH
82790: CALL_OW 1
82794: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
82795: LD_VAR 0 1
82799: PUSH
82800: LD_EXP 80
82804: PUSH
82805: LD_VAR 0 3
82809: ARRAY
82810: IN
82811: IFFALSE 82850
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82813: LD_ADDR_EXP 80
82817: PUSH
82818: LD_EXP 80
82822: PPUSH
82823: LD_VAR 0 3
82827: PPUSH
82828: LD_EXP 80
82832: PUSH
82833: LD_VAR 0 3
82837: ARRAY
82838: PUSH
82839: LD_VAR 0 1
82843: DIFF
82844: PPUSH
82845: CALL_OW 1
82849: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82850: LD_VAR 0 1
82854: PUSH
82855: LD_EXP 67
82859: PUSH
82860: LD_VAR 0 3
82864: ARRAY
82865: IN
82866: IFFALSE 82905
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82868: LD_ADDR_EXP 67
82872: PUSH
82873: LD_EXP 67
82877: PPUSH
82878: LD_VAR 0 3
82882: PPUSH
82883: LD_EXP 67
82887: PUSH
82888: LD_VAR 0 3
82892: ARRAY
82893: PUSH
82894: LD_VAR 0 1
82898: DIFF
82899: PPUSH
82900: CALL_OW 1
82904: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82905: LD_VAR 0 1
82909: PUSH
82910: LD_EXP 66
82914: PUSH
82915: LD_VAR 0 3
82919: ARRAY
82920: IN
82921: IFFALSE 82960
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82923: LD_ADDR_EXP 66
82927: PUSH
82928: LD_EXP 66
82932: PPUSH
82933: LD_VAR 0 3
82937: PPUSH
82938: LD_EXP 66
82942: PUSH
82943: LD_VAR 0 3
82947: ARRAY
82948: PUSH
82949: LD_VAR 0 1
82953: DIFF
82954: PPUSH
82955: CALL_OW 1
82959: ST_TO_ADDR
// end ; break ;
82960: GO 82964
// end ;
82962: GO 81965
82964: POP
82965: POP
// end ;
82966: LD_VAR 0 2
82970: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82971: LD_INT 0
82973: PPUSH
82974: PPUSH
82975: PPUSH
// if not mc_bases or not skirmish then
82976: LD_EXP 58
82980: NOT
82981: PUSH
82982: LD_EXP 56
82986: NOT
82987: OR
82988: IFFALSE 82992
// exit ;
82990: GO 83207
// for i = 1 to mc_bases do
82992: LD_ADDR_VAR 0 3
82996: PUSH
82997: DOUBLE
82998: LD_INT 1
83000: DEC
83001: ST_TO_ADDR
83002: LD_EXP 58
83006: PUSH
83007: FOR_TO
83008: IFFALSE 83205
// begin if building in mc_construct_list [ i ] then
83010: LD_VAR 0 1
83014: PUSH
83015: LD_EXP 65
83019: PUSH
83020: LD_VAR 0 3
83024: ARRAY
83025: IN
83026: IFFALSE 83203
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83028: LD_ADDR_EXP 65
83032: PUSH
83033: LD_EXP 65
83037: PPUSH
83038: LD_VAR 0 3
83042: PPUSH
83043: LD_EXP 65
83047: PUSH
83048: LD_VAR 0 3
83052: ARRAY
83053: PUSH
83054: LD_VAR 0 1
83058: DIFF
83059: PPUSH
83060: CALL_OW 1
83064: ST_TO_ADDR
// if building in mc_lab [ i ] then
83065: LD_VAR 0 1
83069: PUSH
83070: LD_EXP 91
83074: PUSH
83075: LD_VAR 0 3
83079: ARRAY
83080: IN
83081: IFFALSE 83136
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83083: LD_ADDR_EXP 92
83087: PUSH
83088: LD_EXP 92
83092: PPUSH
83093: LD_VAR 0 3
83097: PPUSH
83098: LD_EXP 92
83102: PUSH
83103: LD_VAR 0 3
83107: ARRAY
83108: PPUSH
83109: LD_INT 1
83111: PPUSH
83112: LD_EXP 92
83116: PUSH
83117: LD_VAR 0 3
83121: ARRAY
83122: PPUSH
83123: LD_INT 0
83125: PPUSH
83126: CALL 19915 0 4
83130: PPUSH
83131: CALL_OW 1
83135: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83136: LD_VAR 0 1
83140: PUSH
83141: LD_EXP 58
83145: PUSH
83146: LD_VAR 0 3
83150: ARRAY
83151: IN
83152: NOT
83153: IFFALSE 83199
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83155: LD_ADDR_EXP 58
83159: PUSH
83160: LD_EXP 58
83164: PPUSH
83165: LD_VAR 0 3
83169: PUSH
83170: LD_EXP 58
83174: PUSH
83175: LD_VAR 0 3
83179: ARRAY
83180: PUSH
83181: LD_INT 1
83183: PLUS
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PPUSH
83189: LD_VAR 0 1
83193: PPUSH
83194: CALL 20497 0 3
83198: ST_TO_ADDR
// exit ;
83199: POP
83200: POP
83201: GO 83207
// end ; end ;
83203: GO 83007
83205: POP
83206: POP
// end ;
83207: LD_VAR 0 2
83211: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83212: LD_INT 0
83214: PPUSH
83215: PPUSH
83216: PPUSH
83217: PPUSH
83218: PPUSH
83219: PPUSH
83220: PPUSH
// if not mc_bases or not skirmish then
83221: LD_EXP 58
83225: NOT
83226: PUSH
83227: LD_EXP 56
83231: NOT
83232: OR
83233: IFFALSE 83237
// exit ;
83235: GO 83898
// for i = 1 to mc_bases do
83237: LD_ADDR_VAR 0 3
83241: PUSH
83242: DOUBLE
83243: LD_INT 1
83245: DEC
83246: ST_TO_ADDR
83247: LD_EXP 58
83251: PUSH
83252: FOR_TO
83253: IFFALSE 83896
// begin if building in mc_construct_list [ i ] then
83255: LD_VAR 0 1
83259: PUSH
83260: LD_EXP 65
83264: PUSH
83265: LD_VAR 0 3
83269: ARRAY
83270: IN
83271: IFFALSE 83894
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83273: LD_ADDR_EXP 65
83277: PUSH
83278: LD_EXP 65
83282: PPUSH
83283: LD_VAR 0 3
83287: PPUSH
83288: LD_EXP 65
83292: PUSH
83293: LD_VAR 0 3
83297: ARRAY
83298: PUSH
83299: LD_VAR 0 1
83303: DIFF
83304: PPUSH
83305: CALL_OW 1
83309: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83310: LD_ADDR_EXP 58
83314: PUSH
83315: LD_EXP 58
83319: PPUSH
83320: LD_VAR 0 3
83324: PUSH
83325: LD_EXP 58
83329: PUSH
83330: LD_VAR 0 3
83334: ARRAY
83335: PUSH
83336: LD_INT 1
83338: PLUS
83339: PUSH
83340: EMPTY
83341: LIST
83342: LIST
83343: PPUSH
83344: LD_VAR 0 1
83348: PPUSH
83349: CALL 20497 0 3
83353: ST_TO_ADDR
// btype := GetBType ( building ) ;
83354: LD_ADDR_VAR 0 5
83358: PUSH
83359: LD_VAR 0 1
83363: PPUSH
83364: CALL_OW 266
83368: ST_TO_ADDR
// side := GetSide ( building ) ;
83369: LD_ADDR_VAR 0 8
83373: PUSH
83374: LD_VAR 0 1
83378: PPUSH
83379: CALL_OW 255
83383: ST_TO_ADDR
// if btype = b_lab then
83384: LD_VAR 0 5
83388: PUSH
83389: LD_INT 6
83391: EQUAL
83392: IFFALSE 83442
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83394: LD_ADDR_EXP 91
83398: PUSH
83399: LD_EXP 91
83403: PPUSH
83404: LD_VAR 0 3
83408: PUSH
83409: LD_EXP 91
83413: PUSH
83414: LD_VAR 0 3
83418: ARRAY
83419: PUSH
83420: LD_INT 1
83422: PLUS
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PPUSH
83428: LD_VAR 0 1
83432: PPUSH
83433: CALL 20497 0 3
83437: ST_TO_ADDR
// exit ;
83438: POP
83439: POP
83440: GO 83898
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83442: LD_VAR 0 5
83446: PUSH
83447: LD_INT 0
83449: PUSH
83450: LD_INT 2
83452: PUSH
83453: LD_INT 4
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: LIST
83460: IN
83461: IFFALSE 83585
// begin if btype = b_armoury then
83463: LD_VAR 0 5
83467: PUSH
83468: LD_INT 4
83470: EQUAL
83471: IFFALSE 83481
// btype := b_barracks ;
83473: LD_ADDR_VAR 0 5
83477: PUSH
83478: LD_INT 5
83480: ST_TO_ADDR
// if btype = b_depot then
83481: LD_VAR 0 5
83485: PUSH
83486: LD_INT 0
83488: EQUAL
83489: IFFALSE 83499
// btype := b_warehouse ;
83491: LD_ADDR_VAR 0 5
83495: PUSH
83496: LD_INT 1
83498: ST_TO_ADDR
// if btype = b_workshop then
83499: LD_VAR 0 5
83503: PUSH
83504: LD_INT 2
83506: EQUAL
83507: IFFALSE 83517
// btype := b_factory ;
83509: LD_ADDR_VAR 0 5
83513: PUSH
83514: LD_INT 3
83516: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83517: LD_VAR 0 5
83521: PPUSH
83522: LD_VAR 0 8
83526: PPUSH
83527: CALL_OW 323
83531: PUSH
83532: LD_INT 1
83534: EQUAL
83535: IFFALSE 83581
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83537: LD_ADDR_EXP 90
83541: PUSH
83542: LD_EXP 90
83546: PPUSH
83547: LD_VAR 0 3
83551: PUSH
83552: LD_EXP 90
83556: PUSH
83557: LD_VAR 0 3
83561: ARRAY
83562: PUSH
83563: LD_INT 1
83565: PLUS
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: PPUSH
83571: LD_VAR 0 1
83575: PPUSH
83576: CALL 20497 0 3
83580: ST_TO_ADDR
// exit ;
83581: POP
83582: POP
83583: GO 83898
// end ; if btype in [ b_bunker , b_turret ] then
83585: LD_VAR 0 5
83589: PUSH
83590: LD_INT 32
83592: PUSH
83593: LD_INT 33
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: IN
83600: IFFALSE 83890
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83602: LD_ADDR_EXP 66
83606: PUSH
83607: LD_EXP 66
83611: PPUSH
83612: LD_VAR 0 3
83616: PUSH
83617: LD_EXP 66
83621: PUSH
83622: LD_VAR 0 3
83626: ARRAY
83627: PUSH
83628: LD_INT 1
83630: PLUS
83631: PUSH
83632: EMPTY
83633: LIST
83634: LIST
83635: PPUSH
83636: LD_VAR 0 1
83640: PPUSH
83641: CALL 20497 0 3
83645: ST_TO_ADDR
// if btype = b_bunker then
83646: LD_VAR 0 5
83650: PUSH
83651: LD_INT 32
83653: EQUAL
83654: IFFALSE 83890
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83656: LD_ADDR_EXP 67
83660: PUSH
83661: LD_EXP 67
83665: PPUSH
83666: LD_VAR 0 3
83670: PUSH
83671: LD_EXP 67
83675: PUSH
83676: LD_VAR 0 3
83680: ARRAY
83681: PUSH
83682: LD_INT 1
83684: PLUS
83685: PUSH
83686: EMPTY
83687: LIST
83688: LIST
83689: PPUSH
83690: LD_VAR 0 1
83694: PPUSH
83695: CALL 20497 0 3
83699: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83700: LD_ADDR_VAR 0 6
83704: PUSH
83705: LD_EXP 58
83709: PUSH
83710: LD_VAR 0 3
83714: ARRAY
83715: PPUSH
83716: LD_INT 25
83718: PUSH
83719: LD_INT 1
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: PUSH
83726: LD_INT 3
83728: PUSH
83729: LD_INT 54
83731: PUSH
83732: EMPTY
83733: LIST
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: PPUSH
83743: CALL_OW 72
83747: ST_TO_ADDR
// if tmp then
83748: LD_VAR 0 6
83752: IFFALSE 83758
// exit ;
83754: POP
83755: POP
83756: GO 83898
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83758: LD_ADDR_VAR 0 6
83762: PUSH
83763: LD_EXP 58
83767: PUSH
83768: LD_VAR 0 3
83772: ARRAY
83773: PPUSH
83774: LD_INT 2
83776: PUSH
83777: LD_INT 30
83779: PUSH
83780: LD_INT 4
83782: PUSH
83783: EMPTY
83784: LIST
83785: LIST
83786: PUSH
83787: LD_INT 30
83789: PUSH
83790: LD_INT 5
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: EMPTY
83798: LIST
83799: LIST
83800: LIST
83801: PPUSH
83802: CALL_OW 72
83806: ST_TO_ADDR
// if not tmp then
83807: LD_VAR 0 6
83811: NOT
83812: IFFALSE 83818
// exit ;
83814: POP
83815: POP
83816: GO 83898
// for j in tmp do
83818: LD_ADDR_VAR 0 4
83822: PUSH
83823: LD_VAR 0 6
83827: PUSH
83828: FOR_IN
83829: IFFALSE 83888
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83831: LD_ADDR_VAR 0 7
83835: PUSH
83836: LD_VAR 0 4
83840: PPUSH
83841: CALL_OW 313
83845: PPUSH
83846: LD_INT 25
83848: PUSH
83849: LD_INT 1
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PPUSH
83856: CALL_OW 72
83860: ST_TO_ADDR
// if units then
83861: LD_VAR 0 7
83865: IFFALSE 83886
// begin ComExitBuilding ( units [ 1 ] ) ;
83867: LD_VAR 0 7
83871: PUSH
83872: LD_INT 1
83874: ARRAY
83875: PPUSH
83876: CALL_OW 122
// exit ;
83880: POP
83881: POP
83882: POP
83883: POP
83884: GO 83898
// end ; end ;
83886: GO 83828
83888: POP
83889: POP
// end ; end ; exit ;
83890: POP
83891: POP
83892: GO 83898
// end ; end ;
83894: GO 83252
83896: POP
83897: POP
// end ;
83898: LD_VAR 0 2
83902: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83903: LD_INT 0
83905: PPUSH
83906: PPUSH
83907: PPUSH
83908: PPUSH
83909: PPUSH
83910: PPUSH
83911: PPUSH
// if not mc_bases or not skirmish then
83912: LD_EXP 58
83916: NOT
83917: PUSH
83918: LD_EXP 56
83922: NOT
83923: OR
83924: IFFALSE 83928
// exit ;
83926: GO 84159
// btype := GetBType ( building ) ;
83928: LD_ADDR_VAR 0 6
83932: PUSH
83933: LD_VAR 0 1
83937: PPUSH
83938: CALL_OW 266
83942: ST_TO_ADDR
// x := GetX ( building ) ;
83943: LD_ADDR_VAR 0 7
83947: PUSH
83948: LD_VAR 0 1
83952: PPUSH
83953: CALL_OW 250
83957: ST_TO_ADDR
// y := GetY ( building ) ;
83958: LD_ADDR_VAR 0 8
83962: PUSH
83963: LD_VAR 0 1
83967: PPUSH
83968: CALL_OW 251
83972: ST_TO_ADDR
// d := GetDir ( building ) ;
83973: LD_ADDR_VAR 0 9
83977: PUSH
83978: LD_VAR 0 1
83982: PPUSH
83983: CALL_OW 254
83987: ST_TO_ADDR
// for i = 1 to mc_bases do
83988: LD_ADDR_VAR 0 4
83992: PUSH
83993: DOUBLE
83994: LD_INT 1
83996: DEC
83997: ST_TO_ADDR
83998: LD_EXP 58
84002: PUSH
84003: FOR_TO
84004: IFFALSE 84157
// begin if not mc_build_list [ i ] then
84006: LD_EXP 63
84010: PUSH
84011: LD_VAR 0 4
84015: ARRAY
84016: NOT
84017: IFFALSE 84021
// continue ;
84019: GO 84003
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
84021: LD_VAR 0 6
84025: PUSH
84026: LD_VAR 0 7
84030: PUSH
84031: LD_VAR 0 8
84035: PUSH
84036: LD_VAR 0 9
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: LIST
84045: LIST
84046: PPUSH
84047: LD_EXP 63
84051: PUSH
84052: LD_VAR 0 4
84056: ARRAY
84057: PUSH
84058: LD_INT 1
84060: ARRAY
84061: PPUSH
84062: CALL 26666 0 2
84066: IFFALSE 84155
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
84068: LD_ADDR_EXP 63
84072: PUSH
84073: LD_EXP 63
84077: PPUSH
84078: LD_VAR 0 4
84082: PPUSH
84083: LD_EXP 63
84087: PUSH
84088: LD_VAR 0 4
84092: ARRAY
84093: PPUSH
84094: LD_INT 1
84096: PPUSH
84097: CALL_OW 3
84101: PPUSH
84102: CALL_OW 1
84106: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84107: LD_ADDR_EXP 65
84111: PUSH
84112: LD_EXP 65
84116: PPUSH
84117: LD_VAR 0 4
84121: PUSH
84122: LD_EXP 65
84126: PUSH
84127: LD_VAR 0 4
84131: ARRAY
84132: PUSH
84133: LD_INT 1
84135: PLUS
84136: PUSH
84137: EMPTY
84138: LIST
84139: LIST
84140: PPUSH
84141: LD_VAR 0 1
84145: PPUSH
84146: CALL 20497 0 3
84150: ST_TO_ADDR
// exit ;
84151: POP
84152: POP
84153: GO 84159
// end ; end ;
84155: GO 84003
84157: POP
84158: POP
// end ;
84159: LD_VAR 0 3
84163: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84164: LD_INT 0
84166: PPUSH
84167: PPUSH
84168: PPUSH
// if not mc_bases or not skirmish then
84169: LD_EXP 58
84173: NOT
84174: PUSH
84175: LD_EXP 56
84179: NOT
84180: OR
84181: IFFALSE 84185
// exit ;
84183: GO 84375
// for i = 1 to mc_bases do
84185: LD_ADDR_VAR 0 4
84189: PUSH
84190: DOUBLE
84191: LD_INT 1
84193: DEC
84194: ST_TO_ADDR
84195: LD_EXP 58
84199: PUSH
84200: FOR_TO
84201: IFFALSE 84288
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84203: LD_VAR 0 1
84207: PUSH
84208: LD_EXP 66
84212: PUSH
84213: LD_VAR 0 4
84217: ARRAY
84218: IN
84219: PUSH
84220: LD_VAR 0 1
84224: PUSH
84225: LD_EXP 67
84229: PUSH
84230: LD_VAR 0 4
84234: ARRAY
84235: IN
84236: NOT
84237: AND
84238: IFFALSE 84286
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84240: LD_ADDR_EXP 67
84244: PUSH
84245: LD_EXP 67
84249: PPUSH
84250: LD_VAR 0 4
84254: PUSH
84255: LD_EXP 67
84259: PUSH
84260: LD_VAR 0 4
84264: ARRAY
84265: PUSH
84266: LD_INT 1
84268: PLUS
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PPUSH
84274: LD_VAR 0 1
84278: PPUSH
84279: CALL 20497 0 3
84283: ST_TO_ADDR
// break ;
84284: GO 84288
// end ; end ;
84286: GO 84200
84288: POP
84289: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84290: LD_VAR 0 1
84294: PPUSH
84295: CALL_OW 257
84299: PUSH
84300: LD_EXP 84
84304: IN
84305: PUSH
84306: LD_VAR 0 1
84310: PPUSH
84311: CALL_OW 266
84315: PUSH
84316: LD_INT 5
84318: EQUAL
84319: AND
84320: PUSH
84321: LD_VAR 0 2
84325: PPUSH
84326: CALL_OW 110
84330: PUSH
84331: LD_INT 18
84333: NONEQUAL
84334: AND
84335: IFFALSE 84375
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84337: LD_VAR 0 2
84341: PPUSH
84342: CALL_OW 257
84346: PUSH
84347: LD_INT 5
84349: PUSH
84350: LD_INT 8
84352: PUSH
84353: LD_INT 9
84355: PUSH
84356: EMPTY
84357: LIST
84358: LIST
84359: LIST
84360: IN
84361: IFFALSE 84375
// SetClass ( unit , 1 ) ;
84363: LD_VAR 0 2
84367: PPUSH
84368: LD_INT 1
84370: PPUSH
84371: CALL_OW 336
// end ;
84375: LD_VAR 0 3
84379: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84380: LD_INT 0
84382: PPUSH
84383: PPUSH
// if not mc_bases or not skirmish then
84384: LD_EXP 58
84388: NOT
84389: PUSH
84390: LD_EXP 56
84394: NOT
84395: OR
84396: IFFALSE 84400
// exit ;
84398: GO 84516
// if GetLives ( abandoned_vehicle ) > 250 then
84400: LD_VAR 0 2
84404: PPUSH
84405: CALL_OW 256
84409: PUSH
84410: LD_INT 250
84412: GREATER
84413: IFFALSE 84417
// exit ;
84415: GO 84516
// for i = 1 to mc_bases do
84417: LD_ADDR_VAR 0 6
84421: PUSH
84422: DOUBLE
84423: LD_INT 1
84425: DEC
84426: ST_TO_ADDR
84427: LD_EXP 58
84431: PUSH
84432: FOR_TO
84433: IFFALSE 84514
// begin if driver in mc_bases [ i ] then
84435: LD_VAR 0 1
84439: PUSH
84440: LD_EXP 58
84444: PUSH
84445: LD_VAR 0 6
84449: ARRAY
84450: IN
84451: IFFALSE 84512
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84453: LD_VAR 0 1
84457: PPUSH
84458: LD_EXP 58
84462: PUSH
84463: LD_VAR 0 6
84467: ARRAY
84468: PPUSH
84469: LD_INT 2
84471: PUSH
84472: LD_INT 30
84474: PUSH
84475: LD_INT 0
84477: PUSH
84478: EMPTY
84479: LIST
84480: LIST
84481: PUSH
84482: LD_INT 30
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: LIST
84496: PPUSH
84497: CALL_OW 72
84501: PUSH
84502: LD_INT 1
84504: ARRAY
84505: PPUSH
84506: CALL_OW 112
// break ;
84510: GO 84514
// end ; end ;
84512: GO 84432
84514: POP
84515: POP
// end ; end_of_file
84516: LD_VAR 0 5
84520: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
84521: GO 84523
84523: DISABLE
// begin ru_radar := 98 ;
84524: LD_ADDR_EXP 101
84528: PUSH
84529: LD_INT 98
84531: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84532: LD_ADDR_EXP 102
84536: PUSH
84537: LD_INT 89
84539: ST_TO_ADDR
// us_hack := 99 ;
84540: LD_ADDR_EXP 103
84544: PUSH
84545: LD_INT 99
84547: ST_TO_ADDR
// us_artillery := 97 ;
84548: LD_ADDR_EXP 104
84552: PUSH
84553: LD_INT 97
84555: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84556: LD_ADDR_EXP 105
84560: PUSH
84561: LD_INT 91
84563: ST_TO_ADDR
// end ;
84564: END
