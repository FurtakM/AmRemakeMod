// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 56048 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 47938 0 9
// PrepareArabian ;
 140: CALL 3430 0 0
// PrepareRussian ;
 144: CALL 2554 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 57195 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6627 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 77673 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 78099 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 78552 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 78821 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 78039 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 78728 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 78099 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 78552 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 78821 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 77883 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 78039 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := false ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 0
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13515 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13515 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13515 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13515 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13515 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13515 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13515 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13515 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13515 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13515 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornel
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13515 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13515 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13515 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13515 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13515 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13515 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13515 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20148 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 63 , 9 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 63
1567: PPUSH
1568: LD_INT 9
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20148 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 2
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 4 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 60
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
// uc_side := 6 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 6
1696: ST_TO_ADDR
// uc_nation := 3 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// InitHc ;
1705: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1709: LD_ADDR_EXP 31
1713: PUSH
1714: LD_STRING Gossudarov
1716: PPUSH
1717: CALL_OW 25
1721: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1722: LD_ADDR_EXP 32
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: CALL_OW 25
1734: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1735: LD_ADDR_EXP 33
1739: PUSH
1740: LD_STRING Titov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Oblukov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1761: LD_ADDR_EXP 35
1765: PUSH
1766: LD_STRING Dolgov
1768: PPUSH
1769: CALL_OW 25
1773: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1774: LD_ADDR_EXP 36
1778: PUSH
1779: LD_STRING Petrosyan
1781: PPUSH
1782: CALL_OW 25
1786: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1787: LD_ADDR_EXP 37
1791: PUSH
1792: LD_STRING Scholtze
1794: PPUSH
1795: CALL_OW 25
1799: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1800: LD_ADDR_EXP 39
1804: PUSH
1805: LD_STRING Kapitsova
1807: PPUSH
1808: CALL_OW 25
1812: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_EXP 31
1822: PUSH
1823: LD_EXP 32
1827: PUSH
1828: LD_EXP 33
1832: PUSH
1833: LD_EXP 38
1837: PUSH
1838: LD_EXP 35
1842: PUSH
1843: LD_EXP 36
1847: PUSH
1848: LD_EXP 37
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1898
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1881: LD_VAR 0 3
1885: PPUSH
1886: LD_INT 14
1888: PPUSH
1889: LD_INT 0
1891: PPUSH
1892: CALL_OW 49
1896: GO 1878
1898: POP
1899: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1900: LD_VAR 0 2
1904: PPUSH
1905: LD_EXP 3
1909: PPUSH
1910: CALL_OW 250
1914: PPUSH
1915: LD_EXP 3
1919: PPUSH
1920: CALL_OW 251
1924: PPUSH
1925: CALL_OW 111
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareBelkov ; begin
1934: LD_INT 0
1936: PPUSH
// uc_side := 4 ;
1937: LD_ADDR_OWVAR 20
1941: PUSH
1942: LD_INT 4
1944: ST_TO_ADDR
// uc_nation := 3 ;
1945: LD_ADDR_OWVAR 21
1949: PUSH
1950: LD_INT 3
1952: ST_TO_ADDR
// InitHc ;
1953: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1957: LD_ADDR_EXP 46
1961: PUSH
1962: LD_STRING Belkov
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1970: LD_EXP 46
1974: PPUSH
1975: LD_INT 14
1977: PPUSH
1978: LD_INT 0
1980: PPUSH
1981: CALL_OW 49
// end ;
1985: LD_VAR 0 1
1989: RET
// export function PrepareGnyevko ; begin
1990: LD_INT 0
1992: PPUSH
// uc_side := 4 ;
1993: LD_ADDR_OWVAR 20
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// uc_nation := 3 ;
2001: LD_ADDR_OWVAR 21
2005: PUSH
2006: LD_INT 3
2008: ST_TO_ADDR
// InitHc ;
2009: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2013: LD_ADDR_EXP 47
2017: PUSH
2018: LD_STRING Gnyevko
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2026: LD_EXP 47
2030: PPUSH
2031: LD_INT 14
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 49
// end ;
2041: LD_VAR 0 1
2045: RET
// export function PrepareBurlak ; var i , tmp ; begin
2046: LD_INT 0
2048: PPUSH
2049: PPUSH
2050: PPUSH
// uc_side := 4 ;
2051: LD_ADDR_OWVAR 20
2055: PUSH
2056: LD_INT 4
2058: ST_TO_ADDR
// uc_nation := 3 ;
2059: LD_ADDR_OWVAR 21
2063: PUSH
2064: LD_INT 3
2066: ST_TO_ADDR
// InitHc ;
2067: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2071: LD_ADDR_EXP 45
2075: PUSH
2076: LD_STRING Burlak
2078: PPUSH
2079: CALL_OW 25
2083: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2084: LD_INT 24
2086: PUSH
2087: LD_INT 23
2089: PUSH
2090: LD_INT 22
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_OWVAR 67
2102: ARRAY
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: LD_INT 45
2112: PUSH
2113: LD_INT 44
2115: PUSH
2116: LD_INT 43
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: LIST
2123: PUSH
2124: LD_OWVAR 67
2128: ARRAY
2129: PPUSH
2130: LD_INT 0
2132: PPUSH
2133: CALL 20148 0 5
// Masha := CreateVehicle ;
2137: LD_ADDR_EXP 48
2141: PUSH
2142: CALL_OW 45
2146: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2147: LD_EXP 48
2151: PUSH
2152: LD_EXP 45
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PPUSH
2161: LD_INT 499
2163: PPUSH
2164: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2168: LD_EXP 48
2172: PPUSH
2173: LD_INT 3
2175: PPUSH
2176: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2180: LD_EXP 48
2184: PPUSH
2185: LD_INT 1
2187: PPUSH
2188: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2192: LD_EXP 48
2196: PPUSH
2197: LD_INT 18
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2207: LD_EXP 45
2211: PPUSH
2212: LD_INT 125
2214: PPUSH
2215: LD_INT 1
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2225: LD_EXP 45
2229: PPUSH
2230: LD_EXP 48
2234: PPUSH
2235: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2239: LD_INT 10
2241: PPUSH
2242: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2246: LD_EXP 48
2250: PPUSH
2251: LD_INT 110
2253: PPUSH
2254: LD_INT 10
2256: PPUSH
2257: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2261: LD_ADDR_EXP 41
2265: PUSH
2266: LD_STRING Petrovova
2268: PPUSH
2269: CALL_OW 25
2273: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2274: LD_ADDR_EXP 43
2278: PUSH
2279: LD_STRING Kuzmov
2281: PPUSH
2282: CALL_OW 25
2286: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2287: LD_ADDR_EXP 42
2291: PUSH
2292: LD_STRING Kovalyuk
2294: PPUSH
2295: CALL_OW 25
2299: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2300: LD_ADDR_EXP 40
2304: PUSH
2305: LD_STRING Lipshchin
2307: PPUSH
2308: CALL_OW 25
2312: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2313: LD_ADDR_EXP 44
2317: PUSH
2318: LD_STRING Karamazov
2320: PPUSH
2321: CALL_OW 25
2325: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: LD_EXP 41
2335: PUSH
2336: LD_EXP 43
2340: PUSH
2341: LD_EXP 42
2345: PUSH
2346: LD_EXP 40
2350: PUSH
2351: LD_EXP 44
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: ST_TO_ADDR
// for i in tmp do
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_IN
2374: IFFALSE 2413
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 399
2383: PPUSH
2384: LD_INT 799
2386: PPUSH
2387: CALL_OW 12
2391: PPUSH
2392: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2396: LD_VAR 0 2
2400: PPUSH
2401: LD_INT 19
2403: PPUSH
2404: LD_INT 0
2406: PPUSH
2407: CALL_OW 49
// end ;
2411: GO 2373
2413: POP
2414: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2415: LD_VAR 0 3
2419: PPUSH
2420: LD_INT 116
2422: PPUSH
2423: LD_INT 8
2425: PPUSH
2426: CALL_OW 111
// AddComHold ( tmp ) ;
2430: LD_VAR 0 3
2434: PPUSH
2435: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2439: LD_ADDR_VAR 0 2
2443: PUSH
2444: LD_VAR 0 3
2448: PPUSH
2449: LD_INT 25
2451: PUSH
2452: LD_INT 1
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PPUSH
2459: CALL_OW 72
2463: PUSH
2464: FOR_IN
2465: IFFALSE 2505
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2467: LD_VAR 0 2
2471: PPUSH
2472: LD_INT 20
2474: PPUSH
2475: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2479: LD_VAR 0 2
2483: PPUSH
2484: LD_INT 147
2486: PPUSH
2487: LD_INT 45
2489: PPUSH
2490: CALL_OW 178
// AddComCrawl ( i ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: CALL_OW 197
// end ;
2503: GO 2464
2505: POP
2506: POP
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) ;
2514: LD_EXP 48
2518: PPUSH
2519: LD_INT 110
2521: PPUSH
2522: LD_INT 10
2524: PPUSH
2525: CALL_OW 307
2529: IFFALSE 2507
// ComStop ( Burlak ) ;
2531: LD_EXP 45
2535: PPUSH
2536: CALL_OW 141
// AddComHold ( Burlak ) ;
2540: LD_EXP 45
2544: PPUSH
2545: CALL_OW 200
// end ; end_of_file
2549: LD_VAR 0 1
2553: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// uc_side := 3 ;
2560: LD_ADDR_OWVAR 20
2564: PUSH
2565: LD_INT 3
2567: ST_TO_ADDR
// uc_nation := 3 ;
2568: LD_ADDR_OWVAR 21
2572: PUSH
2573: LD_INT 3
2575: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2576: LD_ADDR_EXP 49
2580: PUSH
2581: LD_INT 47
2583: PPUSH
2584: LD_INT 4
2586: PPUSH
2587: LD_STRING 
2589: PPUSH
2590: LD_INT 7
2592: PUSH
2593: LD_INT 8
2595: PUSH
2596: LD_INT 9
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: PUSH
2604: LD_OWVAR 67
2608: ARRAY
2609: PPUSH
2610: LD_INT 10000
2612: PUSH
2613: LD_INT 3000
2615: PUSH
2616: LD_INT 300
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: PPUSH
2624: LD_INT 9
2626: PUSH
2627: LD_INT 5
2629: PUSH
2630: LD_INT 6
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: PPUSH
2642: CALL 23557 0 6
2646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2647: LD_ADDR_EXP 58
2651: PUSH
2652: LD_EXP 58
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: LD_EXP 49
2664: PPUSH
2665: CALL_OW 1
2669: ST_TO_ADDR
// tmp := [ ] ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: EMPTY
2676: ST_TO_ADDR
// for i = 1 to 4 do
2677: LD_ADDR_VAR 0 2
2681: PUSH
2682: DOUBLE
2683: LD_INT 1
2685: DEC
2686: ST_TO_ADDR
2687: LD_INT 4
2689: PUSH
2690: FOR_TO
2691: IFFALSE 2784
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2693: LD_INT 22
2695: PPUSH
2696: LD_INT 3
2698: PPUSH
2699: LD_INT 3
2701: PPUSH
2702: LD_INT 43
2704: PUSH
2705: LD_INT 45
2707: PUSH
2708: LD_INT 45
2710: PUSH
2711: LD_INT 44
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_INT 4
2727: MOD
2728: PUSH
2729: LD_INT 1
2731: PLUS
2732: ARRAY
2733: PPUSH
2734: LD_INT 100
2736: PPUSH
2737: CALL 20148 0 5
// veh := CreateVehicle ;
2741: LD_ADDR_VAR 0 3
2745: PUSH
2746: CALL_OW 45
2750: ST_TO_ADDR
// tmp := tmp ^ veh ;
2751: LD_ADDR_VAR 0 4
2755: PUSH
2756: LD_VAR 0 4
2760: PUSH
2761: LD_VAR 0 3
2765: ADD
2766: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 2
2774: PPUSH
2775: LD_INT 0
2777: PPUSH
2778: CALL_OW 49
// end ;
2782: GO 2690
2784: POP
2785: POP
// russian_guard := tmp ;
2786: LD_ADDR_EXP 50
2790: PUSH
2791: LD_VAR 0 4
2795: ST_TO_ADDR
// end ;
2796: LD_VAR 0 1
2800: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2801: LD_INT 47
2803: PPUSH
2804: CALL_OW 302
2808: PUSH
2809: LD_EXP 6
2813: AND
2814: IFFALSE 3427
2816: GO 2818
2818: DISABLE
2819: LD_INT 0
2821: PPUSH
2822: PPUSH
2823: PPUSH
2824: PPUSH
2825: PPUSH
2826: PPUSH
// begin enable ;
2827: ENABLE
// base := 2 ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 2
2835: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2836: LD_ADDR_VAR 0 4
2840: PUSH
2841: LD_INT 0
2843: PUSH
2844: LD_INT 0
2846: PUSH
2847: LD_INT 0
2849: PUSH
2850: LD_INT 0
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 0
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: LD_INT 0
2864: PUSH
2865: LD_INT 1
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2883: LD_ADDR_VAR 0 3
2887: PUSH
2888: LD_INT 22
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: LD_INT 45
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: LD_INT 21
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: LD_INT 3
2914: PUSH
2915: LD_INT 45
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: PUSH
2924: LD_INT 22
2926: PUSH
2927: LD_INT 1
2929: PUSH
2930: LD_INT 3
2932: PUSH
2933: LD_INT 45
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 23
2944: PUSH
2945: LD_INT 1
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: LD_INT 46
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
2966: LD_ADDR_VAR 0 1
2970: PUSH
2971: DOUBLE
2972: LD_INT 1
2974: DEC
2975: ST_TO_ADDR
2976: LD_OWVAR 67
2980: PUSH
2981: LD_OWVAR 1
2985: PUSH
2986: LD_INT 21000
2988: DIV
2989: PLUS
2990: PUSH
2991: FOR_TO
2992: IFFALSE 3080
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_VAR 0 3
3003: PPUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_INT 1
3011: PLUS
3012: PPUSH
3013: LD_INT 23
3015: PUSH
3016: LD_INT 24
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 1
3025: PPUSH
3026: LD_INT 2
3028: PPUSH
3029: CALL_OW 12
3033: ARRAY
3034: PUSH
3035: LD_INT 1
3037: PUSH
3038: LD_INT 3
3040: PUSH
3041: LD_INT 46
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 45
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 3
3060: PPUSH
3061: CALL_OW 12
3065: ARRAY
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 2
3077: ST_TO_ADDR
3078: GO 2991
3080: POP
3081: POP
// MC_SetProduceList ( base , tmp ) ;
3082: LD_VAR 0 2
3086: PPUSH
3087: LD_VAR 0 3
3091: PPUSH
3092: CALL 77991 0 2
// repeat wait ( 0 0$1 ) ;
3096: LD_INT 35
3098: PPUSH
3099: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
3103: LD_VAR 0 2
3107: PPUSH
3108: CALL 78445 0 1
3112: PUSH
3113: LD_INT 0
3115: EQUAL
3116: IFFALSE 3096
// wait ( 0 0$20 ) ;
3118: LD_INT 700
3120: PPUSH
3121: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3125: LD_ADDR_VAR 0 5
3129: PUSH
3130: LD_INT 71
3132: PUSH
3133: LD_INT 19
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: PUSH
3140: LD_INT 91
3142: PUSH
3143: LD_INT 67
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 52
3152: PUSH
3153: LD_INT 44
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: LD_INT 68
3162: PUSH
3163: LD_INT 48
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ) ;
3176: LD_ADDR_VAR 0 6
3180: PUSH
3181: LD_EXP 77
3185: PUSH
3186: LD_VAR 0 2
3190: ARRAY
3191: PUSH
3192: LD_EXP 80
3196: PUSH
3197: LD_VAR 0 2
3201: ARRAY
3202: PUSH
3203: LD_EXP 77
3207: PUSH
3208: LD_VAR 0 2
3212: ARRAY
3213: PPUSH
3214: LD_INT 2
3216: PUSH
3217: LD_INT 34
3219: PUSH
3220: LD_INT 51
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 34
3229: PUSH
3230: LD_INT 52
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 72
3246: UNION
3247: DIFF
3248: ST_TO_ADDR
// if not attackers then
3249: LD_VAR 0 6
3253: NOT
3254: IFFALSE 3258
// exit ;
3256: GO 3427
// ru_attackers := attackers ;
3258: LD_ADDR_EXP 51
3262: PUSH
3263: LD_VAR 0 6
3267: ST_TO_ADDR
// for i = 1 to attackers do
3268: LD_ADDR_VAR 0 1
3272: PUSH
3273: DOUBLE
3274: LD_INT 1
3276: DEC
3277: ST_TO_ADDR
3278: LD_VAR 0 6
3282: PUSH
3283: FOR_TO
3284: IFFALSE 3361
// begin case i mod 3 of 0 :
3286: LD_VAR 0 1
3290: PUSH
3291: LD_INT 3
3293: MOD
3294: PUSH
3295: LD_INT 0
3297: DOUBLE
3298: EQUAL
3299: IFTRUE 3303
3301: GO 3306
3303: POP
// ; 1 :
3304: GO 3359
3306: LD_INT 1
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3332
3314: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3315: LD_VAR 0 1
3319: PPUSH
3320: LD_INT 32
3322: PPUSH
3323: LD_INT 49
3325: PPUSH
3326: CALL_OW 114
3330: GO 3359
3332: LD_INT 2
3334: DOUBLE
3335: EQUAL
3336: IFTRUE 3340
3338: GO 3358
3340: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3341: LD_VAR 0 1
3345: PPUSH
3346: LD_INT 117
3348: PPUSH
3349: LD_INT 107
3351: PPUSH
3352: CALL_OW 114
3356: GO 3359
3358: POP
// end ;
3359: GO 3283
3361: POP
3362: POP
// repeat wait ( 0 0$1 ) ;
3363: LD_INT 35
3365: PPUSH
3366: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3370: LD_VAR 0 6
3374: PPUSH
3375: LD_INT 60
3377: PUSH
3378: EMPTY
3379: LIST
3380: PPUSH
3381: CALL_OW 72
3385: NOT
3386: IFFALSE 3363
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3388: LD_VAR 0 2
3392: PPUSH
3393: LD_VAR 0 6
3397: PPUSH
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_VAR 0 4
3407: PPUSH
3408: CALL 78282 0 4
// if not first_attack then
3412: LD_EXP 7
3416: NOT
3417: IFFALSE 3427
// first_attack := true ;
3419: LD_ADDR_EXP 7
3423: PUSH
3424: LD_INT 1
3426: ST_TO_ADDR
// end ; end_of_file
3427: PPOPN 6
3429: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3430: LD_INT 0
3432: PPUSH
3433: PPUSH
3434: PPUSH
3435: PPUSH
3436: PPUSH
3437: PPUSH
3438: PPUSH
// uc_side := 2 ;
3439: LD_ADDR_OWVAR 20
3443: PUSH
3444: LD_INT 2
3446: ST_TO_ADDR
// uc_nation := 2 ;
3447: LD_ADDR_OWVAR 21
3451: PUSH
3452: LD_INT 2
3454: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3455: LD_ADDR_EXP 54
3459: PUSH
3460: LD_STRING Abdul
3462: PPUSH
3463: CALL_OW 25
3467: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3468: LD_EXP 54
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3480: LD_EXP 54
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: CALL_OW 52
// vc_chassis := 31 ;
3492: LD_ADDR_OWVAR 37
3496: PUSH
3497: LD_INT 31
3499: ST_TO_ADDR
// vc_control := control_rider ;
3500: LD_ADDR_OWVAR 38
3504: PUSH
3505: LD_INT 4
3507: ST_TO_ADDR
// mastodont := CreateVehicle ;
3508: LD_ADDR_EXP 55
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3518: LD_EXP 55
3522: PPUSH
3523: LD_INT 153
3525: PPUSH
3526: LD_INT 71
3528: PPUSH
3529: LD_INT 0
3531: PPUSH
3532: CALL_OW 48
// InitVc ;
3536: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3540: LD_ADDR_EXP 52
3544: PUSH
3545: LD_INT 1
3547: PPUSH
3548: LD_INT 3
3550: PPUSH
3551: LD_STRING 
3553: PPUSH
3554: LD_INT 7
3556: PUSH
3557: LD_INT 8
3559: PUSH
3560: LD_INT 9
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: PUSH
3568: LD_OWVAR 67
3572: ARRAY
3573: PPUSH
3574: LD_INT 5000
3576: PUSH
3577: LD_INT 1000
3579: PUSH
3580: LD_INT 300
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: PPUSH
3588: LD_INT 22
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 6
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PPUSH
3606: CALL 23557 0 6
3610: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3611: LD_ADDR_EXP 58
3615: PUSH
3616: LD_EXP 58
3620: PPUSH
3621: LD_INT 1
3623: PPUSH
3624: LD_EXP 52
3628: PPUSH
3629: CALL_OW 1
3633: ST_TO_ADDR
// tmp := [ ] ;
3634: LD_ADDR_VAR 0 4
3638: PUSH
3639: EMPTY
3640: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3641: LD_ADDR_OWVAR 37
3645: PUSH
3646: LD_INT 14
3648: ST_TO_ADDR
// vc_engine := engine_siberite ;
3649: LD_ADDR_OWVAR 39
3653: PUSH
3654: LD_INT 3
3656: ST_TO_ADDR
// vc_control := control_manual ;
3657: LD_ADDR_OWVAR 38
3661: PUSH
3662: LD_INT 1
3664: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3665: LD_ADDR_OWVAR 40
3669: PUSH
3670: LD_INT 31
3672: ST_TO_ADDR
// for i = 1 to 3 do
3673: LD_ADDR_VAR 0 2
3677: PUSH
3678: DOUBLE
3679: LD_INT 1
3681: DEC
3682: ST_TO_ADDR
3683: LD_INT 3
3685: PUSH
3686: FOR_TO
3687: IFFALSE 3931
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3689: LD_ADDR_VAR 0 5
3693: PUSH
3694: LD_INT 153
3696: PUSH
3697: LD_INT 71
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 155
3706: PUSH
3707: LD_INT 81
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_VAR 0 2
3722: PUSH
3723: LD_INT 2
3725: MOD
3726: PUSH
3727: LD_INT 1
3729: PLUS
3730: ARRAY
3731: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3732: LD_INT 0
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 7
3740: PUSH
3741: LD_INT 8
3743: PUSH
3744: LD_INT 9
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: PUSH
3752: LD_OWVAR 67
3756: ARRAY
3757: PPUSH
3758: CALL_OW 380
// un := CreateVehicle ;
3762: LD_ADDR_VAR 0 6
3766: PUSH
3767: CALL_OW 45
3771: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3772: LD_VAR 0 6
3776: PPUSH
3777: LD_INT 0
3779: PPUSH
3780: LD_INT 5
3782: PPUSH
3783: CALL_OW 12
3787: PPUSH
3788: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3792: LD_VAR 0 6
3796: PPUSH
3797: LD_VAR 0 5
3801: PUSH
3802: LD_INT 1
3804: ARRAY
3805: PPUSH
3806: LD_VAR 0 5
3810: PUSH
3811: LD_INT 2
3813: ARRAY
3814: PPUSH
3815: LD_INT 6
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 50
// un2 := CreateHuman ;
3825: LD_ADDR_VAR 0 7
3829: PUSH
3830: CALL_OW 44
3834: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3835: LD_VAR 0 7
3839: PPUSH
3840: LD_VAR 0 6
3844: PPUSH
3845: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3849: LD_ADDR_EXP 58
3853: PUSH
3854: LD_EXP 58
3858: PPUSH
3859: LD_INT 1
3861: PUSH
3862: LD_EXP 58
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PUSH
3871: LD_INT 1
3873: PLUS
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: LD_VAR 0 6
3883: PPUSH
3884: CALL 20270 0 3
3888: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3889: LD_ADDR_EXP 58
3893: PUSH
3894: LD_EXP 58
3898: PPUSH
3899: LD_INT 1
3901: PUSH
3902: LD_EXP 58
3906: PUSH
3907: LD_INT 1
3909: ARRAY
3910: PUSH
3911: LD_INT 1
3913: PLUS
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: PPUSH
3919: LD_VAR 0 7
3923: PPUSH
3924: CALL 20270 0 3
3928: ST_TO_ADDR
// end ;
3929: GO 3686
3931: POP
3932: POP
// for i = 1 to 5 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 5
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4040
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3949: LD_INT 14
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 25
3960: PUSH
3961: LD_INT 28
3963: PUSH
3964: LD_INT 28
3966: PUSH
3967: LD_INT 26
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: PUSH
3976: LD_VAR 0 2
3980: PUSH
3981: LD_INT 4
3983: MOD
3984: PUSH
3985: LD_INT 1
3987: PLUS
3988: ARRAY
3989: PPUSH
3990: LD_INT 100
3992: PPUSH
3993: CALL 20148 0 5
// veh := CreateVehicle ;
3997: LD_ADDR_VAR 0 3
4001: PUSH
4002: CALL_OW 45
4006: ST_TO_ADDR
// tmp := tmp ^ veh ;
4007: LD_ADDR_VAR 0 4
4011: PUSH
4012: LD_VAR 0 4
4016: PUSH
4017: LD_VAR 0 3
4021: ADD
4022: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4023: LD_VAR 0 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 49
// end ;
4038: GO 3946
4040: POP
4041: POP
// arabian_guard := tmp ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_VAR 0 4
4051: ST_TO_ADDR
// end ;
4052: LD_VAR 0 1
4056: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4057: LD_INT 22
4059: PUSH
4060: LD_INT 7
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 91
4069: PUSH
4070: LD_INT 1
4072: PUSH
4073: LD_INT 12
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: LIST
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PPUSH
4085: CALL_OW 69
4089: PUSH
4090: LD_EXP 55
4094: PPUSH
4095: CALL_OW 256
4099: PUSH
4100: LD_INT 990
4102: LESS
4103: OR
4104: PUSH
4105: LD_EXP 54
4109: PPUSH
4110: CALL_OW 256
4114: PUSH
4115: LD_INT 990
4117: LESS
4118: OR
4119: IFFALSE 4262
4121: GO 4123
4123: DISABLE
// begin if IsInUnit ( Abdul ) then
4124: LD_EXP 54
4128: PPUSH
4129: CALL_OW 310
4133: IFFALSE 4144
// ComExitBuilding ( Abdul ) ;
4135: LD_EXP 54
4139: PPUSH
4140: CALL_OW 122
// if Mastodont then
4144: LD_EXP 55
4148: IFFALSE 4165
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4150: LD_EXP 55
4154: PPUSH
4155: LD_INT 205
4157: PPUSH
4158: LD_INT 132
4160: PPUSH
4161: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4165: LD_EXP 54
4169: PPUSH
4170: LD_INT 205
4172: PPUSH
4173: LD_INT 132
4175: PPUSH
4176: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4187: LD_EXP 54
4191: PPUSH
4192: LD_INT 21
4194: PPUSH
4195: CALL_OW 308
4199: IFFALSE 4180
// RemoveUnit ( Abdul ) ;
4201: LD_EXP 54
4205: PPUSH
4206: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4210: LD_INT 35
4212: PPUSH
4213: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4217: LD_EXP 55
4221: PPUSH
4222: LD_INT 21
4224: PPUSH
4225: CALL_OW 308
4229: PUSH
4230: LD_EXP 55
4234: PPUSH
4235: CALL_OW 301
4239: OR
4240: IFFALSE 4210
// if IsOk ( Mastodont ) then
4242: LD_EXP 55
4246: PPUSH
4247: CALL_OW 302
4251: IFFALSE 4262
// RemoveUnit ( Mastodont ) ;
4253: LD_EXP 55
4257: PPUSH
4258: CALL_OW 64
// end ;
4262: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4263: LD_EXP 54
4267: PPUSH
4268: CALL_OW 301
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 2
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 2
4285: PUSH
4286: LD_INT 25
4288: PUSH
4289: LD_INT 1
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 25
4298: PUSH
4299: LD_INT 2
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 25
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 25
4318: PUSH
4319: LD_INT 4
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 25
4328: PUSH
4329: LD_INT 8
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL_OW 69
4352: PUSH
4353: LD_INT 16
4355: PUSH
4356: LD_INT 19
4358: PUSH
4359: LD_INT 22
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PUSH
4367: LD_OWVAR 67
4371: ARRAY
4372: LESS
4373: OR
4374: IFFALSE 5047
4376: GO 4378
4378: DISABLE
4379: LD_INT 0
4381: PPUSH
4382: PPUSH
4383: PPUSH
4384: PPUSH
4385: PPUSH
4386: PPUSH
// begin MC_Kill ( 1 ) ;
4387: LD_INT 1
4389: PPUSH
4390: CALL 56283 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4394: LD_ADDR_VAR 0 2
4398: PUSH
4399: LD_INT 22
4401: PUSH
4402: LD_INT 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 25
4414: PUSH
4415: LD_INT 1
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 25
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 25
4434: PUSH
4435: LD_INT 3
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 4
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 25
4454: PUSH
4455: LD_INT 8
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 69
4478: ST_TO_ADDR
// for i in tmp do
4479: LD_ADDR_VAR 0 5
4483: PUSH
4484: LD_VAR 0 2
4488: PUSH
4489: FOR_IN
4490: IFFALSE 4506
// SetTag ( i , 10 ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_INT 10
4499: PPUSH
4500: CALL_OW 109
4504: GO 4489
4506: POP
4507: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: LD_INT 22
4515: PUSH
4516: LD_INT 2
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 21
4525: PUSH
4526: LD_INT 1
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PPUSH
4537: CALL_OW 69
4541: PUSH
4542: LD_VAR 0 2
4546: DIFF
4547: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4548: LD_ADDR_VAR 0 1
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 2
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 21
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: LD_INT 24
4575: PUSH
4576: LD_INT 300
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4593: LD_ADDR_VAR 0 4
4597: PUSH
4598: LD_VAR 0 1
4602: PPUSH
4603: LD_INT 33
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: LD_INT 58
4615: PUSH
4616: EMPTY
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 72
4627: ST_TO_ADDR
// for i in tmp do
4628: LD_ADDR_VAR 0 5
4632: PUSH
4633: LD_VAR 0 2
4637: PUSH
4638: FOR_IN
4639: IFFALSE 4823
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4641: LD_VAR 0 5
4645: PUSH
4646: LD_INT 55
4648: PUSH
4649: EMPTY
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: IN
4657: IFFALSE 4676
// begin AddComMoveXY ( i , 209 , 132 ) ;
4659: LD_VAR 0 5
4663: PPUSH
4664: LD_INT 209
4666: PPUSH
4667: LD_INT 132
4669: PPUSH
4670: CALL_OW 171
// continue ;
4674: GO 4638
// end ; if IsInUnit ( i ) then
4676: LD_VAR 0 5
4680: PPUSH
4681: CALL_OW 310
4685: IFFALSE 4703
// begin ComExitBuilding ( i ) ;
4687: LD_VAR 0 5
4691: PPUSH
4692: CALL_OW 122
// wait ( 3 ) ;
4696: LD_INT 3
4698: PPUSH
4699: CALL_OW 67
// end ; if tmp_empty then
4703: LD_VAR 0 4
4707: IFFALSE 4806
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_VAR 0 4
4718: PPUSH
4719: LD_VAR 0 5
4723: PPUSH
4724: CALL_OW 74
4728: PPUSH
4729: CALL_OW 296
4733: PUSH
4734: LD_INT 25
4736: LESS
4737: IFFALSE 4806
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4739: LD_ADDR_VAR 0 6
4743: PUSH
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 74
4758: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4759: LD_VAR 0 5
4763: PPUSH
4764: LD_VAR 0 6
4768: PPUSH
4769: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4773: LD_VAR 0 5
4777: PPUSH
4778: LD_INT 209
4780: PPUSH
4781: LD_INT 132
4783: PPUSH
4784: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4788: LD_ADDR_VAR 0 4
4792: PUSH
4793: LD_VAR 0 4
4797: PUSH
4798: LD_VAR 0 6
4802: DIFF
4803: ST_TO_ADDR
// continue ;
4804: GO 4638
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4806: LD_VAR 0 5
4810: PPUSH
4811: LD_INT 201
4813: PPUSH
4814: LD_INT 132
4816: PPUSH
4817: CALL_OW 171
// end ;
4821: GO 4638
4823: POP
4824: POP
// for i in tmp_ape do
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_VAR 0 3
4834: PUSH
4835: FOR_IN
4836: IFFALSE 4875
// begin if IsInUnit ( i ) then
4838: LD_VAR 0 5
4842: PPUSH
4843: CALL_OW 310
4847: IFFALSE 4858
// ComExitBuilding ( i ) ;
4849: LD_VAR 0 5
4853: PPUSH
4854: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_INT 201
4865: PPUSH
4866: LD_INT 132
4868: PPUSH
4869: CALL_OW 171
// end ;
4873: GO 4835
4875: POP
4876: POP
// repeat wait ( 0 0$1 ) ;
4877: LD_INT 35
4879: PPUSH
4880: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4884: LD_ADDR_VAR 0 5
4888: PUSH
4889: LD_VAR 0 2
4893: PUSH
4894: LD_VAR 0 3
4898: UNION
4899: PUSH
4900: LD_VAR 0 1
4904: UNION
4905: PUSH
4906: FOR_IN
4907: IFFALSE 4938
// if not HasTask ( i ) then
4909: LD_VAR 0 5
4913: PPUSH
4914: CALL_OW 314
4918: NOT
4919: IFFALSE 4936
// ComMoveXY ( i , 201 , 132 ) ;
4921: LD_VAR 0 5
4925: PPUSH
4926: LD_INT 201
4928: PPUSH
4929: LD_INT 132
4931: PPUSH
4932: CALL_OW 111
4936: GO 4906
4938: POP
4939: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4940: LD_INT 21
4942: PPUSH
4943: LD_INT 22
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 70
4957: IFFALSE 4998
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4959: LD_ADDR_VAR 0 5
4963: PUSH
4964: LD_INT 21
4966: PPUSH
4967: LD_INT 22
4969: PUSH
4970: LD_INT 2
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PPUSH
4977: CALL_OW 70
4981: PUSH
4982: FOR_IN
4983: IFFALSE 4996
// RemoveUnit ( i ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: CALL_OW 64
4994: GO 4982
4996: POP
4997: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
4998: LD_INT 22
5000: PUSH
5001: LD_INT 2
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: LD_INT 21
5013: PUSH
5014: LD_INT 1
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 21
5023: PUSH
5024: LD_INT 2
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: NOT
5045: IFFALSE 4877
// end ;
5047: PPOPN 6
5049: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5050: LD_EXP 9
5054: PUSH
5055: LD_INT 92
5057: PPUSH
5058: LD_INT 40
5060: PPUSH
5061: CALL_OW 428
5065: PPUSH
5066: CALL_OW 266
5070: PUSH
5071: LD_INT 30
5073: EQUAL
5074: AND
5075: IFFALSE 5271
5077: GO 5079
5079: DISABLE
5080: LD_INT 0
5082: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5083: LD_ADDR_VAR 0 1
5087: PUSH
5088: LD_EXP 58
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: PPUSH
5097: LD_INT 25
5099: PUSH
5100: LD_INT 4
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 72
5111: ST_TO_ADDR
// if not sci then
5112: LD_VAR 0 1
5116: NOT
5117: IFFALSE 5121
// exit ;
5119: GO 5271
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5121: LD_ADDR_EXP 58
5125: PUSH
5126: LD_EXP 58
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_EXP 58
5138: PUSH
5139: LD_INT 1
5141: ARRAY
5142: PUSH
5143: LD_VAR 0 1
5147: PUSH
5148: LD_INT 1
5150: ARRAY
5151: DIFF
5152: PPUSH
5153: CALL_OW 1
5157: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5158: LD_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ARRAY
5166: PPUSH
5167: CALL_OW 310
5171: IFFALSE 5186
// ComExitBuilding ( sci [ 1 ] ) ;
5173: LD_VAR 0 1
5177: PUSH
5178: LD_INT 1
5180: ARRAY
5181: PPUSH
5182: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5186: LD_INT 2
5188: PPUSH
5189: LD_INT 105
5191: PPUSH
5192: LD_INT 14
5194: PPUSH
5195: LD_INT 20
5197: PPUSH
5198: CALL 21166 0 4
5202: PUSH
5203: LD_INT 4
5205: ARRAY
5206: PUSH
5207: LD_INT 10
5209: LESS
5210: IFFALSE 5233
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5212: LD_VAR 0 1
5216: PUSH
5217: LD_INT 1
5219: ARRAY
5220: PPUSH
5221: LD_INT 105
5223: PPUSH
5224: LD_INT 14
5226: PPUSH
5227: CALL_OW 171
5231: GO 5252
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5233: LD_VAR 0 1
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PPUSH
5242: LD_INT 118
5244: PPUSH
5245: LD_INT 77
5247: PPUSH
5248: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5252: LD_VAR 0 1
5256: PUSH
5257: LD_INT 1
5259: ARRAY
5260: PPUSH
5261: LD_INT 92
5263: PPUSH
5264: LD_INT 40
5266: PPUSH
5267: CALL_OW 218
// end ;
5271: PPOPN 1
5273: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5274: LD_INT 1
5276: PPUSH
5277: CALL_OW 302
5281: PUSH
5282: LD_EXP 9
5286: AND
5287: IFFALSE 5757
5289: GO 5291
5291: DISABLE
5292: LD_INT 0
5294: PPUSH
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
5299: PPUSH
// begin enable ;
5300: ENABLE
// base := 1 ;
5301: LD_ADDR_VAR 0 2
5305: PUSH
5306: LD_INT 1
5308: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5309: LD_ADDR_VAR 0 4
5313: PUSH
5314: LD_INT 0
5316: PUSH
5317: LD_INT 0
5319: PUSH
5320: LD_INT 0
5322: PUSH
5323: LD_INT 0
5325: PUSH
5326: LD_INT 0
5328: PUSH
5329: LD_INT 0
5331: PUSH
5332: LD_INT 0
5334: PUSH
5335: LD_INT 0
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: LD_INT 0
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: LIST
5355: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5356: LD_ADDR_VAR 0 3
5360: PUSH
5361: LD_INT 14
5363: PUSH
5364: LD_INT 1
5366: PUSH
5367: LD_INT 2
5369: PUSH
5370: LD_INT 26
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 14
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: LD_INT 2
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 13
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 2
5405: PUSH
5406: LD_INT 29
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5420: LD_ADDR_VAR 0 1
5424: PUSH
5425: DOUBLE
5426: LD_INT 1
5428: DEC
5429: ST_TO_ADDR
5430: LD_OWVAR 67
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 21000
5442: DIV
5443: PLUS
5444: PUSH
5445: FOR_TO
5446: IFFALSE 5538
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5448: LD_ADDR_VAR 0 3
5452: PUSH
5453: LD_VAR 0 3
5457: PPUSH
5458: LD_VAR 0 3
5462: PUSH
5463: LD_INT 1
5465: PLUS
5466: PPUSH
5467: LD_INT 13
5469: PUSH
5470: LD_INT 14
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 1
5479: PPUSH
5480: LD_INT 2
5482: PPUSH
5483: CALL_OW 12
5487: ARRAY
5488: PUSH
5489: LD_INT 1
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: LD_INT 28
5497: PUSH
5498: LD_INT 29
5500: PUSH
5501: LD_INT 25
5503: PUSH
5504: LD_INT 26
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 1
5515: PPUSH
5516: LD_INT 4
5518: PPUSH
5519: CALL_OW 12
5523: ARRAY
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PPUSH
5531: CALL_OW 2
5535: ST_TO_ADDR
5536: GO 5445
5538: POP
5539: POP
// MC_SetProduceList ( base , tmp ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_VAR 0 3
5549: PPUSH
5550: CALL 77991 0 2
// repeat wait ( 0 0$1 ) ;
5554: LD_INT 35
5556: PPUSH
5557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL 78445 0 1
5570: PUSH
5571: LD_INT 0
5573: EQUAL
5574: IFFALSE 5554
// wait ( 0 0$20 ) ;
5576: LD_INT 700
5578: PPUSH
5579: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5583: LD_ADDR_VAR 0 5
5587: PUSH
5588: LD_INT 124
5590: PUSH
5591: LD_INT 85
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 90
5600: PUSH
5601: LD_INT 61
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 69
5610: PUSH
5611: LD_INT 48
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 68
5620: PUSH
5621: LD_INT 48
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
5634: LD_ADDR_VAR 0 6
5638: PUSH
5639: LD_EXP 77
5643: PUSH
5644: LD_VAR 0 2
5648: ARRAY
5649: PUSH
5650: LD_EXP 80
5654: PUSH
5655: LD_VAR 0 2
5659: ARRAY
5660: PUSH
5661: LD_EXP 77
5665: PUSH
5666: LD_VAR 0 2
5670: ARRAY
5671: PPUSH
5672: LD_INT 34
5674: PUSH
5675: LD_INT 32
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PPUSH
5682: CALL_OW 72
5686: UNION
5687: DIFF
5688: ST_TO_ADDR
// if not attackers then
5689: LD_VAR 0 6
5693: NOT
5694: IFFALSE 5698
// exit ;
5696: GO 5757
// ar_attackers := attackers ;
5698: LD_ADDR_EXP 10
5702: PUSH
5703: LD_VAR 0 6
5707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5715: LD_VAR 0 6
5719: PPUSH
5720: LD_INT 60
5722: PUSH
5723: EMPTY
5724: LIST
5725: PPUSH
5726: CALL_OW 72
5730: NOT
5731: IFFALSE 5708
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5733: LD_VAR 0 2
5737: PPUSH
5738: LD_VAR 0 6
5742: PPUSH
5743: LD_VAR 0 5
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL 78282 0 4
// end ;
5757: PPOPN 6
5759: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5760: LD_INT 1
5762: PPUSH
5763: CALL_OW 302
5767: PUSH
5768: LD_EXP 9
5772: AND
5773: PUSH
5774: LD_EXP 48
5778: PPUSH
5779: LD_INT 22
5781: PPUSH
5782: CALL_OW 308
5786: AND
5787: PUSH
5788: LD_INT 1
5790: PPUSH
5791: CALL 78445 0 1
5795: PUSH
5796: LD_INT 0
5798: EQUAL
5799: AND
5800: PUSH
5801: LD_EXP 10
5805: NOT
5806: AND
5807: IFFALSE 6282
5809: GO 5811
5811: DISABLE
5812: LD_INT 0
5814: PPUSH
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
// begin base := 1 ;
5821: LD_ADDR_VAR 0 2
5825: PUSH
5826: LD_INT 1
5828: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 0
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: LD_INT 0
5848: PUSH
5849: LD_INT 0
5851: PUSH
5852: LD_INT 0
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 0
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 13
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 27
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 13
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: LD_INT 25
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 11
5937: PUSH
5938: LD_INT 2
5940: PUSH
5941: LD_INT 2
5943: PUSH
5944: LD_INT 24
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 11
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 24
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// MC_SetProduceList ( base , tmp ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL 77991 0 2
// repeat wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 78445 0 1
6008: PUSH
6009: LD_INT 0
6011: EQUAL
6012: IFFALSE 5992
// wait ( 0 0$20 ) ;
6014: LD_INT 700
6016: PPUSH
6017: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6021: LD_ADDR_VAR 0 5
6025: PUSH
6026: LD_INT 119
6028: PUSH
6029: LD_INT 9
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PUSH
6036: EMPTY
6037: LIST
6038: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
6039: LD_ADDR_VAR 0 6
6043: PUSH
6044: LD_EXP 77
6048: PUSH
6049: LD_VAR 0 2
6053: ARRAY
6054: PUSH
6055: LD_EXP 80
6059: PUSH
6060: LD_VAR 0 2
6064: ARRAY
6065: PUSH
6066: LD_EXP 77
6070: PUSH
6071: LD_VAR 0 2
6075: ARRAY
6076: PPUSH
6077: LD_INT 34
6079: PUSH
6080: LD_INT 32
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: UNION
6092: DIFF
6093: ST_TO_ADDR
// if not attackers then
6094: LD_VAR 0 6
6098: NOT
6099: IFFALSE 6103
// exit ;
6101: GO 6282
// uc_side := 2 ;
6103: LD_ADDR_OWVAR 20
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// uc_nation := 2 ;
6111: LD_ADDR_OWVAR 21
6115: PUSH
6116: LD_INT 2
6118: ST_TO_ADDR
// InitHc ;
6119: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: DOUBLE
6129: LD_INT 1
6131: DEC
6132: ST_TO_ADDR
6133: LD_INT 4
6135: PUSH
6136: LD_INT 5
6138: PUSH
6139: LD_INT 6
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_OWVAR 67
6151: ARRAY
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6231
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6156: LD_INT 0
6158: PPUSH
6159: LD_INT 15
6161: PUSH
6162: LD_INT 17
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: PPUSH
6181: LD_INT 8
6183: PPUSH
6184: CALL_OW 380
// un := CreateHuman ;
6188: LD_ADDR_VAR 0 7
6192: PUSH
6193: CALL_OW 44
6197: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6198: LD_VAR 0 7
6202: PPUSH
6203: LD_INT 23
6205: PPUSH
6206: LD_INT 0
6208: PPUSH
6209: CALL_OW 49
// attackers := attackers union un ;
6213: LD_ADDR_VAR 0 6
6217: PUSH
6218: LD_VAR 0 6
6222: PUSH
6223: LD_VAR 0 7
6227: UNION
6228: ST_TO_ADDR
// end ;
6229: GO 6153
6231: POP
6232: POP
// repeat wait ( 0 0$1 ) ;
6233: LD_INT 35
6235: PPUSH
6236: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6240: LD_VAR 0 6
6244: PPUSH
6245: LD_INT 60
6247: PUSH
6248: EMPTY
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: NOT
6256: IFFALSE 6233
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6258: LD_VAR 0 2
6262: PPUSH
6263: LD_VAR 0 6
6267: PPUSH
6268: LD_VAR 0 5
6272: PPUSH
6273: LD_VAR 0 4
6277: PPUSH
6278: CALL 78282 0 4
// end ; end_of_file
6282: PPOPN 7
6284: END
// export function PrepareAmericanAttack ; var i , tmp , veh , flags , _target ; begin
6285: LD_INT 0
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
6291: PPUSH
6292: PPUSH
// uc_side := 1 ;
6293: LD_ADDR_OWVAR 20
6297: PUSH
6298: LD_INT 1
6300: ST_TO_ADDR
// uc_nation := 1 ;
6301: LD_ADDR_OWVAR 21
6305: PUSH
6306: LD_INT 1
6308: ST_TO_ADDR
// InitHc ;
6309: CALL_OW 19
// InitVc ;
6313: CALL_OW 20
// tmp := [ ] ;
6317: LD_ADDR_VAR 0 3
6321: PUSH
6322: EMPTY
6323: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6324: LD_ADDR_VAR 0 5
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_INT 0
6334: PUSH
6335: LD_INT 0
6337: PUSH
6338: LD_INT 0
6340: PUSH
6341: LD_INT 0
6343: PUSH
6344: LD_INT 0
6346: PUSH
6347: LD_INT 0
6349: PUSH
6350: LD_INT 0
6352: PUSH
6353: LD_INT 1
6355: PUSH
6356: LD_INT 0
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: ST_TO_ADDR
// _target := [ [ 71 , 34 ] , [ 63 , 49 ] ] ;
6371: LD_ADDR_VAR 0 6
6375: PUSH
6376: LD_INT 71
6378: PUSH
6379: LD_INT 34
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 63
6388: PUSH
6389: LD_INT 49
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6400: LD_ADDR_VAR 0 2
6404: PUSH
6405: DOUBLE
6406: LD_INT 1
6408: DEC
6409: ST_TO_ADDR
6410: LD_INT 5
6412: PUSH
6413: LD_INT 6
6415: PUSH
6416: LD_INT 6
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_OWVAR 67
6428: ARRAY
6429: PUSH
6430: FOR_TO
6431: IFFALSE 6568
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6433: LD_INT 2
6435: PUSH
6436: LD_INT 4
6438: PUSH
6439: LD_INT 5
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 1
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: CALL_OW 12
6457: ARRAY
6458: PPUSH
6459: LD_INT 1
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 2
6474: PPUSH
6475: CALL_OW 12
6479: ARRAY
6480: PPUSH
6481: LD_INT 3
6483: PPUSH
6484: LD_INT 9
6486: PUSH
6487: LD_INT 7
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 1
6496: PPUSH
6497: LD_INT 2
6499: PPUSH
6500: CALL_OW 12
6504: ARRAY
6505: PPUSH
6506: LD_INT 78
6508: PPUSH
6509: CALL 20148 0 5
// veh := CreateVehicle ;
6513: LD_ADDR_VAR 0 4
6517: PUSH
6518: CALL_OW 45
6522: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 2
6530: PPUSH
6531: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6535: LD_VAR 0 4
6539: PPUSH
6540: LD_INT 17
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// tmp := tmp ^ veh ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 4
6564: ADD
6565: ST_TO_ADDR
// end ;
6566: GO 6430
6568: POP
6569: POP
// if not tmp then
6570: LD_VAR 0 3
6574: NOT
6575: IFFALSE 6579
// exit ;
6577: GO 6622
// if not first_powell_attack then
6579: LD_EXP 11
6583: NOT
6584: IFFALSE 6594
// first_powell_attack := true ;
6586: LD_ADDR_EXP 11
6590: PUSH
6591: LD_INT 1
6593: ST_TO_ADDR
// Attack ( [ 0 , tmp , _target , flags ] ) ;
6594: LD_INT 0
6596: PUSH
6597: LD_VAR 0 3
6601: PUSH
6602: LD_VAR 0 6
6606: PUSH
6607: LD_VAR 0 5
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PPUSH
6618: CALL 48723 0 1
// end ; end_of_file
6622: LD_VAR 0 1
6626: RET
// export function Action ; var tmp , i , un ; begin
6627: LD_INT 0
6629: PPUSH
6630: PPUSH
6631: PPUSH
6632: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6633: LD_INT 68
6635: PPUSH
6636: LD_INT 39
6638: PPUSH
6639: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6643: LD_ADDR_VAR 0 2
6647: PUSH
6648: LD_INT 22
6650: PUSH
6651: LD_INT 7
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PPUSH
6658: CALL_OW 69
6662: ST_TO_ADDR
// InGameOn ;
6663: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 71
6674: PPUSH
6675: LD_INT 49
6677: PPUSH
6678: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6682: LD_INT 35
6684: PPUSH
6685: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6689: LD_INT 7
6691: PPUSH
6692: LD_INT 71
6694: PPUSH
6695: LD_INT 51
6697: PPUSH
6698: CALL_OW 293
6702: IFFALSE 6682
// DialogueOn ;
6704: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6708: LD_EXP 14
6712: PPUSH
6713: LD_STRING D1-JMM-1
6715: PPUSH
6716: CALL_OW 88
// if Joan then
6720: LD_EXP 29
6724: IFFALSE 6738
// Say ( Joan , D1-Joan-1 ) ;
6726: LD_EXP 29
6730: PPUSH
6731: LD_STRING D1-Joan-1
6733: PPUSH
6734: CALL_OW 88
// if Lisa then
6738: LD_EXP 16
6742: IFFALSE 6756
// Say ( Lisa , D1-Lisa-1 ) ;
6744: LD_EXP 16
6748: PPUSH
6749: LD_STRING D1-Lisa-1
6751: PPUSH
6752: CALL_OW 88
// if Joan or Lisa then
6756: LD_EXP 29
6760: PUSH
6761: LD_EXP 16
6765: OR
6766: IFFALSE 6780
// Say ( JMM , D1-JMM-2 ) ;
6768: LD_EXP 14
6772: PPUSH
6773: LD_STRING D1-JMM-2
6775: PPUSH
6776: CALL_OW 88
// DialogueOff ;
6780: CALL_OW 7
// InGameOff ;
6784: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6788: LD_INT 71
6790: PPUSH
6791: LD_INT 50
6793: PPUSH
6794: LD_INT 7
6796: PPUSH
6797: LD_INT 30
6799: NEG
6800: PPUSH
6801: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6805: LD_INT 71
6807: PPUSH
6808: LD_INT 50
6810: PPUSH
6811: LD_INT 7
6813: PPUSH
6814: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6818: LD_STRING M1
6820: PPUSH
6821: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6825: LD_INT 35
6827: PPUSH
6828: CALL_OW 67
// until freedom ;
6832: LD_EXP 3
6836: IFFALSE 6825
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6838: LD_INT 350
6840: PPUSH
6841: LD_INT 700
6843: PPUSH
6844: CALL_OW 12
6848: PPUSH
6849: CALL_OW 67
// PrepareGossudarov ;
6853: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6857: LD_INT 35
6859: PPUSH
6860: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6864: LD_INT 22
6866: PUSH
6867: LD_INT 6
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: LD_INT 24
6879: PUSH
6880: LD_INT 1000
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: PPUSH
6895: CALL_OW 69
6899: IFFALSE 6857
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6901: LD_ADDR_VAR 0 2
6905: PUSH
6906: LD_INT 22
6908: PUSH
6909: LD_INT 6
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for i in tmp do
6921: LD_ADDR_VAR 0 3
6925: PUSH
6926: LD_VAR 0 2
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6948
// SetSide ( i , 7 ) ;
6934: LD_VAR 0 3
6938: PPUSH
6939: LD_INT 7
6941: PPUSH
6942: CALL_OW 235
6946: GO 6931
6948: POP
6949: POP
// DialogueOn ;
6950: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6954: LD_EXP 14
6958: PUSH
6959: LD_EXP 15
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6977: LD_EXP 31
6981: PPUSH
6982: CALL_OW 87
// if not Roth then
6986: LD_EXP 15
6990: NOT
6991: IFFALSE 7055
// begin Say ( JMM , D2-JMM-1 ) ;
6993: LD_EXP 14
6997: PPUSH
6998: LD_STRING D2-JMM-1
7000: PPUSH
7001: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7005: LD_EXP 14
7009: PPUSH
7010: LD_STRING D2-JMM-1b
7012: PPUSH
7013: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7017: LD_EXP 31
7021: PPUSH
7022: LD_STRING D2-Gos-1
7024: PPUSH
7025: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7029: LD_EXP 14
7033: PPUSH
7034: LD_STRING D2-JMM-2
7036: PPUSH
7037: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7041: LD_EXP 31
7045: PPUSH
7046: LD_STRING D2-Gos-2
7048: PPUSH
7049: CALL_OW 88
// end else
7053: GO 7151
// begin Say ( Roth , D2-Roth-2 ) ;
7055: LD_EXP 15
7059: PPUSH
7060: LD_STRING D2-Roth-2
7062: PPUSH
7063: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7067: LD_EXP 14
7071: PPUSH
7072: LD_STRING D2-JMM-1a
7074: PPUSH
7075: CALL_OW 88
// Say ( Roth , D2-Roth-2a ) ;
7079: LD_EXP 15
7083: PPUSH
7084: LD_STRING D2-Roth-2a
7086: PPUSH
7087: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7091: LD_EXP 15
7095: PPUSH
7096: LD_STRING D2-Roth-2b
7098: PPUSH
7099: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7103: LD_EXP 14
7107: PPUSH
7108: LD_STRING D2-JMM-3
7110: PPUSH
7111: CALL_OW 88
// Say ( Gossudarov , D2-Gos-3 ) ;
7115: LD_EXP 31
7119: PPUSH
7120: LD_STRING D2-Gos-3
7122: PPUSH
7123: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7127: LD_EXP 14
7131: PPUSH
7132: LD_STRING D2-JMM-4
7134: PPUSH
7135: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7139: LD_EXP 31
7143: PPUSH
7144: LD_STRING D2-Gos-4
7146: PPUSH
7147: CALL_OW 88
// end ; Say ( JMM , D2-JMM-5 ) ;
7151: LD_EXP 14
7155: PPUSH
7156: LD_STRING D2-JMM-5
7158: PPUSH
7159: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7163: LD_EXP 31
7167: PPUSH
7168: LD_STRING D2-Gos-5
7170: PPUSH
7171: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7175: LD_EXP 14
7179: PPUSH
7180: LD_STRING D2-JMM-6
7182: PPUSH
7183: CALL_OW 88
// DialogueOff ;
7187: CALL_OW 7
// wait ( 0 0$2 ) ;
7191: LD_INT 70
7193: PPUSH
7194: CALL_OW 67
// if Kirilenkova then
7198: LD_EXP 32
7202: IFFALSE 7216
// Say ( Kirilenkova , D3-Kir-1 ) ;
7204: LD_EXP 32
7208: PPUSH
7209: LD_STRING D3-Kir-1
7211: PPUSH
7212: CALL_OW 88
// gossudarov_arrive := true ;
7216: LD_ADDR_EXP 4
7220: PUSH
7221: LD_INT 1
7223: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7224: LD_INT 35
7226: PPUSH
7227: CALL_OW 67
// until ru_lab_builded ;
7231: LD_EXP 5
7235: IFFALSE 7224
// if Kirilenkova then
7237: LD_EXP 32
7241: IFFALSE 7257
// Say ( Kirilenkova , D3a-Kir-1 ) else
7243: LD_EXP 32
7247: PPUSH
7248: LD_STRING D3a-Kir-1
7250: PPUSH
7251: CALL_OW 88
7255: GO 7279
// begin un := SciRu ;
7257: LD_ADDR_VAR 0 4
7261: PUSH
7262: CALL 12046 0 0
7266: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7267: LD_VAR 0 4
7271: PPUSH
7272: LD_STRING D3a-Sci1-1
7274: PPUSH
7275: CALL_OW 88
// end ; if Kirilenkova or un then
7279: LD_EXP 32
7283: PUSH
7284: LD_VAR 0 4
7288: OR
7289: IFFALSE 7303
// Say ( JMM , D3a-JMM-1 ) ;
7291: LD_EXP 14
7295: PPUSH
7296: LD_STRING D3a-JMM-1
7298: PPUSH
7299: CALL_OW 88
// end ;
7303: LD_VAR 0 1
7307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7308: LD_EXP 4
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_INT 7
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 1
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: LD_INT 25
7338: PUSH
7339: LD_INT 2
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PUSH
7346: LD_INT 25
7348: PUSH
7349: LD_INT 3
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 25
7358: PUSH
7359: LD_INT 4
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: PUSH
7366: LD_INT 25
7368: PUSH
7369: LD_INT 5
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PUSH
7376: LD_INT 25
7378: PUSH
7379: LD_INT 8
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 25
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PPUSH
7410: CALL_OW 69
7414: PUSH
7415: LD_INT 6
7417: LESS
7418: AND
7419: IFFALSE 7431
7421: GO 7423
7423: DISABLE
// YouLost ( TooMany ) ;
7424: LD_STRING TooMany
7426: PPUSH
7427: CALL_OW 104
7431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7432: LD_EXP 31
7436: PPUSH
7437: CALL_OW 255
7441: PUSH
7442: LD_INT 7
7444: EQUAL
7445: IFFALSE 7645
7447: GO 7449
7449: DISABLE
7450: LD_INT 0
7452: PPUSH
7453: PPUSH
7454: PPUSH
// begin uc_side := 3 ;
7455: LD_ADDR_OWVAR 20
7459: PUSH
7460: LD_INT 3
7462: ST_TO_ADDR
// uc_nation := 3 ;
7463: LD_ADDR_OWVAR 21
7467: PUSH
7468: LD_INT 3
7470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7471: LD_INT 21
7473: PPUSH
7474: LD_INT 3
7476: PPUSH
7477: LD_INT 3
7479: PPUSH
7480: LD_INT 42
7482: PPUSH
7483: LD_INT 100
7485: PPUSH
7486: CALL 20148 0 5
// un := CreateVehicle ;
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: CALL_OW 45
7499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7500: LD_VAR 0 3
7504: PPUSH
7505: LD_INT 15
7507: PPUSH
7508: LD_INT 0
7510: PPUSH
7511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7515: LD_VAR 0 3
7519: PPUSH
7520: LD_INT 67
7522: PPUSH
7523: LD_INT 45
7525: PPUSH
7526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7530: LD_VAR 0 3
7534: PPUSH
7535: LD_INT 70
7537: PPUSH
7538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7542: LD_VAR 0 3
7546: PPUSH
7547: LD_INT 69
7549: PPUSH
7550: LD_INT 18
7552: PPUSH
7553: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7557: LD_VAR 0 3
7561: PPUSH
7562: LD_INT 60
7564: PPUSH
7565: LD_INT 2
7567: PPUSH
7568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7572: LD_INT 35
7574: PPUSH
7575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7579: LD_VAR 0 3
7583: PPUSH
7584: CALL_OW 302
7588: NOT
7589: PUSH
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 17
7597: PPUSH
7598: CALL_OW 308
7602: OR
7603: IFFALSE 7572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 17
7612: PPUSH
7613: CALL_OW 308
7617: PUSH
7618: LD_VAR 0 3
7622: PPUSH
7623: LD_INT 60
7625: PPUSH
7626: LD_INT 2
7628: PPUSH
7629: CALL_OW 307
7633: OR
7634: IFFALSE 7645
// RemoveUnit ( un ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 64
// end ;
7645: PPOPN 3
7647: END
// every 0 0$2 do var i , un , tmp ;
7648: GO 7650
7650: DISABLE
7651: LD_INT 0
7653: PPUSH
7654: PPUSH
7655: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7656: LD_INT 70
7658: PPUSH
7659: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7663: LD_ADDR_VAR 0 3
7667: PUSH
7668: LD_INT 22
7670: PUSH
7671: LD_INT 7
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 101
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PPUSH
7692: CALL_OW 69
7696: ST_TO_ADDR
// until tmp ;
7697: LD_VAR 0 3
7701: IFFALSE 7656
// un := NearestUnitToUnit ( tmp , JMM ) ;
7703: LD_ADDR_VAR 0 2
7707: PUSH
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_EXP 14
7717: PPUSH
7718: CALL_OW 74
7722: ST_TO_ADDR
// player_spotted := true ;
7723: LD_ADDR_EXP 6
7727: PUSH
7728: LD_INT 1
7730: ST_TO_ADDR
// tmp := SciRu ;
7731: LD_ADDR_VAR 0 3
7735: PUSH
7736: CALL 12046 0 0
7740: ST_TO_ADDR
// DialogueOn ;
7741: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7745: LD_VAR 0 2
7749: PPUSH
7750: CALL_OW 250
7754: PPUSH
7755: LD_VAR 0 2
7759: PPUSH
7760: CALL_OW 251
7764: PPUSH
7765: LD_INT 7
7767: PPUSH
7768: LD_INT 8
7770: NEG
7771: PPUSH
7772: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: CALL_OW 87
// if tmp then
7785: LD_VAR 0 3
7789: IFFALSE 7803
// Say ( tmp , D4-RSci1-1 ) ;
7791: LD_VAR 0 3
7795: PPUSH
7796: LD_STRING D4-RSci1-1
7798: PPUSH
7799: CALL_OW 88
// if Gossudarov then
7803: LD_EXP 31
7807: IFFALSE 7833
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7809: LD_EXP 31
7813: PPUSH
7814: LD_STRING D4-Gos-1
7816: PPUSH
7817: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7821: LD_EXP 14
7825: PPUSH
7826: LD_STRING D4-JMM-1
7828: PPUSH
7829: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7833: LD_VAR 0 2
7837: PPUSH
7838: CALL_OW 250
7842: PPUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: CALL_OW 251
7852: PPUSH
7853: LD_INT 7
7855: PPUSH
7856: CALL_OW 331
// DialogueOff ;
7860: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7864: LD_STRING M5
7866: PPUSH
7867: CALL_OW 337
// end ;
7871: PPOPN 3
7873: END
// every 0 0$30 + 2 2$30 trigger player_spotted do
7874: LD_EXP 6
7878: IFFALSE 8337
7880: GO 7882
7882: DISABLE
// begin PrepareBelkov ;
7883: CALL 1934 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7887: LD_EXP 46
7891: PPUSH
7892: LD_INT 118
7894: PPUSH
7895: LD_INT 106
7897: PPUSH
7898: CALL_OW 111
// AddComHold ( Belkov ) ;
7902: LD_EXP 46
7906: PPUSH
7907: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
7911: LD_INT 35
7913: PPUSH
7914: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
7918: LD_EXP 46
7922: PPUSH
7923: LD_INT 118
7925: PPUSH
7926: LD_INT 106
7928: PPUSH
7929: CALL_OW 307
7933: IFFALSE 7911
// ChangeSideFog ( 4 , 7 ) ;
7935: LD_INT 4
7937: PPUSH
7938: LD_INT 7
7940: PPUSH
7941: CALL_OW 343
// if IsOk ( Belkov ) then
7945: LD_EXP 46
7949: PPUSH
7950: CALL_OW 302
7954: IFFALSE 8038
// begin InGameOn ;
7956: CALL_OW 8
// DialogueOn ;
7960: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
7964: LD_EXP 46
7968: PPUSH
7969: LD_STRING D5-Bel-1
7971: PPUSH
7972: CALL_OW 94
// if Gossudarov then
7976: LD_EXP 31
7980: IFFALSE 8030
// begin Say ( Gossudarov , D5-Gos-1 ) ;
7982: LD_EXP 31
7986: PPUSH
7987: LD_STRING D5-Gos-1
7989: PPUSH
7990: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
7994: LD_EXP 14
7998: PPUSH
7999: LD_STRING D5-JMM-1
8001: PPUSH
8002: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8006: LD_EXP 31
8010: PPUSH
8011: LD_STRING D5-Gos-2
8013: PPUSH
8014: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8018: LD_EXP 14
8022: PPUSH
8023: LD_STRING D5-JMM-2
8025: PPUSH
8026: CALL_OW 88
// end ; DialogueOff ;
8030: CALL_OW 7
// InGameOff ;
8034: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8038: LD_STRING QSaveBelkov
8040: PPUSH
8041: CALL_OW 97
8045: PUSH
8046: LD_INT 1
8048: DOUBLE
8049: EQUAL
8050: IFTRUE 8054
8052: GO 8104
8054: POP
// begin DialogueOn ;
8055: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8059: LD_EXP 14
8063: PPUSH
8064: LD_STRING D5a-JMM-1
8066: PPUSH
8067: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8071: LD_EXP 46
8075: PPUSH
8076: LD_STRING D5a-Bel-1
8078: PPUSH
8079: CALL_OW 94
// DialogueOff ;
8083: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8087: LD_EXP 46
8091: PPUSH
8092: LD_INT 83
8094: PPUSH
8095: LD_INT 49
8097: PPUSH
8098: CALL_OW 111
// end ; 2 :
8102: GO 8164
8104: LD_INT 2
8106: DOUBLE
8107: EQUAL
8108: IFTRUE 8112
8110: GO 8163
8112: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8113: LD_EXP 14
8117: PPUSH
8118: LD_STRING D5a-JMM-2
8120: PPUSH
8121: CALL_OW 88
// ComWait ( Belkov , 0 0$10 ) ;
8125: LD_EXP 46
8129: PPUSH
8130: LD_INT 350
8132: PPUSH
8133: CALL_OW 142
// AddComMoveXY ( Belkov , 107 , 109 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_INT 107
8144: PPUSH
8145: LD_INT 109
8147: PPUSH
8148: CALL_OW 171
// AddComHold ( Belkov ) ;
8152: LD_EXP 46
8156: PPUSH
8157: CALL_OW 200
// end ; end ;
8161: GO 8164
8163: POP
// repeat wait ( 0 0$1 ) ;
8164: LD_INT 35
8166: PPUSH
8167: CALL_OW 67
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8171: LD_EXP 46
8175: PPUSH
8176: CALL_OW 301
8180: PUSH
8181: LD_EXP 46
8185: PPUSH
8186: CALL_OW 255
8190: PUSH
8191: LD_INT 4
8193: EQUAL
8194: AND
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 7
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PPUSH
8206: CALL_OW 69
8210: PPUSH
8211: LD_EXP 46
8215: PPUSH
8216: CALL_OW 74
8220: PPUSH
8221: LD_EXP 46
8225: PPUSH
8226: CALL_OW 296
8230: PUSH
8231: LD_INT 10
8233: LESS
8234: OR
8235: IFFALSE 8164
// if IsDead ( Belkov ) then
8237: LD_EXP 46
8241: PPUSH
8242: CALL_OW 301
8246: IFFALSE 8271
// begin CenterNowOnUnits ( Belkov ) ;
8248: LD_EXP 46
8252: PPUSH
8253: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8257: LD_EXP 14
8261: PPUSH
8262: LD_STRING D5a-JMM-2a
8264: PPUSH
8265: CALL_OW 88
// exit ;
8269: GO 8337
// end ; if See ( 7 , Belkov ) then
8271: LD_INT 7
8273: PPUSH
8274: LD_EXP 46
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8297
// SetSide ( Belkov , 7 ) ;
8285: LD_EXP 46
8289: PPUSH
8290: LD_INT 7
8292: PPUSH
8293: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8304: LD_EXP 46
8308: PPUSH
8309: LD_INT 66
8311: PPUSH
8312: LD_INT 45
8314: PPUSH
8315: CALL_OW 297
8319: PUSH
8320: LD_INT 30
8322: LESS
8323: IFFALSE 8297
// Say ( Belkov , D6-Bel-1 ) ;
8325: LD_EXP 46
8329: PPUSH
8330: LD_STRING D6-Bel-1
8332: PPUSH
8333: CALL_OW 88
// end ;
8337: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8338: LD_EXP 46
8342: PPUSH
8343: CALL_OW 302
8347: PUSH
8348: LD_EXP 46
8352: PPUSH
8353: CALL_OW 504
8357: PUSH
8358: LD_INT 2
8360: PUSH
8361: LD_INT 34
8363: PUSH
8364: LD_INT 47
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PUSH
8371: LD_INT 34
8373: PUSH
8374: LD_INT 45
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: PPUSH
8386: CALL_OW 69
8390: IN
8391: AND
8392: IFFALSE 8409
8394: GO 8396
8396: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8397: LD_EXP 46
8401: PPUSH
8402: LD_STRING D7-Bel-1
8404: PPUSH
8405: CALL_OW 88
8409: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8410: LD_INT 22
8412: PUSH
8413: LD_INT 7
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 101
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PPUSH
8434: CALL_OW 69
8438: PUSH
8439: LD_EXP 8
8443: NOT
8444: AND
8445: PUSH
8446: LD_EXP 45
8450: PPUSH
8451: CALL_OW 305
8455: NOT
8456: AND
8457: IFFALSE 8927
8459: GO 8461
8461: DISABLE
8462: LD_INT 0
8464: PPUSH
// begin ar_base_spotted := true ;
8465: LD_ADDR_EXP 8
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 21
8490: PUSH
8491: LD_INT 3
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8507: LD_ADDR_VAR 0 1
8511: PUSH
8512: LD_VAR 0 1
8516: PPUSH
8517: LD_EXP 14
8521: PPUSH
8522: CALL_OW 74
8526: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8527: LD_INT 7
8529: PPUSH
8530: LD_INT 3
8532: PPUSH
8533: CALL_OW 332
// DialogueOn ;
8537: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8541: LD_VAR 0 1
8545: PPUSH
8546: CALL_OW 250
8550: PPUSH
8551: LD_VAR 0 1
8555: PPUSH
8556: CALL_OW 251
8560: PPUSH
8561: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_INT 22
8572: PUSH
8573: LD_INT 7
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PUSH
8580: LD_INT 23
8582: PUSH
8583: LD_INT 1
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PUSH
8590: LD_INT 26
8592: PUSH
8593: LD_INT 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: LIST
8604: PPUSH
8605: CALL_OW 69
8609: PUSH
8610: LD_EXP 14
8614: PUSH
8615: LD_EXP 18
8619: PUSH
8620: LD_EXP 19
8624: PUSH
8625: LD_EXP 26
8629: PUSH
8630: LD_EXP 15
8634: PUSH
8635: LD_EXP 24
8639: PUSH
8640: LD_EXP 20
8644: PUSH
8645: LD_EXP 22
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: DIFF
8660: ST_TO_ADDR
// if not tmp then
8661: LD_VAR 0 1
8665: NOT
8666: IFFALSE 8740
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8668: LD_ADDR_VAR 0 1
8672: PUSH
8673: LD_INT 22
8675: PUSH
8676: LD_INT 7
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 23
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: PUSH
8693: LD_INT 26
8695: PUSH
8696: LD_INT 2
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: PUSH
8713: LD_EXP 29
8717: PUSH
8718: LD_EXP 16
8722: PUSH
8723: LD_EXP 27
8727: PUSH
8728: LD_EXP 28
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: DIFF
8739: ST_TO_ADDR
// if tmp then
8740: LD_VAR 0 1
8744: IFFALSE 8815
// case GetSex ( tmp [ 1 ] ) of sex_male :
8746: LD_VAR 0 1
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: CALL_OW 258
8759: PUSH
8760: LD_INT 1
8762: DOUBLE
8763: EQUAL
8764: IFTRUE 8768
8766: GO 8787
8768: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8769: LD_VAR 0 1
8773: PUSH
8774: LD_INT 1
8776: ARRAY
8777: PPUSH
8778: LD_STRING D9-Sol1-1
8780: PPUSH
8781: CALL_OW 88
8785: GO 8815
8787: LD_INT 2
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8814
8795: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
8796: LD_VAR 0 1
8800: PUSH
8801: LD_INT 1
8803: ARRAY
8804: PPUSH
8805: LD_STRING D9-FSol1-1
8807: PPUSH
8808: CALL_OW 88
8812: GO 8815
8814: POP
// if Frank then
8815: LD_EXP 26
8819: IFFALSE 8923
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
8821: LD_EXP 55
8825: PPUSH
8826: CALL_OW 250
8830: PPUSH
8831: LD_EXP 55
8835: PPUSH
8836: CALL_OW 251
8840: PPUSH
8841: LD_INT 7
8843: PPUSH
8844: LD_INT 8
8846: PPUSH
8847: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
8851: LD_EXP 55
8855: PPUSH
8856: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
8860: LD_EXP 26
8864: PPUSH
8865: LD_STRING D9-Frank-1
8867: PPUSH
8868: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
8872: LD_EXP 14
8876: PPUSH
8877: LD_STRING D9-JMM-1
8879: PPUSH
8880: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
8884: LD_EXP 26
8888: PPUSH
8889: LD_STRING D9-Frank-2
8891: PPUSH
8892: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
8896: LD_EXP 55
8900: PPUSH
8901: CALL_OW 250
8905: PPUSH
8906: LD_EXP 55
8910: PPUSH
8911: CALL_OW 251
8915: PPUSH
8916: LD_INT 7
8918: PPUSH
8919: CALL_OW 331
// end ; DialogueOff ;
8923: CALL_OW 7
// end ;
8927: PPOPN 1
8929: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
8930: LD_EXP 7
8934: PUSH
8935: LD_OWVAR 1
8939: PUSH
8940: LD_INT 42000
8942: GREATEREQUAL
8943: OR
8944: IFFALSE 9971
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
8952: PPUSH
// begin selected_option := 1 ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_INT 1
8960: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8961: LD_INT 10500
8963: PPUSH
8964: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8968: LD_INT 35
8970: PPUSH
8971: CALL_OW 67
// until not ru_attackers ;
8975: LD_EXP 51
8979: NOT
8980: IFFALSE 8968
// PrepareBurlak ;
8982: CALL 2046 0 0
// repeat wait ( 0 0$2 ) ;
8986: LD_INT 70
8988: PPUSH
8989: CALL_OW 67
// until not HasTask ( Burlak ) ;
8993: LD_EXP 45
8997: PPUSH
8998: CALL_OW 314
9002: NOT
9003: IFFALSE 8986
// InGameOn ;
9005: CALL_OW 8
// DialogueOn ;
9009: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9013: LD_EXP 48
9017: PPUSH
9018: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9022: LD_EXP 45
9026: PPUSH
9027: LD_STRING D10-Bur-1
9029: PPUSH
9030: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9034: LD_EXP 46
9038: PUSH
9039: LD_EXP 46
9043: PPUSH
9044: CALL_OW 255
9048: PUSH
9049: LD_INT 7
9051: EQUAL
9052: AND
9053: IFFALSE 9067
// Say ( Belkov , D10-Bel-1 ) ;
9055: LD_EXP 46
9059: PPUSH
9060: LD_STRING D10-Bel-1
9062: PPUSH
9063: CALL_OW 88
// if Gossudarov then
9067: LD_EXP 31
9071: IFFALSE 9085
// Say ( Gossudarov , D10-Gos-1 ) ;
9073: LD_EXP 31
9077: PPUSH
9078: LD_STRING D10-Gos-1
9080: PPUSH
9081: CALL_OW 88
// if Kirilenkova then
9085: LD_EXP 32
9089: IFFALSE 9103
// Say ( Kirilenkova , D10-Kir-1 ) ;
9091: LD_EXP 32
9095: PPUSH
9096: LD_STRING D10-Kir-1
9098: PPUSH
9099: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9103: CALL 12175 0 0
9107: PPUSH
9108: LD_STRING D10-RSol1-1
9110: PPUSH
9111: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9115: LD_EXP 45
9119: PPUSH
9120: LD_STRING D10-Bur-2
9122: PPUSH
9123: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9127: LD_EXP 14
9131: PPUSH
9132: LD_STRING D10-JMM-2
9134: PPUSH
9135: CALL_OW 88
// if Kirilenkova then
9139: LD_EXP 32
9143: IFFALSE 9159
// Say ( Kirilenkova , D10-Kir-2 ) else
9145: LD_EXP 32
9149: PPUSH
9150: LD_STRING D10-Kir-2
9152: PPUSH
9153: CALL_OW 88
9157: GO 9171
// Say ( SolRu , D10-RSol1-2 ) ;
9159: CALL 12175 0 0
9163: PPUSH
9164: LD_STRING D10-RSol1-2
9166: PPUSH
9167: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9171: LD_EXP 14
9175: PPUSH
9176: LD_STRING D10-JMM-3
9178: PPUSH
9179: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9183: LD_EXP 45
9187: PPUSH
9188: LD_STRING D10-Bur-3
9190: PPUSH
9191: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9195: LD_EXP 14
9199: PPUSH
9200: LD_STRING D10-JMM-4
9202: PPUSH
9203: CALL_OW 88
// DialogueOff ;
9207: CALL_OW 7
// InGameOff ;
9211: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9215: LD_STRING M2
9217: PPUSH
9218: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9222: LD_INT 35
9224: PPUSH
9225: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9229: LD_INT 22
9231: PUSH
9232: LD_INT 7
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 91
9241: PUSH
9242: LD_EXP 45
9246: PUSH
9247: LD_INT 8
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: PPUSH
9259: CALL_OW 69
9263: IFFALSE 9222
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9265: LD_ADDR_VAR 0 1
9269: PUSH
9270: LD_INT 22
9272: PUSH
9273: LD_INT 4
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 69
9284: PUSH
9285: FOR_IN
9286: IFFALSE 9302
// SetSide ( i , 7 ) ;
9288: LD_VAR 0 1
9292: PPUSH
9293: LD_INT 7
9295: PPUSH
9296: CALL_OW 235
9300: GO 9285
9302: POP
9303: POP
// ChangeMissionObjectives ( M3 ) ;
9304: LD_STRING M3
9306: PPUSH
9307: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9311: LD_INT 35
9313: PPUSH
9314: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9318: LD_EXP 14
9322: PPUSH
9323: LD_EXP 45
9327: PPUSH
9328: CALL_OW 296
9332: PUSH
9333: LD_INT 8
9335: LESS
9336: IFFALSE 9311
// ComTurnUnit ( JMM , Burlak ) ;
9338: LD_EXP 14
9342: PPUSH
9343: LD_EXP 45
9347: PPUSH
9348: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9352: LD_EXP 45
9356: PPUSH
9357: LD_EXP 14
9361: PPUSH
9362: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9366: LD_INT 10
9368: PPUSH
9369: CALL_OW 67
// DialogueOn ;
9373: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9377: LD_EXP 14
9381: PPUSH
9382: LD_STRING D11-JMM-1
9384: PPUSH
9385: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9389: LD_EXP 45
9393: PPUSH
9394: LD_STRING D11-Bur-1
9396: PPUSH
9397: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9401: LD_EXP 14
9405: PPUSH
9406: LD_STRING D11-JMM-2
9408: PPUSH
9409: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9413: LD_EXP 45
9417: PPUSH
9418: LD_STRING D11-Bur-2
9420: PPUSH
9421: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9425: LD_EXP 14
9429: PPUSH
9430: LD_STRING D11-JMM-3
9432: PPUSH
9433: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9437: LD_EXP 45
9441: PPUSH
9442: LD_STRING D11-Bur-3
9444: PPUSH
9445: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9449: LD_EXP 14
9453: PPUSH
9454: LD_STRING D11-JMM-4
9456: PPUSH
9457: CALL_OW 88
// if ar_base_spotted then
9461: LD_EXP 8
9465: IFFALSE 9481
// Say ( Burlak , D12-Bur-1 ) else
9467: LD_EXP 45
9471: PPUSH
9472: LD_STRING D12-Bur-1
9474: PPUSH
9475: CALL_OW 88
9479: GO 9520
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9481: LD_INT 7
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9491: LD_INT 127
9493: PPUSH
9494: LD_INT 45
9496: PPUSH
9497: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9501: LD_EXP 45
9505: PPUSH
9506: LD_STRING D12-Bur-1a
9508: PPUSH
9509: CALL_OW 88
// dwait ( 0 0$2 ) ;
9513: LD_INT 70
9515: PPUSH
9516: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9520: LD_EXP 45
9524: PPUSH
9525: LD_STRING D12-Bur-1b
9527: PPUSH
9528: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9532: LD_EXP 14
9536: PPUSH
9537: LD_STRING D12-JMM-1
9539: PPUSH
9540: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9544: LD_EXP 45
9548: PPUSH
9549: LD_STRING D12-Bur-2
9551: PPUSH
9552: CALL_OW 88
// if Roth then
9556: LD_EXP 15
9560: IFFALSE 9576
// Say ( Roth , D12-Roth-2 ) else
9562: LD_EXP 15
9566: PPUSH
9567: LD_STRING D12-Roth-2
9569: PPUSH
9570: CALL_OW 88
9574: GO 9588
// Say ( SciRu , D12-RSci1-2 ) ;
9576: CALL 12046 0 0
9580: PPUSH
9581: LD_STRING D12-RSci1-2
9583: PPUSH
9584: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9588: LD_EXP 14
9592: PPUSH
9593: LD_STRING D12-JMM-2
9595: PPUSH
9596: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9600: LD_EXP 45
9604: PPUSH
9605: LD_STRING D12-Bur-3
9607: PPUSH
9608: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9612: LD_EXP 14
9616: PPUSH
9617: LD_STRING D12-JMM-3
9619: PPUSH
9620: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9624: LD_EXP 45
9628: PPUSH
9629: LD_STRING D12-Bur-4
9631: PPUSH
9632: CALL_OW 88
// case Query ( QBase ) of 1 :
9636: LD_STRING QBase
9638: PPUSH
9639: CALL_OW 97
9643: PUSH
9644: LD_INT 1
9646: DOUBLE
9647: EQUAL
9648: IFTRUE 9652
9650: GO 9770
9652: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9653: LD_EXP 14
9657: PPUSH
9658: LD_STRING D13a-JMM-1
9660: PPUSH
9661: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9665: LD_EXP 45
9669: PPUSH
9670: LD_STRING D13a-Bur-1
9672: PPUSH
9673: CALL_OW 88
// if Roth then
9677: LD_EXP 15
9681: IFFALSE 9697
// Say ( Roth , D13a-Roth-1 ) else
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D13a-Roth-1
9690: PPUSH
9691: CALL_OW 88
9695: GO 9709
// Say ( SciRu , D13a-RSci1-1 ) ;
9697: CALL 12046 0 0
9701: PPUSH
9702: LD_STRING D13a-RSci1-1
9704: PPUSH
9705: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9709: LD_EXP 14
9713: PPUSH
9714: LD_STRING D13a-JMM-2
9716: PPUSH
9717: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9721: LD_STRING QBaseAgain
9723: PPUSH
9724: CALL_OW 97
9728: PUSH
9729: LD_INT 1
9731: DOUBLE
9732: EQUAL
9733: IFTRUE 9737
9735: GO 9748
9737: POP
// selected_option := 2 ; 2 :
9738: LD_ADDR_VAR 0 2
9742: PUSH
9743: LD_INT 2
9745: ST_TO_ADDR
9746: GO 9768
9748: LD_INT 2
9750: DOUBLE
9751: EQUAL
9752: IFTRUE 9756
9754: GO 9767
9756: POP
// selected_option := 3 ; end ;
9757: LD_ADDR_VAR 0 2
9761: PUSH
9762: LD_INT 3
9764: ST_TO_ADDR
9765: GO 9768
9767: POP
// end ; 2 :
9768: GO 9809
9770: LD_INT 2
9772: DOUBLE
9773: EQUAL
9774: IFTRUE 9778
9776: GO 9789
9778: POP
// selected_option := 2 ; 3 :
9779: LD_ADDR_VAR 0 2
9783: PUSH
9784: LD_INT 2
9786: ST_TO_ADDR
9787: GO 9809
9789: LD_INT 3
9791: DOUBLE
9792: EQUAL
9793: IFTRUE 9797
9795: GO 9808
9797: POP
// selected_option := 3 ; end ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 3
9805: ST_TO_ADDR
9806: GO 9809
9808: POP
// if selected_option = 2 then
9809: LD_VAR 0 2
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: IFFALSE 9911
// begin Say ( JMM , D13b-JMM-1 ) ;
9819: LD_EXP 14
9823: PPUSH
9824: LD_STRING D13b-JMM-1
9826: PPUSH
9827: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
9831: LD_EXP 45
9835: PPUSH
9836: LD_STRING D13b-Bur-1
9838: PPUSH
9839: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
9843: LD_EXP 14
9847: PPUSH
9848: LD_STRING D13b-JMM-2
9850: PPUSH
9851: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
9855: LD_EXP 54
9859: PPUSH
9860: LD_STRING D13b-Abd-2
9862: PPUSH
9863: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
9867: LD_EXP 14
9871: PPUSH
9872: LD_STRING D13b-JMM-3
9874: PPUSH
9875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
9879: LD_EXP 54
9883: PPUSH
9884: LD_STRING D13b-Abd-3
9886: PPUSH
9887: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
9891: LD_EXP 14
9895: PPUSH
9896: LD_STRING D13b-JMM-4
9898: PPUSH
9899: CALL_OW 88
// ar_active_attack := true ;
9903: LD_ADDR_EXP 9
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// end ; if selected_option = 3 then
9911: LD_VAR 0 2
9915: PUSH
9916: LD_INT 3
9918: EQUAL
9919: IFFALSE 9945
// begin Say ( JMM , D13c-JMM-1 ) ;
9921: LD_EXP 14
9925: PPUSH
9926: LD_STRING D13c-JMM-1
9928: PPUSH
9929: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
9933: LD_EXP 45
9937: PPUSH
9938: LD_STRING D13c-Bur-1
9940: PPUSH
9941: CALL_OW 88
// end ; DialogueOff ;
9945: CALL_OW 7
// if not ar_active_attack then
9949: LD_EXP 9
9953: NOT
9954: IFFALSE 9971
// begin wait ( 6 6$00 ) ;
9956: LD_INT 12600
9958: PPUSH
9959: CALL_OW 67
// ar_active_attack := true ;
9963: LD_ADDR_EXP 9
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// end ; end ;
9971: PPOPN 2
9973: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do
9974: LD_EXP 45
9978: PPUSH
9979: CALL_OW 305
9983: PUSH
9984: LD_EXP 45
9988: PPUSH
9989: CALL_OW 255
9993: PUSH
9994: LD_INT 7
9996: EQUAL
9997: AND
9998: IFFALSE 10159
10000: GO 10002
10002: DISABLE
// begin wait ( 4 4$40 ) ;
10003: LD_INT 9800
10005: PPUSH
10006: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10010: LD_INT 35
10012: PPUSH
10013: CALL_OW 67
// until not ru_attackers ;
10017: LD_EXP 51
10021: NOT
10022: IFFALSE 10010
// PrepareGnyevko ;
10024: CALL 1990 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10028: LD_EXP 47
10032: PPUSH
10033: LD_INT 124
10035: PPUSH
10036: LD_INT 118
10038: PPUSH
10039: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10043: LD_EXP 47
10047: PPUSH
10048: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10052: LD_INT 35
10054: PPUSH
10055: CALL_OW 67
// until IsAt ( Gnyevko , 124 , 118 ) ;
10059: LD_EXP 47
10063: PPUSH
10064: LD_INT 124
10066: PPUSH
10067: LD_INT 118
10069: PPUSH
10070: CALL_OW 307
10074: IFFALSE 10052
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10076: LD_EXP 47
10080: PPUSH
10081: LD_STRING DBelkov-Gny-1
10083: PPUSH
10084: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10088: LD_EXP 45
10092: PPUSH
10093: LD_STRING DBelkov-Bur-1a
10095: PPUSH
10096: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10100: LD_INT 35
10102: PPUSH
10103: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10107: LD_EXP 47
10111: PPUSH
10112: LD_INT 22
10114: PUSH
10115: LD_INT 7
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PPUSH
10122: CALL_OW 69
10126: PPUSH
10127: LD_EXP 47
10131: PPUSH
10132: CALL_OW 74
10136: PPUSH
10137: CALL_OW 296
10141: PUSH
10142: LD_INT 8
10144: LESS
10145: IFFALSE 10100
// SetSide ( Gnyevko , 7 ) ;
10147: LD_EXP 47
10151: PPUSH
10152: LD_INT 7
10154: PPUSH
10155: CALL_OW 235
// end ;
10159: END
// every 10 10$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10160: LD_EXP 45
10164: PPUSH
10165: CALL_OW 255
10169: PUSH
10170: LD_INT 7
10172: EQUAL
10173: IFFALSE 10183
10175: GO 10177
10177: DISABLE
// begin enable ;
10178: ENABLE
// PrepareAmericanAttack ;
10179: CALL 6285 0 0
// end ;
10183: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10184: LD_INT 22
10186: PUSH
10187: LD_INT 1
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10382
10200: GO 10202
10202: DISABLE
10203: LD_INT 0
10205: PPUSH
10206: PPUSH
// begin while true do
10207: LD_INT 1
10209: IFFALSE 10266
// begin wait ( 0 0$1 ) ;
10211: LD_INT 35
10213: PPUSH
10214: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10218: LD_ADDR_VAR 0 2
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_INT 1
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PPUSH
10233: CALL_OW 69
10237: PPUSH
10238: LD_EXP 14
10242: PPUSH
10243: CALL_OW 74
10247: ST_TO_ADDR
// if See ( 7 , tmp ) then
10248: LD_INT 7
10250: PPUSH
10251: LD_VAR 0 2
10255: PPUSH
10256: CALL_OW 292
10260: IFFALSE 10264
// break ;
10262: GO 10266
// end ;
10264: GO 10207
// DialogueOn ;
10266: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10270: LD_VAR 0 2
10274: PPUSH
10275: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10279: LD_VAR 0 2
10283: PPUSH
10284: CALL_OW 250
10288: PPUSH
10289: LD_VAR 0 2
10293: PPUSH
10294: CALL_OW 251
10298: PPUSH
10299: LD_INT 7
10301: PPUSH
10302: LD_INT 8
10304: PPUSH
10305: CALL_OW 330
// if Denis then
10309: LD_EXP 20
10313: IFFALSE 10327
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10315: LD_EXP 20
10319: PPUSH
10320: LD_STRING DAmerAttack-Pet-1
10322: PPUSH
10323: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10327: LD_EXP 14
10331: PPUSH
10332: LD_STRING DAmerAttack-JMM-1
10334: PPUSH
10335: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10339: LD_EXP 45
10343: PPUSH
10344: LD_STRING DStop-Bur-1
10346: PPUSH
10347: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10351: LD_VAR 0 2
10355: PPUSH
10356: CALL_OW 250
10360: PPUSH
10361: LD_VAR 0 2
10365: PPUSH
10366: CALL_OW 251
10370: PPUSH
10371: LD_INT 7
10373: PPUSH
10374: CALL_OW 331
// DialogueOff ;
10378: CALL_OW 7
// end ;
10382: PPOPN 2
10384: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10385: LD_INT 22
10387: PUSH
10388: LD_INT 3
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 1
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PPUSH
10409: CALL_OW 69
10413: PUSH
10414: LD_INT 0
10416: EQUAL
10417: IFFALSE 10459
10419: GO 10421
10421: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10422: LD_STRING M5a
10424: PPUSH
10425: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10429: LD_EXP 14
10433: PPUSH
10434: LD_STRING D8-JMM-1
10436: PPUSH
10437: CALL_OW 88
// if Gossudarov then
10441: LD_EXP 31
10445: IFFALSE 10459
// Say ( Gossudarov , D8-Gos-1 ) ;
10447: LD_EXP 31
10451: PPUSH
10452: LD_STRING D8-Gos-1
10454: PPUSH
10455: CALL_OW 88
// end ;
10459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10460: LD_INT 22
10462: PUSH
10463: LD_INT 2
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: LD_INT 21
10472: PUSH
10473: LD_INT 1
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 69
10488: PUSH
10489: LD_INT 0
10491: EQUAL
10492: IFFALSE 10542
10494: GO 10496
10496: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10497: LD_STRING M4c
10499: PPUSH
10500: CALL_OW 337
// if Roth then
10504: LD_EXP 15
10508: IFFALSE 10524
// Say ( Roth , DStop-Roth-1 ) else
10510: LD_EXP 15
10514: PPUSH
10515: LD_STRING DStop-Roth-1
10517: PPUSH
10518: CALL_OW 88
10522: GO 10542
// if Gossudarov then
10524: LD_EXP 31
10528: IFFALSE 10542
// Say ( Gossudarov , D8-Gos-1a ) ;
10530: LD_EXP 31
10534: PPUSH
10535: LD_STRING D8-Gos-1a
10537: PPUSH
10538: CALL_OW 88
// end ;
10542: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10543: LD_INT 7
10545: PPUSH
10546: LD_INT 1
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 13578 0 3
10556: PUSH
10557: LD_INT 0
10559: EQUAL
10560: PUSH
10561: LD_INT 7
10563: PPUSH
10564: LD_INT 3
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 13578 0 3
10574: PUSH
10575: LD_INT 0
10577: EQUAL
10578: AND
10579: IFFALSE 10591
10581: GO 10583
10583: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10584: LD_STRING M1a
10586: PPUSH
10587: CALL_OW 337
// end ;
10591: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 3 ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10592: LD_INT 22
10594: PUSH
10595: LD_INT 2
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: LD_INT 21
10604: PUSH
10605: LD_INT 1
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 69
10620: PUSH
10621: LD_INT 0
10623: EQUAL
10624: PUSH
10625: LD_INT 22
10627: PUSH
10628: LD_INT 3
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PPUSH
10635: CALL_OW 69
10639: PUSH
10640: LD_INT 0
10642: EQUAL
10643: AND
10644: PUSH
10645: LD_INT 22
10647: PUSH
10648: LD_INT 1
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 69
10659: PUSH
10660: LD_INT 0
10662: EQUAL
10663: AND
10664: PUSH
10665: LD_INT 7
10667: PPUSH
10668: LD_INT 1
10670: PPUSH
10671: LD_INT 1
10673: PPUSH
10674: CALL 13578 0 3
10678: PUSH
10679: LD_INT 0
10681: EQUAL
10682: AND
10683: PUSH
10684: LD_INT 7
10686: PPUSH
10687: LD_INT 3
10689: PPUSH
10690: LD_INT 1
10692: PPUSH
10693: CALL 13578 0 3
10697: PUSH
10698: LD_INT 0
10700: EQUAL
10701: AND
10702: IFFALSE 12043
10704: GO 10706
10706: DISABLE
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// begin wait ( 0 0$3 ) ;
10712: LD_INT 105
10714: PPUSH
10715: CALL_OW 67
// if not IsDead ( Masha ) then
10719: LD_EXP 48
10723: PPUSH
10724: CALL_OW 301
10728: NOT
10729: IFFALSE 10743
// AddMedal ( Masha , 1 ) else
10731: LD_STRING Masha
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 101
10741: GO 10754
// AddMedal ( Masha , - 1 ) ;
10743: LD_STRING Masha
10745: PPUSH
10746: LD_INT 1
10748: NEG
10749: PPUSH
10750: CALL_OW 101
// if abdul_escaped then
10754: LD_EXP 12
10758: IFFALSE 10773
// AddMedal ( Abdul , - 1 ) else
10760: LD_STRING Abdul
10762: PPUSH
10763: LD_INT 1
10765: NEG
10766: PPUSH
10767: CALL_OW 101
10771: GO 10783
// AddMedal ( Abdul , 1 ) ;
10773: LD_STRING Abdul
10775: PPUSH
10776: LD_INT 1
10778: PPUSH
10779: CALL_OW 101
// if loss_counter = 0 then
10783: LD_EXP 13
10787: PUSH
10788: LD_INT 0
10790: EQUAL
10791: IFFALSE 10805
// AddMedal ( People , 2 ) else
10793: LD_STRING People
10795: PPUSH
10796: LD_INT 2
10798: PPUSH
10799: CALL_OW 101
10803: GO 10855
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
10805: LD_EXP 13
10809: PUSH
10810: LD_INT 3
10812: PUSH
10813: LD_INT 2
10815: PUSH
10816: LD_INT 2
10818: PUSH
10819: EMPTY
10820: LIST
10821: LIST
10822: LIST
10823: PUSH
10824: LD_OWVAR 67
10828: ARRAY
10829: LESSEQUAL
10830: IFFALSE 10844
// AddMedal ( People , 1 ) else
10832: LD_STRING People
10834: PPUSH
10835: LD_INT 1
10837: PPUSH
10838: CALL_OW 101
10842: GO 10855
// AddMedal ( People , - 1 ) ;
10844: LD_STRING People
10846: PPUSH
10847: LD_INT 1
10849: NEG
10850: PPUSH
10851: CALL_OW 101
// GiveMedals ( MAIN ) ;
10855: LD_STRING MAIN
10857: PPUSH
10858: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
10862: LD_ADDR_VAR 0 2
10866: PUSH
10867: LD_INT 22
10869: PUSH
10870: LD_INT 7
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: PUSH
10877: LD_INT 2
10879: PUSH
10880: LD_INT 25
10882: PUSH
10883: LD_INT 1
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PUSH
10890: LD_INT 25
10892: PUSH
10893: LD_INT 2
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PUSH
10900: LD_INT 25
10902: PUSH
10903: LD_INT 3
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PUSH
10910: LD_INT 25
10912: PUSH
10913: LD_INT 4
10915: PUSH
10916: EMPTY
10917: LIST
10918: LIST
10919: PUSH
10920: LD_INT 25
10922: PUSH
10923: LD_INT 5
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: LD_INT 25
10932: PUSH
10933: LD_INT 8
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: PUSH
10940: LD_INT 25
10942: PUSH
10943: LD_INT 9
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: LIST
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PPUSH
10964: CALL_OW 69
10968: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
10978: LD_ADDR_VAR 0 3
10982: PUSH
10983: LD_EXP 14
10987: PUSH
10988: LD_EXP 15
10992: PUSH
10993: LD_EXP 16
10997: PUSH
10998: LD_EXP 17
11002: PUSH
11003: LD_EXP 18
11007: PUSH
11008: LD_EXP 19
11012: PUSH
11013: LD_EXP 20
11017: PUSH
11018: LD_EXP 21
11022: PUSH
11023: LD_EXP 22
11027: PUSH
11028: LD_EXP 23
11032: PUSH
11033: LD_EXP 24
11037: PUSH
11038: LD_EXP 25
11042: PUSH
11043: LD_EXP 26
11047: PUSH
11048: LD_EXP 27
11052: PUSH
11053: LD_EXP 28
11057: PUSH
11058: LD_EXP 29
11062: PUSH
11063: LD_EXP 30
11067: PUSH
11068: LD_EXP 31
11072: PUSH
11073: LD_EXP 32
11077: PUSH
11078: LD_EXP 33
11082: PUSH
11083: LD_EXP 35
11087: PUSH
11088: LD_EXP 36
11092: PUSH
11093: LD_EXP 37
11097: PUSH
11098: LD_EXP 38
11102: PUSH
11103: LD_EXP 39
11107: PUSH
11108: LD_EXP 40
11112: PUSH
11113: LD_EXP 41
11117: PUSH
11118: LD_EXP 42
11122: PUSH
11123: LD_EXP 43
11127: PUSH
11128: LD_EXP 44
11132: PUSH
11133: LD_EXP 45
11137: PUSH
11138: LD_EXP 46
11142: PUSH
11143: LD_EXP 47
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: LIST
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: ST_TO_ADDR
// if tmp diff tmp2 then
11183: LD_VAR 0 2
11187: PUSH
11188: LD_VAR 0 3
11192: DIFF
11193: IFFALSE 11213
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11195: LD_VAR 0 2
11199: PUSH
11200: LD_VAR 0 3
11204: DIFF
11205: PPUSH
11206: LD_STRING 13a_others
11208: PPUSH
11209: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11213: LD_EXP 14
11217: PPUSH
11218: LD_STRING 13a_JMM
11220: PPUSH
11221: CALL_OW 38
// if Titov then
11225: LD_EXP 33
11229: IFFALSE 11243
// SaveCharacters ( Titov , 13a_Titov ) ;
11231: LD_EXP 33
11235: PPUSH
11236: LD_STRING 13a_Titov
11238: PPUSH
11239: CALL_OW 38
// if Dolgov then
11243: LD_EXP 35
11247: IFFALSE 11261
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11249: LD_EXP 35
11253: PPUSH
11254: LD_STRING 13a_Dolgov
11256: PPUSH
11257: CALL_OW 38
// if Petrosyan then
11261: LD_EXP 36
11265: IFFALSE 11279
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11267: LD_EXP 36
11271: PPUSH
11272: LD_STRING 13a_Petrosyan
11274: PPUSH
11275: CALL_OW 38
// if Scholtze then
11279: LD_EXP 37
11283: IFFALSE 11297
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11285: LD_EXP 37
11289: PPUSH
11290: LD_STRING 13a_Scholtze
11292: PPUSH
11293: CALL_OW 38
// if Oblukov then
11297: LD_EXP 38
11301: IFFALSE 11315
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11303: LD_EXP 38
11307: PPUSH
11308: LD_STRING 13a_Oblukov
11310: PPUSH
11311: CALL_OW 38
// if Kapitsova then
11315: LD_EXP 39
11319: IFFALSE 11333
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11321: LD_EXP 39
11325: PPUSH
11326: LD_STRING 13a_Kapitsova
11328: PPUSH
11329: CALL_OW 38
// if Lipshchin then
11333: LD_EXP 40
11337: IFFALSE 11351
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11339: LD_EXP 40
11343: PPUSH
11344: LD_STRING 13a_Lipshchin
11346: PPUSH
11347: CALL_OW 38
// if Petrovova then
11351: LD_EXP 41
11355: IFFALSE 11369
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11357: LD_EXP 41
11361: PPUSH
11362: LD_STRING 13a_Petrovova
11364: PPUSH
11365: CALL_OW 38
// if Kovalyuk then
11369: LD_EXP 42
11373: IFFALSE 11387
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11375: LD_EXP 42
11379: PPUSH
11380: LD_STRING 13a_Kovalyuk
11382: PPUSH
11383: CALL_OW 38
// if Kuzmov then
11387: LD_EXP 43
11391: IFFALSE 11405
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11393: LD_EXP 43
11397: PPUSH
11398: LD_STRING 13a_Kuzmov
11400: PPUSH
11401: CALL_OW 38
// if Karamazov then
11405: LD_EXP 44
11409: IFFALSE 11423
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11411: LD_EXP 44
11415: PPUSH
11416: LD_STRING 13a_Karamazov
11418: PPUSH
11419: CALL_OW 38
// if Burlak then
11423: LD_EXP 45
11427: IFFALSE 11441
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11429: LD_EXP 45
11433: PPUSH
11434: LD_STRING 13a_Burlak
11436: PPUSH
11437: CALL_OW 38
// if Belkov then
11441: LD_EXP 46
11445: IFFALSE 11459
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11447: LD_EXP 46
11451: PPUSH
11452: LD_STRING 13a_Belkov
11454: PPUSH
11455: CALL_OW 38
// if Gnyevko then
11459: LD_EXP 47
11463: IFFALSE 11477
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11465: LD_EXP 47
11469: PPUSH
11470: LD_STRING 13a_Gnyevko
11472: PPUSH
11473: CALL_OW 38
// if Lisa then
11477: LD_EXP 16
11481: IFFALSE 11495
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11483: LD_EXP 16
11487: PPUSH
11488: LD_STRING 13a_Lisa
11490: PPUSH
11491: CALL_OW 38
// if Donaldson then
11495: LD_EXP 17
11499: IFFALSE 11513
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11501: LD_EXP 17
11505: PPUSH
11506: LD_STRING 13a_Donaldson
11508: PPUSH
11509: CALL_OW 38
// if Bobby then
11513: LD_EXP 18
11517: IFFALSE 11531
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11519: LD_EXP 18
11523: PPUSH
11524: LD_STRING 13a_Bobby
11526: PPUSH
11527: CALL_OW 38
// if Cyrus then
11531: LD_EXP 19
11535: IFFALSE 11549
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11537: LD_EXP 19
11541: PPUSH
11542: LD_STRING 13a_Cyrus
11544: PPUSH
11545: CALL_OW 38
// if Denis then
11549: LD_EXP 20
11553: IFFALSE 11567
// SaveCharacters ( Denis , 13a_Denis ) ;
11555: LD_EXP 20
11559: PPUSH
11560: LD_STRING 13a_Denis
11562: PPUSH
11563: CALL_OW 38
// if Brown then
11567: LD_EXP 21
11571: IFFALSE 11585
// SaveCharacters ( Brown , 13a_Brown ) ;
11573: LD_EXP 21
11577: PPUSH
11578: LD_STRING 13a_Brown
11580: PPUSH
11581: CALL_OW 38
// if Gladstone then
11585: LD_EXP 22
11589: IFFALSE 11603
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11591: LD_EXP 22
11595: PPUSH
11596: LD_STRING 13a_Gladstone
11598: PPUSH
11599: CALL_OW 38
// if Houten then
11603: LD_EXP 23
11607: IFFALSE 11621
// SaveCharacters ( Houten , 13a_Houten ) ;
11609: LD_EXP 23
11613: PPUSH
11614: LD_STRING 13a_Houten
11616: PPUSH
11617: CALL_OW 38
// if Cornel then
11621: LD_EXP 24
11625: IFFALSE 11639
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11627: LD_EXP 24
11631: PPUSH
11632: LD_STRING 13a_Cornel
11634: PPUSH
11635: CALL_OW 38
// if Gary then
11639: LD_EXP 25
11643: IFFALSE 11657
// SaveCharacters ( Gary , 13a_Gary ) ;
11645: LD_EXP 25
11649: PPUSH
11650: LD_STRING 13a_Gary
11652: PPUSH
11653: CALL_OW 38
// if Frank then
11657: LD_EXP 26
11661: IFFALSE 11675
// SaveCharacters ( Frank , 13a_Frank ) ;
11663: LD_EXP 26
11667: PPUSH
11668: LD_STRING 13a_Frank
11670: PPUSH
11671: CALL_OW 38
// if Kikuchi then
11675: LD_EXP 27
11679: IFFALSE 11693
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11681: LD_EXP 27
11685: PPUSH
11686: LD_STRING 13a_Kikuchi
11688: PPUSH
11689: CALL_OW 38
// if Simms then
11693: LD_EXP 28
11697: IFFALSE 11711
// SaveCharacters ( Simms , 13a_Simms ) ;
11699: LD_EXP 28
11703: PPUSH
11704: LD_STRING 13a_Simms
11706: PPUSH
11707: CALL_OW 38
// if Joan then
11711: LD_EXP 29
11715: IFFALSE 11729
// SaveCharacters ( Joan , 13a_Joan ) ;
11717: LD_EXP 29
11721: PPUSH
11722: LD_STRING 13a_Joan
11724: PPUSH
11725: CALL_OW 38
// if DeltaDoctor then
11729: LD_EXP 30
11733: IFFALSE 11747
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
11735: LD_EXP 30
11739: PPUSH
11740: LD_STRING 13a_DeltaDoctor
11742: PPUSH
11743: CALL_OW 38
// if Gossudarov then
11747: LD_EXP 31
11751: IFFALSE 11765
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
11753: LD_EXP 31
11757: PPUSH
11758: LD_STRING 13a_Gossudarov
11760: PPUSH
11761: CALL_OW 38
// if Kirilenkova then
11765: LD_EXP 32
11769: IFFALSE 11783
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
11771: LD_EXP 32
11775: PPUSH
11776: LD_STRING 13a_Kirilenkova
11778: PPUSH
11779: CALL_OW 38
// if Masha then
11783: LD_EXP 48
11787: IFFALSE 11842
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
11789: LD_EXP 48
11793: PPUSH
11794: CALL_OW 265
11798: PUSH
11799: LD_EXP 48
11803: PPUSH
11804: CALL_OW 262
11808: PUSH
11809: LD_EXP 48
11813: PPUSH
11814: CALL_OW 263
11818: PUSH
11819: LD_EXP 48
11823: PPUSH
11824: CALL_OW 264
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: PPUSH
11835: LD_STRING 13a_Masha
11837: PPUSH
11838: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
11842: LD_ADDR_VAR 0 2
11846: PUSH
11847: LD_INT 21
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: ST_TO_ADDR
// tmp2 := [ ] ;
11862: LD_ADDR_VAR 0 3
11866: PUSH
11867: EMPTY
11868: ST_TO_ADDR
// if tmp then
11869: LD_VAR 0 2
11873: IFFALSE 12021
// for i in tmp do
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_VAR 0 2
11884: PUSH
11885: FOR_IN
11886: IFFALSE 12019
// tmp2 := tmp2 ^ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: LD_VAR 0 1
11902: PPUSH
11903: CALL_OW 255
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL_OW 248
11917: PUSH
11918: LD_VAR 0 1
11922: PPUSH
11923: CALL_OW 266
11927: PUSH
11928: LD_VAR 0 1
11932: PPUSH
11933: CALL_OW 250
11937: PUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 251
11947: PUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 254
11957: PUSH
11958: LD_VAR 0 1
11962: PPUSH
11963: CALL_OW 267
11967: PUSH
11968: LD_VAR 0 1
11972: PPUSH
11973: LD_INT 1
11975: PPUSH
11976: CALL_OW 268
11980: PUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: LD_INT 2
11988: PPUSH
11989: CALL_OW 268
11993: PUSH
11994: LD_VAR 0 1
11998: PPUSH
11999: CALL_OW 269
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: ADD
12016: ST_TO_ADDR
12017: GO 11885
12019: POP
12020: POP
// if tmp2 then
12021: LD_VAR 0 3
12025: IFFALSE 12039
// SaveVariable ( tmp2 , 13a_buildings ) ;
12027: LD_VAR 0 3
12031: PPUSH
12032: LD_STRING 13a_buildings
12034: PPUSH
12035: CALL_OW 39
// YouWin ;
12039: CALL_OW 103
// end ;
12043: PPOPN 3
12045: END
// export function SciRu ; var tmp , t ; begin
12046: LD_INT 0
12048: PPUSH
12049: PPUSH
12050: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12051: LD_ADDR_VAR 0 3
12055: PUSH
12056: LD_EXP 31
12060: PUSH
12061: LD_EXP 45
12065: PUSH
12066: LD_EXP 33
12070: PUSH
12071: LD_EXP 46
12075: PUSH
12076: LD_EXP 47
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12088: LD_ADDR_VAR 0 2
12092: PUSH
12093: LD_INT 22
12095: PUSH
12096: LD_INT 7
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 23
12105: PUSH
12106: LD_INT 3
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 4
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 26
12125: PUSH
12126: LD_INT 1
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: PPUSH
12139: CALL_OW 69
12143: PUSH
12144: LD_VAR 0 3
12148: DIFF
12149: ST_TO_ADDR
// if tmp then
12150: LD_VAR 0 2
12154: IFFALSE 12170
// result := tmp [ 1 ] ;
12156: LD_ADDR_VAR 0 1
12160: PUSH
12161: LD_VAR 0 2
12165: PUSH
12166: LD_INT 1
12168: ARRAY
12169: ST_TO_ADDR
// end ;
12170: LD_VAR 0 1
12174: RET
// export function SolRu ; var tmp , t ; begin
12175: LD_INT 0
12177: PPUSH
12178: PPUSH
12179: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12180: LD_ADDR_VAR 0 3
12184: PUSH
12185: LD_EXP 46
12189: PUSH
12190: LD_EXP 45
12194: PUSH
12195: LD_EXP 31
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: LIST
12204: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12205: LD_ADDR_VAR 0 2
12209: PUSH
12210: LD_INT 22
12212: PUSH
12213: LD_INT 7
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 23
12222: PUSH
12223: LD_INT 3
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: LD_INT 25
12232: PUSH
12233: LD_INT 1
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: PUSH
12240: LD_INT 26
12242: PUSH
12243: LD_INT 1
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PUSH
12250: EMPTY
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: PPUSH
12256: CALL_OW 69
12260: PUSH
12261: LD_VAR 0 3
12265: DIFF
12266: ST_TO_ADDR
// if tmp then
12267: LD_VAR 0 2
12271: IFFALSE 12287
// result := tmp [ 1 ] ;
12273: LD_ADDR_VAR 0 1
12277: PUSH
12278: LD_VAR 0 2
12282: PUSH
12283: LD_INT 1
12285: ARRAY
12286: ST_TO_ADDR
// end ; end_of_file
12287: LD_VAR 0 1
12291: RET
// export function CustomEvent ( event ) ; begin
12292: LD_INT 0
12294: PPUSH
// end ;
12295: LD_VAR 0 2
12299: RET
// on UnitDestroyed ( un ) do var i , side ;
12300: LD_INT 0
12302: PPUSH
12303: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12304: LD_VAR 0 1
12308: PUSH
12309: LD_INT 22
12311: PUSH
12312: LD_INT 7
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 2
12321: PUSH
12322: LD_INT 25
12324: PUSH
12325: LD_INT 1
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: LD_INT 25
12334: PUSH
12335: LD_INT 2
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PUSH
12342: LD_INT 25
12344: PUSH
12345: LD_INT 3
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: PUSH
12352: LD_INT 25
12354: PUSH
12355: LD_INT 4
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PUSH
12362: LD_INT 25
12364: PUSH
12365: LD_INT 5
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: LD_INT 25
12374: PUSH
12375: LD_INT 8
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 25
12384: PUSH
12385: LD_INT 9
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PPUSH
12406: CALL_OW 69
12410: IN
12411: IFFALSE 12427
// loss_counter := loss_counter + 1 ;
12413: LD_ADDR_EXP 13
12417: PUSH
12418: LD_EXP 13
12422: PUSH
12423: LD_INT 1
12425: PLUS
12426: ST_TO_ADDR
// if un = Abdul then
12427: LD_VAR 0 1
12431: PUSH
12432: LD_EXP 54
12436: EQUAL
12437: IFFALSE 12447
// abdul_escaped := false ;
12439: LD_ADDR_EXP 12
12443: PUSH
12444: LD_INT 0
12446: ST_TO_ADDR
// if un in ru_attackers then
12447: LD_VAR 0 1
12451: PUSH
12452: LD_EXP 51
12456: IN
12457: IFFALSE 12475
// ru_attackers := ru_attackers diff un ;
12459: LD_ADDR_EXP 51
12463: PUSH
12464: LD_EXP 51
12468: PUSH
12469: LD_VAR 0 1
12473: DIFF
12474: ST_TO_ADDR
// if un in ar_attackers then
12475: LD_VAR 0 1
12479: PUSH
12480: LD_EXP 10
12484: IN
12485: IFFALSE 12503
// ar_attackers := ar_attackers diff un ;
12487: LD_ADDR_EXP 10
12491: PUSH
12492: LD_EXP 10
12496: PUSH
12497: LD_VAR 0 1
12501: DIFF
12502: ST_TO_ADDR
// if un = JMM then
12503: LD_VAR 0 1
12507: PUSH
12508: LD_EXP 14
12512: EQUAL
12513: IFFALSE 12524
// begin YouLost ( JMM ) ;
12515: LD_STRING JMM
12517: PPUSH
12518: CALL_OW 104
// exit ;
12522: GO 12613
// end ; if un = Burlak then
12524: LD_VAR 0 1
12528: PUSH
12529: LD_EXP 45
12533: EQUAL
12534: IFFALSE 12545
// begin YouLost ( Burlak ) ;
12536: LD_STRING Burlak
12538: PPUSH
12539: CALL_OW 104
// exit ;
12543: GO 12613
// end ; if un = freedom then
12545: LD_VAR 0 1
12549: PUSH
12550: LD_EXP 3
12554: EQUAL
12555: IFFALSE 12566
// begin YouLost ( Destroyed ) ;
12557: LD_STRING Destroyed
12559: PPUSH
12560: CALL_OW 104
// exit ;
12564: GO 12613
// end ; if un = Masha then
12566: LD_VAR 0 1
12570: PUSH
12571: LD_EXP 48
12575: EQUAL
12576: IFFALSE 12585
// ChangeMissionObjectives ( M4b ) ;
12578: LD_STRING M4b
12580: PPUSH
12581: CALL_OW 337
// if un = Mastodont then
12585: LD_VAR 0 1
12589: PUSH
12590: LD_EXP 55
12594: EQUAL
12595: IFFALSE 12604
// ChangeMissionObjectives ( M4a ) ;
12597: LD_STRING M4a
12599: PPUSH
12600: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: CALL 81410 0 1
// end ;
12613: PPOPN 3
12615: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12616: LD_VAR 0 1
12620: PPUSH
12621: LD_VAR 0 2
12625: PPUSH
12626: CALL 83316 0 2
// end ;
12630: PPOPN 2
12632: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL 82384 0 1
// end ;
12642: PPOPN 1
12644: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12645: LD_VAR 0 1
12649: PUSH
12650: LD_INT 22
12652: PUSH
12653: LD_INT 7
12655: PUSH
12656: EMPTY
12657: LIST
12658: LIST
12659: PUSH
12660: LD_INT 30
12662: PUSH
12663: LD_INT 0
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: PPUSH
12674: CALL_OW 69
12678: IN
12679: IFFALSE 12718
// begin SetBName ( building , freedom ) ;
12681: LD_VAR 0 1
12685: PPUSH
12686: LD_STRING freedom
12688: PPUSH
12689: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12693: LD_INT 0
12695: PPUSH
12696: LD_INT 7
12698: PPUSH
12699: LD_INT 0
12701: PPUSH
12702: CALL_OW 324
// freedom := building ;
12706: LD_ADDR_EXP 3
12710: PUSH
12711: LD_VAR 0 1
12715: ST_TO_ADDR
// exit ;
12716: GO 12784
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
12718: LD_VAR 0 1
12722: PUSH
12723: LD_INT 22
12725: PUSH
12726: LD_INT 7
12728: PUSH
12729: EMPTY
12730: LIST
12731: LIST
12732: PUSH
12733: LD_INT 23
12735: PUSH
12736: LD_INT 3
12738: PUSH
12739: EMPTY
12740: LIST
12741: LIST
12742: PUSH
12743: LD_INT 30
12745: PUSH
12746: LD_INT 6
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: LIST
12757: PPUSH
12758: CALL_OW 69
12762: IN
12763: IFFALSE 12775
// begin ru_lab_builded := true ;
12765: LD_ADDR_EXP 5
12769: PUSH
12770: LD_INT 1
12772: ST_TO_ADDR
// exit ;
12773: GO 12784
// end ; MCE_BuildingComplete ( building ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: CALL 82625 0 1
// end ;
12784: PPOPN 1
12786: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12787: LD_VAR 0 1
12791: PPUSH
12792: LD_VAR 0 2
12796: PPUSH
12797: CALL 81106 0 2
// end ;
12801: PPOPN 2
12803: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: LD_VAR 0 4
12823: PPUSH
12824: LD_VAR 0 5
12828: PPUSH
12829: CALL 80726 0 5
// end ;
12833: PPOPN 5
12835: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12836: LD_VAR 0 1
12840: PPUSH
12841: LD_VAR 0 2
12845: PPUSH
12846: CALL 80316 0 2
// end ;
12850: PPOPN 2
12852: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12853: LD_VAR 0 1
12857: PPUSH
12858: LD_VAR 0 2
12862: PPUSH
12863: LD_VAR 0 3
12867: PPUSH
12868: LD_VAR 0 4
12872: PPUSH
12873: CALL 80154 0 4
// end ;
12877: PPOPN 4
12879: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12880: LD_VAR 0 1
12884: PPUSH
12885: LD_VAR 0 2
12889: PPUSH
12890: LD_VAR 0 3
12894: PPUSH
12895: CALL 79929 0 3
// end ;
12899: PPOPN 3
12901: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12902: LD_VAR 0 1
12906: PPUSH
12907: LD_VAR 0 2
12911: PPUSH
12912: CALL 79814 0 2
// end ;
12916: PPOPN 2
12918: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12919: LD_VAR 0 1
12923: PPUSH
12924: LD_VAR 0 2
12928: PPUSH
12929: CALL 83577 0 2
// end ;
12933: PPOPN 2
12935: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12936: LD_VAR 0 1
12940: PPUSH
12941: LD_VAR 0 2
12945: PPUSH
12946: LD_VAR 0 3
12950: PPUSH
12951: LD_VAR 0 4
12955: PPUSH
12956: CALL 83793 0 4
// end ;
12960: PPOPN 4
12962: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12963: LD_VAR 0 1
12967: PPUSH
12968: LD_VAR 0 2
12972: PPUSH
12973: CALL 79623 0 2
// end ; end_of_file
12977: PPOPN 2
12979: END
// every 0 0$30 do var cr , time ;
12980: GO 12982
12982: DISABLE
12983: LD_INT 0
12985: PPUSH
12986: PPUSH
// begin time := 0 0$10 ;
12987: LD_ADDR_VAR 0 2
12991: PUSH
12992: LD_INT 350
12994: ST_TO_ADDR
// while game do
12995: LD_EXP 2
12999: IFFALSE 13098
// begin wait ( time ) ;
13001: LD_VAR 0 2
13005: PPUSH
13006: CALL_OW 67
// if tick > 2 2$00 then
13010: LD_OWVAR 1
13014: PUSH
13015: LD_INT 4200
13017: GREATER
13018: IFFALSE 13051
// time := time + [ 0 0$06 , 0 0$07 , 0 0$08 ] [ Difficulty ] ;
13020: LD_ADDR_VAR 0 2
13024: PUSH
13025: LD_VAR 0 2
13029: PUSH
13030: LD_INT 210
13032: PUSH
13033: LD_INT 245
13035: PUSH
13036: LD_INT 280
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: PUSH
13044: LD_OWVAR 67
13048: ARRAY
13049: PLUS
13050: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13051: LD_INT 1
13053: PPUSH
13054: LD_INT 5
13056: PPUSH
13057: CALL_OW 12
13061: PPUSH
13062: LD_INT 70
13064: PPUSH
13065: LD_INT 49
13067: PPUSH
13068: LD_INT 25
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 56
// if time > 5 5$00 then
13078: LD_VAR 0 2
13082: PUSH
13083: LD_INT 10500
13085: GREATER
13086: IFFALSE 13096
// time := 0 0$30 ;
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: LD_INT 1050
13095: ST_TO_ADDR
// end ;
13096: GO 12995
// end ;
13098: PPOPN 2
13100: END
// every 0 0$30 do var cr , time ;
13101: GO 13103
13103: DISABLE
13104: LD_INT 0
13106: PPUSH
13107: PPUSH
// begin time := 0 0$01 ;
13108: LD_ADDR_VAR 0 2
13112: PUSH
13113: LD_INT 35
13115: ST_TO_ADDR
// while game do
13116: LD_EXP 2
13120: IFFALSE 13209
// begin wait ( time ) ;
13122: LD_VAR 0 2
13126: PPUSH
13127: CALL_OW 67
// time := time + [ 0 0$04 , 0 0$05 , 0 0$06 ] [ Difficulty ] ;
13131: LD_ADDR_VAR 0 2
13135: PUSH
13136: LD_VAR 0 2
13140: PUSH
13141: LD_INT 140
13143: PUSH
13144: LD_INT 175
13146: PUSH
13147: LD_INT 210
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: LIST
13154: PUSH
13155: LD_OWVAR 67
13159: ARRAY
13160: PLUS
13161: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13162: LD_INT 3
13164: PPUSH
13165: LD_INT 5
13167: PPUSH
13168: CALL_OW 12
13172: PPUSH
13173: LD_INT 26
13175: PPUSH
13176: LD_INT 9
13178: PPUSH
13179: LD_INT 30
13181: PPUSH
13182: LD_INT 1
13184: PPUSH
13185: CALL_OW 56
// if time > 3 3$00 then
13189: LD_VAR 0 2
13193: PUSH
13194: LD_INT 6300
13196: GREATER
13197: IFFALSE 13207
// time := 0 0$20 ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 700
13206: ST_TO_ADDR
// end ;
13207: GO 13116
// end ;
13209: PPOPN 2
13211: END
// every 0 0$30 do var cr , time ;
13212: GO 13214
13214: DISABLE
13215: LD_INT 0
13217: PPUSH
13218: PPUSH
// begin time := 0 0$20 ;
13219: LD_ADDR_VAR 0 2
13223: PUSH
13224: LD_INT 700
13226: ST_TO_ADDR
// while game do
13227: LD_EXP 2
13231: IFFALSE 13356
// begin wait ( time ) ;
13233: LD_VAR 0 2
13237: PPUSH
13238: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13242: LD_ADDR_VAR 0 2
13246: PUSH
13247: LD_VAR 0 2
13251: PUSH
13252: LD_INT 175
13254: PUSH
13255: LD_INT 210
13257: PUSH
13258: LD_INT 280
13260: PUSH
13261: EMPTY
13262: LIST
13263: LIST
13264: LIST
13265: PUSH
13266: LD_OWVAR 67
13270: ARRAY
13271: PLUS
13272: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13273: LD_INT 1
13275: PPUSH
13276: LD_INT 5
13278: PPUSH
13279: CALL_OW 12
13283: PPUSH
13284: LD_INT 179
13286: PPUSH
13287: LD_INT 101
13289: PPUSH
13290: LD_INT 20
13292: PPUSH
13293: LD_INT 1
13295: PPUSH
13296: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13300: LD_INT 350
13302: PPUSH
13303: LD_INT 525
13305: PPUSH
13306: CALL_OW 12
13310: PPUSH
13311: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13315: LD_INT 1
13317: PPUSH
13318: LD_INT 5
13320: PPUSH
13321: CALL_OW 12
13325: PPUSH
13326: LD_INT 9
13328: PPUSH
13329: LD_INT 1
13331: PPUSH
13332: CALL_OW 55
// if time > 4 4$00 then
13336: LD_VAR 0 2
13340: PUSH
13341: LD_INT 8400
13343: GREATER
13344: IFFALSE 13354
// time := 0 0$30 ;
13346: LD_ADDR_VAR 0 2
13350: PUSH
13351: LD_INT 1050
13353: ST_TO_ADDR
// end ;
13354: GO 13227
// end ;
13356: PPOPN 2
13358: END
// every 0 0$30 do var cr , time ;
13359: GO 13361
13361: DISABLE
13362: LD_INT 0
13364: PPUSH
13365: PPUSH
// begin time := 0 0$10 ;
13366: LD_ADDR_VAR 0 2
13370: PUSH
13371: LD_INT 350
13373: ST_TO_ADDR
// while game do
13374: LD_EXP 2
13378: IFFALSE 13512
// begin wait ( time ) ;
13380: LD_VAR 0 2
13384: PPUSH
13385: CALL_OW 67
// time := time + 0 0$10 ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: LD_VAR 0 2
13398: PUSH
13399: LD_INT 350
13401: PLUS
13402: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13403: LD_INT 1
13405: PPUSH
13406: LD_INT 5
13408: PPUSH
13409: CALL_OW 12
13413: PPUSH
13414: LD_INT 11
13416: PPUSH
13417: LD_INT 1
13419: PPUSH
13420: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_INT 1
13431: PPUSH
13432: LD_INT 3
13434: PPUSH
13435: CALL_OW 12
13439: ST_TO_ADDR
// if cr = 1 then
13440: LD_VAR 0 1
13444: PUSH
13445: LD_INT 1
13447: EQUAL
13448: IFFALSE 13492
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13450: LD_INT 700
13452: PPUSH
13453: LD_INT 1575
13455: PPUSH
13456: CALL_OW 12
13460: PPUSH
13461: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13465: LD_INT 1
13467: PPUSH
13468: LD_INT 5
13470: PPUSH
13471: CALL_OW 12
13475: PPUSH
13476: LD_INT 34
13478: PPUSH
13479: LD_INT 50
13481: PPUSH
13482: LD_INT 7
13484: PPUSH
13485: LD_INT 1
13487: PPUSH
13488: CALL_OW 56
// end ; if time > 8 8$00 then
13492: LD_VAR 0 2
13496: PUSH
13497: LD_INT 16800
13499: GREATER
13500: IFFALSE 13510
// time := 0 0$40 ;
13502: LD_ADDR_VAR 0 2
13506: PUSH
13507: LD_INT 1400
13509: ST_TO_ADDR
// end ;
13510: GO 13374
// end ; end_of_file
13512: PPOPN 2
13514: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13515: LD_INT 0
13517: PPUSH
13518: PPUSH
// if exist_mode then
13519: LD_VAR 0 2
13523: IFFALSE 13548
// unit := CreateCharacter ( prefix & ident ) else
13525: LD_ADDR_VAR 0 5
13529: PUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 1
13539: STR
13540: PPUSH
13541: CALL_OW 34
13545: ST_TO_ADDR
13546: GO 13563
// unit := NewCharacter ( ident ) ;
13548: LD_ADDR_VAR 0 5
13552: PUSH
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 25
13562: ST_TO_ADDR
// result := unit ;
13563: LD_ADDR_VAR 0 4
13567: PUSH
13568: LD_VAR 0 5
13572: ST_TO_ADDR
// end ;
13573: LD_VAR 0 4
13577: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13578: LD_INT 0
13580: PPUSH
13581: PPUSH
// if not side or not nation then
13582: LD_VAR 0 1
13586: NOT
13587: PUSH
13588: LD_VAR 0 2
13592: NOT
13593: OR
13594: IFFALSE 13598
// exit ;
13596: GO 14234
// case nation of nation_american :
13598: LD_VAR 0 2
13602: PUSH
13603: LD_INT 1
13605: DOUBLE
13606: EQUAL
13607: IFTRUE 13611
13609: GO 13781
13611: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13612: LD_ADDR_VAR 0 4
13616: PUSH
13617: LD_INT 35
13619: PUSH
13620: LD_INT 45
13622: PUSH
13623: LD_INT 46
13625: PUSH
13626: LD_INT 47
13628: PUSH
13629: LD_INT 1
13631: PUSH
13632: LD_INT 2
13634: PUSH
13635: LD_INT 6
13637: PUSH
13638: LD_INT 15
13640: PUSH
13641: LD_INT 16
13643: PUSH
13644: LD_INT 7
13646: PUSH
13647: LD_INT 12
13649: PUSH
13650: LD_INT 13
13652: PUSH
13653: LD_INT 10
13655: PUSH
13656: LD_INT 14
13658: PUSH
13659: LD_INT 20
13661: PUSH
13662: LD_INT 21
13664: PUSH
13665: LD_INT 22
13667: PUSH
13668: LD_INT 25
13670: PUSH
13671: LD_INT 32
13673: PUSH
13674: LD_INT 27
13676: PUSH
13677: LD_INT 36
13679: PUSH
13680: LD_INT 69
13682: PUSH
13683: LD_INT 39
13685: PUSH
13686: LD_INT 34
13688: PUSH
13689: LD_INT 40
13691: PUSH
13692: LD_INT 48
13694: PUSH
13695: LD_INT 49
13697: PUSH
13698: LD_INT 50
13700: PUSH
13701: LD_INT 51
13703: PUSH
13704: LD_INT 52
13706: PUSH
13707: LD_INT 53
13709: PUSH
13710: LD_INT 54
13712: PUSH
13713: LD_INT 55
13715: PUSH
13716: LD_INT 56
13718: PUSH
13719: LD_INT 57
13721: PUSH
13722: LD_INT 58
13724: PUSH
13725: LD_INT 59
13727: PUSH
13728: LD_INT 60
13730: PUSH
13731: LD_INT 61
13733: PUSH
13734: LD_INT 62
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: ST_TO_ADDR
13779: GO 14158
13781: LD_INT 2
13783: DOUBLE
13784: EQUAL
13785: IFTRUE 13789
13787: GO 13967
13789: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
13790: LD_ADDR_VAR 0 4
13794: PUSH
13795: LD_INT 35
13797: PUSH
13798: LD_INT 45
13800: PUSH
13801: LD_INT 46
13803: PUSH
13804: LD_INT 47
13806: PUSH
13807: LD_INT 70
13809: PUSH
13810: LD_INT 1
13812: PUSH
13813: LD_INT 11
13815: PUSH
13816: LD_INT 3
13818: PUSH
13819: LD_INT 4
13821: PUSH
13822: LD_INT 5
13824: PUSH
13825: LD_INT 6
13827: PUSH
13828: LD_INT 15
13830: PUSH
13831: LD_INT 18
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: LD_INT 17
13839: PUSH
13840: LD_INT 8
13842: PUSH
13843: LD_INT 20
13845: PUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 22
13851: PUSH
13852: LD_INT 72
13854: PUSH
13855: LD_INT 26
13857: PUSH
13858: LD_INT 69
13860: PUSH
13861: LD_INT 39
13863: PUSH
13864: LD_INT 40
13866: PUSH
13867: LD_INT 41
13869: PUSH
13870: LD_INT 42
13872: PUSH
13873: LD_INT 43
13875: PUSH
13876: LD_INT 48
13878: PUSH
13879: LD_INT 49
13881: PUSH
13882: LD_INT 50
13884: PUSH
13885: LD_INT 51
13887: PUSH
13888: LD_INT 52
13890: PUSH
13891: LD_INT 53
13893: PUSH
13894: LD_INT 54
13896: PUSH
13897: LD_INT 55
13899: PUSH
13900: LD_INT 56
13902: PUSH
13903: LD_INT 60
13905: PUSH
13906: LD_INT 61
13908: PUSH
13909: LD_INT 62
13911: PUSH
13912: LD_INT 66
13914: PUSH
13915: LD_INT 67
13917: PUSH
13918: LD_INT 68
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: ST_TO_ADDR
13965: GO 14158
13967: LD_INT 3
13969: DOUBLE
13970: EQUAL
13971: IFTRUE 13975
13973: GO 14157
13975: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
13976: LD_ADDR_VAR 0 4
13980: PUSH
13981: LD_INT 46
13983: PUSH
13984: LD_INT 47
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: LD_INT 2
13992: PUSH
13993: LD_INT 11
13995: PUSH
13996: LD_INT 9
13998: PUSH
13999: LD_INT 20
14001: PUSH
14002: LD_INT 19
14004: PUSH
14005: LD_INT 21
14007: PUSH
14008: LD_INT 24
14010: PUSH
14011: LD_INT 22
14013: PUSH
14014: LD_INT 25
14016: PUSH
14017: LD_INT 28
14019: PUSH
14020: LD_INT 29
14022: PUSH
14023: LD_INT 30
14025: PUSH
14026: LD_INT 31
14028: PUSH
14029: LD_INT 37
14031: PUSH
14032: LD_INT 38
14034: PUSH
14035: LD_INT 32
14037: PUSH
14038: LD_INT 27
14040: PUSH
14041: LD_INT 33
14043: PUSH
14044: LD_INT 69
14046: PUSH
14047: LD_INT 39
14049: PUSH
14050: LD_INT 34
14052: PUSH
14053: LD_INT 40
14055: PUSH
14056: LD_INT 71
14058: PUSH
14059: LD_INT 23
14061: PUSH
14062: LD_INT 44
14064: PUSH
14065: LD_INT 48
14067: PUSH
14068: LD_INT 49
14070: PUSH
14071: LD_INT 50
14073: PUSH
14074: LD_INT 51
14076: PUSH
14077: LD_INT 52
14079: PUSH
14080: LD_INT 53
14082: PUSH
14083: LD_INT 54
14085: PUSH
14086: LD_INT 55
14088: PUSH
14089: LD_INT 56
14091: PUSH
14092: LD_INT 57
14094: PUSH
14095: LD_INT 58
14097: PUSH
14098: LD_INT 59
14100: PUSH
14101: LD_INT 63
14103: PUSH
14104: LD_INT 64
14106: PUSH
14107: LD_INT 65
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: ST_TO_ADDR
14155: GO 14158
14157: POP
// if state > - 1 and state < 3 then
14158: LD_VAR 0 3
14162: PUSH
14163: LD_INT 1
14165: NEG
14166: GREATER
14167: PUSH
14168: LD_VAR 0 3
14172: PUSH
14173: LD_INT 3
14175: LESS
14176: AND
14177: IFFALSE 14234
// for i in result do
14179: LD_ADDR_VAR 0 5
14183: PUSH
14184: LD_VAR 0 4
14188: PUSH
14189: FOR_IN
14190: IFFALSE 14232
// if GetTech ( i , side ) <> state then
14192: LD_VAR 0 5
14196: PPUSH
14197: LD_VAR 0 1
14201: PPUSH
14202: CALL_OW 321
14206: PUSH
14207: LD_VAR 0 3
14211: NONEQUAL
14212: IFFALSE 14230
// result := result diff i ;
14214: LD_ADDR_VAR 0 4
14218: PUSH
14219: LD_VAR 0 4
14223: PUSH
14224: LD_VAR 0 5
14228: DIFF
14229: ST_TO_ADDR
14230: GO 14189
14232: POP
14233: POP
// end ;
14234: LD_VAR 0 4
14238: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14239: LD_INT 0
14241: PPUSH
14242: PPUSH
14243: PPUSH
// result := true ;
14244: LD_ADDR_VAR 0 3
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14252: LD_ADDR_VAR 0 5
14256: PUSH
14257: LD_VAR 0 2
14261: PPUSH
14262: CALL_OW 480
14266: ST_TO_ADDR
// if not tmp then
14267: LD_VAR 0 5
14271: NOT
14272: IFFALSE 14276
// exit ;
14274: GO 14325
// for i in tmp do
14276: LD_ADDR_VAR 0 4
14280: PUSH
14281: LD_VAR 0 5
14285: PUSH
14286: FOR_IN
14287: IFFALSE 14323
// if GetTech ( i , side ) <> state_researched then
14289: LD_VAR 0 4
14293: PPUSH
14294: LD_VAR 0 1
14298: PPUSH
14299: CALL_OW 321
14303: PUSH
14304: LD_INT 2
14306: NONEQUAL
14307: IFFALSE 14321
// begin result := false ;
14309: LD_ADDR_VAR 0 3
14313: PUSH
14314: LD_INT 0
14316: ST_TO_ADDR
// exit ;
14317: POP
14318: POP
14319: GO 14325
// end ;
14321: GO 14286
14323: POP
14324: POP
// end ;
14325: LD_VAR 0 3
14329: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14330: LD_INT 0
14332: PPUSH
14333: PPUSH
14334: PPUSH
14335: PPUSH
14336: PPUSH
14337: PPUSH
14338: PPUSH
14339: PPUSH
14340: PPUSH
14341: PPUSH
14342: PPUSH
14343: PPUSH
14344: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14345: LD_VAR 0 1
14349: NOT
14350: PUSH
14351: LD_VAR 0 1
14355: PPUSH
14356: CALL_OW 257
14360: PUSH
14361: LD_INT 9
14363: NONEQUAL
14364: OR
14365: IFFALSE 14369
// exit ;
14367: GO 14942
// side := GetSide ( unit ) ;
14369: LD_ADDR_VAR 0 9
14373: PUSH
14374: LD_VAR 0 1
14378: PPUSH
14379: CALL_OW 255
14383: ST_TO_ADDR
// tech_space := tech_spacanom ;
14384: LD_ADDR_VAR 0 12
14388: PUSH
14389: LD_INT 29
14391: ST_TO_ADDR
// tech_time := tech_taurad ;
14392: LD_ADDR_VAR 0 13
14396: PUSH
14397: LD_INT 28
14399: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14400: LD_ADDR_VAR 0 11
14404: PUSH
14405: LD_VAR 0 1
14409: PPUSH
14410: CALL_OW 310
14414: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14415: LD_VAR 0 11
14419: PPUSH
14420: CALL_OW 247
14424: PUSH
14425: LD_INT 2
14427: EQUAL
14428: IFFALSE 14432
// exit ;
14430: GO 14942
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14432: LD_ADDR_VAR 0 8
14436: PUSH
14437: LD_INT 81
14439: PUSH
14440: LD_VAR 0 9
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 3
14451: PUSH
14452: LD_INT 21
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: ST_TO_ADDR
// if not tmp then
14475: LD_VAR 0 8
14479: NOT
14480: IFFALSE 14484
// exit ;
14482: GO 14942
// if in_unit then
14484: LD_VAR 0 11
14488: IFFALSE 14512
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14490: LD_ADDR_VAR 0 10
14494: PUSH
14495: LD_VAR 0 8
14499: PPUSH
14500: LD_VAR 0 11
14504: PPUSH
14505: CALL_OW 74
14509: ST_TO_ADDR
14510: GO 14532
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14512: LD_ADDR_VAR 0 10
14516: PUSH
14517: LD_VAR 0 8
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 74
14531: ST_TO_ADDR
// if not enemy then
14532: LD_VAR 0 10
14536: NOT
14537: IFFALSE 14541
// exit ;
14539: GO 14942
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14541: LD_VAR 0 11
14545: PUSH
14546: LD_VAR 0 11
14550: PPUSH
14551: LD_VAR 0 10
14555: PPUSH
14556: CALL_OW 296
14560: PUSH
14561: LD_INT 13
14563: GREATER
14564: AND
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: LD_VAR 0 10
14575: PPUSH
14576: CALL_OW 296
14580: PUSH
14581: LD_INT 12
14583: GREATER
14584: OR
14585: IFFALSE 14589
// exit ;
14587: GO 14942
// missile := [ 1 ] ;
14589: LD_ADDR_VAR 0 14
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14600: LD_VAR 0 9
14604: PPUSH
14605: LD_VAR 0 12
14609: PPUSH
14610: CALL_OW 325
14614: IFFALSE 14643
// missile := Insert ( missile , missile + 1 , 2 ) ;
14616: LD_ADDR_VAR 0 14
14620: PUSH
14621: LD_VAR 0 14
14625: PPUSH
14626: LD_VAR 0 14
14630: PUSH
14631: LD_INT 1
14633: PLUS
14634: PPUSH
14635: LD_INT 2
14637: PPUSH
14638: CALL_OW 2
14642: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14643: LD_VAR 0 9
14647: PPUSH
14648: LD_VAR 0 13
14652: PPUSH
14653: CALL_OW 325
14657: PUSH
14658: LD_VAR 0 10
14662: PPUSH
14663: CALL_OW 255
14667: PPUSH
14668: LD_VAR 0 13
14672: PPUSH
14673: CALL_OW 325
14677: NOT
14678: AND
14679: IFFALSE 14708
// missile := Insert ( missile , missile + 1 , 3 ) ;
14681: LD_ADDR_VAR 0 14
14685: PUSH
14686: LD_VAR 0 14
14690: PPUSH
14691: LD_VAR 0 14
14695: PUSH
14696: LD_INT 1
14698: PLUS
14699: PPUSH
14700: LD_INT 3
14702: PPUSH
14703: CALL_OW 2
14707: ST_TO_ADDR
// if missile < 2 then
14708: LD_VAR 0 14
14712: PUSH
14713: LD_INT 2
14715: LESS
14716: IFFALSE 14720
// exit ;
14718: GO 14942
// x := GetX ( enemy ) ;
14720: LD_ADDR_VAR 0 4
14724: PUSH
14725: LD_VAR 0 10
14729: PPUSH
14730: CALL_OW 250
14734: ST_TO_ADDR
// y := GetY ( enemy ) ;
14735: LD_ADDR_VAR 0 5
14739: PUSH
14740: LD_VAR 0 10
14744: PPUSH
14745: CALL_OW 251
14749: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14750: LD_ADDR_VAR 0 6
14754: PUSH
14755: LD_VAR 0 4
14759: PUSH
14760: LD_INT 1
14762: NEG
14763: PPUSH
14764: LD_INT 1
14766: PPUSH
14767: CALL_OW 12
14771: PLUS
14772: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14773: LD_ADDR_VAR 0 7
14777: PUSH
14778: LD_VAR 0 5
14782: PUSH
14783: LD_INT 1
14785: NEG
14786: PPUSH
14787: LD_INT 1
14789: PPUSH
14790: CALL_OW 12
14794: PLUS
14795: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
14796: LD_VAR 0 6
14800: PPUSH
14801: LD_VAR 0 7
14805: PPUSH
14806: CALL_OW 488
14810: NOT
14811: IFFALSE 14833
// begin _x := x ;
14813: LD_ADDR_VAR 0 6
14817: PUSH
14818: LD_VAR 0 4
14822: ST_TO_ADDR
// _y := y ;
14823: LD_ADDR_VAR 0 7
14827: PUSH
14828: LD_VAR 0 5
14832: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
14833: LD_ADDR_VAR 0 3
14837: PUSH
14838: LD_INT 1
14840: PPUSH
14841: LD_VAR 0 14
14845: PPUSH
14846: CALL_OW 12
14850: ST_TO_ADDR
// case i of 1 :
14851: LD_VAR 0 3
14855: PUSH
14856: LD_INT 1
14858: DOUBLE
14859: EQUAL
14860: IFTRUE 14864
14862: GO 14881
14864: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
14865: LD_VAR 0 1
14869: PPUSH
14870: LD_VAR 0 10
14874: PPUSH
14875: CALL_OW 115
14879: GO 14942
14881: LD_INT 2
14883: DOUBLE
14884: EQUAL
14885: IFTRUE 14889
14887: GO 14911
14889: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
14890: LD_VAR 0 1
14894: PPUSH
14895: LD_VAR 0 6
14899: PPUSH
14900: LD_VAR 0 7
14904: PPUSH
14905: CALL_OW 153
14909: GO 14942
14911: LD_INT 3
14913: DOUBLE
14914: EQUAL
14915: IFTRUE 14919
14917: GO 14941
14919: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
14920: LD_VAR 0 1
14924: PPUSH
14925: LD_VAR 0 6
14929: PPUSH
14930: LD_VAR 0 7
14934: PPUSH
14935: CALL_OW 154
14939: GO 14942
14941: POP
// end ;
14942: LD_VAR 0 2
14946: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
14947: LD_INT 0
14949: PPUSH
14950: PPUSH
14951: PPUSH
14952: PPUSH
14953: PPUSH
14954: PPUSH
// if not unit or not building then
14955: LD_VAR 0 1
14959: NOT
14960: PUSH
14961: LD_VAR 0 2
14965: NOT
14966: OR
14967: IFFALSE 14971
// exit ;
14969: GO 15129
// x := GetX ( building ) ;
14971: LD_ADDR_VAR 0 5
14975: PUSH
14976: LD_VAR 0 2
14980: PPUSH
14981: CALL_OW 250
14985: ST_TO_ADDR
// y := GetY ( building ) ;
14986: LD_ADDR_VAR 0 6
14990: PUSH
14991: LD_VAR 0 2
14995: PPUSH
14996: CALL_OW 251
15000: ST_TO_ADDR
// for i = 0 to 5 do
15001: LD_ADDR_VAR 0 4
15005: PUSH
15006: DOUBLE
15007: LD_INT 0
15009: DEC
15010: ST_TO_ADDR
15011: LD_INT 5
15013: PUSH
15014: FOR_TO
15015: IFFALSE 15127
// begin _x := ShiftX ( x , i , 3 ) ;
15017: LD_ADDR_VAR 0 7
15021: PUSH
15022: LD_VAR 0 5
15026: PPUSH
15027: LD_VAR 0 4
15031: PPUSH
15032: LD_INT 3
15034: PPUSH
15035: CALL_OW 272
15039: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15040: LD_ADDR_VAR 0 8
15044: PUSH
15045: LD_VAR 0 6
15049: PPUSH
15050: LD_VAR 0 4
15054: PPUSH
15055: LD_INT 3
15057: PPUSH
15058: CALL_OW 273
15062: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15063: LD_VAR 0 7
15067: PPUSH
15068: LD_VAR 0 8
15072: PPUSH
15073: CALL_OW 488
15077: NOT
15078: IFFALSE 15082
// continue ;
15080: GO 15014
// if HexInfo ( _x , _y ) = 0 then
15082: LD_VAR 0 7
15086: PPUSH
15087: LD_VAR 0 8
15091: PPUSH
15092: CALL_OW 428
15096: PUSH
15097: LD_INT 0
15099: EQUAL
15100: IFFALSE 15125
// begin ComMoveXY ( unit , _x , _y ) ;
15102: LD_VAR 0 1
15106: PPUSH
15107: LD_VAR 0 7
15111: PPUSH
15112: LD_VAR 0 8
15116: PPUSH
15117: CALL_OW 111
// exit ;
15121: POP
15122: POP
15123: GO 15129
// end ; end ;
15125: GO 15014
15127: POP
15128: POP
// end ;
15129: LD_VAR 0 3
15133: RET
// export function ScanBase ( side , base_area ) ; begin
15134: LD_INT 0
15136: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15137: LD_ADDR_VAR 0 3
15141: PUSH
15142: LD_VAR 0 2
15146: PPUSH
15147: LD_INT 81
15149: PUSH
15150: LD_VAR 0 1
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PPUSH
15159: CALL_OW 70
15163: ST_TO_ADDR
// end ;
15164: LD_VAR 0 3
15168: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15169: LD_INT 0
15171: PPUSH
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15176: LD_VAR 0 1
15180: NOT
15181: PUSH
15182: LD_EXP 58
15186: PUSH
15187: LD_VAR 0 1
15191: ARRAY
15192: NOT
15193: OR
15194: PUSH
15195: LD_VAR 0 2
15199: NOT
15200: OR
15201: PUSH
15202: LD_VAR 0 3
15206: NOT
15207: OR
15208: IFFALSE 15212
// exit ;
15210: GO 15662
// side := mc_sides [ base ] ;
15212: LD_ADDR_VAR 0 6
15216: PUSH
15217: LD_EXP 84
15221: PUSH
15222: LD_VAR 0 1
15226: ARRAY
15227: ST_TO_ADDR
// if not side then
15228: LD_VAR 0 6
15232: NOT
15233: IFFALSE 15237
// exit ;
15235: GO 15662
// for i in solds do
15237: LD_ADDR_VAR 0 7
15241: PUSH
15242: LD_VAR 0 2
15246: PUSH
15247: FOR_IN
15248: IFFALSE 15309
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15250: LD_VAR 0 7
15254: PPUSH
15255: CALL_OW 310
15259: PPUSH
15260: CALL_OW 266
15264: PUSH
15265: LD_INT 32
15267: PUSH
15268: LD_INT 31
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: IN
15275: IFFALSE 15295
// solds := solds diff i else
15277: LD_ADDR_VAR 0 2
15281: PUSH
15282: LD_VAR 0 2
15286: PUSH
15287: LD_VAR 0 7
15291: DIFF
15292: ST_TO_ADDR
15293: GO 15307
// SetTag ( i , 18 ) ;
15295: LD_VAR 0 7
15299: PPUSH
15300: LD_INT 18
15302: PPUSH
15303: CALL_OW 109
15307: GO 15247
15309: POP
15310: POP
// if not solds then
15311: LD_VAR 0 2
15315: NOT
15316: IFFALSE 15320
// exit ;
15318: GO 15662
// repeat wait ( 0 0$1 ) ;
15320: LD_INT 35
15322: PPUSH
15323: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15327: LD_ADDR_VAR 0 5
15331: PUSH
15332: LD_VAR 0 6
15336: PPUSH
15337: LD_VAR 0 3
15341: PPUSH
15342: CALL 15134 0 2
15346: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15347: LD_VAR 0 5
15351: NOT
15352: PUSH
15353: LD_VAR 0 5
15357: PUSH
15358: LD_INT 3
15360: GREATER
15361: OR
15362: PUSH
15363: LD_EXP 80
15367: PUSH
15368: LD_VAR 0 1
15372: ARRAY
15373: OR
15374: IFFALSE 15415
// begin for i in solds do
15376: LD_ADDR_VAR 0 7
15380: PUSH
15381: LD_VAR 0 2
15385: PUSH
15386: FOR_IN
15387: IFFALSE 15411
// if HasTask ( i ) then
15389: LD_VAR 0 7
15393: PPUSH
15394: CALL_OW 314
15398: IFFALSE 15409
// ComStop ( i ) ;
15400: LD_VAR 0 7
15404: PPUSH
15405: CALL_OW 141
15409: GO 15386
15411: POP
15412: POP
// break ;
15413: GO 15650
// end ; for i in solds do
15415: LD_ADDR_VAR 0 7
15419: PUSH
15420: LD_VAR 0 2
15424: PUSH
15425: FOR_IN
15426: IFFALSE 15642
// begin if IsInUnit ( i ) then
15428: LD_VAR 0 7
15432: PPUSH
15433: CALL_OW 310
15437: IFFALSE 15448
// ComExitBuilding ( i ) ;
15439: LD_VAR 0 7
15443: PPUSH
15444: CALL_OW 122
// if GetLives ( i ) > 333 then
15448: LD_VAR 0 7
15452: PPUSH
15453: CALL_OW 256
15457: PUSH
15458: LD_INT 333
15460: GREATER
15461: IFFALSE 15489
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15463: LD_VAR 0 7
15467: PPUSH
15468: LD_VAR 0 5
15472: PPUSH
15473: LD_VAR 0 7
15477: PPUSH
15478: CALL_OW 74
15482: PPUSH
15483: CALL_OW 115
15487: GO 15640
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15489: LD_ADDR_VAR 0 8
15493: PUSH
15494: LD_EXP 58
15498: PUSH
15499: LD_VAR 0 1
15503: ARRAY
15504: PPUSH
15505: LD_INT 2
15507: PUSH
15508: LD_INT 30
15510: PUSH
15511: LD_INT 0
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: LD_INT 30
15520: PUSH
15521: LD_INT 1
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PUSH
15528: LD_INT 30
15530: PUSH
15531: LD_INT 6
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL_OW 72
15548: PPUSH
15549: LD_VAR 0 7
15553: PPUSH
15554: CALL_OW 74
15558: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15559: LD_VAR 0 7
15563: PPUSH
15564: LD_VAR 0 8
15568: PPUSH
15569: CALL_OW 250
15573: PPUSH
15574: LD_INT 3
15576: PPUSH
15577: LD_INT 5
15579: PPUSH
15580: CALL_OW 272
15584: PPUSH
15585: LD_VAR 0 8
15589: PPUSH
15590: CALL_OW 251
15594: PPUSH
15595: LD_INT 3
15597: PPUSH
15598: LD_INT 5
15600: PPUSH
15601: CALL_OW 273
15605: PPUSH
15606: CALL_OW 111
// SetTag ( i , 0 ) ;
15610: LD_VAR 0 7
15614: PPUSH
15615: LD_INT 0
15617: PPUSH
15618: CALL_OW 109
// solds := solds diff i ;
15622: LD_ADDR_VAR 0 2
15626: PUSH
15627: LD_VAR 0 2
15631: PUSH
15632: LD_VAR 0 7
15636: DIFF
15637: ST_TO_ADDR
// continue ;
15638: GO 15425
// end ; end ;
15640: GO 15425
15642: POP
15643: POP
// until solds ;
15644: LD_VAR 0 2
15648: IFFALSE 15320
// MC_Reset ( base , 18 ) ;
15650: LD_VAR 0 1
15654: PPUSH
15655: LD_INT 18
15657: PPUSH
15658: CALL 59161 0 2
// end ;
15662: LD_VAR 0 4
15666: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15667: LD_INT 0
15669: PPUSH
15670: PPUSH
15671: PPUSH
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
15677: PPUSH
15678: PPUSH
15679: PPUSH
15680: PPUSH
15681: PPUSH
15682: PPUSH
15683: PPUSH
15684: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15685: LD_ADDR_VAR 0 12
15689: PUSH
15690: LD_EXP 58
15694: PUSH
15695: LD_VAR 0 1
15699: ARRAY
15700: PPUSH
15701: LD_INT 25
15703: PUSH
15704: LD_INT 3
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PPUSH
15711: CALL_OW 72
15715: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15716: LD_ADDR_VAR 0 8
15720: PUSH
15721: LD_EXP 58
15725: PUSH
15726: LD_VAR 0 1
15730: ARRAY
15731: PPUSH
15732: LD_INT 2
15734: PUSH
15735: LD_INT 25
15737: PUSH
15738: LD_INT 1
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 25
15747: PUSH
15748: LD_INT 5
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 25
15757: PUSH
15758: LD_INT 8
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: LD_INT 25
15767: PUSH
15768: LD_INT 9
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: PPUSH
15782: CALL_OW 72
15786: ST_TO_ADDR
// if not defenders and not solds then
15787: LD_VAR 0 2
15791: NOT
15792: PUSH
15793: LD_VAR 0 8
15797: NOT
15798: AND
15799: IFFALSE 15803
// exit ;
15801: GO 17169
// depot_under_attack := false ;
15803: LD_ADDR_VAR 0 16
15807: PUSH
15808: LD_INT 0
15810: ST_TO_ADDR
// sold_defenders := [ ] ;
15811: LD_ADDR_VAR 0 17
15815: PUSH
15816: EMPTY
15817: ST_TO_ADDR
// if mechs then
15818: LD_VAR 0 12
15822: IFFALSE 15951
// for i in defenders do
15824: LD_ADDR_VAR 0 5
15828: PUSH
15829: LD_VAR 0 2
15833: PUSH
15834: FOR_IN
15835: IFFALSE 15949
// begin SetTag ( i , 20 ) ;
15837: LD_VAR 0 5
15841: PPUSH
15842: LD_INT 20
15844: PPUSH
15845: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
15849: LD_VAR 0 5
15853: PPUSH
15854: CALL_OW 263
15858: PUSH
15859: LD_INT 1
15861: EQUAL
15862: PUSH
15863: LD_VAR 0 5
15867: PPUSH
15868: CALL_OW 311
15872: NOT
15873: AND
15874: PUSH
15875: LD_VAR 0 12
15879: AND
15880: IFFALSE 15947
// begin un := mechs [ 1 ] ;
15882: LD_ADDR_VAR 0 10
15886: PUSH
15887: LD_VAR 0 12
15891: PUSH
15892: LD_INT 1
15894: ARRAY
15895: ST_TO_ADDR
// ComExitBuilding ( un ) ;
15896: LD_VAR 0 10
15900: PPUSH
15901: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
15905: LD_VAR 0 10
15909: PPUSH
15910: LD_VAR 0 5
15914: PPUSH
15915: CALL_OW 180
// SetTag ( un , 19 ) ;
15919: LD_VAR 0 10
15923: PPUSH
15924: LD_INT 19
15926: PPUSH
15927: CALL_OW 109
// mechs := mechs diff un ;
15931: LD_ADDR_VAR 0 12
15935: PUSH
15936: LD_VAR 0 12
15940: PUSH
15941: LD_VAR 0 10
15945: DIFF
15946: ST_TO_ADDR
// end ; end ;
15947: GO 15834
15949: POP
15950: POP
// if solds then
15951: LD_VAR 0 8
15955: IFFALSE 16014
// for i in solds do
15957: LD_ADDR_VAR 0 5
15961: PUSH
15962: LD_VAR 0 8
15966: PUSH
15967: FOR_IN
15968: IFFALSE 16012
// if not GetTag ( i ) then
15970: LD_VAR 0 5
15974: PPUSH
15975: CALL_OW 110
15979: NOT
15980: IFFALSE 16010
// begin defenders := defenders union i ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 2
15991: PUSH
15992: LD_VAR 0 5
15996: UNION
15997: ST_TO_ADDR
// SetTag ( i , 18 ) ;
15998: LD_VAR 0 5
16002: PPUSH
16003: LD_INT 18
16005: PPUSH
16006: CALL_OW 109
// end ;
16010: GO 15967
16012: POP
16013: POP
// repeat wait ( 0 0$1 ) ;
16014: LD_INT 35
16016: PPUSH
16017: CALL_OW 67
// enemy := mc_scan [ base ] ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_EXP 81
16030: PUSH
16031: LD_VAR 0 1
16035: ARRAY
16036: ST_TO_ADDR
// for i in defenders do
16037: LD_ADDR_VAR 0 5
16041: PUSH
16042: LD_VAR 0 2
16046: PUSH
16047: FOR_IN
16048: IFFALSE 16733
// begin e := NearestUnitToUnit ( enemy , i ) ;
16050: LD_ADDR_VAR 0 13
16054: PUSH
16055: LD_VAR 0 3
16059: PPUSH
16060: LD_VAR 0 5
16064: PPUSH
16065: CALL_OW 74
16069: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16070: LD_ADDR_VAR 0 16
16074: PUSH
16075: LD_EXP 58
16079: PUSH
16080: LD_VAR 0 1
16084: ARRAY
16085: PPUSH
16086: LD_INT 2
16088: PUSH
16089: LD_INT 30
16091: PUSH
16092: LD_INT 0
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: PUSH
16099: LD_INT 30
16101: PUSH
16102: LD_INT 1
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: LIST
16113: PPUSH
16114: CALL_OW 72
16118: NOT
16119: PUSH
16120: LD_EXP 58
16124: PUSH
16125: LD_VAR 0 1
16129: ARRAY
16130: PPUSH
16131: LD_INT 2
16133: PUSH
16134: LD_INT 30
16136: PUSH
16137: LD_INT 0
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: PUSH
16144: LD_INT 30
16146: PUSH
16147: LD_INT 1
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: LIST
16158: PPUSH
16159: CALL_OW 72
16163: PPUSH
16164: CALL_OW 256
16168: PUSH
16169: LD_INT 600
16171: LESS
16172: OR
16173: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16174: LD_VAR 0 5
16178: PPUSH
16179: CALL_OW 247
16183: PUSH
16184: LD_INT 2
16186: DOUBLE
16187: EQUAL
16188: IFTRUE 16192
16190: GO 16439
16192: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16193: LD_VAR 0 5
16197: PPUSH
16198: CALL_OW 256
16202: PUSH
16203: LD_INT 650
16205: GREATER
16206: PUSH
16207: LD_VAR 0 5
16211: PPUSH
16212: LD_VAR 0 13
16216: PPUSH
16217: CALL_OW 296
16221: PUSH
16222: LD_INT 40
16224: LESS
16225: AND
16226: IFFALSE 16244
// ComAttackUnit ( i , e ) else
16228: LD_VAR 0 5
16232: PPUSH
16233: LD_VAR 0 13
16237: PPUSH
16238: CALL_OW 115
16242: GO 16322
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16244: LD_VAR 0 5
16248: PPUSH
16249: LD_VAR 0 13
16253: PPUSH
16254: CALL_OW 296
16258: PUSH
16259: LD_INT 30
16261: GREATEREQUAL
16262: PUSH
16263: LD_VAR 0 5
16267: PPUSH
16268: CALL_OW 256
16272: PUSH
16273: LD_INT 650
16275: LESSEQUAL
16276: OR
16277: PUSH
16278: LD_VAR 0 5
16282: PPUSH
16283: LD_EXP 82
16287: PUSH
16288: LD_VAR 0 1
16292: ARRAY
16293: PPUSH
16294: CALL_OW 308
16298: NOT
16299: AND
16300: IFFALSE 16322
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16302: LD_VAR 0 5
16306: PPUSH
16307: LD_EXP 82
16311: PUSH
16312: LD_VAR 0 1
16316: ARRAY
16317: PPUSH
16318: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16322: LD_VAR 0 5
16326: PPUSH
16327: CALL_OW 256
16331: PUSH
16332: LD_INT 998
16334: LESS
16335: PUSH
16336: LD_VAR 0 5
16340: PPUSH
16341: CALL_OW 263
16345: PUSH
16346: LD_INT 1
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_VAR 0 5
16355: PPUSH
16356: CALL_OW 311
16360: AND
16361: PUSH
16362: LD_VAR 0 5
16366: PPUSH
16367: LD_EXP 82
16371: PUSH
16372: LD_VAR 0 1
16376: ARRAY
16377: PPUSH
16378: CALL_OW 308
16382: AND
16383: IFFALSE 16437
// begin mech := IsDrivenBy ( i ) ;
16385: LD_ADDR_VAR 0 9
16389: PUSH
16390: LD_VAR 0 5
16394: PPUSH
16395: CALL_OW 311
16399: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16400: LD_VAR 0 9
16404: PPUSH
16405: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16409: LD_VAR 0 9
16413: PPUSH
16414: LD_VAR 0 5
16418: PPUSH
16419: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16423: LD_VAR 0 9
16427: PPUSH
16428: LD_VAR 0 5
16432: PPUSH
16433: CALL_OW 180
// end ; end ; unit_human :
16437: GO 16704
16439: LD_INT 1
16441: DOUBLE
16442: EQUAL
16443: IFTRUE 16447
16445: GO 16703
16447: POP
// begin b := IsInUnit ( i ) ;
16448: LD_ADDR_VAR 0 18
16452: PUSH
16453: LD_VAR 0 5
16457: PPUSH
16458: CALL_OW 310
16462: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16463: LD_ADDR_VAR 0 19
16467: PUSH
16468: LD_VAR 0 18
16472: NOT
16473: PUSH
16474: LD_VAR 0 18
16478: PPUSH
16479: CALL_OW 266
16483: PUSH
16484: LD_INT 32
16486: PUSH
16487: LD_INT 31
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: IN
16494: OR
16495: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16496: LD_VAR 0 16
16500: PUSH
16501: LD_VAR 0 2
16505: PPUSH
16506: LD_INT 21
16508: PUSH
16509: LD_INT 2
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 72
16520: PUSH
16521: LD_INT 1
16523: LESSEQUAL
16524: OR
16525: PUSH
16526: LD_VAR 0 19
16530: AND
16531: PUSH
16532: LD_VAR 0 5
16536: PUSH
16537: LD_VAR 0 17
16541: IN
16542: NOT
16543: AND
16544: IFFALSE 16637
// begin if b then
16546: LD_VAR 0 18
16550: IFFALSE 16599
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16552: LD_VAR 0 18
16556: PPUSH
16557: LD_VAR 0 3
16561: PPUSH
16562: LD_VAR 0 18
16566: PPUSH
16567: CALL_OW 74
16571: PPUSH
16572: CALL_OW 296
16576: PUSH
16577: LD_INT 10
16579: LESS
16580: PUSH
16581: LD_VAR 0 18
16585: PPUSH
16586: CALL_OW 461
16590: PUSH
16591: LD_INT 7
16593: NONEQUAL
16594: AND
16595: IFFALSE 16599
// continue ;
16597: GO 16047
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16599: LD_ADDR_VAR 0 17
16603: PUSH
16604: LD_VAR 0 17
16608: PPUSH
16609: LD_VAR 0 17
16613: PUSH
16614: LD_INT 1
16616: PLUS
16617: PPUSH
16618: LD_VAR 0 5
16622: PPUSH
16623: CALL_OW 1
16627: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16628: LD_VAR 0 5
16632: PPUSH
16633: CALL_OW 122
// end ; if sold_defenders then
16637: LD_VAR 0 17
16641: IFFALSE 16701
// if i in sold_defenders then
16643: LD_VAR 0 5
16647: PUSH
16648: LD_VAR 0 17
16652: IN
16653: IFFALSE 16701
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16655: LD_VAR 0 5
16659: PPUSH
16660: CALL_OW 314
16664: NOT
16665: PUSH
16666: LD_VAR 0 5
16670: PPUSH
16671: LD_VAR 0 13
16675: PPUSH
16676: CALL_OW 296
16680: PUSH
16681: LD_INT 30
16683: LESS
16684: AND
16685: IFFALSE 16701
// ComAttackUnit ( i , e ) ;
16687: LD_VAR 0 5
16691: PPUSH
16692: LD_VAR 0 13
16696: PPUSH
16697: CALL_OW 115
// end ; end ; end ;
16701: GO 16704
16703: POP
// if IsDead ( i ) then
16704: LD_VAR 0 5
16708: PPUSH
16709: CALL_OW 301
16713: IFFALSE 16731
// defenders := defenders diff i ;
16715: LD_ADDR_VAR 0 2
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: LD_VAR 0 5
16729: DIFF
16730: ST_TO_ADDR
// end ;
16731: GO 16047
16733: POP
16734: POP
// until not enemy or not defenders ;
16735: LD_VAR 0 3
16739: NOT
16740: PUSH
16741: LD_VAR 0 2
16745: NOT
16746: OR
16747: IFFALSE 16014
// MC_Reset ( base , 18 ) ;
16749: LD_VAR 0 1
16753: PPUSH
16754: LD_INT 18
16756: PPUSH
16757: CALL 59161 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16761: LD_ADDR_VAR 0 2
16765: PUSH
16766: LD_VAR 0 2
16770: PUSH
16771: LD_VAR 0 2
16775: PPUSH
16776: LD_INT 2
16778: PUSH
16779: LD_INT 25
16781: PUSH
16782: LD_INT 1
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 5
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: LD_INT 25
16801: PUSH
16802: LD_INT 8
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 25
16811: PUSH
16812: LD_INT 9
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: PPUSH
16826: CALL_OW 72
16830: DIFF
16831: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
16832: LD_VAR 0 3
16836: NOT
16837: PUSH
16838: LD_VAR 0 2
16842: PPUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 2
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 72
16857: AND
16858: IFFALSE 17120
// begin tmp := FilterByTag ( defenders , 19 ) ;
16860: LD_ADDR_VAR 0 11
16864: PUSH
16865: LD_VAR 0 2
16869: PPUSH
16870: LD_INT 19
16872: PPUSH
16873: CALL 53467 0 2
16877: ST_TO_ADDR
// if tmp then
16878: LD_VAR 0 11
16882: IFFALSE 16952
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
16884: LD_ADDR_VAR 0 11
16888: PUSH
16889: LD_VAR 0 11
16893: PPUSH
16894: LD_INT 25
16896: PUSH
16897: LD_INT 3
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PPUSH
16904: CALL_OW 72
16908: ST_TO_ADDR
// if tmp then
16909: LD_VAR 0 11
16913: IFFALSE 16952
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
16915: LD_ADDR_EXP 70
16919: PUSH
16920: LD_EXP 70
16924: PPUSH
16925: LD_VAR 0 1
16929: PPUSH
16930: LD_EXP 70
16934: PUSH
16935: LD_VAR 0 1
16939: ARRAY
16940: PUSH
16941: LD_VAR 0 11
16945: UNION
16946: PPUSH
16947: CALL_OW 1
16951: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
16952: LD_VAR 0 1
16956: PPUSH
16957: LD_INT 19
16959: PPUSH
16960: CALL 59161 0 2
// repeat wait ( 0 0$1 ) ;
16964: LD_INT 35
16966: PPUSH
16967: CALL_OW 67
// for i in defenders do
16971: LD_ADDR_VAR 0 5
16975: PUSH
16976: LD_VAR 0 2
16980: PUSH
16981: FOR_IN
16982: IFFALSE 17071
// begin if not IsInArea ( i , mc_parking [ base ] ) then
16984: LD_VAR 0 5
16988: PPUSH
16989: LD_EXP 82
16993: PUSH
16994: LD_VAR 0 1
16998: ARRAY
16999: PPUSH
17000: CALL_OW 308
17004: NOT
17005: IFFALSE 17029
// ComMoveToArea ( i , mc_parking [ base ] ) else
17007: LD_VAR 0 5
17011: PPUSH
17012: LD_EXP 82
17016: PUSH
17017: LD_VAR 0 1
17021: ARRAY
17022: PPUSH
17023: CALL_OW 113
17027: GO 17069
// if GetControl ( i ) = control_manual then
17029: LD_VAR 0 5
17033: PPUSH
17034: CALL_OW 263
17038: PUSH
17039: LD_INT 1
17041: EQUAL
17042: IFFALSE 17069
// if IsDrivenBy ( i ) then
17044: LD_VAR 0 5
17048: PPUSH
17049: CALL_OW 311
17053: IFFALSE 17069
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17055: LD_VAR 0 5
17059: PPUSH
17060: CALL_OW 311
17064: PPUSH
17065: CALL_OW 121
// end ;
17069: GO 16981
17071: POP
17072: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17073: LD_VAR 0 2
17077: PPUSH
17078: LD_INT 95
17080: PUSH
17081: LD_EXP 82
17085: PUSH
17086: LD_VAR 0 1
17090: ARRAY
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PPUSH
17096: CALL_OW 72
17100: PUSH
17101: LD_VAR 0 2
17105: EQUAL
17106: PUSH
17107: LD_EXP 81
17111: PUSH
17112: LD_VAR 0 1
17116: ARRAY
17117: OR
17118: IFFALSE 16964
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17120: LD_ADDR_EXP 80
17124: PUSH
17125: LD_EXP 80
17129: PPUSH
17130: LD_VAR 0 1
17134: PPUSH
17135: LD_EXP 80
17139: PUSH
17140: LD_VAR 0 1
17144: ARRAY
17145: PUSH
17146: LD_VAR 0 2
17150: UNION
17151: PPUSH
17152: CALL_OW 1
17156: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17157: LD_VAR 0 1
17161: PPUSH
17162: LD_INT 20
17164: PPUSH
17165: CALL 59161 0 2
// end ;
17169: LD_VAR 0 4
17173: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17174: LD_INT 0
17176: PPUSH
17177: PPUSH
17178: PPUSH
17179: PPUSH
// result := false ;
17180: LD_ADDR_VAR 0 2
17184: PUSH
17185: LD_INT 0
17187: ST_TO_ADDR
// side := GetSide ( unit ) ;
17188: LD_ADDR_VAR 0 3
17192: PUSH
17193: LD_VAR 0 1
17197: PPUSH
17198: CALL_OW 255
17202: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17203: LD_ADDR_VAR 0 4
17207: PUSH
17208: LD_VAR 0 1
17212: PPUSH
17213: CALL_OW 248
17217: ST_TO_ADDR
// case nat of 1 :
17218: LD_VAR 0 4
17222: PUSH
17223: LD_INT 1
17225: DOUBLE
17226: EQUAL
17227: IFTRUE 17231
17229: GO 17242
17231: POP
// tech := tech_lassight ; 2 :
17232: LD_ADDR_VAR 0 5
17236: PUSH
17237: LD_INT 12
17239: ST_TO_ADDR
17240: GO 17281
17242: LD_INT 2
17244: DOUBLE
17245: EQUAL
17246: IFTRUE 17250
17248: GO 17261
17250: POP
// tech := tech_mortar ; 3 :
17251: LD_ADDR_VAR 0 5
17255: PUSH
17256: LD_INT 41
17258: ST_TO_ADDR
17259: GO 17281
17261: LD_INT 3
17263: DOUBLE
17264: EQUAL
17265: IFTRUE 17269
17267: GO 17280
17269: POP
// tech := tech_bazooka ; end ;
17270: LD_ADDR_VAR 0 5
17274: PUSH
17275: LD_INT 44
17277: ST_TO_ADDR
17278: GO 17281
17280: POP
// if Researched ( side , tech ) then
17281: LD_VAR 0 3
17285: PPUSH
17286: LD_VAR 0 5
17290: PPUSH
17291: CALL_OW 325
17295: IFFALSE 17322
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17297: LD_ADDR_VAR 0 2
17301: PUSH
17302: LD_INT 5
17304: PUSH
17305: LD_INT 8
17307: PUSH
17308: LD_INT 9
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: PUSH
17316: LD_VAR 0 4
17320: ARRAY
17321: ST_TO_ADDR
// end ;
17322: LD_VAR 0 2
17326: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17327: LD_INT 0
17329: PPUSH
17330: PPUSH
17331: PPUSH
// if not mines then
17332: LD_VAR 0 2
17336: NOT
17337: IFFALSE 17341
// exit ;
17339: GO 17485
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17341: LD_ADDR_VAR 0 5
17345: PUSH
17346: LD_INT 81
17348: PUSH
17349: LD_VAR 0 1
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: LD_INT 3
17360: PUSH
17361: LD_INT 21
17363: PUSH
17364: LD_INT 3
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 69
17383: ST_TO_ADDR
// for i in mines do
17384: LD_ADDR_VAR 0 4
17388: PUSH
17389: LD_VAR 0 2
17393: PUSH
17394: FOR_IN
17395: IFFALSE 17483
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17397: LD_VAR 0 4
17401: PUSH
17402: LD_INT 1
17404: ARRAY
17405: PPUSH
17406: LD_VAR 0 4
17410: PUSH
17411: LD_INT 2
17413: ARRAY
17414: PPUSH
17415: CALL_OW 458
17419: NOT
17420: IFFALSE 17424
// continue ;
17422: GO 17394
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17424: LD_VAR 0 4
17428: PUSH
17429: LD_INT 1
17431: ARRAY
17432: PPUSH
17433: LD_VAR 0 4
17437: PUSH
17438: LD_INT 2
17440: ARRAY
17441: PPUSH
17442: CALL_OW 428
17446: PUSH
17447: LD_VAR 0 5
17451: IN
17452: IFFALSE 17481
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17454: LD_VAR 0 4
17458: PUSH
17459: LD_INT 1
17461: ARRAY
17462: PPUSH
17463: LD_VAR 0 4
17467: PUSH
17468: LD_INT 2
17470: ARRAY
17471: PPUSH
17472: LD_VAR 0 1
17476: PPUSH
17477: CALL_OW 456
// end ;
17481: GO 17394
17483: POP
17484: POP
// end ;
17485: LD_VAR 0 3
17489: RET
// export function Count ( array ) ; var i ; begin
17490: LD_INT 0
17492: PPUSH
17493: PPUSH
// result := 0 ;
17494: LD_ADDR_VAR 0 2
17498: PUSH
17499: LD_INT 0
17501: ST_TO_ADDR
// for i in array do
17502: LD_ADDR_VAR 0 3
17506: PUSH
17507: LD_VAR 0 1
17511: PUSH
17512: FOR_IN
17513: IFFALSE 17537
// if i then
17515: LD_VAR 0 3
17519: IFFALSE 17535
// result := result + 1 ;
17521: LD_ADDR_VAR 0 2
17525: PUSH
17526: LD_VAR 0 2
17530: PUSH
17531: LD_INT 1
17533: PLUS
17534: ST_TO_ADDR
17535: GO 17512
17537: POP
17538: POP
// end ;
17539: LD_VAR 0 2
17543: RET
// export function IsEmpty ( building ) ; begin
17544: LD_INT 0
17546: PPUSH
// if not building then
17547: LD_VAR 0 1
17551: NOT
17552: IFFALSE 17556
// exit ;
17554: GO 17599
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17556: LD_ADDR_VAR 0 2
17560: PUSH
17561: LD_VAR 0 1
17565: PUSH
17566: LD_INT 22
17568: PUSH
17569: LD_VAR 0 1
17573: PPUSH
17574: CALL_OW 255
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: LD_INT 58
17585: PUSH
17586: EMPTY
17587: LIST
17588: PUSH
17589: EMPTY
17590: LIST
17591: LIST
17592: PPUSH
17593: CALL_OW 69
17597: IN
17598: ST_TO_ADDR
// end ;
17599: LD_VAR 0 2
17603: RET
// export function IsNotFull ( building ) ; begin
17604: LD_INT 0
17606: PPUSH
// if not building then
17607: LD_VAR 0 1
17611: NOT
17612: IFFALSE 17616
// exit ;
17614: GO 17635
// result := UnitsInside ( building ) < 6 ;
17616: LD_ADDR_VAR 0 2
17620: PUSH
17621: LD_VAR 0 1
17625: PPUSH
17626: CALL_OW 313
17630: PUSH
17631: LD_INT 6
17633: LESS
17634: ST_TO_ADDR
// end ;
17635: LD_VAR 0 2
17639: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17640: LD_INT 0
17642: PPUSH
17643: PPUSH
17644: PPUSH
17645: PPUSH
// tmp := [ ] ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: EMPTY
17652: ST_TO_ADDR
// list := [ ] ;
17653: LD_ADDR_VAR 0 5
17657: PUSH
17658: EMPTY
17659: ST_TO_ADDR
// for i = 16 to 25 do
17660: LD_ADDR_VAR 0 4
17664: PUSH
17665: DOUBLE
17666: LD_INT 16
17668: DEC
17669: ST_TO_ADDR
17670: LD_INT 25
17672: PUSH
17673: FOR_TO
17674: IFFALSE 17747
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17676: LD_ADDR_VAR 0 3
17680: PUSH
17681: LD_VAR 0 3
17685: PUSH
17686: LD_INT 22
17688: PUSH
17689: LD_VAR 0 1
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: EMPTY
17700: LIST
17701: LIST
17702: PUSH
17703: LD_INT 91
17705: PUSH
17706: LD_VAR 0 1
17710: PUSH
17711: LD_INT 6
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: PUSH
17719: LD_INT 30
17721: PUSH
17722: LD_VAR 0 4
17726: PUSH
17727: EMPTY
17728: LIST
17729: LIST
17730: PUSH
17731: EMPTY
17732: LIST
17733: LIST
17734: LIST
17735: PUSH
17736: EMPTY
17737: LIST
17738: PPUSH
17739: CALL_OW 69
17743: ADD
17744: ST_TO_ADDR
17745: GO 17673
17747: POP
17748: POP
// for i = 1 to tmp do
17749: LD_ADDR_VAR 0 4
17753: PUSH
17754: DOUBLE
17755: LD_INT 1
17757: DEC
17758: ST_TO_ADDR
17759: LD_VAR 0 3
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17853
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17767: LD_ADDR_VAR 0 5
17771: PUSH
17772: LD_VAR 0 5
17776: PUSH
17777: LD_VAR 0 3
17781: PUSH
17782: LD_VAR 0 4
17786: ARRAY
17787: PPUSH
17788: CALL_OW 266
17792: PUSH
17793: LD_VAR 0 3
17797: PUSH
17798: LD_VAR 0 4
17802: ARRAY
17803: PPUSH
17804: CALL_OW 250
17808: PUSH
17809: LD_VAR 0 3
17813: PUSH
17814: LD_VAR 0 4
17818: ARRAY
17819: PPUSH
17820: CALL_OW 251
17824: PUSH
17825: LD_VAR 0 3
17829: PUSH
17830: LD_VAR 0 4
17834: ARRAY
17835: PPUSH
17836: CALL_OW 254
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: PUSH
17847: EMPTY
17848: LIST
17849: ADD
17850: ST_TO_ADDR
17851: GO 17764
17853: POP
17854: POP
// result := list ;
17855: LD_ADDR_VAR 0 2
17859: PUSH
17860: LD_VAR 0 5
17864: ST_TO_ADDR
// end ;
17865: LD_VAR 0 2
17869: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17870: LD_INT 0
17872: PPUSH
17873: PPUSH
17874: PPUSH
17875: PPUSH
17876: PPUSH
17877: PPUSH
17878: PPUSH
// if not factory then
17879: LD_VAR 0 1
17883: NOT
17884: IFFALSE 17888
// exit ;
17886: GO 18413
// if control = control_apeman then
17888: LD_VAR 0 4
17892: PUSH
17893: LD_INT 5
17895: EQUAL
17896: IFFALSE 18005
// begin tmp := UnitsInside ( factory ) ;
17898: LD_ADDR_VAR 0 8
17902: PUSH
17903: LD_VAR 0 1
17907: PPUSH
17908: CALL_OW 313
17912: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17913: LD_VAR 0 8
17917: PPUSH
17918: LD_INT 25
17920: PUSH
17921: LD_INT 12
17923: PUSH
17924: EMPTY
17925: LIST
17926: LIST
17927: PPUSH
17928: CALL_OW 72
17932: NOT
17933: IFFALSE 17943
// control := control_manual ;
17935: LD_ADDR_VAR 0 4
17939: PUSH
17940: LD_INT 1
17942: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17943: LD_ADDR_VAR 0 8
17947: PUSH
17948: LD_VAR 0 1
17952: PPUSH
17953: CALL 17640 0 1
17957: ST_TO_ADDR
// if tmp then
17958: LD_VAR 0 8
17962: IFFALSE 18005
// begin for i in tmp do
17964: LD_ADDR_VAR 0 7
17968: PUSH
17969: LD_VAR 0 8
17973: PUSH
17974: FOR_IN
17975: IFFALSE 18003
// if i [ 1 ] = b_ext_radar then
17977: LD_VAR 0 7
17981: PUSH
17982: LD_INT 1
17984: ARRAY
17985: PUSH
17986: LD_INT 20
17988: EQUAL
17989: IFFALSE 18001
// begin control := control_remote ;
17991: LD_ADDR_VAR 0 4
17995: PUSH
17996: LD_INT 2
17998: ST_TO_ADDR
// break ;
17999: GO 18003
// end ;
18001: GO 17974
18003: POP
18004: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18005: LD_VAR 0 1
18009: PPUSH
18010: LD_VAR 0 2
18014: PPUSH
18015: LD_VAR 0 3
18019: PPUSH
18020: LD_VAR 0 4
18024: PPUSH
18025: LD_VAR 0 5
18029: PPUSH
18030: CALL_OW 448
18034: IFFALSE 18069
// begin result := [ chassis , engine , control , weapon ] ;
18036: LD_ADDR_VAR 0 6
18040: PUSH
18041: LD_VAR 0 2
18045: PUSH
18046: LD_VAR 0 3
18050: PUSH
18051: LD_VAR 0 4
18055: PUSH
18056: LD_VAR 0 5
18060: PUSH
18061: EMPTY
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: ST_TO_ADDR
// exit ;
18067: GO 18413
// end ; _chassis := AvailableChassisList ( factory ) ;
18069: LD_ADDR_VAR 0 9
18073: PUSH
18074: LD_VAR 0 1
18078: PPUSH
18079: CALL_OW 475
18083: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18084: LD_ADDR_VAR 0 11
18088: PUSH
18089: LD_VAR 0 1
18093: PPUSH
18094: CALL_OW 476
18098: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18099: LD_ADDR_VAR 0 12
18103: PUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: CALL_OW 477
18113: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18114: LD_ADDR_VAR 0 10
18118: PUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: CALL_OW 478
18128: ST_TO_ADDR
// if not chassis in _chassis then
18129: LD_VAR 0 2
18133: PUSH
18134: LD_VAR 0 9
18138: IN
18139: NOT
18140: IFFALSE 18166
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18142: LD_ADDR_VAR 0 2
18146: PUSH
18147: LD_VAR 0 9
18151: PUSH
18152: LD_INT 1
18154: PPUSH
18155: LD_VAR 0 9
18159: PPUSH
18160: CALL_OW 12
18164: ARRAY
18165: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18166: LD_VAR 0 2
18170: PPUSH
18171: LD_VAR 0 3
18175: PPUSH
18176: CALL 18418 0 2
18180: NOT
18181: IFFALSE 18240
// repeat engine := _engine [ 1 ] ;
18183: LD_ADDR_VAR 0 3
18187: PUSH
18188: LD_VAR 0 11
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18197: LD_ADDR_VAR 0 11
18201: PUSH
18202: LD_VAR 0 11
18206: PPUSH
18207: LD_INT 1
18209: PPUSH
18210: CALL_OW 3
18214: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18215: LD_VAR 0 2
18219: PPUSH
18220: LD_VAR 0 3
18224: PPUSH
18225: CALL 18418 0 2
18229: PUSH
18230: LD_VAR 0 11
18234: PUSH
18235: EMPTY
18236: EQUAL
18237: OR
18238: IFFALSE 18183
// if not control in _control then
18240: LD_VAR 0 4
18244: PUSH
18245: LD_VAR 0 12
18249: IN
18250: NOT
18251: IFFALSE 18277
// control := _control [ rand ( 1 , _control ) ] ;
18253: LD_ADDR_VAR 0 4
18257: PUSH
18258: LD_VAR 0 12
18262: PUSH
18263: LD_INT 1
18265: PPUSH
18266: LD_VAR 0 12
18270: PPUSH
18271: CALL_OW 12
18275: ARRAY
18276: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18277: LD_VAR 0 2
18281: PPUSH
18282: LD_VAR 0 5
18286: PPUSH
18287: CALL 18638 0 2
18291: NOT
18292: IFFALSE 18351
// repeat weapon := _weapon [ 1 ] ;
18294: LD_ADDR_VAR 0 5
18298: PUSH
18299: LD_VAR 0 10
18303: PUSH
18304: LD_INT 1
18306: ARRAY
18307: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18308: LD_ADDR_VAR 0 10
18312: PUSH
18313: LD_VAR 0 10
18317: PPUSH
18318: LD_INT 1
18320: PPUSH
18321: CALL_OW 3
18325: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18326: LD_VAR 0 2
18330: PPUSH
18331: LD_VAR 0 5
18335: PPUSH
18336: CALL 18638 0 2
18340: PUSH
18341: LD_VAR 0 10
18345: PUSH
18346: EMPTY
18347: EQUAL
18348: OR
18349: IFFALSE 18294
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18351: LD_VAR 0 1
18355: PPUSH
18356: LD_VAR 0 2
18360: PPUSH
18361: LD_VAR 0 3
18365: PPUSH
18366: LD_VAR 0 4
18370: PPUSH
18371: LD_VAR 0 5
18375: PPUSH
18376: CALL_OW 448
18380: IFFALSE 18413
// result := [ chassis , engine , control , weapon ] ;
18382: LD_ADDR_VAR 0 6
18386: PUSH
18387: LD_VAR 0 2
18391: PUSH
18392: LD_VAR 0 3
18396: PUSH
18397: LD_VAR 0 4
18401: PUSH
18402: LD_VAR 0 5
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: ST_TO_ADDR
// end ;
18413: LD_VAR 0 6
18417: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18418: LD_INT 0
18420: PPUSH
// if not chassis or not engine then
18421: LD_VAR 0 1
18425: NOT
18426: PUSH
18427: LD_VAR 0 2
18431: NOT
18432: OR
18433: IFFALSE 18437
// exit ;
18435: GO 18633
// case engine of engine_solar :
18437: LD_VAR 0 2
18441: PUSH
18442: LD_INT 2
18444: DOUBLE
18445: EQUAL
18446: IFTRUE 18450
18448: GO 18488
18450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18451: LD_ADDR_VAR 0 3
18455: PUSH
18456: LD_INT 11
18458: PUSH
18459: LD_INT 12
18461: PUSH
18462: LD_INT 13
18464: PUSH
18465: LD_INT 14
18467: PUSH
18468: LD_INT 1
18470: PUSH
18471: LD_INT 2
18473: PUSH
18474: LD_INT 3
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18617
18488: LD_INT 1
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18558
18496: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 11
18504: PUSH
18505: LD_INT 12
18507: PUSH
18508: LD_INT 13
18510: PUSH
18511: LD_INT 14
18513: PUSH
18514: LD_INT 1
18516: PUSH
18517: LD_INT 2
18519: PUSH
18520: LD_INT 3
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: LD_INT 5
18528: PUSH
18529: LD_INT 21
18531: PUSH
18532: LD_INT 23
18534: PUSH
18535: LD_INT 22
18537: PUSH
18538: LD_INT 24
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: ST_TO_ADDR
18556: GO 18617
18558: LD_INT 3
18560: DOUBLE
18561: EQUAL
18562: IFTRUE 18566
18564: GO 18616
18566: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18567: LD_ADDR_VAR 0 3
18571: PUSH
18572: LD_INT 13
18574: PUSH
18575: LD_INT 14
18577: PUSH
18578: LD_INT 2
18580: PUSH
18581: LD_INT 3
18583: PUSH
18584: LD_INT 4
18586: PUSH
18587: LD_INT 5
18589: PUSH
18590: LD_INT 21
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
18614: GO 18617
18616: POP
// result := ( chassis in result ) ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_VAR 0 1
18626: PUSH
18627: LD_VAR 0 3
18631: IN
18632: ST_TO_ADDR
// end ;
18633: LD_VAR 0 3
18637: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18638: LD_INT 0
18640: PPUSH
// if not chassis or not weapon then
18641: LD_VAR 0 1
18645: NOT
18646: PUSH
18647: LD_VAR 0 2
18651: NOT
18652: OR
18653: IFFALSE 18657
// exit ;
18655: GO 19683
// case weapon of us_machine_gun :
18657: LD_VAR 0 2
18661: PUSH
18662: LD_INT 2
18664: DOUBLE
18665: EQUAL
18666: IFTRUE 18670
18668: GO 18700
18670: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: LD_INT 1
18678: PUSH
18679: LD_INT 2
18681: PUSH
18682: LD_INT 3
18684: PUSH
18685: LD_INT 4
18687: PUSH
18688: LD_INT 5
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: ST_TO_ADDR
18698: GO 19667
18700: LD_INT 3
18702: DOUBLE
18703: EQUAL
18704: IFTRUE 18708
18706: GO 18738
18708: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18709: LD_ADDR_VAR 0 3
18713: PUSH
18714: LD_INT 1
18716: PUSH
18717: LD_INT 2
18719: PUSH
18720: LD_INT 3
18722: PUSH
18723: LD_INT 4
18725: PUSH
18726: LD_INT 5
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: LIST
18733: LIST
18734: LIST
18735: ST_TO_ADDR
18736: GO 19667
18738: LD_INT 11
18740: DOUBLE
18741: EQUAL
18742: IFTRUE 18746
18744: GO 18776
18746: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18747: LD_ADDR_VAR 0 3
18751: PUSH
18752: LD_INT 1
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 3
18760: PUSH
18761: LD_INT 4
18763: PUSH
18764: LD_INT 5
18766: PUSH
18767: EMPTY
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: ST_TO_ADDR
18774: GO 19667
18776: LD_INT 4
18778: DOUBLE
18779: EQUAL
18780: IFTRUE 18784
18782: GO 18810
18784: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18785: LD_ADDR_VAR 0 3
18789: PUSH
18790: LD_INT 2
18792: PUSH
18793: LD_INT 3
18795: PUSH
18796: LD_INT 4
18798: PUSH
18799: LD_INT 5
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: ST_TO_ADDR
18808: GO 19667
18810: LD_INT 5
18812: DOUBLE
18813: EQUAL
18814: IFTRUE 18818
18816: GO 18844
18818: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18819: LD_ADDR_VAR 0 3
18823: PUSH
18824: LD_INT 2
18826: PUSH
18827: LD_INT 3
18829: PUSH
18830: LD_INT 4
18832: PUSH
18833: LD_INT 5
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: ST_TO_ADDR
18842: GO 19667
18844: LD_INT 9
18846: DOUBLE
18847: EQUAL
18848: IFTRUE 18852
18850: GO 18878
18852: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18853: LD_ADDR_VAR 0 3
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: LD_INT 3
18863: PUSH
18864: LD_INT 4
18866: PUSH
18867: LD_INT 5
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: LIST
18874: LIST
18875: ST_TO_ADDR
18876: GO 19667
18878: LD_INT 7
18880: DOUBLE
18881: EQUAL
18882: IFTRUE 18886
18884: GO 18912
18886: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18887: LD_ADDR_VAR 0 3
18891: PUSH
18892: LD_INT 2
18894: PUSH
18895: LD_INT 3
18897: PUSH
18898: LD_INT 4
18900: PUSH
18901: LD_INT 5
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: LIST
18908: LIST
18909: ST_TO_ADDR
18910: GO 19667
18912: LD_INT 12
18914: DOUBLE
18915: EQUAL
18916: IFTRUE 18920
18918: GO 18946
18920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18921: LD_ADDR_VAR 0 3
18925: PUSH
18926: LD_INT 2
18928: PUSH
18929: LD_INT 3
18931: PUSH
18932: LD_INT 4
18934: PUSH
18935: LD_INT 5
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: ST_TO_ADDR
18944: GO 19667
18946: LD_INT 13
18948: DOUBLE
18949: EQUAL
18950: IFTRUE 18954
18952: GO 18980
18954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18955: LD_ADDR_VAR 0 3
18959: PUSH
18960: LD_INT 2
18962: PUSH
18963: LD_INT 3
18965: PUSH
18966: LD_INT 4
18968: PUSH
18969: LD_INT 5
18971: PUSH
18972: EMPTY
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: ST_TO_ADDR
18978: GO 19667
18980: LD_INT 14
18982: DOUBLE
18983: EQUAL
18984: IFTRUE 18988
18986: GO 19006
18988: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18989: LD_ADDR_VAR 0 3
18993: PUSH
18994: LD_INT 4
18996: PUSH
18997: LD_INT 5
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: ST_TO_ADDR
19004: GO 19667
19006: LD_INT 6
19008: DOUBLE
19009: EQUAL
19010: IFTRUE 19014
19012: GO 19032
19014: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19015: LD_ADDR_VAR 0 3
19019: PUSH
19020: LD_INT 4
19022: PUSH
19023: LD_INT 5
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: ST_TO_ADDR
19030: GO 19667
19032: LD_INT 10
19034: DOUBLE
19035: EQUAL
19036: IFTRUE 19040
19038: GO 19058
19040: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19041: LD_ADDR_VAR 0 3
19045: PUSH
19046: LD_INT 4
19048: PUSH
19049: LD_INT 5
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: ST_TO_ADDR
19056: GO 19667
19058: LD_INT 22
19060: DOUBLE
19061: EQUAL
19062: IFTRUE 19066
19064: GO 19092
19066: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19067: LD_ADDR_VAR 0 3
19071: PUSH
19072: LD_INT 11
19074: PUSH
19075: LD_INT 12
19077: PUSH
19078: LD_INT 13
19080: PUSH
19081: LD_INT 14
19083: PUSH
19084: EMPTY
19085: LIST
19086: LIST
19087: LIST
19088: LIST
19089: ST_TO_ADDR
19090: GO 19667
19092: LD_INT 23
19094: DOUBLE
19095: EQUAL
19096: IFTRUE 19100
19098: GO 19126
19100: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19101: LD_ADDR_VAR 0 3
19105: PUSH
19106: LD_INT 11
19108: PUSH
19109: LD_INT 12
19111: PUSH
19112: LD_INT 13
19114: PUSH
19115: LD_INT 14
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: ST_TO_ADDR
19124: GO 19667
19126: LD_INT 24
19128: DOUBLE
19129: EQUAL
19130: IFTRUE 19134
19132: GO 19160
19134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19135: LD_ADDR_VAR 0 3
19139: PUSH
19140: LD_INT 11
19142: PUSH
19143: LD_INT 12
19145: PUSH
19146: LD_INT 13
19148: PUSH
19149: LD_INT 14
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: ST_TO_ADDR
19158: GO 19667
19160: LD_INT 30
19162: DOUBLE
19163: EQUAL
19164: IFTRUE 19168
19166: GO 19194
19168: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19169: LD_ADDR_VAR 0 3
19173: PUSH
19174: LD_INT 11
19176: PUSH
19177: LD_INT 12
19179: PUSH
19180: LD_INT 13
19182: PUSH
19183: LD_INT 14
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: ST_TO_ADDR
19192: GO 19667
19194: LD_INT 25
19196: DOUBLE
19197: EQUAL
19198: IFTRUE 19202
19200: GO 19220
19202: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19203: LD_ADDR_VAR 0 3
19207: PUSH
19208: LD_INT 13
19210: PUSH
19211: LD_INT 14
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: ST_TO_ADDR
19218: GO 19667
19220: LD_INT 27
19222: DOUBLE
19223: EQUAL
19224: IFTRUE 19228
19226: GO 19246
19228: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19229: LD_ADDR_VAR 0 3
19233: PUSH
19234: LD_INT 13
19236: PUSH
19237: LD_INT 14
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: ST_TO_ADDR
19244: GO 19667
19246: LD_INT 28
19248: DOUBLE
19249: EQUAL
19250: IFTRUE 19254
19252: GO 19272
19254: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19255: LD_ADDR_VAR 0 3
19259: PUSH
19260: LD_INT 13
19262: PUSH
19263: LD_INT 14
19265: PUSH
19266: EMPTY
19267: LIST
19268: LIST
19269: ST_TO_ADDR
19270: GO 19667
19272: LD_INT 29
19274: DOUBLE
19275: EQUAL
19276: IFTRUE 19280
19278: GO 19298
19280: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19281: LD_ADDR_VAR 0 3
19285: PUSH
19286: LD_INT 13
19288: PUSH
19289: LD_INT 14
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: ST_TO_ADDR
19296: GO 19667
19298: LD_INT 31
19300: DOUBLE
19301: EQUAL
19302: IFTRUE 19306
19304: GO 19324
19306: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19307: LD_ADDR_VAR 0 3
19311: PUSH
19312: LD_INT 13
19314: PUSH
19315: LD_INT 14
19317: PUSH
19318: EMPTY
19319: LIST
19320: LIST
19321: ST_TO_ADDR
19322: GO 19667
19324: LD_INT 26
19326: DOUBLE
19327: EQUAL
19328: IFTRUE 19332
19330: GO 19350
19332: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19333: LD_ADDR_VAR 0 3
19337: PUSH
19338: LD_INT 13
19340: PUSH
19341: LD_INT 14
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: ST_TO_ADDR
19348: GO 19667
19350: LD_INT 42
19352: DOUBLE
19353: EQUAL
19354: IFTRUE 19358
19356: GO 19384
19358: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19359: LD_ADDR_VAR 0 3
19363: PUSH
19364: LD_INT 21
19366: PUSH
19367: LD_INT 22
19369: PUSH
19370: LD_INT 23
19372: PUSH
19373: LD_INT 24
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: ST_TO_ADDR
19382: GO 19667
19384: LD_INT 43
19386: DOUBLE
19387: EQUAL
19388: IFTRUE 19392
19390: GO 19418
19392: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19393: LD_ADDR_VAR 0 3
19397: PUSH
19398: LD_INT 21
19400: PUSH
19401: LD_INT 22
19403: PUSH
19404: LD_INT 23
19406: PUSH
19407: LD_INT 24
19409: PUSH
19410: EMPTY
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: ST_TO_ADDR
19416: GO 19667
19418: LD_INT 44
19420: DOUBLE
19421: EQUAL
19422: IFTRUE 19426
19424: GO 19452
19426: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19427: LD_ADDR_VAR 0 3
19431: PUSH
19432: LD_INT 21
19434: PUSH
19435: LD_INT 22
19437: PUSH
19438: LD_INT 23
19440: PUSH
19441: LD_INT 24
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: ST_TO_ADDR
19450: GO 19667
19452: LD_INT 45
19454: DOUBLE
19455: EQUAL
19456: IFTRUE 19460
19458: GO 19486
19460: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19461: LD_ADDR_VAR 0 3
19465: PUSH
19466: LD_INT 21
19468: PUSH
19469: LD_INT 22
19471: PUSH
19472: LD_INT 23
19474: PUSH
19475: LD_INT 24
19477: PUSH
19478: EMPTY
19479: LIST
19480: LIST
19481: LIST
19482: LIST
19483: ST_TO_ADDR
19484: GO 19667
19486: LD_INT 49
19488: DOUBLE
19489: EQUAL
19490: IFTRUE 19494
19492: GO 19520
19494: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19495: LD_ADDR_VAR 0 3
19499: PUSH
19500: LD_INT 21
19502: PUSH
19503: LD_INT 22
19505: PUSH
19506: LD_INT 23
19508: PUSH
19509: LD_INT 24
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: ST_TO_ADDR
19518: GO 19667
19520: LD_INT 51
19522: DOUBLE
19523: EQUAL
19524: IFTRUE 19528
19526: GO 19554
19528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19529: LD_ADDR_VAR 0 3
19533: PUSH
19534: LD_INT 21
19536: PUSH
19537: LD_INT 22
19539: PUSH
19540: LD_INT 23
19542: PUSH
19543: LD_INT 24
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: LIST
19550: LIST
19551: ST_TO_ADDR
19552: GO 19667
19554: LD_INT 52
19556: DOUBLE
19557: EQUAL
19558: IFTRUE 19562
19560: GO 19588
19562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19563: LD_ADDR_VAR 0 3
19567: PUSH
19568: LD_INT 21
19570: PUSH
19571: LD_INT 22
19573: PUSH
19574: LD_INT 23
19576: PUSH
19577: LD_INT 24
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: ST_TO_ADDR
19586: GO 19667
19588: LD_INT 53
19590: DOUBLE
19591: EQUAL
19592: IFTRUE 19596
19594: GO 19614
19596: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19597: LD_ADDR_VAR 0 3
19601: PUSH
19602: LD_INT 23
19604: PUSH
19605: LD_INT 24
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: ST_TO_ADDR
19612: GO 19667
19614: LD_INT 46
19616: DOUBLE
19617: EQUAL
19618: IFTRUE 19622
19620: GO 19640
19622: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19623: LD_ADDR_VAR 0 3
19627: PUSH
19628: LD_INT 23
19630: PUSH
19631: LD_INT 24
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: ST_TO_ADDR
19638: GO 19667
19640: LD_INT 47
19642: DOUBLE
19643: EQUAL
19644: IFTRUE 19648
19646: GO 19666
19648: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19649: LD_ADDR_VAR 0 3
19653: PUSH
19654: LD_INT 23
19656: PUSH
19657: LD_INT 24
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: ST_TO_ADDR
19664: GO 19667
19666: POP
// result := ( chassis in result ) ;
19667: LD_ADDR_VAR 0 3
19671: PUSH
19672: LD_VAR 0 1
19676: PUSH
19677: LD_VAR 0 3
19681: IN
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 3
19687: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19688: LD_INT 0
19690: PPUSH
19691: PPUSH
19692: PPUSH
19693: PPUSH
19694: PPUSH
19695: PPUSH
19696: PPUSH
// result := array ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_VAR 0 1
19706: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19707: LD_VAR 0 1
19711: NOT
19712: PUSH
19713: LD_VAR 0 2
19717: NOT
19718: OR
19719: PUSH
19720: LD_VAR 0 3
19724: NOT
19725: OR
19726: PUSH
19727: LD_VAR 0 2
19731: PUSH
19732: LD_VAR 0 1
19736: GREATER
19737: OR
19738: PUSH
19739: LD_VAR 0 3
19743: PUSH
19744: LD_VAR 0 1
19748: GREATER
19749: OR
19750: IFFALSE 19754
// exit ;
19752: GO 20050
// if direction then
19754: LD_VAR 0 4
19758: IFFALSE 19822
// begin d := 1 ;
19760: LD_ADDR_VAR 0 9
19764: PUSH
19765: LD_INT 1
19767: ST_TO_ADDR
// if i_from > i_to then
19768: LD_VAR 0 2
19772: PUSH
19773: LD_VAR 0 3
19777: GREATER
19778: IFFALSE 19804
// length := ( array - i_from ) + i_to else
19780: LD_ADDR_VAR 0 11
19784: PUSH
19785: LD_VAR 0 1
19789: PUSH
19790: LD_VAR 0 2
19794: MINUS
19795: PUSH
19796: LD_VAR 0 3
19800: PLUS
19801: ST_TO_ADDR
19802: GO 19820
// length := i_to - i_from ;
19804: LD_ADDR_VAR 0 11
19808: PUSH
19809: LD_VAR 0 3
19813: PUSH
19814: LD_VAR 0 2
19818: MINUS
19819: ST_TO_ADDR
// end else
19820: GO 19883
// begin d := - 1 ;
19822: LD_ADDR_VAR 0 9
19826: PUSH
19827: LD_INT 1
19829: NEG
19830: ST_TO_ADDR
// if i_from > i_to then
19831: LD_VAR 0 2
19835: PUSH
19836: LD_VAR 0 3
19840: GREATER
19841: IFFALSE 19861
// length := i_from - i_to else
19843: LD_ADDR_VAR 0 11
19847: PUSH
19848: LD_VAR 0 2
19852: PUSH
19853: LD_VAR 0 3
19857: MINUS
19858: ST_TO_ADDR
19859: GO 19883
// length := ( array - i_to ) + i_from ;
19861: LD_ADDR_VAR 0 11
19865: PUSH
19866: LD_VAR 0 1
19870: PUSH
19871: LD_VAR 0 3
19875: MINUS
19876: PUSH
19877: LD_VAR 0 2
19881: PLUS
19882: ST_TO_ADDR
// end ; if not length then
19883: LD_VAR 0 11
19887: NOT
19888: IFFALSE 19892
// exit ;
19890: GO 20050
// tmp := array ;
19892: LD_ADDR_VAR 0 10
19896: PUSH
19897: LD_VAR 0 1
19901: ST_TO_ADDR
// for i = 1 to length do
19902: LD_ADDR_VAR 0 6
19906: PUSH
19907: DOUBLE
19908: LD_INT 1
19910: DEC
19911: ST_TO_ADDR
19912: LD_VAR 0 11
19916: PUSH
19917: FOR_TO
19918: IFFALSE 20038
// begin for j = 1 to array do
19920: LD_ADDR_VAR 0 7
19924: PUSH
19925: DOUBLE
19926: LD_INT 1
19928: DEC
19929: ST_TO_ADDR
19930: LD_VAR 0 1
19934: PUSH
19935: FOR_TO
19936: IFFALSE 20024
// begin k := j + d ;
19938: LD_ADDR_VAR 0 8
19942: PUSH
19943: LD_VAR 0 7
19947: PUSH
19948: LD_VAR 0 9
19952: PLUS
19953: ST_TO_ADDR
// if k > array then
19954: LD_VAR 0 8
19958: PUSH
19959: LD_VAR 0 1
19963: GREATER
19964: IFFALSE 19974
// k := 1 ;
19966: LD_ADDR_VAR 0 8
19970: PUSH
19971: LD_INT 1
19973: ST_TO_ADDR
// if not k then
19974: LD_VAR 0 8
19978: NOT
19979: IFFALSE 19991
// k := array ;
19981: LD_ADDR_VAR 0 8
19985: PUSH
19986: LD_VAR 0 1
19990: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19991: LD_ADDR_VAR 0 10
19995: PUSH
19996: LD_VAR 0 10
20000: PPUSH
20001: LD_VAR 0 8
20005: PPUSH
20006: LD_VAR 0 1
20010: PUSH
20011: LD_VAR 0 7
20015: ARRAY
20016: PPUSH
20017: CALL_OW 1
20021: ST_TO_ADDR
// end ;
20022: GO 19935
20024: POP
20025: POP
// array := tmp ;
20026: LD_ADDR_VAR 0 1
20030: PUSH
20031: LD_VAR 0 10
20035: ST_TO_ADDR
// end ;
20036: GO 19917
20038: POP
20039: POP
// result := array ;
20040: LD_ADDR_VAR 0 5
20044: PUSH
20045: LD_VAR 0 1
20049: ST_TO_ADDR
// end ;
20050: LD_VAR 0 5
20054: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20055: LD_INT 0
20057: PPUSH
20058: PPUSH
// result := 0 ;
20059: LD_ADDR_VAR 0 3
20063: PUSH
20064: LD_INT 0
20066: ST_TO_ADDR
// if not array or not value in array then
20067: LD_VAR 0 1
20071: NOT
20072: PUSH
20073: LD_VAR 0 2
20077: PUSH
20078: LD_VAR 0 1
20082: IN
20083: NOT
20084: OR
20085: IFFALSE 20089
// exit ;
20087: GO 20143
// for i = 1 to array do
20089: LD_ADDR_VAR 0 4
20093: PUSH
20094: DOUBLE
20095: LD_INT 1
20097: DEC
20098: ST_TO_ADDR
20099: LD_VAR 0 1
20103: PUSH
20104: FOR_TO
20105: IFFALSE 20141
// if value = array [ i ] then
20107: LD_VAR 0 2
20111: PUSH
20112: LD_VAR 0 1
20116: PUSH
20117: LD_VAR 0 4
20121: ARRAY
20122: EQUAL
20123: IFFALSE 20139
// begin result := i ;
20125: LD_ADDR_VAR 0 3
20129: PUSH
20130: LD_VAR 0 4
20134: ST_TO_ADDR
// exit ;
20135: POP
20136: POP
20137: GO 20143
// end ;
20139: GO 20104
20141: POP
20142: POP
// end ;
20143: LD_VAR 0 3
20147: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20148: LD_INT 0
20150: PPUSH
// vc_chassis := chassis ;
20151: LD_ADDR_OWVAR 37
20155: PUSH
20156: LD_VAR 0 1
20160: ST_TO_ADDR
// vc_engine := engine ;
20161: LD_ADDR_OWVAR 39
20165: PUSH
20166: LD_VAR 0 2
20170: ST_TO_ADDR
// vc_control := control ;
20171: LD_ADDR_OWVAR 38
20175: PUSH
20176: LD_VAR 0 3
20180: ST_TO_ADDR
// vc_weapon := weapon ;
20181: LD_ADDR_OWVAR 40
20185: PUSH
20186: LD_VAR 0 4
20190: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20191: LD_ADDR_OWVAR 41
20195: PUSH
20196: LD_VAR 0 5
20200: ST_TO_ADDR
// end ;
20201: LD_VAR 0 6
20205: RET
// export function WantPlant ( unit ) ; var task ; begin
20206: LD_INT 0
20208: PPUSH
20209: PPUSH
// result := false ;
20210: LD_ADDR_VAR 0 2
20214: PUSH
20215: LD_INT 0
20217: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20218: LD_ADDR_VAR 0 3
20222: PUSH
20223: LD_VAR 0 1
20227: PPUSH
20228: CALL_OW 437
20232: ST_TO_ADDR
// if task then
20233: LD_VAR 0 3
20237: IFFALSE 20265
// if task [ 1 ] [ 1 ] = p then
20239: LD_VAR 0 3
20243: PUSH
20244: LD_INT 1
20246: ARRAY
20247: PUSH
20248: LD_INT 1
20250: ARRAY
20251: PUSH
20252: LD_STRING p
20254: EQUAL
20255: IFFALSE 20265
// result := true ;
20257: LD_ADDR_VAR 0 2
20261: PUSH
20262: LD_INT 1
20264: ST_TO_ADDR
// end ;
20265: LD_VAR 0 2
20269: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20270: LD_INT 0
20272: PPUSH
20273: PPUSH
20274: PPUSH
20275: PPUSH
// if pos < 1 then
20276: LD_VAR 0 2
20280: PUSH
20281: LD_INT 1
20283: LESS
20284: IFFALSE 20288
// exit ;
20286: GO 20591
// if pos = 1 then
20288: LD_VAR 0 2
20292: PUSH
20293: LD_INT 1
20295: EQUAL
20296: IFFALSE 20329
// result := Replace ( arr , pos [ 1 ] , value ) else
20298: LD_ADDR_VAR 0 4
20302: PUSH
20303: LD_VAR 0 1
20307: PPUSH
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 3
20321: PPUSH
20322: CALL_OW 1
20326: ST_TO_ADDR
20327: GO 20591
// begin tmp := arr ;
20329: LD_ADDR_VAR 0 6
20333: PUSH
20334: LD_VAR 0 1
20338: ST_TO_ADDR
// s_arr := [ tmp ] ;
20339: LD_ADDR_VAR 0 7
20343: PUSH
20344: LD_VAR 0 6
20348: PUSH
20349: EMPTY
20350: LIST
20351: ST_TO_ADDR
// for i = 1 to pos - 1 do
20352: LD_ADDR_VAR 0 5
20356: PUSH
20357: DOUBLE
20358: LD_INT 1
20360: DEC
20361: ST_TO_ADDR
20362: LD_VAR 0 2
20366: PUSH
20367: LD_INT 1
20369: MINUS
20370: PUSH
20371: FOR_TO
20372: IFFALSE 20417
// begin tmp := tmp [ pos [ i ] ] ;
20374: LD_ADDR_VAR 0 6
20378: PUSH
20379: LD_VAR 0 6
20383: PUSH
20384: LD_VAR 0 2
20388: PUSH
20389: LD_VAR 0 5
20393: ARRAY
20394: ARRAY
20395: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20396: LD_ADDR_VAR 0 7
20400: PUSH
20401: LD_VAR 0 7
20405: PUSH
20406: LD_VAR 0 6
20410: PUSH
20411: EMPTY
20412: LIST
20413: ADD
20414: ST_TO_ADDR
// end ;
20415: GO 20371
20417: POP
20418: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20419: LD_ADDR_VAR 0 6
20423: PUSH
20424: LD_VAR 0 6
20428: PPUSH
20429: LD_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: ARRAY
20439: PPUSH
20440: LD_VAR 0 3
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20450: LD_ADDR_VAR 0 7
20454: PUSH
20455: LD_VAR 0 7
20459: PPUSH
20460: LD_VAR 0 7
20464: PPUSH
20465: LD_VAR 0 6
20469: PPUSH
20470: CALL_OW 1
20474: ST_TO_ADDR
// for i = s_arr downto 2 do
20475: LD_ADDR_VAR 0 5
20479: PUSH
20480: DOUBLE
20481: LD_VAR 0 7
20485: INC
20486: ST_TO_ADDR
20487: LD_INT 2
20489: PUSH
20490: FOR_DOWNTO
20491: IFFALSE 20575
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20493: LD_ADDR_VAR 0 6
20497: PUSH
20498: LD_VAR 0 7
20502: PUSH
20503: LD_VAR 0 5
20507: PUSH
20508: LD_INT 1
20510: MINUS
20511: ARRAY
20512: PPUSH
20513: LD_VAR 0 2
20517: PUSH
20518: LD_VAR 0 5
20522: PUSH
20523: LD_INT 1
20525: MINUS
20526: ARRAY
20527: PPUSH
20528: LD_VAR 0 7
20532: PUSH
20533: LD_VAR 0 5
20537: ARRAY
20538: PPUSH
20539: CALL_OW 1
20543: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20544: LD_ADDR_VAR 0 7
20548: PUSH
20549: LD_VAR 0 7
20553: PPUSH
20554: LD_VAR 0 5
20558: PUSH
20559: LD_INT 1
20561: MINUS
20562: PPUSH
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 1
20572: ST_TO_ADDR
// end ;
20573: GO 20490
20575: POP
20576: POP
// result := s_arr [ 1 ] ;
20577: LD_ADDR_VAR 0 4
20581: PUSH
20582: LD_VAR 0 7
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: ST_TO_ADDR
// end ; end ;
20591: LD_VAR 0 4
20595: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20596: LD_INT 0
20598: PPUSH
20599: PPUSH
// if not list then
20600: LD_VAR 0 1
20604: NOT
20605: IFFALSE 20609
// exit ;
20607: GO 20700
// i := list [ pos1 ] ;
20609: LD_ADDR_VAR 0 5
20613: PUSH
20614: LD_VAR 0 1
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: ST_TO_ADDR
// if not i then
20625: LD_VAR 0 5
20629: NOT
20630: IFFALSE 20634
// exit ;
20632: GO 20700
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20634: LD_ADDR_VAR 0 1
20638: PUSH
20639: LD_VAR 0 1
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: LD_VAR 0 1
20653: PUSH
20654: LD_VAR 0 3
20658: ARRAY
20659: PPUSH
20660: CALL_OW 1
20664: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20665: LD_ADDR_VAR 0 1
20669: PUSH
20670: LD_VAR 0 1
20674: PPUSH
20675: LD_VAR 0 3
20679: PPUSH
20680: LD_VAR 0 5
20684: PPUSH
20685: CALL_OW 1
20689: ST_TO_ADDR
// result := list ;
20690: LD_ADDR_VAR 0 4
20694: PUSH
20695: LD_VAR 0 1
20699: ST_TO_ADDR
// end ;
20700: LD_VAR 0 4
20704: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20705: LD_INT 0
20707: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: LD_VAR 0 1
20717: PPUSH
20718: CALL_OW 250
20722: PPUSH
20723: LD_VAR 0 1
20727: PPUSH
20728: CALL_OW 251
20732: PPUSH
20733: LD_VAR 0 2
20737: PPUSH
20738: LD_VAR 0 3
20742: PPUSH
20743: LD_VAR 0 4
20747: PPUSH
20748: CALL 20758 0 5
20752: ST_TO_ADDR
// end ;
20753: LD_VAR 0 5
20757: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not list then
20764: LD_VAR 0 3
20768: NOT
20769: IFFALSE 20773
// exit ;
20771: GO 21161
// result := [ ] ;
20773: LD_ADDR_VAR 0 6
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// for i in list do
20780: LD_ADDR_VAR 0 7
20784: PUSH
20785: LD_VAR 0 3
20789: PUSH
20790: FOR_IN
20791: IFFALSE 20993
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20793: LD_ADDR_VAR 0 9
20797: PUSH
20798: LD_VAR 0 7
20802: PPUSH
20803: LD_VAR 0 1
20807: PPUSH
20808: LD_VAR 0 2
20812: PPUSH
20813: CALL_OW 297
20817: ST_TO_ADDR
// if not result then
20818: LD_VAR 0 6
20822: NOT
20823: IFFALSE 20849
// result := [ [ i , tmp ] ] else
20825: LD_ADDR_VAR 0 6
20829: PUSH
20830: LD_VAR 0 7
20834: PUSH
20835: LD_VAR 0 9
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: PUSH
20844: EMPTY
20845: LIST
20846: ST_TO_ADDR
20847: GO 20991
// begin if result [ result ] [ 2 ] < tmp then
20849: LD_VAR 0 6
20853: PUSH
20854: LD_VAR 0 6
20858: ARRAY
20859: PUSH
20860: LD_INT 2
20862: ARRAY
20863: PUSH
20864: LD_VAR 0 9
20868: LESS
20869: IFFALSE 20911
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20871: LD_ADDR_VAR 0 6
20875: PUSH
20876: LD_VAR 0 6
20880: PPUSH
20881: LD_VAR 0 6
20885: PUSH
20886: LD_INT 1
20888: PLUS
20889: PPUSH
20890: LD_VAR 0 7
20894: PUSH
20895: LD_VAR 0 9
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PPUSH
20904: CALL_OW 2
20908: ST_TO_ADDR
20909: GO 20991
// for j = 1 to result do
20911: LD_ADDR_VAR 0 8
20915: PUSH
20916: DOUBLE
20917: LD_INT 1
20919: DEC
20920: ST_TO_ADDR
20921: LD_VAR 0 6
20925: PUSH
20926: FOR_TO
20927: IFFALSE 20989
// begin if tmp < result [ j ] [ 2 ] then
20929: LD_VAR 0 9
20933: PUSH
20934: LD_VAR 0 6
20938: PUSH
20939: LD_VAR 0 8
20943: ARRAY
20944: PUSH
20945: LD_INT 2
20947: ARRAY
20948: LESS
20949: IFFALSE 20987
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20951: LD_ADDR_VAR 0 6
20955: PUSH
20956: LD_VAR 0 6
20960: PPUSH
20961: LD_VAR 0 8
20965: PPUSH
20966: LD_VAR 0 7
20970: PUSH
20971: LD_VAR 0 9
20975: PUSH
20976: EMPTY
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 2
20984: ST_TO_ADDR
// break ;
20985: GO 20989
// end ; end ;
20987: GO 20926
20989: POP
20990: POP
// end ; end ;
20991: GO 20790
20993: POP
20994: POP
// if result and not asc then
20995: LD_VAR 0 6
20999: PUSH
21000: LD_VAR 0 4
21004: NOT
21005: AND
21006: IFFALSE 21081
// begin tmp := result ;
21008: LD_ADDR_VAR 0 9
21012: PUSH
21013: LD_VAR 0 6
21017: ST_TO_ADDR
// for i = tmp downto 1 do
21018: LD_ADDR_VAR 0 7
21022: PUSH
21023: DOUBLE
21024: LD_VAR 0 9
21028: INC
21029: ST_TO_ADDR
21030: LD_INT 1
21032: PUSH
21033: FOR_DOWNTO
21034: IFFALSE 21079
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21036: LD_ADDR_VAR 0 6
21040: PUSH
21041: LD_VAR 0 6
21045: PPUSH
21046: LD_VAR 0 9
21050: PUSH
21051: LD_VAR 0 7
21055: MINUS
21056: PUSH
21057: LD_INT 1
21059: PLUS
21060: PPUSH
21061: LD_VAR 0 9
21065: PUSH
21066: LD_VAR 0 7
21070: ARRAY
21071: PPUSH
21072: CALL_OW 1
21076: ST_TO_ADDR
21077: GO 21033
21079: POP
21080: POP
// end ; tmp := [ ] ;
21081: LD_ADDR_VAR 0 9
21085: PUSH
21086: EMPTY
21087: ST_TO_ADDR
// if mode then
21088: LD_VAR 0 5
21092: IFFALSE 21161
// begin for i = 1 to result do
21094: LD_ADDR_VAR 0 7
21098: PUSH
21099: DOUBLE
21100: LD_INT 1
21102: DEC
21103: ST_TO_ADDR
21104: LD_VAR 0 6
21108: PUSH
21109: FOR_TO
21110: IFFALSE 21149
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21112: LD_ADDR_VAR 0 9
21116: PUSH
21117: LD_VAR 0 9
21121: PPUSH
21122: LD_VAR 0 7
21126: PPUSH
21127: LD_VAR 0 6
21131: PUSH
21132: LD_VAR 0 7
21136: ARRAY
21137: PUSH
21138: LD_INT 1
21140: ARRAY
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
21147: GO 21109
21149: POP
21150: POP
// result := tmp ;
21151: LD_ADDR_VAR 0 6
21155: PUSH
21156: LD_VAR 0 9
21160: ST_TO_ADDR
// end ; end ;
21161: LD_VAR 0 6
21165: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21166: LD_INT 0
21168: PPUSH
21169: PPUSH
21170: PPUSH
21171: PPUSH
21172: PPUSH
21173: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21174: LD_ADDR_VAR 0 5
21178: PUSH
21179: LD_INT 0
21181: PUSH
21182: LD_INT 0
21184: PUSH
21185: LD_INT 0
21187: PUSH
21188: EMPTY
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: ST_TO_ADDR
// if not x or not y then
21196: LD_VAR 0 2
21200: NOT
21201: PUSH
21202: LD_VAR 0 3
21206: NOT
21207: OR
21208: IFFALSE 21212
// exit ;
21210: GO 22858
// if not range then
21212: LD_VAR 0 4
21216: NOT
21217: IFFALSE 21227
// range := 10 ;
21219: LD_ADDR_VAR 0 4
21223: PUSH
21224: LD_INT 10
21226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21227: LD_ADDR_VAR 0 8
21231: PUSH
21232: LD_INT 81
21234: PUSH
21235: LD_VAR 0 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: LD_INT 92
21246: PUSH
21247: LD_VAR 0 2
21251: PUSH
21252: LD_VAR 0 3
21256: PUSH
21257: LD_VAR 0 4
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 3
21270: PUSH
21271: LD_INT 21
21273: PUSH
21274: LD_INT 3
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: PPUSH
21290: CALL_OW 69
21294: ST_TO_ADDR
// if not tmp then
21295: LD_VAR 0 8
21299: NOT
21300: IFFALSE 21304
// exit ;
21302: GO 22858
// for i in tmp do
21304: LD_ADDR_VAR 0 6
21308: PUSH
21309: LD_VAR 0 8
21313: PUSH
21314: FOR_IN
21315: IFFALSE 22833
// begin points := [ 0 , 0 , 0 ] ;
21317: LD_ADDR_VAR 0 9
21321: PUSH
21322: LD_INT 0
21324: PUSH
21325: LD_INT 0
21327: PUSH
21328: LD_INT 0
21330: PUSH
21331: EMPTY
21332: LIST
21333: LIST
21334: LIST
21335: ST_TO_ADDR
// bpoints := 1 ;
21336: LD_ADDR_VAR 0 10
21340: PUSH
21341: LD_INT 1
21343: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21344: LD_VAR 0 6
21348: PPUSH
21349: CALL_OW 247
21353: PUSH
21354: LD_INT 1
21356: DOUBLE
21357: EQUAL
21358: IFTRUE 21362
21360: GO 21940
21362: POP
// begin if GetClass ( i ) = 1 then
21363: LD_VAR 0 6
21367: PPUSH
21368: CALL_OW 257
21372: PUSH
21373: LD_INT 1
21375: EQUAL
21376: IFFALSE 21397
// points := [ 10 , 5 , 3 ] ;
21378: LD_ADDR_VAR 0 9
21382: PUSH
21383: LD_INT 10
21385: PUSH
21386: LD_INT 5
21388: PUSH
21389: LD_INT 3
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21397: LD_VAR 0 6
21401: PPUSH
21402: CALL_OW 257
21406: PUSH
21407: LD_INT 2
21409: PUSH
21410: LD_INT 3
21412: PUSH
21413: LD_INT 4
21415: PUSH
21416: EMPTY
21417: LIST
21418: LIST
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 3 , 2 , 1 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 3
21430: PUSH
21431: LD_INT 2
21433: PUSH
21434: LD_INT 1
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 257
21451: PUSH
21452: LD_INT 5
21454: EQUAL
21455: IFFALSE 21476
// points := [ 130 , 5 , 2 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 130
21464: PUSH
21465: LD_INT 5
21467: PUSH
21468: LD_INT 2
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 257
21485: PUSH
21486: LD_INT 8
21488: EQUAL
21489: IFFALSE 21510
// points := [ 35 , 35 , 30 ] ;
21491: LD_ADDR_VAR 0 9
21495: PUSH
21496: LD_INT 35
21498: PUSH
21499: LD_INT 35
21501: PUSH
21502: LD_INT 30
21504: PUSH
21505: EMPTY
21506: LIST
21507: LIST
21508: LIST
21509: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21510: LD_VAR 0 6
21514: PPUSH
21515: CALL_OW 257
21519: PUSH
21520: LD_INT 9
21522: EQUAL
21523: IFFALSE 21544
// points := [ 20 , 55 , 40 ] ;
21525: LD_ADDR_VAR 0 9
21529: PUSH
21530: LD_INT 20
21532: PUSH
21533: LD_INT 55
21535: PUSH
21536: LD_INT 40
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: LIST
21543: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 257
21553: PUSH
21554: LD_INT 12
21556: PUSH
21557: LD_INT 16
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: IN
21564: IFFALSE 21585
// points := [ 5 , 3 , 2 ] ;
21566: LD_ADDR_VAR 0 9
21570: PUSH
21571: LD_INT 5
21573: PUSH
21574: LD_INT 3
21576: PUSH
21577: LD_INT 2
21579: PUSH
21580: EMPTY
21581: LIST
21582: LIST
21583: LIST
21584: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21585: LD_VAR 0 6
21589: PPUSH
21590: CALL_OW 257
21594: PUSH
21595: LD_INT 17
21597: EQUAL
21598: IFFALSE 21619
// points := [ 100 , 50 , 75 ] ;
21600: LD_ADDR_VAR 0 9
21604: PUSH
21605: LD_INT 100
21607: PUSH
21608: LD_INT 50
21610: PUSH
21611: LD_INT 75
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: LIST
21618: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21619: LD_VAR 0 6
21623: PPUSH
21624: CALL_OW 257
21628: PUSH
21629: LD_INT 15
21631: EQUAL
21632: IFFALSE 21653
// points := [ 10 , 5 , 3 ] ;
21634: LD_ADDR_VAR 0 9
21638: PUSH
21639: LD_INT 10
21641: PUSH
21642: LD_INT 5
21644: PUSH
21645: LD_INT 3
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21653: LD_VAR 0 6
21657: PPUSH
21658: CALL_OW 257
21662: PUSH
21663: LD_INT 14
21665: EQUAL
21666: IFFALSE 21687
// points := [ 10 , 0 , 0 ] ;
21668: LD_ADDR_VAR 0 9
21672: PUSH
21673: LD_INT 10
21675: PUSH
21676: LD_INT 0
21678: PUSH
21679: LD_INT 0
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: LIST
21686: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21687: LD_VAR 0 6
21691: PPUSH
21692: CALL_OW 257
21696: PUSH
21697: LD_INT 11
21699: EQUAL
21700: IFFALSE 21721
// points := [ 30 , 10 , 5 ] ;
21702: LD_ADDR_VAR 0 9
21706: PUSH
21707: LD_INT 30
21709: PUSH
21710: LD_INT 10
21712: PUSH
21713: LD_INT 5
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: LIST
21720: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21721: LD_VAR 0 1
21725: PPUSH
21726: LD_INT 5
21728: PPUSH
21729: CALL_OW 321
21733: PUSH
21734: LD_INT 2
21736: EQUAL
21737: IFFALSE 21754
// bpoints := bpoints * 1.8 ;
21739: LD_ADDR_VAR 0 10
21743: PUSH
21744: LD_VAR 0 10
21748: PUSH
21749: LD_REAL  1.80000000000000E+0000
21752: MUL
21753: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21754: LD_VAR 0 6
21758: PPUSH
21759: CALL_OW 257
21763: PUSH
21764: LD_INT 1
21766: PUSH
21767: LD_INT 2
21769: PUSH
21770: LD_INT 3
21772: PUSH
21773: LD_INT 4
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: IN
21782: PUSH
21783: LD_VAR 0 1
21787: PPUSH
21788: LD_INT 51
21790: PPUSH
21791: CALL_OW 321
21795: PUSH
21796: LD_INT 2
21798: EQUAL
21799: AND
21800: IFFALSE 21817
// bpoints := bpoints * 1.2 ;
21802: LD_ADDR_VAR 0 10
21806: PUSH
21807: LD_VAR 0 10
21811: PUSH
21812: LD_REAL  1.20000000000000E+0000
21815: MUL
21816: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21817: LD_VAR 0 6
21821: PPUSH
21822: CALL_OW 257
21826: PUSH
21827: LD_INT 5
21829: PUSH
21830: LD_INT 7
21832: PUSH
21833: LD_INT 9
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: LIST
21840: IN
21841: PUSH
21842: LD_VAR 0 1
21846: PPUSH
21847: LD_INT 52
21849: PPUSH
21850: CALL_OW 321
21854: PUSH
21855: LD_INT 2
21857: EQUAL
21858: AND
21859: IFFALSE 21876
// bpoints := bpoints * 1.5 ;
21861: LD_ADDR_VAR 0 10
21865: PUSH
21866: LD_VAR 0 10
21870: PUSH
21871: LD_REAL  1.50000000000000E+0000
21874: MUL
21875: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21876: LD_VAR 0 1
21880: PPUSH
21881: LD_INT 66
21883: PPUSH
21884: CALL_OW 321
21888: PUSH
21889: LD_INT 2
21891: EQUAL
21892: IFFALSE 21909
// bpoints := bpoints * 1.1 ;
21894: LD_ADDR_VAR 0 10
21898: PUSH
21899: LD_VAR 0 10
21903: PUSH
21904: LD_REAL  1.10000000000000E+0000
21907: MUL
21908: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21909: LD_ADDR_VAR 0 10
21913: PUSH
21914: LD_VAR 0 10
21918: PUSH
21919: LD_VAR 0 6
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 259
21931: PUSH
21932: LD_REAL  1.15000000000000E+0000
21935: MUL
21936: MUL
21937: ST_TO_ADDR
// end ; unit_vehicle :
21938: GO 22762
21940: LD_INT 2
21942: DOUBLE
21943: EQUAL
21944: IFTRUE 21948
21946: GO 22750
21948: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21949: LD_VAR 0 6
21953: PPUSH
21954: CALL_OW 264
21958: PUSH
21959: LD_INT 2
21961: PUSH
21962: LD_INT 42
21964: PUSH
21965: LD_INT 24
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: LIST
21972: IN
21973: IFFALSE 21994
// points := [ 25 , 5 , 3 ] ;
21975: LD_ADDR_VAR 0 9
21979: PUSH
21980: LD_INT 25
21982: PUSH
21983: LD_INT 5
21985: PUSH
21986: LD_INT 3
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: LIST
21993: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21994: LD_VAR 0 6
21998: PPUSH
21999: CALL_OW 264
22003: PUSH
22004: LD_INT 4
22006: PUSH
22007: LD_INT 43
22009: PUSH
22010: LD_INT 25
22012: PUSH
22013: EMPTY
22014: LIST
22015: LIST
22016: LIST
22017: IN
22018: IFFALSE 22039
// points := [ 40 , 15 , 5 ] ;
22020: LD_ADDR_VAR 0 9
22024: PUSH
22025: LD_INT 40
22027: PUSH
22028: LD_INT 15
22030: PUSH
22031: LD_INT 5
22033: PUSH
22034: EMPTY
22035: LIST
22036: LIST
22037: LIST
22038: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22039: LD_VAR 0 6
22043: PPUSH
22044: CALL_OW 264
22048: PUSH
22049: LD_INT 3
22051: PUSH
22052: LD_INT 23
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: IN
22059: IFFALSE 22080
// points := [ 7 , 25 , 8 ] ;
22061: LD_ADDR_VAR 0 9
22065: PUSH
22066: LD_INT 7
22068: PUSH
22069: LD_INT 25
22071: PUSH
22072: LD_INT 8
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: LIST
22079: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22080: LD_VAR 0 6
22084: PPUSH
22085: CALL_OW 264
22089: PUSH
22090: LD_INT 5
22092: PUSH
22093: LD_INT 27
22095: PUSH
22096: LD_INT 44
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: LIST
22103: IN
22104: IFFALSE 22125
// points := [ 14 , 50 , 16 ] ;
22106: LD_ADDR_VAR 0 9
22110: PUSH
22111: LD_INT 14
22113: PUSH
22114: LD_INT 50
22116: PUSH
22117: LD_INT 16
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: LIST
22124: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22125: LD_VAR 0 6
22129: PPUSH
22130: CALL_OW 264
22134: PUSH
22135: LD_INT 6
22137: PUSH
22138: LD_INT 46
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: IN
22145: IFFALSE 22166
// points := [ 32 , 120 , 70 ] ;
22147: LD_ADDR_VAR 0 9
22151: PUSH
22152: LD_INT 32
22154: PUSH
22155: LD_INT 120
22157: PUSH
22158: LD_INT 70
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: LIST
22165: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22166: LD_VAR 0 6
22170: PPUSH
22171: CALL_OW 264
22175: PUSH
22176: LD_INT 7
22178: PUSH
22179: LD_INT 28
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: LIST
22189: IN
22190: IFFALSE 22211
// points := [ 35 , 20 , 45 ] ;
22192: LD_ADDR_VAR 0 9
22196: PUSH
22197: LD_INT 35
22199: PUSH
22200: LD_INT 20
22202: PUSH
22203: LD_INT 45
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22211: LD_VAR 0 6
22215: PPUSH
22216: CALL_OW 264
22220: PUSH
22221: LD_INT 47
22223: PUSH
22224: EMPTY
22225: LIST
22226: IN
22227: IFFALSE 22248
// points := [ 67 , 45 , 75 ] ;
22229: LD_ADDR_VAR 0 9
22233: PUSH
22234: LD_INT 67
22236: PUSH
22237: LD_INT 45
22239: PUSH
22240: LD_INT 75
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: LIST
22247: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22248: LD_VAR 0 6
22252: PPUSH
22253: CALL_OW 264
22257: PUSH
22258: LD_INT 26
22260: PUSH
22261: EMPTY
22262: LIST
22263: IN
22264: IFFALSE 22285
// points := [ 120 , 30 , 80 ] ;
22266: LD_ADDR_VAR 0 9
22270: PUSH
22271: LD_INT 120
22273: PUSH
22274: LD_INT 30
22276: PUSH
22277: LD_INT 80
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: LIST
22284: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22285: LD_VAR 0 6
22289: PPUSH
22290: CALL_OW 264
22294: PUSH
22295: LD_INT 22
22297: PUSH
22298: EMPTY
22299: LIST
22300: IN
22301: IFFALSE 22322
// points := [ 40 , 1 , 1 ] ;
22303: LD_ADDR_VAR 0 9
22307: PUSH
22308: LD_INT 40
22310: PUSH
22311: LD_INT 1
22313: PUSH
22314: LD_INT 1
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: LIST
22321: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22322: LD_VAR 0 6
22326: PPUSH
22327: CALL_OW 264
22331: PUSH
22332: LD_INT 29
22334: PUSH
22335: EMPTY
22336: LIST
22337: IN
22338: IFFALSE 22359
// points := [ 70 , 200 , 400 ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: LD_INT 70
22347: PUSH
22348: LD_INT 200
22350: PUSH
22351: LD_INT 400
22353: PUSH
22354: EMPTY
22355: LIST
22356: LIST
22357: LIST
22358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 53
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: IN
22379: IFFALSE 22400
// points := [ 40 , 10 , 20 ] ;
22381: LD_ADDR_VAR 0 9
22385: PUSH
22386: LD_INT 40
22388: PUSH
22389: LD_INT 10
22391: PUSH
22392: LD_INT 20
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: LIST
22399: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22400: LD_VAR 0 6
22404: PPUSH
22405: CALL_OW 264
22409: PUSH
22410: LD_INT 9
22412: PUSH
22413: EMPTY
22414: LIST
22415: IN
22416: IFFALSE 22437
// points := [ 5 , 70 , 20 ] ;
22418: LD_ADDR_VAR 0 9
22422: PUSH
22423: LD_INT 5
22425: PUSH
22426: LD_INT 70
22428: PUSH
22429: LD_INT 20
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: LIST
22436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22437: LD_VAR 0 6
22441: PPUSH
22442: CALL_OW 264
22446: PUSH
22447: LD_INT 10
22449: PUSH
22450: EMPTY
22451: LIST
22452: IN
22453: IFFALSE 22474
// points := [ 35 , 110 , 70 ] ;
22455: LD_ADDR_VAR 0 9
22459: PUSH
22460: LD_INT 35
22462: PUSH
22463: LD_INT 110
22465: PUSH
22466: LD_INT 70
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: LIST
22473: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22474: LD_VAR 0 6
22478: PPUSH
22479: CALL_OW 265
22483: PUSH
22484: LD_INT 25
22486: EQUAL
22487: IFFALSE 22508
// points := [ 80 , 65 , 100 ] ;
22489: LD_ADDR_VAR 0 9
22493: PUSH
22494: LD_INT 80
22496: PUSH
22497: LD_INT 65
22499: PUSH
22500: LD_INT 100
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: LIST
22507: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22508: LD_VAR 0 6
22512: PPUSH
22513: CALL_OW 263
22517: PUSH
22518: LD_INT 1
22520: EQUAL
22521: IFFALSE 22556
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22523: LD_ADDR_VAR 0 10
22527: PUSH
22528: LD_VAR 0 10
22532: PUSH
22533: LD_VAR 0 6
22537: PPUSH
22538: CALL_OW 311
22542: PPUSH
22543: LD_INT 3
22545: PPUSH
22546: CALL_OW 259
22550: PUSH
22551: LD_INT 4
22553: MUL
22554: MUL
22555: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22556: LD_VAR 0 6
22560: PPUSH
22561: CALL_OW 263
22565: PUSH
22566: LD_INT 2
22568: EQUAL
22569: IFFALSE 22620
// begin j := IsControledBy ( i ) ;
22571: LD_ADDR_VAR 0 7
22575: PUSH
22576: LD_VAR 0 6
22580: PPUSH
22581: CALL_OW 312
22585: ST_TO_ADDR
// if j then
22586: LD_VAR 0 7
22590: IFFALSE 22620
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22592: LD_ADDR_VAR 0 10
22596: PUSH
22597: LD_VAR 0 10
22601: PUSH
22602: LD_VAR 0 7
22606: PPUSH
22607: LD_INT 3
22609: PPUSH
22610: CALL_OW 259
22614: PUSH
22615: LD_INT 3
22617: MUL
22618: MUL
22619: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22620: LD_VAR 0 6
22624: PPUSH
22625: CALL_OW 264
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: LD_INT 6
22635: PUSH
22636: LD_INT 46
22638: PUSH
22639: LD_INT 44
22641: PUSH
22642: LD_INT 47
22644: PUSH
22645: LD_INT 45
22647: PUSH
22648: LD_INT 28
22650: PUSH
22651: LD_INT 7
22653: PUSH
22654: LD_INT 27
22656: PUSH
22657: LD_INT 29
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: LIST
22671: IN
22672: PUSH
22673: LD_VAR 0 1
22677: PPUSH
22678: LD_INT 52
22680: PPUSH
22681: CALL_OW 321
22685: PUSH
22686: LD_INT 2
22688: EQUAL
22689: AND
22690: IFFALSE 22707
// bpoints := bpoints * 1.2 ;
22692: LD_ADDR_VAR 0 10
22696: PUSH
22697: LD_VAR 0 10
22701: PUSH
22702: LD_REAL  1.20000000000000E+0000
22705: MUL
22706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22707: LD_VAR 0 6
22711: PPUSH
22712: CALL_OW 264
22716: PUSH
22717: LD_INT 6
22719: PUSH
22720: LD_INT 46
22722: PUSH
22723: LD_INT 47
22725: PUSH
22726: EMPTY
22727: LIST
22728: LIST
22729: LIST
22730: IN
22731: IFFALSE 22748
// bpoints := bpoints * 1.2 ;
22733: LD_ADDR_VAR 0 10
22737: PUSH
22738: LD_VAR 0 10
22742: PUSH
22743: LD_REAL  1.20000000000000E+0000
22746: MUL
22747: ST_TO_ADDR
// end ; unit_building :
22748: GO 22762
22750: LD_INT 3
22752: DOUBLE
22753: EQUAL
22754: IFTRUE 22758
22756: GO 22761
22758: POP
// ; end ;
22759: GO 22762
22761: POP
// for j = 1 to 3 do
22762: LD_ADDR_VAR 0 7
22766: PUSH
22767: DOUBLE
22768: LD_INT 1
22770: DEC
22771: ST_TO_ADDR
22772: LD_INT 3
22774: PUSH
22775: FOR_TO
22776: IFFALSE 22829
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22778: LD_ADDR_VAR 0 5
22782: PUSH
22783: LD_VAR 0 5
22787: PPUSH
22788: LD_VAR 0 7
22792: PPUSH
22793: LD_VAR 0 5
22797: PUSH
22798: LD_VAR 0 7
22802: ARRAY
22803: PUSH
22804: LD_VAR 0 9
22808: PUSH
22809: LD_VAR 0 7
22813: ARRAY
22814: PUSH
22815: LD_VAR 0 10
22819: MUL
22820: PLUS
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
22827: GO 22775
22829: POP
22830: POP
// end ;
22831: GO 21314
22833: POP
22834: POP
// result := Replace ( result , 4 , tmp ) ;
22835: LD_ADDR_VAR 0 5
22839: PUSH
22840: LD_VAR 0 5
22844: PPUSH
22845: LD_INT 4
22847: PPUSH
22848: LD_VAR 0 8
22852: PPUSH
22853: CALL_OW 1
22857: ST_TO_ADDR
// end ;
22858: LD_VAR 0 5
22862: RET
// export function DangerAtRange ( unit , range ) ; begin
22863: LD_INT 0
22865: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22866: LD_ADDR_VAR 0 3
22870: PUSH
22871: LD_VAR 0 1
22875: PPUSH
22876: CALL_OW 255
22880: PPUSH
22881: LD_VAR 0 1
22885: PPUSH
22886: CALL_OW 250
22890: PPUSH
22891: LD_VAR 0 1
22895: PPUSH
22896: CALL_OW 251
22900: PPUSH
22901: LD_VAR 0 2
22905: PPUSH
22906: CALL 21166 0 4
22910: ST_TO_ADDR
// end ;
22911: LD_VAR 0 3
22915: RET
// export function DangerInArea ( side , area ) ; begin
22916: LD_INT 0
22918: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_VAR 0 2
22928: PPUSH
22929: LD_INT 81
22931: PUSH
22932: LD_VAR 0 1
22936: PUSH
22937: EMPTY
22938: LIST
22939: LIST
22940: PPUSH
22941: CALL_OW 70
22945: ST_TO_ADDR
// end ;
22946: LD_VAR 0 3
22950: RET
// export function IsExtension ( b ) ; begin
22951: LD_INT 0
22953: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22954: LD_ADDR_VAR 0 2
22958: PUSH
22959: LD_VAR 0 1
22963: PUSH
22964: LD_INT 23
22966: PUSH
22967: LD_INT 20
22969: PUSH
22970: LD_INT 22
22972: PUSH
22973: LD_INT 17
22975: PUSH
22976: LD_INT 24
22978: PUSH
22979: LD_INT 21
22981: PUSH
22982: LD_INT 19
22984: PUSH
22985: LD_INT 16
22987: PUSH
22988: LD_INT 25
22990: PUSH
22991: LD_INT 18
22993: PUSH
22994: EMPTY
22995: LIST
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: LIST
23001: LIST
23002: LIST
23003: LIST
23004: LIST
23005: IN
23006: ST_TO_ADDR
// end ;
23007: LD_VAR 0 2
23011: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23012: LD_INT 0
23014: PPUSH
23015: PPUSH
23016: PPUSH
// result := [ ] ;
23017: LD_ADDR_VAR 0 3
23021: PUSH
23022: EMPTY
23023: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23024: LD_ADDR_VAR 0 4
23028: PUSH
23029: LD_VAR 0 2
23033: PPUSH
23034: LD_INT 21
23036: PUSH
23037: LD_INT 3
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PPUSH
23044: CALL_OW 70
23048: ST_TO_ADDR
// if not tmp then
23049: LD_VAR 0 4
23053: NOT
23054: IFFALSE 23058
// exit ;
23056: GO 23116
// for i in tmp do
23058: LD_ADDR_VAR 0 5
23062: PUSH
23063: LD_VAR 0 4
23067: PUSH
23068: FOR_IN
23069: IFFALSE 23104
// if GetBase ( i ) <> base then
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 274
23080: PUSH
23081: LD_VAR 0 1
23085: NONEQUAL
23086: IFFALSE 23102
// ComLinkToBase ( base , i ) ;
23088: LD_VAR 0 1
23092: PPUSH
23093: LD_VAR 0 5
23097: PPUSH
23098: CALL_OW 169
23102: GO 23068
23104: POP
23105: POP
// result := tmp ;
23106: LD_ADDR_VAR 0 3
23110: PUSH
23111: LD_VAR 0 4
23115: ST_TO_ADDR
// end ;
23116: LD_VAR 0 3
23120: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23121: LD_INT 0
23123: PPUSH
23124: PPUSH
// if BuildingStatus ( b ) = bs_build then
23125: LD_VAR 0 2
23129: PPUSH
23130: CALL_OW 461
23134: PUSH
23135: LD_INT 1
23137: EQUAL
23138: IFFALSE 23198
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23140: LD_VAR 0 1
23144: PPUSH
23145: LD_STRING h
23147: PUSH
23148: LD_VAR 0 2
23152: PPUSH
23153: CALL_OW 250
23157: PUSH
23158: LD_VAR 0 2
23162: PPUSH
23163: CALL_OW 251
23167: PUSH
23168: LD_VAR 0 2
23172: PUSH
23173: LD_INT 0
23175: PUSH
23176: LD_INT 0
23178: PUSH
23179: LD_INT 0
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: PPUSH
23194: CALL_OW 446
// end ;
23198: LD_VAR 0 3
23202: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23203: LD_INT 0
23205: PPUSH
23206: PPUSH
23207: PPUSH
23208: PPUSH
23209: PPUSH
23210: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23211: LD_VAR 0 1
23215: NOT
23216: PUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: CALL_OW 263
23226: PUSH
23227: LD_INT 2
23229: EQUAL
23230: NOT
23231: OR
23232: IFFALSE 23236
// exit ;
23234: GO 23552
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23236: LD_ADDR_VAR 0 6
23240: PUSH
23241: LD_INT 22
23243: PUSH
23244: LD_VAR 0 1
23248: PPUSH
23249: CALL_OW 255
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: LD_INT 2
23260: PUSH
23261: LD_INT 30
23263: PUSH
23264: LD_INT 36
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: PUSH
23271: LD_INT 34
23273: PUSH
23274: LD_INT 31
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PPUSH
23290: CALL_OW 69
23294: ST_TO_ADDR
// if not tmp then
23295: LD_VAR 0 6
23299: NOT
23300: IFFALSE 23304
// exit ;
23302: GO 23552
// result := [ ] ;
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: EMPTY
23310: ST_TO_ADDR
// for i in tmp do
23311: LD_ADDR_VAR 0 3
23315: PUSH
23316: LD_VAR 0 6
23320: PUSH
23321: FOR_IN
23322: IFFALSE 23393
// begin t := UnitsInside ( i ) ;
23324: LD_ADDR_VAR 0 4
23328: PUSH
23329: LD_VAR 0 3
23333: PPUSH
23334: CALL_OW 313
23338: ST_TO_ADDR
// if t then
23339: LD_VAR 0 4
23343: IFFALSE 23391
// for j in t do
23345: LD_ADDR_VAR 0 7
23349: PUSH
23350: LD_VAR 0 4
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23389
// result := Insert ( result , result + 1 , j ) ;
23358: LD_ADDR_VAR 0 2
23362: PUSH
23363: LD_VAR 0 2
23367: PPUSH
23368: LD_VAR 0 2
23372: PUSH
23373: LD_INT 1
23375: PLUS
23376: PPUSH
23377: LD_VAR 0 7
23381: PPUSH
23382: CALL_OW 2
23386: ST_TO_ADDR
23387: GO 23355
23389: POP
23390: POP
// end ;
23391: GO 23321
23393: POP
23394: POP
// if not result then
23395: LD_VAR 0 2
23399: NOT
23400: IFFALSE 23404
// exit ;
23402: GO 23552
// mech := result [ 1 ] ;
23404: LD_ADDR_VAR 0 5
23408: PUSH
23409: LD_VAR 0 2
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: ST_TO_ADDR
// if result > 1 then
23418: LD_VAR 0 2
23422: PUSH
23423: LD_INT 1
23425: GREATER
23426: IFFALSE 23538
// for i = 2 to result do
23428: LD_ADDR_VAR 0 3
23432: PUSH
23433: DOUBLE
23434: LD_INT 2
23436: DEC
23437: ST_TO_ADDR
23438: LD_VAR 0 2
23442: PUSH
23443: FOR_TO
23444: IFFALSE 23536
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23446: LD_ADDR_VAR 0 4
23450: PUSH
23451: LD_VAR 0 2
23455: PUSH
23456: LD_VAR 0 3
23460: ARRAY
23461: PPUSH
23462: LD_INT 3
23464: PPUSH
23465: CALL_OW 259
23469: PUSH
23470: LD_VAR 0 2
23474: PUSH
23475: LD_VAR 0 3
23479: ARRAY
23480: PPUSH
23481: CALL_OW 432
23485: MINUS
23486: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23487: LD_VAR 0 4
23491: PUSH
23492: LD_VAR 0 5
23496: PPUSH
23497: LD_INT 3
23499: PPUSH
23500: CALL_OW 259
23504: PUSH
23505: LD_VAR 0 5
23509: PPUSH
23510: CALL_OW 432
23514: MINUS
23515: GREATEREQUAL
23516: IFFALSE 23534
// mech := result [ i ] ;
23518: LD_ADDR_VAR 0 5
23522: PUSH
23523: LD_VAR 0 2
23527: PUSH
23528: LD_VAR 0 3
23532: ARRAY
23533: ST_TO_ADDR
// end ;
23534: GO 23443
23536: POP
23537: POP
// ComLinkTo ( vehicle , mech ) ;
23538: LD_VAR 0 1
23542: PPUSH
23543: LD_VAR 0 5
23547: PPUSH
23548: CALL_OW 135
// end ;
23552: LD_VAR 0 2
23556: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23557: LD_INT 0
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
23567: PPUSH
23568: PPUSH
23569: PPUSH
23570: PPUSH
23571: PPUSH
// result := [ ] ;
23572: LD_ADDR_VAR 0 7
23576: PUSH
23577: EMPTY
23578: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23579: LD_VAR 0 1
23583: PPUSH
23584: CALL_OW 266
23588: PUSH
23589: LD_INT 0
23591: PUSH
23592: LD_INT 1
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: IN
23599: NOT
23600: IFFALSE 23604
// exit ;
23602: GO 25235
// if name then
23604: LD_VAR 0 3
23608: IFFALSE 23624
// SetBName ( base_dep , name ) ;
23610: LD_VAR 0 1
23614: PPUSH
23615: LD_VAR 0 3
23619: PPUSH
23620: CALL_OW 500
// base := GetBase ( base_dep ) ;
23624: LD_ADDR_VAR 0 15
23628: PUSH
23629: LD_VAR 0 1
23633: PPUSH
23634: CALL_OW 274
23638: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23639: LD_ADDR_VAR 0 16
23643: PUSH
23644: LD_VAR 0 1
23648: PPUSH
23649: CALL_OW 255
23653: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23654: LD_ADDR_VAR 0 17
23658: PUSH
23659: LD_VAR 0 1
23663: PPUSH
23664: CALL_OW 248
23668: ST_TO_ADDR
// if sources then
23669: LD_VAR 0 5
23673: IFFALSE 23720
// for i = 1 to 3 do
23675: LD_ADDR_VAR 0 8
23679: PUSH
23680: DOUBLE
23681: LD_INT 1
23683: DEC
23684: ST_TO_ADDR
23685: LD_INT 3
23687: PUSH
23688: FOR_TO
23689: IFFALSE 23718
// AddResourceType ( base , i , sources [ i ] ) ;
23691: LD_VAR 0 15
23695: PPUSH
23696: LD_VAR 0 8
23700: PPUSH
23701: LD_VAR 0 5
23705: PUSH
23706: LD_VAR 0 8
23710: ARRAY
23711: PPUSH
23712: CALL_OW 276
23716: GO 23688
23718: POP
23719: POP
// buildings := GetBaseBuildings ( base , area ) ;
23720: LD_ADDR_VAR 0 18
23724: PUSH
23725: LD_VAR 0 15
23729: PPUSH
23730: LD_VAR 0 2
23734: PPUSH
23735: CALL 23012 0 2
23739: ST_TO_ADDR
// InitHc ;
23740: CALL_OW 19
// InitUc ;
23744: CALL_OW 18
// uc_side := side ;
23748: LD_ADDR_OWVAR 20
23752: PUSH
23753: LD_VAR 0 16
23757: ST_TO_ADDR
// uc_nation := nation ;
23758: LD_ADDR_OWVAR 21
23762: PUSH
23763: LD_VAR 0 17
23767: ST_TO_ADDR
// if buildings then
23768: LD_VAR 0 18
23772: IFFALSE 25094
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23774: LD_ADDR_VAR 0 19
23778: PUSH
23779: LD_VAR 0 18
23783: PPUSH
23784: LD_INT 2
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 29
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 30
23799: PUSH
23800: LD_INT 30
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: LIST
23811: PPUSH
23812: CALL_OW 72
23816: ST_TO_ADDR
// if tmp then
23817: LD_VAR 0 19
23821: IFFALSE 23869
// for i in tmp do
23823: LD_ADDR_VAR 0 8
23827: PUSH
23828: LD_VAR 0 19
23832: PUSH
23833: FOR_IN
23834: IFFALSE 23867
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23836: LD_VAR 0 8
23840: PPUSH
23841: CALL_OW 250
23845: PPUSH
23846: LD_VAR 0 8
23850: PPUSH
23851: CALL_OW 251
23855: PPUSH
23856: LD_VAR 0 16
23860: PPUSH
23861: CALL_OW 441
23865: GO 23833
23867: POP
23868: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23869: LD_VAR 0 18
23873: PPUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 30
23879: PUSH
23880: LD_INT 32
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 30
23889: PUSH
23890: LD_INT 33
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 72
23906: IFFALSE 23994
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23908: LD_ADDR_VAR 0 8
23912: PUSH
23913: LD_VAR 0 18
23917: PPUSH
23918: LD_INT 2
23920: PUSH
23921: LD_INT 30
23923: PUSH
23924: LD_INT 32
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PUSH
23931: LD_INT 30
23933: PUSH
23934: LD_INT 33
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: LIST
23945: PPUSH
23946: CALL_OW 72
23950: PUSH
23951: FOR_IN
23952: IFFALSE 23992
// begin if not GetBWeapon ( i ) then
23954: LD_VAR 0 8
23958: PPUSH
23959: CALL_OW 269
23963: NOT
23964: IFFALSE 23990
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23966: LD_VAR 0 8
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 2
23980: PPUSH
23981: CALL 25240 0 2
23985: PPUSH
23986: CALL_OW 431
// end ;
23990: GO 23951
23992: POP
23993: POP
// end ; for i = 1 to personel do
23994: LD_ADDR_VAR 0 8
23998: PUSH
23999: DOUBLE
24000: LD_INT 1
24002: DEC
24003: ST_TO_ADDR
24004: LD_VAR 0 6
24008: PUSH
24009: FOR_TO
24010: IFFALSE 25074
// begin if i > 4 then
24012: LD_VAR 0 8
24016: PUSH
24017: LD_INT 4
24019: GREATER
24020: IFFALSE 24024
// break ;
24022: GO 25074
// case i of 1 :
24024: LD_VAR 0 8
24028: PUSH
24029: LD_INT 1
24031: DOUBLE
24032: EQUAL
24033: IFTRUE 24037
24035: GO 24117
24037: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24038: LD_ADDR_VAR 0 12
24042: PUSH
24043: LD_VAR 0 18
24047: PPUSH
24048: LD_INT 22
24050: PUSH
24051: LD_VAR 0 16
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PUSH
24060: LD_INT 58
24062: PUSH
24063: EMPTY
24064: LIST
24065: PUSH
24066: LD_INT 2
24068: PUSH
24069: LD_INT 30
24071: PUSH
24072: LD_INT 32
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: LD_INT 30
24081: PUSH
24082: LD_INT 4
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PUSH
24089: LD_INT 30
24091: PUSH
24092: LD_INT 5
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: LIST
24103: LIST
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: LIST
24109: PPUSH
24110: CALL_OW 72
24114: ST_TO_ADDR
24115: GO 24339
24117: LD_INT 2
24119: DOUBLE
24120: EQUAL
24121: IFTRUE 24125
24123: GO 24187
24125: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24126: LD_ADDR_VAR 0 12
24130: PUSH
24131: LD_VAR 0 18
24135: PPUSH
24136: LD_INT 22
24138: PUSH
24139: LD_VAR 0 16
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: LD_INT 2
24150: PUSH
24151: LD_INT 30
24153: PUSH
24154: LD_INT 0
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: LD_INT 30
24163: PUSH
24164: LD_INT 1
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: EMPTY
24172: LIST
24173: LIST
24174: LIST
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PPUSH
24180: CALL_OW 72
24184: ST_TO_ADDR
24185: GO 24339
24187: LD_INT 3
24189: DOUBLE
24190: EQUAL
24191: IFTRUE 24195
24193: GO 24257
24195: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24196: LD_ADDR_VAR 0 12
24200: PUSH
24201: LD_VAR 0 18
24205: PPUSH
24206: LD_INT 22
24208: PUSH
24209: LD_VAR 0 16
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: PUSH
24218: LD_INT 2
24220: PUSH
24221: LD_INT 30
24223: PUSH
24224: LD_INT 2
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 30
24233: PUSH
24234: LD_INT 3
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: LIST
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PPUSH
24250: CALL_OW 72
24254: ST_TO_ADDR
24255: GO 24339
24257: LD_INT 4
24259: DOUBLE
24260: EQUAL
24261: IFTRUE 24265
24263: GO 24338
24265: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 18
24275: PPUSH
24276: LD_INT 22
24278: PUSH
24279: LD_VAR 0 16
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 2
24290: PUSH
24291: LD_INT 30
24293: PUSH
24294: LD_INT 6
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: LD_INT 30
24303: PUSH
24304: LD_INT 7
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: PUSH
24311: LD_INT 30
24313: PUSH
24314: LD_INT 8
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PPUSH
24331: CALL_OW 72
24335: ST_TO_ADDR
24336: GO 24339
24338: POP
// if i = 1 then
24339: LD_VAR 0 8
24343: PUSH
24344: LD_INT 1
24346: EQUAL
24347: IFFALSE 24458
// begin tmp := [ ] ;
24349: LD_ADDR_VAR 0 19
24353: PUSH
24354: EMPTY
24355: ST_TO_ADDR
// for j in f do
24356: LD_ADDR_VAR 0 9
24360: PUSH
24361: LD_VAR 0 12
24365: PUSH
24366: FOR_IN
24367: IFFALSE 24440
// if GetBType ( j ) = b_bunker then
24369: LD_VAR 0 9
24373: PPUSH
24374: CALL_OW 266
24378: PUSH
24379: LD_INT 32
24381: EQUAL
24382: IFFALSE 24409
// tmp := Insert ( tmp , 1 , j ) else
24384: LD_ADDR_VAR 0 19
24388: PUSH
24389: LD_VAR 0 19
24393: PPUSH
24394: LD_INT 1
24396: PPUSH
24397: LD_VAR 0 9
24401: PPUSH
24402: CALL_OW 2
24406: ST_TO_ADDR
24407: GO 24438
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24409: LD_ADDR_VAR 0 19
24413: PUSH
24414: LD_VAR 0 19
24418: PPUSH
24419: LD_VAR 0 19
24423: PUSH
24424: LD_INT 1
24426: PLUS
24427: PPUSH
24428: LD_VAR 0 9
24432: PPUSH
24433: CALL_OW 2
24437: ST_TO_ADDR
24438: GO 24366
24440: POP
24441: POP
// if tmp then
24442: LD_VAR 0 19
24446: IFFALSE 24458
// f := tmp ;
24448: LD_ADDR_VAR 0 12
24452: PUSH
24453: LD_VAR 0 19
24457: ST_TO_ADDR
// end ; x := personel [ i ] ;
24458: LD_ADDR_VAR 0 13
24462: PUSH
24463: LD_VAR 0 6
24467: PUSH
24468: LD_VAR 0 8
24472: ARRAY
24473: ST_TO_ADDR
// if x = - 1 then
24474: LD_VAR 0 13
24478: PUSH
24479: LD_INT 1
24481: NEG
24482: EQUAL
24483: IFFALSE 24692
// begin for j in f do
24485: LD_ADDR_VAR 0 9
24489: PUSH
24490: LD_VAR 0 12
24494: PUSH
24495: FOR_IN
24496: IFFALSE 24688
// repeat InitHc ;
24498: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24502: LD_VAR 0 9
24506: PPUSH
24507: CALL_OW 266
24511: PUSH
24512: LD_INT 5
24514: EQUAL
24515: IFFALSE 24585
// begin if UnitsInside ( j ) < 3 then
24517: LD_VAR 0 9
24521: PPUSH
24522: CALL_OW 313
24526: PUSH
24527: LD_INT 3
24529: LESS
24530: IFFALSE 24566
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24532: LD_INT 0
24534: PPUSH
24535: LD_INT 5
24537: PUSH
24538: LD_INT 8
24540: PUSH
24541: LD_INT 9
24543: PUSH
24544: EMPTY
24545: LIST
24546: LIST
24547: LIST
24548: PUSH
24549: LD_VAR 0 17
24553: ARRAY
24554: PPUSH
24555: LD_VAR 0 4
24559: PPUSH
24560: CALL_OW 380
24564: GO 24583
// PrepareHuman ( false , i , skill ) ;
24566: LD_INT 0
24568: PPUSH
24569: LD_VAR 0 8
24573: PPUSH
24574: LD_VAR 0 4
24578: PPUSH
24579: CALL_OW 380
// end else
24583: GO 24602
// PrepareHuman ( false , i , skill ) ;
24585: LD_INT 0
24587: PPUSH
24588: LD_VAR 0 8
24592: PPUSH
24593: LD_VAR 0 4
24597: PPUSH
24598: CALL_OW 380
// un := CreateHuman ;
24602: LD_ADDR_VAR 0 14
24606: PUSH
24607: CALL_OW 44
24611: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24612: LD_ADDR_VAR 0 7
24616: PUSH
24617: LD_VAR 0 7
24621: PPUSH
24622: LD_INT 1
24624: PPUSH
24625: LD_VAR 0 14
24629: PPUSH
24630: CALL_OW 2
24634: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24635: LD_VAR 0 14
24639: PPUSH
24640: LD_VAR 0 9
24644: PPUSH
24645: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24649: LD_VAR 0 9
24653: PPUSH
24654: CALL_OW 313
24658: PUSH
24659: LD_INT 6
24661: EQUAL
24662: PUSH
24663: LD_VAR 0 9
24667: PPUSH
24668: CALL_OW 266
24672: PUSH
24673: LD_INT 32
24675: PUSH
24676: LD_INT 31
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: IN
24683: OR
24684: IFFALSE 24498
24686: GO 24495
24688: POP
24689: POP
// end else
24690: GO 25072
// for j = 1 to x do
24692: LD_ADDR_VAR 0 9
24696: PUSH
24697: DOUBLE
24698: LD_INT 1
24700: DEC
24701: ST_TO_ADDR
24702: LD_VAR 0 13
24706: PUSH
24707: FOR_TO
24708: IFFALSE 25070
// begin InitHc ;
24710: CALL_OW 19
// if not f then
24714: LD_VAR 0 12
24718: NOT
24719: IFFALSE 24808
// begin PrepareHuman ( false , i , skill ) ;
24721: LD_INT 0
24723: PPUSH
24724: LD_VAR 0 8
24728: PPUSH
24729: LD_VAR 0 4
24733: PPUSH
24734: CALL_OW 380
// un := CreateHuman ;
24738: LD_ADDR_VAR 0 14
24742: PUSH
24743: CALL_OW 44
24747: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24748: LD_ADDR_VAR 0 7
24752: PUSH
24753: LD_VAR 0 7
24757: PPUSH
24758: LD_INT 1
24760: PPUSH
24761: LD_VAR 0 14
24765: PPUSH
24766: CALL_OW 2
24770: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24771: LD_VAR 0 14
24775: PPUSH
24776: LD_VAR 0 1
24780: PPUSH
24781: CALL_OW 250
24785: PPUSH
24786: LD_VAR 0 1
24790: PPUSH
24791: CALL_OW 251
24795: PPUSH
24796: LD_INT 10
24798: PPUSH
24799: LD_INT 0
24801: PPUSH
24802: CALL_OW 50
// continue ;
24806: GO 24707
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24808: LD_VAR 0 12
24812: PUSH
24813: LD_INT 1
24815: ARRAY
24816: PPUSH
24817: CALL_OW 313
24821: PUSH
24822: LD_VAR 0 12
24826: PUSH
24827: LD_INT 1
24829: ARRAY
24830: PPUSH
24831: CALL_OW 266
24835: PUSH
24836: LD_INT 32
24838: PUSH
24839: LD_INT 31
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: IN
24846: AND
24847: PUSH
24848: LD_VAR 0 12
24852: PUSH
24853: LD_INT 1
24855: ARRAY
24856: PPUSH
24857: CALL_OW 313
24861: PUSH
24862: LD_INT 6
24864: EQUAL
24865: OR
24866: IFFALSE 24886
// f := Delete ( f , 1 ) ;
24868: LD_ADDR_VAR 0 12
24872: PUSH
24873: LD_VAR 0 12
24877: PPUSH
24878: LD_INT 1
24880: PPUSH
24881: CALL_OW 3
24885: ST_TO_ADDR
// if not f then
24886: LD_VAR 0 12
24890: NOT
24891: IFFALSE 24909
// begin x := x + 2 ;
24893: LD_ADDR_VAR 0 13
24897: PUSH
24898: LD_VAR 0 13
24902: PUSH
24903: LD_INT 2
24905: PLUS
24906: ST_TO_ADDR
// continue ;
24907: GO 24707
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24909: LD_VAR 0 12
24913: PUSH
24914: LD_INT 1
24916: ARRAY
24917: PPUSH
24918: CALL_OW 266
24922: PUSH
24923: LD_INT 5
24925: EQUAL
24926: IFFALSE 25000
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24928: LD_VAR 0 12
24932: PUSH
24933: LD_INT 1
24935: ARRAY
24936: PPUSH
24937: CALL_OW 313
24941: PUSH
24942: LD_INT 3
24944: LESS
24945: IFFALSE 24981
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24947: LD_INT 0
24949: PPUSH
24950: LD_INT 5
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 9
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_VAR 0 17
24968: ARRAY
24969: PPUSH
24970: LD_VAR 0 4
24974: PPUSH
24975: CALL_OW 380
24979: GO 24998
// PrepareHuman ( false , i , skill ) ;
24981: LD_INT 0
24983: PPUSH
24984: LD_VAR 0 8
24988: PPUSH
24989: LD_VAR 0 4
24993: PPUSH
24994: CALL_OW 380
// end else
24998: GO 25017
// PrepareHuman ( false , i , skill ) ;
25000: LD_INT 0
25002: PPUSH
25003: LD_VAR 0 8
25007: PPUSH
25008: LD_VAR 0 4
25012: PPUSH
25013: CALL_OW 380
// un := CreateHuman ;
25017: LD_ADDR_VAR 0 14
25021: PUSH
25022: CALL_OW 44
25026: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25027: LD_ADDR_VAR 0 7
25031: PUSH
25032: LD_VAR 0 7
25036: PPUSH
25037: LD_INT 1
25039: PPUSH
25040: LD_VAR 0 14
25044: PPUSH
25045: CALL_OW 2
25049: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25050: LD_VAR 0 14
25054: PPUSH
25055: LD_VAR 0 12
25059: PUSH
25060: LD_INT 1
25062: ARRAY
25063: PPUSH
25064: CALL_OW 52
// end ;
25068: GO 24707
25070: POP
25071: POP
// end ;
25072: GO 24009
25074: POP
25075: POP
// result := result ^ buildings ;
25076: LD_ADDR_VAR 0 7
25080: PUSH
25081: LD_VAR 0 7
25085: PUSH
25086: LD_VAR 0 18
25090: ADD
25091: ST_TO_ADDR
// end else
25092: GO 25235
// begin for i = 1 to personel do
25094: LD_ADDR_VAR 0 8
25098: PUSH
25099: DOUBLE
25100: LD_INT 1
25102: DEC
25103: ST_TO_ADDR
25104: LD_VAR 0 6
25108: PUSH
25109: FOR_TO
25110: IFFALSE 25233
// begin if i > 4 then
25112: LD_VAR 0 8
25116: PUSH
25117: LD_INT 4
25119: GREATER
25120: IFFALSE 25124
// break ;
25122: GO 25233
// x := personel [ i ] ;
25124: LD_ADDR_VAR 0 13
25128: PUSH
25129: LD_VAR 0 6
25133: PUSH
25134: LD_VAR 0 8
25138: ARRAY
25139: ST_TO_ADDR
// if x = - 1 then
25140: LD_VAR 0 13
25144: PUSH
25145: LD_INT 1
25147: NEG
25148: EQUAL
25149: IFFALSE 25153
// continue ;
25151: GO 25109
// PrepareHuman ( false , i , skill ) ;
25153: LD_INT 0
25155: PPUSH
25156: LD_VAR 0 8
25160: PPUSH
25161: LD_VAR 0 4
25165: PPUSH
25166: CALL_OW 380
// un := CreateHuman ;
25170: LD_ADDR_VAR 0 14
25174: PUSH
25175: CALL_OW 44
25179: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25180: LD_VAR 0 14
25184: PPUSH
25185: LD_VAR 0 1
25189: PPUSH
25190: CALL_OW 250
25194: PPUSH
25195: LD_VAR 0 1
25199: PPUSH
25200: CALL_OW 251
25204: PPUSH
25205: LD_INT 10
25207: PPUSH
25208: LD_INT 0
25210: PPUSH
25211: CALL_OW 50
// result := result ^ un ;
25215: LD_ADDR_VAR 0 7
25219: PUSH
25220: LD_VAR 0 7
25224: PUSH
25225: LD_VAR 0 14
25229: ADD
25230: ST_TO_ADDR
// end ;
25231: GO 25109
25233: POP
25234: POP
// end ; end ;
25235: LD_VAR 0 7
25239: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25240: LD_INT 0
25242: PPUSH
25243: PPUSH
25244: PPUSH
25245: PPUSH
25246: PPUSH
25247: PPUSH
25248: PPUSH
25249: PPUSH
25250: PPUSH
25251: PPUSH
25252: PPUSH
25253: PPUSH
25254: PPUSH
25255: PPUSH
25256: PPUSH
25257: PPUSH
// result := false ;
25258: LD_ADDR_VAR 0 3
25262: PUSH
25263: LD_INT 0
25265: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25266: LD_VAR 0 1
25270: NOT
25271: PUSH
25272: LD_VAR 0 1
25276: PPUSH
25277: CALL_OW 266
25281: PUSH
25282: LD_INT 32
25284: PUSH
25285: LD_INT 33
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: IN
25292: NOT
25293: OR
25294: IFFALSE 25298
// exit ;
25296: GO 26434
// nat := GetNation ( tower ) ;
25298: LD_ADDR_VAR 0 12
25302: PUSH
25303: LD_VAR 0 1
25307: PPUSH
25308: CALL_OW 248
25312: ST_TO_ADDR
// side := GetSide ( tower ) ;
25313: LD_ADDR_VAR 0 16
25317: PUSH
25318: LD_VAR 0 1
25322: PPUSH
25323: CALL_OW 255
25327: ST_TO_ADDR
// x := GetX ( tower ) ;
25328: LD_ADDR_VAR 0 10
25332: PUSH
25333: LD_VAR 0 1
25337: PPUSH
25338: CALL_OW 250
25342: ST_TO_ADDR
// y := GetY ( tower ) ;
25343: LD_ADDR_VAR 0 11
25347: PUSH
25348: LD_VAR 0 1
25352: PPUSH
25353: CALL_OW 251
25357: ST_TO_ADDR
// if not x or not y then
25358: LD_VAR 0 10
25362: NOT
25363: PUSH
25364: LD_VAR 0 11
25368: NOT
25369: OR
25370: IFFALSE 25374
// exit ;
25372: GO 26434
// weapon := 0 ;
25374: LD_ADDR_VAR 0 18
25378: PUSH
25379: LD_INT 0
25381: ST_TO_ADDR
// fac_list := [ ] ;
25382: LD_ADDR_VAR 0 17
25386: PUSH
25387: EMPTY
25388: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25389: LD_ADDR_VAR 0 6
25393: PUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: CALL_OW 274
25403: PPUSH
25404: LD_VAR 0 2
25408: PPUSH
25409: CALL 23012 0 2
25413: PPUSH
25414: LD_INT 30
25416: PUSH
25417: LD_INT 3
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PPUSH
25424: CALL_OW 72
25428: ST_TO_ADDR
// if not factories then
25429: LD_VAR 0 6
25433: NOT
25434: IFFALSE 25438
// exit ;
25436: GO 26434
// for i in factories do
25438: LD_ADDR_VAR 0 8
25442: PUSH
25443: LD_VAR 0 6
25447: PUSH
25448: FOR_IN
25449: IFFALSE 25474
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25451: LD_ADDR_VAR 0 17
25455: PUSH
25456: LD_VAR 0 17
25460: PUSH
25461: LD_VAR 0 8
25465: PPUSH
25466: CALL_OW 478
25470: UNION
25471: ST_TO_ADDR
25472: GO 25448
25474: POP
25475: POP
// if not fac_list then
25476: LD_VAR 0 17
25480: NOT
25481: IFFALSE 25485
// exit ;
25483: GO 26434
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25485: LD_ADDR_VAR 0 5
25489: PUSH
25490: LD_INT 4
25492: PUSH
25493: LD_INT 5
25495: PUSH
25496: LD_INT 9
25498: PUSH
25499: LD_INT 10
25501: PUSH
25502: LD_INT 6
25504: PUSH
25505: LD_INT 7
25507: PUSH
25508: LD_INT 11
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 27
25522: PUSH
25523: LD_INT 28
25525: PUSH
25526: LD_INT 26
25528: PUSH
25529: LD_INT 30
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 43
25540: PUSH
25541: LD_INT 44
25543: PUSH
25544: LD_INT 46
25546: PUSH
25547: LD_INT 45
25549: PUSH
25550: LD_INT 47
25552: PUSH
25553: LD_INT 49
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: LIST
25560: LIST
25561: LIST
25562: LIST
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: PUSH
25569: LD_VAR 0 12
25573: ARRAY
25574: ST_TO_ADDR
// for i in list do
25575: LD_ADDR_VAR 0 8
25579: PUSH
25580: LD_VAR 0 5
25584: PUSH
25585: FOR_IN
25586: IFFALSE 25619
// if not i in fac_list then
25588: LD_VAR 0 8
25592: PUSH
25593: LD_VAR 0 17
25597: IN
25598: NOT
25599: IFFALSE 25617
// list := list diff i ;
25601: LD_ADDR_VAR 0 5
25605: PUSH
25606: LD_VAR 0 5
25610: PUSH
25611: LD_VAR 0 8
25615: DIFF
25616: ST_TO_ADDR
25617: GO 25585
25619: POP
25620: POP
// if not list then
25621: LD_VAR 0 5
25625: NOT
25626: IFFALSE 25630
// exit ;
25628: GO 26434
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25630: LD_VAR 0 12
25634: PUSH
25635: LD_INT 3
25637: EQUAL
25638: PUSH
25639: LD_INT 49
25641: PUSH
25642: LD_VAR 0 5
25646: IN
25647: AND
25648: PUSH
25649: LD_INT 31
25651: PPUSH
25652: LD_VAR 0 16
25656: PPUSH
25657: CALL_OW 321
25661: PUSH
25662: LD_INT 2
25664: EQUAL
25665: AND
25666: IFFALSE 25726
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25668: LD_INT 22
25670: PUSH
25671: LD_VAR 0 16
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: PUSH
25680: LD_INT 35
25682: PUSH
25683: LD_INT 49
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 91
25692: PUSH
25693: LD_VAR 0 1
25697: PUSH
25698: LD_INT 10
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: LIST
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: LIST
25710: PPUSH
25711: CALL_OW 69
25715: NOT
25716: IFFALSE 25726
// weapon := ru_time_lapser ;
25718: LD_ADDR_VAR 0 18
25722: PUSH
25723: LD_INT 49
25725: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25726: LD_VAR 0 12
25730: PUSH
25731: LD_INT 1
25733: PUSH
25734: LD_INT 2
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: IN
25741: PUSH
25742: LD_INT 11
25744: PUSH
25745: LD_VAR 0 5
25749: IN
25750: PUSH
25751: LD_INT 30
25753: PUSH
25754: LD_VAR 0 5
25758: IN
25759: OR
25760: AND
25761: PUSH
25762: LD_INT 6
25764: PPUSH
25765: LD_VAR 0 16
25769: PPUSH
25770: CALL_OW 321
25774: PUSH
25775: LD_INT 2
25777: EQUAL
25778: AND
25779: IFFALSE 25944
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25781: LD_INT 22
25783: PUSH
25784: LD_VAR 0 16
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: PUSH
25796: LD_INT 35
25798: PUSH
25799: LD_INT 11
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 35
25808: PUSH
25809: LD_INT 30
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: LIST
25820: PUSH
25821: LD_INT 91
25823: PUSH
25824: LD_VAR 0 1
25828: PUSH
25829: LD_INT 18
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: LIST
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: LIST
25841: PPUSH
25842: CALL_OW 69
25846: NOT
25847: PUSH
25848: LD_INT 22
25850: PUSH
25851: LD_VAR 0 16
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: LD_INT 30
25865: PUSH
25866: LD_INT 32
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 30
25875: PUSH
25876: LD_INT 33
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 91
25890: PUSH
25891: LD_VAR 0 1
25895: PUSH
25896: LD_INT 12
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: LIST
25908: PUSH
25909: EMPTY
25910: LIST
25911: PPUSH
25912: CALL_OW 69
25916: PUSH
25917: LD_INT 2
25919: GREATER
25920: AND
25921: IFFALSE 25944
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25923: LD_ADDR_VAR 0 18
25927: PUSH
25928: LD_INT 11
25930: PUSH
25931: LD_INT 30
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_VAR 0 12
25942: ARRAY
25943: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25944: LD_VAR 0 18
25948: NOT
25949: PUSH
25950: LD_INT 40
25952: PPUSH
25953: LD_VAR 0 16
25957: PPUSH
25958: CALL_OW 321
25962: PUSH
25963: LD_INT 2
25965: EQUAL
25966: AND
25967: PUSH
25968: LD_INT 7
25970: PUSH
25971: LD_VAR 0 5
25975: IN
25976: PUSH
25977: LD_INT 28
25979: PUSH
25980: LD_VAR 0 5
25984: IN
25985: OR
25986: PUSH
25987: LD_INT 45
25989: PUSH
25990: LD_VAR 0 5
25994: IN
25995: OR
25996: AND
25997: IFFALSE 26251
// begin hex := GetHexInfo ( x , y ) ;
25999: LD_ADDR_VAR 0 4
26003: PUSH
26004: LD_VAR 0 10
26008: PPUSH
26009: LD_VAR 0 11
26013: PPUSH
26014: CALL_OW 546
26018: ST_TO_ADDR
// if hex [ 1 ] then
26019: LD_VAR 0 4
26023: PUSH
26024: LD_INT 1
26026: ARRAY
26027: IFFALSE 26031
// exit ;
26029: GO 26434
// height := hex [ 2 ] ;
26031: LD_ADDR_VAR 0 15
26035: PUSH
26036: LD_VAR 0 4
26040: PUSH
26041: LD_INT 2
26043: ARRAY
26044: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26045: LD_ADDR_VAR 0 14
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 2
26055: PUSH
26056: LD_INT 3
26058: PUSH
26059: LD_INT 5
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: LIST
26066: LIST
26067: ST_TO_ADDR
// for i in tmp do
26068: LD_ADDR_VAR 0 8
26072: PUSH
26073: LD_VAR 0 14
26077: PUSH
26078: FOR_IN
26079: IFFALSE 26249
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26081: LD_ADDR_VAR 0 9
26085: PUSH
26086: LD_VAR 0 10
26090: PPUSH
26091: LD_VAR 0 8
26095: PPUSH
26096: LD_INT 5
26098: PPUSH
26099: CALL_OW 272
26103: PUSH
26104: LD_VAR 0 11
26108: PPUSH
26109: LD_VAR 0 8
26113: PPUSH
26114: LD_INT 5
26116: PPUSH
26117: CALL_OW 273
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26126: LD_VAR 0 9
26130: PUSH
26131: LD_INT 1
26133: ARRAY
26134: PPUSH
26135: LD_VAR 0 9
26139: PUSH
26140: LD_INT 2
26142: ARRAY
26143: PPUSH
26144: CALL_OW 488
26148: IFFALSE 26247
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26150: LD_ADDR_VAR 0 4
26154: PUSH
26155: LD_VAR 0 9
26159: PUSH
26160: LD_INT 1
26162: ARRAY
26163: PPUSH
26164: LD_VAR 0 9
26168: PUSH
26169: LD_INT 2
26171: ARRAY
26172: PPUSH
26173: CALL_OW 546
26177: ST_TO_ADDR
// if hex [ 1 ] then
26178: LD_VAR 0 4
26182: PUSH
26183: LD_INT 1
26185: ARRAY
26186: IFFALSE 26190
// continue ;
26188: GO 26078
// h := hex [ 2 ] ;
26190: LD_ADDR_VAR 0 13
26194: PUSH
26195: LD_VAR 0 4
26199: PUSH
26200: LD_INT 2
26202: ARRAY
26203: ST_TO_ADDR
// if h + 7 < height then
26204: LD_VAR 0 13
26208: PUSH
26209: LD_INT 7
26211: PLUS
26212: PUSH
26213: LD_VAR 0 15
26217: LESS
26218: IFFALSE 26247
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26220: LD_ADDR_VAR 0 18
26224: PUSH
26225: LD_INT 7
26227: PUSH
26228: LD_INT 28
26230: PUSH
26231: LD_INT 45
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: LIST
26238: PUSH
26239: LD_VAR 0 12
26243: ARRAY
26244: ST_TO_ADDR
// break ;
26245: GO 26249
// end ; end ; end ;
26247: GO 26078
26249: POP
26250: POP
// end ; if not weapon then
26251: LD_VAR 0 18
26255: NOT
26256: IFFALSE 26316
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26258: LD_ADDR_VAR 0 5
26262: PUSH
26263: LD_VAR 0 5
26267: PUSH
26268: LD_INT 11
26270: PUSH
26271: LD_INT 30
26273: PUSH
26274: LD_INT 49
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: LIST
26281: DIFF
26282: ST_TO_ADDR
// if not list then
26283: LD_VAR 0 5
26287: NOT
26288: IFFALSE 26292
// exit ;
26290: GO 26434
// weapon := list [ rand ( 1 , list ) ] ;
26292: LD_ADDR_VAR 0 18
26296: PUSH
26297: LD_VAR 0 5
26301: PUSH
26302: LD_INT 1
26304: PPUSH
26305: LD_VAR 0 5
26309: PPUSH
26310: CALL_OW 12
26314: ARRAY
26315: ST_TO_ADDR
// end ; if weapon then
26316: LD_VAR 0 18
26320: IFFALSE 26434
// begin tmp := CostOfWeapon ( weapon ) ;
26322: LD_ADDR_VAR 0 14
26326: PUSH
26327: LD_VAR 0 18
26331: PPUSH
26332: CALL_OW 451
26336: ST_TO_ADDR
// j := GetBase ( tower ) ;
26337: LD_ADDR_VAR 0 9
26341: PUSH
26342: LD_VAR 0 1
26346: PPUSH
26347: CALL_OW 274
26351: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26352: LD_VAR 0 9
26356: PPUSH
26357: LD_INT 1
26359: PPUSH
26360: CALL_OW 275
26364: PUSH
26365: LD_VAR 0 14
26369: PUSH
26370: LD_INT 1
26372: ARRAY
26373: GREATEREQUAL
26374: PUSH
26375: LD_VAR 0 9
26379: PPUSH
26380: LD_INT 2
26382: PPUSH
26383: CALL_OW 275
26387: PUSH
26388: LD_VAR 0 14
26392: PUSH
26393: LD_INT 2
26395: ARRAY
26396: GREATEREQUAL
26397: AND
26398: PUSH
26399: LD_VAR 0 9
26403: PPUSH
26404: LD_INT 3
26406: PPUSH
26407: CALL_OW 275
26411: PUSH
26412: LD_VAR 0 14
26416: PUSH
26417: LD_INT 3
26419: ARRAY
26420: GREATEREQUAL
26421: AND
26422: IFFALSE 26434
// result := weapon ;
26424: LD_ADDR_VAR 0 3
26428: PUSH
26429: LD_VAR 0 18
26433: ST_TO_ADDR
// end ; end ;
26434: LD_VAR 0 3
26438: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26439: LD_INT 0
26441: PPUSH
26442: PPUSH
// result := true ;
26443: LD_ADDR_VAR 0 3
26447: PUSH
26448: LD_INT 1
26450: ST_TO_ADDR
// if array1 = array2 then
26451: LD_VAR 0 1
26455: PUSH
26456: LD_VAR 0 2
26460: EQUAL
26461: IFFALSE 26521
// begin for i = 1 to array1 do
26463: LD_ADDR_VAR 0 4
26467: PUSH
26468: DOUBLE
26469: LD_INT 1
26471: DEC
26472: ST_TO_ADDR
26473: LD_VAR 0 1
26477: PUSH
26478: FOR_TO
26479: IFFALSE 26517
// if array1 [ i ] <> array2 [ i ] then
26481: LD_VAR 0 1
26485: PUSH
26486: LD_VAR 0 4
26490: ARRAY
26491: PUSH
26492: LD_VAR 0 2
26496: PUSH
26497: LD_VAR 0 4
26501: ARRAY
26502: NONEQUAL
26503: IFFALSE 26515
// begin result := false ;
26505: LD_ADDR_VAR 0 3
26509: PUSH
26510: LD_INT 0
26512: ST_TO_ADDR
// break ;
26513: GO 26517
// end ;
26515: GO 26478
26517: POP
26518: POP
// end else
26519: GO 26529
// result := false ;
26521: LD_ADDR_VAR 0 3
26525: PUSH
26526: LD_INT 0
26528: ST_TO_ADDR
// end ;
26529: LD_VAR 0 3
26533: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26534: LD_INT 0
26536: PPUSH
26537: PPUSH
26538: PPUSH
// pom := GetBase ( fac ) ;
26539: LD_ADDR_VAR 0 5
26543: PUSH
26544: LD_VAR 0 1
26548: PPUSH
26549: CALL_OW 274
26553: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26554: LD_ADDR_VAR 0 4
26558: PUSH
26559: LD_VAR 0 2
26563: PUSH
26564: LD_INT 1
26566: ARRAY
26567: PPUSH
26568: LD_VAR 0 2
26572: PUSH
26573: LD_INT 2
26575: ARRAY
26576: PPUSH
26577: LD_VAR 0 2
26581: PUSH
26582: LD_INT 3
26584: ARRAY
26585: PPUSH
26586: LD_VAR 0 2
26590: PUSH
26591: LD_INT 4
26593: ARRAY
26594: PPUSH
26595: CALL_OW 449
26599: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26600: LD_ADDR_VAR 0 3
26604: PUSH
26605: LD_VAR 0 5
26609: PPUSH
26610: LD_INT 1
26612: PPUSH
26613: CALL_OW 275
26617: PUSH
26618: LD_VAR 0 4
26622: PUSH
26623: LD_INT 1
26625: ARRAY
26626: GREATEREQUAL
26627: PUSH
26628: LD_VAR 0 5
26632: PPUSH
26633: LD_INT 2
26635: PPUSH
26636: CALL_OW 275
26640: PUSH
26641: LD_VAR 0 4
26645: PUSH
26646: LD_INT 2
26648: ARRAY
26649: GREATEREQUAL
26650: AND
26651: PUSH
26652: LD_VAR 0 5
26656: PPUSH
26657: LD_INT 3
26659: PPUSH
26660: CALL_OW 275
26664: PUSH
26665: LD_VAR 0 4
26669: PUSH
26670: LD_INT 3
26672: ARRAY
26673: GREATEREQUAL
26674: AND
26675: ST_TO_ADDR
// end ;
26676: LD_VAR 0 3
26680: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26681: LD_INT 0
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
// pom := GetBase ( building ) ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: LD_VAR 0 1
26696: PPUSH
26697: CALL_OW 274
26701: ST_TO_ADDR
// if not pom then
26702: LD_VAR 0 3
26706: NOT
26707: IFFALSE 26711
// exit ;
26709: GO 26881
// btype := GetBType ( building ) ;
26711: LD_ADDR_VAR 0 5
26715: PUSH
26716: LD_VAR 0 1
26720: PPUSH
26721: CALL_OW 266
26725: ST_TO_ADDR
// if btype = b_armoury then
26726: LD_VAR 0 5
26730: PUSH
26731: LD_INT 4
26733: EQUAL
26734: IFFALSE 26744
// btype := b_barracks ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_INT 5
26743: ST_TO_ADDR
// if btype = b_depot then
26744: LD_VAR 0 5
26748: PUSH
26749: LD_INT 0
26751: EQUAL
26752: IFFALSE 26762
// btype := b_warehouse ;
26754: LD_ADDR_VAR 0 5
26758: PUSH
26759: LD_INT 1
26761: ST_TO_ADDR
// if btype = b_workshop then
26762: LD_VAR 0 5
26766: PUSH
26767: LD_INT 2
26769: EQUAL
26770: IFFALSE 26780
// btype := b_factory ;
26772: LD_ADDR_VAR 0 5
26776: PUSH
26777: LD_INT 3
26779: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26780: LD_ADDR_VAR 0 4
26784: PUSH
26785: LD_VAR 0 5
26789: PPUSH
26790: LD_VAR 0 1
26794: PPUSH
26795: CALL_OW 248
26799: PPUSH
26800: CALL_OW 450
26804: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26805: LD_ADDR_VAR 0 2
26809: PUSH
26810: LD_VAR 0 3
26814: PPUSH
26815: LD_INT 1
26817: PPUSH
26818: CALL_OW 275
26822: PUSH
26823: LD_VAR 0 4
26827: PUSH
26828: LD_INT 1
26830: ARRAY
26831: GREATEREQUAL
26832: PUSH
26833: LD_VAR 0 3
26837: PPUSH
26838: LD_INT 2
26840: PPUSH
26841: CALL_OW 275
26845: PUSH
26846: LD_VAR 0 4
26850: PUSH
26851: LD_INT 2
26853: ARRAY
26854: GREATEREQUAL
26855: AND
26856: PUSH
26857: LD_VAR 0 3
26861: PPUSH
26862: LD_INT 3
26864: PPUSH
26865: CALL_OW 275
26869: PUSH
26870: LD_VAR 0 4
26874: PUSH
26875: LD_INT 3
26877: ARRAY
26878: GREATEREQUAL
26879: AND
26880: ST_TO_ADDR
// end ;
26881: LD_VAR 0 2
26885: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26886: LD_INT 0
26888: PPUSH
26889: PPUSH
26890: PPUSH
// pom := GetBase ( building ) ;
26891: LD_ADDR_VAR 0 4
26895: PUSH
26896: LD_VAR 0 1
26900: PPUSH
26901: CALL_OW 274
26905: ST_TO_ADDR
// if not pom then
26906: LD_VAR 0 4
26910: NOT
26911: IFFALSE 26915
// exit ;
26913: GO 27016
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26915: LD_ADDR_VAR 0 5
26919: PUSH
26920: LD_VAR 0 2
26924: PPUSH
26925: LD_VAR 0 1
26929: PPUSH
26930: CALL_OW 248
26934: PPUSH
26935: CALL_OW 450
26939: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26940: LD_ADDR_VAR 0 3
26944: PUSH
26945: LD_VAR 0 4
26949: PPUSH
26950: LD_INT 1
26952: PPUSH
26953: CALL_OW 275
26957: PUSH
26958: LD_VAR 0 5
26962: PUSH
26963: LD_INT 1
26965: ARRAY
26966: GREATEREQUAL
26967: PUSH
26968: LD_VAR 0 4
26972: PPUSH
26973: LD_INT 2
26975: PPUSH
26976: CALL_OW 275
26980: PUSH
26981: LD_VAR 0 5
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: GREATEREQUAL
26990: AND
26991: PUSH
26992: LD_VAR 0 4
26996: PPUSH
26997: LD_INT 3
26999: PPUSH
27000: CALL_OW 275
27004: PUSH
27005: LD_VAR 0 5
27009: PUSH
27010: LD_INT 3
27012: ARRAY
27013: GREATEREQUAL
27014: AND
27015: ST_TO_ADDR
// end ;
27016: LD_VAR 0 3
27020: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27021: LD_INT 0
27023: PPUSH
27024: PPUSH
27025: PPUSH
27026: PPUSH
27027: PPUSH
27028: PPUSH
27029: PPUSH
27030: PPUSH
27031: PPUSH
27032: PPUSH
// result := false ;
27033: LD_ADDR_VAR 0 6
27037: PUSH
27038: LD_INT 0
27040: ST_TO_ADDR
// if not base or not btype or not x or not y then
27041: LD_VAR 0 1
27045: NOT
27046: PUSH
27047: LD_VAR 0 2
27051: NOT
27052: OR
27053: PUSH
27054: LD_VAR 0 3
27058: NOT
27059: OR
27060: PUSH
27061: LD_VAR 0 4
27065: NOT
27066: OR
27067: IFFALSE 27071
// exit ;
27069: GO 27662
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27071: LD_ADDR_VAR 0 12
27075: PUSH
27076: LD_VAR 0 2
27080: PPUSH
27081: LD_VAR 0 3
27085: PPUSH
27086: LD_VAR 0 4
27090: PPUSH
27091: LD_VAR 0 5
27095: PPUSH
27096: LD_VAR 0 1
27100: PUSH
27101: LD_INT 1
27103: ARRAY
27104: PPUSH
27105: CALL_OW 248
27109: PPUSH
27110: LD_INT 0
27112: PPUSH
27113: CALL 28499 0 6
27117: ST_TO_ADDR
// if not hexes then
27118: LD_VAR 0 12
27122: NOT
27123: IFFALSE 27127
// exit ;
27125: GO 27662
// for i = 1 to hexes do
27127: LD_ADDR_VAR 0 7
27131: PUSH
27132: DOUBLE
27133: LD_INT 1
27135: DEC
27136: ST_TO_ADDR
27137: LD_VAR 0 12
27141: PUSH
27142: FOR_TO
27143: IFFALSE 27660
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27145: LD_ADDR_VAR 0 11
27149: PUSH
27150: LD_VAR 0 12
27154: PUSH
27155: LD_VAR 0 7
27159: ARRAY
27160: PUSH
27161: LD_INT 1
27163: ARRAY
27164: PPUSH
27165: LD_VAR 0 12
27169: PUSH
27170: LD_VAR 0 7
27174: ARRAY
27175: PUSH
27176: LD_INT 2
27178: ARRAY
27179: PPUSH
27180: CALL_OW 428
27184: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27185: LD_VAR 0 12
27189: PUSH
27190: LD_VAR 0 7
27194: ARRAY
27195: PUSH
27196: LD_INT 1
27198: ARRAY
27199: PPUSH
27200: LD_VAR 0 12
27204: PUSH
27205: LD_VAR 0 7
27209: ARRAY
27210: PUSH
27211: LD_INT 2
27213: ARRAY
27214: PPUSH
27215: CALL_OW 351
27219: PUSH
27220: LD_VAR 0 12
27224: PUSH
27225: LD_VAR 0 7
27229: ARRAY
27230: PUSH
27231: LD_INT 1
27233: ARRAY
27234: PPUSH
27235: LD_VAR 0 12
27239: PUSH
27240: LD_VAR 0 7
27244: ARRAY
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: PPUSH
27250: CALL_OW 488
27254: NOT
27255: OR
27256: PUSH
27257: LD_VAR 0 11
27261: PPUSH
27262: CALL_OW 247
27266: PUSH
27267: LD_INT 3
27269: EQUAL
27270: OR
27271: IFFALSE 27277
// exit ;
27273: POP
27274: POP
27275: GO 27662
// if not tmp then
27277: LD_VAR 0 11
27281: NOT
27282: IFFALSE 27286
// continue ;
27284: GO 27142
// result := true ;
27286: LD_ADDR_VAR 0 6
27290: PUSH
27291: LD_INT 1
27293: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27294: LD_ADDR_VAR 0 15
27298: PUSH
27299: LD_INT 22
27301: PUSH
27302: LD_VAR 0 11
27306: PPUSH
27307: CALL_OW 255
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 2
27318: PUSH
27319: LD_INT 30
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 30
27331: PUSH
27332: LD_INT 1
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: LIST
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PPUSH
27348: CALL_OW 69
27352: ST_TO_ADDR
// if dep then
27353: LD_VAR 0 15
27357: IFFALSE 27493
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27359: LD_ADDR_VAR 0 14
27363: PUSH
27364: LD_VAR 0 15
27368: PUSH
27369: LD_INT 1
27371: ARRAY
27372: PPUSH
27373: CALL_OW 250
27377: PPUSH
27378: LD_VAR 0 15
27382: PUSH
27383: LD_INT 1
27385: ARRAY
27386: PPUSH
27387: CALL_OW 254
27391: PPUSH
27392: LD_INT 5
27394: PPUSH
27395: CALL_OW 272
27399: PUSH
27400: LD_VAR 0 15
27404: PUSH
27405: LD_INT 1
27407: ARRAY
27408: PPUSH
27409: CALL_OW 251
27413: PPUSH
27414: LD_VAR 0 15
27418: PUSH
27419: LD_INT 1
27421: ARRAY
27422: PPUSH
27423: CALL_OW 254
27427: PPUSH
27428: LD_INT 5
27430: PPUSH
27431: CALL_OW 273
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27440: LD_VAR 0 14
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PPUSH
27449: LD_VAR 0 14
27453: PUSH
27454: LD_INT 2
27456: ARRAY
27457: PPUSH
27458: CALL_OW 488
27462: IFFALSE 27493
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27464: LD_VAR 0 11
27468: PPUSH
27469: LD_VAR 0 14
27473: PUSH
27474: LD_INT 1
27476: ARRAY
27477: PPUSH
27478: LD_VAR 0 14
27482: PUSH
27483: LD_INT 2
27485: ARRAY
27486: PPUSH
27487: CALL_OW 111
// continue ;
27491: GO 27142
// end ; end ; r := GetDir ( tmp ) ;
27493: LD_ADDR_VAR 0 13
27497: PUSH
27498: LD_VAR 0 11
27502: PPUSH
27503: CALL_OW 254
27507: ST_TO_ADDR
// if r = 5 then
27508: LD_VAR 0 13
27512: PUSH
27513: LD_INT 5
27515: EQUAL
27516: IFFALSE 27526
// r := 0 ;
27518: LD_ADDR_VAR 0 13
27522: PUSH
27523: LD_INT 0
27525: ST_TO_ADDR
// for j = r to 5 do
27526: LD_ADDR_VAR 0 8
27530: PUSH
27531: DOUBLE
27532: LD_VAR 0 13
27536: DEC
27537: ST_TO_ADDR
27538: LD_INT 5
27540: PUSH
27541: FOR_TO
27542: IFFALSE 27656
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27544: LD_ADDR_VAR 0 9
27548: PUSH
27549: LD_VAR 0 11
27553: PPUSH
27554: CALL_OW 250
27558: PPUSH
27559: LD_VAR 0 8
27563: PPUSH
27564: LD_INT 2
27566: PPUSH
27567: CALL_OW 272
27571: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27572: LD_ADDR_VAR 0 10
27576: PUSH
27577: LD_VAR 0 11
27581: PPUSH
27582: CALL_OW 251
27586: PPUSH
27587: LD_VAR 0 8
27591: PPUSH
27592: LD_INT 2
27594: PPUSH
27595: CALL_OW 273
27599: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27600: LD_VAR 0 9
27604: PPUSH
27605: LD_VAR 0 10
27609: PPUSH
27610: CALL_OW 488
27614: PUSH
27615: LD_VAR 0 9
27619: PPUSH
27620: LD_VAR 0 10
27624: PPUSH
27625: CALL_OW 428
27629: NOT
27630: AND
27631: IFFALSE 27654
// begin ComMoveXY ( tmp , _x , _y ) ;
27633: LD_VAR 0 11
27637: PPUSH
27638: LD_VAR 0 9
27642: PPUSH
27643: LD_VAR 0 10
27647: PPUSH
27648: CALL_OW 111
// break ;
27652: GO 27656
// end ; end ;
27654: GO 27541
27656: POP
27657: POP
// end ;
27658: GO 27142
27660: POP
27661: POP
// end ;
27662: LD_VAR 0 6
27666: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27667: LD_INT 0
27669: PPUSH
27670: PPUSH
27671: PPUSH
27672: PPUSH
27673: PPUSH
27674: PPUSH
27675: PPUSH
27676: PPUSH
27677: PPUSH
27678: PPUSH
// result := false ;
27679: LD_ADDR_VAR 0 6
27683: PUSH
27684: LD_INT 0
27686: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27687: LD_VAR 0 1
27691: NOT
27692: PUSH
27693: LD_VAR 0 1
27697: PPUSH
27698: CALL_OW 266
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: LD_INT 1
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: IN
27713: NOT
27714: OR
27715: PUSH
27716: LD_VAR 0 2
27720: NOT
27721: OR
27722: PUSH
27723: LD_VAR 0 5
27727: PUSH
27728: LD_INT 0
27730: PUSH
27731: LD_INT 1
27733: PUSH
27734: LD_INT 2
27736: PUSH
27737: LD_INT 3
27739: PUSH
27740: LD_INT 4
27742: PUSH
27743: LD_INT 5
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: IN
27754: NOT
27755: OR
27756: PUSH
27757: LD_VAR 0 3
27761: PPUSH
27762: LD_VAR 0 4
27766: PPUSH
27767: CALL_OW 488
27771: NOT
27772: OR
27773: IFFALSE 27777
// exit ;
27775: GO 28494
// pom := GetBase ( bdepot ) ;
27777: LD_ADDR_VAR 0 10
27781: PUSH
27782: LD_VAR 0 1
27786: PPUSH
27787: CALL_OW 274
27791: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
27792: LD_ADDR_VAR 0 11
27796: PUSH
27797: LD_VAR 0 2
27801: PPUSH
27802: LD_VAR 0 1
27806: PPUSH
27807: CALL_OW 248
27811: PPUSH
27812: CALL_OW 450
27816: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27817: LD_VAR 0 10
27821: PPUSH
27822: LD_INT 1
27824: PPUSH
27825: CALL_OW 275
27829: PUSH
27830: LD_VAR 0 11
27834: PUSH
27835: LD_INT 1
27837: ARRAY
27838: GREATEREQUAL
27839: PUSH
27840: LD_VAR 0 10
27844: PPUSH
27845: LD_INT 2
27847: PPUSH
27848: CALL_OW 275
27852: PUSH
27853: LD_VAR 0 11
27857: PUSH
27858: LD_INT 2
27860: ARRAY
27861: GREATEREQUAL
27862: AND
27863: PUSH
27864: LD_VAR 0 10
27868: PPUSH
27869: LD_INT 3
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_VAR 0 11
27881: PUSH
27882: LD_INT 3
27884: ARRAY
27885: GREATEREQUAL
27886: AND
27887: NOT
27888: IFFALSE 27892
// exit ;
27890: GO 28494
// if GetBType ( bdepot ) = b_depot then
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 266
27901: PUSH
27902: LD_INT 0
27904: EQUAL
27905: IFFALSE 27917
// dist := 28 else
27907: LD_ADDR_VAR 0 14
27911: PUSH
27912: LD_INT 28
27914: ST_TO_ADDR
27915: GO 27925
// dist := 36 ;
27917: LD_ADDR_VAR 0 14
27921: PUSH
27922: LD_INT 36
27924: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
27925: LD_VAR 0 1
27929: PPUSH
27930: LD_VAR 0 3
27934: PPUSH
27935: LD_VAR 0 4
27939: PPUSH
27940: CALL_OW 297
27944: PUSH
27945: LD_VAR 0 14
27949: GREATER
27950: IFFALSE 27954
// exit ;
27952: GO 28494
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
27954: LD_ADDR_VAR 0 12
27958: PUSH
27959: LD_VAR 0 2
27963: PPUSH
27964: LD_VAR 0 3
27968: PPUSH
27969: LD_VAR 0 4
27973: PPUSH
27974: LD_VAR 0 5
27978: PPUSH
27979: LD_VAR 0 1
27983: PPUSH
27984: CALL_OW 248
27988: PPUSH
27989: LD_INT 0
27991: PPUSH
27992: CALL 28499 0 6
27996: ST_TO_ADDR
// if not hexes then
27997: LD_VAR 0 12
28001: NOT
28002: IFFALSE 28006
// exit ;
28004: GO 28494
// hex := GetHexInfo ( x , y ) ;
28006: LD_ADDR_VAR 0 15
28010: PUSH
28011: LD_VAR 0 3
28015: PPUSH
28016: LD_VAR 0 4
28020: PPUSH
28021: CALL_OW 546
28025: ST_TO_ADDR
// if hex [ 1 ] then
28026: LD_VAR 0 15
28030: PUSH
28031: LD_INT 1
28033: ARRAY
28034: IFFALSE 28038
// exit ;
28036: GO 28494
// height := hex [ 2 ] ;
28038: LD_ADDR_VAR 0 13
28042: PUSH
28043: LD_VAR 0 15
28047: PUSH
28048: LD_INT 2
28050: ARRAY
28051: ST_TO_ADDR
// for i = 1 to hexes do
28052: LD_ADDR_VAR 0 7
28056: PUSH
28057: DOUBLE
28058: LD_INT 1
28060: DEC
28061: ST_TO_ADDR
28062: LD_VAR 0 12
28066: PUSH
28067: FOR_TO
28068: IFFALSE 28398
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28070: LD_VAR 0 12
28074: PUSH
28075: LD_VAR 0 7
28079: ARRAY
28080: PUSH
28081: LD_INT 1
28083: ARRAY
28084: PPUSH
28085: LD_VAR 0 12
28089: PUSH
28090: LD_VAR 0 7
28094: ARRAY
28095: PUSH
28096: LD_INT 2
28098: ARRAY
28099: PPUSH
28100: CALL_OW 488
28104: NOT
28105: PUSH
28106: LD_VAR 0 12
28110: PUSH
28111: LD_VAR 0 7
28115: ARRAY
28116: PUSH
28117: LD_INT 1
28119: ARRAY
28120: PPUSH
28121: LD_VAR 0 12
28125: PUSH
28126: LD_VAR 0 7
28130: ARRAY
28131: PUSH
28132: LD_INT 2
28134: ARRAY
28135: PPUSH
28136: CALL_OW 428
28140: PUSH
28141: LD_INT 0
28143: GREATER
28144: OR
28145: PUSH
28146: LD_VAR 0 12
28150: PUSH
28151: LD_VAR 0 7
28155: ARRAY
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: LD_VAR 0 12
28165: PUSH
28166: LD_VAR 0 7
28170: ARRAY
28171: PUSH
28172: LD_INT 2
28174: ARRAY
28175: PPUSH
28176: CALL_OW 351
28180: OR
28181: IFFALSE 28187
// exit ;
28183: POP
28184: POP
28185: GO 28494
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28187: LD_ADDR_VAR 0 8
28191: PUSH
28192: LD_VAR 0 12
28196: PUSH
28197: LD_VAR 0 7
28201: ARRAY
28202: PUSH
28203: LD_INT 1
28205: ARRAY
28206: PPUSH
28207: LD_VAR 0 12
28211: PUSH
28212: LD_VAR 0 7
28216: ARRAY
28217: PUSH
28218: LD_INT 2
28220: ARRAY
28221: PPUSH
28222: CALL_OW 546
28226: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28227: LD_VAR 0 8
28231: PUSH
28232: LD_INT 1
28234: ARRAY
28235: PUSH
28236: LD_VAR 0 8
28240: PUSH
28241: LD_INT 2
28243: ARRAY
28244: PUSH
28245: LD_VAR 0 13
28249: PUSH
28250: LD_INT 2
28252: PLUS
28253: GREATER
28254: OR
28255: PUSH
28256: LD_VAR 0 8
28260: PUSH
28261: LD_INT 2
28263: ARRAY
28264: PUSH
28265: LD_VAR 0 13
28269: PUSH
28270: LD_INT 2
28272: MINUS
28273: LESS
28274: OR
28275: PUSH
28276: LD_VAR 0 8
28280: PUSH
28281: LD_INT 3
28283: ARRAY
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: LD_INT 8
28290: PUSH
28291: LD_INT 9
28293: PUSH
28294: LD_INT 10
28296: PUSH
28297: LD_INT 11
28299: PUSH
28300: LD_INT 12
28302: PUSH
28303: LD_INT 13
28305: PUSH
28306: LD_INT 16
28308: PUSH
28309: LD_INT 17
28311: PUSH
28312: LD_INT 18
28314: PUSH
28315: LD_INT 19
28317: PUSH
28318: LD_INT 20
28320: PUSH
28321: LD_INT 21
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: IN
28339: NOT
28340: OR
28341: PUSH
28342: LD_VAR 0 8
28346: PUSH
28347: LD_INT 5
28349: ARRAY
28350: NOT
28351: OR
28352: PUSH
28353: LD_VAR 0 8
28357: PUSH
28358: LD_INT 6
28360: ARRAY
28361: PUSH
28362: LD_INT 1
28364: PUSH
28365: LD_INT 2
28367: PUSH
28368: LD_INT 7
28370: PUSH
28371: LD_INT 9
28373: PUSH
28374: LD_INT 10
28376: PUSH
28377: LD_INT 11
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: IN
28388: NOT
28389: OR
28390: IFFALSE 28396
// exit ;
28392: POP
28393: POP
28394: GO 28494
// end ;
28396: GO 28067
28398: POP
28399: POP
// side := GetSide ( bdepot ) ;
28400: LD_ADDR_VAR 0 9
28404: PUSH
28405: LD_VAR 0 1
28409: PPUSH
28410: CALL_OW 255
28414: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28415: LD_VAR 0 9
28419: PPUSH
28420: LD_VAR 0 3
28424: PPUSH
28425: LD_VAR 0 4
28429: PPUSH
28430: LD_INT 20
28432: PPUSH
28433: CALL 21166 0 4
28437: PUSH
28438: LD_INT 4
28440: ARRAY
28441: IFFALSE 28445
// exit ;
28443: GO 28494
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28445: LD_VAR 0 2
28449: PUSH
28450: LD_INT 29
28452: PUSH
28453: LD_INT 30
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: IN
28460: PUSH
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_VAR 0 4
28470: PPUSH
28471: LD_VAR 0 9
28475: PPUSH
28476: CALL_OW 440
28480: NOT
28481: AND
28482: IFFALSE 28486
// exit ;
28484: GO 28494
// result := true ;
28486: LD_ADDR_VAR 0 6
28490: PUSH
28491: LD_INT 1
28493: ST_TO_ADDR
// end ;
28494: LD_VAR 0 6
28498: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28499: LD_INT 0
28501: PPUSH
28502: PPUSH
28503: PPUSH
28504: PPUSH
28505: PPUSH
28506: PPUSH
28507: PPUSH
28508: PPUSH
28509: PPUSH
28510: PPUSH
28511: PPUSH
28512: PPUSH
28513: PPUSH
28514: PPUSH
28515: PPUSH
28516: PPUSH
28517: PPUSH
28518: PPUSH
28519: PPUSH
28520: PPUSH
28521: PPUSH
28522: PPUSH
28523: PPUSH
28524: PPUSH
28525: PPUSH
28526: PPUSH
28527: PPUSH
28528: PPUSH
28529: PPUSH
28530: PPUSH
28531: PPUSH
28532: PPUSH
28533: PPUSH
28534: PPUSH
28535: PPUSH
28536: PPUSH
28537: PPUSH
28538: PPUSH
28539: PPUSH
28540: PPUSH
28541: PPUSH
28542: PPUSH
28543: PPUSH
28544: PPUSH
28545: PPUSH
28546: PPUSH
28547: PPUSH
28548: PPUSH
28549: PPUSH
28550: PPUSH
28551: PPUSH
28552: PPUSH
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
// result = [ ] ;
28559: LD_ADDR_VAR 0 7
28563: PUSH
28564: EMPTY
28565: ST_TO_ADDR
// temp_list = [ ] ;
28566: LD_ADDR_VAR 0 9
28570: PUSH
28571: EMPTY
28572: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28573: LD_VAR 0 4
28577: PUSH
28578: LD_INT 0
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 2
28586: PUSH
28587: LD_INT 3
28589: PUSH
28590: LD_INT 4
28592: PUSH
28593: LD_INT 5
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: IN
28604: NOT
28605: PUSH
28606: LD_VAR 0 1
28610: PUSH
28611: LD_INT 0
28613: PUSH
28614: LD_INT 1
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: IN
28621: PUSH
28622: LD_VAR 0 5
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: LD_INT 2
28632: PUSH
28633: LD_INT 3
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: LIST
28640: IN
28641: NOT
28642: AND
28643: OR
28644: IFFALSE 28648
// exit ;
28646: GO 47033
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28648: LD_VAR 0 1
28652: PUSH
28653: LD_INT 6
28655: PUSH
28656: LD_INT 7
28658: PUSH
28659: LD_INT 8
28661: PUSH
28662: LD_INT 13
28664: PUSH
28665: LD_INT 12
28667: PUSH
28668: LD_INT 15
28670: PUSH
28671: LD_INT 11
28673: PUSH
28674: LD_INT 14
28676: PUSH
28677: LD_INT 10
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: IN
28691: IFFALSE 28701
// btype = b_lab ;
28693: LD_ADDR_VAR 0 1
28697: PUSH
28698: LD_INT 6
28700: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28701: LD_VAR 0 6
28705: PUSH
28706: LD_INT 0
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: LD_INT 2
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: LIST
28719: IN
28720: NOT
28721: PUSH
28722: LD_VAR 0 1
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: LD_INT 1
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: LD_INT 3
28738: PUSH
28739: LD_INT 6
28741: PUSH
28742: LD_INT 36
28744: PUSH
28745: LD_INT 4
28747: PUSH
28748: LD_INT 5
28750: PUSH
28751: LD_INT 31
28753: PUSH
28754: LD_INT 32
28756: PUSH
28757: LD_INT 33
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: IN
28773: NOT
28774: PUSH
28775: LD_VAR 0 6
28779: PUSH
28780: LD_INT 1
28782: EQUAL
28783: AND
28784: OR
28785: PUSH
28786: LD_VAR 0 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: LD_INT 3
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: IN
28801: NOT
28802: PUSH
28803: LD_VAR 0 6
28807: PUSH
28808: LD_INT 2
28810: EQUAL
28811: AND
28812: OR
28813: IFFALSE 28823
// mode = 0 ;
28815: LD_ADDR_VAR 0 6
28819: PUSH
28820: LD_INT 0
28822: ST_TO_ADDR
// case mode of 0 :
28823: LD_VAR 0 6
28827: PUSH
28828: LD_INT 0
28830: DOUBLE
28831: EQUAL
28832: IFTRUE 28836
28834: GO 40289
28836: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28837: LD_ADDR_VAR 0 11
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: LD_INT 0
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 0
28854: PUSH
28855: LD_INT 1
28857: NEG
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: LD_INT 0
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 1
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 0
28885: PUSH
28886: LD_INT 1
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: LD_INT 0
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 1
28906: NEG
28907: PUSH
28908: LD_INT 1
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 1
28918: NEG
28919: PUSH
28920: LD_INT 2
28922: NEG
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 0
28930: PUSH
28931: LD_INT 2
28933: NEG
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: PUSH
28939: LD_INT 1
28941: PUSH
28942: LD_INT 1
28944: NEG
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 1
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: LD_INT 3
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 0
28993: PUSH
28994: LD_INT 3
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 1
29003: NEG
29004: PUSH
29005: LD_INT 2
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29030: LD_ADDR_VAR 0 12
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: LD_INT 0
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: LD_INT 1
29050: NEG
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 1
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 0
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: NEG
29089: PUSH
29090: LD_INT 0
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 1
29099: NEG
29100: PUSH
29101: LD_INT 1
29103: NEG
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 2
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 2
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 1
29142: NEG
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 2
29153: NEG
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 2
29164: NEG
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: NEG
29177: PUSH
29178: LD_INT 1
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 3
29187: NEG
29188: PUSH
29189: LD_INT 0
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 3
29198: NEG
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29226: LD_ADDR_VAR 0 13
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 0
29243: PUSH
29244: LD_INT 1
29246: NEG
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: LD_INT 0
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 1
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 1
29284: NEG
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: NEG
29296: PUSH
29297: LD_INT 1
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: LD_INT 1
29307: NEG
29308: PUSH
29309: LD_INT 2
29311: NEG
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 2
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 2
29329: PUSH
29330: LD_INT 2
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 1
29339: PUSH
29340: LD_INT 2
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: NEG
29350: PUSH
29351: LD_INT 1
29353: NEG
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 2
29361: NEG
29362: PUSH
29363: LD_INT 2
29365: NEG
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 2
29373: NEG
29374: PUSH
29375: LD_INT 3
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 3
29385: NEG
29386: PUSH
29387: LD_INT 2
29389: NEG
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 3
29397: NEG
29398: PUSH
29399: LD_INT 3
29401: NEG
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29425: LD_ADDR_VAR 0 14
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 0
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 1
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: NEG
29507: PUSH
29508: LD_INT 2
29510: NEG
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 2
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 1
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: LD_INT 2
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 1
29571: NEG
29572: PUSH
29573: LD_INT 3
29575: NEG
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 0
29583: PUSH
29584: LD_INT 3
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29621: LD_ADDR_VAR 0 15
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 0
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 1
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 2
29713: PUSH
29714: LD_INT 0
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 2
29723: PUSH
29724: LD_INT 1
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 1
29733: NEG
29734: PUSH
29735: LD_INT 1
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 2
29744: NEG
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 2
29755: NEG
29756: PUSH
29757: LD_INT 1
29759: NEG
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 2
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 3
29778: PUSH
29779: LD_INT 0
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 3
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29814: LD_ADDR_VAR 0 16
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 0
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 0
29831: PUSH
29832: LD_INT 1
29834: NEG
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 0
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: NEG
29873: PUSH
29874: LD_INT 0
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: NEG
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 1
29895: NEG
29896: PUSH
29897: LD_INT 2
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 2
29917: PUSH
29918: LD_INT 2
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 1
29927: PUSH
29928: LD_INT 2
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 2
29937: NEG
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: NEG
29950: PUSH
29951: LD_INT 2
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 3
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 3
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 2
29981: PUSH
29982: LD_INT 3
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30007: LD_ADDR_VAR 0 17
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: LD_INT 0
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 0
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 1
30065: NEG
30066: PUSH
30067: LD_INT 0
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 1
30076: NEG
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: NEG
30089: PUSH
30090: LD_INT 2
30092: NEG
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 0
30100: PUSH
30101: LD_INT 2
30103: NEG
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: PUSH
30123: LD_INT 0
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 2
30142: PUSH
30143: LD_INT 2
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: LD_INT 2
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: LD_INT 2
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 2
30183: NEG
30184: PUSH
30185: LD_INT 0
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 2
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30237: LD_ADDR_VAR 0 18
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: LD_INT 0
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: LD_INT 1
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 0
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: LD_INT 0
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 1
30306: NEG
30307: PUSH
30308: LD_INT 1
30310: NEG
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 1
30318: NEG
30319: PUSH
30320: LD_INT 2
30322: NEG
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: LD_INT 2
30333: NEG
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: LD_INT 1
30344: NEG
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 2
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 2
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 2
30372: PUSH
30373: LD_INT 2
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: PUSH
30383: LD_INT 2
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 0
30392: PUSH
30393: LD_INT 2
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 1
30402: NEG
30403: PUSH
30404: LD_INT 1
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 2
30413: NEG
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 2
30424: NEG
30425: PUSH
30426: LD_INT 1
30428: NEG
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 2
30436: NEG
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30467: LD_ADDR_VAR 0 19
30471: PUSH
30472: LD_INT 0
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 0
30484: PUSH
30485: LD_INT 1
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 0
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PUSH
30503: LD_INT 1
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 0
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 0
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 1
30536: NEG
30537: PUSH
30538: LD_INT 1
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 1
30548: NEG
30549: PUSH
30550: LD_INT 2
30552: NEG
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 0
30560: PUSH
30561: LD_INT 2
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 2
30582: PUSH
30583: LD_INT 0
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 2
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 2
30602: PUSH
30603: LD_INT 2
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 1
30612: PUSH
30613: LD_INT 2
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 0
30622: PUSH
30623: LD_INT 2
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 2
30643: NEG
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: LD_INT 1
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 2
30666: NEG
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30697: LD_ADDR_VAR 0 20
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 0
30714: PUSH
30715: LD_INT 1
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 1
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: LD_INT 1
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 1
30766: NEG
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: LD_INT 2
30782: NEG
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 2
30812: PUSH
30813: LD_INT 0
30815: PUSH
30816: EMPTY
30817: LIST
30818: LIST
30819: PUSH
30820: LD_INT 2
30822: PUSH
30823: LD_INT 1
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 2
30832: PUSH
30833: LD_INT 2
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: PUSH
30843: LD_INT 2
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: LD_INT 1
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 2
30873: NEG
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 2
30884: NEG
30885: PUSH
30886: LD_INT 1
30888: NEG
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 2
30896: NEG
30897: PUSH
30898: LD_INT 2
30900: NEG
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30927: LD_ADDR_VAR 0 21
30931: PUSH
30932: LD_INT 0
30934: PUSH
30935: LD_INT 0
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: LD_INT 1
30947: NEG
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: LD_INT 0
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: LD_INT 1
30965: PUSH
30966: LD_INT 1
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 1
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 1
30985: NEG
30986: PUSH
30987: LD_INT 0
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 1
30996: NEG
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 1
31008: NEG
31009: PUSH
31010: LD_INT 2
31012: NEG
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 0
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: LD_INT 1
31034: NEG
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 2
31042: PUSH
31043: LD_INT 0
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 2
31052: PUSH
31053: LD_INT 1
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 2
31062: PUSH
31063: LD_INT 2
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 1
31072: PUSH
31073: LD_INT 2
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 0
31082: PUSH
31083: LD_INT 2
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: NEG
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 2
31103: NEG
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 2
31114: NEG
31115: PUSH
31116: LD_INT 1
31118: NEG
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: LD_INT 2
31126: NEG
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31157: LD_ADDR_VAR 0 22
31161: PUSH
31162: LD_INT 0
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 0
31174: PUSH
31175: LD_INT 1
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 0
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: LD_INT 1
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: LD_INT 1
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 1
31215: NEG
31216: PUSH
31217: LD_INT 0
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 1
31226: NEG
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 1
31238: NEG
31239: PUSH
31240: LD_INT 2
31242: NEG
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 0
31250: PUSH
31251: LD_INT 2
31253: NEG
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 2
31272: PUSH
31273: LD_INT 0
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: LD_INT 1
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: LD_INT 2
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 0
31312: PUSH
31313: LD_INT 2
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: NEG
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 2
31333: NEG
31334: PUSH
31335: LD_INT 0
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: NEG
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 2
31356: NEG
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31387: LD_ADDR_VAR 0 23
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 1
31415: PUSH
31416: LD_INT 0
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 1
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 1
31445: NEG
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: NEG
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: LD_INT 2
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 2
31502: PUSH
31503: LD_INT 0
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 2
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 2
31522: PUSH
31523: LD_INT 2
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: LD_INT 2
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: LD_INT 2
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: LD_INT 1
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: NEG
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 2
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 2
31586: NEG
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 2
31598: NEG
31599: PUSH
31600: LD_INT 3
31602: NEG
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 3
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 1
31622: PUSH
31623: LD_INT 2
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 2
31633: PUSH
31634: LD_INT 1
31636: NEG
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31667: LD_ADDR_VAR 0 24
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: LD_INT 1
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 1
31736: NEG
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 0
31760: PUSH
31761: LD_INT 2
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: LD_INT 0
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 0
31822: PUSH
31823: LD_INT 2
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: LD_INT 1
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: NEG
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: LD_INT 2
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 1
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 2
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 3
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: LD_INT 2
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31943: LD_ADDR_VAR 0 25
31947: PUSH
31948: LD_INT 0
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: LD_INT 1
31963: NEG
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: NEG
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 2
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: PUSH
32089: LD_INT 2
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 0
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 2
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 2
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: PUSH
32155: LD_INT 1
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 3
32164: PUSH
32165: LD_INT 2
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: LD_INT 3
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: LD_INT 3
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32217: LD_ADDR_VAR 0 26
32221: PUSH
32222: LD_INT 0
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 1
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 0
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 1
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 0
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 1
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 2
32332: PUSH
32333: LD_INT 0
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: LD_INT 2
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 2
32393: NEG
32394: PUSH
32395: LD_INT 0
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 2
32404: NEG
32405: PUSH
32406: LD_INT 1
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: LD_INT 2
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 2
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 1
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 1
32448: NEG
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 2
32459: NEG
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32493: LD_ADDR_VAR 0 27
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 0
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 0
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 0
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: LD_INT 2
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: LD_INT 2
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: LD_INT 0
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 2
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 2
32628: PUSH
32629: LD_INT 2
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: LD_INT 2
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: LD_INT 2
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: LD_INT 1
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 2
32669: NEG
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 2
32692: NEG
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: LD_INT 1
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 3
32726: NEG
32727: PUSH
32728: LD_INT 1
32730: NEG
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32773: LD_ADDR_VAR 0 28
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 1
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 2
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: NEG
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 1
32877: PUSH
32878: LD_INT 1
32880: NEG
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: PUSH
32899: LD_INT 1
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 2
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: LD_INT 2
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: LD_INT 0
32928: PUSH
32929: LD_INT 2
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 1
32938: NEG
32939: PUSH
32940: LD_INT 1
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 2
32960: NEG
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: LD_INT 2
32976: NEG
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: LD_INT 3
32988: NEG
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 1
32996: NEG
32997: PUSH
32998: LD_INT 3
33000: NEG
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 3
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 3
33020: NEG
33021: PUSH
33022: LD_INT 2
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33055: LD_ADDR_VAR 0 29
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: LD_INT 0
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 0
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 1
33113: NEG
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: NEG
33125: PUSH
33126: LD_INT 1
33128: NEG
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 1
33136: NEG
33137: PUSH
33138: LD_INT 2
33140: NEG
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: LD_INT 2
33151: NEG
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: PUSH
33157: LD_INT 1
33159: PUSH
33160: LD_INT 1
33162: NEG
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 2
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 2
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 0
33200: PUSH
33201: LD_INT 2
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: NEG
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 2
33245: NEG
33246: PUSH
33247: LD_INT 3
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 2
33257: PUSH
33258: LD_INT 1
33260: NEG
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 3
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 3
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 2
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 3
33299: NEG
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33334: LD_ADDR_VAR 0 30
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: LD_INT 1
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: PUSH
33363: LD_INT 0
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: LD_INT 0
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 2
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 1
33441: NEG
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 1
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 1
33489: NEG
33490: PUSH
33491: LD_INT 1
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 2
33500: NEG
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 2
33511: NEG
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: LD_INT 3
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 3
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 2
33556: PUSH
33557: LD_INT 3
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 2
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 3
33577: NEG
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33612: LD_ADDR_VAR 0 31
33616: PUSH
33617: LD_INT 0
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: LD_INT 1
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 1
33670: NEG
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: NEG
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 2
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 2
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: LD_INT 2
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: NEG
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 2
33777: NEG
33778: PUSH
33779: LD_INT 1
33781: NEG
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 2
33789: NEG
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 3
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 1
33816: NEG
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 3
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: LD_INT 2
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 3
33855: NEG
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33890: LD_ADDR_VAR 0 32
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 0
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 1
33959: NEG
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 2
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 1
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 2
34005: PUSH
34006: LD_INT 1
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: LD_INT 2
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: LD_INT 2
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: NEG
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 2
34067: NEG
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: LD_INT 3
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: LD_INT 2
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 3
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 2
34112: PUSH
34113: LD_INT 3
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: LD_INT 1
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 3
34133: NEG
34134: PUSH
34135: LD_INT 1
34137: NEG
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34168: LD_ADDR_VAR 0 33
34172: PUSH
34173: LD_INT 0
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 1
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 2
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: LD_INT 1
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 2
34323: NEG
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 2
34334: NEG
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: LD_INT 2
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: NEG
34359: PUSH
34360: LD_INT 3
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 3
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: LD_INT 3
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: LD_INT 2
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 3
34412: NEG
34413: PUSH
34414: LD_INT 2
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34447: LD_ADDR_VAR 0 34
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 1
34467: NEG
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 1
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: LD_INT 1
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 1
34528: NEG
34529: PUSH
34530: LD_INT 2
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: LD_INT 2
34543: NEG
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 2
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: LD_INT 2
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 1
34638: NEG
34639: PUSH
34640: LD_INT 3
34642: NEG
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 1
34650: PUSH
34651: LD_INT 2
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: LD_INT 2
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 2
34671: PUSH
34672: LD_INT 3
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 2
34681: NEG
34682: PUSH
34683: LD_INT 1
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 3
34692: NEG
34693: PUSH
34694: LD_INT 1
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34727: LD_ADDR_VAR 0 35
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 0
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34839: LD_ADDR_VAR 0 36
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 1
34859: NEG
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: NEG
34898: PUSH
34899: LD_INT 0
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: LD_INT 1
34912: NEG
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 1
34920: NEG
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: LD_INT 2
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34951: LD_ADDR_VAR 0 37
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: LD_INT 0
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: LD_INT 1
34971: NEG
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 1
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 1
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: LD_INT 0
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: LD_INT 1
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35063: LD_ADDR_VAR 0 38
35067: PUSH
35068: LD_INT 0
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 0
35080: PUSH
35081: LD_INT 1
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 1
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 1
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 0
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 2
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35175: LD_ADDR_VAR 0 39
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: LD_INT 0
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: LD_INT 0
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: LD_INT 0
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: LD_INT 1
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 0
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: NEG
35257: PUSH
35258: LD_INT 2
35260: NEG
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 1
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35287: LD_ADDR_VAR 0 40
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 1
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 0
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 1
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35399: LD_ADDR_VAR 0 41
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 0
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 2
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 2
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 2
35523: PUSH
35524: LD_INT 2
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: LD_INT 2
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: NEG
35544: PUSH
35545: LD_INT 1
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 2
35554: NEG
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 2
35577: NEG
35578: PUSH
35579: LD_INT 2
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 2
35589: NEG
35590: PUSH
35591: LD_INT 3
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: LD_INT 1
35604: NEG
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 3
35612: PUSH
35613: LD_INT 0
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 3
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 3
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 3
35642: PUSH
35643: LD_INT 3
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 2
35652: PUSH
35653: LD_INT 3
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 2
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 3
35673: NEG
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 3
35684: NEG
35685: PUSH
35686: LD_INT 1
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 3
35696: NEG
35697: PUSH
35698: LD_INT 2
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 3
35708: NEG
35709: PUSH
35710: LD_INT 3
35712: NEG
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35749: LD_ADDR_VAR 0 42
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 0
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 0
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 0
35797: PUSH
35798: LD_INT 1
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: LD_INT 1
35822: NEG
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 2
35845: NEG
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 2
35864: PUSH
35865: LD_INT 1
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 2
35874: PUSH
35875: LD_INT 2
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 2
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 0
35894: PUSH
35895: LD_INT 2
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 2
35915: NEG
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 2
35927: NEG
35928: PUSH
35929: LD_INT 2
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 3
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: LD_INT 3
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 3
35985: PUSH
35986: LD_INT 2
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: PUSH
35993: LD_INT 3
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 2
36005: PUSH
36006: LD_INT 3
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 1
36015: PUSH
36016: LD_INT 3
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 0
36025: PUSH
36026: LD_INT 3
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 3
36046: NEG
36047: PUSH
36048: LD_INT 2
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: LD_INT 3
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36099: LD_ADDR_VAR 0 43
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 0
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 0
36116: PUSH
36117: LD_INT 1
36119: NEG
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: NEG
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: LD_INT 1
36172: NEG
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: LD_INT 2
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 2
36195: NEG
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 2
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 2
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 3
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 3
36303: NEG
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 1
36311: PUSH
36312: LD_INT 2
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: PUSH
36323: LD_INT 1
36325: NEG
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 3
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 3
36343: PUSH
36344: LD_INT 1
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: PUSH
36354: LD_INT 3
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: LD_INT 3
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: LD_INT 2
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 2
36384: NEG
36385: PUSH
36386: LD_INT 1
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 3
36406: NEG
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: LIST
36422: LIST
36423: LIST
36424: LIST
36425: LIST
36426: LIST
36427: LIST
36428: LIST
36429: LIST
36430: LIST
36431: LIST
36432: LIST
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36447: LD_ADDR_VAR 0 44
36451: PUSH
36452: LD_INT 0
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 0
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 1
36475: PUSH
36476: LD_INT 0
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 1
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: LD_INT 1
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 1
36516: NEG
36517: PUSH
36518: LD_INT 1
36520: NEG
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 1
36528: NEG
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: LD_INT 1
36543: NEG
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 2
36561: PUSH
36562: LD_INT 1
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 2
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: LD_INT 2
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 2
36613: NEG
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 2
36625: NEG
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 2
36637: NEG
36638: PUSH
36639: LD_INT 3
36641: NEG
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 3
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 3
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 3
36680: PUSH
36681: LD_INT 2
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 3
36690: PUSH
36691: LD_INT 3
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: PUSH
36701: LD_INT 3
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: NEG
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: NEG
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 3
36732: NEG
36733: PUSH
36734: LD_INT 1
36736: NEG
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 3
36744: NEG
36745: PUSH
36746: LD_INT 2
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 3
36756: NEG
36757: PUSH
36758: LD_INT 3
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: LIST
36781: LIST
36782: LIST
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36797: LD_ADDR_VAR 0 45
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: PUSH
36826: LD_INT 0
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 1
36835: PUSH
36836: LD_INT 1
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 0
36845: PUSH
36846: LD_INT 1
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 1
36855: NEG
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 2
36893: NEG
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 1
36904: NEG
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 2
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 1
36932: PUSH
36933: LD_INT 2
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: LD_INT 2
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: LD_INT 1
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 2
36987: NEG
36988: PUSH
36989: LD_INT 3
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: LD_INT 3
37003: NEG
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: LD_INT 0
37011: PUSH
37012: LD_INT 3
37014: NEG
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: LD_INT 2
37025: NEG
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 3
37033: PUSH
37034: LD_INT 2
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 3
37043: PUSH
37044: LD_INT 3
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 2
37053: PUSH
37054: LD_INT 3
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 3
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 0
37073: PUSH
37074: LD_INT 3
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: LD_INT 2
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 3
37094: NEG
37095: PUSH
37096: LD_INT 2
37098: NEG
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: LD_INT 3
37106: NEG
37107: PUSH
37108: LD_INT 3
37110: NEG
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37147: LD_ADDR_VAR 0 46
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: LD_INT 0
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 0
37164: PUSH
37165: LD_INT 1
37167: NEG
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 1
37175: PUSH
37176: LD_INT 0
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: LD_INT 1
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: LD_INT 1
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 1
37205: NEG
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 1
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 2
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 2
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 1
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 2
37262: PUSH
37263: LD_INT 0
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: LD_INT 1
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: LD_INT 2
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 0
37292: PUSH
37293: LD_INT 2
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 1
37302: NEG
37303: PUSH
37304: LD_INT 1
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 2
37313: NEG
37314: PUSH
37315: LD_INT 0
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 1
37336: NEG
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 0
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: LD_INT 1
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 1
37401: PUSH
37402: LD_INT 3
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 3
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: NEG
37422: PUSH
37423: LD_INT 2
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 2
37432: NEG
37433: PUSH
37434: LD_INT 1
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: LD_INT 0
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 3
37454: NEG
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: LIST
37468: LIST
37469: LIST
37470: LIST
37471: LIST
37472: LIST
37473: LIST
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: LIST
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37495: LD_ADDR_VAR 0 47
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: LD_INT 0
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PUSH
37531: LD_INT 1
37533: PUSH
37534: LD_INT 1
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: LD_INT 1
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: NEG
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: LD_INT 2
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 0
37588: PUSH
37589: LD_INT 2
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 2
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37646: LD_ADDR_VAR 0 48
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: LD_INT 0
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 1
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 1
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: LD_INT 1
37719: NEG
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 1
37727: NEG
37728: PUSH
37729: LD_INT 2
37731: NEG
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 2
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37793: LD_ADDR_VAR 0 49
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: LD_INT 0
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: LD_INT 0
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 1
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 1
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 1
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: LD_INT 1
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: LD_INT 1
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: PUSH
37886: LD_INT 0
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 2
37895: PUSH
37896: LD_INT 1
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 2
37905: PUSH
37906: LD_INT 2
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: LD_INT 2
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37937: LD_ADDR_VAR 0 50
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: LD_INT 1
37957: NEG
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 1
37965: PUSH
37966: LD_INT 0
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 1
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: LD_INT 1
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: LD_INT 0
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 2
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 2
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38081: LD_ADDR_VAR 0 51
38085: PUSH
38086: LD_INT 0
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: LD_INT 1
38101: NEG
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: LD_INT 1
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: NEG
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: LD_INT 2
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 0
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 2
38193: NEG
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: LD_INT 1
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: LIST
38218: LIST
38219: LIST
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38228: LD_ADDR_VAR 0 52
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: LD_INT 1
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: NEG
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 1
38297: NEG
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 1
38309: NEG
38310: PUSH
38311: LD_INT 2
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 1
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 2
38332: NEG
38333: PUSH
38334: LD_INT 0
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 2
38343: NEG
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 2
38355: NEG
38356: PUSH
38357: LD_INT 2
38359: NEG
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38379: LD_ADDR_VAR 0 53
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 1
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 1
38437: NEG
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: NEG
38449: PUSH
38450: LD_INT 1
38452: NEG
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: LD_INT 2
38464: NEG
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: LD_INT 2
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 1
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: LD_INT 0
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 2
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: LD_INT 2
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: NEG
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: NEG
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 2
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38609: LD_ADDR_VAR 0 54
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 1
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: NEG
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: PUSH
38725: LD_INT 0
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 2
38734: PUSH
38735: LD_INT 1
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 2
38744: PUSH
38745: LD_INT 2
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: LD_INT 1
38754: PUSH
38755: LD_INT 2
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 0
38764: PUSH
38765: LD_INT 2
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 1
38774: NEG
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 2
38785: NEG
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: NEG
38797: PUSH
38798: LD_INT 1
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 2
38808: NEG
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38839: LD_ADDR_VAR 0 55
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: LD_INT 0
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 0
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 1
38867: PUSH
38868: LD_INT 0
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 1
38920: NEG
38921: PUSH
38922: LD_INT 2
38924: NEG
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: LD_INT 2
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 0
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 2
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 2
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 2
39038: NEG
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39069: LD_ADDR_VAR 0 56
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: LD_INT 1
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 1
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: LD_INT 1
39107: PUSH
39108: LD_INT 1
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 0
39117: PUSH
39118: LD_INT 1
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 1
39127: NEG
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: NEG
39139: PUSH
39140: LD_INT 1
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: LD_INT 2
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 2
39165: NEG
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 2
39184: PUSH
39185: LD_INT 0
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 2
39194: PUSH
39195: LD_INT 1
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 2
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 1
39214: PUSH
39215: LD_INT 2
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 0
39224: PUSH
39225: LD_INT 2
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 1
39234: NEG
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: LD_INT 0
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PUSH
39254: LD_INT 2
39256: NEG
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 2
39268: NEG
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39299: LD_ADDR_VAR 0 57
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 1
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: LD_INT 1
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 0
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 1
39357: NEG
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: NEG
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: LD_INT 1
39406: NEG
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 2
39414: PUSH
39415: LD_INT 0
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 2
39424: PUSH
39425: LD_INT 1
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 2
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: LD_INT 2
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: LD_INT 1
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 2
39475: NEG
39476: PUSH
39477: LD_INT 0
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: NEG
39487: PUSH
39488: LD_INT 1
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 2
39498: NEG
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39529: LD_ADDR_VAR 0 58
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: LD_INT 1
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 1
39557: PUSH
39558: LD_INT 0
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 1
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: LD_INT 1
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 1
39587: NEG
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 1
39610: NEG
39611: PUSH
39612: LD_INT 2
39614: NEG
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 0
39622: PUSH
39623: LD_INT 2
39625: NEG
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 2
39644: PUSH
39645: LD_INT 0
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 2
39654: PUSH
39655: LD_INT 1
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 2
39664: PUSH
39665: LD_INT 2
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 1
39674: PUSH
39675: LD_INT 2
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: LD_INT 2
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: NEG
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 2
39705: NEG
39706: PUSH
39707: LD_INT 0
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 2
39716: NEG
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 2
39728: NEG
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39759: LD_ADDR_VAR 0 59
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: LD_INT 1
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: LD_INT 0
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 1
39817: NEG
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 1
39828: NEG
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39847: LD_ADDR_VAR 0 60
39851: PUSH
39852: LD_INT 0
39854: PUSH
39855: LD_INT 0
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 0
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 1
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: PUSH
39886: LD_INT 1
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 1
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: NEG
39917: PUSH
39918: LD_INT 1
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39935: LD_ADDR_VAR 0 61
39939: PUSH
39940: LD_INT 0
39942: PUSH
39943: LD_INT 0
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 1
39973: PUSH
39974: LD_INT 1
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 1
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: LD_INT 0
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: NEG
40005: PUSH
40006: LD_INT 1
40008: NEG
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40023: LD_ADDR_VAR 0 62
40027: PUSH
40028: LD_INT 0
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 0
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 1
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 1
40081: NEG
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: NEG
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40111: LD_ADDR_VAR 0 63
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 0
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 0
40128: PUSH
40129: LD_INT 1
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: LD_INT 1
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 1
40180: NEG
40181: PUSH
40182: LD_INT 1
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40199: LD_ADDR_VAR 0 64
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 1
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 1
40237: PUSH
40238: LD_INT 1
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 0
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 1
40257: NEG
40258: PUSH
40259: LD_INT 0
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 1
40272: NEG
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: ST_TO_ADDR
// end ; 1 :
40287: GO 46184
40289: LD_INT 1
40291: DOUBLE
40292: EQUAL
40293: IFTRUE 40297
40295: GO 42920
40297: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40298: LD_ADDR_VAR 0 11
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: LD_INT 3
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 3
40320: NEG
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: LD_INT 2
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: LIST
40341: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40342: LD_ADDR_VAR 0 12
40346: PUSH
40347: LD_INT 2
40349: PUSH
40350: LD_INT 1
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 3
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: LIST
40382: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40383: LD_ADDR_VAR 0 13
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 3
40400: PUSH
40401: LD_INT 3
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 2
40410: PUSH
40411: LD_INT 3
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: LIST
40422: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40423: LD_ADDR_VAR 0 14
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: LD_INT 3
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 0
40440: PUSH
40441: LD_INT 3
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: LIST
40463: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40464: LD_ADDR_VAR 0 15
40468: PUSH
40469: LD_INT 2
40471: NEG
40472: PUSH
40473: LD_INT 1
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 3
40482: NEG
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 3
40493: NEG
40494: PUSH
40495: LD_INT 1
40497: NEG
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: LIST
40507: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40508: LD_ADDR_VAR 0 16
40512: PUSH
40513: LD_INT 2
40515: NEG
40516: PUSH
40517: LD_INT 3
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: LD_INT 2
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 3
40539: NEG
40540: PUSH
40541: LD_INT 3
40543: NEG
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: LIST
40553: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40554: LD_ADDR_VAR 0 17
40558: PUSH
40559: LD_INT 1
40561: NEG
40562: PUSH
40563: LD_INT 3
40565: NEG
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: LD_INT 0
40573: PUSH
40574: LD_INT 3
40576: NEG
40577: PUSH
40578: EMPTY
40579: LIST
40580: LIST
40581: PUSH
40582: LD_INT 1
40584: PUSH
40585: LD_INT 2
40587: NEG
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: LIST
40597: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40598: LD_ADDR_VAR 0 18
40602: PUSH
40603: LD_INT 2
40605: PUSH
40606: LD_INT 1
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 3
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 3
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: LIST
40638: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40639: LD_ADDR_VAR 0 19
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: LD_INT 2
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 3
40656: PUSH
40657: LD_INT 3
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 2
40666: PUSH
40667: LD_INT 3
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: LIST
40678: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40679: LD_ADDR_VAR 0 20
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 3
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 0
40696: PUSH
40697: LD_INT 3
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 1
40706: NEG
40707: PUSH
40708: LD_INT 2
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: LIST
40719: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40720: LD_ADDR_VAR 0 21
40724: PUSH
40725: LD_INT 2
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 3
40738: NEG
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 3
40749: NEG
40750: PUSH
40751: LD_INT 1
40753: NEG
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: LIST
40763: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40764: LD_ADDR_VAR 0 22
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: LD_INT 3
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 3
40783: NEG
40784: PUSH
40785: LD_INT 2
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: LD_INT 3
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: LIST
40809: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40810: LD_ADDR_VAR 0 23
40814: PUSH
40815: LD_INT 0
40817: PUSH
40818: LD_INT 3
40820: NEG
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 1
40828: NEG
40829: PUSH
40830: LD_INT 4
40832: NEG
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 1
40840: PUSH
40841: LD_INT 3
40843: NEG
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: LIST
40853: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40854: LD_ADDR_VAR 0 24
40858: PUSH
40859: LD_INT 3
40861: PUSH
40862: LD_INT 0
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 3
40871: PUSH
40872: LD_INT 1
40874: NEG
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: LIST
40894: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40895: LD_ADDR_VAR 0 25
40899: PUSH
40900: LD_INT 3
40902: PUSH
40903: LD_INT 3
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: PUSH
40913: LD_INT 3
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: PUSH
40923: LD_INT 4
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: LIST
40934: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40935: LD_ADDR_VAR 0 26
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 3
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: LD_INT 4
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 1
40962: NEG
40963: PUSH
40964: LD_INT 3
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: LIST
40975: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40976: LD_ADDR_VAR 0 27
40980: PUSH
40981: LD_INT 3
40983: NEG
40984: PUSH
40985: LD_INT 0
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 3
40994: NEG
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 4
41005: NEG
41006: PUSH
41007: LD_INT 1
41009: NEG
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: LIST
41019: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41020: LD_ADDR_VAR 0 28
41024: PUSH
41025: LD_INT 3
41027: NEG
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: LD_INT 4
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 4
41051: NEG
41052: PUSH
41053: LD_INT 3
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: LIST
41065: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41066: LD_ADDR_VAR 0 29
41070: PUSH
41071: LD_INT 1
41073: NEG
41074: PUSH
41075: LD_INT 3
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 0
41085: PUSH
41086: LD_INT 3
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: LD_INT 2
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 4
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 4
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 3
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 5
41145: NEG
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 0
41153: PUSH
41154: LD_INT 5
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: LD_INT 4
41167: NEG
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 1
41175: NEG
41176: PUSH
41177: LD_INT 6
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 0
41187: PUSH
41188: LD_INT 6
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: LD_INT 5
41201: NEG
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41221: LD_ADDR_VAR 0 30
41225: PUSH
41226: LD_INT 2
41228: PUSH
41229: LD_INT 1
41231: NEG
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 3
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 4
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 4
41280: PUSH
41281: LD_INT 1
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 4
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 5
41301: PUSH
41302: LD_INT 0
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 5
41311: PUSH
41312: LD_INT 1
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 5
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 6
41332: PUSH
41333: LD_INT 0
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 6
41342: PUSH
41343: LD_INT 1
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41364: LD_ADDR_VAR 0 31
41368: PUSH
41369: LD_INT 3
41371: PUSH
41372: LD_INT 2
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 3
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 2
41391: PUSH
41392: LD_INT 3
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 4
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 4
41411: PUSH
41412: LD_INT 4
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 3
41421: PUSH
41422: LD_INT 4
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 5
41431: PUSH
41432: LD_INT 4
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 5
41441: PUSH
41442: LD_INT 5
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 4
41451: PUSH
41452: LD_INT 5
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 6
41461: PUSH
41462: LD_INT 5
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 6
41471: PUSH
41472: LD_INT 6
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 5
41481: PUSH
41482: LD_INT 6
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41503: LD_ADDR_VAR 0 32
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: LD_INT 3
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 0
41520: PUSH
41521: LD_INT 3
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 1
41530: NEG
41531: PUSH
41532: LD_INT 2
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: LD_INT 4
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 0
41551: PUSH
41552: LD_INT 4
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 1
41561: NEG
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 1
41572: PUSH
41573: LD_INT 5
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 5
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 1
41592: NEG
41593: PUSH
41594: LD_INT 4
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 1
41603: PUSH
41604: LD_INT 6
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 0
41613: PUSH
41614: LD_INT 6
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 1
41623: NEG
41624: PUSH
41625: LD_INT 5
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41646: LD_ADDR_VAR 0 33
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: LD_INT 1
41679: NEG
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 3
41687: NEG
41688: PUSH
41689: LD_INT 1
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 4
41698: NEG
41699: PUSH
41700: LD_INT 0
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 4
41709: NEG
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 4
41721: NEG
41722: PUSH
41723: LD_INT 1
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 5
41732: NEG
41733: PUSH
41734: LD_INT 0
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 5
41743: NEG
41744: PUSH
41745: LD_INT 1
41747: NEG
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: LD_INT 5
41755: NEG
41756: PUSH
41757: LD_INT 1
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 6
41766: NEG
41767: PUSH
41768: LD_INT 0
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 6
41777: NEG
41778: PUSH
41779: LD_INT 1
41781: NEG
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41801: LD_ADDR_VAR 0 34
41805: PUSH
41806: LD_INT 2
41808: NEG
41809: PUSH
41810: LD_INT 3
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: LD_INT 2
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 3
41832: NEG
41833: PUSH
41834: LD_INT 3
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: NEG
41845: PUSH
41846: LD_INT 4
41848: NEG
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 4
41856: NEG
41857: PUSH
41858: LD_INT 3
41860: NEG
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 4
41868: NEG
41869: PUSH
41870: LD_INT 4
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 4
41880: NEG
41881: PUSH
41882: LD_INT 5
41884: NEG
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 5
41892: NEG
41893: PUSH
41894: LD_INT 4
41896: NEG
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 5
41904: NEG
41905: PUSH
41906: LD_INT 5
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 5
41916: NEG
41917: PUSH
41918: LD_INT 6
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 6
41928: NEG
41929: PUSH
41930: LD_INT 5
41932: NEG
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 6
41940: NEG
41941: PUSH
41942: LD_INT 6
41944: NEG
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41964: LD_ADDR_VAR 0 41
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: LD_INT 2
41974: NEG
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 1
41982: NEG
41983: PUSH
41984: LD_INT 3
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: LIST
42007: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42008: LD_ADDR_VAR 0 42
42012: PUSH
42013: LD_INT 2
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 2
42025: PUSH
42026: LD_INT 1
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 3
42036: PUSH
42037: LD_INT 1
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: LIST
42048: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42049: LD_ADDR_VAR 0 43
42053: PUSH
42054: LD_INT 2
42056: PUSH
42057: LD_INT 2
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: PUSH
42067: LD_INT 2
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 2
42076: PUSH
42077: LD_INT 3
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: LIST
42088: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42089: LD_ADDR_VAR 0 44
42093: PUSH
42094: LD_INT 0
42096: PUSH
42097: LD_INT 2
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 1
42106: PUSH
42107: LD_INT 3
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 1
42116: NEG
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: LIST
42129: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42130: LD_ADDR_VAR 0 45
42134: PUSH
42135: LD_INT 2
42137: NEG
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 2
42148: NEG
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 3
42159: NEG
42160: PUSH
42161: LD_INT 1
42163: NEG
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: LIST
42173: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42174: LD_ADDR_VAR 0 46
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 2
42185: NEG
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 2
42193: NEG
42194: PUSH
42195: LD_INT 3
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 3
42205: NEG
42206: PUSH
42207: LD_INT 2
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: LIST
42219: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42220: LD_ADDR_VAR 0 47
42224: PUSH
42225: LD_INT 2
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42253: LD_ADDR_VAR 0 48
42257: PUSH
42258: LD_INT 1
42260: PUSH
42261: LD_INT 2
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 2
42271: PUSH
42272: LD_INT 1
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42284: LD_ADDR_VAR 0 49
42288: PUSH
42289: LD_INT 3
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 3
42301: PUSH
42302: LD_INT 2
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42313: LD_ADDR_VAR 0 50
42317: PUSH
42318: LD_INT 2
42320: PUSH
42321: LD_INT 3
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 1
42330: PUSH
42331: LD_INT 3
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42342: LD_ADDR_VAR 0 51
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 2
42360: NEG
42361: PUSH
42362: LD_INT 1
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42373: LD_ADDR_VAR 0 52
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: LD_INT 2
42396: NEG
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42406: LD_ADDR_VAR 0 53
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 3
42417: NEG
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 0
42425: PUSH
42426: LD_INT 3
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 1
42436: PUSH
42437: LD_INT 2
42439: NEG
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42450: LD_ADDR_VAR 0 54
42454: PUSH
42455: LD_INT 2
42457: PUSH
42458: LD_INT 1
42460: NEG
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 3
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 3
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: LIST
42490: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42491: LD_ADDR_VAR 0 55
42495: PUSH
42496: LD_INT 3
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 3
42508: PUSH
42509: LD_INT 3
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 2
42518: PUSH
42519: LD_INT 3
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42531: LD_ADDR_VAR 0 56
42535: PUSH
42536: LD_INT 1
42538: PUSH
42539: LD_INT 3
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 0
42548: PUSH
42549: LD_INT 3
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: LIST
42571: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42572: LD_ADDR_VAR 0 57
42576: PUSH
42577: LD_INT 2
42579: NEG
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 3
42590: NEG
42591: PUSH
42592: LD_INT 0
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 3
42601: NEG
42602: PUSH
42603: LD_INT 1
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: LIST
42615: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42616: LD_ADDR_VAR 0 58
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 3
42635: NEG
42636: PUSH
42637: LD_INT 2
42639: NEG
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 3
42647: NEG
42648: PUSH
42649: LD_INT 3
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: LIST
42661: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42662: LD_ADDR_VAR 0 59
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: NEG
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 0
42681: PUSH
42682: LD_INT 2
42684: NEG
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: LD_INT 1
42695: NEG
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: LIST
42705: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42706: LD_ADDR_VAR 0 60
42710: PUSH
42711: LD_INT 1
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 2
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 2
42734: PUSH
42735: LD_INT 1
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42747: LD_ADDR_VAR 0 61
42751: PUSH
42752: LD_INT 2
42754: PUSH
42755: LD_INT 1
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 2
42764: PUSH
42765: LD_INT 2
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 1
42774: PUSH
42775: LD_INT 2
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: LIST
42786: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42787: LD_ADDR_VAR 0 62
42791: PUSH
42792: LD_INT 1
42794: PUSH
42795: LD_INT 2
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 0
42804: PUSH
42805: LD_INT 2
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: LIST
42827: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42828: LD_ADDR_VAR 0 63
42832: PUSH
42833: LD_INT 1
42835: NEG
42836: PUSH
42837: LD_INT 1
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 2
42846: NEG
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 2
42857: NEG
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: LIST
42871: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42872: LD_ADDR_VAR 0 64
42876: PUSH
42877: LD_INT 1
42879: NEG
42880: PUSH
42881: LD_INT 2
42883: NEG
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 2
42891: NEG
42892: PUSH
42893: LD_INT 1
42895: NEG
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 2
42907: NEG
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: LIST
42917: ST_TO_ADDR
// end ; 2 :
42918: GO 46184
42920: LD_INT 2
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42928
42926: GO 46183
42928: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42929: LD_ADDR_VAR 0 29
42933: PUSH
42934: LD_INT 4
42936: PUSH
42937: LD_INT 0
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 4
42946: PUSH
42947: LD_INT 1
42949: NEG
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 5
42957: PUSH
42958: LD_INT 0
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 5
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 4
42977: PUSH
42978: LD_INT 1
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 3
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 3
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: LD_INT 2
43011: NEG
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 5
43019: PUSH
43020: LD_INT 2
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 3
43029: PUSH
43030: LD_INT 3
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: PUSH
43040: LD_INT 2
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 4
43049: PUSH
43050: LD_INT 3
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 4
43059: PUSH
43060: LD_INT 4
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 3
43069: PUSH
43070: LD_INT 4
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 3
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: PUSH
43090: LD_INT 2
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 4
43099: PUSH
43100: LD_INT 2
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 2
43109: PUSH
43110: LD_INT 4
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 0
43119: PUSH
43120: LD_INT 4
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: LD_INT 3
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: LD_INT 4
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 5
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: LD_INT 5
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: NEG
43170: PUSH
43171: LD_INT 4
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 1
43180: NEG
43181: PUSH
43182: LD_INT 3
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: PUSH
43192: LD_INT 5
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 2
43201: NEG
43202: PUSH
43203: LD_INT 3
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 3
43212: NEG
43213: PUSH
43214: LD_INT 0
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: NEG
43224: PUSH
43225: LD_INT 1
43227: NEG
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: PUSH
43233: LD_INT 2
43235: NEG
43236: PUSH
43237: LD_INT 0
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 2
43246: NEG
43247: PUSH
43248: LD_INT 1
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 3
43257: NEG
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 4
43268: NEG
43269: PUSH
43270: LD_INT 0
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 4
43279: NEG
43280: PUSH
43281: LD_INT 1
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 4
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 2
43303: NEG
43304: PUSH
43305: LD_INT 2
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 4
43314: NEG
43315: PUSH
43316: LD_INT 4
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 4
43326: NEG
43327: PUSH
43328: LD_INT 5
43330: NEG
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 3
43338: NEG
43339: PUSH
43340: LD_INT 4
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 3
43350: NEG
43351: PUSH
43352: LD_INT 3
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 4
43362: NEG
43363: PUSH
43364: LD_INT 3
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 5
43374: NEG
43375: PUSH
43376: LD_INT 4
43378: NEG
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 5
43386: NEG
43387: PUSH
43388: LD_INT 5
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 3
43398: NEG
43399: PUSH
43400: LD_INT 5
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 5
43410: NEG
43411: PUSH
43412: LD_INT 3
43414: NEG
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: LIST
43428: LIST
43429: LIST
43430: LIST
43431: LIST
43432: LIST
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: LIST
43444: LIST
43445: LIST
43446: LIST
43447: LIST
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: LIST
43465: LIST
43466: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43467: LD_ADDR_VAR 0 30
43471: PUSH
43472: LD_INT 4
43474: PUSH
43475: LD_INT 4
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 4
43484: PUSH
43485: LD_INT 3
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 5
43494: PUSH
43495: LD_INT 4
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 5
43504: PUSH
43505: LD_INT 5
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 5
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 3
43524: PUSH
43525: LD_INT 4
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: LD_INT 3
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 5
43544: PUSH
43545: LD_INT 3
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 3
43554: PUSH
43555: LD_INT 5
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 0
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 0
43574: PUSH
43575: LD_INT 2
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 1
43584: PUSH
43585: LD_INT 3
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 1
43594: PUSH
43595: LD_INT 4
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: LD_INT 4
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 1
43614: NEG
43615: PUSH
43616: LD_INT 3
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: LD_INT 4
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 2
43646: NEG
43647: PUSH
43648: LD_INT 2
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 4
43657: NEG
43658: PUSH
43659: LD_INT 0
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 4
43668: NEG
43669: PUSH
43670: LD_INT 1
43672: NEG
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: LD_INT 3
43680: NEG
43681: PUSH
43682: LD_INT 0
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 3
43691: NEG
43692: PUSH
43693: LD_INT 1
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 4
43702: NEG
43703: PUSH
43704: LD_INT 1
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 5
43713: NEG
43714: PUSH
43715: LD_INT 0
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: LD_INT 5
43724: NEG
43725: PUSH
43726: LD_INT 1
43728: NEG
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 5
43736: NEG
43737: PUSH
43738: LD_INT 2
43740: NEG
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 3
43748: NEG
43749: PUSH
43750: LD_INT 2
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 3
43759: NEG
43760: PUSH
43761: LD_INT 3
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: LD_INT 4
43775: NEG
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 2
43783: NEG
43784: PUSH
43785: LD_INT 3
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 2
43795: NEG
43796: PUSH
43797: LD_INT 2
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 3
43807: NEG
43808: PUSH
43809: LD_INT 2
43811: NEG
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 4
43819: NEG
43820: PUSH
43821: LD_INT 3
43823: NEG
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 4
43831: NEG
43832: PUSH
43833: LD_INT 4
43835: NEG
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 2
43843: NEG
43844: PUSH
43845: LD_INT 4
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 4
43855: NEG
43856: PUSH
43857: LD_INT 2
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 4
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: LD_INT 5
43881: NEG
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: LD_INT 4
43892: NEG
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: PUSH
43901: LD_INT 3
43903: NEG
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: LD_INT 3
43914: NEG
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: LD_INT 4
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 1
43934: NEG
43935: PUSH
43936: LD_INT 5
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 2
43946: PUSH
43947: LD_INT 3
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 2
43957: NEG
43958: PUSH
43959: LD_INT 5
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: LIST
43987: LIST
43988: LIST
43989: LIST
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: LIST
44003: LIST
44004: LIST
44005: LIST
44006: LIST
44007: LIST
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44014: LD_ADDR_VAR 0 31
44018: PUSH
44019: LD_INT 0
44021: PUSH
44022: LD_INT 4
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: LD_INT 3
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 1
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: LD_INT 5
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 0
44061: PUSH
44062: LD_INT 5
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: LD_INT 4
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 1
44082: NEG
44083: PUSH
44084: LD_INT 3
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 2
44093: PUSH
44094: LD_INT 5
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 2
44103: NEG
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 3
44114: NEG
44115: PUSH
44116: LD_INT 0
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PUSH
44123: LD_INT 3
44125: NEG
44126: PUSH
44127: LD_INT 1
44129: NEG
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 2
44137: NEG
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 2
44148: NEG
44149: PUSH
44150: LD_INT 1
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: LD_INT 3
44159: NEG
44160: PUSH
44161: LD_INT 1
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: LD_INT 0
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 4
44181: NEG
44182: PUSH
44183: LD_INT 1
44185: NEG
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: LD_INT 2
44197: NEG
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: NEG
44206: PUSH
44207: LD_INT 2
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 4
44216: NEG
44217: PUSH
44218: LD_INT 4
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 4
44228: NEG
44229: PUSH
44230: LD_INT 5
44232: NEG
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 3
44240: NEG
44241: PUSH
44242: LD_INT 4
44244: NEG
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 3
44252: NEG
44253: PUSH
44254: LD_INT 3
44256: NEG
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 4
44264: NEG
44265: PUSH
44266: LD_INT 3
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 5
44276: NEG
44277: PUSH
44278: LD_INT 4
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 5
44288: NEG
44289: PUSH
44290: LD_INT 5
44292: NEG
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 3
44300: NEG
44301: PUSH
44302: LD_INT 5
44304: NEG
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 5
44312: NEG
44313: PUSH
44314: LD_INT 3
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 0
44324: PUSH
44325: LD_INT 3
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 0
44335: PUSH
44336: LD_INT 4
44338: NEG
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 1
44346: PUSH
44347: LD_INT 3
44349: NEG
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 1
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 3
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 4
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 2
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 2
44414: NEG
44415: PUSH
44416: LD_INT 4
44418: NEG
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: LD_INT 0
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 4
44436: PUSH
44437: LD_INT 1
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 5
44447: PUSH
44448: LD_INT 0
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 5
44457: PUSH
44458: LD_INT 1
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 4
44467: PUSH
44468: LD_INT 1
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 3
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 3
44487: PUSH
44488: LD_INT 1
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 3
44498: PUSH
44499: LD_INT 2
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 5
44509: PUSH
44510: LD_INT 2
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44564: LD_ADDR_VAR 0 32
44568: PUSH
44569: LD_INT 4
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 4
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 3
44594: NEG
44595: PUSH
44596: LD_INT 0
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 3
44605: NEG
44606: PUSH
44607: LD_INT 1
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 4
44616: NEG
44617: PUSH
44618: LD_INT 1
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: LD_INT 0
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 5
44638: NEG
44639: PUSH
44640: LD_INT 1
44642: NEG
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 5
44650: NEG
44651: PUSH
44652: LD_INT 2
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: LD_INT 2
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 3
44673: NEG
44674: PUSH
44675: LD_INT 3
44677: NEG
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 3
44685: NEG
44686: PUSH
44687: LD_INT 4
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 2
44697: NEG
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 2
44709: NEG
44710: PUSH
44711: LD_INT 2
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 3
44721: NEG
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: LD_INT 3
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 4
44745: NEG
44746: PUSH
44747: LD_INT 4
44749: NEG
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 2
44757: NEG
44758: PUSH
44759: LD_INT 4
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 4
44769: NEG
44770: PUSH
44771: LD_INT 2
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 0
44781: PUSH
44782: LD_INT 4
44784: NEG
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 0
44792: PUSH
44793: LD_INT 5
44795: NEG
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: LD_INT 4
44806: NEG
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 1
44814: PUSH
44815: LD_INT 3
44817: NEG
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 3
44828: NEG
44829: PUSH
44830: EMPTY
44831: LIST
44832: LIST
44833: PUSH
44834: LD_INT 1
44836: NEG
44837: PUSH
44838: LD_INT 4
44840: NEG
44841: PUSH
44842: EMPTY
44843: LIST
44844: LIST
44845: PUSH
44846: LD_INT 1
44848: NEG
44849: PUSH
44850: LD_INT 5
44852: NEG
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: LD_INT 2
44860: PUSH
44861: LD_INT 3
44863: NEG
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 2
44871: NEG
44872: PUSH
44873: LD_INT 5
44875: NEG
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 3
44883: PUSH
44884: LD_INT 0
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 1
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 4
44904: PUSH
44905: LD_INT 0
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 4
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 3
44924: PUSH
44925: LD_INT 1
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 2
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 2
44944: PUSH
44945: LD_INT 1
44947: NEG
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 2
44955: PUSH
44956: LD_INT 2
44958: NEG
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 4
44966: PUSH
44967: LD_INT 2
44969: PUSH
44970: EMPTY
44971: LIST
44972: LIST
44973: PUSH
44974: LD_INT 4
44976: PUSH
44977: LD_INT 4
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 4
44986: PUSH
44987: LD_INT 3
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 5
44996: PUSH
44997: LD_INT 4
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: LD_INT 5
45006: PUSH
45007: LD_INT 5
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 4
45016: PUSH
45017: LD_INT 5
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 4
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 3
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 5
45046: PUSH
45047: LD_INT 3
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 5
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45111: LD_ADDR_VAR 0 33
45115: PUSH
45116: LD_INT 4
45118: NEG
45119: PUSH
45120: LD_INT 4
45122: NEG
45123: PUSH
45124: EMPTY
45125: LIST
45126: LIST
45127: PUSH
45128: LD_INT 4
45130: NEG
45131: PUSH
45132: LD_INT 5
45134: NEG
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 3
45142: NEG
45143: PUSH
45144: LD_INT 4
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 3
45154: NEG
45155: PUSH
45156: LD_INT 3
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 4
45166: NEG
45167: PUSH
45168: LD_INT 3
45170: NEG
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 5
45178: NEG
45179: PUSH
45180: LD_INT 4
45182: NEG
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 5
45190: NEG
45191: PUSH
45192: LD_INT 5
45194: NEG
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 3
45202: NEG
45203: PUSH
45204: LD_INT 5
45206: NEG
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 0
45226: PUSH
45227: LD_INT 3
45229: NEG
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 4
45240: NEG
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 1
45248: PUSH
45249: LD_INT 3
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 1
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: LD_INT 2
45273: NEG
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 1
45281: NEG
45282: PUSH
45283: LD_INT 3
45285: NEG
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 1
45293: NEG
45294: PUSH
45295: LD_INT 4
45297: NEG
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 2
45305: PUSH
45306: LD_INT 2
45308: NEG
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 2
45316: NEG
45317: PUSH
45318: LD_INT 4
45320: NEG
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 4
45328: PUSH
45329: LD_INT 0
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 4
45338: PUSH
45339: LD_INT 1
45341: NEG
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 5
45349: PUSH
45350: LD_INT 0
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 5
45359: PUSH
45360: LD_INT 1
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 4
45369: PUSH
45370: LD_INT 1
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 3
45379: PUSH
45380: LD_INT 0
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 3
45389: PUSH
45390: LD_INT 1
45392: NEG
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: LD_INT 3
45400: PUSH
45401: LD_INT 2
45403: NEG
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 5
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: PUSH
45422: LD_INT 3
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: LD_INT 2
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 4
45451: PUSH
45452: LD_INT 4
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: PUSH
45462: LD_INT 4
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 2
45471: PUSH
45472: LD_INT 3
45474: PUSH
45475: EMPTY
45476: LIST
45477: LIST
45478: PUSH
45479: LD_INT 2
45481: PUSH
45482: LD_INT 2
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: PUSH
45489: LD_INT 4
45491: PUSH
45492: LD_INT 2
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 2
45501: PUSH
45502: LD_INT 4
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 4
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 0
45521: PUSH
45522: LD_INT 3
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 1
45531: PUSH
45532: LD_INT 4
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 1
45541: PUSH
45542: LD_INT 5
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 0
45551: PUSH
45552: LD_INT 5
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 1
45561: NEG
45562: PUSH
45563: LD_INT 4
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 1
45572: NEG
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 2
45583: PUSH
45584: LD_INT 5
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 2
45593: NEG
45594: PUSH
45595: LD_INT 3
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45649: LD_ADDR_VAR 0 34
45653: PUSH
45654: LD_INT 0
45656: PUSH
45657: LD_INT 4
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: LD_INT 5
45670: NEG
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 1
45678: PUSH
45679: LD_INT 4
45681: NEG
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 1
45689: PUSH
45690: LD_INT 3
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 0
45700: PUSH
45701: LD_INT 3
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 1
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 1
45723: NEG
45724: PUSH
45725: LD_INT 5
45727: NEG
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 2
45735: PUSH
45736: LD_INT 3
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 2
45746: NEG
45747: PUSH
45748: LD_INT 5
45750: NEG
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 3
45758: PUSH
45759: LD_INT 0
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 1
45771: NEG
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 4
45779: PUSH
45780: LD_INT 0
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 4
45789: PUSH
45790: LD_INT 1
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 3
45799: PUSH
45800: LD_INT 1
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: LD_INT 0
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 2
45819: PUSH
45820: LD_INT 1
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 2
45830: PUSH
45831: LD_INT 2
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: LD_INT 2
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: LD_INT 4
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 4
45861: PUSH
45862: LD_INT 3
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 5
45871: PUSH
45872: LD_INT 4
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 5
45881: PUSH
45882: LD_INT 5
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_INT 4
45891: PUSH
45892: LD_INT 5
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 3
45901: PUSH
45902: LD_INT 4
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 3
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 5
45921: PUSH
45922: LD_INT 3
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 3
45931: PUSH
45932: LD_INT 5
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 0
45941: PUSH
45942: LD_INT 3
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 0
45951: PUSH
45952: LD_INT 2
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 1
45961: PUSH
45962: LD_INT 3
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 1
45971: PUSH
45972: LD_INT 4
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 0
45981: PUSH
45982: LD_INT 4
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 1
45991: NEG
45992: PUSH
45993: LD_INT 3
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 1
46002: NEG
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 2
46013: PUSH
46014: LD_INT 4
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: LD_INT 2
46023: NEG
46024: PUSH
46025: LD_INT 2
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 4
46034: NEG
46035: PUSH
46036: LD_INT 0
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 4
46045: NEG
46046: PUSH
46047: LD_INT 1
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 3
46057: NEG
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: NEG
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: LD_INT 1
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: PUSH
46088: LD_INT 5
46090: NEG
46091: PUSH
46092: LD_INT 0
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 5
46101: NEG
46102: PUSH
46103: LD_INT 1
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 5
46113: NEG
46114: PUSH
46115: LD_INT 2
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 3
46125: NEG
46126: PUSH
46127: LD_INT 2
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: ST_TO_ADDR
// end ; end ;
46181: GO 46184
46183: POP
// case btype of b_depot , b_warehouse :
46184: LD_VAR 0 1
46188: PUSH
46189: LD_INT 0
46191: DOUBLE
46192: EQUAL
46193: IFTRUE 46203
46195: LD_INT 1
46197: DOUBLE
46198: EQUAL
46199: IFTRUE 46203
46201: GO 46404
46203: POP
// case nation of nation_american :
46204: LD_VAR 0 5
46208: PUSH
46209: LD_INT 1
46211: DOUBLE
46212: EQUAL
46213: IFTRUE 46217
46215: GO 46273
46217: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46218: LD_ADDR_VAR 0 9
46222: PUSH
46223: LD_VAR 0 11
46227: PUSH
46228: LD_VAR 0 12
46232: PUSH
46233: LD_VAR 0 13
46237: PUSH
46238: LD_VAR 0 14
46242: PUSH
46243: LD_VAR 0 15
46247: PUSH
46248: LD_VAR 0 16
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: PUSH
46261: LD_VAR 0 4
46265: PUSH
46266: LD_INT 1
46268: PLUS
46269: ARRAY
46270: ST_TO_ADDR
46271: GO 46402
46273: LD_INT 2
46275: DOUBLE
46276: EQUAL
46277: IFTRUE 46281
46279: GO 46337
46281: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46282: LD_ADDR_VAR 0 9
46286: PUSH
46287: LD_VAR 0 17
46291: PUSH
46292: LD_VAR 0 18
46296: PUSH
46297: LD_VAR 0 19
46301: PUSH
46302: LD_VAR 0 20
46306: PUSH
46307: LD_VAR 0 21
46311: PUSH
46312: LD_VAR 0 22
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: PUSH
46325: LD_VAR 0 4
46329: PUSH
46330: LD_INT 1
46332: PLUS
46333: ARRAY
46334: ST_TO_ADDR
46335: GO 46402
46337: LD_INT 3
46339: DOUBLE
46340: EQUAL
46341: IFTRUE 46345
46343: GO 46401
46345: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46346: LD_ADDR_VAR 0 9
46350: PUSH
46351: LD_VAR 0 23
46355: PUSH
46356: LD_VAR 0 24
46360: PUSH
46361: LD_VAR 0 25
46365: PUSH
46366: LD_VAR 0 26
46370: PUSH
46371: LD_VAR 0 27
46375: PUSH
46376: LD_VAR 0 28
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: PUSH
46389: LD_VAR 0 4
46393: PUSH
46394: LD_INT 1
46396: PLUS
46397: ARRAY
46398: ST_TO_ADDR
46399: GO 46402
46401: POP
46402: GO 46951
46404: LD_INT 2
46406: DOUBLE
46407: EQUAL
46408: IFTRUE 46418
46410: LD_INT 3
46412: DOUBLE
46413: EQUAL
46414: IFTRUE 46418
46416: GO 46474
46418: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46419: LD_ADDR_VAR 0 9
46423: PUSH
46424: LD_VAR 0 29
46428: PUSH
46429: LD_VAR 0 30
46433: PUSH
46434: LD_VAR 0 31
46438: PUSH
46439: LD_VAR 0 32
46443: PUSH
46444: LD_VAR 0 33
46448: PUSH
46449: LD_VAR 0 34
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: PUSH
46462: LD_VAR 0 4
46466: PUSH
46467: LD_INT 1
46469: PLUS
46470: ARRAY
46471: ST_TO_ADDR
46472: GO 46951
46474: LD_INT 16
46476: DOUBLE
46477: EQUAL
46478: IFTRUE 46530
46480: LD_INT 17
46482: DOUBLE
46483: EQUAL
46484: IFTRUE 46530
46486: LD_INT 18
46488: DOUBLE
46489: EQUAL
46490: IFTRUE 46530
46492: LD_INT 19
46494: DOUBLE
46495: EQUAL
46496: IFTRUE 46530
46498: LD_INT 20
46500: DOUBLE
46501: EQUAL
46502: IFTRUE 46530
46504: LD_INT 21
46506: DOUBLE
46507: EQUAL
46508: IFTRUE 46530
46510: LD_INT 23
46512: DOUBLE
46513: EQUAL
46514: IFTRUE 46530
46516: LD_INT 24
46518: DOUBLE
46519: EQUAL
46520: IFTRUE 46530
46522: LD_INT 25
46524: DOUBLE
46525: EQUAL
46526: IFTRUE 46530
46528: GO 46586
46530: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46531: LD_ADDR_VAR 0 9
46535: PUSH
46536: LD_VAR 0 35
46540: PUSH
46541: LD_VAR 0 36
46545: PUSH
46546: LD_VAR 0 37
46550: PUSH
46551: LD_VAR 0 38
46555: PUSH
46556: LD_VAR 0 39
46560: PUSH
46561: LD_VAR 0 40
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: PUSH
46574: LD_VAR 0 4
46578: PUSH
46579: LD_INT 1
46581: PLUS
46582: ARRAY
46583: ST_TO_ADDR
46584: GO 46951
46586: LD_INT 6
46588: DOUBLE
46589: EQUAL
46590: IFTRUE 46642
46592: LD_INT 7
46594: DOUBLE
46595: EQUAL
46596: IFTRUE 46642
46598: LD_INT 8
46600: DOUBLE
46601: EQUAL
46602: IFTRUE 46642
46604: LD_INT 13
46606: DOUBLE
46607: EQUAL
46608: IFTRUE 46642
46610: LD_INT 12
46612: DOUBLE
46613: EQUAL
46614: IFTRUE 46642
46616: LD_INT 15
46618: DOUBLE
46619: EQUAL
46620: IFTRUE 46642
46622: LD_INT 11
46624: DOUBLE
46625: EQUAL
46626: IFTRUE 46642
46628: LD_INT 14
46630: DOUBLE
46631: EQUAL
46632: IFTRUE 46642
46634: LD_INT 10
46636: DOUBLE
46637: EQUAL
46638: IFTRUE 46642
46640: GO 46698
46642: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46643: LD_ADDR_VAR 0 9
46647: PUSH
46648: LD_VAR 0 41
46652: PUSH
46653: LD_VAR 0 42
46657: PUSH
46658: LD_VAR 0 43
46662: PUSH
46663: LD_VAR 0 44
46667: PUSH
46668: LD_VAR 0 45
46672: PUSH
46673: LD_VAR 0 46
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: PUSH
46686: LD_VAR 0 4
46690: PUSH
46691: LD_INT 1
46693: PLUS
46694: ARRAY
46695: ST_TO_ADDR
46696: GO 46951
46698: LD_INT 36
46700: DOUBLE
46701: EQUAL
46702: IFTRUE 46706
46704: GO 46762
46706: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46707: LD_ADDR_VAR 0 9
46711: PUSH
46712: LD_VAR 0 47
46716: PUSH
46717: LD_VAR 0 48
46721: PUSH
46722: LD_VAR 0 49
46726: PUSH
46727: LD_VAR 0 50
46731: PUSH
46732: LD_VAR 0 51
46736: PUSH
46737: LD_VAR 0 52
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: PUSH
46750: LD_VAR 0 4
46754: PUSH
46755: LD_INT 1
46757: PLUS
46758: ARRAY
46759: ST_TO_ADDR
46760: GO 46951
46762: LD_INT 4
46764: DOUBLE
46765: EQUAL
46766: IFTRUE 46788
46768: LD_INT 5
46770: DOUBLE
46771: EQUAL
46772: IFTRUE 46788
46774: LD_INT 34
46776: DOUBLE
46777: EQUAL
46778: IFTRUE 46788
46780: LD_INT 37
46782: DOUBLE
46783: EQUAL
46784: IFTRUE 46788
46786: GO 46844
46788: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46789: LD_ADDR_VAR 0 9
46793: PUSH
46794: LD_VAR 0 53
46798: PUSH
46799: LD_VAR 0 54
46803: PUSH
46804: LD_VAR 0 55
46808: PUSH
46809: LD_VAR 0 56
46813: PUSH
46814: LD_VAR 0 57
46818: PUSH
46819: LD_VAR 0 58
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: PUSH
46832: LD_VAR 0 4
46836: PUSH
46837: LD_INT 1
46839: PLUS
46840: ARRAY
46841: ST_TO_ADDR
46842: GO 46951
46844: LD_INT 31
46846: DOUBLE
46847: EQUAL
46848: IFTRUE 46894
46850: LD_INT 32
46852: DOUBLE
46853: EQUAL
46854: IFTRUE 46894
46856: LD_INT 33
46858: DOUBLE
46859: EQUAL
46860: IFTRUE 46894
46862: LD_INT 27
46864: DOUBLE
46865: EQUAL
46866: IFTRUE 46894
46868: LD_INT 26
46870: DOUBLE
46871: EQUAL
46872: IFTRUE 46894
46874: LD_INT 28
46876: DOUBLE
46877: EQUAL
46878: IFTRUE 46894
46880: LD_INT 29
46882: DOUBLE
46883: EQUAL
46884: IFTRUE 46894
46886: LD_INT 30
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 46950
46894: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
46895: LD_ADDR_VAR 0 9
46899: PUSH
46900: LD_VAR 0 59
46904: PUSH
46905: LD_VAR 0 60
46909: PUSH
46910: LD_VAR 0 61
46914: PUSH
46915: LD_VAR 0 62
46919: PUSH
46920: LD_VAR 0 63
46924: PUSH
46925: LD_VAR 0 64
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_INT 1
46945: PLUS
46946: ARRAY
46947: ST_TO_ADDR
46948: GO 46951
46950: POP
// temp_list2 = [ ] ;
46951: LD_ADDR_VAR 0 10
46955: PUSH
46956: EMPTY
46957: ST_TO_ADDR
// for i in temp_list do
46958: LD_ADDR_VAR 0 8
46962: PUSH
46963: LD_VAR 0 9
46967: PUSH
46968: FOR_IN
46969: IFFALSE 47021
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46971: LD_ADDR_VAR 0 10
46975: PUSH
46976: LD_VAR 0 10
46980: PUSH
46981: LD_VAR 0 8
46985: PUSH
46986: LD_INT 1
46988: ARRAY
46989: PUSH
46990: LD_VAR 0 2
46994: PLUS
46995: PUSH
46996: LD_VAR 0 8
47000: PUSH
47001: LD_INT 2
47003: ARRAY
47004: PUSH
47005: LD_VAR 0 3
47009: PLUS
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: EMPTY
47016: LIST
47017: ADD
47018: ST_TO_ADDR
47019: GO 46968
47021: POP
47022: POP
// result = temp_list2 ;
47023: LD_ADDR_VAR 0 7
47027: PUSH
47028: LD_VAR 0 10
47032: ST_TO_ADDR
// end ;
47033: LD_VAR 0 7
47037: RET
// export function EnemyInRange ( unit , dist ) ; begin
47038: LD_INT 0
47040: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47041: LD_ADDR_VAR 0 3
47045: PUSH
47046: LD_VAR 0 1
47050: PPUSH
47051: CALL_OW 255
47055: PPUSH
47056: LD_VAR 0 1
47060: PPUSH
47061: CALL_OW 250
47065: PPUSH
47066: LD_VAR 0 1
47070: PPUSH
47071: CALL_OW 251
47075: PPUSH
47076: LD_VAR 0 2
47080: PPUSH
47081: CALL 21166 0 4
47085: PUSH
47086: LD_INT 4
47088: ARRAY
47089: ST_TO_ADDR
// end ;
47090: LD_VAR 0 3
47094: RET
// export function PlayerSeeMe ( unit ) ; begin
47095: LD_INT 0
47097: PPUSH
// result := See ( your_side , unit ) ;
47098: LD_ADDR_VAR 0 2
47102: PUSH
47103: LD_OWVAR 2
47107: PPUSH
47108: LD_VAR 0 1
47112: PPUSH
47113: CALL_OW 292
47117: ST_TO_ADDR
// end ;
47118: LD_VAR 0 2
47122: RET
// export function ReverseDir ( unit ) ; begin
47123: LD_INT 0
47125: PPUSH
// if not unit then
47126: LD_VAR 0 1
47130: NOT
47131: IFFALSE 47135
// exit ;
47133: GO 47181
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47135: LD_ADDR_VAR 0 2
47139: PUSH
47140: LD_INT 3
47142: PUSH
47143: LD_INT 4
47145: PUSH
47146: LD_INT 5
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: LD_INT 1
47154: PUSH
47155: LD_INT 2
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: PUSH
47166: LD_VAR 0 1
47170: PPUSH
47171: CALL_OW 254
47175: PUSH
47176: LD_INT 1
47178: PLUS
47179: ARRAY
47180: ST_TO_ADDR
// end ;
47181: LD_VAR 0 2
47185: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47186: LD_INT 0
47188: PPUSH
47189: PPUSH
47190: PPUSH
47191: PPUSH
47192: PPUSH
// if not hexes then
47193: LD_VAR 0 2
47197: NOT
47198: IFFALSE 47202
// exit ;
47200: GO 47350
// dist := 9999 ;
47202: LD_ADDR_VAR 0 5
47206: PUSH
47207: LD_INT 9999
47209: ST_TO_ADDR
// for i = 1 to hexes do
47210: LD_ADDR_VAR 0 4
47214: PUSH
47215: DOUBLE
47216: LD_INT 1
47218: DEC
47219: ST_TO_ADDR
47220: LD_VAR 0 2
47224: PUSH
47225: FOR_TO
47226: IFFALSE 47338
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47228: LD_VAR 0 1
47232: PPUSH
47233: LD_VAR 0 2
47237: PUSH
47238: LD_VAR 0 4
47242: ARRAY
47243: PUSH
47244: LD_INT 1
47246: ARRAY
47247: PPUSH
47248: LD_VAR 0 2
47252: PUSH
47253: LD_VAR 0 4
47257: ARRAY
47258: PUSH
47259: LD_INT 2
47261: ARRAY
47262: PPUSH
47263: CALL_OW 297
47267: PUSH
47268: LD_VAR 0 5
47272: LESS
47273: IFFALSE 47336
// begin hex := hexes [ i ] ;
47275: LD_ADDR_VAR 0 7
47279: PUSH
47280: LD_VAR 0 2
47284: PUSH
47285: LD_VAR 0 4
47289: ARRAY
47290: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47291: LD_ADDR_VAR 0 5
47295: PUSH
47296: LD_VAR 0 1
47300: PPUSH
47301: LD_VAR 0 2
47305: PUSH
47306: LD_VAR 0 4
47310: ARRAY
47311: PUSH
47312: LD_INT 1
47314: ARRAY
47315: PPUSH
47316: LD_VAR 0 2
47320: PUSH
47321: LD_VAR 0 4
47325: ARRAY
47326: PUSH
47327: LD_INT 2
47329: ARRAY
47330: PPUSH
47331: CALL_OW 297
47335: ST_TO_ADDR
// end ; end ;
47336: GO 47225
47338: POP
47339: POP
// result := hex ;
47340: LD_ADDR_VAR 0 3
47344: PUSH
47345: LD_VAR 0 7
47349: ST_TO_ADDR
// end ;
47350: LD_VAR 0 3
47354: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47355: LD_INT 0
47357: PPUSH
47358: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47359: LD_VAR 0 1
47363: NOT
47364: PUSH
47365: LD_VAR 0 1
47369: PUSH
47370: LD_INT 21
47372: PUSH
47373: LD_INT 2
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 23
47382: PUSH
47383: LD_INT 2
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: PPUSH
47394: CALL_OW 69
47398: IN
47399: NOT
47400: OR
47401: IFFALSE 47405
// exit ;
47403: GO 47452
// for i = 1 to 3 do
47405: LD_ADDR_VAR 0 3
47409: PUSH
47410: DOUBLE
47411: LD_INT 1
47413: DEC
47414: ST_TO_ADDR
47415: LD_INT 3
47417: PUSH
47418: FOR_TO
47419: IFFALSE 47450
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47421: LD_VAR 0 1
47425: PPUSH
47426: CALL_OW 250
47430: PPUSH
47431: LD_VAR 0 1
47435: PPUSH
47436: CALL_OW 251
47440: PPUSH
47441: LD_INT 1
47443: PPUSH
47444: CALL_OW 453
47448: GO 47418
47450: POP
47451: POP
// end ;
47452: LD_VAR 0 2
47456: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47457: LD_INT 0
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
47463: PPUSH
47464: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47465: LD_VAR 0 1
47469: NOT
47470: PUSH
47471: LD_VAR 0 2
47475: NOT
47476: OR
47477: PUSH
47478: LD_VAR 0 1
47482: PPUSH
47483: CALL_OW 314
47487: OR
47488: IFFALSE 47492
// exit ;
47490: GO 47933
// x := GetX ( enemy_unit ) ;
47492: LD_ADDR_VAR 0 7
47496: PUSH
47497: LD_VAR 0 2
47501: PPUSH
47502: CALL_OW 250
47506: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47507: LD_ADDR_VAR 0 8
47511: PUSH
47512: LD_VAR 0 2
47516: PPUSH
47517: CALL_OW 251
47521: ST_TO_ADDR
// if not x or not y then
47522: LD_VAR 0 7
47526: NOT
47527: PUSH
47528: LD_VAR 0 8
47532: NOT
47533: OR
47534: IFFALSE 47538
// exit ;
47536: GO 47933
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47538: LD_ADDR_VAR 0 6
47542: PUSH
47543: LD_VAR 0 7
47547: PPUSH
47548: LD_INT 0
47550: PPUSH
47551: LD_INT 4
47553: PPUSH
47554: CALL_OW 272
47558: PUSH
47559: LD_VAR 0 8
47563: PPUSH
47564: LD_INT 0
47566: PPUSH
47567: LD_INT 4
47569: PPUSH
47570: CALL_OW 273
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: LD_VAR 0 7
47583: PPUSH
47584: LD_INT 1
47586: PPUSH
47587: LD_INT 4
47589: PPUSH
47590: CALL_OW 272
47594: PUSH
47595: LD_VAR 0 8
47599: PPUSH
47600: LD_INT 1
47602: PPUSH
47603: LD_INT 4
47605: PPUSH
47606: CALL_OW 273
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: PUSH
47615: LD_VAR 0 7
47619: PPUSH
47620: LD_INT 2
47622: PPUSH
47623: LD_INT 4
47625: PPUSH
47626: CALL_OW 272
47630: PUSH
47631: LD_VAR 0 8
47635: PPUSH
47636: LD_INT 2
47638: PPUSH
47639: LD_INT 4
47641: PPUSH
47642: CALL_OW 273
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_VAR 0 7
47655: PPUSH
47656: LD_INT 3
47658: PPUSH
47659: LD_INT 4
47661: PPUSH
47662: CALL_OW 272
47666: PUSH
47667: LD_VAR 0 8
47671: PPUSH
47672: LD_INT 3
47674: PPUSH
47675: LD_INT 4
47677: PPUSH
47678: CALL_OW 273
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: PUSH
47687: LD_VAR 0 7
47691: PPUSH
47692: LD_INT 4
47694: PPUSH
47695: LD_INT 4
47697: PPUSH
47698: CALL_OW 272
47702: PUSH
47703: LD_VAR 0 8
47707: PPUSH
47708: LD_INT 4
47710: PPUSH
47711: LD_INT 4
47713: PPUSH
47714: CALL_OW 273
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_VAR 0 7
47727: PPUSH
47728: LD_INT 5
47730: PPUSH
47731: LD_INT 4
47733: PPUSH
47734: CALL_OW 272
47738: PUSH
47739: LD_VAR 0 8
47743: PPUSH
47744: LD_INT 5
47746: PPUSH
47747: LD_INT 4
47749: PPUSH
47750: CALL_OW 273
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: ST_TO_ADDR
// for i = tmp downto 1 do
47767: LD_ADDR_VAR 0 4
47771: PUSH
47772: DOUBLE
47773: LD_VAR 0 6
47777: INC
47778: ST_TO_ADDR
47779: LD_INT 1
47781: PUSH
47782: FOR_DOWNTO
47783: IFFALSE 47884
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47785: LD_VAR 0 6
47789: PUSH
47790: LD_VAR 0 4
47794: ARRAY
47795: PUSH
47796: LD_INT 1
47798: ARRAY
47799: PPUSH
47800: LD_VAR 0 6
47804: PUSH
47805: LD_VAR 0 4
47809: ARRAY
47810: PUSH
47811: LD_INT 2
47813: ARRAY
47814: PPUSH
47815: CALL_OW 488
47819: NOT
47820: PUSH
47821: LD_VAR 0 6
47825: PUSH
47826: LD_VAR 0 4
47830: ARRAY
47831: PUSH
47832: LD_INT 1
47834: ARRAY
47835: PPUSH
47836: LD_VAR 0 6
47840: PUSH
47841: LD_VAR 0 4
47845: ARRAY
47846: PUSH
47847: LD_INT 2
47849: ARRAY
47850: PPUSH
47851: CALL_OW 428
47855: PUSH
47856: LD_INT 0
47858: NONEQUAL
47859: OR
47860: IFFALSE 47882
// tmp := Delete ( tmp , i ) ;
47862: LD_ADDR_VAR 0 6
47866: PUSH
47867: LD_VAR 0 6
47871: PPUSH
47872: LD_VAR 0 4
47876: PPUSH
47877: CALL_OW 3
47881: ST_TO_ADDR
47882: GO 47782
47884: POP
47885: POP
// j := GetClosestHex ( unit , tmp ) ;
47886: LD_ADDR_VAR 0 5
47890: PUSH
47891: LD_VAR 0 1
47895: PPUSH
47896: LD_VAR 0 6
47900: PPUSH
47901: CALL 47186 0 2
47905: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47906: LD_VAR 0 1
47910: PPUSH
47911: LD_VAR 0 5
47915: PUSH
47916: LD_INT 1
47918: ARRAY
47919: PPUSH
47920: LD_VAR 0 5
47924: PUSH
47925: LD_INT 2
47927: ARRAY
47928: PPUSH
47929: CALL_OW 111
// end ;
47933: LD_VAR 0 3
47937: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47938: LD_INT 0
47940: PPUSH
47941: PPUSH
47942: PPUSH
// uc_side = 0 ;
47943: LD_ADDR_OWVAR 20
47947: PUSH
47948: LD_INT 0
47950: ST_TO_ADDR
// uc_nation = 0 ;
47951: LD_ADDR_OWVAR 21
47955: PUSH
47956: LD_INT 0
47958: ST_TO_ADDR
// InitHc ;
47959: CALL_OW 19
// InitVc ;
47963: CALL_OW 20
// if mastodonts then
47967: LD_VAR 0 6
47971: IFFALSE 48038
// for i = 1 to mastodonts do
47973: LD_ADDR_VAR 0 11
47977: PUSH
47978: DOUBLE
47979: LD_INT 1
47981: DEC
47982: ST_TO_ADDR
47983: LD_VAR 0 6
47987: PUSH
47988: FOR_TO
47989: IFFALSE 48036
// begin vc_chassis := 31 ;
47991: LD_ADDR_OWVAR 37
47995: PUSH
47996: LD_INT 31
47998: ST_TO_ADDR
// vc_control := control_rider ;
47999: LD_ADDR_OWVAR 38
48003: PUSH
48004: LD_INT 4
48006: ST_TO_ADDR
// animal := CreateVehicle ;
48007: LD_ADDR_VAR 0 12
48011: PUSH
48012: CALL_OW 45
48016: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48017: LD_VAR 0 12
48021: PPUSH
48022: LD_VAR 0 8
48026: PPUSH
48027: LD_INT 0
48029: PPUSH
48030: CALL 54744 0 3
// end ;
48034: GO 47988
48036: POP
48037: POP
// if horses then
48038: LD_VAR 0 5
48042: IFFALSE 48109
// for i = 1 to horses do
48044: LD_ADDR_VAR 0 11
48048: PUSH
48049: DOUBLE
48050: LD_INT 1
48052: DEC
48053: ST_TO_ADDR
48054: LD_VAR 0 5
48058: PUSH
48059: FOR_TO
48060: IFFALSE 48107
// begin hc_class := 21 ;
48062: LD_ADDR_OWVAR 28
48066: PUSH
48067: LD_INT 21
48069: ST_TO_ADDR
// hc_gallery :=  ;
48070: LD_ADDR_OWVAR 33
48074: PUSH
48075: LD_STRING 
48077: ST_TO_ADDR
// animal := CreateHuman ;
48078: LD_ADDR_VAR 0 12
48082: PUSH
48083: CALL_OW 44
48087: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48088: LD_VAR 0 12
48092: PPUSH
48093: LD_VAR 0 8
48097: PPUSH
48098: LD_INT 0
48100: PPUSH
48101: CALL 54744 0 3
// end ;
48105: GO 48059
48107: POP
48108: POP
// if birds then
48109: LD_VAR 0 1
48113: IFFALSE 48180
// for i = 1 to birds do
48115: LD_ADDR_VAR 0 11
48119: PUSH
48120: DOUBLE
48121: LD_INT 1
48123: DEC
48124: ST_TO_ADDR
48125: LD_VAR 0 1
48129: PUSH
48130: FOR_TO
48131: IFFALSE 48178
// begin hc_class = 18 ;
48133: LD_ADDR_OWVAR 28
48137: PUSH
48138: LD_INT 18
48140: ST_TO_ADDR
// hc_gallery =  ;
48141: LD_ADDR_OWVAR 33
48145: PUSH
48146: LD_STRING 
48148: ST_TO_ADDR
// animal := CreateHuman ;
48149: LD_ADDR_VAR 0 12
48153: PUSH
48154: CALL_OW 44
48158: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48159: LD_VAR 0 12
48163: PPUSH
48164: LD_VAR 0 8
48168: PPUSH
48169: LD_INT 0
48171: PPUSH
48172: CALL 54744 0 3
// end ;
48176: GO 48130
48178: POP
48179: POP
// if tigers then
48180: LD_VAR 0 2
48184: IFFALSE 48268
// for i = 1 to tigers do
48186: LD_ADDR_VAR 0 11
48190: PUSH
48191: DOUBLE
48192: LD_INT 1
48194: DEC
48195: ST_TO_ADDR
48196: LD_VAR 0 2
48200: PUSH
48201: FOR_TO
48202: IFFALSE 48266
// begin hc_class = class_tiger ;
48204: LD_ADDR_OWVAR 28
48208: PUSH
48209: LD_INT 14
48211: ST_TO_ADDR
// hc_gallery =  ;
48212: LD_ADDR_OWVAR 33
48216: PUSH
48217: LD_STRING 
48219: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48220: LD_ADDR_OWVAR 35
48224: PUSH
48225: LD_INT 7
48227: NEG
48228: PPUSH
48229: LD_INT 7
48231: PPUSH
48232: CALL_OW 12
48236: ST_TO_ADDR
// animal := CreateHuman ;
48237: LD_ADDR_VAR 0 12
48241: PUSH
48242: CALL_OW 44
48246: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48247: LD_VAR 0 12
48251: PPUSH
48252: LD_VAR 0 8
48256: PPUSH
48257: LD_INT 0
48259: PPUSH
48260: CALL 54744 0 3
// end ;
48264: GO 48201
48266: POP
48267: POP
// if apemans then
48268: LD_VAR 0 3
48272: IFFALSE 48395
// for i = 1 to apemans do
48274: LD_ADDR_VAR 0 11
48278: PUSH
48279: DOUBLE
48280: LD_INT 1
48282: DEC
48283: ST_TO_ADDR
48284: LD_VAR 0 3
48288: PUSH
48289: FOR_TO
48290: IFFALSE 48393
// begin hc_class = class_apeman ;
48292: LD_ADDR_OWVAR 28
48296: PUSH
48297: LD_INT 12
48299: ST_TO_ADDR
// hc_gallery =  ;
48300: LD_ADDR_OWVAR 33
48304: PUSH
48305: LD_STRING 
48307: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48308: LD_ADDR_OWVAR 35
48312: PUSH
48313: LD_INT 5
48315: NEG
48316: PPUSH
48317: LD_INT 5
48319: PPUSH
48320: CALL_OW 12
48324: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48325: LD_ADDR_OWVAR 31
48329: PUSH
48330: LD_INT 1
48332: PPUSH
48333: LD_INT 3
48335: PPUSH
48336: CALL_OW 12
48340: PUSH
48341: LD_INT 1
48343: PPUSH
48344: LD_INT 3
48346: PPUSH
48347: CALL_OW 12
48351: PUSH
48352: LD_INT 0
48354: PUSH
48355: LD_INT 0
48357: PUSH
48358: EMPTY
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: ST_TO_ADDR
// animal := CreateHuman ;
48364: LD_ADDR_VAR 0 12
48368: PUSH
48369: CALL_OW 44
48373: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48374: LD_VAR 0 12
48378: PPUSH
48379: LD_VAR 0 8
48383: PPUSH
48384: LD_INT 0
48386: PPUSH
48387: CALL 54744 0 3
// end ;
48391: GO 48289
48393: POP
48394: POP
// if enchidnas then
48395: LD_VAR 0 4
48399: IFFALSE 48466
// for i = 1 to enchidnas do
48401: LD_ADDR_VAR 0 11
48405: PUSH
48406: DOUBLE
48407: LD_INT 1
48409: DEC
48410: ST_TO_ADDR
48411: LD_VAR 0 4
48415: PUSH
48416: FOR_TO
48417: IFFALSE 48464
// begin hc_class = 13 ;
48419: LD_ADDR_OWVAR 28
48423: PUSH
48424: LD_INT 13
48426: ST_TO_ADDR
// hc_gallery =  ;
48427: LD_ADDR_OWVAR 33
48431: PUSH
48432: LD_STRING 
48434: ST_TO_ADDR
// animal := CreateHuman ;
48435: LD_ADDR_VAR 0 12
48439: PUSH
48440: CALL_OW 44
48444: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48445: LD_VAR 0 12
48449: PPUSH
48450: LD_VAR 0 8
48454: PPUSH
48455: LD_INT 0
48457: PPUSH
48458: CALL 54744 0 3
// end ;
48462: GO 48416
48464: POP
48465: POP
// if fishes then
48466: LD_VAR 0 7
48470: IFFALSE 48537
// for i = 1 to fishes do
48472: LD_ADDR_VAR 0 11
48476: PUSH
48477: DOUBLE
48478: LD_INT 1
48480: DEC
48481: ST_TO_ADDR
48482: LD_VAR 0 7
48486: PUSH
48487: FOR_TO
48488: IFFALSE 48535
// begin hc_class = 20 ;
48490: LD_ADDR_OWVAR 28
48494: PUSH
48495: LD_INT 20
48497: ST_TO_ADDR
// hc_gallery =  ;
48498: LD_ADDR_OWVAR 33
48502: PUSH
48503: LD_STRING 
48505: ST_TO_ADDR
// animal := CreateHuman ;
48506: LD_ADDR_VAR 0 12
48510: PUSH
48511: CALL_OW 44
48515: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48516: LD_VAR 0 12
48520: PPUSH
48521: LD_VAR 0 9
48525: PPUSH
48526: LD_INT 0
48528: PPUSH
48529: CALL 54744 0 3
// end ;
48533: GO 48487
48535: POP
48536: POP
// end ;
48537: LD_VAR 0 10
48541: RET
// export function WantHeal ( sci , unit ) ; begin
48542: LD_INT 0
48544: PPUSH
// if GetTaskList ( sci ) > 0 then
48545: LD_VAR 0 1
48549: PPUSH
48550: CALL_OW 437
48554: PUSH
48555: LD_INT 0
48557: GREATER
48558: IFFALSE 48628
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48560: LD_VAR 0 1
48564: PPUSH
48565: CALL_OW 437
48569: PUSH
48570: LD_INT 1
48572: ARRAY
48573: PUSH
48574: LD_INT 1
48576: ARRAY
48577: PUSH
48578: LD_STRING l
48580: EQUAL
48581: PUSH
48582: LD_VAR 0 1
48586: PPUSH
48587: CALL_OW 437
48591: PUSH
48592: LD_INT 1
48594: ARRAY
48595: PUSH
48596: LD_INT 4
48598: ARRAY
48599: PUSH
48600: LD_VAR 0 2
48604: EQUAL
48605: AND
48606: IFFALSE 48618
// result := true else
48608: LD_ADDR_VAR 0 3
48612: PUSH
48613: LD_INT 1
48615: ST_TO_ADDR
48616: GO 48626
// result := false ;
48618: LD_ADDR_VAR 0 3
48622: PUSH
48623: LD_INT 0
48625: ST_TO_ADDR
// end else
48626: GO 48636
// result := false ;
48628: LD_ADDR_VAR 0 3
48632: PUSH
48633: LD_INT 0
48635: ST_TO_ADDR
// end ;
48636: LD_VAR 0 3
48640: RET
// export function HealTarget ( sci ) ; begin
48641: LD_INT 0
48643: PPUSH
// if not sci then
48644: LD_VAR 0 1
48648: NOT
48649: IFFALSE 48653
// exit ;
48651: GO 48718
// result := 0 ;
48653: LD_ADDR_VAR 0 2
48657: PUSH
48658: LD_INT 0
48660: ST_TO_ADDR
// if GetTaskList ( sci ) then
48661: LD_VAR 0 1
48665: PPUSH
48666: CALL_OW 437
48670: IFFALSE 48718
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48672: LD_VAR 0 1
48676: PPUSH
48677: CALL_OW 437
48681: PUSH
48682: LD_INT 1
48684: ARRAY
48685: PUSH
48686: LD_INT 1
48688: ARRAY
48689: PUSH
48690: LD_STRING l
48692: EQUAL
48693: IFFALSE 48718
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48695: LD_ADDR_VAR 0 2
48699: PUSH
48700: LD_VAR 0 1
48704: PPUSH
48705: CALL_OW 437
48709: PUSH
48710: LD_INT 1
48712: ARRAY
48713: PUSH
48714: LD_INT 4
48716: ARRAY
48717: ST_TO_ADDR
// end ;
48718: LD_VAR 0 2
48722: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
48723: LD_INT 0
48725: PPUSH
48726: PPUSH
48727: PPUSH
48728: PPUSH
48729: PPUSH
48730: PPUSH
48731: PPUSH
48732: PPUSH
48733: PPUSH
48734: PPUSH
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
48744: PPUSH
48745: PPUSH
48746: PPUSH
48747: PPUSH
48748: PPUSH
48749: PPUSH
48750: PPUSH
48751: PPUSH
48752: PPUSH
48753: PPUSH
48754: PPUSH
48755: PPUSH
48756: PPUSH
48757: PPUSH
// if not list then
48758: LD_VAR 0 1
48762: NOT
48763: IFFALSE 48767
// exit ;
48765: GO 53355
// base := list [ 1 ] ;
48767: LD_ADDR_VAR 0 3
48771: PUSH
48772: LD_VAR 0 1
48776: PUSH
48777: LD_INT 1
48779: ARRAY
48780: ST_TO_ADDR
// group := list [ 2 ] ;
48781: LD_ADDR_VAR 0 4
48785: PUSH
48786: LD_VAR 0 1
48790: PUSH
48791: LD_INT 2
48793: ARRAY
48794: ST_TO_ADDR
// path := list [ 3 ] ;
48795: LD_ADDR_VAR 0 5
48799: PUSH
48800: LD_VAR 0 1
48804: PUSH
48805: LD_INT 3
48807: ARRAY
48808: ST_TO_ADDR
// flags := list [ 4 ] ;
48809: LD_ADDR_VAR 0 6
48813: PUSH
48814: LD_VAR 0 1
48818: PUSH
48819: LD_INT 4
48821: ARRAY
48822: ST_TO_ADDR
// mined := [ ] ;
48823: LD_ADDR_VAR 0 27
48827: PUSH
48828: EMPTY
48829: ST_TO_ADDR
// bombed := [ ] ;
48830: LD_ADDR_VAR 0 28
48834: PUSH
48835: EMPTY
48836: ST_TO_ADDR
// healers := [ ] ;
48837: LD_ADDR_VAR 0 31
48841: PUSH
48842: EMPTY
48843: ST_TO_ADDR
// to_heal := [ ] ;
48844: LD_ADDR_VAR 0 30
48848: PUSH
48849: EMPTY
48850: ST_TO_ADDR
// repairs := [ ] ;
48851: LD_ADDR_VAR 0 33
48855: PUSH
48856: EMPTY
48857: ST_TO_ADDR
// to_repair := [ ] ;
48858: LD_ADDR_VAR 0 32
48862: PUSH
48863: EMPTY
48864: ST_TO_ADDR
// if not group or not path then
48865: LD_VAR 0 4
48869: NOT
48870: PUSH
48871: LD_VAR 0 5
48875: NOT
48876: OR
48877: IFFALSE 48881
// exit ;
48879: GO 53355
// if flags then
48881: LD_VAR 0 6
48885: IFFALSE 49029
// begin f_ignore_area := flags [ 1 ] ;
48887: LD_ADDR_VAR 0 17
48891: PUSH
48892: LD_VAR 0 6
48896: PUSH
48897: LD_INT 1
48899: ARRAY
48900: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
48901: LD_ADDR_VAR 0 18
48905: PUSH
48906: LD_VAR 0 6
48910: PUSH
48911: LD_INT 2
48913: ARRAY
48914: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
48915: LD_ADDR_VAR 0 19
48919: PUSH
48920: LD_VAR 0 6
48924: PUSH
48925: LD_INT 3
48927: ARRAY
48928: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
48929: LD_ADDR_VAR 0 20
48933: PUSH
48934: LD_VAR 0 6
48938: PUSH
48939: LD_INT 4
48941: ARRAY
48942: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
48943: LD_ADDR_VAR 0 21
48947: PUSH
48948: LD_VAR 0 6
48952: PUSH
48953: LD_INT 5
48955: ARRAY
48956: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
48957: LD_ADDR_VAR 0 22
48961: PUSH
48962: LD_VAR 0 6
48966: PUSH
48967: LD_INT 6
48969: ARRAY
48970: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
48971: LD_ADDR_VAR 0 23
48975: PUSH
48976: LD_VAR 0 6
48980: PUSH
48981: LD_INT 7
48983: ARRAY
48984: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
48985: LD_ADDR_VAR 0 24
48989: PUSH
48990: LD_VAR 0 6
48994: PUSH
48995: LD_INT 8
48997: ARRAY
48998: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
48999: LD_ADDR_VAR 0 25
49003: PUSH
49004: LD_VAR 0 6
49008: PUSH
49009: LD_INT 9
49011: ARRAY
49012: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49013: LD_ADDR_VAR 0 26
49017: PUSH
49018: LD_VAR 0 6
49022: PUSH
49023: LD_INT 10
49025: ARRAY
49026: ST_TO_ADDR
// end else
49027: GO 49109
// begin f_ignore_area := false ;
49029: LD_ADDR_VAR 0 17
49033: PUSH
49034: LD_INT 0
49036: ST_TO_ADDR
// f_capture := false ;
49037: LD_ADDR_VAR 0 18
49041: PUSH
49042: LD_INT 0
49044: ST_TO_ADDR
// f_ignore_civ := false ;
49045: LD_ADDR_VAR 0 19
49049: PUSH
49050: LD_INT 0
49052: ST_TO_ADDR
// f_murder := false ;
49053: LD_ADDR_VAR 0 20
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// f_mines := false ;
49061: LD_ADDR_VAR 0 21
49065: PUSH
49066: LD_INT 0
49068: ST_TO_ADDR
// f_repair := false ;
49069: LD_ADDR_VAR 0 22
49073: PUSH
49074: LD_INT 0
49076: ST_TO_ADDR
// f_heal := false ;
49077: LD_ADDR_VAR 0 23
49081: PUSH
49082: LD_INT 0
49084: ST_TO_ADDR
// f_spacetime := false ;
49085: LD_ADDR_VAR 0 24
49089: PUSH
49090: LD_INT 0
49092: ST_TO_ADDR
// f_attack_depot := false ;
49093: LD_ADDR_VAR 0 25
49097: PUSH
49098: LD_INT 0
49100: ST_TO_ADDR
// f_crawl := false ;
49101: LD_ADDR_VAR 0 26
49105: PUSH
49106: LD_INT 0
49108: ST_TO_ADDR
// end ; if f_heal then
49109: LD_VAR 0 23
49113: IFFALSE 49140
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49115: LD_ADDR_VAR 0 31
49119: PUSH
49120: LD_VAR 0 4
49124: PPUSH
49125: LD_INT 25
49127: PUSH
49128: LD_INT 4
49130: PUSH
49131: EMPTY
49132: LIST
49133: LIST
49134: PPUSH
49135: CALL_OW 72
49139: ST_TO_ADDR
// if f_repair then
49140: LD_VAR 0 22
49144: IFFALSE 49171
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49146: LD_ADDR_VAR 0 33
49150: PUSH
49151: LD_VAR 0 4
49155: PPUSH
49156: LD_INT 25
49158: PUSH
49159: LD_INT 3
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PPUSH
49166: CALL_OW 72
49170: ST_TO_ADDR
// units_path := [ ] ;
49171: LD_ADDR_VAR 0 16
49175: PUSH
49176: EMPTY
49177: ST_TO_ADDR
// for i = 1 to group do
49178: LD_ADDR_VAR 0 7
49182: PUSH
49183: DOUBLE
49184: LD_INT 1
49186: DEC
49187: ST_TO_ADDR
49188: LD_VAR 0 4
49192: PUSH
49193: FOR_TO
49194: IFFALSE 49223
// units_path := Replace ( units_path , i , path ) ;
49196: LD_ADDR_VAR 0 16
49200: PUSH
49201: LD_VAR 0 16
49205: PPUSH
49206: LD_VAR 0 7
49210: PPUSH
49211: LD_VAR 0 5
49215: PPUSH
49216: CALL_OW 1
49220: ST_TO_ADDR
49221: GO 49193
49223: POP
49224: POP
// repeat for i = group downto 1 do
49225: LD_ADDR_VAR 0 7
49229: PUSH
49230: DOUBLE
49231: LD_VAR 0 4
49235: INC
49236: ST_TO_ADDR
49237: LD_INT 1
49239: PUSH
49240: FOR_DOWNTO
49241: IFFALSE 53337
// begin wait ( 5 ) ;
49243: LD_INT 5
49245: PPUSH
49246: CALL_OW 67
// tmp := [ ] ;
49250: LD_ADDR_VAR 0 14
49254: PUSH
49255: EMPTY
49256: ST_TO_ADDR
// attacking := false ;
49257: LD_ADDR_VAR 0 29
49261: PUSH
49262: LD_INT 0
49264: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49265: LD_VAR 0 4
49269: PUSH
49270: LD_VAR 0 7
49274: ARRAY
49275: PPUSH
49276: CALL_OW 301
49280: PUSH
49281: LD_VAR 0 4
49285: PUSH
49286: LD_VAR 0 7
49290: ARRAY
49291: NOT
49292: OR
49293: IFFALSE 49402
// begin if GetType ( group [ i ] ) = unit_human then
49295: LD_VAR 0 4
49299: PUSH
49300: LD_VAR 0 7
49304: ARRAY
49305: PPUSH
49306: CALL_OW 247
49310: PUSH
49311: LD_INT 1
49313: EQUAL
49314: IFFALSE 49360
// begin to_heal := to_heal diff group [ i ] ;
49316: LD_ADDR_VAR 0 30
49320: PUSH
49321: LD_VAR 0 30
49325: PUSH
49326: LD_VAR 0 4
49330: PUSH
49331: LD_VAR 0 7
49335: ARRAY
49336: DIFF
49337: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49338: LD_ADDR_VAR 0 31
49342: PUSH
49343: LD_VAR 0 31
49347: PUSH
49348: LD_VAR 0 4
49352: PUSH
49353: LD_VAR 0 7
49357: ARRAY
49358: DIFF
49359: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49360: LD_ADDR_VAR 0 4
49364: PUSH
49365: LD_VAR 0 4
49369: PPUSH
49370: LD_VAR 0 7
49374: PPUSH
49375: CALL_OW 3
49379: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49380: LD_ADDR_VAR 0 16
49384: PUSH
49385: LD_VAR 0 16
49389: PPUSH
49390: LD_VAR 0 7
49394: PPUSH
49395: CALL_OW 3
49399: ST_TO_ADDR
// continue ;
49400: GO 49240
// end ; if f_repair then
49402: LD_VAR 0 22
49406: IFFALSE 49895
// begin if GetType ( group [ i ] ) = unit_vehicle then
49408: LD_VAR 0 4
49412: PUSH
49413: LD_VAR 0 7
49417: ARRAY
49418: PPUSH
49419: CALL_OW 247
49423: PUSH
49424: LD_INT 2
49426: EQUAL
49427: IFFALSE 49617
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49429: LD_VAR 0 4
49433: PUSH
49434: LD_VAR 0 7
49438: ARRAY
49439: PPUSH
49440: CALL_OW 256
49444: PUSH
49445: LD_INT 700
49447: LESS
49448: PUSH
49449: LD_VAR 0 4
49453: PUSH
49454: LD_VAR 0 7
49458: ARRAY
49459: PUSH
49460: LD_VAR 0 32
49464: IN
49465: NOT
49466: AND
49467: IFFALSE 49491
// to_repair := to_repair union group [ i ] ;
49469: LD_ADDR_VAR 0 32
49473: PUSH
49474: LD_VAR 0 32
49478: PUSH
49479: LD_VAR 0 4
49483: PUSH
49484: LD_VAR 0 7
49488: ARRAY
49489: UNION
49490: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49491: LD_VAR 0 4
49495: PUSH
49496: LD_VAR 0 7
49500: ARRAY
49501: PPUSH
49502: CALL_OW 256
49506: PUSH
49507: LD_INT 1000
49509: EQUAL
49510: PUSH
49511: LD_VAR 0 4
49515: PUSH
49516: LD_VAR 0 7
49520: ARRAY
49521: PUSH
49522: LD_VAR 0 32
49526: IN
49527: AND
49528: IFFALSE 49552
// to_repair := to_repair diff group [ i ] ;
49530: LD_ADDR_VAR 0 32
49534: PUSH
49535: LD_VAR 0 32
49539: PUSH
49540: LD_VAR 0 4
49544: PUSH
49545: LD_VAR 0 7
49549: ARRAY
49550: DIFF
49551: ST_TO_ADDR
// if group [ i ] in to_repair then
49552: LD_VAR 0 4
49556: PUSH
49557: LD_VAR 0 7
49561: ARRAY
49562: PUSH
49563: LD_VAR 0 32
49567: IN
49568: IFFALSE 49615
// begin if not IsInArea ( group [ i ] , f_repair ) then
49570: LD_VAR 0 4
49574: PUSH
49575: LD_VAR 0 7
49579: ARRAY
49580: PPUSH
49581: LD_VAR 0 22
49585: PPUSH
49586: CALL_OW 308
49590: NOT
49591: IFFALSE 49613
// ComMoveToArea ( group [ i ] , f_repair ) ;
49593: LD_VAR 0 4
49597: PUSH
49598: LD_VAR 0 7
49602: ARRAY
49603: PPUSH
49604: LD_VAR 0 22
49608: PPUSH
49609: CALL_OW 113
// continue ;
49613: GO 49240
// end ; end else
49615: GO 49895
// if group [ i ] in repairs then
49617: LD_VAR 0 4
49621: PUSH
49622: LD_VAR 0 7
49626: ARRAY
49627: PUSH
49628: LD_VAR 0 33
49632: IN
49633: IFFALSE 49895
// begin if IsInUnit ( group [ i ] ) then
49635: LD_VAR 0 4
49639: PUSH
49640: LD_VAR 0 7
49644: ARRAY
49645: PPUSH
49646: CALL_OW 310
49650: IFFALSE 49718
// begin z := IsInUnit ( group [ i ] ) ;
49652: LD_ADDR_VAR 0 13
49656: PUSH
49657: LD_VAR 0 4
49661: PUSH
49662: LD_VAR 0 7
49666: ARRAY
49667: PPUSH
49668: CALL_OW 310
49672: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49673: LD_VAR 0 13
49677: PUSH
49678: LD_VAR 0 32
49682: IN
49683: PUSH
49684: LD_VAR 0 13
49688: PPUSH
49689: LD_VAR 0 22
49693: PPUSH
49694: CALL_OW 308
49698: AND
49699: IFFALSE 49716
// ComExitVehicle ( group [ i ] ) ;
49701: LD_VAR 0 4
49705: PUSH
49706: LD_VAR 0 7
49710: ARRAY
49711: PPUSH
49712: CALL_OW 121
// end else
49716: GO 49895
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
49718: LD_ADDR_VAR 0 13
49722: PUSH
49723: LD_VAR 0 4
49727: PPUSH
49728: LD_INT 95
49730: PUSH
49731: LD_VAR 0 22
49735: PUSH
49736: EMPTY
49737: LIST
49738: LIST
49739: PUSH
49740: LD_INT 58
49742: PUSH
49743: EMPTY
49744: LIST
49745: PUSH
49746: EMPTY
49747: LIST
49748: LIST
49749: PPUSH
49750: CALL_OW 72
49754: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
49755: LD_VAR 0 4
49759: PUSH
49760: LD_VAR 0 7
49764: ARRAY
49765: PPUSH
49766: CALL_OW 314
49770: NOT
49771: IFFALSE 49893
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
49773: LD_ADDR_VAR 0 10
49777: PUSH
49778: LD_VAR 0 13
49782: PPUSH
49783: LD_VAR 0 4
49787: PUSH
49788: LD_VAR 0 7
49792: ARRAY
49793: PPUSH
49794: CALL_OW 74
49798: ST_TO_ADDR
// if not x then
49799: LD_VAR 0 10
49803: NOT
49804: IFFALSE 49808
// continue ;
49806: GO 49240
// if GetLives ( x ) < 1000 then
49808: LD_VAR 0 10
49812: PPUSH
49813: CALL_OW 256
49817: PUSH
49818: LD_INT 1000
49820: LESS
49821: IFFALSE 49845
// ComRepairVehicle ( group [ i ] , x ) else
49823: LD_VAR 0 4
49827: PUSH
49828: LD_VAR 0 7
49832: ARRAY
49833: PPUSH
49834: LD_VAR 0 10
49838: PPUSH
49839: CALL_OW 129
49843: GO 49893
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
49845: LD_VAR 0 23
49849: PUSH
49850: LD_VAR 0 4
49854: PUSH
49855: LD_VAR 0 7
49859: ARRAY
49860: PPUSH
49861: CALL_OW 256
49865: PUSH
49866: LD_INT 1000
49868: LESS
49869: AND
49870: NOT
49871: IFFALSE 49893
// ComEnterUnit ( group [ i ] , x ) ;
49873: LD_VAR 0 4
49877: PUSH
49878: LD_VAR 0 7
49882: ARRAY
49883: PPUSH
49884: LD_VAR 0 10
49888: PPUSH
49889: CALL_OW 120
// end ; continue ;
49893: GO 49240
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
49895: LD_VAR 0 23
49899: PUSH
49900: LD_VAR 0 4
49904: PUSH
49905: LD_VAR 0 7
49909: ARRAY
49910: PPUSH
49911: CALL_OW 247
49915: PUSH
49916: LD_INT 1
49918: EQUAL
49919: AND
49920: IFFALSE 50398
// begin if group [ i ] in healers then
49922: LD_VAR 0 4
49926: PUSH
49927: LD_VAR 0 7
49931: ARRAY
49932: PUSH
49933: LD_VAR 0 31
49937: IN
49938: IFFALSE 50211
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
49940: LD_VAR 0 4
49944: PUSH
49945: LD_VAR 0 7
49949: ARRAY
49950: PPUSH
49951: LD_VAR 0 23
49955: PPUSH
49956: CALL_OW 308
49960: NOT
49961: PUSH
49962: LD_VAR 0 4
49966: PUSH
49967: LD_VAR 0 7
49971: ARRAY
49972: PPUSH
49973: CALL_OW 314
49977: NOT
49978: AND
49979: IFFALSE 50003
// ComMoveToArea ( group [ i ] , f_heal ) else
49981: LD_VAR 0 4
49985: PUSH
49986: LD_VAR 0 7
49990: ARRAY
49991: PPUSH
49992: LD_VAR 0 23
49996: PPUSH
49997: CALL_OW 113
50001: GO 50209
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50003: LD_VAR 0 4
50007: PUSH
50008: LD_VAR 0 7
50012: ARRAY
50013: PPUSH
50014: CALL 48641 0 1
50018: PPUSH
50019: CALL_OW 256
50023: PUSH
50024: LD_INT 1000
50026: EQUAL
50027: IFFALSE 50046
// ComStop ( group [ i ] ) else
50029: LD_VAR 0 4
50033: PUSH
50034: LD_VAR 0 7
50038: ARRAY
50039: PPUSH
50040: CALL_OW 141
50044: GO 50209
// if not HasTask ( group [ i ] ) and to_heal then
50046: LD_VAR 0 4
50050: PUSH
50051: LD_VAR 0 7
50055: ARRAY
50056: PPUSH
50057: CALL_OW 314
50061: NOT
50062: PUSH
50063: LD_VAR 0 30
50067: AND
50068: IFFALSE 50209
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50070: LD_ADDR_VAR 0 13
50074: PUSH
50075: LD_VAR 0 30
50079: PPUSH
50080: LD_INT 3
50082: PUSH
50083: LD_INT 54
50085: PUSH
50086: EMPTY
50087: LIST
50088: PUSH
50089: EMPTY
50090: LIST
50091: LIST
50092: PPUSH
50093: CALL_OW 72
50097: PPUSH
50098: LD_VAR 0 4
50102: PUSH
50103: LD_VAR 0 7
50107: ARRAY
50108: PPUSH
50109: CALL_OW 74
50113: ST_TO_ADDR
// if z then
50114: LD_VAR 0 13
50118: IFFALSE 50209
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50120: LD_INT 91
50122: PUSH
50123: LD_VAR 0 13
50127: PUSH
50128: LD_INT 10
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: LIST
50135: PUSH
50136: LD_INT 81
50138: PUSH
50139: LD_VAR 0 13
50143: PPUSH
50144: CALL_OW 255
50148: PUSH
50149: EMPTY
50150: LIST
50151: LIST
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PPUSH
50157: CALL_OW 69
50161: PUSH
50162: LD_INT 0
50164: EQUAL
50165: IFFALSE 50189
// ComHeal ( group [ i ] , z ) else
50167: LD_VAR 0 4
50171: PUSH
50172: LD_VAR 0 7
50176: ARRAY
50177: PPUSH
50178: LD_VAR 0 13
50182: PPUSH
50183: CALL_OW 128
50187: GO 50209
// ComMoveToArea ( group [ i ] , f_heal ) ;
50189: LD_VAR 0 4
50193: PUSH
50194: LD_VAR 0 7
50198: ARRAY
50199: PPUSH
50200: LD_VAR 0 23
50204: PPUSH
50205: CALL_OW 113
// end ; continue ;
50209: GO 49240
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50211: LD_VAR 0 4
50215: PUSH
50216: LD_VAR 0 7
50220: ARRAY
50221: PPUSH
50222: CALL_OW 256
50226: PUSH
50227: LD_INT 700
50229: LESS
50230: PUSH
50231: LD_VAR 0 4
50235: PUSH
50236: LD_VAR 0 7
50240: ARRAY
50241: PUSH
50242: LD_VAR 0 30
50246: IN
50247: NOT
50248: AND
50249: IFFALSE 50273
// to_heal := to_heal union group [ i ] ;
50251: LD_ADDR_VAR 0 30
50255: PUSH
50256: LD_VAR 0 30
50260: PUSH
50261: LD_VAR 0 4
50265: PUSH
50266: LD_VAR 0 7
50270: ARRAY
50271: UNION
50272: ST_TO_ADDR
// if group [ i ] in to_heal then
50273: LD_VAR 0 4
50277: PUSH
50278: LD_VAR 0 7
50282: ARRAY
50283: PUSH
50284: LD_VAR 0 30
50288: IN
50289: IFFALSE 50398
// begin if GetLives ( group [ i ] ) = 1000 then
50291: LD_VAR 0 4
50295: PUSH
50296: LD_VAR 0 7
50300: ARRAY
50301: PPUSH
50302: CALL_OW 256
50306: PUSH
50307: LD_INT 1000
50309: EQUAL
50310: IFFALSE 50336
// to_heal := to_heal diff group [ i ] else
50312: LD_ADDR_VAR 0 30
50316: PUSH
50317: LD_VAR 0 30
50321: PUSH
50322: LD_VAR 0 4
50326: PUSH
50327: LD_VAR 0 7
50331: ARRAY
50332: DIFF
50333: ST_TO_ADDR
50334: GO 50398
// begin if not IsInArea ( group [ i ] , to_heal ) then
50336: LD_VAR 0 4
50340: PUSH
50341: LD_VAR 0 7
50345: ARRAY
50346: PPUSH
50347: LD_VAR 0 30
50351: PPUSH
50352: CALL_OW 308
50356: NOT
50357: IFFALSE 50381
// ComMoveToArea ( group [ i ] , f_heal ) else
50359: LD_VAR 0 4
50363: PUSH
50364: LD_VAR 0 7
50368: ARRAY
50369: PPUSH
50370: LD_VAR 0 23
50374: PPUSH
50375: CALL_OW 113
50379: GO 50396
// ComHold ( group [ i ] ) ;
50381: LD_VAR 0 4
50385: PUSH
50386: LD_VAR 0 7
50390: ARRAY
50391: PPUSH
50392: CALL_OW 140
// continue ;
50396: GO 49240
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50398: LD_VAR 0 4
50402: PUSH
50403: LD_VAR 0 7
50407: ARRAY
50408: PPUSH
50409: LD_INT 10
50411: PPUSH
50412: CALL 47038 0 2
50416: NOT
50417: PUSH
50418: LD_VAR 0 16
50422: PUSH
50423: LD_VAR 0 7
50427: ARRAY
50428: PUSH
50429: EMPTY
50430: EQUAL
50431: NOT
50432: AND
50433: IFFALSE 50699
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50435: LD_VAR 0 4
50439: PUSH
50440: LD_VAR 0 7
50444: ARRAY
50445: PPUSH
50446: CALL_OW 262
50450: PUSH
50451: LD_INT 1
50453: PUSH
50454: LD_INT 2
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: IN
50461: IFFALSE 50502
// if GetFuel ( group [ i ] ) < 10 then
50463: LD_VAR 0 4
50467: PUSH
50468: LD_VAR 0 7
50472: ARRAY
50473: PPUSH
50474: CALL_OW 261
50478: PUSH
50479: LD_INT 10
50481: LESS
50482: IFFALSE 50502
// SetFuel ( group [ i ] , 12 ) ;
50484: LD_VAR 0 4
50488: PUSH
50489: LD_VAR 0 7
50493: ARRAY
50494: PPUSH
50495: LD_INT 12
50497: PPUSH
50498: CALL_OW 240
// if units_path [ i ] then
50502: LD_VAR 0 16
50506: PUSH
50507: LD_VAR 0 7
50511: ARRAY
50512: IFFALSE 50697
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50514: LD_VAR 0 4
50518: PUSH
50519: LD_VAR 0 7
50523: ARRAY
50524: PPUSH
50525: LD_VAR 0 16
50529: PUSH
50530: LD_VAR 0 7
50534: ARRAY
50535: PUSH
50536: LD_INT 1
50538: ARRAY
50539: PUSH
50540: LD_INT 1
50542: ARRAY
50543: PPUSH
50544: LD_VAR 0 16
50548: PUSH
50549: LD_VAR 0 7
50553: ARRAY
50554: PUSH
50555: LD_INT 1
50557: ARRAY
50558: PUSH
50559: LD_INT 2
50561: ARRAY
50562: PPUSH
50563: CALL_OW 297
50567: PUSH
50568: LD_INT 6
50570: GREATER
50571: IFFALSE 50646
// begin if not HasTask ( group [ i ] ) then
50573: LD_VAR 0 4
50577: PUSH
50578: LD_VAR 0 7
50582: ARRAY
50583: PPUSH
50584: CALL_OW 314
50588: NOT
50589: IFFALSE 50644
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50591: LD_VAR 0 4
50595: PUSH
50596: LD_VAR 0 7
50600: ARRAY
50601: PPUSH
50602: LD_VAR 0 16
50606: PUSH
50607: LD_VAR 0 7
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: ARRAY
50620: PPUSH
50621: LD_VAR 0 16
50625: PUSH
50626: LD_VAR 0 7
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: PUSH
50636: LD_INT 2
50638: ARRAY
50639: PPUSH
50640: CALL_OW 114
// end else
50644: GO 50697
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50646: LD_ADDR_VAR 0 15
50650: PUSH
50651: LD_VAR 0 16
50655: PUSH
50656: LD_VAR 0 7
50660: ARRAY
50661: PPUSH
50662: LD_INT 1
50664: PPUSH
50665: CALL_OW 3
50669: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50670: LD_ADDR_VAR 0 16
50674: PUSH
50675: LD_VAR 0 16
50679: PPUSH
50680: LD_VAR 0 7
50684: PPUSH
50685: LD_VAR 0 15
50689: PPUSH
50690: CALL_OW 1
50694: ST_TO_ADDR
// continue ;
50695: GO 49240
// end ; end ; end else
50697: GO 53335
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50699: LD_ADDR_VAR 0 14
50703: PUSH
50704: LD_INT 81
50706: PUSH
50707: LD_VAR 0 4
50711: PUSH
50712: LD_VAR 0 7
50716: ARRAY
50717: PPUSH
50718: CALL_OW 255
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PPUSH
50727: CALL_OW 69
50731: ST_TO_ADDR
// if not tmp then
50732: LD_VAR 0 14
50736: NOT
50737: IFFALSE 50741
// continue ;
50739: GO 49240
// if f_ignore_area then
50741: LD_VAR 0 17
50745: IFFALSE 50833
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
50747: LD_ADDR_VAR 0 15
50751: PUSH
50752: LD_VAR 0 14
50756: PPUSH
50757: LD_INT 3
50759: PUSH
50760: LD_INT 92
50762: PUSH
50763: LD_VAR 0 17
50767: PUSH
50768: LD_INT 1
50770: ARRAY
50771: PUSH
50772: LD_VAR 0 17
50776: PUSH
50777: LD_INT 2
50779: ARRAY
50780: PUSH
50781: LD_VAR 0 17
50785: PUSH
50786: LD_INT 3
50788: ARRAY
50789: PUSH
50790: EMPTY
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PPUSH
50800: CALL_OW 72
50804: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50805: LD_VAR 0 14
50809: PUSH
50810: LD_VAR 0 15
50814: DIFF
50815: IFFALSE 50833
// tmp := tmp diff tmp2 ;
50817: LD_ADDR_VAR 0 14
50821: PUSH
50822: LD_VAR 0 14
50826: PUSH
50827: LD_VAR 0 15
50831: DIFF
50832: ST_TO_ADDR
// end ; if not f_murder then
50833: LD_VAR 0 20
50837: NOT
50838: IFFALSE 50896
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
50840: LD_ADDR_VAR 0 15
50844: PUSH
50845: LD_VAR 0 14
50849: PPUSH
50850: LD_INT 3
50852: PUSH
50853: LD_INT 50
50855: PUSH
50856: EMPTY
50857: LIST
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PPUSH
50863: CALL_OW 72
50867: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50868: LD_VAR 0 14
50872: PUSH
50873: LD_VAR 0 15
50877: DIFF
50878: IFFALSE 50896
// tmp := tmp diff tmp2 ;
50880: LD_ADDR_VAR 0 14
50884: PUSH
50885: LD_VAR 0 14
50889: PUSH
50890: LD_VAR 0 15
50894: DIFF
50895: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
50896: LD_ADDR_VAR 0 14
50900: PUSH
50901: LD_VAR 0 4
50905: PUSH
50906: LD_VAR 0 7
50910: ARRAY
50911: PPUSH
50912: LD_VAR 0 14
50916: PPUSH
50917: LD_INT 1
50919: PPUSH
50920: LD_INT 1
50922: PPUSH
50923: CALL 20705 0 4
50927: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
50928: LD_VAR 0 4
50932: PUSH
50933: LD_VAR 0 7
50937: ARRAY
50938: PPUSH
50939: CALL_OW 257
50943: PUSH
50944: LD_INT 1
50946: EQUAL
50947: IFFALSE 51395
// begin if WantPlant ( group [ i ] ) then
50949: LD_VAR 0 4
50953: PUSH
50954: LD_VAR 0 7
50958: ARRAY
50959: PPUSH
50960: CALL 20206 0 1
50964: IFFALSE 50968
// continue ;
50966: GO 49240
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
50968: LD_VAR 0 18
50972: PUSH
50973: LD_VAR 0 4
50977: PUSH
50978: LD_VAR 0 7
50982: ARRAY
50983: PPUSH
50984: CALL_OW 310
50988: NOT
50989: AND
50990: PUSH
50991: LD_VAR 0 14
50995: PUSH
50996: LD_INT 1
50998: ARRAY
50999: PUSH
51000: LD_VAR 0 14
51004: PPUSH
51005: LD_INT 21
51007: PUSH
51008: LD_INT 2
51010: PUSH
51011: EMPTY
51012: LIST
51013: LIST
51014: PUSH
51015: LD_INT 58
51017: PUSH
51018: EMPTY
51019: LIST
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: PPUSH
51025: CALL_OW 72
51029: IN
51030: AND
51031: IFFALSE 51067
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51033: LD_VAR 0 4
51037: PUSH
51038: LD_VAR 0 7
51042: ARRAY
51043: PPUSH
51044: LD_VAR 0 14
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: CALL_OW 120
// attacking := true ;
51057: LD_ADDR_VAR 0 29
51061: PUSH
51062: LD_INT 1
51064: ST_TO_ADDR
// continue ;
51065: GO 49240
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51067: LD_VAR 0 26
51071: PUSH
51072: LD_VAR 0 4
51076: PUSH
51077: LD_VAR 0 7
51081: ARRAY
51082: PPUSH
51083: CALL_OW 257
51087: PUSH
51088: LD_INT 1
51090: EQUAL
51091: AND
51092: PUSH
51093: LD_VAR 0 4
51097: PUSH
51098: LD_VAR 0 7
51102: ARRAY
51103: PPUSH
51104: CALL_OW 256
51108: PUSH
51109: LD_INT 800
51111: LESS
51112: AND
51113: PUSH
51114: LD_VAR 0 4
51118: PUSH
51119: LD_VAR 0 7
51123: ARRAY
51124: PPUSH
51125: CALL_OW 318
51129: NOT
51130: AND
51131: IFFALSE 51148
// ComCrawl ( group [ i ] ) ;
51133: LD_VAR 0 4
51137: PUSH
51138: LD_VAR 0 7
51142: ARRAY
51143: PPUSH
51144: CALL_OW 137
// if f_mines then
51148: LD_VAR 0 21
51152: IFFALSE 51395
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51154: LD_VAR 0 14
51158: PUSH
51159: LD_INT 1
51161: ARRAY
51162: PPUSH
51163: CALL_OW 247
51167: PUSH
51168: LD_INT 3
51170: EQUAL
51171: PUSH
51172: LD_VAR 0 14
51176: PUSH
51177: LD_INT 1
51179: ARRAY
51180: PUSH
51181: LD_VAR 0 27
51185: IN
51186: NOT
51187: AND
51188: IFFALSE 51395
// begin x := GetX ( tmp [ 1 ] ) ;
51190: LD_ADDR_VAR 0 10
51194: PUSH
51195: LD_VAR 0 14
51199: PUSH
51200: LD_INT 1
51202: ARRAY
51203: PPUSH
51204: CALL_OW 250
51208: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51209: LD_ADDR_VAR 0 11
51213: PUSH
51214: LD_VAR 0 14
51218: PUSH
51219: LD_INT 1
51221: ARRAY
51222: PPUSH
51223: CALL_OW 251
51227: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51228: LD_ADDR_VAR 0 12
51232: PUSH
51233: LD_VAR 0 4
51237: PUSH
51238: LD_VAR 0 7
51242: ARRAY
51243: PPUSH
51244: CALL 47123 0 1
51248: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51249: LD_VAR 0 4
51253: PUSH
51254: LD_VAR 0 7
51258: ARRAY
51259: PPUSH
51260: LD_VAR 0 10
51264: PPUSH
51265: LD_VAR 0 11
51269: PPUSH
51270: LD_VAR 0 14
51274: PUSH
51275: LD_INT 1
51277: ARRAY
51278: PPUSH
51279: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51283: LD_VAR 0 4
51287: PUSH
51288: LD_VAR 0 7
51292: ARRAY
51293: PPUSH
51294: LD_VAR 0 10
51298: PPUSH
51299: LD_VAR 0 12
51303: PPUSH
51304: LD_INT 7
51306: PPUSH
51307: CALL_OW 272
51311: PPUSH
51312: LD_VAR 0 11
51316: PPUSH
51317: LD_VAR 0 12
51321: PPUSH
51322: LD_INT 7
51324: PPUSH
51325: CALL_OW 273
51329: PPUSH
51330: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51334: LD_VAR 0 4
51338: PUSH
51339: LD_VAR 0 7
51343: ARRAY
51344: PPUSH
51345: LD_INT 71
51347: PPUSH
51348: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51352: LD_ADDR_VAR 0 27
51356: PUSH
51357: LD_VAR 0 27
51361: PPUSH
51362: LD_VAR 0 27
51366: PUSH
51367: LD_INT 1
51369: PLUS
51370: PPUSH
51371: LD_VAR 0 14
51375: PUSH
51376: LD_INT 1
51378: ARRAY
51379: PPUSH
51380: CALL_OW 1
51384: ST_TO_ADDR
// attacking := true ;
51385: LD_ADDR_VAR 0 29
51389: PUSH
51390: LD_INT 1
51392: ST_TO_ADDR
// continue ;
51393: GO 49240
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51395: LD_VAR 0 4
51399: PUSH
51400: LD_VAR 0 7
51404: ARRAY
51405: PPUSH
51406: CALL_OW 257
51410: PUSH
51411: LD_INT 17
51413: EQUAL
51414: PUSH
51415: LD_VAR 0 4
51419: PUSH
51420: LD_VAR 0 7
51424: ARRAY
51425: PPUSH
51426: CALL_OW 110
51430: PUSH
51431: LD_INT 71
51433: EQUAL
51434: NOT
51435: AND
51436: IFFALSE 51582
// begin attacking := false ;
51438: LD_ADDR_VAR 0 29
51442: PUSH
51443: LD_INT 0
51445: ST_TO_ADDR
// k := 5 ;
51446: LD_ADDR_VAR 0 9
51450: PUSH
51451: LD_INT 5
51453: ST_TO_ADDR
// if tmp < k then
51454: LD_VAR 0 14
51458: PUSH
51459: LD_VAR 0 9
51463: LESS
51464: IFFALSE 51476
// k := tmp ;
51466: LD_ADDR_VAR 0 9
51470: PUSH
51471: LD_VAR 0 14
51475: ST_TO_ADDR
// for j = 1 to k do
51476: LD_ADDR_VAR 0 8
51480: PUSH
51481: DOUBLE
51482: LD_INT 1
51484: DEC
51485: ST_TO_ADDR
51486: LD_VAR 0 9
51490: PUSH
51491: FOR_TO
51492: IFFALSE 51580
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51494: LD_VAR 0 14
51498: PUSH
51499: LD_VAR 0 8
51503: ARRAY
51504: PUSH
51505: LD_VAR 0 14
51509: PPUSH
51510: LD_INT 58
51512: PUSH
51513: EMPTY
51514: LIST
51515: PPUSH
51516: CALL_OW 72
51520: IN
51521: NOT
51522: IFFALSE 51578
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51524: LD_VAR 0 4
51528: PUSH
51529: LD_VAR 0 7
51533: ARRAY
51534: PPUSH
51535: LD_VAR 0 14
51539: PUSH
51540: LD_VAR 0 8
51544: ARRAY
51545: PPUSH
51546: CALL_OW 115
// attacking := true ;
51550: LD_ADDR_VAR 0 29
51554: PUSH
51555: LD_INT 1
51557: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51558: LD_VAR 0 4
51562: PUSH
51563: LD_VAR 0 7
51567: ARRAY
51568: PPUSH
51569: LD_INT 71
51571: PPUSH
51572: CALL_OW 109
// continue ;
51576: GO 51491
// end ; end ;
51578: GO 51491
51580: POP
51581: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51582: LD_VAR 0 4
51586: PUSH
51587: LD_VAR 0 7
51591: ARRAY
51592: PPUSH
51593: CALL_OW 257
51597: PUSH
51598: LD_INT 8
51600: EQUAL
51601: PUSH
51602: LD_VAR 0 4
51606: PUSH
51607: LD_VAR 0 7
51611: ARRAY
51612: PPUSH
51613: CALL_OW 264
51617: PUSH
51618: LD_INT 28
51620: PUSH
51621: LD_INT 45
51623: PUSH
51624: LD_INT 7
51626: PUSH
51627: LD_INT 47
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: IN
51636: OR
51637: IFFALSE 51867
// begin attacking := false ;
51639: LD_ADDR_VAR 0 29
51643: PUSH
51644: LD_INT 0
51646: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51647: LD_VAR 0 14
51651: PUSH
51652: LD_INT 1
51654: ARRAY
51655: PPUSH
51656: CALL_OW 266
51660: PUSH
51661: LD_INT 32
51663: PUSH
51664: LD_INT 31
51666: PUSH
51667: LD_INT 33
51669: PUSH
51670: LD_INT 4
51672: PUSH
51673: LD_INT 5
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: IN
51683: IFFALSE 51867
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51685: LD_ADDR_VAR 0 9
51689: PUSH
51690: LD_VAR 0 14
51694: PUSH
51695: LD_INT 1
51697: ARRAY
51698: PPUSH
51699: CALL_OW 266
51703: PPUSH
51704: LD_VAR 0 14
51708: PUSH
51709: LD_INT 1
51711: ARRAY
51712: PPUSH
51713: CALL_OW 250
51717: PPUSH
51718: LD_VAR 0 14
51722: PUSH
51723: LD_INT 1
51725: ARRAY
51726: PPUSH
51727: CALL_OW 251
51731: PPUSH
51732: LD_VAR 0 14
51736: PUSH
51737: LD_INT 1
51739: ARRAY
51740: PPUSH
51741: CALL_OW 254
51745: PPUSH
51746: LD_VAR 0 14
51750: PUSH
51751: LD_INT 1
51753: ARRAY
51754: PPUSH
51755: CALL_OW 248
51759: PPUSH
51760: LD_INT 0
51762: PPUSH
51763: CALL 28499 0 6
51767: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
51768: LD_ADDR_VAR 0 8
51772: PUSH
51773: LD_VAR 0 4
51777: PUSH
51778: LD_VAR 0 7
51782: ARRAY
51783: PPUSH
51784: LD_VAR 0 9
51788: PPUSH
51789: CALL 47186 0 2
51793: ST_TO_ADDR
// if j then
51794: LD_VAR 0 8
51798: IFFALSE 51867
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
51800: LD_VAR 0 8
51804: PUSH
51805: LD_INT 1
51807: ARRAY
51808: PPUSH
51809: LD_VAR 0 8
51813: PUSH
51814: LD_INT 2
51816: ARRAY
51817: PPUSH
51818: CALL_OW 488
51822: IFFALSE 51867
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
51824: LD_VAR 0 4
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PPUSH
51835: LD_VAR 0 8
51839: PUSH
51840: LD_INT 1
51842: ARRAY
51843: PPUSH
51844: LD_VAR 0 8
51848: PUSH
51849: LD_INT 2
51851: ARRAY
51852: PPUSH
51853: CALL_OW 116
// attacking := true ;
51857: LD_ADDR_VAR 0 29
51861: PUSH
51862: LD_INT 1
51864: ST_TO_ADDR
// continue ;
51865: GO 49240
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 7
51876: ARRAY
51877: PPUSH
51878: CALL_OW 265
51882: PUSH
51883: LD_INT 11
51885: EQUAL
51886: IFFALSE 52164
// begin k := 10 ;
51888: LD_ADDR_VAR 0 9
51892: PUSH
51893: LD_INT 10
51895: ST_TO_ADDR
// x := 0 ;
51896: LD_ADDR_VAR 0 10
51900: PUSH
51901: LD_INT 0
51903: ST_TO_ADDR
// if tmp < k then
51904: LD_VAR 0 14
51908: PUSH
51909: LD_VAR 0 9
51913: LESS
51914: IFFALSE 51926
// k := tmp ;
51916: LD_ADDR_VAR 0 9
51920: PUSH
51921: LD_VAR 0 14
51925: ST_TO_ADDR
// for j = k downto 1 do
51926: LD_ADDR_VAR 0 8
51930: PUSH
51931: DOUBLE
51932: LD_VAR 0 9
51936: INC
51937: ST_TO_ADDR
51938: LD_INT 1
51940: PUSH
51941: FOR_DOWNTO
51942: IFFALSE 52017
// begin if GetType ( tmp [ j ] ) = unit_human then
51944: LD_VAR 0 14
51948: PUSH
51949: LD_VAR 0 8
51953: ARRAY
51954: PPUSH
51955: CALL_OW 247
51959: PUSH
51960: LD_INT 1
51962: EQUAL
51963: IFFALSE 52015
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
51965: LD_VAR 0 4
51969: PUSH
51970: LD_VAR 0 7
51974: ARRAY
51975: PPUSH
51976: LD_VAR 0 14
51980: PUSH
51981: LD_VAR 0 8
51985: ARRAY
51986: PPUSH
51987: CALL 47457 0 2
// x := tmp [ j ] ;
51991: LD_ADDR_VAR 0 10
51995: PUSH
51996: LD_VAR 0 14
52000: PUSH
52001: LD_VAR 0 8
52005: ARRAY
52006: ST_TO_ADDR
// attacking := true ;
52007: LD_ADDR_VAR 0 29
52011: PUSH
52012: LD_INT 1
52014: ST_TO_ADDR
// end ; end ;
52015: GO 51941
52017: POP
52018: POP
// if not x then
52019: LD_VAR 0 10
52023: NOT
52024: IFFALSE 52164
// begin attacking := true ;
52026: LD_ADDR_VAR 0 29
52030: PUSH
52031: LD_INT 1
52033: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52034: LD_VAR 0 4
52038: PUSH
52039: LD_VAR 0 7
52043: ARRAY
52044: PPUSH
52045: CALL_OW 250
52049: PPUSH
52050: LD_VAR 0 4
52054: PUSH
52055: LD_VAR 0 7
52059: ARRAY
52060: PPUSH
52061: CALL_OW 251
52065: PPUSH
52066: CALL_OW 546
52070: PUSH
52071: LD_INT 2
52073: ARRAY
52074: PUSH
52075: LD_VAR 0 14
52079: PUSH
52080: LD_INT 1
52082: ARRAY
52083: PPUSH
52084: CALL_OW 250
52088: PPUSH
52089: LD_VAR 0 14
52093: PUSH
52094: LD_INT 1
52096: ARRAY
52097: PPUSH
52098: CALL_OW 251
52102: PPUSH
52103: CALL_OW 546
52107: PUSH
52108: LD_INT 2
52110: ARRAY
52111: EQUAL
52112: IFFALSE 52140
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52114: LD_VAR 0 4
52118: PUSH
52119: LD_VAR 0 7
52123: ARRAY
52124: PPUSH
52125: LD_VAR 0 14
52129: PUSH
52130: LD_INT 1
52132: ARRAY
52133: PPUSH
52134: CALL 47457 0 2
52138: GO 52164
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52140: LD_VAR 0 4
52144: PUSH
52145: LD_VAR 0 7
52149: ARRAY
52150: PPUSH
52151: LD_VAR 0 14
52155: PUSH
52156: LD_INT 1
52158: ARRAY
52159: PPUSH
52160: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52164: LD_VAR 0 4
52168: PUSH
52169: LD_VAR 0 7
52173: ARRAY
52174: PPUSH
52175: CALL_OW 264
52179: PUSH
52180: LD_INT 29
52182: EQUAL
52183: IFFALSE 52549
// begin if WantsToAttack ( group [ i ] ) in bombed then
52185: LD_VAR 0 4
52189: PUSH
52190: LD_VAR 0 7
52194: ARRAY
52195: PPUSH
52196: CALL_OW 319
52200: PUSH
52201: LD_VAR 0 28
52205: IN
52206: IFFALSE 52210
// continue ;
52208: GO 49240
// k := 8 ;
52210: LD_ADDR_VAR 0 9
52214: PUSH
52215: LD_INT 8
52217: ST_TO_ADDR
// x := 0 ;
52218: LD_ADDR_VAR 0 10
52222: PUSH
52223: LD_INT 0
52225: ST_TO_ADDR
// if tmp < k then
52226: LD_VAR 0 14
52230: PUSH
52231: LD_VAR 0 9
52235: LESS
52236: IFFALSE 52248
// k := tmp ;
52238: LD_ADDR_VAR 0 9
52242: PUSH
52243: LD_VAR 0 14
52247: ST_TO_ADDR
// for j = 1 to k do
52248: LD_ADDR_VAR 0 8
52252: PUSH
52253: DOUBLE
52254: LD_INT 1
52256: DEC
52257: ST_TO_ADDR
52258: LD_VAR 0 9
52262: PUSH
52263: FOR_TO
52264: IFFALSE 52396
// begin if GetType ( tmp [ j ] ) = unit_building then
52266: LD_VAR 0 14
52270: PUSH
52271: LD_VAR 0 8
52275: ARRAY
52276: PPUSH
52277: CALL_OW 247
52281: PUSH
52282: LD_INT 3
52284: EQUAL
52285: IFFALSE 52394
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52287: LD_VAR 0 14
52291: PUSH
52292: LD_VAR 0 8
52296: ARRAY
52297: PUSH
52298: LD_VAR 0 28
52302: IN
52303: NOT
52304: PUSH
52305: LD_VAR 0 14
52309: PUSH
52310: LD_VAR 0 8
52314: ARRAY
52315: PPUSH
52316: CALL_OW 313
52320: AND
52321: IFFALSE 52394
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52323: LD_VAR 0 4
52327: PUSH
52328: LD_VAR 0 7
52332: ARRAY
52333: PPUSH
52334: LD_VAR 0 14
52338: PUSH
52339: LD_VAR 0 8
52343: ARRAY
52344: PPUSH
52345: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52349: LD_ADDR_VAR 0 28
52353: PUSH
52354: LD_VAR 0 28
52358: PPUSH
52359: LD_VAR 0 28
52363: PUSH
52364: LD_INT 1
52366: PLUS
52367: PPUSH
52368: LD_VAR 0 14
52372: PUSH
52373: LD_VAR 0 8
52377: ARRAY
52378: PPUSH
52379: CALL_OW 1
52383: ST_TO_ADDR
// attacking := true ;
52384: LD_ADDR_VAR 0 29
52388: PUSH
52389: LD_INT 1
52391: ST_TO_ADDR
// break ;
52392: GO 52396
// end ; end ;
52394: GO 52263
52396: POP
52397: POP
// if not attacking and f_attack_depot then
52398: LD_VAR 0 29
52402: NOT
52403: PUSH
52404: LD_VAR 0 25
52408: AND
52409: IFFALSE 52504
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52411: LD_ADDR_VAR 0 13
52415: PUSH
52416: LD_VAR 0 14
52420: PPUSH
52421: LD_INT 2
52423: PUSH
52424: LD_INT 30
52426: PUSH
52427: LD_INT 0
52429: PUSH
52430: EMPTY
52431: LIST
52432: LIST
52433: PUSH
52434: LD_INT 30
52436: PUSH
52437: LD_INT 1
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: LIST
52448: PPUSH
52449: CALL_OW 72
52453: ST_TO_ADDR
// if z then
52454: LD_VAR 0 13
52458: IFFALSE 52504
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52460: LD_VAR 0 4
52464: PUSH
52465: LD_VAR 0 7
52469: ARRAY
52470: PPUSH
52471: LD_VAR 0 13
52475: PPUSH
52476: LD_VAR 0 4
52480: PUSH
52481: LD_VAR 0 7
52485: ARRAY
52486: PPUSH
52487: CALL_OW 74
52491: PPUSH
52492: CALL_OW 115
// attacking := true ;
52496: LD_ADDR_VAR 0 29
52500: PUSH
52501: LD_INT 1
52503: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52504: LD_VAR 0 4
52508: PUSH
52509: LD_VAR 0 7
52513: ARRAY
52514: PPUSH
52515: CALL_OW 256
52519: PUSH
52520: LD_INT 500
52522: LESS
52523: IFFALSE 52549
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52525: LD_VAR 0 4
52529: PUSH
52530: LD_VAR 0 7
52534: ARRAY
52535: PPUSH
52536: LD_VAR 0 14
52540: PUSH
52541: LD_INT 1
52543: ARRAY
52544: PPUSH
52545: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52549: LD_VAR 0 4
52553: PUSH
52554: LD_VAR 0 7
52558: ARRAY
52559: PPUSH
52560: CALL_OW 264
52564: PUSH
52565: LD_INT 49
52567: EQUAL
52568: IFFALSE 52689
// begin if not HasTask ( group [ i ] ) then
52570: LD_VAR 0 4
52574: PUSH
52575: LD_VAR 0 7
52579: ARRAY
52580: PPUSH
52581: CALL_OW 314
52585: NOT
52586: IFFALSE 52689
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52588: LD_ADDR_VAR 0 9
52592: PUSH
52593: LD_INT 81
52595: PUSH
52596: LD_VAR 0 4
52600: PUSH
52601: LD_VAR 0 7
52605: ARRAY
52606: PPUSH
52607: CALL_OW 255
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: PPUSH
52616: CALL_OW 69
52620: PPUSH
52621: LD_VAR 0 4
52625: PUSH
52626: LD_VAR 0 7
52630: ARRAY
52631: PPUSH
52632: CALL_OW 74
52636: ST_TO_ADDR
// if k then
52637: LD_VAR 0 9
52641: IFFALSE 52689
// if GetDistUnits ( group [ i ] , k ) > 10 then
52643: LD_VAR 0 4
52647: PUSH
52648: LD_VAR 0 7
52652: ARRAY
52653: PPUSH
52654: LD_VAR 0 9
52658: PPUSH
52659: CALL_OW 296
52663: PUSH
52664: LD_INT 10
52666: GREATER
52667: IFFALSE 52689
// ComMoveUnit ( group [ i ] , k ) ;
52669: LD_VAR 0 4
52673: PUSH
52674: LD_VAR 0 7
52678: ARRAY
52679: PPUSH
52680: LD_VAR 0 9
52684: PPUSH
52685: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52689: LD_VAR 0 4
52693: PUSH
52694: LD_VAR 0 7
52698: ARRAY
52699: PPUSH
52700: CALL_OW 256
52704: PUSH
52705: LD_INT 250
52707: LESS
52708: PUSH
52709: LD_VAR 0 4
52713: PUSH
52714: LD_VAR 0 7
52718: ARRAY
52719: PUSH
52720: LD_INT 21
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PUSH
52730: LD_INT 23
52732: PUSH
52733: LD_INT 2
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PPUSH
52744: CALL_OW 69
52748: IN
52749: AND
52750: IFFALSE 52875
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
52752: LD_ADDR_VAR 0 9
52756: PUSH
52757: LD_OWVAR 3
52761: PUSH
52762: LD_VAR 0 4
52766: PUSH
52767: LD_VAR 0 7
52771: ARRAY
52772: DIFF
52773: PPUSH
52774: LD_VAR 0 4
52778: PUSH
52779: LD_VAR 0 7
52783: ARRAY
52784: PPUSH
52785: CALL_OW 74
52789: ST_TO_ADDR
// if not k then
52790: LD_VAR 0 9
52794: NOT
52795: IFFALSE 52799
// continue ;
52797: GO 49240
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
52799: LD_VAR 0 9
52803: PUSH
52804: LD_INT 81
52806: PUSH
52807: LD_VAR 0 4
52811: PUSH
52812: LD_VAR 0 7
52816: ARRAY
52817: PPUSH
52818: CALL_OW 255
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PPUSH
52827: CALL_OW 69
52831: IN
52832: PUSH
52833: LD_VAR 0 9
52837: PPUSH
52838: LD_VAR 0 4
52842: PUSH
52843: LD_VAR 0 7
52847: ARRAY
52848: PPUSH
52849: CALL_OW 296
52853: PUSH
52854: LD_INT 5
52856: LESS
52857: AND
52858: IFFALSE 52875
// ComAutodestruct ( group [ i ] ) ;
52860: LD_VAR 0 4
52864: PUSH
52865: LD_VAR 0 7
52869: ARRAY
52870: PPUSH
52871: CALL 47355 0 1
// end ; if f_attack_depot then
52875: LD_VAR 0 25
52879: IFFALSE 52991
// begin k := 6 ;
52881: LD_ADDR_VAR 0 9
52885: PUSH
52886: LD_INT 6
52888: ST_TO_ADDR
// if tmp < k then
52889: LD_VAR 0 14
52893: PUSH
52894: LD_VAR 0 9
52898: LESS
52899: IFFALSE 52911
// k := tmp ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_VAR 0 14
52910: ST_TO_ADDR
// for j = 1 to k do
52911: LD_ADDR_VAR 0 8
52915: PUSH
52916: DOUBLE
52917: LD_INT 1
52919: DEC
52920: ST_TO_ADDR
52921: LD_VAR 0 9
52925: PUSH
52926: FOR_TO
52927: IFFALSE 52989
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
52929: LD_VAR 0 8
52933: PPUSH
52934: CALL_OW 266
52938: PUSH
52939: LD_INT 0
52941: PUSH
52942: LD_INT 1
52944: PUSH
52945: EMPTY
52946: LIST
52947: LIST
52948: IN
52949: IFFALSE 52987
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52951: LD_VAR 0 4
52955: PUSH
52956: LD_VAR 0 7
52960: ARRAY
52961: PPUSH
52962: LD_VAR 0 14
52966: PUSH
52967: LD_VAR 0 8
52971: ARRAY
52972: PPUSH
52973: CALL_OW 115
// attacking := true ;
52977: LD_ADDR_VAR 0 29
52981: PUSH
52982: LD_INT 1
52984: ST_TO_ADDR
// break ;
52985: GO 52989
// end ;
52987: GO 52926
52989: POP
52990: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
52991: LD_VAR 0 4
52995: PUSH
52996: LD_VAR 0 7
53000: ARRAY
53001: PPUSH
53002: CALL_OW 302
53006: PUSH
53007: LD_VAR 0 29
53011: NOT
53012: AND
53013: IFFALSE 53335
// begin if GetTag ( group [ i ] ) = 71 then
53015: LD_VAR 0 4
53019: PUSH
53020: LD_VAR 0 7
53024: ARRAY
53025: PPUSH
53026: CALL_OW 110
53030: PUSH
53031: LD_INT 71
53033: EQUAL
53034: IFFALSE 53075
// begin if HasTask ( group [ i ] ) then
53036: LD_VAR 0 4
53040: PUSH
53041: LD_VAR 0 7
53045: ARRAY
53046: PPUSH
53047: CALL_OW 314
53051: IFFALSE 53057
// continue else
53053: GO 49240
53055: GO 53075
// SetTag ( group [ i ] , 0 ) ;
53057: LD_VAR 0 4
53061: PUSH
53062: LD_VAR 0 7
53066: ARRAY
53067: PPUSH
53068: LD_INT 0
53070: PPUSH
53071: CALL_OW 109
// end ; k := 8 ;
53075: LD_ADDR_VAR 0 9
53079: PUSH
53080: LD_INT 8
53082: ST_TO_ADDR
// x := 0 ;
53083: LD_ADDR_VAR 0 10
53087: PUSH
53088: LD_INT 0
53090: ST_TO_ADDR
// if tmp < k then
53091: LD_VAR 0 14
53095: PUSH
53096: LD_VAR 0 9
53100: LESS
53101: IFFALSE 53113
// k := tmp ;
53103: LD_ADDR_VAR 0 9
53107: PUSH
53108: LD_VAR 0 14
53112: ST_TO_ADDR
// for j = 1 to k do
53113: LD_ADDR_VAR 0 8
53117: PUSH
53118: DOUBLE
53119: LD_INT 1
53121: DEC
53122: ST_TO_ADDR
53123: LD_VAR 0 9
53127: PUSH
53128: FOR_TO
53129: IFFALSE 53227
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53131: LD_VAR 0 14
53135: PUSH
53136: LD_VAR 0 8
53140: ARRAY
53141: PPUSH
53142: CALL_OW 247
53146: PUSH
53147: LD_INT 1
53149: EQUAL
53150: PUSH
53151: LD_VAR 0 14
53155: PUSH
53156: LD_VAR 0 8
53160: ARRAY
53161: PPUSH
53162: CALL_OW 256
53166: PUSH
53167: LD_INT 250
53169: LESS
53170: PUSH
53171: LD_VAR 0 20
53175: AND
53176: PUSH
53177: LD_VAR 0 20
53181: NOT
53182: PUSH
53183: LD_VAR 0 14
53187: PUSH
53188: LD_VAR 0 8
53192: ARRAY
53193: PPUSH
53194: CALL_OW 256
53198: PUSH
53199: LD_INT 250
53201: GREATEREQUAL
53202: AND
53203: OR
53204: AND
53205: IFFALSE 53225
// begin x := tmp [ j ] ;
53207: LD_ADDR_VAR 0 10
53211: PUSH
53212: LD_VAR 0 14
53216: PUSH
53217: LD_VAR 0 8
53221: ARRAY
53222: ST_TO_ADDR
// break ;
53223: GO 53227
// end ;
53225: GO 53128
53227: POP
53228: POP
// if x then
53229: LD_VAR 0 10
53233: IFFALSE 53257
// ComAttackUnit ( group [ i ] , x ) else
53235: LD_VAR 0 4
53239: PUSH
53240: LD_VAR 0 7
53244: ARRAY
53245: PPUSH
53246: LD_VAR 0 10
53250: PPUSH
53251: CALL_OW 115
53255: GO 53281
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53257: LD_VAR 0 4
53261: PUSH
53262: LD_VAR 0 7
53266: ARRAY
53267: PPUSH
53268: LD_VAR 0 14
53272: PUSH
53273: LD_INT 1
53275: ARRAY
53276: PPUSH
53277: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53281: LD_VAR 0 4
53285: PUSH
53286: LD_VAR 0 7
53290: ARRAY
53291: PPUSH
53292: CALL_OW 314
53296: NOT
53297: IFFALSE 53335
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53299: LD_VAR 0 4
53303: PUSH
53304: LD_VAR 0 7
53308: ARRAY
53309: PPUSH
53310: LD_VAR 0 14
53314: PPUSH
53315: LD_VAR 0 4
53319: PUSH
53320: LD_VAR 0 7
53324: ARRAY
53325: PPUSH
53326: CALL_OW 74
53330: PPUSH
53331: CALL_OW 115
// end ; end ; end ;
53335: GO 49240
53337: POP
53338: POP
// wait ( 0 0$1 ) ;
53339: LD_INT 35
53341: PPUSH
53342: CALL_OW 67
// until group = [ ] ;
53346: LD_VAR 0 4
53350: PUSH
53351: EMPTY
53352: EQUAL
53353: IFFALSE 49225
// end ;
53355: LD_VAR 0 2
53359: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53360: LD_INT 0
53362: PPUSH
53363: PPUSH
53364: PPUSH
53365: PPUSH
// if not base_units then
53366: LD_VAR 0 1
53370: NOT
53371: IFFALSE 53375
// exit ;
53373: GO 53462
// result := false ;
53375: LD_ADDR_VAR 0 2
53379: PUSH
53380: LD_INT 0
53382: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53383: LD_ADDR_VAR 0 5
53387: PUSH
53388: LD_VAR 0 1
53392: PPUSH
53393: LD_INT 21
53395: PUSH
53396: LD_INT 3
53398: PUSH
53399: EMPTY
53400: LIST
53401: LIST
53402: PPUSH
53403: CALL_OW 72
53407: ST_TO_ADDR
// if not tmp then
53408: LD_VAR 0 5
53412: NOT
53413: IFFALSE 53417
// exit ;
53415: GO 53462
// for i in tmp do
53417: LD_ADDR_VAR 0 3
53421: PUSH
53422: LD_VAR 0 5
53426: PUSH
53427: FOR_IN
53428: IFFALSE 53460
// begin result := EnemyInRange ( i , 22 ) ;
53430: LD_ADDR_VAR 0 2
53434: PUSH
53435: LD_VAR 0 3
53439: PPUSH
53440: LD_INT 22
53442: PPUSH
53443: CALL 47038 0 2
53447: ST_TO_ADDR
// if result then
53448: LD_VAR 0 2
53452: IFFALSE 53458
// exit ;
53454: POP
53455: POP
53456: GO 53462
// end ;
53458: GO 53427
53460: POP
53461: POP
// end ;
53462: LD_VAR 0 2
53466: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53467: LD_INT 0
53469: PPUSH
53470: PPUSH
// if not units then
53471: LD_VAR 0 1
53475: NOT
53476: IFFALSE 53480
// exit ;
53478: GO 53550
// result := [ ] ;
53480: LD_ADDR_VAR 0 3
53484: PUSH
53485: EMPTY
53486: ST_TO_ADDR
// for i in units do
53487: LD_ADDR_VAR 0 4
53491: PUSH
53492: LD_VAR 0 1
53496: PUSH
53497: FOR_IN
53498: IFFALSE 53548
// if GetTag ( i ) = tag then
53500: LD_VAR 0 4
53504: PPUSH
53505: CALL_OW 110
53509: PUSH
53510: LD_VAR 0 2
53514: EQUAL
53515: IFFALSE 53546
// result := Insert ( result , result + 1 , i ) ;
53517: LD_ADDR_VAR 0 3
53521: PUSH
53522: LD_VAR 0 3
53526: PPUSH
53527: LD_VAR 0 3
53531: PUSH
53532: LD_INT 1
53534: PLUS
53535: PPUSH
53536: LD_VAR 0 4
53540: PPUSH
53541: CALL_OW 2
53545: ST_TO_ADDR
53546: GO 53497
53548: POP
53549: POP
// end ;
53550: LD_VAR 0 3
53554: RET
// export function IsDriver ( un ) ; begin
53555: LD_INT 0
53557: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53558: LD_ADDR_VAR 0 2
53562: PUSH
53563: LD_VAR 0 1
53567: PUSH
53568: LD_INT 55
53570: PUSH
53571: EMPTY
53572: LIST
53573: PPUSH
53574: CALL_OW 69
53578: IN
53579: ST_TO_ADDR
// end ;
53580: LD_VAR 0 2
53584: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53585: LD_INT 0
53587: PPUSH
53588: PPUSH
// list := [ ] ;
53589: LD_ADDR_VAR 0 5
53593: PUSH
53594: EMPTY
53595: ST_TO_ADDR
// case d of 0 :
53596: LD_VAR 0 3
53600: PUSH
53601: LD_INT 0
53603: DOUBLE
53604: EQUAL
53605: IFTRUE 53609
53607: GO 53742
53609: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53610: LD_ADDR_VAR 0 5
53614: PUSH
53615: LD_VAR 0 1
53619: PUSH
53620: LD_INT 4
53622: MINUS
53623: PUSH
53624: LD_VAR 0 2
53628: PUSH
53629: LD_INT 4
53631: MINUS
53632: PUSH
53633: LD_INT 2
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: LIST
53640: PUSH
53641: LD_VAR 0 1
53645: PUSH
53646: LD_INT 3
53648: MINUS
53649: PUSH
53650: LD_VAR 0 2
53654: PUSH
53655: LD_INT 1
53657: PUSH
53658: EMPTY
53659: LIST
53660: LIST
53661: LIST
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_INT 4
53670: PLUS
53671: PUSH
53672: LD_VAR 0 2
53676: PUSH
53677: LD_INT 4
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: LIST
53684: PUSH
53685: LD_VAR 0 1
53689: PUSH
53690: LD_INT 3
53692: PLUS
53693: PUSH
53694: LD_VAR 0 2
53698: PUSH
53699: LD_INT 3
53701: PLUS
53702: PUSH
53703: LD_INT 5
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: LIST
53710: PUSH
53711: LD_VAR 0 1
53715: PUSH
53716: LD_VAR 0 2
53720: PUSH
53721: LD_INT 4
53723: PLUS
53724: PUSH
53725: LD_INT 0
53727: PUSH
53728: EMPTY
53729: LIST
53730: LIST
53731: LIST
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: LIST
53737: LIST
53738: LIST
53739: ST_TO_ADDR
// end ; 1 :
53740: GO 54440
53742: LD_INT 1
53744: DOUBLE
53745: EQUAL
53746: IFTRUE 53750
53748: GO 53883
53750: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53751: LD_ADDR_VAR 0 5
53755: PUSH
53756: LD_VAR 0 1
53760: PUSH
53761: LD_VAR 0 2
53765: PUSH
53766: LD_INT 4
53768: MINUS
53769: PUSH
53770: LD_INT 3
53772: PUSH
53773: EMPTY
53774: LIST
53775: LIST
53776: LIST
53777: PUSH
53778: LD_VAR 0 1
53782: PUSH
53783: LD_INT 3
53785: MINUS
53786: PUSH
53787: LD_VAR 0 2
53791: PUSH
53792: LD_INT 3
53794: MINUS
53795: PUSH
53796: LD_INT 2
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: LIST
53803: PUSH
53804: LD_VAR 0 1
53808: PUSH
53809: LD_INT 4
53811: MINUS
53812: PUSH
53813: LD_VAR 0 2
53817: PUSH
53818: LD_INT 1
53820: PUSH
53821: EMPTY
53822: LIST
53823: LIST
53824: LIST
53825: PUSH
53826: LD_VAR 0 1
53830: PUSH
53831: LD_VAR 0 2
53835: PUSH
53836: LD_INT 3
53838: PLUS
53839: PUSH
53840: LD_INT 0
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: LIST
53847: PUSH
53848: LD_VAR 0 1
53852: PUSH
53853: LD_INT 4
53855: PLUS
53856: PUSH
53857: LD_VAR 0 2
53861: PUSH
53862: LD_INT 4
53864: PLUS
53865: PUSH
53866: LD_INT 5
53868: PUSH
53869: EMPTY
53870: LIST
53871: LIST
53872: LIST
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: LIST
53878: LIST
53879: LIST
53880: ST_TO_ADDR
// end ; 2 :
53881: GO 54440
53883: LD_INT 2
53885: DOUBLE
53886: EQUAL
53887: IFTRUE 53891
53889: GO 54020
53891: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53892: LD_ADDR_VAR 0 5
53896: PUSH
53897: LD_VAR 0 1
53901: PUSH
53902: LD_VAR 0 2
53906: PUSH
53907: LD_INT 3
53909: MINUS
53910: PUSH
53911: LD_INT 3
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: LIST
53918: PUSH
53919: LD_VAR 0 1
53923: PUSH
53924: LD_INT 4
53926: PLUS
53927: PUSH
53928: LD_VAR 0 2
53932: PUSH
53933: LD_INT 4
53935: PUSH
53936: EMPTY
53937: LIST
53938: LIST
53939: LIST
53940: PUSH
53941: LD_VAR 0 1
53945: PUSH
53946: LD_VAR 0 2
53950: PUSH
53951: LD_INT 4
53953: PLUS
53954: PUSH
53955: LD_INT 0
53957: PUSH
53958: EMPTY
53959: LIST
53960: LIST
53961: LIST
53962: PUSH
53963: LD_VAR 0 1
53967: PUSH
53968: LD_INT 3
53970: MINUS
53971: PUSH
53972: LD_VAR 0 2
53976: PUSH
53977: LD_INT 1
53979: PUSH
53980: EMPTY
53981: LIST
53982: LIST
53983: LIST
53984: PUSH
53985: LD_VAR 0 1
53989: PUSH
53990: LD_INT 4
53992: MINUS
53993: PUSH
53994: LD_VAR 0 2
53998: PUSH
53999: LD_INT 4
54001: MINUS
54002: PUSH
54003: LD_INT 2
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: LIST
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: ST_TO_ADDR
// end ; 3 :
54018: GO 54440
54020: LD_INT 3
54022: DOUBLE
54023: EQUAL
54024: IFTRUE 54028
54026: GO 54161
54028: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54029: LD_ADDR_VAR 0 5
54033: PUSH
54034: LD_VAR 0 1
54038: PUSH
54039: LD_INT 3
54041: PLUS
54042: PUSH
54043: LD_VAR 0 2
54047: PUSH
54048: LD_INT 4
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: LIST
54055: PUSH
54056: LD_VAR 0 1
54060: PUSH
54061: LD_INT 4
54063: PLUS
54064: PUSH
54065: LD_VAR 0 2
54069: PUSH
54070: LD_INT 4
54072: PLUS
54073: PUSH
54074: LD_INT 5
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: LIST
54081: PUSH
54082: LD_VAR 0 1
54086: PUSH
54087: LD_INT 4
54089: MINUS
54090: PUSH
54091: LD_VAR 0 2
54095: PUSH
54096: LD_INT 1
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: LIST
54103: PUSH
54104: LD_VAR 0 1
54108: PUSH
54109: LD_VAR 0 2
54113: PUSH
54114: LD_INT 4
54116: MINUS
54117: PUSH
54118: LD_INT 3
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: LIST
54125: PUSH
54126: LD_VAR 0 1
54130: PUSH
54131: LD_INT 3
54133: MINUS
54134: PUSH
54135: LD_VAR 0 2
54139: PUSH
54140: LD_INT 3
54142: MINUS
54143: PUSH
54144: LD_INT 2
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: LIST
54157: LIST
54158: ST_TO_ADDR
// end ; 4 :
54159: GO 54440
54161: LD_INT 4
54163: DOUBLE
54164: EQUAL
54165: IFTRUE 54169
54167: GO 54302
54169: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54170: LD_ADDR_VAR 0 5
54174: PUSH
54175: LD_VAR 0 1
54179: PUSH
54180: LD_VAR 0 2
54184: PUSH
54185: LD_INT 4
54187: PLUS
54188: PUSH
54189: LD_INT 0
54191: PUSH
54192: EMPTY
54193: LIST
54194: LIST
54195: LIST
54196: PUSH
54197: LD_VAR 0 1
54201: PUSH
54202: LD_INT 3
54204: PLUS
54205: PUSH
54206: LD_VAR 0 2
54210: PUSH
54211: LD_INT 3
54213: PLUS
54214: PUSH
54215: LD_INT 5
54217: PUSH
54218: EMPTY
54219: LIST
54220: LIST
54221: LIST
54222: PUSH
54223: LD_VAR 0 1
54227: PUSH
54228: LD_INT 4
54230: PLUS
54231: PUSH
54232: LD_VAR 0 2
54236: PUSH
54237: LD_INT 4
54239: PUSH
54240: EMPTY
54241: LIST
54242: LIST
54243: LIST
54244: PUSH
54245: LD_VAR 0 1
54249: PUSH
54250: LD_VAR 0 2
54254: PUSH
54255: LD_INT 3
54257: MINUS
54258: PUSH
54259: LD_INT 3
54261: PUSH
54262: EMPTY
54263: LIST
54264: LIST
54265: LIST
54266: PUSH
54267: LD_VAR 0 1
54271: PUSH
54272: LD_INT 4
54274: MINUS
54275: PUSH
54276: LD_VAR 0 2
54280: PUSH
54281: LD_INT 4
54283: MINUS
54284: PUSH
54285: LD_INT 2
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: LIST
54292: PUSH
54293: EMPTY
54294: LIST
54295: LIST
54296: LIST
54297: LIST
54298: LIST
54299: ST_TO_ADDR
// end ; 5 :
54300: GO 54440
54302: LD_INT 5
54304: DOUBLE
54305: EQUAL
54306: IFTRUE 54310
54308: GO 54439
54310: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54311: LD_ADDR_VAR 0 5
54315: PUSH
54316: LD_VAR 0 1
54320: PUSH
54321: LD_INT 4
54323: MINUS
54324: PUSH
54325: LD_VAR 0 2
54329: PUSH
54330: LD_INT 1
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: LIST
54337: PUSH
54338: LD_VAR 0 1
54342: PUSH
54343: LD_VAR 0 2
54347: PUSH
54348: LD_INT 4
54350: MINUS
54351: PUSH
54352: LD_INT 3
54354: PUSH
54355: EMPTY
54356: LIST
54357: LIST
54358: LIST
54359: PUSH
54360: LD_VAR 0 1
54364: PUSH
54365: LD_INT 4
54367: PLUS
54368: PUSH
54369: LD_VAR 0 2
54373: PUSH
54374: LD_INT 4
54376: PLUS
54377: PUSH
54378: LD_INT 5
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: LIST
54385: PUSH
54386: LD_VAR 0 1
54390: PUSH
54391: LD_INT 3
54393: PLUS
54394: PUSH
54395: LD_VAR 0 2
54399: PUSH
54400: LD_INT 4
54402: PUSH
54403: EMPTY
54404: LIST
54405: LIST
54406: LIST
54407: PUSH
54408: LD_VAR 0 1
54412: PUSH
54413: LD_VAR 0 2
54417: PUSH
54418: LD_INT 3
54420: PLUS
54421: PUSH
54422: LD_INT 0
54424: PUSH
54425: EMPTY
54426: LIST
54427: LIST
54428: LIST
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: LIST
54434: LIST
54435: LIST
54436: ST_TO_ADDR
// end ; end ;
54437: GO 54440
54439: POP
// result := list ;
54440: LD_ADDR_VAR 0 4
54444: PUSH
54445: LD_VAR 0 5
54449: ST_TO_ADDR
// end ;
54450: LD_VAR 0 4
54454: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54455: LD_INT 0
54457: PPUSH
54458: PPUSH
54459: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54460: LD_VAR 0 1
54464: NOT
54465: PUSH
54466: LD_VAR 0 2
54470: PUSH
54471: LD_INT 1
54473: PUSH
54474: LD_INT 2
54476: PUSH
54477: LD_INT 3
54479: PUSH
54480: LD_INT 4
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: LIST
54487: LIST
54488: IN
54489: NOT
54490: OR
54491: IFFALSE 54495
// exit ;
54493: GO 54587
// tmp := [ ] ;
54495: LD_ADDR_VAR 0 5
54499: PUSH
54500: EMPTY
54501: ST_TO_ADDR
// for i in units do
54502: LD_ADDR_VAR 0 4
54506: PUSH
54507: LD_VAR 0 1
54511: PUSH
54512: FOR_IN
54513: IFFALSE 54556
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54515: LD_ADDR_VAR 0 5
54519: PUSH
54520: LD_VAR 0 5
54524: PPUSH
54525: LD_VAR 0 5
54529: PUSH
54530: LD_INT 1
54532: PLUS
54533: PPUSH
54534: LD_VAR 0 4
54538: PPUSH
54539: LD_VAR 0 2
54543: PPUSH
54544: CALL_OW 259
54548: PPUSH
54549: CALL_OW 2
54553: ST_TO_ADDR
54554: GO 54512
54556: POP
54557: POP
// if not tmp then
54558: LD_VAR 0 5
54562: NOT
54563: IFFALSE 54567
// exit ;
54565: GO 54587
// result := SortListByListDesc ( units , tmp ) ;
54567: LD_ADDR_VAR 0 3
54571: PUSH
54572: LD_VAR 0 1
54576: PPUSH
54577: LD_VAR 0 5
54581: PPUSH
54582: CALL_OW 77
54586: ST_TO_ADDR
// end ;
54587: LD_VAR 0 3
54591: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
// x := GetX ( building ) ;
54597: LD_ADDR_VAR 0 4
54601: PUSH
54602: LD_VAR 0 2
54606: PPUSH
54607: CALL_OW 250
54611: ST_TO_ADDR
// y := GetY ( building ) ;
54612: LD_ADDR_VAR 0 5
54616: PUSH
54617: LD_VAR 0 2
54621: PPUSH
54622: CALL_OW 251
54626: ST_TO_ADDR
// if GetTaskList ( unit ) then
54627: LD_VAR 0 1
54631: PPUSH
54632: CALL_OW 437
54636: IFFALSE 54731
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54638: LD_STRING e
54640: PUSH
54641: LD_VAR 0 1
54645: PPUSH
54646: CALL_OW 437
54650: PUSH
54651: LD_INT 1
54653: ARRAY
54654: PUSH
54655: LD_INT 1
54657: ARRAY
54658: EQUAL
54659: PUSH
54660: LD_VAR 0 4
54664: PUSH
54665: LD_VAR 0 1
54669: PPUSH
54670: CALL_OW 437
54674: PUSH
54675: LD_INT 1
54677: ARRAY
54678: PUSH
54679: LD_INT 2
54681: ARRAY
54682: EQUAL
54683: AND
54684: PUSH
54685: LD_VAR 0 5
54689: PUSH
54690: LD_VAR 0 1
54694: PPUSH
54695: CALL_OW 437
54699: PUSH
54700: LD_INT 1
54702: ARRAY
54703: PUSH
54704: LD_INT 3
54706: ARRAY
54707: EQUAL
54708: AND
54709: IFFALSE 54721
// result := true else
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_INT 1
54718: ST_TO_ADDR
54719: GO 54729
// result := false ;
54721: LD_ADDR_VAR 0 3
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// end else
54729: GO 54739
// result := false ;
54731: LD_ADDR_VAR 0 3
54735: PUSH
54736: LD_INT 0
54738: ST_TO_ADDR
// end ;
54739: LD_VAR 0 3
54743: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54744: LD_INT 0
54746: PPUSH
54747: PPUSH
54748: PPUSH
54749: PPUSH
// if not unit or not area then
54750: LD_VAR 0 1
54754: NOT
54755: PUSH
54756: LD_VAR 0 2
54760: NOT
54761: OR
54762: IFFALSE 54766
// exit ;
54764: GO 54931
// tmp := AreaToList ( area , i ) ;
54766: LD_ADDR_VAR 0 6
54770: PUSH
54771: LD_VAR 0 2
54775: PPUSH
54776: LD_VAR 0 5
54780: PPUSH
54781: CALL_OW 517
54785: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54786: LD_ADDR_VAR 0 5
54790: PUSH
54791: DOUBLE
54792: LD_INT 1
54794: DEC
54795: ST_TO_ADDR
54796: LD_VAR 0 6
54800: PUSH
54801: LD_INT 1
54803: ARRAY
54804: PUSH
54805: FOR_TO
54806: IFFALSE 54921
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54808: LD_ADDR_VAR 0 7
54812: PUSH
54813: LD_VAR 0 6
54817: PUSH
54818: LD_INT 1
54820: ARRAY
54821: PUSH
54822: LD_VAR 0 5
54826: ARRAY
54827: PUSH
54828: LD_VAR 0 6
54832: PUSH
54833: LD_INT 2
54835: ARRAY
54836: PUSH
54837: LD_VAR 0 5
54841: ARRAY
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54847: LD_VAR 0 7
54851: PUSH
54852: LD_INT 1
54854: ARRAY
54855: PPUSH
54856: LD_VAR 0 7
54860: PUSH
54861: LD_INT 2
54863: ARRAY
54864: PPUSH
54865: CALL_OW 428
54869: PUSH
54870: LD_INT 0
54872: EQUAL
54873: IFFALSE 54919
// begin result := true ;
54875: LD_ADDR_VAR 0 4
54879: PUSH
54880: LD_INT 1
54882: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54883: LD_VAR 0 1
54887: PPUSH
54888: LD_VAR 0 7
54892: PUSH
54893: LD_INT 1
54895: ARRAY
54896: PPUSH
54897: LD_VAR 0 7
54901: PUSH
54902: LD_INT 2
54904: ARRAY
54905: PPUSH
54906: LD_VAR 0 3
54910: PPUSH
54911: CALL_OW 48
// exit ;
54915: POP
54916: POP
54917: GO 54931
// end ; end ;
54919: GO 54805
54921: POP
54922: POP
// result := false ;
54923: LD_ADDR_VAR 0 4
54927: PUSH
54928: LD_INT 0
54930: ST_TO_ADDR
// end ;
54931: LD_VAR 0 4
54935: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54936: LD_INT 0
54938: PPUSH
54939: PPUSH
54940: PPUSH
// if not side or side > 8 then
54941: LD_VAR 0 1
54945: NOT
54946: PUSH
54947: LD_VAR 0 1
54951: PUSH
54952: LD_INT 8
54954: GREATER
54955: OR
54956: IFFALSE 54960
// exit ;
54958: GO 55147
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54960: LD_ADDR_VAR 0 4
54964: PUSH
54965: LD_INT 22
54967: PUSH
54968: LD_VAR 0 1
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: PUSH
54977: LD_INT 21
54979: PUSH
54980: LD_INT 3
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PPUSH
54991: CALL_OW 69
54995: ST_TO_ADDR
// if not tmp then
54996: LD_VAR 0 4
55000: NOT
55001: IFFALSE 55005
// exit ;
55003: GO 55147
// enable_addtolog := true ;
55005: LD_ADDR_OWVAR 81
55009: PUSH
55010: LD_INT 1
55012: ST_TO_ADDR
// AddToLog ( [ ) ;
55013: LD_STRING [
55015: PPUSH
55016: CALL_OW 561
// for i in tmp do
55020: LD_ADDR_VAR 0 3
55024: PUSH
55025: LD_VAR 0 4
55029: PUSH
55030: FOR_IN
55031: IFFALSE 55138
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55033: LD_STRING [
55035: PUSH
55036: LD_VAR 0 3
55040: PPUSH
55041: CALL_OW 266
55045: STR
55046: PUSH
55047: LD_STRING , 
55049: STR
55050: PUSH
55051: LD_VAR 0 3
55055: PPUSH
55056: CALL_OW 250
55060: STR
55061: PUSH
55062: LD_STRING , 
55064: STR
55065: PUSH
55066: LD_VAR 0 3
55070: PPUSH
55071: CALL_OW 251
55075: STR
55076: PUSH
55077: LD_STRING , 
55079: STR
55080: PUSH
55081: LD_VAR 0 3
55085: PPUSH
55086: CALL_OW 254
55090: STR
55091: PUSH
55092: LD_STRING , 
55094: STR
55095: PUSH
55096: LD_VAR 0 3
55100: PPUSH
55101: LD_INT 1
55103: PPUSH
55104: CALL_OW 268
55108: STR
55109: PUSH
55110: LD_STRING , 
55112: STR
55113: PUSH
55114: LD_VAR 0 3
55118: PPUSH
55119: LD_INT 2
55121: PPUSH
55122: CALL_OW 268
55126: STR
55127: PUSH
55128: LD_STRING ],
55130: STR
55131: PPUSH
55132: CALL_OW 561
// end ;
55136: GO 55030
55138: POP
55139: POP
// AddToLog ( ]; ) ;
55140: LD_STRING ];
55142: PPUSH
55143: CALL_OW 561
// end ;
55147: LD_VAR 0 2
55151: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55152: LD_INT 0
55154: PPUSH
55155: PPUSH
55156: PPUSH
55157: PPUSH
55158: PPUSH
// if not area or not rate or not max then
55159: LD_VAR 0 1
55163: NOT
55164: PUSH
55165: LD_VAR 0 2
55169: NOT
55170: OR
55171: PUSH
55172: LD_VAR 0 4
55176: NOT
55177: OR
55178: IFFALSE 55182
// exit ;
55180: GO 55374
// while 1 do
55182: LD_INT 1
55184: IFFALSE 55374
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55186: LD_ADDR_VAR 0 9
55190: PUSH
55191: LD_VAR 0 1
55195: PPUSH
55196: LD_INT 1
55198: PPUSH
55199: CALL_OW 287
55203: PUSH
55204: LD_INT 10
55206: MUL
55207: ST_TO_ADDR
// r := rate / 10 ;
55208: LD_ADDR_VAR 0 7
55212: PUSH
55213: LD_VAR 0 2
55217: PUSH
55218: LD_INT 10
55220: DIVREAL
55221: ST_TO_ADDR
// time := 1 1$00 ;
55222: LD_ADDR_VAR 0 8
55226: PUSH
55227: LD_INT 2100
55229: ST_TO_ADDR
// if amount < min then
55230: LD_VAR 0 9
55234: PUSH
55235: LD_VAR 0 3
55239: LESS
55240: IFFALSE 55258
// r := r * 2 else
55242: LD_ADDR_VAR 0 7
55246: PUSH
55247: LD_VAR 0 7
55251: PUSH
55252: LD_INT 2
55254: MUL
55255: ST_TO_ADDR
55256: GO 55284
// if amount > max then
55258: LD_VAR 0 9
55262: PUSH
55263: LD_VAR 0 4
55267: GREATER
55268: IFFALSE 55284
// r := r / 2 ;
55270: LD_ADDR_VAR 0 7
55274: PUSH
55275: LD_VAR 0 7
55279: PUSH
55280: LD_INT 2
55282: DIVREAL
55283: ST_TO_ADDR
// time := time / r ;
55284: LD_ADDR_VAR 0 8
55288: PUSH
55289: LD_VAR 0 8
55293: PUSH
55294: LD_VAR 0 7
55298: DIVREAL
55299: ST_TO_ADDR
// if time < 0 then
55300: LD_VAR 0 8
55304: PUSH
55305: LD_INT 0
55307: LESS
55308: IFFALSE 55325
// time := time * - 1 ;
55310: LD_ADDR_VAR 0 8
55314: PUSH
55315: LD_VAR 0 8
55319: PUSH
55320: LD_INT 1
55322: NEG
55323: MUL
55324: ST_TO_ADDR
// wait ( time ) ;
55325: LD_VAR 0 8
55329: PPUSH
55330: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55334: LD_INT 35
55336: PPUSH
55337: LD_INT 875
55339: PPUSH
55340: CALL_OW 12
55344: PPUSH
55345: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55349: LD_INT 1
55351: PPUSH
55352: LD_INT 5
55354: PPUSH
55355: CALL_OW 12
55359: PPUSH
55360: LD_VAR 0 1
55364: PPUSH
55365: LD_INT 1
55367: PPUSH
55368: CALL_OW 55
// end ;
55372: GO 55182
// end ;
55374: LD_VAR 0 5
55378: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55379: LD_INT 0
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
55385: PPUSH
55386: PPUSH
55387: PPUSH
55388: PPUSH
// if not turrets or not factories then
55389: LD_VAR 0 1
55393: NOT
55394: PUSH
55395: LD_VAR 0 2
55399: NOT
55400: OR
55401: IFFALSE 55405
// exit ;
55403: GO 55712
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55405: LD_ADDR_VAR 0 10
55409: PUSH
55410: LD_INT 5
55412: PUSH
55413: LD_INT 6
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: PUSH
55420: LD_INT 2
55422: PUSH
55423: LD_INT 4
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: PUSH
55430: LD_INT 3
55432: PUSH
55433: LD_INT 5
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: PUSH
55445: LD_INT 24
55447: PUSH
55448: LD_INT 25
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: PUSH
55455: LD_INT 23
55457: PUSH
55458: LD_INT 27
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 42
55471: PUSH
55472: LD_INT 43
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PUSH
55479: LD_INT 44
55481: PUSH
55482: LD_INT 46
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PUSH
55489: LD_INT 45
55491: PUSH
55492: LD_INT 47
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: LIST
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: ST_TO_ADDR
// result := [ ] ;
55509: LD_ADDR_VAR 0 3
55513: PUSH
55514: EMPTY
55515: ST_TO_ADDR
// for i in turrets do
55516: LD_ADDR_VAR 0 4
55520: PUSH
55521: LD_VAR 0 1
55525: PUSH
55526: FOR_IN
55527: IFFALSE 55710
// begin nat := GetNation ( i ) ;
55529: LD_ADDR_VAR 0 7
55533: PUSH
55534: LD_VAR 0 4
55538: PPUSH
55539: CALL_OW 248
55543: ST_TO_ADDR
// weapon := 0 ;
55544: LD_ADDR_VAR 0 8
55548: PUSH
55549: LD_INT 0
55551: ST_TO_ADDR
// if not nat then
55552: LD_VAR 0 7
55556: NOT
55557: IFFALSE 55561
// continue ;
55559: GO 55526
// for j in list [ nat ] do
55561: LD_ADDR_VAR 0 5
55565: PUSH
55566: LD_VAR 0 10
55570: PUSH
55571: LD_VAR 0 7
55575: ARRAY
55576: PUSH
55577: FOR_IN
55578: IFFALSE 55619
// if GetBWeapon ( i ) = j [ 1 ] then
55580: LD_VAR 0 4
55584: PPUSH
55585: CALL_OW 269
55589: PUSH
55590: LD_VAR 0 5
55594: PUSH
55595: LD_INT 1
55597: ARRAY
55598: EQUAL
55599: IFFALSE 55617
// begin weapon := j [ 2 ] ;
55601: LD_ADDR_VAR 0 8
55605: PUSH
55606: LD_VAR 0 5
55610: PUSH
55611: LD_INT 2
55613: ARRAY
55614: ST_TO_ADDR
// break ;
55615: GO 55619
// end ;
55617: GO 55577
55619: POP
55620: POP
// if not weapon then
55621: LD_VAR 0 8
55625: NOT
55626: IFFALSE 55630
// continue ;
55628: GO 55526
// for k in factories do
55630: LD_ADDR_VAR 0 6
55634: PUSH
55635: LD_VAR 0 2
55639: PUSH
55640: FOR_IN
55641: IFFALSE 55706
// begin weapons := AvailableWeaponList ( k ) ;
55643: LD_ADDR_VAR 0 9
55647: PUSH
55648: LD_VAR 0 6
55652: PPUSH
55653: CALL_OW 478
55657: ST_TO_ADDR
// if not weapons then
55658: LD_VAR 0 9
55662: NOT
55663: IFFALSE 55667
// continue ;
55665: GO 55640
// if weapon in weapons then
55667: LD_VAR 0 8
55671: PUSH
55672: LD_VAR 0 9
55676: IN
55677: IFFALSE 55704
// begin result := [ i , weapon ] ;
55679: LD_ADDR_VAR 0 3
55683: PUSH
55684: LD_VAR 0 4
55688: PUSH
55689: LD_VAR 0 8
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: ST_TO_ADDR
// exit ;
55698: POP
55699: POP
55700: POP
55701: POP
55702: GO 55712
// end ; end ;
55704: GO 55640
55706: POP
55707: POP
// end ;
55708: GO 55526
55710: POP
55711: POP
// end ;
55712: LD_VAR 0 3
55716: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55717: LD_INT 0
55719: PPUSH
// if not side or side > 8 then
55720: LD_VAR 0 3
55724: NOT
55725: PUSH
55726: LD_VAR 0 3
55730: PUSH
55731: LD_INT 8
55733: GREATER
55734: OR
55735: IFFALSE 55739
// exit ;
55737: GO 55798
// if not range then
55739: LD_VAR 0 4
55743: NOT
55744: IFFALSE 55755
// range := - 12 ;
55746: LD_ADDR_VAR 0 4
55750: PUSH
55751: LD_INT 12
55753: NEG
55754: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55755: LD_VAR 0 1
55759: PPUSH
55760: LD_VAR 0 2
55764: PPUSH
55765: LD_VAR 0 3
55769: PPUSH
55770: LD_VAR 0 4
55774: PPUSH
55775: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55779: LD_VAR 0 1
55783: PPUSH
55784: LD_VAR 0 2
55788: PPUSH
55789: LD_VAR 0 3
55793: PPUSH
55794: CALL_OW 331
// end ;
55798: LD_VAR 0 5
55802: RET
// export function Video ( mode ) ; begin
55803: LD_INT 0
55805: PPUSH
// ingame_video = mode ;
55806: LD_ADDR_OWVAR 52
55810: PUSH
55811: LD_VAR 0 1
55815: ST_TO_ADDR
// interface_hidden = mode ;
55816: LD_ADDR_OWVAR 54
55820: PUSH
55821: LD_VAR 0 1
55825: ST_TO_ADDR
// end ;
55826: LD_VAR 0 2
55830: RET
// export function Join ( array , element ) ; begin
55831: LD_INT 0
55833: PPUSH
// result := array ^ element ;
55834: LD_ADDR_VAR 0 3
55838: PUSH
55839: LD_VAR 0 1
55843: PUSH
55844: LD_VAR 0 2
55848: ADD
55849: ST_TO_ADDR
// end ;
55850: LD_VAR 0 3
55854: RET
// export function JoinUnion ( array , element ) ; begin
55855: LD_INT 0
55857: PPUSH
// result := array union element ;
55858: LD_ADDR_VAR 0 3
55862: PUSH
55863: LD_VAR 0 1
55867: PUSH
55868: LD_VAR 0 2
55872: UNION
55873: ST_TO_ADDR
// end ;
55874: LD_VAR 0 3
55878: RET
// export function GetBehemoths ( side ) ; begin
55879: LD_INT 0
55881: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
55882: LD_ADDR_VAR 0 2
55886: PUSH
55887: LD_INT 22
55889: PUSH
55890: LD_VAR 0 1
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: PUSH
55899: LD_INT 31
55901: PUSH
55902: LD_INT 25
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: PPUSH
55913: CALL_OW 69
55917: ST_TO_ADDR
// end ;
55918: LD_VAR 0 2
55922: RET
// export function Shuffle ( array ) ; var i , index ; begin
55923: LD_INT 0
55925: PPUSH
55926: PPUSH
55927: PPUSH
// result := [ ] ;
55928: LD_ADDR_VAR 0 2
55932: PUSH
55933: EMPTY
55934: ST_TO_ADDR
// if not array then
55935: LD_VAR 0 1
55939: NOT
55940: IFFALSE 55944
// exit ;
55942: GO 56043
// Randomize ;
55944: CALL_OW 10
// for i = array downto 1 do
55948: LD_ADDR_VAR 0 3
55952: PUSH
55953: DOUBLE
55954: LD_VAR 0 1
55958: INC
55959: ST_TO_ADDR
55960: LD_INT 1
55962: PUSH
55963: FOR_DOWNTO
55964: IFFALSE 56041
// begin index := rand ( 1 , array ) ;
55966: LD_ADDR_VAR 0 4
55970: PUSH
55971: LD_INT 1
55973: PPUSH
55974: LD_VAR 0 1
55978: PPUSH
55979: CALL_OW 12
55983: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55984: LD_ADDR_VAR 0 2
55988: PUSH
55989: LD_VAR 0 2
55993: PPUSH
55994: LD_VAR 0 2
55998: PUSH
55999: LD_INT 1
56001: PLUS
56002: PPUSH
56003: LD_VAR 0 1
56007: PUSH
56008: LD_VAR 0 4
56012: ARRAY
56013: PPUSH
56014: CALL_OW 2
56018: ST_TO_ADDR
// array := Delete ( array , index ) ;
56019: LD_ADDR_VAR 0 1
56023: PUSH
56024: LD_VAR 0 1
56028: PPUSH
56029: LD_VAR 0 4
56033: PPUSH
56034: CALL_OW 3
56038: ST_TO_ADDR
// end ;
56039: GO 55963
56041: POP
56042: POP
// end ; end_of_file
56043: LD_VAR 0 2
56047: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56048: LD_INT 0
56050: PPUSH
56051: PPUSH
// skirmish := false ;
56052: LD_ADDR_EXP 56
56056: PUSH
56057: LD_INT 0
56059: ST_TO_ADDR
// debug_mc := false ;
56060: LD_ADDR_EXP 57
56064: PUSH
56065: LD_INT 0
56067: ST_TO_ADDR
// mc_bases := [ ] ;
56068: LD_ADDR_EXP 58
56072: PUSH
56073: EMPTY
56074: ST_TO_ADDR
// mc_sides := [ ] ;
56075: LD_ADDR_EXP 84
56079: PUSH
56080: EMPTY
56081: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56082: LD_ADDR_EXP 59
56086: PUSH
56087: EMPTY
56088: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56089: LD_ADDR_EXP 60
56093: PUSH
56094: EMPTY
56095: ST_TO_ADDR
// mc_need_heal := [ ] ;
56096: LD_ADDR_EXP 61
56100: PUSH
56101: EMPTY
56102: ST_TO_ADDR
// mc_healers := [ ] ;
56103: LD_ADDR_EXP 62
56107: PUSH
56108: EMPTY
56109: ST_TO_ADDR
// mc_build_list := [ ] ;
56110: LD_ADDR_EXP 63
56114: PUSH
56115: EMPTY
56116: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56117: LD_ADDR_EXP 90
56121: PUSH
56122: EMPTY
56123: ST_TO_ADDR
// mc_builders := [ ] ;
56124: LD_ADDR_EXP 64
56128: PUSH
56129: EMPTY
56130: ST_TO_ADDR
// mc_construct_list := [ ] ;
56131: LD_ADDR_EXP 65
56135: PUSH
56136: EMPTY
56137: ST_TO_ADDR
// mc_turret_list := [ ] ;
56138: LD_ADDR_EXP 66
56142: PUSH
56143: EMPTY
56144: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56145: LD_ADDR_EXP 67
56149: PUSH
56150: EMPTY
56151: ST_TO_ADDR
// mc_miners := [ ] ;
56152: LD_ADDR_EXP 72
56156: PUSH
56157: EMPTY
56158: ST_TO_ADDR
// mc_mines := [ ] ;
56159: LD_ADDR_EXP 71
56163: PUSH
56164: EMPTY
56165: ST_TO_ADDR
// mc_minefields := [ ] ;
56166: LD_ADDR_EXP 73
56170: PUSH
56171: EMPTY
56172: ST_TO_ADDR
// mc_crates := [ ] ;
56173: LD_ADDR_EXP 74
56177: PUSH
56178: EMPTY
56179: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56180: LD_ADDR_EXP 75
56184: PUSH
56185: EMPTY
56186: ST_TO_ADDR
// mc_crates_area := [ ] ;
56187: LD_ADDR_EXP 76
56191: PUSH
56192: EMPTY
56193: ST_TO_ADDR
// mc_vehicles := [ ] ;
56194: LD_ADDR_EXP 77
56198: PUSH
56199: EMPTY
56200: ST_TO_ADDR
// mc_attack := [ ] ;
56201: LD_ADDR_EXP 78
56205: PUSH
56206: EMPTY
56207: ST_TO_ADDR
// mc_produce := [ ] ;
56208: LD_ADDR_EXP 79
56212: PUSH
56213: EMPTY
56214: ST_TO_ADDR
// mc_defender := [ ] ;
56215: LD_ADDR_EXP 80
56219: PUSH
56220: EMPTY
56221: ST_TO_ADDR
// mc_parking := [ ] ;
56222: LD_ADDR_EXP 82
56226: PUSH
56227: EMPTY
56228: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56229: LD_ADDR_EXP 68
56233: PUSH
56234: EMPTY
56235: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56236: LD_ADDR_EXP 70
56240: PUSH
56241: EMPTY
56242: ST_TO_ADDR
// mc_scan := [ ] ;
56243: LD_ADDR_EXP 81
56247: PUSH
56248: EMPTY
56249: ST_TO_ADDR
// mc_scan_area := [ ] ;
56250: LD_ADDR_EXP 83
56254: PUSH
56255: EMPTY
56256: ST_TO_ADDR
// mc_tech := [ ] ;
56257: LD_ADDR_EXP 85
56261: PUSH
56262: EMPTY
56263: ST_TO_ADDR
// mc_class := [ ] ;
56264: LD_ADDR_EXP 99
56268: PUSH
56269: EMPTY
56270: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56271: LD_ADDR_EXP 100
56275: PUSH
56276: EMPTY
56277: ST_TO_ADDR
// end ;
56278: LD_VAR 0 1
56282: RET
// export function MC_Kill ( base ) ; begin
56283: LD_INT 0
56285: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56286: LD_ADDR_EXP 58
56290: PUSH
56291: LD_EXP 58
56295: PPUSH
56296: LD_VAR 0 1
56300: PPUSH
56301: EMPTY
56302: PPUSH
56303: CALL_OW 1
56307: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56308: LD_ADDR_EXP 59
56312: PUSH
56313: LD_EXP 59
56317: PPUSH
56318: LD_VAR 0 1
56322: PPUSH
56323: EMPTY
56324: PPUSH
56325: CALL_OW 1
56329: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56330: LD_ADDR_EXP 60
56334: PUSH
56335: LD_EXP 60
56339: PPUSH
56340: LD_VAR 0 1
56344: PPUSH
56345: EMPTY
56346: PPUSH
56347: CALL_OW 1
56351: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56352: LD_ADDR_EXP 61
56356: PUSH
56357: LD_EXP 61
56361: PPUSH
56362: LD_VAR 0 1
56366: PPUSH
56367: EMPTY
56368: PPUSH
56369: CALL_OW 1
56373: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56374: LD_ADDR_EXP 62
56378: PUSH
56379: LD_EXP 62
56383: PPUSH
56384: LD_VAR 0 1
56388: PPUSH
56389: EMPTY
56390: PPUSH
56391: CALL_OW 1
56395: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56396: LD_ADDR_EXP 63
56400: PUSH
56401: LD_EXP 63
56405: PPUSH
56406: LD_VAR 0 1
56410: PPUSH
56411: EMPTY
56412: PPUSH
56413: CALL_OW 1
56417: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56418: LD_ADDR_EXP 64
56422: PUSH
56423: LD_EXP 64
56427: PPUSH
56428: LD_VAR 0 1
56432: PPUSH
56433: EMPTY
56434: PPUSH
56435: CALL_OW 1
56439: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56440: LD_ADDR_EXP 65
56444: PUSH
56445: LD_EXP 65
56449: PPUSH
56450: LD_VAR 0 1
56454: PPUSH
56455: EMPTY
56456: PPUSH
56457: CALL_OW 1
56461: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56462: LD_ADDR_EXP 66
56466: PUSH
56467: LD_EXP 66
56471: PPUSH
56472: LD_VAR 0 1
56476: PPUSH
56477: EMPTY
56478: PPUSH
56479: CALL_OW 1
56483: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56484: LD_ADDR_EXP 67
56488: PUSH
56489: LD_EXP 67
56493: PPUSH
56494: LD_VAR 0 1
56498: PPUSH
56499: EMPTY
56500: PPUSH
56501: CALL_OW 1
56505: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56506: LD_ADDR_EXP 68
56510: PUSH
56511: LD_EXP 68
56515: PPUSH
56516: LD_VAR 0 1
56520: PPUSH
56521: EMPTY
56522: PPUSH
56523: CALL_OW 1
56527: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56528: LD_ADDR_EXP 69
56532: PUSH
56533: LD_EXP 69
56537: PPUSH
56538: LD_VAR 0 1
56542: PPUSH
56543: LD_INT 0
56545: PPUSH
56546: CALL_OW 1
56550: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56551: LD_ADDR_EXP 70
56555: PUSH
56556: LD_EXP 70
56560: PPUSH
56561: LD_VAR 0 1
56565: PPUSH
56566: EMPTY
56567: PPUSH
56568: CALL_OW 1
56572: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56573: LD_ADDR_EXP 71
56577: PUSH
56578: LD_EXP 71
56582: PPUSH
56583: LD_VAR 0 1
56587: PPUSH
56588: EMPTY
56589: PPUSH
56590: CALL_OW 1
56594: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56595: LD_ADDR_EXP 72
56599: PUSH
56600: LD_EXP 72
56604: PPUSH
56605: LD_VAR 0 1
56609: PPUSH
56610: EMPTY
56611: PPUSH
56612: CALL_OW 1
56616: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56617: LD_ADDR_EXP 73
56621: PUSH
56622: LD_EXP 73
56626: PPUSH
56627: LD_VAR 0 1
56631: PPUSH
56632: EMPTY
56633: PPUSH
56634: CALL_OW 1
56638: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56639: LD_ADDR_EXP 74
56643: PUSH
56644: LD_EXP 74
56648: PPUSH
56649: LD_VAR 0 1
56653: PPUSH
56654: EMPTY
56655: PPUSH
56656: CALL_OW 1
56660: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56661: LD_ADDR_EXP 75
56665: PUSH
56666: LD_EXP 75
56670: PPUSH
56671: LD_VAR 0 1
56675: PPUSH
56676: EMPTY
56677: PPUSH
56678: CALL_OW 1
56682: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56683: LD_ADDR_EXP 76
56687: PUSH
56688: LD_EXP 76
56692: PPUSH
56693: LD_VAR 0 1
56697: PPUSH
56698: EMPTY
56699: PPUSH
56700: CALL_OW 1
56704: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56705: LD_ADDR_EXP 77
56709: PUSH
56710: LD_EXP 77
56714: PPUSH
56715: LD_VAR 0 1
56719: PPUSH
56720: EMPTY
56721: PPUSH
56722: CALL_OW 1
56726: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56727: LD_ADDR_EXP 78
56731: PUSH
56732: LD_EXP 78
56736: PPUSH
56737: LD_VAR 0 1
56741: PPUSH
56742: EMPTY
56743: PPUSH
56744: CALL_OW 1
56748: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56749: LD_ADDR_EXP 79
56753: PUSH
56754: LD_EXP 79
56758: PPUSH
56759: LD_VAR 0 1
56763: PPUSH
56764: EMPTY
56765: PPUSH
56766: CALL_OW 1
56770: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56771: LD_ADDR_EXP 80
56775: PUSH
56776: LD_EXP 80
56780: PPUSH
56781: LD_VAR 0 1
56785: PPUSH
56786: EMPTY
56787: PPUSH
56788: CALL_OW 1
56792: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56793: LD_ADDR_EXP 81
56797: PUSH
56798: LD_EXP 81
56802: PPUSH
56803: LD_VAR 0 1
56807: PPUSH
56808: EMPTY
56809: PPUSH
56810: CALL_OW 1
56814: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56815: LD_ADDR_EXP 82
56819: PUSH
56820: LD_EXP 82
56824: PPUSH
56825: LD_VAR 0 1
56829: PPUSH
56830: EMPTY
56831: PPUSH
56832: CALL_OW 1
56836: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56837: LD_ADDR_EXP 83
56841: PUSH
56842: LD_EXP 83
56846: PPUSH
56847: LD_VAR 0 1
56851: PPUSH
56852: EMPTY
56853: PPUSH
56854: CALL_OW 1
56858: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56859: LD_ADDR_EXP 85
56863: PUSH
56864: LD_EXP 85
56868: PPUSH
56869: LD_VAR 0 1
56873: PPUSH
56874: EMPTY
56875: PPUSH
56876: CALL_OW 1
56880: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56881: LD_ADDR_EXP 87
56885: PUSH
56886: LD_EXP 87
56890: PPUSH
56891: LD_VAR 0 1
56895: PPUSH
56896: EMPTY
56897: PPUSH
56898: CALL_OW 1
56902: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56903: LD_ADDR_EXP 88
56907: PUSH
56908: LD_EXP 88
56912: PPUSH
56913: LD_VAR 0 1
56917: PPUSH
56918: EMPTY
56919: PPUSH
56920: CALL_OW 1
56924: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56925: LD_ADDR_EXP 89
56929: PUSH
56930: LD_EXP 89
56934: PPUSH
56935: LD_VAR 0 1
56939: PPUSH
56940: EMPTY
56941: PPUSH
56942: CALL_OW 1
56946: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56947: LD_ADDR_EXP 90
56951: PUSH
56952: LD_EXP 90
56956: PPUSH
56957: LD_VAR 0 1
56961: PPUSH
56962: EMPTY
56963: PPUSH
56964: CALL_OW 1
56968: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56969: LD_ADDR_EXP 91
56973: PUSH
56974: LD_EXP 91
56978: PPUSH
56979: LD_VAR 0 1
56983: PPUSH
56984: EMPTY
56985: PPUSH
56986: CALL_OW 1
56990: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56991: LD_ADDR_EXP 92
56995: PUSH
56996: LD_EXP 92
57000: PPUSH
57001: LD_VAR 0 1
57005: PPUSH
57006: EMPTY
57007: PPUSH
57008: CALL_OW 1
57012: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57013: LD_ADDR_EXP 93
57017: PUSH
57018: LD_EXP 93
57022: PPUSH
57023: LD_VAR 0 1
57027: PPUSH
57028: EMPTY
57029: PPUSH
57030: CALL_OW 1
57034: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57035: LD_ADDR_EXP 94
57039: PUSH
57040: LD_EXP 94
57044: PPUSH
57045: LD_VAR 0 1
57049: PPUSH
57050: EMPTY
57051: PPUSH
57052: CALL_OW 1
57056: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57057: LD_ADDR_EXP 95
57061: PUSH
57062: LD_EXP 95
57066: PPUSH
57067: LD_VAR 0 1
57071: PPUSH
57072: EMPTY
57073: PPUSH
57074: CALL_OW 1
57078: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57079: LD_ADDR_EXP 96
57083: PUSH
57084: LD_EXP 96
57088: PPUSH
57089: LD_VAR 0 1
57093: PPUSH
57094: EMPTY
57095: PPUSH
57096: CALL_OW 1
57100: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57101: LD_ADDR_EXP 97
57105: PUSH
57106: LD_EXP 97
57110: PPUSH
57111: LD_VAR 0 1
57115: PPUSH
57116: EMPTY
57117: PPUSH
57118: CALL_OW 1
57122: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57123: LD_ADDR_EXP 98
57127: PUSH
57128: LD_EXP 98
57132: PPUSH
57133: LD_VAR 0 1
57137: PPUSH
57138: EMPTY
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57145: LD_ADDR_EXP 99
57149: PUSH
57150: LD_EXP 99
57154: PPUSH
57155: LD_VAR 0 1
57159: PPUSH
57160: EMPTY
57161: PPUSH
57162: CALL_OW 1
57166: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57167: LD_ADDR_EXP 100
57171: PUSH
57172: LD_EXP 100
57176: PPUSH
57177: LD_VAR 0 1
57181: PPUSH
57182: LD_INT 0
57184: PPUSH
57185: CALL_OW 1
57189: ST_TO_ADDR
// end ;
57190: LD_VAR 0 2
57194: RET
// export function MC_Start ( ) ; var i ; begin
57195: LD_INT 0
57197: PPUSH
57198: PPUSH
// for i = 1 to mc_bases do
57199: LD_ADDR_VAR 0 2
57203: PUSH
57204: DOUBLE
57205: LD_INT 1
57207: DEC
57208: ST_TO_ADDR
57209: LD_EXP 58
57213: PUSH
57214: FOR_TO
57215: IFFALSE 58292
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57217: LD_ADDR_EXP 58
57221: PUSH
57222: LD_EXP 58
57226: PPUSH
57227: LD_VAR 0 2
57231: PPUSH
57232: LD_EXP 58
57236: PUSH
57237: LD_VAR 0 2
57241: ARRAY
57242: PUSH
57243: LD_INT 0
57245: DIFF
57246: PPUSH
57247: CALL_OW 1
57251: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57252: LD_ADDR_EXP 59
57256: PUSH
57257: LD_EXP 59
57261: PPUSH
57262: LD_VAR 0 2
57266: PPUSH
57267: EMPTY
57268: PPUSH
57269: CALL_OW 1
57273: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57274: LD_ADDR_EXP 60
57278: PUSH
57279: LD_EXP 60
57283: PPUSH
57284: LD_VAR 0 2
57288: PPUSH
57289: EMPTY
57290: PPUSH
57291: CALL_OW 1
57295: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57296: LD_ADDR_EXP 61
57300: PUSH
57301: LD_EXP 61
57305: PPUSH
57306: LD_VAR 0 2
57310: PPUSH
57311: EMPTY
57312: PPUSH
57313: CALL_OW 1
57317: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57318: LD_ADDR_EXP 62
57322: PUSH
57323: LD_EXP 62
57327: PPUSH
57328: LD_VAR 0 2
57332: PPUSH
57333: EMPTY
57334: PUSH
57335: EMPTY
57336: PUSH
57337: EMPTY
57338: LIST
57339: LIST
57340: PPUSH
57341: CALL_OW 1
57345: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57346: LD_ADDR_EXP 63
57350: PUSH
57351: LD_EXP 63
57355: PPUSH
57356: LD_VAR 0 2
57360: PPUSH
57361: EMPTY
57362: PPUSH
57363: CALL_OW 1
57367: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57368: LD_ADDR_EXP 90
57372: PUSH
57373: LD_EXP 90
57377: PPUSH
57378: LD_VAR 0 2
57382: PPUSH
57383: EMPTY
57384: PPUSH
57385: CALL_OW 1
57389: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57390: LD_ADDR_EXP 64
57394: PUSH
57395: LD_EXP 64
57399: PPUSH
57400: LD_VAR 0 2
57404: PPUSH
57405: EMPTY
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57412: LD_ADDR_EXP 65
57416: PUSH
57417: LD_EXP 65
57421: PPUSH
57422: LD_VAR 0 2
57426: PPUSH
57427: EMPTY
57428: PPUSH
57429: CALL_OW 1
57433: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57434: LD_ADDR_EXP 66
57438: PUSH
57439: LD_EXP 66
57443: PPUSH
57444: LD_VAR 0 2
57448: PPUSH
57449: LD_EXP 58
57453: PUSH
57454: LD_VAR 0 2
57458: ARRAY
57459: PPUSH
57460: LD_INT 2
57462: PUSH
57463: LD_INT 30
57465: PUSH
57466: LD_INT 32
57468: PUSH
57469: EMPTY
57470: LIST
57471: LIST
57472: PUSH
57473: LD_INT 30
57475: PUSH
57476: LD_INT 33
57478: PUSH
57479: EMPTY
57480: LIST
57481: LIST
57482: PUSH
57483: EMPTY
57484: LIST
57485: LIST
57486: LIST
57487: PPUSH
57488: CALL_OW 72
57492: PPUSH
57493: CALL_OW 1
57497: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57498: LD_ADDR_EXP 67
57502: PUSH
57503: LD_EXP 67
57507: PPUSH
57508: LD_VAR 0 2
57512: PPUSH
57513: LD_EXP 58
57517: PUSH
57518: LD_VAR 0 2
57522: ARRAY
57523: PPUSH
57524: LD_INT 2
57526: PUSH
57527: LD_INT 30
57529: PUSH
57530: LD_INT 32
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: PUSH
57537: LD_INT 30
57539: PUSH
57540: LD_INT 31
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: PUSH
57547: EMPTY
57548: LIST
57549: LIST
57550: LIST
57551: PUSH
57552: LD_INT 58
57554: PUSH
57555: EMPTY
57556: LIST
57557: PUSH
57558: EMPTY
57559: LIST
57560: LIST
57561: PPUSH
57562: CALL_OW 72
57566: PPUSH
57567: CALL_OW 1
57571: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57572: LD_ADDR_EXP 68
57576: PUSH
57577: LD_EXP 68
57581: PPUSH
57582: LD_VAR 0 2
57586: PPUSH
57587: EMPTY
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57594: LD_ADDR_EXP 72
57598: PUSH
57599: LD_EXP 72
57603: PPUSH
57604: LD_VAR 0 2
57608: PPUSH
57609: EMPTY
57610: PPUSH
57611: CALL_OW 1
57615: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57616: LD_ADDR_EXP 71
57620: PUSH
57621: LD_EXP 71
57625: PPUSH
57626: LD_VAR 0 2
57630: PPUSH
57631: EMPTY
57632: PPUSH
57633: CALL_OW 1
57637: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57638: LD_ADDR_EXP 73
57642: PUSH
57643: LD_EXP 73
57647: PPUSH
57648: LD_VAR 0 2
57652: PPUSH
57653: EMPTY
57654: PPUSH
57655: CALL_OW 1
57659: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57660: LD_ADDR_EXP 74
57664: PUSH
57665: LD_EXP 74
57669: PPUSH
57670: LD_VAR 0 2
57674: PPUSH
57675: EMPTY
57676: PPUSH
57677: CALL_OW 1
57681: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57682: LD_ADDR_EXP 75
57686: PUSH
57687: LD_EXP 75
57691: PPUSH
57692: LD_VAR 0 2
57696: PPUSH
57697: EMPTY
57698: PPUSH
57699: CALL_OW 1
57703: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57704: LD_ADDR_EXP 76
57708: PUSH
57709: LD_EXP 76
57713: PPUSH
57714: LD_VAR 0 2
57718: PPUSH
57719: EMPTY
57720: PPUSH
57721: CALL_OW 1
57725: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57726: LD_ADDR_EXP 77
57730: PUSH
57731: LD_EXP 77
57735: PPUSH
57736: LD_VAR 0 2
57740: PPUSH
57741: EMPTY
57742: PPUSH
57743: CALL_OW 1
57747: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57748: LD_ADDR_EXP 78
57752: PUSH
57753: LD_EXP 78
57757: PPUSH
57758: LD_VAR 0 2
57762: PPUSH
57763: EMPTY
57764: PPUSH
57765: CALL_OW 1
57769: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57770: LD_ADDR_EXP 79
57774: PUSH
57775: LD_EXP 79
57779: PPUSH
57780: LD_VAR 0 2
57784: PPUSH
57785: EMPTY
57786: PPUSH
57787: CALL_OW 1
57791: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57792: LD_ADDR_EXP 80
57796: PUSH
57797: LD_EXP 80
57801: PPUSH
57802: LD_VAR 0 2
57806: PPUSH
57807: EMPTY
57808: PPUSH
57809: CALL_OW 1
57813: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57814: LD_ADDR_EXP 69
57818: PUSH
57819: LD_EXP 69
57823: PPUSH
57824: LD_VAR 0 2
57828: PPUSH
57829: LD_INT 0
57831: PPUSH
57832: CALL_OW 1
57836: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57837: LD_ADDR_EXP 82
57841: PUSH
57842: LD_EXP 82
57846: PPUSH
57847: LD_VAR 0 2
57851: PPUSH
57852: LD_INT 0
57854: PPUSH
57855: CALL_OW 1
57859: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57860: LD_ADDR_EXP 70
57864: PUSH
57865: LD_EXP 70
57869: PPUSH
57870: LD_VAR 0 2
57874: PPUSH
57875: EMPTY
57876: PPUSH
57877: CALL_OW 1
57881: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57882: LD_ADDR_EXP 81
57886: PUSH
57887: LD_EXP 81
57891: PPUSH
57892: LD_VAR 0 2
57896: PPUSH
57897: LD_INT 0
57899: PPUSH
57900: CALL_OW 1
57904: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57905: LD_ADDR_EXP 83
57909: PUSH
57910: LD_EXP 83
57914: PPUSH
57915: LD_VAR 0 2
57919: PPUSH
57920: EMPTY
57921: PPUSH
57922: CALL_OW 1
57926: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57927: LD_ADDR_EXP 86
57931: PUSH
57932: LD_EXP 86
57936: PPUSH
57937: LD_VAR 0 2
57941: PPUSH
57942: LD_INT 0
57944: PPUSH
57945: CALL_OW 1
57949: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57950: LD_ADDR_EXP 87
57954: PUSH
57955: LD_EXP 87
57959: PPUSH
57960: LD_VAR 0 2
57964: PPUSH
57965: EMPTY
57966: PPUSH
57967: CALL_OW 1
57971: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57972: LD_ADDR_EXP 88
57976: PUSH
57977: LD_EXP 88
57981: PPUSH
57982: LD_VAR 0 2
57986: PPUSH
57987: EMPTY
57988: PPUSH
57989: CALL_OW 1
57993: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57994: LD_ADDR_EXP 89
57998: PUSH
57999: LD_EXP 89
58003: PPUSH
58004: LD_VAR 0 2
58008: PPUSH
58009: EMPTY
58010: PPUSH
58011: CALL_OW 1
58015: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
58016: LD_ADDR_EXP 91
58020: PUSH
58021: LD_EXP 91
58025: PPUSH
58026: LD_VAR 0 2
58030: PPUSH
58031: LD_EXP 58
58035: PUSH
58036: LD_VAR 0 2
58040: ARRAY
58041: PPUSH
58042: LD_INT 2
58044: PUSH
58045: LD_INT 30
58047: PUSH
58048: LD_INT 6
58050: PUSH
58051: EMPTY
58052: LIST
58053: LIST
58054: PUSH
58055: LD_INT 30
58057: PUSH
58058: LD_INT 7
58060: PUSH
58061: EMPTY
58062: LIST
58063: LIST
58064: PUSH
58065: LD_INT 30
58067: PUSH
58068: LD_INT 8
58070: PUSH
58071: EMPTY
58072: LIST
58073: LIST
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: LIST
58079: LIST
58080: PPUSH
58081: CALL_OW 72
58085: PPUSH
58086: CALL_OW 1
58090: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
58091: LD_ADDR_EXP 92
58095: PUSH
58096: LD_EXP 92
58100: PPUSH
58101: LD_VAR 0 2
58105: PPUSH
58106: EMPTY
58107: PPUSH
58108: CALL_OW 1
58112: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
58113: LD_ADDR_EXP 93
58117: PUSH
58118: LD_EXP 93
58122: PPUSH
58123: LD_VAR 0 2
58127: PPUSH
58128: EMPTY
58129: PPUSH
58130: CALL_OW 1
58134: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58135: LD_ADDR_EXP 94
58139: PUSH
58140: LD_EXP 94
58144: PPUSH
58145: LD_VAR 0 2
58149: PPUSH
58150: EMPTY
58151: PPUSH
58152: CALL_OW 1
58156: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58157: LD_ADDR_EXP 95
58161: PUSH
58162: LD_EXP 95
58166: PPUSH
58167: LD_VAR 0 2
58171: PPUSH
58172: EMPTY
58173: PPUSH
58174: CALL_OW 1
58178: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58179: LD_ADDR_EXP 96
58183: PUSH
58184: LD_EXP 96
58188: PPUSH
58189: LD_VAR 0 2
58193: PPUSH
58194: EMPTY
58195: PPUSH
58196: CALL_OW 1
58200: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58201: LD_ADDR_EXP 97
58205: PUSH
58206: LD_EXP 97
58210: PPUSH
58211: LD_VAR 0 2
58215: PPUSH
58216: EMPTY
58217: PPUSH
58218: CALL_OW 1
58222: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58223: LD_ADDR_EXP 98
58227: PUSH
58228: LD_EXP 98
58232: PPUSH
58233: LD_VAR 0 2
58237: PPUSH
58238: EMPTY
58239: PPUSH
58240: CALL_OW 1
58244: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58245: LD_ADDR_EXP 99
58249: PUSH
58250: LD_EXP 99
58254: PPUSH
58255: LD_VAR 0 2
58259: PPUSH
58260: EMPTY
58261: PPUSH
58262: CALL_OW 1
58266: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58267: LD_ADDR_EXP 100
58271: PUSH
58272: LD_EXP 100
58276: PPUSH
58277: LD_VAR 0 2
58281: PPUSH
58282: LD_INT 0
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
// end ;
58290: GO 57214
58292: POP
58293: POP
// MC_InitSides ( ) ;
58294: CALL 58580 0 0
// MC_InitResearch ( ) ;
58298: CALL 58319 0 0
// CustomInitMacro ( ) ;
58302: CALL 174 0 0
// skirmish := true ;
58306: LD_ADDR_EXP 56
58310: PUSH
58311: LD_INT 1
58313: ST_TO_ADDR
// end ;
58314: LD_VAR 0 1
58318: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58319: LD_INT 0
58321: PPUSH
58322: PPUSH
58323: PPUSH
58324: PPUSH
58325: PPUSH
58326: PPUSH
// if not mc_bases then
58327: LD_EXP 58
58331: NOT
58332: IFFALSE 58336
// exit ;
58334: GO 58575
// for i = 1 to 8 do
58336: LD_ADDR_VAR 0 2
58340: PUSH
58341: DOUBLE
58342: LD_INT 1
58344: DEC
58345: ST_TO_ADDR
58346: LD_INT 8
58348: PUSH
58349: FOR_TO
58350: IFFALSE 58376
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58352: LD_ADDR_EXP 85
58356: PUSH
58357: LD_EXP 85
58361: PPUSH
58362: LD_VAR 0 2
58366: PPUSH
58367: EMPTY
58368: PPUSH
58369: CALL_OW 1
58373: ST_TO_ADDR
58374: GO 58349
58376: POP
58377: POP
// tmp := [ ] ;
58378: LD_ADDR_VAR 0 5
58382: PUSH
58383: EMPTY
58384: ST_TO_ADDR
// for i = 1 to mc_sides do
58385: LD_ADDR_VAR 0 2
58389: PUSH
58390: DOUBLE
58391: LD_INT 1
58393: DEC
58394: ST_TO_ADDR
58395: LD_EXP 84
58399: PUSH
58400: FOR_TO
58401: IFFALSE 58459
// if not mc_sides [ i ] in tmp then
58403: LD_EXP 84
58407: PUSH
58408: LD_VAR 0 2
58412: ARRAY
58413: PUSH
58414: LD_VAR 0 5
58418: IN
58419: NOT
58420: IFFALSE 58457
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58422: LD_ADDR_VAR 0 5
58426: PUSH
58427: LD_VAR 0 5
58431: PPUSH
58432: LD_VAR 0 5
58436: PUSH
58437: LD_INT 1
58439: PLUS
58440: PPUSH
58441: LD_EXP 84
58445: PUSH
58446: LD_VAR 0 2
58450: ARRAY
58451: PPUSH
58452: CALL_OW 2
58456: ST_TO_ADDR
58457: GO 58400
58459: POP
58460: POP
// if not tmp then
58461: LD_VAR 0 5
58465: NOT
58466: IFFALSE 58470
// exit ;
58468: GO 58575
// for j in tmp do
58470: LD_ADDR_VAR 0 3
58474: PUSH
58475: LD_VAR 0 5
58479: PUSH
58480: FOR_IN
58481: IFFALSE 58573
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58483: LD_ADDR_VAR 0 6
58487: PUSH
58488: LD_INT 22
58490: PUSH
58491: LD_VAR 0 3
58495: PUSH
58496: EMPTY
58497: LIST
58498: LIST
58499: PPUSH
58500: CALL_OW 69
58504: ST_TO_ADDR
// if not un then
58505: LD_VAR 0 6
58509: NOT
58510: IFFALSE 58514
// continue ;
58512: GO 58480
// nation := GetNation ( un [ 1 ] ) ;
58514: LD_ADDR_VAR 0 4
58518: PUSH
58519: LD_VAR 0 6
58523: PUSH
58524: LD_INT 1
58526: ARRAY
58527: PPUSH
58528: CALL_OW 248
58532: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58533: LD_ADDR_EXP 85
58537: PUSH
58538: LD_EXP 85
58542: PPUSH
58543: LD_VAR 0 3
58547: PPUSH
58548: LD_VAR 0 3
58552: PPUSH
58553: LD_VAR 0 4
58557: PPUSH
58558: LD_INT 1
58560: PPUSH
58561: CALL 13578 0 3
58565: PPUSH
58566: CALL_OW 1
58570: ST_TO_ADDR
// end ;
58571: GO 58480
58573: POP
58574: POP
// end ;
58575: LD_VAR 0 1
58579: RET
// export function MC_InitSides ( ) ; var i ; begin
58580: LD_INT 0
58582: PPUSH
58583: PPUSH
// if not mc_bases then
58584: LD_EXP 58
58588: NOT
58589: IFFALSE 58593
// exit ;
58591: GO 58667
// for i = 1 to mc_bases do
58593: LD_ADDR_VAR 0 2
58597: PUSH
58598: DOUBLE
58599: LD_INT 1
58601: DEC
58602: ST_TO_ADDR
58603: LD_EXP 58
58607: PUSH
58608: FOR_TO
58609: IFFALSE 58665
// if mc_bases [ i ] then
58611: LD_EXP 58
58615: PUSH
58616: LD_VAR 0 2
58620: ARRAY
58621: IFFALSE 58663
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58623: LD_ADDR_EXP 84
58627: PUSH
58628: LD_EXP 84
58632: PPUSH
58633: LD_VAR 0 2
58637: PPUSH
58638: LD_EXP 58
58642: PUSH
58643: LD_VAR 0 2
58647: ARRAY
58648: PUSH
58649: LD_INT 1
58651: ARRAY
58652: PPUSH
58653: CALL_OW 255
58657: PPUSH
58658: CALL_OW 1
58662: ST_TO_ADDR
58663: GO 58608
58665: POP
58666: POP
// end ;
58667: LD_VAR 0 1
58671: RET
// every 0 0$01 trigger skirmish do
58672: LD_EXP 56
58676: IFFALSE 58830
58678: GO 58680
58680: DISABLE
// begin enable ;
58681: ENABLE
// MC_CheckBuildings ( ) ;
58682: CALL 62996 0 0
// MC_CheckPeopleLife ( ) ;
58686: CALL 63121 0 0
// RaiseSailEvent ( 100 ) ;
58690: LD_INT 100
58692: PPUSH
58693: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58697: LD_INT 103
58699: PPUSH
58700: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58704: LD_INT 104
58706: PPUSH
58707: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58711: LD_INT 105
58713: PPUSH
58714: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58718: LD_INT 106
58720: PPUSH
58721: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58725: LD_INT 107
58727: PPUSH
58728: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58732: LD_INT 108
58734: PPUSH
58735: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58739: LD_INT 109
58741: PPUSH
58742: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58746: LD_INT 110
58748: PPUSH
58749: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58753: LD_INT 111
58755: PPUSH
58756: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58760: LD_INT 112
58762: PPUSH
58763: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58767: LD_INT 113
58769: PPUSH
58770: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58774: LD_INT 120
58776: PPUSH
58777: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58781: LD_INT 121
58783: PPUSH
58784: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58788: LD_INT 122
58790: PPUSH
58791: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58795: LD_INT 123
58797: PPUSH
58798: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58802: LD_INT 124
58804: PPUSH
58805: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58809: LD_INT 125
58811: PPUSH
58812: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58816: LD_INT 126
58818: PPUSH
58819: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58823: LD_INT 200
58825: PPUSH
58826: CALL_OW 427
// end ;
58830: END
// on SailEvent ( event ) do begin if event < 100 then
58831: LD_VAR 0 1
58835: PUSH
58836: LD_INT 100
58838: LESS
58839: IFFALSE 58850
// CustomEvent ( event ) ;
58841: LD_VAR 0 1
58845: PPUSH
58846: CALL 12292 0 1
// if event = 100 then
58850: LD_VAR 0 1
58854: PUSH
58855: LD_INT 100
58857: EQUAL
58858: IFFALSE 58864
// MC_ClassManager ( ) ;
58860: CALL 59256 0 0
// if event = 101 then
58864: LD_VAR 0 1
58868: PUSH
58869: LD_INT 101
58871: EQUAL
58872: IFFALSE 58878
// MC_RepairBuildings ( ) ;
58874: CALL 63717 0 0
// if event = 102 then
58878: LD_VAR 0 1
58882: PUSH
58883: LD_INT 102
58885: EQUAL
58886: IFFALSE 58892
// MC_Heal ( ) ;
58888: CALL 64123 0 0
// if event = 103 then
58892: LD_VAR 0 1
58896: PUSH
58897: LD_INT 103
58899: EQUAL
58900: IFFALSE 58906
// MC_Build ( ) ;
58902: CALL 64545 0 0
// if event = 104 then
58906: LD_VAR 0 1
58910: PUSH
58911: LD_INT 104
58913: EQUAL
58914: IFFALSE 58920
// MC_TurretWeapon ( ) ;
58916: CALL 66158 0 0
// if event = 105 then
58920: LD_VAR 0 1
58924: PUSH
58925: LD_INT 105
58927: EQUAL
58928: IFFALSE 58934
// MC_BuildUpgrade ( ) ;
58930: CALL 65709 0 0
// if event = 106 then
58934: LD_VAR 0 1
58938: PUSH
58939: LD_INT 106
58941: EQUAL
58942: IFFALSE 58948
// MC_PlantMines ( ) ;
58944: CALL 66588 0 0
// if event = 107 then
58948: LD_VAR 0 1
58952: PUSH
58953: LD_INT 107
58955: EQUAL
58956: IFFALSE 58962
// MC_CollectCrates ( ) ;
58958: CALL 67622 0 0
// if event = 108 then
58962: LD_VAR 0 1
58966: PUSH
58967: LD_INT 108
58969: EQUAL
58970: IFFALSE 58976
// MC_LinkRemoteControl ( ) ;
58972: CALL 69379 0 0
// if event = 109 then
58976: LD_VAR 0 1
58980: PUSH
58981: LD_INT 109
58983: EQUAL
58984: IFFALSE 58990
// MC_ProduceVehicle ( ) ;
58986: CALL 69560 0 0
// if event = 110 then
58990: LD_VAR 0 1
58994: PUSH
58995: LD_INT 110
58997: EQUAL
58998: IFFALSE 59004
// MC_SendAttack ( ) ;
59000: CALL 70041 0 0
// if event = 111 then
59004: LD_VAR 0 1
59008: PUSH
59009: LD_INT 111
59011: EQUAL
59012: IFFALSE 59018
// MC_Defend ( ) ;
59014: CALL 70149 0 0
// if event = 112 then
59018: LD_VAR 0 1
59022: PUSH
59023: LD_INT 112
59025: EQUAL
59026: IFFALSE 59032
// MC_Research ( ) ;
59028: CALL 70776 0 0
// if event = 113 then
59032: LD_VAR 0 1
59036: PUSH
59037: LD_INT 113
59039: EQUAL
59040: IFFALSE 59046
// MC_MinesTrigger ( ) ;
59042: CALL 71890 0 0
// if event = 120 then
59046: LD_VAR 0 1
59050: PUSH
59051: LD_INT 120
59053: EQUAL
59054: IFFALSE 59060
// MC_RepairVehicle ( ) ;
59056: CALL 71989 0 0
// if event = 121 then
59060: LD_VAR 0 1
59064: PUSH
59065: LD_INT 121
59067: EQUAL
59068: IFFALSE 59074
// MC_TameApe ( ) ;
59070: CALL 72732 0 0
// if event = 122 then
59074: LD_VAR 0 1
59078: PUSH
59079: LD_INT 122
59081: EQUAL
59082: IFFALSE 59088
// MC_ChangeApeClass ( ) ;
59084: CALL 73561 0 0
// if event = 123 then
59088: LD_VAR 0 1
59092: PUSH
59093: LD_INT 123
59095: EQUAL
59096: IFFALSE 59102
// MC_Bazooka ( ) ;
59098: CALL 74211 0 0
// if event = 124 then
59102: LD_VAR 0 1
59106: PUSH
59107: LD_INT 124
59109: EQUAL
59110: IFFALSE 59116
// MC_TeleportExit ( ) ;
59112: CALL 74409 0 0
// if event = 125 then
59116: LD_VAR 0 1
59120: PUSH
59121: LD_INT 125
59123: EQUAL
59124: IFFALSE 59130
// MC_Deposits ( ) ;
59126: CALL 75056 0 0
// if event = 126 then
59130: LD_VAR 0 1
59134: PUSH
59135: LD_INT 126
59137: EQUAL
59138: IFFALSE 59144
// MC_RemoteDriver ( ) ;
59140: CALL 75681 0 0
// if event = 200 then
59144: LD_VAR 0 1
59148: PUSH
59149: LD_INT 200
59151: EQUAL
59152: IFFALSE 59158
// MC_Idle ( ) ;
59154: CALL 77414 0 0
// end ;
59158: PPOPN 1
59160: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59161: LD_INT 0
59163: PPUSH
59164: PPUSH
// if not mc_bases [ base ] or not tag then
59165: LD_EXP 58
59169: PUSH
59170: LD_VAR 0 1
59174: ARRAY
59175: NOT
59176: PUSH
59177: LD_VAR 0 2
59181: NOT
59182: OR
59183: IFFALSE 59187
// exit ;
59185: GO 59251
// for i in mc_bases [ base ] union mc_ape [ base ] do
59187: LD_ADDR_VAR 0 4
59191: PUSH
59192: LD_EXP 58
59196: PUSH
59197: LD_VAR 0 1
59201: ARRAY
59202: PUSH
59203: LD_EXP 87
59207: PUSH
59208: LD_VAR 0 1
59212: ARRAY
59213: UNION
59214: PUSH
59215: FOR_IN
59216: IFFALSE 59249
// if GetTag ( i ) = tag then
59218: LD_VAR 0 4
59222: PPUSH
59223: CALL_OW 110
59227: PUSH
59228: LD_VAR 0 2
59232: EQUAL
59233: IFFALSE 59247
// SetTag ( i , 0 ) ;
59235: LD_VAR 0 4
59239: PPUSH
59240: LD_INT 0
59242: PPUSH
59243: CALL_OW 109
59247: GO 59215
59249: POP
59250: POP
// end ;
59251: LD_VAR 0 3
59255: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59256: LD_INT 0
59258: PPUSH
59259: PPUSH
59260: PPUSH
59261: PPUSH
59262: PPUSH
59263: PPUSH
59264: PPUSH
59265: PPUSH
// if not mc_bases then
59266: LD_EXP 58
59270: NOT
59271: IFFALSE 59275
// exit ;
59273: GO 59733
// for i = 1 to mc_bases do
59275: LD_ADDR_VAR 0 2
59279: PUSH
59280: DOUBLE
59281: LD_INT 1
59283: DEC
59284: ST_TO_ADDR
59285: LD_EXP 58
59289: PUSH
59290: FOR_TO
59291: IFFALSE 59731
// begin tmp := MC_ClassCheckReq ( i ) ;
59293: LD_ADDR_VAR 0 4
59297: PUSH
59298: LD_VAR 0 2
59302: PPUSH
59303: CALL 59738 0 1
59307: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59308: LD_ADDR_EXP 99
59312: PUSH
59313: LD_EXP 99
59317: PPUSH
59318: LD_VAR 0 2
59322: PPUSH
59323: LD_VAR 0 4
59327: PPUSH
59328: CALL_OW 1
59332: ST_TO_ADDR
// if not tmp then
59333: LD_VAR 0 4
59337: NOT
59338: IFFALSE 59342
// continue ;
59340: GO 59290
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59342: LD_ADDR_VAR 0 6
59346: PUSH
59347: LD_EXP 58
59351: PUSH
59352: LD_VAR 0 2
59356: ARRAY
59357: PPUSH
59358: LD_INT 2
59360: PUSH
59361: LD_INT 30
59363: PUSH
59364: LD_INT 4
59366: PUSH
59367: EMPTY
59368: LIST
59369: LIST
59370: PUSH
59371: LD_INT 30
59373: PUSH
59374: LD_INT 5
59376: PUSH
59377: EMPTY
59378: LIST
59379: LIST
59380: PUSH
59381: EMPTY
59382: LIST
59383: LIST
59384: LIST
59385: PPUSH
59386: CALL_OW 72
59390: PUSH
59391: LD_EXP 58
59395: PUSH
59396: LD_VAR 0 2
59400: ARRAY
59401: PPUSH
59402: LD_INT 2
59404: PUSH
59405: LD_INT 30
59407: PUSH
59408: LD_INT 0
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: PUSH
59415: LD_INT 30
59417: PUSH
59418: LD_INT 1
59420: PUSH
59421: EMPTY
59422: LIST
59423: LIST
59424: PUSH
59425: EMPTY
59426: LIST
59427: LIST
59428: LIST
59429: PPUSH
59430: CALL_OW 72
59434: PUSH
59435: LD_EXP 58
59439: PUSH
59440: LD_VAR 0 2
59444: ARRAY
59445: PPUSH
59446: LD_INT 30
59448: PUSH
59449: LD_INT 3
59451: PUSH
59452: EMPTY
59453: LIST
59454: LIST
59455: PPUSH
59456: CALL_OW 72
59460: PUSH
59461: LD_EXP 58
59465: PUSH
59466: LD_VAR 0 2
59470: ARRAY
59471: PPUSH
59472: LD_INT 2
59474: PUSH
59475: LD_INT 30
59477: PUSH
59478: LD_INT 6
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: PUSH
59485: LD_INT 30
59487: PUSH
59488: LD_INT 7
59490: PUSH
59491: EMPTY
59492: LIST
59493: LIST
59494: PUSH
59495: LD_INT 30
59497: PUSH
59498: LD_INT 8
59500: PUSH
59501: EMPTY
59502: LIST
59503: LIST
59504: PUSH
59505: EMPTY
59506: LIST
59507: LIST
59508: LIST
59509: LIST
59510: PPUSH
59511: CALL_OW 72
59515: PUSH
59516: EMPTY
59517: LIST
59518: LIST
59519: LIST
59520: LIST
59521: ST_TO_ADDR
// for j = 1 to 4 do
59522: LD_ADDR_VAR 0 3
59526: PUSH
59527: DOUBLE
59528: LD_INT 1
59530: DEC
59531: ST_TO_ADDR
59532: LD_INT 4
59534: PUSH
59535: FOR_TO
59536: IFFALSE 59727
// begin if not tmp [ j ] then
59538: LD_VAR 0 4
59542: PUSH
59543: LD_VAR 0 3
59547: ARRAY
59548: NOT
59549: IFFALSE 59553
// continue ;
59551: GO 59535
// for p in tmp [ j ] do
59553: LD_ADDR_VAR 0 5
59557: PUSH
59558: LD_VAR 0 4
59562: PUSH
59563: LD_VAR 0 3
59567: ARRAY
59568: PUSH
59569: FOR_IN
59570: IFFALSE 59723
// begin if not b [ j ] then
59572: LD_VAR 0 6
59576: PUSH
59577: LD_VAR 0 3
59581: ARRAY
59582: NOT
59583: IFFALSE 59587
// break ;
59585: GO 59723
// e := 0 ;
59587: LD_ADDR_VAR 0 7
59591: PUSH
59592: LD_INT 0
59594: ST_TO_ADDR
// for k in b [ j ] do
59595: LD_ADDR_VAR 0 8
59599: PUSH
59600: LD_VAR 0 6
59604: PUSH
59605: LD_VAR 0 3
59609: ARRAY
59610: PUSH
59611: FOR_IN
59612: IFFALSE 59639
// if IsNotFull ( k ) then
59614: LD_VAR 0 8
59618: PPUSH
59619: CALL 17604 0 1
59623: IFFALSE 59637
// begin e := k ;
59625: LD_ADDR_VAR 0 7
59629: PUSH
59630: LD_VAR 0 8
59634: ST_TO_ADDR
// break ;
59635: GO 59639
// end ;
59637: GO 59611
59639: POP
59640: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59641: LD_VAR 0 7
59645: PUSH
59646: LD_VAR 0 5
59650: PPUSH
59651: LD_VAR 0 7
59655: PPUSH
59656: CALL 54592 0 2
59660: NOT
59661: AND
59662: IFFALSE 59721
// begin if IsInUnit ( p ) then
59664: LD_VAR 0 5
59668: PPUSH
59669: CALL_OW 310
59673: IFFALSE 59684
// ComExitBuilding ( p ) ;
59675: LD_VAR 0 5
59679: PPUSH
59680: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59684: LD_VAR 0 5
59688: PPUSH
59689: LD_VAR 0 7
59693: PPUSH
59694: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59698: LD_VAR 0 5
59702: PPUSH
59703: LD_VAR 0 3
59707: PPUSH
59708: CALL_OW 183
// AddComExitBuilding ( p ) ;
59712: LD_VAR 0 5
59716: PPUSH
59717: CALL_OW 182
// end ; end ;
59721: GO 59569
59723: POP
59724: POP
// end ;
59725: GO 59535
59727: POP
59728: POP
// end ;
59729: GO 59290
59731: POP
59732: POP
// end ;
59733: LD_VAR 0 1
59737: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59738: LD_INT 0
59740: PPUSH
59741: PPUSH
59742: PPUSH
59743: PPUSH
59744: PPUSH
59745: PPUSH
59746: PPUSH
59747: PPUSH
59748: PPUSH
59749: PPUSH
59750: PPUSH
59751: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59752: LD_VAR 0 1
59756: NOT
59757: PUSH
59758: LD_EXP 58
59762: PUSH
59763: LD_VAR 0 1
59767: ARRAY
59768: NOT
59769: OR
59770: PUSH
59771: LD_EXP 58
59775: PUSH
59776: LD_VAR 0 1
59780: ARRAY
59781: PPUSH
59782: LD_INT 2
59784: PUSH
59785: LD_INT 30
59787: PUSH
59788: LD_INT 0
59790: PUSH
59791: EMPTY
59792: LIST
59793: LIST
59794: PUSH
59795: LD_INT 30
59797: PUSH
59798: LD_INT 1
59800: PUSH
59801: EMPTY
59802: LIST
59803: LIST
59804: PUSH
59805: EMPTY
59806: LIST
59807: LIST
59808: LIST
59809: PPUSH
59810: CALL_OW 72
59814: NOT
59815: OR
59816: IFFALSE 59820
// exit ;
59818: GO 62991
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59820: LD_ADDR_VAR 0 4
59824: PUSH
59825: LD_EXP 58
59829: PUSH
59830: LD_VAR 0 1
59834: ARRAY
59835: PPUSH
59836: LD_INT 2
59838: PUSH
59839: LD_INT 25
59841: PUSH
59842: LD_INT 1
59844: PUSH
59845: EMPTY
59846: LIST
59847: LIST
59848: PUSH
59849: LD_INT 25
59851: PUSH
59852: LD_INT 2
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: LD_INT 25
59861: PUSH
59862: LD_INT 3
59864: PUSH
59865: EMPTY
59866: LIST
59867: LIST
59868: PUSH
59869: LD_INT 25
59871: PUSH
59872: LD_INT 4
59874: PUSH
59875: EMPTY
59876: LIST
59877: LIST
59878: PUSH
59879: LD_INT 25
59881: PUSH
59882: LD_INT 5
59884: PUSH
59885: EMPTY
59886: LIST
59887: LIST
59888: PUSH
59889: LD_INT 25
59891: PUSH
59892: LD_INT 8
59894: PUSH
59895: EMPTY
59896: LIST
59897: LIST
59898: PUSH
59899: LD_INT 25
59901: PUSH
59902: LD_INT 9
59904: PUSH
59905: EMPTY
59906: LIST
59907: LIST
59908: PUSH
59909: EMPTY
59910: LIST
59911: LIST
59912: LIST
59913: LIST
59914: LIST
59915: LIST
59916: LIST
59917: LIST
59918: PPUSH
59919: CALL_OW 72
59923: ST_TO_ADDR
// for i in tmp do
59924: LD_ADDR_VAR 0 3
59928: PUSH
59929: LD_VAR 0 4
59933: PUSH
59934: FOR_IN
59935: IFFALSE 59966
// if GetTag ( i ) then
59937: LD_VAR 0 3
59941: PPUSH
59942: CALL_OW 110
59946: IFFALSE 59964
// tmp := tmp diff i ;
59948: LD_ADDR_VAR 0 4
59952: PUSH
59953: LD_VAR 0 4
59957: PUSH
59958: LD_VAR 0 3
59962: DIFF
59963: ST_TO_ADDR
59964: GO 59934
59966: POP
59967: POP
// if not tmp then
59968: LD_VAR 0 4
59972: NOT
59973: IFFALSE 59977
// exit ;
59975: GO 62991
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59977: LD_ADDR_VAR 0 5
59981: PUSH
59982: LD_EXP 58
59986: PUSH
59987: LD_VAR 0 1
59991: ARRAY
59992: PPUSH
59993: LD_INT 2
59995: PUSH
59996: LD_INT 25
59998: PUSH
59999: LD_INT 1
60001: PUSH
60002: EMPTY
60003: LIST
60004: LIST
60005: PUSH
60006: LD_INT 25
60008: PUSH
60009: LD_INT 5
60011: PUSH
60012: EMPTY
60013: LIST
60014: LIST
60015: PUSH
60016: LD_INT 25
60018: PUSH
60019: LD_INT 8
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: PUSH
60026: LD_INT 25
60028: PUSH
60029: LD_INT 9
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: EMPTY
60037: LIST
60038: LIST
60039: LIST
60040: LIST
60041: LIST
60042: PPUSH
60043: CALL_OW 72
60047: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
60048: LD_ADDR_VAR 0 6
60052: PUSH
60053: LD_EXP 58
60057: PUSH
60058: LD_VAR 0 1
60062: ARRAY
60063: PPUSH
60064: LD_INT 25
60066: PUSH
60067: LD_INT 2
60069: PUSH
60070: EMPTY
60071: LIST
60072: LIST
60073: PPUSH
60074: CALL_OW 72
60078: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
60079: LD_ADDR_VAR 0 7
60083: PUSH
60084: LD_EXP 58
60088: PUSH
60089: LD_VAR 0 1
60093: ARRAY
60094: PPUSH
60095: LD_INT 25
60097: PUSH
60098: LD_INT 3
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PPUSH
60105: CALL_OW 72
60109: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60110: LD_ADDR_VAR 0 8
60114: PUSH
60115: LD_EXP 58
60119: PUSH
60120: LD_VAR 0 1
60124: ARRAY
60125: PPUSH
60126: LD_INT 25
60128: PUSH
60129: LD_INT 4
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PUSH
60136: LD_INT 24
60138: PUSH
60139: LD_INT 251
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: EMPTY
60147: LIST
60148: LIST
60149: PPUSH
60150: CALL_OW 72
60154: ST_TO_ADDR
// if mc_scan [ base ] then
60155: LD_EXP 81
60159: PUSH
60160: LD_VAR 0 1
60164: ARRAY
60165: IFFALSE 60626
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60167: LD_ADDR_EXP 100
60171: PUSH
60172: LD_EXP 100
60176: PPUSH
60177: LD_VAR 0 1
60181: PPUSH
60182: LD_INT 4
60184: PPUSH
60185: CALL_OW 1
60189: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60190: LD_ADDR_VAR 0 12
60194: PUSH
60195: LD_EXP 58
60199: PUSH
60200: LD_VAR 0 1
60204: ARRAY
60205: PPUSH
60206: LD_INT 2
60208: PUSH
60209: LD_INT 30
60211: PUSH
60212: LD_INT 4
60214: PUSH
60215: EMPTY
60216: LIST
60217: LIST
60218: PUSH
60219: LD_INT 30
60221: PUSH
60222: LD_INT 5
60224: PUSH
60225: EMPTY
60226: LIST
60227: LIST
60228: PUSH
60229: EMPTY
60230: LIST
60231: LIST
60232: LIST
60233: PPUSH
60234: CALL_OW 72
60238: ST_TO_ADDR
// if not b then
60239: LD_VAR 0 12
60243: NOT
60244: IFFALSE 60248
// exit ;
60246: GO 62991
// p := [ ] ;
60248: LD_ADDR_VAR 0 11
60252: PUSH
60253: EMPTY
60254: ST_TO_ADDR
// if sci >= 2 then
60255: LD_VAR 0 8
60259: PUSH
60260: LD_INT 2
60262: GREATEREQUAL
60263: IFFALSE 60294
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60265: LD_ADDR_VAR 0 8
60269: PUSH
60270: LD_VAR 0 8
60274: PUSH
60275: LD_INT 1
60277: ARRAY
60278: PUSH
60279: LD_VAR 0 8
60283: PUSH
60284: LD_INT 2
60286: ARRAY
60287: PUSH
60288: EMPTY
60289: LIST
60290: LIST
60291: ST_TO_ADDR
60292: GO 60355
// if sci = 1 then
60294: LD_VAR 0 8
60298: PUSH
60299: LD_INT 1
60301: EQUAL
60302: IFFALSE 60323
// sci := [ sci [ 1 ] ] else
60304: LD_ADDR_VAR 0 8
60308: PUSH
60309: LD_VAR 0 8
60313: PUSH
60314: LD_INT 1
60316: ARRAY
60317: PUSH
60318: EMPTY
60319: LIST
60320: ST_TO_ADDR
60321: GO 60355
// if sci = 0 then
60323: LD_VAR 0 8
60327: PUSH
60328: LD_INT 0
60330: EQUAL
60331: IFFALSE 60355
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60333: LD_ADDR_VAR 0 11
60337: PUSH
60338: LD_VAR 0 4
60342: PPUSH
60343: LD_INT 4
60345: PPUSH
60346: CALL 54455 0 2
60350: PUSH
60351: LD_INT 1
60353: ARRAY
60354: ST_TO_ADDR
// if eng > 4 then
60355: LD_VAR 0 6
60359: PUSH
60360: LD_INT 4
60362: GREATER
60363: IFFALSE 60409
// for i = eng downto 4 do
60365: LD_ADDR_VAR 0 3
60369: PUSH
60370: DOUBLE
60371: LD_VAR 0 6
60375: INC
60376: ST_TO_ADDR
60377: LD_INT 4
60379: PUSH
60380: FOR_DOWNTO
60381: IFFALSE 60407
// eng := eng diff eng [ i ] ;
60383: LD_ADDR_VAR 0 6
60387: PUSH
60388: LD_VAR 0 6
60392: PUSH
60393: LD_VAR 0 6
60397: PUSH
60398: LD_VAR 0 3
60402: ARRAY
60403: DIFF
60404: ST_TO_ADDR
60405: GO 60380
60407: POP
60408: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60409: LD_ADDR_VAR 0 4
60413: PUSH
60414: LD_VAR 0 4
60418: PUSH
60419: LD_VAR 0 5
60423: PUSH
60424: LD_VAR 0 6
60428: UNION
60429: PUSH
60430: LD_VAR 0 7
60434: UNION
60435: PUSH
60436: LD_VAR 0 8
60440: UNION
60441: DIFF
60442: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60443: LD_ADDR_VAR 0 13
60447: PUSH
60448: LD_EXP 58
60452: PUSH
60453: LD_VAR 0 1
60457: ARRAY
60458: PPUSH
60459: LD_INT 2
60461: PUSH
60462: LD_INT 30
60464: PUSH
60465: LD_INT 32
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PUSH
60472: LD_INT 30
60474: PUSH
60475: LD_INT 31
60477: PUSH
60478: EMPTY
60479: LIST
60480: LIST
60481: PUSH
60482: EMPTY
60483: LIST
60484: LIST
60485: LIST
60486: PPUSH
60487: CALL_OW 72
60491: PUSH
60492: LD_EXP 58
60496: PUSH
60497: LD_VAR 0 1
60501: ARRAY
60502: PPUSH
60503: LD_INT 2
60505: PUSH
60506: LD_INT 30
60508: PUSH
60509: LD_INT 4
60511: PUSH
60512: EMPTY
60513: LIST
60514: LIST
60515: PUSH
60516: LD_INT 30
60518: PUSH
60519: LD_INT 5
60521: PUSH
60522: EMPTY
60523: LIST
60524: LIST
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: LIST
60530: PPUSH
60531: CALL_OW 72
60535: PUSH
60536: LD_INT 6
60538: MUL
60539: PLUS
60540: ST_TO_ADDR
// if bcount < tmp then
60541: LD_VAR 0 13
60545: PUSH
60546: LD_VAR 0 4
60550: LESS
60551: IFFALSE 60597
// for i = tmp downto bcount do
60553: LD_ADDR_VAR 0 3
60557: PUSH
60558: DOUBLE
60559: LD_VAR 0 4
60563: INC
60564: ST_TO_ADDR
60565: LD_VAR 0 13
60569: PUSH
60570: FOR_DOWNTO
60571: IFFALSE 60595
// tmp := Delete ( tmp , tmp ) ;
60573: LD_ADDR_VAR 0 4
60577: PUSH
60578: LD_VAR 0 4
60582: PPUSH
60583: LD_VAR 0 4
60587: PPUSH
60588: CALL_OW 3
60592: ST_TO_ADDR
60593: GO 60570
60595: POP
60596: POP
// result := [ tmp , 0 , 0 , p ] ;
60597: LD_ADDR_VAR 0 2
60601: PUSH
60602: LD_VAR 0 4
60606: PUSH
60607: LD_INT 0
60609: PUSH
60610: LD_INT 0
60612: PUSH
60613: LD_VAR 0 11
60617: PUSH
60618: EMPTY
60619: LIST
60620: LIST
60621: LIST
60622: LIST
60623: ST_TO_ADDR
// exit ;
60624: GO 62991
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60626: LD_EXP 58
60630: PUSH
60631: LD_VAR 0 1
60635: ARRAY
60636: PPUSH
60637: LD_INT 2
60639: PUSH
60640: LD_INT 30
60642: PUSH
60643: LD_INT 6
60645: PUSH
60646: EMPTY
60647: LIST
60648: LIST
60649: PUSH
60650: LD_INT 30
60652: PUSH
60653: LD_INT 7
60655: PUSH
60656: EMPTY
60657: LIST
60658: LIST
60659: PUSH
60660: LD_INT 30
60662: PUSH
60663: LD_INT 8
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PUSH
60670: EMPTY
60671: LIST
60672: LIST
60673: LIST
60674: LIST
60675: PPUSH
60676: CALL_OW 72
60680: NOT
60681: PUSH
60682: LD_EXP 58
60686: PUSH
60687: LD_VAR 0 1
60691: ARRAY
60692: PPUSH
60693: LD_INT 30
60695: PUSH
60696: LD_INT 3
60698: PUSH
60699: EMPTY
60700: LIST
60701: LIST
60702: PPUSH
60703: CALL_OW 72
60707: NOT
60708: AND
60709: IFFALSE 60781
// begin if eng = tmp then
60711: LD_VAR 0 6
60715: PUSH
60716: LD_VAR 0 4
60720: EQUAL
60721: IFFALSE 60725
// exit ;
60723: GO 62991
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60725: LD_ADDR_EXP 100
60729: PUSH
60730: LD_EXP 100
60734: PPUSH
60735: LD_VAR 0 1
60739: PPUSH
60740: LD_INT 1
60742: PPUSH
60743: CALL_OW 1
60747: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60748: LD_ADDR_VAR 0 2
60752: PUSH
60753: LD_INT 0
60755: PUSH
60756: LD_VAR 0 4
60760: PUSH
60761: LD_VAR 0 6
60765: DIFF
60766: PUSH
60767: LD_INT 0
60769: PUSH
60770: LD_INT 0
60772: PUSH
60773: EMPTY
60774: LIST
60775: LIST
60776: LIST
60777: LIST
60778: ST_TO_ADDR
// exit ;
60779: GO 62991
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60781: LD_EXP 85
60785: PUSH
60786: LD_EXP 84
60790: PUSH
60791: LD_VAR 0 1
60795: ARRAY
60796: ARRAY
60797: PUSH
60798: LD_EXP 58
60802: PUSH
60803: LD_VAR 0 1
60807: ARRAY
60808: PPUSH
60809: LD_INT 2
60811: PUSH
60812: LD_INT 30
60814: PUSH
60815: LD_INT 6
60817: PUSH
60818: EMPTY
60819: LIST
60820: LIST
60821: PUSH
60822: LD_INT 30
60824: PUSH
60825: LD_INT 7
60827: PUSH
60828: EMPTY
60829: LIST
60830: LIST
60831: PUSH
60832: LD_INT 30
60834: PUSH
60835: LD_INT 8
60837: PUSH
60838: EMPTY
60839: LIST
60840: LIST
60841: PUSH
60842: EMPTY
60843: LIST
60844: LIST
60845: LIST
60846: LIST
60847: PPUSH
60848: CALL_OW 72
60852: AND
60853: PUSH
60854: LD_EXP 58
60858: PUSH
60859: LD_VAR 0 1
60863: ARRAY
60864: PPUSH
60865: LD_INT 30
60867: PUSH
60868: LD_INT 3
60870: PUSH
60871: EMPTY
60872: LIST
60873: LIST
60874: PPUSH
60875: CALL_OW 72
60879: NOT
60880: AND
60881: IFFALSE 61095
// begin if sci >= 6 then
60883: LD_VAR 0 8
60887: PUSH
60888: LD_INT 6
60890: GREATEREQUAL
60891: IFFALSE 60895
// exit ;
60893: GO 62991
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60895: LD_ADDR_EXP 100
60899: PUSH
60900: LD_EXP 100
60904: PPUSH
60905: LD_VAR 0 1
60909: PPUSH
60910: LD_INT 2
60912: PPUSH
60913: CALL_OW 1
60917: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60918: LD_ADDR_VAR 0 9
60922: PUSH
60923: LD_VAR 0 4
60927: PUSH
60928: LD_VAR 0 8
60932: DIFF
60933: PPUSH
60934: LD_INT 4
60936: PPUSH
60937: CALL 54455 0 2
60941: ST_TO_ADDR
// p := [ ] ;
60942: LD_ADDR_VAR 0 11
60946: PUSH
60947: EMPTY
60948: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60949: LD_VAR 0 8
60953: PUSH
60954: LD_INT 6
60956: LESS
60957: PUSH
60958: LD_VAR 0 9
60962: PUSH
60963: LD_INT 6
60965: GREATER
60966: AND
60967: IFFALSE 61048
// begin for i = 1 to 6 - sci do
60969: LD_ADDR_VAR 0 3
60973: PUSH
60974: DOUBLE
60975: LD_INT 1
60977: DEC
60978: ST_TO_ADDR
60979: LD_INT 6
60981: PUSH
60982: LD_VAR 0 8
60986: MINUS
60987: PUSH
60988: FOR_TO
60989: IFFALSE 61044
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60991: LD_ADDR_VAR 0 11
60995: PUSH
60996: LD_VAR 0 11
61000: PPUSH
61001: LD_VAR 0 11
61005: PUSH
61006: LD_INT 1
61008: PLUS
61009: PPUSH
61010: LD_VAR 0 9
61014: PUSH
61015: LD_INT 1
61017: ARRAY
61018: PPUSH
61019: CALL_OW 2
61023: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
61024: LD_ADDR_VAR 0 9
61028: PUSH
61029: LD_VAR 0 9
61033: PPUSH
61034: LD_INT 1
61036: PPUSH
61037: CALL_OW 3
61041: ST_TO_ADDR
// end ;
61042: GO 60988
61044: POP
61045: POP
// end else
61046: GO 61068
// if sort then
61048: LD_VAR 0 9
61052: IFFALSE 61068
// p := sort [ 1 ] ;
61054: LD_ADDR_VAR 0 11
61058: PUSH
61059: LD_VAR 0 9
61063: PUSH
61064: LD_INT 1
61066: ARRAY
61067: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
61068: LD_ADDR_VAR 0 2
61072: PUSH
61073: LD_INT 0
61075: PUSH
61076: LD_INT 0
61078: PUSH
61079: LD_INT 0
61081: PUSH
61082: LD_VAR 0 11
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: LIST
61091: LIST
61092: ST_TO_ADDR
// exit ;
61093: GO 62991
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61095: LD_EXP 85
61099: PUSH
61100: LD_EXP 84
61104: PUSH
61105: LD_VAR 0 1
61109: ARRAY
61110: ARRAY
61111: PUSH
61112: LD_EXP 58
61116: PUSH
61117: LD_VAR 0 1
61121: ARRAY
61122: PPUSH
61123: LD_INT 2
61125: PUSH
61126: LD_INT 30
61128: PUSH
61129: LD_INT 6
61131: PUSH
61132: EMPTY
61133: LIST
61134: LIST
61135: PUSH
61136: LD_INT 30
61138: PUSH
61139: LD_INT 7
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 30
61148: PUSH
61149: LD_INT 8
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: LIST
61160: LIST
61161: PPUSH
61162: CALL_OW 72
61166: AND
61167: PUSH
61168: LD_EXP 58
61172: PUSH
61173: LD_VAR 0 1
61177: ARRAY
61178: PPUSH
61179: LD_INT 30
61181: PUSH
61182: LD_INT 3
61184: PUSH
61185: EMPTY
61186: LIST
61187: LIST
61188: PPUSH
61189: CALL_OW 72
61193: AND
61194: IFFALSE 61721
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61196: LD_ADDR_EXP 100
61200: PUSH
61201: LD_EXP 100
61205: PPUSH
61206: LD_VAR 0 1
61210: PPUSH
61211: LD_INT 3
61213: PPUSH
61214: CALL_OW 1
61218: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61219: LD_ADDR_VAR 0 2
61223: PUSH
61224: LD_INT 0
61226: PUSH
61227: LD_INT 0
61229: PUSH
61230: LD_INT 0
61232: PUSH
61233: LD_INT 0
61235: PUSH
61236: EMPTY
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: ST_TO_ADDR
// if not eng then
61242: LD_VAR 0 6
61246: NOT
61247: IFFALSE 61310
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61249: LD_ADDR_VAR 0 11
61253: PUSH
61254: LD_VAR 0 4
61258: PPUSH
61259: LD_INT 2
61261: PPUSH
61262: CALL 54455 0 2
61266: PUSH
61267: LD_INT 1
61269: ARRAY
61270: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61271: LD_ADDR_VAR 0 2
61275: PUSH
61276: LD_VAR 0 2
61280: PPUSH
61281: LD_INT 2
61283: PPUSH
61284: LD_VAR 0 11
61288: PPUSH
61289: CALL_OW 1
61293: ST_TO_ADDR
// tmp := tmp diff p ;
61294: LD_ADDR_VAR 0 4
61298: PUSH
61299: LD_VAR 0 4
61303: PUSH
61304: LD_VAR 0 11
61308: DIFF
61309: ST_TO_ADDR
// end ; if not eng then
61310: LD_VAR 0 6
61314: NOT
61315: IFFALSE 61341
// tmp := tmp diff ( mech union sci ) else
61317: LD_ADDR_VAR 0 4
61321: PUSH
61322: LD_VAR 0 4
61326: PUSH
61327: LD_VAR 0 7
61331: PUSH
61332: LD_VAR 0 8
61336: UNION
61337: DIFF
61338: ST_TO_ADDR
61339: GO 61373
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
61341: LD_ADDR_VAR 0 4
61345: PUSH
61346: LD_VAR 0 4
61350: PUSH
61351: LD_VAR 0 6
61355: PUSH
61356: LD_INT 1
61358: ARRAY
61359: PUSH
61360: LD_VAR 0 7
61364: UNION
61365: PUSH
61366: LD_VAR 0 8
61370: UNION
61371: DIFF
61372: ST_TO_ADDR
// if tmp and sci < 6 then
61373: LD_VAR 0 4
61377: PUSH
61378: LD_VAR 0 8
61382: PUSH
61383: LD_INT 6
61385: LESS
61386: AND
61387: IFFALSE 61546
// begin sort := SortBySkill ( tmp , 4 ) ;
61389: LD_ADDR_VAR 0 9
61393: PUSH
61394: LD_VAR 0 4
61398: PPUSH
61399: LD_INT 4
61401: PPUSH
61402: CALL 54455 0 2
61406: ST_TO_ADDR
// p := [ ] ;
61407: LD_ADDR_VAR 0 11
61411: PUSH
61412: EMPTY
61413: ST_TO_ADDR
// if sort then
61414: LD_VAR 0 9
61418: IFFALSE 61517
// for i = 1 to 6 - sci do
61420: LD_ADDR_VAR 0 3
61424: PUSH
61425: DOUBLE
61426: LD_INT 1
61428: DEC
61429: ST_TO_ADDR
61430: LD_INT 6
61432: PUSH
61433: LD_VAR 0 8
61437: MINUS
61438: PUSH
61439: FOR_TO
61440: IFFALSE 61515
// begin if i = sort then
61442: LD_VAR 0 3
61446: PUSH
61447: LD_VAR 0 9
61451: EQUAL
61452: IFFALSE 61456
// break ;
61454: GO 61515
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61456: LD_ADDR_VAR 0 11
61460: PUSH
61461: LD_VAR 0 11
61465: PPUSH
61466: LD_VAR 0 11
61470: PUSH
61471: LD_INT 1
61473: PLUS
61474: PPUSH
61475: LD_VAR 0 9
61479: PUSH
61480: LD_VAR 0 3
61484: ARRAY
61485: PPUSH
61486: CALL_OW 2
61490: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61491: LD_ADDR_VAR 0 4
61495: PUSH
61496: LD_VAR 0 4
61500: PUSH
61501: LD_VAR 0 9
61505: PUSH
61506: LD_VAR 0 3
61510: ARRAY
61511: DIFF
61512: ST_TO_ADDR
// end ;
61513: GO 61439
61515: POP
61516: POP
// if p then
61517: LD_VAR 0 11
61521: IFFALSE 61546
// result := Replace ( result , 4 , p ) ;
61523: LD_ADDR_VAR 0 2
61527: PUSH
61528: LD_VAR 0 2
61532: PPUSH
61533: LD_INT 4
61535: PPUSH
61536: LD_VAR 0 11
61540: PPUSH
61541: CALL_OW 1
61545: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61546: LD_VAR 0 4
61550: PUSH
61551: LD_VAR 0 7
61555: PUSH
61556: LD_INT 6
61558: LESS
61559: AND
61560: IFFALSE 61719
// begin sort := SortBySkill ( tmp , 3 ) ;
61562: LD_ADDR_VAR 0 9
61566: PUSH
61567: LD_VAR 0 4
61571: PPUSH
61572: LD_INT 3
61574: PPUSH
61575: CALL 54455 0 2
61579: ST_TO_ADDR
// p := [ ] ;
61580: LD_ADDR_VAR 0 11
61584: PUSH
61585: EMPTY
61586: ST_TO_ADDR
// if sort then
61587: LD_VAR 0 9
61591: IFFALSE 61690
// for i = 1 to 6 - mech do
61593: LD_ADDR_VAR 0 3
61597: PUSH
61598: DOUBLE
61599: LD_INT 1
61601: DEC
61602: ST_TO_ADDR
61603: LD_INT 6
61605: PUSH
61606: LD_VAR 0 7
61610: MINUS
61611: PUSH
61612: FOR_TO
61613: IFFALSE 61688
// begin if i = sort then
61615: LD_VAR 0 3
61619: PUSH
61620: LD_VAR 0 9
61624: EQUAL
61625: IFFALSE 61629
// break ;
61627: GO 61688
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61629: LD_ADDR_VAR 0 11
61633: PUSH
61634: LD_VAR 0 11
61638: PPUSH
61639: LD_VAR 0 11
61643: PUSH
61644: LD_INT 1
61646: PLUS
61647: PPUSH
61648: LD_VAR 0 9
61652: PUSH
61653: LD_VAR 0 3
61657: ARRAY
61658: PPUSH
61659: CALL_OW 2
61663: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61664: LD_ADDR_VAR 0 4
61668: PUSH
61669: LD_VAR 0 4
61673: PUSH
61674: LD_VAR 0 9
61678: PUSH
61679: LD_VAR 0 3
61683: ARRAY
61684: DIFF
61685: ST_TO_ADDR
// end ;
61686: GO 61612
61688: POP
61689: POP
// if p then
61690: LD_VAR 0 11
61694: IFFALSE 61719
// result := Replace ( result , 3 , p ) ;
61696: LD_ADDR_VAR 0 2
61700: PUSH
61701: LD_VAR 0 2
61705: PPUSH
61706: LD_INT 3
61708: PPUSH
61709: LD_VAR 0 11
61713: PPUSH
61714: CALL_OW 1
61718: ST_TO_ADDR
// end ; exit ;
61719: GO 62991
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61721: LD_EXP 85
61725: PUSH
61726: LD_EXP 84
61730: PUSH
61731: LD_VAR 0 1
61735: ARRAY
61736: ARRAY
61737: NOT
61738: PUSH
61739: LD_EXP 58
61743: PUSH
61744: LD_VAR 0 1
61748: ARRAY
61749: PPUSH
61750: LD_INT 30
61752: PUSH
61753: LD_INT 3
61755: PUSH
61756: EMPTY
61757: LIST
61758: LIST
61759: PPUSH
61760: CALL_OW 72
61764: AND
61765: PUSH
61766: LD_EXP 63
61770: PUSH
61771: LD_VAR 0 1
61775: ARRAY
61776: AND
61777: IFFALSE 62321
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61779: LD_ADDR_EXP 100
61783: PUSH
61784: LD_EXP 100
61788: PPUSH
61789: LD_VAR 0 1
61793: PPUSH
61794: LD_INT 5
61796: PPUSH
61797: CALL_OW 1
61801: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61802: LD_ADDR_VAR 0 2
61806: PUSH
61807: LD_INT 0
61809: PUSH
61810: LD_INT 0
61812: PUSH
61813: LD_INT 0
61815: PUSH
61816: LD_INT 0
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: LIST
61823: LIST
61824: ST_TO_ADDR
// if sci > 1 then
61825: LD_VAR 0 8
61829: PUSH
61830: LD_INT 1
61832: GREATER
61833: IFFALSE 61861
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61835: LD_ADDR_VAR 0 4
61839: PUSH
61840: LD_VAR 0 4
61844: PUSH
61845: LD_VAR 0 8
61849: PUSH
61850: LD_VAR 0 8
61854: PUSH
61855: LD_INT 1
61857: ARRAY
61858: DIFF
61859: DIFF
61860: ST_TO_ADDR
// if tmp and not sci then
61861: LD_VAR 0 4
61865: PUSH
61866: LD_VAR 0 8
61870: NOT
61871: AND
61872: IFFALSE 61941
// begin sort := SortBySkill ( tmp , 4 ) ;
61874: LD_ADDR_VAR 0 9
61878: PUSH
61879: LD_VAR 0 4
61883: PPUSH
61884: LD_INT 4
61886: PPUSH
61887: CALL 54455 0 2
61891: ST_TO_ADDR
// if sort then
61892: LD_VAR 0 9
61896: IFFALSE 61912
// p := sort [ 1 ] ;
61898: LD_ADDR_VAR 0 11
61902: PUSH
61903: LD_VAR 0 9
61907: PUSH
61908: LD_INT 1
61910: ARRAY
61911: ST_TO_ADDR
// if p then
61912: LD_VAR 0 11
61916: IFFALSE 61941
// result := Replace ( result , 4 , p ) ;
61918: LD_ADDR_VAR 0 2
61922: PUSH
61923: LD_VAR 0 2
61927: PPUSH
61928: LD_INT 4
61930: PPUSH
61931: LD_VAR 0 11
61935: PPUSH
61936: CALL_OW 1
61940: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61941: LD_ADDR_VAR 0 4
61945: PUSH
61946: LD_VAR 0 4
61950: PUSH
61951: LD_VAR 0 7
61955: DIFF
61956: ST_TO_ADDR
// if tmp and mech < 6 then
61957: LD_VAR 0 4
61961: PUSH
61962: LD_VAR 0 7
61966: PUSH
61967: LD_INT 6
61969: LESS
61970: AND
61971: IFFALSE 62130
// begin sort := SortBySkill ( tmp , 3 ) ;
61973: LD_ADDR_VAR 0 9
61977: PUSH
61978: LD_VAR 0 4
61982: PPUSH
61983: LD_INT 3
61985: PPUSH
61986: CALL 54455 0 2
61990: ST_TO_ADDR
// p := [ ] ;
61991: LD_ADDR_VAR 0 11
61995: PUSH
61996: EMPTY
61997: ST_TO_ADDR
// if sort then
61998: LD_VAR 0 9
62002: IFFALSE 62101
// for i = 1 to 6 - mech do
62004: LD_ADDR_VAR 0 3
62008: PUSH
62009: DOUBLE
62010: LD_INT 1
62012: DEC
62013: ST_TO_ADDR
62014: LD_INT 6
62016: PUSH
62017: LD_VAR 0 7
62021: MINUS
62022: PUSH
62023: FOR_TO
62024: IFFALSE 62099
// begin if i = sort then
62026: LD_VAR 0 3
62030: PUSH
62031: LD_VAR 0 9
62035: EQUAL
62036: IFFALSE 62040
// break ;
62038: GO 62099
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62040: LD_ADDR_VAR 0 11
62044: PUSH
62045: LD_VAR 0 11
62049: PPUSH
62050: LD_VAR 0 11
62054: PUSH
62055: LD_INT 1
62057: PLUS
62058: PPUSH
62059: LD_VAR 0 9
62063: PUSH
62064: LD_VAR 0 3
62068: ARRAY
62069: PPUSH
62070: CALL_OW 2
62074: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62075: LD_ADDR_VAR 0 4
62079: PUSH
62080: LD_VAR 0 4
62084: PUSH
62085: LD_VAR 0 9
62089: PUSH
62090: LD_VAR 0 3
62094: ARRAY
62095: DIFF
62096: ST_TO_ADDR
// end ;
62097: GO 62023
62099: POP
62100: POP
// if p then
62101: LD_VAR 0 11
62105: IFFALSE 62130
// result := Replace ( result , 3 , p ) ;
62107: LD_ADDR_VAR 0 2
62111: PUSH
62112: LD_VAR 0 2
62116: PPUSH
62117: LD_INT 3
62119: PPUSH
62120: LD_VAR 0 11
62124: PPUSH
62125: CALL_OW 1
62129: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62130: LD_ADDR_VAR 0 4
62134: PUSH
62135: LD_VAR 0 4
62139: PUSH
62140: LD_VAR 0 6
62144: DIFF
62145: ST_TO_ADDR
// if tmp and eng < 6 then
62146: LD_VAR 0 4
62150: PUSH
62151: LD_VAR 0 6
62155: PUSH
62156: LD_INT 6
62158: LESS
62159: AND
62160: IFFALSE 62319
// begin sort := SortBySkill ( tmp , 2 ) ;
62162: LD_ADDR_VAR 0 9
62166: PUSH
62167: LD_VAR 0 4
62171: PPUSH
62172: LD_INT 2
62174: PPUSH
62175: CALL 54455 0 2
62179: ST_TO_ADDR
// p := [ ] ;
62180: LD_ADDR_VAR 0 11
62184: PUSH
62185: EMPTY
62186: ST_TO_ADDR
// if sort then
62187: LD_VAR 0 9
62191: IFFALSE 62290
// for i = 1 to 6 - eng do
62193: LD_ADDR_VAR 0 3
62197: PUSH
62198: DOUBLE
62199: LD_INT 1
62201: DEC
62202: ST_TO_ADDR
62203: LD_INT 6
62205: PUSH
62206: LD_VAR 0 6
62210: MINUS
62211: PUSH
62212: FOR_TO
62213: IFFALSE 62288
// begin if i = sort then
62215: LD_VAR 0 3
62219: PUSH
62220: LD_VAR 0 9
62224: EQUAL
62225: IFFALSE 62229
// break ;
62227: GO 62288
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62229: LD_ADDR_VAR 0 11
62233: PUSH
62234: LD_VAR 0 11
62238: PPUSH
62239: LD_VAR 0 11
62243: PUSH
62244: LD_INT 1
62246: PLUS
62247: PPUSH
62248: LD_VAR 0 9
62252: PUSH
62253: LD_VAR 0 3
62257: ARRAY
62258: PPUSH
62259: CALL_OW 2
62263: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62264: LD_ADDR_VAR 0 4
62268: PUSH
62269: LD_VAR 0 4
62273: PUSH
62274: LD_VAR 0 9
62278: PUSH
62279: LD_VAR 0 3
62283: ARRAY
62284: DIFF
62285: ST_TO_ADDR
// end ;
62286: GO 62212
62288: POP
62289: POP
// if p then
62290: LD_VAR 0 11
62294: IFFALSE 62319
// result := Replace ( result , 2 , p ) ;
62296: LD_ADDR_VAR 0 2
62300: PUSH
62301: LD_VAR 0 2
62305: PPUSH
62306: LD_INT 2
62308: PPUSH
62309: LD_VAR 0 11
62313: PPUSH
62314: CALL_OW 1
62318: ST_TO_ADDR
// end ; exit ;
62319: GO 62991
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62321: LD_EXP 85
62325: PUSH
62326: LD_EXP 84
62330: PUSH
62331: LD_VAR 0 1
62335: ARRAY
62336: ARRAY
62337: NOT
62338: PUSH
62339: LD_EXP 58
62343: PUSH
62344: LD_VAR 0 1
62348: ARRAY
62349: PPUSH
62350: LD_INT 30
62352: PUSH
62353: LD_INT 3
62355: PUSH
62356: EMPTY
62357: LIST
62358: LIST
62359: PPUSH
62360: CALL_OW 72
62364: AND
62365: PUSH
62366: LD_EXP 63
62370: PUSH
62371: LD_VAR 0 1
62375: ARRAY
62376: NOT
62377: AND
62378: IFFALSE 62991
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62380: LD_ADDR_EXP 100
62384: PUSH
62385: LD_EXP 100
62389: PPUSH
62390: LD_VAR 0 1
62394: PPUSH
62395: LD_INT 6
62397: PPUSH
62398: CALL_OW 1
62402: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62403: LD_ADDR_VAR 0 2
62407: PUSH
62408: LD_INT 0
62410: PUSH
62411: LD_INT 0
62413: PUSH
62414: LD_INT 0
62416: PUSH
62417: LD_INT 0
62419: PUSH
62420: EMPTY
62421: LIST
62422: LIST
62423: LIST
62424: LIST
62425: ST_TO_ADDR
// if sci >= 1 then
62426: LD_VAR 0 8
62430: PUSH
62431: LD_INT 1
62433: GREATEREQUAL
62434: IFFALSE 62456
// tmp := tmp diff sci [ 1 ] ;
62436: LD_ADDR_VAR 0 4
62440: PUSH
62441: LD_VAR 0 4
62445: PUSH
62446: LD_VAR 0 8
62450: PUSH
62451: LD_INT 1
62453: ARRAY
62454: DIFF
62455: ST_TO_ADDR
// if tmp and not sci then
62456: LD_VAR 0 4
62460: PUSH
62461: LD_VAR 0 8
62465: NOT
62466: AND
62467: IFFALSE 62536
// begin sort := SortBySkill ( tmp , 4 ) ;
62469: LD_ADDR_VAR 0 9
62473: PUSH
62474: LD_VAR 0 4
62478: PPUSH
62479: LD_INT 4
62481: PPUSH
62482: CALL 54455 0 2
62486: ST_TO_ADDR
// if sort then
62487: LD_VAR 0 9
62491: IFFALSE 62507
// p := sort [ 1 ] ;
62493: LD_ADDR_VAR 0 11
62497: PUSH
62498: LD_VAR 0 9
62502: PUSH
62503: LD_INT 1
62505: ARRAY
62506: ST_TO_ADDR
// if p then
62507: LD_VAR 0 11
62511: IFFALSE 62536
// result := Replace ( result , 4 , p ) ;
62513: LD_ADDR_VAR 0 2
62517: PUSH
62518: LD_VAR 0 2
62522: PPUSH
62523: LD_INT 4
62525: PPUSH
62526: LD_VAR 0 11
62530: PPUSH
62531: CALL_OW 1
62535: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62536: LD_ADDR_VAR 0 4
62540: PUSH
62541: LD_VAR 0 4
62545: PUSH
62546: LD_VAR 0 7
62550: DIFF
62551: ST_TO_ADDR
// if tmp and mech < 6 then
62552: LD_VAR 0 4
62556: PUSH
62557: LD_VAR 0 7
62561: PUSH
62562: LD_INT 6
62564: LESS
62565: AND
62566: IFFALSE 62725
// begin sort := SortBySkill ( tmp , 3 ) ;
62568: LD_ADDR_VAR 0 9
62572: PUSH
62573: LD_VAR 0 4
62577: PPUSH
62578: LD_INT 3
62580: PPUSH
62581: CALL 54455 0 2
62585: ST_TO_ADDR
// p := [ ] ;
62586: LD_ADDR_VAR 0 11
62590: PUSH
62591: EMPTY
62592: ST_TO_ADDR
// if sort then
62593: LD_VAR 0 9
62597: IFFALSE 62696
// for i = 1 to 6 - mech do
62599: LD_ADDR_VAR 0 3
62603: PUSH
62604: DOUBLE
62605: LD_INT 1
62607: DEC
62608: ST_TO_ADDR
62609: LD_INT 6
62611: PUSH
62612: LD_VAR 0 7
62616: MINUS
62617: PUSH
62618: FOR_TO
62619: IFFALSE 62694
// begin if i = sort then
62621: LD_VAR 0 3
62625: PUSH
62626: LD_VAR 0 9
62630: EQUAL
62631: IFFALSE 62635
// break ;
62633: GO 62694
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62635: LD_ADDR_VAR 0 11
62639: PUSH
62640: LD_VAR 0 11
62644: PPUSH
62645: LD_VAR 0 11
62649: PUSH
62650: LD_INT 1
62652: PLUS
62653: PPUSH
62654: LD_VAR 0 9
62658: PUSH
62659: LD_VAR 0 3
62663: ARRAY
62664: PPUSH
62665: CALL_OW 2
62669: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62670: LD_ADDR_VAR 0 4
62674: PUSH
62675: LD_VAR 0 4
62679: PUSH
62680: LD_VAR 0 9
62684: PUSH
62685: LD_VAR 0 3
62689: ARRAY
62690: DIFF
62691: ST_TO_ADDR
// end ;
62692: GO 62618
62694: POP
62695: POP
// if p then
62696: LD_VAR 0 11
62700: IFFALSE 62725
// result := Replace ( result , 3 , p ) ;
62702: LD_ADDR_VAR 0 2
62706: PUSH
62707: LD_VAR 0 2
62711: PPUSH
62712: LD_INT 3
62714: PPUSH
62715: LD_VAR 0 11
62719: PPUSH
62720: CALL_OW 1
62724: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62725: LD_ADDR_VAR 0 4
62729: PUSH
62730: LD_VAR 0 4
62734: PUSH
62735: LD_VAR 0 6
62739: DIFF
62740: ST_TO_ADDR
// if tmp and eng < 4 then
62741: LD_VAR 0 4
62745: PUSH
62746: LD_VAR 0 6
62750: PUSH
62751: LD_INT 4
62753: LESS
62754: AND
62755: IFFALSE 62916
// begin sort := SortBySkill ( tmp , 2 ) ;
62757: LD_ADDR_VAR 0 9
62761: PUSH
62762: LD_VAR 0 4
62766: PPUSH
62767: LD_INT 2
62769: PPUSH
62770: CALL 54455 0 2
62774: ST_TO_ADDR
// p := [ ] ;
62775: LD_ADDR_VAR 0 11
62779: PUSH
62780: EMPTY
62781: ST_TO_ADDR
// if sort then
62782: LD_VAR 0 9
62786: IFFALSE 62885
// for i = 1 to 4 - eng do
62788: LD_ADDR_VAR 0 3
62792: PUSH
62793: DOUBLE
62794: LD_INT 1
62796: DEC
62797: ST_TO_ADDR
62798: LD_INT 4
62800: PUSH
62801: LD_VAR 0 6
62805: MINUS
62806: PUSH
62807: FOR_TO
62808: IFFALSE 62883
// begin if i = sort then
62810: LD_VAR 0 3
62814: PUSH
62815: LD_VAR 0 9
62819: EQUAL
62820: IFFALSE 62824
// break ;
62822: GO 62883
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62824: LD_ADDR_VAR 0 11
62828: PUSH
62829: LD_VAR 0 11
62833: PPUSH
62834: LD_VAR 0 11
62838: PUSH
62839: LD_INT 1
62841: PLUS
62842: PPUSH
62843: LD_VAR 0 9
62847: PUSH
62848: LD_VAR 0 3
62852: ARRAY
62853: PPUSH
62854: CALL_OW 2
62858: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62859: LD_ADDR_VAR 0 4
62863: PUSH
62864: LD_VAR 0 4
62868: PUSH
62869: LD_VAR 0 9
62873: PUSH
62874: LD_VAR 0 3
62878: ARRAY
62879: DIFF
62880: ST_TO_ADDR
// end ;
62881: GO 62807
62883: POP
62884: POP
// if p then
62885: LD_VAR 0 11
62889: IFFALSE 62914
// result := Replace ( result , 2 , p ) ;
62891: LD_ADDR_VAR 0 2
62895: PUSH
62896: LD_VAR 0 2
62900: PPUSH
62901: LD_INT 2
62903: PPUSH
62904: LD_VAR 0 11
62908: PPUSH
62909: CALL_OW 1
62913: ST_TO_ADDR
// end else
62914: GO 62960
// for i = eng downto 5 do
62916: LD_ADDR_VAR 0 3
62920: PUSH
62921: DOUBLE
62922: LD_VAR 0 6
62926: INC
62927: ST_TO_ADDR
62928: LD_INT 5
62930: PUSH
62931: FOR_DOWNTO
62932: IFFALSE 62958
// tmp := tmp union eng [ i ] ;
62934: LD_ADDR_VAR 0 4
62938: PUSH
62939: LD_VAR 0 4
62943: PUSH
62944: LD_VAR 0 6
62948: PUSH
62949: LD_VAR 0 3
62953: ARRAY
62954: UNION
62955: ST_TO_ADDR
62956: GO 62931
62958: POP
62959: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62960: LD_ADDR_VAR 0 2
62964: PUSH
62965: LD_VAR 0 2
62969: PPUSH
62970: LD_INT 1
62972: PPUSH
62973: LD_VAR 0 4
62977: PUSH
62978: LD_VAR 0 5
62982: DIFF
62983: PPUSH
62984: CALL_OW 1
62988: ST_TO_ADDR
// exit ;
62989: GO 62991
// end ; end ;
62991: LD_VAR 0 2
62995: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62996: LD_INT 0
62998: PPUSH
62999: PPUSH
63000: PPUSH
// if not mc_bases then
63001: LD_EXP 58
63005: NOT
63006: IFFALSE 63010
// exit ;
63008: GO 63116
// for i = 1 to mc_bases do
63010: LD_ADDR_VAR 0 2
63014: PUSH
63015: DOUBLE
63016: LD_INT 1
63018: DEC
63019: ST_TO_ADDR
63020: LD_EXP 58
63024: PUSH
63025: FOR_TO
63026: IFFALSE 63107
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63028: LD_ADDR_VAR 0 3
63032: PUSH
63033: LD_EXP 58
63037: PUSH
63038: LD_VAR 0 2
63042: ARRAY
63043: PPUSH
63044: LD_INT 21
63046: PUSH
63047: LD_INT 3
63049: PUSH
63050: EMPTY
63051: LIST
63052: LIST
63053: PUSH
63054: LD_INT 3
63056: PUSH
63057: LD_INT 24
63059: PUSH
63060: LD_INT 1000
63062: PUSH
63063: EMPTY
63064: LIST
63065: LIST
63066: PUSH
63067: EMPTY
63068: LIST
63069: LIST
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PPUSH
63075: CALL_OW 72
63079: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63080: LD_ADDR_EXP 59
63084: PUSH
63085: LD_EXP 59
63089: PPUSH
63090: LD_VAR 0 2
63094: PPUSH
63095: LD_VAR 0 3
63099: PPUSH
63100: CALL_OW 1
63104: ST_TO_ADDR
// end ;
63105: GO 63025
63107: POP
63108: POP
// RaiseSailEvent ( 101 ) ;
63109: LD_INT 101
63111: PPUSH
63112: CALL_OW 427
// end ;
63116: LD_VAR 0 1
63120: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63121: LD_INT 0
63123: PPUSH
63124: PPUSH
63125: PPUSH
63126: PPUSH
63127: PPUSH
63128: PPUSH
63129: PPUSH
// if not mc_bases then
63130: LD_EXP 58
63134: NOT
63135: IFFALSE 63139
// exit ;
63137: GO 63712
// for i = 1 to mc_bases do
63139: LD_ADDR_VAR 0 2
63143: PUSH
63144: DOUBLE
63145: LD_INT 1
63147: DEC
63148: ST_TO_ADDR
63149: LD_EXP 58
63153: PUSH
63154: FOR_TO
63155: IFFALSE 63703
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
63157: LD_ADDR_VAR 0 5
63161: PUSH
63162: LD_EXP 58
63166: PUSH
63167: LD_VAR 0 2
63171: ARRAY
63172: PUSH
63173: LD_EXP 87
63177: PUSH
63178: LD_VAR 0 2
63182: ARRAY
63183: UNION
63184: PPUSH
63185: LD_INT 21
63187: PUSH
63188: LD_INT 1
63190: PUSH
63191: EMPTY
63192: LIST
63193: LIST
63194: PUSH
63195: LD_INT 1
63197: PUSH
63198: LD_INT 3
63200: PUSH
63201: LD_INT 54
63203: PUSH
63204: EMPTY
63205: LIST
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 3
63213: PUSH
63214: LD_INT 24
63216: PUSH
63217: LD_INT 750
63219: PUSH
63220: EMPTY
63221: LIST
63222: LIST
63223: PUSH
63224: EMPTY
63225: LIST
63226: LIST
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: LIST
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PPUSH
63237: CALL_OW 72
63241: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63242: LD_ADDR_VAR 0 6
63246: PUSH
63247: LD_EXP 58
63251: PUSH
63252: LD_VAR 0 2
63256: ARRAY
63257: PPUSH
63258: LD_INT 21
63260: PUSH
63261: LD_INT 1
63263: PUSH
63264: EMPTY
63265: LIST
63266: LIST
63267: PUSH
63268: LD_INT 1
63270: PUSH
63271: LD_INT 3
63273: PUSH
63274: LD_INT 54
63276: PUSH
63277: EMPTY
63278: LIST
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 3
63286: PUSH
63287: LD_INT 24
63289: PUSH
63290: LD_INT 250
63292: PUSH
63293: EMPTY
63294: LIST
63295: LIST
63296: PUSH
63297: EMPTY
63298: LIST
63299: LIST
63300: PUSH
63301: EMPTY
63302: LIST
63303: LIST
63304: LIST
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: PPUSH
63310: CALL_OW 72
63314: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63315: LD_ADDR_VAR 0 7
63319: PUSH
63320: LD_VAR 0 5
63324: PUSH
63325: LD_VAR 0 6
63329: DIFF
63330: ST_TO_ADDR
// if not need_heal_1 then
63331: LD_VAR 0 6
63335: NOT
63336: IFFALSE 63369
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63338: LD_ADDR_EXP 61
63342: PUSH
63343: LD_EXP 61
63347: PPUSH
63348: LD_VAR 0 2
63352: PUSH
63353: LD_INT 1
63355: PUSH
63356: EMPTY
63357: LIST
63358: LIST
63359: PPUSH
63360: EMPTY
63361: PPUSH
63362: CALL 20270 0 3
63366: ST_TO_ADDR
63367: GO 63439
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63369: LD_ADDR_EXP 61
63373: PUSH
63374: LD_EXP 61
63378: PPUSH
63379: LD_VAR 0 2
63383: PUSH
63384: LD_INT 1
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PPUSH
63391: LD_EXP 61
63395: PUSH
63396: LD_VAR 0 2
63400: ARRAY
63401: PUSH
63402: LD_INT 1
63404: ARRAY
63405: PPUSH
63406: LD_INT 3
63408: PUSH
63409: LD_INT 24
63411: PUSH
63412: LD_INT 1000
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: EMPTY
63420: LIST
63421: LIST
63422: PPUSH
63423: CALL_OW 72
63427: PUSH
63428: LD_VAR 0 6
63432: UNION
63433: PPUSH
63434: CALL 20270 0 3
63438: ST_TO_ADDR
// if not need_heal_2 then
63439: LD_VAR 0 7
63443: NOT
63444: IFFALSE 63477
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63446: LD_ADDR_EXP 61
63450: PUSH
63451: LD_EXP 61
63455: PPUSH
63456: LD_VAR 0 2
63460: PUSH
63461: LD_INT 2
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PPUSH
63468: EMPTY
63469: PPUSH
63470: CALL 20270 0 3
63474: ST_TO_ADDR
63475: GO 63509
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63477: LD_ADDR_EXP 61
63481: PUSH
63482: LD_EXP 61
63486: PPUSH
63487: LD_VAR 0 2
63491: PUSH
63492: LD_INT 2
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: PPUSH
63499: LD_VAR 0 7
63503: PPUSH
63504: CALL 20270 0 3
63508: ST_TO_ADDR
// if need_heal_2 then
63509: LD_VAR 0 7
63513: IFFALSE 63685
// for j in need_heal_2 do
63515: LD_ADDR_VAR 0 3
63519: PUSH
63520: LD_VAR 0 7
63524: PUSH
63525: FOR_IN
63526: IFFALSE 63683
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
63528: LD_ADDR_VAR 0 5
63532: PUSH
63533: LD_EXP 58
63537: PUSH
63538: LD_VAR 0 2
63542: ARRAY
63543: PPUSH
63544: LD_INT 2
63546: PUSH
63547: LD_INT 30
63549: PUSH
63550: LD_INT 6
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: LD_INT 30
63559: PUSH
63560: LD_INT 7
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 30
63569: PUSH
63570: LD_INT 8
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 30
63579: PUSH
63580: LD_INT 0
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: LD_INT 30
63589: PUSH
63590: LD_INT 1
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: PUSH
63597: LD_INT 25
63599: PUSH
63600: LD_INT 4
63602: PUSH
63603: EMPTY
63604: LIST
63605: LIST
63606: PUSH
63607: EMPTY
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: LIST
63615: PPUSH
63616: CALL_OW 72
63620: ST_TO_ADDR
// if tmp then
63621: LD_VAR 0 5
63625: IFFALSE 63681
// begin k := NearestUnitToUnit ( tmp , j ) ;
63627: LD_ADDR_VAR 0 4
63631: PUSH
63632: LD_VAR 0 5
63636: PPUSH
63637: LD_VAR 0 3
63641: PPUSH
63642: CALL_OW 74
63646: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63647: LD_VAR 0 3
63651: PPUSH
63652: LD_VAR 0 4
63656: PPUSH
63657: CALL_OW 296
63661: PUSH
63662: LD_INT 7
63664: GREATER
63665: IFFALSE 63681
// ComMoveUnit ( j , k ) ;
63667: LD_VAR 0 3
63671: PPUSH
63672: LD_VAR 0 4
63676: PPUSH
63677: CALL_OW 112
// end ; end ;
63681: GO 63525
63683: POP
63684: POP
// if not need_heal_1 and not need_heal_2 then
63685: LD_VAR 0 6
63689: NOT
63690: PUSH
63691: LD_VAR 0 7
63695: NOT
63696: AND
63697: IFFALSE 63701
// continue ;
63699: GO 63154
// end ;
63701: GO 63154
63703: POP
63704: POP
// RaiseSailEvent ( 102 ) ;
63705: LD_INT 102
63707: PPUSH
63708: CALL_OW 427
// end ;
63712: LD_VAR 0 1
63716: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
63717: LD_INT 0
63719: PPUSH
63720: PPUSH
63721: PPUSH
63722: PPUSH
63723: PPUSH
// if not mc_bases then
63724: LD_EXP 58
63728: NOT
63729: IFFALSE 63733
// exit ;
63731: GO 64118
// for i = 1 to mc_bases do
63733: LD_ADDR_VAR 0 2
63737: PUSH
63738: DOUBLE
63739: LD_INT 1
63741: DEC
63742: ST_TO_ADDR
63743: LD_EXP 58
63747: PUSH
63748: FOR_TO
63749: IFFALSE 64116
// begin if not mc_building_need_repair [ i ] then
63751: LD_EXP 59
63755: PUSH
63756: LD_VAR 0 2
63760: ARRAY
63761: NOT
63762: IFFALSE 63800
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63764: LD_ADDR_EXP 60
63768: PUSH
63769: LD_EXP 60
63773: PPUSH
63774: LD_VAR 0 2
63778: PPUSH
63779: EMPTY
63780: PPUSH
63781: CALL_OW 1
63785: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63786: LD_VAR 0 2
63790: PPUSH
63791: LD_INT 101
63793: PPUSH
63794: CALL 59161 0 2
// continue ;
63798: GO 63748
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63800: LD_ADDR_EXP 64
63804: PUSH
63805: LD_EXP 64
63809: PPUSH
63810: LD_VAR 0 2
63814: PPUSH
63815: EMPTY
63816: PPUSH
63817: CALL_OW 1
63821: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63822: LD_VAR 0 2
63826: PPUSH
63827: LD_INT 103
63829: PPUSH
63830: CALL 59161 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63834: LD_ADDR_VAR 0 5
63838: PUSH
63839: LD_EXP 58
63843: PUSH
63844: LD_VAR 0 2
63848: ARRAY
63849: PUSH
63850: LD_EXP 87
63854: PUSH
63855: LD_VAR 0 2
63859: ARRAY
63860: UNION
63861: PPUSH
63862: LD_INT 2
63864: PUSH
63865: LD_INT 25
63867: PUSH
63868: LD_INT 2
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 25
63877: PUSH
63878: LD_INT 16
63880: PUSH
63881: EMPTY
63882: LIST
63883: LIST
63884: PUSH
63885: EMPTY
63886: LIST
63887: LIST
63888: LIST
63889: PUSH
63890: EMPTY
63891: LIST
63892: PPUSH
63893: CALL_OW 72
63897: ST_TO_ADDR
// if not tmp then
63898: LD_VAR 0 5
63902: NOT
63903: IFFALSE 63907
// continue ;
63905: GO 63748
// for j in tmp do
63907: LD_ADDR_VAR 0 3
63911: PUSH
63912: LD_VAR 0 5
63916: PUSH
63917: FOR_IN
63918: IFFALSE 64112
// begin if mc_need_heal [ i ] then
63920: LD_EXP 61
63924: PUSH
63925: LD_VAR 0 2
63929: ARRAY
63930: IFFALSE 63978
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63932: LD_VAR 0 3
63936: PUSH
63937: LD_EXP 61
63941: PUSH
63942: LD_VAR 0 2
63946: ARRAY
63947: PUSH
63948: LD_INT 1
63950: ARRAY
63951: IN
63952: PUSH
63953: LD_VAR 0 3
63957: PUSH
63958: LD_EXP 61
63962: PUSH
63963: LD_VAR 0 2
63967: ARRAY
63968: PUSH
63969: LD_INT 2
63971: ARRAY
63972: IN
63973: OR
63974: IFFALSE 63978
// continue ;
63976: GO 63917
// if IsInUnit ( j ) then
63978: LD_VAR 0 3
63982: PPUSH
63983: CALL_OW 310
63987: IFFALSE 63998
// ComExitBuilding ( j ) ;
63989: LD_VAR 0 3
63993: PPUSH
63994: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63998: LD_VAR 0 3
64002: PUSH
64003: LD_EXP 60
64007: PUSH
64008: LD_VAR 0 2
64012: ARRAY
64013: IN
64014: NOT
64015: IFFALSE 64073
// begin SetTag ( j , 101 ) ;
64017: LD_VAR 0 3
64021: PPUSH
64022: LD_INT 101
64024: PPUSH
64025: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64029: LD_ADDR_EXP 60
64033: PUSH
64034: LD_EXP 60
64038: PPUSH
64039: LD_VAR 0 2
64043: PUSH
64044: LD_EXP 60
64048: PUSH
64049: LD_VAR 0 2
64053: ARRAY
64054: PUSH
64055: LD_INT 1
64057: PLUS
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PPUSH
64063: LD_VAR 0 3
64067: PPUSH
64068: CALL 20270 0 3
64072: ST_TO_ADDR
// end ; wait ( 1 ) ;
64073: LD_INT 1
64075: PPUSH
64076: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
64080: LD_VAR 0 3
64084: PPUSH
64085: LD_EXP 59
64089: PUSH
64090: LD_VAR 0 2
64094: ARRAY
64095: PPUSH
64096: LD_VAR 0 3
64100: PPUSH
64101: CALL_OW 74
64105: PPUSH
64106: CALL_OW 130
// end ;
64110: GO 63917
64112: POP
64113: POP
// end ;
64114: GO 63748
64116: POP
64117: POP
// end ;
64118: LD_VAR 0 1
64122: RET
// export function MC_Heal ; var i , j , tmp ; begin
64123: LD_INT 0
64125: PPUSH
64126: PPUSH
64127: PPUSH
64128: PPUSH
// if not mc_bases then
64129: LD_EXP 58
64133: NOT
64134: IFFALSE 64138
// exit ;
64136: GO 64540
// for i = 1 to mc_bases do
64138: LD_ADDR_VAR 0 2
64142: PUSH
64143: DOUBLE
64144: LD_INT 1
64146: DEC
64147: ST_TO_ADDR
64148: LD_EXP 58
64152: PUSH
64153: FOR_TO
64154: IFFALSE 64538
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64156: LD_EXP 61
64160: PUSH
64161: LD_VAR 0 2
64165: ARRAY
64166: PUSH
64167: LD_INT 1
64169: ARRAY
64170: NOT
64171: PUSH
64172: LD_EXP 61
64176: PUSH
64177: LD_VAR 0 2
64181: ARRAY
64182: PUSH
64183: LD_INT 2
64185: ARRAY
64186: NOT
64187: AND
64188: IFFALSE 64226
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64190: LD_ADDR_EXP 62
64194: PUSH
64195: LD_EXP 62
64199: PPUSH
64200: LD_VAR 0 2
64204: PPUSH
64205: EMPTY
64206: PPUSH
64207: CALL_OW 1
64211: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64212: LD_VAR 0 2
64216: PPUSH
64217: LD_INT 102
64219: PPUSH
64220: CALL 59161 0 2
// continue ;
64224: GO 64153
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64226: LD_ADDR_VAR 0 4
64230: PUSH
64231: LD_EXP 58
64235: PUSH
64236: LD_VAR 0 2
64240: ARRAY
64241: PPUSH
64242: LD_INT 25
64244: PUSH
64245: LD_INT 4
64247: PUSH
64248: EMPTY
64249: LIST
64250: LIST
64251: PPUSH
64252: CALL_OW 72
64256: ST_TO_ADDR
// if not tmp then
64257: LD_VAR 0 4
64261: NOT
64262: IFFALSE 64266
// continue ;
64264: GO 64153
// if mc_taming [ i ] then
64266: LD_EXP 89
64270: PUSH
64271: LD_VAR 0 2
64275: ARRAY
64276: IFFALSE 64300
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64278: LD_ADDR_EXP 89
64282: PUSH
64283: LD_EXP 89
64287: PPUSH
64288: LD_VAR 0 2
64292: PPUSH
64293: EMPTY
64294: PPUSH
64295: CALL_OW 1
64299: ST_TO_ADDR
// for j in tmp do
64300: LD_ADDR_VAR 0 3
64304: PUSH
64305: LD_VAR 0 4
64309: PUSH
64310: FOR_IN
64311: IFFALSE 64534
// begin if IsInUnit ( j ) then
64313: LD_VAR 0 3
64317: PPUSH
64318: CALL_OW 310
64322: IFFALSE 64333
// ComExitBuilding ( j ) ;
64324: LD_VAR 0 3
64328: PPUSH
64329: CALL_OW 122
// if not j in mc_healers [ i ] then
64333: LD_VAR 0 3
64337: PUSH
64338: LD_EXP 62
64342: PUSH
64343: LD_VAR 0 2
64347: ARRAY
64348: IN
64349: NOT
64350: IFFALSE 64396
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64352: LD_ADDR_EXP 62
64356: PUSH
64357: LD_EXP 62
64361: PPUSH
64362: LD_VAR 0 2
64366: PUSH
64367: LD_EXP 62
64371: PUSH
64372: LD_VAR 0 2
64376: ARRAY
64377: PUSH
64378: LD_INT 1
64380: PLUS
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PPUSH
64386: LD_VAR 0 3
64390: PPUSH
64391: CALL 20270 0 3
64395: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64396: LD_VAR 0 3
64400: PPUSH
64401: CALL_OW 110
64405: PUSH
64406: LD_INT 102
64408: NONEQUAL
64409: IFFALSE 64423
// SetTag ( j , 102 ) ;
64411: LD_VAR 0 3
64415: PPUSH
64416: LD_INT 102
64418: PPUSH
64419: CALL_OW 109
// Wait ( 3 ) ;
64423: LD_INT 3
64425: PPUSH
64426: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64430: LD_EXP 61
64434: PUSH
64435: LD_VAR 0 2
64439: ARRAY
64440: PUSH
64441: LD_INT 1
64443: ARRAY
64444: IFFALSE 64476
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64446: LD_VAR 0 3
64450: PPUSH
64451: LD_EXP 61
64455: PUSH
64456: LD_VAR 0 2
64460: ARRAY
64461: PUSH
64462: LD_INT 1
64464: ARRAY
64465: PUSH
64466: LD_INT 1
64468: ARRAY
64469: PPUSH
64470: CALL_OW 128
64474: GO 64532
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64476: LD_VAR 0 3
64480: PPUSH
64481: CALL_OW 314
64485: NOT
64486: PUSH
64487: LD_EXP 61
64491: PUSH
64492: LD_VAR 0 2
64496: ARRAY
64497: PUSH
64498: LD_INT 2
64500: ARRAY
64501: AND
64502: IFFALSE 64532
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64504: LD_VAR 0 3
64508: PPUSH
64509: LD_EXP 61
64513: PUSH
64514: LD_VAR 0 2
64518: ARRAY
64519: PUSH
64520: LD_INT 2
64522: ARRAY
64523: PUSH
64524: LD_INT 1
64526: ARRAY
64527: PPUSH
64528: CALL_OW 128
// end ;
64532: GO 64310
64534: POP
64535: POP
// end ;
64536: GO 64153
64538: POP
64539: POP
// end ;
64540: LD_VAR 0 1
64544: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64545: LD_INT 0
64547: PPUSH
64548: PPUSH
64549: PPUSH
64550: PPUSH
64551: PPUSH
// if not mc_bases then
64552: LD_EXP 58
64556: NOT
64557: IFFALSE 64561
// exit ;
64559: GO 65704
// for i = 1 to mc_bases do
64561: LD_ADDR_VAR 0 2
64565: PUSH
64566: DOUBLE
64567: LD_INT 1
64569: DEC
64570: ST_TO_ADDR
64571: LD_EXP 58
64575: PUSH
64576: FOR_TO
64577: IFFALSE 65702
// begin if mc_scan [ i ] then
64579: LD_EXP 81
64583: PUSH
64584: LD_VAR 0 2
64588: ARRAY
64589: IFFALSE 64593
// continue ;
64591: GO 64576
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64593: LD_EXP 63
64597: PUSH
64598: LD_VAR 0 2
64602: ARRAY
64603: NOT
64604: PUSH
64605: LD_EXP 65
64609: PUSH
64610: LD_VAR 0 2
64614: ARRAY
64615: NOT
64616: AND
64617: PUSH
64618: LD_EXP 64
64622: PUSH
64623: LD_VAR 0 2
64627: ARRAY
64628: AND
64629: IFFALSE 64667
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64631: LD_ADDR_EXP 64
64635: PUSH
64636: LD_EXP 64
64640: PPUSH
64641: LD_VAR 0 2
64645: PPUSH
64646: EMPTY
64647: PPUSH
64648: CALL_OW 1
64652: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64653: LD_VAR 0 2
64657: PPUSH
64658: LD_INT 103
64660: PPUSH
64661: CALL 59161 0 2
// continue ;
64665: GO 64576
// end ; if mc_construct_list [ i ] then
64667: LD_EXP 65
64671: PUSH
64672: LD_VAR 0 2
64676: ARRAY
64677: IFFALSE 64897
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64679: LD_ADDR_VAR 0 4
64683: PUSH
64684: LD_EXP 58
64688: PUSH
64689: LD_VAR 0 2
64693: ARRAY
64694: PPUSH
64695: LD_INT 25
64697: PUSH
64698: LD_INT 2
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: PPUSH
64705: CALL_OW 72
64709: PUSH
64710: LD_EXP 60
64714: PUSH
64715: LD_VAR 0 2
64719: ARRAY
64720: DIFF
64721: ST_TO_ADDR
// if not tmp then
64722: LD_VAR 0 4
64726: NOT
64727: IFFALSE 64731
// continue ;
64729: GO 64576
// for j in tmp do
64731: LD_ADDR_VAR 0 3
64735: PUSH
64736: LD_VAR 0 4
64740: PUSH
64741: FOR_IN
64742: IFFALSE 64893
// begin if not mc_builders [ i ] then
64744: LD_EXP 64
64748: PUSH
64749: LD_VAR 0 2
64753: ARRAY
64754: NOT
64755: IFFALSE 64813
// begin SetTag ( j , 103 ) ;
64757: LD_VAR 0 3
64761: PPUSH
64762: LD_INT 103
64764: PPUSH
64765: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64769: LD_ADDR_EXP 64
64773: PUSH
64774: LD_EXP 64
64778: PPUSH
64779: LD_VAR 0 2
64783: PUSH
64784: LD_EXP 64
64788: PUSH
64789: LD_VAR 0 2
64793: ARRAY
64794: PUSH
64795: LD_INT 1
64797: PLUS
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PPUSH
64803: LD_VAR 0 3
64807: PPUSH
64808: CALL 20270 0 3
64812: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64813: LD_VAR 0 3
64817: PPUSH
64818: CALL_OW 310
64822: IFFALSE 64833
// ComExitBuilding ( j ) ;
64824: LD_VAR 0 3
64828: PPUSH
64829: CALL_OW 122
// wait ( 3 ) ;
64833: LD_INT 3
64835: PPUSH
64836: CALL_OW 67
// if not mc_construct_list [ i ] then
64840: LD_EXP 65
64844: PUSH
64845: LD_VAR 0 2
64849: ARRAY
64850: NOT
64851: IFFALSE 64855
// break ;
64853: GO 64893
// if not HasTask ( j ) then
64855: LD_VAR 0 3
64859: PPUSH
64860: CALL_OW 314
64864: NOT
64865: IFFALSE 64891
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64867: LD_VAR 0 3
64871: PPUSH
64872: LD_EXP 65
64876: PUSH
64877: LD_VAR 0 2
64881: ARRAY
64882: PUSH
64883: LD_INT 1
64885: ARRAY
64886: PPUSH
64887: CALL 23121 0 2
// end ;
64891: GO 64741
64893: POP
64894: POP
// end else
64895: GO 65700
// if mc_build_list [ i ] then
64897: LD_EXP 63
64901: PUSH
64902: LD_VAR 0 2
64906: ARRAY
64907: IFFALSE 65700
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64909: LD_ADDR_VAR 0 5
64913: PUSH
64914: LD_EXP 58
64918: PUSH
64919: LD_VAR 0 2
64923: ARRAY
64924: PPUSH
64925: LD_INT 2
64927: PUSH
64928: LD_INT 30
64930: PUSH
64931: LD_INT 0
64933: PUSH
64934: EMPTY
64935: LIST
64936: LIST
64937: PUSH
64938: LD_INT 30
64940: PUSH
64941: LD_INT 1
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: LIST
64952: PPUSH
64953: CALL_OW 72
64957: ST_TO_ADDR
// if depot then
64958: LD_VAR 0 5
64962: IFFALSE 64980
// depot := depot [ 1 ] else
64964: LD_ADDR_VAR 0 5
64968: PUSH
64969: LD_VAR 0 5
64973: PUSH
64974: LD_INT 1
64976: ARRAY
64977: ST_TO_ADDR
64978: GO 64988
// depot := 0 ;
64980: LD_ADDR_VAR 0 5
64984: PUSH
64985: LD_INT 0
64987: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64988: LD_EXP 63
64992: PUSH
64993: LD_VAR 0 2
64997: ARRAY
64998: PUSH
64999: LD_INT 1
65001: ARRAY
65002: PUSH
65003: LD_INT 1
65005: ARRAY
65006: PPUSH
65007: CALL 22951 0 1
65011: PUSH
65012: LD_EXP 58
65016: PUSH
65017: LD_VAR 0 2
65021: ARRAY
65022: PPUSH
65023: LD_INT 2
65025: PUSH
65026: LD_INT 30
65028: PUSH
65029: LD_INT 2
65031: PUSH
65032: EMPTY
65033: LIST
65034: LIST
65035: PUSH
65036: LD_INT 30
65038: PUSH
65039: LD_INT 3
65041: PUSH
65042: EMPTY
65043: LIST
65044: LIST
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: LIST
65050: PPUSH
65051: CALL_OW 72
65055: NOT
65056: AND
65057: IFFALSE 65162
// begin for j = 1 to mc_build_list [ i ] do
65059: LD_ADDR_VAR 0 3
65063: PUSH
65064: DOUBLE
65065: LD_INT 1
65067: DEC
65068: ST_TO_ADDR
65069: LD_EXP 63
65073: PUSH
65074: LD_VAR 0 2
65078: ARRAY
65079: PUSH
65080: FOR_TO
65081: IFFALSE 65160
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65083: LD_EXP 63
65087: PUSH
65088: LD_VAR 0 2
65092: ARRAY
65093: PUSH
65094: LD_VAR 0 3
65098: ARRAY
65099: PUSH
65100: LD_INT 1
65102: ARRAY
65103: PUSH
65104: LD_INT 2
65106: EQUAL
65107: IFFALSE 65158
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65109: LD_ADDR_EXP 63
65113: PUSH
65114: LD_EXP 63
65118: PPUSH
65119: LD_VAR 0 2
65123: PPUSH
65124: LD_EXP 63
65128: PUSH
65129: LD_VAR 0 2
65133: ARRAY
65134: PPUSH
65135: LD_VAR 0 3
65139: PPUSH
65140: LD_INT 1
65142: PPUSH
65143: LD_INT 0
65145: PPUSH
65146: CALL 19688 0 4
65150: PPUSH
65151: CALL_OW 1
65155: ST_TO_ADDR
// break ;
65156: GO 65160
// end ;
65158: GO 65080
65160: POP
65161: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65162: LD_EXP 63
65166: PUSH
65167: LD_VAR 0 2
65171: ARRAY
65172: PUSH
65173: LD_INT 1
65175: ARRAY
65176: PUSH
65177: LD_INT 1
65179: ARRAY
65180: PUSH
65181: LD_INT 0
65183: EQUAL
65184: PUSH
65185: LD_VAR 0 5
65189: PUSH
65190: LD_VAR 0 5
65194: PPUSH
65195: LD_EXP 63
65199: PUSH
65200: LD_VAR 0 2
65204: ARRAY
65205: PUSH
65206: LD_INT 1
65208: ARRAY
65209: PUSH
65210: LD_INT 1
65212: ARRAY
65213: PPUSH
65214: LD_EXP 63
65218: PUSH
65219: LD_VAR 0 2
65223: ARRAY
65224: PUSH
65225: LD_INT 1
65227: ARRAY
65228: PUSH
65229: LD_INT 2
65231: ARRAY
65232: PPUSH
65233: LD_EXP 63
65237: PUSH
65238: LD_VAR 0 2
65242: ARRAY
65243: PUSH
65244: LD_INT 1
65246: ARRAY
65247: PUSH
65248: LD_INT 3
65250: ARRAY
65251: PPUSH
65252: LD_EXP 63
65256: PUSH
65257: LD_VAR 0 2
65261: ARRAY
65262: PUSH
65263: LD_INT 1
65265: ARRAY
65266: PUSH
65267: LD_INT 4
65269: ARRAY
65270: PPUSH
65271: CALL 27667 0 5
65275: AND
65276: OR
65277: IFFALSE 65558
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65279: LD_ADDR_VAR 0 4
65283: PUSH
65284: LD_EXP 58
65288: PUSH
65289: LD_VAR 0 2
65293: ARRAY
65294: PPUSH
65295: LD_INT 25
65297: PUSH
65298: LD_INT 2
65300: PUSH
65301: EMPTY
65302: LIST
65303: LIST
65304: PPUSH
65305: CALL_OW 72
65309: PUSH
65310: LD_EXP 60
65314: PUSH
65315: LD_VAR 0 2
65319: ARRAY
65320: DIFF
65321: ST_TO_ADDR
// if not tmp then
65322: LD_VAR 0 4
65326: NOT
65327: IFFALSE 65331
// continue ;
65329: GO 64576
// for j in tmp do
65331: LD_ADDR_VAR 0 3
65335: PUSH
65336: LD_VAR 0 4
65340: PUSH
65341: FOR_IN
65342: IFFALSE 65554
// begin if not mc_builders [ i ] then
65344: LD_EXP 64
65348: PUSH
65349: LD_VAR 0 2
65353: ARRAY
65354: NOT
65355: IFFALSE 65413
// begin SetTag ( j , 103 ) ;
65357: LD_VAR 0 3
65361: PPUSH
65362: LD_INT 103
65364: PPUSH
65365: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65369: LD_ADDR_EXP 64
65373: PUSH
65374: LD_EXP 64
65378: PPUSH
65379: LD_VAR 0 2
65383: PUSH
65384: LD_EXP 64
65388: PUSH
65389: LD_VAR 0 2
65393: ARRAY
65394: PUSH
65395: LD_INT 1
65397: PLUS
65398: PUSH
65399: EMPTY
65400: LIST
65401: LIST
65402: PPUSH
65403: LD_VAR 0 3
65407: PPUSH
65408: CALL 20270 0 3
65412: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65413: LD_VAR 0 3
65417: PPUSH
65418: CALL_OW 310
65422: IFFALSE 65433
// ComExitBuilding ( j ) ;
65424: LD_VAR 0 3
65428: PPUSH
65429: CALL_OW 122
// wait ( 3 ) ;
65433: LD_INT 3
65435: PPUSH
65436: CALL_OW 67
// if not mc_build_list [ i ] then
65440: LD_EXP 63
65444: PUSH
65445: LD_VAR 0 2
65449: ARRAY
65450: NOT
65451: IFFALSE 65455
// break ;
65453: GO 65554
// if not HasTask ( j ) then
65455: LD_VAR 0 3
65459: PPUSH
65460: CALL_OW 314
65464: NOT
65465: IFFALSE 65552
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65467: LD_VAR 0 3
65471: PPUSH
65472: LD_EXP 63
65476: PUSH
65477: LD_VAR 0 2
65481: ARRAY
65482: PUSH
65483: LD_INT 1
65485: ARRAY
65486: PUSH
65487: LD_INT 1
65489: ARRAY
65490: PPUSH
65491: LD_EXP 63
65495: PUSH
65496: LD_VAR 0 2
65500: ARRAY
65501: PUSH
65502: LD_INT 1
65504: ARRAY
65505: PUSH
65506: LD_INT 2
65508: ARRAY
65509: PPUSH
65510: LD_EXP 63
65514: PUSH
65515: LD_VAR 0 2
65519: ARRAY
65520: PUSH
65521: LD_INT 1
65523: ARRAY
65524: PUSH
65525: LD_INT 3
65527: ARRAY
65528: PPUSH
65529: LD_EXP 63
65533: PUSH
65534: LD_VAR 0 2
65538: ARRAY
65539: PUSH
65540: LD_INT 1
65542: ARRAY
65543: PUSH
65544: LD_INT 4
65546: ARRAY
65547: PPUSH
65548: CALL_OW 145
// end ;
65552: GO 65341
65554: POP
65555: POP
// end else
65556: GO 65700
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65558: LD_EXP 58
65562: PUSH
65563: LD_VAR 0 2
65567: ARRAY
65568: PPUSH
65569: LD_EXP 63
65573: PUSH
65574: LD_VAR 0 2
65578: ARRAY
65579: PUSH
65580: LD_INT 1
65582: ARRAY
65583: PUSH
65584: LD_INT 1
65586: ARRAY
65587: PPUSH
65588: LD_EXP 63
65592: PUSH
65593: LD_VAR 0 2
65597: ARRAY
65598: PUSH
65599: LD_INT 1
65601: ARRAY
65602: PUSH
65603: LD_INT 2
65605: ARRAY
65606: PPUSH
65607: LD_EXP 63
65611: PUSH
65612: LD_VAR 0 2
65616: ARRAY
65617: PUSH
65618: LD_INT 1
65620: ARRAY
65621: PUSH
65622: LD_INT 3
65624: ARRAY
65625: PPUSH
65626: LD_EXP 63
65630: PUSH
65631: LD_VAR 0 2
65635: ARRAY
65636: PUSH
65637: LD_INT 1
65639: ARRAY
65640: PUSH
65641: LD_INT 4
65643: ARRAY
65644: PPUSH
65645: CALL 27021 0 5
65649: NOT
65650: IFFALSE 65700
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65652: LD_ADDR_EXP 63
65656: PUSH
65657: LD_EXP 63
65661: PPUSH
65662: LD_VAR 0 2
65666: PPUSH
65667: LD_EXP 63
65671: PUSH
65672: LD_VAR 0 2
65676: ARRAY
65677: PPUSH
65678: LD_INT 1
65680: PPUSH
65681: LD_INT 1
65683: NEG
65684: PPUSH
65685: LD_INT 0
65687: PPUSH
65688: CALL 19688 0 4
65692: PPUSH
65693: CALL_OW 1
65697: ST_TO_ADDR
// continue ;
65698: GO 64576
// end ; end ; end ;
65700: GO 64576
65702: POP
65703: POP
// end ;
65704: LD_VAR 0 1
65708: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65709: LD_INT 0
65711: PPUSH
65712: PPUSH
65713: PPUSH
65714: PPUSH
65715: PPUSH
65716: PPUSH
// if not mc_bases then
65717: LD_EXP 58
65721: NOT
65722: IFFALSE 65726
// exit ;
65724: GO 66153
// for i = 1 to mc_bases do
65726: LD_ADDR_VAR 0 2
65730: PUSH
65731: DOUBLE
65732: LD_INT 1
65734: DEC
65735: ST_TO_ADDR
65736: LD_EXP 58
65740: PUSH
65741: FOR_TO
65742: IFFALSE 66151
// begin tmp := mc_build_upgrade [ i ] ;
65744: LD_ADDR_VAR 0 4
65748: PUSH
65749: LD_EXP 90
65753: PUSH
65754: LD_VAR 0 2
65758: ARRAY
65759: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65760: LD_ADDR_VAR 0 6
65764: PUSH
65765: LD_EXP 91
65769: PUSH
65770: LD_VAR 0 2
65774: ARRAY
65775: PPUSH
65776: LD_INT 2
65778: PUSH
65779: LD_INT 30
65781: PUSH
65782: LD_INT 6
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: PUSH
65789: LD_INT 30
65791: PUSH
65792: LD_INT 7
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: LIST
65803: PPUSH
65804: CALL_OW 72
65808: ST_TO_ADDR
// if not tmp and not lab then
65809: LD_VAR 0 4
65813: NOT
65814: PUSH
65815: LD_VAR 0 6
65819: NOT
65820: AND
65821: IFFALSE 65825
// continue ;
65823: GO 65741
// if tmp then
65825: LD_VAR 0 4
65829: IFFALSE 65949
// for j in tmp do
65831: LD_ADDR_VAR 0 3
65835: PUSH
65836: LD_VAR 0 4
65840: PUSH
65841: FOR_IN
65842: IFFALSE 65947
// begin if UpgradeCost ( j ) then
65844: LD_VAR 0 3
65848: PPUSH
65849: CALL 26681 0 1
65853: IFFALSE 65945
// begin ComUpgrade ( j ) ;
65855: LD_VAR 0 3
65859: PPUSH
65860: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65864: LD_ADDR_EXP 90
65868: PUSH
65869: LD_EXP 90
65873: PPUSH
65874: LD_VAR 0 2
65878: PPUSH
65879: LD_EXP 90
65883: PUSH
65884: LD_VAR 0 2
65888: ARRAY
65889: PUSH
65890: LD_VAR 0 3
65894: DIFF
65895: PPUSH
65896: CALL_OW 1
65900: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65901: LD_ADDR_EXP 65
65905: PUSH
65906: LD_EXP 65
65910: PPUSH
65911: LD_VAR 0 2
65915: PUSH
65916: LD_EXP 65
65920: PUSH
65921: LD_VAR 0 2
65925: ARRAY
65926: PUSH
65927: LD_INT 1
65929: PLUS
65930: PUSH
65931: EMPTY
65932: LIST
65933: LIST
65934: PPUSH
65935: LD_VAR 0 3
65939: PPUSH
65940: CALL 20270 0 3
65944: ST_TO_ADDR
// end ; end ;
65945: GO 65841
65947: POP
65948: POP
// if not lab or not mc_lab_upgrade [ i ] then
65949: LD_VAR 0 6
65953: NOT
65954: PUSH
65955: LD_EXP 92
65959: PUSH
65960: LD_VAR 0 2
65964: ARRAY
65965: NOT
65966: OR
65967: IFFALSE 65971
// continue ;
65969: GO 65741
// for j in lab do
65971: LD_ADDR_VAR 0 3
65975: PUSH
65976: LD_VAR 0 6
65980: PUSH
65981: FOR_IN
65982: IFFALSE 66147
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65984: LD_VAR 0 3
65988: PPUSH
65989: CALL_OW 266
65993: PUSH
65994: LD_INT 6
65996: PUSH
65997: LD_INT 7
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: IN
66004: PUSH
66005: LD_VAR 0 3
66009: PPUSH
66010: CALL_OW 461
66014: PUSH
66015: LD_INT 1
66017: NONEQUAL
66018: AND
66019: IFFALSE 66145
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66021: LD_VAR 0 3
66025: PPUSH
66026: LD_EXP 92
66030: PUSH
66031: LD_VAR 0 2
66035: ARRAY
66036: PUSH
66037: LD_INT 1
66039: ARRAY
66040: PPUSH
66041: CALL 26886 0 2
66045: IFFALSE 66145
// begin ComCancel ( j ) ;
66047: LD_VAR 0 3
66051: PPUSH
66052: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66056: LD_VAR 0 3
66060: PPUSH
66061: LD_EXP 92
66065: PUSH
66066: LD_VAR 0 2
66070: ARRAY
66071: PUSH
66072: LD_INT 1
66074: ARRAY
66075: PPUSH
66076: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66080: LD_VAR 0 3
66084: PUSH
66085: LD_EXP 65
66089: PUSH
66090: LD_VAR 0 2
66094: ARRAY
66095: IN
66096: NOT
66097: IFFALSE 66143
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66099: LD_ADDR_EXP 65
66103: PUSH
66104: LD_EXP 65
66108: PPUSH
66109: LD_VAR 0 2
66113: PUSH
66114: LD_EXP 65
66118: PUSH
66119: LD_VAR 0 2
66123: ARRAY
66124: PUSH
66125: LD_INT 1
66127: PLUS
66128: PUSH
66129: EMPTY
66130: LIST
66131: LIST
66132: PPUSH
66133: LD_VAR 0 3
66137: PPUSH
66138: CALL 20270 0 3
66142: ST_TO_ADDR
// break ;
66143: GO 66147
// end ; end ; end ;
66145: GO 65981
66147: POP
66148: POP
// end ;
66149: GO 65741
66151: POP
66152: POP
// end ;
66153: LD_VAR 0 1
66157: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66158: LD_INT 0
66160: PPUSH
66161: PPUSH
66162: PPUSH
66163: PPUSH
66164: PPUSH
66165: PPUSH
66166: PPUSH
66167: PPUSH
66168: PPUSH
// if not mc_bases then
66169: LD_EXP 58
66173: NOT
66174: IFFALSE 66178
// exit ;
66176: GO 66583
// for i = 1 to mc_bases do
66178: LD_ADDR_VAR 0 2
66182: PUSH
66183: DOUBLE
66184: LD_INT 1
66186: DEC
66187: ST_TO_ADDR
66188: LD_EXP 58
66192: PUSH
66193: FOR_TO
66194: IFFALSE 66581
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66196: LD_EXP 66
66200: PUSH
66201: LD_VAR 0 2
66205: ARRAY
66206: NOT
66207: PUSH
66208: LD_EXP 58
66212: PUSH
66213: LD_VAR 0 2
66217: ARRAY
66218: PPUSH
66219: LD_INT 30
66221: PUSH
66222: LD_INT 3
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PPUSH
66229: CALL_OW 72
66233: NOT
66234: OR
66235: IFFALSE 66239
// continue ;
66237: GO 66193
// busy := false ;
66239: LD_ADDR_VAR 0 8
66243: PUSH
66244: LD_INT 0
66246: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66247: LD_ADDR_VAR 0 4
66251: PUSH
66252: LD_EXP 58
66256: PUSH
66257: LD_VAR 0 2
66261: ARRAY
66262: PPUSH
66263: LD_INT 30
66265: PUSH
66266: LD_INT 3
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PPUSH
66273: CALL_OW 72
66277: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66278: LD_ADDR_VAR 0 6
66282: PUSH
66283: LD_EXP 66
66287: PUSH
66288: LD_VAR 0 2
66292: ARRAY
66293: PPUSH
66294: LD_INT 2
66296: PUSH
66297: LD_INT 30
66299: PUSH
66300: LD_INT 32
66302: PUSH
66303: EMPTY
66304: LIST
66305: LIST
66306: PUSH
66307: LD_INT 30
66309: PUSH
66310: LD_INT 33
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: LIST
66321: PPUSH
66322: CALL_OW 72
66326: ST_TO_ADDR
// if not t then
66327: LD_VAR 0 6
66331: NOT
66332: IFFALSE 66336
// continue ;
66334: GO 66193
// for j in tmp do
66336: LD_ADDR_VAR 0 3
66340: PUSH
66341: LD_VAR 0 4
66345: PUSH
66346: FOR_IN
66347: IFFALSE 66377
// if not BuildingStatus ( j ) = bs_idle then
66349: LD_VAR 0 3
66353: PPUSH
66354: CALL_OW 461
66358: PUSH
66359: LD_INT 2
66361: EQUAL
66362: NOT
66363: IFFALSE 66375
// begin busy := true ;
66365: LD_ADDR_VAR 0 8
66369: PUSH
66370: LD_INT 1
66372: ST_TO_ADDR
// break ;
66373: GO 66377
// end ;
66375: GO 66346
66377: POP
66378: POP
// if busy then
66379: LD_VAR 0 8
66383: IFFALSE 66387
// continue ;
66385: GO 66193
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66387: LD_ADDR_VAR 0 7
66391: PUSH
66392: LD_VAR 0 6
66396: PPUSH
66397: LD_INT 35
66399: PUSH
66400: LD_INT 0
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PPUSH
66407: CALL_OW 72
66411: ST_TO_ADDR
// if tw then
66412: LD_VAR 0 7
66416: IFFALSE 66493
// begin tw := tw [ 1 ] ;
66418: LD_ADDR_VAR 0 7
66422: PUSH
66423: LD_VAR 0 7
66427: PUSH
66428: LD_INT 1
66430: ARRAY
66431: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66432: LD_ADDR_VAR 0 9
66436: PUSH
66437: LD_VAR 0 7
66441: PPUSH
66442: LD_EXP 83
66446: PUSH
66447: LD_VAR 0 2
66451: ARRAY
66452: PPUSH
66453: CALL 25240 0 2
66457: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66458: LD_EXP 97
66462: PUSH
66463: LD_VAR 0 2
66467: ARRAY
66468: IFFALSE 66491
// if not weapon in mc_allowed_tower_weapons [ i ] then
66470: LD_VAR 0 9
66474: PUSH
66475: LD_EXP 97
66479: PUSH
66480: LD_VAR 0 2
66484: ARRAY
66485: IN
66486: NOT
66487: IFFALSE 66491
// continue ;
66489: GO 66193
// end else
66491: GO 66556
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66493: LD_ADDR_VAR 0 5
66497: PUSH
66498: LD_EXP 66
66502: PUSH
66503: LD_VAR 0 2
66507: ARRAY
66508: PPUSH
66509: LD_VAR 0 4
66513: PPUSH
66514: CALL 55379 0 2
66518: ST_TO_ADDR
// if not tmp2 then
66519: LD_VAR 0 5
66523: NOT
66524: IFFALSE 66528
// continue ;
66526: GO 66193
// tw := tmp2 [ 1 ] ;
66528: LD_ADDR_VAR 0 7
66532: PUSH
66533: LD_VAR 0 5
66537: PUSH
66538: LD_INT 1
66540: ARRAY
66541: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66542: LD_ADDR_VAR 0 9
66546: PUSH
66547: LD_VAR 0 5
66551: PUSH
66552: LD_INT 2
66554: ARRAY
66555: ST_TO_ADDR
// end ; if not weapon then
66556: LD_VAR 0 9
66560: NOT
66561: IFFALSE 66565
// continue ;
66563: GO 66193
// ComPlaceWeapon ( tw , weapon ) ;
66565: LD_VAR 0 7
66569: PPUSH
66570: LD_VAR 0 9
66574: PPUSH
66575: CALL_OW 148
// end ;
66579: GO 66193
66581: POP
66582: POP
// end ;
66583: LD_VAR 0 1
66587: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
66588: LD_INT 0
66590: PPUSH
66591: PPUSH
66592: PPUSH
66593: PPUSH
66594: PPUSH
66595: PPUSH
// if not mc_bases then
66596: LD_EXP 58
66600: NOT
66601: IFFALSE 66605
// exit ;
66603: GO 67617
// for i = 1 to mc_bases do
66605: LD_ADDR_VAR 0 2
66609: PUSH
66610: DOUBLE
66611: LD_INT 1
66613: DEC
66614: ST_TO_ADDR
66615: LD_EXP 58
66619: PUSH
66620: FOR_TO
66621: IFFALSE 67615
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
66623: LD_EXP 71
66627: PUSH
66628: LD_VAR 0 2
66632: ARRAY
66633: NOT
66634: PUSH
66635: LD_EXP 71
66639: PUSH
66640: LD_VAR 0 2
66644: ARRAY
66645: PUSH
66646: LD_EXP 72
66650: PUSH
66651: LD_VAR 0 2
66655: ARRAY
66656: EQUAL
66657: OR
66658: IFFALSE 66662
// continue ;
66660: GO 66620
// if mc_miners [ i ] then
66662: LD_EXP 72
66666: PUSH
66667: LD_VAR 0 2
66671: ARRAY
66672: IFFALSE 67302
// begin k := 1 ;
66674: LD_ADDR_VAR 0 4
66678: PUSH
66679: LD_INT 1
66681: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
66682: LD_ADDR_VAR 0 3
66686: PUSH
66687: DOUBLE
66688: LD_EXP 72
66692: PUSH
66693: LD_VAR 0 2
66697: ARRAY
66698: INC
66699: ST_TO_ADDR
66700: LD_INT 1
66702: PUSH
66703: FOR_DOWNTO
66704: IFFALSE 67300
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66706: LD_EXP 72
66710: PUSH
66711: LD_VAR 0 2
66715: ARRAY
66716: PUSH
66717: LD_VAR 0 3
66721: ARRAY
66722: PPUSH
66723: CALL_OW 301
66727: PUSH
66728: LD_EXP 72
66732: PUSH
66733: LD_VAR 0 2
66737: ARRAY
66738: PUSH
66739: LD_VAR 0 3
66743: ARRAY
66744: PPUSH
66745: CALL_OW 257
66749: PUSH
66750: LD_INT 1
66752: NONEQUAL
66753: OR
66754: IFFALSE 66817
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66756: LD_ADDR_VAR 0 5
66760: PUSH
66761: LD_EXP 72
66765: PUSH
66766: LD_VAR 0 2
66770: ARRAY
66771: PUSH
66772: LD_EXP 72
66776: PUSH
66777: LD_VAR 0 2
66781: ARRAY
66782: PUSH
66783: LD_VAR 0 3
66787: ARRAY
66788: DIFF
66789: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66790: LD_ADDR_EXP 72
66794: PUSH
66795: LD_EXP 72
66799: PPUSH
66800: LD_VAR 0 2
66804: PPUSH
66805: LD_VAR 0 5
66809: PPUSH
66810: CALL_OW 1
66814: ST_TO_ADDR
// continue ;
66815: GO 66703
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
66817: LD_EXP 72
66821: PUSH
66822: LD_VAR 0 2
66826: ARRAY
66827: PUSH
66828: LD_VAR 0 3
66832: ARRAY
66833: PPUSH
66834: CALL 20206 0 1
66838: PUSH
66839: LD_EXP 72
66843: PUSH
66844: LD_VAR 0 2
66848: ARRAY
66849: PUSH
66850: LD_VAR 0 3
66854: ARRAY
66855: PPUSH
66856: CALL_OW 255
66860: PPUSH
66861: LD_EXP 71
66865: PUSH
66866: LD_VAR 0 2
66870: ARRAY
66871: PUSH
66872: LD_VAR 0 4
66876: ARRAY
66877: PUSH
66878: LD_INT 1
66880: ARRAY
66881: PPUSH
66882: LD_EXP 71
66886: PUSH
66887: LD_VAR 0 2
66891: ARRAY
66892: PUSH
66893: LD_VAR 0 4
66897: ARRAY
66898: PUSH
66899: LD_INT 2
66901: ARRAY
66902: PPUSH
66903: LD_INT 15
66905: PPUSH
66906: CALL 21166 0 4
66910: PUSH
66911: LD_INT 4
66913: ARRAY
66914: PUSH
66915: LD_EXP 72
66919: PUSH
66920: LD_VAR 0 2
66924: ARRAY
66925: PUSH
66926: LD_VAR 0 3
66930: ARRAY
66931: PPUSH
66932: LD_INT 10
66934: PPUSH
66935: CALL 22863 0 2
66939: PUSH
66940: LD_INT 4
66942: ARRAY
66943: OR
66944: AND
66945: IFFALSE 66968
// ComStop ( mc_miners [ i ] [ j ] ) ;
66947: LD_EXP 72
66951: PUSH
66952: LD_VAR 0 2
66956: ARRAY
66957: PUSH
66958: LD_VAR 0 3
66962: ARRAY
66963: PPUSH
66964: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
66968: LD_EXP 72
66972: PUSH
66973: LD_VAR 0 2
66977: ARRAY
66978: PUSH
66979: LD_VAR 0 3
66983: ARRAY
66984: PPUSH
66985: CALL_OW 257
66989: PUSH
66990: LD_INT 1
66992: EQUAL
66993: PUSH
66994: LD_EXP 72
66998: PUSH
66999: LD_VAR 0 2
67003: ARRAY
67004: PUSH
67005: LD_VAR 0 3
67009: ARRAY
67010: PPUSH
67011: CALL_OW 459
67015: NOT
67016: AND
67017: PUSH
67018: LD_EXP 72
67022: PUSH
67023: LD_VAR 0 2
67027: ARRAY
67028: PUSH
67029: LD_VAR 0 3
67033: ARRAY
67034: PPUSH
67035: CALL_OW 255
67039: PPUSH
67040: LD_EXP 71
67044: PUSH
67045: LD_VAR 0 2
67049: ARRAY
67050: PUSH
67051: LD_VAR 0 4
67055: ARRAY
67056: PUSH
67057: LD_INT 1
67059: ARRAY
67060: PPUSH
67061: LD_EXP 71
67065: PUSH
67066: LD_VAR 0 2
67070: ARRAY
67071: PUSH
67072: LD_VAR 0 4
67076: ARRAY
67077: PUSH
67078: LD_INT 2
67080: ARRAY
67081: PPUSH
67082: LD_INT 15
67084: PPUSH
67085: CALL 21166 0 4
67089: PUSH
67090: LD_INT 4
67092: ARRAY
67093: PUSH
67094: LD_INT 0
67096: EQUAL
67097: AND
67098: PUSH
67099: LD_EXP 72
67103: PUSH
67104: LD_VAR 0 2
67108: ARRAY
67109: PUSH
67110: LD_VAR 0 3
67114: ARRAY
67115: PPUSH
67116: CALL_OW 314
67120: NOT
67121: AND
67122: IFFALSE 67298
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67124: LD_EXP 72
67128: PUSH
67129: LD_VAR 0 2
67133: ARRAY
67134: PUSH
67135: LD_VAR 0 3
67139: ARRAY
67140: PPUSH
67141: CALL_OW 310
67145: IFFALSE 67168
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67147: LD_EXP 72
67151: PUSH
67152: LD_VAR 0 2
67156: ARRAY
67157: PUSH
67158: LD_VAR 0 3
67162: ARRAY
67163: PPUSH
67164: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67168: LD_EXP 72
67172: PUSH
67173: LD_VAR 0 2
67177: ARRAY
67178: PUSH
67179: LD_VAR 0 3
67183: ARRAY
67184: PPUSH
67185: CALL_OW 314
67189: NOT
67190: IFFALSE 67258
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
67192: LD_EXP 72
67196: PUSH
67197: LD_VAR 0 2
67201: ARRAY
67202: PUSH
67203: LD_VAR 0 3
67207: ARRAY
67208: PPUSH
67209: LD_EXP 71
67213: PUSH
67214: LD_VAR 0 2
67218: ARRAY
67219: PUSH
67220: LD_VAR 0 4
67224: ARRAY
67225: PUSH
67226: LD_INT 1
67228: ARRAY
67229: PPUSH
67230: LD_EXP 71
67234: PUSH
67235: LD_VAR 0 2
67239: ARRAY
67240: PUSH
67241: LD_VAR 0 4
67245: ARRAY
67246: PUSH
67247: LD_INT 2
67249: ARRAY
67250: PPUSH
67251: LD_INT 0
67253: PPUSH
67254: CALL_OW 193
// k := k + 1 ;
67258: LD_ADDR_VAR 0 4
67262: PUSH
67263: LD_VAR 0 4
67267: PUSH
67268: LD_INT 1
67270: PLUS
67271: ST_TO_ADDR
// if k > mc_mines [ i ] then
67272: LD_VAR 0 4
67276: PUSH
67277: LD_EXP 71
67281: PUSH
67282: LD_VAR 0 2
67286: ARRAY
67287: GREATER
67288: IFFALSE 67298
// k := 1 ;
67290: LD_ADDR_VAR 0 4
67294: PUSH
67295: LD_INT 1
67297: ST_TO_ADDR
// end ; end ;
67298: GO 66703
67300: POP
67301: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67302: LD_ADDR_VAR 0 5
67306: PUSH
67307: LD_EXP 58
67311: PUSH
67312: LD_VAR 0 2
67316: ARRAY
67317: PPUSH
67318: LD_INT 2
67320: PUSH
67321: LD_INT 30
67323: PUSH
67324: LD_INT 4
67326: PUSH
67327: EMPTY
67328: LIST
67329: LIST
67330: PUSH
67331: LD_INT 30
67333: PUSH
67334: LD_INT 5
67336: PUSH
67337: EMPTY
67338: LIST
67339: LIST
67340: PUSH
67341: LD_INT 30
67343: PUSH
67344: LD_INT 32
67346: PUSH
67347: EMPTY
67348: LIST
67349: LIST
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: LIST
67355: LIST
67356: PPUSH
67357: CALL_OW 72
67361: ST_TO_ADDR
// if not tmp then
67362: LD_VAR 0 5
67366: NOT
67367: IFFALSE 67371
// continue ;
67369: GO 66620
// list := [ ] ;
67371: LD_ADDR_VAR 0 6
67375: PUSH
67376: EMPTY
67377: ST_TO_ADDR
// for j in tmp do
67378: LD_ADDR_VAR 0 3
67382: PUSH
67383: LD_VAR 0 5
67387: PUSH
67388: FOR_IN
67389: IFFALSE 67458
// begin for k in UnitsInside ( j ) do
67391: LD_ADDR_VAR 0 4
67395: PUSH
67396: LD_VAR 0 3
67400: PPUSH
67401: CALL_OW 313
67405: PUSH
67406: FOR_IN
67407: IFFALSE 67454
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67409: LD_VAR 0 4
67413: PPUSH
67414: CALL_OW 257
67418: PUSH
67419: LD_INT 1
67421: EQUAL
67422: PUSH
67423: LD_VAR 0 4
67427: PPUSH
67428: CALL_OW 459
67432: NOT
67433: AND
67434: IFFALSE 67452
// list := list ^ k ;
67436: LD_ADDR_VAR 0 6
67440: PUSH
67441: LD_VAR 0 6
67445: PUSH
67446: LD_VAR 0 4
67450: ADD
67451: ST_TO_ADDR
67452: GO 67406
67454: POP
67455: POP
// end ;
67456: GO 67388
67458: POP
67459: POP
// list := list diff mc_miners [ i ] ;
67460: LD_ADDR_VAR 0 6
67464: PUSH
67465: LD_VAR 0 6
67469: PUSH
67470: LD_EXP 72
67474: PUSH
67475: LD_VAR 0 2
67479: ARRAY
67480: DIFF
67481: ST_TO_ADDR
// if not list then
67482: LD_VAR 0 6
67486: NOT
67487: IFFALSE 67491
// continue ;
67489: GO 66620
// k := mc_mines [ i ] - mc_miners [ i ] ;
67491: LD_ADDR_VAR 0 4
67495: PUSH
67496: LD_EXP 71
67500: PUSH
67501: LD_VAR 0 2
67505: ARRAY
67506: PUSH
67507: LD_EXP 72
67511: PUSH
67512: LD_VAR 0 2
67516: ARRAY
67517: MINUS
67518: ST_TO_ADDR
// if k > list then
67519: LD_VAR 0 4
67523: PUSH
67524: LD_VAR 0 6
67528: GREATER
67529: IFFALSE 67541
// k := list ;
67531: LD_ADDR_VAR 0 4
67535: PUSH
67536: LD_VAR 0 6
67540: ST_TO_ADDR
// for j = 1 to k do
67541: LD_ADDR_VAR 0 3
67545: PUSH
67546: DOUBLE
67547: LD_INT 1
67549: DEC
67550: ST_TO_ADDR
67551: LD_VAR 0 4
67555: PUSH
67556: FOR_TO
67557: IFFALSE 67611
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67559: LD_ADDR_EXP 72
67563: PUSH
67564: LD_EXP 72
67568: PPUSH
67569: LD_VAR 0 2
67573: PUSH
67574: LD_EXP 72
67578: PUSH
67579: LD_VAR 0 2
67583: ARRAY
67584: PUSH
67585: LD_INT 1
67587: PLUS
67588: PUSH
67589: EMPTY
67590: LIST
67591: LIST
67592: PPUSH
67593: LD_VAR 0 6
67597: PUSH
67598: LD_VAR 0 3
67602: ARRAY
67603: PPUSH
67604: CALL 20270 0 3
67608: ST_TO_ADDR
67609: GO 67556
67611: POP
67612: POP
// end ;
67613: GO 66620
67615: POP
67616: POP
// end ;
67617: LD_VAR 0 1
67621: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67622: LD_INT 0
67624: PPUSH
67625: PPUSH
67626: PPUSH
67627: PPUSH
67628: PPUSH
67629: PPUSH
67630: PPUSH
67631: PPUSH
67632: PPUSH
67633: PPUSH
// if not mc_bases then
67634: LD_EXP 58
67638: NOT
67639: IFFALSE 67643
// exit ;
67641: GO 69374
// for i = 1 to mc_bases do
67643: LD_ADDR_VAR 0 2
67647: PUSH
67648: DOUBLE
67649: LD_INT 1
67651: DEC
67652: ST_TO_ADDR
67653: LD_EXP 58
67657: PUSH
67658: FOR_TO
67659: IFFALSE 69372
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67661: LD_EXP 58
67665: PUSH
67666: LD_VAR 0 2
67670: ARRAY
67671: NOT
67672: PUSH
67673: LD_EXP 65
67677: PUSH
67678: LD_VAR 0 2
67682: ARRAY
67683: OR
67684: IFFALSE 67688
// continue ;
67686: GO 67658
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67688: LD_EXP 74
67692: PUSH
67693: LD_VAR 0 2
67697: ARRAY
67698: NOT
67699: PUSH
67700: LD_EXP 75
67704: PUSH
67705: LD_VAR 0 2
67709: ARRAY
67710: AND
67711: IFFALSE 67749
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67713: LD_ADDR_EXP 75
67717: PUSH
67718: LD_EXP 75
67722: PPUSH
67723: LD_VAR 0 2
67727: PPUSH
67728: EMPTY
67729: PPUSH
67730: CALL_OW 1
67734: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67735: LD_VAR 0 2
67739: PPUSH
67740: LD_INT 107
67742: PPUSH
67743: CALL 59161 0 2
// continue ;
67747: GO 67658
// end ; target := [ ] ;
67749: LD_ADDR_VAR 0 6
67753: PUSH
67754: EMPTY
67755: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67756: LD_ADDR_VAR 0 3
67760: PUSH
67761: DOUBLE
67762: LD_EXP 74
67766: PUSH
67767: LD_VAR 0 2
67771: ARRAY
67772: INC
67773: ST_TO_ADDR
67774: LD_INT 1
67776: PUSH
67777: FOR_DOWNTO
67778: IFFALSE 68038
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67780: LD_EXP 74
67784: PUSH
67785: LD_VAR 0 2
67789: ARRAY
67790: PUSH
67791: LD_VAR 0 3
67795: ARRAY
67796: PUSH
67797: LD_INT 2
67799: ARRAY
67800: PPUSH
67801: LD_EXP 74
67805: PUSH
67806: LD_VAR 0 2
67810: ARRAY
67811: PUSH
67812: LD_VAR 0 3
67816: ARRAY
67817: PUSH
67818: LD_INT 3
67820: ARRAY
67821: PPUSH
67822: CALL_OW 488
67826: PUSH
67827: LD_EXP 74
67831: PUSH
67832: LD_VAR 0 2
67836: ARRAY
67837: PUSH
67838: LD_VAR 0 3
67842: ARRAY
67843: PUSH
67844: LD_INT 2
67846: ARRAY
67847: PPUSH
67848: LD_EXP 74
67852: PUSH
67853: LD_VAR 0 2
67857: ARRAY
67858: PUSH
67859: LD_VAR 0 3
67863: ARRAY
67864: PUSH
67865: LD_INT 3
67867: ARRAY
67868: PPUSH
67869: CALL_OW 284
67873: PUSH
67874: LD_INT 0
67876: EQUAL
67877: AND
67878: IFFALSE 67933
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67880: LD_ADDR_VAR 0 5
67884: PUSH
67885: LD_EXP 74
67889: PUSH
67890: LD_VAR 0 2
67894: ARRAY
67895: PPUSH
67896: LD_VAR 0 3
67900: PPUSH
67901: CALL_OW 3
67905: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67906: LD_ADDR_EXP 74
67910: PUSH
67911: LD_EXP 74
67915: PPUSH
67916: LD_VAR 0 2
67920: PPUSH
67921: LD_VAR 0 5
67925: PPUSH
67926: CALL_OW 1
67930: ST_TO_ADDR
// continue ;
67931: GO 67777
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67933: LD_EXP 58
67937: PUSH
67938: LD_VAR 0 2
67942: ARRAY
67943: PUSH
67944: LD_INT 1
67946: ARRAY
67947: PPUSH
67948: CALL_OW 255
67952: PPUSH
67953: LD_EXP 74
67957: PUSH
67958: LD_VAR 0 2
67962: ARRAY
67963: PUSH
67964: LD_VAR 0 3
67968: ARRAY
67969: PUSH
67970: LD_INT 2
67972: ARRAY
67973: PPUSH
67974: LD_EXP 74
67978: PUSH
67979: LD_VAR 0 2
67983: ARRAY
67984: PUSH
67985: LD_VAR 0 3
67989: ARRAY
67990: PUSH
67991: LD_INT 3
67993: ARRAY
67994: PPUSH
67995: LD_INT 30
67997: PPUSH
67998: CALL 21166 0 4
68002: PUSH
68003: LD_INT 4
68005: ARRAY
68006: PUSH
68007: LD_INT 0
68009: EQUAL
68010: IFFALSE 68036
// begin target := mc_crates [ i ] [ j ] ;
68012: LD_ADDR_VAR 0 6
68016: PUSH
68017: LD_EXP 74
68021: PUSH
68022: LD_VAR 0 2
68026: ARRAY
68027: PUSH
68028: LD_VAR 0 3
68032: ARRAY
68033: ST_TO_ADDR
// break ;
68034: GO 68038
// end ; end ;
68036: GO 67777
68038: POP
68039: POP
// if not target then
68040: LD_VAR 0 6
68044: NOT
68045: IFFALSE 68049
// continue ;
68047: GO 67658
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68049: LD_ADDR_VAR 0 7
68053: PUSH
68054: LD_EXP 77
68058: PUSH
68059: LD_VAR 0 2
68063: ARRAY
68064: PPUSH
68065: LD_INT 2
68067: PUSH
68068: LD_INT 3
68070: PUSH
68071: LD_INT 58
68073: PUSH
68074: EMPTY
68075: LIST
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 61
68083: PUSH
68084: EMPTY
68085: LIST
68086: PUSH
68087: LD_INT 33
68089: PUSH
68090: LD_INT 5
68092: PUSH
68093: EMPTY
68094: LIST
68095: LIST
68096: PUSH
68097: LD_INT 33
68099: PUSH
68100: LD_INT 3
68102: PUSH
68103: EMPTY
68104: LIST
68105: LIST
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: PUSH
68117: LD_INT 34
68119: PUSH
68120: LD_INT 32
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 34
68129: PUSH
68130: LD_INT 51
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: LD_INT 34
68139: PUSH
68140: LD_INT 12
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PPUSH
68157: CALL_OW 72
68161: ST_TO_ADDR
// if not cargo then
68162: LD_VAR 0 7
68166: NOT
68167: IFFALSE 68810
// begin if mc_crates_collector [ i ] < 5 then
68169: LD_EXP 75
68173: PUSH
68174: LD_VAR 0 2
68178: ARRAY
68179: PUSH
68180: LD_INT 5
68182: LESS
68183: IFFALSE 68549
// begin if mc_ape [ i ] then
68185: LD_EXP 87
68189: PUSH
68190: LD_VAR 0 2
68194: ARRAY
68195: IFFALSE 68242
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68197: LD_ADDR_VAR 0 5
68201: PUSH
68202: LD_EXP 87
68206: PUSH
68207: LD_VAR 0 2
68211: ARRAY
68212: PPUSH
68213: LD_INT 25
68215: PUSH
68216: LD_INT 16
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PUSH
68223: LD_INT 24
68225: PUSH
68226: LD_INT 750
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PPUSH
68237: CALL_OW 72
68241: ST_TO_ADDR
// if not tmp then
68242: LD_VAR 0 5
68246: NOT
68247: IFFALSE 68294
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68249: LD_ADDR_VAR 0 5
68253: PUSH
68254: LD_EXP 58
68258: PUSH
68259: LD_VAR 0 2
68263: ARRAY
68264: PPUSH
68265: LD_INT 25
68267: PUSH
68268: LD_INT 2
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: PUSH
68275: LD_INT 24
68277: PUSH
68278: LD_INT 750
68280: PUSH
68281: EMPTY
68282: LIST
68283: LIST
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PPUSH
68289: CALL_OW 72
68293: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68294: LD_EXP 87
68298: PUSH
68299: LD_VAR 0 2
68303: ARRAY
68304: PUSH
68305: LD_EXP 58
68309: PUSH
68310: LD_VAR 0 2
68314: ARRAY
68315: PPUSH
68316: LD_INT 25
68318: PUSH
68319: LD_INT 2
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 24
68328: PUSH
68329: LD_INT 750
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PPUSH
68340: CALL_OW 72
68344: AND
68345: PUSH
68346: LD_VAR 0 5
68350: PUSH
68351: LD_INT 5
68353: LESS
68354: AND
68355: IFFALSE 68437
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68357: LD_ADDR_VAR 0 3
68361: PUSH
68362: LD_EXP 58
68366: PUSH
68367: LD_VAR 0 2
68371: ARRAY
68372: PPUSH
68373: LD_INT 25
68375: PUSH
68376: LD_INT 2
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: PUSH
68383: LD_INT 24
68385: PUSH
68386: LD_INT 750
68388: PUSH
68389: EMPTY
68390: LIST
68391: LIST
68392: PUSH
68393: EMPTY
68394: LIST
68395: LIST
68396: PPUSH
68397: CALL_OW 72
68401: PUSH
68402: FOR_IN
68403: IFFALSE 68435
// begin tmp := tmp union j ;
68405: LD_ADDR_VAR 0 5
68409: PUSH
68410: LD_VAR 0 5
68414: PUSH
68415: LD_VAR 0 3
68419: UNION
68420: ST_TO_ADDR
// if tmp >= 5 then
68421: LD_VAR 0 5
68425: PUSH
68426: LD_INT 5
68428: GREATEREQUAL
68429: IFFALSE 68433
// break ;
68431: GO 68435
// end ;
68433: GO 68402
68435: POP
68436: POP
// end ; if not tmp then
68437: LD_VAR 0 5
68441: NOT
68442: IFFALSE 68446
// continue ;
68444: GO 67658
// for j in tmp do
68446: LD_ADDR_VAR 0 3
68450: PUSH
68451: LD_VAR 0 5
68455: PUSH
68456: FOR_IN
68457: IFFALSE 68547
// if not GetTag ( j ) then
68459: LD_VAR 0 3
68463: PPUSH
68464: CALL_OW 110
68468: NOT
68469: IFFALSE 68545
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68471: LD_ADDR_EXP 75
68475: PUSH
68476: LD_EXP 75
68480: PPUSH
68481: LD_VAR 0 2
68485: PUSH
68486: LD_EXP 75
68490: PUSH
68491: LD_VAR 0 2
68495: ARRAY
68496: PUSH
68497: LD_INT 1
68499: PLUS
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: PPUSH
68505: LD_VAR 0 3
68509: PPUSH
68510: CALL 20270 0 3
68514: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68515: LD_VAR 0 3
68519: PPUSH
68520: LD_INT 107
68522: PPUSH
68523: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68527: LD_EXP 75
68531: PUSH
68532: LD_VAR 0 2
68536: ARRAY
68537: PUSH
68538: LD_INT 5
68540: GREATEREQUAL
68541: IFFALSE 68545
// break ;
68543: GO 68547
// end ;
68545: GO 68456
68547: POP
68548: POP
// end ; if mc_crates_collector [ i ] and target then
68549: LD_EXP 75
68553: PUSH
68554: LD_VAR 0 2
68558: ARRAY
68559: PUSH
68560: LD_VAR 0 6
68564: AND
68565: IFFALSE 68808
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68567: LD_EXP 75
68571: PUSH
68572: LD_VAR 0 2
68576: ARRAY
68577: PUSH
68578: LD_VAR 0 6
68582: PUSH
68583: LD_INT 1
68585: ARRAY
68586: LESS
68587: IFFALSE 68607
// tmp := mc_crates_collector [ i ] else
68589: LD_ADDR_VAR 0 5
68593: PUSH
68594: LD_EXP 75
68598: PUSH
68599: LD_VAR 0 2
68603: ARRAY
68604: ST_TO_ADDR
68605: GO 68621
// tmp := target [ 1 ] ;
68607: LD_ADDR_VAR 0 5
68611: PUSH
68612: LD_VAR 0 6
68616: PUSH
68617: LD_INT 1
68619: ARRAY
68620: ST_TO_ADDR
// k := 0 ;
68621: LD_ADDR_VAR 0 4
68625: PUSH
68626: LD_INT 0
68628: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68629: LD_ADDR_VAR 0 3
68633: PUSH
68634: LD_EXP 75
68638: PUSH
68639: LD_VAR 0 2
68643: ARRAY
68644: PUSH
68645: FOR_IN
68646: IFFALSE 68806
// begin k := k + 1 ;
68648: LD_ADDR_VAR 0 4
68652: PUSH
68653: LD_VAR 0 4
68657: PUSH
68658: LD_INT 1
68660: PLUS
68661: ST_TO_ADDR
// if k > tmp then
68662: LD_VAR 0 4
68666: PUSH
68667: LD_VAR 0 5
68671: GREATER
68672: IFFALSE 68676
// break ;
68674: GO 68806
// if not GetClass ( j ) in [ 2 , 16 ] then
68676: LD_VAR 0 3
68680: PPUSH
68681: CALL_OW 257
68685: PUSH
68686: LD_INT 2
68688: PUSH
68689: LD_INT 16
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: IN
68696: NOT
68697: IFFALSE 68750
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68699: LD_ADDR_EXP 75
68703: PUSH
68704: LD_EXP 75
68708: PPUSH
68709: LD_VAR 0 2
68713: PPUSH
68714: LD_EXP 75
68718: PUSH
68719: LD_VAR 0 2
68723: ARRAY
68724: PUSH
68725: LD_VAR 0 3
68729: DIFF
68730: PPUSH
68731: CALL_OW 1
68735: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68736: LD_VAR 0 3
68740: PPUSH
68741: LD_INT 0
68743: PPUSH
68744: CALL_OW 109
// continue ;
68748: GO 68645
// end ; if IsInUnit ( j ) then
68750: LD_VAR 0 3
68754: PPUSH
68755: CALL_OW 310
68759: IFFALSE 68770
// ComExitBuilding ( j ) ;
68761: LD_VAR 0 3
68765: PPUSH
68766: CALL_OW 122
// wait ( 3 ) ;
68770: LD_INT 3
68772: PPUSH
68773: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68777: LD_VAR 0 3
68781: PPUSH
68782: LD_VAR 0 6
68786: PUSH
68787: LD_INT 2
68789: ARRAY
68790: PPUSH
68791: LD_VAR 0 6
68795: PUSH
68796: LD_INT 3
68798: ARRAY
68799: PPUSH
68800: CALL_OW 117
// end ;
68804: GO 68645
68806: POP
68807: POP
// end ; end else
68808: GO 69370
// begin for j in cargo do
68810: LD_ADDR_VAR 0 3
68814: PUSH
68815: LD_VAR 0 7
68819: PUSH
68820: FOR_IN
68821: IFFALSE 69368
// begin if GetTag ( j ) <> 0 then
68823: LD_VAR 0 3
68827: PPUSH
68828: CALL_OW 110
68832: PUSH
68833: LD_INT 0
68835: NONEQUAL
68836: IFFALSE 68840
// continue ;
68838: GO 68820
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68840: LD_VAR 0 3
68844: PPUSH
68845: CALL_OW 256
68849: PUSH
68850: LD_INT 1000
68852: LESS
68853: PUSH
68854: LD_VAR 0 3
68858: PPUSH
68859: LD_EXP 82
68863: PUSH
68864: LD_VAR 0 2
68868: ARRAY
68869: PPUSH
68870: CALL_OW 308
68874: NOT
68875: AND
68876: IFFALSE 68898
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68878: LD_VAR 0 3
68882: PPUSH
68883: LD_EXP 82
68887: PUSH
68888: LD_VAR 0 2
68892: ARRAY
68893: PPUSH
68894: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68898: LD_VAR 0 3
68902: PPUSH
68903: CALL_OW 256
68907: PUSH
68908: LD_INT 1000
68910: LESS
68911: PUSH
68912: LD_VAR 0 3
68916: PPUSH
68917: LD_EXP 82
68921: PUSH
68922: LD_VAR 0 2
68926: ARRAY
68927: PPUSH
68928: CALL_OW 308
68932: AND
68933: IFFALSE 68937
// continue ;
68935: GO 68820
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68937: LD_VAR 0 3
68941: PPUSH
68942: CALL_OW 262
68946: PUSH
68947: LD_INT 2
68949: EQUAL
68950: PUSH
68951: LD_VAR 0 3
68955: PPUSH
68956: CALL_OW 261
68960: PUSH
68961: LD_INT 15
68963: LESS
68964: AND
68965: IFFALSE 68969
// continue ;
68967: GO 68820
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68969: LD_VAR 0 3
68973: PPUSH
68974: CALL_OW 262
68978: PUSH
68979: LD_INT 1
68981: EQUAL
68982: PUSH
68983: LD_VAR 0 3
68987: PPUSH
68988: CALL_OW 261
68992: PUSH
68993: LD_INT 10
68995: LESS
68996: AND
68997: IFFALSE 69307
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68999: LD_ADDR_VAR 0 8
69003: PUSH
69004: LD_EXP 58
69008: PUSH
69009: LD_VAR 0 2
69013: ARRAY
69014: PPUSH
69015: LD_INT 2
69017: PUSH
69018: LD_INT 30
69020: PUSH
69021: LD_INT 0
69023: PUSH
69024: EMPTY
69025: LIST
69026: LIST
69027: PUSH
69028: LD_INT 30
69030: PUSH
69031: LD_INT 1
69033: PUSH
69034: EMPTY
69035: LIST
69036: LIST
69037: PUSH
69038: EMPTY
69039: LIST
69040: LIST
69041: LIST
69042: PPUSH
69043: CALL_OW 72
69047: ST_TO_ADDR
// if not depot then
69048: LD_VAR 0 8
69052: NOT
69053: IFFALSE 69057
// continue ;
69055: GO 68820
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69057: LD_VAR 0 3
69061: PPUSH
69062: LD_VAR 0 8
69066: PPUSH
69067: LD_VAR 0 3
69071: PPUSH
69072: CALL_OW 74
69076: PPUSH
69077: CALL_OW 296
69081: PUSH
69082: LD_INT 6
69084: LESS
69085: IFFALSE 69101
// SetFuel ( j , 100 ) else
69087: LD_VAR 0 3
69091: PPUSH
69092: LD_INT 100
69094: PPUSH
69095: CALL_OW 240
69099: GO 69307
// if GetFuel ( j ) = 0 then
69101: LD_VAR 0 3
69105: PPUSH
69106: CALL_OW 261
69110: PUSH
69111: LD_INT 0
69113: EQUAL
69114: IFFALSE 69307
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69116: LD_ADDR_EXP 77
69120: PUSH
69121: LD_EXP 77
69125: PPUSH
69126: LD_VAR 0 2
69130: PPUSH
69131: LD_EXP 77
69135: PUSH
69136: LD_VAR 0 2
69140: ARRAY
69141: PUSH
69142: LD_VAR 0 3
69146: DIFF
69147: PPUSH
69148: CALL_OW 1
69152: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69153: LD_VAR 0 3
69157: PPUSH
69158: CALL_OW 263
69162: PUSH
69163: LD_INT 1
69165: EQUAL
69166: IFFALSE 69182
// ComExitVehicle ( IsInUnit ( j ) ) ;
69168: LD_VAR 0 3
69172: PPUSH
69173: CALL_OW 310
69177: PPUSH
69178: CALL_OW 121
// if GetControl ( j ) = control_remote then
69182: LD_VAR 0 3
69186: PPUSH
69187: CALL_OW 263
69191: PUSH
69192: LD_INT 2
69194: EQUAL
69195: IFFALSE 69206
// ComUnlink ( j ) ;
69197: LD_VAR 0 3
69201: PPUSH
69202: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
69206: LD_ADDR_VAR 0 9
69210: PUSH
69211: LD_VAR 0 2
69215: PPUSH
69216: LD_INT 3
69218: PPUSH
69219: CALL 78469 0 2
69223: ST_TO_ADDR
// if fac then
69224: LD_VAR 0 9
69228: IFFALSE 69305
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69230: LD_ADDR_VAR 0 10
69234: PUSH
69235: LD_VAR 0 9
69239: PPUSH
69240: LD_VAR 0 3
69244: PPUSH
69245: CALL_OW 265
69249: PPUSH
69250: LD_VAR 0 3
69254: PPUSH
69255: CALL_OW 262
69259: PPUSH
69260: LD_VAR 0 3
69264: PPUSH
69265: CALL_OW 263
69269: PPUSH
69270: LD_VAR 0 3
69274: PPUSH
69275: CALL_OW 264
69279: PPUSH
69280: CALL 17870 0 5
69284: ST_TO_ADDR
// if components then
69285: LD_VAR 0 10
69289: IFFALSE 69305
// MC_InsertProduceList ( i , components ) ;
69291: LD_VAR 0 2
69295: PPUSH
69296: LD_VAR 0 10
69300: PPUSH
69301: CALL 78039 0 2
// end ; continue ;
69305: GO 68820
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69307: LD_VAR 0 3
69311: PPUSH
69312: LD_INT 1
69314: PPUSH
69315: CALL_OW 289
69319: PUSH
69320: LD_INT 100
69322: LESS
69323: PUSH
69324: LD_VAR 0 3
69328: PPUSH
69329: CALL_OW 314
69333: NOT
69334: AND
69335: IFFALSE 69364
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69337: LD_VAR 0 3
69341: PPUSH
69342: LD_VAR 0 6
69346: PUSH
69347: LD_INT 2
69349: ARRAY
69350: PPUSH
69351: LD_VAR 0 6
69355: PUSH
69356: LD_INT 3
69358: ARRAY
69359: PPUSH
69360: CALL_OW 117
// break ;
69364: GO 69368
// end ;
69366: GO 68820
69368: POP
69369: POP
// end ; end ;
69370: GO 67658
69372: POP
69373: POP
// end ;
69374: LD_VAR 0 1
69378: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69379: LD_INT 0
69381: PPUSH
69382: PPUSH
69383: PPUSH
69384: PPUSH
// if not mc_bases then
69385: LD_EXP 58
69389: NOT
69390: IFFALSE 69394
// exit ;
69392: GO 69555
// for i = 1 to mc_bases do
69394: LD_ADDR_VAR 0 2
69398: PUSH
69399: DOUBLE
69400: LD_INT 1
69402: DEC
69403: ST_TO_ADDR
69404: LD_EXP 58
69408: PUSH
69409: FOR_TO
69410: IFFALSE 69553
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69412: LD_ADDR_VAR 0 4
69416: PUSH
69417: LD_EXP 77
69421: PUSH
69422: LD_VAR 0 2
69426: ARRAY
69427: PUSH
69428: LD_EXP 80
69432: PUSH
69433: LD_VAR 0 2
69437: ARRAY
69438: UNION
69439: PPUSH
69440: LD_INT 33
69442: PUSH
69443: LD_INT 2
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PPUSH
69450: CALL_OW 72
69454: ST_TO_ADDR
// if tmp then
69455: LD_VAR 0 4
69459: IFFALSE 69551
// for j in tmp do
69461: LD_ADDR_VAR 0 3
69465: PUSH
69466: LD_VAR 0 4
69470: PUSH
69471: FOR_IN
69472: IFFALSE 69549
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69474: LD_VAR 0 3
69478: PPUSH
69479: CALL_OW 312
69483: NOT
69484: PUSH
69485: LD_VAR 0 3
69489: PPUSH
69490: CALL_OW 256
69494: PUSH
69495: LD_INT 250
69497: GREATEREQUAL
69498: AND
69499: IFFALSE 69512
// Connect ( j ) else
69501: LD_VAR 0 3
69505: PPUSH
69506: CALL 23203 0 1
69510: GO 69547
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69512: LD_VAR 0 3
69516: PPUSH
69517: CALL_OW 256
69521: PUSH
69522: LD_INT 250
69524: LESS
69525: PUSH
69526: LD_VAR 0 3
69530: PPUSH
69531: CALL_OW 312
69535: AND
69536: IFFALSE 69547
// ComUnlink ( j ) ;
69538: LD_VAR 0 3
69542: PPUSH
69543: CALL_OW 136
69547: GO 69471
69549: POP
69550: POP
// end ;
69551: GO 69409
69553: POP
69554: POP
// end ;
69555: LD_VAR 0 1
69559: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69560: LD_INT 0
69562: PPUSH
69563: PPUSH
69564: PPUSH
69565: PPUSH
69566: PPUSH
// if not mc_bases then
69567: LD_EXP 58
69571: NOT
69572: IFFALSE 69576
// exit ;
69574: GO 70036
// for i = 1 to mc_bases do
69576: LD_ADDR_VAR 0 2
69580: PUSH
69581: DOUBLE
69582: LD_INT 1
69584: DEC
69585: ST_TO_ADDR
69586: LD_EXP 58
69590: PUSH
69591: FOR_TO
69592: IFFALSE 70034
// begin if not mc_produce [ i ] then
69594: LD_EXP 79
69598: PUSH
69599: LD_VAR 0 2
69603: ARRAY
69604: NOT
69605: IFFALSE 69609
// continue ;
69607: GO 69591
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69609: LD_ADDR_VAR 0 5
69613: PUSH
69614: LD_EXP 58
69618: PUSH
69619: LD_VAR 0 2
69623: ARRAY
69624: PPUSH
69625: LD_INT 30
69627: PUSH
69628: LD_INT 3
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PPUSH
69635: CALL_OW 72
69639: ST_TO_ADDR
// if not fac then
69640: LD_VAR 0 5
69644: NOT
69645: IFFALSE 69649
// continue ;
69647: GO 69591
// for j in fac do
69649: LD_ADDR_VAR 0 3
69653: PUSH
69654: LD_VAR 0 5
69658: PUSH
69659: FOR_IN
69660: IFFALSE 70030
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
69662: LD_VAR 0 3
69666: PPUSH
69667: CALL_OW 461
69671: PUSH
69672: LD_INT 2
69674: NONEQUAL
69675: PUSH
69676: LD_VAR 0 3
69680: PPUSH
69681: LD_INT 15
69683: PPUSH
69684: CALL 22863 0 2
69688: PUSH
69689: LD_INT 4
69691: ARRAY
69692: OR
69693: PUSH
69694: LD_VAR 0 3
69698: PPUSH
69699: CALL_OW 313
69703: PUSH
69704: LD_INT 0
69706: EQUAL
69707: OR
69708: IFFALSE 69712
// continue ;
69710: GO 69659
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69712: LD_VAR 0 3
69716: PPUSH
69717: LD_EXP 79
69721: PUSH
69722: LD_VAR 0 2
69726: ARRAY
69727: PUSH
69728: LD_INT 1
69730: ARRAY
69731: PUSH
69732: LD_INT 1
69734: ARRAY
69735: PPUSH
69736: LD_EXP 79
69740: PUSH
69741: LD_VAR 0 2
69745: ARRAY
69746: PUSH
69747: LD_INT 1
69749: ARRAY
69750: PUSH
69751: LD_INT 2
69753: ARRAY
69754: PPUSH
69755: LD_EXP 79
69759: PUSH
69760: LD_VAR 0 2
69764: ARRAY
69765: PUSH
69766: LD_INT 1
69768: ARRAY
69769: PUSH
69770: LD_INT 3
69772: ARRAY
69773: PPUSH
69774: LD_EXP 79
69778: PUSH
69779: LD_VAR 0 2
69783: ARRAY
69784: PUSH
69785: LD_INT 1
69787: ARRAY
69788: PUSH
69789: LD_INT 4
69791: ARRAY
69792: PPUSH
69793: CALL_OW 448
69797: PUSH
69798: LD_VAR 0 3
69802: PPUSH
69803: LD_EXP 79
69807: PUSH
69808: LD_VAR 0 2
69812: ARRAY
69813: PUSH
69814: LD_INT 1
69816: ARRAY
69817: PUSH
69818: LD_INT 1
69820: ARRAY
69821: PUSH
69822: LD_EXP 79
69826: PUSH
69827: LD_VAR 0 2
69831: ARRAY
69832: PUSH
69833: LD_INT 1
69835: ARRAY
69836: PUSH
69837: LD_INT 2
69839: ARRAY
69840: PUSH
69841: LD_EXP 79
69845: PUSH
69846: LD_VAR 0 2
69850: ARRAY
69851: PUSH
69852: LD_INT 1
69854: ARRAY
69855: PUSH
69856: LD_INT 3
69858: ARRAY
69859: PUSH
69860: LD_EXP 79
69864: PUSH
69865: LD_VAR 0 2
69869: ARRAY
69870: PUSH
69871: LD_INT 1
69873: ARRAY
69874: PUSH
69875: LD_INT 4
69877: ARRAY
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: LIST
69883: LIST
69884: PPUSH
69885: CALL 26534 0 2
69889: AND
69890: IFFALSE 70028
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69892: LD_VAR 0 3
69896: PPUSH
69897: LD_EXP 79
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PUSH
69908: LD_INT 1
69910: ARRAY
69911: PUSH
69912: LD_INT 1
69914: ARRAY
69915: PPUSH
69916: LD_EXP 79
69920: PUSH
69921: LD_VAR 0 2
69925: ARRAY
69926: PUSH
69927: LD_INT 1
69929: ARRAY
69930: PUSH
69931: LD_INT 2
69933: ARRAY
69934: PPUSH
69935: LD_EXP 79
69939: PUSH
69940: LD_VAR 0 2
69944: ARRAY
69945: PUSH
69946: LD_INT 1
69948: ARRAY
69949: PUSH
69950: LD_INT 3
69952: ARRAY
69953: PPUSH
69954: LD_EXP 79
69958: PUSH
69959: LD_VAR 0 2
69963: ARRAY
69964: PUSH
69965: LD_INT 1
69967: ARRAY
69968: PUSH
69969: LD_INT 4
69971: ARRAY
69972: PPUSH
69973: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69977: LD_ADDR_VAR 0 4
69981: PUSH
69982: LD_EXP 79
69986: PUSH
69987: LD_VAR 0 2
69991: ARRAY
69992: PPUSH
69993: LD_INT 1
69995: PPUSH
69996: CALL_OW 3
70000: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70001: LD_ADDR_EXP 79
70005: PUSH
70006: LD_EXP 79
70010: PPUSH
70011: LD_VAR 0 2
70015: PPUSH
70016: LD_VAR 0 4
70020: PPUSH
70021: CALL_OW 1
70025: ST_TO_ADDR
// break ;
70026: GO 70030
// end ; end ;
70028: GO 69659
70030: POP
70031: POP
// end ;
70032: GO 69591
70034: POP
70035: POP
// end ;
70036: LD_VAR 0 1
70040: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70041: LD_INT 0
70043: PPUSH
70044: PPUSH
70045: PPUSH
// if not mc_bases then
70046: LD_EXP 58
70050: NOT
70051: IFFALSE 70055
// exit ;
70053: GO 70144
// for i = 1 to mc_bases do
70055: LD_ADDR_VAR 0 2
70059: PUSH
70060: DOUBLE
70061: LD_INT 1
70063: DEC
70064: ST_TO_ADDR
70065: LD_EXP 58
70069: PUSH
70070: FOR_TO
70071: IFFALSE 70142
// begin if mc_attack [ i ] then
70073: LD_EXP 78
70077: PUSH
70078: LD_VAR 0 2
70082: ARRAY
70083: IFFALSE 70140
// begin tmp := mc_attack [ i ] [ 1 ] ;
70085: LD_ADDR_VAR 0 3
70089: PUSH
70090: LD_EXP 78
70094: PUSH
70095: LD_VAR 0 2
70099: ARRAY
70100: PUSH
70101: LD_INT 1
70103: ARRAY
70104: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70105: LD_ADDR_EXP 78
70109: PUSH
70110: LD_EXP 78
70114: PPUSH
70115: LD_VAR 0 2
70119: PPUSH
70120: EMPTY
70121: PPUSH
70122: CALL_OW 1
70126: ST_TO_ADDR
// Attack ( tmp ) ;
70127: LD_VAR 0 3
70131: PPUSH
70132: CALL 48723 0 1
// exit ;
70136: POP
70137: POP
70138: GO 70144
// end ; end ;
70140: GO 70070
70142: POP
70143: POP
// end ;
70144: LD_VAR 0 1
70148: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70149: LD_INT 0
70151: PPUSH
70152: PPUSH
70153: PPUSH
70154: PPUSH
70155: PPUSH
70156: PPUSH
70157: PPUSH
// if not mc_bases then
70158: LD_EXP 58
70162: NOT
70163: IFFALSE 70167
// exit ;
70165: GO 70771
// for i = 1 to mc_bases do
70167: LD_ADDR_VAR 0 2
70171: PUSH
70172: DOUBLE
70173: LD_INT 1
70175: DEC
70176: ST_TO_ADDR
70177: LD_EXP 58
70181: PUSH
70182: FOR_TO
70183: IFFALSE 70769
// begin if not mc_bases [ i ] then
70185: LD_EXP 58
70189: PUSH
70190: LD_VAR 0 2
70194: ARRAY
70195: NOT
70196: IFFALSE 70200
// continue ;
70198: GO 70182
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70200: LD_ADDR_VAR 0 7
70204: PUSH
70205: LD_EXP 58
70209: PUSH
70210: LD_VAR 0 2
70214: ARRAY
70215: PUSH
70216: LD_INT 1
70218: ARRAY
70219: PPUSH
70220: CALL 17174 0 1
70224: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70225: LD_ADDR_EXP 81
70229: PUSH
70230: LD_EXP 81
70234: PPUSH
70235: LD_VAR 0 2
70239: PPUSH
70240: LD_EXP 58
70244: PUSH
70245: LD_VAR 0 2
70249: ARRAY
70250: PUSH
70251: LD_INT 1
70253: ARRAY
70254: PPUSH
70255: CALL_OW 255
70259: PPUSH
70260: LD_EXP 83
70264: PUSH
70265: LD_VAR 0 2
70269: ARRAY
70270: PPUSH
70271: CALL 15134 0 2
70275: PPUSH
70276: CALL_OW 1
70280: ST_TO_ADDR
// if not mc_scan [ i ] then
70281: LD_EXP 81
70285: PUSH
70286: LD_VAR 0 2
70290: ARRAY
70291: NOT
70292: IFFALSE 70447
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70294: LD_ADDR_VAR 0 4
70298: PUSH
70299: LD_EXP 58
70303: PUSH
70304: LD_VAR 0 2
70308: ARRAY
70309: PPUSH
70310: LD_INT 2
70312: PUSH
70313: LD_INT 25
70315: PUSH
70316: LD_INT 5
70318: PUSH
70319: EMPTY
70320: LIST
70321: LIST
70322: PUSH
70323: LD_INT 25
70325: PUSH
70326: LD_INT 8
70328: PUSH
70329: EMPTY
70330: LIST
70331: LIST
70332: PUSH
70333: LD_INT 25
70335: PUSH
70336: LD_INT 9
70338: PUSH
70339: EMPTY
70340: LIST
70341: LIST
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: LIST
70347: LIST
70348: PPUSH
70349: CALL_OW 72
70353: ST_TO_ADDR
// if not tmp then
70354: LD_VAR 0 4
70358: NOT
70359: IFFALSE 70363
// continue ;
70361: GO 70182
// for j in tmp do
70363: LD_ADDR_VAR 0 3
70367: PUSH
70368: LD_VAR 0 4
70372: PUSH
70373: FOR_IN
70374: IFFALSE 70445
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70376: LD_VAR 0 3
70380: PPUSH
70381: CALL_OW 310
70385: PPUSH
70386: CALL_OW 266
70390: PUSH
70391: LD_INT 5
70393: EQUAL
70394: PUSH
70395: LD_VAR 0 3
70399: PPUSH
70400: CALL_OW 257
70404: PUSH
70405: LD_INT 1
70407: EQUAL
70408: AND
70409: PUSH
70410: LD_VAR 0 3
70414: PPUSH
70415: CALL_OW 459
70419: NOT
70420: AND
70421: PUSH
70422: LD_VAR 0 7
70426: AND
70427: IFFALSE 70443
// ComChangeProfession ( j , class ) ;
70429: LD_VAR 0 3
70433: PPUSH
70434: LD_VAR 0 7
70438: PPUSH
70439: CALL_OW 123
70443: GO 70373
70445: POP
70446: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70447: LD_EXP 81
70451: PUSH
70452: LD_VAR 0 2
70456: ARRAY
70457: PUSH
70458: LD_EXP 80
70462: PUSH
70463: LD_VAR 0 2
70467: ARRAY
70468: NOT
70469: AND
70470: PUSH
70471: LD_EXP 58
70475: PUSH
70476: LD_VAR 0 2
70480: ARRAY
70481: PPUSH
70482: LD_INT 30
70484: PUSH
70485: LD_INT 32
70487: PUSH
70488: EMPTY
70489: LIST
70490: LIST
70491: PPUSH
70492: CALL_OW 72
70496: NOT
70497: AND
70498: PUSH
70499: LD_EXP 58
70503: PUSH
70504: LD_VAR 0 2
70508: ARRAY
70509: PPUSH
70510: LD_INT 2
70512: PUSH
70513: LD_INT 30
70515: PUSH
70516: LD_INT 4
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: PUSH
70523: LD_INT 30
70525: PUSH
70526: LD_INT 5
70528: PUSH
70529: EMPTY
70530: LIST
70531: LIST
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: LIST
70537: PPUSH
70538: CALL_OW 72
70542: NOT
70543: AND
70544: IFFALSE 70676
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70546: LD_ADDR_VAR 0 4
70550: PUSH
70551: LD_EXP 58
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: PPUSH
70562: LD_INT 2
70564: PUSH
70565: LD_INT 25
70567: PUSH
70568: LD_INT 1
70570: PUSH
70571: EMPTY
70572: LIST
70573: LIST
70574: PUSH
70575: LD_INT 25
70577: PUSH
70578: LD_INT 5
70580: PUSH
70581: EMPTY
70582: LIST
70583: LIST
70584: PUSH
70585: LD_INT 25
70587: PUSH
70588: LD_INT 8
70590: PUSH
70591: EMPTY
70592: LIST
70593: LIST
70594: PUSH
70595: LD_INT 25
70597: PUSH
70598: LD_INT 9
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: EMPTY
70606: LIST
70607: LIST
70608: LIST
70609: LIST
70610: LIST
70611: PPUSH
70612: CALL_OW 72
70616: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70617: LD_ADDR_VAR 0 4
70621: PUSH
70622: LD_VAR 0 4
70626: PUSH
70627: LD_VAR 0 4
70631: PPUSH
70632: LD_INT 18
70634: PPUSH
70635: CALL 53467 0 2
70639: DIFF
70640: ST_TO_ADDR
// if tmp then
70641: LD_VAR 0 4
70645: IFFALSE 70676
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70647: LD_VAR 0 2
70651: PPUSH
70652: LD_VAR 0 4
70656: PPUSH
70657: LD_EXP 83
70661: PUSH
70662: LD_VAR 0 2
70666: ARRAY
70667: PPUSH
70668: CALL 15169 0 3
// exit ;
70672: POP
70673: POP
70674: GO 70771
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70676: LD_EXP 81
70680: PUSH
70681: LD_VAR 0 2
70685: ARRAY
70686: PUSH
70687: LD_EXP 80
70691: PUSH
70692: LD_VAR 0 2
70696: ARRAY
70697: AND
70698: IFFALSE 70767
// begin tmp := mc_defender [ i ] ;
70700: LD_ADDR_VAR 0 4
70704: PUSH
70705: LD_EXP 80
70709: PUSH
70710: LD_VAR 0 2
70714: ARRAY
70715: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70716: LD_ADDR_EXP 80
70720: PUSH
70721: LD_EXP 80
70725: PPUSH
70726: LD_VAR 0 2
70730: PPUSH
70731: EMPTY
70732: PPUSH
70733: CALL_OW 1
70737: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70738: LD_VAR 0 2
70742: PPUSH
70743: LD_VAR 0 4
70747: PPUSH
70748: LD_EXP 81
70752: PUSH
70753: LD_VAR 0 2
70757: ARRAY
70758: PPUSH
70759: CALL 15667 0 3
// exit ;
70763: POP
70764: POP
70765: GO 70771
// end ; end ;
70767: GO 70182
70769: POP
70770: POP
// end ;
70771: LD_VAR 0 1
70775: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70776: LD_INT 0
70778: PPUSH
70779: PPUSH
70780: PPUSH
70781: PPUSH
70782: PPUSH
70783: PPUSH
70784: PPUSH
70785: PPUSH
70786: PPUSH
70787: PPUSH
70788: PPUSH
// if not mc_bases then
70789: LD_EXP 58
70793: NOT
70794: IFFALSE 70798
// exit ;
70796: GO 71885
// for i = 1 to mc_bases do
70798: LD_ADDR_VAR 0 2
70802: PUSH
70803: DOUBLE
70804: LD_INT 1
70806: DEC
70807: ST_TO_ADDR
70808: LD_EXP 58
70812: PUSH
70813: FOR_TO
70814: IFFALSE 71883
// begin tmp := mc_lab [ i ] ;
70816: LD_ADDR_VAR 0 6
70820: PUSH
70821: LD_EXP 91
70825: PUSH
70826: LD_VAR 0 2
70830: ARRAY
70831: ST_TO_ADDR
// if not tmp then
70832: LD_VAR 0 6
70836: NOT
70837: IFFALSE 70841
// continue ;
70839: GO 70813
// idle_lab := 0 ;
70841: LD_ADDR_VAR 0 11
70845: PUSH
70846: LD_INT 0
70848: ST_TO_ADDR
// for j in tmp do
70849: LD_ADDR_VAR 0 3
70853: PUSH
70854: LD_VAR 0 6
70858: PUSH
70859: FOR_IN
70860: IFFALSE 71879
// begin researching := false ;
70862: LD_ADDR_VAR 0 10
70866: PUSH
70867: LD_INT 0
70869: ST_TO_ADDR
// side := GetSide ( j ) ;
70870: LD_ADDR_VAR 0 4
70874: PUSH
70875: LD_VAR 0 3
70879: PPUSH
70880: CALL_OW 255
70884: ST_TO_ADDR
// if not mc_tech [ side ] then
70885: LD_EXP 85
70889: PUSH
70890: LD_VAR 0 4
70894: ARRAY
70895: NOT
70896: IFFALSE 70900
// continue ;
70898: GO 70859
// if BuildingStatus ( j ) = bs_idle then
70900: LD_VAR 0 3
70904: PPUSH
70905: CALL_OW 461
70909: PUSH
70910: LD_INT 2
70912: EQUAL
70913: IFFALSE 71101
// begin if idle_lab and UnitsInside ( j ) < 6 then
70915: LD_VAR 0 11
70919: PUSH
70920: LD_VAR 0 3
70924: PPUSH
70925: CALL_OW 313
70929: PUSH
70930: LD_INT 6
70932: LESS
70933: AND
70934: IFFALSE 71005
// begin tmp2 := UnitsInside ( idle_lab ) ;
70936: LD_ADDR_VAR 0 9
70940: PUSH
70941: LD_VAR 0 11
70945: PPUSH
70946: CALL_OW 313
70950: ST_TO_ADDR
// if tmp2 then
70951: LD_VAR 0 9
70955: IFFALSE 70997
// for x in tmp2 do
70957: LD_ADDR_VAR 0 7
70961: PUSH
70962: LD_VAR 0 9
70966: PUSH
70967: FOR_IN
70968: IFFALSE 70995
// begin ComExitBuilding ( x ) ;
70970: LD_VAR 0 7
70974: PPUSH
70975: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70979: LD_VAR 0 7
70983: PPUSH
70984: LD_VAR 0 3
70988: PPUSH
70989: CALL_OW 180
// end ;
70993: GO 70967
70995: POP
70996: POP
// idle_lab := 0 ;
70997: LD_ADDR_VAR 0 11
71001: PUSH
71002: LD_INT 0
71004: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71005: LD_ADDR_VAR 0 5
71009: PUSH
71010: LD_EXP 85
71014: PUSH
71015: LD_VAR 0 4
71019: ARRAY
71020: PUSH
71021: FOR_IN
71022: IFFALSE 71082
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71024: LD_VAR 0 3
71028: PPUSH
71029: LD_VAR 0 5
71033: PPUSH
71034: CALL_OW 430
71038: PUSH
71039: LD_VAR 0 4
71043: PPUSH
71044: LD_VAR 0 5
71048: PPUSH
71049: CALL 14239 0 2
71053: AND
71054: IFFALSE 71080
// begin researching := true ;
71056: LD_ADDR_VAR 0 10
71060: PUSH
71061: LD_INT 1
71063: ST_TO_ADDR
// ComResearch ( j , t ) ;
71064: LD_VAR 0 3
71068: PPUSH
71069: LD_VAR 0 5
71073: PPUSH
71074: CALL_OW 124
// break ;
71078: GO 71082
// end ;
71080: GO 71021
71082: POP
71083: POP
// if not researching then
71084: LD_VAR 0 10
71088: NOT
71089: IFFALSE 71101
// idle_lab := j ;
71091: LD_ADDR_VAR 0 11
71095: PUSH
71096: LD_VAR 0 3
71100: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71101: LD_VAR 0 3
71105: PPUSH
71106: CALL_OW 461
71110: PUSH
71111: LD_INT 10
71113: EQUAL
71114: IFFALSE 71702
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71116: LD_EXP 87
71120: PUSH
71121: LD_VAR 0 2
71125: ARRAY
71126: NOT
71127: PUSH
71128: LD_EXP 88
71132: PUSH
71133: LD_VAR 0 2
71137: ARRAY
71138: NOT
71139: AND
71140: PUSH
71141: LD_EXP 85
71145: PUSH
71146: LD_VAR 0 4
71150: ARRAY
71151: PUSH
71152: LD_INT 1
71154: GREATER
71155: AND
71156: IFFALSE 71287
// begin ComCancel ( j ) ;
71158: LD_VAR 0 3
71162: PPUSH
71163: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71167: LD_ADDR_EXP 85
71171: PUSH
71172: LD_EXP 85
71176: PPUSH
71177: LD_VAR 0 4
71181: PPUSH
71182: LD_EXP 85
71186: PUSH
71187: LD_VAR 0 4
71191: ARRAY
71192: PPUSH
71193: LD_EXP 85
71197: PUSH
71198: LD_VAR 0 4
71202: ARRAY
71203: PUSH
71204: LD_INT 1
71206: MINUS
71207: PPUSH
71208: LD_EXP 85
71212: PUSH
71213: LD_VAR 0 4
71217: ARRAY
71218: PPUSH
71219: LD_INT 0
71221: PPUSH
71222: CALL 19688 0 4
71226: PPUSH
71227: CALL_OW 1
71231: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71232: LD_ADDR_EXP 85
71236: PUSH
71237: LD_EXP 85
71241: PPUSH
71242: LD_VAR 0 4
71246: PPUSH
71247: LD_EXP 85
71251: PUSH
71252: LD_VAR 0 4
71256: ARRAY
71257: PPUSH
71258: LD_EXP 85
71262: PUSH
71263: LD_VAR 0 4
71267: ARRAY
71268: PPUSH
71269: LD_INT 1
71271: PPUSH
71272: LD_INT 0
71274: PPUSH
71275: CALL 19688 0 4
71279: PPUSH
71280: CALL_OW 1
71284: ST_TO_ADDR
// continue ;
71285: GO 70859
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71287: LD_EXP 87
71291: PUSH
71292: LD_VAR 0 2
71296: ARRAY
71297: PUSH
71298: LD_EXP 88
71302: PUSH
71303: LD_VAR 0 2
71307: ARRAY
71308: NOT
71309: AND
71310: IFFALSE 71437
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71312: LD_ADDR_EXP 88
71316: PUSH
71317: LD_EXP 88
71321: PPUSH
71322: LD_VAR 0 2
71326: PUSH
71327: LD_EXP 88
71331: PUSH
71332: LD_VAR 0 2
71336: ARRAY
71337: PUSH
71338: LD_INT 1
71340: PLUS
71341: PUSH
71342: EMPTY
71343: LIST
71344: LIST
71345: PPUSH
71346: LD_EXP 87
71350: PUSH
71351: LD_VAR 0 2
71355: ARRAY
71356: PUSH
71357: LD_INT 1
71359: ARRAY
71360: PPUSH
71361: CALL 20270 0 3
71365: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71366: LD_EXP 87
71370: PUSH
71371: LD_VAR 0 2
71375: ARRAY
71376: PUSH
71377: LD_INT 1
71379: ARRAY
71380: PPUSH
71381: LD_INT 112
71383: PPUSH
71384: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71388: LD_ADDR_VAR 0 9
71392: PUSH
71393: LD_EXP 87
71397: PUSH
71398: LD_VAR 0 2
71402: ARRAY
71403: PPUSH
71404: LD_INT 1
71406: PPUSH
71407: CALL_OW 3
71411: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71412: LD_ADDR_EXP 87
71416: PUSH
71417: LD_EXP 87
71421: PPUSH
71422: LD_VAR 0 2
71426: PPUSH
71427: LD_VAR 0 9
71431: PPUSH
71432: CALL_OW 1
71436: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71437: LD_EXP 87
71441: PUSH
71442: LD_VAR 0 2
71446: ARRAY
71447: PUSH
71448: LD_EXP 88
71452: PUSH
71453: LD_VAR 0 2
71457: ARRAY
71458: AND
71459: PUSH
71460: LD_EXP 88
71464: PUSH
71465: LD_VAR 0 2
71469: ARRAY
71470: PUSH
71471: LD_INT 1
71473: ARRAY
71474: PPUSH
71475: CALL_OW 310
71479: NOT
71480: AND
71481: PUSH
71482: LD_VAR 0 3
71486: PPUSH
71487: CALL_OW 313
71491: PUSH
71492: LD_INT 6
71494: EQUAL
71495: AND
71496: IFFALSE 71552
// begin tmp2 := UnitsInside ( j ) ;
71498: LD_ADDR_VAR 0 9
71502: PUSH
71503: LD_VAR 0 3
71507: PPUSH
71508: CALL_OW 313
71512: ST_TO_ADDR
// if tmp2 = 6 then
71513: LD_VAR 0 9
71517: PUSH
71518: LD_INT 6
71520: EQUAL
71521: IFFALSE 71552
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71523: LD_VAR 0 9
71527: PUSH
71528: LD_INT 1
71530: ARRAY
71531: PPUSH
71532: LD_INT 112
71534: PPUSH
71535: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71539: LD_VAR 0 9
71543: PUSH
71544: LD_INT 1
71546: ARRAY
71547: PPUSH
71548: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71552: LD_EXP 88
71556: PUSH
71557: LD_VAR 0 2
71561: ARRAY
71562: PUSH
71563: LD_EXP 88
71567: PUSH
71568: LD_VAR 0 2
71572: ARRAY
71573: PUSH
71574: LD_INT 1
71576: ARRAY
71577: PPUSH
71578: CALL_OW 314
71582: NOT
71583: AND
71584: PUSH
71585: LD_EXP 88
71589: PUSH
71590: LD_VAR 0 2
71594: ARRAY
71595: PUSH
71596: LD_INT 1
71598: ARRAY
71599: PPUSH
71600: CALL_OW 310
71604: NOT
71605: AND
71606: IFFALSE 71632
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71608: LD_EXP 88
71612: PUSH
71613: LD_VAR 0 2
71617: ARRAY
71618: PUSH
71619: LD_INT 1
71621: ARRAY
71622: PPUSH
71623: LD_VAR 0 3
71627: PPUSH
71628: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71632: LD_EXP 88
71636: PUSH
71637: LD_VAR 0 2
71641: ARRAY
71642: PUSH
71643: LD_INT 1
71645: ARRAY
71646: PPUSH
71647: CALL_OW 310
71651: PUSH
71652: LD_EXP 88
71656: PUSH
71657: LD_VAR 0 2
71661: ARRAY
71662: PUSH
71663: LD_INT 1
71665: ARRAY
71666: PPUSH
71667: CALL_OW 310
71671: PPUSH
71672: CALL_OW 461
71676: PUSH
71677: LD_INT 3
71679: NONEQUAL
71680: AND
71681: IFFALSE 71702
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71683: LD_EXP 88
71687: PUSH
71688: LD_VAR 0 2
71692: ARRAY
71693: PUSH
71694: LD_INT 1
71696: ARRAY
71697: PPUSH
71698: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71702: LD_VAR 0 3
71706: PPUSH
71707: CALL_OW 461
71711: PUSH
71712: LD_INT 6
71714: EQUAL
71715: PUSH
71716: LD_VAR 0 6
71720: PUSH
71721: LD_INT 1
71723: GREATER
71724: AND
71725: IFFALSE 71877
// begin sci := [ ] ;
71727: LD_ADDR_VAR 0 8
71731: PUSH
71732: EMPTY
71733: ST_TO_ADDR
// for x in ( tmp diff j ) do
71734: LD_ADDR_VAR 0 7
71738: PUSH
71739: LD_VAR 0 6
71743: PUSH
71744: LD_VAR 0 3
71748: DIFF
71749: PUSH
71750: FOR_IN
71751: IFFALSE 71803
// begin if sci = 6 then
71753: LD_VAR 0 8
71757: PUSH
71758: LD_INT 6
71760: EQUAL
71761: IFFALSE 71765
// break ;
71763: GO 71803
// if BuildingStatus ( x ) = bs_idle then
71765: LD_VAR 0 7
71769: PPUSH
71770: CALL_OW 461
71774: PUSH
71775: LD_INT 2
71777: EQUAL
71778: IFFALSE 71801
// sci := sci ^ UnitsInside ( x ) ;
71780: LD_ADDR_VAR 0 8
71784: PUSH
71785: LD_VAR 0 8
71789: PUSH
71790: LD_VAR 0 7
71794: PPUSH
71795: CALL_OW 313
71799: ADD
71800: ST_TO_ADDR
// end ;
71801: GO 71750
71803: POP
71804: POP
// if not sci then
71805: LD_VAR 0 8
71809: NOT
71810: IFFALSE 71814
// continue ;
71812: GO 70859
// for x in sci do
71814: LD_ADDR_VAR 0 7
71818: PUSH
71819: LD_VAR 0 8
71823: PUSH
71824: FOR_IN
71825: IFFALSE 71875
// if IsInUnit ( x ) and not HasTask ( x ) then
71827: LD_VAR 0 7
71831: PPUSH
71832: CALL_OW 310
71836: PUSH
71837: LD_VAR 0 7
71841: PPUSH
71842: CALL_OW 314
71846: NOT
71847: AND
71848: IFFALSE 71873
// begin ComExitBuilding ( x ) ;
71850: LD_VAR 0 7
71854: PPUSH
71855: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71859: LD_VAR 0 7
71863: PPUSH
71864: LD_VAR 0 3
71868: PPUSH
71869: CALL_OW 180
// end ;
71873: GO 71824
71875: POP
71876: POP
// end ; end ;
71877: GO 70859
71879: POP
71880: POP
// end ;
71881: GO 70813
71883: POP
71884: POP
// end ;
71885: LD_VAR 0 1
71889: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71890: LD_INT 0
71892: PPUSH
71893: PPUSH
// if not mc_bases then
71894: LD_EXP 58
71898: NOT
71899: IFFALSE 71903
// exit ;
71901: GO 71984
// for i = 1 to mc_bases do
71903: LD_ADDR_VAR 0 2
71907: PUSH
71908: DOUBLE
71909: LD_INT 1
71911: DEC
71912: ST_TO_ADDR
71913: LD_EXP 58
71917: PUSH
71918: FOR_TO
71919: IFFALSE 71982
// if mc_mines [ i ] and mc_miners [ i ] then
71921: LD_EXP 71
71925: PUSH
71926: LD_VAR 0 2
71930: ARRAY
71931: PUSH
71932: LD_EXP 72
71936: PUSH
71937: LD_VAR 0 2
71941: ARRAY
71942: AND
71943: IFFALSE 71980
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71945: LD_EXP 72
71949: PUSH
71950: LD_VAR 0 2
71954: ARRAY
71955: PUSH
71956: LD_INT 1
71958: ARRAY
71959: PPUSH
71960: CALL_OW 255
71964: PPUSH
71965: LD_EXP 71
71969: PUSH
71970: LD_VAR 0 2
71974: ARRAY
71975: PPUSH
71976: CALL 17327 0 2
71980: GO 71918
71982: POP
71983: POP
// end ;
71984: LD_VAR 0 1
71988: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71989: LD_INT 0
71991: PPUSH
71992: PPUSH
71993: PPUSH
71994: PPUSH
71995: PPUSH
71996: PPUSH
71997: PPUSH
71998: PPUSH
// if not mc_bases or not mc_parking then
71999: LD_EXP 58
72003: NOT
72004: PUSH
72005: LD_EXP 82
72009: NOT
72010: OR
72011: IFFALSE 72015
// exit ;
72013: GO 72727
// for i = 1 to mc_bases do
72015: LD_ADDR_VAR 0 2
72019: PUSH
72020: DOUBLE
72021: LD_INT 1
72023: DEC
72024: ST_TO_ADDR
72025: LD_EXP 58
72029: PUSH
72030: FOR_TO
72031: IFFALSE 72725
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72033: LD_EXP 58
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: NOT
72044: PUSH
72045: LD_EXP 82
72049: PUSH
72050: LD_VAR 0 2
72054: ARRAY
72055: NOT
72056: OR
72057: IFFALSE 72061
// continue ;
72059: GO 72030
// if mc_scan [ i ] then
72061: LD_EXP 81
72065: PUSH
72066: LD_VAR 0 2
72070: ARRAY
72071: IFFALSE 72097
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72073: LD_ADDR_EXP 70
72077: PUSH
72078: LD_EXP 70
72082: PPUSH
72083: LD_VAR 0 2
72087: PPUSH
72088: EMPTY
72089: PPUSH
72090: CALL_OW 1
72094: ST_TO_ADDR
// continue ;
72095: GO 72030
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72097: LD_ADDR_VAR 0 5
72101: PUSH
72102: LD_EXP 58
72106: PUSH
72107: LD_VAR 0 2
72111: ARRAY
72112: PUSH
72113: LD_INT 1
72115: ARRAY
72116: PPUSH
72117: CALL_OW 255
72121: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72122: LD_ADDR_VAR 0 6
72126: PUSH
72127: LD_EXP 58
72131: PUSH
72132: LD_VAR 0 2
72136: ARRAY
72137: PPUSH
72138: LD_INT 30
72140: PUSH
72141: LD_INT 3
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PPUSH
72148: CALL_OW 72
72152: ST_TO_ADDR
// if not fac then
72153: LD_VAR 0 6
72157: NOT
72158: IFFALSE 72209
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72160: LD_ADDR_VAR 0 6
72164: PUSH
72165: LD_EXP 58
72169: PUSH
72170: LD_VAR 0 2
72174: ARRAY
72175: PPUSH
72176: LD_INT 2
72178: PUSH
72179: LD_INT 30
72181: PUSH
72182: LD_INT 0
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: PUSH
72189: LD_INT 30
72191: PUSH
72192: LD_INT 1
72194: PUSH
72195: EMPTY
72196: LIST
72197: LIST
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: LIST
72203: PPUSH
72204: CALL_OW 72
72208: ST_TO_ADDR
// if not fac then
72209: LD_VAR 0 6
72213: NOT
72214: IFFALSE 72218
// continue ;
72216: GO 72030
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72218: LD_ADDR_VAR 0 7
72222: PUSH
72223: LD_EXP 82
72227: PUSH
72228: LD_VAR 0 2
72232: ARRAY
72233: PPUSH
72234: LD_INT 22
72236: PUSH
72237: LD_VAR 0 5
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PUSH
72246: LD_INT 21
72248: PUSH
72249: LD_INT 2
72251: PUSH
72252: EMPTY
72253: LIST
72254: LIST
72255: PUSH
72256: LD_INT 3
72258: PUSH
72259: LD_INT 24
72261: PUSH
72262: LD_INT 1000
72264: PUSH
72265: EMPTY
72266: LIST
72267: LIST
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: LIST
72277: PPUSH
72278: CALL_OW 70
72282: PUSH
72283: LD_INT 22
72285: PUSH
72286: LD_VAR 0 5
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 91
72297: PUSH
72298: LD_VAR 0 6
72302: PUSH
72303: LD_INT 1
72305: ARRAY
72306: PUSH
72307: LD_INT 25
72309: PUSH
72310: EMPTY
72311: LIST
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 21
72317: PUSH
72318: LD_INT 2
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 3
72327: PUSH
72328: LD_INT 24
72330: PUSH
72331: LD_INT 1000
72333: PUSH
72334: EMPTY
72335: LIST
72336: LIST
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: LIST
72346: LIST
72347: PPUSH
72348: CALL_OW 69
72352: UNION
72353: ST_TO_ADDR
// if not vehs then
72354: LD_VAR 0 7
72358: NOT
72359: IFFALSE 72385
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72361: LD_ADDR_EXP 70
72365: PUSH
72366: LD_EXP 70
72370: PPUSH
72371: LD_VAR 0 2
72375: PPUSH
72376: EMPTY
72377: PPUSH
72378: CALL_OW 1
72382: ST_TO_ADDR
// continue ;
72383: GO 72030
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72385: LD_ADDR_VAR 0 8
72389: PUSH
72390: LD_EXP 58
72394: PUSH
72395: LD_VAR 0 2
72399: ARRAY
72400: PPUSH
72401: LD_INT 30
72403: PUSH
72404: LD_INT 3
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: PPUSH
72411: CALL_OW 72
72415: ST_TO_ADDR
// if tmp then
72416: LD_VAR 0 8
72420: IFFALSE 72523
// begin for j in tmp do
72422: LD_ADDR_VAR 0 3
72426: PUSH
72427: LD_VAR 0 8
72431: PUSH
72432: FOR_IN
72433: IFFALSE 72521
// for k in UnitsInside ( j ) do
72435: LD_ADDR_VAR 0 4
72439: PUSH
72440: LD_VAR 0 3
72444: PPUSH
72445: CALL_OW 313
72449: PUSH
72450: FOR_IN
72451: IFFALSE 72517
// if k then
72453: LD_VAR 0 4
72457: IFFALSE 72515
// if not k in mc_repair_vehicle [ i ] then
72459: LD_VAR 0 4
72463: PUSH
72464: LD_EXP 70
72468: PUSH
72469: LD_VAR 0 2
72473: ARRAY
72474: IN
72475: NOT
72476: IFFALSE 72515
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72478: LD_ADDR_EXP 70
72482: PUSH
72483: LD_EXP 70
72487: PPUSH
72488: LD_VAR 0 2
72492: PPUSH
72493: LD_EXP 70
72497: PUSH
72498: LD_VAR 0 2
72502: ARRAY
72503: PUSH
72504: LD_VAR 0 4
72508: UNION
72509: PPUSH
72510: CALL_OW 1
72514: ST_TO_ADDR
72515: GO 72450
72517: POP
72518: POP
72519: GO 72432
72521: POP
72522: POP
// end ; if not mc_repair_vehicle [ i ] then
72523: LD_EXP 70
72527: PUSH
72528: LD_VAR 0 2
72532: ARRAY
72533: NOT
72534: IFFALSE 72538
// continue ;
72536: GO 72030
// for j in mc_repair_vehicle [ i ] do
72538: LD_ADDR_VAR 0 3
72542: PUSH
72543: LD_EXP 70
72547: PUSH
72548: LD_VAR 0 2
72552: ARRAY
72553: PUSH
72554: FOR_IN
72555: IFFALSE 72721
// begin if GetClass ( j ) <> 3 then
72557: LD_VAR 0 3
72561: PPUSH
72562: CALL_OW 257
72566: PUSH
72567: LD_INT 3
72569: NONEQUAL
72570: IFFALSE 72611
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72572: LD_ADDR_EXP 70
72576: PUSH
72577: LD_EXP 70
72581: PPUSH
72582: LD_VAR 0 2
72586: PPUSH
72587: LD_EXP 70
72591: PUSH
72592: LD_VAR 0 2
72596: ARRAY
72597: PUSH
72598: LD_VAR 0 3
72602: DIFF
72603: PPUSH
72604: CALL_OW 1
72608: ST_TO_ADDR
// continue ;
72609: GO 72554
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72611: LD_VAR 0 3
72615: PPUSH
72616: CALL_OW 311
72620: NOT
72621: PUSH
72622: LD_VAR 0 3
72626: PUSH
72627: LD_EXP 61
72631: PUSH
72632: LD_VAR 0 2
72636: ARRAY
72637: PUSH
72638: LD_INT 1
72640: ARRAY
72641: IN
72642: NOT
72643: AND
72644: PUSH
72645: LD_VAR 0 3
72649: PUSH
72650: LD_EXP 61
72654: PUSH
72655: LD_VAR 0 2
72659: ARRAY
72660: PUSH
72661: LD_INT 2
72663: ARRAY
72664: IN
72665: NOT
72666: AND
72667: IFFALSE 72719
// begin if IsInUnit ( j ) then
72669: LD_VAR 0 3
72673: PPUSH
72674: CALL_OW 310
72678: IFFALSE 72689
// ComExitBuilding ( j ) ;
72680: LD_VAR 0 3
72684: PPUSH
72685: CALL_OW 122
// if not HasTask ( j ) then
72689: LD_VAR 0 3
72693: PPUSH
72694: CALL_OW 314
72698: NOT
72699: IFFALSE 72719
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72701: LD_VAR 0 3
72705: PPUSH
72706: LD_VAR 0 7
72710: PUSH
72711: LD_INT 1
72713: ARRAY
72714: PPUSH
72715: CALL_OW 189
// end ; end ;
72719: GO 72554
72721: POP
72722: POP
// end ;
72723: GO 72030
72725: POP
72726: POP
// end ;
72727: LD_VAR 0 1
72731: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72732: LD_INT 0
72734: PPUSH
72735: PPUSH
72736: PPUSH
72737: PPUSH
72738: PPUSH
72739: PPUSH
72740: PPUSH
72741: PPUSH
72742: PPUSH
72743: PPUSH
72744: PPUSH
// if not mc_bases then
72745: LD_EXP 58
72749: NOT
72750: IFFALSE 72754
// exit ;
72752: GO 73556
// for i = 1 to mc_bases do
72754: LD_ADDR_VAR 0 2
72758: PUSH
72759: DOUBLE
72760: LD_INT 1
72762: DEC
72763: ST_TO_ADDR
72764: LD_EXP 58
72768: PUSH
72769: FOR_TO
72770: IFFALSE 73554
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72772: LD_EXP 86
72776: PUSH
72777: LD_VAR 0 2
72781: ARRAY
72782: NOT
72783: PUSH
72784: LD_EXP 61
72788: PUSH
72789: LD_VAR 0 2
72793: ARRAY
72794: PUSH
72795: LD_INT 1
72797: ARRAY
72798: OR
72799: PUSH
72800: LD_EXP 61
72804: PUSH
72805: LD_VAR 0 2
72809: ARRAY
72810: PUSH
72811: LD_INT 2
72813: ARRAY
72814: OR
72815: PUSH
72816: LD_EXP 84
72820: PUSH
72821: LD_VAR 0 2
72825: ARRAY
72826: PPUSH
72827: LD_INT 1
72829: PPUSH
72830: CALL_OW 325
72834: NOT
72835: OR
72836: PUSH
72837: LD_EXP 81
72841: PUSH
72842: LD_VAR 0 2
72846: ARRAY
72847: OR
72848: IFFALSE 72852
// continue ;
72850: GO 72769
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72852: LD_ADDR_VAR 0 8
72856: PUSH
72857: LD_EXP 58
72861: PUSH
72862: LD_VAR 0 2
72866: ARRAY
72867: PPUSH
72868: LD_INT 25
72870: PUSH
72871: LD_INT 4
72873: PUSH
72874: EMPTY
72875: LIST
72876: LIST
72877: PUSH
72878: LD_INT 50
72880: PUSH
72881: EMPTY
72882: LIST
72883: PUSH
72884: LD_INT 3
72886: PUSH
72887: LD_INT 60
72889: PUSH
72890: EMPTY
72891: LIST
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: LIST
72901: PPUSH
72902: CALL_OW 72
72906: PUSH
72907: LD_EXP 62
72911: PUSH
72912: LD_VAR 0 2
72916: ARRAY
72917: DIFF
72918: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72919: LD_ADDR_VAR 0 9
72923: PUSH
72924: LD_EXP 58
72928: PUSH
72929: LD_VAR 0 2
72933: ARRAY
72934: PPUSH
72935: LD_INT 2
72937: PUSH
72938: LD_INT 30
72940: PUSH
72941: LD_INT 0
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: LD_INT 30
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: EMPTY
72955: LIST
72956: LIST
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: LIST
72962: PPUSH
72963: CALL_OW 72
72967: ST_TO_ADDR
// if not tmp or not dep then
72968: LD_VAR 0 8
72972: NOT
72973: PUSH
72974: LD_VAR 0 9
72978: NOT
72979: OR
72980: IFFALSE 72984
// continue ;
72982: GO 72769
// side := GetSide ( tmp [ 1 ] ) ;
72984: LD_ADDR_VAR 0 11
72988: PUSH
72989: LD_VAR 0 8
72993: PUSH
72994: LD_INT 1
72996: ARRAY
72997: PPUSH
72998: CALL_OW 255
73002: ST_TO_ADDR
// dep := dep [ 1 ] ;
73003: LD_ADDR_VAR 0 9
73007: PUSH
73008: LD_VAR 0 9
73012: PUSH
73013: LD_INT 1
73015: ARRAY
73016: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73017: LD_ADDR_VAR 0 7
73021: PUSH
73022: LD_EXP 86
73026: PUSH
73027: LD_VAR 0 2
73031: ARRAY
73032: PPUSH
73033: LD_INT 22
73035: PUSH
73036: LD_INT 0
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: PUSH
73043: LD_INT 25
73045: PUSH
73046: LD_INT 12
73048: PUSH
73049: EMPTY
73050: LIST
73051: LIST
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PPUSH
73057: CALL_OW 70
73061: PUSH
73062: LD_INT 22
73064: PUSH
73065: LD_INT 0
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: PUSH
73072: LD_INT 25
73074: PUSH
73075: LD_INT 12
73077: PUSH
73078: EMPTY
73079: LIST
73080: LIST
73081: PUSH
73082: LD_INT 91
73084: PUSH
73085: LD_VAR 0 9
73089: PUSH
73090: LD_INT 20
73092: PUSH
73093: EMPTY
73094: LIST
73095: LIST
73096: LIST
73097: PUSH
73098: EMPTY
73099: LIST
73100: LIST
73101: LIST
73102: PPUSH
73103: CALL_OW 69
73107: UNION
73108: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73109: LD_ADDR_VAR 0 10
73113: PUSH
73114: LD_EXP 86
73118: PUSH
73119: LD_VAR 0 2
73123: ARRAY
73124: PPUSH
73125: LD_INT 81
73127: PUSH
73128: LD_VAR 0 11
73132: PUSH
73133: EMPTY
73134: LIST
73135: LIST
73136: PPUSH
73137: CALL_OW 70
73141: ST_TO_ADDR
// if not apes or danger_at_area then
73142: LD_VAR 0 7
73146: NOT
73147: PUSH
73148: LD_VAR 0 10
73152: OR
73153: IFFALSE 73203
// begin if mc_taming [ i ] then
73155: LD_EXP 89
73159: PUSH
73160: LD_VAR 0 2
73164: ARRAY
73165: IFFALSE 73201
// begin MC_Reset ( i , 121 ) ;
73167: LD_VAR 0 2
73171: PPUSH
73172: LD_INT 121
73174: PPUSH
73175: CALL 59161 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73179: LD_ADDR_EXP 89
73183: PUSH
73184: LD_EXP 89
73188: PPUSH
73189: LD_VAR 0 2
73193: PPUSH
73194: EMPTY
73195: PPUSH
73196: CALL_OW 1
73200: ST_TO_ADDR
// end ; continue ;
73201: GO 72769
// end ; for j in tmp do
73203: LD_ADDR_VAR 0 3
73207: PUSH
73208: LD_VAR 0 8
73212: PUSH
73213: FOR_IN
73214: IFFALSE 73550
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73216: LD_VAR 0 3
73220: PUSH
73221: LD_EXP 89
73225: PUSH
73226: LD_VAR 0 2
73230: ARRAY
73231: IN
73232: NOT
73233: PUSH
73234: LD_EXP 89
73238: PUSH
73239: LD_VAR 0 2
73243: ARRAY
73244: PUSH
73245: LD_INT 3
73247: LESS
73248: AND
73249: IFFALSE 73307
// begin SetTag ( j , 121 ) ;
73251: LD_VAR 0 3
73255: PPUSH
73256: LD_INT 121
73258: PPUSH
73259: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73263: LD_ADDR_EXP 89
73267: PUSH
73268: LD_EXP 89
73272: PPUSH
73273: LD_VAR 0 2
73277: PUSH
73278: LD_EXP 89
73282: PUSH
73283: LD_VAR 0 2
73287: ARRAY
73288: PUSH
73289: LD_INT 1
73291: PLUS
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: PPUSH
73297: LD_VAR 0 3
73301: PPUSH
73302: CALL 20270 0 3
73306: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73307: LD_VAR 0 3
73311: PUSH
73312: LD_EXP 89
73316: PUSH
73317: LD_VAR 0 2
73321: ARRAY
73322: IN
73323: IFFALSE 73548
// begin if GetClass ( j ) <> 4 then
73325: LD_VAR 0 3
73329: PPUSH
73330: CALL_OW 257
73334: PUSH
73335: LD_INT 4
73337: NONEQUAL
73338: IFFALSE 73391
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73340: LD_ADDR_EXP 89
73344: PUSH
73345: LD_EXP 89
73349: PPUSH
73350: LD_VAR 0 2
73354: PPUSH
73355: LD_EXP 89
73359: PUSH
73360: LD_VAR 0 2
73364: ARRAY
73365: PUSH
73366: LD_VAR 0 3
73370: DIFF
73371: PPUSH
73372: CALL_OW 1
73376: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73377: LD_VAR 0 3
73381: PPUSH
73382: LD_INT 0
73384: PPUSH
73385: CALL_OW 109
// continue ;
73389: GO 73213
// end ; if IsInUnit ( j ) then
73391: LD_VAR 0 3
73395: PPUSH
73396: CALL_OW 310
73400: IFFALSE 73411
// ComExitBuilding ( j ) ;
73402: LD_VAR 0 3
73406: PPUSH
73407: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73411: LD_ADDR_VAR 0 6
73415: PUSH
73416: LD_VAR 0 7
73420: PPUSH
73421: LD_VAR 0 3
73425: PPUSH
73426: CALL_OW 74
73430: ST_TO_ADDR
// if not ape then
73431: LD_VAR 0 6
73435: NOT
73436: IFFALSE 73440
// break ;
73438: GO 73550
// x := GetX ( ape ) ;
73440: LD_ADDR_VAR 0 4
73444: PUSH
73445: LD_VAR 0 6
73449: PPUSH
73450: CALL_OW 250
73454: ST_TO_ADDR
// y := GetY ( ape ) ;
73455: LD_ADDR_VAR 0 5
73459: PUSH
73460: LD_VAR 0 6
73464: PPUSH
73465: CALL_OW 251
73469: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73470: LD_VAR 0 4
73474: PPUSH
73475: LD_VAR 0 5
73479: PPUSH
73480: CALL_OW 488
73484: NOT
73485: PUSH
73486: LD_VAR 0 11
73490: PPUSH
73491: LD_VAR 0 4
73495: PPUSH
73496: LD_VAR 0 5
73500: PPUSH
73501: LD_INT 20
73503: PPUSH
73504: CALL 21166 0 4
73508: PUSH
73509: LD_INT 4
73511: ARRAY
73512: OR
73513: IFFALSE 73517
// break ;
73515: GO 73550
// if not HasTask ( j ) then
73517: LD_VAR 0 3
73521: PPUSH
73522: CALL_OW 314
73526: NOT
73527: IFFALSE 73548
// ComTameXY ( j , x , y ) ;
73529: LD_VAR 0 3
73533: PPUSH
73534: LD_VAR 0 4
73538: PPUSH
73539: LD_VAR 0 5
73543: PPUSH
73544: CALL_OW 131
// end ; end ;
73548: GO 73213
73550: POP
73551: POP
// end ;
73552: GO 72769
73554: POP
73555: POP
// end ;
73556: LD_VAR 0 1
73560: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73561: LD_INT 0
73563: PPUSH
73564: PPUSH
73565: PPUSH
73566: PPUSH
73567: PPUSH
73568: PPUSH
73569: PPUSH
73570: PPUSH
// if not mc_bases then
73571: LD_EXP 58
73575: NOT
73576: IFFALSE 73580
// exit ;
73578: GO 74206
// for i = 1 to mc_bases do
73580: LD_ADDR_VAR 0 2
73584: PUSH
73585: DOUBLE
73586: LD_INT 1
73588: DEC
73589: ST_TO_ADDR
73590: LD_EXP 58
73594: PUSH
73595: FOR_TO
73596: IFFALSE 74204
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73598: LD_EXP 87
73602: PUSH
73603: LD_VAR 0 2
73607: ARRAY
73608: NOT
73609: PUSH
73610: LD_EXP 87
73614: PUSH
73615: LD_VAR 0 2
73619: ARRAY
73620: PPUSH
73621: LD_INT 25
73623: PUSH
73624: LD_INT 12
73626: PUSH
73627: EMPTY
73628: LIST
73629: LIST
73630: PPUSH
73631: CALL_OW 72
73635: NOT
73636: OR
73637: IFFALSE 73641
// continue ;
73639: GO 73595
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73641: LD_ADDR_VAR 0 5
73645: PUSH
73646: LD_EXP 87
73650: PUSH
73651: LD_VAR 0 2
73655: ARRAY
73656: PUSH
73657: LD_INT 1
73659: ARRAY
73660: PPUSH
73661: CALL_OW 255
73665: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73666: LD_VAR 0 5
73670: PPUSH
73671: LD_INT 2
73673: PPUSH
73674: CALL_OW 325
73678: IFFALSE 73931
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73680: LD_ADDR_VAR 0 4
73684: PUSH
73685: LD_EXP 87
73689: PUSH
73690: LD_VAR 0 2
73694: ARRAY
73695: PPUSH
73696: LD_INT 25
73698: PUSH
73699: LD_INT 16
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PPUSH
73706: CALL_OW 72
73710: ST_TO_ADDR
// if tmp < 6 then
73711: LD_VAR 0 4
73715: PUSH
73716: LD_INT 6
73718: LESS
73719: IFFALSE 73931
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73721: LD_ADDR_VAR 0 6
73725: PUSH
73726: LD_EXP 58
73730: PUSH
73731: LD_VAR 0 2
73735: ARRAY
73736: PPUSH
73737: LD_INT 2
73739: PUSH
73740: LD_INT 30
73742: PUSH
73743: LD_INT 0
73745: PUSH
73746: EMPTY
73747: LIST
73748: LIST
73749: PUSH
73750: LD_INT 30
73752: PUSH
73753: LD_INT 1
73755: PUSH
73756: EMPTY
73757: LIST
73758: LIST
73759: PUSH
73760: EMPTY
73761: LIST
73762: LIST
73763: LIST
73764: PPUSH
73765: CALL_OW 72
73769: ST_TO_ADDR
// if depot then
73770: LD_VAR 0 6
73774: IFFALSE 73931
// begin selected := 0 ;
73776: LD_ADDR_VAR 0 7
73780: PUSH
73781: LD_INT 0
73783: ST_TO_ADDR
// for j in depot do
73784: LD_ADDR_VAR 0 3
73788: PUSH
73789: LD_VAR 0 6
73793: PUSH
73794: FOR_IN
73795: IFFALSE 73826
// begin if UnitsInside ( j ) < 6 then
73797: LD_VAR 0 3
73801: PPUSH
73802: CALL_OW 313
73806: PUSH
73807: LD_INT 6
73809: LESS
73810: IFFALSE 73824
// begin selected := j ;
73812: LD_ADDR_VAR 0 7
73816: PUSH
73817: LD_VAR 0 3
73821: ST_TO_ADDR
// break ;
73822: GO 73826
// end ; end ;
73824: GO 73794
73826: POP
73827: POP
// if selected then
73828: LD_VAR 0 7
73832: IFFALSE 73931
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73834: LD_ADDR_VAR 0 3
73838: PUSH
73839: LD_EXP 87
73843: PUSH
73844: LD_VAR 0 2
73848: ARRAY
73849: PPUSH
73850: LD_INT 25
73852: PUSH
73853: LD_INT 12
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PPUSH
73860: CALL_OW 72
73864: PUSH
73865: FOR_IN
73866: IFFALSE 73929
// if not HasTask ( j ) then
73868: LD_VAR 0 3
73872: PPUSH
73873: CALL_OW 314
73877: NOT
73878: IFFALSE 73927
// begin if not IsInUnit ( j ) then
73880: LD_VAR 0 3
73884: PPUSH
73885: CALL_OW 310
73889: NOT
73890: IFFALSE 73906
// ComEnterUnit ( j , selected ) ;
73892: LD_VAR 0 3
73896: PPUSH
73897: LD_VAR 0 7
73901: PPUSH
73902: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73906: LD_VAR 0 3
73910: PPUSH
73911: LD_INT 16
73913: PPUSH
73914: CALL_OW 183
// AddComExitBuilding ( j ) ;
73918: LD_VAR 0 3
73922: PPUSH
73923: CALL_OW 182
// end ;
73927: GO 73865
73929: POP
73930: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73931: LD_VAR 0 5
73935: PPUSH
73936: LD_INT 11
73938: PPUSH
73939: CALL_OW 325
73943: IFFALSE 74202
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73945: LD_ADDR_VAR 0 4
73949: PUSH
73950: LD_EXP 87
73954: PUSH
73955: LD_VAR 0 2
73959: ARRAY
73960: PPUSH
73961: LD_INT 25
73963: PUSH
73964: LD_INT 16
73966: PUSH
73967: EMPTY
73968: LIST
73969: LIST
73970: PPUSH
73971: CALL_OW 72
73975: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73976: LD_VAR 0 4
73980: PUSH
73981: LD_INT 6
73983: GREATEREQUAL
73984: PUSH
73985: LD_VAR 0 5
73989: PPUSH
73990: LD_INT 2
73992: PPUSH
73993: CALL_OW 325
73997: NOT
73998: OR
73999: IFFALSE 74202
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74001: LD_ADDR_VAR 0 8
74005: PUSH
74006: LD_EXP 58
74010: PUSH
74011: LD_VAR 0 2
74015: ARRAY
74016: PPUSH
74017: LD_INT 2
74019: PUSH
74020: LD_INT 30
74022: PUSH
74023: LD_INT 4
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 30
74032: PUSH
74033: LD_INT 5
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: LIST
74044: PPUSH
74045: CALL_OW 72
74049: ST_TO_ADDR
// if barracks then
74050: LD_VAR 0 8
74054: IFFALSE 74202
// begin selected := 0 ;
74056: LD_ADDR_VAR 0 7
74060: PUSH
74061: LD_INT 0
74063: ST_TO_ADDR
// for j in barracks do
74064: LD_ADDR_VAR 0 3
74068: PUSH
74069: LD_VAR 0 8
74073: PUSH
74074: FOR_IN
74075: IFFALSE 74106
// begin if UnitsInside ( j ) < 6 then
74077: LD_VAR 0 3
74081: PPUSH
74082: CALL_OW 313
74086: PUSH
74087: LD_INT 6
74089: LESS
74090: IFFALSE 74104
// begin selected := j ;
74092: LD_ADDR_VAR 0 7
74096: PUSH
74097: LD_VAR 0 3
74101: ST_TO_ADDR
// break ;
74102: GO 74106
// end ; end ;
74104: GO 74074
74106: POP
74107: POP
// if selected then
74108: LD_VAR 0 7
74112: IFFALSE 74202
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74114: LD_ADDR_VAR 0 3
74118: PUSH
74119: LD_EXP 87
74123: PUSH
74124: LD_VAR 0 2
74128: ARRAY
74129: PPUSH
74130: LD_INT 25
74132: PUSH
74133: LD_INT 12
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: PPUSH
74140: CALL_OW 72
74144: PUSH
74145: FOR_IN
74146: IFFALSE 74200
// if not IsInUnit ( j ) and not HasTask ( j ) then
74148: LD_VAR 0 3
74152: PPUSH
74153: CALL_OW 310
74157: NOT
74158: PUSH
74159: LD_VAR 0 3
74163: PPUSH
74164: CALL_OW 314
74168: NOT
74169: AND
74170: IFFALSE 74198
// begin ComEnterUnit ( j , selected ) ;
74172: LD_VAR 0 3
74176: PPUSH
74177: LD_VAR 0 7
74181: PPUSH
74182: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74186: LD_VAR 0 3
74190: PPUSH
74191: LD_INT 15
74193: PPUSH
74194: CALL_OW 183
// end ;
74198: GO 74145
74200: POP
74201: POP
// end ; end ; end ; end ; end ;
74202: GO 73595
74204: POP
74205: POP
// end ;
74206: LD_VAR 0 1
74210: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74211: LD_INT 0
74213: PPUSH
74214: PPUSH
74215: PPUSH
74216: PPUSH
// if not mc_bases then
74217: LD_EXP 58
74221: NOT
74222: IFFALSE 74226
// exit ;
74224: GO 74404
// for i = 1 to mc_bases do
74226: LD_ADDR_VAR 0 2
74230: PUSH
74231: DOUBLE
74232: LD_INT 1
74234: DEC
74235: ST_TO_ADDR
74236: LD_EXP 58
74240: PUSH
74241: FOR_TO
74242: IFFALSE 74402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74244: LD_ADDR_VAR 0 4
74248: PUSH
74249: LD_EXP 58
74253: PUSH
74254: LD_VAR 0 2
74258: ARRAY
74259: PPUSH
74260: LD_INT 25
74262: PUSH
74263: LD_INT 9
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PPUSH
74270: CALL_OW 72
74274: ST_TO_ADDR
// if not tmp then
74275: LD_VAR 0 4
74279: NOT
74280: IFFALSE 74284
// continue ;
74282: GO 74241
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74284: LD_EXP 84
74288: PUSH
74289: LD_VAR 0 2
74293: ARRAY
74294: PPUSH
74295: LD_INT 29
74297: PPUSH
74298: CALL_OW 325
74302: NOT
74303: PUSH
74304: LD_EXP 84
74308: PUSH
74309: LD_VAR 0 2
74313: ARRAY
74314: PPUSH
74315: LD_INT 28
74317: PPUSH
74318: CALL_OW 325
74322: NOT
74323: AND
74324: IFFALSE 74328
// continue ;
74326: GO 74241
// for j in tmp do
74328: LD_ADDR_VAR 0 3
74332: PUSH
74333: LD_VAR 0 4
74337: PUSH
74338: FOR_IN
74339: IFFALSE 74398
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74341: LD_VAR 0 3
74345: PUSH
74346: LD_EXP 61
74350: PUSH
74351: LD_VAR 0 2
74355: ARRAY
74356: PUSH
74357: LD_INT 1
74359: ARRAY
74360: IN
74361: NOT
74362: PUSH
74363: LD_VAR 0 3
74367: PUSH
74368: LD_EXP 61
74372: PUSH
74373: LD_VAR 0 2
74377: ARRAY
74378: PUSH
74379: LD_INT 2
74381: ARRAY
74382: IN
74383: NOT
74384: AND
74385: IFFALSE 74396
// ComSpaceTimeShoot ( j ) ;
74387: LD_VAR 0 3
74391: PPUSH
74392: CALL 14330 0 1
74396: GO 74338
74398: POP
74399: POP
// end ;
74400: GO 74241
74402: POP
74403: POP
// end ;
74404: LD_VAR 0 1
74408: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74409: LD_INT 0
74411: PPUSH
74412: PPUSH
74413: PPUSH
74414: PPUSH
74415: PPUSH
74416: PPUSH
74417: PPUSH
74418: PPUSH
74419: PPUSH
// if not mc_bases then
74420: LD_EXP 58
74424: NOT
74425: IFFALSE 74429
// exit ;
74427: GO 75051
// for i = 1 to mc_bases do
74429: LD_ADDR_VAR 0 2
74433: PUSH
74434: DOUBLE
74435: LD_INT 1
74437: DEC
74438: ST_TO_ADDR
74439: LD_EXP 58
74443: PUSH
74444: FOR_TO
74445: IFFALSE 75049
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74447: LD_EXP 93
74451: PUSH
74452: LD_VAR 0 2
74456: ARRAY
74457: NOT
74458: PUSH
74459: LD_INT 38
74461: PPUSH
74462: LD_EXP 84
74466: PUSH
74467: LD_VAR 0 2
74471: ARRAY
74472: PPUSH
74473: CALL_OW 321
74477: PUSH
74478: LD_INT 2
74480: NONEQUAL
74481: OR
74482: IFFALSE 74486
// continue ;
74484: GO 74444
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74486: LD_ADDR_VAR 0 8
74490: PUSH
74491: LD_EXP 58
74495: PUSH
74496: LD_VAR 0 2
74500: ARRAY
74501: PPUSH
74502: LD_INT 30
74504: PUSH
74505: LD_INT 34
74507: PUSH
74508: EMPTY
74509: LIST
74510: LIST
74511: PPUSH
74512: CALL_OW 72
74516: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74517: LD_ADDR_VAR 0 9
74521: PUSH
74522: LD_EXP 58
74526: PUSH
74527: LD_VAR 0 2
74531: ARRAY
74532: PPUSH
74533: LD_INT 25
74535: PUSH
74536: LD_INT 4
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PPUSH
74543: CALL_OW 72
74547: PPUSH
74548: LD_INT 0
74550: PPUSH
74551: CALL 53467 0 2
74555: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74556: LD_VAR 0 9
74560: NOT
74561: PUSH
74562: LD_VAR 0 8
74566: NOT
74567: OR
74568: PUSH
74569: LD_EXP 58
74573: PUSH
74574: LD_VAR 0 2
74578: ARRAY
74579: PPUSH
74580: LD_INT 124
74582: PPUSH
74583: CALL 53467 0 2
74587: OR
74588: IFFALSE 74592
// continue ;
74590: GO 74444
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74592: LD_EXP 94
74596: PUSH
74597: LD_VAR 0 2
74601: ARRAY
74602: PUSH
74603: LD_EXP 93
74607: PUSH
74608: LD_VAR 0 2
74612: ARRAY
74613: LESS
74614: PUSH
74615: LD_EXP 94
74619: PUSH
74620: LD_VAR 0 2
74624: ARRAY
74625: PUSH
74626: LD_VAR 0 8
74630: LESS
74631: AND
74632: IFFALSE 75047
// begin tmp := sci [ 1 ] ;
74634: LD_ADDR_VAR 0 7
74638: PUSH
74639: LD_VAR 0 9
74643: PUSH
74644: LD_INT 1
74646: ARRAY
74647: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74648: LD_VAR 0 7
74652: PPUSH
74653: LD_INT 124
74655: PPUSH
74656: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74660: LD_ADDR_VAR 0 3
74664: PUSH
74665: DOUBLE
74666: LD_EXP 93
74670: PUSH
74671: LD_VAR 0 2
74675: ARRAY
74676: INC
74677: ST_TO_ADDR
74678: LD_EXP 93
74682: PUSH
74683: LD_VAR 0 2
74687: ARRAY
74688: PUSH
74689: FOR_DOWNTO
74690: IFFALSE 75033
// begin if IsInUnit ( tmp ) then
74692: LD_VAR 0 7
74696: PPUSH
74697: CALL_OW 310
74701: IFFALSE 74712
// ComExitBuilding ( tmp ) ;
74703: LD_VAR 0 7
74707: PPUSH
74708: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74712: LD_INT 35
74714: PPUSH
74715: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74719: LD_VAR 0 7
74723: PPUSH
74724: CALL_OW 310
74728: NOT
74729: PUSH
74730: LD_VAR 0 7
74734: PPUSH
74735: CALL_OW 314
74739: NOT
74740: AND
74741: IFFALSE 74712
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74743: LD_ADDR_VAR 0 6
74747: PUSH
74748: LD_VAR 0 7
74752: PPUSH
74753: CALL_OW 250
74757: PUSH
74758: LD_VAR 0 7
74762: PPUSH
74763: CALL_OW 251
74767: PUSH
74768: EMPTY
74769: LIST
74770: LIST
74771: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74772: LD_INT 35
74774: PPUSH
74775: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74779: LD_ADDR_VAR 0 4
74783: PUSH
74784: LD_EXP 93
74788: PUSH
74789: LD_VAR 0 2
74793: ARRAY
74794: PUSH
74795: LD_VAR 0 3
74799: ARRAY
74800: PUSH
74801: LD_INT 1
74803: ARRAY
74804: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74805: LD_ADDR_VAR 0 5
74809: PUSH
74810: LD_EXP 93
74814: PUSH
74815: LD_VAR 0 2
74819: ARRAY
74820: PUSH
74821: LD_VAR 0 3
74825: ARRAY
74826: PUSH
74827: LD_INT 2
74829: ARRAY
74830: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74831: LD_VAR 0 7
74835: PPUSH
74836: LD_INT 10
74838: PPUSH
74839: CALL 22863 0 2
74843: PUSH
74844: LD_INT 4
74846: ARRAY
74847: IFFALSE 74885
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74849: LD_VAR 0 7
74853: PPUSH
74854: LD_VAR 0 6
74858: PUSH
74859: LD_INT 1
74861: ARRAY
74862: PPUSH
74863: LD_VAR 0 6
74867: PUSH
74868: LD_INT 2
74870: ARRAY
74871: PPUSH
74872: CALL_OW 111
// wait ( 0 0$10 ) ;
74876: LD_INT 350
74878: PPUSH
74879: CALL_OW 67
// end else
74883: GO 74911
// begin ComMoveXY ( tmp , x , y ) ;
74885: LD_VAR 0 7
74889: PPUSH
74890: LD_VAR 0 4
74894: PPUSH
74895: LD_VAR 0 5
74899: PPUSH
74900: CALL_OW 111
// wait ( 0 0$3 ) ;
74904: LD_INT 105
74906: PPUSH
74907: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74911: LD_VAR 0 7
74915: PPUSH
74916: LD_VAR 0 4
74920: PPUSH
74921: LD_VAR 0 5
74925: PPUSH
74926: CALL_OW 307
74930: IFFALSE 74772
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74932: LD_VAR 0 7
74936: PPUSH
74937: LD_VAR 0 4
74941: PPUSH
74942: LD_VAR 0 5
74946: PPUSH
74947: LD_VAR 0 8
74951: PUSH
74952: LD_VAR 0 3
74956: ARRAY
74957: PPUSH
74958: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74962: LD_INT 35
74964: PPUSH
74965: CALL_OW 67
// until not HasTask ( tmp ) ;
74969: LD_VAR 0 7
74973: PPUSH
74974: CALL_OW 314
74978: NOT
74979: IFFALSE 74962
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74981: LD_ADDR_EXP 94
74985: PUSH
74986: LD_EXP 94
74990: PPUSH
74991: LD_VAR 0 2
74995: PUSH
74996: LD_EXP 94
75000: PUSH
75001: LD_VAR 0 2
75005: ARRAY
75006: PUSH
75007: LD_INT 1
75009: PLUS
75010: PUSH
75011: EMPTY
75012: LIST
75013: LIST
75014: PPUSH
75015: LD_VAR 0 8
75019: PUSH
75020: LD_VAR 0 3
75024: ARRAY
75025: PPUSH
75026: CALL 20270 0 3
75030: ST_TO_ADDR
// end ;
75031: GO 74689
75033: POP
75034: POP
// MC_Reset ( i , 124 ) ;
75035: LD_VAR 0 2
75039: PPUSH
75040: LD_INT 124
75042: PPUSH
75043: CALL 59161 0 2
// end ; end ;
75047: GO 74444
75049: POP
75050: POP
// end ;
75051: LD_VAR 0 1
75055: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75056: LD_INT 0
75058: PPUSH
75059: PPUSH
75060: PPUSH
// if not mc_bases then
75061: LD_EXP 58
75065: NOT
75066: IFFALSE 75070
// exit ;
75068: GO 75676
// for i = 1 to mc_bases do
75070: LD_ADDR_VAR 0 2
75074: PUSH
75075: DOUBLE
75076: LD_INT 1
75078: DEC
75079: ST_TO_ADDR
75080: LD_EXP 58
75084: PUSH
75085: FOR_TO
75086: IFFALSE 75674
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75088: LD_ADDR_VAR 0 3
75092: PUSH
75093: LD_EXP 58
75097: PUSH
75098: LD_VAR 0 2
75102: ARRAY
75103: PPUSH
75104: LD_INT 25
75106: PUSH
75107: LD_INT 4
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: PPUSH
75114: CALL_OW 72
75118: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75119: LD_VAR 0 3
75123: NOT
75124: PUSH
75125: LD_EXP 95
75129: PUSH
75130: LD_VAR 0 2
75134: ARRAY
75135: NOT
75136: OR
75137: PUSH
75138: LD_EXP 58
75142: PUSH
75143: LD_VAR 0 2
75147: ARRAY
75148: PPUSH
75149: LD_INT 2
75151: PUSH
75152: LD_INT 30
75154: PUSH
75155: LD_INT 0
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: LD_INT 30
75164: PUSH
75165: LD_INT 1
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: EMPTY
75173: LIST
75174: LIST
75175: LIST
75176: PPUSH
75177: CALL_OW 72
75181: NOT
75182: OR
75183: IFFALSE 75233
// begin if mc_deposits_finder [ i ] then
75185: LD_EXP 96
75189: PUSH
75190: LD_VAR 0 2
75194: ARRAY
75195: IFFALSE 75231
// begin MC_Reset ( i , 125 ) ;
75197: LD_VAR 0 2
75201: PPUSH
75202: LD_INT 125
75204: PPUSH
75205: CALL 59161 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75209: LD_ADDR_EXP 96
75213: PUSH
75214: LD_EXP 96
75218: PPUSH
75219: LD_VAR 0 2
75223: PPUSH
75224: EMPTY
75225: PPUSH
75226: CALL_OW 1
75230: ST_TO_ADDR
// end ; continue ;
75231: GO 75085
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75233: LD_EXP 95
75237: PUSH
75238: LD_VAR 0 2
75242: ARRAY
75243: PUSH
75244: LD_INT 1
75246: ARRAY
75247: PUSH
75248: LD_INT 3
75250: ARRAY
75251: PUSH
75252: LD_INT 1
75254: EQUAL
75255: PUSH
75256: LD_INT 20
75258: PPUSH
75259: LD_EXP 84
75263: PUSH
75264: LD_VAR 0 2
75268: ARRAY
75269: PPUSH
75270: CALL_OW 321
75274: PUSH
75275: LD_INT 2
75277: NONEQUAL
75278: AND
75279: IFFALSE 75329
// begin if mc_deposits_finder [ i ] then
75281: LD_EXP 96
75285: PUSH
75286: LD_VAR 0 2
75290: ARRAY
75291: IFFALSE 75327
// begin MC_Reset ( i , 125 ) ;
75293: LD_VAR 0 2
75297: PPUSH
75298: LD_INT 125
75300: PPUSH
75301: CALL 59161 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75305: LD_ADDR_EXP 96
75309: PUSH
75310: LD_EXP 96
75314: PPUSH
75315: LD_VAR 0 2
75319: PPUSH
75320: EMPTY
75321: PPUSH
75322: CALL_OW 1
75326: ST_TO_ADDR
// end ; continue ;
75327: GO 75085
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75329: LD_EXP 95
75333: PUSH
75334: LD_VAR 0 2
75338: ARRAY
75339: PUSH
75340: LD_INT 1
75342: ARRAY
75343: PUSH
75344: LD_INT 1
75346: ARRAY
75347: PPUSH
75348: LD_EXP 95
75352: PUSH
75353: LD_VAR 0 2
75357: ARRAY
75358: PUSH
75359: LD_INT 1
75361: ARRAY
75362: PUSH
75363: LD_INT 2
75365: ARRAY
75366: PPUSH
75367: LD_EXP 84
75371: PUSH
75372: LD_VAR 0 2
75376: ARRAY
75377: PPUSH
75378: CALL_OW 440
75382: IFFALSE 75425
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75384: LD_ADDR_EXP 95
75388: PUSH
75389: LD_EXP 95
75393: PPUSH
75394: LD_VAR 0 2
75398: PPUSH
75399: LD_EXP 95
75403: PUSH
75404: LD_VAR 0 2
75408: ARRAY
75409: PPUSH
75410: LD_INT 1
75412: PPUSH
75413: CALL_OW 3
75417: PPUSH
75418: CALL_OW 1
75422: ST_TO_ADDR
75423: GO 75672
// begin if not mc_deposits_finder [ i ] then
75425: LD_EXP 96
75429: PUSH
75430: LD_VAR 0 2
75434: ARRAY
75435: NOT
75436: IFFALSE 75488
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75438: LD_ADDR_EXP 96
75442: PUSH
75443: LD_EXP 96
75447: PPUSH
75448: LD_VAR 0 2
75452: PPUSH
75453: LD_VAR 0 3
75457: PUSH
75458: LD_INT 1
75460: ARRAY
75461: PUSH
75462: EMPTY
75463: LIST
75464: PPUSH
75465: CALL_OW 1
75469: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75470: LD_VAR 0 3
75474: PUSH
75475: LD_INT 1
75477: ARRAY
75478: PPUSH
75479: LD_INT 125
75481: PPUSH
75482: CALL_OW 109
// end else
75486: GO 75672
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75488: LD_EXP 96
75492: PUSH
75493: LD_VAR 0 2
75497: ARRAY
75498: PUSH
75499: LD_INT 1
75501: ARRAY
75502: PPUSH
75503: CALL_OW 310
75507: IFFALSE 75530
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75509: LD_EXP 96
75513: PUSH
75514: LD_VAR 0 2
75518: ARRAY
75519: PUSH
75520: LD_INT 1
75522: ARRAY
75523: PPUSH
75524: CALL_OW 122
75528: GO 75672
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75530: LD_EXP 96
75534: PUSH
75535: LD_VAR 0 2
75539: ARRAY
75540: PUSH
75541: LD_INT 1
75543: ARRAY
75544: PPUSH
75545: CALL_OW 314
75549: NOT
75550: PUSH
75551: LD_EXP 96
75555: PUSH
75556: LD_VAR 0 2
75560: ARRAY
75561: PUSH
75562: LD_INT 1
75564: ARRAY
75565: PPUSH
75566: LD_EXP 95
75570: PUSH
75571: LD_VAR 0 2
75575: ARRAY
75576: PUSH
75577: LD_INT 1
75579: ARRAY
75580: PUSH
75581: LD_INT 1
75583: ARRAY
75584: PPUSH
75585: LD_EXP 95
75589: PUSH
75590: LD_VAR 0 2
75594: ARRAY
75595: PUSH
75596: LD_INT 1
75598: ARRAY
75599: PUSH
75600: LD_INT 2
75602: ARRAY
75603: PPUSH
75604: CALL_OW 297
75608: PUSH
75609: LD_INT 6
75611: GREATER
75612: AND
75613: IFFALSE 75672
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75615: LD_EXP 96
75619: PUSH
75620: LD_VAR 0 2
75624: ARRAY
75625: PUSH
75626: LD_INT 1
75628: ARRAY
75629: PPUSH
75630: LD_EXP 95
75634: PUSH
75635: LD_VAR 0 2
75639: ARRAY
75640: PUSH
75641: LD_INT 1
75643: ARRAY
75644: PUSH
75645: LD_INT 1
75647: ARRAY
75648: PPUSH
75649: LD_EXP 95
75653: PUSH
75654: LD_VAR 0 2
75658: ARRAY
75659: PUSH
75660: LD_INT 1
75662: ARRAY
75663: PUSH
75664: LD_INT 2
75666: ARRAY
75667: PPUSH
75668: CALL_OW 111
// end ; end ; end ;
75672: GO 75085
75674: POP
75675: POP
// end ;
75676: LD_VAR 0 1
75680: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75681: LD_INT 0
75683: PPUSH
75684: PPUSH
75685: PPUSH
75686: PPUSH
75687: PPUSH
75688: PPUSH
75689: PPUSH
75690: PPUSH
75691: PPUSH
75692: PPUSH
75693: PPUSH
// if not mc_bases then
75694: LD_EXP 58
75698: NOT
75699: IFFALSE 75703
// exit ;
75701: GO 76427
// for i = 1 to mc_bases do
75703: LD_ADDR_VAR 0 2
75707: PUSH
75708: DOUBLE
75709: LD_INT 1
75711: DEC
75712: ST_TO_ADDR
75713: LD_EXP 58
75717: PUSH
75718: FOR_TO
75719: IFFALSE 76425
// begin if not mc_bases [ i ] then
75721: LD_EXP 58
75725: PUSH
75726: LD_VAR 0 2
75730: ARRAY
75731: NOT
75732: IFFALSE 75736
// continue ;
75734: GO 75718
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75736: LD_ADDR_VAR 0 7
75740: PUSH
75741: LD_EXP 58
75745: PUSH
75746: LD_VAR 0 2
75750: ARRAY
75751: PUSH
75752: LD_INT 1
75754: ARRAY
75755: PPUSH
75756: CALL_OW 248
75760: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75761: LD_VAR 0 7
75765: PUSH
75766: LD_INT 3
75768: EQUAL
75769: PUSH
75770: LD_EXP 77
75774: PUSH
75775: LD_VAR 0 2
75779: ARRAY
75780: PUSH
75781: LD_EXP 80
75785: PUSH
75786: LD_VAR 0 2
75790: ARRAY
75791: UNION
75792: PPUSH
75793: LD_INT 33
75795: PUSH
75796: LD_INT 2
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PPUSH
75803: CALL_OW 72
75807: NOT
75808: OR
75809: IFFALSE 75813
// continue ;
75811: GO 75718
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75813: LD_ADDR_VAR 0 9
75817: PUSH
75818: LD_EXP 58
75822: PUSH
75823: LD_VAR 0 2
75827: ARRAY
75828: PPUSH
75829: LD_INT 30
75831: PUSH
75832: LD_INT 36
75834: PUSH
75835: EMPTY
75836: LIST
75837: LIST
75838: PPUSH
75839: CALL_OW 72
75843: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75844: LD_ADDR_VAR 0 10
75848: PUSH
75849: LD_EXP 77
75853: PUSH
75854: LD_VAR 0 2
75858: ARRAY
75859: PPUSH
75860: LD_INT 34
75862: PUSH
75863: LD_INT 31
75865: PUSH
75866: EMPTY
75867: LIST
75868: LIST
75869: PPUSH
75870: CALL_OW 72
75874: ST_TO_ADDR
// if not cts and not mcts then
75875: LD_VAR 0 9
75879: NOT
75880: PUSH
75881: LD_VAR 0 10
75885: NOT
75886: AND
75887: IFFALSE 75891
// continue ;
75889: GO 75718
// x := cts ;
75891: LD_ADDR_VAR 0 11
75895: PUSH
75896: LD_VAR 0 9
75900: ST_TO_ADDR
// if not x then
75901: LD_VAR 0 11
75905: NOT
75906: IFFALSE 75918
// x := mcts ;
75908: LD_ADDR_VAR 0 11
75912: PUSH
75913: LD_VAR 0 10
75917: ST_TO_ADDR
// if mc_remote_driver [ i ] then
75918: LD_EXP 98
75922: PUSH
75923: LD_VAR 0 2
75927: ARRAY
75928: IFFALSE 76197
// for j in mc_remote_driver [ i ] do
75930: LD_ADDR_VAR 0 3
75934: PUSH
75935: LD_EXP 98
75939: PUSH
75940: LD_VAR 0 2
75944: ARRAY
75945: PUSH
75946: FOR_IN
75947: IFFALSE 76195
// begin if GetClass ( j ) <> 3 then
75949: LD_VAR 0 3
75953: PPUSH
75954: CALL_OW 257
75958: PUSH
75959: LD_INT 3
75961: NONEQUAL
75962: IFFALSE 76015
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75964: LD_ADDR_EXP 98
75968: PUSH
75969: LD_EXP 98
75973: PPUSH
75974: LD_VAR 0 2
75978: PPUSH
75979: LD_EXP 98
75983: PUSH
75984: LD_VAR 0 2
75988: ARRAY
75989: PUSH
75990: LD_VAR 0 3
75994: DIFF
75995: PPUSH
75996: CALL_OW 1
76000: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76001: LD_VAR 0 3
76005: PPUSH
76006: LD_INT 0
76008: PPUSH
76009: CALL_OW 109
// continue ;
76013: GO 75946
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76015: LD_VAR 0 3
76019: PPUSH
76020: CALL_OW 310
76024: NOT
76025: PUSH
76026: LD_VAR 0 3
76030: PPUSH
76031: CALL_OW 310
76035: PPUSH
76036: CALL_OW 266
76040: PUSH
76041: LD_INT 36
76043: NONEQUAL
76044: PUSH
76045: LD_VAR 0 3
76049: PPUSH
76050: CALL 53555 0 1
76054: NOT
76055: AND
76056: OR
76057: IFFALSE 76193
// begin if IsInUnit ( j ) then
76059: LD_VAR 0 3
76063: PPUSH
76064: CALL_OW 310
76068: IFFALSE 76079
// ComExitBuilding ( j ) ;
76070: LD_VAR 0 3
76074: PPUSH
76075: CALL_OW 122
// ct := 0 ;
76079: LD_ADDR_VAR 0 8
76083: PUSH
76084: LD_INT 0
76086: ST_TO_ADDR
// for k in x do
76087: LD_ADDR_VAR 0 4
76091: PUSH
76092: LD_VAR 0 11
76096: PUSH
76097: FOR_IN
76098: IFFALSE 76171
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76100: LD_VAR 0 4
76104: PPUSH
76105: CALL_OW 264
76109: PUSH
76110: LD_INT 31
76112: EQUAL
76113: PUSH
76114: LD_VAR 0 4
76118: PPUSH
76119: CALL_OW 311
76123: NOT
76124: AND
76125: PUSH
76126: LD_VAR 0 4
76130: PPUSH
76131: CALL_OW 266
76135: PUSH
76136: LD_INT 36
76138: EQUAL
76139: PUSH
76140: LD_VAR 0 4
76144: PPUSH
76145: CALL_OW 313
76149: PUSH
76150: LD_INT 3
76152: LESS
76153: AND
76154: OR
76155: IFFALSE 76169
// begin ct := k ;
76157: LD_ADDR_VAR 0 8
76161: PUSH
76162: LD_VAR 0 4
76166: ST_TO_ADDR
// break ;
76167: GO 76171
// end ;
76169: GO 76097
76171: POP
76172: POP
// if ct then
76173: LD_VAR 0 8
76177: IFFALSE 76193
// ComEnterUnit ( j , ct ) ;
76179: LD_VAR 0 3
76183: PPUSH
76184: LD_VAR 0 8
76188: PPUSH
76189: CALL_OW 120
// end ; end ;
76193: GO 75946
76195: POP
76196: POP
// places := 0 ;
76197: LD_ADDR_VAR 0 5
76201: PUSH
76202: LD_INT 0
76204: ST_TO_ADDR
// for j = 1 to x do
76205: LD_ADDR_VAR 0 3
76209: PUSH
76210: DOUBLE
76211: LD_INT 1
76213: DEC
76214: ST_TO_ADDR
76215: LD_VAR 0 11
76219: PUSH
76220: FOR_TO
76221: IFFALSE 76276
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76223: LD_VAR 0 11
76227: PUSH
76228: LD_VAR 0 3
76232: ARRAY
76233: PPUSH
76234: CALL_OW 264
76238: PUSH
76239: LD_INT 31
76241: EQUAL
76242: IFFALSE 76260
// places := places + 1 else
76244: LD_ADDR_VAR 0 5
76248: PUSH
76249: LD_VAR 0 5
76253: PUSH
76254: LD_INT 1
76256: PLUS
76257: ST_TO_ADDR
76258: GO 76274
// places := places + 3 ;
76260: LD_ADDR_VAR 0 5
76264: PUSH
76265: LD_VAR 0 5
76269: PUSH
76270: LD_INT 3
76272: PLUS
76273: ST_TO_ADDR
76274: GO 76220
76276: POP
76277: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76278: LD_ADDR_VAR 0 6
76282: PUSH
76283: LD_EXP 58
76287: PUSH
76288: LD_VAR 0 2
76292: ARRAY
76293: PPUSH
76294: LD_INT 25
76296: PUSH
76297: LD_INT 3
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PPUSH
76304: CALL_OW 72
76308: PUSH
76309: LD_EXP 98
76313: PUSH
76314: LD_VAR 0 2
76318: ARRAY
76319: DIFF
76320: PPUSH
76321: LD_INT 3
76323: PPUSH
76324: CALL 54455 0 2
76328: ST_TO_ADDR
// if not tmp then
76329: LD_VAR 0 6
76333: NOT
76334: IFFALSE 76338
// continue ;
76336: GO 75718
// places := places - mc_remote_driver [ i ] ;
76338: LD_ADDR_VAR 0 5
76342: PUSH
76343: LD_VAR 0 5
76347: PUSH
76348: LD_EXP 98
76352: PUSH
76353: LD_VAR 0 2
76357: ARRAY
76358: MINUS
76359: ST_TO_ADDR
// if places then
76360: LD_VAR 0 5
76364: IFFALSE 76423
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76366: LD_ADDR_EXP 98
76370: PUSH
76371: LD_EXP 98
76375: PPUSH
76376: LD_VAR 0 2
76380: PPUSH
76381: LD_EXP 98
76385: PUSH
76386: LD_VAR 0 2
76390: ARRAY
76391: PUSH
76392: LD_VAR 0 6
76396: PUSH
76397: LD_INT 1
76399: ARRAY
76400: UNION
76401: PPUSH
76402: CALL_OW 1
76406: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76407: LD_VAR 0 6
76411: PUSH
76412: LD_INT 1
76414: ARRAY
76415: PPUSH
76416: LD_INT 126
76418: PPUSH
76419: CALL_OW 109
// end ; end ;
76423: GO 75718
76425: POP
76426: POP
// end ;
76427: LD_VAR 0 1
76431: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76432: LD_INT 0
76434: PPUSH
76435: PPUSH
76436: PPUSH
76437: PPUSH
76438: PPUSH
76439: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76440: LD_VAR 0 1
76444: NOT
76445: PUSH
76446: LD_VAR 0 2
76450: NOT
76451: OR
76452: PUSH
76453: LD_VAR 0 3
76457: NOT
76458: OR
76459: PUSH
76460: LD_VAR 0 4
76464: PUSH
76465: LD_INT 1
76467: PUSH
76468: LD_INT 2
76470: PUSH
76471: LD_INT 3
76473: PUSH
76474: LD_INT 4
76476: PUSH
76477: LD_INT 5
76479: PUSH
76480: LD_INT 8
76482: PUSH
76483: LD_INT 9
76485: PUSH
76486: LD_INT 15
76488: PUSH
76489: LD_INT 16
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: LIST
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: IN
76503: NOT
76504: OR
76505: IFFALSE 76509
// exit ;
76507: GO 77409
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76509: LD_ADDR_VAR 0 2
76513: PUSH
76514: LD_VAR 0 2
76518: PPUSH
76519: LD_INT 21
76521: PUSH
76522: LD_INT 3
76524: PUSH
76525: EMPTY
76526: LIST
76527: LIST
76528: PUSH
76529: LD_INT 24
76531: PUSH
76532: LD_INT 250
76534: PUSH
76535: EMPTY
76536: LIST
76537: LIST
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PPUSH
76543: CALL_OW 72
76547: ST_TO_ADDR
// case class of 1 , 15 :
76548: LD_VAR 0 4
76552: PUSH
76553: LD_INT 1
76555: DOUBLE
76556: EQUAL
76557: IFTRUE 76567
76559: LD_INT 15
76561: DOUBLE
76562: EQUAL
76563: IFTRUE 76567
76565: GO 76652
76567: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76568: LD_ADDR_VAR 0 8
76572: PUSH
76573: LD_VAR 0 2
76577: PPUSH
76578: LD_INT 2
76580: PUSH
76581: LD_INT 30
76583: PUSH
76584: LD_INT 32
76586: PUSH
76587: EMPTY
76588: LIST
76589: LIST
76590: PUSH
76591: LD_INT 30
76593: PUSH
76594: LD_INT 31
76596: PUSH
76597: EMPTY
76598: LIST
76599: LIST
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: LIST
76605: PPUSH
76606: CALL_OW 72
76610: PUSH
76611: LD_VAR 0 2
76615: PPUSH
76616: LD_INT 2
76618: PUSH
76619: LD_INT 30
76621: PUSH
76622: LD_INT 4
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 30
76631: PUSH
76632: LD_INT 5
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: EMPTY
76640: LIST
76641: LIST
76642: LIST
76643: PPUSH
76644: CALL_OW 72
76648: ADD
76649: ST_TO_ADDR
76650: GO 76898
76652: LD_INT 2
76654: DOUBLE
76655: EQUAL
76656: IFTRUE 76666
76658: LD_INT 16
76660: DOUBLE
76661: EQUAL
76662: IFTRUE 76666
76664: GO 76712
76666: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76667: LD_ADDR_VAR 0 8
76671: PUSH
76672: LD_VAR 0 2
76676: PPUSH
76677: LD_INT 2
76679: PUSH
76680: LD_INT 30
76682: PUSH
76683: LD_INT 0
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 30
76692: PUSH
76693: LD_INT 1
76695: PUSH
76696: EMPTY
76697: LIST
76698: LIST
76699: PUSH
76700: EMPTY
76701: LIST
76702: LIST
76703: LIST
76704: PPUSH
76705: CALL_OW 72
76709: ST_TO_ADDR
76710: GO 76898
76712: LD_INT 3
76714: DOUBLE
76715: EQUAL
76716: IFTRUE 76720
76718: GO 76766
76720: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76721: LD_ADDR_VAR 0 8
76725: PUSH
76726: LD_VAR 0 2
76730: PPUSH
76731: LD_INT 2
76733: PUSH
76734: LD_INT 30
76736: PUSH
76737: LD_INT 2
76739: PUSH
76740: EMPTY
76741: LIST
76742: LIST
76743: PUSH
76744: LD_INT 30
76746: PUSH
76747: LD_INT 3
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: LIST
76758: PPUSH
76759: CALL_OW 72
76763: ST_TO_ADDR
76764: GO 76898
76766: LD_INT 4
76768: DOUBLE
76769: EQUAL
76770: IFTRUE 76774
76772: GO 76831
76774: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76775: LD_ADDR_VAR 0 8
76779: PUSH
76780: LD_VAR 0 2
76784: PPUSH
76785: LD_INT 2
76787: PUSH
76788: LD_INT 30
76790: PUSH
76791: LD_INT 6
76793: PUSH
76794: EMPTY
76795: LIST
76796: LIST
76797: PUSH
76798: LD_INT 30
76800: PUSH
76801: LD_INT 7
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: PUSH
76808: LD_INT 30
76810: PUSH
76811: LD_INT 8
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: LIST
76822: LIST
76823: PPUSH
76824: CALL_OW 72
76828: ST_TO_ADDR
76829: GO 76898
76831: LD_INT 5
76833: DOUBLE
76834: EQUAL
76835: IFTRUE 76851
76837: LD_INT 8
76839: DOUBLE
76840: EQUAL
76841: IFTRUE 76851
76843: LD_INT 9
76845: DOUBLE
76846: EQUAL
76847: IFTRUE 76851
76849: GO 76897
76851: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76852: LD_ADDR_VAR 0 8
76856: PUSH
76857: LD_VAR 0 2
76861: PPUSH
76862: LD_INT 2
76864: PUSH
76865: LD_INT 30
76867: PUSH
76868: LD_INT 4
76870: PUSH
76871: EMPTY
76872: LIST
76873: LIST
76874: PUSH
76875: LD_INT 30
76877: PUSH
76878: LD_INT 5
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: LIST
76889: PPUSH
76890: CALL_OW 72
76894: ST_TO_ADDR
76895: GO 76898
76897: POP
// if not tmp then
76898: LD_VAR 0 8
76902: NOT
76903: IFFALSE 76907
// exit ;
76905: GO 77409
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76907: LD_VAR 0 4
76911: PUSH
76912: LD_INT 1
76914: PUSH
76915: LD_INT 15
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: IN
76922: PUSH
76923: LD_EXP 67
76927: PUSH
76928: LD_VAR 0 1
76932: ARRAY
76933: AND
76934: IFFALSE 77090
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76936: LD_ADDR_VAR 0 9
76940: PUSH
76941: LD_EXP 67
76945: PUSH
76946: LD_VAR 0 1
76950: ARRAY
76951: PUSH
76952: LD_INT 1
76954: ARRAY
76955: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76956: LD_VAR 0 9
76960: PUSH
76961: LD_EXP 68
76965: PUSH
76966: LD_VAR 0 1
76970: ARRAY
76971: IN
76972: NOT
76973: IFFALSE 77088
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76975: LD_ADDR_EXP 68
76979: PUSH
76980: LD_EXP 68
76984: PPUSH
76985: LD_VAR 0 1
76989: PUSH
76990: LD_EXP 68
76994: PUSH
76995: LD_VAR 0 1
76999: ARRAY
77000: PUSH
77001: LD_INT 1
77003: PLUS
77004: PUSH
77005: EMPTY
77006: LIST
77007: LIST
77008: PPUSH
77009: LD_VAR 0 9
77013: PPUSH
77014: CALL 20270 0 3
77018: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77019: LD_ADDR_EXP 67
77023: PUSH
77024: LD_EXP 67
77028: PPUSH
77029: LD_VAR 0 1
77033: PPUSH
77034: LD_EXP 67
77038: PUSH
77039: LD_VAR 0 1
77043: ARRAY
77044: PUSH
77045: LD_VAR 0 9
77049: DIFF
77050: PPUSH
77051: CALL_OW 1
77055: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77056: LD_VAR 0 3
77060: PPUSH
77061: LD_EXP 68
77065: PUSH
77066: LD_VAR 0 1
77070: ARRAY
77071: PUSH
77072: LD_EXP 68
77076: PUSH
77077: LD_VAR 0 1
77081: ARRAY
77082: ARRAY
77083: PPUSH
77084: CALL_OW 120
// end ; exit ;
77088: GO 77409
// end ; if tmp > 1 then
77090: LD_VAR 0 8
77094: PUSH
77095: LD_INT 1
77097: GREATER
77098: IFFALSE 77202
// for i = 2 to tmp do
77100: LD_ADDR_VAR 0 6
77104: PUSH
77105: DOUBLE
77106: LD_INT 2
77108: DEC
77109: ST_TO_ADDR
77110: LD_VAR 0 8
77114: PUSH
77115: FOR_TO
77116: IFFALSE 77200
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77118: LD_VAR 0 8
77122: PUSH
77123: LD_VAR 0 6
77127: ARRAY
77128: PPUSH
77129: CALL_OW 461
77133: PUSH
77134: LD_INT 6
77136: EQUAL
77137: IFFALSE 77198
// begin x := tmp [ i ] ;
77139: LD_ADDR_VAR 0 9
77143: PUSH
77144: LD_VAR 0 8
77148: PUSH
77149: LD_VAR 0 6
77153: ARRAY
77154: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77155: LD_ADDR_VAR 0 8
77159: PUSH
77160: LD_VAR 0 8
77164: PPUSH
77165: LD_VAR 0 6
77169: PPUSH
77170: CALL_OW 3
77174: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77175: LD_ADDR_VAR 0 8
77179: PUSH
77180: LD_VAR 0 8
77184: PPUSH
77185: LD_INT 1
77187: PPUSH
77188: LD_VAR 0 9
77192: PPUSH
77193: CALL_OW 2
77197: ST_TO_ADDR
// end ;
77198: GO 77115
77200: POP
77201: POP
// for i in tmp do
77202: LD_ADDR_VAR 0 6
77206: PUSH
77207: LD_VAR 0 8
77211: PUSH
77212: FOR_IN
77213: IFFALSE 77282
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77215: LD_VAR 0 6
77219: PPUSH
77220: CALL_OW 313
77224: PUSH
77225: LD_INT 6
77227: LESS
77228: PUSH
77229: LD_VAR 0 6
77233: PPUSH
77234: CALL_OW 266
77238: PUSH
77239: LD_INT 31
77241: PUSH
77242: LD_INT 32
77244: PUSH
77245: EMPTY
77246: LIST
77247: LIST
77248: IN
77249: NOT
77250: AND
77251: PUSH
77252: LD_VAR 0 6
77256: PPUSH
77257: CALL_OW 313
77261: PUSH
77262: LD_INT 0
77264: EQUAL
77265: OR
77266: IFFALSE 77280
// begin j := i ;
77268: LD_ADDR_VAR 0 7
77272: PUSH
77273: LD_VAR 0 6
77277: ST_TO_ADDR
// break ;
77278: GO 77282
// end ; end ;
77280: GO 77212
77282: POP
77283: POP
// if j then
77284: LD_VAR 0 7
77288: IFFALSE 77306
// ComEnterUnit ( unit , j ) else
77290: LD_VAR 0 3
77294: PPUSH
77295: LD_VAR 0 7
77299: PPUSH
77300: CALL_OW 120
77304: GO 77409
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77306: LD_ADDR_VAR 0 10
77310: PUSH
77311: LD_VAR 0 2
77315: PPUSH
77316: LD_INT 2
77318: PUSH
77319: LD_INT 30
77321: PUSH
77322: LD_INT 0
77324: PUSH
77325: EMPTY
77326: LIST
77327: LIST
77328: PUSH
77329: LD_INT 30
77331: PUSH
77332: LD_INT 1
77334: PUSH
77335: EMPTY
77336: LIST
77337: LIST
77338: PUSH
77339: EMPTY
77340: LIST
77341: LIST
77342: LIST
77343: PPUSH
77344: CALL_OW 72
77348: ST_TO_ADDR
// if depot then
77349: LD_VAR 0 10
77353: IFFALSE 77409
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77355: LD_ADDR_VAR 0 10
77359: PUSH
77360: LD_VAR 0 10
77364: PPUSH
77365: LD_VAR 0 3
77369: PPUSH
77370: CALL_OW 74
77374: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77375: LD_VAR 0 3
77379: PPUSH
77380: LD_VAR 0 10
77384: PPUSH
77385: CALL_OW 296
77389: PUSH
77390: LD_INT 10
77392: GREATER
77393: IFFALSE 77409
// ComStandNearbyBuilding ( unit , depot ) ;
77395: LD_VAR 0 3
77399: PPUSH
77400: LD_VAR 0 10
77404: PPUSH
77405: CALL 14947 0 2
// end ; end ; end ;
77409: LD_VAR 0 5
77413: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77414: LD_INT 0
77416: PPUSH
77417: PPUSH
77418: PPUSH
77419: PPUSH
// if not mc_bases then
77420: LD_EXP 58
77424: NOT
77425: IFFALSE 77429
// exit ;
77427: GO 77668
// for i = 1 to mc_bases do
77429: LD_ADDR_VAR 0 2
77433: PUSH
77434: DOUBLE
77435: LD_INT 1
77437: DEC
77438: ST_TO_ADDR
77439: LD_EXP 58
77443: PUSH
77444: FOR_TO
77445: IFFALSE 77666
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77447: LD_ADDR_VAR 0 4
77451: PUSH
77452: LD_EXP 58
77456: PUSH
77457: LD_VAR 0 2
77461: ARRAY
77462: PPUSH
77463: LD_INT 21
77465: PUSH
77466: LD_INT 1
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PPUSH
77473: CALL_OW 72
77477: PUSH
77478: LD_EXP 87
77482: PUSH
77483: LD_VAR 0 2
77487: ARRAY
77488: UNION
77489: ST_TO_ADDR
// if not tmp then
77490: LD_VAR 0 4
77494: NOT
77495: IFFALSE 77499
// continue ;
77497: GO 77444
// for j in tmp do
77499: LD_ADDR_VAR 0 3
77503: PUSH
77504: LD_VAR 0 4
77508: PUSH
77509: FOR_IN
77510: IFFALSE 77662
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77512: LD_VAR 0 3
77516: PPUSH
77517: CALL_OW 110
77521: NOT
77522: PUSH
77523: LD_VAR 0 3
77527: PPUSH
77528: CALL_OW 314
77532: NOT
77533: AND
77534: PUSH
77535: LD_VAR 0 3
77539: PPUSH
77540: CALL_OW 311
77544: NOT
77545: AND
77546: PUSH
77547: LD_VAR 0 3
77551: PPUSH
77552: CALL_OW 310
77556: NOT
77557: AND
77558: PUSH
77559: LD_VAR 0 3
77563: PUSH
77564: LD_EXP 61
77568: PUSH
77569: LD_VAR 0 2
77573: ARRAY
77574: PUSH
77575: LD_INT 1
77577: ARRAY
77578: IN
77579: NOT
77580: AND
77581: PUSH
77582: LD_VAR 0 3
77586: PUSH
77587: LD_EXP 61
77591: PUSH
77592: LD_VAR 0 2
77596: ARRAY
77597: PUSH
77598: LD_INT 2
77600: ARRAY
77601: IN
77602: NOT
77603: AND
77604: PUSH
77605: LD_VAR 0 3
77609: PUSH
77610: LD_EXP 70
77614: PUSH
77615: LD_VAR 0 2
77619: ARRAY
77620: IN
77621: NOT
77622: AND
77623: IFFALSE 77660
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77625: LD_VAR 0 2
77629: PPUSH
77630: LD_EXP 58
77634: PUSH
77635: LD_VAR 0 2
77639: ARRAY
77640: PPUSH
77641: LD_VAR 0 3
77645: PPUSH
77646: LD_VAR 0 3
77650: PPUSH
77651: CALL_OW 257
77655: PPUSH
77656: CALL 76432 0 4
// end ;
77660: GO 77509
77662: POP
77663: POP
// end ;
77664: GO 77444
77666: POP
77667: POP
// end ;
77668: LD_VAR 0 1
77672: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77673: LD_INT 0
77675: PPUSH
77676: PPUSH
77677: PPUSH
77678: PPUSH
77679: PPUSH
77680: PPUSH
// if not mc_bases [ base ] then
77681: LD_EXP 58
77685: PUSH
77686: LD_VAR 0 1
77690: ARRAY
77691: NOT
77692: IFFALSE 77696
// exit ;
77694: GO 77878
// tmp := [ ] ;
77696: LD_ADDR_VAR 0 6
77700: PUSH
77701: EMPTY
77702: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77703: LD_ADDR_VAR 0 7
77707: PUSH
77708: LD_VAR 0 3
77712: PPUSH
77713: LD_INT 0
77715: PPUSH
77716: CALL_OW 517
77720: ST_TO_ADDR
// if not list then
77721: LD_VAR 0 7
77725: NOT
77726: IFFALSE 77730
// exit ;
77728: GO 77878
// for i = 1 to amount do
77730: LD_ADDR_VAR 0 5
77734: PUSH
77735: DOUBLE
77736: LD_INT 1
77738: DEC
77739: ST_TO_ADDR
77740: LD_VAR 0 2
77744: PUSH
77745: FOR_TO
77746: IFFALSE 77826
// begin x := rand ( 1 , list [ 1 ] ) ;
77748: LD_ADDR_VAR 0 8
77752: PUSH
77753: LD_INT 1
77755: PPUSH
77756: LD_VAR 0 7
77760: PUSH
77761: LD_INT 1
77763: ARRAY
77764: PPUSH
77765: CALL_OW 12
77769: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77770: LD_ADDR_VAR 0 6
77774: PUSH
77775: LD_VAR 0 6
77779: PPUSH
77780: LD_VAR 0 5
77784: PPUSH
77785: LD_VAR 0 7
77789: PUSH
77790: LD_INT 1
77792: ARRAY
77793: PUSH
77794: LD_VAR 0 8
77798: ARRAY
77799: PUSH
77800: LD_VAR 0 7
77804: PUSH
77805: LD_INT 2
77807: ARRAY
77808: PUSH
77809: LD_VAR 0 8
77813: ARRAY
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PPUSH
77819: CALL_OW 1
77823: ST_TO_ADDR
// end ;
77824: GO 77745
77826: POP
77827: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77828: LD_ADDR_EXP 71
77832: PUSH
77833: LD_EXP 71
77837: PPUSH
77838: LD_VAR 0 1
77842: PPUSH
77843: LD_VAR 0 6
77847: PPUSH
77848: CALL_OW 1
77852: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77853: LD_ADDR_EXP 73
77857: PUSH
77858: LD_EXP 73
77862: PPUSH
77863: LD_VAR 0 1
77867: PPUSH
77868: LD_VAR 0 3
77872: PPUSH
77873: CALL_OW 1
77877: ST_TO_ADDR
// end ;
77878: LD_VAR 0 4
77882: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77883: LD_INT 0
77885: PPUSH
// if not mc_bases [ base ] then
77886: LD_EXP 58
77890: PUSH
77891: LD_VAR 0 1
77895: ARRAY
77896: NOT
77897: IFFALSE 77901
// exit ;
77899: GO 77926
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77901: LD_ADDR_EXP 63
77905: PUSH
77906: LD_EXP 63
77910: PPUSH
77911: LD_VAR 0 1
77915: PPUSH
77916: LD_VAR 0 2
77920: PPUSH
77921: CALL_OW 1
77925: ST_TO_ADDR
// end ;
77926: LD_VAR 0 3
77930: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77931: LD_INT 0
77933: PPUSH
// if not mc_bases [ base ] then
77934: LD_EXP 58
77938: PUSH
77939: LD_VAR 0 1
77943: ARRAY
77944: NOT
77945: IFFALSE 77949
// exit ;
77947: GO 77986
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77949: LD_ADDR_EXP 63
77953: PUSH
77954: LD_EXP 63
77958: PPUSH
77959: LD_VAR 0 1
77963: PPUSH
77964: LD_EXP 63
77968: PUSH
77969: LD_VAR 0 1
77973: ARRAY
77974: PUSH
77975: LD_VAR 0 2
77979: UNION
77980: PPUSH
77981: CALL_OW 1
77985: ST_TO_ADDR
// end ;
77986: LD_VAR 0 3
77990: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77991: LD_INT 0
77993: PPUSH
// if not mc_bases [ base ] then
77994: LD_EXP 58
77998: PUSH
77999: LD_VAR 0 1
78003: ARRAY
78004: NOT
78005: IFFALSE 78009
// exit ;
78007: GO 78034
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78009: LD_ADDR_EXP 79
78013: PUSH
78014: LD_EXP 79
78018: PPUSH
78019: LD_VAR 0 1
78023: PPUSH
78024: LD_VAR 0 2
78028: PPUSH
78029: CALL_OW 1
78033: ST_TO_ADDR
// end ;
78034: LD_VAR 0 3
78038: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
78039: LD_INT 0
78041: PPUSH
// if not mc_bases [ base ] then
78042: LD_EXP 58
78046: PUSH
78047: LD_VAR 0 1
78051: ARRAY
78052: NOT
78053: IFFALSE 78057
// exit ;
78055: GO 78094
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
78057: LD_ADDR_EXP 79
78061: PUSH
78062: LD_EXP 79
78066: PPUSH
78067: LD_VAR 0 1
78071: PPUSH
78072: LD_EXP 79
78076: PUSH
78077: LD_VAR 0 1
78081: ARRAY
78082: PUSH
78083: LD_VAR 0 2
78087: UNION
78088: PPUSH
78089: CALL_OW 1
78093: ST_TO_ADDR
// end ;
78094: LD_VAR 0 3
78098: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78099: LD_INT 0
78101: PPUSH
// if not mc_bases [ base ] then
78102: LD_EXP 58
78106: PUSH
78107: LD_VAR 0 1
78111: ARRAY
78112: NOT
78113: IFFALSE 78117
// exit ;
78115: GO 78229
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78117: LD_ADDR_EXP 80
78121: PUSH
78122: LD_EXP 80
78126: PPUSH
78127: LD_VAR 0 1
78131: PPUSH
78132: LD_VAR 0 2
78136: PPUSH
78137: CALL_OW 1
78141: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78142: LD_ADDR_EXP 69
78146: PUSH
78147: LD_EXP 69
78151: PPUSH
78152: LD_VAR 0 1
78156: PPUSH
78157: LD_VAR 0 2
78161: PUSH
78162: LD_INT 0
78164: PLUS
78165: PPUSH
78166: CALL_OW 1
78170: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
78171: LD_ADDR_EXP 77
78175: PUSH
78176: LD_EXP 77
78180: PPUSH
78181: LD_VAR 0 1
78185: PPUSH
78186: LD_EXP 77
78190: PUSH
78191: LD_VAR 0 1
78195: ARRAY
78196: PUSH
78197: LD_EXP 80
78201: PUSH
78202: LD_VAR 0 1
78206: ARRAY
78207: PPUSH
78208: LD_INT 21
78210: PUSH
78211: LD_INT 2
78213: PUSH
78214: EMPTY
78215: LIST
78216: LIST
78217: PPUSH
78218: CALL_OW 72
78222: UNION
78223: PPUSH
78224: CALL_OW 1
78228: ST_TO_ADDR
// end ;
78229: LD_VAR 0 3
78233: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78234: LD_INT 0
78236: PPUSH
// if not mc_bases [ base ] then
78237: LD_EXP 58
78241: PUSH
78242: LD_VAR 0 1
78246: ARRAY
78247: NOT
78248: IFFALSE 78252
// exit ;
78250: GO 78277
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78252: LD_ADDR_EXP 69
78256: PUSH
78257: LD_EXP 69
78261: PPUSH
78262: LD_VAR 0 1
78266: PPUSH
78267: LD_VAR 0 2
78271: PPUSH
78272: CALL_OW 1
78276: ST_TO_ADDR
// end ;
78277: LD_VAR 0 3
78281: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78282: LD_INT 0
78284: PPUSH
78285: PPUSH
78286: PPUSH
78287: PPUSH
// if not mc_bases [ base ] then
78288: LD_EXP 58
78292: PUSH
78293: LD_VAR 0 1
78297: ARRAY
78298: NOT
78299: IFFALSE 78303
// exit ;
78301: GO 78368
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78303: LD_ADDR_EXP 78
78307: PUSH
78308: LD_EXP 78
78312: PPUSH
78313: LD_VAR 0 1
78317: PUSH
78318: LD_EXP 78
78322: PUSH
78323: LD_VAR 0 1
78327: ARRAY
78328: PUSH
78329: LD_INT 1
78331: PLUS
78332: PUSH
78333: EMPTY
78334: LIST
78335: LIST
78336: PPUSH
78337: LD_VAR 0 1
78341: PUSH
78342: LD_VAR 0 2
78346: PUSH
78347: LD_VAR 0 3
78351: PUSH
78352: LD_VAR 0 4
78356: PUSH
78357: EMPTY
78358: LIST
78359: LIST
78360: LIST
78361: LIST
78362: PPUSH
78363: CALL 20270 0 3
78367: ST_TO_ADDR
// end ;
78368: LD_VAR 0 5
78372: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78373: LD_INT 0
78375: PPUSH
// if not mc_bases [ base ] then
78376: LD_EXP 58
78380: PUSH
78381: LD_VAR 0 1
78385: ARRAY
78386: NOT
78387: IFFALSE 78391
// exit ;
78389: GO 78416
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78391: LD_ADDR_EXP 95
78395: PUSH
78396: LD_EXP 95
78400: PPUSH
78401: LD_VAR 0 1
78405: PPUSH
78406: LD_VAR 0 2
78410: PPUSH
78411: CALL_OW 1
78415: ST_TO_ADDR
// end ;
78416: LD_VAR 0 3
78420: RET
// export function MC_GetMinesField ( base ) ; begin
78421: LD_INT 0
78423: PPUSH
// result := mc_mines [ base ] ;
78424: LD_ADDR_VAR 0 2
78428: PUSH
78429: LD_EXP 71
78433: PUSH
78434: LD_VAR 0 1
78438: ARRAY
78439: ST_TO_ADDR
// end ;
78440: LD_VAR 0 2
78444: RET
// export function MC_GetProduceList ( base ) ; begin
78445: LD_INT 0
78447: PPUSH
// result := mc_produce [ base ] ;
78448: LD_ADDR_VAR 0 2
78452: PUSH
78453: LD_EXP 79
78457: PUSH
78458: LD_VAR 0 1
78462: ARRAY
78463: ST_TO_ADDR
// end ;
78464: LD_VAR 0 2
78468: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78469: LD_INT 0
78471: PPUSH
78472: PPUSH
// if not mc_bases then
78473: LD_EXP 58
78477: NOT
78478: IFFALSE 78482
// exit ;
78480: GO 78547
// if mc_bases [ base ] then
78482: LD_EXP 58
78486: PUSH
78487: LD_VAR 0 1
78491: ARRAY
78492: IFFALSE 78547
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78494: LD_ADDR_VAR 0 3
78498: PUSH
78499: LD_EXP 58
78503: PUSH
78504: LD_VAR 0 1
78508: ARRAY
78509: PPUSH
78510: LD_INT 30
78512: PUSH
78513: LD_VAR 0 2
78517: PUSH
78518: EMPTY
78519: LIST
78520: LIST
78521: PPUSH
78522: CALL_OW 72
78526: ST_TO_ADDR
// if result then
78527: LD_VAR 0 3
78531: IFFALSE 78547
// result := result [ 1 ] ;
78533: LD_ADDR_VAR 0 3
78537: PUSH
78538: LD_VAR 0 3
78542: PUSH
78543: LD_INT 1
78545: ARRAY
78546: ST_TO_ADDR
// end ; end ;
78547: LD_VAR 0 3
78551: RET
// export function MC_SetTame ( base , area ) ; begin
78552: LD_INT 0
78554: PPUSH
// if not mc_bases or not base then
78555: LD_EXP 58
78559: NOT
78560: PUSH
78561: LD_VAR 0 1
78565: NOT
78566: OR
78567: IFFALSE 78571
// exit ;
78569: GO 78596
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78571: LD_ADDR_EXP 86
78575: PUSH
78576: LD_EXP 86
78580: PPUSH
78581: LD_VAR 0 1
78585: PPUSH
78586: LD_VAR 0 2
78590: PPUSH
78591: CALL_OW 1
78595: ST_TO_ADDR
// end ;
78596: LD_VAR 0 3
78600: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78601: LD_INT 0
78603: PPUSH
78604: PPUSH
// if not mc_bases or not base then
78605: LD_EXP 58
78609: NOT
78610: PUSH
78611: LD_VAR 0 1
78615: NOT
78616: OR
78617: IFFALSE 78621
// exit ;
78619: GO 78723
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78621: LD_ADDR_VAR 0 4
78625: PUSH
78626: LD_EXP 58
78630: PUSH
78631: LD_VAR 0 1
78635: ARRAY
78636: PPUSH
78637: LD_INT 30
78639: PUSH
78640: LD_VAR 0 2
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PPUSH
78649: CALL_OW 72
78653: ST_TO_ADDR
// if not tmp then
78654: LD_VAR 0 4
78658: NOT
78659: IFFALSE 78663
// exit ;
78661: GO 78723
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78663: LD_ADDR_EXP 90
78667: PUSH
78668: LD_EXP 90
78672: PPUSH
78673: LD_VAR 0 1
78677: PPUSH
78678: LD_EXP 90
78682: PUSH
78683: LD_VAR 0 1
78687: ARRAY
78688: PPUSH
78689: LD_EXP 90
78693: PUSH
78694: LD_VAR 0 1
78698: ARRAY
78699: PUSH
78700: LD_INT 1
78702: PLUS
78703: PPUSH
78704: LD_VAR 0 4
78708: PUSH
78709: LD_INT 1
78711: ARRAY
78712: PPUSH
78713: CALL_OW 2
78717: PPUSH
78718: CALL_OW 1
78722: ST_TO_ADDR
// end ;
78723: LD_VAR 0 3
78727: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78728: LD_INT 0
78730: PPUSH
78731: PPUSH
// if not mc_bases or not base or not kinds then
78732: LD_EXP 58
78736: NOT
78737: PUSH
78738: LD_VAR 0 1
78742: NOT
78743: OR
78744: PUSH
78745: LD_VAR 0 2
78749: NOT
78750: OR
78751: IFFALSE 78755
// exit ;
78753: GO 78816
// for i in kinds do
78755: LD_ADDR_VAR 0 4
78759: PUSH
78760: LD_VAR 0 2
78764: PUSH
78765: FOR_IN
78766: IFFALSE 78814
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78768: LD_ADDR_EXP 92
78772: PUSH
78773: LD_EXP 92
78777: PPUSH
78778: LD_VAR 0 1
78782: PUSH
78783: LD_EXP 92
78787: PUSH
78788: LD_VAR 0 1
78792: ARRAY
78793: PUSH
78794: LD_INT 1
78796: PLUS
78797: PUSH
78798: EMPTY
78799: LIST
78800: LIST
78801: PPUSH
78802: LD_VAR 0 4
78806: PPUSH
78807: CALL 20270 0 3
78811: ST_TO_ADDR
78812: GO 78765
78814: POP
78815: POP
// end ;
78816: LD_VAR 0 3
78820: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78821: LD_INT 0
78823: PPUSH
// if not mc_bases or not base or not areas then
78824: LD_EXP 58
78828: NOT
78829: PUSH
78830: LD_VAR 0 1
78834: NOT
78835: OR
78836: PUSH
78837: LD_VAR 0 2
78841: NOT
78842: OR
78843: IFFALSE 78847
// exit ;
78845: GO 78872
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78847: LD_ADDR_EXP 76
78851: PUSH
78852: LD_EXP 76
78856: PPUSH
78857: LD_VAR 0 1
78861: PPUSH
78862: LD_VAR 0 2
78866: PPUSH
78867: CALL_OW 1
78871: ST_TO_ADDR
// end ;
78872: LD_VAR 0 3
78876: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78877: LD_INT 0
78879: PPUSH
// if not mc_bases or not base or not teleports_exit then
78880: LD_EXP 58
78884: NOT
78885: PUSH
78886: LD_VAR 0 1
78890: NOT
78891: OR
78892: PUSH
78893: LD_VAR 0 2
78897: NOT
78898: OR
78899: IFFALSE 78903
// exit ;
78901: GO 78928
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78903: LD_ADDR_EXP 93
78907: PUSH
78908: LD_EXP 93
78912: PPUSH
78913: LD_VAR 0 1
78917: PPUSH
78918: LD_VAR 0 2
78922: PPUSH
78923: CALL_OW 1
78927: ST_TO_ADDR
// end ;
78928: LD_VAR 0 3
78932: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78933: LD_INT 0
78935: PPUSH
78936: PPUSH
78937: PPUSH
// if not mc_bases or not base or not ext_list then
78938: LD_EXP 58
78942: NOT
78943: PUSH
78944: LD_VAR 0 1
78948: NOT
78949: OR
78950: PUSH
78951: LD_VAR 0 5
78955: NOT
78956: OR
78957: IFFALSE 78961
// exit ;
78959: GO 79134
// tmp := GetFacExtXYD ( x , y , d ) ;
78961: LD_ADDR_VAR 0 8
78965: PUSH
78966: LD_VAR 0 2
78970: PPUSH
78971: LD_VAR 0 3
78975: PPUSH
78976: LD_VAR 0 4
78980: PPUSH
78981: CALL 53585 0 3
78985: ST_TO_ADDR
// if not tmp then
78986: LD_VAR 0 8
78990: NOT
78991: IFFALSE 78995
// exit ;
78993: GO 79134
// for i in tmp do
78995: LD_ADDR_VAR 0 7
78999: PUSH
79000: LD_VAR 0 8
79004: PUSH
79005: FOR_IN
79006: IFFALSE 79132
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79008: LD_ADDR_EXP 63
79012: PUSH
79013: LD_EXP 63
79017: PPUSH
79018: LD_VAR 0 1
79022: PPUSH
79023: LD_EXP 63
79027: PUSH
79028: LD_VAR 0 1
79032: ARRAY
79033: PPUSH
79034: LD_EXP 63
79038: PUSH
79039: LD_VAR 0 1
79043: ARRAY
79044: PUSH
79045: LD_INT 1
79047: PLUS
79048: PPUSH
79049: LD_VAR 0 5
79053: PUSH
79054: LD_INT 1
79056: ARRAY
79057: PUSH
79058: LD_VAR 0 7
79062: PUSH
79063: LD_INT 1
79065: ARRAY
79066: PUSH
79067: LD_VAR 0 7
79071: PUSH
79072: LD_INT 2
79074: ARRAY
79075: PUSH
79076: LD_VAR 0 7
79080: PUSH
79081: LD_INT 3
79083: ARRAY
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: PPUSH
79091: CALL_OW 2
79095: PPUSH
79096: CALL_OW 1
79100: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79101: LD_ADDR_VAR 0 5
79105: PUSH
79106: LD_VAR 0 5
79110: PPUSH
79111: LD_INT 1
79113: PPUSH
79114: CALL_OW 3
79118: ST_TO_ADDR
// if not ext_list then
79119: LD_VAR 0 5
79123: NOT
79124: IFFALSE 79130
// exit ;
79126: POP
79127: POP
79128: GO 79134
// end ;
79130: GO 79005
79132: POP
79133: POP
// end ;
79134: LD_VAR 0 6
79138: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79139: LD_INT 0
79141: PPUSH
// if not mc_bases or not base or not weapon_list then
79142: LD_EXP 58
79146: NOT
79147: PUSH
79148: LD_VAR 0 1
79152: NOT
79153: OR
79154: PUSH
79155: LD_VAR 0 2
79159: NOT
79160: OR
79161: IFFALSE 79165
// exit ;
79163: GO 79190
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79165: LD_ADDR_EXP 97
79169: PUSH
79170: LD_EXP 97
79174: PPUSH
79175: LD_VAR 0 1
79179: PPUSH
79180: LD_VAR 0 2
79184: PPUSH
79185: CALL_OW 1
79189: ST_TO_ADDR
// end ;
79190: LD_VAR 0 3
79194: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79195: LD_INT 0
79197: PPUSH
// if not mc_bases or not base or not tech_list then
79198: LD_EXP 58
79202: NOT
79203: PUSH
79204: LD_VAR 0 1
79208: NOT
79209: OR
79210: PUSH
79211: LD_VAR 0 2
79215: NOT
79216: OR
79217: IFFALSE 79221
// exit ;
79219: GO 79246
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79221: LD_ADDR_EXP 85
79225: PUSH
79226: LD_EXP 85
79230: PPUSH
79231: LD_VAR 0 1
79235: PPUSH
79236: LD_VAR 0 2
79240: PPUSH
79241: CALL_OW 1
79245: ST_TO_ADDR
// end ;
79246: LD_VAR 0 3
79250: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79251: LD_INT 0
79253: PPUSH
// if not mc_bases or not parking_area or not base then
79254: LD_EXP 58
79258: NOT
79259: PUSH
79260: LD_VAR 0 2
79264: NOT
79265: OR
79266: PUSH
79267: LD_VAR 0 1
79271: NOT
79272: OR
79273: IFFALSE 79277
// exit ;
79275: GO 79302
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79277: LD_ADDR_EXP 82
79281: PUSH
79282: LD_EXP 82
79286: PPUSH
79287: LD_VAR 0 1
79291: PPUSH
79292: LD_VAR 0 2
79296: PPUSH
79297: CALL_OW 1
79301: ST_TO_ADDR
// end ;
79302: LD_VAR 0 3
79306: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79307: LD_INT 0
79309: PPUSH
// if not mc_bases or not base or not scan_area then
79310: LD_EXP 58
79314: NOT
79315: PUSH
79316: LD_VAR 0 1
79320: NOT
79321: OR
79322: PUSH
79323: LD_VAR 0 2
79327: NOT
79328: OR
79329: IFFALSE 79333
// exit ;
79331: GO 79358
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79333: LD_ADDR_EXP 83
79337: PUSH
79338: LD_EXP 83
79342: PPUSH
79343: LD_VAR 0 1
79347: PPUSH
79348: LD_VAR 0 2
79352: PPUSH
79353: CALL_OW 1
79357: ST_TO_ADDR
// end ;
79358: LD_VAR 0 3
79362: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79363: LD_INT 0
79365: PPUSH
79366: PPUSH
// if not mc_bases or not base then
79367: LD_EXP 58
79371: NOT
79372: PUSH
79373: LD_VAR 0 1
79377: NOT
79378: OR
79379: IFFALSE 79383
// exit ;
79381: GO 79447
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79383: LD_ADDR_VAR 0 3
79387: PUSH
79388: LD_INT 1
79390: PUSH
79391: LD_INT 2
79393: PUSH
79394: LD_INT 3
79396: PUSH
79397: LD_INT 4
79399: PUSH
79400: LD_INT 11
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79410: LD_ADDR_EXP 85
79414: PUSH
79415: LD_EXP 85
79419: PPUSH
79420: LD_VAR 0 1
79424: PPUSH
79425: LD_EXP 85
79429: PUSH
79430: LD_VAR 0 1
79434: ARRAY
79435: PUSH
79436: LD_VAR 0 3
79440: DIFF
79441: PPUSH
79442: CALL_OW 1
79446: ST_TO_ADDR
// end ;
79447: LD_VAR 0 2
79451: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79452: LD_INT 0
79454: PPUSH
// result := mc_vehicles [ base ] ;
79455: LD_ADDR_VAR 0 3
79459: PUSH
79460: LD_EXP 77
79464: PUSH
79465: LD_VAR 0 1
79469: ARRAY
79470: ST_TO_ADDR
// if onlyCombat then
79471: LD_VAR 0 2
79475: IFFALSE 79618
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] ] ) ;
79477: LD_ADDR_VAR 0 3
79481: PUSH
79482: LD_VAR 0 3
79486: PUSH
79487: LD_VAR 0 3
79491: PPUSH
79492: LD_INT 2
79494: PUSH
79495: LD_INT 34
79497: PUSH
79498: LD_INT 12
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PUSH
79505: LD_INT 34
79507: PUSH
79508: LD_INT 51
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: PUSH
79515: LD_INT 34
79517: PUSH
79518: LD_EXP 102
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 34
79529: PUSH
79530: LD_INT 32
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 34
79539: PUSH
79540: LD_INT 13
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 34
79549: PUSH
79550: LD_INT 52
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 34
79559: PUSH
79560: LD_INT 14
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 34
79569: PUSH
79570: LD_INT 53
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 34
79579: PUSH
79580: LD_EXP 101
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 34
79591: PUSH
79592: LD_INT 31
79594: PUSH
79595: EMPTY
79596: LIST
79597: LIST
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: LIST
79603: LIST
79604: LIST
79605: LIST
79606: LIST
79607: LIST
79608: LIST
79609: LIST
79610: LIST
79611: PPUSH
79612: CALL_OW 72
79616: DIFF
79617: ST_TO_ADDR
// end ; end_of_file
79618: LD_VAR 0 3
79622: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79623: LD_INT 0
79625: PPUSH
79626: PPUSH
79627: PPUSH
// if not mc_bases or not skirmish then
79628: LD_EXP 58
79632: NOT
79633: PUSH
79634: LD_EXP 56
79638: NOT
79639: OR
79640: IFFALSE 79644
// exit ;
79642: GO 79809
// for i = 1 to mc_bases do
79644: LD_ADDR_VAR 0 4
79648: PUSH
79649: DOUBLE
79650: LD_INT 1
79652: DEC
79653: ST_TO_ADDR
79654: LD_EXP 58
79658: PUSH
79659: FOR_TO
79660: IFFALSE 79807
// begin if sci in mc_bases [ i ] then
79662: LD_VAR 0 2
79666: PUSH
79667: LD_EXP 58
79671: PUSH
79672: LD_VAR 0 4
79676: ARRAY
79677: IN
79678: IFFALSE 79805
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79680: LD_ADDR_EXP 87
79684: PUSH
79685: LD_EXP 87
79689: PPUSH
79690: LD_VAR 0 4
79694: PUSH
79695: LD_EXP 87
79699: PUSH
79700: LD_VAR 0 4
79704: ARRAY
79705: PUSH
79706: LD_INT 1
79708: PLUS
79709: PUSH
79710: EMPTY
79711: LIST
79712: LIST
79713: PPUSH
79714: LD_VAR 0 1
79718: PPUSH
79719: CALL 20270 0 3
79723: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79724: LD_ADDR_VAR 0 5
79728: PUSH
79729: LD_EXP 58
79733: PUSH
79734: LD_VAR 0 4
79738: ARRAY
79739: PPUSH
79740: LD_INT 2
79742: PUSH
79743: LD_INT 30
79745: PUSH
79746: LD_INT 0
79748: PUSH
79749: EMPTY
79750: LIST
79751: LIST
79752: PUSH
79753: LD_INT 30
79755: PUSH
79756: LD_INT 1
79758: PUSH
79759: EMPTY
79760: LIST
79761: LIST
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: LIST
79767: PPUSH
79768: CALL_OW 72
79772: PPUSH
79773: LD_VAR 0 1
79777: PPUSH
79778: CALL_OW 74
79782: ST_TO_ADDR
// if tmp then
79783: LD_VAR 0 5
79787: IFFALSE 79803
// ComStandNearbyBuilding ( ape , tmp ) ;
79789: LD_VAR 0 1
79793: PPUSH
79794: LD_VAR 0 5
79798: PPUSH
79799: CALL 14947 0 2
// break ;
79803: GO 79807
// end ; end ;
79805: GO 79659
79807: POP
79808: POP
// end ;
79809: LD_VAR 0 3
79813: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79814: LD_INT 0
79816: PPUSH
79817: PPUSH
79818: PPUSH
// if not mc_bases or not skirmish then
79819: LD_EXP 58
79823: NOT
79824: PUSH
79825: LD_EXP 56
79829: NOT
79830: OR
79831: IFFALSE 79835
// exit ;
79833: GO 79924
// for i = 1 to mc_bases do
79835: LD_ADDR_VAR 0 4
79839: PUSH
79840: DOUBLE
79841: LD_INT 1
79843: DEC
79844: ST_TO_ADDR
79845: LD_EXP 58
79849: PUSH
79850: FOR_TO
79851: IFFALSE 79922
// begin if building in mc_busy_turret_list [ i ] then
79853: LD_VAR 0 1
79857: PUSH
79858: LD_EXP 68
79862: PUSH
79863: LD_VAR 0 4
79867: ARRAY
79868: IN
79869: IFFALSE 79920
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79871: LD_ADDR_VAR 0 5
79875: PUSH
79876: LD_EXP 68
79880: PUSH
79881: LD_VAR 0 4
79885: ARRAY
79886: PUSH
79887: LD_VAR 0 1
79891: DIFF
79892: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79893: LD_ADDR_EXP 68
79897: PUSH
79898: LD_EXP 68
79902: PPUSH
79903: LD_VAR 0 4
79907: PPUSH
79908: LD_VAR 0 5
79912: PPUSH
79913: CALL_OW 1
79917: ST_TO_ADDR
// break ;
79918: GO 79922
// end ; end ;
79920: GO 79850
79922: POP
79923: POP
// end ;
79924: LD_VAR 0 3
79928: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79929: LD_INT 0
79931: PPUSH
79932: PPUSH
79933: PPUSH
// if not mc_bases or not skirmish then
79934: LD_EXP 58
79938: NOT
79939: PUSH
79940: LD_EXP 56
79944: NOT
79945: OR
79946: IFFALSE 79950
// exit ;
79948: GO 80149
// for i = 1 to mc_bases do
79950: LD_ADDR_VAR 0 5
79954: PUSH
79955: DOUBLE
79956: LD_INT 1
79958: DEC
79959: ST_TO_ADDR
79960: LD_EXP 58
79964: PUSH
79965: FOR_TO
79966: IFFALSE 80147
// if building in mc_bases [ i ] then
79968: LD_VAR 0 1
79972: PUSH
79973: LD_EXP 58
79977: PUSH
79978: LD_VAR 0 5
79982: ARRAY
79983: IN
79984: IFFALSE 80145
// begin tmp := mc_bases [ i ] diff building ;
79986: LD_ADDR_VAR 0 6
79990: PUSH
79991: LD_EXP 58
79995: PUSH
79996: LD_VAR 0 5
80000: ARRAY
80001: PUSH
80002: LD_VAR 0 1
80006: DIFF
80007: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80008: LD_ADDR_EXP 58
80012: PUSH
80013: LD_EXP 58
80017: PPUSH
80018: LD_VAR 0 5
80022: PPUSH
80023: LD_VAR 0 6
80027: PPUSH
80028: CALL_OW 1
80032: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80033: LD_VAR 0 1
80037: PUSH
80038: LD_EXP 66
80042: PUSH
80043: LD_VAR 0 5
80047: ARRAY
80048: IN
80049: IFFALSE 80088
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80051: LD_ADDR_EXP 66
80055: PUSH
80056: LD_EXP 66
80060: PPUSH
80061: LD_VAR 0 5
80065: PPUSH
80066: LD_EXP 66
80070: PUSH
80071: LD_VAR 0 5
80075: ARRAY
80076: PUSH
80077: LD_VAR 0 1
80081: DIFF
80082: PPUSH
80083: CALL_OW 1
80087: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80088: LD_VAR 0 1
80092: PUSH
80093: LD_EXP 67
80097: PUSH
80098: LD_VAR 0 5
80102: ARRAY
80103: IN
80104: IFFALSE 80143
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80106: LD_ADDR_EXP 67
80110: PUSH
80111: LD_EXP 67
80115: PPUSH
80116: LD_VAR 0 5
80120: PPUSH
80121: LD_EXP 67
80125: PUSH
80126: LD_VAR 0 5
80130: ARRAY
80131: PUSH
80132: LD_VAR 0 1
80136: DIFF
80137: PPUSH
80138: CALL_OW 1
80142: ST_TO_ADDR
// break ;
80143: GO 80147
// end ;
80145: GO 79965
80147: POP
80148: POP
// end ;
80149: LD_VAR 0 4
80153: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80154: LD_INT 0
80156: PPUSH
80157: PPUSH
80158: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80159: LD_EXP 58
80163: NOT
80164: PUSH
80165: LD_EXP 56
80169: NOT
80170: OR
80171: PUSH
80172: LD_VAR 0 3
80176: PUSH
80177: LD_EXP 84
80181: IN
80182: NOT
80183: OR
80184: IFFALSE 80188
// exit ;
80186: GO 80311
// for i = 1 to mc_vehicles do
80188: LD_ADDR_VAR 0 6
80192: PUSH
80193: DOUBLE
80194: LD_INT 1
80196: DEC
80197: ST_TO_ADDR
80198: LD_EXP 77
80202: PUSH
80203: FOR_TO
80204: IFFALSE 80309
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80206: LD_VAR 0 2
80210: PUSH
80211: LD_EXP 77
80215: PUSH
80216: LD_VAR 0 6
80220: ARRAY
80221: IN
80222: PUSH
80223: LD_VAR 0 1
80227: PUSH
80228: LD_EXP 77
80232: PUSH
80233: LD_VAR 0 6
80237: ARRAY
80238: IN
80239: OR
80240: IFFALSE 80307
// begin tmp := mc_vehicles [ i ] diff old ;
80242: LD_ADDR_VAR 0 7
80246: PUSH
80247: LD_EXP 77
80251: PUSH
80252: LD_VAR 0 6
80256: ARRAY
80257: PUSH
80258: LD_VAR 0 2
80262: DIFF
80263: ST_TO_ADDR
// tmp := tmp diff new ;
80264: LD_ADDR_VAR 0 7
80268: PUSH
80269: LD_VAR 0 7
80273: PUSH
80274: LD_VAR 0 1
80278: DIFF
80279: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80280: LD_ADDR_EXP 77
80284: PUSH
80285: LD_EXP 77
80289: PPUSH
80290: LD_VAR 0 6
80294: PPUSH
80295: LD_VAR 0 7
80299: PPUSH
80300: CALL_OW 1
80304: ST_TO_ADDR
// break ;
80305: GO 80309
// end ;
80307: GO 80203
80309: POP
80310: POP
// end ;
80311: LD_VAR 0 5
80315: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80316: LD_INT 0
80318: PPUSH
80319: PPUSH
80320: PPUSH
80321: PPUSH
// if not mc_bases or not skirmish then
80322: LD_EXP 58
80326: NOT
80327: PUSH
80328: LD_EXP 56
80332: NOT
80333: OR
80334: IFFALSE 80338
// exit ;
80336: GO 80721
// side := GetSide ( vehicle ) ;
80338: LD_ADDR_VAR 0 5
80342: PUSH
80343: LD_VAR 0 1
80347: PPUSH
80348: CALL_OW 255
80352: ST_TO_ADDR
// for i = 1 to mc_bases do
80353: LD_ADDR_VAR 0 4
80357: PUSH
80358: DOUBLE
80359: LD_INT 1
80361: DEC
80362: ST_TO_ADDR
80363: LD_EXP 58
80367: PUSH
80368: FOR_TO
80369: IFFALSE 80719
// begin if factory in mc_bases [ i ] then
80371: LD_VAR 0 2
80375: PUSH
80376: LD_EXP 58
80380: PUSH
80381: LD_VAR 0 4
80385: ARRAY
80386: IN
80387: IFFALSE 80717
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
80389: LD_EXP 80
80393: PUSH
80394: LD_VAR 0 4
80398: ARRAY
80399: PUSH
80400: LD_EXP 69
80404: PUSH
80405: LD_VAR 0 4
80409: ARRAY
80410: LESS
80411: PUSH
80412: LD_VAR 0 1
80416: PPUSH
80417: CALL_OW 264
80421: PUSH
80422: LD_INT 31
80424: PUSH
80425: LD_INT 32
80427: PUSH
80428: LD_INT 51
80430: PUSH
80431: LD_EXP 102
80435: PUSH
80436: LD_INT 12
80438: PUSH
80439: LD_INT 30
80441: PUSH
80442: LD_EXP 101
80446: PUSH
80447: LD_INT 11
80449: PUSH
80450: LD_INT 53
80452: PUSH
80453: LD_INT 14
80455: PUSH
80456: LD_EXP 105
80460: PUSH
80461: LD_INT 29
80463: PUSH
80464: LD_EXP 103
80468: PUSH
80469: LD_INT 13
80471: PUSH
80472: LD_INT 52
80474: PUSH
80475: LD_INT 48
80477: PUSH
80478: LD_INT 8
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: LIST
80485: LIST
80486: LIST
80487: LIST
80488: LIST
80489: LIST
80490: LIST
80491: LIST
80492: LIST
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: IN
80500: NOT
80501: AND
80502: IFFALSE 80543
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
80504: LD_ADDR_EXP 80
80508: PUSH
80509: LD_EXP 80
80513: PPUSH
80514: LD_VAR 0 4
80518: PPUSH
80519: LD_EXP 80
80523: PUSH
80524: LD_VAR 0 4
80528: ARRAY
80529: PUSH
80530: LD_VAR 0 1
80534: ADD
80535: PPUSH
80536: CALL_OW 1
80540: ST_TO_ADDR
80541: GO 80587
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80543: LD_ADDR_EXP 77
80547: PUSH
80548: LD_EXP 77
80552: PPUSH
80553: LD_VAR 0 4
80557: PUSH
80558: LD_EXP 77
80562: PUSH
80563: LD_VAR 0 4
80567: ARRAY
80568: PUSH
80569: LD_INT 1
80571: PLUS
80572: PUSH
80573: EMPTY
80574: LIST
80575: LIST
80576: PPUSH
80577: LD_VAR 0 1
80581: PPUSH
80582: CALL 20270 0 3
80586: ST_TO_ADDR
// if not mc_scan [ i ] then
80587: LD_EXP 81
80591: PUSH
80592: LD_VAR 0 4
80596: ARRAY
80597: NOT
80598: IFFALSE 80717
// begin if GetControl ( vehicle ) = control_remote then
80600: LD_VAR 0 1
80604: PPUSH
80605: CALL_OW 263
80609: PUSH
80610: LD_INT 2
80612: EQUAL
80613: IFFALSE 80633
// repeat wait ( 0 0$1 ) ;
80615: LD_INT 35
80617: PPUSH
80618: CALL_OW 67
// until IsControledBy ( vehicle ) ;
80622: LD_VAR 0 1
80626: PPUSH
80627: CALL_OW 312
80631: IFFALSE 80615
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80633: LD_VAR 0 1
80637: PPUSH
80638: LD_EXP 82
80642: PUSH
80643: LD_VAR 0 4
80647: ARRAY
80648: PPUSH
80649: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80653: LD_VAR 0 1
80657: PPUSH
80658: CALL_OW 263
80662: PUSH
80663: LD_INT 1
80665: NONEQUAL
80666: IFFALSE 80670
// break ;
80668: GO 80719
// repeat wait ( 0 0$1 ) ;
80670: LD_INT 35
80672: PPUSH
80673: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80677: LD_VAR 0 1
80681: PPUSH
80682: LD_EXP 82
80686: PUSH
80687: LD_VAR 0 4
80691: ARRAY
80692: PPUSH
80693: CALL_OW 308
80697: IFFALSE 80670
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80699: LD_VAR 0 1
80703: PPUSH
80704: CALL_OW 311
80708: PPUSH
80709: CALL_OW 121
// exit ;
80713: POP
80714: POP
80715: GO 80721
// end ; end ; end ;
80717: GO 80368
80719: POP
80720: POP
// end ;
80721: LD_VAR 0 3
80725: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80726: LD_INT 0
80728: PPUSH
80729: PPUSH
80730: PPUSH
80731: PPUSH
// if not mc_bases or not skirmish then
80732: LD_EXP 58
80736: NOT
80737: PUSH
80738: LD_EXP 56
80742: NOT
80743: OR
80744: IFFALSE 80748
// exit ;
80746: GO 81101
// repeat wait ( 0 0$1 ) ;
80748: LD_INT 35
80750: PPUSH
80751: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80755: LD_VAR 0 2
80759: PPUSH
80760: LD_VAR 0 3
80764: PPUSH
80765: CALL_OW 284
80769: IFFALSE 80748
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80771: LD_VAR 0 2
80775: PPUSH
80776: LD_VAR 0 3
80780: PPUSH
80781: CALL_OW 283
80785: PUSH
80786: LD_INT 4
80788: EQUAL
80789: IFFALSE 80793
// exit ;
80791: GO 81101
// for i = 1 to mc_bases do
80793: LD_ADDR_VAR 0 7
80797: PUSH
80798: DOUBLE
80799: LD_INT 1
80801: DEC
80802: ST_TO_ADDR
80803: LD_EXP 58
80807: PUSH
80808: FOR_TO
80809: IFFALSE 81099
// begin if mc_crates_area [ i ] then
80811: LD_EXP 76
80815: PUSH
80816: LD_VAR 0 7
80820: ARRAY
80821: IFFALSE 80932
// for j in mc_crates_area [ i ] do
80823: LD_ADDR_VAR 0 8
80827: PUSH
80828: LD_EXP 76
80832: PUSH
80833: LD_VAR 0 7
80837: ARRAY
80838: PUSH
80839: FOR_IN
80840: IFFALSE 80930
// if InArea ( x , y , j ) then
80842: LD_VAR 0 2
80846: PPUSH
80847: LD_VAR 0 3
80851: PPUSH
80852: LD_VAR 0 8
80856: PPUSH
80857: CALL_OW 309
80861: IFFALSE 80928
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80863: LD_ADDR_EXP 74
80867: PUSH
80868: LD_EXP 74
80872: PPUSH
80873: LD_VAR 0 7
80877: PUSH
80878: LD_EXP 74
80882: PUSH
80883: LD_VAR 0 7
80887: ARRAY
80888: PUSH
80889: LD_INT 1
80891: PLUS
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PPUSH
80897: LD_VAR 0 4
80901: PUSH
80902: LD_VAR 0 2
80906: PUSH
80907: LD_VAR 0 3
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: LIST
80916: PPUSH
80917: CALL 20270 0 3
80921: ST_TO_ADDR
// exit ;
80922: POP
80923: POP
80924: POP
80925: POP
80926: GO 81101
// end ;
80928: GO 80839
80930: POP
80931: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80932: LD_ADDR_VAR 0 9
80936: PUSH
80937: LD_EXP 58
80941: PUSH
80942: LD_VAR 0 7
80946: ARRAY
80947: PPUSH
80948: LD_INT 2
80950: PUSH
80951: LD_INT 30
80953: PUSH
80954: LD_INT 0
80956: PUSH
80957: EMPTY
80958: LIST
80959: LIST
80960: PUSH
80961: LD_INT 30
80963: PUSH
80964: LD_INT 1
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: EMPTY
80972: LIST
80973: LIST
80974: LIST
80975: PPUSH
80976: CALL_OW 72
80980: ST_TO_ADDR
// if not depot then
80981: LD_VAR 0 9
80985: NOT
80986: IFFALSE 80990
// continue ;
80988: GO 80808
// for j in depot do
80990: LD_ADDR_VAR 0 8
80994: PUSH
80995: LD_VAR 0 9
80999: PUSH
81000: FOR_IN
81001: IFFALSE 81095
// if GetDistUnitXY ( j , x , y ) < 30 then
81003: LD_VAR 0 8
81007: PPUSH
81008: LD_VAR 0 2
81012: PPUSH
81013: LD_VAR 0 3
81017: PPUSH
81018: CALL_OW 297
81022: PUSH
81023: LD_INT 30
81025: LESS
81026: IFFALSE 81093
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81028: LD_ADDR_EXP 74
81032: PUSH
81033: LD_EXP 74
81037: PPUSH
81038: LD_VAR 0 7
81042: PUSH
81043: LD_EXP 74
81047: PUSH
81048: LD_VAR 0 7
81052: ARRAY
81053: PUSH
81054: LD_INT 1
81056: PLUS
81057: PUSH
81058: EMPTY
81059: LIST
81060: LIST
81061: PPUSH
81062: LD_VAR 0 4
81066: PUSH
81067: LD_VAR 0 2
81071: PUSH
81072: LD_VAR 0 3
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: LIST
81081: PPUSH
81082: CALL 20270 0 3
81086: ST_TO_ADDR
// exit ;
81087: POP
81088: POP
81089: POP
81090: POP
81091: GO 81101
// end ;
81093: GO 81000
81095: POP
81096: POP
// end ;
81097: GO 80808
81099: POP
81100: POP
// end ;
81101: LD_VAR 0 6
81105: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81106: LD_INT 0
81108: PPUSH
81109: PPUSH
81110: PPUSH
81111: PPUSH
// if not mc_bases or not skirmish then
81112: LD_EXP 58
81116: NOT
81117: PUSH
81118: LD_EXP 56
81122: NOT
81123: OR
81124: IFFALSE 81128
// exit ;
81126: GO 81405
// side := GetSide ( lab ) ;
81128: LD_ADDR_VAR 0 4
81132: PUSH
81133: LD_VAR 0 2
81137: PPUSH
81138: CALL_OW 255
81142: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81143: LD_VAR 0 4
81147: PUSH
81148: LD_EXP 84
81152: IN
81153: NOT
81154: PUSH
81155: LD_EXP 85
81159: NOT
81160: OR
81161: PUSH
81162: LD_EXP 58
81166: NOT
81167: OR
81168: IFFALSE 81172
// exit ;
81170: GO 81405
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81172: LD_ADDR_EXP 85
81176: PUSH
81177: LD_EXP 85
81181: PPUSH
81182: LD_VAR 0 4
81186: PPUSH
81187: LD_EXP 85
81191: PUSH
81192: LD_VAR 0 4
81196: ARRAY
81197: PUSH
81198: LD_VAR 0 1
81202: DIFF
81203: PPUSH
81204: CALL_OW 1
81208: ST_TO_ADDR
// for i = 1 to mc_bases do
81209: LD_ADDR_VAR 0 5
81213: PUSH
81214: DOUBLE
81215: LD_INT 1
81217: DEC
81218: ST_TO_ADDR
81219: LD_EXP 58
81223: PUSH
81224: FOR_TO
81225: IFFALSE 81403
// begin if lab in mc_bases [ i ] then
81227: LD_VAR 0 2
81231: PUSH
81232: LD_EXP 58
81236: PUSH
81237: LD_VAR 0 5
81241: ARRAY
81242: IN
81243: IFFALSE 81401
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81245: LD_VAR 0 1
81249: PUSH
81250: LD_INT 11
81252: PUSH
81253: LD_INT 4
81255: PUSH
81256: LD_INT 3
81258: PUSH
81259: LD_INT 2
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: LIST
81266: LIST
81267: IN
81268: PUSH
81269: LD_EXP 88
81273: PUSH
81274: LD_VAR 0 5
81278: ARRAY
81279: AND
81280: IFFALSE 81401
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81282: LD_ADDR_VAR 0 6
81286: PUSH
81287: LD_EXP 88
81291: PUSH
81292: LD_VAR 0 5
81296: ARRAY
81297: PUSH
81298: LD_INT 1
81300: ARRAY
81301: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81302: LD_ADDR_EXP 88
81306: PUSH
81307: LD_EXP 88
81311: PPUSH
81312: LD_VAR 0 5
81316: PPUSH
81317: EMPTY
81318: PPUSH
81319: CALL_OW 1
81323: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81324: LD_VAR 0 6
81328: PPUSH
81329: LD_INT 0
81331: PPUSH
81332: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81336: LD_VAR 0 6
81340: PPUSH
81341: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81345: LD_ADDR_EXP 87
81349: PUSH
81350: LD_EXP 87
81354: PPUSH
81355: LD_VAR 0 5
81359: PPUSH
81360: LD_EXP 87
81364: PUSH
81365: LD_VAR 0 5
81369: ARRAY
81370: PPUSH
81371: LD_INT 1
81373: PPUSH
81374: LD_VAR 0 6
81378: PPUSH
81379: CALL_OW 2
81383: PPUSH
81384: CALL_OW 1
81388: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81389: LD_VAR 0 5
81393: PPUSH
81394: LD_INT 112
81396: PPUSH
81397: CALL 59161 0 2
// end ; end ; end ;
81401: GO 81224
81403: POP
81404: POP
// end ;
81405: LD_VAR 0 3
81409: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81410: LD_INT 0
81412: PPUSH
81413: PPUSH
81414: PPUSH
81415: PPUSH
81416: PPUSH
81417: PPUSH
81418: PPUSH
81419: PPUSH
// if not mc_bases or not skirmish then
81420: LD_EXP 58
81424: NOT
81425: PUSH
81426: LD_EXP 56
81430: NOT
81431: OR
81432: IFFALSE 81436
// exit ;
81434: GO 82379
// for i = 1 to mc_bases do
81436: LD_ADDR_VAR 0 3
81440: PUSH
81441: DOUBLE
81442: LD_INT 1
81444: DEC
81445: ST_TO_ADDR
81446: LD_EXP 58
81450: PUSH
81451: FOR_TO
81452: IFFALSE 82377
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81454: LD_VAR 0 1
81458: PUSH
81459: LD_EXP 58
81463: PUSH
81464: LD_VAR 0 3
81468: ARRAY
81469: IN
81470: PUSH
81471: LD_VAR 0 1
81475: PUSH
81476: LD_EXP 65
81480: PUSH
81481: LD_VAR 0 3
81485: ARRAY
81486: IN
81487: OR
81488: PUSH
81489: LD_VAR 0 1
81493: PUSH
81494: LD_EXP 77
81498: PUSH
81499: LD_VAR 0 3
81503: ARRAY
81504: IN
81505: OR
81506: PUSH
81507: LD_VAR 0 1
81511: PUSH
81512: LD_EXP 87
81516: PUSH
81517: LD_VAR 0 3
81521: ARRAY
81522: IN
81523: OR
81524: PUSH
81525: LD_VAR 0 1
81529: PUSH
81530: LD_EXP 88
81534: PUSH
81535: LD_VAR 0 3
81539: ARRAY
81540: IN
81541: OR
81542: IFFALSE 82375
// begin if un in mc_ape [ i ] then
81544: LD_VAR 0 1
81548: PUSH
81549: LD_EXP 87
81553: PUSH
81554: LD_VAR 0 3
81558: ARRAY
81559: IN
81560: IFFALSE 81599
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81562: LD_ADDR_EXP 87
81566: PUSH
81567: LD_EXP 87
81571: PPUSH
81572: LD_VAR 0 3
81576: PPUSH
81577: LD_EXP 87
81581: PUSH
81582: LD_VAR 0 3
81586: ARRAY
81587: PUSH
81588: LD_VAR 0 1
81592: DIFF
81593: PPUSH
81594: CALL_OW 1
81598: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81599: LD_VAR 0 1
81603: PUSH
81604: LD_EXP 88
81608: PUSH
81609: LD_VAR 0 3
81613: ARRAY
81614: IN
81615: IFFALSE 81639
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81617: LD_ADDR_EXP 88
81621: PUSH
81622: LD_EXP 88
81626: PPUSH
81627: LD_VAR 0 3
81631: PPUSH
81632: EMPTY
81633: PPUSH
81634: CALL_OW 1
81638: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
81639: LD_VAR 0 1
81643: PPUSH
81644: CALL_OW 247
81648: PUSH
81649: LD_INT 2
81651: EQUAL
81652: PUSH
81653: LD_VAR 0 1
81657: PPUSH
81658: CALL_OW 110
81662: PUSH
81663: LD_INT 20
81665: EQUAL
81666: AND
81667: IFFALSE 81770
// begin fac := MC_GetBuilding ( i , b_factory ) ;
81669: LD_ADDR_VAR 0 8
81673: PUSH
81674: LD_VAR 0 3
81678: PPUSH
81679: LD_INT 3
81681: PPUSH
81682: CALL 78469 0 2
81686: ST_TO_ADDR
// if fac then
81687: LD_VAR 0 8
81691: IFFALSE 81770
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81693: LD_ADDR_VAR 0 9
81697: PUSH
81698: LD_VAR 0 8
81702: PPUSH
81703: LD_VAR 0 1
81707: PPUSH
81708: CALL_OW 265
81712: PPUSH
81713: LD_VAR 0 1
81717: PPUSH
81718: CALL_OW 262
81722: PPUSH
81723: LD_VAR 0 1
81727: PPUSH
81728: CALL_OW 263
81732: PPUSH
81733: LD_VAR 0 1
81737: PPUSH
81738: CALL_OW 264
81742: PPUSH
81743: CALL 17870 0 5
81747: ST_TO_ADDR
// if components then
81748: LD_VAR 0 9
81752: IFFALSE 81768
// MC_InsertProduceList ( i , components ) ;
81754: LD_VAR 0 3
81758: PPUSH
81759: LD_VAR 0 9
81763: PPUSH
81764: CALL 78039 0 2
// break ;
81768: GO 82377
// end ; end ; if GetType ( un ) = unit_building then
81770: LD_VAR 0 1
81774: PPUSH
81775: CALL_OW 247
81779: PUSH
81780: LD_INT 3
81782: EQUAL
81783: IFFALSE 82098
// begin btype := GetBType ( un ) ;
81785: LD_ADDR_VAR 0 5
81789: PUSH
81790: LD_VAR 0 1
81794: PPUSH
81795: CALL_OW 266
81799: ST_TO_ADDR
// if btype = b_warehouse then
81800: LD_VAR 0 5
81804: PUSH
81805: LD_INT 1
81807: EQUAL
81808: IFFALSE 81826
// begin btype := b_depot ;
81810: LD_ADDR_VAR 0 5
81814: PUSH
81815: LD_INT 0
81817: ST_TO_ADDR
// pos := 1 ;
81818: LD_ADDR_VAR 0 6
81822: PUSH
81823: LD_INT 1
81825: ST_TO_ADDR
// end ; if btype = b_factory then
81826: LD_VAR 0 5
81830: PUSH
81831: LD_INT 3
81833: EQUAL
81834: IFFALSE 81852
// begin btype := b_workshop ;
81836: LD_ADDR_VAR 0 5
81840: PUSH
81841: LD_INT 2
81843: ST_TO_ADDR
// pos := 1 ;
81844: LD_ADDR_VAR 0 6
81848: PUSH
81849: LD_INT 1
81851: ST_TO_ADDR
// end ; if btype = b_barracks then
81852: LD_VAR 0 5
81856: PUSH
81857: LD_INT 5
81859: EQUAL
81860: IFFALSE 81870
// btype := b_armoury ;
81862: LD_ADDR_VAR 0 5
81866: PUSH
81867: LD_INT 4
81869: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81870: LD_VAR 0 5
81874: PUSH
81875: LD_INT 7
81877: PUSH
81878: LD_INT 8
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: IN
81885: IFFALSE 81895
// btype := b_lab ;
81887: LD_ADDR_VAR 0 5
81891: PUSH
81892: LD_INT 6
81894: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81895: LD_ADDR_EXP 63
81899: PUSH
81900: LD_EXP 63
81904: PPUSH
81905: LD_VAR 0 3
81909: PUSH
81910: LD_EXP 63
81914: PUSH
81915: LD_VAR 0 3
81919: ARRAY
81920: PUSH
81921: LD_INT 1
81923: PLUS
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PPUSH
81929: LD_VAR 0 5
81933: PUSH
81934: LD_VAR 0 1
81938: PPUSH
81939: CALL_OW 250
81943: PUSH
81944: LD_VAR 0 1
81948: PPUSH
81949: CALL_OW 251
81953: PUSH
81954: LD_VAR 0 1
81958: PPUSH
81959: CALL_OW 254
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: LIST
81968: LIST
81969: PPUSH
81970: CALL 20270 0 3
81974: ST_TO_ADDR
// if pos = 1 then
81975: LD_VAR 0 6
81979: PUSH
81980: LD_INT 1
81982: EQUAL
81983: IFFALSE 82098
// begin tmp := mc_build_list [ i ] ;
81985: LD_ADDR_VAR 0 7
81989: PUSH
81990: LD_EXP 63
81994: PUSH
81995: LD_VAR 0 3
81999: ARRAY
82000: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82001: LD_VAR 0 7
82005: PPUSH
82006: LD_INT 2
82008: PUSH
82009: LD_INT 30
82011: PUSH
82012: LD_INT 0
82014: PUSH
82015: EMPTY
82016: LIST
82017: LIST
82018: PUSH
82019: LD_INT 30
82021: PUSH
82022: LD_INT 1
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: LIST
82033: PPUSH
82034: CALL_OW 72
82038: IFFALSE 82048
// pos := 2 ;
82040: LD_ADDR_VAR 0 6
82044: PUSH
82045: LD_INT 2
82047: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82048: LD_ADDR_VAR 0 7
82052: PUSH
82053: LD_VAR 0 7
82057: PPUSH
82058: LD_VAR 0 6
82062: PPUSH
82063: LD_VAR 0 7
82067: PPUSH
82068: CALL 20596 0 3
82072: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82073: LD_ADDR_EXP 63
82077: PUSH
82078: LD_EXP 63
82082: PPUSH
82083: LD_VAR 0 3
82087: PPUSH
82088: LD_VAR 0 7
82092: PPUSH
82093: CALL_OW 1
82097: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82098: LD_VAR 0 1
82102: PUSH
82103: LD_EXP 58
82107: PUSH
82108: LD_VAR 0 3
82112: ARRAY
82113: IN
82114: IFFALSE 82153
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82116: LD_ADDR_EXP 58
82120: PUSH
82121: LD_EXP 58
82125: PPUSH
82126: LD_VAR 0 3
82130: PPUSH
82131: LD_EXP 58
82135: PUSH
82136: LD_VAR 0 3
82140: ARRAY
82141: PUSH
82142: LD_VAR 0 1
82146: DIFF
82147: PPUSH
82148: CALL_OW 1
82152: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82153: LD_VAR 0 1
82157: PUSH
82158: LD_EXP 65
82162: PUSH
82163: LD_VAR 0 3
82167: ARRAY
82168: IN
82169: IFFALSE 82208
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82171: LD_ADDR_EXP 65
82175: PUSH
82176: LD_EXP 65
82180: PPUSH
82181: LD_VAR 0 3
82185: PPUSH
82186: LD_EXP 65
82190: PUSH
82191: LD_VAR 0 3
82195: ARRAY
82196: PUSH
82197: LD_VAR 0 1
82201: DIFF
82202: PPUSH
82203: CALL_OW 1
82207: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
82208: LD_VAR 0 1
82212: PUSH
82213: LD_EXP 77
82217: PUSH
82218: LD_VAR 0 3
82222: ARRAY
82223: IN
82224: IFFALSE 82263
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
82226: LD_ADDR_EXP 77
82230: PUSH
82231: LD_EXP 77
82235: PPUSH
82236: LD_VAR 0 3
82240: PPUSH
82241: LD_EXP 77
82245: PUSH
82246: LD_VAR 0 3
82250: ARRAY
82251: PUSH
82252: LD_VAR 0 1
82256: DIFF
82257: PPUSH
82258: CALL_OW 1
82262: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
82263: LD_VAR 0 1
82267: PUSH
82268: LD_EXP 67
82272: PUSH
82273: LD_VAR 0 3
82277: ARRAY
82278: IN
82279: IFFALSE 82318
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
82281: LD_ADDR_EXP 67
82285: PUSH
82286: LD_EXP 67
82290: PPUSH
82291: LD_VAR 0 3
82295: PPUSH
82296: LD_EXP 67
82300: PUSH
82301: LD_VAR 0 3
82305: ARRAY
82306: PUSH
82307: LD_VAR 0 1
82311: DIFF
82312: PPUSH
82313: CALL_OW 1
82317: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82318: LD_VAR 0 1
82322: PUSH
82323: LD_EXP 66
82327: PUSH
82328: LD_VAR 0 3
82332: ARRAY
82333: IN
82334: IFFALSE 82373
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82336: LD_ADDR_EXP 66
82340: PUSH
82341: LD_EXP 66
82345: PPUSH
82346: LD_VAR 0 3
82350: PPUSH
82351: LD_EXP 66
82355: PUSH
82356: LD_VAR 0 3
82360: ARRAY
82361: PUSH
82362: LD_VAR 0 1
82366: DIFF
82367: PPUSH
82368: CALL_OW 1
82372: ST_TO_ADDR
// end ; break ;
82373: GO 82377
// end ;
82375: GO 81451
82377: POP
82378: POP
// end ;
82379: LD_VAR 0 2
82383: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82384: LD_INT 0
82386: PPUSH
82387: PPUSH
82388: PPUSH
// if not mc_bases or not skirmish then
82389: LD_EXP 58
82393: NOT
82394: PUSH
82395: LD_EXP 56
82399: NOT
82400: OR
82401: IFFALSE 82405
// exit ;
82403: GO 82620
// for i = 1 to mc_bases do
82405: LD_ADDR_VAR 0 3
82409: PUSH
82410: DOUBLE
82411: LD_INT 1
82413: DEC
82414: ST_TO_ADDR
82415: LD_EXP 58
82419: PUSH
82420: FOR_TO
82421: IFFALSE 82618
// begin if building in mc_construct_list [ i ] then
82423: LD_VAR 0 1
82427: PUSH
82428: LD_EXP 65
82432: PUSH
82433: LD_VAR 0 3
82437: ARRAY
82438: IN
82439: IFFALSE 82616
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82441: LD_ADDR_EXP 65
82445: PUSH
82446: LD_EXP 65
82450: PPUSH
82451: LD_VAR 0 3
82455: PPUSH
82456: LD_EXP 65
82460: PUSH
82461: LD_VAR 0 3
82465: ARRAY
82466: PUSH
82467: LD_VAR 0 1
82471: DIFF
82472: PPUSH
82473: CALL_OW 1
82477: ST_TO_ADDR
// if building in mc_lab [ i ] then
82478: LD_VAR 0 1
82482: PUSH
82483: LD_EXP 91
82487: PUSH
82488: LD_VAR 0 3
82492: ARRAY
82493: IN
82494: IFFALSE 82549
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82496: LD_ADDR_EXP 92
82500: PUSH
82501: LD_EXP 92
82505: PPUSH
82506: LD_VAR 0 3
82510: PPUSH
82511: LD_EXP 92
82515: PUSH
82516: LD_VAR 0 3
82520: ARRAY
82521: PPUSH
82522: LD_INT 1
82524: PPUSH
82525: LD_EXP 92
82529: PUSH
82530: LD_VAR 0 3
82534: ARRAY
82535: PPUSH
82536: LD_INT 0
82538: PPUSH
82539: CALL 19688 0 4
82543: PPUSH
82544: CALL_OW 1
82548: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82549: LD_VAR 0 1
82553: PUSH
82554: LD_EXP 58
82558: PUSH
82559: LD_VAR 0 3
82563: ARRAY
82564: IN
82565: NOT
82566: IFFALSE 82612
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82568: LD_ADDR_EXP 58
82572: PUSH
82573: LD_EXP 58
82577: PPUSH
82578: LD_VAR 0 3
82582: PUSH
82583: LD_EXP 58
82587: PUSH
82588: LD_VAR 0 3
82592: ARRAY
82593: PUSH
82594: LD_INT 1
82596: PLUS
82597: PUSH
82598: EMPTY
82599: LIST
82600: LIST
82601: PPUSH
82602: LD_VAR 0 1
82606: PPUSH
82607: CALL 20270 0 3
82611: ST_TO_ADDR
// exit ;
82612: POP
82613: POP
82614: GO 82620
// end ; end ;
82616: GO 82420
82618: POP
82619: POP
// end ;
82620: LD_VAR 0 2
82624: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82625: LD_INT 0
82627: PPUSH
82628: PPUSH
82629: PPUSH
82630: PPUSH
82631: PPUSH
82632: PPUSH
82633: PPUSH
// if not mc_bases or not skirmish then
82634: LD_EXP 58
82638: NOT
82639: PUSH
82640: LD_EXP 56
82644: NOT
82645: OR
82646: IFFALSE 82650
// exit ;
82648: GO 83311
// for i = 1 to mc_bases do
82650: LD_ADDR_VAR 0 3
82654: PUSH
82655: DOUBLE
82656: LD_INT 1
82658: DEC
82659: ST_TO_ADDR
82660: LD_EXP 58
82664: PUSH
82665: FOR_TO
82666: IFFALSE 83309
// begin if building in mc_construct_list [ i ] then
82668: LD_VAR 0 1
82672: PUSH
82673: LD_EXP 65
82677: PUSH
82678: LD_VAR 0 3
82682: ARRAY
82683: IN
82684: IFFALSE 83307
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82686: LD_ADDR_EXP 65
82690: PUSH
82691: LD_EXP 65
82695: PPUSH
82696: LD_VAR 0 3
82700: PPUSH
82701: LD_EXP 65
82705: PUSH
82706: LD_VAR 0 3
82710: ARRAY
82711: PUSH
82712: LD_VAR 0 1
82716: DIFF
82717: PPUSH
82718: CALL_OW 1
82722: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82723: LD_ADDR_EXP 58
82727: PUSH
82728: LD_EXP 58
82732: PPUSH
82733: LD_VAR 0 3
82737: PUSH
82738: LD_EXP 58
82742: PUSH
82743: LD_VAR 0 3
82747: ARRAY
82748: PUSH
82749: LD_INT 1
82751: PLUS
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PPUSH
82757: LD_VAR 0 1
82761: PPUSH
82762: CALL 20270 0 3
82766: ST_TO_ADDR
// btype := GetBType ( building ) ;
82767: LD_ADDR_VAR 0 5
82771: PUSH
82772: LD_VAR 0 1
82776: PPUSH
82777: CALL_OW 266
82781: ST_TO_ADDR
// side := GetSide ( building ) ;
82782: LD_ADDR_VAR 0 8
82786: PUSH
82787: LD_VAR 0 1
82791: PPUSH
82792: CALL_OW 255
82796: ST_TO_ADDR
// if btype = b_lab then
82797: LD_VAR 0 5
82801: PUSH
82802: LD_INT 6
82804: EQUAL
82805: IFFALSE 82855
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82807: LD_ADDR_EXP 91
82811: PUSH
82812: LD_EXP 91
82816: PPUSH
82817: LD_VAR 0 3
82821: PUSH
82822: LD_EXP 91
82826: PUSH
82827: LD_VAR 0 3
82831: ARRAY
82832: PUSH
82833: LD_INT 1
82835: PLUS
82836: PUSH
82837: EMPTY
82838: LIST
82839: LIST
82840: PPUSH
82841: LD_VAR 0 1
82845: PPUSH
82846: CALL 20270 0 3
82850: ST_TO_ADDR
// exit ;
82851: POP
82852: POP
82853: GO 83311
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82855: LD_VAR 0 5
82859: PUSH
82860: LD_INT 0
82862: PUSH
82863: LD_INT 2
82865: PUSH
82866: LD_INT 4
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: LIST
82873: IN
82874: IFFALSE 82998
// begin if btype = b_armoury then
82876: LD_VAR 0 5
82880: PUSH
82881: LD_INT 4
82883: EQUAL
82884: IFFALSE 82894
// btype := b_barracks ;
82886: LD_ADDR_VAR 0 5
82890: PUSH
82891: LD_INT 5
82893: ST_TO_ADDR
// if btype = b_depot then
82894: LD_VAR 0 5
82898: PUSH
82899: LD_INT 0
82901: EQUAL
82902: IFFALSE 82912
// btype := b_warehouse ;
82904: LD_ADDR_VAR 0 5
82908: PUSH
82909: LD_INT 1
82911: ST_TO_ADDR
// if btype = b_workshop then
82912: LD_VAR 0 5
82916: PUSH
82917: LD_INT 2
82919: EQUAL
82920: IFFALSE 82930
// btype := b_factory ;
82922: LD_ADDR_VAR 0 5
82926: PUSH
82927: LD_INT 3
82929: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82930: LD_VAR 0 5
82934: PPUSH
82935: LD_VAR 0 8
82939: PPUSH
82940: CALL_OW 323
82944: PUSH
82945: LD_INT 1
82947: EQUAL
82948: IFFALSE 82994
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82950: LD_ADDR_EXP 90
82954: PUSH
82955: LD_EXP 90
82959: PPUSH
82960: LD_VAR 0 3
82964: PUSH
82965: LD_EXP 90
82969: PUSH
82970: LD_VAR 0 3
82974: ARRAY
82975: PUSH
82976: LD_INT 1
82978: PLUS
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PPUSH
82984: LD_VAR 0 1
82988: PPUSH
82989: CALL 20270 0 3
82993: ST_TO_ADDR
// exit ;
82994: POP
82995: POP
82996: GO 83311
// end ; if btype in [ b_bunker , b_turret ] then
82998: LD_VAR 0 5
83002: PUSH
83003: LD_INT 32
83005: PUSH
83006: LD_INT 33
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: IN
83013: IFFALSE 83303
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83015: LD_ADDR_EXP 66
83019: PUSH
83020: LD_EXP 66
83024: PPUSH
83025: LD_VAR 0 3
83029: PUSH
83030: LD_EXP 66
83034: PUSH
83035: LD_VAR 0 3
83039: ARRAY
83040: PUSH
83041: LD_INT 1
83043: PLUS
83044: PUSH
83045: EMPTY
83046: LIST
83047: LIST
83048: PPUSH
83049: LD_VAR 0 1
83053: PPUSH
83054: CALL 20270 0 3
83058: ST_TO_ADDR
// if btype = b_bunker then
83059: LD_VAR 0 5
83063: PUSH
83064: LD_INT 32
83066: EQUAL
83067: IFFALSE 83303
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83069: LD_ADDR_EXP 67
83073: PUSH
83074: LD_EXP 67
83078: PPUSH
83079: LD_VAR 0 3
83083: PUSH
83084: LD_EXP 67
83088: PUSH
83089: LD_VAR 0 3
83093: ARRAY
83094: PUSH
83095: LD_INT 1
83097: PLUS
83098: PUSH
83099: EMPTY
83100: LIST
83101: LIST
83102: PPUSH
83103: LD_VAR 0 1
83107: PPUSH
83108: CALL 20270 0 3
83112: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83113: LD_ADDR_VAR 0 6
83117: PUSH
83118: LD_EXP 58
83122: PUSH
83123: LD_VAR 0 3
83127: ARRAY
83128: PPUSH
83129: LD_INT 25
83131: PUSH
83132: LD_INT 1
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 3
83141: PUSH
83142: LD_INT 54
83144: PUSH
83145: EMPTY
83146: LIST
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: EMPTY
83153: LIST
83154: LIST
83155: PPUSH
83156: CALL_OW 72
83160: ST_TO_ADDR
// if tmp then
83161: LD_VAR 0 6
83165: IFFALSE 83171
// exit ;
83167: POP
83168: POP
83169: GO 83311
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
83171: LD_ADDR_VAR 0 6
83175: PUSH
83176: LD_EXP 58
83180: PUSH
83181: LD_VAR 0 3
83185: ARRAY
83186: PPUSH
83187: LD_INT 2
83189: PUSH
83190: LD_INT 30
83192: PUSH
83193: LD_INT 4
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 30
83202: PUSH
83203: LD_INT 5
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: LIST
83214: PPUSH
83215: CALL_OW 72
83219: ST_TO_ADDR
// if not tmp then
83220: LD_VAR 0 6
83224: NOT
83225: IFFALSE 83231
// exit ;
83227: POP
83228: POP
83229: GO 83311
// for j in tmp do
83231: LD_ADDR_VAR 0 4
83235: PUSH
83236: LD_VAR 0 6
83240: PUSH
83241: FOR_IN
83242: IFFALSE 83301
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
83244: LD_ADDR_VAR 0 7
83248: PUSH
83249: LD_VAR 0 4
83253: PPUSH
83254: CALL_OW 313
83258: PPUSH
83259: LD_INT 25
83261: PUSH
83262: LD_INT 1
83264: PUSH
83265: EMPTY
83266: LIST
83267: LIST
83268: PPUSH
83269: CALL_OW 72
83273: ST_TO_ADDR
// if units then
83274: LD_VAR 0 7
83278: IFFALSE 83299
// begin ComExitBuilding ( units [ 1 ] ) ;
83280: LD_VAR 0 7
83284: PUSH
83285: LD_INT 1
83287: ARRAY
83288: PPUSH
83289: CALL_OW 122
// exit ;
83293: POP
83294: POP
83295: POP
83296: POP
83297: GO 83311
// end ; end ;
83299: GO 83241
83301: POP
83302: POP
// end ; end ; exit ;
83303: POP
83304: POP
83305: GO 83311
// end ; end ;
83307: GO 82665
83309: POP
83310: POP
// end ;
83311: LD_VAR 0 2
83315: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83316: LD_INT 0
83318: PPUSH
83319: PPUSH
83320: PPUSH
83321: PPUSH
83322: PPUSH
83323: PPUSH
83324: PPUSH
// if not mc_bases or not skirmish then
83325: LD_EXP 58
83329: NOT
83330: PUSH
83331: LD_EXP 56
83335: NOT
83336: OR
83337: IFFALSE 83341
// exit ;
83339: GO 83572
// btype := GetBType ( building ) ;
83341: LD_ADDR_VAR 0 6
83345: PUSH
83346: LD_VAR 0 1
83350: PPUSH
83351: CALL_OW 266
83355: ST_TO_ADDR
// x := GetX ( building ) ;
83356: LD_ADDR_VAR 0 7
83360: PUSH
83361: LD_VAR 0 1
83365: PPUSH
83366: CALL_OW 250
83370: ST_TO_ADDR
// y := GetY ( building ) ;
83371: LD_ADDR_VAR 0 8
83375: PUSH
83376: LD_VAR 0 1
83380: PPUSH
83381: CALL_OW 251
83385: ST_TO_ADDR
// d := GetDir ( building ) ;
83386: LD_ADDR_VAR 0 9
83390: PUSH
83391: LD_VAR 0 1
83395: PPUSH
83396: CALL_OW 254
83400: ST_TO_ADDR
// for i = 1 to mc_bases do
83401: LD_ADDR_VAR 0 4
83405: PUSH
83406: DOUBLE
83407: LD_INT 1
83409: DEC
83410: ST_TO_ADDR
83411: LD_EXP 58
83415: PUSH
83416: FOR_TO
83417: IFFALSE 83570
// begin if not mc_build_list [ i ] then
83419: LD_EXP 63
83423: PUSH
83424: LD_VAR 0 4
83428: ARRAY
83429: NOT
83430: IFFALSE 83434
// continue ;
83432: GO 83416
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
83434: LD_VAR 0 6
83438: PUSH
83439: LD_VAR 0 7
83443: PUSH
83444: LD_VAR 0 8
83448: PUSH
83449: LD_VAR 0 9
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: LIST
83458: LIST
83459: PPUSH
83460: LD_EXP 63
83464: PUSH
83465: LD_VAR 0 4
83469: ARRAY
83470: PUSH
83471: LD_INT 1
83473: ARRAY
83474: PPUSH
83475: CALL 26439 0 2
83479: IFFALSE 83568
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
83481: LD_ADDR_EXP 63
83485: PUSH
83486: LD_EXP 63
83490: PPUSH
83491: LD_VAR 0 4
83495: PPUSH
83496: LD_EXP 63
83500: PUSH
83501: LD_VAR 0 4
83505: ARRAY
83506: PPUSH
83507: LD_INT 1
83509: PPUSH
83510: CALL_OW 3
83514: PPUSH
83515: CALL_OW 1
83519: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83520: LD_ADDR_EXP 65
83524: PUSH
83525: LD_EXP 65
83529: PPUSH
83530: LD_VAR 0 4
83534: PUSH
83535: LD_EXP 65
83539: PUSH
83540: LD_VAR 0 4
83544: ARRAY
83545: PUSH
83546: LD_INT 1
83548: PLUS
83549: PUSH
83550: EMPTY
83551: LIST
83552: LIST
83553: PPUSH
83554: LD_VAR 0 1
83558: PPUSH
83559: CALL 20270 0 3
83563: ST_TO_ADDR
// exit ;
83564: POP
83565: POP
83566: GO 83572
// end ; end ;
83568: GO 83416
83570: POP
83571: POP
// end ;
83572: LD_VAR 0 3
83576: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83577: LD_INT 0
83579: PPUSH
83580: PPUSH
83581: PPUSH
// if not mc_bases or not skirmish then
83582: LD_EXP 58
83586: NOT
83587: PUSH
83588: LD_EXP 56
83592: NOT
83593: OR
83594: IFFALSE 83598
// exit ;
83596: GO 83788
// for i = 1 to mc_bases do
83598: LD_ADDR_VAR 0 4
83602: PUSH
83603: DOUBLE
83604: LD_INT 1
83606: DEC
83607: ST_TO_ADDR
83608: LD_EXP 58
83612: PUSH
83613: FOR_TO
83614: IFFALSE 83701
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83616: LD_VAR 0 1
83620: PUSH
83621: LD_EXP 66
83625: PUSH
83626: LD_VAR 0 4
83630: ARRAY
83631: IN
83632: PUSH
83633: LD_VAR 0 1
83637: PUSH
83638: LD_EXP 67
83642: PUSH
83643: LD_VAR 0 4
83647: ARRAY
83648: IN
83649: NOT
83650: AND
83651: IFFALSE 83699
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83653: LD_ADDR_EXP 67
83657: PUSH
83658: LD_EXP 67
83662: PPUSH
83663: LD_VAR 0 4
83667: PUSH
83668: LD_EXP 67
83672: PUSH
83673: LD_VAR 0 4
83677: ARRAY
83678: PUSH
83679: LD_INT 1
83681: PLUS
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PPUSH
83687: LD_VAR 0 1
83691: PPUSH
83692: CALL 20270 0 3
83696: ST_TO_ADDR
// break ;
83697: GO 83701
// end ; end ;
83699: GO 83613
83701: POP
83702: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83703: LD_VAR 0 1
83707: PPUSH
83708: CALL_OW 257
83712: PUSH
83713: LD_EXP 84
83717: IN
83718: PUSH
83719: LD_VAR 0 1
83723: PPUSH
83724: CALL_OW 266
83728: PUSH
83729: LD_INT 5
83731: EQUAL
83732: AND
83733: PUSH
83734: LD_VAR 0 2
83738: PPUSH
83739: CALL_OW 110
83743: PUSH
83744: LD_INT 18
83746: NONEQUAL
83747: AND
83748: IFFALSE 83788
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83750: LD_VAR 0 2
83754: PPUSH
83755: CALL_OW 257
83759: PUSH
83760: LD_INT 5
83762: PUSH
83763: LD_INT 8
83765: PUSH
83766: LD_INT 9
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: LIST
83773: IN
83774: IFFALSE 83788
// SetClass ( unit , 1 ) ;
83776: LD_VAR 0 2
83780: PPUSH
83781: LD_INT 1
83783: PPUSH
83784: CALL_OW 336
// end ;
83788: LD_VAR 0 3
83792: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83793: LD_INT 0
83795: PPUSH
83796: PPUSH
// if not mc_bases or not skirmish then
83797: LD_EXP 58
83801: NOT
83802: PUSH
83803: LD_EXP 56
83807: NOT
83808: OR
83809: IFFALSE 83813
// exit ;
83811: GO 83929
// if GetLives ( abandoned_vehicle ) > 250 then
83813: LD_VAR 0 2
83817: PPUSH
83818: CALL_OW 256
83822: PUSH
83823: LD_INT 250
83825: GREATER
83826: IFFALSE 83830
// exit ;
83828: GO 83929
// for i = 1 to mc_bases do
83830: LD_ADDR_VAR 0 6
83834: PUSH
83835: DOUBLE
83836: LD_INT 1
83838: DEC
83839: ST_TO_ADDR
83840: LD_EXP 58
83844: PUSH
83845: FOR_TO
83846: IFFALSE 83927
// begin if driver in mc_bases [ i ] then
83848: LD_VAR 0 1
83852: PUSH
83853: LD_EXP 58
83857: PUSH
83858: LD_VAR 0 6
83862: ARRAY
83863: IN
83864: IFFALSE 83925
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83866: LD_VAR 0 1
83870: PPUSH
83871: LD_EXP 58
83875: PUSH
83876: LD_VAR 0 6
83880: ARRAY
83881: PPUSH
83882: LD_INT 2
83884: PUSH
83885: LD_INT 30
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: EMPTY
83892: LIST
83893: LIST
83894: PUSH
83895: LD_INT 30
83897: PUSH
83898: LD_INT 1
83900: PUSH
83901: EMPTY
83902: LIST
83903: LIST
83904: PUSH
83905: EMPTY
83906: LIST
83907: LIST
83908: LIST
83909: PPUSH
83910: CALL_OW 72
83914: PUSH
83915: LD_INT 1
83917: ARRAY
83918: PPUSH
83919: CALL_OW 112
// break ;
83923: GO 83927
// end ; end ;
83925: GO 83845
83927: POP
83928: POP
// end ; end_of_file
83929: LD_VAR 0 5
83933: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
83934: GO 83936
83936: DISABLE
// begin ru_radar := 98 ;
83937: LD_ADDR_EXP 101
83941: PUSH
83942: LD_INT 98
83944: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83945: LD_ADDR_EXP 102
83949: PUSH
83950: LD_INT 89
83952: ST_TO_ADDR
// us_hack := 99 ;
83953: LD_ADDR_EXP 103
83957: PUSH
83958: LD_INT 99
83960: ST_TO_ADDR
// us_artillery := 97 ;
83961: LD_ADDR_EXP 104
83965: PUSH
83966: LD_INT 97
83968: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83969: LD_ADDR_EXP 105
83973: PUSH
83974: LD_INT 91
83976: ST_TO_ADDR
// end ;
83977: END
