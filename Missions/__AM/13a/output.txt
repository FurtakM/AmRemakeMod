// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 55923 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 47938 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 47938 0 9
// PrepareArabian ;
 140: CALL 3430 0 0
// PrepareRussian ;
 144: CALL 2554 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 57070 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6627 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 77548 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 77974 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 78427 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 78696 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 77914 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 78603 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 77974 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 78427 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 78696 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 77758 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 77914 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := 1 ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 1
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13515 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13515 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13515 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13515 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13515 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13515 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13515 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13515 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13515 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13515 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornel
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13515 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13515 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13515 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13515 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13515 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13515 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13515 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20148 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 63 , 9 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 63
1567: PPUSH
1568: LD_INT 9
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20148 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 2
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 4 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 60
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
// uc_side := 6 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 6
1696: ST_TO_ADDR
// uc_nation := 3 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// InitHc ;
1705: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1709: LD_ADDR_EXP 31
1713: PUSH
1714: LD_STRING Gossudarov
1716: PPUSH
1717: CALL_OW 25
1721: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1722: LD_ADDR_EXP 32
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: CALL_OW 25
1734: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1735: LD_ADDR_EXP 33
1739: PUSH
1740: LD_STRING Titov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Oblukov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1761: LD_ADDR_EXP 35
1765: PUSH
1766: LD_STRING Dolgov
1768: PPUSH
1769: CALL_OW 25
1773: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1774: LD_ADDR_EXP 36
1778: PUSH
1779: LD_STRING Petrosyan
1781: PPUSH
1782: CALL_OW 25
1786: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1787: LD_ADDR_EXP 37
1791: PUSH
1792: LD_STRING Scholtze
1794: PPUSH
1795: CALL_OW 25
1799: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1800: LD_ADDR_EXP 39
1804: PUSH
1805: LD_STRING Kapitsova
1807: PPUSH
1808: CALL_OW 25
1812: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_EXP 31
1822: PUSH
1823: LD_EXP 32
1827: PUSH
1828: LD_EXP 33
1832: PUSH
1833: LD_EXP 38
1837: PUSH
1838: LD_EXP 35
1842: PUSH
1843: LD_EXP 36
1847: PUSH
1848: LD_EXP 37
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1898
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1881: LD_VAR 0 3
1885: PPUSH
1886: LD_INT 14
1888: PPUSH
1889: LD_INT 0
1891: PPUSH
1892: CALL_OW 49
1896: GO 1878
1898: POP
1899: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1900: LD_VAR 0 2
1904: PPUSH
1905: LD_EXP 3
1909: PPUSH
1910: CALL_OW 250
1914: PPUSH
1915: LD_EXP 3
1919: PPUSH
1920: CALL_OW 251
1924: PPUSH
1925: CALL_OW 111
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareBelkov ; begin
1934: LD_INT 0
1936: PPUSH
// uc_side := 4 ;
1937: LD_ADDR_OWVAR 20
1941: PUSH
1942: LD_INT 4
1944: ST_TO_ADDR
// uc_nation := 3 ;
1945: LD_ADDR_OWVAR 21
1949: PUSH
1950: LD_INT 3
1952: ST_TO_ADDR
// InitHc ;
1953: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1957: LD_ADDR_EXP 46
1961: PUSH
1962: LD_STRING Belkov
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1970: LD_EXP 46
1974: PPUSH
1975: LD_INT 14
1977: PPUSH
1978: LD_INT 0
1980: PPUSH
1981: CALL_OW 49
// end ;
1985: LD_VAR 0 1
1989: RET
// export function PrepareGnyevko ; begin
1990: LD_INT 0
1992: PPUSH
// uc_side := 4 ;
1993: LD_ADDR_OWVAR 20
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// uc_nation := 3 ;
2001: LD_ADDR_OWVAR 21
2005: PUSH
2006: LD_INT 3
2008: ST_TO_ADDR
// InitHc ;
2009: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2013: LD_ADDR_EXP 47
2017: PUSH
2018: LD_STRING Gnyevko
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2026: LD_EXP 47
2030: PPUSH
2031: LD_INT 14
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 49
// end ;
2041: LD_VAR 0 1
2045: RET
// export function PrepareBurlak ; var i , tmp ; begin
2046: LD_INT 0
2048: PPUSH
2049: PPUSH
2050: PPUSH
// uc_side := 4 ;
2051: LD_ADDR_OWVAR 20
2055: PUSH
2056: LD_INT 4
2058: ST_TO_ADDR
// uc_nation := 3 ;
2059: LD_ADDR_OWVAR 21
2063: PUSH
2064: LD_INT 3
2066: ST_TO_ADDR
// InitHc ;
2067: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2071: LD_ADDR_EXP 45
2075: PUSH
2076: LD_STRING Burlak
2078: PPUSH
2079: CALL_OW 25
2083: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2084: LD_INT 24
2086: PUSH
2087: LD_INT 23
2089: PUSH
2090: LD_INT 22
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_OWVAR 67
2102: ARRAY
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: LD_INT 45
2112: PUSH
2113: LD_INT 44
2115: PUSH
2116: LD_INT 43
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: LIST
2123: PUSH
2124: LD_OWVAR 67
2128: ARRAY
2129: PPUSH
2130: LD_INT 0
2132: PPUSH
2133: CALL 20148 0 5
// Masha := CreateVehicle ;
2137: LD_ADDR_EXP 48
2141: PUSH
2142: CALL_OW 45
2146: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2147: LD_EXP 48
2151: PUSH
2152: LD_EXP 45
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PPUSH
2161: LD_INT 499
2163: PPUSH
2164: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2168: LD_EXP 48
2172: PPUSH
2173: LD_INT 3
2175: PPUSH
2176: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2180: LD_EXP 48
2184: PPUSH
2185: LD_INT 1
2187: PPUSH
2188: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2192: LD_EXP 48
2196: PPUSH
2197: LD_INT 18
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2207: LD_EXP 45
2211: PPUSH
2212: LD_INT 125
2214: PPUSH
2215: LD_INT 1
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2225: LD_EXP 45
2229: PPUSH
2230: LD_EXP 48
2234: PPUSH
2235: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2239: LD_INT 10
2241: PPUSH
2242: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2246: LD_EXP 48
2250: PPUSH
2251: LD_INT 110
2253: PPUSH
2254: LD_INT 10
2256: PPUSH
2257: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2261: LD_ADDR_EXP 41
2265: PUSH
2266: LD_STRING Petrovova
2268: PPUSH
2269: CALL_OW 25
2273: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2274: LD_ADDR_EXP 43
2278: PUSH
2279: LD_STRING Kuzmov
2281: PPUSH
2282: CALL_OW 25
2286: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2287: LD_ADDR_EXP 42
2291: PUSH
2292: LD_STRING Kovalyuk
2294: PPUSH
2295: CALL_OW 25
2299: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2300: LD_ADDR_EXP 40
2304: PUSH
2305: LD_STRING Lipshchin
2307: PPUSH
2308: CALL_OW 25
2312: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2313: LD_ADDR_EXP 44
2317: PUSH
2318: LD_STRING Karamazov
2320: PPUSH
2321: CALL_OW 25
2325: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: LD_EXP 41
2335: PUSH
2336: LD_EXP 43
2340: PUSH
2341: LD_EXP 42
2345: PUSH
2346: LD_EXP 40
2350: PUSH
2351: LD_EXP 44
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: ST_TO_ADDR
// for i in tmp do
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_IN
2374: IFFALSE 2413
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 399
2383: PPUSH
2384: LD_INT 799
2386: PPUSH
2387: CALL_OW 12
2391: PPUSH
2392: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2396: LD_VAR 0 2
2400: PPUSH
2401: LD_INT 19
2403: PPUSH
2404: LD_INT 0
2406: PPUSH
2407: CALL_OW 49
// end ;
2411: GO 2373
2413: POP
2414: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2415: LD_VAR 0 3
2419: PPUSH
2420: LD_INT 116
2422: PPUSH
2423: LD_INT 8
2425: PPUSH
2426: CALL_OW 111
// AddComHold ( tmp ) ;
2430: LD_VAR 0 3
2434: PPUSH
2435: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2439: LD_ADDR_VAR 0 2
2443: PUSH
2444: LD_VAR 0 3
2448: PPUSH
2449: LD_INT 25
2451: PUSH
2452: LD_INT 1
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PPUSH
2459: CALL_OW 72
2463: PUSH
2464: FOR_IN
2465: IFFALSE 2505
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2467: LD_VAR 0 2
2471: PPUSH
2472: LD_INT 20
2474: PPUSH
2475: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2479: LD_VAR 0 2
2483: PPUSH
2484: LD_INT 147
2486: PPUSH
2487: LD_INT 45
2489: PPUSH
2490: CALL_OW 178
// AddComCrawl ( i ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: CALL_OW 197
// end ;
2503: GO 2464
2505: POP
2506: POP
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) ;
2514: LD_EXP 48
2518: PPUSH
2519: LD_INT 110
2521: PPUSH
2522: LD_INT 10
2524: PPUSH
2525: CALL_OW 307
2529: IFFALSE 2507
// ComStop ( Burlak ) ;
2531: LD_EXP 45
2535: PPUSH
2536: CALL_OW 141
// AddComHold ( Burlak ) ;
2540: LD_EXP 45
2544: PPUSH
2545: CALL_OW 200
// end ; end_of_file
2549: LD_VAR 0 1
2553: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// uc_side := 3 ;
2560: LD_ADDR_OWVAR 20
2564: PUSH
2565: LD_INT 3
2567: ST_TO_ADDR
// uc_nation := 3 ;
2568: LD_ADDR_OWVAR 21
2572: PUSH
2573: LD_INT 3
2575: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2576: LD_ADDR_EXP 49
2580: PUSH
2581: LD_INT 47
2583: PPUSH
2584: LD_INT 4
2586: PPUSH
2587: LD_STRING 
2589: PPUSH
2590: LD_INT 7
2592: PUSH
2593: LD_INT 8
2595: PUSH
2596: LD_INT 9
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: PUSH
2604: LD_OWVAR 67
2608: ARRAY
2609: PPUSH
2610: LD_INT 10000
2612: PUSH
2613: LD_INT 3000
2615: PUSH
2616: LD_INT 300
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: PPUSH
2624: LD_INT 9
2626: PUSH
2627: LD_INT 5
2629: PUSH
2630: LD_INT 6
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: PPUSH
2642: CALL 23557 0 6
2646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2647: LD_ADDR_EXP 58
2651: PUSH
2652: LD_EXP 58
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: LD_EXP 49
2664: PPUSH
2665: CALL_OW 1
2669: ST_TO_ADDR
// tmp := [ ] ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: EMPTY
2676: ST_TO_ADDR
// for i = 1 to 4 do
2677: LD_ADDR_VAR 0 2
2681: PUSH
2682: DOUBLE
2683: LD_INT 1
2685: DEC
2686: ST_TO_ADDR
2687: LD_INT 4
2689: PUSH
2690: FOR_TO
2691: IFFALSE 2784
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2693: LD_INT 22
2695: PPUSH
2696: LD_INT 3
2698: PPUSH
2699: LD_INT 3
2701: PPUSH
2702: LD_INT 43
2704: PUSH
2705: LD_INT 45
2707: PUSH
2708: LD_INT 45
2710: PUSH
2711: LD_INT 44
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_INT 4
2727: MOD
2728: PUSH
2729: LD_INT 1
2731: PLUS
2732: ARRAY
2733: PPUSH
2734: LD_INT 100
2736: PPUSH
2737: CALL 20148 0 5
// veh := CreateVehicle ;
2741: LD_ADDR_VAR 0 3
2745: PUSH
2746: CALL_OW 45
2750: ST_TO_ADDR
// tmp := tmp ^ veh ;
2751: LD_ADDR_VAR 0 4
2755: PUSH
2756: LD_VAR 0 4
2760: PUSH
2761: LD_VAR 0 3
2765: ADD
2766: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 2
2774: PPUSH
2775: LD_INT 0
2777: PPUSH
2778: CALL_OW 49
// end ;
2782: GO 2690
2784: POP
2785: POP
// russian_guard := tmp ;
2786: LD_ADDR_EXP 50
2790: PUSH
2791: LD_VAR 0 4
2795: ST_TO_ADDR
// end ;
2796: LD_VAR 0 1
2800: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2801: LD_INT 47
2803: PPUSH
2804: CALL_OW 302
2808: PUSH
2809: LD_EXP 6
2813: AND
2814: IFFALSE 3427
2816: GO 2818
2818: DISABLE
2819: LD_INT 0
2821: PPUSH
2822: PPUSH
2823: PPUSH
2824: PPUSH
2825: PPUSH
2826: PPUSH
// begin enable ;
2827: ENABLE
// base := 2 ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 2
2835: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2836: LD_ADDR_VAR 0 4
2840: PUSH
2841: LD_INT 0
2843: PUSH
2844: LD_INT 0
2846: PUSH
2847: LD_INT 0
2849: PUSH
2850: LD_INT 0
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 0
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: LD_INT 0
2864: PUSH
2865: LD_INT 1
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2883: LD_ADDR_VAR 0 3
2887: PUSH
2888: LD_INT 22
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: LD_INT 45
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: LD_INT 21
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: LD_INT 3
2914: PUSH
2915: LD_INT 45
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: PUSH
2924: LD_INT 22
2926: PUSH
2927: LD_INT 1
2929: PUSH
2930: LD_INT 3
2932: PUSH
2933: LD_INT 45
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 23
2944: PUSH
2945: LD_INT 1
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: LD_INT 46
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
2966: LD_ADDR_VAR 0 1
2970: PUSH
2971: DOUBLE
2972: LD_INT 1
2974: DEC
2975: ST_TO_ADDR
2976: LD_OWVAR 67
2980: PUSH
2981: LD_OWVAR 1
2985: PUSH
2986: LD_INT 21000
2988: DIV
2989: PLUS
2990: PUSH
2991: FOR_TO
2992: IFFALSE 3080
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_VAR 0 3
3003: PPUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_INT 1
3011: PLUS
3012: PPUSH
3013: LD_INT 23
3015: PUSH
3016: LD_INT 24
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 1
3025: PPUSH
3026: LD_INT 2
3028: PPUSH
3029: CALL_OW 12
3033: ARRAY
3034: PUSH
3035: LD_INT 1
3037: PUSH
3038: LD_INT 3
3040: PUSH
3041: LD_INT 46
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 45
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 3
3060: PPUSH
3061: CALL_OW 12
3065: ARRAY
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 2
3077: ST_TO_ADDR
3078: GO 2991
3080: POP
3081: POP
// MC_SetProduceList ( base , tmp ) ;
3082: LD_VAR 0 2
3086: PPUSH
3087: LD_VAR 0 3
3091: PPUSH
3092: CALL 77866 0 2
// repeat wait ( 0 0$1 ) ;
3096: LD_INT 35
3098: PPUSH
3099: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
3103: LD_VAR 0 2
3107: PPUSH
3108: CALL 78320 0 1
3112: PUSH
3113: LD_INT 0
3115: EQUAL
3116: IFFALSE 3096
// wait ( 0 0$20 ) ;
3118: LD_INT 700
3120: PPUSH
3121: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3125: LD_ADDR_VAR 0 5
3129: PUSH
3130: LD_INT 71
3132: PUSH
3133: LD_INT 19
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: PUSH
3140: LD_INT 91
3142: PUSH
3143: LD_INT 67
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 52
3152: PUSH
3153: LD_INT 44
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: LD_INT 68
3162: PUSH
3163: LD_INT 48
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ) ;
3176: LD_ADDR_VAR 0 6
3180: PUSH
3181: LD_EXP 77
3185: PUSH
3186: LD_VAR 0 2
3190: ARRAY
3191: PUSH
3192: LD_EXP 80
3196: PUSH
3197: LD_VAR 0 2
3201: ARRAY
3202: PUSH
3203: LD_EXP 77
3207: PUSH
3208: LD_VAR 0 2
3212: ARRAY
3213: PPUSH
3214: LD_INT 2
3216: PUSH
3217: LD_INT 34
3219: PUSH
3220: LD_INT 51
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 34
3229: PUSH
3230: LD_INT 52
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 72
3246: UNION
3247: DIFF
3248: ST_TO_ADDR
// if not attackers then
3249: LD_VAR 0 6
3253: NOT
3254: IFFALSE 3258
// exit ;
3256: GO 3427
// ru_attackers := attackers ;
3258: LD_ADDR_EXP 51
3262: PUSH
3263: LD_VAR 0 6
3267: ST_TO_ADDR
// for i = 1 to attackers do
3268: LD_ADDR_VAR 0 1
3272: PUSH
3273: DOUBLE
3274: LD_INT 1
3276: DEC
3277: ST_TO_ADDR
3278: LD_VAR 0 6
3282: PUSH
3283: FOR_TO
3284: IFFALSE 3361
// begin case i mod 3 of 0 :
3286: LD_VAR 0 1
3290: PUSH
3291: LD_INT 3
3293: MOD
3294: PUSH
3295: LD_INT 0
3297: DOUBLE
3298: EQUAL
3299: IFTRUE 3303
3301: GO 3306
3303: POP
// ; 1 :
3304: GO 3359
3306: LD_INT 1
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3332
3314: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3315: LD_VAR 0 1
3319: PPUSH
3320: LD_INT 32
3322: PPUSH
3323: LD_INT 49
3325: PPUSH
3326: CALL_OW 114
3330: GO 3359
3332: LD_INT 2
3334: DOUBLE
3335: EQUAL
3336: IFTRUE 3340
3338: GO 3358
3340: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3341: LD_VAR 0 1
3345: PPUSH
3346: LD_INT 117
3348: PPUSH
3349: LD_INT 107
3351: PPUSH
3352: CALL_OW 114
3356: GO 3359
3358: POP
// end ;
3359: GO 3283
3361: POP
3362: POP
// repeat wait ( 0 0$1 ) ;
3363: LD_INT 35
3365: PPUSH
3366: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3370: LD_VAR 0 6
3374: PPUSH
3375: LD_INT 60
3377: PUSH
3378: EMPTY
3379: LIST
3380: PPUSH
3381: CALL_OW 72
3385: NOT
3386: IFFALSE 3363
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3388: LD_VAR 0 2
3392: PPUSH
3393: LD_VAR 0 6
3397: PPUSH
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_VAR 0 4
3407: PPUSH
3408: CALL 78157 0 4
// if not first_attack then
3412: LD_EXP 7
3416: NOT
3417: IFFALSE 3427
// first_attack := true ;
3419: LD_ADDR_EXP 7
3423: PUSH
3424: LD_INT 1
3426: ST_TO_ADDR
// end ; end_of_file
3427: PPOPN 6
3429: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3430: LD_INT 0
3432: PPUSH
3433: PPUSH
3434: PPUSH
3435: PPUSH
3436: PPUSH
3437: PPUSH
3438: PPUSH
// uc_side := 2 ;
3439: LD_ADDR_OWVAR 20
3443: PUSH
3444: LD_INT 2
3446: ST_TO_ADDR
// uc_nation := 2 ;
3447: LD_ADDR_OWVAR 21
3451: PUSH
3452: LD_INT 2
3454: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3455: LD_ADDR_EXP 54
3459: PUSH
3460: LD_STRING Abdul
3462: PPUSH
3463: CALL_OW 25
3467: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3468: LD_EXP 54
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3480: LD_EXP 54
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: CALL_OW 52
// vc_chassis := 31 ;
3492: LD_ADDR_OWVAR 37
3496: PUSH
3497: LD_INT 31
3499: ST_TO_ADDR
// vc_control := control_rider ;
3500: LD_ADDR_OWVAR 38
3504: PUSH
3505: LD_INT 4
3507: ST_TO_ADDR
// mastodont := CreateVehicle ;
3508: LD_ADDR_EXP 55
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3518: LD_EXP 55
3522: PPUSH
3523: LD_INT 153
3525: PPUSH
3526: LD_INT 71
3528: PPUSH
3529: LD_INT 0
3531: PPUSH
3532: CALL_OW 48
// InitVc ;
3536: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3540: LD_ADDR_EXP 52
3544: PUSH
3545: LD_INT 1
3547: PPUSH
3548: LD_INT 3
3550: PPUSH
3551: LD_STRING 
3553: PPUSH
3554: LD_INT 7
3556: PUSH
3557: LD_INT 8
3559: PUSH
3560: LD_INT 9
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: PUSH
3568: LD_OWVAR 67
3572: ARRAY
3573: PPUSH
3574: LD_INT 5000
3576: PUSH
3577: LD_INT 1000
3579: PUSH
3580: LD_INT 300
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: PPUSH
3588: LD_INT 22
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 6
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PPUSH
3606: CALL 23557 0 6
3610: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3611: LD_ADDR_EXP 58
3615: PUSH
3616: LD_EXP 58
3620: PPUSH
3621: LD_INT 1
3623: PPUSH
3624: LD_EXP 52
3628: PPUSH
3629: CALL_OW 1
3633: ST_TO_ADDR
// tmp := [ ] ;
3634: LD_ADDR_VAR 0 4
3638: PUSH
3639: EMPTY
3640: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3641: LD_ADDR_OWVAR 37
3645: PUSH
3646: LD_INT 14
3648: ST_TO_ADDR
// vc_engine := engine_siberite ;
3649: LD_ADDR_OWVAR 39
3653: PUSH
3654: LD_INT 3
3656: ST_TO_ADDR
// vc_control := control_manual ;
3657: LD_ADDR_OWVAR 38
3661: PUSH
3662: LD_INT 1
3664: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3665: LD_ADDR_OWVAR 40
3669: PUSH
3670: LD_INT 31
3672: ST_TO_ADDR
// for i = 1 to 3 do
3673: LD_ADDR_VAR 0 2
3677: PUSH
3678: DOUBLE
3679: LD_INT 1
3681: DEC
3682: ST_TO_ADDR
3683: LD_INT 3
3685: PUSH
3686: FOR_TO
3687: IFFALSE 3931
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3689: LD_ADDR_VAR 0 5
3693: PUSH
3694: LD_INT 153
3696: PUSH
3697: LD_INT 71
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 155
3706: PUSH
3707: LD_INT 81
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_VAR 0 2
3722: PUSH
3723: LD_INT 2
3725: MOD
3726: PUSH
3727: LD_INT 1
3729: PLUS
3730: ARRAY
3731: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3732: LD_INT 0
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 7
3740: PUSH
3741: LD_INT 8
3743: PUSH
3744: LD_INT 9
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: PUSH
3752: LD_OWVAR 67
3756: ARRAY
3757: PPUSH
3758: CALL_OW 380
// un := CreateVehicle ;
3762: LD_ADDR_VAR 0 6
3766: PUSH
3767: CALL_OW 45
3771: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3772: LD_VAR 0 6
3776: PPUSH
3777: LD_INT 0
3779: PPUSH
3780: LD_INT 5
3782: PPUSH
3783: CALL_OW 12
3787: PPUSH
3788: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3792: LD_VAR 0 6
3796: PPUSH
3797: LD_VAR 0 5
3801: PUSH
3802: LD_INT 1
3804: ARRAY
3805: PPUSH
3806: LD_VAR 0 5
3810: PUSH
3811: LD_INT 2
3813: ARRAY
3814: PPUSH
3815: LD_INT 6
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 50
// un2 := CreateHuman ;
3825: LD_ADDR_VAR 0 7
3829: PUSH
3830: CALL_OW 44
3834: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3835: LD_VAR 0 7
3839: PPUSH
3840: LD_VAR 0 6
3844: PPUSH
3845: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3849: LD_ADDR_EXP 58
3853: PUSH
3854: LD_EXP 58
3858: PPUSH
3859: LD_INT 1
3861: PUSH
3862: LD_EXP 58
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PUSH
3871: LD_INT 1
3873: PLUS
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: LD_VAR 0 6
3883: PPUSH
3884: CALL 20270 0 3
3888: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3889: LD_ADDR_EXP 58
3893: PUSH
3894: LD_EXP 58
3898: PPUSH
3899: LD_INT 1
3901: PUSH
3902: LD_EXP 58
3906: PUSH
3907: LD_INT 1
3909: ARRAY
3910: PUSH
3911: LD_INT 1
3913: PLUS
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: PPUSH
3919: LD_VAR 0 7
3923: PPUSH
3924: CALL 20270 0 3
3928: ST_TO_ADDR
// end ;
3929: GO 3686
3931: POP
3932: POP
// for i = 1 to 5 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 5
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4040
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3949: LD_INT 14
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 25
3960: PUSH
3961: LD_INT 28
3963: PUSH
3964: LD_INT 28
3966: PUSH
3967: LD_INT 26
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: PUSH
3976: LD_VAR 0 2
3980: PUSH
3981: LD_INT 4
3983: MOD
3984: PUSH
3985: LD_INT 1
3987: PLUS
3988: ARRAY
3989: PPUSH
3990: LD_INT 100
3992: PPUSH
3993: CALL 20148 0 5
// veh := CreateVehicle ;
3997: LD_ADDR_VAR 0 3
4001: PUSH
4002: CALL_OW 45
4006: ST_TO_ADDR
// tmp := tmp ^ veh ;
4007: LD_ADDR_VAR 0 4
4011: PUSH
4012: LD_VAR 0 4
4016: PUSH
4017: LD_VAR 0 3
4021: ADD
4022: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4023: LD_VAR 0 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 49
// end ;
4038: GO 3946
4040: POP
4041: POP
// arabian_guard := tmp ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_VAR 0 4
4051: ST_TO_ADDR
// end ;
4052: LD_VAR 0 1
4056: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4057: LD_INT 22
4059: PUSH
4060: LD_INT 7
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 91
4069: PUSH
4070: LD_INT 1
4072: PUSH
4073: LD_INT 12
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: LIST
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PPUSH
4085: CALL_OW 69
4089: PUSH
4090: LD_EXP 55
4094: PPUSH
4095: CALL_OW 256
4099: PUSH
4100: LD_INT 990
4102: LESS
4103: OR
4104: PUSH
4105: LD_EXP 54
4109: PPUSH
4110: CALL_OW 256
4114: PUSH
4115: LD_INT 990
4117: LESS
4118: OR
4119: IFFALSE 4262
4121: GO 4123
4123: DISABLE
// begin if IsInUnit ( Abdul ) then
4124: LD_EXP 54
4128: PPUSH
4129: CALL_OW 310
4133: IFFALSE 4144
// ComExitBuilding ( Abdul ) ;
4135: LD_EXP 54
4139: PPUSH
4140: CALL_OW 122
// if Mastodont then
4144: LD_EXP 55
4148: IFFALSE 4165
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4150: LD_EXP 55
4154: PPUSH
4155: LD_INT 205
4157: PPUSH
4158: LD_INT 132
4160: PPUSH
4161: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4165: LD_EXP 54
4169: PPUSH
4170: LD_INT 205
4172: PPUSH
4173: LD_INT 132
4175: PPUSH
4176: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4187: LD_EXP 54
4191: PPUSH
4192: LD_INT 21
4194: PPUSH
4195: CALL_OW 308
4199: IFFALSE 4180
// RemoveUnit ( Abdul ) ;
4201: LD_EXP 54
4205: PPUSH
4206: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4210: LD_INT 35
4212: PPUSH
4213: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4217: LD_EXP 55
4221: PPUSH
4222: LD_INT 21
4224: PPUSH
4225: CALL_OW 308
4229: PUSH
4230: LD_EXP 55
4234: PPUSH
4235: CALL_OW 301
4239: OR
4240: IFFALSE 4210
// if IsOk ( Mastodont ) then
4242: LD_EXP 55
4246: PPUSH
4247: CALL_OW 302
4251: IFFALSE 4262
// RemoveUnit ( Mastodont ) ;
4253: LD_EXP 55
4257: PPUSH
4258: CALL_OW 64
// end ;
4262: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4263: LD_EXP 54
4267: PPUSH
4268: CALL_OW 301
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 2
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 2
4285: PUSH
4286: LD_INT 25
4288: PUSH
4289: LD_INT 1
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 25
4298: PUSH
4299: LD_INT 2
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 25
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 25
4318: PUSH
4319: LD_INT 4
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 25
4328: PUSH
4329: LD_INT 8
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL_OW 69
4352: PUSH
4353: LD_INT 16
4355: PUSH
4356: LD_INT 19
4358: PUSH
4359: LD_INT 22
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PUSH
4367: LD_OWVAR 67
4371: ARRAY
4372: LESS
4373: OR
4374: IFFALSE 5047
4376: GO 4378
4378: DISABLE
4379: LD_INT 0
4381: PPUSH
4382: PPUSH
4383: PPUSH
4384: PPUSH
4385: PPUSH
4386: PPUSH
// begin MC_Kill ( 1 ) ;
4387: LD_INT 1
4389: PPUSH
4390: CALL 56158 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4394: LD_ADDR_VAR 0 2
4398: PUSH
4399: LD_INT 22
4401: PUSH
4402: LD_INT 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 25
4414: PUSH
4415: LD_INT 1
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 25
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 25
4434: PUSH
4435: LD_INT 3
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 4
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 25
4454: PUSH
4455: LD_INT 8
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 69
4478: ST_TO_ADDR
// for i in tmp do
4479: LD_ADDR_VAR 0 5
4483: PUSH
4484: LD_VAR 0 2
4488: PUSH
4489: FOR_IN
4490: IFFALSE 4506
// SetTag ( i , 10 ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_INT 10
4499: PPUSH
4500: CALL_OW 109
4504: GO 4489
4506: POP
4507: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: LD_INT 22
4515: PUSH
4516: LD_INT 2
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 21
4525: PUSH
4526: LD_INT 1
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PPUSH
4537: CALL_OW 69
4541: PUSH
4542: LD_VAR 0 2
4546: DIFF
4547: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4548: LD_ADDR_VAR 0 1
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 2
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 21
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: LD_INT 24
4575: PUSH
4576: LD_INT 300
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4593: LD_ADDR_VAR 0 4
4597: PUSH
4598: LD_VAR 0 1
4602: PPUSH
4603: LD_INT 33
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: LD_INT 58
4615: PUSH
4616: EMPTY
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 72
4627: ST_TO_ADDR
// for i in tmp do
4628: LD_ADDR_VAR 0 5
4632: PUSH
4633: LD_VAR 0 2
4637: PUSH
4638: FOR_IN
4639: IFFALSE 4823
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4641: LD_VAR 0 5
4645: PUSH
4646: LD_INT 55
4648: PUSH
4649: EMPTY
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: IN
4657: IFFALSE 4676
// begin AddComMoveXY ( i , 209 , 132 ) ;
4659: LD_VAR 0 5
4663: PPUSH
4664: LD_INT 209
4666: PPUSH
4667: LD_INT 132
4669: PPUSH
4670: CALL_OW 171
// continue ;
4674: GO 4638
// end ; if IsInUnit ( i ) then
4676: LD_VAR 0 5
4680: PPUSH
4681: CALL_OW 310
4685: IFFALSE 4703
// begin ComExitBuilding ( i ) ;
4687: LD_VAR 0 5
4691: PPUSH
4692: CALL_OW 122
// wait ( 3 ) ;
4696: LD_INT 3
4698: PPUSH
4699: CALL_OW 67
// end ; if tmp_empty then
4703: LD_VAR 0 4
4707: IFFALSE 4806
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_VAR 0 4
4718: PPUSH
4719: LD_VAR 0 5
4723: PPUSH
4724: CALL_OW 74
4728: PPUSH
4729: CALL_OW 296
4733: PUSH
4734: LD_INT 25
4736: LESS
4737: IFFALSE 4806
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4739: LD_ADDR_VAR 0 6
4743: PUSH
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 74
4758: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4759: LD_VAR 0 5
4763: PPUSH
4764: LD_VAR 0 6
4768: PPUSH
4769: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4773: LD_VAR 0 5
4777: PPUSH
4778: LD_INT 209
4780: PPUSH
4781: LD_INT 132
4783: PPUSH
4784: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4788: LD_ADDR_VAR 0 4
4792: PUSH
4793: LD_VAR 0 4
4797: PUSH
4798: LD_VAR 0 6
4802: DIFF
4803: ST_TO_ADDR
// continue ;
4804: GO 4638
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4806: LD_VAR 0 5
4810: PPUSH
4811: LD_INT 201
4813: PPUSH
4814: LD_INT 132
4816: PPUSH
4817: CALL_OW 171
// end ;
4821: GO 4638
4823: POP
4824: POP
// for i in tmp_ape do
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_VAR 0 3
4834: PUSH
4835: FOR_IN
4836: IFFALSE 4875
// begin if IsInUnit ( i ) then
4838: LD_VAR 0 5
4842: PPUSH
4843: CALL_OW 310
4847: IFFALSE 4858
// ComExitBuilding ( i ) ;
4849: LD_VAR 0 5
4853: PPUSH
4854: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_INT 201
4865: PPUSH
4866: LD_INT 132
4868: PPUSH
4869: CALL_OW 171
// end ;
4873: GO 4835
4875: POP
4876: POP
// repeat wait ( 0 0$1 ) ;
4877: LD_INT 35
4879: PPUSH
4880: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4884: LD_ADDR_VAR 0 5
4888: PUSH
4889: LD_VAR 0 2
4893: PUSH
4894: LD_VAR 0 3
4898: UNION
4899: PUSH
4900: LD_VAR 0 1
4904: UNION
4905: PUSH
4906: FOR_IN
4907: IFFALSE 4938
// if not HasTask ( i ) then
4909: LD_VAR 0 5
4913: PPUSH
4914: CALL_OW 314
4918: NOT
4919: IFFALSE 4936
// ComMoveXY ( i , 201 , 132 ) ;
4921: LD_VAR 0 5
4925: PPUSH
4926: LD_INT 201
4928: PPUSH
4929: LD_INT 132
4931: PPUSH
4932: CALL_OW 111
4936: GO 4906
4938: POP
4939: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4940: LD_INT 21
4942: PPUSH
4943: LD_INT 22
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 70
4957: IFFALSE 4998
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4959: LD_ADDR_VAR 0 5
4963: PUSH
4964: LD_INT 21
4966: PPUSH
4967: LD_INT 22
4969: PUSH
4970: LD_INT 2
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PPUSH
4977: CALL_OW 70
4981: PUSH
4982: FOR_IN
4983: IFFALSE 4996
// RemoveUnit ( i ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: CALL_OW 64
4994: GO 4982
4996: POP
4997: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
4998: LD_INT 22
5000: PUSH
5001: LD_INT 2
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: LD_INT 21
5013: PUSH
5014: LD_INT 1
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 21
5023: PUSH
5024: LD_INT 2
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: NOT
5045: IFFALSE 4877
// end ;
5047: PPOPN 6
5049: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5050: LD_EXP 9
5054: PUSH
5055: LD_INT 92
5057: PPUSH
5058: LD_INT 40
5060: PPUSH
5061: CALL_OW 428
5065: PPUSH
5066: CALL_OW 266
5070: PUSH
5071: LD_INT 30
5073: EQUAL
5074: AND
5075: IFFALSE 5271
5077: GO 5079
5079: DISABLE
5080: LD_INT 0
5082: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5083: LD_ADDR_VAR 0 1
5087: PUSH
5088: LD_EXP 58
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: PPUSH
5097: LD_INT 25
5099: PUSH
5100: LD_INT 4
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 72
5111: ST_TO_ADDR
// if not sci then
5112: LD_VAR 0 1
5116: NOT
5117: IFFALSE 5121
// exit ;
5119: GO 5271
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5121: LD_ADDR_EXP 58
5125: PUSH
5126: LD_EXP 58
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_EXP 58
5138: PUSH
5139: LD_INT 1
5141: ARRAY
5142: PUSH
5143: LD_VAR 0 1
5147: PUSH
5148: LD_INT 1
5150: ARRAY
5151: DIFF
5152: PPUSH
5153: CALL_OW 1
5157: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5158: LD_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ARRAY
5166: PPUSH
5167: CALL_OW 310
5171: IFFALSE 5186
// ComExitBuilding ( sci [ 1 ] ) ;
5173: LD_VAR 0 1
5177: PUSH
5178: LD_INT 1
5180: ARRAY
5181: PPUSH
5182: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5186: LD_INT 2
5188: PPUSH
5189: LD_INT 105
5191: PPUSH
5192: LD_INT 14
5194: PPUSH
5195: LD_INT 20
5197: PPUSH
5198: CALL 21166 0 4
5202: PUSH
5203: LD_INT 4
5205: ARRAY
5206: PUSH
5207: LD_INT 10
5209: LESS
5210: IFFALSE 5233
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5212: LD_VAR 0 1
5216: PUSH
5217: LD_INT 1
5219: ARRAY
5220: PPUSH
5221: LD_INT 105
5223: PPUSH
5224: LD_INT 14
5226: PPUSH
5227: CALL_OW 171
5231: GO 5252
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5233: LD_VAR 0 1
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PPUSH
5242: LD_INT 118
5244: PPUSH
5245: LD_INT 77
5247: PPUSH
5248: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5252: LD_VAR 0 1
5256: PUSH
5257: LD_INT 1
5259: ARRAY
5260: PPUSH
5261: LD_INT 92
5263: PPUSH
5264: LD_INT 40
5266: PPUSH
5267: CALL_OW 218
// end ;
5271: PPOPN 1
5273: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5274: LD_INT 1
5276: PPUSH
5277: CALL_OW 302
5281: PUSH
5282: LD_EXP 9
5286: AND
5287: IFFALSE 5757
5289: GO 5291
5291: DISABLE
5292: LD_INT 0
5294: PPUSH
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
5299: PPUSH
// begin enable ;
5300: ENABLE
// base := 1 ;
5301: LD_ADDR_VAR 0 2
5305: PUSH
5306: LD_INT 1
5308: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5309: LD_ADDR_VAR 0 4
5313: PUSH
5314: LD_INT 0
5316: PUSH
5317: LD_INT 0
5319: PUSH
5320: LD_INT 0
5322: PUSH
5323: LD_INT 0
5325: PUSH
5326: LD_INT 0
5328: PUSH
5329: LD_INT 0
5331: PUSH
5332: LD_INT 0
5334: PUSH
5335: LD_INT 0
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: LD_INT 0
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: LIST
5355: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5356: LD_ADDR_VAR 0 3
5360: PUSH
5361: LD_INT 14
5363: PUSH
5364: LD_INT 1
5366: PUSH
5367: LD_INT 2
5369: PUSH
5370: LD_INT 26
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 14
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: LD_INT 2
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 13
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 2
5405: PUSH
5406: LD_INT 29
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5420: LD_ADDR_VAR 0 1
5424: PUSH
5425: DOUBLE
5426: LD_INT 1
5428: DEC
5429: ST_TO_ADDR
5430: LD_OWVAR 67
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 21000
5442: DIV
5443: PLUS
5444: PUSH
5445: FOR_TO
5446: IFFALSE 5538
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5448: LD_ADDR_VAR 0 3
5452: PUSH
5453: LD_VAR 0 3
5457: PPUSH
5458: LD_VAR 0 3
5462: PUSH
5463: LD_INT 1
5465: PLUS
5466: PPUSH
5467: LD_INT 13
5469: PUSH
5470: LD_INT 14
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 1
5479: PPUSH
5480: LD_INT 2
5482: PPUSH
5483: CALL_OW 12
5487: ARRAY
5488: PUSH
5489: LD_INT 1
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: LD_INT 28
5497: PUSH
5498: LD_INT 29
5500: PUSH
5501: LD_INT 25
5503: PUSH
5504: LD_INT 26
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 1
5515: PPUSH
5516: LD_INT 4
5518: PPUSH
5519: CALL_OW 12
5523: ARRAY
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PPUSH
5531: CALL_OW 2
5535: ST_TO_ADDR
5536: GO 5445
5538: POP
5539: POP
// MC_SetProduceList ( base , tmp ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_VAR 0 3
5549: PPUSH
5550: CALL 77866 0 2
// repeat wait ( 0 0$1 ) ;
5554: LD_INT 35
5556: PPUSH
5557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL 78320 0 1
5570: PUSH
5571: LD_INT 0
5573: EQUAL
5574: IFFALSE 5554
// wait ( 0 0$20 ) ;
5576: LD_INT 700
5578: PPUSH
5579: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5583: LD_ADDR_VAR 0 5
5587: PUSH
5588: LD_INT 124
5590: PUSH
5591: LD_INT 85
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 90
5600: PUSH
5601: LD_INT 61
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 69
5610: PUSH
5611: LD_INT 48
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 68
5620: PUSH
5621: LD_INT 48
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
5634: LD_ADDR_VAR 0 6
5638: PUSH
5639: LD_EXP 77
5643: PUSH
5644: LD_VAR 0 2
5648: ARRAY
5649: PUSH
5650: LD_EXP 80
5654: PUSH
5655: LD_VAR 0 2
5659: ARRAY
5660: PUSH
5661: LD_EXP 77
5665: PUSH
5666: LD_VAR 0 2
5670: ARRAY
5671: PPUSH
5672: LD_INT 34
5674: PUSH
5675: LD_INT 32
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PPUSH
5682: CALL_OW 72
5686: UNION
5687: DIFF
5688: ST_TO_ADDR
// if not attackers then
5689: LD_VAR 0 6
5693: NOT
5694: IFFALSE 5698
// exit ;
5696: GO 5757
// ar_attackers := attackers ;
5698: LD_ADDR_EXP 10
5702: PUSH
5703: LD_VAR 0 6
5707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5715: LD_VAR 0 6
5719: PPUSH
5720: LD_INT 60
5722: PUSH
5723: EMPTY
5724: LIST
5725: PPUSH
5726: CALL_OW 72
5730: NOT
5731: IFFALSE 5708
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5733: LD_VAR 0 2
5737: PPUSH
5738: LD_VAR 0 6
5742: PPUSH
5743: LD_VAR 0 5
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL 78157 0 4
// end ;
5757: PPOPN 6
5759: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5760: LD_INT 1
5762: PPUSH
5763: CALL_OW 302
5767: PUSH
5768: LD_EXP 9
5772: AND
5773: PUSH
5774: LD_EXP 48
5778: PPUSH
5779: LD_INT 22
5781: PPUSH
5782: CALL_OW 308
5786: AND
5787: PUSH
5788: LD_INT 1
5790: PPUSH
5791: CALL 78320 0 1
5795: PUSH
5796: LD_INT 0
5798: EQUAL
5799: AND
5800: PUSH
5801: LD_EXP 10
5805: NOT
5806: AND
5807: IFFALSE 6282
5809: GO 5811
5811: DISABLE
5812: LD_INT 0
5814: PPUSH
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
// begin base := 1 ;
5821: LD_ADDR_VAR 0 2
5825: PUSH
5826: LD_INT 1
5828: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 0
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: LD_INT 0
5848: PUSH
5849: LD_INT 0
5851: PUSH
5852: LD_INT 0
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 0
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 13
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 27
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 13
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: LD_INT 25
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 11
5937: PUSH
5938: LD_INT 2
5940: PUSH
5941: LD_INT 2
5943: PUSH
5944: LD_INT 24
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 11
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 24
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// MC_SetProduceList ( base , tmp ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL 77866 0 2
// repeat wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 78320 0 1
6008: PUSH
6009: LD_INT 0
6011: EQUAL
6012: IFFALSE 5992
// wait ( 0 0$20 ) ;
6014: LD_INT 700
6016: PPUSH
6017: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6021: LD_ADDR_VAR 0 5
6025: PUSH
6026: LD_INT 119
6028: PUSH
6029: LD_INT 9
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PUSH
6036: EMPTY
6037: LIST
6038: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
6039: LD_ADDR_VAR 0 6
6043: PUSH
6044: LD_EXP 77
6048: PUSH
6049: LD_VAR 0 2
6053: ARRAY
6054: PUSH
6055: LD_EXP 80
6059: PUSH
6060: LD_VAR 0 2
6064: ARRAY
6065: PUSH
6066: LD_EXP 77
6070: PUSH
6071: LD_VAR 0 2
6075: ARRAY
6076: PPUSH
6077: LD_INT 34
6079: PUSH
6080: LD_INT 32
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: UNION
6092: DIFF
6093: ST_TO_ADDR
// if not attackers then
6094: LD_VAR 0 6
6098: NOT
6099: IFFALSE 6103
// exit ;
6101: GO 6282
// uc_side := 2 ;
6103: LD_ADDR_OWVAR 20
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// uc_nation := 2 ;
6111: LD_ADDR_OWVAR 21
6115: PUSH
6116: LD_INT 2
6118: ST_TO_ADDR
// InitHc ;
6119: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: DOUBLE
6129: LD_INT 1
6131: DEC
6132: ST_TO_ADDR
6133: LD_INT 4
6135: PUSH
6136: LD_INT 5
6138: PUSH
6139: LD_INT 6
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_OWVAR 67
6151: ARRAY
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6231
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6156: LD_INT 0
6158: PPUSH
6159: LD_INT 15
6161: PUSH
6162: LD_INT 17
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: PPUSH
6181: LD_INT 8
6183: PPUSH
6184: CALL_OW 380
// un := CreateHuman ;
6188: LD_ADDR_VAR 0 7
6192: PUSH
6193: CALL_OW 44
6197: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6198: LD_VAR 0 7
6202: PPUSH
6203: LD_INT 23
6205: PPUSH
6206: LD_INT 0
6208: PPUSH
6209: CALL_OW 49
// attackers := attackers union un ;
6213: LD_ADDR_VAR 0 6
6217: PUSH
6218: LD_VAR 0 6
6222: PUSH
6223: LD_VAR 0 7
6227: UNION
6228: ST_TO_ADDR
// end ;
6229: GO 6153
6231: POP
6232: POP
// repeat wait ( 0 0$1 ) ;
6233: LD_INT 35
6235: PPUSH
6236: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6240: LD_VAR 0 6
6244: PPUSH
6245: LD_INT 60
6247: PUSH
6248: EMPTY
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: NOT
6256: IFFALSE 6233
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6258: LD_VAR 0 2
6262: PPUSH
6263: LD_VAR 0 6
6267: PPUSH
6268: LD_VAR 0 5
6272: PPUSH
6273: LD_VAR 0 4
6277: PPUSH
6278: CALL 78157 0 4
// end ; end_of_file
6282: PPOPN 7
6284: END
// export function PrepareAmericanAttack ; var i , tmp , veh , flags , _target ; begin
6285: LD_INT 0
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
6291: PPUSH
6292: PPUSH
// uc_side := 1 ;
6293: LD_ADDR_OWVAR 20
6297: PUSH
6298: LD_INT 1
6300: ST_TO_ADDR
// uc_nation := 1 ;
6301: LD_ADDR_OWVAR 21
6305: PUSH
6306: LD_INT 1
6308: ST_TO_ADDR
// InitHc ;
6309: CALL_OW 19
// InitVc ;
6313: CALL_OW 20
// tmp := [ ] ;
6317: LD_ADDR_VAR 0 3
6321: PUSH
6322: EMPTY
6323: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6324: LD_ADDR_VAR 0 5
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_INT 0
6334: PUSH
6335: LD_INT 0
6337: PUSH
6338: LD_INT 0
6340: PUSH
6341: LD_INT 0
6343: PUSH
6344: LD_INT 0
6346: PUSH
6347: LD_INT 0
6349: PUSH
6350: LD_INT 0
6352: PUSH
6353: LD_INT 1
6355: PUSH
6356: LD_INT 0
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: ST_TO_ADDR
// _target := [ [ 71 , 34 ] , [ 63 , 49 ] ] ;
6371: LD_ADDR_VAR 0 6
6375: PUSH
6376: LD_INT 71
6378: PUSH
6379: LD_INT 34
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 63
6388: PUSH
6389: LD_INT 49
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6400: LD_ADDR_VAR 0 2
6404: PUSH
6405: DOUBLE
6406: LD_INT 1
6408: DEC
6409: ST_TO_ADDR
6410: LD_INT 5
6412: PUSH
6413: LD_INT 6
6415: PUSH
6416: LD_INT 6
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_OWVAR 67
6428: ARRAY
6429: PUSH
6430: FOR_TO
6431: IFFALSE 6568
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6433: LD_INT 2
6435: PUSH
6436: LD_INT 4
6438: PUSH
6439: LD_INT 5
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 1
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: CALL_OW 12
6457: ARRAY
6458: PPUSH
6459: LD_INT 1
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 2
6474: PPUSH
6475: CALL_OW 12
6479: ARRAY
6480: PPUSH
6481: LD_INT 3
6483: PPUSH
6484: LD_INT 9
6486: PUSH
6487: LD_INT 7
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 1
6496: PPUSH
6497: LD_INT 2
6499: PPUSH
6500: CALL_OW 12
6504: ARRAY
6505: PPUSH
6506: LD_INT 78
6508: PPUSH
6509: CALL 20148 0 5
// veh := CreateVehicle ;
6513: LD_ADDR_VAR 0 4
6517: PUSH
6518: CALL_OW 45
6522: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 2
6530: PPUSH
6531: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6535: LD_VAR 0 4
6539: PPUSH
6540: LD_INT 17
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// tmp := tmp ^ veh ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 4
6564: ADD
6565: ST_TO_ADDR
// end ;
6566: GO 6430
6568: POP
6569: POP
// if not tmp then
6570: LD_VAR 0 3
6574: NOT
6575: IFFALSE 6579
// exit ;
6577: GO 6622
// if not first_powell_attack then
6579: LD_EXP 11
6583: NOT
6584: IFFALSE 6594
// first_powell_attack := true ;
6586: LD_ADDR_EXP 11
6590: PUSH
6591: LD_INT 1
6593: ST_TO_ADDR
// Attack ( [ 0 , tmp , _target , flags ] ) ;
6594: LD_INT 0
6596: PUSH
6597: LD_VAR 0 3
6601: PUSH
6602: LD_VAR 0 6
6606: PUSH
6607: LD_VAR 0 5
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PPUSH
6618: CALL 48723 0 1
// end ; end_of_file
6622: LD_VAR 0 1
6626: RET
// export function Action ; var tmp , i , un ; begin
6627: LD_INT 0
6629: PPUSH
6630: PPUSH
6631: PPUSH
6632: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6633: LD_INT 68
6635: PPUSH
6636: LD_INT 39
6638: PPUSH
6639: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6643: LD_ADDR_VAR 0 2
6647: PUSH
6648: LD_INT 22
6650: PUSH
6651: LD_INT 7
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PPUSH
6658: CALL_OW 69
6662: ST_TO_ADDR
// InGameOn ;
6663: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 71
6674: PPUSH
6675: LD_INT 49
6677: PPUSH
6678: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6682: LD_INT 35
6684: PPUSH
6685: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6689: LD_INT 7
6691: PPUSH
6692: LD_INT 71
6694: PPUSH
6695: LD_INT 51
6697: PPUSH
6698: CALL_OW 293
6702: IFFALSE 6682
// DialogueOn ;
6704: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6708: LD_EXP 14
6712: PPUSH
6713: LD_STRING D1-JMM-1
6715: PPUSH
6716: CALL_OW 88
// if Joan then
6720: LD_EXP 29
6724: IFFALSE 6738
// Say ( Joan , D1-Joan-1 ) ;
6726: LD_EXP 29
6730: PPUSH
6731: LD_STRING D1-Joan-1
6733: PPUSH
6734: CALL_OW 88
// if Lisa then
6738: LD_EXP 16
6742: IFFALSE 6756
// Say ( Lisa , D1-Lisa-1 ) ;
6744: LD_EXP 16
6748: PPUSH
6749: LD_STRING D1-Lisa-1
6751: PPUSH
6752: CALL_OW 88
// if Joan or Lisa then
6756: LD_EXP 29
6760: PUSH
6761: LD_EXP 16
6765: OR
6766: IFFALSE 6780
// Say ( JMM , D1-JMM-2 ) ;
6768: LD_EXP 14
6772: PPUSH
6773: LD_STRING D1-JMM-2
6775: PPUSH
6776: CALL_OW 88
// DialogueOff ;
6780: CALL_OW 7
// InGameOff ;
6784: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6788: LD_INT 71
6790: PPUSH
6791: LD_INT 50
6793: PPUSH
6794: LD_INT 7
6796: PPUSH
6797: LD_INT 30
6799: NEG
6800: PPUSH
6801: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6805: LD_INT 71
6807: PPUSH
6808: LD_INT 50
6810: PPUSH
6811: LD_INT 7
6813: PPUSH
6814: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6818: LD_STRING M1
6820: PPUSH
6821: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6825: LD_INT 35
6827: PPUSH
6828: CALL_OW 67
// until freedom ;
6832: LD_EXP 3
6836: IFFALSE 6825
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6838: LD_INT 350
6840: PPUSH
6841: LD_INT 700
6843: PPUSH
6844: CALL_OW 12
6848: PPUSH
6849: CALL_OW 67
// PrepareGossudarov ;
6853: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6857: LD_INT 35
6859: PPUSH
6860: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6864: LD_INT 22
6866: PUSH
6867: LD_INT 6
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: LD_INT 24
6879: PUSH
6880: LD_INT 1000
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: PPUSH
6895: CALL_OW 69
6899: IFFALSE 6857
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6901: LD_ADDR_VAR 0 2
6905: PUSH
6906: LD_INT 22
6908: PUSH
6909: LD_INT 6
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for i in tmp do
6921: LD_ADDR_VAR 0 3
6925: PUSH
6926: LD_VAR 0 2
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6948
// SetSide ( i , 7 ) ;
6934: LD_VAR 0 3
6938: PPUSH
6939: LD_INT 7
6941: PPUSH
6942: CALL_OW 235
6946: GO 6931
6948: POP
6949: POP
// DialogueOn ;
6950: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6954: LD_EXP 14
6958: PUSH
6959: LD_EXP 15
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6977: LD_EXP 31
6981: PPUSH
6982: CALL_OW 87
// if not Roth then
6986: LD_EXP 15
6990: NOT
6991: IFFALSE 7055
// begin Say ( JMM , D2-JMM-1 ) ;
6993: LD_EXP 14
6997: PPUSH
6998: LD_STRING D2-JMM-1
7000: PPUSH
7001: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7005: LD_EXP 14
7009: PPUSH
7010: LD_STRING D2-JMM-1b
7012: PPUSH
7013: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7017: LD_EXP 31
7021: PPUSH
7022: LD_STRING D2-Gos-1
7024: PPUSH
7025: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7029: LD_EXP 14
7033: PPUSH
7034: LD_STRING D2-JMM-2
7036: PPUSH
7037: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7041: LD_EXP 31
7045: PPUSH
7046: LD_STRING D2-Gos-2
7048: PPUSH
7049: CALL_OW 88
// end else
7053: GO 7151
// begin Say ( Roth , D2-Roth-2 ) ;
7055: LD_EXP 15
7059: PPUSH
7060: LD_STRING D2-Roth-2
7062: PPUSH
7063: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7067: LD_EXP 14
7071: PPUSH
7072: LD_STRING D2-JMM-1a
7074: PPUSH
7075: CALL_OW 88
// Say ( Roth , D2-Roth-2a ) ;
7079: LD_EXP 15
7083: PPUSH
7084: LD_STRING D2-Roth-2a
7086: PPUSH
7087: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7091: LD_EXP 15
7095: PPUSH
7096: LD_STRING D2-Roth-2b
7098: PPUSH
7099: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7103: LD_EXP 14
7107: PPUSH
7108: LD_STRING D2-JMM-3
7110: PPUSH
7111: CALL_OW 88
// Say ( Gossudarov , D2-Gos-3 ) ;
7115: LD_EXP 31
7119: PPUSH
7120: LD_STRING D2-Gos-3
7122: PPUSH
7123: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7127: LD_EXP 14
7131: PPUSH
7132: LD_STRING D2-JMM-4
7134: PPUSH
7135: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7139: LD_EXP 31
7143: PPUSH
7144: LD_STRING D2-Gos-4
7146: PPUSH
7147: CALL_OW 88
// end ; Say ( JMM , D2-JMM-5 ) ;
7151: LD_EXP 14
7155: PPUSH
7156: LD_STRING D2-JMM-5
7158: PPUSH
7159: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7163: LD_EXP 31
7167: PPUSH
7168: LD_STRING D2-Gos-5
7170: PPUSH
7171: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7175: LD_EXP 14
7179: PPUSH
7180: LD_STRING D2-JMM-6
7182: PPUSH
7183: CALL_OW 88
// DialogueOff ;
7187: CALL_OW 7
// wait ( 0 0$2 ) ;
7191: LD_INT 70
7193: PPUSH
7194: CALL_OW 67
// if Kirilenkova then
7198: LD_EXP 32
7202: IFFALSE 7216
// Say ( Kirilenkova , D3-Kir-1 ) ;
7204: LD_EXP 32
7208: PPUSH
7209: LD_STRING D3-Kir-1
7211: PPUSH
7212: CALL_OW 88
// gossudarov_arrive := true ;
7216: LD_ADDR_EXP 4
7220: PUSH
7221: LD_INT 1
7223: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7224: LD_INT 35
7226: PPUSH
7227: CALL_OW 67
// until ru_lab_builded ;
7231: LD_EXP 5
7235: IFFALSE 7224
// if Kirilenkova then
7237: LD_EXP 32
7241: IFFALSE 7257
// Say ( Kirilenkova , D3a-Kir-1 ) else
7243: LD_EXP 32
7247: PPUSH
7248: LD_STRING D3a-Kir-1
7250: PPUSH
7251: CALL_OW 88
7255: GO 7279
// begin un := SciRu ;
7257: LD_ADDR_VAR 0 4
7261: PUSH
7262: CALL 12046 0 0
7266: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7267: LD_VAR 0 4
7271: PPUSH
7272: LD_STRING D3a-Sci1-1
7274: PPUSH
7275: CALL_OW 88
// end ; if Kirilenkova or un then
7279: LD_EXP 32
7283: PUSH
7284: LD_VAR 0 4
7288: OR
7289: IFFALSE 7303
// Say ( JMM , D3a-JMM-1 ) ;
7291: LD_EXP 14
7295: PPUSH
7296: LD_STRING D3a-JMM-1
7298: PPUSH
7299: CALL_OW 88
// end ;
7303: LD_VAR 0 1
7307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7308: LD_EXP 4
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_INT 7
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 1
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: LD_INT 25
7338: PUSH
7339: LD_INT 2
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PUSH
7346: LD_INT 25
7348: PUSH
7349: LD_INT 3
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 25
7358: PUSH
7359: LD_INT 4
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: PUSH
7366: LD_INT 25
7368: PUSH
7369: LD_INT 5
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PUSH
7376: LD_INT 25
7378: PUSH
7379: LD_INT 8
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 25
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PPUSH
7410: CALL_OW 69
7414: PUSH
7415: LD_INT 6
7417: LESS
7418: AND
7419: IFFALSE 7431
7421: GO 7423
7423: DISABLE
// YouLost ( TooMany ) ;
7424: LD_STRING TooMany
7426: PPUSH
7427: CALL_OW 104
7431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7432: LD_EXP 31
7436: PPUSH
7437: CALL_OW 255
7441: PUSH
7442: LD_INT 7
7444: EQUAL
7445: IFFALSE 7645
7447: GO 7449
7449: DISABLE
7450: LD_INT 0
7452: PPUSH
7453: PPUSH
7454: PPUSH
// begin uc_side := 3 ;
7455: LD_ADDR_OWVAR 20
7459: PUSH
7460: LD_INT 3
7462: ST_TO_ADDR
// uc_nation := 3 ;
7463: LD_ADDR_OWVAR 21
7467: PUSH
7468: LD_INT 3
7470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7471: LD_INT 21
7473: PPUSH
7474: LD_INT 3
7476: PPUSH
7477: LD_INT 3
7479: PPUSH
7480: LD_INT 42
7482: PPUSH
7483: LD_INT 100
7485: PPUSH
7486: CALL 20148 0 5
// un := CreateVehicle ;
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: CALL_OW 45
7499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7500: LD_VAR 0 3
7504: PPUSH
7505: LD_INT 15
7507: PPUSH
7508: LD_INT 0
7510: PPUSH
7511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7515: LD_VAR 0 3
7519: PPUSH
7520: LD_INT 67
7522: PPUSH
7523: LD_INT 45
7525: PPUSH
7526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7530: LD_VAR 0 3
7534: PPUSH
7535: LD_INT 70
7537: PPUSH
7538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7542: LD_VAR 0 3
7546: PPUSH
7547: LD_INT 69
7549: PPUSH
7550: LD_INT 18
7552: PPUSH
7553: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7557: LD_VAR 0 3
7561: PPUSH
7562: LD_INT 60
7564: PPUSH
7565: LD_INT 2
7567: PPUSH
7568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7572: LD_INT 35
7574: PPUSH
7575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7579: LD_VAR 0 3
7583: PPUSH
7584: CALL_OW 302
7588: NOT
7589: PUSH
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 17
7597: PPUSH
7598: CALL_OW 308
7602: OR
7603: IFFALSE 7572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 17
7612: PPUSH
7613: CALL_OW 308
7617: PUSH
7618: LD_VAR 0 3
7622: PPUSH
7623: LD_INT 60
7625: PPUSH
7626: LD_INT 2
7628: PPUSH
7629: CALL_OW 307
7633: OR
7634: IFFALSE 7645
// RemoveUnit ( un ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 64
// end ;
7645: PPOPN 3
7647: END
// every 0 0$2 do var i , un , tmp ;
7648: GO 7650
7650: DISABLE
7651: LD_INT 0
7653: PPUSH
7654: PPUSH
7655: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7656: LD_INT 70
7658: PPUSH
7659: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7663: LD_ADDR_VAR 0 3
7667: PUSH
7668: LD_INT 22
7670: PUSH
7671: LD_INT 7
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 101
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PPUSH
7692: CALL_OW 69
7696: ST_TO_ADDR
// until tmp ;
7697: LD_VAR 0 3
7701: IFFALSE 7656
// un := NearestUnitToUnit ( tmp , JMM ) ;
7703: LD_ADDR_VAR 0 2
7707: PUSH
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_EXP 14
7717: PPUSH
7718: CALL_OW 74
7722: ST_TO_ADDR
// player_spotted := true ;
7723: LD_ADDR_EXP 6
7727: PUSH
7728: LD_INT 1
7730: ST_TO_ADDR
// tmp := SciRu ;
7731: LD_ADDR_VAR 0 3
7735: PUSH
7736: CALL 12046 0 0
7740: ST_TO_ADDR
// DialogueOn ;
7741: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7745: LD_VAR 0 2
7749: PPUSH
7750: CALL_OW 250
7754: PPUSH
7755: LD_VAR 0 2
7759: PPUSH
7760: CALL_OW 251
7764: PPUSH
7765: LD_INT 7
7767: PPUSH
7768: LD_INT 8
7770: NEG
7771: PPUSH
7772: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: CALL_OW 87
// if tmp then
7785: LD_VAR 0 3
7789: IFFALSE 7803
// Say ( tmp , D4-RSci1-1 ) ;
7791: LD_VAR 0 3
7795: PPUSH
7796: LD_STRING D4-RSci1-1
7798: PPUSH
7799: CALL_OW 88
// if Gossudarov then
7803: LD_EXP 31
7807: IFFALSE 7833
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7809: LD_EXP 31
7813: PPUSH
7814: LD_STRING D4-Gos-1
7816: PPUSH
7817: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7821: LD_EXP 14
7825: PPUSH
7826: LD_STRING D4-JMM-1
7828: PPUSH
7829: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7833: LD_VAR 0 2
7837: PPUSH
7838: CALL_OW 250
7842: PPUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: CALL_OW 251
7852: PPUSH
7853: LD_INT 7
7855: PPUSH
7856: CALL_OW 331
// DialogueOff ;
7860: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7864: LD_STRING M5
7866: PPUSH
7867: CALL_OW 337
// end ;
7871: PPOPN 3
7873: END
// every 0 0$30 + 2 2$30 trigger player_spotted do
7874: LD_EXP 6
7878: IFFALSE 8337
7880: GO 7882
7882: DISABLE
// begin PrepareBelkov ;
7883: CALL 1934 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7887: LD_EXP 46
7891: PPUSH
7892: LD_INT 118
7894: PPUSH
7895: LD_INT 106
7897: PPUSH
7898: CALL_OW 111
// AddComHold ( Belkov ) ;
7902: LD_EXP 46
7906: PPUSH
7907: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
7911: LD_INT 35
7913: PPUSH
7914: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
7918: LD_EXP 46
7922: PPUSH
7923: LD_INT 118
7925: PPUSH
7926: LD_INT 106
7928: PPUSH
7929: CALL_OW 307
7933: IFFALSE 7911
// ChangeSideFog ( 4 , 7 ) ;
7935: LD_INT 4
7937: PPUSH
7938: LD_INT 7
7940: PPUSH
7941: CALL_OW 343
// if IsOk ( Belkov ) then
7945: LD_EXP 46
7949: PPUSH
7950: CALL_OW 302
7954: IFFALSE 8038
// begin InGameOn ;
7956: CALL_OW 8
// DialogueOn ;
7960: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
7964: LD_EXP 46
7968: PPUSH
7969: LD_STRING D5-Bel-1
7971: PPUSH
7972: CALL_OW 94
// if Gossudarov then
7976: LD_EXP 31
7980: IFFALSE 8030
// begin Say ( Gossudarov , D5-Gos-1 ) ;
7982: LD_EXP 31
7986: PPUSH
7987: LD_STRING D5-Gos-1
7989: PPUSH
7990: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
7994: LD_EXP 14
7998: PPUSH
7999: LD_STRING D5-JMM-1
8001: PPUSH
8002: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8006: LD_EXP 31
8010: PPUSH
8011: LD_STRING D5-Gos-2
8013: PPUSH
8014: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8018: LD_EXP 14
8022: PPUSH
8023: LD_STRING D5-JMM-2
8025: PPUSH
8026: CALL_OW 88
// end ; DialogueOff ;
8030: CALL_OW 7
// InGameOff ;
8034: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8038: LD_STRING QSaveBelkov
8040: PPUSH
8041: CALL_OW 97
8045: PUSH
8046: LD_INT 1
8048: DOUBLE
8049: EQUAL
8050: IFTRUE 8054
8052: GO 8104
8054: POP
// begin DialogueOn ;
8055: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8059: LD_EXP 14
8063: PPUSH
8064: LD_STRING D5a-JMM-1
8066: PPUSH
8067: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8071: LD_EXP 46
8075: PPUSH
8076: LD_STRING D5a-Bel-1
8078: PPUSH
8079: CALL_OW 94
// DialogueOff ;
8083: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8087: LD_EXP 46
8091: PPUSH
8092: LD_INT 83
8094: PPUSH
8095: LD_INT 49
8097: PPUSH
8098: CALL_OW 111
// end ; 2 :
8102: GO 8164
8104: LD_INT 2
8106: DOUBLE
8107: EQUAL
8108: IFTRUE 8112
8110: GO 8163
8112: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8113: LD_EXP 14
8117: PPUSH
8118: LD_STRING D5a-JMM-2
8120: PPUSH
8121: CALL_OW 88
// ComWait ( Belkov , 0 0$10 ) ;
8125: LD_EXP 46
8129: PPUSH
8130: LD_INT 350
8132: PPUSH
8133: CALL_OW 142
// AddComMoveXY ( Belkov , 107 , 109 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_INT 107
8144: PPUSH
8145: LD_INT 109
8147: PPUSH
8148: CALL_OW 171
// AddComHold ( Belkov ) ;
8152: LD_EXP 46
8156: PPUSH
8157: CALL_OW 200
// end ; end ;
8161: GO 8164
8163: POP
// repeat wait ( 0 0$1 ) ;
8164: LD_INT 35
8166: PPUSH
8167: CALL_OW 67
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8171: LD_EXP 46
8175: PPUSH
8176: CALL_OW 301
8180: PUSH
8181: LD_EXP 46
8185: PPUSH
8186: CALL_OW 255
8190: PUSH
8191: LD_INT 4
8193: EQUAL
8194: AND
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 7
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PPUSH
8206: CALL_OW 69
8210: PPUSH
8211: LD_EXP 46
8215: PPUSH
8216: CALL_OW 74
8220: PPUSH
8221: LD_EXP 46
8225: PPUSH
8226: CALL_OW 296
8230: PUSH
8231: LD_INT 10
8233: LESS
8234: OR
8235: IFFALSE 8164
// if IsDead ( Belkov ) then
8237: LD_EXP 46
8241: PPUSH
8242: CALL_OW 301
8246: IFFALSE 8271
// begin CenterNowOnUnits ( Belkov ) ;
8248: LD_EXP 46
8252: PPUSH
8253: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8257: LD_EXP 14
8261: PPUSH
8262: LD_STRING D5a-JMM-2a
8264: PPUSH
8265: CALL_OW 88
// exit ;
8269: GO 8337
// end ; if See ( 7 , Belkov ) then
8271: LD_INT 7
8273: PPUSH
8274: LD_EXP 46
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8297
// SetSide ( Belkov , 7 ) ;
8285: LD_EXP 46
8289: PPUSH
8290: LD_INT 7
8292: PPUSH
8293: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8304: LD_EXP 46
8308: PPUSH
8309: LD_INT 66
8311: PPUSH
8312: LD_INT 45
8314: PPUSH
8315: CALL_OW 297
8319: PUSH
8320: LD_INT 30
8322: LESS
8323: IFFALSE 8297
// Say ( Belkov , D6-Bel-1 ) ;
8325: LD_EXP 46
8329: PPUSH
8330: LD_STRING D6-Bel-1
8332: PPUSH
8333: CALL_OW 88
// end ;
8337: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8338: LD_EXP 46
8342: PPUSH
8343: CALL_OW 302
8347: PUSH
8348: LD_EXP 46
8352: PPUSH
8353: CALL_OW 504
8357: PUSH
8358: LD_INT 2
8360: PUSH
8361: LD_INT 34
8363: PUSH
8364: LD_INT 47
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PUSH
8371: LD_INT 34
8373: PUSH
8374: LD_INT 45
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: PPUSH
8386: CALL_OW 69
8390: IN
8391: AND
8392: IFFALSE 8409
8394: GO 8396
8396: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8397: LD_EXP 46
8401: PPUSH
8402: LD_STRING D7-Bel-1
8404: PPUSH
8405: CALL_OW 88
8409: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8410: LD_INT 22
8412: PUSH
8413: LD_INT 7
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 101
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PPUSH
8434: CALL_OW 69
8438: PUSH
8439: LD_EXP 8
8443: NOT
8444: AND
8445: PUSH
8446: LD_EXP 45
8450: PPUSH
8451: CALL_OW 305
8455: NOT
8456: AND
8457: IFFALSE 8927
8459: GO 8461
8461: DISABLE
8462: LD_INT 0
8464: PPUSH
// begin ar_base_spotted := true ;
8465: LD_ADDR_EXP 8
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 21
8490: PUSH
8491: LD_INT 3
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8507: LD_ADDR_VAR 0 1
8511: PUSH
8512: LD_VAR 0 1
8516: PPUSH
8517: LD_EXP 14
8521: PPUSH
8522: CALL_OW 74
8526: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8527: LD_INT 7
8529: PPUSH
8530: LD_INT 3
8532: PPUSH
8533: CALL_OW 332
// DialogueOn ;
8537: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8541: LD_VAR 0 1
8545: PPUSH
8546: CALL_OW 250
8550: PPUSH
8551: LD_VAR 0 1
8555: PPUSH
8556: CALL_OW 251
8560: PPUSH
8561: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_INT 22
8572: PUSH
8573: LD_INT 7
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PUSH
8580: LD_INT 23
8582: PUSH
8583: LD_INT 1
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PUSH
8590: LD_INT 26
8592: PUSH
8593: LD_INT 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: LIST
8604: PPUSH
8605: CALL_OW 69
8609: PUSH
8610: LD_EXP 14
8614: PUSH
8615: LD_EXP 18
8619: PUSH
8620: LD_EXP 19
8624: PUSH
8625: LD_EXP 26
8629: PUSH
8630: LD_EXP 15
8634: PUSH
8635: LD_EXP 24
8639: PUSH
8640: LD_EXP 20
8644: PUSH
8645: LD_EXP 22
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: DIFF
8660: ST_TO_ADDR
// if not tmp then
8661: LD_VAR 0 1
8665: NOT
8666: IFFALSE 8740
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8668: LD_ADDR_VAR 0 1
8672: PUSH
8673: LD_INT 22
8675: PUSH
8676: LD_INT 7
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 23
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: PUSH
8693: LD_INT 26
8695: PUSH
8696: LD_INT 2
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: PUSH
8713: LD_EXP 29
8717: PUSH
8718: LD_EXP 16
8722: PUSH
8723: LD_EXP 27
8727: PUSH
8728: LD_EXP 28
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: DIFF
8739: ST_TO_ADDR
// if tmp then
8740: LD_VAR 0 1
8744: IFFALSE 8815
// case GetSex ( tmp [ 1 ] ) of sex_male :
8746: LD_VAR 0 1
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: CALL_OW 258
8759: PUSH
8760: LD_INT 1
8762: DOUBLE
8763: EQUAL
8764: IFTRUE 8768
8766: GO 8787
8768: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8769: LD_VAR 0 1
8773: PUSH
8774: LD_INT 1
8776: ARRAY
8777: PPUSH
8778: LD_STRING D9-Sol1-1
8780: PPUSH
8781: CALL_OW 88
8785: GO 8815
8787: LD_INT 2
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8814
8795: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
8796: LD_VAR 0 1
8800: PUSH
8801: LD_INT 1
8803: ARRAY
8804: PPUSH
8805: LD_STRING D9-FSol1-1
8807: PPUSH
8808: CALL_OW 88
8812: GO 8815
8814: POP
// if Frank then
8815: LD_EXP 26
8819: IFFALSE 8923
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
8821: LD_EXP 55
8825: PPUSH
8826: CALL_OW 250
8830: PPUSH
8831: LD_EXP 55
8835: PPUSH
8836: CALL_OW 251
8840: PPUSH
8841: LD_INT 7
8843: PPUSH
8844: LD_INT 8
8846: PPUSH
8847: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
8851: LD_EXP 55
8855: PPUSH
8856: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
8860: LD_EXP 26
8864: PPUSH
8865: LD_STRING D9-Frank-1
8867: PPUSH
8868: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
8872: LD_EXP 14
8876: PPUSH
8877: LD_STRING D9-JMM-1
8879: PPUSH
8880: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
8884: LD_EXP 26
8888: PPUSH
8889: LD_STRING D9-Frank-2
8891: PPUSH
8892: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
8896: LD_EXP 55
8900: PPUSH
8901: CALL_OW 250
8905: PPUSH
8906: LD_EXP 55
8910: PPUSH
8911: CALL_OW 251
8915: PPUSH
8916: LD_INT 7
8918: PPUSH
8919: CALL_OW 331
// end ; DialogueOff ;
8923: CALL_OW 7
// end ;
8927: PPOPN 1
8929: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
8930: LD_EXP 7
8934: PUSH
8935: LD_OWVAR 1
8939: PUSH
8940: LD_INT 42000
8942: GREATEREQUAL
8943: OR
8944: IFFALSE 9971
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
8952: PPUSH
// begin selected_option := 1 ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_INT 1
8960: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8961: LD_INT 10500
8963: PPUSH
8964: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8968: LD_INT 35
8970: PPUSH
8971: CALL_OW 67
// until not ru_attackers ;
8975: LD_EXP 51
8979: NOT
8980: IFFALSE 8968
// PrepareBurlak ;
8982: CALL 2046 0 0
// repeat wait ( 0 0$2 ) ;
8986: LD_INT 70
8988: PPUSH
8989: CALL_OW 67
// until not HasTask ( Burlak ) ;
8993: LD_EXP 45
8997: PPUSH
8998: CALL_OW 314
9002: NOT
9003: IFFALSE 8986
// InGameOn ;
9005: CALL_OW 8
// DialogueOn ;
9009: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9013: LD_EXP 48
9017: PPUSH
9018: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9022: LD_EXP 45
9026: PPUSH
9027: LD_STRING D10-Bur-1
9029: PPUSH
9030: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9034: LD_EXP 46
9038: PUSH
9039: LD_EXP 46
9043: PPUSH
9044: CALL_OW 255
9048: PUSH
9049: LD_INT 7
9051: EQUAL
9052: AND
9053: IFFALSE 9067
// Say ( Belkov , D10-Bel-1 ) ;
9055: LD_EXP 46
9059: PPUSH
9060: LD_STRING D10-Bel-1
9062: PPUSH
9063: CALL_OW 88
// if Gossudarov then
9067: LD_EXP 31
9071: IFFALSE 9085
// Say ( Gossudarov , D10-Gos-1 ) ;
9073: LD_EXP 31
9077: PPUSH
9078: LD_STRING D10-Gos-1
9080: PPUSH
9081: CALL_OW 88
// if Kirilenkova then
9085: LD_EXP 32
9089: IFFALSE 9103
// Say ( Kirilenkova , D10-Kir-1 ) ;
9091: LD_EXP 32
9095: PPUSH
9096: LD_STRING D10-Kir-1
9098: PPUSH
9099: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9103: CALL 12175 0 0
9107: PPUSH
9108: LD_STRING D10-RSol1-1
9110: PPUSH
9111: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9115: LD_EXP 45
9119: PPUSH
9120: LD_STRING D10-Bur-2
9122: PPUSH
9123: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9127: LD_EXP 14
9131: PPUSH
9132: LD_STRING D10-JMM-2
9134: PPUSH
9135: CALL_OW 88
// if Kirilenkova then
9139: LD_EXP 32
9143: IFFALSE 9159
// Say ( Kirilenkova , D10-Kir-2 ) else
9145: LD_EXP 32
9149: PPUSH
9150: LD_STRING D10-Kir-2
9152: PPUSH
9153: CALL_OW 88
9157: GO 9171
// Say ( SolRu , D10-RSol1-2 ) ;
9159: CALL 12175 0 0
9163: PPUSH
9164: LD_STRING D10-RSol1-2
9166: PPUSH
9167: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9171: LD_EXP 14
9175: PPUSH
9176: LD_STRING D10-JMM-3
9178: PPUSH
9179: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9183: LD_EXP 45
9187: PPUSH
9188: LD_STRING D10-Bur-3
9190: PPUSH
9191: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9195: LD_EXP 14
9199: PPUSH
9200: LD_STRING D10-JMM-4
9202: PPUSH
9203: CALL_OW 88
// DialogueOff ;
9207: CALL_OW 7
// InGameOff ;
9211: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9215: LD_STRING M2
9217: PPUSH
9218: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9222: LD_INT 35
9224: PPUSH
9225: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9229: LD_INT 22
9231: PUSH
9232: LD_INT 7
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 91
9241: PUSH
9242: LD_EXP 45
9246: PUSH
9247: LD_INT 8
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: PPUSH
9259: CALL_OW 69
9263: IFFALSE 9222
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9265: LD_ADDR_VAR 0 1
9269: PUSH
9270: LD_INT 22
9272: PUSH
9273: LD_INT 4
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 69
9284: PUSH
9285: FOR_IN
9286: IFFALSE 9302
// SetSide ( i , 7 ) ;
9288: LD_VAR 0 1
9292: PPUSH
9293: LD_INT 7
9295: PPUSH
9296: CALL_OW 235
9300: GO 9285
9302: POP
9303: POP
// ChangeMissionObjectives ( M3 ) ;
9304: LD_STRING M3
9306: PPUSH
9307: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9311: LD_INT 35
9313: PPUSH
9314: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9318: LD_EXP 14
9322: PPUSH
9323: LD_EXP 45
9327: PPUSH
9328: CALL_OW 296
9332: PUSH
9333: LD_INT 8
9335: LESS
9336: IFFALSE 9311
// ComTurnUnit ( JMM , Burlak ) ;
9338: LD_EXP 14
9342: PPUSH
9343: LD_EXP 45
9347: PPUSH
9348: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9352: LD_EXP 45
9356: PPUSH
9357: LD_EXP 14
9361: PPUSH
9362: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9366: LD_INT 10
9368: PPUSH
9369: CALL_OW 67
// DialogueOn ;
9373: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9377: LD_EXP 14
9381: PPUSH
9382: LD_STRING D11-JMM-1
9384: PPUSH
9385: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9389: LD_EXP 45
9393: PPUSH
9394: LD_STRING D11-Bur-1
9396: PPUSH
9397: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9401: LD_EXP 14
9405: PPUSH
9406: LD_STRING D11-JMM-2
9408: PPUSH
9409: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9413: LD_EXP 45
9417: PPUSH
9418: LD_STRING D11-Bur-2
9420: PPUSH
9421: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9425: LD_EXP 14
9429: PPUSH
9430: LD_STRING D11-JMM-3
9432: PPUSH
9433: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9437: LD_EXP 45
9441: PPUSH
9442: LD_STRING D11-Bur-3
9444: PPUSH
9445: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9449: LD_EXP 14
9453: PPUSH
9454: LD_STRING D11-JMM-4
9456: PPUSH
9457: CALL_OW 88
// if ar_base_spotted then
9461: LD_EXP 8
9465: IFFALSE 9481
// Say ( Burlak , D12-Bur-1 ) else
9467: LD_EXP 45
9471: PPUSH
9472: LD_STRING D12-Bur-1
9474: PPUSH
9475: CALL_OW 88
9479: GO 9520
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9481: LD_INT 7
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9491: LD_INT 127
9493: PPUSH
9494: LD_INT 45
9496: PPUSH
9497: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9501: LD_EXP 45
9505: PPUSH
9506: LD_STRING D12-Bur-1a
9508: PPUSH
9509: CALL_OW 88
// dwait ( 0 0$2 ) ;
9513: LD_INT 70
9515: PPUSH
9516: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9520: LD_EXP 45
9524: PPUSH
9525: LD_STRING D12-Bur-1b
9527: PPUSH
9528: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9532: LD_EXP 14
9536: PPUSH
9537: LD_STRING D12-JMM-1
9539: PPUSH
9540: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9544: LD_EXP 45
9548: PPUSH
9549: LD_STRING D12-Bur-2
9551: PPUSH
9552: CALL_OW 88
// if Roth then
9556: LD_EXP 15
9560: IFFALSE 9576
// Say ( Roth , D12-Roth-2 ) else
9562: LD_EXP 15
9566: PPUSH
9567: LD_STRING D12-Roth-2
9569: PPUSH
9570: CALL_OW 88
9574: GO 9588
// Say ( SciRu , D12-RSci1-2 ) ;
9576: CALL 12046 0 0
9580: PPUSH
9581: LD_STRING D12-RSci1-2
9583: PPUSH
9584: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9588: LD_EXP 14
9592: PPUSH
9593: LD_STRING D12-JMM-2
9595: PPUSH
9596: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9600: LD_EXP 45
9604: PPUSH
9605: LD_STRING D12-Bur-3
9607: PPUSH
9608: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9612: LD_EXP 14
9616: PPUSH
9617: LD_STRING D12-JMM-3
9619: PPUSH
9620: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9624: LD_EXP 45
9628: PPUSH
9629: LD_STRING D12-Bur-4
9631: PPUSH
9632: CALL_OW 88
// case Query ( QBase ) of 1 :
9636: LD_STRING QBase
9638: PPUSH
9639: CALL_OW 97
9643: PUSH
9644: LD_INT 1
9646: DOUBLE
9647: EQUAL
9648: IFTRUE 9652
9650: GO 9770
9652: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9653: LD_EXP 14
9657: PPUSH
9658: LD_STRING D13a-JMM-1
9660: PPUSH
9661: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9665: LD_EXP 45
9669: PPUSH
9670: LD_STRING D13a-Bur-1
9672: PPUSH
9673: CALL_OW 88
// if Roth then
9677: LD_EXP 15
9681: IFFALSE 9697
// Say ( Roth , D13a-Roth-1 ) else
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D13a-Roth-1
9690: PPUSH
9691: CALL_OW 88
9695: GO 9709
// Say ( SciRu , D13a-RSci1-1 ) ;
9697: CALL 12046 0 0
9701: PPUSH
9702: LD_STRING D13a-RSci1-1
9704: PPUSH
9705: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9709: LD_EXP 14
9713: PPUSH
9714: LD_STRING D13a-JMM-2
9716: PPUSH
9717: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9721: LD_STRING QBaseAgain
9723: PPUSH
9724: CALL_OW 97
9728: PUSH
9729: LD_INT 1
9731: DOUBLE
9732: EQUAL
9733: IFTRUE 9737
9735: GO 9748
9737: POP
// selected_option := 2 ; 2 :
9738: LD_ADDR_VAR 0 2
9742: PUSH
9743: LD_INT 2
9745: ST_TO_ADDR
9746: GO 9768
9748: LD_INT 2
9750: DOUBLE
9751: EQUAL
9752: IFTRUE 9756
9754: GO 9767
9756: POP
// selected_option := 3 ; end ;
9757: LD_ADDR_VAR 0 2
9761: PUSH
9762: LD_INT 3
9764: ST_TO_ADDR
9765: GO 9768
9767: POP
// end ; 2 :
9768: GO 9809
9770: LD_INT 2
9772: DOUBLE
9773: EQUAL
9774: IFTRUE 9778
9776: GO 9789
9778: POP
// selected_option := 2 ; 3 :
9779: LD_ADDR_VAR 0 2
9783: PUSH
9784: LD_INT 2
9786: ST_TO_ADDR
9787: GO 9809
9789: LD_INT 3
9791: DOUBLE
9792: EQUAL
9793: IFTRUE 9797
9795: GO 9808
9797: POP
// selected_option := 3 ; end ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 3
9805: ST_TO_ADDR
9806: GO 9809
9808: POP
// if selected_option = 2 then
9809: LD_VAR 0 2
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: IFFALSE 9911
// begin Say ( JMM , D13b-JMM-1 ) ;
9819: LD_EXP 14
9823: PPUSH
9824: LD_STRING D13b-JMM-1
9826: PPUSH
9827: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
9831: LD_EXP 45
9835: PPUSH
9836: LD_STRING D13b-Bur-1
9838: PPUSH
9839: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
9843: LD_EXP 14
9847: PPUSH
9848: LD_STRING D13b-JMM-2
9850: PPUSH
9851: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
9855: LD_EXP 54
9859: PPUSH
9860: LD_STRING D13b-Abd-2
9862: PPUSH
9863: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
9867: LD_EXP 14
9871: PPUSH
9872: LD_STRING D13b-JMM-3
9874: PPUSH
9875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
9879: LD_EXP 54
9883: PPUSH
9884: LD_STRING D13b-Abd-3
9886: PPUSH
9887: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
9891: LD_EXP 14
9895: PPUSH
9896: LD_STRING D13b-JMM-4
9898: PPUSH
9899: CALL_OW 88
// ar_active_attack := true ;
9903: LD_ADDR_EXP 9
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// end ; if selected_option = 3 then
9911: LD_VAR 0 2
9915: PUSH
9916: LD_INT 3
9918: EQUAL
9919: IFFALSE 9945
// begin Say ( JMM , D13c-JMM-1 ) ;
9921: LD_EXP 14
9925: PPUSH
9926: LD_STRING D13c-JMM-1
9928: PPUSH
9929: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
9933: LD_EXP 45
9937: PPUSH
9938: LD_STRING D13c-Bur-1
9940: PPUSH
9941: CALL_OW 88
// end ; DialogueOff ;
9945: CALL_OW 7
// if not ar_active_attack then
9949: LD_EXP 9
9953: NOT
9954: IFFALSE 9971
// begin wait ( 6 6$00 ) ;
9956: LD_INT 12600
9958: PPUSH
9959: CALL_OW 67
// ar_active_attack := true ;
9963: LD_ADDR_EXP 9
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// end ; end ;
9971: PPOPN 2
9973: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do
9974: LD_EXP 45
9978: PPUSH
9979: CALL_OW 305
9983: PUSH
9984: LD_EXP 45
9988: PPUSH
9989: CALL_OW 255
9993: PUSH
9994: LD_INT 7
9996: EQUAL
9997: AND
9998: IFFALSE 10159
10000: GO 10002
10002: DISABLE
// begin wait ( 4 4$40 ) ;
10003: LD_INT 9800
10005: PPUSH
10006: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10010: LD_INT 35
10012: PPUSH
10013: CALL_OW 67
// until not ru_attackers ;
10017: LD_EXP 51
10021: NOT
10022: IFFALSE 10010
// PrepareGnyevko ;
10024: CALL 1990 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10028: LD_EXP 47
10032: PPUSH
10033: LD_INT 124
10035: PPUSH
10036: LD_INT 118
10038: PPUSH
10039: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10043: LD_EXP 47
10047: PPUSH
10048: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10052: LD_INT 35
10054: PPUSH
10055: CALL_OW 67
// until IsAt ( Gnyevko , 124 , 118 ) ;
10059: LD_EXP 47
10063: PPUSH
10064: LD_INT 124
10066: PPUSH
10067: LD_INT 118
10069: PPUSH
10070: CALL_OW 307
10074: IFFALSE 10052
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10076: LD_EXP 47
10080: PPUSH
10081: LD_STRING DBelkov-Gny-1
10083: PPUSH
10084: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10088: LD_EXP 45
10092: PPUSH
10093: LD_STRING DBelkov-Bur-1a
10095: PPUSH
10096: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10100: LD_INT 35
10102: PPUSH
10103: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10107: LD_EXP 47
10111: PPUSH
10112: LD_INT 22
10114: PUSH
10115: LD_INT 7
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PPUSH
10122: CALL_OW 69
10126: PPUSH
10127: LD_EXP 47
10131: PPUSH
10132: CALL_OW 74
10136: PPUSH
10137: CALL_OW 296
10141: PUSH
10142: LD_INT 8
10144: LESS
10145: IFFALSE 10100
// SetSide ( Gnyevko , 7 ) ;
10147: LD_EXP 47
10151: PPUSH
10152: LD_INT 7
10154: PPUSH
10155: CALL_OW 235
// end ;
10159: END
// every 10 10$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10160: LD_EXP 45
10164: PPUSH
10165: CALL_OW 255
10169: PUSH
10170: LD_INT 7
10172: EQUAL
10173: IFFALSE 10183
10175: GO 10177
10177: DISABLE
// begin enable ;
10178: ENABLE
// PrepareAmericanAttack ;
10179: CALL 6285 0 0
// end ;
10183: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10184: LD_INT 22
10186: PUSH
10187: LD_INT 1
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10382
10200: GO 10202
10202: DISABLE
10203: LD_INT 0
10205: PPUSH
10206: PPUSH
// begin while true do
10207: LD_INT 1
10209: IFFALSE 10266
// begin wait ( 0 0$1 ) ;
10211: LD_INT 35
10213: PPUSH
10214: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10218: LD_ADDR_VAR 0 2
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_INT 1
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PPUSH
10233: CALL_OW 69
10237: PPUSH
10238: LD_EXP 14
10242: PPUSH
10243: CALL_OW 74
10247: ST_TO_ADDR
// if See ( 7 , tmp ) then
10248: LD_INT 7
10250: PPUSH
10251: LD_VAR 0 2
10255: PPUSH
10256: CALL_OW 292
10260: IFFALSE 10264
// break ;
10262: GO 10266
// end ;
10264: GO 10207
// DialogueOn ;
10266: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10270: LD_VAR 0 2
10274: PPUSH
10275: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10279: LD_VAR 0 2
10283: PPUSH
10284: CALL_OW 250
10288: PPUSH
10289: LD_VAR 0 2
10293: PPUSH
10294: CALL_OW 251
10298: PPUSH
10299: LD_INT 7
10301: PPUSH
10302: LD_INT 8
10304: PPUSH
10305: CALL_OW 330
// if Denis then
10309: LD_EXP 20
10313: IFFALSE 10327
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10315: LD_EXP 20
10319: PPUSH
10320: LD_STRING DAmerAttack-Pet-1
10322: PPUSH
10323: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10327: LD_EXP 14
10331: PPUSH
10332: LD_STRING DAmerAttack-JMM-1
10334: PPUSH
10335: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10339: LD_EXP 45
10343: PPUSH
10344: LD_STRING DStop-Bur-1
10346: PPUSH
10347: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10351: LD_VAR 0 2
10355: PPUSH
10356: CALL_OW 250
10360: PPUSH
10361: LD_VAR 0 2
10365: PPUSH
10366: CALL_OW 251
10370: PPUSH
10371: LD_INT 7
10373: PPUSH
10374: CALL_OW 331
// DialogueOff ;
10378: CALL_OW 7
// end ;
10382: PPOPN 2
10384: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10385: LD_INT 22
10387: PUSH
10388: LD_INT 3
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 1
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PPUSH
10409: CALL_OW 69
10413: PUSH
10414: LD_INT 0
10416: EQUAL
10417: IFFALSE 10459
10419: GO 10421
10421: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10422: LD_STRING M5a
10424: PPUSH
10425: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10429: LD_EXP 14
10433: PPUSH
10434: LD_STRING D8-JMM-1
10436: PPUSH
10437: CALL_OW 88
// if Gossudarov then
10441: LD_EXP 31
10445: IFFALSE 10459
// Say ( Gossudarov , D8-Gos-1 ) ;
10447: LD_EXP 31
10451: PPUSH
10452: LD_STRING D8-Gos-1
10454: PPUSH
10455: CALL_OW 88
// end ;
10459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10460: LD_INT 22
10462: PUSH
10463: LD_INT 2
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: LD_INT 21
10472: PUSH
10473: LD_INT 1
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 69
10488: PUSH
10489: LD_INT 0
10491: EQUAL
10492: IFFALSE 10542
10494: GO 10496
10496: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10497: LD_STRING M4c
10499: PPUSH
10500: CALL_OW 337
// if Roth then
10504: LD_EXP 15
10508: IFFALSE 10524
// Say ( Roth , DStop-Roth-1 ) else
10510: LD_EXP 15
10514: PPUSH
10515: LD_STRING DStop-Roth-1
10517: PPUSH
10518: CALL_OW 88
10522: GO 10542
// if Gossudarov then
10524: LD_EXP 31
10528: IFFALSE 10542
// Say ( Gossudarov , D8-Gos-1a ) ;
10530: LD_EXP 31
10534: PPUSH
10535: LD_STRING D8-Gos-1a
10537: PPUSH
10538: CALL_OW 88
// end ;
10542: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10543: LD_INT 7
10545: PPUSH
10546: LD_INT 1
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 13578 0 3
10556: PUSH
10557: LD_INT 0
10559: EQUAL
10560: PUSH
10561: LD_INT 7
10563: PPUSH
10564: LD_INT 3
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 13578 0 3
10574: PUSH
10575: LD_INT 0
10577: EQUAL
10578: AND
10579: IFFALSE 10591
10581: GO 10583
10583: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10584: LD_STRING M1a
10586: PPUSH
10587: CALL_OW 337
// end ;
10591: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 3 ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10592: LD_INT 22
10594: PUSH
10595: LD_INT 2
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: LD_INT 21
10604: PUSH
10605: LD_INT 1
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 69
10620: PUSH
10621: LD_INT 0
10623: EQUAL
10624: PUSH
10625: LD_INT 22
10627: PUSH
10628: LD_INT 3
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PPUSH
10635: CALL_OW 69
10639: PUSH
10640: LD_INT 0
10642: EQUAL
10643: AND
10644: PUSH
10645: LD_INT 22
10647: PUSH
10648: LD_INT 1
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 69
10659: PUSH
10660: LD_INT 0
10662: EQUAL
10663: AND
10664: PUSH
10665: LD_INT 7
10667: PPUSH
10668: LD_INT 1
10670: PPUSH
10671: LD_INT 1
10673: PPUSH
10674: CALL 13578 0 3
10678: PUSH
10679: LD_INT 0
10681: EQUAL
10682: AND
10683: PUSH
10684: LD_INT 7
10686: PPUSH
10687: LD_INT 3
10689: PPUSH
10690: LD_INT 1
10692: PPUSH
10693: CALL 13578 0 3
10697: PUSH
10698: LD_INT 0
10700: EQUAL
10701: AND
10702: IFFALSE 12043
10704: GO 10706
10706: DISABLE
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// begin wait ( 0 0$3 ) ;
10712: LD_INT 105
10714: PPUSH
10715: CALL_OW 67
// if not IsDead ( Masha ) then
10719: LD_EXP 48
10723: PPUSH
10724: CALL_OW 301
10728: NOT
10729: IFFALSE 10743
// AddMedal ( Masha , 1 ) else
10731: LD_STRING Masha
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 101
10741: GO 10754
// AddMedal ( Masha , - 1 ) ;
10743: LD_STRING Masha
10745: PPUSH
10746: LD_INT 1
10748: NEG
10749: PPUSH
10750: CALL_OW 101
// if abdul_escaped then
10754: LD_EXP 12
10758: IFFALSE 10773
// AddMedal ( Abdul , - 1 ) else
10760: LD_STRING Abdul
10762: PPUSH
10763: LD_INT 1
10765: NEG
10766: PPUSH
10767: CALL_OW 101
10771: GO 10783
// AddMedal ( Abdul , 1 ) ;
10773: LD_STRING Abdul
10775: PPUSH
10776: LD_INT 1
10778: PPUSH
10779: CALL_OW 101
// if loss_counter = 0 then
10783: LD_EXP 13
10787: PUSH
10788: LD_INT 0
10790: EQUAL
10791: IFFALSE 10805
// AddMedal ( People , 2 ) else
10793: LD_STRING People
10795: PPUSH
10796: LD_INT 2
10798: PPUSH
10799: CALL_OW 101
10803: GO 10855
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
10805: LD_EXP 13
10809: PUSH
10810: LD_INT 3
10812: PUSH
10813: LD_INT 2
10815: PUSH
10816: LD_INT 2
10818: PUSH
10819: EMPTY
10820: LIST
10821: LIST
10822: LIST
10823: PUSH
10824: LD_OWVAR 67
10828: ARRAY
10829: LESSEQUAL
10830: IFFALSE 10844
// AddMedal ( People , 1 ) else
10832: LD_STRING People
10834: PPUSH
10835: LD_INT 1
10837: PPUSH
10838: CALL_OW 101
10842: GO 10855
// AddMedal ( People , - 1 ) ;
10844: LD_STRING People
10846: PPUSH
10847: LD_INT 1
10849: NEG
10850: PPUSH
10851: CALL_OW 101
// GiveMedals ( MAIN ) ;
10855: LD_STRING MAIN
10857: PPUSH
10858: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
10862: LD_ADDR_VAR 0 2
10866: PUSH
10867: LD_INT 22
10869: PUSH
10870: LD_INT 7
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: PUSH
10877: LD_INT 2
10879: PUSH
10880: LD_INT 25
10882: PUSH
10883: LD_INT 1
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PUSH
10890: LD_INT 25
10892: PUSH
10893: LD_INT 2
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PUSH
10900: LD_INT 25
10902: PUSH
10903: LD_INT 3
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PUSH
10910: LD_INT 25
10912: PUSH
10913: LD_INT 4
10915: PUSH
10916: EMPTY
10917: LIST
10918: LIST
10919: PUSH
10920: LD_INT 25
10922: PUSH
10923: LD_INT 5
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: LD_INT 25
10932: PUSH
10933: LD_INT 8
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: PUSH
10940: LD_INT 25
10942: PUSH
10943: LD_INT 9
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: LIST
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PPUSH
10964: CALL_OW 69
10968: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
10978: LD_ADDR_VAR 0 3
10982: PUSH
10983: LD_EXP 14
10987: PUSH
10988: LD_EXP 15
10992: PUSH
10993: LD_EXP 16
10997: PUSH
10998: LD_EXP 17
11002: PUSH
11003: LD_EXP 18
11007: PUSH
11008: LD_EXP 19
11012: PUSH
11013: LD_EXP 20
11017: PUSH
11018: LD_EXP 21
11022: PUSH
11023: LD_EXP 22
11027: PUSH
11028: LD_EXP 23
11032: PUSH
11033: LD_EXP 24
11037: PUSH
11038: LD_EXP 25
11042: PUSH
11043: LD_EXP 26
11047: PUSH
11048: LD_EXP 27
11052: PUSH
11053: LD_EXP 28
11057: PUSH
11058: LD_EXP 29
11062: PUSH
11063: LD_EXP 30
11067: PUSH
11068: LD_EXP 31
11072: PUSH
11073: LD_EXP 32
11077: PUSH
11078: LD_EXP 33
11082: PUSH
11083: LD_EXP 35
11087: PUSH
11088: LD_EXP 36
11092: PUSH
11093: LD_EXP 37
11097: PUSH
11098: LD_EXP 38
11102: PUSH
11103: LD_EXP 39
11107: PUSH
11108: LD_EXP 40
11112: PUSH
11113: LD_EXP 41
11117: PUSH
11118: LD_EXP 42
11122: PUSH
11123: LD_EXP 43
11127: PUSH
11128: LD_EXP 44
11132: PUSH
11133: LD_EXP 45
11137: PUSH
11138: LD_EXP 46
11142: PUSH
11143: LD_EXP 47
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: LIST
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: ST_TO_ADDR
// if tmp diff tmp2 then
11183: LD_VAR 0 2
11187: PUSH
11188: LD_VAR 0 3
11192: DIFF
11193: IFFALSE 11213
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11195: LD_VAR 0 2
11199: PUSH
11200: LD_VAR 0 3
11204: DIFF
11205: PPUSH
11206: LD_STRING 13a_others
11208: PPUSH
11209: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11213: LD_EXP 14
11217: PPUSH
11218: LD_STRING 13a_JMM
11220: PPUSH
11221: CALL_OW 38
// if Titov then
11225: LD_EXP 33
11229: IFFALSE 11243
// SaveCharacters ( Titov , 13a_Titov ) ;
11231: LD_EXP 33
11235: PPUSH
11236: LD_STRING 13a_Titov
11238: PPUSH
11239: CALL_OW 38
// if Dolgov then
11243: LD_EXP 35
11247: IFFALSE 11261
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11249: LD_EXP 35
11253: PPUSH
11254: LD_STRING 13a_Dolgov
11256: PPUSH
11257: CALL_OW 38
// if Petrosyan then
11261: LD_EXP 36
11265: IFFALSE 11279
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11267: LD_EXP 36
11271: PPUSH
11272: LD_STRING 13a_Petrosyan
11274: PPUSH
11275: CALL_OW 38
// if Scholtze then
11279: LD_EXP 37
11283: IFFALSE 11297
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11285: LD_EXP 37
11289: PPUSH
11290: LD_STRING 13a_Scholtze
11292: PPUSH
11293: CALL_OW 38
// if Oblukov then
11297: LD_EXP 38
11301: IFFALSE 11315
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11303: LD_EXP 38
11307: PPUSH
11308: LD_STRING 13a_Oblukov
11310: PPUSH
11311: CALL_OW 38
// if Kapitsova then
11315: LD_EXP 39
11319: IFFALSE 11333
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11321: LD_EXP 39
11325: PPUSH
11326: LD_STRING 13a_Kapitsova
11328: PPUSH
11329: CALL_OW 38
// if Lipshchin then
11333: LD_EXP 40
11337: IFFALSE 11351
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11339: LD_EXP 40
11343: PPUSH
11344: LD_STRING 13a_Lipshchin
11346: PPUSH
11347: CALL_OW 38
// if Petrovova then
11351: LD_EXP 41
11355: IFFALSE 11369
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11357: LD_EXP 41
11361: PPUSH
11362: LD_STRING 13a_Petrovova
11364: PPUSH
11365: CALL_OW 38
// if Kovalyuk then
11369: LD_EXP 42
11373: IFFALSE 11387
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11375: LD_EXP 42
11379: PPUSH
11380: LD_STRING 13a_Kovalyuk
11382: PPUSH
11383: CALL_OW 38
// if Kuzmov then
11387: LD_EXP 43
11391: IFFALSE 11405
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11393: LD_EXP 43
11397: PPUSH
11398: LD_STRING 13a_Kuzmov
11400: PPUSH
11401: CALL_OW 38
// if Karamazov then
11405: LD_EXP 44
11409: IFFALSE 11423
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11411: LD_EXP 44
11415: PPUSH
11416: LD_STRING 13a_Karamazov
11418: PPUSH
11419: CALL_OW 38
// if Burlak then
11423: LD_EXP 45
11427: IFFALSE 11441
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11429: LD_EXP 45
11433: PPUSH
11434: LD_STRING 13a_Burlak
11436: PPUSH
11437: CALL_OW 38
// if Belkov then
11441: LD_EXP 46
11445: IFFALSE 11459
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11447: LD_EXP 46
11451: PPUSH
11452: LD_STRING 13a_Belkov
11454: PPUSH
11455: CALL_OW 38
// if Gnyevko then
11459: LD_EXP 47
11463: IFFALSE 11477
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11465: LD_EXP 47
11469: PPUSH
11470: LD_STRING 13a_Gnyevko
11472: PPUSH
11473: CALL_OW 38
// if Lisa then
11477: LD_EXP 16
11481: IFFALSE 11495
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11483: LD_EXP 16
11487: PPUSH
11488: LD_STRING 13a_Lisa
11490: PPUSH
11491: CALL_OW 38
// if Donaldson then
11495: LD_EXP 17
11499: IFFALSE 11513
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11501: LD_EXP 17
11505: PPUSH
11506: LD_STRING 13a_Donaldson
11508: PPUSH
11509: CALL_OW 38
// if Bobby then
11513: LD_EXP 18
11517: IFFALSE 11531
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11519: LD_EXP 18
11523: PPUSH
11524: LD_STRING 13a_Bobby
11526: PPUSH
11527: CALL_OW 38
// if Cyrus then
11531: LD_EXP 19
11535: IFFALSE 11549
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11537: LD_EXP 19
11541: PPUSH
11542: LD_STRING 13a_Cyrus
11544: PPUSH
11545: CALL_OW 38
// if Denis then
11549: LD_EXP 20
11553: IFFALSE 11567
// SaveCharacters ( Denis , 13a_Denis ) ;
11555: LD_EXP 20
11559: PPUSH
11560: LD_STRING 13a_Denis
11562: PPUSH
11563: CALL_OW 38
// if Brown then
11567: LD_EXP 21
11571: IFFALSE 11585
// SaveCharacters ( Brown , 13a_Brown ) ;
11573: LD_EXP 21
11577: PPUSH
11578: LD_STRING 13a_Brown
11580: PPUSH
11581: CALL_OW 38
// if Gladstone then
11585: LD_EXP 22
11589: IFFALSE 11603
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11591: LD_EXP 22
11595: PPUSH
11596: LD_STRING 13a_Gladstone
11598: PPUSH
11599: CALL_OW 38
// if Houten then
11603: LD_EXP 23
11607: IFFALSE 11621
// SaveCharacters ( Houten , 13a_Houten ) ;
11609: LD_EXP 23
11613: PPUSH
11614: LD_STRING 13a_Houten
11616: PPUSH
11617: CALL_OW 38
// if Cornel then
11621: LD_EXP 24
11625: IFFALSE 11639
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11627: LD_EXP 24
11631: PPUSH
11632: LD_STRING 13a_Cornel
11634: PPUSH
11635: CALL_OW 38
// if Gary then
11639: LD_EXP 25
11643: IFFALSE 11657
// SaveCharacters ( Gary , 13a_Gary ) ;
11645: LD_EXP 25
11649: PPUSH
11650: LD_STRING 13a_Gary
11652: PPUSH
11653: CALL_OW 38
// if Frank then
11657: LD_EXP 26
11661: IFFALSE 11675
// SaveCharacters ( Frank , 13a_Frank ) ;
11663: LD_EXP 26
11667: PPUSH
11668: LD_STRING 13a_Frank
11670: PPUSH
11671: CALL_OW 38
// if Kikuchi then
11675: LD_EXP 27
11679: IFFALSE 11693
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11681: LD_EXP 27
11685: PPUSH
11686: LD_STRING 13a_Kikuchi
11688: PPUSH
11689: CALL_OW 38
// if Simms then
11693: LD_EXP 28
11697: IFFALSE 11711
// SaveCharacters ( Simms , 13a_Simms ) ;
11699: LD_EXP 28
11703: PPUSH
11704: LD_STRING 13a_Simms
11706: PPUSH
11707: CALL_OW 38
// if Joan then
11711: LD_EXP 29
11715: IFFALSE 11729
// SaveCharacters ( Joan , 13a_Joan ) ;
11717: LD_EXP 29
11721: PPUSH
11722: LD_STRING 13a_Joan
11724: PPUSH
11725: CALL_OW 38
// if DeltaDoctor then
11729: LD_EXP 30
11733: IFFALSE 11747
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
11735: LD_EXP 30
11739: PPUSH
11740: LD_STRING 13a_DeltaDoctor
11742: PPUSH
11743: CALL_OW 38
// if Gossudarov then
11747: LD_EXP 31
11751: IFFALSE 11765
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
11753: LD_EXP 31
11757: PPUSH
11758: LD_STRING 13a_Gossudarov
11760: PPUSH
11761: CALL_OW 38
// if Kirilenkova then
11765: LD_EXP 32
11769: IFFALSE 11783
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
11771: LD_EXP 32
11775: PPUSH
11776: LD_STRING 13a_Kirilenkova
11778: PPUSH
11779: CALL_OW 38
// if Masha then
11783: LD_EXP 48
11787: IFFALSE 11842
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
11789: LD_EXP 48
11793: PPUSH
11794: CALL_OW 265
11798: PUSH
11799: LD_EXP 48
11803: PPUSH
11804: CALL_OW 262
11808: PUSH
11809: LD_EXP 48
11813: PPUSH
11814: CALL_OW 263
11818: PUSH
11819: LD_EXP 48
11823: PPUSH
11824: CALL_OW 264
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: PPUSH
11835: LD_STRING 13a_Masha
11837: PPUSH
11838: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
11842: LD_ADDR_VAR 0 2
11846: PUSH
11847: LD_INT 21
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: ST_TO_ADDR
// tmp2 := [ ] ;
11862: LD_ADDR_VAR 0 3
11866: PUSH
11867: EMPTY
11868: ST_TO_ADDR
// if tmp then
11869: LD_VAR 0 2
11873: IFFALSE 12021
// for i in tmp do
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_VAR 0 2
11884: PUSH
11885: FOR_IN
11886: IFFALSE 12019
// tmp2 := tmp2 ^ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: LD_VAR 0 1
11902: PPUSH
11903: CALL_OW 255
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL_OW 248
11917: PUSH
11918: LD_VAR 0 1
11922: PPUSH
11923: CALL_OW 266
11927: PUSH
11928: LD_VAR 0 1
11932: PPUSH
11933: CALL_OW 250
11937: PUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 251
11947: PUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 254
11957: PUSH
11958: LD_VAR 0 1
11962: PPUSH
11963: CALL_OW 267
11967: PUSH
11968: LD_VAR 0 1
11972: PPUSH
11973: LD_INT 1
11975: PPUSH
11976: CALL_OW 268
11980: PUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: LD_INT 2
11988: PPUSH
11989: CALL_OW 268
11993: PUSH
11994: LD_VAR 0 1
11998: PPUSH
11999: CALL_OW 269
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: ADD
12016: ST_TO_ADDR
12017: GO 11885
12019: POP
12020: POP
// if tmp2 then
12021: LD_VAR 0 3
12025: IFFALSE 12039
// SaveVariable ( tmp2 , 13a_buildings ) ;
12027: LD_VAR 0 3
12031: PPUSH
12032: LD_STRING 13a_buildings
12034: PPUSH
12035: CALL_OW 39
// YouWin ;
12039: CALL_OW 103
// end ;
12043: PPOPN 3
12045: END
// export function SciRu ; var tmp , t ; begin
12046: LD_INT 0
12048: PPUSH
12049: PPUSH
12050: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12051: LD_ADDR_VAR 0 3
12055: PUSH
12056: LD_EXP 31
12060: PUSH
12061: LD_EXP 45
12065: PUSH
12066: LD_EXP 33
12070: PUSH
12071: LD_EXP 46
12075: PUSH
12076: LD_EXP 47
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12088: LD_ADDR_VAR 0 2
12092: PUSH
12093: LD_INT 22
12095: PUSH
12096: LD_INT 7
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 23
12105: PUSH
12106: LD_INT 3
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 4
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 26
12125: PUSH
12126: LD_INT 1
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: PPUSH
12139: CALL_OW 69
12143: PUSH
12144: LD_VAR 0 3
12148: DIFF
12149: ST_TO_ADDR
// if tmp then
12150: LD_VAR 0 2
12154: IFFALSE 12170
// result := tmp [ 1 ] ;
12156: LD_ADDR_VAR 0 1
12160: PUSH
12161: LD_VAR 0 2
12165: PUSH
12166: LD_INT 1
12168: ARRAY
12169: ST_TO_ADDR
// end ;
12170: LD_VAR 0 1
12174: RET
// export function SolRu ; var tmp , t ; begin
12175: LD_INT 0
12177: PPUSH
12178: PPUSH
12179: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12180: LD_ADDR_VAR 0 3
12184: PUSH
12185: LD_EXP 46
12189: PUSH
12190: LD_EXP 45
12194: PUSH
12195: LD_EXP 31
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: LIST
12204: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12205: LD_ADDR_VAR 0 2
12209: PUSH
12210: LD_INT 22
12212: PUSH
12213: LD_INT 7
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 23
12222: PUSH
12223: LD_INT 3
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: LD_INT 25
12232: PUSH
12233: LD_INT 1
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: PUSH
12240: LD_INT 26
12242: PUSH
12243: LD_INT 1
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PUSH
12250: EMPTY
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: PPUSH
12256: CALL_OW 69
12260: PUSH
12261: LD_VAR 0 3
12265: DIFF
12266: ST_TO_ADDR
// if tmp then
12267: LD_VAR 0 2
12271: IFFALSE 12287
// result := tmp [ 1 ] ;
12273: LD_ADDR_VAR 0 1
12277: PUSH
12278: LD_VAR 0 2
12282: PUSH
12283: LD_INT 1
12285: ARRAY
12286: ST_TO_ADDR
// end ; end_of_file
12287: LD_VAR 0 1
12291: RET
// export function CustomEvent ( event ) ; begin
12292: LD_INT 0
12294: PPUSH
// end ;
12295: LD_VAR 0 2
12299: RET
// on UnitDestroyed ( un ) do var i , side ;
12300: LD_INT 0
12302: PPUSH
12303: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12304: LD_VAR 0 1
12308: PUSH
12309: LD_INT 22
12311: PUSH
12312: LD_INT 7
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: PUSH
12319: LD_INT 2
12321: PUSH
12322: LD_INT 25
12324: PUSH
12325: LD_INT 1
12327: PUSH
12328: EMPTY
12329: LIST
12330: LIST
12331: PUSH
12332: LD_INT 25
12334: PUSH
12335: LD_INT 2
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: PUSH
12342: LD_INT 25
12344: PUSH
12345: LD_INT 3
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: PUSH
12352: LD_INT 25
12354: PUSH
12355: LD_INT 4
12357: PUSH
12358: EMPTY
12359: LIST
12360: LIST
12361: PUSH
12362: LD_INT 25
12364: PUSH
12365: LD_INT 5
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: PUSH
12372: LD_INT 25
12374: PUSH
12375: LD_INT 8
12377: PUSH
12378: EMPTY
12379: LIST
12380: LIST
12381: PUSH
12382: LD_INT 25
12384: PUSH
12385: LD_INT 9
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: PUSH
12402: EMPTY
12403: LIST
12404: LIST
12405: PPUSH
12406: CALL_OW 69
12410: IN
12411: IFFALSE 12427
// loss_counter := loss_counter + 1 ;
12413: LD_ADDR_EXP 13
12417: PUSH
12418: LD_EXP 13
12422: PUSH
12423: LD_INT 1
12425: PLUS
12426: ST_TO_ADDR
// if un = Abdul then
12427: LD_VAR 0 1
12431: PUSH
12432: LD_EXP 54
12436: EQUAL
12437: IFFALSE 12447
// abdul_escaped := false ;
12439: LD_ADDR_EXP 12
12443: PUSH
12444: LD_INT 0
12446: ST_TO_ADDR
// if un in ru_attackers then
12447: LD_VAR 0 1
12451: PUSH
12452: LD_EXP 51
12456: IN
12457: IFFALSE 12475
// ru_attackers := ru_attackers diff un ;
12459: LD_ADDR_EXP 51
12463: PUSH
12464: LD_EXP 51
12468: PUSH
12469: LD_VAR 0 1
12473: DIFF
12474: ST_TO_ADDR
// if un in ar_attackers then
12475: LD_VAR 0 1
12479: PUSH
12480: LD_EXP 10
12484: IN
12485: IFFALSE 12503
// ar_attackers := ar_attackers diff un ;
12487: LD_ADDR_EXP 10
12491: PUSH
12492: LD_EXP 10
12496: PUSH
12497: LD_VAR 0 1
12501: DIFF
12502: ST_TO_ADDR
// if un = JMM then
12503: LD_VAR 0 1
12507: PUSH
12508: LD_EXP 14
12512: EQUAL
12513: IFFALSE 12524
// begin YouLost ( JMM ) ;
12515: LD_STRING JMM
12517: PPUSH
12518: CALL_OW 104
// exit ;
12522: GO 12613
// end ; if un = Burlak then
12524: LD_VAR 0 1
12528: PUSH
12529: LD_EXP 45
12533: EQUAL
12534: IFFALSE 12545
// begin YouLost ( Burlak ) ;
12536: LD_STRING Burlak
12538: PPUSH
12539: CALL_OW 104
// exit ;
12543: GO 12613
// end ; if un = freedom then
12545: LD_VAR 0 1
12549: PUSH
12550: LD_EXP 3
12554: EQUAL
12555: IFFALSE 12566
// begin YouLost ( Destroyed ) ;
12557: LD_STRING Destroyed
12559: PPUSH
12560: CALL_OW 104
// exit ;
12564: GO 12613
// end ; if un = Masha then
12566: LD_VAR 0 1
12570: PUSH
12571: LD_EXP 48
12575: EQUAL
12576: IFFALSE 12585
// ChangeMissionObjectives ( M4b ) ;
12578: LD_STRING M4b
12580: PPUSH
12581: CALL_OW 337
// if un = Mastodont then
12585: LD_VAR 0 1
12589: PUSH
12590: LD_EXP 55
12594: EQUAL
12595: IFFALSE 12604
// ChangeMissionObjectives ( M4a ) ;
12597: LD_STRING M4a
12599: PPUSH
12600: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12604: LD_VAR 0 1
12608: PPUSH
12609: CALL 81114 0 1
// end ;
12613: PPOPN 3
12615: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12616: LD_VAR 0 1
12620: PPUSH
12621: LD_VAR 0 2
12625: PPUSH
12626: CALL 83020 0 2
// end ;
12630: PPOPN 2
12632: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL 82088 0 1
// end ;
12642: PPOPN 1
12644: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12645: LD_VAR 0 1
12649: PUSH
12650: LD_INT 22
12652: PUSH
12653: LD_INT 7
12655: PUSH
12656: EMPTY
12657: LIST
12658: LIST
12659: PUSH
12660: LD_INT 30
12662: PUSH
12663: LD_INT 0
12665: PUSH
12666: EMPTY
12667: LIST
12668: LIST
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: PPUSH
12674: CALL_OW 69
12678: IN
12679: IFFALSE 12718
// begin SetBName ( building , freedom ) ;
12681: LD_VAR 0 1
12685: PPUSH
12686: LD_STRING freedom
12688: PPUSH
12689: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12693: LD_INT 0
12695: PPUSH
12696: LD_INT 7
12698: PPUSH
12699: LD_INT 0
12701: PPUSH
12702: CALL_OW 324
// freedom := building ;
12706: LD_ADDR_EXP 3
12710: PUSH
12711: LD_VAR 0 1
12715: ST_TO_ADDR
// exit ;
12716: GO 12784
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
12718: LD_VAR 0 1
12722: PUSH
12723: LD_INT 22
12725: PUSH
12726: LD_INT 7
12728: PUSH
12729: EMPTY
12730: LIST
12731: LIST
12732: PUSH
12733: LD_INT 23
12735: PUSH
12736: LD_INT 3
12738: PUSH
12739: EMPTY
12740: LIST
12741: LIST
12742: PUSH
12743: LD_INT 30
12745: PUSH
12746: LD_INT 6
12748: PUSH
12749: EMPTY
12750: LIST
12751: LIST
12752: PUSH
12753: EMPTY
12754: LIST
12755: LIST
12756: LIST
12757: PPUSH
12758: CALL_OW 69
12762: IN
12763: IFFALSE 12775
// begin ru_lab_builded := true ;
12765: LD_ADDR_EXP 5
12769: PUSH
12770: LD_INT 1
12772: ST_TO_ADDR
// exit ;
12773: GO 12784
// end ; MCE_BuildingComplete ( building ) ;
12775: LD_VAR 0 1
12779: PPUSH
12780: CALL 82329 0 1
// end ;
12784: PPOPN 1
12786: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12787: LD_VAR 0 1
12791: PPUSH
12792: LD_VAR 0 2
12796: PPUSH
12797: CALL 80810 0 2
// end ;
12801: PPOPN 2
12803: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12804: LD_VAR 0 1
12808: PPUSH
12809: LD_VAR 0 2
12813: PPUSH
12814: LD_VAR 0 3
12818: PPUSH
12819: LD_VAR 0 4
12823: PPUSH
12824: LD_VAR 0 5
12828: PPUSH
12829: CALL 80430 0 5
// end ;
12833: PPOPN 5
12835: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12836: LD_VAR 0 1
12840: PPUSH
12841: LD_VAR 0 2
12845: PPUSH
12846: CALL 80020 0 2
// end ;
12850: PPOPN 2
12852: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12853: LD_VAR 0 1
12857: PPUSH
12858: LD_VAR 0 2
12862: PPUSH
12863: LD_VAR 0 3
12867: PPUSH
12868: LD_VAR 0 4
12872: PPUSH
12873: CALL 79858 0 4
// end ;
12877: PPOPN 4
12879: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12880: LD_VAR 0 1
12884: PPUSH
12885: LD_VAR 0 2
12889: PPUSH
12890: LD_VAR 0 3
12894: PPUSH
12895: CALL 79633 0 3
// end ;
12899: PPOPN 3
12901: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12902: LD_VAR 0 1
12906: PPUSH
12907: LD_VAR 0 2
12911: PPUSH
12912: CALL 79518 0 2
// end ;
12916: PPOPN 2
12918: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12919: LD_VAR 0 1
12923: PPUSH
12924: LD_VAR 0 2
12928: PPUSH
12929: CALL 83281 0 2
// end ;
12933: PPOPN 2
12935: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12936: LD_VAR 0 1
12940: PPUSH
12941: LD_VAR 0 2
12945: PPUSH
12946: LD_VAR 0 3
12950: PPUSH
12951: LD_VAR 0 4
12955: PPUSH
12956: CALL 83497 0 4
// end ;
12960: PPOPN 4
12962: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12963: LD_VAR 0 1
12967: PPUSH
12968: LD_VAR 0 2
12972: PPUSH
12973: CALL 79327 0 2
// end ; end_of_file
12977: PPOPN 2
12979: END
// every 0 0$30 do var cr , time ;
12980: GO 12982
12982: DISABLE
12983: LD_INT 0
12985: PPUSH
12986: PPUSH
// begin time := 0 0$10 ;
12987: LD_ADDR_VAR 0 2
12991: PUSH
12992: LD_INT 350
12994: ST_TO_ADDR
// while game do
12995: LD_EXP 2
12999: IFFALSE 13098
// begin wait ( time ) ;
13001: LD_VAR 0 2
13005: PPUSH
13006: CALL_OW 67
// if tick > 2 2$00 then
13010: LD_OWVAR 1
13014: PUSH
13015: LD_INT 4200
13017: GREATER
13018: IFFALSE 13051
// time := time + [ 0 0$06 , 0 0$07 , 0 0$08 ] [ Difficulty ] ;
13020: LD_ADDR_VAR 0 2
13024: PUSH
13025: LD_VAR 0 2
13029: PUSH
13030: LD_INT 210
13032: PUSH
13033: LD_INT 245
13035: PUSH
13036: LD_INT 280
13038: PUSH
13039: EMPTY
13040: LIST
13041: LIST
13042: LIST
13043: PUSH
13044: LD_OWVAR 67
13048: ARRAY
13049: PLUS
13050: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13051: LD_INT 1
13053: PPUSH
13054: LD_INT 5
13056: PPUSH
13057: CALL_OW 12
13061: PPUSH
13062: LD_INT 70
13064: PPUSH
13065: LD_INT 49
13067: PPUSH
13068: LD_INT 25
13070: PPUSH
13071: LD_INT 1
13073: PPUSH
13074: CALL_OW 56
// if time > 5 5$00 then
13078: LD_VAR 0 2
13082: PUSH
13083: LD_INT 10500
13085: GREATER
13086: IFFALSE 13096
// time := 0 0$30 ;
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: LD_INT 1050
13095: ST_TO_ADDR
// end ;
13096: GO 12995
// end ;
13098: PPOPN 2
13100: END
// every 0 0$30 do var cr , time ;
13101: GO 13103
13103: DISABLE
13104: LD_INT 0
13106: PPUSH
13107: PPUSH
// begin time := 0 0$01 ;
13108: LD_ADDR_VAR 0 2
13112: PUSH
13113: LD_INT 35
13115: ST_TO_ADDR
// while game do
13116: LD_EXP 2
13120: IFFALSE 13209
// begin wait ( time ) ;
13122: LD_VAR 0 2
13126: PPUSH
13127: CALL_OW 67
// time := time + [ 0 0$04 , 0 0$05 , 0 0$06 ] [ Difficulty ] ;
13131: LD_ADDR_VAR 0 2
13135: PUSH
13136: LD_VAR 0 2
13140: PUSH
13141: LD_INT 140
13143: PUSH
13144: LD_INT 175
13146: PUSH
13147: LD_INT 210
13149: PUSH
13150: EMPTY
13151: LIST
13152: LIST
13153: LIST
13154: PUSH
13155: LD_OWVAR 67
13159: ARRAY
13160: PLUS
13161: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13162: LD_INT 3
13164: PPUSH
13165: LD_INT 5
13167: PPUSH
13168: CALL_OW 12
13172: PPUSH
13173: LD_INT 26
13175: PPUSH
13176: LD_INT 9
13178: PPUSH
13179: LD_INT 30
13181: PPUSH
13182: LD_INT 1
13184: PPUSH
13185: CALL_OW 56
// if time > 3 3$00 then
13189: LD_VAR 0 2
13193: PUSH
13194: LD_INT 6300
13196: GREATER
13197: IFFALSE 13207
// time := 0 0$20 ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 700
13206: ST_TO_ADDR
// end ;
13207: GO 13116
// end ;
13209: PPOPN 2
13211: END
// every 0 0$30 do var cr , time ;
13212: GO 13214
13214: DISABLE
13215: LD_INT 0
13217: PPUSH
13218: PPUSH
// begin time := 0 0$20 ;
13219: LD_ADDR_VAR 0 2
13223: PUSH
13224: LD_INT 700
13226: ST_TO_ADDR
// while game do
13227: LD_EXP 2
13231: IFFALSE 13356
// begin wait ( time ) ;
13233: LD_VAR 0 2
13237: PPUSH
13238: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13242: LD_ADDR_VAR 0 2
13246: PUSH
13247: LD_VAR 0 2
13251: PUSH
13252: LD_INT 175
13254: PUSH
13255: LD_INT 210
13257: PUSH
13258: LD_INT 280
13260: PUSH
13261: EMPTY
13262: LIST
13263: LIST
13264: LIST
13265: PUSH
13266: LD_OWVAR 67
13270: ARRAY
13271: PLUS
13272: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13273: LD_INT 1
13275: PPUSH
13276: LD_INT 5
13278: PPUSH
13279: CALL_OW 12
13283: PPUSH
13284: LD_INT 179
13286: PPUSH
13287: LD_INT 101
13289: PPUSH
13290: LD_INT 20
13292: PPUSH
13293: LD_INT 1
13295: PPUSH
13296: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13300: LD_INT 350
13302: PPUSH
13303: LD_INT 525
13305: PPUSH
13306: CALL_OW 12
13310: PPUSH
13311: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13315: LD_INT 1
13317: PPUSH
13318: LD_INT 5
13320: PPUSH
13321: CALL_OW 12
13325: PPUSH
13326: LD_INT 9
13328: PPUSH
13329: LD_INT 1
13331: PPUSH
13332: CALL_OW 55
// if time > 4 4$00 then
13336: LD_VAR 0 2
13340: PUSH
13341: LD_INT 8400
13343: GREATER
13344: IFFALSE 13354
// time := 0 0$30 ;
13346: LD_ADDR_VAR 0 2
13350: PUSH
13351: LD_INT 1050
13353: ST_TO_ADDR
// end ;
13354: GO 13227
// end ;
13356: PPOPN 2
13358: END
// every 0 0$30 do var cr , time ;
13359: GO 13361
13361: DISABLE
13362: LD_INT 0
13364: PPUSH
13365: PPUSH
// begin time := 0 0$10 ;
13366: LD_ADDR_VAR 0 2
13370: PUSH
13371: LD_INT 350
13373: ST_TO_ADDR
// while game do
13374: LD_EXP 2
13378: IFFALSE 13512
// begin wait ( time ) ;
13380: LD_VAR 0 2
13384: PPUSH
13385: CALL_OW 67
// time := time + 0 0$10 ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: LD_VAR 0 2
13398: PUSH
13399: LD_INT 350
13401: PLUS
13402: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13403: LD_INT 1
13405: PPUSH
13406: LD_INT 5
13408: PPUSH
13409: CALL_OW 12
13413: PPUSH
13414: LD_INT 11
13416: PPUSH
13417: LD_INT 1
13419: PPUSH
13420: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13424: LD_ADDR_VAR 0 1
13428: PUSH
13429: LD_INT 1
13431: PPUSH
13432: LD_INT 3
13434: PPUSH
13435: CALL_OW 12
13439: ST_TO_ADDR
// if cr = 1 then
13440: LD_VAR 0 1
13444: PUSH
13445: LD_INT 1
13447: EQUAL
13448: IFFALSE 13492
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13450: LD_INT 700
13452: PPUSH
13453: LD_INT 1575
13455: PPUSH
13456: CALL_OW 12
13460: PPUSH
13461: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13465: LD_INT 1
13467: PPUSH
13468: LD_INT 5
13470: PPUSH
13471: CALL_OW 12
13475: PPUSH
13476: LD_INT 34
13478: PPUSH
13479: LD_INT 50
13481: PPUSH
13482: LD_INT 7
13484: PPUSH
13485: LD_INT 1
13487: PPUSH
13488: CALL_OW 56
// end ; if time > 8 8$00 then
13492: LD_VAR 0 2
13496: PUSH
13497: LD_INT 16800
13499: GREATER
13500: IFFALSE 13510
// time := 0 0$40 ;
13502: LD_ADDR_VAR 0 2
13506: PUSH
13507: LD_INT 1400
13509: ST_TO_ADDR
// end ;
13510: GO 13374
// end ; end_of_file
13512: PPOPN 2
13514: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13515: LD_INT 0
13517: PPUSH
13518: PPUSH
// if exist_mode then
13519: LD_VAR 0 2
13523: IFFALSE 13548
// unit := CreateCharacter ( prefix & ident ) else
13525: LD_ADDR_VAR 0 5
13529: PUSH
13530: LD_VAR 0 3
13534: PUSH
13535: LD_VAR 0 1
13539: STR
13540: PPUSH
13541: CALL_OW 34
13545: ST_TO_ADDR
13546: GO 13563
// unit := NewCharacter ( ident ) ;
13548: LD_ADDR_VAR 0 5
13552: PUSH
13553: LD_VAR 0 1
13557: PPUSH
13558: CALL_OW 25
13562: ST_TO_ADDR
// result := unit ;
13563: LD_ADDR_VAR 0 4
13567: PUSH
13568: LD_VAR 0 5
13572: ST_TO_ADDR
// end ;
13573: LD_VAR 0 4
13577: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13578: LD_INT 0
13580: PPUSH
13581: PPUSH
// if not side or not nation then
13582: LD_VAR 0 1
13586: NOT
13587: PUSH
13588: LD_VAR 0 2
13592: NOT
13593: OR
13594: IFFALSE 13598
// exit ;
13596: GO 14234
// case nation of nation_american :
13598: LD_VAR 0 2
13602: PUSH
13603: LD_INT 1
13605: DOUBLE
13606: EQUAL
13607: IFTRUE 13611
13609: GO 13781
13611: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13612: LD_ADDR_VAR 0 4
13616: PUSH
13617: LD_INT 35
13619: PUSH
13620: LD_INT 45
13622: PUSH
13623: LD_INT 46
13625: PUSH
13626: LD_INT 47
13628: PUSH
13629: LD_INT 1
13631: PUSH
13632: LD_INT 2
13634: PUSH
13635: LD_INT 6
13637: PUSH
13638: LD_INT 15
13640: PUSH
13641: LD_INT 16
13643: PUSH
13644: LD_INT 7
13646: PUSH
13647: LD_INT 12
13649: PUSH
13650: LD_INT 13
13652: PUSH
13653: LD_INT 10
13655: PUSH
13656: LD_INT 14
13658: PUSH
13659: LD_INT 20
13661: PUSH
13662: LD_INT 21
13664: PUSH
13665: LD_INT 22
13667: PUSH
13668: LD_INT 25
13670: PUSH
13671: LD_INT 32
13673: PUSH
13674: LD_INT 27
13676: PUSH
13677: LD_INT 36
13679: PUSH
13680: LD_INT 69
13682: PUSH
13683: LD_INT 39
13685: PUSH
13686: LD_INT 34
13688: PUSH
13689: LD_INT 40
13691: PUSH
13692: LD_INT 48
13694: PUSH
13695: LD_INT 49
13697: PUSH
13698: LD_INT 50
13700: PUSH
13701: LD_INT 51
13703: PUSH
13704: LD_INT 52
13706: PUSH
13707: LD_INT 53
13709: PUSH
13710: LD_INT 54
13712: PUSH
13713: LD_INT 55
13715: PUSH
13716: LD_INT 56
13718: PUSH
13719: LD_INT 57
13721: PUSH
13722: LD_INT 58
13724: PUSH
13725: LD_INT 59
13727: PUSH
13728: LD_INT 60
13730: PUSH
13731: LD_INT 61
13733: PUSH
13734: LD_INT 62
13736: PUSH
13737: EMPTY
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: LIST
13771: LIST
13772: LIST
13773: LIST
13774: LIST
13775: LIST
13776: LIST
13777: LIST
13778: ST_TO_ADDR
13779: GO 14158
13781: LD_INT 2
13783: DOUBLE
13784: EQUAL
13785: IFTRUE 13789
13787: GO 13967
13789: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
13790: LD_ADDR_VAR 0 4
13794: PUSH
13795: LD_INT 35
13797: PUSH
13798: LD_INT 45
13800: PUSH
13801: LD_INT 46
13803: PUSH
13804: LD_INT 47
13806: PUSH
13807: LD_INT 70
13809: PUSH
13810: LD_INT 1
13812: PUSH
13813: LD_INT 11
13815: PUSH
13816: LD_INT 3
13818: PUSH
13819: LD_INT 4
13821: PUSH
13822: LD_INT 5
13824: PUSH
13825: LD_INT 6
13827: PUSH
13828: LD_INT 15
13830: PUSH
13831: LD_INT 18
13833: PUSH
13834: LD_INT 7
13836: PUSH
13837: LD_INT 17
13839: PUSH
13840: LD_INT 8
13842: PUSH
13843: LD_INT 20
13845: PUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 22
13851: PUSH
13852: LD_INT 72
13854: PUSH
13855: LD_INT 26
13857: PUSH
13858: LD_INT 69
13860: PUSH
13861: LD_INT 39
13863: PUSH
13864: LD_INT 40
13866: PUSH
13867: LD_INT 41
13869: PUSH
13870: LD_INT 42
13872: PUSH
13873: LD_INT 43
13875: PUSH
13876: LD_INT 48
13878: PUSH
13879: LD_INT 49
13881: PUSH
13882: LD_INT 50
13884: PUSH
13885: LD_INT 51
13887: PUSH
13888: LD_INT 52
13890: PUSH
13891: LD_INT 53
13893: PUSH
13894: LD_INT 54
13896: PUSH
13897: LD_INT 55
13899: PUSH
13900: LD_INT 56
13902: PUSH
13903: LD_INT 60
13905: PUSH
13906: LD_INT 61
13908: PUSH
13909: LD_INT 62
13911: PUSH
13912: LD_INT 66
13914: PUSH
13915: LD_INT 67
13917: PUSH
13918: LD_INT 68
13920: PUSH
13921: EMPTY
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: ST_TO_ADDR
13965: GO 14158
13967: LD_INT 3
13969: DOUBLE
13970: EQUAL
13971: IFTRUE 13975
13973: GO 14157
13975: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
13976: LD_ADDR_VAR 0 4
13980: PUSH
13981: LD_INT 46
13983: PUSH
13984: LD_INT 47
13986: PUSH
13987: LD_INT 1
13989: PUSH
13990: LD_INT 2
13992: PUSH
13993: LD_INT 11
13995: PUSH
13996: LD_INT 9
13998: PUSH
13999: LD_INT 20
14001: PUSH
14002: LD_INT 19
14004: PUSH
14005: LD_INT 21
14007: PUSH
14008: LD_INT 24
14010: PUSH
14011: LD_INT 22
14013: PUSH
14014: LD_INT 25
14016: PUSH
14017: LD_INT 28
14019: PUSH
14020: LD_INT 29
14022: PUSH
14023: LD_INT 30
14025: PUSH
14026: LD_INT 31
14028: PUSH
14029: LD_INT 37
14031: PUSH
14032: LD_INT 38
14034: PUSH
14035: LD_INT 32
14037: PUSH
14038: LD_INT 27
14040: PUSH
14041: LD_INT 33
14043: PUSH
14044: LD_INT 69
14046: PUSH
14047: LD_INT 39
14049: PUSH
14050: LD_INT 34
14052: PUSH
14053: LD_INT 40
14055: PUSH
14056: LD_INT 71
14058: PUSH
14059: LD_INT 23
14061: PUSH
14062: LD_INT 44
14064: PUSH
14065: LD_INT 48
14067: PUSH
14068: LD_INT 49
14070: PUSH
14071: LD_INT 50
14073: PUSH
14074: LD_INT 51
14076: PUSH
14077: LD_INT 52
14079: PUSH
14080: LD_INT 53
14082: PUSH
14083: LD_INT 54
14085: PUSH
14086: LD_INT 55
14088: PUSH
14089: LD_INT 56
14091: PUSH
14092: LD_INT 57
14094: PUSH
14095: LD_INT 58
14097: PUSH
14098: LD_INT 59
14100: PUSH
14101: LD_INT 63
14103: PUSH
14104: LD_INT 64
14106: PUSH
14107: LD_INT 65
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: ST_TO_ADDR
14155: GO 14158
14157: POP
// if state > - 1 and state < 3 then
14158: LD_VAR 0 3
14162: PUSH
14163: LD_INT 1
14165: NEG
14166: GREATER
14167: PUSH
14168: LD_VAR 0 3
14172: PUSH
14173: LD_INT 3
14175: LESS
14176: AND
14177: IFFALSE 14234
// for i in result do
14179: LD_ADDR_VAR 0 5
14183: PUSH
14184: LD_VAR 0 4
14188: PUSH
14189: FOR_IN
14190: IFFALSE 14232
// if GetTech ( i , side ) <> state then
14192: LD_VAR 0 5
14196: PPUSH
14197: LD_VAR 0 1
14201: PPUSH
14202: CALL_OW 321
14206: PUSH
14207: LD_VAR 0 3
14211: NONEQUAL
14212: IFFALSE 14230
// result := result diff i ;
14214: LD_ADDR_VAR 0 4
14218: PUSH
14219: LD_VAR 0 4
14223: PUSH
14224: LD_VAR 0 5
14228: DIFF
14229: ST_TO_ADDR
14230: GO 14189
14232: POP
14233: POP
// end ;
14234: LD_VAR 0 4
14238: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14239: LD_INT 0
14241: PPUSH
14242: PPUSH
14243: PPUSH
// result := true ;
14244: LD_ADDR_VAR 0 3
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14252: LD_ADDR_VAR 0 5
14256: PUSH
14257: LD_VAR 0 2
14261: PPUSH
14262: CALL_OW 480
14266: ST_TO_ADDR
// if not tmp then
14267: LD_VAR 0 5
14271: NOT
14272: IFFALSE 14276
// exit ;
14274: GO 14325
// for i in tmp do
14276: LD_ADDR_VAR 0 4
14280: PUSH
14281: LD_VAR 0 5
14285: PUSH
14286: FOR_IN
14287: IFFALSE 14323
// if GetTech ( i , side ) <> state_researched then
14289: LD_VAR 0 4
14293: PPUSH
14294: LD_VAR 0 1
14298: PPUSH
14299: CALL_OW 321
14303: PUSH
14304: LD_INT 2
14306: NONEQUAL
14307: IFFALSE 14321
// begin result := false ;
14309: LD_ADDR_VAR 0 3
14313: PUSH
14314: LD_INT 0
14316: ST_TO_ADDR
// exit ;
14317: POP
14318: POP
14319: GO 14325
// end ;
14321: GO 14286
14323: POP
14324: POP
// end ;
14325: LD_VAR 0 3
14329: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14330: LD_INT 0
14332: PPUSH
14333: PPUSH
14334: PPUSH
14335: PPUSH
14336: PPUSH
14337: PPUSH
14338: PPUSH
14339: PPUSH
14340: PPUSH
14341: PPUSH
14342: PPUSH
14343: PPUSH
14344: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14345: LD_VAR 0 1
14349: NOT
14350: PUSH
14351: LD_VAR 0 1
14355: PPUSH
14356: CALL_OW 257
14360: PUSH
14361: LD_INT 9
14363: NONEQUAL
14364: OR
14365: IFFALSE 14369
// exit ;
14367: GO 14942
// side := GetSide ( unit ) ;
14369: LD_ADDR_VAR 0 9
14373: PUSH
14374: LD_VAR 0 1
14378: PPUSH
14379: CALL_OW 255
14383: ST_TO_ADDR
// tech_space := tech_spacanom ;
14384: LD_ADDR_VAR 0 12
14388: PUSH
14389: LD_INT 29
14391: ST_TO_ADDR
// tech_time := tech_taurad ;
14392: LD_ADDR_VAR 0 13
14396: PUSH
14397: LD_INT 28
14399: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14400: LD_ADDR_VAR 0 11
14404: PUSH
14405: LD_VAR 0 1
14409: PPUSH
14410: CALL_OW 310
14414: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14415: LD_VAR 0 11
14419: PPUSH
14420: CALL_OW 247
14424: PUSH
14425: LD_INT 2
14427: EQUAL
14428: IFFALSE 14432
// exit ;
14430: GO 14942
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14432: LD_ADDR_VAR 0 8
14436: PUSH
14437: LD_INT 81
14439: PUSH
14440: LD_VAR 0 9
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: PUSH
14449: LD_INT 3
14451: PUSH
14452: LD_INT 21
14454: PUSH
14455: LD_INT 3
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PUSH
14462: EMPTY
14463: LIST
14464: LIST
14465: PUSH
14466: EMPTY
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: ST_TO_ADDR
// if not tmp then
14475: LD_VAR 0 8
14479: NOT
14480: IFFALSE 14484
// exit ;
14482: GO 14942
// if in_unit then
14484: LD_VAR 0 11
14488: IFFALSE 14512
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14490: LD_ADDR_VAR 0 10
14494: PUSH
14495: LD_VAR 0 8
14499: PPUSH
14500: LD_VAR 0 11
14504: PPUSH
14505: CALL_OW 74
14509: ST_TO_ADDR
14510: GO 14532
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14512: LD_ADDR_VAR 0 10
14516: PUSH
14517: LD_VAR 0 8
14521: PPUSH
14522: LD_VAR 0 1
14526: PPUSH
14527: CALL_OW 74
14531: ST_TO_ADDR
// if not enemy then
14532: LD_VAR 0 10
14536: NOT
14537: IFFALSE 14541
// exit ;
14539: GO 14942
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14541: LD_VAR 0 11
14545: PUSH
14546: LD_VAR 0 11
14550: PPUSH
14551: LD_VAR 0 10
14555: PPUSH
14556: CALL_OW 296
14560: PUSH
14561: LD_INT 13
14563: GREATER
14564: AND
14565: PUSH
14566: LD_VAR 0 1
14570: PPUSH
14571: LD_VAR 0 10
14575: PPUSH
14576: CALL_OW 296
14580: PUSH
14581: LD_INT 12
14583: GREATER
14584: OR
14585: IFFALSE 14589
// exit ;
14587: GO 14942
// missile := [ 1 ] ;
14589: LD_ADDR_VAR 0 14
14593: PUSH
14594: LD_INT 1
14596: PUSH
14597: EMPTY
14598: LIST
14599: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14600: LD_VAR 0 9
14604: PPUSH
14605: LD_VAR 0 12
14609: PPUSH
14610: CALL_OW 325
14614: IFFALSE 14643
// missile := Insert ( missile , missile + 1 , 2 ) ;
14616: LD_ADDR_VAR 0 14
14620: PUSH
14621: LD_VAR 0 14
14625: PPUSH
14626: LD_VAR 0 14
14630: PUSH
14631: LD_INT 1
14633: PLUS
14634: PPUSH
14635: LD_INT 2
14637: PPUSH
14638: CALL_OW 2
14642: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14643: LD_VAR 0 9
14647: PPUSH
14648: LD_VAR 0 13
14652: PPUSH
14653: CALL_OW 325
14657: PUSH
14658: LD_VAR 0 10
14662: PPUSH
14663: CALL_OW 255
14667: PPUSH
14668: LD_VAR 0 13
14672: PPUSH
14673: CALL_OW 325
14677: NOT
14678: AND
14679: IFFALSE 14708
// missile := Insert ( missile , missile + 1 , 3 ) ;
14681: LD_ADDR_VAR 0 14
14685: PUSH
14686: LD_VAR 0 14
14690: PPUSH
14691: LD_VAR 0 14
14695: PUSH
14696: LD_INT 1
14698: PLUS
14699: PPUSH
14700: LD_INT 3
14702: PPUSH
14703: CALL_OW 2
14707: ST_TO_ADDR
// if missile < 2 then
14708: LD_VAR 0 14
14712: PUSH
14713: LD_INT 2
14715: LESS
14716: IFFALSE 14720
// exit ;
14718: GO 14942
// x := GetX ( enemy ) ;
14720: LD_ADDR_VAR 0 4
14724: PUSH
14725: LD_VAR 0 10
14729: PPUSH
14730: CALL_OW 250
14734: ST_TO_ADDR
// y := GetY ( enemy ) ;
14735: LD_ADDR_VAR 0 5
14739: PUSH
14740: LD_VAR 0 10
14744: PPUSH
14745: CALL_OW 251
14749: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14750: LD_ADDR_VAR 0 6
14754: PUSH
14755: LD_VAR 0 4
14759: PUSH
14760: LD_INT 1
14762: NEG
14763: PPUSH
14764: LD_INT 1
14766: PPUSH
14767: CALL_OW 12
14771: PLUS
14772: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14773: LD_ADDR_VAR 0 7
14777: PUSH
14778: LD_VAR 0 5
14782: PUSH
14783: LD_INT 1
14785: NEG
14786: PPUSH
14787: LD_INT 1
14789: PPUSH
14790: CALL_OW 12
14794: PLUS
14795: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
14796: LD_VAR 0 6
14800: PPUSH
14801: LD_VAR 0 7
14805: PPUSH
14806: CALL_OW 488
14810: NOT
14811: IFFALSE 14833
// begin _x := x ;
14813: LD_ADDR_VAR 0 6
14817: PUSH
14818: LD_VAR 0 4
14822: ST_TO_ADDR
// _y := y ;
14823: LD_ADDR_VAR 0 7
14827: PUSH
14828: LD_VAR 0 5
14832: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
14833: LD_ADDR_VAR 0 3
14837: PUSH
14838: LD_INT 1
14840: PPUSH
14841: LD_VAR 0 14
14845: PPUSH
14846: CALL_OW 12
14850: ST_TO_ADDR
// case i of 1 :
14851: LD_VAR 0 3
14855: PUSH
14856: LD_INT 1
14858: DOUBLE
14859: EQUAL
14860: IFTRUE 14864
14862: GO 14881
14864: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
14865: LD_VAR 0 1
14869: PPUSH
14870: LD_VAR 0 10
14874: PPUSH
14875: CALL_OW 115
14879: GO 14942
14881: LD_INT 2
14883: DOUBLE
14884: EQUAL
14885: IFTRUE 14889
14887: GO 14911
14889: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
14890: LD_VAR 0 1
14894: PPUSH
14895: LD_VAR 0 6
14899: PPUSH
14900: LD_VAR 0 7
14904: PPUSH
14905: CALL_OW 153
14909: GO 14942
14911: LD_INT 3
14913: DOUBLE
14914: EQUAL
14915: IFTRUE 14919
14917: GO 14941
14919: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
14920: LD_VAR 0 1
14924: PPUSH
14925: LD_VAR 0 6
14929: PPUSH
14930: LD_VAR 0 7
14934: PPUSH
14935: CALL_OW 154
14939: GO 14942
14941: POP
// end ;
14942: LD_VAR 0 2
14946: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
14947: LD_INT 0
14949: PPUSH
14950: PPUSH
14951: PPUSH
14952: PPUSH
14953: PPUSH
14954: PPUSH
// if not unit or not building then
14955: LD_VAR 0 1
14959: NOT
14960: PUSH
14961: LD_VAR 0 2
14965: NOT
14966: OR
14967: IFFALSE 14971
// exit ;
14969: GO 15129
// x := GetX ( building ) ;
14971: LD_ADDR_VAR 0 5
14975: PUSH
14976: LD_VAR 0 2
14980: PPUSH
14981: CALL_OW 250
14985: ST_TO_ADDR
// y := GetY ( building ) ;
14986: LD_ADDR_VAR 0 6
14990: PUSH
14991: LD_VAR 0 2
14995: PPUSH
14996: CALL_OW 251
15000: ST_TO_ADDR
// for i = 0 to 5 do
15001: LD_ADDR_VAR 0 4
15005: PUSH
15006: DOUBLE
15007: LD_INT 0
15009: DEC
15010: ST_TO_ADDR
15011: LD_INT 5
15013: PUSH
15014: FOR_TO
15015: IFFALSE 15127
// begin _x := ShiftX ( x , i , 3 ) ;
15017: LD_ADDR_VAR 0 7
15021: PUSH
15022: LD_VAR 0 5
15026: PPUSH
15027: LD_VAR 0 4
15031: PPUSH
15032: LD_INT 3
15034: PPUSH
15035: CALL_OW 272
15039: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15040: LD_ADDR_VAR 0 8
15044: PUSH
15045: LD_VAR 0 6
15049: PPUSH
15050: LD_VAR 0 4
15054: PPUSH
15055: LD_INT 3
15057: PPUSH
15058: CALL_OW 273
15062: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15063: LD_VAR 0 7
15067: PPUSH
15068: LD_VAR 0 8
15072: PPUSH
15073: CALL_OW 488
15077: NOT
15078: IFFALSE 15082
// continue ;
15080: GO 15014
// if HexInfo ( _x , _y ) = 0 then
15082: LD_VAR 0 7
15086: PPUSH
15087: LD_VAR 0 8
15091: PPUSH
15092: CALL_OW 428
15096: PUSH
15097: LD_INT 0
15099: EQUAL
15100: IFFALSE 15125
// begin ComMoveXY ( unit , _x , _y ) ;
15102: LD_VAR 0 1
15106: PPUSH
15107: LD_VAR 0 7
15111: PPUSH
15112: LD_VAR 0 8
15116: PPUSH
15117: CALL_OW 111
// exit ;
15121: POP
15122: POP
15123: GO 15129
// end ; end ;
15125: GO 15014
15127: POP
15128: POP
// end ;
15129: LD_VAR 0 3
15133: RET
// export function ScanBase ( side , base_area ) ; begin
15134: LD_INT 0
15136: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15137: LD_ADDR_VAR 0 3
15141: PUSH
15142: LD_VAR 0 2
15146: PPUSH
15147: LD_INT 81
15149: PUSH
15150: LD_VAR 0 1
15154: PUSH
15155: EMPTY
15156: LIST
15157: LIST
15158: PPUSH
15159: CALL_OW 70
15163: ST_TO_ADDR
// end ;
15164: LD_VAR 0 3
15168: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15169: LD_INT 0
15171: PPUSH
15172: PPUSH
15173: PPUSH
15174: PPUSH
15175: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15176: LD_VAR 0 1
15180: NOT
15181: PUSH
15182: LD_EXP 58
15186: PUSH
15187: LD_VAR 0 1
15191: ARRAY
15192: NOT
15193: OR
15194: PUSH
15195: LD_VAR 0 2
15199: NOT
15200: OR
15201: PUSH
15202: LD_VAR 0 3
15206: NOT
15207: OR
15208: IFFALSE 15212
// exit ;
15210: GO 15662
// side := mc_sides [ base ] ;
15212: LD_ADDR_VAR 0 6
15216: PUSH
15217: LD_EXP 84
15221: PUSH
15222: LD_VAR 0 1
15226: ARRAY
15227: ST_TO_ADDR
// if not side then
15228: LD_VAR 0 6
15232: NOT
15233: IFFALSE 15237
// exit ;
15235: GO 15662
// for i in solds do
15237: LD_ADDR_VAR 0 7
15241: PUSH
15242: LD_VAR 0 2
15246: PUSH
15247: FOR_IN
15248: IFFALSE 15309
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15250: LD_VAR 0 7
15254: PPUSH
15255: CALL_OW 310
15259: PPUSH
15260: CALL_OW 266
15264: PUSH
15265: LD_INT 32
15267: PUSH
15268: LD_INT 31
15270: PUSH
15271: EMPTY
15272: LIST
15273: LIST
15274: IN
15275: IFFALSE 15295
// solds := solds diff i else
15277: LD_ADDR_VAR 0 2
15281: PUSH
15282: LD_VAR 0 2
15286: PUSH
15287: LD_VAR 0 7
15291: DIFF
15292: ST_TO_ADDR
15293: GO 15307
// SetTag ( i , 18 ) ;
15295: LD_VAR 0 7
15299: PPUSH
15300: LD_INT 18
15302: PPUSH
15303: CALL_OW 109
15307: GO 15247
15309: POP
15310: POP
// if not solds then
15311: LD_VAR 0 2
15315: NOT
15316: IFFALSE 15320
// exit ;
15318: GO 15662
// repeat wait ( 0 0$1 ) ;
15320: LD_INT 35
15322: PPUSH
15323: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15327: LD_ADDR_VAR 0 5
15331: PUSH
15332: LD_VAR 0 6
15336: PPUSH
15337: LD_VAR 0 3
15341: PPUSH
15342: CALL 15134 0 2
15346: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15347: LD_VAR 0 5
15351: NOT
15352: PUSH
15353: LD_VAR 0 5
15357: PUSH
15358: LD_INT 3
15360: GREATER
15361: OR
15362: PUSH
15363: LD_EXP 80
15367: PUSH
15368: LD_VAR 0 1
15372: ARRAY
15373: OR
15374: IFFALSE 15415
// begin for i in solds do
15376: LD_ADDR_VAR 0 7
15380: PUSH
15381: LD_VAR 0 2
15385: PUSH
15386: FOR_IN
15387: IFFALSE 15411
// if HasTask ( i ) then
15389: LD_VAR 0 7
15393: PPUSH
15394: CALL_OW 314
15398: IFFALSE 15409
// ComStop ( i ) ;
15400: LD_VAR 0 7
15404: PPUSH
15405: CALL_OW 141
15409: GO 15386
15411: POP
15412: POP
// break ;
15413: GO 15650
// end ; for i in solds do
15415: LD_ADDR_VAR 0 7
15419: PUSH
15420: LD_VAR 0 2
15424: PUSH
15425: FOR_IN
15426: IFFALSE 15642
// begin if IsInUnit ( i ) then
15428: LD_VAR 0 7
15432: PPUSH
15433: CALL_OW 310
15437: IFFALSE 15448
// ComExitBuilding ( i ) ;
15439: LD_VAR 0 7
15443: PPUSH
15444: CALL_OW 122
// if GetLives ( i ) > 333 then
15448: LD_VAR 0 7
15452: PPUSH
15453: CALL_OW 256
15457: PUSH
15458: LD_INT 333
15460: GREATER
15461: IFFALSE 15489
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15463: LD_VAR 0 7
15467: PPUSH
15468: LD_VAR 0 5
15472: PPUSH
15473: LD_VAR 0 7
15477: PPUSH
15478: CALL_OW 74
15482: PPUSH
15483: CALL_OW 115
15487: GO 15640
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15489: LD_ADDR_VAR 0 8
15493: PUSH
15494: LD_EXP 58
15498: PUSH
15499: LD_VAR 0 1
15503: ARRAY
15504: PPUSH
15505: LD_INT 2
15507: PUSH
15508: LD_INT 30
15510: PUSH
15511: LD_INT 0
15513: PUSH
15514: EMPTY
15515: LIST
15516: LIST
15517: PUSH
15518: LD_INT 30
15520: PUSH
15521: LD_INT 1
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: PUSH
15528: LD_INT 30
15530: PUSH
15531: LD_INT 6
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: EMPTY
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: PPUSH
15544: CALL_OW 72
15548: PPUSH
15549: LD_VAR 0 7
15553: PPUSH
15554: CALL_OW 74
15558: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15559: LD_VAR 0 7
15563: PPUSH
15564: LD_VAR 0 8
15568: PPUSH
15569: CALL_OW 250
15573: PPUSH
15574: LD_INT 3
15576: PPUSH
15577: LD_INT 5
15579: PPUSH
15580: CALL_OW 272
15584: PPUSH
15585: LD_VAR 0 8
15589: PPUSH
15590: CALL_OW 251
15594: PPUSH
15595: LD_INT 3
15597: PPUSH
15598: LD_INT 5
15600: PPUSH
15601: CALL_OW 273
15605: PPUSH
15606: CALL_OW 111
// SetTag ( i , 0 ) ;
15610: LD_VAR 0 7
15614: PPUSH
15615: LD_INT 0
15617: PPUSH
15618: CALL_OW 109
// solds := solds diff i ;
15622: LD_ADDR_VAR 0 2
15626: PUSH
15627: LD_VAR 0 2
15631: PUSH
15632: LD_VAR 0 7
15636: DIFF
15637: ST_TO_ADDR
// continue ;
15638: GO 15425
// end ; end ;
15640: GO 15425
15642: POP
15643: POP
// until solds ;
15644: LD_VAR 0 2
15648: IFFALSE 15320
// MC_Reset ( base , 18 ) ;
15650: LD_VAR 0 1
15654: PPUSH
15655: LD_INT 18
15657: PPUSH
15658: CALL 59036 0 2
// end ;
15662: LD_VAR 0 4
15666: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15667: LD_INT 0
15669: PPUSH
15670: PPUSH
15671: PPUSH
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
15677: PPUSH
15678: PPUSH
15679: PPUSH
15680: PPUSH
15681: PPUSH
15682: PPUSH
15683: PPUSH
15684: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15685: LD_ADDR_VAR 0 12
15689: PUSH
15690: LD_EXP 58
15694: PUSH
15695: LD_VAR 0 1
15699: ARRAY
15700: PPUSH
15701: LD_INT 25
15703: PUSH
15704: LD_INT 3
15706: PUSH
15707: EMPTY
15708: LIST
15709: LIST
15710: PPUSH
15711: CALL_OW 72
15715: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15716: LD_ADDR_VAR 0 8
15720: PUSH
15721: LD_EXP 58
15725: PUSH
15726: LD_VAR 0 1
15730: ARRAY
15731: PPUSH
15732: LD_INT 2
15734: PUSH
15735: LD_INT 25
15737: PUSH
15738: LD_INT 1
15740: PUSH
15741: EMPTY
15742: LIST
15743: LIST
15744: PUSH
15745: LD_INT 25
15747: PUSH
15748: LD_INT 5
15750: PUSH
15751: EMPTY
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 25
15757: PUSH
15758: LD_INT 8
15760: PUSH
15761: EMPTY
15762: LIST
15763: LIST
15764: PUSH
15765: LD_INT 25
15767: PUSH
15768: LD_INT 9
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: PUSH
15775: EMPTY
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: PPUSH
15782: CALL_OW 72
15786: ST_TO_ADDR
// if not defenders and not solds then
15787: LD_VAR 0 2
15791: NOT
15792: PUSH
15793: LD_VAR 0 8
15797: NOT
15798: AND
15799: IFFALSE 15803
// exit ;
15801: GO 17169
// depot_under_attack := false ;
15803: LD_ADDR_VAR 0 16
15807: PUSH
15808: LD_INT 0
15810: ST_TO_ADDR
// sold_defenders := [ ] ;
15811: LD_ADDR_VAR 0 17
15815: PUSH
15816: EMPTY
15817: ST_TO_ADDR
// if mechs then
15818: LD_VAR 0 12
15822: IFFALSE 15951
// for i in defenders do
15824: LD_ADDR_VAR 0 5
15828: PUSH
15829: LD_VAR 0 2
15833: PUSH
15834: FOR_IN
15835: IFFALSE 15949
// begin SetTag ( i , 20 ) ;
15837: LD_VAR 0 5
15841: PPUSH
15842: LD_INT 20
15844: PPUSH
15845: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
15849: LD_VAR 0 5
15853: PPUSH
15854: CALL_OW 263
15858: PUSH
15859: LD_INT 1
15861: EQUAL
15862: PUSH
15863: LD_VAR 0 5
15867: PPUSH
15868: CALL_OW 311
15872: NOT
15873: AND
15874: PUSH
15875: LD_VAR 0 12
15879: AND
15880: IFFALSE 15947
// begin un := mechs [ 1 ] ;
15882: LD_ADDR_VAR 0 10
15886: PUSH
15887: LD_VAR 0 12
15891: PUSH
15892: LD_INT 1
15894: ARRAY
15895: ST_TO_ADDR
// ComExitBuilding ( un ) ;
15896: LD_VAR 0 10
15900: PPUSH
15901: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
15905: LD_VAR 0 10
15909: PPUSH
15910: LD_VAR 0 5
15914: PPUSH
15915: CALL_OW 180
// SetTag ( un , 19 ) ;
15919: LD_VAR 0 10
15923: PPUSH
15924: LD_INT 19
15926: PPUSH
15927: CALL_OW 109
// mechs := mechs diff un ;
15931: LD_ADDR_VAR 0 12
15935: PUSH
15936: LD_VAR 0 12
15940: PUSH
15941: LD_VAR 0 10
15945: DIFF
15946: ST_TO_ADDR
// end ; end ;
15947: GO 15834
15949: POP
15950: POP
// if solds then
15951: LD_VAR 0 8
15955: IFFALSE 16014
// for i in solds do
15957: LD_ADDR_VAR 0 5
15961: PUSH
15962: LD_VAR 0 8
15966: PUSH
15967: FOR_IN
15968: IFFALSE 16012
// if not GetTag ( i ) then
15970: LD_VAR 0 5
15974: PPUSH
15975: CALL_OW 110
15979: NOT
15980: IFFALSE 16010
// begin defenders := defenders union i ;
15982: LD_ADDR_VAR 0 2
15986: PUSH
15987: LD_VAR 0 2
15991: PUSH
15992: LD_VAR 0 5
15996: UNION
15997: ST_TO_ADDR
// SetTag ( i , 18 ) ;
15998: LD_VAR 0 5
16002: PPUSH
16003: LD_INT 18
16005: PPUSH
16006: CALL_OW 109
// end ;
16010: GO 15967
16012: POP
16013: POP
// repeat wait ( 0 0$1 ) ;
16014: LD_INT 35
16016: PPUSH
16017: CALL_OW 67
// enemy := mc_scan [ base ] ;
16021: LD_ADDR_VAR 0 3
16025: PUSH
16026: LD_EXP 81
16030: PUSH
16031: LD_VAR 0 1
16035: ARRAY
16036: ST_TO_ADDR
// for i in defenders do
16037: LD_ADDR_VAR 0 5
16041: PUSH
16042: LD_VAR 0 2
16046: PUSH
16047: FOR_IN
16048: IFFALSE 16733
// begin e := NearestUnitToUnit ( enemy , i ) ;
16050: LD_ADDR_VAR 0 13
16054: PUSH
16055: LD_VAR 0 3
16059: PPUSH
16060: LD_VAR 0 5
16064: PPUSH
16065: CALL_OW 74
16069: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16070: LD_ADDR_VAR 0 16
16074: PUSH
16075: LD_EXP 58
16079: PUSH
16080: LD_VAR 0 1
16084: ARRAY
16085: PPUSH
16086: LD_INT 2
16088: PUSH
16089: LD_INT 30
16091: PUSH
16092: LD_INT 0
16094: PUSH
16095: EMPTY
16096: LIST
16097: LIST
16098: PUSH
16099: LD_INT 30
16101: PUSH
16102: LD_INT 1
16104: PUSH
16105: EMPTY
16106: LIST
16107: LIST
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: LIST
16113: PPUSH
16114: CALL_OW 72
16118: NOT
16119: PUSH
16120: LD_EXP 58
16124: PUSH
16125: LD_VAR 0 1
16129: ARRAY
16130: PPUSH
16131: LD_INT 2
16133: PUSH
16134: LD_INT 30
16136: PUSH
16137: LD_INT 0
16139: PUSH
16140: EMPTY
16141: LIST
16142: LIST
16143: PUSH
16144: LD_INT 30
16146: PUSH
16147: LD_INT 1
16149: PUSH
16150: EMPTY
16151: LIST
16152: LIST
16153: PUSH
16154: EMPTY
16155: LIST
16156: LIST
16157: LIST
16158: PPUSH
16159: CALL_OW 72
16163: PPUSH
16164: CALL_OW 256
16168: PUSH
16169: LD_INT 600
16171: LESS
16172: OR
16173: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16174: LD_VAR 0 5
16178: PPUSH
16179: CALL_OW 247
16183: PUSH
16184: LD_INT 2
16186: DOUBLE
16187: EQUAL
16188: IFTRUE 16192
16190: GO 16439
16192: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16193: LD_VAR 0 5
16197: PPUSH
16198: CALL_OW 256
16202: PUSH
16203: LD_INT 650
16205: GREATER
16206: PUSH
16207: LD_VAR 0 5
16211: PPUSH
16212: LD_VAR 0 13
16216: PPUSH
16217: CALL_OW 296
16221: PUSH
16222: LD_INT 40
16224: LESS
16225: AND
16226: IFFALSE 16244
// ComAttackUnit ( i , e ) else
16228: LD_VAR 0 5
16232: PPUSH
16233: LD_VAR 0 13
16237: PPUSH
16238: CALL_OW 115
16242: GO 16322
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16244: LD_VAR 0 5
16248: PPUSH
16249: LD_VAR 0 13
16253: PPUSH
16254: CALL_OW 296
16258: PUSH
16259: LD_INT 30
16261: GREATEREQUAL
16262: PUSH
16263: LD_VAR 0 5
16267: PPUSH
16268: CALL_OW 256
16272: PUSH
16273: LD_INT 650
16275: LESSEQUAL
16276: OR
16277: PUSH
16278: LD_VAR 0 5
16282: PPUSH
16283: LD_EXP 82
16287: PUSH
16288: LD_VAR 0 1
16292: ARRAY
16293: PPUSH
16294: CALL_OW 308
16298: NOT
16299: AND
16300: IFFALSE 16322
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16302: LD_VAR 0 5
16306: PPUSH
16307: LD_EXP 82
16311: PUSH
16312: LD_VAR 0 1
16316: ARRAY
16317: PPUSH
16318: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16322: LD_VAR 0 5
16326: PPUSH
16327: CALL_OW 256
16331: PUSH
16332: LD_INT 998
16334: LESS
16335: PUSH
16336: LD_VAR 0 5
16340: PPUSH
16341: CALL_OW 263
16345: PUSH
16346: LD_INT 1
16348: EQUAL
16349: AND
16350: PUSH
16351: LD_VAR 0 5
16355: PPUSH
16356: CALL_OW 311
16360: AND
16361: PUSH
16362: LD_VAR 0 5
16366: PPUSH
16367: LD_EXP 82
16371: PUSH
16372: LD_VAR 0 1
16376: ARRAY
16377: PPUSH
16378: CALL_OW 308
16382: AND
16383: IFFALSE 16437
// begin mech := IsDrivenBy ( i ) ;
16385: LD_ADDR_VAR 0 9
16389: PUSH
16390: LD_VAR 0 5
16394: PPUSH
16395: CALL_OW 311
16399: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16400: LD_VAR 0 9
16404: PPUSH
16405: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16409: LD_VAR 0 9
16413: PPUSH
16414: LD_VAR 0 5
16418: PPUSH
16419: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16423: LD_VAR 0 9
16427: PPUSH
16428: LD_VAR 0 5
16432: PPUSH
16433: CALL_OW 180
// end ; end ; unit_human :
16437: GO 16704
16439: LD_INT 1
16441: DOUBLE
16442: EQUAL
16443: IFTRUE 16447
16445: GO 16703
16447: POP
// begin b := IsInUnit ( i ) ;
16448: LD_ADDR_VAR 0 18
16452: PUSH
16453: LD_VAR 0 5
16457: PPUSH
16458: CALL_OW 310
16462: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16463: LD_ADDR_VAR 0 19
16467: PUSH
16468: LD_VAR 0 18
16472: NOT
16473: PUSH
16474: LD_VAR 0 18
16478: PPUSH
16479: CALL_OW 266
16483: PUSH
16484: LD_INT 32
16486: PUSH
16487: LD_INT 31
16489: PUSH
16490: EMPTY
16491: LIST
16492: LIST
16493: IN
16494: OR
16495: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16496: LD_VAR 0 16
16500: PUSH
16501: LD_VAR 0 2
16505: PPUSH
16506: LD_INT 21
16508: PUSH
16509: LD_INT 2
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 72
16520: PUSH
16521: LD_INT 1
16523: LESSEQUAL
16524: OR
16525: PUSH
16526: LD_VAR 0 19
16530: AND
16531: PUSH
16532: LD_VAR 0 5
16536: PUSH
16537: LD_VAR 0 17
16541: IN
16542: NOT
16543: AND
16544: IFFALSE 16637
// begin if b then
16546: LD_VAR 0 18
16550: IFFALSE 16599
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16552: LD_VAR 0 18
16556: PPUSH
16557: LD_VAR 0 3
16561: PPUSH
16562: LD_VAR 0 18
16566: PPUSH
16567: CALL_OW 74
16571: PPUSH
16572: CALL_OW 296
16576: PUSH
16577: LD_INT 10
16579: LESS
16580: PUSH
16581: LD_VAR 0 18
16585: PPUSH
16586: CALL_OW 461
16590: PUSH
16591: LD_INT 7
16593: NONEQUAL
16594: AND
16595: IFFALSE 16599
// continue ;
16597: GO 16047
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16599: LD_ADDR_VAR 0 17
16603: PUSH
16604: LD_VAR 0 17
16608: PPUSH
16609: LD_VAR 0 17
16613: PUSH
16614: LD_INT 1
16616: PLUS
16617: PPUSH
16618: LD_VAR 0 5
16622: PPUSH
16623: CALL_OW 1
16627: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16628: LD_VAR 0 5
16632: PPUSH
16633: CALL_OW 122
// end ; if sold_defenders then
16637: LD_VAR 0 17
16641: IFFALSE 16701
// if i in sold_defenders then
16643: LD_VAR 0 5
16647: PUSH
16648: LD_VAR 0 17
16652: IN
16653: IFFALSE 16701
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16655: LD_VAR 0 5
16659: PPUSH
16660: CALL_OW 314
16664: NOT
16665: PUSH
16666: LD_VAR 0 5
16670: PPUSH
16671: LD_VAR 0 13
16675: PPUSH
16676: CALL_OW 296
16680: PUSH
16681: LD_INT 30
16683: LESS
16684: AND
16685: IFFALSE 16701
// ComAttackUnit ( i , e ) ;
16687: LD_VAR 0 5
16691: PPUSH
16692: LD_VAR 0 13
16696: PPUSH
16697: CALL_OW 115
// end ; end ; end ;
16701: GO 16704
16703: POP
// if IsDead ( i ) then
16704: LD_VAR 0 5
16708: PPUSH
16709: CALL_OW 301
16713: IFFALSE 16731
// defenders := defenders diff i ;
16715: LD_ADDR_VAR 0 2
16719: PUSH
16720: LD_VAR 0 2
16724: PUSH
16725: LD_VAR 0 5
16729: DIFF
16730: ST_TO_ADDR
// end ;
16731: GO 16047
16733: POP
16734: POP
// until not enemy or not defenders ;
16735: LD_VAR 0 3
16739: NOT
16740: PUSH
16741: LD_VAR 0 2
16745: NOT
16746: OR
16747: IFFALSE 16014
// MC_Reset ( base , 18 ) ;
16749: LD_VAR 0 1
16753: PPUSH
16754: LD_INT 18
16756: PPUSH
16757: CALL 59036 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16761: LD_ADDR_VAR 0 2
16765: PUSH
16766: LD_VAR 0 2
16770: PUSH
16771: LD_VAR 0 2
16775: PPUSH
16776: LD_INT 2
16778: PUSH
16779: LD_INT 25
16781: PUSH
16782: LD_INT 1
16784: PUSH
16785: EMPTY
16786: LIST
16787: LIST
16788: PUSH
16789: LD_INT 25
16791: PUSH
16792: LD_INT 5
16794: PUSH
16795: EMPTY
16796: LIST
16797: LIST
16798: PUSH
16799: LD_INT 25
16801: PUSH
16802: LD_INT 8
16804: PUSH
16805: EMPTY
16806: LIST
16807: LIST
16808: PUSH
16809: LD_INT 25
16811: PUSH
16812: LD_INT 9
16814: PUSH
16815: EMPTY
16816: LIST
16817: LIST
16818: PUSH
16819: EMPTY
16820: LIST
16821: LIST
16822: LIST
16823: LIST
16824: LIST
16825: PPUSH
16826: CALL_OW 72
16830: DIFF
16831: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
16832: LD_VAR 0 3
16836: NOT
16837: PUSH
16838: LD_VAR 0 2
16842: PPUSH
16843: LD_INT 21
16845: PUSH
16846: LD_INT 2
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 72
16857: AND
16858: IFFALSE 17120
// begin tmp := FilterByTag ( defenders , 19 ) ;
16860: LD_ADDR_VAR 0 11
16864: PUSH
16865: LD_VAR 0 2
16869: PPUSH
16870: LD_INT 19
16872: PPUSH
16873: CALL 53467 0 2
16877: ST_TO_ADDR
// if tmp then
16878: LD_VAR 0 11
16882: IFFALSE 16952
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
16884: LD_ADDR_VAR 0 11
16888: PUSH
16889: LD_VAR 0 11
16893: PPUSH
16894: LD_INT 25
16896: PUSH
16897: LD_INT 3
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PPUSH
16904: CALL_OW 72
16908: ST_TO_ADDR
// if tmp then
16909: LD_VAR 0 11
16913: IFFALSE 16952
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
16915: LD_ADDR_EXP 70
16919: PUSH
16920: LD_EXP 70
16924: PPUSH
16925: LD_VAR 0 1
16929: PPUSH
16930: LD_EXP 70
16934: PUSH
16935: LD_VAR 0 1
16939: ARRAY
16940: PUSH
16941: LD_VAR 0 11
16945: UNION
16946: PPUSH
16947: CALL_OW 1
16951: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
16952: LD_VAR 0 1
16956: PPUSH
16957: LD_INT 19
16959: PPUSH
16960: CALL 59036 0 2
// repeat wait ( 0 0$1 ) ;
16964: LD_INT 35
16966: PPUSH
16967: CALL_OW 67
// for i in defenders do
16971: LD_ADDR_VAR 0 5
16975: PUSH
16976: LD_VAR 0 2
16980: PUSH
16981: FOR_IN
16982: IFFALSE 17071
// begin if not IsInArea ( i , mc_parking [ base ] ) then
16984: LD_VAR 0 5
16988: PPUSH
16989: LD_EXP 82
16993: PUSH
16994: LD_VAR 0 1
16998: ARRAY
16999: PPUSH
17000: CALL_OW 308
17004: NOT
17005: IFFALSE 17029
// ComMoveToArea ( i , mc_parking [ base ] ) else
17007: LD_VAR 0 5
17011: PPUSH
17012: LD_EXP 82
17016: PUSH
17017: LD_VAR 0 1
17021: ARRAY
17022: PPUSH
17023: CALL_OW 113
17027: GO 17069
// if GetControl ( i ) = control_manual then
17029: LD_VAR 0 5
17033: PPUSH
17034: CALL_OW 263
17038: PUSH
17039: LD_INT 1
17041: EQUAL
17042: IFFALSE 17069
// if IsDrivenBy ( i ) then
17044: LD_VAR 0 5
17048: PPUSH
17049: CALL_OW 311
17053: IFFALSE 17069
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17055: LD_VAR 0 5
17059: PPUSH
17060: CALL_OW 311
17064: PPUSH
17065: CALL_OW 121
// end ;
17069: GO 16981
17071: POP
17072: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17073: LD_VAR 0 2
17077: PPUSH
17078: LD_INT 95
17080: PUSH
17081: LD_EXP 82
17085: PUSH
17086: LD_VAR 0 1
17090: ARRAY
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PPUSH
17096: CALL_OW 72
17100: PUSH
17101: LD_VAR 0 2
17105: EQUAL
17106: PUSH
17107: LD_EXP 81
17111: PUSH
17112: LD_VAR 0 1
17116: ARRAY
17117: OR
17118: IFFALSE 16964
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17120: LD_ADDR_EXP 80
17124: PUSH
17125: LD_EXP 80
17129: PPUSH
17130: LD_VAR 0 1
17134: PPUSH
17135: LD_EXP 80
17139: PUSH
17140: LD_VAR 0 1
17144: ARRAY
17145: PUSH
17146: LD_VAR 0 2
17150: UNION
17151: PPUSH
17152: CALL_OW 1
17156: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17157: LD_VAR 0 1
17161: PPUSH
17162: LD_INT 20
17164: PPUSH
17165: CALL 59036 0 2
// end ;
17169: LD_VAR 0 4
17173: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17174: LD_INT 0
17176: PPUSH
17177: PPUSH
17178: PPUSH
17179: PPUSH
// result := false ;
17180: LD_ADDR_VAR 0 2
17184: PUSH
17185: LD_INT 0
17187: ST_TO_ADDR
// side := GetSide ( unit ) ;
17188: LD_ADDR_VAR 0 3
17192: PUSH
17193: LD_VAR 0 1
17197: PPUSH
17198: CALL_OW 255
17202: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17203: LD_ADDR_VAR 0 4
17207: PUSH
17208: LD_VAR 0 1
17212: PPUSH
17213: CALL_OW 248
17217: ST_TO_ADDR
// case nat of 1 :
17218: LD_VAR 0 4
17222: PUSH
17223: LD_INT 1
17225: DOUBLE
17226: EQUAL
17227: IFTRUE 17231
17229: GO 17242
17231: POP
// tech := tech_lassight ; 2 :
17232: LD_ADDR_VAR 0 5
17236: PUSH
17237: LD_INT 12
17239: ST_TO_ADDR
17240: GO 17281
17242: LD_INT 2
17244: DOUBLE
17245: EQUAL
17246: IFTRUE 17250
17248: GO 17261
17250: POP
// tech := tech_mortar ; 3 :
17251: LD_ADDR_VAR 0 5
17255: PUSH
17256: LD_INT 41
17258: ST_TO_ADDR
17259: GO 17281
17261: LD_INT 3
17263: DOUBLE
17264: EQUAL
17265: IFTRUE 17269
17267: GO 17280
17269: POP
// tech := tech_bazooka ; end ;
17270: LD_ADDR_VAR 0 5
17274: PUSH
17275: LD_INT 44
17277: ST_TO_ADDR
17278: GO 17281
17280: POP
// if Researched ( side , tech ) then
17281: LD_VAR 0 3
17285: PPUSH
17286: LD_VAR 0 5
17290: PPUSH
17291: CALL_OW 325
17295: IFFALSE 17322
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17297: LD_ADDR_VAR 0 2
17301: PUSH
17302: LD_INT 5
17304: PUSH
17305: LD_INT 8
17307: PUSH
17308: LD_INT 9
17310: PUSH
17311: EMPTY
17312: LIST
17313: LIST
17314: LIST
17315: PUSH
17316: LD_VAR 0 4
17320: ARRAY
17321: ST_TO_ADDR
// end ;
17322: LD_VAR 0 2
17326: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17327: LD_INT 0
17329: PPUSH
17330: PPUSH
17331: PPUSH
// if not mines then
17332: LD_VAR 0 2
17336: NOT
17337: IFFALSE 17341
// exit ;
17339: GO 17485
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17341: LD_ADDR_VAR 0 5
17345: PUSH
17346: LD_INT 81
17348: PUSH
17349: LD_VAR 0 1
17353: PUSH
17354: EMPTY
17355: LIST
17356: LIST
17357: PUSH
17358: LD_INT 3
17360: PUSH
17361: LD_INT 21
17363: PUSH
17364: LD_INT 3
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PUSH
17371: EMPTY
17372: LIST
17373: LIST
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: PPUSH
17379: CALL_OW 69
17383: ST_TO_ADDR
// for i in mines do
17384: LD_ADDR_VAR 0 4
17388: PUSH
17389: LD_VAR 0 2
17393: PUSH
17394: FOR_IN
17395: IFFALSE 17483
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17397: LD_VAR 0 4
17401: PUSH
17402: LD_INT 1
17404: ARRAY
17405: PPUSH
17406: LD_VAR 0 4
17410: PUSH
17411: LD_INT 2
17413: ARRAY
17414: PPUSH
17415: CALL_OW 458
17419: NOT
17420: IFFALSE 17424
// continue ;
17422: GO 17394
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17424: LD_VAR 0 4
17428: PUSH
17429: LD_INT 1
17431: ARRAY
17432: PPUSH
17433: LD_VAR 0 4
17437: PUSH
17438: LD_INT 2
17440: ARRAY
17441: PPUSH
17442: CALL_OW 428
17446: PUSH
17447: LD_VAR 0 5
17451: IN
17452: IFFALSE 17481
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17454: LD_VAR 0 4
17458: PUSH
17459: LD_INT 1
17461: ARRAY
17462: PPUSH
17463: LD_VAR 0 4
17467: PUSH
17468: LD_INT 2
17470: ARRAY
17471: PPUSH
17472: LD_VAR 0 1
17476: PPUSH
17477: CALL_OW 456
// end ;
17481: GO 17394
17483: POP
17484: POP
// end ;
17485: LD_VAR 0 3
17489: RET
// export function Count ( array ) ; var i ; begin
17490: LD_INT 0
17492: PPUSH
17493: PPUSH
// result := 0 ;
17494: LD_ADDR_VAR 0 2
17498: PUSH
17499: LD_INT 0
17501: ST_TO_ADDR
// for i in array do
17502: LD_ADDR_VAR 0 3
17506: PUSH
17507: LD_VAR 0 1
17511: PUSH
17512: FOR_IN
17513: IFFALSE 17537
// if i then
17515: LD_VAR 0 3
17519: IFFALSE 17535
// result := result + 1 ;
17521: LD_ADDR_VAR 0 2
17525: PUSH
17526: LD_VAR 0 2
17530: PUSH
17531: LD_INT 1
17533: PLUS
17534: ST_TO_ADDR
17535: GO 17512
17537: POP
17538: POP
// end ;
17539: LD_VAR 0 2
17543: RET
// export function IsEmpty ( building ) ; begin
17544: LD_INT 0
17546: PPUSH
// if not building then
17547: LD_VAR 0 1
17551: NOT
17552: IFFALSE 17556
// exit ;
17554: GO 17599
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17556: LD_ADDR_VAR 0 2
17560: PUSH
17561: LD_VAR 0 1
17565: PUSH
17566: LD_INT 22
17568: PUSH
17569: LD_VAR 0 1
17573: PPUSH
17574: CALL_OW 255
17578: PUSH
17579: EMPTY
17580: LIST
17581: LIST
17582: PUSH
17583: LD_INT 58
17585: PUSH
17586: EMPTY
17587: LIST
17588: PUSH
17589: EMPTY
17590: LIST
17591: LIST
17592: PPUSH
17593: CALL_OW 69
17597: IN
17598: ST_TO_ADDR
// end ;
17599: LD_VAR 0 2
17603: RET
// export function IsNotFull ( building ) ; begin
17604: LD_INT 0
17606: PPUSH
// if not building then
17607: LD_VAR 0 1
17611: NOT
17612: IFFALSE 17616
// exit ;
17614: GO 17635
// result := UnitsInside ( building ) < 6 ;
17616: LD_ADDR_VAR 0 2
17620: PUSH
17621: LD_VAR 0 1
17625: PPUSH
17626: CALL_OW 313
17630: PUSH
17631: LD_INT 6
17633: LESS
17634: ST_TO_ADDR
// end ;
17635: LD_VAR 0 2
17639: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17640: LD_INT 0
17642: PPUSH
17643: PPUSH
17644: PPUSH
17645: PPUSH
// tmp := [ ] ;
17646: LD_ADDR_VAR 0 3
17650: PUSH
17651: EMPTY
17652: ST_TO_ADDR
// list := [ ] ;
17653: LD_ADDR_VAR 0 5
17657: PUSH
17658: EMPTY
17659: ST_TO_ADDR
// for i = 16 to 25 do
17660: LD_ADDR_VAR 0 4
17664: PUSH
17665: DOUBLE
17666: LD_INT 16
17668: DEC
17669: ST_TO_ADDR
17670: LD_INT 25
17672: PUSH
17673: FOR_TO
17674: IFFALSE 17747
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17676: LD_ADDR_VAR 0 3
17680: PUSH
17681: LD_VAR 0 3
17685: PUSH
17686: LD_INT 22
17688: PUSH
17689: LD_VAR 0 1
17693: PPUSH
17694: CALL_OW 255
17698: PUSH
17699: EMPTY
17700: LIST
17701: LIST
17702: PUSH
17703: LD_INT 91
17705: PUSH
17706: LD_VAR 0 1
17710: PUSH
17711: LD_INT 6
17713: PUSH
17714: EMPTY
17715: LIST
17716: LIST
17717: LIST
17718: PUSH
17719: LD_INT 30
17721: PUSH
17722: LD_VAR 0 4
17726: PUSH
17727: EMPTY
17728: LIST
17729: LIST
17730: PUSH
17731: EMPTY
17732: LIST
17733: LIST
17734: LIST
17735: PUSH
17736: EMPTY
17737: LIST
17738: PPUSH
17739: CALL_OW 69
17743: ADD
17744: ST_TO_ADDR
17745: GO 17673
17747: POP
17748: POP
// for i = 1 to tmp do
17749: LD_ADDR_VAR 0 4
17753: PUSH
17754: DOUBLE
17755: LD_INT 1
17757: DEC
17758: ST_TO_ADDR
17759: LD_VAR 0 3
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17853
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17767: LD_ADDR_VAR 0 5
17771: PUSH
17772: LD_VAR 0 5
17776: PUSH
17777: LD_VAR 0 3
17781: PUSH
17782: LD_VAR 0 4
17786: ARRAY
17787: PPUSH
17788: CALL_OW 266
17792: PUSH
17793: LD_VAR 0 3
17797: PUSH
17798: LD_VAR 0 4
17802: ARRAY
17803: PPUSH
17804: CALL_OW 250
17808: PUSH
17809: LD_VAR 0 3
17813: PUSH
17814: LD_VAR 0 4
17818: ARRAY
17819: PPUSH
17820: CALL_OW 251
17824: PUSH
17825: LD_VAR 0 3
17829: PUSH
17830: LD_VAR 0 4
17834: ARRAY
17835: PPUSH
17836: CALL_OW 254
17840: PUSH
17841: EMPTY
17842: LIST
17843: LIST
17844: LIST
17845: LIST
17846: PUSH
17847: EMPTY
17848: LIST
17849: ADD
17850: ST_TO_ADDR
17851: GO 17764
17853: POP
17854: POP
// result := list ;
17855: LD_ADDR_VAR 0 2
17859: PUSH
17860: LD_VAR 0 5
17864: ST_TO_ADDR
// end ;
17865: LD_VAR 0 2
17869: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17870: LD_INT 0
17872: PPUSH
17873: PPUSH
17874: PPUSH
17875: PPUSH
17876: PPUSH
17877: PPUSH
17878: PPUSH
// if not factory then
17879: LD_VAR 0 1
17883: NOT
17884: IFFALSE 17888
// exit ;
17886: GO 18413
// if control = control_apeman then
17888: LD_VAR 0 4
17892: PUSH
17893: LD_INT 5
17895: EQUAL
17896: IFFALSE 18005
// begin tmp := UnitsInside ( factory ) ;
17898: LD_ADDR_VAR 0 8
17902: PUSH
17903: LD_VAR 0 1
17907: PPUSH
17908: CALL_OW 313
17912: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17913: LD_VAR 0 8
17917: PPUSH
17918: LD_INT 25
17920: PUSH
17921: LD_INT 12
17923: PUSH
17924: EMPTY
17925: LIST
17926: LIST
17927: PPUSH
17928: CALL_OW 72
17932: NOT
17933: IFFALSE 17943
// control := control_manual ;
17935: LD_ADDR_VAR 0 4
17939: PUSH
17940: LD_INT 1
17942: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17943: LD_ADDR_VAR 0 8
17947: PUSH
17948: LD_VAR 0 1
17952: PPUSH
17953: CALL 17640 0 1
17957: ST_TO_ADDR
// if tmp then
17958: LD_VAR 0 8
17962: IFFALSE 18005
// begin for i in tmp do
17964: LD_ADDR_VAR 0 7
17968: PUSH
17969: LD_VAR 0 8
17973: PUSH
17974: FOR_IN
17975: IFFALSE 18003
// if i [ 1 ] = b_ext_radar then
17977: LD_VAR 0 7
17981: PUSH
17982: LD_INT 1
17984: ARRAY
17985: PUSH
17986: LD_INT 20
17988: EQUAL
17989: IFFALSE 18001
// begin control := control_remote ;
17991: LD_ADDR_VAR 0 4
17995: PUSH
17996: LD_INT 2
17998: ST_TO_ADDR
// break ;
17999: GO 18003
// end ;
18001: GO 17974
18003: POP
18004: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18005: LD_VAR 0 1
18009: PPUSH
18010: LD_VAR 0 2
18014: PPUSH
18015: LD_VAR 0 3
18019: PPUSH
18020: LD_VAR 0 4
18024: PPUSH
18025: LD_VAR 0 5
18029: PPUSH
18030: CALL_OW 448
18034: IFFALSE 18069
// begin result := [ chassis , engine , control , weapon ] ;
18036: LD_ADDR_VAR 0 6
18040: PUSH
18041: LD_VAR 0 2
18045: PUSH
18046: LD_VAR 0 3
18050: PUSH
18051: LD_VAR 0 4
18055: PUSH
18056: LD_VAR 0 5
18060: PUSH
18061: EMPTY
18062: LIST
18063: LIST
18064: LIST
18065: LIST
18066: ST_TO_ADDR
// exit ;
18067: GO 18413
// end ; _chassis := AvailableChassisList ( factory ) ;
18069: LD_ADDR_VAR 0 9
18073: PUSH
18074: LD_VAR 0 1
18078: PPUSH
18079: CALL_OW 475
18083: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18084: LD_ADDR_VAR 0 11
18088: PUSH
18089: LD_VAR 0 1
18093: PPUSH
18094: CALL_OW 476
18098: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18099: LD_ADDR_VAR 0 12
18103: PUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: CALL_OW 477
18113: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18114: LD_ADDR_VAR 0 10
18118: PUSH
18119: LD_VAR 0 1
18123: PPUSH
18124: CALL_OW 478
18128: ST_TO_ADDR
// if not chassis in _chassis then
18129: LD_VAR 0 2
18133: PUSH
18134: LD_VAR 0 9
18138: IN
18139: NOT
18140: IFFALSE 18166
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18142: LD_ADDR_VAR 0 2
18146: PUSH
18147: LD_VAR 0 9
18151: PUSH
18152: LD_INT 1
18154: PPUSH
18155: LD_VAR 0 9
18159: PPUSH
18160: CALL_OW 12
18164: ARRAY
18165: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18166: LD_VAR 0 2
18170: PPUSH
18171: LD_VAR 0 3
18175: PPUSH
18176: CALL 18418 0 2
18180: NOT
18181: IFFALSE 18240
// repeat engine := _engine [ 1 ] ;
18183: LD_ADDR_VAR 0 3
18187: PUSH
18188: LD_VAR 0 11
18192: PUSH
18193: LD_INT 1
18195: ARRAY
18196: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18197: LD_ADDR_VAR 0 11
18201: PUSH
18202: LD_VAR 0 11
18206: PPUSH
18207: LD_INT 1
18209: PPUSH
18210: CALL_OW 3
18214: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18215: LD_VAR 0 2
18219: PPUSH
18220: LD_VAR 0 3
18224: PPUSH
18225: CALL 18418 0 2
18229: PUSH
18230: LD_VAR 0 11
18234: PUSH
18235: EMPTY
18236: EQUAL
18237: OR
18238: IFFALSE 18183
// if not control in _control then
18240: LD_VAR 0 4
18244: PUSH
18245: LD_VAR 0 12
18249: IN
18250: NOT
18251: IFFALSE 18277
// control := _control [ rand ( 1 , _control ) ] ;
18253: LD_ADDR_VAR 0 4
18257: PUSH
18258: LD_VAR 0 12
18262: PUSH
18263: LD_INT 1
18265: PPUSH
18266: LD_VAR 0 12
18270: PPUSH
18271: CALL_OW 12
18275: ARRAY
18276: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18277: LD_VAR 0 2
18281: PPUSH
18282: LD_VAR 0 5
18286: PPUSH
18287: CALL 18638 0 2
18291: NOT
18292: IFFALSE 18351
// repeat weapon := _weapon [ 1 ] ;
18294: LD_ADDR_VAR 0 5
18298: PUSH
18299: LD_VAR 0 10
18303: PUSH
18304: LD_INT 1
18306: ARRAY
18307: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18308: LD_ADDR_VAR 0 10
18312: PUSH
18313: LD_VAR 0 10
18317: PPUSH
18318: LD_INT 1
18320: PPUSH
18321: CALL_OW 3
18325: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18326: LD_VAR 0 2
18330: PPUSH
18331: LD_VAR 0 5
18335: PPUSH
18336: CALL 18638 0 2
18340: PUSH
18341: LD_VAR 0 10
18345: PUSH
18346: EMPTY
18347: EQUAL
18348: OR
18349: IFFALSE 18294
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18351: LD_VAR 0 1
18355: PPUSH
18356: LD_VAR 0 2
18360: PPUSH
18361: LD_VAR 0 3
18365: PPUSH
18366: LD_VAR 0 4
18370: PPUSH
18371: LD_VAR 0 5
18375: PPUSH
18376: CALL_OW 448
18380: IFFALSE 18413
// result := [ chassis , engine , control , weapon ] ;
18382: LD_ADDR_VAR 0 6
18386: PUSH
18387: LD_VAR 0 2
18391: PUSH
18392: LD_VAR 0 3
18396: PUSH
18397: LD_VAR 0 4
18401: PUSH
18402: LD_VAR 0 5
18406: PUSH
18407: EMPTY
18408: LIST
18409: LIST
18410: LIST
18411: LIST
18412: ST_TO_ADDR
// end ;
18413: LD_VAR 0 6
18417: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18418: LD_INT 0
18420: PPUSH
// if not chassis or not engine then
18421: LD_VAR 0 1
18425: NOT
18426: PUSH
18427: LD_VAR 0 2
18431: NOT
18432: OR
18433: IFFALSE 18437
// exit ;
18435: GO 18633
// case engine of engine_solar :
18437: LD_VAR 0 2
18441: PUSH
18442: LD_INT 2
18444: DOUBLE
18445: EQUAL
18446: IFTRUE 18450
18448: GO 18488
18450: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18451: LD_ADDR_VAR 0 3
18455: PUSH
18456: LD_INT 11
18458: PUSH
18459: LD_INT 12
18461: PUSH
18462: LD_INT 13
18464: PUSH
18465: LD_INT 14
18467: PUSH
18468: LD_INT 1
18470: PUSH
18471: LD_INT 2
18473: PUSH
18474: LD_INT 3
18476: PUSH
18477: EMPTY
18478: LIST
18479: LIST
18480: LIST
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18617
18488: LD_INT 1
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18558
18496: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 11
18504: PUSH
18505: LD_INT 12
18507: PUSH
18508: LD_INT 13
18510: PUSH
18511: LD_INT 14
18513: PUSH
18514: LD_INT 1
18516: PUSH
18517: LD_INT 2
18519: PUSH
18520: LD_INT 3
18522: PUSH
18523: LD_INT 4
18525: PUSH
18526: LD_INT 5
18528: PUSH
18529: LD_INT 21
18531: PUSH
18532: LD_INT 23
18534: PUSH
18535: LD_INT 22
18537: PUSH
18538: LD_INT 24
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: LIST
18548: LIST
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: LIST
18555: ST_TO_ADDR
18556: GO 18617
18558: LD_INT 3
18560: DOUBLE
18561: EQUAL
18562: IFTRUE 18566
18564: GO 18616
18566: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18567: LD_ADDR_VAR 0 3
18571: PUSH
18572: LD_INT 13
18574: PUSH
18575: LD_INT 14
18577: PUSH
18578: LD_INT 2
18580: PUSH
18581: LD_INT 3
18583: PUSH
18584: LD_INT 4
18586: PUSH
18587: LD_INT 5
18589: PUSH
18590: LD_INT 21
18592: PUSH
18593: LD_INT 22
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: LIST
18608: LIST
18609: LIST
18610: LIST
18611: LIST
18612: LIST
18613: ST_TO_ADDR
18614: GO 18617
18616: POP
// result := ( chassis in result ) ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_VAR 0 1
18626: PUSH
18627: LD_VAR 0 3
18631: IN
18632: ST_TO_ADDR
// end ;
18633: LD_VAR 0 3
18637: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18638: LD_INT 0
18640: PPUSH
// if not chassis or not weapon then
18641: LD_VAR 0 1
18645: NOT
18646: PUSH
18647: LD_VAR 0 2
18651: NOT
18652: OR
18653: IFFALSE 18657
// exit ;
18655: GO 19683
// case weapon of us_machine_gun :
18657: LD_VAR 0 2
18661: PUSH
18662: LD_INT 2
18664: DOUBLE
18665: EQUAL
18666: IFTRUE 18670
18668: GO 18700
18670: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18671: LD_ADDR_VAR 0 3
18675: PUSH
18676: LD_INT 1
18678: PUSH
18679: LD_INT 2
18681: PUSH
18682: LD_INT 3
18684: PUSH
18685: LD_INT 4
18687: PUSH
18688: LD_INT 5
18690: PUSH
18691: EMPTY
18692: LIST
18693: LIST
18694: LIST
18695: LIST
18696: LIST
18697: ST_TO_ADDR
18698: GO 19667
18700: LD_INT 3
18702: DOUBLE
18703: EQUAL
18704: IFTRUE 18708
18706: GO 18738
18708: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18709: LD_ADDR_VAR 0 3
18713: PUSH
18714: LD_INT 1
18716: PUSH
18717: LD_INT 2
18719: PUSH
18720: LD_INT 3
18722: PUSH
18723: LD_INT 4
18725: PUSH
18726: LD_INT 5
18728: PUSH
18729: EMPTY
18730: LIST
18731: LIST
18732: LIST
18733: LIST
18734: LIST
18735: ST_TO_ADDR
18736: GO 19667
18738: LD_INT 11
18740: DOUBLE
18741: EQUAL
18742: IFTRUE 18746
18744: GO 18776
18746: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18747: LD_ADDR_VAR 0 3
18751: PUSH
18752: LD_INT 1
18754: PUSH
18755: LD_INT 2
18757: PUSH
18758: LD_INT 3
18760: PUSH
18761: LD_INT 4
18763: PUSH
18764: LD_INT 5
18766: PUSH
18767: EMPTY
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: LIST
18773: ST_TO_ADDR
18774: GO 19667
18776: LD_INT 4
18778: DOUBLE
18779: EQUAL
18780: IFTRUE 18784
18782: GO 18810
18784: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18785: LD_ADDR_VAR 0 3
18789: PUSH
18790: LD_INT 2
18792: PUSH
18793: LD_INT 3
18795: PUSH
18796: LD_INT 4
18798: PUSH
18799: LD_INT 5
18801: PUSH
18802: EMPTY
18803: LIST
18804: LIST
18805: LIST
18806: LIST
18807: ST_TO_ADDR
18808: GO 19667
18810: LD_INT 5
18812: DOUBLE
18813: EQUAL
18814: IFTRUE 18818
18816: GO 18844
18818: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18819: LD_ADDR_VAR 0 3
18823: PUSH
18824: LD_INT 2
18826: PUSH
18827: LD_INT 3
18829: PUSH
18830: LD_INT 4
18832: PUSH
18833: LD_INT 5
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: LIST
18840: LIST
18841: ST_TO_ADDR
18842: GO 19667
18844: LD_INT 9
18846: DOUBLE
18847: EQUAL
18848: IFTRUE 18852
18850: GO 18878
18852: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18853: LD_ADDR_VAR 0 3
18857: PUSH
18858: LD_INT 2
18860: PUSH
18861: LD_INT 3
18863: PUSH
18864: LD_INT 4
18866: PUSH
18867: LD_INT 5
18869: PUSH
18870: EMPTY
18871: LIST
18872: LIST
18873: LIST
18874: LIST
18875: ST_TO_ADDR
18876: GO 19667
18878: LD_INT 7
18880: DOUBLE
18881: EQUAL
18882: IFTRUE 18886
18884: GO 18912
18886: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18887: LD_ADDR_VAR 0 3
18891: PUSH
18892: LD_INT 2
18894: PUSH
18895: LD_INT 3
18897: PUSH
18898: LD_INT 4
18900: PUSH
18901: LD_INT 5
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: LIST
18908: LIST
18909: ST_TO_ADDR
18910: GO 19667
18912: LD_INT 12
18914: DOUBLE
18915: EQUAL
18916: IFTRUE 18920
18918: GO 18946
18920: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18921: LD_ADDR_VAR 0 3
18925: PUSH
18926: LD_INT 2
18928: PUSH
18929: LD_INT 3
18931: PUSH
18932: LD_INT 4
18934: PUSH
18935: LD_INT 5
18937: PUSH
18938: EMPTY
18939: LIST
18940: LIST
18941: LIST
18942: LIST
18943: ST_TO_ADDR
18944: GO 19667
18946: LD_INT 13
18948: DOUBLE
18949: EQUAL
18950: IFTRUE 18954
18952: GO 18980
18954: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18955: LD_ADDR_VAR 0 3
18959: PUSH
18960: LD_INT 2
18962: PUSH
18963: LD_INT 3
18965: PUSH
18966: LD_INT 4
18968: PUSH
18969: LD_INT 5
18971: PUSH
18972: EMPTY
18973: LIST
18974: LIST
18975: LIST
18976: LIST
18977: ST_TO_ADDR
18978: GO 19667
18980: LD_INT 14
18982: DOUBLE
18983: EQUAL
18984: IFTRUE 18988
18986: GO 19006
18988: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18989: LD_ADDR_VAR 0 3
18993: PUSH
18994: LD_INT 4
18996: PUSH
18997: LD_INT 5
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: ST_TO_ADDR
19004: GO 19667
19006: LD_INT 6
19008: DOUBLE
19009: EQUAL
19010: IFTRUE 19014
19012: GO 19032
19014: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19015: LD_ADDR_VAR 0 3
19019: PUSH
19020: LD_INT 4
19022: PUSH
19023: LD_INT 5
19025: PUSH
19026: EMPTY
19027: LIST
19028: LIST
19029: ST_TO_ADDR
19030: GO 19667
19032: LD_INT 10
19034: DOUBLE
19035: EQUAL
19036: IFTRUE 19040
19038: GO 19058
19040: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19041: LD_ADDR_VAR 0 3
19045: PUSH
19046: LD_INT 4
19048: PUSH
19049: LD_INT 5
19051: PUSH
19052: EMPTY
19053: LIST
19054: LIST
19055: ST_TO_ADDR
19056: GO 19667
19058: LD_INT 22
19060: DOUBLE
19061: EQUAL
19062: IFTRUE 19066
19064: GO 19092
19066: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19067: LD_ADDR_VAR 0 3
19071: PUSH
19072: LD_INT 11
19074: PUSH
19075: LD_INT 12
19077: PUSH
19078: LD_INT 13
19080: PUSH
19081: LD_INT 14
19083: PUSH
19084: EMPTY
19085: LIST
19086: LIST
19087: LIST
19088: LIST
19089: ST_TO_ADDR
19090: GO 19667
19092: LD_INT 23
19094: DOUBLE
19095: EQUAL
19096: IFTRUE 19100
19098: GO 19126
19100: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19101: LD_ADDR_VAR 0 3
19105: PUSH
19106: LD_INT 11
19108: PUSH
19109: LD_INT 12
19111: PUSH
19112: LD_INT 13
19114: PUSH
19115: LD_INT 14
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: ST_TO_ADDR
19124: GO 19667
19126: LD_INT 24
19128: DOUBLE
19129: EQUAL
19130: IFTRUE 19134
19132: GO 19160
19134: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19135: LD_ADDR_VAR 0 3
19139: PUSH
19140: LD_INT 11
19142: PUSH
19143: LD_INT 12
19145: PUSH
19146: LD_INT 13
19148: PUSH
19149: LD_INT 14
19151: PUSH
19152: EMPTY
19153: LIST
19154: LIST
19155: LIST
19156: LIST
19157: ST_TO_ADDR
19158: GO 19667
19160: LD_INT 30
19162: DOUBLE
19163: EQUAL
19164: IFTRUE 19168
19166: GO 19194
19168: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19169: LD_ADDR_VAR 0 3
19173: PUSH
19174: LD_INT 11
19176: PUSH
19177: LD_INT 12
19179: PUSH
19180: LD_INT 13
19182: PUSH
19183: LD_INT 14
19185: PUSH
19186: EMPTY
19187: LIST
19188: LIST
19189: LIST
19190: LIST
19191: ST_TO_ADDR
19192: GO 19667
19194: LD_INT 25
19196: DOUBLE
19197: EQUAL
19198: IFTRUE 19202
19200: GO 19220
19202: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19203: LD_ADDR_VAR 0 3
19207: PUSH
19208: LD_INT 13
19210: PUSH
19211: LD_INT 14
19213: PUSH
19214: EMPTY
19215: LIST
19216: LIST
19217: ST_TO_ADDR
19218: GO 19667
19220: LD_INT 27
19222: DOUBLE
19223: EQUAL
19224: IFTRUE 19228
19226: GO 19246
19228: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19229: LD_ADDR_VAR 0 3
19233: PUSH
19234: LD_INT 13
19236: PUSH
19237: LD_INT 14
19239: PUSH
19240: EMPTY
19241: LIST
19242: LIST
19243: ST_TO_ADDR
19244: GO 19667
19246: LD_INT 28
19248: DOUBLE
19249: EQUAL
19250: IFTRUE 19254
19252: GO 19272
19254: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19255: LD_ADDR_VAR 0 3
19259: PUSH
19260: LD_INT 13
19262: PUSH
19263: LD_INT 14
19265: PUSH
19266: EMPTY
19267: LIST
19268: LIST
19269: ST_TO_ADDR
19270: GO 19667
19272: LD_INT 29
19274: DOUBLE
19275: EQUAL
19276: IFTRUE 19280
19278: GO 19298
19280: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19281: LD_ADDR_VAR 0 3
19285: PUSH
19286: LD_INT 13
19288: PUSH
19289: LD_INT 14
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: ST_TO_ADDR
19296: GO 19667
19298: LD_INT 31
19300: DOUBLE
19301: EQUAL
19302: IFTRUE 19306
19304: GO 19324
19306: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19307: LD_ADDR_VAR 0 3
19311: PUSH
19312: LD_INT 13
19314: PUSH
19315: LD_INT 14
19317: PUSH
19318: EMPTY
19319: LIST
19320: LIST
19321: ST_TO_ADDR
19322: GO 19667
19324: LD_INT 26
19326: DOUBLE
19327: EQUAL
19328: IFTRUE 19332
19330: GO 19350
19332: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19333: LD_ADDR_VAR 0 3
19337: PUSH
19338: LD_INT 13
19340: PUSH
19341: LD_INT 14
19343: PUSH
19344: EMPTY
19345: LIST
19346: LIST
19347: ST_TO_ADDR
19348: GO 19667
19350: LD_INT 42
19352: DOUBLE
19353: EQUAL
19354: IFTRUE 19358
19356: GO 19384
19358: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19359: LD_ADDR_VAR 0 3
19363: PUSH
19364: LD_INT 21
19366: PUSH
19367: LD_INT 22
19369: PUSH
19370: LD_INT 23
19372: PUSH
19373: LD_INT 24
19375: PUSH
19376: EMPTY
19377: LIST
19378: LIST
19379: LIST
19380: LIST
19381: ST_TO_ADDR
19382: GO 19667
19384: LD_INT 43
19386: DOUBLE
19387: EQUAL
19388: IFTRUE 19392
19390: GO 19418
19392: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19393: LD_ADDR_VAR 0 3
19397: PUSH
19398: LD_INT 21
19400: PUSH
19401: LD_INT 22
19403: PUSH
19404: LD_INT 23
19406: PUSH
19407: LD_INT 24
19409: PUSH
19410: EMPTY
19411: LIST
19412: LIST
19413: LIST
19414: LIST
19415: ST_TO_ADDR
19416: GO 19667
19418: LD_INT 44
19420: DOUBLE
19421: EQUAL
19422: IFTRUE 19426
19424: GO 19452
19426: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19427: LD_ADDR_VAR 0 3
19431: PUSH
19432: LD_INT 21
19434: PUSH
19435: LD_INT 22
19437: PUSH
19438: LD_INT 23
19440: PUSH
19441: LD_INT 24
19443: PUSH
19444: EMPTY
19445: LIST
19446: LIST
19447: LIST
19448: LIST
19449: ST_TO_ADDR
19450: GO 19667
19452: LD_INT 45
19454: DOUBLE
19455: EQUAL
19456: IFTRUE 19460
19458: GO 19486
19460: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19461: LD_ADDR_VAR 0 3
19465: PUSH
19466: LD_INT 21
19468: PUSH
19469: LD_INT 22
19471: PUSH
19472: LD_INT 23
19474: PUSH
19475: LD_INT 24
19477: PUSH
19478: EMPTY
19479: LIST
19480: LIST
19481: LIST
19482: LIST
19483: ST_TO_ADDR
19484: GO 19667
19486: LD_INT 49
19488: DOUBLE
19489: EQUAL
19490: IFTRUE 19494
19492: GO 19520
19494: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19495: LD_ADDR_VAR 0 3
19499: PUSH
19500: LD_INT 21
19502: PUSH
19503: LD_INT 22
19505: PUSH
19506: LD_INT 23
19508: PUSH
19509: LD_INT 24
19511: PUSH
19512: EMPTY
19513: LIST
19514: LIST
19515: LIST
19516: LIST
19517: ST_TO_ADDR
19518: GO 19667
19520: LD_INT 51
19522: DOUBLE
19523: EQUAL
19524: IFTRUE 19528
19526: GO 19554
19528: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19529: LD_ADDR_VAR 0 3
19533: PUSH
19534: LD_INT 21
19536: PUSH
19537: LD_INT 22
19539: PUSH
19540: LD_INT 23
19542: PUSH
19543: LD_INT 24
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: LIST
19550: LIST
19551: ST_TO_ADDR
19552: GO 19667
19554: LD_INT 52
19556: DOUBLE
19557: EQUAL
19558: IFTRUE 19562
19560: GO 19588
19562: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19563: LD_ADDR_VAR 0 3
19567: PUSH
19568: LD_INT 21
19570: PUSH
19571: LD_INT 22
19573: PUSH
19574: LD_INT 23
19576: PUSH
19577: LD_INT 24
19579: PUSH
19580: EMPTY
19581: LIST
19582: LIST
19583: LIST
19584: LIST
19585: ST_TO_ADDR
19586: GO 19667
19588: LD_INT 53
19590: DOUBLE
19591: EQUAL
19592: IFTRUE 19596
19594: GO 19614
19596: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19597: LD_ADDR_VAR 0 3
19601: PUSH
19602: LD_INT 23
19604: PUSH
19605: LD_INT 24
19607: PUSH
19608: EMPTY
19609: LIST
19610: LIST
19611: ST_TO_ADDR
19612: GO 19667
19614: LD_INT 46
19616: DOUBLE
19617: EQUAL
19618: IFTRUE 19622
19620: GO 19640
19622: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19623: LD_ADDR_VAR 0 3
19627: PUSH
19628: LD_INT 23
19630: PUSH
19631: LD_INT 24
19633: PUSH
19634: EMPTY
19635: LIST
19636: LIST
19637: ST_TO_ADDR
19638: GO 19667
19640: LD_INT 47
19642: DOUBLE
19643: EQUAL
19644: IFTRUE 19648
19646: GO 19666
19648: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19649: LD_ADDR_VAR 0 3
19653: PUSH
19654: LD_INT 23
19656: PUSH
19657: LD_INT 24
19659: PUSH
19660: EMPTY
19661: LIST
19662: LIST
19663: ST_TO_ADDR
19664: GO 19667
19666: POP
// result := ( chassis in result ) ;
19667: LD_ADDR_VAR 0 3
19671: PUSH
19672: LD_VAR 0 1
19676: PUSH
19677: LD_VAR 0 3
19681: IN
19682: ST_TO_ADDR
// end ;
19683: LD_VAR 0 3
19687: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19688: LD_INT 0
19690: PPUSH
19691: PPUSH
19692: PPUSH
19693: PPUSH
19694: PPUSH
19695: PPUSH
19696: PPUSH
// result := array ;
19697: LD_ADDR_VAR 0 5
19701: PUSH
19702: LD_VAR 0 1
19706: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19707: LD_VAR 0 1
19711: NOT
19712: PUSH
19713: LD_VAR 0 2
19717: NOT
19718: OR
19719: PUSH
19720: LD_VAR 0 3
19724: NOT
19725: OR
19726: PUSH
19727: LD_VAR 0 2
19731: PUSH
19732: LD_VAR 0 1
19736: GREATER
19737: OR
19738: PUSH
19739: LD_VAR 0 3
19743: PUSH
19744: LD_VAR 0 1
19748: GREATER
19749: OR
19750: IFFALSE 19754
// exit ;
19752: GO 20050
// if direction then
19754: LD_VAR 0 4
19758: IFFALSE 19822
// begin d := 1 ;
19760: LD_ADDR_VAR 0 9
19764: PUSH
19765: LD_INT 1
19767: ST_TO_ADDR
// if i_from > i_to then
19768: LD_VAR 0 2
19772: PUSH
19773: LD_VAR 0 3
19777: GREATER
19778: IFFALSE 19804
// length := ( array - i_from ) + i_to else
19780: LD_ADDR_VAR 0 11
19784: PUSH
19785: LD_VAR 0 1
19789: PUSH
19790: LD_VAR 0 2
19794: MINUS
19795: PUSH
19796: LD_VAR 0 3
19800: PLUS
19801: ST_TO_ADDR
19802: GO 19820
// length := i_to - i_from ;
19804: LD_ADDR_VAR 0 11
19808: PUSH
19809: LD_VAR 0 3
19813: PUSH
19814: LD_VAR 0 2
19818: MINUS
19819: ST_TO_ADDR
// end else
19820: GO 19883
// begin d := - 1 ;
19822: LD_ADDR_VAR 0 9
19826: PUSH
19827: LD_INT 1
19829: NEG
19830: ST_TO_ADDR
// if i_from > i_to then
19831: LD_VAR 0 2
19835: PUSH
19836: LD_VAR 0 3
19840: GREATER
19841: IFFALSE 19861
// length := i_from - i_to else
19843: LD_ADDR_VAR 0 11
19847: PUSH
19848: LD_VAR 0 2
19852: PUSH
19853: LD_VAR 0 3
19857: MINUS
19858: ST_TO_ADDR
19859: GO 19883
// length := ( array - i_to ) + i_from ;
19861: LD_ADDR_VAR 0 11
19865: PUSH
19866: LD_VAR 0 1
19870: PUSH
19871: LD_VAR 0 3
19875: MINUS
19876: PUSH
19877: LD_VAR 0 2
19881: PLUS
19882: ST_TO_ADDR
// end ; if not length then
19883: LD_VAR 0 11
19887: NOT
19888: IFFALSE 19892
// exit ;
19890: GO 20050
// tmp := array ;
19892: LD_ADDR_VAR 0 10
19896: PUSH
19897: LD_VAR 0 1
19901: ST_TO_ADDR
// for i = 1 to length do
19902: LD_ADDR_VAR 0 6
19906: PUSH
19907: DOUBLE
19908: LD_INT 1
19910: DEC
19911: ST_TO_ADDR
19912: LD_VAR 0 11
19916: PUSH
19917: FOR_TO
19918: IFFALSE 20038
// begin for j = 1 to array do
19920: LD_ADDR_VAR 0 7
19924: PUSH
19925: DOUBLE
19926: LD_INT 1
19928: DEC
19929: ST_TO_ADDR
19930: LD_VAR 0 1
19934: PUSH
19935: FOR_TO
19936: IFFALSE 20024
// begin k := j + d ;
19938: LD_ADDR_VAR 0 8
19942: PUSH
19943: LD_VAR 0 7
19947: PUSH
19948: LD_VAR 0 9
19952: PLUS
19953: ST_TO_ADDR
// if k > array then
19954: LD_VAR 0 8
19958: PUSH
19959: LD_VAR 0 1
19963: GREATER
19964: IFFALSE 19974
// k := 1 ;
19966: LD_ADDR_VAR 0 8
19970: PUSH
19971: LD_INT 1
19973: ST_TO_ADDR
// if not k then
19974: LD_VAR 0 8
19978: NOT
19979: IFFALSE 19991
// k := array ;
19981: LD_ADDR_VAR 0 8
19985: PUSH
19986: LD_VAR 0 1
19990: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19991: LD_ADDR_VAR 0 10
19995: PUSH
19996: LD_VAR 0 10
20000: PPUSH
20001: LD_VAR 0 8
20005: PPUSH
20006: LD_VAR 0 1
20010: PUSH
20011: LD_VAR 0 7
20015: ARRAY
20016: PPUSH
20017: CALL_OW 1
20021: ST_TO_ADDR
// end ;
20022: GO 19935
20024: POP
20025: POP
// array := tmp ;
20026: LD_ADDR_VAR 0 1
20030: PUSH
20031: LD_VAR 0 10
20035: ST_TO_ADDR
// end ;
20036: GO 19917
20038: POP
20039: POP
// result := array ;
20040: LD_ADDR_VAR 0 5
20044: PUSH
20045: LD_VAR 0 1
20049: ST_TO_ADDR
// end ;
20050: LD_VAR 0 5
20054: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20055: LD_INT 0
20057: PPUSH
20058: PPUSH
// result := 0 ;
20059: LD_ADDR_VAR 0 3
20063: PUSH
20064: LD_INT 0
20066: ST_TO_ADDR
// if not array or not value in array then
20067: LD_VAR 0 1
20071: NOT
20072: PUSH
20073: LD_VAR 0 2
20077: PUSH
20078: LD_VAR 0 1
20082: IN
20083: NOT
20084: OR
20085: IFFALSE 20089
// exit ;
20087: GO 20143
// for i = 1 to array do
20089: LD_ADDR_VAR 0 4
20093: PUSH
20094: DOUBLE
20095: LD_INT 1
20097: DEC
20098: ST_TO_ADDR
20099: LD_VAR 0 1
20103: PUSH
20104: FOR_TO
20105: IFFALSE 20141
// if value = array [ i ] then
20107: LD_VAR 0 2
20111: PUSH
20112: LD_VAR 0 1
20116: PUSH
20117: LD_VAR 0 4
20121: ARRAY
20122: EQUAL
20123: IFFALSE 20139
// begin result := i ;
20125: LD_ADDR_VAR 0 3
20129: PUSH
20130: LD_VAR 0 4
20134: ST_TO_ADDR
// exit ;
20135: POP
20136: POP
20137: GO 20143
// end ;
20139: GO 20104
20141: POP
20142: POP
// end ;
20143: LD_VAR 0 3
20147: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20148: LD_INT 0
20150: PPUSH
// vc_chassis := chassis ;
20151: LD_ADDR_OWVAR 37
20155: PUSH
20156: LD_VAR 0 1
20160: ST_TO_ADDR
// vc_engine := engine ;
20161: LD_ADDR_OWVAR 39
20165: PUSH
20166: LD_VAR 0 2
20170: ST_TO_ADDR
// vc_control := control ;
20171: LD_ADDR_OWVAR 38
20175: PUSH
20176: LD_VAR 0 3
20180: ST_TO_ADDR
// vc_weapon := weapon ;
20181: LD_ADDR_OWVAR 40
20185: PUSH
20186: LD_VAR 0 4
20190: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20191: LD_ADDR_OWVAR 41
20195: PUSH
20196: LD_VAR 0 5
20200: ST_TO_ADDR
// end ;
20201: LD_VAR 0 6
20205: RET
// export function WantPlant ( unit ) ; var task ; begin
20206: LD_INT 0
20208: PPUSH
20209: PPUSH
// result := false ;
20210: LD_ADDR_VAR 0 2
20214: PUSH
20215: LD_INT 0
20217: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20218: LD_ADDR_VAR 0 3
20222: PUSH
20223: LD_VAR 0 1
20227: PPUSH
20228: CALL_OW 437
20232: ST_TO_ADDR
// if task then
20233: LD_VAR 0 3
20237: IFFALSE 20265
// if task [ 1 ] [ 1 ] = p then
20239: LD_VAR 0 3
20243: PUSH
20244: LD_INT 1
20246: ARRAY
20247: PUSH
20248: LD_INT 1
20250: ARRAY
20251: PUSH
20252: LD_STRING p
20254: EQUAL
20255: IFFALSE 20265
// result := true ;
20257: LD_ADDR_VAR 0 2
20261: PUSH
20262: LD_INT 1
20264: ST_TO_ADDR
// end ;
20265: LD_VAR 0 2
20269: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20270: LD_INT 0
20272: PPUSH
20273: PPUSH
20274: PPUSH
20275: PPUSH
// if pos < 1 then
20276: LD_VAR 0 2
20280: PUSH
20281: LD_INT 1
20283: LESS
20284: IFFALSE 20288
// exit ;
20286: GO 20591
// if pos = 1 then
20288: LD_VAR 0 2
20292: PUSH
20293: LD_INT 1
20295: EQUAL
20296: IFFALSE 20329
// result := Replace ( arr , pos [ 1 ] , value ) else
20298: LD_ADDR_VAR 0 4
20302: PUSH
20303: LD_VAR 0 1
20307: PPUSH
20308: LD_VAR 0 2
20312: PUSH
20313: LD_INT 1
20315: ARRAY
20316: PPUSH
20317: LD_VAR 0 3
20321: PPUSH
20322: CALL_OW 1
20326: ST_TO_ADDR
20327: GO 20591
// begin tmp := arr ;
20329: LD_ADDR_VAR 0 6
20333: PUSH
20334: LD_VAR 0 1
20338: ST_TO_ADDR
// s_arr := [ tmp ] ;
20339: LD_ADDR_VAR 0 7
20343: PUSH
20344: LD_VAR 0 6
20348: PUSH
20349: EMPTY
20350: LIST
20351: ST_TO_ADDR
// for i = 1 to pos - 1 do
20352: LD_ADDR_VAR 0 5
20356: PUSH
20357: DOUBLE
20358: LD_INT 1
20360: DEC
20361: ST_TO_ADDR
20362: LD_VAR 0 2
20366: PUSH
20367: LD_INT 1
20369: MINUS
20370: PUSH
20371: FOR_TO
20372: IFFALSE 20417
// begin tmp := tmp [ pos [ i ] ] ;
20374: LD_ADDR_VAR 0 6
20378: PUSH
20379: LD_VAR 0 6
20383: PUSH
20384: LD_VAR 0 2
20388: PUSH
20389: LD_VAR 0 5
20393: ARRAY
20394: ARRAY
20395: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20396: LD_ADDR_VAR 0 7
20400: PUSH
20401: LD_VAR 0 7
20405: PUSH
20406: LD_VAR 0 6
20410: PUSH
20411: EMPTY
20412: LIST
20413: ADD
20414: ST_TO_ADDR
// end ;
20415: GO 20371
20417: POP
20418: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20419: LD_ADDR_VAR 0 6
20423: PUSH
20424: LD_VAR 0 6
20428: PPUSH
20429: LD_VAR 0 2
20433: PUSH
20434: LD_VAR 0 2
20438: ARRAY
20439: PPUSH
20440: LD_VAR 0 3
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20450: LD_ADDR_VAR 0 7
20454: PUSH
20455: LD_VAR 0 7
20459: PPUSH
20460: LD_VAR 0 7
20464: PPUSH
20465: LD_VAR 0 6
20469: PPUSH
20470: CALL_OW 1
20474: ST_TO_ADDR
// for i = s_arr downto 2 do
20475: LD_ADDR_VAR 0 5
20479: PUSH
20480: DOUBLE
20481: LD_VAR 0 7
20485: INC
20486: ST_TO_ADDR
20487: LD_INT 2
20489: PUSH
20490: FOR_DOWNTO
20491: IFFALSE 20575
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20493: LD_ADDR_VAR 0 6
20497: PUSH
20498: LD_VAR 0 7
20502: PUSH
20503: LD_VAR 0 5
20507: PUSH
20508: LD_INT 1
20510: MINUS
20511: ARRAY
20512: PPUSH
20513: LD_VAR 0 2
20517: PUSH
20518: LD_VAR 0 5
20522: PUSH
20523: LD_INT 1
20525: MINUS
20526: ARRAY
20527: PPUSH
20528: LD_VAR 0 7
20532: PUSH
20533: LD_VAR 0 5
20537: ARRAY
20538: PPUSH
20539: CALL_OW 1
20543: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20544: LD_ADDR_VAR 0 7
20548: PUSH
20549: LD_VAR 0 7
20553: PPUSH
20554: LD_VAR 0 5
20558: PUSH
20559: LD_INT 1
20561: MINUS
20562: PPUSH
20563: LD_VAR 0 6
20567: PPUSH
20568: CALL_OW 1
20572: ST_TO_ADDR
// end ;
20573: GO 20490
20575: POP
20576: POP
// result := s_arr [ 1 ] ;
20577: LD_ADDR_VAR 0 4
20581: PUSH
20582: LD_VAR 0 7
20586: PUSH
20587: LD_INT 1
20589: ARRAY
20590: ST_TO_ADDR
// end ; end ;
20591: LD_VAR 0 4
20595: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20596: LD_INT 0
20598: PPUSH
20599: PPUSH
// if not list then
20600: LD_VAR 0 1
20604: NOT
20605: IFFALSE 20609
// exit ;
20607: GO 20700
// i := list [ pos1 ] ;
20609: LD_ADDR_VAR 0 5
20613: PUSH
20614: LD_VAR 0 1
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: ST_TO_ADDR
// if not i then
20625: LD_VAR 0 5
20629: NOT
20630: IFFALSE 20634
// exit ;
20632: GO 20700
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20634: LD_ADDR_VAR 0 1
20638: PUSH
20639: LD_VAR 0 1
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: LD_VAR 0 1
20653: PUSH
20654: LD_VAR 0 3
20658: ARRAY
20659: PPUSH
20660: CALL_OW 1
20664: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20665: LD_ADDR_VAR 0 1
20669: PUSH
20670: LD_VAR 0 1
20674: PPUSH
20675: LD_VAR 0 3
20679: PPUSH
20680: LD_VAR 0 5
20684: PPUSH
20685: CALL_OW 1
20689: ST_TO_ADDR
// result := list ;
20690: LD_ADDR_VAR 0 4
20694: PUSH
20695: LD_VAR 0 1
20699: ST_TO_ADDR
// end ;
20700: LD_VAR 0 4
20704: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20705: LD_INT 0
20707: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20708: LD_ADDR_VAR 0 5
20712: PUSH
20713: LD_VAR 0 1
20717: PPUSH
20718: CALL_OW 250
20722: PPUSH
20723: LD_VAR 0 1
20727: PPUSH
20728: CALL_OW 251
20732: PPUSH
20733: LD_VAR 0 2
20737: PPUSH
20738: LD_VAR 0 3
20742: PPUSH
20743: LD_VAR 0 4
20747: PPUSH
20748: CALL 20758 0 5
20752: ST_TO_ADDR
// end ;
20753: LD_VAR 0 5
20757: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20758: LD_INT 0
20760: PPUSH
20761: PPUSH
20762: PPUSH
20763: PPUSH
// if not list then
20764: LD_VAR 0 3
20768: NOT
20769: IFFALSE 20773
// exit ;
20771: GO 21161
// result := [ ] ;
20773: LD_ADDR_VAR 0 6
20777: PUSH
20778: EMPTY
20779: ST_TO_ADDR
// for i in list do
20780: LD_ADDR_VAR 0 7
20784: PUSH
20785: LD_VAR 0 3
20789: PUSH
20790: FOR_IN
20791: IFFALSE 20993
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20793: LD_ADDR_VAR 0 9
20797: PUSH
20798: LD_VAR 0 7
20802: PPUSH
20803: LD_VAR 0 1
20807: PPUSH
20808: LD_VAR 0 2
20812: PPUSH
20813: CALL_OW 297
20817: ST_TO_ADDR
// if not result then
20818: LD_VAR 0 6
20822: NOT
20823: IFFALSE 20849
// result := [ [ i , tmp ] ] else
20825: LD_ADDR_VAR 0 6
20829: PUSH
20830: LD_VAR 0 7
20834: PUSH
20835: LD_VAR 0 9
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: PUSH
20844: EMPTY
20845: LIST
20846: ST_TO_ADDR
20847: GO 20991
// begin if result [ result ] [ 2 ] < tmp then
20849: LD_VAR 0 6
20853: PUSH
20854: LD_VAR 0 6
20858: ARRAY
20859: PUSH
20860: LD_INT 2
20862: ARRAY
20863: PUSH
20864: LD_VAR 0 9
20868: LESS
20869: IFFALSE 20911
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20871: LD_ADDR_VAR 0 6
20875: PUSH
20876: LD_VAR 0 6
20880: PPUSH
20881: LD_VAR 0 6
20885: PUSH
20886: LD_INT 1
20888: PLUS
20889: PPUSH
20890: LD_VAR 0 7
20894: PUSH
20895: LD_VAR 0 9
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PPUSH
20904: CALL_OW 2
20908: ST_TO_ADDR
20909: GO 20991
// for j = 1 to result do
20911: LD_ADDR_VAR 0 8
20915: PUSH
20916: DOUBLE
20917: LD_INT 1
20919: DEC
20920: ST_TO_ADDR
20921: LD_VAR 0 6
20925: PUSH
20926: FOR_TO
20927: IFFALSE 20989
// begin if tmp < result [ j ] [ 2 ] then
20929: LD_VAR 0 9
20933: PUSH
20934: LD_VAR 0 6
20938: PUSH
20939: LD_VAR 0 8
20943: ARRAY
20944: PUSH
20945: LD_INT 2
20947: ARRAY
20948: LESS
20949: IFFALSE 20987
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20951: LD_ADDR_VAR 0 6
20955: PUSH
20956: LD_VAR 0 6
20960: PPUSH
20961: LD_VAR 0 8
20965: PPUSH
20966: LD_VAR 0 7
20970: PUSH
20971: LD_VAR 0 9
20975: PUSH
20976: EMPTY
20977: LIST
20978: LIST
20979: PPUSH
20980: CALL_OW 2
20984: ST_TO_ADDR
// break ;
20985: GO 20989
// end ; end ;
20987: GO 20926
20989: POP
20990: POP
// end ; end ;
20991: GO 20790
20993: POP
20994: POP
// if result and not asc then
20995: LD_VAR 0 6
20999: PUSH
21000: LD_VAR 0 4
21004: NOT
21005: AND
21006: IFFALSE 21081
// begin tmp := result ;
21008: LD_ADDR_VAR 0 9
21012: PUSH
21013: LD_VAR 0 6
21017: ST_TO_ADDR
// for i = tmp downto 1 do
21018: LD_ADDR_VAR 0 7
21022: PUSH
21023: DOUBLE
21024: LD_VAR 0 9
21028: INC
21029: ST_TO_ADDR
21030: LD_INT 1
21032: PUSH
21033: FOR_DOWNTO
21034: IFFALSE 21079
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21036: LD_ADDR_VAR 0 6
21040: PUSH
21041: LD_VAR 0 6
21045: PPUSH
21046: LD_VAR 0 9
21050: PUSH
21051: LD_VAR 0 7
21055: MINUS
21056: PUSH
21057: LD_INT 1
21059: PLUS
21060: PPUSH
21061: LD_VAR 0 9
21065: PUSH
21066: LD_VAR 0 7
21070: ARRAY
21071: PPUSH
21072: CALL_OW 1
21076: ST_TO_ADDR
21077: GO 21033
21079: POP
21080: POP
// end ; tmp := [ ] ;
21081: LD_ADDR_VAR 0 9
21085: PUSH
21086: EMPTY
21087: ST_TO_ADDR
// if mode then
21088: LD_VAR 0 5
21092: IFFALSE 21161
// begin for i = 1 to result do
21094: LD_ADDR_VAR 0 7
21098: PUSH
21099: DOUBLE
21100: LD_INT 1
21102: DEC
21103: ST_TO_ADDR
21104: LD_VAR 0 6
21108: PUSH
21109: FOR_TO
21110: IFFALSE 21149
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21112: LD_ADDR_VAR 0 9
21116: PUSH
21117: LD_VAR 0 9
21121: PPUSH
21122: LD_VAR 0 7
21126: PPUSH
21127: LD_VAR 0 6
21131: PUSH
21132: LD_VAR 0 7
21136: ARRAY
21137: PUSH
21138: LD_INT 1
21140: ARRAY
21141: PPUSH
21142: CALL_OW 1
21146: ST_TO_ADDR
21147: GO 21109
21149: POP
21150: POP
// result := tmp ;
21151: LD_ADDR_VAR 0 6
21155: PUSH
21156: LD_VAR 0 9
21160: ST_TO_ADDR
// end ; end ;
21161: LD_VAR 0 6
21165: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21166: LD_INT 0
21168: PPUSH
21169: PPUSH
21170: PPUSH
21171: PPUSH
21172: PPUSH
21173: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21174: LD_ADDR_VAR 0 5
21178: PUSH
21179: LD_INT 0
21181: PUSH
21182: LD_INT 0
21184: PUSH
21185: LD_INT 0
21187: PUSH
21188: EMPTY
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: ST_TO_ADDR
// if not x or not y then
21196: LD_VAR 0 2
21200: NOT
21201: PUSH
21202: LD_VAR 0 3
21206: NOT
21207: OR
21208: IFFALSE 21212
// exit ;
21210: GO 22858
// if not range then
21212: LD_VAR 0 4
21216: NOT
21217: IFFALSE 21227
// range := 10 ;
21219: LD_ADDR_VAR 0 4
21223: PUSH
21224: LD_INT 10
21226: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21227: LD_ADDR_VAR 0 8
21231: PUSH
21232: LD_INT 81
21234: PUSH
21235: LD_VAR 0 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: LD_INT 92
21246: PUSH
21247: LD_VAR 0 2
21251: PUSH
21252: LD_VAR 0 3
21256: PUSH
21257: LD_VAR 0 4
21261: PUSH
21262: EMPTY
21263: LIST
21264: LIST
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 3
21270: PUSH
21271: LD_INT 21
21273: PUSH
21274: LD_INT 3
21276: PUSH
21277: EMPTY
21278: LIST
21279: LIST
21280: PUSH
21281: EMPTY
21282: LIST
21283: LIST
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: PPUSH
21290: CALL_OW 69
21294: ST_TO_ADDR
// if not tmp then
21295: LD_VAR 0 8
21299: NOT
21300: IFFALSE 21304
// exit ;
21302: GO 22858
// for i in tmp do
21304: LD_ADDR_VAR 0 6
21308: PUSH
21309: LD_VAR 0 8
21313: PUSH
21314: FOR_IN
21315: IFFALSE 22833
// begin points := [ 0 , 0 , 0 ] ;
21317: LD_ADDR_VAR 0 9
21321: PUSH
21322: LD_INT 0
21324: PUSH
21325: LD_INT 0
21327: PUSH
21328: LD_INT 0
21330: PUSH
21331: EMPTY
21332: LIST
21333: LIST
21334: LIST
21335: ST_TO_ADDR
// bpoints := 1 ;
21336: LD_ADDR_VAR 0 10
21340: PUSH
21341: LD_INT 1
21343: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21344: LD_VAR 0 6
21348: PPUSH
21349: CALL_OW 247
21353: PUSH
21354: LD_INT 1
21356: DOUBLE
21357: EQUAL
21358: IFTRUE 21362
21360: GO 21940
21362: POP
// begin if GetClass ( i ) = 1 then
21363: LD_VAR 0 6
21367: PPUSH
21368: CALL_OW 257
21372: PUSH
21373: LD_INT 1
21375: EQUAL
21376: IFFALSE 21397
// points := [ 10 , 5 , 3 ] ;
21378: LD_ADDR_VAR 0 9
21382: PUSH
21383: LD_INT 10
21385: PUSH
21386: LD_INT 5
21388: PUSH
21389: LD_INT 3
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21397: LD_VAR 0 6
21401: PPUSH
21402: CALL_OW 257
21406: PUSH
21407: LD_INT 2
21409: PUSH
21410: LD_INT 3
21412: PUSH
21413: LD_INT 4
21415: PUSH
21416: EMPTY
21417: LIST
21418: LIST
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 3 , 2 , 1 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 3
21430: PUSH
21431: LD_INT 2
21433: PUSH
21434: LD_INT 1
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 257
21451: PUSH
21452: LD_INT 5
21454: EQUAL
21455: IFFALSE 21476
// points := [ 130 , 5 , 2 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 130
21464: PUSH
21465: LD_INT 5
21467: PUSH
21468: LD_INT 2
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 257
21485: PUSH
21486: LD_INT 8
21488: EQUAL
21489: IFFALSE 21510
// points := [ 35 , 35 , 30 ] ;
21491: LD_ADDR_VAR 0 9
21495: PUSH
21496: LD_INT 35
21498: PUSH
21499: LD_INT 35
21501: PUSH
21502: LD_INT 30
21504: PUSH
21505: EMPTY
21506: LIST
21507: LIST
21508: LIST
21509: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21510: LD_VAR 0 6
21514: PPUSH
21515: CALL_OW 257
21519: PUSH
21520: LD_INT 9
21522: EQUAL
21523: IFFALSE 21544
// points := [ 20 , 55 , 40 ] ;
21525: LD_ADDR_VAR 0 9
21529: PUSH
21530: LD_INT 20
21532: PUSH
21533: LD_INT 55
21535: PUSH
21536: LD_INT 40
21538: PUSH
21539: EMPTY
21540: LIST
21541: LIST
21542: LIST
21543: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 257
21553: PUSH
21554: LD_INT 12
21556: PUSH
21557: LD_INT 16
21559: PUSH
21560: EMPTY
21561: LIST
21562: LIST
21563: IN
21564: IFFALSE 21585
// points := [ 5 , 3 , 2 ] ;
21566: LD_ADDR_VAR 0 9
21570: PUSH
21571: LD_INT 5
21573: PUSH
21574: LD_INT 3
21576: PUSH
21577: LD_INT 2
21579: PUSH
21580: EMPTY
21581: LIST
21582: LIST
21583: LIST
21584: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21585: LD_VAR 0 6
21589: PPUSH
21590: CALL_OW 257
21594: PUSH
21595: LD_INT 17
21597: EQUAL
21598: IFFALSE 21619
// points := [ 100 , 50 , 75 ] ;
21600: LD_ADDR_VAR 0 9
21604: PUSH
21605: LD_INT 100
21607: PUSH
21608: LD_INT 50
21610: PUSH
21611: LD_INT 75
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: LIST
21618: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21619: LD_VAR 0 6
21623: PPUSH
21624: CALL_OW 257
21628: PUSH
21629: LD_INT 15
21631: EQUAL
21632: IFFALSE 21653
// points := [ 10 , 5 , 3 ] ;
21634: LD_ADDR_VAR 0 9
21638: PUSH
21639: LD_INT 10
21641: PUSH
21642: LD_INT 5
21644: PUSH
21645: LD_INT 3
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21653: LD_VAR 0 6
21657: PPUSH
21658: CALL_OW 257
21662: PUSH
21663: LD_INT 14
21665: EQUAL
21666: IFFALSE 21687
// points := [ 10 , 0 , 0 ] ;
21668: LD_ADDR_VAR 0 9
21672: PUSH
21673: LD_INT 10
21675: PUSH
21676: LD_INT 0
21678: PUSH
21679: LD_INT 0
21681: PUSH
21682: EMPTY
21683: LIST
21684: LIST
21685: LIST
21686: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21687: LD_VAR 0 6
21691: PPUSH
21692: CALL_OW 257
21696: PUSH
21697: LD_INT 11
21699: EQUAL
21700: IFFALSE 21721
// points := [ 30 , 10 , 5 ] ;
21702: LD_ADDR_VAR 0 9
21706: PUSH
21707: LD_INT 30
21709: PUSH
21710: LD_INT 10
21712: PUSH
21713: LD_INT 5
21715: PUSH
21716: EMPTY
21717: LIST
21718: LIST
21719: LIST
21720: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21721: LD_VAR 0 1
21725: PPUSH
21726: LD_INT 5
21728: PPUSH
21729: CALL_OW 321
21733: PUSH
21734: LD_INT 2
21736: EQUAL
21737: IFFALSE 21754
// bpoints := bpoints * 1.8 ;
21739: LD_ADDR_VAR 0 10
21743: PUSH
21744: LD_VAR 0 10
21748: PUSH
21749: LD_REAL  1.80000000000000E+0000
21752: MUL
21753: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21754: LD_VAR 0 6
21758: PPUSH
21759: CALL_OW 257
21763: PUSH
21764: LD_INT 1
21766: PUSH
21767: LD_INT 2
21769: PUSH
21770: LD_INT 3
21772: PUSH
21773: LD_INT 4
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: LIST
21780: LIST
21781: IN
21782: PUSH
21783: LD_VAR 0 1
21787: PPUSH
21788: LD_INT 51
21790: PPUSH
21791: CALL_OW 321
21795: PUSH
21796: LD_INT 2
21798: EQUAL
21799: AND
21800: IFFALSE 21817
// bpoints := bpoints * 1.2 ;
21802: LD_ADDR_VAR 0 10
21806: PUSH
21807: LD_VAR 0 10
21811: PUSH
21812: LD_REAL  1.20000000000000E+0000
21815: MUL
21816: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21817: LD_VAR 0 6
21821: PPUSH
21822: CALL_OW 257
21826: PUSH
21827: LD_INT 5
21829: PUSH
21830: LD_INT 7
21832: PUSH
21833: LD_INT 9
21835: PUSH
21836: EMPTY
21837: LIST
21838: LIST
21839: LIST
21840: IN
21841: PUSH
21842: LD_VAR 0 1
21846: PPUSH
21847: LD_INT 52
21849: PPUSH
21850: CALL_OW 321
21854: PUSH
21855: LD_INT 2
21857: EQUAL
21858: AND
21859: IFFALSE 21876
// bpoints := bpoints * 1.5 ;
21861: LD_ADDR_VAR 0 10
21865: PUSH
21866: LD_VAR 0 10
21870: PUSH
21871: LD_REAL  1.50000000000000E+0000
21874: MUL
21875: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21876: LD_VAR 0 1
21880: PPUSH
21881: LD_INT 66
21883: PPUSH
21884: CALL_OW 321
21888: PUSH
21889: LD_INT 2
21891: EQUAL
21892: IFFALSE 21909
// bpoints := bpoints * 1.1 ;
21894: LD_ADDR_VAR 0 10
21898: PUSH
21899: LD_VAR 0 10
21903: PUSH
21904: LD_REAL  1.10000000000000E+0000
21907: MUL
21908: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21909: LD_ADDR_VAR 0 10
21913: PUSH
21914: LD_VAR 0 10
21918: PUSH
21919: LD_VAR 0 6
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 259
21931: PUSH
21932: LD_REAL  1.15000000000000E+0000
21935: MUL
21936: MUL
21937: ST_TO_ADDR
// end ; unit_vehicle :
21938: GO 22762
21940: LD_INT 2
21942: DOUBLE
21943: EQUAL
21944: IFTRUE 21948
21946: GO 22750
21948: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21949: LD_VAR 0 6
21953: PPUSH
21954: CALL_OW 264
21958: PUSH
21959: LD_INT 2
21961: PUSH
21962: LD_INT 42
21964: PUSH
21965: LD_INT 24
21967: PUSH
21968: EMPTY
21969: LIST
21970: LIST
21971: LIST
21972: IN
21973: IFFALSE 21994
// points := [ 25 , 5 , 3 ] ;
21975: LD_ADDR_VAR 0 9
21979: PUSH
21980: LD_INT 25
21982: PUSH
21983: LD_INT 5
21985: PUSH
21986: LD_INT 3
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: LIST
21993: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21994: LD_VAR 0 6
21998: PPUSH
21999: CALL_OW 264
22003: PUSH
22004: LD_INT 4
22006: PUSH
22007: LD_INT 43
22009: PUSH
22010: LD_INT 25
22012: PUSH
22013: EMPTY
22014: LIST
22015: LIST
22016: LIST
22017: IN
22018: IFFALSE 22039
// points := [ 40 , 15 , 5 ] ;
22020: LD_ADDR_VAR 0 9
22024: PUSH
22025: LD_INT 40
22027: PUSH
22028: LD_INT 15
22030: PUSH
22031: LD_INT 5
22033: PUSH
22034: EMPTY
22035: LIST
22036: LIST
22037: LIST
22038: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22039: LD_VAR 0 6
22043: PPUSH
22044: CALL_OW 264
22048: PUSH
22049: LD_INT 3
22051: PUSH
22052: LD_INT 23
22054: PUSH
22055: EMPTY
22056: LIST
22057: LIST
22058: IN
22059: IFFALSE 22080
// points := [ 7 , 25 , 8 ] ;
22061: LD_ADDR_VAR 0 9
22065: PUSH
22066: LD_INT 7
22068: PUSH
22069: LD_INT 25
22071: PUSH
22072: LD_INT 8
22074: PUSH
22075: EMPTY
22076: LIST
22077: LIST
22078: LIST
22079: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22080: LD_VAR 0 6
22084: PPUSH
22085: CALL_OW 264
22089: PUSH
22090: LD_INT 5
22092: PUSH
22093: LD_INT 27
22095: PUSH
22096: LD_INT 44
22098: PUSH
22099: EMPTY
22100: LIST
22101: LIST
22102: LIST
22103: IN
22104: IFFALSE 22125
// points := [ 14 , 50 , 16 ] ;
22106: LD_ADDR_VAR 0 9
22110: PUSH
22111: LD_INT 14
22113: PUSH
22114: LD_INT 50
22116: PUSH
22117: LD_INT 16
22119: PUSH
22120: EMPTY
22121: LIST
22122: LIST
22123: LIST
22124: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22125: LD_VAR 0 6
22129: PPUSH
22130: CALL_OW 264
22134: PUSH
22135: LD_INT 6
22137: PUSH
22138: LD_INT 46
22140: PUSH
22141: EMPTY
22142: LIST
22143: LIST
22144: IN
22145: IFFALSE 22166
// points := [ 32 , 120 , 70 ] ;
22147: LD_ADDR_VAR 0 9
22151: PUSH
22152: LD_INT 32
22154: PUSH
22155: LD_INT 120
22157: PUSH
22158: LD_INT 70
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: LIST
22165: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22166: LD_VAR 0 6
22170: PPUSH
22171: CALL_OW 264
22175: PUSH
22176: LD_INT 7
22178: PUSH
22179: LD_INT 28
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: EMPTY
22186: LIST
22187: LIST
22188: LIST
22189: IN
22190: IFFALSE 22211
// points := [ 35 , 20 , 45 ] ;
22192: LD_ADDR_VAR 0 9
22196: PUSH
22197: LD_INT 35
22199: PUSH
22200: LD_INT 20
22202: PUSH
22203: LD_INT 45
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22211: LD_VAR 0 6
22215: PPUSH
22216: CALL_OW 264
22220: PUSH
22221: LD_INT 47
22223: PUSH
22224: EMPTY
22225: LIST
22226: IN
22227: IFFALSE 22248
// points := [ 67 , 45 , 75 ] ;
22229: LD_ADDR_VAR 0 9
22233: PUSH
22234: LD_INT 67
22236: PUSH
22237: LD_INT 45
22239: PUSH
22240: LD_INT 75
22242: PUSH
22243: EMPTY
22244: LIST
22245: LIST
22246: LIST
22247: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22248: LD_VAR 0 6
22252: PPUSH
22253: CALL_OW 264
22257: PUSH
22258: LD_INT 26
22260: PUSH
22261: EMPTY
22262: LIST
22263: IN
22264: IFFALSE 22285
// points := [ 120 , 30 , 80 ] ;
22266: LD_ADDR_VAR 0 9
22270: PUSH
22271: LD_INT 120
22273: PUSH
22274: LD_INT 30
22276: PUSH
22277: LD_INT 80
22279: PUSH
22280: EMPTY
22281: LIST
22282: LIST
22283: LIST
22284: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22285: LD_VAR 0 6
22289: PPUSH
22290: CALL_OW 264
22294: PUSH
22295: LD_INT 22
22297: PUSH
22298: EMPTY
22299: LIST
22300: IN
22301: IFFALSE 22322
// points := [ 40 , 1 , 1 ] ;
22303: LD_ADDR_VAR 0 9
22307: PUSH
22308: LD_INT 40
22310: PUSH
22311: LD_INT 1
22313: PUSH
22314: LD_INT 1
22316: PUSH
22317: EMPTY
22318: LIST
22319: LIST
22320: LIST
22321: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22322: LD_VAR 0 6
22326: PPUSH
22327: CALL_OW 264
22331: PUSH
22332: LD_INT 29
22334: PUSH
22335: EMPTY
22336: LIST
22337: IN
22338: IFFALSE 22359
// points := [ 70 , 200 , 400 ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: LD_INT 70
22347: PUSH
22348: LD_INT 200
22350: PUSH
22351: LD_INT 400
22353: PUSH
22354: EMPTY
22355: LIST
22356: LIST
22357: LIST
22358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 14
22371: PUSH
22372: LD_INT 53
22374: PUSH
22375: EMPTY
22376: LIST
22377: LIST
22378: IN
22379: IFFALSE 22400
// points := [ 40 , 10 , 20 ] ;
22381: LD_ADDR_VAR 0 9
22385: PUSH
22386: LD_INT 40
22388: PUSH
22389: LD_INT 10
22391: PUSH
22392: LD_INT 20
22394: PUSH
22395: EMPTY
22396: LIST
22397: LIST
22398: LIST
22399: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22400: LD_VAR 0 6
22404: PPUSH
22405: CALL_OW 264
22409: PUSH
22410: LD_INT 9
22412: PUSH
22413: EMPTY
22414: LIST
22415: IN
22416: IFFALSE 22437
// points := [ 5 , 70 , 20 ] ;
22418: LD_ADDR_VAR 0 9
22422: PUSH
22423: LD_INT 5
22425: PUSH
22426: LD_INT 70
22428: PUSH
22429: LD_INT 20
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: LIST
22436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22437: LD_VAR 0 6
22441: PPUSH
22442: CALL_OW 264
22446: PUSH
22447: LD_INT 10
22449: PUSH
22450: EMPTY
22451: LIST
22452: IN
22453: IFFALSE 22474
// points := [ 35 , 110 , 70 ] ;
22455: LD_ADDR_VAR 0 9
22459: PUSH
22460: LD_INT 35
22462: PUSH
22463: LD_INT 110
22465: PUSH
22466: LD_INT 70
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: LIST
22473: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22474: LD_VAR 0 6
22478: PPUSH
22479: CALL_OW 265
22483: PUSH
22484: LD_INT 25
22486: EQUAL
22487: IFFALSE 22508
// points := [ 80 , 65 , 100 ] ;
22489: LD_ADDR_VAR 0 9
22493: PUSH
22494: LD_INT 80
22496: PUSH
22497: LD_INT 65
22499: PUSH
22500: LD_INT 100
22502: PUSH
22503: EMPTY
22504: LIST
22505: LIST
22506: LIST
22507: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22508: LD_VAR 0 6
22512: PPUSH
22513: CALL_OW 263
22517: PUSH
22518: LD_INT 1
22520: EQUAL
22521: IFFALSE 22556
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22523: LD_ADDR_VAR 0 10
22527: PUSH
22528: LD_VAR 0 10
22532: PUSH
22533: LD_VAR 0 6
22537: PPUSH
22538: CALL_OW 311
22542: PPUSH
22543: LD_INT 3
22545: PPUSH
22546: CALL_OW 259
22550: PUSH
22551: LD_INT 4
22553: MUL
22554: MUL
22555: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22556: LD_VAR 0 6
22560: PPUSH
22561: CALL_OW 263
22565: PUSH
22566: LD_INT 2
22568: EQUAL
22569: IFFALSE 22620
// begin j := IsControledBy ( i ) ;
22571: LD_ADDR_VAR 0 7
22575: PUSH
22576: LD_VAR 0 6
22580: PPUSH
22581: CALL_OW 312
22585: ST_TO_ADDR
// if j then
22586: LD_VAR 0 7
22590: IFFALSE 22620
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22592: LD_ADDR_VAR 0 10
22596: PUSH
22597: LD_VAR 0 10
22601: PUSH
22602: LD_VAR 0 7
22606: PPUSH
22607: LD_INT 3
22609: PPUSH
22610: CALL_OW 259
22614: PUSH
22615: LD_INT 3
22617: MUL
22618: MUL
22619: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22620: LD_VAR 0 6
22624: PPUSH
22625: CALL_OW 264
22629: PUSH
22630: LD_INT 5
22632: PUSH
22633: LD_INT 6
22635: PUSH
22636: LD_INT 46
22638: PUSH
22639: LD_INT 44
22641: PUSH
22642: LD_INT 47
22644: PUSH
22645: LD_INT 45
22647: PUSH
22648: LD_INT 28
22650: PUSH
22651: LD_INT 7
22653: PUSH
22654: LD_INT 27
22656: PUSH
22657: LD_INT 29
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: LIST
22666: LIST
22667: LIST
22668: LIST
22669: LIST
22670: LIST
22671: IN
22672: PUSH
22673: LD_VAR 0 1
22677: PPUSH
22678: LD_INT 52
22680: PPUSH
22681: CALL_OW 321
22685: PUSH
22686: LD_INT 2
22688: EQUAL
22689: AND
22690: IFFALSE 22707
// bpoints := bpoints * 1.2 ;
22692: LD_ADDR_VAR 0 10
22696: PUSH
22697: LD_VAR 0 10
22701: PUSH
22702: LD_REAL  1.20000000000000E+0000
22705: MUL
22706: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22707: LD_VAR 0 6
22711: PPUSH
22712: CALL_OW 264
22716: PUSH
22717: LD_INT 6
22719: PUSH
22720: LD_INT 46
22722: PUSH
22723: LD_INT 47
22725: PUSH
22726: EMPTY
22727: LIST
22728: LIST
22729: LIST
22730: IN
22731: IFFALSE 22748
// bpoints := bpoints * 1.2 ;
22733: LD_ADDR_VAR 0 10
22737: PUSH
22738: LD_VAR 0 10
22742: PUSH
22743: LD_REAL  1.20000000000000E+0000
22746: MUL
22747: ST_TO_ADDR
// end ; unit_building :
22748: GO 22762
22750: LD_INT 3
22752: DOUBLE
22753: EQUAL
22754: IFTRUE 22758
22756: GO 22761
22758: POP
// ; end ;
22759: GO 22762
22761: POP
// for j = 1 to 3 do
22762: LD_ADDR_VAR 0 7
22766: PUSH
22767: DOUBLE
22768: LD_INT 1
22770: DEC
22771: ST_TO_ADDR
22772: LD_INT 3
22774: PUSH
22775: FOR_TO
22776: IFFALSE 22829
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22778: LD_ADDR_VAR 0 5
22782: PUSH
22783: LD_VAR 0 5
22787: PPUSH
22788: LD_VAR 0 7
22792: PPUSH
22793: LD_VAR 0 5
22797: PUSH
22798: LD_VAR 0 7
22802: ARRAY
22803: PUSH
22804: LD_VAR 0 9
22808: PUSH
22809: LD_VAR 0 7
22813: ARRAY
22814: PUSH
22815: LD_VAR 0 10
22819: MUL
22820: PLUS
22821: PPUSH
22822: CALL_OW 1
22826: ST_TO_ADDR
22827: GO 22775
22829: POP
22830: POP
// end ;
22831: GO 21314
22833: POP
22834: POP
// result := Replace ( result , 4 , tmp ) ;
22835: LD_ADDR_VAR 0 5
22839: PUSH
22840: LD_VAR 0 5
22844: PPUSH
22845: LD_INT 4
22847: PPUSH
22848: LD_VAR 0 8
22852: PPUSH
22853: CALL_OW 1
22857: ST_TO_ADDR
// end ;
22858: LD_VAR 0 5
22862: RET
// export function DangerAtRange ( unit , range ) ; begin
22863: LD_INT 0
22865: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22866: LD_ADDR_VAR 0 3
22870: PUSH
22871: LD_VAR 0 1
22875: PPUSH
22876: CALL_OW 255
22880: PPUSH
22881: LD_VAR 0 1
22885: PPUSH
22886: CALL_OW 250
22890: PPUSH
22891: LD_VAR 0 1
22895: PPUSH
22896: CALL_OW 251
22900: PPUSH
22901: LD_VAR 0 2
22905: PPUSH
22906: CALL 21166 0 4
22910: ST_TO_ADDR
// end ;
22911: LD_VAR 0 3
22915: RET
// export function DangerInArea ( side , area ) ; begin
22916: LD_INT 0
22918: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22919: LD_ADDR_VAR 0 3
22923: PUSH
22924: LD_VAR 0 2
22928: PPUSH
22929: LD_INT 81
22931: PUSH
22932: LD_VAR 0 1
22936: PUSH
22937: EMPTY
22938: LIST
22939: LIST
22940: PPUSH
22941: CALL_OW 70
22945: ST_TO_ADDR
// end ;
22946: LD_VAR 0 3
22950: RET
// export function IsExtension ( b ) ; begin
22951: LD_INT 0
22953: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22954: LD_ADDR_VAR 0 2
22958: PUSH
22959: LD_VAR 0 1
22963: PUSH
22964: LD_INT 23
22966: PUSH
22967: LD_INT 20
22969: PUSH
22970: LD_INT 22
22972: PUSH
22973: LD_INT 17
22975: PUSH
22976: LD_INT 24
22978: PUSH
22979: LD_INT 21
22981: PUSH
22982: LD_INT 19
22984: PUSH
22985: LD_INT 16
22987: PUSH
22988: LD_INT 25
22990: PUSH
22991: LD_INT 18
22993: PUSH
22994: EMPTY
22995: LIST
22996: LIST
22997: LIST
22998: LIST
22999: LIST
23000: LIST
23001: LIST
23002: LIST
23003: LIST
23004: LIST
23005: IN
23006: ST_TO_ADDR
// end ;
23007: LD_VAR 0 2
23011: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23012: LD_INT 0
23014: PPUSH
23015: PPUSH
23016: PPUSH
// result := [ ] ;
23017: LD_ADDR_VAR 0 3
23021: PUSH
23022: EMPTY
23023: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23024: LD_ADDR_VAR 0 4
23028: PUSH
23029: LD_VAR 0 2
23033: PPUSH
23034: LD_INT 21
23036: PUSH
23037: LD_INT 3
23039: PUSH
23040: EMPTY
23041: LIST
23042: LIST
23043: PPUSH
23044: CALL_OW 70
23048: ST_TO_ADDR
// if not tmp then
23049: LD_VAR 0 4
23053: NOT
23054: IFFALSE 23058
// exit ;
23056: GO 23116
// for i in tmp do
23058: LD_ADDR_VAR 0 5
23062: PUSH
23063: LD_VAR 0 4
23067: PUSH
23068: FOR_IN
23069: IFFALSE 23104
// if GetBase ( i ) <> base then
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 274
23080: PUSH
23081: LD_VAR 0 1
23085: NONEQUAL
23086: IFFALSE 23102
// ComLinkToBase ( base , i ) ;
23088: LD_VAR 0 1
23092: PPUSH
23093: LD_VAR 0 5
23097: PPUSH
23098: CALL_OW 169
23102: GO 23068
23104: POP
23105: POP
// result := tmp ;
23106: LD_ADDR_VAR 0 3
23110: PUSH
23111: LD_VAR 0 4
23115: ST_TO_ADDR
// end ;
23116: LD_VAR 0 3
23120: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23121: LD_INT 0
23123: PPUSH
23124: PPUSH
// if BuildingStatus ( b ) = bs_build then
23125: LD_VAR 0 2
23129: PPUSH
23130: CALL_OW 461
23134: PUSH
23135: LD_INT 1
23137: EQUAL
23138: IFFALSE 23198
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23140: LD_VAR 0 1
23144: PPUSH
23145: LD_STRING h
23147: PUSH
23148: LD_VAR 0 2
23152: PPUSH
23153: CALL_OW 250
23157: PUSH
23158: LD_VAR 0 2
23162: PPUSH
23163: CALL_OW 251
23167: PUSH
23168: LD_VAR 0 2
23172: PUSH
23173: LD_INT 0
23175: PUSH
23176: LD_INT 0
23178: PUSH
23179: LD_INT 0
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: LIST
23186: LIST
23187: LIST
23188: LIST
23189: LIST
23190: PUSH
23191: EMPTY
23192: LIST
23193: PPUSH
23194: CALL_OW 446
// end ;
23198: LD_VAR 0 3
23202: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23203: LD_INT 0
23205: PPUSH
23206: PPUSH
23207: PPUSH
23208: PPUSH
23209: PPUSH
23210: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23211: LD_VAR 0 1
23215: NOT
23216: PUSH
23217: LD_VAR 0 1
23221: PPUSH
23222: CALL_OW 263
23226: PUSH
23227: LD_INT 2
23229: EQUAL
23230: NOT
23231: OR
23232: IFFALSE 23236
// exit ;
23234: GO 23552
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23236: LD_ADDR_VAR 0 6
23240: PUSH
23241: LD_INT 22
23243: PUSH
23244: LD_VAR 0 1
23248: PPUSH
23249: CALL_OW 255
23253: PUSH
23254: EMPTY
23255: LIST
23256: LIST
23257: PUSH
23258: LD_INT 2
23260: PUSH
23261: LD_INT 30
23263: PUSH
23264: LD_INT 36
23266: PUSH
23267: EMPTY
23268: LIST
23269: LIST
23270: PUSH
23271: LD_INT 34
23273: PUSH
23274: LD_INT 31
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: EMPTY
23282: LIST
23283: LIST
23284: LIST
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PPUSH
23290: CALL_OW 69
23294: ST_TO_ADDR
// if not tmp then
23295: LD_VAR 0 6
23299: NOT
23300: IFFALSE 23304
// exit ;
23302: GO 23552
// result := [ ] ;
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: EMPTY
23310: ST_TO_ADDR
// for i in tmp do
23311: LD_ADDR_VAR 0 3
23315: PUSH
23316: LD_VAR 0 6
23320: PUSH
23321: FOR_IN
23322: IFFALSE 23393
// begin t := UnitsInside ( i ) ;
23324: LD_ADDR_VAR 0 4
23328: PUSH
23329: LD_VAR 0 3
23333: PPUSH
23334: CALL_OW 313
23338: ST_TO_ADDR
// if t then
23339: LD_VAR 0 4
23343: IFFALSE 23391
// for j in t do
23345: LD_ADDR_VAR 0 7
23349: PUSH
23350: LD_VAR 0 4
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23389
// result := Insert ( result , result + 1 , j ) ;
23358: LD_ADDR_VAR 0 2
23362: PUSH
23363: LD_VAR 0 2
23367: PPUSH
23368: LD_VAR 0 2
23372: PUSH
23373: LD_INT 1
23375: PLUS
23376: PPUSH
23377: LD_VAR 0 7
23381: PPUSH
23382: CALL_OW 2
23386: ST_TO_ADDR
23387: GO 23355
23389: POP
23390: POP
// end ;
23391: GO 23321
23393: POP
23394: POP
// if not result then
23395: LD_VAR 0 2
23399: NOT
23400: IFFALSE 23404
// exit ;
23402: GO 23552
// mech := result [ 1 ] ;
23404: LD_ADDR_VAR 0 5
23408: PUSH
23409: LD_VAR 0 2
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: ST_TO_ADDR
// if result > 1 then
23418: LD_VAR 0 2
23422: PUSH
23423: LD_INT 1
23425: GREATER
23426: IFFALSE 23538
// for i = 2 to result do
23428: LD_ADDR_VAR 0 3
23432: PUSH
23433: DOUBLE
23434: LD_INT 2
23436: DEC
23437: ST_TO_ADDR
23438: LD_VAR 0 2
23442: PUSH
23443: FOR_TO
23444: IFFALSE 23536
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23446: LD_ADDR_VAR 0 4
23450: PUSH
23451: LD_VAR 0 2
23455: PUSH
23456: LD_VAR 0 3
23460: ARRAY
23461: PPUSH
23462: LD_INT 3
23464: PPUSH
23465: CALL_OW 259
23469: PUSH
23470: LD_VAR 0 2
23474: PUSH
23475: LD_VAR 0 3
23479: ARRAY
23480: PPUSH
23481: CALL_OW 432
23485: MINUS
23486: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23487: LD_VAR 0 4
23491: PUSH
23492: LD_VAR 0 5
23496: PPUSH
23497: LD_INT 3
23499: PPUSH
23500: CALL_OW 259
23504: PUSH
23505: LD_VAR 0 5
23509: PPUSH
23510: CALL_OW 432
23514: MINUS
23515: GREATEREQUAL
23516: IFFALSE 23534
// mech := result [ i ] ;
23518: LD_ADDR_VAR 0 5
23522: PUSH
23523: LD_VAR 0 2
23527: PUSH
23528: LD_VAR 0 3
23532: ARRAY
23533: ST_TO_ADDR
// end ;
23534: GO 23443
23536: POP
23537: POP
// ComLinkTo ( vehicle , mech ) ;
23538: LD_VAR 0 1
23542: PPUSH
23543: LD_VAR 0 5
23547: PPUSH
23548: CALL_OW 135
// end ;
23552: LD_VAR 0 2
23556: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23557: LD_INT 0
23559: PPUSH
23560: PPUSH
23561: PPUSH
23562: PPUSH
23563: PPUSH
23564: PPUSH
23565: PPUSH
23566: PPUSH
23567: PPUSH
23568: PPUSH
23569: PPUSH
23570: PPUSH
23571: PPUSH
// result := [ ] ;
23572: LD_ADDR_VAR 0 7
23576: PUSH
23577: EMPTY
23578: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23579: LD_VAR 0 1
23583: PPUSH
23584: CALL_OW 266
23588: PUSH
23589: LD_INT 0
23591: PUSH
23592: LD_INT 1
23594: PUSH
23595: EMPTY
23596: LIST
23597: LIST
23598: IN
23599: NOT
23600: IFFALSE 23604
// exit ;
23602: GO 25235
// if name then
23604: LD_VAR 0 3
23608: IFFALSE 23624
// SetBName ( base_dep , name ) ;
23610: LD_VAR 0 1
23614: PPUSH
23615: LD_VAR 0 3
23619: PPUSH
23620: CALL_OW 500
// base := GetBase ( base_dep ) ;
23624: LD_ADDR_VAR 0 15
23628: PUSH
23629: LD_VAR 0 1
23633: PPUSH
23634: CALL_OW 274
23638: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23639: LD_ADDR_VAR 0 16
23643: PUSH
23644: LD_VAR 0 1
23648: PPUSH
23649: CALL_OW 255
23653: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23654: LD_ADDR_VAR 0 17
23658: PUSH
23659: LD_VAR 0 1
23663: PPUSH
23664: CALL_OW 248
23668: ST_TO_ADDR
// if sources then
23669: LD_VAR 0 5
23673: IFFALSE 23720
// for i = 1 to 3 do
23675: LD_ADDR_VAR 0 8
23679: PUSH
23680: DOUBLE
23681: LD_INT 1
23683: DEC
23684: ST_TO_ADDR
23685: LD_INT 3
23687: PUSH
23688: FOR_TO
23689: IFFALSE 23718
// AddResourceType ( base , i , sources [ i ] ) ;
23691: LD_VAR 0 15
23695: PPUSH
23696: LD_VAR 0 8
23700: PPUSH
23701: LD_VAR 0 5
23705: PUSH
23706: LD_VAR 0 8
23710: ARRAY
23711: PPUSH
23712: CALL_OW 276
23716: GO 23688
23718: POP
23719: POP
// buildings := GetBaseBuildings ( base , area ) ;
23720: LD_ADDR_VAR 0 18
23724: PUSH
23725: LD_VAR 0 15
23729: PPUSH
23730: LD_VAR 0 2
23734: PPUSH
23735: CALL 23012 0 2
23739: ST_TO_ADDR
// InitHc ;
23740: CALL_OW 19
// InitUc ;
23744: CALL_OW 18
// uc_side := side ;
23748: LD_ADDR_OWVAR 20
23752: PUSH
23753: LD_VAR 0 16
23757: ST_TO_ADDR
// uc_nation := nation ;
23758: LD_ADDR_OWVAR 21
23762: PUSH
23763: LD_VAR 0 17
23767: ST_TO_ADDR
// if buildings then
23768: LD_VAR 0 18
23772: IFFALSE 25094
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23774: LD_ADDR_VAR 0 19
23778: PUSH
23779: LD_VAR 0 18
23783: PPUSH
23784: LD_INT 2
23786: PUSH
23787: LD_INT 30
23789: PUSH
23790: LD_INT 29
23792: PUSH
23793: EMPTY
23794: LIST
23795: LIST
23796: PUSH
23797: LD_INT 30
23799: PUSH
23800: LD_INT 30
23802: PUSH
23803: EMPTY
23804: LIST
23805: LIST
23806: PUSH
23807: EMPTY
23808: LIST
23809: LIST
23810: LIST
23811: PPUSH
23812: CALL_OW 72
23816: ST_TO_ADDR
// if tmp then
23817: LD_VAR 0 19
23821: IFFALSE 23869
// for i in tmp do
23823: LD_ADDR_VAR 0 8
23827: PUSH
23828: LD_VAR 0 19
23832: PUSH
23833: FOR_IN
23834: IFFALSE 23867
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23836: LD_VAR 0 8
23840: PPUSH
23841: CALL_OW 250
23845: PPUSH
23846: LD_VAR 0 8
23850: PPUSH
23851: CALL_OW 251
23855: PPUSH
23856: LD_VAR 0 16
23860: PPUSH
23861: CALL_OW 441
23865: GO 23833
23867: POP
23868: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23869: LD_VAR 0 18
23873: PPUSH
23874: LD_INT 2
23876: PUSH
23877: LD_INT 30
23879: PUSH
23880: LD_INT 32
23882: PUSH
23883: EMPTY
23884: LIST
23885: LIST
23886: PUSH
23887: LD_INT 30
23889: PUSH
23890: LD_INT 33
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 72
23906: IFFALSE 23994
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23908: LD_ADDR_VAR 0 8
23912: PUSH
23913: LD_VAR 0 18
23917: PPUSH
23918: LD_INT 2
23920: PUSH
23921: LD_INT 30
23923: PUSH
23924: LD_INT 32
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: PUSH
23931: LD_INT 30
23933: PUSH
23934: LD_INT 33
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: LIST
23945: PPUSH
23946: CALL_OW 72
23950: PUSH
23951: FOR_IN
23952: IFFALSE 23992
// begin if not GetBWeapon ( i ) then
23954: LD_VAR 0 8
23958: PPUSH
23959: CALL_OW 269
23963: NOT
23964: IFFALSE 23990
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23966: LD_VAR 0 8
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 2
23980: PPUSH
23981: CALL 25240 0 2
23985: PPUSH
23986: CALL_OW 431
// end ;
23990: GO 23951
23992: POP
23993: POP
// end ; for i = 1 to personel do
23994: LD_ADDR_VAR 0 8
23998: PUSH
23999: DOUBLE
24000: LD_INT 1
24002: DEC
24003: ST_TO_ADDR
24004: LD_VAR 0 6
24008: PUSH
24009: FOR_TO
24010: IFFALSE 25074
// begin if i > 4 then
24012: LD_VAR 0 8
24016: PUSH
24017: LD_INT 4
24019: GREATER
24020: IFFALSE 24024
// break ;
24022: GO 25074
// case i of 1 :
24024: LD_VAR 0 8
24028: PUSH
24029: LD_INT 1
24031: DOUBLE
24032: EQUAL
24033: IFTRUE 24037
24035: GO 24117
24037: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24038: LD_ADDR_VAR 0 12
24042: PUSH
24043: LD_VAR 0 18
24047: PPUSH
24048: LD_INT 22
24050: PUSH
24051: LD_VAR 0 16
24055: PUSH
24056: EMPTY
24057: LIST
24058: LIST
24059: PUSH
24060: LD_INT 58
24062: PUSH
24063: EMPTY
24064: LIST
24065: PUSH
24066: LD_INT 2
24068: PUSH
24069: LD_INT 30
24071: PUSH
24072: LD_INT 32
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: LD_INT 30
24081: PUSH
24082: LD_INT 4
24084: PUSH
24085: EMPTY
24086: LIST
24087: LIST
24088: PUSH
24089: LD_INT 30
24091: PUSH
24092: LD_INT 5
24094: PUSH
24095: EMPTY
24096: LIST
24097: LIST
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: LIST
24103: LIST
24104: PUSH
24105: EMPTY
24106: LIST
24107: LIST
24108: LIST
24109: PPUSH
24110: CALL_OW 72
24114: ST_TO_ADDR
24115: GO 24339
24117: LD_INT 2
24119: DOUBLE
24120: EQUAL
24121: IFTRUE 24125
24123: GO 24187
24125: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24126: LD_ADDR_VAR 0 12
24130: PUSH
24131: LD_VAR 0 18
24135: PPUSH
24136: LD_INT 22
24138: PUSH
24139: LD_VAR 0 16
24143: PUSH
24144: EMPTY
24145: LIST
24146: LIST
24147: PUSH
24148: LD_INT 2
24150: PUSH
24151: LD_INT 30
24153: PUSH
24154: LD_INT 0
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: LD_INT 30
24163: PUSH
24164: LD_INT 1
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: EMPTY
24172: LIST
24173: LIST
24174: LIST
24175: PUSH
24176: EMPTY
24177: LIST
24178: LIST
24179: PPUSH
24180: CALL_OW 72
24184: ST_TO_ADDR
24185: GO 24339
24187: LD_INT 3
24189: DOUBLE
24190: EQUAL
24191: IFTRUE 24195
24193: GO 24257
24195: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24196: LD_ADDR_VAR 0 12
24200: PUSH
24201: LD_VAR 0 18
24205: PPUSH
24206: LD_INT 22
24208: PUSH
24209: LD_VAR 0 16
24213: PUSH
24214: EMPTY
24215: LIST
24216: LIST
24217: PUSH
24218: LD_INT 2
24220: PUSH
24221: LD_INT 30
24223: PUSH
24224: LD_INT 2
24226: PUSH
24227: EMPTY
24228: LIST
24229: LIST
24230: PUSH
24231: LD_INT 30
24233: PUSH
24234: LD_INT 3
24236: PUSH
24237: EMPTY
24238: LIST
24239: LIST
24240: PUSH
24241: EMPTY
24242: LIST
24243: LIST
24244: LIST
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PPUSH
24250: CALL_OW 72
24254: ST_TO_ADDR
24255: GO 24339
24257: LD_INT 4
24259: DOUBLE
24260: EQUAL
24261: IFTRUE 24265
24263: GO 24338
24265: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 18
24275: PPUSH
24276: LD_INT 22
24278: PUSH
24279: LD_VAR 0 16
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: LD_INT 2
24290: PUSH
24291: LD_INT 30
24293: PUSH
24294: LD_INT 6
24296: PUSH
24297: EMPTY
24298: LIST
24299: LIST
24300: PUSH
24301: LD_INT 30
24303: PUSH
24304: LD_INT 7
24306: PUSH
24307: EMPTY
24308: LIST
24309: LIST
24310: PUSH
24311: LD_INT 30
24313: PUSH
24314: LD_INT 8
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PUSH
24327: EMPTY
24328: LIST
24329: LIST
24330: PPUSH
24331: CALL_OW 72
24335: ST_TO_ADDR
24336: GO 24339
24338: POP
// if i = 1 then
24339: LD_VAR 0 8
24343: PUSH
24344: LD_INT 1
24346: EQUAL
24347: IFFALSE 24458
// begin tmp := [ ] ;
24349: LD_ADDR_VAR 0 19
24353: PUSH
24354: EMPTY
24355: ST_TO_ADDR
// for j in f do
24356: LD_ADDR_VAR 0 9
24360: PUSH
24361: LD_VAR 0 12
24365: PUSH
24366: FOR_IN
24367: IFFALSE 24440
// if GetBType ( j ) = b_bunker then
24369: LD_VAR 0 9
24373: PPUSH
24374: CALL_OW 266
24378: PUSH
24379: LD_INT 32
24381: EQUAL
24382: IFFALSE 24409
// tmp := Insert ( tmp , 1 , j ) else
24384: LD_ADDR_VAR 0 19
24388: PUSH
24389: LD_VAR 0 19
24393: PPUSH
24394: LD_INT 1
24396: PPUSH
24397: LD_VAR 0 9
24401: PPUSH
24402: CALL_OW 2
24406: ST_TO_ADDR
24407: GO 24438
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24409: LD_ADDR_VAR 0 19
24413: PUSH
24414: LD_VAR 0 19
24418: PPUSH
24419: LD_VAR 0 19
24423: PUSH
24424: LD_INT 1
24426: PLUS
24427: PPUSH
24428: LD_VAR 0 9
24432: PPUSH
24433: CALL_OW 2
24437: ST_TO_ADDR
24438: GO 24366
24440: POP
24441: POP
// if tmp then
24442: LD_VAR 0 19
24446: IFFALSE 24458
// f := tmp ;
24448: LD_ADDR_VAR 0 12
24452: PUSH
24453: LD_VAR 0 19
24457: ST_TO_ADDR
// end ; x := personel [ i ] ;
24458: LD_ADDR_VAR 0 13
24462: PUSH
24463: LD_VAR 0 6
24467: PUSH
24468: LD_VAR 0 8
24472: ARRAY
24473: ST_TO_ADDR
// if x = - 1 then
24474: LD_VAR 0 13
24478: PUSH
24479: LD_INT 1
24481: NEG
24482: EQUAL
24483: IFFALSE 24692
// begin for j in f do
24485: LD_ADDR_VAR 0 9
24489: PUSH
24490: LD_VAR 0 12
24494: PUSH
24495: FOR_IN
24496: IFFALSE 24688
// repeat InitHc ;
24498: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24502: LD_VAR 0 9
24506: PPUSH
24507: CALL_OW 266
24511: PUSH
24512: LD_INT 5
24514: EQUAL
24515: IFFALSE 24585
// begin if UnitsInside ( j ) < 3 then
24517: LD_VAR 0 9
24521: PPUSH
24522: CALL_OW 313
24526: PUSH
24527: LD_INT 3
24529: LESS
24530: IFFALSE 24566
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24532: LD_INT 0
24534: PPUSH
24535: LD_INT 5
24537: PUSH
24538: LD_INT 8
24540: PUSH
24541: LD_INT 9
24543: PUSH
24544: EMPTY
24545: LIST
24546: LIST
24547: LIST
24548: PUSH
24549: LD_VAR 0 17
24553: ARRAY
24554: PPUSH
24555: LD_VAR 0 4
24559: PPUSH
24560: CALL_OW 380
24564: GO 24583
// PrepareHuman ( false , i , skill ) ;
24566: LD_INT 0
24568: PPUSH
24569: LD_VAR 0 8
24573: PPUSH
24574: LD_VAR 0 4
24578: PPUSH
24579: CALL_OW 380
// end else
24583: GO 24602
// PrepareHuman ( false , i , skill ) ;
24585: LD_INT 0
24587: PPUSH
24588: LD_VAR 0 8
24592: PPUSH
24593: LD_VAR 0 4
24597: PPUSH
24598: CALL_OW 380
// un := CreateHuman ;
24602: LD_ADDR_VAR 0 14
24606: PUSH
24607: CALL_OW 44
24611: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24612: LD_ADDR_VAR 0 7
24616: PUSH
24617: LD_VAR 0 7
24621: PPUSH
24622: LD_INT 1
24624: PPUSH
24625: LD_VAR 0 14
24629: PPUSH
24630: CALL_OW 2
24634: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24635: LD_VAR 0 14
24639: PPUSH
24640: LD_VAR 0 9
24644: PPUSH
24645: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24649: LD_VAR 0 9
24653: PPUSH
24654: CALL_OW 313
24658: PUSH
24659: LD_INT 6
24661: EQUAL
24662: PUSH
24663: LD_VAR 0 9
24667: PPUSH
24668: CALL_OW 266
24672: PUSH
24673: LD_INT 32
24675: PUSH
24676: LD_INT 31
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: IN
24683: OR
24684: IFFALSE 24498
24686: GO 24495
24688: POP
24689: POP
// end else
24690: GO 25072
// for j = 1 to x do
24692: LD_ADDR_VAR 0 9
24696: PUSH
24697: DOUBLE
24698: LD_INT 1
24700: DEC
24701: ST_TO_ADDR
24702: LD_VAR 0 13
24706: PUSH
24707: FOR_TO
24708: IFFALSE 25070
// begin InitHc ;
24710: CALL_OW 19
// if not f then
24714: LD_VAR 0 12
24718: NOT
24719: IFFALSE 24808
// begin PrepareHuman ( false , i , skill ) ;
24721: LD_INT 0
24723: PPUSH
24724: LD_VAR 0 8
24728: PPUSH
24729: LD_VAR 0 4
24733: PPUSH
24734: CALL_OW 380
// un := CreateHuman ;
24738: LD_ADDR_VAR 0 14
24742: PUSH
24743: CALL_OW 44
24747: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24748: LD_ADDR_VAR 0 7
24752: PUSH
24753: LD_VAR 0 7
24757: PPUSH
24758: LD_INT 1
24760: PPUSH
24761: LD_VAR 0 14
24765: PPUSH
24766: CALL_OW 2
24770: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24771: LD_VAR 0 14
24775: PPUSH
24776: LD_VAR 0 1
24780: PPUSH
24781: CALL_OW 250
24785: PPUSH
24786: LD_VAR 0 1
24790: PPUSH
24791: CALL_OW 251
24795: PPUSH
24796: LD_INT 10
24798: PPUSH
24799: LD_INT 0
24801: PPUSH
24802: CALL_OW 50
// continue ;
24806: GO 24707
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24808: LD_VAR 0 12
24812: PUSH
24813: LD_INT 1
24815: ARRAY
24816: PPUSH
24817: CALL_OW 313
24821: PUSH
24822: LD_VAR 0 12
24826: PUSH
24827: LD_INT 1
24829: ARRAY
24830: PPUSH
24831: CALL_OW 266
24835: PUSH
24836: LD_INT 32
24838: PUSH
24839: LD_INT 31
24841: PUSH
24842: EMPTY
24843: LIST
24844: LIST
24845: IN
24846: AND
24847: PUSH
24848: LD_VAR 0 12
24852: PUSH
24853: LD_INT 1
24855: ARRAY
24856: PPUSH
24857: CALL_OW 313
24861: PUSH
24862: LD_INT 6
24864: EQUAL
24865: OR
24866: IFFALSE 24886
// f := Delete ( f , 1 ) ;
24868: LD_ADDR_VAR 0 12
24872: PUSH
24873: LD_VAR 0 12
24877: PPUSH
24878: LD_INT 1
24880: PPUSH
24881: CALL_OW 3
24885: ST_TO_ADDR
// if not f then
24886: LD_VAR 0 12
24890: NOT
24891: IFFALSE 24909
// begin x := x + 2 ;
24893: LD_ADDR_VAR 0 13
24897: PUSH
24898: LD_VAR 0 13
24902: PUSH
24903: LD_INT 2
24905: PLUS
24906: ST_TO_ADDR
// continue ;
24907: GO 24707
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24909: LD_VAR 0 12
24913: PUSH
24914: LD_INT 1
24916: ARRAY
24917: PPUSH
24918: CALL_OW 266
24922: PUSH
24923: LD_INT 5
24925: EQUAL
24926: IFFALSE 25000
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24928: LD_VAR 0 12
24932: PUSH
24933: LD_INT 1
24935: ARRAY
24936: PPUSH
24937: CALL_OW 313
24941: PUSH
24942: LD_INT 3
24944: LESS
24945: IFFALSE 24981
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24947: LD_INT 0
24949: PPUSH
24950: LD_INT 5
24952: PUSH
24953: LD_INT 8
24955: PUSH
24956: LD_INT 9
24958: PUSH
24959: EMPTY
24960: LIST
24961: LIST
24962: LIST
24963: PUSH
24964: LD_VAR 0 17
24968: ARRAY
24969: PPUSH
24970: LD_VAR 0 4
24974: PPUSH
24975: CALL_OW 380
24979: GO 24998
// PrepareHuman ( false , i , skill ) ;
24981: LD_INT 0
24983: PPUSH
24984: LD_VAR 0 8
24988: PPUSH
24989: LD_VAR 0 4
24993: PPUSH
24994: CALL_OW 380
// end else
24998: GO 25017
// PrepareHuman ( false , i , skill ) ;
25000: LD_INT 0
25002: PPUSH
25003: LD_VAR 0 8
25007: PPUSH
25008: LD_VAR 0 4
25012: PPUSH
25013: CALL_OW 380
// un := CreateHuman ;
25017: LD_ADDR_VAR 0 14
25021: PUSH
25022: CALL_OW 44
25026: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25027: LD_ADDR_VAR 0 7
25031: PUSH
25032: LD_VAR 0 7
25036: PPUSH
25037: LD_INT 1
25039: PPUSH
25040: LD_VAR 0 14
25044: PPUSH
25045: CALL_OW 2
25049: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25050: LD_VAR 0 14
25054: PPUSH
25055: LD_VAR 0 12
25059: PUSH
25060: LD_INT 1
25062: ARRAY
25063: PPUSH
25064: CALL_OW 52
// end ;
25068: GO 24707
25070: POP
25071: POP
// end ;
25072: GO 24009
25074: POP
25075: POP
// result := result ^ buildings ;
25076: LD_ADDR_VAR 0 7
25080: PUSH
25081: LD_VAR 0 7
25085: PUSH
25086: LD_VAR 0 18
25090: ADD
25091: ST_TO_ADDR
// end else
25092: GO 25235
// begin for i = 1 to personel do
25094: LD_ADDR_VAR 0 8
25098: PUSH
25099: DOUBLE
25100: LD_INT 1
25102: DEC
25103: ST_TO_ADDR
25104: LD_VAR 0 6
25108: PUSH
25109: FOR_TO
25110: IFFALSE 25233
// begin if i > 4 then
25112: LD_VAR 0 8
25116: PUSH
25117: LD_INT 4
25119: GREATER
25120: IFFALSE 25124
// break ;
25122: GO 25233
// x := personel [ i ] ;
25124: LD_ADDR_VAR 0 13
25128: PUSH
25129: LD_VAR 0 6
25133: PUSH
25134: LD_VAR 0 8
25138: ARRAY
25139: ST_TO_ADDR
// if x = - 1 then
25140: LD_VAR 0 13
25144: PUSH
25145: LD_INT 1
25147: NEG
25148: EQUAL
25149: IFFALSE 25153
// continue ;
25151: GO 25109
// PrepareHuman ( false , i , skill ) ;
25153: LD_INT 0
25155: PPUSH
25156: LD_VAR 0 8
25160: PPUSH
25161: LD_VAR 0 4
25165: PPUSH
25166: CALL_OW 380
// un := CreateHuman ;
25170: LD_ADDR_VAR 0 14
25174: PUSH
25175: CALL_OW 44
25179: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25180: LD_VAR 0 14
25184: PPUSH
25185: LD_VAR 0 1
25189: PPUSH
25190: CALL_OW 250
25194: PPUSH
25195: LD_VAR 0 1
25199: PPUSH
25200: CALL_OW 251
25204: PPUSH
25205: LD_INT 10
25207: PPUSH
25208: LD_INT 0
25210: PPUSH
25211: CALL_OW 50
// result := result ^ un ;
25215: LD_ADDR_VAR 0 7
25219: PUSH
25220: LD_VAR 0 7
25224: PUSH
25225: LD_VAR 0 14
25229: ADD
25230: ST_TO_ADDR
// end ;
25231: GO 25109
25233: POP
25234: POP
// end ; end ;
25235: LD_VAR 0 7
25239: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25240: LD_INT 0
25242: PPUSH
25243: PPUSH
25244: PPUSH
25245: PPUSH
25246: PPUSH
25247: PPUSH
25248: PPUSH
25249: PPUSH
25250: PPUSH
25251: PPUSH
25252: PPUSH
25253: PPUSH
25254: PPUSH
25255: PPUSH
25256: PPUSH
25257: PPUSH
// result := false ;
25258: LD_ADDR_VAR 0 3
25262: PUSH
25263: LD_INT 0
25265: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25266: LD_VAR 0 1
25270: NOT
25271: PUSH
25272: LD_VAR 0 1
25276: PPUSH
25277: CALL_OW 266
25281: PUSH
25282: LD_INT 32
25284: PUSH
25285: LD_INT 33
25287: PUSH
25288: EMPTY
25289: LIST
25290: LIST
25291: IN
25292: NOT
25293: OR
25294: IFFALSE 25298
// exit ;
25296: GO 26434
// nat := GetNation ( tower ) ;
25298: LD_ADDR_VAR 0 12
25302: PUSH
25303: LD_VAR 0 1
25307: PPUSH
25308: CALL_OW 248
25312: ST_TO_ADDR
// side := GetSide ( tower ) ;
25313: LD_ADDR_VAR 0 16
25317: PUSH
25318: LD_VAR 0 1
25322: PPUSH
25323: CALL_OW 255
25327: ST_TO_ADDR
// x := GetX ( tower ) ;
25328: LD_ADDR_VAR 0 10
25332: PUSH
25333: LD_VAR 0 1
25337: PPUSH
25338: CALL_OW 250
25342: ST_TO_ADDR
// y := GetY ( tower ) ;
25343: LD_ADDR_VAR 0 11
25347: PUSH
25348: LD_VAR 0 1
25352: PPUSH
25353: CALL_OW 251
25357: ST_TO_ADDR
// if not x or not y then
25358: LD_VAR 0 10
25362: NOT
25363: PUSH
25364: LD_VAR 0 11
25368: NOT
25369: OR
25370: IFFALSE 25374
// exit ;
25372: GO 26434
// weapon := 0 ;
25374: LD_ADDR_VAR 0 18
25378: PUSH
25379: LD_INT 0
25381: ST_TO_ADDR
// fac_list := [ ] ;
25382: LD_ADDR_VAR 0 17
25386: PUSH
25387: EMPTY
25388: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25389: LD_ADDR_VAR 0 6
25393: PUSH
25394: LD_VAR 0 1
25398: PPUSH
25399: CALL_OW 274
25403: PPUSH
25404: LD_VAR 0 2
25408: PPUSH
25409: CALL 23012 0 2
25413: PPUSH
25414: LD_INT 30
25416: PUSH
25417: LD_INT 3
25419: PUSH
25420: EMPTY
25421: LIST
25422: LIST
25423: PPUSH
25424: CALL_OW 72
25428: ST_TO_ADDR
// if not factories then
25429: LD_VAR 0 6
25433: NOT
25434: IFFALSE 25438
// exit ;
25436: GO 26434
// for i in factories do
25438: LD_ADDR_VAR 0 8
25442: PUSH
25443: LD_VAR 0 6
25447: PUSH
25448: FOR_IN
25449: IFFALSE 25474
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25451: LD_ADDR_VAR 0 17
25455: PUSH
25456: LD_VAR 0 17
25460: PUSH
25461: LD_VAR 0 8
25465: PPUSH
25466: CALL_OW 478
25470: UNION
25471: ST_TO_ADDR
25472: GO 25448
25474: POP
25475: POP
// if not fac_list then
25476: LD_VAR 0 17
25480: NOT
25481: IFFALSE 25485
// exit ;
25483: GO 26434
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25485: LD_ADDR_VAR 0 5
25489: PUSH
25490: LD_INT 4
25492: PUSH
25493: LD_INT 5
25495: PUSH
25496: LD_INT 9
25498: PUSH
25499: LD_INT 10
25501: PUSH
25502: LD_INT 6
25504: PUSH
25505: LD_INT 7
25507: PUSH
25508: LD_INT 11
25510: PUSH
25511: EMPTY
25512: LIST
25513: LIST
25514: LIST
25515: LIST
25516: LIST
25517: LIST
25518: LIST
25519: PUSH
25520: LD_INT 27
25522: PUSH
25523: LD_INT 28
25525: PUSH
25526: LD_INT 26
25528: PUSH
25529: LD_INT 30
25531: PUSH
25532: EMPTY
25533: LIST
25534: LIST
25535: LIST
25536: LIST
25537: PUSH
25538: LD_INT 43
25540: PUSH
25541: LD_INT 44
25543: PUSH
25544: LD_INT 46
25546: PUSH
25547: LD_INT 45
25549: PUSH
25550: LD_INT 47
25552: PUSH
25553: LD_INT 49
25555: PUSH
25556: EMPTY
25557: LIST
25558: LIST
25559: LIST
25560: LIST
25561: LIST
25562: LIST
25563: PUSH
25564: EMPTY
25565: LIST
25566: LIST
25567: LIST
25568: PUSH
25569: LD_VAR 0 12
25573: ARRAY
25574: ST_TO_ADDR
// for i in list do
25575: LD_ADDR_VAR 0 8
25579: PUSH
25580: LD_VAR 0 5
25584: PUSH
25585: FOR_IN
25586: IFFALSE 25619
// if not i in fac_list then
25588: LD_VAR 0 8
25592: PUSH
25593: LD_VAR 0 17
25597: IN
25598: NOT
25599: IFFALSE 25617
// list := list diff i ;
25601: LD_ADDR_VAR 0 5
25605: PUSH
25606: LD_VAR 0 5
25610: PUSH
25611: LD_VAR 0 8
25615: DIFF
25616: ST_TO_ADDR
25617: GO 25585
25619: POP
25620: POP
// if not list then
25621: LD_VAR 0 5
25625: NOT
25626: IFFALSE 25630
// exit ;
25628: GO 26434
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25630: LD_VAR 0 12
25634: PUSH
25635: LD_INT 3
25637: EQUAL
25638: PUSH
25639: LD_INT 49
25641: PUSH
25642: LD_VAR 0 5
25646: IN
25647: AND
25648: PUSH
25649: LD_INT 31
25651: PPUSH
25652: LD_VAR 0 16
25656: PPUSH
25657: CALL_OW 321
25661: PUSH
25662: LD_INT 2
25664: EQUAL
25665: AND
25666: IFFALSE 25726
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25668: LD_INT 22
25670: PUSH
25671: LD_VAR 0 16
25675: PUSH
25676: EMPTY
25677: LIST
25678: LIST
25679: PUSH
25680: LD_INT 35
25682: PUSH
25683: LD_INT 49
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: PUSH
25690: LD_INT 91
25692: PUSH
25693: LD_VAR 0 1
25697: PUSH
25698: LD_INT 10
25700: PUSH
25701: EMPTY
25702: LIST
25703: LIST
25704: LIST
25705: PUSH
25706: EMPTY
25707: LIST
25708: LIST
25709: LIST
25710: PPUSH
25711: CALL_OW 69
25715: NOT
25716: IFFALSE 25726
// weapon := ru_time_lapser ;
25718: LD_ADDR_VAR 0 18
25722: PUSH
25723: LD_INT 49
25725: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25726: LD_VAR 0 12
25730: PUSH
25731: LD_INT 1
25733: PUSH
25734: LD_INT 2
25736: PUSH
25737: EMPTY
25738: LIST
25739: LIST
25740: IN
25741: PUSH
25742: LD_INT 11
25744: PUSH
25745: LD_VAR 0 5
25749: IN
25750: PUSH
25751: LD_INT 30
25753: PUSH
25754: LD_VAR 0 5
25758: IN
25759: OR
25760: AND
25761: PUSH
25762: LD_INT 6
25764: PPUSH
25765: LD_VAR 0 16
25769: PPUSH
25770: CALL_OW 321
25774: PUSH
25775: LD_INT 2
25777: EQUAL
25778: AND
25779: IFFALSE 25944
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25781: LD_INT 22
25783: PUSH
25784: LD_VAR 0 16
25788: PUSH
25789: EMPTY
25790: LIST
25791: LIST
25792: PUSH
25793: LD_INT 2
25795: PUSH
25796: LD_INT 35
25798: PUSH
25799: LD_INT 11
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: LD_INT 35
25808: PUSH
25809: LD_INT 30
25811: PUSH
25812: EMPTY
25813: LIST
25814: LIST
25815: PUSH
25816: EMPTY
25817: LIST
25818: LIST
25819: LIST
25820: PUSH
25821: LD_INT 91
25823: PUSH
25824: LD_VAR 0 1
25828: PUSH
25829: LD_INT 18
25831: PUSH
25832: EMPTY
25833: LIST
25834: LIST
25835: LIST
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: LIST
25841: PPUSH
25842: CALL_OW 69
25846: NOT
25847: PUSH
25848: LD_INT 22
25850: PUSH
25851: LD_VAR 0 16
25855: PUSH
25856: EMPTY
25857: LIST
25858: LIST
25859: PUSH
25860: LD_INT 2
25862: PUSH
25863: LD_INT 30
25865: PUSH
25866: LD_INT 32
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: PUSH
25873: LD_INT 30
25875: PUSH
25876: LD_INT 33
25878: PUSH
25879: EMPTY
25880: LIST
25881: LIST
25882: PUSH
25883: EMPTY
25884: LIST
25885: LIST
25886: LIST
25887: PUSH
25888: LD_INT 91
25890: PUSH
25891: LD_VAR 0 1
25895: PUSH
25896: LD_INT 12
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: LIST
25908: PUSH
25909: EMPTY
25910: LIST
25911: PPUSH
25912: CALL_OW 69
25916: PUSH
25917: LD_INT 2
25919: GREATER
25920: AND
25921: IFFALSE 25944
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25923: LD_ADDR_VAR 0 18
25927: PUSH
25928: LD_INT 11
25930: PUSH
25931: LD_INT 30
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: PUSH
25938: LD_VAR 0 12
25942: ARRAY
25943: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25944: LD_VAR 0 18
25948: NOT
25949: PUSH
25950: LD_INT 40
25952: PPUSH
25953: LD_VAR 0 16
25957: PPUSH
25958: CALL_OW 321
25962: PUSH
25963: LD_INT 2
25965: EQUAL
25966: AND
25967: PUSH
25968: LD_INT 7
25970: PUSH
25971: LD_VAR 0 5
25975: IN
25976: PUSH
25977: LD_INT 28
25979: PUSH
25980: LD_VAR 0 5
25984: IN
25985: OR
25986: PUSH
25987: LD_INT 45
25989: PUSH
25990: LD_VAR 0 5
25994: IN
25995: OR
25996: AND
25997: IFFALSE 26251
// begin hex := GetHexInfo ( x , y ) ;
25999: LD_ADDR_VAR 0 4
26003: PUSH
26004: LD_VAR 0 10
26008: PPUSH
26009: LD_VAR 0 11
26013: PPUSH
26014: CALL_OW 546
26018: ST_TO_ADDR
// if hex [ 1 ] then
26019: LD_VAR 0 4
26023: PUSH
26024: LD_INT 1
26026: ARRAY
26027: IFFALSE 26031
// exit ;
26029: GO 26434
// height := hex [ 2 ] ;
26031: LD_ADDR_VAR 0 15
26035: PUSH
26036: LD_VAR 0 4
26040: PUSH
26041: LD_INT 2
26043: ARRAY
26044: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26045: LD_ADDR_VAR 0 14
26049: PUSH
26050: LD_INT 0
26052: PUSH
26053: LD_INT 2
26055: PUSH
26056: LD_INT 3
26058: PUSH
26059: LD_INT 5
26061: PUSH
26062: EMPTY
26063: LIST
26064: LIST
26065: LIST
26066: LIST
26067: ST_TO_ADDR
// for i in tmp do
26068: LD_ADDR_VAR 0 8
26072: PUSH
26073: LD_VAR 0 14
26077: PUSH
26078: FOR_IN
26079: IFFALSE 26249
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26081: LD_ADDR_VAR 0 9
26085: PUSH
26086: LD_VAR 0 10
26090: PPUSH
26091: LD_VAR 0 8
26095: PPUSH
26096: LD_INT 5
26098: PPUSH
26099: CALL_OW 272
26103: PUSH
26104: LD_VAR 0 11
26108: PPUSH
26109: LD_VAR 0 8
26113: PPUSH
26114: LD_INT 5
26116: PPUSH
26117: CALL_OW 273
26121: PUSH
26122: EMPTY
26123: LIST
26124: LIST
26125: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26126: LD_VAR 0 9
26130: PUSH
26131: LD_INT 1
26133: ARRAY
26134: PPUSH
26135: LD_VAR 0 9
26139: PUSH
26140: LD_INT 2
26142: ARRAY
26143: PPUSH
26144: CALL_OW 488
26148: IFFALSE 26247
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26150: LD_ADDR_VAR 0 4
26154: PUSH
26155: LD_VAR 0 9
26159: PUSH
26160: LD_INT 1
26162: ARRAY
26163: PPUSH
26164: LD_VAR 0 9
26168: PUSH
26169: LD_INT 2
26171: ARRAY
26172: PPUSH
26173: CALL_OW 546
26177: ST_TO_ADDR
// if hex [ 1 ] then
26178: LD_VAR 0 4
26182: PUSH
26183: LD_INT 1
26185: ARRAY
26186: IFFALSE 26190
// continue ;
26188: GO 26078
// h := hex [ 2 ] ;
26190: LD_ADDR_VAR 0 13
26194: PUSH
26195: LD_VAR 0 4
26199: PUSH
26200: LD_INT 2
26202: ARRAY
26203: ST_TO_ADDR
// if h + 7 < height then
26204: LD_VAR 0 13
26208: PUSH
26209: LD_INT 7
26211: PLUS
26212: PUSH
26213: LD_VAR 0 15
26217: LESS
26218: IFFALSE 26247
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26220: LD_ADDR_VAR 0 18
26224: PUSH
26225: LD_INT 7
26227: PUSH
26228: LD_INT 28
26230: PUSH
26231: LD_INT 45
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: LIST
26238: PUSH
26239: LD_VAR 0 12
26243: ARRAY
26244: ST_TO_ADDR
// break ;
26245: GO 26249
// end ; end ; end ;
26247: GO 26078
26249: POP
26250: POP
// end ; if not weapon then
26251: LD_VAR 0 18
26255: NOT
26256: IFFALSE 26316
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26258: LD_ADDR_VAR 0 5
26262: PUSH
26263: LD_VAR 0 5
26267: PUSH
26268: LD_INT 11
26270: PUSH
26271: LD_INT 30
26273: PUSH
26274: LD_INT 49
26276: PUSH
26277: EMPTY
26278: LIST
26279: LIST
26280: LIST
26281: DIFF
26282: ST_TO_ADDR
// if not list then
26283: LD_VAR 0 5
26287: NOT
26288: IFFALSE 26292
// exit ;
26290: GO 26434
// weapon := list [ rand ( 1 , list ) ] ;
26292: LD_ADDR_VAR 0 18
26296: PUSH
26297: LD_VAR 0 5
26301: PUSH
26302: LD_INT 1
26304: PPUSH
26305: LD_VAR 0 5
26309: PPUSH
26310: CALL_OW 12
26314: ARRAY
26315: ST_TO_ADDR
// end ; if weapon then
26316: LD_VAR 0 18
26320: IFFALSE 26434
// begin tmp := CostOfWeapon ( weapon ) ;
26322: LD_ADDR_VAR 0 14
26326: PUSH
26327: LD_VAR 0 18
26331: PPUSH
26332: CALL_OW 451
26336: ST_TO_ADDR
// j := GetBase ( tower ) ;
26337: LD_ADDR_VAR 0 9
26341: PUSH
26342: LD_VAR 0 1
26346: PPUSH
26347: CALL_OW 274
26351: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26352: LD_VAR 0 9
26356: PPUSH
26357: LD_INT 1
26359: PPUSH
26360: CALL_OW 275
26364: PUSH
26365: LD_VAR 0 14
26369: PUSH
26370: LD_INT 1
26372: ARRAY
26373: GREATEREQUAL
26374: PUSH
26375: LD_VAR 0 9
26379: PPUSH
26380: LD_INT 2
26382: PPUSH
26383: CALL_OW 275
26387: PUSH
26388: LD_VAR 0 14
26392: PUSH
26393: LD_INT 2
26395: ARRAY
26396: GREATEREQUAL
26397: AND
26398: PUSH
26399: LD_VAR 0 9
26403: PPUSH
26404: LD_INT 3
26406: PPUSH
26407: CALL_OW 275
26411: PUSH
26412: LD_VAR 0 14
26416: PUSH
26417: LD_INT 3
26419: ARRAY
26420: GREATEREQUAL
26421: AND
26422: IFFALSE 26434
// result := weapon ;
26424: LD_ADDR_VAR 0 3
26428: PUSH
26429: LD_VAR 0 18
26433: ST_TO_ADDR
// end ; end ;
26434: LD_VAR 0 3
26438: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26439: LD_INT 0
26441: PPUSH
26442: PPUSH
// result := true ;
26443: LD_ADDR_VAR 0 3
26447: PUSH
26448: LD_INT 1
26450: ST_TO_ADDR
// if array1 = array2 then
26451: LD_VAR 0 1
26455: PUSH
26456: LD_VAR 0 2
26460: EQUAL
26461: IFFALSE 26521
// begin for i = 1 to array1 do
26463: LD_ADDR_VAR 0 4
26467: PUSH
26468: DOUBLE
26469: LD_INT 1
26471: DEC
26472: ST_TO_ADDR
26473: LD_VAR 0 1
26477: PUSH
26478: FOR_TO
26479: IFFALSE 26517
// if array1 [ i ] <> array2 [ i ] then
26481: LD_VAR 0 1
26485: PUSH
26486: LD_VAR 0 4
26490: ARRAY
26491: PUSH
26492: LD_VAR 0 2
26496: PUSH
26497: LD_VAR 0 4
26501: ARRAY
26502: NONEQUAL
26503: IFFALSE 26515
// begin result := false ;
26505: LD_ADDR_VAR 0 3
26509: PUSH
26510: LD_INT 0
26512: ST_TO_ADDR
// break ;
26513: GO 26517
// end ;
26515: GO 26478
26517: POP
26518: POP
// end else
26519: GO 26529
// result := false ;
26521: LD_ADDR_VAR 0 3
26525: PUSH
26526: LD_INT 0
26528: ST_TO_ADDR
// end ;
26529: LD_VAR 0 3
26533: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26534: LD_INT 0
26536: PPUSH
26537: PPUSH
26538: PPUSH
// pom := GetBase ( fac ) ;
26539: LD_ADDR_VAR 0 5
26543: PUSH
26544: LD_VAR 0 1
26548: PPUSH
26549: CALL_OW 274
26553: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26554: LD_ADDR_VAR 0 4
26558: PUSH
26559: LD_VAR 0 2
26563: PUSH
26564: LD_INT 1
26566: ARRAY
26567: PPUSH
26568: LD_VAR 0 2
26572: PUSH
26573: LD_INT 2
26575: ARRAY
26576: PPUSH
26577: LD_VAR 0 2
26581: PUSH
26582: LD_INT 3
26584: ARRAY
26585: PPUSH
26586: LD_VAR 0 2
26590: PUSH
26591: LD_INT 4
26593: ARRAY
26594: PPUSH
26595: CALL_OW 449
26599: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26600: LD_ADDR_VAR 0 3
26604: PUSH
26605: LD_VAR 0 5
26609: PPUSH
26610: LD_INT 1
26612: PPUSH
26613: CALL_OW 275
26617: PUSH
26618: LD_VAR 0 4
26622: PUSH
26623: LD_INT 1
26625: ARRAY
26626: GREATEREQUAL
26627: PUSH
26628: LD_VAR 0 5
26632: PPUSH
26633: LD_INT 2
26635: PPUSH
26636: CALL_OW 275
26640: PUSH
26641: LD_VAR 0 4
26645: PUSH
26646: LD_INT 2
26648: ARRAY
26649: GREATEREQUAL
26650: AND
26651: PUSH
26652: LD_VAR 0 5
26656: PPUSH
26657: LD_INT 3
26659: PPUSH
26660: CALL_OW 275
26664: PUSH
26665: LD_VAR 0 4
26669: PUSH
26670: LD_INT 3
26672: ARRAY
26673: GREATEREQUAL
26674: AND
26675: ST_TO_ADDR
// end ;
26676: LD_VAR 0 3
26680: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26681: LD_INT 0
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
// pom := GetBase ( building ) ;
26687: LD_ADDR_VAR 0 3
26691: PUSH
26692: LD_VAR 0 1
26696: PPUSH
26697: CALL_OW 274
26701: ST_TO_ADDR
// if not pom then
26702: LD_VAR 0 3
26706: NOT
26707: IFFALSE 26711
// exit ;
26709: GO 26881
// btype := GetBType ( building ) ;
26711: LD_ADDR_VAR 0 5
26715: PUSH
26716: LD_VAR 0 1
26720: PPUSH
26721: CALL_OW 266
26725: ST_TO_ADDR
// if btype = b_armoury then
26726: LD_VAR 0 5
26730: PUSH
26731: LD_INT 4
26733: EQUAL
26734: IFFALSE 26744
// btype := b_barracks ;
26736: LD_ADDR_VAR 0 5
26740: PUSH
26741: LD_INT 5
26743: ST_TO_ADDR
// if btype = b_depot then
26744: LD_VAR 0 5
26748: PUSH
26749: LD_INT 0
26751: EQUAL
26752: IFFALSE 26762
// btype := b_warehouse ;
26754: LD_ADDR_VAR 0 5
26758: PUSH
26759: LD_INT 1
26761: ST_TO_ADDR
// if btype = b_workshop then
26762: LD_VAR 0 5
26766: PUSH
26767: LD_INT 2
26769: EQUAL
26770: IFFALSE 26780
// btype := b_factory ;
26772: LD_ADDR_VAR 0 5
26776: PUSH
26777: LD_INT 3
26779: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26780: LD_ADDR_VAR 0 4
26784: PUSH
26785: LD_VAR 0 5
26789: PPUSH
26790: LD_VAR 0 1
26794: PPUSH
26795: CALL_OW 248
26799: PPUSH
26800: CALL_OW 450
26804: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26805: LD_ADDR_VAR 0 2
26809: PUSH
26810: LD_VAR 0 3
26814: PPUSH
26815: LD_INT 1
26817: PPUSH
26818: CALL_OW 275
26822: PUSH
26823: LD_VAR 0 4
26827: PUSH
26828: LD_INT 1
26830: ARRAY
26831: GREATEREQUAL
26832: PUSH
26833: LD_VAR 0 3
26837: PPUSH
26838: LD_INT 2
26840: PPUSH
26841: CALL_OW 275
26845: PUSH
26846: LD_VAR 0 4
26850: PUSH
26851: LD_INT 2
26853: ARRAY
26854: GREATEREQUAL
26855: AND
26856: PUSH
26857: LD_VAR 0 3
26861: PPUSH
26862: LD_INT 3
26864: PPUSH
26865: CALL_OW 275
26869: PUSH
26870: LD_VAR 0 4
26874: PUSH
26875: LD_INT 3
26877: ARRAY
26878: GREATEREQUAL
26879: AND
26880: ST_TO_ADDR
// end ;
26881: LD_VAR 0 2
26885: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26886: LD_INT 0
26888: PPUSH
26889: PPUSH
26890: PPUSH
// pom := GetBase ( building ) ;
26891: LD_ADDR_VAR 0 4
26895: PUSH
26896: LD_VAR 0 1
26900: PPUSH
26901: CALL_OW 274
26905: ST_TO_ADDR
// if not pom then
26906: LD_VAR 0 4
26910: NOT
26911: IFFALSE 26915
// exit ;
26913: GO 27016
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26915: LD_ADDR_VAR 0 5
26919: PUSH
26920: LD_VAR 0 2
26924: PPUSH
26925: LD_VAR 0 1
26929: PPUSH
26930: CALL_OW 248
26934: PPUSH
26935: CALL_OW 450
26939: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26940: LD_ADDR_VAR 0 3
26944: PUSH
26945: LD_VAR 0 4
26949: PPUSH
26950: LD_INT 1
26952: PPUSH
26953: CALL_OW 275
26957: PUSH
26958: LD_VAR 0 5
26962: PUSH
26963: LD_INT 1
26965: ARRAY
26966: GREATEREQUAL
26967: PUSH
26968: LD_VAR 0 4
26972: PPUSH
26973: LD_INT 2
26975: PPUSH
26976: CALL_OW 275
26980: PUSH
26981: LD_VAR 0 5
26985: PUSH
26986: LD_INT 2
26988: ARRAY
26989: GREATEREQUAL
26990: AND
26991: PUSH
26992: LD_VAR 0 4
26996: PPUSH
26997: LD_INT 3
26999: PPUSH
27000: CALL_OW 275
27004: PUSH
27005: LD_VAR 0 5
27009: PUSH
27010: LD_INT 3
27012: ARRAY
27013: GREATEREQUAL
27014: AND
27015: ST_TO_ADDR
// end ;
27016: LD_VAR 0 3
27020: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27021: LD_INT 0
27023: PPUSH
27024: PPUSH
27025: PPUSH
27026: PPUSH
27027: PPUSH
27028: PPUSH
27029: PPUSH
27030: PPUSH
27031: PPUSH
27032: PPUSH
// result := false ;
27033: LD_ADDR_VAR 0 6
27037: PUSH
27038: LD_INT 0
27040: ST_TO_ADDR
// if not base or not btype or not x or not y then
27041: LD_VAR 0 1
27045: NOT
27046: PUSH
27047: LD_VAR 0 2
27051: NOT
27052: OR
27053: PUSH
27054: LD_VAR 0 3
27058: NOT
27059: OR
27060: PUSH
27061: LD_VAR 0 4
27065: NOT
27066: OR
27067: IFFALSE 27071
// exit ;
27069: GO 27662
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27071: LD_ADDR_VAR 0 12
27075: PUSH
27076: LD_VAR 0 2
27080: PPUSH
27081: LD_VAR 0 3
27085: PPUSH
27086: LD_VAR 0 4
27090: PPUSH
27091: LD_VAR 0 5
27095: PPUSH
27096: LD_VAR 0 1
27100: PUSH
27101: LD_INT 1
27103: ARRAY
27104: PPUSH
27105: CALL_OW 248
27109: PPUSH
27110: LD_INT 0
27112: PPUSH
27113: CALL 28499 0 6
27117: ST_TO_ADDR
// if not hexes then
27118: LD_VAR 0 12
27122: NOT
27123: IFFALSE 27127
// exit ;
27125: GO 27662
// for i = 1 to hexes do
27127: LD_ADDR_VAR 0 7
27131: PUSH
27132: DOUBLE
27133: LD_INT 1
27135: DEC
27136: ST_TO_ADDR
27137: LD_VAR 0 12
27141: PUSH
27142: FOR_TO
27143: IFFALSE 27660
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27145: LD_ADDR_VAR 0 11
27149: PUSH
27150: LD_VAR 0 12
27154: PUSH
27155: LD_VAR 0 7
27159: ARRAY
27160: PUSH
27161: LD_INT 1
27163: ARRAY
27164: PPUSH
27165: LD_VAR 0 12
27169: PUSH
27170: LD_VAR 0 7
27174: ARRAY
27175: PUSH
27176: LD_INT 2
27178: ARRAY
27179: PPUSH
27180: CALL_OW 428
27184: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27185: LD_VAR 0 12
27189: PUSH
27190: LD_VAR 0 7
27194: ARRAY
27195: PUSH
27196: LD_INT 1
27198: ARRAY
27199: PPUSH
27200: LD_VAR 0 12
27204: PUSH
27205: LD_VAR 0 7
27209: ARRAY
27210: PUSH
27211: LD_INT 2
27213: ARRAY
27214: PPUSH
27215: CALL_OW 351
27219: PUSH
27220: LD_VAR 0 12
27224: PUSH
27225: LD_VAR 0 7
27229: ARRAY
27230: PUSH
27231: LD_INT 1
27233: ARRAY
27234: PPUSH
27235: LD_VAR 0 12
27239: PUSH
27240: LD_VAR 0 7
27244: ARRAY
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: PPUSH
27250: CALL_OW 488
27254: NOT
27255: OR
27256: PUSH
27257: LD_VAR 0 11
27261: PPUSH
27262: CALL_OW 247
27266: PUSH
27267: LD_INT 3
27269: EQUAL
27270: OR
27271: IFFALSE 27277
// exit ;
27273: POP
27274: POP
27275: GO 27662
// if not tmp then
27277: LD_VAR 0 11
27281: NOT
27282: IFFALSE 27286
// continue ;
27284: GO 27142
// result := true ;
27286: LD_ADDR_VAR 0 6
27290: PUSH
27291: LD_INT 1
27293: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27294: LD_ADDR_VAR 0 15
27298: PUSH
27299: LD_INT 22
27301: PUSH
27302: LD_VAR 0 11
27306: PPUSH
27307: CALL_OW 255
27311: PUSH
27312: EMPTY
27313: LIST
27314: LIST
27315: PUSH
27316: LD_INT 2
27318: PUSH
27319: LD_INT 30
27321: PUSH
27322: LD_INT 0
27324: PUSH
27325: EMPTY
27326: LIST
27327: LIST
27328: PUSH
27329: LD_INT 30
27331: PUSH
27332: LD_INT 1
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: LIST
27343: PUSH
27344: EMPTY
27345: LIST
27346: LIST
27347: PPUSH
27348: CALL_OW 69
27352: ST_TO_ADDR
// if dep then
27353: LD_VAR 0 15
27357: IFFALSE 27493
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27359: LD_ADDR_VAR 0 14
27363: PUSH
27364: LD_VAR 0 15
27368: PUSH
27369: LD_INT 1
27371: ARRAY
27372: PPUSH
27373: CALL_OW 250
27377: PPUSH
27378: LD_VAR 0 15
27382: PUSH
27383: LD_INT 1
27385: ARRAY
27386: PPUSH
27387: CALL_OW 254
27391: PPUSH
27392: LD_INT 5
27394: PPUSH
27395: CALL_OW 272
27399: PUSH
27400: LD_VAR 0 15
27404: PUSH
27405: LD_INT 1
27407: ARRAY
27408: PPUSH
27409: CALL_OW 251
27413: PPUSH
27414: LD_VAR 0 15
27418: PUSH
27419: LD_INT 1
27421: ARRAY
27422: PPUSH
27423: CALL_OW 254
27427: PPUSH
27428: LD_INT 5
27430: PPUSH
27431: CALL_OW 273
27435: PUSH
27436: EMPTY
27437: LIST
27438: LIST
27439: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27440: LD_VAR 0 14
27444: PUSH
27445: LD_INT 1
27447: ARRAY
27448: PPUSH
27449: LD_VAR 0 14
27453: PUSH
27454: LD_INT 2
27456: ARRAY
27457: PPUSH
27458: CALL_OW 488
27462: IFFALSE 27493
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27464: LD_VAR 0 11
27468: PPUSH
27469: LD_VAR 0 14
27473: PUSH
27474: LD_INT 1
27476: ARRAY
27477: PPUSH
27478: LD_VAR 0 14
27482: PUSH
27483: LD_INT 2
27485: ARRAY
27486: PPUSH
27487: CALL_OW 111
// continue ;
27491: GO 27142
// end ; end ; r := GetDir ( tmp ) ;
27493: LD_ADDR_VAR 0 13
27497: PUSH
27498: LD_VAR 0 11
27502: PPUSH
27503: CALL_OW 254
27507: ST_TO_ADDR
// if r = 5 then
27508: LD_VAR 0 13
27512: PUSH
27513: LD_INT 5
27515: EQUAL
27516: IFFALSE 27526
// r := 0 ;
27518: LD_ADDR_VAR 0 13
27522: PUSH
27523: LD_INT 0
27525: ST_TO_ADDR
// for j = r to 5 do
27526: LD_ADDR_VAR 0 8
27530: PUSH
27531: DOUBLE
27532: LD_VAR 0 13
27536: DEC
27537: ST_TO_ADDR
27538: LD_INT 5
27540: PUSH
27541: FOR_TO
27542: IFFALSE 27656
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27544: LD_ADDR_VAR 0 9
27548: PUSH
27549: LD_VAR 0 11
27553: PPUSH
27554: CALL_OW 250
27558: PPUSH
27559: LD_VAR 0 8
27563: PPUSH
27564: LD_INT 2
27566: PPUSH
27567: CALL_OW 272
27571: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27572: LD_ADDR_VAR 0 10
27576: PUSH
27577: LD_VAR 0 11
27581: PPUSH
27582: CALL_OW 251
27586: PPUSH
27587: LD_VAR 0 8
27591: PPUSH
27592: LD_INT 2
27594: PPUSH
27595: CALL_OW 273
27599: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27600: LD_VAR 0 9
27604: PPUSH
27605: LD_VAR 0 10
27609: PPUSH
27610: CALL_OW 488
27614: PUSH
27615: LD_VAR 0 9
27619: PPUSH
27620: LD_VAR 0 10
27624: PPUSH
27625: CALL_OW 428
27629: NOT
27630: AND
27631: IFFALSE 27654
// begin ComMoveXY ( tmp , _x , _y ) ;
27633: LD_VAR 0 11
27637: PPUSH
27638: LD_VAR 0 9
27642: PPUSH
27643: LD_VAR 0 10
27647: PPUSH
27648: CALL_OW 111
// break ;
27652: GO 27656
// end ; end ;
27654: GO 27541
27656: POP
27657: POP
// end ;
27658: GO 27142
27660: POP
27661: POP
// end ;
27662: LD_VAR 0 6
27666: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27667: LD_INT 0
27669: PPUSH
27670: PPUSH
27671: PPUSH
27672: PPUSH
27673: PPUSH
27674: PPUSH
27675: PPUSH
27676: PPUSH
27677: PPUSH
27678: PPUSH
// result := false ;
27679: LD_ADDR_VAR 0 6
27683: PUSH
27684: LD_INT 0
27686: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27687: LD_VAR 0 1
27691: NOT
27692: PUSH
27693: LD_VAR 0 1
27697: PPUSH
27698: CALL_OW 266
27702: PUSH
27703: LD_INT 0
27705: PUSH
27706: LD_INT 1
27708: PUSH
27709: EMPTY
27710: LIST
27711: LIST
27712: IN
27713: NOT
27714: OR
27715: PUSH
27716: LD_VAR 0 2
27720: NOT
27721: OR
27722: PUSH
27723: LD_VAR 0 5
27727: PUSH
27728: LD_INT 0
27730: PUSH
27731: LD_INT 1
27733: PUSH
27734: LD_INT 2
27736: PUSH
27737: LD_INT 3
27739: PUSH
27740: LD_INT 4
27742: PUSH
27743: LD_INT 5
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: IN
27754: NOT
27755: OR
27756: PUSH
27757: LD_VAR 0 3
27761: PPUSH
27762: LD_VAR 0 4
27766: PPUSH
27767: CALL_OW 488
27771: NOT
27772: OR
27773: IFFALSE 27777
// exit ;
27775: GO 28494
// pom := GetBase ( bdepot ) ;
27777: LD_ADDR_VAR 0 10
27781: PUSH
27782: LD_VAR 0 1
27786: PPUSH
27787: CALL_OW 274
27791: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
27792: LD_ADDR_VAR 0 11
27796: PUSH
27797: LD_VAR 0 2
27801: PPUSH
27802: LD_VAR 0 1
27806: PPUSH
27807: CALL_OW 248
27811: PPUSH
27812: CALL_OW 450
27816: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27817: LD_VAR 0 10
27821: PPUSH
27822: LD_INT 1
27824: PPUSH
27825: CALL_OW 275
27829: PUSH
27830: LD_VAR 0 11
27834: PUSH
27835: LD_INT 1
27837: ARRAY
27838: GREATEREQUAL
27839: PUSH
27840: LD_VAR 0 10
27844: PPUSH
27845: LD_INT 2
27847: PPUSH
27848: CALL_OW 275
27852: PUSH
27853: LD_VAR 0 11
27857: PUSH
27858: LD_INT 2
27860: ARRAY
27861: GREATEREQUAL
27862: AND
27863: PUSH
27864: LD_VAR 0 10
27868: PPUSH
27869: LD_INT 3
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_VAR 0 11
27881: PUSH
27882: LD_INT 3
27884: ARRAY
27885: GREATEREQUAL
27886: AND
27887: NOT
27888: IFFALSE 27892
// exit ;
27890: GO 28494
// if GetBType ( bdepot ) = b_depot then
27892: LD_VAR 0 1
27896: PPUSH
27897: CALL_OW 266
27901: PUSH
27902: LD_INT 0
27904: EQUAL
27905: IFFALSE 27917
// dist := 28 else
27907: LD_ADDR_VAR 0 14
27911: PUSH
27912: LD_INT 28
27914: ST_TO_ADDR
27915: GO 27925
// dist := 36 ;
27917: LD_ADDR_VAR 0 14
27921: PUSH
27922: LD_INT 36
27924: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
27925: LD_VAR 0 1
27929: PPUSH
27930: LD_VAR 0 3
27934: PPUSH
27935: LD_VAR 0 4
27939: PPUSH
27940: CALL_OW 297
27944: PUSH
27945: LD_VAR 0 14
27949: GREATER
27950: IFFALSE 27954
// exit ;
27952: GO 28494
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
27954: LD_ADDR_VAR 0 12
27958: PUSH
27959: LD_VAR 0 2
27963: PPUSH
27964: LD_VAR 0 3
27968: PPUSH
27969: LD_VAR 0 4
27973: PPUSH
27974: LD_VAR 0 5
27978: PPUSH
27979: LD_VAR 0 1
27983: PPUSH
27984: CALL_OW 248
27988: PPUSH
27989: LD_INT 0
27991: PPUSH
27992: CALL 28499 0 6
27996: ST_TO_ADDR
// if not hexes then
27997: LD_VAR 0 12
28001: NOT
28002: IFFALSE 28006
// exit ;
28004: GO 28494
// hex := GetHexInfo ( x , y ) ;
28006: LD_ADDR_VAR 0 15
28010: PUSH
28011: LD_VAR 0 3
28015: PPUSH
28016: LD_VAR 0 4
28020: PPUSH
28021: CALL_OW 546
28025: ST_TO_ADDR
// if hex [ 1 ] then
28026: LD_VAR 0 15
28030: PUSH
28031: LD_INT 1
28033: ARRAY
28034: IFFALSE 28038
// exit ;
28036: GO 28494
// height := hex [ 2 ] ;
28038: LD_ADDR_VAR 0 13
28042: PUSH
28043: LD_VAR 0 15
28047: PUSH
28048: LD_INT 2
28050: ARRAY
28051: ST_TO_ADDR
// for i = 1 to hexes do
28052: LD_ADDR_VAR 0 7
28056: PUSH
28057: DOUBLE
28058: LD_INT 1
28060: DEC
28061: ST_TO_ADDR
28062: LD_VAR 0 12
28066: PUSH
28067: FOR_TO
28068: IFFALSE 28398
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28070: LD_VAR 0 12
28074: PUSH
28075: LD_VAR 0 7
28079: ARRAY
28080: PUSH
28081: LD_INT 1
28083: ARRAY
28084: PPUSH
28085: LD_VAR 0 12
28089: PUSH
28090: LD_VAR 0 7
28094: ARRAY
28095: PUSH
28096: LD_INT 2
28098: ARRAY
28099: PPUSH
28100: CALL_OW 488
28104: NOT
28105: PUSH
28106: LD_VAR 0 12
28110: PUSH
28111: LD_VAR 0 7
28115: ARRAY
28116: PUSH
28117: LD_INT 1
28119: ARRAY
28120: PPUSH
28121: LD_VAR 0 12
28125: PUSH
28126: LD_VAR 0 7
28130: ARRAY
28131: PUSH
28132: LD_INT 2
28134: ARRAY
28135: PPUSH
28136: CALL_OW 428
28140: PUSH
28141: LD_INT 0
28143: GREATER
28144: OR
28145: PUSH
28146: LD_VAR 0 12
28150: PUSH
28151: LD_VAR 0 7
28155: ARRAY
28156: PUSH
28157: LD_INT 1
28159: ARRAY
28160: PPUSH
28161: LD_VAR 0 12
28165: PUSH
28166: LD_VAR 0 7
28170: ARRAY
28171: PUSH
28172: LD_INT 2
28174: ARRAY
28175: PPUSH
28176: CALL_OW 351
28180: OR
28181: IFFALSE 28187
// exit ;
28183: POP
28184: POP
28185: GO 28494
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28187: LD_ADDR_VAR 0 8
28191: PUSH
28192: LD_VAR 0 12
28196: PUSH
28197: LD_VAR 0 7
28201: ARRAY
28202: PUSH
28203: LD_INT 1
28205: ARRAY
28206: PPUSH
28207: LD_VAR 0 12
28211: PUSH
28212: LD_VAR 0 7
28216: ARRAY
28217: PUSH
28218: LD_INT 2
28220: ARRAY
28221: PPUSH
28222: CALL_OW 546
28226: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28227: LD_VAR 0 8
28231: PUSH
28232: LD_INT 1
28234: ARRAY
28235: PUSH
28236: LD_VAR 0 8
28240: PUSH
28241: LD_INT 2
28243: ARRAY
28244: PUSH
28245: LD_VAR 0 13
28249: PUSH
28250: LD_INT 2
28252: PLUS
28253: GREATER
28254: OR
28255: PUSH
28256: LD_VAR 0 8
28260: PUSH
28261: LD_INT 2
28263: ARRAY
28264: PUSH
28265: LD_VAR 0 13
28269: PUSH
28270: LD_INT 2
28272: MINUS
28273: LESS
28274: OR
28275: PUSH
28276: LD_VAR 0 8
28280: PUSH
28281: LD_INT 3
28283: ARRAY
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: LD_INT 8
28290: PUSH
28291: LD_INT 9
28293: PUSH
28294: LD_INT 10
28296: PUSH
28297: LD_INT 11
28299: PUSH
28300: LD_INT 12
28302: PUSH
28303: LD_INT 13
28305: PUSH
28306: LD_INT 16
28308: PUSH
28309: LD_INT 17
28311: PUSH
28312: LD_INT 18
28314: PUSH
28315: LD_INT 19
28317: PUSH
28318: LD_INT 20
28320: PUSH
28321: LD_INT 21
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: LIST
28328: LIST
28329: LIST
28330: LIST
28331: LIST
28332: LIST
28333: LIST
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: IN
28339: NOT
28340: OR
28341: PUSH
28342: LD_VAR 0 8
28346: PUSH
28347: LD_INT 5
28349: ARRAY
28350: NOT
28351: OR
28352: PUSH
28353: LD_VAR 0 8
28357: PUSH
28358: LD_INT 6
28360: ARRAY
28361: PUSH
28362: LD_INT 1
28364: PUSH
28365: LD_INT 2
28367: PUSH
28368: LD_INT 7
28370: PUSH
28371: LD_INT 9
28373: PUSH
28374: LD_INT 10
28376: PUSH
28377: LD_INT 11
28379: PUSH
28380: EMPTY
28381: LIST
28382: LIST
28383: LIST
28384: LIST
28385: LIST
28386: LIST
28387: IN
28388: NOT
28389: OR
28390: IFFALSE 28396
// exit ;
28392: POP
28393: POP
28394: GO 28494
// end ;
28396: GO 28067
28398: POP
28399: POP
// side := GetSide ( bdepot ) ;
28400: LD_ADDR_VAR 0 9
28404: PUSH
28405: LD_VAR 0 1
28409: PPUSH
28410: CALL_OW 255
28414: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28415: LD_VAR 0 9
28419: PPUSH
28420: LD_VAR 0 3
28424: PPUSH
28425: LD_VAR 0 4
28429: PPUSH
28430: LD_INT 20
28432: PPUSH
28433: CALL 21166 0 4
28437: PUSH
28438: LD_INT 4
28440: ARRAY
28441: IFFALSE 28445
// exit ;
28443: GO 28494
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28445: LD_VAR 0 2
28449: PUSH
28450: LD_INT 29
28452: PUSH
28453: LD_INT 30
28455: PUSH
28456: EMPTY
28457: LIST
28458: LIST
28459: IN
28460: PUSH
28461: LD_VAR 0 3
28465: PPUSH
28466: LD_VAR 0 4
28470: PPUSH
28471: LD_VAR 0 9
28475: PPUSH
28476: CALL_OW 440
28480: NOT
28481: AND
28482: IFFALSE 28486
// exit ;
28484: GO 28494
// result := true ;
28486: LD_ADDR_VAR 0 6
28490: PUSH
28491: LD_INT 1
28493: ST_TO_ADDR
// end ;
28494: LD_VAR 0 6
28498: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28499: LD_INT 0
28501: PPUSH
28502: PPUSH
28503: PPUSH
28504: PPUSH
28505: PPUSH
28506: PPUSH
28507: PPUSH
28508: PPUSH
28509: PPUSH
28510: PPUSH
28511: PPUSH
28512: PPUSH
28513: PPUSH
28514: PPUSH
28515: PPUSH
28516: PPUSH
28517: PPUSH
28518: PPUSH
28519: PPUSH
28520: PPUSH
28521: PPUSH
28522: PPUSH
28523: PPUSH
28524: PPUSH
28525: PPUSH
28526: PPUSH
28527: PPUSH
28528: PPUSH
28529: PPUSH
28530: PPUSH
28531: PPUSH
28532: PPUSH
28533: PPUSH
28534: PPUSH
28535: PPUSH
28536: PPUSH
28537: PPUSH
28538: PPUSH
28539: PPUSH
28540: PPUSH
28541: PPUSH
28542: PPUSH
28543: PPUSH
28544: PPUSH
28545: PPUSH
28546: PPUSH
28547: PPUSH
28548: PPUSH
28549: PPUSH
28550: PPUSH
28551: PPUSH
28552: PPUSH
28553: PPUSH
28554: PPUSH
28555: PPUSH
28556: PPUSH
28557: PPUSH
28558: PPUSH
// result = [ ] ;
28559: LD_ADDR_VAR 0 7
28563: PUSH
28564: EMPTY
28565: ST_TO_ADDR
// temp_list = [ ] ;
28566: LD_ADDR_VAR 0 9
28570: PUSH
28571: EMPTY
28572: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28573: LD_VAR 0 4
28577: PUSH
28578: LD_INT 0
28580: PUSH
28581: LD_INT 1
28583: PUSH
28584: LD_INT 2
28586: PUSH
28587: LD_INT 3
28589: PUSH
28590: LD_INT 4
28592: PUSH
28593: LD_INT 5
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: IN
28604: NOT
28605: PUSH
28606: LD_VAR 0 1
28610: PUSH
28611: LD_INT 0
28613: PUSH
28614: LD_INT 1
28616: PUSH
28617: EMPTY
28618: LIST
28619: LIST
28620: IN
28621: PUSH
28622: LD_VAR 0 5
28626: PUSH
28627: LD_INT 1
28629: PUSH
28630: LD_INT 2
28632: PUSH
28633: LD_INT 3
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: LIST
28640: IN
28641: NOT
28642: AND
28643: OR
28644: IFFALSE 28648
// exit ;
28646: GO 47033
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28648: LD_VAR 0 1
28652: PUSH
28653: LD_INT 6
28655: PUSH
28656: LD_INT 7
28658: PUSH
28659: LD_INT 8
28661: PUSH
28662: LD_INT 13
28664: PUSH
28665: LD_INT 12
28667: PUSH
28668: LD_INT 15
28670: PUSH
28671: LD_INT 11
28673: PUSH
28674: LD_INT 14
28676: PUSH
28677: LD_INT 10
28679: PUSH
28680: EMPTY
28681: LIST
28682: LIST
28683: LIST
28684: LIST
28685: LIST
28686: LIST
28687: LIST
28688: LIST
28689: LIST
28690: IN
28691: IFFALSE 28701
// btype = b_lab ;
28693: LD_ADDR_VAR 0 1
28697: PUSH
28698: LD_INT 6
28700: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28701: LD_VAR 0 6
28705: PUSH
28706: LD_INT 0
28708: PUSH
28709: LD_INT 1
28711: PUSH
28712: LD_INT 2
28714: PUSH
28715: EMPTY
28716: LIST
28717: LIST
28718: LIST
28719: IN
28720: NOT
28721: PUSH
28722: LD_VAR 0 1
28726: PUSH
28727: LD_INT 0
28729: PUSH
28730: LD_INT 1
28732: PUSH
28733: LD_INT 2
28735: PUSH
28736: LD_INT 3
28738: PUSH
28739: LD_INT 6
28741: PUSH
28742: LD_INT 36
28744: PUSH
28745: LD_INT 4
28747: PUSH
28748: LD_INT 5
28750: PUSH
28751: LD_INT 31
28753: PUSH
28754: LD_INT 32
28756: PUSH
28757: LD_INT 33
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: LIST
28764: LIST
28765: LIST
28766: LIST
28767: LIST
28768: LIST
28769: LIST
28770: LIST
28771: LIST
28772: IN
28773: NOT
28774: PUSH
28775: LD_VAR 0 6
28779: PUSH
28780: LD_INT 1
28782: EQUAL
28783: AND
28784: OR
28785: PUSH
28786: LD_VAR 0 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: LD_INT 3
28796: PUSH
28797: EMPTY
28798: LIST
28799: LIST
28800: IN
28801: NOT
28802: PUSH
28803: LD_VAR 0 6
28807: PUSH
28808: LD_INT 2
28810: EQUAL
28811: AND
28812: OR
28813: IFFALSE 28823
// mode = 0 ;
28815: LD_ADDR_VAR 0 6
28819: PUSH
28820: LD_INT 0
28822: ST_TO_ADDR
// case mode of 0 :
28823: LD_VAR 0 6
28827: PUSH
28828: LD_INT 0
28830: DOUBLE
28831: EQUAL
28832: IFTRUE 28836
28834: GO 40289
28836: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28837: LD_ADDR_VAR 0 11
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: LD_INT 0
28847: PUSH
28848: EMPTY
28849: LIST
28850: LIST
28851: PUSH
28852: LD_INT 0
28854: PUSH
28855: LD_INT 1
28857: NEG
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: PUSH
28863: LD_INT 1
28865: PUSH
28866: LD_INT 0
28868: PUSH
28869: EMPTY
28870: LIST
28871: LIST
28872: PUSH
28873: LD_INT 1
28875: PUSH
28876: LD_INT 1
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 0
28885: PUSH
28886: LD_INT 1
28888: PUSH
28889: EMPTY
28890: LIST
28891: LIST
28892: PUSH
28893: LD_INT 1
28895: NEG
28896: PUSH
28897: LD_INT 0
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 1
28906: NEG
28907: PUSH
28908: LD_INT 1
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 1
28918: NEG
28919: PUSH
28920: LD_INT 2
28922: NEG
28923: PUSH
28924: EMPTY
28925: LIST
28926: LIST
28927: PUSH
28928: LD_INT 0
28930: PUSH
28931: LD_INT 2
28933: NEG
28934: PUSH
28935: EMPTY
28936: LIST
28937: LIST
28938: PUSH
28939: LD_INT 1
28941: PUSH
28942: LD_INT 1
28944: NEG
28945: PUSH
28946: EMPTY
28947: LIST
28948: LIST
28949: PUSH
28950: LD_INT 1
28952: PUSH
28953: LD_INT 2
28955: PUSH
28956: EMPTY
28957: LIST
28958: LIST
28959: PUSH
28960: LD_INT 0
28962: PUSH
28963: LD_INT 2
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 1
28972: NEG
28973: PUSH
28974: LD_INT 1
28976: PUSH
28977: EMPTY
28978: LIST
28979: LIST
28980: PUSH
28981: LD_INT 1
28983: PUSH
28984: LD_INT 3
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: LD_INT 0
28993: PUSH
28994: LD_INT 3
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: PUSH
29001: LD_INT 1
29003: NEG
29004: PUSH
29005: LD_INT 2
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29030: LD_ADDR_VAR 0 12
29034: PUSH
29035: LD_INT 0
29037: PUSH
29038: LD_INT 0
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: LD_INT 0
29047: PUSH
29048: LD_INT 1
29050: NEG
29051: PUSH
29052: EMPTY
29053: LIST
29054: LIST
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: LD_INT 0
29061: PUSH
29062: EMPTY
29063: LIST
29064: LIST
29065: PUSH
29066: LD_INT 1
29068: PUSH
29069: LD_INT 1
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 0
29078: PUSH
29079: LD_INT 1
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: PUSH
29086: LD_INT 1
29088: NEG
29089: PUSH
29090: LD_INT 0
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 1
29099: NEG
29100: PUSH
29101: LD_INT 1
29103: NEG
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 2
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 2
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 1
29142: NEG
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 2
29153: NEG
29154: PUSH
29155: LD_INT 0
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 2
29164: NEG
29165: PUSH
29166: LD_INT 1
29168: NEG
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 2
29176: NEG
29177: PUSH
29178: LD_INT 1
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 3
29187: NEG
29188: PUSH
29189: LD_INT 0
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 3
29198: NEG
29199: PUSH
29200: LD_INT 1
29202: NEG
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: PUSH
29208: EMPTY
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29226: LD_ADDR_VAR 0 13
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: LD_INT 0
29236: PUSH
29237: EMPTY
29238: LIST
29239: LIST
29240: PUSH
29241: LD_INT 0
29243: PUSH
29244: LD_INT 1
29246: NEG
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PUSH
29252: LD_INT 1
29254: PUSH
29255: LD_INT 0
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: EMPTY
29269: LIST
29270: LIST
29271: PUSH
29272: LD_INT 0
29274: PUSH
29275: LD_INT 1
29277: PUSH
29278: EMPTY
29279: LIST
29280: LIST
29281: PUSH
29282: LD_INT 1
29284: NEG
29285: PUSH
29286: LD_INT 0
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 1
29295: NEG
29296: PUSH
29297: LD_INT 1
29299: NEG
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: LD_INT 1
29307: NEG
29308: PUSH
29309: LD_INT 2
29311: NEG
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: PUSH
29317: LD_INT 2
29319: PUSH
29320: LD_INT 1
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 2
29329: PUSH
29330: LD_INT 2
29332: PUSH
29333: EMPTY
29334: LIST
29335: LIST
29336: PUSH
29337: LD_INT 1
29339: PUSH
29340: LD_INT 2
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 2
29349: NEG
29350: PUSH
29351: LD_INT 1
29353: NEG
29354: PUSH
29355: EMPTY
29356: LIST
29357: LIST
29358: PUSH
29359: LD_INT 2
29361: NEG
29362: PUSH
29363: LD_INT 2
29365: NEG
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 2
29373: NEG
29374: PUSH
29375: LD_INT 3
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 3
29385: NEG
29386: PUSH
29387: LD_INT 2
29389: NEG
29390: PUSH
29391: EMPTY
29392: LIST
29393: LIST
29394: PUSH
29395: LD_INT 3
29397: NEG
29398: PUSH
29399: LD_INT 3
29401: NEG
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: LIST
29413: LIST
29414: LIST
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29425: LD_ADDR_VAR 0 14
29429: PUSH
29430: LD_INT 0
29432: PUSH
29433: LD_INT 0
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: LD_INT 1
29445: NEG
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: PUSH
29454: LD_INT 0
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: LD_INT 1
29463: PUSH
29464: LD_INT 1
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: LD_INT 0
29473: PUSH
29474: LD_INT 1
29476: PUSH
29477: EMPTY
29478: LIST
29479: LIST
29480: PUSH
29481: LD_INT 1
29483: NEG
29484: PUSH
29485: LD_INT 0
29487: PUSH
29488: EMPTY
29489: LIST
29490: LIST
29491: PUSH
29492: LD_INT 1
29494: NEG
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: NEG
29507: PUSH
29508: LD_INT 2
29510: NEG
29511: PUSH
29512: EMPTY
29513: LIST
29514: LIST
29515: PUSH
29516: LD_INT 0
29518: PUSH
29519: LD_INT 2
29521: NEG
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: LD_INT 1
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: LD_INT 2
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 1
29571: NEG
29572: PUSH
29573: LD_INT 3
29575: NEG
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 0
29583: PUSH
29584: LD_INT 3
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: LD_INT 2
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: EMPTY
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29621: LD_ADDR_VAR 0 15
29625: PUSH
29626: LD_INT 0
29628: PUSH
29629: LD_INT 0
29631: PUSH
29632: EMPTY
29633: LIST
29634: LIST
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: NEG
29642: PUSH
29643: EMPTY
29644: LIST
29645: LIST
29646: PUSH
29647: LD_INT 1
29649: PUSH
29650: LD_INT 0
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: PUSH
29657: LD_INT 1
29659: PUSH
29660: LD_INT 1
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 1
29679: NEG
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 1
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 2
29713: PUSH
29714: LD_INT 0
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 2
29723: PUSH
29724: LD_INT 1
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 1
29733: NEG
29734: PUSH
29735: LD_INT 1
29737: PUSH
29738: EMPTY
29739: LIST
29740: LIST
29741: PUSH
29742: LD_INT 2
29744: NEG
29745: PUSH
29746: LD_INT 0
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 2
29755: NEG
29756: PUSH
29757: LD_INT 1
29759: NEG
29760: PUSH
29761: EMPTY
29762: LIST
29763: LIST
29764: PUSH
29765: LD_INT 2
29767: PUSH
29768: LD_INT 1
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 3
29778: PUSH
29779: LD_INT 0
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 3
29788: PUSH
29789: LD_INT 1
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: EMPTY
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: LIST
29813: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29814: LD_ADDR_VAR 0 16
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: LD_INT 0
29824: PUSH
29825: EMPTY
29826: LIST
29827: LIST
29828: PUSH
29829: LD_INT 0
29831: PUSH
29832: LD_INT 1
29834: NEG
29835: PUSH
29836: EMPTY
29837: LIST
29838: LIST
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: LD_INT 0
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 1
29872: NEG
29873: PUSH
29874: LD_INT 0
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: NEG
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 1
29895: NEG
29896: PUSH
29897: LD_INT 2
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: PUSH
29908: LD_INT 1
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 2
29917: PUSH
29918: LD_INT 2
29920: PUSH
29921: EMPTY
29922: LIST
29923: LIST
29924: PUSH
29925: LD_INT 1
29927: PUSH
29928: LD_INT 2
29930: PUSH
29931: EMPTY
29932: LIST
29933: LIST
29934: PUSH
29935: LD_INT 2
29937: NEG
29938: PUSH
29939: LD_INT 1
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 2
29949: NEG
29950: PUSH
29951: LD_INT 2
29953: NEG
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 3
29961: PUSH
29962: LD_INT 2
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 3
29971: PUSH
29972: LD_INT 3
29974: PUSH
29975: EMPTY
29976: LIST
29977: LIST
29978: PUSH
29979: LD_INT 2
29981: PUSH
29982: LD_INT 3
29984: PUSH
29985: EMPTY
29986: LIST
29987: LIST
29988: PUSH
29989: EMPTY
29990: LIST
29991: LIST
29992: LIST
29993: LIST
29994: LIST
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30007: LD_ADDR_VAR 0 17
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: LD_INT 0
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 0
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 1
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 1
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: LD_INT 0
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: EMPTY
30060: LIST
30061: LIST
30062: PUSH
30063: LD_INT 1
30065: NEG
30066: PUSH
30067: LD_INT 0
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 1
30076: NEG
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: NEG
30089: PUSH
30090: LD_INT 2
30092: NEG
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 0
30100: PUSH
30101: LD_INT 2
30103: NEG
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 1
30111: PUSH
30112: LD_INT 1
30114: NEG
30115: PUSH
30116: EMPTY
30117: LIST
30118: LIST
30119: PUSH
30120: LD_INT 2
30122: PUSH
30123: LD_INT 0
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: LD_INT 2
30132: PUSH
30133: LD_INT 1
30135: PUSH
30136: EMPTY
30137: LIST
30138: LIST
30139: PUSH
30140: LD_INT 2
30142: PUSH
30143: LD_INT 2
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: PUSH
30153: LD_INT 2
30155: PUSH
30156: EMPTY
30157: LIST
30158: LIST
30159: PUSH
30160: LD_INT 0
30162: PUSH
30163: LD_INT 2
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 2
30183: NEG
30184: PUSH
30185: LD_INT 0
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 2
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: LIST
30227: LIST
30228: LIST
30229: LIST
30230: LIST
30231: LIST
30232: LIST
30233: LIST
30234: LIST
30235: LIST
30236: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30237: LD_ADDR_VAR 0 18
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: LD_INT 0
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 0
30254: PUSH
30255: LD_INT 1
30257: NEG
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 1
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 0
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: LD_INT 0
30299: PUSH
30300: EMPTY
30301: LIST
30302: LIST
30303: PUSH
30304: LD_INT 1
30306: NEG
30307: PUSH
30308: LD_INT 1
30310: NEG
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: LD_INT 1
30318: NEG
30319: PUSH
30320: LD_INT 2
30322: NEG
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 0
30330: PUSH
30331: LD_INT 2
30333: NEG
30334: PUSH
30335: EMPTY
30336: LIST
30337: LIST
30338: PUSH
30339: LD_INT 1
30341: PUSH
30342: LD_INT 1
30344: NEG
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 2
30352: PUSH
30353: LD_INT 0
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 2
30362: PUSH
30363: LD_INT 1
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 2
30372: PUSH
30373: LD_INT 2
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 1
30382: PUSH
30383: LD_INT 2
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 0
30392: PUSH
30393: LD_INT 2
30395: PUSH
30396: EMPTY
30397: LIST
30398: LIST
30399: PUSH
30400: LD_INT 1
30402: NEG
30403: PUSH
30404: LD_INT 1
30406: PUSH
30407: EMPTY
30408: LIST
30409: LIST
30410: PUSH
30411: LD_INT 2
30413: NEG
30414: PUSH
30415: LD_INT 0
30417: PUSH
30418: EMPTY
30419: LIST
30420: LIST
30421: PUSH
30422: LD_INT 2
30424: NEG
30425: PUSH
30426: LD_INT 1
30428: NEG
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 2
30436: NEG
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30467: LD_ADDR_VAR 0 19
30471: PUSH
30472: LD_INT 0
30474: PUSH
30475: LD_INT 0
30477: PUSH
30478: EMPTY
30479: LIST
30480: LIST
30481: PUSH
30482: LD_INT 0
30484: PUSH
30485: LD_INT 1
30487: NEG
30488: PUSH
30489: EMPTY
30490: LIST
30491: LIST
30492: PUSH
30493: LD_INT 1
30495: PUSH
30496: LD_INT 0
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PUSH
30503: LD_INT 1
30505: PUSH
30506: LD_INT 1
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 0
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 1
30525: NEG
30526: PUSH
30527: LD_INT 0
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 1
30536: NEG
30537: PUSH
30538: LD_INT 1
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 1
30548: NEG
30549: PUSH
30550: LD_INT 2
30552: NEG
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 0
30560: PUSH
30561: LD_INT 2
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: PUSH
30580: LD_INT 2
30582: PUSH
30583: LD_INT 0
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PUSH
30590: LD_INT 2
30592: PUSH
30593: LD_INT 1
30595: PUSH
30596: EMPTY
30597: LIST
30598: LIST
30599: PUSH
30600: LD_INT 2
30602: PUSH
30603: LD_INT 2
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 1
30612: PUSH
30613: LD_INT 2
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 0
30622: PUSH
30623: LD_INT 2
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: PUSH
30637: EMPTY
30638: LIST
30639: LIST
30640: PUSH
30641: LD_INT 2
30643: NEG
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 2
30654: NEG
30655: PUSH
30656: LD_INT 1
30658: NEG
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 2
30666: NEG
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: EMPTY
30673: LIST
30674: LIST
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: LIST
30696: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30697: LD_ADDR_VAR 0 20
30701: PUSH
30702: LD_INT 0
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 0
30714: PUSH
30715: LD_INT 1
30717: NEG
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: LD_INT 1
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PUSH
30733: LD_INT 1
30735: PUSH
30736: LD_INT 1
30738: PUSH
30739: EMPTY
30740: LIST
30741: LIST
30742: PUSH
30743: LD_INT 0
30745: PUSH
30746: LD_INT 1
30748: PUSH
30749: EMPTY
30750: LIST
30751: LIST
30752: PUSH
30753: LD_INT 1
30755: NEG
30756: PUSH
30757: LD_INT 0
30759: PUSH
30760: EMPTY
30761: LIST
30762: LIST
30763: PUSH
30764: LD_INT 1
30766: NEG
30767: PUSH
30768: LD_INT 1
30770: NEG
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 1
30778: NEG
30779: PUSH
30780: LD_INT 2
30782: NEG
30783: PUSH
30784: EMPTY
30785: LIST
30786: LIST
30787: PUSH
30788: LD_INT 0
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PUSH
30799: LD_INT 1
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: EMPTY
30807: LIST
30808: LIST
30809: PUSH
30810: LD_INT 2
30812: PUSH
30813: LD_INT 0
30815: PUSH
30816: EMPTY
30817: LIST
30818: LIST
30819: PUSH
30820: LD_INT 2
30822: PUSH
30823: LD_INT 1
30825: PUSH
30826: EMPTY
30827: LIST
30828: LIST
30829: PUSH
30830: LD_INT 2
30832: PUSH
30833: LD_INT 2
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: PUSH
30840: LD_INT 1
30842: PUSH
30843: LD_INT 2
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 0
30852: PUSH
30853: LD_INT 2
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 1
30862: NEG
30863: PUSH
30864: LD_INT 1
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: LD_INT 2
30873: NEG
30874: PUSH
30875: LD_INT 0
30877: PUSH
30878: EMPTY
30879: LIST
30880: LIST
30881: PUSH
30882: LD_INT 2
30884: NEG
30885: PUSH
30886: LD_INT 1
30888: NEG
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 2
30896: NEG
30897: PUSH
30898: LD_INT 2
30900: NEG
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30927: LD_ADDR_VAR 0 21
30931: PUSH
30932: LD_INT 0
30934: PUSH
30935: LD_INT 0
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 0
30944: PUSH
30945: LD_INT 1
30947: NEG
30948: PUSH
30949: EMPTY
30950: LIST
30951: LIST
30952: PUSH
30953: LD_INT 1
30955: PUSH
30956: LD_INT 0
30958: PUSH
30959: EMPTY
30960: LIST
30961: LIST
30962: PUSH
30963: LD_INT 1
30965: PUSH
30966: LD_INT 1
30968: PUSH
30969: EMPTY
30970: LIST
30971: LIST
30972: PUSH
30973: LD_INT 0
30975: PUSH
30976: LD_INT 1
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 1
30985: NEG
30986: PUSH
30987: LD_INT 0
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 1
30996: NEG
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 1
31008: NEG
31009: PUSH
31010: LD_INT 2
31012: NEG
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: LD_INT 0
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: EMPTY
31026: LIST
31027: LIST
31028: PUSH
31029: LD_INT 1
31031: PUSH
31032: LD_INT 1
31034: NEG
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 2
31042: PUSH
31043: LD_INT 0
31045: PUSH
31046: EMPTY
31047: LIST
31048: LIST
31049: PUSH
31050: LD_INT 2
31052: PUSH
31053: LD_INT 1
31055: PUSH
31056: EMPTY
31057: LIST
31058: LIST
31059: PUSH
31060: LD_INT 2
31062: PUSH
31063: LD_INT 2
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 1
31072: PUSH
31073: LD_INT 2
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 0
31082: PUSH
31083: LD_INT 2
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: NEG
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 2
31103: NEG
31104: PUSH
31105: LD_INT 0
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 2
31114: NEG
31115: PUSH
31116: LD_INT 1
31118: NEG
31119: PUSH
31120: EMPTY
31121: LIST
31122: LIST
31123: PUSH
31124: LD_INT 2
31126: NEG
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: EMPTY
31133: LIST
31134: LIST
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31157: LD_ADDR_VAR 0 22
31161: PUSH
31162: LD_INT 0
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 0
31174: PUSH
31175: LD_INT 1
31177: NEG
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 1
31185: PUSH
31186: LD_INT 0
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: LD_INT 1
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: LD_INT 0
31205: PUSH
31206: LD_INT 1
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 1
31215: NEG
31216: PUSH
31217: LD_INT 0
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 1
31226: NEG
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 1
31238: NEG
31239: PUSH
31240: LD_INT 2
31242: NEG
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: LD_INT 0
31250: PUSH
31251: LD_INT 2
31253: NEG
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 2
31272: PUSH
31273: LD_INT 0
31275: PUSH
31276: EMPTY
31277: LIST
31278: LIST
31279: PUSH
31280: LD_INT 2
31282: PUSH
31283: LD_INT 1
31285: PUSH
31286: EMPTY
31287: LIST
31288: LIST
31289: PUSH
31290: LD_INT 2
31292: PUSH
31293: LD_INT 2
31295: PUSH
31296: EMPTY
31297: LIST
31298: LIST
31299: PUSH
31300: LD_INT 1
31302: PUSH
31303: LD_INT 2
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 0
31312: PUSH
31313: LD_INT 2
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: NEG
31323: PUSH
31324: LD_INT 1
31326: PUSH
31327: EMPTY
31328: LIST
31329: LIST
31330: PUSH
31331: LD_INT 2
31333: NEG
31334: PUSH
31335: LD_INT 0
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 2
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: NEG
31349: PUSH
31350: EMPTY
31351: LIST
31352: LIST
31353: PUSH
31354: LD_INT 2
31356: NEG
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31387: LD_ADDR_VAR 0 23
31391: PUSH
31392: LD_INT 0
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 0
31404: PUSH
31405: LD_INT 1
31407: NEG
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 1
31415: PUSH
31416: LD_INT 0
31418: PUSH
31419: EMPTY
31420: LIST
31421: LIST
31422: PUSH
31423: LD_INT 1
31425: PUSH
31426: LD_INT 1
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 0
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 1
31445: NEG
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 1
31456: NEG
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 1
31468: NEG
31469: PUSH
31470: LD_INT 2
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: LD_INT 0
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: EMPTY
31486: LIST
31487: LIST
31488: PUSH
31489: LD_INT 1
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 2
31502: PUSH
31503: LD_INT 0
31505: PUSH
31506: EMPTY
31507: LIST
31508: LIST
31509: PUSH
31510: LD_INT 2
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 2
31522: PUSH
31523: LD_INT 2
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: LD_INT 2
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 0
31542: PUSH
31543: LD_INT 2
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: LD_INT 1
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 2
31563: NEG
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 2
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 2
31586: NEG
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 2
31598: NEG
31599: PUSH
31600: LD_INT 3
31602: NEG
31603: PUSH
31604: EMPTY
31605: LIST
31606: LIST
31607: PUSH
31608: LD_INT 1
31610: NEG
31611: PUSH
31612: LD_INT 3
31614: NEG
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 1
31622: PUSH
31623: LD_INT 2
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 2
31633: PUSH
31634: LD_INT 1
31636: NEG
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: EMPTY
31643: LIST
31644: LIST
31645: LIST
31646: LIST
31647: LIST
31648: LIST
31649: LIST
31650: LIST
31651: LIST
31652: LIST
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31667: LD_ADDR_VAR 0 24
31671: PUSH
31672: LD_INT 0
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 1
31687: NEG
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: LD_INT 1
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 0
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: LD_INT 1
31736: NEG
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: NEG
31749: PUSH
31750: LD_INT 2
31752: NEG
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 0
31760: PUSH
31761: LD_INT 2
31763: NEG
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 1
31771: PUSH
31772: LD_INT 1
31774: NEG
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: LD_INT 0
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 0
31822: PUSH
31823: LD_INT 2
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: LD_INT 1
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: NEG
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: LD_INT 2
31870: NEG
31871: PUSH
31872: EMPTY
31873: LIST
31874: LIST
31875: PUSH
31876: LD_INT 1
31878: PUSH
31879: LD_INT 2
31881: NEG
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 2
31889: PUSH
31890: LD_INT 1
31892: NEG
31893: PUSH
31894: EMPTY
31895: LIST
31896: LIST
31897: PUSH
31898: LD_INT 3
31900: PUSH
31901: LD_INT 1
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: LD_INT 2
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: LIST
31924: LIST
31925: LIST
31926: LIST
31927: LIST
31928: LIST
31929: LIST
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31943: LD_ADDR_VAR 0 25
31947: PUSH
31948: LD_INT 0
31950: PUSH
31951: LD_INT 0
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 0
31960: PUSH
31961: LD_INT 1
31963: NEG
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 1
31981: PUSH
31982: LD_INT 1
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 1
32001: NEG
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 1
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: NEG
32025: PUSH
32026: LD_INT 2
32028: NEG
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 2
32039: NEG
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: PUSH
32045: LD_INT 1
32047: PUSH
32048: LD_INT 1
32050: NEG
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 2
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: PUSH
32069: LD_INT 1
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 2
32078: PUSH
32079: LD_INT 2
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 1
32088: PUSH
32089: LD_INT 2
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PUSH
32096: LD_INT 0
32098: PUSH
32099: LD_INT 2
32101: PUSH
32102: EMPTY
32103: LIST
32104: LIST
32105: PUSH
32106: LD_INT 1
32108: NEG
32109: PUSH
32110: LD_INT 1
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 2
32119: NEG
32120: PUSH
32121: LD_INT 0
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 2
32130: NEG
32131: PUSH
32132: LD_INT 1
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 2
32142: NEG
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 3
32154: PUSH
32155: LD_INT 1
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 3
32164: PUSH
32165: LD_INT 2
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 2
32174: PUSH
32175: LD_INT 3
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: PUSH
32185: LD_INT 3
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: EMPTY
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: LIST
32206: LIST
32207: LIST
32208: LIST
32209: LIST
32210: LIST
32211: LIST
32212: LIST
32213: LIST
32214: LIST
32215: LIST
32216: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32217: LD_ADDR_VAR 0 26
32221: PUSH
32222: LD_INT 0
32224: PUSH
32225: LD_INT 0
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 1
32237: NEG
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 1
32255: PUSH
32256: LD_INT 1
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 0
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 1
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 1
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 0
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: EMPTY
32316: LIST
32317: LIST
32318: PUSH
32319: LD_INT 1
32321: PUSH
32322: LD_INT 1
32324: NEG
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 2
32332: PUSH
32333: LD_INT 0
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 2
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 2
32352: PUSH
32353: LD_INT 2
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: LD_INT 2
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: LD_INT 2
32375: PUSH
32376: EMPTY
32377: LIST
32378: LIST
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 2
32393: NEG
32394: PUSH
32395: LD_INT 0
32397: PUSH
32398: EMPTY
32399: LIST
32400: LIST
32401: PUSH
32402: LD_INT 2
32404: NEG
32405: PUSH
32406: LD_INT 1
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: LD_INT 2
32420: NEG
32421: PUSH
32422: EMPTY
32423: LIST
32424: LIST
32425: PUSH
32426: LD_INT 2
32428: PUSH
32429: LD_INT 3
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 1
32438: PUSH
32439: LD_INT 3
32441: PUSH
32442: EMPTY
32443: LIST
32444: LIST
32445: PUSH
32446: LD_INT 1
32448: NEG
32449: PUSH
32450: LD_INT 2
32452: PUSH
32453: EMPTY
32454: LIST
32455: LIST
32456: PUSH
32457: LD_INT 2
32459: NEG
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: LIST
32474: LIST
32475: LIST
32476: LIST
32477: LIST
32478: LIST
32479: LIST
32480: LIST
32481: LIST
32482: LIST
32483: LIST
32484: LIST
32485: LIST
32486: LIST
32487: LIST
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32493: LD_ADDR_VAR 0 27
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 0
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 0
32510: PUSH
32511: LD_INT 1
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 0
32524: PUSH
32525: EMPTY
32526: LIST
32527: LIST
32528: PUSH
32529: LD_INT 1
32531: PUSH
32532: LD_INT 1
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: PUSH
32539: LD_INT 0
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PUSH
32549: LD_INT 1
32551: NEG
32552: PUSH
32553: LD_INT 0
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 1
32562: NEG
32563: PUSH
32564: LD_INT 1
32566: NEG
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: LD_INT 2
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 0
32586: PUSH
32587: LD_INT 2
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: LD_INT 1
32600: NEG
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: LD_INT 0
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 2
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 2
32628: PUSH
32629: LD_INT 2
32631: PUSH
32632: EMPTY
32633: LIST
32634: LIST
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: LD_INT 2
32641: PUSH
32642: EMPTY
32643: LIST
32644: LIST
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: LD_INT 2
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: LD_INT 1
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 2
32669: NEG
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 2
32680: NEG
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 2
32692: NEG
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: LD_INT 1
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 3
32726: NEG
32727: PUSH
32728: LD_INT 1
32730: NEG
32731: PUSH
32732: EMPTY
32733: LIST
32734: LIST
32735: PUSH
32736: LD_INT 3
32738: NEG
32739: PUSH
32740: LD_INT 2
32742: NEG
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: LIST
32752: LIST
32753: LIST
32754: LIST
32755: LIST
32756: LIST
32757: LIST
32758: LIST
32759: LIST
32760: LIST
32761: LIST
32762: LIST
32763: LIST
32764: LIST
32765: LIST
32766: LIST
32767: LIST
32768: LIST
32769: LIST
32770: LIST
32771: LIST
32772: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32773: LD_ADDR_VAR 0 28
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: LD_INT 0
32783: PUSH
32784: EMPTY
32785: LIST
32786: LIST
32787: PUSH
32788: LD_INT 0
32790: PUSH
32791: LD_INT 1
32793: NEG
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: LD_INT 0
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 1
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: LD_INT 1
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: NEG
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: NEG
32855: PUSH
32856: LD_INT 2
32858: NEG
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: LD_INT 2
32869: NEG
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 1
32877: PUSH
32878: LD_INT 1
32880: NEG
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: PUSH
32889: LD_INT 0
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PUSH
32896: LD_INT 2
32898: PUSH
32899: LD_INT 1
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 2
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 1
32918: PUSH
32919: LD_INT 2
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: LD_INT 0
32928: PUSH
32929: LD_INT 2
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 1
32938: NEG
32939: PUSH
32940: LD_INT 1
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: LD_INT 0
32953: PUSH
32954: EMPTY
32955: LIST
32956: LIST
32957: PUSH
32958: LD_INT 2
32960: NEG
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: LD_INT 2
32976: NEG
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 2
32984: NEG
32985: PUSH
32986: LD_INT 3
32988: NEG
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 1
32996: NEG
32997: PUSH
32998: LD_INT 3
33000: NEG
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 3
33008: NEG
33009: PUSH
33010: LD_INT 1
33012: NEG
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 3
33020: NEG
33021: PUSH
33022: LD_INT 2
33024: NEG
33025: PUSH
33026: EMPTY
33027: LIST
33028: LIST
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: LIST
33034: LIST
33035: LIST
33036: LIST
33037: LIST
33038: LIST
33039: LIST
33040: LIST
33041: LIST
33042: LIST
33043: LIST
33044: LIST
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33055: LD_ADDR_VAR 0 29
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: LD_INT 0
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 0
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 1
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 1
33113: NEG
33114: PUSH
33115: LD_INT 0
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: NEG
33125: PUSH
33126: LD_INT 1
33128: NEG
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 1
33136: NEG
33137: PUSH
33138: LD_INT 2
33140: NEG
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: LD_INT 2
33151: NEG
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: PUSH
33157: LD_INT 1
33159: PUSH
33160: LD_INT 1
33162: NEG
33163: PUSH
33164: EMPTY
33165: LIST
33166: LIST
33167: PUSH
33168: LD_INT 2
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: EMPTY
33175: LIST
33176: LIST
33177: PUSH
33178: LD_INT 2
33180: PUSH
33181: LD_INT 1
33183: PUSH
33184: EMPTY
33185: LIST
33186: LIST
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: LD_INT 2
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 0
33200: PUSH
33201: LD_INT 2
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: EMPTY
33216: LIST
33217: LIST
33218: PUSH
33219: LD_INT 2
33221: NEG
33222: PUSH
33223: LD_INT 1
33225: NEG
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: LD_INT 2
33237: NEG
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 2
33245: NEG
33246: PUSH
33247: LD_INT 3
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 2
33257: PUSH
33258: LD_INT 1
33260: NEG
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 3
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 3
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 1
33288: NEG
33289: PUSH
33290: LD_INT 2
33292: PUSH
33293: EMPTY
33294: LIST
33295: LIST
33296: PUSH
33297: LD_INT 3
33299: NEG
33300: PUSH
33301: LD_INT 2
33303: NEG
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: LIST
33316: LIST
33317: LIST
33318: LIST
33319: LIST
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33334: LD_ADDR_VAR 0 30
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: LD_INT 1
33354: NEG
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: PUSH
33363: LD_INT 0
33365: PUSH
33366: EMPTY
33367: LIST
33368: LIST
33369: PUSH
33370: LD_INT 1
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 0
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 1
33392: NEG
33393: PUSH
33394: LD_INT 0
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 1
33403: NEG
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 1
33415: NEG
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 0
33427: PUSH
33428: LD_INT 2
33430: NEG
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 1
33441: NEG
33442: PUSH
33443: EMPTY
33444: LIST
33445: LIST
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: EMPTY
33454: LIST
33455: LIST
33456: PUSH
33457: LD_INT 2
33459: PUSH
33460: LD_INT 1
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 2
33469: PUSH
33470: LD_INT 2
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: LD_INT 2
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 1
33489: NEG
33490: PUSH
33491: LD_INT 1
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 2
33500: NEG
33501: PUSH
33502: LD_INT 0
33504: PUSH
33505: EMPTY
33506: LIST
33507: LIST
33508: PUSH
33509: LD_INT 2
33511: NEG
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: EMPTY
33518: LIST
33519: LIST
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: LD_INT 3
33527: NEG
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 2
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 3
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 2
33556: PUSH
33557: LD_INT 3
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 2
33566: NEG
33567: PUSH
33568: LD_INT 1
33570: PUSH
33571: EMPTY
33572: LIST
33573: LIST
33574: PUSH
33575: LD_INT 3
33577: NEG
33578: PUSH
33579: LD_INT 1
33581: NEG
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: LIST
33593: LIST
33594: LIST
33595: LIST
33596: LIST
33597: LIST
33598: LIST
33599: LIST
33600: LIST
33601: LIST
33602: LIST
33603: LIST
33604: LIST
33605: LIST
33606: LIST
33607: LIST
33608: LIST
33609: LIST
33610: LIST
33611: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33612: LD_ADDR_VAR 0 31
33616: PUSH
33617: LD_INT 0
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 0
33629: PUSH
33630: LD_INT 1
33632: NEG
33633: PUSH
33634: EMPTY
33635: LIST
33636: LIST
33637: PUSH
33638: LD_INT 1
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: EMPTY
33645: LIST
33646: LIST
33647: PUSH
33648: LD_INT 1
33650: PUSH
33651: LD_INT 1
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 0
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 1
33670: NEG
33671: PUSH
33672: LD_INT 0
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 1
33681: NEG
33682: PUSH
33683: LD_INT 1
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 1
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: PUSH
33706: LD_INT 1
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 2
33726: PUSH
33727: LD_INT 1
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 2
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: LD_INT 2
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 0
33756: PUSH
33757: LD_INT 2
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: NEG
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 2
33777: NEG
33778: PUSH
33779: LD_INT 1
33781: NEG
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 2
33789: NEG
33790: PUSH
33791: LD_INT 2
33793: NEG
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 2
33801: NEG
33802: PUSH
33803: LD_INT 3
33805: NEG
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 1
33816: NEG
33817: PUSH
33818: EMPTY
33819: LIST
33820: LIST
33821: PUSH
33822: LD_INT 3
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: LD_INT 3
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 1
33844: NEG
33845: PUSH
33846: LD_INT 2
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 3
33855: NEG
33856: PUSH
33857: LD_INT 2
33859: NEG
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: LIST
33869: LIST
33870: LIST
33871: LIST
33872: LIST
33873: LIST
33874: LIST
33875: LIST
33876: LIST
33877: LIST
33878: LIST
33879: LIST
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: LIST
33886: LIST
33887: LIST
33888: LIST
33889: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33890: LD_ADDR_VAR 0 32
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 0
33907: PUSH
33908: LD_INT 1
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 0
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 1
33928: PUSH
33929: LD_INT 1
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 1
33959: NEG
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 1
33971: NEG
33972: PUSH
33973: LD_INT 2
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: LD_INT 2
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 1
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 2
34005: PUSH
34006: LD_INT 1
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: LD_INT 2
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 2
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: LD_INT 2
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 1
34045: NEG
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: NEG
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 2
34067: NEG
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: EMPTY
34074: LIST
34075: LIST
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: LD_INT 3
34083: NEG
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: LD_INT 2
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 3
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 2
34112: PUSH
34113: LD_INT 3
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 2
34122: NEG
34123: PUSH
34124: LD_INT 1
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 3
34133: NEG
34134: PUSH
34135: LD_INT 1
34137: NEG
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: LIST
34147: LIST
34148: LIST
34149: LIST
34150: LIST
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34168: LD_ADDR_VAR 0 33
34172: PUSH
34173: LD_INT 0
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 0
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 1
34196: PUSH
34197: LD_INT 0
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 1
34206: PUSH
34207: LD_INT 1
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 1
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 1
34226: NEG
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: NEG
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: EMPTY
34244: LIST
34245: LIST
34246: PUSH
34247: LD_INT 1
34249: NEG
34250: PUSH
34251: LD_INT 2
34253: NEG
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: LD_INT 1
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: LD_INT 1
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 1
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 2
34305: PUSH
34306: EMPTY
34307: LIST
34308: LIST
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: LD_INT 1
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 2
34323: NEG
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 2
34334: NEG
34335: PUSH
34336: LD_INT 1
34338: NEG
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 2
34346: NEG
34347: PUSH
34348: LD_INT 2
34350: NEG
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: NEG
34359: PUSH
34360: LD_INT 3
34362: NEG
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: LD_INT 2
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 3
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 1
34391: PUSH
34392: LD_INT 3
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: NEG
34402: PUSH
34403: LD_INT 2
34405: PUSH
34406: EMPTY
34407: LIST
34408: LIST
34409: PUSH
34410: LD_INT 3
34412: NEG
34413: PUSH
34414: LD_INT 2
34416: NEG
34417: PUSH
34418: EMPTY
34419: LIST
34420: LIST
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: LIST
34426: LIST
34427: LIST
34428: LIST
34429: LIST
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34447: LD_ADDR_VAR 0 34
34451: PUSH
34452: LD_INT 0
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: LD_INT 1
34467: NEG
34468: PUSH
34469: EMPTY
34470: LIST
34471: LIST
34472: PUSH
34473: LD_INT 1
34475: PUSH
34476: LD_INT 0
34478: PUSH
34479: EMPTY
34480: LIST
34481: LIST
34482: PUSH
34483: LD_INT 1
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: LD_INT 1
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 1
34505: NEG
34506: PUSH
34507: LD_INT 0
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 1
34516: NEG
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 1
34528: NEG
34529: PUSH
34530: LD_INT 2
34532: NEG
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 0
34540: PUSH
34541: LD_INT 2
34543: NEG
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 1
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: LD_INT 1
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 2
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: LD_INT 1
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 0
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: LD_INT 2
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 1
34638: NEG
34639: PUSH
34640: LD_INT 3
34642: NEG
34643: PUSH
34644: EMPTY
34645: LIST
34646: LIST
34647: PUSH
34648: LD_INT 1
34650: PUSH
34651: LD_INT 2
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: LD_INT 2
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 2
34671: PUSH
34672: LD_INT 3
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 2
34681: NEG
34682: PUSH
34683: LD_INT 1
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 3
34692: NEG
34693: PUSH
34694: LD_INT 1
34696: NEG
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34727: LD_ADDR_VAR 0 35
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: LD_INT 0
34758: PUSH
34759: EMPTY
34760: LIST
34761: LIST
34762: PUSH
34763: LD_INT 1
34765: PUSH
34766: LD_INT 1
34768: PUSH
34769: EMPTY
34770: LIST
34771: LIST
34772: PUSH
34773: LD_INT 0
34775: PUSH
34776: LD_INT 1
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 0
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: NEG
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: LD_INT 1
34822: NEG
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: PUSH
34828: EMPTY
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34839: LD_ADDR_VAR 0 36
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 1
34859: NEG
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 1
34867: PUSH
34868: LD_INT 0
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 0
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 1
34897: NEG
34898: PUSH
34899: LD_INT 0
34901: PUSH
34902: EMPTY
34903: LIST
34904: LIST
34905: PUSH
34906: LD_INT 1
34908: NEG
34909: PUSH
34910: LD_INT 1
34912: NEG
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 1
34920: NEG
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 1
34932: PUSH
34933: LD_INT 2
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: EMPTY
34941: LIST
34942: LIST
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34951: LD_ADDR_VAR 0 37
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: LD_INT 0
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: LD_INT 1
34971: NEG
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 1
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 1
34989: PUSH
34990: LD_INT 1
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: LD_INT 1
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 1
35009: NEG
35010: PUSH
35011: LD_INT 0
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: LD_INT 1
35024: NEG
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: LD_INT 1
35035: NEG
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35063: LD_ADDR_VAR 0 38
35067: PUSH
35068: LD_INT 0
35070: PUSH
35071: LD_INT 0
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: PUSH
35078: LD_INT 0
35080: PUSH
35081: LD_INT 1
35083: NEG
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: PUSH
35089: LD_INT 1
35091: PUSH
35092: LD_INT 0
35094: PUSH
35095: EMPTY
35096: LIST
35097: LIST
35098: PUSH
35099: LD_INT 1
35101: PUSH
35102: LD_INT 1
35104: PUSH
35105: EMPTY
35106: LIST
35107: LIST
35108: PUSH
35109: LD_INT 0
35111: PUSH
35112: LD_INT 1
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 1
35121: NEG
35122: PUSH
35123: LD_INT 0
35125: PUSH
35126: EMPTY
35127: LIST
35128: LIST
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: LD_INT 1
35136: NEG
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 2
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 2
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35175: LD_ADDR_VAR 0 39
35179: PUSH
35180: LD_INT 0
35182: PUSH
35183: LD_INT 0
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: PUSH
35190: LD_INT 0
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: LD_INT 0
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 0
35223: PUSH
35224: LD_INT 1
35226: PUSH
35227: EMPTY
35228: LIST
35229: LIST
35230: PUSH
35231: LD_INT 1
35233: NEG
35234: PUSH
35235: LD_INT 0
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 1
35256: NEG
35257: PUSH
35258: LD_INT 2
35260: NEG
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 1
35268: PUSH
35269: LD_INT 2
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: LIST
35280: LIST
35281: LIST
35282: LIST
35283: LIST
35284: LIST
35285: LIST
35286: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35287: LD_ADDR_VAR 0 40
35291: PUSH
35292: LD_INT 0
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: PUSH
35302: LD_INT 0
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 1
35315: PUSH
35316: LD_INT 0
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 1
35325: PUSH
35326: LD_INT 1
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 0
35335: PUSH
35336: LD_INT 1
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 1
35345: NEG
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 1
35360: NEG
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 1
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 1
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: LIST
35392: LIST
35393: LIST
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35399: LD_ADDR_VAR 0 41
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 0
35416: PUSH
35417: LD_INT 1
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 0
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 0
35447: PUSH
35448: LD_INT 1
35450: PUSH
35451: EMPTY
35452: LIST
35453: LIST
35454: PUSH
35455: LD_INT 1
35457: NEG
35458: PUSH
35459: LD_INT 0
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 1
35472: NEG
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 1
35480: NEG
35481: PUSH
35482: LD_INT 2
35484: NEG
35485: PUSH
35486: EMPTY
35487: LIST
35488: LIST
35489: PUSH
35490: LD_INT 1
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 2
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 2
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 2
35523: PUSH
35524: LD_INT 2
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 1
35533: PUSH
35534: LD_INT 2
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 1
35543: NEG
35544: PUSH
35545: LD_INT 1
35547: PUSH
35548: EMPTY
35549: LIST
35550: LIST
35551: PUSH
35552: LD_INT 2
35554: NEG
35555: PUSH
35556: LD_INT 0
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 2
35565: NEG
35566: PUSH
35567: LD_INT 1
35569: NEG
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 2
35577: NEG
35578: PUSH
35579: LD_INT 2
35581: NEG
35582: PUSH
35583: EMPTY
35584: LIST
35585: LIST
35586: PUSH
35587: LD_INT 2
35589: NEG
35590: PUSH
35591: LD_INT 3
35593: NEG
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: LD_INT 1
35604: NEG
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 3
35612: PUSH
35613: LD_INT 0
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 3
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 3
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 3
35642: PUSH
35643: LD_INT 3
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 2
35652: PUSH
35653: LD_INT 3
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 2
35662: NEG
35663: PUSH
35664: LD_INT 1
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 3
35673: NEG
35674: PUSH
35675: LD_INT 0
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 3
35684: NEG
35685: PUSH
35686: LD_INT 1
35688: NEG
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 3
35696: NEG
35697: PUSH
35698: LD_INT 2
35700: NEG
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 3
35708: NEG
35709: PUSH
35710: LD_INT 3
35712: NEG
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: EMPTY
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35749: LD_ADDR_VAR 0 42
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: LD_INT 0
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 0
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 1
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 0
35797: PUSH
35798: LD_INT 1
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: NEG
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 1
35818: NEG
35819: PUSH
35820: LD_INT 1
35822: NEG
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 2
35845: NEG
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 2
35864: PUSH
35865: LD_INT 1
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 2
35874: PUSH
35875: LD_INT 2
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 1
35884: PUSH
35885: LD_INT 2
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 0
35894: PUSH
35895: LD_INT 2
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 1
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 2
35915: NEG
35916: PUSH
35917: LD_INT 1
35919: NEG
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 2
35927: NEG
35928: PUSH
35929: LD_INT 2
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 3
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: LD_INT 3
35955: NEG
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 0
35963: PUSH
35964: LD_INT 3
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 2
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 3
35985: PUSH
35986: LD_INT 2
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: PUSH
35993: LD_INT 3
35995: PUSH
35996: LD_INT 3
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 2
36005: PUSH
36006: LD_INT 3
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 1
36015: PUSH
36016: LD_INT 3
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 0
36025: PUSH
36026: LD_INT 3
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 3
36046: NEG
36047: PUSH
36048: LD_INT 2
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 3
36058: NEG
36059: PUSH
36060: LD_INT 3
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: LIST
36072: LIST
36073: LIST
36074: LIST
36075: LIST
36076: LIST
36077: LIST
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: LIST
36097: LIST
36098: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36099: LD_ADDR_VAR 0 43
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 0
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 0
36116: PUSH
36117: LD_INT 1
36119: NEG
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 0
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 0
36147: PUSH
36148: LD_INT 1
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: NEG
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 1
36168: NEG
36169: PUSH
36170: LD_INT 1
36172: NEG
36173: PUSH
36174: EMPTY
36175: LIST
36176: LIST
36177: PUSH
36178: LD_INT 1
36180: NEG
36181: PUSH
36182: LD_INT 2
36184: NEG
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 2
36195: NEG
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 1
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 2
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: PUSH
36222: LD_INT 2
36224: PUSH
36225: LD_INT 1
36227: PUSH
36228: EMPTY
36229: LIST
36230: LIST
36231: PUSH
36232: LD_INT 1
36234: PUSH
36235: LD_INT 2
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: LD_INT 0
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: NEG
36277: PUSH
36278: LD_INT 1
36280: NEG
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 3
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: LD_INT 3
36303: NEG
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: PUSH
36309: LD_INT 1
36311: PUSH
36312: LD_INT 2
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 2
36322: PUSH
36323: LD_INT 1
36325: NEG
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 3
36333: PUSH
36334: LD_INT 0
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 3
36343: PUSH
36344: LD_INT 1
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: PUSH
36354: LD_INT 3
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: LD_INT 3
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: NEG
36374: PUSH
36375: LD_INT 2
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 2
36384: NEG
36385: PUSH
36386: LD_INT 1
36388: PUSH
36389: EMPTY
36390: LIST
36391: LIST
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: EMPTY
36401: LIST
36402: LIST
36403: PUSH
36404: LD_INT 3
36406: NEG
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: LIST
36422: LIST
36423: LIST
36424: LIST
36425: LIST
36426: LIST
36427: LIST
36428: LIST
36429: LIST
36430: LIST
36431: LIST
36432: LIST
36433: LIST
36434: LIST
36435: LIST
36436: LIST
36437: LIST
36438: LIST
36439: LIST
36440: LIST
36441: LIST
36442: LIST
36443: LIST
36444: LIST
36445: LIST
36446: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36447: LD_ADDR_VAR 0 44
36451: PUSH
36452: LD_INT 0
36454: PUSH
36455: LD_INT 0
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 0
36464: PUSH
36465: LD_INT 1
36467: NEG
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 1
36475: PUSH
36476: LD_INT 0
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 1
36485: PUSH
36486: LD_INT 1
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 0
36495: PUSH
36496: LD_INT 1
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: LD_INT 0
36509: PUSH
36510: EMPTY
36511: LIST
36512: LIST
36513: PUSH
36514: LD_INT 1
36516: NEG
36517: PUSH
36518: LD_INT 1
36520: NEG
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 1
36528: NEG
36529: PUSH
36530: LD_INT 2
36532: NEG
36533: PUSH
36534: EMPTY
36535: LIST
36536: LIST
36537: PUSH
36538: LD_INT 1
36540: PUSH
36541: LD_INT 1
36543: NEG
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 2
36561: PUSH
36562: LD_INT 1
36564: PUSH
36565: EMPTY
36566: LIST
36567: LIST
36568: PUSH
36569: LD_INT 2
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: EMPTY
36576: LIST
36577: LIST
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: LD_INT 2
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: PUSH
36589: LD_INT 1
36591: NEG
36592: PUSH
36593: LD_INT 1
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: EMPTY
36608: LIST
36609: LIST
36610: PUSH
36611: LD_INT 2
36613: NEG
36614: PUSH
36615: LD_INT 1
36617: NEG
36618: PUSH
36619: EMPTY
36620: LIST
36621: LIST
36622: PUSH
36623: LD_INT 2
36625: NEG
36626: PUSH
36627: LD_INT 2
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 2
36637: NEG
36638: PUSH
36639: LD_INT 3
36641: NEG
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 3
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 3
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 3
36680: PUSH
36681: LD_INT 2
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 3
36690: PUSH
36691: LD_INT 3
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 2
36700: PUSH
36701: LD_INT 3
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 2
36710: NEG
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: NEG
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 3
36732: NEG
36733: PUSH
36734: LD_INT 1
36736: NEG
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 3
36744: NEG
36745: PUSH
36746: LD_INT 2
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 3
36756: NEG
36757: PUSH
36758: LD_INT 3
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: LIST
36781: LIST
36782: LIST
36783: LIST
36784: LIST
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36797: LD_ADDR_VAR 0 45
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: LD_INT 0
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: LD_INT 1
36817: NEG
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 1
36825: PUSH
36826: LD_INT 0
36828: PUSH
36829: EMPTY
36830: LIST
36831: LIST
36832: PUSH
36833: LD_INT 1
36835: PUSH
36836: LD_INT 1
36838: PUSH
36839: EMPTY
36840: LIST
36841: LIST
36842: PUSH
36843: LD_INT 0
36845: PUSH
36846: LD_INT 1
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 1
36855: NEG
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 1
36866: NEG
36867: PUSH
36868: LD_INT 1
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 2
36893: NEG
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 1
36904: NEG
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: EMPTY
36917: LIST
36918: LIST
36919: PUSH
36920: LD_INT 2
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 1
36932: PUSH
36933: LD_INT 2
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 0
36942: PUSH
36943: LD_INT 2
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: NEG
36964: PUSH
36965: LD_INT 1
36967: NEG
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 2
36987: NEG
36988: PUSH
36989: LD_INT 3
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: NEG
37000: PUSH
37001: LD_INT 3
37003: NEG
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: PUSH
37009: LD_INT 0
37011: PUSH
37012: LD_INT 3
37014: NEG
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: LD_INT 1
37022: PUSH
37023: LD_INT 2
37025: NEG
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 3
37033: PUSH
37034: LD_INT 2
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 3
37043: PUSH
37044: LD_INT 3
37046: PUSH
37047: EMPTY
37048: LIST
37049: LIST
37050: PUSH
37051: LD_INT 2
37053: PUSH
37054: LD_INT 3
37056: PUSH
37057: EMPTY
37058: LIST
37059: LIST
37060: PUSH
37061: LD_INT 1
37063: PUSH
37064: LD_INT 3
37066: PUSH
37067: EMPTY
37068: LIST
37069: LIST
37070: PUSH
37071: LD_INT 0
37073: PUSH
37074: LD_INT 3
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 1
37083: NEG
37084: PUSH
37085: LD_INT 2
37087: PUSH
37088: EMPTY
37089: LIST
37090: LIST
37091: PUSH
37092: LD_INT 3
37094: NEG
37095: PUSH
37096: LD_INT 2
37098: NEG
37099: PUSH
37100: EMPTY
37101: LIST
37102: LIST
37103: PUSH
37104: LD_INT 3
37106: NEG
37107: PUSH
37108: LD_INT 3
37110: NEG
37111: PUSH
37112: EMPTY
37113: LIST
37114: LIST
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: LIST
37135: LIST
37136: LIST
37137: LIST
37138: LIST
37139: LIST
37140: LIST
37141: LIST
37142: LIST
37143: LIST
37144: LIST
37145: LIST
37146: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37147: LD_ADDR_VAR 0 46
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: LD_INT 0
37157: PUSH
37158: EMPTY
37159: LIST
37160: LIST
37161: PUSH
37162: LD_INT 0
37164: PUSH
37165: LD_INT 1
37167: NEG
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 1
37175: PUSH
37176: LD_INT 0
37178: PUSH
37179: EMPTY
37180: LIST
37181: LIST
37182: PUSH
37183: LD_INT 1
37185: PUSH
37186: LD_INT 1
37188: PUSH
37189: EMPTY
37190: LIST
37191: LIST
37192: PUSH
37193: LD_INT 0
37195: PUSH
37196: LD_INT 1
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 1
37205: NEG
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 1
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: NEG
37229: PUSH
37230: LD_INT 2
37232: NEG
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 0
37240: PUSH
37241: LD_INT 2
37243: NEG
37244: PUSH
37245: EMPTY
37246: LIST
37247: LIST
37248: PUSH
37249: LD_INT 1
37251: PUSH
37252: LD_INT 1
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 2
37262: PUSH
37263: LD_INT 0
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: LD_INT 1
37275: PUSH
37276: EMPTY
37277: LIST
37278: LIST
37279: PUSH
37280: LD_INT 1
37282: PUSH
37283: LD_INT 2
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 0
37292: PUSH
37293: LD_INT 2
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 1
37302: NEG
37303: PUSH
37304: LD_INT 1
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 2
37313: NEG
37314: PUSH
37315: LD_INT 0
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: LD_INT 1
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 1
37336: NEG
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: PUSH
37357: LD_INT 1
37359: PUSH
37360: LD_INT 2
37362: NEG
37363: PUSH
37364: EMPTY
37365: LIST
37366: LIST
37367: PUSH
37368: LD_INT 2
37370: PUSH
37371: LD_INT 1
37373: NEG
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: LD_INT 0
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: LD_INT 1
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 1
37401: PUSH
37402: LD_INT 3
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 3
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: NEG
37422: PUSH
37423: LD_INT 2
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 2
37432: NEG
37433: PUSH
37434: LD_INT 1
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: LD_INT 0
37447: PUSH
37448: EMPTY
37449: LIST
37450: LIST
37451: PUSH
37452: LD_INT 3
37454: NEG
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: EMPTY
37461: LIST
37462: LIST
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: LIST
37468: LIST
37469: LIST
37470: LIST
37471: LIST
37472: LIST
37473: LIST
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: LIST
37484: LIST
37485: LIST
37486: LIST
37487: LIST
37488: LIST
37489: LIST
37490: LIST
37491: LIST
37492: LIST
37493: LIST
37494: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37495: LD_ADDR_VAR 0 47
37499: PUSH
37500: LD_INT 0
37502: PUSH
37503: LD_INT 0
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 0
37512: PUSH
37513: LD_INT 1
37515: NEG
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: LD_INT 0
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PUSH
37531: LD_INT 1
37533: PUSH
37534: LD_INT 1
37536: PUSH
37537: EMPTY
37538: LIST
37539: LIST
37540: PUSH
37541: LD_INT 0
37543: PUSH
37544: LD_INT 1
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 0
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 1
37564: NEG
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 1
37576: NEG
37577: PUSH
37578: LD_INT 2
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 0
37588: PUSH
37589: LD_INT 2
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 1
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: EMPTY
37605: LIST
37606: LIST
37607: PUSH
37608: LD_INT 2
37610: NEG
37611: PUSH
37612: LD_INT 1
37614: NEG
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: NEG
37623: PUSH
37624: LD_INT 2
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37646: LD_ADDR_VAR 0 48
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: LD_INT 0
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 0
37663: PUSH
37664: LD_INT 1
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 1
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 1
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: LD_INT 1
37719: NEG
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: PUSH
37725: LD_INT 1
37727: NEG
37728: PUSH
37729: LD_INT 2
37731: NEG
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 2
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 1
37750: PUSH
37751: LD_INT 1
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 2
37761: PUSH
37762: LD_INT 0
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: PUSH
37772: LD_INT 1
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: LIST
37783: LIST
37784: LIST
37785: LIST
37786: LIST
37787: LIST
37788: LIST
37789: LIST
37790: LIST
37791: LIST
37792: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37793: LD_ADDR_VAR 0 49
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: LD_INT 0
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: LD_INT 0
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 1
37821: PUSH
37822: LD_INT 0
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: LD_INT 1
37831: PUSH
37832: LD_INT 1
37834: PUSH
37835: EMPTY
37836: LIST
37837: LIST
37838: PUSH
37839: LD_INT 0
37841: PUSH
37842: LD_INT 1
37844: PUSH
37845: EMPTY
37846: LIST
37847: LIST
37848: PUSH
37849: LD_INT 1
37851: NEG
37852: PUSH
37853: LD_INT 0
37855: PUSH
37856: EMPTY
37857: LIST
37858: LIST
37859: PUSH
37860: LD_INT 1
37862: NEG
37863: PUSH
37864: LD_INT 1
37866: NEG
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: LD_INT 1
37877: NEG
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: PUSH
37886: LD_INT 0
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: PUSH
37893: LD_INT 2
37895: PUSH
37896: LD_INT 1
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 2
37905: PUSH
37906: LD_INT 2
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 1
37915: PUSH
37916: LD_INT 2
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37937: LD_ADDR_VAR 0 50
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: LD_INT 1
37957: NEG
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 1
37965: PUSH
37966: LD_INT 0
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 1
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: LD_INT 1
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: LD_INT 0
37999: PUSH
38000: EMPTY
38001: LIST
38002: LIST
38003: PUSH
38004: LD_INT 1
38006: NEG
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 2
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: LD_INT 2
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 0
38048: PUSH
38049: LD_INT 2
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: NEG
38059: PUSH
38060: LD_INT 1
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38081: LD_ADDR_VAR 0 51
38085: PUSH
38086: LD_INT 0
38088: PUSH
38089: LD_INT 0
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: LD_INT 1
38101: NEG
38102: PUSH
38103: EMPTY
38104: LIST
38105: LIST
38106: PUSH
38107: LD_INT 1
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: LD_INT 1
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 0
38129: PUSH
38130: LD_INT 1
38132: PUSH
38133: EMPTY
38134: LIST
38135: LIST
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: LD_INT 0
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: NEG
38151: PUSH
38152: LD_INT 1
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: PUSH
38163: LD_INT 2
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 0
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 1
38182: NEG
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 2
38193: NEG
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: LD_INT 1
38208: NEG
38209: PUSH
38210: EMPTY
38211: LIST
38212: LIST
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: LIST
38218: LIST
38219: LIST
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38228: LD_ADDR_VAR 0 52
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 0
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: LD_INT 1
38248: NEG
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 1
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 1
38266: PUSH
38267: LD_INT 1
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 0
38276: PUSH
38277: LD_INT 1
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: NEG
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 1
38297: NEG
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PUSH
38307: LD_INT 1
38309: NEG
38310: PUSH
38311: LD_INT 2
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 1
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 2
38332: NEG
38333: PUSH
38334: LD_INT 0
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 2
38343: NEG
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 2
38355: NEG
38356: PUSH
38357: LD_INT 2
38359: NEG
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38379: LD_ADDR_VAR 0 53
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: LD_INT 1
38399: NEG
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: LD_INT 1
38417: PUSH
38418: LD_INT 1
38420: PUSH
38421: EMPTY
38422: LIST
38423: LIST
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 1
38437: NEG
38438: PUSH
38439: LD_INT 0
38441: PUSH
38442: EMPTY
38443: LIST
38444: LIST
38445: PUSH
38446: LD_INT 1
38448: NEG
38449: PUSH
38450: LD_INT 1
38452: NEG
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: LD_INT 2
38464: NEG
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: LD_INT 2
38475: NEG
38476: PUSH
38477: EMPTY
38478: LIST
38479: LIST
38480: PUSH
38481: LD_INT 1
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 2
38494: PUSH
38495: LD_INT 0
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 2
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 2
38514: PUSH
38515: LD_INT 2
38517: PUSH
38518: EMPTY
38519: LIST
38520: LIST
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: LD_INT 2
38527: PUSH
38528: EMPTY
38529: LIST
38530: LIST
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: LD_INT 2
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 2
38555: NEG
38556: PUSH
38557: LD_INT 0
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 2
38566: NEG
38567: PUSH
38568: LD_INT 1
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 2
38578: NEG
38579: PUSH
38580: LD_INT 2
38582: NEG
38583: PUSH
38584: EMPTY
38585: LIST
38586: LIST
38587: PUSH
38588: EMPTY
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: LIST
38601: LIST
38602: LIST
38603: LIST
38604: LIST
38605: LIST
38606: LIST
38607: LIST
38608: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38609: LD_ADDR_VAR 0 54
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: LD_INT 1
38629: NEG
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 1
38647: PUSH
38648: LD_INT 1
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: LD_INT 0
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: NEG
38679: PUSH
38680: LD_INT 1
38682: NEG
38683: PUSH
38684: EMPTY
38685: LIST
38686: LIST
38687: PUSH
38688: LD_INT 1
38690: NEG
38691: PUSH
38692: LD_INT 2
38694: NEG
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: LD_INT 2
38705: NEG
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 1
38713: PUSH
38714: LD_INT 1
38716: NEG
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: PUSH
38725: LD_INT 0
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 2
38734: PUSH
38735: LD_INT 1
38737: PUSH
38738: EMPTY
38739: LIST
38740: LIST
38741: PUSH
38742: LD_INT 2
38744: PUSH
38745: LD_INT 2
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PUSH
38752: LD_INT 1
38754: PUSH
38755: LD_INT 2
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 0
38764: PUSH
38765: LD_INT 2
38767: PUSH
38768: EMPTY
38769: LIST
38770: LIST
38771: PUSH
38772: LD_INT 1
38774: NEG
38775: PUSH
38776: LD_INT 1
38778: PUSH
38779: EMPTY
38780: LIST
38781: LIST
38782: PUSH
38783: LD_INT 2
38785: NEG
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: NEG
38797: PUSH
38798: LD_INT 1
38800: NEG
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 2
38808: NEG
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: LIST
38822: LIST
38823: LIST
38824: LIST
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: LIST
38838: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38839: LD_ADDR_VAR 0 55
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: LD_INT 0
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 0
38856: PUSH
38857: LD_INT 1
38859: NEG
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: LD_INT 1
38867: PUSH
38868: LD_INT 0
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 1
38877: PUSH
38878: LD_INT 1
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 0
38887: PUSH
38888: LD_INT 1
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: NEG
38898: PUSH
38899: LD_INT 0
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 1
38912: NEG
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 1
38920: NEG
38921: PUSH
38922: LD_INT 2
38924: NEG
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: LD_INT 2
38935: NEG
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: LD_INT 2
38954: PUSH
38955: LD_INT 0
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 2
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 2
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 2
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 2
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 2
39015: NEG
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: NEG
39027: PUSH
39028: LD_INT 1
39030: NEG
39031: PUSH
39032: EMPTY
39033: LIST
39034: LIST
39035: PUSH
39036: LD_INT 2
39038: NEG
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: EMPTY
39045: LIST
39046: LIST
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: LIST
39068: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39069: LD_ADDR_VAR 0 56
39073: PUSH
39074: LD_INT 0
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 0
39086: PUSH
39087: LD_INT 1
39089: NEG
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 1
39097: PUSH
39098: LD_INT 0
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: LD_INT 1
39107: PUSH
39108: LD_INT 1
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 0
39117: PUSH
39118: LD_INT 1
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 1
39127: NEG
39128: PUSH
39129: LD_INT 0
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: LD_INT 1
39138: NEG
39139: PUSH
39140: LD_INT 1
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: LD_INT 2
39154: NEG
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: PUSH
39160: LD_INT 0
39162: PUSH
39163: LD_INT 2
39165: NEG
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 2
39184: PUSH
39185: LD_INT 0
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 2
39194: PUSH
39195: LD_INT 1
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 2
39204: PUSH
39205: LD_INT 2
39207: PUSH
39208: EMPTY
39209: LIST
39210: LIST
39211: PUSH
39212: LD_INT 1
39214: PUSH
39215: LD_INT 2
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 0
39224: PUSH
39225: LD_INT 2
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 1
39234: NEG
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: PUSH
39243: LD_INT 2
39245: NEG
39246: PUSH
39247: LD_INT 0
39249: PUSH
39250: EMPTY
39251: LIST
39252: LIST
39253: PUSH
39254: LD_INT 2
39256: NEG
39257: PUSH
39258: LD_INT 1
39260: NEG
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 2
39268: NEG
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39299: LD_ADDR_VAR 0 57
39303: PUSH
39304: LD_INT 0
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 1
39319: NEG
39320: PUSH
39321: EMPTY
39322: LIST
39323: LIST
39324: PUSH
39325: LD_INT 1
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: PUSH
39338: LD_INT 1
39340: PUSH
39341: EMPTY
39342: LIST
39343: LIST
39344: PUSH
39345: LD_INT 0
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 1
39357: NEG
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 1
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 1
39380: NEG
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 0
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: LD_INT 1
39406: NEG
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 2
39414: PUSH
39415: LD_INT 0
39417: PUSH
39418: EMPTY
39419: LIST
39420: LIST
39421: PUSH
39422: LD_INT 2
39424: PUSH
39425: LD_INT 1
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 2
39434: PUSH
39435: LD_INT 2
39437: PUSH
39438: EMPTY
39439: LIST
39440: LIST
39441: PUSH
39442: LD_INT 1
39444: PUSH
39445: LD_INT 2
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 0
39454: PUSH
39455: LD_INT 2
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 1
39464: NEG
39465: PUSH
39466: LD_INT 1
39468: PUSH
39469: EMPTY
39470: LIST
39471: LIST
39472: PUSH
39473: LD_INT 2
39475: NEG
39476: PUSH
39477: LD_INT 0
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 2
39486: NEG
39487: PUSH
39488: LD_INT 1
39490: NEG
39491: PUSH
39492: EMPTY
39493: LIST
39494: LIST
39495: PUSH
39496: LD_INT 2
39498: NEG
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39529: LD_ADDR_VAR 0 58
39533: PUSH
39534: LD_INT 0
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 0
39546: PUSH
39547: LD_INT 1
39549: NEG
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 1
39557: PUSH
39558: LD_INT 0
39560: PUSH
39561: EMPTY
39562: LIST
39563: LIST
39564: PUSH
39565: LD_INT 1
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: EMPTY
39572: LIST
39573: LIST
39574: PUSH
39575: LD_INT 0
39577: PUSH
39578: LD_INT 1
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 1
39587: NEG
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 1
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 1
39610: NEG
39611: PUSH
39612: LD_INT 2
39614: NEG
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 0
39622: PUSH
39623: LD_INT 2
39625: NEG
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 1
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 2
39644: PUSH
39645: LD_INT 0
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 2
39654: PUSH
39655: LD_INT 1
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 2
39664: PUSH
39665: LD_INT 2
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 1
39674: PUSH
39675: LD_INT 2
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: LD_INT 2
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: NEG
39695: PUSH
39696: LD_INT 1
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 2
39705: NEG
39706: PUSH
39707: LD_INT 0
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 2
39716: NEG
39717: PUSH
39718: LD_INT 1
39720: NEG
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: LD_INT 2
39728: NEG
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39759: LD_ADDR_VAR 0 59
39763: PUSH
39764: LD_INT 0
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 0
39776: PUSH
39777: LD_INT 1
39779: NEG
39780: PUSH
39781: EMPTY
39782: LIST
39783: LIST
39784: PUSH
39785: LD_INT 1
39787: PUSH
39788: LD_INT 0
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 1
39797: PUSH
39798: LD_INT 1
39800: PUSH
39801: EMPTY
39802: LIST
39803: LIST
39804: PUSH
39805: LD_INT 0
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 1
39817: NEG
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 1
39828: NEG
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: LIST
39842: LIST
39843: LIST
39844: LIST
39845: LIST
39846: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39847: LD_ADDR_VAR 0 60
39851: PUSH
39852: LD_INT 0
39854: PUSH
39855: LD_INT 0
39857: PUSH
39858: EMPTY
39859: LIST
39860: LIST
39861: PUSH
39862: LD_INT 0
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: EMPTY
39870: LIST
39871: LIST
39872: PUSH
39873: LD_INT 1
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: PUSH
39886: LD_INT 1
39888: PUSH
39889: EMPTY
39890: LIST
39891: LIST
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: LD_INT 1
39898: PUSH
39899: EMPTY
39900: LIST
39901: LIST
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 1
39916: NEG
39917: PUSH
39918: LD_INT 1
39920: NEG
39921: PUSH
39922: EMPTY
39923: LIST
39924: LIST
39925: PUSH
39926: EMPTY
39927: LIST
39928: LIST
39929: LIST
39930: LIST
39931: LIST
39932: LIST
39933: LIST
39934: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39935: LD_ADDR_VAR 0 61
39939: PUSH
39940: LD_INT 0
39942: PUSH
39943: LD_INT 0
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 0
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 1
39973: PUSH
39974: LD_INT 1
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 1
39986: PUSH
39987: EMPTY
39988: LIST
39989: LIST
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: LD_INT 0
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: NEG
40005: PUSH
40006: LD_INT 1
40008: NEG
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: EMPTY
40015: LIST
40016: LIST
40017: LIST
40018: LIST
40019: LIST
40020: LIST
40021: LIST
40022: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40023: LD_ADDR_VAR 0 62
40027: PUSH
40028: LD_INT 0
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 0
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: EMPTY
40056: LIST
40057: LIST
40058: PUSH
40059: LD_INT 1
40061: PUSH
40062: LD_INT 1
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 1
40081: NEG
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: NEG
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: EMPTY
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40111: LD_ADDR_VAR 0 63
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 0
40121: PUSH
40122: EMPTY
40123: LIST
40124: LIST
40125: PUSH
40126: LD_INT 0
40128: PUSH
40129: LD_INT 1
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 1
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 0
40159: PUSH
40160: LD_INT 1
40162: PUSH
40163: EMPTY
40164: LIST
40165: LIST
40166: PUSH
40167: LD_INT 1
40169: NEG
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 1
40180: NEG
40181: PUSH
40182: LD_INT 1
40184: NEG
40185: PUSH
40186: EMPTY
40187: LIST
40188: LIST
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: LIST
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40199: LD_ADDR_VAR 0 64
40203: PUSH
40204: LD_INT 0
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 0
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: PUSH
40225: LD_INT 1
40227: PUSH
40228: LD_INT 0
40230: PUSH
40231: EMPTY
40232: LIST
40233: LIST
40234: PUSH
40235: LD_INT 1
40237: PUSH
40238: LD_INT 1
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: PUSH
40245: LD_INT 0
40247: PUSH
40248: LD_INT 1
40250: PUSH
40251: EMPTY
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 1
40257: NEG
40258: PUSH
40259: LD_INT 0
40261: PUSH
40262: EMPTY
40263: LIST
40264: LIST
40265: PUSH
40266: LD_INT 1
40268: NEG
40269: PUSH
40270: LD_INT 1
40272: NEG
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: LIST
40282: LIST
40283: LIST
40284: LIST
40285: LIST
40286: ST_TO_ADDR
// end ; 1 :
40287: GO 46184
40289: LD_INT 1
40291: DOUBLE
40292: EQUAL
40293: IFTRUE 40297
40295: GO 42920
40297: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40298: LD_ADDR_VAR 0 11
40302: PUSH
40303: LD_INT 1
40305: NEG
40306: PUSH
40307: LD_INT 3
40309: NEG
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 3
40320: NEG
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 1
40328: PUSH
40329: LD_INT 2
40331: NEG
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: LIST
40341: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40342: LD_ADDR_VAR 0 12
40346: PUSH
40347: LD_INT 2
40349: PUSH
40350: LD_INT 1
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 3
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: LD_INT 1
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: LIST
40382: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40383: LD_ADDR_VAR 0 13
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: LD_INT 2
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 3
40400: PUSH
40401: LD_INT 3
40403: PUSH
40404: EMPTY
40405: LIST
40406: LIST
40407: PUSH
40408: LD_INT 2
40410: PUSH
40411: LD_INT 3
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: LIST
40422: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40423: LD_ADDR_VAR 0 14
40427: PUSH
40428: LD_INT 1
40430: PUSH
40431: LD_INT 3
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 0
40440: PUSH
40441: LD_INT 3
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 1
40450: NEG
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: LIST
40463: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40464: LD_ADDR_VAR 0 15
40468: PUSH
40469: LD_INT 2
40471: NEG
40472: PUSH
40473: LD_INT 1
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 3
40482: NEG
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 3
40493: NEG
40494: PUSH
40495: LD_INT 1
40497: NEG
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: LIST
40507: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40508: LD_ADDR_VAR 0 16
40512: PUSH
40513: LD_INT 2
40515: NEG
40516: PUSH
40517: LD_INT 3
40519: NEG
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 3
40527: NEG
40528: PUSH
40529: LD_INT 2
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 3
40539: NEG
40540: PUSH
40541: LD_INT 3
40543: NEG
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: LIST
40553: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40554: LD_ADDR_VAR 0 17
40558: PUSH
40559: LD_INT 1
40561: NEG
40562: PUSH
40563: LD_INT 3
40565: NEG
40566: PUSH
40567: EMPTY
40568: LIST
40569: LIST
40570: PUSH
40571: LD_INT 0
40573: PUSH
40574: LD_INT 3
40576: NEG
40577: PUSH
40578: EMPTY
40579: LIST
40580: LIST
40581: PUSH
40582: LD_INT 1
40584: PUSH
40585: LD_INT 2
40587: NEG
40588: PUSH
40589: EMPTY
40590: LIST
40591: LIST
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: LIST
40597: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40598: LD_ADDR_VAR 0 18
40602: PUSH
40603: LD_INT 2
40605: PUSH
40606: LD_INT 1
40608: NEG
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 3
40616: PUSH
40617: LD_INT 0
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 3
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: EMPTY
40635: LIST
40636: LIST
40637: LIST
40638: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40639: LD_ADDR_VAR 0 19
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: LD_INT 2
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 3
40656: PUSH
40657: LD_INT 3
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 2
40666: PUSH
40667: LD_INT 3
40669: PUSH
40670: EMPTY
40671: LIST
40672: LIST
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: LIST
40678: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40679: LD_ADDR_VAR 0 20
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 3
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 0
40696: PUSH
40697: LD_INT 3
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 1
40706: NEG
40707: PUSH
40708: LD_INT 2
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: PUSH
40715: EMPTY
40716: LIST
40717: LIST
40718: LIST
40719: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40720: LD_ADDR_VAR 0 21
40724: PUSH
40725: LD_INT 2
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: LD_INT 3
40738: NEG
40739: PUSH
40740: LD_INT 0
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 3
40749: NEG
40750: PUSH
40751: LD_INT 1
40753: NEG
40754: PUSH
40755: EMPTY
40756: LIST
40757: LIST
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: LIST
40763: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40764: LD_ADDR_VAR 0 22
40768: PUSH
40769: LD_INT 2
40771: NEG
40772: PUSH
40773: LD_INT 3
40775: NEG
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: PUSH
40781: LD_INT 3
40783: NEG
40784: PUSH
40785: LD_INT 2
40787: NEG
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 3
40795: NEG
40796: PUSH
40797: LD_INT 3
40799: NEG
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: LIST
40809: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40810: LD_ADDR_VAR 0 23
40814: PUSH
40815: LD_INT 0
40817: PUSH
40818: LD_INT 3
40820: NEG
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: LD_INT 1
40828: NEG
40829: PUSH
40830: LD_INT 4
40832: NEG
40833: PUSH
40834: EMPTY
40835: LIST
40836: LIST
40837: PUSH
40838: LD_INT 1
40840: PUSH
40841: LD_INT 3
40843: NEG
40844: PUSH
40845: EMPTY
40846: LIST
40847: LIST
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: LIST
40853: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40854: LD_ADDR_VAR 0 24
40858: PUSH
40859: LD_INT 3
40861: PUSH
40862: LD_INT 0
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 3
40871: PUSH
40872: LD_INT 1
40874: NEG
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 4
40882: PUSH
40883: LD_INT 1
40885: PUSH
40886: EMPTY
40887: LIST
40888: LIST
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: LIST
40894: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40895: LD_ADDR_VAR 0 25
40899: PUSH
40900: LD_INT 3
40902: PUSH
40903: LD_INT 3
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 4
40912: PUSH
40913: LD_INT 3
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: LD_INT 3
40922: PUSH
40923: LD_INT 4
40925: PUSH
40926: EMPTY
40927: LIST
40928: LIST
40929: PUSH
40930: EMPTY
40931: LIST
40932: LIST
40933: LIST
40934: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40935: LD_ADDR_VAR 0 26
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 3
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: PUSH
40953: LD_INT 4
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 1
40962: NEG
40963: PUSH
40964: LD_INT 3
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: LIST
40975: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40976: LD_ADDR_VAR 0 27
40980: PUSH
40981: LD_INT 3
40983: NEG
40984: PUSH
40985: LD_INT 0
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: LD_INT 3
40994: NEG
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 4
41005: NEG
41006: PUSH
41007: LD_INT 1
41009: NEG
41010: PUSH
41011: EMPTY
41012: LIST
41013: LIST
41014: PUSH
41015: EMPTY
41016: LIST
41017: LIST
41018: LIST
41019: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41020: LD_ADDR_VAR 0 28
41024: PUSH
41025: LD_INT 3
41027: NEG
41028: PUSH
41029: LD_INT 3
41031: NEG
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: LD_INT 4
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 4
41051: NEG
41052: PUSH
41053: LD_INT 3
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: EMPTY
41062: LIST
41063: LIST
41064: LIST
41065: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41066: LD_ADDR_VAR 0 29
41070: PUSH
41071: LD_INT 1
41073: NEG
41074: PUSH
41075: LD_INT 3
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 0
41085: PUSH
41086: LD_INT 3
41088: NEG
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 1
41096: PUSH
41097: LD_INT 2
41099: NEG
41100: PUSH
41101: EMPTY
41102: LIST
41103: LIST
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 4
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 4
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 3
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: LD_INT 5
41145: NEG
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 0
41153: PUSH
41154: LD_INT 5
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: LD_INT 4
41167: NEG
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 1
41175: NEG
41176: PUSH
41177: LD_INT 6
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 0
41187: PUSH
41188: LD_INT 6
41190: NEG
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: LD_INT 5
41201: NEG
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: LIST
41211: LIST
41212: LIST
41213: LIST
41214: LIST
41215: LIST
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41221: LD_ADDR_VAR 0 30
41225: PUSH
41226: LD_INT 2
41228: PUSH
41229: LD_INT 1
41231: NEG
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 3
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 3
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 3
41259: PUSH
41260: LD_INT 1
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 4
41270: PUSH
41271: LD_INT 0
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 4
41280: PUSH
41281: LD_INT 1
41283: PUSH
41284: EMPTY
41285: LIST
41286: LIST
41287: PUSH
41288: LD_INT 4
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: PUSH
41299: LD_INT 5
41301: PUSH
41302: LD_INT 0
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: PUSH
41309: LD_INT 5
41311: PUSH
41312: LD_INT 1
41314: PUSH
41315: EMPTY
41316: LIST
41317: LIST
41318: PUSH
41319: LD_INT 5
41321: PUSH
41322: LD_INT 1
41324: NEG
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 6
41332: PUSH
41333: LD_INT 0
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 6
41342: PUSH
41343: LD_INT 1
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: EMPTY
41351: LIST
41352: LIST
41353: LIST
41354: LIST
41355: LIST
41356: LIST
41357: LIST
41358: LIST
41359: LIST
41360: LIST
41361: LIST
41362: LIST
41363: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41364: LD_ADDR_VAR 0 31
41368: PUSH
41369: LD_INT 3
41371: PUSH
41372: LD_INT 2
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 3
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 2
41391: PUSH
41392: LD_INT 3
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: PUSH
41399: LD_INT 4
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 4
41411: PUSH
41412: LD_INT 4
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 3
41421: PUSH
41422: LD_INT 4
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: PUSH
41429: LD_INT 5
41431: PUSH
41432: LD_INT 4
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 5
41441: PUSH
41442: LD_INT 5
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 4
41451: PUSH
41452: LD_INT 5
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 6
41461: PUSH
41462: LD_INT 5
41464: PUSH
41465: EMPTY
41466: LIST
41467: LIST
41468: PUSH
41469: LD_INT 6
41471: PUSH
41472: LD_INT 6
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 5
41481: PUSH
41482: LD_INT 6
41484: PUSH
41485: EMPTY
41486: LIST
41487: LIST
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: LIST
41493: LIST
41494: LIST
41495: LIST
41496: LIST
41497: LIST
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41503: LD_ADDR_VAR 0 32
41507: PUSH
41508: LD_INT 1
41510: PUSH
41511: LD_INT 3
41513: PUSH
41514: EMPTY
41515: LIST
41516: LIST
41517: PUSH
41518: LD_INT 0
41520: PUSH
41521: LD_INT 3
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: LD_INT 1
41530: NEG
41531: PUSH
41532: LD_INT 2
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 1
41541: PUSH
41542: LD_INT 4
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 0
41551: PUSH
41552: LD_INT 4
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 1
41561: NEG
41562: PUSH
41563: LD_INT 3
41565: PUSH
41566: EMPTY
41567: LIST
41568: LIST
41569: PUSH
41570: LD_INT 1
41572: PUSH
41573: LD_INT 5
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: PUSH
41580: LD_INT 0
41582: PUSH
41583: LD_INT 5
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 1
41592: NEG
41593: PUSH
41594: LD_INT 4
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: PUSH
41601: LD_INT 1
41603: PUSH
41604: LD_INT 6
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: PUSH
41611: LD_INT 0
41613: PUSH
41614: LD_INT 6
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 1
41623: NEG
41624: PUSH
41625: LD_INT 5
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: LIST
41639: LIST
41640: LIST
41641: LIST
41642: LIST
41643: LIST
41644: LIST
41645: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41646: LD_ADDR_VAR 0 33
41650: PUSH
41651: LD_INT 2
41653: NEG
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: EMPTY
41659: LIST
41660: LIST
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: LD_INT 0
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: LD_INT 1
41679: NEG
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 3
41687: NEG
41688: PUSH
41689: LD_INT 1
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 4
41698: NEG
41699: PUSH
41700: LD_INT 0
41702: PUSH
41703: EMPTY
41704: LIST
41705: LIST
41706: PUSH
41707: LD_INT 4
41709: NEG
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 4
41721: NEG
41722: PUSH
41723: LD_INT 1
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: PUSH
41730: LD_INT 5
41732: NEG
41733: PUSH
41734: LD_INT 0
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: PUSH
41741: LD_INT 5
41743: NEG
41744: PUSH
41745: LD_INT 1
41747: NEG
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: LD_INT 5
41755: NEG
41756: PUSH
41757: LD_INT 1
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 6
41766: NEG
41767: PUSH
41768: LD_INT 0
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 6
41777: NEG
41778: PUSH
41779: LD_INT 1
41781: NEG
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41801: LD_ADDR_VAR 0 34
41805: PUSH
41806: LD_INT 2
41808: NEG
41809: PUSH
41810: LD_INT 3
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: LD_INT 2
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 3
41832: NEG
41833: PUSH
41834: LD_INT 3
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: NEG
41845: PUSH
41846: LD_INT 4
41848: NEG
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 4
41856: NEG
41857: PUSH
41858: LD_INT 3
41860: NEG
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 4
41868: NEG
41869: PUSH
41870: LD_INT 4
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 4
41880: NEG
41881: PUSH
41882: LD_INT 5
41884: NEG
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 5
41892: NEG
41893: PUSH
41894: LD_INT 4
41896: NEG
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 5
41904: NEG
41905: PUSH
41906: LD_INT 5
41908: NEG
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 5
41916: NEG
41917: PUSH
41918: LD_INT 6
41920: NEG
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: PUSH
41926: LD_INT 6
41928: NEG
41929: PUSH
41930: LD_INT 5
41932: NEG
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 6
41940: NEG
41941: PUSH
41942: LD_INT 6
41944: NEG
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: EMPTY
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: LIST
41962: LIST
41963: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41964: LD_ADDR_VAR 0 41
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: LD_INT 2
41974: NEG
41975: PUSH
41976: EMPTY
41977: LIST
41978: LIST
41979: PUSH
41980: LD_INT 1
41982: NEG
41983: PUSH
41984: LD_INT 3
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: LIST
42007: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42008: LD_ADDR_VAR 0 42
42012: PUSH
42013: LD_INT 2
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 2
42025: PUSH
42026: LD_INT 1
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 3
42036: PUSH
42037: LD_INT 1
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: LIST
42048: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42049: LD_ADDR_VAR 0 43
42053: PUSH
42054: LD_INT 2
42056: PUSH
42057: LD_INT 2
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: PUSH
42067: LD_INT 2
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 2
42076: PUSH
42077: LD_INT 3
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: LIST
42088: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42089: LD_ADDR_VAR 0 44
42093: PUSH
42094: LD_INT 0
42096: PUSH
42097: LD_INT 2
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 1
42106: PUSH
42107: LD_INT 3
42109: PUSH
42110: EMPTY
42111: LIST
42112: LIST
42113: PUSH
42114: LD_INT 1
42116: NEG
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: EMPTY
42122: LIST
42123: LIST
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: LIST
42129: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42130: LD_ADDR_VAR 0 45
42134: PUSH
42135: LD_INT 2
42137: NEG
42138: PUSH
42139: LD_INT 0
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 2
42148: NEG
42149: PUSH
42150: LD_INT 1
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 3
42159: NEG
42160: PUSH
42161: LD_INT 1
42163: NEG
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: LIST
42173: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42174: LD_ADDR_VAR 0 46
42178: PUSH
42179: LD_INT 2
42181: NEG
42182: PUSH
42183: LD_INT 2
42185: NEG
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 2
42193: NEG
42194: PUSH
42195: LD_INT 3
42197: NEG
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PUSH
42203: LD_INT 3
42205: NEG
42206: PUSH
42207: LD_INT 2
42209: NEG
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: LIST
42219: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42220: LD_ADDR_VAR 0 47
42224: PUSH
42225: LD_INT 2
42227: NEG
42228: PUSH
42229: LD_INT 3
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42253: LD_ADDR_VAR 0 48
42257: PUSH
42258: LD_INT 1
42260: PUSH
42261: LD_INT 2
42263: NEG
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 2
42271: PUSH
42272: LD_INT 1
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42284: LD_ADDR_VAR 0 49
42288: PUSH
42289: LD_INT 3
42291: PUSH
42292: LD_INT 1
42294: PUSH
42295: EMPTY
42296: LIST
42297: LIST
42298: PUSH
42299: LD_INT 3
42301: PUSH
42302: LD_INT 2
42304: PUSH
42305: EMPTY
42306: LIST
42307: LIST
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42313: LD_ADDR_VAR 0 50
42317: PUSH
42318: LD_INT 2
42320: PUSH
42321: LD_INT 3
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 1
42330: PUSH
42331: LD_INT 3
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: EMPTY
42339: LIST
42340: LIST
42341: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42342: LD_ADDR_VAR 0 51
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: LD_INT 2
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 2
42360: NEG
42361: PUSH
42362: LD_INT 1
42364: PUSH
42365: EMPTY
42366: LIST
42367: LIST
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42373: LD_ADDR_VAR 0 52
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: EMPTY
42387: LIST
42388: LIST
42389: PUSH
42390: LD_INT 3
42392: NEG
42393: PUSH
42394: LD_INT 2
42396: NEG
42397: PUSH
42398: EMPTY
42399: LIST
42400: LIST
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42406: LD_ADDR_VAR 0 53
42410: PUSH
42411: LD_INT 1
42413: NEG
42414: PUSH
42415: LD_INT 3
42417: NEG
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 0
42425: PUSH
42426: LD_INT 3
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 1
42436: PUSH
42437: LD_INT 2
42439: NEG
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: LIST
42449: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42450: LD_ADDR_VAR 0 54
42454: PUSH
42455: LD_INT 2
42457: PUSH
42458: LD_INT 1
42460: NEG
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 3
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 3
42478: PUSH
42479: LD_INT 1
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: LIST
42490: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42491: LD_ADDR_VAR 0 55
42495: PUSH
42496: LD_INT 3
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 3
42508: PUSH
42509: LD_INT 3
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 2
42518: PUSH
42519: LD_INT 3
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: LIST
42530: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42531: LD_ADDR_VAR 0 56
42535: PUSH
42536: LD_INT 1
42538: PUSH
42539: LD_INT 3
42541: PUSH
42542: EMPTY
42543: LIST
42544: LIST
42545: PUSH
42546: LD_INT 0
42548: PUSH
42549: LD_INT 3
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 1
42558: NEG
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: LIST
42571: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42572: LD_ADDR_VAR 0 57
42576: PUSH
42577: LD_INT 2
42579: NEG
42580: PUSH
42581: LD_INT 1
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 3
42590: NEG
42591: PUSH
42592: LD_INT 0
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: PUSH
42599: LD_INT 3
42601: NEG
42602: PUSH
42603: LD_INT 1
42605: NEG
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: LIST
42615: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42616: LD_ADDR_VAR 0 58
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: LD_INT 3
42627: NEG
42628: PUSH
42629: EMPTY
42630: LIST
42631: LIST
42632: PUSH
42633: LD_INT 3
42635: NEG
42636: PUSH
42637: LD_INT 2
42639: NEG
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 3
42647: NEG
42648: PUSH
42649: LD_INT 3
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: LIST
42661: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42662: LD_ADDR_VAR 0 59
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: LD_INT 2
42673: NEG
42674: PUSH
42675: EMPTY
42676: LIST
42677: LIST
42678: PUSH
42679: LD_INT 0
42681: PUSH
42682: LD_INT 2
42684: NEG
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: LD_INT 1
42695: NEG
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: LIST
42705: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42706: LD_ADDR_VAR 0 60
42710: PUSH
42711: LD_INT 1
42713: PUSH
42714: LD_INT 1
42716: NEG
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 2
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 2
42734: PUSH
42735: LD_INT 1
42737: PUSH
42738: EMPTY
42739: LIST
42740: LIST
42741: PUSH
42742: EMPTY
42743: LIST
42744: LIST
42745: LIST
42746: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42747: LD_ADDR_VAR 0 61
42751: PUSH
42752: LD_INT 2
42754: PUSH
42755: LD_INT 1
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 2
42764: PUSH
42765: LD_INT 2
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 1
42774: PUSH
42775: LD_INT 2
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: EMPTY
42783: LIST
42784: LIST
42785: LIST
42786: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42787: LD_ADDR_VAR 0 62
42791: PUSH
42792: LD_INT 1
42794: PUSH
42795: LD_INT 2
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 0
42804: PUSH
42805: LD_INT 2
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 1
42814: NEG
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: LIST
42827: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42828: LD_ADDR_VAR 0 63
42832: PUSH
42833: LD_INT 1
42835: NEG
42836: PUSH
42837: LD_INT 1
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 2
42846: NEG
42847: PUSH
42848: LD_INT 0
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 2
42857: NEG
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: LIST
42871: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42872: LD_ADDR_VAR 0 64
42876: PUSH
42877: LD_INT 1
42879: NEG
42880: PUSH
42881: LD_INT 2
42883: NEG
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 2
42891: NEG
42892: PUSH
42893: LD_INT 1
42895: NEG
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 2
42903: NEG
42904: PUSH
42905: LD_INT 2
42907: NEG
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: LIST
42917: ST_TO_ADDR
// end ; 2 :
42918: GO 46184
42920: LD_INT 2
42922: DOUBLE
42923: EQUAL
42924: IFTRUE 42928
42926: GO 46183
42928: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42929: LD_ADDR_VAR 0 29
42933: PUSH
42934: LD_INT 4
42936: PUSH
42937: LD_INT 0
42939: PUSH
42940: EMPTY
42941: LIST
42942: LIST
42943: PUSH
42944: LD_INT 4
42946: PUSH
42947: LD_INT 1
42949: NEG
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 5
42957: PUSH
42958: LD_INT 0
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 5
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 4
42977: PUSH
42978: LD_INT 1
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 3
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 3
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: LD_INT 2
43011: NEG
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 5
43019: PUSH
43020: LD_INT 2
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 3
43029: PUSH
43030: LD_INT 3
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 3
43039: PUSH
43040: LD_INT 2
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 4
43049: PUSH
43050: LD_INT 3
43052: PUSH
43053: EMPTY
43054: LIST
43055: LIST
43056: PUSH
43057: LD_INT 4
43059: PUSH
43060: LD_INT 4
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 3
43069: PUSH
43070: LD_INT 4
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 3
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: PUSH
43090: LD_INT 2
43092: PUSH
43093: EMPTY
43094: LIST
43095: LIST
43096: PUSH
43097: LD_INT 4
43099: PUSH
43100: LD_INT 2
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: PUSH
43107: LD_INT 2
43109: PUSH
43110: LD_INT 4
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 0
43119: PUSH
43120: LD_INT 4
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: LD_INT 3
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: LD_INT 4
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 5
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: LD_INT 5
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: NEG
43170: PUSH
43171: LD_INT 4
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 1
43180: NEG
43181: PUSH
43182: LD_INT 3
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: PUSH
43192: LD_INT 5
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 2
43201: NEG
43202: PUSH
43203: LD_INT 3
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 3
43212: NEG
43213: PUSH
43214: LD_INT 0
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: NEG
43224: PUSH
43225: LD_INT 1
43227: NEG
43228: PUSH
43229: EMPTY
43230: LIST
43231: LIST
43232: PUSH
43233: LD_INT 2
43235: NEG
43236: PUSH
43237: LD_INT 0
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: LD_INT 2
43246: NEG
43247: PUSH
43248: LD_INT 1
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: PUSH
43255: LD_INT 3
43257: NEG
43258: PUSH
43259: LD_INT 1
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 4
43268: NEG
43269: PUSH
43270: LD_INT 0
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 4
43279: NEG
43280: PUSH
43281: LD_INT 1
43283: NEG
43284: PUSH
43285: EMPTY
43286: LIST
43287: LIST
43288: PUSH
43289: LD_INT 4
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: NEG
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 2
43303: NEG
43304: PUSH
43305: LD_INT 2
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 4
43314: NEG
43315: PUSH
43316: LD_INT 4
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 4
43326: NEG
43327: PUSH
43328: LD_INT 5
43330: NEG
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 3
43338: NEG
43339: PUSH
43340: LD_INT 4
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 3
43350: NEG
43351: PUSH
43352: LD_INT 3
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 4
43362: NEG
43363: PUSH
43364: LD_INT 3
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 5
43374: NEG
43375: PUSH
43376: LD_INT 4
43378: NEG
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 5
43386: NEG
43387: PUSH
43388: LD_INT 5
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 3
43398: NEG
43399: PUSH
43400: LD_INT 5
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 5
43410: NEG
43411: PUSH
43412: LD_INT 3
43414: NEG
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: LIST
43424: LIST
43425: LIST
43426: LIST
43427: LIST
43428: LIST
43429: LIST
43430: LIST
43431: LIST
43432: LIST
43433: LIST
43434: LIST
43435: LIST
43436: LIST
43437: LIST
43438: LIST
43439: LIST
43440: LIST
43441: LIST
43442: LIST
43443: LIST
43444: LIST
43445: LIST
43446: LIST
43447: LIST
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: LIST
43458: LIST
43459: LIST
43460: LIST
43461: LIST
43462: LIST
43463: LIST
43464: LIST
43465: LIST
43466: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43467: LD_ADDR_VAR 0 30
43471: PUSH
43472: LD_INT 4
43474: PUSH
43475: LD_INT 4
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 4
43484: PUSH
43485: LD_INT 3
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 5
43494: PUSH
43495: LD_INT 4
43497: PUSH
43498: EMPTY
43499: LIST
43500: LIST
43501: PUSH
43502: LD_INT 5
43504: PUSH
43505: LD_INT 5
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: LD_INT 5
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 3
43524: PUSH
43525: LD_INT 4
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: LD_INT 3
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 5
43544: PUSH
43545: LD_INT 3
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 3
43554: PUSH
43555: LD_INT 5
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 0
43564: PUSH
43565: LD_INT 3
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 0
43574: PUSH
43575: LD_INT 2
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 1
43584: PUSH
43585: LD_INT 3
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 1
43594: PUSH
43595: LD_INT 4
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 0
43604: PUSH
43605: LD_INT 4
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 1
43614: NEG
43615: PUSH
43616: LD_INT 3
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 1
43625: NEG
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 2
43636: PUSH
43637: LD_INT 4
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 2
43646: NEG
43647: PUSH
43648: LD_INT 2
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 4
43657: NEG
43658: PUSH
43659: LD_INT 0
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 4
43668: NEG
43669: PUSH
43670: LD_INT 1
43672: NEG
43673: PUSH
43674: EMPTY
43675: LIST
43676: LIST
43677: PUSH
43678: LD_INT 3
43680: NEG
43681: PUSH
43682: LD_INT 0
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 3
43691: NEG
43692: PUSH
43693: LD_INT 1
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 4
43702: NEG
43703: PUSH
43704: LD_INT 1
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: LD_INT 5
43713: NEG
43714: PUSH
43715: LD_INT 0
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: PUSH
43722: LD_INT 5
43724: NEG
43725: PUSH
43726: LD_INT 1
43728: NEG
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 5
43736: NEG
43737: PUSH
43738: LD_INT 2
43740: NEG
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 3
43748: NEG
43749: PUSH
43750: LD_INT 2
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 3
43759: NEG
43760: PUSH
43761: LD_INT 3
43763: NEG
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: LD_INT 4
43775: NEG
43776: PUSH
43777: EMPTY
43778: LIST
43779: LIST
43780: PUSH
43781: LD_INT 2
43783: NEG
43784: PUSH
43785: LD_INT 3
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 2
43795: NEG
43796: PUSH
43797: LD_INT 2
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 3
43807: NEG
43808: PUSH
43809: LD_INT 2
43811: NEG
43812: PUSH
43813: EMPTY
43814: LIST
43815: LIST
43816: PUSH
43817: LD_INT 4
43819: NEG
43820: PUSH
43821: LD_INT 3
43823: NEG
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 4
43831: NEG
43832: PUSH
43833: LD_INT 4
43835: NEG
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 2
43843: NEG
43844: PUSH
43845: LD_INT 4
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 4
43855: NEG
43856: PUSH
43857: LD_INT 2
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 4
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 0
43878: PUSH
43879: LD_INT 5
43881: NEG
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: LD_INT 4
43892: NEG
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 1
43900: PUSH
43901: LD_INT 3
43903: NEG
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: LD_INT 3
43914: NEG
43915: PUSH
43916: EMPTY
43917: LIST
43918: LIST
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: LD_INT 4
43926: NEG
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: PUSH
43932: LD_INT 1
43934: NEG
43935: PUSH
43936: LD_INT 5
43938: NEG
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 2
43946: PUSH
43947: LD_INT 3
43949: NEG
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 2
43957: NEG
43958: PUSH
43959: LD_INT 5
43961: NEG
43962: PUSH
43963: EMPTY
43964: LIST
43965: LIST
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: LIST
43987: LIST
43988: LIST
43989: LIST
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: LIST
44001: LIST
44002: LIST
44003: LIST
44004: LIST
44005: LIST
44006: LIST
44007: LIST
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44014: LD_ADDR_VAR 0 31
44018: PUSH
44019: LD_INT 0
44021: PUSH
44022: LD_INT 4
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 0
44031: PUSH
44032: LD_INT 3
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 1
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: LD_INT 5
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 0
44061: PUSH
44062: LD_INT 5
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: NEG
44072: PUSH
44073: LD_INT 4
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 1
44082: NEG
44083: PUSH
44084: LD_INT 3
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 2
44093: PUSH
44094: LD_INT 5
44096: PUSH
44097: EMPTY
44098: LIST
44099: LIST
44100: PUSH
44101: LD_INT 2
44103: NEG
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 3
44114: NEG
44115: PUSH
44116: LD_INT 0
44118: PUSH
44119: EMPTY
44120: LIST
44121: LIST
44122: PUSH
44123: LD_INT 3
44125: NEG
44126: PUSH
44127: LD_INT 1
44129: NEG
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 2
44137: NEG
44138: PUSH
44139: LD_INT 0
44141: PUSH
44142: EMPTY
44143: LIST
44144: LIST
44145: PUSH
44146: LD_INT 2
44148: NEG
44149: PUSH
44150: LD_INT 1
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: LD_INT 3
44159: NEG
44160: PUSH
44161: LD_INT 1
44163: PUSH
44164: EMPTY
44165: LIST
44166: LIST
44167: PUSH
44168: LD_INT 4
44170: NEG
44171: PUSH
44172: LD_INT 0
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 4
44181: NEG
44182: PUSH
44183: LD_INT 1
44185: NEG
44186: PUSH
44187: EMPTY
44188: LIST
44189: LIST
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: LD_INT 2
44197: NEG
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 2
44205: NEG
44206: PUSH
44207: LD_INT 2
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 4
44216: NEG
44217: PUSH
44218: LD_INT 4
44220: NEG
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: PUSH
44226: LD_INT 4
44228: NEG
44229: PUSH
44230: LD_INT 5
44232: NEG
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: LD_INT 3
44240: NEG
44241: PUSH
44242: LD_INT 4
44244: NEG
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 3
44252: NEG
44253: PUSH
44254: LD_INT 3
44256: NEG
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 4
44264: NEG
44265: PUSH
44266: LD_INT 3
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 5
44276: NEG
44277: PUSH
44278: LD_INT 4
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 5
44288: NEG
44289: PUSH
44290: LD_INT 5
44292: NEG
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 3
44300: NEG
44301: PUSH
44302: LD_INT 5
44304: NEG
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 5
44312: NEG
44313: PUSH
44314: LD_INT 3
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 0
44324: PUSH
44325: LD_INT 3
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 0
44335: PUSH
44336: LD_INT 4
44338: NEG
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 1
44346: PUSH
44347: LD_INT 3
44349: NEG
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 1
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: LD_INT 2
44371: NEG
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: LD_INT 1
44379: NEG
44380: PUSH
44381: LD_INT 3
44383: NEG
44384: PUSH
44385: EMPTY
44386: LIST
44387: LIST
44388: PUSH
44389: LD_INT 1
44391: NEG
44392: PUSH
44393: LD_INT 4
44395: NEG
44396: PUSH
44397: EMPTY
44398: LIST
44399: LIST
44400: PUSH
44401: LD_INT 2
44403: PUSH
44404: LD_INT 2
44406: NEG
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 2
44414: NEG
44415: PUSH
44416: LD_INT 4
44418: NEG
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: LD_INT 0
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 4
44436: PUSH
44437: LD_INT 1
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 5
44447: PUSH
44448: LD_INT 0
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 5
44457: PUSH
44458: LD_INT 1
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 4
44467: PUSH
44468: LD_INT 1
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 3
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 3
44487: PUSH
44488: LD_INT 1
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 3
44498: PUSH
44499: LD_INT 2
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 5
44509: PUSH
44510: LD_INT 2
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: LIST
44534: LIST
44535: LIST
44536: LIST
44537: LIST
44538: LIST
44539: LIST
44540: LIST
44541: LIST
44542: LIST
44543: LIST
44544: LIST
44545: LIST
44546: LIST
44547: LIST
44548: LIST
44549: LIST
44550: LIST
44551: LIST
44552: LIST
44553: LIST
44554: LIST
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44564: LD_ADDR_VAR 0 32
44568: PUSH
44569: LD_INT 4
44571: NEG
44572: PUSH
44573: LD_INT 0
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 4
44582: NEG
44583: PUSH
44584: LD_INT 1
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 3
44594: NEG
44595: PUSH
44596: LD_INT 0
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 3
44605: NEG
44606: PUSH
44607: LD_INT 1
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 4
44616: NEG
44617: PUSH
44618: LD_INT 1
44620: PUSH
44621: EMPTY
44622: LIST
44623: LIST
44624: PUSH
44625: LD_INT 5
44627: NEG
44628: PUSH
44629: LD_INT 0
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 5
44638: NEG
44639: PUSH
44640: LD_INT 1
44642: NEG
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 5
44650: NEG
44651: PUSH
44652: LD_INT 2
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 3
44662: NEG
44663: PUSH
44664: LD_INT 2
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 3
44673: NEG
44674: PUSH
44675: LD_INT 3
44677: NEG
44678: PUSH
44679: EMPTY
44680: LIST
44681: LIST
44682: PUSH
44683: LD_INT 3
44685: NEG
44686: PUSH
44687: LD_INT 4
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 2
44697: NEG
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 2
44709: NEG
44710: PUSH
44711: LD_INT 2
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 3
44721: NEG
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 4
44733: NEG
44734: PUSH
44735: LD_INT 3
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 4
44745: NEG
44746: PUSH
44747: LD_INT 4
44749: NEG
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 2
44757: NEG
44758: PUSH
44759: LD_INT 4
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 4
44769: NEG
44770: PUSH
44771: LD_INT 2
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 0
44781: PUSH
44782: LD_INT 4
44784: NEG
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 0
44792: PUSH
44793: LD_INT 5
44795: NEG
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: LD_INT 4
44806: NEG
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 1
44814: PUSH
44815: LD_INT 3
44817: NEG
44818: PUSH
44819: EMPTY
44820: LIST
44821: LIST
44822: PUSH
44823: LD_INT 0
44825: PUSH
44826: LD_INT 3
44828: NEG
44829: PUSH
44830: EMPTY
44831: LIST
44832: LIST
44833: PUSH
44834: LD_INT 1
44836: NEG
44837: PUSH
44838: LD_INT 4
44840: NEG
44841: PUSH
44842: EMPTY
44843: LIST
44844: LIST
44845: PUSH
44846: LD_INT 1
44848: NEG
44849: PUSH
44850: LD_INT 5
44852: NEG
44853: PUSH
44854: EMPTY
44855: LIST
44856: LIST
44857: PUSH
44858: LD_INT 2
44860: PUSH
44861: LD_INT 3
44863: NEG
44864: PUSH
44865: EMPTY
44866: LIST
44867: LIST
44868: PUSH
44869: LD_INT 2
44871: NEG
44872: PUSH
44873: LD_INT 5
44875: NEG
44876: PUSH
44877: EMPTY
44878: LIST
44879: LIST
44880: PUSH
44881: LD_INT 3
44883: PUSH
44884: LD_INT 0
44886: PUSH
44887: EMPTY
44888: LIST
44889: LIST
44890: PUSH
44891: LD_INT 3
44893: PUSH
44894: LD_INT 1
44896: NEG
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 4
44904: PUSH
44905: LD_INT 0
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 4
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 3
44924: PUSH
44925: LD_INT 1
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 2
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 2
44944: PUSH
44945: LD_INT 1
44947: NEG
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 2
44955: PUSH
44956: LD_INT 2
44958: NEG
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 4
44966: PUSH
44967: LD_INT 2
44969: PUSH
44970: EMPTY
44971: LIST
44972: LIST
44973: PUSH
44974: LD_INT 4
44976: PUSH
44977: LD_INT 4
44979: PUSH
44980: EMPTY
44981: LIST
44982: LIST
44983: PUSH
44984: LD_INT 4
44986: PUSH
44987: LD_INT 3
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 5
44996: PUSH
44997: LD_INT 4
44999: PUSH
45000: EMPTY
45001: LIST
45002: LIST
45003: PUSH
45004: LD_INT 5
45006: PUSH
45007: LD_INT 5
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 4
45016: PUSH
45017: LD_INT 5
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 3
45026: PUSH
45027: LD_INT 4
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: LD_INT 3
45039: PUSH
45040: EMPTY
45041: LIST
45042: LIST
45043: PUSH
45044: LD_INT 5
45046: PUSH
45047: LD_INT 3
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 3
45056: PUSH
45057: LD_INT 5
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: LIST
45084: LIST
45085: LIST
45086: LIST
45087: LIST
45088: LIST
45089: LIST
45090: LIST
45091: LIST
45092: LIST
45093: LIST
45094: LIST
45095: LIST
45096: LIST
45097: LIST
45098: LIST
45099: LIST
45100: LIST
45101: LIST
45102: LIST
45103: LIST
45104: LIST
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45111: LD_ADDR_VAR 0 33
45115: PUSH
45116: LD_INT 4
45118: NEG
45119: PUSH
45120: LD_INT 4
45122: NEG
45123: PUSH
45124: EMPTY
45125: LIST
45126: LIST
45127: PUSH
45128: LD_INT 4
45130: NEG
45131: PUSH
45132: LD_INT 5
45134: NEG
45135: PUSH
45136: EMPTY
45137: LIST
45138: LIST
45139: PUSH
45140: LD_INT 3
45142: NEG
45143: PUSH
45144: LD_INT 4
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 3
45154: NEG
45155: PUSH
45156: LD_INT 3
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 4
45166: NEG
45167: PUSH
45168: LD_INT 3
45170: NEG
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: PUSH
45176: LD_INT 5
45178: NEG
45179: PUSH
45180: LD_INT 4
45182: NEG
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 5
45190: NEG
45191: PUSH
45192: LD_INT 5
45194: NEG
45195: PUSH
45196: EMPTY
45197: LIST
45198: LIST
45199: PUSH
45200: LD_INT 3
45202: NEG
45203: PUSH
45204: LD_INT 5
45206: NEG
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: LD_INT 3
45218: NEG
45219: PUSH
45220: EMPTY
45221: LIST
45222: LIST
45223: PUSH
45224: LD_INT 0
45226: PUSH
45227: LD_INT 3
45229: NEG
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 4
45240: NEG
45241: PUSH
45242: EMPTY
45243: LIST
45244: LIST
45245: PUSH
45246: LD_INT 1
45248: PUSH
45249: LD_INT 3
45251: NEG
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 1
45259: PUSH
45260: LD_INT 2
45262: NEG
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: PUSH
45268: LD_INT 0
45270: PUSH
45271: LD_INT 2
45273: NEG
45274: PUSH
45275: EMPTY
45276: LIST
45277: LIST
45278: PUSH
45279: LD_INT 1
45281: NEG
45282: PUSH
45283: LD_INT 3
45285: NEG
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 1
45293: NEG
45294: PUSH
45295: LD_INT 4
45297: NEG
45298: PUSH
45299: EMPTY
45300: LIST
45301: LIST
45302: PUSH
45303: LD_INT 2
45305: PUSH
45306: LD_INT 2
45308: NEG
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 2
45316: NEG
45317: PUSH
45318: LD_INT 4
45320: NEG
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 4
45328: PUSH
45329: LD_INT 0
45331: PUSH
45332: EMPTY
45333: LIST
45334: LIST
45335: PUSH
45336: LD_INT 4
45338: PUSH
45339: LD_INT 1
45341: NEG
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 5
45349: PUSH
45350: LD_INT 0
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 5
45359: PUSH
45360: LD_INT 1
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 4
45369: PUSH
45370: LD_INT 1
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 3
45379: PUSH
45380: LD_INT 0
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 3
45389: PUSH
45390: LD_INT 1
45392: NEG
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: LD_INT 3
45400: PUSH
45401: LD_INT 2
45403: NEG
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 5
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 3
45421: PUSH
45422: LD_INT 3
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 3
45431: PUSH
45432: LD_INT 2
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 4
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 4
45451: PUSH
45452: LD_INT 4
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 3
45461: PUSH
45462: LD_INT 4
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 2
45471: PUSH
45472: LD_INT 3
45474: PUSH
45475: EMPTY
45476: LIST
45477: LIST
45478: PUSH
45479: LD_INT 2
45481: PUSH
45482: LD_INT 2
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: PUSH
45489: LD_INT 4
45491: PUSH
45492: LD_INT 2
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 2
45501: PUSH
45502: LD_INT 4
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 0
45511: PUSH
45512: LD_INT 4
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 0
45521: PUSH
45522: LD_INT 3
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 1
45531: PUSH
45532: LD_INT 4
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 1
45541: PUSH
45542: LD_INT 5
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 0
45551: PUSH
45552: LD_INT 5
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 1
45561: NEG
45562: PUSH
45563: LD_INT 4
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 1
45572: NEG
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 2
45583: PUSH
45584: LD_INT 5
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 2
45593: NEG
45594: PUSH
45595: LD_INT 3
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: EMPTY
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: LIST
45631: LIST
45632: LIST
45633: LIST
45634: LIST
45635: LIST
45636: LIST
45637: LIST
45638: LIST
45639: LIST
45640: LIST
45641: LIST
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45649: LD_ADDR_VAR 0 34
45653: PUSH
45654: LD_INT 0
45656: PUSH
45657: LD_INT 4
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: LD_INT 5
45670: NEG
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 1
45678: PUSH
45679: LD_INT 4
45681: NEG
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 1
45689: PUSH
45690: LD_INT 3
45692: NEG
45693: PUSH
45694: EMPTY
45695: LIST
45696: LIST
45697: PUSH
45698: LD_INT 0
45700: PUSH
45701: LD_INT 3
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 1
45711: NEG
45712: PUSH
45713: LD_INT 4
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 1
45723: NEG
45724: PUSH
45725: LD_INT 5
45727: NEG
45728: PUSH
45729: EMPTY
45730: LIST
45731: LIST
45732: PUSH
45733: LD_INT 2
45735: PUSH
45736: LD_INT 3
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 2
45746: NEG
45747: PUSH
45748: LD_INT 5
45750: NEG
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 3
45758: PUSH
45759: LD_INT 0
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 3
45768: PUSH
45769: LD_INT 1
45771: NEG
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 4
45779: PUSH
45780: LD_INT 0
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 4
45789: PUSH
45790: LD_INT 1
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 3
45799: PUSH
45800: LD_INT 1
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 2
45809: PUSH
45810: LD_INT 0
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 2
45819: PUSH
45820: LD_INT 1
45822: NEG
45823: PUSH
45824: EMPTY
45825: LIST
45826: LIST
45827: PUSH
45828: LD_INT 2
45830: PUSH
45831: LD_INT 2
45833: NEG
45834: PUSH
45835: EMPTY
45836: LIST
45837: LIST
45838: PUSH
45839: LD_INT 4
45841: PUSH
45842: LD_INT 2
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 4
45851: PUSH
45852: LD_INT 4
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 4
45861: PUSH
45862: LD_INT 3
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 5
45871: PUSH
45872: LD_INT 4
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 5
45881: PUSH
45882: LD_INT 5
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_INT 4
45891: PUSH
45892: LD_INT 5
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 3
45901: PUSH
45902: LD_INT 4
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 3
45911: PUSH
45912: LD_INT 3
45914: PUSH
45915: EMPTY
45916: LIST
45917: LIST
45918: PUSH
45919: LD_INT 5
45921: PUSH
45922: LD_INT 3
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 3
45931: PUSH
45932: LD_INT 5
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 0
45941: PUSH
45942: LD_INT 3
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 0
45951: PUSH
45952: LD_INT 2
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 1
45961: PUSH
45962: LD_INT 3
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 1
45971: PUSH
45972: LD_INT 4
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 0
45981: PUSH
45982: LD_INT 4
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 1
45991: NEG
45992: PUSH
45993: LD_INT 3
45995: PUSH
45996: EMPTY
45997: LIST
45998: LIST
45999: PUSH
46000: LD_INT 1
46002: NEG
46003: PUSH
46004: LD_INT 2
46006: PUSH
46007: EMPTY
46008: LIST
46009: LIST
46010: PUSH
46011: LD_INT 2
46013: PUSH
46014: LD_INT 4
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: LD_INT 2
46023: NEG
46024: PUSH
46025: LD_INT 2
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: LD_INT 4
46034: NEG
46035: PUSH
46036: LD_INT 0
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 4
46045: NEG
46046: PUSH
46047: LD_INT 1
46049: NEG
46050: PUSH
46051: EMPTY
46052: LIST
46053: LIST
46054: PUSH
46055: LD_INT 3
46057: NEG
46058: PUSH
46059: LD_INT 0
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 3
46068: NEG
46069: PUSH
46070: LD_INT 1
46072: PUSH
46073: EMPTY
46074: LIST
46075: LIST
46076: PUSH
46077: LD_INT 4
46079: NEG
46080: PUSH
46081: LD_INT 1
46083: PUSH
46084: EMPTY
46085: LIST
46086: LIST
46087: PUSH
46088: LD_INT 5
46090: NEG
46091: PUSH
46092: LD_INT 0
46094: PUSH
46095: EMPTY
46096: LIST
46097: LIST
46098: PUSH
46099: LD_INT 5
46101: NEG
46102: PUSH
46103: LD_INT 1
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 5
46113: NEG
46114: PUSH
46115: LD_INT 2
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 3
46125: NEG
46126: PUSH
46127: LD_INT 2
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: LIST
46170: LIST
46171: LIST
46172: LIST
46173: LIST
46174: LIST
46175: LIST
46176: LIST
46177: LIST
46178: LIST
46179: LIST
46180: ST_TO_ADDR
// end ; end ;
46181: GO 46184
46183: POP
// case btype of b_depot , b_warehouse :
46184: LD_VAR 0 1
46188: PUSH
46189: LD_INT 0
46191: DOUBLE
46192: EQUAL
46193: IFTRUE 46203
46195: LD_INT 1
46197: DOUBLE
46198: EQUAL
46199: IFTRUE 46203
46201: GO 46404
46203: POP
// case nation of nation_american :
46204: LD_VAR 0 5
46208: PUSH
46209: LD_INT 1
46211: DOUBLE
46212: EQUAL
46213: IFTRUE 46217
46215: GO 46273
46217: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46218: LD_ADDR_VAR 0 9
46222: PUSH
46223: LD_VAR 0 11
46227: PUSH
46228: LD_VAR 0 12
46232: PUSH
46233: LD_VAR 0 13
46237: PUSH
46238: LD_VAR 0 14
46242: PUSH
46243: LD_VAR 0 15
46247: PUSH
46248: LD_VAR 0 16
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: LIST
46257: LIST
46258: LIST
46259: LIST
46260: PUSH
46261: LD_VAR 0 4
46265: PUSH
46266: LD_INT 1
46268: PLUS
46269: ARRAY
46270: ST_TO_ADDR
46271: GO 46402
46273: LD_INT 2
46275: DOUBLE
46276: EQUAL
46277: IFTRUE 46281
46279: GO 46337
46281: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46282: LD_ADDR_VAR 0 9
46286: PUSH
46287: LD_VAR 0 17
46291: PUSH
46292: LD_VAR 0 18
46296: PUSH
46297: LD_VAR 0 19
46301: PUSH
46302: LD_VAR 0 20
46306: PUSH
46307: LD_VAR 0 21
46311: PUSH
46312: LD_VAR 0 22
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: LIST
46321: LIST
46322: LIST
46323: LIST
46324: PUSH
46325: LD_VAR 0 4
46329: PUSH
46330: LD_INT 1
46332: PLUS
46333: ARRAY
46334: ST_TO_ADDR
46335: GO 46402
46337: LD_INT 3
46339: DOUBLE
46340: EQUAL
46341: IFTRUE 46345
46343: GO 46401
46345: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46346: LD_ADDR_VAR 0 9
46350: PUSH
46351: LD_VAR 0 23
46355: PUSH
46356: LD_VAR 0 24
46360: PUSH
46361: LD_VAR 0 25
46365: PUSH
46366: LD_VAR 0 26
46370: PUSH
46371: LD_VAR 0 27
46375: PUSH
46376: LD_VAR 0 28
46380: PUSH
46381: EMPTY
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: PUSH
46389: LD_VAR 0 4
46393: PUSH
46394: LD_INT 1
46396: PLUS
46397: ARRAY
46398: ST_TO_ADDR
46399: GO 46402
46401: POP
46402: GO 46951
46404: LD_INT 2
46406: DOUBLE
46407: EQUAL
46408: IFTRUE 46418
46410: LD_INT 3
46412: DOUBLE
46413: EQUAL
46414: IFTRUE 46418
46416: GO 46474
46418: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46419: LD_ADDR_VAR 0 9
46423: PUSH
46424: LD_VAR 0 29
46428: PUSH
46429: LD_VAR 0 30
46433: PUSH
46434: LD_VAR 0 31
46438: PUSH
46439: LD_VAR 0 32
46443: PUSH
46444: LD_VAR 0 33
46448: PUSH
46449: LD_VAR 0 34
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: LIST
46458: LIST
46459: LIST
46460: LIST
46461: PUSH
46462: LD_VAR 0 4
46466: PUSH
46467: LD_INT 1
46469: PLUS
46470: ARRAY
46471: ST_TO_ADDR
46472: GO 46951
46474: LD_INT 16
46476: DOUBLE
46477: EQUAL
46478: IFTRUE 46530
46480: LD_INT 17
46482: DOUBLE
46483: EQUAL
46484: IFTRUE 46530
46486: LD_INT 18
46488: DOUBLE
46489: EQUAL
46490: IFTRUE 46530
46492: LD_INT 19
46494: DOUBLE
46495: EQUAL
46496: IFTRUE 46530
46498: LD_INT 20
46500: DOUBLE
46501: EQUAL
46502: IFTRUE 46530
46504: LD_INT 21
46506: DOUBLE
46507: EQUAL
46508: IFTRUE 46530
46510: LD_INT 23
46512: DOUBLE
46513: EQUAL
46514: IFTRUE 46530
46516: LD_INT 24
46518: DOUBLE
46519: EQUAL
46520: IFTRUE 46530
46522: LD_INT 25
46524: DOUBLE
46525: EQUAL
46526: IFTRUE 46530
46528: GO 46586
46530: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46531: LD_ADDR_VAR 0 9
46535: PUSH
46536: LD_VAR 0 35
46540: PUSH
46541: LD_VAR 0 36
46545: PUSH
46546: LD_VAR 0 37
46550: PUSH
46551: LD_VAR 0 38
46555: PUSH
46556: LD_VAR 0 39
46560: PUSH
46561: LD_VAR 0 40
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: PUSH
46574: LD_VAR 0 4
46578: PUSH
46579: LD_INT 1
46581: PLUS
46582: ARRAY
46583: ST_TO_ADDR
46584: GO 46951
46586: LD_INT 6
46588: DOUBLE
46589: EQUAL
46590: IFTRUE 46642
46592: LD_INT 7
46594: DOUBLE
46595: EQUAL
46596: IFTRUE 46642
46598: LD_INT 8
46600: DOUBLE
46601: EQUAL
46602: IFTRUE 46642
46604: LD_INT 13
46606: DOUBLE
46607: EQUAL
46608: IFTRUE 46642
46610: LD_INT 12
46612: DOUBLE
46613: EQUAL
46614: IFTRUE 46642
46616: LD_INT 15
46618: DOUBLE
46619: EQUAL
46620: IFTRUE 46642
46622: LD_INT 11
46624: DOUBLE
46625: EQUAL
46626: IFTRUE 46642
46628: LD_INT 14
46630: DOUBLE
46631: EQUAL
46632: IFTRUE 46642
46634: LD_INT 10
46636: DOUBLE
46637: EQUAL
46638: IFTRUE 46642
46640: GO 46698
46642: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46643: LD_ADDR_VAR 0 9
46647: PUSH
46648: LD_VAR 0 41
46652: PUSH
46653: LD_VAR 0 42
46657: PUSH
46658: LD_VAR 0 43
46662: PUSH
46663: LD_VAR 0 44
46667: PUSH
46668: LD_VAR 0 45
46672: PUSH
46673: LD_VAR 0 46
46677: PUSH
46678: EMPTY
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: PUSH
46686: LD_VAR 0 4
46690: PUSH
46691: LD_INT 1
46693: PLUS
46694: ARRAY
46695: ST_TO_ADDR
46696: GO 46951
46698: LD_INT 36
46700: DOUBLE
46701: EQUAL
46702: IFTRUE 46706
46704: GO 46762
46706: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46707: LD_ADDR_VAR 0 9
46711: PUSH
46712: LD_VAR 0 47
46716: PUSH
46717: LD_VAR 0 48
46721: PUSH
46722: LD_VAR 0 49
46726: PUSH
46727: LD_VAR 0 50
46731: PUSH
46732: LD_VAR 0 51
46736: PUSH
46737: LD_VAR 0 52
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: PUSH
46750: LD_VAR 0 4
46754: PUSH
46755: LD_INT 1
46757: PLUS
46758: ARRAY
46759: ST_TO_ADDR
46760: GO 46951
46762: LD_INT 4
46764: DOUBLE
46765: EQUAL
46766: IFTRUE 46788
46768: LD_INT 5
46770: DOUBLE
46771: EQUAL
46772: IFTRUE 46788
46774: LD_INT 34
46776: DOUBLE
46777: EQUAL
46778: IFTRUE 46788
46780: LD_INT 37
46782: DOUBLE
46783: EQUAL
46784: IFTRUE 46788
46786: GO 46844
46788: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46789: LD_ADDR_VAR 0 9
46793: PUSH
46794: LD_VAR 0 53
46798: PUSH
46799: LD_VAR 0 54
46803: PUSH
46804: LD_VAR 0 55
46808: PUSH
46809: LD_VAR 0 56
46813: PUSH
46814: LD_VAR 0 57
46818: PUSH
46819: LD_VAR 0 58
46823: PUSH
46824: EMPTY
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: PUSH
46832: LD_VAR 0 4
46836: PUSH
46837: LD_INT 1
46839: PLUS
46840: ARRAY
46841: ST_TO_ADDR
46842: GO 46951
46844: LD_INT 31
46846: DOUBLE
46847: EQUAL
46848: IFTRUE 46894
46850: LD_INT 32
46852: DOUBLE
46853: EQUAL
46854: IFTRUE 46894
46856: LD_INT 33
46858: DOUBLE
46859: EQUAL
46860: IFTRUE 46894
46862: LD_INT 27
46864: DOUBLE
46865: EQUAL
46866: IFTRUE 46894
46868: LD_INT 26
46870: DOUBLE
46871: EQUAL
46872: IFTRUE 46894
46874: LD_INT 28
46876: DOUBLE
46877: EQUAL
46878: IFTRUE 46894
46880: LD_INT 29
46882: DOUBLE
46883: EQUAL
46884: IFTRUE 46894
46886: LD_INT 30
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 46950
46894: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
46895: LD_ADDR_VAR 0 9
46899: PUSH
46900: LD_VAR 0 59
46904: PUSH
46905: LD_VAR 0 60
46909: PUSH
46910: LD_VAR 0 61
46914: PUSH
46915: LD_VAR 0 62
46919: PUSH
46920: LD_VAR 0 63
46924: PUSH
46925: LD_VAR 0 64
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_INT 1
46945: PLUS
46946: ARRAY
46947: ST_TO_ADDR
46948: GO 46951
46950: POP
// temp_list2 = [ ] ;
46951: LD_ADDR_VAR 0 10
46955: PUSH
46956: EMPTY
46957: ST_TO_ADDR
// for i in temp_list do
46958: LD_ADDR_VAR 0 8
46962: PUSH
46963: LD_VAR 0 9
46967: PUSH
46968: FOR_IN
46969: IFFALSE 47021
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46971: LD_ADDR_VAR 0 10
46975: PUSH
46976: LD_VAR 0 10
46980: PUSH
46981: LD_VAR 0 8
46985: PUSH
46986: LD_INT 1
46988: ARRAY
46989: PUSH
46990: LD_VAR 0 2
46994: PLUS
46995: PUSH
46996: LD_VAR 0 8
47000: PUSH
47001: LD_INT 2
47003: ARRAY
47004: PUSH
47005: LD_VAR 0 3
47009: PLUS
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: EMPTY
47016: LIST
47017: ADD
47018: ST_TO_ADDR
47019: GO 46968
47021: POP
47022: POP
// result = temp_list2 ;
47023: LD_ADDR_VAR 0 7
47027: PUSH
47028: LD_VAR 0 10
47032: ST_TO_ADDR
// end ;
47033: LD_VAR 0 7
47037: RET
// export function EnemyInRange ( unit , dist ) ; begin
47038: LD_INT 0
47040: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47041: LD_ADDR_VAR 0 3
47045: PUSH
47046: LD_VAR 0 1
47050: PPUSH
47051: CALL_OW 255
47055: PPUSH
47056: LD_VAR 0 1
47060: PPUSH
47061: CALL_OW 250
47065: PPUSH
47066: LD_VAR 0 1
47070: PPUSH
47071: CALL_OW 251
47075: PPUSH
47076: LD_VAR 0 2
47080: PPUSH
47081: CALL 21166 0 4
47085: PUSH
47086: LD_INT 4
47088: ARRAY
47089: ST_TO_ADDR
// end ;
47090: LD_VAR 0 3
47094: RET
// export function PlayerSeeMe ( unit ) ; begin
47095: LD_INT 0
47097: PPUSH
// result := See ( your_side , unit ) ;
47098: LD_ADDR_VAR 0 2
47102: PUSH
47103: LD_OWVAR 2
47107: PPUSH
47108: LD_VAR 0 1
47112: PPUSH
47113: CALL_OW 292
47117: ST_TO_ADDR
// end ;
47118: LD_VAR 0 2
47122: RET
// export function ReverseDir ( unit ) ; begin
47123: LD_INT 0
47125: PPUSH
// if not unit then
47126: LD_VAR 0 1
47130: NOT
47131: IFFALSE 47135
// exit ;
47133: GO 47181
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47135: LD_ADDR_VAR 0 2
47139: PUSH
47140: LD_INT 3
47142: PUSH
47143: LD_INT 4
47145: PUSH
47146: LD_INT 5
47148: PUSH
47149: LD_INT 0
47151: PUSH
47152: LD_INT 1
47154: PUSH
47155: LD_INT 2
47157: PUSH
47158: EMPTY
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: PUSH
47166: LD_VAR 0 1
47170: PPUSH
47171: CALL_OW 254
47175: PUSH
47176: LD_INT 1
47178: PLUS
47179: ARRAY
47180: ST_TO_ADDR
// end ;
47181: LD_VAR 0 2
47185: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47186: LD_INT 0
47188: PPUSH
47189: PPUSH
47190: PPUSH
47191: PPUSH
47192: PPUSH
// if not hexes then
47193: LD_VAR 0 2
47197: NOT
47198: IFFALSE 47202
// exit ;
47200: GO 47350
// dist := 9999 ;
47202: LD_ADDR_VAR 0 5
47206: PUSH
47207: LD_INT 9999
47209: ST_TO_ADDR
// for i = 1 to hexes do
47210: LD_ADDR_VAR 0 4
47214: PUSH
47215: DOUBLE
47216: LD_INT 1
47218: DEC
47219: ST_TO_ADDR
47220: LD_VAR 0 2
47224: PUSH
47225: FOR_TO
47226: IFFALSE 47338
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47228: LD_VAR 0 1
47232: PPUSH
47233: LD_VAR 0 2
47237: PUSH
47238: LD_VAR 0 4
47242: ARRAY
47243: PUSH
47244: LD_INT 1
47246: ARRAY
47247: PPUSH
47248: LD_VAR 0 2
47252: PUSH
47253: LD_VAR 0 4
47257: ARRAY
47258: PUSH
47259: LD_INT 2
47261: ARRAY
47262: PPUSH
47263: CALL_OW 297
47267: PUSH
47268: LD_VAR 0 5
47272: LESS
47273: IFFALSE 47336
// begin hex := hexes [ i ] ;
47275: LD_ADDR_VAR 0 7
47279: PUSH
47280: LD_VAR 0 2
47284: PUSH
47285: LD_VAR 0 4
47289: ARRAY
47290: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47291: LD_ADDR_VAR 0 5
47295: PUSH
47296: LD_VAR 0 1
47300: PPUSH
47301: LD_VAR 0 2
47305: PUSH
47306: LD_VAR 0 4
47310: ARRAY
47311: PUSH
47312: LD_INT 1
47314: ARRAY
47315: PPUSH
47316: LD_VAR 0 2
47320: PUSH
47321: LD_VAR 0 4
47325: ARRAY
47326: PUSH
47327: LD_INT 2
47329: ARRAY
47330: PPUSH
47331: CALL_OW 297
47335: ST_TO_ADDR
// end ; end ;
47336: GO 47225
47338: POP
47339: POP
// result := hex ;
47340: LD_ADDR_VAR 0 3
47344: PUSH
47345: LD_VAR 0 7
47349: ST_TO_ADDR
// end ;
47350: LD_VAR 0 3
47354: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47355: LD_INT 0
47357: PPUSH
47358: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47359: LD_VAR 0 1
47363: NOT
47364: PUSH
47365: LD_VAR 0 1
47369: PUSH
47370: LD_INT 21
47372: PUSH
47373: LD_INT 2
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: PUSH
47380: LD_INT 23
47382: PUSH
47383: LD_INT 2
47385: PUSH
47386: EMPTY
47387: LIST
47388: LIST
47389: PUSH
47390: EMPTY
47391: LIST
47392: LIST
47393: PPUSH
47394: CALL_OW 69
47398: IN
47399: NOT
47400: OR
47401: IFFALSE 47405
// exit ;
47403: GO 47452
// for i = 1 to 3 do
47405: LD_ADDR_VAR 0 3
47409: PUSH
47410: DOUBLE
47411: LD_INT 1
47413: DEC
47414: ST_TO_ADDR
47415: LD_INT 3
47417: PUSH
47418: FOR_TO
47419: IFFALSE 47450
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47421: LD_VAR 0 1
47425: PPUSH
47426: CALL_OW 250
47430: PPUSH
47431: LD_VAR 0 1
47435: PPUSH
47436: CALL_OW 251
47440: PPUSH
47441: LD_INT 1
47443: PPUSH
47444: CALL_OW 453
47448: GO 47418
47450: POP
47451: POP
// end ;
47452: LD_VAR 0 2
47456: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47457: LD_INT 0
47459: PPUSH
47460: PPUSH
47461: PPUSH
47462: PPUSH
47463: PPUSH
47464: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47465: LD_VAR 0 1
47469: NOT
47470: PUSH
47471: LD_VAR 0 2
47475: NOT
47476: OR
47477: PUSH
47478: LD_VAR 0 1
47482: PPUSH
47483: CALL_OW 314
47487: OR
47488: IFFALSE 47492
// exit ;
47490: GO 47933
// x := GetX ( enemy_unit ) ;
47492: LD_ADDR_VAR 0 7
47496: PUSH
47497: LD_VAR 0 2
47501: PPUSH
47502: CALL_OW 250
47506: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47507: LD_ADDR_VAR 0 8
47511: PUSH
47512: LD_VAR 0 2
47516: PPUSH
47517: CALL_OW 251
47521: ST_TO_ADDR
// if not x or not y then
47522: LD_VAR 0 7
47526: NOT
47527: PUSH
47528: LD_VAR 0 8
47532: NOT
47533: OR
47534: IFFALSE 47538
// exit ;
47536: GO 47933
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47538: LD_ADDR_VAR 0 6
47542: PUSH
47543: LD_VAR 0 7
47547: PPUSH
47548: LD_INT 0
47550: PPUSH
47551: LD_INT 4
47553: PPUSH
47554: CALL_OW 272
47558: PUSH
47559: LD_VAR 0 8
47563: PPUSH
47564: LD_INT 0
47566: PPUSH
47567: LD_INT 4
47569: PPUSH
47570: CALL_OW 273
47574: PUSH
47575: EMPTY
47576: LIST
47577: LIST
47578: PUSH
47579: LD_VAR 0 7
47583: PPUSH
47584: LD_INT 1
47586: PPUSH
47587: LD_INT 4
47589: PPUSH
47590: CALL_OW 272
47594: PUSH
47595: LD_VAR 0 8
47599: PPUSH
47600: LD_INT 1
47602: PPUSH
47603: LD_INT 4
47605: PPUSH
47606: CALL_OW 273
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: PUSH
47615: LD_VAR 0 7
47619: PPUSH
47620: LD_INT 2
47622: PPUSH
47623: LD_INT 4
47625: PPUSH
47626: CALL_OW 272
47630: PUSH
47631: LD_VAR 0 8
47635: PPUSH
47636: LD_INT 2
47638: PPUSH
47639: LD_INT 4
47641: PPUSH
47642: CALL_OW 273
47646: PUSH
47647: EMPTY
47648: LIST
47649: LIST
47650: PUSH
47651: LD_VAR 0 7
47655: PPUSH
47656: LD_INT 3
47658: PPUSH
47659: LD_INT 4
47661: PPUSH
47662: CALL_OW 272
47666: PUSH
47667: LD_VAR 0 8
47671: PPUSH
47672: LD_INT 3
47674: PPUSH
47675: LD_INT 4
47677: PPUSH
47678: CALL_OW 273
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: PUSH
47687: LD_VAR 0 7
47691: PPUSH
47692: LD_INT 4
47694: PPUSH
47695: LD_INT 4
47697: PPUSH
47698: CALL_OW 272
47702: PUSH
47703: LD_VAR 0 8
47707: PPUSH
47708: LD_INT 4
47710: PPUSH
47711: LD_INT 4
47713: PPUSH
47714: CALL_OW 273
47718: PUSH
47719: EMPTY
47720: LIST
47721: LIST
47722: PUSH
47723: LD_VAR 0 7
47727: PPUSH
47728: LD_INT 5
47730: PPUSH
47731: LD_INT 4
47733: PPUSH
47734: CALL_OW 272
47738: PUSH
47739: LD_VAR 0 8
47743: PPUSH
47744: LD_INT 5
47746: PPUSH
47747: LD_INT 4
47749: PPUSH
47750: CALL_OW 273
47754: PUSH
47755: EMPTY
47756: LIST
47757: LIST
47758: PUSH
47759: EMPTY
47760: LIST
47761: LIST
47762: LIST
47763: LIST
47764: LIST
47765: LIST
47766: ST_TO_ADDR
// for i = tmp downto 1 do
47767: LD_ADDR_VAR 0 4
47771: PUSH
47772: DOUBLE
47773: LD_VAR 0 6
47777: INC
47778: ST_TO_ADDR
47779: LD_INT 1
47781: PUSH
47782: FOR_DOWNTO
47783: IFFALSE 47884
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47785: LD_VAR 0 6
47789: PUSH
47790: LD_VAR 0 4
47794: ARRAY
47795: PUSH
47796: LD_INT 1
47798: ARRAY
47799: PPUSH
47800: LD_VAR 0 6
47804: PUSH
47805: LD_VAR 0 4
47809: ARRAY
47810: PUSH
47811: LD_INT 2
47813: ARRAY
47814: PPUSH
47815: CALL_OW 488
47819: NOT
47820: PUSH
47821: LD_VAR 0 6
47825: PUSH
47826: LD_VAR 0 4
47830: ARRAY
47831: PUSH
47832: LD_INT 1
47834: ARRAY
47835: PPUSH
47836: LD_VAR 0 6
47840: PUSH
47841: LD_VAR 0 4
47845: ARRAY
47846: PUSH
47847: LD_INT 2
47849: ARRAY
47850: PPUSH
47851: CALL_OW 428
47855: PUSH
47856: LD_INT 0
47858: NONEQUAL
47859: OR
47860: IFFALSE 47882
// tmp := Delete ( tmp , i ) ;
47862: LD_ADDR_VAR 0 6
47866: PUSH
47867: LD_VAR 0 6
47871: PPUSH
47872: LD_VAR 0 4
47876: PPUSH
47877: CALL_OW 3
47881: ST_TO_ADDR
47882: GO 47782
47884: POP
47885: POP
// j := GetClosestHex ( unit , tmp ) ;
47886: LD_ADDR_VAR 0 5
47890: PUSH
47891: LD_VAR 0 1
47895: PPUSH
47896: LD_VAR 0 6
47900: PPUSH
47901: CALL 47186 0 2
47905: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47906: LD_VAR 0 1
47910: PPUSH
47911: LD_VAR 0 5
47915: PUSH
47916: LD_INT 1
47918: ARRAY
47919: PPUSH
47920: LD_VAR 0 5
47924: PUSH
47925: LD_INT 2
47927: ARRAY
47928: PPUSH
47929: CALL_OW 111
// end ;
47933: LD_VAR 0 3
47937: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47938: LD_INT 0
47940: PPUSH
47941: PPUSH
47942: PPUSH
// uc_side = 0 ;
47943: LD_ADDR_OWVAR 20
47947: PUSH
47948: LD_INT 0
47950: ST_TO_ADDR
// uc_nation = 0 ;
47951: LD_ADDR_OWVAR 21
47955: PUSH
47956: LD_INT 0
47958: ST_TO_ADDR
// InitHc ;
47959: CALL_OW 19
// InitVc ;
47963: CALL_OW 20
// if mastodonts then
47967: LD_VAR 0 6
47971: IFFALSE 48038
// for i = 1 to mastodonts do
47973: LD_ADDR_VAR 0 11
47977: PUSH
47978: DOUBLE
47979: LD_INT 1
47981: DEC
47982: ST_TO_ADDR
47983: LD_VAR 0 6
47987: PUSH
47988: FOR_TO
47989: IFFALSE 48036
// begin vc_chassis := 31 ;
47991: LD_ADDR_OWVAR 37
47995: PUSH
47996: LD_INT 31
47998: ST_TO_ADDR
// vc_control := control_rider ;
47999: LD_ADDR_OWVAR 38
48003: PUSH
48004: LD_INT 4
48006: ST_TO_ADDR
// animal := CreateVehicle ;
48007: LD_ADDR_VAR 0 12
48011: PUSH
48012: CALL_OW 45
48016: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48017: LD_VAR 0 12
48021: PPUSH
48022: LD_VAR 0 8
48026: PPUSH
48027: LD_INT 0
48029: PPUSH
48030: CALL 54744 0 3
// end ;
48034: GO 47988
48036: POP
48037: POP
// if horses then
48038: LD_VAR 0 5
48042: IFFALSE 48109
// for i = 1 to horses do
48044: LD_ADDR_VAR 0 11
48048: PUSH
48049: DOUBLE
48050: LD_INT 1
48052: DEC
48053: ST_TO_ADDR
48054: LD_VAR 0 5
48058: PUSH
48059: FOR_TO
48060: IFFALSE 48107
// begin hc_class := 21 ;
48062: LD_ADDR_OWVAR 28
48066: PUSH
48067: LD_INT 21
48069: ST_TO_ADDR
// hc_gallery :=  ;
48070: LD_ADDR_OWVAR 33
48074: PUSH
48075: LD_STRING 
48077: ST_TO_ADDR
// animal := CreateHuman ;
48078: LD_ADDR_VAR 0 12
48082: PUSH
48083: CALL_OW 44
48087: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48088: LD_VAR 0 12
48092: PPUSH
48093: LD_VAR 0 8
48097: PPUSH
48098: LD_INT 0
48100: PPUSH
48101: CALL 54744 0 3
// end ;
48105: GO 48059
48107: POP
48108: POP
// if birds then
48109: LD_VAR 0 1
48113: IFFALSE 48180
// for i = 1 to birds do
48115: LD_ADDR_VAR 0 11
48119: PUSH
48120: DOUBLE
48121: LD_INT 1
48123: DEC
48124: ST_TO_ADDR
48125: LD_VAR 0 1
48129: PUSH
48130: FOR_TO
48131: IFFALSE 48178
// begin hc_class = 18 ;
48133: LD_ADDR_OWVAR 28
48137: PUSH
48138: LD_INT 18
48140: ST_TO_ADDR
// hc_gallery =  ;
48141: LD_ADDR_OWVAR 33
48145: PUSH
48146: LD_STRING 
48148: ST_TO_ADDR
// animal := CreateHuman ;
48149: LD_ADDR_VAR 0 12
48153: PUSH
48154: CALL_OW 44
48158: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48159: LD_VAR 0 12
48163: PPUSH
48164: LD_VAR 0 8
48168: PPUSH
48169: LD_INT 0
48171: PPUSH
48172: CALL 54744 0 3
// end ;
48176: GO 48130
48178: POP
48179: POP
// if tigers then
48180: LD_VAR 0 2
48184: IFFALSE 48268
// for i = 1 to tigers do
48186: LD_ADDR_VAR 0 11
48190: PUSH
48191: DOUBLE
48192: LD_INT 1
48194: DEC
48195: ST_TO_ADDR
48196: LD_VAR 0 2
48200: PUSH
48201: FOR_TO
48202: IFFALSE 48266
// begin hc_class = class_tiger ;
48204: LD_ADDR_OWVAR 28
48208: PUSH
48209: LD_INT 14
48211: ST_TO_ADDR
// hc_gallery =  ;
48212: LD_ADDR_OWVAR 33
48216: PUSH
48217: LD_STRING 
48219: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48220: LD_ADDR_OWVAR 35
48224: PUSH
48225: LD_INT 7
48227: NEG
48228: PPUSH
48229: LD_INT 7
48231: PPUSH
48232: CALL_OW 12
48236: ST_TO_ADDR
// animal := CreateHuman ;
48237: LD_ADDR_VAR 0 12
48241: PUSH
48242: CALL_OW 44
48246: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48247: LD_VAR 0 12
48251: PPUSH
48252: LD_VAR 0 8
48256: PPUSH
48257: LD_INT 0
48259: PPUSH
48260: CALL 54744 0 3
// end ;
48264: GO 48201
48266: POP
48267: POP
// if apemans then
48268: LD_VAR 0 3
48272: IFFALSE 48395
// for i = 1 to apemans do
48274: LD_ADDR_VAR 0 11
48278: PUSH
48279: DOUBLE
48280: LD_INT 1
48282: DEC
48283: ST_TO_ADDR
48284: LD_VAR 0 3
48288: PUSH
48289: FOR_TO
48290: IFFALSE 48393
// begin hc_class = class_apeman ;
48292: LD_ADDR_OWVAR 28
48296: PUSH
48297: LD_INT 12
48299: ST_TO_ADDR
// hc_gallery =  ;
48300: LD_ADDR_OWVAR 33
48304: PUSH
48305: LD_STRING 
48307: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48308: LD_ADDR_OWVAR 35
48312: PUSH
48313: LD_INT 5
48315: NEG
48316: PPUSH
48317: LD_INT 5
48319: PPUSH
48320: CALL_OW 12
48324: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48325: LD_ADDR_OWVAR 31
48329: PUSH
48330: LD_INT 1
48332: PPUSH
48333: LD_INT 3
48335: PPUSH
48336: CALL_OW 12
48340: PUSH
48341: LD_INT 1
48343: PPUSH
48344: LD_INT 3
48346: PPUSH
48347: CALL_OW 12
48351: PUSH
48352: LD_INT 0
48354: PUSH
48355: LD_INT 0
48357: PUSH
48358: EMPTY
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: ST_TO_ADDR
// animal := CreateHuman ;
48364: LD_ADDR_VAR 0 12
48368: PUSH
48369: CALL_OW 44
48373: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48374: LD_VAR 0 12
48378: PPUSH
48379: LD_VAR 0 8
48383: PPUSH
48384: LD_INT 0
48386: PPUSH
48387: CALL 54744 0 3
// end ;
48391: GO 48289
48393: POP
48394: POP
// if enchidnas then
48395: LD_VAR 0 4
48399: IFFALSE 48466
// for i = 1 to enchidnas do
48401: LD_ADDR_VAR 0 11
48405: PUSH
48406: DOUBLE
48407: LD_INT 1
48409: DEC
48410: ST_TO_ADDR
48411: LD_VAR 0 4
48415: PUSH
48416: FOR_TO
48417: IFFALSE 48464
// begin hc_class = 13 ;
48419: LD_ADDR_OWVAR 28
48423: PUSH
48424: LD_INT 13
48426: ST_TO_ADDR
// hc_gallery =  ;
48427: LD_ADDR_OWVAR 33
48431: PUSH
48432: LD_STRING 
48434: ST_TO_ADDR
// animal := CreateHuman ;
48435: LD_ADDR_VAR 0 12
48439: PUSH
48440: CALL_OW 44
48444: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48445: LD_VAR 0 12
48449: PPUSH
48450: LD_VAR 0 8
48454: PPUSH
48455: LD_INT 0
48457: PPUSH
48458: CALL 54744 0 3
// end ;
48462: GO 48416
48464: POP
48465: POP
// if fishes then
48466: LD_VAR 0 7
48470: IFFALSE 48537
// for i = 1 to fishes do
48472: LD_ADDR_VAR 0 11
48476: PUSH
48477: DOUBLE
48478: LD_INT 1
48480: DEC
48481: ST_TO_ADDR
48482: LD_VAR 0 7
48486: PUSH
48487: FOR_TO
48488: IFFALSE 48535
// begin hc_class = 20 ;
48490: LD_ADDR_OWVAR 28
48494: PUSH
48495: LD_INT 20
48497: ST_TO_ADDR
// hc_gallery =  ;
48498: LD_ADDR_OWVAR 33
48502: PUSH
48503: LD_STRING 
48505: ST_TO_ADDR
// animal := CreateHuman ;
48506: LD_ADDR_VAR 0 12
48510: PUSH
48511: CALL_OW 44
48515: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48516: LD_VAR 0 12
48520: PPUSH
48521: LD_VAR 0 9
48525: PPUSH
48526: LD_INT 0
48528: PPUSH
48529: CALL 54744 0 3
// end ;
48533: GO 48487
48535: POP
48536: POP
// end ;
48537: LD_VAR 0 10
48541: RET
// export function WantHeal ( sci , unit ) ; begin
48542: LD_INT 0
48544: PPUSH
// if GetTaskList ( sci ) > 0 then
48545: LD_VAR 0 1
48549: PPUSH
48550: CALL_OW 437
48554: PUSH
48555: LD_INT 0
48557: GREATER
48558: IFFALSE 48628
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48560: LD_VAR 0 1
48564: PPUSH
48565: CALL_OW 437
48569: PUSH
48570: LD_INT 1
48572: ARRAY
48573: PUSH
48574: LD_INT 1
48576: ARRAY
48577: PUSH
48578: LD_STRING l
48580: EQUAL
48581: PUSH
48582: LD_VAR 0 1
48586: PPUSH
48587: CALL_OW 437
48591: PUSH
48592: LD_INT 1
48594: ARRAY
48595: PUSH
48596: LD_INT 4
48598: ARRAY
48599: PUSH
48600: LD_VAR 0 2
48604: EQUAL
48605: AND
48606: IFFALSE 48618
// result := true else
48608: LD_ADDR_VAR 0 3
48612: PUSH
48613: LD_INT 1
48615: ST_TO_ADDR
48616: GO 48626
// result := false ;
48618: LD_ADDR_VAR 0 3
48622: PUSH
48623: LD_INT 0
48625: ST_TO_ADDR
// end else
48626: GO 48636
// result := false ;
48628: LD_ADDR_VAR 0 3
48632: PUSH
48633: LD_INT 0
48635: ST_TO_ADDR
// end ;
48636: LD_VAR 0 3
48640: RET
// export function HealTarget ( sci ) ; begin
48641: LD_INT 0
48643: PPUSH
// if not sci then
48644: LD_VAR 0 1
48648: NOT
48649: IFFALSE 48653
// exit ;
48651: GO 48718
// result := 0 ;
48653: LD_ADDR_VAR 0 2
48657: PUSH
48658: LD_INT 0
48660: ST_TO_ADDR
// if GetTaskList ( sci ) then
48661: LD_VAR 0 1
48665: PPUSH
48666: CALL_OW 437
48670: IFFALSE 48718
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48672: LD_VAR 0 1
48676: PPUSH
48677: CALL_OW 437
48681: PUSH
48682: LD_INT 1
48684: ARRAY
48685: PUSH
48686: LD_INT 1
48688: ARRAY
48689: PUSH
48690: LD_STRING l
48692: EQUAL
48693: IFFALSE 48718
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48695: LD_ADDR_VAR 0 2
48699: PUSH
48700: LD_VAR 0 1
48704: PPUSH
48705: CALL_OW 437
48709: PUSH
48710: LD_INT 1
48712: ARRAY
48713: PUSH
48714: LD_INT 4
48716: ARRAY
48717: ST_TO_ADDR
// end ;
48718: LD_VAR 0 2
48722: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
48723: LD_INT 0
48725: PPUSH
48726: PPUSH
48727: PPUSH
48728: PPUSH
48729: PPUSH
48730: PPUSH
48731: PPUSH
48732: PPUSH
48733: PPUSH
48734: PPUSH
48735: PPUSH
48736: PPUSH
48737: PPUSH
48738: PPUSH
48739: PPUSH
48740: PPUSH
48741: PPUSH
48742: PPUSH
48743: PPUSH
48744: PPUSH
48745: PPUSH
48746: PPUSH
48747: PPUSH
48748: PPUSH
48749: PPUSH
48750: PPUSH
48751: PPUSH
48752: PPUSH
48753: PPUSH
48754: PPUSH
48755: PPUSH
48756: PPUSH
48757: PPUSH
// if not list then
48758: LD_VAR 0 1
48762: NOT
48763: IFFALSE 48767
// exit ;
48765: GO 53355
// base := list [ 1 ] ;
48767: LD_ADDR_VAR 0 3
48771: PUSH
48772: LD_VAR 0 1
48776: PUSH
48777: LD_INT 1
48779: ARRAY
48780: ST_TO_ADDR
// group := list [ 2 ] ;
48781: LD_ADDR_VAR 0 4
48785: PUSH
48786: LD_VAR 0 1
48790: PUSH
48791: LD_INT 2
48793: ARRAY
48794: ST_TO_ADDR
// path := list [ 3 ] ;
48795: LD_ADDR_VAR 0 5
48799: PUSH
48800: LD_VAR 0 1
48804: PUSH
48805: LD_INT 3
48807: ARRAY
48808: ST_TO_ADDR
// flags := list [ 4 ] ;
48809: LD_ADDR_VAR 0 6
48813: PUSH
48814: LD_VAR 0 1
48818: PUSH
48819: LD_INT 4
48821: ARRAY
48822: ST_TO_ADDR
// mined := [ ] ;
48823: LD_ADDR_VAR 0 27
48827: PUSH
48828: EMPTY
48829: ST_TO_ADDR
// bombed := [ ] ;
48830: LD_ADDR_VAR 0 28
48834: PUSH
48835: EMPTY
48836: ST_TO_ADDR
// healers := [ ] ;
48837: LD_ADDR_VAR 0 31
48841: PUSH
48842: EMPTY
48843: ST_TO_ADDR
// to_heal := [ ] ;
48844: LD_ADDR_VAR 0 30
48848: PUSH
48849: EMPTY
48850: ST_TO_ADDR
// repairs := [ ] ;
48851: LD_ADDR_VAR 0 33
48855: PUSH
48856: EMPTY
48857: ST_TO_ADDR
// to_repair := [ ] ;
48858: LD_ADDR_VAR 0 32
48862: PUSH
48863: EMPTY
48864: ST_TO_ADDR
// if not group or not path then
48865: LD_VAR 0 4
48869: NOT
48870: PUSH
48871: LD_VAR 0 5
48875: NOT
48876: OR
48877: IFFALSE 48881
// exit ;
48879: GO 53355
// if flags then
48881: LD_VAR 0 6
48885: IFFALSE 49029
// begin f_ignore_area := flags [ 1 ] ;
48887: LD_ADDR_VAR 0 17
48891: PUSH
48892: LD_VAR 0 6
48896: PUSH
48897: LD_INT 1
48899: ARRAY
48900: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
48901: LD_ADDR_VAR 0 18
48905: PUSH
48906: LD_VAR 0 6
48910: PUSH
48911: LD_INT 2
48913: ARRAY
48914: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
48915: LD_ADDR_VAR 0 19
48919: PUSH
48920: LD_VAR 0 6
48924: PUSH
48925: LD_INT 3
48927: ARRAY
48928: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
48929: LD_ADDR_VAR 0 20
48933: PUSH
48934: LD_VAR 0 6
48938: PUSH
48939: LD_INT 4
48941: ARRAY
48942: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
48943: LD_ADDR_VAR 0 21
48947: PUSH
48948: LD_VAR 0 6
48952: PUSH
48953: LD_INT 5
48955: ARRAY
48956: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
48957: LD_ADDR_VAR 0 22
48961: PUSH
48962: LD_VAR 0 6
48966: PUSH
48967: LD_INT 6
48969: ARRAY
48970: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
48971: LD_ADDR_VAR 0 23
48975: PUSH
48976: LD_VAR 0 6
48980: PUSH
48981: LD_INT 7
48983: ARRAY
48984: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
48985: LD_ADDR_VAR 0 24
48989: PUSH
48990: LD_VAR 0 6
48994: PUSH
48995: LD_INT 8
48997: ARRAY
48998: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
48999: LD_ADDR_VAR 0 25
49003: PUSH
49004: LD_VAR 0 6
49008: PUSH
49009: LD_INT 9
49011: ARRAY
49012: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49013: LD_ADDR_VAR 0 26
49017: PUSH
49018: LD_VAR 0 6
49022: PUSH
49023: LD_INT 10
49025: ARRAY
49026: ST_TO_ADDR
// end else
49027: GO 49109
// begin f_ignore_area := false ;
49029: LD_ADDR_VAR 0 17
49033: PUSH
49034: LD_INT 0
49036: ST_TO_ADDR
// f_capture := false ;
49037: LD_ADDR_VAR 0 18
49041: PUSH
49042: LD_INT 0
49044: ST_TO_ADDR
// f_ignore_civ := false ;
49045: LD_ADDR_VAR 0 19
49049: PUSH
49050: LD_INT 0
49052: ST_TO_ADDR
// f_murder := false ;
49053: LD_ADDR_VAR 0 20
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// f_mines := false ;
49061: LD_ADDR_VAR 0 21
49065: PUSH
49066: LD_INT 0
49068: ST_TO_ADDR
// f_repair := false ;
49069: LD_ADDR_VAR 0 22
49073: PUSH
49074: LD_INT 0
49076: ST_TO_ADDR
// f_heal := false ;
49077: LD_ADDR_VAR 0 23
49081: PUSH
49082: LD_INT 0
49084: ST_TO_ADDR
// f_spacetime := false ;
49085: LD_ADDR_VAR 0 24
49089: PUSH
49090: LD_INT 0
49092: ST_TO_ADDR
// f_attack_depot := false ;
49093: LD_ADDR_VAR 0 25
49097: PUSH
49098: LD_INT 0
49100: ST_TO_ADDR
// f_crawl := false ;
49101: LD_ADDR_VAR 0 26
49105: PUSH
49106: LD_INT 0
49108: ST_TO_ADDR
// end ; if f_heal then
49109: LD_VAR 0 23
49113: IFFALSE 49140
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49115: LD_ADDR_VAR 0 31
49119: PUSH
49120: LD_VAR 0 4
49124: PPUSH
49125: LD_INT 25
49127: PUSH
49128: LD_INT 4
49130: PUSH
49131: EMPTY
49132: LIST
49133: LIST
49134: PPUSH
49135: CALL_OW 72
49139: ST_TO_ADDR
// if f_repair then
49140: LD_VAR 0 22
49144: IFFALSE 49171
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49146: LD_ADDR_VAR 0 33
49150: PUSH
49151: LD_VAR 0 4
49155: PPUSH
49156: LD_INT 25
49158: PUSH
49159: LD_INT 3
49161: PUSH
49162: EMPTY
49163: LIST
49164: LIST
49165: PPUSH
49166: CALL_OW 72
49170: ST_TO_ADDR
// units_path := [ ] ;
49171: LD_ADDR_VAR 0 16
49175: PUSH
49176: EMPTY
49177: ST_TO_ADDR
// for i = 1 to group do
49178: LD_ADDR_VAR 0 7
49182: PUSH
49183: DOUBLE
49184: LD_INT 1
49186: DEC
49187: ST_TO_ADDR
49188: LD_VAR 0 4
49192: PUSH
49193: FOR_TO
49194: IFFALSE 49223
// units_path := Replace ( units_path , i , path ) ;
49196: LD_ADDR_VAR 0 16
49200: PUSH
49201: LD_VAR 0 16
49205: PPUSH
49206: LD_VAR 0 7
49210: PPUSH
49211: LD_VAR 0 5
49215: PPUSH
49216: CALL_OW 1
49220: ST_TO_ADDR
49221: GO 49193
49223: POP
49224: POP
// repeat for i = group downto 1 do
49225: LD_ADDR_VAR 0 7
49229: PUSH
49230: DOUBLE
49231: LD_VAR 0 4
49235: INC
49236: ST_TO_ADDR
49237: LD_INT 1
49239: PUSH
49240: FOR_DOWNTO
49241: IFFALSE 53337
// begin wait ( 5 ) ;
49243: LD_INT 5
49245: PPUSH
49246: CALL_OW 67
// tmp := [ ] ;
49250: LD_ADDR_VAR 0 14
49254: PUSH
49255: EMPTY
49256: ST_TO_ADDR
// attacking := false ;
49257: LD_ADDR_VAR 0 29
49261: PUSH
49262: LD_INT 0
49264: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49265: LD_VAR 0 4
49269: PUSH
49270: LD_VAR 0 7
49274: ARRAY
49275: PPUSH
49276: CALL_OW 301
49280: PUSH
49281: LD_VAR 0 4
49285: PUSH
49286: LD_VAR 0 7
49290: ARRAY
49291: NOT
49292: OR
49293: IFFALSE 49402
// begin if GetType ( group [ i ] ) = unit_human then
49295: LD_VAR 0 4
49299: PUSH
49300: LD_VAR 0 7
49304: ARRAY
49305: PPUSH
49306: CALL_OW 247
49310: PUSH
49311: LD_INT 1
49313: EQUAL
49314: IFFALSE 49360
// begin to_heal := to_heal diff group [ i ] ;
49316: LD_ADDR_VAR 0 30
49320: PUSH
49321: LD_VAR 0 30
49325: PUSH
49326: LD_VAR 0 4
49330: PUSH
49331: LD_VAR 0 7
49335: ARRAY
49336: DIFF
49337: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49338: LD_ADDR_VAR 0 31
49342: PUSH
49343: LD_VAR 0 31
49347: PUSH
49348: LD_VAR 0 4
49352: PUSH
49353: LD_VAR 0 7
49357: ARRAY
49358: DIFF
49359: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49360: LD_ADDR_VAR 0 4
49364: PUSH
49365: LD_VAR 0 4
49369: PPUSH
49370: LD_VAR 0 7
49374: PPUSH
49375: CALL_OW 3
49379: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49380: LD_ADDR_VAR 0 16
49384: PUSH
49385: LD_VAR 0 16
49389: PPUSH
49390: LD_VAR 0 7
49394: PPUSH
49395: CALL_OW 3
49399: ST_TO_ADDR
// continue ;
49400: GO 49240
// end ; if f_repair then
49402: LD_VAR 0 22
49406: IFFALSE 49895
// begin if GetType ( group [ i ] ) = unit_vehicle then
49408: LD_VAR 0 4
49412: PUSH
49413: LD_VAR 0 7
49417: ARRAY
49418: PPUSH
49419: CALL_OW 247
49423: PUSH
49424: LD_INT 2
49426: EQUAL
49427: IFFALSE 49617
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49429: LD_VAR 0 4
49433: PUSH
49434: LD_VAR 0 7
49438: ARRAY
49439: PPUSH
49440: CALL_OW 256
49444: PUSH
49445: LD_INT 700
49447: LESS
49448: PUSH
49449: LD_VAR 0 4
49453: PUSH
49454: LD_VAR 0 7
49458: ARRAY
49459: PUSH
49460: LD_VAR 0 32
49464: IN
49465: NOT
49466: AND
49467: IFFALSE 49491
// to_repair := to_repair union group [ i ] ;
49469: LD_ADDR_VAR 0 32
49473: PUSH
49474: LD_VAR 0 32
49478: PUSH
49479: LD_VAR 0 4
49483: PUSH
49484: LD_VAR 0 7
49488: ARRAY
49489: UNION
49490: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49491: LD_VAR 0 4
49495: PUSH
49496: LD_VAR 0 7
49500: ARRAY
49501: PPUSH
49502: CALL_OW 256
49506: PUSH
49507: LD_INT 1000
49509: EQUAL
49510: PUSH
49511: LD_VAR 0 4
49515: PUSH
49516: LD_VAR 0 7
49520: ARRAY
49521: PUSH
49522: LD_VAR 0 32
49526: IN
49527: AND
49528: IFFALSE 49552
// to_repair := to_repair diff group [ i ] ;
49530: LD_ADDR_VAR 0 32
49534: PUSH
49535: LD_VAR 0 32
49539: PUSH
49540: LD_VAR 0 4
49544: PUSH
49545: LD_VAR 0 7
49549: ARRAY
49550: DIFF
49551: ST_TO_ADDR
// if group [ i ] in to_repair then
49552: LD_VAR 0 4
49556: PUSH
49557: LD_VAR 0 7
49561: ARRAY
49562: PUSH
49563: LD_VAR 0 32
49567: IN
49568: IFFALSE 49615
// begin if not IsInArea ( group [ i ] , f_repair ) then
49570: LD_VAR 0 4
49574: PUSH
49575: LD_VAR 0 7
49579: ARRAY
49580: PPUSH
49581: LD_VAR 0 22
49585: PPUSH
49586: CALL_OW 308
49590: NOT
49591: IFFALSE 49613
// ComMoveToArea ( group [ i ] , f_repair ) ;
49593: LD_VAR 0 4
49597: PUSH
49598: LD_VAR 0 7
49602: ARRAY
49603: PPUSH
49604: LD_VAR 0 22
49608: PPUSH
49609: CALL_OW 113
// continue ;
49613: GO 49240
// end ; end else
49615: GO 49895
// if group [ i ] in repairs then
49617: LD_VAR 0 4
49621: PUSH
49622: LD_VAR 0 7
49626: ARRAY
49627: PUSH
49628: LD_VAR 0 33
49632: IN
49633: IFFALSE 49895
// begin if IsInUnit ( group [ i ] ) then
49635: LD_VAR 0 4
49639: PUSH
49640: LD_VAR 0 7
49644: ARRAY
49645: PPUSH
49646: CALL_OW 310
49650: IFFALSE 49718
// begin z := IsInUnit ( group [ i ] ) ;
49652: LD_ADDR_VAR 0 13
49656: PUSH
49657: LD_VAR 0 4
49661: PUSH
49662: LD_VAR 0 7
49666: ARRAY
49667: PPUSH
49668: CALL_OW 310
49672: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49673: LD_VAR 0 13
49677: PUSH
49678: LD_VAR 0 32
49682: IN
49683: PUSH
49684: LD_VAR 0 13
49688: PPUSH
49689: LD_VAR 0 22
49693: PPUSH
49694: CALL_OW 308
49698: AND
49699: IFFALSE 49716
// ComExitVehicle ( group [ i ] ) ;
49701: LD_VAR 0 4
49705: PUSH
49706: LD_VAR 0 7
49710: ARRAY
49711: PPUSH
49712: CALL_OW 121
// end else
49716: GO 49895
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
49718: LD_ADDR_VAR 0 13
49722: PUSH
49723: LD_VAR 0 4
49727: PPUSH
49728: LD_INT 95
49730: PUSH
49731: LD_VAR 0 22
49735: PUSH
49736: EMPTY
49737: LIST
49738: LIST
49739: PUSH
49740: LD_INT 58
49742: PUSH
49743: EMPTY
49744: LIST
49745: PUSH
49746: EMPTY
49747: LIST
49748: LIST
49749: PPUSH
49750: CALL_OW 72
49754: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
49755: LD_VAR 0 4
49759: PUSH
49760: LD_VAR 0 7
49764: ARRAY
49765: PPUSH
49766: CALL_OW 314
49770: NOT
49771: IFFALSE 49893
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
49773: LD_ADDR_VAR 0 10
49777: PUSH
49778: LD_VAR 0 13
49782: PPUSH
49783: LD_VAR 0 4
49787: PUSH
49788: LD_VAR 0 7
49792: ARRAY
49793: PPUSH
49794: CALL_OW 74
49798: ST_TO_ADDR
// if not x then
49799: LD_VAR 0 10
49803: NOT
49804: IFFALSE 49808
// continue ;
49806: GO 49240
// if GetLives ( x ) < 1000 then
49808: LD_VAR 0 10
49812: PPUSH
49813: CALL_OW 256
49817: PUSH
49818: LD_INT 1000
49820: LESS
49821: IFFALSE 49845
// ComRepairVehicle ( group [ i ] , x ) else
49823: LD_VAR 0 4
49827: PUSH
49828: LD_VAR 0 7
49832: ARRAY
49833: PPUSH
49834: LD_VAR 0 10
49838: PPUSH
49839: CALL_OW 129
49843: GO 49893
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
49845: LD_VAR 0 23
49849: PUSH
49850: LD_VAR 0 4
49854: PUSH
49855: LD_VAR 0 7
49859: ARRAY
49860: PPUSH
49861: CALL_OW 256
49865: PUSH
49866: LD_INT 1000
49868: LESS
49869: AND
49870: NOT
49871: IFFALSE 49893
// ComEnterUnit ( group [ i ] , x ) ;
49873: LD_VAR 0 4
49877: PUSH
49878: LD_VAR 0 7
49882: ARRAY
49883: PPUSH
49884: LD_VAR 0 10
49888: PPUSH
49889: CALL_OW 120
// end ; continue ;
49893: GO 49240
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
49895: LD_VAR 0 23
49899: PUSH
49900: LD_VAR 0 4
49904: PUSH
49905: LD_VAR 0 7
49909: ARRAY
49910: PPUSH
49911: CALL_OW 247
49915: PUSH
49916: LD_INT 1
49918: EQUAL
49919: AND
49920: IFFALSE 50398
// begin if group [ i ] in healers then
49922: LD_VAR 0 4
49926: PUSH
49927: LD_VAR 0 7
49931: ARRAY
49932: PUSH
49933: LD_VAR 0 31
49937: IN
49938: IFFALSE 50211
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
49940: LD_VAR 0 4
49944: PUSH
49945: LD_VAR 0 7
49949: ARRAY
49950: PPUSH
49951: LD_VAR 0 23
49955: PPUSH
49956: CALL_OW 308
49960: NOT
49961: PUSH
49962: LD_VAR 0 4
49966: PUSH
49967: LD_VAR 0 7
49971: ARRAY
49972: PPUSH
49973: CALL_OW 314
49977: NOT
49978: AND
49979: IFFALSE 50003
// ComMoveToArea ( group [ i ] , f_heal ) else
49981: LD_VAR 0 4
49985: PUSH
49986: LD_VAR 0 7
49990: ARRAY
49991: PPUSH
49992: LD_VAR 0 23
49996: PPUSH
49997: CALL_OW 113
50001: GO 50209
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50003: LD_VAR 0 4
50007: PUSH
50008: LD_VAR 0 7
50012: ARRAY
50013: PPUSH
50014: CALL 48641 0 1
50018: PPUSH
50019: CALL_OW 256
50023: PUSH
50024: LD_INT 1000
50026: EQUAL
50027: IFFALSE 50046
// ComStop ( group [ i ] ) else
50029: LD_VAR 0 4
50033: PUSH
50034: LD_VAR 0 7
50038: ARRAY
50039: PPUSH
50040: CALL_OW 141
50044: GO 50209
// if not HasTask ( group [ i ] ) and to_heal then
50046: LD_VAR 0 4
50050: PUSH
50051: LD_VAR 0 7
50055: ARRAY
50056: PPUSH
50057: CALL_OW 314
50061: NOT
50062: PUSH
50063: LD_VAR 0 30
50067: AND
50068: IFFALSE 50209
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50070: LD_ADDR_VAR 0 13
50074: PUSH
50075: LD_VAR 0 30
50079: PPUSH
50080: LD_INT 3
50082: PUSH
50083: LD_INT 54
50085: PUSH
50086: EMPTY
50087: LIST
50088: PUSH
50089: EMPTY
50090: LIST
50091: LIST
50092: PPUSH
50093: CALL_OW 72
50097: PPUSH
50098: LD_VAR 0 4
50102: PUSH
50103: LD_VAR 0 7
50107: ARRAY
50108: PPUSH
50109: CALL_OW 74
50113: ST_TO_ADDR
// if z then
50114: LD_VAR 0 13
50118: IFFALSE 50209
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50120: LD_INT 91
50122: PUSH
50123: LD_VAR 0 13
50127: PUSH
50128: LD_INT 10
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: LIST
50135: PUSH
50136: LD_INT 81
50138: PUSH
50139: LD_VAR 0 13
50143: PPUSH
50144: CALL_OW 255
50148: PUSH
50149: EMPTY
50150: LIST
50151: LIST
50152: PUSH
50153: EMPTY
50154: LIST
50155: LIST
50156: PPUSH
50157: CALL_OW 69
50161: PUSH
50162: LD_INT 0
50164: EQUAL
50165: IFFALSE 50189
// ComHeal ( group [ i ] , z ) else
50167: LD_VAR 0 4
50171: PUSH
50172: LD_VAR 0 7
50176: ARRAY
50177: PPUSH
50178: LD_VAR 0 13
50182: PPUSH
50183: CALL_OW 128
50187: GO 50209
// ComMoveToArea ( group [ i ] , f_heal ) ;
50189: LD_VAR 0 4
50193: PUSH
50194: LD_VAR 0 7
50198: ARRAY
50199: PPUSH
50200: LD_VAR 0 23
50204: PPUSH
50205: CALL_OW 113
// end ; continue ;
50209: GO 49240
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50211: LD_VAR 0 4
50215: PUSH
50216: LD_VAR 0 7
50220: ARRAY
50221: PPUSH
50222: CALL_OW 256
50226: PUSH
50227: LD_INT 700
50229: LESS
50230: PUSH
50231: LD_VAR 0 4
50235: PUSH
50236: LD_VAR 0 7
50240: ARRAY
50241: PUSH
50242: LD_VAR 0 30
50246: IN
50247: NOT
50248: AND
50249: IFFALSE 50273
// to_heal := to_heal union group [ i ] ;
50251: LD_ADDR_VAR 0 30
50255: PUSH
50256: LD_VAR 0 30
50260: PUSH
50261: LD_VAR 0 4
50265: PUSH
50266: LD_VAR 0 7
50270: ARRAY
50271: UNION
50272: ST_TO_ADDR
// if group [ i ] in to_heal then
50273: LD_VAR 0 4
50277: PUSH
50278: LD_VAR 0 7
50282: ARRAY
50283: PUSH
50284: LD_VAR 0 30
50288: IN
50289: IFFALSE 50398
// begin if GetLives ( group [ i ] ) = 1000 then
50291: LD_VAR 0 4
50295: PUSH
50296: LD_VAR 0 7
50300: ARRAY
50301: PPUSH
50302: CALL_OW 256
50306: PUSH
50307: LD_INT 1000
50309: EQUAL
50310: IFFALSE 50336
// to_heal := to_heal diff group [ i ] else
50312: LD_ADDR_VAR 0 30
50316: PUSH
50317: LD_VAR 0 30
50321: PUSH
50322: LD_VAR 0 4
50326: PUSH
50327: LD_VAR 0 7
50331: ARRAY
50332: DIFF
50333: ST_TO_ADDR
50334: GO 50398
// begin if not IsInArea ( group [ i ] , to_heal ) then
50336: LD_VAR 0 4
50340: PUSH
50341: LD_VAR 0 7
50345: ARRAY
50346: PPUSH
50347: LD_VAR 0 30
50351: PPUSH
50352: CALL_OW 308
50356: NOT
50357: IFFALSE 50381
// ComMoveToArea ( group [ i ] , f_heal ) else
50359: LD_VAR 0 4
50363: PUSH
50364: LD_VAR 0 7
50368: ARRAY
50369: PPUSH
50370: LD_VAR 0 23
50374: PPUSH
50375: CALL_OW 113
50379: GO 50396
// ComHold ( group [ i ] ) ;
50381: LD_VAR 0 4
50385: PUSH
50386: LD_VAR 0 7
50390: ARRAY
50391: PPUSH
50392: CALL_OW 140
// continue ;
50396: GO 49240
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50398: LD_VAR 0 4
50402: PUSH
50403: LD_VAR 0 7
50407: ARRAY
50408: PPUSH
50409: LD_INT 10
50411: PPUSH
50412: CALL 47038 0 2
50416: NOT
50417: PUSH
50418: LD_VAR 0 16
50422: PUSH
50423: LD_VAR 0 7
50427: ARRAY
50428: PUSH
50429: EMPTY
50430: EQUAL
50431: NOT
50432: AND
50433: IFFALSE 50699
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50435: LD_VAR 0 4
50439: PUSH
50440: LD_VAR 0 7
50444: ARRAY
50445: PPUSH
50446: CALL_OW 262
50450: PUSH
50451: LD_INT 1
50453: PUSH
50454: LD_INT 2
50456: PUSH
50457: EMPTY
50458: LIST
50459: LIST
50460: IN
50461: IFFALSE 50502
// if GetFuel ( group [ i ] ) < 10 then
50463: LD_VAR 0 4
50467: PUSH
50468: LD_VAR 0 7
50472: ARRAY
50473: PPUSH
50474: CALL_OW 261
50478: PUSH
50479: LD_INT 10
50481: LESS
50482: IFFALSE 50502
// SetFuel ( group [ i ] , 12 ) ;
50484: LD_VAR 0 4
50488: PUSH
50489: LD_VAR 0 7
50493: ARRAY
50494: PPUSH
50495: LD_INT 12
50497: PPUSH
50498: CALL_OW 240
// if units_path [ i ] then
50502: LD_VAR 0 16
50506: PUSH
50507: LD_VAR 0 7
50511: ARRAY
50512: IFFALSE 50697
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50514: LD_VAR 0 4
50518: PUSH
50519: LD_VAR 0 7
50523: ARRAY
50524: PPUSH
50525: LD_VAR 0 16
50529: PUSH
50530: LD_VAR 0 7
50534: ARRAY
50535: PUSH
50536: LD_INT 1
50538: ARRAY
50539: PUSH
50540: LD_INT 1
50542: ARRAY
50543: PPUSH
50544: LD_VAR 0 16
50548: PUSH
50549: LD_VAR 0 7
50553: ARRAY
50554: PUSH
50555: LD_INT 1
50557: ARRAY
50558: PUSH
50559: LD_INT 2
50561: ARRAY
50562: PPUSH
50563: CALL_OW 297
50567: PUSH
50568: LD_INT 6
50570: GREATER
50571: IFFALSE 50646
// begin if not HasTask ( group [ i ] ) then
50573: LD_VAR 0 4
50577: PUSH
50578: LD_VAR 0 7
50582: ARRAY
50583: PPUSH
50584: CALL_OW 314
50588: NOT
50589: IFFALSE 50644
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50591: LD_VAR 0 4
50595: PUSH
50596: LD_VAR 0 7
50600: ARRAY
50601: PPUSH
50602: LD_VAR 0 16
50606: PUSH
50607: LD_VAR 0 7
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: ARRAY
50620: PPUSH
50621: LD_VAR 0 16
50625: PUSH
50626: LD_VAR 0 7
50630: ARRAY
50631: PUSH
50632: LD_INT 1
50634: ARRAY
50635: PUSH
50636: LD_INT 2
50638: ARRAY
50639: PPUSH
50640: CALL_OW 114
// end else
50644: GO 50697
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50646: LD_ADDR_VAR 0 15
50650: PUSH
50651: LD_VAR 0 16
50655: PUSH
50656: LD_VAR 0 7
50660: ARRAY
50661: PPUSH
50662: LD_INT 1
50664: PPUSH
50665: CALL_OW 3
50669: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50670: LD_ADDR_VAR 0 16
50674: PUSH
50675: LD_VAR 0 16
50679: PPUSH
50680: LD_VAR 0 7
50684: PPUSH
50685: LD_VAR 0 15
50689: PPUSH
50690: CALL_OW 1
50694: ST_TO_ADDR
// continue ;
50695: GO 49240
// end ; end ; end else
50697: GO 53335
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50699: LD_ADDR_VAR 0 14
50703: PUSH
50704: LD_INT 81
50706: PUSH
50707: LD_VAR 0 4
50711: PUSH
50712: LD_VAR 0 7
50716: ARRAY
50717: PPUSH
50718: CALL_OW 255
50722: PUSH
50723: EMPTY
50724: LIST
50725: LIST
50726: PPUSH
50727: CALL_OW 69
50731: ST_TO_ADDR
// if not tmp then
50732: LD_VAR 0 14
50736: NOT
50737: IFFALSE 50741
// continue ;
50739: GO 49240
// if f_ignore_area then
50741: LD_VAR 0 17
50745: IFFALSE 50833
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
50747: LD_ADDR_VAR 0 15
50751: PUSH
50752: LD_VAR 0 14
50756: PPUSH
50757: LD_INT 3
50759: PUSH
50760: LD_INT 92
50762: PUSH
50763: LD_VAR 0 17
50767: PUSH
50768: LD_INT 1
50770: ARRAY
50771: PUSH
50772: LD_VAR 0 17
50776: PUSH
50777: LD_INT 2
50779: ARRAY
50780: PUSH
50781: LD_VAR 0 17
50785: PUSH
50786: LD_INT 3
50788: ARRAY
50789: PUSH
50790: EMPTY
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: PUSH
50796: EMPTY
50797: LIST
50798: LIST
50799: PPUSH
50800: CALL_OW 72
50804: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50805: LD_VAR 0 14
50809: PUSH
50810: LD_VAR 0 15
50814: DIFF
50815: IFFALSE 50833
// tmp := tmp diff tmp2 ;
50817: LD_ADDR_VAR 0 14
50821: PUSH
50822: LD_VAR 0 14
50826: PUSH
50827: LD_VAR 0 15
50831: DIFF
50832: ST_TO_ADDR
// end ; if not f_murder then
50833: LD_VAR 0 20
50837: NOT
50838: IFFALSE 50896
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
50840: LD_ADDR_VAR 0 15
50844: PUSH
50845: LD_VAR 0 14
50849: PPUSH
50850: LD_INT 3
50852: PUSH
50853: LD_INT 50
50855: PUSH
50856: EMPTY
50857: LIST
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PPUSH
50863: CALL_OW 72
50867: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50868: LD_VAR 0 14
50872: PUSH
50873: LD_VAR 0 15
50877: DIFF
50878: IFFALSE 50896
// tmp := tmp diff tmp2 ;
50880: LD_ADDR_VAR 0 14
50884: PUSH
50885: LD_VAR 0 14
50889: PUSH
50890: LD_VAR 0 15
50894: DIFF
50895: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
50896: LD_ADDR_VAR 0 14
50900: PUSH
50901: LD_VAR 0 4
50905: PUSH
50906: LD_VAR 0 7
50910: ARRAY
50911: PPUSH
50912: LD_VAR 0 14
50916: PPUSH
50917: LD_INT 1
50919: PPUSH
50920: LD_INT 1
50922: PPUSH
50923: CALL 20705 0 4
50927: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
50928: LD_VAR 0 4
50932: PUSH
50933: LD_VAR 0 7
50937: ARRAY
50938: PPUSH
50939: CALL_OW 257
50943: PUSH
50944: LD_INT 1
50946: EQUAL
50947: IFFALSE 51395
// begin if WantPlant ( group [ i ] ) then
50949: LD_VAR 0 4
50953: PUSH
50954: LD_VAR 0 7
50958: ARRAY
50959: PPUSH
50960: CALL 20206 0 1
50964: IFFALSE 50968
// continue ;
50966: GO 49240
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
50968: LD_VAR 0 18
50972: PUSH
50973: LD_VAR 0 4
50977: PUSH
50978: LD_VAR 0 7
50982: ARRAY
50983: PPUSH
50984: CALL_OW 310
50988: NOT
50989: AND
50990: PUSH
50991: LD_VAR 0 14
50995: PUSH
50996: LD_INT 1
50998: ARRAY
50999: PUSH
51000: LD_VAR 0 14
51004: PPUSH
51005: LD_INT 21
51007: PUSH
51008: LD_INT 2
51010: PUSH
51011: EMPTY
51012: LIST
51013: LIST
51014: PUSH
51015: LD_INT 58
51017: PUSH
51018: EMPTY
51019: LIST
51020: PUSH
51021: EMPTY
51022: LIST
51023: LIST
51024: PPUSH
51025: CALL_OW 72
51029: IN
51030: AND
51031: IFFALSE 51067
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51033: LD_VAR 0 4
51037: PUSH
51038: LD_VAR 0 7
51042: ARRAY
51043: PPUSH
51044: LD_VAR 0 14
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: CALL_OW 120
// attacking := true ;
51057: LD_ADDR_VAR 0 29
51061: PUSH
51062: LD_INT 1
51064: ST_TO_ADDR
// continue ;
51065: GO 49240
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51067: LD_VAR 0 26
51071: PUSH
51072: LD_VAR 0 4
51076: PUSH
51077: LD_VAR 0 7
51081: ARRAY
51082: PPUSH
51083: CALL_OW 257
51087: PUSH
51088: LD_INT 1
51090: EQUAL
51091: AND
51092: PUSH
51093: LD_VAR 0 4
51097: PUSH
51098: LD_VAR 0 7
51102: ARRAY
51103: PPUSH
51104: CALL_OW 256
51108: PUSH
51109: LD_INT 800
51111: LESS
51112: AND
51113: PUSH
51114: LD_VAR 0 4
51118: PUSH
51119: LD_VAR 0 7
51123: ARRAY
51124: PPUSH
51125: CALL_OW 318
51129: NOT
51130: AND
51131: IFFALSE 51148
// ComCrawl ( group [ i ] ) ;
51133: LD_VAR 0 4
51137: PUSH
51138: LD_VAR 0 7
51142: ARRAY
51143: PPUSH
51144: CALL_OW 137
// if f_mines then
51148: LD_VAR 0 21
51152: IFFALSE 51395
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51154: LD_VAR 0 14
51158: PUSH
51159: LD_INT 1
51161: ARRAY
51162: PPUSH
51163: CALL_OW 247
51167: PUSH
51168: LD_INT 3
51170: EQUAL
51171: PUSH
51172: LD_VAR 0 14
51176: PUSH
51177: LD_INT 1
51179: ARRAY
51180: PUSH
51181: LD_VAR 0 27
51185: IN
51186: NOT
51187: AND
51188: IFFALSE 51395
// begin x := GetX ( tmp [ 1 ] ) ;
51190: LD_ADDR_VAR 0 10
51194: PUSH
51195: LD_VAR 0 14
51199: PUSH
51200: LD_INT 1
51202: ARRAY
51203: PPUSH
51204: CALL_OW 250
51208: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51209: LD_ADDR_VAR 0 11
51213: PUSH
51214: LD_VAR 0 14
51218: PUSH
51219: LD_INT 1
51221: ARRAY
51222: PPUSH
51223: CALL_OW 251
51227: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51228: LD_ADDR_VAR 0 12
51232: PUSH
51233: LD_VAR 0 4
51237: PUSH
51238: LD_VAR 0 7
51242: ARRAY
51243: PPUSH
51244: CALL 47123 0 1
51248: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51249: LD_VAR 0 4
51253: PUSH
51254: LD_VAR 0 7
51258: ARRAY
51259: PPUSH
51260: LD_VAR 0 10
51264: PPUSH
51265: LD_VAR 0 11
51269: PPUSH
51270: LD_VAR 0 14
51274: PUSH
51275: LD_INT 1
51277: ARRAY
51278: PPUSH
51279: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51283: LD_VAR 0 4
51287: PUSH
51288: LD_VAR 0 7
51292: ARRAY
51293: PPUSH
51294: LD_VAR 0 10
51298: PPUSH
51299: LD_VAR 0 12
51303: PPUSH
51304: LD_INT 7
51306: PPUSH
51307: CALL_OW 272
51311: PPUSH
51312: LD_VAR 0 11
51316: PPUSH
51317: LD_VAR 0 12
51321: PPUSH
51322: LD_INT 7
51324: PPUSH
51325: CALL_OW 273
51329: PPUSH
51330: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51334: LD_VAR 0 4
51338: PUSH
51339: LD_VAR 0 7
51343: ARRAY
51344: PPUSH
51345: LD_INT 71
51347: PPUSH
51348: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51352: LD_ADDR_VAR 0 27
51356: PUSH
51357: LD_VAR 0 27
51361: PPUSH
51362: LD_VAR 0 27
51366: PUSH
51367: LD_INT 1
51369: PLUS
51370: PPUSH
51371: LD_VAR 0 14
51375: PUSH
51376: LD_INT 1
51378: ARRAY
51379: PPUSH
51380: CALL_OW 1
51384: ST_TO_ADDR
// attacking := true ;
51385: LD_ADDR_VAR 0 29
51389: PUSH
51390: LD_INT 1
51392: ST_TO_ADDR
// continue ;
51393: GO 49240
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51395: LD_VAR 0 4
51399: PUSH
51400: LD_VAR 0 7
51404: ARRAY
51405: PPUSH
51406: CALL_OW 257
51410: PUSH
51411: LD_INT 17
51413: EQUAL
51414: PUSH
51415: LD_VAR 0 4
51419: PUSH
51420: LD_VAR 0 7
51424: ARRAY
51425: PPUSH
51426: CALL_OW 110
51430: PUSH
51431: LD_INT 71
51433: EQUAL
51434: NOT
51435: AND
51436: IFFALSE 51582
// begin attacking := false ;
51438: LD_ADDR_VAR 0 29
51442: PUSH
51443: LD_INT 0
51445: ST_TO_ADDR
// k := 5 ;
51446: LD_ADDR_VAR 0 9
51450: PUSH
51451: LD_INT 5
51453: ST_TO_ADDR
// if tmp < k then
51454: LD_VAR 0 14
51458: PUSH
51459: LD_VAR 0 9
51463: LESS
51464: IFFALSE 51476
// k := tmp ;
51466: LD_ADDR_VAR 0 9
51470: PUSH
51471: LD_VAR 0 14
51475: ST_TO_ADDR
// for j = 1 to k do
51476: LD_ADDR_VAR 0 8
51480: PUSH
51481: DOUBLE
51482: LD_INT 1
51484: DEC
51485: ST_TO_ADDR
51486: LD_VAR 0 9
51490: PUSH
51491: FOR_TO
51492: IFFALSE 51580
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51494: LD_VAR 0 14
51498: PUSH
51499: LD_VAR 0 8
51503: ARRAY
51504: PUSH
51505: LD_VAR 0 14
51509: PPUSH
51510: LD_INT 58
51512: PUSH
51513: EMPTY
51514: LIST
51515: PPUSH
51516: CALL_OW 72
51520: IN
51521: NOT
51522: IFFALSE 51578
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51524: LD_VAR 0 4
51528: PUSH
51529: LD_VAR 0 7
51533: ARRAY
51534: PPUSH
51535: LD_VAR 0 14
51539: PUSH
51540: LD_VAR 0 8
51544: ARRAY
51545: PPUSH
51546: CALL_OW 115
// attacking := true ;
51550: LD_ADDR_VAR 0 29
51554: PUSH
51555: LD_INT 1
51557: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51558: LD_VAR 0 4
51562: PUSH
51563: LD_VAR 0 7
51567: ARRAY
51568: PPUSH
51569: LD_INT 71
51571: PPUSH
51572: CALL_OW 109
// continue ;
51576: GO 51491
// end ; end ;
51578: GO 51491
51580: POP
51581: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51582: LD_VAR 0 4
51586: PUSH
51587: LD_VAR 0 7
51591: ARRAY
51592: PPUSH
51593: CALL_OW 257
51597: PUSH
51598: LD_INT 8
51600: EQUAL
51601: PUSH
51602: LD_VAR 0 4
51606: PUSH
51607: LD_VAR 0 7
51611: ARRAY
51612: PPUSH
51613: CALL_OW 264
51617: PUSH
51618: LD_INT 28
51620: PUSH
51621: LD_INT 45
51623: PUSH
51624: LD_INT 7
51626: PUSH
51627: LD_INT 47
51629: PUSH
51630: EMPTY
51631: LIST
51632: LIST
51633: LIST
51634: LIST
51635: IN
51636: OR
51637: IFFALSE 51867
// begin attacking := false ;
51639: LD_ADDR_VAR 0 29
51643: PUSH
51644: LD_INT 0
51646: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51647: LD_VAR 0 14
51651: PUSH
51652: LD_INT 1
51654: ARRAY
51655: PPUSH
51656: CALL_OW 266
51660: PUSH
51661: LD_INT 32
51663: PUSH
51664: LD_INT 31
51666: PUSH
51667: LD_INT 33
51669: PUSH
51670: LD_INT 4
51672: PUSH
51673: LD_INT 5
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: LIST
51680: LIST
51681: LIST
51682: IN
51683: IFFALSE 51867
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51685: LD_ADDR_VAR 0 9
51689: PUSH
51690: LD_VAR 0 14
51694: PUSH
51695: LD_INT 1
51697: ARRAY
51698: PPUSH
51699: CALL_OW 266
51703: PPUSH
51704: LD_VAR 0 14
51708: PUSH
51709: LD_INT 1
51711: ARRAY
51712: PPUSH
51713: CALL_OW 250
51717: PPUSH
51718: LD_VAR 0 14
51722: PUSH
51723: LD_INT 1
51725: ARRAY
51726: PPUSH
51727: CALL_OW 251
51731: PPUSH
51732: LD_VAR 0 14
51736: PUSH
51737: LD_INT 1
51739: ARRAY
51740: PPUSH
51741: CALL_OW 254
51745: PPUSH
51746: LD_VAR 0 14
51750: PUSH
51751: LD_INT 1
51753: ARRAY
51754: PPUSH
51755: CALL_OW 248
51759: PPUSH
51760: LD_INT 0
51762: PPUSH
51763: CALL 28499 0 6
51767: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
51768: LD_ADDR_VAR 0 8
51772: PUSH
51773: LD_VAR 0 4
51777: PUSH
51778: LD_VAR 0 7
51782: ARRAY
51783: PPUSH
51784: LD_VAR 0 9
51788: PPUSH
51789: CALL 47186 0 2
51793: ST_TO_ADDR
// if j then
51794: LD_VAR 0 8
51798: IFFALSE 51867
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
51800: LD_VAR 0 8
51804: PUSH
51805: LD_INT 1
51807: ARRAY
51808: PPUSH
51809: LD_VAR 0 8
51813: PUSH
51814: LD_INT 2
51816: ARRAY
51817: PPUSH
51818: CALL_OW 488
51822: IFFALSE 51867
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
51824: LD_VAR 0 4
51828: PUSH
51829: LD_VAR 0 7
51833: ARRAY
51834: PPUSH
51835: LD_VAR 0 8
51839: PUSH
51840: LD_INT 1
51842: ARRAY
51843: PPUSH
51844: LD_VAR 0 8
51848: PUSH
51849: LD_INT 2
51851: ARRAY
51852: PPUSH
51853: CALL_OW 116
// attacking := true ;
51857: LD_ADDR_VAR 0 29
51861: PUSH
51862: LD_INT 1
51864: ST_TO_ADDR
// continue ;
51865: GO 49240
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 7
51876: ARRAY
51877: PPUSH
51878: CALL_OW 265
51882: PUSH
51883: LD_INT 11
51885: EQUAL
51886: IFFALSE 52164
// begin k := 10 ;
51888: LD_ADDR_VAR 0 9
51892: PUSH
51893: LD_INT 10
51895: ST_TO_ADDR
// x := 0 ;
51896: LD_ADDR_VAR 0 10
51900: PUSH
51901: LD_INT 0
51903: ST_TO_ADDR
// if tmp < k then
51904: LD_VAR 0 14
51908: PUSH
51909: LD_VAR 0 9
51913: LESS
51914: IFFALSE 51926
// k := tmp ;
51916: LD_ADDR_VAR 0 9
51920: PUSH
51921: LD_VAR 0 14
51925: ST_TO_ADDR
// for j = k downto 1 do
51926: LD_ADDR_VAR 0 8
51930: PUSH
51931: DOUBLE
51932: LD_VAR 0 9
51936: INC
51937: ST_TO_ADDR
51938: LD_INT 1
51940: PUSH
51941: FOR_DOWNTO
51942: IFFALSE 52017
// begin if GetType ( tmp [ j ] ) = unit_human then
51944: LD_VAR 0 14
51948: PUSH
51949: LD_VAR 0 8
51953: ARRAY
51954: PPUSH
51955: CALL_OW 247
51959: PUSH
51960: LD_INT 1
51962: EQUAL
51963: IFFALSE 52015
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
51965: LD_VAR 0 4
51969: PUSH
51970: LD_VAR 0 7
51974: ARRAY
51975: PPUSH
51976: LD_VAR 0 14
51980: PUSH
51981: LD_VAR 0 8
51985: ARRAY
51986: PPUSH
51987: CALL 47457 0 2
// x := tmp [ j ] ;
51991: LD_ADDR_VAR 0 10
51995: PUSH
51996: LD_VAR 0 14
52000: PUSH
52001: LD_VAR 0 8
52005: ARRAY
52006: ST_TO_ADDR
// attacking := true ;
52007: LD_ADDR_VAR 0 29
52011: PUSH
52012: LD_INT 1
52014: ST_TO_ADDR
// end ; end ;
52015: GO 51941
52017: POP
52018: POP
// if not x then
52019: LD_VAR 0 10
52023: NOT
52024: IFFALSE 52164
// begin attacking := true ;
52026: LD_ADDR_VAR 0 29
52030: PUSH
52031: LD_INT 1
52033: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52034: LD_VAR 0 4
52038: PUSH
52039: LD_VAR 0 7
52043: ARRAY
52044: PPUSH
52045: CALL_OW 250
52049: PPUSH
52050: LD_VAR 0 4
52054: PUSH
52055: LD_VAR 0 7
52059: ARRAY
52060: PPUSH
52061: CALL_OW 251
52065: PPUSH
52066: CALL_OW 546
52070: PUSH
52071: LD_INT 2
52073: ARRAY
52074: PUSH
52075: LD_VAR 0 14
52079: PUSH
52080: LD_INT 1
52082: ARRAY
52083: PPUSH
52084: CALL_OW 250
52088: PPUSH
52089: LD_VAR 0 14
52093: PUSH
52094: LD_INT 1
52096: ARRAY
52097: PPUSH
52098: CALL_OW 251
52102: PPUSH
52103: CALL_OW 546
52107: PUSH
52108: LD_INT 2
52110: ARRAY
52111: EQUAL
52112: IFFALSE 52140
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52114: LD_VAR 0 4
52118: PUSH
52119: LD_VAR 0 7
52123: ARRAY
52124: PPUSH
52125: LD_VAR 0 14
52129: PUSH
52130: LD_INT 1
52132: ARRAY
52133: PPUSH
52134: CALL 47457 0 2
52138: GO 52164
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52140: LD_VAR 0 4
52144: PUSH
52145: LD_VAR 0 7
52149: ARRAY
52150: PPUSH
52151: LD_VAR 0 14
52155: PUSH
52156: LD_INT 1
52158: ARRAY
52159: PPUSH
52160: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52164: LD_VAR 0 4
52168: PUSH
52169: LD_VAR 0 7
52173: ARRAY
52174: PPUSH
52175: CALL_OW 264
52179: PUSH
52180: LD_INT 29
52182: EQUAL
52183: IFFALSE 52549
// begin if WantsToAttack ( group [ i ] ) in bombed then
52185: LD_VAR 0 4
52189: PUSH
52190: LD_VAR 0 7
52194: ARRAY
52195: PPUSH
52196: CALL_OW 319
52200: PUSH
52201: LD_VAR 0 28
52205: IN
52206: IFFALSE 52210
// continue ;
52208: GO 49240
// k := 8 ;
52210: LD_ADDR_VAR 0 9
52214: PUSH
52215: LD_INT 8
52217: ST_TO_ADDR
// x := 0 ;
52218: LD_ADDR_VAR 0 10
52222: PUSH
52223: LD_INT 0
52225: ST_TO_ADDR
// if tmp < k then
52226: LD_VAR 0 14
52230: PUSH
52231: LD_VAR 0 9
52235: LESS
52236: IFFALSE 52248
// k := tmp ;
52238: LD_ADDR_VAR 0 9
52242: PUSH
52243: LD_VAR 0 14
52247: ST_TO_ADDR
// for j = 1 to k do
52248: LD_ADDR_VAR 0 8
52252: PUSH
52253: DOUBLE
52254: LD_INT 1
52256: DEC
52257: ST_TO_ADDR
52258: LD_VAR 0 9
52262: PUSH
52263: FOR_TO
52264: IFFALSE 52396
// begin if GetType ( tmp [ j ] ) = unit_building then
52266: LD_VAR 0 14
52270: PUSH
52271: LD_VAR 0 8
52275: ARRAY
52276: PPUSH
52277: CALL_OW 247
52281: PUSH
52282: LD_INT 3
52284: EQUAL
52285: IFFALSE 52394
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52287: LD_VAR 0 14
52291: PUSH
52292: LD_VAR 0 8
52296: ARRAY
52297: PUSH
52298: LD_VAR 0 28
52302: IN
52303: NOT
52304: PUSH
52305: LD_VAR 0 14
52309: PUSH
52310: LD_VAR 0 8
52314: ARRAY
52315: PPUSH
52316: CALL_OW 313
52320: AND
52321: IFFALSE 52394
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52323: LD_VAR 0 4
52327: PUSH
52328: LD_VAR 0 7
52332: ARRAY
52333: PPUSH
52334: LD_VAR 0 14
52338: PUSH
52339: LD_VAR 0 8
52343: ARRAY
52344: PPUSH
52345: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52349: LD_ADDR_VAR 0 28
52353: PUSH
52354: LD_VAR 0 28
52358: PPUSH
52359: LD_VAR 0 28
52363: PUSH
52364: LD_INT 1
52366: PLUS
52367: PPUSH
52368: LD_VAR 0 14
52372: PUSH
52373: LD_VAR 0 8
52377: ARRAY
52378: PPUSH
52379: CALL_OW 1
52383: ST_TO_ADDR
// attacking := true ;
52384: LD_ADDR_VAR 0 29
52388: PUSH
52389: LD_INT 1
52391: ST_TO_ADDR
// break ;
52392: GO 52396
// end ; end ;
52394: GO 52263
52396: POP
52397: POP
// if not attacking and f_attack_depot then
52398: LD_VAR 0 29
52402: NOT
52403: PUSH
52404: LD_VAR 0 25
52408: AND
52409: IFFALSE 52504
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52411: LD_ADDR_VAR 0 13
52415: PUSH
52416: LD_VAR 0 14
52420: PPUSH
52421: LD_INT 2
52423: PUSH
52424: LD_INT 30
52426: PUSH
52427: LD_INT 0
52429: PUSH
52430: EMPTY
52431: LIST
52432: LIST
52433: PUSH
52434: LD_INT 30
52436: PUSH
52437: LD_INT 1
52439: PUSH
52440: EMPTY
52441: LIST
52442: LIST
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: LIST
52448: PPUSH
52449: CALL_OW 72
52453: ST_TO_ADDR
// if z then
52454: LD_VAR 0 13
52458: IFFALSE 52504
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52460: LD_VAR 0 4
52464: PUSH
52465: LD_VAR 0 7
52469: ARRAY
52470: PPUSH
52471: LD_VAR 0 13
52475: PPUSH
52476: LD_VAR 0 4
52480: PUSH
52481: LD_VAR 0 7
52485: ARRAY
52486: PPUSH
52487: CALL_OW 74
52491: PPUSH
52492: CALL_OW 115
// attacking := true ;
52496: LD_ADDR_VAR 0 29
52500: PUSH
52501: LD_INT 1
52503: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52504: LD_VAR 0 4
52508: PUSH
52509: LD_VAR 0 7
52513: ARRAY
52514: PPUSH
52515: CALL_OW 256
52519: PUSH
52520: LD_INT 500
52522: LESS
52523: IFFALSE 52549
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52525: LD_VAR 0 4
52529: PUSH
52530: LD_VAR 0 7
52534: ARRAY
52535: PPUSH
52536: LD_VAR 0 14
52540: PUSH
52541: LD_INT 1
52543: ARRAY
52544: PPUSH
52545: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52549: LD_VAR 0 4
52553: PUSH
52554: LD_VAR 0 7
52558: ARRAY
52559: PPUSH
52560: CALL_OW 264
52564: PUSH
52565: LD_INT 49
52567: EQUAL
52568: IFFALSE 52689
// begin if not HasTask ( group [ i ] ) then
52570: LD_VAR 0 4
52574: PUSH
52575: LD_VAR 0 7
52579: ARRAY
52580: PPUSH
52581: CALL_OW 314
52585: NOT
52586: IFFALSE 52689
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52588: LD_ADDR_VAR 0 9
52592: PUSH
52593: LD_INT 81
52595: PUSH
52596: LD_VAR 0 4
52600: PUSH
52601: LD_VAR 0 7
52605: ARRAY
52606: PPUSH
52607: CALL_OW 255
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: PPUSH
52616: CALL_OW 69
52620: PPUSH
52621: LD_VAR 0 4
52625: PUSH
52626: LD_VAR 0 7
52630: ARRAY
52631: PPUSH
52632: CALL_OW 74
52636: ST_TO_ADDR
// if k then
52637: LD_VAR 0 9
52641: IFFALSE 52689
// if GetDistUnits ( group [ i ] , k ) > 10 then
52643: LD_VAR 0 4
52647: PUSH
52648: LD_VAR 0 7
52652: ARRAY
52653: PPUSH
52654: LD_VAR 0 9
52658: PPUSH
52659: CALL_OW 296
52663: PUSH
52664: LD_INT 10
52666: GREATER
52667: IFFALSE 52689
// ComMoveUnit ( group [ i ] , k ) ;
52669: LD_VAR 0 4
52673: PUSH
52674: LD_VAR 0 7
52678: ARRAY
52679: PPUSH
52680: LD_VAR 0 9
52684: PPUSH
52685: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52689: LD_VAR 0 4
52693: PUSH
52694: LD_VAR 0 7
52698: ARRAY
52699: PPUSH
52700: CALL_OW 256
52704: PUSH
52705: LD_INT 250
52707: LESS
52708: PUSH
52709: LD_VAR 0 4
52713: PUSH
52714: LD_VAR 0 7
52718: ARRAY
52719: PUSH
52720: LD_INT 21
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: EMPTY
52727: LIST
52728: LIST
52729: PUSH
52730: LD_INT 23
52732: PUSH
52733: LD_INT 2
52735: PUSH
52736: EMPTY
52737: LIST
52738: LIST
52739: PUSH
52740: EMPTY
52741: LIST
52742: LIST
52743: PPUSH
52744: CALL_OW 69
52748: IN
52749: AND
52750: IFFALSE 52875
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
52752: LD_ADDR_VAR 0 9
52756: PUSH
52757: LD_OWVAR 3
52761: PUSH
52762: LD_VAR 0 4
52766: PUSH
52767: LD_VAR 0 7
52771: ARRAY
52772: DIFF
52773: PPUSH
52774: LD_VAR 0 4
52778: PUSH
52779: LD_VAR 0 7
52783: ARRAY
52784: PPUSH
52785: CALL_OW 74
52789: ST_TO_ADDR
// if not k then
52790: LD_VAR 0 9
52794: NOT
52795: IFFALSE 52799
// continue ;
52797: GO 49240
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
52799: LD_VAR 0 9
52803: PUSH
52804: LD_INT 81
52806: PUSH
52807: LD_VAR 0 4
52811: PUSH
52812: LD_VAR 0 7
52816: ARRAY
52817: PPUSH
52818: CALL_OW 255
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PPUSH
52827: CALL_OW 69
52831: IN
52832: PUSH
52833: LD_VAR 0 9
52837: PPUSH
52838: LD_VAR 0 4
52842: PUSH
52843: LD_VAR 0 7
52847: ARRAY
52848: PPUSH
52849: CALL_OW 296
52853: PUSH
52854: LD_INT 5
52856: LESS
52857: AND
52858: IFFALSE 52875
// ComAutodestruct ( group [ i ] ) ;
52860: LD_VAR 0 4
52864: PUSH
52865: LD_VAR 0 7
52869: ARRAY
52870: PPUSH
52871: CALL 47355 0 1
// end ; if f_attack_depot then
52875: LD_VAR 0 25
52879: IFFALSE 52991
// begin k := 6 ;
52881: LD_ADDR_VAR 0 9
52885: PUSH
52886: LD_INT 6
52888: ST_TO_ADDR
// if tmp < k then
52889: LD_VAR 0 14
52893: PUSH
52894: LD_VAR 0 9
52898: LESS
52899: IFFALSE 52911
// k := tmp ;
52901: LD_ADDR_VAR 0 9
52905: PUSH
52906: LD_VAR 0 14
52910: ST_TO_ADDR
// for j = 1 to k do
52911: LD_ADDR_VAR 0 8
52915: PUSH
52916: DOUBLE
52917: LD_INT 1
52919: DEC
52920: ST_TO_ADDR
52921: LD_VAR 0 9
52925: PUSH
52926: FOR_TO
52927: IFFALSE 52989
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
52929: LD_VAR 0 8
52933: PPUSH
52934: CALL_OW 266
52938: PUSH
52939: LD_INT 0
52941: PUSH
52942: LD_INT 1
52944: PUSH
52945: EMPTY
52946: LIST
52947: LIST
52948: IN
52949: IFFALSE 52987
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52951: LD_VAR 0 4
52955: PUSH
52956: LD_VAR 0 7
52960: ARRAY
52961: PPUSH
52962: LD_VAR 0 14
52966: PUSH
52967: LD_VAR 0 8
52971: ARRAY
52972: PPUSH
52973: CALL_OW 115
// attacking := true ;
52977: LD_ADDR_VAR 0 29
52981: PUSH
52982: LD_INT 1
52984: ST_TO_ADDR
// break ;
52985: GO 52989
// end ;
52987: GO 52926
52989: POP
52990: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
52991: LD_VAR 0 4
52995: PUSH
52996: LD_VAR 0 7
53000: ARRAY
53001: PPUSH
53002: CALL_OW 302
53006: PUSH
53007: LD_VAR 0 29
53011: NOT
53012: AND
53013: IFFALSE 53335
// begin if GetTag ( group [ i ] ) = 71 then
53015: LD_VAR 0 4
53019: PUSH
53020: LD_VAR 0 7
53024: ARRAY
53025: PPUSH
53026: CALL_OW 110
53030: PUSH
53031: LD_INT 71
53033: EQUAL
53034: IFFALSE 53075
// begin if HasTask ( group [ i ] ) then
53036: LD_VAR 0 4
53040: PUSH
53041: LD_VAR 0 7
53045: ARRAY
53046: PPUSH
53047: CALL_OW 314
53051: IFFALSE 53057
// continue else
53053: GO 49240
53055: GO 53075
// SetTag ( group [ i ] , 0 ) ;
53057: LD_VAR 0 4
53061: PUSH
53062: LD_VAR 0 7
53066: ARRAY
53067: PPUSH
53068: LD_INT 0
53070: PPUSH
53071: CALL_OW 109
// end ; k := 8 ;
53075: LD_ADDR_VAR 0 9
53079: PUSH
53080: LD_INT 8
53082: ST_TO_ADDR
// x := 0 ;
53083: LD_ADDR_VAR 0 10
53087: PUSH
53088: LD_INT 0
53090: ST_TO_ADDR
// if tmp < k then
53091: LD_VAR 0 14
53095: PUSH
53096: LD_VAR 0 9
53100: LESS
53101: IFFALSE 53113
// k := tmp ;
53103: LD_ADDR_VAR 0 9
53107: PUSH
53108: LD_VAR 0 14
53112: ST_TO_ADDR
// for j = 1 to k do
53113: LD_ADDR_VAR 0 8
53117: PUSH
53118: DOUBLE
53119: LD_INT 1
53121: DEC
53122: ST_TO_ADDR
53123: LD_VAR 0 9
53127: PUSH
53128: FOR_TO
53129: IFFALSE 53227
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53131: LD_VAR 0 14
53135: PUSH
53136: LD_VAR 0 8
53140: ARRAY
53141: PPUSH
53142: CALL_OW 247
53146: PUSH
53147: LD_INT 1
53149: EQUAL
53150: PUSH
53151: LD_VAR 0 14
53155: PUSH
53156: LD_VAR 0 8
53160: ARRAY
53161: PPUSH
53162: CALL_OW 256
53166: PUSH
53167: LD_INT 250
53169: LESS
53170: PUSH
53171: LD_VAR 0 20
53175: AND
53176: PUSH
53177: LD_VAR 0 20
53181: NOT
53182: PUSH
53183: LD_VAR 0 14
53187: PUSH
53188: LD_VAR 0 8
53192: ARRAY
53193: PPUSH
53194: CALL_OW 256
53198: PUSH
53199: LD_INT 250
53201: GREATEREQUAL
53202: AND
53203: OR
53204: AND
53205: IFFALSE 53225
// begin x := tmp [ j ] ;
53207: LD_ADDR_VAR 0 10
53211: PUSH
53212: LD_VAR 0 14
53216: PUSH
53217: LD_VAR 0 8
53221: ARRAY
53222: ST_TO_ADDR
// break ;
53223: GO 53227
// end ;
53225: GO 53128
53227: POP
53228: POP
// if x then
53229: LD_VAR 0 10
53233: IFFALSE 53257
// ComAttackUnit ( group [ i ] , x ) else
53235: LD_VAR 0 4
53239: PUSH
53240: LD_VAR 0 7
53244: ARRAY
53245: PPUSH
53246: LD_VAR 0 10
53250: PPUSH
53251: CALL_OW 115
53255: GO 53281
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53257: LD_VAR 0 4
53261: PUSH
53262: LD_VAR 0 7
53266: ARRAY
53267: PPUSH
53268: LD_VAR 0 14
53272: PUSH
53273: LD_INT 1
53275: ARRAY
53276: PPUSH
53277: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53281: LD_VAR 0 4
53285: PUSH
53286: LD_VAR 0 7
53290: ARRAY
53291: PPUSH
53292: CALL_OW 314
53296: NOT
53297: IFFALSE 53335
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53299: LD_VAR 0 4
53303: PUSH
53304: LD_VAR 0 7
53308: ARRAY
53309: PPUSH
53310: LD_VAR 0 14
53314: PPUSH
53315: LD_VAR 0 4
53319: PUSH
53320: LD_VAR 0 7
53324: ARRAY
53325: PPUSH
53326: CALL_OW 74
53330: PPUSH
53331: CALL_OW 115
// end ; end ; end ;
53335: GO 49240
53337: POP
53338: POP
// wait ( 0 0$1 ) ;
53339: LD_INT 35
53341: PPUSH
53342: CALL_OW 67
// until group = [ ] ;
53346: LD_VAR 0 4
53350: PUSH
53351: EMPTY
53352: EQUAL
53353: IFFALSE 49225
// end ;
53355: LD_VAR 0 2
53359: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53360: LD_INT 0
53362: PPUSH
53363: PPUSH
53364: PPUSH
53365: PPUSH
// if not base_units then
53366: LD_VAR 0 1
53370: NOT
53371: IFFALSE 53375
// exit ;
53373: GO 53462
// result := false ;
53375: LD_ADDR_VAR 0 2
53379: PUSH
53380: LD_INT 0
53382: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53383: LD_ADDR_VAR 0 5
53387: PUSH
53388: LD_VAR 0 1
53392: PPUSH
53393: LD_INT 21
53395: PUSH
53396: LD_INT 3
53398: PUSH
53399: EMPTY
53400: LIST
53401: LIST
53402: PPUSH
53403: CALL_OW 72
53407: ST_TO_ADDR
// if not tmp then
53408: LD_VAR 0 5
53412: NOT
53413: IFFALSE 53417
// exit ;
53415: GO 53462
// for i in tmp do
53417: LD_ADDR_VAR 0 3
53421: PUSH
53422: LD_VAR 0 5
53426: PUSH
53427: FOR_IN
53428: IFFALSE 53460
// begin result := EnemyInRange ( i , 22 ) ;
53430: LD_ADDR_VAR 0 2
53434: PUSH
53435: LD_VAR 0 3
53439: PPUSH
53440: LD_INT 22
53442: PPUSH
53443: CALL 47038 0 2
53447: ST_TO_ADDR
// if result then
53448: LD_VAR 0 2
53452: IFFALSE 53458
// exit ;
53454: POP
53455: POP
53456: GO 53462
// end ;
53458: GO 53427
53460: POP
53461: POP
// end ;
53462: LD_VAR 0 2
53466: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53467: LD_INT 0
53469: PPUSH
53470: PPUSH
// if not units then
53471: LD_VAR 0 1
53475: NOT
53476: IFFALSE 53480
// exit ;
53478: GO 53550
// result := [ ] ;
53480: LD_ADDR_VAR 0 3
53484: PUSH
53485: EMPTY
53486: ST_TO_ADDR
// for i in units do
53487: LD_ADDR_VAR 0 4
53491: PUSH
53492: LD_VAR 0 1
53496: PUSH
53497: FOR_IN
53498: IFFALSE 53548
// if GetTag ( i ) = tag then
53500: LD_VAR 0 4
53504: PPUSH
53505: CALL_OW 110
53509: PUSH
53510: LD_VAR 0 2
53514: EQUAL
53515: IFFALSE 53546
// result := Insert ( result , result + 1 , i ) ;
53517: LD_ADDR_VAR 0 3
53521: PUSH
53522: LD_VAR 0 3
53526: PPUSH
53527: LD_VAR 0 3
53531: PUSH
53532: LD_INT 1
53534: PLUS
53535: PPUSH
53536: LD_VAR 0 4
53540: PPUSH
53541: CALL_OW 2
53545: ST_TO_ADDR
53546: GO 53497
53548: POP
53549: POP
// end ;
53550: LD_VAR 0 3
53554: RET
// export function IsDriver ( un ) ; begin
53555: LD_INT 0
53557: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53558: LD_ADDR_VAR 0 2
53562: PUSH
53563: LD_VAR 0 1
53567: PUSH
53568: LD_INT 55
53570: PUSH
53571: EMPTY
53572: LIST
53573: PPUSH
53574: CALL_OW 69
53578: IN
53579: ST_TO_ADDR
// end ;
53580: LD_VAR 0 2
53584: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53585: LD_INT 0
53587: PPUSH
53588: PPUSH
// list := [ ] ;
53589: LD_ADDR_VAR 0 5
53593: PUSH
53594: EMPTY
53595: ST_TO_ADDR
// case d of 0 :
53596: LD_VAR 0 3
53600: PUSH
53601: LD_INT 0
53603: DOUBLE
53604: EQUAL
53605: IFTRUE 53609
53607: GO 53742
53609: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53610: LD_ADDR_VAR 0 5
53614: PUSH
53615: LD_VAR 0 1
53619: PUSH
53620: LD_INT 4
53622: MINUS
53623: PUSH
53624: LD_VAR 0 2
53628: PUSH
53629: LD_INT 4
53631: MINUS
53632: PUSH
53633: LD_INT 2
53635: PUSH
53636: EMPTY
53637: LIST
53638: LIST
53639: LIST
53640: PUSH
53641: LD_VAR 0 1
53645: PUSH
53646: LD_INT 3
53648: MINUS
53649: PUSH
53650: LD_VAR 0 2
53654: PUSH
53655: LD_INT 1
53657: PUSH
53658: EMPTY
53659: LIST
53660: LIST
53661: LIST
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_INT 4
53670: PLUS
53671: PUSH
53672: LD_VAR 0 2
53676: PUSH
53677: LD_INT 4
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: LIST
53684: PUSH
53685: LD_VAR 0 1
53689: PUSH
53690: LD_INT 3
53692: PLUS
53693: PUSH
53694: LD_VAR 0 2
53698: PUSH
53699: LD_INT 3
53701: PLUS
53702: PUSH
53703: LD_INT 5
53705: PUSH
53706: EMPTY
53707: LIST
53708: LIST
53709: LIST
53710: PUSH
53711: LD_VAR 0 1
53715: PUSH
53716: LD_VAR 0 2
53720: PUSH
53721: LD_INT 4
53723: PLUS
53724: PUSH
53725: LD_INT 0
53727: PUSH
53728: EMPTY
53729: LIST
53730: LIST
53731: LIST
53732: PUSH
53733: EMPTY
53734: LIST
53735: LIST
53736: LIST
53737: LIST
53738: LIST
53739: ST_TO_ADDR
// end ; 1 :
53740: GO 54440
53742: LD_INT 1
53744: DOUBLE
53745: EQUAL
53746: IFTRUE 53750
53748: GO 53883
53750: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53751: LD_ADDR_VAR 0 5
53755: PUSH
53756: LD_VAR 0 1
53760: PUSH
53761: LD_VAR 0 2
53765: PUSH
53766: LD_INT 4
53768: MINUS
53769: PUSH
53770: LD_INT 3
53772: PUSH
53773: EMPTY
53774: LIST
53775: LIST
53776: LIST
53777: PUSH
53778: LD_VAR 0 1
53782: PUSH
53783: LD_INT 3
53785: MINUS
53786: PUSH
53787: LD_VAR 0 2
53791: PUSH
53792: LD_INT 3
53794: MINUS
53795: PUSH
53796: LD_INT 2
53798: PUSH
53799: EMPTY
53800: LIST
53801: LIST
53802: LIST
53803: PUSH
53804: LD_VAR 0 1
53808: PUSH
53809: LD_INT 4
53811: MINUS
53812: PUSH
53813: LD_VAR 0 2
53817: PUSH
53818: LD_INT 1
53820: PUSH
53821: EMPTY
53822: LIST
53823: LIST
53824: LIST
53825: PUSH
53826: LD_VAR 0 1
53830: PUSH
53831: LD_VAR 0 2
53835: PUSH
53836: LD_INT 3
53838: PLUS
53839: PUSH
53840: LD_INT 0
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: LIST
53847: PUSH
53848: LD_VAR 0 1
53852: PUSH
53853: LD_INT 4
53855: PLUS
53856: PUSH
53857: LD_VAR 0 2
53861: PUSH
53862: LD_INT 4
53864: PLUS
53865: PUSH
53866: LD_INT 5
53868: PUSH
53869: EMPTY
53870: LIST
53871: LIST
53872: LIST
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: LIST
53878: LIST
53879: LIST
53880: ST_TO_ADDR
// end ; 2 :
53881: GO 54440
53883: LD_INT 2
53885: DOUBLE
53886: EQUAL
53887: IFTRUE 53891
53889: GO 54020
53891: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53892: LD_ADDR_VAR 0 5
53896: PUSH
53897: LD_VAR 0 1
53901: PUSH
53902: LD_VAR 0 2
53906: PUSH
53907: LD_INT 3
53909: MINUS
53910: PUSH
53911: LD_INT 3
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: LIST
53918: PUSH
53919: LD_VAR 0 1
53923: PUSH
53924: LD_INT 4
53926: PLUS
53927: PUSH
53928: LD_VAR 0 2
53932: PUSH
53933: LD_INT 4
53935: PUSH
53936: EMPTY
53937: LIST
53938: LIST
53939: LIST
53940: PUSH
53941: LD_VAR 0 1
53945: PUSH
53946: LD_VAR 0 2
53950: PUSH
53951: LD_INT 4
53953: PLUS
53954: PUSH
53955: LD_INT 0
53957: PUSH
53958: EMPTY
53959: LIST
53960: LIST
53961: LIST
53962: PUSH
53963: LD_VAR 0 1
53967: PUSH
53968: LD_INT 3
53970: MINUS
53971: PUSH
53972: LD_VAR 0 2
53976: PUSH
53977: LD_INT 1
53979: PUSH
53980: EMPTY
53981: LIST
53982: LIST
53983: LIST
53984: PUSH
53985: LD_VAR 0 1
53989: PUSH
53990: LD_INT 4
53992: MINUS
53993: PUSH
53994: LD_VAR 0 2
53998: PUSH
53999: LD_INT 4
54001: MINUS
54002: PUSH
54003: LD_INT 2
54005: PUSH
54006: EMPTY
54007: LIST
54008: LIST
54009: LIST
54010: PUSH
54011: EMPTY
54012: LIST
54013: LIST
54014: LIST
54015: LIST
54016: LIST
54017: ST_TO_ADDR
// end ; 3 :
54018: GO 54440
54020: LD_INT 3
54022: DOUBLE
54023: EQUAL
54024: IFTRUE 54028
54026: GO 54161
54028: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54029: LD_ADDR_VAR 0 5
54033: PUSH
54034: LD_VAR 0 1
54038: PUSH
54039: LD_INT 3
54041: PLUS
54042: PUSH
54043: LD_VAR 0 2
54047: PUSH
54048: LD_INT 4
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: LIST
54055: PUSH
54056: LD_VAR 0 1
54060: PUSH
54061: LD_INT 4
54063: PLUS
54064: PUSH
54065: LD_VAR 0 2
54069: PUSH
54070: LD_INT 4
54072: PLUS
54073: PUSH
54074: LD_INT 5
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: LIST
54081: PUSH
54082: LD_VAR 0 1
54086: PUSH
54087: LD_INT 4
54089: MINUS
54090: PUSH
54091: LD_VAR 0 2
54095: PUSH
54096: LD_INT 1
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: LIST
54103: PUSH
54104: LD_VAR 0 1
54108: PUSH
54109: LD_VAR 0 2
54113: PUSH
54114: LD_INT 4
54116: MINUS
54117: PUSH
54118: LD_INT 3
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: LIST
54125: PUSH
54126: LD_VAR 0 1
54130: PUSH
54131: LD_INT 3
54133: MINUS
54134: PUSH
54135: LD_VAR 0 2
54139: PUSH
54140: LD_INT 3
54142: MINUS
54143: PUSH
54144: LD_INT 2
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: PUSH
54152: EMPTY
54153: LIST
54154: LIST
54155: LIST
54156: LIST
54157: LIST
54158: ST_TO_ADDR
// end ; 4 :
54159: GO 54440
54161: LD_INT 4
54163: DOUBLE
54164: EQUAL
54165: IFTRUE 54169
54167: GO 54302
54169: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54170: LD_ADDR_VAR 0 5
54174: PUSH
54175: LD_VAR 0 1
54179: PUSH
54180: LD_VAR 0 2
54184: PUSH
54185: LD_INT 4
54187: PLUS
54188: PUSH
54189: LD_INT 0
54191: PUSH
54192: EMPTY
54193: LIST
54194: LIST
54195: LIST
54196: PUSH
54197: LD_VAR 0 1
54201: PUSH
54202: LD_INT 3
54204: PLUS
54205: PUSH
54206: LD_VAR 0 2
54210: PUSH
54211: LD_INT 3
54213: PLUS
54214: PUSH
54215: LD_INT 5
54217: PUSH
54218: EMPTY
54219: LIST
54220: LIST
54221: LIST
54222: PUSH
54223: LD_VAR 0 1
54227: PUSH
54228: LD_INT 4
54230: PLUS
54231: PUSH
54232: LD_VAR 0 2
54236: PUSH
54237: LD_INT 4
54239: PUSH
54240: EMPTY
54241: LIST
54242: LIST
54243: LIST
54244: PUSH
54245: LD_VAR 0 1
54249: PUSH
54250: LD_VAR 0 2
54254: PUSH
54255: LD_INT 3
54257: MINUS
54258: PUSH
54259: LD_INT 3
54261: PUSH
54262: EMPTY
54263: LIST
54264: LIST
54265: LIST
54266: PUSH
54267: LD_VAR 0 1
54271: PUSH
54272: LD_INT 4
54274: MINUS
54275: PUSH
54276: LD_VAR 0 2
54280: PUSH
54281: LD_INT 4
54283: MINUS
54284: PUSH
54285: LD_INT 2
54287: PUSH
54288: EMPTY
54289: LIST
54290: LIST
54291: LIST
54292: PUSH
54293: EMPTY
54294: LIST
54295: LIST
54296: LIST
54297: LIST
54298: LIST
54299: ST_TO_ADDR
// end ; 5 :
54300: GO 54440
54302: LD_INT 5
54304: DOUBLE
54305: EQUAL
54306: IFTRUE 54310
54308: GO 54439
54310: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54311: LD_ADDR_VAR 0 5
54315: PUSH
54316: LD_VAR 0 1
54320: PUSH
54321: LD_INT 4
54323: MINUS
54324: PUSH
54325: LD_VAR 0 2
54329: PUSH
54330: LD_INT 1
54332: PUSH
54333: EMPTY
54334: LIST
54335: LIST
54336: LIST
54337: PUSH
54338: LD_VAR 0 1
54342: PUSH
54343: LD_VAR 0 2
54347: PUSH
54348: LD_INT 4
54350: MINUS
54351: PUSH
54352: LD_INT 3
54354: PUSH
54355: EMPTY
54356: LIST
54357: LIST
54358: LIST
54359: PUSH
54360: LD_VAR 0 1
54364: PUSH
54365: LD_INT 4
54367: PLUS
54368: PUSH
54369: LD_VAR 0 2
54373: PUSH
54374: LD_INT 4
54376: PLUS
54377: PUSH
54378: LD_INT 5
54380: PUSH
54381: EMPTY
54382: LIST
54383: LIST
54384: LIST
54385: PUSH
54386: LD_VAR 0 1
54390: PUSH
54391: LD_INT 3
54393: PLUS
54394: PUSH
54395: LD_VAR 0 2
54399: PUSH
54400: LD_INT 4
54402: PUSH
54403: EMPTY
54404: LIST
54405: LIST
54406: LIST
54407: PUSH
54408: LD_VAR 0 1
54412: PUSH
54413: LD_VAR 0 2
54417: PUSH
54418: LD_INT 3
54420: PLUS
54421: PUSH
54422: LD_INT 0
54424: PUSH
54425: EMPTY
54426: LIST
54427: LIST
54428: LIST
54429: PUSH
54430: EMPTY
54431: LIST
54432: LIST
54433: LIST
54434: LIST
54435: LIST
54436: ST_TO_ADDR
// end ; end ;
54437: GO 54440
54439: POP
// result := list ;
54440: LD_ADDR_VAR 0 4
54444: PUSH
54445: LD_VAR 0 5
54449: ST_TO_ADDR
// end ;
54450: LD_VAR 0 4
54454: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54455: LD_INT 0
54457: PPUSH
54458: PPUSH
54459: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54460: LD_VAR 0 1
54464: NOT
54465: PUSH
54466: LD_VAR 0 2
54470: PUSH
54471: LD_INT 1
54473: PUSH
54474: LD_INT 2
54476: PUSH
54477: LD_INT 3
54479: PUSH
54480: LD_INT 4
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: LIST
54487: LIST
54488: IN
54489: NOT
54490: OR
54491: IFFALSE 54495
// exit ;
54493: GO 54587
// tmp := [ ] ;
54495: LD_ADDR_VAR 0 5
54499: PUSH
54500: EMPTY
54501: ST_TO_ADDR
// for i in units do
54502: LD_ADDR_VAR 0 4
54506: PUSH
54507: LD_VAR 0 1
54511: PUSH
54512: FOR_IN
54513: IFFALSE 54556
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54515: LD_ADDR_VAR 0 5
54519: PUSH
54520: LD_VAR 0 5
54524: PPUSH
54525: LD_VAR 0 5
54529: PUSH
54530: LD_INT 1
54532: PLUS
54533: PPUSH
54534: LD_VAR 0 4
54538: PPUSH
54539: LD_VAR 0 2
54543: PPUSH
54544: CALL_OW 259
54548: PPUSH
54549: CALL_OW 2
54553: ST_TO_ADDR
54554: GO 54512
54556: POP
54557: POP
// if not tmp then
54558: LD_VAR 0 5
54562: NOT
54563: IFFALSE 54567
// exit ;
54565: GO 54587
// result := SortListByListDesc ( units , tmp ) ;
54567: LD_ADDR_VAR 0 3
54571: PUSH
54572: LD_VAR 0 1
54576: PPUSH
54577: LD_VAR 0 5
54581: PPUSH
54582: CALL_OW 77
54586: ST_TO_ADDR
// end ;
54587: LD_VAR 0 3
54591: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54592: LD_INT 0
54594: PPUSH
54595: PPUSH
54596: PPUSH
// x := GetX ( building ) ;
54597: LD_ADDR_VAR 0 4
54601: PUSH
54602: LD_VAR 0 2
54606: PPUSH
54607: CALL_OW 250
54611: ST_TO_ADDR
// y := GetY ( building ) ;
54612: LD_ADDR_VAR 0 5
54616: PUSH
54617: LD_VAR 0 2
54621: PPUSH
54622: CALL_OW 251
54626: ST_TO_ADDR
// if GetTaskList ( unit ) then
54627: LD_VAR 0 1
54631: PPUSH
54632: CALL_OW 437
54636: IFFALSE 54731
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54638: LD_STRING e
54640: PUSH
54641: LD_VAR 0 1
54645: PPUSH
54646: CALL_OW 437
54650: PUSH
54651: LD_INT 1
54653: ARRAY
54654: PUSH
54655: LD_INT 1
54657: ARRAY
54658: EQUAL
54659: PUSH
54660: LD_VAR 0 4
54664: PUSH
54665: LD_VAR 0 1
54669: PPUSH
54670: CALL_OW 437
54674: PUSH
54675: LD_INT 1
54677: ARRAY
54678: PUSH
54679: LD_INT 2
54681: ARRAY
54682: EQUAL
54683: AND
54684: PUSH
54685: LD_VAR 0 5
54689: PUSH
54690: LD_VAR 0 1
54694: PPUSH
54695: CALL_OW 437
54699: PUSH
54700: LD_INT 1
54702: ARRAY
54703: PUSH
54704: LD_INT 3
54706: ARRAY
54707: EQUAL
54708: AND
54709: IFFALSE 54721
// result := true else
54711: LD_ADDR_VAR 0 3
54715: PUSH
54716: LD_INT 1
54718: ST_TO_ADDR
54719: GO 54729
// result := false ;
54721: LD_ADDR_VAR 0 3
54725: PUSH
54726: LD_INT 0
54728: ST_TO_ADDR
// end else
54729: GO 54739
// result := false ;
54731: LD_ADDR_VAR 0 3
54735: PUSH
54736: LD_INT 0
54738: ST_TO_ADDR
// end ;
54739: LD_VAR 0 3
54743: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54744: LD_INT 0
54746: PPUSH
54747: PPUSH
54748: PPUSH
54749: PPUSH
// if not unit or not area then
54750: LD_VAR 0 1
54754: NOT
54755: PUSH
54756: LD_VAR 0 2
54760: NOT
54761: OR
54762: IFFALSE 54766
// exit ;
54764: GO 54931
// tmp := AreaToList ( area , i ) ;
54766: LD_ADDR_VAR 0 6
54770: PUSH
54771: LD_VAR 0 2
54775: PPUSH
54776: LD_VAR 0 5
54780: PPUSH
54781: CALL_OW 517
54785: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54786: LD_ADDR_VAR 0 5
54790: PUSH
54791: DOUBLE
54792: LD_INT 1
54794: DEC
54795: ST_TO_ADDR
54796: LD_VAR 0 6
54800: PUSH
54801: LD_INT 1
54803: ARRAY
54804: PUSH
54805: FOR_TO
54806: IFFALSE 54921
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54808: LD_ADDR_VAR 0 7
54812: PUSH
54813: LD_VAR 0 6
54817: PUSH
54818: LD_INT 1
54820: ARRAY
54821: PUSH
54822: LD_VAR 0 5
54826: ARRAY
54827: PUSH
54828: LD_VAR 0 6
54832: PUSH
54833: LD_INT 2
54835: ARRAY
54836: PUSH
54837: LD_VAR 0 5
54841: ARRAY
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54847: LD_VAR 0 7
54851: PUSH
54852: LD_INT 1
54854: ARRAY
54855: PPUSH
54856: LD_VAR 0 7
54860: PUSH
54861: LD_INT 2
54863: ARRAY
54864: PPUSH
54865: CALL_OW 428
54869: PUSH
54870: LD_INT 0
54872: EQUAL
54873: IFFALSE 54919
// begin result := true ;
54875: LD_ADDR_VAR 0 4
54879: PUSH
54880: LD_INT 1
54882: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54883: LD_VAR 0 1
54887: PPUSH
54888: LD_VAR 0 7
54892: PUSH
54893: LD_INT 1
54895: ARRAY
54896: PPUSH
54897: LD_VAR 0 7
54901: PUSH
54902: LD_INT 2
54904: ARRAY
54905: PPUSH
54906: LD_VAR 0 3
54910: PPUSH
54911: CALL_OW 48
// exit ;
54915: POP
54916: POP
54917: GO 54931
// end ; end ;
54919: GO 54805
54921: POP
54922: POP
// result := false ;
54923: LD_ADDR_VAR 0 4
54927: PUSH
54928: LD_INT 0
54930: ST_TO_ADDR
// end ;
54931: LD_VAR 0 4
54935: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54936: LD_INT 0
54938: PPUSH
54939: PPUSH
54940: PPUSH
// if not side or side > 8 then
54941: LD_VAR 0 1
54945: NOT
54946: PUSH
54947: LD_VAR 0 1
54951: PUSH
54952: LD_INT 8
54954: GREATER
54955: OR
54956: IFFALSE 54960
// exit ;
54958: GO 55147
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54960: LD_ADDR_VAR 0 4
54964: PUSH
54965: LD_INT 22
54967: PUSH
54968: LD_VAR 0 1
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: PUSH
54977: LD_INT 21
54979: PUSH
54980: LD_INT 3
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: PPUSH
54991: CALL_OW 69
54995: ST_TO_ADDR
// if not tmp then
54996: LD_VAR 0 4
55000: NOT
55001: IFFALSE 55005
// exit ;
55003: GO 55147
// enable_addtolog := true ;
55005: LD_ADDR_OWVAR 81
55009: PUSH
55010: LD_INT 1
55012: ST_TO_ADDR
// AddToLog ( [ ) ;
55013: LD_STRING [
55015: PPUSH
55016: CALL_OW 561
// for i in tmp do
55020: LD_ADDR_VAR 0 3
55024: PUSH
55025: LD_VAR 0 4
55029: PUSH
55030: FOR_IN
55031: IFFALSE 55138
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55033: LD_STRING [
55035: PUSH
55036: LD_VAR 0 3
55040: PPUSH
55041: CALL_OW 266
55045: STR
55046: PUSH
55047: LD_STRING , 
55049: STR
55050: PUSH
55051: LD_VAR 0 3
55055: PPUSH
55056: CALL_OW 250
55060: STR
55061: PUSH
55062: LD_STRING , 
55064: STR
55065: PUSH
55066: LD_VAR 0 3
55070: PPUSH
55071: CALL_OW 251
55075: STR
55076: PUSH
55077: LD_STRING , 
55079: STR
55080: PUSH
55081: LD_VAR 0 3
55085: PPUSH
55086: CALL_OW 254
55090: STR
55091: PUSH
55092: LD_STRING , 
55094: STR
55095: PUSH
55096: LD_VAR 0 3
55100: PPUSH
55101: LD_INT 1
55103: PPUSH
55104: CALL_OW 268
55108: STR
55109: PUSH
55110: LD_STRING , 
55112: STR
55113: PUSH
55114: LD_VAR 0 3
55118: PPUSH
55119: LD_INT 2
55121: PPUSH
55122: CALL_OW 268
55126: STR
55127: PUSH
55128: LD_STRING ],
55130: STR
55131: PPUSH
55132: CALL_OW 561
// end ;
55136: GO 55030
55138: POP
55139: POP
// AddToLog ( ]; ) ;
55140: LD_STRING ];
55142: PPUSH
55143: CALL_OW 561
// end ;
55147: LD_VAR 0 2
55151: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55152: LD_INT 0
55154: PPUSH
55155: PPUSH
55156: PPUSH
55157: PPUSH
55158: PPUSH
// if not area or not rate or not max then
55159: LD_VAR 0 1
55163: NOT
55164: PUSH
55165: LD_VAR 0 2
55169: NOT
55170: OR
55171: PUSH
55172: LD_VAR 0 4
55176: NOT
55177: OR
55178: IFFALSE 55182
// exit ;
55180: GO 55374
// while 1 do
55182: LD_INT 1
55184: IFFALSE 55374
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55186: LD_ADDR_VAR 0 9
55190: PUSH
55191: LD_VAR 0 1
55195: PPUSH
55196: LD_INT 1
55198: PPUSH
55199: CALL_OW 287
55203: PUSH
55204: LD_INT 10
55206: MUL
55207: ST_TO_ADDR
// r := rate / 10 ;
55208: LD_ADDR_VAR 0 7
55212: PUSH
55213: LD_VAR 0 2
55217: PUSH
55218: LD_INT 10
55220: DIVREAL
55221: ST_TO_ADDR
// time := 1 1$00 ;
55222: LD_ADDR_VAR 0 8
55226: PUSH
55227: LD_INT 2100
55229: ST_TO_ADDR
// if amount < min then
55230: LD_VAR 0 9
55234: PUSH
55235: LD_VAR 0 3
55239: LESS
55240: IFFALSE 55258
// r := r * 2 else
55242: LD_ADDR_VAR 0 7
55246: PUSH
55247: LD_VAR 0 7
55251: PUSH
55252: LD_INT 2
55254: MUL
55255: ST_TO_ADDR
55256: GO 55284
// if amount > max then
55258: LD_VAR 0 9
55262: PUSH
55263: LD_VAR 0 4
55267: GREATER
55268: IFFALSE 55284
// r := r / 2 ;
55270: LD_ADDR_VAR 0 7
55274: PUSH
55275: LD_VAR 0 7
55279: PUSH
55280: LD_INT 2
55282: DIVREAL
55283: ST_TO_ADDR
// time := time / r ;
55284: LD_ADDR_VAR 0 8
55288: PUSH
55289: LD_VAR 0 8
55293: PUSH
55294: LD_VAR 0 7
55298: DIVREAL
55299: ST_TO_ADDR
// if time < 0 then
55300: LD_VAR 0 8
55304: PUSH
55305: LD_INT 0
55307: LESS
55308: IFFALSE 55325
// time := time * - 1 ;
55310: LD_ADDR_VAR 0 8
55314: PUSH
55315: LD_VAR 0 8
55319: PUSH
55320: LD_INT 1
55322: NEG
55323: MUL
55324: ST_TO_ADDR
// wait ( time ) ;
55325: LD_VAR 0 8
55329: PPUSH
55330: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55334: LD_INT 35
55336: PPUSH
55337: LD_INT 875
55339: PPUSH
55340: CALL_OW 12
55344: PPUSH
55345: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55349: LD_INT 1
55351: PPUSH
55352: LD_INT 5
55354: PPUSH
55355: CALL_OW 12
55359: PPUSH
55360: LD_VAR 0 1
55364: PPUSH
55365: LD_INT 1
55367: PPUSH
55368: CALL_OW 55
// end ;
55372: GO 55182
// end ;
55374: LD_VAR 0 5
55378: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55379: LD_INT 0
55381: PPUSH
55382: PPUSH
55383: PPUSH
55384: PPUSH
55385: PPUSH
55386: PPUSH
55387: PPUSH
55388: PPUSH
// if not turrets or not factories then
55389: LD_VAR 0 1
55393: NOT
55394: PUSH
55395: LD_VAR 0 2
55399: NOT
55400: OR
55401: IFFALSE 55405
// exit ;
55403: GO 55712
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55405: LD_ADDR_VAR 0 10
55409: PUSH
55410: LD_INT 5
55412: PUSH
55413: LD_INT 6
55415: PUSH
55416: EMPTY
55417: LIST
55418: LIST
55419: PUSH
55420: LD_INT 2
55422: PUSH
55423: LD_INT 4
55425: PUSH
55426: EMPTY
55427: LIST
55428: LIST
55429: PUSH
55430: LD_INT 3
55432: PUSH
55433: LD_INT 5
55435: PUSH
55436: EMPTY
55437: LIST
55438: LIST
55439: PUSH
55440: EMPTY
55441: LIST
55442: LIST
55443: LIST
55444: PUSH
55445: LD_INT 24
55447: PUSH
55448: LD_INT 25
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: PUSH
55455: LD_INT 23
55457: PUSH
55458: LD_INT 27
55460: PUSH
55461: EMPTY
55462: LIST
55463: LIST
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 42
55471: PUSH
55472: LD_INT 43
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PUSH
55479: LD_INT 44
55481: PUSH
55482: LD_INT 46
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PUSH
55489: LD_INT 45
55491: PUSH
55492: LD_INT 47
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: LIST
55503: PUSH
55504: EMPTY
55505: LIST
55506: LIST
55507: LIST
55508: ST_TO_ADDR
// result := [ ] ;
55509: LD_ADDR_VAR 0 3
55513: PUSH
55514: EMPTY
55515: ST_TO_ADDR
// for i in turrets do
55516: LD_ADDR_VAR 0 4
55520: PUSH
55521: LD_VAR 0 1
55525: PUSH
55526: FOR_IN
55527: IFFALSE 55710
// begin nat := GetNation ( i ) ;
55529: LD_ADDR_VAR 0 7
55533: PUSH
55534: LD_VAR 0 4
55538: PPUSH
55539: CALL_OW 248
55543: ST_TO_ADDR
// weapon := 0 ;
55544: LD_ADDR_VAR 0 8
55548: PUSH
55549: LD_INT 0
55551: ST_TO_ADDR
// if not nat then
55552: LD_VAR 0 7
55556: NOT
55557: IFFALSE 55561
// continue ;
55559: GO 55526
// for j in list [ nat ] do
55561: LD_ADDR_VAR 0 5
55565: PUSH
55566: LD_VAR 0 10
55570: PUSH
55571: LD_VAR 0 7
55575: ARRAY
55576: PUSH
55577: FOR_IN
55578: IFFALSE 55619
// if GetBWeapon ( i ) = j [ 1 ] then
55580: LD_VAR 0 4
55584: PPUSH
55585: CALL_OW 269
55589: PUSH
55590: LD_VAR 0 5
55594: PUSH
55595: LD_INT 1
55597: ARRAY
55598: EQUAL
55599: IFFALSE 55617
// begin weapon := j [ 2 ] ;
55601: LD_ADDR_VAR 0 8
55605: PUSH
55606: LD_VAR 0 5
55610: PUSH
55611: LD_INT 2
55613: ARRAY
55614: ST_TO_ADDR
// break ;
55615: GO 55619
// end ;
55617: GO 55577
55619: POP
55620: POP
// if not weapon then
55621: LD_VAR 0 8
55625: NOT
55626: IFFALSE 55630
// continue ;
55628: GO 55526
// for k in factories do
55630: LD_ADDR_VAR 0 6
55634: PUSH
55635: LD_VAR 0 2
55639: PUSH
55640: FOR_IN
55641: IFFALSE 55706
// begin weapons := AvailableWeaponList ( k ) ;
55643: LD_ADDR_VAR 0 9
55647: PUSH
55648: LD_VAR 0 6
55652: PPUSH
55653: CALL_OW 478
55657: ST_TO_ADDR
// if not weapons then
55658: LD_VAR 0 9
55662: NOT
55663: IFFALSE 55667
// continue ;
55665: GO 55640
// if weapon in weapons then
55667: LD_VAR 0 8
55671: PUSH
55672: LD_VAR 0 9
55676: IN
55677: IFFALSE 55704
// begin result := [ i , weapon ] ;
55679: LD_ADDR_VAR 0 3
55683: PUSH
55684: LD_VAR 0 4
55688: PUSH
55689: LD_VAR 0 8
55693: PUSH
55694: EMPTY
55695: LIST
55696: LIST
55697: ST_TO_ADDR
// exit ;
55698: POP
55699: POP
55700: POP
55701: POP
55702: GO 55712
// end ; end ;
55704: GO 55640
55706: POP
55707: POP
// end ;
55708: GO 55526
55710: POP
55711: POP
// end ;
55712: LD_VAR 0 3
55716: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55717: LD_INT 0
55719: PPUSH
// if not side or side > 8 then
55720: LD_VAR 0 3
55724: NOT
55725: PUSH
55726: LD_VAR 0 3
55730: PUSH
55731: LD_INT 8
55733: GREATER
55734: OR
55735: IFFALSE 55739
// exit ;
55737: GO 55798
// if not range then
55739: LD_VAR 0 4
55743: NOT
55744: IFFALSE 55755
// range := - 12 ;
55746: LD_ADDR_VAR 0 4
55750: PUSH
55751: LD_INT 12
55753: NEG
55754: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55755: LD_VAR 0 1
55759: PPUSH
55760: LD_VAR 0 2
55764: PPUSH
55765: LD_VAR 0 3
55769: PPUSH
55770: LD_VAR 0 4
55774: PPUSH
55775: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55779: LD_VAR 0 1
55783: PPUSH
55784: LD_VAR 0 2
55788: PPUSH
55789: LD_VAR 0 3
55793: PPUSH
55794: CALL_OW 331
// end ;
55798: LD_VAR 0 5
55802: RET
// export function Video ( mode ) ; begin
55803: LD_INT 0
55805: PPUSH
// ingame_video = mode ;
55806: LD_ADDR_OWVAR 52
55810: PUSH
55811: LD_VAR 0 1
55815: ST_TO_ADDR
// interface_hidden = mode ;
55816: LD_ADDR_OWVAR 54
55820: PUSH
55821: LD_VAR 0 1
55825: ST_TO_ADDR
// end ;
55826: LD_VAR 0 2
55830: RET
// export function Join ( array , element ) ; begin
55831: LD_INT 0
55833: PPUSH
// result := array ^ element ;
55834: LD_ADDR_VAR 0 3
55838: PUSH
55839: LD_VAR 0 1
55843: PUSH
55844: LD_VAR 0 2
55848: ADD
55849: ST_TO_ADDR
// end ;
55850: LD_VAR 0 3
55854: RET
// export function JoinUnion ( array , element ) ; begin
55855: LD_INT 0
55857: PPUSH
// result := array union element ;
55858: LD_ADDR_VAR 0 3
55862: PUSH
55863: LD_VAR 0 1
55867: PUSH
55868: LD_VAR 0 2
55872: UNION
55873: ST_TO_ADDR
// end ;
55874: LD_VAR 0 3
55878: RET
// export function GetBehemoths ( side ) ; begin
55879: LD_INT 0
55881: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
55882: LD_ADDR_VAR 0 2
55886: PUSH
55887: LD_INT 22
55889: PUSH
55890: LD_VAR 0 1
55894: PUSH
55895: EMPTY
55896: LIST
55897: LIST
55898: PUSH
55899: LD_INT 31
55901: PUSH
55902: LD_INT 25
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: PUSH
55909: EMPTY
55910: LIST
55911: LIST
55912: PPUSH
55913: CALL_OW 69
55917: ST_TO_ADDR
// end ; end_of_file
55918: LD_VAR 0 2
55922: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
55923: LD_INT 0
55925: PPUSH
55926: PPUSH
// skirmish := false ;
55927: LD_ADDR_EXP 56
55931: PUSH
55932: LD_INT 0
55934: ST_TO_ADDR
// debug_mc := false ;
55935: LD_ADDR_EXP 57
55939: PUSH
55940: LD_INT 0
55942: ST_TO_ADDR
// mc_bases := [ ] ;
55943: LD_ADDR_EXP 58
55947: PUSH
55948: EMPTY
55949: ST_TO_ADDR
// mc_sides := [ ] ;
55950: LD_ADDR_EXP 84
55954: PUSH
55955: EMPTY
55956: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55957: LD_ADDR_EXP 59
55961: PUSH
55962: EMPTY
55963: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55964: LD_ADDR_EXP 60
55968: PUSH
55969: EMPTY
55970: ST_TO_ADDR
// mc_need_heal := [ ] ;
55971: LD_ADDR_EXP 61
55975: PUSH
55976: EMPTY
55977: ST_TO_ADDR
// mc_healers := [ ] ;
55978: LD_ADDR_EXP 62
55982: PUSH
55983: EMPTY
55984: ST_TO_ADDR
// mc_build_list := [ ] ;
55985: LD_ADDR_EXP 63
55989: PUSH
55990: EMPTY
55991: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55992: LD_ADDR_EXP 90
55996: PUSH
55997: EMPTY
55998: ST_TO_ADDR
// mc_builders := [ ] ;
55999: LD_ADDR_EXP 64
56003: PUSH
56004: EMPTY
56005: ST_TO_ADDR
// mc_construct_list := [ ] ;
56006: LD_ADDR_EXP 65
56010: PUSH
56011: EMPTY
56012: ST_TO_ADDR
// mc_turret_list := [ ] ;
56013: LD_ADDR_EXP 66
56017: PUSH
56018: EMPTY
56019: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56020: LD_ADDR_EXP 67
56024: PUSH
56025: EMPTY
56026: ST_TO_ADDR
// mc_miners := [ ] ;
56027: LD_ADDR_EXP 72
56031: PUSH
56032: EMPTY
56033: ST_TO_ADDR
// mc_mines := [ ] ;
56034: LD_ADDR_EXP 71
56038: PUSH
56039: EMPTY
56040: ST_TO_ADDR
// mc_minefields := [ ] ;
56041: LD_ADDR_EXP 73
56045: PUSH
56046: EMPTY
56047: ST_TO_ADDR
// mc_crates := [ ] ;
56048: LD_ADDR_EXP 74
56052: PUSH
56053: EMPTY
56054: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56055: LD_ADDR_EXP 75
56059: PUSH
56060: EMPTY
56061: ST_TO_ADDR
// mc_crates_area := [ ] ;
56062: LD_ADDR_EXP 76
56066: PUSH
56067: EMPTY
56068: ST_TO_ADDR
// mc_vehicles := [ ] ;
56069: LD_ADDR_EXP 77
56073: PUSH
56074: EMPTY
56075: ST_TO_ADDR
// mc_attack := [ ] ;
56076: LD_ADDR_EXP 78
56080: PUSH
56081: EMPTY
56082: ST_TO_ADDR
// mc_produce := [ ] ;
56083: LD_ADDR_EXP 79
56087: PUSH
56088: EMPTY
56089: ST_TO_ADDR
// mc_defender := [ ] ;
56090: LD_ADDR_EXP 80
56094: PUSH
56095: EMPTY
56096: ST_TO_ADDR
// mc_parking := [ ] ;
56097: LD_ADDR_EXP 82
56101: PUSH
56102: EMPTY
56103: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56104: LD_ADDR_EXP 68
56108: PUSH
56109: EMPTY
56110: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56111: LD_ADDR_EXP 70
56115: PUSH
56116: EMPTY
56117: ST_TO_ADDR
// mc_scan := [ ] ;
56118: LD_ADDR_EXP 81
56122: PUSH
56123: EMPTY
56124: ST_TO_ADDR
// mc_scan_area := [ ] ;
56125: LD_ADDR_EXP 83
56129: PUSH
56130: EMPTY
56131: ST_TO_ADDR
// mc_tech := [ ] ;
56132: LD_ADDR_EXP 85
56136: PUSH
56137: EMPTY
56138: ST_TO_ADDR
// mc_class := [ ] ;
56139: LD_ADDR_EXP 99
56143: PUSH
56144: EMPTY
56145: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56146: LD_ADDR_EXP 100
56150: PUSH
56151: EMPTY
56152: ST_TO_ADDR
// end ;
56153: LD_VAR 0 1
56157: RET
// export function MC_Kill ( base ) ; begin
56158: LD_INT 0
56160: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56161: LD_ADDR_EXP 58
56165: PUSH
56166: LD_EXP 58
56170: PPUSH
56171: LD_VAR 0 1
56175: PPUSH
56176: EMPTY
56177: PPUSH
56178: CALL_OW 1
56182: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56183: LD_ADDR_EXP 59
56187: PUSH
56188: LD_EXP 59
56192: PPUSH
56193: LD_VAR 0 1
56197: PPUSH
56198: EMPTY
56199: PPUSH
56200: CALL_OW 1
56204: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56205: LD_ADDR_EXP 60
56209: PUSH
56210: LD_EXP 60
56214: PPUSH
56215: LD_VAR 0 1
56219: PPUSH
56220: EMPTY
56221: PPUSH
56222: CALL_OW 1
56226: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56227: LD_ADDR_EXP 61
56231: PUSH
56232: LD_EXP 61
56236: PPUSH
56237: LD_VAR 0 1
56241: PPUSH
56242: EMPTY
56243: PPUSH
56244: CALL_OW 1
56248: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56249: LD_ADDR_EXP 62
56253: PUSH
56254: LD_EXP 62
56258: PPUSH
56259: LD_VAR 0 1
56263: PPUSH
56264: EMPTY
56265: PPUSH
56266: CALL_OW 1
56270: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56271: LD_ADDR_EXP 63
56275: PUSH
56276: LD_EXP 63
56280: PPUSH
56281: LD_VAR 0 1
56285: PPUSH
56286: EMPTY
56287: PPUSH
56288: CALL_OW 1
56292: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56293: LD_ADDR_EXP 64
56297: PUSH
56298: LD_EXP 64
56302: PPUSH
56303: LD_VAR 0 1
56307: PPUSH
56308: EMPTY
56309: PPUSH
56310: CALL_OW 1
56314: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56315: LD_ADDR_EXP 65
56319: PUSH
56320: LD_EXP 65
56324: PPUSH
56325: LD_VAR 0 1
56329: PPUSH
56330: EMPTY
56331: PPUSH
56332: CALL_OW 1
56336: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56337: LD_ADDR_EXP 66
56341: PUSH
56342: LD_EXP 66
56346: PPUSH
56347: LD_VAR 0 1
56351: PPUSH
56352: EMPTY
56353: PPUSH
56354: CALL_OW 1
56358: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56359: LD_ADDR_EXP 67
56363: PUSH
56364: LD_EXP 67
56368: PPUSH
56369: LD_VAR 0 1
56373: PPUSH
56374: EMPTY
56375: PPUSH
56376: CALL_OW 1
56380: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56381: LD_ADDR_EXP 68
56385: PUSH
56386: LD_EXP 68
56390: PPUSH
56391: LD_VAR 0 1
56395: PPUSH
56396: EMPTY
56397: PPUSH
56398: CALL_OW 1
56402: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56403: LD_ADDR_EXP 69
56407: PUSH
56408: LD_EXP 69
56412: PPUSH
56413: LD_VAR 0 1
56417: PPUSH
56418: LD_INT 0
56420: PPUSH
56421: CALL_OW 1
56425: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56426: LD_ADDR_EXP 70
56430: PUSH
56431: LD_EXP 70
56435: PPUSH
56436: LD_VAR 0 1
56440: PPUSH
56441: EMPTY
56442: PPUSH
56443: CALL_OW 1
56447: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56448: LD_ADDR_EXP 71
56452: PUSH
56453: LD_EXP 71
56457: PPUSH
56458: LD_VAR 0 1
56462: PPUSH
56463: EMPTY
56464: PPUSH
56465: CALL_OW 1
56469: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56470: LD_ADDR_EXP 72
56474: PUSH
56475: LD_EXP 72
56479: PPUSH
56480: LD_VAR 0 1
56484: PPUSH
56485: EMPTY
56486: PPUSH
56487: CALL_OW 1
56491: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56492: LD_ADDR_EXP 73
56496: PUSH
56497: LD_EXP 73
56501: PPUSH
56502: LD_VAR 0 1
56506: PPUSH
56507: EMPTY
56508: PPUSH
56509: CALL_OW 1
56513: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56514: LD_ADDR_EXP 74
56518: PUSH
56519: LD_EXP 74
56523: PPUSH
56524: LD_VAR 0 1
56528: PPUSH
56529: EMPTY
56530: PPUSH
56531: CALL_OW 1
56535: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56536: LD_ADDR_EXP 75
56540: PUSH
56541: LD_EXP 75
56545: PPUSH
56546: LD_VAR 0 1
56550: PPUSH
56551: EMPTY
56552: PPUSH
56553: CALL_OW 1
56557: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56558: LD_ADDR_EXP 76
56562: PUSH
56563: LD_EXP 76
56567: PPUSH
56568: LD_VAR 0 1
56572: PPUSH
56573: EMPTY
56574: PPUSH
56575: CALL_OW 1
56579: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56580: LD_ADDR_EXP 77
56584: PUSH
56585: LD_EXP 77
56589: PPUSH
56590: LD_VAR 0 1
56594: PPUSH
56595: EMPTY
56596: PPUSH
56597: CALL_OW 1
56601: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56602: LD_ADDR_EXP 78
56606: PUSH
56607: LD_EXP 78
56611: PPUSH
56612: LD_VAR 0 1
56616: PPUSH
56617: EMPTY
56618: PPUSH
56619: CALL_OW 1
56623: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56624: LD_ADDR_EXP 79
56628: PUSH
56629: LD_EXP 79
56633: PPUSH
56634: LD_VAR 0 1
56638: PPUSH
56639: EMPTY
56640: PPUSH
56641: CALL_OW 1
56645: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56646: LD_ADDR_EXP 80
56650: PUSH
56651: LD_EXP 80
56655: PPUSH
56656: LD_VAR 0 1
56660: PPUSH
56661: EMPTY
56662: PPUSH
56663: CALL_OW 1
56667: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56668: LD_ADDR_EXP 81
56672: PUSH
56673: LD_EXP 81
56677: PPUSH
56678: LD_VAR 0 1
56682: PPUSH
56683: EMPTY
56684: PPUSH
56685: CALL_OW 1
56689: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56690: LD_ADDR_EXP 82
56694: PUSH
56695: LD_EXP 82
56699: PPUSH
56700: LD_VAR 0 1
56704: PPUSH
56705: EMPTY
56706: PPUSH
56707: CALL_OW 1
56711: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56712: LD_ADDR_EXP 83
56716: PUSH
56717: LD_EXP 83
56721: PPUSH
56722: LD_VAR 0 1
56726: PPUSH
56727: EMPTY
56728: PPUSH
56729: CALL_OW 1
56733: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56734: LD_ADDR_EXP 85
56738: PUSH
56739: LD_EXP 85
56743: PPUSH
56744: LD_VAR 0 1
56748: PPUSH
56749: EMPTY
56750: PPUSH
56751: CALL_OW 1
56755: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56756: LD_ADDR_EXP 87
56760: PUSH
56761: LD_EXP 87
56765: PPUSH
56766: LD_VAR 0 1
56770: PPUSH
56771: EMPTY
56772: PPUSH
56773: CALL_OW 1
56777: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56778: LD_ADDR_EXP 88
56782: PUSH
56783: LD_EXP 88
56787: PPUSH
56788: LD_VAR 0 1
56792: PPUSH
56793: EMPTY
56794: PPUSH
56795: CALL_OW 1
56799: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56800: LD_ADDR_EXP 89
56804: PUSH
56805: LD_EXP 89
56809: PPUSH
56810: LD_VAR 0 1
56814: PPUSH
56815: EMPTY
56816: PPUSH
56817: CALL_OW 1
56821: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56822: LD_ADDR_EXP 90
56826: PUSH
56827: LD_EXP 90
56831: PPUSH
56832: LD_VAR 0 1
56836: PPUSH
56837: EMPTY
56838: PPUSH
56839: CALL_OW 1
56843: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56844: LD_ADDR_EXP 91
56848: PUSH
56849: LD_EXP 91
56853: PPUSH
56854: LD_VAR 0 1
56858: PPUSH
56859: EMPTY
56860: PPUSH
56861: CALL_OW 1
56865: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56866: LD_ADDR_EXP 92
56870: PUSH
56871: LD_EXP 92
56875: PPUSH
56876: LD_VAR 0 1
56880: PPUSH
56881: EMPTY
56882: PPUSH
56883: CALL_OW 1
56887: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56888: LD_ADDR_EXP 93
56892: PUSH
56893: LD_EXP 93
56897: PPUSH
56898: LD_VAR 0 1
56902: PPUSH
56903: EMPTY
56904: PPUSH
56905: CALL_OW 1
56909: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56910: LD_ADDR_EXP 94
56914: PUSH
56915: LD_EXP 94
56919: PPUSH
56920: LD_VAR 0 1
56924: PPUSH
56925: EMPTY
56926: PPUSH
56927: CALL_OW 1
56931: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56932: LD_ADDR_EXP 95
56936: PUSH
56937: LD_EXP 95
56941: PPUSH
56942: LD_VAR 0 1
56946: PPUSH
56947: EMPTY
56948: PPUSH
56949: CALL_OW 1
56953: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56954: LD_ADDR_EXP 96
56958: PUSH
56959: LD_EXP 96
56963: PPUSH
56964: LD_VAR 0 1
56968: PPUSH
56969: EMPTY
56970: PPUSH
56971: CALL_OW 1
56975: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56976: LD_ADDR_EXP 97
56980: PUSH
56981: LD_EXP 97
56985: PPUSH
56986: LD_VAR 0 1
56990: PPUSH
56991: EMPTY
56992: PPUSH
56993: CALL_OW 1
56997: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56998: LD_ADDR_EXP 98
57002: PUSH
57003: LD_EXP 98
57007: PPUSH
57008: LD_VAR 0 1
57012: PPUSH
57013: EMPTY
57014: PPUSH
57015: CALL_OW 1
57019: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57020: LD_ADDR_EXP 99
57024: PUSH
57025: LD_EXP 99
57029: PPUSH
57030: LD_VAR 0 1
57034: PPUSH
57035: EMPTY
57036: PPUSH
57037: CALL_OW 1
57041: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57042: LD_ADDR_EXP 100
57046: PUSH
57047: LD_EXP 100
57051: PPUSH
57052: LD_VAR 0 1
57056: PPUSH
57057: LD_INT 0
57059: PPUSH
57060: CALL_OW 1
57064: ST_TO_ADDR
// end ;
57065: LD_VAR 0 2
57069: RET
// export function MC_Start ( ) ; var i ; begin
57070: LD_INT 0
57072: PPUSH
57073: PPUSH
// for i = 1 to mc_bases do
57074: LD_ADDR_VAR 0 2
57078: PUSH
57079: DOUBLE
57080: LD_INT 1
57082: DEC
57083: ST_TO_ADDR
57084: LD_EXP 58
57088: PUSH
57089: FOR_TO
57090: IFFALSE 58167
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57092: LD_ADDR_EXP 58
57096: PUSH
57097: LD_EXP 58
57101: PPUSH
57102: LD_VAR 0 2
57106: PPUSH
57107: LD_EXP 58
57111: PUSH
57112: LD_VAR 0 2
57116: ARRAY
57117: PUSH
57118: LD_INT 0
57120: DIFF
57121: PPUSH
57122: CALL_OW 1
57126: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57127: LD_ADDR_EXP 59
57131: PUSH
57132: LD_EXP 59
57136: PPUSH
57137: LD_VAR 0 2
57141: PPUSH
57142: EMPTY
57143: PPUSH
57144: CALL_OW 1
57148: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57149: LD_ADDR_EXP 60
57153: PUSH
57154: LD_EXP 60
57158: PPUSH
57159: LD_VAR 0 2
57163: PPUSH
57164: EMPTY
57165: PPUSH
57166: CALL_OW 1
57170: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57171: LD_ADDR_EXP 61
57175: PUSH
57176: LD_EXP 61
57180: PPUSH
57181: LD_VAR 0 2
57185: PPUSH
57186: EMPTY
57187: PPUSH
57188: CALL_OW 1
57192: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57193: LD_ADDR_EXP 62
57197: PUSH
57198: LD_EXP 62
57202: PPUSH
57203: LD_VAR 0 2
57207: PPUSH
57208: EMPTY
57209: PUSH
57210: EMPTY
57211: PUSH
57212: EMPTY
57213: LIST
57214: LIST
57215: PPUSH
57216: CALL_OW 1
57220: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57221: LD_ADDR_EXP 63
57225: PUSH
57226: LD_EXP 63
57230: PPUSH
57231: LD_VAR 0 2
57235: PPUSH
57236: EMPTY
57237: PPUSH
57238: CALL_OW 1
57242: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57243: LD_ADDR_EXP 90
57247: PUSH
57248: LD_EXP 90
57252: PPUSH
57253: LD_VAR 0 2
57257: PPUSH
57258: EMPTY
57259: PPUSH
57260: CALL_OW 1
57264: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57265: LD_ADDR_EXP 64
57269: PUSH
57270: LD_EXP 64
57274: PPUSH
57275: LD_VAR 0 2
57279: PPUSH
57280: EMPTY
57281: PPUSH
57282: CALL_OW 1
57286: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57287: LD_ADDR_EXP 65
57291: PUSH
57292: LD_EXP 65
57296: PPUSH
57297: LD_VAR 0 2
57301: PPUSH
57302: EMPTY
57303: PPUSH
57304: CALL_OW 1
57308: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57309: LD_ADDR_EXP 66
57313: PUSH
57314: LD_EXP 66
57318: PPUSH
57319: LD_VAR 0 2
57323: PPUSH
57324: LD_EXP 58
57328: PUSH
57329: LD_VAR 0 2
57333: ARRAY
57334: PPUSH
57335: LD_INT 2
57337: PUSH
57338: LD_INT 30
57340: PUSH
57341: LD_INT 32
57343: PUSH
57344: EMPTY
57345: LIST
57346: LIST
57347: PUSH
57348: LD_INT 30
57350: PUSH
57351: LD_INT 33
57353: PUSH
57354: EMPTY
57355: LIST
57356: LIST
57357: PUSH
57358: EMPTY
57359: LIST
57360: LIST
57361: LIST
57362: PPUSH
57363: CALL_OW 72
57367: PPUSH
57368: CALL_OW 1
57372: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57373: LD_ADDR_EXP 67
57377: PUSH
57378: LD_EXP 67
57382: PPUSH
57383: LD_VAR 0 2
57387: PPUSH
57388: LD_EXP 58
57392: PUSH
57393: LD_VAR 0 2
57397: ARRAY
57398: PPUSH
57399: LD_INT 2
57401: PUSH
57402: LD_INT 30
57404: PUSH
57405: LD_INT 32
57407: PUSH
57408: EMPTY
57409: LIST
57410: LIST
57411: PUSH
57412: LD_INT 30
57414: PUSH
57415: LD_INT 31
57417: PUSH
57418: EMPTY
57419: LIST
57420: LIST
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: LIST
57426: PUSH
57427: LD_INT 58
57429: PUSH
57430: EMPTY
57431: LIST
57432: PUSH
57433: EMPTY
57434: LIST
57435: LIST
57436: PPUSH
57437: CALL_OW 72
57441: PPUSH
57442: CALL_OW 1
57446: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57447: LD_ADDR_EXP 68
57451: PUSH
57452: LD_EXP 68
57456: PPUSH
57457: LD_VAR 0 2
57461: PPUSH
57462: EMPTY
57463: PPUSH
57464: CALL_OW 1
57468: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57469: LD_ADDR_EXP 72
57473: PUSH
57474: LD_EXP 72
57478: PPUSH
57479: LD_VAR 0 2
57483: PPUSH
57484: EMPTY
57485: PPUSH
57486: CALL_OW 1
57490: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57491: LD_ADDR_EXP 71
57495: PUSH
57496: LD_EXP 71
57500: PPUSH
57501: LD_VAR 0 2
57505: PPUSH
57506: EMPTY
57507: PPUSH
57508: CALL_OW 1
57512: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57513: LD_ADDR_EXP 73
57517: PUSH
57518: LD_EXP 73
57522: PPUSH
57523: LD_VAR 0 2
57527: PPUSH
57528: EMPTY
57529: PPUSH
57530: CALL_OW 1
57534: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57535: LD_ADDR_EXP 74
57539: PUSH
57540: LD_EXP 74
57544: PPUSH
57545: LD_VAR 0 2
57549: PPUSH
57550: EMPTY
57551: PPUSH
57552: CALL_OW 1
57556: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57557: LD_ADDR_EXP 75
57561: PUSH
57562: LD_EXP 75
57566: PPUSH
57567: LD_VAR 0 2
57571: PPUSH
57572: EMPTY
57573: PPUSH
57574: CALL_OW 1
57578: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57579: LD_ADDR_EXP 76
57583: PUSH
57584: LD_EXP 76
57588: PPUSH
57589: LD_VAR 0 2
57593: PPUSH
57594: EMPTY
57595: PPUSH
57596: CALL_OW 1
57600: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57601: LD_ADDR_EXP 77
57605: PUSH
57606: LD_EXP 77
57610: PPUSH
57611: LD_VAR 0 2
57615: PPUSH
57616: EMPTY
57617: PPUSH
57618: CALL_OW 1
57622: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57623: LD_ADDR_EXP 78
57627: PUSH
57628: LD_EXP 78
57632: PPUSH
57633: LD_VAR 0 2
57637: PPUSH
57638: EMPTY
57639: PPUSH
57640: CALL_OW 1
57644: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57645: LD_ADDR_EXP 79
57649: PUSH
57650: LD_EXP 79
57654: PPUSH
57655: LD_VAR 0 2
57659: PPUSH
57660: EMPTY
57661: PPUSH
57662: CALL_OW 1
57666: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57667: LD_ADDR_EXP 80
57671: PUSH
57672: LD_EXP 80
57676: PPUSH
57677: LD_VAR 0 2
57681: PPUSH
57682: EMPTY
57683: PPUSH
57684: CALL_OW 1
57688: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57689: LD_ADDR_EXP 69
57693: PUSH
57694: LD_EXP 69
57698: PPUSH
57699: LD_VAR 0 2
57703: PPUSH
57704: LD_INT 0
57706: PPUSH
57707: CALL_OW 1
57711: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57712: LD_ADDR_EXP 82
57716: PUSH
57717: LD_EXP 82
57721: PPUSH
57722: LD_VAR 0 2
57726: PPUSH
57727: LD_INT 0
57729: PPUSH
57730: CALL_OW 1
57734: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57735: LD_ADDR_EXP 70
57739: PUSH
57740: LD_EXP 70
57744: PPUSH
57745: LD_VAR 0 2
57749: PPUSH
57750: EMPTY
57751: PPUSH
57752: CALL_OW 1
57756: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57757: LD_ADDR_EXP 81
57761: PUSH
57762: LD_EXP 81
57766: PPUSH
57767: LD_VAR 0 2
57771: PPUSH
57772: LD_INT 0
57774: PPUSH
57775: CALL_OW 1
57779: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57780: LD_ADDR_EXP 83
57784: PUSH
57785: LD_EXP 83
57789: PPUSH
57790: LD_VAR 0 2
57794: PPUSH
57795: EMPTY
57796: PPUSH
57797: CALL_OW 1
57801: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57802: LD_ADDR_EXP 86
57806: PUSH
57807: LD_EXP 86
57811: PPUSH
57812: LD_VAR 0 2
57816: PPUSH
57817: LD_INT 0
57819: PPUSH
57820: CALL_OW 1
57824: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57825: LD_ADDR_EXP 87
57829: PUSH
57830: LD_EXP 87
57834: PPUSH
57835: LD_VAR 0 2
57839: PPUSH
57840: EMPTY
57841: PPUSH
57842: CALL_OW 1
57846: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57847: LD_ADDR_EXP 88
57851: PUSH
57852: LD_EXP 88
57856: PPUSH
57857: LD_VAR 0 2
57861: PPUSH
57862: EMPTY
57863: PPUSH
57864: CALL_OW 1
57868: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57869: LD_ADDR_EXP 89
57873: PUSH
57874: LD_EXP 89
57878: PPUSH
57879: LD_VAR 0 2
57883: PPUSH
57884: EMPTY
57885: PPUSH
57886: CALL_OW 1
57890: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57891: LD_ADDR_EXP 91
57895: PUSH
57896: LD_EXP 91
57900: PPUSH
57901: LD_VAR 0 2
57905: PPUSH
57906: LD_EXP 58
57910: PUSH
57911: LD_VAR 0 2
57915: ARRAY
57916: PPUSH
57917: LD_INT 2
57919: PUSH
57920: LD_INT 30
57922: PUSH
57923: LD_INT 6
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: PUSH
57930: LD_INT 30
57932: PUSH
57933: LD_INT 7
57935: PUSH
57936: EMPTY
57937: LIST
57938: LIST
57939: PUSH
57940: LD_INT 30
57942: PUSH
57943: LD_INT 8
57945: PUSH
57946: EMPTY
57947: LIST
57948: LIST
57949: PUSH
57950: EMPTY
57951: LIST
57952: LIST
57953: LIST
57954: LIST
57955: PPUSH
57956: CALL_OW 72
57960: PPUSH
57961: CALL_OW 1
57965: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57966: LD_ADDR_EXP 92
57970: PUSH
57971: LD_EXP 92
57975: PPUSH
57976: LD_VAR 0 2
57980: PPUSH
57981: EMPTY
57982: PPUSH
57983: CALL_OW 1
57987: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57988: LD_ADDR_EXP 93
57992: PUSH
57993: LD_EXP 93
57997: PPUSH
57998: LD_VAR 0 2
58002: PPUSH
58003: EMPTY
58004: PPUSH
58005: CALL_OW 1
58009: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58010: LD_ADDR_EXP 94
58014: PUSH
58015: LD_EXP 94
58019: PPUSH
58020: LD_VAR 0 2
58024: PPUSH
58025: EMPTY
58026: PPUSH
58027: CALL_OW 1
58031: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58032: LD_ADDR_EXP 95
58036: PUSH
58037: LD_EXP 95
58041: PPUSH
58042: LD_VAR 0 2
58046: PPUSH
58047: EMPTY
58048: PPUSH
58049: CALL_OW 1
58053: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58054: LD_ADDR_EXP 96
58058: PUSH
58059: LD_EXP 96
58063: PPUSH
58064: LD_VAR 0 2
58068: PPUSH
58069: EMPTY
58070: PPUSH
58071: CALL_OW 1
58075: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58076: LD_ADDR_EXP 97
58080: PUSH
58081: LD_EXP 97
58085: PPUSH
58086: LD_VAR 0 2
58090: PPUSH
58091: EMPTY
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58098: LD_ADDR_EXP 98
58102: PUSH
58103: LD_EXP 98
58107: PPUSH
58108: LD_VAR 0 2
58112: PPUSH
58113: EMPTY
58114: PPUSH
58115: CALL_OW 1
58119: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58120: LD_ADDR_EXP 99
58124: PUSH
58125: LD_EXP 99
58129: PPUSH
58130: LD_VAR 0 2
58134: PPUSH
58135: EMPTY
58136: PPUSH
58137: CALL_OW 1
58141: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58142: LD_ADDR_EXP 100
58146: PUSH
58147: LD_EXP 100
58151: PPUSH
58152: LD_VAR 0 2
58156: PPUSH
58157: LD_INT 0
58159: PPUSH
58160: CALL_OW 1
58164: ST_TO_ADDR
// end ;
58165: GO 57089
58167: POP
58168: POP
// MC_InitSides ( ) ;
58169: CALL 58455 0 0
// MC_InitResearch ( ) ;
58173: CALL 58194 0 0
// CustomInitMacro ( ) ;
58177: CALL 174 0 0
// skirmish := true ;
58181: LD_ADDR_EXP 56
58185: PUSH
58186: LD_INT 1
58188: ST_TO_ADDR
// end ;
58189: LD_VAR 0 1
58193: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58194: LD_INT 0
58196: PPUSH
58197: PPUSH
58198: PPUSH
58199: PPUSH
58200: PPUSH
58201: PPUSH
// if not mc_bases then
58202: LD_EXP 58
58206: NOT
58207: IFFALSE 58211
// exit ;
58209: GO 58450
// for i = 1 to 8 do
58211: LD_ADDR_VAR 0 2
58215: PUSH
58216: DOUBLE
58217: LD_INT 1
58219: DEC
58220: ST_TO_ADDR
58221: LD_INT 8
58223: PUSH
58224: FOR_TO
58225: IFFALSE 58251
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58227: LD_ADDR_EXP 85
58231: PUSH
58232: LD_EXP 85
58236: PPUSH
58237: LD_VAR 0 2
58241: PPUSH
58242: EMPTY
58243: PPUSH
58244: CALL_OW 1
58248: ST_TO_ADDR
58249: GO 58224
58251: POP
58252: POP
// tmp := [ ] ;
58253: LD_ADDR_VAR 0 5
58257: PUSH
58258: EMPTY
58259: ST_TO_ADDR
// for i = 1 to mc_sides do
58260: LD_ADDR_VAR 0 2
58264: PUSH
58265: DOUBLE
58266: LD_INT 1
58268: DEC
58269: ST_TO_ADDR
58270: LD_EXP 84
58274: PUSH
58275: FOR_TO
58276: IFFALSE 58334
// if not mc_sides [ i ] in tmp then
58278: LD_EXP 84
58282: PUSH
58283: LD_VAR 0 2
58287: ARRAY
58288: PUSH
58289: LD_VAR 0 5
58293: IN
58294: NOT
58295: IFFALSE 58332
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58297: LD_ADDR_VAR 0 5
58301: PUSH
58302: LD_VAR 0 5
58306: PPUSH
58307: LD_VAR 0 5
58311: PUSH
58312: LD_INT 1
58314: PLUS
58315: PPUSH
58316: LD_EXP 84
58320: PUSH
58321: LD_VAR 0 2
58325: ARRAY
58326: PPUSH
58327: CALL_OW 2
58331: ST_TO_ADDR
58332: GO 58275
58334: POP
58335: POP
// if not tmp then
58336: LD_VAR 0 5
58340: NOT
58341: IFFALSE 58345
// exit ;
58343: GO 58450
// for j in tmp do
58345: LD_ADDR_VAR 0 3
58349: PUSH
58350: LD_VAR 0 5
58354: PUSH
58355: FOR_IN
58356: IFFALSE 58448
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58358: LD_ADDR_VAR 0 6
58362: PUSH
58363: LD_INT 22
58365: PUSH
58366: LD_VAR 0 3
58370: PUSH
58371: EMPTY
58372: LIST
58373: LIST
58374: PPUSH
58375: CALL_OW 69
58379: ST_TO_ADDR
// if not un then
58380: LD_VAR 0 6
58384: NOT
58385: IFFALSE 58389
// continue ;
58387: GO 58355
// nation := GetNation ( un [ 1 ] ) ;
58389: LD_ADDR_VAR 0 4
58393: PUSH
58394: LD_VAR 0 6
58398: PUSH
58399: LD_INT 1
58401: ARRAY
58402: PPUSH
58403: CALL_OW 248
58407: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58408: LD_ADDR_EXP 85
58412: PUSH
58413: LD_EXP 85
58417: PPUSH
58418: LD_VAR 0 3
58422: PPUSH
58423: LD_VAR 0 3
58427: PPUSH
58428: LD_VAR 0 4
58432: PPUSH
58433: LD_INT 1
58435: PPUSH
58436: CALL 13578 0 3
58440: PPUSH
58441: CALL_OW 1
58445: ST_TO_ADDR
// end ;
58446: GO 58355
58448: POP
58449: POP
// end ;
58450: LD_VAR 0 1
58454: RET
// export function MC_InitSides ( ) ; var i ; begin
58455: LD_INT 0
58457: PPUSH
58458: PPUSH
// if not mc_bases then
58459: LD_EXP 58
58463: NOT
58464: IFFALSE 58468
// exit ;
58466: GO 58542
// for i = 1 to mc_bases do
58468: LD_ADDR_VAR 0 2
58472: PUSH
58473: DOUBLE
58474: LD_INT 1
58476: DEC
58477: ST_TO_ADDR
58478: LD_EXP 58
58482: PUSH
58483: FOR_TO
58484: IFFALSE 58540
// if mc_bases [ i ] then
58486: LD_EXP 58
58490: PUSH
58491: LD_VAR 0 2
58495: ARRAY
58496: IFFALSE 58538
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58498: LD_ADDR_EXP 84
58502: PUSH
58503: LD_EXP 84
58507: PPUSH
58508: LD_VAR 0 2
58512: PPUSH
58513: LD_EXP 58
58517: PUSH
58518: LD_VAR 0 2
58522: ARRAY
58523: PUSH
58524: LD_INT 1
58526: ARRAY
58527: PPUSH
58528: CALL_OW 255
58532: PPUSH
58533: CALL_OW 1
58537: ST_TO_ADDR
58538: GO 58483
58540: POP
58541: POP
// end ;
58542: LD_VAR 0 1
58546: RET
// every 0 0$01 trigger skirmish do
58547: LD_EXP 56
58551: IFFALSE 58705
58553: GO 58555
58555: DISABLE
// begin enable ;
58556: ENABLE
// MC_CheckBuildings ( ) ;
58557: CALL 62871 0 0
// MC_CheckPeopleLife ( ) ;
58561: CALL 62996 0 0
// RaiseSailEvent ( 100 ) ;
58565: LD_INT 100
58567: PPUSH
58568: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58572: LD_INT 103
58574: PPUSH
58575: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58579: LD_INT 104
58581: PPUSH
58582: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58586: LD_INT 105
58588: PPUSH
58589: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58593: LD_INT 106
58595: PPUSH
58596: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58600: LD_INT 107
58602: PPUSH
58603: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58607: LD_INT 108
58609: PPUSH
58610: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58614: LD_INT 109
58616: PPUSH
58617: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58621: LD_INT 110
58623: PPUSH
58624: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58628: LD_INT 111
58630: PPUSH
58631: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58635: LD_INT 112
58637: PPUSH
58638: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58642: LD_INT 113
58644: PPUSH
58645: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58649: LD_INT 120
58651: PPUSH
58652: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58656: LD_INT 121
58658: PPUSH
58659: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58663: LD_INT 122
58665: PPUSH
58666: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58670: LD_INT 123
58672: PPUSH
58673: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58677: LD_INT 124
58679: PPUSH
58680: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58684: LD_INT 125
58686: PPUSH
58687: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58691: LD_INT 126
58693: PPUSH
58694: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58698: LD_INT 200
58700: PPUSH
58701: CALL_OW 427
// end ;
58705: END
// on SailEvent ( event ) do begin if event < 100 then
58706: LD_VAR 0 1
58710: PUSH
58711: LD_INT 100
58713: LESS
58714: IFFALSE 58725
// CustomEvent ( event ) ;
58716: LD_VAR 0 1
58720: PPUSH
58721: CALL 12292 0 1
// if event = 100 then
58725: LD_VAR 0 1
58729: PUSH
58730: LD_INT 100
58732: EQUAL
58733: IFFALSE 58739
// MC_ClassManager ( ) ;
58735: CALL 59131 0 0
// if event = 101 then
58739: LD_VAR 0 1
58743: PUSH
58744: LD_INT 101
58746: EQUAL
58747: IFFALSE 58753
// MC_RepairBuildings ( ) ;
58749: CALL 63592 0 0
// if event = 102 then
58753: LD_VAR 0 1
58757: PUSH
58758: LD_INT 102
58760: EQUAL
58761: IFFALSE 58767
// MC_Heal ( ) ;
58763: CALL 63998 0 0
// if event = 103 then
58767: LD_VAR 0 1
58771: PUSH
58772: LD_INT 103
58774: EQUAL
58775: IFFALSE 58781
// MC_Build ( ) ;
58777: CALL 64420 0 0
// if event = 104 then
58781: LD_VAR 0 1
58785: PUSH
58786: LD_INT 104
58788: EQUAL
58789: IFFALSE 58795
// MC_TurretWeapon ( ) ;
58791: CALL 66033 0 0
// if event = 105 then
58795: LD_VAR 0 1
58799: PUSH
58800: LD_INT 105
58802: EQUAL
58803: IFFALSE 58809
// MC_BuildUpgrade ( ) ;
58805: CALL 65584 0 0
// if event = 106 then
58809: LD_VAR 0 1
58813: PUSH
58814: LD_INT 106
58816: EQUAL
58817: IFFALSE 58823
// MC_PlantMines ( ) ;
58819: CALL 66463 0 0
// if event = 107 then
58823: LD_VAR 0 1
58827: PUSH
58828: LD_INT 107
58830: EQUAL
58831: IFFALSE 58837
// MC_CollectCrates ( ) ;
58833: CALL 67497 0 0
// if event = 108 then
58837: LD_VAR 0 1
58841: PUSH
58842: LD_INT 108
58844: EQUAL
58845: IFFALSE 58851
// MC_LinkRemoteControl ( ) ;
58847: CALL 69254 0 0
// if event = 109 then
58851: LD_VAR 0 1
58855: PUSH
58856: LD_INT 109
58858: EQUAL
58859: IFFALSE 58865
// MC_ProduceVehicle ( ) ;
58861: CALL 69435 0 0
// if event = 110 then
58865: LD_VAR 0 1
58869: PUSH
58870: LD_INT 110
58872: EQUAL
58873: IFFALSE 58879
// MC_SendAttack ( ) ;
58875: CALL 69916 0 0
// if event = 111 then
58879: LD_VAR 0 1
58883: PUSH
58884: LD_INT 111
58886: EQUAL
58887: IFFALSE 58893
// MC_Defend ( ) ;
58889: CALL 70024 0 0
// if event = 112 then
58893: LD_VAR 0 1
58897: PUSH
58898: LD_INT 112
58900: EQUAL
58901: IFFALSE 58907
// MC_Research ( ) ;
58903: CALL 70651 0 0
// if event = 113 then
58907: LD_VAR 0 1
58911: PUSH
58912: LD_INT 113
58914: EQUAL
58915: IFFALSE 58921
// MC_MinesTrigger ( ) ;
58917: CALL 71765 0 0
// if event = 120 then
58921: LD_VAR 0 1
58925: PUSH
58926: LD_INT 120
58928: EQUAL
58929: IFFALSE 58935
// MC_RepairVehicle ( ) ;
58931: CALL 71864 0 0
// if event = 121 then
58935: LD_VAR 0 1
58939: PUSH
58940: LD_INT 121
58942: EQUAL
58943: IFFALSE 58949
// MC_TameApe ( ) ;
58945: CALL 72607 0 0
// if event = 122 then
58949: LD_VAR 0 1
58953: PUSH
58954: LD_INT 122
58956: EQUAL
58957: IFFALSE 58963
// MC_ChangeApeClass ( ) ;
58959: CALL 73436 0 0
// if event = 123 then
58963: LD_VAR 0 1
58967: PUSH
58968: LD_INT 123
58970: EQUAL
58971: IFFALSE 58977
// MC_Bazooka ( ) ;
58973: CALL 74086 0 0
// if event = 124 then
58977: LD_VAR 0 1
58981: PUSH
58982: LD_INT 124
58984: EQUAL
58985: IFFALSE 58991
// MC_TeleportExit ( ) ;
58987: CALL 74284 0 0
// if event = 125 then
58991: LD_VAR 0 1
58995: PUSH
58996: LD_INT 125
58998: EQUAL
58999: IFFALSE 59005
// MC_Deposits ( ) ;
59001: CALL 74931 0 0
// if event = 126 then
59005: LD_VAR 0 1
59009: PUSH
59010: LD_INT 126
59012: EQUAL
59013: IFFALSE 59019
// MC_RemoteDriver ( ) ;
59015: CALL 75556 0 0
// if event = 200 then
59019: LD_VAR 0 1
59023: PUSH
59024: LD_INT 200
59026: EQUAL
59027: IFFALSE 59033
// MC_Idle ( ) ;
59029: CALL 77289 0 0
// end ;
59033: PPOPN 1
59035: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59036: LD_INT 0
59038: PPUSH
59039: PPUSH
// if not mc_bases [ base ] or not tag then
59040: LD_EXP 58
59044: PUSH
59045: LD_VAR 0 1
59049: ARRAY
59050: NOT
59051: PUSH
59052: LD_VAR 0 2
59056: NOT
59057: OR
59058: IFFALSE 59062
// exit ;
59060: GO 59126
// for i in mc_bases [ base ] union mc_ape [ base ] do
59062: LD_ADDR_VAR 0 4
59066: PUSH
59067: LD_EXP 58
59071: PUSH
59072: LD_VAR 0 1
59076: ARRAY
59077: PUSH
59078: LD_EXP 87
59082: PUSH
59083: LD_VAR 0 1
59087: ARRAY
59088: UNION
59089: PUSH
59090: FOR_IN
59091: IFFALSE 59124
// if GetTag ( i ) = tag then
59093: LD_VAR 0 4
59097: PPUSH
59098: CALL_OW 110
59102: PUSH
59103: LD_VAR 0 2
59107: EQUAL
59108: IFFALSE 59122
// SetTag ( i , 0 ) ;
59110: LD_VAR 0 4
59114: PPUSH
59115: LD_INT 0
59117: PPUSH
59118: CALL_OW 109
59122: GO 59090
59124: POP
59125: POP
// end ;
59126: LD_VAR 0 3
59130: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59131: LD_INT 0
59133: PPUSH
59134: PPUSH
59135: PPUSH
59136: PPUSH
59137: PPUSH
59138: PPUSH
59139: PPUSH
59140: PPUSH
// if not mc_bases then
59141: LD_EXP 58
59145: NOT
59146: IFFALSE 59150
// exit ;
59148: GO 59608
// for i = 1 to mc_bases do
59150: LD_ADDR_VAR 0 2
59154: PUSH
59155: DOUBLE
59156: LD_INT 1
59158: DEC
59159: ST_TO_ADDR
59160: LD_EXP 58
59164: PUSH
59165: FOR_TO
59166: IFFALSE 59606
// begin tmp := MC_ClassCheckReq ( i ) ;
59168: LD_ADDR_VAR 0 4
59172: PUSH
59173: LD_VAR 0 2
59177: PPUSH
59178: CALL 59613 0 1
59182: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59183: LD_ADDR_EXP 99
59187: PUSH
59188: LD_EXP 99
59192: PPUSH
59193: LD_VAR 0 2
59197: PPUSH
59198: LD_VAR 0 4
59202: PPUSH
59203: CALL_OW 1
59207: ST_TO_ADDR
// if not tmp then
59208: LD_VAR 0 4
59212: NOT
59213: IFFALSE 59217
// continue ;
59215: GO 59165
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59217: LD_ADDR_VAR 0 6
59221: PUSH
59222: LD_EXP 58
59226: PUSH
59227: LD_VAR 0 2
59231: ARRAY
59232: PPUSH
59233: LD_INT 2
59235: PUSH
59236: LD_INT 30
59238: PUSH
59239: LD_INT 4
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PUSH
59246: LD_INT 30
59248: PUSH
59249: LD_INT 5
59251: PUSH
59252: EMPTY
59253: LIST
59254: LIST
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: LIST
59260: PPUSH
59261: CALL_OW 72
59265: PUSH
59266: LD_EXP 58
59270: PUSH
59271: LD_VAR 0 2
59275: ARRAY
59276: PPUSH
59277: LD_INT 2
59279: PUSH
59280: LD_INT 30
59282: PUSH
59283: LD_INT 0
59285: PUSH
59286: EMPTY
59287: LIST
59288: LIST
59289: PUSH
59290: LD_INT 30
59292: PUSH
59293: LD_INT 1
59295: PUSH
59296: EMPTY
59297: LIST
59298: LIST
59299: PUSH
59300: EMPTY
59301: LIST
59302: LIST
59303: LIST
59304: PPUSH
59305: CALL_OW 72
59309: PUSH
59310: LD_EXP 58
59314: PUSH
59315: LD_VAR 0 2
59319: ARRAY
59320: PPUSH
59321: LD_INT 30
59323: PUSH
59324: LD_INT 3
59326: PUSH
59327: EMPTY
59328: LIST
59329: LIST
59330: PPUSH
59331: CALL_OW 72
59335: PUSH
59336: LD_EXP 58
59340: PUSH
59341: LD_VAR 0 2
59345: ARRAY
59346: PPUSH
59347: LD_INT 2
59349: PUSH
59350: LD_INT 30
59352: PUSH
59353: LD_INT 6
59355: PUSH
59356: EMPTY
59357: LIST
59358: LIST
59359: PUSH
59360: LD_INT 30
59362: PUSH
59363: LD_INT 7
59365: PUSH
59366: EMPTY
59367: LIST
59368: LIST
59369: PUSH
59370: LD_INT 30
59372: PUSH
59373: LD_INT 8
59375: PUSH
59376: EMPTY
59377: LIST
59378: LIST
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: LIST
59384: LIST
59385: PPUSH
59386: CALL_OW 72
59390: PUSH
59391: EMPTY
59392: LIST
59393: LIST
59394: LIST
59395: LIST
59396: ST_TO_ADDR
// for j = 1 to 4 do
59397: LD_ADDR_VAR 0 3
59401: PUSH
59402: DOUBLE
59403: LD_INT 1
59405: DEC
59406: ST_TO_ADDR
59407: LD_INT 4
59409: PUSH
59410: FOR_TO
59411: IFFALSE 59602
// begin if not tmp [ j ] then
59413: LD_VAR 0 4
59417: PUSH
59418: LD_VAR 0 3
59422: ARRAY
59423: NOT
59424: IFFALSE 59428
// continue ;
59426: GO 59410
// for p in tmp [ j ] do
59428: LD_ADDR_VAR 0 5
59432: PUSH
59433: LD_VAR 0 4
59437: PUSH
59438: LD_VAR 0 3
59442: ARRAY
59443: PUSH
59444: FOR_IN
59445: IFFALSE 59598
// begin if not b [ j ] then
59447: LD_VAR 0 6
59451: PUSH
59452: LD_VAR 0 3
59456: ARRAY
59457: NOT
59458: IFFALSE 59462
// break ;
59460: GO 59598
// e := 0 ;
59462: LD_ADDR_VAR 0 7
59466: PUSH
59467: LD_INT 0
59469: ST_TO_ADDR
// for k in b [ j ] do
59470: LD_ADDR_VAR 0 8
59474: PUSH
59475: LD_VAR 0 6
59479: PUSH
59480: LD_VAR 0 3
59484: ARRAY
59485: PUSH
59486: FOR_IN
59487: IFFALSE 59514
// if IsNotFull ( k ) then
59489: LD_VAR 0 8
59493: PPUSH
59494: CALL 17604 0 1
59498: IFFALSE 59512
// begin e := k ;
59500: LD_ADDR_VAR 0 7
59504: PUSH
59505: LD_VAR 0 8
59509: ST_TO_ADDR
// break ;
59510: GO 59514
// end ;
59512: GO 59486
59514: POP
59515: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59516: LD_VAR 0 7
59520: PUSH
59521: LD_VAR 0 5
59525: PPUSH
59526: LD_VAR 0 7
59530: PPUSH
59531: CALL 54592 0 2
59535: NOT
59536: AND
59537: IFFALSE 59596
// begin if IsInUnit ( p ) then
59539: LD_VAR 0 5
59543: PPUSH
59544: CALL_OW 310
59548: IFFALSE 59559
// ComExitBuilding ( p ) ;
59550: LD_VAR 0 5
59554: PPUSH
59555: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59559: LD_VAR 0 5
59563: PPUSH
59564: LD_VAR 0 7
59568: PPUSH
59569: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59573: LD_VAR 0 5
59577: PPUSH
59578: LD_VAR 0 3
59582: PPUSH
59583: CALL_OW 183
// AddComExitBuilding ( p ) ;
59587: LD_VAR 0 5
59591: PPUSH
59592: CALL_OW 182
// end ; end ;
59596: GO 59444
59598: POP
59599: POP
// end ;
59600: GO 59410
59602: POP
59603: POP
// end ;
59604: GO 59165
59606: POP
59607: POP
// end ;
59608: LD_VAR 0 1
59612: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59613: LD_INT 0
59615: PPUSH
59616: PPUSH
59617: PPUSH
59618: PPUSH
59619: PPUSH
59620: PPUSH
59621: PPUSH
59622: PPUSH
59623: PPUSH
59624: PPUSH
59625: PPUSH
59626: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59627: LD_VAR 0 1
59631: NOT
59632: PUSH
59633: LD_EXP 58
59637: PUSH
59638: LD_VAR 0 1
59642: ARRAY
59643: NOT
59644: OR
59645: PUSH
59646: LD_EXP 58
59650: PUSH
59651: LD_VAR 0 1
59655: ARRAY
59656: PPUSH
59657: LD_INT 2
59659: PUSH
59660: LD_INT 30
59662: PUSH
59663: LD_INT 0
59665: PUSH
59666: EMPTY
59667: LIST
59668: LIST
59669: PUSH
59670: LD_INT 30
59672: PUSH
59673: LD_INT 1
59675: PUSH
59676: EMPTY
59677: LIST
59678: LIST
59679: PUSH
59680: EMPTY
59681: LIST
59682: LIST
59683: LIST
59684: PPUSH
59685: CALL_OW 72
59689: NOT
59690: OR
59691: IFFALSE 59695
// exit ;
59693: GO 62866
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59695: LD_ADDR_VAR 0 4
59699: PUSH
59700: LD_EXP 58
59704: PUSH
59705: LD_VAR 0 1
59709: ARRAY
59710: PPUSH
59711: LD_INT 2
59713: PUSH
59714: LD_INT 25
59716: PUSH
59717: LD_INT 1
59719: PUSH
59720: EMPTY
59721: LIST
59722: LIST
59723: PUSH
59724: LD_INT 25
59726: PUSH
59727: LD_INT 2
59729: PUSH
59730: EMPTY
59731: LIST
59732: LIST
59733: PUSH
59734: LD_INT 25
59736: PUSH
59737: LD_INT 3
59739: PUSH
59740: EMPTY
59741: LIST
59742: LIST
59743: PUSH
59744: LD_INT 25
59746: PUSH
59747: LD_INT 4
59749: PUSH
59750: EMPTY
59751: LIST
59752: LIST
59753: PUSH
59754: LD_INT 25
59756: PUSH
59757: LD_INT 5
59759: PUSH
59760: EMPTY
59761: LIST
59762: LIST
59763: PUSH
59764: LD_INT 25
59766: PUSH
59767: LD_INT 8
59769: PUSH
59770: EMPTY
59771: LIST
59772: LIST
59773: PUSH
59774: LD_INT 25
59776: PUSH
59777: LD_INT 9
59779: PUSH
59780: EMPTY
59781: LIST
59782: LIST
59783: PUSH
59784: EMPTY
59785: LIST
59786: LIST
59787: LIST
59788: LIST
59789: LIST
59790: LIST
59791: LIST
59792: LIST
59793: PPUSH
59794: CALL_OW 72
59798: ST_TO_ADDR
// for i in tmp do
59799: LD_ADDR_VAR 0 3
59803: PUSH
59804: LD_VAR 0 4
59808: PUSH
59809: FOR_IN
59810: IFFALSE 59841
// if GetTag ( i ) then
59812: LD_VAR 0 3
59816: PPUSH
59817: CALL_OW 110
59821: IFFALSE 59839
// tmp := tmp diff i ;
59823: LD_ADDR_VAR 0 4
59827: PUSH
59828: LD_VAR 0 4
59832: PUSH
59833: LD_VAR 0 3
59837: DIFF
59838: ST_TO_ADDR
59839: GO 59809
59841: POP
59842: POP
// if not tmp then
59843: LD_VAR 0 4
59847: NOT
59848: IFFALSE 59852
// exit ;
59850: GO 62866
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59852: LD_ADDR_VAR 0 5
59856: PUSH
59857: LD_EXP 58
59861: PUSH
59862: LD_VAR 0 1
59866: ARRAY
59867: PPUSH
59868: LD_INT 2
59870: PUSH
59871: LD_INT 25
59873: PUSH
59874: LD_INT 1
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: PUSH
59881: LD_INT 25
59883: PUSH
59884: LD_INT 5
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: PUSH
59891: LD_INT 25
59893: PUSH
59894: LD_INT 8
59896: PUSH
59897: EMPTY
59898: LIST
59899: LIST
59900: PUSH
59901: LD_INT 25
59903: PUSH
59904: LD_INT 9
59906: PUSH
59907: EMPTY
59908: LIST
59909: LIST
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: LIST
59915: LIST
59916: LIST
59917: PPUSH
59918: CALL_OW 72
59922: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59923: LD_ADDR_VAR 0 6
59927: PUSH
59928: LD_EXP 58
59932: PUSH
59933: LD_VAR 0 1
59937: ARRAY
59938: PPUSH
59939: LD_INT 25
59941: PUSH
59942: LD_INT 2
59944: PUSH
59945: EMPTY
59946: LIST
59947: LIST
59948: PPUSH
59949: CALL_OW 72
59953: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59954: LD_ADDR_VAR 0 7
59958: PUSH
59959: LD_EXP 58
59963: PUSH
59964: LD_VAR 0 1
59968: ARRAY
59969: PPUSH
59970: LD_INT 25
59972: PUSH
59973: LD_INT 3
59975: PUSH
59976: EMPTY
59977: LIST
59978: LIST
59979: PPUSH
59980: CALL_OW 72
59984: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59985: LD_ADDR_VAR 0 8
59989: PUSH
59990: LD_EXP 58
59994: PUSH
59995: LD_VAR 0 1
59999: ARRAY
60000: PPUSH
60001: LD_INT 25
60003: PUSH
60004: LD_INT 4
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PUSH
60011: LD_INT 24
60013: PUSH
60014: LD_INT 251
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PPUSH
60025: CALL_OW 72
60029: ST_TO_ADDR
// if mc_scan [ base ] then
60030: LD_EXP 81
60034: PUSH
60035: LD_VAR 0 1
60039: ARRAY
60040: IFFALSE 60501
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60042: LD_ADDR_EXP 100
60046: PUSH
60047: LD_EXP 100
60051: PPUSH
60052: LD_VAR 0 1
60056: PPUSH
60057: LD_INT 4
60059: PPUSH
60060: CALL_OW 1
60064: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60065: LD_ADDR_VAR 0 12
60069: PUSH
60070: LD_EXP 58
60074: PUSH
60075: LD_VAR 0 1
60079: ARRAY
60080: PPUSH
60081: LD_INT 2
60083: PUSH
60084: LD_INT 30
60086: PUSH
60087: LD_INT 4
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PUSH
60094: LD_INT 30
60096: PUSH
60097: LD_INT 5
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: LIST
60108: PPUSH
60109: CALL_OW 72
60113: ST_TO_ADDR
// if not b then
60114: LD_VAR 0 12
60118: NOT
60119: IFFALSE 60123
// exit ;
60121: GO 62866
// p := [ ] ;
60123: LD_ADDR_VAR 0 11
60127: PUSH
60128: EMPTY
60129: ST_TO_ADDR
// if sci >= 2 then
60130: LD_VAR 0 8
60134: PUSH
60135: LD_INT 2
60137: GREATEREQUAL
60138: IFFALSE 60169
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60140: LD_ADDR_VAR 0 8
60144: PUSH
60145: LD_VAR 0 8
60149: PUSH
60150: LD_INT 1
60152: ARRAY
60153: PUSH
60154: LD_VAR 0 8
60158: PUSH
60159: LD_INT 2
60161: ARRAY
60162: PUSH
60163: EMPTY
60164: LIST
60165: LIST
60166: ST_TO_ADDR
60167: GO 60230
// if sci = 1 then
60169: LD_VAR 0 8
60173: PUSH
60174: LD_INT 1
60176: EQUAL
60177: IFFALSE 60198
// sci := [ sci [ 1 ] ] else
60179: LD_ADDR_VAR 0 8
60183: PUSH
60184: LD_VAR 0 8
60188: PUSH
60189: LD_INT 1
60191: ARRAY
60192: PUSH
60193: EMPTY
60194: LIST
60195: ST_TO_ADDR
60196: GO 60230
// if sci = 0 then
60198: LD_VAR 0 8
60202: PUSH
60203: LD_INT 0
60205: EQUAL
60206: IFFALSE 60230
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60208: LD_ADDR_VAR 0 11
60212: PUSH
60213: LD_VAR 0 4
60217: PPUSH
60218: LD_INT 4
60220: PPUSH
60221: CALL 54455 0 2
60225: PUSH
60226: LD_INT 1
60228: ARRAY
60229: ST_TO_ADDR
// if eng > 4 then
60230: LD_VAR 0 6
60234: PUSH
60235: LD_INT 4
60237: GREATER
60238: IFFALSE 60284
// for i = eng downto 4 do
60240: LD_ADDR_VAR 0 3
60244: PUSH
60245: DOUBLE
60246: LD_VAR 0 6
60250: INC
60251: ST_TO_ADDR
60252: LD_INT 4
60254: PUSH
60255: FOR_DOWNTO
60256: IFFALSE 60282
// eng := eng diff eng [ i ] ;
60258: LD_ADDR_VAR 0 6
60262: PUSH
60263: LD_VAR 0 6
60267: PUSH
60268: LD_VAR 0 6
60272: PUSH
60273: LD_VAR 0 3
60277: ARRAY
60278: DIFF
60279: ST_TO_ADDR
60280: GO 60255
60282: POP
60283: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60284: LD_ADDR_VAR 0 4
60288: PUSH
60289: LD_VAR 0 4
60293: PUSH
60294: LD_VAR 0 5
60298: PUSH
60299: LD_VAR 0 6
60303: UNION
60304: PUSH
60305: LD_VAR 0 7
60309: UNION
60310: PUSH
60311: LD_VAR 0 8
60315: UNION
60316: DIFF
60317: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60318: LD_ADDR_VAR 0 13
60322: PUSH
60323: LD_EXP 58
60327: PUSH
60328: LD_VAR 0 1
60332: ARRAY
60333: PPUSH
60334: LD_INT 2
60336: PUSH
60337: LD_INT 30
60339: PUSH
60340: LD_INT 32
60342: PUSH
60343: EMPTY
60344: LIST
60345: LIST
60346: PUSH
60347: LD_INT 30
60349: PUSH
60350: LD_INT 31
60352: PUSH
60353: EMPTY
60354: LIST
60355: LIST
60356: PUSH
60357: EMPTY
60358: LIST
60359: LIST
60360: LIST
60361: PPUSH
60362: CALL_OW 72
60366: PUSH
60367: LD_EXP 58
60371: PUSH
60372: LD_VAR 0 1
60376: ARRAY
60377: PPUSH
60378: LD_INT 2
60380: PUSH
60381: LD_INT 30
60383: PUSH
60384: LD_INT 4
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PUSH
60391: LD_INT 30
60393: PUSH
60394: LD_INT 5
60396: PUSH
60397: EMPTY
60398: LIST
60399: LIST
60400: PUSH
60401: EMPTY
60402: LIST
60403: LIST
60404: LIST
60405: PPUSH
60406: CALL_OW 72
60410: PUSH
60411: LD_INT 6
60413: MUL
60414: PLUS
60415: ST_TO_ADDR
// if bcount < tmp then
60416: LD_VAR 0 13
60420: PUSH
60421: LD_VAR 0 4
60425: LESS
60426: IFFALSE 60472
// for i = tmp downto bcount do
60428: LD_ADDR_VAR 0 3
60432: PUSH
60433: DOUBLE
60434: LD_VAR 0 4
60438: INC
60439: ST_TO_ADDR
60440: LD_VAR 0 13
60444: PUSH
60445: FOR_DOWNTO
60446: IFFALSE 60470
// tmp := Delete ( tmp , tmp ) ;
60448: LD_ADDR_VAR 0 4
60452: PUSH
60453: LD_VAR 0 4
60457: PPUSH
60458: LD_VAR 0 4
60462: PPUSH
60463: CALL_OW 3
60467: ST_TO_ADDR
60468: GO 60445
60470: POP
60471: POP
// result := [ tmp , 0 , 0 , p ] ;
60472: LD_ADDR_VAR 0 2
60476: PUSH
60477: LD_VAR 0 4
60481: PUSH
60482: LD_INT 0
60484: PUSH
60485: LD_INT 0
60487: PUSH
60488: LD_VAR 0 11
60492: PUSH
60493: EMPTY
60494: LIST
60495: LIST
60496: LIST
60497: LIST
60498: ST_TO_ADDR
// exit ;
60499: GO 62866
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60501: LD_EXP 58
60505: PUSH
60506: LD_VAR 0 1
60510: ARRAY
60511: PPUSH
60512: LD_INT 2
60514: PUSH
60515: LD_INT 30
60517: PUSH
60518: LD_INT 6
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PUSH
60525: LD_INT 30
60527: PUSH
60528: LD_INT 7
60530: PUSH
60531: EMPTY
60532: LIST
60533: LIST
60534: PUSH
60535: LD_INT 30
60537: PUSH
60538: LD_INT 8
60540: PUSH
60541: EMPTY
60542: LIST
60543: LIST
60544: PUSH
60545: EMPTY
60546: LIST
60547: LIST
60548: LIST
60549: LIST
60550: PPUSH
60551: CALL_OW 72
60555: NOT
60556: PUSH
60557: LD_EXP 58
60561: PUSH
60562: LD_VAR 0 1
60566: ARRAY
60567: PPUSH
60568: LD_INT 30
60570: PUSH
60571: LD_INT 3
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PPUSH
60578: CALL_OW 72
60582: NOT
60583: AND
60584: IFFALSE 60656
// begin if eng = tmp then
60586: LD_VAR 0 6
60590: PUSH
60591: LD_VAR 0 4
60595: EQUAL
60596: IFFALSE 60600
// exit ;
60598: GO 62866
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60600: LD_ADDR_EXP 100
60604: PUSH
60605: LD_EXP 100
60609: PPUSH
60610: LD_VAR 0 1
60614: PPUSH
60615: LD_INT 1
60617: PPUSH
60618: CALL_OW 1
60622: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60623: LD_ADDR_VAR 0 2
60627: PUSH
60628: LD_INT 0
60630: PUSH
60631: LD_VAR 0 4
60635: PUSH
60636: LD_VAR 0 6
60640: DIFF
60641: PUSH
60642: LD_INT 0
60644: PUSH
60645: LD_INT 0
60647: PUSH
60648: EMPTY
60649: LIST
60650: LIST
60651: LIST
60652: LIST
60653: ST_TO_ADDR
// exit ;
60654: GO 62866
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60656: LD_EXP 85
60660: PUSH
60661: LD_EXP 84
60665: PUSH
60666: LD_VAR 0 1
60670: ARRAY
60671: ARRAY
60672: PUSH
60673: LD_EXP 58
60677: PUSH
60678: LD_VAR 0 1
60682: ARRAY
60683: PPUSH
60684: LD_INT 2
60686: PUSH
60687: LD_INT 30
60689: PUSH
60690: LD_INT 6
60692: PUSH
60693: EMPTY
60694: LIST
60695: LIST
60696: PUSH
60697: LD_INT 30
60699: PUSH
60700: LD_INT 7
60702: PUSH
60703: EMPTY
60704: LIST
60705: LIST
60706: PUSH
60707: LD_INT 30
60709: PUSH
60710: LD_INT 8
60712: PUSH
60713: EMPTY
60714: LIST
60715: LIST
60716: PUSH
60717: EMPTY
60718: LIST
60719: LIST
60720: LIST
60721: LIST
60722: PPUSH
60723: CALL_OW 72
60727: AND
60728: PUSH
60729: LD_EXP 58
60733: PUSH
60734: LD_VAR 0 1
60738: ARRAY
60739: PPUSH
60740: LD_INT 30
60742: PUSH
60743: LD_INT 3
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: PPUSH
60750: CALL_OW 72
60754: NOT
60755: AND
60756: IFFALSE 60970
// begin if sci >= 6 then
60758: LD_VAR 0 8
60762: PUSH
60763: LD_INT 6
60765: GREATEREQUAL
60766: IFFALSE 60770
// exit ;
60768: GO 62866
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60770: LD_ADDR_EXP 100
60774: PUSH
60775: LD_EXP 100
60779: PPUSH
60780: LD_VAR 0 1
60784: PPUSH
60785: LD_INT 2
60787: PPUSH
60788: CALL_OW 1
60792: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60793: LD_ADDR_VAR 0 9
60797: PUSH
60798: LD_VAR 0 4
60802: PUSH
60803: LD_VAR 0 8
60807: DIFF
60808: PPUSH
60809: LD_INT 4
60811: PPUSH
60812: CALL 54455 0 2
60816: ST_TO_ADDR
// p := [ ] ;
60817: LD_ADDR_VAR 0 11
60821: PUSH
60822: EMPTY
60823: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60824: LD_VAR 0 8
60828: PUSH
60829: LD_INT 6
60831: LESS
60832: PUSH
60833: LD_VAR 0 9
60837: PUSH
60838: LD_INT 6
60840: GREATER
60841: AND
60842: IFFALSE 60923
// begin for i = 1 to 6 - sci do
60844: LD_ADDR_VAR 0 3
60848: PUSH
60849: DOUBLE
60850: LD_INT 1
60852: DEC
60853: ST_TO_ADDR
60854: LD_INT 6
60856: PUSH
60857: LD_VAR 0 8
60861: MINUS
60862: PUSH
60863: FOR_TO
60864: IFFALSE 60919
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60866: LD_ADDR_VAR 0 11
60870: PUSH
60871: LD_VAR 0 11
60875: PPUSH
60876: LD_VAR 0 11
60880: PUSH
60881: LD_INT 1
60883: PLUS
60884: PPUSH
60885: LD_VAR 0 9
60889: PUSH
60890: LD_INT 1
60892: ARRAY
60893: PPUSH
60894: CALL_OW 2
60898: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60899: LD_ADDR_VAR 0 9
60903: PUSH
60904: LD_VAR 0 9
60908: PPUSH
60909: LD_INT 1
60911: PPUSH
60912: CALL_OW 3
60916: ST_TO_ADDR
// end ;
60917: GO 60863
60919: POP
60920: POP
// end else
60921: GO 60943
// if sort then
60923: LD_VAR 0 9
60927: IFFALSE 60943
// p := sort [ 1 ] ;
60929: LD_ADDR_VAR 0 11
60933: PUSH
60934: LD_VAR 0 9
60938: PUSH
60939: LD_INT 1
60941: ARRAY
60942: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60943: LD_ADDR_VAR 0 2
60947: PUSH
60948: LD_INT 0
60950: PUSH
60951: LD_INT 0
60953: PUSH
60954: LD_INT 0
60956: PUSH
60957: LD_VAR 0 11
60961: PUSH
60962: EMPTY
60963: LIST
60964: LIST
60965: LIST
60966: LIST
60967: ST_TO_ADDR
// exit ;
60968: GO 62866
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60970: LD_EXP 85
60974: PUSH
60975: LD_EXP 84
60979: PUSH
60980: LD_VAR 0 1
60984: ARRAY
60985: ARRAY
60986: PUSH
60987: LD_EXP 58
60991: PUSH
60992: LD_VAR 0 1
60996: ARRAY
60997: PPUSH
60998: LD_INT 2
61000: PUSH
61001: LD_INT 30
61003: PUSH
61004: LD_INT 6
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: PUSH
61011: LD_INT 30
61013: PUSH
61014: LD_INT 7
61016: PUSH
61017: EMPTY
61018: LIST
61019: LIST
61020: PUSH
61021: LD_INT 30
61023: PUSH
61024: LD_INT 8
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PUSH
61031: EMPTY
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: PPUSH
61037: CALL_OW 72
61041: AND
61042: PUSH
61043: LD_EXP 58
61047: PUSH
61048: LD_VAR 0 1
61052: ARRAY
61053: PPUSH
61054: LD_INT 30
61056: PUSH
61057: LD_INT 3
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PPUSH
61064: CALL_OW 72
61068: AND
61069: IFFALSE 61596
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61071: LD_ADDR_EXP 100
61075: PUSH
61076: LD_EXP 100
61080: PPUSH
61081: LD_VAR 0 1
61085: PPUSH
61086: LD_INT 3
61088: PPUSH
61089: CALL_OW 1
61093: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61094: LD_ADDR_VAR 0 2
61098: PUSH
61099: LD_INT 0
61101: PUSH
61102: LD_INT 0
61104: PUSH
61105: LD_INT 0
61107: PUSH
61108: LD_INT 0
61110: PUSH
61111: EMPTY
61112: LIST
61113: LIST
61114: LIST
61115: LIST
61116: ST_TO_ADDR
// if not eng then
61117: LD_VAR 0 6
61121: NOT
61122: IFFALSE 61185
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61124: LD_ADDR_VAR 0 11
61128: PUSH
61129: LD_VAR 0 4
61133: PPUSH
61134: LD_INT 2
61136: PPUSH
61137: CALL 54455 0 2
61141: PUSH
61142: LD_INT 1
61144: ARRAY
61145: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61146: LD_ADDR_VAR 0 2
61150: PUSH
61151: LD_VAR 0 2
61155: PPUSH
61156: LD_INT 2
61158: PPUSH
61159: LD_VAR 0 11
61163: PPUSH
61164: CALL_OW 1
61168: ST_TO_ADDR
// tmp := tmp diff p ;
61169: LD_ADDR_VAR 0 4
61173: PUSH
61174: LD_VAR 0 4
61178: PUSH
61179: LD_VAR 0 11
61183: DIFF
61184: ST_TO_ADDR
// end ; if not eng then
61185: LD_VAR 0 6
61189: NOT
61190: IFFALSE 61216
// tmp := tmp diff ( mech union sci ) else
61192: LD_ADDR_VAR 0 4
61196: PUSH
61197: LD_VAR 0 4
61201: PUSH
61202: LD_VAR 0 7
61206: PUSH
61207: LD_VAR 0 8
61211: UNION
61212: DIFF
61213: ST_TO_ADDR
61214: GO 61248
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
61216: LD_ADDR_VAR 0 4
61220: PUSH
61221: LD_VAR 0 4
61225: PUSH
61226: LD_VAR 0 6
61230: PUSH
61231: LD_INT 1
61233: ARRAY
61234: PUSH
61235: LD_VAR 0 7
61239: UNION
61240: PUSH
61241: LD_VAR 0 8
61245: UNION
61246: DIFF
61247: ST_TO_ADDR
// if tmp and sci < 6 then
61248: LD_VAR 0 4
61252: PUSH
61253: LD_VAR 0 8
61257: PUSH
61258: LD_INT 6
61260: LESS
61261: AND
61262: IFFALSE 61421
// begin sort := SortBySkill ( tmp , 4 ) ;
61264: LD_ADDR_VAR 0 9
61268: PUSH
61269: LD_VAR 0 4
61273: PPUSH
61274: LD_INT 4
61276: PPUSH
61277: CALL 54455 0 2
61281: ST_TO_ADDR
// p := [ ] ;
61282: LD_ADDR_VAR 0 11
61286: PUSH
61287: EMPTY
61288: ST_TO_ADDR
// if sort then
61289: LD_VAR 0 9
61293: IFFALSE 61392
// for i = 1 to 6 - sci do
61295: LD_ADDR_VAR 0 3
61299: PUSH
61300: DOUBLE
61301: LD_INT 1
61303: DEC
61304: ST_TO_ADDR
61305: LD_INT 6
61307: PUSH
61308: LD_VAR 0 8
61312: MINUS
61313: PUSH
61314: FOR_TO
61315: IFFALSE 61390
// begin if i = sort then
61317: LD_VAR 0 3
61321: PUSH
61322: LD_VAR 0 9
61326: EQUAL
61327: IFFALSE 61331
// break ;
61329: GO 61390
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61331: LD_ADDR_VAR 0 11
61335: PUSH
61336: LD_VAR 0 11
61340: PPUSH
61341: LD_VAR 0 11
61345: PUSH
61346: LD_INT 1
61348: PLUS
61349: PPUSH
61350: LD_VAR 0 9
61354: PUSH
61355: LD_VAR 0 3
61359: ARRAY
61360: PPUSH
61361: CALL_OW 2
61365: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61366: LD_ADDR_VAR 0 4
61370: PUSH
61371: LD_VAR 0 4
61375: PUSH
61376: LD_VAR 0 9
61380: PUSH
61381: LD_VAR 0 3
61385: ARRAY
61386: DIFF
61387: ST_TO_ADDR
// end ;
61388: GO 61314
61390: POP
61391: POP
// if p then
61392: LD_VAR 0 11
61396: IFFALSE 61421
// result := Replace ( result , 4 , p ) ;
61398: LD_ADDR_VAR 0 2
61402: PUSH
61403: LD_VAR 0 2
61407: PPUSH
61408: LD_INT 4
61410: PPUSH
61411: LD_VAR 0 11
61415: PPUSH
61416: CALL_OW 1
61420: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61421: LD_VAR 0 4
61425: PUSH
61426: LD_VAR 0 7
61430: PUSH
61431: LD_INT 6
61433: LESS
61434: AND
61435: IFFALSE 61594
// begin sort := SortBySkill ( tmp , 3 ) ;
61437: LD_ADDR_VAR 0 9
61441: PUSH
61442: LD_VAR 0 4
61446: PPUSH
61447: LD_INT 3
61449: PPUSH
61450: CALL 54455 0 2
61454: ST_TO_ADDR
// p := [ ] ;
61455: LD_ADDR_VAR 0 11
61459: PUSH
61460: EMPTY
61461: ST_TO_ADDR
// if sort then
61462: LD_VAR 0 9
61466: IFFALSE 61565
// for i = 1 to 6 - mech do
61468: LD_ADDR_VAR 0 3
61472: PUSH
61473: DOUBLE
61474: LD_INT 1
61476: DEC
61477: ST_TO_ADDR
61478: LD_INT 6
61480: PUSH
61481: LD_VAR 0 7
61485: MINUS
61486: PUSH
61487: FOR_TO
61488: IFFALSE 61563
// begin if i = sort then
61490: LD_VAR 0 3
61494: PUSH
61495: LD_VAR 0 9
61499: EQUAL
61500: IFFALSE 61504
// break ;
61502: GO 61563
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61504: LD_ADDR_VAR 0 11
61508: PUSH
61509: LD_VAR 0 11
61513: PPUSH
61514: LD_VAR 0 11
61518: PUSH
61519: LD_INT 1
61521: PLUS
61522: PPUSH
61523: LD_VAR 0 9
61527: PUSH
61528: LD_VAR 0 3
61532: ARRAY
61533: PPUSH
61534: CALL_OW 2
61538: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61539: LD_ADDR_VAR 0 4
61543: PUSH
61544: LD_VAR 0 4
61548: PUSH
61549: LD_VAR 0 9
61553: PUSH
61554: LD_VAR 0 3
61558: ARRAY
61559: DIFF
61560: ST_TO_ADDR
// end ;
61561: GO 61487
61563: POP
61564: POP
// if p then
61565: LD_VAR 0 11
61569: IFFALSE 61594
// result := Replace ( result , 3 , p ) ;
61571: LD_ADDR_VAR 0 2
61575: PUSH
61576: LD_VAR 0 2
61580: PPUSH
61581: LD_INT 3
61583: PPUSH
61584: LD_VAR 0 11
61588: PPUSH
61589: CALL_OW 1
61593: ST_TO_ADDR
// end ; exit ;
61594: GO 62866
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61596: LD_EXP 85
61600: PUSH
61601: LD_EXP 84
61605: PUSH
61606: LD_VAR 0 1
61610: ARRAY
61611: ARRAY
61612: NOT
61613: PUSH
61614: LD_EXP 58
61618: PUSH
61619: LD_VAR 0 1
61623: ARRAY
61624: PPUSH
61625: LD_INT 30
61627: PUSH
61628: LD_INT 3
61630: PUSH
61631: EMPTY
61632: LIST
61633: LIST
61634: PPUSH
61635: CALL_OW 72
61639: AND
61640: PUSH
61641: LD_EXP 63
61645: PUSH
61646: LD_VAR 0 1
61650: ARRAY
61651: AND
61652: IFFALSE 62196
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61654: LD_ADDR_EXP 100
61658: PUSH
61659: LD_EXP 100
61663: PPUSH
61664: LD_VAR 0 1
61668: PPUSH
61669: LD_INT 5
61671: PPUSH
61672: CALL_OW 1
61676: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61677: LD_ADDR_VAR 0 2
61681: PUSH
61682: LD_INT 0
61684: PUSH
61685: LD_INT 0
61687: PUSH
61688: LD_INT 0
61690: PUSH
61691: LD_INT 0
61693: PUSH
61694: EMPTY
61695: LIST
61696: LIST
61697: LIST
61698: LIST
61699: ST_TO_ADDR
// if sci > 1 then
61700: LD_VAR 0 8
61704: PUSH
61705: LD_INT 1
61707: GREATER
61708: IFFALSE 61736
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61710: LD_ADDR_VAR 0 4
61714: PUSH
61715: LD_VAR 0 4
61719: PUSH
61720: LD_VAR 0 8
61724: PUSH
61725: LD_VAR 0 8
61729: PUSH
61730: LD_INT 1
61732: ARRAY
61733: DIFF
61734: DIFF
61735: ST_TO_ADDR
// if tmp and not sci then
61736: LD_VAR 0 4
61740: PUSH
61741: LD_VAR 0 8
61745: NOT
61746: AND
61747: IFFALSE 61816
// begin sort := SortBySkill ( tmp , 4 ) ;
61749: LD_ADDR_VAR 0 9
61753: PUSH
61754: LD_VAR 0 4
61758: PPUSH
61759: LD_INT 4
61761: PPUSH
61762: CALL 54455 0 2
61766: ST_TO_ADDR
// if sort then
61767: LD_VAR 0 9
61771: IFFALSE 61787
// p := sort [ 1 ] ;
61773: LD_ADDR_VAR 0 11
61777: PUSH
61778: LD_VAR 0 9
61782: PUSH
61783: LD_INT 1
61785: ARRAY
61786: ST_TO_ADDR
// if p then
61787: LD_VAR 0 11
61791: IFFALSE 61816
// result := Replace ( result , 4 , p ) ;
61793: LD_ADDR_VAR 0 2
61797: PUSH
61798: LD_VAR 0 2
61802: PPUSH
61803: LD_INT 4
61805: PPUSH
61806: LD_VAR 0 11
61810: PPUSH
61811: CALL_OW 1
61815: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61816: LD_ADDR_VAR 0 4
61820: PUSH
61821: LD_VAR 0 4
61825: PUSH
61826: LD_VAR 0 7
61830: DIFF
61831: ST_TO_ADDR
// if tmp and mech < 6 then
61832: LD_VAR 0 4
61836: PUSH
61837: LD_VAR 0 7
61841: PUSH
61842: LD_INT 6
61844: LESS
61845: AND
61846: IFFALSE 62005
// begin sort := SortBySkill ( tmp , 3 ) ;
61848: LD_ADDR_VAR 0 9
61852: PUSH
61853: LD_VAR 0 4
61857: PPUSH
61858: LD_INT 3
61860: PPUSH
61861: CALL 54455 0 2
61865: ST_TO_ADDR
// p := [ ] ;
61866: LD_ADDR_VAR 0 11
61870: PUSH
61871: EMPTY
61872: ST_TO_ADDR
// if sort then
61873: LD_VAR 0 9
61877: IFFALSE 61976
// for i = 1 to 6 - mech do
61879: LD_ADDR_VAR 0 3
61883: PUSH
61884: DOUBLE
61885: LD_INT 1
61887: DEC
61888: ST_TO_ADDR
61889: LD_INT 6
61891: PUSH
61892: LD_VAR 0 7
61896: MINUS
61897: PUSH
61898: FOR_TO
61899: IFFALSE 61974
// begin if i = sort then
61901: LD_VAR 0 3
61905: PUSH
61906: LD_VAR 0 9
61910: EQUAL
61911: IFFALSE 61915
// break ;
61913: GO 61974
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61915: LD_ADDR_VAR 0 11
61919: PUSH
61920: LD_VAR 0 11
61924: PPUSH
61925: LD_VAR 0 11
61929: PUSH
61930: LD_INT 1
61932: PLUS
61933: PPUSH
61934: LD_VAR 0 9
61938: PUSH
61939: LD_VAR 0 3
61943: ARRAY
61944: PPUSH
61945: CALL_OW 2
61949: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61950: LD_ADDR_VAR 0 4
61954: PUSH
61955: LD_VAR 0 4
61959: PUSH
61960: LD_VAR 0 9
61964: PUSH
61965: LD_VAR 0 3
61969: ARRAY
61970: DIFF
61971: ST_TO_ADDR
// end ;
61972: GO 61898
61974: POP
61975: POP
// if p then
61976: LD_VAR 0 11
61980: IFFALSE 62005
// result := Replace ( result , 3 , p ) ;
61982: LD_ADDR_VAR 0 2
61986: PUSH
61987: LD_VAR 0 2
61991: PPUSH
61992: LD_INT 3
61994: PPUSH
61995: LD_VAR 0 11
61999: PPUSH
62000: CALL_OW 1
62004: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62005: LD_ADDR_VAR 0 4
62009: PUSH
62010: LD_VAR 0 4
62014: PUSH
62015: LD_VAR 0 6
62019: DIFF
62020: ST_TO_ADDR
// if tmp and eng < 6 then
62021: LD_VAR 0 4
62025: PUSH
62026: LD_VAR 0 6
62030: PUSH
62031: LD_INT 6
62033: LESS
62034: AND
62035: IFFALSE 62194
// begin sort := SortBySkill ( tmp , 2 ) ;
62037: LD_ADDR_VAR 0 9
62041: PUSH
62042: LD_VAR 0 4
62046: PPUSH
62047: LD_INT 2
62049: PPUSH
62050: CALL 54455 0 2
62054: ST_TO_ADDR
// p := [ ] ;
62055: LD_ADDR_VAR 0 11
62059: PUSH
62060: EMPTY
62061: ST_TO_ADDR
// if sort then
62062: LD_VAR 0 9
62066: IFFALSE 62165
// for i = 1 to 6 - eng do
62068: LD_ADDR_VAR 0 3
62072: PUSH
62073: DOUBLE
62074: LD_INT 1
62076: DEC
62077: ST_TO_ADDR
62078: LD_INT 6
62080: PUSH
62081: LD_VAR 0 6
62085: MINUS
62086: PUSH
62087: FOR_TO
62088: IFFALSE 62163
// begin if i = sort then
62090: LD_VAR 0 3
62094: PUSH
62095: LD_VAR 0 9
62099: EQUAL
62100: IFFALSE 62104
// break ;
62102: GO 62163
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62104: LD_ADDR_VAR 0 11
62108: PUSH
62109: LD_VAR 0 11
62113: PPUSH
62114: LD_VAR 0 11
62118: PUSH
62119: LD_INT 1
62121: PLUS
62122: PPUSH
62123: LD_VAR 0 9
62127: PUSH
62128: LD_VAR 0 3
62132: ARRAY
62133: PPUSH
62134: CALL_OW 2
62138: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62139: LD_ADDR_VAR 0 4
62143: PUSH
62144: LD_VAR 0 4
62148: PUSH
62149: LD_VAR 0 9
62153: PUSH
62154: LD_VAR 0 3
62158: ARRAY
62159: DIFF
62160: ST_TO_ADDR
// end ;
62161: GO 62087
62163: POP
62164: POP
// if p then
62165: LD_VAR 0 11
62169: IFFALSE 62194
// result := Replace ( result , 2 , p ) ;
62171: LD_ADDR_VAR 0 2
62175: PUSH
62176: LD_VAR 0 2
62180: PPUSH
62181: LD_INT 2
62183: PPUSH
62184: LD_VAR 0 11
62188: PPUSH
62189: CALL_OW 1
62193: ST_TO_ADDR
// end ; exit ;
62194: GO 62866
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62196: LD_EXP 85
62200: PUSH
62201: LD_EXP 84
62205: PUSH
62206: LD_VAR 0 1
62210: ARRAY
62211: ARRAY
62212: NOT
62213: PUSH
62214: LD_EXP 58
62218: PUSH
62219: LD_VAR 0 1
62223: ARRAY
62224: PPUSH
62225: LD_INT 30
62227: PUSH
62228: LD_INT 3
62230: PUSH
62231: EMPTY
62232: LIST
62233: LIST
62234: PPUSH
62235: CALL_OW 72
62239: AND
62240: PUSH
62241: LD_EXP 63
62245: PUSH
62246: LD_VAR 0 1
62250: ARRAY
62251: NOT
62252: AND
62253: IFFALSE 62866
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62255: LD_ADDR_EXP 100
62259: PUSH
62260: LD_EXP 100
62264: PPUSH
62265: LD_VAR 0 1
62269: PPUSH
62270: LD_INT 6
62272: PPUSH
62273: CALL_OW 1
62277: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62278: LD_ADDR_VAR 0 2
62282: PUSH
62283: LD_INT 0
62285: PUSH
62286: LD_INT 0
62288: PUSH
62289: LD_INT 0
62291: PUSH
62292: LD_INT 0
62294: PUSH
62295: EMPTY
62296: LIST
62297: LIST
62298: LIST
62299: LIST
62300: ST_TO_ADDR
// if sci >= 1 then
62301: LD_VAR 0 8
62305: PUSH
62306: LD_INT 1
62308: GREATEREQUAL
62309: IFFALSE 62331
// tmp := tmp diff sci [ 1 ] ;
62311: LD_ADDR_VAR 0 4
62315: PUSH
62316: LD_VAR 0 4
62320: PUSH
62321: LD_VAR 0 8
62325: PUSH
62326: LD_INT 1
62328: ARRAY
62329: DIFF
62330: ST_TO_ADDR
// if tmp and not sci then
62331: LD_VAR 0 4
62335: PUSH
62336: LD_VAR 0 8
62340: NOT
62341: AND
62342: IFFALSE 62411
// begin sort := SortBySkill ( tmp , 4 ) ;
62344: LD_ADDR_VAR 0 9
62348: PUSH
62349: LD_VAR 0 4
62353: PPUSH
62354: LD_INT 4
62356: PPUSH
62357: CALL 54455 0 2
62361: ST_TO_ADDR
// if sort then
62362: LD_VAR 0 9
62366: IFFALSE 62382
// p := sort [ 1 ] ;
62368: LD_ADDR_VAR 0 11
62372: PUSH
62373: LD_VAR 0 9
62377: PUSH
62378: LD_INT 1
62380: ARRAY
62381: ST_TO_ADDR
// if p then
62382: LD_VAR 0 11
62386: IFFALSE 62411
// result := Replace ( result , 4 , p ) ;
62388: LD_ADDR_VAR 0 2
62392: PUSH
62393: LD_VAR 0 2
62397: PPUSH
62398: LD_INT 4
62400: PPUSH
62401: LD_VAR 0 11
62405: PPUSH
62406: CALL_OW 1
62410: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62411: LD_ADDR_VAR 0 4
62415: PUSH
62416: LD_VAR 0 4
62420: PUSH
62421: LD_VAR 0 7
62425: DIFF
62426: ST_TO_ADDR
// if tmp and mech < 6 then
62427: LD_VAR 0 4
62431: PUSH
62432: LD_VAR 0 7
62436: PUSH
62437: LD_INT 6
62439: LESS
62440: AND
62441: IFFALSE 62600
// begin sort := SortBySkill ( tmp , 3 ) ;
62443: LD_ADDR_VAR 0 9
62447: PUSH
62448: LD_VAR 0 4
62452: PPUSH
62453: LD_INT 3
62455: PPUSH
62456: CALL 54455 0 2
62460: ST_TO_ADDR
// p := [ ] ;
62461: LD_ADDR_VAR 0 11
62465: PUSH
62466: EMPTY
62467: ST_TO_ADDR
// if sort then
62468: LD_VAR 0 9
62472: IFFALSE 62571
// for i = 1 to 6 - mech do
62474: LD_ADDR_VAR 0 3
62478: PUSH
62479: DOUBLE
62480: LD_INT 1
62482: DEC
62483: ST_TO_ADDR
62484: LD_INT 6
62486: PUSH
62487: LD_VAR 0 7
62491: MINUS
62492: PUSH
62493: FOR_TO
62494: IFFALSE 62569
// begin if i = sort then
62496: LD_VAR 0 3
62500: PUSH
62501: LD_VAR 0 9
62505: EQUAL
62506: IFFALSE 62510
// break ;
62508: GO 62569
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62510: LD_ADDR_VAR 0 11
62514: PUSH
62515: LD_VAR 0 11
62519: PPUSH
62520: LD_VAR 0 11
62524: PUSH
62525: LD_INT 1
62527: PLUS
62528: PPUSH
62529: LD_VAR 0 9
62533: PUSH
62534: LD_VAR 0 3
62538: ARRAY
62539: PPUSH
62540: CALL_OW 2
62544: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62545: LD_ADDR_VAR 0 4
62549: PUSH
62550: LD_VAR 0 4
62554: PUSH
62555: LD_VAR 0 9
62559: PUSH
62560: LD_VAR 0 3
62564: ARRAY
62565: DIFF
62566: ST_TO_ADDR
// end ;
62567: GO 62493
62569: POP
62570: POP
// if p then
62571: LD_VAR 0 11
62575: IFFALSE 62600
// result := Replace ( result , 3 , p ) ;
62577: LD_ADDR_VAR 0 2
62581: PUSH
62582: LD_VAR 0 2
62586: PPUSH
62587: LD_INT 3
62589: PPUSH
62590: LD_VAR 0 11
62594: PPUSH
62595: CALL_OW 1
62599: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62600: LD_ADDR_VAR 0 4
62604: PUSH
62605: LD_VAR 0 4
62609: PUSH
62610: LD_VAR 0 6
62614: DIFF
62615: ST_TO_ADDR
// if tmp and eng < 4 then
62616: LD_VAR 0 4
62620: PUSH
62621: LD_VAR 0 6
62625: PUSH
62626: LD_INT 4
62628: LESS
62629: AND
62630: IFFALSE 62791
// begin sort := SortBySkill ( tmp , 2 ) ;
62632: LD_ADDR_VAR 0 9
62636: PUSH
62637: LD_VAR 0 4
62641: PPUSH
62642: LD_INT 2
62644: PPUSH
62645: CALL 54455 0 2
62649: ST_TO_ADDR
// p := [ ] ;
62650: LD_ADDR_VAR 0 11
62654: PUSH
62655: EMPTY
62656: ST_TO_ADDR
// if sort then
62657: LD_VAR 0 9
62661: IFFALSE 62760
// for i = 1 to 4 - eng do
62663: LD_ADDR_VAR 0 3
62667: PUSH
62668: DOUBLE
62669: LD_INT 1
62671: DEC
62672: ST_TO_ADDR
62673: LD_INT 4
62675: PUSH
62676: LD_VAR 0 6
62680: MINUS
62681: PUSH
62682: FOR_TO
62683: IFFALSE 62758
// begin if i = sort then
62685: LD_VAR 0 3
62689: PUSH
62690: LD_VAR 0 9
62694: EQUAL
62695: IFFALSE 62699
// break ;
62697: GO 62758
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62699: LD_ADDR_VAR 0 11
62703: PUSH
62704: LD_VAR 0 11
62708: PPUSH
62709: LD_VAR 0 11
62713: PUSH
62714: LD_INT 1
62716: PLUS
62717: PPUSH
62718: LD_VAR 0 9
62722: PUSH
62723: LD_VAR 0 3
62727: ARRAY
62728: PPUSH
62729: CALL_OW 2
62733: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62734: LD_ADDR_VAR 0 4
62738: PUSH
62739: LD_VAR 0 4
62743: PUSH
62744: LD_VAR 0 9
62748: PUSH
62749: LD_VAR 0 3
62753: ARRAY
62754: DIFF
62755: ST_TO_ADDR
// end ;
62756: GO 62682
62758: POP
62759: POP
// if p then
62760: LD_VAR 0 11
62764: IFFALSE 62789
// result := Replace ( result , 2 , p ) ;
62766: LD_ADDR_VAR 0 2
62770: PUSH
62771: LD_VAR 0 2
62775: PPUSH
62776: LD_INT 2
62778: PPUSH
62779: LD_VAR 0 11
62783: PPUSH
62784: CALL_OW 1
62788: ST_TO_ADDR
// end else
62789: GO 62835
// for i = eng downto 5 do
62791: LD_ADDR_VAR 0 3
62795: PUSH
62796: DOUBLE
62797: LD_VAR 0 6
62801: INC
62802: ST_TO_ADDR
62803: LD_INT 5
62805: PUSH
62806: FOR_DOWNTO
62807: IFFALSE 62833
// tmp := tmp union eng [ i ] ;
62809: LD_ADDR_VAR 0 4
62813: PUSH
62814: LD_VAR 0 4
62818: PUSH
62819: LD_VAR 0 6
62823: PUSH
62824: LD_VAR 0 3
62828: ARRAY
62829: UNION
62830: ST_TO_ADDR
62831: GO 62806
62833: POP
62834: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62835: LD_ADDR_VAR 0 2
62839: PUSH
62840: LD_VAR 0 2
62844: PPUSH
62845: LD_INT 1
62847: PPUSH
62848: LD_VAR 0 4
62852: PUSH
62853: LD_VAR 0 5
62857: DIFF
62858: PPUSH
62859: CALL_OW 1
62863: ST_TO_ADDR
// exit ;
62864: GO 62866
// end ; end ;
62866: LD_VAR 0 2
62870: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62871: LD_INT 0
62873: PPUSH
62874: PPUSH
62875: PPUSH
// if not mc_bases then
62876: LD_EXP 58
62880: NOT
62881: IFFALSE 62885
// exit ;
62883: GO 62991
// for i = 1 to mc_bases do
62885: LD_ADDR_VAR 0 2
62889: PUSH
62890: DOUBLE
62891: LD_INT 1
62893: DEC
62894: ST_TO_ADDR
62895: LD_EXP 58
62899: PUSH
62900: FOR_TO
62901: IFFALSE 62982
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62903: LD_ADDR_VAR 0 3
62907: PUSH
62908: LD_EXP 58
62912: PUSH
62913: LD_VAR 0 2
62917: ARRAY
62918: PPUSH
62919: LD_INT 21
62921: PUSH
62922: LD_INT 3
62924: PUSH
62925: EMPTY
62926: LIST
62927: LIST
62928: PUSH
62929: LD_INT 3
62931: PUSH
62932: LD_INT 24
62934: PUSH
62935: LD_INT 1000
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: PUSH
62942: EMPTY
62943: LIST
62944: LIST
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PPUSH
62950: CALL_OW 72
62954: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62955: LD_ADDR_EXP 59
62959: PUSH
62960: LD_EXP 59
62964: PPUSH
62965: LD_VAR 0 2
62969: PPUSH
62970: LD_VAR 0 3
62974: PPUSH
62975: CALL_OW 1
62979: ST_TO_ADDR
// end ;
62980: GO 62900
62982: POP
62983: POP
// RaiseSailEvent ( 101 ) ;
62984: LD_INT 101
62986: PPUSH
62987: CALL_OW 427
// end ;
62991: LD_VAR 0 1
62995: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62996: LD_INT 0
62998: PPUSH
62999: PPUSH
63000: PPUSH
63001: PPUSH
63002: PPUSH
63003: PPUSH
63004: PPUSH
// if not mc_bases then
63005: LD_EXP 58
63009: NOT
63010: IFFALSE 63014
// exit ;
63012: GO 63587
// for i = 1 to mc_bases do
63014: LD_ADDR_VAR 0 2
63018: PUSH
63019: DOUBLE
63020: LD_INT 1
63022: DEC
63023: ST_TO_ADDR
63024: LD_EXP 58
63028: PUSH
63029: FOR_TO
63030: IFFALSE 63578
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
63032: LD_ADDR_VAR 0 5
63036: PUSH
63037: LD_EXP 58
63041: PUSH
63042: LD_VAR 0 2
63046: ARRAY
63047: PUSH
63048: LD_EXP 87
63052: PUSH
63053: LD_VAR 0 2
63057: ARRAY
63058: UNION
63059: PPUSH
63060: LD_INT 21
63062: PUSH
63063: LD_INT 1
63065: PUSH
63066: EMPTY
63067: LIST
63068: LIST
63069: PUSH
63070: LD_INT 1
63072: PUSH
63073: LD_INT 3
63075: PUSH
63076: LD_INT 54
63078: PUSH
63079: EMPTY
63080: LIST
63081: PUSH
63082: EMPTY
63083: LIST
63084: LIST
63085: PUSH
63086: LD_INT 3
63088: PUSH
63089: LD_INT 24
63091: PUSH
63092: LD_INT 750
63094: PUSH
63095: EMPTY
63096: LIST
63097: LIST
63098: PUSH
63099: EMPTY
63100: LIST
63101: LIST
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: LIST
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PPUSH
63112: CALL_OW 72
63116: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63117: LD_ADDR_VAR 0 6
63121: PUSH
63122: LD_EXP 58
63126: PUSH
63127: LD_VAR 0 2
63131: ARRAY
63132: PPUSH
63133: LD_INT 21
63135: PUSH
63136: LD_INT 1
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: PUSH
63143: LD_INT 1
63145: PUSH
63146: LD_INT 3
63148: PUSH
63149: LD_INT 54
63151: PUSH
63152: EMPTY
63153: LIST
63154: PUSH
63155: EMPTY
63156: LIST
63157: LIST
63158: PUSH
63159: LD_INT 3
63161: PUSH
63162: LD_INT 24
63164: PUSH
63165: LD_INT 250
63167: PUSH
63168: EMPTY
63169: LIST
63170: LIST
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: PUSH
63176: EMPTY
63177: LIST
63178: LIST
63179: LIST
63180: PUSH
63181: EMPTY
63182: LIST
63183: LIST
63184: PPUSH
63185: CALL_OW 72
63189: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63190: LD_ADDR_VAR 0 7
63194: PUSH
63195: LD_VAR 0 5
63199: PUSH
63200: LD_VAR 0 6
63204: DIFF
63205: ST_TO_ADDR
// if not need_heal_1 then
63206: LD_VAR 0 6
63210: NOT
63211: IFFALSE 63244
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63213: LD_ADDR_EXP 61
63217: PUSH
63218: LD_EXP 61
63222: PPUSH
63223: LD_VAR 0 2
63227: PUSH
63228: LD_INT 1
63230: PUSH
63231: EMPTY
63232: LIST
63233: LIST
63234: PPUSH
63235: EMPTY
63236: PPUSH
63237: CALL 20270 0 3
63241: ST_TO_ADDR
63242: GO 63314
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63244: LD_ADDR_EXP 61
63248: PUSH
63249: LD_EXP 61
63253: PPUSH
63254: LD_VAR 0 2
63258: PUSH
63259: LD_INT 1
63261: PUSH
63262: EMPTY
63263: LIST
63264: LIST
63265: PPUSH
63266: LD_EXP 61
63270: PUSH
63271: LD_VAR 0 2
63275: ARRAY
63276: PUSH
63277: LD_INT 1
63279: ARRAY
63280: PPUSH
63281: LD_INT 3
63283: PUSH
63284: LD_INT 24
63286: PUSH
63287: LD_INT 1000
63289: PUSH
63290: EMPTY
63291: LIST
63292: LIST
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PPUSH
63298: CALL_OW 72
63302: PUSH
63303: LD_VAR 0 6
63307: UNION
63308: PPUSH
63309: CALL 20270 0 3
63313: ST_TO_ADDR
// if not need_heal_2 then
63314: LD_VAR 0 7
63318: NOT
63319: IFFALSE 63352
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63321: LD_ADDR_EXP 61
63325: PUSH
63326: LD_EXP 61
63330: PPUSH
63331: LD_VAR 0 2
63335: PUSH
63336: LD_INT 2
63338: PUSH
63339: EMPTY
63340: LIST
63341: LIST
63342: PPUSH
63343: EMPTY
63344: PPUSH
63345: CALL 20270 0 3
63349: ST_TO_ADDR
63350: GO 63384
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63352: LD_ADDR_EXP 61
63356: PUSH
63357: LD_EXP 61
63361: PPUSH
63362: LD_VAR 0 2
63366: PUSH
63367: LD_INT 2
63369: PUSH
63370: EMPTY
63371: LIST
63372: LIST
63373: PPUSH
63374: LD_VAR 0 7
63378: PPUSH
63379: CALL 20270 0 3
63383: ST_TO_ADDR
// if need_heal_2 then
63384: LD_VAR 0 7
63388: IFFALSE 63560
// for j in need_heal_2 do
63390: LD_ADDR_VAR 0 3
63394: PUSH
63395: LD_VAR 0 7
63399: PUSH
63400: FOR_IN
63401: IFFALSE 63558
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
63403: LD_ADDR_VAR 0 5
63407: PUSH
63408: LD_EXP 58
63412: PUSH
63413: LD_VAR 0 2
63417: ARRAY
63418: PPUSH
63419: LD_INT 2
63421: PUSH
63422: LD_INT 30
63424: PUSH
63425: LD_INT 6
63427: PUSH
63428: EMPTY
63429: LIST
63430: LIST
63431: PUSH
63432: LD_INT 30
63434: PUSH
63435: LD_INT 7
63437: PUSH
63438: EMPTY
63439: LIST
63440: LIST
63441: PUSH
63442: LD_INT 30
63444: PUSH
63445: LD_INT 8
63447: PUSH
63448: EMPTY
63449: LIST
63450: LIST
63451: PUSH
63452: LD_INT 30
63454: PUSH
63455: LD_INT 0
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 30
63464: PUSH
63465: LD_INT 1
63467: PUSH
63468: EMPTY
63469: LIST
63470: LIST
63471: PUSH
63472: LD_INT 25
63474: PUSH
63475: LD_INT 4
63477: PUSH
63478: EMPTY
63479: LIST
63480: LIST
63481: PUSH
63482: EMPTY
63483: LIST
63484: LIST
63485: LIST
63486: LIST
63487: LIST
63488: LIST
63489: LIST
63490: PPUSH
63491: CALL_OW 72
63495: ST_TO_ADDR
// if tmp then
63496: LD_VAR 0 5
63500: IFFALSE 63556
// begin k := NearestUnitToUnit ( tmp , j ) ;
63502: LD_ADDR_VAR 0 4
63506: PUSH
63507: LD_VAR 0 5
63511: PPUSH
63512: LD_VAR 0 3
63516: PPUSH
63517: CALL_OW 74
63521: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63522: LD_VAR 0 3
63526: PPUSH
63527: LD_VAR 0 4
63531: PPUSH
63532: CALL_OW 296
63536: PUSH
63537: LD_INT 7
63539: GREATER
63540: IFFALSE 63556
// ComMoveUnit ( j , k ) ;
63542: LD_VAR 0 3
63546: PPUSH
63547: LD_VAR 0 4
63551: PPUSH
63552: CALL_OW 112
// end ; end ;
63556: GO 63400
63558: POP
63559: POP
// if not need_heal_1 and not need_heal_2 then
63560: LD_VAR 0 6
63564: NOT
63565: PUSH
63566: LD_VAR 0 7
63570: NOT
63571: AND
63572: IFFALSE 63576
// continue ;
63574: GO 63029
// end ;
63576: GO 63029
63578: POP
63579: POP
// RaiseSailEvent ( 102 ) ;
63580: LD_INT 102
63582: PPUSH
63583: CALL_OW 427
// end ;
63587: LD_VAR 0 1
63591: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
63592: LD_INT 0
63594: PPUSH
63595: PPUSH
63596: PPUSH
63597: PPUSH
63598: PPUSH
// if not mc_bases then
63599: LD_EXP 58
63603: NOT
63604: IFFALSE 63608
// exit ;
63606: GO 63993
// for i = 1 to mc_bases do
63608: LD_ADDR_VAR 0 2
63612: PUSH
63613: DOUBLE
63614: LD_INT 1
63616: DEC
63617: ST_TO_ADDR
63618: LD_EXP 58
63622: PUSH
63623: FOR_TO
63624: IFFALSE 63991
// begin if not mc_building_need_repair [ i ] then
63626: LD_EXP 59
63630: PUSH
63631: LD_VAR 0 2
63635: ARRAY
63636: NOT
63637: IFFALSE 63675
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63639: LD_ADDR_EXP 60
63643: PUSH
63644: LD_EXP 60
63648: PPUSH
63649: LD_VAR 0 2
63653: PPUSH
63654: EMPTY
63655: PPUSH
63656: CALL_OW 1
63660: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63661: LD_VAR 0 2
63665: PPUSH
63666: LD_INT 101
63668: PPUSH
63669: CALL 59036 0 2
// continue ;
63673: GO 63623
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63675: LD_ADDR_EXP 64
63679: PUSH
63680: LD_EXP 64
63684: PPUSH
63685: LD_VAR 0 2
63689: PPUSH
63690: EMPTY
63691: PPUSH
63692: CALL_OW 1
63696: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63697: LD_VAR 0 2
63701: PPUSH
63702: LD_INT 103
63704: PPUSH
63705: CALL 59036 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63709: LD_ADDR_VAR 0 5
63713: PUSH
63714: LD_EXP 58
63718: PUSH
63719: LD_VAR 0 2
63723: ARRAY
63724: PUSH
63725: LD_EXP 87
63729: PUSH
63730: LD_VAR 0 2
63734: ARRAY
63735: UNION
63736: PPUSH
63737: LD_INT 2
63739: PUSH
63740: LD_INT 25
63742: PUSH
63743: LD_INT 2
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PUSH
63750: LD_INT 25
63752: PUSH
63753: LD_INT 16
63755: PUSH
63756: EMPTY
63757: LIST
63758: LIST
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: LIST
63764: PUSH
63765: EMPTY
63766: LIST
63767: PPUSH
63768: CALL_OW 72
63772: ST_TO_ADDR
// if not tmp then
63773: LD_VAR 0 5
63777: NOT
63778: IFFALSE 63782
// continue ;
63780: GO 63623
// for j in tmp do
63782: LD_ADDR_VAR 0 3
63786: PUSH
63787: LD_VAR 0 5
63791: PUSH
63792: FOR_IN
63793: IFFALSE 63987
// begin if mc_need_heal [ i ] then
63795: LD_EXP 61
63799: PUSH
63800: LD_VAR 0 2
63804: ARRAY
63805: IFFALSE 63853
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63807: LD_VAR 0 3
63811: PUSH
63812: LD_EXP 61
63816: PUSH
63817: LD_VAR 0 2
63821: ARRAY
63822: PUSH
63823: LD_INT 1
63825: ARRAY
63826: IN
63827: PUSH
63828: LD_VAR 0 3
63832: PUSH
63833: LD_EXP 61
63837: PUSH
63838: LD_VAR 0 2
63842: ARRAY
63843: PUSH
63844: LD_INT 2
63846: ARRAY
63847: IN
63848: OR
63849: IFFALSE 63853
// continue ;
63851: GO 63792
// if IsInUnit ( j ) then
63853: LD_VAR 0 3
63857: PPUSH
63858: CALL_OW 310
63862: IFFALSE 63873
// ComExitBuilding ( j ) ;
63864: LD_VAR 0 3
63868: PPUSH
63869: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63873: LD_VAR 0 3
63877: PUSH
63878: LD_EXP 60
63882: PUSH
63883: LD_VAR 0 2
63887: ARRAY
63888: IN
63889: NOT
63890: IFFALSE 63948
// begin SetTag ( j , 101 ) ;
63892: LD_VAR 0 3
63896: PPUSH
63897: LD_INT 101
63899: PPUSH
63900: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63904: LD_ADDR_EXP 60
63908: PUSH
63909: LD_EXP 60
63913: PPUSH
63914: LD_VAR 0 2
63918: PUSH
63919: LD_EXP 60
63923: PUSH
63924: LD_VAR 0 2
63928: ARRAY
63929: PUSH
63930: LD_INT 1
63932: PLUS
63933: PUSH
63934: EMPTY
63935: LIST
63936: LIST
63937: PPUSH
63938: LD_VAR 0 3
63942: PPUSH
63943: CALL 20270 0 3
63947: ST_TO_ADDR
// end ; wait ( 1 ) ;
63948: LD_INT 1
63950: PPUSH
63951: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
63955: LD_VAR 0 3
63959: PPUSH
63960: LD_EXP 59
63964: PUSH
63965: LD_VAR 0 2
63969: ARRAY
63970: PPUSH
63971: LD_VAR 0 3
63975: PPUSH
63976: CALL_OW 74
63980: PPUSH
63981: CALL_OW 130
// end ;
63985: GO 63792
63987: POP
63988: POP
// end ;
63989: GO 63623
63991: POP
63992: POP
// end ;
63993: LD_VAR 0 1
63997: RET
// export function MC_Heal ; var i , j , tmp ; begin
63998: LD_INT 0
64000: PPUSH
64001: PPUSH
64002: PPUSH
64003: PPUSH
// if not mc_bases then
64004: LD_EXP 58
64008: NOT
64009: IFFALSE 64013
// exit ;
64011: GO 64415
// for i = 1 to mc_bases do
64013: LD_ADDR_VAR 0 2
64017: PUSH
64018: DOUBLE
64019: LD_INT 1
64021: DEC
64022: ST_TO_ADDR
64023: LD_EXP 58
64027: PUSH
64028: FOR_TO
64029: IFFALSE 64413
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64031: LD_EXP 61
64035: PUSH
64036: LD_VAR 0 2
64040: ARRAY
64041: PUSH
64042: LD_INT 1
64044: ARRAY
64045: NOT
64046: PUSH
64047: LD_EXP 61
64051: PUSH
64052: LD_VAR 0 2
64056: ARRAY
64057: PUSH
64058: LD_INT 2
64060: ARRAY
64061: NOT
64062: AND
64063: IFFALSE 64101
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64065: LD_ADDR_EXP 62
64069: PUSH
64070: LD_EXP 62
64074: PPUSH
64075: LD_VAR 0 2
64079: PPUSH
64080: EMPTY
64081: PPUSH
64082: CALL_OW 1
64086: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64087: LD_VAR 0 2
64091: PPUSH
64092: LD_INT 102
64094: PPUSH
64095: CALL 59036 0 2
// continue ;
64099: GO 64028
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64101: LD_ADDR_VAR 0 4
64105: PUSH
64106: LD_EXP 58
64110: PUSH
64111: LD_VAR 0 2
64115: ARRAY
64116: PPUSH
64117: LD_INT 25
64119: PUSH
64120: LD_INT 4
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PPUSH
64127: CALL_OW 72
64131: ST_TO_ADDR
// if not tmp then
64132: LD_VAR 0 4
64136: NOT
64137: IFFALSE 64141
// continue ;
64139: GO 64028
// if mc_taming [ i ] then
64141: LD_EXP 89
64145: PUSH
64146: LD_VAR 0 2
64150: ARRAY
64151: IFFALSE 64175
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64153: LD_ADDR_EXP 89
64157: PUSH
64158: LD_EXP 89
64162: PPUSH
64163: LD_VAR 0 2
64167: PPUSH
64168: EMPTY
64169: PPUSH
64170: CALL_OW 1
64174: ST_TO_ADDR
// for j in tmp do
64175: LD_ADDR_VAR 0 3
64179: PUSH
64180: LD_VAR 0 4
64184: PUSH
64185: FOR_IN
64186: IFFALSE 64409
// begin if IsInUnit ( j ) then
64188: LD_VAR 0 3
64192: PPUSH
64193: CALL_OW 310
64197: IFFALSE 64208
// ComExitBuilding ( j ) ;
64199: LD_VAR 0 3
64203: PPUSH
64204: CALL_OW 122
// if not j in mc_healers [ i ] then
64208: LD_VAR 0 3
64212: PUSH
64213: LD_EXP 62
64217: PUSH
64218: LD_VAR 0 2
64222: ARRAY
64223: IN
64224: NOT
64225: IFFALSE 64271
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64227: LD_ADDR_EXP 62
64231: PUSH
64232: LD_EXP 62
64236: PPUSH
64237: LD_VAR 0 2
64241: PUSH
64242: LD_EXP 62
64246: PUSH
64247: LD_VAR 0 2
64251: ARRAY
64252: PUSH
64253: LD_INT 1
64255: PLUS
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PPUSH
64261: LD_VAR 0 3
64265: PPUSH
64266: CALL 20270 0 3
64270: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64271: LD_VAR 0 3
64275: PPUSH
64276: CALL_OW 110
64280: PUSH
64281: LD_INT 102
64283: NONEQUAL
64284: IFFALSE 64298
// SetTag ( j , 102 ) ;
64286: LD_VAR 0 3
64290: PPUSH
64291: LD_INT 102
64293: PPUSH
64294: CALL_OW 109
// Wait ( 3 ) ;
64298: LD_INT 3
64300: PPUSH
64301: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64305: LD_EXP 61
64309: PUSH
64310: LD_VAR 0 2
64314: ARRAY
64315: PUSH
64316: LD_INT 1
64318: ARRAY
64319: IFFALSE 64351
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64321: LD_VAR 0 3
64325: PPUSH
64326: LD_EXP 61
64330: PUSH
64331: LD_VAR 0 2
64335: ARRAY
64336: PUSH
64337: LD_INT 1
64339: ARRAY
64340: PUSH
64341: LD_INT 1
64343: ARRAY
64344: PPUSH
64345: CALL_OW 128
64349: GO 64407
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64351: LD_VAR 0 3
64355: PPUSH
64356: CALL_OW 314
64360: NOT
64361: PUSH
64362: LD_EXP 61
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: PUSH
64373: LD_INT 2
64375: ARRAY
64376: AND
64377: IFFALSE 64407
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64379: LD_VAR 0 3
64383: PPUSH
64384: LD_EXP 61
64388: PUSH
64389: LD_VAR 0 2
64393: ARRAY
64394: PUSH
64395: LD_INT 2
64397: ARRAY
64398: PUSH
64399: LD_INT 1
64401: ARRAY
64402: PPUSH
64403: CALL_OW 128
// end ;
64407: GO 64185
64409: POP
64410: POP
// end ;
64411: GO 64028
64413: POP
64414: POP
// end ;
64415: LD_VAR 0 1
64419: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64420: LD_INT 0
64422: PPUSH
64423: PPUSH
64424: PPUSH
64425: PPUSH
64426: PPUSH
// if not mc_bases then
64427: LD_EXP 58
64431: NOT
64432: IFFALSE 64436
// exit ;
64434: GO 65579
// for i = 1 to mc_bases do
64436: LD_ADDR_VAR 0 2
64440: PUSH
64441: DOUBLE
64442: LD_INT 1
64444: DEC
64445: ST_TO_ADDR
64446: LD_EXP 58
64450: PUSH
64451: FOR_TO
64452: IFFALSE 65577
// begin if mc_scan [ i ] then
64454: LD_EXP 81
64458: PUSH
64459: LD_VAR 0 2
64463: ARRAY
64464: IFFALSE 64468
// continue ;
64466: GO 64451
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64468: LD_EXP 63
64472: PUSH
64473: LD_VAR 0 2
64477: ARRAY
64478: NOT
64479: PUSH
64480: LD_EXP 65
64484: PUSH
64485: LD_VAR 0 2
64489: ARRAY
64490: NOT
64491: AND
64492: PUSH
64493: LD_EXP 64
64497: PUSH
64498: LD_VAR 0 2
64502: ARRAY
64503: AND
64504: IFFALSE 64542
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64506: LD_ADDR_EXP 64
64510: PUSH
64511: LD_EXP 64
64515: PPUSH
64516: LD_VAR 0 2
64520: PPUSH
64521: EMPTY
64522: PPUSH
64523: CALL_OW 1
64527: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64528: LD_VAR 0 2
64532: PPUSH
64533: LD_INT 103
64535: PPUSH
64536: CALL 59036 0 2
// continue ;
64540: GO 64451
// end ; if mc_construct_list [ i ] then
64542: LD_EXP 65
64546: PUSH
64547: LD_VAR 0 2
64551: ARRAY
64552: IFFALSE 64772
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64554: LD_ADDR_VAR 0 4
64558: PUSH
64559: LD_EXP 58
64563: PUSH
64564: LD_VAR 0 2
64568: ARRAY
64569: PPUSH
64570: LD_INT 25
64572: PUSH
64573: LD_INT 2
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: PPUSH
64580: CALL_OW 72
64584: PUSH
64585: LD_EXP 60
64589: PUSH
64590: LD_VAR 0 2
64594: ARRAY
64595: DIFF
64596: ST_TO_ADDR
// if not tmp then
64597: LD_VAR 0 4
64601: NOT
64602: IFFALSE 64606
// continue ;
64604: GO 64451
// for j in tmp do
64606: LD_ADDR_VAR 0 3
64610: PUSH
64611: LD_VAR 0 4
64615: PUSH
64616: FOR_IN
64617: IFFALSE 64768
// begin if not mc_builders [ i ] then
64619: LD_EXP 64
64623: PUSH
64624: LD_VAR 0 2
64628: ARRAY
64629: NOT
64630: IFFALSE 64688
// begin SetTag ( j , 103 ) ;
64632: LD_VAR 0 3
64636: PPUSH
64637: LD_INT 103
64639: PPUSH
64640: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64644: LD_ADDR_EXP 64
64648: PUSH
64649: LD_EXP 64
64653: PPUSH
64654: LD_VAR 0 2
64658: PUSH
64659: LD_EXP 64
64663: PUSH
64664: LD_VAR 0 2
64668: ARRAY
64669: PUSH
64670: LD_INT 1
64672: PLUS
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: PPUSH
64678: LD_VAR 0 3
64682: PPUSH
64683: CALL 20270 0 3
64687: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64688: LD_VAR 0 3
64692: PPUSH
64693: CALL_OW 310
64697: IFFALSE 64708
// ComExitBuilding ( j ) ;
64699: LD_VAR 0 3
64703: PPUSH
64704: CALL_OW 122
// wait ( 3 ) ;
64708: LD_INT 3
64710: PPUSH
64711: CALL_OW 67
// if not mc_construct_list [ i ] then
64715: LD_EXP 65
64719: PUSH
64720: LD_VAR 0 2
64724: ARRAY
64725: NOT
64726: IFFALSE 64730
// break ;
64728: GO 64768
// if not HasTask ( j ) then
64730: LD_VAR 0 3
64734: PPUSH
64735: CALL_OW 314
64739: NOT
64740: IFFALSE 64766
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64742: LD_VAR 0 3
64746: PPUSH
64747: LD_EXP 65
64751: PUSH
64752: LD_VAR 0 2
64756: ARRAY
64757: PUSH
64758: LD_INT 1
64760: ARRAY
64761: PPUSH
64762: CALL 23121 0 2
// end ;
64766: GO 64616
64768: POP
64769: POP
// end else
64770: GO 65575
// if mc_build_list [ i ] then
64772: LD_EXP 63
64776: PUSH
64777: LD_VAR 0 2
64781: ARRAY
64782: IFFALSE 65575
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64784: LD_ADDR_VAR 0 5
64788: PUSH
64789: LD_EXP 58
64793: PUSH
64794: LD_VAR 0 2
64798: ARRAY
64799: PPUSH
64800: LD_INT 2
64802: PUSH
64803: LD_INT 30
64805: PUSH
64806: LD_INT 0
64808: PUSH
64809: EMPTY
64810: LIST
64811: LIST
64812: PUSH
64813: LD_INT 30
64815: PUSH
64816: LD_INT 1
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: EMPTY
64824: LIST
64825: LIST
64826: LIST
64827: PPUSH
64828: CALL_OW 72
64832: ST_TO_ADDR
// if depot then
64833: LD_VAR 0 5
64837: IFFALSE 64855
// depot := depot [ 1 ] else
64839: LD_ADDR_VAR 0 5
64843: PUSH
64844: LD_VAR 0 5
64848: PUSH
64849: LD_INT 1
64851: ARRAY
64852: ST_TO_ADDR
64853: GO 64863
// depot := 0 ;
64855: LD_ADDR_VAR 0 5
64859: PUSH
64860: LD_INT 0
64862: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64863: LD_EXP 63
64867: PUSH
64868: LD_VAR 0 2
64872: ARRAY
64873: PUSH
64874: LD_INT 1
64876: ARRAY
64877: PUSH
64878: LD_INT 1
64880: ARRAY
64881: PPUSH
64882: CALL 22951 0 1
64886: PUSH
64887: LD_EXP 58
64891: PUSH
64892: LD_VAR 0 2
64896: ARRAY
64897: PPUSH
64898: LD_INT 2
64900: PUSH
64901: LD_INT 30
64903: PUSH
64904: LD_INT 2
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 30
64913: PUSH
64914: LD_INT 3
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: PUSH
64921: EMPTY
64922: LIST
64923: LIST
64924: LIST
64925: PPUSH
64926: CALL_OW 72
64930: NOT
64931: AND
64932: IFFALSE 65037
// begin for j = 1 to mc_build_list [ i ] do
64934: LD_ADDR_VAR 0 3
64938: PUSH
64939: DOUBLE
64940: LD_INT 1
64942: DEC
64943: ST_TO_ADDR
64944: LD_EXP 63
64948: PUSH
64949: LD_VAR 0 2
64953: ARRAY
64954: PUSH
64955: FOR_TO
64956: IFFALSE 65035
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64958: LD_EXP 63
64962: PUSH
64963: LD_VAR 0 2
64967: ARRAY
64968: PUSH
64969: LD_VAR 0 3
64973: ARRAY
64974: PUSH
64975: LD_INT 1
64977: ARRAY
64978: PUSH
64979: LD_INT 2
64981: EQUAL
64982: IFFALSE 65033
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64984: LD_ADDR_EXP 63
64988: PUSH
64989: LD_EXP 63
64993: PPUSH
64994: LD_VAR 0 2
64998: PPUSH
64999: LD_EXP 63
65003: PUSH
65004: LD_VAR 0 2
65008: ARRAY
65009: PPUSH
65010: LD_VAR 0 3
65014: PPUSH
65015: LD_INT 1
65017: PPUSH
65018: LD_INT 0
65020: PPUSH
65021: CALL 19688 0 4
65025: PPUSH
65026: CALL_OW 1
65030: ST_TO_ADDR
// break ;
65031: GO 65035
// end ;
65033: GO 64955
65035: POP
65036: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65037: LD_EXP 63
65041: PUSH
65042: LD_VAR 0 2
65046: ARRAY
65047: PUSH
65048: LD_INT 1
65050: ARRAY
65051: PUSH
65052: LD_INT 1
65054: ARRAY
65055: PUSH
65056: LD_INT 0
65058: EQUAL
65059: PUSH
65060: LD_VAR 0 5
65064: PUSH
65065: LD_VAR 0 5
65069: PPUSH
65070: LD_EXP 63
65074: PUSH
65075: LD_VAR 0 2
65079: ARRAY
65080: PUSH
65081: LD_INT 1
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: ARRAY
65088: PPUSH
65089: LD_EXP 63
65093: PUSH
65094: LD_VAR 0 2
65098: ARRAY
65099: PUSH
65100: LD_INT 1
65102: ARRAY
65103: PUSH
65104: LD_INT 2
65106: ARRAY
65107: PPUSH
65108: LD_EXP 63
65112: PUSH
65113: LD_VAR 0 2
65117: ARRAY
65118: PUSH
65119: LD_INT 1
65121: ARRAY
65122: PUSH
65123: LD_INT 3
65125: ARRAY
65126: PPUSH
65127: LD_EXP 63
65131: PUSH
65132: LD_VAR 0 2
65136: ARRAY
65137: PUSH
65138: LD_INT 1
65140: ARRAY
65141: PUSH
65142: LD_INT 4
65144: ARRAY
65145: PPUSH
65146: CALL 27667 0 5
65150: AND
65151: OR
65152: IFFALSE 65433
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65154: LD_ADDR_VAR 0 4
65158: PUSH
65159: LD_EXP 58
65163: PUSH
65164: LD_VAR 0 2
65168: ARRAY
65169: PPUSH
65170: LD_INT 25
65172: PUSH
65173: LD_INT 2
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PPUSH
65180: CALL_OW 72
65184: PUSH
65185: LD_EXP 60
65189: PUSH
65190: LD_VAR 0 2
65194: ARRAY
65195: DIFF
65196: ST_TO_ADDR
// if not tmp then
65197: LD_VAR 0 4
65201: NOT
65202: IFFALSE 65206
// continue ;
65204: GO 64451
// for j in tmp do
65206: LD_ADDR_VAR 0 3
65210: PUSH
65211: LD_VAR 0 4
65215: PUSH
65216: FOR_IN
65217: IFFALSE 65429
// begin if not mc_builders [ i ] then
65219: LD_EXP 64
65223: PUSH
65224: LD_VAR 0 2
65228: ARRAY
65229: NOT
65230: IFFALSE 65288
// begin SetTag ( j , 103 ) ;
65232: LD_VAR 0 3
65236: PPUSH
65237: LD_INT 103
65239: PPUSH
65240: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65244: LD_ADDR_EXP 64
65248: PUSH
65249: LD_EXP 64
65253: PPUSH
65254: LD_VAR 0 2
65258: PUSH
65259: LD_EXP 64
65263: PUSH
65264: LD_VAR 0 2
65268: ARRAY
65269: PUSH
65270: LD_INT 1
65272: PLUS
65273: PUSH
65274: EMPTY
65275: LIST
65276: LIST
65277: PPUSH
65278: LD_VAR 0 3
65282: PPUSH
65283: CALL 20270 0 3
65287: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65288: LD_VAR 0 3
65292: PPUSH
65293: CALL_OW 310
65297: IFFALSE 65308
// ComExitBuilding ( j ) ;
65299: LD_VAR 0 3
65303: PPUSH
65304: CALL_OW 122
// wait ( 3 ) ;
65308: LD_INT 3
65310: PPUSH
65311: CALL_OW 67
// if not mc_build_list [ i ] then
65315: LD_EXP 63
65319: PUSH
65320: LD_VAR 0 2
65324: ARRAY
65325: NOT
65326: IFFALSE 65330
// break ;
65328: GO 65429
// if not HasTask ( j ) then
65330: LD_VAR 0 3
65334: PPUSH
65335: CALL_OW 314
65339: NOT
65340: IFFALSE 65427
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65342: LD_VAR 0 3
65346: PPUSH
65347: LD_EXP 63
65351: PUSH
65352: LD_VAR 0 2
65356: ARRAY
65357: PUSH
65358: LD_INT 1
65360: ARRAY
65361: PUSH
65362: LD_INT 1
65364: ARRAY
65365: PPUSH
65366: LD_EXP 63
65370: PUSH
65371: LD_VAR 0 2
65375: ARRAY
65376: PUSH
65377: LD_INT 1
65379: ARRAY
65380: PUSH
65381: LD_INT 2
65383: ARRAY
65384: PPUSH
65385: LD_EXP 63
65389: PUSH
65390: LD_VAR 0 2
65394: ARRAY
65395: PUSH
65396: LD_INT 1
65398: ARRAY
65399: PUSH
65400: LD_INT 3
65402: ARRAY
65403: PPUSH
65404: LD_EXP 63
65408: PUSH
65409: LD_VAR 0 2
65413: ARRAY
65414: PUSH
65415: LD_INT 1
65417: ARRAY
65418: PUSH
65419: LD_INT 4
65421: ARRAY
65422: PPUSH
65423: CALL_OW 145
// end ;
65427: GO 65216
65429: POP
65430: POP
// end else
65431: GO 65575
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65433: LD_EXP 58
65437: PUSH
65438: LD_VAR 0 2
65442: ARRAY
65443: PPUSH
65444: LD_EXP 63
65448: PUSH
65449: LD_VAR 0 2
65453: ARRAY
65454: PUSH
65455: LD_INT 1
65457: ARRAY
65458: PUSH
65459: LD_INT 1
65461: ARRAY
65462: PPUSH
65463: LD_EXP 63
65467: PUSH
65468: LD_VAR 0 2
65472: ARRAY
65473: PUSH
65474: LD_INT 1
65476: ARRAY
65477: PUSH
65478: LD_INT 2
65480: ARRAY
65481: PPUSH
65482: LD_EXP 63
65486: PUSH
65487: LD_VAR 0 2
65491: ARRAY
65492: PUSH
65493: LD_INT 1
65495: ARRAY
65496: PUSH
65497: LD_INT 3
65499: ARRAY
65500: PPUSH
65501: LD_EXP 63
65505: PUSH
65506: LD_VAR 0 2
65510: ARRAY
65511: PUSH
65512: LD_INT 1
65514: ARRAY
65515: PUSH
65516: LD_INT 4
65518: ARRAY
65519: PPUSH
65520: CALL 27021 0 5
65524: NOT
65525: IFFALSE 65575
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65527: LD_ADDR_EXP 63
65531: PUSH
65532: LD_EXP 63
65536: PPUSH
65537: LD_VAR 0 2
65541: PPUSH
65542: LD_EXP 63
65546: PUSH
65547: LD_VAR 0 2
65551: ARRAY
65552: PPUSH
65553: LD_INT 1
65555: PPUSH
65556: LD_INT 1
65558: NEG
65559: PPUSH
65560: LD_INT 0
65562: PPUSH
65563: CALL 19688 0 4
65567: PPUSH
65568: CALL_OW 1
65572: ST_TO_ADDR
// continue ;
65573: GO 64451
// end ; end ; end ;
65575: GO 64451
65577: POP
65578: POP
// end ;
65579: LD_VAR 0 1
65583: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65584: LD_INT 0
65586: PPUSH
65587: PPUSH
65588: PPUSH
65589: PPUSH
65590: PPUSH
65591: PPUSH
// if not mc_bases then
65592: LD_EXP 58
65596: NOT
65597: IFFALSE 65601
// exit ;
65599: GO 66028
// for i = 1 to mc_bases do
65601: LD_ADDR_VAR 0 2
65605: PUSH
65606: DOUBLE
65607: LD_INT 1
65609: DEC
65610: ST_TO_ADDR
65611: LD_EXP 58
65615: PUSH
65616: FOR_TO
65617: IFFALSE 66026
// begin tmp := mc_build_upgrade [ i ] ;
65619: LD_ADDR_VAR 0 4
65623: PUSH
65624: LD_EXP 90
65628: PUSH
65629: LD_VAR 0 2
65633: ARRAY
65634: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65635: LD_ADDR_VAR 0 6
65639: PUSH
65640: LD_EXP 91
65644: PUSH
65645: LD_VAR 0 2
65649: ARRAY
65650: PPUSH
65651: LD_INT 2
65653: PUSH
65654: LD_INT 30
65656: PUSH
65657: LD_INT 6
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 30
65666: PUSH
65667: LD_INT 7
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: LIST
65678: PPUSH
65679: CALL_OW 72
65683: ST_TO_ADDR
// if not tmp and not lab then
65684: LD_VAR 0 4
65688: NOT
65689: PUSH
65690: LD_VAR 0 6
65694: NOT
65695: AND
65696: IFFALSE 65700
// continue ;
65698: GO 65616
// if tmp then
65700: LD_VAR 0 4
65704: IFFALSE 65824
// for j in tmp do
65706: LD_ADDR_VAR 0 3
65710: PUSH
65711: LD_VAR 0 4
65715: PUSH
65716: FOR_IN
65717: IFFALSE 65822
// begin if UpgradeCost ( j ) then
65719: LD_VAR 0 3
65723: PPUSH
65724: CALL 26681 0 1
65728: IFFALSE 65820
// begin ComUpgrade ( j ) ;
65730: LD_VAR 0 3
65734: PPUSH
65735: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65739: LD_ADDR_EXP 90
65743: PUSH
65744: LD_EXP 90
65748: PPUSH
65749: LD_VAR 0 2
65753: PPUSH
65754: LD_EXP 90
65758: PUSH
65759: LD_VAR 0 2
65763: ARRAY
65764: PUSH
65765: LD_VAR 0 3
65769: DIFF
65770: PPUSH
65771: CALL_OW 1
65775: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65776: LD_ADDR_EXP 65
65780: PUSH
65781: LD_EXP 65
65785: PPUSH
65786: LD_VAR 0 2
65790: PUSH
65791: LD_EXP 65
65795: PUSH
65796: LD_VAR 0 2
65800: ARRAY
65801: PUSH
65802: LD_INT 1
65804: PLUS
65805: PUSH
65806: EMPTY
65807: LIST
65808: LIST
65809: PPUSH
65810: LD_VAR 0 3
65814: PPUSH
65815: CALL 20270 0 3
65819: ST_TO_ADDR
// end ; end ;
65820: GO 65716
65822: POP
65823: POP
// if not lab or not mc_lab_upgrade [ i ] then
65824: LD_VAR 0 6
65828: NOT
65829: PUSH
65830: LD_EXP 92
65834: PUSH
65835: LD_VAR 0 2
65839: ARRAY
65840: NOT
65841: OR
65842: IFFALSE 65846
// continue ;
65844: GO 65616
// for j in lab do
65846: LD_ADDR_VAR 0 3
65850: PUSH
65851: LD_VAR 0 6
65855: PUSH
65856: FOR_IN
65857: IFFALSE 66022
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65859: LD_VAR 0 3
65863: PPUSH
65864: CALL_OW 266
65868: PUSH
65869: LD_INT 6
65871: PUSH
65872: LD_INT 7
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: IN
65879: PUSH
65880: LD_VAR 0 3
65884: PPUSH
65885: CALL_OW 461
65889: PUSH
65890: LD_INT 1
65892: NONEQUAL
65893: AND
65894: IFFALSE 66020
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65896: LD_VAR 0 3
65900: PPUSH
65901: LD_EXP 92
65905: PUSH
65906: LD_VAR 0 2
65910: ARRAY
65911: PUSH
65912: LD_INT 1
65914: ARRAY
65915: PPUSH
65916: CALL 26886 0 2
65920: IFFALSE 66020
// begin ComCancel ( j ) ;
65922: LD_VAR 0 3
65926: PPUSH
65927: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65931: LD_VAR 0 3
65935: PPUSH
65936: LD_EXP 92
65940: PUSH
65941: LD_VAR 0 2
65945: ARRAY
65946: PUSH
65947: LD_INT 1
65949: ARRAY
65950: PPUSH
65951: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65955: LD_VAR 0 3
65959: PUSH
65960: LD_EXP 65
65964: PUSH
65965: LD_VAR 0 2
65969: ARRAY
65970: IN
65971: NOT
65972: IFFALSE 66018
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65974: LD_ADDR_EXP 65
65978: PUSH
65979: LD_EXP 65
65983: PPUSH
65984: LD_VAR 0 2
65988: PUSH
65989: LD_EXP 65
65993: PUSH
65994: LD_VAR 0 2
65998: ARRAY
65999: PUSH
66000: LD_INT 1
66002: PLUS
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PPUSH
66008: LD_VAR 0 3
66012: PPUSH
66013: CALL 20270 0 3
66017: ST_TO_ADDR
// break ;
66018: GO 66022
// end ; end ; end ;
66020: GO 65856
66022: POP
66023: POP
// end ;
66024: GO 65616
66026: POP
66027: POP
// end ;
66028: LD_VAR 0 1
66032: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66033: LD_INT 0
66035: PPUSH
66036: PPUSH
66037: PPUSH
66038: PPUSH
66039: PPUSH
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
// if not mc_bases then
66044: LD_EXP 58
66048: NOT
66049: IFFALSE 66053
// exit ;
66051: GO 66458
// for i = 1 to mc_bases do
66053: LD_ADDR_VAR 0 2
66057: PUSH
66058: DOUBLE
66059: LD_INT 1
66061: DEC
66062: ST_TO_ADDR
66063: LD_EXP 58
66067: PUSH
66068: FOR_TO
66069: IFFALSE 66456
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66071: LD_EXP 66
66075: PUSH
66076: LD_VAR 0 2
66080: ARRAY
66081: NOT
66082: PUSH
66083: LD_EXP 58
66087: PUSH
66088: LD_VAR 0 2
66092: ARRAY
66093: PPUSH
66094: LD_INT 30
66096: PUSH
66097: LD_INT 3
66099: PUSH
66100: EMPTY
66101: LIST
66102: LIST
66103: PPUSH
66104: CALL_OW 72
66108: NOT
66109: OR
66110: IFFALSE 66114
// continue ;
66112: GO 66068
// busy := false ;
66114: LD_ADDR_VAR 0 8
66118: PUSH
66119: LD_INT 0
66121: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66122: LD_ADDR_VAR 0 4
66126: PUSH
66127: LD_EXP 58
66131: PUSH
66132: LD_VAR 0 2
66136: ARRAY
66137: PPUSH
66138: LD_INT 30
66140: PUSH
66141: LD_INT 3
66143: PUSH
66144: EMPTY
66145: LIST
66146: LIST
66147: PPUSH
66148: CALL_OW 72
66152: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66153: LD_ADDR_VAR 0 6
66157: PUSH
66158: LD_EXP 66
66162: PUSH
66163: LD_VAR 0 2
66167: ARRAY
66168: PPUSH
66169: LD_INT 2
66171: PUSH
66172: LD_INT 30
66174: PUSH
66175: LD_INT 32
66177: PUSH
66178: EMPTY
66179: LIST
66180: LIST
66181: PUSH
66182: LD_INT 30
66184: PUSH
66185: LD_INT 33
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: LIST
66196: PPUSH
66197: CALL_OW 72
66201: ST_TO_ADDR
// if not t then
66202: LD_VAR 0 6
66206: NOT
66207: IFFALSE 66211
// continue ;
66209: GO 66068
// for j in tmp do
66211: LD_ADDR_VAR 0 3
66215: PUSH
66216: LD_VAR 0 4
66220: PUSH
66221: FOR_IN
66222: IFFALSE 66252
// if not BuildingStatus ( j ) = bs_idle then
66224: LD_VAR 0 3
66228: PPUSH
66229: CALL_OW 461
66233: PUSH
66234: LD_INT 2
66236: EQUAL
66237: NOT
66238: IFFALSE 66250
// begin busy := true ;
66240: LD_ADDR_VAR 0 8
66244: PUSH
66245: LD_INT 1
66247: ST_TO_ADDR
// break ;
66248: GO 66252
// end ;
66250: GO 66221
66252: POP
66253: POP
// if busy then
66254: LD_VAR 0 8
66258: IFFALSE 66262
// continue ;
66260: GO 66068
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66262: LD_ADDR_VAR 0 7
66266: PUSH
66267: LD_VAR 0 6
66271: PPUSH
66272: LD_INT 35
66274: PUSH
66275: LD_INT 0
66277: PUSH
66278: EMPTY
66279: LIST
66280: LIST
66281: PPUSH
66282: CALL_OW 72
66286: ST_TO_ADDR
// if tw then
66287: LD_VAR 0 7
66291: IFFALSE 66368
// begin tw := tw [ 1 ] ;
66293: LD_ADDR_VAR 0 7
66297: PUSH
66298: LD_VAR 0 7
66302: PUSH
66303: LD_INT 1
66305: ARRAY
66306: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66307: LD_ADDR_VAR 0 9
66311: PUSH
66312: LD_VAR 0 7
66316: PPUSH
66317: LD_EXP 83
66321: PUSH
66322: LD_VAR 0 2
66326: ARRAY
66327: PPUSH
66328: CALL 25240 0 2
66332: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66333: LD_EXP 97
66337: PUSH
66338: LD_VAR 0 2
66342: ARRAY
66343: IFFALSE 66366
// if not weapon in mc_allowed_tower_weapons [ i ] then
66345: LD_VAR 0 9
66349: PUSH
66350: LD_EXP 97
66354: PUSH
66355: LD_VAR 0 2
66359: ARRAY
66360: IN
66361: NOT
66362: IFFALSE 66366
// continue ;
66364: GO 66068
// end else
66366: GO 66431
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66368: LD_ADDR_VAR 0 5
66372: PUSH
66373: LD_EXP 66
66377: PUSH
66378: LD_VAR 0 2
66382: ARRAY
66383: PPUSH
66384: LD_VAR 0 4
66388: PPUSH
66389: CALL 55379 0 2
66393: ST_TO_ADDR
// if not tmp2 then
66394: LD_VAR 0 5
66398: NOT
66399: IFFALSE 66403
// continue ;
66401: GO 66068
// tw := tmp2 [ 1 ] ;
66403: LD_ADDR_VAR 0 7
66407: PUSH
66408: LD_VAR 0 5
66412: PUSH
66413: LD_INT 1
66415: ARRAY
66416: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66417: LD_ADDR_VAR 0 9
66421: PUSH
66422: LD_VAR 0 5
66426: PUSH
66427: LD_INT 2
66429: ARRAY
66430: ST_TO_ADDR
// end ; if not weapon then
66431: LD_VAR 0 9
66435: NOT
66436: IFFALSE 66440
// continue ;
66438: GO 66068
// ComPlaceWeapon ( tw , weapon ) ;
66440: LD_VAR 0 7
66444: PPUSH
66445: LD_VAR 0 9
66449: PPUSH
66450: CALL_OW 148
// end ;
66454: GO 66068
66456: POP
66457: POP
// end ;
66458: LD_VAR 0 1
66462: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
66463: LD_INT 0
66465: PPUSH
66466: PPUSH
66467: PPUSH
66468: PPUSH
66469: PPUSH
66470: PPUSH
// if not mc_bases then
66471: LD_EXP 58
66475: NOT
66476: IFFALSE 66480
// exit ;
66478: GO 67492
// for i = 1 to mc_bases do
66480: LD_ADDR_VAR 0 2
66484: PUSH
66485: DOUBLE
66486: LD_INT 1
66488: DEC
66489: ST_TO_ADDR
66490: LD_EXP 58
66494: PUSH
66495: FOR_TO
66496: IFFALSE 67490
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
66498: LD_EXP 71
66502: PUSH
66503: LD_VAR 0 2
66507: ARRAY
66508: NOT
66509: PUSH
66510: LD_EXP 71
66514: PUSH
66515: LD_VAR 0 2
66519: ARRAY
66520: PUSH
66521: LD_EXP 72
66525: PUSH
66526: LD_VAR 0 2
66530: ARRAY
66531: EQUAL
66532: OR
66533: IFFALSE 66537
// continue ;
66535: GO 66495
// if mc_miners [ i ] then
66537: LD_EXP 72
66541: PUSH
66542: LD_VAR 0 2
66546: ARRAY
66547: IFFALSE 67177
// begin k := 1 ;
66549: LD_ADDR_VAR 0 4
66553: PUSH
66554: LD_INT 1
66556: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
66557: LD_ADDR_VAR 0 3
66561: PUSH
66562: DOUBLE
66563: LD_EXP 72
66567: PUSH
66568: LD_VAR 0 2
66572: ARRAY
66573: INC
66574: ST_TO_ADDR
66575: LD_INT 1
66577: PUSH
66578: FOR_DOWNTO
66579: IFFALSE 67175
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66581: LD_EXP 72
66585: PUSH
66586: LD_VAR 0 2
66590: ARRAY
66591: PUSH
66592: LD_VAR 0 3
66596: ARRAY
66597: PPUSH
66598: CALL_OW 301
66602: PUSH
66603: LD_EXP 72
66607: PUSH
66608: LD_VAR 0 2
66612: ARRAY
66613: PUSH
66614: LD_VAR 0 3
66618: ARRAY
66619: PPUSH
66620: CALL_OW 257
66624: PUSH
66625: LD_INT 1
66627: NONEQUAL
66628: OR
66629: IFFALSE 66692
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66631: LD_ADDR_VAR 0 5
66635: PUSH
66636: LD_EXP 72
66640: PUSH
66641: LD_VAR 0 2
66645: ARRAY
66646: PUSH
66647: LD_EXP 72
66651: PUSH
66652: LD_VAR 0 2
66656: ARRAY
66657: PUSH
66658: LD_VAR 0 3
66662: ARRAY
66663: DIFF
66664: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66665: LD_ADDR_EXP 72
66669: PUSH
66670: LD_EXP 72
66674: PPUSH
66675: LD_VAR 0 2
66679: PPUSH
66680: LD_VAR 0 5
66684: PPUSH
66685: CALL_OW 1
66689: ST_TO_ADDR
// continue ;
66690: GO 66578
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
66692: LD_EXP 72
66696: PUSH
66697: LD_VAR 0 2
66701: ARRAY
66702: PUSH
66703: LD_VAR 0 3
66707: ARRAY
66708: PPUSH
66709: CALL 20206 0 1
66713: PUSH
66714: LD_EXP 72
66718: PUSH
66719: LD_VAR 0 2
66723: ARRAY
66724: PUSH
66725: LD_VAR 0 3
66729: ARRAY
66730: PPUSH
66731: CALL_OW 255
66735: PPUSH
66736: LD_EXP 71
66740: PUSH
66741: LD_VAR 0 2
66745: ARRAY
66746: PUSH
66747: LD_VAR 0 4
66751: ARRAY
66752: PUSH
66753: LD_INT 1
66755: ARRAY
66756: PPUSH
66757: LD_EXP 71
66761: PUSH
66762: LD_VAR 0 2
66766: ARRAY
66767: PUSH
66768: LD_VAR 0 4
66772: ARRAY
66773: PUSH
66774: LD_INT 2
66776: ARRAY
66777: PPUSH
66778: LD_INT 15
66780: PPUSH
66781: CALL 21166 0 4
66785: PUSH
66786: LD_INT 4
66788: ARRAY
66789: PUSH
66790: LD_EXP 72
66794: PUSH
66795: LD_VAR 0 2
66799: ARRAY
66800: PUSH
66801: LD_VAR 0 3
66805: ARRAY
66806: PPUSH
66807: LD_INT 10
66809: PPUSH
66810: CALL 22863 0 2
66814: PUSH
66815: LD_INT 4
66817: ARRAY
66818: OR
66819: AND
66820: IFFALSE 66843
// ComStop ( mc_miners [ i ] [ j ] ) ;
66822: LD_EXP 72
66826: PUSH
66827: LD_VAR 0 2
66831: ARRAY
66832: PUSH
66833: LD_VAR 0 3
66837: ARRAY
66838: PPUSH
66839: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
66843: LD_EXP 72
66847: PUSH
66848: LD_VAR 0 2
66852: ARRAY
66853: PUSH
66854: LD_VAR 0 3
66858: ARRAY
66859: PPUSH
66860: CALL_OW 257
66864: PUSH
66865: LD_INT 1
66867: EQUAL
66868: PUSH
66869: LD_EXP 72
66873: PUSH
66874: LD_VAR 0 2
66878: ARRAY
66879: PUSH
66880: LD_VAR 0 3
66884: ARRAY
66885: PPUSH
66886: CALL_OW 459
66890: NOT
66891: AND
66892: PUSH
66893: LD_EXP 72
66897: PUSH
66898: LD_VAR 0 2
66902: ARRAY
66903: PUSH
66904: LD_VAR 0 3
66908: ARRAY
66909: PPUSH
66910: CALL_OW 255
66914: PPUSH
66915: LD_EXP 71
66919: PUSH
66920: LD_VAR 0 2
66924: ARRAY
66925: PUSH
66926: LD_VAR 0 4
66930: ARRAY
66931: PUSH
66932: LD_INT 1
66934: ARRAY
66935: PPUSH
66936: LD_EXP 71
66940: PUSH
66941: LD_VAR 0 2
66945: ARRAY
66946: PUSH
66947: LD_VAR 0 4
66951: ARRAY
66952: PUSH
66953: LD_INT 2
66955: ARRAY
66956: PPUSH
66957: LD_INT 15
66959: PPUSH
66960: CALL 21166 0 4
66964: PUSH
66965: LD_INT 4
66967: ARRAY
66968: PUSH
66969: LD_INT 0
66971: EQUAL
66972: AND
66973: PUSH
66974: LD_EXP 72
66978: PUSH
66979: LD_VAR 0 2
66983: ARRAY
66984: PUSH
66985: LD_VAR 0 3
66989: ARRAY
66990: PPUSH
66991: CALL_OW 314
66995: NOT
66996: AND
66997: IFFALSE 67173
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66999: LD_EXP 72
67003: PUSH
67004: LD_VAR 0 2
67008: ARRAY
67009: PUSH
67010: LD_VAR 0 3
67014: ARRAY
67015: PPUSH
67016: CALL_OW 310
67020: IFFALSE 67043
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67022: LD_EXP 72
67026: PUSH
67027: LD_VAR 0 2
67031: ARRAY
67032: PUSH
67033: LD_VAR 0 3
67037: ARRAY
67038: PPUSH
67039: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67043: LD_EXP 72
67047: PUSH
67048: LD_VAR 0 2
67052: ARRAY
67053: PUSH
67054: LD_VAR 0 3
67058: ARRAY
67059: PPUSH
67060: CALL_OW 314
67064: NOT
67065: IFFALSE 67133
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
67067: LD_EXP 72
67071: PUSH
67072: LD_VAR 0 2
67076: ARRAY
67077: PUSH
67078: LD_VAR 0 3
67082: ARRAY
67083: PPUSH
67084: LD_EXP 71
67088: PUSH
67089: LD_VAR 0 2
67093: ARRAY
67094: PUSH
67095: LD_VAR 0 4
67099: ARRAY
67100: PUSH
67101: LD_INT 1
67103: ARRAY
67104: PPUSH
67105: LD_EXP 71
67109: PUSH
67110: LD_VAR 0 2
67114: ARRAY
67115: PUSH
67116: LD_VAR 0 4
67120: ARRAY
67121: PUSH
67122: LD_INT 2
67124: ARRAY
67125: PPUSH
67126: LD_INT 0
67128: PPUSH
67129: CALL_OW 193
// k := k + 1 ;
67133: LD_ADDR_VAR 0 4
67137: PUSH
67138: LD_VAR 0 4
67142: PUSH
67143: LD_INT 1
67145: PLUS
67146: ST_TO_ADDR
// if k > mc_mines [ i ] then
67147: LD_VAR 0 4
67151: PUSH
67152: LD_EXP 71
67156: PUSH
67157: LD_VAR 0 2
67161: ARRAY
67162: GREATER
67163: IFFALSE 67173
// k := 1 ;
67165: LD_ADDR_VAR 0 4
67169: PUSH
67170: LD_INT 1
67172: ST_TO_ADDR
// end ; end ;
67173: GO 66578
67175: POP
67176: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67177: LD_ADDR_VAR 0 5
67181: PUSH
67182: LD_EXP 58
67186: PUSH
67187: LD_VAR 0 2
67191: ARRAY
67192: PPUSH
67193: LD_INT 2
67195: PUSH
67196: LD_INT 30
67198: PUSH
67199: LD_INT 4
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 30
67208: PUSH
67209: LD_INT 5
67211: PUSH
67212: EMPTY
67213: LIST
67214: LIST
67215: PUSH
67216: LD_INT 30
67218: PUSH
67219: LD_INT 32
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: LIST
67230: LIST
67231: PPUSH
67232: CALL_OW 72
67236: ST_TO_ADDR
// if not tmp then
67237: LD_VAR 0 5
67241: NOT
67242: IFFALSE 67246
// continue ;
67244: GO 66495
// list := [ ] ;
67246: LD_ADDR_VAR 0 6
67250: PUSH
67251: EMPTY
67252: ST_TO_ADDR
// for j in tmp do
67253: LD_ADDR_VAR 0 3
67257: PUSH
67258: LD_VAR 0 5
67262: PUSH
67263: FOR_IN
67264: IFFALSE 67333
// begin for k in UnitsInside ( j ) do
67266: LD_ADDR_VAR 0 4
67270: PUSH
67271: LD_VAR 0 3
67275: PPUSH
67276: CALL_OW 313
67280: PUSH
67281: FOR_IN
67282: IFFALSE 67329
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67284: LD_VAR 0 4
67288: PPUSH
67289: CALL_OW 257
67293: PUSH
67294: LD_INT 1
67296: EQUAL
67297: PUSH
67298: LD_VAR 0 4
67302: PPUSH
67303: CALL_OW 459
67307: NOT
67308: AND
67309: IFFALSE 67327
// list := list ^ k ;
67311: LD_ADDR_VAR 0 6
67315: PUSH
67316: LD_VAR 0 6
67320: PUSH
67321: LD_VAR 0 4
67325: ADD
67326: ST_TO_ADDR
67327: GO 67281
67329: POP
67330: POP
// end ;
67331: GO 67263
67333: POP
67334: POP
// list := list diff mc_miners [ i ] ;
67335: LD_ADDR_VAR 0 6
67339: PUSH
67340: LD_VAR 0 6
67344: PUSH
67345: LD_EXP 72
67349: PUSH
67350: LD_VAR 0 2
67354: ARRAY
67355: DIFF
67356: ST_TO_ADDR
// if not list then
67357: LD_VAR 0 6
67361: NOT
67362: IFFALSE 67366
// continue ;
67364: GO 66495
// k := mc_mines [ i ] - mc_miners [ i ] ;
67366: LD_ADDR_VAR 0 4
67370: PUSH
67371: LD_EXP 71
67375: PUSH
67376: LD_VAR 0 2
67380: ARRAY
67381: PUSH
67382: LD_EXP 72
67386: PUSH
67387: LD_VAR 0 2
67391: ARRAY
67392: MINUS
67393: ST_TO_ADDR
// if k > list then
67394: LD_VAR 0 4
67398: PUSH
67399: LD_VAR 0 6
67403: GREATER
67404: IFFALSE 67416
// k := list ;
67406: LD_ADDR_VAR 0 4
67410: PUSH
67411: LD_VAR 0 6
67415: ST_TO_ADDR
// for j = 1 to k do
67416: LD_ADDR_VAR 0 3
67420: PUSH
67421: DOUBLE
67422: LD_INT 1
67424: DEC
67425: ST_TO_ADDR
67426: LD_VAR 0 4
67430: PUSH
67431: FOR_TO
67432: IFFALSE 67486
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67434: LD_ADDR_EXP 72
67438: PUSH
67439: LD_EXP 72
67443: PPUSH
67444: LD_VAR 0 2
67448: PUSH
67449: LD_EXP 72
67453: PUSH
67454: LD_VAR 0 2
67458: ARRAY
67459: PUSH
67460: LD_INT 1
67462: PLUS
67463: PUSH
67464: EMPTY
67465: LIST
67466: LIST
67467: PPUSH
67468: LD_VAR 0 6
67472: PUSH
67473: LD_VAR 0 3
67477: ARRAY
67478: PPUSH
67479: CALL 20270 0 3
67483: ST_TO_ADDR
67484: GO 67431
67486: POP
67487: POP
// end ;
67488: GO 66495
67490: POP
67491: POP
// end ;
67492: LD_VAR 0 1
67496: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67497: LD_INT 0
67499: PPUSH
67500: PPUSH
67501: PPUSH
67502: PPUSH
67503: PPUSH
67504: PPUSH
67505: PPUSH
67506: PPUSH
67507: PPUSH
67508: PPUSH
// if not mc_bases then
67509: LD_EXP 58
67513: NOT
67514: IFFALSE 67518
// exit ;
67516: GO 69249
// for i = 1 to mc_bases do
67518: LD_ADDR_VAR 0 2
67522: PUSH
67523: DOUBLE
67524: LD_INT 1
67526: DEC
67527: ST_TO_ADDR
67528: LD_EXP 58
67532: PUSH
67533: FOR_TO
67534: IFFALSE 69247
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67536: LD_EXP 58
67540: PUSH
67541: LD_VAR 0 2
67545: ARRAY
67546: NOT
67547: PUSH
67548: LD_EXP 65
67552: PUSH
67553: LD_VAR 0 2
67557: ARRAY
67558: OR
67559: IFFALSE 67563
// continue ;
67561: GO 67533
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67563: LD_EXP 74
67567: PUSH
67568: LD_VAR 0 2
67572: ARRAY
67573: NOT
67574: PUSH
67575: LD_EXP 75
67579: PUSH
67580: LD_VAR 0 2
67584: ARRAY
67585: AND
67586: IFFALSE 67624
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67588: LD_ADDR_EXP 75
67592: PUSH
67593: LD_EXP 75
67597: PPUSH
67598: LD_VAR 0 2
67602: PPUSH
67603: EMPTY
67604: PPUSH
67605: CALL_OW 1
67609: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67610: LD_VAR 0 2
67614: PPUSH
67615: LD_INT 107
67617: PPUSH
67618: CALL 59036 0 2
// continue ;
67622: GO 67533
// end ; target := [ ] ;
67624: LD_ADDR_VAR 0 6
67628: PUSH
67629: EMPTY
67630: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67631: LD_ADDR_VAR 0 3
67635: PUSH
67636: DOUBLE
67637: LD_EXP 74
67641: PUSH
67642: LD_VAR 0 2
67646: ARRAY
67647: INC
67648: ST_TO_ADDR
67649: LD_INT 1
67651: PUSH
67652: FOR_DOWNTO
67653: IFFALSE 67913
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67655: LD_EXP 74
67659: PUSH
67660: LD_VAR 0 2
67664: ARRAY
67665: PUSH
67666: LD_VAR 0 3
67670: ARRAY
67671: PUSH
67672: LD_INT 2
67674: ARRAY
67675: PPUSH
67676: LD_EXP 74
67680: PUSH
67681: LD_VAR 0 2
67685: ARRAY
67686: PUSH
67687: LD_VAR 0 3
67691: ARRAY
67692: PUSH
67693: LD_INT 3
67695: ARRAY
67696: PPUSH
67697: CALL_OW 488
67701: PUSH
67702: LD_EXP 74
67706: PUSH
67707: LD_VAR 0 2
67711: ARRAY
67712: PUSH
67713: LD_VAR 0 3
67717: ARRAY
67718: PUSH
67719: LD_INT 2
67721: ARRAY
67722: PPUSH
67723: LD_EXP 74
67727: PUSH
67728: LD_VAR 0 2
67732: ARRAY
67733: PUSH
67734: LD_VAR 0 3
67738: ARRAY
67739: PUSH
67740: LD_INT 3
67742: ARRAY
67743: PPUSH
67744: CALL_OW 284
67748: PUSH
67749: LD_INT 0
67751: EQUAL
67752: AND
67753: IFFALSE 67808
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67755: LD_ADDR_VAR 0 5
67759: PUSH
67760: LD_EXP 74
67764: PUSH
67765: LD_VAR 0 2
67769: ARRAY
67770: PPUSH
67771: LD_VAR 0 3
67775: PPUSH
67776: CALL_OW 3
67780: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67781: LD_ADDR_EXP 74
67785: PUSH
67786: LD_EXP 74
67790: PPUSH
67791: LD_VAR 0 2
67795: PPUSH
67796: LD_VAR 0 5
67800: PPUSH
67801: CALL_OW 1
67805: ST_TO_ADDR
// continue ;
67806: GO 67652
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67808: LD_EXP 58
67812: PUSH
67813: LD_VAR 0 2
67817: ARRAY
67818: PUSH
67819: LD_INT 1
67821: ARRAY
67822: PPUSH
67823: CALL_OW 255
67827: PPUSH
67828: LD_EXP 74
67832: PUSH
67833: LD_VAR 0 2
67837: ARRAY
67838: PUSH
67839: LD_VAR 0 3
67843: ARRAY
67844: PUSH
67845: LD_INT 2
67847: ARRAY
67848: PPUSH
67849: LD_EXP 74
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: PUSH
67860: LD_VAR 0 3
67864: ARRAY
67865: PUSH
67866: LD_INT 3
67868: ARRAY
67869: PPUSH
67870: LD_INT 30
67872: PPUSH
67873: CALL 21166 0 4
67877: PUSH
67878: LD_INT 4
67880: ARRAY
67881: PUSH
67882: LD_INT 0
67884: EQUAL
67885: IFFALSE 67911
// begin target := mc_crates [ i ] [ j ] ;
67887: LD_ADDR_VAR 0 6
67891: PUSH
67892: LD_EXP 74
67896: PUSH
67897: LD_VAR 0 2
67901: ARRAY
67902: PUSH
67903: LD_VAR 0 3
67907: ARRAY
67908: ST_TO_ADDR
// break ;
67909: GO 67913
// end ; end ;
67911: GO 67652
67913: POP
67914: POP
// if not target then
67915: LD_VAR 0 6
67919: NOT
67920: IFFALSE 67924
// continue ;
67922: GO 67533
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67924: LD_ADDR_VAR 0 7
67928: PUSH
67929: LD_EXP 77
67933: PUSH
67934: LD_VAR 0 2
67938: ARRAY
67939: PPUSH
67940: LD_INT 2
67942: PUSH
67943: LD_INT 3
67945: PUSH
67946: LD_INT 58
67948: PUSH
67949: EMPTY
67950: LIST
67951: PUSH
67952: EMPTY
67953: LIST
67954: LIST
67955: PUSH
67956: LD_INT 61
67958: PUSH
67959: EMPTY
67960: LIST
67961: PUSH
67962: LD_INT 33
67964: PUSH
67965: LD_INT 5
67967: PUSH
67968: EMPTY
67969: LIST
67970: LIST
67971: PUSH
67972: LD_INT 33
67974: PUSH
67975: LD_INT 3
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: PUSH
67989: LD_INT 2
67991: PUSH
67992: LD_INT 34
67994: PUSH
67995: LD_INT 32
67997: PUSH
67998: EMPTY
67999: LIST
68000: LIST
68001: PUSH
68002: LD_INT 34
68004: PUSH
68005: LD_INT 51
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 34
68014: PUSH
68015: LD_INT 12
68017: PUSH
68018: EMPTY
68019: LIST
68020: LIST
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: LIST
68026: LIST
68027: PUSH
68028: EMPTY
68029: LIST
68030: LIST
68031: PPUSH
68032: CALL_OW 72
68036: ST_TO_ADDR
// if not cargo then
68037: LD_VAR 0 7
68041: NOT
68042: IFFALSE 68685
// begin if mc_crates_collector [ i ] < 5 then
68044: LD_EXP 75
68048: PUSH
68049: LD_VAR 0 2
68053: ARRAY
68054: PUSH
68055: LD_INT 5
68057: LESS
68058: IFFALSE 68424
// begin if mc_ape [ i ] then
68060: LD_EXP 87
68064: PUSH
68065: LD_VAR 0 2
68069: ARRAY
68070: IFFALSE 68117
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68072: LD_ADDR_VAR 0 5
68076: PUSH
68077: LD_EXP 87
68081: PUSH
68082: LD_VAR 0 2
68086: ARRAY
68087: PPUSH
68088: LD_INT 25
68090: PUSH
68091: LD_INT 16
68093: PUSH
68094: EMPTY
68095: LIST
68096: LIST
68097: PUSH
68098: LD_INT 24
68100: PUSH
68101: LD_INT 750
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: PPUSH
68112: CALL_OW 72
68116: ST_TO_ADDR
// if not tmp then
68117: LD_VAR 0 5
68121: NOT
68122: IFFALSE 68169
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68124: LD_ADDR_VAR 0 5
68128: PUSH
68129: LD_EXP 58
68133: PUSH
68134: LD_VAR 0 2
68138: ARRAY
68139: PPUSH
68140: LD_INT 25
68142: PUSH
68143: LD_INT 2
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: LD_INT 24
68152: PUSH
68153: LD_INT 750
68155: PUSH
68156: EMPTY
68157: LIST
68158: LIST
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: PPUSH
68164: CALL_OW 72
68168: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68169: LD_EXP 87
68173: PUSH
68174: LD_VAR 0 2
68178: ARRAY
68179: PUSH
68180: LD_EXP 58
68184: PUSH
68185: LD_VAR 0 2
68189: ARRAY
68190: PPUSH
68191: LD_INT 25
68193: PUSH
68194: LD_INT 2
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 24
68203: PUSH
68204: LD_INT 750
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: PPUSH
68215: CALL_OW 72
68219: AND
68220: PUSH
68221: LD_VAR 0 5
68225: PUSH
68226: LD_INT 5
68228: LESS
68229: AND
68230: IFFALSE 68312
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68232: LD_ADDR_VAR 0 3
68236: PUSH
68237: LD_EXP 58
68241: PUSH
68242: LD_VAR 0 2
68246: ARRAY
68247: PPUSH
68248: LD_INT 25
68250: PUSH
68251: LD_INT 2
68253: PUSH
68254: EMPTY
68255: LIST
68256: LIST
68257: PUSH
68258: LD_INT 24
68260: PUSH
68261: LD_INT 750
68263: PUSH
68264: EMPTY
68265: LIST
68266: LIST
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PPUSH
68272: CALL_OW 72
68276: PUSH
68277: FOR_IN
68278: IFFALSE 68310
// begin tmp := tmp union j ;
68280: LD_ADDR_VAR 0 5
68284: PUSH
68285: LD_VAR 0 5
68289: PUSH
68290: LD_VAR 0 3
68294: UNION
68295: ST_TO_ADDR
// if tmp >= 5 then
68296: LD_VAR 0 5
68300: PUSH
68301: LD_INT 5
68303: GREATEREQUAL
68304: IFFALSE 68308
// break ;
68306: GO 68310
// end ;
68308: GO 68277
68310: POP
68311: POP
// end ; if not tmp then
68312: LD_VAR 0 5
68316: NOT
68317: IFFALSE 68321
// continue ;
68319: GO 67533
// for j in tmp do
68321: LD_ADDR_VAR 0 3
68325: PUSH
68326: LD_VAR 0 5
68330: PUSH
68331: FOR_IN
68332: IFFALSE 68422
// if not GetTag ( j ) then
68334: LD_VAR 0 3
68338: PPUSH
68339: CALL_OW 110
68343: NOT
68344: IFFALSE 68420
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68346: LD_ADDR_EXP 75
68350: PUSH
68351: LD_EXP 75
68355: PPUSH
68356: LD_VAR 0 2
68360: PUSH
68361: LD_EXP 75
68365: PUSH
68366: LD_VAR 0 2
68370: ARRAY
68371: PUSH
68372: LD_INT 1
68374: PLUS
68375: PUSH
68376: EMPTY
68377: LIST
68378: LIST
68379: PPUSH
68380: LD_VAR 0 3
68384: PPUSH
68385: CALL 20270 0 3
68389: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68390: LD_VAR 0 3
68394: PPUSH
68395: LD_INT 107
68397: PPUSH
68398: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68402: LD_EXP 75
68406: PUSH
68407: LD_VAR 0 2
68411: ARRAY
68412: PUSH
68413: LD_INT 5
68415: GREATEREQUAL
68416: IFFALSE 68420
// break ;
68418: GO 68422
// end ;
68420: GO 68331
68422: POP
68423: POP
// end ; if mc_crates_collector [ i ] and target then
68424: LD_EXP 75
68428: PUSH
68429: LD_VAR 0 2
68433: ARRAY
68434: PUSH
68435: LD_VAR 0 6
68439: AND
68440: IFFALSE 68683
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68442: LD_EXP 75
68446: PUSH
68447: LD_VAR 0 2
68451: ARRAY
68452: PUSH
68453: LD_VAR 0 6
68457: PUSH
68458: LD_INT 1
68460: ARRAY
68461: LESS
68462: IFFALSE 68482
// tmp := mc_crates_collector [ i ] else
68464: LD_ADDR_VAR 0 5
68468: PUSH
68469: LD_EXP 75
68473: PUSH
68474: LD_VAR 0 2
68478: ARRAY
68479: ST_TO_ADDR
68480: GO 68496
// tmp := target [ 1 ] ;
68482: LD_ADDR_VAR 0 5
68486: PUSH
68487: LD_VAR 0 6
68491: PUSH
68492: LD_INT 1
68494: ARRAY
68495: ST_TO_ADDR
// k := 0 ;
68496: LD_ADDR_VAR 0 4
68500: PUSH
68501: LD_INT 0
68503: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68504: LD_ADDR_VAR 0 3
68508: PUSH
68509: LD_EXP 75
68513: PUSH
68514: LD_VAR 0 2
68518: ARRAY
68519: PUSH
68520: FOR_IN
68521: IFFALSE 68681
// begin k := k + 1 ;
68523: LD_ADDR_VAR 0 4
68527: PUSH
68528: LD_VAR 0 4
68532: PUSH
68533: LD_INT 1
68535: PLUS
68536: ST_TO_ADDR
// if k > tmp then
68537: LD_VAR 0 4
68541: PUSH
68542: LD_VAR 0 5
68546: GREATER
68547: IFFALSE 68551
// break ;
68549: GO 68681
// if not GetClass ( j ) in [ 2 , 16 ] then
68551: LD_VAR 0 3
68555: PPUSH
68556: CALL_OW 257
68560: PUSH
68561: LD_INT 2
68563: PUSH
68564: LD_INT 16
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: IN
68571: NOT
68572: IFFALSE 68625
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68574: LD_ADDR_EXP 75
68578: PUSH
68579: LD_EXP 75
68583: PPUSH
68584: LD_VAR 0 2
68588: PPUSH
68589: LD_EXP 75
68593: PUSH
68594: LD_VAR 0 2
68598: ARRAY
68599: PUSH
68600: LD_VAR 0 3
68604: DIFF
68605: PPUSH
68606: CALL_OW 1
68610: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68611: LD_VAR 0 3
68615: PPUSH
68616: LD_INT 0
68618: PPUSH
68619: CALL_OW 109
// continue ;
68623: GO 68520
// end ; if IsInUnit ( j ) then
68625: LD_VAR 0 3
68629: PPUSH
68630: CALL_OW 310
68634: IFFALSE 68645
// ComExitBuilding ( j ) ;
68636: LD_VAR 0 3
68640: PPUSH
68641: CALL_OW 122
// wait ( 3 ) ;
68645: LD_INT 3
68647: PPUSH
68648: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68652: LD_VAR 0 3
68656: PPUSH
68657: LD_VAR 0 6
68661: PUSH
68662: LD_INT 2
68664: ARRAY
68665: PPUSH
68666: LD_VAR 0 6
68670: PUSH
68671: LD_INT 3
68673: ARRAY
68674: PPUSH
68675: CALL_OW 117
// end ;
68679: GO 68520
68681: POP
68682: POP
// end ; end else
68683: GO 69245
// begin for j in cargo do
68685: LD_ADDR_VAR 0 3
68689: PUSH
68690: LD_VAR 0 7
68694: PUSH
68695: FOR_IN
68696: IFFALSE 69243
// begin if GetTag ( j ) <> 0 then
68698: LD_VAR 0 3
68702: PPUSH
68703: CALL_OW 110
68707: PUSH
68708: LD_INT 0
68710: NONEQUAL
68711: IFFALSE 68715
// continue ;
68713: GO 68695
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68715: LD_VAR 0 3
68719: PPUSH
68720: CALL_OW 256
68724: PUSH
68725: LD_INT 1000
68727: LESS
68728: PUSH
68729: LD_VAR 0 3
68733: PPUSH
68734: LD_EXP 82
68738: PUSH
68739: LD_VAR 0 2
68743: ARRAY
68744: PPUSH
68745: CALL_OW 308
68749: NOT
68750: AND
68751: IFFALSE 68773
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68753: LD_VAR 0 3
68757: PPUSH
68758: LD_EXP 82
68762: PUSH
68763: LD_VAR 0 2
68767: ARRAY
68768: PPUSH
68769: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68773: LD_VAR 0 3
68777: PPUSH
68778: CALL_OW 256
68782: PUSH
68783: LD_INT 1000
68785: LESS
68786: PUSH
68787: LD_VAR 0 3
68791: PPUSH
68792: LD_EXP 82
68796: PUSH
68797: LD_VAR 0 2
68801: ARRAY
68802: PPUSH
68803: CALL_OW 308
68807: AND
68808: IFFALSE 68812
// continue ;
68810: GO 68695
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68812: LD_VAR 0 3
68816: PPUSH
68817: CALL_OW 262
68821: PUSH
68822: LD_INT 2
68824: EQUAL
68825: PUSH
68826: LD_VAR 0 3
68830: PPUSH
68831: CALL_OW 261
68835: PUSH
68836: LD_INT 15
68838: LESS
68839: AND
68840: IFFALSE 68844
// continue ;
68842: GO 68695
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68844: LD_VAR 0 3
68848: PPUSH
68849: CALL_OW 262
68853: PUSH
68854: LD_INT 1
68856: EQUAL
68857: PUSH
68858: LD_VAR 0 3
68862: PPUSH
68863: CALL_OW 261
68867: PUSH
68868: LD_INT 10
68870: LESS
68871: AND
68872: IFFALSE 69182
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68874: LD_ADDR_VAR 0 8
68878: PUSH
68879: LD_EXP 58
68883: PUSH
68884: LD_VAR 0 2
68888: ARRAY
68889: PPUSH
68890: LD_INT 2
68892: PUSH
68893: LD_INT 30
68895: PUSH
68896: LD_INT 0
68898: PUSH
68899: EMPTY
68900: LIST
68901: LIST
68902: PUSH
68903: LD_INT 30
68905: PUSH
68906: LD_INT 1
68908: PUSH
68909: EMPTY
68910: LIST
68911: LIST
68912: PUSH
68913: EMPTY
68914: LIST
68915: LIST
68916: LIST
68917: PPUSH
68918: CALL_OW 72
68922: ST_TO_ADDR
// if not depot then
68923: LD_VAR 0 8
68927: NOT
68928: IFFALSE 68932
// continue ;
68930: GO 68695
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68932: LD_VAR 0 3
68936: PPUSH
68937: LD_VAR 0 8
68941: PPUSH
68942: LD_VAR 0 3
68946: PPUSH
68947: CALL_OW 74
68951: PPUSH
68952: CALL_OW 296
68956: PUSH
68957: LD_INT 6
68959: LESS
68960: IFFALSE 68976
// SetFuel ( j , 100 ) else
68962: LD_VAR 0 3
68966: PPUSH
68967: LD_INT 100
68969: PPUSH
68970: CALL_OW 240
68974: GO 69182
// if GetFuel ( j ) = 0 then
68976: LD_VAR 0 3
68980: PPUSH
68981: CALL_OW 261
68985: PUSH
68986: LD_INT 0
68988: EQUAL
68989: IFFALSE 69182
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68991: LD_ADDR_EXP 77
68995: PUSH
68996: LD_EXP 77
69000: PPUSH
69001: LD_VAR 0 2
69005: PPUSH
69006: LD_EXP 77
69010: PUSH
69011: LD_VAR 0 2
69015: ARRAY
69016: PUSH
69017: LD_VAR 0 3
69021: DIFF
69022: PPUSH
69023: CALL_OW 1
69027: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69028: LD_VAR 0 3
69032: PPUSH
69033: CALL_OW 263
69037: PUSH
69038: LD_INT 1
69040: EQUAL
69041: IFFALSE 69057
// ComExitVehicle ( IsInUnit ( j ) ) ;
69043: LD_VAR 0 3
69047: PPUSH
69048: CALL_OW 310
69052: PPUSH
69053: CALL_OW 121
// if GetControl ( j ) = control_remote then
69057: LD_VAR 0 3
69061: PPUSH
69062: CALL_OW 263
69066: PUSH
69067: LD_INT 2
69069: EQUAL
69070: IFFALSE 69081
// ComUnlink ( j ) ;
69072: LD_VAR 0 3
69076: PPUSH
69077: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
69081: LD_ADDR_VAR 0 9
69085: PUSH
69086: LD_VAR 0 2
69090: PPUSH
69091: LD_INT 3
69093: PPUSH
69094: CALL 78344 0 2
69098: ST_TO_ADDR
// if fac then
69099: LD_VAR 0 9
69103: IFFALSE 69180
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69105: LD_ADDR_VAR 0 10
69109: PUSH
69110: LD_VAR 0 9
69114: PPUSH
69115: LD_VAR 0 3
69119: PPUSH
69120: CALL_OW 265
69124: PPUSH
69125: LD_VAR 0 3
69129: PPUSH
69130: CALL_OW 262
69134: PPUSH
69135: LD_VAR 0 3
69139: PPUSH
69140: CALL_OW 263
69144: PPUSH
69145: LD_VAR 0 3
69149: PPUSH
69150: CALL_OW 264
69154: PPUSH
69155: CALL 17870 0 5
69159: ST_TO_ADDR
// if components then
69160: LD_VAR 0 10
69164: IFFALSE 69180
// MC_InsertProduceList ( i , components ) ;
69166: LD_VAR 0 2
69170: PPUSH
69171: LD_VAR 0 10
69175: PPUSH
69176: CALL 77914 0 2
// end ; continue ;
69180: GO 68695
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69182: LD_VAR 0 3
69186: PPUSH
69187: LD_INT 1
69189: PPUSH
69190: CALL_OW 289
69194: PUSH
69195: LD_INT 100
69197: LESS
69198: PUSH
69199: LD_VAR 0 3
69203: PPUSH
69204: CALL_OW 314
69208: NOT
69209: AND
69210: IFFALSE 69239
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69212: LD_VAR 0 3
69216: PPUSH
69217: LD_VAR 0 6
69221: PUSH
69222: LD_INT 2
69224: ARRAY
69225: PPUSH
69226: LD_VAR 0 6
69230: PUSH
69231: LD_INT 3
69233: ARRAY
69234: PPUSH
69235: CALL_OW 117
// break ;
69239: GO 69243
// end ;
69241: GO 68695
69243: POP
69244: POP
// end ; end ;
69245: GO 67533
69247: POP
69248: POP
// end ;
69249: LD_VAR 0 1
69253: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69254: LD_INT 0
69256: PPUSH
69257: PPUSH
69258: PPUSH
69259: PPUSH
// if not mc_bases then
69260: LD_EXP 58
69264: NOT
69265: IFFALSE 69269
// exit ;
69267: GO 69430
// for i = 1 to mc_bases do
69269: LD_ADDR_VAR 0 2
69273: PUSH
69274: DOUBLE
69275: LD_INT 1
69277: DEC
69278: ST_TO_ADDR
69279: LD_EXP 58
69283: PUSH
69284: FOR_TO
69285: IFFALSE 69428
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69287: LD_ADDR_VAR 0 4
69291: PUSH
69292: LD_EXP 77
69296: PUSH
69297: LD_VAR 0 2
69301: ARRAY
69302: PUSH
69303: LD_EXP 80
69307: PUSH
69308: LD_VAR 0 2
69312: ARRAY
69313: UNION
69314: PPUSH
69315: LD_INT 33
69317: PUSH
69318: LD_INT 2
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: PPUSH
69325: CALL_OW 72
69329: ST_TO_ADDR
// if tmp then
69330: LD_VAR 0 4
69334: IFFALSE 69426
// for j in tmp do
69336: LD_ADDR_VAR 0 3
69340: PUSH
69341: LD_VAR 0 4
69345: PUSH
69346: FOR_IN
69347: IFFALSE 69424
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69349: LD_VAR 0 3
69353: PPUSH
69354: CALL_OW 312
69358: NOT
69359: PUSH
69360: LD_VAR 0 3
69364: PPUSH
69365: CALL_OW 256
69369: PUSH
69370: LD_INT 250
69372: GREATEREQUAL
69373: AND
69374: IFFALSE 69387
// Connect ( j ) else
69376: LD_VAR 0 3
69380: PPUSH
69381: CALL 23203 0 1
69385: GO 69422
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69387: LD_VAR 0 3
69391: PPUSH
69392: CALL_OW 256
69396: PUSH
69397: LD_INT 250
69399: LESS
69400: PUSH
69401: LD_VAR 0 3
69405: PPUSH
69406: CALL_OW 312
69410: AND
69411: IFFALSE 69422
// ComUnlink ( j ) ;
69413: LD_VAR 0 3
69417: PPUSH
69418: CALL_OW 136
69422: GO 69346
69424: POP
69425: POP
// end ;
69426: GO 69284
69428: POP
69429: POP
// end ;
69430: LD_VAR 0 1
69434: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69435: LD_INT 0
69437: PPUSH
69438: PPUSH
69439: PPUSH
69440: PPUSH
69441: PPUSH
// if not mc_bases then
69442: LD_EXP 58
69446: NOT
69447: IFFALSE 69451
// exit ;
69449: GO 69911
// for i = 1 to mc_bases do
69451: LD_ADDR_VAR 0 2
69455: PUSH
69456: DOUBLE
69457: LD_INT 1
69459: DEC
69460: ST_TO_ADDR
69461: LD_EXP 58
69465: PUSH
69466: FOR_TO
69467: IFFALSE 69909
// begin if not mc_produce [ i ] then
69469: LD_EXP 79
69473: PUSH
69474: LD_VAR 0 2
69478: ARRAY
69479: NOT
69480: IFFALSE 69484
// continue ;
69482: GO 69466
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69484: LD_ADDR_VAR 0 5
69488: PUSH
69489: LD_EXP 58
69493: PUSH
69494: LD_VAR 0 2
69498: ARRAY
69499: PPUSH
69500: LD_INT 30
69502: PUSH
69503: LD_INT 3
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PPUSH
69510: CALL_OW 72
69514: ST_TO_ADDR
// if not fac then
69515: LD_VAR 0 5
69519: NOT
69520: IFFALSE 69524
// continue ;
69522: GO 69466
// for j in fac do
69524: LD_ADDR_VAR 0 3
69528: PUSH
69529: LD_VAR 0 5
69533: PUSH
69534: FOR_IN
69535: IFFALSE 69905
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
69537: LD_VAR 0 3
69541: PPUSH
69542: CALL_OW 461
69546: PUSH
69547: LD_INT 2
69549: NONEQUAL
69550: PUSH
69551: LD_VAR 0 3
69555: PPUSH
69556: LD_INT 15
69558: PPUSH
69559: CALL 22863 0 2
69563: PUSH
69564: LD_INT 4
69566: ARRAY
69567: OR
69568: PUSH
69569: LD_VAR 0 3
69573: PPUSH
69574: CALL_OW 313
69578: PUSH
69579: LD_INT 0
69581: EQUAL
69582: OR
69583: IFFALSE 69587
// continue ;
69585: GO 69534
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69587: LD_VAR 0 3
69591: PPUSH
69592: LD_EXP 79
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: LD_INT 1
69605: ARRAY
69606: PUSH
69607: LD_INT 1
69609: ARRAY
69610: PPUSH
69611: LD_EXP 79
69615: PUSH
69616: LD_VAR 0 2
69620: ARRAY
69621: PUSH
69622: LD_INT 1
69624: ARRAY
69625: PUSH
69626: LD_INT 2
69628: ARRAY
69629: PPUSH
69630: LD_EXP 79
69634: PUSH
69635: LD_VAR 0 2
69639: ARRAY
69640: PUSH
69641: LD_INT 1
69643: ARRAY
69644: PUSH
69645: LD_INT 3
69647: ARRAY
69648: PPUSH
69649: LD_EXP 79
69653: PUSH
69654: LD_VAR 0 2
69658: ARRAY
69659: PUSH
69660: LD_INT 1
69662: ARRAY
69663: PUSH
69664: LD_INT 4
69666: ARRAY
69667: PPUSH
69668: CALL_OW 448
69672: PUSH
69673: LD_VAR 0 3
69677: PPUSH
69678: LD_EXP 79
69682: PUSH
69683: LD_VAR 0 2
69687: ARRAY
69688: PUSH
69689: LD_INT 1
69691: ARRAY
69692: PUSH
69693: LD_INT 1
69695: ARRAY
69696: PUSH
69697: LD_EXP 79
69701: PUSH
69702: LD_VAR 0 2
69706: ARRAY
69707: PUSH
69708: LD_INT 1
69710: ARRAY
69711: PUSH
69712: LD_INT 2
69714: ARRAY
69715: PUSH
69716: LD_EXP 79
69720: PUSH
69721: LD_VAR 0 2
69725: ARRAY
69726: PUSH
69727: LD_INT 1
69729: ARRAY
69730: PUSH
69731: LD_INT 3
69733: ARRAY
69734: PUSH
69735: LD_EXP 79
69739: PUSH
69740: LD_VAR 0 2
69744: ARRAY
69745: PUSH
69746: LD_INT 1
69748: ARRAY
69749: PUSH
69750: LD_INT 4
69752: ARRAY
69753: PUSH
69754: EMPTY
69755: LIST
69756: LIST
69757: LIST
69758: LIST
69759: PPUSH
69760: CALL 26534 0 2
69764: AND
69765: IFFALSE 69903
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69767: LD_VAR 0 3
69771: PPUSH
69772: LD_EXP 79
69776: PUSH
69777: LD_VAR 0 2
69781: ARRAY
69782: PUSH
69783: LD_INT 1
69785: ARRAY
69786: PUSH
69787: LD_INT 1
69789: ARRAY
69790: PPUSH
69791: LD_EXP 79
69795: PUSH
69796: LD_VAR 0 2
69800: ARRAY
69801: PUSH
69802: LD_INT 1
69804: ARRAY
69805: PUSH
69806: LD_INT 2
69808: ARRAY
69809: PPUSH
69810: LD_EXP 79
69814: PUSH
69815: LD_VAR 0 2
69819: ARRAY
69820: PUSH
69821: LD_INT 1
69823: ARRAY
69824: PUSH
69825: LD_INT 3
69827: ARRAY
69828: PPUSH
69829: LD_EXP 79
69833: PUSH
69834: LD_VAR 0 2
69838: ARRAY
69839: PUSH
69840: LD_INT 1
69842: ARRAY
69843: PUSH
69844: LD_INT 4
69846: ARRAY
69847: PPUSH
69848: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69852: LD_ADDR_VAR 0 4
69856: PUSH
69857: LD_EXP 79
69861: PUSH
69862: LD_VAR 0 2
69866: ARRAY
69867: PPUSH
69868: LD_INT 1
69870: PPUSH
69871: CALL_OW 3
69875: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69876: LD_ADDR_EXP 79
69880: PUSH
69881: LD_EXP 79
69885: PPUSH
69886: LD_VAR 0 2
69890: PPUSH
69891: LD_VAR 0 4
69895: PPUSH
69896: CALL_OW 1
69900: ST_TO_ADDR
// break ;
69901: GO 69905
// end ; end ;
69903: GO 69534
69905: POP
69906: POP
// end ;
69907: GO 69466
69909: POP
69910: POP
// end ;
69911: LD_VAR 0 1
69915: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69916: LD_INT 0
69918: PPUSH
69919: PPUSH
69920: PPUSH
// if not mc_bases then
69921: LD_EXP 58
69925: NOT
69926: IFFALSE 69930
// exit ;
69928: GO 70019
// for i = 1 to mc_bases do
69930: LD_ADDR_VAR 0 2
69934: PUSH
69935: DOUBLE
69936: LD_INT 1
69938: DEC
69939: ST_TO_ADDR
69940: LD_EXP 58
69944: PUSH
69945: FOR_TO
69946: IFFALSE 70017
// begin if mc_attack [ i ] then
69948: LD_EXP 78
69952: PUSH
69953: LD_VAR 0 2
69957: ARRAY
69958: IFFALSE 70015
// begin tmp := mc_attack [ i ] [ 1 ] ;
69960: LD_ADDR_VAR 0 3
69964: PUSH
69965: LD_EXP 78
69969: PUSH
69970: LD_VAR 0 2
69974: ARRAY
69975: PUSH
69976: LD_INT 1
69978: ARRAY
69979: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69980: LD_ADDR_EXP 78
69984: PUSH
69985: LD_EXP 78
69989: PPUSH
69990: LD_VAR 0 2
69994: PPUSH
69995: EMPTY
69996: PPUSH
69997: CALL_OW 1
70001: ST_TO_ADDR
// Attack ( tmp ) ;
70002: LD_VAR 0 3
70006: PPUSH
70007: CALL 48723 0 1
// exit ;
70011: POP
70012: POP
70013: GO 70019
// end ; end ;
70015: GO 69945
70017: POP
70018: POP
// end ;
70019: LD_VAR 0 1
70023: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70024: LD_INT 0
70026: PPUSH
70027: PPUSH
70028: PPUSH
70029: PPUSH
70030: PPUSH
70031: PPUSH
70032: PPUSH
// if not mc_bases then
70033: LD_EXP 58
70037: NOT
70038: IFFALSE 70042
// exit ;
70040: GO 70646
// for i = 1 to mc_bases do
70042: LD_ADDR_VAR 0 2
70046: PUSH
70047: DOUBLE
70048: LD_INT 1
70050: DEC
70051: ST_TO_ADDR
70052: LD_EXP 58
70056: PUSH
70057: FOR_TO
70058: IFFALSE 70644
// begin if not mc_bases [ i ] then
70060: LD_EXP 58
70064: PUSH
70065: LD_VAR 0 2
70069: ARRAY
70070: NOT
70071: IFFALSE 70075
// continue ;
70073: GO 70057
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70075: LD_ADDR_VAR 0 7
70079: PUSH
70080: LD_EXP 58
70084: PUSH
70085: LD_VAR 0 2
70089: ARRAY
70090: PUSH
70091: LD_INT 1
70093: ARRAY
70094: PPUSH
70095: CALL 17174 0 1
70099: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70100: LD_ADDR_EXP 81
70104: PUSH
70105: LD_EXP 81
70109: PPUSH
70110: LD_VAR 0 2
70114: PPUSH
70115: LD_EXP 58
70119: PUSH
70120: LD_VAR 0 2
70124: ARRAY
70125: PUSH
70126: LD_INT 1
70128: ARRAY
70129: PPUSH
70130: CALL_OW 255
70134: PPUSH
70135: LD_EXP 83
70139: PUSH
70140: LD_VAR 0 2
70144: ARRAY
70145: PPUSH
70146: CALL 15134 0 2
70150: PPUSH
70151: CALL_OW 1
70155: ST_TO_ADDR
// if not mc_scan [ i ] then
70156: LD_EXP 81
70160: PUSH
70161: LD_VAR 0 2
70165: ARRAY
70166: NOT
70167: IFFALSE 70322
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70169: LD_ADDR_VAR 0 4
70173: PUSH
70174: LD_EXP 58
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PPUSH
70185: LD_INT 2
70187: PUSH
70188: LD_INT 25
70190: PUSH
70191: LD_INT 5
70193: PUSH
70194: EMPTY
70195: LIST
70196: LIST
70197: PUSH
70198: LD_INT 25
70200: PUSH
70201: LD_INT 8
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 25
70210: PUSH
70211: LD_INT 9
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: LIST
70222: LIST
70223: PPUSH
70224: CALL_OW 72
70228: ST_TO_ADDR
// if not tmp then
70229: LD_VAR 0 4
70233: NOT
70234: IFFALSE 70238
// continue ;
70236: GO 70057
// for j in tmp do
70238: LD_ADDR_VAR 0 3
70242: PUSH
70243: LD_VAR 0 4
70247: PUSH
70248: FOR_IN
70249: IFFALSE 70320
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70251: LD_VAR 0 3
70255: PPUSH
70256: CALL_OW 310
70260: PPUSH
70261: CALL_OW 266
70265: PUSH
70266: LD_INT 5
70268: EQUAL
70269: PUSH
70270: LD_VAR 0 3
70274: PPUSH
70275: CALL_OW 257
70279: PUSH
70280: LD_INT 1
70282: EQUAL
70283: AND
70284: PUSH
70285: LD_VAR 0 3
70289: PPUSH
70290: CALL_OW 459
70294: NOT
70295: AND
70296: PUSH
70297: LD_VAR 0 7
70301: AND
70302: IFFALSE 70318
// ComChangeProfession ( j , class ) ;
70304: LD_VAR 0 3
70308: PPUSH
70309: LD_VAR 0 7
70313: PPUSH
70314: CALL_OW 123
70318: GO 70248
70320: POP
70321: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70322: LD_EXP 81
70326: PUSH
70327: LD_VAR 0 2
70331: ARRAY
70332: PUSH
70333: LD_EXP 80
70337: PUSH
70338: LD_VAR 0 2
70342: ARRAY
70343: NOT
70344: AND
70345: PUSH
70346: LD_EXP 58
70350: PUSH
70351: LD_VAR 0 2
70355: ARRAY
70356: PPUSH
70357: LD_INT 30
70359: PUSH
70360: LD_INT 32
70362: PUSH
70363: EMPTY
70364: LIST
70365: LIST
70366: PPUSH
70367: CALL_OW 72
70371: NOT
70372: AND
70373: PUSH
70374: LD_EXP 58
70378: PUSH
70379: LD_VAR 0 2
70383: ARRAY
70384: PPUSH
70385: LD_INT 2
70387: PUSH
70388: LD_INT 30
70390: PUSH
70391: LD_INT 4
70393: PUSH
70394: EMPTY
70395: LIST
70396: LIST
70397: PUSH
70398: LD_INT 30
70400: PUSH
70401: LD_INT 5
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: EMPTY
70409: LIST
70410: LIST
70411: LIST
70412: PPUSH
70413: CALL_OW 72
70417: NOT
70418: AND
70419: IFFALSE 70551
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70421: LD_ADDR_VAR 0 4
70425: PUSH
70426: LD_EXP 58
70430: PUSH
70431: LD_VAR 0 2
70435: ARRAY
70436: PPUSH
70437: LD_INT 2
70439: PUSH
70440: LD_INT 25
70442: PUSH
70443: LD_INT 1
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: LD_INT 25
70452: PUSH
70453: LD_INT 5
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 25
70462: PUSH
70463: LD_INT 8
70465: PUSH
70466: EMPTY
70467: LIST
70468: LIST
70469: PUSH
70470: LD_INT 25
70472: PUSH
70473: LD_INT 9
70475: PUSH
70476: EMPTY
70477: LIST
70478: LIST
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: PPUSH
70487: CALL_OW 72
70491: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70492: LD_ADDR_VAR 0 4
70496: PUSH
70497: LD_VAR 0 4
70501: PUSH
70502: LD_VAR 0 4
70506: PPUSH
70507: LD_INT 18
70509: PPUSH
70510: CALL 53467 0 2
70514: DIFF
70515: ST_TO_ADDR
// if tmp then
70516: LD_VAR 0 4
70520: IFFALSE 70551
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70522: LD_VAR 0 2
70526: PPUSH
70527: LD_VAR 0 4
70531: PPUSH
70532: LD_EXP 83
70536: PUSH
70537: LD_VAR 0 2
70541: ARRAY
70542: PPUSH
70543: CALL 15169 0 3
// exit ;
70547: POP
70548: POP
70549: GO 70646
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70551: LD_EXP 81
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: PUSH
70562: LD_EXP 80
70566: PUSH
70567: LD_VAR 0 2
70571: ARRAY
70572: AND
70573: IFFALSE 70642
// begin tmp := mc_defender [ i ] ;
70575: LD_ADDR_VAR 0 4
70579: PUSH
70580: LD_EXP 80
70584: PUSH
70585: LD_VAR 0 2
70589: ARRAY
70590: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70591: LD_ADDR_EXP 80
70595: PUSH
70596: LD_EXP 80
70600: PPUSH
70601: LD_VAR 0 2
70605: PPUSH
70606: EMPTY
70607: PPUSH
70608: CALL_OW 1
70612: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70613: LD_VAR 0 2
70617: PPUSH
70618: LD_VAR 0 4
70622: PPUSH
70623: LD_EXP 81
70627: PUSH
70628: LD_VAR 0 2
70632: ARRAY
70633: PPUSH
70634: CALL 15667 0 3
// exit ;
70638: POP
70639: POP
70640: GO 70646
// end ; end ;
70642: GO 70057
70644: POP
70645: POP
// end ;
70646: LD_VAR 0 1
70650: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70651: LD_INT 0
70653: PPUSH
70654: PPUSH
70655: PPUSH
70656: PPUSH
70657: PPUSH
70658: PPUSH
70659: PPUSH
70660: PPUSH
70661: PPUSH
70662: PPUSH
70663: PPUSH
// if not mc_bases then
70664: LD_EXP 58
70668: NOT
70669: IFFALSE 70673
// exit ;
70671: GO 71760
// for i = 1 to mc_bases do
70673: LD_ADDR_VAR 0 2
70677: PUSH
70678: DOUBLE
70679: LD_INT 1
70681: DEC
70682: ST_TO_ADDR
70683: LD_EXP 58
70687: PUSH
70688: FOR_TO
70689: IFFALSE 71758
// begin tmp := mc_lab [ i ] ;
70691: LD_ADDR_VAR 0 6
70695: PUSH
70696: LD_EXP 91
70700: PUSH
70701: LD_VAR 0 2
70705: ARRAY
70706: ST_TO_ADDR
// if not tmp then
70707: LD_VAR 0 6
70711: NOT
70712: IFFALSE 70716
// continue ;
70714: GO 70688
// idle_lab := 0 ;
70716: LD_ADDR_VAR 0 11
70720: PUSH
70721: LD_INT 0
70723: ST_TO_ADDR
// for j in tmp do
70724: LD_ADDR_VAR 0 3
70728: PUSH
70729: LD_VAR 0 6
70733: PUSH
70734: FOR_IN
70735: IFFALSE 71754
// begin researching := false ;
70737: LD_ADDR_VAR 0 10
70741: PUSH
70742: LD_INT 0
70744: ST_TO_ADDR
// side := GetSide ( j ) ;
70745: LD_ADDR_VAR 0 4
70749: PUSH
70750: LD_VAR 0 3
70754: PPUSH
70755: CALL_OW 255
70759: ST_TO_ADDR
// if not mc_tech [ side ] then
70760: LD_EXP 85
70764: PUSH
70765: LD_VAR 0 4
70769: ARRAY
70770: NOT
70771: IFFALSE 70775
// continue ;
70773: GO 70734
// if BuildingStatus ( j ) = bs_idle then
70775: LD_VAR 0 3
70779: PPUSH
70780: CALL_OW 461
70784: PUSH
70785: LD_INT 2
70787: EQUAL
70788: IFFALSE 70976
// begin if idle_lab and UnitsInside ( j ) < 6 then
70790: LD_VAR 0 11
70794: PUSH
70795: LD_VAR 0 3
70799: PPUSH
70800: CALL_OW 313
70804: PUSH
70805: LD_INT 6
70807: LESS
70808: AND
70809: IFFALSE 70880
// begin tmp2 := UnitsInside ( idle_lab ) ;
70811: LD_ADDR_VAR 0 9
70815: PUSH
70816: LD_VAR 0 11
70820: PPUSH
70821: CALL_OW 313
70825: ST_TO_ADDR
// if tmp2 then
70826: LD_VAR 0 9
70830: IFFALSE 70872
// for x in tmp2 do
70832: LD_ADDR_VAR 0 7
70836: PUSH
70837: LD_VAR 0 9
70841: PUSH
70842: FOR_IN
70843: IFFALSE 70870
// begin ComExitBuilding ( x ) ;
70845: LD_VAR 0 7
70849: PPUSH
70850: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70854: LD_VAR 0 7
70858: PPUSH
70859: LD_VAR 0 3
70863: PPUSH
70864: CALL_OW 180
// end ;
70868: GO 70842
70870: POP
70871: POP
// idle_lab := 0 ;
70872: LD_ADDR_VAR 0 11
70876: PUSH
70877: LD_INT 0
70879: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70880: LD_ADDR_VAR 0 5
70884: PUSH
70885: LD_EXP 85
70889: PUSH
70890: LD_VAR 0 4
70894: ARRAY
70895: PUSH
70896: FOR_IN
70897: IFFALSE 70957
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70899: LD_VAR 0 3
70903: PPUSH
70904: LD_VAR 0 5
70908: PPUSH
70909: CALL_OW 430
70913: PUSH
70914: LD_VAR 0 4
70918: PPUSH
70919: LD_VAR 0 5
70923: PPUSH
70924: CALL 14239 0 2
70928: AND
70929: IFFALSE 70955
// begin researching := true ;
70931: LD_ADDR_VAR 0 10
70935: PUSH
70936: LD_INT 1
70938: ST_TO_ADDR
// ComResearch ( j , t ) ;
70939: LD_VAR 0 3
70943: PPUSH
70944: LD_VAR 0 5
70948: PPUSH
70949: CALL_OW 124
// break ;
70953: GO 70957
// end ;
70955: GO 70896
70957: POP
70958: POP
// if not researching then
70959: LD_VAR 0 10
70963: NOT
70964: IFFALSE 70976
// idle_lab := j ;
70966: LD_ADDR_VAR 0 11
70970: PUSH
70971: LD_VAR 0 3
70975: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70976: LD_VAR 0 3
70980: PPUSH
70981: CALL_OW 461
70985: PUSH
70986: LD_INT 10
70988: EQUAL
70989: IFFALSE 71577
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70991: LD_EXP 87
70995: PUSH
70996: LD_VAR 0 2
71000: ARRAY
71001: NOT
71002: PUSH
71003: LD_EXP 88
71007: PUSH
71008: LD_VAR 0 2
71012: ARRAY
71013: NOT
71014: AND
71015: PUSH
71016: LD_EXP 85
71020: PUSH
71021: LD_VAR 0 4
71025: ARRAY
71026: PUSH
71027: LD_INT 1
71029: GREATER
71030: AND
71031: IFFALSE 71162
// begin ComCancel ( j ) ;
71033: LD_VAR 0 3
71037: PPUSH
71038: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71042: LD_ADDR_EXP 85
71046: PUSH
71047: LD_EXP 85
71051: PPUSH
71052: LD_VAR 0 4
71056: PPUSH
71057: LD_EXP 85
71061: PUSH
71062: LD_VAR 0 4
71066: ARRAY
71067: PPUSH
71068: LD_EXP 85
71072: PUSH
71073: LD_VAR 0 4
71077: ARRAY
71078: PUSH
71079: LD_INT 1
71081: MINUS
71082: PPUSH
71083: LD_EXP 85
71087: PUSH
71088: LD_VAR 0 4
71092: ARRAY
71093: PPUSH
71094: LD_INT 0
71096: PPUSH
71097: CALL 19688 0 4
71101: PPUSH
71102: CALL_OW 1
71106: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71107: LD_ADDR_EXP 85
71111: PUSH
71112: LD_EXP 85
71116: PPUSH
71117: LD_VAR 0 4
71121: PPUSH
71122: LD_EXP 85
71126: PUSH
71127: LD_VAR 0 4
71131: ARRAY
71132: PPUSH
71133: LD_EXP 85
71137: PUSH
71138: LD_VAR 0 4
71142: ARRAY
71143: PPUSH
71144: LD_INT 1
71146: PPUSH
71147: LD_INT 0
71149: PPUSH
71150: CALL 19688 0 4
71154: PPUSH
71155: CALL_OW 1
71159: ST_TO_ADDR
// continue ;
71160: GO 70734
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71162: LD_EXP 87
71166: PUSH
71167: LD_VAR 0 2
71171: ARRAY
71172: PUSH
71173: LD_EXP 88
71177: PUSH
71178: LD_VAR 0 2
71182: ARRAY
71183: NOT
71184: AND
71185: IFFALSE 71312
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71187: LD_ADDR_EXP 88
71191: PUSH
71192: LD_EXP 88
71196: PPUSH
71197: LD_VAR 0 2
71201: PUSH
71202: LD_EXP 88
71206: PUSH
71207: LD_VAR 0 2
71211: ARRAY
71212: PUSH
71213: LD_INT 1
71215: PLUS
71216: PUSH
71217: EMPTY
71218: LIST
71219: LIST
71220: PPUSH
71221: LD_EXP 87
71225: PUSH
71226: LD_VAR 0 2
71230: ARRAY
71231: PUSH
71232: LD_INT 1
71234: ARRAY
71235: PPUSH
71236: CALL 20270 0 3
71240: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71241: LD_EXP 87
71245: PUSH
71246: LD_VAR 0 2
71250: ARRAY
71251: PUSH
71252: LD_INT 1
71254: ARRAY
71255: PPUSH
71256: LD_INT 112
71258: PPUSH
71259: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71263: LD_ADDR_VAR 0 9
71267: PUSH
71268: LD_EXP 87
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PPUSH
71279: LD_INT 1
71281: PPUSH
71282: CALL_OW 3
71286: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71287: LD_ADDR_EXP 87
71291: PUSH
71292: LD_EXP 87
71296: PPUSH
71297: LD_VAR 0 2
71301: PPUSH
71302: LD_VAR 0 9
71306: PPUSH
71307: CALL_OW 1
71311: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71312: LD_EXP 87
71316: PUSH
71317: LD_VAR 0 2
71321: ARRAY
71322: PUSH
71323: LD_EXP 88
71327: PUSH
71328: LD_VAR 0 2
71332: ARRAY
71333: AND
71334: PUSH
71335: LD_EXP 88
71339: PUSH
71340: LD_VAR 0 2
71344: ARRAY
71345: PUSH
71346: LD_INT 1
71348: ARRAY
71349: PPUSH
71350: CALL_OW 310
71354: NOT
71355: AND
71356: PUSH
71357: LD_VAR 0 3
71361: PPUSH
71362: CALL_OW 313
71366: PUSH
71367: LD_INT 6
71369: EQUAL
71370: AND
71371: IFFALSE 71427
// begin tmp2 := UnitsInside ( j ) ;
71373: LD_ADDR_VAR 0 9
71377: PUSH
71378: LD_VAR 0 3
71382: PPUSH
71383: CALL_OW 313
71387: ST_TO_ADDR
// if tmp2 = 6 then
71388: LD_VAR 0 9
71392: PUSH
71393: LD_INT 6
71395: EQUAL
71396: IFFALSE 71427
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71398: LD_VAR 0 9
71402: PUSH
71403: LD_INT 1
71405: ARRAY
71406: PPUSH
71407: LD_INT 112
71409: PPUSH
71410: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71414: LD_VAR 0 9
71418: PUSH
71419: LD_INT 1
71421: ARRAY
71422: PPUSH
71423: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71427: LD_EXP 88
71431: PUSH
71432: LD_VAR 0 2
71436: ARRAY
71437: PUSH
71438: LD_EXP 88
71442: PUSH
71443: LD_VAR 0 2
71447: ARRAY
71448: PUSH
71449: LD_INT 1
71451: ARRAY
71452: PPUSH
71453: CALL_OW 314
71457: NOT
71458: AND
71459: PUSH
71460: LD_EXP 88
71464: PUSH
71465: LD_VAR 0 2
71469: ARRAY
71470: PUSH
71471: LD_INT 1
71473: ARRAY
71474: PPUSH
71475: CALL_OW 310
71479: NOT
71480: AND
71481: IFFALSE 71507
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71483: LD_EXP 88
71487: PUSH
71488: LD_VAR 0 2
71492: ARRAY
71493: PUSH
71494: LD_INT 1
71496: ARRAY
71497: PPUSH
71498: LD_VAR 0 3
71502: PPUSH
71503: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71507: LD_EXP 88
71511: PUSH
71512: LD_VAR 0 2
71516: ARRAY
71517: PUSH
71518: LD_INT 1
71520: ARRAY
71521: PPUSH
71522: CALL_OW 310
71526: PUSH
71527: LD_EXP 88
71531: PUSH
71532: LD_VAR 0 2
71536: ARRAY
71537: PUSH
71538: LD_INT 1
71540: ARRAY
71541: PPUSH
71542: CALL_OW 310
71546: PPUSH
71547: CALL_OW 461
71551: PUSH
71552: LD_INT 3
71554: NONEQUAL
71555: AND
71556: IFFALSE 71577
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71558: LD_EXP 88
71562: PUSH
71563: LD_VAR 0 2
71567: ARRAY
71568: PUSH
71569: LD_INT 1
71571: ARRAY
71572: PPUSH
71573: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71577: LD_VAR 0 3
71581: PPUSH
71582: CALL_OW 461
71586: PUSH
71587: LD_INT 6
71589: EQUAL
71590: PUSH
71591: LD_VAR 0 6
71595: PUSH
71596: LD_INT 1
71598: GREATER
71599: AND
71600: IFFALSE 71752
// begin sci := [ ] ;
71602: LD_ADDR_VAR 0 8
71606: PUSH
71607: EMPTY
71608: ST_TO_ADDR
// for x in ( tmp diff j ) do
71609: LD_ADDR_VAR 0 7
71613: PUSH
71614: LD_VAR 0 6
71618: PUSH
71619: LD_VAR 0 3
71623: DIFF
71624: PUSH
71625: FOR_IN
71626: IFFALSE 71678
// begin if sci = 6 then
71628: LD_VAR 0 8
71632: PUSH
71633: LD_INT 6
71635: EQUAL
71636: IFFALSE 71640
// break ;
71638: GO 71678
// if BuildingStatus ( x ) = bs_idle then
71640: LD_VAR 0 7
71644: PPUSH
71645: CALL_OW 461
71649: PUSH
71650: LD_INT 2
71652: EQUAL
71653: IFFALSE 71676
// sci := sci ^ UnitsInside ( x ) ;
71655: LD_ADDR_VAR 0 8
71659: PUSH
71660: LD_VAR 0 8
71664: PUSH
71665: LD_VAR 0 7
71669: PPUSH
71670: CALL_OW 313
71674: ADD
71675: ST_TO_ADDR
// end ;
71676: GO 71625
71678: POP
71679: POP
// if not sci then
71680: LD_VAR 0 8
71684: NOT
71685: IFFALSE 71689
// continue ;
71687: GO 70734
// for x in sci do
71689: LD_ADDR_VAR 0 7
71693: PUSH
71694: LD_VAR 0 8
71698: PUSH
71699: FOR_IN
71700: IFFALSE 71750
// if IsInUnit ( x ) and not HasTask ( x ) then
71702: LD_VAR 0 7
71706: PPUSH
71707: CALL_OW 310
71711: PUSH
71712: LD_VAR 0 7
71716: PPUSH
71717: CALL_OW 314
71721: NOT
71722: AND
71723: IFFALSE 71748
// begin ComExitBuilding ( x ) ;
71725: LD_VAR 0 7
71729: PPUSH
71730: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71734: LD_VAR 0 7
71738: PPUSH
71739: LD_VAR 0 3
71743: PPUSH
71744: CALL_OW 180
// end ;
71748: GO 71699
71750: POP
71751: POP
// end ; end ;
71752: GO 70734
71754: POP
71755: POP
// end ;
71756: GO 70688
71758: POP
71759: POP
// end ;
71760: LD_VAR 0 1
71764: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71765: LD_INT 0
71767: PPUSH
71768: PPUSH
// if not mc_bases then
71769: LD_EXP 58
71773: NOT
71774: IFFALSE 71778
// exit ;
71776: GO 71859
// for i = 1 to mc_bases do
71778: LD_ADDR_VAR 0 2
71782: PUSH
71783: DOUBLE
71784: LD_INT 1
71786: DEC
71787: ST_TO_ADDR
71788: LD_EXP 58
71792: PUSH
71793: FOR_TO
71794: IFFALSE 71857
// if mc_mines [ i ] and mc_miners [ i ] then
71796: LD_EXP 71
71800: PUSH
71801: LD_VAR 0 2
71805: ARRAY
71806: PUSH
71807: LD_EXP 72
71811: PUSH
71812: LD_VAR 0 2
71816: ARRAY
71817: AND
71818: IFFALSE 71855
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71820: LD_EXP 72
71824: PUSH
71825: LD_VAR 0 2
71829: ARRAY
71830: PUSH
71831: LD_INT 1
71833: ARRAY
71834: PPUSH
71835: CALL_OW 255
71839: PPUSH
71840: LD_EXP 71
71844: PUSH
71845: LD_VAR 0 2
71849: ARRAY
71850: PPUSH
71851: CALL 17327 0 2
71855: GO 71793
71857: POP
71858: POP
// end ;
71859: LD_VAR 0 1
71863: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71864: LD_INT 0
71866: PPUSH
71867: PPUSH
71868: PPUSH
71869: PPUSH
71870: PPUSH
71871: PPUSH
71872: PPUSH
71873: PPUSH
// if not mc_bases or not mc_parking then
71874: LD_EXP 58
71878: NOT
71879: PUSH
71880: LD_EXP 82
71884: NOT
71885: OR
71886: IFFALSE 71890
// exit ;
71888: GO 72602
// for i = 1 to mc_bases do
71890: LD_ADDR_VAR 0 2
71894: PUSH
71895: DOUBLE
71896: LD_INT 1
71898: DEC
71899: ST_TO_ADDR
71900: LD_EXP 58
71904: PUSH
71905: FOR_TO
71906: IFFALSE 72600
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71908: LD_EXP 58
71912: PUSH
71913: LD_VAR 0 2
71917: ARRAY
71918: NOT
71919: PUSH
71920: LD_EXP 82
71924: PUSH
71925: LD_VAR 0 2
71929: ARRAY
71930: NOT
71931: OR
71932: IFFALSE 71936
// continue ;
71934: GO 71905
// if mc_scan [ i ] then
71936: LD_EXP 81
71940: PUSH
71941: LD_VAR 0 2
71945: ARRAY
71946: IFFALSE 71972
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71948: LD_ADDR_EXP 70
71952: PUSH
71953: LD_EXP 70
71957: PPUSH
71958: LD_VAR 0 2
71962: PPUSH
71963: EMPTY
71964: PPUSH
71965: CALL_OW 1
71969: ST_TO_ADDR
// continue ;
71970: GO 71905
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71972: LD_ADDR_VAR 0 5
71976: PUSH
71977: LD_EXP 58
71981: PUSH
71982: LD_VAR 0 2
71986: ARRAY
71987: PUSH
71988: LD_INT 1
71990: ARRAY
71991: PPUSH
71992: CALL_OW 255
71996: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71997: LD_ADDR_VAR 0 6
72001: PUSH
72002: LD_EXP 58
72006: PUSH
72007: LD_VAR 0 2
72011: ARRAY
72012: PPUSH
72013: LD_INT 30
72015: PUSH
72016: LD_INT 3
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PPUSH
72023: CALL_OW 72
72027: ST_TO_ADDR
// if not fac then
72028: LD_VAR 0 6
72032: NOT
72033: IFFALSE 72084
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72035: LD_ADDR_VAR 0 6
72039: PUSH
72040: LD_EXP 58
72044: PUSH
72045: LD_VAR 0 2
72049: ARRAY
72050: PPUSH
72051: LD_INT 2
72053: PUSH
72054: LD_INT 30
72056: PUSH
72057: LD_INT 0
72059: PUSH
72060: EMPTY
72061: LIST
72062: LIST
72063: PUSH
72064: LD_INT 30
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: EMPTY
72071: LIST
72072: LIST
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: LIST
72078: PPUSH
72079: CALL_OW 72
72083: ST_TO_ADDR
// if not fac then
72084: LD_VAR 0 6
72088: NOT
72089: IFFALSE 72093
// continue ;
72091: GO 71905
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72093: LD_ADDR_VAR 0 7
72097: PUSH
72098: LD_EXP 82
72102: PUSH
72103: LD_VAR 0 2
72107: ARRAY
72108: PPUSH
72109: LD_INT 22
72111: PUSH
72112: LD_VAR 0 5
72116: PUSH
72117: EMPTY
72118: LIST
72119: LIST
72120: PUSH
72121: LD_INT 21
72123: PUSH
72124: LD_INT 2
72126: PUSH
72127: EMPTY
72128: LIST
72129: LIST
72130: PUSH
72131: LD_INT 3
72133: PUSH
72134: LD_INT 24
72136: PUSH
72137: LD_INT 1000
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PUSH
72144: EMPTY
72145: LIST
72146: LIST
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: LIST
72152: PPUSH
72153: CALL_OW 70
72157: PUSH
72158: LD_INT 22
72160: PUSH
72161: LD_VAR 0 5
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PUSH
72170: LD_INT 91
72172: PUSH
72173: LD_VAR 0 6
72177: PUSH
72178: LD_INT 1
72180: ARRAY
72181: PUSH
72182: LD_INT 25
72184: PUSH
72185: EMPTY
72186: LIST
72187: LIST
72188: LIST
72189: PUSH
72190: LD_INT 21
72192: PUSH
72193: LD_INT 2
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: PUSH
72200: LD_INT 3
72202: PUSH
72203: LD_INT 24
72205: PUSH
72206: LD_INT 1000
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: EMPTY
72214: LIST
72215: LIST
72216: PUSH
72217: EMPTY
72218: LIST
72219: LIST
72220: LIST
72221: LIST
72222: PPUSH
72223: CALL_OW 69
72227: UNION
72228: ST_TO_ADDR
// if not vehs then
72229: LD_VAR 0 7
72233: NOT
72234: IFFALSE 72260
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72236: LD_ADDR_EXP 70
72240: PUSH
72241: LD_EXP 70
72245: PPUSH
72246: LD_VAR 0 2
72250: PPUSH
72251: EMPTY
72252: PPUSH
72253: CALL_OW 1
72257: ST_TO_ADDR
// continue ;
72258: GO 71905
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72260: LD_ADDR_VAR 0 8
72264: PUSH
72265: LD_EXP 58
72269: PUSH
72270: LD_VAR 0 2
72274: ARRAY
72275: PPUSH
72276: LD_INT 30
72278: PUSH
72279: LD_INT 3
72281: PUSH
72282: EMPTY
72283: LIST
72284: LIST
72285: PPUSH
72286: CALL_OW 72
72290: ST_TO_ADDR
// if tmp then
72291: LD_VAR 0 8
72295: IFFALSE 72398
// begin for j in tmp do
72297: LD_ADDR_VAR 0 3
72301: PUSH
72302: LD_VAR 0 8
72306: PUSH
72307: FOR_IN
72308: IFFALSE 72396
// for k in UnitsInside ( j ) do
72310: LD_ADDR_VAR 0 4
72314: PUSH
72315: LD_VAR 0 3
72319: PPUSH
72320: CALL_OW 313
72324: PUSH
72325: FOR_IN
72326: IFFALSE 72392
// if k then
72328: LD_VAR 0 4
72332: IFFALSE 72390
// if not k in mc_repair_vehicle [ i ] then
72334: LD_VAR 0 4
72338: PUSH
72339: LD_EXP 70
72343: PUSH
72344: LD_VAR 0 2
72348: ARRAY
72349: IN
72350: NOT
72351: IFFALSE 72390
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72353: LD_ADDR_EXP 70
72357: PUSH
72358: LD_EXP 70
72362: PPUSH
72363: LD_VAR 0 2
72367: PPUSH
72368: LD_EXP 70
72372: PUSH
72373: LD_VAR 0 2
72377: ARRAY
72378: PUSH
72379: LD_VAR 0 4
72383: UNION
72384: PPUSH
72385: CALL_OW 1
72389: ST_TO_ADDR
72390: GO 72325
72392: POP
72393: POP
72394: GO 72307
72396: POP
72397: POP
// end ; if not mc_repair_vehicle [ i ] then
72398: LD_EXP 70
72402: PUSH
72403: LD_VAR 0 2
72407: ARRAY
72408: NOT
72409: IFFALSE 72413
// continue ;
72411: GO 71905
// for j in mc_repair_vehicle [ i ] do
72413: LD_ADDR_VAR 0 3
72417: PUSH
72418: LD_EXP 70
72422: PUSH
72423: LD_VAR 0 2
72427: ARRAY
72428: PUSH
72429: FOR_IN
72430: IFFALSE 72596
// begin if GetClass ( j ) <> 3 then
72432: LD_VAR 0 3
72436: PPUSH
72437: CALL_OW 257
72441: PUSH
72442: LD_INT 3
72444: NONEQUAL
72445: IFFALSE 72486
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72447: LD_ADDR_EXP 70
72451: PUSH
72452: LD_EXP 70
72456: PPUSH
72457: LD_VAR 0 2
72461: PPUSH
72462: LD_EXP 70
72466: PUSH
72467: LD_VAR 0 2
72471: ARRAY
72472: PUSH
72473: LD_VAR 0 3
72477: DIFF
72478: PPUSH
72479: CALL_OW 1
72483: ST_TO_ADDR
// continue ;
72484: GO 72429
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72486: LD_VAR 0 3
72490: PPUSH
72491: CALL_OW 311
72495: NOT
72496: PUSH
72497: LD_VAR 0 3
72501: PUSH
72502: LD_EXP 61
72506: PUSH
72507: LD_VAR 0 2
72511: ARRAY
72512: PUSH
72513: LD_INT 1
72515: ARRAY
72516: IN
72517: NOT
72518: AND
72519: PUSH
72520: LD_VAR 0 3
72524: PUSH
72525: LD_EXP 61
72529: PUSH
72530: LD_VAR 0 2
72534: ARRAY
72535: PUSH
72536: LD_INT 2
72538: ARRAY
72539: IN
72540: NOT
72541: AND
72542: IFFALSE 72594
// begin if IsInUnit ( j ) then
72544: LD_VAR 0 3
72548: PPUSH
72549: CALL_OW 310
72553: IFFALSE 72564
// ComExitBuilding ( j ) ;
72555: LD_VAR 0 3
72559: PPUSH
72560: CALL_OW 122
// if not HasTask ( j ) then
72564: LD_VAR 0 3
72568: PPUSH
72569: CALL_OW 314
72573: NOT
72574: IFFALSE 72594
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72576: LD_VAR 0 3
72580: PPUSH
72581: LD_VAR 0 7
72585: PUSH
72586: LD_INT 1
72588: ARRAY
72589: PPUSH
72590: CALL_OW 189
// end ; end ;
72594: GO 72429
72596: POP
72597: POP
// end ;
72598: GO 71905
72600: POP
72601: POP
// end ;
72602: LD_VAR 0 1
72606: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72607: LD_INT 0
72609: PPUSH
72610: PPUSH
72611: PPUSH
72612: PPUSH
72613: PPUSH
72614: PPUSH
72615: PPUSH
72616: PPUSH
72617: PPUSH
72618: PPUSH
72619: PPUSH
// if not mc_bases then
72620: LD_EXP 58
72624: NOT
72625: IFFALSE 72629
// exit ;
72627: GO 73431
// for i = 1 to mc_bases do
72629: LD_ADDR_VAR 0 2
72633: PUSH
72634: DOUBLE
72635: LD_INT 1
72637: DEC
72638: ST_TO_ADDR
72639: LD_EXP 58
72643: PUSH
72644: FOR_TO
72645: IFFALSE 73429
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72647: LD_EXP 86
72651: PUSH
72652: LD_VAR 0 2
72656: ARRAY
72657: NOT
72658: PUSH
72659: LD_EXP 61
72663: PUSH
72664: LD_VAR 0 2
72668: ARRAY
72669: PUSH
72670: LD_INT 1
72672: ARRAY
72673: OR
72674: PUSH
72675: LD_EXP 61
72679: PUSH
72680: LD_VAR 0 2
72684: ARRAY
72685: PUSH
72686: LD_INT 2
72688: ARRAY
72689: OR
72690: PUSH
72691: LD_EXP 84
72695: PUSH
72696: LD_VAR 0 2
72700: ARRAY
72701: PPUSH
72702: LD_INT 1
72704: PPUSH
72705: CALL_OW 325
72709: NOT
72710: OR
72711: PUSH
72712: LD_EXP 81
72716: PUSH
72717: LD_VAR 0 2
72721: ARRAY
72722: OR
72723: IFFALSE 72727
// continue ;
72725: GO 72644
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72727: LD_ADDR_VAR 0 8
72731: PUSH
72732: LD_EXP 58
72736: PUSH
72737: LD_VAR 0 2
72741: ARRAY
72742: PPUSH
72743: LD_INT 25
72745: PUSH
72746: LD_INT 4
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 50
72755: PUSH
72756: EMPTY
72757: LIST
72758: PUSH
72759: LD_INT 3
72761: PUSH
72762: LD_INT 60
72764: PUSH
72765: EMPTY
72766: LIST
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: LIST
72776: PPUSH
72777: CALL_OW 72
72781: PUSH
72782: LD_EXP 62
72786: PUSH
72787: LD_VAR 0 2
72791: ARRAY
72792: DIFF
72793: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72794: LD_ADDR_VAR 0 9
72798: PUSH
72799: LD_EXP 58
72803: PUSH
72804: LD_VAR 0 2
72808: ARRAY
72809: PPUSH
72810: LD_INT 2
72812: PUSH
72813: LD_INT 30
72815: PUSH
72816: LD_INT 0
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 30
72825: PUSH
72826: LD_INT 1
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: LIST
72837: PPUSH
72838: CALL_OW 72
72842: ST_TO_ADDR
// if not tmp or not dep then
72843: LD_VAR 0 8
72847: NOT
72848: PUSH
72849: LD_VAR 0 9
72853: NOT
72854: OR
72855: IFFALSE 72859
// continue ;
72857: GO 72644
// side := GetSide ( tmp [ 1 ] ) ;
72859: LD_ADDR_VAR 0 11
72863: PUSH
72864: LD_VAR 0 8
72868: PUSH
72869: LD_INT 1
72871: ARRAY
72872: PPUSH
72873: CALL_OW 255
72877: ST_TO_ADDR
// dep := dep [ 1 ] ;
72878: LD_ADDR_VAR 0 9
72882: PUSH
72883: LD_VAR 0 9
72887: PUSH
72888: LD_INT 1
72890: ARRAY
72891: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72892: LD_ADDR_VAR 0 7
72896: PUSH
72897: LD_EXP 86
72901: PUSH
72902: LD_VAR 0 2
72906: ARRAY
72907: PPUSH
72908: LD_INT 22
72910: PUSH
72911: LD_INT 0
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 25
72920: PUSH
72921: LD_INT 12
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PPUSH
72932: CALL_OW 70
72936: PUSH
72937: LD_INT 22
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: EMPTY
72944: LIST
72945: LIST
72946: PUSH
72947: LD_INT 25
72949: PUSH
72950: LD_INT 12
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 91
72959: PUSH
72960: LD_VAR 0 9
72964: PUSH
72965: LD_INT 20
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: LIST
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: LIST
72977: PPUSH
72978: CALL_OW 69
72982: UNION
72983: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72984: LD_ADDR_VAR 0 10
72988: PUSH
72989: LD_EXP 86
72993: PUSH
72994: LD_VAR 0 2
72998: ARRAY
72999: PPUSH
73000: LD_INT 81
73002: PUSH
73003: LD_VAR 0 11
73007: PUSH
73008: EMPTY
73009: LIST
73010: LIST
73011: PPUSH
73012: CALL_OW 70
73016: ST_TO_ADDR
// if not apes or danger_at_area then
73017: LD_VAR 0 7
73021: NOT
73022: PUSH
73023: LD_VAR 0 10
73027: OR
73028: IFFALSE 73078
// begin if mc_taming [ i ] then
73030: LD_EXP 89
73034: PUSH
73035: LD_VAR 0 2
73039: ARRAY
73040: IFFALSE 73076
// begin MC_Reset ( i , 121 ) ;
73042: LD_VAR 0 2
73046: PPUSH
73047: LD_INT 121
73049: PPUSH
73050: CALL 59036 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73054: LD_ADDR_EXP 89
73058: PUSH
73059: LD_EXP 89
73063: PPUSH
73064: LD_VAR 0 2
73068: PPUSH
73069: EMPTY
73070: PPUSH
73071: CALL_OW 1
73075: ST_TO_ADDR
// end ; continue ;
73076: GO 72644
// end ; for j in tmp do
73078: LD_ADDR_VAR 0 3
73082: PUSH
73083: LD_VAR 0 8
73087: PUSH
73088: FOR_IN
73089: IFFALSE 73425
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73091: LD_VAR 0 3
73095: PUSH
73096: LD_EXP 89
73100: PUSH
73101: LD_VAR 0 2
73105: ARRAY
73106: IN
73107: NOT
73108: PUSH
73109: LD_EXP 89
73113: PUSH
73114: LD_VAR 0 2
73118: ARRAY
73119: PUSH
73120: LD_INT 3
73122: LESS
73123: AND
73124: IFFALSE 73182
// begin SetTag ( j , 121 ) ;
73126: LD_VAR 0 3
73130: PPUSH
73131: LD_INT 121
73133: PPUSH
73134: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73138: LD_ADDR_EXP 89
73142: PUSH
73143: LD_EXP 89
73147: PPUSH
73148: LD_VAR 0 2
73152: PUSH
73153: LD_EXP 89
73157: PUSH
73158: LD_VAR 0 2
73162: ARRAY
73163: PUSH
73164: LD_INT 1
73166: PLUS
73167: PUSH
73168: EMPTY
73169: LIST
73170: LIST
73171: PPUSH
73172: LD_VAR 0 3
73176: PPUSH
73177: CALL 20270 0 3
73181: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73182: LD_VAR 0 3
73186: PUSH
73187: LD_EXP 89
73191: PUSH
73192: LD_VAR 0 2
73196: ARRAY
73197: IN
73198: IFFALSE 73423
// begin if GetClass ( j ) <> 4 then
73200: LD_VAR 0 3
73204: PPUSH
73205: CALL_OW 257
73209: PUSH
73210: LD_INT 4
73212: NONEQUAL
73213: IFFALSE 73266
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73215: LD_ADDR_EXP 89
73219: PUSH
73220: LD_EXP 89
73224: PPUSH
73225: LD_VAR 0 2
73229: PPUSH
73230: LD_EXP 89
73234: PUSH
73235: LD_VAR 0 2
73239: ARRAY
73240: PUSH
73241: LD_VAR 0 3
73245: DIFF
73246: PPUSH
73247: CALL_OW 1
73251: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73252: LD_VAR 0 3
73256: PPUSH
73257: LD_INT 0
73259: PPUSH
73260: CALL_OW 109
// continue ;
73264: GO 73088
// end ; if IsInUnit ( j ) then
73266: LD_VAR 0 3
73270: PPUSH
73271: CALL_OW 310
73275: IFFALSE 73286
// ComExitBuilding ( j ) ;
73277: LD_VAR 0 3
73281: PPUSH
73282: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73286: LD_ADDR_VAR 0 6
73290: PUSH
73291: LD_VAR 0 7
73295: PPUSH
73296: LD_VAR 0 3
73300: PPUSH
73301: CALL_OW 74
73305: ST_TO_ADDR
// if not ape then
73306: LD_VAR 0 6
73310: NOT
73311: IFFALSE 73315
// break ;
73313: GO 73425
// x := GetX ( ape ) ;
73315: LD_ADDR_VAR 0 4
73319: PUSH
73320: LD_VAR 0 6
73324: PPUSH
73325: CALL_OW 250
73329: ST_TO_ADDR
// y := GetY ( ape ) ;
73330: LD_ADDR_VAR 0 5
73334: PUSH
73335: LD_VAR 0 6
73339: PPUSH
73340: CALL_OW 251
73344: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73345: LD_VAR 0 4
73349: PPUSH
73350: LD_VAR 0 5
73354: PPUSH
73355: CALL_OW 488
73359: NOT
73360: PUSH
73361: LD_VAR 0 11
73365: PPUSH
73366: LD_VAR 0 4
73370: PPUSH
73371: LD_VAR 0 5
73375: PPUSH
73376: LD_INT 20
73378: PPUSH
73379: CALL 21166 0 4
73383: PUSH
73384: LD_INT 4
73386: ARRAY
73387: OR
73388: IFFALSE 73392
// break ;
73390: GO 73425
// if not HasTask ( j ) then
73392: LD_VAR 0 3
73396: PPUSH
73397: CALL_OW 314
73401: NOT
73402: IFFALSE 73423
// ComTameXY ( j , x , y ) ;
73404: LD_VAR 0 3
73408: PPUSH
73409: LD_VAR 0 4
73413: PPUSH
73414: LD_VAR 0 5
73418: PPUSH
73419: CALL_OW 131
// end ; end ;
73423: GO 73088
73425: POP
73426: POP
// end ;
73427: GO 72644
73429: POP
73430: POP
// end ;
73431: LD_VAR 0 1
73435: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73436: LD_INT 0
73438: PPUSH
73439: PPUSH
73440: PPUSH
73441: PPUSH
73442: PPUSH
73443: PPUSH
73444: PPUSH
73445: PPUSH
// if not mc_bases then
73446: LD_EXP 58
73450: NOT
73451: IFFALSE 73455
// exit ;
73453: GO 74081
// for i = 1 to mc_bases do
73455: LD_ADDR_VAR 0 2
73459: PUSH
73460: DOUBLE
73461: LD_INT 1
73463: DEC
73464: ST_TO_ADDR
73465: LD_EXP 58
73469: PUSH
73470: FOR_TO
73471: IFFALSE 74079
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73473: LD_EXP 87
73477: PUSH
73478: LD_VAR 0 2
73482: ARRAY
73483: NOT
73484: PUSH
73485: LD_EXP 87
73489: PUSH
73490: LD_VAR 0 2
73494: ARRAY
73495: PPUSH
73496: LD_INT 25
73498: PUSH
73499: LD_INT 12
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PPUSH
73506: CALL_OW 72
73510: NOT
73511: OR
73512: IFFALSE 73516
// continue ;
73514: GO 73470
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73516: LD_ADDR_VAR 0 5
73520: PUSH
73521: LD_EXP 87
73525: PUSH
73526: LD_VAR 0 2
73530: ARRAY
73531: PUSH
73532: LD_INT 1
73534: ARRAY
73535: PPUSH
73536: CALL_OW 255
73540: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73541: LD_VAR 0 5
73545: PPUSH
73546: LD_INT 2
73548: PPUSH
73549: CALL_OW 325
73553: IFFALSE 73806
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73555: LD_ADDR_VAR 0 4
73559: PUSH
73560: LD_EXP 87
73564: PUSH
73565: LD_VAR 0 2
73569: ARRAY
73570: PPUSH
73571: LD_INT 25
73573: PUSH
73574: LD_INT 16
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: PPUSH
73581: CALL_OW 72
73585: ST_TO_ADDR
// if tmp < 6 then
73586: LD_VAR 0 4
73590: PUSH
73591: LD_INT 6
73593: LESS
73594: IFFALSE 73806
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73596: LD_ADDR_VAR 0 6
73600: PUSH
73601: LD_EXP 58
73605: PUSH
73606: LD_VAR 0 2
73610: ARRAY
73611: PPUSH
73612: LD_INT 2
73614: PUSH
73615: LD_INT 30
73617: PUSH
73618: LD_INT 0
73620: PUSH
73621: EMPTY
73622: LIST
73623: LIST
73624: PUSH
73625: LD_INT 30
73627: PUSH
73628: LD_INT 1
73630: PUSH
73631: EMPTY
73632: LIST
73633: LIST
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: LIST
73639: PPUSH
73640: CALL_OW 72
73644: ST_TO_ADDR
// if depot then
73645: LD_VAR 0 6
73649: IFFALSE 73806
// begin selected := 0 ;
73651: LD_ADDR_VAR 0 7
73655: PUSH
73656: LD_INT 0
73658: ST_TO_ADDR
// for j in depot do
73659: LD_ADDR_VAR 0 3
73663: PUSH
73664: LD_VAR 0 6
73668: PUSH
73669: FOR_IN
73670: IFFALSE 73701
// begin if UnitsInside ( j ) < 6 then
73672: LD_VAR 0 3
73676: PPUSH
73677: CALL_OW 313
73681: PUSH
73682: LD_INT 6
73684: LESS
73685: IFFALSE 73699
// begin selected := j ;
73687: LD_ADDR_VAR 0 7
73691: PUSH
73692: LD_VAR 0 3
73696: ST_TO_ADDR
// break ;
73697: GO 73701
// end ; end ;
73699: GO 73669
73701: POP
73702: POP
// if selected then
73703: LD_VAR 0 7
73707: IFFALSE 73806
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73709: LD_ADDR_VAR 0 3
73713: PUSH
73714: LD_EXP 87
73718: PUSH
73719: LD_VAR 0 2
73723: ARRAY
73724: PPUSH
73725: LD_INT 25
73727: PUSH
73728: LD_INT 12
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PPUSH
73735: CALL_OW 72
73739: PUSH
73740: FOR_IN
73741: IFFALSE 73804
// if not HasTask ( j ) then
73743: LD_VAR 0 3
73747: PPUSH
73748: CALL_OW 314
73752: NOT
73753: IFFALSE 73802
// begin if not IsInUnit ( j ) then
73755: LD_VAR 0 3
73759: PPUSH
73760: CALL_OW 310
73764: NOT
73765: IFFALSE 73781
// ComEnterUnit ( j , selected ) ;
73767: LD_VAR 0 3
73771: PPUSH
73772: LD_VAR 0 7
73776: PPUSH
73777: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73781: LD_VAR 0 3
73785: PPUSH
73786: LD_INT 16
73788: PPUSH
73789: CALL_OW 183
// AddComExitBuilding ( j ) ;
73793: LD_VAR 0 3
73797: PPUSH
73798: CALL_OW 182
// end ;
73802: GO 73740
73804: POP
73805: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73806: LD_VAR 0 5
73810: PPUSH
73811: LD_INT 11
73813: PPUSH
73814: CALL_OW 325
73818: IFFALSE 74077
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73820: LD_ADDR_VAR 0 4
73824: PUSH
73825: LD_EXP 87
73829: PUSH
73830: LD_VAR 0 2
73834: ARRAY
73835: PPUSH
73836: LD_INT 25
73838: PUSH
73839: LD_INT 16
73841: PUSH
73842: EMPTY
73843: LIST
73844: LIST
73845: PPUSH
73846: CALL_OW 72
73850: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73851: LD_VAR 0 4
73855: PUSH
73856: LD_INT 6
73858: GREATEREQUAL
73859: PUSH
73860: LD_VAR 0 5
73864: PPUSH
73865: LD_INT 2
73867: PPUSH
73868: CALL_OW 325
73872: NOT
73873: OR
73874: IFFALSE 74077
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73876: LD_ADDR_VAR 0 8
73880: PUSH
73881: LD_EXP 58
73885: PUSH
73886: LD_VAR 0 2
73890: ARRAY
73891: PPUSH
73892: LD_INT 2
73894: PUSH
73895: LD_INT 30
73897: PUSH
73898: LD_INT 4
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: PUSH
73905: LD_INT 30
73907: PUSH
73908: LD_INT 5
73910: PUSH
73911: EMPTY
73912: LIST
73913: LIST
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: LIST
73919: PPUSH
73920: CALL_OW 72
73924: ST_TO_ADDR
// if barracks then
73925: LD_VAR 0 8
73929: IFFALSE 74077
// begin selected := 0 ;
73931: LD_ADDR_VAR 0 7
73935: PUSH
73936: LD_INT 0
73938: ST_TO_ADDR
// for j in barracks do
73939: LD_ADDR_VAR 0 3
73943: PUSH
73944: LD_VAR 0 8
73948: PUSH
73949: FOR_IN
73950: IFFALSE 73981
// begin if UnitsInside ( j ) < 6 then
73952: LD_VAR 0 3
73956: PPUSH
73957: CALL_OW 313
73961: PUSH
73962: LD_INT 6
73964: LESS
73965: IFFALSE 73979
// begin selected := j ;
73967: LD_ADDR_VAR 0 7
73971: PUSH
73972: LD_VAR 0 3
73976: ST_TO_ADDR
// break ;
73977: GO 73981
// end ; end ;
73979: GO 73949
73981: POP
73982: POP
// if selected then
73983: LD_VAR 0 7
73987: IFFALSE 74077
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73989: LD_ADDR_VAR 0 3
73993: PUSH
73994: LD_EXP 87
73998: PUSH
73999: LD_VAR 0 2
74003: ARRAY
74004: PPUSH
74005: LD_INT 25
74007: PUSH
74008: LD_INT 12
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PPUSH
74015: CALL_OW 72
74019: PUSH
74020: FOR_IN
74021: IFFALSE 74075
// if not IsInUnit ( j ) and not HasTask ( j ) then
74023: LD_VAR 0 3
74027: PPUSH
74028: CALL_OW 310
74032: NOT
74033: PUSH
74034: LD_VAR 0 3
74038: PPUSH
74039: CALL_OW 314
74043: NOT
74044: AND
74045: IFFALSE 74073
// begin ComEnterUnit ( j , selected ) ;
74047: LD_VAR 0 3
74051: PPUSH
74052: LD_VAR 0 7
74056: PPUSH
74057: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74061: LD_VAR 0 3
74065: PPUSH
74066: LD_INT 15
74068: PPUSH
74069: CALL_OW 183
// end ;
74073: GO 74020
74075: POP
74076: POP
// end ; end ; end ; end ; end ;
74077: GO 73470
74079: POP
74080: POP
// end ;
74081: LD_VAR 0 1
74085: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74086: LD_INT 0
74088: PPUSH
74089: PPUSH
74090: PPUSH
74091: PPUSH
// if not mc_bases then
74092: LD_EXP 58
74096: NOT
74097: IFFALSE 74101
// exit ;
74099: GO 74279
// for i = 1 to mc_bases do
74101: LD_ADDR_VAR 0 2
74105: PUSH
74106: DOUBLE
74107: LD_INT 1
74109: DEC
74110: ST_TO_ADDR
74111: LD_EXP 58
74115: PUSH
74116: FOR_TO
74117: IFFALSE 74277
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74119: LD_ADDR_VAR 0 4
74123: PUSH
74124: LD_EXP 58
74128: PUSH
74129: LD_VAR 0 2
74133: ARRAY
74134: PPUSH
74135: LD_INT 25
74137: PUSH
74138: LD_INT 9
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PPUSH
74145: CALL_OW 72
74149: ST_TO_ADDR
// if not tmp then
74150: LD_VAR 0 4
74154: NOT
74155: IFFALSE 74159
// continue ;
74157: GO 74116
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74159: LD_EXP 84
74163: PUSH
74164: LD_VAR 0 2
74168: ARRAY
74169: PPUSH
74170: LD_INT 29
74172: PPUSH
74173: CALL_OW 325
74177: NOT
74178: PUSH
74179: LD_EXP 84
74183: PUSH
74184: LD_VAR 0 2
74188: ARRAY
74189: PPUSH
74190: LD_INT 28
74192: PPUSH
74193: CALL_OW 325
74197: NOT
74198: AND
74199: IFFALSE 74203
// continue ;
74201: GO 74116
// for j in tmp do
74203: LD_ADDR_VAR 0 3
74207: PUSH
74208: LD_VAR 0 4
74212: PUSH
74213: FOR_IN
74214: IFFALSE 74273
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74216: LD_VAR 0 3
74220: PUSH
74221: LD_EXP 61
74225: PUSH
74226: LD_VAR 0 2
74230: ARRAY
74231: PUSH
74232: LD_INT 1
74234: ARRAY
74235: IN
74236: NOT
74237: PUSH
74238: LD_VAR 0 3
74242: PUSH
74243: LD_EXP 61
74247: PUSH
74248: LD_VAR 0 2
74252: ARRAY
74253: PUSH
74254: LD_INT 2
74256: ARRAY
74257: IN
74258: NOT
74259: AND
74260: IFFALSE 74271
// ComSpaceTimeShoot ( j ) ;
74262: LD_VAR 0 3
74266: PPUSH
74267: CALL 14330 0 1
74271: GO 74213
74273: POP
74274: POP
// end ;
74275: GO 74116
74277: POP
74278: POP
// end ;
74279: LD_VAR 0 1
74283: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74284: LD_INT 0
74286: PPUSH
74287: PPUSH
74288: PPUSH
74289: PPUSH
74290: PPUSH
74291: PPUSH
74292: PPUSH
74293: PPUSH
74294: PPUSH
// if not mc_bases then
74295: LD_EXP 58
74299: NOT
74300: IFFALSE 74304
// exit ;
74302: GO 74926
// for i = 1 to mc_bases do
74304: LD_ADDR_VAR 0 2
74308: PUSH
74309: DOUBLE
74310: LD_INT 1
74312: DEC
74313: ST_TO_ADDR
74314: LD_EXP 58
74318: PUSH
74319: FOR_TO
74320: IFFALSE 74924
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74322: LD_EXP 93
74326: PUSH
74327: LD_VAR 0 2
74331: ARRAY
74332: NOT
74333: PUSH
74334: LD_INT 38
74336: PPUSH
74337: LD_EXP 84
74341: PUSH
74342: LD_VAR 0 2
74346: ARRAY
74347: PPUSH
74348: CALL_OW 321
74352: PUSH
74353: LD_INT 2
74355: NONEQUAL
74356: OR
74357: IFFALSE 74361
// continue ;
74359: GO 74319
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74361: LD_ADDR_VAR 0 8
74365: PUSH
74366: LD_EXP 58
74370: PUSH
74371: LD_VAR 0 2
74375: ARRAY
74376: PPUSH
74377: LD_INT 30
74379: PUSH
74380: LD_INT 34
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PPUSH
74387: CALL_OW 72
74391: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74392: LD_ADDR_VAR 0 9
74396: PUSH
74397: LD_EXP 58
74401: PUSH
74402: LD_VAR 0 2
74406: ARRAY
74407: PPUSH
74408: LD_INT 25
74410: PUSH
74411: LD_INT 4
74413: PUSH
74414: EMPTY
74415: LIST
74416: LIST
74417: PPUSH
74418: CALL_OW 72
74422: PPUSH
74423: LD_INT 0
74425: PPUSH
74426: CALL 53467 0 2
74430: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74431: LD_VAR 0 9
74435: NOT
74436: PUSH
74437: LD_VAR 0 8
74441: NOT
74442: OR
74443: PUSH
74444: LD_EXP 58
74448: PUSH
74449: LD_VAR 0 2
74453: ARRAY
74454: PPUSH
74455: LD_INT 124
74457: PPUSH
74458: CALL 53467 0 2
74462: OR
74463: IFFALSE 74467
// continue ;
74465: GO 74319
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74467: LD_EXP 94
74471: PUSH
74472: LD_VAR 0 2
74476: ARRAY
74477: PUSH
74478: LD_EXP 93
74482: PUSH
74483: LD_VAR 0 2
74487: ARRAY
74488: LESS
74489: PUSH
74490: LD_EXP 94
74494: PUSH
74495: LD_VAR 0 2
74499: ARRAY
74500: PUSH
74501: LD_VAR 0 8
74505: LESS
74506: AND
74507: IFFALSE 74922
// begin tmp := sci [ 1 ] ;
74509: LD_ADDR_VAR 0 7
74513: PUSH
74514: LD_VAR 0 9
74518: PUSH
74519: LD_INT 1
74521: ARRAY
74522: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74523: LD_VAR 0 7
74527: PPUSH
74528: LD_INT 124
74530: PPUSH
74531: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74535: LD_ADDR_VAR 0 3
74539: PUSH
74540: DOUBLE
74541: LD_EXP 93
74545: PUSH
74546: LD_VAR 0 2
74550: ARRAY
74551: INC
74552: ST_TO_ADDR
74553: LD_EXP 93
74557: PUSH
74558: LD_VAR 0 2
74562: ARRAY
74563: PUSH
74564: FOR_DOWNTO
74565: IFFALSE 74908
// begin if IsInUnit ( tmp ) then
74567: LD_VAR 0 7
74571: PPUSH
74572: CALL_OW 310
74576: IFFALSE 74587
// ComExitBuilding ( tmp ) ;
74578: LD_VAR 0 7
74582: PPUSH
74583: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74587: LD_INT 35
74589: PPUSH
74590: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74594: LD_VAR 0 7
74598: PPUSH
74599: CALL_OW 310
74603: NOT
74604: PUSH
74605: LD_VAR 0 7
74609: PPUSH
74610: CALL_OW 314
74614: NOT
74615: AND
74616: IFFALSE 74587
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74618: LD_ADDR_VAR 0 6
74622: PUSH
74623: LD_VAR 0 7
74627: PPUSH
74628: CALL_OW 250
74632: PUSH
74633: LD_VAR 0 7
74637: PPUSH
74638: CALL_OW 251
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74647: LD_INT 35
74649: PPUSH
74650: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74654: LD_ADDR_VAR 0 4
74658: PUSH
74659: LD_EXP 93
74663: PUSH
74664: LD_VAR 0 2
74668: ARRAY
74669: PUSH
74670: LD_VAR 0 3
74674: ARRAY
74675: PUSH
74676: LD_INT 1
74678: ARRAY
74679: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74680: LD_ADDR_VAR 0 5
74684: PUSH
74685: LD_EXP 93
74689: PUSH
74690: LD_VAR 0 2
74694: ARRAY
74695: PUSH
74696: LD_VAR 0 3
74700: ARRAY
74701: PUSH
74702: LD_INT 2
74704: ARRAY
74705: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74706: LD_VAR 0 7
74710: PPUSH
74711: LD_INT 10
74713: PPUSH
74714: CALL 22863 0 2
74718: PUSH
74719: LD_INT 4
74721: ARRAY
74722: IFFALSE 74760
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74724: LD_VAR 0 7
74728: PPUSH
74729: LD_VAR 0 6
74733: PUSH
74734: LD_INT 1
74736: ARRAY
74737: PPUSH
74738: LD_VAR 0 6
74742: PUSH
74743: LD_INT 2
74745: ARRAY
74746: PPUSH
74747: CALL_OW 111
// wait ( 0 0$10 ) ;
74751: LD_INT 350
74753: PPUSH
74754: CALL_OW 67
// end else
74758: GO 74786
// begin ComMoveXY ( tmp , x , y ) ;
74760: LD_VAR 0 7
74764: PPUSH
74765: LD_VAR 0 4
74769: PPUSH
74770: LD_VAR 0 5
74774: PPUSH
74775: CALL_OW 111
// wait ( 0 0$3 ) ;
74779: LD_INT 105
74781: PPUSH
74782: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74786: LD_VAR 0 7
74790: PPUSH
74791: LD_VAR 0 4
74795: PPUSH
74796: LD_VAR 0 5
74800: PPUSH
74801: CALL_OW 307
74805: IFFALSE 74647
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74807: LD_VAR 0 7
74811: PPUSH
74812: LD_VAR 0 4
74816: PPUSH
74817: LD_VAR 0 5
74821: PPUSH
74822: LD_VAR 0 8
74826: PUSH
74827: LD_VAR 0 3
74831: ARRAY
74832: PPUSH
74833: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74837: LD_INT 35
74839: PPUSH
74840: CALL_OW 67
// until not HasTask ( tmp ) ;
74844: LD_VAR 0 7
74848: PPUSH
74849: CALL_OW 314
74853: NOT
74854: IFFALSE 74837
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74856: LD_ADDR_EXP 94
74860: PUSH
74861: LD_EXP 94
74865: PPUSH
74866: LD_VAR 0 2
74870: PUSH
74871: LD_EXP 94
74875: PUSH
74876: LD_VAR 0 2
74880: ARRAY
74881: PUSH
74882: LD_INT 1
74884: PLUS
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PPUSH
74890: LD_VAR 0 8
74894: PUSH
74895: LD_VAR 0 3
74899: ARRAY
74900: PPUSH
74901: CALL 20270 0 3
74905: ST_TO_ADDR
// end ;
74906: GO 74564
74908: POP
74909: POP
// MC_Reset ( i , 124 ) ;
74910: LD_VAR 0 2
74914: PPUSH
74915: LD_INT 124
74917: PPUSH
74918: CALL 59036 0 2
// end ; end ;
74922: GO 74319
74924: POP
74925: POP
// end ;
74926: LD_VAR 0 1
74930: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74931: LD_INT 0
74933: PPUSH
74934: PPUSH
74935: PPUSH
// if not mc_bases then
74936: LD_EXP 58
74940: NOT
74941: IFFALSE 74945
// exit ;
74943: GO 75551
// for i = 1 to mc_bases do
74945: LD_ADDR_VAR 0 2
74949: PUSH
74950: DOUBLE
74951: LD_INT 1
74953: DEC
74954: ST_TO_ADDR
74955: LD_EXP 58
74959: PUSH
74960: FOR_TO
74961: IFFALSE 75549
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74963: LD_ADDR_VAR 0 3
74967: PUSH
74968: LD_EXP 58
74972: PUSH
74973: LD_VAR 0 2
74977: ARRAY
74978: PPUSH
74979: LD_INT 25
74981: PUSH
74982: LD_INT 4
74984: PUSH
74985: EMPTY
74986: LIST
74987: LIST
74988: PPUSH
74989: CALL_OW 72
74993: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74994: LD_VAR 0 3
74998: NOT
74999: PUSH
75000: LD_EXP 95
75004: PUSH
75005: LD_VAR 0 2
75009: ARRAY
75010: NOT
75011: OR
75012: PUSH
75013: LD_EXP 58
75017: PUSH
75018: LD_VAR 0 2
75022: ARRAY
75023: PPUSH
75024: LD_INT 2
75026: PUSH
75027: LD_INT 30
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 30
75039: PUSH
75040: LD_INT 1
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: EMPTY
75048: LIST
75049: LIST
75050: LIST
75051: PPUSH
75052: CALL_OW 72
75056: NOT
75057: OR
75058: IFFALSE 75108
// begin if mc_deposits_finder [ i ] then
75060: LD_EXP 96
75064: PUSH
75065: LD_VAR 0 2
75069: ARRAY
75070: IFFALSE 75106
// begin MC_Reset ( i , 125 ) ;
75072: LD_VAR 0 2
75076: PPUSH
75077: LD_INT 125
75079: PPUSH
75080: CALL 59036 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75084: LD_ADDR_EXP 96
75088: PUSH
75089: LD_EXP 96
75093: PPUSH
75094: LD_VAR 0 2
75098: PPUSH
75099: EMPTY
75100: PPUSH
75101: CALL_OW 1
75105: ST_TO_ADDR
// end ; continue ;
75106: GO 74960
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75108: LD_EXP 95
75112: PUSH
75113: LD_VAR 0 2
75117: ARRAY
75118: PUSH
75119: LD_INT 1
75121: ARRAY
75122: PUSH
75123: LD_INT 3
75125: ARRAY
75126: PUSH
75127: LD_INT 1
75129: EQUAL
75130: PUSH
75131: LD_INT 20
75133: PPUSH
75134: LD_EXP 84
75138: PUSH
75139: LD_VAR 0 2
75143: ARRAY
75144: PPUSH
75145: CALL_OW 321
75149: PUSH
75150: LD_INT 2
75152: NONEQUAL
75153: AND
75154: IFFALSE 75204
// begin if mc_deposits_finder [ i ] then
75156: LD_EXP 96
75160: PUSH
75161: LD_VAR 0 2
75165: ARRAY
75166: IFFALSE 75202
// begin MC_Reset ( i , 125 ) ;
75168: LD_VAR 0 2
75172: PPUSH
75173: LD_INT 125
75175: PPUSH
75176: CALL 59036 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75180: LD_ADDR_EXP 96
75184: PUSH
75185: LD_EXP 96
75189: PPUSH
75190: LD_VAR 0 2
75194: PPUSH
75195: EMPTY
75196: PPUSH
75197: CALL_OW 1
75201: ST_TO_ADDR
// end ; continue ;
75202: GO 74960
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75204: LD_EXP 95
75208: PUSH
75209: LD_VAR 0 2
75213: ARRAY
75214: PUSH
75215: LD_INT 1
75217: ARRAY
75218: PUSH
75219: LD_INT 1
75221: ARRAY
75222: PPUSH
75223: LD_EXP 95
75227: PUSH
75228: LD_VAR 0 2
75232: ARRAY
75233: PUSH
75234: LD_INT 1
75236: ARRAY
75237: PUSH
75238: LD_INT 2
75240: ARRAY
75241: PPUSH
75242: LD_EXP 84
75246: PUSH
75247: LD_VAR 0 2
75251: ARRAY
75252: PPUSH
75253: CALL_OW 440
75257: IFFALSE 75300
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75259: LD_ADDR_EXP 95
75263: PUSH
75264: LD_EXP 95
75268: PPUSH
75269: LD_VAR 0 2
75273: PPUSH
75274: LD_EXP 95
75278: PUSH
75279: LD_VAR 0 2
75283: ARRAY
75284: PPUSH
75285: LD_INT 1
75287: PPUSH
75288: CALL_OW 3
75292: PPUSH
75293: CALL_OW 1
75297: ST_TO_ADDR
75298: GO 75547
// begin if not mc_deposits_finder [ i ] then
75300: LD_EXP 96
75304: PUSH
75305: LD_VAR 0 2
75309: ARRAY
75310: NOT
75311: IFFALSE 75363
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75313: LD_ADDR_EXP 96
75317: PUSH
75318: LD_EXP 96
75322: PPUSH
75323: LD_VAR 0 2
75327: PPUSH
75328: LD_VAR 0 3
75332: PUSH
75333: LD_INT 1
75335: ARRAY
75336: PUSH
75337: EMPTY
75338: LIST
75339: PPUSH
75340: CALL_OW 1
75344: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75345: LD_VAR 0 3
75349: PUSH
75350: LD_INT 1
75352: ARRAY
75353: PPUSH
75354: LD_INT 125
75356: PPUSH
75357: CALL_OW 109
// end else
75361: GO 75547
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75363: LD_EXP 96
75367: PUSH
75368: LD_VAR 0 2
75372: ARRAY
75373: PUSH
75374: LD_INT 1
75376: ARRAY
75377: PPUSH
75378: CALL_OW 310
75382: IFFALSE 75405
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75384: LD_EXP 96
75388: PUSH
75389: LD_VAR 0 2
75393: ARRAY
75394: PUSH
75395: LD_INT 1
75397: ARRAY
75398: PPUSH
75399: CALL_OW 122
75403: GO 75547
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75405: LD_EXP 96
75409: PUSH
75410: LD_VAR 0 2
75414: ARRAY
75415: PUSH
75416: LD_INT 1
75418: ARRAY
75419: PPUSH
75420: CALL_OW 314
75424: NOT
75425: PUSH
75426: LD_EXP 96
75430: PUSH
75431: LD_VAR 0 2
75435: ARRAY
75436: PUSH
75437: LD_INT 1
75439: ARRAY
75440: PPUSH
75441: LD_EXP 95
75445: PUSH
75446: LD_VAR 0 2
75450: ARRAY
75451: PUSH
75452: LD_INT 1
75454: ARRAY
75455: PUSH
75456: LD_INT 1
75458: ARRAY
75459: PPUSH
75460: LD_EXP 95
75464: PUSH
75465: LD_VAR 0 2
75469: ARRAY
75470: PUSH
75471: LD_INT 1
75473: ARRAY
75474: PUSH
75475: LD_INT 2
75477: ARRAY
75478: PPUSH
75479: CALL_OW 297
75483: PUSH
75484: LD_INT 6
75486: GREATER
75487: AND
75488: IFFALSE 75547
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75490: LD_EXP 96
75494: PUSH
75495: LD_VAR 0 2
75499: ARRAY
75500: PUSH
75501: LD_INT 1
75503: ARRAY
75504: PPUSH
75505: LD_EXP 95
75509: PUSH
75510: LD_VAR 0 2
75514: ARRAY
75515: PUSH
75516: LD_INT 1
75518: ARRAY
75519: PUSH
75520: LD_INT 1
75522: ARRAY
75523: PPUSH
75524: LD_EXP 95
75528: PUSH
75529: LD_VAR 0 2
75533: ARRAY
75534: PUSH
75535: LD_INT 1
75537: ARRAY
75538: PUSH
75539: LD_INT 2
75541: ARRAY
75542: PPUSH
75543: CALL_OW 111
// end ; end ; end ;
75547: GO 74960
75549: POP
75550: POP
// end ;
75551: LD_VAR 0 1
75555: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75556: LD_INT 0
75558: PPUSH
75559: PPUSH
75560: PPUSH
75561: PPUSH
75562: PPUSH
75563: PPUSH
75564: PPUSH
75565: PPUSH
75566: PPUSH
75567: PPUSH
75568: PPUSH
// if not mc_bases then
75569: LD_EXP 58
75573: NOT
75574: IFFALSE 75578
// exit ;
75576: GO 76302
// for i = 1 to mc_bases do
75578: LD_ADDR_VAR 0 2
75582: PUSH
75583: DOUBLE
75584: LD_INT 1
75586: DEC
75587: ST_TO_ADDR
75588: LD_EXP 58
75592: PUSH
75593: FOR_TO
75594: IFFALSE 76300
// begin if not mc_bases [ i ] then
75596: LD_EXP 58
75600: PUSH
75601: LD_VAR 0 2
75605: ARRAY
75606: NOT
75607: IFFALSE 75611
// continue ;
75609: GO 75593
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75611: LD_ADDR_VAR 0 7
75615: PUSH
75616: LD_EXP 58
75620: PUSH
75621: LD_VAR 0 2
75625: ARRAY
75626: PUSH
75627: LD_INT 1
75629: ARRAY
75630: PPUSH
75631: CALL_OW 248
75635: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75636: LD_VAR 0 7
75640: PUSH
75641: LD_INT 3
75643: EQUAL
75644: PUSH
75645: LD_EXP 77
75649: PUSH
75650: LD_VAR 0 2
75654: ARRAY
75655: PUSH
75656: LD_EXP 80
75660: PUSH
75661: LD_VAR 0 2
75665: ARRAY
75666: UNION
75667: PPUSH
75668: LD_INT 33
75670: PUSH
75671: LD_INT 2
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PPUSH
75678: CALL_OW 72
75682: NOT
75683: OR
75684: IFFALSE 75688
// continue ;
75686: GO 75593
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75688: LD_ADDR_VAR 0 9
75692: PUSH
75693: LD_EXP 58
75697: PUSH
75698: LD_VAR 0 2
75702: ARRAY
75703: PPUSH
75704: LD_INT 30
75706: PUSH
75707: LD_INT 36
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: PPUSH
75714: CALL_OW 72
75718: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75719: LD_ADDR_VAR 0 10
75723: PUSH
75724: LD_EXP 77
75728: PUSH
75729: LD_VAR 0 2
75733: ARRAY
75734: PPUSH
75735: LD_INT 34
75737: PUSH
75738: LD_INT 31
75740: PUSH
75741: EMPTY
75742: LIST
75743: LIST
75744: PPUSH
75745: CALL_OW 72
75749: ST_TO_ADDR
// if not cts and not mcts then
75750: LD_VAR 0 9
75754: NOT
75755: PUSH
75756: LD_VAR 0 10
75760: NOT
75761: AND
75762: IFFALSE 75766
// continue ;
75764: GO 75593
// x := cts ;
75766: LD_ADDR_VAR 0 11
75770: PUSH
75771: LD_VAR 0 9
75775: ST_TO_ADDR
// if not x then
75776: LD_VAR 0 11
75780: NOT
75781: IFFALSE 75793
// x := mcts ;
75783: LD_ADDR_VAR 0 11
75787: PUSH
75788: LD_VAR 0 10
75792: ST_TO_ADDR
// if mc_remote_driver [ i ] then
75793: LD_EXP 98
75797: PUSH
75798: LD_VAR 0 2
75802: ARRAY
75803: IFFALSE 76072
// for j in mc_remote_driver [ i ] do
75805: LD_ADDR_VAR 0 3
75809: PUSH
75810: LD_EXP 98
75814: PUSH
75815: LD_VAR 0 2
75819: ARRAY
75820: PUSH
75821: FOR_IN
75822: IFFALSE 76070
// begin if GetClass ( j ) <> 3 then
75824: LD_VAR 0 3
75828: PPUSH
75829: CALL_OW 257
75833: PUSH
75834: LD_INT 3
75836: NONEQUAL
75837: IFFALSE 75890
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75839: LD_ADDR_EXP 98
75843: PUSH
75844: LD_EXP 98
75848: PPUSH
75849: LD_VAR 0 2
75853: PPUSH
75854: LD_EXP 98
75858: PUSH
75859: LD_VAR 0 2
75863: ARRAY
75864: PUSH
75865: LD_VAR 0 3
75869: DIFF
75870: PPUSH
75871: CALL_OW 1
75875: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75876: LD_VAR 0 3
75880: PPUSH
75881: LD_INT 0
75883: PPUSH
75884: CALL_OW 109
// continue ;
75888: GO 75821
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75890: LD_VAR 0 3
75894: PPUSH
75895: CALL_OW 310
75899: NOT
75900: PUSH
75901: LD_VAR 0 3
75905: PPUSH
75906: CALL_OW 310
75910: PPUSH
75911: CALL_OW 266
75915: PUSH
75916: LD_INT 36
75918: NONEQUAL
75919: PUSH
75920: LD_VAR 0 3
75924: PPUSH
75925: CALL 53555 0 1
75929: NOT
75930: AND
75931: OR
75932: IFFALSE 76068
// begin if IsInUnit ( j ) then
75934: LD_VAR 0 3
75938: PPUSH
75939: CALL_OW 310
75943: IFFALSE 75954
// ComExitBuilding ( j ) ;
75945: LD_VAR 0 3
75949: PPUSH
75950: CALL_OW 122
// ct := 0 ;
75954: LD_ADDR_VAR 0 8
75958: PUSH
75959: LD_INT 0
75961: ST_TO_ADDR
// for k in x do
75962: LD_ADDR_VAR 0 4
75966: PUSH
75967: LD_VAR 0 11
75971: PUSH
75972: FOR_IN
75973: IFFALSE 76046
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75975: LD_VAR 0 4
75979: PPUSH
75980: CALL_OW 264
75984: PUSH
75985: LD_INT 31
75987: EQUAL
75988: PUSH
75989: LD_VAR 0 4
75993: PPUSH
75994: CALL_OW 311
75998: NOT
75999: AND
76000: PUSH
76001: LD_VAR 0 4
76005: PPUSH
76006: CALL_OW 266
76010: PUSH
76011: LD_INT 36
76013: EQUAL
76014: PUSH
76015: LD_VAR 0 4
76019: PPUSH
76020: CALL_OW 313
76024: PUSH
76025: LD_INT 3
76027: LESS
76028: AND
76029: OR
76030: IFFALSE 76044
// begin ct := k ;
76032: LD_ADDR_VAR 0 8
76036: PUSH
76037: LD_VAR 0 4
76041: ST_TO_ADDR
// break ;
76042: GO 76046
// end ;
76044: GO 75972
76046: POP
76047: POP
// if ct then
76048: LD_VAR 0 8
76052: IFFALSE 76068
// ComEnterUnit ( j , ct ) ;
76054: LD_VAR 0 3
76058: PPUSH
76059: LD_VAR 0 8
76063: PPUSH
76064: CALL_OW 120
// end ; end ;
76068: GO 75821
76070: POP
76071: POP
// places := 0 ;
76072: LD_ADDR_VAR 0 5
76076: PUSH
76077: LD_INT 0
76079: ST_TO_ADDR
// for j = 1 to x do
76080: LD_ADDR_VAR 0 3
76084: PUSH
76085: DOUBLE
76086: LD_INT 1
76088: DEC
76089: ST_TO_ADDR
76090: LD_VAR 0 11
76094: PUSH
76095: FOR_TO
76096: IFFALSE 76151
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76098: LD_VAR 0 11
76102: PUSH
76103: LD_VAR 0 3
76107: ARRAY
76108: PPUSH
76109: CALL_OW 264
76113: PUSH
76114: LD_INT 31
76116: EQUAL
76117: IFFALSE 76135
// places := places + 1 else
76119: LD_ADDR_VAR 0 5
76123: PUSH
76124: LD_VAR 0 5
76128: PUSH
76129: LD_INT 1
76131: PLUS
76132: ST_TO_ADDR
76133: GO 76149
// places := places + 3 ;
76135: LD_ADDR_VAR 0 5
76139: PUSH
76140: LD_VAR 0 5
76144: PUSH
76145: LD_INT 3
76147: PLUS
76148: ST_TO_ADDR
76149: GO 76095
76151: POP
76152: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76153: LD_ADDR_VAR 0 6
76157: PUSH
76158: LD_EXP 58
76162: PUSH
76163: LD_VAR 0 2
76167: ARRAY
76168: PPUSH
76169: LD_INT 25
76171: PUSH
76172: LD_INT 3
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PPUSH
76179: CALL_OW 72
76183: PUSH
76184: LD_EXP 98
76188: PUSH
76189: LD_VAR 0 2
76193: ARRAY
76194: DIFF
76195: PPUSH
76196: LD_INT 3
76198: PPUSH
76199: CALL 54455 0 2
76203: ST_TO_ADDR
// if not tmp then
76204: LD_VAR 0 6
76208: NOT
76209: IFFALSE 76213
// continue ;
76211: GO 75593
// places := places - mc_remote_driver [ i ] ;
76213: LD_ADDR_VAR 0 5
76217: PUSH
76218: LD_VAR 0 5
76222: PUSH
76223: LD_EXP 98
76227: PUSH
76228: LD_VAR 0 2
76232: ARRAY
76233: MINUS
76234: ST_TO_ADDR
// if places then
76235: LD_VAR 0 5
76239: IFFALSE 76298
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76241: LD_ADDR_EXP 98
76245: PUSH
76246: LD_EXP 98
76250: PPUSH
76251: LD_VAR 0 2
76255: PPUSH
76256: LD_EXP 98
76260: PUSH
76261: LD_VAR 0 2
76265: ARRAY
76266: PUSH
76267: LD_VAR 0 6
76271: PUSH
76272: LD_INT 1
76274: ARRAY
76275: UNION
76276: PPUSH
76277: CALL_OW 1
76281: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76282: LD_VAR 0 6
76286: PUSH
76287: LD_INT 1
76289: ARRAY
76290: PPUSH
76291: LD_INT 126
76293: PPUSH
76294: CALL_OW 109
// end ; end ;
76298: GO 75593
76300: POP
76301: POP
// end ;
76302: LD_VAR 0 1
76306: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76307: LD_INT 0
76309: PPUSH
76310: PPUSH
76311: PPUSH
76312: PPUSH
76313: PPUSH
76314: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76315: LD_VAR 0 1
76319: NOT
76320: PUSH
76321: LD_VAR 0 2
76325: NOT
76326: OR
76327: PUSH
76328: LD_VAR 0 3
76332: NOT
76333: OR
76334: PUSH
76335: LD_VAR 0 4
76339: PUSH
76340: LD_INT 1
76342: PUSH
76343: LD_INT 2
76345: PUSH
76346: LD_INT 3
76348: PUSH
76349: LD_INT 4
76351: PUSH
76352: LD_INT 5
76354: PUSH
76355: LD_INT 8
76357: PUSH
76358: LD_INT 9
76360: PUSH
76361: LD_INT 15
76363: PUSH
76364: LD_INT 16
76366: PUSH
76367: EMPTY
76368: LIST
76369: LIST
76370: LIST
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: LIST
76377: IN
76378: NOT
76379: OR
76380: IFFALSE 76384
// exit ;
76382: GO 77284
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76384: LD_ADDR_VAR 0 2
76388: PUSH
76389: LD_VAR 0 2
76393: PPUSH
76394: LD_INT 21
76396: PUSH
76397: LD_INT 3
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 24
76406: PUSH
76407: LD_INT 250
76409: PUSH
76410: EMPTY
76411: LIST
76412: LIST
76413: PUSH
76414: EMPTY
76415: LIST
76416: LIST
76417: PPUSH
76418: CALL_OW 72
76422: ST_TO_ADDR
// case class of 1 , 15 :
76423: LD_VAR 0 4
76427: PUSH
76428: LD_INT 1
76430: DOUBLE
76431: EQUAL
76432: IFTRUE 76442
76434: LD_INT 15
76436: DOUBLE
76437: EQUAL
76438: IFTRUE 76442
76440: GO 76527
76442: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76443: LD_ADDR_VAR 0 8
76447: PUSH
76448: LD_VAR 0 2
76452: PPUSH
76453: LD_INT 2
76455: PUSH
76456: LD_INT 30
76458: PUSH
76459: LD_INT 32
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 30
76468: PUSH
76469: LD_INT 31
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: EMPTY
76477: LIST
76478: LIST
76479: LIST
76480: PPUSH
76481: CALL_OW 72
76485: PUSH
76486: LD_VAR 0 2
76490: PPUSH
76491: LD_INT 2
76493: PUSH
76494: LD_INT 30
76496: PUSH
76497: LD_INT 4
76499: PUSH
76500: EMPTY
76501: LIST
76502: LIST
76503: PUSH
76504: LD_INT 30
76506: PUSH
76507: LD_INT 5
76509: PUSH
76510: EMPTY
76511: LIST
76512: LIST
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: LIST
76518: PPUSH
76519: CALL_OW 72
76523: ADD
76524: ST_TO_ADDR
76525: GO 76773
76527: LD_INT 2
76529: DOUBLE
76530: EQUAL
76531: IFTRUE 76541
76533: LD_INT 16
76535: DOUBLE
76536: EQUAL
76537: IFTRUE 76541
76539: GO 76587
76541: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76542: LD_ADDR_VAR 0 8
76546: PUSH
76547: LD_VAR 0 2
76551: PPUSH
76552: LD_INT 2
76554: PUSH
76555: LD_INT 30
76557: PUSH
76558: LD_INT 0
76560: PUSH
76561: EMPTY
76562: LIST
76563: LIST
76564: PUSH
76565: LD_INT 30
76567: PUSH
76568: LD_INT 1
76570: PUSH
76571: EMPTY
76572: LIST
76573: LIST
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: LIST
76579: PPUSH
76580: CALL_OW 72
76584: ST_TO_ADDR
76585: GO 76773
76587: LD_INT 3
76589: DOUBLE
76590: EQUAL
76591: IFTRUE 76595
76593: GO 76641
76595: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76596: LD_ADDR_VAR 0 8
76600: PUSH
76601: LD_VAR 0 2
76605: PPUSH
76606: LD_INT 2
76608: PUSH
76609: LD_INT 30
76611: PUSH
76612: LD_INT 2
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: LD_INT 30
76621: PUSH
76622: LD_INT 3
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: EMPTY
76630: LIST
76631: LIST
76632: LIST
76633: PPUSH
76634: CALL_OW 72
76638: ST_TO_ADDR
76639: GO 76773
76641: LD_INT 4
76643: DOUBLE
76644: EQUAL
76645: IFTRUE 76649
76647: GO 76706
76649: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76650: LD_ADDR_VAR 0 8
76654: PUSH
76655: LD_VAR 0 2
76659: PPUSH
76660: LD_INT 2
76662: PUSH
76663: LD_INT 30
76665: PUSH
76666: LD_INT 6
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 30
76675: PUSH
76676: LD_INT 7
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: LD_INT 30
76685: PUSH
76686: LD_INT 8
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: LIST
76697: LIST
76698: PPUSH
76699: CALL_OW 72
76703: ST_TO_ADDR
76704: GO 76773
76706: LD_INT 5
76708: DOUBLE
76709: EQUAL
76710: IFTRUE 76726
76712: LD_INT 8
76714: DOUBLE
76715: EQUAL
76716: IFTRUE 76726
76718: LD_INT 9
76720: DOUBLE
76721: EQUAL
76722: IFTRUE 76726
76724: GO 76772
76726: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76727: LD_ADDR_VAR 0 8
76731: PUSH
76732: LD_VAR 0 2
76736: PPUSH
76737: LD_INT 2
76739: PUSH
76740: LD_INT 30
76742: PUSH
76743: LD_INT 4
76745: PUSH
76746: EMPTY
76747: LIST
76748: LIST
76749: PUSH
76750: LD_INT 30
76752: PUSH
76753: LD_INT 5
76755: PUSH
76756: EMPTY
76757: LIST
76758: LIST
76759: PUSH
76760: EMPTY
76761: LIST
76762: LIST
76763: LIST
76764: PPUSH
76765: CALL_OW 72
76769: ST_TO_ADDR
76770: GO 76773
76772: POP
// if not tmp then
76773: LD_VAR 0 8
76777: NOT
76778: IFFALSE 76782
// exit ;
76780: GO 77284
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76782: LD_VAR 0 4
76786: PUSH
76787: LD_INT 1
76789: PUSH
76790: LD_INT 15
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: IN
76797: PUSH
76798: LD_EXP 67
76802: PUSH
76803: LD_VAR 0 1
76807: ARRAY
76808: AND
76809: IFFALSE 76965
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76811: LD_ADDR_VAR 0 9
76815: PUSH
76816: LD_EXP 67
76820: PUSH
76821: LD_VAR 0 1
76825: ARRAY
76826: PUSH
76827: LD_INT 1
76829: ARRAY
76830: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76831: LD_VAR 0 9
76835: PUSH
76836: LD_EXP 68
76840: PUSH
76841: LD_VAR 0 1
76845: ARRAY
76846: IN
76847: NOT
76848: IFFALSE 76963
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76850: LD_ADDR_EXP 68
76854: PUSH
76855: LD_EXP 68
76859: PPUSH
76860: LD_VAR 0 1
76864: PUSH
76865: LD_EXP 68
76869: PUSH
76870: LD_VAR 0 1
76874: ARRAY
76875: PUSH
76876: LD_INT 1
76878: PLUS
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PPUSH
76884: LD_VAR 0 9
76888: PPUSH
76889: CALL 20270 0 3
76893: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76894: LD_ADDR_EXP 67
76898: PUSH
76899: LD_EXP 67
76903: PPUSH
76904: LD_VAR 0 1
76908: PPUSH
76909: LD_EXP 67
76913: PUSH
76914: LD_VAR 0 1
76918: ARRAY
76919: PUSH
76920: LD_VAR 0 9
76924: DIFF
76925: PPUSH
76926: CALL_OW 1
76930: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76931: LD_VAR 0 3
76935: PPUSH
76936: LD_EXP 68
76940: PUSH
76941: LD_VAR 0 1
76945: ARRAY
76946: PUSH
76947: LD_EXP 68
76951: PUSH
76952: LD_VAR 0 1
76956: ARRAY
76957: ARRAY
76958: PPUSH
76959: CALL_OW 120
// end ; exit ;
76963: GO 77284
// end ; if tmp > 1 then
76965: LD_VAR 0 8
76969: PUSH
76970: LD_INT 1
76972: GREATER
76973: IFFALSE 77077
// for i = 2 to tmp do
76975: LD_ADDR_VAR 0 6
76979: PUSH
76980: DOUBLE
76981: LD_INT 2
76983: DEC
76984: ST_TO_ADDR
76985: LD_VAR 0 8
76989: PUSH
76990: FOR_TO
76991: IFFALSE 77075
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76993: LD_VAR 0 8
76997: PUSH
76998: LD_VAR 0 6
77002: ARRAY
77003: PPUSH
77004: CALL_OW 461
77008: PUSH
77009: LD_INT 6
77011: EQUAL
77012: IFFALSE 77073
// begin x := tmp [ i ] ;
77014: LD_ADDR_VAR 0 9
77018: PUSH
77019: LD_VAR 0 8
77023: PUSH
77024: LD_VAR 0 6
77028: ARRAY
77029: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77030: LD_ADDR_VAR 0 8
77034: PUSH
77035: LD_VAR 0 8
77039: PPUSH
77040: LD_VAR 0 6
77044: PPUSH
77045: CALL_OW 3
77049: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77050: LD_ADDR_VAR 0 8
77054: PUSH
77055: LD_VAR 0 8
77059: PPUSH
77060: LD_INT 1
77062: PPUSH
77063: LD_VAR 0 9
77067: PPUSH
77068: CALL_OW 2
77072: ST_TO_ADDR
// end ;
77073: GO 76990
77075: POP
77076: POP
// for i in tmp do
77077: LD_ADDR_VAR 0 6
77081: PUSH
77082: LD_VAR 0 8
77086: PUSH
77087: FOR_IN
77088: IFFALSE 77157
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77090: LD_VAR 0 6
77094: PPUSH
77095: CALL_OW 313
77099: PUSH
77100: LD_INT 6
77102: LESS
77103: PUSH
77104: LD_VAR 0 6
77108: PPUSH
77109: CALL_OW 266
77113: PUSH
77114: LD_INT 31
77116: PUSH
77117: LD_INT 32
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: IN
77124: NOT
77125: AND
77126: PUSH
77127: LD_VAR 0 6
77131: PPUSH
77132: CALL_OW 313
77136: PUSH
77137: LD_INT 0
77139: EQUAL
77140: OR
77141: IFFALSE 77155
// begin j := i ;
77143: LD_ADDR_VAR 0 7
77147: PUSH
77148: LD_VAR 0 6
77152: ST_TO_ADDR
// break ;
77153: GO 77157
// end ; end ;
77155: GO 77087
77157: POP
77158: POP
// if j then
77159: LD_VAR 0 7
77163: IFFALSE 77181
// ComEnterUnit ( unit , j ) else
77165: LD_VAR 0 3
77169: PPUSH
77170: LD_VAR 0 7
77174: PPUSH
77175: CALL_OW 120
77179: GO 77284
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77181: LD_ADDR_VAR 0 10
77185: PUSH
77186: LD_VAR 0 2
77190: PPUSH
77191: LD_INT 2
77193: PUSH
77194: LD_INT 30
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 30
77206: PUSH
77207: LD_INT 1
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: EMPTY
77215: LIST
77216: LIST
77217: LIST
77218: PPUSH
77219: CALL_OW 72
77223: ST_TO_ADDR
// if depot then
77224: LD_VAR 0 10
77228: IFFALSE 77284
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77230: LD_ADDR_VAR 0 10
77234: PUSH
77235: LD_VAR 0 10
77239: PPUSH
77240: LD_VAR 0 3
77244: PPUSH
77245: CALL_OW 74
77249: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77250: LD_VAR 0 3
77254: PPUSH
77255: LD_VAR 0 10
77259: PPUSH
77260: CALL_OW 296
77264: PUSH
77265: LD_INT 10
77267: GREATER
77268: IFFALSE 77284
// ComStandNearbyBuilding ( unit , depot ) ;
77270: LD_VAR 0 3
77274: PPUSH
77275: LD_VAR 0 10
77279: PPUSH
77280: CALL 14947 0 2
// end ; end ; end ;
77284: LD_VAR 0 5
77288: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77289: LD_INT 0
77291: PPUSH
77292: PPUSH
77293: PPUSH
77294: PPUSH
// if not mc_bases then
77295: LD_EXP 58
77299: NOT
77300: IFFALSE 77304
// exit ;
77302: GO 77543
// for i = 1 to mc_bases do
77304: LD_ADDR_VAR 0 2
77308: PUSH
77309: DOUBLE
77310: LD_INT 1
77312: DEC
77313: ST_TO_ADDR
77314: LD_EXP 58
77318: PUSH
77319: FOR_TO
77320: IFFALSE 77541
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77322: LD_ADDR_VAR 0 4
77326: PUSH
77327: LD_EXP 58
77331: PUSH
77332: LD_VAR 0 2
77336: ARRAY
77337: PPUSH
77338: LD_INT 21
77340: PUSH
77341: LD_INT 1
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PPUSH
77348: CALL_OW 72
77352: PUSH
77353: LD_EXP 87
77357: PUSH
77358: LD_VAR 0 2
77362: ARRAY
77363: UNION
77364: ST_TO_ADDR
// if not tmp then
77365: LD_VAR 0 4
77369: NOT
77370: IFFALSE 77374
// continue ;
77372: GO 77319
// for j in tmp do
77374: LD_ADDR_VAR 0 3
77378: PUSH
77379: LD_VAR 0 4
77383: PUSH
77384: FOR_IN
77385: IFFALSE 77537
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77387: LD_VAR 0 3
77391: PPUSH
77392: CALL_OW 110
77396: NOT
77397: PUSH
77398: LD_VAR 0 3
77402: PPUSH
77403: CALL_OW 314
77407: NOT
77408: AND
77409: PUSH
77410: LD_VAR 0 3
77414: PPUSH
77415: CALL_OW 311
77419: NOT
77420: AND
77421: PUSH
77422: LD_VAR 0 3
77426: PPUSH
77427: CALL_OW 310
77431: NOT
77432: AND
77433: PUSH
77434: LD_VAR 0 3
77438: PUSH
77439: LD_EXP 61
77443: PUSH
77444: LD_VAR 0 2
77448: ARRAY
77449: PUSH
77450: LD_INT 1
77452: ARRAY
77453: IN
77454: NOT
77455: AND
77456: PUSH
77457: LD_VAR 0 3
77461: PUSH
77462: LD_EXP 61
77466: PUSH
77467: LD_VAR 0 2
77471: ARRAY
77472: PUSH
77473: LD_INT 2
77475: ARRAY
77476: IN
77477: NOT
77478: AND
77479: PUSH
77480: LD_VAR 0 3
77484: PUSH
77485: LD_EXP 70
77489: PUSH
77490: LD_VAR 0 2
77494: ARRAY
77495: IN
77496: NOT
77497: AND
77498: IFFALSE 77535
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77500: LD_VAR 0 2
77504: PPUSH
77505: LD_EXP 58
77509: PUSH
77510: LD_VAR 0 2
77514: ARRAY
77515: PPUSH
77516: LD_VAR 0 3
77520: PPUSH
77521: LD_VAR 0 3
77525: PPUSH
77526: CALL_OW 257
77530: PPUSH
77531: CALL 76307 0 4
// end ;
77535: GO 77384
77537: POP
77538: POP
// end ;
77539: GO 77319
77541: POP
77542: POP
// end ;
77543: LD_VAR 0 1
77547: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77548: LD_INT 0
77550: PPUSH
77551: PPUSH
77552: PPUSH
77553: PPUSH
77554: PPUSH
77555: PPUSH
// if not mc_bases [ base ] then
77556: LD_EXP 58
77560: PUSH
77561: LD_VAR 0 1
77565: ARRAY
77566: NOT
77567: IFFALSE 77571
// exit ;
77569: GO 77753
// tmp := [ ] ;
77571: LD_ADDR_VAR 0 6
77575: PUSH
77576: EMPTY
77577: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77578: LD_ADDR_VAR 0 7
77582: PUSH
77583: LD_VAR 0 3
77587: PPUSH
77588: LD_INT 0
77590: PPUSH
77591: CALL_OW 517
77595: ST_TO_ADDR
// if not list then
77596: LD_VAR 0 7
77600: NOT
77601: IFFALSE 77605
// exit ;
77603: GO 77753
// for i = 1 to amount do
77605: LD_ADDR_VAR 0 5
77609: PUSH
77610: DOUBLE
77611: LD_INT 1
77613: DEC
77614: ST_TO_ADDR
77615: LD_VAR 0 2
77619: PUSH
77620: FOR_TO
77621: IFFALSE 77701
// begin x := rand ( 1 , list [ 1 ] ) ;
77623: LD_ADDR_VAR 0 8
77627: PUSH
77628: LD_INT 1
77630: PPUSH
77631: LD_VAR 0 7
77635: PUSH
77636: LD_INT 1
77638: ARRAY
77639: PPUSH
77640: CALL_OW 12
77644: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77645: LD_ADDR_VAR 0 6
77649: PUSH
77650: LD_VAR 0 6
77654: PPUSH
77655: LD_VAR 0 5
77659: PPUSH
77660: LD_VAR 0 7
77664: PUSH
77665: LD_INT 1
77667: ARRAY
77668: PUSH
77669: LD_VAR 0 8
77673: ARRAY
77674: PUSH
77675: LD_VAR 0 7
77679: PUSH
77680: LD_INT 2
77682: ARRAY
77683: PUSH
77684: LD_VAR 0 8
77688: ARRAY
77689: PUSH
77690: EMPTY
77691: LIST
77692: LIST
77693: PPUSH
77694: CALL_OW 1
77698: ST_TO_ADDR
// end ;
77699: GO 77620
77701: POP
77702: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77703: LD_ADDR_EXP 71
77707: PUSH
77708: LD_EXP 71
77712: PPUSH
77713: LD_VAR 0 1
77717: PPUSH
77718: LD_VAR 0 6
77722: PPUSH
77723: CALL_OW 1
77727: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77728: LD_ADDR_EXP 73
77732: PUSH
77733: LD_EXP 73
77737: PPUSH
77738: LD_VAR 0 1
77742: PPUSH
77743: LD_VAR 0 3
77747: PPUSH
77748: CALL_OW 1
77752: ST_TO_ADDR
// end ;
77753: LD_VAR 0 4
77757: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77758: LD_INT 0
77760: PPUSH
// if not mc_bases [ base ] then
77761: LD_EXP 58
77765: PUSH
77766: LD_VAR 0 1
77770: ARRAY
77771: NOT
77772: IFFALSE 77776
// exit ;
77774: GO 77801
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77776: LD_ADDR_EXP 63
77780: PUSH
77781: LD_EXP 63
77785: PPUSH
77786: LD_VAR 0 1
77790: PPUSH
77791: LD_VAR 0 2
77795: PPUSH
77796: CALL_OW 1
77800: ST_TO_ADDR
// end ;
77801: LD_VAR 0 3
77805: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77806: LD_INT 0
77808: PPUSH
// if not mc_bases [ base ] then
77809: LD_EXP 58
77813: PUSH
77814: LD_VAR 0 1
77818: ARRAY
77819: NOT
77820: IFFALSE 77824
// exit ;
77822: GO 77861
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77824: LD_ADDR_EXP 63
77828: PUSH
77829: LD_EXP 63
77833: PPUSH
77834: LD_VAR 0 1
77838: PPUSH
77839: LD_EXP 63
77843: PUSH
77844: LD_VAR 0 1
77848: ARRAY
77849: PUSH
77850: LD_VAR 0 2
77854: UNION
77855: PPUSH
77856: CALL_OW 1
77860: ST_TO_ADDR
// end ;
77861: LD_VAR 0 3
77865: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77866: LD_INT 0
77868: PPUSH
// if not mc_bases [ base ] then
77869: LD_EXP 58
77873: PUSH
77874: LD_VAR 0 1
77878: ARRAY
77879: NOT
77880: IFFALSE 77884
// exit ;
77882: GO 77909
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77884: LD_ADDR_EXP 79
77888: PUSH
77889: LD_EXP 79
77893: PPUSH
77894: LD_VAR 0 1
77898: PPUSH
77899: LD_VAR 0 2
77903: PPUSH
77904: CALL_OW 1
77908: ST_TO_ADDR
// end ;
77909: LD_VAR 0 3
77913: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
77914: LD_INT 0
77916: PPUSH
// if not mc_bases [ base ] then
77917: LD_EXP 58
77921: PUSH
77922: LD_VAR 0 1
77926: ARRAY
77927: NOT
77928: IFFALSE 77932
// exit ;
77930: GO 77969
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
77932: LD_ADDR_EXP 79
77936: PUSH
77937: LD_EXP 79
77941: PPUSH
77942: LD_VAR 0 1
77946: PPUSH
77947: LD_EXP 79
77951: PUSH
77952: LD_VAR 0 1
77956: ARRAY
77957: PUSH
77958: LD_VAR 0 2
77962: UNION
77963: PPUSH
77964: CALL_OW 1
77968: ST_TO_ADDR
// end ;
77969: LD_VAR 0 3
77973: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77974: LD_INT 0
77976: PPUSH
// if not mc_bases [ base ] then
77977: LD_EXP 58
77981: PUSH
77982: LD_VAR 0 1
77986: ARRAY
77987: NOT
77988: IFFALSE 77992
// exit ;
77990: GO 78104
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77992: LD_ADDR_EXP 80
77996: PUSH
77997: LD_EXP 80
78001: PPUSH
78002: LD_VAR 0 1
78006: PPUSH
78007: LD_VAR 0 2
78011: PPUSH
78012: CALL_OW 1
78016: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78017: LD_ADDR_EXP 69
78021: PUSH
78022: LD_EXP 69
78026: PPUSH
78027: LD_VAR 0 1
78031: PPUSH
78032: LD_VAR 0 2
78036: PUSH
78037: LD_INT 0
78039: PLUS
78040: PPUSH
78041: CALL_OW 1
78045: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
78046: LD_ADDR_EXP 77
78050: PUSH
78051: LD_EXP 77
78055: PPUSH
78056: LD_VAR 0 1
78060: PPUSH
78061: LD_EXP 77
78065: PUSH
78066: LD_VAR 0 1
78070: ARRAY
78071: PUSH
78072: LD_EXP 80
78076: PUSH
78077: LD_VAR 0 1
78081: ARRAY
78082: PPUSH
78083: LD_INT 21
78085: PUSH
78086: LD_INT 2
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: PPUSH
78093: CALL_OW 72
78097: UNION
78098: PPUSH
78099: CALL_OW 1
78103: ST_TO_ADDR
// end ;
78104: LD_VAR 0 3
78108: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78109: LD_INT 0
78111: PPUSH
// if not mc_bases [ base ] then
78112: LD_EXP 58
78116: PUSH
78117: LD_VAR 0 1
78121: ARRAY
78122: NOT
78123: IFFALSE 78127
// exit ;
78125: GO 78152
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78127: LD_ADDR_EXP 69
78131: PUSH
78132: LD_EXP 69
78136: PPUSH
78137: LD_VAR 0 1
78141: PPUSH
78142: LD_VAR 0 2
78146: PPUSH
78147: CALL_OW 1
78151: ST_TO_ADDR
// end ;
78152: LD_VAR 0 3
78156: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78157: LD_INT 0
78159: PPUSH
78160: PPUSH
78161: PPUSH
78162: PPUSH
// if not mc_bases [ base ] then
78163: LD_EXP 58
78167: PUSH
78168: LD_VAR 0 1
78172: ARRAY
78173: NOT
78174: IFFALSE 78178
// exit ;
78176: GO 78243
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78178: LD_ADDR_EXP 78
78182: PUSH
78183: LD_EXP 78
78187: PPUSH
78188: LD_VAR 0 1
78192: PUSH
78193: LD_EXP 78
78197: PUSH
78198: LD_VAR 0 1
78202: ARRAY
78203: PUSH
78204: LD_INT 1
78206: PLUS
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PPUSH
78212: LD_VAR 0 1
78216: PUSH
78217: LD_VAR 0 2
78221: PUSH
78222: LD_VAR 0 3
78226: PUSH
78227: LD_VAR 0 4
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: PPUSH
78238: CALL 20270 0 3
78242: ST_TO_ADDR
// end ;
78243: LD_VAR 0 5
78247: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78248: LD_INT 0
78250: PPUSH
// if not mc_bases [ base ] then
78251: LD_EXP 58
78255: PUSH
78256: LD_VAR 0 1
78260: ARRAY
78261: NOT
78262: IFFALSE 78266
// exit ;
78264: GO 78291
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78266: LD_ADDR_EXP 95
78270: PUSH
78271: LD_EXP 95
78275: PPUSH
78276: LD_VAR 0 1
78280: PPUSH
78281: LD_VAR 0 2
78285: PPUSH
78286: CALL_OW 1
78290: ST_TO_ADDR
// end ;
78291: LD_VAR 0 3
78295: RET
// export function MC_GetMinesField ( base ) ; begin
78296: LD_INT 0
78298: PPUSH
// result := mc_mines [ base ] ;
78299: LD_ADDR_VAR 0 2
78303: PUSH
78304: LD_EXP 71
78308: PUSH
78309: LD_VAR 0 1
78313: ARRAY
78314: ST_TO_ADDR
// end ;
78315: LD_VAR 0 2
78319: RET
// export function MC_GetProduceList ( base ) ; begin
78320: LD_INT 0
78322: PPUSH
// result := mc_produce [ base ] ;
78323: LD_ADDR_VAR 0 2
78327: PUSH
78328: LD_EXP 79
78332: PUSH
78333: LD_VAR 0 1
78337: ARRAY
78338: ST_TO_ADDR
// end ;
78339: LD_VAR 0 2
78343: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78344: LD_INT 0
78346: PPUSH
78347: PPUSH
// if not mc_bases then
78348: LD_EXP 58
78352: NOT
78353: IFFALSE 78357
// exit ;
78355: GO 78422
// if mc_bases [ base ] then
78357: LD_EXP 58
78361: PUSH
78362: LD_VAR 0 1
78366: ARRAY
78367: IFFALSE 78422
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78369: LD_ADDR_VAR 0 3
78373: PUSH
78374: LD_EXP 58
78378: PUSH
78379: LD_VAR 0 1
78383: ARRAY
78384: PPUSH
78385: LD_INT 30
78387: PUSH
78388: LD_VAR 0 2
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: PPUSH
78397: CALL_OW 72
78401: ST_TO_ADDR
// if result then
78402: LD_VAR 0 3
78406: IFFALSE 78422
// result := result [ 1 ] ;
78408: LD_ADDR_VAR 0 3
78412: PUSH
78413: LD_VAR 0 3
78417: PUSH
78418: LD_INT 1
78420: ARRAY
78421: ST_TO_ADDR
// end ; end ;
78422: LD_VAR 0 3
78426: RET
// export function MC_SetTame ( base , area ) ; begin
78427: LD_INT 0
78429: PPUSH
// if not mc_bases or not base then
78430: LD_EXP 58
78434: NOT
78435: PUSH
78436: LD_VAR 0 1
78440: NOT
78441: OR
78442: IFFALSE 78446
// exit ;
78444: GO 78471
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78446: LD_ADDR_EXP 86
78450: PUSH
78451: LD_EXP 86
78455: PPUSH
78456: LD_VAR 0 1
78460: PPUSH
78461: LD_VAR 0 2
78465: PPUSH
78466: CALL_OW 1
78470: ST_TO_ADDR
// end ;
78471: LD_VAR 0 3
78475: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78476: LD_INT 0
78478: PPUSH
78479: PPUSH
// if not mc_bases or not base then
78480: LD_EXP 58
78484: NOT
78485: PUSH
78486: LD_VAR 0 1
78490: NOT
78491: OR
78492: IFFALSE 78496
// exit ;
78494: GO 78598
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78496: LD_ADDR_VAR 0 4
78500: PUSH
78501: LD_EXP 58
78505: PUSH
78506: LD_VAR 0 1
78510: ARRAY
78511: PPUSH
78512: LD_INT 30
78514: PUSH
78515: LD_VAR 0 2
78519: PUSH
78520: EMPTY
78521: LIST
78522: LIST
78523: PPUSH
78524: CALL_OW 72
78528: ST_TO_ADDR
// if not tmp then
78529: LD_VAR 0 4
78533: NOT
78534: IFFALSE 78538
// exit ;
78536: GO 78598
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78538: LD_ADDR_EXP 90
78542: PUSH
78543: LD_EXP 90
78547: PPUSH
78548: LD_VAR 0 1
78552: PPUSH
78553: LD_EXP 90
78557: PUSH
78558: LD_VAR 0 1
78562: ARRAY
78563: PPUSH
78564: LD_EXP 90
78568: PUSH
78569: LD_VAR 0 1
78573: ARRAY
78574: PUSH
78575: LD_INT 1
78577: PLUS
78578: PPUSH
78579: LD_VAR 0 4
78583: PUSH
78584: LD_INT 1
78586: ARRAY
78587: PPUSH
78588: CALL_OW 2
78592: PPUSH
78593: CALL_OW 1
78597: ST_TO_ADDR
// end ;
78598: LD_VAR 0 3
78602: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78603: LD_INT 0
78605: PPUSH
78606: PPUSH
// if not mc_bases or not base or not kinds then
78607: LD_EXP 58
78611: NOT
78612: PUSH
78613: LD_VAR 0 1
78617: NOT
78618: OR
78619: PUSH
78620: LD_VAR 0 2
78624: NOT
78625: OR
78626: IFFALSE 78630
// exit ;
78628: GO 78691
// for i in kinds do
78630: LD_ADDR_VAR 0 4
78634: PUSH
78635: LD_VAR 0 2
78639: PUSH
78640: FOR_IN
78641: IFFALSE 78689
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78643: LD_ADDR_EXP 92
78647: PUSH
78648: LD_EXP 92
78652: PPUSH
78653: LD_VAR 0 1
78657: PUSH
78658: LD_EXP 92
78662: PUSH
78663: LD_VAR 0 1
78667: ARRAY
78668: PUSH
78669: LD_INT 1
78671: PLUS
78672: PUSH
78673: EMPTY
78674: LIST
78675: LIST
78676: PPUSH
78677: LD_VAR 0 4
78681: PPUSH
78682: CALL 20270 0 3
78686: ST_TO_ADDR
78687: GO 78640
78689: POP
78690: POP
// end ;
78691: LD_VAR 0 3
78695: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78696: LD_INT 0
78698: PPUSH
// if not mc_bases or not base or not areas then
78699: LD_EXP 58
78703: NOT
78704: PUSH
78705: LD_VAR 0 1
78709: NOT
78710: OR
78711: PUSH
78712: LD_VAR 0 2
78716: NOT
78717: OR
78718: IFFALSE 78722
// exit ;
78720: GO 78747
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78722: LD_ADDR_EXP 76
78726: PUSH
78727: LD_EXP 76
78731: PPUSH
78732: LD_VAR 0 1
78736: PPUSH
78737: LD_VAR 0 2
78741: PPUSH
78742: CALL_OW 1
78746: ST_TO_ADDR
// end ;
78747: LD_VAR 0 3
78751: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78752: LD_INT 0
78754: PPUSH
// if not mc_bases or not base or not teleports_exit then
78755: LD_EXP 58
78759: NOT
78760: PUSH
78761: LD_VAR 0 1
78765: NOT
78766: OR
78767: PUSH
78768: LD_VAR 0 2
78772: NOT
78773: OR
78774: IFFALSE 78778
// exit ;
78776: GO 78803
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78778: LD_ADDR_EXP 93
78782: PUSH
78783: LD_EXP 93
78787: PPUSH
78788: LD_VAR 0 1
78792: PPUSH
78793: LD_VAR 0 2
78797: PPUSH
78798: CALL_OW 1
78802: ST_TO_ADDR
// end ;
78803: LD_VAR 0 3
78807: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78808: LD_INT 0
78810: PPUSH
78811: PPUSH
78812: PPUSH
// if not mc_bases or not base or not ext_list then
78813: LD_EXP 58
78817: NOT
78818: PUSH
78819: LD_VAR 0 1
78823: NOT
78824: OR
78825: PUSH
78826: LD_VAR 0 5
78830: NOT
78831: OR
78832: IFFALSE 78836
// exit ;
78834: GO 79009
// tmp := GetFacExtXYD ( x , y , d ) ;
78836: LD_ADDR_VAR 0 8
78840: PUSH
78841: LD_VAR 0 2
78845: PPUSH
78846: LD_VAR 0 3
78850: PPUSH
78851: LD_VAR 0 4
78855: PPUSH
78856: CALL 53585 0 3
78860: ST_TO_ADDR
// if not tmp then
78861: LD_VAR 0 8
78865: NOT
78866: IFFALSE 78870
// exit ;
78868: GO 79009
// for i in tmp do
78870: LD_ADDR_VAR 0 7
78874: PUSH
78875: LD_VAR 0 8
78879: PUSH
78880: FOR_IN
78881: IFFALSE 79007
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78883: LD_ADDR_EXP 63
78887: PUSH
78888: LD_EXP 63
78892: PPUSH
78893: LD_VAR 0 1
78897: PPUSH
78898: LD_EXP 63
78902: PUSH
78903: LD_VAR 0 1
78907: ARRAY
78908: PPUSH
78909: LD_EXP 63
78913: PUSH
78914: LD_VAR 0 1
78918: ARRAY
78919: PUSH
78920: LD_INT 1
78922: PLUS
78923: PPUSH
78924: LD_VAR 0 5
78928: PUSH
78929: LD_INT 1
78931: ARRAY
78932: PUSH
78933: LD_VAR 0 7
78937: PUSH
78938: LD_INT 1
78940: ARRAY
78941: PUSH
78942: LD_VAR 0 7
78946: PUSH
78947: LD_INT 2
78949: ARRAY
78950: PUSH
78951: LD_VAR 0 7
78955: PUSH
78956: LD_INT 3
78958: ARRAY
78959: PUSH
78960: EMPTY
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: PPUSH
78966: CALL_OW 2
78970: PPUSH
78971: CALL_OW 1
78975: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78976: LD_ADDR_VAR 0 5
78980: PUSH
78981: LD_VAR 0 5
78985: PPUSH
78986: LD_INT 1
78988: PPUSH
78989: CALL_OW 3
78993: ST_TO_ADDR
// if not ext_list then
78994: LD_VAR 0 5
78998: NOT
78999: IFFALSE 79005
// exit ;
79001: POP
79002: POP
79003: GO 79009
// end ;
79005: GO 78880
79007: POP
79008: POP
// end ;
79009: LD_VAR 0 6
79013: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79014: LD_INT 0
79016: PPUSH
// if not mc_bases or not base or not weapon_list then
79017: LD_EXP 58
79021: NOT
79022: PUSH
79023: LD_VAR 0 1
79027: NOT
79028: OR
79029: PUSH
79030: LD_VAR 0 2
79034: NOT
79035: OR
79036: IFFALSE 79040
// exit ;
79038: GO 79065
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79040: LD_ADDR_EXP 97
79044: PUSH
79045: LD_EXP 97
79049: PPUSH
79050: LD_VAR 0 1
79054: PPUSH
79055: LD_VAR 0 2
79059: PPUSH
79060: CALL_OW 1
79064: ST_TO_ADDR
// end ;
79065: LD_VAR 0 3
79069: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79070: LD_INT 0
79072: PPUSH
// if not mc_bases or not base or not tech_list then
79073: LD_EXP 58
79077: NOT
79078: PUSH
79079: LD_VAR 0 1
79083: NOT
79084: OR
79085: PUSH
79086: LD_VAR 0 2
79090: NOT
79091: OR
79092: IFFALSE 79096
// exit ;
79094: GO 79121
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79096: LD_ADDR_EXP 85
79100: PUSH
79101: LD_EXP 85
79105: PPUSH
79106: LD_VAR 0 1
79110: PPUSH
79111: LD_VAR 0 2
79115: PPUSH
79116: CALL_OW 1
79120: ST_TO_ADDR
// end ;
79121: LD_VAR 0 3
79125: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79126: LD_INT 0
79128: PPUSH
// if not mc_bases or not parking_area or not base then
79129: LD_EXP 58
79133: NOT
79134: PUSH
79135: LD_VAR 0 2
79139: NOT
79140: OR
79141: PUSH
79142: LD_VAR 0 1
79146: NOT
79147: OR
79148: IFFALSE 79152
// exit ;
79150: GO 79177
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79152: LD_ADDR_EXP 82
79156: PUSH
79157: LD_EXP 82
79161: PPUSH
79162: LD_VAR 0 1
79166: PPUSH
79167: LD_VAR 0 2
79171: PPUSH
79172: CALL_OW 1
79176: ST_TO_ADDR
// end ;
79177: LD_VAR 0 3
79181: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79182: LD_INT 0
79184: PPUSH
// if not mc_bases or not base or not scan_area then
79185: LD_EXP 58
79189: NOT
79190: PUSH
79191: LD_VAR 0 1
79195: NOT
79196: OR
79197: PUSH
79198: LD_VAR 0 2
79202: NOT
79203: OR
79204: IFFALSE 79208
// exit ;
79206: GO 79233
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79208: LD_ADDR_EXP 83
79212: PUSH
79213: LD_EXP 83
79217: PPUSH
79218: LD_VAR 0 1
79222: PPUSH
79223: LD_VAR 0 2
79227: PPUSH
79228: CALL_OW 1
79232: ST_TO_ADDR
// end ;
79233: LD_VAR 0 3
79237: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79238: LD_INT 0
79240: PPUSH
79241: PPUSH
// if not mc_bases or not base then
79242: LD_EXP 58
79246: NOT
79247: PUSH
79248: LD_VAR 0 1
79252: NOT
79253: OR
79254: IFFALSE 79258
// exit ;
79256: GO 79322
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79258: LD_ADDR_VAR 0 3
79262: PUSH
79263: LD_INT 1
79265: PUSH
79266: LD_INT 2
79268: PUSH
79269: LD_INT 3
79271: PUSH
79272: LD_INT 4
79274: PUSH
79275: LD_INT 11
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: LIST
79282: LIST
79283: LIST
79284: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79285: LD_ADDR_EXP 85
79289: PUSH
79290: LD_EXP 85
79294: PPUSH
79295: LD_VAR 0 1
79299: PPUSH
79300: LD_EXP 85
79304: PUSH
79305: LD_VAR 0 1
79309: ARRAY
79310: PUSH
79311: LD_VAR 0 3
79315: DIFF
79316: PPUSH
79317: CALL_OW 1
79321: ST_TO_ADDR
// end ; end_of_file
79322: LD_VAR 0 2
79326: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
79327: LD_INT 0
79329: PPUSH
79330: PPUSH
79331: PPUSH
// if not mc_bases or not skirmish then
79332: LD_EXP 58
79336: NOT
79337: PUSH
79338: LD_EXP 56
79342: NOT
79343: OR
79344: IFFALSE 79348
// exit ;
79346: GO 79513
// for i = 1 to mc_bases do
79348: LD_ADDR_VAR 0 4
79352: PUSH
79353: DOUBLE
79354: LD_INT 1
79356: DEC
79357: ST_TO_ADDR
79358: LD_EXP 58
79362: PUSH
79363: FOR_TO
79364: IFFALSE 79511
// begin if sci in mc_bases [ i ] then
79366: LD_VAR 0 2
79370: PUSH
79371: LD_EXP 58
79375: PUSH
79376: LD_VAR 0 4
79380: ARRAY
79381: IN
79382: IFFALSE 79509
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
79384: LD_ADDR_EXP 87
79388: PUSH
79389: LD_EXP 87
79393: PPUSH
79394: LD_VAR 0 4
79398: PUSH
79399: LD_EXP 87
79403: PUSH
79404: LD_VAR 0 4
79408: ARRAY
79409: PUSH
79410: LD_INT 1
79412: PLUS
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PPUSH
79418: LD_VAR 0 1
79422: PPUSH
79423: CALL 20270 0 3
79427: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
79428: LD_ADDR_VAR 0 5
79432: PUSH
79433: LD_EXP 58
79437: PUSH
79438: LD_VAR 0 4
79442: ARRAY
79443: PPUSH
79444: LD_INT 2
79446: PUSH
79447: LD_INT 30
79449: PUSH
79450: LD_INT 0
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 30
79459: PUSH
79460: LD_INT 1
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: LIST
79471: PPUSH
79472: CALL_OW 72
79476: PPUSH
79477: LD_VAR 0 1
79481: PPUSH
79482: CALL_OW 74
79486: ST_TO_ADDR
// if tmp then
79487: LD_VAR 0 5
79491: IFFALSE 79507
// ComStandNearbyBuilding ( ape , tmp ) ;
79493: LD_VAR 0 1
79497: PPUSH
79498: LD_VAR 0 5
79502: PPUSH
79503: CALL 14947 0 2
// break ;
79507: GO 79511
// end ; end ;
79509: GO 79363
79511: POP
79512: POP
// end ;
79513: LD_VAR 0 3
79517: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79518: LD_INT 0
79520: PPUSH
79521: PPUSH
79522: PPUSH
// if not mc_bases or not skirmish then
79523: LD_EXP 58
79527: NOT
79528: PUSH
79529: LD_EXP 56
79533: NOT
79534: OR
79535: IFFALSE 79539
// exit ;
79537: GO 79628
// for i = 1 to mc_bases do
79539: LD_ADDR_VAR 0 4
79543: PUSH
79544: DOUBLE
79545: LD_INT 1
79547: DEC
79548: ST_TO_ADDR
79549: LD_EXP 58
79553: PUSH
79554: FOR_TO
79555: IFFALSE 79626
// begin if building in mc_busy_turret_list [ i ] then
79557: LD_VAR 0 1
79561: PUSH
79562: LD_EXP 68
79566: PUSH
79567: LD_VAR 0 4
79571: ARRAY
79572: IN
79573: IFFALSE 79624
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79575: LD_ADDR_VAR 0 5
79579: PUSH
79580: LD_EXP 68
79584: PUSH
79585: LD_VAR 0 4
79589: ARRAY
79590: PUSH
79591: LD_VAR 0 1
79595: DIFF
79596: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79597: LD_ADDR_EXP 68
79601: PUSH
79602: LD_EXP 68
79606: PPUSH
79607: LD_VAR 0 4
79611: PPUSH
79612: LD_VAR 0 5
79616: PPUSH
79617: CALL_OW 1
79621: ST_TO_ADDR
// break ;
79622: GO 79626
// end ; end ;
79624: GO 79554
79626: POP
79627: POP
// end ;
79628: LD_VAR 0 3
79632: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79633: LD_INT 0
79635: PPUSH
79636: PPUSH
79637: PPUSH
// if not mc_bases or not skirmish then
79638: LD_EXP 58
79642: NOT
79643: PUSH
79644: LD_EXP 56
79648: NOT
79649: OR
79650: IFFALSE 79654
// exit ;
79652: GO 79853
// for i = 1 to mc_bases do
79654: LD_ADDR_VAR 0 5
79658: PUSH
79659: DOUBLE
79660: LD_INT 1
79662: DEC
79663: ST_TO_ADDR
79664: LD_EXP 58
79668: PUSH
79669: FOR_TO
79670: IFFALSE 79851
// if building in mc_bases [ i ] then
79672: LD_VAR 0 1
79676: PUSH
79677: LD_EXP 58
79681: PUSH
79682: LD_VAR 0 5
79686: ARRAY
79687: IN
79688: IFFALSE 79849
// begin tmp := mc_bases [ i ] diff building ;
79690: LD_ADDR_VAR 0 6
79694: PUSH
79695: LD_EXP 58
79699: PUSH
79700: LD_VAR 0 5
79704: ARRAY
79705: PUSH
79706: LD_VAR 0 1
79710: DIFF
79711: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79712: LD_ADDR_EXP 58
79716: PUSH
79717: LD_EXP 58
79721: PPUSH
79722: LD_VAR 0 5
79726: PPUSH
79727: LD_VAR 0 6
79731: PPUSH
79732: CALL_OW 1
79736: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79737: LD_VAR 0 1
79741: PUSH
79742: LD_EXP 66
79746: PUSH
79747: LD_VAR 0 5
79751: ARRAY
79752: IN
79753: IFFALSE 79792
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79755: LD_ADDR_EXP 66
79759: PUSH
79760: LD_EXP 66
79764: PPUSH
79765: LD_VAR 0 5
79769: PPUSH
79770: LD_EXP 66
79774: PUSH
79775: LD_VAR 0 5
79779: ARRAY
79780: PUSH
79781: LD_VAR 0 1
79785: DIFF
79786: PPUSH
79787: CALL_OW 1
79791: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79792: LD_VAR 0 1
79796: PUSH
79797: LD_EXP 67
79801: PUSH
79802: LD_VAR 0 5
79806: ARRAY
79807: IN
79808: IFFALSE 79847
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79810: LD_ADDR_EXP 67
79814: PUSH
79815: LD_EXP 67
79819: PPUSH
79820: LD_VAR 0 5
79824: PPUSH
79825: LD_EXP 67
79829: PUSH
79830: LD_VAR 0 5
79834: ARRAY
79835: PUSH
79836: LD_VAR 0 1
79840: DIFF
79841: PPUSH
79842: CALL_OW 1
79846: ST_TO_ADDR
// break ;
79847: GO 79851
// end ;
79849: GO 79669
79851: POP
79852: POP
// end ;
79853: LD_VAR 0 4
79857: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79858: LD_INT 0
79860: PPUSH
79861: PPUSH
79862: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
79863: LD_EXP 58
79867: NOT
79868: PUSH
79869: LD_EXP 56
79873: NOT
79874: OR
79875: PUSH
79876: LD_VAR 0 3
79880: PUSH
79881: LD_EXP 84
79885: IN
79886: NOT
79887: OR
79888: IFFALSE 79892
// exit ;
79890: GO 80015
// for i = 1 to mc_vehicles do
79892: LD_ADDR_VAR 0 6
79896: PUSH
79897: DOUBLE
79898: LD_INT 1
79900: DEC
79901: ST_TO_ADDR
79902: LD_EXP 77
79906: PUSH
79907: FOR_TO
79908: IFFALSE 80013
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79910: LD_VAR 0 2
79914: PUSH
79915: LD_EXP 77
79919: PUSH
79920: LD_VAR 0 6
79924: ARRAY
79925: IN
79926: PUSH
79927: LD_VAR 0 1
79931: PUSH
79932: LD_EXP 77
79936: PUSH
79937: LD_VAR 0 6
79941: ARRAY
79942: IN
79943: OR
79944: IFFALSE 80011
// begin tmp := mc_vehicles [ i ] diff old ;
79946: LD_ADDR_VAR 0 7
79950: PUSH
79951: LD_EXP 77
79955: PUSH
79956: LD_VAR 0 6
79960: ARRAY
79961: PUSH
79962: LD_VAR 0 2
79966: DIFF
79967: ST_TO_ADDR
// tmp := tmp diff new ;
79968: LD_ADDR_VAR 0 7
79972: PUSH
79973: LD_VAR 0 7
79977: PUSH
79978: LD_VAR 0 1
79982: DIFF
79983: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79984: LD_ADDR_EXP 77
79988: PUSH
79989: LD_EXP 77
79993: PPUSH
79994: LD_VAR 0 6
79998: PPUSH
79999: LD_VAR 0 7
80003: PPUSH
80004: CALL_OW 1
80008: ST_TO_ADDR
// break ;
80009: GO 80013
// end ;
80011: GO 79907
80013: POP
80014: POP
// end ;
80015: LD_VAR 0 5
80019: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80020: LD_INT 0
80022: PPUSH
80023: PPUSH
80024: PPUSH
80025: PPUSH
// if not mc_bases or not skirmish then
80026: LD_EXP 58
80030: NOT
80031: PUSH
80032: LD_EXP 56
80036: NOT
80037: OR
80038: IFFALSE 80042
// exit ;
80040: GO 80425
// side := GetSide ( vehicle ) ;
80042: LD_ADDR_VAR 0 5
80046: PUSH
80047: LD_VAR 0 1
80051: PPUSH
80052: CALL_OW 255
80056: ST_TO_ADDR
// for i = 1 to mc_bases do
80057: LD_ADDR_VAR 0 4
80061: PUSH
80062: DOUBLE
80063: LD_INT 1
80065: DEC
80066: ST_TO_ADDR
80067: LD_EXP 58
80071: PUSH
80072: FOR_TO
80073: IFFALSE 80423
// begin if factory in mc_bases [ i ] then
80075: LD_VAR 0 2
80079: PUSH
80080: LD_EXP 58
80084: PUSH
80085: LD_VAR 0 4
80089: ARRAY
80090: IN
80091: IFFALSE 80421
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
80093: LD_EXP 80
80097: PUSH
80098: LD_VAR 0 4
80102: ARRAY
80103: PUSH
80104: LD_EXP 69
80108: PUSH
80109: LD_VAR 0 4
80113: ARRAY
80114: LESS
80115: PUSH
80116: LD_VAR 0 1
80120: PPUSH
80121: CALL_OW 264
80125: PUSH
80126: LD_INT 31
80128: PUSH
80129: LD_INT 32
80131: PUSH
80132: LD_INT 51
80134: PUSH
80135: LD_EXP 102
80139: PUSH
80140: LD_INT 12
80142: PUSH
80143: LD_INT 30
80145: PUSH
80146: LD_EXP 101
80150: PUSH
80151: LD_INT 11
80153: PUSH
80154: LD_INT 53
80156: PUSH
80157: LD_INT 14
80159: PUSH
80160: LD_EXP 105
80164: PUSH
80165: LD_INT 29
80167: PUSH
80168: LD_EXP 103
80172: PUSH
80173: LD_INT 13
80175: PUSH
80176: LD_INT 52
80178: PUSH
80179: LD_INT 48
80181: PUSH
80182: LD_INT 8
80184: PUSH
80185: EMPTY
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: LIST
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: LIST
80202: LIST
80203: IN
80204: NOT
80205: AND
80206: IFFALSE 80247
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
80208: LD_ADDR_EXP 80
80212: PUSH
80213: LD_EXP 80
80217: PPUSH
80218: LD_VAR 0 4
80222: PPUSH
80223: LD_EXP 80
80227: PUSH
80228: LD_VAR 0 4
80232: ARRAY
80233: PUSH
80234: LD_VAR 0 1
80238: ADD
80239: PPUSH
80240: CALL_OW 1
80244: ST_TO_ADDR
80245: GO 80291
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80247: LD_ADDR_EXP 77
80251: PUSH
80252: LD_EXP 77
80256: PPUSH
80257: LD_VAR 0 4
80261: PUSH
80262: LD_EXP 77
80266: PUSH
80267: LD_VAR 0 4
80271: ARRAY
80272: PUSH
80273: LD_INT 1
80275: PLUS
80276: PUSH
80277: EMPTY
80278: LIST
80279: LIST
80280: PPUSH
80281: LD_VAR 0 1
80285: PPUSH
80286: CALL 20270 0 3
80290: ST_TO_ADDR
// if not mc_scan [ i ] then
80291: LD_EXP 81
80295: PUSH
80296: LD_VAR 0 4
80300: ARRAY
80301: NOT
80302: IFFALSE 80421
// begin if GetControl ( vehicle ) = control_remote then
80304: LD_VAR 0 1
80308: PPUSH
80309: CALL_OW 263
80313: PUSH
80314: LD_INT 2
80316: EQUAL
80317: IFFALSE 80337
// repeat wait ( 0 0$1 ) ;
80319: LD_INT 35
80321: PPUSH
80322: CALL_OW 67
// until IsControledBy ( vehicle ) ;
80326: LD_VAR 0 1
80330: PPUSH
80331: CALL_OW 312
80335: IFFALSE 80319
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
80337: LD_VAR 0 1
80341: PPUSH
80342: LD_EXP 82
80346: PUSH
80347: LD_VAR 0 4
80351: ARRAY
80352: PPUSH
80353: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
80357: LD_VAR 0 1
80361: PPUSH
80362: CALL_OW 263
80366: PUSH
80367: LD_INT 1
80369: NONEQUAL
80370: IFFALSE 80374
// break ;
80372: GO 80423
// repeat wait ( 0 0$1 ) ;
80374: LD_INT 35
80376: PPUSH
80377: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
80381: LD_VAR 0 1
80385: PPUSH
80386: LD_EXP 82
80390: PUSH
80391: LD_VAR 0 4
80395: ARRAY
80396: PPUSH
80397: CALL_OW 308
80401: IFFALSE 80374
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
80403: LD_VAR 0 1
80407: PPUSH
80408: CALL_OW 311
80412: PPUSH
80413: CALL_OW 121
// exit ;
80417: POP
80418: POP
80419: GO 80425
// end ; end ; end ;
80421: GO 80072
80423: POP
80424: POP
// end ;
80425: LD_VAR 0 3
80429: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
80430: LD_INT 0
80432: PPUSH
80433: PPUSH
80434: PPUSH
80435: PPUSH
// if not mc_bases or not skirmish then
80436: LD_EXP 58
80440: NOT
80441: PUSH
80442: LD_EXP 56
80446: NOT
80447: OR
80448: IFFALSE 80452
// exit ;
80450: GO 80805
// repeat wait ( 0 0$1 ) ;
80452: LD_INT 35
80454: PPUSH
80455: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
80459: LD_VAR 0 2
80463: PPUSH
80464: LD_VAR 0 3
80468: PPUSH
80469: CALL_OW 284
80473: IFFALSE 80452
// if GetResourceTypeXY ( x , y ) = mat_artefact then
80475: LD_VAR 0 2
80479: PPUSH
80480: LD_VAR 0 3
80484: PPUSH
80485: CALL_OW 283
80489: PUSH
80490: LD_INT 4
80492: EQUAL
80493: IFFALSE 80497
// exit ;
80495: GO 80805
// for i = 1 to mc_bases do
80497: LD_ADDR_VAR 0 7
80501: PUSH
80502: DOUBLE
80503: LD_INT 1
80505: DEC
80506: ST_TO_ADDR
80507: LD_EXP 58
80511: PUSH
80512: FOR_TO
80513: IFFALSE 80803
// begin if mc_crates_area [ i ] then
80515: LD_EXP 76
80519: PUSH
80520: LD_VAR 0 7
80524: ARRAY
80525: IFFALSE 80636
// for j in mc_crates_area [ i ] do
80527: LD_ADDR_VAR 0 8
80531: PUSH
80532: LD_EXP 76
80536: PUSH
80537: LD_VAR 0 7
80541: ARRAY
80542: PUSH
80543: FOR_IN
80544: IFFALSE 80634
// if InArea ( x , y , j ) then
80546: LD_VAR 0 2
80550: PPUSH
80551: LD_VAR 0 3
80555: PPUSH
80556: LD_VAR 0 8
80560: PPUSH
80561: CALL_OW 309
80565: IFFALSE 80632
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80567: LD_ADDR_EXP 74
80571: PUSH
80572: LD_EXP 74
80576: PPUSH
80577: LD_VAR 0 7
80581: PUSH
80582: LD_EXP 74
80586: PUSH
80587: LD_VAR 0 7
80591: ARRAY
80592: PUSH
80593: LD_INT 1
80595: PLUS
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PPUSH
80601: LD_VAR 0 4
80605: PUSH
80606: LD_VAR 0 2
80610: PUSH
80611: LD_VAR 0 3
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: LIST
80620: PPUSH
80621: CALL 20270 0 3
80625: ST_TO_ADDR
// exit ;
80626: POP
80627: POP
80628: POP
80629: POP
80630: GO 80805
// end ;
80632: GO 80543
80634: POP
80635: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80636: LD_ADDR_VAR 0 9
80640: PUSH
80641: LD_EXP 58
80645: PUSH
80646: LD_VAR 0 7
80650: ARRAY
80651: PPUSH
80652: LD_INT 2
80654: PUSH
80655: LD_INT 30
80657: PUSH
80658: LD_INT 0
80660: PUSH
80661: EMPTY
80662: LIST
80663: LIST
80664: PUSH
80665: LD_INT 30
80667: PUSH
80668: LD_INT 1
80670: PUSH
80671: EMPTY
80672: LIST
80673: LIST
80674: PUSH
80675: EMPTY
80676: LIST
80677: LIST
80678: LIST
80679: PPUSH
80680: CALL_OW 72
80684: ST_TO_ADDR
// if not depot then
80685: LD_VAR 0 9
80689: NOT
80690: IFFALSE 80694
// continue ;
80692: GO 80512
// for j in depot do
80694: LD_ADDR_VAR 0 8
80698: PUSH
80699: LD_VAR 0 9
80703: PUSH
80704: FOR_IN
80705: IFFALSE 80799
// if GetDistUnitXY ( j , x , y ) < 30 then
80707: LD_VAR 0 8
80711: PPUSH
80712: LD_VAR 0 2
80716: PPUSH
80717: LD_VAR 0 3
80721: PPUSH
80722: CALL_OW 297
80726: PUSH
80727: LD_INT 30
80729: LESS
80730: IFFALSE 80797
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80732: LD_ADDR_EXP 74
80736: PUSH
80737: LD_EXP 74
80741: PPUSH
80742: LD_VAR 0 7
80746: PUSH
80747: LD_EXP 74
80751: PUSH
80752: LD_VAR 0 7
80756: ARRAY
80757: PUSH
80758: LD_INT 1
80760: PLUS
80761: PUSH
80762: EMPTY
80763: LIST
80764: LIST
80765: PPUSH
80766: LD_VAR 0 4
80770: PUSH
80771: LD_VAR 0 2
80775: PUSH
80776: LD_VAR 0 3
80780: PUSH
80781: EMPTY
80782: LIST
80783: LIST
80784: LIST
80785: PPUSH
80786: CALL 20270 0 3
80790: ST_TO_ADDR
// exit ;
80791: POP
80792: POP
80793: POP
80794: POP
80795: GO 80805
// end ;
80797: GO 80704
80799: POP
80800: POP
// end ;
80801: GO 80512
80803: POP
80804: POP
// end ;
80805: LD_VAR 0 6
80809: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80810: LD_INT 0
80812: PPUSH
80813: PPUSH
80814: PPUSH
80815: PPUSH
// if not mc_bases or not skirmish then
80816: LD_EXP 58
80820: NOT
80821: PUSH
80822: LD_EXP 56
80826: NOT
80827: OR
80828: IFFALSE 80832
// exit ;
80830: GO 81109
// side := GetSide ( lab ) ;
80832: LD_ADDR_VAR 0 4
80836: PUSH
80837: LD_VAR 0 2
80841: PPUSH
80842: CALL_OW 255
80846: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80847: LD_VAR 0 4
80851: PUSH
80852: LD_EXP 84
80856: IN
80857: NOT
80858: PUSH
80859: LD_EXP 85
80863: NOT
80864: OR
80865: PUSH
80866: LD_EXP 58
80870: NOT
80871: OR
80872: IFFALSE 80876
// exit ;
80874: GO 81109
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80876: LD_ADDR_EXP 85
80880: PUSH
80881: LD_EXP 85
80885: PPUSH
80886: LD_VAR 0 4
80890: PPUSH
80891: LD_EXP 85
80895: PUSH
80896: LD_VAR 0 4
80900: ARRAY
80901: PUSH
80902: LD_VAR 0 1
80906: DIFF
80907: PPUSH
80908: CALL_OW 1
80912: ST_TO_ADDR
// for i = 1 to mc_bases do
80913: LD_ADDR_VAR 0 5
80917: PUSH
80918: DOUBLE
80919: LD_INT 1
80921: DEC
80922: ST_TO_ADDR
80923: LD_EXP 58
80927: PUSH
80928: FOR_TO
80929: IFFALSE 81107
// begin if lab in mc_bases [ i ] then
80931: LD_VAR 0 2
80935: PUSH
80936: LD_EXP 58
80940: PUSH
80941: LD_VAR 0 5
80945: ARRAY
80946: IN
80947: IFFALSE 81105
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80949: LD_VAR 0 1
80953: PUSH
80954: LD_INT 11
80956: PUSH
80957: LD_INT 4
80959: PUSH
80960: LD_INT 3
80962: PUSH
80963: LD_INT 2
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: LIST
80970: LIST
80971: IN
80972: PUSH
80973: LD_EXP 88
80977: PUSH
80978: LD_VAR 0 5
80982: ARRAY
80983: AND
80984: IFFALSE 81105
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80986: LD_ADDR_VAR 0 6
80990: PUSH
80991: LD_EXP 88
80995: PUSH
80996: LD_VAR 0 5
81000: ARRAY
81001: PUSH
81002: LD_INT 1
81004: ARRAY
81005: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81006: LD_ADDR_EXP 88
81010: PUSH
81011: LD_EXP 88
81015: PPUSH
81016: LD_VAR 0 5
81020: PPUSH
81021: EMPTY
81022: PPUSH
81023: CALL_OW 1
81027: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81028: LD_VAR 0 6
81032: PPUSH
81033: LD_INT 0
81035: PPUSH
81036: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81040: LD_VAR 0 6
81044: PPUSH
81045: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81049: LD_ADDR_EXP 87
81053: PUSH
81054: LD_EXP 87
81058: PPUSH
81059: LD_VAR 0 5
81063: PPUSH
81064: LD_EXP 87
81068: PUSH
81069: LD_VAR 0 5
81073: ARRAY
81074: PPUSH
81075: LD_INT 1
81077: PPUSH
81078: LD_VAR 0 6
81082: PPUSH
81083: CALL_OW 2
81087: PPUSH
81088: CALL_OW 1
81092: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81093: LD_VAR 0 5
81097: PPUSH
81098: LD_INT 112
81100: PPUSH
81101: CALL 59036 0 2
// end ; end ; end ;
81105: GO 80928
81107: POP
81108: POP
// end ;
81109: LD_VAR 0 3
81113: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81114: LD_INT 0
81116: PPUSH
81117: PPUSH
81118: PPUSH
81119: PPUSH
81120: PPUSH
81121: PPUSH
81122: PPUSH
81123: PPUSH
// if not mc_bases or not skirmish then
81124: LD_EXP 58
81128: NOT
81129: PUSH
81130: LD_EXP 56
81134: NOT
81135: OR
81136: IFFALSE 81140
// exit ;
81138: GO 82083
// for i = 1 to mc_bases do
81140: LD_ADDR_VAR 0 3
81144: PUSH
81145: DOUBLE
81146: LD_INT 1
81148: DEC
81149: ST_TO_ADDR
81150: LD_EXP 58
81154: PUSH
81155: FOR_TO
81156: IFFALSE 82081
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81158: LD_VAR 0 1
81162: PUSH
81163: LD_EXP 58
81167: PUSH
81168: LD_VAR 0 3
81172: ARRAY
81173: IN
81174: PUSH
81175: LD_VAR 0 1
81179: PUSH
81180: LD_EXP 65
81184: PUSH
81185: LD_VAR 0 3
81189: ARRAY
81190: IN
81191: OR
81192: PUSH
81193: LD_VAR 0 1
81197: PUSH
81198: LD_EXP 77
81202: PUSH
81203: LD_VAR 0 3
81207: ARRAY
81208: IN
81209: OR
81210: PUSH
81211: LD_VAR 0 1
81215: PUSH
81216: LD_EXP 87
81220: PUSH
81221: LD_VAR 0 3
81225: ARRAY
81226: IN
81227: OR
81228: PUSH
81229: LD_VAR 0 1
81233: PUSH
81234: LD_EXP 88
81238: PUSH
81239: LD_VAR 0 3
81243: ARRAY
81244: IN
81245: OR
81246: IFFALSE 82079
// begin if un in mc_ape [ i ] then
81248: LD_VAR 0 1
81252: PUSH
81253: LD_EXP 87
81257: PUSH
81258: LD_VAR 0 3
81262: ARRAY
81263: IN
81264: IFFALSE 81303
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
81266: LD_ADDR_EXP 87
81270: PUSH
81271: LD_EXP 87
81275: PPUSH
81276: LD_VAR 0 3
81280: PPUSH
81281: LD_EXP 87
81285: PUSH
81286: LD_VAR 0 3
81290: ARRAY
81291: PUSH
81292: LD_VAR 0 1
81296: DIFF
81297: PPUSH
81298: CALL_OW 1
81302: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
81303: LD_VAR 0 1
81307: PUSH
81308: LD_EXP 88
81312: PUSH
81313: LD_VAR 0 3
81317: ARRAY
81318: IN
81319: IFFALSE 81343
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81321: LD_ADDR_EXP 88
81325: PUSH
81326: LD_EXP 88
81330: PPUSH
81331: LD_VAR 0 3
81335: PPUSH
81336: EMPTY
81337: PPUSH
81338: CALL_OW 1
81342: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
81343: LD_VAR 0 1
81347: PPUSH
81348: CALL_OW 247
81352: PUSH
81353: LD_INT 2
81355: EQUAL
81356: PUSH
81357: LD_VAR 0 1
81361: PPUSH
81362: CALL_OW 110
81366: PUSH
81367: LD_INT 20
81369: EQUAL
81370: AND
81371: IFFALSE 81474
// begin fac := MC_GetBuilding ( i , b_factory ) ;
81373: LD_ADDR_VAR 0 8
81377: PUSH
81378: LD_VAR 0 3
81382: PPUSH
81383: LD_INT 3
81385: PPUSH
81386: CALL 78344 0 2
81390: ST_TO_ADDR
// if fac then
81391: LD_VAR 0 8
81395: IFFALSE 81474
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
81397: LD_ADDR_VAR 0 9
81401: PUSH
81402: LD_VAR 0 8
81406: PPUSH
81407: LD_VAR 0 1
81411: PPUSH
81412: CALL_OW 265
81416: PPUSH
81417: LD_VAR 0 1
81421: PPUSH
81422: CALL_OW 262
81426: PPUSH
81427: LD_VAR 0 1
81431: PPUSH
81432: CALL_OW 263
81436: PPUSH
81437: LD_VAR 0 1
81441: PPUSH
81442: CALL_OW 264
81446: PPUSH
81447: CALL 17870 0 5
81451: ST_TO_ADDR
// if components then
81452: LD_VAR 0 9
81456: IFFALSE 81472
// MC_InsertProduceList ( i , components ) ;
81458: LD_VAR 0 3
81462: PPUSH
81463: LD_VAR 0 9
81467: PPUSH
81468: CALL 77914 0 2
// break ;
81472: GO 82081
// end ; end ; if GetType ( un ) = unit_building then
81474: LD_VAR 0 1
81478: PPUSH
81479: CALL_OW 247
81483: PUSH
81484: LD_INT 3
81486: EQUAL
81487: IFFALSE 81802
// begin btype := GetBType ( un ) ;
81489: LD_ADDR_VAR 0 5
81493: PUSH
81494: LD_VAR 0 1
81498: PPUSH
81499: CALL_OW 266
81503: ST_TO_ADDR
// if btype = b_warehouse then
81504: LD_VAR 0 5
81508: PUSH
81509: LD_INT 1
81511: EQUAL
81512: IFFALSE 81530
// begin btype := b_depot ;
81514: LD_ADDR_VAR 0 5
81518: PUSH
81519: LD_INT 0
81521: ST_TO_ADDR
// pos := 1 ;
81522: LD_ADDR_VAR 0 6
81526: PUSH
81527: LD_INT 1
81529: ST_TO_ADDR
// end ; if btype = b_factory then
81530: LD_VAR 0 5
81534: PUSH
81535: LD_INT 3
81537: EQUAL
81538: IFFALSE 81556
// begin btype := b_workshop ;
81540: LD_ADDR_VAR 0 5
81544: PUSH
81545: LD_INT 2
81547: ST_TO_ADDR
// pos := 1 ;
81548: LD_ADDR_VAR 0 6
81552: PUSH
81553: LD_INT 1
81555: ST_TO_ADDR
// end ; if btype = b_barracks then
81556: LD_VAR 0 5
81560: PUSH
81561: LD_INT 5
81563: EQUAL
81564: IFFALSE 81574
// btype := b_armoury ;
81566: LD_ADDR_VAR 0 5
81570: PUSH
81571: LD_INT 4
81573: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81574: LD_VAR 0 5
81578: PUSH
81579: LD_INT 7
81581: PUSH
81582: LD_INT 8
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: IN
81589: IFFALSE 81599
// btype := b_lab ;
81591: LD_ADDR_VAR 0 5
81595: PUSH
81596: LD_INT 6
81598: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81599: LD_ADDR_EXP 63
81603: PUSH
81604: LD_EXP 63
81608: PPUSH
81609: LD_VAR 0 3
81613: PUSH
81614: LD_EXP 63
81618: PUSH
81619: LD_VAR 0 3
81623: ARRAY
81624: PUSH
81625: LD_INT 1
81627: PLUS
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PPUSH
81633: LD_VAR 0 5
81637: PUSH
81638: LD_VAR 0 1
81642: PPUSH
81643: CALL_OW 250
81647: PUSH
81648: LD_VAR 0 1
81652: PPUSH
81653: CALL_OW 251
81657: PUSH
81658: LD_VAR 0 1
81662: PPUSH
81663: CALL_OW 254
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: LIST
81672: LIST
81673: PPUSH
81674: CALL 20270 0 3
81678: ST_TO_ADDR
// if pos = 1 then
81679: LD_VAR 0 6
81683: PUSH
81684: LD_INT 1
81686: EQUAL
81687: IFFALSE 81802
// begin tmp := mc_build_list [ i ] ;
81689: LD_ADDR_VAR 0 7
81693: PUSH
81694: LD_EXP 63
81698: PUSH
81699: LD_VAR 0 3
81703: ARRAY
81704: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81705: LD_VAR 0 7
81709: PPUSH
81710: LD_INT 2
81712: PUSH
81713: LD_INT 30
81715: PUSH
81716: LD_INT 0
81718: PUSH
81719: EMPTY
81720: LIST
81721: LIST
81722: PUSH
81723: LD_INT 30
81725: PUSH
81726: LD_INT 1
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: LIST
81737: PPUSH
81738: CALL_OW 72
81742: IFFALSE 81752
// pos := 2 ;
81744: LD_ADDR_VAR 0 6
81748: PUSH
81749: LD_INT 2
81751: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81752: LD_ADDR_VAR 0 7
81756: PUSH
81757: LD_VAR 0 7
81761: PPUSH
81762: LD_VAR 0 6
81766: PPUSH
81767: LD_VAR 0 7
81771: PPUSH
81772: CALL 20596 0 3
81776: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81777: LD_ADDR_EXP 63
81781: PUSH
81782: LD_EXP 63
81786: PPUSH
81787: LD_VAR 0 3
81791: PPUSH
81792: LD_VAR 0 7
81796: PPUSH
81797: CALL_OW 1
81801: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81802: LD_VAR 0 1
81806: PUSH
81807: LD_EXP 58
81811: PUSH
81812: LD_VAR 0 3
81816: ARRAY
81817: IN
81818: IFFALSE 81857
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81820: LD_ADDR_EXP 58
81824: PUSH
81825: LD_EXP 58
81829: PPUSH
81830: LD_VAR 0 3
81834: PPUSH
81835: LD_EXP 58
81839: PUSH
81840: LD_VAR 0 3
81844: ARRAY
81845: PUSH
81846: LD_VAR 0 1
81850: DIFF
81851: PPUSH
81852: CALL_OW 1
81856: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81857: LD_VAR 0 1
81861: PUSH
81862: LD_EXP 65
81866: PUSH
81867: LD_VAR 0 3
81871: ARRAY
81872: IN
81873: IFFALSE 81912
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81875: LD_ADDR_EXP 65
81879: PUSH
81880: LD_EXP 65
81884: PPUSH
81885: LD_VAR 0 3
81889: PPUSH
81890: LD_EXP 65
81894: PUSH
81895: LD_VAR 0 3
81899: ARRAY
81900: PUSH
81901: LD_VAR 0 1
81905: DIFF
81906: PPUSH
81907: CALL_OW 1
81911: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81912: LD_VAR 0 1
81916: PUSH
81917: LD_EXP 77
81921: PUSH
81922: LD_VAR 0 3
81926: ARRAY
81927: IN
81928: IFFALSE 81967
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81930: LD_ADDR_EXP 77
81934: PUSH
81935: LD_EXP 77
81939: PPUSH
81940: LD_VAR 0 3
81944: PPUSH
81945: LD_EXP 77
81949: PUSH
81950: LD_VAR 0 3
81954: ARRAY
81955: PUSH
81956: LD_VAR 0 1
81960: DIFF
81961: PPUSH
81962: CALL_OW 1
81966: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81967: LD_VAR 0 1
81971: PUSH
81972: LD_EXP 67
81976: PUSH
81977: LD_VAR 0 3
81981: ARRAY
81982: IN
81983: IFFALSE 82022
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81985: LD_ADDR_EXP 67
81989: PUSH
81990: LD_EXP 67
81994: PPUSH
81995: LD_VAR 0 3
81999: PPUSH
82000: LD_EXP 67
82004: PUSH
82005: LD_VAR 0 3
82009: ARRAY
82010: PUSH
82011: LD_VAR 0 1
82015: DIFF
82016: PPUSH
82017: CALL_OW 1
82021: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
82022: LD_VAR 0 1
82026: PUSH
82027: LD_EXP 66
82031: PUSH
82032: LD_VAR 0 3
82036: ARRAY
82037: IN
82038: IFFALSE 82077
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
82040: LD_ADDR_EXP 66
82044: PUSH
82045: LD_EXP 66
82049: PPUSH
82050: LD_VAR 0 3
82054: PPUSH
82055: LD_EXP 66
82059: PUSH
82060: LD_VAR 0 3
82064: ARRAY
82065: PUSH
82066: LD_VAR 0 1
82070: DIFF
82071: PPUSH
82072: CALL_OW 1
82076: ST_TO_ADDR
// end ; break ;
82077: GO 82081
// end ;
82079: GO 81155
82081: POP
82082: POP
// end ;
82083: LD_VAR 0 2
82087: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
82088: LD_INT 0
82090: PPUSH
82091: PPUSH
82092: PPUSH
// if not mc_bases or not skirmish then
82093: LD_EXP 58
82097: NOT
82098: PUSH
82099: LD_EXP 56
82103: NOT
82104: OR
82105: IFFALSE 82109
// exit ;
82107: GO 82324
// for i = 1 to mc_bases do
82109: LD_ADDR_VAR 0 3
82113: PUSH
82114: DOUBLE
82115: LD_INT 1
82117: DEC
82118: ST_TO_ADDR
82119: LD_EXP 58
82123: PUSH
82124: FOR_TO
82125: IFFALSE 82322
// begin if building in mc_construct_list [ i ] then
82127: LD_VAR 0 1
82131: PUSH
82132: LD_EXP 65
82136: PUSH
82137: LD_VAR 0 3
82141: ARRAY
82142: IN
82143: IFFALSE 82320
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82145: LD_ADDR_EXP 65
82149: PUSH
82150: LD_EXP 65
82154: PPUSH
82155: LD_VAR 0 3
82159: PPUSH
82160: LD_EXP 65
82164: PUSH
82165: LD_VAR 0 3
82169: ARRAY
82170: PUSH
82171: LD_VAR 0 1
82175: DIFF
82176: PPUSH
82177: CALL_OW 1
82181: ST_TO_ADDR
// if building in mc_lab [ i ] then
82182: LD_VAR 0 1
82186: PUSH
82187: LD_EXP 91
82191: PUSH
82192: LD_VAR 0 3
82196: ARRAY
82197: IN
82198: IFFALSE 82253
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
82200: LD_ADDR_EXP 92
82204: PUSH
82205: LD_EXP 92
82209: PPUSH
82210: LD_VAR 0 3
82214: PPUSH
82215: LD_EXP 92
82219: PUSH
82220: LD_VAR 0 3
82224: ARRAY
82225: PPUSH
82226: LD_INT 1
82228: PPUSH
82229: LD_EXP 92
82233: PUSH
82234: LD_VAR 0 3
82238: ARRAY
82239: PPUSH
82240: LD_INT 0
82242: PPUSH
82243: CALL 19688 0 4
82247: PPUSH
82248: CALL_OW 1
82252: ST_TO_ADDR
// if not building in mc_bases [ i ] then
82253: LD_VAR 0 1
82257: PUSH
82258: LD_EXP 58
82262: PUSH
82263: LD_VAR 0 3
82267: ARRAY
82268: IN
82269: NOT
82270: IFFALSE 82316
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82272: LD_ADDR_EXP 58
82276: PUSH
82277: LD_EXP 58
82281: PPUSH
82282: LD_VAR 0 3
82286: PUSH
82287: LD_EXP 58
82291: PUSH
82292: LD_VAR 0 3
82296: ARRAY
82297: PUSH
82298: LD_INT 1
82300: PLUS
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PPUSH
82306: LD_VAR 0 1
82310: PPUSH
82311: CALL 20270 0 3
82315: ST_TO_ADDR
// exit ;
82316: POP
82317: POP
82318: GO 82324
// end ; end ;
82320: GO 82124
82322: POP
82323: POP
// end ;
82324: LD_VAR 0 2
82328: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
82329: LD_INT 0
82331: PPUSH
82332: PPUSH
82333: PPUSH
82334: PPUSH
82335: PPUSH
82336: PPUSH
82337: PPUSH
// if not mc_bases or not skirmish then
82338: LD_EXP 58
82342: NOT
82343: PUSH
82344: LD_EXP 56
82348: NOT
82349: OR
82350: IFFALSE 82354
// exit ;
82352: GO 83015
// for i = 1 to mc_bases do
82354: LD_ADDR_VAR 0 3
82358: PUSH
82359: DOUBLE
82360: LD_INT 1
82362: DEC
82363: ST_TO_ADDR
82364: LD_EXP 58
82368: PUSH
82369: FOR_TO
82370: IFFALSE 83013
// begin if building in mc_construct_list [ i ] then
82372: LD_VAR 0 1
82376: PUSH
82377: LD_EXP 65
82381: PUSH
82382: LD_VAR 0 3
82386: ARRAY
82387: IN
82388: IFFALSE 83011
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
82390: LD_ADDR_EXP 65
82394: PUSH
82395: LD_EXP 65
82399: PPUSH
82400: LD_VAR 0 3
82404: PPUSH
82405: LD_EXP 65
82409: PUSH
82410: LD_VAR 0 3
82414: ARRAY
82415: PUSH
82416: LD_VAR 0 1
82420: DIFF
82421: PPUSH
82422: CALL_OW 1
82426: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
82427: LD_ADDR_EXP 58
82431: PUSH
82432: LD_EXP 58
82436: PPUSH
82437: LD_VAR 0 3
82441: PUSH
82442: LD_EXP 58
82446: PUSH
82447: LD_VAR 0 3
82451: ARRAY
82452: PUSH
82453: LD_INT 1
82455: PLUS
82456: PUSH
82457: EMPTY
82458: LIST
82459: LIST
82460: PPUSH
82461: LD_VAR 0 1
82465: PPUSH
82466: CALL 20270 0 3
82470: ST_TO_ADDR
// btype := GetBType ( building ) ;
82471: LD_ADDR_VAR 0 5
82475: PUSH
82476: LD_VAR 0 1
82480: PPUSH
82481: CALL_OW 266
82485: ST_TO_ADDR
// side := GetSide ( building ) ;
82486: LD_ADDR_VAR 0 8
82490: PUSH
82491: LD_VAR 0 1
82495: PPUSH
82496: CALL_OW 255
82500: ST_TO_ADDR
// if btype = b_lab then
82501: LD_VAR 0 5
82505: PUSH
82506: LD_INT 6
82508: EQUAL
82509: IFFALSE 82559
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
82511: LD_ADDR_EXP 91
82515: PUSH
82516: LD_EXP 91
82520: PPUSH
82521: LD_VAR 0 3
82525: PUSH
82526: LD_EXP 91
82530: PUSH
82531: LD_VAR 0 3
82535: ARRAY
82536: PUSH
82537: LD_INT 1
82539: PLUS
82540: PUSH
82541: EMPTY
82542: LIST
82543: LIST
82544: PPUSH
82545: LD_VAR 0 1
82549: PPUSH
82550: CALL 20270 0 3
82554: ST_TO_ADDR
// exit ;
82555: POP
82556: POP
82557: GO 83015
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82559: LD_VAR 0 5
82563: PUSH
82564: LD_INT 0
82566: PUSH
82567: LD_INT 2
82569: PUSH
82570: LD_INT 4
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: LIST
82577: IN
82578: IFFALSE 82702
// begin if btype = b_armoury then
82580: LD_VAR 0 5
82584: PUSH
82585: LD_INT 4
82587: EQUAL
82588: IFFALSE 82598
// btype := b_barracks ;
82590: LD_ADDR_VAR 0 5
82594: PUSH
82595: LD_INT 5
82597: ST_TO_ADDR
// if btype = b_depot then
82598: LD_VAR 0 5
82602: PUSH
82603: LD_INT 0
82605: EQUAL
82606: IFFALSE 82616
// btype := b_warehouse ;
82608: LD_ADDR_VAR 0 5
82612: PUSH
82613: LD_INT 1
82615: ST_TO_ADDR
// if btype = b_workshop then
82616: LD_VAR 0 5
82620: PUSH
82621: LD_INT 2
82623: EQUAL
82624: IFFALSE 82634
// btype := b_factory ;
82626: LD_ADDR_VAR 0 5
82630: PUSH
82631: LD_INT 3
82633: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82634: LD_VAR 0 5
82638: PPUSH
82639: LD_VAR 0 8
82643: PPUSH
82644: CALL_OW 323
82648: PUSH
82649: LD_INT 1
82651: EQUAL
82652: IFFALSE 82698
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82654: LD_ADDR_EXP 90
82658: PUSH
82659: LD_EXP 90
82663: PPUSH
82664: LD_VAR 0 3
82668: PUSH
82669: LD_EXP 90
82673: PUSH
82674: LD_VAR 0 3
82678: ARRAY
82679: PUSH
82680: LD_INT 1
82682: PLUS
82683: PUSH
82684: EMPTY
82685: LIST
82686: LIST
82687: PPUSH
82688: LD_VAR 0 1
82692: PPUSH
82693: CALL 20270 0 3
82697: ST_TO_ADDR
// exit ;
82698: POP
82699: POP
82700: GO 83015
// end ; if btype in [ b_bunker , b_turret ] then
82702: LD_VAR 0 5
82706: PUSH
82707: LD_INT 32
82709: PUSH
82710: LD_INT 33
82712: PUSH
82713: EMPTY
82714: LIST
82715: LIST
82716: IN
82717: IFFALSE 83007
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82719: LD_ADDR_EXP 66
82723: PUSH
82724: LD_EXP 66
82728: PPUSH
82729: LD_VAR 0 3
82733: PUSH
82734: LD_EXP 66
82738: PUSH
82739: LD_VAR 0 3
82743: ARRAY
82744: PUSH
82745: LD_INT 1
82747: PLUS
82748: PUSH
82749: EMPTY
82750: LIST
82751: LIST
82752: PPUSH
82753: LD_VAR 0 1
82757: PPUSH
82758: CALL 20270 0 3
82762: ST_TO_ADDR
// if btype = b_bunker then
82763: LD_VAR 0 5
82767: PUSH
82768: LD_INT 32
82770: EQUAL
82771: IFFALSE 83007
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82773: LD_ADDR_EXP 67
82777: PUSH
82778: LD_EXP 67
82782: PPUSH
82783: LD_VAR 0 3
82787: PUSH
82788: LD_EXP 67
82792: PUSH
82793: LD_VAR 0 3
82797: ARRAY
82798: PUSH
82799: LD_INT 1
82801: PLUS
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PPUSH
82807: LD_VAR 0 1
82811: PPUSH
82812: CALL 20270 0 3
82816: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82817: LD_ADDR_VAR 0 6
82821: PUSH
82822: LD_EXP 58
82826: PUSH
82827: LD_VAR 0 3
82831: ARRAY
82832: PPUSH
82833: LD_INT 25
82835: PUSH
82836: LD_INT 1
82838: PUSH
82839: EMPTY
82840: LIST
82841: LIST
82842: PUSH
82843: LD_INT 3
82845: PUSH
82846: LD_INT 54
82848: PUSH
82849: EMPTY
82850: LIST
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PPUSH
82860: CALL_OW 72
82864: ST_TO_ADDR
// if tmp then
82865: LD_VAR 0 6
82869: IFFALSE 82875
// exit ;
82871: POP
82872: POP
82873: GO 83015
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82875: LD_ADDR_VAR 0 6
82879: PUSH
82880: LD_EXP 58
82884: PUSH
82885: LD_VAR 0 3
82889: ARRAY
82890: PPUSH
82891: LD_INT 2
82893: PUSH
82894: LD_INT 30
82896: PUSH
82897: LD_INT 4
82899: PUSH
82900: EMPTY
82901: LIST
82902: LIST
82903: PUSH
82904: LD_INT 30
82906: PUSH
82907: LD_INT 5
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: LIST
82918: PPUSH
82919: CALL_OW 72
82923: ST_TO_ADDR
// if not tmp then
82924: LD_VAR 0 6
82928: NOT
82929: IFFALSE 82935
// exit ;
82931: POP
82932: POP
82933: GO 83015
// for j in tmp do
82935: LD_ADDR_VAR 0 4
82939: PUSH
82940: LD_VAR 0 6
82944: PUSH
82945: FOR_IN
82946: IFFALSE 83005
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82948: LD_ADDR_VAR 0 7
82952: PUSH
82953: LD_VAR 0 4
82957: PPUSH
82958: CALL_OW 313
82962: PPUSH
82963: LD_INT 25
82965: PUSH
82966: LD_INT 1
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PPUSH
82973: CALL_OW 72
82977: ST_TO_ADDR
// if units then
82978: LD_VAR 0 7
82982: IFFALSE 83003
// begin ComExitBuilding ( units [ 1 ] ) ;
82984: LD_VAR 0 7
82988: PUSH
82989: LD_INT 1
82991: ARRAY
82992: PPUSH
82993: CALL_OW 122
// exit ;
82997: POP
82998: POP
82999: POP
83000: POP
83001: GO 83015
// end ; end ;
83003: GO 82945
83005: POP
83006: POP
// end ; end ; exit ;
83007: POP
83008: POP
83009: GO 83015
// end ; end ;
83011: GO 82369
83013: POP
83014: POP
// end ;
83015: LD_VAR 0 2
83019: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
83020: LD_INT 0
83022: PPUSH
83023: PPUSH
83024: PPUSH
83025: PPUSH
83026: PPUSH
83027: PPUSH
83028: PPUSH
// if not mc_bases or not skirmish then
83029: LD_EXP 58
83033: NOT
83034: PUSH
83035: LD_EXP 56
83039: NOT
83040: OR
83041: IFFALSE 83045
// exit ;
83043: GO 83276
// btype := GetBType ( building ) ;
83045: LD_ADDR_VAR 0 6
83049: PUSH
83050: LD_VAR 0 1
83054: PPUSH
83055: CALL_OW 266
83059: ST_TO_ADDR
// x := GetX ( building ) ;
83060: LD_ADDR_VAR 0 7
83064: PUSH
83065: LD_VAR 0 1
83069: PPUSH
83070: CALL_OW 250
83074: ST_TO_ADDR
// y := GetY ( building ) ;
83075: LD_ADDR_VAR 0 8
83079: PUSH
83080: LD_VAR 0 1
83084: PPUSH
83085: CALL_OW 251
83089: ST_TO_ADDR
// d := GetDir ( building ) ;
83090: LD_ADDR_VAR 0 9
83094: PUSH
83095: LD_VAR 0 1
83099: PPUSH
83100: CALL_OW 254
83104: ST_TO_ADDR
// for i = 1 to mc_bases do
83105: LD_ADDR_VAR 0 4
83109: PUSH
83110: DOUBLE
83111: LD_INT 1
83113: DEC
83114: ST_TO_ADDR
83115: LD_EXP 58
83119: PUSH
83120: FOR_TO
83121: IFFALSE 83274
// begin if not mc_build_list [ i ] then
83123: LD_EXP 63
83127: PUSH
83128: LD_VAR 0 4
83132: ARRAY
83133: NOT
83134: IFFALSE 83138
// continue ;
83136: GO 83120
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
83138: LD_VAR 0 6
83142: PUSH
83143: LD_VAR 0 7
83147: PUSH
83148: LD_VAR 0 8
83152: PUSH
83153: LD_VAR 0 9
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: PPUSH
83164: LD_EXP 63
83168: PUSH
83169: LD_VAR 0 4
83173: ARRAY
83174: PUSH
83175: LD_INT 1
83177: ARRAY
83178: PPUSH
83179: CALL 26439 0 2
83183: IFFALSE 83272
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
83185: LD_ADDR_EXP 63
83189: PUSH
83190: LD_EXP 63
83194: PPUSH
83195: LD_VAR 0 4
83199: PPUSH
83200: LD_EXP 63
83204: PUSH
83205: LD_VAR 0 4
83209: ARRAY
83210: PPUSH
83211: LD_INT 1
83213: PPUSH
83214: CALL_OW 3
83218: PPUSH
83219: CALL_OW 1
83223: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
83224: LD_ADDR_EXP 65
83228: PUSH
83229: LD_EXP 65
83233: PPUSH
83234: LD_VAR 0 4
83238: PUSH
83239: LD_EXP 65
83243: PUSH
83244: LD_VAR 0 4
83248: ARRAY
83249: PUSH
83250: LD_INT 1
83252: PLUS
83253: PUSH
83254: EMPTY
83255: LIST
83256: LIST
83257: PPUSH
83258: LD_VAR 0 1
83262: PPUSH
83263: CALL 20270 0 3
83267: ST_TO_ADDR
// exit ;
83268: POP
83269: POP
83270: GO 83276
// end ; end ;
83272: GO 83120
83274: POP
83275: POP
// end ;
83276: LD_VAR 0 3
83280: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
83281: LD_INT 0
83283: PPUSH
83284: PPUSH
83285: PPUSH
// if not mc_bases or not skirmish then
83286: LD_EXP 58
83290: NOT
83291: PUSH
83292: LD_EXP 56
83296: NOT
83297: OR
83298: IFFALSE 83302
// exit ;
83300: GO 83492
// for i = 1 to mc_bases do
83302: LD_ADDR_VAR 0 4
83306: PUSH
83307: DOUBLE
83308: LD_INT 1
83310: DEC
83311: ST_TO_ADDR
83312: LD_EXP 58
83316: PUSH
83317: FOR_TO
83318: IFFALSE 83405
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
83320: LD_VAR 0 1
83324: PUSH
83325: LD_EXP 66
83329: PUSH
83330: LD_VAR 0 4
83334: ARRAY
83335: IN
83336: PUSH
83337: LD_VAR 0 1
83341: PUSH
83342: LD_EXP 67
83346: PUSH
83347: LD_VAR 0 4
83351: ARRAY
83352: IN
83353: NOT
83354: AND
83355: IFFALSE 83403
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83357: LD_ADDR_EXP 67
83361: PUSH
83362: LD_EXP 67
83366: PPUSH
83367: LD_VAR 0 4
83371: PUSH
83372: LD_EXP 67
83376: PUSH
83377: LD_VAR 0 4
83381: ARRAY
83382: PUSH
83383: LD_INT 1
83385: PLUS
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PPUSH
83391: LD_VAR 0 1
83395: PPUSH
83396: CALL 20270 0 3
83400: ST_TO_ADDR
// break ;
83401: GO 83405
// end ; end ;
83403: GO 83317
83405: POP
83406: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
83407: LD_VAR 0 1
83411: PPUSH
83412: CALL_OW 257
83416: PUSH
83417: LD_EXP 84
83421: IN
83422: PUSH
83423: LD_VAR 0 1
83427: PPUSH
83428: CALL_OW 266
83432: PUSH
83433: LD_INT 5
83435: EQUAL
83436: AND
83437: PUSH
83438: LD_VAR 0 2
83442: PPUSH
83443: CALL_OW 110
83447: PUSH
83448: LD_INT 18
83450: NONEQUAL
83451: AND
83452: IFFALSE 83492
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
83454: LD_VAR 0 2
83458: PPUSH
83459: CALL_OW 257
83463: PUSH
83464: LD_INT 5
83466: PUSH
83467: LD_INT 8
83469: PUSH
83470: LD_INT 9
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: LIST
83477: IN
83478: IFFALSE 83492
// SetClass ( unit , 1 ) ;
83480: LD_VAR 0 2
83484: PPUSH
83485: LD_INT 1
83487: PPUSH
83488: CALL_OW 336
// end ;
83492: LD_VAR 0 3
83496: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
83497: LD_INT 0
83499: PPUSH
83500: PPUSH
// if not mc_bases or not skirmish then
83501: LD_EXP 58
83505: NOT
83506: PUSH
83507: LD_EXP 56
83511: NOT
83512: OR
83513: IFFALSE 83517
// exit ;
83515: GO 83633
// if GetLives ( abandoned_vehicle ) > 250 then
83517: LD_VAR 0 2
83521: PPUSH
83522: CALL_OW 256
83526: PUSH
83527: LD_INT 250
83529: GREATER
83530: IFFALSE 83534
// exit ;
83532: GO 83633
// for i = 1 to mc_bases do
83534: LD_ADDR_VAR 0 6
83538: PUSH
83539: DOUBLE
83540: LD_INT 1
83542: DEC
83543: ST_TO_ADDR
83544: LD_EXP 58
83548: PUSH
83549: FOR_TO
83550: IFFALSE 83631
// begin if driver in mc_bases [ i ] then
83552: LD_VAR 0 1
83556: PUSH
83557: LD_EXP 58
83561: PUSH
83562: LD_VAR 0 6
83566: ARRAY
83567: IN
83568: IFFALSE 83629
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83570: LD_VAR 0 1
83574: PPUSH
83575: LD_EXP 58
83579: PUSH
83580: LD_VAR 0 6
83584: ARRAY
83585: PPUSH
83586: LD_INT 2
83588: PUSH
83589: LD_INT 30
83591: PUSH
83592: LD_INT 0
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 30
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: LIST
83613: PPUSH
83614: CALL_OW 72
83618: PUSH
83619: LD_INT 1
83621: ARRAY
83622: PPUSH
83623: CALL_OW 112
// break ;
83627: GO 83631
// end ; end ;
83629: GO 83549
83631: POP
83632: POP
// end ; end_of_file
83633: LD_VAR 0 5
83637: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
83638: GO 83640
83640: DISABLE
// begin ru_radar := 98 ;
83641: LD_ADDR_EXP 101
83645: PUSH
83646: LD_INT 98
83648: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83649: LD_ADDR_EXP 102
83653: PUSH
83654: LD_INT 89
83656: ST_TO_ADDR
// us_hack := 99 ;
83657: LD_ADDR_EXP 103
83661: PUSH
83662: LD_INT 99
83664: ST_TO_ADDR
// us_artillery := 97 ;
83665: LD_ADDR_EXP 104
83669: PUSH
83670: LD_INT 97
83672: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83673: LD_ADDR_EXP 105
83677: PUSH
83678: LD_INT 91
83680: ST_TO_ADDR
// end ;
83681: END
