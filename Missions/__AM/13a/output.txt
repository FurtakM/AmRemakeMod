// starting begin ResetFog ;
   0: CALL_OW 335
// RandomizeAll ;
   4: CALL_OW 11
// InitVariables ;
   8: CALL 593 0 0
// InitMacro ;
  12: CALL 55555 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  16: LD_INT 3
  18: PPUSH
  19: LD_INT 3
  21: PPUSH
  22: LD_INT 3
  24: PPUSH
  25: LD_INT 4
  27: PPUSH
  28: LD_INT 3
  30: PPUSH
  31: LD_INT 0
  33: PPUSH
  34: LD_INT 0
  36: PPUSH
  37: LD_INT 5
  39: PPUSH
  40: LD_INT 0
  42: PPUSH
  43: CALL 47776 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  47: LD_INT 0
  49: PPUSH
  50: LD_INT 0
  52: PPUSH
  53: LD_INT 5
  55: PPUSH
  56: LD_INT 0
  58: PPUSH
  59: LD_INT 0
  61: PPUSH
  62: LD_INT 0
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 8
  70: PPUSH
  71: LD_INT 0
  73: PPUSH
  74: CALL 47776 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  78: LD_INT 0
  80: PPUSH
  81: LD_INT 0
  83: PPUSH
  84: LD_INT 6
  86: PPUSH
  87: LD_INT 0
  89: PPUSH
  90: LD_INT 0
  92: PPUSH
  93: LD_INT 1
  95: PPUSH
  96: LD_INT 0
  98: PPUSH
  99: LD_INT 6
 101: PPUSH
 102: LD_INT 0
 104: PPUSH
 105: CALL 47776 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 109: LD_INT 0
 111: PPUSH
 112: LD_INT 0
 114: PPUSH
 115: LD_INT 5
 117: PPUSH
 118: LD_INT 0
 120: PPUSH
 121: LD_INT 0
 123: PPUSH
 124: LD_INT 0
 126: PPUSH
 127: LD_INT 0
 129: PPUSH
 130: LD_INT 12
 132: PPUSH
 133: LD_INT 0
 135: PPUSH
 136: CALL 47776 0 9
// PrepareArabian ;
 140: CALL 3430 0 0
// PrepareRussian ;
 144: CALL 2554 0 0
// PrepareAlliance ;
 148: CALL 703 0 0
// MC_Start ( ) ;
 152: CALL 56702 0 0
// if debug then
 156: LD_EXP 1
 160: IFFALSE 169
// FogOff ( 1 ) ;
 162: LD_INT 1
 164: PPUSH
 165: CALL_OW 344
// Action ;
 169: CALL 6627 0 0
// end ;
 173: END
// export function CustomInitMacro ; var i ; begin
 174: LD_INT 0
 176: PPUSH
 177: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 178: LD_ADDR_EXP 82
 182: PUSH
 183: LD_INT 1
 185: PUSH
 186: LD_INT 2
 188: PUSH
 189: EMPTY
 190: LIST
 191: LIST
 192: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 193: LD_ADDR_EXP 83
 197: PUSH
 198: LD_INT 3
 200: PUSH
 201: LD_INT 4
 203: PUSH
 204: EMPTY
 205: LIST
 206: LIST
 207: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 208: LD_INT 1
 210: PPUSH
 211: LD_INT 12
 213: PUSH
 214: LD_INT 15
 216: PUSH
 217: LD_INT 18
 219: PUSH
 220: EMPTY
 221: LIST
 222: LIST
 223: LIST
 224: PUSH
 225: LD_OWVAR 67
 229: ARRAY
 230: PPUSH
 231: LD_INT 7
 233: PPUSH
 234: CALL 77096 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 238: LD_INT 1
 240: PPUSH
 241: LD_EXP 53
 245: PPUSH
 246: CALL 77522 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 250: LD_INT 1
 252: PPUSH
 253: LD_INT 6
 255: PPUSH
 256: CALL 77975 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 260: LD_INT 1
 262: PPUSH
 263: LD_INT 9
 265: PUSH
 266: EMPTY
 267: LIST
 268: PPUSH
 269: CALL 78244 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 273: LD_INT 1
 275: PPUSH
 276: LD_INT 13
 278: PUSH
 279: LD_INT 1
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 32
 287: PUSH
 288: EMPTY
 289: LIST
 290: LIST
 291: LIST
 292: LIST
 293: PUSH
 294: EMPTY
 295: LIST
 296: PPUSH
 297: CALL 77462 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 301: LD_INT 2
 303: PPUSH
 304: LD_INT 12
 306: PUSH
 307: LD_INT 14
 309: PUSH
 310: LD_INT 10
 312: PUSH
 313: LD_INT 11
 315: PUSH
 316: EMPTY
 317: LIST
 318: LIST
 319: LIST
 320: LIST
 321: PPUSH
 322: CALL 78151 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 326: LD_INT 2
 328: PPUSH
 329: LD_EXP 50
 333: PPUSH
 334: CALL 77522 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 338: LD_INT 2
 340: PPUSH
 341: LD_INT 8
 343: PPUSH
 344: CALL 77975 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 348: LD_INT 2
 350: PPUSH
 351: LD_INT 10
 353: PUSH
 354: EMPTY
 355: LIST
 356: PPUSH
 357: CALL 78244 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 361: LD_INT 2
 363: PPUSH
 364: LD_INT 6
 366: PUSH
 367: LD_INT 71
 369: PUSH
 370: LD_INT 116
 372: PUSH
 373: LD_INT 4
 375: PUSH
 376: EMPTY
 377: LIST
 378: LIST
 379: LIST
 380: LIST
 381: PUSH
 382: LD_INT 4
 384: PUSH
 385: LD_INT 85
 387: PUSH
 388: LD_INT 116
 390: PUSH
 391: LD_INT 4
 393: PUSH
 394: EMPTY
 395: LIST
 396: LIST
 397: LIST
 398: LIST
 399: PUSH
 400: LD_INT 32
 402: PUSH
 403: LD_INT 83
 405: PUSH
 406: LD_INT 111
 408: PUSH
 409: LD_INT 4
 411: PUSH
 412: EMPTY
 413: LIST
 414: LIST
 415: LIST
 416: LIST
 417: PUSH
 418: LD_INT 32
 420: PUSH
 421: LD_INT 87
 423: PUSH
 424: LD_INT 121
 426: PUSH
 427: LD_INT 4
 429: PUSH
 430: EMPTY
 431: LIST
 432: LIST
 433: LIST
 434: LIST
 435: PUSH
 436: LD_INT 33
 438: PUSH
 439: LD_INT 88
 441: PUSH
 442: LD_INT 128
 444: PUSH
 445: LD_INT 4
 447: PUSH
 448: EMPTY
 449: LIST
 450: LIST
 451: LIST
 452: LIST
 453: PUSH
 454: LD_INT 32
 456: PUSH
 457: LD_INT 59
 459: PUSH
 460: LD_INT 89
 462: PUSH
 463: LD_INT 3
 465: PUSH
 466: EMPTY
 467: LIST
 468: LIST
 469: LIST
 470: LIST
 471: PUSH
 472: LD_INT 33
 474: PUSH
 475: LD_INT 69
 477: PUSH
 478: LD_INT 98
 480: PUSH
 481: LD_INT 3
 483: PUSH
 484: EMPTY
 485: LIST
 486: LIST
 487: LIST
 488: LIST
 489: PUSH
 490: LD_INT 33
 492: PUSH
 493: LD_INT 77
 495: PUSH
 496: LD_INT 103
 498: PUSH
 499: LD_INT 3
 501: PUSH
 502: EMPTY
 503: LIST
 504: LIST
 505: LIST
 506: LIST
 507: PUSH
 508: LD_INT 33
 510: PUSH
 511: LD_INT 83
 513: PUSH
 514: LD_INT 105
 516: PUSH
 517: LD_INT 3
 519: PUSH
 520: EMPTY
 521: LIST
 522: LIST
 523: LIST
 524: LIST
 525: PUSH
 526: LD_INT 33
 528: PUSH
 529: LD_INT 71
 531: PUSH
 532: LD_INT 125
 534: PUSH
 535: LD_INT 5
 537: PUSH
 538: EMPTY
 539: LIST
 540: LIST
 541: LIST
 542: LIST
 543: PUSH
 544: EMPTY
 545: LIST
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: LIST
 555: PPUSH
 556: CALL 77306 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 560: LD_INT 2
 562: PPUSH
 563: LD_INT 21
 565: PUSH
 566: LD_INT 1
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 51
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: EMPTY
 582: LIST
 583: PPUSH
 584: CALL 77462 0 2
// end ;
 588: LD_VAR 0 1
 592: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 593: LD_INT 0
 595: PPUSH
// debug := 1 ;
 596: LD_ADDR_EXP 1
 600: PUSH
 601: LD_INT 1
 603: ST_TO_ADDR
// game := true ;
 604: LD_ADDR_EXP 2
 608: PUSH
 609: LD_INT 1
 611: ST_TO_ADDR
// gossudarov_arrive := false ;
 612: LD_ADDR_EXP 4
 616: PUSH
 617: LD_INT 0
 619: ST_TO_ADDR
// ru_lab_builded := false ;
 620: LD_ADDR_EXP 5
 624: PUSH
 625: LD_INT 0
 627: ST_TO_ADDR
// player_spotted := false ;
 628: LD_ADDR_EXP 6
 632: PUSH
 633: LD_INT 0
 635: ST_TO_ADDR
// first_attack := false ;
 636: LD_ADDR_EXP 7
 640: PUSH
 641: LD_INT 0
 643: ST_TO_ADDR
// ru_attackers := [ ] ;
 644: LD_ADDR_EXP 51
 648: PUSH
 649: EMPTY
 650: ST_TO_ADDR
// ar_base_spotted := false ;
 651: LD_ADDR_EXP 8
 655: PUSH
 656: LD_INT 0
 658: ST_TO_ADDR
// ar_active_attack := false ;
 659: LD_ADDR_EXP 9
 663: PUSH
 664: LD_INT 0
 666: ST_TO_ADDR
// ar_attackers := [ ] ;
 667: LD_ADDR_EXP 10
 671: PUSH
 672: EMPTY
 673: ST_TO_ADDR
// first_powell_attack := false ;
 674: LD_ADDR_EXP 11
 678: PUSH
 679: LD_INT 0
 681: ST_TO_ADDR
// abdul_escaped := true ;
 682: LD_ADDR_EXP 12
 686: PUSH
 687: LD_INT 1
 689: ST_TO_ADDR
// loss_counter := 0 ;
 690: LD_ADDR_EXP 13
 694: PUSH
 695: LD_INT 0
 697: ST_TO_ADDR
// end ; end_of_file
 698: LD_VAR 0 1
 702: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 703: LD_INT 0
 705: PPUSH
 706: PPUSH
 707: PPUSH
 708: PPUSH
// uc_side := 7 ;
 709: LD_ADDR_OWVAR 20
 713: PUSH
 714: LD_INT 7
 716: ST_TO_ADDR
// uc_nation := 1 ;
 717: LD_ADDR_OWVAR 21
 721: PUSH
 722: LD_INT 1
 724: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 725: LD_ADDR_EXP 14
 729: PUSH
 730: LD_STRING JMM
 732: PPUSH
 733: LD_EXP 1
 737: NOT
 738: PPUSH
 739: LD_STRING 12a_
 741: PPUSH
 742: CALL 13507 0 3
 746: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 747: LD_EXP 14
 751: PPUSH
 752: LD_INT 71
 754: PPUSH
 755: LD_INT 23
 757: PPUSH
 758: LD_INT 0
 760: PPUSH
 761: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 765: LD_EXP 14
 769: PPUSH
 770: LD_INT 2
 772: PPUSH
 773: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 777: LD_ADDR_EXP 15
 781: PUSH
 782: LD_STRING Roth
 784: PPUSH
 785: LD_EXP 1
 789: NOT
 790: PPUSH
 791: LD_STRING 12a_
 793: PPUSH
 794: CALL 13507 0 3
 798: ST_TO_ADDR
// if Roth then
 799: LD_EXP 15
 803: IFFALSE 823
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 805: LD_EXP 15
 809: PPUSH
 810: LD_INT 71
 812: PPUSH
 813: LD_INT 21
 815: PPUSH
 816: LD_INT 0
 818: PPUSH
 819: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 823: LD_ADDR_EXP 16
 827: PUSH
 828: LD_STRING Lisa
 830: PPUSH
 831: LD_EXP 1
 835: NOT
 836: PPUSH
 837: LD_STRING 12a_
 839: PPUSH
 840: CALL 13507 0 3
 844: ST_TO_ADDR
// if Lisa then
 845: LD_EXP 16
 849: IFFALSE 866
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 851: LD_EXP 16
 855: PPUSH
 856: LD_INT 13
 858: PPUSH
 859: LD_INT 0
 861: PPUSH
 862: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 866: LD_ADDR_EXP 17
 870: PUSH
 871: LD_STRING Donaldson
 873: PPUSH
 874: LD_EXP 1
 878: NOT
 879: PPUSH
 880: LD_STRING 12a_
 882: PPUSH
 883: CALL 13507 0 3
 887: ST_TO_ADDR
// if Donaldson then
 888: LD_EXP 17
 892: IFFALSE 909
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 894: LD_EXP 17
 898: PPUSH
 899: LD_INT 13
 901: PPUSH
 902: LD_INT 0
 904: PPUSH
 905: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 909: LD_ADDR_EXP 18
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_STRING 12a_
 925: PPUSH
 926: CALL 13507 0 3
 930: ST_TO_ADDR
// if Bobby then
 931: LD_EXP 18
 935: IFFALSE 952
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 937: LD_EXP 18
 941: PPUSH
 942: LD_INT 13
 944: PPUSH
 945: LD_INT 0
 947: PPUSH
 948: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 952: LD_ADDR_EXP 19
 956: PUSH
 957: LD_STRING Cyrus
 959: PPUSH
 960: LD_EXP 1
 964: NOT
 965: PPUSH
 966: LD_STRING 12a_
 968: PPUSH
 969: CALL 13507 0 3
 973: ST_TO_ADDR
// if Cyrus then
 974: LD_EXP 19
 978: IFFALSE 995
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 980: LD_EXP 19
 984: PPUSH
 985: LD_INT 13
 987: PPUSH
 988: LD_INT 0
 990: PPUSH
 991: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
 995: LD_ADDR_EXP 20
 999: PUSH
1000: LD_STRING Denis
1002: PPUSH
1003: LD_EXP 1
1007: NOT
1008: PPUSH
1009: LD_STRING 12a_
1011: PPUSH
1012: CALL 13507 0 3
1016: ST_TO_ADDR
// if Denis then
1017: LD_EXP 20
1021: IFFALSE 1038
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1023: LD_EXP 20
1027: PPUSH
1028: LD_INT 13
1030: PPUSH
1031: LD_INT 0
1033: PPUSH
1034: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1038: LD_ADDR_EXP 21
1042: PUSH
1043: LD_STRING Brown
1045: PPUSH
1046: LD_EXP 1
1050: NOT
1051: PPUSH
1052: LD_STRING 12a_
1054: PPUSH
1055: CALL 13507 0 3
1059: ST_TO_ADDR
// if Brown then
1060: LD_EXP 21
1064: IFFALSE 1081
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1066: LD_EXP 21
1070: PPUSH
1071: LD_INT 13
1073: PPUSH
1074: LD_INT 0
1076: PPUSH
1077: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1081: LD_ADDR_EXP 22
1085: PUSH
1086: LD_STRING Gladstone
1088: PPUSH
1089: LD_EXP 1
1093: NOT
1094: PPUSH
1095: LD_STRING 12a_
1097: PPUSH
1098: CALL 13507 0 3
1102: ST_TO_ADDR
// if Gladstone then
1103: LD_EXP 22
1107: IFFALSE 1124
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1109: LD_EXP 22
1113: PPUSH
1114: LD_INT 13
1116: PPUSH
1117: LD_INT 0
1119: PPUSH
1120: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1124: LD_ADDR_EXP 23
1128: PUSH
1129: LD_STRING Houten
1131: PPUSH
1132: LD_EXP 1
1136: NOT
1137: PPUSH
1138: LD_STRING 12a_
1140: PPUSH
1141: CALL 13507 0 3
1145: ST_TO_ADDR
// if Houten then
1146: LD_EXP 23
1150: IFFALSE 1167
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1152: LD_EXP 23
1156: PPUSH
1157: LD_INT 13
1159: PPUSH
1160: LD_INT 0
1162: PPUSH
1163: CALL_OW 49
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 12a_ ) ;
1167: LD_ADDR_EXP 24
1171: PUSH
1172: LD_STRING Cornel
1174: PPUSH
1175: LD_EXP 1
1179: NOT
1180: PPUSH
1181: LD_STRING 12a_
1183: PPUSH
1184: CALL 13507 0 3
1188: ST_TO_ADDR
// if Cornel then
1189: LD_EXP 24
1193: IFFALSE 1210
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1195: LD_EXP 24
1199: PPUSH
1200: LD_INT 13
1202: PPUSH
1203: LD_INT 0
1205: PPUSH
1206: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1210: LD_ADDR_EXP 25
1214: PUSH
1215: LD_STRING Gary
1217: PPUSH
1218: LD_EXP 1
1222: NOT
1223: PPUSH
1224: LD_STRING 12a_
1226: PPUSH
1227: CALL 13507 0 3
1231: ST_TO_ADDR
// if Gary then
1232: LD_EXP 25
1236: IFFALSE 1253
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1238: LD_EXP 25
1242: PPUSH
1243: LD_INT 13
1245: PPUSH
1246: LD_INT 0
1248: PPUSH
1249: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1253: LD_ADDR_EXP 26
1257: PUSH
1258: LD_STRING Frank
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_STRING 12a_
1269: PPUSH
1270: CALL 13507 0 3
1274: ST_TO_ADDR
// if Frank then
1275: LD_EXP 26
1279: IFFALSE 1296
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1281: LD_EXP 26
1285: PPUSH
1286: LD_INT 13
1288: PPUSH
1289: LD_INT 0
1291: PPUSH
1292: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1296: LD_ADDR_EXP 27
1300: PUSH
1301: LD_STRING Kikuchi
1303: PPUSH
1304: LD_EXP 1
1308: NOT
1309: PPUSH
1310: LD_STRING 12a_
1312: PPUSH
1313: CALL 13507 0 3
1317: ST_TO_ADDR
// if Kikuchi then
1318: LD_EXP 27
1322: IFFALSE 1339
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1324: LD_EXP 27
1328: PPUSH
1329: LD_INT 13
1331: PPUSH
1332: LD_INT 0
1334: PPUSH
1335: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1339: LD_ADDR_EXP 28
1343: PUSH
1344: LD_STRING Simms
1346: PPUSH
1347: LD_EXP 1
1351: NOT
1352: PPUSH
1353: LD_STRING 12a_
1355: PPUSH
1356: CALL 13507 0 3
1360: ST_TO_ADDR
// if Simms then
1361: LD_EXP 28
1365: IFFALSE 1382
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1367: LD_EXP 28
1371: PPUSH
1372: LD_INT 13
1374: PPUSH
1375: LD_INT 0
1377: PPUSH
1378: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1382: LD_ADDR_EXP 29
1386: PUSH
1387: LD_STRING Joan
1389: PPUSH
1390: LD_EXP 1
1394: NOT
1395: PPUSH
1396: LD_STRING 12a_
1398: PPUSH
1399: CALL 13507 0 3
1403: ST_TO_ADDR
// if Joan then
1404: LD_EXP 29
1408: IFFALSE 1425
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1410: LD_EXP 29
1414: PPUSH
1415: LD_INT 13
1417: PPUSH
1418: LD_INT 0
1420: PPUSH
1421: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1425: LD_ADDR_EXP 30
1429: PUSH
1430: LD_STRING DeltaDoctor
1432: PPUSH
1433: LD_EXP 1
1437: NOT
1438: PPUSH
1439: LD_STRING 12a_
1441: PPUSH
1442: CALL 13507 0 3
1446: ST_TO_ADDR
// if DeltaDoctor then
1447: LD_EXP 30
1451: IFFALSE 1468
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1453: LD_EXP 30
1457: PPUSH
1458: LD_INT 13
1460: PPUSH
1461: LD_INT 0
1463: PPUSH
1464: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1468: LD_ADDR_VAR 0 4
1472: PUSH
1473: LD_STRING 12a_others
1475: PPUSH
1476: CALL_OW 31
1480: ST_TO_ADDR
// if tmp then
1481: LD_VAR 0 4
1485: IFFALSE 1519
// for i in tmp do
1487: LD_ADDR_VAR 0 3
1491: PUSH
1492: LD_VAR 0 4
1496: PUSH
1497: FOR_IN
1498: IFFALSE 1517
// PlaceUnitArea ( i , alliance_start , false ) ;
1500: LD_VAR 0 3
1504: PPUSH
1505: LD_INT 13
1507: PPUSH
1508: LD_INT 0
1510: PPUSH
1511: CALL_OW 49
1515: GO 1497
1517: POP
1518: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1519: LD_INT 3
1521: PPUSH
1522: LD_INT 3
1524: PPUSH
1525: LD_INT 3
1527: PPUSH
1528: LD_INT 12
1530: PPUSH
1531: LD_INT 100
1533: PPUSH
1534: CALL 20140 0 5
// veh := CreateVehicle ;
1538: LD_ADDR_VAR 0 2
1542: PUSH
1543: CALL_OW 45
1547: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1548: LD_VAR 0 2
1552: PPUSH
1553: LD_INT 2
1555: PPUSH
1556: CALL_OW 233
// PlaceUnitXY ( veh , 63 , 9 , false ) ;
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 63
1567: PPUSH
1568: LD_INT 9
1570: PPUSH
1571: LD_INT 0
1573: PPUSH
1574: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 4
1585: PPUSH
1586: LD_INT 30
1588: PPUSH
1589: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1593: LD_STRING 11_artifact_captured
1595: PPUSH
1596: LD_INT 0
1598: PPUSH
1599: CALL_OW 30
1603: IFFALSE 1679
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1605: LD_INT 3
1607: PPUSH
1608: LD_INT 3
1610: PPUSH
1611: LD_INT 3
1613: PPUSH
1614: LD_INT 12
1616: PPUSH
1617: LD_INT 100
1619: PPUSH
1620: CALL 20140 0 5
// veh := CreateVehicle ;
1624: LD_ADDR_VAR 0 2
1628: PUSH
1629: CALL_OW 45
1633: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1634: LD_VAR 0 2
1638: PPUSH
1639: LD_INT 2
1641: PPUSH
1642: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 4 , false ) ;
1646: LD_VAR 0 2
1650: PPUSH
1651: LD_INT 60
1653: PPUSH
1654: LD_INT 4
1656: PPUSH
1657: LD_INT 0
1659: PPUSH
1660: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 4
1671: PPUSH
1672: LD_INT 50
1674: PPUSH
1675: CALL_OW 290
// end ; end ;
1679: LD_VAR 0 1
1683: RET
// export function PrepareGossudarov ; var tmp , i ; begin
1684: LD_INT 0
1686: PPUSH
1687: PPUSH
1688: PPUSH
// uc_side := 6 ;
1689: LD_ADDR_OWVAR 20
1693: PUSH
1694: LD_INT 6
1696: ST_TO_ADDR
// uc_nation := 3 ;
1697: LD_ADDR_OWVAR 21
1701: PUSH
1702: LD_INT 3
1704: ST_TO_ADDR
// InitHc ;
1705: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1709: LD_ADDR_EXP 31
1713: PUSH
1714: LD_STRING Gossudarov
1716: PPUSH
1717: CALL_OW 25
1721: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1722: LD_ADDR_EXP 32
1726: PUSH
1727: LD_STRING Kirilenkova
1729: PPUSH
1730: CALL_OW 25
1734: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1735: LD_ADDR_EXP 33
1739: PUSH
1740: LD_STRING Titov
1742: PPUSH
1743: CALL_OW 25
1747: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Oblukov
1755: PPUSH
1756: CALL_OW 25
1760: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1761: LD_ADDR_EXP 35
1765: PUSH
1766: LD_STRING Dolgov
1768: PPUSH
1769: CALL_OW 25
1773: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1774: LD_ADDR_EXP 36
1778: PUSH
1779: LD_STRING Petrosyan
1781: PPUSH
1782: CALL_OW 25
1786: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1787: LD_ADDR_EXP 37
1791: PUSH
1792: LD_STRING Scholtze
1794: PPUSH
1795: CALL_OW 25
1799: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1800: LD_ADDR_EXP 39
1804: PUSH
1805: LD_STRING Kapitsova
1807: PPUSH
1808: CALL_OW 25
1812: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_EXP 31
1822: PUSH
1823: LD_EXP 32
1827: PUSH
1828: LD_EXP 33
1832: PUSH
1833: LD_EXP 38
1837: PUSH
1838: LD_EXP 35
1842: PUSH
1843: LD_EXP 36
1847: PUSH
1848: LD_EXP 37
1852: PUSH
1853: LD_EXP 39
1857: PUSH
1858: EMPTY
1859: LIST
1860: LIST
1861: LIST
1862: LIST
1863: LIST
1864: LIST
1865: LIST
1866: LIST
1867: ST_TO_ADDR
// for i in tmp do
1868: LD_ADDR_VAR 0 3
1872: PUSH
1873: LD_VAR 0 2
1877: PUSH
1878: FOR_IN
1879: IFFALSE 1898
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1881: LD_VAR 0 3
1885: PPUSH
1886: LD_INT 14
1888: PPUSH
1889: LD_INT 0
1891: PPUSH
1892: CALL_OW 49
1896: GO 1878
1898: POP
1899: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1900: LD_VAR 0 2
1904: PPUSH
1905: LD_EXP 3
1909: PPUSH
1910: CALL_OW 250
1914: PPUSH
1915: LD_EXP 3
1919: PPUSH
1920: CALL_OW 251
1924: PPUSH
1925: CALL_OW 111
// end ;
1929: LD_VAR 0 1
1933: RET
// export function PrepareBelkov ; begin
1934: LD_INT 0
1936: PPUSH
// uc_side := 4 ;
1937: LD_ADDR_OWVAR 20
1941: PUSH
1942: LD_INT 4
1944: ST_TO_ADDR
// uc_nation := 3 ;
1945: LD_ADDR_OWVAR 21
1949: PUSH
1950: LD_INT 3
1952: ST_TO_ADDR
// InitHc ;
1953: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
1957: LD_ADDR_EXP 46
1961: PUSH
1962: LD_STRING Belkov
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
1970: LD_EXP 46
1974: PPUSH
1975: LD_INT 14
1977: PPUSH
1978: LD_INT 0
1980: PPUSH
1981: CALL_OW 49
// end ;
1985: LD_VAR 0 1
1989: RET
// export function PrepareGnyevko ; begin
1990: LD_INT 0
1992: PPUSH
// uc_side := 4 ;
1993: LD_ADDR_OWVAR 20
1997: PUSH
1998: LD_INT 4
2000: ST_TO_ADDR
// uc_nation := 3 ;
2001: LD_ADDR_OWVAR 21
2005: PUSH
2006: LD_INT 3
2008: ST_TO_ADDR
// InitHc ;
2009: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2013: LD_ADDR_EXP 47
2017: PUSH
2018: LD_STRING Gnyevko
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2026: LD_EXP 47
2030: PPUSH
2031: LD_INT 14
2033: PPUSH
2034: LD_INT 0
2036: PPUSH
2037: CALL_OW 49
// end ;
2041: LD_VAR 0 1
2045: RET
// export function PrepareBurlak ; var i , tmp ; begin
2046: LD_INT 0
2048: PPUSH
2049: PPUSH
2050: PPUSH
// uc_side := 4 ;
2051: LD_ADDR_OWVAR 20
2055: PUSH
2056: LD_INT 4
2058: ST_TO_ADDR
// uc_nation := 3 ;
2059: LD_ADDR_OWVAR 21
2063: PUSH
2064: LD_INT 3
2066: ST_TO_ADDR
// InitHc ;
2067: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2071: LD_ADDR_EXP 45
2075: PUSH
2076: LD_STRING Burlak
2078: PPUSH
2079: CALL_OW 25
2083: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2084: LD_INT 24
2086: PUSH
2087: LD_INT 23
2089: PUSH
2090: LD_INT 22
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: PUSH
2098: LD_OWVAR 67
2102: ARRAY
2103: PPUSH
2104: LD_INT 1
2106: PPUSH
2107: LD_INT 1
2109: PPUSH
2110: LD_INT 45
2112: PUSH
2113: LD_INT 44
2115: PUSH
2116: LD_INT 43
2118: PUSH
2119: EMPTY
2120: LIST
2121: LIST
2122: LIST
2123: PUSH
2124: LD_OWVAR 67
2128: ARRAY
2129: PPUSH
2130: LD_INT 0
2132: PPUSH
2133: CALL 20140 0 5
// Masha := CreateVehicle ;
2137: LD_ADDR_EXP 48
2141: PUSH
2142: CALL_OW 45
2146: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2147: LD_EXP 48
2151: PUSH
2152: LD_EXP 45
2156: PUSH
2157: EMPTY
2158: LIST
2159: LIST
2160: PPUSH
2161: LD_INT 499
2163: PPUSH
2164: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2168: LD_EXP 48
2172: PPUSH
2173: LD_INT 3
2175: PPUSH
2176: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2180: LD_EXP 48
2184: PPUSH
2185: LD_INT 1
2187: PPUSH
2188: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2192: LD_EXP 48
2196: PPUSH
2197: LD_INT 18
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2207: LD_EXP 45
2211: PPUSH
2212: LD_INT 125
2214: PPUSH
2215: LD_INT 1
2217: PPUSH
2218: LD_INT 0
2220: PPUSH
2221: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2225: LD_EXP 45
2229: PPUSH
2230: LD_EXP 48
2234: PPUSH
2235: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2239: LD_INT 10
2241: PPUSH
2242: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2246: LD_EXP 48
2250: PPUSH
2251: LD_INT 110
2253: PPUSH
2254: LD_INT 10
2256: PPUSH
2257: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2261: LD_ADDR_EXP 41
2265: PUSH
2266: LD_STRING Petrovova
2268: PPUSH
2269: CALL_OW 25
2273: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2274: LD_ADDR_EXP 43
2278: PUSH
2279: LD_STRING Kuzmov
2281: PPUSH
2282: CALL_OW 25
2286: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2287: LD_ADDR_EXP 42
2291: PUSH
2292: LD_STRING Kovalyuk
2294: PPUSH
2295: CALL_OW 25
2299: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2300: LD_ADDR_EXP 40
2304: PUSH
2305: LD_STRING Lipshchin
2307: PPUSH
2308: CALL_OW 25
2312: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2313: LD_ADDR_EXP 44
2317: PUSH
2318: LD_STRING Karamazov
2320: PPUSH
2321: CALL_OW 25
2325: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2326: LD_ADDR_VAR 0 3
2330: PUSH
2331: LD_EXP 41
2335: PUSH
2336: LD_EXP 43
2340: PUSH
2341: LD_EXP 42
2345: PUSH
2346: LD_EXP 40
2350: PUSH
2351: LD_EXP 44
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: LIST
2362: ST_TO_ADDR
// for i in tmp do
2363: LD_ADDR_VAR 0 2
2367: PUSH
2368: LD_VAR 0 3
2372: PUSH
2373: FOR_IN
2374: IFFALSE 2413
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 399
2383: PPUSH
2384: LD_INT 799
2386: PPUSH
2387: CALL_OW 12
2391: PPUSH
2392: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2396: LD_VAR 0 2
2400: PPUSH
2401: LD_INT 19
2403: PPUSH
2404: LD_INT 0
2406: PPUSH
2407: CALL_OW 49
// end ;
2411: GO 2373
2413: POP
2414: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2415: LD_VAR 0 3
2419: PPUSH
2420: LD_INT 116
2422: PPUSH
2423: LD_INT 8
2425: PPUSH
2426: CALL_OW 111
// AddComHold ( tmp ) ;
2430: LD_VAR 0 3
2434: PPUSH
2435: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2439: LD_ADDR_VAR 0 2
2443: PUSH
2444: LD_VAR 0 3
2448: PPUSH
2449: LD_INT 25
2451: PUSH
2452: LD_INT 1
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: PPUSH
2459: CALL_OW 72
2463: PUSH
2464: FOR_IN
2465: IFFALSE 2505
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2467: LD_VAR 0 2
2471: PPUSH
2472: LD_INT 20
2474: PPUSH
2475: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2479: LD_VAR 0 2
2483: PPUSH
2484: LD_INT 147
2486: PPUSH
2487: LD_INT 45
2489: PPUSH
2490: CALL_OW 178
// AddComCrawl ( i ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: CALL_OW 197
// end ;
2503: GO 2464
2505: POP
2506: POP
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) ;
2514: LD_EXP 48
2518: PPUSH
2519: LD_INT 110
2521: PPUSH
2522: LD_INT 10
2524: PPUSH
2525: CALL_OW 307
2529: IFFALSE 2507
// ComStop ( Burlak ) ;
2531: LD_EXP 45
2535: PPUSH
2536: CALL_OW 141
// AddComHold ( Burlak ) ;
2540: LD_EXP 45
2544: PPUSH
2545: CALL_OW 200
// end ; end_of_file
2549: LD_VAR 0 1
2553: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2554: LD_INT 0
2556: PPUSH
2557: PPUSH
2558: PPUSH
2559: PPUSH
// uc_side := 3 ;
2560: LD_ADDR_OWVAR 20
2564: PUSH
2565: LD_INT 3
2567: ST_TO_ADDR
// uc_nation := 3 ;
2568: LD_ADDR_OWVAR 21
2572: PUSH
2573: LD_INT 3
2575: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2576: LD_ADDR_EXP 49
2580: PUSH
2581: LD_INT 47
2583: PPUSH
2584: LD_INT 4
2586: PPUSH
2587: LD_STRING 
2589: PPUSH
2590: LD_INT 7
2592: PUSH
2593: LD_INT 8
2595: PUSH
2596: LD_INT 9
2598: PUSH
2599: EMPTY
2600: LIST
2601: LIST
2602: LIST
2603: PUSH
2604: LD_OWVAR 67
2608: ARRAY
2609: PPUSH
2610: LD_INT 10000
2612: PUSH
2613: LD_INT 3000
2615: PUSH
2616: LD_INT 300
2618: PUSH
2619: EMPTY
2620: LIST
2621: LIST
2622: LIST
2623: PPUSH
2624: LD_INT 9
2626: PUSH
2627: LD_INT 5
2629: PUSH
2630: LD_INT 6
2632: PUSH
2633: LD_INT 6
2635: PUSH
2636: EMPTY
2637: LIST
2638: LIST
2639: LIST
2640: LIST
2641: PPUSH
2642: CALL 23582 0 6
2646: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2647: LD_ADDR_EXP 58
2651: PUSH
2652: LD_EXP 58
2656: PPUSH
2657: LD_INT 2
2659: PPUSH
2660: LD_EXP 49
2664: PPUSH
2665: CALL_OW 1
2669: ST_TO_ADDR
// tmp := [ ] ;
2670: LD_ADDR_VAR 0 4
2674: PUSH
2675: EMPTY
2676: ST_TO_ADDR
// for i = 1 to 4 do
2677: LD_ADDR_VAR 0 2
2681: PUSH
2682: DOUBLE
2683: LD_INT 1
2685: DEC
2686: ST_TO_ADDR
2687: LD_INT 4
2689: PUSH
2690: FOR_TO
2691: IFFALSE 2784
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2693: LD_INT 22
2695: PPUSH
2696: LD_INT 3
2698: PPUSH
2699: LD_INT 3
2701: PPUSH
2702: LD_INT 43
2704: PUSH
2705: LD_INT 45
2707: PUSH
2708: LD_INT 45
2710: PUSH
2711: LD_INT 44
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: LIST
2718: LIST
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_INT 4
2727: MOD
2728: PUSH
2729: LD_INT 1
2731: PLUS
2732: ARRAY
2733: PPUSH
2734: LD_INT 100
2736: PPUSH
2737: CALL 20140 0 5
// veh := CreateVehicle ;
2741: LD_ADDR_VAR 0 3
2745: PUSH
2746: CALL_OW 45
2750: ST_TO_ADDR
// tmp := tmp ^ veh ;
2751: LD_ADDR_VAR 0 4
2755: PUSH
2756: LD_VAR 0 4
2760: PUSH
2761: LD_VAR 0 3
2765: ADD
2766: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2767: LD_VAR 0 3
2771: PPUSH
2772: LD_INT 2
2774: PPUSH
2775: LD_INT 0
2777: PPUSH
2778: CALL_OW 49
// end ;
2782: GO 2690
2784: POP
2785: POP
// russian_guard := tmp ;
2786: LD_ADDR_EXP 50
2790: PUSH
2791: LD_VAR 0 4
2795: ST_TO_ADDR
// end ;
2796: LD_VAR 0 1
2800: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2801: LD_INT 47
2803: PPUSH
2804: CALL_OW 302
2808: PUSH
2809: LD_EXP 6
2813: AND
2814: IFFALSE 3427
2816: GO 2818
2818: DISABLE
2819: LD_INT 0
2821: PPUSH
2822: PPUSH
2823: PPUSH
2824: PPUSH
2825: PPUSH
2826: PPUSH
// begin enable ;
2827: ENABLE
// base := 2 ;
2828: LD_ADDR_VAR 0 2
2832: PUSH
2833: LD_INT 2
2835: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2836: LD_ADDR_VAR 0 4
2840: PUSH
2841: LD_INT 0
2843: PUSH
2844: LD_INT 0
2846: PUSH
2847: LD_INT 0
2849: PUSH
2850: LD_INT 0
2852: PUSH
2853: LD_INT 0
2855: PUSH
2856: LD_INT 0
2858: PUSH
2859: LD_INT 0
2861: PUSH
2862: LD_INT 0
2864: PUSH
2865: LD_INT 1
2867: PUSH
2868: LD_INT 0
2870: PUSH
2871: EMPTY
2872: LIST
2873: LIST
2874: LIST
2875: LIST
2876: LIST
2877: LIST
2878: LIST
2879: LIST
2880: LIST
2881: LIST
2882: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2883: LD_ADDR_VAR 0 3
2887: PUSH
2888: LD_INT 22
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: LD_INT 3
2896: PUSH
2897: LD_INT 45
2899: PUSH
2900: EMPTY
2901: LIST
2902: LIST
2903: LIST
2904: LIST
2905: PUSH
2906: LD_INT 21
2908: PUSH
2909: LD_INT 1
2911: PUSH
2912: LD_INT 3
2914: PUSH
2915: LD_INT 45
2917: PUSH
2918: EMPTY
2919: LIST
2920: LIST
2921: LIST
2922: LIST
2923: PUSH
2924: LD_INT 22
2926: PUSH
2927: LD_INT 1
2929: PUSH
2930: LD_INT 3
2932: PUSH
2933: LD_INT 45
2935: PUSH
2936: EMPTY
2937: LIST
2938: LIST
2939: LIST
2940: LIST
2941: PUSH
2942: LD_INT 23
2944: PUSH
2945: LD_INT 1
2947: PUSH
2948: LD_INT 3
2950: PUSH
2951: LD_INT 46
2953: PUSH
2954: EMPTY
2955: LIST
2956: LIST
2957: LIST
2958: LIST
2959: PUSH
2960: EMPTY
2961: LIST
2962: LIST
2963: LIST
2964: LIST
2965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
2966: LD_ADDR_VAR 0 1
2970: PUSH
2971: DOUBLE
2972: LD_INT 1
2974: DEC
2975: ST_TO_ADDR
2976: LD_OWVAR 67
2980: PUSH
2981: LD_OWVAR 1
2985: PUSH
2986: LD_INT 21000
2988: DIV
2989: PLUS
2990: PUSH
2991: FOR_TO
2992: IFFALSE 3080
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
2994: LD_ADDR_VAR 0 3
2998: PUSH
2999: LD_VAR 0 3
3003: PPUSH
3004: LD_VAR 0 3
3008: PUSH
3009: LD_INT 1
3011: PLUS
3012: PPUSH
3013: LD_INT 23
3015: PUSH
3016: LD_INT 24
3018: PUSH
3019: EMPTY
3020: LIST
3021: LIST
3022: PUSH
3023: LD_INT 1
3025: PPUSH
3026: LD_INT 2
3028: PPUSH
3029: CALL_OW 12
3033: ARRAY
3034: PUSH
3035: LD_INT 1
3037: PUSH
3038: LD_INT 3
3040: PUSH
3041: LD_INT 46
3043: PUSH
3044: LD_INT 47
3046: PUSH
3047: LD_INT 45
3049: PUSH
3050: EMPTY
3051: LIST
3052: LIST
3053: LIST
3054: PUSH
3055: LD_INT 1
3057: PPUSH
3058: LD_INT 3
3060: PPUSH
3061: CALL_OW 12
3065: ARRAY
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: LIST
3072: PPUSH
3073: CALL_OW 2
3077: ST_TO_ADDR
3078: GO 2991
3080: POP
3081: POP
// MC_SetProduceList ( base , tmp ) ;
3082: LD_VAR 0 2
3086: PPUSH
3087: LD_VAR 0 3
3091: PPUSH
3092: CALL 77414 0 2
// repeat wait ( 0 0$1 ) ;
3096: LD_INT 35
3098: PPUSH
3099: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
3103: LD_VAR 0 2
3107: PPUSH
3108: CALL 77868 0 1
3112: PUSH
3113: LD_INT 0
3115: EQUAL
3116: IFFALSE 3096
// wait ( 0 0$20 ) ;
3118: LD_INT 700
3120: PPUSH
3121: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3125: LD_ADDR_VAR 0 5
3129: PUSH
3130: LD_INT 71
3132: PUSH
3133: LD_INT 19
3135: PUSH
3136: EMPTY
3137: LIST
3138: LIST
3139: PUSH
3140: LD_INT 91
3142: PUSH
3143: LD_INT 67
3145: PUSH
3146: EMPTY
3147: LIST
3148: LIST
3149: PUSH
3150: LD_INT 52
3152: PUSH
3153: LD_INT 44
3155: PUSH
3156: EMPTY
3157: LIST
3158: LIST
3159: PUSH
3160: LD_INT 68
3162: PUSH
3163: LD_INT 48
3165: PUSH
3166: EMPTY
3167: LIST
3168: LIST
3169: PUSH
3170: EMPTY
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ) ;
3176: LD_ADDR_VAR 0 6
3180: PUSH
3181: LD_EXP 77
3185: PUSH
3186: LD_VAR 0 2
3190: ARRAY
3191: PUSH
3192: LD_EXP 80
3196: PUSH
3197: LD_VAR 0 2
3201: ARRAY
3202: PUSH
3203: LD_EXP 77
3207: PUSH
3208: LD_VAR 0 2
3212: ARRAY
3213: PPUSH
3214: LD_INT 2
3216: PUSH
3217: LD_INT 34
3219: PUSH
3220: LD_INT 51
3222: PUSH
3223: EMPTY
3224: LIST
3225: LIST
3226: PUSH
3227: LD_INT 34
3229: PUSH
3230: LD_INT 52
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: PUSH
3237: EMPTY
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL_OW 72
3246: UNION
3247: DIFF
3248: ST_TO_ADDR
// if not attackers then
3249: LD_VAR 0 6
3253: NOT
3254: IFFALSE 3258
// exit ;
3256: GO 3427
// ru_attackers := attackers ;
3258: LD_ADDR_EXP 51
3262: PUSH
3263: LD_VAR 0 6
3267: ST_TO_ADDR
// for i = 1 to attackers do
3268: LD_ADDR_VAR 0 1
3272: PUSH
3273: DOUBLE
3274: LD_INT 1
3276: DEC
3277: ST_TO_ADDR
3278: LD_VAR 0 6
3282: PUSH
3283: FOR_TO
3284: IFFALSE 3361
// begin case i mod 3 of 0 :
3286: LD_VAR 0 1
3290: PUSH
3291: LD_INT 3
3293: MOD
3294: PUSH
3295: LD_INT 0
3297: DOUBLE
3298: EQUAL
3299: IFTRUE 3303
3301: GO 3306
3303: POP
// ; 1 :
3304: GO 3359
3306: LD_INT 1
3308: DOUBLE
3309: EQUAL
3310: IFTRUE 3314
3312: GO 3332
3314: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3315: LD_VAR 0 1
3319: PPUSH
3320: LD_INT 32
3322: PPUSH
3323: LD_INT 49
3325: PPUSH
3326: CALL_OW 114
3330: GO 3359
3332: LD_INT 2
3334: DOUBLE
3335: EQUAL
3336: IFTRUE 3340
3338: GO 3358
3340: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3341: LD_VAR 0 1
3345: PPUSH
3346: LD_INT 117
3348: PPUSH
3349: LD_INT 107
3351: PPUSH
3352: CALL_OW 114
3356: GO 3359
3358: POP
// end ;
3359: GO 3283
3361: POP
3362: POP
// repeat wait ( 0 0$1 ) ;
3363: LD_INT 35
3365: PPUSH
3366: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3370: LD_VAR 0 6
3374: PPUSH
3375: LD_INT 60
3377: PUSH
3378: EMPTY
3379: LIST
3380: PPUSH
3381: CALL_OW 72
3385: NOT
3386: IFFALSE 3363
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3388: LD_VAR 0 2
3392: PPUSH
3393: LD_VAR 0 6
3397: PPUSH
3398: LD_VAR 0 5
3402: PPUSH
3403: LD_VAR 0 4
3407: PPUSH
3408: CALL 77705 0 4
// if not first_attack then
3412: LD_EXP 7
3416: NOT
3417: IFFALSE 3427
// first_attack := true ;
3419: LD_ADDR_EXP 7
3423: PUSH
3424: LD_INT 1
3426: ST_TO_ADDR
// end ; end_of_file
3427: PPOPN 6
3429: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3430: LD_INT 0
3432: PPUSH
3433: PPUSH
3434: PPUSH
3435: PPUSH
3436: PPUSH
3437: PPUSH
3438: PPUSH
// uc_side := 2 ;
3439: LD_ADDR_OWVAR 20
3443: PUSH
3444: LD_INT 2
3446: ST_TO_ADDR
// uc_nation := 2 ;
3447: LD_ADDR_OWVAR 21
3451: PUSH
3452: LD_INT 2
3454: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3455: LD_ADDR_EXP 54
3459: PUSH
3460: LD_STRING Abdul
3462: PPUSH
3463: CALL_OW 25
3467: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3468: LD_EXP 54
3472: PPUSH
3473: LD_INT 11
3475: PPUSH
3476: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3480: LD_EXP 54
3484: PPUSH
3485: LD_INT 1
3487: PPUSH
3488: CALL_OW 52
// vc_chassis := 31 ;
3492: LD_ADDR_OWVAR 37
3496: PUSH
3497: LD_INT 31
3499: ST_TO_ADDR
// vc_control := control_rider ;
3500: LD_ADDR_OWVAR 38
3504: PUSH
3505: LD_INT 4
3507: ST_TO_ADDR
// mastodont := CreateVehicle ;
3508: LD_ADDR_EXP 55
3512: PUSH
3513: CALL_OW 45
3517: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3518: LD_EXP 55
3522: PPUSH
3523: LD_INT 153
3525: PPUSH
3526: LD_INT 71
3528: PPUSH
3529: LD_INT 0
3531: PPUSH
3532: CALL_OW 48
// InitVc ;
3536: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3540: LD_ADDR_EXP 52
3544: PUSH
3545: LD_INT 1
3547: PPUSH
3548: LD_INT 3
3550: PPUSH
3551: LD_STRING 
3553: PPUSH
3554: LD_INT 7
3556: PUSH
3557: LD_INT 8
3559: PUSH
3560: LD_INT 9
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: PUSH
3568: LD_OWVAR 67
3572: ARRAY
3573: PPUSH
3574: LD_INT 5000
3576: PUSH
3577: LD_INT 1000
3579: PUSH
3580: LD_INT 300
3582: PUSH
3583: EMPTY
3584: LIST
3585: LIST
3586: LIST
3587: PPUSH
3588: LD_INT 22
3590: PUSH
3591: LD_INT 5
3593: PUSH
3594: LD_INT 6
3596: PUSH
3597: LD_INT 9
3599: PUSH
3600: EMPTY
3601: LIST
3602: LIST
3603: LIST
3604: LIST
3605: PPUSH
3606: CALL 23582 0 6
3610: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3611: LD_ADDR_EXP 58
3615: PUSH
3616: LD_EXP 58
3620: PPUSH
3621: LD_INT 1
3623: PPUSH
3624: LD_EXP 52
3628: PPUSH
3629: CALL_OW 1
3633: ST_TO_ADDR
// tmp := [ ] ;
3634: LD_ADDR_VAR 0 4
3638: PUSH
3639: EMPTY
3640: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3641: LD_ADDR_OWVAR 37
3645: PUSH
3646: LD_INT 14
3648: ST_TO_ADDR
// vc_engine := engine_siberite ;
3649: LD_ADDR_OWVAR 39
3653: PUSH
3654: LD_INT 3
3656: ST_TO_ADDR
// vc_control := control_manual ;
3657: LD_ADDR_OWVAR 38
3661: PUSH
3662: LD_INT 1
3664: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3665: LD_ADDR_OWVAR 40
3669: PUSH
3670: LD_INT 31
3672: ST_TO_ADDR
// for i = 1 to 3 do
3673: LD_ADDR_VAR 0 2
3677: PUSH
3678: DOUBLE
3679: LD_INT 1
3681: DEC
3682: ST_TO_ADDR
3683: LD_INT 3
3685: PUSH
3686: FOR_TO
3687: IFFALSE 3931
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3689: LD_ADDR_VAR 0 5
3693: PUSH
3694: LD_INT 153
3696: PUSH
3697: LD_INT 71
3699: PUSH
3700: EMPTY
3701: LIST
3702: LIST
3703: PUSH
3704: LD_INT 155
3706: PUSH
3707: LD_INT 81
3709: PUSH
3710: EMPTY
3711: LIST
3712: LIST
3713: PUSH
3714: EMPTY
3715: LIST
3716: LIST
3717: PUSH
3718: LD_VAR 0 2
3722: PUSH
3723: LD_INT 2
3725: MOD
3726: PUSH
3727: LD_INT 1
3729: PLUS
3730: ARRAY
3731: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3732: LD_INT 0
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: LD_INT 7
3740: PUSH
3741: LD_INT 8
3743: PUSH
3744: LD_INT 9
3746: PUSH
3747: EMPTY
3748: LIST
3749: LIST
3750: LIST
3751: PUSH
3752: LD_OWVAR 67
3756: ARRAY
3757: PPUSH
3758: CALL_OW 380
// un := CreateVehicle ;
3762: LD_ADDR_VAR 0 6
3766: PUSH
3767: CALL_OW 45
3771: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3772: LD_VAR 0 6
3776: PPUSH
3777: LD_INT 0
3779: PPUSH
3780: LD_INT 5
3782: PPUSH
3783: CALL_OW 12
3787: PPUSH
3788: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3792: LD_VAR 0 6
3796: PPUSH
3797: LD_VAR 0 5
3801: PUSH
3802: LD_INT 1
3804: ARRAY
3805: PPUSH
3806: LD_VAR 0 5
3810: PUSH
3811: LD_INT 2
3813: ARRAY
3814: PPUSH
3815: LD_INT 6
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 50
// un2 := CreateHuman ;
3825: LD_ADDR_VAR 0 7
3829: PUSH
3830: CALL_OW 44
3834: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3835: LD_VAR 0 7
3839: PPUSH
3840: LD_VAR 0 6
3844: PPUSH
3845: CALL_OW 52
// mc_bases := Add ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3849: LD_ADDR_EXP 58
3853: PUSH
3854: LD_EXP 58
3858: PPUSH
3859: LD_INT 1
3861: PUSH
3862: LD_EXP 58
3866: PUSH
3867: LD_INT 1
3869: ARRAY
3870: PUSH
3871: LD_INT 1
3873: PLUS
3874: PUSH
3875: EMPTY
3876: LIST
3877: LIST
3878: PPUSH
3879: LD_VAR 0 6
3883: PPUSH
3884: CALL 20697 0 3
3888: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3889: LD_ADDR_EXP 58
3893: PUSH
3894: LD_EXP 58
3898: PPUSH
3899: LD_INT 1
3901: PUSH
3902: LD_EXP 58
3906: PUSH
3907: LD_INT 1
3909: ARRAY
3910: PUSH
3911: LD_INT 1
3913: PLUS
3914: PUSH
3915: EMPTY
3916: LIST
3917: LIST
3918: PPUSH
3919: LD_VAR 0 7
3923: PPUSH
3924: CALL 20697 0 3
3928: ST_TO_ADDR
// end ;
3929: GO 3686
3931: POP
3932: POP
// for i = 1 to 5 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 5
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4040
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
3949: LD_INT 14
3951: PPUSH
3952: LD_INT 3
3954: PPUSH
3955: LD_INT 1
3957: PPUSH
3958: LD_INT 25
3960: PUSH
3961: LD_INT 28
3963: PUSH
3964: LD_INT 28
3966: PUSH
3967: LD_INT 26
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: LIST
3974: LIST
3975: PUSH
3976: LD_VAR 0 2
3980: PUSH
3981: LD_INT 4
3983: MOD
3984: PUSH
3985: LD_INT 1
3987: PLUS
3988: ARRAY
3989: PPUSH
3990: LD_INT 100
3992: PPUSH
3993: CALL 20140 0 5
// veh := CreateVehicle ;
3997: LD_ADDR_VAR 0 3
4001: PUSH
4002: CALL_OW 45
4006: ST_TO_ADDR
// tmp := tmp ^ veh ;
4007: LD_ADDR_VAR 0 4
4011: PUSH
4012: LD_VAR 0 4
4016: PUSH
4017: LD_VAR 0 3
4021: ADD
4022: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4023: LD_VAR 0 3
4027: PPUSH
4028: LD_INT 1
4030: PPUSH
4031: LD_INT 0
4033: PPUSH
4034: CALL_OW 49
// end ;
4038: GO 3946
4040: POP
4041: POP
// arabian_guard := tmp ;
4042: LD_ADDR_EXP 53
4046: PUSH
4047: LD_VAR 0 4
4051: ST_TO_ADDR
// end ;
4052: LD_VAR 0 1
4056: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4057: LD_INT 22
4059: PUSH
4060: LD_INT 7
4062: PUSH
4063: EMPTY
4064: LIST
4065: LIST
4066: PUSH
4067: LD_INT 91
4069: PUSH
4070: LD_INT 1
4072: PUSH
4073: LD_INT 12
4075: PUSH
4076: EMPTY
4077: LIST
4078: LIST
4079: LIST
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PPUSH
4085: CALL_OW 69
4089: PUSH
4090: LD_EXP 55
4094: PPUSH
4095: CALL_OW 256
4099: PUSH
4100: LD_INT 990
4102: LESS
4103: OR
4104: PUSH
4105: LD_EXP 54
4109: PPUSH
4110: CALL_OW 256
4114: PUSH
4115: LD_INT 990
4117: LESS
4118: OR
4119: IFFALSE 4262
4121: GO 4123
4123: DISABLE
// begin if IsInUnit ( Abdul ) then
4124: LD_EXP 54
4128: PPUSH
4129: CALL_OW 310
4133: IFFALSE 4144
// ComExitBuilding ( Abdul ) ;
4135: LD_EXP 54
4139: PPUSH
4140: CALL_OW 122
// if Mastodont then
4144: LD_EXP 55
4148: IFFALSE 4165
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4150: LD_EXP 55
4154: PPUSH
4155: LD_INT 205
4157: PPUSH
4158: LD_INT 132
4160: PPUSH
4161: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4165: LD_EXP 54
4169: PPUSH
4170: LD_INT 205
4172: PPUSH
4173: LD_INT 132
4175: PPUSH
4176: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4180: LD_INT 35
4182: PPUSH
4183: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4187: LD_EXP 54
4191: PPUSH
4192: LD_INT 21
4194: PPUSH
4195: CALL_OW 308
4199: IFFALSE 4180
// RemoveUnit ( Abdul ) ;
4201: LD_EXP 54
4205: PPUSH
4206: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4210: LD_INT 35
4212: PPUSH
4213: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4217: LD_EXP 55
4221: PPUSH
4222: LD_INT 21
4224: PPUSH
4225: CALL_OW 308
4229: PUSH
4230: LD_EXP 55
4234: PPUSH
4235: CALL_OW 301
4239: OR
4240: IFFALSE 4210
// if IsOk ( Mastodont ) then
4242: LD_EXP 55
4246: PPUSH
4247: CALL_OW 302
4251: IFFALSE 4262
// RemoveUnit ( Mastodont ) ;
4253: LD_EXP 55
4257: PPUSH
4258: CALL_OW 64
// end ;
4262: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4263: LD_EXP 54
4267: PPUSH
4268: CALL_OW 301
4272: PUSH
4273: LD_INT 22
4275: PUSH
4276: LD_INT 2
4278: PUSH
4279: EMPTY
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 2
4285: PUSH
4286: LD_INT 25
4288: PUSH
4289: LD_INT 1
4291: PUSH
4292: EMPTY
4293: LIST
4294: LIST
4295: PUSH
4296: LD_INT 25
4298: PUSH
4299: LD_INT 2
4301: PUSH
4302: EMPTY
4303: LIST
4304: LIST
4305: PUSH
4306: LD_INT 25
4308: PUSH
4309: LD_INT 3
4311: PUSH
4312: EMPTY
4313: LIST
4314: LIST
4315: PUSH
4316: LD_INT 25
4318: PUSH
4319: LD_INT 4
4321: PUSH
4322: EMPTY
4323: LIST
4324: LIST
4325: PUSH
4326: LD_INT 25
4328: PUSH
4329: LD_INT 8
4331: PUSH
4332: EMPTY
4333: LIST
4334: LIST
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: LIST
4341: LIST
4342: LIST
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PPUSH
4348: CALL_OW 69
4352: PUSH
4353: LD_INT 16
4355: PUSH
4356: LD_INT 19
4358: PUSH
4359: LD_INT 22
4361: PUSH
4362: EMPTY
4363: LIST
4364: LIST
4365: LIST
4366: PUSH
4367: LD_OWVAR 67
4371: ARRAY
4372: LESS
4373: OR
4374: IFFALSE 5047
4376: GO 4378
4378: DISABLE
4379: LD_INT 0
4381: PPUSH
4382: PPUSH
4383: PPUSH
4384: PPUSH
4385: PPUSH
4386: PPUSH
// begin MC_Kill ( 1 ) ;
4387: LD_INT 1
4389: PPUSH
4390: CALL 55790 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4394: LD_ADDR_VAR 0 2
4398: PUSH
4399: LD_INT 22
4401: PUSH
4402: LD_INT 2
4404: PUSH
4405: EMPTY
4406: LIST
4407: LIST
4408: PUSH
4409: LD_INT 2
4411: PUSH
4412: LD_INT 25
4414: PUSH
4415: LD_INT 1
4417: PUSH
4418: EMPTY
4419: LIST
4420: LIST
4421: PUSH
4422: LD_INT 25
4424: PUSH
4425: LD_INT 2
4427: PUSH
4428: EMPTY
4429: LIST
4430: LIST
4431: PUSH
4432: LD_INT 25
4434: PUSH
4435: LD_INT 3
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 4
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: PUSH
4452: LD_INT 25
4454: PUSH
4455: LD_INT 8
4457: PUSH
4458: EMPTY
4459: LIST
4460: LIST
4461: PUSH
4462: EMPTY
4463: LIST
4464: LIST
4465: LIST
4466: LIST
4467: LIST
4468: LIST
4469: PUSH
4470: EMPTY
4471: LIST
4472: LIST
4473: PPUSH
4474: CALL_OW 69
4478: ST_TO_ADDR
// for i in tmp do
4479: LD_ADDR_VAR 0 5
4483: PUSH
4484: LD_VAR 0 2
4488: PUSH
4489: FOR_IN
4490: IFFALSE 4506
// SetTag ( i , 10 ) ;
4492: LD_VAR 0 5
4496: PPUSH
4497: LD_INT 10
4499: PPUSH
4500: CALL_OW 109
4504: GO 4489
4506: POP
4507: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4508: LD_ADDR_VAR 0 3
4512: PUSH
4513: LD_INT 22
4515: PUSH
4516: LD_INT 2
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 21
4525: PUSH
4526: LD_INT 1
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: PUSH
4533: EMPTY
4534: LIST
4535: LIST
4536: PPUSH
4537: CALL_OW 69
4541: PUSH
4542: LD_VAR 0 2
4546: DIFF
4547: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4548: LD_ADDR_VAR 0 1
4552: PUSH
4553: LD_INT 22
4555: PUSH
4556: LD_INT 2
4558: PUSH
4559: EMPTY
4560: LIST
4561: LIST
4562: PUSH
4563: LD_INT 21
4565: PUSH
4566: LD_INT 2
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PUSH
4573: LD_INT 24
4575: PUSH
4576: LD_INT 300
4578: PUSH
4579: EMPTY
4580: LIST
4581: LIST
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: LIST
4587: PPUSH
4588: CALL_OW 69
4592: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4593: LD_ADDR_VAR 0 4
4597: PUSH
4598: LD_VAR 0 1
4602: PPUSH
4603: LD_INT 33
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: LD_INT 58
4615: PUSH
4616: EMPTY
4617: LIST
4618: PUSH
4619: EMPTY
4620: LIST
4621: LIST
4622: PPUSH
4623: CALL_OW 72
4627: ST_TO_ADDR
// for i in tmp do
4628: LD_ADDR_VAR 0 5
4632: PUSH
4633: LD_VAR 0 2
4637: PUSH
4638: FOR_IN
4639: IFFALSE 4823
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4641: LD_VAR 0 5
4645: PUSH
4646: LD_INT 55
4648: PUSH
4649: EMPTY
4650: LIST
4651: PPUSH
4652: CALL_OW 69
4656: IN
4657: IFFALSE 4676
// begin AddComMoveXY ( i , 209 , 132 ) ;
4659: LD_VAR 0 5
4663: PPUSH
4664: LD_INT 209
4666: PPUSH
4667: LD_INT 132
4669: PPUSH
4670: CALL_OW 171
// continue ;
4674: GO 4638
// end ; if IsInUnit ( i ) then
4676: LD_VAR 0 5
4680: PPUSH
4681: CALL_OW 310
4685: IFFALSE 4703
// begin ComExitBuilding ( i ) ;
4687: LD_VAR 0 5
4691: PPUSH
4692: CALL_OW 122
// wait ( 3 ) ;
4696: LD_INT 3
4698: PPUSH
4699: CALL_OW 67
// end ; if tmp_empty then
4703: LD_VAR 0 4
4707: IFFALSE 4806
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4709: LD_VAR 0 5
4713: PPUSH
4714: LD_VAR 0 4
4718: PPUSH
4719: LD_VAR 0 5
4723: PPUSH
4724: CALL_OW 74
4728: PPUSH
4729: CALL_OW 296
4733: PUSH
4734: LD_INT 25
4736: LESS
4737: IFFALSE 4806
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4739: LD_ADDR_VAR 0 6
4743: PUSH
4744: LD_VAR 0 4
4748: PPUSH
4749: LD_VAR 0 5
4753: PPUSH
4754: CALL_OW 74
4758: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4759: LD_VAR 0 5
4763: PPUSH
4764: LD_VAR 0 6
4768: PPUSH
4769: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4773: LD_VAR 0 5
4777: PPUSH
4778: LD_INT 209
4780: PPUSH
4781: LD_INT 132
4783: PPUSH
4784: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4788: LD_ADDR_VAR 0 4
4792: PUSH
4793: LD_VAR 0 4
4797: PUSH
4798: LD_VAR 0 6
4802: DIFF
4803: ST_TO_ADDR
// continue ;
4804: GO 4638
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4806: LD_VAR 0 5
4810: PPUSH
4811: LD_INT 201
4813: PPUSH
4814: LD_INT 132
4816: PPUSH
4817: CALL_OW 171
// end ;
4821: GO 4638
4823: POP
4824: POP
// for i in tmp_ape do
4825: LD_ADDR_VAR 0 5
4829: PUSH
4830: LD_VAR 0 3
4834: PUSH
4835: FOR_IN
4836: IFFALSE 4875
// begin if IsInUnit ( i ) then
4838: LD_VAR 0 5
4842: PPUSH
4843: CALL_OW 310
4847: IFFALSE 4858
// ComExitBuilding ( i ) ;
4849: LD_VAR 0 5
4853: PPUSH
4854: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_INT 201
4865: PPUSH
4866: LD_INT 132
4868: PPUSH
4869: CALL_OW 171
// end ;
4873: GO 4835
4875: POP
4876: POP
// repeat wait ( 0 0$1 ) ;
4877: LD_INT 35
4879: PPUSH
4880: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4884: LD_ADDR_VAR 0 5
4888: PUSH
4889: LD_VAR 0 2
4893: PUSH
4894: LD_VAR 0 3
4898: UNION
4899: PUSH
4900: LD_VAR 0 1
4904: UNION
4905: PUSH
4906: FOR_IN
4907: IFFALSE 4938
// if not HasTask ( i ) then
4909: LD_VAR 0 5
4913: PPUSH
4914: CALL_OW 314
4918: NOT
4919: IFFALSE 4936
// ComMoveXY ( i , 201 , 132 ) ;
4921: LD_VAR 0 5
4925: PPUSH
4926: LD_INT 201
4928: PPUSH
4929: LD_INT 132
4931: PPUSH
4932: CALL_OW 111
4936: GO 4906
4938: POP
4939: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
4940: LD_INT 21
4942: PPUSH
4943: LD_INT 22
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: EMPTY
4950: LIST
4951: LIST
4952: PPUSH
4953: CALL_OW 70
4957: IFFALSE 4998
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
4959: LD_ADDR_VAR 0 5
4963: PUSH
4964: LD_INT 21
4966: PPUSH
4967: LD_INT 22
4969: PUSH
4970: LD_INT 2
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PPUSH
4977: CALL_OW 70
4981: PUSH
4982: FOR_IN
4983: IFFALSE 4996
// RemoveUnit ( i ) ;
4985: LD_VAR 0 5
4989: PPUSH
4990: CALL_OW 64
4994: GO 4982
4996: POP
4997: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
4998: LD_INT 22
5000: PUSH
5001: LD_INT 2
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: LD_INT 21
5013: PUSH
5014: LD_INT 1
5016: PUSH
5017: EMPTY
5018: LIST
5019: LIST
5020: PUSH
5021: LD_INT 21
5023: PUSH
5024: LD_INT 2
5026: PUSH
5027: EMPTY
5028: LIST
5029: LIST
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: LIST
5035: PUSH
5036: EMPTY
5037: LIST
5038: LIST
5039: PPUSH
5040: CALL_OW 69
5044: NOT
5045: IFFALSE 4877
// end ;
5047: PPOPN 6
5049: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5050: LD_EXP 9
5054: PUSH
5055: LD_INT 92
5057: PPUSH
5058: LD_INT 40
5060: PPUSH
5061: CALL_OW 428
5065: PPUSH
5066: CALL_OW 266
5070: PUSH
5071: LD_INT 30
5073: EQUAL
5074: AND
5075: IFFALSE 5271
5077: GO 5079
5079: DISABLE
5080: LD_INT 0
5082: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5083: LD_ADDR_VAR 0 1
5087: PUSH
5088: LD_EXP 58
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: PPUSH
5097: LD_INT 25
5099: PUSH
5100: LD_INT 4
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PPUSH
5107: CALL_OW 72
5111: ST_TO_ADDR
// if not sci then
5112: LD_VAR 0 1
5116: NOT
5117: IFFALSE 5121
// exit ;
5119: GO 5271
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5121: LD_ADDR_EXP 58
5125: PUSH
5126: LD_EXP 58
5130: PPUSH
5131: LD_INT 1
5133: PPUSH
5134: LD_EXP 58
5138: PUSH
5139: LD_INT 1
5141: ARRAY
5142: PUSH
5143: LD_VAR 0 1
5147: PUSH
5148: LD_INT 1
5150: ARRAY
5151: DIFF
5152: PPUSH
5153: CALL_OW 1
5157: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5158: LD_VAR 0 1
5162: PUSH
5163: LD_INT 1
5165: ARRAY
5166: PPUSH
5167: CALL_OW 310
5171: IFFALSE 5186
// ComExitBuilding ( sci [ 1 ] ) ;
5173: LD_VAR 0 1
5177: PUSH
5178: LD_INT 1
5180: ARRAY
5181: PPUSH
5182: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5186: LD_INT 2
5188: PPUSH
5189: LD_INT 105
5191: PPUSH
5192: LD_INT 14
5194: PPUSH
5195: LD_INT 20
5197: PPUSH
5198: CALL 21191 0 4
5202: PUSH
5203: LD_INT 4
5205: ARRAY
5206: PUSH
5207: LD_INT 10
5209: LESS
5210: IFFALSE 5233
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5212: LD_VAR 0 1
5216: PUSH
5217: LD_INT 1
5219: ARRAY
5220: PPUSH
5221: LD_INT 105
5223: PPUSH
5224: LD_INT 14
5226: PPUSH
5227: CALL_OW 171
5231: GO 5252
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5233: LD_VAR 0 1
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PPUSH
5242: LD_INT 118
5244: PPUSH
5245: LD_INT 77
5247: PPUSH
5248: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5252: LD_VAR 0 1
5256: PUSH
5257: LD_INT 1
5259: ARRAY
5260: PPUSH
5261: LD_INT 92
5263: PPUSH
5264: LD_INT 40
5266: PPUSH
5267: CALL_OW 218
// end ;
5271: PPOPN 1
5273: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5274: LD_INT 1
5276: PPUSH
5277: CALL_OW 302
5281: PUSH
5282: LD_EXP 9
5286: AND
5287: IFFALSE 5757
5289: GO 5291
5291: DISABLE
5292: LD_INT 0
5294: PPUSH
5295: PPUSH
5296: PPUSH
5297: PPUSH
5298: PPUSH
5299: PPUSH
// begin enable ;
5300: ENABLE
// base := 1 ;
5301: LD_ADDR_VAR 0 2
5305: PUSH
5306: LD_INT 1
5308: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5309: LD_ADDR_VAR 0 4
5313: PUSH
5314: LD_INT 0
5316: PUSH
5317: LD_INT 0
5319: PUSH
5320: LD_INT 0
5322: PUSH
5323: LD_INT 0
5325: PUSH
5326: LD_INT 0
5328: PUSH
5329: LD_INT 0
5331: PUSH
5332: LD_INT 0
5334: PUSH
5335: LD_INT 0
5337: PUSH
5338: LD_INT 1
5340: PUSH
5341: LD_INT 0
5343: PUSH
5344: EMPTY
5345: LIST
5346: LIST
5347: LIST
5348: LIST
5349: LIST
5350: LIST
5351: LIST
5352: LIST
5353: LIST
5354: LIST
5355: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5356: LD_ADDR_VAR 0 3
5360: PUSH
5361: LD_INT 14
5363: PUSH
5364: LD_INT 1
5366: PUSH
5367: LD_INT 2
5369: PUSH
5370: LD_INT 26
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 14
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: LD_INT 2
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: EMPTY
5392: LIST
5393: LIST
5394: LIST
5395: LIST
5396: PUSH
5397: LD_INT 13
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 2
5405: PUSH
5406: LD_INT 29
5408: PUSH
5409: EMPTY
5410: LIST
5411: LIST
5412: LIST
5413: LIST
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: LIST
5419: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5420: LD_ADDR_VAR 0 1
5424: PUSH
5425: DOUBLE
5426: LD_INT 1
5428: DEC
5429: ST_TO_ADDR
5430: LD_OWVAR 67
5434: PUSH
5435: LD_OWVAR 1
5439: PUSH
5440: LD_INT 21000
5442: DIV
5443: PLUS
5444: PUSH
5445: FOR_TO
5446: IFFALSE 5538
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5448: LD_ADDR_VAR 0 3
5452: PUSH
5453: LD_VAR 0 3
5457: PPUSH
5458: LD_VAR 0 3
5462: PUSH
5463: LD_INT 1
5465: PLUS
5466: PPUSH
5467: LD_INT 13
5469: PUSH
5470: LD_INT 14
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 1
5479: PPUSH
5480: LD_INT 2
5482: PPUSH
5483: CALL_OW 12
5487: ARRAY
5488: PUSH
5489: LD_INT 1
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: LD_INT 28
5497: PUSH
5498: LD_INT 29
5500: PUSH
5501: LD_INT 25
5503: PUSH
5504: LD_INT 26
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 1
5515: PPUSH
5516: LD_INT 4
5518: PPUSH
5519: CALL_OW 12
5523: ARRAY
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PPUSH
5531: CALL_OW 2
5535: ST_TO_ADDR
5536: GO 5445
5538: POP
5539: POP
// MC_SetProduceList ( base , tmp ) ;
5540: LD_VAR 0 2
5544: PPUSH
5545: LD_VAR 0 3
5549: PPUSH
5550: CALL 77414 0 2
// repeat wait ( 0 0$1 ) ;
5554: LD_INT 35
5556: PPUSH
5557: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5561: LD_VAR 0 2
5565: PPUSH
5566: CALL 77868 0 1
5570: PUSH
5571: LD_INT 0
5573: EQUAL
5574: IFFALSE 5554
// wait ( 0 0$20 ) ;
5576: LD_INT 700
5578: PPUSH
5579: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5583: LD_ADDR_VAR 0 5
5587: PUSH
5588: LD_INT 124
5590: PUSH
5591: LD_INT 85
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: PUSH
5598: LD_INT 90
5600: PUSH
5601: LD_INT 61
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: PUSH
5608: LD_INT 69
5610: PUSH
5611: LD_INT 48
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: PUSH
5618: LD_INT 68
5620: PUSH
5621: LD_INT 48
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: PUSH
5628: EMPTY
5629: LIST
5630: LIST
5631: LIST
5632: LIST
5633: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
5634: LD_ADDR_VAR 0 6
5638: PUSH
5639: LD_EXP 77
5643: PUSH
5644: LD_VAR 0 2
5648: ARRAY
5649: PUSH
5650: LD_EXP 80
5654: PUSH
5655: LD_VAR 0 2
5659: ARRAY
5660: PUSH
5661: LD_EXP 77
5665: PUSH
5666: LD_VAR 0 2
5670: ARRAY
5671: PPUSH
5672: LD_INT 34
5674: PUSH
5675: LD_INT 32
5677: PUSH
5678: EMPTY
5679: LIST
5680: LIST
5681: PPUSH
5682: CALL_OW 72
5686: UNION
5687: DIFF
5688: ST_TO_ADDR
// if not attackers then
5689: LD_VAR 0 6
5693: NOT
5694: IFFALSE 5698
// exit ;
5696: GO 5757
// ar_attackers := attackers ;
5698: LD_ADDR_EXP 10
5702: PUSH
5703: LD_VAR 0 6
5707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5708: LD_INT 35
5710: PPUSH
5711: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5715: LD_VAR 0 6
5719: PPUSH
5720: LD_INT 60
5722: PUSH
5723: EMPTY
5724: LIST
5725: PPUSH
5726: CALL_OW 72
5730: NOT
5731: IFFALSE 5708
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5733: LD_VAR 0 2
5737: PPUSH
5738: LD_VAR 0 6
5742: PPUSH
5743: LD_VAR 0 5
5747: PPUSH
5748: LD_VAR 0 4
5752: PPUSH
5753: CALL 77705 0 4
// end ;
5757: PPOPN 6
5759: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5760: LD_INT 1
5762: PPUSH
5763: CALL_OW 302
5767: PUSH
5768: LD_EXP 9
5772: AND
5773: PUSH
5774: LD_EXP 48
5778: PPUSH
5779: LD_INT 22
5781: PPUSH
5782: CALL_OW 308
5786: AND
5787: PUSH
5788: LD_INT 1
5790: PPUSH
5791: CALL 77868 0 1
5795: PUSH
5796: LD_INT 0
5798: EQUAL
5799: AND
5800: PUSH
5801: LD_EXP 10
5805: NOT
5806: AND
5807: IFFALSE 6282
5809: GO 5811
5811: DISABLE
5812: LD_INT 0
5814: PPUSH
5815: PPUSH
5816: PPUSH
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
// begin base := 1 ;
5821: LD_ADDR_VAR 0 2
5825: PUSH
5826: LD_INT 1
5828: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5829: LD_ADDR_VAR 0 4
5833: PUSH
5834: LD_INT 0
5836: PUSH
5837: LD_INT 0
5839: PUSH
5840: LD_INT 0
5842: PUSH
5843: LD_INT 0
5845: PUSH
5846: LD_INT 0
5848: PUSH
5849: LD_INT 0
5851: PUSH
5852: LD_INT 0
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: LD_INT 1
5860: PUSH
5861: LD_INT 0
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: LIST
5868: LIST
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5876: LD_ADDR_VAR 0 3
5880: PUSH
5881: LD_INT 13
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 2
5889: PUSH
5890: LD_INT 28
5892: PUSH
5893: EMPTY
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_INT 13
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 27
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 13
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: LD_INT 25
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 11
5937: PUSH
5938: LD_INT 2
5940: PUSH
5941: LD_INT 2
5943: PUSH
5944: LD_INT 24
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 11
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 24
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: EMPTY
5972: LIST
5973: LIST
5974: LIST
5975: LIST
5976: LIST
5977: ST_TO_ADDR
// MC_SetProduceList ( base , tmp ) ;
5978: LD_VAR 0 2
5982: PPUSH
5983: LD_VAR 0 3
5987: PPUSH
5988: CALL 77414 0 2
// repeat wait ( 0 0$1 ) ;
5992: LD_INT 35
5994: PPUSH
5995: CALL_OW 67
// until MC_GetProduceList ( base ) = 0 ;
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 77868 0 1
6008: PUSH
6009: LD_INT 0
6011: EQUAL
6012: IFFALSE 5992
// wait ( 0 0$20 ) ;
6014: LD_INT 700
6016: PPUSH
6017: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6021: LD_ADDR_VAR 0 5
6025: PUSH
6026: LD_INT 119
6028: PUSH
6029: LD_INT 9
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: PUSH
6036: EMPTY
6037: LIST
6038: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff ( mc_defender [ base ] union UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ) ;
6039: LD_ADDR_VAR 0 6
6043: PUSH
6044: LD_EXP 77
6048: PUSH
6049: LD_VAR 0 2
6053: ARRAY
6054: PUSH
6055: LD_EXP 80
6059: PUSH
6060: LD_VAR 0 2
6064: ARRAY
6065: PUSH
6066: LD_EXP 77
6070: PUSH
6071: LD_VAR 0 2
6075: ARRAY
6076: PPUSH
6077: LD_INT 34
6079: PUSH
6080: LD_INT 32
6082: PUSH
6083: EMPTY
6084: LIST
6085: LIST
6086: PPUSH
6087: CALL_OW 72
6091: UNION
6092: DIFF
6093: ST_TO_ADDR
// if not attackers then
6094: LD_VAR 0 6
6098: NOT
6099: IFFALSE 6103
// exit ;
6101: GO 6282
// uc_side := 2 ;
6103: LD_ADDR_OWVAR 20
6107: PUSH
6108: LD_INT 2
6110: ST_TO_ADDR
// uc_nation := 2 ;
6111: LD_ADDR_OWVAR 21
6115: PUSH
6116: LD_INT 2
6118: ST_TO_ADDR
// InitHc ;
6119: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6123: LD_ADDR_VAR 0 1
6127: PUSH
6128: DOUBLE
6129: LD_INT 1
6131: DEC
6132: ST_TO_ADDR
6133: LD_INT 4
6135: PUSH
6136: LD_INT 5
6138: PUSH
6139: LD_INT 6
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_OWVAR 67
6151: ARRAY
6152: PUSH
6153: FOR_TO
6154: IFFALSE 6231
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6156: LD_INT 0
6158: PPUSH
6159: LD_INT 15
6161: PUSH
6162: LD_INT 17
6164: PUSH
6165: EMPTY
6166: LIST
6167: LIST
6168: PUSH
6169: LD_INT 1
6171: PPUSH
6172: LD_INT 2
6174: PPUSH
6175: CALL_OW 12
6179: ARRAY
6180: PPUSH
6181: LD_INT 8
6183: PPUSH
6184: CALL_OW 380
// un := CreateHuman ;
6188: LD_ADDR_VAR 0 7
6192: PUSH
6193: CALL_OW 44
6197: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6198: LD_VAR 0 7
6202: PPUSH
6203: LD_INT 23
6205: PPUSH
6206: LD_INT 0
6208: PPUSH
6209: CALL_OW 49
// attackers := attackers union un ;
6213: LD_ADDR_VAR 0 6
6217: PUSH
6218: LD_VAR 0 6
6222: PUSH
6223: LD_VAR 0 7
6227: UNION
6228: ST_TO_ADDR
// end ;
6229: GO 6153
6231: POP
6232: POP
// repeat wait ( 0 0$1 ) ;
6233: LD_INT 35
6235: PPUSH
6236: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6240: LD_VAR 0 6
6244: PPUSH
6245: LD_INT 60
6247: PUSH
6248: EMPTY
6249: LIST
6250: PPUSH
6251: CALL_OW 72
6255: NOT
6256: IFFALSE 6233
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6258: LD_VAR 0 2
6262: PPUSH
6263: LD_VAR 0 6
6267: PPUSH
6268: LD_VAR 0 5
6272: PPUSH
6273: LD_VAR 0 4
6277: PPUSH
6278: CALL 77705 0 4
// end ; end_of_file
6282: PPOPN 7
6284: END
// export function PrepareAmericanAttack ; var i , tmp , veh , flags , _target ; begin
6285: LD_INT 0
6287: PPUSH
6288: PPUSH
6289: PPUSH
6290: PPUSH
6291: PPUSH
6292: PPUSH
// uc_side := 1 ;
6293: LD_ADDR_OWVAR 20
6297: PUSH
6298: LD_INT 1
6300: ST_TO_ADDR
// uc_nation := 1 ;
6301: LD_ADDR_OWVAR 21
6305: PUSH
6306: LD_INT 1
6308: ST_TO_ADDR
// InitHc ;
6309: CALL_OW 19
// InitVc ;
6313: CALL_OW 20
// tmp := [ ] ;
6317: LD_ADDR_VAR 0 3
6321: PUSH
6322: EMPTY
6323: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6324: LD_ADDR_VAR 0 5
6328: PUSH
6329: LD_INT 0
6331: PUSH
6332: LD_INT 0
6334: PUSH
6335: LD_INT 0
6337: PUSH
6338: LD_INT 0
6340: PUSH
6341: LD_INT 0
6343: PUSH
6344: LD_INT 0
6346: PUSH
6347: LD_INT 0
6349: PUSH
6350: LD_INT 0
6352: PUSH
6353: LD_INT 1
6355: PUSH
6356: LD_INT 0
6358: PUSH
6359: EMPTY
6360: LIST
6361: LIST
6362: LIST
6363: LIST
6364: LIST
6365: LIST
6366: LIST
6367: LIST
6368: LIST
6369: LIST
6370: ST_TO_ADDR
// _target := [ [ 71 , 34 ] , [ 63 , 49 ] ] ;
6371: LD_ADDR_VAR 0 6
6375: PUSH
6376: LD_INT 71
6378: PUSH
6379: LD_INT 34
6381: PUSH
6382: EMPTY
6383: LIST
6384: LIST
6385: PUSH
6386: LD_INT 63
6388: PUSH
6389: LD_INT 49
6391: PUSH
6392: EMPTY
6393: LIST
6394: LIST
6395: PUSH
6396: EMPTY
6397: LIST
6398: LIST
6399: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6400: LD_ADDR_VAR 0 2
6404: PUSH
6405: DOUBLE
6406: LD_INT 1
6408: DEC
6409: ST_TO_ADDR
6410: LD_INT 5
6412: PUSH
6413: LD_INT 6
6415: PUSH
6416: LD_INT 6
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: PUSH
6424: LD_OWVAR 67
6428: ARRAY
6429: PUSH
6430: FOR_TO
6431: IFFALSE 6568
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6433: LD_INT 2
6435: PUSH
6436: LD_INT 4
6438: PUSH
6439: LD_INT 5
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: LIST
6446: PUSH
6447: LD_INT 1
6449: PPUSH
6450: LD_INT 3
6452: PPUSH
6453: CALL_OW 12
6457: ARRAY
6458: PPUSH
6459: LD_INT 1
6461: PUSH
6462: LD_INT 3
6464: PUSH
6465: EMPTY
6466: LIST
6467: LIST
6468: PUSH
6469: LD_INT 1
6471: PPUSH
6472: LD_INT 2
6474: PPUSH
6475: CALL_OW 12
6479: ARRAY
6480: PPUSH
6481: LD_INT 3
6483: PPUSH
6484: LD_INT 9
6486: PUSH
6487: LD_INT 7
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: PUSH
6494: LD_INT 1
6496: PPUSH
6497: LD_INT 2
6499: PPUSH
6500: CALL_OW 12
6504: ARRAY
6505: PPUSH
6506: LD_INT 78
6508: PPUSH
6509: CALL 20140 0 5
// veh := CreateVehicle ;
6513: LD_ADDR_VAR 0 4
6517: PUSH
6518: CALL_OW 45
6522: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6523: LD_VAR 0 4
6527: PPUSH
6528: LD_INT 2
6530: PPUSH
6531: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6535: LD_VAR 0 4
6539: PPUSH
6540: LD_INT 17
6542: PPUSH
6543: LD_INT 0
6545: PPUSH
6546: CALL_OW 49
// tmp := tmp ^ veh ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 4
6564: ADD
6565: ST_TO_ADDR
// end ;
6566: GO 6430
6568: POP
6569: POP
// if not tmp then
6570: LD_VAR 0 3
6574: NOT
6575: IFFALSE 6579
// exit ;
6577: GO 6622
// if not first_powell_attack then
6579: LD_EXP 11
6583: NOT
6584: IFFALSE 6594
// first_powell_attack := true ;
6586: LD_ADDR_EXP 11
6590: PUSH
6591: LD_INT 1
6593: ST_TO_ADDR
// Attack ( [ 0 , tmp , _target , flags ] ) ;
6594: LD_INT 0
6596: PUSH
6597: LD_VAR 0 3
6601: PUSH
6602: LD_VAR 0 6
6606: PUSH
6607: LD_VAR 0 5
6611: PUSH
6612: EMPTY
6613: LIST
6614: LIST
6615: LIST
6616: LIST
6617: PPUSH
6618: CALL 48561 0 1
// end ; end_of_file
6622: LD_VAR 0 1
6626: RET
// export function Action ; var tmp , i , un ; begin
6627: LD_INT 0
6629: PPUSH
6630: PPUSH
6631: PPUSH
6632: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6633: LD_INT 68
6635: PPUSH
6636: LD_INT 39
6638: PPUSH
6639: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6643: LD_ADDR_VAR 0 2
6647: PUSH
6648: LD_INT 22
6650: PUSH
6651: LD_INT 7
6653: PUSH
6654: EMPTY
6655: LIST
6656: LIST
6657: PPUSH
6658: CALL_OW 69
6662: ST_TO_ADDR
// InGameOn ;
6663: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 71
6674: PPUSH
6675: LD_INT 49
6677: PPUSH
6678: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6682: LD_INT 35
6684: PPUSH
6685: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6689: LD_INT 7
6691: PPUSH
6692: LD_INT 71
6694: PPUSH
6695: LD_INT 51
6697: PPUSH
6698: CALL_OW 293
6702: IFFALSE 6682
// DialogueOn ;
6704: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6708: LD_EXP 14
6712: PPUSH
6713: LD_STRING D1-JMM-1
6715: PPUSH
6716: CALL_OW 88
// if Joan then
6720: LD_EXP 29
6724: IFFALSE 6738
// Say ( Joan , D1-Joan-1 ) ;
6726: LD_EXP 29
6730: PPUSH
6731: LD_STRING D1-Joan-1
6733: PPUSH
6734: CALL_OW 88
// if Lisa then
6738: LD_EXP 16
6742: IFFALSE 6756
// Say ( Lisa , D1-Lisa-1 ) ;
6744: LD_EXP 16
6748: PPUSH
6749: LD_STRING D1-Lisa-1
6751: PPUSH
6752: CALL_OW 88
// if Joan or Lisa then
6756: LD_EXP 29
6760: PUSH
6761: LD_EXP 16
6765: OR
6766: IFFALSE 6780
// Say ( JMM , D1-JMM-2 ) ;
6768: LD_EXP 14
6772: PPUSH
6773: LD_STRING D1-JMM-2
6775: PPUSH
6776: CALL_OW 88
// DialogueOff ;
6780: CALL_OW 7
// InGameOff ;
6784: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6788: LD_INT 71
6790: PPUSH
6791: LD_INT 50
6793: PPUSH
6794: LD_INT 7
6796: PPUSH
6797: LD_INT 30
6799: NEG
6800: PPUSH
6801: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6805: LD_INT 71
6807: PPUSH
6808: LD_INT 50
6810: PPUSH
6811: LD_INT 7
6813: PPUSH
6814: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6818: LD_STRING M1
6820: PPUSH
6821: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6825: LD_INT 35
6827: PPUSH
6828: CALL_OW 67
// until freedom ;
6832: LD_EXP 3
6836: IFFALSE 6825
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6838: LD_INT 350
6840: PPUSH
6841: LD_INT 700
6843: PPUSH
6844: CALL_OW 12
6848: PPUSH
6849: CALL_OW 67
// PrepareGossudarov ;
6853: CALL 1684 0 0
// repeat wait ( 0 0$1 ) ;
6857: LD_INT 35
6859: PPUSH
6860: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
6864: LD_INT 22
6866: PUSH
6867: LD_INT 6
6869: PUSH
6870: EMPTY
6871: LIST
6872: LIST
6873: PUSH
6874: LD_INT 3
6876: PUSH
6877: LD_INT 24
6879: PUSH
6880: LD_INT 1000
6882: PUSH
6883: EMPTY
6884: LIST
6885: LIST
6886: PUSH
6887: EMPTY
6888: LIST
6889: LIST
6890: PUSH
6891: EMPTY
6892: LIST
6893: LIST
6894: PPUSH
6895: CALL_OW 69
6899: IFFALSE 6857
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6901: LD_ADDR_VAR 0 2
6905: PUSH
6906: LD_INT 22
6908: PUSH
6909: LD_INT 6
6911: PUSH
6912: EMPTY
6913: LIST
6914: LIST
6915: PPUSH
6916: CALL_OW 69
6920: ST_TO_ADDR
// for i in tmp do
6921: LD_ADDR_VAR 0 3
6925: PUSH
6926: LD_VAR 0 2
6930: PUSH
6931: FOR_IN
6932: IFFALSE 6948
// SetSide ( i , 7 ) ;
6934: LD_VAR 0 3
6938: PPUSH
6939: LD_INT 7
6941: PPUSH
6942: CALL_OW 235
6946: GO 6931
6948: POP
6949: POP
// DialogueOn ;
6950: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
6954: LD_EXP 14
6958: PUSH
6959: LD_EXP 15
6963: PUSH
6964: EMPTY
6965: LIST
6966: LIST
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
6977: LD_EXP 31
6981: PPUSH
6982: CALL_OW 87
// if not Roth then
6986: LD_EXP 15
6990: NOT
6991: IFFALSE 7055
// begin Say ( JMM , D2-JMM-1 ) ;
6993: LD_EXP 14
6997: PPUSH
6998: LD_STRING D2-JMM-1
7000: PPUSH
7001: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7005: LD_EXP 14
7009: PPUSH
7010: LD_STRING D2-JMM-1b
7012: PPUSH
7013: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7017: LD_EXP 31
7021: PPUSH
7022: LD_STRING D2-Gos-1
7024: PPUSH
7025: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7029: LD_EXP 14
7033: PPUSH
7034: LD_STRING D2-JMM-2
7036: PPUSH
7037: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7041: LD_EXP 31
7045: PPUSH
7046: LD_STRING D2-Gos-2
7048: PPUSH
7049: CALL_OW 88
// end else
7053: GO 7151
// begin Say ( Roth , D2-Roth-2 ) ;
7055: LD_EXP 15
7059: PPUSH
7060: LD_STRING D2-Roth-2
7062: PPUSH
7063: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7067: LD_EXP 14
7071: PPUSH
7072: LD_STRING D2-JMM-1a
7074: PPUSH
7075: CALL_OW 88
// Say ( Roth , D2-Roth-2a ) ;
7079: LD_EXP 15
7083: PPUSH
7084: LD_STRING D2-Roth-2a
7086: PPUSH
7087: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7091: LD_EXP 15
7095: PPUSH
7096: LD_STRING D2-Roth-2b
7098: PPUSH
7099: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7103: LD_EXP 14
7107: PPUSH
7108: LD_STRING D2-JMM-3
7110: PPUSH
7111: CALL_OW 88
// Say ( Gossudarov , D2-Gos-3 ) ;
7115: LD_EXP 31
7119: PPUSH
7120: LD_STRING D2-Gos-3
7122: PPUSH
7123: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7127: LD_EXP 14
7131: PPUSH
7132: LD_STRING D2-JMM-4
7134: PPUSH
7135: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7139: LD_EXP 31
7143: PPUSH
7144: LD_STRING D2-Gos-4
7146: PPUSH
7147: CALL_OW 88
// end ; Say ( JMM , D2-JMM-5 ) ;
7151: LD_EXP 14
7155: PPUSH
7156: LD_STRING D2-JMM-5
7158: PPUSH
7159: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7163: LD_EXP 31
7167: PPUSH
7168: LD_STRING D2-Gos-5
7170: PPUSH
7171: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7175: LD_EXP 14
7179: PPUSH
7180: LD_STRING D2-JMM-6
7182: PPUSH
7183: CALL_OW 88
// DialogueOff ;
7187: CALL_OW 7
// wait ( 0 0$2 ) ;
7191: LD_INT 70
7193: PPUSH
7194: CALL_OW 67
// if Kirilenkova then
7198: LD_EXP 32
7202: IFFALSE 7216
// Say ( Kirilenkova , D3-Kir-1 ) ;
7204: LD_EXP 32
7208: PPUSH
7209: LD_STRING D3-Kir-1
7211: PPUSH
7212: CALL_OW 88
// gossudarov_arrive := true ;
7216: LD_ADDR_EXP 4
7220: PUSH
7221: LD_INT 1
7223: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7224: LD_INT 35
7226: PPUSH
7227: CALL_OW 67
// until ru_lab_builded ;
7231: LD_EXP 5
7235: IFFALSE 7224
// if Kirilenkova then
7237: LD_EXP 32
7241: IFFALSE 7257
// Say ( Kirilenkova , D3a-Kir-1 ) else
7243: LD_EXP 32
7247: PPUSH
7248: LD_STRING D3a-Kir-1
7250: PPUSH
7251: CALL_OW 88
7255: GO 7279
// begin un := SciRu ;
7257: LD_ADDR_VAR 0 4
7261: PUSH
7262: CALL 12046 0 0
7266: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7267: LD_VAR 0 4
7271: PPUSH
7272: LD_STRING D3a-Sci1-1
7274: PPUSH
7275: CALL_OW 88
// end ; if Kirilenkova or un then
7279: LD_EXP 32
7283: PUSH
7284: LD_VAR 0 4
7288: OR
7289: IFFALSE 7303
// Say ( JMM , D3a-JMM-1 ) ;
7291: LD_EXP 14
7295: PPUSH
7296: LD_STRING D3a-JMM-1
7298: PPUSH
7299: CALL_OW 88
// end ;
7303: LD_VAR 0 1
7307: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 6 do
7308: LD_EXP 4
7312: PUSH
7313: LD_INT 22
7315: PUSH
7316: LD_INT 7
7318: PUSH
7319: EMPTY
7320: LIST
7321: LIST
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 1
7331: PUSH
7332: EMPTY
7333: LIST
7334: LIST
7335: PUSH
7336: LD_INT 25
7338: PUSH
7339: LD_INT 2
7341: PUSH
7342: EMPTY
7343: LIST
7344: LIST
7345: PUSH
7346: LD_INT 25
7348: PUSH
7349: LD_INT 3
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: PUSH
7356: LD_INT 25
7358: PUSH
7359: LD_INT 4
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: PUSH
7366: LD_INT 25
7368: PUSH
7369: LD_INT 5
7371: PUSH
7372: EMPTY
7373: LIST
7374: LIST
7375: PUSH
7376: LD_INT 25
7378: PUSH
7379: LD_INT 8
7381: PUSH
7382: EMPTY
7383: LIST
7384: LIST
7385: PUSH
7386: LD_INT 25
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: EMPTY
7393: LIST
7394: LIST
7395: PUSH
7396: EMPTY
7397: LIST
7398: LIST
7399: LIST
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PPUSH
7410: CALL_OW 69
7414: PUSH
7415: LD_INT 6
7417: LESS
7418: AND
7419: IFFALSE 7431
7421: GO 7423
7423: DISABLE
// YouLost ( TooMany ) ;
7424: LD_STRING TooMany
7426: PPUSH
7427: CALL_OW 104
7431: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7432: LD_EXP 31
7436: PPUSH
7437: CALL_OW 255
7441: PUSH
7442: LD_INT 7
7444: EQUAL
7445: IFFALSE 7645
7447: GO 7449
7449: DISABLE
7450: LD_INT 0
7452: PPUSH
7453: PPUSH
7454: PPUSH
// begin uc_side := 3 ;
7455: LD_ADDR_OWVAR 20
7459: PUSH
7460: LD_INT 3
7462: ST_TO_ADDR
// uc_nation := 3 ;
7463: LD_ADDR_OWVAR 21
7467: PUSH
7468: LD_INT 3
7470: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7471: LD_INT 21
7473: PPUSH
7474: LD_INT 3
7476: PPUSH
7477: LD_INT 3
7479: PPUSH
7480: LD_INT 42
7482: PPUSH
7483: LD_INT 100
7485: PPUSH
7486: CALL 20140 0 5
// un := CreateVehicle ;
7490: LD_ADDR_VAR 0 3
7494: PUSH
7495: CALL_OW 45
7499: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7500: LD_VAR 0 3
7504: PPUSH
7505: LD_INT 15
7507: PPUSH
7508: LD_INT 0
7510: PPUSH
7511: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7515: LD_VAR 0 3
7519: PPUSH
7520: LD_INT 67
7522: PPUSH
7523: LD_INT 45
7525: PPUSH
7526: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7530: LD_VAR 0 3
7534: PPUSH
7535: LD_INT 70
7537: PPUSH
7538: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7542: LD_VAR 0 3
7546: PPUSH
7547: LD_INT 69
7549: PPUSH
7550: LD_INT 18
7552: PPUSH
7553: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7557: LD_VAR 0 3
7561: PPUSH
7562: LD_INT 60
7564: PPUSH
7565: LD_INT 2
7567: PPUSH
7568: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7572: LD_INT 35
7574: PPUSH
7575: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7579: LD_VAR 0 3
7583: PPUSH
7584: CALL_OW 302
7588: NOT
7589: PUSH
7590: LD_VAR 0 3
7594: PPUSH
7595: LD_INT 17
7597: PPUSH
7598: CALL_OW 308
7602: OR
7603: IFFALSE 7572
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7605: LD_VAR 0 3
7609: PPUSH
7610: LD_INT 17
7612: PPUSH
7613: CALL_OW 308
7617: PUSH
7618: LD_VAR 0 3
7622: PPUSH
7623: LD_INT 60
7625: PPUSH
7626: LD_INT 2
7628: PPUSH
7629: CALL_OW 307
7633: OR
7634: IFFALSE 7645
// RemoveUnit ( un ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: CALL_OW 64
// end ;
7645: PPOPN 3
7647: END
// every 0 0$2 do var i , un , tmp ;
7648: GO 7650
7650: DISABLE
7651: LD_INT 0
7653: PPUSH
7654: PPUSH
7655: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7656: LD_INT 70
7658: PPUSH
7659: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7663: LD_ADDR_VAR 0 3
7667: PUSH
7668: LD_INT 22
7670: PUSH
7671: LD_INT 7
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 101
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: EMPTY
7689: LIST
7690: LIST
7691: PPUSH
7692: CALL_OW 69
7696: ST_TO_ADDR
// until tmp ;
7697: LD_VAR 0 3
7701: IFFALSE 7656
// un := NearestUnitToUnit ( tmp , JMM ) ;
7703: LD_ADDR_VAR 0 2
7707: PUSH
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_EXP 14
7717: PPUSH
7718: CALL_OW 74
7722: ST_TO_ADDR
// player_spotted := true ;
7723: LD_ADDR_EXP 6
7727: PUSH
7728: LD_INT 1
7730: ST_TO_ADDR
// tmp := SciRu ;
7731: LD_ADDR_VAR 0 3
7735: PUSH
7736: CALL 12046 0 0
7740: ST_TO_ADDR
// DialogueOn ;
7741: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7745: LD_VAR 0 2
7749: PPUSH
7750: CALL_OW 250
7754: PPUSH
7755: LD_VAR 0 2
7759: PPUSH
7760: CALL_OW 251
7764: PPUSH
7765: LD_INT 7
7767: PPUSH
7768: LD_INT 8
7770: NEG
7771: PPUSH
7772: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: CALL_OW 87
// if tmp then
7785: LD_VAR 0 3
7789: IFFALSE 7803
// Say ( tmp , D4-RSci1-1 ) ;
7791: LD_VAR 0 3
7795: PPUSH
7796: LD_STRING D4-RSci1-1
7798: PPUSH
7799: CALL_OW 88
// if Gossudarov then
7803: LD_EXP 31
7807: IFFALSE 7833
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7809: LD_EXP 31
7813: PPUSH
7814: LD_STRING D4-Gos-1
7816: PPUSH
7817: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7821: LD_EXP 14
7825: PPUSH
7826: LD_STRING D4-JMM-1
7828: PPUSH
7829: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
7833: LD_VAR 0 2
7837: PPUSH
7838: CALL_OW 250
7842: PPUSH
7843: LD_VAR 0 2
7847: PPUSH
7848: CALL_OW 251
7852: PPUSH
7853: LD_INT 7
7855: PPUSH
7856: CALL_OW 331
// DialogueOff ;
7860: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
7864: LD_STRING M5
7866: PPUSH
7867: CALL_OW 337
// end ;
7871: PPOPN 3
7873: END
// every 0 0$30 + 2 2$30 trigger player_spotted do
7874: LD_EXP 6
7878: IFFALSE 8337
7880: GO 7882
7882: DISABLE
// begin PrepareBelkov ;
7883: CALL 1934 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
7887: LD_EXP 46
7891: PPUSH
7892: LD_INT 118
7894: PPUSH
7895: LD_INT 106
7897: PPUSH
7898: CALL_OW 111
// AddComHold ( Belkov ) ;
7902: LD_EXP 46
7906: PPUSH
7907: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
7911: LD_INT 35
7913: PPUSH
7914: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
7918: LD_EXP 46
7922: PPUSH
7923: LD_INT 118
7925: PPUSH
7926: LD_INT 106
7928: PPUSH
7929: CALL_OW 307
7933: IFFALSE 7911
// ChangeSideFog ( 4 , 7 ) ;
7935: LD_INT 4
7937: PPUSH
7938: LD_INT 7
7940: PPUSH
7941: CALL_OW 343
// if IsOk ( Belkov ) then
7945: LD_EXP 46
7949: PPUSH
7950: CALL_OW 302
7954: IFFALSE 8038
// begin InGameOn ;
7956: CALL_OW 8
// DialogueOn ;
7960: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
7964: LD_EXP 46
7968: PPUSH
7969: LD_STRING D5-Bel-1
7971: PPUSH
7972: CALL_OW 94
// if Gossudarov then
7976: LD_EXP 31
7980: IFFALSE 8030
// begin Say ( Gossudarov , D5-Gos-1 ) ;
7982: LD_EXP 31
7986: PPUSH
7987: LD_STRING D5-Gos-1
7989: PPUSH
7990: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
7994: LD_EXP 14
7998: PPUSH
7999: LD_STRING D5-JMM-1
8001: PPUSH
8002: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8006: LD_EXP 31
8010: PPUSH
8011: LD_STRING D5-Gos-2
8013: PPUSH
8014: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8018: LD_EXP 14
8022: PPUSH
8023: LD_STRING D5-JMM-2
8025: PPUSH
8026: CALL_OW 88
// end ; DialogueOff ;
8030: CALL_OW 7
// InGameOff ;
8034: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8038: LD_STRING QSaveBelkov
8040: PPUSH
8041: CALL_OW 97
8045: PUSH
8046: LD_INT 1
8048: DOUBLE
8049: EQUAL
8050: IFTRUE 8054
8052: GO 8104
8054: POP
// begin DialogueOn ;
8055: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8059: LD_EXP 14
8063: PPUSH
8064: LD_STRING D5a-JMM-1
8066: PPUSH
8067: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8071: LD_EXP 46
8075: PPUSH
8076: LD_STRING D5a-Bel-1
8078: PPUSH
8079: CALL_OW 94
// DialogueOff ;
8083: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8087: LD_EXP 46
8091: PPUSH
8092: LD_INT 83
8094: PPUSH
8095: LD_INT 49
8097: PPUSH
8098: CALL_OW 111
// end ; 2 :
8102: GO 8164
8104: LD_INT 2
8106: DOUBLE
8107: EQUAL
8108: IFTRUE 8112
8110: GO 8163
8112: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8113: LD_EXP 14
8117: PPUSH
8118: LD_STRING D5a-JMM-2
8120: PPUSH
8121: CALL_OW 88
// ComWait ( Belkov , 0 0$10 ) ;
8125: LD_EXP 46
8129: PPUSH
8130: LD_INT 350
8132: PPUSH
8133: CALL_OW 142
// AddComMoveXY ( Belkov , 107 , 109 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_INT 107
8144: PPUSH
8145: LD_INT 109
8147: PPUSH
8148: CALL_OW 171
// AddComHold ( Belkov ) ;
8152: LD_EXP 46
8156: PPUSH
8157: CALL_OW 200
// end ; end ;
8161: GO 8164
8163: POP
// repeat wait ( 0 0$1 ) ;
8164: LD_INT 35
8166: PPUSH
8167: CALL_OW 67
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8171: LD_EXP 46
8175: PPUSH
8176: CALL_OW 301
8180: PUSH
8181: LD_EXP 46
8185: PPUSH
8186: CALL_OW 255
8190: PUSH
8191: LD_INT 4
8193: EQUAL
8194: AND
8195: PUSH
8196: LD_INT 22
8198: PUSH
8199: LD_INT 7
8201: PUSH
8202: EMPTY
8203: LIST
8204: LIST
8205: PPUSH
8206: CALL_OW 69
8210: PPUSH
8211: LD_EXP 46
8215: PPUSH
8216: CALL_OW 74
8220: PPUSH
8221: LD_EXP 46
8225: PPUSH
8226: CALL_OW 296
8230: PUSH
8231: LD_INT 10
8233: LESS
8234: OR
8235: IFFALSE 8164
// if IsDead ( Belkov ) then
8237: LD_EXP 46
8241: PPUSH
8242: CALL_OW 301
8246: IFFALSE 8271
// begin CenterNowOnUnits ( Belkov ) ;
8248: LD_EXP 46
8252: PPUSH
8253: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8257: LD_EXP 14
8261: PPUSH
8262: LD_STRING D5a-JMM-2a
8264: PPUSH
8265: CALL_OW 88
// exit ;
8269: GO 8337
// end ; if See ( 7 , Belkov ) then
8271: LD_INT 7
8273: PPUSH
8274: LD_EXP 46
8278: PPUSH
8279: CALL_OW 292
8283: IFFALSE 8297
// SetSide ( Belkov , 7 ) ;
8285: LD_EXP 46
8289: PPUSH
8290: LD_INT 7
8292: PPUSH
8293: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8297: LD_INT 35
8299: PPUSH
8300: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8304: LD_EXP 46
8308: PPUSH
8309: LD_INT 66
8311: PPUSH
8312: LD_INT 45
8314: PPUSH
8315: CALL_OW 297
8319: PUSH
8320: LD_INT 30
8322: LESS
8323: IFFALSE 8297
// Say ( Belkov , D6-Bel-1 ) ;
8325: LD_EXP 46
8329: PPUSH
8330: LD_STRING D6-Bel-1
8332: PPUSH
8333: CALL_OW 88
// end ;
8337: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8338: LD_EXP 46
8342: PPUSH
8343: CALL_OW 302
8347: PUSH
8348: LD_EXP 46
8352: PPUSH
8353: CALL_OW 504
8357: PUSH
8358: LD_INT 2
8360: PUSH
8361: LD_INT 34
8363: PUSH
8364: LD_INT 47
8366: PUSH
8367: EMPTY
8368: LIST
8369: LIST
8370: PUSH
8371: LD_INT 34
8373: PUSH
8374: LD_INT 45
8376: PUSH
8377: EMPTY
8378: LIST
8379: LIST
8380: PUSH
8381: EMPTY
8382: LIST
8383: LIST
8384: LIST
8385: PPUSH
8386: CALL_OW 69
8390: IN
8391: AND
8392: IFFALSE 8409
8394: GO 8396
8396: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8397: LD_EXP 46
8401: PPUSH
8402: LD_STRING D7-Bel-1
8404: PPUSH
8405: CALL_OW 88
8409: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8410: LD_INT 22
8412: PUSH
8413: LD_INT 7
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 101
8422: PUSH
8423: LD_INT 2
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PPUSH
8434: CALL_OW 69
8438: PUSH
8439: LD_EXP 8
8443: NOT
8444: AND
8445: PUSH
8446: LD_EXP 45
8450: PPUSH
8451: CALL_OW 305
8455: NOT
8456: AND
8457: IFFALSE 8927
8459: GO 8461
8461: DISABLE
8462: LD_INT 0
8464: PPUSH
// begin ar_base_spotted := true ;
8465: LD_ADDR_EXP 8
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: LD_INT 22
8480: PUSH
8481: LD_INT 2
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PUSH
8488: LD_INT 21
8490: PUSH
8491: LD_INT 3
8493: PUSH
8494: EMPTY
8495: LIST
8496: LIST
8497: PUSH
8498: EMPTY
8499: LIST
8500: LIST
8501: PPUSH
8502: CALL_OW 69
8506: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8507: LD_ADDR_VAR 0 1
8511: PUSH
8512: LD_VAR 0 1
8516: PPUSH
8517: LD_EXP 14
8521: PPUSH
8522: CALL_OW 74
8526: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8527: LD_INT 7
8529: PPUSH
8530: LD_INT 3
8532: PPUSH
8533: CALL_OW 332
// DialogueOn ;
8537: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8541: LD_VAR 0 1
8545: PPUSH
8546: CALL_OW 250
8550: PPUSH
8551: LD_VAR 0 1
8555: PPUSH
8556: CALL_OW 251
8560: PPUSH
8561: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_INT 22
8572: PUSH
8573: LD_INT 7
8575: PUSH
8576: EMPTY
8577: LIST
8578: LIST
8579: PUSH
8580: LD_INT 23
8582: PUSH
8583: LD_INT 1
8585: PUSH
8586: EMPTY
8587: LIST
8588: LIST
8589: PUSH
8590: LD_INT 26
8592: PUSH
8593: LD_INT 1
8595: PUSH
8596: EMPTY
8597: LIST
8598: LIST
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: LIST
8604: PPUSH
8605: CALL_OW 69
8609: PUSH
8610: LD_EXP 14
8614: PUSH
8615: LD_EXP 18
8619: PUSH
8620: LD_EXP 19
8624: PUSH
8625: LD_EXP 26
8629: PUSH
8630: LD_EXP 15
8634: PUSH
8635: LD_EXP 24
8639: PUSH
8640: LD_EXP 20
8644: PUSH
8645: LD_EXP 22
8649: PUSH
8650: EMPTY
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: LIST
8657: LIST
8658: LIST
8659: DIFF
8660: ST_TO_ADDR
// if not tmp then
8661: LD_VAR 0 1
8665: NOT
8666: IFFALSE 8740
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8668: LD_ADDR_VAR 0 1
8672: PUSH
8673: LD_INT 22
8675: PUSH
8676: LD_INT 7
8678: PUSH
8679: EMPTY
8680: LIST
8681: LIST
8682: PUSH
8683: LD_INT 23
8685: PUSH
8686: LD_INT 1
8688: PUSH
8689: EMPTY
8690: LIST
8691: LIST
8692: PUSH
8693: LD_INT 26
8695: PUSH
8696: LD_INT 2
8698: PUSH
8699: EMPTY
8700: LIST
8701: LIST
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: LIST
8707: PPUSH
8708: CALL_OW 69
8712: PUSH
8713: LD_EXP 29
8717: PUSH
8718: LD_EXP 16
8722: PUSH
8723: LD_EXP 27
8727: PUSH
8728: LD_EXP 28
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: DIFF
8739: ST_TO_ADDR
// if tmp then
8740: LD_VAR 0 1
8744: IFFALSE 8815
// case GetSex ( tmp [ 1 ] ) of sex_male :
8746: LD_VAR 0 1
8750: PUSH
8751: LD_INT 1
8753: ARRAY
8754: PPUSH
8755: CALL_OW 258
8759: PUSH
8760: LD_INT 1
8762: DOUBLE
8763: EQUAL
8764: IFTRUE 8768
8766: GO 8787
8768: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
8769: LD_VAR 0 1
8773: PUSH
8774: LD_INT 1
8776: ARRAY
8777: PPUSH
8778: LD_STRING D9-Sol1-1
8780: PPUSH
8781: CALL_OW 88
8785: GO 8815
8787: LD_INT 2
8789: DOUBLE
8790: EQUAL
8791: IFTRUE 8795
8793: GO 8814
8795: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
8796: LD_VAR 0 1
8800: PUSH
8801: LD_INT 1
8803: ARRAY
8804: PPUSH
8805: LD_STRING D9-FSol1-1
8807: PPUSH
8808: CALL_OW 88
8812: GO 8815
8814: POP
// if Frank then
8815: LD_EXP 26
8819: IFFALSE 8923
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
8821: LD_EXP 55
8825: PPUSH
8826: CALL_OW 250
8830: PPUSH
8831: LD_EXP 55
8835: PPUSH
8836: CALL_OW 251
8840: PPUSH
8841: LD_INT 7
8843: PPUSH
8844: LD_INT 8
8846: PPUSH
8847: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
8851: LD_EXP 55
8855: PPUSH
8856: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
8860: LD_EXP 26
8864: PPUSH
8865: LD_STRING D9-Frank-1
8867: PPUSH
8868: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
8872: LD_EXP 14
8876: PPUSH
8877: LD_STRING D9-JMM-1
8879: PPUSH
8880: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
8884: LD_EXP 26
8888: PPUSH
8889: LD_STRING D9-Frank-2
8891: PPUSH
8892: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
8896: LD_EXP 55
8900: PPUSH
8901: CALL_OW 250
8905: PPUSH
8906: LD_EXP 55
8910: PPUSH
8911: CALL_OW 251
8915: PPUSH
8916: LD_INT 7
8918: PPUSH
8919: CALL_OW 331
// end ; DialogueOff ;
8923: CALL_OW 7
// end ;
8927: PPOPN 1
8929: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
8930: LD_EXP 7
8934: PUSH
8935: LD_OWVAR 1
8939: PUSH
8940: LD_INT 42000
8942: GREATEREQUAL
8943: OR
8944: IFFALSE 9971
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
8952: PPUSH
// begin selected_option := 1 ;
8953: LD_ADDR_VAR 0 2
8957: PUSH
8958: LD_INT 1
8960: ST_TO_ADDR
// wait ( 5 5$00 ) ;
8961: LD_INT 10500
8963: PPUSH
8964: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
8968: LD_INT 35
8970: PPUSH
8971: CALL_OW 67
// until not ru_attackers ;
8975: LD_EXP 51
8979: NOT
8980: IFFALSE 8968
// PrepareBurlak ;
8982: CALL 2046 0 0
// repeat wait ( 0 0$2 ) ;
8986: LD_INT 70
8988: PPUSH
8989: CALL_OW 67
// until not HasTask ( Burlak ) ;
8993: LD_EXP 45
8997: PPUSH
8998: CALL_OW 314
9002: NOT
9003: IFFALSE 8986
// InGameOn ;
9005: CALL_OW 8
// DialogueOn ;
9009: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9013: LD_EXP 48
9017: PPUSH
9018: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9022: LD_EXP 45
9026: PPUSH
9027: LD_STRING D10-Bur-1
9029: PPUSH
9030: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9034: LD_EXP 46
9038: PUSH
9039: LD_EXP 46
9043: PPUSH
9044: CALL_OW 255
9048: PUSH
9049: LD_INT 7
9051: EQUAL
9052: AND
9053: IFFALSE 9067
// Say ( Belkov , D10-Bel-1 ) ;
9055: LD_EXP 46
9059: PPUSH
9060: LD_STRING D10-Bel-1
9062: PPUSH
9063: CALL_OW 88
// if Gossudarov then
9067: LD_EXP 31
9071: IFFALSE 9085
// Say ( Gossudarov , D10-Gos-1 ) ;
9073: LD_EXP 31
9077: PPUSH
9078: LD_STRING D10-Gos-1
9080: PPUSH
9081: CALL_OW 88
// if Kirilenkova then
9085: LD_EXP 32
9089: IFFALSE 9103
// Say ( Kirilenkova , D10-Kir-1 ) ;
9091: LD_EXP 32
9095: PPUSH
9096: LD_STRING D10-Kir-1
9098: PPUSH
9099: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9103: CALL 12175 0 0
9107: PPUSH
9108: LD_STRING D10-RSol1-1
9110: PPUSH
9111: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9115: LD_EXP 45
9119: PPUSH
9120: LD_STRING D10-Bur-2
9122: PPUSH
9123: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9127: LD_EXP 14
9131: PPUSH
9132: LD_STRING D10-JMM-2
9134: PPUSH
9135: CALL_OW 88
// if Kirilenkova then
9139: LD_EXP 32
9143: IFFALSE 9159
// Say ( Kirilenkova , D10-Kir-2 ) else
9145: LD_EXP 32
9149: PPUSH
9150: LD_STRING D10-Kir-2
9152: PPUSH
9153: CALL_OW 88
9157: GO 9171
// Say ( SolRu , D10-RSol1-2 ) ;
9159: CALL 12175 0 0
9163: PPUSH
9164: LD_STRING D10-RSol1-2
9166: PPUSH
9167: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9171: LD_EXP 14
9175: PPUSH
9176: LD_STRING D10-JMM-3
9178: PPUSH
9179: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9183: LD_EXP 45
9187: PPUSH
9188: LD_STRING D10-Bur-3
9190: PPUSH
9191: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9195: LD_EXP 14
9199: PPUSH
9200: LD_STRING D10-JMM-4
9202: PPUSH
9203: CALL_OW 88
// DialogueOff ;
9207: CALL_OW 7
// InGameOff ;
9211: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9215: LD_STRING M2
9217: PPUSH
9218: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9222: LD_INT 35
9224: PPUSH
9225: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9229: LD_INT 22
9231: PUSH
9232: LD_INT 7
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 91
9241: PUSH
9242: LD_EXP 45
9246: PUSH
9247: LD_INT 8
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: PPUSH
9259: CALL_OW 69
9263: IFFALSE 9222
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9265: LD_ADDR_VAR 0 1
9269: PUSH
9270: LD_INT 22
9272: PUSH
9273: LD_INT 4
9275: PUSH
9276: EMPTY
9277: LIST
9278: LIST
9279: PPUSH
9280: CALL_OW 69
9284: PUSH
9285: FOR_IN
9286: IFFALSE 9302
// SetSide ( i , 7 ) ;
9288: LD_VAR 0 1
9292: PPUSH
9293: LD_INT 7
9295: PPUSH
9296: CALL_OW 235
9300: GO 9285
9302: POP
9303: POP
// ChangeMissionObjectives ( M3 ) ;
9304: LD_STRING M3
9306: PPUSH
9307: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9311: LD_INT 35
9313: PPUSH
9314: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9318: LD_EXP 14
9322: PPUSH
9323: LD_EXP 45
9327: PPUSH
9328: CALL_OW 296
9332: PUSH
9333: LD_INT 8
9335: LESS
9336: IFFALSE 9311
// ComTurnUnit ( JMM , Burlak ) ;
9338: LD_EXP 14
9342: PPUSH
9343: LD_EXP 45
9347: PPUSH
9348: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9352: LD_EXP 45
9356: PPUSH
9357: LD_EXP 14
9361: PPUSH
9362: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9366: LD_INT 10
9368: PPUSH
9369: CALL_OW 67
// DialogueOn ;
9373: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9377: LD_EXP 14
9381: PPUSH
9382: LD_STRING D11-JMM-1
9384: PPUSH
9385: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9389: LD_EXP 45
9393: PPUSH
9394: LD_STRING D11-Bur-1
9396: PPUSH
9397: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9401: LD_EXP 14
9405: PPUSH
9406: LD_STRING D11-JMM-2
9408: PPUSH
9409: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9413: LD_EXP 45
9417: PPUSH
9418: LD_STRING D11-Bur-2
9420: PPUSH
9421: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9425: LD_EXP 14
9429: PPUSH
9430: LD_STRING D11-JMM-3
9432: PPUSH
9433: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9437: LD_EXP 45
9441: PPUSH
9442: LD_STRING D11-Bur-3
9444: PPUSH
9445: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9449: LD_EXP 14
9453: PPUSH
9454: LD_STRING D11-JMM-4
9456: PPUSH
9457: CALL_OW 88
// if ar_base_spotted then
9461: LD_EXP 8
9465: IFFALSE 9481
// Say ( Burlak , D12-Bur-1 ) else
9467: LD_EXP 45
9471: PPUSH
9472: LD_STRING D12-Bur-1
9474: PPUSH
9475: CALL_OW 88
9479: GO 9520
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9481: LD_INT 7
9483: PPUSH
9484: LD_INT 3
9486: PPUSH
9487: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9491: LD_INT 127
9493: PPUSH
9494: LD_INT 45
9496: PPUSH
9497: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9501: LD_EXP 45
9505: PPUSH
9506: LD_STRING D12-Bur-1a
9508: PPUSH
9509: CALL_OW 88
// dwait ( 0 0$2 ) ;
9513: LD_INT 70
9515: PPUSH
9516: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9520: LD_EXP 45
9524: PPUSH
9525: LD_STRING D12-Bur-1b
9527: PPUSH
9528: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9532: LD_EXP 14
9536: PPUSH
9537: LD_STRING D12-JMM-1
9539: PPUSH
9540: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9544: LD_EXP 45
9548: PPUSH
9549: LD_STRING D12-Bur-2
9551: PPUSH
9552: CALL_OW 88
// if Roth then
9556: LD_EXP 15
9560: IFFALSE 9576
// Say ( Roth , D12-Roth-2 ) else
9562: LD_EXP 15
9566: PPUSH
9567: LD_STRING D12-Roth-2
9569: PPUSH
9570: CALL_OW 88
9574: GO 9588
// Say ( SciRu , D12-RSci1-2 ) ;
9576: CALL 12046 0 0
9580: PPUSH
9581: LD_STRING D12-RSci1-2
9583: PPUSH
9584: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9588: LD_EXP 14
9592: PPUSH
9593: LD_STRING D12-JMM-2
9595: PPUSH
9596: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9600: LD_EXP 45
9604: PPUSH
9605: LD_STRING D12-Bur-3
9607: PPUSH
9608: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9612: LD_EXP 14
9616: PPUSH
9617: LD_STRING D12-JMM-3
9619: PPUSH
9620: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9624: LD_EXP 45
9628: PPUSH
9629: LD_STRING D12-Bur-4
9631: PPUSH
9632: CALL_OW 88
// case Query ( QBase ) of 1 :
9636: LD_STRING QBase
9638: PPUSH
9639: CALL_OW 97
9643: PUSH
9644: LD_INT 1
9646: DOUBLE
9647: EQUAL
9648: IFTRUE 9652
9650: GO 9770
9652: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9653: LD_EXP 14
9657: PPUSH
9658: LD_STRING D13a-JMM-1
9660: PPUSH
9661: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9665: LD_EXP 45
9669: PPUSH
9670: LD_STRING D13a-Bur-1
9672: PPUSH
9673: CALL_OW 88
// if Roth then
9677: LD_EXP 15
9681: IFFALSE 9697
// Say ( Roth , D13a-Roth-1 ) else
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D13a-Roth-1
9690: PPUSH
9691: CALL_OW 88
9695: GO 9709
// Say ( SciRu , D13a-RSci1-1 ) ;
9697: CALL 12046 0 0
9701: PPUSH
9702: LD_STRING D13a-RSci1-1
9704: PPUSH
9705: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
9709: LD_EXP 14
9713: PPUSH
9714: LD_STRING D13a-JMM-2
9716: PPUSH
9717: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
9721: LD_STRING QBaseAgain
9723: PPUSH
9724: CALL_OW 97
9728: PUSH
9729: LD_INT 1
9731: DOUBLE
9732: EQUAL
9733: IFTRUE 9737
9735: GO 9748
9737: POP
// selected_option := 2 ; 2 :
9738: LD_ADDR_VAR 0 2
9742: PUSH
9743: LD_INT 2
9745: ST_TO_ADDR
9746: GO 9768
9748: LD_INT 2
9750: DOUBLE
9751: EQUAL
9752: IFTRUE 9756
9754: GO 9767
9756: POP
// selected_option := 3 ; end ;
9757: LD_ADDR_VAR 0 2
9761: PUSH
9762: LD_INT 3
9764: ST_TO_ADDR
9765: GO 9768
9767: POP
// end ; 2 :
9768: GO 9809
9770: LD_INT 2
9772: DOUBLE
9773: EQUAL
9774: IFTRUE 9778
9776: GO 9789
9778: POP
// selected_option := 2 ; 3 :
9779: LD_ADDR_VAR 0 2
9783: PUSH
9784: LD_INT 2
9786: ST_TO_ADDR
9787: GO 9809
9789: LD_INT 3
9791: DOUBLE
9792: EQUAL
9793: IFTRUE 9797
9795: GO 9808
9797: POP
// selected_option := 3 ; end ;
9798: LD_ADDR_VAR 0 2
9802: PUSH
9803: LD_INT 3
9805: ST_TO_ADDR
9806: GO 9809
9808: POP
// if selected_option = 2 then
9809: LD_VAR 0 2
9813: PUSH
9814: LD_INT 2
9816: EQUAL
9817: IFFALSE 9911
// begin Say ( JMM , D13b-JMM-1 ) ;
9819: LD_EXP 14
9823: PPUSH
9824: LD_STRING D13b-JMM-1
9826: PPUSH
9827: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
9831: LD_EXP 45
9835: PPUSH
9836: LD_STRING D13b-Bur-1
9838: PPUSH
9839: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
9843: LD_EXP 14
9847: PPUSH
9848: LD_STRING D13b-JMM-2
9850: PPUSH
9851: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
9855: LD_EXP 54
9859: PPUSH
9860: LD_STRING D13b-Abd-2
9862: PPUSH
9863: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
9867: LD_EXP 14
9871: PPUSH
9872: LD_STRING D13b-JMM-3
9874: PPUSH
9875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
9879: LD_EXP 54
9883: PPUSH
9884: LD_STRING D13b-Abd-3
9886: PPUSH
9887: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
9891: LD_EXP 14
9895: PPUSH
9896: LD_STRING D13b-JMM-4
9898: PPUSH
9899: CALL_OW 88
// ar_active_attack := true ;
9903: LD_ADDR_EXP 9
9907: PUSH
9908: LD_INT 1
9910: ST_TO_ADDR
// end ; if selected_option = 3 then
9911: LD_VAR 0 2
9915: PUSH
9916: LD_INT 3
9918: EQUAL
9919: IFFALSE 9945
// begin Say ( JMM , D13c-JMM-1 ) ;
9921: LD_EXP 14
9925: PPUSH
9926: LD_STRING D13c-JMM-1
9928: PPUSH
9929: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
9933: LD_EXP 45
9937: PPUSH
9938: LD_STRING D13c-Bur-1
9940: PPUSH
9941: CALL_OW 88
// end ; DialogueOff ;
9945: CALL_OW 7
// if not ar_active_attack then
9949: LD_EXP 9
9953: NOT
9954: IFFALSE 9971
// begin wait ( 6 6$00 ) ;
9956: LD_INT 12600
9958: PPUSH
9959: CALL_OW 67
// ar_active_attack := true ;
9963: LD_ADDR_EXP 9
9967: PUSH
9968: LD_INT 1
9970: ST_TO_ADDR
// end ; end ;
9971: PPOPN 2
9973: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do
9974: LD_EXP 45
9978: PPUSH
9979: CALL_OW 305
9983: PUSH
9984: LD_EXP 45
9988: PPUSH
9989: CALL_OW 255
9993: PUSH
9994: LD_INT 7
9996: EQUAL
9997: AND
9998: IFFALSE 10159
10000: GO 10002
10002: DISABLE
// begin wait ( 4 4$40 ) ;
10003: LD_INT 9800
10005: PPUSH
10006: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10010: LD_INT 35
10012: PPUSH
10013: CALL_OW 67
// until not ru_attackers ;
10017: LD_EXP 51
10021: NOT
10022: IFFALSE 10010
// PrepareGnyevko ;
10024: CALL 1990 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10028: LD_EXP 47
10032: PPUSH
10033: LD_INT 124
10035: PPUSH
10036: LD_INT 118
10038: PPUSH
10039: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10043: LD_EXP 47
10047: PPUSH
10048: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10052: LD_INT 35
10054: PPUSH
10055: CALL_OW 67
// until IsAt ( Gnyevko , 124 , 118 ) ;
10059: LD_EXP 47
10063: PPUSH
10064: LD_INT 124
10066: PPUSH
10067: LD_INT 118
10069: PPUSH
10070: CALL_OW 307
10074: IFFALSE 10052
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10076: LD_EXP 47
10080: PPUSH
10081: LD_STRING DBelkov-Gny-1
10083: PPUSH
10084: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10088: LD_EXP 45
10092: PPUSH
10093: LD_STRING DBelkov-Bur-1a
10095: PPUSH
10096: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10100: LD_INT 35
10102: PPUSH
10103: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10107: LD_EXP 47
10111: PPUSH
10112: LD_INT 22
10114: PUSH
10115: LD_INT 7
10117: PUSH
10118: EMPTY
10119: LIST
10120: LIST
10121: PPUSH
10122: CALL_OW 69
10126: PPUSH
10127: LD_EXP 47
10131: PPUSH
10132: CALL_OW 74
10136: PPUSH
10137: CALL_OW 296
10141: PUSH
10142: LD_INT 8
10144: LESS
10145: IFFALSE 10100
// SetSide ( Gnyevko , 7 ) ;
10147: LD_EXP 47
10151: PPUSH
10152: LD_INT 7
10154: PPUSH
10155: CALL_OW 235
// end ;
10159: END
// every 10 10$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10160: LD_EXP 45
10164: PPUSH
10165: CALL_OW 255
10169: PUSH
10170: LD_INT 7
10172: EQUAL
10173: IFFALSE 10183
10175: GO 10177
10177: DISABLE
// begin enable ;
10178: ENABLE
// PrepareAmericanAttack ;
10179: CALL 6285 0 0
// end ;
10183: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10184: LD_INT 22
10186: PUSH
10187: LD_INT 1
10189: PUSH
10190: EMPTY
10191: LIST
10192: LIST
10193: PPUSH
10194: CALL_OW 69
10198: IFFALSE 10382
10200: GO 10202
10202: DISABLE
10203: LD_INT 0
10205: PPUSH
10206: PPUSH
// begin while true do
10207: LD_INT 1
10209: IFFALSE 10266
// begin wait ( 0 0$1 ) ;
10211: LD_INT 35
10213: PPUSH
10214: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10218: LD_ADDR_VAR 0 2
10222: PUSH
10223: LD_INT 22
10225: PUSH
10226: LD_INT 1
10228: PUSH
10229: EMPTY
10230: LIST
10231: LIST
10232: PPUSH
10233: CALL_OW 69
10237: PPUSH
10238: LD_EXP 14
10242: PPUSH
10243: CALL_OW 74
10247: ST_TO_ADDR
// if See ( 7 , tmp ) then
10248: LD_INT 7
10250: PPUSH
10251: LD_VAR 0 2
10255: PPUSH
10256: CALL_OW 292
10260: IFFALSE 10264
// break ;
10262: GO 10266
// end ;
10264: GO 10207
// DialogueOn ;
10266: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10270: LD_VAR 0 2
10274: PPUSH
10275: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10279: LD_VAR 0 2
10283: PPUSH
10284: CALL_OW 250
10288: PPUSH
10289: LD_VAR 0 2
10293: PPUSH
10294: CALL_OW 251
10298: PPUSH
10299: LD_INT 7
10301: PPUSH
10302: LD_INT 8
10304: PPUSH
10305: CALL_OW 330
// if Denis then
10309: LD_EXP 20
10313: IFFALSE 10327
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10315: LD_EXP 20
10319: PPUSH
10320: LD_STRING DAmerAttack-Pet-1
10322: PPUSH
10323: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10327: LD_EXP 14
10331: PPUSH
10332: LD_STRING DAmerAttack-JMM-1
10334: PPUSH
10335: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10339: LD_EXP 45
10343: PPUSH
10344: LD_STRING DStop-Bur-1
10346: PPUSH
10347: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10351: LD_VAR 0 2
10355: PPUSH
10356: CALL_OW 250
10360: PPUSH
10361: LD_VAR 0 2
10365: PPUSH
10366: CALL_OW 251
10370: PPUSH
10371: LD_INT 7
10373: PPUSH
10374: CALL_OW 331
// DialogueOff ;
10378: CALL_OW 7
// end ;
10382: PPOPN 2
10384: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10385: LD_INT 22
10387: PUSH
10388: LD_INT 3
10390: PUSH
10391: EMPTY
10392: LIST
10393: LIST
10394: PUSH
10395: LD_INT 21
10397: PUSH
10398: LD_INT 1
10400: PUSH
10401: EMPTY
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PPUSH
10409: CALL_OW 69
10413: PUSH
10414: LD_INT 0
10416: EQUAL
10417: IFFALSE 10459
10419: GO 10421
10421: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10422: LD_STRING M5a
10424: PPUSH
10425: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10429: LD_EXP 14
10433: PPUSH
10434: LD_STRING D8-JMM-1
10436: PPUSH
10437: CALL_OW 88
// if Gossudarov then
10441: LD_EXP 31
10445: IFFALSE 10459
// Say ( Gossudarov , D8-Gos-1 ) ;
10447: LD_EXP 31
10451: PPUSH
10452: LD_STRING D8-Gos-1
10454: PPUSH
10455: CALL_OW 88
// end ;
10459: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10460: LD_INT 22
10462: PUSH
10463: LD_INT 2
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: LD_INT 21
10472: PUSH
10473: LD_INT 1
10475: PUSH
10476: EMPTY
10477: LIST
10478: LIST
10479: PUSH
10480: EMPTY
10481: LIST
10482: LIST
10483: PPUSH
10484: CALL_OW 69
10488: PUSH
10489: LD_INT 0
10491: EQUAL
10492: IFFALSE 10542
10494: GO 10496
10496: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10497: LD_STRING M4c
10499: PPUSH
10500: CALL_OW 337
// if Roth then
10504: LD_EXP 15
10508: IFFALSE 10524
// Say ( Roth , DStop-Roth-1 ) else
10510: LD_EXP 15
10514: PPUSH
10515: LD_STRING DStop-Roth-1
10517: PPUSH
10518: CALL_OW 88
10522: GO 10542
// if Gossudarov then
10524: LD_EXP 31
10528: IFFALSE 10542
// Say ( Gossudarov , D8-Gos-1a ) ;
10530: LD_EXP 31
10534: PPUSH
10535: LD_STRING D8-Gos-1a
10537: PPUSH
10538: CALL_OW 88
// end ;
10542: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10543: LD_INT 7
10545: PPUSH
10546: LD_INT 1
10548: PPUSH
10549: LD_INT 1
10551: PPUSH
10552: CALL 13570 0 3
10556: PUSH
10557: LD_INT 0
10559: EQUAL
10560: PUSH
10561: LD_INT 7
10563: PPUSH
10564: LD_INT 3
10566: PPUSH
10567: LD_INT 1
10569: PPUSH
10570: CALL 13570 0 3
10574: PUSH
10575: LD_INT 0
10577: EQUAL
10578: AND
10579: IFFALSE 10591
10581: GO 10583
10583: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10584: LD_STRING M1a
10586: PPUSH
10587: CALL_OW 337
// end ;
10591: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 3 ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10592: LD_INT 22
10594: PUSH
10595: LD_INT 2
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: LD_INT 21
10604: PUSH
10605: LD_INT 1
10607: PUSH
10608: EMPTY
10609: LIST
10610: LIST
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 69
10620: PUSH
10621: LD_INT 0
10623: EQUAL
10624: PUSH
10625: LD_INT 22
10627: PUSH
10628: LD_INT 3
10630: PUSH
10631: EMPTY
10632: LIST
10633: LIST
10634: PPUSH
10635: CALL_OW 69
10639: PUSH
10640: LD_INT 0
10642: EQUAL
10643: AND
10644: PUSH
10645: LD_INT 22
10647: PUSH
10648: LD_INT 1
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 69
10659: PUSH
10660: LD_INT 0
10662: EQUAL
10663: AND
10664: PUSH
10665: LD_INT 7
10667: PPUSH
10668: LD_INT 1
10670: PPUSH
10671: LD_INT 1
10673: PPUSH
10674: CALL 13570 0 3
10678: PUSH
10679: LD_INT 0
10681: EQUAL
10682: AND
10683: PUSH
10684: LD_INT 7
10686: PPUSH
10687: LD_INT 3
10689: PPUSH
10690: LD_INT 1
10692: PPUSH
10693: CALL 13570 0 3
10697: PUSH
10698: LD_INT 0
10700: EQUAL
10701: AND
10702: IFFALSE 12043
10704: GO 10706
10706: DISABLE
10707: LD_INT 0
10709: PPUSH
10710: PPUSH
10711: PPUSH
// begin wait ( 0 0$3 ) ;
10712: LD_INT 105
10714: PPUSH
10715: CALL_OW 67
// if not IsDead ( Masha ) then
10719: LD_EXP 48
10723: PPUSH
10724: CALL_OW 301
10728: NOT
10729: IFFALSE 10743
// AddMedal ( Masha , 1 ) else
10731: LD_STRING Masha
10733: PPUSH
10734: LD_INT 1
10736: PPUSH
10737: CALL_OW 101
10741: GO 10754
// AddMedal ( Masha , - 1 ) ;
10743: LD_STRING Masha
10745: PPUSH
10746: LD_INT 1
10748: NEG
10749: PPUSH
10750: CALL_OW 101
// if abdul_escaped then
10754: LD_EXP 12
10758: IFFALSE 10773
// AddMedal ( Abdul , - 1 ) else
10760: LD_STRING Abdul
10762: PPUSH
10763: LD_INT 1
10765: NEG
10766: PPUSH
10767: CALL_OW 101
10771: GO 10783
// AddMedal ( Abdul , 1 ) ;
10773: LD_STRING Abdul
10775: PPUSH
10776: LD_INT 1
10778: PPUSH
10779: CALL_OW 101
// if loss_counter = 0 then
10783: LD_EXP 13
10787: PUSH
10788: LD_INT 0
10790: EQUAL
10791: IFFALSE 10805
// AddMedal ( People , 2 ) else
10793: LD_STRING People
10795: PPUSH
10796: LD_INT 2
10798: PPUSH
10799: CALL_OW 101
10803: GO 10855
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
10805: LD_EXP 13
10809: PUSH
10810: LD_INT 3
10812: PUSH
10813: LD_INT 2
10815: PUSH
10816: LD_INT 2
10818: PUSH
10819: EMPTY
10820: LIST
10821: LIST
10822: LIST
10823: PUSH
10824: LD_OWVAR 67
10828: ARRAY
10829: LESSEQUAL
10830: IFFALSE 10844
// AddMedal ( People , 1 ) else
10832: LD_STRING People
10834: PPUSH
10835: LD_INT 1
10837: PPUSH
10838: CALL_OW 101
10842: GO 10855
// AddMedal ( People , - 1 ) ;
10844: LD_STRING People
10846: PPUSH
10847: LD_INT 1
10849: NEG
10850: PPUSH
10851: CALL_OW 101
// GiveMedals ( MAIN ) ;
10855: LD_STRING MAIN
10857: PPUSH
10858: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
10862: LD_ADDR_VAR 0 2
10866: PUSH
10867: LD_INT 22
10869: PUSH
10870: LD_INT 7
10872: PUSH
10873: EMPTY
10874: LIST
10875: LIST
10876: PUSH
10877: LD_INT 2
10879: PUSH
10880: LD_INT 25
10882: PUSH
10883: LD_INT 1
10885: PUSH
10886: EMPTY
10887: LIST
10888: LIST
10889: PUSH
10890: LD_INT 25
10892: PUSH
10893: LD_INT 2
10895: PUSH
10896: EMPTY
10897: LIST
10898: LIST
10899: PUSH
10900: LD_INT 25
10902: PUSH
10903: LD_INT 3
10905: PUSH
10906: EMPTY
10907: LIST
10908: LIST
10909: PUSH
10910: LD_INT 25
10912: PUSH
10913: LD_INT 4
10915: PUSH
10916: EMPTY
10917: LIST
10918: LIST
10919: PUSH
10920: LD_INT 25
10922: PUSH
10923: LD_INT 5
10925: PUSH
10926: EMPTY
10927: LIST
10928: LIST
10929: PUSH
10930: LD_INT 25
10932: PUSH
10933: LD_INT 8
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: PUSH
10940: LD_INT 25
10942: PUSH
10943: LD_INT 9
10945: PUSH
10946: EMPTY
10947: LIST
10948: LIST
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: LIST
10954: LIST
10955: LIST
10956: LIST
10957: LIST
10958: LIST
10959: PUSH
10960: EMPTY
10961: LIST
10962: LIST
10963: PPUSH
10964: CALL_OW 69
10968: ST_TO_ADDR
// RewardPeople ( tmp ) ;
10969: LD_VAR 0 2
10973: PPUSH
10974: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
10978: LD_ADDR_VAR 0 3
10982: PUSH
10983: LD_EXP 14
10987: PUSH
10988: LD_EXP 15
10992: PUSH
10993: LD_EXP 16
10997: PUSH
10998: LD_EXP 17
11002: PUSH
11003: LD_EXP 18
11007: PUSH
11008: LD_EXP 19
11012: PUSH
11013: LD_EXP 20
11017: PUSH
11018: LD_EXP 21
11022: PUSH
11023: LD_EXP 22
11027: PUSH
11028: LD_EXP 23
11032: PUSH
11033: LD_EXP 24
11037: PUSH
11038: LD_EXP 25
11042: PUSH
11043: LD_EXP 26
11047: PUSH
11048: LD_EXP 27
11052: PUSH
11053: LD_EXP 28
11057: PUSH
11058: LD_EXP 29
11062: PUSH
11063: LD_EXP 30
11067: PUSH
11068: LD_EXP 31
11072: PUSH
11073: LD_EXP 32
11077: PUSH
11078: LD_EXP 33
11082: PUSH
11083: LD_EXP 35
11087: PUSH
11088: LD_EXP 36
11092: PUSH
11093: LD_EXP 37
11097: PUSH
11098: LD_EXP 38
11102: PUSH
11103: LD_EXP 39
11107: PUSH
11108: LD_EXP 40
11112: PUSH
11113: LD_EXP 41
11117: PUSH
11118: LD_EXP 42
11122: PUSH
11123: LD_EXP 43
11127: PUSH
11128: LD_EXP 44
11132: PUSH
11133: LD_EXP 45
11137: PUSH
11138: LD_EXP 46
11142: PUSH
11143: LD_EXP 47
11147: PUSH
11148: EMPTY
11149: LIST
11150: LIST
11151: LIST
11152: LIST
11153: LIST
11154: LIST
11155: LIST
11156: LIST
11157: LIST
11158: LIST
11159: LIST
11160: LIST
11161: LIST
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: LIST
11167: LIST
11168: LIST
11169: LIST
11170: LIST
11171: LIST
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: LIST
11177: LIST
11178: LIST
11179: LIST
11180: LIST
11181: LIST
11182: ST_TO_ADDR
// if tmp diff tmp2 then
11183: LD_VAR 0 2
11187: PUSH
11188: LD_VAR 0 3
11192: DIFF
11193: IFFALSE 11213
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11195: LD_VAR 0 2
11199: PUSH
11200: LD_VAR 0 3
11204: DIFF
11205: PPUSH
11206: LD_STRING 13a_others
11208: PPUSH
11209: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11213: LD_EXP 14
11217: PPUSH
11218: LD_STRING 13a_JMM
11220: PPUSH
11221: CALL_OW 38
// if Titov then
11225: LD_EXP 33
11229: IFFALSE 11243
// SaveCharacters ( Titov , 13a_Titov ) ;
11231: LD_EXP 33
11235: PPUSH
11236: LD_STRING 13a_Titov
11238: PPUSH
11239: CALL_OW 38
// if Dolgov then
11243: LD_EXP 35
11247: IFFALSE 11261
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11249: LD_EXP 35
11253: PPUSH
11254: LD_STRING 13a_Dolgov
11256: PPUSH
11257: CALL_OW 38
// if Petrosyan then
11261: LD_EXP 36
11265: IFFALSE 11279
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11267: LD_EXP 36
11271: PPUSH
11272: LD_STRING 13a_Petrosyan
11274: PPUSH
11275: CALL_OW 38
// if Scholtze then
11279: LD_EXP 37
11283: IFFALSE 11297
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11285: LD_EXP 37
11289: PPUSH
11290: LD_STRING 13a_Scholtze
11292: PPUSH
11293: CALL_OW 38
// if Oblukov then
11297: LD_EXP 38
11301: IFFALSE 11315
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11303: LD_EXP 38
11307: PPUSH
11308: LD_STRING 13a_Oblukov
11310: PPUSH
11311: CALL_OW 38
// if Kapitsova then
11315: LD_EXP 39
11319: IFFALSE 11333
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11321: LD_EXP 39
11325: PPUSH
11326: LD_STRING 13a_Kapitsova
11328: PPUSH
11329: CALL_OW 38
// if Lipshchin then
11333: LD_EXP 40
11337: IFFALSE 11351
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11339: LD_EXP 40
11343: PPUSH
11344: LD_STRING 13a_Lipshchin
11346: PPUSH
11347: CALL_OW 38
// if Petrovova then
11351: LD_EXP 41
11355: IFFALSE 11369
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11357: LD_EXP 41
11361: PPUSH
11362: LD_STRING 13a_Petrovova
11364: PPUSH
11365: CALL_OW 38
// if Kovalyuk then
11369: LD_EXP 42
11373: IFFALSE 11387
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11375: LD_EXP 42
11379: PPUSH
11380: LD_STRING 13a_Kovalyuk
11382: PPUSH
11383: CALL_OW 38
// if Kuzmov then
11387: LD_EXP 43
11391: IFFALSE 11405
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11393: LD_EXP 43
11397: PPUSH
11398: LD_STRING 13a_Kuzmov
11400: PPUSH
11401: CALL_OW 38
// if Karamazov then
11405: LD_EXP 44
11409: IFFALSE 11423
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11411: LD_EXP 44
11415: PPUSH
11416: LD_STRING 13a_Karamazov
11418: PPUSH
11419: CALL_OW 38
// if Burlak then
11423: LD_EXP 45
11427: IFFALSE 11441
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11429: LD_EXP 45
11433: PPUSH
11434: LD_STRING 13a_Burlak
11436: PPUSH
11437: CALL_OW 38
// if Belkov then
11441: LD_EXP 46
11445: IFFALSE 11459
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11447: LD_EXP 46
11451: PPUSH
11452: LD_STRING 13a_Belkov
11454: PPUSH
11455: CALL_OW 38
// if Gnyevko then
11459: LD_EXP 47
11463: IFFALSE 11477
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11465: LD_EXP 47
11469: PPUSH
11470: LD_STRING 13a_Gnyevko
11472: PPUSH
11473: CALL_OW 38
// if Lisa then
11477: LD_EXP 16
11481: IFFALSE 11495
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11483: LD_EXP 16
11487: PPUSH
11488: LD_STRING 13a_Lisa
11490: PPUSH
11491: CALL_OW 38
// if Donaldson then
11495: LD_EXP 17
11499: IFFALSE 11513
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11501: LD_EXP 17
11505: PPUSH
11506: LD_STRING 13a_Donaldson
11508: PPUSH
11509: CALL_OW 38
// if Bobby then
11513: LD_EXP 18
11517: IFFALSE 11531
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11519: LD_EXP 18
11523: PPUSH
11524: LD_STRING 13a_Bobby
11526: PPUSH
11527: CALL_OW 38
// if Cyrus then
11531: LD_EXP 19
11535: IFFALSE 11549
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11537: LD_EXP 19
11541: PPUSH
11542: LD_STRING 13a_Cyrus
11544: PPUSH
11545: CALL_OW 38
// if Denis then
11549: LD_EXP 20
11553: IFFALSE 11567
// SaveCharacters ( Denis , 13a_Denis ) ;
11555: LD_EXP 20
11559: PPUSH
11560: LD_STRING 13a_Denis
11562: PPUSH
11563: CALL_OW 38
// if Brown then
11567: LD_EXP 21
11571: IFFALSE 11585
// SaveCharacters ( Brown , 13a_Brown ) ;
11573: LD_EXP 21
11577: PPUSH
11578: LD_STRING 13a_Brown
11580: PPUSH
11581: CALL_OW 38
// if Gladstone then
11585: LD_EXP 22
11589: IFFALSE 11603
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11591: LD_EXP 22
11595: PPUSH
11596: LD_STRING 13a_Gladstone
11598: PPUSH
11599: CALL_OW 38
// if Houten then
11603: LD_EXP 23
11607: IFFALSE 11621
// SaveCharacters ( Houten , 13a_Houten ) ;
11609: LD_EXP 23
11613: PPUSH
11614: LD_STRING 13a_Houten
11616: PPUSH
11617: CALL_OW 38
// if Cornel then
11621: LD_EXP 24
11625: IFFALSE 11639
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11627: LD_EXP 24
11631: PPUSH
11632: LD_STRING 13a_Cornel
11634: PPUSH
11635: CALL_OW 38
// if Gary then
11639: LD_EXP 25
11643: IFFALSE 11657
// SaveCharacters ( Gary , 13a_Gary ) ;
11645: LD_EXP 25
11649: PPUSH
11650: LD_STRING 13a_Gary
11652: PPUSH
11653: CALL_OW 38
// if Frank then
11657: LD_EXP 26
11661: IFFALSE 11675
// SaveCharacters ( Frank , 13a_Frank ) ;
11663: LD_EXP 26
11667: PPUSH
11668: LD_STRING 13a_Frank
11670: PPUSH
11671: CALL_OW 38
// if Kikuchi then
11675: LD_EXP 27
11679: IFFALSE 11693
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
11681: LD_EXP 27
11685: PPUSH
11686: LD_STRING 13a_Kikuchi
11688: PPUSH
11689: CALL_OW 38
// if Simms then
11693: LD_EXP 28
11697: IFFALSE 11711
// SaveCharacters ( Simms , 13a_Simms ) ;
11699: LD_EXP 28
11703: PPUSH
11704: LD_STRING 13a_Simms
11706: PPUSH
11707: CALL_OW 38
// if Joan then
11711: LD_EXP 29
11715: IFFALSE 11729
// SaveCharacters ( Joan , 13a_Joan ) ;
11717: LD_EXP 29
11721: PPUSH
11722: LD_STRING 13a_Joan
11724: PPUSH
11725: CALL_OW 38
// if DeltaDoctor then
11729: LD_EXP 30
11733: IFFALSE 11747
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
11735: LD_EXP 30
11739: PPUSH
11740: LD_STRING 13a_DeltaDoctor
11742: PPUSH
11743: CALL_OW 38
// if Gossudarov then
11747: LD_EXP 31
11751: IFFALSE 11765
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
11753: LD_EXP 31
11757: PPUSH
11758: LD_STRING 13a_Gossudarov
11760: PPUSH
11761: CALL_OW 38
// if Kirilenkova then
11765: LD_EXP 32
11769: IFFALSE 11783
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
11771: LD_EXP 32
11775: PPUSH
11776: LD_STRING 13a_Kirilenkova
11778: PPUSH
11779: CALL_OW 38
// if Masha then
11783: LD_EXP 48
11787: IFFALSE 11842
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
11789: LD_EXP 48
11793: PPUSH
11794: CALL_OW 265
11798: PUSH
11799: LD_EXP 48
11803: PPUSH
11804: CALL_OW 262
11808: PUSH
11809: LD_EXP 48
11813: PPUSH
11814: CALL_OW 263
11818: PUSH
11819: LD_EXP 48
11823: PPUSH
11824: CALL_OW 264
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: PPUSH
11835: LD_STRING 13a_Masha
11837: PPUSH
11838: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
11842: LD_ADDR_VAR 0 2
11846: PUSH
11847: LD_INT 21
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PPUSH
11857: CALL_OW 69
11861: ST_TO_ADDR
// tmp2 := [ ] ;
11862: LD_ADDR_VAR 0 3
11866: PUSH
11867: EMPTY
11868: ST_TO_ADDR
// if tmp then
11869: LD_VAR 0 2
11873: IFFALSE 12021
// for i in tmp do
11875: LD_ADDR_VAR 0 1
11879: PUSH
11880: LD_VAR 0 2
11884: PUSH
11885: FOR_IN
11886: IFFALSE 12019
// tmp2 := tmp2 ^ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: LD_VAR 0 1
11902: PPUSH
11903: CALL_OW 255
11907: PUSH
11908: LD_VAR 0 1
11912: PPUSH
11913: CALL_OW 248
11917: PUSH
11918: LD_VAR 0 1
11922: PPUSH
11923: CALL_OW 266
11927: PUSH
11928: LD_VAR 0 1
11932: PPUSH
11933: CALL_OW 250
11937: PUSH
11938: LD_VAR 0 1
11942: PPUSH
11943: CALL_OW 251
11947: PUSH
11948: LD_VAR 0 1
11952: PPUSH
11953: CALL_OW 254
11957: PUSH
11958: LD_VAR 0 1
11962: PPUSH
11963: CALL_OW 267
11967: PUSH
11968: LD_VAR 0 1
11972: PPUSH
11973: LD_INT 1
11975: PPUSH
11976: CALL_OW 268
11980: PUSH
11981: LD_VAR 0 1
11985: PPUSH
11986: LD_INT 2
11988: PPUSH
11989: CALL_OW 268
11993: PUSH
11994: LD_VAR 0 1
11998: PPUSH
11999: CALL_OW 269
12003: PUSH
12004: EMPTY
12005: LIST
12006: LIST
12007: LIST
12008: LIST
12009: LIST
12010: LIST
12011: LIST
12012: LIST
12013: LIST
12014: LIST
12015: ADD
12016: ST_TO_ADDR
12017: GO 11885
12019: POP
12020: POP
// if tmp2 then
12021: LD_VAR 0 3
12025: IFFALSE 12039
// SaveVariable ( tmp2 , 13a_buildings ) ;
12027: LD_VAR 0 3
12031: PPUSH
12032: LD_STRING 13a_buildings
12034: PPUSH
12035: CALL_OW 39
// YouWin ;
12039: CALL_OW 103
// end ;
12043: PPOPN 3
12045: END
// export function SciRu ; var tmp , t ; begin
12046: LD_INT 0
12048: PPUSH
12049: PPUSH
12050: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko ] ;
12051: LD_ADDR_VAR 0 3
12055: PUSH
12056: LD_EXP 31
12060: PUSH
12061: LD_EXP 45
12065: PUSH
12066: LD_EXP 33
12070: PUSH
12071: LD_EXP 46
12075: PUSH
12076: LD_EXP 47
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12088: LD_ADDR_VAR 0 2
12092: PUSH
12093: LD_INT 22
12095: PUSH
12096: LD_INT 7
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PUSH
12103: LD_INT 23
12105: PUSH
12106: LD_INT 3
12108: PUSH
12109: EMPTY
12110: LIST
12111: LIST
12112: PUSH
12113: LD_INT 25
12115: PUSH
12116: LD_INT 4
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: PUSH
12123: LD_INT 26
12125: PUSH
12126: LD_INT 1
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: EMPTY
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: PPUSH
12139: CALL_OW 69
12143: PUSH
12144: LD_VAR 0 3
12148: DIFF
12149: ST_TO_ADDR
// if tmp then
12150: LD_VAR 0 2
12154: IFFALSE 12170
// result := tmp [ 1 ] ;
12156: LD_ADDR_VAR 0 1
12160: PUSH
12161: LD_VAR 0 2
12165: PUSH
12166: LD_INT 1
12168: ARRAY
12169: ST_TO_ADDR
// end ;
12170: LD_VAR 0 1
12174: RET
// export function SolRu ; var tmp , t ; begin
12175: LD_INT 0
12177: PPUSH
12178: PPUSH
12179: PPUSH
// t := [ Belkov , Burlak , Gossudarov ] ;
12180: LD_ADDR_VAR 0 3
12184: PUSH
12185: LD_EXP 46
12189: PUSH
12190: LD_EXP 45
12194: PUSH
12195: LD_EXP 31
12199: PUSH
12200: EMPTY
12201: LIST
12202: LIST
12203: LIST
12204: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12205: LD_ADDR_VAR 0 2
12209: PUSH
12210: LD_INT 22
12212: PUSH
12213: LD_INT 7
12215: PUSH
12216: EMPTY
12217: LIST
12218: LIST
12219: PUSH
12220: LD_INT 23
12222: PUSH
12223: LD_INT 3
12225: PUSH
12226: EMPTY
12227: LIST
12228: LIST
12229: PUSH
12230: LD_INT 25
12232: PUSH
12233: LD_INT 1
12235: PUSH
12236: EMPTY
12237: LIST
12238: LIST
12239: PUSH
12240: LD_INT 26
12242: PUSH
12243: LD_INT 1
12245: PUSH
12246: EMPTY
12247: LIST
12248: LIST
12249: PUSH
12250: EMPTY
12251: LIST
12252: LIST
12253: LIST
12254: LIST
12255: PPUSH
12256: CALL_OW 69
12260: PUSH
12261: LD_VAR 0 3
12265: DIFF
12266: ST_TO_ADDR
// if tmp then
12267: LD_VAR 0 2
12271: IFFALSE 12287
// result := tmp [ 1 ] ;
12273: LD_ADDR_VAR 0 1
12277: PUSH
12278: LD_VAR 0 2
12282: PUSH
12283: LD_INT 1
12285: ARRAY
12286: ST_TO_ADDR
// end ; end_of_file
12287: LD_VAR 0 1
12291: RET
// on UnitDestroyed ( un ) do var i , side ;
12292: LD_INT 0
12294: PPUSH
12295: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12296: LD_VAR 0 1
12300: PUSH
12301: LD_INT 22
12303: PUSH
12304: LD_INT 7
12306: PUSH
12307: EMPTY
12308: LIST
12309: LIST
12310: PUSH
12311: LD_INT 2
12313: PUSH
12314: LD_INT 25
12316: PUSH
12317: LD_INT 1
12319: PUSH
12320: EMPTY
12321: LIST
12322: LIST
12323: PUSH
12324: LD_INT 25
12326: PUSH
12327: LD_INT 2
12329: PUSH
12330: EMPTY
12331: LIST
12332: LIST
12333: PUSH
12334: LD_INT 25
12336: PUSH
12337: LD_INT 3
12339: PUSH
12340: EMPTY
12341: LIST
12342: LIST
12343: PUSH
12344: LD_INT 25
12346: PUSH
12347: LD_INT 4
12349: PUSH
12350: EMPTY
12351: LIST
12352: LIST
12353: PUSH
12354: LD_INT 25
12356: PUSH
12357: LD_INT 5
12359: PUSH
12360: EMPTY
12361: LIST
12362: LIST
12363: PUSH
12364: LD_INT 25
12366: PUSH
12367: LD_INT 8
12369: PUSH
12370: EMPTY
12371: LIST
12372: LIST
12373: PUSH
12374: LD_INT 25
12376: PUSH
12377: LD_INT 9
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: PUSH
12384: EMPTY
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PPUSH
12398: CALL_OW 69
12402: IN
12403: IFFALSE 12419
// loss_counter := loss_counter + 1 ;
12405: LD_ADDR_EXP 13
12409: PUSH
12410: LD_EXP 13
12414: PUSH
12415: LD_INT 1
12417: PLUS
12418: ST_TO_ADDR
// if un = Abdul then
12419: LD_VAR 0 1
12423: PUSH
12424: LD_EXP 54
12428: EQUAL
12429: IFFALSE 12439
// abdul_escaped := false ;
12431: LD_ADDR_EXP 12
12435: PUSH
12436: LD_INT 0
12438: ST_TO_ADDR
// if un in ru_attackers then
12439: LD_VAR 0 1
12443: PUSH
12444: LD_EXP 51
12448: IN
12449: IFFALSE 12467
// ru_attackers := ru_attackers diff un ;
12451: LD_ADDR_EXP 51
12455: PUSH
12456: LD_EXP 51
12460: PUSH
12461: LD_VAR 0 1
12465: DIFF
12466: ST_TO_ADDR
// if un in ar_attackers then
12467: LD_VAR 0 1
12471: PUSH
12472: LD_EXP 10
12476: IN
12477: IFFALSE 12495
// ar_attackers := ar_attackers diff un ;
12479: LD_ADDR_EXP 10
12483: PUSH
12484: LD_EXP 10
12488: PUSH
12489: LD_VAR 0 1
12493: DIFF
12494: ST_TO_ADDR
// if un = JMM then
12495: LD_VAR 0 1
12499: PUSH
12500: LD_EXP 14
12504: EQUAL
12505: IFFALSE 12516
// begin YouLost ( JMM ) ;
12507: LD_STRING JMM
12509: PPUSH
12510: CALL_OW 104
// exit ;
12514: GO 12605
// end ; if un = Burlak then
12516: LD_VAR 0 1
12520: PUSH
12521: LD_EXP 45
12525: EQUAL
12526: IFFALSE 12537
// begin YouLost ( Burlak ) ;
12528: LD_STRING Burlak
12530: PPUSH
12531: CALL_OW 104
// exit ;
12535: GO 12605
// end ; if un = freedom then
12537: LD_VAR 0 1
12541: PUSH
12542: LD_EXP 3
12546: EQUAL
12547: IFFALSE 12558
// begin YouLost ( Destroyed ) ;
12549: LD_STRING Destroyed
12551: PPUSH
12552: CALL_OW 104
// exit ;
12556: GO 12605
// end ; if un = Masha then
12558: LD_VAR 0 1
12562: PUSH
12563: LD_EXP 48
12567: EQUAL
12568: IFFALSE 12577
// ChangeMissionObjectives ( M4b ) ;
12570: LD_STRING M4b
12572: PPUSH
12573: CALL_OW 337
// if un = Mastodont then
12577: LD_VAR 0 1
12581: PUSH
12582: LD_EXP 55
12586: EQUAL
12587: IFFALSE 12596
// ChangeMissionObjectives ( M4a ) ;
12589: LD_STRING M4a
12591: PPUSH
12592: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
12596: LD_VAR 0 1
12600: PPUSH
12601: CALL 80604 0 1
// end ;
12605: PPOPN 3
12607: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
12608: LD_VAR 0 1
12612: PPUSH
12613: LD_VAR 0 2
12617: PPUSH
12618: CALL 82489 0 2
// end ;
12622: PPOPN 2
12624: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
12625: LD_VAR 0 1
12629: PPUSH
12630: CALL 81571 0 1
// end ;
12634: PPOPN 1
12636: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
12637: LD_VAR 0 1
12641: PUSH
12642: LD_INT 22
12644: PUSH
12645: LD_INT 7
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: LD_INT 30
12654: PUSH
12655: LD_INT 0
12657: PUSH
12658: EMPTY
12659: LIST
12660: LIST
12661: PUSH
12662: EMPTY
12663: LIST
12664: LIST
12665: PPUSH
12666: CALL_OW 69
12670: IN
12671: IFFALSE 12710
// begin SetBName ( building , freedom ) ;
12673: LD_VAR 0 1
12677: PPUSH
12678: LD_STRING freedom
12680: PPUSH
12681: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
12685: LD_INT 0
12687: PPUSH
12688: LD_INT 7
12690: PPUSH
12691: LD_INT 0
12693: PPUSH
12694: CALL_OW 324
// freedom := building ;
12698: LD_ADDR_EXP 3
12702: PUSH
12703: LD_VAR 0 1
12707: ST_TO_ADDR
// exit ;
12708: GO 12776
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
12710: LD_VAR 0 1
12714: PUSH
12715: LD_INT 22
12717: PUSH
12718: LD_INT 7
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 23
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 30
12737: PUSH
12738: LD_INT 6
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: EMPTY
12746: LIST
12747: LIST
12748: LIST
12749: PPUSH
12750: CALL_OW 69
12754: IN
12755: IFFALSE 12767
// begin ru_lab_builded := true ;
12757: LD_ADDR_EXP 5
12761: PUSH
12762: LD_INT 1
12764: ST_TO_ADDR
// exit ;
12765: GO 12776
// end ; MCE_BuildingComplete ( building ) ;
12767: LD_VAR 0 1
12771: PPUSH
12772: CALL 81805 0 1
// end ;
12776: PPOPN 1
12778: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
12779: LD_VAR 0 1
12783: PPUSH
12784: LD_VAR 0 2
12788: PPUSH
12789: CALL 80316 0 2
// end ;
12793: PPOPN 2
12795: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
12796: LD_VAR 0 1
12800: PPUSH
12801: LD_VAR 0 2
12805: PPUSH
12806: LD_VAR 0 3
12810: PPUSH
12811: LD_VAR 0 4
12815: PPUSH
12816: LD_VAR 0 5
12820: PPUSH
12821: CALL 79943 0 5
// end ;
12825: PPOPN 5
12827: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
12828: LD_VAR 0 1
12832: PPUSH
12833: LD_VAR 0 2
12837: PPUSH
12838: CALL 79540 0 2
// end ;
12842: PPOPN 2
12844: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
12845: LD_VAR 0 1
12849: PPUSH
12850: LD_VAR 0 2
12854: PPUSH
12855: LD_VAR 0 3
12859: PPUSH
12860: LD_VAR 0 4
12864: PPUSH
12865: CALL 79385 0 4
// end ;
12869: PPOPN 4
12871: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
12872: LD_VAR 0 1
12876: PPUSH
12877: LD_VAR 0 2
12881: PPUSH
12882: LD_VAR 0 3
12886: PPUSH
12887: CALL 79167 0 3
// end ;
12891: PPOPN 3
12893: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
12894: LD_VAR 0 1
12898: PPUSH
12899: LD_VAR 0 2
12903: PPUSH
12904: CALL 79059 0 2
// end ;
12908: PPOPN 2
12910: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
12911: LD_VAR 0 1
12915: PPUSH
12916: LD_VAR 0 2
12920: PPUSH
12921: CALL 82743 0 2
// end ;
12925: PPOPN 2
12927: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
12928: LD_VAR 0 1
12932: PPUSH
12933: LD_VAR 0 2
12937: PPUSH
12938: LD_VAR 0 3
12942: PPUSH
12943: LD_VAR 0 4
12947: PPUSH
12948: CALL 82952 0 4
// end ;
12952: PPOPN 4
12954: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
12955: LD_VAR 0 1
12959: PPUSH
12960: LD_VAR 0 2
12964: PPUSH
12965: CALL 78875 0 2
// end ; end_of_file
12969: PPOPN 2
12971: END
// every 0 0$30 do var cr , time ;
12972: GO 12974
12974: DISABLE
12975: LD_INT 0
12977: PPUSH
12978: PPUSH
// begin time := 0 0$10 ;
12979: LD_ADDR_VAR 0 2
12983: PUSH
12984: LD_INT 350
12986: ST_TO_ADDR
// while game do
12987: LD_EXP 2
12991: IFFALSE 13090
// begin wait ( time ) ;
12993: LD_VAR 0 2
12997: PPUSH
12998: CALL_OW 67
// if tick > 2 2$00 then
13002: LD_OWVAR 1
13006: PUSH
13007: LD_INT 4200
13009: GREATER
13010: IFFALSE 13043
// time := time + [ 0 0$06 , 0 0$07 , 0 0$08 ] [ Difficulty ] ;
13012: LD_ADDR_VAR 0 2
13016: PUSH
13017: LD_VAR 0 2
13021: PUSH
13022: LD_INT 210
13024: PUSH
13025: LD_INT 245
13027: PUSH
13028: LD_INT 280
13030: PUSH
13031: EMPTY
13032: LIST
13033: LIST
13034: LIST
13035: PUSH
13036: LD_OWVAR 67
13040: ARRAY
13041: PLUS
13042: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13043: LD_INT 1
13045: PPUSH
13046: LD_INT 5
13048: PPUSH
13049: CALL_OW 12
13053: PPUSH
13054: LD_INT 70
13056: PPUSH
13057: LD_INT 49
13059: PPUSH
13060: LD_INT 25
13062: PPUSH
13063: LD_INT 1
13065: PPUSH
13066: CALL_OW 56
// if time > 5 5$00 then
13070: LD_VAR 0 2
13074: PUSH
13075: LD_INT 10500
13077: GREATER
13078: IFFALSE 13088
// time := 0 0$30 ;
13080: LD_ADDR_VAR 0 2
13084: PUSH
13085: LD_INT 1050
13087: ST_TO_ADDR
// end ;
13088: GO 12987
// end ;
13090: PPOPN 2
13092: END
// every 0 0$30 do var cr , time ;
13093: GO 13095
13095: DISABLE
13096: LD_INT 0
13098: PPUSH
13099: PPUSH
// begin time := 0 0$01 ;
13100: LD_ADDR_VAR 0 2
13104: PUSH
13105: LD_INT 35
13107: ST_TO_ADDR
// while game do
13108: LD_EXP 2
13112: IFFALSE 13201
// begin wait ( time ) ;
13114: LD_VAR 0 2
13118: PPUSH
13119: CALL_OW 67
// time := time + [ 0 0$04 , 0 0$05 , 0 0$06 ] [ Difficulty ] ;
13123: LD_ADDR_VAR 0 2
13127: PUSH
13128: LD_VAR 0 2
13132: PUSH
13133: LD_INT 140
13135: PUSH
13136: LD_INT 175
13138: PUSH
13139: LD_INT 210
13141: PUSH
13142: EMPTY
13143: LIST
13144: LIST
13145: LIST
13146: PUSH
13147: LD_OWVAR 67
13151: ARRAY
13152: PLUS
13153: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13154: LD_INT 3
13156: PPUSH
13157: LD_INT 5
13159: PPUSH
13160: CALL_OW 12
13164: PPUSH
13165: LD_INT 26
13167: PPUSH
13168: LD_INT 9
13170: PPUSH
13171: LD_INT 30
13173: PPUSH
13174: LD_INT 1
13176: PPUSH
13177: CALL_OW 56
// if time > 3 3$00 then
13181: LD_VAR 0 2
13185: PUSH
13186: LD_INT 6300
13188: GREATER
13189: IFFALSE 13199
// time := 0 0$20 ;
13191: LD_ADDR_VAR 0 2
13195: PUSH
13196: LD_INT 700
13198: ST_TO_ADDR
// end ;
13199: GO 13108
// end ;
13201: PPOPN 2
13203: END
// every 0 0$30 do var cr , time ;
13204: GO 13206
13206: DISABLE
13207: LD_INT 0
13209: PPUSH
13210: PPUSH
// begin time := 0 0$20 ;
13211: LD_ADDR_VAR 0 2
13215: PUSH
13216: LD_INT 700
13218: ST_TO_ADDR
// while game do
13219: LD_EXP 2
13223: IFFALSE 13348
// begin wait ( time ) ;
13225: LD_VAR 0 2
13229: PPUSH
13230: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13234: LD_ADDR_VAR 0 2
13238: PUSH
13239: LD_VAR 0 2
13243: PUSH
13244: LD_INT 175
13246: PUSH
13247: LD_INT 210
13249: PUSH
13250: LD_INT 280
13252: PUSH
13253: EMPTY
13254: LIST
13255: LIST
13256: LIST
13257: PUSH
13258: LD_OWVAR 67
13262: ARRAY
13263: PLUS
13264: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13265: LD_INT 1
13267: PPUSH
13268: LD_INT 5
13270: PPUSH
13271: CALL_OW 12
13275: PPUSH
13276: LD_INT 179
13278: PPUSH
13279: LD_INT 101
13281: PPUSH
13282: LD_INT 20
13284: PPUSH
13285: LD_INT 1
13287: PPUSH
13288: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13292: LD_INT 350
13294: PPUSH
13295: LD_INT 525
13297: PPUSH
13298: CALL_OW 12
13302: PPUSH
13303: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13307: LD_INT 1
13309: PPUSH
13310: LD_INT 5
13312: PPUSH
13313: CALL_OW 12
13317: PPUSH
13318: LD_INT 9
13320: PPUSH
13321: LD_INT 1
13323: PPUSH
13324: CALL_OW 55
// if time > 4 4$00 then
13328: LD_VAR 0 2
13332: PUSH
13333: LD_INT 8400
13335: GREATER
13336: IFFALSE 13346
// time := 0 0$30 ;
13338: LD_ADDR_VAR 0 2
13342: PUSH
13343: LD_INT 1050
13345: ST_TO_ADDR
// end ;
13346: GO 13219
// end ;
13348: PPOPN 2
13350: END
// every 0 0$30 do var cr , time ;
13351: GO 13353
13353: DISABLE
13354: LD_INT 0
13356: PPUSH
13357: PPUSH
// begin time := 0 0$10 ;
13358: LD_ADDR_VAR 0 2
13362: PUSH
13363: LD_INT 350
13365: ST_TO_ADDR
// while game do
13366: LD_EXP 2
13370: IFFALSE 13504
// begin wait ( time ) ;
13372: LD_VAR 0 2
13376: PPUSH
13377: CALL_OW 67
// time := time + 0 0$10 ;
13381: LD_ADDR_VAR 0 2
13385: PUSH
13386: LD_VAR 0 2
13390: PUSH
13391: LD_INT 350
13393: PLUS
13394: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13395: LD_INT 1
13397: PPUSH
13398: LD_INT 5
13400: PPUSH
13401: CALL_OW 12
13405: PPUSH
13406: LD_INT 11
13408: PPUSH
13409: LD_INT 1
13411: PPUSH
13412: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13416: LD_ADDR_VAR 0 1
13420: PUSH
13421: LD_INT 1
13423: PPUSH
13424: LD_INT 3
13426: PPUSH
13427: CALL_OW 12
13431: ST_TO_ADDR
// if cr = 1 then
13432: LD_VAR 0 1
13436: PUSH
13437: LD_INT 1
13439: EQUAL
13440: IFFALSE 13484
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13442: LD_INT 700
13444: PPUSH
13445: LD_INT 1575
13447: PPUSH
13448: CALL_OW 12
13452: PPUSH
13453: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13457: LD_INT 1
13459: PPUSH
13460: LD_INT 5
13462: PPUSH
13463: CALL_OW 12
13467: PPUSH
13468: LD_INT 34
13470: PPUSH
13471: LD_INT 50
13473: PPUSH
13474: LD_INT 7
13476: PPUSH
13477: LD_INT 1
13479: PPUSH
13480: CALL_OW 56
// end ; if time > 8 8$00 then
13484: LD_VAR 0 2
13488: PUSH
13489: LD_INT 16800
13491: GREATER
13492: IFFALSE 13502
// time := 0 0$40 ;
13494: LD_ADDR_VAR 0 2
13498: PUSH
13499: LD_INT 1400
13501: ST_TO_ADDR
// end ;
13502: GO 13366
// end ; end_of_file
13504: PPOPN 2
13506: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13507: LD_INT 0
13509: PPUSH
13510: PPUSH
// if exist_mode then
13511: LD_VAR 0 2
13515: IFFALSE 13540
// unit := CreateCharacter ( prefix & ident ) else
13517: LD_ADDR_VAR 0 5
13521: PUSH
13522: LD_VAR 0 3
13526: PUSH
13527: LD_VAR 0 1
13531: STR
13532: PPUSH
13533: CALL_OW 34
13537: ST_TO_ADDR
13538: GO 13555
// unit := NewCharacter ( ident ) ;
13540: LD_ADDR_VAR 0 5
13544: PUSH
13545: LD_VAR 0 1
13549: PPUSH
13550: CALL_OW 25
13554: ST_TO_ADDR
// result := unit ;
13555: LD_ADDR_VAR 0 4
13559: PUSH
13560: LD_VAR 0 5
13564: ST_TO_ADDR
// end ;
13565: LD_VAR 0 4
13569: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13570: LD_INT 0
13572: PPUSH
13573: PPUSH
// if not side or not nation then
13574: LD_VAR 0 1
13578: NOT
13579: PUSH
13580: LD_VAR 0 2
13584: NOT
13585: OR
13586: IFFALSE 13590
// exit ;
13588: GO 14226
// case nation of nation_american :
13590: LD_VAR 0 2
13594: PUSH
13595: LD_INT 1
13597: DOUBLE
13598: EQUAL
13599: IFTRUE 13603
13601: GO 13773
13603: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
13604: LD_ADDR_VAR 0 4
13608: PUSH
13609: LD_INT 35
13611: PUSH
13612: LD_INT 45
13614: PUSH
13615: LD_INT 46
13617: PUSH
13618: LD_INT 47
13620: PUSH
13621: LD_INT 1
13623: PUSH
13624: LD_INT 2
13626: PUSH
13627: LD_INT 6
13629: PUSH
13630: LD_INT 15
13632: PUSH
13633: LD_INT 16
13635: PUSH
13636: LD_INT 7
13638: PUSH
13639: LD_INT 12
13641: PUSH
13642: LD_INT 13
13644: PUSH
13645: LD_INT 10
13647: PUSH
13648: LD_INT 14
13650: PUSH
13651: LD_INT 20
13653: PUSH
13654: LD_INT 21
13656: PUSH
13657: LD_INT 22
13659: PUSH
13660: LD_INT 25
13662: PUSH
13663: LD_INT 32
13665: PUSH
13666: LD_INT 27
13668: PUSH
13669: LD_INT 36
13671: PUSH
13672: LD_INT 69
13674: PUSH
13675: LD_INT 39
13677: PUSH
13678: LD_INT 34
13680: PUSH
13681: LD_INT 40
13683: PUSH
13684: LD_INT 48
13686: PUSH
13687: LD_INT 49
13689: PUSH
13690: LD_INT 50
13692: PUSH
13693: LD_INT 51
13695: PUSH
13696: LD_INT 52
13698: PUSH
13699: LD_INT 53
13701: PUSH
13702: LD_INT 54
13704: PUSH
13705: LD_INT 55
13707: PUSH
13708: LD_INT 56
13710: PUSH
13711: LD_INT 57
13713: PUSH
13714: LD_INT 58
13716: PUSH
13717: LD_INT 59
13719: PUSH
13720: LD_INT 60
13722: PUSH
13723: LD_INT 61
13725: PUSH
13726: LD_INT 62
13728: PUSH
13729: EMPTY
13730: LIST
13731: LIST
13732: LIST
13733: LIST
13734: LIST
13735: LIST
13736: LIST
13737: LIST
13738: LIST
13739: LIST
13740: LIST
13741: LIST
13742: LIST
13743: LIST
13744: LIST
13745: LIST
13746: LIST
13747: LIST
13748: LIST
13749: LIST
13750: LIST
13751: LIST
13752: LIST
13753: LIST
13754: LIST
13755: LIST
13756: LIST
13757: LIST
13758: LIST
13759: LIST
13760: LIST
13761: LIST
13762: LIST
13763: LIST
13764: LIST
13765: LIST
13766: LIST
13767: LIST
13768: LIST
13769: LIST
13770: ST_TO_ADDR
13771: GO 14150
13773: LD_INT 2
13775: DOUBLE
13776: EQUAL
13777: IFTRUE 13781
13779: GO 13959
13781: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
13782: LD_ADDR_VAR 0 4
13786: PUSH
13787: LD_INT 35
13789: PUSH
13790: LD_INT 45
13792: PUSH
13793: LD_INT 46
13795: PUSH
13796: LD_INT 47
13798: PUSH
13799: LD_INT 70
13801: PUSH
13802: LD_INT 1
13804: PUSH
13805: LD_INT 11
13807: PUSH
13808: LD_INT 3
13810: PUSH
13811: LD_INT 4
13813: PUSH
13814: LD_INT 5
13816: PUSH
13817: LD_INT 6
13819: PUSH
13820: LD_INT 15
13822: PUSH
13823: LD_INT 18
13825: PUSH
13826: LD_INT 7
13828: PUSH
13829: LD_INT 17
13831: PUSH
13832: LD_INT 8
13834: PUSH
13835: LD_INT 20
13837: PUSH
13838: LD_INT 21
13840: PUSH
13841: LD_INT 22
13843: PUSH
13844: LD_INT 72
13846: PUSH
13847: LD_INT 26
13849: PUSH
13850: LD_INT 69
13852: PUSH
13853: LD_INT 39
13855: PUSH
13856: LD_INT 40
13858: PUSH
13859: LD_INT 41
13861: PUSH
13862: LD_INT 42
13864: PUSH
13865: LD_INT 43
13867: PUSH
13868: LD_INT 48
13870: PUSH
13871: LD_INT 49
13873: PUSH
13874: LD_INT 50
13876: PUSH
13877: LD_INT 51
13879: PUSH
13880: LD_INT 52
13882: PUSH
13883: LD_INT 53
13885: PUSH
13886: LD_INT 54
13888: PUSH
13889: LD_INT 55
13891: PUSH
13892: LD_INT 56
13894: PUSH
13895: LD_INT 60
13897: PUSH
13898: LD_INT 61
13900: PUSH
13901: LD_INT 62
13903: PUSH
13904: LD_INT 66
13906: PUSH
13907: LD_INT 67
13909: PUSH
13910: LD_INT 68
13912: PUSH
13913: EMPTY
13914: LIST
13915: LIST
13916: LIST
13917: LIST
13918: LIST
13919: LIST
13920: LIST
13921: LIST
13922: LIST
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: LIST
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: LIST
13946: LIST
13947: LIST
13948: LIST
13949: LIST
13950: LIST
13951: LIST
13952: LIST
13953: LIST
13954: LIST
13955: LIST
13956: ST_TO_ADDR
13957: GO 14150
13959: LD_INT 3
13961: DOUBLE
13962: EQUAL
13963: IFTRUE 13967
13965: GO 14149
13967: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
13968: LD_ADDR_VAR 0 4
13972: PUSH
13973: LD_INT 46
13975: PUSH
13976: LD_INT 47
13978: PUSH
13979: LD_INT 1
13981: PUSH
13982: LD_INT 2
13984: PUSH
13985: LD_INT 11
13987: PUSH
13988: LD_INT 9
13990: PUSH
13991: LD_INT 20
13993: PUSH
13994: LD_INT 19
13996: PUSH
13997: LD_INT 21
13999: PUSH
14000: LD_INT 24
14002: PUSH
14003: LD_INT 22
14005: PUSH
14006: LD_INT 25
14008: PUSH
14009: LD_INT 28
14011: PUSH
14012: LD_INT 29
14014: PUSH
14015: LD_INT 30
14017: PUSH
14018: LD_INT 31
14020: PUSH
14021: LD_INT 37
14023: PUSH
14024: LD_INT 38
14026: PUSH
14027: LD_INT 32
14029: PUSH
14030: LD_INT 27
14032: PUSH
14033: LD_INT 33
14035: PUSH
14036: LD_INT 69
14038: PUSH
14039: LD_INT 39
14041: PUSH
14042: LD_INT 34
14044: PUSH
14045: LD_INT 40
14047: PUSH
14048: LD_INT 71
14050: PUSH
14051: LD_INT 23
14053: PUSH
14054: LD_INT 44
14056: PUSH
14057: LD_INT 48
14059: PUSH
14060: LD_INT 49
14062: PUSH
14063: LD_INT 50
14065: PUSH
14066: LD_INT 51
14068: PUSH
14069: LD_INT 52
14071: PUSH
14072: LD_INT 53
14074: PUSH
14075: LD_INT 54
14077: PUSH
14078: LD_INT 55
14080: PUSH
14081: LD_INT 56
14083: PUSH
14084: LD_INT 57
14086: PUSH
14087: LD_INT 58
14089: PUSH
14090: LD_INT 59
14092: PUSH
14093: LD_INT 63
14095: PUSH
14096: LD_INT 64
14098: PUSH
14099: LD_INT 65
14101: PUSH
14102: EMPTY
14103: LIST
14104: LIST
14105: LIST
14106: LIST
14107: LIST
14108: LIST
14109: LIST
14110: LIST
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: LIST
14119: LIST
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: LIST
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: LIST
14131: LIST
14132: LIST
14133: LIST
14134: LIST
14135: LIST
14136: LIST
14137: LIST
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: ST_TO_ADDR
14147: GO 14150
14149: POP
// if state > - 1 and state < 3 then
14150: LD_VAR 0 3
14154: PUSH
14155: LD_INT 1
14157: NEG
14158: GREATER
14159: PUSH
14160: LD_VAR 0 3
14164: PUSH
14165: LD_INT 3
14167: LESS
14168: AND
14169: IFFALSE 14226
// for i in result do
14171: LD_ADDR_VAR 0 5
14175: PUSH
14176: LD_VAR 0 4
14180: PUSH
14181: FOR_IN
14182: IFFALSE 14224
// if GetTech ( i , side ) <> state then
14184: LD_VAR 0 5
14188: PPUSH
14189: LD_VAR 0 1
14193: PPUSH
14194: CALL_OW 321
14198: PUSH
14199: LD_VAR 0 3
14203: NONEQUAL
14204: IFFALSE 14222
// result := result diff i ;
14206: LD_ADDR_VAR 0 4
14210: PUSH
14211: LD_VAR 0 4
14215: PUSH
14216: LD_VAR 0 5
14220: DIFF
14221: ST_TO_ADDR
14222: GO 14181
14224: POP
14225: POP
// end ;
14226: LD_VAR 0 4
14230: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14231: LD_INT 0
14233: PPUSH
14234: PPUSH
14235: PPUSH
// result := true ;
14236: LD_ADDR_VAR 0 3
14240: PUSH
14241: LD_INT 1
14243: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14244: LD_ADDR_VAR 0 5
14248: PUSH
14249: LD_VAR 0 2
14253: PPUSH
14254: CALL_OW 480
14258: ST_TO_ADDR
// if not tmp then
14259: LD_VAR 0 5
14263: NOT
14264: IFFALSE 14268
// exit ;
14266: GO 14317
// for i in tmp do
14268: LD_ADDR_VAR 0 4
14272: PUSH
14273: LD_VAR 0 5
14277: PUSH
14278: FOR_IN
14279: IFFALSE 14315
// if GetTech ( i , side ) <> state_researched then
14281: LD_VAR 0 4
14285: PPUSH
14286: LD_VAR 0 1
14290: PPUSH
14291: CALL_OW 321
14295: PUSH
14296: LD_INT 2
14298: NONEQUAL
14299: IFFALSE 14313
// begin result := false ;
14301: LD_ADDR_VAR 0 3
14305: PUSH
14306: LD_INT 0
14308: ST_TO_ADDR
// exit ;
14309: POP
14310: POP
14311: GO 14317
// end ;
14313: GO 14278
14315: POP
14316: POP
// end ;
14317: LD_VAR 0 3
14321: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14322: LD_INT 0
14324: PPUSH
14325: PPUSH
14326: PPUSH
14327: PPUSH
14328: PPUSH
14329: PPUSH
14330: PPUSH
14331: PPUSH
14332: PPUSH
14333: PPUSH
14334: PPUSH
14335: PPUSH
14336: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14337: LD_VAR 0 1
14341: NOT
14342: PUSH
14343: LD_VAR 0 1
14347: PPUSH
14348: CALL_OW 257
14352: PUSH
14353: LD_INT 9
14355: NONEQUAL
14356: OR
14357: IFFALSE 14361
// exit ;
14359: GO 14934
// side := GetSide ( unit ) ;
14361: LD_ADDR_VAR 0 9
14365: PUSH
14366: LD_VAR 0 1
14370: PPUSH
14371: CALL_OW 255
14375: ST_TO_ADDR
// tech_space := tech_spacanom ;
14376: LD_ADDR_VAR 0 12
14380: PUSH
14381: LD_INT 29
14383: ST_TO_ADDR
// tech_time := tech_taurad ;
14384: LD_ADDR_VAR 0 13
14388: PUSH
14389: LD_INT 28
14391: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14392: LD_ADDR_VAR 0 11
14396: PUSH
14397: LD_VAR 0 1
14401: PPUSH
14402: CALL_OW 310
14406: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14407: LD_VAR 0 11
14411: PPUSH
14412: CALL_OW 247
14416: PUSH
14417: LD_INT 2
14419: EQUAL
14420: IFFALSE 14424
// exit ;
14422: GO 14934
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14424: LD_ADDR_VAR 0 8
14428: PUSH
14429: LD_INT 81
14431: PUSH
14432: LD_VAR 0 9
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: LD_INT 3
14443: PUSH
14444: LD_INT 21
14446: PUSH
14447: LD_INT 3
14449: PUSH
14450: EMPTY
14451: LIST
14452: LIST
14453: PUSH
14454: EMPTY
14455: LIST
14456: LIST
14457: PUSH
14458: EMPTY
14459: LIST
14460: LIST
14461: PPUSH
14462: CALL_OW 69
14466: ST_TO_ADDR
// if not tmp then
14467: LD_VAR 0 8
14471: NOT
14472: IFFALSE 14476
// exit ;
14474: GO 14934
// if in_unit then
14476: LD_VAR 0 11
14480: IFFALSE 14504
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14482: LD_ADDR_VAR 0 10
14486: PUSH
14487: LD_VAR 0 8
14491: PPUSH
14492: LD_VAR 0 11
14496: PPUSH
14497: CALL_OW 74
14501: ST_TO_ADDR
14502: GO 14524
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14504: LD_ADDR_VAR 0 10
14508: PUSH
14509: LD_VAR 0 8
14513: PPUSH
14514: LD_VAR 0 1
14518: PPUSH
14519: CALL_OW 74
14523: ST_TO_ADDR
// if not enemy then
14524: LD_VAR 0 10
14528: NOT
14529: IFFALSE 14533
// exit ;
14531: GO 14934
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14533: LD_VAR 0 11
14537: PUSH
14538: LD_VAR 0 11
14542: PPUSH
14543: LD_VAR 0 10
14547: PPUSH
14548: CALL_OW 296
14552: PUSH
14553: LD_INT 13
14555: GREATER
14556: AND
14557: PUSH
14558: LD_VAR 0 1
14562: PPUSH
14563: LD_VAR 0 10
14567: PPUSH
14568: CALL_OW 296
14572: PUSH
14573: LD_INT 12
14575: GREATER
14576: OR
14577: IFFALSE 14581
// exit ;
14579: GO 14934
// missile := [ 1 ] ;
14581: LD_ADDR_VAR 0 14
14585: PUSH
14586: LD_INT 1
14588: PUSH
14589: EMPTY
14590: LIST
14591: ST_TO_ADDR
// if Researched ( side , tech_space ) then
14592: LD_VAR 0 9
14596: PPUSH
14597: LD_VAR 0 12
14601: PPUSH
14602: CALL_OW 325
14606: IFFALSE 14635
// missile := Insert ( missile , missile + 1 , 2 ) ;
14608: LD_ADDR_VAR 0 14
14612: PUSH
14613: LD_VAR 0 14
14617: PPUSH
14618: LD_VAR 0 14
14622: PUSH
14623: LD_INT 1
14625: PLUS
14626: PPUSH
14627: LD_INT 2
14629: PPUSH
14630: CALL_OW 2
14634: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
14635: LD_VAR 0 9
14639: PPUSH
14640: LD_VAR 0 13
14644: PPUSH
14645: CALL_OW 325
14649: PUSH
14650: LD_VAR 0 10
14654: PPUSH
14655: CALL_OW 255
14659: PPUSH
14660: LD_VAR 0 13
14664: PPUSH
14665: CALL_OW 325
14669: NOT
14670: AND
14671: IFFALSE 14700
// missile := Insert ( missile , missile + 1 , 3 ) ;
14673: LD_ADDR_VAR 0 14
14677: PUSH
14678: LD_VAR 0 14
14682: PPUSH
14683: LD_VAR 0 14
14687: PUSH
14688: LD_INT 1
14690: PLUS
14691: PPUSH
14692: LD_INT 3
14694: PPUSH
14695: CALL_OW 2
14699: ST_TO_ADDR
// if missile < 2 then
14700: LD_VAR 0 14
14704: PUSH
14705: LD_INT 2
14707: LESS
14708: IFFALSE 14712
// exit ;
14710: GO 14934
// x := GetX ( enemy ) ;
14712: LD_ADDR_VAR 0 4
14716: PUSH
14717: LD_VAR 0 10
14721: PPUSH
14722: CALL_OW 250
14726: ST_TO_ADDR
// y := GetY ( enemy ) ;
14727: LD_ADDR_VAR 0 5
14731: PUSH
14732: LD_VAR 0 10
14736: PPUSH
14737: CALL_OW 251
14741: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
14742: LD_ADDR_VAR 0 6
14746: PUSH
14747: LD_VAR 0 4
14751: PUSH
14752: LD_INT 1
14754: NEG
14755: PPUSH
14756: LD_INT 1
14758: PPUSH
14759: CALL_OW 12
14763: PLUS
14764: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
14765: LD_ADDR_VAR 0 7
14769: PUSH
14770: LD_VAR 0 5
14774: PUSH
14775: LD_INT 1
14777: NEG
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 12
14786: PLUS
14787: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
14788: LD_VAR 0 6
14792: PPUSH
14793: LD_VAR 0 7
14797: PPUSH
14798: CALL_OW 488
14802: NOT
14803: IFFALSE 14825
// begin _x := x ;
14805: LD_ADDR_VAR 0 6
14809: PUSH
14810: LD_VAR 0 4
14814: ST_TO_ADDR
// _y := y ;
14815: LD_ADDR_VAR 0 7
14819: PUSH
14820: LD_VAR 0 5
14824: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
14825: LD_ADDR_VAR 0 3
14829: PUSH
14830: LD_INT 1
14832: PPUSH
14833: LD_VAR 0 14
14837: PPUSH
14838: CALL_OW 12
14842: ST_TO_ADDR
// case i of 1 :
14843: LD_VAR 0 3
14847: PUSH
14848: LD_INT 1
14850: DOUBLE
14851: EQUAL
14852: IFTRUE 14856
14854: GO 14873
14856: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
14857: LD_VAR 0 1
14861: PPUSH
14862: LD_VAR 0 10
14866: PPUSH
14867: CALL_OW 115
14871: GO 14934
14873: LD_INT 2
14875: DOUBLE
14876: EQUAL
14877: IFTRUE 14881
14879: GO 14903
14881: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
14882: LD_VAR 0 1
14886: PPUSH
14887: LD_VAR 0 6
14891: PPUSH
14892: LD_VAR 0 7
14896: PPUSH
14897: CALL_OW 153
14901: GO 14934
14903: LD_INT 3
14905: DOUBLE
14906: EQUAL
14907: IFTRUE 14911
14909: GO 14933
14911: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
14912: LD_VAR 0 1
14916: PPUSH
14917: LD_VAR 0 6
14921: PPUSH
14922: LD_VAR 0 7
14926: PPUSH
14927: CALL_OW 154
14931: GO 14934
14933: POP
// end ;
14934: LD_VAR 0 2
14938: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
14939: LD_INT 0
14941: PPUSH
14942: PPUSH
14943: PPUSH
14944: PPUSH
14945: PPUSH
14946: PPUSH
// if not unit or not building then
14947: LD_VAR 0 1
14951: NOT
14952: PUSH
14953: LD_VAR 0 2
14957: NOT
14958: OR
14959: IFFALSE 14963
// exit ;
14961: GO 15121
// x := GetX ( building ) ;
14963: LD_ADDR_VAR 0 5
14967: PUSH
14968: LD_VAR 0 2
14972: PPUSH
14973: CALL_OW 250
14977: ST_TO_ADDR
// y := GetY ( building ) ;
14978: LD_ADDR_VAR 0 6
14982: PUSH
14983: LD_VAR 0 2
14987: PPUSH
14988: CALL_OW 251
14992: ST_TO_ADDR
// for i = 0 to 5 do
14993: LD_ADDR_VAR 0 4
14997: PUSH
14998: DOUBLE
14999: LD_INT 0
15001: DEC
15002: ST_TO_ADDR
15003: LD_INT 5
15005: PUSH
15006: FOR_TO
15007: IFFALSE 15119
// begin _x := ShiftX ( x , i , 3 ) ;
15009: LD_ADDR_VAR 0 7
15013: PUSH
15014: LD_VAR 0 5
15018: PPUSH
15019: LD_VAR 0 4
15023: PPUSH
15024: LD_INT 3
15026: PPUSH
15027: CALL_OW 272
15031: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15032: LD_ADDR_VAR 0 8
15036: PUSH
15037: LD_VAR 0 6
15041: PPUSH
15042: LD_VAR 0 4
15046: PPUSH
15047: LD_INT 3
15049: PPUSH
15050: CALL_OW 273
15054: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15055: LD_VAR 0 7
15059: PPUSH
15060: LD_VAR 0 8
15064: PPUSH
15065: CALL_OW 488
15069: NOT
15070: IFFALSE 15074
// continue ;
15072: GO 15006
// if HexInfo ( _x , _y ) = 0 then
15074: LD_VAR 0 7
15078: PPUSH
15079: LD_VAR 0 8
15083: PPUSH
15084: CALL_OW 428
15088: PUSH
15089: LD_INT 0
15091: EQUAL
15092: IFFALSE 15117
// begin ComMoveXY ( unit , _x , _y ) ;
15094: LD_VAR 0 1
15098: PPUSH
15099: LD_VAR 0 7
15103: PPUSH
15104: LD_VAR 0 8
15108: PPUSH
15109: CALL_OW 111
// exit ;
15113: POP
15114: POP
15115: GO 15121
// end ; end ;
15117: GO 15006
15119: POP
15120: POP
// end ;
15121: LD_VAR 0 3
15125: RET
// export function ScanBase ( side , base_area ) ; begin
15126: LD_INT 0
15128: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15129: LD_ADDR_VAR 0 3
15133: PUSH
15134: LD_VAR 0 2
15138: PPUSH
15139: LD_INT 81
15141: PUSH
15142: LD_VAR 0 1
15146: PUSH
15147: EMPTY
15148: LIST
15149: LIST
15150: PPUSH
15151: CALL_OW 70
15155: ST_TO_ADDR
// end ;
15156: LD_VAR 0 3
15160: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15161: LD_INT 0
15163: PPUSH
15164: PPUSH
15165: PPUSH
15166: PPUSH
15167: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15168: LD_VAR 0 1
15172: NOT
15173: PUSH
15174: LD_EXP 58
15178: PUSH
15179: LD_VAR 0 1
15183: ARRAY
15184: NOT
15185: OR
15186: PUSH
15187: LD_VAR 0 2
15191: NOT
15192: OR
15193: PUSH
15194: LD_VAR 0 3
15198: NOT
15199: OR
15200: IFFALSE 15204
// exit ;
15202: GO 15654
// side := mc_sides [ base ] ;
15204: LD_ADDR_VAR 0 6
15208: PUSH
15209: LD_EXP 84
15213: PUSH
15214: LD_VAR 0 1
15218: ARRAY
15219: ST_TO_ADDR
// if not side then
15220: LD_VAR 0 6
15224: NOT
15225: IFFALSE 15229
// exit ;
15227: GO 15654
// for i in solds do
15229: LD_ADDR_VAR 0 7
15233: PUSH
15234: LD_VAR 0 2
15238: PUSH
15239: FOR_IN
15240: IFFALSE 15301
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15242: LD_VAR 0 7
15246: PPUSH
15247: CALL_OW 310
15251: PPUSH
15252: CALL_OW 266
15256: PUSH
15257: LD_INT 32
15259: PUSH
15260: LD_INT 31
15262: PUSH
15263: EMPTY
15264: LIST
15265: LIST
15266: IN
15267: IFFALSE 15287
// solds := solds diff i else
15269: LD_ADDR_VAR 0 2
15273: PUSH
15274: LD_VAR 0 2
15278: PUSH
15279: LD_VAR 0 7
15283: DIFF
15284: ST_TO_ADDR
15285: GO 15299
// SetTag ( i , 18 ) ;
15287: LD_VAR 0 7
15291: PPUSH
15292: LD_INT 18
15294: PPUSH
15295: CALL_OW 109
15299: GO 15239
15301: POP
15302: POP
// if not solds then
15303: LD_VAR 0 2
15307: NOT
15308: IFFALSE 15312
// exit ;
15310: GO 15654
// repeat wait ( 0 0$1 ) ;
15312: LD_INT 35
15314: PPUSH
15315: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15319: LD_ADDR_VAR 0 5
15323: PUSH
15324: LD_VAR 0 6
15328: PPUSH
15329: LD_VAR 0 3
15333: PPUSH
15334: CALL 15126 0 2
15338: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15339: LD_VAR 0 5
15343: NOT
15344: PUSH
15345: LD_VAR 0 5
15349: PUSH
15350: LD_INT 3
15352: GREATER
15353: OR
15354: PUSH
15355: LD_EXP 80
15359: PUSH
15360: LD_VAR 0 1
15364: ARRAY
15365: OR
15366: IFFALSE 15407
// begin for i in solds do
15368: LD_ADDR_VAR 0 7
15372: PUSH
15373: LD_VAR 0 2
15377: PUSH
15378: FOR_IN
15379: IFFALSE 15403
// if HasTask ( i ) then
15381: LD_VAR 0 7
15385: PPUSH
15386: CALL_OW 314
15390: IFFALSE 15401
// ComStop ( i ) ;
15392: LD_VAR 0 7
15396: PPUSH
15397: CALL_OW 141
15401: GO 15378
15403: POP
15404: POP
// break ;
15405: GO 15642
// end ; for i in solds do
15407: LD_ADDR_VAR 0 7
15411: PUSH
15412: LD_VAR 0 2
15416: PUSH
15417: FOR_IN
15418: IFFALSE 15634
// begin if IsInUnit ( i ) then
15420: LD_VAR 0 7
15424: PPUSH
15425: CALL_OW 310
15429: IFFALSE 15440
// ComExitBuilding ( i ) ;
15431: LD_VAR 0 7
15435: PPUSH
15436: CALL_OW 122
// if GetLives ( i ) > 333 then
15440: LD_VAR 0 7
15444: PPUSH
15445: CALL_OW 256
15449: PUSH
15450: LD_INT 333
15452: GREATER
15453: IFFALSE 15481
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15455: LD_VAR 0 7
15459: PPUSH
15460: LD_VAR 0 5
15464: PPUSH
15465: LD_VAR 0 7
15469: PPUSH
15470: CALL_OW 74
15474: PPUSH
15475: CALL_OW 115
15479: GO 15632
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15481: LD_ADDR_VAR 0 8
15485: PUSH
15486: LD_EXP 58
15490: PUSH
15491: LD_VAR 0 1
15495: ARRAY
15496: PPUSH
15497: LD_INT 2
15499: PUSH
15500: LD_INT 30
15502: PUSH
15503: LD_INT 0
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 30
15512: PUSH
15513: LD_INT 1
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 30
15522: PUSH
15523: LD_INT 6
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: CALL_OW 72
15540: PPUSH
15541: LD_VAR 0 7
15545: PPUSH
15546: CALL_OW 74
15550: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15551: LD_VAR 0 7
15555: PPUSH
15556: LD_VAR 0 8
15560: PPUSH
15561: CALL_OW 250
15565: PPUSH
15566: LD_INT 3
15568: PPUSH
15569: LD_INT 5
15571: PPUSH
15572: CALL_OW 272
15576: PPUSH
15577: LD_VAR 0 8
15581: PPUSH
15582: CALL_OW 251
15586: PPUSH
15587: LD_INT 3
15589: PPUSH
15590: LD_INT 5
15592: PPUSH
15593: CALL_OW 273
15597: PPUSH
15598: CALL_OW 111
// SetTag ( i , 0 ) ;
15602: LD_VAR 0 7
15606: PPUSH
15607: LD_INT 0
15609: PPUSH
15610: CALL_OW 109
// solds := solds diff i ;
15614: LD_ADDR_VAR 0 2
15618: PUSH
15619: LD_VAR 0 2
15623: PUSH
15624: LD_VAR 0 7
15628: DIFF
15629: ST_TO_ADDR
// continue ;
15630: GO 15417
// end ; end ;
15632: GO 15417
15634: POP
15635: POP
// until solds ;
15636: LD_VAR 0 2
15640: IFFALSE 15312
// MC_Reset ( base , 18 ) ;
15642: LD_VAR 0 1
15646: PPUSH
15647: LD_INT 18
15649: PPUSH
15650: CALL 58649 0 2
// end ;
15654: LD_VAR 0 4
15658: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
15659: LD_INT 0
15661: PPUSH
15662: PPUSH
15663: PPUSH
15664: PPUSH
15665: PPUSH
15666: PPUSH
15667: PPUSH
15668: PPUSH
15669: PPUSH
15670: PPUSH
15671: PPUSH
15672: PPUSH
15673: PPUSH
15674: PPUSH
15675: PPUSH
15676: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
15677: LD_ADDR_VAR 0 12
15681: PUSH
15682: LD_EXP 58
15686: PUSH
15687: LD_VAR 0 1
15691: ARRAY
15692: PPUSH
15693: LD_INT 25
15695: PUSH
15696: LD_INT 3
15698: PUSH
15699: EMPTY
15700: LIST
15701: LIST
15702: PPUSH
15703: CALL_OW 72
15707: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
15708: LD_ADDR_VAR 0 8
15712: PUSH
15713: LD_EXP 58
15717: PUSH
15718: LD_VAR 0 1
15722: ARRAY
15723: PPUSH
15724: LD_INT 2
15726: PUSH
15727: LD_INT 25
15729: PUSH
15730: LD_INT 1
15732: PUSH
15733: EMPTY
15734: LIST
15735: LIST
15736: PUSH
15737: LD_INT 25
15739: PUSH
15740: LD_INT 5
15742: PUSH
15743: EMPTY
15744: LIST
15745: LIST
15746: PUSH
15747: LD_INT 25
15749: PUSH
15750: LD_INT 8
15752: PUSH
15753: EMPTY
15754: LIST
15755: LIST
15756: PUSH
15757: LD_INT 25
15759: PUSH
15760: LD_INT 9
15762: PUSH
15763: EMPTY
15764: LIST
15765: LIST
15766: PUSH
15767: EMPTY
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: PPUSH
15774: CALL_OW 72
15778: ST_TO_ADDR
// if not defenders and not solds then
15779: LD_VAR 0 2
15783: NOT
15784: PUSH
15785: LD_VAR 0 8
15789: NOT
15790: AND
15791: IFFALSE 15795
// exit ;
15793: GO 17161
// depot_under_attack := false ;
15795: LD_ADDR_VAR 0 16
15799: PUSH
15800: LD_INT 0
15802: ST_TO_ADDR
// sold_defenders := [ ] ;
15803: LD_ADDR_VAR 0 17
15807: PUSH
15808: EMPTY
15809: ST_TO_ADDR
// if mechs then
15810: LD_VAR 0 12
15814: IFFALSE 15943
// for i in defenders do
15816: LD_ADDR_VAR 0 5
15820: PUSH
15821: LD_VAR 0 2
15825: PUSH
15826: FOR_IN
15827: IFFALSE 15941
// begin SetTag ( i , 20 ) ;
15829: LD_VAR 0 5
15833: PPUSH
15834: LD_INT 20
15836: PPUSH
15837: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
15841: LD_VAR 0 5
15845: PPUSH
15846: CALL_OW 263
15850: PUSH
15851: LD_INT 1
15853: EQUAL
15854: PUSH
15855: LD_VAR 0 5
15859: PPUSH
15860: CALL_OW 311
15864: NOT
15865: AND
15866: PUSH
15867: LD_VAR 0 12
15871: AND
15872: IFFALSE 15939
// begin un := mechs [ 1 ] ;
15874: LD_ADDR_VAR 0 10
15878: PUSH
15879: LD_VAR 0 12
15883: PUSH
15884: LD_INT 1
15886: ARRAY
15887: ST_TO_ADDR
// ComExitBuilding ( un ) ;
15888: LD_VAR 0 10
15892: PPUSH
15893: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
15897: LD_VAR 0 10
15901: PPUSH
15902: LD_VAR 0 5
15906: PPUSH
15907: CALL_OW 180
// SetTag ( un , 19 ) ;
15911: LD_VAR 0 10
15915: PPUSH
15916: LD_INT 19
15918: PPUSH
15919: CALL_OW 109
// mechs := mechs diff un ;
15923: LD_ADDR_VAR 0 12
15927: PUSH
15928: LD_VAR 0 12
15932: PUSH
15933: LD_VAR 0 10
15937: DIFF
15938: ST_TO_ADDR
// end ; end ;
15939: GO 15826
15941: POP
15942: POP
// if solds then
15943: LD_VAR 0 8
15947: IFFALSE 16006
// for i in solds do
15949: LD_ADDR_VAR 0 5
15953: PUSH
15954: LD_VAR 0 8
15958: PUSH
15959: FOR_IN
15960: IFFALSE 16004
// if not GetTag ( i ) then
15962: LD_VAR 0 5
15966: PPUSH
15967: CALL_OW 110
15971: NOT
15972: IFFALSE 16002
// begin defenders := defenders union i ;
15974: LD_ADDR_VAR 0 2
15978: PUSH
15979: LD_VAR 0 2
15983: PUSH
15984: LD_VAR 0 5
15988: UNION
15989: ST_TO_ADDR
// SetTag ( i , 18 ) ;
15990: LD_VAR 0 5
15994: PPUSH
15995: LD_INT 18
15997: PPUSH
15998: CALL_OW 109
// end ;
16002: GO 15959
16004: POP
16005: POP
// repeat wait ( 0 0$1 ) ;
16006: LD_INT 35
16008: PPUSH
16009: CALL_OW 67
// enemy := mc_scan [ base ] ;
16013: LD_ADDR_VAR 0 3
16017: PUSH
16018: LD_EXP 81
16022: PUSH
16023: LD_VAR 0 1
16027: ARRAY
16028: ST_TO_ADDR
// for i in defenders do
16029: LD_ADDR_VAR 0 5
16033: PUSH
16034: LD_VAR 0 2
16038: PUSH
16039: FOR_IN
16040: IFFALSE 16725
// begin e := NearestUnitToUnit ( enemy , i ) ;
16042: LD_ADDR_VAR 0 13
16046: PUSH
16047: LD_VAR 0 3
16051: PPUSH
16052: LD_VAR 0 5
16056: PPUSH
16057: CALL_OW 74
16061: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16062: LD_ADDR_VAR 0 16
16066: PUSH
16067: LD_EXP 58
16071: PUSH
16072: LD_VAR 0 1
16076: ARRAY
16077: PPUSH
16078: LD_INT 2
16080: PUSH
16081: LD_INT 30
16083: PUSH
16084: LD_INT 0
16086: PUSH
16087: EMPTY
16088: LIST
16089: LIST
16090: PUSH
16091: LD_INT 30
16093: PUSH
16094: LD_INT 1
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: PUSH
16101: EMPTY
16102: LIST
16103: LIST
16104: LIST
16105: PPUSH
16106: CALL_OW 72
16110: NOT
16111: PUSH
16112: LD_EXP 58
16116: PUSH
16117: LD_VAR 0 1
16121: ARRAY
16122: PPUSH
16123: LD_INT 2
16125: PUSH
16126: LD_INT 30
16128: PUSH
16129: LD_INT 0
16131: PUSH
16132: EMPTY
16133: LIST
16134: LIST
16135: PUSH
16136: LD_INT 30
16138: PUSH
16139: LD_INT 1
16141: PUSH
16142: EMPTY
16143: LIST
16144: LIST
16145: PUSH
16146: EMPTY
16147: LIST
16148: LIST
16149: LIST
16150: PPUSH
16151: CALL_OW 72
16155: PPUSH
16156: CALL_OW 256
16160: PUSH
16161: LD_INT 600
16163: LESS
16164: OR
16165: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16166: LD_VAR 0 5
16170: PPUSH
16171: CALL_OW 247
16175: PUSH
16176: LD_INT 2
16178: DOUBLE
16179: EQUAL
16180: IFTRUE 16184
16182: GO 16431
16184: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16185: LD_VAR 0 5
16189: PPUSH
16190: CALL_OW 256
16194: PUSH
16195: LD_INT 650
16197: GREATER
16198: PUSH
16199: LD_VAR 0 5
16203: PPUSH
16204: LD_VAR 0 13
16208: PPUSH
16209: CALL_OW 296
16213: PUSH
16214: LD_INT 40
16216: LESS
16217: AND
16218: IFFALSE 16236
// ComAttackUnit ( i , e ) else
16220: LD_VAR 0 5
16224: PPUSH
16225: LD_VAR 0 13
16229: PPUSH
16230: CALL_OW 115
16234: GO 16314
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16236: LD_VAR 0 5
16240: PPUSH
16241: LD_VAR 0 13
16245: PPUSH
16246: CALL_OW 296
16250: PUSH
16251: LD_INT 30
16253: GREATEREQUAL
16254: PUSH
16255: LD_VAR 0 5
16259: PPUSH
16260: CALL_OW 256
16264: PUSH
16265: LD_INT 650
16267: LESSEQUAL
16268: OR
16269: PUSH
16270: LD_VAR 0 5
16274: PPUSH
16275: LD_EXP 82
16279: PUSH
16280: LD_VAR 0 1
16284: ARRAY
16285: PPUSH
16286: CALL_OW 308
16290: NOT
16291: AND
16292: IFFALSE 16314
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16294: LD_VAR 0 5
16298: PPUSH
16299: LD_EXP 82
16303: PUSH
16304: LD_VAR 0 1
16308: ARRAY
16309: PPUSH
16310: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16314: LD_VAR 0 5
16318: PPUSH
16319: CALL_OW 256
16323: PUSH
16324: LD_INT 998
16326: LESS
16327: PUSH
16328: LD_VAR 0 5
16332: PPUSH
16333: CALL_OW 263
16337: PUSH
16338: LD_INT 1
16340: EQUAL
16341: AND
16342: PUSH
16343: LD_VAR 0 5
16347: PPUSH
16348: CALL_OW 311
16352: AND
16353: PUSH
16354: LD_VAR 0 5
16358: PPUSH
16359: LD_EXP 82
16363: PUSH
16364: LD_VAR 0 1
16368: ARRAY
16369: PPUSH
16370: CALL_OW 308
16374: AND
16375: IFFALSE 16429
// begin mech := IsDrivenBy ( i ) ;
16377: LD_ADDR_VAR 0 9
16381: PUSH
16382: LD_VAR 0 5
16386: PPUSH
16387: CALL_OW 311
16391: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16392: LD_VAR 0 9
16396: PPUSH
16397: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16401: LD_VAR 0 9
16405: PPUSH
16406: LD_VAR 0 5
16410: PPUSH
16411: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16415: LD_VAR 0 9
16419: PPUSH
16420: LD_VAR 0 5
16424: PPUSH
16425: CALL_OW 180
// end ; end ; unit_human :
16429: GO 16696
16431: LD_INT 1
16433: DOUBLE
16434: EQUAL
16435: IFTRUE 16439
16437: GO 16695
16439: POP
// begin b := IsInUnit ( i ) ;
16440: LD_ADDR_VAR 0 18
16444: PUSH
16445: LD_VAR 0 5
16449: PPUSH
16450: CALL_OW 310
16454: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16455: LD_ADDR_VAR 0 19
16459: PUSH
16460: LD_VAR 0 18
16464: NOT
16465: PUSH
16466: LD_VAR 0 18
16470: PPUSH
16471: CALL_OW 266
16475: PUSH
16476: LD_INT 32
16478: PUSH
16479: LD_INT 31
16481: PUSH
16482: EMPTY
16483: LIST
16484: LIST
16485: IN
16486: OR
16487: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16488: LD_VAR 0 16
16492: PUSH
16493: LD_VAR 0 2
16497: PPUSH
16498: LD_INT 21
16500: PUSH
16501: LD_INT 2
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PPUSH
16508: CALL_OW 72
16512: PUSH
16513: LD_INT 1
16515: LESSEQUAL
16516: OR
16517: PUSH
16518: LD_VAR 0 19
16522: AND
16523: PUSH
16524: LD_VAR 0 5
16528: PUSH
16529: LD_VAR 0 17
16533: IN
16534: NOT
16535: AND
16536: IFFALSE 16629
// begin if b then
16538: LD_VAR 0 18
16542: IFFALSE 16591
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16544: LD_VAR 0 18
16548: PPUSH
16549: LD_VAR 0 3
16553: PPUSH
16554: LD_VAR 0 18
16558: PPUSH
16559: CALL_OW 74
16563: PPUSH
16564: CALL_OW 296
16568: PUSH
16569: LD_INT 10
16571: LESS
16572: PUSH
16573: LD_VAR 0 18
16577: PPUSH
16578: CALL_OW 461
16582: PUSH
16583: LD_INT 7
16585: NONEQUAL
16586: AND
16587: IFFALSE 16591
// continue ;
16589: GO 16039
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
16591: LD_ADDR_VAR 0 17
16595: PUSH
16596: LD_VAR 0 17
16600: PPUSH
16601: LD_VAR 0 17
16605: PUSH
16606: LD_INT 1
16608: PLUS
16609: PPUSH
16610: LD_VAR 0 5
16614: PPUSH
16615: CALL_OW 1
16619: ST_TO_ADDR
// ComExitBuilding ( i ) ;
16620: LD_VAR 0 5
16624: PPUSH
16625: CALL_OW 122
// end ; if sold_defenders then
16629: LD_VAR 0 17
16633: IFFALSE 16693
// if i in sold_defenders then
16635: LD_VAR 0 5
16639: PUSH
16640: LD_VAR 0 17
16644: IN
16645: IFFALSE 16693
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
16647: LD_VAR 0 5
16651: PPUSH
16652: CALL_OW 314
16656: NOT
16657: PUSH
16658: LD_VAR 0 5
16662: PPUSH
16663: LD_VAR 0 13
16667: PPUSH
16668: CALL_OW 296
16672: PUSH
16673: LD_INT 30
16675: LESS
16676: AND
16677: IFFALSE 16693
// ComAttackUnit ( i , e ) ;
16679: LD_VAR 0 5
16683: PPUSH
16684: LD_VAR 0 13
16688: PPUSH
16689: CALL_OW 115
// end ; end ; end ;
16693: GO 16696
16695: POP
// if IsDead ( i ) then
16696: LD_VAR 0 5
16700: PPUSH
16701: CALL_OW 301
16705: IFFALSE 16723
// defenders := defenders diff i ;
16707: LD_ADDR_VAR 0 2
16711: PUSH
16712: LD_VAR 0 2
16716: PUSH
16717: LD_VAR 0 5
16721: DIFF
16722: ST_TO_ADDR
// end ;
16723: GO 16039
16725: POP
16726: POP
// until not enemy or not defenders ;
16727: LD_VAR 0 3
16731: NOT
16732: PUSH
16733: LD_VAR 0 2
16737: NOT
16738: OR
16739: IFFALSE 16006
// MC_Reset ( base , 18 ) ;
16741: LD_VAR 0 1
16745: PPUSH
16746: LD_INT 18
16748: PPUSH
16749: CALL 58649 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16753: LD_ADDR_VAR 0 2
16757: PUSH
16758: LD_VAR 0 2
16762: PUSH
16763: LD_VAR 0 2
16767: PPUSH
16768: LD_INT 2
16770: PUSH
16771: LD_INT 25
16773: PUSH
16774: LD_INT 1
16776: PUSH
16777: EMPTY
16778: LIST
16779: LIST
16780: PUSH
16781: LD_INT 25
16783: PUSH
16784: LD_INT 5
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PUSH
16791: LD_INT 25
16793: PUSH
16794: LD_INT 8
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PUSH
16801: LD_INT 25
16803: PUSH
16804: LD_INT 9
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PUSH
16811: EMPTY
16812: LIST
16813: LIST
16814: LIST
16815: LIST
16816: LIST
16817: PPUSH
16818: CALL_OW 72
16822: DIFF
16823: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
16824: LD_VAR 0 3
16828: NOT
16829: PUSH
16830: LD_VAR 0 2
16834: PPUSH
16835: LD_INT 21
16837: PUSH
16838: LD_INT 2
16840: PUSH
16841: EMPTY
16842: LIST
16843: LIST
16844: PPUSH
16845: CALL_OW 72
16849: AND
16850: IFFALSE 17112
// begin tmp := FilterByTag ( defenders , 19 ) ;
16852: LD_ADDR_VAR 0 11
16856: PUSH
16857: LD_VAR 0 2
16861: PPUSH
16862: LD_INT 19
16864: PPUSH
16865: CALL 53305 0 2
16869: ST_TO_ADDR
// if tmp then
16870: LD_VAR 0 11
16874: IFFALSE 16944
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
16876: LD_ADDR_VAR 0 11
16880: PUSH
16881: LD_VAR 0 11
16885: PPUSH
16886: LD_INT 25
16888: PUSH
16889: LD_INT 3
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: PPUSH
16896: CALL_OW 72
16900: ST_TO_ADDR
// if tmp then
16901: LD_VAR 0 11
16905: IFFALSE 16944
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
16907: LD_ADDR_EXP 70
16911: PUSH
16912: LD_EXP 70
16916: PPUSH
16917: LD_VAR 0 1
16921: PPUSH
16922: LD_EXP 70
16926: PUSH
16927: LD_VAR 0 1
16931: ARRAY
16932: PUSH
16933: LD_VAR 0 11
16937: UNION
16938: PPUSH
16939: CALL_OW 1
16943: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
16944: LD_VAR 0 1
16948: PPUSH
16949: LD_INT 19
16951: PPUSH
16952: CALL 58649 0 2
// repeat wait ( 0 0$1 ) ;
16956: LD_INT 35
16958: PPUSH
16959: CALL_OW 67
// for i in defenders do
16963: LD_ADDR_VAR 0 5
16967: PUSH
16968: LD_VAR 0 2
16972: PUSH
16973: FOR_IN
16974: IFFALSE 17063
// begin if not IsInArea ( i , mc_parking [ base ] ) then
16976: LD_VAR 0 5
16980: PPUSH
16981: LD_EXP 82
16985: PUSH
16986: LD_VAR 0 1
16990: ARRAY
16991: PPUSH
16992: CALL_OW 308
16996: NOT
16997: IFFALSE 17021
// ComMoveToArea ( i , mc_parking [ base ] ) else
16999: LD_VAR 0 5
17003: PPUSH
17004: LD_EXP 82
17008: PUSH
17009: LD_VAR 0 1
17013: ARRAY
17014: PPUSH
17015: CALL_OW 113
17019: GO 17061
// if GetControl ( i ) = control_manual then
17021: LD_VAR 0 5
17025: PPUSH
17026: CALL_OW 263
17030: PUSH
17031: LD_INT 1
17033: EQUAL
17034: IFFALSE 17061
// if IsDrivenBy ( i ) then
17036: LD_VAR 0 5
17040: PPUSH
17041: CALL_OW 311
17045: IFFALSE 17061
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17047: LD_VAR 0 5
17051: PPUSH
17052: CALL_OW 311
17056: PPUSH
17057: CALL_OW 121
// end ;
17061: GO 16973
17063: POP
17064: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17065: LD_VAR 0 2
17069: PPUSH
17070: LD_INT 95
17072: PUSH
17073: LD_EXP 82
17077: PUSH
17078: LD_VAR 0 1
17082: ARRAY
17083: PUSH
17084: EMPTY
17085: LIST
17086: LIST
17087: PPUSH
17088: CALL_OW 72
17092: PUSH
17093: LD_VAR 0 2
17097: EQUAL
17098: PUSH
17099: LD_EXP 81
17103: PUSH
17104: LD_VAR 0 1
17108: ARRAY
17109: OR
17110: IFFALSE 16956
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17112: LD_ADDR_EXP 80
17116: PUSH
17117: LD_EXP 80
17121: PPUSH
17122: LD_VAR 0 1
17126: PPUSH
17127: LD_EXP 80
17131: PUSH
17132: LD_VAR 0 1
17136: ARRAY
17137: PUSH
17138: LD_VAR 0 2
17142: UNION
17143: PPUSH
17144: CALL_OW 1
17148: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17149: LD_VAR 0 1
17153: PPUSH
17154: LD_INT 20
17156: PPUSH
17157: CALL 58649 0 2
// end ;
17161: LD_VAR 0 4
17165: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17166: LD_INT 0
17168: PPUSH
17169: PPUSH
17170: PPUSH
17171: PPUSH
// result := false ;
17172: LD_ADDR_VAR 0 2
17176: PUSH
17177: LD_INT 0
17179: ST_TO_ADDR
// side := GetSide ( unit ) ;
17180: LD_ADDR_VAR 0 3
17184: PUSH
17185: LD_VAR 0 1
17189: PPUSH
17190: CALL_OW 255
17194: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17195: LD_ADDR_VAR 0 4
17199: PUSH
17200: LD_VAR 0 1
17204: PPUSH
17205: CALL_OW 248
17209: ST_TO_ADDR
// case nat of 1 :
17210: LD_VAR 0 4
17214: PUSH
17215: LD_INT 1
17217: DOUBLE
17218: EQUAL
17219: IFTRUE 17223
17221: GO 17234
17223: POP
// tech := tech_lassight ; 2 :
17224: LD_ADDR_VAR 0 5
17228: PUSH
17229: LD_INT 12
17231: ST_TO_ADDR
17232: GO 17273
17234: LD_INT 2
17236: DOUBLE
17237: EQUAL
17238: IFTRUE 17242
17240: GO 17253
17242: POP
// tech := tech_mortar ; 3 :
17243: LD_ADDR_VAR 0 5
17247: PUSH
17248: LD_INT 41
17250: ST_TO_ADDR
17251: GO 17273
17253: LD_INT 3
17255: DOUBLE
17256: EQUAL
17257: IFTRUE 17261
17259: GO 17272
17261: POP
// tech := tech_bazooka ; end ;
17262: LD_ADDR_VAR 0 5
17266: PUSH
17267: LD_INT 44
17269: ST_TO_ADDR
17270: GO 17273
17272: POP
// if Researched ( side , tech ) then
17273: LD_VAR 0 3
17277: PPUSH
17278: LD_VAR 0 5
17282: PPUSH
17283: CALL_OW 325
17287: IFFALSE 17314
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17289: LD_ADDR_VAR 0 2
17293: PUSH
17294: LD_INT 5
17296: PUSH
17297: LD_INT 8
17299: PUSH
17300: LD_INT 9
17302: PUSH
17303: EMPTY
17304: LIST
17305: LIST
17306: LIST
17307: PUSH
17308: LD_VAR 0 4
17312: ARRAY
17313: ST_TO_ADDR
// end ;
17314: LD_VAR 0 2
17318: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17319: LD_INT 0
17321: PPUSH
17322: PPUSH
17323: PPUSH
// if not mines then
17324: LD_VAR 0 2
17328: NOT
17329: IFFALSE 17333
// exit ;
17331: GO 17477
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17333: LD_ADDR_VAR 0 5
17337: PUSH
17338: LD_INT 81
17340: PUSH
17341: LD_VAR 0 1
17345: PUSH
17346: EMPTY
17347: LIST
17348: LIST
17349: PUSH
17350: LD_INT 3
17352: PUSH
17353: LD_INT 21
17355: PUSH
17356: LD_INT 3
17358: PUSH
17359: EMPTY
17360: LIST
17361: LIST
17362: PUSH
17363: EMPTY
17364: LIST
17365: LIST
17366: PUSH
17367: EMPTY
17368: LIST
17369: LIST
17370: PPUSH
17371: CALL_OW 69
17375: ST_TO_ADDR
// for i in mines do
17376: LD_ADDR_VAR 0 4
17380: PUSH
17381: LD_VAR 0 2
17385: PUSH
17386: FOR_IN
17387: IFFALSE 17475
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17389: LD_VAR 0 4
17393: PUSH
17394: LD_INT 1
17396: ARRAY
17397: PPUSH
17398: LD_VAR 0 4
17402: PUSH
17403: LD_INT 2
17405: ARRAY
17406: PPUSH
17407: CALL_OW 458
17411: NOT
17412: IFFALSE 17416
// continue ;
17414: GO 17386
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17416: LD_VAR 0 4
17420: PUSH
17421: LD_INT 1
17423: ARRAY
17424: PPUSH
17425: LD_VAR 0 4
17429: PUSH
17430: LD_INT 2
17432: ARRAY
17433: PPUSH
17434: CALL_OW 428
17438: PUSH
17439: LD_VAR 0 5
17443: IN
17444: IFFALSE 17473
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17446: LD_VAR 0 4
17450: PUSH
17451: LD_INT 1
17453: ARRAY
17454: PPUSH
17455: LD_VAR 0 4
17459: PUSH
17460: LD_INT 2
17462: ARRAY
17463: PPUSH
17464: LD_VAR 0 1
17468: PPUSH
17469: CALL_OW 456
// end ;
17473: GO 17386
17475: POP
17476: POP
// end ;
17477: LD_VAR 0 3
17481: RET
// export function Count ( array ) ; var i ; begin
17482: LD_INT 0
17484: PPUSH
17485: PPUSH
// result := 0 ;
17486: LD_ADDR_VAR 0 2
17490: PUSH
17491: LD_INT 0
17493: ST_TO_ADDR
// for i in array do
17494: LD_ADDR_VAR 0 3
17498: PUSH
17499: LD_VAR 0 1
17503: PUSH
17504: FOR_IN
17505: IFFALSE 17529
// if i then
17507: LD_VAR 0 3
17511: IFFALSE 17527
// result := result + 1 ;
17513: LD_ADDR_VAR 0 2
17517: PUSH
17518: LD_VAR 0 2
17522: PUSH
17523: LD_INT 1
17525: PLUS
17526: ST_TO_ADDR
17527: GO 17504
17529: POP
17530: POP
// end ;
17531: LD_VAR 0 2
17535: RET
// export function IsEmpty ( building ) ; begin
17536: LD_INT 0
17538: PPUSH
// if not building then
17539: LD_VAR 0 1
17543: NOT
17544: IFFALSE 17548
// exit ;
17546: GO 17591
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17548: LD_ADDR_VAR 0 2
17552: PUSH
17553: LD_VAR 0 1
17557: PUSH
17558: LD_INT 22
17560: PUSH
17561: LD_VAR 0 1
17565: PPUSH
17566: CALL_OW 255
17570: PUSH
17571: EMPTY
17572: LIST
17573: LIST
17574: PUSH
17575: LD_INT 58
17577: PUSH
17578: EMPTY
17579: LIST
17580: PUSH
17581: EMPTY
17582: LIST
17583: LIST
17584: PPUSH
17585: CALL_OW 69
17589: IN
17590: ST_TO_ADDR
// end ;
17591: LD_VAR 0 2
17595: RET
// export function IsNotFull ( building ) ; begin
17596: LD_INT 0
17598: PPUSH
// if not building then
17599: LD_VAR 0 1
17603: NOT
17604: IFFALSE 17608
// exit ;
17606: GO 17627
// result := UnitsInside ( building ) < 6 ;
17608: LD_ADDR_VAR 0 2
17612: PUSH
17613: LD_VAR 0 1
17617: PPUSH
17618: CALL_OW 313
17622: PUSH
17623: LD_INT 6
17625: LESS
17626: ST_TO_ADDR
// end ;
17627: LD_VAR 0 2
17631: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17632: LD_INT 0
17634: PPUSH
17635: PPUSH
17636: PPUSH
17637: PPUSH
// tmp := [ ] ;
17638: LD_ADDR_VAR 0 3
17642: PUSH
17643: EMPTY
17644: ST_TO_ADDR
// list := [ ] ;
17645: LD_ADDR_VAR 0 5
17649: PUSH
17650: EMPTY
17651: ST_TO_ADDR
// for i = 16 to 25 do
17652: LD_ADDR_VAR 0 4
17656: PUSH
17657: DOUBLE
17658: LD_INT 16
17660: DEC
17661: ST_TO_ADDR
17662: LD_INT 25
17664: PUSH
17665: FOR_TO
17666: IFFALSE 17739
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17668: LD_ADDR_VAR 0 3
17672: PUSH
17673: LD_VAR 0 3
17677: PUSH
17678: LD_INT 22
17680: PUSH
17681: LD_VAR 0 1
17685: PPUSH
17686: CALL_OW 255
17690: PUSH
17691: EMPTY
17692: LIST
17693: LIST
17694: PUSH
17695: LD_INT 91
17697: PUSH
17698: LD_VAR 0 1
17702: PUSH
17703: LD_INT 6
17705: PUSH
17706: EMPTY
17707: LIST
17708: LIST
17709: LIST
17710: PUSH
17711: LD_INT 30
17713: PUSH
17714: LD_VAR 0 4
17718: PUSH
17719: EMPTY
17720: LIST
17721: LIST
17722: PUSH
17723: EMPTY
17724: LIST
17725: LIST
17726: LIST
17727: PUSH
17728: EMPTY
17729: LIST
17730: PPUSH
17731: CALL_OW 69
17735: ADD
17736: ST_TO_ADDR
17737: GO 17665
17739: POP
17740: POP
// for i = 1 to tmp do
17741: LD_ADDR_VAR 0 4
17745: PUSH
17746: DOUBLE
17747: LD_INT 1
17749: DEC
17750: ST_TO_ADDR
17751: LD_VAR 0 3
17755: PUSH
17756: FOR_TO
17757: IFFALSE 17845
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17759: LD_ADDR_VAR 0 5
17763: PUSH
17764: LD_VAR 0 5
17768: PUSH
17769: LD_VAR 0 3
17773: PUSH
17774: LD_VAR 0 4
17778: ARRAY
17779: PPUSH
17780: CALL_OW 266
17784: PUSH
17785: LD_VAR 0 3
17789: PUSH
17790: LD_VAR 0 4
17794: ARRAY
17795: PPUSH
17796: CALL_OW 250
17800: PUSH
17801: LD_VAR 0 3
17805: PUSH
17806: LD_VAR 0 4
17810: ARRAY
17811: PPUSH
17812: CALL_OW 251
17816: PUSH
17817: LD_VAR 0 3
17821: PUSH
17822: LD_VAR 0 4
17826: ARRAY
17827: PPUSH
17828: CALL_OW 254
17832: PUSH
17833: EMPTY
17834: LIST
17835: LIST
17836: LIST
17837: LIST
17838: PUSH
17839: EMPTY
17840: LIST
17841: ADD
17842: ST_TO_ADDR
17843: GO 17756
17845: POP
17846: POP
// result := list ;
17847: LD_ADDR_VAR 0 2
17851: PUSH
17852: LD_VAR 0 5
17856: ST_TO_ADDR
// end ;
17857: LD_VAR 0 2
17861: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17862: LD_INT 0
17864: PPUSH
17865: PPUSH
17866: PPUSH
17867: PPUSH
17868: PPUSH
17869: PPUSH
17870: PPUSH
// if not factory then
17871: LD_VAR 0 1
17875: NOT
17876: IFFALSE 17880
// exit ;
17878: GO 18405
// if control = control_apeman then
17880: LD_VAR 0 4
17884: PUSH
17885: LD_INT 5
17887: EQUAL
17888: IFFALSE 17997
// begin tmp := UnitsInside ( factory ) ;
17890: LD_ADDR_VAR 0 8
17894: PUSH
17895: LD_VAR 0 1
17899: PPUSH
17900: CALL_OW 313
17904: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17905: LD_VAR 0 8
17909: PPUSH
17910: LD_INT 25
17912: PUSH
17913: LD_INT 12
17915: PUSH
17916: EMPTY
17917: LIST
17918: LIST
17919: PPUSH
17920: CALL_OW 72
17924: NOT
17925: IFFALSE 17935
// control := control_manual ;
17927: LD_ADDR_VAR 0 4
17931: PUSH
17932: LD_INT 1
17934: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17935: LD_ADDR_VAR 0 8
17939: PUSH
17940: LD_VAR 0 1
17944: PPUSH
17945: CALL 17632 0 1
17949: ST_TO_ADDR
// if tmp then
17950: LD_VAR 0 8
17954: IFFALSE 17997
// begin for i in tmp do
17956: LD_ADDR_VAR 0 7
17960: PUSH
17961: LD_VAR 0 8
17965: PUSH
17966: FOR_IN
17967: IFFALSE 17995
// if i [ 1 ] = b_ext_radar then
17969: LD_VAR 0 7
17973: PUSH
17974: LD_INT 1
17976: ARRAY
17977: PUSH
17978: LD_INT 20
17980: EQUAL
17981: IFFALSE 17993
// begin control := control_remote ;
17983: LD_ADDR_VAR 0 4
17987: PUSH
17988: LD_INT 2
17990: ST_TO_ADDR
// break ;
17991: GO 17995
// end ;
17993: GO 17966
17995: POP
17996: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17997: LD_VAR 0 1
18001: PPUSH
18002: LD_VAR 0 2
18006: PPUSH
18007: LD_VAR 0 3
18011: PPUSH
18012: LD_VAR 0 4
18016: PPUSH
18017: LD_VAR 0 5
18021: PPUSH
18022: CALL_OW 448
18026: IFFALSE 18061
// begin result := [ chassis , engine , control , weapon ] ;
18028: LD_ADDR_VAR 0 6
18032: PUSH
18033: LD_VAR 0 2
18037: PUSH
18038: LD_VAR 0 3
18042: PUSH
18043: LD_VAR 0 4
18047: PUSH
18048: LD_VAR 0 5
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: LIST
18057: LIST
18058: ST_TO_ADDR
// exit ;
18059: GO 18405
// end ; _chassis := AvailableChassisList ( factory ) ;
18061: LD_ADDR_VAR 0 9
18065: PUSH
18066: LD_VAR 0 1
18070: PPUSH
18071: CALL_OW 475
18075: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18076: LD_ADDR_VAR 0 11
18080: PUSH
18081: LD_VAR 0 1
18085: PPUSH
18086: CALL_OW 476
18090: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18091: LD_ADDR_VAR 0 12
18095: PUSH
18096: LD_VAR 0 1
18100: PPUSH
18101: CALL_OW 477
18105: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18106: LD_ADDR_VAR 0 10
18110: PUSH
18111: LD_VAR 0 1
18115: PPUSH
18116: CALL_OW 478
18120: ST_TO_ADDR
// if not chassis in _chassis then
18121: LD_VAR 0 2
18125: PUSH
18126: LD_VAR 0 9
18130: IN
18131: NOT
18132: IFFALSE 18158
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18134: LD_ADDR_VAR 0 2
18138: PUSH
18139: LD_VAR 0 9
18143: PUSH
18144: LD_INT 1
18146: PPUSH
18147: LD_VAR 0 9
18151: PPUSH
18152: CALL_OW 12
18156: ARRAY
18157: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18158: LD_VAR 0 2
18162: PPUSH
18163: LD_VAR 0 3
18167: PPUSH
18168: CALL 18410 0 2
18172: NOT
18173: IFFALSE 18232
// repeat engine := _engine [ 1 ] ;
18175: LD_ADDR_VAR 0 3
18179: PUSH
18180: LD_VAR 0 11
18184: PUSH
18185: LD_INT 1
18187: ARRAY
18188: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18189: LD_ADDR_VAR 0 11
18193: PUSH
18194: LD_VAR 0 11
18198: PPUSH
18199: LD_INT 1
18201: PPUSH
18202: CALL_OW 3
18206: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18207: LD_VAR 0 2
18211: PPUSH
18212: LD_VAR 0 3
18216: PPUSH
18217: CALL 18410 0 2
18221: PUSH
18222: LD_VAR 0 11
18226: PUSH
18227: EMPTY
18228: EQUAL
18229: OR
18230: IFFALSE 18175
// if not control in _control then
18232: LD_VAR 0 4
18236: PUSH
18237: LD_VAR 0 12
18241: IN
18242: NOT
18243: IFFALSE 18269
// control := _control [ rand ( 1 , _control ) ] ;
18245: LD_ADDR_VAR 0 4
18249: PUSH
18250: LD_VAR 0 12
18254: PUSH
18255: LD_INT 1
18257: PPUSH
18258: LD_VAR 0 12
18262: PPUSH
18263: CALL_OW 12
18267: ARRAY
18268: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18269: LD_VAR 0 2
18273: PPUSH
18274: LD_VAR 0 5
18278: PPUSH
18279: CALL 18630 0 2
18283: NOT
18284: IFFALSE 18343
// repeat weapon := _weapon [ 1 ] ;
18286: LD_ADDR_VAR 0 5
18290: PUSH
18291: LD_VAR 0 10
18295: PUSH
18296: LD_INT 1
18298: ARRAY
18299: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18300: LD_ADDR_VAR 0 10
18304: PUSH
18305: LD_VAR 0 10
18309: PPUSH
18310: LD_INT 1
18312: PPUSH
18313: CALL_OW 3
18317: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18318: LD_VAR 0 2
18322: PPUSH
18323: LD_VAR 0 5
18327: PPUSH
18328: CALL 18630 0 2
18332: PUSH
18333: LD_VAR 0 10
18337: PUSH
18338: EMPTY
18339: EQUAL
18340: OR
18341: IFFALSE 18286
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18343: LD_VAR 0 1
18347: PPUSH
18348: LD_VAR 0 2
18352: PPUSH
18353: LD_VAR 0 3
18357: PPUSH
18358: LD_VAR 0 4
18362: PPUSH
18363: LD_VAR 0 5
18367: PPUSH
18368: CALL_OW 448
18372: IFFALSE 18405
// result := [ chassis , engine , control , weapon ] ;
18374: LD_ADDR_VAR 0 6
18378: PUSH
18379: LD_VAR 0 2
18383: PUSH
18384: LD_VAR 0 3
18388: PUSH
18389: LD_VAR 0 4
18393: PUSH
18394: LD_VAR 0 5
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: ST_TO_ADDR
// end ;
18405: LD_VAR 0 6
18409: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18410: LD_INT 0
18412: PPUSH
// if not chassis or not engine then
18413: LD_VAR 0 1
18417: NOT
18418: PUSH
18419: LD_VAR 0 2
18423: NOT
18424: OR
18425: IFFALSE 18429
// exit ;
18427: GO 18625
// case engine of engine_solar :
18429: LD_VAR 0 2
18433: PUSH
18434: LD_INT 2
18436: DOUBLE
18437: EQUAL
18438: IFTRUE 18442
18440: GO 18480
18442: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18443: LD_ADDR_VAR 0 3
18447: PUSH
18448: LD_INT 11
18450: PUSH
18451: LD_INT 12
18453: PUSH
18454: LD_INT 13
18456: PUSH
18457: LD_INT 14
18459: PUSH
18460: LD_INT 1
18462: PUSH
18463: LD_INT 2
18465: PUSH
18466: LD_INT 3
18468: PUSH
18469: EMPTY
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: LIST
18475: LIST
18476: LIST
18477: ST_TO_ADDR
18478: GO 18609
18480: LD_INT 1
18482: DOUBLE
18483: EQUAL
18484: IFTRUE 18488
18486: GO 18550
18488: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18489: LD_ADDR_VAR 0 3
18493: PUSH
18494: LD_INT 11
18496: PUSH
18497: LD_INT 12
18499: PUSH
18500: LD_INT 13
18502: PUSH
18503: LD_INT 14
18505: PUSH
18506: LD_INT 1
18508: PUSH
18509: LD_INT 2
18511: PUSH
18512: LD_INT 3
18514: PUSH
18515: LD_INT 4
18517: PUSH
18518: LD_INT 5
18520: PUSH
18521: LD_INT 21
18523: PUSH
18524: LD_INT 23
18526: PUSH
18527: LD_INT 22
18529: PUSH
18530: LD_INT 24
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: LIST
18538: LIST
18539: LIST
18540: LIST
18541: LIST
18542: LIST
18543: LIST
18544: LIST
18545: LIST
18546: LIST
18547: ST_TO_ADDR
18548: GO 18609
18550: LD_INT 3
18552: DOUBLE
18553: EQUAL
18554: IFTRUE 18558
18556: GO 18608
18558: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18559: LD_ADDR_VAR 0 3
18563: PUSH
18564: LD_INT 13
18566: PUSH
18567: LD_INT 14
18569: PUSH
18570: LD_INT 2
18572: PUSH
18573: LD_INT 3
18575: PUSH
18576: LD_INT 4
18578: PUSH
18579: LD_INT 5
18581: PUSH
18582: LD_INT 21
18584: PUSH
18585: LD_INT 22
18587: PUSH
18588: LD_INT 23
18590: PUSH
18591: LD_INT 24
18593: PUSH
18594: EMPTY
18595: LIST
18596: LIST
18597: LIST
18598: LIST
18599: LIST
18600: LIST
18601: LIST
18602: LIST
18603: LIST
18604: LIST
18605: ST_TO_ADDR
18606: GO 18609
18608: POP
// result := ( chassis in result ) ;
18609: LD_ADDR_VAR 0 3
18613: PUSH
18614: LD_VAR 0 1
18618: PUSH
18619: LD_VAR 0 3
18623: IN
18624: ST_TO_ADDR
// end ;
18625: LD_VAR 0 3
18629: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18630: LD_INT 0
18632: PPUSH
// if not chassis or not weapon then
18633: LD_VAR 0 1
18637: NOT
18638: PUSH
18639: LD_VAR 0 2
18643: NOT
18644: OR
18645: IFFALSE 18649
// exit ;
18647: GO 19675
// case weapon of us_machine_gun :
18649: LD_VAR 0 2
18653: PUSH
18654: LD_INT 2
18656: DOUBLE
18657: EQUAL
18658: IFTRUE 18662
18660: GO 18692
18662: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18663: LD_ADDR_VAR 0 3
18667: PUSH
18668: LD_INT 1
18670: PUSH
18671: LD_INT 2
18673: PUSH
18674: LD_INT 3
18676: PUSH
18677: LD_INT 4
18679: PUSH
18680: LD_INT 5
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: LIST
18687: LIST
18688: LIST
18689: ST_TO_ADDR
18690: GO 19659
18692: LD_INT 3
18694: DOUBLE
18695: EQUAL
18696: IFTRUE 18700
18698: GO 18730
18700: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18701: LD_ADDR_VAR 0 3
18705: PUSH
18706: LD_INT 1
18708: PUSH
18709: LD_INT 2
18711: PUSH
18712: LD_INT 3
18714: PUSH
18715: LD_INT 4
18717: PUSH
18718: LD_INT 5
18720: PUSH
18721: EMPTY
18722: LIST
18723: LIST
18724: LIST
18725: LIST
18726: LIST
18727: ST_TO_ADDR
18728: GO 19659
18730: LD_INT 11
18732: DOUBLE
18733: EQUAL
18734: IFTRUE 18738
18736: GO 18768
18738: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18739: LD_ADDR_VAR 0 3
18743: PUSH
18744: LD_INT 1
18746: PUSH
18747: LD_INT 2
18749: PUSH
18750: LD_INT 3
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: LD_INT 5
18758: PUSH
18759: EMPTY
18760: LIST
18761: LIST
18762: LIST
18763: LIST
18764: LIST
18765: ST_TO_ADDR
18766: GO 19659
18768: LD_INT 4
18770: DOUBLE
18771: EQUAL
18772: IFTRUE 18776
18774: GO 18802
18776: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18777: LD_ADDR_VAR 0 3
18781: PUSH
18782: LD_INT 2
18784: PUSH
18785: LD_INT 3
18787: PUSH
18788: LD_INT 4
18790: PUSH
18791: LD_INT 5
18793: PUSH
18794: EMPTY
18795: LIST
18796: LIST
18797: LIST
18798: LIST
18799: ST_TO_ADDR
18800: GO 19659
18802: LD_INT 5
18804: DOUBLE
18805: EQUAL
18806: IFTRUE 18810
18808: GO 18836
18810: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18811: LD_ADDR_VAR 0 3
18815: PUSH
18816: LD_INT 2
18818: PUSH
18819: LD_INT 3
18821: PUSH
18822: LD_INT 4
18824: PUSH
18825: LD_INT 5
18827: PUSH
18828: EMPTY
18829: LIST
18830: LIST
18831: LIST
18832: LIST
18833: ST_TO_ADDR
18834: GO 19659
18836: LD_INT 9
18838: DOUBLE
18839: EQUAL
18840: IFTRUE 18844
18842: GO 18870
18844: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18845: LD_ADDR_VAR 0 3
18849: PUSH
18850: LD_INT 2
18852: PUSH
18853: LD_INT 3
18855: PUSH
18856: LD_INT 4
18858: PUSH
18859: LD_INT 5
18861: PUSH
18862: EMPTY
18863: LIST
18864: LIST
18865: LIST
18866: LIST
18867: ST_TO_ADDR
18868: GO 19659
18870: LD_INT 7
18872: DOUBLE
18873: EQUAL
18874: IFTRUE 18878
18876: GO 18904
18878: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18879: LD_ADDR_VAR 0 3
18883: PUSH
18884: LD_INT 2
18886: PUSH
18887: LD_INT 3
18889: PUSH
18890: LD_INT 4
18892: PUSH
18893: LD_INT 5
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: LIST
18900: LIST
18901: ST_TO_ADDR
18902: GO 19659
18904: LD_INT 12
18906: DOUBLE
18907: EQUAL
18908: IFTRUE 18912
18910: GO 18938
18912: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18913: LD_ADDR_VAR 0 3
18917: PUSH
18918: LD_INT 2
18920: PUSH
18921: LD_INT 3
18923: PUSH
18924: LD_INT 4
18926: PUSH
18927: LD_INT 5
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: ST_TO_ADDR
18936: GO 19659
18938: LD_INT 13
18940: DOUBLE
18941: EQUAL
18942: IFTRUE 18946
18944: GO 18972
18946: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18947: LD_ADDR_VAR 0 3
18951: PUSH
18952: LD_INT 2
18954: PUSH
18955: LD_INT 3
18957: PUSH
18958: LD_INT 4
18960: PUSH
18961: LD_INT 5
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: ST_TO_ADDR
18970: GO 19659
18972: LD_INT 14
18974: DOUBLE
18975: EQUAL
18976: IFTRUE 18980
18978: GO 18998
18980: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18981: LD_ADDR_VAR 0 3
18985: PUSH
18986: LD_INT 4
18988: PUSH
18989: LD_INT 5
18991: PUSH
18992: EMPTY
18993: LIST
18994: LIST
18995: ST_TO_ADDR
18996: GO 19659
18998: LD_INT 6
19000: DOUBLE
19001: EQUAL
19002: IFTRUE 19006
19004: GO 19024
19006: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19007: LD_ADDR_VAR 0 3
19011: PUSH
19012: LD_INT 4
19014: PUSH
19015: LD_INT 5
19017: PUSH
19018: EMPTY
19019: LIST
19020: LIST
19021: ST_TO_ADDR
19022: GO 19659
19024: LD_INT 10
19026: DOUBLE
19027: EQUAL
19028: IFTRUE 19032
19030: GO 19050
19032: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19033: LD_ADDR_VAR 0 3
19037: PUSH
19038: LD_INT 4
19040: PUSH
19041: LD_INT 5
19043: PUSH
19044: EMPTY
19045: LIST
19046: LIST
19047: ST_TO_ADDR
19048: GO 19659
19050: LD_INT 22
19052: DOUBLE
19053: EQUAL
19054: IFTRUE 19058
19056: GO 19084
19058: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19059: LD_ADDR_VAR 0 3
19063: PUSH
19064: LD_INT 11
19066: PUSH
19067: LD_INT 12
19069: PUSH
19070: LD_INT 13
19072: PUSH
19073: LD_INT 14
19075: PUSH
19076: EMPTY
19077: LIST
19078: LIST
19079: LIST
19080: LIST
19081: ST_TO_ADDR
19082: GO 19659
19084: LD_INT 23
19086: DOUBLE
19087: EQUAL
19088: IFTRUE 19092
19090: GO 19118
19092: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_INT 11
19100: PUSH
19101: LD_INT 12
19103: PUSH
19104: LD_INT 13
19106: PUSH
19107: LD_INT 14
19109: PUSH
19110: EMPTY
19111: LIST
19112: LIST
19113: LIST
19114: LIST
19115: ST_TO_ADDR
19116: GO 19659
19118: LD_INT 24
19120: DOUBLE
19121: EQUAL
19122: IFTRUE 19126
19124: GO 19152
19126: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19127: LD_ADDR_VAR 0 3
19131: PUSH
19132: LD_INT 11
19134: PUSH
19135: LD_INT 12
19137: PUSH
19138: LD_INT 13
19140: PUSH
19141: LD_INT 14
19143: PUSH
19144: EMPTY
19145: LIST
19146: LIST
19147: LIST
19148: LIST
19149: ST_TO_ADDR
19150: GO 19659
19152: LD_INT 30
19154: DOUBLE
19155: EQUAL
19156: IFTRUE 19160
19158: GO 19186
19160: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19161: LD_ADDR_VAR 0 3
19165: PUSH
19166: LD_INT 11
19168: PUSH
19169: LD_INT 12
19171: PUSH
19172: LD_INT 13
19174: PUSH
19175: LD_INT 14
19177: PUSH
19178: EMPTY
19179: LIST
19180: LIST
19181: LIST
19182: LIST
19183: ST_TO_ADDR
19184: GO 19659
19186: LD_INT 25
19188: DOUBLE
19189: EQUAL
19190: IFTRUE 19194
19192: GO 19212
19194: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19195: LD_ADDR_VAR 0 3
19199: PUSH
19200: LD_INT 13
19202: PUSH
19203: LD_INT 14
19205: PUSH
19206: EMPTY
19207: LIST
19208: LIST
19209: ST_TO_ADDR
19210: GO 19659
19212: LD_INT 27
19214: DOUBLE
19215: EQUAL
19216: IFTRUE 19220
19218: GO 19238
19220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19221: LD_ADDR_VAR 0 3
19225: PUSH
19226: LD_INT 13
19228: PUSH
19229: LD_INT 14
19231: PUSH
19232: EMPTY
19233: LIST
19234: LIST
19235: ST_TO_ADDR
19236: GO 19659
19238: LD_INT 28
19240: DOUBLE
19241: EQUAL
19242: IFTRUE 19246
19244: GO 19264
19246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19247: LD_ADDR_VAR 0 3
19251: PUSH
19252: LD_INT 13
19254: PUSH
19255: LD_INT 14
19257: PUSH
19258: EMPTY
19259: LIST
19260: LIST
19261: ST_TO_ADDR
19262: GO 19659
19264: LD_INT 29
19266: DOUBLE
19267: EQUAL
19268: IFTRUE 19272
19270: GO 19290
19272: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19273: LD_ADDR_VAR 0 3
19277: PUSH
19278: LD_INT 13
19280: PUSH
19281: LD_INT 14
19283: PUSH
19284: EMPTY
19285: LIST
19286: LIST
19287: ST_TO_ADDR
19288: GO 19659
19290: LD_INT 31
19292: DOUBLE
19293: EQUAL
19294: IFTRUE 19298
19296: GO 19316
19298: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19299: LD_ADDR_VAR 0 3
19303: PUSH
19304: LD_INT 13
19306: PUSH
19307: LD_INT 14
19309: PUSH
19310: EMPTY
19311: LIST
19312: LIST
19313: ST_TO_ADDR
19314: GO 19659
19316: LD_INT 26
19318: DOUBLE
19319: EQUAL
19320: IFTRUE 19324
19322: GO 19342
19324: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19325: LD_ADDR_VAR 0 3
19329: PUSH
19330: LD_INT 13
19332: PUSH
19333: LD_INT 14
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: ST_TO_ADDR
19340: GO 19659
19342: LD_INT 42
19344: DOUBLE
19345: EQUAL
19346: IFTRUE 19350
19348: GO 19376
19350: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19351: LD_ADDR_VAR 0 3
19355: PUSH
19356: LD_INT 21
19358: PUSH
19359: LD_INT 22
19361: PUSH
19362: LD_INT 23
19364: PUSH
19365: LD_INT 24
19367: PUSH
19368: EMPTY
19369: LIST
19370: LIST
19371: LIST
19372: LIST
19373: ST_TO_ADDR
19374: GO 19659
19376: LD_INT 43
19378: DOUBLE
19379: EQUAL
19380: IFTRUE 19384
19382: GO 19410
19384: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19385: LD_ADDR_VAR 0 3
19389: PUSH
19390: LD_INT 21
19392: PUSH
19393: LD_INT 22
19395: PUSH
19396: LD_INT 23
19398: PUSH
19399: LD_INT 24
19401: PUSH
19402: EMPTY
19403: LIST
19404: LIST
19405: LIST
19406: LIST
19407: ST_TO_ADDR
19408: GO 19659
19410: LD_INT 44
19412: DOUBLE
19413: EQUAL
19414: IFTRUE 19418
19416: GO 19444
19418: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19419: LD_ADDR_VAR 0 3
19423: PUSH
19424: LD_INT 21
19426: PUSH
19427: LD_INT 22
19429: PUSH
19430: LD_INT 23
19432: PUSH
19433: LD_INT 24
19435: PUSH
19436: EMPTY
19437: LIST
19438: LIST
19439: LIST
19440: LIST
19441: ST_TO_ADDR
19442: GO 19659
19444: LD_INT 45
19446: DOUBLE
19447: EQUAL
19448: IFTRUE 19452
19450: GO 19478
19452: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19453: LD_ADDR_VAR 0 3
19457: PUSH
19458: LD_INT 21
19460: PUSH
19461: LD_INT 22
19463: PUSH
19464: LD_INT 23
19466: PUSH
19467: LD_INT 24
19469: PUSH
19470: EMPTY
19471: LIST
19472: LIST
19473: LIST
19474: LIST
19475: ST_TO_ADDR
19476: GO 19659
19478: LD_INT 49
19480: DOUBLE
19481: EQUAL
19482: IFTRUE 19486
19484: GO 19512
19486: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19487: LD_ADDR_VAR 0 3
19491: PUSH
19492: LD_INT 21
19494: PUSH
19495: LD_INT 22
19497: PUSH
19498: LD_INT 23
19500: PUSH
19501: LD_INT 24
19503: PUSH
19504: EMPTY
19505: LIST
19506: LIST
19507: LIST
19508: LIST
19509: ST_TO_ADDR
19510: GO 19659
19512: LD_INT 51
19514: DOUBLE
19515: EQUAL
19516: IFTRUE 19520
19518: GO 19546
19520: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19521: LD_ADDR_VAR 0 3
19525: PUSH
19526: LD_INT 21
19528: PUSH
19529: LD_INT 22
19531: PUSH
19532: LD_INT 23
19534: PUSH
19535: LD_INT 24
19537: PUSH
19538: EMPTY
19539: LIST
19540: LIST
19541: LIST
19542: LIST
19543: ST_TO_ADDR
19544: GO 19659
19546: LD_INT 52
19548: DOUBLE
19549: EQUAL
19550: IFTRUE 19554
19552: GO 19580
19554: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19555: LD_ADDR_VAR 0 3
19559: PUSH
19560: LD_INT 21
19562: PUSH
19563: LD_INT 22
19565: PUSH
19566: LD_INT 23
19568: PUSH
19569: LD_INT 24
19571: PUSH
19572: EMPTY
19573: LIST
19574: LIST
19575: LIST
19576: LIST
19577: ST_TO_ADDR
19578: GO 19659
19580: LD_INT 53
19582: DOUBLE
19583: EQUAL
19584: IFTRUE 19588
19586: GO 19606
19588: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19589: LD_ADDR_VAR 0 3
19593: PUSH
19594: LD_INT 23
19596: PUSH
19597: LD_INT 24
19599: PUSH
19600: EMPTY
19601: LIST
19602: LIST
19603: ST_TO_ADDR
19604: GO 19659
19606: LD_INT 46
19608: DOUBLE
19609: EQUAL
19610: IFTRUE 19614
19612: GO 19632
19614: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19615: LD_ADDR_VAR 0 3
19619: PUSH
19620: LD_INT 23
19622: PUSH
19623: LD_INT 24
19625: PUSH
19626: EMPTY
19627: LIST
19628: LIST
19629: ST_TO_ADDR
19630: GO 19659
19632: LD_INT 47
19634: DOUBLE
19635: EQUAL
19636: IFTRUE 19640
19638: GO 19658
19640: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19641: LD_ADDR_VAR 0 3
19645: PUSH
19646: LD_INT 23
19648: PUSH
19649: LD_INT 24
19651: PUSH
19652: EMPTY
19653: LIST
19654: LIST
19655: ST_TO_ADDR
19656: GO 19659
19658: POP
// result := ( chassis in result ) ;
19659: LD_ADDR_VAR 0 3
19663: PUSH
19664: LD_VAR 0 1
19668: PUSH
19669: LD_VAR 0 3
19673: IN
19674: ST_TO_ADDR
// end ;
19675: LD_VAR 0 3
19679: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19680: LD_INT 0
19682: PPUSH
19683: PPUSH
19684: PPUSH
19685: PPUSH
19686: PPUSH
19687: PPUSH
19688: PPUSH
// result := array ;
19689: LD_ADDR_VAR 0 5
19693: PUSH
19694: LD_VAR 0 1
19698: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19699: LD_VAR 0 1
19703: NOT
19704: PUSH
19705: LD_VAR 0 2
19709: NOT
19710: OR
19711: PUSH
19712: LD_VAR 0 3
19716: NOT
19717: OR
19718: PUSH
19719: LD_VAR 0 2
19723: PUSH
19724: LD_VAR 0 1
19728: GREATER
19729: OR
19730: PUSH
19731: LD_VAR 0 3
19735: PUSH
19736: LD_VAR 0 1
19740: GREATER
19741: OR
19742: IFFALSE 19746
// exit ;
19744: GO 20042
// if direction then
19746: LD_VAR 0 4
19750: IFFALSE 19814
// begin d := 1 ;
19752: LD_ADDR_VAR 0 9
19756: PUSH
19757: LD_INT 1
19759: ST_TO_ADDR
// if i_from > i_to then
19760: LD_VAR 0 2
19764: PUSH
19765: LD_VAR 0 3
19769: GREATER
19770: IFFALSE 19796
// length := ( array - i_from ) + i_to else
19772: LD_ADDR_VAR 0 11
19776: PUSH
19777: LD_VAR 0 1
19781: PUSH
19782: LD_VAR 0 2
19786: MINUS
19787: PUSH
19788: LD_VAR 0 3
19792: PLUS
19793: ST_TO_ADDR
19794: GO 19812
// length := i_to - i_from ;
19796: LD_ADDR_VAR 0 11
19800: PUSH
19801: LD_VAR 0 3
19805: PUSH
19806: LD_VAR 0 2
19810: MINUS
19811: ST_TO_ADDR
// end else
19812: GO 19875
// begin d := - 1 ;
19814: LD_ADDR_VAR 0 9
19818: PUSH
19819: LD_INT 1
19821: NEG
19822: ST_TO_ADDR
// if i_from > i_to then
19823: LD_VAR 0 2
19827: PUSH
19828: LD_VAR 0 3
19832: GREATER
19833: IFFALSE 19853
// length := i_from - i_to else
19835: LD_ADDR_VAR 0 11
19839: PUSH
19840: LD_VAR 0 2
19844: PUSH
19845: LD_VAR 0 3
19849: MINUS
19850: ST_TO_ADDR
19851: GO 19875
// length := ( array - i_to ) + i_from ;
19853: LD_ADDR_VAR 0 11
19857: PUSH
19858: LD_VAR 0 1
19862: PUSH
19863: LD_VAR 0 3
19867: MINUS
19868: PUSH
19869: LD_VAR 0 2
19873: PLUS
19874: ST_TO_ADDR
// end ; if not length then
19875: LD_VAR 0 11
19879: NOT
19880: IFFALSE 19884
// exit ;
19882: GO 20042
// tmp := array ;
19884: LD_ADDR_VAR 0 10
19888: PUSH
19889: LD_VAR 0 1
19893: ST_TO_ADDR
// for i = 1 to length do
19894: LD_ADDR_VAR 0 6
19898: PUSH
19899: DOUBLE
19900: LD_INT 1
19902: DEC
19903: ST_TO_ADDR
19904: LD_VAR 0 11
19908: PUSH
19909: FOR_TO
19910: IFFALSE 20030
// begin for j = 1 to array do
19912: LD_ADDR_VAR 0 7
19916: PUSH
19917: DOUBLE
19918: LD_INT 1
19920: DEC
19921: ST_TO_ADDR
19922: LD_VAR 0 1
19926: PUSH
19927: FOR_TO
19928: IFFALSE 20016
// begin k := j + d ;
19930: LD_ADDR_VAR 0 8
19934: PUSH
19935: LD_VAR 0 7
19939: PUSH
19940: LD_VAR 0 9
19944: PLUS
19945: ST_TO_ADDR
// if k > array then
19946: LD_VAR 0 8
19950: PUSH
19951: LD_VAR 0 1
19955: GREATER
19956: IFFALSE 19966
// k := 1 ;
19958: LD_ADDR_VAR 0 8
19962: PUSH
19963: LD_INT 1
19965: ST_TO_ADDR
// if not k then
19966: LD_VAR 0 8
19970: NOT
19971: IFFALSE 19983
// k := array ;
19973: LD_ADDR_VAR 0 8
19977: PUSH
19978: LD_VAR 0 1
19982: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19983: LD_ADDR_VAR 0 10
19987: PUSH
19988: LD_VAR 0 10
19992: PPUSH
19993: LD_VAR 0 8
19997: PPUSH
19998: LD_VAR 0 1
20002: PUSH
20003: LD_VAR 0 7
20007: ARRAY
20008: PPUSH
20009: CALL_OW 1
20013: ST_TO_ADDR
// end ;
20014: GO 19927
20016: POP
20017: POP
// array := tmp ;
20018: LD_ADDR_VAR 0 1
20022: PUSH
20023: LD_VAR 0 10
20027: ST_TO_ADDR
// end ;
20028: GO 19909
20030: POP
20031: POP
// result := array ;
20032: LD_ADDR_VAR 0 5
20036: PUSH
20037: LD_VAR 0 1
20041: ST_TO_ADDR
// end ;
20042: LD_VAR 0 5
20046: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20047: LD_INT 0
20049: PPUSH
20050: PPUSH
// result := 0 ;
20051: LD_ADDR_VAR 0 3
20055: PUSH
20056: LD_INT 0
20058: ST_TO_ADDR
// if not array or not value in array then
20059: LD_VAR 0 1
20063: NOT
20064: PUSH
20065: LD_VAR 0 2
20069: PUSH
20070: LD_VAR 0 1
20074: IN
20075: NOT
20076: OR
20077: IFFALSE 20081
// exit ;
20079: GO 20135
// for i = 1 to array do
20081: LD_ADDR_VAR 0 4
20085: PUSH
20086: DOUBLE
20087: LD_INT 1
20089: DEC
20090: ST_TO_ADDR
20091: LD_VAR 0 1
20095: PUSH
20096: FOR_TO
20097: IFFALSE 20133
// if value = array [ i ] then
20099: LD_VAR 0 2
20103: PUSH
20104: LD_VAR 0 1
20108: PUSH
20109: LD_VAR 0 4
20113: ARRAY
20114: EQUAL
20115: IFFALSE 20131
// begin result := i ;
20117: LD_ADDR_VAR 0 3
20121: PUSH
20122: LD_VAR 0 4
20126: ST_TO_ADDR
// exit ;
20127: POP
20128: POP
20129: GO 20135
// end ;
20131: GO 20096
20133: POP
20134: POP
// end ;
20135: LD_VAR 0 3
20139: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20140: LD_INT 0
20142: PPUSH
// vc_chassis := chassis ;
20143: LD_ADDR_OWVAR 37
20147: PUSH
20148: LD_VAR 0 1
20152: ST_TO_ADDR
// vc_engine := engine ;
20153: LD_ADDR_OWVAR 39
20157: PUSH
20158: LD_VAR 0 2
20162: ST_TO_ADDR
// vc_control := control ;
20163: LD_ADDR_OWVAR 38
20167: PUSH
20168: LD_VAR 0 3
20172: ST_TO_ADDR
// vc_weapon := weapon ;
20173: LD_ADDR_OWVAR 40
20177: PUSH
20178: LD_VAR 0 4
20182: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20183: LD_ADDR_OWVAR 41
20187: PUSH
20188: LD_VAR 0 5
20192: ST_TO_ADDR
// end ;
20193: LD_VAR 0 6
20197: RET
// export function WantPlant ( unit ) ; var task ; begin
20198: LD_INT 0
20200: PPUSH
20201: PPUSH
// result := false ;
20202: LD_ADDR_VAR 0 2
20206: PUSH
20207: LD_INT 0
20209: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20210: LD_ADDR_VAR 0 3
20214: PUSH
20215: LD_VAR 0 1
20219: PPUSH
20220: CALL_OW 437
20224: ST_TO_ADDR
// if task then
20225: LD_VAR 0 3
20229: IFFALSE 20257
// if task [ 1 ] [ 1 ] = p then
20231: LD_VAR 0 3
20235: PUSH
20236: LD_INT 1
20238: ARRAY
20239: PUSH
20240: LD_INT 1
20242: ARRAY
20243: PUSH
20244: LD_STRING p
20246: EQUAL
20247: IFFALSE 20257
// result := true ;
20249: LD_ADDR_VAR 0 2
20253: PUSH
20254: LD_INT 1
20256: ST_TO_ADDR
// end ;
20257: LD_VAR 0 2
20261: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20262: LD_INT 0
20264: PPUSH
20265: PPUSH
20266: PPUSH
20267: PPUSH
// if pos < 1 then
20268: LD_VAR 0 2
20272: PUSH
20273: LD_INT 1
20275: LESS
20276: IFFALSE 20280
// exit ;
20278: GO 20583
// if pos = 1 then
20280: LD_VAR 0 2
20284: PUSH
20285: LD_INT 1
20287: EQUAL
20288: IFFALSE 20321
// result := Replace ( arr , pos [ 1 ] , value ) else
20290: LD_ADDR_VAR 0 4
20294: PUSH
20295: LD_VAR 0 1
20299: PPUSH
20300: LD_VAR 0 2
20304: PUSH
20305: LD_INT 1
20307: ARRAY
20308: PPUSH
20309: LD_VAR 0 3
20313: PPUSH
20314: CALL_OW 1
20318: ST_TO_ADDR
20319: GO 20583
// begin tmp := arr ;
20321: LD_ADDR_VAR 0 6
20325: PUSH
20326: LD_VAR 0 1
20330: ST_TO_ADDR
// s_arr := [ tmp ] ;
20331: LD_ADDR_VAR 0 7
20335: PUSH
20336: LD_VAR 0 6
20340: PUSH
20341: EMPTY
20342: LIST
20343: ST_TO_ADDR
// for i = 1 to pos - 1 do
20344: LD_ADDR_VAR 0 5
20348: PUSH
20349: DOUBLE
20350: LD_INT 1
20352: DEC
20353: ST_TO_ADDR
20354: LD_VAR 0 2
20358: PUSH
20359: LD_INT 1
20361: MINUS
20362: PUSH
20363: FOR_TO
20364: IFFALSE 20409
// begin tmp := tmp [ pos [ i ] ] ;
20366: LD_ADDR_VAR 0 6
20370: PUSH
20371: LD_VAR 0 6
20375: PUSH
20376: LD_VAR 0 2
20380: PUSH
20381: LD_VAR 0 5
20385: ARRAY
20386: ARRAY
20387: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20388: LD_ADDR_VAR 0 7
20392: PUSH
20393: LD_VAR 0 7
20397: PUSH
20398: LD_VAR 0 6
20402: PUSH
20403: EMPTY
20404: LIST
20405: ADD
20406: ST_TO_ADDR
// end ;
20407: GO 20363
20409: POP
20410: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20411: LD_ADDR_VAR 0 6
20415: PUSH
20416: LD_VAR 0 6
20420: PPUSH
20421: LD_VAR 0 2
20425: PUSH
20426: LD_VAR 0 2
20430: ARRAY
20431: PPUSH
20432: LD_VAR 0 3
20436: PPUSH
20437: CALL_OW 1
20441: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20442: LD_ADDR_VAR 0 7
20446: PUSH
20447: LD_VAR 0 7
20451: PPUSH
20452: LD_VAR 0 7
20456: PPUSH
20457: LD_VAR 0 6
20461: PPUSH
20462: CALL_OW 1
20466: ST_TO_ADDR
// for i = s_arr downto 2 do
20467: LD_ADDR_VAR 0 5
20471: PUSH
20472: DOUBLE
20473: LD_VAR 0 7
20477: INC
20478: ST_TO_ADDR
20479: LD_INT 2
20481: PUSH
20482: FOR_DOWNTO
20483: IFFALSE 20567
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20485: LD_ADDR_VAR 0 6
20489: PUSH
20490: LD_VAR 0 7
20494: PUSH
20495: LD_VAR 0 5
20499: PUSH
20500: LD_INT 1
20502: MINUS
20503: ARRAY
20504: PPUSH
20505: LD_VAR 0 2
20509: PUSH
20510: LD_VAR 0 5
20514: PUSH
20515: LD_INT 1
20517: MINUS
20518: ARRAY
20519: PPUSH
20520: LD_VAR 0 7
20524: PUSH
20525: LD_VAR 0 5
20529: ARRAY
20530: PPUSH
20531: CALL_OW 1
20535: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20536: LD_ADDR_VAR 0 7
20540: PUSH
20541: LD_VAR 0 7
20545: PPUSH
20546: LD_VAR 0 5
20550: PUSH
20551: LD_INT 1
20553: MINUS
20554: PPUSH
20555: LD_VAR 0 6
20559: PPUSH
20560: CALL_OW 1
20564: ST_TO_ADDR
// end ;
20565: GO 20482
20567: POP
20568: POP
// result := s_arr [ 1 ] ;
20569: LD_ADDR_VAR 0 4
20573: PUSH
20574: LD_VAR 0 7
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: ST_TO_ADDR
// end ; end ;
20583: LD_VAR 0 4
20587: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20588: LD_INT 0
20590: PPUSH
20591: PPUSH
// if not list then
20592: LD_VAR 0 1
20596: NOT
20597: IFFALSE 20601
// exit ;
20599: GO 20692
// i := list [ pos1 ] ;
20601: LD_ADDR_VAR 0 5
20605: PUSH
20606: LD_VAR 0 1
20610: PUSH
20611: LD_VAR 0 2
20615: ARRAY
20616: ST_TO_ADDR
// if not i then
20617: LD_VAR 0 5
20621: NOT
20622: IFFALSE 20626
// exit ;
20624: GO 20692
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20626: LD_ADDR_VAR 0 1
20630: PUSH
20631: LD_VAR 0 1
20635: PPUSH
20636: LD_VAR 0 2
20640: PPUSH
20641: LD_VAR 0 1
20645: PUSH
20646: LD_VAR 0 3
20650: ARRAY
20651: PPUSH
20652: CALL_OW 1
20656: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20657: LD_ADDR_VAR 0 1
20661: PUSH
20662: LD_VAR 0 1
20666: PPUSH
20667: LD_VAR 0 3
20671: PPUSH
20672: LD_VAR 0 5
20676: PPUSH
20677: CALL_OW 1
20681: ST_TO_ADDR
// result := list ;
20682: LD_ADDR_VAR 0 4
20686: PUSH
20687: LD_VAR 0 1
20691: ST_TO_ADDR
// end ;
20692: LD_VAR 0 4
20696: RET
// export function Add ( list , pos , val ) ; begin
20697: LD_INT 0
20699: PPUSH
// result := ReplaceIn ( list , pos , val ) end ;
20700: LD_ADDR_VAR 0 4
20704: PUSH
20705: LD_VAR 0 1
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: LD_VAR 0 3
20719: PPUSH
20720: CALL 20262 0 3
20724: ST_TO_ADDR
20725: LD_VAR 0 4
20729: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20730: LD_INT 0
20732: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20733: LD_ADDR_VAR 0 5
20737: PUSH
20738: LD_VAR 0 1
20742: PPUSH
20743: CALL_OW 250
20747: PPUSH
20748: LD_VAR 0 1
20752: PPUSH
20753: CALL_OW 251
20757: PPUSH
20758: LD_VAR 0 2
20762: PPUSH
20763: LD_VAR 0 3
20767: PPUSH
20768: LD_VAR 0 4
20772: PPUSH
20773: CALL 20783 0 5
20777: ST_TO_ADDR
// end ;
20778: LD_VAR 0 5
20782: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20783: LD_INT 0
20785: PPUSH
20786: PPUSH
20787: PPUSH
20788: PPUSH
// if not list then
20789: LD_VAR 0 3
20793: NOT
20794: IFFALSE 20798
// exit ;
20796: GO 21186
// result := [ ] ;
20798: LD_ADDR_VAR 0 6
20802: PUSH
20803: EMPTY
20804: ST_TO_ADDR
// for i in list do
20805: LD_ADDR_VAR 0 7
20809: PUSH
20810: LD_VAR 0 3
20814: PUSH
20815: FOR_IN
20816: IFFALSE 21018
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20818: LD_ADDR_VAR 0 9
20822: PUSH
20823: LD_VAR 0 7
20827: PPUSH
20828: LD_VAR 0 1
20832: PPUSH
20833: LD_VAR 0 2
20837: PPUSH
20838: CALL_OW 297
20842: ST_TO_ADDR
// if not result then
20843: LD_VAR 0 6
20847: NOT
20848: IFFALSE 20874
// result := [ [ i , tmp ] ] else
20850: LD_ADDR_VAR 0 6
20854: PUSH
20855: LD_VAR 0 7
20859: PUSH
20860: LD_VAR 0 9
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: PUSH
20869: EMPTY
20870: LIST
20871: ST_TO_ADDR
20872: GO 21016
// begin if result [ result ] [ 2 ] < tmp then
20874: LD_VAR 0 6
20878: PUSH
20879: LD_VAR 0 6
20883: ARRAY
20884: PUSH
20885: LD_INT 2
20887: ARRAY
20888: PUSH
20889: LD_VAR 0 9
20893: LESS
20894: IFFALSE 20936
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20896: LD_ADDR_VAR 0 6
20900: PUSH
20901: LD_VAR 0 6
20905: PPUSH
20906: LD_VAR 0 6
20910: PUSH
20911: LD_INT 1
20913: PLUS
20914: PPUSH
20915: LD_VAR 0 7
20919: PUSH
20920: LD_VAR 0 9
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PPUSH
20929: CALL_OW 2
20933: ST_TO_ADDR
20934: GO 21016
// for j = 1 to result do
20936: LD_ADDR_VAR 0 8
20940: PUSH
20941: DOUBLE
20942: LD_INT 1
20944: DEC
20945: ST_TO_ADDR
20946: LD_VAR 0 6
20950: PUSH
20951: FOR_TO
20952: IFFALSE 21014
// begin if tmp < result [ j ] [ 2 ] then
20954: LD_VAR 0 9
20958: PUSH
20959: LD_VAR 0 6
20963: PUSH
20964: LD_VAR 0 8
20968: ARRAY
20969: PUSH
20970: LD_INT 2
20972: ARRAY
20973: LESS
20974: IFFALSE 21012
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20976: LD_ADDR_VAR 0 6
20980: PUSH
20981: LD_VAR 0 6
20985: PPUSH
20986: LD_VAR 0 8
20990: PPUSH
20991: LD_VAR 0 7
20995: PUSH
20996: LD_VAR 0 9
21000: PUSH
21001: EMPTY
21002: LIST
21003: LIST
21004: PPUSH
21005: CALL_OW 2
21009: ST_TO_ADDR
// break ;
21010: GO 21014
// end ; end ;
21012: GO 20951
21014: POP
21015: POP
// end ; end ;
21016: GO 20815
21018: POP
21019: POP
// if result and not asc then
21020: LD_VAR 0 6
21024: PUSH
21025: LD_VAR 0 4
21029: NOT
21030: AND
21031: IFFALSE 21106
// begin tmp := result ;
21033: LD_ADDR_VAR 0 9
21037: PUSH
21038: LD_VAR 0 6
21042: ST_TO_ADDR
// for i = tmp downto 1 do
21043: LD_ADDR_VAR 0 7
21047: PUSH
21048: DOUBLE
21049: LD_VAR 0 9
21053: INC
21054: ST_TO_ADDR
21055: LD_INT 1
21057: PUSH
21058: FOR_DOWNTO
21059: IFFALSE 21104
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21061: LD_ADDR_VAR 0 6
21065: PUSH
21066: LD_VAR 0 6
21070: PPUSH
21071: LD_VAR 0 9
21075: PUSH
21076: LD_VAR 0 7
21080: MINUS
21081: PUSH
21082: LD_INT 1
21084: PLUS
21085: PPUSH
21086: LD_VAR 0 9
21090: PUSH
21091: LD_VAR 0 7
21095: ARRAY
21096: PPUSH
21097: CALL_OW 1
21101: ST_TO_ADDR
21102: GO 21058
21104: POP
21105: POP
// end ; tmp := [ ] ;
21106: LD_ADDR_VAR 0 9
21110: PUSH
21111: EMPTY
21112: ST_TO_ADDR
// if mode then
21113: LD_VAR 0 5
21117: IFFALSE 21186
// begin for i = 1 to result do
21119: LD_ADDR_VAR 0 7
21123: PUSH
21124: DOUBLE
21125: LD_INT 1
21127: DEC
21128: ST_TO_ADDR
21129: LD_VAR 0 6
21133: PUSH
21134: FOR_TO
21135: IFFALSE 21174
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21137: LD_ADDR_VAR 0 9
21141: PUSH
21142: LD_VAR 0 9
21146: PPUSH
21147: LD_VAR 0 7
21151: PPUSH
21152: LD_VAR 0 6
21156: PUSH
21157: LD_VAR 0 7
21161: ARRAY
21162: PUSH
21163: LD_INT 1
21165: ARRAY
21166: PPUSH
21167: CALL_OW 1
21171: ST_TO_ADDR
21172: GO 21134
21174: POP
21175: POP
// result := tmp ;
21176: LD_ADDR_VAR 0 6
21180: PUSH
21181: LD_VAR 0 9
21185: ST_TO_ADDR
// end ; end ;
21186: LD_VAR 0 6
21190: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21191: LD_INT 0
21193: PPUSH
21194: PPUSH
21195: PPUSH
21196: PPUSH
21197: PPUSH
21198: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21199: LD_ADDR_VAR 0 5
21203: PUSH
21204: LD_INT 0
21206: PUSH
21207: LD_INT 0
21209: PUSH
21210: LD_INT 0
21212: PUSH
21213: EMPTY
21214: PUSH
21215: EMPTY
21216: LIST
21217: LIST
21218: LIST
21219: LIST
21220: ST_TO_ADDR
// if not x or not y then
21221: LD_VAR 0 2
21225: NOT
21226: PUSH
21227: LD_VAR 0 3
21231: NOT
21232: OR
21233: IFFALSE 21237
// exit ;
21235: GO 22883
// if not range then
21237: LD_VAR 0 4
21241: NOT
21242: IFFALSE 21252
// range := 10 ;
21244: LD_ADDR_VAR 0 4
21248: PUSH
21249: LD_INT 10
21251: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21252: LD_ADDR_VAR 0 8
21256: PUSH
21257: LD_INT 81
21259: PUSH
21260: LD_VAR 0 1
21264: PUSH
21265: EMPTY
21266: LIST
21267: LIST
21268: PUSH
21269: LD_INT 92
21271: PUSH
21272: LD_VAR 0 2
21276: PUSH
21277: LD_VAR 0 3
21281: PUSH
21282: LD_VAR 0 4
21286: PUSH
21287: EMPTY
21288: LIST
21289: LIST
21290: LIST
21291: LIST
21292: PUSH
21293: LD_INT 3
21295: PUSH
21296: LD_INT 21
21298: PUSH
21299: LD_INT 3
21301: PUSH
21302: EMPTY
21303: LIST
21304: LIST
21305: PUSH
21306: EMPTY
21307: LIST
21308: LIST
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: LIST
21314: PPUSH
21315: CALL_OW 69
21319: ST_TO_ADDR
// if not tmp then
21320: LD_VAR 0 8
21324: NOT
21325: IFFALSE 21329
// exit ;
21327: GO 22883
// for i in tmp do
21329: LD_ADDR_VAR 0 6
21333: PUSH
21334: LD_VAR 0 8
21338: PUSH
21339: FOR_IN
21340: IFFALSE 22858
// begin points := [ 0 , 0 , 0 ] ;
21342: LD_ADDR_VAR 0 9
21346: PUSH
21347: LD_INT 0
21349: PUSH
21350: LD_INT 0
21352: PUSH
21353: LD_INT 0
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: LIST
21360: ST_TO_ADDR
// bpoints := 1 ;
21361: LD_ADDR_VAR 0 10
21365: PUSH
21366: LD_INT 1
21368: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21369: LD_VAR 0 6
21373: PPUSH
21374: CALL_OW 247
21378: PUSH
21379: LD_INT 1
21381: DOUBLE
21382: EQUAL
21383: IFTRUE 21387
21385: GO 21965
21387: POP
// begin if GetClass ( i ) = 1 then
21388: LD_VAR 0 6
21392: PPUSH
21393: CALL_OW 257
21397: PUSH
21398: LD_INT 1
21400: EQUAL
21401: IFFALSE 21422
// points := [ 10 , 5 , 3 ] ;
21403: LD_ADDR_VAR 0 9
21407: PUSH
21408: LD_INT 10
21410: PUSH
21411: LD_INT 5
21413: PUSH
21414: LD_INT 3
21416: PUSH
21417: EMPTY
21418: LIST
21419: LIST
21420: LIST
21421: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21422: LD_VAR 0 6
21426: PPUSH
21427: CALL_OW 257
21431: PUSH
21432: LD_INT 2
21434: PUSH
21435: LD_INT 3
21437: PUSH
21438: LD_INT 4
21440: PUSH
21441: EMPTY
21442: LIST
21443: LIST
21444: LIST
21445: IN
21446: IFFALSE 21467
// points := [ 3 , 2 , 1 ] ;
21448: LD_ADDR_VAR 0 9
21452: PUSH
21453: LD_INT 3
21455: PUSH
21456: LD_INT 2
21458: PUSH
21459: LD_INT 1
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: LIST
21466: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21467: LD_VAR 0 6
21471: PPUSH
21472: CALL_OW 257
21476: PUSH
21477: LD_INT 5
21479: EQUAL
21480: IFFALSE 21501
// points := [ 130 , 5 , 2 ] ;
21482: LD_ADDR_VAR 0 9
21486: PUSH
21487: LD_INT 130
21489: PUSH
21490: LD_INT 5
21492: PUSH
21493: LD_INT 2
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: LIST
21500: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 257
21510: PUSH
21511: LD_INT 8
21513: EQUAL
21514: IFFALSE 21535
// points := [ 35 , 35 , 30 ] ;
21516: LD_ADDR_VAR 0 9
21520: PUSH
21521: LD_INT 35
21523: PUSH
21524: LD_INT 35
21526: PUSH
21527: LD_INT 30
21529: PUSH
21530: EMPTY
21531: LIST
21532: LIST
21533: LIST
21534: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21535: LD_VAR 0 6
21539: PPUSH
21540: CALL_OW 257
21544: PUSH
21545: LD_INT 9
21547: EQUAL
21548: IFFALSE 21569
// points := [ 20 , 55 , 40 ] ;
21550: LD_ADDR_VAR 0 9
21554: PUSH
21555: LD_INT 20
21557: PUSH
21558: LD_INT 55
21560: PUSH
21561: LD_INT 40
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: LIST
21568: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21569: LD_VAR 0 6
21573: PPUSH
21574: CALL_OW 257
21578: PUSH
21579: LD_INT 12
21581: PUSH
21582: LD_INT 16
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: IN
21589: IFFALSE 21610
// points := [ 5 , 3 , 2 ] ;
21591: LD_ADDR_VAR 0 9
21595: PUSH
21596: LD_INT 5
21598: PUSH
21599: LD_INT 3
21601: PUSH
21602: LD_INT 2
21604: PUSH
21605: EMPTY
21606: LIST
21607: LIST
21608: LIST
21609: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21610: LD_VAR 0 6
21614: PPUSH
21615: CALL_OW 257
21619: PUSH
21620: LD_INT 17
21622: EQUAL
21623: IFFALSE 21644
// points := [ 100 , 50 , 75 ] ;
21625: LD_ADDR_VAR 0 9
21629: PUSH
21630: LD_INT 100
21632: PUSH
21633: LD_INT 50
21635: PUSH
21636: LD_INT 75
21638: PUSH
21639: EMPTY
21640: LIST
21641: LIST
21642: LIST
21643: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21644: LD_VAR 0 6
21648: PPUSH
21649: CALL_OW 257
21653: PUSH
21654: LD_INT 15
21656: EQUAL
21657: IFFALSE 21678
// points := [ 10 , 5 , 3 ] ;
21659: LD_ADDR_VAR 0 9
21663: PUSH
21664: LD_INT 10
21666: PUSH
21667: LD_INT 5
21669: PUSH
21670: LD_INT 3
21672: PUSH
21673: EMPTY
21674: LIST
21675: LIST
21676: LIST
21677: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21678: LD_VAR 0 6
21682: PPUSH
21683: CALL_OW 257
21687: PUSH
21688: LD_INT 14
21690: EQUAL
21691: IFFALSE 21712
// points := [ 10 , 0 , 0 ] ;
21693: LD_ADDR_VAR 0 9
21697: PUSH
21698: LD_INT 10
21700: PUSH
21701: LD_INT 0
21703: PUSH
21704: LD_INT 0
21706: PUSH
21707: EMPTY
21708: LIST
21709: LIST
21710: LIST
21711: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21712: LD_VAR 0 6
21716: PPUSH
21717: CALL_OW 257
21721: PUSH
21722: LD_INT 11
21724: EQUAL
21725: IFFALSE 21746
// points := [ 30 , 10 , 5 ] ;
21727: LD_ADDR_VAR 0 9
21731: PUSH
21732: LD_INT 30
21734: PUSH
21735: LD_INT 10
21737: PUSH
21738: LD_INT 5
21740: PUSH
21741: EMPTY
21742: LIST
21743: LIST
21744: LIST
21745: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21746: LD_VAR 0 1
21750: PPUSH
21751: LD_INT 5
21753: PPUSH
21754: CALL_OW 321
21758: PUSH
21759: LD_INT 2
21761: EQUAL
21762: IFFALSE 21779
// bpoints := bpoints * 1.8 ;
21764: LD_ADDR_VAR 0 10
21768: PUSH
21769: LD_VAR 0 10
21773: PUSH
21774: LD_REAL  1.80000000000000E+0000
21777: MUL
21778: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21779: LD_VAR 0 6
21783: PPUSH
21784: CALL_OW 257
21788: PUSH
21789: LD_INT 1
21791: PUSH
21792: LD_INT 2
21794: PUSH
21795: LD_INT 3
21797: PUSH
21798: LD_INT 4
21800: PUSH
21801: EMPTY
21802: LIST
21803: LIST
21804: LIST
21805: LIST
21806: IN
21807: PUSH
21808: LD_VAR 0 1
21812: PPUSH
21813: LD_INT 51
21815: PPUSH
21816: CALL_OW 321
21820: PUSH
21821: LD_INT 2
21823: EQUAL
21824: AND
21825: IFFALSE 21842
// bpoints := bpoints * 1.2 ;
21827: LD_ADDR_VAR 0 10
21831: PUSH
21832: LD_VAR 0 10
21836: PUSH
21837: LD_REAL  1.20000000000000E+0000
21840: MUL
21841: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21842: LD_VAR 0 6
21846: PPUSH
21847: CALL_OW 257
21851: PUSH
21852: LD_INT 5
21854: PUSH
21855: LD_INT 7
21857: PUSH
21858: LD_INT 9
21860: PUSH
21861: EMPTY
21862: LIST
21863: LIST
21864: LIST
21865: IN
21866: PUSH
21867: LD_VAR 0 1
21871: PPUSH
21872: LD_INT 52
21874: PPUSH
21875: CALL_OW 321
21879: PUSH
21880: LD_INT 2
21882: EQUAL
21883: AND
21884: IFFALSE 21901
// bpoints := bpoints * 1.5 ;
21886: LD_ADDR_VAR 0 10
21890: PUSH
21891: LD_VAR 0 10
21895: PUSH
21896: LD_REAL  1.50000000000000E+0000
21899: MUL
21900: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21901: LD_VAR 0 1
21905: PPUSH
21906: LD_INT 66
21908: PPUSH
21909: CALL_OW 321
21913: PUSH
21914: LD_INT 2
21916: EQUAL
21917: IFFALSE 21934
// bpoints := bpoints * 1.1 ;
21919: LD_ADDR_VAR 0 10
21923: PUSH
21924: LD_VAR 0 10
21928: PUSH
21929: LD_REAL  1.10000000000000E+0000
21932: MUL
21933: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21934: LD_ADDR_VAR 0 10
21938: PUSH
21939: LD_VAR 0 10
21943: PUSH
21944: LD_VAR 0 6
21948: PPUSH
21949: LD_INT 1
21951: PPUSH
21952: CALL_OW 259
21956: PUSH
21957: LD_REAL  1.15000000000000E+0000
21960: MUL
21961: MUL
21962: ST_TO_ADDR
// end ; unit_vehicle :
21963: GO 22787
21965: LD_INT 2
21967: DOUBLE
21968: EQUAL
21969: IFTRUE 21973
21971: GO 22775
21973: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21974: LD_VAR 0 6
21978: PPUSH
21979: CALL_OW 264
21983: PUSH
21984: LD_INT 2
21986: PUSH
21987: LD_INT 42
21989: PUSH
21990: LD_INT 24
21992: PUSH
21993: EMPTY
21994: LIST
21995: LIST
21996: LIST
21997: IN
21998: IFFALSE 22019
// points := [ 25 , 5 , 3 ] ;
22000: LD_ADDR_VAR 0 9
22004: PUSH
22005: LD_INT 25
22007: PUSH
22008: LD_INT 5
22010: PUSH
22011: LD_INT 3
22013: PUSH
22014: EMPTY
22015: LIST
22016: LIST
22017: LIST
22018: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22019: LD_VAR 0 6
22023: PPUSH
22024: CALL_OW 264
22028: PUSH
22029: LD_INT 4
22031: PUSH
22032: LD_INT 43
22034: PUSH
22035: LD_INT 25
22037: PUSH
22038: EMPTY
22039: LIST
22040: LIST
22041: LIST
22042: IN
22043: IFFALSE 22064
// points := [ 40 , 15 , 5 ] ;
22045: LD_ADDR_VAR 0 9
22049: PUSH
22050: LD_INT 40
22052: PUSH
22053: LD_INT 15
22055: PUSH
22056: LD_INT 5
22058: PUSH
22059: EMPTY
22060: LIST
22061: LIST
22062: LIST
22063: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22064: LD_VAR 0 6
22068: PPUSH
22069: CALL_OW 264
22073: PUSH
22074: LD_INT 3
22076: PUSH
22077: LD_INT 23
22079: PUSH
22080: EMPTY
22081: LIST
22082: LIST
22083: IN
22084: IFFALSE 22105
// points := [ 7 , 25 , 8 ] ;
22086: LD_ADDR_VAR 0 9
22090: PUSH
22091: LD_INT 7
22093: PUSH
22094: LD_INT 25
22096: PUSH
22097: LD_INT 8
22099: PUSH
22100: EMPTY
22101: LIST
22102: LIST
22103: LIST
22104: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22105: LD_VAR 0 6
22109: PPUSH
22110: CALL_OW 264
22114: PUSH
22115: LD_INT 5
22117: PUSH
22118: LD_INT 27
22120: PUSH
22121: LD_INT 44
22123: PUSH
22124: EMPTY
22125: LIST
22126: LIST
22127: LIST
22128: IN
22129: IFFALSE 22150
// points := [ 14 , 50 , 16 ] ;
22131: LD_ADDR_VAR 0 9
22135: PUSH
22136: LD_INT 14
22138: PUSH
22139: LD_INT 50
22141: PUSH
22142: LD_INT 16
22144: PUSH
22145: EMPTY
22146: LIST
22147: LIST
22148: LIST
22149: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22150: LD_VAR 0 6
22154: PPUSH
22155: CALL_OW 264
22159: PUSH
22160: LD_INT 6
22162: PUSH
22163: LD_INT 46
22165: PUSH
22166: EMPTY
22167: LIST
22168: LIST
22169: IN
22170: IFFALSE 22191
// points := [ 32 , 120 , 70 ] ;
22172: LD_ADDR_VAR 0 9
22176: PUSH
22177: LD_INT 32
22179: PUSH
22180: LD_INT 120
22182: PUSH
22183: LD_INT 70
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: LIST
22190: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22191: LD_VAR 0 6
22195: PPUSH
22196: CALL_OW 264
22200: PUSH
22201: LD_INT 7
22203: PUSH
22204: LD_INT 28
22206: PUSH
22207: LD_INT 45
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: LIST
22214: IN
22215: IFFALSE 22236
// points := [ 35 , 20 , 45 ] ;
22217: LD_ADDR_VAR 0 9
22221: PUSH
22222: LD_INT 35
22224: PUSH
22225: LD_INT 20
22227: PUSH
22228: LD_INT 45
22230: PUSH
22231: EMPTY
22232: LIST
22233: LIST
22234: LIST
22235: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22236: LD_VAR 0 6
22240: PPUSH
22241: CALL_OW 264
22245: PUSH
22246: LD_INT 47
22248: PUSH
22249: EMPTY
22250: LIST
22251: IN
22252: IFFALSE 22273
// points := [ 67 , 45 , 75 ] ;
22254: LD_ADDR_VAR 0 9
22258: PUSH
22259: LD_INT 67
22261: PUSH
22262: LD_INT 45
22264: PUSH
22265: LD_INT 75
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: LIST
22272: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22273: LD_VAR 0 6
22277: PPUSH
22278: CALL_OW 264
22282: PUSH
22283: LD_INT 26
22285: PUSH
22286: EMPTY
22287: LIST
22288: IN
22289: IFFALSE 22310
// points := [ 120 , 30 , 80 ] ;
22291: LD_ADDR_VAR 0 9
22295: PUSH
22296: LD_INT 120
22298: PUSH
22299: LD_INT 30
22301: PUSH
22302: LD_INT 80
22304: PUSH
22305: EMPTY
22306: LIST
22307: LIST
22308: LIST
22309: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22310: LD_VAR 0 6
22314: PPUSH
22315: CALL_OW 264
22319: PUSH
22320: LD_INT 22
22322: PUSH
22323: EMPTY
22324: LIST
22325: IN
22326: IFFALSE 22347
// points := [ 40 , 1 , 1 ] ;
22328: LD_ADDR_VAR 0 9
22332: PUSH
22333: LD_INT 40
22335: PUSH
22336: LD_INT 1
22338: PUSH
22339: LD_INT 1
22341: PUSH
22342: EMPTY
22343: LIST
22344: LIST
22345: LIST
22346: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22347: LD_VAR 0 6
22351: PPUSH
22352: CALL_OW 264
22356: PUSH
22357: LD_INT 29
22359: PUSH
22360: EMPTY
22361: LIST
22362: IN
22363: IFFALSE 22384
// points := [ 70 , 200 , 400 ] ;
22365: LD_ADDR_VAR 0 9
22369: PUSH
22370: LD_INT 70
22372: PUSH
22373: LD_INT 200
22375: PUSH
22376: LD_INT 400
22378: PUSH
22379: EMPTY
22380: LIST
22381: LIST
22382: LIST
22383: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22384: LD_VAR 0 6
22388: PPUSH
22389: CALL_OW 264
22393: PUSH
22394: LD_INT 14
22396: PUSH
22397: LD_INT 53
22399: PUSH
22400: EMPTY
22401: LIST
22402: LIST
22403: IN
22404: IFFALSE 22425
// points := [ 40 , 10 , 20 ] ;
22406: LD_ADDR_VAR 0 9
22410: PUSH
22411: LD_INT 40
22413: PUSH
22414: LD_INT 10
22416: PUSH
22417: LD_INT 20
22419: PUSH
22420: EMPTY
22421: LIST
22422: LIST
22423: LIST
22424: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22425: LD_VAR 0 6
22429: PPUSH
22430: CALL_OW 264
22434: PUSH
22435: LD_INT 9
22437: PUSH
22438: EMPTY
22439: LIST
22440: IN
22441: IFFALSE 22462
// points := [ 5 , 70 , 20 ] ;
22443: LD_ADDR_VAR 0 9
22447: PUSH
22448: LD_INT 5
22450: PUSH
22451: LD_INT 70
22453: PUSH
22454: LD_INT 20
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: LIST
22461: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22462: LD_VAR 0 6
22466: PPUSH
22467: CALL_OW 264
22471: PUSH
22472: LD_INT 10
22474: PUSH
22475: EMPTY
22476: LIST
22477: IN
22478: IFFALSE 22499
// points := [ 35 , 110 , 70 ] ;
22480: LD_ADDR_VAR 0 9
22484: PUSH
22485: LD_INT 35
22487: PUSH
22488: LD_INT 110
22490: PUSH
22491: LD_INT 70
22493: PUSH
22494: EMPTY
22495: LIST
22496: LIST
22497: LIST
22498: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22499: LD_VAR 0 6
22503: PPUSH
22504: CALL_OW 265
22508: PUSH
22509: LD_INT 25
22511: EQUAL
22512: IFFALSE 22533
// points := [ 80 , 65 , 100 ] ;
22514: LD_ADDR_VAR 0 9
22518: PUSH
22519: LD_INT 80
22521: PUSH
22522: LD_INT 65
22524: PUSH
22525: LD_INT 100
22527: PUSH
22528: EMPTY
22529: LIST
22530: LIST
22531: LIST
22532: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22533: LD_VAR 0 6
22537: PPUSH
22538: CALL_OW 263
22542: PUSH
22543: LD_INT 1
22545: EQUAL
22546: IFFALSE 22581
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22548: LD_ADDR_VAR 0 10
22552: PUSH
22553: LD_VAR 0 10
22557: PUSH
22558: LD_VAR 0 6
22562: PPUSH
22563: CALL_OW 311
22567: PPUSH
22568: LD_INT 3
22570: PPUSH
22571: CALL_OW 259
22575: PUSH
22576: LD_INT 4
22578: MUL
22579: MUL
22580: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22581: LD_VAR 0 6
22585: PPUSH
22586: CALL_OW 263
22590: PUSH
22591: LD_INT 2
22593: EQUAL
22594: IFFALSE 22645
// begin j := IsControledBy ( i ) ;
22596: LD_ADDR_VAR 0 7
22600: PUSH
22601: LD_VAR 0 6
22605: PPUSH
22606: CALL_OW 312
22610: ST_TO_ADDR
// if j then
22611: LD_VAR 0 7
22615: IFFALSE 22645
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22617: LD_ADDR_VAR 0 10
22621: PUSH
22622: LD_VAR 0 10
22626: PUSH
22627: LD_VAR 0 7
22631: PPUSH
22632: LD_INT 3
22634: PPUSH
22635: CALL_OW 259
22639: PUSH
22640: LD_INT 3
22642: MUL
22643: MUL
22644: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22645: LD_VAR 0 6
22649: PPUSH
22650: CALL_OW 264
22654: PUSH
22655: LD_INT 5
22657: PUSH
22658: LD_INT 6
22660: PUSH
22661: LD_INT 46
22663: PUSH
22664: LD_INT 44
22666: PUSH
22667: LD_INT 47
22669: PUSH
22670: LD_INT 45
22672: PUSH
22673: LD_INT 28
22675: PUSH
22676: LD_INT 7
22678: PUSH
22679: LD_INT 27
22681: PUSH
22682: LD_INT 29
22684: PUSH
22685: EMPTY
22686: LIST
22687: LIST
22688: LIST
22689: LIST
22690: LIST
22691: LIST
22692: LIST
22693: LIST
22694: LIST
22695: LIST
22696: IN
22697: PUSH
22698: LD_VAR 0 1
22702: PPUSH
22703: LD_INT 52
22705: PPUSH
22706: CALL_OW 321
22710: PUSH
22711: LD_INT 2
22713: EQUAL
22714: AND
22715: IFFALSE 22732
// bpoints := bpoints * 1.2 ;
22717: LD_ADDR_VAR 0 10
22721: PUSH
22722: LD_VAR 0 10
22726: PUSH
22727: LD_REAL  1.20000000000000E+0000
22730: MUL
22731: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22732: LD_VAR 0 6
22736: PPUSH
22737: CALL_OW 264
22741: PUSH
22742: LD_INT 6
22744: PUSH
22745: LD_INT 46
22747: PUSH
22748: LD_INT 47
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: IN
22756: IFFALSE 22773
// bpoints := bpoints * 1.2 ;
22758: LD_ADDR_VAR 0 10
22762: PUSH
22763: LD_VAR 0 10
22767: PUSH
22768: LD_REAL  1.20000000000000E+0000
22771: MUL
22772: ST_TO_ADDR
// end ; unit_building :
22773: GO 22787
22775: LD_INT 3
22777: DOUBLE
22778: EQUAL
22779: IFTRUE 22783
22781: GO 22786
22783: POP
// ; end ;
22784: GO 22787
22786: POP
// for j = 1 to 3 do
22787: LD_ADDR_VAR 0 7
22791: PUSH
22792: DOUBLE
22793: LD_INT 1
22795: DEC
22796: ST_TO_ADDR
22797: LD_INT 3
22799: PUSH
22800: FOR_TO
22801: IFFALSE 22854
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22803: LD_ADDR_VAR 0 5
22807: PUSH
22808: LD_VAR 0 5
22812: PPUSH
22813: LD_VAR 0 7
22817: PPUSH
22818: LD_VAR 0 5
22822: PUSH
22823: LD_VAR 0 7
22827: ARRAY
22828: PUSH
22829: LD_VAR 0 9
22833: PUSH
22834: LD_VAR 0 7
22838: ARRAY
22839: PUSH
22840: LD_VAR 0 10
22844: MUL
22845: PLUS
22846: PPUSH
22847: CALL_OW 1
22851: ST_TO_ADDR
22852: GO 22800
22854: POP
22855: POP
// end ;
22856: GO 21339
22858: POP
22859: POP
// result := Replace ( result , 4 , tmp ) ;
22860: LD_ADDR_VAR 0 5
22864: PUSH
22865: LD_VAR 0 5
22869: PPUSH
22870: LD_INT 4
22872: PPUSH
22873: LD_VAR 0 8
22877: PPUSH
22878: CALL_OW 1
22882: ST_TO_ADDR
// end ;
22883: LD_VAR 0 5
22887: RET
// export function DangerAtRange ( unit , range ) ; begin
22888: LD_INT 0
22890: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22891: LD_ADDR_VAR 0 3
22895: PUSH
22896: LD_VAR 0 1
22900: PPUSH
22901: CALL_OW 255
22905: PPUSH
22906: LD_VAR 0 1
22910: PPUSH
22911: CALL_OW 250
22915: PPUSH
22916: LD_VAR 0 1
22920: PPUSH
22921: CALL_OW 251
22925: PPUSH
22926: LD_VAR 0 2
22930: PPUSH
22931: CALL 21191 0 4
22935: ST_TO_ADDR
// end ;
22936: LD_VAR 0 3
22940: RET
// export function DangerInArea ( side , area ) ; begin
22941: LD_INT 0
22943: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22944: LD_ADDR_VAR 0 3
22948: PUSH
22949: LD_VAR 0 2
22953: PPUSH
22954: LD_INT 81
22956: PUSH
22957: LD_VAR 0 1
22961: PUSH
22962: EMPTY
22963: LIST
22964: LIST
22965: PPUSH
22966: CALL_OW 70
22970: ST_TO_ADDR
// end ;
22971: LD_VAR 0 3
22975: RET
// export function IsExtension ( b ) ; begin
22976: LD_INT 0
22978: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22979: LD_ADDR_VAR 0 2
22983: PUSH
22984: LD_VAR 0 1
22988: PUSH
22989: LD_INT 23
22991: PUSH
22992: LD_INT 20
22994: PUSH
22995: LD_INT 22
22997: PUSH
22998: LD_INT 17
23000: PUSH
23001: LD_INT 24
23003: PUSH
23004: LD_INT 21
23006: PUSH
23007: LD_INT 19
23009: PUSH
23010: LD_INT 16
23012: PUSH
23013: LD_INT 25
23015: PUSH
23016: LD_INT 18
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: LIST
23023: LIST
23024: LIST
23025: LIST
23026: LIST
23027: LIST
23028: LIST
23029: LIST
23030: IN
23031: ST_TO_ADDR
// end ;
23032: LD_VAR 0 2
23036: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23037: LD_INT 0
23039: PPUSH
23040: PPUSH
23041: PPUSH
// result := [ ] ;
23042: LD_ADDR_VAR 0 3
23046: PUSH
23047: EMPTY
23048: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23049: LD_ADDR_VAR 0 4
23053: PUSH
23054: LD_VAR 0 2
23058: PPUSH
23059: LD_INT 21
23061: PUSH
23062: LD_INT 3
23064: PUSH
23065: EMPTY
23066: LIST
23067: LIST
23068: PPUSH
23069: CALL_OW 70
23073: ST_TO_ADDR
// if not tmp then
23074: LD_VAR 0 4
23078: NOT
23079: IFFALSE 23083
// exit ;
23081: GO 23141
// for i in tmp do
23083: LD_ADDR_VAR 0 5
23087: PUSH
23088: LD_VAR 0 4
23092: PUSH
23093: FOR_IN
23094: IFFALSE 23129
// if GetBase ( i ) <> base then
23096: LD_VAR 0 5
23100: PPUSH
23101: CALL_OW 274
23105: PUSH
23106: LD_VAR 0 1
23110: NONEQUAL
23111: IFFALSE 23127
// ComLinkToBase ( base , i ) ;
23113: LD_VAR 0 1
23117: PPUSH
23118: LD_VAR 0 5
23122: PPUSH
23123: CALL_OW 169
23127: GO 23093
23129: POP
23130: POP
// result := tmp ;
23131: LD_ADDR_VAR 0 3
23135: PUSH
23136: LD_VAR 0 4
23140: ST_TO_ADDR
// end ;
23141: LD_VAR 0 3
23145: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23146: LD_INT 0
23148: PPUSH
23149: PPUSH
// if BuildingStatus ( b ) = bs_build then
23150: LD_VAR 0 2
23154: PPUSH
23155: CALL_OW 461
23159: PUSH
23160: LD_INT 1
23162: EQUAL
23163: IFFALSE 23223
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23165: LD_VAR 0 1
23169: PPUSH
23170: LD_STRING h
23172: PUSH
23173: LD_VAR 0 2
23177: PPUSH
23178: CALL_OW 250
23182: PUSH
23183: LD_VAR 0 2
23187: PPUSH
23188: CALL_OW 251
23192: PUSH
23193: LD_VAR 0 2
23197: PUSH
23198: LD_INT 0
23200: PUSH
23201: LD_INT 0
23203: PUSH
23204: LD_INT 0
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: LIST
23211: LIST
23212: LIST
23213: LIST
23214: LIST
23215: PUSH
23216: EMPTY
23217: LIST
23218: PPUSH
23219: CALL_OW 446
// end ;
23223: LD_VAR 0 3
23227: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23228: LD_INT 0
23230: PPUSH
23231: PPUSH
23232: PPUSH
23233: PPUSH
23234: PPUSH
23235: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23236: LD_VAR 0 1
23240: NOT
23241: PUSH
23242: LD_VAR 0 1
23246: PPUSH
23247: CALL_OW 263
23251: PUSH
23252: LD_INT 2
23254: EQUAL
23255: NOT
23256: OR
23257: IFFALSE 23261
// exit ;
23259: GO 23577
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23261: LD_ADDR_VAR 0 6
23265: PUSH
23266: LD_INT 22
23268: PUSH
23269: LD_VAR 0 1
23273: PPUSH
23274: CALL_OW 255
23278: PUSH
23279: EMPTY
23280: LIST
23281: LIST
23282: PUSH
23283: LD_INT 2
23285: PUSH
23286: LD_INT 30
23288: PUSH
23289: LD_INT 36
23291: PUSH
23292: EMPTY
23293: LIST
23294: LIST
23295: PUSH
23296: LD_INT 34
23298: PUSH
23299: LD_INT 31
23301: PUSH
23302: EMPTY
23303: LIST
23304: LIST
23305: PUSH
23306: EMPTY
23307: LIST
23308: LIST
23309: LIST
23310: PUSH
23311: EMPTY
23312: LIST
23313: LIST
23314: PPUSH
23315: CALL_OW 69
23319: ST_TO_ADDR
// if not tmp then
23320: LD_VAR 0 6
23324: NOT
23325: IFFALSE 23329
// exit ;
23327: GO 23577
// result := [ ] ;
23329: LD_ADDR_VAR 0 2
23333: PUSH
23334: EMPTY
23335: ST_TO_ADDR
// for i in tmp do
23336: LD_ADDR_VAR 0 3
23340: PUSH
23341: LD_VAR 0 6
23345: PUSH
23346: FOR_IN
23347: IFFALSE 23418
// begin t := UnitsInside ( i ) ;
23349: LD_ADDR_VAR 0 4
23353: PUSH
23354: LD_VAR 0 3
23358: PPUSH
23359: CALL_OW 313
23363: ST_TO_ADDR
// if t then
23364: LD_VAR 0 4
23368: IFFALSE 23416
// for j in t do
23370: LD_ADDR_VAR 0 7
23374: PUSH
23375: LD_VAR 0 4
23379: PUSH
23380: FOR_IN
23381: IFFALSE 23414
// result := Insert ( result , result + 1 , j ) ;
23383: LD_ADDR_VAR 0 2
23387: PUSH
23388: LD_VAR 0 2
23392: PPUSH
23393: LD_VAR 0 2
23397: PUSH
23398: LD_INT 1
23400: PLUS
23401: PPUSH
23402: LD_VAR 0 7
23406: PPUSH
23407: CALL_OW 2
23411: ST_TO_ADDR
23412: GO 23380
23414: POP
23415: POP
// end ;
23416: GO 23346
23418: POP
23419: POP
// if not result then
23420: LD_VAR 0 2
23424: NOT
23425: IFFALSE 23429
// exit ;
23427: GO 23577
// mech := result [ 1 ] ;
23429: LD_ADDR_VAR 0 5
23433: PUSH
23434: LD_VAR 0 2
23438: PUSH
23439: LD_INT 1
23441: ARRAY
23442: ST_TO_ADDR
// if result > 1 then
23443: LD_VAR 0 2
23447: PUSH
23448: LD_INT 1
23450: GREATER
23451: IFFALSE 23563
// for i = 2 to result do
23453: LD_ADDR_VAR 0 3
23457: PUSH
23458: DOUBLE
23459: LD_INT 2
23461: DEC
23462: ST_TO_ADDR
23463: LD_VAR 0 2
23467: PUSH
23468: FOR_TO
23469: IFFALSE 23561
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23471: LD_ADDR_VAR 0 4
23475: PUSH
23476: LD_VAR 0 2
23480: PUSH
23481: LD_VAR 0 3
23485: ARRAY
23486: PPUSH
23487: LD_INT 3
23489: PPUSH
23490: CALL_OW 259
23494: PUSH
23495: LD_VAR 0 2
23499: PUSH
23500: LD_VAR 0 3
23504: ARRAY
23505: PPUSH
23506: CALL_OW 432
23510: MINUS
23511: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23512: LD_VAR 0 4
23516: PUSH
23517: LD_VAR 0 5
23521: PPUSH
23522: LD_INT 3
23524: PPUSH
23525: CALL_OW 259
23529: PUSH
23530: LD_VAR 0 5
23534: PPUSH
23535: CALL_OW 432
23539: MINUS
23540: GREATEREQUAL
23541: IFFALSE 23559
// mech := result [ i ] ;
23543: LD_ADDR_VAR 0 5
23547: PUSH
23548: LD_VAR 0 2
23552: PUSH
23553: LD_VAR 0 3
23557: ARRAY
23558: ST_TO_ADDR
// end ;
23559: GO 23468
23561: POP
23562: POP
// ComLinkTo ( vehicle , mech ) ;
23563: LD_VAR 0 1
23567: PPUSH
23568: LD_VAR 0 5
23572: PPUSH
23573: CALL_OW 135
// end ;
23577: LD_VAR 0 2
23581: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23582: LD_INT 0
23584: PPUSH
23585: PPUSH
23586: PPUSH
23587: PPUSH
23588: PPUSH
23589: PPUSH
23590: PPUSH
23591: PPUSH
23592: PPUSH
23593: PPUSH
23594: PPUSH
23595: PPUSH
23596: PPUSH
// result := [ ] ;
23597: LD_ADDR_VAR 0 7
23601: PUSH
23602: EMPTY
23603: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23604: LD_VAR 0 1
23608: PPUSH
23609: CALL_OW 266
23613: PUSH
23614: LD_INT 0
23616: PUSH
23617: LD_INT 1
23619: PUSH
23620: EMPTY
23621: LIST
23622: LIST
23623: IN
23624: NOT
23625: IFFALSE 23629
// exit ;
23627: GO 25158
// if name then
23629: LD_VAR 0 3
23633: IFFALSE 23649
// SetBName ( base_dep , name ) ;
23635: LD_VAR 0 1
23639: PPUSH
23640: LD_VAR 0 3
23644: PPUSH
23645: CALL_OW 500
// base := GetBase ( base_dep ) ;
23649: LD_ADDR_VAR 0 15
23653: PUSH
23654: LD_VAR 0 1
23658: PPUSH
23659: CALL_OW 274
23663: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23664: LD_ADDR_VAR 0 16
23668: PUSH
23669: LD_VAR 0 1
23673: PPUSH
23674: CALL_OW 255
23678: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23679: LD_ADDR_VAR 0 17
23683: PUSH
23684: LD_VAR 0 1
23688: PPUSH
23689: CALL_OW 248
23693: ST_TO_ADDR
// if sources then
23694: LD_VAR 0 5
23698: IFFALSE 23745
// for i = 1 to 3 do
23700: LD_ADDR_VAR 0 8
23704: PUSH
23705: DOUBLE
23706: LD_INT 1
23708: DEC
23709: ST_TO_ADDR
23710: LD_INT 3
23712: PUSH
23713: FOR_TO
23714: IFFALSE 23743
// AddResourceType ( base , i , sources [ i ] ) ;
23716: LD_VAR 0 15
23720: PPUSH
23721: LD_VAR 0 8
23725: PPUSH
23726: LD_VAR 0 5
23730: PUSH
23731: LD_VAR 0 8
23735: ARRAY
23736: PPUSH
23737: CALL_OW 276
23741: GO 23713
23743: POP
23744: POP
// buildings := GetBaseBuildings ( base , area ) ;
23745: LD_ADDR_VAR 0 18
23749: PUSH
23750: LD_VAR 0 15
23754: PPUSH
23755: LD_VAR 0 2
23759: PPUSH
23760: CALL 23037 0 2
23764: ST_TO_ADDR
// InitHc ;
23765: CALL_OW 19
// InitUc ;
23769: CALL_OW 18
// uc_side := side ;
23773: LD_ADDR_OWVAR 20
23777: PUSH
23778: LD_VAR 0 16
23782: ST_TO_ADDR
// uc_nation := nation ;
23783: LD_ADDR_OWVAR 21
23787: PUSH
23788: LD_VAR 0 17
23792: ST_TO_ADDR
// if buildings then
23793: LD_VAR 0 18
23797: IFFALSE 25017
// begin if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23799: LD_VAR 0 18
23803: PPUSH
23804: LD_INT 2
23806: PUSH
23807: LD_INT 30
23809: PUSH
23810: LD_INT 32
23812: PUSH
23813: EMPTY
23814: LIST
23815: LIST
23816: PUSH
23817: LD_INT 30
23819: PUSH
23820: LD_INT 33
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: EMPTY
23828: LIST
23829: LIST
23830: LIST
23831: PPUSH
23832: CALL_OW 72
23836: IFFALSE 23924
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23838: LD_ADDR_VAR 0 8
23842: PUSH
23843: LD_VAR 0 18
23847: PPUSH
23848: LD_INT 2
23850: PUSH
23851: LD_INT 30
23853: PUSH
23854: LD_INT 32
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: LD_INT 30
23863: PUSH
23864: LD_INT 33
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: LIST
23875: PPUSH
23876: CALL_OW 72
23880: PUSH
23881: FOR_IN
23882: IFFALSE 23922
// begin if not GetBWeapon ( i ) then
23884: LD_VAR 0 8
23888: PPUSH
23889: CALL_OW 269
23893: NOT
23894: IFFALSE 23920
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23896: LD_VAR 0 8
23900: PPUSH
23901: LD_VAR 0 8
23905: PPUSH
23906: LD_VAR 0 2
23910: PPUSH
23911: CALL 25163 0 2
23915: PPUSH
23916: CALL_OW 431
// end ;
23920: GO 23881
23922: POP
23923: POP
// end ; for i = 1 to personel do
23924: LD_ADDR_VAR 0 8
23928: PUSH
23929: DOUBLE
23930: LD_INT 1
23932: DEC
23933: ST_TO_ADDR
23934: LD_VAR 0 6
23938: PUSH
23939: FOR_TO
23940: IFFALSE 24997
// begin if i > 4 then
23942: LD_VAR 0 8
23946: PUSH
23947: LD_INT 4
23949: GREATER
23950: IFFALSE 23954
// break ;
23952: GO 24997
// case i of 1 :
23954: LD_VAR 0 8
23958: PUSH
23959: LD_INT 1
23961: DOUBLE
23962: EQUAL
23963: IFTRUE 23967
23965: GO 24040
23967: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23968: LD_ADDR_VAR 0 12
23972: PUSH
23973: LD_VAR 0 18
23977: PPUSH
23978: LD_INT 22
23980: PUSH
23981: LD_VAR 0 16
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PUSH
23990: LD_INT 2
23992: PUSH
23993: LD_INT 30
23995: PUSH
23996: LD_INT 32
23998: PUSH
23999: EMPTY
24000: LIST
24001: LIST
24002: PUSH
24003: LD_INT 30
24005: PUSH
24006: LD_INT 4
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: PUSH
24013: LD_INT 30
24015: PUSH
24016: LD_INT 5
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: PUSH
24023: EMPTY
24024: LIST
24025: LIST
24026: LIST
24027: LIST
24028: PUSH
24029: EMPTY
24030: LIST
24031: LIST
24032: PPUSH
24033: CALL_OW 72
24037: ST_TO_ADDR
24038: GO 24262
24040: LD_INT 2
24042: DOUBLE
24043: EQUAL
24044: IFTRUE 24048
24046: GO 24110
24048: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24049: LD_ADDR_VAR 0 12
24053: PUSH
24054: LD_VAR 0 18
24058: PPUSH
24059: LD_INT 22
24061: PUSH
24062: LD_VAR 0 16
24066: PUSH
24067: EMPTY
24068: LIST
24069: LIST
24070: PUSH
24071: LD_INT 2
24073: PUSH
24074: LD_INT 30
24076: PUSH
24077: LD_INT 0
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 30
24086: PUSH
24087: LD_INT 1
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: LIST
24098: PUSH
24099: EMPTY
24100: LIST
24101: LIST
24102: PPUSH
24103: CALL_OW 72
24107: ST_TO_ADDR
24108: GO 24262
24110: LD_INT 3
24112: DOUBLE
24113: EQUAL
24114: IFTRUE 24118
24116: GO 24180
24118: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24119: LD_ADDR_VAR 0 12
24123: PUSH
24124: LD_VAR 0 18
24128: PPUSH
24129: LD_INT 22
24131: PUSH
24132: LD_VAR 0 16
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PUSH
24141: LD_INT 2
24143: PUSH
24144: LD_INT 30
24146: PUSH
24147: LD_INT 2
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: PUSH
24154: LD_INT 30
24156: PUSH
24157: LD_INT 3
24159: PUSH
24160: EMPTY
24161: LIST
24162: LIST
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: LIST
24168: PUSH
24169: EMPTY
24170: LIST
24171: LIST
24172: PPUSH
24173: CALL_OW 72
24177: ST_TO_ADDR
24178: GO 24262
24180: LD_INT 4
24182: DOUBLE
24183: EQUAL
24184: IFTRUE 24188
24186: GO 24261
24188: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24189: LD_ADDR_VAR 0 12
24193: PUSH
24194: LD_VAR 0 18
24198: PPUSH
24199: LD_INT 22
24201: PUSH
24202: LD_VAR 0 16
24206: PUSH
24207: EMPTY
24208: LIST
24209: LIST
24210: PUSH
24211: LD_INT 2
24213: PUSH
24214: LD_INT 30
24216: PUSH
24217: LD_INT 6
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: PUSH
24224: LD_INT 30
24226: PUSH
24227: LD_INT 7
24229: PUSH
24230: EMPTY
24231: LIST
24232: LIST
24233: PUSH
24234: LD_INT 30
24236: PUSH
24237: LD_INT 8
24239: PUSH
24240: EMPTY
24241: LIST
24242: LIST
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: LIST
24248: LIST
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: PPUSH
24254: CALL_OW 72
24258: ST_TO_ADDR
24259: GO 24262
24261: POP
// if i = 1 then
24262: LD_VAR 0 8
24266: PUSH
24267: LD_INT 1
24269: EQUAL
24270: IFFALSE 24381
// begin tmp := [ ] ;
24272: LD_ADDR_VAR 0 19
24276: PUSH
24277: EMPTY
24278: ST_TO_ADDR
// for j in f do
24279: LD_ADDR_VAR 0 9
24283: PUSH
24284: LD_VAR 0 12
24288: PUSH
24289: FOR_IN
24290: IFFALSE 24363
// if GetBType ( j ) = b_bunker then
24292: LD_VAR 0 9
24296: PPUSH
24297: CALL_OW 266
24301: PUSH
24302: LD_INT 32
24304: EQUAL
24305: IFFALSE 24332
// tmp := Insert ( tmp , 1 , j ) else
24307: LD_ADDR_VAR 0 19
24311: PUSH
24312: LD_VAR 0 19
24316: PPUSH
24317: LD_INT 1
24319: PPUSH
24320: LD_VAR 0 9
24324: PPUSH
24325: CALL_OW 2
24329: ST_TO_ADDR
24330: GO 24361
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24332: LD_ADDR_VAR 0 19
24336: PUSH
24337: LD_VAR 0 19
24341: PPUSH
24342: LD_VAR 0 19
24346: PUSH
24347: LD_INT 1
24349: PLUS
24350: PPUSH
24351: LD_VAR 0 9
24355: PPUSH
24356: CALL_OW 2
24360: ST_TO_ADDR
24361: GO 24289
24363: POP
24364: POP
// if tmp then
24365: LD_VAR 0 19
24369: IFFALSE 24381
// f := tmp ;
24371: LD_ADDR_VAR 0 12
24375: PUSH
24376: LD_VAR 0 19
24380: ST_TO_ADDR
// end ; x := personel [ i ] ;
24381: LD_ADDR_VAR 0 13
24385: PUSH
24386: LD_VAR 0 6
24390: PUSH
24391: LD_VAR 0 8
24395: ARRAY
24396: ST_TO_ADDR
// if x = - 1 then
24397: LD_VAR 0 13
24401: PUSH
24402: LD_INT 1
24404: NEG
24405: EQUAL
24406: IFFALSE 24615
// begin for j in f do
24408: LD_ADDR_VAR 0 9
24412: PUSH
24413: LD_VAR 0 12
24417: PUSH
24418: FOR_IN
24419: IFFALSE 24611
// repeat InitHc ;
24421: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24425: LD_VAR 0 9
24429: PPUSH
24430: CALL_OW 266
24434: PUSH
24435: LD_INT 5
24437: EQUAL
24438: IFFALSE 24508
// begin if UnitsInside ( j ) < 3 then
24440: LD_VAR 0 9
24444: PPUSH
24445: CALL_OW 313
24449: PUSH
24450: LD_INT 3
24452: LESS
24453: IFFALSE 24489
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24455: LD_INT 0
24457: PPUSH
24458: LD_INT 5
24460: PUSH
24461: LD_INT 8
24463: PUSH
24464: LD_INT 9
24466: PUSH
24467: EMPTY
24468: LIST
24469: LIST
24470: LIST
24471: PUSH
24472: LD_VAR 0 17
24476: ARRAY
24477: PPUSH
24478: LD_VAR 0 4
24482: PPUSH
24483: CALL_OW 380
24487: GO 24506
// PrepareHuman ( false , i , skill ) ;
24489: LD_INT 0
24491: PPUSH
24492: LD_VAR 0 8
24496: PPUSH
24497: LD_VAR 0 4
24501: PPUSH
24502: CALL_OW 380
// end else
24506: GO 24525
// PrepareHuman ( false , i , skill ) ;
24508: LD_INT 0
24510: PPUSH
24511: LD_VAR 0 8
24515: PPUSH
24516: LD_VAR 0 4
24520: PPUSH
24521: CALL_OW 380
// un := CreateHuman ;
24525: LD_ADDR_VAR 0 14
24529: PUSH
24530: CALL_OW 44
24534: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24535: LD_ADDR_VAR 0 7
24539: PUSH
24540: LD_VAR 0 7
24544: PPUSH
24545: LD_INT 1
24547: PPUSH
24548: LD_VAR 0 14
24552: PPUSH
24553: CALL_OW 2
24557: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24558: LD_VAR 0 14
24562: PPUSH
24563: LD_VAR 0 9
24567: PPUSH
24568: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24572: LD_VAR 0 9
24576: PPUSH
24577: CALL_OW 313
24581: PUSH
24582: LD_INT 6
24584: EQUAL
24585: PUSH
24586: LD_VAR 0 9
24590: PPUSH
24591: CALL_OW 266
24595: PUSH
24596: LD_INT 32
24598: PUSH
24599: LD_INT 31
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: IN
24606: OR
24607: IFFALSE 24421
24609: GO 24418
24611: POP
24612: POP
// end else
24613: GO 24995
// for j = 1 to x do
24615: LD_ADDR_VAR 0 9
24619: PUSH
24620: DOUBLE
24621: LD_INT 1
24623: DEC
24624: ST_TO_ADDR
24625: LD_VAR 0 13
24629: PUSH
24630: FOR_TO
24631: IFFALSE 24993
// begin InitHc ;
24633: CALL_OW 19
// if not f then
24637: LD_VAR 0 12
24641: NOT
24642: IFFALSE 24731
// begin PrepareHuman ( false , i , skill ) ;
24644: LD_INT 0
24646: PPUSH
24647: LD_VAR 0 8
24651: PPUSH
24652: LD_VAR 0 4
24656: PPUSH
24657: CALL_OW 380
// un := CreateHuman ;
24661: LD_ADDR_VAR 0 14
24665: PUSH
24666: CALL_OW 44
24670: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24671: LD_ADDR_VAR 0 7
24675: PUSH
24676: LD_VAR 0 7
24680: PPUSH
24681: LD_INT 1
24683: PPUSH
24684: LD_VAR 0 14
24688: PPUSH
24689: CALL_OW 2
24693: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24694: LD_VAR 0 14
24698: PPUSH
24699: LD_VAR 0 1
24703: PPUSH
24704: CALL_OW 250
24708: PPUSH
24709: LD_VAR 0 1
24713: PPUSH
24714: CALL_OW 251
24718: PPUSH
24719: LD_INT 10
24721: PPUSH
24722: LD_INT 0
24724: PPUSH
24725: CALL_OW 50
// continue ;
24729: GO 24630
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24731: LD_VAR 0 12
24735: PUSH
24736: LD_INT 1
24738: ARRAY
24739: PPUSH
24740: CALL_OW 313
24744: PUSH
24745: LD_VAR 0 12
24749: PUSH
24750: LD_INT 1
24752: ARRAY
24753: PPUSH
24754: CALL_OW 266
24758: PUSH
24759: LD_INT 32
24761: PUSH
24762: LD_INT 31
24764: PUSH
24765: EMPTY
24766: LIST
24767: LIST
24768: IN
24769: AND
24770: PUSH
24771: LD_VAR 0 12
24775: PUSH
24776: LD_INT 1
24778: ARRAY
24779: PPUSH
24780: CALL_OW 313
24784: PUSH
24785: LD_INT 6
24787: EQUAL
24788: OR
24789: IFFALSE 24809
// f := Delete ( f , 1 ) ;
24791: LD_ADDR_VAR 0 12
24795: PUSH
24796: LD_VAR 0 12
24800: PPUSH
24801: LD_INT 1
24803: PPUSH
24804: CALL_OW 3
24808: ST_TO_ADDR
// if not f then
24809: LD_VAR 0 12
24813: NOT
24814: IFFALSE 24832
// begin x := x + 2 ;
24816: LD_ADDR_VAR 0 13
24820: PUSH
24821: LD_VAR 0 13
24825: PUSH
24826: LD_INT 2
24828: PLUS
24829: ST_TO_ADDR
// continue ;
24830: GO 24630
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24832: LD_VAR 0 12
24836: PUSH
24837: LD_INT 1
24839: ARRAY
24840: PPUSH
24841: CALL_OW 266
24845: PUSH
24846: LD_INT 5
24848: EQUAL
24849: IFFALSE 24923
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24851: LD_VAR 0 12
24855: PUSH
24856: LD_INT 1
24858: ARRAY
24859: PPUSH
24860: CALL_OW 313
24864: PUSH
24865: LD_INT 3
24867: LESS
24868: IFFALSE 24904
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24870: LD_INT 0
24872: PPUSH
24873: LD_INT 5
24875: PUSH
24876: LD_INT 8
24878: PUSH
24879: LD_INT 9
24881: PUSH
24882: EMPTY
24883: LIST
24884: LIST
24885: LIST
24886: PUSH
24887: LD_VAR 0 17
24891: ARRAY
24892: PPUSH
24893: LD_VAR 0 4
24897: PPUSH
24898: CALL_OW 380
24902: GO 24921
// PrepareHuman ( false , i , skill ) ;
24904: LD_INT 0
24906: PPUSH
24907: LD_VAR 0 8
24911: PPUSH
24912: LD_VAR 0 4
24916: PPUSH
24917: CALL_OW 380
// end else
24921: GO 24940
// PrepareHuman ( false , i , skill ) ;
24923: LD_INT 0
24925: PPUSH
24926: LD_VAR 0 8
24930: PPUSH
24931: LD_VAR 0 4
24935: PPUSH
24936: CALL_OW 380
// un := CreateHuman ;
24940: LD_ADDR_VAR 0 14
24944: PUSH
24945: CALL_OW 44
24949: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24950: LD_ADDR_VAR 0 7
24954: PUSH
24955: LD_VAR 0 7
24959: PPUSH
24960: LD_INT 1
24962: PPUSH
24963: LD_VAR 0 14
24967: PPUSH
24968: CALL_OW 2
24972: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24973: LD_VAR 0 14
24977: PPUSH
24978: LD_VAR 0 12
24982: PUSH
24983: LD_INT 1
24985: ARRAY
24986: PPUSH
24987: CALL_OW 52
// end ;
24991: GO 24630
24993: POP
24994: POP
// end ;
24995: GO 23939
24997: POP
24998: POP
// result := result ^ buildings ;
24999: LD_ADDR_VAR 0 7
25003: PUSH
25004: LD_VAR 0 7
25008: PUSH
25009: LD_VAR 0 18
25013: ADD
25014: ST_TO_ADDR
// end else
25015: GO 25158
// begin for i = 1 to personel do
25017: LD_ADDR_VAR 0 8
25021: PUSH
25022: DOUBLE
25023: LD_INT 1
25025: DEC
25026: ST_TO_ADDR
25027: LD_VAR 0 6
25031: PUSH
25032: FOR_TO
25033: IFFALSE 25156
// begin if i > 4 then
25035: LD_VAR 0 8
25039: PUSH
25040: LD_INT 4
25042: GREATER
25043: IFFALSE 25047
// break ;
25045: GO 25156
// x := personel [ i ] ;
25047: LD_ADDR_VAR 0 13
25051: PUSH
25052: LD_VAR 0 6
25056: PUSH
25057: LD_VAR 0 8
25061: ARRAY
25062: ST_TO_ADDR
// if x = - 1 then
25063: LD_VAR 0 13
25067: PUSH
25068: LD_INT 1
25070: NEG
25071: EQUAL
25072: IFFALSE 25076
// continue ;
25074: GO 25032
// PrepareHuman ( false , i , skill ) ;
25076: LD_INT 0
25078: PPUSH
25079: LD_VAR 0 8
25083: PPUSH
25084: LD_VAR 0 4
25088: PPUSH
25089: CALL_OW 380
// un := CreateHuman ;
25093: LD_ADDR_VAR 0 14
25097: PUSH
25098: CALL_OW 44
25102: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25103: LD_VAR 0 14
25107: PPUSH
25108: LD_VAR 0 1
25112: PPUSH
25113: CALL_OW 250
25117: PPUSH
25118: LD_VAR 0 1
25122: PPUSH
25123: CALL_OW 251
25127: PPUSH
25128: LD_INT 10
25130: PPUSH
25131: LD_INT 0
25133: PPUSH
25134: CALL_OW 50
// result := result ^ un ;
25138: LD_ADDR_VAR 0 7
25142: PUSH
25143: LD_VAR 0 7
25147: PUSH
25148: LD_VAR 0 14
25152: ADD
25153: ST_TO_ADDR
// end ;
25154: GO 25032
25156: POP
25157: POP
// end ; end ;
25158: LD_VAR 0 7
25162: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25163: LD_INT 0
25165: PPUSH
25166: PPUSH
25167: PPUSH
25168: PPUSH
25169: PPUSH
25170: PPUSH
25171: PPUSH
25172: PPUSH
25173: PPUSH
25174: PPUSH
25175: PPUSH
25176: PPUSH
25177: PPUSH
25178: PPUSH
25179: PPUSH
25180: PPUSH
// result := false ;
25181: LD_ADDR_VAR 0 3
25185: PUSH
25186: LD_INT 0
25188: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25189: LD_VAR 0 1
25193: NOT
25194: PUSH
25195: LD_VAR 0 1
25199: PPUSH
25200: CALL_OW 266
25204: PUSH
25205: LD_INT 32
25207: PUSH
25208: LD_INT 33
25210: PUSH
25211: EMPTY
25212: LIST
25213: LIST
25214: IN
25215: NOT
25216: OR
25217: IFFALSE 25221
// exit ;
25219: GO 26357
// nat := GetNation ( tower ) ;
25221: LD_ADDR_VAR 0 12
25225: PUSH
25226: LD_VAR 0 1
25230: PPUSH
25231: CALL_OW 248
25235: ST_TO_ADDR
// side := GetSide ( tower ) ;
25236: LD_ADDR_VAR 0 16
25240: PUSH
25241: LD_VAR 0 1
25245: PPUSH
25246: CALL_OW 255
25250: ST_TO_ADDR
// x := GetX ( tower ) ;
25251: LD_ADDR_VAR 0 10
25255: PUSH
25256: LD_VAR 0 1
25260: PPUSH
25261: CALL_OW 250
25265: ST_TO_ADDR
// y := GetY ( tower ) ;
25266: LD_ADDR_VAR 0 11
25270: PUSH
25271: LD_VAR 0 1
25275: PPUSH
25276: CALL_OW 251
25280: ST_TO_ADDR
// if not x or not y then
25281: LD_VAR 0 10
25285: NOT
25286: PUSH
25287: LD_VAR 0 11
25291: NOT
25292: OR
25293: IFFALSE 25297
// exit ;
25295: GO 26357
// weapon := 0 ;
25297: LD_ADDR_VAR 0 18
25301: PUSH
25302: LD_INT 0
25304: ST_TO_ADDR
// fac_list := [ ] ;
25305: LD_ADDR_VAR 0 17
25309: PUSH
25310: EMPTY
25311: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25312: LD_ADDR_VAR 0 6
25316: PUSH
25317: LD_VAR 0 1
25321: PPUSH
25322: CALL_OW 274
25326: PPUSH
25327: LD_VAR 0 2
25331: PPUSH
25332: CALL 23037 0 2
25336: PPUSH
25337: LD_INT 30
25339: PUSH
25340: LD_INT 3
25342: PUSH
25343: EMPTY
25344: LIST
25345: LIST
25346: PPUSH
25347: CALL_OW 72
25351: ST_TO_ADDR
// if not factories then
25352: LD_VAR 0 6
25356: NOT
25357: IFFALSE 25361
// exit ;
25359: GO 26357
// for i in factories do
25361: LD_ADDR_VAR 0 8
25365: PUSH
25366: LD_VAR 0 6
25370: PUSH
25371: FOR_IN
25372: IFFALSE 25397
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25374: LD_ADDR_VAR 0 17
25378: PUSH
25379: LD_VAR 0 17
25383: PUSH
25384: LD_VAR 0 8
25388: PPUSH
25389: CALL_OW 478
25393: UNION
25394: ST_TO_ADDR
25395: GO 25371
25397: POP
25398: POP
// if not fac_list then
25399: LD_VAR 0 17
25403: NOT
25404: IFFALSE 25408
// exit ;
25406: GO 26357
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25408: LD_ADDR_VAR 0 5
25412: PUSH
25413: LD_INT 4
25415: PUSH
25416: LD_INT 5
25418: PUSH
25419: LD_INT 9
25421: PUSH
25422: LD_INT 10
25424: PUSH
25425: LD_INT 6
25427: PUSH
25428: LD_INT 7
25430: PUSH
25431: LD_INT 11
25433: PUSH
25434: EMPTY
25435: LIST
25436: LIST
25437: LIST
25438: LIST
25439: LIST
25440: LIST
25441: LIST
25442: PUSH
25443: LD_INT 27
25445: PUSH
25446: LD_INT 28
25448: PUSH
25449: LD_INT 26
25451: PUSH
25452: LD_INT 30
25454: PUSH
25455: EMPTY
25456: LIST
25457: LIST
25458: LIST
25459: LIST
25460: PUSH
25461: LD_INT 43
25463: PUSH
25464: LD_INT 44
25466: PUSH
25467: LD_INT 46
25469: PUSH
25470: LD_INT 45
25472: PUSH
25473: LD_INT 47
25475: PUSH
25476: LD_INT 49
25478: PUSH
25479: EMPTY
25480: LIST
25481: LIST
25482: LIST
25483: LIST
25484: LIST
25485: LIST
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: LIST
25491: PUSH
25492: LD_VAR 0 12
25496: ARRAY
25497: ST_TO_ADDR
// for i in list do
25498: LD_ADDR_VAR 0 8
25502: PUSH
25503: LD_VAR 0 5
25507: PUSH
25508: FOR_IN
25509: IFFALSE 25542
// if not i in fac_list then
25511: LD_VAR 0 8
25515: PUSH
25516: LD_VAR 0 17
25520: IN
25521: NOT
25522: IFFALSE 25540
// list := list diff i ;
25524: LD_ADDR_VAR 0 5
25528: PUSH
25529: LD_VAR 0 5
25533: PUSH
25534: LD_VAR 0 8
25538: DIFF
25539: ST_TO_ADDR
25540: GO 25508
25542: POP
25543: POP
// if not list then
25544: LD_VAR 0 5
25548: NOT
25549: IFFALSE 25553
// exit ;
25551: GO 26357
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25553: LD_VAR 0 12
25557: PUSH
25558: LD_INT 3
25560: EQUAL
25561: PUSH
25562: LD_INT 49
25564: PUSH
25565: LD_VAR 0 5
25569: IN
25570: AND
25571: PUSH
25572: LD_INT 31
25574: PPUSH
25575: LD_VAR 0 16
25579: PPUSH
25580: CALL_OW 321
25584: PUSH
25585: LD_INT 2
25587: EQUAL
25588: AND
25589: IFFALSE 25649
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25591: LD_INT 22
25593: PUSH
25594: LD_VAR 0 16
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: LD_INT 35
25605: PUSH
25606: LD_INT 49
25608: PUSH
25609: EMPTY
25610: LIST
25611: LIST
25612: PUSH
25613: LD_INT 91
25615: PUSH
25616: LD_VAR 0 1
25620: PUSH
25621: LD_INT 10
25623: PUSH
25624: EMPTY
25625: LIST
25626: LIST
25627: LIST
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: LIST
25633: PPUSH
25634: CALL_OW 69
25638: NOT
25639: IFFALSE 25649
// weapon := ru_time_lapser ;
25641: LD_ADDR_VAR 0 18
25645: PUSH
25646: LD_INT 49
25648: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25649: LD_VAR 0 12
25653: PUSH
25654: LD_INT 1
25656: PUSH
25657: LD_INT 2
25659: PUSH
25660: EMPTY
25661: LIST
25662: LIST
25663: IN
25664: PUSH
25665: LD_INT 11
25667: PUSH
25668: LD_VAR 0 5
25672: IN
25673: PUSH
25674: LD_INT 30
25676: PUSH
25677: LD_VAR 0 5
25681: IN
25682: OR
25683: AND
25684: PUSH
25685: LD_INT 6
25687: PPUSH
25688: LD_VAR 0 16
25692: PPUSH
25693: CALL_OW 321
25697: PUSH
25698: LD_INT 2
25700: EQUAL
25701: AND
25702: IFFALSE 25867
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25704: LD_INT 22
25706: PUSH
25707: LD_VAR 0 16
25711: PUSH
25712: EMPTY
25713: LIST
25714: LIST
25715: PUSH
25716: LD_INT 2
25718: PUSH
25719: LD_INT 35
25721: PUSH
25722: LD_INT 11
25724: PUSH
25725: EMPTY
25726: LIST
25727: LIST
25728: PUSH
25729: LD_INT 35
25731: PUSH
25732: LD_INT 30
25734: PUSH
25735: EMPTY
25736: LIST
25737: LIST
25738: PUSH
25739: EMPTY
25740: LIST
25741: LIST
25742: LIST
25743: PUSH
25744: LD_INT 91
25746: PUSH
25747: LD_VAR 0 1
25751: PUSH
25752: LD_INT 18
25754: PUSH
25755: EMPTY
25756: LIST
25757: LIST
25758: LIST
25759: PUSH
25760: EMPTY
25761: LIST
25762: LIST
25763: LIST
25764: PPUSH
25765: CALL_OW 69
25769: NOT
25770: PUSH
25771: LD_INT 22
25773: PUSH
25774: LD_VAR 0 16
25778: PUSH
25779: EMPTY
25780: LIST
25781: LIST
25782: PUSH
25783: LD_INT 2
25785: PUSH
25786: LD_INT 30
25788: PUSH
25789: LD_INT 32
25791: PUSH
25792: EMPTY
25793: LIST
25794: LIST
25795: PUSH
25796: LD_INT 30
25798: PUSH
25799: LD_INT 33
25801: PUSH
25802: EMPTY
25803: LIST
25804: LIST
25805: PUSH
25806: EMPTY
25807: LIST
25808: LIST
25809: LIST
25810: PUSH
25811: LD_INT 91
25813: PUSH
25814: LD_VAR 0 1
25818: PUSH
25819: LD_INT 12
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: LIST
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: LIST
25831: PUSH
25832: EMPTY
25833: LIST
25834: PPUSH
25835: CALL_OW 69
25839: PUSH
25840: LD_INT 2
25842: GREATER
25843: AND
25844: IFFALSE 25867
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25846: LD_ADDR_VAR 0 18
25850: PUSH
25851: LD_INT 11
25853: PUSH
25854: LD_INT 30
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: PUSH
25861: LD_VAR 0 12
25865: ARRAY
25866: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25867: LD_VAR 0 18
25871: NOT
25872: PUSH
25873: LD_INT 40
25875: PPUSH
25876: LD_VAR 0 16
25880: PPUSH
25881: CALL_OW 321
25885: PUSH
25886: LD_INT 2
25888: EQUAL
25889: AND
25890: PUSH
25891: LD_INT 7
25893: PUSH
25894: LD_VAR 0 5
25898: IN
25899: PUSH
25900: LD_INT 28
25902: PUSH
25903: LD_VAR 0 5
25907: IN
25908: OR
25909: PUSH
25910: LD_INT 45
25912: PUSH
25913: LD_VAR 0 5
25917: IN
25918: OR
25919: AND
25920: IFFALSE 26174
// begin hex := GetHexInfo ( x , y ) ;
25922: LD_ADDR_VAR 0 4
25926: PUSH
25927: LD_VAR 0 10
25931: PPUSH
25932: LD_VAR 0 11
25936: PPUSH
25937: CALL_OW 546
25941: ST_TO_ADDR
// if hex [ 1 ] then
25942: LD_VAR 0 4
25946: PUSH
25947: LD_INT 1
25949: ARRAY
25950: IFFALSE 25954
// exit ;
25952: GO 26357
// height := hex [ 2 ] ;
25954: LD_ADDR_VAR 0 15
25958: PUSH
25959: LD_VAR 0 4
25963: PUSH
25964: LD_INT 2
25966: ARRAY
25967: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25968: LD_ADDR_VAR 0 14
25972: PUSH
25973: LD_INT 0
25975: PUSH
25976: LD_INT 2
25978: PUSH
25979: LD_INT 3
25981: PUSH
25982: LD_INT 5
25984: PUSH
25985: EMPTY
25986: LIST
25987: LIST
25988: LIST
25989: LIST
25990: ST_TO_ADDR
// for i in tmp do
25991: LD_ADDR_VAR 0 8
25995: PUSH
25996: LD_VAR 0 14
26000: PUSH
26001: FOR_IN
26002: IFFALSE 26172
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26004: LD_ADDR_VAR 0 9
26008: PUSH
26009: LD_VAR 0 10
26013: PPUSH
26014: LD_VAR 0 8
26018: PPUSH
26019: LD_INT 5
26021: PPUSH
26022: CALL_OW 272
26026: PUSH
26027: LD_VAR 0 11
26031: PPUSH
26032: LD_VAR 0 8
26036: PPUSH
26037: LD_INT 5
26039: PPUSH
26040: CALL_OW 273
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26049: LD_VAR 0 9
26053: PUSH
26054: LD_INT 1
26056: ARRAY
26057: PPUSH
26058: LD_VAR 0 9
26062: PUSH
26063: LD_INT 2
26065: ARRAY
26066: PPUSH
26067: CALL_OW 488
26071: IFFALSE 26170
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26073: LD_ADDR_VAR 0 4
26077: PUSH
26078: LD_VAR 0 9
26082: PUSH
26083: LD_INT 1
26085: ARRAY
26086: PPUSH
26087: LD_VAR 0 9
26091: PUSH
26092: LD_INT 2
26094: ARRAY
26095: PPUSH
26096: CALL_OW 546
26100: ST_TO_ADDR
// if hex [ 1 ] then
26101: LD_VAR 0 4
26105: PUSH
26106: LD_INT 1
26108: ARRAY
26109: IFFALSE 26113
// continue ;
26111: GO 26001
// h := hex [ 2 ] ;
26113: LD_ADDR_VAR 0 13
26117: PUSH
26118: LD_VAR 0 4
26122: PUSH
26123: LD_INT 2
26125: ARRAY
26126: ST_TO_ADDR
// if h + 7 < height then
26127: LD_VAR 0 13
26131: PUSH
26132: LD_INT 7
26134: PLUS
26135: PUSH
26136: LD_VAR 0 15
26140: LESS
26141: IFFALSE 26170
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26143: LD_ADDR_VAR 0 18
26147: PUSH
26148: LD_INT 7
26150: PUSH
26151: LD_INT 28
26153: PUSH
26154: LD_INT 45
26156: PUSH
26157: EMPTY
26158: LIST
26159: LIST
26160: LIST
26161: PUSH
26162: LD_VAR 0 12
26166: ARRAY
26167: ST_TO_ADDR
// break ;
26168: GO 26172
// end ; end ; end ;
26170: GO 26001
26172: POP
26173: POP
// end ; if not weapon then
26174: LD_VAR 0 18
26178: NOT
26179: IFFALSE 26239
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26181: LD_ADDR_VAR 0 5
26185: PUSH
26186: LD_VAR 0 5
26190: PUSH
26191: LD_INT 11
26193: PUSH
26194: LD_INT 30
26196: PUSH
26197: LD_INT 49
26199: PUSH
26200: EMPTY
26201: LIST
26202: LIST
26203: LIST
26204: DIFF
26205: ST_TO_ADDR
// if not list then
26206: LD_VAR 0 5
26210: NOT
26211: IFFALSE 26215
// exit ;
26213: GO 26357
// weapon := list [ rand ( 1 , list ) ] ;
26215: LD_ADDR_VAR 0 18
26219: PUSH
26220: LD_VAR 0 5
26224: PUSH
26225: LD_INT 1
26227: PPUSH
26228: LD_VAR 0 5
26232: PPUSH
26233: CALL_OW 12
26237: ARRAY
26238: ST_TO_ADDR
// end ; if weapon then
26239: LD_VAR 0 18
26243: IFFALSE 26357
// begin tmp := CostOfWeapon ( weapon ) ;
26245: LD_ADDR_VAR 0 14
26249: PUSH
26250: LD_VAR 0 18
26254: PPUSH
26255: CALL_OW 451
26259: ST_TO_ADDR
// j := GetBase ( tower ) ;
26260: LD_ADDR_VAR 0 9
26264: PUSH
26265: LD_VAR 0 1
26269: PPUSH
26270: CALL_OW 274
26274: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26275: LD_VAR 0 9
26279: PPUSH
26280: LD_INT 1
26282: PPUSH
26283: CALL_OW 275
26287: PUSH
26288: LD_VAR 0 14
26292: PUSH
26293: LD_INT 1
26295: ARRAY
26296: GREATEREQUAL
26297: PUSH
26298: LD_VAR 0 9
26302: PPUSH
26303: LD_INT 2
26305: PPUSH
26306: CALL_OW 275
26310: PUSH
26311: LD_VAR 0 14
26315: PUSH
26316: LD_INT 2
26318: ARRAY
26319: GREATEREQUAL
26320: AND
26321: PUSH
26322: LD_VAR 0 9
26326: PPUSH
26327: LD_INT 3
26329: PPUSH
26330: CALL_OW 275
26334: PUSH
26335: LD_VAR 0 14
26339: PUSH
26340: LD_INT 3
26342: ARRAY
26343: GREATEREQUAL
26344: AND
26345: IFFALSE 26357
// result := weapon ;
26347: LD_ADDR_VAR 0 3
26351: PUSH
26352: LD_VAR 0 18
26356: ST_TO_ADDR
// end ; end ;
26357: LD_VAR 0 3
26361: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26362: LD_INT 0
26364: PPUSH
26365: PPUSH
// result := true ;
26366: LD_ADDR_VAR 0 3
26370: PUSH
26371: LD_INT 1
26373: ST_TO_ADDR
// if array1 = array2 then
26374: LD_VAR 0 1
26378: PUSH
26379: LD_VAR 0 2
26383: EQUAL
26384: IFFALSE 26444
// begin for i = 1 to array1 do
26386: LD_ADDR_VAR 0 4
26390: PUSH
26391: DOUBLE
26392: LD_INT 1
26394: DEC
26395: ST_TO_ADDR
26396: LD_VAR 0 1
26400: PUSH
26401: FOR_TO
26402: IFFALSE 26440
// if array1 [ i ] <> array2 [ i ] then
26404: LD_VAR 0 1
26408: PUSH
26409: LD_VAR 0 4
26413: ARRAY
26414: PUSH
26415: LD_VAR 0 2
26419: PUSH
26420: LD_VAR 0 4
26424: ARRAY
26425: NONEQUAL
26426: IFFALSE 26438
// begin result := false ;
26428: LD_ADDR_VAR 0 3
26432: PUSH
26433: LD_INT 0
26435: ST_TO_ADDR
// break ;
26436: GO 26440
// end ;
26438: GO 26401
26440: POP
26441: POP
// end else
26442: GO 26452
// result := false ;
26444: LD_ADDR_VAR 0 3
26448: PUSH
26449: LD_INT 0
26451: ST_TO_ADDR
// end ;
26452: LD_VAR 0 3
26456: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26457: LD_INT 0
26459: PPUSH
26460: PPUSH
26461: PPUSH
// pom := GetBase ( fac ) ;
26462: LD_ADDR_VAR 0 5
26466: PUSH
26467: LD_VAR 0 1
26471: PPUSH
26472: CALL_OW 274
26476: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26477: LD_ADDR_VAR 0 4
26481: PUSH
26482: LD_VAR 0 2
26486: PUSH
26487: LD_INT 1
26489: ARRAY
26490: PPUSH
26491: LD_VAR 0 2
26495: PUSH
26496: LD_INT 2
26498: ARRAY
26499: PPUSH
26500: LD_VAR 0 2
26504: PUSH
26505: LD_INT 3
26507: ARRAY
26508: PPUSH
26509: LD_VAR 0 2
26513: PUSH
26514: LD_INT 4
26516: ARRAY
26517: PPUSH
26518: CALL_OW 449
26522: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26523: LD_ADDR_VAR 0 3
26527: PUSH
26528: LD_VAR 0 5
26532: PPUSH
26533: LD_INT 1
26535: PPUSH
26536: CALL_OW 275
26540: PUSH
26541: LD_VAR 0 4
26545: PUSH
26546: LD_INT 1
26548: ARRAY
26549: GREATEREQUAL
26550: PUSH
26551: LD_VAR 0 5
26555: PPUSH
26556: LD_INT 2
26558: PPUSH
26559: CALL_OW 275
26563: PUSH
26564: LD_VAR 0 4
26568: PUSH
26569: LD_INT 2
26571: ARRAY
26572: GREATEREQUAL
26573: AND
26574: PUSH
26575: LD_VAR 0 5
26579: PPUSH
26580: LD_INT 3
26582: PPUSH
26583: CALL_OW 275
26587: PUSH
26588: LD_VAR 0 4
26592: PUSH
26593: LD_INT 3
26595: ARRAY
26596: GREATEREQUAL
26597: AND
26598: ST_TO_ADDR
// end ;
26599: LD_VAR 0 3
26603: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26604: LD_INT 0
26606: PPUSH
26607: PPUSH
26608: PPUSH
26609: PPUSH
// pom := GetBase ( building ) ;
26610: LD_ADDR_VAR 0 3
26614: PUSH
26615: LD_VAR 0 1
26619: PPUSH
26620: CALL_OW 274
26624: ST_TO_ADDR
// if not pom then
26625: LD_VAR 0 3
26629: NOT
26630: IFFALSE 26634
// exit ;
26632: GO 26804
// btype := GetBType ( building ) ;
26634: LD_ADDR_VAR 0 5
26638: PUSH
26639: LD_VAR 0 1
26643: PPUSH
26644: CALL_OW 266
26648: ST_TO_ADDR
// if btype = b_armoury then
26649: LD_VAR 0 5
26653: PUSH
26654: LD_INT 4
26656: EQUAL
26657: IFFALSE 26667
// btype := b_barracks ;
26659: LD_ADDR_VAR 0 5
26663: PUSH
26664: LD_INT 5
26666: ST_TO_ADDR
// if btype = b_depot then
26667: LD_VAR 0 5
26671: PUSH
26672: LD_INT 0
26674: EQUAL
26675: IFFALSE 26685
// btype := b_warehouse ;
26677: LD_ADDR_VAR 0 5
26681: PUSH
26682: LD_INT 1
26684: ST_TO_ADDR
// if btype = b_workshop then
26685: LD_VAR 0 5
26689: PUSH
26690: LD_INT 2
26692: EQUAL
26693: IFFALSE 26703
// btype := b_factory ;
26695: LD_ADDR_VAR 0 5
26699: PUSH
26700: LD_INT 3
26702: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26703: LD_ADDR_VAR 0 4
26707: PUSH
26708: LD_VAR 0 5
26712: PPUSH
26713: LD_VAR 0 1
26717: PPUSH
26718: CALL_OW 248
26722: PPUSH
26723: CALL_OW 450
26727: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26728: LD_ADDR_VAR 0 2
26732: PUSH
26733: LD_VAR 0 3
26737: PPUSH
26738: LD_INT 1
26740: PPUSH
26741: CALL_OW 275
26745: PUSH
26746: LD_VAR 0 4
26750: PUSH
26751: LD_INT 1
26753: ARRAY
26754: GREATEREQUAL
26755: PUSH
26756: LD_VAR 0 3
26760: PPUSH
26761: LD_INT 2
26763: PPUSH
26764: CALL_OW 275
26768: PUSH
26769: LD_VAR 0 4
26773: PUSH
26774: LD_INT 2
26776: ARRAY
26777: GREATEREQUAL
26778: AND
26779: PUSH
26780: LD_VAR 0 3
26784: PPUSH
26785: LD_INT 3
26787: PPUSH
26788: CALL_OW 275
26792: PUSH
26793: LD_VAR 0 4
26797: PUSH
26798: LD_INT 3
26800: ARRAY
26801: GREATEREQUAL
26802: AND
26803: ST_TO_ADDR
// end ;
26804: LD_VAR 0 2
26808: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26809: LD_INT 0
26811: PPUSH
26812: PPUSH
26813: PPUSH
// pom := GetBase ( building ) ;
26814: LD_ADDR_VAR 0 4
26818: PUSH
26819: LD_VAR 0 1
26823: PPUSH
26824: CALL_OW 274
26828: ST_TO_ADDR
// if not pom then
26829: LD_VAR 0 4
26833: NOT
26834: IFFALSE 26838
// exit ;
26836: GO 26939
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26838: LD_ADDR_VAR 0 5
26842: PUSH
26843: LD_VAR 0 2
26847: PPUSH
26848: LD_VAR 0 1
26852: PPUSH
26853: CALL_OW 248
26857: PPUSH
26858: CALL_OW 450
26862: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26863: LD_ADDR_VAR 0 3
26867: PUSH
26868: LD_VAR 0 4
26872: PPUSH
26873: LD_INT 1
26875: PPUSH
26876: CALL_OW 275
26880: PUSH
26881: LD_VAR 0 5
26885: PUSH
26886: LD_INT 1
26888: ARRAY
26889: GREATEREQUAL
26890: PUSH
26891: LD_VAR 0 4
26895: PPUSH
26896: LD_INT 2
26898: PPUSH
26899: CALL_OW 275
26903: PUSH
26904: LD_VAR 0 5
26908: PUSH
26909: LD_INT 2
26911: ARRAY
26912: GREATEREQUAL
26913: AND
26914: PUSH
26915: LD_VAR 0 4
26919: PPUSH
26920: LD_INT 3
26922: PPUSH
26923: CALL_OW 275
26927: PUSH
26928: LD_VAR 0 5
26932: PUSH
26933: LD_INT 3
26935: ARRAY
26936: GREATEREQUAL
26937: AND
26938: ST_TO_ADDR
// end ;
26939: LD_VAR 0 3
26943: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
26944: LD_INT 0
26946: PPUSH
26947: PPUSH
26948: PPUSH
26949: PPUSH
26950: PPUSH
26951: PPUSH
26952: PPUSH
26953: PPUSH
26954: PPUSH
26955: PPUSH
// result := false ;
26956: LD_ADDR_VAR 0 6
26960: PUSH
26961: LD_INT 0
26963: ST_TO_ADDR
// if not base or not btype or not x or not y then
26964: LD_VAR 0 1
26968: NOT
26969: PUSH
26970: LD_VAR 0 2
26974: NOT
26975: OR
26976: PUSH
26977: LD_VAR 0 3
26981: NOT
26982: OR
26983: PUSH
26984: LD_VAR 0 4
26988: NOT
26989: OR
26990: IFFALSE 26994
// exit ;
26992: GO 27508
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26994: LD_ADDR_VAR 0 12
26998: PUSH
26999: LD_VAR 0 2
27003: PPUSH
27004: LD_VAR 0 3
27008: PPUSH
27009: LD_VAR 0 4
27013: PPUSH
27014: LD_VAR 0 5
27018: PPUSH
27019: LD_VAR 0 1
27023: PUSH
27024: LD_INT 1
27026: ARRAY
27027: PPUSH
27028: CALL_OW 248
27032: PPUSH
27033: LD_INT 0
27035: PPUSH
27036: CALL 28337 0 6
27040: ST_TO_ADDR
// if not hexes then
27041: LD_VAR 0 12
27045: NOT
27046: IFFALSE 27050
// exit ;
27048: GO 27508
// for i = 1 to hexes do
27050: LD_ADDR_VAR 0 7
27054: PUSH
27055: DOUBLE
27056: LD_INT 1
27058: DEC
27059: ST_TO_ADDR
27060: LD_VAR 0 12
27064: PUSH
27065: FOR_TO
27066: IFFALSE 27506
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27068: LD_ADDR_VAR 0 11
27072: PUSH
27073: LD_VAR 0 12
27077: PUSH
27078: LD_VAR 0 7
27082: ARRAY
27083: PUSH
27084: LD_INT 1
27086: ARRAY
27087: PPUSH
27088: LD_VAR 0 12
27092: PUSH
27093: LD_VAR 0 7
27097: ARRAY
27098: PUSH
27099: LD_INT 2
27101: ARRAY
27102: PPUSH
27103: CALL_OW 428
27107: ST_TO_ADDR
// if not tmp or GetType ( tmp ) = unit_building then
27108: LD_VAR 0 11
27112: NOT
27113: PUSH
27114: LD_VAR 0 11
27118: PPUSH
27119: CALL_OW 247
27123: PUSH
27124: LD_INT 3
27126: EQUAL
27127: OR
27128: IFFALSE 27132
// continue ;
27130: GO 27065
// result := true ;
27132: LD_ADDR_VAR 0 6
27136: PUSH
27137: LD_INT 1
27139: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27140: LD_ADDR_VAR 0 15
27144: PUSH
27145: LD_INT 22
27147: PUSH
27148: LD_VAR 0 11
27152: PPUSH
27153: CALL_OW 255
27157: PUSH
27158: EMPTY
27159: LIST
27160: LIST
27161: PUSH
27162: LD_INT 2
27164: PUSH
27165: LD_INT 30
27167: PUSH
27168: LD_INT 0
27170: PUSH
27171: EMPTY
27172: LIST
27173: LIST
27174: PUSH
27175: LD_INT 30
27177: PUSH
27178: LD_INT 1
27180: PUSH
27181: EMPTY
27182: LIST
27183: LIST
27184: PUSH
27185: EMPTY
27186: LIST
27187: LIST
27188: LIST
27189: PUSH
27190: EMPTY
27191: LIST
27192: LIST
27193: PPUSH
27194: CALL_OW 69
27198: ST_TO_ADDR
// if dep then
27199: LD_VAR 0 15
27203: IFFALSE 27339
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27205: LD_ADDR_VAR 0 14
27209: PUSH
27210: LD_VAR 0 15
27214: PUSH
27215: LD_INT 1
27217: ARRAY
27218: PPUSH
27219: CALL_OW 250
27223: PPUSH
27224: LD_VAR 0 15
27228: PUSH
27229: LD_INT 1
27231: ARRAY
27232: PPUSH
27233: CALL_OW 254
27237: PPUSH
27238: LD_INT 5
27240: PPUSH
27241: CALL_OW 272
27245: PUSH
27246: LD_VAR 0 15
27250: PUSH
27251: LD_INT 1
27253: ARRAY
27254: PPUSH
27255: CALL_OW 251
27259: PPUSH
27260: LD_VAR 0 15
27264: PUSH
27265: LD_INT 1
27267: ARRAY
27268: PPUSH
27269: CALL_OW 254
27273: PPUSH
27274: LD_INT 5
27276: PPUSH
27277: CALL_OW 273
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27286: LD_VAR 0 14
27290: PUSH
27291: LD_INT 1
27293: ARRAY
27294: PPUSH
27295: LD_VAR 0 14
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: PPUSH
27304: CALL_OW 488
27308: IFFALSE 27339
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27310: LD_VAR 0 11
27314: PPUSH
27315: LD_VAR 0 14
27319: PUSH
27320: LD_INT 1
27322: ARRAY
27323: PPUSH
27324: LD_VAR 0 14
27328: PUSH
27329: LD_INT 2
27331: ARRAY
27332: PPUSH
27333: CALL_OW 111
// continue ;
27337: GO 27065
// end ; end ; r := GetDir ( tmp ) ;
27339: LD_ADDR_VAR 0 13
27343: PUSH
27344: LD_VAR 0 11
27348: PPUSH
27349: CALL_OW 254
27353: ST_TO_ADDR
// if r = 5 then
27354: LD_VAR 0 13
27358: PUSH
27359: LD_INT 5
27361: EQUAL
27362: IFFALSE 27372
// r := 0 ;
27364: LD_ADDR_VAR 0 13
27368: PUSH
27369: LD_INT 0
27371: ST_TO_ADDR
// for j = r to 5 do
27372: LD_ADDR_VAR 0 8
27376: PUSH
27377: DOUBLE
27378: LD_VAR 0 13
27382: DEC
27383: ST_TO_ADDR
27384: LD_INT 5
27386: PUSH
27387: FOR_TO
27388: IFFALSE 27502
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27390: LD_ADDR_VAR 0 9
27394: PUSH
27395: LD_VAR 0 11
27399: PPUSH
27400: CALL_OW 250
27404: PPUSH
27405: LD_VAR 0 8
27409: PPUSH
27410: LD_INT 2
27412: PPUSH
27413: CALL_OW 272
27417: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27418: LD_ADDR_VAR 0 10
27422: PUSH
27423: LD_VAR 0 11
27427: PPUSH
27428: CALL_OW 251
27432: PPUSH
27433: LD_VAR 0 8
27437: PPUSH
27438: LD_INT 2
27440: PPUSH
27441: CALL_OW 273
27445: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27446: LD_VAR 0 9
27450: PPUSH
27451: LD_VAR 0 10
27455: PPUSH
27456: CALL_OW 488
27460: PUSH
27461: LD_VAR 0 9
27465: PPUSH
27466: LD_VAR 0 10
27470: PPUSH
27471: CALL_OW 428
27475: NOT
27476: AND
27477: IFFALSE 27500
// begin ComMoveXY ( tmp , _x , _y ) ;
27479: LD_VAR 0 11
27483: PPUSH
27484: LD_VAR 0 9
27488: PPUSH
27489: LD_VAR 0 10
27493: PPUSH
27494: CALL_OW 111
// break ;
27498: GO 27502
// end ; end ;
27500: GO 27387
27502: POP
27503: POP
// end ;
27504: GO 27065
27506: POP
27507: POP
// end ;
27508: LD_VAR 0 6
27512: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , pom , cost , hexes , height , dist , hex ; begin
27513: LD_INT 0
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
// result := false ;
27524: LD_ADDR_VAR 0 6
27528: PUSH
27529: LD_INT 0
27531: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27532: LD_VAR 0 1
27536: NOT
27537: PUSH
27538: LD_VAR 0 1
27542: PPUSH
27543: CALL_OW 266
27547: PUSH
27548: LD_INT 0
27550: PUSH
27551: LD_INT 1
27553: PUSH
27554: EMPTY
27555: LIST
27556: LIST
27557: IN
27558: NOT
27559: OR
27560: PUSH
27561: LD_VAR 0 2
27565: NOT
27566: OR
27567: PUSH
27568: LD_VAR 0 5
27572: PUSH
27573: LD_INT 0
27575: PUSH
27576: LD_INT 1
27578: PUSH
27579: LD_INT 2
27581: PUSH
27582: LD_INT 3
27584: PUSH
27585: LD_INT 4
27587: PUSH
27588: LD_INT 5
27590: PUSH
27591: EMPTY
27592: LIST
27593: LIST
27594: LIST
27595: LIST
27596: LIST
27597: LIST
27598: IN
27599: NOT
27600: OR
27601: PUSH
27602: LD_VAR 0 3
27606: PPUSH
27607: LD_VAR 0 4
27611: PPUSH
27612: CALL_OW 488
27616: NOT
27617: OR
27618: IFFALSE 27622
// exit ;
27620: GO 28332
// pom := GetBase ( bdepot ) ;
27622: LD_ADDR_VAR 0 9
27626: PUSH
27627: LD_VAR 0 1
27631: PPUSH
27632: CALL_OW 274
27636: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
27637: LD_ADDR_VAR 0 10
27641: PUSH
27642: LD_VAR 0 2
27646: PPUSH
27647: LD_VAR 0 1
27651: PPUSH
27652: CALL_OW 248
27656: PPUSH
27657: CALL_OW 450
27661: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27662: LD_VAR 0 9
27666: PPUSH
27667: LD_INT 1
27669: PPUSH
27670: CALL_OW 275
27674: PUSH
27675: LD_VAR 0 10
27679: PUSH
27680: LD_INT 1
27682: ARRAY
27683: GREATEREQUAL
27684: PUSH
27685: LD_VAR 0 9
27689: PPUSH
27690: LD_INT 2
27692: PPUSH
27693: CALL_OW 275
27697: PUSH
27698: LD_VAR 0 10
27702: PUSH
27703: LD_INT 2
27705: ARRAY
27706: GREATEREQUAL
27707: AND
27708: PUSH
27709: LD_VAR 0 9
27713: PPUSH
27714: LD_INT 3
27716: PPUSH
27717: CALL_OW 275
27721: PUSH
27722: LD_VAR 0 10
27726: PUSH
27727: LD_INT 3
27729: ARRAY
27730: GREATEREQUAL
27731: AND
27732: NOT
27733: IFFALSE 27737
// exit ;
27735: GO 28332
// if GetBType ( bdepot ) = b_depot then
27737: LD_VAR 0 1
27741: PPUSH
27742: CALL_OW 266
27746: PUSH
27747: LD_INT 0
27749: EQUAL
27750: IFFALSE 27762
// dist := 28 else
27752: LD_ADDR_VAR 0 13
27756: PUSH
27757: LD_INT 28
27759: ST_TO_ADDR
27760: GO 27770
// dist := 36 ;
27762: LD_ADDR_VAR 0 13
27766: PUSH
27767: LD_INT 36
27769: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
27770: LD_VAR 0 1
27774: PPUSH
27775: LD_VAR 0 3
27779: PPUSH
27780: LD_VAR 0 4
27784: PPUSH
27785: CALL_OW 297
27789: PUSH
27790: LD_VAR 0 13
27794: GREATER
27795: IFFALSE 27799
// exit ;
27797: GO 28332
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
27799: LD_ADDR_VAR 0 11
27803: PUSH
27804: LD_VAR 0 2
27808: PPUSH
27809: LD_VAR 0 3
27813: PPUSH
27814: LD_VAR 0 4
27818: PPUSH
27819: LD_VAR 0 5
27823: PPUSH
27824: LD_VAR 0 1
27828: PPUSH
27829: CALL_OW 248
27833: PPUSH
27834: LD_INT 0
27836: PPUSH
27837: CALL 28337 0 6
27841: ST_TO_ADDR
// if not hexes then
27842: LD_VAR 0 11
27846: NOT
27847: IFFALSE 27851
// exit ;
27849: GO 28332
// hex := GetHexInfo ( x , y ) ;
27851: LD_ADDR_VAR 0 14
27855: PUSH
27856: LD_VAR 0 3
27860: PPUSH
27861: LD_VAR 0 4
27865: PPUSH
27866: CALL_OW 546
27870: ST_TO_ADDR
// if hex [ 1 ] then
27871: LD_VAR 0 14
27875: PUSH
27876: LD_INT 1
27878: ARRAY
27879: IFFALSE 27883
// exit ;
27881: GO 28332
// height := hex [ 2 ] ;
27883: LD_ADDR_VAR 0 12
27887: PUSH
27888: LD_VAR 0 14
27892: PUSH
27893: LD_INT 2
27895: ARRAY
27896: ST_TO_ADDR
// for i = 1 to hexes do
27897: LD_ADDR_VAR 0 7
27901: PUSH
27902: DOUBLE
27903: LD_INT 1
27905: DEC
27906: ST_TO_ADDR
27907: LD_VAR 0 11
27911: PUSH
27912: FOR_TO
27913: IFFALSE 28241
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27915: LD_VAR 0 11
27919: PUSH
27920: LD_VAR 0 7
27924: ARRAY
27925: PUSH
27926: LD_INT 1
27928: ARRAY
27929: PPUSH
27930: LD_VAR 0 11
27934: PUSH
27935: LD_VAR 0 7
27939: ARRAY
27940: PUSH
27941: LD_INT 2
27943: ARRAY
27944: PPUSH
27945: CALL_OW 488
27949: NOT
27950: IFFALSE 27954
// continue ;
27952: GO 27912
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27954: LD_ADDR_VAR 0 8
27958: PUSH
27959: LD_VAR 0 11
27963: PUSH
27964: LD_VAR 0 7
27968: ARRAY
27969: PUSH
27970: LD_INT 1
27972: ARRAY
27973: PPUSH
27974: LD_VAR 0 11
27978: PUSH
27979: LD_VAR 0 7
27983: ARRAY
27984: PUSH
27985: LD_INT 2
27987: ARRAY
27988: PPUSH
27989: CALL_OW 546
27993: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27994: LD_VAR 0 8
27998: PUSH
27999: LD_INT 1
28001: ARRAY
28002: PUSH
28003: LD_VAR 0 8
28007: PUSH
28008: LD_INT 2
28010: ARRAY
28011: PUSH
28012: LD_VAR 0 12
28016: PUSH
28017: LD_INT 2
28019: PLUS
28020: GREATER
28021: OR
28022: PUSH
28023: LD_VAR 0 8
28027: PUSH
28028: LD_INT 2
28030: ARRAY
28031: PUSH
28032: LD_VAR 0 12
28036: PUSH
28037: LD_INT 2
28039: MINUS
28040: LESS
28041: OR
28042: PUSH
28043: LD_VAR 0 8
28047: PUSH
28048: LD_INT 3
28050: ARRAY
28051: PUSH
28052: LD_INT 0
28054: PUSH
28055: LD_INT 8
28057: PUSH
28058: LD_INT 9
28060: PUSH
28061: LD_INT 10
28063: PUSH
28064: LD_INT 11
28066: PUSH
28067: LD_INT 12
28069: PUSH
28070: LD_INT 13
28072: PUSH
28073: LD_INT 16
28075: PUSH
28076: LD_INT 17
28078: PUSH
28079: LD_INT 18
28081: PUSH
28082: LD_INT 19
28084: PUSH
28085: LD_INT 20
28087: PUSH
28088: LD_INT 21
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: LIST
28095: LIST
28096: LIST
28097: LIST
28098: LIST
28099: LIST
28100: LIST
28101: LIST
28102: LIST
28103: LIST
28104: LIST
28105: IN
28106: NOT
28107: OR
28108: PUSH
28109: LD_VAR 0 8
28113: PUSH
28114: LD_INT 5
28116: ARRAY
28117: NOT
28118: OR
28119: PUSH
28120: LD_VAR 0 8
28124: PUSH
28125: LD_INT 6
28127: ARRAY
28128: PUSH
28129: LD_INT 1
28131: PUSH
28132: LD_INT 2
28134: PUSH
28135: LD_INT 7
28137: PUSH
28138: LD_INT 9
28140: PUSH
28141: LD_INT 10
28143: PUSH
28144: LD_INT 11
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: IN
28155: NOT
28156: OR
28157: PUSH
28158: LD_VAR 0 11
28162: PUSH
28163: LD_VAR 0 7
28167: ARRAY
28168: PUSH
28169: LD_INT 1
28171: ARRAY
28172: PPUSH
28173: LD_VAR 0 11
28177: PUSH
28178: LD_VAR 0 7
28182: ARRAY
28183: PUSH
28184: LD_INT 2
28186: ARRAY
28187: PPUSH
28188: CALL_OW 428
28192: PUSH
28193: LD_INT 0
28195: GREATER
28196: OR
28197: PUSH
28198: LD_VAR 0 11
28202: PUSH
28203: LD_VAR 0 7
28207: ARRAY
28208: PUSH
28209: LD_INT 1
28211: ARRAY
28212: PPUSH
28213: LD_VAR 0 11
28217: PUSH
28218: LD_VAR 0 7
28222: ARRAY
28223: PUSH
28224: LD_INT 2
28226: ARRAY
28227: PPUSH
28228: CALL_OW 351
28232: OR
28233: IFFALSE 28239
// exit ;
28235: POP
28236: POP
28237: GO 28332
// end ;
28239: GO 27912
28241: POP
28242: POP
// if DangerAtRangeXY ( GetSide ( bdepot ) , x , y , 20 ) [ 4 ] then
28243: LD_VAR 0 1
28247: PPUSH
28248: CALL_OW 255
28252: PPUSH
28253: LD_VAR 0 3
28257: PPUSH
28258: LD_VAR 0 4
28262: PPUSH
28263: LD_INT 20
28265: PPUSH
28266: CALL 21191 0 4
28270: PUSH
28271: LD_INT 4
28273: ARRAY
28274: IFFALSE 28278
// exit ;
28276: GO 28332
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , GetSide ( bdepot ) ) then
28278: LD_VAR 0 2
28282: PUSH
28283: LD_INT 29
28285: PUSH
28286: LD_INT 30
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: IN
28293: PUSH
28294: LD_VAR 0 3
28298: PPUSH
28299: LD_VAR 0 4
28303: PPUSH
28304: LD_VAR 0 1
28308: PPUSH
28309: CALL_OW 255
28313: PPUSH
28314: CALL_OW 440
28318: NOT
28319: AND
28320: IFFALSE 28324
// exit ;
28322: GO 28332
// result := true ;
28324: LD_ADDR_VAR 0 6
28328: PUSH
28329: LD_INT 1
28331: ST_TO_ADDR
// end ;
28332: LD_VAR 0 6
28336: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28337: LD_INT 0
28339: PPUSH
28340: PPUSH
28341: PPUSH
28342: PPUSH
28343: PPUSH
28344: PPUSH
28345: PPUSH
28346: PPUSH
28347: PPUSH
28348: PPUSH
28349: PPUSH
28350: PPUSH
28351: PPUSH
28352: PPUSH
28353: PPUSH
28354: PPUSH
28355: PPUSH
28356: PPUSH
28357: PPUSH
28358: PPUSH
28359: PPUSH
28360: PPUSH
28361: PPUSH
28362: PPUSH
28363: PPUSH
28364: PPUSH
28365: PPUSH
28366: PPUSH
28367: PPUSH
28368: PPUSH
28369: PPUSH
28370: PPUSH
28371: PPUSH
28372: PPUSH
28373: PPUSH
28374: PPUSH
28375: PPUSH
28376: PPUSH
28377: PPUSH
28378: PPUSH
28379: PPUSH
28380: PPUSH
28381: PPUSH
28382: PPUSH
28383: PPUSH
28384: PPUSH
28385: PPUSH
28386: PPUSH
28387: PPUSH
28388: PPUSH
28389: PPUSH
28390: PPUSH
28391: PPUSH
28392: PPUSH
28393: PPUSH
28394: PPUSH
28395: PPUSH
28396: PPUSH
// result = [ ] ;
28397: LD_ADDR_VAR 0 7
28401: PUSH
28402: EMPTY
28403: ST_TO_ADDR
// temp_list = [ ] ;
28404: LD_ADDR_VAR 0 9
28408: PUSH
28409: EMPTY
28410: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28411: LD_VAR 0 4
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 1
28421: PUSH
28422: LD_INT 2
28424: PUSH
28425: LD_INT 3
28427: PUSH
28428: LD_INT 4
28430: PUSH
28431: LD_INT 5
28433: PUSH
28434: EMPTY
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: IN
28442: NOT
28443: PUSH
28444: LD_VAR 0 1
28448: PUSH
28449: LD_INT 0
28451: PUSH
28452: LD_INT 1
28454: PUSH
28455: EMPTY
28456: LIST
28457: LIST
28458: IN
28459: PUSH
28460: LD_VAR 0 5
28464: PUSH
28465: LD_INT 1
28467: PUSH
28468: LD_INT 2
28470: PUSH
28471: LD_INT 3
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: LIST
28478: IN
28479: NOT
28480: AND
28481: OR
28482: IFFALSE 28486
// exit ;
28484: GO 46871
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28486: LD_VAR 0 1
28490: PUSH
28491: LD_INT 6
28493: PUSH
28494: LD_INT 7
28496: PUSH
28497: LD_INT 8
28499: PUSH
28500: LD_INT 13
28502: PUSH
28503: LD_INT 12
28505: PUSH
28506: LD_INT 15
28508: PUSH
28509: LD_INT 11
28511: PUSH
28512: LD_INT 14
28514: PUSH
28515: LD_INT 10
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: LIST
28522: LIST
28523: LIST
28524: LIST
28525: LIST
28526: LIST
28527: LIST
28528: IN
28529: IFFALSE 28539
// btype = b_lab ;
28531: LD_ADDR_VAR 0 1
28535: PUSH
28536: LD_INT 6
28538: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28539: LD_VAR 0 6
28543: PUSH
28544: LD_INT 0
28546: PUSH
28547: LD_INT 1
28549: PUSH
28550: LD_INT 2
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: LIST
28557: IN
28558: NOT
28559: PUSH
28560: LD_VAR 0 1
28564: PUSH
28565: LD_INT 0
28567: PUSH
28568: LD_INT 1
28570: PUSH
28571: LD_INT 2
28573: PUSH
28574: LD_INT 3
28576: PUSH
28577: LD_INT 6
28579: PUSH
28580: LD_INT 36
28582: PUSH
28583: LD_INT 4
28585: PUSH
28586: LD_INT 5
28588: PUSH
28589: LD_INT 31
28591: PUSH
28592: LD_INT 32
28594: PUSH
28595: LD_INT 33
28597: PUSH
28598: EMPTY
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: IN
28611: NOT
28612: PUSH
28613: LD_VAR 0 6
28617: PUSH
28618: LD_INT 1
28620: EQUAL
28621: AND
28622: OR
28623: PUSH
28624: LD_VAR 0 1
28628: PUSH
28629: LD_INT 2
28631: PUSH
28632: LD_INT 3
28634: PUSH
28635: EMPTY
28636: LIST
28637: LIST
28638: IN
28639: NOT
28640: PUSH
28641: LD_VAR 0 6
28645: PUSH
28646: LD_INT 2
28648: EQUAL
28649: AND
28650: OR
28651: IFFALSE 28661
// mode = 0 ;
28653: LD_ADDR_VAR 0 6
28657: PUSH
28658: LD_INT 0
28660: ST_TO_ADDR
// case mode of 0 :
28661: LD_VAR 0 6
28665: PUSH
28666: LD_INT 0
28668: DOUBLE
28669: EQUAL
28670: IFTRUE 28674
28672: GO 40127
28674: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28675: LD_ADDR_VAR 0 11
28679: PUSH
28680: LD_INT 0
28682: PUSH
28683: LD_INT 0
28685: PUSH
28686: EMPTY
28687: LIST
28688: LIST
28689: PUSH
28690: LD_INT 0
28692: PUSH
28693: LD_INT 1
28695: NEG
28696: PUSH
28697: EMPTY
28698: LIST
28699: LIST
28700: PUSH
28701: LD_INT 1
28703: PUSH
28704: LD_INT 0
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 1
28713: PUSH
28714: LD_INT 1
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: PUSH
28721: LD_INT 0
28723: PUSH
28724: LD_INT 1
28726: PUSH
28727: EMPTY
28728: LIST
28729: LIST
28730: PUSH
28731: LD_INT 1
28733: NEG
28734: PUSH
28735: LD_INT 0
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 1
28748: NEG
28749: PUSH
28750: EMPTY
28751: LIST
28752: LIST
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: LD_INT 2
28760: NEG
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: PUSH
28766: LD_INT 0
28768: PUSH
28769: LD_INT 2
28771: NEG
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: PUSH
28777: LD_INT 1
28779: PUSH
28780: LD_INT 1
28782: NEG
28783: PUSH
28784: EMPTY
28785: LIST
28786: LIST
28787: PUSH
28788: LD_INT 1
28790: PUSH
28791: LD_INT 2
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 0
28800: PUSH
28801: LD_INT 2
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 1
28810: NEG
28811: PUSH
28812: LD_INT 1
28814: PUSH
28815: EMPTY
28816: LIST
28817: LIST
28818: PUSH
28819: LD_INT 1
28821: PUSH
28822: LD_INT 3
28824: PUSH
28825: EMPTY
28826: LIST
28827: LIST
28828: PUSH
28829: LD_INT 0
28831: PUSH
28832: LD_INT 3
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 1
28841: NEG
28842: PUSH
28843: LD_INT 2
28845: PUSH
28846: EMPTY
28847: LIST
28848: LIST
28849: PUSH
28850: EMPTY
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28868: LD_ADDR_VAR 0 12
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: LD_INT 0
28878: PUSH
28879: EMPTY
28880: LIST
28881: LIST
28882: PUSH
28883: LD_INT 0
28885: PUSH
28886: LD_INT 1
28888: NEG
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: LD_INT 0
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 1
28906: PUSH
28907: LD_INT 1
28909: PUSH
28910: EMPTY
28911: LIST
28912: LIST
28913: PUSH
28914: LD_INT 0
28916: PUSH
28917: LD_INT 1
28919: PUSH
28920: EMPTY
28921: LIST
28922: LIST
28923: PUSH
28924: LD_INT 1
28926: NEG
28927: PUSH
28928: LD_INT 0
28930: PUSH
28931: EMPTY
28932: LIST
28933: LIST
28934: PUSH
28935: LD_INT 1
28937: NEG
28938: PUSH
28939: LD_INT 1
28941: NEG
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PUSH
28947: LD_INT 1
28949: PUSH
28950: LD_INT 1
28952: NEG
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 2
28960: PUSH
28961: LD_INT 0
28963: PUSH
28964: EMPTY
28965: LIST
28966: LIST
28967: PUSH
28968: LD_INT 2
28970: PUSH
28971: LD_INT 1
28973: PUSH
28974: EMPTY
28975: LIST
28976: LIST
28977: PUSH
28978: LD_INT 1
28980: NEG
28981: PUSH
28982: LD_INT 1
28984: PUSH
28985: EMPTY
28986: LIST
28987: LIST
28988: PUSH
28989: LD_INT 2
28991: NEG
28992: PUSH
28993: LD_INT 0
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: LD_INT 2
29002: NEG
29003: PUSH
29004: LD_INT 1
29006: NEG
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: LD_INT 2
29014: NEG
29015: PUSH
29016: LD_INT 1
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: PUSH
29023: LD_INT 3
29025: NEG
29026: PUSH
29027: LD_INT 0
29029: PUSH
29030: EMPTY
29031: LIST
29032: LIST
29033: PUSH
29034: LD_INT 3
29036: NEG
29037: PUSH
29038: LD_INT 1
29040: NEG
29041: PUSH
29042: EMPTY
29043: LIST
29044: LIST
29045: PUSH
29046: EMPTY
29047: LIST
29048: LIST
29049: LIST
29050: LIST
29051: LIST
29052: LIST
29053: LIST
29054: LIST
29055: LIST
29056: LIST
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: LIST
29062: LIST
29063: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29064: LD_ADDR_VAR 0 13
29068: PUSH
29069: LD_INT 0
29071: PUSH
29072: LD_INT 0
29074: PUSH
29075: EMPTY
29076: LIST
29077: LIST
29078: PUSH
29079: LD_INT 0
29081: PUSH
29082: LD_INT 1
29084: NEG
29085: PUSH
29086: EMPTY
29087: LIST
29088: LIST
29089: PUSH
29090: LD_INT 1
29092: PUSH
29093: LD_INT 0
29095: PUSH
29096: EMPTY
29097: LIST
29098: LIST
29099: PUSH
29100: LD_INT 1
29102: PUSH
29103: LD_INT 1
29105: PUSH
29106: EMPTY
29107: LIST
29108: LIST
29109: PUSH
29110: LD_INT 0
29112: PUSH
29113: LD_INT 1
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: NEG
29123: PUSH
29124: LD_INT 0
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 1
29133: NEG
29134: PUSH
29135: LD_INT 1
29137: NEG
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: PUSH
29143: LD_INT 1
29145: NEG
29146: PUSH
29147: LD_INT 2
29149: NEG
29150: PUSH
29151: EMPTY
29152: LIST
29153: LIST
29154: PUSH
29155: LD_INT 2
29157: PUSH
29158: LD_INT 1
29160: PUSH
29161: EMPTY
29162: LIST
29163: LIST
29164: PUSH
29165: LD_INT 2
29167: PUSH
29168: LD_INT 2
29170: PUSH
29171: EMPTY
29172: LIST
29173: LIST
29174: PUSH
29175: LD_INT 1
29177: PUSH
29178: LD_INT 2
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 2
29187: NEG
29188: PUSH
29189: LD_INT 1
29191: NEG
29192: PUSH
29193: EMPTY
29194: LIST
29195: LIST
29196: PUSH
29197: LD_INT 2
29199: NEG
29200: PUSH
29201: LD_INT 2
29203: NEG
29204: PUSH
29205: EMPTY
29206: LIST
29207: LIST
29208: PUSH
29209: LD_INT 2
29211: NEG
29212: PUSH
29213: LD_INT 3
29215: NEG
29216: PUSH
29217: EMPTY
29218: LIST
29219: LIST
29220: PUSH
29221: LD_INT 3
29223: NEG
29224: PUSH
29225: LD_INT 2
29227: NEG
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: PUSH
29233: LD_INT 3
29235: NEG
29236: PUSH
29237: LD_INT 3
29239: NEG
29240: PUSH
29241: EMPTY
29242: LIST
29243: LIST
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: LIST
29251: LIST
29252: LIST
29253: LIST
29254: LIST
29255: LIST
29256: LIST
29257: LIST
29258: LIST
29259: LIST
29260: LIST
29261: LIST
29262: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29263: LD_ADDR_VAR 0 14
29267: PUSH
29268: LD_INT 0
29270: PUSH
29271: LD_INT 0
29273: PUSH
29274: EMPTY
29275: LIST
29276: LIST
29277: PUSH
29278: LD_INT 0
29280: PUSH
29281: LD_INT 1
29283: NEG
29284: PUSH
29285: EMPTY
29286: LIST
29287: LIST
29288: PUSH
29289: LD_INT 1
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: EMPTY
29296: LIST
29297: LIST
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: LD_INT 1
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: PUSH
29309: LD_INT 0
29311: PUSH
29312: LD_INT 1
29314: PUSH
29315: EMPTY
29316: LIST
29317: LIST
29318: PUSH
29319: LD_INT 1
29321: NEG
29322: PUSH
29323: LD_INT 0
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 1
29332: NEG
29333: PUSH
29334: LD_INT 1
29336: NEG
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 1
29344: NEG
29345: PUSH
29346: LD_INT 2
29348: NEG
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 0
29356: PUSH
29357: LD_INT 2
29359: NEG
29360: PUSH
29361: EMPTY
29362: LIST
29363: LIST
29364: PUSH
29365: LD_INT 1
29367: PUSH
29368: LD_INT 1
29370: NEG
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: LD_INT 2
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 1
29398: NEG
29399: PUSH
29400: LD_INT 1
29402: PUSH
29403: EMPTY
29404: LIST
29405: LIST
29406: PUSH
29407: LD_INT 1
29409: NEG
29410: PUSH
29411: LD_INT 3
29413: NEG
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 0
29421: PUSH
29422: LD_INT 3
29424: NEG
29425: PUSH
29426: EMPTY
29427: LIST
29428: LIST
29429: PUSH
29430: LD_INT 1
29432: PUSH
29433: LD_INT 2
29435: NEG
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: LIST
29453: LIST
29454: LIST
29455: LIST
29456: LIST
29457: LIST
29458: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29459: LD_ADDR_VAR 0 15
29463: PUSH
29464: LD_INT 0
29466: PUSH
29467: LD_INT 0
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 0
29476: PUSH
29477: LD_INT 1
29479: NEG
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: PUSH
29485: LD_INT 1
29487: PUSH
29488: LD_INT 0
29490: PUSH
29491: EMPTY
29492: LIST
29493: LIST
29494: PUSH
29495: LD_INT 1
29497: PUSH
29498: LD_INT 1
29500: PUSH
29501: EMPTY
29502: LIST
29503: LIST
29504: PUSH
29505: LD_INT 0
29507: PUSH
29508: LD_INT 1
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 1
29517: NEG
29518: PUSH
29519: LD_INT 0
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 1
29528: NEG
29529: PUSH
29530: LD_INT 1
29532: NEG
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: LD_INT 1
29543: NEG
29544: PUSH
29545: EMPTY
29546: LIST
29547: LIST
29548: PUSH
29549: LD_INT 2
29551: PUSH
29552: LD_INT 0
29554: PUSH
29555: EMPTY
29556: LIST
29557: LIST
29558: PUSH
29559: LD_INT 2
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 1
29571: NEG
29572: PUSH
29573: LD_INT 1
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 2
29582: NEG
29583: PUSH
29584: LD_INT 0
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 2
29593: NEG
29594: PUSH
29595: LD_INT 1
29597: NEG
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: PUSH
29603: LD_INT 2
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: PUSH
29614: LD_INT 3
29616: PUSH
29617: LD_INT 0
29619: PUSH
29620: EMPTY
29621: LIST
29622: LIST
29623: PUSH
29624: LD_INT 3
29626: PUSH
29627: LD_INT 1
29629: PUSH
29630: EMPTY
29631: LIST
29632: LIST
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: LIST
29638: LIST
29639: LIST
29640: LIST
29641: LIST
29642: LIST
29643: LIST
29644: LIST
29645: LIST
29646: LIST
29647: LIST
29648: LIST
29649: LIST
29650: LIST
29651: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29652: LD_ADDR_VAR 0 16
29656: PUSH
29657: LD_INT 0
29659: PUSH
29660: LD_INT 0
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 0
29669: PUSH
29670: LD_INT 1
29672: NEG
29673: PUSH
29674: EMPTY
29675: LIST
29676: LIST
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: LD_INT 0
29683: PUSH
29684: EMPTY
29685: LIST
29686: LIST
29687: PUSH
29688: LD_INT 1
29690: PUSH
29691: LD_INT 1
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 1
29710: NEG
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: NEG
29722: PUSH
29723: LD_INT 1
29725: NEG
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 1
29733: NEG
29734: PUSH
29735: LD_INT 2
29737: NEG
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: PUSH
29743: LD_INT 2
29745: PUSH
29746: LD_INT 1
29748: PUSH
29749: EMPTY
29750: LIST
29751: LIST
29752: PUSH
29753: LD_INT 2
29755: PUSH
29756: LD_INT 2
29758: PUSH
29759: EMPTY
29760: LIST
29761: LIST
29762: PUSH
29763: LD_INT 1
29765: PUSH
29766: LD_INT 2
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 2
29775: NEG
29776: PUSH
29777: LD_INT 1
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 2
29787: NEG
29788: PUSH
29789: LD_INT 2
29791: NEG
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 3
29799: PUSH
29800: LD_INT 2
29802: PUSH
29803: EMPTY
29804: LIST
29805: LIST
29806: PUSH
29807: LD_INT 3
29809: PUSH
29810: LD_INT 3
29812: PUSH
29813: EMPTY
29814: LIST
29815: LIST
29816: PUSH
29817: LD_INT 2
29819: PUSH
29820: LD_INT 3
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: LIST
29831: LIST
29832: LIST
29833: LIST
29834: LIST
29835: LIST
29836: LIST
29837: LIST
29838: LIST
29839: LIST
29840: LIST
29841: LIST
29842: LIST
29843: LIST
29844: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29845: LD_ADDR_VAR 0 17
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 0
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: LD_INT 1
29865: NEG
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 1
29873: PUSH
29874: LD_INT 0
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: PUSH
29884: LD_INT 1
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 0
29893: PUSH
29894: LD_INT 1
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 1
29903: NEG
29904: PUSH
29905: LD_INT 0
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 1
29914: NEG
29915: PUSH
29916: LD_INT 1
29918: NEG
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 1
29926: NEG
29927: PUSH
29928: LD_INT 2
29930: NEG
29931: PUSH
29932: EMPTY
29933: LIST
29934: LIST
29935: PUSH
29936: LD_INT 0
29938: PUSH
29939: LD_INT 2
29941: NEG
29942: PUSH
29943: EMPTY
29944: LIST
29945: LIST
29946: PUSH
29947: LD_INT 1
29949: PUSH
29950: LD_INT 1
29952: NEG
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 2
29960: PUSH
29961: LD_INT 0
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 2
29970: PUSH
29971: LD_INT 1
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 2
29980: PUSH
29981: LD_INT 2
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: PUSH
29991: LD_INT 2
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 0
30000: PUSH
30001: LD_INT 2
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: LD_INT 1
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 2
30021: NEG
30022: PUSH
30023: LD_INT 0
30025: PUSH
30026: EMPTY
30027: LIST
30028: LIST
30029: PUSH
30030: LD_INT 2
30032: NEG
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 2
30044: NEG
30045: PUSH
30046: LD_INT 2
30048: NEG
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: LIST
30061: LIST
30062: LIST
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30075: LD_ADDR_VAR 0 18
30079: PUSH
30080: LD_INT 0
30082: PUSH
30083: LD_INT 0
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 0
30092: PUSH
30093: LD_INT 1
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 1
30103: PUSH
30104: LD_INT 0
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 1
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: LD_INT 0
30123: PUSH
30124: LD_INT 1
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PUSH
30131: LD_INT 1
30133: NEG
30134: PUSH
30135: LD_INT 0
30137: PUSH
30138: EMPTY
30139: LIST
30140: LIST
30141: PUSH
30142: LD_INT 1
30144: NEG
30145: PUSH
30146: LD_INT 1
30148: NEG
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: PUSH
30154: LD_INT 1
30156: NEG
30157: PUSH
30158: LD_INT 2
30160: NEG
30161: PUSH
30162: EMPTY
30163: LIST
30164: LIST
30165: PUSH
30166: LD_INT 0
30168: PUSH
30169: LD_INT 2
30171: NEG
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 1
30179: PUSH
30180: LD_INT 1
30182: NEG
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 2
30190: PUSH
30191: LD_INT 0
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: LD_INT 1
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 2
30210: PUSH
30211: LD_INT 2
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 1
30220: PUSH
30221: LD_INT 2
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 0
30230: PUSH
30231: LD_INT 2
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PUSH
30238: LD_INT 1
30240: NEG
30241: PUSH
30242: LD_INT 1
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 2
30251: NEG
30252: PUSH
30253: LD_INT 0
30255: PUSH
30256: EMPTY
30257: LIST
30258: LIST
30259: PUSH
30260: LD_INT 2
30262: NEG
30263: PUSH
30264: LD_INT 1
30266: NEG
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: PUSH
30272: LD_INT 2
30274: NEG
30275: PUSH
30276: LD_INT 2
30278: NEG
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: LIST
30288: LIST
30289: LIST
30290: LIST
30291: LIST
30292: LIST
30293: LIST
30294: LIST
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30305: LD_ADDR_VAR 0 19
30309: PUSH
30310: LD_INT 0
30312: PUSH
30313: LD_INT 0
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 0
30322: PUSH
30323: LD_INT 1
30325: NEG
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 1
30333: PUSH
30334: LD_INT 0
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 1
30343: PUSH
30344: LD_INT 1
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 0
30353: PUSH
30354: LD_INT 1
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 1
30363: NEG
30364: PUSH
30365: LD_INT 0
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 1
30374: NEG
30375: PUSH
30376: LD_INT 1
30378: NEG
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 1
30386: NEG
30387: PUSH
30388: LD_INT 2
30390: NEG
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: LD_INT 2
30401: NEG
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: PUSH
30410: LD_INT 1
30412: NEG
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 2
30420: PUSH
30421: LD_INT 0
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 2
30430: PUSH
30431: LD_INT 1
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: PUSH
30441: LD_INT 2
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 1
30450: PUSH
30451: LD_INT 2
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: LD_INT 2
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: LD_INT 1
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 2
30481: NEG
30482: PUSH
30483: LD_INT 0
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 2
30492: NEG
30493: PUSH
30494: LD_INT 1
30496: NEG
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 2
30504: NEG
30505: PUSH
30506: LD_INT 2
30508: NEG
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: EMPTY
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30535: LD_ADDR_VAR 0 20
30539: PUSH
30540: LD_INT 0
30542: PUSH
30543: LD_INT 0
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 0
30552: PUSH
30553: LD_INT 1
30555: NEG
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 1
30563: PUSH
30564: LD_INT 0
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: LD_INT 1
30576: PUSH
30577: EMPTY
30578: LIST
30579: LIST
30580: PUSH
30581: LD_INT 0
30583: PUSH
30584: LD_INT 1
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 1
30593: NEG
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 1
30604: NEG
30605: PUSH
30606: LD_INT 1
30608: NEG
30609: PUSH
30610: EMPTY
30611: LIST
30612: LIST
30613: PUSH
30614: LD_INT 1
30616: NEG
30617: PUSH
30618: LD_INT 2
30620: NEG
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 0
30628: PUSH
30629: LD_INT 2
30631: NEG
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 1
30639: PUSH
30640: LD_INT 1
30642: NEG
30643: PUSH
30644: EMPTY
30645: LIST
30646: LIST
30647: PUSH
30648: LD_INT 2
30650: PUSH
30651: LD_INT 0
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 2
30660: PUSH
30661: LD_INT 1
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 2
30670: PUSH
30671: LD_INT 2
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 1
30680: PUSH
30681: LD_INT 2
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 0
30690: PUSH
30691: LD_INT 2
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 1
30700: NEG
30701: PUSH
30702: LD_INT 1
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 2
30711: NEG
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 2
30722: NEG
30723: PUSH
30724: LD_INT 1
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 2
30734: NEG
30735: PUSH
30736: LD_INT 2
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: EMPTY
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30765: LD_ADDR_VAR 0 21
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: LD_INT 0
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 0
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 1
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 0
30813: PUSH
30814: LD_INT 1
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 1
30823: NEG
30824: PUSH
30825: LD_INT 0
30827: PUSH
30828: EMPTY
30829: LIST
30830: LIST
30831: PUSH
30832: LD_INT 1
30834: NEG
30835: PUSH
30836: LD_INT 1
30838: NEG
30839: PUSH
30840: EMPTY
30841: LIST
30842: LIST
30843: PUSH
30844: LD_INT 1
30846: NEG
30847: PUSH
30848: LD_INT 2
30850: NEG
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: LD_INT 2
30861: NEG
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: LD_INT 1
30869: PUSH
30870: LD_INT 1
30872: NEG
30873: PUSH
30874: EMPTY
30875: LIST
30876: LIST
30877: PUSH
30878: LD_INT 2
30880: PUSH
30881: LD_INT 0
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 2
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: PUSH
30901: LD_INT 2
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 1
30910: PUSH
30911: LD_INT 2
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 0
30920: PUSH
30921: LD_INT 2
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 1
30930: NEG
30931: PUSH
30932: LD_INT 1
30934: PUSH
30935: EMPTY
30936: LIST
30937: LIST
30938: PUSH
30939: LD_INT 2
30941: NEG
30942: PUSH
30943: LD_INT 0
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 2
30952: NEG
30953: PUSH
30954: LD_INT 1
30956: NEG
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 2
30964: NEG
30965: PUSH
30966: LD_INT 2
30968: NEG
30969: PUSH
30970: EMPTY
30971: LIST
30972: LIST
30973: PUSH
30974: EMPTY
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: LIST
30987: LIST
30988: LIST
30989: LIST
30990: LIST
30991: LIST
30992: LIST
30993: LIST
30994: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30995: LD_ADDR_VAR 0 22
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: LD_INT 0
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 0
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: PUSH
31024: LD_INT 0
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: PUSH
31037: EMPTY
31038: LIST
31039: LIST
31040: PUSH
31041: LD_INT 0
31043: PUSH
31044: LD_INT 1
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 1
31053: NEG
31054: PUSH
31055: LD_INT 0
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 1
31064: NEG
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: EMPTY
31071: LIST
31072: LIST
31073: PUSH
31074: LD_INT 1
31076: NEG
31077: PUSH
31078: LD_INT 2
31080: NEG
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 0
31088: PUSH
31089: LD_INT 2
31091: NEG
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 1
31102: NEG
31103: PUSH
31104: EMPTY
31105: LIST
31106: LIST
31107: PUSH
31108: LD_INT 2
31110: PUSH
31111: LD_INT 0
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 2
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: PUSH
31131: LD_INT 2
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: LD_INT 2
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 0
31150: PUSH
31151: LD_INT 2
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 1
31160: NEG
31161: PUSH
31162: LD_INT 1
31164: PUSH
31165: EMPTY
31166: LIST
31167: LIST
31168: PUSH
31169: LD_INT 2
31171: NEG
31172: PUSH
31173: LD_INT 0
31175: PUSH
31176: EMPTY
31177: LIST
31178: LIST
31179: PUSH
31180: LD_INT 2
31182: NEG
31183: PUSH
31184: LD_INT 1
31186: NEG
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 2
31194: NEG
31195: PUSH
31196: LD_INT 2
31198: NEG
31199: PUSH
31200: EMPTY
31201: LIST
31202: LIST
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: LIST
31224: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31225: LD_ADDR_VAR 0 23
31229: PUSH
31230: LD_INT 0
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 0
31242: PUSH
31243: LD_INT 1
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: PUSH
31254: LD_INT 0
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 1
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: EMPTY
31268: LIST
31269: LIST
31270: PUSH
31271: LD_INT 0
31273: PUSH
31274: LD_INT 1
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 1
31283: NEG
31284: PUSH
31285: LD_INT 0
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 1
31294: NEG
31295: PUSH
31296: LD_INT 1
31298: NEG
31299: PUSH
31300: EMPTY
31301: LIST
31302: LIST
31303: PUSH
31304: LD_INT 1
31306: NEG
31307: PUSH
31308: LD_INT 2
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 0
31318: PUSH
31319: LD_INT 2
31321: NEG
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: PUSH
31327: LD_INT 1
31329: PUSH
31330: LD_INT 1
31332: NEG
31333: PUSH
31334: EMPTY
31335: LIST
31336: LIST
31337: PUSH
31338: LD_INT 2
31340: PUSH
31341: LD_INT 0
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 2
31350: PUSH
31351: LD_INT 1
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 2
31360: PUSH
31361: LD_INT 2
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: LD_INT 2
31373: PUSH
31374: EMPTY
31375: LIST
31376: LIST
31377: PUSH
31378: LD_INT 0
31380: PUSH
31381: LD_INT 2
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 1
31390: NEG
31391: PUSH
31392: LD_INT 1
31394: PUSH
31395: EMPTY
31396: LIST
31397: LIST
31398: PUSH
31399: LD_INT 2
31401: NEG
31402: PUSH
31403: LD_INT 0
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 2
31412: NEG
31413: PUSH
31414: LD_INT 1
31416: NEG
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 2
31424: NEG
31425: PUSH
31426: LD_INT 2
31428: NEG
31429: PUSH
31430: EMPTY
31431: LIST
31432: LIST
31433: PUSH
31434: LD_INT 2
31436: NEG
31437: PUSH
31438: LD_INT 3
31440: NEG
31441: PUSH
31442: EMPTY
31443: LIST
31444: LIST
31445: PUSH
31446: LD_INT 1
31448: NEG
31449: PUSH
31450: LD_INT 3
31452: NEG
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 1
31460: PUSH
31461: LD_INT 2
31463: NEG
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 2
31471: PUSH
31472: LD_INT 1
31474: NEG
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31505: LD_ADDR_VAR 0 24
31509: PUSH
31510: LD_INT 0
31512: PUSH
31513: LD_INT 0
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 0
31522: PUSH
31523: LD_INT 1
31525: NEG
31526: PUSH
31527: EMPTY
31528: LIST
31529: LIST
31530: PUSH
31531: LD_INT 1
31533: PUSH
31534: LD_INT 0
31536: PUSH
31537: EMPTY
31538: LIST
31539: LIST
31540: PUSH
31541: LD_INT 1
31543: PUSH
31544: LD_INT 1
31546: PUSH
31547: EMPTY
31548: LIST
31549: LIST
31550: PUSH
31551: LD_INT 0
31553: PUSH
31554: LD_INT 1
31556: PUSH
31557: EMPTY
31558: LIST
31559: LIST
31560: PUSH
31561: LD_INT 1
31563: NEG
31564: PUSH
31565: LD_INT 0
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: NEG
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PUSH
31584: LD_INT 1
31586: NEG
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 0
31598: PUSH
31599: LD_INT 2
31601: NEG
31602: PUSH
31603: EMPTY
31604: LIST
31605: LIST
31606: PUSH
31607: LD_INT 1
31609: PUSH
31610: LD_INT 1
31612: NEG
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: LD_INT 2
31620: PUSH
31621: LD_INT 0
31623: PUSH
31624: EMPTY
31625: LIST
31626: LIST
31627: PUSH
31628: LD_INT 2
31630: PUSH
31631: LD_INT 1
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 2
31640: PUSH
31641: LD_INT 2
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: PUSH
31648: LD_INT 1
31650: PUSH
31651: LD_INT 2
31653: PUSH
31654: EMPTY
31655: LIST
31656: LIST
31657: PUSH
31658: LD_INT 0
31660: PUSH
31661: LD_INT 2
31663: PUSH
31664: EMPTY
31665: LIST
31666: LIST
31667: PUSH
31668: LD_INT 1
31670: NEG
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 2
31681: NEG
31682: PUSH
31683: LD_INT 0
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 2
31692: NEG
31693: PUSH
31694: LD_INT 1
31696: NEG
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 2
31704: NEG
31705: PUSH
31706: LD_INT 2
31708: NEG
31709: PUSH
31710: EMPTY
31711: LIST
31712: LIST
31713: PUSH
31714: LD_INT 1
31716: PUSH
31717: LD_INT 2
31719: NEG
31720: PUSH
31721: EMPTY
31722: LIST
31723: LIST
31724: PUSH
31725: LD_INT 2
31727: PUSH
31728: LD_INT 1
31730: NEG
31731: PUSH
31732: EMPTY
31733: LIST
31734: LIST
31735: PUSH
31736: LD_INT 3
31738: PUSH
31739: LD_INT 1
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 3
31748: PUSH
31749: LD_INT 2
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: EMPTY
31757: LIST
31758: LIST
31759: LIST
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31781: LD_ADDR_VAR 0 25
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 0
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 0
31798: PUSH
31799: LD_INT 1
31801: NEG
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: PUSH
31810: LD_INT 0
31812: PUSH
31813: EMPTY
31814: LIST
31815: LIST
31816: PUSH
31817: LD_INT 1
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: EMPTY
31824: LIST
31825: LIST
31826: PUSH
31827: LD_INT 0
31829: PUSH
31830: LD_INT 1
31832: PUSH
31833: EMPTY
31834: LIST
31835: LIST
31836: PUSH
31837: LD_INT 1
31839: NEG
31840: PUSH
31841: LD_INT 0
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: LD_INT 1
31850: NEG
31851: PUSH
31852: LD_INT 1
31854: NEG
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: LD_INT 2
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 0
31874: PUSH
31875: LD_INT 2
31877: NEG
31878: PUSH
31879: EMPTY
31880: LIST
31881: LIST
31882: PUSH
31883: LD_INT 1
31885: PUSH
31886: LD_INT 1
31888: NEG
31889: PUSH
31890: EMPTY
31891: LIST
31892: LIST
31893: PUSH
31894: LD_INT 2
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: EMPTY
31901: LIST
31902: LIST
31903: PUSH
31904: LD_INT 2
31906: PUSH
31907: LD_INT 1
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 2
31916: PUSH
31917: LD_INT 2
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 1
31926: PUSH
31927: LD_INT 2
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: LD_INT 0
31936: PUSH
31937: LD_INT 2
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 1
31946: NEG
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: EMPTY
31952: LIST
31953: LIST
31954: PUSH
31955: LD_INT 2
31957: NEG
31958: PUSH
31959: LD_INT 0
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: PUSH
31966: LD_INT 2
31968: NEG
31969: PUSH
31970: LD_INT 1
31972: NEG
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 2
31980: NEG
31981: PUSH
31982: LD_INT 2
31984: NEG
31985: PUSH
31986: EMPTY
31987: LIST
31988: LIST
31989: PUSH
31990: LD_INT 3
31992: PUSH
31993: LD_INT 1
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 3
32002: PUSH
32003: LD_INT 2
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 2
32012: PUSH
32013: LD_INT 3
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 1
32022: PUSH
32023: LD_INT 3
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: LIST
32041: LIST
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32055: LD_ADDR_VAR 0 26
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: LD_INT 0
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: LD_INT 1
32075: NEG
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 1
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: EMPTY
32088: LIST
32089: LIST
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: LD_INT 1
32106: PUSH
32107: EMPTY
32108: LIST
32109: LIST
32110: PUSH
32111: LD_INT 1
32113: NEG
32114: PUSH
32115: LD_INT 0
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: NEG
32125: PUSH
32126: LD_INT 1
32128: NEG
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: PUSH
32134: LD_INT 1
32136: NEG
32137: PUSH
32138: LD_INT 2
32140: NEG
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 0
32148: PUSH
32149: LD_INT 2
32151: NEG
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 1
32159: PUSH
32160: LD_INT 1
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 2
32170: PUSH
32171: LD_INT 0
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 2
32180: PUSH
32181: LD_INT 1
32183: PUSH
32184: EMPTY
32185: LIST
32186: LIST
32187: PUSH
32188: LD_INT 2
32190: PUSH
32191: LD_INT 2
32193: PUSH
32194: EMPTY
32195: LIST
32196: LIST
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: LD_INT 2
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PUSH
32208: LD_INT 0
32210: PUSH
32211: LD_INT 2
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 2
32231: NEG
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 2
32242: NEG
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 2
32254: NEG
32255: PUSH
32256: LD_INT 2
32258: NEG
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: LD_INT 3
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 1
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 1
32286: NEG
32287: PUSH
32288: LD_INT 2
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 2
32297: NEG
32298: PUSH
32299: LD_INT 1
32301: PUSH
32302: EMPTY
32303: LIST
32304: LIST
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32331: LD_ADDR_VAR 0 27
32335: PUSH
32336: LD_INT 0
32338: PUSH
32339: LD_INT 0
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 0
32348: PUSH
32349: LD_INT 1
32351: NEG
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 1
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 1
32369: PUSH
32370: LD_INT 1
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 0
32379: PUSH
32380: LD_INT 1
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PUSH
32398: LD_INT 1
32400: NEG
32401: PUSH
32402: LD_INT 1
32404: NEG
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 1
32412: NEG
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 0
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 1
32435: PUSH
32436: LD_INT 1
32438: NEG
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: LD_INT 2
32446: PUSH
32447: LD_INT 0
32449: PUSH
32450: EMPTY
32451: LIST
32452: LIST
32453: PUSH
32454: LD_INT 2
32456: PUSH
32457: LD_INT 1
32459: PUSH
32460: EMPTY
32461: LIST
32462: LIST
32463: PUSH
32464: LD_INT 2
32466: PUSH
32467: LD_INT 2
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 1
32476: PUSH
32477: LD_INT 2
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 0
32486: PUSH
32487: LD_INT 2
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 1
32496: NEG
32497: PUSH
32498: LD_INT 1
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 2
32507: NEG
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: EMPTY
32513: LIST
32514: LIST
32515: PUSH
32516: LD_INT 2
32518: NEG
32519: PUSH
32520: LD_INT 1
32522: NEG
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PUSH
32528: LD_INT 2
32530: NEG
32531: PUSH
32532: LD_INT 2
32534: NEG
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 1
32542: NEG
32543: PUSH
32544: LD_INT 2
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 2
32553: NEG
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 3
32564: NEG
32565: PUSH
32566: LD_INT 1
32568: NEG
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 3
32576: NEG
32577: PUSH
32578: LD_INT 2
32580: NEG
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: EMPTY
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32611: LD_ADDR_VAR 0 28
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: LD_INT 0
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 0
32628: PUSH
32629: LD_INT 1
32631: NEG
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: LD_INT 0
32642: PUSH
32643: EMPTY
32644: LIST
32645: LIST
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: LD_INT 1
32652: PUSH
32653: EMPTY
32654: LIST
32655: LIST
32656: PUSH
32657: LD_INT 0
32659: PUSH
32660: LD_INT 1
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: LD_INT 1
32669: NEG
32670: PUSH
32671: LD_INT 0
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: NEG
32681: PUSH
32682: LD_INT 1
32684: NEG
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: LD_INT 2
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 0
32704: PUSH
32705: LD_INT 2
32707: NEG
32708: PUSH
32709: EMPTY
32710: LIST
32711: LIST
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: LD_INT 1
32718: NEG
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: PUSH
32724: LD_INT 2
32726: PUSH
32727: LD_INT 0
32729: PUSH
32730: EMPTY
32731: LIST
32732: LIST
32733: PUSH
32734: LD_INT 2
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: EMPTY
32741: LIST
32742: LIST
32743: PUSH
32744: LD_INT 2
32746: PUSH
32747: LD_INT 2
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: LD_INT 2
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: LD_INT 2
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 1
32776: NEG
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 2
32787: NEG
32788: PUSH
32789: LD_INT 0
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 2
32798: NEG
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 2
32810: NEG
32811: PUSH
32812: LD_INT 2
32814: NEG
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 2
32822: NEG
32823: PUSH
32824: LD_INT 3
32826: NEG
32827: PUSH
32828: EMPTY
32829: LIST
32830: LIST
32831: PUSH
32832: LD_INT 1
32834: NEG
32835: PUSH
32836: LD_INT 3
32838: NEG
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: PUSH
32844: LD_INT 3
32846: NEG
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: EMPTY
32853: LIST
32854: LIST
32855: PUSH
32856: LD_INT 3
32858: NEG
32859: PUSH
32860: LD_INT 2
32862: NEG
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32893: LD_ADDR_VAR 0 29
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 0
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: LD_INT 1
32913: NEG
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 1
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: EMPTY
32926: LIST
32927: LIST
32928: PUSH
32929: LD_INT 1
32931: PUSH
32932: LD_INT 1
32934: PUSH
32935: EMPTY
32936: LIST
32937: LIST
32938: PUSH
32939: LD_INT 0
32941: PUSH
32942: LD_INT 1
32944: PUSH
32945: EMPTY
32946: LIST
32947: LIST
32948: PUSH
32949: LD_INT 1
32951: NEG
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PUSH
32960: LD_INT 1
32962: NEG
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: EMPTY
32969: LIST
32970: LIST
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: LD_INT 2
32978: NEG
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 0
32986: PUSH
32987: LD_INT 2
32989: NEG
32990: PUSH
32991: EMPTY
32992: LIST
32993: LIST
32994: PUSH
32995: LD_INT 1
32997: PUSH
32998: LD_INT 1
33000: NEG
33001: PUSH
33002: EMPTY
33003: LIST
33004: LIST
33005: PUSH
33006: LD_INT 2
33008: PUSH
33009: LD_INT 0
33011: PUSH
33012: EMPTY
33013: LIST
33014: LIST
33015: PUSH
33016: LD_INT 2
33018: PUSH
33019: LD_INT 1
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: LD_INT 2
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 0
33038: PUSH
33039: LD_INT 2
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 1
33048: NEG
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: EMPTY
33054: LIST
33055: LIST
33056: PUSH
33057: LD_INT 2
33059: NEG
33060: PUSH
33061: LD_INT 1
33063: NEG
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 2
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: NEG
33084: PUSH
33085: LD_INT 3
33087: NEG
33088: PUSH
33089: EMPTY
33090: LIST
33091: LIST
33092: PUSH
33093: LD_INT 2
33095: PUSH
33096: LD_INT 1
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 3
33106: PUSH
33107: LD_INT 1
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 1
33116: PUSH
33117: LD_INT 3
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: LD_INT 2
33130: PUSH
33131: EMPTY
33132: LIST
33133: LIST
33134: PUSH
33135: LD_INT 3
33137: NEG
33138: PUSH
33139: LD_INT 2
33141: NEG
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: EMPTY
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33172: LD_ADDR_VAR 0 30
33176: PUSH
33177: LD_INT 0
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 0
33189: PUSH
33190: LD_INT 1
33192: NEG
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: LD_INT 0
33203: PUSH
33204: EMPTY
33205: LIST
33206: LIST
33207: PUSH
33208: LD_INT 1
33210: PUSH
33211: LD_INT 1
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 0
33220: PUSH
33221: LD_INT 1
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 1
33230: NEG
33231: PUSH
33232: LD_INT 0
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 1
33241: NEG
33242: PUSH
33243: LD_INT 1
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 1
33253: NEG
33254: PUSH
33255: LD_INT 2
33257: NEG
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 0
33265: PUSH
33266: LD_INT 2
33268: NEG
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: PUSH
33274: LD_INT 1
33276: PUSH
33277: LD_INT 1
33279: NEG
33280: PUSH
33281: EMPTY
33282: LIST
33283: LIST
33284: PUSH
33285: LD_INT 2
33287: PUSH
33288: LD_INT 0
33290: PUSH
33291: EMPTY
33292: LIST
33293: LIST
33294: PUSH
33295: LD_INT 2
33297: PUSH
33298: LD_INT 1
33300: PUSH
33301: EMPTY
33302: LIST
33303: LIST
33304: PUSH
33305: LD_INT 2
33307: PUSH
33308: LD_INT 2
33310: PUSH
33311: EMPTY
33312: LIST
33313: LIST
33314: PUSH
33315: LD_INT 1
33317: PUSH
33318: LD_INT 2
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 1
33327: NEG
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 2
33338: NEG
33339: PUSH
33340: LD_INT 0
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: PUSH
33347: LD_INT 2
33349: NEG
33350: PUSH
33351: LD_INT 1
33353: NEG
33354: PUSH
33355: EMPTY
33356: LIST
33357: LIST
33358: PUSH
33359: LD_INT 1
33361: NEG
33362: PUSH
33363: LD_INT 3
33365: NEG
33366: PUSH
33367: EMPTY
33368: LIST
33369: LIST
33370: PUSH
33371: LD_INT 1
33373: PUSH
33374: LD_INT 2
33376: NEG
33377: PUSH
33378: EMPTY
33379: LIST
33380: LIST
33381: PUSH
33382: LD_INT 3
33384: PUSH
33385: LD_INT 2
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 2
33394: PUSH
33395: LD_INT 3
33397: PUSH
33398: EMPTY
33399: LIST
33400: LIST
33401: PUSH
33402: LD_INT 2
33404: NEG
33405: PUSH
33406: LD_INT 1
33408: PUSH
33409: EMPTY
33410: LIST
33411: LIST
33412: PUSH
33413: LD_INT 3
33415: NEG
33416: PUSH
33417: LD_INT 1
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33450: LD_ADDR_VAR 0 31
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 0
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: LD_INT 1
33470: NEG
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 1
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: EMPTY
33483: LIST
33484: LIST
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: LD_INT 1
33491: PUSH
33492: EMPTY
33493: LIST
33494: LIST
33495: PUSH
33496: LD_INT 0
33498: PUSH
33499: LD_INT 1
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: LD_INT 0
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: NEG
33520: PUSH
33521: LD_INT 1
33523: NEG
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: LD_INT 2
33535: NEG
33536: PUSH
33537: EMPTY
33538: LIST
33539: LIST
33540: PUSH
33541: LD_INT 1
33543: PUSH
33544: LD_INT 1
33546: NEG
33547: PUSH
33548: EMPTY
33549: LIST
33550: LIST
33551: PUSH
33552: LD_INT 2
33554: PUSH
33555: LD_INT 0
33557: PUSH
33558: EMPTY
33559: LIST
33560: LIST
33561: PUSH
33562: LD_INT 2
33564: PUSH
33565: LD_INT 1
33567: PUSH
33568: EMPTY
33569: LIST
33570: LIST
33571: PUSH
33572: LD_INT 2
33574: PUSH
33575: LD_INT 2
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: LD_INT 2
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 0
33594: PUSH
33595: LD_INT 2
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 1
33604: NEG
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: PUSH
33613: LD_INT 2
33615: NEG
33616: PUSH
33617: LD_INT 1
33619: NEG
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PUSH
33625: LD_INT 2
33627: NEG
33628: PUSH
33629: LD_INT 2
33631: NEG
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: LD_INT 3
33643: NEG
33644: PUSH
33645: EMPTY
33646: LIST
33647: LIST
33648: PUSH
33649: LD_INT 2
33651: PUSH
33652: LD_INT 1
33654: NEG
33655: PUSH
33656: EMPTY
33657: LIST
33658: LIST
33659: PUSH
33660: LD_INT 3
33662: PUSH
33663: LD_INT 1
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: PUSH
33673: LD_INT 3
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: LD_INT 2
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: LD_INT 3
33693: NEG
33694: PUSH
33695: LD_INT 2
33697: NEG
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: EMPTY
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33728: LD_ADDR_VAR 0 32
33732: PUSH
33733: LD_INT 0
33735: PUSH
33736: LD_INT 0
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: PUSH
33743: LD_INT 0
33745: PUSH
33746: LD_INT 1
33748: NEG
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 1
33756: PUSH
33757: LD_INT 0
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: PUSH
33767: LD_INT 1
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 0
33776: PUSH
33777: LD_INT 1
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: LD_INT 0
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 1
33797: NEG
33798: PUSH
33799: LD_INT 1
33801: NEG
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: LD_INT 1
33809: NEG
33810: PUSH
33811: LD_INT 2
33813: NEG
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 0
33821: PUSH
33822: LD_INT 2
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 1
33832: PUSH
33833: LD_INT 1
33835: NEG
33836: PUSH
33837: EMPTY
33838: LIST
33839: LIST
33840: PUSH
33841: LD_INT 2
33843: PUSH
33844: LD_INT 1
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: LD_INT 2
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 2
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 2
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 1
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 2
33894: NEG
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: EMPTY
33900: LIST
33901: LIST
33902: PUSH
33903: LD_INT 2
33905: NEG
33906: PUSH
33907: LD_INT 1
33909: NEG
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 1
33917: NEG
33918: PUSH
33919: LD_INT 3
33921: NEG
33922: PUSH
33923: EMPTY
33924: LIST
33925: LIST
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: LD_INT 2
33932: NEG
33933: PUSH
33934: EMPTY
33935: LIST
33936: LIST
33937: PUSH
33938: LD_INT 3
33940: PUSH
33941: LD_INT 2
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 2
33950: PUSH
33951: LD_INT 3
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 2
33960: NEG
33961: PUSH
33962: LD_INT 1
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: LD_INT 3
33971: NEG
33972: PUSH
33973: LD_INT 1
33975: NEG
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34006: LD_ADDR_VAR 0 33
34010: PUSH
34011: LD_INT 0
34013: PUSH
34014: LD_INT 0
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 0
34023: PUSH
34024: LD_INT 1
34026: NEG
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 1
34034: PUSH
34035: LD_INT 0
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: PUSH
34042: LD_INT 1
34044: PUSH
34045: LD_INT 1
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 0
34054: PUSH
34055: LD_INT 1
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 1
34064: NEG
34065: PUSH
34066: LD_INT 0
34068: PUSH
34069: EMPTY
34070: LIST
34071: LIST
34072: PUSH
34073: LD_INT 1
34075: NEG
34076: PUSH
34077: LD_INT 1
34079: NEG
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: LD_INT 2
34091: NEG
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 1
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 2
34110: PUSH
34111: LD_INT 0
34113: PUSH
34114: EMPTY
34115: LIST
34116: LIST
34117: PUSH
34118: LD_INT 2
34120: PUSH
34121: LD_INT 1
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 1
34130: PUSH
34131: LD_INT 2
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 0
34140: PUSH
34141: LD_INT 2
34143: PUSH
34144: EMPTY
34145: LIST
34146: LIST
34147: PUSH
34148: LD_INT 1
34150: NEG
34151: PUSH
34152: LD_INT 1
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 2
34161: NEG
34162: PUSH
34163: LD_INT 0
34165: PUSH
34166: EMPTY
34167: LIST
34168: LIST
34169: PUSH
34170: LD_INT 2
34172: NEG
34173: PUSH
34174: LD_INT 1
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 2
34184: NEG
34185: PUSH
34186: LD_INT 2
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: NEG
34197: PUSH
34198: LD_INT 3
34200: NEG
34201: PUSH
34202: EMPTY
34203: LIST
34204: LIST
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: LD_INT 1
34211: NEG
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 3
34219: PUSH
34220: LD_INT 1
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: LD_INT 3
34232: PUSH
34233: EMPTY
34234: LIST
34235: LIST
34236: PUSH
34237: LD_INT 1
34239: NEG
34240: PUSH
34241: LD_INT 2
34243: PUSH
34244: EMPTY
34245: LIST
34246: LIST
34247: PUSH
34248: LD_INT 3
34250: NEG
34251: PUSH
34252: LD_INT 2
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34285: LD_ADDR_VAR 0 34
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 0
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: LD_INT 1
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: PUSH
34314: LD_INT 0
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 1
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 1
34343: NEG
34344: PUSH
34345: LD_INT 0
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: NEG
34355: PUSH
34356: LD_INT 1
34358: NEG
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 1
34366: NEG
34367: PUSH
34368: LD_INT 2
34370: NEG
34371: PUSH
34372: EMPTY
34373: LIST
34374: LIST
34375: PUSH
34376: LD_INT 0
34378: PUSH
34379: LD_INT 2
34381: NEG
34382: PUSH
34383: EMPTY
34384: LIST
34385: LIST
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: LD_INT 1
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 1
34403: PUSH
34404: EMPTY
34405: LIST
34406: LIST
34407: PUSH
34408: LD_INT 2
34410: PUSH
34411: LD_INT 2
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 2
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: LD_INT 1
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 2
34441: NEG
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 2
34452: NEG
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: NEG
34465: PUSH
34466: LD_INT 2
34468: NEG
34469: PUSH
34470: EMPTY
34471: LIST
34472: LIST
34473: PUSH
34474: LD_INT 1
34476: NEG
34477: PUSH
34478: LD_INT 3
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: LD_INT 2
34491: NEG
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 3
34499: PUSH
34500: LD_INT 2
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: LD_INT 3
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 2
34519: NEG
34520: PUSH
34521: LD_INT 1
34523: PUSH
34524: EMPTY
34525: LIST
34526: LIST
34527: PUSH
34528: LD_INT 3
34530: NEG
34531: PUSH
34532: LD_INT 1
34534: NEG
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34565: LD_ADDR_VAR 0 35
34569: PUSH
34570: LD_INT 0
34572: PUSH
34573: LD_INT 0
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 0
34582: PUSH
34583: LD_INT 1
34585: NEG
34586: PUSH
34587: EMPTY
34588: LIST
34589: LIST
34590: PUSH
34591: LD_INT 1
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: PUSH
34604: LD_INT 1
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: LD_INT 0
34613: PUSH
34614: LD_INT 1
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 1
34623: NEG
34624: PUSH
34625: LD_INT 0
34627: PUSH
34628: EMPTY
34629: LIST
34630: LIST
34631: PUSH
34632: LD_INT 1
34634: NEG
34635: PUSH
34636: LD_INT 1
34638: NEG
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: LD_INT 1
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 2
34656: NEG
34657: PUSH
34658: LD_INT 1
34660: NEG
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: EMPTY
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34677: LD_ADDR_VAR 0 36
34681: PUSH
34682: LD_INT 0
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 0
34694: PUSH
34695: LD_INT 1
34697: NEG
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 1
34705: PUSH
34706: LD_INT 0
34708: PUSH
34709: EMPTY
34710: LIST
34711: LIST
34712: PUSH
34713: LD_INT 1
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 0
34725: PUSH
34726: LD_INT 1
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 1
34735: NEG
34736: PUSH
34737: LD_INT 0
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: LD_INT 1
34750: NEG
34751: PUSH
34752: EMPTY
34753: LIST
34754: LIST
34755: PUSH
34756: LD_INT 1
34758: NEG
34759: PUSH
34760: LD_INT 2
34762: NEG
34763: PUSH
34764: EMPTY
34765: LIST
34766: LIST
34767: PUSH
34768: LD_INT 1
34770: PUSH
34771: LD_INT 2
34773: PUSH
34774: EMPTY
34775: LIST
34776: LIST
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: LIST
34787: LIST
34788: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34789: LD_ADDR_VAR 0 37
34793: PUSH
34794: LD_INT 0
34796: PUSH
34797: LD_INT 0
34799: PUSH
34800: EMPTY
34801: LIST
34802: LIST
34803: PUSH
34804: LD_INT 0
34806: PUSH
34807: LD_INT 1
34809: NEG
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 1
34817: PUSH
34818: LD_INT 0
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: PUSH
34825: LD_INT 1
34827: PUSH
34828: LD_INT 1
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 0
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 1
34847: NEG
34848: PUSH
34849: LD_INT 0
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: LD_INT 1
34862: NEG
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 1
34873: NEG
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: LD_INT 1
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34901: LD_ADDR_VAR 0 38
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 0
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 1
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: EMPTY
34934: LIST
34935: LIST
34936: PUSH
34937: LD_INT 1
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 1
34952: PUSH
34953: EMPTY
34954: LIST
34955: LIST
34956: PUSH
34957: LD_INT 1
34959: NEG
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: EMPTY
34965: LIST
34966: LIST
34967: PUSH
34968: LD_INT 1
34970: NEG
34971: PUSH
34972: LD_INT 1
34974: NEG
34975: PUSH
34976: EMPTY
34977: LIST
34978: LIST
34979: PUSH
34980: LD_INT 2
34982: PUSH
34983: LD_INT 1
34985: PUSH
34986: EMPTY
34987: LIST
34988: LIST
34989: PUSH
34990: LD_INT 2
34992: NEG
34993: PUSH
34994: LD_INT 1
34996: NEG
34997: PUSH
34998: EMPTY
34999: LIST
35000: LIST
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: LIST
35009: LIST
35010: LIST
35011: LIST
35012: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35013: LD_ADDR_VAR 0 39
35017: PUSH
35018: LD_INT 0
35020: PUSH
35021: LD_INT 0
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PUSH
35028: LD_INT 0
35030: PUSH
35031: LD_INT 1
35033: NEG
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 1
35041: PUSH
35042: LD_INT 0
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 1
35051: PUSH
35052: LD_INT 1
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 0
35061: PUSH
35062: LD_INT 1
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 1
35071: NEG
35072: PUSH
35073: LD_INT 0
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 1
35082: NEG
35083: PUSH
35084: LD_INT 1
35086: NEG
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 1
35094: NEG
35095: PUSH
35096: LD_INT 2
35098: NEG
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: LD_INT 1
35106: PUSH
35107: LD_INT 2
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35125: LD_ADDR_VAR 0 40
35129: PUSH
35130: LD_INT 0
35132: PUSH
35133: LD_INT 0
35135: PUSH
35136: EMPTY
35137: LIST
35138: LIST
35139: PUSH
35140: LD_INT 0
35142: PUSH
35143: LD_INT 1
35145: NEG
35146: PUSH
35147: EMPTY
35148: LIST
35149: LIST
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: LD_INT 0
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: LD_INT 1
35166: PUSH
35167: EMPTY
35168: LIST
35169: LIST
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: LD_INT 1
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: LD_INT 0
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 1
35194: NEG
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: PUSH
35207: LD_INT 1
35209: NEG
35210: PUSH
35211: EMPTY
35212: LIST
35213: LIST
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: LD_INT 1
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35237: LD_ADDR_VAR 0 41
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: LD_INT 0
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 0
35254: PUSH
35255: LD_INT 1
35257: NEG
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 1
35265: PUSH
35266: LD_INT 0
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 0
35285: PUSH
35286: LD_INT 1
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 1
35295: NEG
35296: PUSH
35297: LD_INT 0
35299: PUSH
35300: EMPTY
35301: LIST
35302: LIST
35303: PUSH
35304: LD_INT 1
35306: NEG
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: LD_INT 2
35322: NEG
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 1
35330: PUSH
35331: LD_INT 1
35333: NEG
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 2
35341: PUSH
35342: LD_INT 0
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 2
35351: PUSH
35352: LD_INT 1
35354: PUSH
35355: EMPTY
35356: LIST
35357: LIST
35358: PUSH
35359: LD_INT 2
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 1
35371: PUSH
35372: LD_INT 2
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 1
35381: NEG
35382: PUSH
35383: LD_INT 1
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 2
35392: NEG
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 2
35403: NEG
35404: PUSH
35405: LD_INT 1
35407: NEG
35408: PUSH
35409: EMPTY
35410: LIST
35411: LIST
35412: PUSH
35413: LD_INT 2
35415: NEG
35416: PUSH
35417: LD_INT 2
35419: NEG
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 2
35427: NEG
35428: PUSH
35429: LD_INT 3
35431: NEG
35432: PUSH
35433: EMPTY
35434: LIST
35435: LIST
35436: PUSH
35437: LD_INT 2
35439: PUSH
35440: LD_INT 1
35442: NEG
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 3
35450: PUSH
35451: LD_INT 0
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 3
35460: PUSH
35461: LD_INT 1
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 3
35470: PUSH
35471: LD_INT 2
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 3
35480: PUSH
35481: LD_INT 3
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 2
35490: PUSH
35491: LD_INT 3
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PUSH
35498: LD_INT 2
35500: NEG
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 3
35511: NEG
35512: PUSH
35513: LD_INT 0
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 3
35522: NEG
35523: PUSH
35524: LD_INT 1
35526: NEG
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 3
35534: NEG
35535: PUSH
35536: LD_INT 2
35538: NEG
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 3
35546: NEG
35547: PUSH
35548: LD_INT 3
35550: NEG
35551: PUSH
35552: EMPTY
35553: LIST
35554: LIST
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: LIST
35560: LIST
35561: LIST
35562: LIST
35563: LIST
35564: LIST
35565: LIST
35566: LIST
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: LIST
35583: LIST
35584: LIST
35585: LIST
35586: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35587: LD_ADDR_VAR 0 42
35591: PUSH
35592: LD_INT 0
35594: PUSH
35595: LD_INT 0
35597: PUSH
35598: EMPTY
35599: LIST
35600: LIST
35601: PUSH
35602: LD_INT 0
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: LD_INT 0
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 0
35635: PUSH
35636: LD_INT 1
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: PUSH
35643: LD_INT 1
35645: NEG
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 1
35656: NEG
35657: PUSH
35658: LD_INT 1
35660: NEG
35661: PUSH
35662: EMPTY
35663: LIST
35664: LIST
35665: PUSH
35666: LD_INT 1
35668: NEG
35669: PUSH
35670: LD_INT 2
35672: NEG
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: LD_INT 2
35683: NEG
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 1
35691: PUSH
35692: LD_INT 1
35694: NEG
35695: PUSH
35696: EMPTY
35697: LIST
35698: LIST
35699: PUSH
35700: LD_INT 2
35702: PUSH
35703: LD_INT 1
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 2
35712: PUSH
35713: LD_INT 2
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: PUSH
35723: LD_INT 2
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 0
35732: PUSH
35733: LD_INT 2
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 1
35742: NEG
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: LD_INT 2
35753: NEG
35754: PUSH
35755: LD_INT 1
35757: NEG
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: LD_INT 2
35765: NEG
35766: PUSH
35767: LD_INT 2
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: LD_INT 3
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 3
35793: NEG
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 3
35804: NEG
35805: PUSH
35806: EMPTY
35807: LIST
35808: LIST
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: LD_INT 2
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 3
35823: PUSH
35824: LD_INT 2
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 3
35833: PUSH
35834: LD_INT 3
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: PUSH
35844: LD_INT 3
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: LD_INT 1
35853: PUSH
35854: LD_INT 3
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 3
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 2
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 3
35884: NEG
35885: PUSH
35886: LD_INT 2
35888: NEG
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 3
35896: NEG
35897: PUSH
35898: LD_INT 3
35900: NEG
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35937: LD_ADDR_VAR 0 43
35941: PUSH
35942: LD_INT 0
35944: PUSH
35945: LD_INT 0
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 0
35954: PUSH
35955: LD_INT 1
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 1
35965: PUSH
35966: LD_INT 0
35968: PUSH
35969: EMPTY
35970: LIST
35971: LIST
35972: PUSH
35973: LD_INT 1
35975: PUSH
35976: LD_INT 1
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: LD_INT 1
35988: PUSH
35989: EMPTY
35990: LIST
35991: LIST
35992: PUSH
35993: LD_INT 1
35995: NEG
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: EMPTY
36013: LIST
36014: LIST
36015: PUSH
36016: LD_INT 1
36018: NEG
36019: PUSH
36020: LD_INT 2
36022: NEG
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: PUSH
36028: LD_INT 0
36030: PUSH
36031: LD_INT 2
36033: NEG
36034: PUSH
36035: EMPTY
36036: LIST
36037: LIST
36038: PUSH
36039: LD_INT 1
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: EMPTY
36047: LIST
36048: LIST
36049: PUSH
36050: LD_INT 2
36052: PUSH
36053: LD_INT 0
36055: PUSH
36056: EMPTY
36057: LIST
36058: LIST
36059: PUSH
36060: LD_INT 2
36062: PUSH
36063: LD_INT 1
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 1
36072: PUSH
36073: LD_INT 2
36075: PUSH
36076: EMPTY
36077: LIST
36078: LIST
36079: PUSH
36080: LD_INT 0
36082: PUSH
36083: LD_INT 2
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 1
36092: NEG
36093: PUSH
36094: LD_INT 1
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 2
36103: NEG
36104: PUSH
36105: LD_INT 0
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 2
36114: NEG
36115: PUSH
36116: LD_INT 1
36118: NEG
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 1
36126: NEG
36127: PUSH
36128: LD_INT 3
36130: NEG
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 0
36138: PUSH
36139: LD_INT 3
36141: NEG
36142: PUSH
36143: EMPTY
36144: LIST
36145: LIST
36146: PUSH
36147: LD_INT 1
36149: PUSH
36150: LD_INT 2
36152: NEG
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 2
36160: PUSH
36161: LD_INT 1
36163: NEG
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 3
36171: PUSH
36172: LD_INT 0
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 3
36181: PUSH
36182: LD_INT 1
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 1
36191: PUSH
36192: LD_INT 3
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 0
36201: PUSH
36202: LD_INT 3
36204: PUSH
36205: EMPTY
36206: LIST
36207: LIST
36208: PUSH
36209: LD_INT 1
36211: NEG
36212: PUSH
36213: LD_INT 2
36215: PUSH
36216: EMPTY
36217: LIST
36218: LIST
36219: PUSH
36220: LD_INT 2
36222: NEG
36223: PUSH
36224: LD_INT 1
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 3
36233: NEG
36234: PUSH
36235: LD_INT 0
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 3
36244: NEG
36245: PUSH
36246: LD_INT 1
36248: NEG
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: LIST
36269: LIST
36270: LIST
36271: LIST
36272: LIST
36273: LIST
36274: LIST
36275: LIST
36276: LIST
36277: LIST
36278: LIST
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36285: LD_ADDR_VAR 0 44
36289: PUSH
36290: LD_INT 0
36292: PUSH
36293: LD_INT 0
36295: PUSH
36296: EMPTY
36297: LIST
36298: LIST
36299: PUSH
36300: LD_INT 0
36302: PUSH
36303: LD_INT 1
36305: NEG
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: PUSH
36314: LD_INT 0
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 1
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 0
36333: PUSH
36334: LD_INT 1
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: NEG
36344: PUSH
36345: LD_INT 0
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: LD_INT 1
36358: NEG
36359: PUSH
36360: EMPTY
36361: LIST
36362: LIST
36363: PUSH
36364: LD_INT 1
36366: NEG
36367: PUSH
36368: LD_INT 2
36370: NEG
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PUSH
36376: LD_INT 1
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 2
36389: PUSH
36390: LD_INT 0
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 2
36399: PUSH
36400: LD_INT 1
36402: PUSH
36403: EMPTY
36404: LIST
36405: LIST
36406: PUSH
36407: LD_INT 2
36409: PUSH
36410: LD_INT 2
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: PUSH
36417: LD_INT 1
36419: PUSH
36420: LD_INT 2
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 2
36440: NEG
36441: PUSH
36442: LD_INT 0
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 2
36451: NEG
36452: PUSH
36453: LD_INT 1
36455: NEG
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 2
36463: NEG
36464: PUSH
36465: LD_INT 2
36467: NEG
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 2
36475: NEG
36476: PUSH
36477: LD_INT 3
36479: NEG
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 2
36487: PUSH
36488: LD_INT 1
36490: NEG
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 3
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: EMPTY
36503: LIST
36504: LIST
36505: PUSH
36506: LD_INT 3
36508: PUSH
36509: LD_INT 1
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 3
36518: PUSH
36519: LD_INT 2
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: LD_INT 3
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 2
36538: PUSH
36539: LD_INT 3
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 2
36548: NEG
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 3
36559: NEG
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 3
36570: NEG
36571: PUSH
36572: LD_INT 1
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 3
36582: NEG
36583: PUSH
36584: LD_INT 2
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 3
36594: NEG
36595: PUSH
36596: LD_INT 3
36598: NEG
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: LIST
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: LIST
36632: LIST
36633: LIST
36634: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36635: LD_ADDR_VAR 0 45
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 0
36652: PUSH
36653: LD_INT 1
36655: NEG
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 1
36663: PUSH
36664: LD_INT 0
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: LD_INT 1
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 0
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 1
36693: NEG
36694: PUSH
36695: LD_INT 0
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 1
36704: NEG
36705: PUSH
36706: LD_INT 1
36708: NEG
36709: PUSH
36710: EMPTY
36711: LIST
36712: LIST
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: LD_INT 2
36720: NEG
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PUSH
36726: LD_INT 0
36728: PUSH
36729: LD_INT 2
36731: NEG
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: LD_INT 1
36742: NEG
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 2
36750: PUSH
36751: LD_INT 1
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 2
36760: PUSH
36761: LD_INT 2
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: PUSH
36771: LD_INT 2
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 0
36780: PUSH
36781: LD_INT 2
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: NEG
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 2
36801: NEG
36802: PUSH
36803: LD_INT 1
36805: NEG
36806: PUSH
36807: EMPTY
36808: LIST
36809: LIST
36810: PUSH
36811: LD_INT 2
36813: NEG
36814: PUSH
36815: LD_INT 2
36817: NEG
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 2
36825: NEG
36826: PUSH
36827: LD_INT 3
36829: NEG
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 3
36841: NEG
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 0
36849: PUSH
36850: LD_INT 3
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 2
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 3
36871: PUSH
36872: LD_INT 2
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 3
36881: PUSH
36882: LD_INT 3
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 3
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 3
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: LD_INT 3
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: LD_INT 2
36925: PUSH
36926: EMPTY
36927: LIST
36928: LIST
36929: PUSH
36930: LD_INT 3
36932: NEG
36933: PUSH
36934: LD_INT 2
36936: NEG
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 3
36944: NEG
36945: PUSH
36946: LD_INT 3
36948: NEG
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: LIST
36967: LIST
36968: LIST
36969: LIST
36970: LIST
36971: LIST
36972: LIST
36973: LIST
36974: LIST
36975: LIST
36976: LIST
36977: LIST
36978: LIST
36979: LIST
36980: LIST
36981: LIST
36982: LIST
36983: LIST
36984: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36985: LD_ADDR_VAR 0 46
36989: PUSH
36990: LD_INT 0
36992: PUSH
36993: LD_INT 0
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 0
37002: PUSH
37003: LD_INT 1
37005: NEG
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 1
37013: PUSH
37014: LD_INT 0
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 1
37023: PUSH
37024: LD_INT 1
37026: PUSH
37027: EMPTY
37028: LIST
37029: LIST
37030: PUSH
37031: LD_INT 0
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: EMPTY
37038: LIST
37039: LIST
37040: PUSH
37041: LD_INT 1
37043: NEG
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: LD_INT 1
37058: NEG
37059: PUSH
37060: EMPTY
37061: LIST
37062: LIST
37063: PUSH
37064: LD_INT 1
37066: NEG
37067: PUSH
37068: LD_INT 2
37070: NEG
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PUSH
37076: LD_INT 0
37078: PUSH
37079: LD_INT 2
37081: NEG
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 1
37089: PUSH
37090: LD_INT 1
37092: NEG
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 2
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 2
37110: PUSH
37111: LD_INT 1
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 1
37120: PUSH
37121: LD_INT 2
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 0
37130: PUSH
37131: LD_INT 2
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: LD_INT 1
37144: PUSH
37145: EMPTY
37146: LIST
37147: LIST
37148: PUSH
37149: LD_INT 2
37151: NEG
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 2
37162: NEG
37163: PUSH
37164: LD_INT 1
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 1
37174: NEG
37175: PUSH
37176: LD_INT 3
37178: NEG
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 3
37189: NEG
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: LD_INT 2
37200: NEG
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 2
37208: PUSH
37209: LD_INT 1
37211: NEG
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 3
37219: PUSH
37220: LD_INT 0
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 3
37229: PUSH
37230: LD_INT 1
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 1
37239: PUSH
37240: LD_INT 3
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: LD_INT 3
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: LD_INT 2
37263: PUSH
37264: EMPTY
37265: LIST
37266: LIST
37267: PUSH
37268: LD_INT 2
37270: NEG
37271: PUSH
37272: LD_INT 1
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 3
37281: NEG
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 3
37292: NEG
37293: PUSH
37294: LD_INT 1
37296: NEG
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37333: LD_ADDR_VAR 0 47
37337: PUSH
37338: LD_INT 0
37340: PUSH
37341: LD_INT 0
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: PUSH
37348: LD_INT 0
37350: PUSH
37351: LD_INT 1
37353: NEG
37354: PUSH
37355: EMPTY
37356: LIST
37357: LIST
37358: PUSH
37359: LD_INT 1
37361: PUSH
37362: LD_INT 0
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 1
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 0
37381: PUSH
37382: LD_INT 1
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 1
37391: NEG
37392: PUSH
37393: LD_INT 0
37395: PUSH
37396: EMPTY
37397: LIST
37398: LIST
37399: PUSH
37400: LD_INT 1
37402: NEG
37403: PUSH
37404: LD_INT 1
37406: NEG
37407: PUSH
37408: EMPTY
37409: LIST
37410: LIST
37411: PUSH
37412: LD_INT 1
37414: NEG
37415: PUSH
37416: LD_INT 2
37418: NEG
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 0
37426: PUSH
37427: LD_INT 2
37429: NEG
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 1
37437: PUSH
37438: LD_INT 1
37440: NEG
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 2
37448: NEG
37449: PUSH
37450: LD_INT 1
37452: NEG
37453: PUSH
37454: EMPTY
37455: LIST
37456: LIST
37457: PUSH
37458: LD_INT 2
37460: NEG
37461: PUSH
37462: LD_INT 2
37464: NEG
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: EMPTY
37471: LIST
37472: LIST
37473: LIST
37474: LIST
37475: LIST
37476: LIST
37477: LIST
37478: LIST
37479: LIST
37480: LIST
37481: LIST
37482: LIST
37483: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37484: LD_ADDR_VAR 0 48
37488: PUSH
37489: LD_INT 0
37491: PUSH
37492: LD_INT 0
37494: PUSH
37495: EMPTY
37496: LIST
37497: LIST
37498: PUSH
37499: LD_INT 0
37501: PUSH
37502: LD_INT 1
37504: NEG
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 1
37512: PUSH
37513: LD_INT 0
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: PUSH
37523: LD_INT 1
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: LD_INT 0
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 1
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: NEG
37566: PUSH
37567: LD_INT 2
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 0
37577: PUSH
37578: LD_INT 2
37580: NEG
37581: PUSH
37582: EMPTY
37583: LIST
37584: LIST
37585: PUSH
37586: LD_INT 1
37588: PUSH
37589: LD_INT 1
37591: NEG
37592: PUSH
37593: EMPTY
37594: LIST
37595: LIST
37596: PUSH
37597: LD_INT 2
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 2
37609: PUSH
37610: LD_INT 1
37612: PUSH
37613: EMPTY
37614: LIST
37615: LIST
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: LIST
37621: LIST
37622: LIST
37623: LIST
37624: LIST
37625: LIST
37626: LIST
37627: LIST
37628: LIST
37629: LIST
37630: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37631: LD_ADDR_VAR 0 49
37635: PUSH
37636: LD_INT 0
37638: PUSH
37639: LD_INT 0
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 0
37648: PUSH
37649: LD_INT 1
37651: NEG
37652: PUSH
37653: EMPTY
37654: LIST
37655: LIST
37656: PUSH
37657: LD_INT 1
37659: PUSH
37660: LD_INT 0
37662: PUSH
37663: EMPTY
37664: LIST
37665: LIST
37666: PUSH
37667: LD_INT 1
37669: PUSH
37670: LD_INT 1
37672: PUSH
37673: EMPTY
37674: LIST
37675: LIST
37676: PUSH
37677: LD_INT 0
37679: PUSH
37680: LD_INT 1
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: NEG
37690: PUSH
37691: LD_INT 0
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 1
37700: NEG
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: LD_INT 2
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: EMPTY
37728: LIST
37729: LIST
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: LD_INT 2
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PUSH
37751: LD_INT 1
37753: PUSH
37754: LD_INT 2
37756: PUSH
37757: EMPTY
37758: LIST
37759: LIST
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: LIST
37765: LIST
37766: LIST
37767: LIST
37768: LIST
37769: LIST
37770: LIST
37771: LIST
37772: LIST
37773: LIST
37774: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37775: LD_ADDR_VAR 0 50
37779: PUSH
37780: LD_INT 0
37782: PUSH
37783: LD_INT 0
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 0
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: LD_INT 0
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 1
37813: PUSH
37814: LD_INT 1
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 0
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 1
37844: NEG
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 2
37856: PUSH
37857: LD_INT 1
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 2
37866: PUSH
37867: LD_INT 2
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: LD_INT 2
37879: PUSH
37880: EMPTY
37881: LIST
37882: LIST
37883: PUSH
37884: LD_INT 0
37886: PUSH
37887: LD_INT 2
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 1
37896: NEG
37897: PUSH
37898: LD_INT 1
37900: PUSH
37901: EMPTY
37902: LIST
37903: LIST
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37919: LD_ADDR_VAR 0 51
37923: PUSH
37924: LD_INT 0
37926: PUSH
37927: LD_INT 0
37929: PUSH
37930: EMPTY
37931: LIST
37932: LIST
37933: PUSH
37934: LD_INT 0
37936: PUSH
37937: LD_INT 1
37939: NEG
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 1
37947: PUSH
37948: LD_INT 0
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 1
37957: PUSH
37958: LD_INT 1
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 1
37977: NEG
37978: PUSH
37979: LD_INT 0
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 1
37988: NEG
37989: PUSH
37990: LD_INT 1
37992: NEG
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 1
38000: PUSH
38001: LD_INT 2
38003: PUSH
38004: EMPTY
38005: LIST
38006: LIST
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: LD_INT 2
38013: PUSH
38014: EMPTY
38015: LIST
38016: LIST
38017: PUSH
38018: LD_INT 1
38020: NEG
38021: PUSH
38022: LD_INT 1
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: PUSH
38029: LD_INT 2
38031: NEG
38032: PUSH
38033: LD_INT 0
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 2
38042: NEG
38043: PUSH
38044: LD_INT 1
38046: NEG
38047: PUSH
38048: EMPTY
38049: LIST
38050: LIST
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38066: LD_ADDR_VAR 0 52
38070: PUSH
38071: LD_INT 0
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 0
38083: PUSH
38084: LD_INT 1
38086: NEG
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 1
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: PUSH
38105: LD_INT 1
38107: PUSH
38108: EMPTY
38109: LIST
38110: LIST
38111: PUSH
38112: LD_INT 0
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: EMPTY
38130: LIST
38131: LIST
38132: PUSH
38133: LD_INT 1
38135: NEG
38136: PUSH
38137: LD_INT 1
38139: NEG
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: NEG
38160: PUSH
38161: LD_INT 1
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: NEG
38171: PUSH
38172: LD_INT 0
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PUSH
38179: LD_INT 2
38181: NEG
38182: PUSH
38183: LD_INT 1
38185: NEG
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 2
38193: NEG
38194: PUSH
38195: LD_INT 2
38197: NEG
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: LIST
38207: LIST
38208: LIST
38209: LIST
38210: LIST
38211: LIST
38212: LIST
38213: LIST
38214: LIST
38215: LIST
38216: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38217: LD_ADDR_VAR 0 53
38221: PUSH
38222: LD_INT 0
38224: PUSH
38225: LD_INT 0
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: LD_INT 1
38237: NEG
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: LD_INT 0
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: LD_INT 1
38255: PUSH
38256: LD_INT 1
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 0
38265: PUSH
38266: LD_INT 1
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 1
38275: NEG
38276: PUSH
38277: LD_INT 0
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 1
38286: NEG
38287: PUSH
38288: LD_INT 1
38290: NEG
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 1
38298: NEG
38299: PUSH
38300: LD_INT 2
38302: NEG
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 0
38310: PUSH
38311: LD_INT 2
38313: NEG
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: PUSH
38322: LD_INT 1
38324: NEG
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 2
38332: PUSH
38333: LD_INT 0
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 2
38342: PUSH
38343: LD_INT 1
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 2
38352: PUSH
38353: LD_INT 2
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 1
38362: PUSH
38363: LD_INT 2
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: LD_INT 2
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: LD_INT 1
38386: PUSH
38387: EMPTY
38388: LIST
38389: LIST
38390: PUSH
38391: LD_INT 2
38393: NEG
38394: PUSH
38395: LD_INT 0
38397: PUSH
38398: EMPTY
38399: LIST
38400: LIST
38401: PUSH
38402: LD_INT 2
38404: NEG
38405: PUSH
38406: LD_INT 1
38408: NEG
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 2
38416: NEG
38417: PUSH
38418: LD_INT 2
38420: NEG
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: EMPTY
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: LIST
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: LIST
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38447: LD_ADDR_VAR 0 54
38451: PUSH
38452: LD_INT 0
38454: PUSH
38455: LD_INT 0
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 1
38467: NEG
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 1
38475: PUSH
38476: LD_INT 0
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: LD_INT 1
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 0
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: LD_INT 0
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 1
38516: NEG
38517: PUSH
38518: LD_INT 1
38520: NEG
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: LD_INT 1
38528: NEG
38529: PUSH
38530: LD_INT 2
38532: NEG
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: PUSH
38538: LD_INT 0
38540: PUSH
38541: LD_INT 2
38543: NEG
38544: PUSH
38545: EMPTY
38546: LIST
38547: LIST
38548: PUSH
38549: LD_INT 1
38551: PUSH
38552: LD_INT 1
38554: NEG
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 2
38562: PUSH
38563: LD_INT 0
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 2
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: PUSH
38583: LD_INT 2
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 1
38592: PUSH
38593: LD_INT 2
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: LD_INT 2
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 1
38612: NEG
38613: PUSH
38614: LD_INT 1
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 2
38623: NEG
38624: PUSH
38625: LD_INT 0
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 2
38634: NEG
38635: PUSH
38636: LD_INT 1
38638: NEG
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 2
38646: NEG
38647: PUSH
38648: LD_INT 2
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: EMPTY
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: LIST
38669: LIST
38670: LIST
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38677: LD_ADDR_VAR 0 55
38681: PUSH
38682: LD_INT 0
38684: PUSH
38685: LD_INT 0
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: LD_INT 1
38697: NEG
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: LD_INT 1
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 0
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 1
38735: NEG
38736: PUSH
38737: LD_INT 0
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 1
38746: NEG
38747: PUSH
38748: LD_INT 1
38750: NEG
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 1
38758: NEG
38759: PUSH
38760: LD_INT 2
38762: NEG
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 0
38770: PUSH
38771: LD_INT 2
38773: NEG
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 1
38781: PUSH
38782: LD_INT 1
38784: NEG
38785: PUSH
38786: EMPTY
38787: LIST
38788: LIST
38789: PUSH
38790: LD_INT 2
38792: PUSH
38793: LD_INT 0
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 2
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 2
38812: PUSH
38813: LD_INT 2
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 1
38822: PUSH
38823: LD_INT 2
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 0
38832: PUSH
38833: LD_INT 2
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 1
38842: NEG
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 2
38853: NEG
38854: PUSH
38855: LD_INT 0
38857: PUSH
38858: EMPTY
38859: LIST
38860: LIST
38861: PUSH
38862: LD_INT 2
38864: NEG
38865: PUSH
38866: LD_INT 1
38868: NEG
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 2
38876: NEG
38877: PUSH
38878: LD_INT 2
38880: NEG
38881: PUSH
38882: EMPTY
38883: LIST
38884: LIST
38885: PUSH
38886: EMPTY
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38907: LD_ADDR_VAR 0 56
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: LD_INT 1
38927: NEG
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 1
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: LD_INT 1
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 0
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 1
38965: NEG
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 1
38988: NEG
38989: PUSH
38990: LD_INT 2
38992: NEG
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 0
39000: PUSH
39001: LD_INT 2
39003: NEG
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: LD_INT 1
39011: PUSH
39012: LD_INT 1
39014: NEG
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 2
39022: PUSH
39023: LD_INT 0
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 2
39032: PUSH
39033: LD_INT 1
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 2
39042: PUSH
39043: LD_INT 2
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: LD_INT 2
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 0
39062: PUSH
39063: LD_INT 2
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: NEG
39073: PUSH
39074: LD_INT 1
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 2
39083: NEG
39084: PUSH
39085: LD_INT 0
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 2
39094: NEG
39095: PUSH
39096: LD_INT 1
39098: NEG
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 2
39106: NEG
39107: PUSH
39108: LD_INT 2
39110: NEG
39111: PUSH
39112: EMPTY
39113: LIST
39114: LIST
39115: PUSH
39116: EMPTY
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: LIST
39128: LIST
39129: LIST
39130: LIST
39131: LIST
39132: LIST
39133: LIST
39134: LIST
39135: LIST
39136: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39137: LD_ADDR_VAR 0 57
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: LD_INT 0
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: LD_INT 1
39157: NEG
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 1
39165: PUSH
39166: LD_INT 0
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 1
39175: PUSH
39176: LD_INT 1
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: PUSH
39183: LD_INT 0
39185: PUSH
39186: LD_INT 1
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: LD_INT 0
39199: PUSH
39200: EMPTY
39201: LIST
39202: LIST
39203: PUSH
39204: LD_INT 1
39206: NEG
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 1
39218: NEG
39219: PUSH
39220: LD_INT 2
39222: NEG
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 0
39230: PUSH
39231: LD_INT 2
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: LD_INT 1
39244: NEG
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 2
39252: PUSH
39253: LD_INT 0
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 2
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: PUSH
39273: LD_INT 2
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 1
39282: PUSH
39283: LD_INT 2
39285: PUSH
39286: EMPTY
39287: LIST
39288: LIST
39289: PUSH
39290: LD_INT 0
39292: PUSH
39293: LD_INT 2
39295: PUSH
39296: EMPTY
39297: LIST
39298: LIST
39299: PUSH
39300: LD_INT 1
39302: NEG
39303: PUSH
39304: LD_INT 1
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: PUSH
39311: LD_INT 2
39313: NEG
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: EMPTY
39319: LIST
39320: LIST
39321: PUSH
39322: LD_INT 2
39324: NEG
39325: PUSH
39326: LD_INT 1
39328: NEG
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 2
39336: NEG
39337: PUSH
39338: LD_INT 2
39340: NEG
39341: PUSH
39342: EMPTY
39343: LIST
39344: LIST
39345: PUSH
39346: EMPTY
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: LIST
39359: LIST
39360: LIST
39361: LIST
39362: LIST
39363: LIST
39364: LIST
39365: LIST
39366: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39367: LD_ADDR_VAR 0 58
39371: PUSH
39372: LD_INT 0
39374: PUSH
39375: LD_INT 0
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 0
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 1
39395: PUSH
39396: LD_INT 0
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: LD_INT 1
39408: PUSH
39409: EMPTY
39410: LIST
39411: LIST
39412: PUSH
39413: LD_INT 0
39415: PUSH
39416: LD_INT 1
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 1
39425: NEG
39426: PUSH
39427: LD_INT 0
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: LD_INT 1
39440: NEG
39441: PUSH
39442: EMPTY
39443: LIST
39444: LIST
39445: PUSH
39446: LD_INT 1
39448: NEG
39449: PUSH
39450: LD_INT 2
39452: NEG
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 0
39460: PUSH
39461: LD_INT 2
39463: NEG
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 1
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: EMPTY
39477: LIST
39478: LIST
39479: PUSH
39480: LD_INT 2
39482: PUSH
39483: LD_INT 0
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 2
39492: PUSH
39493: LD_INT 1
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 2
39502: PUSH
39503: LD_INT 2
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 1
39512: PUSH
39513: LD_INT 2
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: LD_INT 2
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 1
39532: NEG
39533: PUSH
39534: LD_INT 1
39536: PUSH
39537: EMPTY
39538: LIST
39539: LIST
39540: PUSH
39541: LD_INT 2
39543: NEG
39544: PUSH
39545: LD_INT 0
39547: PUSH
39548: EMPTY
39549: LIST
39550: LIST
39551: PUSH
39552: LD_INT 2
39554: NEG
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 2
39566: NEG
39567: PUSH
39568: LD_INT 2
39570: NEG
39571: PUSH
39572: EMPTY
39573: LIST
39574: LIST
39575: PUSH
39576: EMPTY
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39597: LD_ADDR_VAR 0 59
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: LD_INT 0
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 0
39614: PUSH
39615: LD_INT 1
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 1
39625: PUSH
39626: LD_INT 0
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 1
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 0
39645: PUSH
39646: LD_INT 1
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: NEG
39656: PUSH
39657: LD_INT 0
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 1
39666: NEG
39667: PUSH
39668: LD_INT 1
39670: NEG
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: LIST
39682: LIST
39683: LIST
39684: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39685: LD_ADDR_VAR 0 60
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: LD_INT 0
39695: PUSH
39696: EMPTY
39697: LIST
39698: LIST
39699: PUSH
39700: LD_INT 0
39702: PUSH
39703: LD_INT 1
39705: NEG
39706: PUSH
39707: EMPTY
39708: LIST
39709: LIST
39710: PUSH
39711: LD_INT 1
39713: PUSH
39714: LD_INT 0
39716: PUSH
39717: EMPTY
39718: LIST
39719: LIST
39720: PUSH
39721: LD_INT 1
39723: PUSH
39724: LD_INT 1
39726: PUSH
39727: EMPTY
39728: LIST
39729: LIST
39730: PUSH
39731: LD_INT 0
39733: PUSH
39734: LD_INT 1
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 1
39743: NEG
39744: PUSH
39745: LD_INT 0
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 1
39754: NEG
39755: PUSH
39756: LD_INT 1
39758: NEG
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39773: LD_ADDR_VAR 0 61
39777: PUSH
39778: LD_INT 0
39780: PUSH
39781: LD_INT 0
39783: PUSH
39784: EMPTY
39785: LIST
39786: LIST
39787: PUSH
39788: LD_INT 0
39790: PUSH
39791: LD_INT 1
39793: NEG
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: PUSH
39802: LD_INT 0
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 1
39811: PUSH
39812: LD_INT 1
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: EMPTY
39826: LIST
39827: LIST
39828: PUSH
39829: LD_INT 1
39831: NEG
39832: PUSH
39833: LD_INT 0
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 1
39842: NEG
39843: PUSH
39844: LD_INT 1
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: EMPTY
39853: LIST
39854: LIST
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: LIST
39860: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39861: LD_ADDR_VAR 0 62
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 1
39881: NEG
39882: PUSH
39883: EMPTY
39884: LIST
39885: LIST
39886: PUSH
39887: LD_INT 1
39889: PUSH
39890: LD_INT 0
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 1
39919: NEG
39920: PUSH
39921: LD_INT 0
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 1
39930: NEG
39931: PUSH
39932: LD_INT 1
39934: NEG
39935: PUSH
39936: EMPTY
39937: LIST
39938: LIST
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39949: LD_ADDR_VAR 0 63
39953: PUSH
39954: LD_INT 0
39956: PUSH
39957: LD_INT 0
39959: PUSH
39960: EMPTY
39961: LIST
39962: LIST
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: LD_INT 1
39969: NEG
39970: PUSH
39971: EMPTY
39972: LIST
39973: LIST
39974: PUSH
39975: LD_INT 1
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 1
39987: PUSH
39988: LD_INT 1
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: LD_INT 0
39997: PUSH
39998: LD_INT 1
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: PUSH
40005: LD_INT 1
40007: NEG
40008: PUSH
40009: LD_INT 0
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 1
40018: NEG
40019: PUSH
40020: LD_INT 1
40022: NEG
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40037: LD_ADDR_VAR 0 64
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 0
40054: PUSH
40055: LD_INT 1
40057: NEG
40058: PUSH
40059: EMPTY
40060: LIST
40061: LIST
40062: PUSH
40063: LD_INT 1
40065: PUSH
40066: LD_INT 0
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: LD_INT 1
40075: PUSH
40076: LD_INT 1
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 0
40085: PUSH
40086: LD_INT 1
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 1
40095: NEG
40096: PUSH
40097: LD_INT 0
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 1
40106: NEG
40107: PUSH
40108: LD_INT 1
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: LIST
40120: LIST
40121: LIST
40122: LIST
40123: LIST
40124: ST_TO_ADDR
// end ; 1 :
40125: GO 46022
40127: LD_INT 1
40129: DOUBLE
40130: EQUAL
40131: IFTRUE 40135
40133: GO 42758
40135: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40136: LD_ADDR_VAR 0 11
40140: PUSH
40141: LD_INT 1
40143: NEG
40144: PUSH
40145: LD_INT 3
40147: NEG
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 0
40155: PUSH
40156: LD_INT 3
40158: NEG
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 1
40166: PUSH
40167: LD_INT 2
40169: NEG
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: PUSH
40175: EMPTY
40176: LIST
40177: LIST
40178: LIST
40179: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40180: LD_ADDR_VAR 0 12
40184: PUSH
40185: LD_INT 2
40187: PUSH
40188: LD_INT 1
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 3
40198: PUSH
40199: LD_INT 0
40201: PUSH
40202: EMPTY
40203: LIST
40204: LIST
40205: PUSH
40206: LD_INT 3
40208: PUSH
40209: LD_INT 1
40211: PUSH
40212: EMPTY
40213: LIST
40214: LIST
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: LIST
40220: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40221: LD_ADDR_VAR 0 13
40225: PUSH
40226: LD_INT 3
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 3
40238: PUSH
40239: LD_INT 3
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: PUSH
40249: LD_INT 3
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: LIST
40260: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40261: LD_ADDR_VAR 0 14
40265: PUSH
40266: LD_INT 1
40268: PUSH
40269: LD_INT 3
40271: PUSH
40272: EMPTY
40273: LIST
40274: LIST
40275: PUSH
40276: LD_INT 0
40278: PUSH
40279: LD_INT 3
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 1
40288: NEG
40289: PUSH
40290: LD_INT 2
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: LIST
40301: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40302: LD_ADDR_VAR 0 15
40306: PUSH
40307: LD_INT 2
40309: NEG
40310: PUSH
40311: LD_INT 1
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: LD_INT 3
40320: NEG
40321: PUSH
40322: LD_INT 0
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PUSH
40329: LD_INT 3
40331: NEG
40332: PUSH
40333: LD_INT 1
40335: NEG
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: EMPTY
40342: LIST
40343: LIST
40344: LIST
40345: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40346: LD_ADDR_VAR 0 16
40350: PUSH
40351: LD_INT 2
40353: NEG
40354: PUSH
40355: LD_INT 3
40357: NEG
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 3
40365: NEG
40366: PUSH
40367: LD_INT 2
40369: NEG
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 3
40377: NEG
40378: PUSH
40379: LD_INT 3
40381: NEG
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: LIST
40391: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40392: LD_ADDR_VAR 0 17
40396: PUSH
40397: LD_INT 1
40399: NEG
40400: PUSH
40401: LD_INT 3
40403: NEG
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 0
40411: PUSH
40412: LD_INT 3
40414: NEG
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: LD_INT 2
40425: NEG
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: LIST
40435: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40436: LD_ADDR_VAR 0 18
40440: PUSH
40441: LD_INT 2
40443: PUSH
40444: LD_INT 1
40446: NEG
40447: PUSH
40448: EMPTY
40449: LIST
40450: LIST
40451: PUSH
40452: LD_INT 3
40454: PUSH
40455: LD_INT 0
40457: PUSH
40458: EMPTY
40459: LIST
40460: LIST
40461: PUSH
40462: LD_INT 3
40464: PUSH
40465: LD_INT 1
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: EMPTY
40473: LIST
40474: LIST
40475: LIST
40476: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40477: LD_ADDR_VAR 0 19
40481: PUSH
40482: LD_INT 3
40484: PUSH
40485: LD_INT 2
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 3
40494: PUSH
40495: LD_INT 3
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 2
40504: PUSH
40505: LD_INT 3
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: LIST
40516: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40517: LD_ADDR_VAR 0 20
40521: PUSH
40522: LD_INT 1
40524: PUSH
40525: LD_INT 3
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: LD_INT 3
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 1
40544: NEG
40545: PUSH
40546: LD_INT 2
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: EMPTY
40554: LIST
40555: LIST
40556: LIST
40557: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40558: LD_ADDR_VAR 0 21
40562: PUSH
40563: LD_INT 2
40565: NEG
40566: PUSH
40567: LD_INT 1
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 3
40576: NEG
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 3
40587: NEG
40588: PUSH
40589: LD_INT 1
40591: NEG
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: LIST
40601: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40602: LD_ADDR_VAR 0 22
40606: PUSH
40607: LD_INT 2
40609: NEG
40610: PUSH
40611: LD_INT 3
40613: NEG
40614: PUSH
40615: EMPTY
40616: LIST
40617: LIST
40618: PUSH
40619: LD_INT 3
40621: NEG
40622: PUSH
40623: LD_INT 2
40625: NEG
40626: PUSH
40627: EMPTY
40628: LIST
40629: LIST
40630: PUSH
40631: LD_INT 3
40633: NEG
40634: PUSH
40635: LD_INT 3
40637: NEG
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: LIST
40647: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40648: LD_ADDR_VAR 0 23
40652: PUSH
40653: LD_INT 0
40655: PUSH
40656: LD_INT 3
40658: NEG
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 1
40666: NEG
40667: PUSH
40668: LD_INT 4
40670: NEG
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: LD_INT 1
40678: PUSH
40679: LD_INT 3
40681: NEG
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: LIST
40691: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40692: LD_ADDR_VAR 0 24
40696: PUSH
40697: LD_INT 3
40699: PUSH
40700: LD_INT 0
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 3
40709: PUSH
40710: LD_INT 1
40712: NEG
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 4
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: LIST
40732: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40733: LD_ADDR_VAR 0 25
40737: PUSH
40738: LD_INT 3
40740: PUSH
40741: LD_INT 3
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 4
40750: PUSH
40751: LD_INT 3
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 3
40760: PUSH
40761: LD_INT 4
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: LIST
40772: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40773: LD_ADDR_VAR 0 26
40777: PUSH
40778: LD_INT 0
40780: PUSH
40781: LD_INT 3
40783: PUSH
40784: EMPTY
40785: LIST
40786: LIST
40787: PUSH
40788: LD_INT 1
40790: PUSH
40791: LD_INT 4
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: LD_INT 1
40800: NEG
40801: PUSH
40802: LD_INT 3
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: LIST
40813: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40814: LD_ADDR_VAR 0 27
40818: PUSH
40819: LD_INT 3
40821: NEG
40822: PUSH
40823: LD_INT 0
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 3
40832: NEG
40833: PUSH
40834: LD_INT 1
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 4
40843: NEG
40844: PUSH
40845: LD_INT 1
40847: NEG
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: LIST
40857: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40858: LD_ADDR_VAR 0 28
40862: PUSH
40863: LD_INT 3
40865: NEG
40866: PUSH
40867: LD_INT 3
40869: NEG
40870: PUSH
40871: EMPTY
40872: LIST
40873: LIST
40874: PUSH
40875: LD_INT 3
40877: NEG
40878: PUSH
40879: LD_INT 4
40881: NEG
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 4
40889: NEG
40890: PUSH
40891: LD_INT 3
40893: NEG
40894: PUSH
40895: EMPTY
40896: LIST
40897: LIST
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: LIST
40903: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40904: LD_ADDR_VAR 0 29
40908: PUSH
40909: LD_INT 1
40911: NEG
40912: PUSH
40913: LD_INT 3
40915: NEG
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 0
40923: PUSH
40924: LD_INT 3
40926: NEG
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 1
40934: PUSH
40935: LD_INT 2
40937: NEG
40938: PUSH
40939: EMPTY
40940: LIST
40941: LIST
40942: PUSH
40943: LD_INT 1
40945: NEG
40946: PUSH
40947: LD_INT 4
40949: NEG
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 4
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: PUSH
40969: LD_INT 3
40971: NEG
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 1
40979: NEG
40980: PUSH
40981: LD_INT 5
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 0
40991: PUSH
40992: LD_INT 5
40994: NEG
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: LD_INT 1
41002: PUSH
41003: LD_INT 4
41005: NEG
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 1
41013: NEG
41014: PUSH
41015: LD_INT 6
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 0
41025: PUSH
41026: LD_INT 6
41028: NEG
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 1
41036: PUSH
41037: LD_INT 5
41039: NEG
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: LIST
41053: LIST
41054: LIST
41055: LIST
41056: LIST
41057: LIST
41058: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41059: LD_ADDR_VAR 0 30
41063: PUSH
41064: LD_INT 2
41066: PUSH
41067: LD_INT 1
41069: NEG
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 3
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 3
41087: PUSH
41088: LD_INT 1
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 3
41097: PUSH
41098: LD_INT 1
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 4
41108: PUSH
41109: LD_INT 0
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: PUSH
41116: LD_INT 4
41118: PUSH
41119: LD_INT 1
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 4
41128: PUSH
41129: LD_INT 1
41131: NEG
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: LD_INT 5
41139: PUSH
41140: LD_INT 0
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 5
41149: PUSH
41150: LD_INT 1
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 5
41159: PUSH
41160: LD_INT 1
41162: NEG
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 6
41170: PUSH
41171: LD_INT 0
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: PUSH
41178: LD_INT 6
41180: PUSH
41181: LD_INT 1
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: LIST
41192: LIST
41193: LIST
41194: LIST
41195: LIST
41196: LIST
41197: LIST
41198: LIST
41199: LIST
41200: LIST
41201: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41202: LD_ADDR_VAR 0 31
41206: PUSH
41207: LD_INT 3
41209: PUSH
41210: LD_INT 2
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 3
41219: PUSH
41220: LD_INT 3
41222: PUSH
41223: EMPTY
41224: LIST
41225: LIST
41226: PUSH
41227: LD_INT 2
41229: PUSH
41230: LD_INT 3
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 4
41239: PUSH
41240: LD_INT 3
41242: PUSH
41243: EMPTY
41244: LIST
41245: LIST
41246: PUSH
41247: LD_INT 4
41249: PUSH
41250: LD_INT 4
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 3
41259: PUSH
41260: LD_INT 4
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 5
41269: PUSH
41270: LD_INT 4
41272: PUSH
41273: EMPTY
41274: LIST
41275: LIST
41276: PUSH
41277: LD_INT 5
41279: PUSH
41280: LD_INT 5
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 4
41289: PUSH
41290: LD_INT 5
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 6
41299: PUSH
41300: LD_INT 5
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: LD_INT 6
41309: PUSH
41310: LD_INT 6
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 5
41319: PUSH
41320: LD_INT 6
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: LIST
41331: LIST
41332: LIST
41333: LIST
41334: LIST
41335: LIST
41336: LIST
41337: LIST
41338: LIST
41339: LIST
41340: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41341: LD_ADDR_VAR 0 32
41345: PUSH
41346: LD_INT 1
41348: PUSH
41349: LD_INT 3
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PUSH
41356: LD_INT 0
41358: PUSH
41359: LD_INT 3
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: PUSH
41366: LD_INT 1
41368: NEG
41369: PUSH
41370: LD_INT 2
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: PUSH
41377: LD_INT 1
41379: PUSH
41380: LD_INT 4
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: PUSH
41387: LD_INT 0
41389: PUSH
41390: LD_INT 4
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 1
41410: PUSH
41411: LD_INT 5
41413: PUSH
41414: EMPTY
41415: LIST
41416: LIST
41417: PUSH
41418: LD_INT 0
41420: PUSH
41421: LD_INT 5
41423: PUSH
41424: EMPTY
41425: LIST
41426: LIST
41427: PUSH
41428: LD_INT 1
41430: NEG
41431: PUSH
41432: LD_INT 4
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 1
41441: PUSH
41442: LD_INT 6
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: PUSH
41449: LD_INT 0
41451: PUSH
41452: LD_INT 6
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 1
41461: NEG
41462: PUSH
41463: LD_INT 5
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: LIST
41476: LIST
41477: LIST
41478: LIST
41479: LIST
41480: LIST
41481: LIST
41482: LIST
41483: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41484: LD_ADDR_VAR 0 33
41488: PUSH
41489: LD_INT 2
41491: NEG
41492: PUSH
41493: LD_INT 1
41495: PUSH
41496: EMPTY
41497: LIST
41498: LIST
41499: PUSH
41500: LD_INT 3
41502: NEG
41503: PUSH
41504: LD_INT 0
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PUSH
41511: LD_INT 3
41513: NEG
41514: PUSH
41515: LD_INT 1
41517: NEG
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 3
41525: NEG
41526: PUSH
41527: LD_INT 1
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 4
41536: NEG
41537: PUSH
41538: LD_INT 0
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 4
41547: NEG
41548: PUSH
41549: LD_INT 1
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 4
41559: NEG
41560: PUSH
41561: LD_INT 1
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: PUSH
41568: LD_INT 5
41570: NEG
41571: PUSH
41572: LD_INT 0
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 5
41581: NEG
41582: PUSH
41583: LD_INT 1
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 5
41593: NEG
41594: PUSH
41595: LD_INT 1
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 6
41604: NEG
41605: PUSH
41606: LD_INT 0
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: PUSH
41613: LD_INT 6
41615: NEG
41616: PUSH
41617: LD_INT 1
41619: NEG
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: EMPTY
41626: LIST
41627: LIST
41628: LIST
41629: LIST
41630: LIST
41631: LIST
41632: LIST
41633: LIST
41634: LIST
41635: LIST
41636: LIST
41637: LIST
41638: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41639: LD_ADDR_VAR 0 34
41643: PUSH
41644: LD_INT 2
41646: NEG
41647: PUSH
41648: LD_INT 3
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: NEG
41659: PUSH
41660: LD_INT 2
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: LD_INT 3
41670: NEG
41671: PUSH
41672: LD_INT 3
41674: NEG
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 3
41682: NEG
41683: PUSH
41684: LD_INT 4
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 4
41694: NEG
41695: PUSH
41696: LD_INT 3
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 4
41706: NEG
41707: PUSH
41708: LD_INT 4
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 4
41718: NEG
41719: PUSH
41720: LD_INT 5
41722: NEG
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: LD_INT 5
41730: NEG
41731: PUSH
41732: LD_INT 4
41734: NEG
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: LD_INT 5
41742: NEG
41743: PUSH
41744: LD_INT 5
41746: NEG
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 5
41754: NEG
41755: PUSH
41756: LD_INT 6
41758: NEG
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 6
41766: NEG
41767: PUSH
41768: LD_INT 5
41770: NEG
41771: PUSH
41772: EMPTY
41773: LIST
41774: LIST
41775: PUSH
41776: LD_INT 6
41778: NEG
41779: PUSH
41780: LD_INT 6
41782: NEG
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: EMPTY
41789: LIST
41790: LIST
41791: LIST
41792: LIST
41793: LIST
41794: LIST
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41802: LD_ADDR_VAR 0 41
41806: PUSH
41807: LD_INT 0
41809: PUSH
41810: LD_INT 2
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 1
41820: NEG
41821: PUSH
41822: LD_INT 3
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 1
41832: PUSH
41833: LD_INT 2
41835: NEG
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: LIST
41845: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41846: LD_ADDR_VAR 0 42
41850: PUSH
41851: LD_INT 2
41853: PUSH
41854: LD_INT 0
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 2
41863: PUSH
41864: LD_INT 1
41866: NEG
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 3
41874: PUSH
41875: LD_INT 1
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: LIST
41886: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41887: LD_ADDR_VAR 0 43
41891: PUSH
41892: LD_INT 2
41894: PUSH
41895: LD_INT 2
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 3
41904: PUSH
41905: LD_INT 2
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 2
41914: PUSH
41915: LD_INT 3
41917: PUSH
41918: EMPTY
41919: LIST
41920: LIST
41921: PUSH
41922: EMPTY
41923: LIST
41924: LIST
41925: LIST
41926: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41927: LD_ADDR_VAR 0 44
41931: PUSH
41932: LD_INT 0
41934: PUSH
41935: LD_INT 2
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 1
41944: PUSH
41945: LD_INT 3
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 1
41954: NEG
41955: PUSH
41956: LD_INT 2
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: LIST
41967: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41968: LD_ADDR_VAR 0 45
41972: PUSH
41973: LD_INT 2
41975: NEG
41976: PUSH
41977: LD_INT 0
41979: PUSH
41980: EMPTY
41981: LIST
41982: LIST
41983: PUSH
41984: LD_INT 2
41986: NEG
41987: PUSH
41988: LD_INT 1
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 3
41997: NEG
41998: PUSH
41999: LD_INT 1
42001: NEG
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PUSH
42007: EMPTY
42008: LIST
42009: LIST
42010: LIST
42011: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42012: LD_ADDR_VAR 0 46
42016: PUSH
42017: LD_INT 2
42019: NEG
42020: PUSH
42021: LD_INT 2
42023: NEG
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 2
42031: NEG
42032: PUSH
42033: LD_INT 3
42035: NEG
42036: PUSH
42037: EMPTY
42038: LIST
42039: LIST
42040: PUSH
42041: LD_INT 3
42043: NEG
42044: PUSH
42045: LD_INT 2
42047: NEG
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: EMPTY
42054: LIST
42055: LIST
42056: LIST
42057: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42058: LD_ADDR_VAR 0 47
42062: PUSH
42063: LD_INT 2
42065: NEG
42066: PUSH
42067: LD_INT 3
42069: NEG
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 1
42077: NEG
42078: PUSH
42079: LD_INT 3
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42091: LD_ADDR_VAR 0 48
42095: PUSH
42096: LD_INT 1
42098: PUSH
42099: LD_INT 2
42101: NEG
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 2
42109: PUSH
42110: LD_INT 1
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: EMPTY
42119: LIST
42120: LIST
42121: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42122: LD_ADDR_VAR 0 49
42126: PUSH
42127: LD_INT 3
42129: PUSH
42130: LD_INT 1
42132: PUSH
42133: EMPTY
42134: LIST
42135: LIST
42136: PUSH
42137: LD_INT 3
42139: PUSH
42140: LD_INT 2
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42151: LD_ADDR_VAR 0 50
42155: PUSH
42156: LD_INT 2
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 1
42168: PUSH
42169: LD_INT 3
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: EMPTY
42177: LIST
42178: LIST
42179: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42180: LD_ADDR_VAR 0 51
42184: PUSH
42185: LD_INT 1
42187: NEG
42188: PUSH
42189: LD_INT 2
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 2
42198: NEG
42199: PUSH
42200: LD_INT 1
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42211: LD_ADDR_VAR 0 52
42215: PUSH
42216: LD_INT 3
42218: NEG
42219: PUSH
42220: LD_INT 1
42222: NEG
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: LD_INT 3
42230: NEG
42231: PUSH
42232: LD_INT 2
42234: NEG
42235: PUSH
42236: EMPTY
42237: LIST
42238: LIST
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42244: LD_ADDR_VAR 0 53
42248: PUSH
42249: LD_INT 1
42251: NEG
42252: PUSH
42253: LD_INT 3
42255: NEG
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 0
42263: PUSH
42264: LD_INT 3
42266: NEG
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 1
42274: PUSH
42275: LD_INT 2
42277: NEG
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: LIST
42287: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42288: LD_ADDR_VAR 0 54
42292: PUSH
42293: LD_INT 2
42295: PUSH
42296: LD_INT 1
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 3
42306: PUSH
42307: LD_INT 0
42309: PUSH
42310: EMPTY
42311: LIST
42312: LIST
42313: PUSH
42314: LD_INT 3
42316: PUSH
42317: LD_INT 1
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: LIST
42328: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42329: LD_ADDR_VAR 0 55
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: LD_INT 2
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: LD_INT 3
42346: PUSH
42347: LD_INT 3
42349: PUSH
42350: EMPTY
42351: LIST
42352: LIST
42353: PUSH
42354: LD_INT 2
42356: PUSH
42357: LD_INT 3
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: LIST
42368: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42369: LD_ADDR_VAR 0 56
42373: PUSH
42374: LD_INT 1
42376: PUSH
42377: LD_INT 3
42379: PUSH
42380: EMPTY
42381: LIST
42382: LIST
42383: PUSH
42384: LD_INT 0
42386: PUSH
42387: LD_INT 3
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 1
42396: NEG
42397: PUSH
42398: LD_INT 2
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: LIST
42409: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42410: LD_ADDR_VAR 0 57
42414: PUSH
42415: LD_INT 2
42417: NEG
42418: PUSH
42419: LD_INT 1
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PUSH
42426: LD_INT 3
42428: NEG
42429: PUSH
42430: LD_INT 0
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: LD_INT 3
42439: NEG
42440: PUSH
42441: LD_INT 1
42443: NEG
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: LIST
42453: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42454: LD_ADDR_VAR 0 58
42458: PUSH
42459: LD_INT 2
42461: NEG
42462: PUSH
42463: LD_INT 3
42465: NEG
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 3
42473: NEG
42474: PUSH
42475: LD_INT 2
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 3
42485: NEG
42486: PUSH
42487: LD_INT 3
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: LIST
42499: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42500: LD_ADDR_VAR 0 59
42504: PUSH
42505: LD_INT 1
42507: NEG
42508: PUSH
42509: LD_INT 2
42511: NEG
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PUSH
42517: LD_INT 0
42519: PUSH
42520: LD_INT 2
42522: NEG
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 1
42530: PUSH
42531: LD_INT 1
42533: NEG
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: LIST
42543: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42544: LD_ADDR_VAR 0 60
42548: PUSH
42549: LD_INT 1
42551: PUSH
42552: LD_INT 1
42554: NEG
42555: PUSH
42556: EMPTY
42557: LIST
42558: LIST
42559: PUSH
42560: LD_INT 2
42562: PUSH
42563: LD_INT 0
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 2
42572: PUSH
42573: LD_INT 1
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: LIST
42584: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42585: LD_ADDR_VAR 0 61
42589: PUSH
42590: LD_INT 2
42592: PUSH
42593: LD_INT 1
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: PUSH
42600: LD_INT 2
42602: PUSH
42603: LD_INT 2
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: LD_INT 1
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: LIST
42624: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42625: LD_ADDR_VAR 0 62
42629: PUSH
42630: LD_INT 1
42632: PUSH
42633: LD_INT 2
42635: PUSH
42636: EMPTY
42637: LIST
42638: LIST
42639: PUSH
42640: LD_INT 0
42642: PUSH
42643: LD_INT 2
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 1
42652: NEG
42653: PUSH
42654: LD_INT 1
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: LIST
42665: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42666: LD_ADDR_VAR 0 63
42670: PUSH
42671: LD_INT 1
42673: NEG
42674: PUSH
42675: LD_INT 1
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: LD_INT 2
42684: NEG
42685: PUSH
42686: LD_INT 0
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: PUSH
42693: LD_INT 2
42695: NEG
42696: PUSH
42697: LD_INT 1
42699: NEG
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: LIST
42709: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42710: LD_ADDR_VAR 0 64
42714: PUSH
42715: LD_INT 1
42717: NEG
42718: PUSH
42719: LD_INT 2
42721: NEG
42722: PUSH
42723: EMPTY
42724: LIST
42725: LIST
42726: PUSH
42727: LD_INT 2
42729: NEG
42730: PUSH
42731: LD_INT 1
42733: NEG
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: LD_INT 2
42741: NEG
42742: PUSH
42743: LD_INT 2
42745: NEG
42746: PUSH
42747: EMPTY
42748: LIST
42749: LIST
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: LIST
42755: ST_TO_ADDR
// end ; 2 :
42756: GO 46022
42758: LD_INT 2
42760: DOUBLE
42761: EQUAL
42762: IFTRUE 42766
42764: GO 46021
42766: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42767: LD_ADDR_VAR 0 29
42771: PUSH
42772: LD_INT 4
42774: PUSH
42775: LD_INT 0
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 4
42784: PUSH
42785: LD_INT 1
42787: NEG
42788: PUSH
42789: EMPTY
42790: LIST
42791: LIST
42792: PUSH
42793: LD_INT 5
42795: PUSH
42796: LD_INT 0
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 5
42805: PUSH
42806: LD_INT 1
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 4
42815: PUSH
42816: LD_INT 1
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: PUSH
42823: LD_INT 3
42825: PUSH
42826: LD_INT 0
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: PUSH
42833: LD_INT 3
42835: PUSH
42836: LD_INT 1
42838: NEG
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 3
42846: PUSH
42847: LD_INT 2
42849: NEG
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 5
42857: PUSH
42858: LD_INT 2
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 3
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: EMPTY
42872: LIST
42873: LIST
42874: PUSH
42875: LD_INT 3
42877: PUSH
42878: LD_INT 2
42880: PUSH
42881: EMPTY
42882: LIST
42883: LIST
42884: PUSH
42885: LD_INT 4
42887: PUSH
42888: LD_INT 3
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 4
42897: PUSH
42898: LD_INT 4
42900: PUSH
42901: EMPTY
42902: LIST
42903: LIST
42904: PUSH
42905: LD_INT 3
42907: PUSH
42908: LD_INT 4
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 2
42917: PUSH
42918: LD_INT 3
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 2
42927: PUSH
42928: LD_INT 2
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 4
42937: PUSH
42938: LD_INT 2
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: PUSH
42948: LD_INT 4
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 0
42957: PUSH
42958: LD_INT 4
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 0
42967: PUSH
42968: LD_INT 3
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 1
42977: PUSH
42978: LD_INT 4
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: PUSH
42988: LD_INT 5
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 0
42997: PUSH
42998: LD_INT 5
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 1
43007: NEG
43008: PUSH
43009: LD_INT 4
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 1
43018: NEG
43019: PUSH
43020: LD_INT 3
43022: PUSH
43023: EMPTY
43024: LIST
43025: LIST
43026: PUSH
43027: LD_INT 2
43029: PUSH
43030: LD_INT 5
43032: PUSH
43033: EMPTY
43034: LIST
43035: LIST
43036: PUSH
43037: LD_INT 2
43039: NEG
43040: PUSH
43041: LD_INT 3
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 3
43050: NEG
43051: PUSH
43052: LD_INT 0
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 3
43061: NEG
43062: PUSH
43063: LD_INT 1
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 2
43073: NEG
43074: PUSH
43075: LD_INT 0
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: LD_INT 2
43084: NEG
43085: PUSH
43086: LD_INT 1
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 3
43095: NEG
43096: PUSH
43097: LD_INT 1
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 4
43106: NEG
43107: PUSH
43108: LD_INT 0
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: PUSH
43115: LD_INT 4
43117: NEG
43118: PUSH
43119: LD_INT 1
43121: NEG
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 4
43129: NEG
43130: PUSH
43131: LD_INT 2
43133: NEG
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PUSH
43139: LD_INT 2
43141: NEG
43142: PUSH
43143: LD_INT 2
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 4
43152: NEG
43153: PUSH
43154: LD_INT 4
43156: NEG
43157: PUSH
43158: EMPTY
43159: LIST
43160: LIST
43161: PUSH
43162: LD_INT 4
43164: NEG
43165: PUSH
43166: LD_INT 5
43168: NEG
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 3
43176: NEG
43177: PUSH
43178: LD_INT 4
43180: NEG
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: PUSH
43186: LD_INT 3
43188: NEG
43189: PUSH
43190: LD_INT 3
43192: NEG
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: LD_INT 4
43200: NEG
43201: PUSH
43202: LD_INT 3
43204: NEG
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 5
43212: NEG
43213: PUSH
43214: LD_INT 4
43216: NEG
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 5
43224: NEG
43225: PUSH
43226: LD_INT 5
43228: NEG
43229: PUSH
43230: EMPTY
43231: LIST
43232: LIST
43233: PUSH
43234: LD_INT 3
43236: NEG
43237: PUSH
43238: LD_INT 5
43240: NEG
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 5
43248: NEG
43249: PUSH
43250: LD_INT 3
43252: NEG
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: LIST
43275: LIST
43276: LIST
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: LIST
43282: LIST
43283: LIST
43284: LIST
43285: LIST
43286: LIST
43287: LIST
43288: LIST
43289: LIST
43290: LIST
43291: LIST
43292: LIST
43293: LIST
43294: LIST
43295: LIST
43296: LIST
43297: LIST
43298: LIST
43299: LIST
43300: LIST
43301: LIST
43302: LIST
43303: LIST
43304: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43305: LD_ADDR_VAR 0 30
43309: PUSH
43310: LD_INT 4
43312: PUSH
43313: LD_INT 4
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 4
43322: PUSH
43323: LD_INT 3
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 5
43332: PUSH
43333: LD_INT 4
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 5
43342: PUSH
43343: LD_INT 5
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 4
43352: PUSH
43353: LD_INT 5
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 3
43362: PUSH
43363: LD_INT 4
43365: PUSH
43366: EMPTY
43367: LIST
43368: LIST
43369: PUSH
43370: LD_INT 3
43372: PUSH
43373: LD_INT 3
43375: PUSH
43376: EMPTY
43377: LIST
43378: LIST
43379: PUSH
43380: LD_INT 5
43382: PUSH
43383: LD_INT 3
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 3
43392: PUSH
43393: LD_INT 5
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 0
43402: PUSH
43403: LD_INT 3
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 0
43412: PUSH
43413: LD_INT 2
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 1
43422: PUSH
43423: LD_INT 3
43425: PUSH
43426: EMPTY
43427: LIST
43428: LIST
43429: PUSH
43430: LD_INT 1
43432: PUSH
43433: LD_INT 4
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 0
43442: PUSH
43443: LD_INT 4
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PUSH
43450: LD_INT 1
43452: NEG
43453: PUSH
43454: LD_INT 3
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 1
43463: NEG
43464: PUSH
43465: LD_INT 2
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: PUSH
43472: LD_INT 2
43474: PUSH
43475: LD_INT 4
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 2
43484: NEG
43485: PUSH
43486: LD_INT 2
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 4
43495: NEG
43496: PUSH
43497: LD_INT 0
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 4
43506: NEG
43507: PUSH
43508: LD_INT 1
43510: NEG
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 3
43518: NEG
43519: PUSH
43520: LD_INT 0
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 3
43529: NEG
43530: PUSH
43531: LD_INT 1
43533: PUSH
43534: EMPTY
43535: LIST
43536: LIST
43537: PUSH
43538: LD_INT 4
43540: NEG
43541: PUSH
43542: LD_INT 1
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 5
43551: NEG
43552: PUSH
43553: LD_INT 0
43555: PUSH
43556: EMPTY
43557: LIST
43558: LIST
43559: PUSH
43560: LD_INT 5
43562: NEG
43563: PUSH
43564: LD_INT 1
43566: NEG
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 5
43574: NEG
43575: PUSH
43576: LD_INT 2
43578: NEG
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: LD_INT 3
43586: NEG
43587: PUSH
43588: LD_INT 2
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 3
43597: NEG
43598: PUSH
43599: LD_INT 3
43601: NEG
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 3
43609: NEG
43610: PUSH
43611: LD_INT 4
43613: NEG
43614: PUSH
43615: EMPTY
43616: LIST
43617: LIST
43618: PUSH
43619: LD_INT 2
43621: NEG
43622: PUSH
43623: LD_INT 3
43625: NEG
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 2
43633: NEG
43634: PUSH
43635: LD_INT 2
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: LD_INT 3
43645: NEG
43646: PUSH
43647: LD_INT 2
43649: NEG
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PUSH
43655: LD_INT 4
43657: NEG
43658: PUSH
43659: LD_INT 3
43661: NEG
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 4
43669: NEG
43670: PUSH
43671: LD_INT 4
43673: NEG
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 2
43681: NEG
43682: PUSH
43683: LD_INT 4
43685: NEG
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 4
43693: NEG
43694: PUSH
43695: LD_INT 2
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 0
43705: PUSH
43706: LD_INT 4
43708: NEG
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 5
43719: NEG
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 1
43727: PUSH
43728: LD_INT 4
43730: NEG
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 1
43738: PUSH
43739: LD_INT 3
43741: NEG
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 0
43749: PUSH
43750: LD_INT 3
43752: NEG
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 1
43760: NEG
43761: PUSH
43762: LD_INT 4
43764: NEG
43765: PUSH
43766: EMPTY
43767: LIST
43768: LIST
43769: PUSH
43770: LD_INT 1
43772: NEG
43773: PUSH
43774: LD_INT 5
43776: NEG
43777: PUSH
43778: EMPTY
43779: LIST
43780: LIST
43781: PUSH
43782: LD_INT 2
43784: PUSH
43785: LD_INT 3
43787: NEG
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 2
43795: NEG
43796: PUSH
43797: LD_INT 5
43799: NEG
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: LIST
43809: LIST
43810: LIST
43811: LIST
43812: LIST
43813: LIST
43814: LIST
43815: LIST
43816: LIST
43817: LIST
43818: LIST
43819: LIST
43820: LIST
43821: LIST
43822: LIST
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43852: LD_ADDR_VAR 0 31
43856: PUSH
43857: LD_INT 0
43859: PUSH
43860: LD_INT 4
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 0
43869: PUSH
43870: LD_INT 3
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 1
43879: PUSH
43880: LD_INT 4
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: LD_INT 5
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 0
43899: PUSH
43900: LD_INT 5
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 1
43909: NEG
43910: PUSH
43911: LD_INT 4
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 1
43920: NEG
43921: PUSH
43922: LD_INT 3
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 2
43931: PUSH
43932: LD_INT 5
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 2
43941: NEG
43942: PUSH
43943: LD_INT 3
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 3
43952: NEG
43953: PUSH
43954: LD_INT 0
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 3
43963: NEG
43964: PUSH
43965: LD_INT 1
43967: NEG
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PUSH
43973: LD_INT 2
43975: NEG
43976: PUSH
43977: LD_INT 0
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 2
43986: NEG
43987: PUSH
43988: LD_INT 1
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 3
43997: NEG
43998: PUSH
43999: LD_INT 1
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 4
44008: NEG
44009: PUSH
44010: LD_INT 0
44012: PUSH
44013: EMPTY
44014: LIST
44015: LIST
44016: PUSH
44017: LD_INT 4
44019: NEG
44020: PUSH
44021: LD_INT 1
44023: NEG
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 4
44031: NEG
44032: PUSH
44033: LD_INT 2
44035: NEG
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 2
44043: NEG
44044: PUSH
44045: LD_INT 2
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 4
44054: NEG
44055: PUSH
44056: LD_INT 4
44058: NEG
44059: PUSH
44060: EMPTY
44061: LIST
44062: LIST
44063: PUSH
44064: LD_INT 4
44066: NEG
44067: PUSH
44068: LD_INT 5
44070: NEG
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: PUSH
44076: LD_INT 3
44078: NEG
44079: PUSH
44080: LD_INT 4
44082: NEG
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PUSH
44088: LD_INT 3
44090: NEG
44091: PUSH
44092: LD_INT 3
44094: NEG
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: LD_INT 4
44102: NEG
44103: PUSH
44104: LD_INT 3
44106: NEG
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 5
44114: NEG
44115: PUSH
44116: LD_INT 4
44118: NEG
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 5
44126: NEG
44127: PUSH
44128: LD_INT 5
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 3
44138: NEG
44139: PUSH
44140: LD_INT 5
44142: NEG
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 5
44150: NEG
44151: PUSH
44152: LD_INT 3
44154: NEG
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 0
44162: PUSH
44163: LD_INT 3
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: LD_INT 4
44176: NEG
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 1
44184: PUSH
44185: LD_INT 3
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 1
44195: PUSH
44196: LD_INT 2
44198: NEG
44199: PUSH
44200: EMPTY
44201: LIST
44202: LIST
44203: PUSH
44204: LD_INT 0
44206: PUSH
44207: LD_INT 2
44209: NEG
44210: PUSH
44211: EMPTY
44212: LIST
44213: LIST
44214: PUSH
44215: LD_INT 1
44217: NEG
44218: PUSH
44219: LD_INT 3
44221: NEG
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 1
44229: NEG
44230: PUSH
44231: LD_INT 4
44233: NEG
44234: PUSH
44235: EMPTY
44236: LIST
44237: LIST
44238: PUSH
44239: LD_INT 2
44241: PUSH
44242: LD_INT 2
44244: NEG
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 2
44252: NEG
44253: PUSH
44254: LD_INT 4
44256: NEG
44257: PUSH
44258: EMPTY
44259: LIST
44260: LIST
44261: PUSH
44262: LD_INT 4
44264: PUSH
44265: LD_INT 0
44267: PUSH
44268: EMPTY
44269: LIST
44270: LIST
44271: PUSH
44272: LD_INT 4
44274: PUSH
44275: LD_INT 1
44277: NEG
44278: PUSH
44279: EMPTY
44280: LIST
44281: LIST
44282: PUSH
44283: LD_INT 5
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 5
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: LD_INT 4
44305: PUSH
44306: LD_INT 1
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 3
44315: PUSH
44316: LD_INT 0
44318: PUSH
44319: EMPTY
44320: LIST
44321: LIST
44322: PUSH
44323: LD_INT 3
44325: PUSH
44326: LD_INT 1
44328: NEG
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 3
44336: PUSH
44337: LD_INT 2
44339: NEG
44340: PUSH
44341: EMPTY
44342: LIST
44343: LIST
44344: PUSH
44345: LD_INT 5
44347: PUSH
44348: LD_INT 2
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: EMPTY
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44402: LD_ADDR_VAR 0 32
44406: PUSH
44407: LD_INT 4
44409: NEG
44410: PUSH
44411: LD_INT 0
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 4
44420: NEG
44421: PUSH
44422: LD_INT 1
44424: NEG
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 3
44432: NEG
44433: PUSH
44434: LD_INT 0
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 3
44443: NEG
44444: PUSH
44445: LD_INT 1
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 4
44454: NEG
44455: PUSH
44456: LD_INT 1
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 5
44465: NEG
44466: PUSH
44467: LD_INT 0
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 5
44476: NEG
44477: PUSH
44478: LD_INT 1
44480: NEG
44481: PUSH
44482: EMPTY
44483: LIST
44484: LIST
44485: PUSH
44486: LD_INT 5
44488: NEG
44489: PUSH
44490: LD_INT 2
44492: NEG
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 3
44500: NEG
44501: PUSH
44502: LD_INT 2
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 3
44511: NEG
44512: PUSH
44513: LD_INT 3
44515: NEG
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: PUSH
44521: LD_INT 3
44523: NEG
44524: PUSH
44525: LD_INT 4
44527: NEG
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: PUSH
44533: LD_INT 2
44535: NEG
44536: PUSH
44537: LD_INT 3
44539: NEG
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 2
44547: NEG
44548: PUSH
44549: LD_INT 2
44551: NEG
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 3
44559: NEG
44560: PUSH
44561: LD_INT 2
44563: NEG
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 4
44571: NEG
44572: PUSH
44573: LD_INT 3
44575: NEG
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 4
44583: NEG
44584: PUSH
44585: LD_INT 4
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 2
44595: NEG
44596: PUSH
44597: LD_INT 4
44599: NEG
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 4
44607: NEG
44608: PUSH
44609: LD_INT 2
44611: NEG
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 0
44619: PUSH
44620: LD_INT 4
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 0
44630: PUSH
44631: LD_INT 5
44633: NEG
44634: PUSH
44635: EMPTY
44636: LIST
44637: LIST
44638: PUSH
44639: LD_INT 1
44641: PUSH
44642: LD_INT 4
44644: NEG
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 1
44652: PUSH
44653: LD_INT 3
44655: NEG
44656: PUSH
44657: EMPTY
44658: LIST
44659: LIST
44660: PUSH
44661: LD_INT 0
44663: PUSH
44664: LD_INT 3
44666: NEG
44667: PUSH
44668: EMPTY
44669: LIST
44670: LIST
44671: PUSH
44672: LD_INT 1
44674: NEG
44675: PUSH
44676: LD_INT 4
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 1
44686: NEG
44687: PUSH
44688: LD_INT 5
44690: NEG
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: LD_INT 2
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 2
44709: NEG
44710: PUSH
44711: LD_INT 5
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 3
44721: PUSH
44722: LD_INT 0
44724: PUSH
44725: EMPTY
44726: LIST
44727: LIST
44728: PUSH
44729: LD_INT 3
44731: PUSH
44732: LD_INT 1
44734: NEG
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: LD_INT 4
44742: PUSH
44743: LD_INT 0
44745: PUSH
44746: EMPTY
44747: LIST
44748: LIST
44749: PUSH
44750: LD_INT 4
44752: PUSH
44753: LD_INT 1
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 3
44762: PUSH
44763: LD_INT 1
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 2
44772: PUSH
44773: LD_INT 0
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 2
44782: PUSH
44783: LD_INT 1
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 2
44793: PUSH
44794: LD_INT 2
44796: NEG
44797: PUSH
44798: EMPTY
44799: LIST
44800: LIST
44801: PUSH
44802: LD_INT 4
44804: PUSH
44805: LD_INT 2
44807: PUSH
44808: EMPTY
44809: LIST
44810: LIST
44811: PUSH
44812: LD_INT 4
44814: PUSH
44815: LD_INT 4
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: PUSH
44822: LD_INT 4
44824: PUSH
44825: LD_INT 3
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 5
44834: PUSH
44835: LD_INT 4
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 5
44844: PUSH
44845: LD_INT 5
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 4
44854: PUSH
44855: LD_INT 5
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: LD_INT 3
44864: PUSH
44865: LD_INT 4
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 3
44874: PUSH
44875: LD_INT 3
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 5
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: EMPTY
44889: LIST
44890: LIST
44891: PUSH
44892: LD_INT 3
44894: PUSH
44895: LD_INT 5
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: EMPTY
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: LIST
44909: LIST
44910: LIST
44911: LIST
44912: LIST
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44949: LD_ADDR_VAR 0 33
44953: PUSH
44954: LD_INT 4
44956: NEG
44957: PUSH
44958: LD_INT 4
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 4
44968: NEG
44969: PUSH
44970: LD_INT 5
44972: NEG
44973: PUSH
44974: EMPTY
44975: LIST
44976: LIST
44977: PUSH
44978: LD_INT 3
44980: NEG
44981: PUSH
44982: LD_INT 4
44984: NEG
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 3
44992: NEG
44993: PUSH
44994: LD_INT 3
44996: NEG
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: LD_INT 4
45004: NEG
45005: PUSH
45006: LD_INT 3
45008: NEG
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 5
45016: NEG
45017: PUSH
45018: LD_INT 4
45020: NEG
45021: PUSH
45022: EMPTY
45023: LIST
45024: LIST
45025: PUSH
45026: LD_INT 5
45028: NEG
45029: PUSH
45030: LD_INT 5
45032: NEG
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 3
45040: NEG
45041: PUSH
45042: LD_INT 5
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 5
45052: NEG
45053: PUSH
45054: LD_INT 3
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 0
45064: PUSH
45065: LD_INT 3
45067: NEG
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 0
45075: PUSH
45076: LD_INT 4
45078: NEG
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 1
45086: PUSH
45087: LD_INT 3
45089: NEG
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 1
45097: PUSH
45098: LD_INT 2
45100: NEG
45101: PUSH
45102: EMPTY
45103: LIST
45104: LIST
45105: PUSH
45106: LD_INT 0
45108: PUSH
45109: LD_INT 2
45111: NEG
45112: PUSH
45113: EMPTY
45114: LIST
45115: LIST
45116: PUSH
45117: LD_INT 1
45119: NEG
45120: PUSH
45121: LD_INT 3
45123: NEG
45124: PUSH
45125: EMPTY
45126: LIST
45127: LIST
45128: PUSH
45129: LD_INT 1
45131: NEG
45132: PUSH
45133: LD_INT 4
45135: NEG
45136: PUSH
45137: EMPTY
45138: LIST
45139: LIST
45140: PUSH
45141: LD_INT 2
45143: PUSH
45144: LD_INT 2
45146: NEG
45147: PUSH
45148: EMPTY
45149: LIST
45150: LIST
45151: PUSH
45152: LD_INT 2
45154: NEG
45155: PUSH
45156: LD_INT 4
45158: NEG
45159: PUSH
45160: EMPTY
45161: LIST
45162: LIST
45163: PUSH
45164: LD_INT 4
45166: PUSH
45167: LD_INT 0
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: PUSH
45174: LD_INT 4
45176: PUSH
45177: LD_INT 1
45179: NEG
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 5
45187: PUSH
45188: LD_INT 0
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PUSH
45195: LD_INT 5
45197: PUSH
45198: LD_INT 1
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 4
45207: PUSH
45208: LD_INT 1
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 3
45217: PUSH
45218: LD_INT 0
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: PUSH
45225: LD_INT 3
45227: PUSH
45228: LD_INT 1
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 3
45238: PUSH
45239: LD_INT 2
45241: NEG
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 5
45249: PUSH
45250: LD_INT 2
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 3
45259: PUSH
45260: LD_INT 3
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 3
45269: PUSH
45270: LD_INT 2
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 4
45279: PUSH
45280: LD_INT 3
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 4
45289: PUSH
45290: LD_INT 4
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 3
45299: PUSH
45300: LD_INT 4
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 2
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 2
45319: PUSH
45320: LD_INT 2
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 4
45329: PUSH
45330: LD_INT 2
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 2
45339: PUSH
45340: LD_INT 4
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: LD_INT 4
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 0
45359: PUSH
45360: LD_INT 3
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 1
45369: PUSH
45370: LD_INT 4
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 1
45379: PUSH
45380: LD_INT 5
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 0
45389: PUSH
45390: LD_INT 5
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: LD_INT 1
45399: NEG
45400: PUSH
45401: LD_INT 4
45403: PUSH
45404: EMPTY
45405: LIST
45406: LIST
45407: PUSH
45408: LD_INT 1
45410: NEG
45411: PUSH
45412: LD_INT 3
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 2
45421: PUSH
45422: LD_INT 5
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 2
45431: NEG
45432: PUSH
45433: LD_INT 3
45435: PUSH
45436: EMPTY
45437: LIST
45438: LIST
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45487: LD_ADDR_VAR 0 34
45491: PUSH
45492: LD_INT 0
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 0
45505: PUSH
45506: LD_INT 5
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 1
45516: PUSH
45517: LD_INT 4
45519: NEG
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 1
45527: PUSH
45528: LD_INT 3
45530: NEG
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: LD_INT 0
45538: PUSH
45539: LD_INT 3
45541: NEG
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 1
45549: NEG
45550: PUSH
45551: LD_INT 4
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 1
45561: NEG
45562: PUSH
45563: LD_INT 5
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 2
45573: PUSH
45574: LD_INT 3
45576: NEG
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: PUSH
45582: LD_INT 2
45584: NEG
45585: PUSH
45586: LD_INT 5
45588: NEG
45589: PUSH
45590: EMPTY
45591: LIST
45592: LIST
45593: PUSH
45594: LD_INT 3
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 3
45606: PUSH
45607: LD_INT 1
45609: NEG
45610: PUSH
45611: EMPTY
45612: LIST
45613: LIST
45614: PUSH
45615: LD_INT 4
45617: PUSH
45618: LD_INT 0
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 4
45627: PUSH
45628: LD_INT 1
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 3
45637: PUSH
45638: LD_INT 1
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: LD_INT 2
45647: PUSH
45648: LD_INT 0
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: PUSH
45655: LD_INT 2
45657: PUSH
45658: LD_INT 1
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 2
45668: PUSH
45669: LD_INT 2
45671: NEG
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: PUSH
45677: LD_INT 4
45679: PUSH
45680: LD_INT 2
45682: PUSH
45683: EMPTY
45684: LIST
45685: LIST
45686: PUSH
45687: LD_INT 4
45689: PUSH
45690: LD_INT 4
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 4
45699: PUSH
45700: LD_INT 3
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: PUSH
45707: LD_INT 5
45709: PUSH
45710: LD_INT 4
45712: PUSH
45713: EMPTY
45714: LIST
45715: LIST
45716: PUSH
45717: LD_INT 5
45719: PUSH
45720: LD_INT 5
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 4
45729: PUSH
45730: LD_INT 5
45732: PUSH
45733: EMPTY
45734: LIST
45735: LIST
45736: PUSH
45737: LD_INT 3
45739: PUSH
45740: LD_INT 4
45742: PUSH
45743: EMPTY
45744: LIST
45745: LIST
45746: PUSH
45747: LD_INT 3
45749: PUSH
45750: LD_INT 3
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 5
45759: PUSH
45760: LD_INT 3
45762: PUSH
45763: EMPTY
45764: LIST
45765: LIST
45766: PUSH
45767: LD_INT 3
45769: PUSH
45770: LD_INT 5
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 0
45779: PUSH
45780: LD_INT 3
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 0
45789: PUSH
45790: LD_INT 2
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PUSH
45797: LD_INT 1
45799: PUSH
45800: LD_INT 3
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: PUSH
45807: LD_INT 1
45809: PUSH
45810: LD_INT 4
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: PUSH
45817: LD_INT 0
45819: PUSH
45820: LD_INT 4
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 1
45829: NEG
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 1
45840: NEG
45841: PUSH
45842: LD_INT 2
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 2
45851: PUSH
45852: LD_INT 4
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 2
45861: NEG
45862: PUSH
45863: LD_INT 2
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: PUSH
45870: LD_INT 4
45872: NEG
45873: PUSH
45874: LD_INT 0
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 4
45883: NEG
45884: PUSH
45885: LD_INT 1
45887: NEG
45888: PUSH
45889: EMPTY
45890: LIST
45891: LIST
45892: PUSH
45893: LD_INT 3
45895: NEG
45896: PUSH
45897: LD_INT 0
45899: PUSH
45900: EMPTY
45901: LIST
45902: LIST
45903: PUSH
45904: LD_INT 3
45906: NEG
45907: PUSH
45908: LD_INT 1
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: PUSH
45915: LD_INT 4
45917: NEG
45918: PUSH
45919: LD_INT 1
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 5
45928: NEG
45929: PUSH
45930: LD_INT 0
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PUSH
45937: LD_INT 5
45939: NEG
45940: PUSH
45941: LD_INT 1
45943: NEG
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 5
45951: NEG
45952: PUSH
45953: LD_INT 2
45955: NEG
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: LD_INT 3
45963: NEG
45964: PUSH
45965: LD_INT 2
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: LIST
45979: LIST
45980: LIST
45981: LIST
45982: LIST
45983: LIST
45984: LIST
45985: LIST
45986: LIST
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: ST_TO_ADDR
// end ; end ;
46019: GO 46022
46021: POP
// case btype of b_depot , b_warehouse :
46022: LD_VAR 0 1
46026: PUSH
46027: LD_INT 0
46029: DOUBLE
46030: EQUAL
46031: IFTRUE 46041
46033: LD_INT 1
46035: DOUBLE
46036: EQUAL
46037: IFTRUE 46041
46039: GO 46242
46041: POP
// case nation of nation_american :
46042: LD_VAR 0 5
46046: PUSH
46047: LD_INT 1
46049: DOUBLE
46050: EQUAL
46051: IFTRUE 46055
46053: GO 46111
46055: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46056: LD_ADDR_VAR 0 9
46060: PUSH
46061: LD_VAR 0 11
46065: PUSH
46066: LD_VAR 0 12
46070: PUSH
46071: LD_VAR 0 13
46075: PUSH
46076: LD_VAR 0 14
46080: PUSH
46081: LD_VAR 0 15
46085: PUSH
46086: LD_VAR 0 16
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: PUSH
46099: LD_VAR 0 4
46103: PUSH
46104: LD_INT 1
46106: PLUS
46107: ARRAY
46108: ST_TO_ADDR
46109: GO 46240
46111: LD_INT 2
46113: DOUBLE
46114: EQUAL
46115: IFTRUE 46119
46117: GO 46175
46119: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46120: LD_ADDR_VAR 0 9
46124: PUSH
46125: LD_VAR 0 17
46129: PUSH
46130: LD_VAR 0 18
46134: PUSH
46135: LD_VAR 0 19
46139: PUSH
46140: LD_VAR 0 20
46144: PUSH
46145: LD_VAR 0 21
46149: PUSH
46150: LD_VAR 0 22
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: PUSH
46163: LD_VAR 0 4
46167: PUSH
46168: LD_INT 1
46170: PLUS
46171: ARRAY
46172: ST_TO_ADDR
46173: GO 46240
46175: LD_INT 3
46177: DOUBLE
46178: EQUAL
46179: IFTRUE 46183
46181: GO 46239
46183: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46184: LD_ADDR_VAR 0 9
46188: PUSH
46189: LD_VAR 0 23
46193: PUSH
46194: LD_VAR 0 24
46198: PUSH
46199: LD_VAR 0 25
46203: PUSH
46204: LD_VAR 0 26
46208: PUSH
46209: LD_VAR 0 27
46213: PUSH
46214: LD_VAR 0 28
46218: PUSH
46219: EMPTY
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: PUSH
46227: LD_VAR 0 4
46231: PUSH
46232: LD_INT 1
46234: PLUS
46235: ARRAY
46236: ST_TO_ADDR
46237: GO 46240
46239: POP
46240: GO 46789
46242: LD_INT 2
46244: DOUBLE
46245: EQUAL
46246: IFTRUE 46256
46248: LD_INT 3
46250: DOUBLE
46251: EQUAL
46252: IFTRUE 46256
46254: GO 46312
46256: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46257: LD_ADDR_VAR 0 9
46261: PUSH
46262: LD_VAR 0 29
46266: PUSH
46267: LD_VAR 0 30
46271: PUSH
46272: LD_VAR 0 31
46276: PUSH
46277: LD_VAR 0 32
46281: PUSH
46282: LD_VAR 0 33
46286: PUSH
46287: LD_VAR 0 34
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: LIST
46298: LIST
46299: PUSH
46300: LD_VAR 0 4
46304: PUSH
46305: LD_INT 1
46307: PLUS
46308: ARRAY
46309: ST_TO_ADDR
46310: GO 46789
46312: LD_INT 16
46314: DOUBLE
46315: EQUAL
46316: IFTRUE 46368
46318: LD_INT 17
46320: DOUBLE
46321: EQUAL
46322: IFTRUE 46368
46324: LD_INT 18
46326: DOUBLE
46327: EQUAL
46328: IFTRUE 46368
46330: LD_INT 19
46332: DOUBLE
46333: EQUAL
46334: IFTRUE 46368
46336: LD_INT 20
46338: DOUBLE
46339: EQUAL
46340: IFTRUE 46368
46342: LD_INT 21
46344: DOUBLE
46345: EQUAL
46346: IFTRUE 46368
46348: LD_INT 23
46350: DOUBLE
46351: EQUAL
46352: IFTRUE 46368
46354: LD_INT 24
46356: DOUBLE
46357: EQUAL
46358: IFTRUE 46368
46360: LD_INT 25
46362: DOUBLE
46363: EQUAL
46364: IFTRUE 46368
46366: GO 46424
46368: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46369: LD_ADDR_VAR 0 9
46373: PUSH
46374: LD_VAR 0 35
46378: PUSH
46379: LD_VAR 0 36
46383: PUSH
46384: LD_VAR 0 37
46388: PUSH
46389: LD_VAR 0 38
46393: PUSH
46394: LD_VAR 0 39
46398: PUSH
46399: LD_VAR 0 40
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: PUSH
46412: LD_VAR 0 4
46416: PUSH
46417: LD_INT 1
46419: PLUS
46420: ARRAY
46421: ST_TO_ADDR
46422: GO 46789
46424: LD_INT 6
46426: DOUBLE
46427: EQUAL
46428: IFTRUE 46480
46430: LD_INT 7
46432: DOUBLE
46433: EQUAL
46434: IFTRUE 46480
46436: LD_INT 8
46438: DOUBLE
46439: EQUAL
46440: IFTRUE 46480
46442: LD_INT 13
46444: DOUBLE
46445: EQUAL
46446: IFTRUE 46480
46448: LD_INT 12
46450: DOUBLE
46451: EQUAL
46452: IFTRUE 46480
46454: LD_INT 15
46456: DOUBLE
46457: EQUAL
46458: IFTRUE 46480
46460: LD_INT 11
46462: DOUBLE
46463: EQUAL
46464: IFTRUE 46480
46466: LD_INT 14
46468: DOUBLE
46469: EQUAL
46470: IFTRUE 46480
46472: LD_INT 10
46474: DOUBLE
46475: EQUAL
46476: IFTRUE 46480
46478: GO 46536
46480: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
46481: LD_ADDR_VAR 0 9
46485: PUSH
46486: LD_VAR 0 41
46490: PUSH
46491: LD_VAR 0 42
46495: PUSH
46496: LD_VAR 0 43
46500: PUSH
46501: LD_VAR 0 44
46505: PUSH
46506: LD_VAR 0 45
46510: PUSH
46511: LD_VAR 0 46
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: LIST
46520: LIST
46521: LIST
46522: LIST
46523: PUSH
46524: LD_VAR 0 4
46528: PUSH
46529: LD_INT 1
46531: PLUS
46532: ARRAY
46533: ST_TO_ADDR
46534: GO 46789
46536: LD_INT 36
46538: DOUBLE
46539: EQUAL
46540: IFTRUE 46544
46542: GO 46600
46544: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46545: LD_ADDR_VAR 0 9
46549: PUSH
46550: LD_VAR 0 47
46554: PUSH
46555: LD_VAR 0 48
46559: PUSH
46560: LD_VAR 0 49
46564: PUSH
46565: LD_VAR 0 50
46569: PUSH
46570: LD_VAR 0 51
46574: PUSH
46575: LD_VAR 0 52
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: PUSH
46588: LD_VAR 0 4
46592: PUSH
46593: LD_INT 1
46595: PLUS
46596: ARRAY
46597: ST_TO_ADDR
46598: GO 46789
46600: LD_INT 4
46602: DOUBLE
46603: EQUAL
46604: IFTRUE 46626
46606: LD_INT 5
46608: DOUBLE
46609: EQUAL
46610: IFTRUE 46626
46612: LD_INT 34
46614: DOUBLE
46615: EQUAL
46616: IFTRUE 46626
46618: LD_INT 37
46620: DOUBLE
46621: EQUAL
46622: IFTRUE 46626
46624: GO 46682
46626: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46627: LD_ADDR_VAR 0 9
46631: PUSH
46632: LD_VAR 0 53
46636: PUSH
46637: LD_VAR 0 54
46641: PUSH
46642: LD_VAR 0 55
46646: PUSH
46647: LD_VAR 0 56
46651: PUSH
46652: LD_VAR 0 57
46656: PUSH
46657: LD_VAR 0 58
46661: PUSH
46662: EMPTY
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: PUSH
46670: LD_VAR 0 4
46674: PUSH
46675: LD_INT 1
46677: PLUS
46678: ARRAY
46679: ST_TO_ADDR
46680: GO 46789
46682: LD_INT 31
46684: DOUBLE
46685: EQUAL
46686: IFTRUE 46732
46688: LD_INT 32
46690: DOUBLE
46691: EQUAL
46692: IFTRUE 46732
46694: LD_INT 33
46696: DOUBLE
46697: EQUAL
46698: IFTRUE 46732
46700: LD_INT 27
46702: DOUBLE
46703: EQUAL
46704: IFTRUE 46732
46706: LD_INT 26
46708: DOUBLE
46709: EQUAL
46710: IFTRUE 46732
46712: LD_INT 28
46714: DOUBLE
46715: EQUAL
46716: IFTRUE 46732
46718: LD_INT 29
46720: DOUBLE
46721: EQUAL
46722: IFTRUE 46732
46724: LD_INT 30
46726: DOUBLE
46727: EQUAL
46728: IFTRUE 46732
46730: GO 46788
46732: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
46733: LD_ADDR_VAR 0 9
46737: PUSH
46738: LD_VAR 0 59
46742: PUSH
46743: LD_VAR 0 60
46747: PUSH
46748: LD_VAR 0 61
46752: PUSH
46753: LD_VAR 0 62
46757: PUSH
46758: LD_VAR 0 63
46762: PUSH
46763: LD_VAR 0 64
46767: PUSH
46768: EMPTY
46769: LIST
46770: LIST
46771: LIST
46772: LIST
46773: LIST
46774: LIST
46775: PUSH
46776: LD_VAR 0 4
46780: PUSH
46781: LD_INT 1
46783: PLUS
46784: ARRAY
46785: ST_TO_ADDR
46786: GO 46789
46788: POP
// temp_list2 = [ ] ;
46789: LD_ADDR_VAR 0 10
46793: PUSH
46794: EMPTY
46795: ST_TO_ADDR
// for i in temp_list do
46796: LD_ADDR_VAR 0 8
46800: PUSH
46801: LD_VAR 0 9
46805: PUSH
46806: FOR_IN
46807: IFFALSE 46859
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46809: LD_ADDR_VAR 0 10
46813: PUSH
46814: LD_VAR 0 10
46818: PUSH
46819: LD_VAR 0 8
46823: PUSH
46824: LD_INT 1
46826: ARRAY
46827: PUSH
46828: LD_VAR 0 2
46832: PLUS
46833: PUSH
46834: LD_VAR 0 8
46838: PUSH
46839: LD_INT 2
46841: ARRAY
46842: PUSH
46843: LD_VAR 0 3
46847: PLUS
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: EMPTY
46854: LIST
46855: ADD
46856: ST_TO_ADDR
46857: GO 46806
46859: POP
46860: POP
// result = temp_list2 ;
46861: LD_ADDR_VAR 0 7
46865: PUSH
46866: LD_VAR 0 10
46870: ST_TO_ADDR
// end ;
46871: LD_VAR 0 7
46875: RET
// export function EnemyInRange ( unit , dist ) ; begin
46876: LD_INT 0
46878: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46879: LD_ADDR_VAR 0 3
46883: PUSH
46884: LD_VAR 0 1
46888: PPUSH
46889: CALL_OW 255
46893: PPUSH
46894: LD_VAR 0 1
46898: PPUSH
46899: CALL_OW 250
46903: PPUSH
46904: LD_VAR 0 1
46908: PPUSH
46909: CALL_OW 251
46913: PPUSH
46914: LD_VAR 0 2
46918: PPUSH
46919: CALL 21191 0 4
46923: PUSH
46924: LD_INT 4
46926: ARRAY
46927: ST_TO_ADDR
// end ;
46928: LD_VAR 0 3
46932: RET
// export function PlayerSeeMe ( unit ) ; begin
46933: LD_INT 0
46935: PPUSH
// result := See ( your_side , unit ) ;
46936: LD_ADDR_VAR 0 2
46940: PUSH
46941: LD_OWVAR 2
46945: PPUSH
46946: LD_VAR 0 1
46950: PPUSH
46951: CALL_OW 292
46955: ST_TO_ADDR
// end ;
46956: LD_VAR 0 2
46960: RET
// export function ReverseDir ( unit ) ; begin
46961: LD_INT 0
46963: PPUSH
// if not unit then
46964: LD_VAR 0 1
46968: NOT
46969: IFFALSE 46973
// exit ;
46971: GO 47019
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
46973: LD_ADDR_VAR 0 2
46977: PUSH
46978: LD_INT 3
46980: PUSH
46981: LD_INT 4
46983: PUSH
46984: LD_INT 5
46986: PUSH
46987: LD_INT 0
46989: PUSH
46990: LD_INT 1
46992: PUSH
46993: LD_INT 2
46995: PUSH
46996: EMPTY
46997: LIST
46998: LIST
46999: LIST
47000: LIST
47001: LIST
47002: LIST
47003: PUSH
47004: LD_VAR 0 1
47008: PPUSH
47009: CALL_OW 254
47013: PUSH
47014: LD_INT 1
47016: PLUS
47017: ARRAY
47018: ST_TO_ADDR
// end ;
47019: LD_VAR 0 2
47023: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47024: LD_INT 0
47026: PPUSH
47027: PPUSH
47028: PPUSH
47029: PPUSH
47030: PPUSH
// if not hexes then
47031: LD_VAR 0 2
47035: NOT
47036: IFFALSE 47040
// exit ;
47038: GO 47188
// dist := 9999 ;
47040: LD_ADDR_VAR 0 5
47044: PUSH
47045: LD_INT 9999
47047: ST_TO_ADDR
// for i = 1 to hexes do
47048: LD_ADDR_VAR 0 4
47052: PUSH
47053: DOUBLE
47054: LD_INT 1
47056: DEC
47057: ST_TO_ADDR
47058: LD_VAR 0 2
47062: PUSH
47063: FOR_TO
47064: IFFALSE 47176
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47066: LD_VAR 0 1
47070: PPUSH
47071: LD_VAR 0 2
47075: PUSH
47076: LD_VAR 0 4
47080: ARRAY
47081: PUSH
47082: LD_INT 1
47084: ARRAY
47085: PPUSH
47086: LD_VAR 0 2
47090: PUSH
47091: LD_VAR 0 4
47095: ARRAY
47096: PUSH
47097: LD_INT 2
47099: ARRAY
47100: PPUSH
47101: CALL_OW 297
47105: PUSH
47106: LD_VAR 0 5
47110: LESS
47111: IFFALSE 47174
// begin hex := hexes [ i ] ;
47113: LD_ADDR_VAR 0 7
47117: PUSH
47118: LD_VAR 0 2
47122: PUSH
47123: LD_VAR 0 4
47127: ARRAY
47128: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47129: LD_ADDR_VAR 0 5
47133: PUSH
47134: LD_VAR 0 1
47138: PPUSH
47139: LD_VAR 0 2
47143: PUSH
47144: LD_VAR 0 4
47148: ARRAY
47149: PUSH
47150: LD_INT 1
47152: ARRAY
47153: PPUSH
47154: LD_VAR 0 2
47158: PUSH
47159: LD_VAR 0 4
47163: ARRAY
47164: PUSH
47165: LD_INT 2
47167: ARRAY
47168: PPUSH
47169: CALL_OW 297
47173: ST_TO_ADDR
// end ; end ;
47174: GO 47063
47176: POP
47177: POP
// result := hex ;
47178: LD_ADDR_VAR 0 3
47182: PUSH
47183: LD_VAR 0 7
47187: ST_TO_ADDR
// end ;
47188: LD_VAR 0 3
47192: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47193: LD_INT 0
47195: PPUSH
47196: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47197: LD_VAR 0 1
47201: NOT
47202: PUSH
47203: LD_VAR 0 1
47207: PUSH
47208: LD_INT 21
47210: PUSH
47211: LD_INT 2
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 23
47220: PUSH
47221: LD_INT 2
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PPUSH
47232: CALL_OW 69
47236: IN
47237: NOT
47238: OR
47239: IFFALSE 47243
// exit ;
47241: GO 47290
// for i = 1 to 3 do
47243: LD_ADDR_VAR 0 3
47247: PUSH
47248: DOUBLE
47249: LD_INT 1
47251: DEC
47252: ST_TO_ADDR
47253: LD_INT 3
47255: PUSH
47256: FOR_TO
47257: IFFALSE 47288
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47259: LD_VAR 0 1
47263: PPUSH
47264: CALL_OW 250
47268: PPUSH
47269: LD_VAR 0 1
47273: PPUSH
47274: CALL_OW 251
47278: PPUSH
47279: LD_INT 1
47281: PPUSH
47282: CALL_OW 453
47286: GO 47256
47288: POP
47289: POP
// end ;
47290: LD_VAR 0 2
47294: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47295: LD_INT 0
47297: PPUSH
47298: PPUSH
47299: PPUSH
47300: PPUSH
47301: PPUSH
47302: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47303: LD_VAR 0 1
47307: NOT
47308: PUSH
47309: LD_VAR 0 2
47313: NOT
47314: OR
47315: PUSH
47316: LD_VAR 0 1
47320: PPUSH
47321: CALL_OW 314
47325: OR
47326: IFFALSE 47330
// exit ;
47328: GO 47771
// x := GetX ( enemy_unit ) ;
47330: LD_ADDR_VAR 0 7
47334: PUSH
47335: LD_VAR 0 2
47339: PPUSH
47340: CALL_OW 250
47344: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47345: LD_ADDR_VAR 0 8
47349: PUSH
47350: LD_VAR 0 2
47354: PPUSH
47355: CALL_OW 251
47359: ST_TO_ADDR
// if not x or not y then
47360: LD_VAR 0 7
47364: NOT
47365: PUSH
47366: LD_VAR 0 8
47370: NOT
47371: OR
47372: IFFALSE 47376
// exit ;
47374: GO 47771
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47376: LD_ADDR_VAR 0 6
47380: PUSH
47381: LD_VAR 0 7
47385: PPUSH
47386: LD_INT 0
47388: PPUSH
47389: LD_INT 4
47391: PPUSH
47392: CALL_OW 272
47396: PUSH
47397: LD_VAR 0 8
47401: PPUSH
47402: LD_INT 0
47404: PPUSH
47405: LD_INT 4
47407: PPUSH
47408: CALL_OW 273
47412: PUSH
47413: EMPTY
47414: LIST
47415: LIST
47416: PUSH
47417: LD_VAR 0 7
47421: PPUSH
47422: LD_INT 1
47424: PPUSH
47425: LD_INT 4
47427: PPUSH
47428: CALL_OW 272
47432: PUSH
47433: LD_VAR 0 8
47437: PPUSH
47438: LD_INT 1
47440: PPUSH
47441: LD_INT 4
47443: PPUSH
47444: CALL_OW 273
47448: PUSH
47449: EMPTY
47450: LIST
47451: LIST
47452: PUSH
47453: LD_VAR 0 7
47457: PPUSH
47458: LD_INT 2
47460: PPUSH
47461: LD_INT 4
47463: PPUSH
47464: CALL_OW 272
47468: PUSH
47469: LD_VAR 0 8
47473: PPUSH
47474: LD_INT 2
47476: PPUSH
47477: LD_INT 4
47479: PPUSH
47480: CALL_OW 273
47484: PUSH
47485: EMPTY
47486: LIST
47487: LIST
47488: PUSH
47489: LD_VAR 0 7
47493: PPUSH
47494: LD_INT 3
47496: PPUSH
47497: LD_INT 4
47499: PPUSH
47500: CALL_OW 272
47504: PUSH
47505: LD_VAR 0 8
47509: PPUSH
47510: LD_INT 3
47512: PPUSH
47513: LD_INT 4
47515: PPUSH
47516: CALL_OW 273
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PUSH
47525: LD_VAR 0 7
47529: PPUSH
47530: LD_INT 4
47532: PPUSH
47533: LD_INT 4
47535: PPUSH
47536: CALL_OW 272
47540: PUSH
47541: LD_VAR 0 8
47545: PPUSH
47546: LD_INT 4
47548: PPUSH
47549: LD_INT 4
47551: PPUSH
47552: CALL_OW 273
47556: PUSH
47557: EMPTY
47558: LIST
47559: LIST
47560: PUSH
47561: LD_VAR 0 7
47565: PPUSH
47566: LD_INT 5
47568: PPUSH
47569: LD_INT 4
47571: PPUSH
47572: CALL_OW 272
47576: PUSH
47577: LD_VAR 0 8
47581: PPUSH
47582: LD_INT 5
47584: PPUSH
47585: LD_INT 4
47587: PPUSH
47588: CALL_OW 273
47592: PUSH
47593: EMPTY
47594: LIST
47595: LIST
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: ST_TO_ADDR
// for i = tmp downto 1 do
47605: LD_ADDR_VAR 0 4
47609: PUSH
47610: DOUBLE
47611: LD_VAR 0 6
47615: INC
47616: ST_TO_ADDR
47617: LD_INT 1
47619: PUSH
47620: FOR_DOWNTO
47621: IFFALSE 47722
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47623: LD_VAR 0 6
47627: PUSH
47628: LD_VAR 0 4
47632: ARRAY
47633: PUSH
47634: LD_INT 1
47636: ARRAY
47637: PPUSH
47638: LD_VAR 0 6
47642: PUSH
47643: LD_VAR 0 4
47647: ARRAY
47648: PUSH
47649: LD_INT 2
47651: ARRAY
47652: PPUSH
47653: CALL_OW 488
47657: NOT
47658: PUSH
47659: LD_VAR 0 6
47663: PUSH
47664: LD_VAR 0 4
47668: ARRAY
47669: PUSH
47670: LD_INT 1
47672: ARRAY
47673: PPUSH
47674: LD_VAR 0 6
47678: PUSH
47679: LD_VAR 0 4
47683: ARRAY
47684: PUSH
47685: LD_INT 2
47687: ARRAY
47688: PPUSH
47689: CALL_OW 428
47693: PUSH
47694: LD_INT 0
47696: NONEQUAL
47697: OR
47698: IFFALSE 47720
// tmp := Delete ( tmp , i ) ;
47700: LD_ADDR_VAR 0 6
47704: PUSH
47705: LD_VAR 0 6
47709: PPUSH
47710: LD_VAR 0 4
47714: PPUSH
47715: CALL_OW 3
47719: ST_TO_ADDR
47720: GO 47620
47722: POP
47723: POP
// j := GetClosestHex ( unit , tmp ) ;
47724: LD_ADDR_VAR 0 5
47728: PUSH
47729: LD_VAR 0 1
47733: PPUSH
47734: LD_VAR 0 6
47738: PPUSH
47739: CALL 47024 0 2
47743: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47744: LD_VAR 0 1
47748: PPUSH
47749: LD_VAR 0 5
47753: PUSH
47754: LD_INT 1
47756: ARRAY
47757: PPUSH
47758: LD_VAR 0 5
47762: PUSH
47763: LD_INT 2
47765: ARRAY
47766: PPUSH
47767: CALL_OW 111
// end ;
47771: LD_VAR 0 3
47775: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47776: LD_INT 0
47778: PPUSH
47779: PPUSH
47780: PPUSH
// uc_side = 0 ;
47781: LD_ADDR_OWVAR 20
47785: PUSH
47786: LD_INT 0
47788: ST_TO_ADDR
// uc_nation = 0 ;
47789: LD_ADDR_OWVAR 21
47793: PUSH
47794: LD_INT 0
47796: ST_TO_ADDR
// InitHc ;
47797: CALL_OW 19
// InitVc ;
47801: CALL_OW 20
// if mastodonts then
47805: LD_VAR 0 6
47809: IFFALSE 47876
// for i = 1 to mastodonts do
47811: LD_ADDR_VAR 0 11
47815: PUSH
47816: DOUBLE
47817: LD_INT 1
47819: DEC
47820: ST_TO_ADDR
47821: LD_VAR 0 6
47825: PUSH
47826: FOR_TO
47827: IFFALSE 47874
// begin vc_chassis := 31 ;
47829: LD_ADDR_OWVAR 37
47833: PUSH
47834: LD_INT 31
47836: ST_TO_ADDR
// vc_control := control_rider ;
47837: LD_ADDR_OWVAR 38
47841: PUSH
47842: LD_INT 4
47844: ST_TO_ADDR
// animal := CreateVehicle ;
47845: LD_ADDR_VAR 0 12
47849: PUSH
47850: CALL_OW 45
47854: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47855: LD_VAR 0 12
47859: PPUSH
47860: LD_VAR 0 8
47864: PPUSH
47865: LD_INT 0
47867: PPUSH
47868: CALL 54582 0 3
// end ;
47872: GO 47826
47874: POP
47875: POP
// if horses then
47876: LD_VAR 0 5
47880: IFFALSE 47947
// for i = 1 to horses do
47882: LD_ADDR_VAR 0 11
47886: PUSH
47887: DOUBLE
47888: LD_INT 1
47890: DEC
47891: ST_TO_ADDR
47892: LD_VAR 0 5
47896: PUSH
47897: FOR_TO
47898: IFFALSE 47945
// begin hc_class := 21 ;
47900: LD_ADDR_OWVAR 28
47904: PUSH
47905: LD_INT 21
47907: ST_TO_ADDR
// hc_gallery :=  ;
47908: LD_ADDR_OWVAR 33
47912: PUSH
47913: LD_STRING 
47915: ST_TO_ADDR
// animal := CreateHuman ;
47916: LD_ADDR_VAR 0 12
47920: PUSH
47921: CALL_OW 44
47925: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47926: LD_VAR 0 12
47930: PPUSH
47931: LD_VAR 0 8
47935: PPUSH
47936: LD_INT 0
47938: PPUSH
47939: CALL 54582 0 3
// end ;
47943: GO 47897
47945: POP
47946: POP
// if birds then
47947: LD_VAR 0 1
47951: IFFALSE 48018
// for i = 1 to birds do
47953: LD_ADDR_VAR 0 11
47957: PUSH
47958: DOUBLE
47959: LD_INT 1
47961: DEC
47962: ST_TO_ADDR
47963: LD_VAR 0 1
47967: PUSH
47968: FOR_TO
47969: IFFALSE 48016
// begin hc_class = 18 ;
47971: LD_ADDR_OWVAR 28
47975: PUSH
47976: LD_INT 18
47978: ST_TO_ADDR
// hc_gallery =  ;
47979: LD_ADDR_OWVAR 33
47983: PUSH
47984: LD_STRING 
47986: ST_TO_ADDR
// animal := CreateHuman ;
47987: LD_ADDR_VAR 0 12
47991: PUSH
47992: CALL_OW 44
47996: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47997: LD_VAR 0 12
48001: PPUSH
48002: LD_VAR 0 8
48006: PPUSH
48007: LD_INT 0
48009: PPUSH
48010: CALL 54582 0 3
// end ;
48014: GO 47968
48016: POP
48017: POP
// if tigers then
48018: LD_VAR 0 2
48022: IFFALSE 48106
// for i = 1 to tigers do
48024: LD_ADDR_VAR 0 11
48028: PUSH
48029: DOUBLE
48030: LD_INT 1
48032: DEC
48033: ST_TO_ADDR
48034: LD_VAR 0 2
48038: PUSH
48039: FOR_TO
48040: IFFALSE 48104
// begin hc_class = class_tiger ;
48042: LD_ADDR_OWVAR 28
48046: PUSH
48047: LD_INT 14
48049: ST_TO_ADDR
// hc_gallery =  ;
48050: LD_ADDR_OWVAR 33
48054: PUSH
48055: LD_STRING 
48057: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48058: LD_ADDR_OWVAR 35
48062: PUSH
48063: LD_INT 7
48065: NEG
48066: PPUSH
48067: LD_INT 7
48069: PPUSH
48070: CALL_OW 12
48074: ST_TO_ADDR
// animal := CreateHuman ;
48075: LD_ADDR_VAR 0 12
48079: PUSH
48080: CALL_OW 44
48084: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48085: LD_VAR 0 12
48089: PPUSH
48090: LD_VAR 0 8
48094: PPUSH
48095: LD_INT 0
48097: PPUSH
48098: CALL 54582 0 3
// end ;
48102: GO 48039
48104: POP
48105: POP
// if apemans then
48106: LD_VAR 0 3
48110: IFFALSE 48233
// for i = 1 to apemans do
48112: LD_ADDR_VAR 0 11
48116: PUSH
48117: DOUBLE
48118: LD_INT 1
48120: DEC
48121: ST_TO_ADDR
48122: LD_VAR 0 3
48126: PUSH
48127: FOR_TO
48128: IFFALSE 48231
// begin hc_class = class_apeman ;
48130: LD_ADDR_OWVAR 28
48134: PUSH
48135: LD_INT 12
48137: ST_TO_ADDR
// hc_gallery =  ;
48138: LD_ADDR_OWVAR 33
48142: PUSH
48143: LD_STRING 
48145: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48146: LD_ADDR_OWVAR 35
48150: PUSH
48151: LD_INT 5
48153: NEG
48154: PPUSH
48155: LD_INT 5
48157: PPUSH
48158: CALL_OW 12
48162: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48163: LD_ADDR_OWVAR 31
48167: PUSH
48168: LD_INT 1
48170: PPUSH
48171: LD_INT 3
48173: PPUSH
48174: CALL_OW 12
48178: PUSH
48179: LD_INT 1
48181: PPUSH
48182: LD_INT 3
48184: PPUSH
48185: CALL_OW 12
48189: PUSH
48190: LD_INT 0
48192: PUSH
48193: LD_INT 0
48195: PUSH
48196: EMPTY
48197: LIST
48198: LIST
48199: LIST
48200: LIST
48201: ST_TO_ADDR
// animal := CreateHuman ;
48202: LD_ADDR_VAR 0 12
48206: PUSH
48207: CALL_OW 44
48211: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48212: LD_VAR 0 12
48216: PPUSH
48217: LD_VAR 0 8
48221: PPUSH
48222: LD_INT 0
48224: PPUSH
48225: CALL 54582 0 3
// end ;
48229: GO 48127
48231: POP
48232: POP
// if enchidnas then
48233: LD_VAR 0 4
48237: IFFALSE 48304
// for i = 1 to enchidnas do
48239: LD_ADDR_VAR 0 11
48243: PUSH
48244: DOUBLE
48245: LD_INT 1
48247: DEC
48248: ST_TO_ADDR
48249: LD_VAR 0 4
48253: PUSH
48254: FOR_TO
48255: IFFALSE 48302
// begin hc_class = 13 ;
48257: LD_ADDR_OWVAR 28
48261: PUSH
48262: LD_INT 13
48264: ST_TO_ADDR
// hc_gallery =  ;
48265: LD_ADDR_OWVAR 33
48269: PUSH
48270: LD_STRING 
48272: ST_TO_ADDR
// animal := CreateHuman ;
48273: LD_ADDR_VAR 0 12
48277: PUSH
48278: CALL_OW 44
48282: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48283: LD_VAR 0 12
48287: PPUSH
48288: LD_VAR 0 8
48292: PPUSH
48293: LD_INT 0
48295: PPUSH
48296: CALL 54582 0 3
// end ;
48300: GO 48254
48302: POP
48303: POP
// if fishes then
48304: LD_VAR 0 7
48308: IFFALSE 48375
// for i = 1 to fishes do
48310: LD_ADDR_VAR 0 11
48314: PUSH
48315: DOUBLE
48316: LD_INT 1
48318: DEC
48319: ST_TO_ADDR
48320: LD_VAR 0 7
48324: PUSH
48325: FOR_TO
48326: IFFALSE 48373
// begin hc_class = 20 ;
48328: LD_ADDR_OWVAR 28
48332: PUSH
48333: LD_INT 20
48335: ST_TO_ADDR
// hc_gallery =  ;
48336: LD_ADDR_OWVAR 33
48340: PUSH
48341: LD_STRING 
48343: ST_TO_ADDR
// animal := CreateHuman ;
48344: LD_ADDR_VAR 0 12
48348: PUSH
48349: CALL_OW 44
48353: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48354: LD_VAR 0 12
48358: PPUSH
48359: LD_VAR 0 9
48363: PPUSH
48364: LD_INT 0
48366: PPUSH
48367: CALL 54582 0 3
// end ;
48371: GO 48325
48373: POP
48374: POP
// end ;
48375: LD_VAR 0 10
48379: RET
// export function WantHeal ( sci , unit ) ; begin
48380: LD_INT 0
48382: PPUSH
// if GetTaskList ( sci ) > 0 then
48383: LD_VAR 0 1
48387: PPUSH
48388: CALL_OW 437
48392: PUSH
48393: LD_INT 0
48395: GREATER
48396: IFFALSE 48466
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48398: LD_VAR 0 1
48402: PPUSH
48403: CALL_OW 437
48407: PUSH
48408: LD_INT 1
48410: ARRAY
48411: PUSH
48412: LD_INT 1
48414: ARRAY
48415: PUSH
48416: LD_STRING l
48418: EQUAL
48419: PUSH
48420: LD_VAR 0 1
48424: PPUSH
48425: CALL_OW 437
48429: PUSH
48430: LD_INT 1
48432: ARRAY
48433: PUSH
48434: LD_INT 4
48436: ARRAY
48437: PUSH
48438: LD_VAR 0 2
48442: EQUAL
48443: AND
48444: IFFALSE 48456
// result := true else
48446: LD_ADDR_VAR 0 3
48450: PUSH
48451: LD_INT 1
48453: ST_TO_ADDR
48454: GO 48464
// result := false ;
48456: LD_ADDR_VAR 0 3
48460: PUSH
48461: LD_INT 0
48463: ST_TO_ADDR
// end else
48464: GO 48474
// result := false ;
48466: LD_ADDR_VAR 0 3
48470: PUSH
48471: LD_INT 0
48473: ST_TO_ADDR
// end ;
48474: LD_VAR 0 3
48478: RET
// export function HealTarget ( sci ) ; begin
48479: LD_INT 0
48481: PPUSH
// if not sci then
48482: LD_VAR 0 1
48486: NOT
48487: IFFALSE 48491
// exit ;
48489: GO 48556
// result := 0 ;
48491: LD_ADDR_VAR 0 2
48495: PUSH
48496: LD_INT 0
48498: ST_TO_ADDR
// if GetTaskList ( sci ) then
48499: LD_VAR 0 1
48503: PPUSH
48504: CALL_OW 437
48508: IFFALSE 48556
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48510: LD_VAR 0 1
48514: PPUSH
48515: CALL_OW 437
48519: PUSH
48520: LD_INT 1
48522: ARRAY
48523: PUSH
48524: LD_INT 1
48526: ARRAY
48527: PUSH
48528: LD_STRING l
48530: EQUAL
48531: IFFALSE 48556
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48533: LD_ADDR_VAR 0 2
48537: PUSH
48538: LD_VAR 0 1
48542: PPUSH
48543: CALL_OW 437
48547: PUSH
48548: LD_INT 1
48550: ARRAY
48551: PUSH
48552: LD_INT 4
48554: ARRAY
48555: ST_TO_ADDR
// end ;
48556: LD_VAR 0 2
48560: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
48561: LD_INT 0
48563: PPUSH
48564: PPUSH
48565: PPUSH
48566: PPUSH
48567: PPUSH
48568: PPUSH
48569: PPUSH
48570: PPUSH
48571: PPUSH
48572: PPUSH
48573: PPUSH
48574: PPUSH
48575: PPUSH
48576: PPUSH
48577: PPUSH
48578: PPUSH
48579: PPUSH
48580: PPUSH
48581: PPUSH
48582: PPUSH
48583: PPUSH
48584: PPUSH
48585: PPUSH
48586: PPUSH
48587: PPUSH
48588: PPUSH
48589: PPUSH
48590: PPUSH
48591: PPUSH
48592: PPUSH
48593: PPUSH
48594: PPUSH
48595: PPUSH
// if not list then
48596: LD_VAR 0 1
48600: NOT
48601: IFFALSE 48605
// exit ;
48603: GO 53193
// base := list [ 1 ] ;
48605: LD_ADDR_VAR 0 3
48609: PUSH
48610: LD_VAR 0 1
48614: PUSH
48615: LD_INT 1
48617: ARRAY
48618: ST_TO_ADDR
// group := list [ 2 ] ;
48619: LD_ADDR_VAR 0 4
48623: PUSH
48624: LD_VAR 0 1
48628: PUSH
48629: LD_INT 2
48631: ARRAY
48632: ST_TO_ADDR
// path := list [ 3 ] ;
48633: LD_ADDR_VAR 0 5
48637: PUSH
48638: LD_VAR 0 1
48642: PUSH
48643: LD_INT 3
48645: ARRAY
48646: ST_TO_ADDR
// flags := list [ 4 ] ;
48647: LD_ADDR_VAR 0 6
48651: PUSH
48652: LD_VAR 0 1
48656: PUSH
48657: LD_INT 4
48659: ARRAY
48660: ST_TO_ADDR
// mined := [ ] ;
48661: LD_ADDR_VAR 0 27
48665: PUSH
48666: EMPTY
48667: ST_TO_ADDR
// bombed := [ ] ;
48668: LD_ADDR_VAR 0 28
48672: PUSH
48673: EMPTY
48674: ST_TO_ADDR
// healers := [ ] ;
48675: LD_ADDR_VAR 0 31
48679: PUSH
48680: EMPTY
48681: ST_TO_ADDR
// to_heal := [ ] ;
48682: LD_ADDR_VAR 0 30
48686: PUSH
48687: EMPTY
48688: ST_TO_ADDR
// repairs := [ ] ;
48689: LD_ADDR_VAR 0 33
48693: PUSH
48694: EMPTY
48695: ST_TO_ADDR
// to_repair := [ ] ;
48696: LD_ADDR_VAR 0 32
48700: PUSH
48701: EMPTY
48702: ST_TO_ADDR
// if not group or not path then
48703: LD_VAR 0 4
48707: NOT
48708: PUSH
48709: LD_VAR 0 5
48713: NOT
48714: OR
48715: IFFALSE 48719
// exit ;
48717: GO 53193
// if flags then
48719: LD_VAR 0 6
48723: IFFALSE 48867
// begin f_ignore_area := flags [ 1 ] ;
48725: LD_ADDR_VAR 0 17
48729: PUSH
48730: LD_VAR 0 6
48734: PUSH
48735: LD_INT 1
48737: ARRAY
48738: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
48739: LD_ADDR_VAR 0 18
48743: PUSH
48744: LD_VAR 0 6
48748: PUSH
48749: LD_INT 2
48751: ARRAY
48752: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
48753: LD_ADDR_VAR 0 19
48757: PUSH
48758: LD_VAR 0 6
48762: PUSH
48763: LD_INT 3
48765: ARRAY
48766: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
48767: LD_ADDR_VAR 0 20
48771: PUSH
48772: LD_VAR 0 6
48776: PUSH
48777: LD_INT 4
48779: ARRAY
48780: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
48781: LD_ADDR_VAR 0 21
48785: PUSH
48786: LD_VAR 0 6
48790: PUSH
48791: LD_INT 5
48793: ARRAY
48794: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
48795: LD_ADDR_VAR 0 22
48799: PUSH
48800: LD_VAR 0 6
48804: PUSH
48805: LD_INT 6
48807: ARRAY
48808: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
48809: LD_ADDR_VAR 0 23
48813: PUSH
48814: LD_VAR 0 6
48818: PUSH
48819: LD_INT 7
48821: ARRAY
48822: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
48823: LD_ADDR_VAR 0 24
48827: PUSH
48828: LD_VAR 0 6
48832: PUSH
48833: LD_INT 8
48835: ARRAY
48836: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
48837: LD_ADDR_VAR 0 25
48841: PUSH
48842: LD_VAR 0 6
48846: PUSH
48847: LD_INT 9
48849: ARRAY
48850: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
48851: LD_ADDR_VAR 0 26
48855: PUSH
48856: LD_VAR 0 6
48860: PUSH
48861: LD_INT 10
48863: ARRAY
48864: ST_TO_ADDR
// end else
48865: GO 48947
// begin f_ignore_area := false ;
48867: LD_ADDR_VAR 0 17
48871: PUSH
48872: LD_INT 0
48874: ST_TO_ADDR
// f_capture := false ;
48875: LD_ADDR_VAR 0 18
48879: PUSH
48880: LD_INT 0
48882: ST_TO_ADDR
// f_ignore_civ := false ;
48883: LD_ADDR_VAR 0 19
48887: PUSH
48888: LD_INT 0
48890: ST_TO_ADDR
// f_murder := false ;
48891: LD_ADDR_VAR 0 20
48895: PUSH
48896: LD_INT 0
48898: ST_TO_ADDR
// f_mines := false ;
48899: LD_ADDR_VAR 0 21
48903: PUSH
48904: LD_INT 0
48906: ST_TO_ADDR
// f_repair := false ;
48907: LD_ADDR_VAR 0 22
48911: PUSH
48912: LD_INT 0
48914: ST_TO_ADDR
// f_heal := false ;
48915: LD_ADDR_VAR 0 23
48919: PUSH
48920: LD_INT 0
48922: ST_TO_ADDR
// f_spacetime := false ;
48923: LD_ADDR_VAR 0 24
48927: PUSH
48928: LD_INT 0
48930: ST_TO_ADDR
// f_attack_depot := false ;
48931: LD_ADDR_VAR 0 25
48935: PUSH
48936: LD_INT 0
48938: ST_TO_ADDR
// f_crawl := false ;
48939: LD_ADDR_VAR 0 26
48943: PUSH
48944: LD_INT 0
48946: ST_TO_ADDR
// end ; if f_heal then
48947: LD_VAR 0 23
48951: IFFALSE 48978
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
48953: LD_ADDR_VAR 0 31
48957: PUSH
48958: LD_VAR 0 4
48962: PPUSH
48963: LD_INT 25
48965: PUSH
48966: LD_INT 4
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PPUSH
48973: CALL_OW 72
48977: ST_TO_ADDR
// if f_repair then
48978: LD_VAR 0 22
48982: IFFALSE 49009
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
48984: LD_ADDR_VAR 0 33
48988: PUSH
48989: LD_VAR 0 4
48993: PPUSH
48994: LD_INT 25
48996: PUSH
48997: LD_INT 3
48999: PUSH
49000: EMPTY
49001: LIST
49002: LIST
49003: PPUSH
49004: CALL_OW 72
49008: ST_TO_ADDR
// units_path := [ ] ;
49009: LD_ADDR_VAR 0 16
49013: PUSH
49014: EMPTY
49015: ST_TO_ADDR
// for i = 1 to group do
49016: LD_ADDR_VAR 0 7
49020: PUSH
49021: DOUBLE
49022: LD_INT 1
49024: DEC
49025: ST_TO_ADDR
49026: LD_VAR 0 4
49030: PUSH
49031: FOR_TO
49032: IFFALSE 49061
// units_path := Replace ( units_path , i , path ) ;
49034: LD_ADDR_VAR 0 16
49038: PUSH
49039: LD_VAR 0 16
49043: PPUSH
49044: LD_VAR 0 7
49048: PPUSH
49049: LD_VAR 0 5
49053: PPUSH
49054: CALL_OW 1
49058: ST_TO_ADDR
49059: GO 49031
49061: POP
49062: POP
// repeat for i = group downto 1 do
49063: LD_ADDR_VAR 0 7
49067: PUSH
49068: DOUBLE
49069: LD_VAR 0 4
49073: INC
49074: ST_TO_ADDR
49075: LD_INT 1
49077: PUSH
49078: FOR_DOWNTO
49079: IFFALSE 53175
// begin wait ( 5 ) ;
49081: LD_INT 5
49083: PPUSH
49084: CALL_OW 67
// tmp := [ ] ;
49088: LD_ADDR_VAR 0 14
49092: PUSH
49093: EMPTY
49094: ST_TO_ADDR
// attacking := false ;
49095: LD_ADDR_VAR 0 29
49099: PUSH
49100: LD_INT 0
49102: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49103: LD_VAR 0 4
49107: PUSH
49108: LD_VAR 0 7
49112: ARRAY
49113: PPUSH
49114: CALL_OW 301
49118: PUSH
49119: LD_VAR 0 4
49123: PUSH
49124: LD_VAR 0 7
49128: ARRAY
49129: NOT
49130: OR
49131: IFFALSE 49240
// begin if GetType ( group [ i ] ) = unit_human then
49133: LD_VAR 0 4
49137: PUSH
49138: LD_VAR 0 7
49142: ARRAY
49143: PPUSH
49144: CALL_OW 247
49148: PUSH
49149: LD_INT 1
49151: EQUAL
49152: IFFALSE 49198
// begin to_heal := to_heal diff group [ i ] ;
49154: LD_ADDR_VAR 0 30
49158: PUSH
49159: LD_VAR 0 30
49163: PUSH
49164: LD_VAR 0 4
49168: PUSH
49169: LD_VAR 0 7
49173: ARRAY
49174: DIFF
49175: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49176: LD_ADDR_VAR 0 31
49180: PUSH
49181: LD_VAR 0 31
49185: PUSH
49186: LD_VAR 0 4
49190: PUSH
49191: LD_VAR 0 7
49195: ARRAY
49196: DIFF
49197: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49198: LD_ADDR_VAR 0 4
49202: PUSH
49203: LD_VAR 0 4
49207: PPUSH
49208: LD_VAR 0 7
49212: PPUSH
49213: CALL_OW 3
49217: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49218: LD_ADDR_VAR 0 16
49222: PUSH
49223: LD_VAR 0 16
49227: PPUSH
49228: LD_VAR 0 7
49232: PPUSH
49233: CALL_OW 3
49237: ST_TO_ADDR
// continue ;
49238: GO 49078
// end ; if f_repair then
49240: LD_VAR 0 22
49244: IFFALSE 49733
// begin if GetType ( group [ i ] ) = unit_vehicle then
49246: LD_VAR 0 4
49250: PUSH
49251: LD_VAR 0 7
49255: ARRAY
49256: PPUSH
49257: CALL_OW 247
49261: PUSH
49262: LD_INT 2
49264: EQUAL
49265: IFFALSE 49455
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49267: LD_VAR 0 4
49271: PUSH
49272: LD_VAR 0 7
49276: ARRAY
49277: PPUSH
49278: CALL_OW 256
49282: PUSH
49283: LD_INT 700
49285: LESS
49286: PUSH
49287: LD_VAR 0 4
49291: PUSH
49292: LD_VAR 0 7
49296: ARRAY
49297: PUSH
49298: LD_VAR 0 32
49302: IN
49303: NOT
49304: AND
49305: IFFALSE 49329
// to_repair := to_repair union group [ i ] ;
49307: LD_ADDR_VAR 0 32
49311: PUSH
49312: LD_VAR 0 32
49316: PUSH
49317: LD_VAR 0 4
49321: PUSH
49322: LD_VAR 0 7
49326: ARRAY
49327: UNION
49328: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49329: LD_VAR 0 4
49333: PUSH
49334: LD_VAR 0 7
49338: ARRAY
49339: PPUSH
49340: CALL_OW 256
49344: PUSH
49345: LD_INT 1000
49347: EQUAL
49348: PUSH
49349: LD_VAR 0 4
49353: PUSH
49354: LD_VAR 0 7
49358: ARRAY
49359: PUSH
49360: LD_VAR 0 32
49364: IN
49365: AND
49366: IFFALSE 49390
// to_repair := to_repair diff group [ i ] ;
49368: LD_ADDR_VAR 0 32
49372: PUSH
49373: LD_VAR 0 32
49377: PUSH
49378: LD_VAR 0 4
49382: PUSH
49383: LD_VAR 0 7
49387: ARRAY
49388: DIFF
49389: ST_TO_ADDR
// if group [ i ] in to_repair then
49390: LD_VAR 0 4
49394: PUSH
49395: LD_VAR 0 7
49399: ARRAY
49400: PUSH
49401: LD_VAR 0 32
49405: IN
49406: IFFALSE 49453
// begin if not IsInArea ( group [ i ] , f_repair ) then
49408: LD_VAR 0 4
49412: PUSH
49413: LD_VAR 0 7
49417: ARRAY
49418: PPUSH
49419: LD_VAR 0 22
49423: PPUSH
49424: CALL_OW 308
49428: NOT
49429: IFFALSE 49451
// ComMoveToArea ( group [ i ] , f_repair ) ;
49431: LD_VAR 0 4
49435: PUSH
49436: LD_VAR 0 7
49440: ARRAY
49441: PPUSH
49442: LD_VAR 0 22
49446: PPUSH
49447: CALL_OW 113
// continue ;
49451: GO 49078
// end ; end else
49453: GO 49733
// if group [ i ] in repairs then
49455: LD_VAR 0 4
49459: PUSH
49460: LD_VAR 0 7
49464: ARRAY
49465: PUSH
49466: LD_VAR 0 33
49470: IN
49471: IFFALSE 49733
// begin if IsInUnit ( group [ i ] ) then
49473: LD_VAR 0 4
49477: PUSH
49478: LD_VAR 0 7
49482: ARRAY
49483: PPUSH
49484: CALL_OW 310
49488: IFFALSE 49556
// begin z := IsInUnit ( group [ i ] ) ;
49490: LD_ADDR_VAR 0 13
49494: PUSH
49495: LD_VAR 0 4
49499: PUSH
49500: LD_VAR 0 7
49504: ARRAY
49505: PPUSH
49506: CALL_OW 310
49510: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
49511: LD_VAR 0 13
49515: PUSH
49516: LD_VAR 0 32
49520: IN
49521: PUSH
49522: LD_VAR 0 13
49526: PPUSH
49527: LD_VAR 0 22
49531: PPUSH
49532: CALL_OW 308
49536: AND
49537: IFFALSE 49554
// ComExitVehicle ( group [ i ] ) ;
49539: LD_VAR 0 4
49543: PUSH
49544: LD_VAR 0 7
49548: ARRAY
49549: PPUSH
49550: CALL_OW 121
// end else
49554: GO 49733
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
49556: LD_ADDR_VAR 0 13
49560: PUSH
49561: LD_VAR 0 4
49565: PPUSH
49566: LD_INT 95
49568: PUSH
49569: LD_VAR 0 22
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 58
49580: PUSH
49581: EMPTY
49582: LIST
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PPUSH
49588: CALL_OW 72
49592: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
49593: LD_VAR 0 4
49597: PUSH
49598: LD_VAR 0 7
49602: ARRAY
49603: PPUSH
49604: CALL_OW 314
49608: NOT
49609: IFFALSE 49731
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
49611: LD_ADDR_VAR 0 10
49615: PUSH
49616: LD_VAR 0 13
49620: PPUSH
49621: LD_VAR 0 4
49625: PUSH
49626: LD_VAR 0 7
49630: ARRAY
49631: PPUSH
49632: CALL_OW 74
49636: ST_TO_ADDR
// if not x then
49637: LD_VAR 0 10
49641: NOT
49642: IFFALSE 49646
// continue ;
49644: GO 49078
// if GetLives ( x ) < 1000 then
49646: LD_VAR 0 10
49650: PPUSH
49651: CALL_OW 256
49655: PUSH
49656: LD_INT 1000
49658: LESS
49659: IFFALSE 49683
// ComRepairVehicle ( group [ i ] , x ) else
49661: LD_VAR 0 4
49665: PUSH
49666: LD_VAR 0 7
49670: ARRAY
49671: PPUSH
49672: LD_VAR 0 10
49676: PPUSH
49677: CALL_OW 129
49681: GO 49731
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
49683: LD_VAR 0 23
49687: PUSH
49688: LD_VAR 0 4
49692: PUSH
49693: LD_VAR 0 7
49697: ARRAY
49698: PPUSH
49699: CALL_OW 256
49703: PUSH
49704: LD_INT 1000
49706: LESS
49707: AND
49708: NOT
49709: IFFALSE 49731
// ComEnterUnit ( group [ i ] , x ) ;
49711: LD_VAR 0 4
49715: PUSH
49716: LD_VAR 0 7
49720: ARRAY
49721: PPUSH
49722: LD_VAR 0 10
49726: PPUSH
49727: CALL_OW 120
// end ; continue ;
49731: GO 49078
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
49733: LD_VAR 0 23
49737: PUSH
49738: LD_VAR 0 4
49742: PUSH
49743: LD_VAR 0 7
49747: ARRAY
49748: PPUSH
49749: CALL_OW 247
49753: PUSH
49754: LD_INT 1
49756: EQUAL
49757: AND
49758: IFFALSE 50236
// begin if group [ i ] in healers then
49760: LD_VAR 0 4
49764: PUSH
49765: LD_VAR 0 7
49769: ARRAY
49770: PUSH
49771: LD_VAR 0 31
49775: IN
49776: IFFALSE 50049
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
49778: LD_VAR 0 4
49782: PUSH
49783: LD_VAR 0 7
49787: ARRAY
49788: PPUSH
49789: LD_VAR 0 23
49793: PPUSH
49794: CALL_OW 308
49798: NOT
49799: PUSH
49800: LD_VAR 0 4
49804: PUSH
49805: LD_VAR 0 7
49809: ARRAY
49810: PPUSH
49811: CALL_OW 314
49815: NOT
49816: AND
49817: IFFALSE 49841
// ComMoveToArea ( group [ i ] , f_heal ) else
49819: LD_VAR 0 4
49823: PUSH
49824: LD_VAR 0 7
49828: ARRAY
49829: PPUSH
49830: LD_VAR 0 23
49834: PPUSH
49835: CALL_OW 113
49839: GO 50047
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
49841: LD_VAR 0 4
49845: PUSH
49846: LD_VAR 0 7
49850: ARRAY
49851: PPUSH
49852: CALL 48479 0 1
49856: PPUSH
49857: CALL_OW 256
49861: PUSH
49862: LD_INT 1000
49864: EQUAL
49865: IFFALSE 49884
// ComStop ( group [ i ] ) else
49867: LD_VAR 0 4
49871: PUSH
49872: LD_VAR 0 7
49876: ARRAY
49877: PPUSH
49878: CALL_OW 141
49882: GO 50047
// if not HasTask ( group [ i ] ) and to_heal then
49884: LD_VAR 0 4
49888: PUSH
49889: LD_VAR 0 7
49893: ARRAY
49894: PPUSH
49895: CALL_OW 314
49899: NOT
49900: PUSH
49901: LD_VAR 0 30
49905: AND
49906: IFFALSE 50047
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
49908: LD_ADDR_VAR 0 13
49912: PUSH
49913: LD_VAR 0 30
49917: PPUSH
49918: LD_INT 3
49920: PUSH
49921: LD_INT 54
49923: PUSH
49924: EMPTY
49925: LIST
49926: PUSH
49927: EMPTY
49928: LIST
49929: LIST
49930: PPUSH
49931: CALL_OW 72
49935: PPUSH
49936: LD_VAR 0 4
49940: PUSH
49941: LD_VAR 0 7
49945: ARRAY
49946: PPUSH
49947: CALL_OW 74
49951: ST_TO_ADDR
// if z then
49952: LD_VAR 0 13
49956: IFFALSE 50047
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
49958: LD_INT 91
49960: PUSH
49961: LD_VAR 0 13
49965: PUSH
49966: LD_INT 10
49968: PUSH
49969: EMPTY
49970: LIST
49971: LIST
49972: LIST
49973: PUSH
49974: LD_INT 81
49976: PUSH
49977: LD_VAR 0 13
49981: PPUSH
49982: CALL_OW 255
49986: PUSH
49987: EMPTY
49988: LIST
49989: LIST
49990: PUSH
49991: EMPTY
49992: LIST
49993: LIST
49994: PPUSH
49995: CALL_OW 69
49999: PUSH
50000: LD_INT 0
50002: EQUAL
50003: IFFALSE 50027
// ComHeal ( group [ i ] , z ) else
50005: LD_VAR 0 4
50009: PUSH
50010: LD_VAR 0 7
50014: ARRAY
50015: PPUSH
50016: LD_VAR 0 13
50020: PPUSH
50021: CALL_OW 128
50025: GO 50047
// ComMoveToArea ( group [ i ] , f_heal ) ;
50027: LD_VAR 0 4
50031: PUSH
50032: LD_VAR 0 7
50036: ARRAY
50037: PPUSH
50038: LD_VAR 0 23
50042: PPUSH
50043: CALL_OW 113
// end ; continue ;
50047: GO 49078
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50049: LD_VAR 0 4
50053: PUSH
50054: LD_VAR 0 7
50058: ARRAY
50059: PPUSH
50060: CALL_OW 256
50064: PUSH
50065: LD_INT 700
50067: LESS
50068: PUSH
50069: LD_VAR 0 4
50073: PUSH
50074: LD_VAR 0 7
50078: ARRAY
50079: PUSH
50080: LD_VAR 0 30
50084: IN
50085: NOT
50086: AND
50087: IFFALSE 50111
// to_heal := to_heal union group [ i ] ;
50089: LD_ADDR_VAR 0 30
50093: PUSH
50094: LD_VAR 0 30
50098: PUSH
50099: LD_VAR 0 4
50103: PUSH
50104: LD_VAR 0 7
50108: ARRAY
50109: UNION
50110: ST_TO_ADDR
// if group [ i ] in to_heal then
50111: LD_VAR 0 4
50115: PUSH
50116: LD_VAR 0 7
50120: ARRAY
50121: PUSH
50122: LD_VAR 0 30
50126: IN
50127: IFFALSE 50236
// begin if GetLives ( group [ i ] ) = 1000 then
50129: LD_VAR 0 4
50133: PUSH
50134: LD_VAR 0 7
50138: ARRAY
50139: PPUSH
50140: CALL_OW 256
50144: PUSH
50145: LD_INT 1000
50147: EQUAL
50148: IFFALSE 50174
// to_heal := to_heal diff group [ i ] else
50150: LD_ADDR_VAR 0 30
50154: PUSH
50155: LD_VAR 0 30
50159: PUSH
50160: LD_VAR 0 4
50164: PUSH
50165: LD_VAR 0 7
50169: ARRAY
50170: DIFF
50171: ST_TO_ADDR
50172: GO 50236
// begin if not IsInArea ( group [ i ] , to_heal ) then
50174: LD_VAR 0 4
50178: PUSH
50179: LD_VAR 0 7
50183: ARRAY
50184: PPUSH
50185: LD_VAR 0 30
50189: PPUSH
50190: CALL_OW 308
50194: NOT
50195: IFFALSE 50219
// ComMoveToArea ( group [ i ] , f_heal ) else
50197: LD_VAR 0 4
50201: PUSH
50202: LD_VAR 0 7
50206: ARRAY
50207: PPUSH
50208: LD_VAR 0 23
50212: PPUSH
50213: CALL_OW 113
50217: GO 50234
// ComHold ( group [ i ] ) ;
50219: LD_VAR 0 4
50223: PUSH
50224: LD_VAR 0 7
50228: ARRAY
50229: PPUSH
50230: CALL_OW 140
// continue ;
50234: GO 49078
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50236: LD_VAR 0 4
50240: PUSH
50241: LD_VAR 0 7
50245: ARRAY
50246: PPUSH
50247: LD_INT 10
50249: PPUSH
50250: CALL 46876 0 2
50254: NOT
50255: PUSH
50256: LD_VAR 0 16
50260: PUSH
50261: LD_VAR 0 7
50265: ARRAY
50266: PUSH
50267: EMPTY
50268: EQUAL
50269: NOT
50270: AND
50271: IFFALSE 50537
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50273: LD_VAR 0 4
50277: PUSH
50278: LD_VAR 0 7
50282: ARRAY
50283: PPUSH
50284: CALL_OW 262
50288: PUSH
50289: LD_INT 1
50291: PUSH
50292: LD_INT 2
50294: PUSH
50295: EMPTY
50296: LIST
50297: LIST
50298: IN
50299: IFFALSE 50340
// if GetFuel ( group [ i ] ) < 10 then
50301: LD_VAR 0 4
50305: PUSH
50306: LD_VAR 0 7
50310: ARRAY
50311: PPUSH
50312: CALL_OW 261
50316: PUSH
50317: LD_INT 10
50319: LESS
50320: IFFALSE 50340
// SetFuel ( group [ i ] , 12 ) ;
50322: LD_VAR 0 4
50326: PUSH
50327: LD_VAR 0 7
50331: ARRAY
50332: PPUSH
50333: LD_INT 12
50335: PPUSH
50336: CALL_OW 240
// if units_path [ i ] then
50340: LD_VAR 0 16
50344: PUSH
50345: LD_VAR 0 7
50349: ARRAY
50350: IFFALSE 50535
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50352: LD_VAR 0 4
50356: PUSH
50357: LD_VAR 0 7
50361: ARRAY
50362: PPUSH
50363: LD_VAR 0 16
50367: PUSH
50368: LD_VAR 0 7
50372: ARRAY
50373: PUSH
50374: LD_INT 1
50376: ARRAY
50377: PUSH
50378: LD_INT 1
50380: ARRAY
50381: PPUSH
50382: LD_VAR 0 16
50386: PUSH
50387: LD_VAR 0 7
50391: ARRAY
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PUSH
50397: LD_INT 2
50399: ARRAY
50400: PPUSH
50401: CALL_OW 297
50405: PUSH
50406: LD_INT 6
50408: GREATER
50409: IFFALSE 50484
// begin if not HasTask ( group [ i ] ) then
50411: LD_VAR 0 4
50415: PUSH
50416: LD_VAR 0 7
50420: ARRAY
50421: PPUSH
50422: CALL_OW 314
50426: NOT
50427: IFFALSE 50482
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
50429: LD_VAR 0 4
50433: PUSH
50434: LD_VAR 0 7
50438: ARRAY
50439: PPUSH
50440: LD_VAR 0 16
50444: PUSH
50445: LD_VAR 0 7
50449: ARRAY
50450: PUSH
50451: LD_INT 1
50453: ARRAY
50454: PUSH
50455: LD_INT 1
50457: ARRAY
50458: PPUSH
50459: LD_VAR 0 16
50463: PUSH
50464: LD_VAR 0 7
50468: ARRAY
50469: PUSH
50470: LD_INT 1
50472: ARRAY
50473: PUSH
50474: LD_INT 2
50476: ARRAY
50477: PPUSH
50478: CALL_OW 114
// end else
50482: GO 50535
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
50484: LD_ADDR_VAR 0 15
50488: PUSH
50489: LD_VAR 0 16
50493: PUSH
50494: LD_VAR 0 7
50498: ARRAY
50499: PPUSH
50500: LD_INT 1
50502: PPUSH
50503: CALL_OW 3
50507: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
50508: LD_ADDR_VAR 0 16
50512: PUSH
50513: LD_VAR 0 16
50517: PPUSH
50518: LD_VAR 0 7
50522: PPUSH
50523: LD_VAR 0 15
50527: PPUSH
50528: CALL_OW 1
50532: ST_TO_ADDR
// continue ;
50533: GO 49078
// end ; end ; end else
50535: GO 53173
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
50537: LD_ADDR_VAR 0 14
50541: PUSH
50542: LD_INT 81
50544: PUSH
50545: LD_VAR 0 4
50549: PUSH
50550: LD_VAR 0 7
50554: ARRAY
50555: PPUSH
50556: CALL_OW 255
50560: PUSH
50561: EMPTY
50562: LIST
50563: LIST
50564: PPUSH
50565: CALL_OW 69
50569: ST_TO_ADDR
// if not tmp then
50570: LD_VAR 0 14
50574: NOT
50575: IFFALSE 50579
// continue ;
50577: GO 49078
// if f_ignore_area then
50579: LD_VAR 0 17
50583: IFFALSE 50671
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
50585: LD_ADDR_VAR 0 15
50589: PUSH
50590: LD_VAR 0 14
50594: PPUSH
50595: LD_INT 3
50597: PUSH
50598: LD_INT 92
50600: PUSH
50601: LD_VAR 0 17
50605: PUSH
50606: LD_INT 1
50608: ARRAY
50609: PUSH
50610: LD_VAR 0 17
50614: PUSH
50615: LD_INT 2
50617: ARRAY
50618: PUSH
50619: LD_VAR 0 17
50623: PUSH
50624: LD_INT 3
50626: ARRAY
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: LIST
50632: LIST
50633: PUSH
50634: EMPTY
50635: LIST
50636: LIST
50637: PPUSH
50638: CALL_OW 72
50642: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50643: LD_VAR 0 14
50647: PUSH
50648: LD_VAR 0 15
50652: DIFF
50653: IFFALSE 50671
// tmp := tmp diff tmp2 ;
50655: LD_ADDR_VAR 0 14
50659: PUSH
50660: LD_VAR 0 14
50664: PUSH
50665: LD_VAR 0 15
50669: DIFF
50670: ST_TO_ADDR
// end ; if not f_murder then
50671: LD_VAR 0 20
50675: NOT
50676: IFFALSE 50734
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
50678: LD_ADDR_VAR 0 15
50682: PUSH
50683: LD_VAR 0 14
50687: PPUSH
50688: LD_INT 3
50690: PUSH
50691: LD_INT 50
50693: PUSH
50694: EMPTY
50695: LIST
50696: PUSH
50697: EMPTY
50698: LIST
50699: LIST
50700: PPUSH
50701: CALL_OW 72
50705: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
50706: LD_VAR 0 14
50710: PUSH
50711: LD_VAR 0 15
50715: DIFF
50716: IFFALSE 50734
// tmp := tmp diff tmp2 ;
50718: LD_ADDR_VAR 0 14
50722: PUSH
50723: LD_VAR 0 14
50727: PUSH
50728: LD_VAR 0 15
50732: DIFF
50733: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
50734: LD_ADDR_VAR 0 14
50738: PUSH
50739: LD_VAR 0 4
50743: PUSH
50744: LD_VAR 0 7
50748: ARRAY
50749: PPUSH
50750: LD_VAR 0 14
50754: PPUSH
50755: LD_INT 1
50757: PPUSH
50758: LD_INT 1
50760: PPUSH
50761: CALL 20730 0 4
50765: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
50766: LD_VAR 0 4
50770: PUSH
50771: LD_VAR 0 7
50775: ARRAY
50776: PPUSH
50777: CALL_OW 257
50781: PUSH
50782: LD_INT 1
50784: EQUAL
50785: IFFALSE 51233
// begin if WantPlant ( group [ i ] ) then
50787: LD_VAR 0 4
50791: PUSH
50792: LD_VAR 0 7
50796: ARRAY
50797: PPUSH
50798: CALL 20198 0 1
50802: IFFALSE 50806
// continue ;
50804: GO 49078
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
50806: LD_VAR 0 18
50810: PUSH
50811: LD_VAR 0 4
50815: PUSH
50816: LD_VAR 0 7
50820: ARRAY
50821: PPUSH
50822: CALL_OW 310
50826: NOT
50827: AND
50828: PUSH
50829: LD_VAR 0 14
50833: PUSH
50834: LD_INT 1
50836: ARRAY
50837: PUSH
50838: LD_VAR 0 14
50842: PPUSH
50843: LD_INT 21
50845: PUSH
50846: LD_INT 2
50848: PUSH
50849: EMPTY
50850: LIST
50851: LIST
50852: PUSH
50853: LD_INT 58
50855: PUSH
50856: EMPTY
50857: LIST
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PPUSH
50863: CALL_OW 72
50867: IN
50868: AND
50869: IFFALSE 50905
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
50871: LD_VAR 0 4
50875: PUSH
50876: LD_VAR 0 7
50880: ARRAY
50881: PPUSH
50882: LD_VAR 0 14
50886: PUSH
50887: LD_INT 1
50889: ARRAY
50890: PPUSH
50891: CALL_OW 120
// attacking := true ;
50895: LD_ADDR_VAR 0 29
50899: PUSH
50900: LD_INT 1
50902: ST_TO_ADDR
// continue ;
50903: GO 49078
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
50905: LD_VAR 0 26
50909: PUSH
50910: LD_VAR 0 4
50914: PUSH
50915: LD_VAR 0 7
50919: ARRAY
50920: PPUSH
50921: CALL_OW 257
50925: PUSH
50926: LD_INT 1
50928: EQUAL
50929: AND
50930: PUSH
50931: LD_VAR 0 4
50935: PUSH
50936: LD_VAR 0 7
50940: ARRAY
50941: PPUSH
50942: CALL_OW 256
50946: PUSH
50947: LD_INT 800
50949: LESS
50950: AND
50951: PUSH
50952: LD_VAR 0 4
50956: PUSH
50957: LD_VAR 0 7
50961: ARRAY
50962: PPUSH
50963: CALL_OW 318
50967: NOT
50968: AND
50969: IFFALSE 50986
// ComCrawl ( group [ i ] ) ;
50971: LD_VAR 0 4
50975: PUSH
50976: LD_VAR 0 7
50980: ARRAY
50981: PPUSH
50982: CALL_OW 137
// if f_mines then
50986: LD_VAR 0 21
50990: IFFALSE 51233
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
50992: LD_VAR 0 14
50996: PUSH
50997: LD_INT 1
50999: ARRAY
51000: PPUSH
51001: CALL_OW 247
51005: PUSH
51006: LD_INT 3
51008: EQUAL
51009: PUSH
51010: LD_VAR 0 14
51014: PUSH
51015: LD_INT 1
51017: ARRAY
51018: PUSH
51019: LD_VAR 0 27
51023: IN
51024: NOT
51025: AND
51026: IFFALSE 51233
// begin x := GetX ( tmp [ 1 ] ) ;
51028: LD_ADDR_VAR 0 10
51032: PUSH
51033: LD_VAR 0 14
51037: PUSH
51038: LD_INT 1
51040: ARRAY
51041: PPUSH
51042: CALL_OW 250
51046: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51047: LD_ADDR_VAR 0 11
51051: PUSH
51052: LD_VAR 0 14
51056: PUSH
51057: LD_INT 1
51059: ARRAY
51060: PPUSH
51061: CALL_OW 251
51065: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51066: LD_ADDR_VAR 0 12
51070: PUSH
51071: LD_VAR 0 4
51075: PUSH
51076: LD_VAR 0 7
51080: ARRAY
51081: PPUSH
51082: CALL 46961 0 1
51086: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51087: LD_VAR 0 4
51091: PUSH
51092: LD_VAR 0 7
51096: ARRAY
51097: PPUSH
51098: LD_VAR 0 10
51102: PPUSH
51103: LD_VAR 0 11
51107: PPUSH
51108: LD_VAR 0 14
51112: PUSH
51113: LD_INT 1
51115: ARRAY
51116: PPUSH
51117: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51121: LD_VAR 0 4
51125: PUSH
51126: LD_VAR 0 7
51130: ARRAY
51131: PPUSH
51132: LD_VAR 0 10
51136: PPUSH
51137: LD_VAR 0 12
51141: PPUSH
51142: LD_INT 7
51144: PPUSH
51145: CALL_OW 272
51149: PPUSH
51150: LD_VAR 0 11
51154: PPUSH
51155: LD_VAR 0 12
51159: PPUSH
51160: LD_INT 7
51162: PPUSH
51163: CALL_OW 273
51167: PPUSH
51168: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51172: LD_VAR 0 4
51176: PUSH
51177: LD_VAR 0 7
51181: ARRAY
51182: PPUSH
51183: LD_INT 71
51185: PPUSH
51186: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51190: LD_ADDR_VAR 0 27
51194: PUSH
51195: LD_VAR 0 27
51199: PPUSH
51200: LD_VAR 0 27
51204: PUSH
51205: LD_INT 1
51207: PLUS
51208: PPUSH
51209: LD_VAR 0 14
51213: PUSH
51214: LD_INT 1
51216: ARRAY
51217: PPUSH
51218: CALL_OW 1
51222: ST_TO_ADDR
// attacking := true ;
51223: LD_ADDR_VAR 0 29
51227: PUSH
51228: LD_INT 1
51230: ST_TO_ADDR
// continue ;
51231: GO 49078
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51233: LD_VAR 0 4
51237: PUSH
51238: LD_VAR 0 7
51242: ARRAY
51243: PPUSH
51244: CALL_OW 257
51248: PUSH
51249: LD_INT 17
51251: EQUAL
51252: PUSH
51253: LD_VAR 0 4
51257: PUSH
51258: LD_VAR 0 7
51262: ARRAY
51263: PPUSH
51264: CALL_OW 110
51268: PUSH
51269: LD_INT 71
51271: EQUAL
51272: NOT
51273: AND
51274: IFFALSE 51420
// begin attacking := false ;
51276: LD_ADDR_VAR 0 29
51280: PUSH
51281: LD_INT 0
51283: ST_TO_ADDR
// k := 5 ;
51284: LD_ADDR_VAR 0 9
51288: PUSH
51289: LD_INT 5
51291: ST_TO_ADDR
// if tmp < k then
51292: LD_VAR 0 14
51296: PUSH
51297: LD_VAR 0 9
51301: LESS
51302: IFFALSE 51314
// k := tmp ;
51304: LD_ADDR_VAR 0 9
51308: PUSH
51309: LD_VAR 0 14
51313: ST_TO_ADDR
// for j = 1 to k do
51314: LD_ADDR_VAR 0 8
51318: PUSH
51319: DOUBLE
51320: LD_INT 1
51322: DEC
51323: ST_TO_ADDR
51324: LD_VAR 0 9
51328: PUSH
51329: FOR_TO
51330: IFFALSE 51418
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51332: LD_VAR 0 14
51336: PUSH
51337: LD_VAR 0 8
51341: ARRAY
51342: PUSH
51343: LD_VAR 0 14
51347: PPUSH
51348: LD_INT 58
51350: PUSH
51351: EMPTY
51352: LIST
51353: PPUSH
51354: CALL_OW 72
51358: IN
51359: NOT
51360: IFFALSE 51416
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51362: LD_VAR 0 4
51366: PUSH
51367: LD_VAR 0 7
51371: ARRAY
51372: PPUSH
51373: LD_VAR 0 14
51377: PUSH
51378: LD_VAR 0 8
51382: ARRAY
51383: PPUSH
51384: CALL_OW 115
// attacking := true ;
51388: LD_ADDR_VAR 0 29
51392: PUSH
51393: LD_INT 1
51395: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51396: LD_VAR 0 4
51400: PUSH
51401: LD_VAR 0 7
51405: ARRAY
51406: PPUSH
51407: LD_INT 71
51409: PPUSH
51410: CALL_OW 109
// continue ;
51414: GO 51329
// end ; end ;
51416: GO 51329
51418: POP
51419: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
51420: LD_VAR 0 4
51424: PUSH
51425: LD_VAR 0 7
51429: ARRAY
51430: PPUSH
51431: CALL_OW 257
51435: PUSH
51436: LD_INT 8
51438: EQUAL
51439: PUSH
51440: LD_VAR 0 4
51444: PUSH
51445: LD_VAR 0 7
51449: ARRAY
51450: PPUSH
51451: CALL_OW 264
51455: PUSH
51456: LD_INT 28
51458: PUSH
51459: LD_INT 45
51461: PUSH
51462: LD_INT 7
51464: PUSH
51465: LD_INT 47
51467: PUSH
51468: EMPTY
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: IN
51474: OR
51475: IFFALSE 51705
// begin attacking := false ;
51477: LD_ADDR_VAR 0 29
51481: PUSH
51482: LD_INT 0
51484: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
51485: LD_VAR 0 14
51489: PUSH
51490: LD_INT 1
51492: ARRAY
51493: PPUSH
51494: CALL_OW 266
51498: PUSH
51499: LD_INT 32
51501: PUSH
51502: LD_INT 31
51504: PUSH
51505: LD_INT 33
51507: PUSH
51508: LD_INT 4
51510: PUSH
51511: LD_INT 5
51513: PUSH
51514: EMPTY
51515: LIST
51516: LIST
51517: LIST
51518: LIST
51519: LIST
51520: IN
51521: IFFALSE 51705
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
51523: LD_ADDR_VAR 0 9
51527: PUSH
51528: LD_VAR 0 14
51532: PUSH
51533: LD_INT 1
51535: ARRAY
51536: PPUSH
51537: CALL_OW 266
51541: PPUSH
51542: LD_VAR 0 14
51546: PUSH
51547: LD_INT 1
51549: ARRAY
51550: PPUSH
51551: CALL_OW 250
51555: PPUSH
51556: LD_VAR 0 14
51560: PUSH
51561: LD_INT 1
51563: ARRAY
51564: PPUSH
51565: CALL_OW 251
51569: PPUSH
51570: LD_VAR 0 14
51574: PUSH
51575: LD_INT 1
51577: ARRAY
51578: PPUSH
51579: CALL_OW 254
51583: PPUSH
51584: LD_VAR 0 14
51588: PUSH
51589: LD_INT 1
51591: ARRAY
51592: PPUSH
51593: CALL_OW 248
51597: PPUSH
51598: LD_INT 0
51600: PPUSH
51601: CALL 28337 0 6
51605: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
51606: LD_ADDR_VAR 0 8
51610: PUSH
51611: LD_VAR 0 4
51615: PUSH
51616: LD_VAR 0 7
51620: ARRAY
51621: PPUSH
51622: LD_VAR 0 9
51626: PPUSH
51627: CALL 47024 0 2
51631: ST_TO_ADDR
// if j then
51632: LD_VAR 0 8
51636: IFFALSE 51705
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
51638: LD_VAR 0 8
51642: PUSH
51643: LD_INT 1
51645: ARRAY
51646: PPUSH
51647: LD_VAR 0 8
51651: PUSH
51652: LD_INT 2
51654: ARRAY
51655: PPUSH
51656: CALL_OW 488
51660: IFFALSE 51705
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
51662: LD_VAR 0 4
51666: PUSH
51667: LD_VAR 0 7
51671: ARRAY
51672: PPUSH
51673: LD_VAR 0 8
51677: PUSH
51678: LD_INT 1
51680: ARRAY
51681: PPUSH
51682: LD_VAR 0 8
51686: PUSH
51687: LD_INT 2
51689: ARRAY
51690: PPUSH
51691: CALL_OW 116
// attacking := true ;
51695: LD_ADDR_VAR 0 29
51699: PUSH
51700: LD_INT 1
51702: ST_TO_ADDR
// continue ;
51703: GO 49078
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
51705: LD_VAR 0 4
51709: PUSH
51710: LD_VAR 0 7
51714: ARRAY
51715: PPUSH
51716: CALL_OW 265
51720: PUSH
51721: LD_INT 11
51723: EQUAL
51724: IFFALSE 52002
// begin k := 10 ;
51726: LD_ADDR_VAR 0 9
51730: PUSH
51731: LD_INT 10
51733: ST_TO_ADDR
// x := 0 ;
51734: LD_ADDR_VAR 0 10
51738: PUSH
51739: LD_INT 0
51741: ST_TO_ADDR
// if tmp < k then
51742: LD_VAR 0 14
51746: PUSH
51747: LD_VAR 0 9
51751: LESS
51752: IFFALSE 51764
// k := tmp ;
51754: LD_ADDR_VAR 0 9
51758: PUSH
51759: LD_VAR 0 14
51763: ST_TO_ADDR
// for j = k downto 1 do
51764: LD_ADDR_VAR 0 8
51768: PUSH
51769: DOUBLE
51770: LD_VAR 0 9
51774: INC
51775: ST_TO_ADDR
51776: LD_INT 1
51778: PUSH
51779: FOR_DOWNTO
51780: IFFALSE 51855
// begin if GetType ( tmp [ j ] ) = unit_human then
51782: LD_VAR 0 14
51786: PUSH
51787: LD_VAR 0 8
51791: ARRAY
51792: PPUSH
51793: CALL_OW 247
51797: PUSH
51798: LD_INT 1
51800: EQUAL
51801: IFFALSE 51853
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
51803: LD_VAR 0 4
51807: PUSH
51808: LD_VAR 0 7
51812: ARRAY
51813: PPUSH
51814: LD_VAR 0 14
51818: PUSH
51819: LD_VAR 0 8
51823: ARRAY
51824: PPUSH
51825: CALL 47295 0 2
// x := tmp [ j ] ;
51829: LD_ADDR_VAR 0 10
51833: PUSH
51834: LD_VAR 0 14
51838: PUSH
51839: LD_VAR 0 8
51843: ARRAY
51844: ST_TO_ADDR
// attacking := true ;
51845: LD_ADDR_VAR 0 29
51849: PUSH
51850: LD_INT 1
51852: ST_TO_ADDR
// end ; end ;
51853: GO 51779
51855: POP
51856: POP
// if not x then
51857: LD_VAR 0 10
51861: NOT
51862: IFFALSE 52002
// begin attacking := true ;
51864: LD_ADDR_VAR 0 29
51868: PUSH
51869: LD_INT 1
51871: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
51872: LD_VAR 0 4
51876: PUSH
51877: LD_VAR 0 7
51881: ARRAY
51882: PPUSH
51883: CALL_OW 250
51887: PPUSH
51888: LD_VAR 0 4
51892: PUSH
51893: LD_VAR 0 7
51897: ARRAY
51898: PPUSH
51899: CALL_OW 251
51903: PPUSH
51904: CALL_OW 546
51908: PUSH
51909: LD_INT 2
51911: ARRAY
51912: PUSH
51913: LD_VAR 0 14
51917: PUSH
51918: LD_INT 1
51920: ARRAY
51921: PPUSH
51922: CALL_OW 250
51926: PPUSH
51927: LD_VAR 0 14
51931: PUSH
51932: LD_INT 1
51934: ARRAY
51935: PPUSH
51936: CALL_OW 251
51940: PPUSH
51941: CALL_OW 546
51945: PUSH
51946: LD_INT 2
51948: ARRAY
51949: EQUAL
51950: IFFALSE 51978
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
51952: LD_VAR 0 4
51956: PUSH
51957: LD_VAR 0 7
51961: ARRAY
51962: PPUSH
51963: LD_VAR 0 14
51967: PUSH
51968: LD_INT 1
51970: ARRAY
51971: PPUSH
51972: CALL 47295 0 2
51976: GO 52002
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
51978: LD_VAR 0 4
51982: PUSH
51983: LD_VAR 0 7
51987: ARRAY
51988: PPUSH
51989: LD_VAR 0 14
51993: PUSH
51994: LD_INT 1
51996: ARRAY
51997: PPUSH
51998: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52002: LD_VAR 0 4
52006: PUSH
52007: LD_VAR 0 7
52011: ARRAY
52012: PPUSH
52013: CALL_OW 264
52017: PUSH
52018: LD_INT 29
52020: EQUAL
52021: IFFALSE 52387
// begin if WantsToAttack ( group [ i ] ) in bombed then
52023: LD_VAR 0 4
52027: PUSH
52028: LD_VAR 0 7
52032: ARRAY
52033: PPUSH
52034: CALL_OW 319
52038: PUSH
52039: LD_VAR 0 28
52043: IN
52044: IFFALSE 52048
// continue ;
52046: GO 49078
// k := 8 ;
52048: LD_ADDR_VAR 0 9
52052: PUSH
52053: LD_INT 8
52055: ST_TO_ADDR
// x := 0 ;
52056: LD_ADDR_VAR 0 10
52060: PUSH
52061: LD_INT 0
52063: ST_TO_ADDR
// if tmp < k then
52064: LD_VAR 0 14
52068: PUSH
52069: LD_VAR 0 9
52073: LESS
52074: IFFALSE 52086
// k := tmp ;
52076: LD_ADDR_VAR 0 9
52080: PUSH
52081: LD_VAR 0 14
52085: ST_TO_ADDR
// for j = 1 to k do
52086: LD_ADDR_VAR 0 8
52090: PUSH
52091: DOUBLE
52092: LD_INT 1
52094: DEC
52095: ST_TO_ADDR
52096: LD_VAR 0 9
52100: PUSH
52101: FOR_TO
52102: IFFALSE 52234
// begin if GetType ( tmp [ j ] ) = unit_building then
52104: LD_VAR 0 14
52108: PUSH
52109: LD_VAR 0 8
52113: ARRAY
52114: PPUSH
52115: CALL_OW 247
52119: PUSH
52120: LD_INT 3
52122: EQUAL
52123: IFFALSE 52232
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52125: LD_VAR 0 14
52129: PUSH
52130: LD_VAR 0 8
52134: ARRAY
52135: PUSH
52136: LD_VAR 0 28
52140: IN
52141: NOT
52142: PUSH
52143: LD_VAR 0 14
52147: PUSH
52148: LD_VAR 0 8
52152: ARRAY
52153: PPUSH
52154: CALL_OW 313
52158: AND
52159: IFFALSE 52232
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52161: LD_VAR 0 4
52165: PUSH
52166: LD_VAR 0 7
52170: ARRAY
52171: PPUSH
52172: LD_VAR 0 14
52176: PUSH
52177: LD_VAR 0 8
52181: ARRAY
52182: PPUSH
52183: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52187: LD_ADDR_VAR 0 28
52191: PUSH
52192: LD_VAR 0 28
52196: PPUSH
52197: LD_VAR 0 28
52201: PUSH
52202: LD_INT 1
52204: PLUS
52205: PPUSH
52206: LD_VAR 0 14
52210: PUSH
52211: LD_VAR 0 8
52215: ARRAY
52216: PPUSH
52217: CALL_OW 1
52221: ST_TO_ADDR
// attacking := true ;
52222: LD_ADDR_VAR 0 29
52226: PUSH
52227: LD_INT 1
52229: ST_TO_ADDR
// break ;
52230: GO 52234
// end ; end ;
52232: GO 52101
52234: POP
52235: POP
// if not attacking and f_attack_depot then
52236: LD_VAR 0 29
52240: NOT
52241: PUSH
52242: LD_VAR 0 25
52246: AND
52247: IFFALSE 52342
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52249: LD_ADDR_VAR 0 13
52253: PUSH
52254: LD_VAR 0 14
52258: PPUSH
52259: LD_INT 2
52261: PUSH
52262: LD_INT 30
52264: PUSH
52265: LD_INT 0
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: PUSH
52272: LD_INT 30
52274: PUSH
52275: LD_INT 1
52277: PUSH
52278: EMPTY
52279: LIST
52280: LIST
52281: PUSH
52282: EMPTY
52283: LIST
52284: LIST
52285: LIST
52286: PPUSH
52287: CALL_OW 72
52291: ST_TO_ADDR
// if z then
52292: LD_VAR 0 13
52296: IFFALSE 52342
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52298: LD_VAR 0 4
52302: PUSH
52303: LD_VAR 0 7
52307: ARRAY
52308: PPUSH
52309: LD_VAR 0 13
52313: PPUSH
52314: LD_VAR 0 4
52318: PUSH
52319: LD_VAR 0 7
52323: ARRAY
52324: PPUSH
52325: CALL_OW 74
52329: PPUSH
52330: CALL_OW 115
// attacking := true ;
52334: LD_ADDR_VAR 0 29
52338: PUSH
52339: LD_INT 1
52341: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52342: LD_VAR 0 4
52346: PUSH
52347: LD_VAR 0 7
52351: ARRAY
52352: PPUSH
52353: CALL_OW 256
52357: PUSH
52358: LD_INT 500
52360: LESS
52361: IFFALSE 52387
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52363: LD_VAR 0 4
52367: PUSH
52368: LD_VAR 0 7
52372: ARRAY
52373: PPUSH
52374: LD_VAR 0 14
52378: PUSH
52379: LD_INT 1
52381: ARRAY
52382: PPUSH
52383: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52387: LD_VAR 0 4
52391: PUSH
52392: LD_VAR 0 7
52396: ARRAY
52397: PPUSH
52398: CALL_OW 264
52402: PUSH
52403: LD_INT 49
52405: EQUAL
52406: IFFALSE 52527
// begin if not HasTask ( group [ i ] ) then
52408: LD_VAR 0 4
52412: PUSH
52413: LD_VAR 0 7
52417: ARRAY
52418: PPUSH
52419: CALL_OW 314
52423: NOT
52424: IFFALSE 52527
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
52426: LD_ADDR_VAR 0 9
52430: PUSH
52431: LD_INT 81
52433: PUSH
52434: LD_VAR 0 4
52438: PUSH
52439: LD_VAR 0 7
52443: ARRAY
52444: PPUSH
52445: CALL_OW 255
52449: PUSH
52450: EMPTY
52451: LIST
52452: LIST
52453: PPUSH
52454: CALL_OW 69
52458: PPUSH
52459: LD_VAR 0 4
52463: PUSH
52464: LD_VAR 0 7
52468: ARRAY
52469: PPUSH
52470: CALL_OW 74
52474: ST_TO_ADDR
// if k then
52475: LD_VAR 0 9
52479: IFFALSE 52527
// if GetDistUnits ( group [ i ] , k ) > 10 then
52481: LD_VAR 0 4
52485: PUSH
52486: LD_VAR 0 7
52490: ARRAY
52491: PPUSH
52492: LD_VAR 0 9
52496: PPUSH
52497: CALL_OW 296
52501: PUSH
52502: LD_INT 10
52504: GREATER
52505: IFFALSE 52527
// ComMoveUnit ( group [ i ] , k ) ;
52507: LD_VAR 0 4
52511: PUSH
52512: LD_VAR 0 7
52516: ARRAY
52517: PPUSH
52518: LD_VAR 0 9
52522: PPUSH
52523: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
52527: LD_VAR 0 4
52531: PUSH
52532: LD_VAR 0 7
52536: ARRAY
52537: PPUSH
52538: CALL_OW 256
52542: PUSH
52543: LD_INT 250
52545: LESS
52546: PUSH
52547: LD_VAR 0 4
52551: PUSH
52552: LD_VAR 0 7
52556: ARRAY
52557: PUSH
52558: LD_INT 21
52560: PUSH
52561: LD_INT 2
52563: PUSH
52564: EMPTY
52565: LIST
52566: LIST
52567: PUSH
52568: LD_INT 23
52570: PUSH
52571: LD_INT 2
52573: PUSH
52574: EMPTY
52575: LIST
52576: LIST
52577: PUSH
52578: EMPTY
52579: LIST
52580: LIST
52581: PPUSH
52582: CALL_OW 69
52586: IN
52587: AND
52588: IFFALSE 52713
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
52590: LD_ADDR_VAR 0 9
52594: PUSH
52595: LD_OWVAR 3
52599: PUSH
52600: LD_VAR 0 4
52604: PUSH
52605: LD_VAR 0 7
52609: ARRAY
52610: DIFF
52611: PPUSH
52612: LD_VAR 0 4
52616: PUSH
52617: LD_VAR 0 7
52621: ARRAY
52622: PPUSH
52623: CALL_OW 74
52627: ST_TO_ADDR
// if not k then
52628: LD_VAR 0 9
52632: NOT
52633: IFFALSE 52637
// continue ;
52635: GO 49078
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
52637: LD_VAR 0 9
52641: PUSH
52642: LD_INT 81
52644: PUSH
52645: LD_VAR 0 4
52649: PUSH
52650: LD_VAR 0 7
52654: ARRAY
52655: PPUSH
52656: CALL_OW 255
52660: PUSH
52661: EMPTY
52662: LIST
52663: LIST
52664: PPUSH
52665: CALL_OW 69
52669: IN
52670: PUSH
52671: LD_VAR 0 9
52675: PPUSH
52676: LD_VAR 0 4
52680: PUSH
52681: LD_VAR 0 7
52685: ARRAY
52686: PPUSH
52687: CALL_OW 296
52691: PUSH
52692: LD_INT 5
52694: LESS
52695: AND
52696: IFFALSE 52713
// ComAutodestruct ( group [ i ] ) ;
52698: LD_VAR 0 4
52702: PUSH
52703: LD_VAR 0 7
52707: ARRAY
52708: PPUSH
52709: CALL 47193 0 1
// end ; if f_attack_depot then
52713: LD_VAR 0 25
52717: IFFALSE 52829
// begin k := 6 ;
52719: LD_ADDR_VAR 0 9
52723: PUSH
52724: LD_INT 6
52726: ST_TO_ADDR
// if tmp < k then
52727: LD_VAR 0 14
52731: PUSH
52732: LD_VAR 0 9
52736: LESS
52737: IFFALSE 52749
// k := tmp ;
52739: LD_ADDR_VAR 0 9
52743: PUSH
52744: LD_VAR 0 14
52748: ST_TO_ADDR
// for j = 1 to k do
52749: LD_ADDR_VAR 0 8
52753: PUSH
52754: DOUBLE
52755: LD_INT 1
52757: DEC
52758: ST_TO_ADDR
52759: LD_VAR 0 9
52763: PUSH
52764: FOR_TO
52765: IFFALSE 52827
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
52767: LD_VAR 0 8
52771: PPUSH
52772: CALL_OW 266
52776: PUSH
52777: LD_INT 0
52779: PUSH
52780: LD_INT 1
52782: PUSH
52783: EMPTY
52784: LIST
52785: LIST
52786: IN
52787: IFFALSE 52825
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52789: LD_VAR 0 4
52793: PUSH
52794: LD_VAR 0 7
52798: ARRAY
52799: PPUSH
52800: LD_VAR 0 14
52804: PUSH
52805: LD_VAR 0 8
52809: ARRAY
52810: PPUSH
52811: CALL_OW 115
// attacking := true ;
52815: LD_ADDR_VAR 0 29
52819: PUSH
52820: LD_INT 1
52822: ST_TO_ADDR
// break ;
52823: GO 52827
// end ;
52825: GO 52764
52827: POP
52828: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
52829: LD_VAR 0 4
52833: PUSH
52834: LD_VAR 0 7
52838: ARRAY
52839: PPUSH
52840: CALL_OW 302
52844: PUSH
52845: LD_VAR 0 29
52849: NOT
52850: AND
52851: IFFALSE 53173
// begin if GetTag ( group [ i ] ) = 71 then
52853: LD_VAR 0 4
52857: PUSH
52858: LD_VAR 0 7
52862: ARRAY
52863: PPUSH
52864: CALL_OW 110
52868: PUSH
52869: LD_INT 71
52871: EQUAL
52872: IFFALSE 52913
// begin if HasTask ( group [ i ] ) then
52874: LD_VAR 0 4
52878: PUSH
52879: LD_VAR 0 7
52883: ARRAY
52884: PPUSH
52885: CALL_OW 314
52889: IFFALSE 52895
// continue else
52891: GO 49078
52893: GO 52913
// SetTag ( group [ i ] , 0 ) ;
52895: LD_VAR 0 4
52899: PUSH
52900: LD_VAR 0 7
52904: ARRAY
52905: PPUSH
52906: LD_INT 0
52908: PPUSH
52909: CALL_OW 109
// end ; k := 8 ;
52913: LD_ADDR_VAR 0 9
52917: PUSH
52918: LD_INT 8
52920: ST_TO_ADDR
// x := 0 ;
52921: LD_ADDR_VAR 0 10
52925: PUSH
52926: LD_INT 0
52928: ST_TO_ADDR
// if tmp < k then
52929: LD_VAR 0 14
52933: PUSH
52934: LD_VAR 0 9
52938: LESS
52939: IFFALSE 52951
// k := tmp ;
52941: LD_ADDR_VAR 0 9
52945: PUSH
52946: LD_VAR 0 14
52950: ST_TO_ADDR
// for j = 1 to k do
52951: LD_ADDR_VAR 0 8
52955: PUSH
52956: DOUBLE
52957: LD_INT 1
52959: DEC
52960: ST_TO_ADDR
52961: LD_VAR 0 9
52965: PUSH
52966: FOR_TO
52967: IFFALSE 53065
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
52969: LD_VAR 0 14
52973: PUSH
52974: LD_VAR 0 8
52978: ARRAY
52979: PPUSH
52980: CALL_OW 247
52984: PUSH
52985: LD_INT 1
52987: EQUAL
52988: PUSH
52989: LD_VAR 0 14
52993: PUSH
52994: LD_VAR 0 8
52998: ARRAY
52999: PPUSH
53000: CALL_OW 256
53004: PUSH
53005: LD_INT 250
53007: LESS
53008: PUSH
53009: LD_VAR 0 20
53013: AND
53014: PUSH
53015: LD_VAR 0 20
53019: NOT
53020: PUSH
53021: LD_VAR 0 14
53025: PUSH
53026: LD_VAR 0 8
53030: ARRAY
53031: PPUSH
53032: CALL_OW 256
53036: PUSH
53037: LD_INT 250
53039: GREATEREQUAL
53040: AND
53041: OR
53042: AND
53043: IFFALSE 53063
// begin x := tmp [ j ] ;
53045: LD_ADDR_VAR 0 10
53049: PUSH
53050: LD_VAR 0 14
53054: PUSH
53055: LD_VAR 0 8
53059: ARRAY
53060: ST_TO_ADDR
// break ;
53061: GO 53065
// end ;
53063: GO 52966
53065: POP
53066: POP
// if x then
53067: LD_VAR 0 10
53071: IFFALSE 53095
// ComAttackUnit ( group [ i ] , x ) else
53073: LD_VAR 0 4
53077: PUSH
53078: LD_VAR 0 7
53082: ARRAY
53083: PPUSH
53084: LD_VAR 0 10
53088: PPUSH
53089: CALL_OW 115
53093: GO 53119
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53095: LD_VAR 0 4
53099: PUSH
53100: LD_VAR 0 7
53104: ARRAY
53105: PPUSH
53106: LD_VAR 0 14
53110: PUSH
53111: LD_INT 1
53113: ARRAY
53114: PPUSH
53115: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53119: LD_VAR 0 4
53123: PUSH
53124: LD_VAR 0 7
53128: ARRAY
53129: PPUSH
53130: CALL_OW 314
53134: NOT
53135: IFFALSE 53173
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53137: LD_VAR 0 4
53141: PUSH
53142: LD_VAR 0 7
53146: ARRAY
53147: PPUSH
53148: LD_VAR 0 14
53152: PPUSH
53153: LD_VAR 0 4
53157: PUSH
53158: LD_VAR 0 7
53162: ARRAY
53163: PPUSH
53164: CALL_OW 74
53168: PPUSH
53169: CALL_OW 115
// end ; end ; end ;
53173: GO 49078
53175: POP
53176: POP
// wait ( 0 0$1 ) ;
53177: LD_INT 35
53179: PPUSH
53180: CALL_OW 67
// until group = [ ] ;
53184: LD_VAR 0 4
53188: PUSH
53189: EMPTY
53190: EQUAL
53191: IFFALSE 49063
// end ;
53193: LD_VAR 0 2
53197: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53198: LD_INT 0
53200: PPUSH
53201: PPUSH
53202: PPUSH
53203: PPUSH
// if not base_units then
53204: LD_VAR 0 1
53208: NOT
53209: IFFALSE 53213
// exit ;
53211: GO 53300
// result := false ;
53213: LD_ADDR_VAR 0 2
53217: PUSH
53218: LD_INT 0
53220: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53221: LD_ADDR_VAR 0 5
53225: PUSH
53226: LD_VAR 0 1
53230: PPUSH
53231: LD_INT 21
53233: PUSH
53234: LD_INT 3
53236: PUSH
53237: EMPTY
53238: LIST
53239: LIST
53240: PPUSH
53241: CALL_OW 72
53245: ST_TO_ADDR
// if not tmp then
53246: LD_VAR 0 5
53250: NOT
53251: IFFALSE 53255
// exit ;
53253: GO 53300
// for i in tmp do
53255: LD_ADDR_VAR 0 3
53259: PUSH
53260: LD_VAR 0 5
53264: PUSH
53265: FOR_IN
53266: IFFALSE 53298
// begin result := EnemyInRange ( i , 22 ) ;
53268: LD_ADDR_VAR 0 2
53272: PUSH
53273: LD_VAR 0 3
53277: PPUSH
53278: LD_INT 22
53280: PPUSH
53281: CALL 46876 0 2
53285: ST_TO_ADDR
// if result then
53286: LD_VAR 0 2
53290: IFFALSE 53296
// exit ;
53292: POP
53293: POP
53294: GO 53300
// end ;
53296: GO 53265
53298: POP
53299: POP
// end ;
53300: LD_VAR 0 2
53304: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53305: LD_INT 0
53307: PPUSH
53308: PPUSH
// if not units then
53309: LD_VAR 0 1
53313: NOT
53314: IFFALSE 53318
// exit ;
53316: GO 53388
// result := [ ] ;
53318: LD_ADDR_VAR 0 3
53322: PUSH
53323: EMPTY
53324: ST_TO_ADDR
// for i in units do
53325: LD_ADDR_VAR 0 4
53329: PUSH
53330: LD_VAR 0 1
53334: PUSH
53335: FOR_IN
53336: IFFALSE 53386
// if GetTag ( i ) = tag then
53338: LD_VAR 0 4
53342: PPUSH
53343: CALL_OW 110
53347: PUSH
53348: LD_VAR 0 2
53352: EQUAL
53353: IFFALSE 53384
// result := Insert ( result , result + 1 , i ) ;
53355: LD_ADDR_VAR 0 3
53359: PUSH
53360: LD_VAR 0 3
53364: PPUSH
53365: LD_VAR 0 3
53369: PUSH
53370: LD_INT 1
53372: PLUS
53373: PPUSH
53374: LD_VAR 0 4
53378: PPUSH
53379: CALL_OW 2
53383: ST_TO_ADDR
53384: GO 53335
53386: POP
53387: POP
// end ;
53388: LD_VAR 0 3
53392: RET
// export function IsDriver ( un ) ; begin
53393: LD_INT 0
53395: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53396: LD_ADDR_VAR 0 2
53400: PUSH
53401: LD_VAR 0 1
53405: PUSH
53406: LD_INT 55
53408: PUSH
53409: EMPTY
53410: LIST
53411: PPUSH
53412: CALL_OW 69
53416: IN
53417: ST_TO_ADDR
// end ;
53418: LD_VAR 0 2
53422: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53423: LD_INT 0
53425: PPUSH
53426: PPUSH
// list := [ ] ;
53427: LD_ADDR_VAR 0 5
53431: PUSH
53432: EMPTY
53433: ST_TO_ADDR
// case d of 0 :
53434: LD_VAR 0 3
53438: PUSH
53439: LD_INT 0
53441: DOUBLE
53442: EQUAL
53443: IFTRUE 53447
53445: GO 53580
53447: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53448: LD_ADDR_VAR 0 5
53452: PUSH
53453: LD_VAR 0 1
53457: PUSH
53458: LD_INT 4
53460: MINUS
53461: PUSH
53462: LD_VAR 0 2
53466: PUSH
53467: LD_INT 4
53469: MINUS
53470: PUSH
53471: LD_INT 2
53473: PUSH
53474: EMPTY
53475: LIST
53476: LIST
53477: LIST
53478: PUSH
53479: LD_VAR 0 1
53483: PUSH
53484: LD_INT 3
53486: MINUS
53487: PUSH
53488: LD_VAR 0 2
53492: PUSH
53493: LD_INT 1
53495: PUSH
53496: EMPTY
53497: LIST
53498: LIST
53499: LIST
53500: PUSH
53501: LD_VAR 0 1
53505: PUSH
53506: LD_INT 4
53508: PLUS
53509: PUSH
53510: LD_VAR 0 2
53514: PUSH
53515: LD_INT 4
53517: PUSH
53518: EMPTY
53519: LIST
53520: LIST
53521: LIST
53522: PUSH
53523: LD_VAR 0 1
53527: PUSH
53528: LD_INT 3
53530: PLUS
53531: PUSH
53532: LD_VAR 0 2
53536: PUSH
53537: LD_INT 3
53539: PLUS
53540: PUSH
53541: LD_INT 5
53543: PUSH
53544: EMPTY
53545: LIST
53546: LIST
53547: LIST
53548: PUSH
53549: LD_VAR 0 1
53553: PUSH
53554: LD_VAR 0 2
53558: PUSH
53559: LD_INT 4
53561: PLUS
53562: PUSH
53563: LD_INT 0
53565: PUSH
53566: EMPTY
53567: LIST
53568: LIST
53569: LIST
53570: PUSH
53571: EMPTY
53572: LIST
53573: LIST
53574: LIST
53575: LIST
53576: LIST
53577: ST_TO_ADDR
// end ; 1 :
53578: GO 54278
53580: LD_INT 1
53582: DOUBLE
53583: EQUAL
53584: IFTRUE 53588
53586: GO 53721
53588: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53589: LD_ADDR_VAR 0 5
53593: PUSH
53594: LD_VAR 0 1
53598: PUSH
53599: LD_VAR 0 2
53603: PUSH
53604: LD_INT 4
53606: MINUS
53607: PUSH
53608: LD_INT 3
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: LIST
53615: PUSH
53616: LD_VAR 0 1
53620: PUSH
53621: LD_INT 3
53623: MINUS
53624: PUSH
53625: LD_VAR 0 2
53629: PUSH
53630: LD_INT 3
53632: MINUS
53633: PUSH
53634: LD_INT 2
53636: PUSH
53637: EMPTY
53638: LIST
53639: LIST
53640: LIST
53641: PUSH
53642: LD_VAR 0 1
53646: PUSH
53647: LD_INT 4
53649: MINUS
53650: PUSH
53651: LD_VAR 0 2
53655: PUSH
53656: LD_INT 1
53658: PUSH
53659: EMPTY
53660: LIST
53661: LIST
53662: LIST
53663: PUSH
53664: LD_VAR 0 1
53668: PUSH
53669: LD_VAR 0 2
53673: PUSH
53674: LD_INT 3
53676: PLUS
53677: PUSH
53678: LD_INT 0
53680: PUSH
53681: EMPTY
53682: LIST
53683: LIST
53684: LIST
53685: PUSH
53686: LD_VAR 0 1
53690: PUSH
53691: LD_INT 4
53693: PLUS
53694: PUSH
53695: LD_VAR 0 2
53699: PUSH
53700: LD_INT 4
53702: PLUS
53703: PUSH
53704: LD_INT 5
53706: PUSH
53707: EMPTY
53708: LIST
53709: LIST
53710: LIST
53711: PUSH
53712: EMPTY
53713: LIST
53714: LIST
53715: LIST
53716: LIST
53717: LIST
53718: ST_TO_ADDR
// end ; 2 :
53719: GO 54278
53721: LD_INT 2
53723: DOUBLE
53724: EQUAL
53725: IFTRUE 53729
53727: GO 53858
53729: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53730: LD_ADDR_VAR 0 5
53734: PUSH
53735: LD_VAR 0 1
53739: PUSH
53740: LD_VAR 0 2
53744: PUSH
53745: LD_INT 3
53747: MINUS
53748: PUSH
53749: LD_INT 3
53751: PUSH
53752: EMPTY
53753: LIST
53754: LIST
53755: LIST
53756: PUSH
53757: LD_VAR 0 1
53761: PUSH
53762: LD_INT 4
53764: PLUS
53765: PUSH
53766: LD_VAR 0 2
53770: PUSH
53771: LD_INT 4
53773: PUSH
53774: EMPTY
53775: LIST
53776: LIST
53777: LIST
53778: PUSH
53779: LD_VAR 0 1
53783: PUSH
53784: LD_VAR 0 2
53788: PUSH
53789: LD_INT 4
53791: PLUS
53792: PUSH
53793: LD_INT 0
53795: PUSH
53796: EMPTY
53797: LIST
53798: LIST
53799: LIST
53800: PUSH
53801: LD_VAR 0 1
53805: PUSH
53806: LD_INT 3
53808: MINUS
53809: PUSH
53810: LD_VAR 0 2
53814: PUSH
53815: LD_INT 1
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: LIST
53822: PUSH
53823: LD_VAR 0 1
53827: PUSH
53828: LD_INT 4
53830: MINUS
53831: PUSH
53832: LD_VAR 0 2
53836: PUSH
53837: LD_INT 4
53839: MINUS
53840: PUSH
53841: LD_INT 2
53843: PUSH
53844: EMPTY
53845: LIST
53846: LIST
53847: LIST
53848: PUSH
53849: EMPTY
53850: LIST
53851: LIST
53852: LIST
53853: LIST
53854: LIST
53855: ST_TO_ADDR
// end ; 3 :
53856: GO 54278
53858: LD_INT 3
53860: DOUBLE
53861: EQUAL
53862: IFTRUE 53866
53864: GO 53999
53866: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53867: LD_ADDR_VAR 0 5
53871: PUSH
53872: LD_VAR 0 1
53876: PUSH
53877: LD_INT 3
53879: PLUS
53880: PUSH
53881: LD_VAR 0 2
53885: PUSH
53886: LD_INT 4
53888: PUSH
53889: EMPTY
53890: LIST
53891: LIST
53892: LIST
53893: PUSH
53894: LD_VAR 0 1
53898: PUSH
53899: LD_INT 4
53901: PLUS
53902: PUSH
53903: LD_VAR 0 2
53907: PUSH
53908: LD_INT 4
53910: PLUS
53911: PUSH
53912: LD_INT 5
53914: PUSH
53915: EMPTY
53916: LIST
53917: LIST
53918: LIST
53919: PUSH
53920: LD_VAR 0 1
53924: PUSH
53925: LD_INT 4
53927: MINUS
53928: PUSH
53929: LD_VAR 0 2
53933: PUSH
53934: LD_INT 1
53936: PUSH
53937: EMPTY
53938: LIST
53939: LIST
53940: LIST
53941: PUSH
53942: LD_VAR 0 1
53946: PUSH
53947: LD_VAR 0 2
53951: PUSH
53952: LD_INT 4
53954: MINUS
53955: PUSH
53956: LD_INT 3
53958: PUSH
53959: EMPTY
53960: LIST
53961: LIST
53962: LIST
53963: PUSH
53964: LD_VAR 0 1
53968: PUSH
53969: LD_INT 3
53971: MINUS
53972: PUSH
53973: LD_VAR 0 2
53977: PUSH
53978: LD_INT 3
53980: MINUS
53981: PUSH
53982: LD_INT 2
53984: PUSH
53985: EMPTY
53986: LIST
53987: LIST
53988: LIST
53989: PUSH
53990: EMPTY
53991: LIST
53992: LIST
53993: LIST
53994: LIST
53995: LIST
53996: ST_TO_ADDR
// end ; 4 :
53997: GO 54278
53999: LD_INT 4
54001: DOUBLE
54002: EQUAL
54003: IFTRUE 54007
54005: GO 54140
54007: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54008: LD_ADDR_VAR 0 5
54012: PUSH
54013: LD_VAR 0 1
54017: PUSH
54018: LD_VAR 0 2
54022: PUSH
54023: LD_INT 4
54025: PLUS
54026: PUSH
54027: LD_INT 0
54029: PUSH
54030: EMPTY
54031: LIST
54032: LIST
54033: LIST
54034: PUSH
54035: LD_VAR 0 1
54039: PUSH
54040: LD_INT 3
54042: PLUS
54043: PUSH
54044: LD_VAR 0 2
54048: PUSH
54049: LD_INT 3
54051: PLUS
54052: PUSH
54053: LD_INT 5
54055: PUSH
54056: EMPTY
54057: LIST
54058: LIST
54059: LIST
54060: PUSH
54061: LD_VAR 0 1
54065: PUSH
54066: LD_INT 4
54068: PLUS
54069: PUSH
54070: LD_VAR 0 2
54074: PUSH
54075: LD_INT 4
54077: PUSH
54078: EMPTY
54079: LIST
54080: LIST
54081: LIST
54082: PUSH
54083: LD_VAR 0 1
54087: PUSH
54088: LD_VAR 0 2
54092: PUSH
54093: LD_INT 3
54095: MINUS
54096: PUSH
54097: LD_INT 3
54099: PUSH
54100: EMPTY
54101: LIST
54102: LIST
54103: LIST
54104: PUSH
54105: LD_VAR 0 1
54109: PUSH
54110: LD_INT 4
54112: MINUS
54113: PUSH
54114: LD_VAR 0 2
54118: PUSH
54119: LD_INT 4
54121: MINUS
54122: PUSH
54123: LD_INT 2
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: LIST
54130: PUSH
54131: EMPTY
54132: LIST
54133: LIST
54134: LIST
54135: LIST
54136: LIST
54137: ST_TO_ADDR
// end ; 5 :
54138: GO 54278
54140: LD_INT 5
54142: DOUBLE
54143: EQUAL
54144: IFTRUE 54148
54146: GO 54277
54148: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54149: LD_ADDR_VAR 0 5
54153: PUSH
54154: LD_VAR 0 1
54158: PUSH
54159: LD_INT 4
54161: MINUS
54162: PUSH
54163: LD_VAR 0 2
54167: PUSH
54168: LD_INT 1
54170: PUSH
54171: EMPTY
54172: LIST
54173: LIST
54174: LIST
54175: PUSH
54176: LD_VAR 0 1
54180: PUSH
54181: LD_VAR 0 2
54185: PUSH
54186: LD_INT 4
54188: MINUS
54189: PUSH
54190: LD_INT 3
54192: PUSH
54193: EMPTY
54194: LIST
54195: LIST
54196: LIST
54197: PUSH
54198: LD_VAR 0 1
54202: PUSH
54203: LD_INT 4
54205: PLUS
54206: PUSH
54207: LD_VAR 0 2
54211: PUSH
54212: LD_INT 4
54214: PLUS
54215: PUSH
54216: LD_INT 5
54218: PUSH
54219: EMPTY
54220: LIST
54221: LIST
54222: LIST
54223: PUSH
54224: LD_VAR 0 1
54228: PUSH
54229: LD_INT 3
54231: PLUS
54232: PUSH
54233: LD_VAR 0 2
54237: PUSH
54238: LD_INT 4
54240: PUSH
54241: EMPTY
54242: LIST
54243: LIST
54244: LIST
54245: PUSH
54246: LD_VAR 0 1
54250: PUSH
54251: LD_VAR 0 2
54255: PUSH
54256: LD_INT 3
54258: PLUS
54259: PUSH
54260: LD_INT 0
54262: PUSH
54263: EMPTY
54264: LIST
54265: LIST
54266: LIST
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: LIST
54272: LIST
54273: LIST
54274: ST_TO_ADDR
// end ; end ;
54275: GO 54278
54277: POP
// result := list ;
54278: LD_ADDR_VAR 0 4
54282: PUSH
54283: LD_VAR 0 5
54287: ST_TO_ADDR
// end ;
54288: LD_VAR 0 4
54292: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54293: LD_INT 0
54295: PPUSH
54296: PPUSH
54297: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54298: LD_VAR 0 1
54302: NOT
54303: PUSH
54304: LD_VAR 0 2
54308: PUSH
54309: LD_INT 1
54311: PUSH
54312: LD_INT 2
54314: PUSH
54315: LD_INT 3
54317: PUSH
54318: LD_INT 4
54320: PUSH
54321: EMPTY
54322: LIST
54323: LIST
54324: LIST
54325: LIST
54326: IN
54327: NOT
54328: OR
54329: IFFALSE 54333
// exit ;
54331: GO 54425
// tmp := [ ] ;
54333: LD_ADDR_VAR 0 5
54337: PUSH
54338: EMPTY
54339: ST_TO_ADDR
// for i in units do
54340: LD_ADDR_VAR 0 4
54344: PUSH
54345: LD_VAR 0 1
54349: PUSH
54350: FOR_IN
54351: IFFALSE 54394
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54353: LD_ADDR_VAR 0 5
54357: PUSH
54358: LD_VAR 0 5
54362: PPUSH
54363: LD_VAR 0 5
54367: PUSH
54368: LD_INT 1
54370: PLUS
54371: PPUSH
54372: LD_VAR 0 4
54376: PPUSH
54377: LD_VAR 0 2
54381: PPUSH
54382: CALL_OW 259
54386: PPUSH
54387: CALL_OW 2
54391: ST_TO_ADDR
54392: GO 54350
54394: POP
54395: POP
// if not tmp then
54396: LD_VAR 0 5
54400: NOT
54401: IFFALSE 54405
// exit ;
54403: GO 54425
// result := SortListByListDesc ( units , tmp ) ;
54405: LD_ADDR_VAR 0 3
54409: PUSH
54410: LD_VAR 0 1
54414: PPUSH
54415: LD_VAR 0 5
54419: PPUSH
54420: CALL_OW 77
54424: ST_TO_ADDR
// end ;
54425: LD_VAR 0 3
54429: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54430: LD_INT 0
54432: PPUSH
54433: PPUSH
54434: PPUSH
// x := GetX ( building ) ;
54435: LD_ADDR_VAR 0 4
54439: PUSH
54440: LD_VAR 0 2
54444: PPUSH
54445: CALL_OW 250
54449: ST_TO_ADDR
// y := GetY ( building ) ;
54450: LD_ADDR_VAR 0 5
54454: PUSH
54455: LD_VAR 0 2
54459: PPUSH
54460: CALL_OW 251
54464: ST_TO_ADDR
// if GetTaskList ( unit ) then
54465: LD_VAR 0 1
54469: PPUSH
54470: CALL_OW 437
54474: IFFALSE 54569
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54476: LD_STRING e
54478: PUSH
54479: LD_VAR 0 1
54483: PPUSH
54484: CALL_OW 437
54488: PUSH
54489: LD_INT 1
54491: ARRAY
54492: PUSH
54493: LD_INT 1
54495: ARRAY
54496: EQUAL
54497: PUSH
54498: LD_VAR 0 4
54502: PUSH
54503: LD_VAR 0 1
54507: PPUSH
54508: CALL_OW 437
54512: PUSH
54513: LD_INT 1
54515: ARRAY
54516: PUSH
54517: LD_INT 2
54519: ARRAY
54520: EQUAL
54521: AND
54522: PUSH
54523: LD_VAR 0 5
54527: PUSH
54528: LD_VAR 0 1
54532: PPUSH
54533: CALL_OW 437
54537: PUSH
54538: LD_INT 1
54540: ARRAY
54541: PUSH
54542: LD_INT 3
54544: ARRAY
54545: EQUAL
54546: AND
54547: IFFALSE 54559
// result := true else
54549: LD_ADDR_VAR 0 3
54553: PUSH
54554: LD_INT 1
54556: ST_TO_ADDR
54557: GO 54567
// result := false ;
54559: LD_ADDR_VAR 0 3
54563: PUSH
54564: LD_INT 0
54566: ST_TO_ADDR
// end else
54567: GO 54577
// result := false ;
54569: LD_ADDR_VAR 0 3
54573: PUSH
54574: LD_INT 0
54576: ST_TO_ADDR
// end ;
54577: LD_VAR 0 3
54581: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54582: LD_INT 0
54584: PPUSH
54585: PPUSH
54586: PPUSH
54587: PPUSH
// if not unit or not area then
54588: LD_VAR 0 1
54592: NOT
54593: PUSH
54594: LD_VAR 0 2
54598: NOT
54599: OR
54600: IFFALSE 54604
// exit ;
54602: GO 54769
// tmp := AreaToList ( area , i ) ;
54604: LD_ADDR_VAR 0 6
54608: PUSH
54609: LD_VAR 0 2
54613: PPUSH
54614: LD_VAR 0 5
54618: PPUSH
54619: CALL_OW 517
54623: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54624: LD_ADDR_VAR 0 5
54628: PUSH
54629: DOUBLE
54630: LD_INT 1
54632: DEC
54633: ST_TO_ADDR
54634: LD_VAR 0 6
54638: PUSH
54639: LD_INT 1
54641: ARRAY
54642: PUSH
54643: FOR_TO
54644: IFFALSE 54759
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54646: LD_ADDR_VAR 0 7
54650: PUSH
54651: LD_VAR 0 6
54655: PUSH
54656: LD_INT 1
54658: ARRAY
54659: PUSH
54660: LD_VAR 0 5
54664: ARRAY
54665: PUSH
54666: LD_VAR 0 6
54670: PUSH
54671: LD_INT 2
54673: ARRAY
54674: PUSH
54675: LD_VAR 0 5
54679: ARRAY
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
54685: LD_VAR 0 7
54689: PUSH
54690: LD_INT 1
54692: ARRAY
54693: PPUSH
54694: LD_VAR 0 7
54698: PUSH
54699: LD_INT 2
54701: ARRAY
54702: PPUSH
54703: CALL_OW 428
54707: PUSH
54708: LD_INT 0
54710: EQUAL
54711: IFFALSE 54757
// begin result := true ;
54713: LD_ADDR_VAR 0 4
54717: PUSH
54718: LD_INT 1
54720: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54721: LD_VAR 0 1
54725: PPUSH
54726: LD_VAR 0 7
54730: PUSH
54731: LD_INT 1
54733: ARRAY
54734: PPUSH
54735: LD_VAR 0 7
54739: PUSH
54740: LD_INT 2
54742: ARRAY
54743: PPUSH
54744: LD_VAR 0 3
54748: PPUSH
54749: CALL_OW 48
// exit ;
54753: POP
54754: POP
54755: GO 54769
// end ; end ;
54757: GO 54643
54759: POP
54760: POP
// result := false ;
54761: LD_ADDR_VAR 0 4
54765: PUSH
54766: LD_INT 0
54768: ST_TO_ADDR
// end ;
54769: LD_VAR 0 4
54773: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54774: LD_INT 0
54776: PPUSH
54777: PPUSH
54778: PPUSH
// if not side or side > 8 then
54779: LD_VAR 0 1
54783: NOT
54784: PUSH
54785: LD_VAR 0 1
54789: PUSH
54790: LD_INT 8
54792: GREATER
54793: OR
54794: IFFALSE 54798
// exit ;
54796: GO 54985
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54798: LD_ADDR_VAR 0 4
54802: PUSH
54803: LD_INT 22
54805: PUSH
54806: LD_VAR 0 1
54810: PUSH
54811: EMPTY
54812: LIST
54813: LIST
54814: PUSH
54815: LD_INT 21
54817: PUSH
54818: LD_INT 3
54820: PUSH
54821: EMPTY
54822: LIST
54823: LIST
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: PPUSH
54829: CALL_OW 69
54833: ST_TO_ADDR
// if not tmp then
54834: LD_VAR 0 4
54838: NOT
54839: IFFALSE 54843
// exit ;
54841: GO 54985
// enable_addtolog := true ;
54843: LD_ADDR_OWVAR 81
54847: PUSH
54848: LD_INT 1
54850: ST_TO_ADDR
// AddToLog ( [ ) ;
54851: LD_STRING [
54853: PPUSH
54854: CALL_OW 561
// for i in tmp do
54858: LD_ADDR_VAR 0 3
54862: PUSH
54863: LD_VAR 0 4
54867: PUSH
54868: FOR_IN
54869: IFFALSE 54976
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54871: LD_STRING [
54873: PUSH
54874: LD_VAR 0 3
54878: PPUSH
54879: CALL_OW 266
54883: STR
54884: PUSH
54885: LD_STRING , 
54887: STR
54888: PUSH
54889: LD_VAR 0 3
54893: PPUSH
54894: CALL_OW 250
54898: STR
54899: PUSH
54900: LD_STRING , 
54902: STR
54903: PUSH
54904: LD_VAR 0 3
54908: PPUSH
54909: CALL_OW 251
54913: STR
54914: PUSH
54915: LD_STRING , 
54917: STR
54918: PUSH
54919: LD_VAR 0 3
54923: PPUSH
54924: CALL_OW 254
54928: STR
54929: PUSH
54930: LD_STRING , 
54932: STR
54933: PUSH
54934: LD_VAR 0 3
54938: PPUSH
54939: LD_INT 1
54941: PPUSH
54942: CALL_OW 268
54946: STR
54947: PUSH
54948: LD_STRING , 
54950: STR
54951: PUSH
54952: LD_VAR 0 3
54956: PPUSH
54957: LD_INT 2
54959: PPUSH
54960: CALL_OW 268
54964: STR
54965: PUSH
54966: LD_STRING ],
54968: STR
54969: PPUSH
54970: CALL_OW 561
// end ;
54974: GO 54868
54976: POP
54977: POP
// AddToLog ( ]; ) ;
54978: LD_STRING ];
54980: PPUSH
54981: CALL_OW 561
// end ;
54985: LD_VAR 0 2
54989: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54990: LD_INT 0
54992: PPUSH
54993: PPUSH
54994: PPUSH
54995: PPUSH
54996: PPUSH
// if not area or not rate or not max then
54997: LD_VAR 0 1
55001: NOT
55002: PUSH
55003: LD_VAR 0 2
55007: NOT
55008: OR
55009: PUSH
55010: LD_VAR 0 4
55014: NOT
55015: OR
55016: IFFALSE 55020
// exit ;
55018: GO 55212
// while 1 do
55020: LD_INT 1
55022: IFFALSE 55212
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55024: LD_ADDR_VAR 0 9
55028: PUSH
55029: LD_VAR 0 1
55033: PPUSH
55034: LD_INT 1
55036: PPUSH
55037: CALL_OW 287
55041: PUSH
55042: LD_INT 10
55044: MUL
55045: ST_TO_ADDR
// r := rate / 10 ;
55046: LD_ADDR_VAR 0 7
55050: PUSH
55051: LD_VAR 0 2
55055: PUSH
55056: LD_INT 10
55058: DIVREAL
55059: ST_TO_ADDR
// time := 1 1$00 ;
55060: LD_ADDR_VAR 0 8
55064: PUSH
55065: LD_INT 2100
55067: ST_TO_ADDR
// if amount < min then
55068: LD_VAR 0 9
55072: PUSH
55073: LD_VAR 0 3
55077: LESS
55078: IFFALSE 55096
// r := r * 2 else
55080: LD_ADDR_VAR 0 7
55084: PUSH
55085: LD_VAR 0 7
55089: PUSH
55090: LD_INT 2
55092: MUL
55093: ST_TO_ADDR
55094: GO 55122
// if amount > max then
55096: LD_VAR 0 9
55100: PUSH
55101: LD_VAR 0 4
55105: GREATER
55106: IFFALSE 55122
// r := r / 2 ;
55108: LD_ADDR_VAR 0 7
55112: PUSH
55113: LD_VAR 0 7
55117: PUSH
55118: LD_INT 2
55120: DIVREAL
55121: ST_TO_ADDR
// time := time / r ;
55122: LD_ADDR_VAR 0 8
55126: PUSH
55127: LD_VAR 0 8
55131: PUSH
55132: LD_VAR 0 7
55136: DIVREAL
55137: ST_TO_ADDR
// if time < 0 then
55138: LD_VAR 0 8
55142: PUSH
55143: LD_INT 0
55145: LESS
55146: IFFALSE 55163
// time := time * - 1 ;
55148: LD_ADDR_VAR 0 8
55152: PUSH
55153: LD_VAR 0 8
55157: PUSH
55158: LD_INT 1
55160: NEG
55161: MUL
55162: ST_TO_ADDR
// wait ( time ) ;
55163: LD_VAR 0 8
55167: PPUSH
55168: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55172: LD_INT 35
55174: PPUSH
55175: LD_INT 875
55177: PPUSH
55178: CALL_OW 12
55182: PPUSH
55183: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55187: LD_INT 1
55189: PPUSH
55190: LD_INT 5
55192: PPUSH
55193: CALL_OW 12
55197: PPUSH
55198: LD_VAR 0 1
55202: PPUSH
55203: LD_INT 1
55205: PPUSH
55206: CALL_OW 55
// end ;
55210: GO 55020
// end ;
55212: LD_VAR 0 5
55216: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55217: LD_INT 0
55219: PPUSH
55220: PPUSH
55221: PPUSH
55222: PPUSH
55223: PPUSH
55224: PPUSH
55225: PPUSH
55226: PPUSH
// if not turrets or not factories then
55227: LD_VAR 0 1
55231: NOT
55232: PUSH
55233: LD_VAR 0 2
55237: NOT
55238: OR
55239: IFFALSE 55243
// exit ;
55241: GO 55550
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55243: LD_ADDR_VAR 0 10
55247: PUSH
55248: LD_INT 5
55250: PUSH
55251: LD_INT 6
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: PUSH
55258: LD_INT 2
55260: PUSH
55261: LD_INT 4
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: PUSH
55268: LD_INT 3
55270: PUSH
55271: LD_INT 5
55273: PUSH
55274: EMPTY
55275: LIST
55276: LIST
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: LIST
55282: PUSH
55283: LD_INT 24
55285: PUSH
55286: LD_INT 25
55288: PUSH
55289: EMPTY
55290: LIST
55291: LIST
55292: PUSH
55293: LD_INT 23
55295: PUSH
55296: LD_INT 27
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: PUSH
55303: EMPTY
55304: LIST
55305: LIST
55306: PUSH
55307: LD_INT 42
55309: PUSH
55310: LD_INT 43
55312: PUSH
55313: EMPTY
55314: LIST
55315: LIST
55316: PUSH
55317: LD_INT 44
55319: PUSH
55320: LD_INT 46
55322: PUSH
55323: EMPTY
55324: LIST
55325: LIST
55326: PUSH
55327: LD_INT 45
55329: PUSH
55330: LD_INT 47
55332: PUSH
55333: EMPTY
55334: LIST
55335: LIST
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: LIST
55341: PUSH
55342: EMPTY
55343: LIST
55344: LIST
55345: LIST
55346: ST_TO_ADDR
// result := [ ] ;
55347: LD_ADDR_VAR 0 3
55351: PUSH
55352: EMPTY
55353: ST_TO_ADDR
// for i in turrets do
55354: LD_ADDR_VAR 0 4
55358: PUSH
55359: LD_VAR 0 1
55363: PUSH
55364: FOR_IN
55365: IFFALSE 55548
// begin nat := GetNation ( i ) ;
55367: LD_ADDR_VAR 0 7
55371: PUSH
55372: LD_VAR 0 4
55376: PPUSH
55377: CALL_OW 248
55381: ST_TO_ADDR
// weapon := 0 ;
55382: LD_ADDR_VAR 0 8
55386: PUSH
55387: LD_INT 0
55389: ST_TO_ADDR
// if not nat then
55390: LD_VAR 0 7
55394: NOT
55395: IFFALSE 55399
// continue ;
55397: GO 55364
// for j in list [ nat ] do
55399: LD_ADDR_VAR 0 5
55403: PUSH
55404: LD_VAR 0 10
55408: PUSH
55409: LD_VAR 0 7
55413: ARRAY
55414: PUSH
55415: FOR_IN
55416: IFFALSE 55457
// if GetBWeapon ( i ) = j [ 1 ] then
55418: LD_VAR 0 4
55422: PPUSH
55423: CALL_OW 269
55427: PUSH
55428: LD_VAR 0 5
55432: PUSH
55433: LD_INT 1
55435: ARRAY
55436: EQUAL
55437: IFFALSE 55455
// begin weapon := j [ 2 ] ;
55439: LD_ADDR_VAR 0 8
55443: PUSH
55444: LD_VAR 0 5
55448: PUSH
55449: LD_INT 2
55451: ARRAY
55452: ST_TO_ADDR
// break ;
55453: GO 55457
// end ;
55455: GO 55415
55457: POP
55458: POP
// if not weapon then
55459: LD_VAR 0 8
55463: NOT
55464: IFFALSE 55468
// continue ;
55466: GO 55364
// for k in factories do
55468: LD_ADDR_VAR 0 6
55472: PUSH
55473: LD_VAR 0 2
55477: PUSH
55478: FOR_IN
55479: IFFALSE 55544
// begin weapons := AvailableWeaponList ( k ) ;
55481: LD_ADDR_VAR 0 9
55485: PUSH
55486: LD_VAR 0 6
55490: PPUSH
55491: CALL_OW 478
55495: ST_TO_ADDR
// if not weapons then
55496: LD_VAR 0 9
55500: NOT
55501: IFFALSE 55505
// continue ;
55503: GO 55478
// if weapon in weapons then
55505: LD_VAR 0 8
55509: PUSH
55510: LD_VAR 0 9
55514: IN
55515: IFFALSE 55542
// begin result := [ i , weapon ] ;
55517: LD_ADDR_VAR 0 3
55521: PUSH
55522: LD_VAR 0 4
55526: PUSH
55527: LD_VAR 0 8
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: ST_TO_ADDR
// exit ;
55536: POP
55537: POP
55538: POP
55539: POP
55540: GO 55550
// end ; end ;
55542: GO 55478
55544: POP
55545: POP
// end ;
55546: GO 55364
55548: POP
55549: POP
// end ; end_of_file
55550: LD_VAR 0 3
55554: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
55555: LD_INT 0
55557: PPUSH
55558: PPUSH
// skirmish := false ;
55559: LD_ADDR_EXP 56
55563: PUSH
55564: LD_INT 0
55566: ST_TO_ADDR
// debug_mc := false ;
55567: LD_ADDR_EXP 57
55571: PUSH
55572: LD_INT 0
55574: ST_TO_ADDR
// mc_bases := [ ] ;
55575: LD_ADDR_EXP 58
55579: PUSH
55580: EMPTY
55581: ST_TO_ADDR
// mc_sides := [ ] ;
55582: LD_ADDR_EXP 84
55586: PUSH
55587: EMPTY
55588: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
55589: LD_ADDR_EXP 59
55593: PUSH
55594: EMPTY
55595: ST_TO_ADDR
// mc_building_repairs := [ ] ;
55596: LD_ADDR_EXP 60
55600: PUSH
55601: EMPTY
55602: ST_TO_ADDR
// mc_need_heal := [ ] ;
55603: LD_ADDR_EXP 61
55607: PUSH
55608: EMPTY
55609: ST_TO_ADDR
// mc_healers := [ ] ;
55610: LD_ADDR_EXP 62
55614: PUSH
55615: EMPTY
55616: ST_TO_ADDR
// mc_build_list := [ ] ;
55617: LD_ADDR_EXP 63
55621: PUSH
55622: EMPTY
55623: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
55624: LD_ADDR_EXP 90
55628: PUSH
55629: EMPTY
55630: ST_TO_ADDR
// mc_builders := [ ] ;
55631: LD_ADDR_EXP 64
55635: PUSH
55636: EMPTY
55637: ST_TO_ADDR
// mc_construct_list := [ ] ;
55638: LD_ADDR_EXP 65
55642: PUSH
55643: EMPTY
55644: ST_TO_ADDR
// mc_turret_list := [ ] ;
55645: LD_ADDR_EXP 66
55649: PUSH
55650: EMPTY
55651: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55652: LD_ADDR_EXP 67
55656: PUSH
55657: EMPTY
55658: ST_TO_ADDR
// mc_miners := [ ] ;
55659: LD_ADDR_EXP 72
55663: PUSH
55664: EMPTY
55665: ST_TO_ADDR
// mc_mines := [ ] ;
55666: LD_ADDR_EXP 71
55670: PUSH
55671: EMPTY
55672: ST_TO_ADDR
// mc_minefields := [ ] ;
55673: LD_ADDR_EXP 73
55677: PUSH
55678: EMPTY
55679: ST_TO_ADDR
// mc_crates := [ ] ;
55680: LD_ADDR_EXP 74
55684: PUSH
55685: EMPTY
55686: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55687: LD_ADDR_EXP 75
55691: PUSH
55692: EMPTY
55693: ST_TO_ADDR
// mc_crates_area := [ ] ;
55694: LD_ADDR_EXP 76
55698: PUSH
55699: EMPTY
55700: ST_TO_ADDR
// mc_vehicles := [ ] ;
55701: LD_ADDR_EXP 77
55705: PUSH
55706: EMPTY
55707: ST_TO_ADDR
// mc_attack := [ ] ;
55708: LD_ADDR_EXP 78
55712: PUSH
55713: EMPTY
55714: ST_TO_ADDR
// mc_produce := [ ] ;
55715: LD_ADDR_EXP 79
55719: PUSH
55720: EMPTY
55721: ST_TO_ADDR
// mc_defender := [ ] ;
55722: LD_ADDR_EXP 80
55726: PUSH
55727: EMPTY
55728: ST_TO_ADDR
// mc_parking := [ ] ;
55729: LD_ADDR_EXP 82
55733: PUSH
55734: EMPTY
55735: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55736: LD_ADDR_EXP 68
55740: PUSH
55741: EMPTY
55742: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55743: LD_ADDR_EXP 70
55747: PUSH
55748: EMPTY
55749: ST_TO_ADDR
// mc_scan := [ ] ;
55750: LD_ADDR_EXP 81
55754: PUSH
55755: EMPTY
55756: ST_TO_ADDR
// mc_scan_area := [ ] ;
55757: LD_ADDR_EXP 83
55761: PUSH
55762: EMPTY
55763: ST_TO_ADDR
// mc_tech := [ ] ;
55764: LD_ADDR_EXP 85
55768: PUSH
55769: EMPTY
55770: ST_TO_ADDR
// mc_class := [ ] ;
55771: LD_ADDR_EXP 99
55775: PUSH
55776: EMPTY
55777: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55778: LD_ADDR_EXP 100
55782: PUSH
55783: EMPTY
55784: ST_TO_ADDR
// end ;
55785: LD_VAR 0 1
55789: RET
// export function MC_Kill ( base ) ; begin
55790: LD_INT 0
55792: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55793: LD_ADDR_EXP 58
55797: PUSH
55798: LD_EXP 58
55802: PPUSH
55803: LD_VAR 0 1
55807: PPUSH
55808: EMPTY
55809: PPUSH
55810: CALL_OW 1
55814: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55815: LD_ADDR_EXP 59
55819: PUSH
55820: LD_EXP 59
55824: PPUSH
55825: LD_VAR 0 1
55829: PPUSH
55830: EMPTY
55831: PPUSH
55832: CALL_OW 1
55836: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55837: LD_ADDR_EXP 60
55841: PUSH
55842: LD_EXP 60
55846: PPUSH
55847: LD_VAR 0 1
55851: PPUSH
55852: EMPTY
55853: PPUSH
55854: CALL_OW 1
55858: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55859: LD_ADDR_EXP 61
55863: PUSH
55864: LD_EXP 61
55868: PPUSH
55869: LD_VAR 0 1
55873: PPUSH
55874: EMPTY
55875: PPUSH
55876: CALL_OW 1
55880: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55881: LD_ADDR_EXP 62
55885: PUSH
55886: LD_EXP 62
55890: PPUSH
55891: LD_VAR 0 1
55895: PPUSH
55896: EMPTY
55897: PPUSH
55898: CALL_OW 1
55902: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55903: LD_ADDR_EXP 63
55907: PUSH
55908: LD_EXP 63
55912: PPUSH
55913: LD_VAR 0 1
55917: PPUSH
55918: EMPTY
55919: PPUSH
55920: CALL_OW 1
55924: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55925: LD_ADDR_EXP 64
55929: PUSH
55930: LD_EXP 64
55934: PPUSH
55935: LD_VAR 0 1
55939: PPUSH
55940: EMPTY
55941: PPUSH
55942: CALL_OW 1
55946: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55947: LD_ADDR_EXP 65
55951: PUSH
55952: LD_EXP 65
55956: PPUSH
55957: LD_VAR 0 1
55961: PPUSH
55962: EMPTY
55963: PPUSH
55964: CALL_OW 1
55968: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55969: LD_ADDR_EXP 66
55973: PUSH
55974: LD_EXP 66
55978: PPUSH
55979: LD_VAR 0 1
55983: PPUSH
55984: EMPTY
55985: PPUSH
55986: CALL_OW 1
55990: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55991: LD_ADDR_EXP 67
55995: PUSH
55996: LD_EXP 67
56000: PPUSH
56001: LD_VAR 0 1
56005: PPUSH
56006: EMPTY
56007: PPUSH
56008: CALL_OW 1
56012: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56013: LD_ADDR_EXP 68
56017: PUSH
56018: LD_EXP 68
56022: PPUSH
56023: LD_VAR 0 1
56027: PPUSH
56028: EMPTY
56029: PPUSH
56030: CALL_OW 1
56034: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56035: LD_ADDR_EXP 69
56039: PUSH
56040: LD_EXP 69
56044: PPUSH
56045: LD_VAR 0 1
56049: PPUSH
56050: LD_INT 0
56052: PPUSH
56053: CALL_OW 1
56057: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56058: LD_ADDR_EXP 70
56062: PUSH
56063: LD_EXP 70
56067: PPUSH
56068: LD_VAR 0 1
56072: PPUSH
56073: EMPTY
56074: PPUSH
56075: CALL_OW 1
56079: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56080: LD_ADDR_EXP 71
56084: PUSH
56085: LD_EXP 71
56089: PPUSH
56090: LD_VAR 0 1
56094: PPUSH
56095: EMPTY
56096: PPUSH
56097: CALL_OW 1
56101: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56102: LD_ADDR_EXP 72
56106: PUSH
56107: LD_EXP 72
56111: PPUSH
56112: LD_VAR 0 1
56116: PPUSH
56117: EMPTY
56118: PPUSH
56119: CALL_OW 1
56123: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56124: LD_ADDR_EXP 73
56128: PUSH
56129: LD_EXP 73
56133: PPUSH
56134: LD_VAR 0 1
56138: PPUSH
56139: EMPTY
56140: PPUSH
56141: CALL_OW 1
56145: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56146: LD_ADDR_EXP 74
56150: PUSH
56151: LD_EXP 74
56155: PPUSH
56156: LD_VAR 0 1
56160: PPUSH
56161: EMPTY
56162: PPUSH
56163: CALL_OW 1
56167: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56168: LD_ADDR_EXP 75
56172: PUSH
56173: LD_EXP 75
56177: PPUSH
56178: LD_VAR 0 1
56182: PPUSH
56183: EMPTY
56184: PPUSH
56185: CALL_OW 1
56189: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56190: LD_ADDR_EXP 76
56194: PUSH
56195: LD_EXP 76
56199: PPUSH
56200: LD_VAR 0 1
56204: PPUSH
56205: EMPTY
56206: PPUSH
56207: CALL_OW 1
56211: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56212: LD_ADDR_EXP 77
56216: PUSH
56217: LD_EXP 77
56221: PPUSH
56222: LD_VAR 0 1
56226: PPUSH
56227: EMPTY
56228: PPUSH
56229: CALL_OW 1
56233: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56234: LD_ADDR_EXP 78
56238: PUSH
56239: LD_EXP 78
56243: PPUSH
56244: LD_VAR 0 1
56248: PPUSH
56249: EMPTY
56250: PPUSH
56251: CALL_OW 1
56255: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56256: LD_ADDR_EXP 79
56260: PUSH
56261: LD_EXP 79
56265: PPUSH
56266: LD_VAR 0 1
56270: PPUSH
56271: EMPTY
56272: PPUSH
56273: CALL_OW 1
56277: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56278: LD_ADDR_EXP 80
56282: PUSH
56283: LD_EXP 80
56287: PPUSH
56288: LD_VAR 0 1
56292: PPUSH
56293: EMPTY
56294: PPUSH
56295: CALL_OW 1
56299: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56300: LD_ADDR_EXP 81
56304: PUSH
56305: LD_EXP 81
56309: PPUSH
56310: LD_VAR 0 1
56314: PPUSH
56315: EMPTY
56316: PPUSH
56317: CALL_OW 1
56321: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56322: LD_ADDR_EXP 82
56326: PUSH
56327: LD_EXP 82
56331: PPUSH
56332: LD_VAR 0 1
56336: PPUSH
56337: EMPTY
56338: PPUSH
56339: CALL_OW 1
56343: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56344: LD_ADDR_EXP 83
56348: PUSH
56349: LD_EXP 83
56353: PPUSH
56354: LD_VAR 0 1
56358: PPUSH
56359: EMPTY
56360: PPUSH
56361: CALL_OW 1
56365: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56366: LD_ADDR_EXP 85
56370: PUSH
56371: LD_EXP 85
56375: PPUSH
56376: LD_VAR 0 1
56380: PPUSH
56381: EMPTY
56382: PPUSH
56383: CALL_OW 1
56387: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56388: LD_ADDR_EXP 87
56392: PUSH
56393: LD_EXP 87
56397: PPUSH
56398: LD_VAR 0 1
56402: PPUSH
56403: EMPTY
56404: PPUSH
56405: CALL_OW 1
56409: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56410: LD_ADDR_EXP 88
56414: PUSH
56415: LD_EXP 88
56419: PPUSH
56420: LD_VAR 0 1
56424: PPUSH
56425: EMPTY
56426: PPUSH
56427: CALL_OW 1
56431: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56432: LD_ADDR_EXP 89
56436: PUSH
56437: LD_EXP 89
56441: PPUSH
56442: LD_VAR 0 1
56446: PPUSH
56447: EMPTY
56448: PPUSH
56449: CALL_OW 1
56453: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56454: LD_ADDR_EXP 90
56458: PUSH
56459: LD_EXP 90
56463: PPUSH
56464: LD_VAR 0 1
56468: PPUSH
56469: EMPTY
56470: PPUSH
56471: CALL_OW 1
56475: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56476: LD_ADDR_EXP 91
56480: PUSH
56481: LD_EXP 91
56485: PPUSH
56486: LD_VAR 0 1
56490: PPUSH
56491: EMPTY
56492: PPUSH
56493: CALL_OW 1
56497: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56498: LD_ADDR_EXP 92
56502: PUSH
56503: LD_EXP 92
56507: PPUSH
56508: LD_VAR 0 1
56512: PPUSH
56513: EMPTY
56514: PPUSH
56515: CALL_OW 1
56519: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56520: LD_ADDR_EXP 93
56524: PUSH
56525: LD_EXP 93
56529: PPUSH
56530: LD_VAR 0 1
56534: PPUSH
56535: EMPTY
56536: PPUSH
56537: CALL_OW 1
56541: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56542: LD_ADDR_EXP 94
56546: PUSH
56547: LD_EXP 94
56551: PPUSH
56552: LD_VAR 0 1
56556: PPUSH
56557: EMPTY
56558: PPUSH
56559: CALL_OW 1
56563: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56564: LD_ADDR_EXP 95
56568: PUSH
56569: LD_EXP 95
56573: PPUSH
56574: LD_VAR 0 1
56578: PPUSH
56579: EMPTY
56580: PPUSH
56581: CALL_OW 1
56585: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56586: LD_ADDR_EXP 96
56590: PUSH
56591: LD_EXP 96
56595: PPUSH
56596: LD_VAR 0 1
56600: PPUSH
56601: EMPTY
56602: PPUSH
56603: CALL_OW 1
56607: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56608: LD_ADDR_EXP 97
56612: PUSH
56613: LD_EXP 97
56617: PPUSH
56618: LD_VAR 0 1
56622: PPUSH
56623: EMPTY
56624: PPUSH
56625: CALL_OW 1
56629: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56630: LD_ADDR_EXP 98
56634: PUSH
56635: LD_EXP 98
56639: PPUSH
56640: LD_VAR 0 1
56644: PPUSH
56645: EMPTY
56646: PPUSH
56647: CALL_OW 1
56651: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56652: LD_ADDR_EXP 99
56656: PUSH
56657: LD_EXP 99
56661: PPUSH
56662: LD_VAR 0 1
56666: PPUSH
56667: EMPTY
56668: PPUSH
56669: CALL_OW 1
56673: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56674: LD_ADDR_EXP 100
56678: PUSH
56679: LD_EXP 100
56683: PPUSH
56684: LD_VAR 0 1
56688: PPUSH
56689: LD_INT 0
56691: PPUSH
56692: CALL_OW 1
56696: ST_TO_ADDR
// end ;
56697: LD_VAR 0 2
56701: RET
// export function MC_Start ( ) ; var i ; begin
56702: LD_INT 0
56704: PPUSH
56705: PPUSH
// for i = 1 to mc_bases do
56706: LD_ADDR_VAR 0 2
56710: PUSH
56711: DOUBLE
56712: LD_INT 1
56714: DEC
56715: ST_TO_ADDR
56716: LD_EXP 58
56720: PUSH
56721: FOR_TO
56722: IFFALSE 57799
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56724: LD_ADDR_EXP 58
56728: PUSH
56729: LD_EXP 58
56733: PPUSH
56734: LD_VAR 0 2
56738: PPUSH
56739: LD_EXP 58
56743: PUSH
56744: LD_VAR 0 2
56748: ARRAY
56749: PUSH
56750: LD_INT 0
56752: DIFF
56753: PPUSH
56754: CALL_OW 1
56758: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56759: LD_ADDR_EXP 59
56763: PUSH
56764: LD_EXP 59
56768: PPUSH
56769: LD_VAR 0 2
56773: PPUSH
56774: EMPTY
56775: PPUSH
56776: CALL_OW 1
56780: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56781: LD_ADDR_EXP 60
56785: PUSH
56786: LD_EXP 60
56790: PPUSH
56791: LD_VAR 0 2
56795: PPUSH
56796: EMPTY
56797: PPUSH
56798: CALL_OW 1
56802: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56803: LD_ADDR_EXP 61
56807: PUSH
56808: LD_EXP 61
56812: PPUSH
56813: LD_VAR 0 2
56817: PPUSH
56818: EMPTY
56819: PPUSH
56820: CALL_OW 1
56824: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56825: LD_ADDR_EXP 62
56829: PUSH
56830: LD_EXP 62
56834: PPUSH
56835: LD_VAR 0 2
56839: PPUSH
56840: EMPTY
56841: PUSH
56842: EMPTY
56843: PUSH
56844: EMPTY
56845: LIST
56846: LIST
56847: PPUSH
56848: CALL_OW 1
56852: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56853: LD_ADDR_EXP 63
56857: PUSH
56858: LD_EXP 63
56862: PPUSH
56863: LD_VAR 0 2
56867: PPUSH
56868: EMPTY
56869: PPUSH
56870: CALL_OW 1
56874: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56875: LD_ADDR_EXP 90
56879: PUSH
56880: LD_EXP 90
56884: PPUSH
56885: LD_VAR 0 2
56889: PPUSH
56890: EMPTY
56891: PPUSH
56892: CALL_OW 1
56896: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56897: LD_ADDR_EXP 64
56901: PUSH
56902: LD_EXP 64
56906: PPUSH
56907: LD_VAR 0 2
56911: PPUSH
56912: EMPTY
56913: PPUSH
56914: CALL_OW 1
56918: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56919: LD_ADDR_EXP 65
56923: PUSH
56924: LD_EXP 65
56928: PPUSH
56929: LD_VAR 0 2
56933: PPUSH
56934: EMPTY
56935: PPUSH
56936: CALL_OW 1
56940: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56941: LD_ADDR_EXP 66
56945: PUSH
56946: LD_EXP 66
56950: PPUSH
56951: LD_VAR 0 2
56955: PPUSH
56956: LD_EXP 58
56960: PUSH
56961: LD_VAR 0 2
56965: ARRAY
56966: PPUSH
56967: LD_INT 2
56969: PUSH
56970: LD_INT 30
56972: PUSH
56973: LD_INT 32
56975: PUSH
56976: EMPTY
56977: LIST
56978: LIST
56979: PUSH
56980: LD_INT 30
56982: PUSH
56983: LD_INT 33
56985: PUSH
56986: EMPTY
56987: LIST
56988: LIST
56989: PUSH
56990: EMPTY
56991: LIST
56992: LIST
56993: LIST
56994: PPUSH
56995: CALL_OW 72
56999: PPUSH
57000: CALL_OW 1
57004: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57005: LD_ADDR_EXP 67
57009: PUSH
57010: LD_EXP 67
57014: PPUSH
57015: LD_VAR 0 2
57019: PPUSH
57020: LD_EXP 58
57024: PUSH
57025: LD_VAR 0 2
57029: ARRAY
57030: PPUSH
57031: LD_INT 2
57033: PUSH
57034: LD_INT 30
57036: PUSH
57037: LD_INT 32
57039: PUSH
57040: EMPTY
57041: LIST
57042: LIST
57043: PUSH
57044: LD_INT 30
57046: PUSH
57047: LD_INT 31
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: PUSH
57054: EMPTY
57055: LIST
57056: LIST
57057: LIST
57058: PUSH
57059: LD_INT 58
57061: PUSH
57062: EMPTY
57063: LIST
57064: PUSH
57065: EMPTY
57066: LIST
57067: LIST
57068: PPUSH
57069: CALL_OW 72
57073: PPUSH
57074: CALL_OW 1
57078: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57079: LD_ADDR_EXP 68
57083: PUSH
57084: LD_EXP 68
57088: PPUSH
57089: LD_VAR 0 2
57093: PPUSH
57094: EMPTY
57095: PPUSH
57096: CALL_OW 1
57100: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57101: LD_ADDR_EXP 72
57105: PUSH
57106: LD_EXP 72
57110: PPUSH
57111: LD_VAR 0 2
57115: PPUSH
57116: EMPTY
57117: PPUSH
57118: CALL_OW 1
57122: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57123: LD_ADDR_EXP 71
57127: PUSH
57128: LD_EXP 71
57132: PPUSH
57133: LD_VAR 0 2
57137: PPUSH
57138: EMPTY
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57145: LD_ADDR_EXP 73
57149: PUSH
57150: LD_EXP 73
57154: PPUSH
57155: LD_VAR 0 2
57159: PPUSH
57160: EMPTY
57161: PPUSH
57162: CALL_OW 1
57166: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57167: LD_ADDR_EXP 74
57171: PUSH
57172: LD_EXP 74
57176: PPUSH
57177: LD_VAR 0 2
57181: PPUSH
57182: EMPTY
57183: PPUSH
57184: CALL_OW 1
57188: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57189: LD_ADDR_EXP 75
57193: PUSH
57194: LD_EXP 75
57198: PPUSH
57199: LD_VAR 0 2
57203: PPUSH
57204: EMPTY
57205: PPUSH
57206: CALL_OW 1
57210: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57211: LD_ADDR_EXP 76
57215: PUSH
57216: LD_EXP 76
57220: PPUSH
57221: LD_VAR 0 2
57225: PPUSH
57226: EMPTY
57227: PPUSH
57228: CALL_OW 1
57232: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57233: LD_ADDR_EXP 77
57237: PUSH
57238: LD_EXP 77
57242: PPUSH
57243: LD_VAR 0 2
57247: PPUSH
57248: EMPTY
57249: PPUSH
57250: CALL_OW 1
57254: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57255: LD_ADDR_EXP 78
57259: PUSH
57260: LD_EXP 78
57264: PPUSH
57265: LD_VAR 0 2
57269: PPUSH
57270: EMPTY
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57277: LD_ADDR_EXP 79
57281: PUSH
57282: LD_EXP 79
57286: PPUSH
57287: LD_VAR 0 2
57291: PPUSH
57292: EMPTY
57293: PPUSH
57294: CALL_OW 1
57298: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57299: LD_ADDR_EXP 80
57303: PUSH
57304: LD_EXP 80
57308: PPUSH
57309: LD_VAR 0 2
57313: PPUSH
57314: EMPTY
57315: PPUSH
57316: CALL_OW 1
57320: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57321: LD_ADDR_EXP 69
57325: PUSH
57326: LD_EXP 69
57330: PPUSH
57331: LD_VAR 0 2
57335: PPUSH
57336: LD_INT 0
57338: PPUSH
57339: CALL_OW 1
57343: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57344: LD_ADDR_EXP 82
57348: PUSH
57349: LD_EXP 82
57353: PPUSH
57354: LD_VAR 0 2
57358: PPUSH
57359: LD_INT 0
57361: PPUSH
57362: CALL_OW 1
57366: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57367: LD_ADDR_EXP 70
57371: PUSH
57372: LD_EXP 70
57376: PPUSH
57377: LD_VAR 0 2
57381: PPUSH
57382: EMPTY
57383: PPUSH
57384: CALL_OW 1
57388: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57389: LD_ADDR_EXP 81
57393: PUSH
57394: LD_EXP 81
57398: PPUSH
57399: LD_VAR 0 2
57403: PPUSH
57404: LD_INT 0
57406: PPUSH
57407: CALL_OW 1
57411: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57412: LD_ADDR_EXP 83
57416: PUSH
57417: LD_EXP 83
57421: PPUSH
57422: LD_VAR 0 2
57426: PPUSH
57427: EMPTY
57428: PPUSH
57429: CALL_OW 1
57433: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57434: LD_ADDR_EXP 86
57438: PUSH
57439: LD_EXP 86
57443: PPUSH
57444: LD_VAR 0 2
57448: PPUSH
57449: LD_INT 0
57451: PPUSH
57452: CALL_OW 1
57456: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57457: LD_ADDR_EXP 87
57461: PUSH
57462: LD_EXP 87
57466: PPUSH
57467: LD_VAR 0 2
57471: PPUSH
57472: EMPTY
57473: PPUSH
57474: CALL_OW 1
57478: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57479: LD_ADDR_EXP 88
57483: PUSH
57484: LD_EXP 88
57488: PPUSH
57489: LD_VAR 0 2
57493: PPUSH
57494: EMPTY
57495: PPUSH
57496: CALL_OW 1
57500: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57501: LD_ADDR_EXP 89
57505: PUSH
57506: LD_EXP 89
57510: PPUSH
57511: LD_VAR 0 2
57515: PPUSH
57516: EMPTY
57517: PPUSH
57518: CALL_OW 1
57522: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57523: LD_ADDR_EXP 91
57527: PUSH
57528: LD_EXP 91
57532: PPUSH
57533: LD_VAR 0 2
57537: PPUSH
57538: LD_EXP 58
57542: PUSH
57543: LD_VAR 0 2
57547: ARRAY
57548: PPUSH
57549: LD_INT 2
57551: PUSH
57552: LD_INT 30
57554: PUSH
57555: LD_INT 6
57557: PUSH
57558: EMPTY
57559: LIST
57560: LIST
57561: PUSH
57562: LD_INT 30
57564: PUSH
57565: LD_INT 7
57567: PUSH
57568: EMPTY
57569: LIST
57570: LIST
57571: PUSH
57572: LD_INT 30
57574: PUSH
57575: LD_INT 8
57577: PUSH
57578: EMPTY
57579: LIST
57580: LIST
57581: PUSH
57582: EMPTY
57583: LIST
57584: LIST
57585: LIST
57586: LIST
57587: PPUSH
57588: CALL_OW 72
57592: PPUSH
57593: CALL_OW 1
57597: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57598: LD_ADDR_EXP 92
57602: PUSH
57603: LD_EXP 92
57607: PPUSH
57608: LD_VAR 0 2
57612: PPUSH
57613: EMPTY
57614: PPUSH
57615: CALL_OW 1
57619: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57620: LD_ADDR_EXP 93
57624: PUSH
57625: LD_EXP 93
57629: PPUSH
57630: LD_VAR 0 2
57634: PPUSH
57635: EMPTY
57636: PPUSH
57637: CALL_OW 1
57641: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57642: LD_ADDR_EXP 94
57646: PUSH
57647: LD_EXP 94
57651: PPUSH
57652: LD_VAR 0 2
57656: PPUSH
57657: EMPTY
57658: PPUSH
57659: CALL_OW 1
57663: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57664: LD_ADDR_EXP 95
57668: PUSH
57669: LD_EXP 95
57673: PPUSH
57674: LD_VAR 0 2
57678: PPUSH
57679: EMPTY
57680: PPUSH
57681: CALL_OW 1
57685: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57686: LD_ADDR_EXP 96
57690: PUSH
57691: LD_EXP 96
57695: PPUSH
57696: LD_VAR 0 2
57700: PPUSH
57701: EMPTY
57702: PPUSH
57703: CALL_OW 1
57707: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57708: LD_ADDR_EXP 97
57712: PUSH
57713: LD_EXP 97
57717: PPUSH
57718: LD_VAR 0 2
57722: PPUSH
57723: EMPTY
57724: PPUSH
57725: CALL_OW 1
57729: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57730: LD_ADDR_EXP 98
57734: PUSH
57735: LD_EXP 98
57739: PPUSH
57740: LD_VAR 0 2
57744: PPUSH
57745: EMPTY
57746: PPUSH
57747: CALL_OW 1
57751: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57752: LD_ADDR_EXP 99
57756: PUSH
57757: LD_EXP 99
57761: PPUSH
57762: LD_VAR 0 2
57766: PPUSH
57767: EMPTY
57768: PPUSH
57769: CALL_OW 1
57773: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57774: LD_ADDR_EXP 100
57778: PUSH
57779: LD_EXP 100
57783: PPUSH
57784: LD_VAR 0 2
57788: PPUSH
57789: LD_INT 0
57791: PPUSH
57792: CALL_OW 1
57796: ST_TO_ADDR
// end ;
57797: GO 56721
57799: POP
57800: POP
// MC_InitSides ( ) ;
57801: CALL 58087 0 0
// MC_InitResearch ( ) ;
57805: CALL 57826 0 0
// CustomInitMacro ( ) ;
57809: CALL 174 0 0
// skirmish := true ;
57813: LD_ADDR_EXP 56
57817: PUSH
57818: LD_INT 1
57820: ST_TO_ADDR
// end ;
57821: LD_VAR 0 1
57825: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57826: LD_INT 0
57828: PPUSH
57829: PPUSH
57830: PPUSH
57831: PPUSH
57832: PPUSH
57833: PPUSH
// if not mc_bases then
57834: LD_EXP 58
57838: NOT
57839: IFFALSE 57843
// exit ;
57841: GO 58082
// for i = 1 to 8 do
57843: LD_ADDR_VAR 0 2
57847: PUSH
57848: DOUBLE
57849: LD_INT 1
57851: DEC
57852: ST_TO_ADDR
57853: LD_INT 8
57855: PUSH
57856: FOR_TO
57857: IFFALSE 57883
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57859: LD_ADDR_EXP 85
57863: PUSH
57864: LD_EXP 85
57868: PPUSH
57869: LD_VAR 0 2
57873: PPUSH
57874: EMPTY
57875: PPUSH
57876: CALL_OW 1
57880: ST_TO_ADDR
57881: GO 57856
57883: POP
57884: POP
// tmp := [ ] ;
57885: LD_ADDR_VAR 0 5
57889: PUSH
57890: EMPTY
57891: ST_TO_ADDR
// for i = 1 to mc_sides do
57892: LD_ADDR_VAR 0 2
57896: PUSH
57897: DOUBLE
57898: LD_INT 1
57900: DEC
57901: ST_TO_ADDR
57902: LD_EXP 84
57906: PUSH
57907: FOR_TO
57908: IFFALSE 57966
// if not mc_sides [ i ] in tmp then
57910: LD_EXP 84
57914: PUSH
57915: LD_VAR 0 2
57919: ARRAY
57920: PUSH
57921: LD_VAR 0 5
57925: IN
57926: NOT
57927: IFFALSE 57964
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57929: LD_ADDR_VAR 0 5
57933: PUSH
57934: LD_VAR 0 5
57938: PPUSH
57939: LD_VAR 0 5
57943: PUSH
57944: LD_INT 1
57946: PLUS
57947: PPUSH
57948: LD_EXP 84
57952: PUSH
57953: LD_VAR 0 2
57957: ARRAY
57958: PPUSH
57959: CALL_OW 2
57963: ST_TO_ADDR
57964: GO 57907
57966: POP
57967: POP
// if not tmp then
57968: LD_VAR 0 5
57972: NOT
57973: IFFALSE 57977
// exit ;
57975: GO 58082
// for j in tmp do
57977: LD_ADDR_VAR 0 3
57981: PUSH
57982: LD_VAR 0 5
57986: PUSH
57987: FOR_IN
57988: IFFALSE 58080
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57990: LD_ADDR_VAR 0 6
57994: PUSH
57995: LD_INT 22
57997: PUSH
57998: LD_VAR 0 3
58002: PUSH
58003: EMPTY
58004: LIST
58005: LIST
58006: PPUSH
58007: CALL_OW 69
58011: ST_TO_ADDR
// if not un then
58012: LD_VAR 0 6
58016: NOT
58017: IFFALSE 58021
// continue ;
58019: GO 57987
// nation := GetNation ( un [ 1 ] ) ;
58021: LD_ADDR_VAR 0 4
58025: PUSH
58026: LD_VAR 0 6
58030: PUSH
58031: LD_INT 1
58033: ARRAY
58034: PPUSH
58035: CALL_OW 248
58039: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58040: LD_ADDR_EXP 85
58044: PUSH
58045: LD_EXP 85
58049: PPUSH
58050: LD_VAR 0 3
58054: PPUSH
58055: LD_VAR 0 3
58059: PPUSH
58060: LD_VAR 0 4
58064: PPUSH
58065: LD_INT 1
58067: PPUSH
58068: CALL 13570 0 3
58072: PPUSH
58073: CALL_OW 1
58077: ST_TO_ADDR
// end ;
58078: GO 57987
58080: POP
58081: POP
// end ;
58082: LD_VAR 0 1
58086: RET
// export function MC_InitSides ( ) ; var i ; begin
58087: LD_INT 0
58089: PPUSH
58090: PPUSH
// if not mc_bases then
58091: LD_EXP 58
58095: NOT
58096: IFFALSE 58100
// exit ;
58098: GO 58174
// for i = 1 to mc_bases do
58100: LD_ADDR_VAR 0 2
58104: PUSH
58105: DOUBLE
58106: LD_INT 1
58108: DEC
58109: ST_TO_ADDR
58110: LD_EXP 58
58114: PUSH
58115: FOR_TO
58116: IFFALSE 58172
// if mc_bases [ i ] then
58118: LD_EXP 58
58122: PUSH
58123: LD_VAR 0 2
58127: ARRAY
58128: IFFALSE 58170
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58130: LD_ADDR_EXP 84
58134: PUSH
58135: LD_EXP 84
58139: PPUSH
58140: LD_VAR 0 2
58144: PPUSH
58145: LD_EXP 58
58149: PUSH
58150: LD_VAR 0 2
58154: ARRAY
58155: PUSH
58156: LD_INT 1
58158: ARRAY
58159: PPUSH
58160: CALL_OW 255
58164: PPUSH
58165: CALL_OW 1
58169: ST_TO_ADDR
58170: GO 58115
58172: POP
58173: POP
// end ;
58174: LD_VAR 0 1
58178: RET
// every 0 0$01 trigger skirmish do
58179: LD_EXP 56
58183: IFFALSE 58337
58185: GO 58187
58187: DISABLE
// begin enable ;
58188: ENABLE
// MC_CheckBuildings ( ) ;
58189: CALL 62484 0 0
// MC_CheckPeopleLife ( ) ;
58193: CALL 62609 0 0
// RaiseSailEvent ( 100 ) ;
58197: LD_INT 100
58199: PPUSH
58200: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58204: LD_INT 103
58206: PPUSH
58207: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58211: LD_INT 104
58213: PPUSH
58214: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58218: LD_INT 105
58220: PPUSH
58221: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58225: LD_INT 106
58227: PPUSH
58228: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58232: LD_INT 107
58234: PPUSH
58235: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58239: LD_INT 108
58241: PPUSH
58242: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58246: LD_INT 109
58248: PPUSH
58249: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58253: LD_INT 110
58255: PPUSH
58256: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58260: LD_INT 111
58262: PPUSH
58263: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58267: LD_INT 112
58269: PPUSH
58270: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58274: LD_INT 113
58276: PPUSH
58277: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58281: LD_INT 120
58283: PPUSH
58284: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58288: LD_INT 121
58290: PPUSH
58291: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58295: LD_INT 122
58297: PPUSH
58298: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58302: LD_INT 123
58304: PPUSH
58305: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58309: LD_INT 124
58311: PPUSH
58312: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58316: LD_INT 125
58318: PPUSH
58319: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58323: LD_INT 126
58325: PPUSH
58326: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58330: LD_INT 200
58332: PPUSH
58333: CALL_OW 427
// end ;
58337: END
// on SailEvent ( event ) do begin if event = 100 then
58338: LD_VAR 0 1
58342: PUSH
58343: LD_INT 100
58345: EQUAL
58346: IFFALSE 58352
// MC_ClassManager ( ) ;
58348: CALL 58744 0 0
// if event = 101 then
58352: LD_VAR 0 1
58356: PUSH
58357: LD_INT 101
58359: EQUAL
58360: IFFALSE 58366
// MC_RepairBuildings ( ) ;
58362: CALL 63167 0 0
// if event = 102 then
58366: LD_VAR 0 1
58370: PUSH
58371: LD_INT 102
58373: EQUAL
58374: IFFALSE 58380
// MC_Heal ( ) ;
58376: CALL 63573 0 0
// if event = 103 then
58380: LD_VAR 0 1
58384: PUSH
58385: LD_INT 103
58387: EQUAL
58388: IFFALSE 58394
// MC_Build ( ) ;
58390: CALL 63995 0 0
// if event = 104 then
58394: LD_VAR 0 1
58398: PUSH
58399: LD_INT 104
58401: EQUAL
58402: IFFALSE 58408
// MC_TurretWeapon ( ) ;
58404: CALL 65608 0 0
// if event = 105 then
58408: LD_VAR 0 1
58412: PUSH
58413: LD_INT 105
58415: EQUAL
58416: IFFALSE 58422
// MC_BuildUpgrade ( ) ;
58418: CALL 65159 0 0
// if event = 106 then
58422: LD_VAR 0 1
58426: PUSH
58427: LD_INT 106
58429: EQUAL
58430: IFFALSE 58436
// MC_PlantMines ( ) ;
58432: CALL 66038 0 0
// if event = 107 then
58436: LD_VAR 0 1
58440: PUSH
58441: LD_INT 107
58443: EQUAL
58444: IFFALSE 58450
// MC_CollectCrates ( ) ;
58446: CALL 67072 0 0
// if event = 108 then
58450: LD_VAR 0 1
58454: PUSH
58455: LD_INT 108
58457: EQUAL
58458: IFFALSE 58464
// MC_LinkRemoteControl ( ) ;
58460: CALL 68829 0 0
// if event = 109 then
58464: LD_VAR 0 1
58468: PUSH
58469: LD_INT 109
58471: EQUAL
58472: IFFALSE 58478
// MC_ProduceVehicle ( ) ;
58474: CALL 69010 0 0
// if event = 110 then
58478: LD_VAR 0 1
58482: PUSH
58483: LD_INT 110
58485: EQUAL
58486: IFFALSE 58492
// MC_SendAttack ( ) ;
58488: CALL 69491 0 0
// if event = 111 then
58492: LD_VAR 0 1
58496: PUSH
58497: LD_INT 111
58499: EQUAL
58500: IFFALSE 58506
// MC_Defend ( ) ;
58502: CALL 69599 0 0
// if event = 112 then
58506: LD_VAR 0 1
58510: PUSH
58511: LD_INT 112
58513: EQUAL
58514: IFFALSE 58520
// MC_Research ( ) ;
58516: CALL 70226 0 0
// if event = 113 then
58520: LD_VAR 0 1
58524: PUSH
58525: LD_INT 113
58527: EQUAL
58528: IFFALSE 58534
// MC_MinesTrigger ( ) ;
58530: CALL 71313 0 0
// if event = 120 then
58534: LD_VAR 0 1
58538: PUSH
58539: LD_INT 120
58541: EQUAL
58542: IFFALSE 58548
// MC_RepairVehicle ( ) ;
58544: CALL 71412 0 0
// if event = 121 then
58548: LD_VAR 0 1
58552: PUSH
58553: LD_INT 121
58555: EQUAL
58556: IFFALSE 58562
// MC_TameApe ( ) ;
58558: CALL 72155 0 0
// if event = 122 then
58562: LD_VAR 0 1
58566: PUSH
58567: LD_INT 122
58569: EQUAL
58570: IFFALSE 58576
// MC_ChangeApeClass ( ) ;
58572: CALL 72984 0 0
// if event = 123 then
58576: LD_VAR 0 1
58580: PUSH
58581: LD_INT 123
58583: EQUAL
58584: IFFALSE 58590
// MC_Bazooka ( ) ;
58586: CALL 73634 0 0
// if event = 124 then
58590: LD_VAR 0 1
58594: PUSH
58595: LD_INT 124
58597: EQUAL
58598: IFFALSE 58604
// MC_TeleportExit ( ) ;
58600: CALL 73832 0 0
// if event = 125 then
58604: LD_VAR 0 1
58608: PUSH
58609: LD_INT 125
58611: EQUAL
58612: IFFALSE 58618
// MC_Deposits ( ) ;
58614: CALL 74479 0 0
// if event = 126 then
58618: LD_VAR 0 1
58622: PUSH
58623: LD_INT 126
58625: EQUAL
58626: IFFALSE 58632
// MC_RemoteDriver ( ) ;
58628: CALL 75104 0 0
// if event = 200 then
58632: LD_VAR 0 1
58636: PUSH
58637: LD_INT 200
58639: EQUAL
58640: IFFALSE 58646
// MC_Idle ( ) ;
58642: CALL 76837 0 0
// end ;
58646: PPOPN 1
58648: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58649: LD_INT 0
58651: PPUSH
58652: PPUSH
// if not mc_bases [ base ] or not tag then
58653: LD_EXP 58
58657: PUSH
58658: LD_VAR 0 1
58662: ARRAY
58663: NOT
58664: PUSH
58665: LD_VAR 0 2
58669: NOT
58670: OR
58671: IFFALSE 58675
// exit ;
58673: GO 58739
// for i in mc_bases [ base ] union mc_ape [ base ] do
58675: LD_ADDR_VAR 0 4
58679: PUSH
58680: LD_EXP 58
58684: PUSH
58685: LD_VAR 0 1
58689: ARRAY
58690: PUSH
58691: LD_EXP 87
58695: PUSH
58696: LD_VAR 0 1
58700: ARRAY
58701: UNION
58702: PUSH
58703: FOR_IN
58704: IFFALSE 58737
// if GetTag ( i ) = tag then
58706: LD_VAR 0 4
58710: PPUSH
58711: CALL_OW 110
58715: PUSH
58716: LD_VAR 0 2
58720: EQUAL
58721: IFFALSE 58735
// SetTag ( i , 0 ) ;
58723: LD_VAR 0 4
58727: PPUSH
58728: LD_INT 0
58730: PPUSH
58731: CALL_OW 109
58735: GO 58703
58737: POP
58738: POP
// end ;
58739: LD_VAR 0 3
58743: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58744: LD_INT 0
58746: PPUSH
58747: PPUSH
58748: PPUSH
58749: PPUSH
58750: PPUSH
58751: PPUSH
58752: PPUSH
58753: PPUSH
// if not mc_bases then
58754: LD_EXP 58
58758: NOT
58759: IFFALSE 58763
// exit ;
58761: GO 59221
// for i = 1 to mc_bases do
58763: LD_ADDR_VAR 0 2
58767: PUSH
58768: DOUBLE
58769: LD_INT 1
58771: DEC
58772: ST_TO_ADDR
58773: LD_EXP 58
58777: PUSH
58778: FOR_TO
58779: IFFALSE 59219
// begin tmp := MC_ClassCheckReq ( i ) ;
58781: LD_ADDR_VAR 0 4
58785: PUSH
58786: LD_VAR 0 2
58790: PPUSH
58791: CALL 59226 0 1
58795: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58796: LD_ADDR_EXP 99
58800: PUSH
58801: LD_EXP 99
58805: PPUSH
58806: LD_VAR 0 2
58810: PPUSH
58811: LD_VAR 0 4
58815: PPUSH
58816: CALL_OW 1
58820: ST_TO_ADDR
// if not tmp then
58821: LD_VAR 0 4
58825: NOT
58826: IFFALSE 58830
// continue ;
58828: GO 58778
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58830: LD_ADDR_VAR 0 6
58834: PUSH
58835: LD_EXP 58
58839: PUSH
58840: LD_VAR 0 2
58844: ARRAY
58845: PPUSH
58846: LD_INT 2
58848: PUSH
58849: LD_INT 30
58851: PUSH
58852: LD_INT 4
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: PUSH
58859: LD_INT 30
58861: PUSH
58862: LD_INT 5
58864: PUSH
58865: EMPTY
58866: LIST
58867: LIST
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: LIST
58873: PPUSH
58874: CALL_OW 72
58878: PUSH
58879: LD_EXP 58
58883: PUSH
58884: LD_VAR 0 2
58888: ARRAY
58889: PPUSH
58890: LD_INT 2
58892: PUSH
58893: LD_INT 30
58895: PUSH
58896: LD_INT 0
58898: PUSH
58899: EMPTY
58900: LIST
58901: LIST
58902: PUSH
58903: LD_INT 30
58905: PUSH
58906: LD_INT 1
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: PUSH
58913: EMPTY
58914: LIST
58915: LIST
58916: LIST
58917: PPUSH
58918: CALL_OW 72
58922: PUSH
58923: LD_EXP 58
58927: PUSH
58928: LD_VAR 0 2
58932: ARRAY
58933: PPUSH
58934: LD_INT 30
58936: PUSH
58937: LD_INT 3
58939: PUSH
58940: EMPTY
58941: LIST
58942: LIST
58943: PPUSH
58944: CALL_OW 72
58948: PUSH
58949: LD_EXP 58
58953: PUSH
58954: LD_VAR 0 2
58958: ARRAY
58959: PPUSH
58960: LD_INT 2
58962: PUSH
58963: LD_INT 30
58965: PUSH
58966: LD_INT 6
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: PUSH
58973: LD_INT 30
58975: PUSH
58976: LD_INT 7
58978: PUSH
58979: EMPTY
58980: LIST
58981: LIST
58982: PUSH
58983: LD_INT 30
58985: PUSH
58986: LD_INT 8
58988: PUSH
58989: EMPTY
58990: LIST
58991: LIST
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: LIST
58997: LIST
58998: PPUSH
58999: CALL_OW 72
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: LIST
59008: LIST
59009: ST_TO_ADDR
// for j = 1 to 4 do
59010: LD_ADDR_VAR 0 3
59014: PUSH
59015: DOUBLE
59016: LD_INT 1
59018: DEC
59019: ST_TO_ADDR
59020: LD_INT 4
59022: PUSH
59023: FOR_TO
59024: IFFALSE 59215
// begin if not tmp [ j ] then
59026: LD_VAR 0 4
59030: PUSH
59031: LD_VAR 0 3
59035: ARRAY
59036: NOT
59037: IFFALSE 59041
// continue ;
59039: GO 59023
// for p in tmp [ j ] do
59041: LD_ADDR_VAR 0 5
59045: PUSH
59046: LD_VAR 0 4
59050: PUSH
59051: LD_VAR 0 3
59055: ARRAY
59056: PUSH
59057: FOR_IN
59058: IFFALSE 59211
// begin if not b [ j ] then
59060: LD_VAR 0 6
59064: PUSH
59065: LD_VAR 0 3
59069: ARRAY
59070: NOT
59071: IFFALSE 59075
// break ;
59073: GO 59211
// e := 0 ;
59075: LD_ADDR_VAR 0 7
59079: PUSH
59080: LD_INT 0
59082: ST_TO_ADDR
// for k in b [ j ] do
59083: LD_ADDR_VAR 0 8
59087: PUSH
59088: LD_VAR 0 6
59092: PUSH
59093: LD_VAR 0 3
59097: ARRAY
59098: PUSH
59099: FOR_IN
59100: IFFALSE 59127
// if IsNotFull ( k ) then
59102: LD_VAR 0 8
59106: PPUSH
59107: CALL 17596 0 1
59111: IFFALSE 59125
// begin e := k ;
59113: LD_ADDR_VAR 0 7
59117: PUSH
59118: LD_VAR 0 8
59122: ST_TO_ADDR
// break ;
59123: GO 59127
// end ;
59125: GO 59099
59127: POP
59128: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59129: LD_VAR 0 7
59133: PUSH
59134: LD_VAR 0 5
59138: PPUSH
59139: LD_VAR 0 7
59143: PPUSH
59144: CALL 54430 0 2
59148: NOT
59149: AND
59150: IFFALSE 59209
// begin if IsInUnit ( p ) then
59152: LD_VAR 0 5
59156: PPUSH
59157: CALL_OW 310
59161: IFFALSE 59172
// ComExitBuilding ( p ) ;
59163: LD_VAR 0 5
59167: PPUSH
59168: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59172: LD_VAR 0 5
59176: PPUSH
59177: LD_VAR 0 7
59181: PPUSH
59182: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59186: LD_VAR 0 5
59190: PPUSH
59191: LD_VAR 0 3
59195: PPUSH
59196: CALL_OW 183
// AddComExitBuilding ( p ) ;
59200: LD_VAR 0 5
59204: PPUSH
59205: CALL_OW 182
// end ; end ;
59209: GO 59057
59211: POP
59212: POP
// end ;
59213: GO 59023
59215: POP
59216: POP
// end ;
59217: GO 58778
59219: POP
59220: POP
// end ;
59221: LD_VAR 0 1
59225: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59226: LD_INT 0
59228: PPUSH
59229: PPUSH
59230: PPUSH
59231: PPUSH
59232: PPUSH
59233: PPUSH
59234: PPUSH
59235: PPUSH
59236: PPUSH
59237: PPUSH
59238: PPUSH
59239: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59240: LD_VAR 0 1
59244: NOT
59245: PUSH
59246: LD_EXP 58
59250: PUSH
59251: LD_VAR 0 1
59255: ARRAY
59256: NOT
59257: OR
59258: PUSH
59259: LD_EXP 58
59263: PUSH
59264: LD_VAR 0 1
59268: ARRAY
59269: PPUSH
59270: LD_INT 2
59272: PUSH
59273: LD_INT 30
59275: PUSH
59276: LD_INT 0
59278: PUSH
59279: EMPTY
59280: LIST
59281: LIST
59282: PUSH
59283: LD_INT 30
59285: PUSH
59286: LD_INT 1
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: PUSH
59293: EMPTY
59294: LIST
59295: LIST
59296: LIST
59297: PPUSH
59298: CALL_OW 72
59302: NOT
59303: OR
59304: IFFALSE 59308
// exit ;
59306: GO 62479
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59308: LD_ADDR_VAR 0 4
59312: PUSH
59313: LD_EXP 58
59317: PUSH
59318: LD_VAR 0 1
59322: ARRAY
59323: PPUSH
59324: LD_INT 2
59326: PUSH
59327: LD_INT 25
59329: PUSH
59330: LD_INT 1
59332: PUSH
59333: EMPTY
59334: LIST
59335: LIST
59336: PUSH
59337: LD_INT 25
59339: PUSH
59340: LD_INT 2
59342: PUSH
59343: EMPTY
59344: LIST
59345: LIST
59346: PUSH
59347: LD_INT 25
59349: PUSH
59350: LD_INT 3
59352: PUSH
59353: EMPTY
59354: LIST
59355: LIST
59356: PUSH
59357: LD_INT 25
59359: PUSH
59360: LD_INT 4
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: PUSH
59367: LD_INT 25
59369: PUSH
59370: LD_INT 5
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: PUSH
59377: LD_INT 25
59379: PUSH
59380: LD_INT 8
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PUSH
59387: LD_INT 25
59389: PUSH
59390: LD_INT 9
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: PUSH
59397: EMPTY
59398: LIST
59399: LIST
59400: LIST
59401: LIST
59402: LIST
59403: LIST
59404: LIST
59405: LIST
59406: PPUSH
59407: CALL_OW 72
59411: ST_TO_ADDR
// for i in tmp do
59412: LD_ADDR_VAR 0 3
59416: PUSH
59417: LD_VAR 0 4
59421: PUSH
59422: FOR_IN
59423: IFFALSE 59454
// if GetTag ( i ) then
59425: LD_VAR 0 3
59429: PPUSH
59430: CALL_OW 110
59434: IFFALSE 59452
// tmp := tmp diff i ;
59436: LD_ADDR_VAR 0 4
59440: PUSH
59441: LD_VAR 0 4
59445: PUSH
59446: LD_VAR 0 3
59450: DIFF
59451: ST_TO_ADDR
59452: GO 59422
59454: POP
59455: POP
// if not tmp then
59456: LD_VAR 0 4
59460: NOT
59461: IFFALSE 59465
// exit ;
59463: GO 62479
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59465: LD_ADDR_VAR 0 5
59469: PUSH
59470: LD_EXP 58
59474: PUSH
59475: LD_VAR 0 1
59479: ARRAY
59480: PPUSH
59481: LD_INT 2
59483: PUSH
59484: LD_INT 25
59486: PUSH
59487: LD_INT 1
59489: PUSH
59490: EMPTY
59491: LIST
59492: LIST
59493: PUSH
59494: LD_INT 25
59496: PUSH
59497: LD_INT 5
59499: PUSH
59500: EMPTY
59501: LIST
59502: LIST
59503: PUSH
59504: LD_INT 25
59506: PUSH
59507: LD_INT 8
59509: PUSH
59510: EMPTY
59511: LIST
59512: LIST
59513: PUSH
59514: LD_INT 25
59516: PUSH
59517: LD_INT 9
59519: PUSH
59520: EMPTY
59521: LIST
59522: LIST
59523: PUSH
59524: EMPTY
59525: LIST
59526: LIST
59527: LIST
59528: LIST
59529: LIST
59530: PPUSH
59531: CALL_OW 72
59535: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59536: LD_ADDR_VAR 0 6
59540: PUSH
59541: LD_EXP 58
59545: PUSH
59546: LD_VAR 0 1
59550: ARRAY
59551: PPUSH
59552: LD_INT 25
59554: PUSH
59555: LD_INT 2
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PPUSH
59562: CALL_OW 72
59566: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59567: LD_ADDR_VAR 0 7
59571: PUSH
59572: LD_EXP 58
59576: PUSH
59577: LD_VAR 0 1
59581: ARRAY
59582: PPUSH
59583: LD_INT 25
59585: PUSH
59586: LD_INT 3
59588: PUSH
59589: EMPTY
59590: LIST
59591: LIST
59592: PPUSH
59593: CALL_OW 72
59597: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59598: LD_ADDR_VAR 0 8
59602: PUSH
59603: LD_EXP 58
59607: PUSH
59608: LD_VAR 0 1
59612: ARRAY
59613: PPUSH
59614: LD_INT 25
59616: PUSH
59617: LD_INT 4
59619: PUSH
59620: EMPTY
59621: LIST
59622: LIST
59623: PUSH
59624: LD_INT 24
59626: PUSH
59627: LD_INT 251
59629: PUSH
59630: EMPTY
59631: LIST
59632: LIST
59633: PUSH
59634: EMPTY
59635: LIST
59636: LIST
59637: PPUSH
59638: CALL_OW 72
59642: ST_TO_ADDR
// if mc_scan [ base ] then
59643: LD_EXP 81
59647: PUSH
59648: LD_VAR 0 1
59652: ARRAY
59653: IFFALSE 60114
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59655: LD_ADDR_EXP 100
59659: PUSH
59660: LD_EXP 100
59664: PPUSH
59665: LD_VAR 0 1
59669: PPUSH
59670: LD_INT 4
59672: PPUSH
59673: CALL_OW 1
59677: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59678: LD_ADDR_VAR 0 12
59682: PUSH
59683: LD_EXP 58
59687: PUSH
59688: LD_VAR 0 1
59692: ARRAY
59693: PPUSH
59694: LD_INT 2
59696: PUSH
59697: LD_INT 30
59699: PUSH
59700: LD_INT 4
59702: PUSH
59703: EMPTY
59704: LIST
59705: LIST
59706: PUSH
59707: LD_INT 30
59709: PUSH
59710: LD_INT 5
59712: PUSH
59713: EMPTY
59714: LIST
59715: LIST
59716: PUSH
59717: EMPTY
59718: LIST
59719: LIST
59720: LIST
59721: PPUSH
59722: CALL_OW 72
59726: ST_TO_ADDR
// if not b then
59727: LD_VAR 0 12
59731: NOT
59732: IFFALSE 59736
// exit ;
59734: GO 62479
// p := [ ] ;
59736: LD_ADDR_VAR 0 11
59740: PUSH
59741: EMPTY
59742: ST_TO_ADDR
// if sci >= 2 then
59743: LD_VAR 0 8
59747: PUSH
59748: LD_INT 2
59750: GREATEREQUAL
59751: IFFALSE 59782
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59753: LD_ADDR_VAR 0 8
59757: PUSH
59758: LD_VAR 0 8
59762: PUSH
59763: LD_INT 1
59765: ARRAY
59766: PUSH
59767: LD_VAR 0 8
59771: PUSH
59772: LD_INT 2
59774: ARRAY
59775: PUSH
59776: EMPTY
59777: LIST
59778: LIST
59779: ST_TO_ADDR
59780: GO 59843
// if sci = 1 then
59782: LD_VAR 0 8
59786: PUSH
59787: LD_INT 1
59789: EQUAL
59790: IFFALSE 59811
// sci := [ sci [ 1 ] ] else
59792: LD_ADDR_VAR 0 8
59796: PUSH
59797: LD_VAR 0 8
59801: PUSH
59802: LD_INT 1
59804: ARRAY
59805: PUSH
59806: EMPTY
59807: LIST
59808: ST_TO_ADDR
59809: GO 59843
// if sci = 0 then
59811: LD_VAR 0 8
59815: PUSH
59816: LD_INT 0
59818: EQUAL
59819: IFFALSE 59843
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59821: LD_ADDR_VAR 0 11
59825: PUSH
59826: LD_VAR 0 4
59830: PPUSH
59831: LD_INT 4
59833: PPUSH
59834: CALL 54293 0 2
59838: PUSH
59839: LD_INT 1
59841: ARRAY
59842: ST_TO_ADDR
// if eng > 4 then
59843: LD_VAR 0 6
59847: PUSH
59848: LD_INT 4
59850: GREATER
59851: IFFALSE 59897
// for i = eng downto 4 do
59853: LD_ADDR_VAR 0 3
59857: PUSH
59858: DOUBLE
59859: LD_VAR 0 6
59863: INC
59864: ST_TO_ADDR
59865: LD_INT 4
59867: PUSH
59868: FOR_DOWNTO
59869: IFFALSE 59895
// eng := eng diff eng [ i ] ;
59871: LD_ADDR_VAR 0 6
59875: PUSH
59876: LD_VAR 0 6
59880: PUSH
59881: LD_VAR 0 6
59885: PUSH
59886: LD_VAR 0 3
59890: ARRAY
59891: DIFF
59892: ST_TO_ADDR
59893: GO 59868
59895: POP
59896: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59897: LD_ADDR_VAR 0 4
59901: PUSH
59902: LD_VAR 0 4
59906: PUSH
59907: LD_VAR 0 5
59911: PUSH
59912: LD_VAR 0 6
59916: UNION
59917: PUSH
59918: LD_VAR 0 7
59922: UNION
59923: PUSH
59924: LD_VAR 0 8
59928: UNION
59929: DIFF
59930: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59931: LD_ADDR_VAR 0 13
59935: PUSH
59936: LD_EXP 58
59940: PUSH
59941: LD_VAR 0 1
59945: ARRAY
59946: PPUSH
59947: LD_INT 2
59949: PUSH
59950: LD_INT 30
59952: PUSH
59953: LD_INT 32
59955: PUSH
59956: EMPTY
59957: LIST
59958: LIST
59959: PUSH
59960: LD_INT 30
59962: PUSH
59963: LD_INT 31
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: PUSH
59970: EMPTY
59971: LIST
59972: LIST
59973: LIST
59974: PPUSH
59975: CALL_OW 72
59979: PUSH
59980: LD_EXP 58
59984: PUSH
59985: LD_VAR 0 1
59989: ARRAY
59990: PPUSH
59991: LD_INT 2
59993: PUSH
59994: LD_INT 30
59996: PUSH
59997: LD_INT 4
59999: PUSH
60000: EMPTY
60001: LIST
60002: LIST
60003: PUSH
60004: LD_INT 30
60006: PUSH
60007: LD_INT 5
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PUSH
60014: EMPTY
60015: LIST
60016: LIST
60017: LIST
60018: PPUSH
60019: CALL_OW 72
60023: PUSH
60024: LD_INT 6
60026: MUL
60027: PLUS
60028: ST_TO_ADDR
// if bcount < tmp then
60029: LD_VAR 0 13
60033: PUSH
60034: LD_VAR 0 4
60038: LESS
60039: IFFALSE 60085
// for i = tmp downto bcount do
60041: LD_ADDR_VAR 0 3
60045: PUSH
60046: DOUBLE
60047: LD_VAR 0 4
60051: INC
60052: ST_TO_ADDR
60053: LD_VAR 0 13
60057: PUSH
60058: FOR_DOWNTO
60059: IFFALSE 60083
// tmp := Delete ( tmp , tmp ) ;
60061: LD_ADDR_VAR 0 4
60065: PUSH
60066: LD_VAR 0 4
60070: PPUSH
60071: LD_VAR 0 4
60075: PPUSH
60076: CALL_OW 3
60080: ST_TO_ADDR
60081: GO 60058
60083: POP
60084: POP
// result := [ tmp , 0 , 0 , p ] ;
60085: LD_ADDR_VAR 0 2
60089: PUSH
60090: LD_VAR 0 4
60094: PUSH
60095: LD_INT 0
60097: PUSH
60098: LD_INT 0
60100: PUSH
60101: LD_VAR 0 11
60105: PUSH
60106: EMPTY
60107: LIST
60108: LIST
60109: LIST
60110: LIST
60111: ST_TO_ADDR
// exit ;
60112: GO 62479
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60114: LD_EXP 58
60118: PUSH
60119: LD_VAR 0 1
60123: ARRAY
60124: PPUSH
60125: LD_INT 2
60127: PUSH
60128: LD_INT 30
60130: PUSH
60131: LD_INT 6
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: PUSH
60138: LD_INT 30
60140: PUSH
60141: LD_INT 7
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: PUSH
60148: LD_INT 30
60150: PUSH
60151: LD_INT 8
60153: PUSH
60154: EMPTY
60155: LIST
60156: LIST
60157: PUSH
60158: EMPTY
60159: LIST
60160: LIST
60161: LIST
60162: LIST
60163: PPUSH
60164: CALL_OW 72
60168: NOT
60169: PUSH
60170: LD_EXP 58
60174: PUSH
60175: LD_VAR 0 1
60179: ARRAY
60180: PPUSH
60181: LD_INT 30
60183: PUSH
60184: LD_INT 3
60186: PUSH
60187: EMPTY
60188: LIST
60189: LIST
60190: PPUSH
60191: CALL_OW 72
60195: NOT
60196: AND
60197: IFFALSE 60269
// begin if eng = tmp then
60199: LD_VAR 0 6
60203: PUSH
60204: LD_VAR 0 4
60208: EQUAL
60209: IFFALSE 60213
// exit ;
60211: GO 62479
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60213: LD_ADDR_EXP 100
60217: PUSH
60218: LD_EXP 100
60222: PPUSH
60223: LD_VAR 0 1
60227: PPUSH
60228: LD_INT 1
60230: PPUSH
60231: CALL_OW 1
60235: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60236: LD_ADDR_VAR 0 2
60240: PUSH
60241: LD_INT 0
60243: PUSH
60244: LD_VAR 0 4
60248: PUSH
60249: LD_VAR 0 6
60253: DIFF
60254: PUSH
60255: LD_INT 0
60257: PUSH
60258: LD_INT 0
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: LIST
60265: LIST
60266: ST_TO_ADDR
// exit ;
60267: GO 62479
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60269: LD_EXP 85
60273: PUSH
60274: LD_EXP 84
60278: PUSH
60279: LD_VAR 0 1
60283: ARRAY
60284: ARRAY
60285: PUSH
60286: LD_EXP 58
60290: PUSH
60291: LD_VAR 0 1
60295: ARRAY
60296: PPUSH
60297: LD_INT 2
60299: PUSH
60300: LD_INT 30
60302: PUSH
60303: LD_INT 6
60305: PUSH
60306: EMPTY
60307: LIST
60308: LIST
60309: PUSH
60310: LD_INT 30
60312: PUSH
60313: LD_INT 7
60315: PUSH
60316: EMPTY
60317: LIST
60318: LIST
60319: PUSH
60320: LD_INT 30
60322: PUSH
60323: LD_INT 8
60325: PUSH
60326: EMPTY
60327: LIST
60328: LIST
60329: PUSH
60330: EMPTY
60331: LIST
60332: LIST
60333: LIST
60334: LIST
60335: PPUSH
60336: CALL_OW 72
60340: AND
60341: PUSH
60342: LD_EXP 58
60346: PUSH
60347: LD_VAR 0 1
60351: ARRAY
60352: PPUSH
60353: LD_INT 30
60355: PUSH
60356: LD_INT 3
60358: PUSH
60359: EMPTY
60360: LIST
60361: LIST
60362: PPUSH
60363: CALL_OW 72
60367: NOT
60368: AND
60369: IFFALSE 60583
// begin if sci >= 6 then
60371: LD_VAR 0 8
60375: PUSH
60376: LD_INT 6
60378: GREATEREQUAL
60379: IFFALSE 60383
// exit ;
60381: GO 62479
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60383: LD_ADDR_EXP 100
60387: PUSH
60388: LD_EXP 100
60392: PPUSH
60393: LD_VAR 0 1
60397: PPUSH
60398: LD_INT 2
60400: PPUSH
60401: CALL_OW 1
60405: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60406: LD_ADDR_VAR 0 9
60410: PUSH
60411: LD_VAR 0 4
60415: PUSH
60416: LD_VAR 0 8
60420: DIFF
60421: PPUSH
60422: LD_INT 4
60424: PPUSH
60425: CALL 54293 0 2
60429: ST_TO_ADDR
// p := [ ] ;
60430: LD_ADDR_VAR 0 11
60434: PUSH
60435: EMPTY
60436: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60437: LD_VAR 0 8
60441: PUSH
60442: LD_INT 6
60444: LESS
60445: PUSH
60446: LD_VAR 0 9
60450: PUSH
60451: LD_INT 6
60453: GREATER
60454: AND
60455: IFFALSE 60536
// begin for i = 1 to 6 - sci do
60457: LD_ADDR_VAR 0 3
60461: PUSH
60462: DOUBLE
60463: LD_INT 1
60465: DEC
60466: ST_TO_ADDR
60467: LD_INT 6
60469: PUSH
60470: LD_VAR 0 8
60474: MINUS
60475: PUSH
60476: FOR_TO
60477: IFFALSE 60532
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60479: LD_ADDR_VAR 0 11
60483: PUSH
60484: LD_VAR 0 11
60488: PPUSH
60489: LD_VAR 0 11
60493: PUSH
60494: LD_INT 1
60496: PLUS
60497: PPUSH
60498: LD_VAR 0 9
60502: PUSH
60503: LD_INT 1
60505: ARRAY
60506: PPUSH
60507: CALL_OW 2
60511: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60512: LD_ADDR_VAR 0 9
60516: PUSH
60517: LD_VAR 0 9
60521: PPUSH
60522: LD_INT 1
60524: PPUSH
60525: CALL_OW 3
60529: ST_TO_ADDR
// end ;
60530: GO 60476
60532: POP
60533: POP
// end else
60534: GO 60556
// if sort then
60536: LD_VAR 0 9
60540: IFFALSE 60556
// p := sort [ 1 ] ;
60542: LD_ADDR_VAR 0 11
60546: PUSH
60547: LD_VAR 0 9
60551: PUSH
60552: LD_INT 1
60554: ARRAY
60555: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60556: LD_ADDR_VAR 0 2
60560: PUSH
60561: LD_INT 0
60563: PUSH
60564: LD_INT 0
60566: PUSH
60567: LD_INT 0
60569: PUSH
60570: LD_VAR 0 11
60574: PUSH
60575: EMPTY
60576: LIST
60577: LIST
60578: LIST
60579: LIST
60580: ST_TO_ADDR
// exit ;
60581: GO 62479
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60583: LD_EXP 85
60587: PUSH
60588: LD_EXP 84
60592: PUSH
60593: LD_VAR 0 1
60597: ARRAY
60598: ARRAY
60599: PUSH
60600: LD_EXP 58
60604: PUSH
60605: LD_VAR 0 1
60609: ARRAY
60610: PPUSH
60611: LD_INT 2
60613: PUSH
60614: LD_INT 30
60616: PUSH
60617: LD_INT 6
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: PUSH
60624: LD_INT 30
60626: PUSH
60627: LD_INT 7
60629: PUSH
60630: EMPTY
60631: LIST
60632: LIST
60633: PUSH
60634: LD_INT 30
60636: PUSH
60637: LD_INT 8
60639: PUSH
60640: EMPTY
60641: LIST
60642: LIST
60643: PUSH
60644: EMPTY
60645: LIST
60646: LIST
60647: LIST
60648: LIST
60649: PPUSH
60650: CALL_OW 72
60654: AND
60655: PUSH
60656: LD_EXP 58
60660: PUSH
60661: LD_VAR 0 1
60665: ARRAY
60666: PPUSH
60667: LD_INT 30
60669: PUSH
60670: LD_INT 3
60672: PUSH
60673: EMPTY
60674: LIST
60675: LIST
60676: PPUSH
60677: CALL_OW 72
60681: AND
60682: IFFALSE 61209
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60684: LD_ADDR_EXP 100
60688: PUSH
60689: LD_EXP 100
60693: PPUSH
60694: LD_VAR 0 1
60698: PPUSH
60699: LD_INT 3
60701: PPUSH
60702: CALL_OW 1
60706: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60707: LD_ADDR_VAR 0 2
60711: PUSH
60712: LD_INT 0
60714: PUSH
60715: LD_INT 0
60717: PUSH
60718: LD_INT 0
60720: PUSH
60721: LD_INT 0
60723: PUSH
60724: EMPTY
60725: LIST
60726: LIST
60727: LIST
60728: LIST
60729: ST_TO_ADDR
// if not eng then
60730: LD_VAR 0 6
60734: NOT
60735: IFFALSE 60798
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60737: LD_ADDR_VAR 0 11
60741: PUSH
60742: LD_VAR 0 4
60746: PPUSH
60747: LD_INT 2
60749: PPUSH
60750: CALL 54293 0 2
60754: PUSH
60755: LD_INT 1
60757: ARRAY
60758: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60759: LD_ADDR_VAR 0 2
60763: PUSH
60764: LD_VAR 0 2
60768: PPUSH
60769: LD_INT 2
60771: PPUSH
60772: LD_VAR 0 11
60776: PPUSH
60777: CALL_OW 1
60781: ST_TO_ADDR
// tmp := tmp diff p ;
60782: LD_ADDR_VAR 0 4
60786: PUSH
60787: LD_VAR 0 4
60791: PUSH
60792: LD_VAR 0 11
60796: DIFF
60797: ST_TO_ADDR
// end ; if not eng then
60798: LD_VAR 0 6
60802: NOT
60803: IFFALSE 60829
// tmp := tmp diff ( mech union sci ) else
60805: LD_ADDR_VAR 0 4
60809: PUSH
60810: LD_VAR 0 4
60814: PUSH
60815: LD_VAR 0 7
60819: PUSH
60820: LD_VAR 0 8
60824: UNION
60825: DIFF
60826: ST_TO_ADDR
60827: GO 60861
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
60829: LD_ADDR_VAR 0 4
60833: PUSH
60834: LD_VAR 0 4
60838: PUSH
60839: LD_VAR 0 6
60843: PUSH
60844: LD_INT 1
60846: ARRAY
60847: PUSH
60848: LD_VAR 0 7
60852: UNION
60853: PUSH
60854: LD_VAR 0 8
60858: UNION
60859: DIFF
60860: ST_TO_ADDR
// if tmp and sci < 6 then
60861: LD_VAR 0 4
60865: PUSH
60866: LD_VAR 0 8
60870: PUSH
60871: LD_INT 6
60873: LESS
60874: AND
60875: IFFALSE 61034
// begin sort := SortBySkill ( tmp , 4 ) ;
60877: LD_ADDR_VAR 0 9
60881: PUSH
60882: LD_VAR 0 4
60886: PPUSH
60887: LD_INT 4
60889: PPUSH
60890: CALL 54293 0 2
60894: ST_TO_ADDR
// p := [ ] ;
60895: LD_ADDR_VAR 0 11
60899: PUSH
60900: EMPTY
60901: ST_TO_ADDR
// if sort then
60902: LD_VAR 0 9
60906: IFFALSE 61005
// for i = 1 to 6 - sci do
60908: LD_ADDR_VAR 0 3
60912: PUSH
60913: DOUBLE
60914: LD_INT 1
60916: DEC
60917: ST_TO_ADDR
60918: LD_INT 6
60920: PUSH
60921: LD_VAR 0 8
60925: MINUS
60926: PUSH
60927: FOR_TO
60928: IFFALSE 61003
// begin if i = sort then
60930: LD_VAR 0 3
60934: PUSH
60935: LD_VAR 0 9
60939: EQUAL
60940: IFFALSE 60944
// break ;
60942: GO 61003
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60944: LD_ADDR_VAR 0 11
60948: PUSH
60949: LD_VAR 0 11
60953: PPUSH
60954: LD_VAR 0 11
60958: PUSH
60959: LD_INT 1
60961: PLUS
60962: PPUSH
60963: LD_VAR 0 9
60967: PUSH
60968: LD_VAR 0 3
60972: ARRAY
60973: PPUSH
60974: CALL_OW 2
60978: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60979: LD_ADDR_VAR 0 4
60983: PUSH
60984: LD_VAR 0 4
60988: PUSH
60989: LD_VAR 0 9
60993: PUSH
60994: LD_VAR 0 3
60998: ARRAY
60999: DIFF
61000: ST_TO_ADDR
// end ;
61001: GO 60927
61003: POP
61004: POP
// if p then
61005: LD_VAR 0 11
61009: IFFALSE 61034
// result := Replace ( result , 4 , p ) ;
61011: LD_ADDR_VAR 0 2
61015: PUSH
61016: LD_VAR 0 2
61020: PPUSH
61021: LD_INT 4
61023: PPUSH
61024: LD_VAR 0 11
61028: PPUSH
61029: CALL_OW 1
61033: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61034: LD_VAR 0 4
61038: PUSH
61039: LD_VAR 0 7
61043: PUSH
61044: LD_INT 6
61046: LESS
61047: AND
61048: IFFALSE 61207
// begin sort := SortBySkill ( tmp , 3 ) ;
61050: LD_ADDR_VAR 0 9
61054: PUSH
61055: LD_VAR 0 4
61059: PPUSH
61060: LD_INT 3
61062: PPUSH
61063: CALL 54293 0 2
61067: ST_TO_ADDR
// p := [ ] ;
61068: LD_ADDR_VAR 0 11
61072: PUSH
61073: EMPTY
61074: ST_TO_ADDR
// if sort then
61075: LD_VAR 0 9
61079: IFFALSE 61178
// for i = 1 to 6 - mech do
61081: LD_ADDR_VAR 0 3
61085: PUSH
61086: DOUBLE
61087: LD_INT 1
61089: DEC
61090: ST_TO_ADDR
61091: LD_INT 6
61093: PUSH
61094: LD_VAR 0 7
61098: MINUS
61099: PUSH
61100: FOR_TO
61101: IFFALSE 61176
// begin if i = sort then
61103: LD_VAR 0 3
61107: PUSH
61108: LD_VAR 0 9
61112: EQUAL
61113: IFFALSE 61117
// break ;
61115: GO 61176
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61117: LD_ADDR_VAR 0 11
61121: PUSH
61122: LD_VAR 0 11
61126: PPUSH
61127: LD_VAR 0 11
61131: PUSH
61132: LD_INT 1
61134: PLUS
61135: PPUSH
61136: LD_VAR 0 9
61140: PUSH
61141: LD_VAR 0 3
61145: ARRAY
61146: PPUSH
61147: CALL_OW 2
61151: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61152: LD_ADDR_VAR 0 4
61156: PUSH
61157: LD_VAR 0 4
61161: PUSH
61162: LD_VAR 0 9
61166: PUSH
61167: LD_VAR 0 3
61171: ARRAY
61172: DIFF
61173: ST_TO_ADDR
// end ;
61174: GO 61100
61176: POP
61177: POP
// if p then
61178: LD_VAR 0 11
61182: IFFALSE 61207
// result := Replace ( result , 3 , p ) ;
61184: LD_ADDR_VAR 0 2
61188: PUSH
61189: LD_VAR 0 2
61193: PPUSH
61194: LD_INT 3
61196: PPUSH
61197: LD_VAR 0 11
61201: PPUSH
61202: CALL_OW 1
61206: ST_TO_ADDR
// end ; exit ;
61207: GO 62479
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61209: LD_EXP 85
61213: PUSH
61214: LD_EXP 84
61218: PUSH
61219: LD_VAR 0 1
61223: ARRAY
61224: ARRAY
61225: NOT
61226: PUSH
61227: LD_EXP 58
61231: PUSH
61232: LD_VAR 0 1
61236: ARRAY
61237: PPUSH
61238: LD_INT 30
61240: PUSH
61241: LD_INT 3
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: PPUSH
61248: CALL_OW 72
61252: AND
61253: PUSH
61254: LD_EXP 63
61258: PUSH
61259: LD_VAR 0 1
61263: ARRAY
61264: AND
61265: IFFALSE 61809
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61267: LD_ADDR_EXP 100
61271: PUSH
61272: LD_EXP 100
61276: PPUSH
61277: LD_VAR 0 1
61281: PPUSH
61282: LD_INT 5
61284: PPUSH
61285: CALL_OW 1
61289: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61290: LD_ADDR_VAR 0 2
61294: PUSH
61295: LD_INT 0
61297: PUSH
61298: LD_INT 0
61300: PUSH
61301: LD_INT 0
61303: PUSH
61304: LD_INT 0
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: LIST
61311: LIST
61312: ST_TO_ADDR
// if sci > 1 then
61313: LD_VAR 0 8
61317: PUSH
61318: LD_INT 1
61320: GREATER
61321: IFFALSE 61349
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61323: LD_ADDR_VAR 0 4
61327: PUSH
61328: LD_VAR 0 4
61332: PUSH
61333: LD_VAR 0 8
61337: PUSH
61338: LD_VAR 0 8
61342: PUSH
61343: LD_INT 1
61345: ARRAY
61346: DIFF
61347: DIFF
61348: ST_TO_ADDR
// if tmp and not sci then
61349: LD_VAR 0 4
61353: PUSH
61354: LD_VAR 0 8
61358: NOT
61359: AND
61360: IFFALSE 61429
// begin sort := SortBySkill ( tmp , 4 ) ;
61362: LD_ADDR_VAR 0 9
61366: PUSH
61367: LD_VAR 0 4
61371: PPUSH
61372: LD_INT 4
61374: PPUSH
61375: CALL 54293 0 2
61379: ST_TO_ADDR
// if sort then
61380: LD_VAR 0 9
61384: IFFALSE 61400
// p := sort [ 1 ] ;
61386: LD_ADDR_VAR 0 11
61390: PUSH
61391: LD_VAR 0 9
61395: PUSH
61396: LD_INT 1
61398: ARRAY
61399: ST_TO_ADDR
// if p then
61400: LD_VAR 0 11
61404: IFFALSE 61429
// result := Replace ( result , 4 , p ) ;
61406: LD_ADDR_VAR 0 2
61410: PUSH
61411: LD_VAR 0 2
61415: PPUSH
61416: LD_INT 4
61418: PPUSH
61419: LD_VAR 0 11
61423: PPUSH
61424: CALL_OW 1
61428: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61429: LD_ADDR_VAR 0 4
61433: PUSH
61434: LD_VAR 0 4
61438: PUSH
61439: LD_VAR 0 7
61443: DIFF
61444: ST_TO_ADDR
// if tmp and mech < 6 then
61445: LD_VAR 0 4
61449: PUSH
61450: LD_VAR 0 7
61454: PUSH
61455: LD_INT 6
61457: LESS
61458: AND
61459: IFFALSE 61618
// begin sort := SortBySkill ( tmp , 3 ) ;
61461: LD_ADDR_VAR 0 9
61465: PUSH
61466: LD_VAR 0 4
61470: PPUSH
61471: LD_INT 3
61473: PPUSH
61474: CALL 54293 0 2
61478: ST_TO_ADDR
// p := [ ] ;
61479: LD_ADDR_VAR 0 11
61483: PUSH
61484: EMPTY
61485: ST_TO_ADDR
// if sort then
61486: LD_VAR 0 9
61490: IFFALSE 61589
// for i = 1 to 6 - mech do
61492: LD_ADDR_VAR 0 3
61496: PUSH
61497: DOUBLE
61498: LD_INT 1
61500: DEC
61501: ST_TO_ADDR
61502: LD_INT 6
61504: PUSH
61505: LD_VAR 0 7
61509: MINUS
61510: PUSH
61511: FOR_TO
61512: IFFALSE 61587
// begin if i = sort then
61514: LD_VAR 0 3
61518: PUSH
61519: LD_VAR 0 9
61523: EQUAL
61524: IFFALSE 61528
// break ;
61526: GO 61587
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61528: LD_ADDR_VAR 0 11
61532: PUSH
61533: LD_VAR 0 11
61537: PPUSH
61538: LD_VAR 0 11
61542: PUSH
61543: LD_INT 1
61545: PLUS
61546: PPUSH
61547: LD_VAR 0 9
61551: PUSH
61552: LD_VAR 0 3
61556: ARRAY
61557: PPUSH
61558: CALL_OW 2
61562: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61563: LD_ADDR_VAR 0 4
61567: PUSH
61568: LD_VAR 0 4
61572: PUSH
61573: LD_VAR 0 9
61577: PUSH
61578: LD_VAR 0 3
61582: ARRAY
61583: DIFF
61584: ST_TO_ADDR
// end ;
61585: GO 61511
61587: POP
61588: POP
// if p then
61589: LD_VAR 0 11
61593: IFFALSE 61618
// result := Replace ( result , 3 , p ) ;
61595: LD_ADDR_VAR 0 2
61599: PUSH
61600: LD_VAR 0 2
61604: PPUSH
61605: LD_INT 3
61607: PPUSH
61608: LD_VAR 0 11
61612: PPUSH
61613: CALL_OW 1
61617: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61618: LD_ADDR_VAR 0 4
61622: PUSH
61623: LD_VAR 0 4
61627: PUSH
61628: LD_VAR 0 6
61632: DIFF
61633: ST_TO_ADDR
// if tmp and eng < 6 then
61634: LD_VAR 0 4
61638: PUSH
61639: LD_VAR 0 6
61643: PUSH
61644: LD_INT 6
61646: LESS
61647: AND
61648: IFFALSE 61807
// begin sort := SortBySkill ( tmp , 2 ) ;
61650: LD_ADDR_VAR 0 9
61654: PUSH
61655: LD_VAR 0 4
61659: PPUSH
61660: LD_INT 2
61662: PPUSH
61663: CALL 54293 0 2
61667: ST_TO_ADDR
// p := [ ] ;
61668: LD_ADDR_VAR 0 11
61672: PUSH
61673: EMPTY
61674: ST_TO_ADDR
// if sort then
61675: LD_VAR 0 9
61679: IFFALSE 61778
// for i = 1 to 6 - eng do
61681: LD_ADDR_VAR 0 3
61685: PUSH
61686: DOUBLE
61687: LD_INT 1
61689: DEC
61690: ST_TO_ADDR
61691: LD_INT 6
61693: PUSH
61694: LD_VAR 0 6
61698: MINUS
61699: PUSH
61700: FOR_TO
61701: IFFALSE 61776
// begin if i = sort then
61703: LD_VAR 0 3
61707: PUSH
61708: LD_VAR 0 9
61712: EQUAL
61713: IFFALSE 61717
// break ;
61715: GO 61776
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61717: LD_ADDR_VAR 0 11
61721: PUSH
61722: LD_VAR 0 11
61726: PPUSH
61727: LD_VAR 0 11
61731: PUSH
61732: LD_INT 1
61734: PLUS
61735: PPUSH
61736: LD_VAR 0 9
61740: PUSH
61741: LD_VAR 0 3
61745: ARRAY
61746: PPUSH
61747: CALL_OW 2
61751: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61752: LD_ADDR_VAR 0 4
61756: PUSH
61757: LD_VAR 0 4
61761: PUSH
61762: LD_VAR 0 9
61766: PUSH
61767: LD_VAR 0 3
61771: ARRAY
61772: DIFF
61773: ST_TO_ADDR
// end ;
61774: GO 61700
61776: POP
61777: POP
// if p then
61778: LD_VAR 0 11
61782: IFFALSE 61807
// result := Replace ( result , 2 , p ) ;
61784: LD_ADDR_VAR 0 2
61788: PUSH
61789: LD_VAR 0 2
61793: PPUSH
61794: LD_INT 2
61796: PPUSH
61797: LD_VAR 0 11
61801: PPUSH
61802: CALL_OW 1
61806: ST_TO_ADDR
// end ; exit ;
61807: GO 62479
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61809: LD_EXP 85
61813: PUSH
61814: LD_EXP 84
61818: PUSH
61819: LD_VAR 0 1
61823: ARRAY
61824: ARRAY
61825: NOT
61826: PUSH
61827: LD_EXP 58
61831: PUSH
61832: LD_VAR 0 1
61836: ARRAY
61837: PPUSH
61838: LD_INT 30
61840: PUSH
61841: LD_INT 3
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: PPUSH
61848: CALL_OW 72
61852: AND
61853: PUSH
61854: LD_EXP 63
61858: PUSH
61859: LD_VAR 0 1
61863: ARRAY
61864: NOT
61865: AND
61866: IFFALSE 62479
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
61868: LD_ADDR_EXP 100
61872: PUSH
61873: LD_EXP 100
61877: PPUSH
61878: LD_VAR 0 1
61882: PPUSH
61883: LD_INT 6
61885: PPUSH
61886: CALL_OW 1
61890: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61891: LD_ADDR_VAR 0 2
61895: PUSH
61896: LD_INT 0
61898: PUSH
61899: LD_INT 0
61901: PUSH
61902: LD_INT 0
61904: PUSH
61905: LD_INT 0
61907: PUSH
61908: EMPTY
61909: LIST
61910: LIST
61911: LIST
61912: LIST
61913: ST_TO_ADDR
// if sci >= 1 then
61914: LD_VAR 0 8
61918: PUSH
61919: LD_INT 1
61921: GREATEREQUAL
61922: IFFALSE 61944
// tmp := tmp diff sci [ 1 ] ;
61924: LD_ADDR_VAR 0 4
61928: PUSH
61929: LD_VAR 0 4
61933: PUSH
61934: LD_VAR 0 8
61938: PUSH
61939: LD_INT 1
61941: ARRAY
61942: DIFF
61943: ST_TO_ADDR
// if tmp and not sci then
61944: LD_VAR 0 4
61948: PUSH
61949: LD_VAR 0 8
61953: NOT
61954: AND
61955: IFFALSE 62024
// begin sort := SortBySkill ( tmp , 4 ) ;
61957: LD_ADDR_VAR 0 9
61961: PUSH
61962: LD_VAR 0 4
61966: PPUSH
61967: LD_INT 4
61969: PPUSH
61970: CALL 54293 0 2
61974: ST_TO_ADDR
// if sort then
61975: LD_VAR 0 9
61979: IFFALSE 61995
// p := sort [ 1 ] ;
61981: LD_ADDR_VAR 0 11
61985: PUSH
61986: LD_VAR 0 9
61990: PUSH
61991: LD_INT 1
61993: ARRAY
61994: ST_TO_ADDR
// if p then
61995: LD_VAR 0 11
61999: IFFALSE 62024
// result := Replace ( result , 4 , p ) ;
62001: LD_ADDR_VAR 0 2
62005: PUSH
62006: LD_VAR 0 2
62010: PPUSH
62011: LD_INT 4
62013: PPUSH
62014: LD_VAR 0 11
62018: PPUSH
62019: CALL_OW 1
62023: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62024: LD_ADDR_VAR 0 4
62028: PUSH
62029: LD_VAR 0 4
62033: PUSH
62034: LD_VAR 0 7
62038: DIFF
62039: ST_TO_ADDR
// if tmp and mech < 6 then
62040: LD_VAR 0 4
62044: PUSH
62045: LD_VAR 0 7
62049: PUSH
62050: LD_INT 6
62052: LESS
62053: AND
62054: IFFALSE 62213
// begin sort := SortBySkill ( tmp , 3 ) ;
62056: LD_ADDR_VAR 0 9
62060: PUSH
62061: LD_VAR 0 4
62065: PPUSH
62066: LD_INT 3
62068: PPUSH
62069: CALL 54293 0 2
62073: ST_TO_ADDR
// p := [ ] ;
62074: LD_ADDR_VAR 0 11
62078: PUSH
62079: EMPTY
62080: ST_TO_ADDR
// if sort then
62081: LD_VAR 0 9
62085: IFFALSE 62184
// for i = 1 to 6 - mech do
62087: LD_ADDR_VAR 0 3
62091: PUSH
62092: DOUBLE
62093: LD_INT 1
62095: DEC
62096: ST_TO_ADDR
62097: LD_INT 6
62099: PUSH
62100: LD_VAR 0 7
62104: MINUS
62105: PUSH
62106: FOR_TO
62107: IFFALSE 62182
// begin if i = sort then
62109: LD_VAR 0 3
62113: PUSH
62114: LD_VAR 0 9
62118: EQUAL
62119: IFFALSE 62123
// break ;
62121: GO 62182
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62123: LD_ADDR_VAR 0 11
62127: PUSH
62128: LD_VAR 0 11
62132: PPUSH
62133: LD_VAR 0 11
62137: PUSH
62138: LD_INT 1
62140: PLUS
62141: PPUSH
62142: LD_VAR 0 9
62146: PUSH
62147: LD_VAR 0 3
62151: ARRAY
62152: PPUSH
62153: CALL_OW 2
62157: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62158: LD_ADDR_VAR 0 4
62162: PUSH
62163: LD_VAR 0 4
62167: PUSH
62168: LD_VAR 0 9
62172: PUSH
62173: LD_VAR 0 3
62177: ARRAY
62178: DIFF
62179: ST_TO_ADDR
// end ;
62180: GO 62106
62182: POP
62183: POP
// if p then
62184: LD_VAR 0 11
62188: IFFALSE 62213
// result := Replace ( result , 3 , p ) ;
62190: LD_ADDR_VAR 0 2
62194: PUSH
62195: LD_VAR 0 2
62199: PPUSH
62200: LD_INT 3
62202: PPUSH
62203: LD_VAR 0 11
62207: PPUSH
62208: CALL_OW 1
62212: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62213: LD_ADDR_VAR 0 4
62217: PUSH
62218: LD_VAR 0 4
62222: PUSH
62223: LD_VAR 0 6
62227: DIFF
62228: ST_TO_ADDR
// if tmp and eng < 4 then
62229: LD_VAR 0 4
62233: PUSH
62234: LD_VAR 0 6
62238: PUSH
62239: LD_INT 4
62241: LESS
62242: AND
62243: IFFALSE 62404
// begin sort := SortBySkill ( tmp , 2 ) ;
62245: LD_ADDR_VAR 0 9
62249: PUSH
62250: LD_VAR 0 4
62254: PPUSH
62255: LD_INT 2
62257: PPUSH
62258: CALL 54293 0 2
62262: ST_TO_ADDR
// p := [ ] ;
62263: LD_ADDR_VAR 0 11
62267: PUSH
62268: EMPTY
62269: ST_TO_ADDR
// if sort then
62270: LD_VAR 0 9
62274: IFFALSE 62373
// for i = 1 to 4 - eng do
62276: LD_ADDR_VAR 0 3
62280: PUSH
62281: DOUBLE
62282: LD_INT 1
62284: DEC
62285: ST_TO_ADDR
62286: LD_INT 4
62288: PUSH
62289: LD_VAR 0 6
62293: MINUS
62294: PUSH
62295: FOR_TO
62296: IFFALSE 62371
// begin if i = sort then
62298: LD_VAR 0 3
62302: PUSH
62303: LD_VAR 0 9
62307: EQUAL
62308: IFFALSE 62312
// break ;
62310: GO 62371
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62312: LD_ADDR_VAR 0 11
62316: PUSH
62317: LD_VAR 0 11
62321: PPUSH
62322: LD_VAR 0 11
62326: PUSH
62327: LD_INT 1
62329: PLUS
62330: PPUSH
62331: LD_VAR 0 9
62335: PUSH
62336: LD_VAR 0 3
62340: ARRAY
62341: PPUSH
62342: CALL_OW 2
62346: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62347: LD_ADDR_VAR 0 4
62351: PUSH
62352: LD_VAR 0 4
62356: PUSH
62357: LD_VAR 0 9
62361: PUSH
62362: LD_VAR 0 3
62366: ARRAY
62367: DIFF
62368: ST_TO_ADDR
// end ;
62369: GO 62295
62371: POP
62372: POP
// if p then
62373: LD_VAR 0 11
62377: IFFALSE 62402
// result := Replace ( result , 2 , p ) ;
62379: LD_ADDR_VAR 0 2
62383: PUSH
62384: LD_VAR 0 2
62388: PPUSH
62389: LD_INT 2
62391: PPUSH
62392: LD_VAR 0 11
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// end else
62402: GO 62448
// for i = eng downto 5 do
62404: LD_ADDR_VAR 0 3
62408: PUSH
62409: DOUBLE
62410: LD_VAR 0 6
62414: INC
62415: ST_TO_ADDR
62416: LD_INT 5
62418: PUSH
62419: FOR_DOWNTO
62420: IFFALSE 62446
// tmp := tmp union eng [ i ] ;
62422: LD_ADDR_VAR 0 4
62426: PUSH
62427: LD_VAR 0 4
62431: PUSH
62432: LD_VAR 0 6
62436: PUSH
62437: LD_VAR 0 3
62441: ARRAY
62442: UNION
62443: ST_TO_ADDR
62444: GO 62419
62446: POP
62447: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62448: LD_ADDR_VAR 0 2
62452: PUSH
62453: LD_VAR 0 2
62457: PPUSH
62458: LD_INT 1
62460: PPUSH
62461: LD_VAR 0 4
62465: PUSH
62466: LD_VAR 0 5
62470: DIFF
62471: PPUSH
62472: CALL_OW 1
62476: ST_TO_ADDR
// exit ;
62477: GO 62479
// end ; end ;
62479: LD_VAR 0 2
62483: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62484: LD_INT 0
62486: PPUSH
62487: PPUSH
62488: PPUSH
// if not mc_bases then
62489: LD_EXP 58
62493: NOT
62494: IFFALSE 62498
// exit ;
62496: GO 62604
// for i = 1 to mc_bases do
62498: LD_ADDR_VAR 0 2
62502: PUSH
62503: DOUBLE
62504: LD_INT 1
62506: DEC
62507: ST_TO_ADDR
62508: LD_EXP 58
62512: PUSH
62513: FOR_TO
62514: IFFALSE 62595
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62516: LD_ADDR_VAR 0 3
62520: PUSH
62521: LD_EXP 58
62525: PUSH
62526: LD_VAR 0 2
62530: ARRAY
62531: PPUSH
62532: LD_INT 21
62534: PUSH
62535: LD_INT 3
62537: PUSH
62538: EMPTY
62539: LIST
62540: LIST
62541: PUSH
62542: LD_INT 3
62544: PUSH
62545: LD_INT 24
62547: PUSH
62548: LD_INT 1000
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: EMPTY
62556: LIST
62557: LIST
62558: PUSH
62559: EMPTY
62560: LIST
62561: LIST
62562: PPUSH
62563: CALL_OW 72
62567: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62568: LD_ADDR_EXP 59
62572: PUSH
62573: LD_EXP 59
62577: PPUSH
62578: LD_VAR 0 2
62582: PPUSH
62583: LD_VAR 0 3
62587: PPUSH
62588: CALL_OW 1
62592: ST_TO_ADDR
// end ;
62593: GO 62513
62595: POP
62596: POP
// RaiseSailEvent ( 101 ) ;
62597: LD_INT 101
62599: PPUSH
62600: CALL_OW 427
// end ;
62604: LD_VAR 0 1
62608: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62609: LD_INT 0
62611: PPUSH
62612: PPUSH
62613: PPUSH
62614: PPUSH
62615: PPUSH
62616: PPUSH
62617: PPUSH
// if not mc_bases then
62618: LD_EXP 58
62622: NOT
62623: IFFALSE 62627
// exit ;
62625: GO 63162
// for i = 1 to mc_bases do
62627: LD_ADDR_VAR 0 2
62631: PUSH
62632: DOUBLE
62633: LD_INT 1
62635: DEC
62636: ST_TO_ADDR
62637: LD_EXP 58
62641: PUSH
62642: FOR_TO
62643: IFFALSE 63153
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
62645: LD_ADDR_VAR 0 5
62649: PUSH
62650: LD_EXP 58
62654: PUSH
62655: LD_VAR 0 2
62659: ARRAY
62660: PUSH
62661: LD_EXP 87
62665: PUSH
62666: LD_VAR 0 2
62670: ARRAY
62671: UNION
62672: PPUSH
62673: LD_INT 21
62675: PUSH
62676: LD_INT 1
62678: PUSH
62679: EMPTY
62680: LIST
62681: LIST
62682: PUSH
62683: LD_INT 1
62685: PUSH
62686: LD_INT 3
62688: PUSH
62689: LD_INT 54
62691: PUSH
62692: EMPTY
62693: LIST
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: PUSH
62699: LD_INT 3
62701: PUSH
62702: LD_INT 24
62704: PUSH
62705: LD_INT 700
62707: PUSH
62708: EMPTY
62709: LIST
62710: LIST
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PUSH
62716: EMPTY
62717: LIST
62718: LIST
62719: LIST
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: PPUSH
62725: CALL_OW 72
62729: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62730: LD_ADDR_VAR 0 6
62734: PUSH
62735: LD_EXP 58
62739: PUSH
62740: LD_VAR 0 2
62744: ARRAY
62745: PPUSH
62746: LD_INT 21
62748: PUSH
62749: LD_INT 1
62751: PUSH
62752: EMPTY
62753: LIST
62754: LIST
62755: PUSH
62756: LD_INT 1
62758: PUSH
62759: LD_INT 3
62761: PUSH
62762: LD_INT 54
62764: PUSH
62765: EMPTY
62766: LIST
62767: PUSH
62768: EMPTY
62769: LIST
62770: LIST
62771: PUSH
62772: LD_INT 3
62774: PUSH
62775: LD_INT 24
62777: PUSH
62778: LD_INT 250
62780: PUSH
62781: EMPTY
62782: LIST
62783: LIST
62784: PUSH
62785: EMPTY
62786: LIST
62787: LIST
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: LIST
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PPUSH
62798: CALL_OW 72
62802: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
62803: LD_ADDR_VAR 0 7
62807: PUSH
62808: LD_VAR 0 5
62812: PUSH
62813: LD_VAR 0 6
62817: DIFF
62818: ST_TO_ADDR
// if not need_heal_1 then
62819: LD_VAR 0 6
62823: NOT
62824: IFFALSE 62857
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , [ ] ) else
62826: LD_ADDR_EXP 61
62830: PUSH
62831: LD_EXP 61
62835: PPUSH
62836: LD_VAR 0 2
62840: PUSH
62841: LD_INT 1
62843: PUSH
62844: EMPTY
62845: LIST
62846: LIST
62847: PPUSH
62848: EMPTY
62849: PPUSH
62850: CALL 20697 0 3
62854: ST_TO_ADDR
62855: GO 62889
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , need_heal_1 ) ;
62857: LD_ADDR_EXP 61
62861: PUSH
62862: LD_EXP 61
62866: PPUSH
62867: LD_VAR 0 2
62871: PUSH
62872: LD_INT 1
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PPUSH
62879: LD_VAR 0 6
62883: PPUSH
62884: CALL 20697 0 3
62888: ST_TO_ADDR
// if not need_heal_2 then
62889: LD_VAR 0 7
62893: NOT
62894: IFFALSE 62927
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , [ ] ) else
62896: LD_ADDR_EXP 61
62900: PUSH
62901: LD_EXP 61
62905: PPUSH
62906: LD_VAR 0 2
62910: PUSH
62911: LD_INT 2
62913: PUSH
62914: EMPTY
62915: LIST
62916: LIST
62917: PPUSH
62918: EMPTY
62919: PPUSH
62920: CALL 20697 0 3
62924: ST_TO_ADDR
62925: GO 62959
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
62927: LD_ADDR_EXP 61
62931: PUSH
62932: LD_EXP 61
62936: PPUSH
62937: LD_VAR 0 2
62941: PUSH
62942: LD_INT 2
62944: PUSH
62945: EMPTY
62946: LIST
62947: LIST
62948: PPUSH
62949: LD_VAR 0 7
62953: PPUSH
62954: CALL 20697 0 3
62958: ST_TO_ADDR
// if need_heal_2 then
62959: LD_VAR 0 7
62963: IFFALSE 63135
// for j in need_heal_2 do
62965: LD_ADDR_VAR 0 3
62969: PUSH
62970: LD_VAR 0 7
62974: PUSH
62975: FOR_IN
62976: IFFALSE 63133
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
62978: LD_ADDR_VAR 0 5
62982: PUSH
62983: LD_EXP 58
62987: PUSH
62988: LD_VAR 0 2
62992: ARRAY
62993: PPUSH
62994: LD_INT 2
62996: PUSH
62997: LD_INT 30
62999: PUSH
63000: LD_INT 6
63002: PUSH
63003: EMPTY
63004: LIST
63005: LIST
63006: PUSH
63007: LD_INT 30
63009: PUSH
63010: LD_INT 7
63012: PUSH
63013: EMPTY
63014: LIST
63015: LIST
63016: PUSH
63017: LD_INT 30
63019: PUSH
63020: LD_INT 8
63022: PUSH
63023: EMPTY
63024: LIST
63025: LIST
63026: PUSH
63027: LD_INT 30
63029: PUSH
63030: LD_INT 0
63032: PUSH
63033: EMPTY
63034: LIST
63035: LIST
63036: PUSH
63037: LD_INT 30
63039: PUSH
63040: LD_INT 1
63042: PUSH
63043: EMPTY
63044: LIST
63045: LIST
63046: PUSH
63047: LD_INT 25
63049: PUSH
63050: LD_INT 4
63052: PUSH
63053: EMPTY
63054: LIST
63055: LIST
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: LIST
63061: LIST
63062: LIST
63063: LIST
63064: LIST
63065: PPUSH
63066: CALL_OW 72
63070: ST_TO_ADDR
// if tmp then
63071: LD_VAR 0 5
63075: IFFALSE 63131
// begin k := NearestUnitToUnit ( tmp , j ) ;
63077: LD_ADDR_VAR 0 4
63081: PUSH
63082: LD_VAR 0 5
63086: PPUSH
63087: LD_VAR 0 3
63091: PPUSH
63092: CALL_OW 74
63096: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
63097: LD_VAR 0 3
63101: PPUSH
63102: LD_VAR 0 4
63106: PPUSH
63107: CALL_OW 296
63111: PUSH
63112: LD_INT 7
63114: GREATER
63115: IFFALSE 63131
// ComMoveUnit ( j , k ) ;
63117: LD_VAR 0 3
63121: PPUSH
63122: LD_VAR 0 4
63126: PPUSH
63127: CALL_OW 112
// end ; end ;
63131: GO 62975
63133: POP
63134: POP
// if not need_heal_1 and not need_heal_2 then
63135: LD_VAR 0 6
63139: NOT
63140: PUSH
63141: LD_VAR 0 7
63145: NOT
63146: AND
63147: IFFALSE 63151
// continue ;
63149: GO 62642
// end ;
63151: GO 62642
63153: POP
63154: POP
// RaiseSailEvent ( 102 ) ;
63155: LD_INT 102
63157: PPUSH
63158: CALL_OW 427
// end ;
63162: LD_VAR 0 1
63166: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
63167: LD_INT 0
63169: PPUSH
63170: PPUSH
63171: PPUSH
63172: PPUSH
63173: PPUSH
// if not mc_bases then
63174: LD_EXP 58
63178: NOT
63179: IFFALSE 63183
// exit ;
63181: GO 63568
// for i = 1 to mc_bases do
63183: LD_ADDR_VAR 0 2
63187: PUSH
63188: DOUBLE
63189: LD_INT 1
63191: DEC
63192: ST_TO_ADDR
63193: LD_EXP 58
63197: PUSH
63198: FOR_TO
63199: IFFALSE 63566
// begin if not mc_building_need_repair [ i ] then
63201: LD_EXP 59
63205: PUSH
63206: LD_VAR 0 2
63210: ARRAY
63211: NOT
63212: IFFALSE 63250
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63214: LD_ADDR_EXP 60
63218: PUSH
63219: LD_EXP 60
63223: PPUSH
63224: LD_VAR 0 2
63228: PPUSH
63229: EMPTY
63230: PPUSH
63231: CALL_OW 1
63235: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63236: LD_VAR 0 2
63240: PPUSH
63241: LD_INT 101
63243: PPUSH
63244: CALL 58649 0 2
// continue ;
63248: GO 63198
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63250: LD_ADDR_EXP 64
63254: PUSH
63255: LD_EXP 64
63259: PPUSH
63260: LD_VAR 0 2
63264: PPUSH
63265: EMPTY
63266: PPUSH
63267: CALL_OW 1
63271: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63272: LD_VAR 0 2
63276: PPUSH
63277: LD_INT 103
63279: PPUSH
63280: CALL 58649 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63284: LD_ADDR_VAR 0 5
63288: PUSH
63289: LD_EXP 58
63293: PUSH
63294: LD_VAR 0 2
63298: ARRAY
63299: PUSH
63300: LD_EXP 87
63304: PUSH
63305: LD_VAR 0 2
63309: ARRAY
63310: UNION
63311: PPUSH
63312: LD_INT 2
63314: PUSH
63315: LD_INT 25
63317: PUSH
63318: LD_INT 2
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 25
63327: PUSH
63328: LD_INT 16
63330: PUSH
63331: EMPTY
63332: LIST
63333: LIST
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: LIST
63339: PUSH
63340: EMPTY
63341: LIST
63342: PPUSH
63343: CALL_OW 72
63347: ST_TO_ADDR
// if not tmp then
63348: LD_VAR 0 5
63352: NOT
63353: IFFALSE 63357
// continue ;
63355: GO 63198
// for j in tmp do
63357: LD_ADDR_VAR 0 3
63361: PUSH
63362: LD_VAR 0 5
63366: PUSH
63367: FOR_IN
63368: IFFALSE 63562
// begin if mc_need_heal [ i ] then
63370: LD_EXP 61
63374: PUSH
63375: LD_VAR 0 2
63379: ARRAY
63380: IFFALSE 63428
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
63382: LD_VAR 0 3
63386: PUSH
63387: LD_EXP 61
63391: PUSH
63392: LD_VAR 0 2
63396: ARRAY
63397: PUSH
63398: LD_INT 1
63400: ARRAY
63401: IN
63402: PUSH
63403: LD_VAR 0 3
63407: PUSH
63408: LD_EXP 61
63412: PUSH
63413: LD_VAR 0 2
63417: ARRAY
63418: PUSH
63419: LD_INT 2
63421: ARRAY
63422: IN
63423: OR
63424: IFFALSE 63428
// continue ;
63426: GO 63367
// if IsInUnit ( j ) then
63428: LD_VAR 0 3
63432: PPUSH
63433: CALL_OW 310
63437: IFFALSE 63448
// ComExitBuilding ( j ) ;
63439: LD_VAR 0 3
63443: PPUSH
63444: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
63448: LD_VAR 0 3
63452: PUSH
63453: LD_EXP 60
63457: PUSH
63458: LD_VAR 0 2
63462: ARRAY
63463: IN
63464: NOT
63465: IFFALSE 63523
// begin SetTag ( j , 101 ) ;
63467: LD_VAR 0 3
63471: PPUSH
63472: LD_INT 101
63474: PPUSH
63475: CALL_OW 109
// mc_building_repairs := Add ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
63479: LD_ADDR_EXP 60
63483: PUSH
63484: LD_EXP 60
63488: PPUSH
63489: LD_VAR 0 2
63493: PUSH
63494: LD_EXP 60
63498: PUSH
63499: LD_VAR 0 2
63503: ARRAY
63504: PUSH
63505: LD_INT 1
63507: PLUS
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PPUSH
63513: LD_VAR 0 3
63517: PPUSH
63518: CALL 20697 0 3
63522: ST_TO_ADDR
// end ; Wait ( 3 ) ;
63523: LD_INT 3
63525: PPUSH
63526: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
63530: LD_VAR 0 3
63534: PPUSH
63535: LD_EXP 59
63539: PUSH
63540: LD_VAR 0 2
63544: ARRAY
63545: PPUSH
63546: LD_VAR 0 3
63550: PPUSH
63551: CALL_OW 74
63555: PPUSH
63556: CALL_OW 130
// end ;
63560: GO 63367
63562: POP
63563: POP
// end ;
63564: GO 63198
63566: POP
63567: POP
// end ;
63568: LD_VAR 0 1
63572: RET
// export function MC_Heal ; var i , j , tmp ; begin
63573: LD_INT 0
63575: PPUSH
63576: PPUSH
63577: PPUSH
63578: PPUSH
// if not mc_bases then
63579: LD_EXP 58
63583: NOT
63584: IFFALSE 63588
// exit ;
63586: GO 63990
// for i = 1 to mc_bases do
63588: LD_ADDR_VAR 0 2
63592: PUSH
63593: DOUBLE
63594: LD_INT 1
63596: DEC
63597: ST_TO_ADDR
63598: LD_EXP 58
63602: PUSH
63603: FOR_TO
63604: IFFALSE 63988
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
63606: LD_EXP 61
63610: PUSH
63611: LD_VAR 0 2
63615: ARRAY
63616: PUSH
63617: LD_INT 1
63619: ARRAY
63620: NOT
63621: PUSH
63622: LD_EXP 61
63626: PUSH
63627: LD_VAR 0 2
63631: ARRAY
63632: PUSH
63633: LD_INT 2
63635: ARRAY
63636: NOT
63637: AND
63638: IFFALSE 63676
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
63640: LD_ADDR_EXP 62
63644: PUSH
63645: LD_EXP 62
63649: PPUSH
63650: LD_VAR 0 2
63654: PPUSH
63655: EMPTY
63656: PPUSH
63657: CALL_OW 1
63661: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
63662: LD_VAR 0 2
63666: PPUSH
63667: LD_INT 102
63669: PPUSH
63670: CALL 58649 0 2
// continue ;
63674: GO 63603
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
63676: LD_ADDR_VAR 0 4
63680: PUSH
63681: LD_EXP 58
63685: PUSH
63686: LD_VAR 0 2
63690: ARRAY
63691: PPUSH
63692: LD_INT 25
63694: PUSH
63695: LD_INT 4
63697: PUSH
63698: EMPTY
63699: LIST
63700: LIST
63701: PPUSH
63702: CALL_OW 72
63706: ST_TO_ADDR
// if not tmp then
63707: LD_VAR 0 4
63711: NOT
63712: IFFALSE 63716
// continue ;
63714: GO 63603
// if mc_taming [ i ] then
63716: LD_EXP 89
63720: PUSH
63721: LD_VAR 0 2
63725: ARRAY
63726: IFFALSE 63750
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63728: LD_ADDR_EXP 89
63732: PUSH
63733: LD_EXP 89
63737: PPUSH
63738: LD_VAR 0 2
63742: PPUSH
63743: EMPTY
63744: PPUSH
63745: CALL_OW 1
63749: ST_TO_ADDR
// for j in tmp do
63750: LD_ADDR_VAR 0 3
63754: PUSH
63755: LD_VAR 0 4
63759: PUSH
63760: FOR_IN
63761: IFFALSE 63984
// begin if IsInUnit ( j ) then
63763: LD_VAR 0 3
63767: PPUSH
63768: CALL_OW 310
63772: IFFALSE 63783
// ComExitBuilding ( j ) ;
63774: LD_VAR 0 3
63778: PPUSH
63779: CALL_OW 122
// if not j in mc_healers [ i ] then
63783: LD_VAR 0 3
63787: PUSH
63788: LD_EXP 62
63792: PUSH
63793: LD_VAR 0 2
63797: ARRAY
63798: IN
63799: NOT
63800: IFFALSE 63846
// mc_healers := Add ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
63802: LD_ADDR_EXP 62
63806: PUSH
63807: LD_EXP 62
63811: PPUSH
63812: LD_VAR 0 2
63816: PUSH
63817: LD_EXP 62
63821: PUSH
63822: LD_VAR 0 2
63826: ARRAY
63827: PUSH
63828: LD_INT 1
63830: PLUS
63831: PUSH
63832: EMPTY
63833: LIST
63834: LIST
63835: PPUSH
63836: LD_VAR 0 3
63840: PPUSH
63841: CALL 20697 0 3
63845: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
63846: LD_VAR 0 3
63850: PPUSH
63851: CALL_OW 110
63855: PUSH
63856: LD_INT 102
63858: NONEQUAL
63859: IFFALSE 63873
// SetTag ( j , 102 ) ;
63861: LD_VAR 0 3
63865: PPUSH
63866: LD_INT 102
63868: PPUSH
63869: CALL_OW 109
// Wait ( 3 ) ;
63873: LD_INT 3
63875: PPUSH
63876: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
63880: LD_EXP 61
63884: PUSH
63885: LD_VAR 0 2
63889: ARRAY
63890: PUSH
63891: LD_INT 1
63893: ARRAY
63894: IFFALSE 63926
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
63896: LD_VAR 0 3
63900: PPUSH
63901: LD_EXP 61
63905: PUSH
63906: LD_VAR 0 2
63910: ARRAY
63911: PUSH
63912: LD_INT 1
63914: ARRAY
63915: PUSH
63916: LD_INT 1
63918: ARRAY
63919: PPUSH
63920: CALL_OW 128
63924: GO 63982
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
63926: LD_VAR 0 3
63930: PPUSH
63931: CALL_OW 314
63935: NOT
63936: PUSH
63937: LD_EXP 61
63941: PUSH
63942: LD_VAR 0 2
63946: ARRAY
63947: PUSH
63948: LD_INT 2
63950: ARRAY
63951: AND
63952: IFFALSE 63982
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
63954: LD_VAR 0 3
63958: PPUSH
63959: LD_EXP 61
63963: PUSH
63964: LD_VAR 0 2
63968: ARRAY
63969: PUSH
63970: LD_INT 2
63972: ARRAY
63973: PUSH
63974: LD_INT 1
63976: ARRAY
63977: PPUSH
63978: CALL_OW 128
// end ;
63982: GO 63760
63984: POP
63985: POP
// end ;
63986: GO 63603
63988: POP
63989: POP
// end ;
63990: LD_VAR 0 1
63994: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
63995: LD_INT 0
63997: PPUSH
63998: PPUSH
63999: PPUSH
64000: PPUSH
64001: PPUSH
// if not mc_bases then
64002: LD_EXP 58
64006: NOT
64007: IFFALSE 64011
// exit ;
64009: GO 65154
// for i = 1 to mc_bases do
64011: LD_ADDR_VAR 0 2
64015: PUSH
64016: DOUBLE
64017: LD_INT 1
64019: DEC
64020: ST_TO_ADDR
64021: LD_EXP 58
64025: PUSH
64026: FOR_TO
64027: IFFALSE 65152
// begin if mc_scan [ i ] then
64029: LD_EXP 81
64033: PUSH
64034: LD_VAR 0 2
64038: ARRAY
64039: IFFALSE 64043
// continue ;
64041: GO 64026
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64043: LD_EXP 63
64047: PUSH
64048: LD_VAR 0 2
64052: ARRAY
64053: NOT
64054: PUSH
64055: LD_EXP 65
64059: PUSH
64060: LD_VAR 0 2
64064: ARRAY
64065: NOT
64066: AND
64067: PUSH
64068: LD_EXP 64
64072: PUSH
64073: LD_VAR 0 2
64077: ARRAY
64078: AND
64079: IFFALSE 64117
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64081: LD_ADDR_EXP 64
64085: PUSH
64086: LD_EXP 64
64090: PPUSH
64091: LD_VAR 0 2
64095: PPUSH
64096: EMPTY
64097: PPUSH
64098: CALL_OW 1
64102: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64103: LD_VAR 0 2
64107: PPUSH
64108: LD_INT 103
64110: PPUSH
64111: CALL 58649 0 2
// continue ;
64115: GO 64026
// end ; if mc_construct_list [ i ] then
64117: LD_EXP 65
64121: PUSH
64122: LD_VAR 0 2
64126: ARRAY
64127: IFFALSE 64347
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64129: LD_ADDR_VAR 0 4
64133: PUSH
64134: LD_EXP 58
64138: PUSH
64139: LD_VAR 0 2
64143: ARRAY
64144: PPUSH
64145: LD_INT 25
64147: PUSH
64148: LD_INT 2
64150: PUSH
64151: EMPTY
64152: LIST
64153: LIST
64154: PPUSH
64155: CALL_OW 72
64159: PUSH
64160: LD_EXP 60
64164: PUSH
64165: LD_VAR 0 2
64169: ARRAY
64170: DIFF
64171: ST_TO_ADDR
// if not tmp then
64172: LD_VAR 0 4
64176: NOT
64177: IFFALSE 64181
// continue ;
64179: GO 64026
// for j in tmp do
64181: LD_ADDR_VAR 0 3
64185: PUSH
64186: LD_VAR 0 4
64190: PUSH
64191: FOR_IN
64192: IFFALSE 64343
// begin if not mc_builders [ i ] then
64194: LD_EXP 64
64198: PUSH
64199: LD_VAR 0 2
64203: ARRAY
64204: NOT
64205: IFFALSE 64263
// begin SetTag ( j , 103 ) ;
64207: LD_VAR 0 3
64211: PPUSH
64212: LD_INT 103
64214: PPUSH
64215: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64219: LD_ADDR_EXP 64
64223: PUSH
64224: LD_EXP 64
64228: PPUSH
64229: LD_VAR 0 2
64233: PUSH
64234: LD_EXP 64
64238: PUSH
64239: LD_VAR 0 2
64243: ARRAY
64244: PUSH
64245: LD_INT 1
64247: PLUS
64248: PUSH
64249: EMPTY
64250: LIST
64251: LIST
64252: PPUSH
64253: LD_VAR 0 3
64257: PPUSH
64258: CALL 20697 0 3
64262: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64263: LD_VAR 0 3
64267: PPUSH
64268: CALL_OW 310
64272: IFFALSE 64283
// ComExitBuilding ( j ) ;
64274: LD_VAR 0 3
64278: PPUSH
64279: CALL_OW 122
// wait ( 3 ) ;
64283: LD_INT 3
64285: PPUSH
64286: CALL_OW 67
// if not mc_construct_list [ i ] then
64290: LD_EXP 65
64294: PUSH
64295: LD_VAR 0 2
64299: ARRAY
64300: NOT
64301: IFFALSE 64305
// break ;
64303: GO 64343
// if not HasTask ( j ) then
64305: LD_VAR 0 3
64309: PPUSH
64310: CALL_OW 314
64314: NOT
64315: IFFALSE 64341
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
64317: LD_VAR 0 3
64321: PPUSH
64322: LD_EXP 65
64326: PUSH
64327: LD_VAR 0 2
64331: ARRAY
64332: PUSH
64333: LD_INT 1
64335: ARRAY
64336: PPUSH
64337: CALL 23146 0 2
// end ;
64341: GO 64191
64343: POP
64344: POP
// end else
64345: GO 65150
// if mc_build_list [ i ] then
64347: LD_EXP 63
64351: PUSH
64352: LD_VAR 0 2
64356: ARRAY
64357: IFFALSE 65150
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64359: LD_ADDR_VAR 0 5
64363: PUSH
64364: LD_EXP 58
64368: PUSH
64369: LD_VAR 0 2
64373: ARRAY
64374: PPUSH
64375: LD_INT 2
64377: PUSH
64378: LD_INT 30
64380: PUSH
64381: LD_INT 0
64383: PUSH
64384: EMPTY
64385: LIST
64386: LIST
64387: PUSH
64388: LD_INT 30
64390: PUSH
64391: LD_INT 1
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: PUSH
64398: EMPTY
64399: LIST
64400: LIST
64401: LIST
64402: PPUSH
64403: CALL_OW 72
64407: ST_TO_ADDR
// if depot then
64408: LD_VAR 0 5
64412: IFFALSE 64430
// depot := depot [ 1 ] else
64414: LD_ADDR_VAR 0 5
64418: PUSH
64419: LD_VAR 0 5
64423: PUSH
64424: LD_INT 1
64426: ARRAY
64427: ST_TO_ADDR
64428: GO 64438
// depot := 0 ;
64430: LD_ADDR_VAR 0 5
64434: PUSH
64435: LD_INT 0
64437: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
64438: LD_EXP 63
64442: PUSH
64443: LD_VAR 0 2
64447: ARRAY
64448: PUSH
64449: LD_INT 1
64451: ARRAY
64452: PUSH
64453: LD_INT 1
64455: ARRAY
64456: PPUSH
64457: CALL 22976 0 1
64461: PUSH
64462: LD_EXP 58
64466: PUSH
64467: LD_VAR 0 2
64471: ARRAY
64472: PPUSH
64473: LD_INT 2
64475: PUSH
64476: LD_INT 30
64478: PUSH
64479: LD_INT 2
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 30
64488: PUSH
64489: LD_INT 3
64491: PUSH
64492: EMPTY
64493: LIST
64494: LIST
64495: PUSH
64496: EMPTY
64497: LIST
64498: LIST
64499: LIST
64500: PPUSH
64501: CALL_OW 72
64505: NOT
64506: AND
64507: IFFALSE 64612
// begin for j = 1 to mc_build_list [ i ] do
64509: LD_ADDR_VAR 0 3
64513: PUSH
64514: DOUBLE
64515: LD_INT 1
64517: DEC
64518: ST_TO_ADDR
64519: LD_EXP 63
64523: PUSH
64524: LD_VAR 0 2
64528: ARRAY
64529: PUSH
64530: FOR_TO
64531: IFFALSE 64610
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
64533: LD_EXP 63
64537: PUSH
64538: LD_VAR 0 2
64542: ARRAY
64543: PUSH
64544: LD_VAR 0 3
64548: ARRAY
64549: PUSH
64550: LD_INT 1
64552: ARRAY
64553: PUSH
64554: LD_INT 2
64556: EQUAL
64557: IFFALSE 64608
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
64559: LD_ADDR_EXP 63
64563: PUSH
64564: LD_EXP 63
64568: PPUSH
64569: LD_VAR 0 2
64573: PPUSH
64574: LD_EXP 63
64578: PUSH
64579: LD_VAR 0 2
64583: ARRAY
64584: PPUSH
64585: LD_VAR 0 3
64589: PPUSH
64590: LD_INT 1
64592: PPUSH
64593: LD_INT 0
64595: PPUSH
64596: CALL 19680 0 4
64600: PPUSH
64601: CALL_OW 1
64605: ST_TO_ADDR
// break ;
64606: GO 64610
// end ;
64608: GO 64530
64610: POP
64611: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
64612: LD_EXP 63
64616: PUSH
64617: LD_VAR 0 2
64621: ARRAY
64622: PUSH
64623: LD_INT 1
64625: ARRAY
64626: PUSH
64627: LD_INT 1
64629: ARRAY
64630: PUSH
64631: LD_INT 0
64633: EQUAL
64634: PUSH
64635: LD_VAR 0 5
64639: PUSH
64640: LD_VAR 0 5
64644: PPUSH
64645: LD_EXP 63
64649: PUSH
64650: LD_VAR 0 2
64654: ARRAY
64655: PUSH
64656: LD_INT 1
64658: ARRAY
64659: PUSH
64660: LD_INT 1
64662: ARRAY
64663: PPUSH
64664: LD_EXP 63
64668: PUSH
64669: LD_VAR 0 2
64673: ARRAY
64674: PUSH
64675: LD_INT 1
64677: ARRAY
64678: PUSH
64679: LD_INT 2
64681: ARRAY
64682: PPUSH
64683: LD_EXP 63
64687: PUSH
64688: LD_VAR 0 2
64692: ARRAY
64693: PUSH
64694: LD_INT 1
64696: ARRAY
64697: PUSH
64698: LD_INT 3
64700: ARRAY
64701: PPUSH
64702: LD_EXP 63
64706: PUSH
64707: LD_VAR 0 2
64711: ARRAY
64712: PUSH
64713: LD_INT 1
64715: ARRAY
64716: PUSH
64717: LD_INT 4
64719: ARRAY
64720: PPUSH
64721: CALL 27513 0 5
64725: AND
64726: OR
64727: IFFALSE 65008
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64729: LD_ADDR_VAR 0 4
64733: PUSH
64734: LD_EXP 58
64738: PUSH
64739: LD_VAR 0 2
64743: ARRAY
64744: PPUSH
64745: LD_INT 25
64747: PUSH
64748: LD_INT 2
64750: PUSH
64751: EMPTY
64752: LIST
64753: LIST
64754: PPUSH
64755: CALL_OW 72
64759: PUSH
64760: LD_EXP 60
64764: PUSH
64765: LD_VAR 0 2
64769: ARRAY
64770: DIFF
64771: ST_TO_ADDR
// if not tmp then
64772: LD_VAR 0 4
64776: NOT
64777: IFFALSE 64781
// continue ;
64779: GO 64026
// for j in tmp do
64781: LD_ADDR_VAR 0 3
64785: PUSH
64786: LD_VAR 0 4
64790: PUSH
64791: FOR_IN
64792: IFFALSE 65004
// begin if not mc_builders [ i ] then
64794: LD_EXP 64
64798: PUSH
64799: LD_VAR 0 2
64803: ARRAY
64804: NOT
64805: IFFALSE 64863
// begin SetTag ( j , 103 ) ;
64807: LD_VAR 0 3
64811: PPUSH
64812: LD_INT 103
64814: PPUSH
64815: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64819: LD_ADDR_EXP 64
64823: PUSH
64824: LD_EXP 64
64828: PPUSH
64829: LD_VAR 0 2
64833: PUSH
64834: LD_EXP 64
64838: PUSH
64839: LD_VAR 0 2
64843: ARRAY
64844: PUSH
64845: LD_INT 1
64847: PLUS
64848: PUSH
64849: EMPTY
64850: LIST
64851: LIST
64852: PPUSH
64853: LD_VAR 0 3
64857: PPUSH
64858: CALL 20697 0 3
64862: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
64863: LD_VAR 0 3
64867: PPUSH
64868: CALL_OW 310
64872: IFFALSE 64883
// ComExitBuilding ( j ) ;
64874: LD_VAR 0 3
64878: PPUSH
64879: CALL_OW 122
// wait ( 3 ) ;
64883: LD_INT 3
64885: PPUSH
64886: CALL_OW 67
// if not mc_build_list [ i ] then
64890: LD_EXP 63
64894: PUSH
64895: LD_VAR 0 2
64899: ARRAY
64900: NOT
64901: IFFALSE 64905
// break ;
64903: GO 65004
// if not HasTask ( j ) then
64905: LD_VAR 0 3
64909: PPUSH
64910: CALL_OW 314
64914: NOT
64915: IFFALSE 65002
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
64917: LD_VAR 0 3
64921: PPUSH
64922: LD_EXP 63
64926: PUSH
64927: LD_VAR 0 2
64931: ARRAY
64932: PUSH
64933: LD_INT 1
64935: ARRAY
64936: PUSH
64937: LD_INT 1
64939: ARRAY
64940: PPUSH
64941: LD_EXP 63
64945: PUSH
64946: LD_VAR 0 2
64950: ARRAY
64951: PUSH
64952: LD_INT 1
64954: ARRAY
64955: PUSH
64956: LD_INT 2
64958: ARRAY
64959: PPUSH
64960: LD_EXP 63
64964: PUSH
64965: LD_VAR 0 2
64969: ARRAY
64970: PUSH
64971: LD_INT 1
64973: ARRAY
64974: PUSH
64975: LD_INT 3
64977: ARRAY
64978: PPUSH
64979: LD_EXP 63
64983: PUSH
64984: LD_VAR 0 2
64988: ARRAY
64989: PUSH
64990: LD_INT 1
64992: ARRAY
64993: PUSH
64994: LD_INT 4
64996: ARRAY
64997: PPUSH
64998: CALL_OW 145
// end ;
65002: GO 64791
65004: POP
65005: POP
// end else
65006: GO 65150
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
65008: LD_EXP 58
65012: PUSH
65013: LD_VAR 0 2
65017: ARRAY
65018: PPUSH
65019: LD_EXP 63
65023: PUSH
65024: LD_VAR 0 2
65028: ARRAY
65029: PUSH
65030: LD_INT 1
65032: ARRAY
65033: PUSH
65034: LD_INT 1
65036: ARRAY
65037: PPUSH
65038: LD_EXP 63
65042: PUSH
65043: LD_VAR 0 2
65047: ARRAY
65048: PUSH
65049: LD_INT 1
65051: ARRAY
65052: PUSH
65053: LD_INT 2
65055: ARRAY
65056: PPUSH
65057: LD_EXP 63
65061: PUSH
65062: LD_VAR 0 2
65066: ARRAY
65067: PUSH
65068: LD_INT 1
65070: ARRAY
65071: PUSH
65072: LD_INT 3
65074: ARRAY
65075: PPUSH
65076: LD_EXP 63
65080: PUSH
65081: LD_VAR 0 2
65085: ARRAY
65086: PUSH
65087: LD_INT 1
65089: ARRAY
65090: PUSH
65091: LD_INT 4
65093: ARRAY
65094: PPUSH
65095: CALL 26944 0 5
65099: NOT
65100: IFFALSE 65150
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65102: LD_ADDR_EXP 63
65106: PUSH
65107: LD_EXP 63
65111: PPUSH
65112: LD_VAR 0 2
65116: PPUSH
65117: LD_EXP 63
65121: PUSH
65122: LD_VAR 0 2
65126: ARRAY
65127: PPUSH
65128: LD_INT 1
65130: PPUSH
65131: LD_INT 1
65133: NEG
65134: PPUSH
65135: LD_INT 0
65137: PPUSH
65138: CALL 19680 0 4
65142: PPUSH
65143: CALL_OW 1
65147: ST_TO_ADDR
// continue ;
65148: GO 64026
// end ; end ; end ;
65150: GO 64026
65152: POP
65153: POP
// end ;
65154: LD_VAR 0 1
65158: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65159: LD_INT 0
65161: PPUSH
65162: PPUSH
65163: PPUSH
65164: PPUSH
65165: PPUSH
65166: PPUSH
// if not mc_bases then
65167: LD_EXP 58
65171: NOT
65172: IFFALSE 65176
// exit ;
65174: GO 65603
// for i = 1 to mc_bases do
65176: LD_ADDR_VAR 0 2
65180: PUSH
65181: DOUBLE
65182: LD_INT 1
65184: DEC
65185: ST_TO_ADDR
65186: LD_EXP 58
65190: PUSH
65191: FOR_TO
65192: IFFALSE 65601
// begin tmp := mc_build_upgrade [ i ] ;
65194: LD_ADDR_VAR 0 4
65198: PUSH
65199: LD_EXP 90
65203: PUSH
65204: LD_VAR 0 2
65208: ARRAY
65209: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65210: LD_ADDR_VAR 0 6
65214: PUSH
65215: LD_EXP 91
65219: PUSH
65220: LD_VAR 0 2
65224: ARRAY
65225: PPUSH
65226: LD_INT 2
65228: PUSH
65229: LD_INT 30
65231: PUSH
65232: LD_INT 6
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: PUSH
65239: LD_INT 30
65241: PUSH
65242: LD_INT 7
65244: PUSH
65245: EMPTY
65246: LIST
65247: LIST
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: LIST
65253: PPUSH
65254: CALL_OW 72
65258: ST_TO_ADDR
// if not tmp and not lab then
65259: LD_VAR 0 4
65263: NOT
65264: PUSH
65265: LD_VAR 0 6
65269: NOT
65270: AND
65271: IFFALSE 65275
// continue ;
65273: GO 65191
// if tmp then
65275: LD_VAR 0 4
65279: IFFALSE 65399
// for j in tmp do
65281: LD_ADDR_VAR 0 3
65285: PUSH
65286: LD_VAR 0 4
65290: PUSH
65291: FOR_IN
65292: IFFALSE 65397
// begin if UpgradeCost ( j ) then
65294: LD_VAR 0 3
65298: PPUSH
65299: CALL 26604 0 1
65303: IFFALSE 65395
// begin ComUpgrade ( j ) ;
65305: LD_VAR 0 3
65309: PPUSH
65310: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
65314: LD_ADDR_EXP 90
65318: PUSH
65319: LD_EXP 90
65323: PPUSH
65324: LD_VAR 0 2
65328: PPUSH
65329: LD_EXP 90
65333: PUSH
65334: LD_VAR 0 2
65338: ARRAY
65339: PUSH
65340: LD_VAR 0 3
65344: DIFF
65345: PPUSH
65346: CALL_OW 1
65350: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65351: LD_ADDR_EXP 65
65355: PUSH
65356: LD_EXP 65
65360: PPUSH
65361: LD_VAR 0 2
65365: PUSH
65366: LD_EXP 65
65370: PUSH
65371: LD_VAR 0 2
65375: ARRAY
65376: PUSH
65377: LD_INT 1
65379: PLUS
65380: PUSH
65381: EMPTY
65382: LIST
65383: LIST
65384: PPUSH
65385: LD_VAR 0 3
65389: PPUSH
65390: CALL 20697 0 3
65394: ST_TO_ADDR
// end ; end ;
65395: GO 65291
65397: POP
65398: POP
// if not lab or not mc_lab_upgrade [ i ] then
65399: LD_VAR 0 6
65403: NOT
65404: PUSH
65405: LD_EXP 92
65409: PUSH
65410: LD_VAR 0 2
65414: ARRAY
65415: NOT
65416: OR
65417: IFFALSE 65421
// continue ;
65419: GO 65191
// for j in lab do
65421: LD_ADDR_VAR 0 3
65425: PUSH
65426: LD_VAR 0 6
65430: PUSH
65431: FOR_IN
65432: IFFALSE 65597
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
65434: LD_VAR 0 3
65438: PPUSH
65439: CALL_OW 266
65443: PUSH
65444: LD_INT 6
65446: PUSH
65447: LD_INT 7
65449: PUSH
65450: EMPTY
65451: LIST
65452: LIST
65453: IN
65454: PUSH
65455: LD_VAR 0 3
65459: PPUSH
65460: CALL_OW 461
65464: PUSH
65465: LD_INT 1
65467: NONEQUAL
65468: AND
65469: IFFALSE 65595
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
65471: LD_VAR 0 3
65475: PPUSH
65476: LD_EXP 92
65480: PUSH
65481: LD_VAR 0 2
65485: ARRAY
65486: PUSH
65487: LD_INT 1
65489: ARRAY
65490: PPUSH
65491: CALL 26809 0 2
65495: IFFALSE 65595
// begin ComCancel ( j ) ;
65497: LD_VAR 0 3
65501: PPUSH
65502: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
65506: LD_VAR 0 3
65510: PPUSH
65511: LD_EXP 92
65515: PUSH
65516: LD_VAR 0 2
65520: ARRAY
65521: PUSH
65522: LD_INT 1
65524: ARRAY
65525: PPUSH
65526: CALL_OW 207
// if not j in mc_construct_list [ i ] then
65530: LD_VAR 0 3
65534: PUSH
65535: LD_EXP 65
65539: PUSH
65540: LD_VAR 0 2
65544: ARRAY
65545: IN
65546: NOT
65547: IFFALSE 65593
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
65549: LD_ADDR_EXP 65
65553: PUSH
65554: LD_EXP 65
65558: PPUSH
65559: LD_VAR 0 2
65563: PUSH
65564: LD_EXP 65
65568: PUSH
65569: LD_VAR 0 2
65573: ARRAY
65574: PUSH
65575: LD_INT 1
65577: PLUS
65578: PUSH
65579: EMPTY
65580: LIST
65581: LIST
65582: PPUSH
65583: LD_VAR 0 3
65587: PPUSH
65588: CALL 20697 0 3
65592: ST_TO_ADDR
// break ;
65593: GO 65597
// end ; end ; end ;
65595: GO 65431
65597: POP
65598: POP
// end ;
65599: GO 65191
65601: POP
65602: POP
// end ;
65603: LD_VAR 0 1
65607: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
65608: LD_INT 0
65610: PPUSH
65611: PPUSH
65612: PPUSH
65613: PPUSH
65614: PPUSH
65615: PPUSH
65616: PPUSH
65617: PPUSH
65618: PPUSH
// if not mc_bases then
65619: LD_EXP 58
65623: NOT
65624: IFFALSE 65628
// exit ;
65626: GO 66033
// for i = 1 to mc_bases do
65628: LD_ADDR_VAR 0 2
65632: PUSH
65633: DOUBLE
65634: LD_INT 1
65636: DEC
65637: ST_TO_ADDR
65638: LD_EXP 58
65642: PUSH
65643: FOR_TO
65644: IFFALSE 66031
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
65646: LD_EXP 66
65650: PUSH
65651: LD_VAR 0 2
65655: ARRAY
65656: NOT
65657: PUSH
65658: LD_EXP 58
65662: PUSH
65663: LD_VAR 0 2
65667: ARRAY
65668: PPUSH
65669: LD_INT 30
65671: PUSH
65672: LD_INT 3
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PPUSH
65679: CALL_OW 72
65683: NOT
65684: OR
65685: IFFALSE 65689
// continue ;
65687: GO 65643
// busy := false ;
65689: LD_ADDR_VAR 0 8
65693: PUSH
65694: LD_INT 0
65696: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65697: LD_ADDR_VAR 0 4
65701: PUSH
65702: LD_EXP 58
65706: PUSH
65707: LD_VAR 0 2
65711: ARRAY
65712: PPUSH
65713: LD_INT 30
65715: PUSH
65716: LD_INT 3
65718: PUSH
65719: EMPTY
65720: LIST
65721: LIST
65722: PPUSH
65723: CALL_OW 72
65727: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
65728: LD_ADDR_VAR 0 6
65732: PUSH
65733: LD_EXP 66
65737: PUSH
65738: LD_VAR 0 2
65742: ARRAY
65743: PPUSH
65744: LD_INT 2
65746: PUSH
65747: LD_INT 30
65749: PUSH
65750: LD_INT 32
65752: PUSH
65753: EMPTY
65754: LIST
65755: LIST
65756: PUSH
65757: LD_INT 30
65759: PUSH
65760: LD_INT 33
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PUSH
65767: EMPTY
65768: LIST
65769: LIST
65770: LIST
65771: PPUSH
65772: CALL_OW 72
65776: ST_TO_ADDR
// if not t then
65777: LD_VAR 0 6
65781: NOT
65782: IFFALSE 65786
// continue ;
65784: GO 65643
// for j in tmp do
65786: LD_ADDR_VAR 0 3
65790: PUSH
65791: LD_VAR 0 4
65795: PUSH
65796: FOR_IN
65797: IFFALSE 65827
// if not BuildingStatus ( j ) = bs_idle then
65799: LD_VAR 0 3
65803: PPUSH
65804: CALL_OW 461
65808: PUSH
65809: LD_INT 2
65811: EQUAL
65812: NOT
65813: IFFALSE 65825
// begin busy := true ;
65815: LD_ADDR_VAR 0 8
65819: PUSH
65820: LD_INT 1
65822: ST_TO_ADDR
// break ;
65823: GO 65827
// end ;
65825: GO 65796
65827: POP
65828: POP
// if busy then
65829: LD_VAR 0 8
65833: IFFALSE 65837
// continue ;
65835: GO 65643
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
65837: LD_ADDR_VAR 0 7
65841: PUSH
65842: LD_VAR 0 6
65846: PPUSH
65847: LD_INT 35
65849: PUSH
65850: LD_INT 0
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PPUSH
65857: CALL_OW 72
65861: ST_TO_ADDR
// if tw then
65862: LD_VAR 0 7
65866: IFFALSE 65943
// begin tw := tw [ 1 ] ;
65868: LD_ADDR_VAR 0 7
65872: PUSH
65873: LD_VAR 0 7
65877: PUSH
65878: LD_INT 1
65880: ARRAY
65881: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
65882: LD_ADDR_VAR 0 9
65886: PUSH
65887: LD_VAR 0 7
65891: PPUSH
65892: LD_EXP 83
65896: PUSH
65897: LD_VAR 0 2
65901: ARRAY
65902: PPUSH
65903: CALL 25163 0 2
65907: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
65908: LD_EXP 97
65912: PUSH
65913: LD_VAR 0 2
65917: ARRAY
65918: IFFALSE 65941
// if not weapon in mc_allowed_tower_weapons [ i ] then
65920: LD_VAR 0 9
65924: PUSH
65925: LD_EXP 97
65929: PUSH
65930: LD_VAR 0 2
65934: ARRAY
65935: IN
65936: NOT
65937: IFFALSE 65941
// continue ;
65939: GO 65643
// end else
65941: GO 66006
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
65943: LD_ADDR_VAR 0 5
65947: PUSH
65948: LD_EXP 66
65952: PUSH
65953: LD_VAR 0 2
65957: ARRAY
65958: PPUSH
65959: LD_VAR 0 4
65963: PPUSH
65964: CALL 55217 0 2
65968: ST_TO_ADDR
// if not tmp2 then
65969: LD_VAR 0 5
65973: NOT
65974: IFFALSE 65978
// continue ;
65976: GO 65643
// tw := tmp2 [ 1 ] ;
65978: LD_ADDR_VAR 0 7
65982: PUSH
65983: LD_VAR 0 5
65987: PUSH
65988: LD_INT 1
65990: ARRAY
65991: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
65992: LD_ADDR_VAR 0 9
65996: PUSH
65997: LD_VAR 0 5
66001: PUSH
66002: LD_INT 2
66004: ARRAY
66005: ST_TO_ADDR
// end ; if not weapon then
66006: LD_VAR 0 9
66010: NOT
66011: IFFALSE 66015
// continue ;
66013: GO 65643
// ComPlaceWeapon ( tw , weapon ) ;
66015: LD_VAR 0 7
66019: PPUSH
66020: LD_VAR 0 9
66024: PPUSH
66025: CALL_OW 148
// end ;
66029: GO 65643
66031: POP
66032: POP
// end ;
66033: LD_VAR 0 1
66037: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
66038: LD_INT 0
66040: PPUSH
66041: PPUSH
66042: PPUSH
66043: PPUSH
66044: PPUSH
66045: PPUSH
// if not mc_bases then
66046: LD_EXP 58
66050: NOT
66051: IFFALSE 66055
// exit ;
66053: GO 67067
// for i = 1 to mc_bases do
66055: LD_ADDR_VAR 0 2
66059: PUSH
66060: DOUBLE
66061: LD_INT 1
66063: DEC
66064: ST_TO_ADDR
66065: LD_EXP 58
66069: PUSH
66070: FOR_TO
66071: IFFALSE 67065
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
66073: LD_EXP 71
66077: PUSH
66078: LD_VAR 0 2
66082: ARRAY
66083: NOT
66084: PUSH
66085: LD_EXP 71
66089: PUSH
66090: LD_VAR 0 2
66094: ARRAY
66095: PUSH
66096: LD_EXP 72
66100: PUSH
66101: LD_VAR 0 2
66105: ARRAY
66106: EQUAL
66107: OR
66108: IFFALSE 66112
// continue ;
66110: GO 66070
// if mc_miners [ i ] then
66112: LD_EXP 72
66116: PUSH
66117: LD_VAR 0 2
66121: ARRAY
66122: IFFALSE 66752
// begin k := 1 ;
66124: LD_ADDR_VAR 0 4
66128: PUSH
66129: LD_INT 1
66131: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
66132: LD_ADDR_VAR 0 3
66136: PUSH
66137: DOUBLE
66138: LD_EXP 72
66142: PUSH
66143: LD_VAR 0 2
66147: ARRAY
66148: INC
66149: ST_TO_ADDR
66150: LD_INT 1
66152: PUSH
66153: FOR_DOWNTO
66154: IFFALSE 66750
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66156: LD_EXP 72
66160: PUSH
66161: LD_VAR 0 2
66165: ARRAY
66166: PUSH
66167: LD_VAR 0 3
66171: ARRAY
66172: PPUSH
66173: CALL_OW 301
66177: PUSH
66178: LD_EXP 72
66182: PUSH
66183: LD_VAR 0 2
66187: ARRAY
66188: PUSH
66189: LD_VAR 0 3
66193: ARRAY
66194: PPUSH
66195: CALL_OW 257
66199: PUSH
66200: LD_INT 1
66202: NONEQUAL
66203: OR
66204: IFFALSE 66267
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66206: LD_ADDR_VAR 0 5
66210: PUSH
66211: LD_EXP 72
66215: PUSH
66216: LD_VAR 0 2
66220: ARRAY
66221: PUSH
66222: LD_EXP 72
66226: PUSH
66227: LD_VAR 0 2
66231: ARRAY
66232: PUSH
66233: LD_VAR 0 3
66237: ARRAY
66238: DIFF
66239: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
66240: LD_ADDR_EXP 72
66244: PUSH
66245: LD_EXP 72
66249: PPUSH
66250: LD_VAR 0 2
66254: PPUSH
66255: LD_VAR 0 5
66259: PPUSH
66260: CALL_OW 1
66264: ST_TO_ADDR
// continue ;
66265: GO 66153
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
66267: LD_EXP 72
66271: PUSH
66272: LD_VAR 0 2
66276: ARRAY
66277: PUSH
66278: LD_VAR 0 3
66282: ARRAY
66283: PPUSH
66284: CALL 20198 0 1
66288: PUSH
66289: LD_EXP 72
66293: PUSH
66294: LD_VAR 0 2
66298: ARRAY
66299: PUSH
66300: LD_VAR 0 3
66304: ARRAY
66305: PPUSH
66306: CALL_OW 255
66310: PPUSH
66311: LD_EXP 71
66315: PUSH
66316: LD_VAR 0 2
66320: ARRAY
66321: PUSH
66322: LD_VAR 0 4
66326: ARRAY
66327: PUSH
66328: LD_INT 1
66330: ARRAY
66331: PPUSH
66332: LD_EXP 71
66336: PUSH
66337: LD_VAR 0 2
66341: ARRAY
66342: PUSH
66343: LD_VAR 0 4
66347: ARRAY
66348: PUSH
66349: LD_INT 2
66351: ARRAY
66352: PPUSH
66353: LD_INT 15
66355: PPUSH
66356: CALL 21191 0 4
66360: PUSH
66361: LD_INT 4
66363: ARRAY
66364: PUSH
66365: LD_EXP 72
66369: PUSH
66370: LD_VAR 0 2
66374: ARRAY
66375: PUSH
66376: LD_VAR 0 3
66380: ARRAY
66381: PPUSH
66382: LD_INT 10
66384: PPUSH
66385: CALL 22888 0 2
66389: PUSH
66390: LD_INT 4
66392: ARRAY
66393: OR
66394: AND
66395: IFFALSE 66418
// ComStop ( mc_miners [ i ] [ j ] ) ;
66397: LD_EXP 72
66401: PUSH
66402: LD_VAR 0 2
66406: ARRAY
66407: PUSH
66408: LD_VAR 0 3
66412: ARRAY
66413: PPUSH
66414: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
66418: LD_EXP 72
66422: PUSH
66423: LD_VAR 0 2
66427: ARRAY
66428: PUSH
66429: LD_VAR 0 3
66433: ARRAY
66434: PPUSH
66435: CALL_OW 257
66439: PUSH
66440: LD_INT 1
66442: EQUAL
66443: PUSH
66444: LD_EXP 72
66448: PUSH
66449: LD_VAR 0 2
66453: ARRAY
66454: PUSH
66455: LD_VAR 0 3
66459: ARRAY
66460: PPUSH
66461: CALL_OW 459
66465: NOT
66466: AND
66467: PUSH
66468: LD_EXP 72
66472: PUSH
66473: LD_VAR 0 2
66477: ARRAY
66478: PUSH
66479: LD_VAR 0 3
66483: ARRAY
66484: PPUSH
66485: CALL_OW 255
66489: PPUSH
66490: LD_EXP 71
66494: PUSH
66495: LD_VAR 0 2
66499: ARRAY
66500: PUSH
66501: LD_VAR 0 4
66505: ARRAY
66506: PUSH
66507: LD_INT 1
66509: ARRAY
66510: PPUSH
66511: LD_EXP 71
66515: PUSH
66516: LD_VAR 0 2
66520: ARRAY
66521: PUSH
66522: LD_VAR 0 4
66526: ARRAY
66527: PUSH
66528: LD_INT 2
66530: ARRAY
66531: PPUSH
66532: LD_INT 15
66534: PPUSH
66535: CALL 21191 0 4
66539: PUSH
66540: LD_INT 4
66542: ARRAY
66543: PUSH
66544: LD_INT 0
66546: EQUAL
66547: AND
66548: PUSH
66549: LD_EXP 72
66553: PUSH
66554: LD_VAR 0 2
66558: ARRAY
66559: PUSH
66560: LD_VAR 0 3
66564: ARRAY
66565: PPUSH
66566: CALL_OW 314
66570: NOT
66571: AND
66572: IFFALSE 66748
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
66574: LD_EXP 72
66578: PUSH
66579: LD_VAR 0 2
66583: ARRAY
66584: PUSH
66585: LD_VAR 0 3
66589: ARRAY
66590: PPUSH
66591: CALL_OW 310
66595: IFFALSE 66618
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
66597: LD_EXP 72
66601: PUSH
66602: LD_VAR 0 2
66606: ARRAY
66607: PUSH
66608: LD_VAR 0 3
66612: ARRAY
66613: PPUSH
66614: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
66618: LD_EXP 72
66622: PUSH
66623: LD_VAR 0 2
66627: ARRAY
66628: PUSH
66629: LD_VAR 0 3
66633: ARRAY
66634: PPUSH
66635: CALL_OW 314
66639: NOT
66640: IFFALSE 66708
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
66642: LD_EXP 72
66646: PUSH
66647: LD_VAR 0 2
66651: ARRAY
66652: PUSH
66653: LD_VAR 0 3
66657: ARRAY
66658: PPUSH
66659: LD_EXP 71
66663: PUSH
66664: LD_VAR 0 2
66668: ARRAY
66669: PUSH
66670: LD_VAR 0 4
66674: ARRAY
66675: PUSH
66676: LD_INT 1
66678: ARRAY
66679: PPUSH
66680: LD_EXP 71
66684: PUSH
66685: LD_VAR 0 2
66689: ARRAY
66690: PUSH
66691: LD_VAR 0 4
66695: ARRAY
66696: PUSH
66697: LD_INT 2
66699: ARRAY
66700: PPUSH
66701: LD_INT 0
66703: PPUSH
66704: CALL_OW 193
// k := k + 1 ;
66708: LD_ADDR_VAR 0 4
66712: PUSH
66713: LD_VAR 0 4
66717: PUSH
66718: LD_INT 1
66720: PLUS
66721: ST_TO_ADDR
// if k > mc_mines [ i ] then
66722: LD_VAR 0 4
66726: PUSH
66727: LD_EXP 71
66731: PUSH
66732: LD_VAR 0 2
66736: ARRAY
66737: GREATER
66738: IFFALSE 66748
// k := 1 ;
66740: LD_ADDR_VAR 0 4
66744: PUSH
66745: LD_INT 1
66747: ST_TO_ADDR
// end ; end ;
66748: GO 66153
66750: POP
66751: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
66752: LD_ADDR_VAR 0 5
66756: PUSH
66757: LD_EXP 58
66761: PUSH
66762: LD_VAR 0 2
66766: ARRAY
66767: PPUSH
66768: LD_INT 2
66770: PUSH
66771: LD_INT 30
66773: PUSH
66774: LD_INT 4
66776: PUSH
66777: EMPTY
66778: LIST
66779: LIST
66780: PUSH
66781: LD_INT 30
66783: PUSH
66784: LD_INT 5
66786: PUSH
66787: EMPTY
66788: LIST
66789: LIST
66790: PUSH
66791: LD_INT 30
66793: PUSH
66794: LD_INT 32
66796: PUSH
66797: EMPTY
66798: LIST
66799: LIST
66800: PUSH
66801: EMPTY
66802: LIST
66803: LIST
66804: LIST
66805: LIST
66806: PPUSH
66807: CALL_OW 72
66811: ST_TO_ADDR
// if not tmp then
66812: LD_VAR 0 5
66816: NOT
66817: IFFALSE 66821
// continue ;
66819: GO 66070
// list := [ ] ;
66821: LD_ADDR_VAR 0 6
66825: PUSH
66826: EMPTY
66827: ST_TO_ADDR
// for j in tmp do
66828: LD_ADDR_VAR 0 3
66832: PUSH
66833: LD_VAR 0 5
66837: PUSH
66838: FOR_IN
66839: IFFALSE 66908
// begin for k in UnitsInside ( j ) do
66841: LD_ADDR_VAR 0 4
66845: PUSH
66846: LD_VAR 0 3
66850: PPUSH
66851: CALL_OW 313
66855: PUSH
66856: FOR_IN
66857: IFFALSE 66904
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
66859: LD_VAR 0 4
66863: PPUSH
66864: CALL_OW 257
66868: PUSH
66869: LD_INT 1
66871: EQUAL
66872: PUSH
66873: LD_VAR 0 4
66877: PPUSH
66878: CALL_OW 459
66882: NOT
66883: AND
66884: IFFALSE 66902
// list := list ^ k ;
66886: LD_ADDR_VAR 0 6
66890: PUSH
66891: LD_VAR 0 6
66895: PUSH
66896: LD_VAR 0 4
66900: ADD
66901: ST_TO_ADDR
66902: GO 66856
66904: POP
66905: POP
// end ;
66906: GO 66838
66908: POP
66909: POP
// list := list diff mc_miners [ i ] ;
66910: LD_ADDR_VAR 0 6
66914: PUSH
66915: LD_VAR 0 6
66919: PUSH
66920: LD_EXP 72
66924: PUSH
66925: LD_VAR 0 2
66929: ARRAY
66930: DIFF
66931: ST_TO_ADDR
// if not list then
66932: LD_VAR 0 6
66936: NOT
66937: IFFALSE 66941
// continue ;
66939: GO 66070
// k := mc_mines [ i ] - mc_miners [ i ] ;
66941: LD_ADDR_VAR 0 4
66945: PUSH
66946: LD_EXP 71
66950: PUSH
66951: LD_VAR 0 2
66955: ARRAY
66956: PUSH
66957: LD_EXP 72
66961: PUSH
66962: LD_VAR 0 2
66966: ARRAY
66967: MINUS
66968: ST_TO_ADDR
// if k > list then
66969: LD_VAR 0 4
66973: PUSH
66974: LD_VAR 0 6
66978: GREATER
66979: IFFALSE 66991
// k := list ;
66981: LD_ADDR_VAR 0 4
66985: PUSH
66986: LD_VAR 0 6
66990: ST_TO_ADDR
// for j = 1 to k do
66991: LD_ADDR_VAR 0 3
66995: PUSH
66996: DOUBLE
66997: LD_INT 1
66999: DEC
67000: ST_TO_ADDR
67001: LD_VAR 0 4
67005: PUSH
67006: FOR_TO
67007: IFFALSE 67061
// mc_miners := Add ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67009: LD_ADDR_EXP 72
67013: PUSH
67014: LD_EXP 72
67018: PPUSH
67019: LD_VAR 0 2
67023: PUSH
67024: LD_EXP 72
67028: PUSH
67029: LD_VAR 0 2
67033: ARRAY
67034: PUSH
67035: LD_INT 1
67037: PLUS
67038: PUSH
67039: EMPTY
67040: LIST
67041: LIST
67042: PPUSH
67043: LD_VAR 0 6
67047: PUSH
67048: LD_VAR 0 3
67052: ARRAY
67053: PPUSH
67054: CALL 20697 0 3
67058: ST_TO_ADDR
67059: GO 67006
67061: POP
67062: POP
// end ;
67063: GO 66070
67065: POP
67066: POP
// end ;
67067: LD_VAR 0 1
67071: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
67072: LD_INT 0
67074: PPUSH
67075: PPUSH
67076: PPUSH
67077: PPUSH
67078: PPUSH
67079: PPUSH
67080: PPUSH
67081: PPUSH
67082: PPUSH
67083: PPUSH
// if not mc_bases then
67084: LD_EXP 58
67088: NOT
67089: IFFALSE 67093
// exit ;
67091: GO 68824
// for i = 1 to mc_bases do
67093: LD_ADDR_VAR 0 2
67097: PUSH
67098: DOUBLE
67099: LD_INT 1
67101: DEC
67102: ST_TO_ADDR
67103: LD_EXP 58
67107: PUSH
67108: FOR_TO
67109: IFFALSE 68822
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67111: LD_EXP 58
67115: PUSH
67116: LD_VAR 0 2
67120: ARRAY
67121: NOT
67122: PUSH
67123: LD_EXP 65
67127: PUSH
67128: LD_VAR 0 2
67132: ARRAY
67133: OR
67134: IFFALSE 67138
// continue ;
67136: GO 67108
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67138: LD_EXP 74
67142: PUSH
67143: LD_VAR 0 2
67147: ARRAY
67148: NOT
67149: PUSH
67150: LD_EXP 75
67154: PUSH
67155: LD_VAR 0 2
67159: ARRAY
67160: AND
67161: IFFALSE 67199
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67163: LD_ADDR_EXP 75
67167: PUSH
67168: LD_EXP 75
67172: PPUSH
67173: LD_VAR 0 2
67177: PPUSH
67178: EMPTY
67179: PPUSH
67180: CALL_OW 1
67184: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67185: LD_VAR 0 2
67189: PPUSH
67190: LD_INT 107
67192: PPUSH
67193: CALL 58649 0 2
// continue ;
67197: GO 67108
// end ; target := [ ] ;
67199: LD_ADDR_VAR 0 6
67203: PUSH
67204: EMPTY
67205: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67206: LD_ADDR_VAR 0 3
67210: PUSH
67211: DOUBLE
67212: LD_EXP 74
67216: PUSH
67217: LD_VAR 0 2
67221: ARRAY
67222: INC
67223: ST_TO_ADDR
67224: LD_INT 1
67226: PUSH
67227: FOR_DOWNTO
67228: IFFALSE 67488
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67230: LD_EXP 74
67234: PUSH
67235: LD_VAR 0 2
67239: ARRAY
67240: PUSH
67241: LD_VAR 0 3
67245: ARRAY
67246: PUSH
67247: LD_INT 2
67249: ARRAY
67250: PPUSH
67251: LD_EXP 74
67255: PUSH
67256: LD_VAR 0 2
67260: ARRAY
67261: PUSH
67262: LD_VAR 0 3
67266: ARRAY
67267: PUSH
67268: LD_INT 3
67270: ARRAY
67271: PPUSH
67272: CALL_OW 488
67276: PUSH
67277: LD_EXP 74
67281: PUSH
67282: LD_VAR 0 2
67286: ARRAY
67287: PUSH
67288: LD_VAR 0 3
67292: ARRAY
67293: PUSH
67294: LD_INT 2
67296: ARRAY
67297: PPUSH
67298: LD_EXP 74
67302: PUSH
67303: LD_VAR 0 2
67307: ARRAY
67308: PUSH
67309: LD_VAR 0 3
67313: ARRAY
67314: PUSH
67315: LD_INT 3
67317: ARRAY
67318: PPUSH
67319: CALL_OW 284
67323: PUSH
67324: LD_INT 0
67326: EQUAL
67327: AND
67328: IFFALSE 67383
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67330: LD_ADDR_VAR 0 5
67334: PUSH
67335: LD_EXP 74
67339: PUSH
67340: LD_VAR 0 2
67344: ARRAY
67345: PPUSH
67346: LD_VAR 0 3
67350: PPUSH
67351: CALL_OW 3
67355: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67356: LD_ADDR_EXP 74
67360: PUSH
67361: LD_EXP 74
67365: PPUSH
67366: LD_VAR 0 2
67370: PPUSH
67371: LD_VAR 0 5
67375: PPUSH
67376: CALL_OW 1
67380: ST_TO_ADDR
// continue ;
67381: GO 67227
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
67383: LD_EXP 58
67387: PUSH
67388: LD_VAR 0 2
67392: ARRAY
67393: PUSH
67394: LD_INT 1
67396: ARRAY
67397: PPUSH
67398: CALL_OW 255
67402: PPUSH
67403: LD_EXP 74
67407: PUSH
67408: LD_VAR 0 2
67412: ARRAY
67413: PUSH
67414: LD_VAR 0 3
67418: ARRAY
67419: PUSH
67420: LD_INT 2
67422: ARRAY
67423: PPUSH
67424: LD_EXP 74
67428: PUSH
67429: LD_VAR 0 2
67433: ARRAY
67434: PUSH
67435: LD_VAR 0 3
67439: ARRAY
67440: PUSH
67441: LD_INT 3
67443: ARRAY
67444: PPUSH
67445: LD_INT 30
67447: PPUSH
67448: CALL 21191 0 4
67452: PUSH
67453: LD_INT 4
67455: ARRAY
67456: PUSH
67457: LD_INT 0
67459: EQUAL
67460: IFFALSE 67486
// begin target := mc_crates [ i ] [ j ] ;
67462: LD_ADDR_VAR 0 6
67466: PUSH
67467: LD_EXP 74
67471: PUSH
67472: LD_VAR 0 2
67476: ARRAY
67477: PUSH
67478: LD_VAR 0 3
67482: ARRAY
67483: ST_TO_ADDR
// break ;
67484: GO 67488
// end ; end ;
67486: GO 67227
67488: POP
67489: POP
// if not target then
67490: LD_VAR 0 6
67494: NOT
67495: IFFALSE 67499
// continue ;
67497: GO 67108
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
67499: LD_ADDR_VAR 0 7
67503: PUSH
67504: LD_EXP 77
67508: PUSH
67509: LD_VAR 0 2
67513: ARRAY
67514: PPUSH
67515: LD_INT 2
67517: PUSH
67518: LD_INT 3
67520: PUSH
67521: LD_INT 58
67523: PUSH
67524: EMPTY
67525: LIST
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: PUSH
67531: LD_INT 61
67533: PUSH
67534: EMPTY
67535: LIST
67536: PUSH
67537: LD_INT 33
67539: PUSH
67540: LD_INT 5
67542: PUSH
67543: EMPTY
67544: LIST
67545: LIST
67546: PUSH
67547: LD_INT 33
67549: PUSH
67550: LD_INT 3
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: EMPTY
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 2
67566: PUSH
67567: LD_INT 34
67569: PUSH
67570: LD_INT 32
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 34
67579: PUSH
67580: LD_INT 51
67582: PUSH
67583: EMPTY
67584: LIST
67585: LIST
67586: PUSH
67587: LD_INT 34
67589: PUSH
67590: LD_INT 12
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PUSH
67597: EMPTY
67598: LIST
67599: LIST
67600: LIST
67601: LIST
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: PPUSH
67607: CALL_OW 72
67611: ST_TO_ADDR
// if not cargo then
67612: LD_VAR 0 7
67616: NOT
67617: IFFALSE 68260
// begin if mc_crates_collector [ i ] < 5 then
67619: LD_EXP 75
67623: PUSH
67624: LD_VAR 0 2
67628: ARRAY
67629: PUSH
67630: LD_INT 5
67632: LESS
67633: IFFALSE 67999
// begin if mc_ape [ i ] then
67635: LD_EXP 87
67639: PUSH
67640: LD_VAR 0 2
67644: ARRAY
67645: IFFALSE 67692
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
67647: LD_ADDR_VAR 0 5
67651: PUSH
67652: LD_EXP 87
67656: PUSH
67657: LD_VAR 0 2
67661: ARRAY
67662: PPUSH
67663: LD_INT 25
67665: PUSH
67666: LD_INT 16
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 24
67675: PUSH
67676: LD_INT 750
67678: PUSH
67679: EMPTY
67680: LIST
67681: LIST
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PPUSH
67687: CALL_OW 72
67691: ST_TO_ADDR
// if not tmp then
67692: LD_VAR 0 5
67696: NOT
67697: IFFALSE 67744
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
67699: LD_ADDR_VAR 0 5
67703: PUSH
67704: LD_EXP 58
67708: PUSH
67709: LD_VAR 0 2
67713: ARRAY
67714: PPUSH
67715: LD_INT 25
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: LD_INT 24
67727: PUSH
67728: LD_INT 750
67730: PUSH
67731: EMPTY
67732: LIST
67733: LIST
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PPUSH
67739: CALL_OW 72
67743: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
67744: LD_EXP 87
67748: PUSH
67749: LD_VAR 0 2
67753: ARRAY
67754: PUSH
67755: LD_EXP 58
67759: PUSH
67760: LD_VAR 0 2
67764: ARRAY
67765: PPUSH
67766: LD_INT 25
67768: PUSH
67769: LD_INT 2
67771: PUSH
67772: EMPTY
67773: LIST
67774: LIST
67775: PUSH
67776: LD_INT 24
67778: PUSH
67779: LD_INT 750
67781: PUSH
67782: EMPTY
67783: LIST
67784: LIST
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: PPUSH
67790: CALL_OW 72
67794: AND
67795: PUSH
67796: LD_VAR 0 5
67800: PUSH
67801: LD_INT 5
67803: LESS
67804: AND
67805: IFFALSE 67887
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
67807: LD_ADDR_VAR 0 3
67811: PUSH
67812: LD_EXP 58
67816: PUSH
67817: LD_VAR 0 2
67821: ARRAY
67822: PPUSH
67823: LD_INT 25
67825: PUSH
67826: LD_INT 2
67828: PUSH
67829: EMPTY
67830: LIST
67831: LIST
67832: PUSH
67833: LD_INT 24
67835: PUSH
67836: LD_INT 750
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PPUSH
67847: CALL_OW 72
67851: PUSH
67852: FOR_IN
67853: IFFALSE 67885
// begin tmp := tmp union j ;
67855: LD_ADDR_VAR 0 5
67859: PUSH
67860: LD_VAR 0 5
67864: PUSH
67865: LD_VAR 0 3
67869: UNION
67870: ST_TO_ADDR
// if tmp >= 5 then
67871: LD_VAR 0 5
67875: PUSH
67876: LD_INT 5
67878: GREATEREQUAL
67879: IFFALSE 67883
// break ;
67881: GO 67885
// end ;
67883: GO 67852
67885: POP
67886: POP
// end ; if not tmp then
67887: LD_VAR 0 5
67891: NOT
67892: IFFALSE 67896
// continue ;
67894: GO 67108
// for j in tmp do
67896: LD_ADDR_VAR 0 3
67900: PUSH
67901: LD_VAR 0 5
67905: PUSH
67906: FOR_IN
67907: IFFALSE 67997
// if not GetTag ( j ) then
67909: LD_VAR 0 3
67913: PPUSH
67914: CALL_OW 110
67918: NOT
67919: IFFALSE 67995
// begin mc_crates_collector := Add ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
67921: LD_ADDR_EXP 75
67925: PUSH
67926: LD_EXP 75
67930: PPUSH
67931: LD_VAR 0 2
67935: PUSH
67936: LD_EXP 75
67940: PUSH
67941: LD_VAR 0 2
67945: ARRAY
67946: PUSH
67947: LD_INT 1
67949: PLUS
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: PPUSH
67955: LD_VAR 0 3
67959: PPUSH
67960: CALL 20697 0 3
67964: ST_TO_ADDR
// SetTag ( j , 107 ) ;
67965: LD_VAR 0 3
67969: PPUSH
67970: LD_INT 107
67972: PPUSH
67973: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
67977: LD_EXP 75
67981: PUSH
67982: LD_VAR 0 2
67986: ARRAY
67987: PUSH
67988: LD_INT 5
67990: GREATEREQUAL
67991: IFFALSE 67995
// break ;
67993: GO 67997
// end ;
67995: GO 67906
67997: POP
67998: POP
// end ; if mc_crates_collector [ i ] and target then
67999: LD_EXP 75
68003: PUSH
68004: LD_VAR 0 2
68008: ARRAY
68009: PUSH
68010: LD_VAR 0 6
68014: AND
68015: IFFALSE 68258
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68017: LD_EXP 75
68021: PUSH
68022: LD_VAR 0 2
68026: ARRAY
68027: PUSH
68028: LD_VAR 0 6
68032: PUSH
68033: LD_INT 1
68035: ARRAY
68036: LESS
68037: IFFALSE 68057
// tmp := mc_crates_collector [ i ] else
68039: LD_ADDR_VAR 0 5
68043: PUSH
68044: LD_EXP 75
68048: PUSH
68049: LD_VAR 0 2
68053: ARRAY
68054: ST_TO_ADDR
68055: GO 68071
// tmp := target [ 1 ] ;
68057: LD_ADDR_VAR 0 5
68061: PUSH
68062: LD_VAR 0 6
68066: PUSH
68067: LD_INT 1
68069: ARRAY
68070: ST_TO_ADDR
// k := 0 ;
68071: LD_ADDR_VAR 0 4
68075: PUSH
68076: LD_INT 0
68078: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68079: LD_ADDR_VAR 0 3
68083: PUSH
68084: LD_EXP 75
68088: PUSH
68089: LD_VAR 0 2
68093: ARRAY
68094: PUSH
68095: FOR_IN
68096: IFFALSE 68256
// begin k := k + 1 ;
68098: LD_ADDR_VAR 0 4
68102: PUSH
68103: LD_VAR 0 4
68107: PUSH
68108: LD_INT 1
68110: PLUS
68111: ST_TO_ADDR
// if k > tmp then
68112: LD_VAR 0 4
68116: PUSH
68117: LD_VAR 0 5
68121: GREATER
68122: IFFALSE 68126
// break ;
68124: GO 68256
// if not GetClass ( j ) in [ 2 , 16 ] then
68126: LD_VAR 0 3
68130: PPUSH
68131: CALL_OW 257
68135: PUSH
68136: LD_INT 2
68138: PUSH
68139: LD_INT 16
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: IN
68146: NOT
68147: IFFALSE 68200
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68149: LD_ADDR_EXP 75
68153: PUSH
68154: LD_EXP 75
68158: PPUSH
68159: LD_VAR 0 2
68163: PPUSH
68164: LD_EXP 75
68168: PUSH
68169: LD_VAR 0 2
68173: ARRAY
68174: PUSH
68175: LD_VAR 0 3
68179: DIFF
68180: PPUSH
68181: CALL_OW 1
68185: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68186: LD_VAR 0 3
68190: PPUSH
68191: LD_INT 0
68193: PPUSH
68194: CALL_OW 109
// continue ;
68198: GO 68095
// end ; if IsInUnit ( j ) then
68200: LD_VAR 0 3
68204: PPUSH
68205: CALL_OW 310
68209: IFFALSE 68220
// ComExitBuilding ( j ) ;
68211: LD_VAR 0 3
68215: PPUSH
68216: CALL_OW 122
// wait ( 3 ) ;
68220: LD_INT 3
68222: PPUSH
68223: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68227: LD_VAR 0 3
68231: PPUSH
68232: LD_VAR 0 6
68236: PUSH
68237: LD_INT 2
68239: ARRAY
68240: PPUSH
68241: LD_VAR 0 6
68245: PUSH
68246: LD_INT 3
68248: ARRAY
68249: PPUSH
68250: CALL_OW 117
// end ;
68254: GO 68095
68256: POP
68257: POP
// end ; end else
68258: GO 68820
// begin for j in cargo do
68260: LD_ADDR_VAR 0 3
68264: PUSH
68265: LD_VAR 0 7
68269: PUSH
68270: FOR_IN
68271: IFFALSE 68818
// begin if GetTag ( j ) <> 0 then
68273: LD_VAR 0 3
68277: PPUSH
68278: CALL_OW 110
68282: PUSH
68283: LD_INT 0
68285: NONEQUAL
68286: IFFALSE 68290
// continue ;
68288: GO 68270
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68290: LD_VAR 0 3
68294: PPUSH
68295: CALL_OW 256
68299: PUSH
68300: LD_INT 1000
68302: LESS
68303: PUSH
68304: LD_VAR 0 3
68308: PPUSH
68309: LD_EXP 82
68313: PUSH
68314: LD_VAR 0 2
68318: ARRAY
68319: PPUSH
68320: CALL_OW 308
68324: NOT
68325: AND
68326: IFFALSE 68348
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68328: LD_VAR 0 3
68332: PPUSH
68333: LD_EXP 82
68337: PUSH
68338: LD_VAR 0 2
68342: ARRAY
68343: PPUSH
68344: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
68348: LD_VAR 0 3
68352: PPUSH
68353: CALL_OW 256
68357: PUSH
68358: LD_INT 1000
68360: LESS
68361: PUSH
68362: LD_VAR 0 3
68366: PPUSH
68367: LD_EXP 82
68371: PUSH
68372: LD_VAR 0 2
68376: ARRAY
68377: PPUSH
68378: CALL_OW 308
68382: AND
68383: IFFALSE 68387
// continue ;
68385: GO 68270
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
68387: LD_VAR 0 3
68391: PPUSH
68392: CALL_OW 262
68396: PUSH
68397: LD_INT 2
68399: EQUAL
68400: PUSH
68401: LD_VAR 0 3
68405: PPUSH
68406: CALL_OW 261
68410: PUSH
68411: LD_INT 15
68413: LESS
68414: AND
68415: IFFALSE 68419
// continue ;
68417: GO 68270
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
68419: LD_VAR 0 3
68423: PPUSH
68424: CALL_OW 262
68428: PUSH
68429: LD_INT 1
68431: EQUAL
68432: PUSH
68433: LD_VAR 0 3
68437: PPUSH
68438: CALL_OW 261
68442: PUSH
68443: LD_INT 10
68445: LESS
68446: AND
68447: IFFALSE 68757
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68449: LD_ADDR_VAR 0 8
68453: PUSH
68454: LD_EXP 58
68458: PUSH
68459: LD_VAR 0 2
68463: ARRAY
68464: PPUSH
68465: LD_INT 2
68467: PUSH
68468: LD_INT 30
68470: PUSH
68471: LD_INT 0
68473: PUSH
68474: EMPTY
68475: LIST
68476: LIST
68477: PUSH
68478: LD_INT 30
68480: PUSH
68481: LD_INT 1
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: LIST
68492: PPUSH
68493: CALL_OW 72
68497: ST_TO_ADDR
// if not depot then
68498: LD_VAR 0 8
68502: NOT
68503: IFFALSE 68507
// continue ;
68505: GO 68270
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
68507: LD_VAR 0 3
68511: PPUSH
68512: LD_VAR 0 8
68516: PPUSH
68517: LD_VAR 0 3
68521: PPUSH
68522: CALL_OW 74
68526: PPUSH
68527: CALL_OW 296
68531: PUSH
68532: LD_INT 6
68534: LESS
68535: IFFALSE 68551
// SetFuel ( j , 100 ) else
68537: LD_VAR 0 3
68541: PPUSH
68542: LD_INT 100
68544: PPUSH
68545: CALL_OW 240
68549: GO 68757
// if GetFuel ( j ) = 0 then
68551: LD_VAR 0 3
68555: PPUSH
68556: CALL_OW 261
68560: PUSH
68561: LD_INT 0
68563: EQUAL
68564: IFFALSE 68757
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
68566: LD_ADDR_EXP 77
68570: PUSH
68571: LD_EXP 77
68575: PPUSH
68576: LD_VAR 0 2
68580: PPUSH
68581: LD_EXP 77
68585: PUSH
68586: LD_VAR 0 2
68590: ARRAY
68591: PUSH
68592: LD_VAR 0 3
68596: DIFF
68597: PPUSH
68598: CALL_OW 1
68602: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
68603: LD_VAR 0 3
68607: PPUSH
68608: CALL_OW 263
68612: PUSH
68613: LD_INT 1
68615: EQUAL
68616: IFFALSE 68632
// ComExitVehicle ( IsInUnit ( j ) ) ;
68618: LD_VAR 0 3
68622: PPUSH
68623: CALL_OW 310
68627: PPUSH
68628: CALL_OW 121
// if GetControl ( j ) = control_remote then
68632: LD_VAR 0 3
68636: PPUSH
68637: CALL_OW 263
68641: PUSH
68642: LD_INT 2
68644: EQUAL
68645: IFFALSE 68656
// ComUnlink ( j ) ;
68647: LD_VAR 0 3
68651: PPUSH
68652: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
68656: LD_ADDR_VAR 0 9
68660: PUSH
68661: LD_VAR 0 2
68665: PPUSH
68666: LD_INT 3
68668: PPUSH
68669: CALL 77892 0 2
68673: ST_TO_ADDR
// if fac then
68674: LD_VAR 0 9
68678: IFFALSE 68755
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
68680: LD_ADDR_VAR 0 10
68684: PUSH
68685: LD_VAR 0 9
68689: PPUSH
68690: LD_VAR 0 3
68694: PPUSH
68695: CALL_OW 265
68699: PPUSH
68700: LD_VAR 0 3
68704: PPUSH
68705: CALL_OW 262
68709: PPUSH
68710: LD_VAR 0 3
68714: PPUSH
68715: CALL_OW 263
68719: PPUSH
68720: LD_VAR 0 3
68724: PPUSH
68725: CALL_OW 264
68729: PPUSH
68730: CALL 17862 0 5
68734: ST_TO_ADDR
// if components then
68735: LD_VAR 0 10
68739: IFFALSE 68755
// MC_InsertProduceList ( i , components ) ;
68741: LD_VAR 0 2
68745: PPUSH
68746: LD_VAR 0 10
68750: PPUSH
68751: CALL 77462 0 2
// end ; continue ;
68755: GO 68270
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
68757: LD_VAR 0 3
68761: PPUSH
68762: LD_INT 1
68764: PPUSH
68765: CALL_OW 289
68769: PUSH
68770: LD_INT 100
68772: LESS
68773: PUSH
68774: LD_VAR 0 3
68778: PPUSH
68779: CALL_OW 314
68783: NOT
68784: AND
68785: IFFALSE 68814
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68787: LD_VAR 0 3
68791: PPUSH
68792: LD_VAR 0 6
68796: PUSH
68797: LD_INT 2
68799: ARRAY
68800: PPUSH
68801: LD_VAR 0 6
68805: PUSH
68806: LD_INT 3
68808: ARRAY
68809: PPUSH
68810: CALL_OW 117
// break ;
68814: GO 68818
// end ;
68816: GO 68270
68818: POP
68819: POP
// end ; end ;
68820: GO 67108
68822: POP
68823: POP
// end ;
68824: LD_VAR 0 1
68828: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
68829: LD_INT 0
68831: PPUSH
68832: PPUSH
68833: PPUSH
68834: PPUSH
// if not mc_bases then
68835: LD_EXP 58
68839: NOT
68840: IFFALSE 68844
// exit ;
68842: GO 69005
// for i = 1 to mc_bases do
68844: LD_ADDR_VAR 0 2
68848: PUSH
68849: DOUBLE
68850: LD_INT 1
68852: DEC
68853: ST_TO_ADDR
68854: LD_EXP 58
68858: PUSH
68859: FOR_TO
68860: IFFALSE 69003
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
68862: LD_ADDR_VAR 0 4
68866: PUSH
68867: LD_EXP 77
68871: PUSH
68872: LD_VAR 0 2
68876: ARRAY
68877: PUSH
68878: LD_EXP 80
68882: PUSH
68883: LD_VAR 0 2
68887: ARRAY
68888: UNION
68889: PPUSH
68890: LD_INT 33
68892: PUSH
68893: LD_INT 2
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PPUSH
68900: CALL_OW 72
68904: ST_TO_ADDR
// if tmp then
68905: LD_VAR 0 4
68909: IFFALSE 69001
// for j in tmp do
68911: LD_ADDR_VAR 0 3
68915: PUSH
68916: LD_VAR 0 4
68920: PUSH
68921: FOR_IN
68922: IFFALSE 68999
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
68924: LD_VAR 0 3
68928: PPUSH
68929: CALL_OW 312
68933: NOT
68934: PUSH
68935: LD_VAR 0 3
68939: PPUSH
68940: CALL_OW 256
68944: PUSH
68945: LD_INT 250
68947: GREATEREQUAL
68948: AND
68949: IFFALSE 68962
// Connect ( j ) else
68951: LD_VAR 0 3
68955: PPUSH
68956: CALL 23228 0 1
68960: GO 68997
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
68962: LD_VAR 0 3
68966: PPUSH
68967: CALL_OW 256
68971: PUSH
68972: LD_INT 250
68974: LESS
68975: PUSH
68976: LD_VAR 0 3
68980: PPUSH
68981: CALL_OW 312
68985: AND
68986: IFFALSE 68997
// ComUnlink ( j ) ;
68988: LD_VAR 0 3
68992: PPUSH
68993: CALL_OW 136
68997: GO 68921
68999: POP
69000: POP
// end ;
69001: GO 68859
69003: POP
69004: POP
// end ;
69005: LD_VAR 0 1
69009: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69010: LD_INT 0
69012: PPUSH
69013: PPUSH
69014: PPUSH
69015: PPUSH
69016: PPUSH
// if not mc_bases then
69017: LD_EXP 58
69021: NOT
69022: IFFALSE 69026
// exit ;
69024: GO 69486
// for i = 1 to mc_bases do
69026: LD_ADDR_VAR 0 2
69030: PUSH
69031: DOUBLE
69032: LD_INT 1
69034: DEC
69035: ST_TO_ADDR
69036: LD_EXP 58
69040: PUSH
69041: FOR_TO
69042: IFFALSE 69484
// begin if not mc_produce [ i ] then
69044: LD_EXP 79
69048: PUSH
69049: LD_VAR 0 2
69053: ARRAY
69054: NOT
69055: IFFALSE 69059
// continue ;
69057: GO 69041
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69059: LD_ADDR_VAR 0 5
69063: PUSH
69064: LD_EXP 58
69068: PUSH
69069: LD_VAR 0 2
69073: ARRAY
69074: PPUSH
69075: LD_INT 30
69077: PUSH
69078: LD_INT 3
69080: PUSH
69081: EMPTY
69082: LIST
69083: LIST
69084: PPUSH
69085: CALL_OW 72
69089: ST_TO_ADDR
// if not fac then
69090: LD_VAR 0 5
69094: NOT
69095: IFFALSE 69099
// continue ;
69097: GO 69041
// for j in fac do
69099: LD_ADDR_VAR 0 3
69103: PUSH
69104: LD_VAR 0 5
69108: PUSH
69109: FOR_IN
69110: IFFALSE 69480
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
69112: LD_VAR 0 3
69116: PPUSH
69117: CALL_OW 461
69121: PUSH
69122: LD_INT 2
69124: NONEQUAL
69125: PUSH
69126: LD_VAR 0 3
69130: PPUSH
69131: LD_INT 15
69133: PPUSH
69134: CALL 22888 0 2
69138: PUSH
69139: LD_INT 4
69141: ARRAY
69142: OR
69143: PUSH
69144: LD_VAR 0 3
69148: PPUSH
69149: CALL_OW 313
69153: PUSH
69154: LD_INT 0
69156: EQUAL
69157: OR
69158: IFFALSE 69162
// continue ;
69160: GO 69109
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69162: LD_VAR 0 3
69166: PPUSH
69167: LD_EXP 79
69171: PUSH
69172: LD_VAR 0 2
69176: ARRAY
69177: PUSH
69178: LD_INT 1
69180: ARRAY
69181: PUSH
69182: LD_INT 1
69184: ARRAY
69185: PPUSH
69186: LD_EXP 79
69190: PUSH
69191: LD_VAR 0 2
69195: ARRAY
69196: PUSH
69197: LD_INT 1
69199: ARRAY
69200: PUSH
69201: LD_INT 2
69203: ARRAY
69204: PPUSH
69205: LD_EXP 79
69209: PUSH
69210: LD_VAR 0 2
69214: ARRAY
69215: PUSH
69216: LD_INT 1
69218: ARRAY
69219: PUSH
69220: LD_INT 3
69222: ARRAY
69223: PPUSH
69224: LD_EXP 79
69228: PUSH
69229: LD_VAR 0 2
69233: ARRAY
69234: PUSH
69235: LD_INT 1
69237: ARRAY
69238: PUSH
69239: LD_INT 4
69241: ARRAY
69242: PPUSH
69243: CALL_OW 448
69247: PUSH
69248: LD_VAR 0 3
69252: PPUSH
69253: LD_EXP 79
69257: PUSH
69258: LD_VAR 0 2
69262: ARRAY
69263: PUSH
69264: LD_INT 1
69266: ARRAY
69267: PUSH
69268: LD_INT 1
69270: ARRAY
69271: PUSH
69272: LD_EXP 79
69276: PUSH
69277: LD_VAR 0 2
69281: ARRAY
69282: PUSH
69283: LD_INT 1
69285: ARRAY
69286: PUSH
69287: LD_INT 2
69289: ARRAY
69290: PUSH
69291: LD_EXP 79
69295: PUSH
69296: LD_VAR 0 2
69300: ARRAY
69301: PUSH
69302: LD_INT 1
69304: ARRAY
69305: PUSH
69306: LD_INT 3
69308: ARRAY
69309: PUSH
69310: LD_EXP 79
69314: PUSH
69315: LD_VAR 0 2
69319: ARRAY
69320: PUSH
69321: LD_INT 1
69323: ARRAY
69324: PUSH
69325: LD_INT 4
69327: ARRAY
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: PPUSH
69335: CALL 26457 0 2
69339: AND
69340: IFFALSE 69478
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69342: LD_VAR 0 3
69346: PPUSH
69347: LD_EXP 79
69351: PUSH
69352: LD_VAR 0 2
69356: ARRAY
69357: PUSH
69358: LD_INT 1
69360: ARRAY
69361: PUSH
69362: LD_INT 1
69364: ARRAY
69365: PPUSH
69366: LD_EXP 79
69370: PUSH
69371: LD_VAR 0 2
69375: ARRAY
69376: PUSH
69377: LD_INT 1
69379: ARRAY
69380: PUSH
69381: LD_INT 2
69383: ARRAY
69384: PPUSH
69385: LD_EXP 79
69389: PUSH
69390: LD_VAR 0 2
69394: ARRAY
69395: PUSH
69396: LD_INT 1
69398: ARRAY
69399: PUSH
69400: LD_INT 3
69402: ARRAY
69403: PPUSH
69404: LD_EXP 79
69408: PUSH
69409: LD_VAR 0 2
69413: ARRAY
69414: PUSH
69415: LD_INT 1
69417: ARRAY
69418: PUSH
69419: LD_INT 4
69421: ARRAY
69422: PPUSH
69423: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
69427: LD_ADDR_VAR 0 4
69431: PUSH
69432: LD_EXP 79
69436: PUSH
69437: LD_VAR 0 2
69441: ARRAY
69442: PPUSH
69443: LD_INT 1
69445: PPUSH
69446: CALL_OW 3
69450: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
69451: LD_ADDR_EXP 79
69455: PUSH
69456: LD_EXP 79
69460: PPUSH
69461: LD_VAR 0 2
69465: PPUSH
69466: LD_VAR 0 4
69470: PPUSH
69471: CALL_OW 1
69475: ST_TO_ADDR
// break ;
69476: GO 69480
// end ; end ;
69478: GO 69109
69480: POP
69481: POP
// end ;
69482: GO 69041
69484: POP
69485: POP
// end ;
69486: LD_VAR 0 1
69490: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
69491: LD_INT 0
69493: PPUSH
69494: PPUSH
69495: PPUSH
// if not mc_bases then
69496: LD_EXP 58
69500: NOT
69501: IFFALSE 69505
// exit ;
69503: GO 69594
// for i = 1 to mc_bases do
69505: LD_ADDR_VAR 0 2
69509: PUSH
69510: DOUBLE
69511: LD_INT 1
69513: DEC
69514: ST_TO_ADDR
69515: LD_EXP 58
69519: PUSH
69520: FOR_TO
69521: IFFALSE 69592
// begin if mc_attack [ i ] then
69523: LD_EXP 78
69527: PUSH
69528: LD_VAR 0 2
69532: ARRAY
69533: IFFALSE 69590
// begin tmp := mc_attack [ i ] [ 1 ] ;
69535: LD_ADDR_VAR 0 3
69539: PUSH
69540: LD_EXP 78
69544: PUSH
69545: LD_VAR 0 2
69549: ARRAY
69550: PUSH
69551: LD_INT 1
69553: ARRAY
69554: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
69555: LD_ADDR_EXP 78
69559: PUSH
69560: LD_EXP 78
69564: PPUSH
69565: LD_VAR 0 2
69569: PPUSH
69570: EMPTY
69571: PPUSH
69572: CALL_OW 1
69576: ST_TO_ADDR
// Attack ( tmp ) ;
69577: LD_VAR 0 3
69581: PPUSH
69582: CALL 48561 0 1
// exit ;
69586: POP
69587: POP
69588: GO 69594
// end ; end ;
69590: GO 69520
69592: POP
69593: POP
// end ;
69594: LD_VAR 0 1
69598: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
69599: LD_INT 0
69601: PPUSH
69602: PPUSH
69603: PPUSH
69604: PPUSH
69605: PPUSH
69606: PPUSH
69607: PPUSH
// if not mc_bases then
69608: LD_EXP 58
69612: NOT
69613: IFFALSE 69617
// exit ;
69615: GO 70221
// for i = 1 to mc_bases do
69617: LD_ADDR_VAR 0 2
69621: PUSH
69622: DOUBLE
69623: LD_INT 1
69625: DEC
69626: ST_TO_ADDR
69627: LD_EXP 58
69631: PUSH
69632: FOR_TO
69633: IFFALSE 70219
// begin if not mc_bases [ i ] then
69635: LD_EXP 58
69639: PUSH
69640: LD_VAR 0 2
69644: ARRAY
69645: NOT
69646: IFFALSE 69650
// continue ;
69648: GO 69632
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
69650: LD_ADDR_VAR 0 7
69654: PUSH
69655: LD_EXP 58
69659: PUSH
69660: LD_VAR 0 2
69664: ARRAY
69665: PUSH
69666: LD_INT 1
69668: ARRAY
69669: PPUSH
69670: CALL 17166 0 1
69674: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
69675: LD_ADDR_EXP 81
69679: PUSH
69680: LD_EXP 81
69684: PPUSH
69685: LD_VAR 0 2
69689: PPUSH
69690: LD_EXP 58
69694: PUSH
69695: LD_VAR 0 2
69699: ARRAY
69700: PUSH
69701: LD_INT 1
69703: ARRAY
69704: PPUSH
69705: CALL_OW 255
69709: PPUSH
69710: LD_EXP 83
69714: PUSH
69715: LD_VAR 0 2
69719: ARRAY
69720: PPUSH
69721: CALL 15126 0 2
69725: PPUSH
69726: CALL_OW 1
69730: ST_TO_ADDR
// if not mc_scan [ i ] then
69731: LD_EXP 81
69735: PUSH
69736: LD_VAR 0 2
69740: ARRAY
69741: NOT
69742: IFFALSE 69897
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69744: LD_ADDR_VAR 0 4
69748: PUSH
69749: LD_EXP 58
69753: PUSH
69754: LD_VAR 0 2
69758: ARRAY
69759: PPUSH
69760: LD_INT 2
69762: PUSH
69763: LD_INT 25
69765: PUSH
69766: LD_INT 5
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 25
69775: PUSH
69776: LD_INT 8
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 25
69785: PUSH
69786: LD_INT 9
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: EMPTY
69794: LIST
69795: LIST
69796: LIST
69797: LIST
69798: PPUSH
69799: CALL_OW 72
69803: ST_TO_ADDR
// if not tmp then
69804: LD_VAR 0 4
69808: NOT
69809: IFFALSE 69813
// continue ;
69811: GO 69632
// for j in tmp do
69813: LD_ADDR_VAR 0 3
69817: PUSH
69818: LD_VAR 0 4
69822: PUSH
69823: FOR_IN
69824: IFFALSE 69895
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
69826: LD_VAR 0 3
69830: PPUSH
69831: CALL_OW 310
69835: PPUSH
69836: CALL_OW 266
69840: PUSH
69841: LD_INT 5
69843: EQUAL
69844: PUSH
69845: LD_VAR 0 3
69849: PPUSH
69850: CALL_OW 257
69854: PUSH
69855: LD_INT 1
69857: EQUAL
69858: AND
69859: PUSH
69860: LD_VAR 0 3
69864: PPUSH
69865: CALL_OW 459
69869: NOT
69870: AND
69871: PUSH
69872: LD_VAR 0 7
69876: AND
69877: IFFALSE 69893
// ComChangeProfession ( j , class ) ;
69879: LD_VAR 0 3
69883: PPUSH
69884: LD_VAR 0 7
69888: PPUSH
69889: CALL_OW 123
69893: GO 69823
69895: POP
69896: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
69897: LD_EXP 81
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PUSH
69908: LD_EXP 80
69912: PUSH
69913: LD_VAR 0 2
69917: ARRAY
69918: NOT
69919: AND
69920: PUSH
69921: LD_EXP 58
69925: PUSH
69926: LD_VAR 0 2
69930: ARRAY
69931: PPUSH
69932: LD_INT 30
69934: PUSH
69935: LD_INT 32
69937: PUSH
69938: EMPTY
69939: LIST
69940: LIST
69941: PPUSH
69942: CALL_OW 72
69946: NOT
69947: AND
69948: PUSH
69949: LD_EXP 58
69953: PUSH
69954: LD_VAR 0 2
69958: ARRAY
69959: PPUSH
69960: LD_INT 2
69962: PUSH
69963: LD_INT 30
69965: PUSH
69966: LD_INT 4
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PUSH
69973: LD_INT 30
69975: PUSH
69976: LD_INT 5
69978: PUSH
69979: EMPTY
69980: LIST
69981: LIST
69982: PUSH
69983: EMPTY
69984: LIST
69985: LIST
69986: LIST
69987: PPUSH
69988: CALL_OW 72
69992: NOT
69993: AND
69994: IFFALSE 70126
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
69996: LD_ADDR_VAR 0 4
70000: PUSH
70001: LD_EXP 58
70005: PUSH
70006: LD_VAR 0 2
70010: ARRAY
70011: PPUSH
70012: LD_INT 2
70014: PUSH
70015: LD_INT 25
70017: PUSH
70018: LD_INT 1
70020: PUSH
70021: EMPTY
70022: LIST
70023: LIST
70024: PUSH
70025: LD_INT 25
70027: PUSH
70028: LD_INT 5
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 25
70037: PUSH
70038: LD_INT 8
70040: PUSH
70041: EMPTY
70042: LIST
70043: LIST
70044: PUSH
70045: LD_INT 25
70047: PUSH
70048: LD_INT 9
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: EMPTY
70056: LIST
70057: LIST
70058: LIST
70059: LIST
70060: LIST
70061: PPUSH
70062: CALL_OW 72
70066: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70067: LD_ADDR_VAR 0 4
70071: PUSH
70072: LD_VAR 0 4
70076: PUSH
70077: LD_VAR 0 4
70081: PPUSH
70082: LD_INT 18
70084: PPUSH
70085: CALL 53305 0 2
70089: DIFF
70090: ST_TO_ADDR
// if tmp then
70091: LD_VAR 0 4
70095: IFFALSE 70126
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
70097: LD_VAR 0 2
70101: PPUSH
70102: LD_VAR 0 4
70106: PPUSH
70107: LD_EXP 83
70111: PUSH
70112: LD_VAR 0 2
70116: ARRAY
70117: PPUSH
70118: CALL 15161 0 3
// exit ;
70122: POP
70123: POP
70124: GO 70221
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
70126: LD_EXP 81
70130: PUSH
70131: LD_VAR 0 2
70135: ARRAY
70136: PUSH
70137: LD_EXP 80
70141: PUSH
70142: LD_VAR 0 2
70146: ARRAY
70147: AND
70148: IFFALSE 70217
// begin tmp := mc_defender [ i ] ;
70150: LD_ADDR_VAR 0 4
70154: PUSH
70155: LD_EXP 80
70159: PUSH
70160: LD_VAR 0 2
70164: ARRAY
70165: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70166: LD_ADDR_EXP 80
70170: PUSH
70171: LD_EXP 80
70175: PPUSH
70176: LD_VAR 0 2
70180: PPUSH
70181: EMPTY
70182: PPUSH
70183: CALL_OW 1
70187: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
70188: LD_VAR 0 2
70192: PPUSH
70193: LD_VAR 0 4
70197: PPUSH
70198: LD_EXP 81
70202: PUSH
70203: LD_VAR 0 2
70207: ARRAY
70208: PPUSH
70209: CALL 15659 0 3
// exit ;
70213: POP
70214: POP
70215: GO 70221
// end ; end ;
70217: GO 69632
70219: POP
70220: POP
// end ;
70221: LD_VAR 0 1
70225: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70226: LD_INT 0
70228: PPUSH
70229: PPUSH
70230: PPUSH
70231: PPUSH
70232: PPUSH
70233: PPUSH
70234: PPUSH
70235: PPUSH
70236: PPUSH
70237: PPUSH
70238: PPUSH
// if not mc_bases then
70239: LD_EXP 58
70243: NOT
70244: IFFALSE 70248
// exit ;
70246: GO 71308
// for i = 1 to mc_bases do
70248: LD_ADDR_VAR 0 2
70252: PUSH
70253: DOUBLE
70254: LD_INT 1
70256: DEC
70257: ST_TO_ADDR
70258: LD_EXP 58
70262: PUSH
70263: FOR_TO
70264: IFFALSE 71306
// begin tmp := mc_lab [ i ] ;
70266: LD_ADDR_VAR 0 6
70270: PUSH
70271: LD_EXP 91
70275: PUSH
70276: LD_VAR 0 2
70280: ARRAY
70281: ST_TO_ADDR
// if not tmp then
70282: LD_VAR 0 6
70286: NOT
70287: IFFALSE 70291
// continue ;
70289: GO 70263
// idle_lab := 0 ;
70291: LD_ADDR_VAR 0 11
70295: PUSH
70296: LD_INT 0
70298: ST_TO_ADDR
// for j in tmp do
70299: LD_ADDR_VAR 0 3
70303: PUSH
70304: LD_VAR 0 6
70308: PUSH
70309: FOR_IN
70310: IFFALSE 71302
// begin researching := false ;
70312: LD_ADDR_VAR 0 10
70316: PUSH
70317: LD_INT 0
70319: ST_TO_ADDR
// side := GetSide ( j ) ;
70320: LD_ADDR_VAR 0 4
70324: PUSH
70325: LD_VAR 0 3
70329: PPUSH
70330: CALL_OW 255
70334: ST_TO_ADDR
// if not mc_tech [ side ] then
70335: LD_EXP 85
70339: PUSH
70340: LD_VAR 0 4
70344: ARRAY
70345: NOT
70346: IFFALSE 70350
// continue ;
70348: GO 70309
// if BuildingStatus ( j ) = bs_idle then
70350: LD_VAR 0 3
70354: PPUSH
70355: CALL_OW 461
70359: PUSH
70360: LD_INT 2
70362: EQUAL
70363: IFFALSE 70536
// begin if idle_lab then
70365: LD_VAR 0 11
70369: IFFALSE 70440
// begin tmp2 := UnitsInside ( idle_lab ) ;
70371: LD_ADDR_VAR 0 9
70375: PUSH
70376: LD_VAR 0 11
70380: PPUSH
70381: CALL_OW 313
70385: ST_TO_ADDR
// if tmp2 then
70386: LD_VAR 0 9
70390: IFFALSE 70432
// for x in tmp2 do
70392: LD_ADDR_VAR 0 7
70396: PUSH
70397: LD_VAR 0 9
70401: PUSH
70402: FOR_IN
70403: IFFALSE 70430
// begin ComExitBuilding ( x ) ;
70405: LD_VAR 0 7
70409: PPUSH
70410: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
70414: LD_VAR 0 7
70418: PPUSH
70419: LD_VAR 0 3
70423: PPUSH
70424: CALL_OW 180
// end ;
70428: GO 70402
70430: POP
70431: POP
// idle_lab := 0 ;
70432: LD_ADDR_VAR 0 11
70436: PUSH
70437: LD_INT 0
70439: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
70440: LD_ADDR_VAR 0 5
70444: PUSH
70445: LD_EXP 85
70449: PUSH
70450: LD_VAR 0 4
70454: ARRAY
70455: PUSH
70456: FOR_IN
70457: IFFALSE 70517
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
70459: LD_VAR 0 3
70463: PPUSH
70464: LD_VAR 0 5
70468: PPUSH
70469: CALL_OW 430
70473: PUSH
70474: LD_VAR 0 4
70478: PPUSH
70479: LD_VAR 0 5
70483: PPUSH
70484: CALL 14231 0 2
70488: AND
70489: IFFALSE 70515
// begin researching := true ;
70491: LD_ADDR_VAR 0 10
70495: PUSH
70496: LD_INT 1
70498: ST_TO_ADDR
// ComResearch ( j , t ) ;
70499: LD_VAR 0 3
70503: PPUSH
70504: LD_VAR 0 5
70508: PPUSH
70509: CALL_OW 124
// break ;
70513: GO 70517
// end ;
70515: GO 70456
70517: POP
70518: POP
// if not researching then
70519: LD_VAR 0 10
70523: NOT
70524: IFFALSE 70536
// idle_lab := j ;
70526: LD_ADDR_VAR 0 11
70530: PUSH
70531: LD_VAR 0 3
70535: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
70536: LD_VAR 0 3
70540: PPUSH
70541: CALL_OW 461
70545: PUSH
70546: LD_INT 10
70548: EQUAL
70549: IFFALSE 71137
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
70551: LD_EXP 87
70555: PUSH
70556: LD_VAR 0 2
70560: ARRAY
70561: NOT
70562: PUSH
70563: LD_EXP 88
70567: PUSH
70568: LD_VAR 0 2
70572: ARRAY
70573: NOT
70574: AND
70575: PUSH
70576: LD_EXP 85
70580: PUSH
70581: LD_VAR 0 4
70585: ARRAY
70586: PUSH
70587: LD_INT 1
70589: GREATER
70590: AND
70591: IFFALSE 70722
// begin ComCancel ( j ) ;
70593: LD_VAR 0 3
70597: PPUSH
70598: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
70602: LD_ADDR_EXP 85
70606: PUSH
70607: LD_EXP 85
70611: PPUSH
70612: LD_VAR 0 4
70616: PPUSH
70617: LD_EXP 85
70621: PUSH
70622: LD_VAR 0 4
70626: ARRAY
70627: PPUSH
70628: LD_EXP 85
70632: PUSH
70633: LD_VAR 0 4
70637: ARRAY
70638: PUSH
70639: LD_INT 1
70641: MINUS
70642: PPUSH
70643: LD_EXP 85
70647: PUSH
70648: LD_VAR 0 4
70652: ARRAY
70653: PPUSH
70654: LD_INT 0
70656: PPUSH
70657: CALL 19680 0 4
70661: PPUSH
70662: CALL_OW 1
70666: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
70667: LD_ADDR_EXP 85
70671: PUSH
70672: LD_EXP 85
70676: PPUSH
70677: LD_VAR 0 4
70681: PPUSH
70682: LD_EXP 85
70686: PUSH
70687: LD_VAR 0 4
70691: ARRAY
70692: PPUSH
70693: LD_EXP 85
70697: PUSH
70698: LD_VAR 0 4
70702: ARRAY
70703: PPUSH
70704: LD_INT 1
70706: PPUSH
70707: LD_INT 0
70709: PPUSH
70710: CALL 19680 0 4
70714: PPUSH
70715: CALL_OW 1
70719: ST_TO_ADDR
// continue ;
70720: GO 70309
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
70722: LD_EXP 87
70726: PUSH
70727: LD_VAR 0 2
70731: ARRAY
70732: PUSH
70733: LD_EXP 88
70737: PUSH
70738: LD_VAR 0 2
70742: ARRAY
70743: NOT
70744: AND
70745: IFFALSE 70872
// begin mc_ape_in_lab := Add ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
70747: LD_ADDR_EXP 88
70751: PUSH
70752: LD_EXP 88
70756: PPUSH
70757: LD_VAR 0 2
70761: PUSH
70762: LD_EXP 88
70766: PUSH
70767: LD_VAR 0 2
70771: ARRAY
70772: PUSH
70773: LD_INT 1
70775: PLUS
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PPUSH
70781: LD_EXP 87
70785: PUSH
70786: LD_VAR 0 2
70790: ARRAY
70791: PUSH
70792: LD_INT 1
70794: ARRAY
70795: PPUSH
70796: CALL 20697 0 3
70800: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
70801: LD_EXP 87
70805: PUSH
70806: LD_VAR 0 2
70810: ARRAY
70811: PUSH
70812: LD_INT 1
70814: ARRAY
70815: PPUSH
70816: LD_INT 112
70818: PPUSH
70819: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
70823: LD_ADDR_VAR 0 9
70827: PUSH
70828: LD_EXP 87
70832: PUSH
70833: LD_VAR 0 2
70837: ARRAY
70838: PPUSH
70839: LD_INT 1
70841: PPUSH
70842: CALL_OW 3
70846: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
70847: LD_ADDR_EXP 87
70851: PUSH
70852: LD_EXP 87
70856: PPUSH
70857: LD_VAR 0 2
70861: PPUSH
70862: LD_VAR 0 9
70866: PPUSH
70867: CALL_OW 1
70871: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
70872: LD_EXP 87
70876: PUSH
70877: LD_VAR 0 2
70881: ARRAY
70882: PUSH
70883: LD_EXP 88
70887: PUSH
70888: LD_VAR 0 2
70892: ARRAY
70893: AND
70894: PUSH
70895: LD_EXP 88
70899: PUSH
70900: LD_VAR 0 2
70904: ARRAY
70905: PUSH
70906: LD_INT 1
70908: ARRAY
70909: PPUSH
70910: CALL_OW 310
70914: NOT
70915: AND
70916: PUSH
70917: LD_VAR 0 3
70921: PPUSH
70922: CALL_OW 313
70926: PUSH
70927: LD_INT 6
70929: EQUAL
70930: AND
70931: IFFALSE 70987
// begin tmp2 := UnitsInside ( j ) ;
70933: LD_ADDR_VAR 0 9
70937: PUSH
70938: LD_VAR 0 3
70942: PPUSH
70943: CALL_OW 313
70947: ST_TO_ADDR
// if tmp2 = 6 then
70948: LD_VAR 0 9
70952: PUSH
70953: LD_INT 6
70955: EQUAL
70956: IFFALSE 70987
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
70958: LD_VAR 0 9
70962: PUSH
70963: LD_INT 1
70965: ARRAY
70966: PPUSH
70967: LD_INT 112
70969: PPUSH
70970: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
70974: LD_VAR 0 9
70978: PUSH
70979: LD_INT 1
70981: ARRAY
70982: PPUSH
70983: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
70987: LD_EXP 88
70991: PUSH
70992: LD_VAR 0 2
70996: ARRAY
70997: PUSH
70998: LD_EXP 88
71002: PUSH
71003: LD_VAR 0 2
71007: ARRAY
71008: PUSH
71009: LD_INT 1
71011: ARRAY
71012: PPUSH
71013: CALL_OW 314
71017: NOT
71018: AND
71019: PUSH
71020: LD_EXP 88
71024: PUSH
71025: LD_VAR 0 2
71029: ARRAY
71030: PUSH
71031: LD_INT 1
71033: ARRAY
71034: PPUSH
71035: CALL_OW 310
71039: NOT
71040: AND
71041: IFFALSE 71067
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71043: LD_EXP 88
71047: PUSH
71048: LD_VAR 0 2
71052: ARRAY
71053: PUSH
71054: LD_INT 1
71056: ARRAY
71057: PPUSH
71058: LD_VAR 0 3
71062: PPUSH
71063: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71067: LD_EXP 88
71071: PUSH
71072: LD_VAR 0 2
71076: ARRAY
71077: PUSH
71078: LD_INT 1
71080: ARRAY
71081: PPUSH
71082: CALL_OW 310
71086: PUSH
71087: LD_EXP 88
71091: PUSH
71092: LD_VAR 0 2
71096: ARRAY
71097: PUSH
71098: LD_INT 1
71100: ARRAY
71101: PPUSH
71102: CALL_OW 310
71106: PPUSH
71107: CALL_OW 461
71111: PUSH
71112: LD_INT 3
71114: NONEQUAL
71115: AND
71116: IFFALSE 71137
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71118: LD_EXP 88
71122: PUSH
71123: LD_VAR 0 2
71127: ARRAY
71128: PUSH
71129: LD_INT 1
71131: ARRAY
71132: PPUSH
71133: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71137: LD_VAR 0 3
71141: PPUSH
71142: CALL_OW 461
71146: PUSH
71147: LD_INT 6
71149: EQUAL
71150: PUSH
71151: LD_VAR 0 6
71155: PUSH
71156: LD_INT 1
71158: GREATER
71159: AND
71160: IFFALSE 71300
// begin sci := [ ] ;
71162: LD_ADDR_VAR 0 8
71166: PUSH
71167: EMPTY
71168: ST_TO_ADDR
// for x in tmp diff j do
71169: LD_ADDR_VAR 0 7
71173: PUSH
71174: LD_VAR 0 6
71178: PUSH
71179: LD_VAR 0 3
71183: DIFF
71184: PUSH
71185: FOR_IN
71186: IFFALSE 71226
// begin if BuildingStatus ( x ) = bs_idle then
71188: LD_VAR 0 7
71192: PPUSH
71193: CALL_OW 461
71197: PUSH
71198: LD_INT 2
71200: EQUAL
71201: IFFALSE 71224
// sci := sci ^ UnitsInside ( x ) ;
71203: LD_ADDR_VAR 0 8
71207: PUSH
71208: LD_VAR 0 8
71212: PUSH
71213: LD_VAR 0 7
71217: PPUSH
71218: CALL_OW 313
71222: ADD
71223: ST_TO_ADDR
// end ;
71224: GO 71185
71226: POP
71227: POP
// if not sci then
71228: LD_VAR 0 8
71232: NOT
71233: IFFALSE 71237
// continue ;
71235: GO 70309
// for x in sci do
71237: LD_ADDR_VAR 0 7
71241: PUSH
71242: LD_VAR 0 8
71246: PUSH
71247: FOR_IN
71248: IFFALSE 71298
// if IsInUnit ( x ) and not HasTask ( x ) then
71250: LD_VAR 0 7
71254: PPUSH
71255: CALL_OW 310
71259: PUSH
71260: LD_VAR 0 7
71264: PPUSH
71265: CALL_OW 314
71269: NOT
71270: AND
71271: IFFALSE 71296
// begin ComExitBuilding ( x ) ;
71273: LD_VAR 0 7
71277: PPUSH
71278: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71282: LD_VAR 0 7
71286: PPUSH
71287: LD_VAR 0 3
71291: PPUSH
71292: CALL_OW 180
// end ;
71296: GO 71247
71298: POP
71299: POP
// end ; end ;
71300: GO 70309
71302: POP
71303: POP
// end ;
71304: GO 70263
71306: POP
71307: POP
// end ;
71308: LD_VAR 0 1
71312: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
71313: LD_INT 0
71315: PPUSH
71316: PPUSH
// if not mc_bases then
71317: LD_EXP 58
71321: NOT
71322: IFFALSE 71326
// exit ;
71324: GO 71407
// for i = 1 to mc_bases do
71326: LD_ADDR_VAR 0 2
71330: PUSH
71331: DOUBLE
71332: LD_INT 1
71334: DEC
71335: ST_TO_ADDR
71336: LD_EXP 58
71340: PUSH
71341: FOR_TO
71342: IFFALSE 71405
// if mc_mines [ i ] and mc_miners [ i ] then
71344: LD_EXP 71
71348: PUSH
71349: LD_VAR 0 2
71353: ARRAY
71354: PUSH
71355: LD_EXP 72
71359: PUSH
71360: LD_VAR 0 2
71364: ARRAY
71365: AND
71366: IFFALSE 71403
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
71368: LD_EXP 72
71372: PUSH
71373: LD_VAR 0 2
71377: ARRAY
71378: PUSH
71379: LD_INT 1
71381: ARRAY
71382: PPUSH
71383: CALL_OW 255
71387: PPUSH
71388: LD_EXP 71
71392: PUSH
71393: LD_VAR 0 2
71397: ARRAY
71398: PPUSH
71399: CALL 17319 0 2
71403: GO 71341
71405: POP
71406: POP
// end ;
71407: LD_VAR 0 1
71411: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
71412: LD_INT 0
71414: PPUSH
71415: PPUSH
71416: PPUSH
71417: PPUSH
71418: PPUSH
71419: PPUSH
71420: PPUSH
71421: PPUSH
// if not mc_bases or not mc_parking then
71422: LD_EXP 58
71426: NOT
71427: PUSH
71428: LD_EXP 82
71432: NOT
71433: OR
71434: IFFALSE 71438
// exit ;
71436: GO 72150
// for i = 1 to mc_bases do
71438: LD_ADDR_VAR 0 2
71442: PUSH
71443: DOUBLE
71444: LD_INT 1
71446: DEC
71447: ST_TO_ADDR
71448: LD_EXP 58
71452: PUSH
71453: FOR_TO
71454: IFFALSE 72148
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
71456: LD_EXP 58
71460: PUSH
71461: LD_VAR 0 2
71465: ARRAY
71466: NOT
71467: PUSH
71468: LD_EXP 82
71472: PUSH
71473: LD_VAR 0 2
71477: ARRAY
71478: NOT
71479: OR
71480: IFFALSE 71484
// continue ;
71482: GO 71453
// if mc_scan [ i ] then
71484: LD_EXP 81
71488: PUSH
71489: LD_VAR 0 2
71493: ARRAY
71494: IFFALSE 71520
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71496: LD_ADDR_EXP 70
71500: PUSH
71501: LD_EXP 70
71505: PPUSH
71506: LD_VAR 0 2
71510: PPUSH
71511: EMPTY
71512: PPUSH
71513: CALL_OW 1
71517: ST_TO_ADDR
// continue ;
71518: GO 71453
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
71520: LD_ADDR_VAR 0 5
71524: PUSH
71525: LD_EXP 58
71529: PUSH
71530: LD_VAR 0 2
71534: ARRAY
71535: PUSH
71536: LD_INT 1
71538: ARRAY
71539: PPUSH
71540: CALL_OW 255
71544: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71545: LD_ADDR_VAR 0 6
71549: PUSH
71550: LD_EXP 58
71554: PUSH
71555: LD_VAR 0 2
71559: ARRAY
71560: PPUSH
71561: LD_INT 30
71563: PUSH
71564: LD_INT 3
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PPUSH
71571: CALL_OW 72
71575: ST_TO_ADDR
// if not fac then
71576: LD_VAR 0 6
71580: NOT
71581: IFFALSE 71632
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71583: LD_ADDR_VAR 0 6
71587: PUSH
71588: LD_EXP 58
71592: PUSH
71593: LD_VAR 0 2
71597: ARRAY
71598: PPUSH
71599: LD_INT 2
71601: PUSH
71602: LD_INT 30
71604: PUSH
71605: LD_INT 0
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 30
71614: PUSH
71615: LD_INT 1
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: LIST
71626: PPUSH
71627: CALL_OW 72
71631: ST_TO_ADDR
// if not fac then
71632: LD_VAR 0 6
71636: NOT
71637: IFFALSE 71641
// continue ;
71639: GO 71453
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
71641: LD_ADDR_VAR 0 7
71645: PUSH
71646: LD_EXP 82
71650: PUSH
71651: LD_VAR 0 2
71655: ARRAY
71656: PPUSH
71657: LD_INT 22
71659: PUSH
71660: LD_VAR 0 5
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 21
71671: PUSH
71672: LD_INT 2
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: PUSH
71679: LD_INT 3
71681: PUSH
71682: LD_INT 24
71684: PUSH
71685: LD_INT 1000
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: EMPTY
71693: LIST
71694: LIST
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: LIST
71700: PPUSH
71701: CALL_OW 70
71705: PUSH
71706: LD_INT 22
71708: PUSH
71709: LD_VAR 0 5
71713: PUSH
71714: EMPTY
71715: LIST
71716: LIST
71717: PUSH
71718: LD_INT 91
71720: PUSH
71721: LD_VAR 0 6
71725: PUSH
71726: LD_INT 1
71728: ARRAY
71729: PUSH
71730: LD_INT 25
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 21
71740: PUSH
71741: LD_INT 2
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 3
71750: PUSH
71751: LD_INT 24
71753: PUSH
71754: LD_INT 1000
71756: PUSH
71757: EMPTY
71758: LIST
71759: LIST
71760: PUSH
71761: EMPTY
71762: LIST
71763: LIST
71764: PUSH
71765: EMPTY
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: PPUSH
71771: CALL_OW 69
71775: UNION
71776: ST_TO_ADDR
// if not vehs then
71777: LD_VAR 0 7
71781: NOT
71782: IFFALSE 71808
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
71784: LD_ADDR_EXP 70
71788: PUSH
71789: LD_EXP 70
71793: PPUSH
71794: LD_VAR 0 2
71798: PPUSH
71799: EMPTY
71800: PPUSH
71801: CALL_OW 1
71805: ST_TO_ADDR
// continue ;
71806: GO 71453
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71808: LD_ADDR_VAR 0 8
71812: PUSH
71813: LD_EXP 58
71817: PUSH
71818: LD_VAR 0 2
71822: ARRAY
71823: PPUSH
71824: LD_INT 30
71826: PUSH
71827: LD_INT 3
71829: PUSH
71830: EMPTY
71831: LIST
71832: LIST
71833: PPUSH
71834: CALL_OW 72
71838: ST_TO_ADDR
// if tmp then
71839: LD_VAR 0 8
71843: IFFALSE 71946
// begin for j in tmp do
71845: LD_ADDR_VAR 0 3
71849: PUSH
71850: LD_VAR 0 8
71854: PUSH
71855: FOR_IN
71856: IFFALSE 71944
// for k in UnitsInside ( j ) do
71858: LD_ADDR_VAR 0 4
71862: PUSH
71863: LD_VAR 0 3
71867: PPUSH
71868: CALL_OW 313
71872: PUSH
71873: FOR_IN
71874: IFFALSE 71940
// if k then
71876: LD_VAR 0 4
71880: IFFALSE 71938
// if not k in mc_repair_vehicle [ i ] then
71882: LD_VAR 0 4
71886: PUSH
71887: LD_EXP 70
71891: PUSH
71892: LD_VAR 0 2
71896: ARRAY
71897: IN
71898: NOT
71899: IFFALSE 71938
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
71901: LD_ADDR_EXP 70
71905: PUSH
71906: LD_EXP 70
71910: PPUSH
71911: LD_VAR 0 2
71915: PPUSH
71916: LD_EXP 70
71920: PUSH
71921: LD_VAR 0 2
71925: ARRAY
71926: PUSH
71927: LD_VAR 0 4
71931: UNION
71932: PPUSH
71933: CALL_OW 1
71937: ST_TO_ADDR
71938: GO 71873
71940: POP
71941: POP
71942: GO 71855
71944: POP
71945: POP
// end ; if not mc_repair_vehicle [ i ] then
71946: LD_EXP 70
71950: PUSH
71951: LD_VAR 0 2
71955: ARRAY
71956: NOT
71957: IFFALSE 71961
// continue ;
71959: GO 71453
// for j in mc_repair_vehicle [ i ] do
71961: LD_ADDR_VAR 0 3
71965: PUSH
71966: LD_EXP 70
71970: PUSH
71971: LD_VAR 0 2
71975: ARRAY
71976: PUSH
71977: FOR_IN
71978: IFFALSE 72144
// begin if GetClass ( j ) <> 3 then
71980: LD_VAR 0 3
71984: PPUSH
71985: CALL_OW 257
71989: PUSH
71990: LD_INT 3
71992: NONEQUAL
71993: IFFALSE 72034
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
71995: LD_ADDR_EXP 70
71999: PUSH
72000: LD_EXP 70
72004: PPUSH
72005: LD_VAR 0 2
72009: PPUSH
72010: LD_EXP 70
72014: PUSH
72015: LD_VAR 0 2
72019: ARRAY
72020: PUSH
72021: LD_VAR 0 3
72025: DIFF
72026: PPUSH
72027: CALL_OW 1
72031: ST_TO_ADDR
// continue ;
72032: GO 71977
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72034: LD_VAR 0 3
72038: PPUSH
72039: CALL_OW 311
72043: NOT
72044: PUSH
72045: LD_VAR 0 3
72049: PUSH
72050: LD_EXP 61
72054: PUSH
72055: LD_VAR 0 2
72059: ARRAY
72060: PUSH
72061: LD_INT 1
72063: ARRAY
72064: IN
72065: NOT
72066: AND
72067: PUSH
72068: LD_VAR 0 3
72072: PUSH
72073: LD_EXP 61
72077: PUSH
72078: LD_VAR 0 2
72082: ARRAY
72083: PUSH
72084: LD_INT 2
72086: ARRAY
72087: IN
72088: NOT
72089: AND
72090: IFFALSE 72142
// begin if IsInUnit ( j ) then
72092: LD_VAR 0 3
72096: PPUSH
72097: CALL_OW 310
72101: IFFALSE 72112
// ComExitBuilding ( j ) ;
72103: LD_VAR 0 3
72107: PPUSH
72108: CALL_OW 122
// if not HasTask ( j ) then
72112: LD_VAR 0 3
72116: PPUSH
72117: CALL_OW 314
72121: NOT
72122: IFFALSE 72142
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
72124: LD_VAR 0 3
72128: PPUSH
72129: LD_VAR 0 7
72133: PUSH
72134: LD_INT 1
72136: ARRAY
72137: PPUSH
72138: CALL_OW 189
// end ; end ;
72142: GO 71977
72144: POP
72145: POP
// end ;
72146: GO 71453
72148: POP
72149: POP
// end ;
72150: LD_VAR 0 1
72154: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72155: LD_INT 0
72157: PPUSH
72158: PPUSH
72159: PPUSH
72160: PPUSH
72161: PPUSH
72162: PPUSH
72163: PPUSH
72164: PPUSH
72165: PPUSH
72166: PPUSH
72167: PPUSH
// if not mc_bases then
72168: LD_EXP 58
72172: NOT
72173: IFFALSE 72177
// exit ;
72175: GO 72979
// for i = 1 to mc_bases do
72177: LD_ADDR_VAR 0 2
72181: PUSH
72182: DOUBLE
72183: LD_INT 1
72185: DEC
72186: ST_TO_ADDR
72187: LD_EXP 58
72191: PUSH
72192: FOR_TO
72193: IFFALSE 72977
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72195: LD_EXP 86
72199: PUSH
72200: LD_VAR 0 2
72204: ARRAY
72205: NOT
72206: PUSH
72207: LD_EXP 61
72211: PUSH
72212: LD_VAR 0 2
72216: ARRAY
72217: PUSH
72218: LD_INT 1
72220: ARRAY
72221: OR
72222: PUSH
72223: LD_EXP 61
72227: PUSH
72228: LD_VAR 0 2
72232: ARRAY
72233: PUSH
72234: LD_INT 2
72236: ARRAY
72237: OR
72238: PUSH
72239: LD_EXP 84
72243: PUSH
72244: LD_VAR 0 2
72248: ARRAY
72249: PPUSH
72250: LD_INT 1
72252: PPUSH
72253: CALL_OW 325
72257: NOT
72258: OR
72259: PUSH
72260: LD_EXP 81
72264: PUSH
72265: LD_VAR 0 2
72269: ARRAY
72270: OR
72271: IFFALSE 72275
// continue ;
72273: GO 72192
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
72275: LD_ADDR_VAR 0 8
72279: PUSH
72280: LD_EXP 58
72284: PUSH
72285: LD_VAR 0 2
72289: ARRAY
72290: PPUSH
72291: LD_INT 25
72293: PUSH
72294: LD_INT 4
72296: PUSH
72297: EMPTY
72298: LIST
72299: LIST
72300: PUSH
72301: LD_INT 50
72303: PUSH
72304: EMPTY
72305: LIST
72306: PUSH
72307: LD_INT 3
72309: PUSH
72310: LD_INT 60
72312: PUSH
72313: EMPTY
72314: LIST
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PUSH
72320: EMPTY
72321: LIST
72322: LIST
72323: LIST
72324: PPUSH
72325: CALL_OW 72
72329: PUSH
72330: LD_EXP 62
72334: PUSH
72335: LD_VAR 0 2
72339: ARRAY
72340: DIFF
72341: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72342: LD_ADDR_VAR 0 9
72346: PUSH
72347: LD_EXP 58
72351: PUSH
72352: LD_VAR 0 2
72356: ARRAY
72357: PPUSH
72358: LD_INT 2
72360: PUSH
72361: LD_INT 30
72363: PUSH
72364: LD_INT 0
72366: PUSH
72367: EMPTY
72368: LIST
72369: LIST
72370: PUSH
72371: LD_INT 30
72373: PUSH
72374: LD_INT 1
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: LIST
72385: PPUSH
72386: CALL_OW 72
72390: ST_TO_ADDR
// if not tmp or not dep then
72391: LD_VAR 0 8
72395: NOT
72396: PUSH
72397: LD_VAR 0 9
72401: NOT
72402: OR
72403: IFFALSE 72407
// continue ;
72405: GO 72192
// side := GetSide ( tmp [ 1 ] ) ;
72407: LD_ADDR_VAR 0 11
72411: PUSH
72412: LD_VAR 0 8
72416: PUSH
72417: LD_INT 1
72419: ARRAY
72420: PPUSH
72421: CALL_OW 255
72425: ST_TO_ADDR
// dep := dep [ 1 ] ;
72426: LD_ADDR_VAR 0 9
72430: PUSH
72431: LD_VAR 0 9
72435: PUSH
72436: LD_INT 1
72438: ARRAY
72439: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
72440: LD_ADDR_VAR 0 7
72444: PUSH
72445: LD_EXP 86
72449: PUSH
72450: LD_VAR 0 2
72454: ARRAY
72455: PPUSH
72456: LD_INT 22
72458: PUSH
72459: LD_INT 0
72461: PUSH
72462: EMPTY
72463: LIST
72464: LIST
72465: PUSH
72466: LD_INT 25
72468: PUSH
72469: LD_INT 12
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: PUSH
72476: EMPTY
72477: LIST
72478: LIST
72479: PPUSH
72480: CALL_OW 70
72484: PUSH
72485: LD_INT 22
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: EMPTY
72492: LIST
72493: LIST
72494: PUSH
72495: LD_INT 25
72497: PUSH
72498: LD_INT 12
72500: PUSH
72501: EMPTY
72502: LIST
72503: LIST
72504: PUSH
72505: LD_INT 91
72507: PUSH
72508: LD_VAR 0 9
72512: PUSH
72513: LD_INT 20
72515: PUSH
72516: EMPTY
72517: LIST
72518: LIST
72519: LIST
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: LIST
72525: PPUSH
72526: CALL_OW 69
72530: UNION
72531: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
72532: LD_ADDR_VAR 0 10
72536: PUSH
72537: LD_EXP 86
72541: PUSH
72542: LD_VAR 0 2
72546: ARRAY
72547: PPUSH
72548: LD_INT 81
72550: PUSH
72551: LD_VAR 0 11
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PPUSH
72560: CALL_OW 70
72564: ST_TO_ADDR
// if not apes or danger_at_area then
72565: LD_VAR 0 7
72569: NOT
72570: PUSH
72571: LD_VAR 0 10
72575: OR
72576: IFFALSE 72626
// begin if mc_taming [ i ] then
72578: LD_EXP 89
72582: PUSH
72583: LD_VAR 0 2
72587: ARRAY
72588: IFFALSE 72624
// begin MC_Reset ( i , 121 ) ;
72590: LD_VAR 0 2
72594: PPUSH
72595: LD_INT 121
72597: PPUSH
72598: CALL 58649 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
72602: LD_ADDR_EXP 89
72606: PUSH
72607: LD_EXP 89
72611: PPUSH
72612: LD_VAR 0 2
72616: PPUSH
72617: EMPTY
72618: PPUSH
72619: CALL_OW 1
72623: ST_TO_ADDR
// end ; continue ;
72624: GO 72192
// end ; for j in tmp do
72626: LD_ADDR_VAR 0 3
72630: PUSH
72631: LD_VAR 0 8
72635: PUSH
72636: FOR_IN
72637: IFFALSE 72973
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
72639: LD_VAR 0 3
72643: PUSH
72644: LD_EXP 89
72648: PUSH
72649: LD_VAR 0 2
72653: ARRAY
72654: IN
72655: NOT
72656: PUSH
72657: LD_EXP 89
72661: PUSH
72662: LD_VAR 0 2
72666: ARRAY
72667: PUSH
72668: LD_INT 3
72670: LESS
72671: AND
72672: IFFALSE 72730
// begin SetTag ( j , 121 ) ;
72674: LD_VAR 0 3
72678: PPUSH
72679: LD_INT 121
72681: PPUSH
72682: CALL_OW 109
// mc_taming := Add ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
72686: LD_ADDR_EXP 89
72690: PUSH
72691: LD_EXP 89
72695: PPUSH
72696: LD_VAR 0 2
72700: PUSH
72701: LD_EXP 89
72705: PUSH
72706: LD_VAR 0 2
72710: ARRAY
72711: PUSH
72712: LD_INT 1
72714: PLUS
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PPUSH
72720: LD_VAR 0 3
72724: PPUSH
72725: CALL 20697 0 3
72729: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
72730: LD_VAR 0 3
72734: PUSH
72735: LD_EXP 89
72739: PUSH
72740: LD_VAR 0 2
72744: ARRAY
72745: IN
72746: IFFALSE 72971
// begin if GetClass ( j ) <> 4 then
72748: LD_VAR 0 3
72752: PPUSH
72753: CALL_OW 257
72757: PUSH
72758: LD_INT 4
72760: NONEQUAL
72761: IFFALSE 72814
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
72763: LD_ADDR_EXP 89
72767: PUSH
72768: LD_EXP 89
72772: PPUSH
72773: LD_VAR 0 2
72777: PPUSH
72778: LD_EXP 89
72782: PUSH
72783: LD_VAR 0 2
72787: ARRAY
72788: PUSH
72789: LD_VAR 0 3
72793: DIFF
72794: PPUSH
72795: CALL_OW 1
72799: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72800: LD_VAR 0 3
72804: PPUSH
72805: LD_INT 0
72807: PPUSH
72808: CALL_OW 109
// continue ;
72812: GO 72636
// end ; if IsInUnit ( j ) then
72814: LD_VAR 0 3
72818: PPUSH
72819: CALL_OW 310
72823: IFFALSE 72834
// ComExitBuilding ( j ) ;
72825: LD_VAR 0 3
72829: PPUSH
72830: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
72834: LD_ADDR_VAR 0 6
72838: PUSH
72839: LD_VAR 0 7
72843: PPUSH
72844: LD_VAR 0 3
72848: PPUSH
72849: CALL_OW 74
72853: ST_TO_ADDR
// if not ape then
72854: LD_VAR 0 6
72858: NOT
72859: IFFALSE 72863
// break ;
72861: GO 72973
// x := GetX ( ape ) ;
72863: LD_ADDR_VAR 0 4
72867: PUSH
72868: LD_VAR 0 6
72872: PPUSH
72873: CALL_OW 250
72877: ST_TO_ADDR
// y := GetY ( ape ) ;
72878: LD_ADDR_VAR 0 5
72882: PUSH
72883: LD_VAR 0 6
72887: PPUSH
72888: CALL_OW 251
72892: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
72893: LD_VAR 0 4
72897: PPUSH
72898: LD_VAR 0 5
72902: PPUSH
72903: CALL_OW 488
72907: NOT
72908: PUSH
72909: LD_VAR 0 11
72913: PPUSH
72914: LD_VAR 0 4
72918: PPUSH
72919: LD_VAR 0 5
72923: PPUSH
72924: LD_INT 20
72926: PPUSH
72927: CALL 21191 0 4
72931: PUSH
72932: LD_INT 4
72934: ARRAY
72935: OR
72936: IFFALSE 72940
// break ;
72938: GO 72973
// if not HasTask ( j ) then
72940: LD_VAR 0 3
72944: PPUSH
72945: CALL_OW 314
72949: NOT
72950: IFFALSE 72971
// ComTameXY ( j , x , y ) ;
72952: LD_VAR 0 3
72956: PPUSH
72957: LD_VAR 0 4
72961: PPUSH
72962: LD_VAR 0 5
72966: PPUSH
72967: CALL_OW 131
// end ; end ;
72971: GO 72636
72973: POP
72974: POP
// end ;
72975: GO 72192
72977: POP
72978: POP
// end ;
72979: LD_VAR 0 1
72983: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
72984: LD_INT 0
72986: PPUSH
72987: PPUSH
72988: PPUSH
72989: PPUSH
72990: PPUSH
72991: PPUSH
72992: PPUSH
72993: PPUSH
// if not mc_bases then
72994: LD_EXP 58
72998: NOT
72999: IFFALSE 73003
// exit ;
73001: GO 73629
// for i = 1 to mc_bases do
73003: LD_ADDR_VAR 0 2
73007: PUSH
73008: DOUBLE
73009: LD_INT 1
73011: DEC
73012: ST_TO_ADDR
73013: LD_EXP 58
73017: PUSH
73018: FOR_TO
73019: IFFALSE 73627
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73021: LD_EXP 87
73025: PUSH
73026: LD_VAR 0 2
73030: ARRAY
73031: NOT
73032: PUSH
73033: LD_EXP 87
73037: PUSH
73038: LD_VAR 0 2
73042: ARRAY
73043: PPUSH
73044: LD_INT 25
73046: PUSH
73047: LD_INT 12
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PPUSH
73054: CALL_OW 72
73058: NOT
73059: OR
73060: IFFALSE 73064
// continue ;
73062: GO 73018
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73064: LD_ADDR_VAR 0 5
73068: PUSH
73069: LD_EXP 87
73073: PUSH
73074: LD_VAR 0 2
73078: ARRAY
73079: PUSH
73080: LD_INT 1
73082: ARRAY
73083: PPUSH
73084: CALL_OW 255
73088: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73089: LD_VAR 0 5
73093: PPUSH
73094: LD_INT 2
73096: PPUSH
73097: CALL_OW 325
73101: IFFALSE 73354
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73103: LD_ADDR_VAR 0 4
73107: PUSH
73108: LD_EXP 87
73112: PUSH
73113: LD_VAR 0 2
73117: ARRAY
73118: PPUSH
73119: LD_INT 25
73121: PUSH
73122: LD_INT 16
73124: PUSH
73125: EMPTY
73126: LIST
73127: LIST
73128: PPUSH
73129: CALL_OW 72
73133: ST_TO_ADDR
// if tmp < 6 then
73134: LD_VAR 0 4
73138: PUSH
73139: LD_INT 6
73141: LESS
73142: IFFALSE 73354
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73144: LD_ADDR_VAR 0 6
73148: PUSH
73149: LD_EXP 58
73153: PUSH
73154: LD_VAR 0 2
73158: ARRAY
73159: PPUSH
73160: LD_INT 2
73162: PUSH
73163: LD_INT 30
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 30
73175: PUSH
73176: LD_INT 1
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: LIST
73187: PPUSH
73188: CALL_OW 72
73192: ST_TO_ADDR
// if depot then
73193: LD_VAR 0 6
73197: IFFALSE 73354
// begin selected := 0 ;
73199: LD_ADDR_VAR 0 7
73203: PUSH
73204: LD_INT 0
73206: ST_TO_ADDR
// for j in depot do
73207: LD_ADDR_VAR 0 3
73211: PUSH
73212: LD_VAR 0 6
73216: PUSH
73217: FOR_IN
73218: IFFALSE 73249
// begin if UnitsInside ( j ) < 6 then
73220: LD_VAR 0 3
73224: PPUSH
73225: CALL_OW 313
73229: PUSH
73230: LD_INT 6
73232: LESS
73233: IFFALSE 73247
// begin selected := j ;
73235: LD_ADDR_VAR 0 7
73239: PUSH
73240: LD_VAR 0 3
73244: ST_TO_ADDR
// break ;
73245: GO 73249
// end ; end ;
73247: GO 73217
73249: POP
73250: POP
// if selected then
73251: LD_VAR 0 7
73255: IFFALSE 73354
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73257: LD_ADDR_VAR 0 3
73261: PUSH
73262: LD_EXP 87
73266: PUSH
73267: LD_VAR 0 2
73271: ARRAY
73272: PPUSH
73273: LD_INT 25
73275: PUSH
73276: LD_INT 12
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PPUSH
73283: CALL_OW 72
73287: PUSH
73288: FOR_IN
73289: IFFALSE 73352
// if not HasTask ( j ) then
73291: LD_VAR 0 3
73295: PPUSH
73296: CALL_OW 314
73300: NOT
73301: IFFALSE 73350
// begin if not IsInUnit ( j ) then
73303: LD_VAR 0 3
73307: PPUSH
73308: CALL_OW 310
73312: NOT
73313: IFFALSE 73329
// ComEnterUnit ( j , selected ) ;
73315: LD_VAR 0 3
73319: PPUSH
73320: LD_VAR 0 7
73324: PPUSH
73325: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
73329: LD_VAR 0 3
73333: PPUSH
73334: LD_INT 16
73336: PPUSH
73337: CALL_OW 183
// AddComExitBuilding ( j ) ;
73341: LD_VAR 0 3
73345: PPUSH
73346: CALL_OW 182
// end ;
73350: GO 73288
73352: POP
73353: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
73354: LD_VAR 0 5
73358: PPUSH
73359: LD_INT 11
73361: PPUSH
73362: CALL_OW 325
73366: IFFALSE 73625
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73368: LD_ADDR_VAR 0 4
73372: PUSH
73373: LD_EXP 87
73377: PUSH
73378: LD_VAR 0 2
73382: ARRAY
73383: PPUSH
73384: LD_INT 25
73386: PUSH
73387: LD_INT 16
73389: PUSH
73390: EMPTY
73391: LIST
73392: LIST
73393: PPUSH
73394: CALL_OW 72
73398: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
73399: LD_VAR 0 4
73403: PUSH
73404: LD_INT 6
73406: GREATEREQUAL
73407: PUSH
73408: LD_VAR 0 5
73412: PPUSH
73413: LD_INT 2
73415: PPUSH
73416: CALL_OW 325
73420: NOT
73421: OR
73422: IFFALSE 73625
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
73424: LD_ADDR_VAR 0 8
73428: PUSH
73429: LD_EXP 58
73433: PUSH
73434: LD_VAR 0 2
73438: ARRAY
73439: PPUSH
73440: LD_INT 2
73442: PUSH
73443: LD_INT 30
73445: PUSH
73446: LD_INT 4
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: LD_INT 30
73455: PUSH
73456: LD_INT 5
73458: PUSH
73459: EMPTY
73460: LIST
73461: LIST
73462: PUSH
73463: EMPTY
73464: LIST
73465: LIST
73466: LIST
73467: PPUSH
73468: CALL_OW 72
73472: ST_TO_ADDR
// if barracks then
73473: LD_VAR 0 8
73477: IFFALSE 73625
// begin selected := 0 ;
73479: LD_ADDR_VAR 0 7
73483: PUSH
73484: LD_INT 0
73486: ST_TO_ADDR
// for j in barracks do
73487: LD_ADDR_VAR 0 3
73491: PUSH
73492: LD_VAR 0 8
73496: PUSH
73497: FOR_IN
73498: IFFALSE 73529
// begin if UnitsInside ( j ) < 6 then
73500: LD_VAR 0 3
73504: PPUSH
73505: CALL_OW 313
73509: PUSH
73510: LD_INT 6
73512: LESS
73513: IFFALSE 73527
// begin selected := j ;
73515: LD_ADDR_VAR 0 7
73519: PUSH
73520: LD_VAR 0 3
73524: ST_TO_ADDR
// break ;
73525: GO 73529
// end ; end ;
73527: GO 73497
73529: POP
73530: POP
// if selected then
73531: LD_VAR 0 7
73535: IFFALSE 73625
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
73537: LD_ADDR_VAR 0 3
73541: PUSH
73542: LD_EXP 87
73546: PUSH
73547: LD_VAR 0 2
73551: ARRAY
73552: PPUSH
73553: LD_INT 25
73555: PUSH
73556: LD_INT 12
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: PPUSH
73563: CALL_OW 72
73567: PUSH
73568: FOR_IN
73569: IFFALSE 73623
// if not IsInUnit ( j ) and not HasTask ( j ) then
73571: LD_VAR 0 3
73575: PPUSH
73576: CALL_OW 310
73580: NOT
73581: PUSH
73582: LD_VAR 0 3
73586: PPUSH
73587: CALL_OW 314
73591: NOT
73592: AND
73593: IFFALSE 73621
// begin ComEnterUnit ( j , selected ) ;
73595: LD_VAR 0 3
73599: PPUSH
73600: LD_VAR 0 7
73604: PPUSH
73605: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
73609: LD_VAR 0 3
73613: PPUSH
73614: LD_INT 15
73616: PPUSH
73617: CALL_OW 183
// end ;
73621: GO 73568
73623: POP
73624: POP
// end ; end ; end ; end ; end ;
73625: GO 73018
73627: POP
73628: POP
// end ;
73629: LD_VAR 0 1
73633: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
73634: LD_INT 0
73636: PPUSH
73637: PPUSH
73638: PPUSH
73639: PPUSH
// if not mc_bases then
73640: LD_EXP 58
73644: NOT
73645: IFFALSE 73649
// exit ;
73647: GO 73827
// for i = 1 to mc_bases do
73649: LD_ADDR_VAR 0 2
73653: PUSH
73654: DOUBLE
73655: LD_INT 1
73657: DEC
73658: ST_TO_ADDR
73659: LD_EXP 58
73663: PUSH
73664: FOR_TO
73665: IFFALSE 73825
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
73667: LD_ADDR_VAR 0 4
73671: PUSH
73672: LD_EXP 58
73676: PUSH
73677: LD_VAR 0 2
73681: ARRAY
73682: PPUSH
73683: LD_INT 25
73685: PUSH
73686: LD_INT 9
73688: PUSH
73689: EMPTY
73690: LIST
73691: LIST
73692: PPUSH
73693: CALL_OW 72
73697: ST_TO_ADDR
// if not tmp then
73698: LD_VAR 0 4
73702: NOT
73703: IFFALSE 73707
// continue ;
73705: GO 73664
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
73707: LD_EXP 84
73711: PUSH
73712: LD_VAR 0 2
73716: ARRAY
73717: PPUSH
73718: LD_INT 29
73720: PPUSH
73721: CALL_OW 325
73725: NOT
73726: PUSH
73727: LD_EXP 84
73731: PUSH
73732: LD_VAR 0 2
73736: ARRAY
73737: PPUSH
73738: LD_INT 28
73740: PPUSH
73741: CALL_OW 325
73745: NOT
73746: AND
73747: IFFALSE 73751
// continue ;
73749: GO 73664
// for j in tmp do
73751: LD_ADDR_VAR 0 3
73755: PUSH
73756: LD_VAR 0 4
73760: PUSH
73761: FOR_IN
73762: IFFALSE 73821
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73764: LD_VAR 0 3
73768: PUSH
73769: LD_EXP 61
73773: PUSH
73774: LD_VAR 0 2
73778: ARRAY
73779: PUSH
73780: LD_INT 1
73782: ARRAY
73783: IN
73784: NOT
73785: PUSH
73786: LD_VAR 0 3
73790: PUSH
73791: LD_EXP 61
73795: PUSH
73796: LD_VAR 0 2
73800: ARRAY
73801: PUSH
73802: LD_INT 2
73804: ARRAY
73805: IN
73806: NOT
73807: AND
73808: IFFALSE 73819
// ComSpaceTimeShoot ( j ) ;
73810: LD_VAR 0 3
73814: PPUSH
73815: CALL 14322 0 1
73819: GO 73761
73821: POP
73822: POP
// end ;
73823: GO 73664
73825: POP
73826: POP
// end ;
73827: LD_VAR 0 1
73831: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
73832: LD_INT 0
73834: PPUSH
73835: PPUSH
73836: PPUSH
73837: PPUSH
73838: PPUSH
73839: PPUSH
73840: PPUSH
73841: PPUSH
73842: PPUSH
// if not mc_bases then
73843: LD_EXP 58
73847: NOT
73848: IFFALSE 73852
// exit ;
73850: GO 74474
// for i = 1 to mc_bases do
73852: LD_ADDR_VAR 0 2
73856: PUSH
73857: DOUBLE
73858: LD_INT 1
73860: DEC
73861: ST_TO_ADDR
73862: LD_EXP 58
73866: PUSH
73867: FOR_TO
73868: IFFALSE 74472
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
73870: LD_EXP 93
73874: PUSH
73875: LD_VAR 0 2
73879: ARRAY
73880: NOT
73881: PUSH
73882: LD_INT 38
73884: PPUSH
73885: LD_EXP 84
73889: PUSH
73890: LD_VAR 0 2
73894: ARRAY
73895: PPUSH
73896: CALL_OW 321
73900: PUSH
73901: LD_INT 2
73903: NONEQUAL
73904: OR
73905: IFFALSE 73909
// continue ;
73907: GO 73867
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
73909: LD_ADDR_VAR 0 8
73913: PUSH
73914: LD_EXP 58
73918: PUSH
73919: LD_VAR 0 2
73923: ARRAY
73924: PPUSH
73925: LD_INT 30
73927: PUSH
73928: LD_INT 34
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PPUSH
73935: CALL_OW 72
73939: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
73940: LD_ADDR_VAR 0 9
73944: PUSH
73945: LD_EXP 58
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PPUSH
73956: LD_INT 25
73958: PUSH
73959: LD_INT 4
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PPUSH
73966: CALL_OW 72
73970: PPUSH
73971: LD_INT 0
73973: PPUSH
73974: CALL 53305 0 2
73978: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
73979: LD_VAR 0 9
73983: NOT
73984: PUSH
73985: LD_VAR 0 8
73989: NOT
73990: OR
73991: PUSH
73992: LD_EXP 58
73996: PUSH
73997: LD_VAR 0 2
74001: ARRAY
74002: PPUSH
74003: LD_INT 124
74005: PPUSH
74006: CALL 53305 0 2
74010: OR
74011: IFFALSE 74015
// continue ;
74013: GO 73867
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74015: LD_EXP 94
74019: PUSH
74020: LD_VAR 0 2
74024: ARRAY
74025: PUSH
74026: LD_EXP 93
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: LESS
74037: PUSH
74038: LD_EXP 94
74042: PUSH
74043: LD_VAR 0 2
74047: ARRAY
74048: PUSH
74049: LD_VAR 0 8
74053: LESS
74054: AND
74055: IFFALSE 74470
// begin tmp := sci [ 1 ] ;
74057: LD_ADDR_VAR 0 7
74061: PUSH
74062: LD_VAR 0 9
74066: PUSH
74067: LD_INT 1
74069: ARRAY
74070: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74071: LD_VAR 0 7
74075: PPUSH
74076: LD_INT 124
74078: PPUSH
74079: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74083: LD_ADDR_VAR 0 3
74087: PUSH
74088: DOUBLE
74089: LD_EXP 93
74093: PUSH
74094: LD_VAR 0 2
74098: ARRAY
74099: INC
74100: ST_TO_ADDR
74101: LD_EXP 93
74105: PUSH
74106: LD_VAR 0 2
74110: ARRAY
74111: PUSH
74112: FOR_DOWNTO
74113: IFFALSE 74456
// begin if IsInUnit ( tmp ) then
74115: LD_VAR 0 7
74119: PPUSH
74120: CALL_OW 310
74124: IFFALSE 74135
// ComExitBuilding ( tmp ) ;
74126: LD_VAR 0 7
74130: PPUSH
74131: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74135: LD_INT 35
74137: PPUSH
74138: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74142: LD_VAR 0 7
74146: PPUSH
74147: CALL_OW 310
74151: NOT
74152: PUSH
74153: LD_VAR 0 7
74157: PPUSH
74158: CALL_OW 314
74162: NOT
74163: AND
74164: IFFALSE 74135
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74166: LD_ADDR_VAR 0 6
74170: PUSH
74171: LD_VAR 0 7
74175: PPUSH
74176: CALL_OW 250
74180: PUSH
74181: LD_VAR 0 7
74185: PPUSH
74186: CALL_OW 251
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74195: LD_INT 35
74197: PPUSH
74198: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74202: LD_ADDR_VAR 0 4
74206: PUSH
74207: LD_EXP 93
74211: PUSH
74212: LD_VAR 0 2
74216: ARRAY
74217: PUSH
74218: LD_VAR 0 3
74222: ARRAY
74223: PUSH
74224: LD_INT 1
74226: ARRAY
74227: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74228: LD_ADDR_VAR 0 5
74232: PUSH
74233: LD_EXP 93
74237: PUSH
74238: LD_VAR 0 2
74242: ARRAY
74243: PUSH
74244: LD_VAR 0 3
74248: ARRAY
74249: PUSH
74250: LD_INT 2
74252: ARRAY
74253: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
74254: LD_VAR 0 7
74258: PPUSH
74259: LD_INT 10
74261: PPUSH
74262: CALL 22888 0 2
74266: PUSH
74267: LD_INT 4
74269: ARRAY
74270: IFFALSE 74308
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
74272: LD_VAR 0 7
74276: PPUSH
74277: LD_VAR 0 6
74281: PUSH
74282: LD_INT 1
74284: ARRAY
74285: PPUSH
74286: LD_VAR 0 6
74290: PUSH
74291: LD_INT 2
74293: ARRAY
74294: PPUSH
74295: CALL_OW 111
// wait ( 0 0$10 ) ;
74299: LD_INT 350
74301: PPUSH
74302: CALL_OW 67
// end else
74306: GO 74334
// begin ComMoveXY ( tmp , x , y ) ;
74308: LD_VAR 0 7
74312: PPUSH
74313: LD_VAR 0 4
74317: PPUSH
74318: LD_VAR 0 5
74322: PPUSH
74323: CALL_OW 111
// wait ( 0 0$3 ) ;
74327: LD_INT 105
74329: PPUSH
74330: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
74334: LD_VAR 0 7
74338: PPUSH
74339: LD_VAR 0 4
74343: PPUSH
74344: LD_VAR 0 5
74348: PPUSH
74349: CALL_OW 307
74353: IFFALSE 74195
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
74355: LD_VAR 0 7
74359: PPUSH
74360: LD_VAR 0 4
74364: PPUSH
74365: LD_VAR 0 5
74369: PPUSH
74370: LD_VAR 0 8
74374: PUSH
74375: LD_VAR 0 3
74379: ARRAY
74380: PPUSH
74381: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
74385: LD_INT 35
74387: PPUSH
74388: CALL_OW 67
// until not HasTask ( tmp ) ;
74392: LD_VAR 0 7
74396: PPUSH
74397: CALL_OW 314
74401: NOT
74402: IFFALSE 74385
// mc_teleport_exit_set := Add ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
74404: LD_ADDR_EXP 94
74408: PUSH
74409: LD_EXP 94
74413: PPUSH
74414: LD_VAR 0 2
74418: PUSH
74419: LD_EXP 94
74423: PUSH
74424: LD_VAR 0 2
74428: ARRAY
74429: PUSH
74430: LD_INT 1
74432: PLUS
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PPUSH
74438: LD_VAR 0 8
74442: PUSH
74443: LD_VAR 0 3
74447: ARRAY
74448: PPUSH
74449: CALL 20697 0 3
74453: ST_TO_ADDR
// end ;
74454: GO 74112
74456: POP
74457: POP
// MC_Reset ( i , 124 ) ;
74458: LD_VAR 0 2
74462: PPUSH
74463: LD_INT 124
74465: PPUSH
74466: CALL 58649 0 2
// end ; end ;
74470: GO 73867
74472: POP
74473: POP
// end ;
74474: LD_VAR 0 1
74478: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
74479: LD_INT 0
74481: PPUSH
74482: PPUSH
74483: PPUSH
// if not mc_bases then
74484: LD_EXP 58
74488: NOT
74489: IFFALSE 74493
// exit ;
74491: GO 75099
// for i = 1 to mc_bases do
74493: LD_ADDR_VAR 0 2
74497: PUSH
74498: DOUBLE
74499: LD_INT 1
74501: DEC
74502: ST_TO_ADDR
74503: LD_EXP 58
74507: PUSH
74508: FOR_TO
74509: IFFALSE 75097
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
74511: LD_ADDR_VAR 0 3
74515: PUSH
74516: LD_EXP 58
74520: PUSH
74521: LD_VAR 0 2
74525: ARRAY
74526: PPUSH
74527: LD_INT 25
74529: PUSH
74530: LD_INT 4
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PPUSH
74537: CALL_OW 72
74541: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
74542: LD_VAR 0 3
74546: NOT
74547: PUSH
74548: LD_EXP 95
74552: PUSH
74553: LD_VAR 0 2
74557: ARRAY
74558: NOT
74559: OR
74560: PUSH
74561: LD_EXP 58
74565: PUSH
74566: LD_VAR 0 2
74570: ARRAY
74571: PPUSH
74572: LD_INT 2
74574: PUSH
74575: LD_INT 30
74577: PUSH
74578: LD_INT 0
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 30
74587: PUSH
74588: LD_INT 1
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: LIST
74599: PPUSH
74600: CALL_OW 72
74604: NOT
74605: OR
74606: IFFALSE 74656
// begin if mc_deposits_finder [ i ] then
74608: LD_EXP 96
74612: PUSH
74613: LD_VAR 0 2
74617: ARRAY
74618: IFFALSE 74654
// begin MC_Reset ( i , 125 ) ;
74620: LD_VAR 0 2
74624: PPUSH
74625: LD_INT 125
74627: PPUSH
74628: CALL 58649 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74632: LD_ADDR_EXP 96
74636: PUSH
74637: LD_EXP 96
74641: PPUSH
74642: LD_VAR 0 2
74646: PPUSH
74647: EMPTY
74648: PPUSH
74649: CALL_OW 1
74653: ST_TO_ADDR
// end ; continue ;
74654: GO 74508
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
74656: LD_EXP 95
74660: PUSH
74661: LD_VAR 0 2
74665: ARRAY
74666: PUSH
74667: LD_INT 1
74669: ARRAY
74670: PUSH
74671: LD_INT 3
74673: ARRAY
74674: PUSH
74675: LD_INT 1
74677: EQUAL
74678: PUSH
74679: LD_INT 20
74681: PPUSH
74682: LD_EXP 84
74686: PUSH
74687: LD_VAR 0 2
74691: ARRAY
74692: PPUSH
74693: CALL_OW 321
74697: PUSH
74698: LD_INT 2
74700: NONEQUAL
74701: AND
74702: IFFALSE 74752
// begin if mc_deposits_finder [ i ] then
74704: LD_EXP 96
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: IFFALSE 74750
// begin MC_Reset ( i , 125 ) ;
74716: LD_VAR 0 2
74720: PPUSH
74721: LD_INT 125
74723: PPUSH
74724: CALL 58649 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
74728: LD_ADDR_EXP 96
74732: PUSH
74733: LD_EXP 96
74737: PPUSH
74738: LD_VAR 0 2
74742: PPUSH
74743: EMPTY
74744: PPUSH
74745: CALL_OW 1
74749: ST_TO_ADDR
// end ; continue ;
74750: GO 74508
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
74752: LD_EXP 95
74756: PUSH
74757: LD_VAR 0 2
74761: ARRAY
74762: PUSH
74763: LD_INT 1
74765: ARRAY
74766: PUSH
74767: LD_INT 1
74769: ARRAY
74770: PPUSH
74771: LD_EXP 95
74775: PUSH
74776: LD_VAR 0 2
74780: ARRAY
74781: PUSH
74782: LD_INT 1
74784: ARRAY
74785: PUSH
74786: LD_INT 2
74788: ARRAY
74789: PPUSH
74790: LD_EXP 84
74794: PUSH
74795: LD_VAR 0 2
74799: ARRAY
74800: PPUSH
74801: CALL_OW 440
74805: IFFALSE 74848
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
74807: LD_ADDR_EXP 95
74811: PUSH
74812: LD_EXP 95
74816: PPUSH
74817: LD_VAR 0 2
74821: PPUSH
74822: LD_EXP 95
74826: PUSH
74827: LD_VAR 0 2
74831: ARRAY
74832: PPUSH
74833: LD_INT 1
74835: PPUSH
74836: CALL_OW 3
74840: PPUSH
74841: CALL_OW 1
74845: ST_TO_ADDR
74846: GO 75095
// begin if not mc_deposits_finder [ i ] then
74848: LD_EXP 96
74852: PUSH
74853: LD_VAR 0 2
74857: ARRAY
74858: NOT
74859: IFFALSE 74911
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
74861: LD_ADDR_EXP 96
74865: PUSH
74866: LD_EXP 96
74870: PPUSH
74871: LD_VAR 0 2
74875: PPUSH
74876: LD_VAR 0 3
74880: PUSH
74881: LD_INT 1
74883: ARRAY
74884: PUSH
74885: EMPTY
74886: LIST
74887: PPUSH
74888: CALL_OW 1
74892: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
74893: LD_VAR 0 3
74897: PUSH
74898: LD_INT 1
74900: ARRAY
74901: PPUSH
74902: LD_INT 125
74904: PPUSH
74905: CALL_OW 109
// end else
74909: GO 75095
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
74911: LD_EXP 96
74915: PUSH
74916: LD_VAR 0 2
74920: ARRAY
74921: PUSH
74922: LD_INT 1
74924: ARRAY
74925: PPUSH
74926: CALL_OW 310
74930: IFFALSE 74953
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
74932: LD_EXP 96
74936: PUSH
74937: LD_VAR 0 2
74941: ARRAY
74942: PUSH
74943: LD_INT 1
74945: ARRAY
74946: PPUSH
74947: CALL_OW 122
74951: GO 75095
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
74953: LD_EXP 96
74957: PUSH
74958: LD_VAR 0 2
74962: ARRAY
74963: PUSH
74964: LD_INT 1
74966: ARRAY
74967: PPUSH
74968: CALL_OW 314
74972: NOT
74973: PUSH
74974: LD_EXP 96
74978: PUSH
74979: LD_VAR 0 2
74983: ARRAY
74984: PUSH
74985: LD_INT 1
74987: ARRAY
74988: PPUSH
74989: LD_EXP 95
74993: PUSH
74994: LD_VAR 0 2
74998: ARRAY
74999: PUSH
75000: LD_INT 1
75002: ARRAY
75003: PUSH
75004: LD_INT 1
75006: ARRAY
75007: PPUSH
75008: LD_EXP 95
75012: PUSH
75013: LD_VAR 0 2
75017: ARRAY
75018: PUSH
75019: LD_INT 1
75021: ARRAY
75022: PUSH
75023: LD_INT 2
75025: ARRAY
75026: PPUSH
75027: CALL_OW 297
75031: PUSH
75032: LD_INT 6
75034: GREATER
75035: AND
75036: IFFALSE 75095
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75038: LD_EXP 96
75042: PUSH
75043: LD_VAR 0 2
75047: ARRAY
75048: PUSH
75049: LD_INT 1
75051: ARRAY
75052: PPUSH
75053: LD_EXP 95
75057: PUSH
75058: LD_VAR 0 2
75062: ARRAY
75063: PUSH
75064: LD_INT 1
75066: ARRAY
75067: PUSH
75068: LD_INT 1
75070: ARRAY
75071: PPUSH
75072: LD_EXP 95
75076: PUSH
75077: LD_VAR 0 2
75081: ARRAY
75082: PUSH
75083: LD_INT 1
75085: ARRAY
75086: PUSH
75087: LD_INT 2
75089: ARRAY
75090: PPUSH
75091: CALL_OW 111
// end ; end ; end ;
75095: GO 74508
75097: POP
75098: POP
// end ;
75099: LD_VAR 0 1
75103: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75104: LD_INT 0
75106: PPUSH
75107: PPUSH
75108: PPUSH
75109: PPUSH
75110: PPUSH
75111: PPUSH
75112: PPUSH
75113: PPUSH
75114: PPUSH
75115: PPUSH
75116: PPUSH
// if not mc_bases then
75117: LD_EXP 58
75121: NOT
75122: IFFALSE 75126
// exit ;
75124: GO 75850
// for i = 1 to mc_bases do
75126: LD_ADDR_VAR 0 2
75130: PUSH
75131: DOUBLE
75132: LD_INT 1
75134: DEC
75135: ST_TO_ADDR
75136: LD_EXP 58
75140: PUSH
75141: FOR_TO
75142: IFFALSE 75848
// begin if not mc_bases [ i ] then
75144: LD_EXP 58
75148: PUSH
75149: LD_VAR 0 2
75153: ARRAY
75154: NOT
75155: IFFALSE 75159
// continue ;
75157: GO 75141
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75159: LD_ADDR_VAR 0 7
75163: PUSH
75164: LD_EXP 58
75168: PUSH
75169: LD_VAR 0 2
75173: ARRAY
75174: PUSH
75175: LD_INT 1
75177: ARRAY
75178: PPUSH
75179: CALL_OW 248
75183: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75184: LD_VAR 0 7
75188: PUSH
75189: LD_INT 3
75191: EQUAL
75192: PUSH
75193: LD_EXP 77
75197: PUSH
75198: LD_VAR 0 2
75202: ARRAY
75203: PUSH
75204: LD_EXP 80
75208: PUSH
75209: LD_VAR 0 2
75213: ARRAY
75214: UNION
75215: PPUSH
75216: LD_INT 33
75218: PUSH
75219: LD_INT 2
75221: PUSH
75222: EMPTY
75223: LIST
75224: LIST
75225: PPUSH
75226: CALL_OW 72
75230: NOT
75231: OR
75232: IFFALSE 75236
// continue ;
75234: GO 75141
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
75236: LD_ADDR_VAR 0 9
75240: PUSH
75241: LD_EXP 58
75245: PUSH
75246: LD_VAR 0 2
75250: ARRAY
75251: PPUSH
75252: LD_INT 30
75254: PUSH
75255: LD_INT 36
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PPUSH
75262: CALL_OW 72
75266: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
75267: LD_ADDR_VAR 0 10
75271: PUSH
75272: LD_EXP 77
75276: PUSH
75277: LD_VAR 0 2
75281: ARRAY
75282: PPUSH
75283: LD_INT 34
75285: PUSH
75286: LD_INT 31
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PPUSH
75293: CALL_OW 72
75297: ST_TO_ADDR
// if not cts and not mcts then
75298: LD_VAR 0 9
75302: NOT
75303: PUSH
75304: LD_VAR 0 10
75308: NOT
75309: AND
75310: IFFALSE 75314
// continue ;
75312: GO 75141
// x := cts ;
75314: LD_ADDR_VAR 0 11
75318: PUSH
75319: LD_VAR 0 9
75323: ST_TO_ADDR
// if not x then
75324: LD_VAR 0 11
75328: NOT
75329: IFFALSE 75341
// x := mcts ;
75331: LD_ADDR_VAR 0 11
75335: PUSH
75336: LD_VAR 0 10
75340: ST_TO_ADDR
// if mc_remote_driver [ i ] then
75341: LD_EXP 98
75345: PUSH
75346: LD_VAR 0 2
75350: ARRAY
75351: IFFALSE 75620
// for j in mc_remote_driver [ i ] do
75353: LD_ADDR_VAR 0 3
75357: PUSH
75358: LD_EXP 98
75362: PUSH
75363: LD_VAR 0 2
75367: ARRAY
75368: PUSH
75369: FOR_IN
75370: IFFALSE 75618
// begin if GetClass ( j ) <> 3 then
75372: LD_VAR 0 3
75376: PPUSH
75377: CALL_OW 257
75381: PUSH
75382: LD_INT 3
75384: NONEQUAL
75385: IFFALSE 75438
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
75387: LD_ADDR_EXP 98
75391: PUSH
75392: LD_EXP 98
75396: PPUSH
75397: LD_VAR 0 2
75401: PPUSH
75402: LD_EXP 98
75406: PUSH
75407: LD_VAR 0 2
75411: ARRAY
75412: PUSH
75413: LD_VAR 0 3
75417: DIFF
75418: PPUSH
75419: CALL_OW 1
75423: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75424: LD_VAR 0 3
75428: PPUSH
75429: LD_INT 0
75431: PPUSH
75432: CALL_OW 109
// continue ;
75436: GO 75369
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
75438: LD_VAR 0 3
75442: PPUSH
75443: CALL_OW 310
75447: NOT
75448: PUSH
75449: LD_VAR 0 3
75453: PPUSH
75454: CALL_OW 310
75458: PPUSH
75459: CALL_OW 266
75463: PUSH
75464: LD_INT 36
75466: NONEQUAL
75467: PUSH
75468: LD_VAR 0 3
75472: PPUSH
75473: CALL 53393 0 1
75477: NOT
75478: AND
75479: OR
75480: IFFALSE 75616
// begin if IsInUnit ( j ) then
75482: LD_VAR 0 3
75486: PPUSH
75487: CALL_OW 310
75491: IFFALSE 75502
// ComExitBuilding ( j ) ;
75493: LD_VAR 0 3
75497: PPUSH
75498: CALL_OW 122
// ct := 0 ;
75502: LD_ADDR_VAR 0 8
75506: PUSH
75507: LD_INT 0
75509: ST_TO_ADDR
// for k in x do
75510: LD_ADDR_VAR 0 4
75514: PUSH
75515: LD_VAR 0 11
75519: PUSH
75520: FOR_IN
75521: IFFALSE 75594
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
75523: LD_VAR 0 4
75527: PPUSH
75528: CALL_OW 264
75532: PUSH
75533: LD_INT 31
75535: EQUAL
75536: PUSH
75537: LD_VAR 0 4
75541: PPUSH
75542: CALL_OW 311
75546: NOT
75547: AND
75548: PUSH
75549: LD_VAR 0 4
75553: PPUSH
75554: CALL_OW 266
75558: PUSH
75559: LD_INT 36
75561: EQUAL
75562: PUSH
75563: LD_VAR 0 4
75567: PPUSH
75568: CALL_OW 313
75572: PUSH
75573: LD_INT 3
75575: LESS
75576: AND
75577: OR
75578: IFFALSE 75592
// begin ct := k ;
75580: LD_ADDR_VAR 0 8
75584: PUSH
75585: LD_VAR 0 4
75589: ST_TO_ADDR
// break ;
75590: GO 75594
// end ;
75592: GO 75520
75594: POP
75595: POP
// if ct then
75596: LD_VAR 0 8
75600: IFFALSE 75616
// ComEnterUnit ( j , ct ) ;
75602: LD_VAR 0 3
75606: PPUSH
75607: LD_VAR 0 8
75611: PPUSH
75612: CALL_OW 120
// end ; end ;
75616: GO 75369
75618: POP
75619: POP
// places := 0 ;
75620: LD_ADDR_VAR 0 5
75624: PUSH
75625: LD_INT 0
75627: ST_TO_ADDR
// for j = 1 to x do
75628: LD_ADDR_VAR 0 3
75632: PUSH
75633: DOUBLE
75634: LD_INT 1
75636: DEC
75637: ST_TO_ADDR
75638: LD_VAR 0 11
75642: PUSH
75643: FOR_TO
75644: IFFALSE 75699
// if GetWeapon ( x [ j ] ) = ar_control_tower then
75646: LD_VAR 0 11
75650: PUSH
75651: LD_VAR 0 3
75655: ARRAY
75656: PPUSH
75657: CALL_OW 264
75661: PUSH
75662: LD_INT 31
75664: EQUAL
75665: IFFALSE 75683
// places := places + 1 else
75667: LD_ADDR_VAR 0 5
75671: PUSH
75672: LD_VAR 0 5
75676: PUSH
75677: LD_INT 1
75679: PLUS
75680: ST_TO_ADDR
75681: GO 75697
// places := places + 3 ;
75683: LD_ADDR_VAR 0 5
75687: PUSH
75688: LD_VAR 0 5
75692: PUSH
75693: LD_INT 3
75695: PLUS
75696: ST_TO_ADDR
75697: GO 75643
75699: POP
75700: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
75701: LD_ADDR_VAR 0 6
75705: PUSH
75706: LD_EXP 58
75710: PUSH
75711: LD_VAR 0 2
75715: ARRAY
75716: PPUSH
75717: LD_INT 25
75719: PUSH
75720: LD_INT 3
75722: PUSH
75723: EMPTY
75724: LIST
75725: LIST
75726: PPUSH
75727: CALL_OW 72
75731: PUSH
75732: LD_EXP 98
75736: PUSH
75737: LD_VAR 0 2
75741: ARRAY
75742: DIFF
75743: PPUSH
75744: LD_INT 3
75746: PPUSH
75747: CALL 54293 0 2
75751: ST_TO_ADDR
// if not tmp then
75752: LD_VAR 0 6
75756: NOT
75757: IFFALSE 75761
// continue ;
75759: GO 75141
// places := places - mc_remote_driver [ i ] ;
75761: LD_ADDR_VAR 0 5
75765: PUSH
75766: LD_VAR 0 5
75770: PUSH
75771: LD_EXP 98
75775: PUSH
75776: LD_VAR 0 2
75780: ARRAY
75781: MINUS
75782: ST_TO_ADDR
// if places then
75783: LD_VAR 0 5
75787: IFFALSE 75846
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
75789: LD_ADDR_EXP 98
75793: PUSH
75794: LD_EXP 98
75798: PPUSH
75799: LD_VAR 0 2
75803: PPUSH
75804: LD_EXP 98
75808: PUSH
75809: LD_VAR 0 2
75813: ARRAY
75814: PUSH
75815: LD_VAR 0 6
75819: PUSH
75820: LD_INT 1
75822: ARRAY
75823: UNION
75824: PPUSH
75825: CALL_OW 1
75829: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
75830: LD_VAR 0 6
75834: PUSH
75835: LD_INT 1
75837: ARRAY
75838: PPUSH
75839: LD_INT 126
75841: PPUSH
75842: CALL_OW 109
// end ; end ;
75846: GO 75141
75848: POP
75849: POP
// end ;
75850: LD_VAR 0 1
75854: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
75855: LD_INT 0
75857: PPUSH
75858: PPUSH
75859: PPUSH
75860: PPUSH
75861: PPUSH
75862: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
75863: LD_VAR 0 1
75867: NOT
75868: PUSH
75869: LD_VAR 0 2
75873: NOT
75874: OR
75875: PUSH
75876: LD_VAR 0 3
75880: NOT
75881: OR
75882: PUSH
75883: LD_VAR 0 4
75887: PUSH
75888: LD_INT 1
75890: PUSH
75891: LD_INT 2
75893: PUSH
75894: LD_INT 3
75896: PUSH
75897: LD_INT 4
75899: PUSH
75900: LD_INT 5
75902: PUSH
75903: LD_INT 8
75905: PUSH
75906: LD_INT 9
75908: PUSH
75909: LD_INT 15
75911: PUSH
75912: LD_INT 16
75914: PUSH
75915: EMPTY
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: IN
75926: NOT
75927: OR
75928: IFFALSE 75932
// exit ;
75930: GO 76832
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
75932: LD_ADDR_VAR 0 2
75936: PUSH
75937: LD_VAR 0 2
75941: PPUSH
75942: LD_INT 21
75944: PUSH
75945: LD_INT 3
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: PUSH
75952: LD_INT 24
75954: PUSH
75955: LD_INT 250
75957: PUSH
75958: EMPTY
75959: LIST
75960: LIST
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PPUSH
75966: CALL_OW 72
75970: ST_TO_ADDR
// case class of 1 , 15 :
75971: LD_VAR 0 4
75975: PUSH
75976: LD_INT 1
75978: DOUBLE
75979: EQUAL
75980: IFTRUE 75990
75982: LD_INT 15
75984: DOUBLE
75985: EQUAL
75986: IFTRUE 75990
75988: GO 76075
75990: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
75991: LD_ADDR_VAR 0 8
75995: PUSH
75996: LD_VAR 0 2
76000: PPUSH
76001: LD_INT 2
76003: PUSH
76004: LD_INT 30
76006: PUSH
76007: LD_INT 32
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 30
76016: PUSH
76017: LD_INT 31
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: LIST
76028: PPUSH
76029: CALL_OW 72
76033: PUSH
76034: LD_VAR 0 2
76038: PPUSH
76039: LD_INT 2
76041: PUSH
76042: LD_INT 30
76044: PUSH
76045: LD_INT 4
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: LD_INT 30
76054: PUSH
76055: LD_INT 5
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PUSH
76062: EMPTY
76063: LIST
76064: LIST
76065: LIST
76066: PPUSH
76067: CALL_OW 72
76071: ADD
76072: ST_TO_ADDR
76073: GO 76321
76075: LD_INT 2
76077: DOUBLE
76078: EQUAL
76079: IFTRUE 76089
76081: LD_INT 16
76083: DOUBLE
76084: EQUAL
76085: IFTRUE 76089
76087: GO 76135
76089: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
76090: LD_ADDR_VAR 0 8
76094: PUSH
76095: LD_VAR 0 2
76099: PPUSH
76100: LD_INT 2
76102: PUSH
76103: LD_INT 30
76105: PUSH
76106: LD_INT 0
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 30
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: EMPTY
76124: LIST
76125: LIST
76126: LIST
76127: PPUSH
76128: CALL_OW 72
76132: ST_TO_ADDR
76133: GO 76321
76135: LD_INT 3
76137: DOUBLE
76138: EQUAL
76139: IFTRUE 76143
76141: GO 76189
76143: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
76144: LD_ADDR_VAR 0 8
76148: PUSH
76149: LD_VAR 0 2
76153: PPUSH
76154: LD_INT 2
76156: PUSH
76157: LD_INT 30
76159: PUSH
76160: LD_INT 2
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 30
76169: PUSH
76170: LD_INT 3
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: EMPTY
76178: LIST
76179: LIST
76180: LIST
76181: PPUSH
76182: CALL_OW 72
76186: ST_TO_ADDR
76187: GO 76321
76189: LD_INT 4
76191: DOUBLE
76192: EQUAL
76193: IFTRUE 76197
76195: GO 76254
76197: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
76198: LD_ADDR_VAR 0 8
76202: PUSH
76203: LD_VAR 0 2
76207: PPUSH
76208: LD_INT 2
76210: PUSH
76211: LD_INT 30
76213: PUSH
76214: LD_INT 6
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_INT 30
76223: PUSH
76224: LD_INT 7
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 30
76233: PUSH
76234: LD_INT 8
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: LIST
76245: LIST
76246: PPUSH
76247: CALL_OW 72
76251: ST_TO_ADDR
76252: GO 76321
76254: LD_INT 5
76256: DOUBLE
76257: EQUAL
76258: IFTRUE 76274
76260: LD_INT 8
76262: DOUBLE
76263: EQUAL
76264: IFTRUE 76274
76266: LD_INT 9
76268: DOUBLE
76269: EQUAL
76270: IFTRUE 76274
76272: GO 76320
76274: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
76275: LD_ADDR_VAR 0 8
76279: PUSH
76280: LD_VAR 0 2
76284: PPUSH
76285: LD_INT 2
76287: PUSH
76288: LD_INT 30
76290: PUSH
76291: LD_INT 4
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 30
76300: PUSH
76301: LD_INT 5
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: LIST
76312: PPUSH
76313: CALL_OW 72
76317: ST_TO_ADDR
76318: GO 76321
76320: POP
// if not tmp then
76321: LD_VAR 0 8
76325: NOT
76326: IFFALSE 76330
// exit ;
76328: GO 76832
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
76330: LD_VAR 0 4
76334: PUSH
76335: LD_INT 1
76337: PUSH
76338: LD_INT 15
76340: PUSH
76341: EMPTY
76342: LIST
76343: LIST
76344: IN
76345: PUSH
76346: LD_EXP 67
76350: PUSH
76351: LD_VAR 0 1
76355: ARRAY
76356: AND
76357: IFFALSE 76513
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
76359: LD_ADDR_VAR 0 9
76363: PUSH
76364: LD_EXP 67
76368: PUSH
76369: LD_VAR 0 1
76373: ARRAY
76374: PUSH
76375: LD_INT 1
76377: ARRAY
76378: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
76379: LD_VAR 0 9
76383: PUSH
76384: LD_EXP 68
76388: PUSH
76389: LD_VAR 0 1
76393: ARRAY
76394: IN
76395: NOT
76396: IFFALSE 76511
// begin mc_busy_turret_list := Add ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
76398: LD_ADDR_EXP 68
76402: PUSH
76403: LD_EXP 68
76407: PPUSH
76408: LD_VAR 0 1
76412: PUSH
76413: LD_EXP 68
76417: PUSH
76418: LD_VAR 0 1
76422: ARRAY
76423: PUSH
76424: LD_INT 1
76426: PLUS
76427: PUSH
76428: EMPTY
76429: LIST
76430: LIST
76431: PPUSH
76432: LD_VAR 0 9
76436: PPUSH
76437: CALL 20697 0 3
76441: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
76442: LD_ADDR_EXP 67
76446: PUSH
76447: LD_EXP 67
76451: PPUSH
76452: LD_VAR 0 1
76456: PPUSH
76457: LD_EXP 67
76461: PUSH
76462: LD_VAR 0 1
76466: ARRAY
76467: PUSH
76468: LD_VAR 0 9
76472: DIFF
76473: PPUSH
76474: CALL_OW 1
76478: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
76479: LD_VAR 0 3
76483: PPUSH
76484: LD_EXP 68
76488: PUSH
76489: LD_VAR 0 1
76493: ARRAY
76494: PUSH
76495: LD_EXP 68
76499: PUSH
76500: LD_VAR 0 1
76504: ARRAY
76505: ARRAY
76506: PPUSH
76507: CALL_OW 120
// end ; exit ;
76511: GO 76832
// end ; if tmp > 1 then
76513: LD_VAR 0 8
76517: PUSH
76518: LD_INT 1
76520: GREATER
76521: IFFALSE 76625
// for i = 2 to tmp do
76523: LD_ADDR_VAR 0 6
76527: PUSH
76528: DOUBLE
76529: LD_INT 2
76531: DEC
76532: ST_TO_ADDR
76533: LD_VAR 0 8
76537: PUSH
76538: FOR_TO
76539: IFFALSE 76623
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
76541: LD_VAR 0 8
76545: PUSH
76546: LD_VAR 0 6
76550: ARRAY
76551: PPUSH
76552: CALL_OW 461
76556: PUSH
76557: LD_INT 6
76559: EQUAL
76560: IFFALSE 76621
// begin x := tmp [ i ] ;
76562: LD_ADDR_VAR 0 9
76566: PUSH
76567: LD_VAR 0 8
76571: PUSH
76572: LD_VAR 0 6
76576: ARRAY
76577: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
76578: LD_ADDR_VAR 0 8
76582: PUSH
76583: LD_VAR 0 8
76587: PPUSH
76588: LD_VAR 0 6
76592: PPUSH
76593: CALL_OW 3
76597: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
76598: LD_ADDR_VAR 0 8
76602: PUSH
76603: LD_VAR 0 8
76607: PPUSH
76608: LD_INT 1
76610: PPUSH
76611: LD_VAR 0 9
76615: PPUSH
76616: CALL_OW 2
76620: ST_TO_ADDR
// end ;
76621: GO 76538
76623: POP
76624: POP
// for i in tmp do
76625: LD_ADDR_VAR 0 6
76629: PUSH
76630: LD_VAR 0 8
76634: PUSH
76635: FOR_IN
76636: IFFALSE 76705
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
76638: LD_VAR 0 6
76642: PPUSH
76643: CALL_OW 313
76647: PUSH
76648: LD_INT 6
76650: LESS
76651: PUSH
76652: LD_VAR 0 6
76656: PPUSH
76657: CALL_OW 266
76661: PUSH
76662: LD_INT 31
76664: PUSH
76665: LD_INT 32
76667: PUSH
76668: EMPTY
76669: LIST
76670: LIST
76671: IN
76672: NOT
76673: AND
76674: PUSH
76675: LD_VAR 0 6
76679: PPUSH
76680: CALL_OW 313
76684: PUSH
76685: LD_INT 0
76687: EQUAL
76688: OR
76689: IFFALSE 76703
// begin j := i ;
76691: LD_ADDR_VAR 0 7
76695: PUSH
76696: LD_VAR 0 6
76700: ST_TO_ADDR
// break ;
76701: GO 76705
// end ; end ;
76703: GO 76635
76705: POP
76706: POP
// if j then
76707: LD_VAR 0 7
76711: IFFALSE 76729
// ComEnterUnit ( unit , j ) else
76713: LD_VAR 0 3
76717: PPUSH
76718: LD_VAR 0 7
76722: PPUSH
76723: CALL_OW 120
76727: GO 76832
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76729: LD_ADDR_VAR 0 10
76733: PUSH
76734: LD_VAR 0 2
76738: PPUSH
76739: LD_INT 2
76741: PUSH
76742: LD_INT 30
76744: PUSH
76745: LD_INT 0
76747: PUSH
76748: EMPTY
76749: LIST
76750: LIST
76751: PUSH
76752: LD_INT 30
76754: PUSH
76755: LD_INT 1
76757: PUSH
76758: EMPTY
76759: LIST
76760: LIST
76761: PUSH
76762: EMPTY
76763: LIST
76764: LIST
76765: LIST
76766: PPUSH
76767: CALL_OW 72
76771: ST_TO_ADDR
// if depot then
76772: LD_VAR 0 10
76776: IFFALSE 76832
// begin depot := NearestUnitToUnit ( depot , unit ) ;
76778: LD_ADDR_VAR 0 10
76782: PUSH
76783: LD_VAR 0 10
76787: PPUSH
76788: LD_VAR 0 3
76792: PPUSH
76793: CALL_OW 74
76797: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
76798: LD_VAR 0 3
76802: PPUSH
76803: LD_VAR 0 10
76807: PPUSH
76808: CALL_OW 296
76812: PUSH
76813: LD_INT 10
76815: GREATER
76816: IFFALSE 76832
// ComStandNearbyBuilding ( unit , depot ) ;
76818: LD_VAR 0 3
76822: PPUSH
76823: LD_VAR 0 10
76827: PPUSH
76828: CALL 14939 0 2
// end ; end ; end ;
76832: LD_VAR 0 5
76836: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
76837: LD_INT 0
76839: PPUSH
76840: PPUSH
76841: PPUSH
76842: PPUSH
// if not mc_bases then
76843: LD_EXP 58
76847: NOT
76848: IFFALSE 76852
// exit ;
76850: GO 77091
// for i = 1 to mc_bases do
76852: LD_ADDR_VAR 0 2
76856: PUSH
76857: DOUBLE
76858: LD_INT 1
76860: DEC
76861: ST_TO_ADDR
76862: LD_EXP 58
76866: PUSH
76867: FOR_TO
76868: IFFALSE 77089
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
76870: LD_ADDR_VAR 0 4
76874: PUSH
76875: LD_EXP 58
76879: PUSH
76880: LD_VAR 0 2
76884: ARRAY
76885: PPUSH
76886: LD_INT 21
76888: PUSH
76889: LD_INT 1
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PPUSH
76896: CALL_OW 72
76900: PUSH
76901: LD_EXP 87
76905: PUSH
76906: LD_VAR 0 2
76910: ARRAY
76911: UNION
76912: ST_TO_ADDR
// if not tmp then
76913: LD_VAR 0 4
76917: NOT
76918: IFFALSE 76922
// continue ;
76920: GO 76867
// for j in tmp do
76922: LD_ADDR_VAR 0 3
76926: PUSH
76927: LD_VAR 0 4
76931: PUSH
76932: FOR_IN
76933: IFFALSE 77085
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
76935: LD_VAR 0 3
76939: PPUSH
76940: CALL_OW 110
76944: NOT
76945: PUSH
76946: LD_VAR 0 3
76950: PPUSH
76951: CALL_OW 314
76955: NOT
76956: AND
76957: PUSH
76958: LD_VAR 0 3
76962: PPUSH
76963: CALL_OW 311
76967: NOT
76968: AND
76969: PUSH
76970: LD_VAR 0 3
76974: PPUSH
76975: CALL_OW 310
76979: NOT
76980: AND
76981: PUSH
76982: LD_VAR 0 3
76986: PUSH
76987: LD_EXP 61
76991: PUSH
76992: LD_VAR 0 2
76996: ARRAY
76997: PUSH
76998: LD_INT 1
77000: ARRAY
77001: IN
77002: NOT
77003: AND
77004: PUSH
77005: LD_VAR 0 3
77009: PUSH
77010: LD_EXP 61
77014: PUSH
77015: LD_VAR 0 2
77019: ARRAY
77020: PUSH
77021: LD_INT 2
77023: ARRAY
77024: IN
77025: NOT
77026: AND
77027: PUSH
77028: LD_VAR 0 3
77032: PUSH
77033: LD_EXP 70
77037: PUSH
77038: LD_VAR 0 2
77042: ARRAY
77043: IN
77044: NOT
77045: AND
77046: IFFALSE 77083
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
77048: LD_VAR 0 2
77052: PPUSH
77053: LD_EXP 58
77057: PUSH
77058: LD_VAR 0 2
77062: ARRAY
77063: PPUSH
77064: LD_VAR 0 3
77068: PPUSH
77069: LD_VAR 0 3
77073: PPUSH
77074: CALL_OW 257
77078: PPUSH
77079: CALL 75855 0 4
// end ;
77083: GO 76932
77085: POP
77086: POP
// end ;
77087: GO 76867
77089: POP
77090: POP
// end ;
77091: LD_VAR 0 1
77095: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
77096: LD_INT 0
77098: PPUSH
77099: PPUSH
77100: PPUSH
77101: PPUSH
77102: PPUSH
77103: PPUSH
// if not mc_bases [ base ] then
77104: LD_EXP 58
77108: PUSH
77109: LD_VAR 0 1
77113: ARRAY
77114: NOT
77115: IFFALSE 77119
// exit ;
77117: GO 77301
// tmp := [ ] ;
77119: LD_ADDR_VAR 0 6
77123: PUSH
77124: EMPTY
77125: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
77126: LD_ADDR_VAR 0 7
77130: PUSH
77131: LD_VAR 0 3
77135: PPUSH
77136: LD_INT 0
77138: PPUSH
77139: CALL_OW 517
77143: ST_TO_ADDR
// if not list then
77144: LD_VAR 0 7
77148: NOT
77149: IFFALSE 77153
// exit ;
77151: GO 77301
// for i = 1 to amount do
77153: LD_ADDR_VAR 0 5
77157: PUSH
77158: DOUBLE
77159: LD_INT 1
77161: DEC
77162: ST_TO_ADDR
77163: LD_VAR 0 2
77167: PUSH
77168: FOR_TO
77169: IFFALSE 77249
// begin x := rand ( 1 , list [ 1 ] ) ;
77171: LD_ADDR_VAR 0 8
77175: PUSH
77176: LD_INT 1
77178: PPUSH
77179: LD_VAR 0 7
77183: PUSH
77184: LD_INT 1
77186: ARRAY
77187: PPUSH
77188: CALL_OW 12
77192: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
77193: LD_ADDR_VAR 0 6
77197: PUSH
77198: LD_VAR 0 6
77202: PPUSH
77203: LD_VAR 0 5
77207: PPUSH
77208: LD_VAR 0 7
77212: PUSH
77213: LD_INT 1
77215: ARRAY
77216: PUSH
77217: LD_VAR 0 8
77221: ARRAY
77222: PUSH
77223: LD_VAR 0 7
77227: PUSH
77228: LD_INT 2
77230: ARRAY
77231: PUSH
77232: LD_VAR 0 8
77236: ARRAY
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PPUSH
77242: CALL_OW 1
77246: ST_TO_ADDR
// end ;
77247: GO 77168
77249: POP
77250: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
77251: LD_ADDR_EXP 71
77255: PUSH
77256: LD_EXP 71
77260: PPUSH
77261: LD_VAR 0 1
77265: PPUSH
77266: LD_VAR 0 6
77270: PPUSH
77271: CALL_OW 1
77275: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
77276: LD_ADDR_EXP 73
77280: PUSH
77281: LD_EXP 73
77285: PPUSH
77286: LD_VAR 0 1
77290: PPUSH
77291: LD_VAR 0 3
77295: PPUSH
77296: CALL_OW 1
77300: ST_TO_ADDR
// end ;
77301: LD_VAR 0 4
77305: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
77306: LD_INT 0
77308: PPUSH
// if not mc_bases [ base ] then
77309: LD_EXP 58
77313: PUSH
77314: LD_VAR 0 1
77318: ARRAY
77319: NOT
77320: IFFALSE 77324
// exit ;
77322: GO 77349
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
77324: LD_ADDR_EXP 63
77328: PUSH
77329: LD_EXP 63
77333: PPUSH
77334: LD_VAR 0 1
77338: PPUSH
77339: LD_VAR 0 2
77343: PPUSH
77344: CALL_OW 1
77348: ST_TO_ADDR
// end ;
77349: LD_VAR 0 3
77353: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
77354: LD_INT 0
77356: PPUSH
// if not mc_bases [ base ] then
77357: LD_EXP 58
77361: PUSH
77362: LD_VAR 0 1
77366: ARRAY
77367: NOT
77368: IFFALSE 77372
// exit ;
77370: GO 77409
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
77372: LD_ADDR_EXP 63
77376: PUSH
77377: LD_EXP 63
77381: PPUSH
77382: LD_VAR 0 1
77386: PPUSH
77387: LD_EXP 63
77391: PUSH
77392: LD_VAR 0 1
77396: ARRAY
77397: PUSH
77398: LD_VAR 0 2
77402: UNION
77403: PPUSH
77404: CALL_OW 1
77408: ST_TO_ADDR
// end ;
77409: LD_VAR 0 3
77413: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
77414: LD_INT 0
77416: PPUSH
// if not mc_bases [ base ] then
77417: LD_EXP 58
77421: PUSH
77422: LD_VAR 0 1
77426: ARRAY
77427: NOT
77428: IFFALSE 77432
// exit ;
77430: GO 77457
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
77432: LD_ADDR_EXP 79
77436: PUSH
77437: LD_EXP 79
77441: PPUSH
77442: LD_VAR 0 1
77446: PPUSH
77447: LD_VAR 0 2
77451: PPUSH
77452: CALL_OW 1
77456: ST_TO_ADDR
// end ;
77457: LD_VAR 0 3
77461: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
77462: LD_INT 0
77464: PPUSH
// if not mc_bases [ base ] then
77465: LD_EXP 58
77469: PUSH
77470: LD_VAR 0 1
77474: ARRAY
77475: NOT
77476: IFFALSE 77480
// exit ;
77478: GO 77517
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
77480: LD_ADDR_EXP 79
77484: PUSH
77485: LD_EXP 79
77489: PPUSH
77490: LD_VAR 0 1
77494: PPUSH
77495: LD_EXP 79
77499: PUSH
77500: LD_VAR 0 1
77504: ARRAY
77505: PUSH
77506: LD_VAR 0 2
77510: UNION
77511: PPUSH
77512: CALL_OW 1
77516: ST_TO_ADDR
// end ;
77517: LD_VAR 0 3
77521: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
77522: LD_INT 0
77524: PPUSH
// if not mc_bases [ base ] then
77525: LD_EXP 58
77529: PUSH
77530: LD_VAR 0 1
77534: ARRAY
77535: NOT
77536: IFFALSE 77540
// exit ;
77538: GO 77652
// mc_defender := Replace ( mc_defender , base , deflist ) ;
77540: LD_ADDR_EXP 80
77544: PUSH
77545: LD_EXP 80
77549: PPUSH
77550: LD_VAR 0 1
77554: PPUSH
77555: LD_VAR 0 2
77559: PPUSH
77560: CALL_OW 1
77564: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
77565: LD_ADDR_EXP 69
77569: PUSH
77570: LD_EXP 69
77574: PPUSH
77575: LD_VAR 0 1
77579: PPUSH
77580: LD_VAR 0 2
77584: PUSH
77585: LD_INT 0
77587: PLUS
77588: PPUSH
77589: CALL_OW 1
77593: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
77594: LD_ADDR_EXP 77
77598: PUSH
77599: LD_EXP 77
77603: PPUSH
77604: LD_VAR 0 1
77608: PPUSH
77609: LD_EXP 77
77613: PUSH
77614: LD_VAR 0 1
77618: ARRAY
77619: PUSH
77620: LD_EXP 80
77624: PUSH
77625: LD_VAR 0 1
77629: ARRAY
77630: PPUSH
77631: LD_INT 21
77633: PUSH
77634: LD_INT 2
77636: PUSH
77637: EMPTY
77638: LIST
77639: LIST
77640: PPUSH
77641: CALL_OW 72
77645: UNION
77646: PPUSH
77647: CALL_OW 1
77651: ST_TO_ADDR
// end ;
77652: LD_VAR 0 3
77656: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
77657: LD_INT 0
77659: PPUSH
// if not mc_bases [ base ] then
77660: LD_EXP 58
77664: PUSH
77665: LD_VAR 0 1
77669: ARRAY
77670: NOT
77671: IFFALSE 77675
// exit ;
77673: GO 77700
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
77675: LD_ADDR_EXP 69
77679: PUSH
77680: LD_EXP 69
77684: PPUSH
77685: LD_VAR 0 1
77689: PPUSH
77690: LD_VAR 0 2
77694: PPUSH
77695: CALL_OW 1
77699: ST_TO_ADDR
// end ;
77700: LD_VAR 0 3
77704: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
77705: LD_INT 0
77707: PPUSH
77708: PPUSH
77709: PPUSH
77710: PPUSH
// if not mc_bases [ base ] then
77711: LD_EXP 58
77715: PUSH
77716: LD_VAR 0 1
77720: ARRAY
77721: NOT
77722: IFFALSE 77726
// exit ;
77724: GO 77791
// mc_attack := Add ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
77726: LD_ADDR_EXP 78
77730: PUSH
77731: LD_EXP 78
77735: PPUSH
77736: LD_VAR 0 1
77740: PUSH
77741: LD_EXP 78
77745: PUSH
77746: LD_VAR 0 1
77750: ARRAY
77751: PUSH
77752: LD_INT 1
77754: PLUS
77755: PUSH
77756: EMPTY
77757: LIST
77758: LIST
77759: PPUSH
77760: LD_VAR 0 1
77764: PUSH
77765: LD_VAR 0 2
77769: PUSH
77770: LD_VAR 0 3
77774: PUSH
77775: LD_VAR 0 4
77779: PUSH
77780: EMPTY
77781: LIST
77782: LIST
77783: LIST
77784: LIST
77785: PPUSH
77786: CALL 20697 0 3
77790: ST_TO_ADDR
// end ;
77791: LD_VAR 0 5
77795: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
77796: LD_INT 0
77798: PPUSH
// if not mc_bases [ base ] then
77799: LD_EXP 58
77803: PUSH
77804: LD_VAR 0 1
77808: ARRAY
77809: NOT
77810: IFFALSE 77814
// exit ;
77812: GO 77839
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
77814: LD_ADDR_EXP 95
77818: PUSH
77819: LD_EXP 95
77823: PPUSH
77824: LD_VAR 0 1
77828: PPUSH
77829: LD_VAR 0 2
77833: PPUSH
77834: CALL_OW 1
77838: ST_TO_ADDR
// end ;
77839: LD_VAR 0 3
77843: RET
// export function MC_GetMinesField ( base ) ; begin
77844: LD_INT 0
77846: PPUSH
// result := mc_mines [ base ] ;
77847: LD_ADDR_VAR 0 2
77851: PUSH
77852: LD_EXP 71
77856: PUSH
77857: LD_VAR 0 1
77861: ARRAY
77862: ST_TO_ADDR
// end ;
77863: LD_VAR 0 2
77867: RET
// export function MC_GetProduceList ( base ) ; begin
77868: LD_INT 0
77870: PPUSH
// result := mc_produce [ base ] ;
77871: LD_ADDR_VAR 0 2
77875: PUSH
77876: LD_EXP 79
77880: PUSH
77881: LD_VAR 0 1
77885: ARRAY
77886: ST_TO_ADDR
// end ;
77887: LD_VAR 0 2
77891: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
77892: LD_INT 0
77894: PPUSH
77895: PPUSH
// if not mc_bases then
77896: LD_EXP 58
77900: NOT
77901: IFFALSE 77905
// exit ;
77903: GO 77970
// if mc_bases [ base ] then
77905: LD_EXP 58
77909: PUSH
77910: LD_VAR 0 1
77914: ARRAY
77915: IFFALSE 77970
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
77917: LD_ADDR_VAR 0 3
77921: PUSH
77922: LD_EXP 58
77926: PUSH
77927: LD_VAR 0 1
77931: ARRAY
77932: PPUSH
77933: LD_INT 30
77935: PUSH
77936: LD_VAR 0 2
77940: PUSH
77941: EMPTY
77942: LIST
77943: LIST
77944: PPUSH
77945: CALL_OW 72
77949: ST_TO_ADDR
// if result then
77950: LD_VAR 0 3
77954: IFFALSE 77970
// result := result [ 1 ] ;
77956: LD_ADDR_VAR 0 3
77960: PUSH
77961: LD_VAR 0 3
77965: PUSH
77966: LD_INT 1
77968: ARRAY
77969: ST_TO_ADDR
// end ; end ;
77970: LD_VAR 0 3
77974: RET
// export function MC_SetTame ( base , area ) ; begin
77975: LD_INT 0
77977: PPUSH
// if not mc_bases or not base then
77978: LD_EXP 58
77982: NOT
77983: PUSH
77984: LD_VAR 0 1
77988: NOT
77989: OR
77990: IFFALSE 77994
// exit ;
77992: GO 78019
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
77994: LD_ADDR_EXP 86
77998: PUSH
77999: LD_EXP 86
78003: PPUSH
78004: LD_VAR 0 1
78008: PPUSH
78009: LD_VAR 0 2
78013: PPUSH
78014: CALL_OW 1
78018: ST_TO_ADDR
// end ;
78019: LD_VAR 0 3
78023: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78024: LD_INT 0
78026: PPUSH
78027: PPUSH
// if not mc_bases or not base then
78028: LD_EXP 58
78032: NOT
78033: PUSH
78034: LD_VAR 0 1
78038: NOT
78039: OR
78040: IFFALSE 78044
// exit ;
78042: GO 78146
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78044: LD_ADDR_VAR 0 4
78048: PUSH
78049: LD_EXP 58
78053: PUSH
78054: LD_VAR 0 1
78058: ARRAY
78059: PPUSH
78060: LD_INT 30
78062: PUSH
78063: LD_VAR 0 2
78067: PUSH
78068: EMPTY
78069: LIST
78070: LIST
78071: PPUSH
78072: CALL_OW 72
78076: ST_TO_ADDR
// if not tmp then
78077: LD_VAR 0 4
78081: NOT
78082: IFFALSE 78086
// exit ;
78084: GO 78146
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
78086: LD_ADDR_EXP 90
78090: PUSH
78091: LD_EXP 90
78095: PPUSH
78096: LD_VAR 0 1
78100: PPUSH
78101: LD_EXP 90
78105: PUSH
78106: LD_VAR 0 1
78110: ARRAY
78111: PPUSH
78112: LD_EXP 90
78116: PUSH
78117: LD_VAR 0 1
78121: ARRAY
78122: PUSH
78123: LD_INT 1
78125: PLUS
78126: PPUSH
78127: LD_VAR 0 4
78131: PUSH
78132: LD_INT 1
78134: ARRAY
78135: PPUSH
78136: CALL_OW 2
78140: PPUSH
78141: CALL_OW 1
78145: ST_TO_ADDR
// end ;
78146: LD_VAR 0 3
78150: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
78151: LD_INT 0
78153: PPUSH
78154: PPUSH
// if not mc_bases or not base or not kinds then
78155: LD_EXP 58
78159: NOT
78160: PUSH
78161: LD_VAR 0 1
78165: NOT
78166: OR
78167: PUSH
78168: LD_VAR 0 2
78172: NOT
78173: OR
78174: IFFALSE 78178
// exit ;
78176: GO 78239
// for i in kinds do
78178: LD_ADDR_VAR 0 4
78182: PUSH
78183: LD_VAR 0 2
78187: PUSH
78188: FOR_IN
78189: IFFALSE 78237
// mc_lab_upgrade := Add ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
78191: LD_ADDR_EXP 92
78195: PUSH
78196: LD_EXP 92
78200: PPUSH
78201: LD_VAR 0 1
78205: PUSH
78206: LD_EXP 92
78210: PUSH
78211: LD_VAR 0 1
78215: ARRAY
78216: PUSH
78217: LD_INT 1
78219: PLUS
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PPUSH
78225: LD_VAR 0 4
78229: PPUSH
78230: CALL 20697 0 3
78234: ST_TO_ADDR
78235: GO 78188
78237: POP
78238: POP
// end ;
78239: LD_VAR 0 3
78243: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
78244: LD_INT 0
78246: PPUSH
// if not mc_bases or not base or not areas then
78247: LD_EXP 58
78251: NOT
78252: PUSH
78253: LD_VAR 0 1
78257: NOT
78258: OR
78259: PUSH
78260: LD_VAR 0 2
78264: NOT
78265: OR
78266: IFFALSE 78270
// exit ;
78268: GO 78295
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
78270: LD_ADDR_EXP 76
78274: PUSH
78275: LD_EXP 76
78279: PPUSH
78280: LD_VAR 0 1
78284: PPUSH
78285: LD_VAR 0 2
78289: PPUSH
78290: CALL_OW 1
78294: ST_TO_ADDR
// end ;
78295: LD_VAR 0 3
78299: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
78300: LD_INT 0
78302: PPUSH
// if not mc_bases or not base or not teleports_exit then
78303: LD_EXP 58
78307: NOT
78308: PUSH
78309: LD_VAR 0 1
78313: NOT
78314: OR
78315: PUSH
78316: LD_VAR 0 2
78320: NOT
78321: OR
78322: IFFALSE 78326
// exit ;
78324: GO 78351
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
78326: LD_ADDR_EXP 93
78330: PUSH
78331: LD_EXP 93
78335: PPUSH
78336: LD_VAR 0 1
78340: PPUSH
78341: LD_VAR 0 2
78345: PPUSH
78346: CALL_OW 1
78350: ST_TO_ADDR
// end ;
78351: LD_VAR 0 3
78355: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
78356: LD_INT 0
78358: PPUSH
78359: PPUSH
78360: PPUSH
// if not mc_bases or not base or not ext_list then
78361: LD_EXP 58
78365: NOT
78366: PUSH
78367: LD_VAR 0 1
78371: NOT
78372: OR
78373: PUSH
78374: LD_VAR 0 5
78378: NOT
78379: OR
78380: IFFALSE 78384
// exit ;
78382: GO 78557
// tmp := GetFacExtXYD ( x , y , d ) ;
78384: LD_ADDR_VAR 0 8
78388: PUSH
78389: LD_VAR 0 2
78393: PPUSH
78394: LD_VAR 0 3
78398: PPUSH
78399: LD_VAR 0 4
78403: PPUSH
78404: CALL 53423 0 3
78408: ST_TO_ADDR
// if not tmp then
78409: LD_VAR 0 8
78413: NOT
78414: IFFALSE 78418
// exit ;
78416: GO 78557
// for i in tmp do
78418: LD_ADDR_VAR 0 7
78422: PUSH
78423: LD_VAR 0 8
78427: PUSH
78428: FOR_IN
78429: IFFALSE 78555
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
78431: LD_ADDR_EXP 63
78435: PUSH
78436: LD_EXP 63
78440: PPUSH
78441: LD_VAR 0 1
78445: PPUSH
78446: LD_EXP 63
78450: PUSH
78451: LD_VAR 0 1
78455: ARRAY
78456: PPUSH
78457: LD_EXP 63
78461: PUSH
78462: LD_VAR 0 1
78466: ARRAY
78467: PUSH
78468: LD_INT 1
78470: PLUS
78471: PPUSH
78472: LD_VAR 0 5
78476: PUSH
78477: LD_INT 1
78479: ARRAY
78480: PUSH
78481: LD_VAR 0 7
78485: PUSH
78486: LD_INT 1
78488: ARRAY
78489: PUSH
78490: LD_VAR 0 7
78494: PUSH
78495: LD_INT 2
78497: ARRAY
78498: PUSH
78499: LD_VAR 0 7
78503: PUSH
78504: LD_INT 3
78506: ARRAY
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: LIST
78512: LIST
78513: PPUSH
78514: CALL_OW 2
78518: PPUSH
78519: CALL_OW 1
78523: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
78524: LD_ADDR_VAR 0 5
78528: PUSH
78529: LD_VAR 0 5
78533: PPUSH
78534: LD_INT 1
78536: PPUSH
78537: CALL_OW 3
78541: ST_TO_ADDR
// if not ext_list then
78542: LD_VAR 0 5
78546: NOT
78547: IFFALSE 78553
// exit ;
78549: POP
78550: POP
78551: GO 78557
// end ;
78553: GO 78428
78555: POP
78556: POP
// end ;
78557: LD_VAR 0 6
78561: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
78562: LD_INT 0
78564: PPUSH
// if not mc_bases or not base or not weapon_list then
78565: LD_EXP 58
78569: NOT
78570: PUSH
78571: LD_VAR 0 1
78575: NOT
78576: OR
78577: PUSH
78578: LD_VAR 0 2
78582: NOT
78583: OR
78584: IFFALSE 78588
// exit ;
78586: GO 78613
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
78588: LD_ADDR_EXP 97
78592: PUSH
78593: LD_EXP 97
78597: PPUSH
78598: LD_VAR 0 1
78602: PPUSH
78603: LD_VAR 0 2
78607: PPUSH
78608: CALL_OW 1
78612: ST_TO_ADDR
// end ;
78613: LD_VAR 0 3
78617: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
78618: LD_INT 0
78620: PPUSH
// if not mc_bases or not base or not tech_list then
78621: LD_EXP 58
78625: NOT
78626: PUSH
78627: LD_VAR 0 1
78631: NOT
78632: OR
78633: PUSH
78634: LD_VAR 0 2
78638: NOT
78639: OR
78640: IFFALSE 78644
// exit ;
78642: GO 78669
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
78644: LD_ADDR_EXP 85
78648: PUSH
78649: LD_EXP 85
78653: PPUSH
78654: LD_VAR 0 1
78658: PPUSH
78659: LD_VAR 0 2
78663: PPUSH
78664: CALL_OW 1
78668: ST_TO_ADDR
// end ;
78669: LD_VAR 0 3
78673: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
78674: LD_INT 0
78676: PPUSH
// if not mc_bases or not parking_area or not base then
78677: LD_EXP 58
78681: NOT
78682: PUSH
78683: LD_VAR 0 2
78687: NOT
78688: OR
78689: PUSH
78690: LD_VAR 0 1
78694: NOT
78695: OR
78696: IFFALSE 78700
// exit ;
78698: GO 78725
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
78700: LD_ADDR_EXP 82
78704: PUSH
78705: LD_EXP 82
78709: PPUSH
78710: LD_VAR 0 1
78714: PPUSH
78715: LD_VAR 0 2
78719: PPUSH
78720: CALL_OW 1
78724: ST_TO_ADDR
// end ;
78725: LD_VAR 0 3
78729: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
78730: LD_INT 0
78732: PPUSH
// if not mc_bases or not base or not scan_area then
78733: LD_EXP 58
78737: NOT
78738: PUSH
78739: LD_VAR 0 1
78743: NOT
78744: OR
78745: PUSH
78746: LD_VAR 0 2
78750: NOT
78751: OR
78752: IFFALSE 78756
// exit ;
78754: GO 78781
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
78756: LD_ADDR_EXP 83
78760: PUSH
78761: LD_EXP 83
78765: PPUSH
78766: LD_VAR 0 1
78770: PPUSH
78771: LD_VAR 0 2
78775: PPUSH
78776: CALL_OW 1
78780: ST_TO_ADDR
// end ;
78781: LD_VAR 0 3
78785: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
78786: LD_INT 0
78788: PPUSH
78789: PPUSH
// if not mc_bases or not base then
78790: LD_EXP 58
78794: NOT
78795: PUSH
78796: LD_VAR 0 1
78800: NOT
78801: OR
78802: IFFALSE 78806
// exit ;
78804: GO 78870
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
78806: LD_ADDR_VAR 0 3
78810: PUSH
78811: LD_INT 1
78813: PUSH
78814: LD_INT 2
78816: PUSH
78817: LD_INT 3
78819: PUSH
78820: LD_INT 4
78822: PUSH
78823: LD_INT 11
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: LIST
78830: LIST
78831: LIST
78832: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
78833: LD_ADDR_EXP 85
78837: PUSH
78838: LD_EXP 85
78842: PPUSH
78843: LD_VAR 0 1
78847: PPUSH
78848: LD_EXP 85
78852: PUSH
78853: LD_VAR 0 1
78857: ARRAY
78858: PUSH
78859: LD_VAR 0 3
78863: DIFF
78864: PPUSH
78865: CALL_OW 1
78869: ST_TO_ADDR
// end ; end_of_file
78870: LD_VAR 0 2
78874: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
78875: LD_INT 0
78877: PPUSH
78878: PPUSH
78879: PPUSH
// if not mc_bases then
78880: LD_EXP 58
78884: NOT
78885: IFFALSE 78889
// exit ;
78887: GO 79054
// for i = 1 to mc_bases do
78889: LD_ADDR_VAR 0 4
78893: PUSH
78894: DOUBLE
78895: LD_INT 1
78897: DEC
78898: ST_TO_ADDR
78899: LD_EXP 58
78903: PUSH
78904: FOR_TO
78905: IFFALSE 79052
// begin if sci in mc_bases [ i ] then
78907: LD_VAR 0 2
78911: PUSH
78912: LD_EXP 58
78916: PUSH
78917: LD_VAR 0 4
78921: ARRAY
78922: IN
78923: IFFALSE 79050
// begin mc_ape := Add ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
78925: LD_ADDR_EXP 87
78929: PUSH
78930: LD_EXP 87
78934: PPUSH
78935: LD_VAR 0 4
78939: PUSH
78940: LD_EXP 87
78944: PUSH
78945: LD_VAR 0 4
78949: ARRAY
78950: PUSH
78951: LD_INT 1
78953: PLUS
78954: PUSH
78955: EMPTY
78956: LIST
78957: LIST
78958: PPUSH
78959: LD_VAR 0 1
78963: PPUSH
78964: CALL 20697 0 3
78968: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
78969: LD_ADDR_VAR 0 5
78973: PUSH
78974: LD_EXP 58
78978: PUSH
78979: LD_VAR 0 4
78983: ARRAY
78984: PPUSH
78985: LD_INT 2
78987: PUSH
78988: LD_INT 30
78990: PUSH
78991: LD_INT 0
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 30
79000: PUSH
79001: LD_INT 1
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: LIST
79012: PPUSH
79013: CALL_OW 72
79017: PPUSH
79018: LD_VAR 0 1
79022: PPUSH
79023: CALL_OW 74
79027: ST_TO_ADDR
// if tmp then
79028: LD_VAR 0 5
79032: IFFALSE 79048
// ComStandNearbyBuilding ( ape , tmp ) ;
79034: LD_VAR 0 1
79038: PPUSH
79039: LD_VAR 0 5
79043: PPUSH
79044: CALL 14939 0 2
// break ;
79048: GO 79052
// end ; end ;
79050: GO 78904
79052: POP
79053: POP
// end ;
79054: LD_VAR 0 3
79058: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
79059: LD_INT 0
79061: PPUSH
79062: PPUSH
79063: PPUSH
// if not mc_bases then
79064: LD_EXP 58
79068: NOT
79069: IFFALSE 79073
// exit ;
79071: GO 79162
// for i = 1 to mc_bases do
79073: LD_ADDR_VAR 0 4
79077: PUSH
79078: DOUBLE
79079: LD_INT 1
79081: DEC
79082: ST_TO_ADDR
79083: LD_EXP 58
79087: PUSH
79088: FOR_TO
79089: IFFALSE 79160
// begin if building in mc_busy_turret_list [ i ] then
79091: LD_VAR 0 1
79095: PUSH
79096: LD_EXP 68
79100: PUSH
79101: LD_VAR 0 4
79105: ARRAY
79106: IN
79107: IFFALSE 79158
// begin tmp := mc_busy_turret_list [ i ] diff building ;
79109: LD_ADDR_VAR 0 5
79113: PUSH
79114: LD_EXP 68
79118: PUSH
79119: LD_VAR 0 4
79123: ARRAY
79124: PUSH
79125: LD_VAR 0 1
79129: DIFF
79130: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
79131: LD_ADDR_EXP 68
79135: PUSH
79136: LD_EXP 68
79140: PPUSH
79141: LD_VAR 0 4
79145: PPUSH
79146: LD_VAR 0 5
79150: PPUSH
79151: CALL_OW 1
79155: ST_TO_ADDR
// break ;
79156: GO 79160
// end ; end ;
79158: GO 79088
79160: POP
79161: POP
// end ;
79162: LD_VAR 0 3
79166: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
79167: LD_INT 0
79169: PPUSH
79170: PPUSH
79171: PPUSH
// if not mc_bases then
79172: LD_EXP 58
79176: NOT
79177: IFFALSE 79181
// exit ;
79179: GO 79380
// for i = 1 to mc_bases do
79181: LD_ADDR_VAR 0 5
79185: PUSH
79186: DOUBLE
79187: LD_INT 1
79189: DEC
79190: ST_TO_ADDR
79191: LD_EXP 58
79195: PUSH
79196: FOR_TO
79197: IFFALSE 79378
// if building in mc_bases [ i ] then
79199: LD_VAR 0 1
79203: PUSH
79204: LD_EXP 58
79208: PUSH
79209: LD_VAR 0 5
79213: ARRAY
79214: IN
79215: IFFALSE 79376
// begin tmp := mc_bases [ i ] diff building ;
79217: LD_ADDR_VAR 0 6
79221: PUSH
79222: LD_EXP 58
79226: PUSH
79227: LD_VAR 0 5
79231: ARRAY
79232: PUSH
79233: LD_VAR 0 1
79237: DIFF
79238: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
79239: LD_ADDR_EXP 58
79243: PUSH
79244: LD_EXP 58
79248: PPUSH
79249: LD_VAR 0 5
79253: PPUSH
79254: LD_VAR 0 6
79258: PPUSH
79259: CALL_OW 1
79263: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
79264: LD_VAR 0 1
79268: PUSH
79269: LD_EXP 66
79273: PUSH
79274: LD_VAR 0 5
79278: ARRAY
79279: IN
79280: IFFALSE 79319
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
79282: LD_ADDR_EXP 66
79286: PUSH
79287: LD_EXP 66
79291: PPUSH
79292: LD_VAR 0 5
79296: PPUSH
79297: LD_EXP 66
79301: PUSH
79302: LD_VAR 0 5
79306: ARRAY
79307: PUSH
79308: LD_VAR 0 1
79312: DIFF
79313: PPUSH
79314: CALL_OW 1
79318: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
79319: LD_VAR 0 1
79323: PUSH
79324: LD_EXP 67
79328: PUSH
79329: LD_VAR 0 5
79333: ARRAY
79334: IN
79335: IFFALSE 79374
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
79337: LD_ADDR_EXP 67
79341: PUSH
79342: LD_EXP 67
79346: PPUSH
79347: LD_VAR 0 5
79351: PPUSH
79352: LD_EXP 67
79356: PUSH
79357: LD_VAR 0 5
79361: ARRAY
79362: PUSH
79363: LD_VAR 0 1
79367: DIFF
79368: PPUSH
79369: CALL_OW 1
79373: ST_TO_ADDR
// break ;
79374: GO 79378
// end ;
79376: GO 79196
79378: POP
79379: POP
// end ;
79380: LD_VAR 0 4
79384: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
79385: LD_INT 0
79387: PPUSH
79388: PPUSH
79389: PPUSH
// if not mc_bases or not side in mc_sides then
79390: LD_EXP 58
79394: NOT
79395: PUSH
79396: LD_VAR 0 3
79400: PUSH
79401: LD_EXP 84
79405: IN
79406: NOT
79407: OR
79408: IFFALSE 79412
// exit ;
79410: GO 79535
// for i = 1 to mc_vehicles do
79412: LD_ADDR_VAR 0 6
79416: PUSH
79417: DOUBLE
79418: LD_INT 1
79420: DEC
79421: ST_TO_ADDR
79422: LD_EXP 77
79426: PUSH
79427: FOR_TO
79428: IFFALSE 79533
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
79430: LD_VAR 0 2
79434: PUSH
79435: LD_EXP 77
79439: PUSH
79440: LD_VAR 0 6
79444: ARRAY
79445: IN
79446: PUSH
79447: LD_VAR 0 1
79451: PUSH
79452: LD_EXP 77
79456: PUSH
79457: LD_VAR 0 6
79461: ARRAY
79462: IN
79463: OR
79464: IFFALSE 79531
// begin tmp := mc_vehicles [ i ] diff old ;
79466: LD_ADDR_VAR 0 7
79470: PUSH
79471: LD_EXP 77
79475: PUSH
79476: LD_VAR 0 6
79480: ARRAY
79481: PUSH
79482: LD_VAR 0 2
79486: DIFF
79487: ST_TO_ADDR
// tmp := tmp diff new ;
79488: LD_ADDR_VAR 0 7
79492: PUSH
79493: LD_VAR 0 7
79497: PUSH
79498: LD_VAR 0 1
79502: DIFF
79503: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
79504: LD_ADDR_EXP 77
79508: PUSH
79509: LD_EXP 77
79513: PPUSH
79514: LD_VAR 0 6
79518: PPUSH
79519: LD_VAR 0 7
79523: PPUSH
79524: CALL_OW 1
79528: ST_TO_ADDR
// break ;
79529: GO 79533
// end ;
79531: GO 79427
79533: POP
79534: POP
// end ;
79535: LD_VAR 0 5
79539: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
79540: LD_INT 0
79542: PPUSH
79543: PPUSH
79544: PPUSH
79545: PPUSH
// if not mc_bases then
79546: LD_EXP 58
79550: NOT
79551: IFFALSE 79555
// exit ;
79553: GO 79938
// side := GetSide ( vehicle ) ;
79555: LD_ADDR_VAR 0 5
79559: PUSH
79560: LD_VAR 0 1
79564: PPUSH
79565: CALL_OW 255
79569: ST_TO_ADDR
// for i = 1 to mc_bases do
79570: LD_ADDR_VAR 0 4
79574: PUSH
79575: DOUBLE
79576: LD_INT 1
79578: DEC
79579: ST_TO_ADDR
79580: LD_EXP 58
79584: PUSH
79585: FOR_TO
79586: IFFALSE 79936
// begin if factory in mc_bases [ i ] then
79588: LD_VAR 0 2
79592: PUSH
79593: LD_EXP 58
79597: PUSH
79598: LD_VAR 0 4
79602: ARRAY
79603: IN
79604: IFFALSE 79934
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
79606: LD_EXP 80
79610: PUSH
79611: LD_VAR 0 4
79615: ARRAY
79616: PUSH
79617: LD_EXP 69
79621: PUSH
79622: LD_VAR 0 4
79626: ARRAY
79627: LESS
79628: PUSH
79629: LD_VAR 0 1
79633: PPUSH
79634: CALL_OW 264
79638: PUSH
79639: LD_INT 31
79641: PUSH
79642: LD_INT 32
79644: PUSH
79645: LD_INT 51
79647: PUSH
79648: LD_EXP 102
79652: PUSH
79653: LD_INT 12
79655: PUSH
79656: LD_INT 30
79658: PUSH
79659: LD_EXP 101
79663: PUSH
79664: LD_INT 11
79666: PUSH
79667: LD_INT 53
79669: PUSH
79670: LD_INT 14
79672: PUSH
79673: LD_EXP 105
79677: PUSH
79678: LD_INT 29
79680: PUSH
79681: LD_EXP 103
79685: PUSH
79686: LD_INT 13
79688: PUSH
79689: LD_INT 52
79691: PUSH
79692: LD_INT 48
79694: PUSH
79695: LD_INT 8
79697: PUSH
79698: EMPTY
79699: LIST
79700: LIST
79701: LIST
79702: LIST
79703: LIST
79704: LIST
79705: LIST
79706: LIST
79707: LIST
79708: LIST
79709: LIST
79710: LIST
79711: LIST
79712: LIST
79713: LIST
79714: LIST
79715: LIST
79716: IN
79717: NOT
79718: AND
79719: IFFALSE 79760
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
79721: LD_ADDR_EXP 80
79725: PUSH
79726: LD_EXP 80
79730: PPUSH
79731: LD_VAR 0 4
79735: PPUSH
79736: LD_EXP 80
79740: PUSH
79741: LD_VAR 0 4
79745: ARRAY
79746: PUSH
79747: LD_VAR 0 1
79751: ADD
79752: PPUSH
79753: CALL_OW 1
79757: ST_TO_ADDR
79758: GO 79804
// mc_vehicles := Add ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
79760: LD_ADDR_EXP 77
79764: PUSH
79765: LD_EXP 77
79769: PPUSH
79770: LD_VAR 0 4
79774: PUSH
79775: LD_EXP 77
79779: PUSH
79780: LD_VAR 0 4
79784: ARRAY
79785: PUSH
79786: LD_INT 1
79788: PLUS
79789: PUSH
79790: EMPTY
79791: LIST
79792: LIST
79793: PPUSH
79794: LD_VAR 0 1
79798: PPUSH
79799: CALL 20697 0 3
79803: ST_TO_ADDR
// if not mc_scan [ i ] then
79804: LD_EXP 81
79808: PUSH
79809: LD_VAR 0 4
79813: ARRAY
79814: NOT
79815: IFFALSE 79934
// begin if GetControl ( vehicle ) = control_remote then
79817: LD_VAR 0 1
79821: PPUSH
79822: CALL_OW 263
79826: PUSH
79827: LD_INT 2
79829: EQUAL
79830: IFFALSE 79850
// repeat wait ( 0 0$1 ) ;
79832: LD_INT 35
79834: PPUSH
79835: CALL_OW 67
// until IsControledBy ( vehicle ) ;
79839: LD_VAR 0 1
79843: PPUSH
79844: CALL_OW 312
79848: IFFALSE 79832
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
79850: LD_VAR 0 1
79854: PPUSH
79855: LD_EXP 82
79859: PUSH
79860: LD_VAR 0 4
79864: ARRAY
79865: PPUSH
79866: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
79870: LD_VAR 0 1
79874: PPUSH
79875: CALL_OW 263
79879: PUSH
79880: LD_INT 1
79882: NONEQUAL
79883: IFFALSE 79887
// break ;
79885: GO 79936
// repeat wait ( 0 0$1 ) ;
79887: LD_INT 35
79889: PPUSH
79890: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
79894: LD_VAR 0 1
79898: PPUSH
79899: LD_EXP 82
79903: PUSH
79904: LD_VAR 0 4
79908: ARRAY
79909: PPUSH
79910: CALL_OW 308
79914: IFFALSE 79887
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
79916: LD_VAR 0 1
79920: PPUSH
79921: CALL_OW 311
79925: PPUSH
79926: CALL_OW 121
// exit ;
79930: POP
79931: POP
79932: GO 79938
// end ; end ; end ;
79934: GO 79585
79936: POP
79937: POP
// end ;
79938: LD_VAR 0 3
79942: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
79943: LD_INT 0
79945: PPUSH
79946: PPUSH
79947: PPUSH
79948: PPUSH
// if not mc_bases then
79949: LD_EXP 58
79953: NOT
79954: IFFALSE 79958
// exit ;
79956: GO 80311
// repeat wait ( 0 0$1 ) ;
79958: LD_INT 35
79960: PPUSH
79961: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
79965: LD_VAR 0 2
79969: PPUSH
79970: LD_VAR 0 3
79974: PPUSH
79975: CALL_OW 284
79979: IFFALSE 79958
// if GetResourceTypeXY ( x , y ) = mat_artefact then
79981: LD_VAR 0 2
79985: PPUSH
79986: LD_VAR 0 3
79990: PPUSH
79991: CALL_OW 283
79995: PUSH
79996: LD_INT 4
79998: EQUAL
79999: IFFALSE 80003
// exit ;
80001: GO 80311
// for i = 1 to mc_bases do
80003: LD_ADDR_VAR 0 7
80007: PUSH
80008: DOUBLE
80009: LD_INT 1
80011: DEC
80012: ST_TO_ADDR
80013: LD_EXP 58
80017: PUSH
80018: FOR_TO
80019: IFFALSE 80309
// begin if mc_crates_area [ i ] then
80021: LD_EXP 76
80025: PUSH
80026: LD_VAR 0 7
80030: ARRAY
80031: IFFALSE 80142
// for j in mc_crates_area [ i ] do
80033: LD_ADDR_VAR 0 8
80037: PUSH
80038: LD_EXP 76
80042: PUSH
80043: LD_VAR 0 7
80047: ARRAY
80048: PUSH
80049: FOR_IN
80050: IFFALSE 80140
// if InArea ( x , y , j ) then
80052: LD_VAR 0 2
80056: PPUSH
80057: LD_VAR 0 3
80061: PPUSH
80062: LD_VAR 0 8
80066: PPUSH
80067: CALL_OW 309
80071: IFFALSE 80138
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80073: LD_ADDR_EXP 74
80077: PUSH
80078: LD_EXP 74
80082: PPUSH
80083: LD_VAR 0 7
80087: PUSH
80088: LD_EXP 74
80092: PUSH
80093: LD_VAR 0 7
80097: ARRAY
80098: PUSH
80099: LD_INT 1
80101: PLUS
80102: PUSH
80103: EMPTY
80104: LIST
80105: LIST
80106: PPUSH
80107: LD_VAR 0 4
80111: PUSH
80112: LD_VAR 0 2
80116: PUSH
80117: LD_VAR 0 3
80121: PUSH
80122: EMPTY
80123: LIST
80124: LIST
80125: LIST
80126: PPUSH
80127: CALL 20697 0 3
80131: ST_TO_ADDR
// exit ;
80132: POP
80133: POP
80134: POP
80135: POP
80136: GO 80311
// end ;
80138: GO 80049
80140: POP
80141: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80142: LD_ADDR_VAR 0 9
80146: PUSH
80147: LD_EXP 58
80151: PUSH
80152: LD_VAR 0 7
80156: ARRAY
80157: PPUSH
80158: LD_INT 2
80160: PUSH
80161: LD_INT 30
80163: PUSH
80164: LD_INT 0
80166: PUSH
80167: EMPTY
80168: LIST
80169: LIST
80170: PUSH
80171: LD_INT 30
80173: PUSH
80174: LD_INT 1
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: LIST
80185: PPUSH
80186: CALL_OW 72
80190: ST_TO_ADDR
// if not depot then
80191: LD_VAR 0 9
80195: NOT
80196: IFFALSE 80200
// continue ;
80198: GO 80018
// for j in depot do
80200: LD_ADDR_VAR 0 8
80204: PUSH
80205: LD_VAR 0 9
80209: PUSH
80210: FOR_IN
80211: IFFALSE 80305
// if GetDistUnitXY ( j , x , y ) < 30 then
80213: LD_VAR 0 8
80217: PPUSH
80218: LD_VAR 0 2
80222: PPUSH
80223: LD_VAR 0 3
80227: PPUSH
80228: CALL_OW 297
80232: PUSH
80233: LD_INT 30
80235: LESS
80236: IFFALSE 80303
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
80238: LD_ADDR_EXP 74
80242: PUSH
80243: LD_EXP 74
80247: PPUSH
80248: LD_VAR 0 7
80252: PUSH
80253: LD_EXP 74
80257: PUSH
80258: LD_VAR 0 7
80262: ARRAY
80263: PUSH
80264: LD_INT 1
80266: PLUS
80267: PUSH
80268: EMPTY
80269: LIST
80270: LIST
80271: PPUSH
80272: LD_VAR 0 4
80276: PUSH
80277: LD_VAR 0 2
80281: PUSH
80282: LD_VAR 0 3
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: LIST
80291: PPUSH
80292: CALL 20697 0 3
80296: ST_TO_ADDR
// exit ;
80297: POP
80298: POP
80299: POP
80300: POP
80301: GO 80311
// end ;
80303: GO 80210
80305: POP
80306: POP
// end ;
80307: GO 80018
80309: POP
80310: POP
// end ;
80311: LD_VAR 0 6
80315: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
80316: LD_INT 0
80318: PPUSH
80319: PPUSH
80320: PPUSH
80321: PPUSH
// side := GetSide ( lab ) ;
80322: LD_ADDR_VAR 0 4
80326: PUSH
80327: LD_VAR 0 2
80331: PPUSH
80332: CALL_OW 255
80336: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
80337: LD_VAR 0 4
80341: PUSH
80342: LD_EXP 84
80346: IN
80347: NOT
80348: PUSH
80349: LD_EXP 85
80353: NOT
80354: OR
80355: PUSH
80356: LD_EXP 58
80360: NOT
80361: OR
80362: IFFALSE 80366
// exit ;
80364: GO 80599
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
80366: LD_ADDR_EXP 85
80370: PUSH
80371: LD_EXP 85
80375: PPUSH
80376: LD_VAR 0 4
80380: PPUSH
80381: LD_EXP 85
80385: PUSH
80386: LD_VAR 0 4
80390: ARRAY
80391: PUSH
80392: LD_VAR 0 1
80396: DIFF
80397: PPUSH
80398: CALL_OW 1
80402: ST_TO_ADDR
// for i = 1 to mc_bases do
80403: LD_ADDR_VAR 0 5
80407: PUSH
80408: DOUBLE
80409: LD_INT 1
80411: DEC
80412: ST_TO_ADDR
80413: LD_EXP 58
80417: PUSH
80418: FOR_TO
80419: IFFALSE 80597
// begin if lab in mc_bases [ i ] then
80421: LD_VAR 0 2
80425: PUSH
80426: LD_EXP 58
80430: PUSH
80431: LD_VAR 0 5
80435: ARRAY
80436: IN
80437: IFFALSE 80595
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
80439: LD_VAR 0 1
80443: PUSH
80444: LD_INT 11
80446: PUSH
80447: LD_INT 4
80449: PUSH
80450: LD_INT 3
80452: PUSH
80453: LD_INT 2
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: IN
80462: PUSH
80463: LD_EXP 88
80467: PUSH
80468: LD_VAR 0 5
80472: ARRAY
80473: AND
80474: IFFALSE 80595
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
80476: LD_ADDR_VAR 0 6
80480: PUSH
80481: LD_EXP 88
80485: PUSH
80486: LD_VAR 0 5
80490: ARRAY
80491: PUSH
80492: LD_INT 1
80494: ARRAY
80495: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80496: LD_ADDR_EXP 88
80500: PUSH
80501: LD_EXP 88
80505: PPUSH
80506: LD_VAR 0 5
80510: PPUSH
80511: EMPTY
80512: PPUSH
80513: CALL_OW 1
80517: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
80518: LD_VAR 0 6
80522: PPUSH
80523: LD_INT 0
80525: PPUSH
80526: CALL_OW 109
// ComExitBuilding ( tmp ) ;
80530: LD_VAR 0 6
80534: PPUSH
80535: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
80539: LD_ADDR_EXP 87
80543: PUSH
80544: LD_EXP 87
80548: PPUSH
80549: LD_VAR 0 5
80553: PPUSH
80554: LD_EXP 87
80558: PUSH
80559: LD_VAR 0 5
80563: ARRAY
80564: PPUSH
80565: LD_INT 1
80567: PPUSH
80568: LD_VAR 0 6
80572: PPUSH
80573: CALL_OW 2
80577: PPUSH
80578: CALL_OW 1
80582: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
80583: LD_VAR 0 5
80587: PPUSH
80588: LD_INT 112
80590: PPUSH
80591: CALL 58649 0 2
// end ; end ; end ;
80595: GO 80418
80597: POP
80598: POP
// end ;
80599: LD_VAR 0 3
80603: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
80604: LD_INT 0
80606: PPUSH
80607: PPUSH
80608: PPUSH
80609: PPUSH
80610: PPUSH
80611: PPUSH
80612: PPUSH
80613: PPUSH
// if not mc_bases then
80614: LD_EXP 58
80618: NOT
80619: IFFALSE 80623
// exit ;
80621: GO 81566
// for i = 1 to mc_bases do
80623: LD_ADDR_VAR 0 3
80627: PUSH
80628: DOUBLE
80629: LD_INT 1
80631: DEC
80632: ST_TO_ADDR
80633: LD_EXP 58
80637: PUSH
80638: FOR_TO
80639: IFFALSE 81564
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
80641: LD_VAR 0 1
80645: PUSH
80646: LD_EXP 58
80650: PUSH
80651: LD_VAR 0 3
80655: ARRAY
80656: IN
80657: PUSH
80658: LD_VAR 0 1
80662: PUSH
80663: LD_EXP 65
80667: PUSH
80668: LD_VAR 0 3
80672: ARRAY
80673: IN
80674: OR
80675: PUSH
80676: LD_VAR 0 1
80680: PUSH
80681: LD_EXP 77
80685: PUSH
80686: LD_VAR 0 3
80690: ARRAY
80691: IN
80692: OR
80693: PUSH
80694: LD_VAR 0 1
80698: PUSH
80699: LD_EXP 87
80703: PUSH
80704: LD_VAR 0 3
80708: ARRAY
80709: IN
80710: OR
80711: PUSH
80712: LD_VAR 0 1
80716: PUSH
80717: LD_EXP 88
80721: PUSH
80722: LD_VAR 0 3
80726: ARRAY
80727: IN
80728: OR
80729: IFFALSE 81562
// begin if un in mc_ape [ i ] then
80731: LD_VAR 0 1
80735: PUSH
80736: LD_EXP 87
80740: PUSH
80741: LD_VAR 0 3
80745: ARRAY
80746: IN
80747: IFFALSE 80786
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
80749: LD_ADDR_EXP 87
80753: PUSH
80754: LD_EXP 87
80758: PPUSH
80759: LD_VAR 0 3
80763: PPUSH
80764: LD_EXP 87
80768: PUSH
80769: LD_VAR 0 3
80773: ARRAY
80774: PUSH
80775: LD_VAR 0 1
80779: DIFF
80780: PPUSH
80781: CALL_OW 1
80785: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
80786: LD_VAR 0 1
80790: PUSH
80791: LD_EXP 88
80795: PUSH
80796: LD_VAR 0 3
80800: ARRAY
80801: IN
80802: IFFALSE 80826
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
80804: LD_ADDR_EXP 88
80808: PUSH
80809: LD_EXP 88
80813: PPUSH
80814: LD_VAR 0 3
80818: PPUSH
80819: EMPTY
80820: PPUSH
80821: CALL_OW 1
80825: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
80826: LD_VAR 0 1
80830: PPUSH
80831: CALL_OW 247
80835: PUSH
80836: LD_INT 2
80838: EQUAL
80839: PUSH
80840: LD_VAR 0 1
80844: PPUSH
80845: CALL_OW 110
80849: PUSH
80850: LD_INT 20
80852: EQUAL
80853: AND
80854: IFFALSE 80957
// begin fac := MC_GetBuilding ( i , b_factory ) ;
80856: LD_ADDR_VAR 0 8
80860: PUSH
80861: LD_VAR 0 3
80865: PPUSH
80866: LD_INT 3
80868: PPUSH
80869: CALL 77892 0 2
80873: ST_TO_ADDR
// if fac then
80874: LD_VAR 0 8
80878: IFFALSE 80957
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
80880: LD_ADDR_VAR 0 9
80884: PUSH
80885: LD_VAR 0 8
80889: PPUSH
80890: LD_VAR 0 1
80894: PPUSH
80895: CALL_OW 265
80899: PPUSH
80900: LD_VAR 0 1
80904: PPUSH
80905: CALL_OW 262
80909: PPUSH
80910: LD_VAR 0 1
80914: PPUSH
80915: CALL_OW 263
80919: PPUSH
80920: LD_VAR 0 1
80924: PPUSH
80925: CALL_OW 264
80929: PPUSH
80930: CALL 17862 0 5
80934: ST_TO_ADDR
// if components then
80935: LD_VAR 0 9
80939: IFFALSE 80955
// MC_InsertProduceList ( i , components ) ;
80941: LD_VAR 0 3
80945: PPUSH
80946: LD_VAR 0 9
80950: PPUSH
80951: CALL 77462 0 2
// break ;
80955: GO 81564
// end ; end ; if GetType ( un ) = unit_building then
80957: LD_VAR 0 1
80961: PPUSH
80962: CALL_OW 247
80966: PUSH
80967: LD_INT 3
80969: EQUAL
80970: IFFALSE 81285
// begin btype := GetBType ( un ) ;
80972: LD_ADDR_VAR 0 5
80976: PUSH
80977: LD_VAR 0 1
80981: PPUSH
80982: CALL_OW 266
80986: ST_TO_ADDR
// if btype = b_warehouse then
80987: LD_VAR 0 5
80991: PUSH
80992: LD_INT 1
80994: EQUAL
80995: IFFALSE 81013
// begin btype := b_depot ;
80997: LD_ADDR_VAR 0 5
81001: PUSH
81002: LD_INT 0
81004: ST_TO_ADDR
// pos := 1 ;
81005: LD_ADDR_VAR 0 6
81009: PUSH
81010: LD_INT 1
81012: ST_TO_ADDR
// end ; if btype = b_factory then
81013: LD_VAR 0 5
81017: PUSH
81018: LD_INT 3
81020: EQUAL
81021: IFFALSE 81039
// begin btype := b_workshop ;
81023: LD_ADDR_VAR 0 5
81027: PUSH
81028: LD_INT 2
81030: ST_TO_ADDR
// pos := 1 ;
81031: LD_ADDR_VAR 0 6
81035: PUSH
81036: LD_INT 1
81038: ST_TO_ADDR
// end ; if btype = b_barracks then
81039: LD_VAR 0 5
81043: PUSH
81044: LD_INT 5
81046: EQUAL
81047: IFFALSE 81057
// btype := b_armoury ;
81049: LD_ADDR_VAR 0 5
81053: PUSH
81054: LD_INT 4
81056: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
81057: LD_VAR 0 5
81061: PUSH
81062: LD_INT 7
81064: PUSH
81065: LD_INT 8
81067: PUSH
81068: EMPTY
81069: LIST
81070: LIST
81071: IN
81072: IFFALSE 81082
// btype := b_lab ;
81074: LD_ADDR_VAR 0 5
81078: PUSH
81079: LD_INT 6
81081: ST_TO_ADDR
// mc_build_list := Add ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
81082: LD_ADDR_EXP 63
81086: PUSH
81087: LD_EXP 63
81091: PPUSH
81092: LD_VAR 0 3
81096: PUSH
81097: LD_EXP 63
81101: PUSH
81102: LD_VAR 0 3
81106: ARRAY
81107: PUSH
81108: LD_INT 1
81110: PLUS
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PPUSH
81116: LD_VAR 0 5
81120: PUSH
81121: LD_VAR 0 1
81125: PPUSH
81126: CALL_OW 250
81130: PUSH
81131: LD_VAR 0 1
81135: PPUSH
81136: CALL_OW 251
81140: PUSH
81141: LD_VAR 0 1
81145: PPUSH
81146: CALL_OW 254
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: PPUSH
81157: CALL 20697 0 3
81161: ST_TO_ADDR
// if pos = 1 then
81162: LD_VAR 0 6
81166: PUSH
81167: LD_INT 1
81169: EQUAL
81170: IFFALSE 81285
// begin tmp := mc_build_list [ i ] ;
81172: LD_ADDR_VAR 0 7
81176: PUSH
81177: LD_EXP 63
81181: PUSH
81182: LD_VAR 0 3
81186: ARRAY
81187: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81188: LD_VAR 0 7
81192: PPUSH
81193: LD_INT 2
81195: PUSH
81196: LD_INT 30
81198: PUSH
81199: LD_INT 0
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_INT 30
81208: PUSH
81209: LD_INT 1
81211: PUSH
81212: EMPTY
81213: LIST
81214: LIST
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: LIST
81220: PPUSH
81221: CALL_OW 72
81225: IFFALSE 81235
// pos := 2 ;
81227: LD_ADDR_VAR 0 6
81231: PUSH
81232: LD_INT 2
81234: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
81235: LD_ADDR_VAR 0 7
81239: PUSH
81240: LD_VAR 0 7
81244: PPUSH
81245: LD_VAR 0 6
81249: PPUSH
81250: LD_VAR 0 7
81254: PPUSH
81255: CALL 20588 0 3
81259: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
81260: LD_ADDR_EXP 63
81264: PUSH
81265: LD_EXP 63
81269: PPUSH
81270: LD_VAR 0 3
81274: PPUSH
81275: LD_VAR 0 7
81279: PPUSH
81280: CALL_OW 1
81284: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
81285: LD_VAR 0 1
81289: PUSH
81290: LD_EXP 58
81294: PUSH
81295: LD_VAR 0 3
81299: ARRAY
81300: IN
81301: IFFALSE 81340
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
81303: LD_ADDR_EXP 58
81307: PUSH
81308: LD_EXP 58
81312: PPUSH
81313: LD_VAR 0 3
81317: PPUSH
81318: LD_EXP 58
81322: PUSH
81323: LD_VAR 0 3
81327: ARRAY
81328: PUSH
81329: LD_VAR 0 1
81333: DIFF
81334: PPUSH
81335: CALL_OW 1
81339: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
81340: LD_VAR 0 1
81344: PUSH
81345: LD_EXP 65
81349: PUSH
81350: LD_VAR 0 3
81354: ARRAY
81355: IN
81356: IFFALSE 81395
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
81358: LD_ADDR_EXP 65
81362: PUSH
81363: LD_EXP 65
81367: PPUSH
81368: LD_VAR 0 3
81372: PPUSH
81373: LD_EXP 65
81377: PUSH
81378: LD_VAR 0 3
81382: ARRAY
81383: PUSH
81384: LD_VAR 0 1
81388: DIFF
81389: PPUSH
81390: CALL_OW 1
81394: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
81395: LD_VAR 0 1
81399: PUSH
81400: LD_EXP 77
81404: PUSH
81405: LD_VAR 0 3
81409: ARRAY
81410: IN
81411: IFFALSE 81450
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
81413: LD_ADDR_EXP 77
81417: PUSH
81418: LD_EXP 77
81422: PPUSH
81423: LD_VAR 0 3
81427: PPUSH
81428: LD_EXP 77
81432: PUSH
81433: LD_VAR 0 3
81437: ARRAY
81438: PUSH
81439: LD_VAR 0 1
81443: DIFF
81444: PPUSH
81445: CALL_OW 1
81449: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
81450: LD_VAR 0 1
81454: PUSH
81455: LD_EXP 67
81459: PUSH
81460: LD_VAR 0 3
81464: ARRAY
81465: IN
81466: IFFALSE 81505
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
81468: LD_ADDR_EXP 67
81472: PUSH
81473: LD_EXP 67
81477: PPUSH
81478: LD_VAR 0 3
81482: PPUSH
81483: LD_EXP 67
81487: PUSH
81488: LD_VAR 0 3
81492: ARRAY
81493: PUSH
81494: LD_VAR 0 1
81498: DIFF
81499: PPUSH
81500: CALL_OW 1
81504: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
81505: LD_VAR 0 1
81509: PUSH
81510: LD_EXP 66
81514: PUSH
81515: LD_VAR 0 3
81519: ARRAY
81520: IN
81521: IFFALSE 81560
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
81523: LD_ADDR_EXP 66
81527: PUSH
81528: LD_EXP 66
81532: PPUSH
81533: LD_VAR 0 3
81537: PPUSH
81538: LD_EXP 66
81542: PUSH
81543: LD_VAR 0 3
81547: ARRAY
81548: PUSH
81549: LD_VAR 0 1
81553: DIFF
81554: PPUSH
81555: CALL_OW 1
81559: ST_TO_ADDR
// end ; break ;
81560: GO 81564
// end ;
81562: GO 80638
81564: POP
81565: POP
// end ;
81566: LD_VAR 0 2
81570: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
81571: LD_INT 0
81573: PPUSH
81574: PPUSH
81575: PPUSH
// if not mc_bases then
81576: LD_EXP 58
81580: NOT
81581: IFFALSE 81585
// exit ;
81583: GO 81800
// for i = 1 to mc_bases do
81585: LD_ADDR_VAR 0 3
81589: PUSH
81590: DOUBLE
81591: LD_INT 1
81593: DEC
81594: ST_TO_ADDR
81595: LD_EXP 58
81599: PUSH
81600: FOR_TO
81601: IFFALSE 81798
// begin if building in mc_construct_list [ i ] then
81603: LD_VAR 0 1
81607: PUSH
81608: LD_EXP 65
81612: PUSH
81613: LD_VAR 0 3
81617: ARRAY
81618: IN
81619: IFFALSE 81796
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81621: LD_ADDR_EXP 65
81625: PUSH
81626: LD_EXP 65
81630: PPUSH
81631: LD_VAR 0 3
81635: PPUSH
81636: LD_EXP 65
81640: PUSH
81641: LD_VAR 0 3
81645: ARRAY
81646: PUSH
81647: LD_VAR 0 1
81651: DIFF
81652: PPUSH
81653: CALL_OW 1
81657: ST_TO_ADDR
// if building in mc_lab [ i ] then
81658: LD_VAR 0 1
81662: PUSH
81663: LD_EXP 91
81667: PUSH
81668: LD_VAR 0 3
81672: ARRAY
81673: IN
81674: IFFALSE 81729
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
81676: LD_ADDR_EXP 92
81680: PUSH
81681: LD_EXP 92
81685: PPUSH
81686: LD_VAR 0 3
81690: PPUSH
81691: LD_EXP 92
81695: PUSH
81696: LD_VAR 0 3
81700: ARRAY
81701: PPUSH
81702: LD_INT 1
81704: PPUSH
81705: LD_EXP 92
81709: PUSH
81710: LD_VAR 0 3
81714: ARRAY
81715: PPUSH
81716: LD_INT 0
81718: PPUSH
81719: CALL 19680 0 4
81723: PPUSH
81724: CALL_OW 1
81728: ST_TO_ADDR
// if not building in mc_bases [ i ] then
81729: LD_VAR 0 1
81733: PUSH
81734: LD_EXP 58
81738: PUSH
81739: LD_VAR 0 3
81743: ARRAY
81744: IN
81745: NOT
81746: IFFALSE 81792
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81748: LD_ADDR_EXP 58
81752: PUSH
81753: LD_EXP 58
81757: PPUSH
81758: LD_VAR 0 3
81762: PUSH
81763: LD_EXP 58
81767: PUSH
81768: LD_VAR 0 3
81772: ARRAY
81773: PUSH
81774: LD_INT 1
81776: PLUS
81777: PUSH
81778: EMPTY
81779: LIST
81780: LIST
81781: PPUSH
81782: LD_VAR 0 1
81786: PPUSH
81787: CALL 20697 0 3
81791: ST_TO_ADDR
// exit ;
81792: POP
81793: POP
81794: GO 81800
// end ; end ;
81796: GO 81600
81798: POP
81799: POP
// end ;
81800: LD_VAR 0 2
81804: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
81805: LD_INT 0
81807: PPUSH
81808: PPUSH
81809: PPUSH
81810: PPUSH
81811: PPUSH
81812: PPUSH
81813: PPUSH
// if not mc_bases then
81814: LD_EXP 58
81818: NOT
81819: IFFALSE 81823
// exit ;
81821: GO 82484
// for i = 1 to mc_bases do
81823: LD_ADDR_VAR 0 3
81827: PUSH
81828: DOUBLE
81829: LD_INT 1
81831: DEC
81832: ST_TO_ADDR
81833: LD_EXP 58
81837: PUSH
81838: FOR_TO
81839: IFFALSE 82482
// begin if building in mc_construct_list [ i ] then
81841: LD_VAR 0 1
81845: PUSH
81846: LD_EXP 65
81850: PUSH
81851: LD_VAR 0 3
81855: ARRAY
81856: IN
81857: IFFALSE 82480
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81859: LD_ADDR_EXP 65
81863: PUSH
81864: LD_EXP 65
81868: PPUSH
81869: LD_VAR 0 3
81873: PPUSH
81874: LD_EXP 65
81878: PUSH
81879: LD_VAR 0 3
81883: ARRAY
81884: PUSH
81885: LD_VAR 0 1
81889: DIFF
81890: PPUSH
81891: CALL_OW 1
81895: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81896: LD_ADDR_EXP 58
81900: PUSH
81901: LD_EXP 58
81905: PPUSH
81906: LD_VAR 0 3
81910: PUSH
81911: LD_EXP 58
81915: PUSH
81916: LD_VAR 0 3
81920: ARRAY
81921: PUSH
81922: LD_INT 1
81924: PLUS
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PPUSH
81930: LD_VAR 0 1
81934: PPUSH
81935: CALL 20697 0 3
81939: ST_TO_ADDR
// btype := GetBType ( building ) ;
81940: LD_ADDR_VAR 0 5
81944: PUSH
81945: LD_VAR 0 1
81949: PPUSH
81950: CALL_OW 266
81954: ST_TO_ADDR
// side := GetSide ( building ) ;
81955: LD_ADDR_VAR 0 8
81959: PUSH
81960: LD_VAR 0 1
81964: PPUSH
81965: CALL_OW 255
81969: ST_TO_ADDR
// if btype = b_lab then
81970: LD_VAR 0 5
81974: PUSH
81975: LD_INT 6
81977: EQUAL
81978: IFFALSE 82028
// begin mc_lab := Add ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81980: LD_ADDR_EXP 91
81984: PUSH
81985: LD_EXP 91
81989: PPUSH
81990: LD_VAR 0 3
81994: PUSH
81995: LD_EXP 91
81999: PUSH
82000: LD_VAR 0 3
82004: ARRAY
82005: PUSH
82006: LD_INT 1
82008: PLUS
82009: PUSH
82010: EMPTY
82011: LIST
82012: LIST
82013: PPUSH
82014: LD_VAR 0 1
82018: PPUSH
82019: CALL 20697 0 3
82023: ST_TO_ADDR
// exit ;
82024: POP
82025: POP
82026: GO 82484
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
82028: LD_VAR 0 5
82032: PUSH
82033: LD_INT 0
82035: PUSH
82036: LD_INT 2
82038: PUSH
82039: LD_INT 4
82041: PUSH
82042: EMPTY
82043: LIST
82044: LIST
82045: LIST
82046: IN
82047: IFFALSE 82171
// begin if btype = b_armoury then
82049: LD_VAR 0 5
82053: PUSH
82054: LD_INT 4
82056: EQUAL
82057: IFFALSE 82067
// btype := b_barracks ;
82059: LD_ADDR_VAR 0 5
82063: PUSH
82064: LD_INT 5
82066: ST_TO_ADDR
// if btype = b_depot then
82067: LD_VAR 0 5
82071: PUSH
82072: LD_INT 0
82074: EQUAL
82075: IFFALSE 82085
// btype := b_warehouse ;
82077: LD_ADDR_VAR 0 5
82081: PUSH
82082: LD_INT 1
82084: ST_TO_ADDR
// if btype = b_workshop then
82085: LD_VAR 0 5
82089: PUSH
82090: LD_INT 2
82092: EQUAL
82093: IFFALSE 82103
// btype := b_factory ;
82095: LD_ADDR_VAR 0 5
82099: PUSH
82100: LD_INT 3
82102: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
82103: LD_VAR 0 5
82107: PPUSH
82108: LD_VAR 0 8
82112: PPUSH
82113: CALL_OW 323
82117: PUSH
82118: LD_INT 1
82120: EQUAL
82121: IFFALSE 82167
// mc_build_upgrade := Add ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
82123: LD_ADDR_EXP 90
82127: PUSH
82128: LD_EXP 90
82132: PPUSH
82133: LD_VAR 0 3
82137: PUSH
82138: LD_EXP 90
82142: PUSH
82143: LD_VAR 0 3
82147: ARRAY
82148: PUSH
82149: LD_INT 1
82151: PLUS
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PPUSH
82157: LD_VAR 0 1
82161: PPUSH
82162: CALL 20697 0 3
82166: ST_TO_ADDR
// exit ;
82167: POP
82168: POP
82169: GO 82484
// end ; if btype in [ b_bunker , b_turret ] then
82171: LD_VAR 0 5
82175: PUSH
82176: LD_INT 32
82178: PUSH
82179: LD_INT 33
82181: PUSH
82182: EMPTY
82183: LIST
82184: LIST
82185: IN
82186: IFFALSE 82476
// begin mc_turret_list := Add ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
82188: LD_ADDR_EXP 66
82192: PUSH
82193: LD_EXP 66
82197: PPUSH
82198: LD_VAR 0 3
82202: PUSH
82203: LD_EXP 66
82207: PUSH
82208: LD_VAR 0 3
82212: ARRAY
82213: PUSH
82214: LD_INT 1
82216: PLUS
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PPUSH
82222: LD_VAR 0 1
82226: PPUSH
82227: CALL 20697 0 3
82231: ST_TO_ADDR
// if btype = b_bunker then
82232: LD_VAR 0 5
82236: PUSH
82237: LD_INT 32
82239: EQUAL
82240: IFFALSE 82476
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82242: LD_ADDR_EXP 67
82246: PUSH
82247: LD_EXP 67
82251: PPUSH
82252: LD_VAR 0 3
82256: PUSH
82257: LD_EXP 67
82261: PUSH
82262: LD_VAR 0 3
82266: ARRAY
82267: PUSH
82268: LD_INT 1
82270: PLUS
82271: PUSH
82272: EMPTY
82273: LIST
82274: LIST
82275: PPUSH
82276: LD_VAR 0 1
82280: PPUSH
82281: CALL 20697 0 3
82285: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
82286: LD_ADDR_VAR 0 6
82290: PUSH
82291: LD_EXP 58
82295: PUSH
82296: LD_VAR 0 3
82300: ARRAY
82301: PPUSH
82302: LD_INT 25
82304: PUSH
82305: LD_INT 1
82307: PUSH
82308: EMPTY
82309: LIST
82310: LIST
82311: PUSH
82312: LD_INT 3
82314: PUSH
82315: LD_INT 54
82317: PUSH
82318: EMPTY
82319: LIST
82320: PUSH
82321: EMPTY
82322: LIST
82323: LIST
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PPUSH
82329: CALL_OW 72
82333: ST_TO_ADDR
// if tmp then
82334: LD_VAR 0 6
82338: IFFALSE 82344
// exit ;
82340: POP
82341: POP
82342: GO 82484
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
82344: LD_ADDR_VAR 0 6
82348: PUSH
82349: LD_EXP 58
82353: PUSH
82354: LD_VAR 0 3
82358: ARRAY
82359: PPUSH
82360: LD_INT 2
82362: PUSH
82363: LD_INT 30
82365: PUSH
82366: LD_INT 4
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 30
82375: PUSH
82376: LD_INT 5
82378: PUSH
82379: EMPTY
82380: LIST
82381: LIST
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: LIST
82387: PPUSH
82388: CALL_OW 72
82392: ST_TO_ADDR
// if not tmp then
82393: LD_VAR 0 6
82397: NOT
82398: IFFALSE 82404
// exit ;
82400: POP
82401: POP
82402: GO 82484
// for j in tmp do
82404: LD_ADDR_VAR 0 4
82408: PUSH
82409: LD_VAR 0 6
82413: PUSH
82414: FOR_IN
82415: IFFALSE 82474
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
82417: LD_ADDR_VAR 0 7
82421: PUSH
82422: LD_VAR 0 4
82426: PPUSH
82427: CALL_OW 313
82431: PPUSH
82432: LD_INT 25
82434: PUSH
82435: LD_INT 1
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PPUSH
82442: CALL_OW 72
82446: ST_TO_ADDR
// if units then
82447: LD_VAR 0 7
82451: IFFALSE 82472
// begin ComExitBuilding ( units [ 1 ] ) ;
82453: LD_VAR 0 7
82457: PUSH
82458: LD_INT 1
82460: ARRAY
82461: PPUSH
82462: CALL_OW 122
// exit ;
82466: POP
82467: POP
82468: POP
82469: POP
82470: GO 82484
// end ; end ;
82472: GO 82414
82474: POP
82475: POP
// end ; end ; exit ;
82476: POP
82477: POP
82478: GO 82484
// end ; end ;
82480: GO 81838
82482: POP
82483: POP
// end ;
82484: LD_VAR 0 2
82488: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
82489: LD_INT 0
82491: PPUSH
82492: PPUSH
82493: PPUSH
82494: PPUSH
82495: PPUSH
82496: PPUSH
82497: PPUSH
// if not mc_bases then
82498: LD_EXP 58
82502: NOT
82503: IFFALSE 82507
// exit ;
82505: GO 82738
// btype := GetBType ( building ) ;
82507: LD_ADDR_VAR 0 6
82511: PUSH
82512: LD_VAR 0 1
82516: PPUSH
82517: CALL_OW 266
82521: ST_TO_ADDR
// x := GetX ( building ) ;
82522: LD_ADDR_VAR 0 7
82526: PUSH
82527: LD_VAR 0 1
82531: PPUSH
82532: CALL_OW 250
82536: ST_TO_ADDR
// y := GetY ( building ) ;
82537: LD_ADDR_VAR 0 8
82541: PUSH
82542: LD_VAR 0 1
82546: PPUSH
82547: CALL_OW 251
82551: ST_TO_ADDR
// d := GetDir ( building ) ;
82552: LD_ADDR_VAR 0 9
82556: PUSH
82557: LD_VAR 0 1
82561: PPUSH
82562: CALL_OW 254
82566: ST_TO_ADDR
// for i = 1 to mc_bases do
82567: LD_ADDR_VAR 0 4
82571: PUSH
82572: DOUBLE
82573: LD_INT 1
82575: DEC
82576: ST_TO_ADDR
82577: LD_EXP 58
82581: PUSH
82582: FOR_TO
82583: IFFALSE 82736
// begin if not mc_build_list [ i ] then
82585: LD_EXP 63
82589: PUSH
82590: LD_VAR 0 4
82594: ARRAY
82595: NOT
82596: IFFALSE 82600
// continue ;
82598: GO 82582
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
82600: LD_VAR 0 6
82604: PUSH
82605: LD_VAR 0 7
82609: PUSH
82610: LD_VAR 0 8
82614: PUSH
82615: LD_VAR 0 9
82619: PUSH
82620: EMPTY
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: PPUSH
82626: LD_EXP 63
82630: PUSH
82631: LD_VAR 0 4
82635: ARRAY
82636: PUSH
82637: LD_INT 1
82639: ARRAY
82640: PPUSH
82641: CALL 26362 0 2
82645: IFFALSE 82734
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
82647: LD_ADDR_EXP 63
82651: PUSH
82652: LD_EXP 63
82656: PPUSH
82657: LD_VAR 0 4
82661: PPUSH
82662: LD_EXP 63
82666: PUSH
82667: LD_VAR 0 4
82671: ARRAY
82672: PPUSH
82673: LD_INT 1
82675: PPUSH
82676: CALL_OW 3
82680: PPUSH
82681: CALL_OW 1
82685: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
82686: LD_ADDR_EXP 65
82690: PUSH
82691: LD_EXP 65
82695: PPUSH
82696: LD_VAR 0 4
82700: PUSH
82701: LD_EXP 65
82705: PUSH
82706: LD_VAR 0 4
82710: ARRAY
82711: PUSH
82712: LD_INT 1
82714: PLUS
82715: PUSH
82716: EMPTY
82717: LIST
82718: LIST
82719: PPUSH
82720: LD_VAR 0 1
82724: PPUSH
82725: CALL 20697 0 3
82729: ST_TO_ADDR
// exit ;
82730: POP
82731: POP
82732: GO 82738
// end ; end ;
82734: GO 82582
82736: POP
82737: POP
// end ;
82738: LD_VAR 0 3
82742: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
82743: LD_INT 0
82745: PPUSH
82746: PPUSH
82747: PPUSH
// if not mc_bases then
82748: LD_EXP 58
82752: NOT
82753: IFFALSE 82757
// exit ;
82755: GO 82947
// for i = 1 to mc_bases do
82757: LD_ADDR_VAR 0 4
82761: PUSH
82762: DOUBLE
82763: LD_INT 1
82765: DEC
82766: ST_TO_ADDR
82767: LD_EXP 58
82771: PUSH
82772: FOR_TO
82773: IFFALSE 82860
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
82775: LD_VAR 0 1
82779: PUSH
82780: LD_EXP 66
82784: PUSH
82785: LD_VAR 0 4
82789: ARRAY
82790: IN
82791: PUSH
82792: LD_VAR 0 1
82796: PUSH
82797: LD_EXP 67
82801: PUSH
82802: LD_VAR 0 4
82806: ARRAY
82807: IN
82808: NOT
82809: AND
82810: IFFALSE 82858
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
82812: LD_ADDR_EXP 67
82816: PUSH
82817: LD_EXP 67
82821: PPUSH
82822: LD_VAR 0 4
82826: PUSH
82827: LD_EXP 67
82831: PUSH
82832: LD_VAR 0 4
82836: ARRAY
82837: PUSH
82838: LD_INT 1
82840: PLUS
82841: PUSH
82842: EMPTY
82843: LIST
82844: LIST
82845: PPUSH
82846: LD_VAR 0 1
82850: PPUSH
82851: CALL 20697 0 3
82855: ST_TO_ADDR
// break ;
82856: GO 82860
// end ; end ;
82858: GO 82772
82860: POP
82861: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82862: LD_VAR 0 1
82866: PPUSH
82867: CALL_OW 257
82871: PUSH
82872: LD_EXP 84
82876: IN
82877: PUSH
82878: LD_VAR 0 1
82882: PPUSH
82883: CALL_OW 266
82887: PUSH
82888: LD_INT 5
82890: EQUAL
82891: AND
82892: PUSH
82893: LD_VAR 0 2
82897: PPUSH
82898: CALL_OW 110
82902: PUSH
82903: LD_INT 18
82905: NONEQUAL
82906: AND
82907: IFFALSE 82947
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82909: LD_VAR 0 2
82913: PPUSH
82914: CALL_OW 257
82918: PUSH
82919: LD_INT 5
82921: PUSH
82922: LD_INT 8
82924: PUSH
82925: LD_INT 9
82927: PUSH
82928: EMPTY
82929: LIST
82930: LIST
82931: LIST
82932: IN
82933: IFFALSE 82947
// SetClass ( unit , 1 ) ;
82935: LD_VAR 0 2
82939: PPUSH
82940: LD_INT 1
82942: PPUSH
82943: CALL_OW 336
// end ;
82947: LD_VAR 0 3
82951: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82952: LD_INT 0
82954: PPUSH
82955: PPUSH
// if not mc_bases then
82956: LD_EXP 58
82960: NOT
82961: IFFALSE 82965
// exit ;
82963: GO 83081
// if GetLives ( abandoned_vehicle ) > 250 then
82965: LD_VAR 0 2
82969: PPUSH
82970: CALL_OW 256
82974: PUSH
82975: LD_INT 250
82977: GREATER
82978: IFFALSE 82982
// exit ;
82980: GO 83081
// for i = 1 to mc_bases do
82982: LD_ADDR_VAR 0 6
82986: PUSH
82987: DOUBLE
82988: LD_INT 1
82990: DEC
82991: ST_TO_ADDR
82992: LD_EXP 58
82996: PUSH
82997: FOR_TO
82998: IFFALSE 83079
// begin if driver in mc_bases [ i ] then
83000: LD_VAR 0 1
83004: PUSH
83005: LD_EXP 58
83009: PUSH
83010: LD_VAR 0 6
83014: ARRAY
83015: IN
83016: IFFALSE 83077
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
83018: LD_VAR 0 1
83022: PPUSH
83023: LD_EXP 58
83027: PUSH
83028: LD_VAR 0 6
83032: ARRAY
83033: PPUSH
83034: LD_INT 2
83036: PUSH
83037: LD_INT 30
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 30
83049: PUSH
83050: LD_INT 1
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: LIST
83061: PPUSH
83062: CALL_OW 72
83066: PUSH
83067: LD_INT 1
83069: ARRAY
83070: PPUSH
83071: CALL_OW 112
// break ;
83075: GO 83079
// end ; end ;
83077: GO 82997
83079: POP
83080: POP
// end ; end_of_file
83081: LD_VAR 0 5
83085: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
83086: GO 83088
83088: DISABLE
// begin ru_radar := 98 ;
83089: LD_ADDR_EXP 101
83093: PUSH
83094: LD_INT 98
83096: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
83097: LD_ADDR_EXP 102
83101: PUSH
83102: LD_INT 89
83104: ST_TO_ADDR
// us_hack := 99 ;
83105: LD_ADDR_EXP 103
83109: PUSH
83110: LD_INT 99
83112: ST_TO_ADDR
// us_artillery := 97 ;
83113: LD_ADDR_EXP 104
83117: PUSH
83118: LD_INT 97
83120: ST_TO_ADDR
// ar_bio_bomb := 91 ;
83121: LD_ADDR_EXP 105
83125: PUSH
83126: LD_INT 91
83128: ST_TO_ADDR
// end ;
83129: END
