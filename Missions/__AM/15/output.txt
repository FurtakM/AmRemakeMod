// starting begin end ;
   0: END
// export function CustomInitMacro ( ) ; begin
   1: LD_INT 0
   3: PPUSH
// end ; end_of_file end_of_file end_of_file end_of_file end_of_file
   4: LD_VAR 0 1
   8: RET
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Karamazov , Kapitsova , Scholtze , Oblukov , Titov ; export function PrepareAlliance ; begin
   9: LD_INT 0
  11: PPUSH
// uc_side := 7 ;
  12: LD_ADDR_OWVAR 20
  16: PUSH
  17: LD_INT 7
  19: ST_TO_ADDR
// uc_nation := 1 ;
  20: LD_ADDR_OWVAR 21
  24: PUSH
  25: LD_INT 1
  27: ST_TO_ADDR
// Roth := NewCharacter ( Roth ) ;
  28: LD_ADDR_EXP 1
  32: PUSH
  33: LD_STRING Roth
  35: PPUSH
  36: CALL_OW 25
  40: ST_TO_ADDR
// uc_nation := 3 ;
  41: LD_ADDR_OWVAR 21
  45: PUSH
  46: LD_INT 3
  48: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
  49: LD_ADDR_EXP 3
  53: PUSH
  54: LD_STRING Kirilenkova
  56: PPUSH
  57: CALL_OW 25
  61: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
  62: LD_ADDR_EXP 13
  66: PUSH
  67: LD_STRING Titov
  69: PPUSH
  70: CALL_OW 25
  74: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
  75: LD_ADDR_EXP 12
  79: PUSH
  80: LD_STRING Oblukov
  82: PPUSH
  83: CALL_OW 25
  87: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
  88: LD_ADDR_EXP 4
  92: PUSH
  93: LD_STRING Dolgov
  95: PPUSH
  96: CALL_OW 25
 100: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
 101: LD_ADDR_EXP 5
 105: PUSH
 106: LD_STRING Petrosyan
 108: PPUSH
 109: CALL_OW 25
 113: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
 114: LD_ADDR_EXP 11
 118: PUSH
 119: LD_STRING Scholtze
 121: PPUSH
 122: CALL_OW 25
 126: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
 127: LD_ADDR_EXP 10
 131: PUSH
 132: LD_STRING Kapitsova
 134: PPUSH
 135: CALL_OW 25
 139: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
 140: LD_ADDR_EXP 6
 144: PUSH
 145: LD_STRING Petrovova
 147: PPUSH
 148: CALL_OW 25
 152: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
 153: LD_ADDR_EXP 7
 157: PUSH
 158: LD_STRING Kuzmov
 160: PPUSH
 161: CALL_OW 25
 165: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
 166: LD_ADDR_EXP 8
 170: PUSH
 171: LD_STRING Lipshchin
 173: PPUSH
 174: CALL_OW 25
 178: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
 179: LD_ADDR_EXP 9
 183: PUSH
 184: LD_STRING Karamazov
 186: PPUSH
 187: CALL_OW 25
 191: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
 192: LD_VAR 0 1
 196: RET
// on UnitDestroyed ( un ) do begin MCE_UnitDestroyed ( un ) ;
 197: LD_VAR 0 1
 201: PPUSH
 202: CALL 25536 0 1
// end ;
 206: PPOPN 1
 208: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
 209: LD_VAR 0 1
 213: PPUSH
 214: LD_VAR 0 2
 218: PPUSH
 219: CALL 27421 0 2
// end ;
 223: PPOPN 2
 225: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
 226: LD_VAR 0 1
 230: PPUSH
 231: CALL 26503 0 1
// end ;
 235: PPOPN 1
 237: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
 238: LD_VAR 0 1
 242: PPUSH
 243: CALL 26737 0 1
// end ;
 247: PPOPN 1
 249: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
 250: LD_VAR 0 1
 254: PPUSH
 255: LD_VAR 0 2
 259: PPUSH
 260: CALL 25248 0 2
// end ;
 264: PPOPN 2
 266: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
 267: LD_VAR 0 1
 271: PPUSH
 272: LD_VAR 0 2
 276: PPUSH
 277: LD_VAR 0 3
 281: PPUSH
 282: LD_VAR 0 4
 286: PPUSH
 287: LD_VAR 0 5
 291: PPUSH
 292: CALL 24875 0 5
// end ;
 296: PPOPN 5
 298: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
 299: LD_VAR 0 1
 303: PPUSH
 304: LD_VAR 0 2
 308: PPUSH
 309: CALL 24472 0 2
// end ;
 313: PPOPN 2
 315: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
 316: LD_VAR 0 1
 320: PPUSH
 321: LD_VAR 0 2
 325: PPUSH
 326: LD_VAR 0 3
 330: PPUSH
 331: LD_VAR 0 4
 335: PPUSH
 336: CALL 24317 0 4
// end ;
 340: PPOPN 4
 342: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
 343: LD_VAR 0 1
 347: PPUSH
 348: LD_VAR 0 2
 352: PPUSH
 353: LD_VAR 0 3
 357: PPUSH
 358: CALL 24099 0 3
// end ;
 362: PPOPN 3
 364: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
 365: LD_VAR 0 1
 369: PPUSH
 370: LD_VAR 0 2
 374: PPUSH
 375: CALL 23991 0 2
// end ;
 379: PPOPN 2
 381: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
 382: LD_VAR 0 1
 386: PPUSH
 387: LD_VAR 0 2
 391: PPUSH
 392: CALL 27675 0 2
// end ;
 396: PPOPN 2
 398: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
 399: LD_VAR 0 1
 403: PPUSH
 404: LD_VAR 0 2
 408: PPUSH
 409: LD_VAR 0 3
 413: PPUSH
 414: LD_VAR 0 4
 418: PPUSH
 419: CALL 27884 0 4
// end ;
 423: PPOPN 4
 425: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
 426: LD_VAR 0 1
 430: PPUSH
 431: LD_VAR 0 2
 435: PPUSH
 436: CALL 23807 0 2
// end ; end_of_file
 440: PPOPN 2
 442: END
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
 443: GO 445
 445: DISABLE
// begin ru_radar := 98 ;
 446: LD_ADDR_EXP 14
 450: PUSH
 451: LD_INT 98
 453: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
 454: LD_ADDR_EXP 15
 458: PUSH
 459: LD_INT 89
 461: ST_TO_ADDR
// us_hack := 99 ;
 462: LD_ADDR_EXP 16
 466: PUSH
 467: LD_INT 99
 469: ST_TO_ADDR
// us_artillery := 97 ;
 470: LD_ADDR_EXP 17
 474: PUSH
 475: LD_INT 97
 477: ST_TO_ADDR
// ar_bio_bomb := 91 ;
 478: LD_ADDR_EXP 18
 482: PUSH
 483: LD_INT 91
 485: ST_TO_ADDR
// end ; end_of_file
 486: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
 487: LD_INT 0
 489: PPUSH
 490: PPUSH
// skirmish := false ;
 491: LD_ADDR_EXP 19
 495: PUSH
 496: LD_INT 0
 498: ST_TO_ADDR
// debug_mc := false ;
 499: LD_ADDR_EXP 20
 503: PUSH
 504: LD_INT 0
 506: ST_TO_ADDR
// mc_bases := [ ] ;
 507: LD_ADDR_EXP 21
 511: PUSH
 512: EMPTY
 513: ST_TO_ADDR
// mc_sides := [ ] ;
 514: LD_ADDR_EXP 47
 518: PUSH
 519: EMPTY
 520: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
 521: LD_ADDR_EXP 22
 525: PUSH
 526: EMPTY
 527: ST_TO_ADDR
// mc_building_repairs := [ ] ;
 528: LD_ADDR_EXP 23
 532: PUSH
 533: EMPTY
 534: ST_TO_ADDR
// mc_need_heal := [ ] ;
 535: LD_ADDR_EXP 24
 539: PUSH
 540: EMPTY
 541: ST_TO_ADDR
// mc_healers := [ ] ;
 542: LD_ADDR_EXP 25
 546: PUSH
 547: EMPTY
 548: ST_TO_ADDR
// mc_build_list := [ ] ;
 549: LD_ADDR_EXP 26
 553: PUSH
 554: EMPTY
 555: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
 556: LD_ADDR_EXP 53
 560: PUSH
 561: EMPTY
 562: ST_TO_ADDR
// mc_builders := [ ] ;
 563: LD_ADDR_EXP 27
 567: PUSH
 568: EMPTY
 569: ST_TO_ADDR
// mc_construct_list := [ ] ;
 570: LD_ADDR_EXP 28
 574: PUSH
 575: EMPTY
 576: ST_TO_ADDR
// mc_turret_list := [ ] ;
 577: LD_ADDR_EXP 29
 581: PUSH
 582: EMPTY
 583: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
 584: LD_ADDR_EXP 30
 588: PUSH
 589: EMPTY
 590: ST_TO_ADDR
// mc_miners := [ ] ;
 591: LD_ADDR_EXP 35
 595: PUSH
 596: EMPTY
 597: ST_TO_ADDR
// mc_mines := [ ] ;
 598: LD_ADDR_EXP 34
 602: PUSH
 603: EMPTY
 604: ST_TO_ADDR
// mc_minefields := [ ] ;
 605: LD_ADDR_EXP 36
 609: PUSH
 610: EMPTY
 611: ST_TO_ADDR
// mc_crates := [ ] ;
 612: LD_ADDR_EXP 37
 616: PUSH
 617: EMPTY
 618: ST_TO_ADDR
// mc_crates_collector := [ ] ;
 619: LD_ADDR_EXP 38
 623: PUSH
 624: EMPTY
 625: ST_TO_ADDR
// mc_crates_area := [ ] ;
 626: LD_ADDR_EXP 39
 630: PUSH
 631: EMPTY
 632: ST_TO_ADDR
// mc_vehicles := [ ] ;
 633: LD_ADDR_EXP 40
 637: PUSH
 638: EMPTY
 639: ST_TO_ADDR
// mc_attack := [ ] ;
 640: LD_ADDR_EXP 41
 644: PUSH
 645: EMPTY
 646: ST_TO_ADDR
// mc_produce := [ ] ;
 647: LD_ADDR_EXP 42
 651: PUSH
 652: EMPTY
 653: ST_TO_ADDR
// mc_defender := [ ] ;
 654: LD_ADDR_EXP 43
 658: PUSH
 659: EMPTY
 660: ST_TO_ADDR
// mc_parking := [ ] ;
 661: LD_ADDR_EXP 45
 665: PUSH
 666: EMPTY
 667: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
 668: LD_ADDR_EXP 31
 672: PUSH
 673: EMPTY
 674: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
 675: LD_ADDR_EXP 33
 679: PUSH
 680: EMPTY
 681: ST_TO_ADDR
// mc_scan := [ ] ;
 682: LD_ADDR_EXP 44
 686: PUSH
 687: EMPTY
 688: ST_TO_ADDR
// mc_scan_area := [ ] ;
 689: LD_ADDR_EXP 46
 693: PUSH
 694: EMPTY
 695: ST_TO_ADDR
// mc_tech := [ ] ;
 696: LD_ADDR_EXP 48
 700: PUSH
 701: EMPTY
 702: ST_TO_ADDR
// mc_class := [ ] ;
 703: LD_ADDR_EXP 62
 707: PUSH
 708: EMPTY
 709: ST_TO_ADDR
// mc_class_case_use := [ ] ;
 710: LD_ADDR_EXP 63
 714: PUSH
 715: EMPTY
 716: ST_TO_ADDR
// end ;
 717: LD_VAR 0 1
 721: RET
// export function MC_Kill ( base ) ; begin
 722: LD_INT 0
 724: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
 725: LD_ADDR_EXP 21
 729: PUSH
 730: LD_EXP 21
 734: PPUSH
 735: LD_VAR 0 1
 739: PPUSH
 740: EMPTY
 741: PPUSH
 742: CALL_OW 1
 746: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
 747: LD_ADDR_EXP 22
 751: PUSH
 752: LD_EXP 22
 756: PPUSH
 757: LD_VAR 0 1
 761: PPUSH
 762: EMPTY
 763: PPUSH
 764: CALL_OW 1
 768: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
 769: LD_ADDR_EXP 23
 773: PUSH
 774: LD_EXP 23
 778: PPUSH
 779: LD_VAR 0 1
 783: PPUSH
 784: EMPTY
 785: PPUSH
 786: CALL_OW 1
 790: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
 791: LD_ADDR_EXP 24
 795: PUSH
 796: LD_EXP 24
 800: PPUSH
 801: LD_VAR 0 1
 805: PPUSH
 806: EMPTY
 807: PPUSH
 808: CALL_OW 1
 812: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
 813: LD_ADDR_EXP 25
 817: PUSH
 818: LD_EXP 25
 822: PPUSH
 823: LD_VAR 0 1
 827: PPUSH
 828: EMPTY
 829: PPUSH
 830: CALL_OW 1
 834: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
 835: LD_ADDR_EXP 26
 839: PUSH
 840: LD_EXP 26
 844: PPUSH
 845: LD_VAR 0 1
 849: PPUSH
 850: EMPTY
 851: PPUSH
 852: CALL_OW 1
 856: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
 857: LD_ADDR_EXP 27
 861: PUSH
 862: LD_EXP 27
 866: PPUSH
 867: LD_VAR 0 1
 871: PPUSH
 872: EMPTY
 873: PPUSH
 874: CALL_OW 1
 878: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
 879: LD_ADDR_EXP 28
 883: PUSH
 884: LD_EXP 28
 888: PPUSH
 889: LD_VAR 0 1
 893: PPUSH
 894: EMPTY
 895: PPUSH
 896: CALL_OW 1
 900: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
 901: LD_ADDR_EXP 29
 905: PUSH
 906: LD_EXP 29
 910: PPUSH
 911: LD_VAR 0 1
 915: PPUSH
 916: EMPTY
 917: PPUSH
 918: CALL_OW 1
 922: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
 923: LD_ADDR_EXP 30
 927: PUSH
 928: LD_EXP 30
 932: PPUSH
 933: LD_VAR 0 1
 937: PPUSH
 938: EMPTY
 939: PPUSH
 940: CALL_OW 1
 944: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
 945: LD_ADDR_EXP 31
 949: PUSH
 950: LD_EXP 31
 954: PPUSH
 955: LD_VAR 0 1
 959: PPUSH
 960: EMPTY
 961: PPUSH
 962: CALL_OW 1
 966: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
 967: LD_ADDR_EXP 32
 971: PUSH
 972: LD_EXP 32
 976: PPUSH
 977: LD_VAR 0 1
 981: PPUSH
 982: LD_INT 0
 984: PPUSH
 985: CALL_OW 1
 989: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
 990: LD_ADDR_EXP 33
 994: PUSH
 995: LD_EXP 33
 999: PPUSH
1000: LD_VAR 0 1
1004: PPUSH
1005: EMPTY
1006: PPUSH
1007: CALL_OW 1
1011: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
1012: LD_ADDR_EXP 34
1016: PUSH
1017: LD_EXP 34
1021: PPUSH
1022: LD_VAR 0 1
1026: PPUSH
1027: EMPTY
1028: PPUSH
1029: CALL_OW 1
1033: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
1034: LD_ADDR_EXP 35
1038: PUSH
1039: LD_EXP 35
1043: PPUSH
1044: LD_VAR 0 1
1048: PPUSH
1049: EMPTY
1050: PPUSH
1051: CALL_OW 1
1055: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
1056: LD_ADDR_EXP 36
1060: PUSH
1061: LD_EXP 36
1065: PPUSH
1066: LD_VAR 0 1
1070: PPUSH
1071: EMPTY
1072: PPUSH
1073: CALL_OW 1
1077: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
1078: LD_ADDR_EXP 37
1082: PUSH
1083: LD_EXP 37
1087: PPUSH
1088: LD_VAR 0 1
1092: PPUSH
1093: EMPTY
1094: PPUSH
1095: CALL_OW 1
1099: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
1100: LD_ADDR_EXP 38
1104: PUSH
1105: LD_EXP 38
1109: PPUSH
1110: LD_VAR 0 1
1114: PPUSH
1115: EMPTY
1116: PPUSH
1117: CALL_OW 1
1121: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
1122: LD_ADDR_EXP 39
1126: PUSH
1127: LD_EXP 39
1131: PPUSH
1132: LD_VAR 0 1
1136: PPUSH
1137: EMPTY
1138: PPUSH
1139: CALL_OW 1
1143: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
1144: LD_ADDR_EXP 40
1148: PUSH
1149: LD_EXP 40
1153: PPUSH
1154: LD_VAR 0 1
1158: PPUSH
1159: EMPTY
1160: PPUSH
1161: CALL_OW 1
1165: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
1166: LD_ADDR_EXP 41
1170: PUSH
1171: LD_EXP 41
1175: PPUSH
1176: LD_VAR 0 1
1180: PPUSH
1181: EMPTY
1182: PPUSH
1183: CALL_OW 1
1187: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
1188: LD_ADDR_EXP 42
1192: PUSH
1193: LD_EXP 42
1197: PPUSH
1198: LD_VAR 0 1
1202: PPUSH
1203: EMPTY
1204: PPUSH
1205: CALL_OW 1
1209: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
1210: LD_ADDR_EXP 43
1214: PUSH
1215: LD_EXP 43
1219: PPUSH
1220: LD_VAR 0 1
1224: PPUSH
1225: EMPTY
1226: PPUSH
1227: CALL_OW 1
1231: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
1232: LD_ADDR_EXP 44
1236: PUSH
1237: LD_EXP 44
1241: PPUSH
1242: LD_VAR 0 1
1246: PPUSH
1247: EMPTY
1248: PPUSH
1249: CALL_OW 1
1253: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
1254: LD_ADDR_EXP 45
1258: PUSH
1259: LD_EXP 45
1263: PPUSH
1264: LD_VAR 0 1
1268: PPUSH
1269: EMPTY
1270: PPUSH
1271: CALL_OW 1
1275: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
1276: LD_ADDR_EXP 46
1280: PUSH
1281: LD_EXP 46
1285: PPUSH
1286: LD_VAR 0 1
1290: PPUSH
1291: EMPTY
1292: PPUSH
1293: CALL_OW 1
1297: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
1298: LD_ADDR_EXP 48
1302: PUSH
1303: LD_EXP 48
1307: PPUSH
1308: LD_VAR 0 1
1312: PPUSH
1313: EMPTY
1314: PPUSH
1315: CALL_OW 1
1319: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
1320: LD_ADDR_EXP 50
1324: PUSH
1325: LD_EXP 50
1329: PPUSH
1330: LD_VAR 0 1
1334: PPUSH
1335: EMPTY
1336: PPUSH
1337: CALL_OW 1
1341: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
1342: LD_ADDR_EXP 51
1346: PUSH
1347: LD_EXP 51
1351: PPUSH
1352: LD_VAR 0 1
1356: PPUSH
1357: EMPTY
1358: PPUSH
1359: CALL_OW 1
1363: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
1364: LD_ADDR_EXP 52
1368: PUSH
1369: LD_EXP 52
1373: PPUSH
1374: LD_VAR 0 1
1378: PPUSH
1379: EMPTY
1380: PPUSH
1381: CALL_OW 1
1385: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
1386: LD_ADDR_EXP 53
1390: PUSH
1391: LD_EXP 53
1395: PPUSH
1396: LD_VAR 0 1
1400: PPUSH
1401: EMPTY
1402: PPUSH
1403: CALL_OW 1
1407: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
1408: LD_ADDR_EXP 54
1412: PUSH
1413: LD_EXP 54
1417: PPUSH
1418: LD_VAR 0 1
1422: PPUSH
1423: EMPTY
1424: PPUSH
1425: CALL_OW 1
1429: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
1430: LD_ADDR_EXP 55
1434: PUSH
1435: LD_EXP 55
1439: PPUSH
1440: LD_VAR 0 1
1444: PPUSH
1445: EMPTY
1446: PPUSH
1447: CALL_OW 1
1451: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
1452: LD_ADDR_EXP 56
1456: PUSH
1457: LD_EXP 56
1461: PPUSH
1462: LD_VAR 0 1
1466: PPUSH
1467: EMPTY
1468: PPUSH
1469: CALL_OW 1
1473: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
1474: LD_ADDR_EXP 57
1478: PUSH
1479: LD_EXP 57
1483: PPUSH
1484: LD_VAR 0 1
1488: PPUSH
1489: EMPTY
1490: PPUSH
1491: CALL_OW 1
1495: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
1496: LD_ADDR_EXP 58
1500: PUSH
1501: LD_EXP 58
1505: PPUSH
1506: LD_VAR 0 1
1510: PPUSH
1511: EMPTY
1512: PPUSH
1513: CALL_OW 1
1517: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
1518: LD_ADDR_EXP 59
1522: PUSH
1523: LD_EXP 59
1527: PPUSH
1528: LD_VAR 0 1
1532: PPUSH
1533: EMPTY
1534: PPUSH
1535: CALL_OW 1
1539: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
1540: LD_ADDR_EXP 60
1544: PUSH
1545: LD_EXP 60
1549: PPUSH
1550: LD_VAR 0 1
1554: PPUSH
1555: EMPTY
1556: PPUSH
1557: CALL_OW 1
1561: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
1562: LD_ADDR_EXP 61
1566: PUSH
1567: LD_EXP 61
1571: PPUSH
1572: LD_VAR 0 1
1576: PPUSH
1577: EMPTY
1578: PPUSH
1579: CALL_OW 1
1583: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
1584: LD_ADDR_EXP 62
1588: PUSH
1589: LD_EXP 62
1593: PPUSH
1594: LD_VAR 0 1
1598: PPUSH
1599: EMPTY
1600: PPUSH
1601: CALL_OW 1
1605: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
1606: LD_ADDR_EXP 63
1610: PUSH
1611: LD_EXP 63
1615: PPUSH
1616: LD_VAR 0 1
1620: PPUSH
1621: LD_INT 0
1623: PPUSH
1624: CALL_OW 1
1628: ST_TO_ADDR
// end ;
1629: LD_VAR 0 2
1633: RET
// export function MC_Start ( ) ; var i ; begin
1634: LD_INT 0
1636: PPUSH
1637: PPUSH
// for i = 1 to mc_bases do
1638: LD_ADDR_VAR 0 2
1642: PUSH
1643: DOUBLE
1644: LD_INT 1
1646: DEC
1647: ST_TO_ADDR
1648: LD_EXP 21
1652: PUSH
1653: FOR_TO
1654: IFFALSE 2731
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
1656: LD_ADDR_EXP 21
1660: PUSH
1661: LD_EXP 21
1665: PPUSH
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_EXP 21
1675: PUSH
1676: LD_VAR 0 2
1680: ARRAY
1681: PUSH
1682: LD_INT 0
1684: DIFF
1685: PPUSH
1686: CALL_OW 1
1690: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
1691: LD_ADDR_EXP 22
1695: PUSH
1696: LD_EXP 22
1700: PPUSH
1701: LD_VAR 0 2
1705: PPUSH
1706: EMPTY
1707: PPUSH
1708: CALL_OW 1
1712: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
1713: LD_ADDR_EXP 23
1717: PUSH
1718: LD_EXP 23
1722: PPUSH
1723: LD_VAR 0 2
1727: PPUSH
1728: EMPTY
1729: PPUSH
1730: CALL_OW 1
1734: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
1735: LD_ADDR_EXP 24
1739: PUSH
1740: LD_EXP 24
1744: PPUSH
1745: LD_VAR 0 2
1749: PPUSH
1750: EMPTY
1751: PPUSH
1752: CALL_OW 1
1756: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
1757: LD_ADDR_EXP 25
1761: PUSH
1762: LD_EXP 25
1766: PPUSH
1767: LD_VAR 0 2
1771: PPUSH
1772: EMPTY
1773: PUSH
1774: EMPTY
1775: PUSH
1776: EMPTY
1777: LIST
1778: LIST
1779: PPUSH
1780: CALL_OW 1
1784: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
1785: LD_ADDR_EXP 26
1789: PUSH
1790: LD_EXP 26
1794: PPUSH
1795: LD_VAR 0 2
1799: PPUSH
1800: EMPTY
1801: PPUSH
1802: CALL_OW 1
1806: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
1807: LD_ADDR_EXP 53
1811: PUSH
1812: LD_EXP 53
1816: PPUSH
1817: LD_VAR 0 2
1821: PPUSH
1822: EMPTY
1823: PPUSH
1824: CALL_OW 1
1828: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
1829: LD_ADDR_EXP 27
1833: PUSH
1834: LD_EXP 27
1838: PPUSH
1839: LD_VAR 0 2
1843: PPUSH
1844: EMPTY
1845: PPUSH
1846: CALL_OW 1
1850: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
1851: LD_ADDR_EXP 28
1855: PUSH
1856: LD_EXP 28
1860: PPUSH
1861: LD_VAR 0 2
1865: PPUSH
1866: EMPTY
1867: PPUSH
1868: CALL_OW 1
1872: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
1873: LD_ADDR_EXP 29
1877: PUSH
1878: LD_EXP 29
1882: PPUSH
1883: LD_VAR 0 2
1887: PPUSH
1888: LD_EXP 21
1892: PUSH
1893: LD_VAR 0 2
1897: ARRAY
1898: PPUSH
1899: LD_INT 2
1901: PUSH
1902: LD_INT 30
1904: PUSH
1905: LD_INT 32
1907: PUSH
1908: EMPTY
1909: LIST
1910: LIST
1911: PUSH
1912: LD_INT 30
1914: PUSH
1915: LD_INT 33
1917: PUSH
1918: EMPTY
1919: LIST
1920: LIST
1921: PUSH
1922: EMPTY
1923: LIST
1924: LIST
1925: LIST
1926: PPUSH
1927: CALL_OW 72
1931: PPUSH
1932: CALL_OW 1
1936: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
1937: LD_ADDR_EXP 30
1941: PUSH
1942: LD_EXP 30
1946: PPUSH
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_EXP 21
1956: PUSH
1957: LD_VAR 0 2
1961: ARRAY
1962: PPUSH
1963: LD_INT 2
1965: PUSH
1966: LD_INT 30
1968: PUSH
1969: LD_INT 32
1971: PUSH
1972: EMPTY
1973: LIST
1974: LIST
1975: PUSH
1976: LD_INT 30
1978: PUSH
1979: LD_INT 31
1981: PUSH
1982: EMPTY
1983: LIST
1984: LIST
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 58
1993: PUSH
1994: EMPTY
1995: LIST
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: PPUSH
2001: CALL_OW 72
2005: PPUSH
2006: CALL_OW 1
2010: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
2011: LD_ADDR_EXP 31
2015: PUSH
2016: LD_EXP 31
2020: PPUSH
2021: LD_VAR 0 2
2025: PPUSH
2026: EMPTY
2027: PPUSH
2028: CALL_OW 1
2032: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
2033: LD_ADDR_EXP 35
2037: PUSH
2038: LD_EXP 35
2042: PPUSH
2043: LD_VAR 0 2
2047: PPUSH
2048: EMPTY
2049: PPUSH
2050: CALL_OW 1
2054: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
2055: LD_ADDR_EXP 34
2059: PUSH
2060: LD_EXP 34
2064: PPUSH
2065: LD_VAR 0 2
2069: PPUSH
2070: EMPTY
2071: PPUSH
2072: CALL_OW 1
2076: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
2077: LD_ADDR_EXP 36
2081: PUSH
2082: LD_EXP 36
2086: PPUSH
2087: LD_VAR 0 2
2091: PPUSH
2092: EMPTY
2093: PPUSH
2094: CALL_OW 1
2098: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
2099: LD_ADDR_EXP 37
2103: PUSH
2104: LD_EXP 37
2108: PPUSH
2109: LD_VAR 0 2
2113: PPUSH
2114: EMPTY
2115: PPUSH
2116: CALL_OW 1
2120: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
2121: LD_ADDR_EXP 38
2125: PUSH
2126: LD_EXP 38
2130: PPUSH
2131: LD_VAR 0 2
2135: PPUSH
2136: EMPTY
2137: PPUSH
2138: CALL_OW 1
2142: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
2143: LD_ADDR_EXP 39
2147: PUSH
2148: LD_EXP 39
2152: PPUSH
2153: LD_VAR 0 2
2157: PPUSH
2158: EMPTY
2159: PPUSH
2160: CALL_OW 1
2164: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
2165: LD_ADDR_EXP 40
2169: PUSH
2170: LD_EXP 40
2174: PPUSH
2175: LD_VAR 0 2
2179: PPUSH
2180: EMPTY
2181: PPUSH
2182: CALL_OW 1
2186: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
2187: LD_ADDR_EXP 41
2191: PUSH
2192: LD_EXP 41
2196: PPUSH
2197: LD_VAR 0 2
2201: PPUSH
2202: EMPTY
2203: PPUSH
2204: CALL_OW 1
2208: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
2209: LD_ADDR_EXP 42
2213: PUSH
2214: LD_EXP 42
2218: PPUSH
2219: LD_VAR 0 2
2223: PPUSH
2224: EMPTY
2225: PPUSH
2226: CALL_OW 1
2230: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
2231: LD_ADDR_EXP 43
2235: PUSH
2236: LD_EXP 43
2240: PPUSH
2241: LD_VAR 0 2
2245: PPUSH
2246: EMPTY
2247: PPUSH
2248: CALL_OW 1
2252: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
2253: LD_ADDR_EXP 32
2257: PUSH
2258: LD_EXP 32
2262: PPUSH
2263: LD_VAR 0 2
2267: PPUSH
2268: LD_INT 0
2270: PPUSH
2271: CALL_OW 1
2275: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
2276: LD_ADDR_EXP 45
2280: PUSH
2281: LD_EXP 45
2285: PPUSH
2286: LD_VAR 0 2
2290: PPUSH
2291: LD_INT 0
2293: PPUSH
2294: CALL_OW 1
2298: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
2299: LD_ADDR_EXP 33
2303: PUSH
2304: LD_EXP 33
2308: PPUSH
2309: LD_VAR 0 2
2313: PPUSH
2314: EMPTY
2315: PPUSH
2316: CALL_OW 1
2320: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
2321: LD_ADDR_EXP 44
2325: PUSH
2326: LD_EXP 44
2330: PPUSH
2331: LD_VAR 0 2
2335: PPUSH
2336: LD_INT 0
2338: PPUSH
2339: CALL_OW 1
2343: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
2344: LD_ADDR_EXP 46
2348: PUSH
2349: LD_EXP 46
2353: PPUSH
2354: LD_VAR 0 2
2358: PPUSH
2359: EMPTY
2360: PPUSH
2361: CALL_OW 1
2365: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
2366: LD_ADDR_EXP 49
2370: PUSH
2371: LD_EXP 49
2375: PPUSH
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_INT 0
2383: PPUSH
2384: CALL_OW 1
2388: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
2389: LD_ADDR_EXP 50
2393: PUSH
2394: LD_EXP 50
2398: PPUSH
2399: LD_VAR 0 2
2403: PPUSH
2404: EMPTY
2405: PPUSH
2406: CALL_OW 1
2410: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
2411: LD_ADDR_EXP 51
2415: PUSH
2416: LD_EXP 51
2420: PPUSH
2421: LD_VAR 0 2
2425: PPUSH
2426: EMPTY
2427: PPUSH
2428: CALL_OW 1
2432: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
2433: LD_ADDR_EXP 52
2437: PUSH
2438: LD_EXP 52
2442: PPUSH
2443: LD_VAR 0 2
2447: PPUSH
2448: EMPTY
2449: PPUSH
2450: CALL_OW 1
2454: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
2455: LD_ADDR_EXP 54
2459: PUSH
2460: LD_EXP 54
2464: PPUSH
2465: LD_VAR 0 2
2469: PPUSH
2470: LD_EXP 21
2474: PUSH
2475: LD_VAR 0 2
2479: ARRAY
2480: PPUSH
2481: LD_INT 2
2483: PUSH
2484: LD_INT 30
2486: PUSH
2487: LD_INT 6
2489: PUSH
2490: EMPTY
2491: LIST
2492: LIST
2493: PUSH
2494: LD_INT 30
2496: PUSH
2497: LD_INT 7
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PUSH
2504: LD_INT 30
2506: PUSH
2507: LD_INT 8
2509: PUSH
2510: EMPTY
2511: LIST
2512: LIST
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: PPUSH
2520: CALL_OW 72
2524: PPUSH
2525: CALL_OW 1
2529: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
2530: LD_ADDR_EXP 55
2534: PUSH
2535: LD_EXP 55
2539: PPUSH
2540: LD_VAR 0 2
2544: PPUSH
2545: EMPTY
2546: PPUSH
2547: CALL_OW 1
2551: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
2552: LD_ADDR_EXP 56
2556: PUSH
2557: LD_EXP 56
2561: PPUSH
2562: LD_VAR 0 2
2566: PPUSH
2567: EMPTY
2568: PPUSH
2569: CALL_OW 1
2573: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
2574: LD_ADDR_EXP 57
2578: PUSH
2579: LD_EXP 57
2583: PPUSH
2584: LD_VAR 0 2
2588: PPUSH
2589: EMPTY
2590: PPUSH
2591: CALL_OW 1
2595: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
2596: LD_ADDR_EXP 58
2600: PUSH
2601: LD_EXP 58
2605: PPUSH
2606: LD_VAR 0 2
2610: PPUSH
2611: EMPTY
2612: PPUSH
2613: CALL_OW 1
2617: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
2618: LD_ADDR_EXP 59
2622: PUSH
2623: LD_EXP 59
2627: PPUSH
2628: LD_VAR 0 2
2632: PPUSH
2633: EMPTY
2634: PPUSH
2635: CALL_OW 1
2639: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
2640: LD_ADDR_EXP 60
2644: PUSH
2645: LD_EXP 60
2649: PPUSH
2650: LD_VAR 0 2
2654: PPUSH
2655: EMPTY
2656: PPUSH
2657: CALL_OW 1
2661: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
2662: LD_ADDR_EXP 61
2666: PUSH
2667: LD_EXP 61
2671: PPUSH
2672: LD_VAR 0 2
2676: PPUSH
2677: EMPTY
2678: PPUSH
2679: CALL_OW 1
2683: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
2684: LD_ADDR_EXP 62
2688: PUSH
2689: LD_EXP 62
2693: PPUSH
2694: LD_VAR 0 2
2698: PPUSH
2699: EMPTY
2700: PPUSH
2701: CALL_OW 1
2705: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
2706: LD_ADDR_EXP 63
2710: PUSH
2711: LD_EXP 63
2715: PPUSH
2716: LD_VAR 0 2
2720: PPUSH
2721: LD_INT 0
2723: PPUSH
2724: CALL_OW 1
2728: ST_TO_ADDR
// end ;
2729: GO 1653
2731: POP
2732: POP
// MC_InitSides ( ) ;
2733: CALL 3019 0 0
// MC_InitResearch ( ) ;
2737: CALL 2758 0 0
// CustomInitMacro ( ) ;
2741: CALL 1 0 0
// skirmish := true ;
2745: LD_ADDR_EXP 19
2749: PUSH
2750: LD_INT 1
2752: ST_TO_ADDR
// end ;
2753: LD_VAR 0 1
2757: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
2758: LD_INT 0
2760: PPUSH
2761: PPUSH
2762: PPUSH
2763: PPUSH
2764: PPUSH
2765: PPUSH
// if not mc_bases then
2766: LD_EXP 21
2770: NOT
2771: IFFALSE 2775
// exit ;
2773: GO 3014
// for i = 1 to 8 do
2775: LD_ADDR_VAR 0 2
2779: PUSH
2780: DOUBLE
2781: LD_INT 1
2783: DEC
2784: ST_TO_ADDR
2785: LD_INT 8
2787: PUSH
2788: FOR_TO
2789: IFFALSE 2815
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
2791: LD_ADDR_EXP 48
2795: PUSH
2796: LD_EXP 48
2800: PPUSH
2801: LD_VAR 0 2
2805: PPUSH
2806: EMPTY
2807: PPUSH
2808: CALL_OW 1
2812: ST_TO_ADDR
2813: GO 2788
2815: POP
2816: POP
// tmp := [ ] ;
2817: LD_ADDR_VAR 0 5
2821: PUSH
2822: EMPTY
2823: ST_TO_ADDR
// for i = 1 to mc_sides do
2824: LD_ADDR_VAR 0 2
2828: PUSH
2829: DOUBLE
2830: LD_INT 1
2832: DEC
2833: ST_TO_ADDR
2834: LD_EXP 47
2838: PUSH
2839: FOR_TO
2840: IFFALSE 2898
// if not mc_sides [ i ] in tmp then
2842: LD_EXP 47
2846: PUSH
2847: LD_VAR 0 2
2851: ARRAY
2852: PUSH
2853: LD_VAR 0 5
2857: IN
2858: NOT
2859: IFFALSE 2896
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
2861: LD_ADDR_VAR 0 5
2865: PUSH
2866: LD_VAR 0 5
2870: PPUSH
2871: LD_VAR 0 5
2875: PUSH
2876: LD_INT 1
2878: PLUS
2879: PPUSH
2880: LD_EXP 47
2884: PUSH
2885: LD_VAR 0 2
2889: ARRAY
2890: PPUSH
2891: CALL_OW 2
2895: ST_TO_ADDR
2896: GO 2839
2898: POP
2899: POP
// if not tmp then
2900: LD_VAR 0 5
2904: NOT
2905: IFFALSE 2909
// exit ;
2907: GO 3014
// for j in tmp do
2909: LD_ADDR_VAR 0 3
2913: PUSH
2914: LD_VAR 0 5
2918: PUSH
2919: FOR_IN
2920: IFFALSE 3012
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
2922: LD_ADDR_VAR 0 6
2926: PUSH
2927: LD_INT 22
2929: PUSH
2930: LD_VAR 0 3
2934: PUSH
2935: EMPTY
2936: LIST
2937: LIST
2938: PPUSH
2939: CALL_OW 69
2943: ST_TO_ADDR
// if not un then
2944: LD_VAR 0 6
2948: NOT
2949: IFFALSE 2953
// continue ;
2951: GO 2919
// nation := GetNation ( un [ 1 ] ) ;
2953: LD_ADDR_VAR 0 4
2957: PUSH
2958: LD_VAR 0 6
2962: PUSH
2963: LD_INT 1
2965: ARRAY
2966: PPUSH
2967: CALL_OW 248
2971: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
2972: LD_ADDR_EXP 48
2976: PUSH
2977: LD_EXP 48
2981: PPUSH
2982: LD_VAR 0 3
2986: PPUSH
2987: LD_VAR 0 3
2991: PPUSH
2992: LD_VAR 0 4
2996: PPUSH
2997: LD_INT 1
2999: PPUSH
3000: CALL 28081 0 3
3004: PPUSH
3005: CALL_OW 1
3009: ST_TO_ADDR
// end ;
3010: GO 2919
3012: POP
3013: POP
// end ;
3014: LD_VAR 0 1
3018: RET
// export function MC_InitSides ( ) ; var i ; begin
3019: LD_INT 0
3021: PPUSH
3022: PPUSH
// if not mc_bases then
3023: LD_EXP 21
3027: NOT
3028: IFFALSE 3032
// exit ;
3030: GO 3106
// for i = 1 to mc_bases do
3032: LD_ADDR_VAR 0 2
3036: PUSH
3037: DOUBLE
3038: LD_INT 1
3040: DEC
3041: ST_TO_ADDR
3042: LD_EXP 21
3046: PUSH
3047: FOR_TO
3048: IFFALSE 3104
// if mc_bases [ i ] then
3050: LD_EXP 21
3054: PUSH
3055: LD_VAR 0 2
3059: ARRAY
3060: IFFALSE 3102
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
3062: LD_ADDR_EXP 47
3066: PUSH
3067: LD_EXP 47
3071: PPUSH
3072: LD_VAR 0 2
3076: PPUSH
3077: LD_EXP 21
3081: PUSH
3082: LD_VAR 0 2
3086: ARRAY
3087: PUSH
3088: LD_INT 1
3090: ARRAY
3091: PPUSH
3092: CALL_OW 255
3096: PPUSH
3097: CALL_OW 1
3101: ST_TO_ADDR
3102: GO 3047
3104: POP
3105: POP
// end ;
3106: LD_VAR 0 1
3110: RET
// every 0 0$01 trigger skirmish do
3111: LD_EXP 19
3115: IFFALSE 3269
3117: GO 3119
3119: DISABLE
// begin enable ;
3120: ENABLE
// MC_CheckBuildings ( ) ;
3121: CALL 7416 0 0
// MC_CheckPeopleLife ( ) ;
3125: CALL 7541 0 0
// RaiseSailEvent ( 100 ) ;
3129: LD_INT 100
3131: PPUSH
3132: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
3136: LD_INT 103
3138: PPUSH
3139: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
3143: LD_INT 104
3145: PPUSH
3146: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
3150: LD_INT 105
3152: PPUSH
3153: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
3157: LD_INT 106
3159: PPUSH
3160: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
3164: LD_INT 107
3166: PPUSH
3167: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
3171: LD_INT 108
3173: PPUSH
3174: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
3178: LD_INT 109
3180: PPUSH
3181: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
3185: LD_INT 110
3187: PPUSH
3188: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
3192: LD_INT 111
3194: PPUSH
3195: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
3199: LD_INT 112
3201: PPUSH
3202: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
3206: LD_INT 113
3208: PPUSH
3209: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
3213: LD_INT 120
3215: PPUSH
3216: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
3220: LD_INT 121
3222: PPUSH
3223: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
3227: LD_INT 122
3229: PPUSH
3230: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
3234: LD_INT 123
3236: PPUSH
3237: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
3241: LD_INT 124
3243: PPUSH
3244: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
3248: LD_INT 125
3250: PPUSH
3251: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
3255: LD_INT 126
3257: PPUSH
3258: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
3262: LD_INT 200
3264: PPUSH
3265: CALL_OW 427
// end ;
3269: END
// on SailEvent ( event ) do begin if event = 100 then
3270: LD_VAR 0 1
3274: PUSH
3275: LD_INT 100
3277: EQUAL
3278: IFFALSE 3284
// MC_ClassManager ( ) ;
3280: CALL 3676 0 0
// if event = 101 then
3284: LD_VAR 0 1
3288: PUSH
3289: LD_INT 101
3291: EQUAL
3292: IFFALSE 3298
// MC_RepairBuildings ( ) ;
3294: CALL 8099 0 0
// if event = 102 then
3298: LD_VAR 0 1
3302: PUSH
3303: LD_INT 102
3305: EQUAL
3306: IFFALSE 3312
// MC_Heal ( ) ;
3308: CALL 8505 0 0
// if event = 103 then
3312: LD_VAR 0 1
3316: PUSH
3317: LD_INT 103
3319: EQUAL
3320: IFFALSE 3326
// MC_Build ( ) ;
3322: CALL 8927 0 0
// if event = 104 then
3326: LD_VAR 0 1
3330: PUSH
3331: LD_INT 104
3333: EQUAL
3334: IFFALSE 3340
// MC_TurretWeapon ( ) ;
3336: CALL 10540 0 0
// if event = 105 then
3340: LD_VAR 0 1
3344: PUSH
3345: LD_INT 105
3347: EQUAL
3348: IFFALSE 3354
// MC_BuildUpgrade ( ) ;
3350: CALL 10091 0 0
// if event = 106 then
3354: LD_VAR 0 1
3358: PUSH
3359: LD_INT 106
3361: EQUAL
3362: IFFALSE 3368
// MC_PlantMines ( ) ;
3364: CALL 10970 0 0
// if event = 107 then
3368: LD_VAR 0 1
3372: PUSH
3373: LD_INT 107
3375: EQUAL
3376: IFFALSE 3382
// MC_CollectCrates ( ) ;
3378: CALL 12004 0 0
// if event = 108 then
3382: LD_VAR 0 1
3386: PUSH
3387: LD_INT 108
3389: EQUAL
3390: IFFALSE 3396
// MC_LinkRemoteControl ( ) ;
3392: CALL 13761 0 0
// if event = 109 then
3396: LD_VAR 0 1
3400: PUSH
3401: LD_INT 109
3403: EQUAL
3404: IFFALSE 3410
// MC_ProduceVehicle ( ) ;
3406: CALL 13942 0 0
// if event = 110 then
3410: LD_VAR 0 1
3414: PUSH
3415: LD_INT 110
3417: EQUAL
3418: IFFALSE 3424
// MC_SendAttack ( ) ;
3420: CALL 14423 0 0
// if event = 111 then
3424: LD_VAR 0 1
3428: PUSH
3429: LD_INT 111
3431: EQUAL
3432: IFFALSE 3438
// MC_Defend ( ) ;
3434: CALL 14531 0 0
// if event = 112 then
3438: LD_VAR 0 1
3442: PUSH
3443: LD_INT 112
3445: EQUAL
3446: IFFALSE 3452
// MC_Research ( ) ;
3448: CALL 15158 0 0
// if event = 113 then
3452: LD_VAR 0 1
3456: PUSH
3457: LD_INT 113
3459: EQUAL
3460: IFFALSE 3466
// MC_MinesTrigger ( ) ;
3462: CALL 16245 0 0
// if event = 120 then
3466: LD_VAR 0 1
3470: PUSH
3471: LD_INT 120
3473: EQUAL
3474: IFFALSE 3480
// MC_RepairVehicle ( ) ;
3476: CALL 16344 0 0
// if event = 121 then
3480: LD_VAR 0 1
3484: PUSH
3485: LD_INT 121
3487: EQUAL
3488: IFFALSE 3494
// MC_TameApe ( ) ;
3490: CALL 17087 0 0
// if event = 122 then
3494: LD_VAR 0 1
3498: PUSH
3499: LD_INT 122
3501: EQUAL
3502: IFFALSE 3508
// MC_ChangeApeClass ( ) ;
3504: CALL 17916 0 0
// if event = 123 then
3508: LD_VAR 0 1
3512: PUSH
3513: LD_INT 123
3515: EQUAL
3516: IFFALSE 3522
// MC_Bazooka ( ) ;
3518: CALL 18566 0 0
// if event = 124 then
3522: LD_VAR 0 1
3526: PUSH
3527: LD_INT 124
3529: EQUAL
3530: IFFALSE 3536
// MC_TeleportExit ( ) ;
3532: CALL 18764 0 0
// if event = 125 then
3536: LD_VAR 0 1
3540: PUSH
3541: LD_INT 125
3543: EQUAL
3544: IFFALSE 3550
// MC_Deposits ( ) ;
3546: CALL 19411 0 0
// if event = 126 then
3550: LD_VAR 0 1
3554: PUSH
3555: LD_INT 126
3557: EQUAL
3558: IFFALSE 3564
// MC_RemoteDriver ( ) ;
3560: CALL 20036 0 0
// if event = 200 then
3564: LD_VAR 0 1
3568: PUSH
3569: LD_INT 200
3571: EQUAL
3572: IFFALSE 3578
// MC_Idle ( ) ;
3574: CALL 21769 0 0
// end ;
3578: PPOPN 1
3580: END
// export function MC_Reset ( base , tag ) ; var i ; begin
3581: LD_INT 0
3583: PPUSH
3584: PPUSH
// if not mc_bases [ base ] or not tag then
3585: LD_EXP 21
3589: PUSH
3590: LD_VAR 0 1
3594: ARRAY
3595: NOT
3596: PUSH
3597: LD_VAR 0 2
3601: NOT
3602: OR
3603: IFFALSE 3607
// exit ;
3605: GO 3671
// for i in mc_bases [ base ] union mc_ape [ base ] do
3607: LD_ADDR_VAR 0 4
3611: PUSH
3612: LD_EXP 21
3616: PUSH
3617: LD_VAR 0 1
3621: ARRAY
3622: PUSH
3623: LD_EXP 50
3627: PUSH
3628: LD_VAR 0 1
3632: ARRAY
3633: UNION
3634: PUSH
3635: FOR_IN
3636: IFFALSE 3669
// if GetTag ( i ) = tag then
3638: LD_VAR 0 4
3642: PPUSH
3643: CALL_OW 110
3647: PUSH
3648: LD_VAR 0 2
3652: EQUAL
3653: IFFALSE 3667
// SetTag ( i , 0 ) ;
3655: LD_VAR 0 4
3659: PPUSH
3660: LD_INT 0
3662: PPUSH
3663: CALL_OW 109
3667: GO 3635
3669: POP
3670: POP
// end ;
3671: LD_VAR 0 3
3675: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
3676: LD_INT 0
3678: PPUSH
3679: PPUSH
3680: PPUSH
3681: PPUSH
3682: PPUSH
3683: PPUSH
3684: PPUSH
3685: PPUSH
// if not mc_bases then
3686: LD_EXP 21
3690: NOT
3691: IFFALSE 3695
// exit ;
3693: GO 4153
// for i = 1 to mc_bases do
3695: LD_ADDR_VAR 0 2
3699: PUSH
3700: DOUBLE
3701: LD_INT 1
3703: DEC
3704: ST_TO_ADDR
3705: LD_EXP 21
3709: PUSH
3710: FOR_TO
3711: IFFALSE 4151
// begin tmp := MC_ClassCheckReq ( i ) ;
3713: LD_ADDR_VAR 0 4
3717: PUSH
3718: LD_VAR 0 2
3722: PPUSH
3723: CALL 4158 0 1
3727: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
3728: LD_ADDR_EXP 62
3732: PUSH
3733: LD_EXP 62
3737: PPUSH
3738: LD_VAR 0 2
3742: PPUSH
3743: LD_VAR 0 4
3747: PPUSH
3748: CALL_OW 1
3752: ST_TO_ADDR
// if not tmp then
3753: LD_VAR 0 4
3757: NOT
3758: IFFALSE 3762
// continue ;
3760: GO 3710
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
3762: LD_ADDR_VAR 0 6
3766: PUSH
3767: LD_EXP 21
3771: PUSH
3772: LD_VAR 0 2
3776: ARRAY
3777: PPUSH
3778: LD_INT 2
3780: PUSH
3781: LD_INT 30
3783: PUSH
3784: LD_INT 4
3786: PUSH
3787: EMPTY
3788: LIST
3789: LIST
3790: PUSH
3791: LD_INT 30
3793: PUSH
3794: LD_INT 5
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: EMPTY
3802: LIST
3803: LIST
3804: LIST
3805: PPUSH
3806: CALL_OW 72
3810: PUSH
3811: LD_EXP 21
3815: PUSH
3816: LD_VAR 0 2
3820: ARRAY
3821: PPUSH
3822: LD_INT 2
3824: PUSH
3825: LD_INT 30
3827: PUSH
3828: LD_INT 0
3830: PUSH
3831: EMPTY
3832: LIST
3833: LIST
3834: PUSH
3835: LD_INT 30
3837: PUSH
3838: LD_INT 1
3840: PUSH
3841: EMPTY
3842: LIST
3843: LIST
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: LIST
3849: PPUSH
3850: CALL_OW 72
3854: PUSH
3855: LD_EXP 21
3859: PUSH
3860: LD_VAR 0 2
3864: ARRAY
3865: PPUSH
3866: LD_INT 30
3868: PUSH
3869: LD_INT 3
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: PPUSH
3876: CALL_OW 72
3880: PUSH
3881: LD_EXP 21
3885: PUSH
3886: LD_VAR 0 2
3890: ARRAY
3891: PPUSH
3892: LD_INT 2
3894: PUSH
3895: LD_INT 30
3897: PUSH
3898: LD_INT 6
3900: PUSH
3901: EMPTY
3902: LIST
3903: LIST
3904: PUSH
3905: LD_INT 30
3907: PUSH
3908: LD_INT 7
3910: PUSH
3911: EMPTY
3912: LIST
3913: LIST
3914: PUSH
3915: LD_INT 30
3917: PUSH
3918: LD_INT 8
3920: PUSH
3921: EMPTY
3922: LIST
3923: LIST
3924: PUSH
3925: EMPTY
3926: LIST
3927: LIST
3928: LIST
3929: LIST
3930: PPUSH
3931: CALL_OW 72
3935: PUSH
3936: EMPTY
3937: LIST
3938: LIST
3939: LIST
3940: LIST
3941: ST_TO_ADDR
// for j = 1 to 4 do
3942: LD_ADDR_VAR 0 3
3946: PUSH
3947: DOUBLE
3948: LD_INT 1
3950: DEC
3951: ST_TO_ADDR
3952: LD_INT 4
3954: PUSH
3955: FOR_TO
3956: IFFALSE 4147
// begin if not tmp [ j ] then
3958: LD_VAR 0 4
3962: PUSH
3963: LD_VAR 0 3
3967: ARRAY
3968: NOT
3969: IFFALSE 3973
// continue ;
3971: GO 3955
// for p in tmp [ j ] do
3973: LD_ADDR_VAR 0 5
3977: PUSH
3978: LD_VAR 0 4
3982: PUSH
3983: LD_VAR 0 3
3987: ARRAY
3988: PUSH
3989: FOR_IN
3990: IFFALSE 4143
// begin if not b [ j ] then
3992: LD_VAR 0 6
3996: PUSH
3997: LD_VAR 0 3
4001: ARRAY
4002: NOT
4003: IFFALSE 4007
// break ;
4005: GO 4143
// e := 0 ;
4007: LD_ADDR_VAR 0 7
4011: PUSH
4012: LD_INT 0
4014: ST_TO_ADDR
// for k in b [ j ] do
4015: LD_ADDR_VAR 0 8
4019: PUSH
4020: LD_VAR 0 6
4024: PUSH
4025: LD_VAR 0 3
4029: ARRAY
4030: PUSH
4031: FOR_IN
4032: IFFALSE 4059
// if IsNotFull ( k ) then
4034: LD_VAR 0 8
4038: PPUSH
4039: CALL 32107 0 1
4043: IFFALSE 4057
// begin e := k ;
4045: LD_ADDR_VAR 0 7
4049: PUSH
4050: LD_VAR 0 8
4054: ST_TO_ADDR
// break ;
4055: GO 4059
// end ;
4057: GO 4031
4059: POP
4060: POP
// if e and not UnitGoingToBuilding ( p , e ) then
4061: LD_VAR 0 7
4065: PUSH
4066: LD_VAR 0 5
4070: PPUSH
4071: LD_VAR 0 7
4075: PPUSH
4076: CALL 68941 0 2
4080: NOT
4081: AND
4082: IFFALSE 4141
// begin if IsInUnit ( p ) then
4084: LD_VAR 0 5
4088: PPUSH
4089: CALL_OW 310
4093: IFFALSE 4104
// ComExitBuilding ( p ) ;
4095: LD_VAR 0 5
4099: PPUSH
4100: CALL_OW 122
// ComEnterUnit ( p , e ) ;
4104: LD_VAR 0 5
4108: PPUSH
4109: LD_VAR 0 7
4113: PPUSH
4114: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
4118: LD_VAR 0 5
4122: PPUSH
4123: LD_VAR 0 3
4127: PPUSH
4128: CALL_OW 183
// AddComExitBuilding ( p ) ;
4132: LD_VAR 0 5
4136: PPUSH
4137: CALL_OW 182
// end ; end ;
4141: GO 3989
4143: POP
4144: POP
// end ;
4145: GO 3955
4147: POP
4148: POP
// end ;
4149: GO 3710
4151: POP
4152: POP
// end ;
4153: LD_VAR 0 1
4157: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
4158: LD_INT 0
4160: PPUSH
4161: PPUSH
4162: PPUSH
4163: PPUSH
4164: PPUSH
4165: PPUSH
4166: PPUSH
4167: PPUSH
4168: PPUSH
4169: PPUSH
4170: PPUSH
4171: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
4172: LD_VAR 0 1
4176: NOT
4177: PUSH
4178: LD_EXP 21
4182: PUSH
4183: LD_VAR 0 1
4187: ARRAY
4188: NOT
4189: OR
4190: PUSH
4191: LD_EXP 21
4195: PUSH
4196: LD_VAR 0 1
4200: ARRAY
4201: PPUSH
4202: LD_INT 2
4204: PUSH
4205: LD_INT 30
4207: PUSH
4208: LD_INT 0
4210: PUSH
4211: EMPTY
4212: LIST
4213: LIST
4214: PUSH
4215: LD_INT 30
4217: PUSH
4218: LD_INT 1
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: PUSH
4225: EMPTY
4226: LIST
4227: LIST
4228: LIST
4229: PPUSH
4230: CALL_OW 72
4234: NOT
4235: OR
4236: IFFALSE 4240
// exit ;
4238: GO 7411
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
4240: LD_ADDR_VAR 0 4
4244: PUSH
4245: LD_EXP 21
4249: PUSH
4250: LD_VAR 0 1
4254: ARRAY
4255: PPUSH
4256: LD_INT 2
4258: PUSH
4259: LD_INT 25
4261: PUSH
4262: LD_INT 1
4264: PUSH
4265: EMPTY
4266: LIST
4267: LIST
4268: PUSH
4269: LD_INT 25
4271: PUSH
4272: LD_INT 2
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 25
4281: PUSH
4282: LD_INT 3
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PUSH
4289: LD_INT 25
4291: PUSH
4292: LD_INT 4
4294: PUSH
4295: EMPTY
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 25
4301: PUSH
4302: LD_INT 5
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 25
4311: PUSH
4312: LD_INT 8
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 25
4321: PUSH
4322: LD_INT 9
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: EMPTY
4330: LIST
4331: LIST
4332: LIST
4333: LIST
4334: LIST
4335: LIST
4336: LIST
4337: LIST
4338: PPUSH
4339: CALL_OW 72
4343: ST_TO_ADDR
// for i in tmp do
4344: LD_ADDR_VAR 0 3
4348: PUSH
4349: LD_VAR 0 4
4353: PUSH
4354: FOR_IN
4355: IFFALSE 4386
// if GetTag ( i ) then
4357: LD_VAR 0 3
4361: PPUSH
4362: CALL_OW 110
4366: IFFALSE 4384
// tmp := tmp diff i ;
4368: LD_ADDR_VAR 0 4
4372: PUSH
4373: LD_VAR 0 4
4377: PUSH
4378: LD_VAR 0 3
4382: DIFF
4383: ST_TO_ADDR
4384: GO 4354
4386: POP
4387: POP
// if not tmp then
4388: LD_VAR 0 4
4392: NOT
4393: IFFALSE 4397
// exit ;
4395: GO 7411
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
4397: LD_ADDR_VAR 0 5
4401: PUSH
4402: LD_EXP 21
4406: PUSH
4407: LD_VAR 0 1
4411: ARRAY
4412: PPUSH
4413: LD_INT 2
4415: PUSH
4416: LD_INT 25
4418: PUSH
4419: LD_INT 1
4421: PUSH
4422: EMPTY
4423: LIST
4424: LIST
4425: PUSH
4426: LD_INT 25
4428: PUSH
4429: LD_INT 5
4431: PUSH
4432: EMPTY
4433: LIST
4434: LIST
4435: PUSH
4436: LD_INT 25
4438: PUSH
4439: LD_INT 8
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: PUSH
4446: LD_INT 25
4448: PUSH
4449: LD_INT 9
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PUSH
4456: EMPTY
4457: LIST
4458: LIST
4459: LIST
4460: LIST
4461: LIST
4462: PPUSH
4463: CALL_OW 72
4467: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
4468: LD_ADDR_VAR 0 6
4472: PUSH
4473: LD_EXP 21
4477: PUSH
4478: LD_VAR 0 1
4482: ARRAY
4483: PPUSH
4484: LD_INT 25
4486: PUSH
4487: LD_INT 2
4489: PUSH
4490: EMPTY
4491: LIST
4492: LIST
4493: PPUSH
4494: CALL_OW 72
4498: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
4499: LD_ADDR_VAR 0 7
4503: PUSH
4504: LD_EXP 21
4508: PUSH
4509: LD_VAR 0 1
4513: ARRAY
4514: PPUSH
4515: LD_INT 25
4517: PUSH
4518: LD_INT 3
4520: PUSH
4521: EMPTY
4522: LIST
4523: LIST
4524: PPUSH
4525: CALL_OW 72
4529: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
4530: LD_ADDR_VAR 0 8
4534: PUSH
4535: LD_EXP 21
4539: PUSH
4540: LD_VAR 0 1
4544: ARRAY
4545: PPUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 4
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 24
4558: PUSH
4559: LD_INT 251
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: EMPTY
4567: LIST
4568: LIST
4569: PPUSH
4570: CALL_OW 72
4574: ST_TO_ADDR
// if mc_scan [ base ] then
4575: LD_EXP 44
4579: PUSH
4580: LD_VAR 0 1
4584: ARRAY
4585: IFFALSE 5046
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
4587: LD_ADDR_EXP 63
4591: PUSH
4592: LD_EXP 63
4596: PPUSH
4597: LD_VAR 0 1
4601: PPUSH
4602: LD_INT 4
4604: PPUSH
4605: CALL_OW 1
4609: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
4610: LD_ADDR_VAR 0 12
4614: PUSH
4615: LD_EXP 21
4619: PUSH
4620: LD_VAR 0 1
4624: ARRAY
4625: PPUSH
4626: LD_INT 2
4628: PUSH
4629: LD_INT 30
4631: PUSH
4632: LD_INT 4
4634: PUSH
4635: EMPTY
4636: LIST
4637: LIST
4638: PUSH
4639: LD_INT 30
4641: PUSH
4642: LD_INT 5
4644: PUSH
4645: EMPTY
4646: LIST
4647: LIST
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: LIST
4653: PPUSH
4654: CALL_OW 72
4658: ST_TO_ADDR
// if not b then
4659: LD_VAR 0 12
4663: NOT
4664: IFFALSE 4668
// exit ;
4666: GO 7411
// p := [ ] ;
4668: LD_ADDR_VAR 0 11
4672: PUSH
4673: EMPTY
4674: ST_TO_ADDR
// if sci >= 2 then
4675: LD_VAR 0 8
4679: PUSH
4680: LD_INT 2
4682: GREATEREQUAL
4683: IFFALSE 4714
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
4685: LD_ADDR_VAR 0 8
4689: PUSH
4690: LD_VAR 0 8
4694: PUSH
4695: LD_INT 1
4697: ARRAY
4698: PUSH
4699: LD_VAR 0 8
4703: PUSH
4704: LD_INT 2
4706: ARRAY
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: ST_TO_ADDR
4712: GO 4775
// if sci = 1 then
4714: LD_VAR 0 8
4718: PUSH
4719: LD_INT 1
4721: EQUAL
4722: IFFALSE 4743
// sci := [ sci [ 1 ] ] else
4724: LD_ADDR_VAR 0 8
4728: PUSH
4729: LD_VAR 0 8
4733: PUSH
4734: LD_INT 1
4736: ARRAY
4737: PUSH
4738: EMPTY
4739: LIST
4740: ST_TO_ADDR
4741: GO 4775
// if sci = 0 then
4743: LD_VAR 0 8
4747: PUSH
4748: LD_INT 0
4750: EQUAL
4751: IFFALSE 4775
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
4753: LD_ADDR_VAR 0 11
4757: PUSH
4758: LD_VAR 0 4
4762: PPUSH
4763: LD_INT 4
4765: PPUSH
4766: CALL 68804 0 2
4770: PUSH
4771: LD_INT 1
4773: ARRAY
4774: ST_TO_ADDR
// if eng > 4 then
4775: LD_VAR 0 6
4779: PUSH
4780: LD_INT 4
4782: GREATER
4783: IFFALSE 4829
// for i = eng downto 4 do
4785: LD_ADDR_VAR 0 3
4789: PUSH
4790: DOUBLE
4791: LD_VAR 0 6
4795: INC
4796: ST_TO_ADDR
4797: LD_INT 4
4799: PUSH
4800: FOR_DOWNTO
4801: IFFALSE 4827
// eng := eng diff eng [ i ] ;
4803: LD_ADDR_VAR 0 6
4807: PUSH
4808: LD_VAR 0 6
4812: PUSH
4813: LD_VAR 0 6
4817: PUSH
4818: LD_VAR 0 3
4822: ARRAY
4823: DIFF
4824: ST_TO_ADDR
4825: GO 4800
4827: POP
4828: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
4829: LD_ADDR_VAR 0 4
4833: PUSH
4834: LD_VAR 0 4
4838: PUSH
4839: LD_VAR 0 5
4843: PUSH
4844: LD_VAR 0 6
4848: UNION
4849: PUSH
4850: LD_VAR 0 7
4854: UNION
4855: PUSH
4856: LD_VAR 0 8
4860: UNION
4861: DIFF
4862: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
4863: LD_ADDR_VAR 0 13
4867: PUSH
4868: LD_EXP 21
4872: PUSH
4873: LD_VAR 0 1
4877: ARRAY
4878: PPUSH
4879: LD_INT 2
4881: PUSH
4882: LD_INT 30
4884: PUSH
4885: LD_INT 32
4887: PUSH
4888: EMPTY
4889: LIST
4890: LIST
4891: PUSH
4892: LD_INT 30
4894: PUSH
4895: LD_INT 31
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: EMPTY
4903: LIST
4904: LIST
4905: LIST
4906: PPUSH
4907: CALL_OW 72
4911: PUSH
4912: LD_EXP 21
4916: PUSH
4917: LD_VAR 0 1
4921: ARRAY
4922: PPUSH
4923: LD_INT 2
4925: PUSH
4926: LD_INT 30
4928: PUSH
4929: LD_INT 4
4931: PUSH
4932: EMPTY
4933: LIST
4934: LIST
4935: PUSH
4936: LD_INT 30
4938: PUSH
4939: LD_INT 5
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: LIST
4950: PPUSH
4951: CALL_OW 72
4955: PUSH
4956: LD_INT 6
4958: MUL
4959: PLUS
4960: ST_TO_ADDR
// if bcount < tmp then
4961: LD_VAR 0 13
4965: PUSH
4966: LD_VAR 0 4
4970: LESS
4971: IFFALSE 5017
// for i = tmp downto bcount do
4973: LD_ADDR_VAR 0 3
4977: PUSH
4978: DOUBLE
4979: LD_VAR 0 4
4983: INC
4984: ST_TO_ADDR
4985: LD_VAR 0 13
4989: PUSH
4990: FOR_DOWNTO
4991: IFFALSE 5015
// tmp := Delete ( tmp , tmp ) ;
4993: LD_ADDR_VAR 0 4
4997: PUSH
4998: LD_VAR 0 4
5002: PPUSH
5003: LD_VAR 0 4
5007: PPUSH
5008: CALL_OW 3
5012: ST_TO_ADDR
5013: GO 4990
5015: POP
5016: POP
// result := [ tmp , 0 , 0 , p ] ;
5017: LD_ADDR_VAR 0 2
5021: PUSH
5022: LD_VAR 0 4
5026: PUSH
5027: LD_INT 0
5029: PUSH
5030: LD_INT 0
5032: PUSH
5033: LD_VAR 0 11
5037: PUSH
5038: EMPTY
5039: LIST
5040: LIST
5041: LIST
5042: LIST
5043: ST_TO_ADDR
// exit ;
5044: GO 7411
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
5046: LD_EXP 21
5050: PUSH
5051: LD_VAR 0 1
5055: ARRAY
5056: PPUSH
5057: LD_INT 2
5059: PUSH
5060: LD_INT 30
5062: PUSH
5063: LD_INT 6
5065: PUSH
5066: EMPTY
5067: LIST
5068: LIST
5069: PUSH
5070: LD_INT 30
5072: PUSH
5073: LD_INT 7
5075: PUSH
5076: EMPTY
5077: LIST
5078: LIST
5079: PUSH
5080: LD_INT 30
5082: PUSH
5083: LD_INT 8
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: PUSH
5090: EMPTY
5091: LIST
5092: LIST
5093: LIST
5094: LIST
5095: PPUSH
5096: CALL_OW 72
5100: NOT
5101: PUSH
5102: LD_EXP 21
5106: PUSH
5107: LD_VAR 0 1
5111: ARRAY
5112: PPUSH
5113: LD_INT 30
5115: PUSH
5116: LD_INT 3
5118: PUSH
5119: EMPTY
5120: LIST
5121: LIST
5122: PPUSH
5123: CALL_OW 72
5127: NOT
5128: AND
5129: IFFALSE 5201
// begin if eng = tmp then
5131: LD_VAR 0 6
5135: PUSH
5136: LD_VAR 0 4
5140: EQUAL
5141: IFFALSE 5145
// exit ;
5143: GO 7411
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
5145: LD_ADDR_EXP 63
5149: PUSH
5150: LD_EXP 63
5154: PPUSH
5155: LD_VAR 0 1
5159: PPUSH
5160: LD_INT 1
5162: PPUSH
5163: CALL_OW 1
5167: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
5168: LD_ADDR_VAR 0 2
5172: PUSH
5173: LD_INT 0
5175: PUSH
5176: LD_VAR 0 4
5180: PUSH
5181: LD_VAR 0 6
5185: DIFF
5186: PUSH
5187: LD_INT 0
5189: PUSH
5190: LD_INT 0
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: ST_TO_ADDR
// exit ;
5199: GO 7411
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
5201: LD_EXP 48
5205: PUSH
5206: LD_EXP 47
5210: PUSH
5211: LD_VAR 0 1
5215: ARRAY
5216: ARRAY
5217: PUSH
5218: LD_EXP 21
5222: PUSH
5223: LD_VAR 0 1
5227: ARRAY
5228: PPUSH
5229: LD_INT 2
5231: PUSH
5232: LD_INT 30
5234: PUSH
5235: LD_INT 6
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PUSH
5242: LD_INT 30
5244: PUSH
5245: LD_INT 7
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: PUSH
5252: LD_INT 30
5254: PUSH
5255: LD_INT 8
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: LIST
5266: LIST
5267: PPUSH
5268: CALL_OW 72
5272: AND
5273: PUSH
5274: LD_EXP 21
5278: PUSH
5279: LD_VAR 0 1
5283: ARRAY
5284: PPUSH
5285: LD_INT 30
5287: PUSH
5288: LD_INT 3
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PPUSH
5295: CALL_OW 72
5299: NOT
5300: AND
5301: IFFALSE 5515
// begin if sci >= 6 then
5303: LD_VAR 0 8
5307: PUSH
5308: LD_INT 6
5310: GREATEREQUAL
5311: IFFALSE 5315
// exit ;
5313: GO 7411
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
5315: LD_ADDR_EXP 63
5319: PUSH
5320: LD_EXP 63
5324: PPUSH
5325: LD_VAR 0 1
5329: PPUSH
5330: LD_INT 2
5332: PPUSH
5333: CALL_OW 1
5337: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
5338: LD_ADDR_VAR 0 9
5342: PUSH
5343: LD_VAR 0 4
5347: PUSH
5348: LD_VAR 0 8
5352: DIFF
5353: PPUSH
5354: LD_INT 4
5356: PPUSH
5357: CALL 68804 0 2
5361: ST_TO_ADDR
// p := [ ] ;
5362: LD_ADDR_VAR 0 11
5366: PUSH
5367: EMPTY
5368: ST_TO_ADDR
// if sci < 6 and sort > 6 then
5369: LD_VAR 0 8
5373: PUSH
5374: LD_INT 6
5376: LESS
5377: PUSH
5378: LD_VAR 0 9
5382: PUSH
5383: LD_INT 6
5385: GREATER
5386: AND
5387: IFFALSE 5468
// begin for i = 1 to 6 - sci do
5389: LD_ADDR_VAR 0 3
5393: PUSH
5394: DOUBLE
5395: LD_INT 1
5397: DEC
5398: ST_TO_ADDR
5399: LD_INT 6
5401: PUSH
5402: LD_VAR 0 8
5406: MINUS
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5464
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
5411: LD_ADDR_VAR 0 11
5415: PUSH
5416: LD_VAR 0 11
5420: PPUSH
5421: LD_VAR 0 11
5425: PUSH
5426: LD_INT 1
5428: PLUS
5429: PPUSH
5430: LD_VAR 0 9
5434: PUSH
5435: LD_INT 1
5437: ARRAY
5438: PPUSH
5439: CALL_OW 2
5443: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
5444: LD_ADDR_VAR 0 9
5448: PUSH
5449: LD_VAR 0 9
5453: PPUSH
5454: LD_INT 1
5456: PPUSH
5457: CALL_OW 3
5461: ST_TO_ADDR
// end ;
5462: GO 5408
5464: POP
5465: POP
// end else
5466: GO 5488
// if sort then
5468: LD_VAR 0 9
5472: IFFALSE 5488
// p := sort [ 1 ] ;
5474: LD_ADDR_VAR 0 11
5478: PUSH
5479: LD_VAR 0 9
5483: PUSH
5484: LD_INT 1
5486: ARRAY
5487: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
5488: LD_ADDR_VAR 0 2
5492: PUSH
5493: LD_INT 0
5495: PUSH
5496: LD_INT 0
5498: PUSH
5499: LD_INT 0
5501: PUSH
5502: LD_VAR 0 11
5506: PUSH
5507: EMPTY
5508: LIST
5509: LIST
5510: LIST
5511: LIST
5512: ST_TO_ADDR
// exit ;
5513: GO 7411
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
5515: LD_EXP 48
5519: PUSH
5520: LD_EXP 47
5524: PUSH
5525: LD_VAR 0 1
5529: ARRAY
5530: ARRAY
5531: PUSH
5532: LD_EXP 21
5536: PUSH
5537: LD_VAR 0 1
5541: ARRAY
5542: PPUSH
5543: LD_INT 2
5545: PUSH
5546: LD_INT 30
5548: PUSH
5549: LD_INT 6
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: LD_INT 30
5558: PUSH
5559: LD_INT 7
5561: PUSH
5562: EMPTY
5563: LIST
5564: LIST
5565: PUSH
5566: LD_INT 30
5568: PUSH
5569: LD_INT 8
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 72
5586: AND
5587: PUSH
5588: LD_EXP 21
5592: PUSH
5593: LD_VAR 0 1
5597: ARRAY
5598: PPUSH
5599: LD_INT 30
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: PPUSH
5609: CALL_OW 72
5613: AND
5614: IFFALSE 6141
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
5616: LD_ADDR_EXP 63
5620: PUSH
5621: LD_EXP 63
5625: PPUSH
5626: LD_VAR 0 1
5630: PPUSH
5631: LD_INT 3
5633: PPUSH
5634: CALL_OW 1
5638: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
5639: LD_ADDR_VAR 0 2
5643: PUSH
5644: LD_INT 0
5646: PUSH
5647: LD_INT 0
5649: PUSH
5650: LD_INT 0
5652: PUSH
5653: LD_INT 0
5655: PUSH
5656: EMPTY
5657: LIST
5658: LIST
5659: LIST
5660: LIST
5661: ST_TO_ADDR
// if not eng then
5662: LD_VAR 0 6
5666: NOT
5667: IFFALSE 5730
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
5669: LD_ADDR_VAR 0 11
5673: PUSH
5674: LD_VAR 0 4
5678: PPUSH
5679: LD_INT 2
5681: PPUSH
5682: CALL 68804 0 2
5686: PUSH
5687: LD_INT 1
5689: ARRAY
5690: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
5691: LD_ADDR_VAR 0 2
5695: PUSH
5696: LD_VAR 0 2
5700: PPUSH
5701: LD_INT 2
5703: PPUSH
5704: LD_VAR 0 11
5708: PPUSH
5709: CALL_OW 1
5713: ST_TO_ADDR
// tmp := tmp diff p ;
5714: LD_ADDR_VAR 0 4
5718: PUSH
5719: LD_VAR 0 4
5723: PUSH
5724: LD_VAR 0 11
5728: DIFF
5729: ST_TO_ADDR
// end ; if not eng then
5730: LD_VAR 0 6
5734: NOT
5735: IFFALSE 5761
// tmp := tmp diff ( mech union sci ) else
5737: LD_ADDR_VAR 0 4
5741: PUSH
5742: LD_VAR 0 4
5746: PUSH
5747: LD_VAR 0 7
5751: PUSH
5752: LD_VAR 0 8
5756: UNION
5757: DIFF
5758: ST_TO_ADDR
5759: GO 5793
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
5761: LD_ADDR_VAR 0 4
5765: PUSH
5766: LD_VAR 0 4
5770: PUSH
5771: LD_VAR 0 6
5775: PUSH
5776: LD_INT 1
5778: ARRAY
5779: PUSH
5780: LD_VAR 0 7
5784: UNION
5785: PUSH
5786: LD_VAR 0 8
5790: UNION
5791: DIFF
5792: ST_TO_ADDR
// if tmp and sci < 6 then
5793: LD_VAR 0 4
5797: PUSH
5798: LD_VAR 0 8
5802: PUSH
5803: LD_INT 6
5805: LESS
5806: AND
5807: IFFALSE 5966
// begin sort := SortBySkill ( tmp , 4 ) ;
5809: LD_ADDR_VAR 0 9
5813: PUSH
5814: LD_VAR 0 4
5818: PPUSH
5819: LD_INT 4
5821: PPUSH
5822: CALL 68804 0 2
5826: ST_TO_ADDR
// p := [ ] ;
5827: LD_ADDR_VAR 0 11
5831: PUSH
5832: EMPTY
5833: ST_TO_ADDR
// if sort then
5834: LD_VAR 0 9
5838: IFFALSE 5937
// for i = 1 to 6 - sci do
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: DOUBLE
5846: LD_INT 1
5848: DEC
5849: ST_TO_ADDR
5850: LD_INT 6
5852: PUSH
5853: LD_VAR 0 8
5857: MINUS
5858: PUSH
5859: FOR_TO
5860: IFFALSE 5935
// begin if i = sort then
5862: LD_VAR 0 3
5866: PUSH
5867: LD_VAR 0 9
5871: EQUAL
5872: IFFALSE 5876
// break ;
5874: GO 5935
// p := Insert ( p , p + 1 , sort [ i ] ) ;
5876: LD_ADDR_VAR 0 11
5880: PUSH
5881: LD_VAR 0 11
5885: PPUSH
5886: LD_VAR 0 11
5890: PUSH
5891: LD_INT 1
5893: PLUS
5894: PPUSH
5895: LD_VAR 0 9
5899: PUSH
5900: LD_VAR 0 3
5904: ARRAY
5905: PPUSH
5906: CALL_OW 2
5910: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
5911: LD_ADDR_VAR 0 4
5915: PUSH
5916: LD_VAR 0 4
5920: PUSH
5921: LD_VAR 0 9
5925: PUSH
5926: LD_VAR 0 3
5930: ARRAY
5931: DIFF
5932: ST_TO_ADDR
// end ;
5933: GO 5859
5935: POP
5936: POP
// if p then
5937: LD_VAR 0 11
5941: IFFALSE 5966
// result := Replace ( result , 4 , p ) ;
5943: LD_ADDR_VAR 0 2
5947: PUSH
5948: LD_VAR 0 2
5952: PPUSH
5953: LD_INT 4
5955: PPUSH
5956: LD_VAR 0 11
5960: PPUSH
5961: CALL_OW 1
5965: ST_TO_ADDR
// end ; if tmp and mech < 6 then
5966: LD_VAR 0 4
5970: PUSH
5971: LD_VAR 0 7
5975: PUSH
5976: LD_INT 6
5978: LESS
5979: AND
5980: IFFALSE 6139
// begin sort := SortBySkill ( tmp , 3 ) ;
5982: LD_ADDR_VAR 0 9
5986: PUSH
5987: LD_VAR 0 4
5991: PPUSH
5992: LD_INT 3
5994: PPUSH
5995: CALL 68804 0 2
5999: ST_TO_ADDR
// p := [ ] ;
6000: LD_ADDR_VAR 0 11
6004: PUSH
6005: EMPTY
6006: ST_TO_ADDR
// if sort then
6007: LD_VAR 0 9
6011: IFFALSE 6110
// for i = 1 to 6 - mech do
6013: LD_ADDR_VAR 0 3
6017: PUSH
6018: DOUBLE
6019: LD_INT 1
6021: DEC
6022: ST_TO_ADDR
6023: LD_INT 6
6025: PUSH
6026: LD_VAR 0 7
6030: MINUS
6031: PUSH
6032: FOR_TO
6033: IFFALSE 6108
// begin if i = sort then
6035: LD_VAR 0 3
6039: PUSH
6040: LD_VAR 0 9
6044: EQUAL
6045: IFFALSE 6049
// break ;
6047: GO 6108
// p := Insert ( p , p + 1 , sort [ i ] ) ;
6049: LD_ADDR_VAR 0 11
6053: PUSH
6054: LD_VAR 0 11
6058: PPUSH
6059: LD_VAR 0 11
6063: PUSH
6064: LD_INT 1
6066: PLUS
6067: PPUSH
6068: LD_VAR 0 9
6072: PUSH
6073: LD_VAR 0 3
6077: ARRAY
6078: PPUSH
6079: CALL_OW 2
6083: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
6084: LD_ADDR_VAR 0 4
6088: PUSH
6089: LD_VAR 0 4
6093: PUSH
6094: LD_VAR 0 9
6098: PUSH
6099: LD_VAR 0 3
6103: ARRAY
6104: DIFF
6105: ST_TO_ADDR
// end ;
6106: GO 6032
6108: POP
6109: POP
// if p then
6110: LD_VAR 0 11
6114: IFFALSE 6139
// result := Replace ( result , 3 , p ) ;
6116: LD_ADDR_VAR 0 2
6120: PUSH
6121: LD_VAR 0 2
6125: PPUSH
6126: LD_INT 3
6128: PPUSH
6129: LD_VAR 0 11
6133: PPUSH
6134: CALL_OW 1
6138: ST_TO_ADDR
// end ; exit ;
6139: GO 7411
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
6141: LD_EXP 48
6145: PUSH
6146: LD_EXP 47
6150: PUSH
6151: LD_VAR 0 1
6155: ARRAY
6156: ARRAY
6157: NOT
6158: PUSH
6159: LD_EXP 21
6163: PUSH
6164: LD_VAR 0 1
6168: ARRAY
6169: PPUSH
6170: LD_INT 30
6172: PUSH
6173: LD_INT 3
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: AND
6185: PUSH
6186: LD_EXP 26
6190: PUSH
6191: LD_VAR 0 1
6195: ARRAY
6196: AND
6197: IFFALSE 6741
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
6199: LD_ADDR_EXP 63
6203: PUSH
6204: LD_EXP 63
6208: PPUSH
6209: LD_VAR 0 1
6213: PPUSH
6214: LD_INT 5
6216: PPUSH
6217: CALL_OW 1
6221: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
6222: LD_ADDR_VAR 0 2
6226: PUSH
6227: LD_INT 0
6229: PUSH
6230: LD_INT 0
6232: PUSH
6233: LD_INT 0
6235: PUSH
6236: LD_INT 0
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: ST_TO_ADDR
// if sci > 1 then
6245: LD_VAR 0 8
6249: PUSH
6250: LD_INT 1
6252: GREATER
6253: IFFALSE 6281
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
6255: LD_ADDR_VAR 0 4
6259: PUSH
6260: LD_VAR 0 4
6264: PUSH
6265: LD_VAR 0 8
6269: PUSH
6270: LD_VAR 0 8
6274: PUSH
6275: LD_INT 1
6277: ARRAY
6278: DIFF
6279: DIFF
6280: ST_TO_ADDR
// if tmp and not sci then
6281: LD_VAR 0 4
6285: PUSH
6286: LD_VAR 0 8
6290: NOT
6291: AND
6292: IFFALSE 6361
// begin sort := SortBySkill ( tmp , 4 ) ;
6294: LD_ADDR_VAR 0 9
6298: PUSH
6299: LD_VAR 0 4
6303: PPUSH
6304: LD_INT 4
6306: PPUSH
6307: CALL 68804 0 2
6311: ST_TO_ADDR
// if sort then
6312: LD_VAR 0 9
6316: IFFALSE 6332
// p := sort [ 1 ] ;
6318: LD_ADDR_VAR 0 11
6322: PUSH
6323: LD_VAR 0 9
6327: PUSH
6328: LD_INT 1
6330: ARRAY
6331: ST_TO_ADDR
// if p then
6332: LD_VAR 0 11
6336: IFFALSE 6361
// result := Replace ( result , 4 , p ) ;
6338: LD_ADDR_VAR 0 2
6342: PUSH
6343: LD_VAR 0 2
6347: PPUSH
6348: LD_INT 4
6350: PPUSH
6351: LD_VAR 0 11
6355: PPUSH
6356: CALL_OW 1
6360: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
6361: LD_ADDR_VAR 0 4
6365: PUSH
6366: LD_VAR 0 4
6370: PUSH
6371: LD_VAR 0 7
6375: DIFF
6376: ST_TO_ADDR
// if tmp and mech < 6 then
6377: LD_VAR 0 4
6381: PUSH
6382: LD_VAR 0 7
6386: PUSH
6387: LD_INT 6
6389: LESS
6390: AND
6391: IFFALSE 6550
// begin sort := SortBySkill ( tmp , 3 ) ;
6393: LD_ADDR_VAR 0 9
6397: PUSH
6398: LD_VAR 0 4
6402: PPUSH
6403: LD_INT 3
6405: PPUSH
6406: CALL 68804 0 2
6410: ST_TO_ADDR
// p := [ ] ;
6411: LD_ADDR_VAR 0 11
6415: PUSH
6416: EMPTY
6417: ST_TO_ADDR
// if sort then
6418: LD_VAR 0 9
6422: IFFALSE 6521
// for i = 1 to 6 - mech do
6424: LD_ADDR_VAR 0 3
6428: PUSH
6429: DOUBLE
6430: LD_INT 1
6432: DEC
6433: ST_TO_ADDR
6434: LD_INT 6
6436: PUSH
6437: LD_VAR 0 7
6441: MINUS
6442: PUSH
6443: FOR_TO
6444: IFFALSE 6519
// begin if i = sort then
6446: LD_VAR 0 3
6450: PUSH
6451: LD_VAR 0 9
6455: EQUAL
6456: IFFALSE 6460
// break ;
6458: GO 6519
// p := Insert ( p , p + 1 , sort [ i ] ) ;
6460: LD_ADDR_VAR 0 11
6464: PUSH
6465: LD_VAR 0 11
6469: PPUSH
6470: LD_VAR 0 11
6474: PUSH
6475: LD_INT 1
6477: PLUS
6478: PPUSH
6479: LD_VAR 0 9
6483: PUSH
6484: LD_VAR 0 3
6488: ARRAY
6489: PPUSH
6490: CALL_OW 2
6494: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
6495: LD_ADDR_VAR 0 4
6499: PUSH
6500: LD_VAR 0 4
6504: PUSH
6505: LD_VAR 0 9
6509: PUSH
6510: LD_VAR 0 3
6514: ARRAY
6515: DIFF
6516: ST_TO_ADDR
// end ;
6517: GO 6443
6519: POP
6520: POP
// if p then
6521: LD_VAR 0 11
6525: IFFALSE 6550
// result := Replace ( result , 3 , p ) ;
6527: LD_ADDR_VAR 0 2
6531: PUSH
6532: LD_VAR 0 2
6536: PPUSH
6537: LD_INT 3
6539: PPUSH
6540: LD_VAR 0 11
6544: PPUSH
6545: CALL_OW 1
6549: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
6550: LD_ADDR_VAR 0 4
6554: PUSH
6555: LD_VAR 0 4
6559: PUSH
6560: LD_VAR 0 6
6564: DIFF
6565: ST_TO_ADDR
// if tmp and eng < 6 then
6566: LD_VAR 0 4
6570: PUSH
6571: LD_VAR 0 6
6575: PUSH
6576: LD_INT 6
6578: LESS
6579: AND
6580: IFFALSE 6739
// begin sort := SortBySkill ( tmp , 2 ) ;
6582: LD_ADDR_VAR 0 9
6586: PUSH
6587: LD_VAR 0 4
6591: PPUSH
6592: LD_INT 2
6594: PPUSH
6595: CALL 68804 0 2
6599: ST_TO_ADDR
// p := [ ] ;
6600: LD_ADDR_VAR 0 11
6604: PUSH
6605: EMPTY
6606: ST_TO_ADDR
// if sort then
6607: LD_VAR 0 9
6611: IFFALSE 6710
// for i = 1 to 6 - eng do
6613: LD_ADDR_VAR 0 3
6617: PUSH
6618: DOUBLE
6619: LD_INT 1
6621: DEC
6622: ST_TO_ADDR
6623: LD_INT 6
6625: PUSH
6626: LD_VAR 0 6
6630: MINUS
6631: PUSH
6632: FOR_TO
6633: IFFALSE 6708
// begin if i = sort then
6635: LD_VAR 0 3
6639: PUSH
6640: LD_VAR 0 9
6644: EQUAL
6645: IFFALSE 6649
// break ;
6647: GO 6708
// p := Insert ( p , p + 1 , sort [ i ] ) ;
6649: LD_ADDR_VAR 0 11
6653: PUSH
6654: LD_VAR 0 11
6658: PPUSH
6659: LD_VAR 0 11
6663: PUSH
6664: LD_INT 1
6666: PLUS
6667: PPUSH
6668: LD_VAR 0 9
6672: PUSH
6673: LD_VAR 0 3
6677: ARRAY
6678: PPUSH
6679: CALL_OW 2
6683: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
6684: LD_ADDR_VAR 0 4
6688: PUSH
6689: LD_VAR 0 4
6693: PUSH
6694: LD_VAR 0 9
6698: PUSH
6699: LD_VAR 0 3
6703: ARRAY
6704: DIFF
6705: ST_TO_ADDR
// end ;
6706: GO 6632
6708: POP
6709: POP
// if p then
6710: LD_VAR 0 11
6714: IFFALSE 6739
// result := Replace ( result , 2 , p ) ;
6716: LD_ADDR_VAR 0 2
6720: PUSH
6721: LD_VAR 0 2
6725: PPUSH
6726: LD_INT 2
6728: PPUSH
6729: LD_VAR 0 11
6733: PPUSH
6734: CALL_OW 1
6738: ST_TO_ADDR
// end ; exit ;
6739: GO 7411
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
6741: LD_EXP 48
6745: PUSH
6746: LD_EXP 47
6750: PUSH
6751: LD_VAR 0 1
6755: ARRAY
6756: ARRAY
6757: NOT
6758: PUSH
6759: LD_EXP 21
6763: PUSH
6764: LD_VAR 0 1
6768: ARRAY
6769: PPUSH
6770: LD_INT 30
6772: PUSH
6773: LD_INT 3
6775: PUSH
6776: EMPTY
6777: LIST
6778: LIST
6779: PPUSH
6780: CALL_OW 72
6784: AND
6785: PUSH
6786: LD_EXP 26
6790: PUSH
6791: LD_VAR 0 1
6795: ARRAY
6796: NOT
6797: AND
6798: IFFALSE 7411
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
6800: LD_ADDR_EXP 63
6804: PUSH
6805: LD_EXP 63
6809: PPUSH
6810: LD_VAR 0 1
6814: PPUSH
6815: LD_INT 6
6817: PPUSH
6818: CALL_OW 1
6822: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
6823: LD_ADDR_VAR 0 2
6827: PUSH
6828: LD_INT 0
6830: PUSH
6831: LD_INT 0
6833: PUSH
6834: LD_INT 0
6836: PUSH
6837: LD_INT 0
6839: PUSH
6840: EMPTY
6841: LIST
6842: LIST
6843: LIST
6844: LIST
6845: ST_TO_ADDR
// if sci >= 1 then
6846: LD_VAR 0 8
6850: PUSH
6851: LD_INT 1
6853: GREATEREQUAL
6854: IFFALSE 6876
// tmp := tmp diff sci [ 1 ] ;
6856: LD_ADDR_VAR 0 4
6860: PUSH
6861: LD_VAR 0 4
6865: PUSH
6866: LD_VAR 0 8
6870: PUSH
6871: LD_INT 1
6873: ARRAY
6874: DIFF
6875: ST_TO_ADDR
// if tmp and not sci then
6876: LD_VAR 0 4
6880: PUSH
6881: LD_VAR 0 8
6885: NOT
6886: AND
6887: IFFALSE 6956
// begin sort := SortBySkill ( tmp , 4 ) ;
6889: LD_ADDR_VAR 0 9
6893: PUSH
6894: LD_VAR 0 4
6898: PPUSH
6899: LD_INT 4
6901: PPUSH
6902: CALL 68804 0 2
6906: ST_TO_ADDR
// if sort then
6907: LD_VAR 0 9
6911: IFFALSE 6927
// p := sort [ 1 ] ;
6913: LD_ADDR_VAR 0 11
6917: PUSH
6918: LD_VAR 0 9
6922: PUSH
6923: LD_INT 1
6925: ARRAY
6926: ST_TO_ADDR
// if p then
6927: LD_VAR 0 11
6931: IFFALSE 6956
// result := Replace ( result , 4 , p ) ;
6933: LD_ADDR_VAR 0 2
6937: PUSH
6938: LD_VAR 0 2
6942: PPUSH
6943: LD_INT 4
6945: PPUSH
6946: LD_VAR 0 11
6950: PPUSH
6951: CALL_OW 1
6955: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
6956: LD_ADDR_VAR 0 4
6960: PUSH
6961: LD_VAR 0 4
6965: PUSH
6966: LD_VAR 0 7
6970: DIFF
6971: ST_TO_ADDR
// if tmp and mech < 6 then
6972: LD_VAR 0 4
6976: PUSH
6977: LD_VAR 0 7
6981: PUSH
6982: LD_INT 6
6984: LESS
6985: AND
6986: IFFALSE 7145
// begin sort := SortBySkill ( tmp , 3 ) ;
6988: LD_ADDR_VAR 0 9
6992: PUSH
6993: LD_VAR 0 4
6997: PPUSH
6998: LD_INT 3
7000: PPUSH
7001: CALL 68804 0 2
7005: ST_TO_ADDR
// p := [ ] ;
7006: LD_ADDR_VAR 0 11
7010: PUSH
7011: EMPTY
7012: ST_TO_ADDR
// if sort then
7013: LD_VAR 0 9
7017: IFFALSE 7116
// for i = 1 to 6 - mech do
7019: LD_ADDR_VAR 0 3
7023: PUSH
7024: DOUBLE
7025: LD_INT 1
7027: DEC
7028: ST_TO_ADDR
7029: LD_INT 6
7031: PUSH
7032: LD_VAR 0 7
7036: MINUS
7037: PUSH
7038: FOR_TO
7039: IFFALSE 7114
// begin if i = sort then
7041: LD_VAR 0 3
7045: PUSH
7046: LD_VAR 0 9
7050: EQUAL
7051: IFFALSE 7055
// break ;
7053: GO 7114
// p := Insert ( p , p + 1 , sort [ i ] ) ;
7055: LD_ADDR_VAR 0 11
7059: PUSH
7060: LD_VAR 0 11
7064: PPUSH
7065: LD_VAR 0 11
7069: PUSH
7070: LD_INT 1
7072: PLUS
7073: PPUSH
7074: LD_VAR 0 9
7078: PUSH
7079: LD_VAR 0 3
7083: ARRAY
7084: PPUSH
7085: CALL_OW 2
7089: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
7090: LD_ADDR_VAR 0 4
7094: PUSH
7095: LD_VAR 0 4
7099: PUSH
7100: LD_VAR 0 9
7104: PUSH
7105: LD_VAR 0 3
7109: ARRAY
7110: DIFF
7111: ST_TO_ADDR
// end ;
7112: GO 7038
7114: POP
7115: POP
// if p then
7116: LD_VAR 0 11
7120: IFFALSE 7145
// result := Replace ( result , 3 , p ) ;
7122: LD_ADDR_VAR 0 2
7126: PUSH
7127: LD_VAR 0 2
7131: PPUSH
7132: LD_INT 3
7134: PPUSH
7135: LD_VAR 0 11
7139: PPUSH
7140: CALL_OW 1
7144: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
7145: LD_ADDR_VAR 0 4
7149: PUSH
7150: LD_VAR 0 4
7154: PUSH
7155: LD_VAR 0 6
7159: DIFF
7160: ST_TO_ADDR
// if tmp and eng < 4 then
7161: LD_VAR 0 4
7165: PUSH
7166: LD_VAR 0 6
7170: PUSH
7171: LD_INT 4
7173: LESS
7174: AND
7175: IFFALSE 7336
// begin sort := SortBySkill ( tmp , 2 ) ;
7177: LD_ADDR_VAR 0 9
7181: PUSH
7182: LD_VAR 0 4
7186: PPUSH
7187: LD_INT 2
7189: PPUSH
7190: CALL 68804 0 2
7194: ST_TO_ADDR
// p := [ ] ;
7195: LD_ADDR_VAR 0 11
7199: PUSH
7200: EMPTY
7201: ST_TO_ADDR
// if sort then
7202: LD_VAR 0 9
7206: IFFALSE 7305
// for i = 1 to 4 - eng do
7208: LD_ADDR_VAR 0 3
7212: PUSH
7213: DOUBLE
7214: LD_INT 1
7216: DEC
7217: ST_TO_ADDR
7218: LD_INT 4
7220: PUSH
7221: LD_VAR 0 6
7225: MINUS
7226: PUSH
7227: FOR_TO
7228: IFFALSE 7303
// begin if i = sort then
7230: LD_VAR 0 3
7234: PUSH
7235: LD_VAR 0 9
7239: EQUAL
7240: IFFALSE 7244
// break ;
7242: GO 7303
// p := Insert ( p , p + 1 , sort [ i ] ) ;
7244: LD_ADDR_VAR 0 11
7248: PUSH
7249: LD_VAR 0 11
7253: PPUSH
7254: LD_VAR 0 11
7258: PUSH
7259: LD_INT 1
7261: PLUS
7262: PPUSH
7263: LD_VAR 0 9
7267: PUSH
7268: LD_VAR 0 3
7272: ARRAY
7273: PPUSH
7274: CALL_OW 2
7278: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
7279: LD_ADDR_VAR 0 4
7283: PUSH
7284: LD_VAR 0 4
7288: PUSH
7289: LD_VAR 0 9
7293: PUSH
7294: LD_VAR 0 3
7298: ARRAY
7299: DIFF
7300: ST_TO_ADDR
// end ;
7301: GO 7227
7303: POP
7304: POP
// if p then
7305: LD_VAR 0 11
7309: IFFALSE 7334
// result := Replace ( result , 2 , p ) ;
7311: LD_ADDR_VAR 0 2
7315: PUSH
7316: LD_VAR 0 2
7320: PPUSH
7321: LD_INT 2
7323: PPUSH
7324: LD_VAR 0 11
7328: PPUSH
7329: CALL_OW 1
7333: ST_TO_ADDR
// end else
7334: GO 7380
// for i = eng downto 5 do
7336: LD_ADDR_VAR 0 3
7340: PUSH
7341: DOUBLE
7342: LD_VAR 0 6
7346: INC
7347: ST_TO_ADDR
7348: LD_INT 5
7350: PUSH
7351: FOR_DOWNTO
7352: IFFALSE 7378
// tmp := tmp union eng [ i ] ;
7354: LD_ADDR_VAR 0 4
7358: PUSH
7359: LD_VAR 0 4
7363: PUSH
7364: LD_VAR 0 6
7368: PUSH
7369: LD_VAR 0 3
7373: ARRAY
7374: UNION
7375: ST_TO_ADDR
7376: GO 7351
7378: POP
7379: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
7380: LD_ADDR_VAR 0 2
7384: PUSH
7385: LD_VAR 0 2
7389: PPUSH
7390: LD_INT 1
7392: PPUSH
7393: LD_VAR 0 4
7397: PUSH
7398: LD_VAR 0 5
7402: DIFF
7403: PPUSH
7404: CALL_OW 1
7408: ST_TO_ADDR
// exit ;
7409: GO 7411
// end ; end ;
7411: LD_VAR 0 2
7415: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
7416: LD_INT 0
7418: PPUSH
7419: PPUSH
7420: PPUSH
// if not mc_bases then
7421: LD_EXP 21
7425: NOT
7426: IFFALSE 7430
// exit ;
7428: GO 7536
// for i = 1 to mc_bases do
7430: LD_ADDR_VAR 0 2
7434: PUSH
7435: DOUBLE
7436: LD_INT 1
7438: DEC
7439: ST_TO_ADDR
7440: LD_EXP 21
7444: PUSH
7445: FOR_TO
7446: IFFALSE 7527
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
7448: LD_ADDR_VAR 0 3
7452: PUSH
7453: LD_EXP 21
7457: PUSH
7458: LD_VAR 0 2
7462: ARRAY
7463: PPUSH
7464: LD_INT 21
7466: PUSH
7467: LD_INT 3
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 3
7476: PUSH
7477: LD_INT 24
7479: PUSH
7480: LD_INT 1000
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: EMPTY
7488: LIST
7489: LIST
7490: PUSH
7491: EMPTY
7492: LIST
7493: LIST
7494: PPUSH
7495: CALL_OW 72
7499: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
7500: LD_ADDR_EXP 22
7504: PUSH
7505: LD_EXP 22
7509: PPUSH
7510: LD_VAR 0 2
7514: PPUSH
7515: LD_VAR 0 3
7519: PPUSH
7520: CALL_OW 1
7524: ST_TO_ADDR
// end ;
7525: GO 7445
7527: POP
7528: POP
// RaiseSailEvent ( 101 ) ;
7529: LD_INT 101
7531: PPUSH
7532: CALL_OW 427
// end ;
7536: LD_VAR 0 1
7540: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
7541: LD_INT 0
7543: PPUSH
7544: PPUSH
7545: PPUSH
7546: PPUSH
7547: PPUSH
7548: PPUSH
7549: PPUSH
// if not mc_bases then
7550: LD_EXP 21
7554: NOT
7555: IFFALSE 7559
// exit ;
7557: GO 8094
// for i = 1 to mc_bases do
7559: LD_ADDR_VAR 0 2
7563: PUSH
7564: DOUBLE
7565: LD_INT 1
7567: DEC
7568: ST_TO_ADDR
7569: LD_EXP 21
7573: PUSH
7574: FOR_TO
7575: IFFALSE 8085
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 700 ] ] ] ] ) ;
7577: LD_ADDR_VAR 0 5
7581: PUSH
7582: LD_EXP 21
7586: PUSH
7587: LD_VAR 0 2
7591: ARRAY
7592: PUSH
7593: LD_EXP 50
7597: PUSH
7598: LD_VAR 0 2
7602: ARRAY
7603: UNION
7604: PPUSH
7605: LD_INT 21
7607: PUSH
7608: LD_INT 1
7610: PUSH
7611: EMPTY
7612: LIST
7613: LIST
7614: PUSH
7615: LD_INT 1
7617: PUSH
7618: LD_INT 3
7620: PUSH
7621: LD_INT 54
7623: PUSH
7624: EMPTY
7625: LIST
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: LD_INT 3
7633: PUSH
7634: LD_INT 24
7636: PUSH
7637: LD_INT 700
7639: PUSH
7640: EMPTY
7641: LIST
7642: LIST
7643: PUSH
7644: EMPTY
7645: LIST
7646: LIST
7647: PUSH
7648: EMPTY
7649: LIST
7650: LIST
7651: LIST
7652: PUSH
7653: EMPTY
7654: LIST
7655: LIST
7656: PPUSH
7657: CALL_OW 72
7661: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
7662: LD_ADDR_VAR 0 6
7666: PUSH
7667: LD_EXP 21
7671: PUSH
7672: LD_VAR 0 2
7676: ARRAY
7677: PPUSH
7678: LD_INT 21
7680: PUSH
7681: LD_INT 1
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 1
7690: PUSH
7691: LD_INT 3
7693: PUSH
7694: LD_INT 54
7696: PUSH
7697: EMPTY
7698: LIST
7699: PUSH
7700: EMPTY
7701: LIST
7702: LIST
7703: PUSH
7704: LD_INT 3
7706: PUSH
7707: LD_INT 24
7709: PUSH
7710: LD_INT 250
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: PUSH
7721: EMPTY
7722: LIST
7723: LIST
7724: LIST
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PPUSH
7730: CALL_OW 72
7734: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
7735: LD_ADDR_VAR 0 7
7739: PUSH
7740: LD_VAR 0 5
7744: PUSH
7745: LD_VAR 0 6
7749: DIFF
7750: ST_TO_ADDR
// if not need_heal_1 then
7751: LD_VAR 0 6
7755: NOT
7756: IFFALSE 7789
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , [ ] ) else
7758: LD_ADDR_EXP 24
7762: PUSH
7763: LD_EXP 24
7767: PPUSH
7768: LD_VAR 0 2
7772: PUSH
7773: LD_INT 1
7775: PUSH
7776: EMPTY
7777: LIST
7778: LIST
7779: PPUSH
7780: EMPTY
7781: PPUSH
7782: CALL 35208 0 3
7786: ST_TO_ADDR
7787: GO 7821
// mc_need_heal := Add ( mc_need_heal , [ i , 1 ] , need_heal_1 ) ;
7789: LD_ADDR_EXP 24
7793: PUSH
7794: LD_EXP 24
7798: PPUSH
7799: LD_VAR 0 2
7803: PUSH
7804: LD_INT 1
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PPUSH
7811: LD_VAR 0 6
7815: PPUSH
7816: CALL 35208 0 3
7820: ST_TO_ADDR
// if not need_heal_2 then
7821: LD_VAR 0 7
7825: NOT
7826: IFFALSE 7859
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , [ ] ) else
7828: LD_ADDR_EXP 24
7832: PUSH
7833: LD_EXP 24
7837: PPUSH
7838: LD_VAR 0 2
7842: PUSH
7843: LD_INT 2
7845: PUSH
7846: EMPTY
7847: LIST
7848: LIST
7849: PPUSH
7850: EMPTY
7851: PPUSH
7852: CALL 35208 0 3
7856: ST_TO_ADDR
7857: GO 7891
// mc_need_heal := Add ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
7859: LD_ADDR_EXP 24
7863: PUSH
7864: LD_EXP 24
7868: PPUSH
7869: LD_VAR 0 2
7873: PUSH
7874: LD_INT 2
7876: PUSH
7877: EMPTY
7878: LIST
7879: LIST
7880: PPUSH
7881: LD_VAR 0 7
7885: PPUSH
7886: CALL 35208 0 3
7890: ST_TO_ADDR
// if need_heal_2 then
7891: LD_VAR 0 7
7895: IFFALSE 8067
// for j in need_heal_2 do
7897: LD_ADDR_VAR 0 3
7901: PUSH
7902: LD_VAR 0 7
7906: PUSH
7907: FOR_IN
7908: IFFALSE 8065
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
7910: LD_ADDR_VAR 0 5
7914: PUSH
7915: LD_EXP 21
7919: PUSH
7920: LD_VAR 0 2
7924: ARRAY
7925: PPUSH
7926: LD_INT 2
7928: PUSH
7929: LD_INT 30
7931: PUSH
7932: LD_INT 6
7934: PUSH
7935: EMPTY
7936: LIST
7937: LIST
7938: PUSH
7939: LD_INT 30
7941: PUSH
7942: LD_INT 7
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PUSH
7949: LD_INT 30
7951: PUSH
7952: LD_INT 8
7954: PUSH
7955: EMPTY
7956: LIST
7957: LIST
7958: PUSH
7959: LD_INT 30
7961: PUSH
7962: LD_INT 0
7964: PUSH
7965: EMPTY
7966: LIST
7967: LIST
7968: PUSH
7969: LD_INT 30
7971: PUSH
7972: LD_INT 1
7974: PUSH
7975: EMPTY
7976: LIST
7977: LIST
7978: PUSH
7979: LD_INT 25
7981: PUSH
7982: LD_INT 4
7984: PUSH
7985: EMPTY
7986: LIST
7987: LIST
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: LIST
7993: LIST
7994: LIST
7995: LIST
7996: LIST
7997: PPUSH
7998: CALL_OW 72
8002: ST_TO_ADDR
// if tmp then
8003: LD_VAR 0 5
8007: IFFALSE 8063
// begin k := NearestUnitToUnit ( tmp , j ) ;
8009: LD_ADDR_VAR 0 4
8013: PUSH
8014: LD_VAR 0 5
8018: PPUSH
8019: LD_VAR 0 3
8023: PPUSH
8024: CALL_OW 74
8028: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
8029: LD_VAR 0 3
8033: PPUSH
8034: LD_VAR 0 4
8038: PPUSH
8039: CALL_OW 296
8043: PUSH
8044: LD_INT 7
8046: GREATER
8047: IFFALSE 8063
// ComMoveUnit ( j , k ) ;
8049: LD_VAR 0 3
8053: PPUSH
8054: LD_VAR 0 4
8058: PPUSH
8059: CALL_OW 112
// end ; end ;
8063: GO 7907
8065: POP
8066: POP
// if not need_heal_1 and not need_heal_2 then
8067: LD_VAR 0 6
8071: NOT
8072: PUSH
8073: LD_VAR 0 7
8077: NOT
8078: AND
8079: IFFALSE 8083
// continue ;
8081: GO 7574
// end ;
8083: GO 7574
8085: POP
8086: POP
// RaiseSailEvent ( 102 ) ;
8087: LD_INT 102
8089: PPUSH
8090: CALL_OW 427
// end ;
8094: LD_VAR 0 1
8098: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
8099: LD_INT 0
8101: PPUSH
8102: PPUSH
8103: PPUSH
8104: PPUSH
8105: PPUSH
// if not mc_bases then
8106: LD_EXP 21
8110: NOT
8111: IFFALSE 8115
// exit ;
8113: GO 8500
// for i = 1 to mc_bases do
8115: LD_ADDR_VAR 0 2
8119: PUSH
8120: DOUBLE
8121: LD_INT 1
8123: DEC
8124: ST_TO_ADDR
8125: LD_EXP 21
8129: PUSH
8130: FOR_TO
8131: IFFALSE 8498
// begin if not mc_building_need_repair [ i ] then
8133: LD_EXP 22
8137: PUSH
8138: LD_VAR 0 2
8142: ARRAY
8143: NOT
8144: IFFALSE 8182
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
8146: LD_ADDR_EXP 23
8150: PUSH
8151: LD_EXP 23
8155: PPUSH
8156: LD_VAR 0 2
8160: PPUSH
8161: EMPTY
8162: PPUSH
8163: CALL_OW 1
8167: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
8168: LD_VAR 0 2
8172: PPUSH
8173: LD_INT 101
8175: PPUSH
8176: CALL 3581 0 2
// continue ;
8180: GO 8130
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
8182: LD_ADDR_EXP 27
8186: PUSH
8187: LD_EXP 27
8191: PPUSH
8192: LD_VAR 0 2
8196: PPUSH
8197: EMPTY
8198: PPUSH
8199: CALL_OW 1
8203: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
8204: LD_VAR 0 2
8208: PPUSH
8209: LD_INT 103
8211: PPUSH
8212: CALL 3581 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
8216: LD_ADDR_VAR 0 5
8220: PUSH
8221: LD_EXP 21
8225: PUSH
8226: LD_VAR 0 2
8230: ARRAY
8231: PUSH
8232: LD_EXP 50
8236: PUSH
8237: LD_VAR 0 2
8241: ARRAY
8242: UNION
8243: PPUSH
8244: LD_INT 2
8246: PUSH
8247: LD_INT 25
8249: PUSH
8250: LD_INT 2
8252: PUSH
8253: EMPTY
8254: LIST
8255: LIST
8256: PUSH
8257: LD_INT 25
8259: PUSH
8260: LD_INT 16
8262: PUSH
8263: EMPTY
8264: LIST
8265: LIST
8266: PUSH
8267: EMPTY
8268: LIST
8269: LIST
8270: LIST
8271: PUSH
8272: EMPTY
8273: LIST
8274: PPUSH
8275: CALL_OW 72
8279: ST_TO_ADDR
// if not tmp then
8280: LD_VAR 0 5
8284: NOT
8285: IFFALSE 8289
// continue ;
8287: GO 8130
// for j in tmp do
8289: LD_ADDR_VAR 0 3
8293: PUSH
8294: LD_VAR 0 5
8298: PUSH
8299: FOR_IN
8300: IFFALSE 8494
// begin if mc_need_heal [ i ] then
8302: LD_EXP 24
8306: PUSH
8307: LD_VAR 0 2
8311: ARRAY
8312: IFFALSE 8360
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
8314: LD_VAR 0 3
8318: PUSH
8319: LD_EXP 24
8323: PUSH
8324: LD_VAR 0 2
8328: ARRAY
8329: PUSH
8330: LD_INT 1
8332: ARRAY
8333: IN
8334: PUSH
8335: LD_VAR 0 3
8339: PUSH
8340: LD_EXP 24
8344: PUSH
8345: LD_VAR 0 2
8349: ARRAY
8350: PUSH
8351: LD_INT 2
8353: ARRAY
8354: IN
8355: OR
8356: IFFALSE 8360
// continue ;
8358: GO 8299
// if IsInUnit ( j ) then
8360: LD_VAR 0 3
8364: PPUSH
8365: CALL_OW 310
8369: IFFALSE 8380
// ComExitBuilding ( j ) ;
8371: LD_VAR 0 3
8375: PPUSH
8376: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
8380: LD_VAR 0 3
8384: PUSH
8385: LD_EXP 23
8389: PUSH
8390: LD_VAR 0 2
8394: ARRAY
8395: IN
8396: NOT
8397: IFFALSE 8455
// begin SetTag ( j , 101 ) ;
8399: LD_VAR 0 3
8403: PPUSH
8404: LD_INT 101
8406: PPUSH
8407: CALL_OW 109
// mc_building_repairs := Add ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
8411: LD_ADDR_EXP 23
8415: PUSH
8416: LD_EXP 23
8420: PPUSH
8421: LD_VAR 0 2
8425: PUSH
8426: LD_EXP 23
8430: PUSH
8431: LD_VAR 0 2
8435: ARRAY
8436: PUSH
8437: LD_INT 1
8439: PLUS
8440: PUSH
8441: EMPTY
8442: LIST
8443: LIST
8444: PPUSH
8445: LD_VAR 0 3
8449: PPUSH
8450: CALL 35208 0 3
8454: ST_TO_ADDR
// end ; Wait ( 3 ) ;
8455: LD_INT 3
8457: PPUSH
8458: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
8462: LD_VAR 0 3
8466: PPUSH
8467: LD_EXP 22
8471: PUSH
8472: LD_VAR 0 2
8476: ARRAY
8477: PPUSH
8478: LD_VAR 0 3
8482: PPUSH
8483: CALL_OW 74
8487: PPUSH
8488: CALL_OW 130
// end ;
8492: GO 8299
8494: POP
8495: POP
// end ;
8496: GO 8130
8498: POP
8499: POP
// end ;
8500: LD_VAR 0 1
8504: RET
// export function MC_Heal ; var i , j , tmp ; begin
8505: LD_INT 0
8507: PPUSH
8508: PPUSH
8509: PPUSH
8510: PPUSH
// if not mc_bases then
8511: LD_EXP 21
8515: NOT
8516: IFFALSE 8520
// exit ;
8518: GO 8922
// for i = 1 to mc_bases do
8520: LD_ADDR_VAR 0 2
8524: PUSH
8525: DOUBLE
8526: LD_INT 1
8528: DEC
8529: ST_TO_ADDR
8530: LD_EXP 21
8534: PUSH
8535: FOR_TO
8536: IFFALSE 8920
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
8538: LD_EXP 24
8542: PUSH
8543: LD_VAR 0 2
8547: ARRAY
8548: PUSH
8549: LD_INT 1
8551: ARRAY
8552: NOT
8553: PUSH
8554: LD_EXP 24
8558: PUSH
8559: LD_VAR 0 2
8563: ARRAY
8564: PUSH
8565: LD_INT 2
8567: ARRAY
8568: NOT
8569: AND
8570: IFFALSE 8608
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
8572: LD_ADDR_EXP 25
8576: PUSH
8577: LD_EXP 25
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: EMPTY
8588: PPUSH
8589: CALL_OW 1
8593: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
8594: LD_VAR 0 2
8598: PPUSH
8599: LD_INT 102
8601: PPUSH
8602: CALL 3581 0 2
// continue ;
8606: GO 8535
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
8608: LD_ADDR_VAR 0 4
8612: PUSH
8613: LD_EXP 21
8617: PUSH
8618: LD_VAR 0 2
8622: ARRAY
8623: PPUSH
8624: LD_INT 25
8626: PUSH
8627: LD_INT 4
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: PPUSH
8634: CALL_OW 72
8638: ST_TO_ADDR
// if not tmp then
8639: LD_VAR 0 4
8643: NOT
8644: IFFALSE 8648
// continue ;
8646: GO 8535
// if mc_taming [ i ] then
8648: LD_EXP 52
8652: PUSH
8653: LD_VAR 0 2
8657: ARRAY
8658: IFFALSE 8682
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
8660: LD_ADDR_EXP 52
8664: PUSH
8665: LD_EXP 52
8669: PPUSH
8670: LD_VAR 0 2
8674: PPUSH
8675: EMPTY
8676: PPUSH
8677: CALL_OW 1
8681: ST_TO_ADDR
// for j in tmp do
8682: LD_ADDR_VAR 0 3
8686: PUSH
8687: LD_VAR 0 4
8691: PUSH
8692: FOR_IN
8693: IFFALSE 8916
// begin if IsInUnit ( j ) then
8695: LD_VAR 0 3
8699: PPUSH
8700: CALL_OW 310
8704: IFFALSE 8715
// ComExitBuilding ( j ) ;
8706: LD_VAR 0 3
8710: PPUSH
8711: CALL_OW 122
// if not j in mc_healers [ i ] then
8715: LD_VAR 0 3
8719: PUSH
8720: LD_EXP 25
8724: PUSH
8725: LD_VAR 0 2
8729: ARRAY
8730: IN
8731: NOT
8732: IFFALSE 8778
// mc_healers := Add ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
8734: LD_ADDR_EXP 25
8738: PUSH
8739: LD_EXP 25
8743: PPUSH
8744: LD_VAR 0 2
8748: PUSH
8749: LD_EXP 25
8753: PUSH
8754: LD_VAR 0 2
8758: ARRAY
8759: PUSH
8760: LD_INT 1
8762: PLUS
8763: PUSH
8764: EMPTY
8765: LIST
8766: LIST
8767: PPUSH
8768: LD_VAR 0 3
8772: PPUSH
8773: CALL 35208 0 3
8777: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
8778: LD_VAR 0 3
8782: PPUSH
8783: CALL_OW 110
8787: PUSH
8788: LD_INT 102
8790: NONEQUAL
8791: IFFALSE 8805
// SetTag ( j , 102 ) ;
8793: LD_VAR 0 3
8797: PPUSH
8798: LD_INT 102
8800: PPUSH
8801: CALL_OW 109
// Wait ( 3 ) ;
8805: LD_INT 3
8807: PPUSH
8808: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
8812: LD_EXP 24
8816: PUSH
8817: LD_VAR 0 2
8821: ARRAY
8822: PUSH
8823: LD_INT 1
8825: ARRAY
8826: IFFALSE 8858
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
8828: LD_VAR 0 3
8832: PPUSH
8833: LD_EXP 24
8837: PUSH
8838: LD_VAR 0 2
8842: ARRAY
8843: PUSH
8844: LD_INT 1
8846: ARRAY
8847: PUSH
8848: LD_INT 1
8850: ARRAY
8851: PPUSH
8852: CALL_OW 128
8856: GO 8914
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
8858: LD_VAR 0 3
8862: PPUSH
8863: CALL_OW 314
8867: NOT
8868: PUSH
8869: LD_EXP 24
8873: PUSH
8874: LD_VAR 0 2
8878: ARRAY
8879: PUSH
8880: LD_INT 2
8882: ARRAY
8883: AND
8884: IFFALSE 8914
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
8886: LD_VAR 0 3
8890: PPUSH
8891: LD_EXP 24
8895: PUSH
8896: LD_VAR 0 2
8900: ARRAY
8901: PUSH
8902: LD_INT 2
8904: ARRAY
8905: PUSH
8906: LD_INT 1
8908: ARRAY
8909: PPUSH
8910: CALL_OW 128
// end ;
8914: GO 8692
8916: POP
8917: POP
// end ;
8918: GO 8535
8920: POP
8921: POP
// end ;
8922: LD_VAR 0 1
8926: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
8927: LD_INT 0
8929: PPUSH
8930: PPUSH
8931: PPUSH
8932: PPUSH
8933: PPUSH
// if not mc_bases then
8934: LD_EXP 21
8938: NOT
8939: IFFALSE 8943
// exit ;
8941: GO 10086
// for i = 1 to mc_bases do
8943: LD_ADDR_VAR 0 2
8947: PUSH
8948: DOUBLE
8949: LD_INT 1
8951: DEC
8952: ST_TO_ADDR
8953: LD_EXP 21
8957: PUSH
8958: FOR_TO
8959: IFFALSE 10084
// begin if mc_scan [ i ] then
8961: LD_EXP 44
8965: PUSH
8966: LD_VAR 0 2
8970: ARRAY
8971: IFFALSE 8975
// continue ;
8973: GO 8958
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
8975: LD_EXP 26
8979: PUSH
8980: LD_VAR 0 2
8984: ARRAY
8985: NOT
8986: PUSH
8987: LD_EXP 28
8991: PUSH
8992: LD_VAR 0 2
8996: ARRAY
8997: NOT
8998: AND
8999: PUSH
9000: LD_EXP 27
9004: PUSH
9005: LD_VAR 0 2
9009: ARRAY
9010: AND
9011: IFFALSE 9049
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
9013: LD_ADDR_EXP 27
9017: PUSH
9018: LD_EXP 27
9022: PPUSH
9023: LD_VAR 0 2
9027: PPUSH
9028: EMPTY
9029: PPUSH
9030: CALL_OW 1
9034: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
9035: LD_VAR 0 2
9039: PPUSH
9040: LD_INT 103
9042: PPUSH
9043: CALL 3581 0 2
// continue ;
9047: GO 8958
// end ; if mc_construct_list [ i ] then
9049: LD_EXP 28
9053: PUSH
9054: LD_VAR 0 2
9058: ARRAY
9059: IFFALSE 9279
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
9061: LD_ADDR_VAR 0 4
9065: PUSH
9066: LD_EXP 21
9070: PUSH
9071: LD_VAR 0 2
9075: ARRAY
9076: PPUSH
9077: LD_INT 25
9079: PUSH
9080: LD_INT 2
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PPUSH
9087: CALL_OW 72
9091: PUSH
9092: LD_EXP 23
9096: PUSH
9097: LD_VAR 0 2
9101: ARRAY
9102: DIFF
9103: ST_TO_ADDR
// if not tmp then
9104: LD_VAR 0 4
9108: NOT
9109: IFFALSE 9113
// continue ;
9111: GO 8958
// for j in tmp do
9113: LD_ADDR_VAR 0 3
9117: PUSH
9118: LD_VAR 0 4
9122: PUSH
9123: FOR_IN
9124: IFFALSE 9275
// begin if not mc_builders [ i ] then
9126: LD_EXP 27
9130: PUSH
9131: LD_VAR 0 2
9135: ARRAY
9136: NOT
9137: IFFALSE 9195
// begin SetTag ( j , 103 ) ;
9139: LD_VAR 0 3
9143: PPUSH
9144: LD_INT 103
9146: PPUSH
9147: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
9151: LD_ADDR_EXP 27
9155: PUSH
9156: LD_EXP 27
9160: PPUSH
9161: LD_VAR 0 2
9165: PUSH
9166: LD_EXP 27
9170: PUSH
9171: LD_VAR 0 2
9175: ARRAY
9176: PUSH
9177: LD_INT 1
9179: PLUS
9180: PUSH
9181: EMPTY
9182: LIST
9183: LIST
9184: PPUSH
9185: LD_VAR 0 3
9189: PPUSH
9190: CALL 35208 0 3
9194: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
9195: LD_VAR 0 3
9199: PPUSH
9200: CALL_OW 310
9204: IFFALSE 9215
// ComExitBuilding ( j ) ;
9206: LD_VAR 0 3
9210: PPUSH
9211: CALL_OW 122
// wait ( 3 ) ;
9215: LD_INT 3
9217: PPUSH
9218: CALL_OW 67
// if not mc_construct_list [ i ] then
9222: LD_EXP 28
9226: PUSH
9227: LD_VAR 0 2
9231: ARRAY
9232: NOT
9233: IFFALSE 9237
// break ;
9235: GO 9275
// if not HasTask ( j ) then
9237: LD_VAR 0 3
9241: PPUSH
9242: CALL_OW 314
9246: NOT
9247: IFFALSE 9273
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
9249: LD_VAR 0 3
9253: PPUSH
9254: LD_EXP 28
9258: PUSH
9259: LD_VAR 0 2
9263: ARRAY
9264: PUSH
9265: LD_INT 1
9267: ARRAY
9268: PPUSH
9269: CALL 37657 0 2
// end ;
9273: GO 9123
9275: POP
9276: POP
// end else
9277: GO 10082
// if mc_build_list [ i ] then
9279: LD_EXP 26
9283: PUSH
9284: LD_VAR 0 2
9288: ARRAY
9289: IFFALSE 10082
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
9291: LD_ADDR_VAR 0 5
9295: PUSH
9296: LD_EXP 21
9300: PUSH
9301: LD_VAR 0 2
9305: ARRAY
9306: PPUSH
9307: LD_INT 2
9309: PUSH
9310: LD_INT 30
9312: PUSH
9313: LD_INT 0
9315: PUSH
9316: EMPTY
9317: LIST
9318: LIST
9319: PUSH
9320: LD_INT 30
9322: PUSH
9323: LD_INT 1
9325: PUSH
9326: EMPTY
9327: LIST
9328: LIST
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: LIST
9334: PPUSH
9335: CALL_OW 72
9339: ST_TO_ADDR
// if depot then
9340: LD_VAR 0 5
9344: IFFALSE 9362
// depot := depot [ 1 ] else
9346: LD_ADDR_VAR 0 5
9350: PUSH
9351: LD_VAR 0 5
9355: PUSH
9356: LD_INT 1
9358: ARRAY
9359: ST_TO_ADDR
9360: GO 9370
// depot := 0 ;
9362: LD_ADDR_VAR 0 5
9366: PUSH
9367: LD_INT 0
9369: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
9370: LD_EXP 26
9374: PUSH
9375: LD_VAR 0 2
9379: ARRAY
9380: PUSH
9381: LD_INT 1
9383: ARRAY
9384: PUSH
9385: LD_INT 1
9387: ARRAY
9388: PPUSH
9389: CALL 37487 0 1
9393: PUSH
9394: LD_EXP 21
9398: PUSH
9399: LD_VAR 0 2
9403: ARRAY
9404: PPUSH
9405: LD_INT 2
9407: PUSH
9408: LD_INT 30
9410: PUSH
9411: LD_INT 2
9413: PUSH
9414: EMPTY
9415: LIST
9416: LIST
9417: PUSH
9418: LD_INT 30
9420: PUSH
9421: LD_INT 3
9423: PUSH
9424: EMPTY
9425: LIST
9426: LIST
9427: PUSH
9428: EMPTY
9429: LIST
9430: LIST
9431: LIST
9432: PPUSH
9433: CALL_OW 72
9437: NOT
9438: AND
9439: IFFALSE 9544
// begin for j = 1 to mc_build_list [ i ] do
9441: LD_ADDR_VAR 0 3
9445: PUSH
9446: DOUBLE
9447: LD_INT 1
9449: DEC
9450: ST_TO_ADDR
9451: LD_EXP 26
9455: PUSH
9456: LD_VAR 0 2
9460: ARRAY
9461: PUSH
9462: FOR_TO
9463: IFFALSE 9542
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
9465: LD_EXP 26
9469: PUSH
9470: LD_VAR 0 2
9474: ARRAY
9475: PUSH
9476: LD_VAR 0 3
9480: ARRAY
9481: PUSH
9482: LD_INT 1
9484: ARRAY
9485: PUSH
9486: LD_INT 2
9488: EQUAL
9489: IFFALSE 9540
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
9491: LD_ADDR_EXP 26
9495: PUSH
9496: LD_EXP 26
9500: PPUSH
9501: LD_VAR 0 2
9505: PPUSH
9506: LD_EXP 26
9510: PUSH
9511: LD_VAR 0 2
9515: ARRAY
9516: PPUSH
9517: LD_VAR 0 3
9521: PPUSH
9522: LD_INT 1
9524: PPUSH
9525: LD_INT 0
9527: PPUSH
9528: CALL 34191 0 4
9532: PPUSH
9533: CALL_OW 1
9537: ST_TO_ADDR
// break ;
9538: GO 9542
// end ;
9540: GO 9462
9542: POP
9543: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
9544: LD_EXP 26
9548: PUSH
9549: LD_VAR 0 2
9553: ARRAY
9554: PUSH
9555: LD_INT 1
9557: ARRAY
9558: PUSH
9559: LD_INT 1
9561: ARRAY
9562: PUSH
9563: LD_INT 0
9565: EQUAL
9566: PUSH
9567: LD_VAR 0 5
9571: PUSH
9572: LD_VAR 0 5
9576: PPUSH
9577: LD_EXP 26
9581: PUSH
9582: LD_VAR 0 2
9586: ARRAY
9587: PUSH
9588: LD_INT 1
9590: ARRAY
9591: PUSH
9592: LD_INT 1
9594: ARRAY
9595: PPUSH
9596: LD_EXP 26
9600: PUSH
9601: LD_VAR 0 2
9605: ARRAY
9606: PUSH
9607: LD_INT 1
9609: ARRAY
9610: PUSH
9611: LD_INT 2
9613: ARRAY
9614: PPUSH
9615: LD_EXP 26
9619: PUSH
9620: LD_VAR 0 2
9624: ARRAY
9625: PUSH
9626: LD_INT 1
9628: ARRAY
9629: PUSH
9630: LD_INT 3
9632: ARRAY
9633: PPUSH
9634: LD_EXP 26
9638: PUSH
9639: LD_VAR 0 2
9643: ARRAY
9644: PUSH
9645: LD_INT 1
9647: ARRAY
9648: PUSH
9649: LD_INT 4
9651: ARRAY
9652: PPUSH
9653: CALL 42024 0 5
9657: AND
9658: OR
9659: IFFALSE 9940
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
9661: LD_ADDR_VAR 0 4
9665: PUSH
9666: LD_EXP 21
9670: PUSH
9671: LD_VAR 0 2
9675: ARRAY
9676: PPUSH
9677: LD_INT 25
9679: PUSH
9680: LD_INT 2
9682: PUSH
9683: EMPTY
9684: LIST
9685: LIST
9686: PPUSH
9687: CALL_OW 72
9691: PUSH
9692: LD_EXP 23
9696: PUSH
9697: LD_VAR 0 2
9701: ARRAY
9702: DIFF
9703: ST_TO_ADDR
// if not tmp then
9704: LD_VAR 0 4
9708: NOT
9709: IFFALSE 9713
// continue ;
9711: GO 8958
// for j in tmp do
9713: LD_ADDR_VAR 0 3
9717: PUSH
9718: LD_VAR 0 4
9722: PUSH
9723: FOR_IN
9724: IFFALSE 9936
// begin if not mc_builders [ i ] then
9726: LD_EXP 27
9730: PUSH
9731: LD_VAR 0 2
9735: ARRAY
9736: NOT
9737: IFFALSE 9795
// begin SetTag ( j , 103 ) ;
9739: LD_VAR 0 3
9743: PPUSH
9744: LD_INT 103
9746: PPUSH
9747: CALL_OW 109
// mc_builders := Add ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
9751: LD_ADDR_EXP 27
9755: PUSH
9756: LD_EXP 27
9760: PPUSH
9761: LD_VAR 0 2
9765: PUSH
9766: LD_EXP 27
9770: PUSH
9771: LD_VAR 0 2
9775: ARRAY
9776: PUSH
9777: LD_INT 1
9779: PLUS
9780: PUSH
9781: EMPTY
9782: LIST
9783: LIST
9784: PPUSH
9785: LD_VAR 0 3
9789: PPUSH
9790: CALL 35208 0 3
9794: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
9795: LD_VAR 0 3
9799: PPUSH
9800: CALL_OW 310
9804: IFFALSE 9815
// ComExitBuilding ( j ) ;
9806: LD_VAR 0 3
9810: PPUSH
9811: CALL_OW 122
// wait ( 3 ) ;
9815: LD_INT 3
9817: PPUSH
9818: CALL_OW 67
// if not mc_build_list [ i ] then
9822: LD_EXP 26
9826: PUSH
9827: LD_VAR 0 2
9831: ARRAY
9832: NOT
9833: IFFALSE 9837
// break ;
9835: GO 9936
// if not HasTask ( j ) then
9837: LD_VAR 0 3
9841: PPUSH
9842: CALL_OW 314
9846: NOT
9847: IFFALSE 9934
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
9849: LD_VAR 0 3
9853: PPUSH
9854: LD_EXP 26
9858: PUSH
9859: LD_VAR 0 2
9863: ARRAY
9864: PUSH
9865: LD_INT 1
9867: ARRAY
9868: PUSH
9869: LD_INT 1
9871: ARRAY
9872: PPUSH
9873: LD_EXP 26
9877: PUSH
9878: LD_VAR 0 2
9882: ARRAY
9883: PUSH
9884: LD_INT 1
9886: ARRAY
9887: PUSH
9888: LD_INT 2
9890: ARRAY
9891: PPUSH
9892: LD_EXP 26
9896: PUSH
9897: LD_VAR 0 2
9901: ARRAY
9902: PUSH
9903: LD_INT 1
9905: ARRAY
9906: PUSH
9907: LD_INT 3
9909: ARRAY
9910: PPUSH
9911: LD_EXP 26
9915: PUSH
9916: LD_VAR 0 2
9920: ARRAY
9921: PUSH
9922: LD_INT 1
9924: ARRAY
9925: PUSH
9926: LD_INT 4
9928: ARRAY
9929: PPUSH
9930: CALL_OW 145
// end ;
9934: GO 9723
9936: POP
9937: POP
// end else
9938: GO 10082
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
9940: LD_EXP 21
9944: PUSH
9945: LD_VAR 0 2
9949: ARRAY
9950: PPUSH
9951: LD_EXP 26
9955: PUSH
9956: LD_VAR 0 2
9960: ARRAY
9961: PUSH
9962: LD_INT 1
9964: ARRAY
9965: PUSH
9966: LD_INT 1
9968: ARRAY
9969: PPUSH
9970: LD_EXP 26
9974: PUSH
9975: LD_VAR 0 2
9979: ARRAY
9980: PUSH
9981: LD_INT 1
9983: ARRAY
9984: PUSH
9985: LD_INT 2
9987: ARRAY
9988: PPUSH
9989: LD_EXP 26
9993: PUSH
9994: LD_VAR 0 2
9998: ARRAY
9999: PUSH
10000: LD_INT 1
10002: ARRAY
10003: PUSH
10004: LD_INT 3
10006: ARRAY
10007: PPUSH
10008: LD_EXP 26
10012: PUSH
10013: LD_VAR 0 2
10017: ARRAY
10018: PUSH
10019: LD_INT 1
10021: ARRAY
10022: PUSH
10023: LD_INT 4
10025: ARRAY
10026: PPUSH
10027: CALL 41455 0 5
10031: NOT
10032: IFFALSE 10082
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
10034: LD_ADDR_EXP 26
10038: PUSH
10039: LD_EXP 26
10043: PPUSH
10044: LD_VAR 0 2
10048: PPUSH
10049: LD_EXP 26
10053: PUSH
10054: LD_VAR 0 2
10058: ARRAY
10059: PPUSH
10060: LD_INT 1
10062: PPUSH
10063: LD_INT 1
10065: NEG
10066: PPUSH
10067: LD_INT 0
10069: PPUSH
10070: CALL 34191 0 4
10074: PPUSH
10075: CALL_OW 1
10079: ST_TO_ADDR
// continue ;
10080: GO 8958
// end ; end ; end ;
10082: GO 8958
10084: POP
10085: POP
// end ;
10086: LD_VAR 0 1
10090: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
10091: LD_INT 0
10093: PPUSH
10094: PPUSH
10095: PPUSH
10096: PPUSH
10097: PPUSH
10098: PPUSH
// if not mc_bases then
10099: LD_EXP 21
10103: NOT
10104: IFFALSE 10108
// exit ;
10106: GO 10535
// for i = 1 to mc_bases do
10108: LD_ADDR_VAR 0 2
10112: PUSH
10113: DOUBLE
10114: LD_INT 1
10116: DEC
10117: ST_TO_ADDR
10118: LD_EXP 21
10122: PUSH
10123: FOR_TO
10124: IFFALSE 10533
// begin tmp := mc_build_upgrade [ i ] ;
10126: LD_ADDR_VAR 0 4
10130: PUSH
10131: LD_EXP 53
10135: PUSH
10136: LD_VAR 0 2
10140: ARRAY
10141: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
10142: LD_ADDR_VAR 0 6
10146: PUSH
10147: LD_EXP 54
10151: PUSH
10152: LD_VAR 0 2
10156: ARRAY
10157: PPUSH
10158: LD_INT 2
10160: PUSH
10161: LD_INT 30
10163: PUSH
10164: LD_INT 6
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 30
10173: PUSH
10174: LD_INT 7
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: PUSH
10181: EMPTY
10182: LIST
10183: LIST
10184: LIST
10185: PPUSH
10186: CALL_OW 72
10190: ST_TO_ADDR
// if not tmp and not lab then
10191: LD_VAR 0 4
10195: NOT
10196: PUSH
10197: LD_VAR 0 6
10201: NOT
10202: AND
10203: IFFALSE 10207
// continue ;
10205: GO 10123
// if tmp then
10207: LD_VAR 0 4
10211: IFFALSE 10331
// for j in tmp do
10213: LD_ADDR_VAR 0 3
10217: PUSH
10218: LD_VAR 0 4
10222: PUSH
10223: FOR_IN
10224: IFFALSE 10329
// begin if UpgradeCost ( j ) then
10226: LD_VAR 0 3
10230: PPUSH
10231: CALL 41115 0 1
10235: IFFALSE 10327
// begin ComUpgrade ( j ) ;
10237: LD_VAR 0 3
10241: PPUSH
10242: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
10246: LD_ADDR_EXP 53
10250: PUSH
10251: LD_EXP 53
10255: PPUSH
10256: LD_VAR 0 2
10260: PPUSH
10261: LD_EXP 53
10265: PUSH
10266: LD_VAR 0 2
10270: ARRAY
10271: PUSH
10272: LD_VAR 0 3
10276: DIFF
10277: PPUSH
10278: CALL_OW 1
10282: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
10283: LD_ADDR_EXP 28
10287: PUSH
10288: LD_EXP 28
10292: PPUSH
10293: LD_VAR 0 2
10297: PUSH
10298: LD_EXP 28
10302: PUSH
10303: LD_VAR 0 2
10307: ARRAY
10308: PUSH
10309: LD_INT 1
10311: PLUS
10312: PUSH
10313: EMPTY
10314: LIST
10315: LIST
10316: PPUSH
10317: LD_VAR 0 3
10321: PPUSH
10322: CALL 35208 0 3
10326: ST_TO_ADDR
// end ; end ;
10327: GO 10223
10329: POP
10330: POP
// if not lab or not mc_lab_upgrade [ i ] then
10331: LD_VAR 0 6
10335: NOT
10336: PUSH
10337: LD_EXP 55
10341: PUSH
10342: LD_VAR 0 2
10346: ARRAY
10347: NOT
10348: OR
10349: IFFALSE 10353
// continue ;
10351: GO 10123
// for j in lab do
10353: LD_ADDR_VAR 0 3
10357: PUSH
10358: LD_VAR 0 6
10362: PUSH
10363: FOR_IN
10364: IFFALSE 10529
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
10366: LD_VAR 0 3
10370: PPUSH
10371: CALL_OW 266
10375: PUSH
10376: LD_INT 6
10378: PUSH
10379: LD_INT 7
10381: PUSH
10382: EMPTY
10383: LIST
10384: LIST
10385: IN
10386: PUSH
10387: LD_VAR 0 3
10391: PPUSH
10392: CALL_OW 461
10396: PUSH
10397: LD_INT 1
10399: NONEQUAL
10400: AND
10401: IFFALSE 10527
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
10403: LD_VAR 0 3
10407: PPUSH
10408: LD_EXP 55
10412: PUSH
10413: LD_VAR 0 2
10417: ARRAY
10418: PUSH
10419: LD_INT 1
10421: ARRAY
10422: PPUSH
10423: CALL 41320 0 2
10427: IFFALSE 10527
// begin ComCancel ( j ) ;
10429: LD_VAR 0 3
10433: PPUSH
10434: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
10438: LD_VAR 0 3
10442: PPUSH
10443: LD_EXP 55
10447: PUSH
10448: LD_VAR 0 2
10452: ARRAY
10453: PUSH
10454: LD_INT 1
10456: ARRAY
10457: PPUSH
10458: CALL_OW 207
// if not j in mc_construct_list [ i ] then
10462: LD_VAR 0 3
10466: PUSH
10467: LD_EXP 28
10471: PUSH
10472: LD_VAR 0 2
10476: ARRAY
10477: IN
10478: NOT
10479: IFFALSE 10525
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
10481: LD_ADDR_EXP 28
10485: PUSH
10486: LD_EXP 28
10490: PPUSH
10491: LD_VAR 0 2
10495: PUSH
10496: LD_EXP 28
10500: PUSH
10501: LD_VAR 0 2
10505: ARRAY
10506: PUSH
10507: LD_INT 1
10509: PLUS
10510: PUSH
10511: EMPTY
10512: LIST
10513: LIST
10514: PPUSH
10515: LD_VAR 0 3
10519: PPUSH
10520: CALL 35208 0 3
10524: ST_TO_ADDR
// break ;
10525: GO 10529
// end ; end ; end ;
10527: GO 10363
10529: POP
10530: POP
// end ;
10531: GO 10123
10533: POP
10534: POP
// end ;
10535: LD_VAR 0 1
10539: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
10540: LD_INT 0
10542: PPUSH
10543: PPUSH
10544: PPUSH
10545: PPUSH
10546: PPUSH
10547: PPUSH
10548: PPUSH
10549: PPUSH
10550: PPUSH
// if not mc_bases then
10551: LD_EXP 21
10555: NOT
10556: IFFALSE 10560
// exit ;
10558: GO 10965
// for i = 1 to mc_bases do
10560: LD_ADDR_VAR 0 2
10564: PUSH
10565: DOUBLE
10566: LD_INT 1
10568: DEC
10569: ST_TO_ADDR
10570: LD_EXP 21
10574: PUSH
10575: FOR_TO
10576: IFFALSE 10963
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
10578: LD_EXP 29
10582: PUSH
10583: LD_VAR 0 2
10587: ARRAY
10588: NOT
10589: PUSH
10590: LD_EXP 21
10594: PUSH
10595: LD_VAR 0 2
10599: ARRAY
10600: PPUSH
10601: LD_INT 30
10603: PUSH
10604: LD_INT 3
10606: PUSH
10607: EMPTY
10608: LIST
10609: LIST
10610: PPUSH
10611: CALL_OW 72
10615: NOT
10616: OR
10617: IFFALSE 10621
// continue ;
10619: GO 10575
// busy := false ;
10621: LD_ADDR_VAR 0 8
10625: PUSH
10626: LD_INT 0
10628: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
10629: LD_ADDR_VAR 0 4
10633: PUSH
10634: LD_EXP 21
10638: PUSH
10639: LD_VAR 0 2
10643: ARRAY
10644: PPUSH
10645: LD_INT 30
10647: PUSH
10648: LD_INT 3
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 72
10659: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
10660: LD_ADDR_VAR 0 6
10664: PUSH
10665: LD_EXP 29
10669: PUSH
10670: LD_VAR 0 2
10674: ARRAY
10675: PPUSH
10676: LD_INT 2
10678: PUSH
10679: LD_INT 30
10681: PUSH
10682: LD_INT 32
10684: PUSH
10685: EMPTY
10686: LIST
10687: LIST
10688: PUSH
10689: LD_INT 30
10691: PUSH
10692: LD_INT 33
10694: PUSH
10695: EMPTY
10696: LIST
10697: LIST
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: LIST
10703: PPUSH
10704: CALL_OW 72
10708: ST_TO_ADDR
// if not t then
10709: LD_VAR 0 6
10713: NOT
10714: IFFALSE 10718
// continue ;
10716: GO 10575
// for j in tmp do
10718: LD_ADDR_VAR 0 3
10722: PUSH
10723: LD_VAR 0 4
10727: PUSH
10728: FOR_IN
10729: IFFALSE 10759
// if not BuildingStatus ( j ) = bs_idle then
10731: LD_VAR 0 3
10735: PPUSH
10736: CALL_OW 461
10740: PUSH
10741: LD_INT 2
10743: EQUAL
10744: NOT
10745: IFFALSE 10757
// begin busy := true ;
10747: LD_ADDR_VAR 0 8
10751: PUSH
10752: LD_INT 1
10754: ST_TO_ADDR
// break ;
10755: GO 10759
// end ;
10757: GO 10728
10759: POP
10760: POP
// if busy then
10761: LD_VAR 0 8
10765: IFFALSE 10769
// continue ;
10767: GO 10575
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
10769: LD_ADDR_VAR 0 7
10773: PUSH
10774: LD_VAR 0 6
10778: PPUSH
10779: LD_INT 35
10781: PUSH
10782: LD_INT 0
10784: PUSH
10785: EMPTY
10786: LIST
10787: LIST
10788: PPUSH
10789: CALL_OW 72
10793: ST_TO_ADDR
// if tw then
10794: LD_VAR 0 7
10798: IFFALSE 10875
// begin tw := tw [ 1 ] ;
10800: LD_ADDR_VAR 0 7
10804: PUSH
10805: LD_VAR 0 7
10809: PUSH
10810: LD_INT 1
10812: ARRAY
10813: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
10814: LD_ADDR_VAR 0 9
10818: PUSH
10819: LD_VAR 0 7
10823: PPUSH
10824: LD_EXP 46
10828: PUSH
10829: LD_VAR 0 2
10833: ARRAY
10834: PPUSH
10835: CALL 39674 0 2
10839: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
10840: LD_EXP 60
10844: PUSH
10845: LD_VAR 0 2
10849: ARRAY
10850: IFFALSE 10873
// if not weapon in mc_allowed_tower_weapons [ i ] then
10852: LD_VAR 0 9
10856: PUSH
10857: LD_EXP 60
10861: PUSH
10862: LD_VAR 0 2
10866: ARRAY
10867: IN
10868: NOT
10869: IFFALSE 10873
// continue ;
10871: GO 10575
// end else
10873: GO 10938
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
10875: LD_ADDR_VAR 0 5
10879: PUSH
10880: LD_EXP 29
10884: PUSH
10885: LD_VAR 0 2
10889: ARRAY
10890: PPUSH
10891: LD_VAR 0 4
10895: PPUSH
10896: CALL 69728 0 2
10900: ST_TO_ADDR
// if not tmp2 then
10901: LD_VAR 0 5
10905: NOT
10906: IFFALSE 10910
// continue ;
10908: GO 10575
// tw := tmp2 [ 1 ] ;
10910: LD_ADDR_VAR 0 7
10914: PUSH
10915: LD_VAR 0 5
10919: PUSH
10920: LD_INT 1
10922: ARRAY
10923: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
10924: LD_ADDR_VAR 0 9
10928: PUSH
10929: LD_VAR 0 5
10933: PUSH
10934: LD_INT 2
10936: ARRAY
10937: ST_TO_ADDR
// end ; if not weapon then
10938: LD_VAR 0 9
10942: NOT
10943: IFFALSE 10947
// continue ;
10945: GO 10575
// ComPlaceWeapon ( tw , weapon ) ;
10947: LD_VAR 0 7
10951: PPUSH
10952: LD_VAR 0 9
10956: PPUSH
10957: CALL_OW 148
// end ;
10961: GO 10575
10963: POP
10964: POP
// end ;
10965: LD_VAR 0 1
10969: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
10970: LD_INT 0
10972: PPUSH
10973: PPUSH
10974: PPUSH
10975: PPUSH
10976: PPUSH
10977: PPUSH
// if not mc_bases then
10978: LD_EXP 21
10982: NOT
10983: IFFALSE 10987
// exit ;
10985: GO 11999
// for i = 1 to mc_bases do
10987: LD_ADDR_VAR 0 2
10991: PUSH
10992: DOUBLE
10993: LD_INT 1
10995: DEC
10996: ST_TO_ADDR
10997: LD_EXP 21
11001: PUSH
11002: FOR_TO
11003: IFFALSE 11997
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
11005: LD_EXP 34
11009: PUSH
11010: LD_VAR 0 2
11014: ARRAY
11015: NOT
11016: PUSH
11017: LD_EXP 34
11021: PUSH
11022: LD_VAR 0 2
11026: ARRAY
11027: PUSH
11028: LD_EXP 35
11032: PUSH
11033: LD_VAR 0 2
11037: ARRAY
11038: EQUAL
11039: OR
11040: IFFALSE 11044
// continue ;
11042: GO 11002
// if mc_miners [ i ] then
11044: LD_EXP 35
11048: PUSH
11049: LD_VAR 0 2
11053: ARRAY
11054: IFFALSE 11684
// begin k := 1 ;
11056: LD_ADDR_VAR 0 4
11060: PUSH
11061: LD_INT 1
11063: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
11064: LD_ADDR_VAR 0 3
11068: PUSH
11069: DOUBLE
11070: LD_EXP 35
11074: PUSH
11075: LD_VAR 0 2
11079: ARRAY
11080: INC
11081: ST_TO_ADDR
11082: LD_INT 1
11084: PUSH
11085: FOR_DOWNTO
11086: IFFALSE 11682
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
11088: LD_EXP 35
11092: PUSH
11093: LD_VAR 0 2
11097: ARRAY
11098: PUSH
11099: LD_VAR 0 3
11103: ARRAY
11104: PPUSH
11105: CALL_OW 301
11109: PUSH
11110: LD_EXP 35
11114: PUSH
11115: LD_VAR 0 2
11119: ARRAY
11120: PUSH
11121: LD_VAR 0 3
11125: ARRAY
11126: PPUSH
11127: CALL_OW 257
11131: PUSH
11132: LD_INT 1
11134: NONEQUAL
11135: OR
11136: IFFALSE 11199
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
11138: LD_ADDR_VAR 0 5
11142: PUSH
11143: LD_EXP 35
11147: PUSH
11148: LD_VAR 0 2
11152: ARRAY
11153: PUSH
11154: LD_EXP 35
11158: PUSH
11159: LD_VAR 0 2
11163: ARRAY
11164: PUSH
11165: LD_VAR 0 3
11169: ARRAY
11170: DIFF
11171: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
11172: LD_ADDR_EXP 35
11176: PUSH
11177: LD_EXP 35
11181: PPUSH
11182: LD_VAR 0 2
11186: PPUSH
11187: LD_VAR 0 5
11191: PPUSH
11192: CALL_OW 1
11196: ST_TO_ADDR
// continue ;
11197: GO 11085
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
11199: LD_EXP 35
11203: PUSH
11204: LD_VAR 0 2
11208: ARRAY
11209: PUSH
11210: LD_VAR 0 3
11214: ARRAY
11215: PPUSH
11216: CALL 34709 0 1
11220: PUSH
11221: LD_EXP 35
11225: PUSH
11226: LD_VAR 0 2
11230: ARRAY
11231: PUSH
11232: LD_VAR 0 3
11236: ARRAY
11237: PPUSH
11238: CALL_OW 255
11242: PPUSH
11243: LD_EXP 34
11247: PUSH
11248: LD_VAR 0 2
11252: ARRAY
11253: PUSH
11254: LD_VAR 0 4
11258: ARRAY
11259: PUSH
11260: LD_INT 1
11262: ARRAY
11263: PPUSH
11264: LD_EXP 34
11268: PUSH
11269: LD_VAR 0 2
11273: ARRAY
11274: PUSH
11275: LD_VAR 0 4
11279: ARRAY
11280: PUSH
11281: LD_INT 2
11283: ARRAY
11284: PPUSH
11285: LD_INT 15
11287: PPUSH
11288: CALL 35702 0 4
11292: PUSH
11293: LD_INT 4
11295: ARRAY
11296: PUSH
11297: LD_EXP 35
11301: PUSH
11302: LD_VAR 0 2
11306: ARRAY
11307: PUSH
11308: LD_VAR 0 3
11312: ARRAY
11313: PPUSH
11314: LD_INT 10
11316: PPUSH
11317: CALL 37399 0 2
11321: PUSH
11322: LD_INT 4
11324: ARRAY
11325: OR
11326: AND
11327: IFFALSE 11350
// ComStop ( mc_miners [ i ] [ j ] ) ;
11329: LD_EXP 35
11333: PUSH
11334: LD_VAR 0 2
11338: ARRAY
11339: PUSH
11340: LD_VAR 0 3
11344: ARRAY
11345: PPUSH
11346: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
11350: LD_EXP 35
11354: PUSH
11355: LD_VAR 0 2
11359: ARRAY
11360: PUSH
11361: LD_VAR 0 3
11365: ARRAY
11366: PPUSH
11367: CALL_OW 257
11371: PUSH
11372: LD_INT 1
11374: EQUAL
11375: PUSH
11376: LD_EXP 35
11380: PUSH
11381: LD_VAR 0 2
11385: ARRAY
11386: PUSH
11387: LD_VAR 0 3
11391: ARRAY
11392: PPUSH
11393: CALL_OW 459
11397: NOT
11398: AND
11399: PUSH
11400: LD_EXP 35
11404: PUSH
11405: LD_VAR 0 2
11409: ARRAY
11410: PUSH
11411: LD_VAR 0 3
11415: ARRAY
11416: PPUSH
11417: CALL_OW 255
11421: PPUSH
11422: LD_EXP 34
11426: PUSH
11427: LD_VAR 0 2
11431: ARRAY
11432: PUSH
11433: LD_VAR 0 4
11437: ARRAY
11438: PUSH
11439: LD_INT 1
11441: ARRAY
11442: PPUSH
11443: LD_EXP 34
11447: PUSH
11448: LD_VAR 0 2
11452: ARRAY
11453: PUSH
11454: LD_VAR 0 4
11458: ARRAY
11459: PUSH
11460: LD_INT 2
11462: ARRAY
11463: PPUSH
11464: LD_INT 15
11466: PPUSH
11467: CALL 35702 0 4
11471: PUSH
11472: LD_INT 4
11474: ARRAY
11475: PUSH
11476: LD_INT 0
11478: EQUAL
11479: AND
11480: PUSH
11481: LD_EXP 35
11485: PUSH
11486: LD_VAR 0 2
11490: ARRAY
11491: PUSH
11492: LD_VAR 0 3
11496: ARRAY
11497: PPUSH
11498: CALL_OW 314
11502: NOT
11503: AND
11504: IFFALSE 11680
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
11506: LD_EXP 35
11510: PUSH
11511: LD_VAR 0 2
11515: ARRAY
11516: PUSH
11517: LD_VAR 0 3
11521: ARRAY
11522: PPUSH
11523: CALL_OW 310
11527: IFFALSE 11550
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
11529: LD_EXP 35
11533: PUSH
11534: LD_VAR 0 2
11538: ARRAY
11539: PUSH
11540: LD_VAR 0 3
11544: ARRAY
11545: PPUSH
11546: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
11550: LD_EXP 35
11554: PUSH
11555: LD_VAR 0 2
11559: ARRAY
11560: PUSH
11561: LD_VAR 0 3
11565: ARRAY
11566: PPUSH
11567: CALL_OW 314
11571: NOT
11572: IFFALSE 11640
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
11574: LD_EXP 35
11578: PUSH
11579: LD_VAR 0 2
11583: ARRAY
11584: PUSH
11585: LD_VAR 0 3
11589: ARRAY
11590: PPUSH
11591: LD_EXP 34
11595: PUSH
11596: LD_VAR 0 2
11600: ARRAY
11601: PUSH
11602: LD_VAR 0 4
11606: ARRAY
11607: PUSH
11608: LD_INT 1
11610: ARRAY
11611: PPUSH
11612: LD_EXP 34
11616: PUSH
11617: LD_VAR 0 2
11621: ARRAY
11622: PUSH
11623: LD_VAR 0 4
11627: ARRAY
11628: PUSH
11629: LD_INT 2
11631: ARRAY
11632: PPUSH
11633: LD_INT 0
11635: PPUSH
11636: CALL_OW 193
// k := k + 1 ;
11640: LD_ADDR_VAR 0 4
11644: PUSH
11645: LD_VAR 0 4
11649: PUSH
11650: LD_INT 1
11652: PLUS
11653: ST_TO_ADDR
// if k > mc_mines [ i ] then
11654: LD_VAR 0 4
11658: PUSH
11659: LD_EXP 34
11663: PUSH
11664: LD_VAR 0 2
11668: ARRAY
11669: GREATER
11670: IFFALSE 11680
// k := 1 ;
11672: LD_ADDR_VAR 0 4
11676: PUSH
11677: LD_INT 1
11679: ST_TO_ADDR
// end ; end ;
11680: GO 11085
11682: POP
11683: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
11684: LD_ADDR_VAR 0 5
11688: PUSH
11689: LD_EXP 21
11693: PUSH
11694: LD_VAR 0 2
11698: ARRAY
11699: PPUSH
11700: LD_INT 2
11702: PUSH
11703: LD_INT 30
11705: PUSH
11706: LD_INT 4
11708: PUSH
11709: EMPTY
11710: LIST
11711: LIST
11712: PUSH
11713: LD_INT 30
11715: PUSH
11716: LD_INT 5
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: LD_INT 30
11725: PUSH
11726: LD_INT 32
11728: PUSH
11729: EMPTY
11730: LIST
11731: LIST
11732: PUSH
11733: EMPTY
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 72
11743: ST_TO_ADDR
// if not tmp then
11744: LD_VAR 0 5
11748: NOT
11749: IFFALSE 11753
// continue ;
11751: GO 11002
// list := [ ] ;
11753: LD_ADDR_VAR 0 6
11757: PUSH
11758: EMPTY
11759: ST_TO_ADDR
// for j in tmp do
11760: LD_ADDR_VAR 0 3
11764: PUSH
11765: LD_VAR 0 5
11769: PUSH
11770: FOR_IN
11771: IFFALSE 11840
// begin for k in UnitsInside ( j ) do
11773: LD_ADDR_VAR 0 4
11777: PUSH
11778: LD_VAR 0 3
11782: PPUSH
11783: CALL_OW 313
11787: PUSH
11788: FOR_IN
11789: IFFALSE 11836
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
11791: LD_VAR 0 4
11795: PPUSH
11796: CALL_OW 257
11800: PUSH
11801: LD_INT 1
11803: EQUAL
11804: PUSH
11805: LD_VAR 0 4
11809: PPUSH
11810: CALL_OW 459
11814: NOT
11815: AND
11816: IFFALSE 11834
// list := list ^ k ;
11818: LD_ADDR_VAR 0 6
11822: PUSH
11823: LD_VAR 0 6
11827: PUSH
11828: LD_VAR 0 4
11832: ADD
11833: ST_TO_ADDR
11834: GO 11788
11836: POP
11837: POP
// end ;
11838: GO 11770
11840: POP
11841: POP
// list := list diff mc_miners [ i ] ;
11842: LD_ADDR_VAR 0 6
11846: PUSH
11847: LD_VAR 0 6
11851: PUSH
11852: LD_EXP 35
11856: PUSH
11857: LD_VAR 0 2
11861: ARRAY
11862: DIFF
11863: ST_TO_ADDR
// if not list then
11864: LD_VAR 0 6
11868: NOT
11869: IFFALSE 11873
// continue ;
11871: GO 11002
// k := mc_mines [ i ] - mc_miners [ i ] ;
11873: LD_ADDR_VAR 0 4
11877: PUSH
11878: LD_EXP 34
11882: PUSH
11883: LD_VAR 0 2
11887: ARRAY
11888: PUSH
11889: LD_EXP 35
11893: PUSH
11894: LD_VAR 0 2
11898: ARRAY
11899: MINUS
11900: ST_TO_ADDR
// if k > list then
11901: LD_VAR 0 4
11905: PUSH
11906: LD_VAR 0 6
11910: GREATER
11911: IFFALSE 11923
// k := list ;
11913: LD_ADDR_VAR 0 4
11917: PUSH
11918: LD_VAR 0 6
11922: ST_TO_ADDR
// for j = 1 to k do
11923: LD_ADDR_VAR 0 3
11927: PUSH
11928: DOUBLE
11929: LD_INT 1
11931: DEC
11932: ST_TO_ADDR
11933: LD_VAR 0 4
11937: PUSH
11938: FOR_TO
11939: IFFALSE 11993
// mc_miners := Add ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
11941: LD_ADDR_EXP 35
11945: PUSH
11946: LD_EXP 35
11950: PPUSH
11951: LD_VAR 0 2
11955: PUSH
11956: LD_EXP 35
11960: PUSH
11961: LD_VAR 0 2
11965: ARRAY
11966: PUSH
11967: LD_INT 1
11969: PLUS
11970: PUSH
11971: EMPTY
11972: LIST
11973: LIST
11974: PPUSH
11975: LD_VAR 0 6
11979: PUSH
11980: LD_VAR 0 3
11984: ARRAY
11985: PPUSH
11986: CALL 35208 0 3
11990: ST_TO_ADDR
11991: GO 11938
11993: POP
11994: POP
// end ;
11995: GO 11002
11997: POP
11998: POP
// end ;
11999: LD_VAR 0 1
12003: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
12004: LD_INT 0
12006: PPUSH
12007: PPUSH
12008: PPUSH
12009: PPUSH
12010: PPUSH
12011: PPUSH
12012: PPUSH
12013: PPUSH
12014: PPUSH
12015: PPUSH
// if not mc_bases then
12016: LD_EXP 21
12020: NOT
12021: IFFALSE 12025
// exit ;
12023: GO 13756
// for i = 1 to mc_bases do
12025: LD_ADDR_VAR 0 2
12029: PUSH
12030: DOUBLE
12031: LD_INT 1
12033: DEC
12034: ST_TO_ADDR
12035: LD_EXP 21
12039: PUSH
12040: FOR_TO
12041: IFFALSE 13754
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
12043: LD_EXP 21
12047: PUSH
12048: LD_VAR 0 2
12052: ARRAY
12053: NOT
12054: PUSH
12055: LD_EXP 28
12059: PUSH
12060: LD_VAR 0 2
12064: ARRAY
12065: OR
12066: IFFALSE 12070
// continue ;
12068: GO 12040
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
12070: LD_EXP 37
12074: PUSH
12075: LD_VAR 0 2
12079: ARRAY
12080: NOT
12081: PUSH
12082: LD_EXP 38
12086: PUSH
12087: LD_VAR 0 2
12091: ARRAY
12092: AND
12093: IFFALSE 12131
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
12095: LD_ADDR_EXP 38
12099: PUSH
12100: LD_EXP 38
12104: PPUSH
12105: LD_VAR 0 2
12109: PPUSH
12110: EMPTY
12111: PPUSH
12112: CALL_OW 1
12116: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
12117: LD_VAR 0 2
12121: PPUSH
12122: LD_INT 107
12124: PPUSH
12125: CALL 3581 0 2
// continue ;
12129: GO 12040
// end ; target := [ ] ;
12131: LD_ADDR_VAR 0 6
12135: PUSH
12136: EMPTY
12137: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
12138: LD_ADDR_VAR 0 3
12142: PUSH
12143: DOUBLE
12144: LD_EXP 37
12148: PUSH
12149: LD_VAR 0 2
12153: ARRAY
12154: INC
12155: ST_TO_ADDR
12156: LD_INT 1
12158: PUSH
12159: FOR_DOWNTO
12160: IFFALSE 12420
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
12162: LD_EXP 37
12166: PUSH
12167: LD_VAR 0 2
12171: ARRAY
12172: PUSH
12173: LD_VAR 0 3
12177: ARRAY
12178: PUSH
12179: LD_INT 2
12181: ARRAY
12182: PPUSH
12183: LD_EXP 37
12187: PUSH
12188: LD_VAR 0 2
12192: ARRAY
12193: PUSH
12194: LD_VAR 0 3
12198: ARRAY
12199: PUSH
12200: LD_INT 3
12202: ARRAY
12203: PPUSH
12204: CALL_OW 488
12208: PUSH
12209: LD_EXP 37
12213: PUSH
12214: LD_VAR 0 2
12218: ARRAY
12219: PUSH
12220: LD_VAR 0 3
12224: ARRAY
12225: PUSH
12226: LD_INT 2
12228: ARRAY
12229: PPUSH
12230: LD_EXP 37
12234: PUSH
12235: LD_VAR 0 2
12239: ARRAY
12240: PUSH
12241: LD_VAR 0 3
12245: ARRAY
12246: PUSH
12247: LD_INT 3
12249: ARRAY
12250: PPUSH
12251: CALL_OW 284
12255: PUSH
12256: LD_INT 0
12258: EQUAL
12259: AND
12260: IFFALSE 12315
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
12262: LD_ADDR_VAR 0 5
12266: PUSH
12267: LD_EXP 37
12271: PUSH
12272: LD_VAR 0 2
12276: ARRAY
12277: PPUSH
12278: LD_VAR 0 3
12282: PPUSH
12283: CALL_OW 3
12287: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
12288: LD_ADDR_EXP 37
12292: PUSH
12293: LD_EXP 37
12297: PPUSH
12298: LD_VAR 0 2
12302: PPUSH
12303: LD_VAR 0 5
12307: PPUSH
12308: CALL_OW 1
12312: ST_TO_ADDR
// continue ;
12313: GO 12159
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
12315: LD_EXP 21
12319: PUSH
12320: LD_VAR 0 2
12324: ARRAY
12325: PUSH
12326: LD_INT 1
12328: ARRAY
12329: PPUSH
12330: CALL_OW 255
12334: PPUSH
12335: LD_EXP 37
12339: PUSH
12340: LD_VAR 0 2
12344: ARRAY
12345: PUSH
12346: LD_VAR 0 3
12350: ARRAY
12351: PUSH
12352: LD_INT 2
12354: ARRAY
12355: PPUSH
12356: LD_EXP 37
12360: PUSH
12361: LD_VAR 0 2
12365: ARRAY
12366: PUSH
12367: LD_VAR 0 3
12371: ARRAY
12372: PUSH
12373: LD_INT 3
12375: ARRAY
12376: PPUSH
12377: LD_INT 30
12379: PPUSH
12380: CALL 35702 0 4
12384: PUSH
12385: LD_INT 4
12387: ARRAY
12388: PUSH
12389: LD_INT 0
12391: EQUAL
12392: IFFALSE 12418
// begin target := mc_crates [ i ] [ j ] ;
12394: LD_ADDR_VAR 0 6
12398: PUSH
12399: LD_EXP 37
12403: PUSH
12404: LD_VAR 0 2
12408: ARRAY
12409: PUSH
12410: LD_VAR 0 3
12414: ARRAY
12415: ST_TO_ADDR
// break ;
12416: GO 12420
// end ; end ;
12418: GO 12159
12420: POP
12421: POP
// if not target then
12422: LD_VAR 0 6
12426: NOT
12427: IFFALSE 12431
// continue ;
12429: GO 12040
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
12431: LD_ADDR_VAR 0 7
12435: PUSH
12436: LD_EXP 40
12440: PUSH
12441: LD_VAR 0 2
12445: ARRAY
12446: PPUSH
12447: LD_INT 2
12449: PUSH
12450: LD_INT 3
12452: PUSH
12453: LD_INT 58
12455: PUSH
12456: EMPTY
12457: LIST
12458: PUSH
12459: EMPTY
12460: LIST
12461: LIST
12462: PUSH
12463: LD_INT 61
12465: PUSH
12466: EMPTY
12467: LIST
12468: PUSH
12469: LD_INT 33
12471: PUSH
12472: LD_INT 5
12474: PUSH
12475: EMPTY
12476: LIST
12477: LIST
12478: PUSH
12479: LD_INT 33
12481: PUSH
12482: LD_INT 3
12484: PUSH
12485: EMPTY
12486: LIST
12487: LIST
12488: PUSH
12489: EMPTY
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: PUSH
12496: LD_INT 2
12498: PUSH
12499: LD_INT 34
12501: PUSH
12502: LD_INT 32
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: PUSH
12509: LD_INT 34
12511: PUSH
12512: LD_INT 51
12514: PUSH
12515: EMPTY
12516: LIST
12517: LIST
12518: PUSH
12519: LD_INT 34
12521: PUSH
12522: LD_INT 12
12524: PUSH
12525: EMPTY
12526: LIST
12527: LIST
12528: PUSH
12529: EMPTY
12530: LIST
12531: LIST
12532: LIST
12533: LIST
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PPUSH
12539: CALL_OW 72
12543: ST_TO_ADDR
// if not cargo then
12544: LD_VAR 0 7
12548: NOT
12549: IFFALSE 13192
// begin if mc_crates_collector [ i ] < 5 then
12551: LD_EXP 38
12555: PUSH
12556: LD_VAR 0 2
12560: ARRAY
12561: PUSH
12562: LD_INT 5
12564: LESS
12565: IFFALSE 12931
// begin if mc_ape [ i ] then
12567: LD_EXP 50
12571: PUSH
12572: LD_VAR 0 2
12576: ARRAY
12577: IFFALSE 12624
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
12579: LD_ADDR_VAR 0 5
12583: PUSH
12584: LD_EXP 50
12588: PUSH
12589: LD_VAR 0 2
12593: ARRAY
12594: PPUSH
12595: LD_INT 25
12597: PUSH
12598: LD_INT 16
12600: PUSH
12601: EMPTY
12602: LIST
12603: LIST
12604: PUSH
12605: LD_INT 24
12607: PUSH
12608: LD_INT 750
12610: PUSH
12611: EMPTY
12612: LIST
12613: LIST
12614: PUSH
12615: EMPTY
12616: LIST
12617: LIST
12618: PPUSH
12619: CALL_OW 72
12623: ST_TO_ADDR
// if not tmp then
12624: LD_VAR 0 5
12628: NOT
12629: IFFALSE 12676
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
12631: LD_ADDR_VAR 0 5
12635: PUSH
12636: LD_EXP 21
12640: PUSH
12641: LD_VAR 0 2
12645: ARRAY
12646: PPUSH
12647: LD_INT 25
12649: PUSH
12650: LD_INT 2
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 24
12659: PUSH
12660: LD_INT 750
12662: PUSH
12663: EMPTY
12664: LIST
12665: LIST
12666: PUSH
12667: EMPTY
12668: LIST
12669: LIST
12670: PPUSH
12671: CALL_OW 72
12675: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
12676: LD_EXP 50
12680: PUSH
12681: LD_VAR 0 2
12685: ARRAY
12686: PUSH
12687: LD_EXP 21
12691: PUSH
12692: LD_VAR 0 2
12696: ARRAY
12697: PPUSH
12698: LD_INT 25
12700: PUSH
12701: LD_INT 2
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: PUSH
12708: LD_INT 24
12710: PUSH
12711: LD_INT 750
12713: PUSH
12714: EMPTY
12715: LIST
12716: LIST
12717: PUSH
12718: EMPTY
12719: LIST
12720: LIST
12721: PPUSH
12722: CALL_OW 72
12726: AND
12727: PUSH
12728: LD_VAR 0 5
12732: PUSH
12733: LD_INT 5
12735: LESS
12736: AND
12737: IFFALSE 12819
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
12739: LD_ADDR_VAR 0 3
12743: PUSH
12744: LD_EXP 21
12748: PUSH
12749: LD_VAR 0 2
12753: ARRAY
12754: PPUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: LD_INT 24
12767: PUSH
12768: LD_INT 750
12770: PUSH
12771: EMPTY
12772: LIST
12773: LIST
12774: PUSH
12775: EMPTY
12776: LIST
12777: LIST
12778: PPUSH
12779: CALL_OW 72
12783: PUSH
12784: FOR_IN
12785: IFFALSE 12817
// begin tmp := tmp union j ;
12787: LD_ADDR_VAR 0 5
12791: PUSH
12792: LD_VAR 0 5
12796: PUSH
12797: LD_VAR 0 3
12801: UNION
12802: ST_TO_ADDR
// if tmp >= 5 then
12803: LD_VAR 0 5
12807: PUSH
12808: LD_INT 5
12810: GREATEREQUAL
12811: IFFALSE 12815
// break ;
12813: GO 12817
// end ;
12815: GO 12784
12817: POP
12818: POP
// end ; if not tmp then
12819: LD_VAR 0 5
12823: NOT
12824: IFFALSE 12828
// continue ;
12826: GO 12040
// for j in tmp do
12828: LD_ADDR_VAR 0 3
12832: PUSH
12833: LD_VAR 0 5
12837: PUSH
12838: FOR_IN
12839: IFFALSE 12929
// if not GetTag ( j ) then
12841: LD_VAR 0 3
12845: PPUSH
12846: CALL_OW 110
12850: NOT
12851: IFFALSE 12927
// begin mc_crates_collector := Add ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
12853: LD_ADDR_EXP 38
12857: PUSH
12858: LD_EXP 38
12862: PPUSH
12863: LD_VAR 0 2
12867: PUSH
12868: LD_EXP 38
12872: PUSH
12873: LD_VAR 0 2
12877: ARRAY
12878: PUSH
12879: LD_INT 1
12881: PLUS
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PPUSH
12887: LD_VAR 0 3
12891: PPUSH
12892: CALL 35208 0 3
12896: ST_TO_ADDR
// SetTag ( j , 107 ) ;
12897: LD_VAR 0 3
12901: PPUSH
12902: LD_INT 107
12904: PPUSH
12905: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
12909: LD_EXP 38
12913: PUSH
12914: LD_VAR 0 2
12918: ARRAY
12919: PUSH
12920: LD_INT 5
12922: GREATEREQUAL
12923: IFFALSE 12927
// break ;
12925: GO 12929
// end ;
12927: GO 12838
12929: POP
12930: POP
// end ; if mc_crates_collector [ i ] and target then
12931: LD_EXP 38
12935: PUSH
12936: LD_VAR 0 2
12940: ARRAY
12941: PUSH
12942: LD_VAR 0 6
12946: AND
12947: IFFALSE 13190
// begin if mc_crates_collector [ i ] < target [ 1 ] then
12949: LD_EXP 38
12953: PUSH
12954: LD_VAR 0 2
12958: ARRAY
12959: PUSH
12960: LD_VAR 0 6
12964: PUSH
12965: LD_INT 1
12967: ARRAY
12968: LESS
12969: IFFALSE 12989
// tmp := mc_crates_collector [ i ] else
12971: LD_ADDR_VAR 0 5
12975: PUSH
12976: LD_EXP 38
12980: PUSH
12981: LD_VAR 0 2
12985: ARRAY
12986: ST_TO_ADDR
12987: GO 13003
// tmp := target [ 1 ] ;
12989: LD_ADDR_VAR 0 5
12993: PUSH
12994: LD_VAR 0 6
12998: PUSH
12999: LD_INT 1
13001: ARRAY
13002: ST_TO_ADDR
// k := 0 ;
13003: LD_ADDR_VAR 0 4
13007: PUSH
13008: LD_INT 0
13010: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
13011: LD_ADDR_VAR 0 3
13015: PUSH
13016: LD_EXP 38
13020: PUSH
13021: LD_VAR 0 2
13025: ARRAY
13026: PUSH
13027: FOR_IN
13028: IFFALSE 13188
// begin k := k + 1 ;
13030: LD_ADDR_VAR 0 4
13034: PUSH
13035: LD_VAR 0 4
13039: PUSH
13040: LD_INT 1
13042: PLUS
13043: ST_TO_ADDR
// if k > tmp then
13044: LD_VAR 0 4
13048: PUSH
13049: LD_VAR 0 5
13053: GREATER
13054: IFFALSE 13058
// break ;
13056: GO 13188
// if not GetClass ( j ) in [ 2 , 16 ] then
13058: LD_VAR 0 3
13062: PPUSH
13063: CALL_OW 257
13067: PUSH
13068: LD_INT 2
13070: PUSH
13071: LD_INT 16
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: IN
13078: NOT
13079: IFFALSE 13132
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
13081: LD_ADDR_EXP 38
13085: PUSH
13086: LD_EXP 38
13090: PPUSH
13091: LD_VAR 0 2
13095: PPUSH
13096: LD_EXP 38
13100: PUSH
13101: LD_VAR 0 2
13105: ARRAY
13106: PUSH
13107: LD_VAR 0 3
13111: DIFF
13112: PPUSH
13113: CALL_OW 1
13117: ST_TO_ADDR
// SetTag ( j , 0 ) ;
13118: LD_VAR 0 3
13122: PPUSH
13123: LD_INT 0
13125: PPUSH
13126: CALL_OW 109
// continue ;
13130: GO 13027
// end ; if IsInUnit ( j ) then
13132: LD_VAR 0 3
13136: PPUSH
13137: CALL_OW 310
13141: IFFALSE 13152
// ComExitBuilding ( j ) ;
13143: LD_VAR 0 3
13147: PPUSH
13148: CALL_OW 122
// wait ( 3 ) ;
13152: LD_INT 3
13154: PPUSH
13155: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
13159: LD_VAR 0 3
13163: PPUSH
13164: LD_VAR 0 6
13168: PUSH
13169: LD_INT 2
13171: ARRAY
13172: PPUSH
13173: LD_VAR 0 6
13177: PUSH
13178: LD_INT 3
13180: ARRAY
13181: PPUSH
13182: CALL_OW 117
// end ;
13186: GO 13027
13188: POP
13189: POP
// end ; end else
13190: GO 13752
// begin for j in cargo do
13192: LD_ADDR_VAR 0 3
13196: PUSH
13197: LD_VAR 0 7
13201: PUSH
13202: FOR_IN
13203: IFFALSE 13750
// begin if GetTag ( j ) <> 0 then
13205: LD_VAR 0 3
13209: PPUSH
13210: CALL_OW 110
13214: PUSH
13215: LD_INT 0
13217: NONEQUAL
13218: IFFALSE 13222
// continue ;
13220: GO 13202
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
13222: LD_VAR 0 3
13226: PPUSH
13227: CALL_OW 256
13231: PUSH
13232: LD_INT 1000
13234: LESS
13235: PUSH
13236: LD_VAR 0 3
13240: PPUSH
13241: LD_EXP 45
13245: PUSH
13246: LD_VAR 0 2
13250: ARRAY
13251: PPUSH
13252: CALL_OW 308
13256: NOT
13257: AND
13258: IFFALSE 13280
// ComMoveToArea ( j , mc_parking [ i ] ) ;
13260: LD_VAR 0 3
13264: PPUSH
13265: LD_EXP 45
13269: PUSH
13270: LD_VAR 0 2
13274: ARRAY
13275: PPUSH
13276: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
13280: LD_VAR 0 3
13284: PPUSH
13285: CALL_OW 256
13289: PUSH
13290: LD_INT 1000
13292: LESS
13293: PUSH
13294: LD_VAR 0 3
13298: PPUSH
13299: LD_EXP 45
13303: PUSH
13304: LD_VAR 0 2
13308: ARRAY
13309: PPUSH
13310: CALL_OW 308
13314: AND
13315: IFFALSE 13319
// continue ;
13317: GO 13202
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
13319: LD_VAR 0 3
13323: PPUSH
13324: CALL_OW 262
13328: PUSH
13329: LD_INT 2
13331: EQUAL
13332: PUSH
13333: LD_VAR 0 3
13337: PPUSH
13338: CALL_OW 261
13342: PUSH
13343: LD_INT 15
13345: LESS
13346: AND
13347: IFFALSE 13351
// continue ;
13349: GO 13202
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
13351: LD_VAR 0 3
13355: PPUSH
13356: CALL_OW 262
13360: PUSH
13361: LD_INT 1
13363: EQUAL
13364: PUSH
13365: LD_VAR 0 3
13369: PPUSH
13370: CALL_OW 261
13374: PUSH
13375: LD_INT 10
13377: LESS
13378: AND
13379: IFFALSE 13689
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
13381: LD_ADDR_VAR 0 8
13385: PUSH
13386: LD_EXP 21
13390: PUSH
13391: LD_VAR 0 2
13395: ARRAY
13396: PPUSH
13397: LD_INT 2
13399: PUSH
13400: LD_INT 30
13402: PUSH
13403: LD_INT 0
13405: PUSH
13406: EMPTY
13407: LIST
13408: LIST
13409: PUSH
13410: LD_INT 30
13412: PUSH
13413: LD_INT 1
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PUSH
13420: EMPTY
13421: LIST
13422: LIST
13423: LIST
13424: PPUSH
13425: CALL_OW 72
13429: ST_TO_ADDR
// if not depot then
13430: LD_VAR 0 8
13434: NOT
13435: IFFALSE 13439
// continue ;
13437: GO 13202
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
13439: LD_VAR 0 3
13443: PPUSH
13444: LD_VAR 0 8
13448: PPUSH
13449: LD_VAR 0 3
13453: PPUSH
13454: CALL_OW 74
13458: PPUSH
13459: CALL_OW 296
13463: PUSH
13464: LD_INT 6
13466: LESS
13467: IFFALSE 13483
// SetFuel ( j , 100 ) else
13469: LD_VAR 0 3
13473: PPUSH
13474: LD_INT 100
13476: PPUSH
13477: CALL_OW 240
13481: GO 13689
// if GetFuel ( j ) = 0 then
13483: LD_VAR 0 3
13487: PPUSH
13488: CALL_OW 261
13492: PUSH
13493: LD_INT 0
13495: EQUAL
13496: IFFALSE 13689
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
13498: LD_ADDR_EXP 40
13502: PUSH
13503: LD_EXP 40
13507: PPUSH
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_EXP 40
13517: PUSH
13518: LD_VAR 0 2
13522: ARRAY
13523: PUSH
13524: LD_VAR 0 3
13528: DIFF
13529: PPUSH
13530: CALL_OW 1
13534: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
13535: LD_VAR 0 3
13539: PPUSH
13540: CALL_OW 263
13544: PUSH
13545: LD_INT 1
13547: EQUAL
13548: IFFALSE 13564
// ComExitVehicle ( IsInUnit ( j ) ) ;
13550: LD_VAR 0 3
13554: PPUSH
13555: CALL_OW 310
13559: PPUSH
13560: CALL_OW 121
// if GetControl ( j ) = control_remote then
13564: LD_VAR 0 3
13568: PPUSH
13569: CALL_OW 263
13573: PUSH
13574: LD_INT 2
13576: EQUAL
13577: IFFALSE 13588
// ComUnlink ( j ) ;
13579: LD_VAR 0 3
13583: PPUSH
13584: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
13588: LD_ADDR_VAR 0 9
13592: PUSH
13593: LD_VAR 0 2
13597: PPUSH
13598: LD_INT 3
13600: PPUSH
13601: CALL 22824 0 2
13605: ST_TO_ADDR
// if fac then
13606: LD_VAR 0 9
13610: IFFALSE 13687
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
13612: LD_ADDR_VAR 0 10
13616: PUSH
13617: LD_VAR 0 9
13621: PPUSH
13622: LD_VAR 0 3
13626: PPUSH
13627: CALL_OW 265
13631: PPUSH
13632: LD_VAR 0 3
13636: PPUSH
13637: CALL_OW 262
13641: PPUSH
13642: LD_VAR 0 3
13646: PPUSH
13647: CALL_OW 263
13651: PPUSH
13652: LD_VAR 0 3
13656: PPUSH
13657: CALL_OW 264
13661: PPUSH
13662: CALL 32373 0 5
13666: ST_TO_ADDR
// if components then
13667: LD_VAR 0 10
13671: IFFALSE 13687
// MC_InsertProduceList ( i , components ) ;
13673: LD_VAR 0 2
13677: PPUSH
13678: LD_VAR 0 10
13682: PPUSH
13683: CALL 22394 0 2
// end ; continue ;
13687: GO 13202
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
13689: LD_VAR 0 3
13693: PPUSH
13694: LD_INT 1
13696: PPUSH
13697: CALL_OW 289
13701: PUSH
13702: LD_INT 100
13704: LESS
13705: PUSH
13706: LD_VAR 0 3
13710: PPUSH
13711: CALL_OW 314
13715: NOT
13716: AND
13717: IFFALSE 13746
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
13719: LD_VAR 0 3
13723: PPUSH
13724: LD_VAR 0 6
13728: PUSH
13729: LD_INT 2
13731: ARRAY
13732: PPUSH
13733: LD_VAR 0 6
13737: PUSH
13738: LD_INT 3
13740: ARRAY
13741: PPUSH
13742: CALL_OW 117
// break ;
13746: GO 13750
// end ;
13748: GO 13202
13750: POP
13751: POP
// end ; end ;
13752: GO 12040
13754: POP
13755: POP
// end ;
13756: LD_VAR 0 1
13760: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
13761: LD_INT 0
13763: PPUSH
13764: PPUSH
13765: PPUSH
13766: PPUSH
// if not mc_bases then
13767: LD_EXP 21
13771: NOT
13772: IFFALSE 13776
// exit ;
13774: GO 13937
// for i = 1 to mc_bases do
13776: LD_ADDR_VAR 0 2
13780: PUSH
13781: DOUBLE
13782: LD_INT 1
13784: DEC
13785: ST_TO_ADDR
13786: LD_EXP 21
13790: PUSH
13791: FOR_TO
13792: IFFALSE 13935
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
13794: LD_ADDR_VAR 0 4
13798: PUSH
13799: LD_EXP 40
13803: PUSH
13804: LD_VAR 0 2
13808: ARRAY
13809: PUSH
13810: LD_EXP 43
13814: PUSH
13815: LD_VAR 0 2
13819: ARRAY
13820: UNION
13821: PPUSH
13822: LD_INT 33
13824: PUSH
13825: LD_INT 2
13827: PUSH
13828: EMPTY
13829: LIST
13830: LIST
13831: PPUSH
13832: CALL_OW 72
13836: ST_TO_ADDR
// if tmp then
13837: LD_VAR 0 4
13841: IFFALSE 13933
// for j in tmp do
13843: LD_ADDR_VAR 0 3
13847: PUSH
13848: LD_VAR 0 4
13852: PUSH
13853: FOR_IN
13854: IFFALSE 13931
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
13856: LD_VAR 0 3
13860: PPUSH
13861: CALL_OW 312
13865: NOT
13866: PUSH
13867: LD_VAR 0 3
13871: PPUSH
13872: CALL_OW 256
13876: PUSH
13877: LD_INT 250
13879: GREATEREQUAL
13880: AND
13881: IFFALSE 13894
// Connect ( j ) else
13883: LD_VAR 0 3
13887: PPUSH
13888: CALL 37739 0 1
13892: GO 13929
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
13894: LD_VAR 0 3
13898: PPUSH
13899: CALL_OW 256
13903: PUSH
13904: LD_INT 250
13906: LESS
13907: PUSH
13908: LD_VAR 0 3
13912: PPUSH
13913: CALL_OW 312
13917: AND
13918: IFFALSE 13929
// ComUnlink ( j ) ;
13920: LD_VAR 0 3
13924: PPUSH
13925: CALL_OW 136
13929: GO 13853
13931: POP
13932: POP
// end ;
13933: GO 13791
13935: POP
13936: POP
// end ;
13937: LD_VAR 0 1
13941: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
13942: LD_INT 0
13944: PPUSH
13945: PPUSH
13946: PPUSH
13947: PPUSH
13948: PPUSH
// if not mc_bases then
13949: LD_EXP 21
13953: NOT
13954: IFFALSE 13958
// exit ;
13956: GO 14418
// for i = 1 to mc_bases do
13958: LD_ADDR_VAR 0 2
13962: PUSH
13963: DOUBLE
13964: LD_INT 1
13966: DEC
13967: ST_TO_ADDR
13968: LD_EXP 21
13972: PUSH
13973: FOR_TO
13974: IFFALSE 14416
// begin if not mc_produce [ i ] then
13976: LD_EXP 42
13980: PUSH
13981: LD_VAR 0 2
13985: ARRAY
13986: NOT
13987: IFFALSE 13991
// continue ;
13989: GO 13973
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
13991: LD_ADDR_VAR 0 5
13995: PUSH
13996: LD_EXP 21
14000: PUSH
14001: LD_VAR 0 2
14005: ARRAY
14006: PPUSH
14007: LD_INT 30
14009: PUSH
14010: LD_INT 3
14012: PUSH
14013: EMPTY
14014: LIST
14015: LIST
14016: PPUSH
14017: CALL_OW 72
14021: ST_TO_ADDR
// if not fac then
14022: LD_VAR 0 5
14026: NOT
14027: IFFALSE 14031
// continue ;
14029: GO 13973
// for j in fac do
14031: LD_ADDR_VAR 0 3
14035: PUSH
14036: LD_VAR 0 5
14040: PUSH
14041: FOR_IN
14042: IFFALSE 14412
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
14044: LD_VAR 0 3
14048: PPUSH
14049: CALL_OW 461
14053: PUSH
14054: LD_INT 2
14056: NONEQUAL
14057: PUSH
14058: LD_VAR 0 3
14062: PPUSH
14063: LD_INT 15
14065: PPUSH
14066: CALL 37399 0 2
14070: PUSH
14071: LD_INT 4
14073: ARRAY
14074: OR
14075: PUSH
14076: LD_VAR 0 3
14080: PPUSH
14081: CALL_OW 313
14085: PUSH
14086: LD_INT 0
14088: EQUAL
14089: OR
14090: IFFALSE 14094
// continue ;
14092: GO 14041
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
14094: LD_VAR 0 3
14098: PPUSH
14099: LD_EXP 42
14103: PUSH
14104: LD_VAR 0 2
14108: ARRAY
14109: PUSH
14110: LD_INT 1
14112: ARRAY
14113: PUSH
14114: LD_INT 1
14116: ARRAY
14117: PPUSH
14118: LD_EXP 42
14122: PUSH
14123: LD_VAR 0 2
14127: ARRAY
14128: PUSH
14129: LD_INT 1
14131: ARRAY
14132: PUSH
14133: LD_INT 2
14135: ARRAY
14136: PPUSH
14137: LD_EXP 42
14141: PUSH
14142: LD_VAR 0 2
14146: ARRAY
14147: PUSH
14148: LD_INT 1
14150: ARRAY
14151: PUSH
14152: LD_INT 3
14154: ARRAY
14155: PPUSH
14156: LD_EXP 42
14160: PUSH
14161: LD_VAR 0 2
14165: ARRAY
14166: PUSH
14167: LD_INT 1
14169: ARRAY
14170: PUSH
14171: LD_INT 4
14173: ARRAY
14174: PPUSH
14175: CALL_OW 448
14179: PUSH
14180: LD_VAR 0 3
14184: PPUSH
14185: LD_EXP 42
14189: PUSH
14190: LD_VAR 0 2
14194: ARRAY
14195: PUSH
14196: LD_INT 1
14198: ARRAY
14199: PUSH
14200: LD_INT 1
14202: ARRAY
14203: PUSH
14204: LD_EXP 42
14208: PUSH
14209: LD_VAR 0 2
14213: ARRAY
14214: PUSH
14215: LD_INT 1
14217: ARRAY
14218: PUSH
14219: LD_INT 2
14221: ARRAY
14222: PUSH
14223: LD_EXP 42
14227: PUSH
14228: LD_VAR 0 2
14232: ARRAY
14233: PUSH
14234: LD_INT 1
14236: ARRAY
14237: PUSH
14238: LD_INT 3
14240: ARRAY
14241: PUSH
14242: LD_EXP 42
14246: PUSH
14247: LD_VAR 0 2
14251: ARRAY
14252: PUSH
14253: LD_INT 1
14255: ARRAY
14256: PUSH
14257: LD_INT 4
14259: ARRAY
14260: PUSH
14261: EMPTY
14262: LIST
14263: LIST
14264: LIST
14265: LIST
14266: PPUSH
14267: CALL 40968 0 2
14271: AND
14272: IFFALSE 14410
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
14274: LD_VAR 0 3
14278: PPUSH
14279: LD_EXP 42
14283: PUSH
14284: LD_VAR 0 2
14288: ARRAY
14289: PUSH
14290: LD_INT 1
14292: ARRAY
14293: PUSH
14294: LD_INT 1
14296: ARRAY
14297: PPUSH
14298: LD_EXP 42
14302: PUSH
14303: LD_VAR 0 2
14307: ARRAY
14308: PUSH
14309: LD_INT 1
14311: ARRAY
14312: PUSH
14313: LD_INT 2
14315: ARRAY
14316: PPUSH
14317: LD_EXP 42
14321: PUSH
14322: LD_VAR 0 2
14326: ARRAY
14327: PUSH
14328: LD_INT 1
14330: ARRAY
14331: PUSH
14332: LD_INT 3
14334: ARRAY
14335: PPUSH
14336: LD_EXP 42
14340: PUSH
14341: LD_VAR 0 2
14345: ARRAY
14346: PUSH
14347: LD_INT 1
14349: ARRAY
14350: PUSH
14351: LD_INT 4
14353: ARRAY
14354: PPUSH
14355: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
14359: LD_ADDR_VAR 0 4
14363: PUSH
14364: LD_EXP 42
14368: PUSH
14369: LD_VAR 0 2
14373: ARRAY
14374: PPUSH
14375: LD_INT 1
14377: PPUSH
14378: CALL_OW 3
14382: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
14383: LD_ADDR_EXP 42
14387: PUSH
14388: LD_EXP 42
14392: PPUSH
14393: LD_VAR 0 2
14397: PPUSH
14398: LD_VAR 0 4
14402: PPUSH
14403: CALL_OW 1
14407: ST_TO_ADDR
// break ;
14408: GO 14412
// end ; end ;
14410: GO 14041
14412: POP
14413: POP
// end ;
14414: GO 13973
14416: POP
14417: POP
// end ;
14418: LD_VAR 0 1
14422: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
14423: LD_INT 0
14425: PPUSH
14426: PPUSH
14427: PPUSH
// if not mc_bases then
14428: LD_EXP 21
14432: NOT
14433: IFFALSE 14437
// exit ;
14435: GO 14526
// for i = 1 to mc_bases do
14437: LD_ADDR_VAR 0 2
14441: PUSH
14442: DOUBLE
14443: LD_INT 1
14445: DEC
14446: ST_TO_ADDR
14447: LD_EXP 21
14451: PUSH
14452: FOR_TO
14453: IFFALSE 14524
// begin if mc_attack [ i ] then
14455: LD_EXP 41
14459: PUSH
14460: LD_VAR 0 2
14464: ARRAY
14465: IFFALSE 14522
// begin tmp := mc_attack [ i ] [ 1 ] ;
14467: LD_ADDR_VAR 0 3
14471: PUSH
14472: LD_EXP 41
14476: PUSH
14477: LD_VAR 0 2
14481: ARRAY
14482: PUSH
14483: LD_INT 1
14485: ARRAY
14486: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
14487: LD_ADDR_EXP 41
14491: PUSH
14492: LD_EXP 41
14496: PPUSH
14497: LD_VAR 0 2
14501: PPUSH
14502: EMPTY
14503: PPUSH
14504: CALL_OW 1
14508: ST_TO_ADDR
// Attack ( tmp ) ;
14509: LD_VAR 0 3
14513: PPUSH
14514: CALL 63072 0 1
// exit ;
14518: POP
14519: POP
14520: GO 14526
// end ; end ;
14522: GO 14452
14524: POP
14525: POP
// end ;
14526: LD_VAR 0 1
14530: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
14531: LD_INT 0
14533: PPUSH
14534: PPUSH
14535: PPUSH
14536: PPUSH
14537: PPUSH
14538: PPUSH
14539: PPUSH
// if not mc_bases then
14540: LD_EXP 21
14544: NOT
14545: IFFALSE 14549
// exit ;
14547: GO 15153
// for i = 1 to mc_bases do
14549: LD_ADDR_VAR 0 2
14553: PUSH
14554: DOUBLE
14555: LD_INT 1
14557: DEC
14558: ST_TO_ADDR
14559: LD_EXP 21
14563: PUSH
14564: FOR_TO
14565: IFFALSE 15151
// begin if not mc_bases [ i ] then
14567: LD_EXP 21
14571: PUSH
14572: LD_VAR 0 2
14576: ARRAY
14577: NOT
14578: IFFALSE 14582
// continue ;
14580: GO 14564
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
14582: LD_ADDR_VAR 0 7
14586: PUSH
14587: LD_EXP 21
14591: PUSH
14592: LD_VAR 0 2
14596: ARRAY
14597: PUSH
14598: LD_INT 1
14600: ARRAY
14601: PPUSH
14602: CALL 31677 0 1
14606: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
14607: LD_ADDR_EXP 44
14611: PUSH
14612: LD_EXP 44
14616: PPUSH
14617: LD_VAR 0 2
14621: PPUSH
14622: LD_EXP 21
14626: PUSH
14627: LD_VAR 0 2
14631: ARRAY
14632: PUSH
14633: LD_INT 1
14635: ARRAY
14636: PPUSH
14637: CALL_OW 255
14641: PPUSH
14642: LD_EXP 46
14646: PUSH
14647: LD_VAR 0 2
14651: ARRAY
14652: PPUSH
14653: CALL 29637 0 2
14657: PPUSH
14658: CALL_OW 1
14662: ST_TO_ADDR
// if not mc_scan [ i ] then
14663: LD_EXP 44
14667: PUSH
14668: LD_VAR 0 2
14672: ARRAY
14673: NOT
14674: IFFALSE 14829
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
14676: LD_ADDR_VAR 0 4
14680: PUSH
14681: LD_EXP 21
14685: PUSH
14686: LD_VAR 0 2
14690: ARRAY
14691: PPUSH
14692: LD_INT 2
14694: PUSH
14695: LD_INT 25
14697: PUSH
14698: LD_INT 5
14700: PUSH
14701: EMPTY
14702: LIST
14703: LIST
14704: PUSH
14705: LD_INT 25
14707: PUSH
14708: LD_INT 8
14710: PUSH
14711: EMPTY
14712: LIST
14713: LIST
14714: PUSH
14715: LD_INT 25
14717: PUSH
14718: LD_INT 9
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: LIST
14729: LIST
14730: PPUSH
14731: CALL_OW 72
14735: ST_TO_ADDR
// if not tmp then
14736: LD_VAR 0 4
14740: NOT
14741: IFFALSE 14745
// continue ;
14743: GO 14564
// for j in tmp do
14745: LD_ADDR_VAR 0 3
14749: PUSH
14750: LD_VAR 0 4
14754: PUSH
14755: FOR_IN
14756: IFFALSE 14827
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
14758: LD_VAR 0 3
14762: PPUSH
14763: CALL_OW 310
14767: PPUSH
14768: CALL_OW 266
14772: PUSH
14773: LD_INT 5
14775: EQUAL
14776: PUSH
14777: LD_VAR 0 3
14781: PPUSH
14782: CALL_OW 257
14786: PUSH
14787: LD_INT 1
14789: EQUAL
14790: AND
14791: PUSH
14792: LD_VAR 0 3
14796: PPUSH
14797: CALL_OW 459
14801: NOT
14802: AND
14803: PUSH
14804: LD_VAR 0 7
14808: AND
14809: IFFALSE 14825
// ComChangeProfession ( j , class ) ;
14811: LD_VAR 0 3
14815: PPUSH
14816: LD_VAR 0 7
14820: PPUSH
14821: CALL_OW 123
14825: GO 14755
14827: POP
14828: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
14829: LD_EXP 44
14833: PUSH
14834: LD_VAR 0 2
14838: ARRAY
14839: PUSH
14840: LD_EXP 43
14844: PUSH
14845: LD_VAR 0 2
14849: ARRAY
14850: NOT
14851: AND
14852: PUSH
14853: LD_EXP 21
14857: PUSH
14858: LD_VAR 0 2
14862: ARRAY
14863: PPUSH
14864: LD_INT 30
14866: PUSH
14867: LD_INT 32
14869: PUSH
14870: EMPTY
14871: LIST
14872: LIST
14873: PPUSH
14874: CALL_OW 72
14878: NOT
14879: AND
14880: PUSH
14881: LD_EXP 21
14885: PUSH
14886: LD_VAR 0 2
14890: ARRAY
14891: PPUSH
14892: LD_INT 2
14894: PUSH
14895: LD_INT 30
14897: PUSH
14898: LD_INT 4
14900: PUSH
14901: EMPTY
14902: LIST
14903: LIST
14904: PUSH
14905: LD_INT 30
14907: PUSH
14908: LD_INT 5
14910: PUSH
14911: EMPTY
14912: LIST
14913: LIST
14914: PUSH
14915: EMPTY
14916: LIST
14917: LIST
14918: LIST
14919: PPUSH
14920: CALL_OW 72
14924: NOT
14925: AND
14926: IFFALSE 15058
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
14928: LD_ADDR_VAR 0 4
14932: PUSH
14933: LD_EXP 21
14937: PUSH
14938: LD_VAR 0 2
14942: ARRAY
14943: PPUSH
14944: LD_INT 2
14946: PUSH
14947: LD_INT 25
14949: PUSH
14950: LD_INT 1
14952: PUSH
14953: EMPTY
14954: LIST
14955: LIST
14956: PUSH
14957: LD_INT 25
14959: PUSH
14960: LD_INT 5
14962: PUSH
14963: EMPTY
14964: LIST
14965: LIST
14966: PUSH
14967: LD_INT 25
14969: PUSH
14970: LD_INT 8
14972: PUSH
14973: EMPTY
14974: LIST
14975: LIST
14976: PUSH
14977: LD_INT 25
14979: PUSH
14980: LD_INT 9
14982: PUSH
14983: EMPTY
14984: LIST
14985: LIST
14986: PUSH
14987: EMPTY
14988: LIST
14989: LIST
14990: LIST
14991: LIST
14992: LIST
14993: PPUSH
14994: CALL_OW 72
14998: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
14999: LD_ADDR_VAR 0 4
15003: PUSH
15004: LD_VAR 0 4
15008: PUSH
15009: LD_VAR 0 4
15013: PPUSH
15014: LD_INT 18
15016: PPUSH
15017: CALL 67816 0 2
15021: DIFF
15022: ST_TO_ADDR
// if tmp then
15023: LD_VAR 0 4
15027: IFFALSE 15058
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
15029: LD_VAR 0 2
15033: PPUSH
15034: LD_VAR 0 4
15038: PPUSH
15039: LD_EXP 46
15043: PUSH
15044: LD_VAR 0 2
15048: ARRAY
15049: PPUSH
15050: CALL 29672 0 3
// exit ;
15054: POP
15055: POP
15056: GO 15153
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
15058: LD_EXP 44
15062: PUSH
15063: LD_VAR 0 2
15067: ARRAY
15068: PUSH
15069: LD_EXP 43
15073: PUSH
15074: LD_VAR 0 2
15078: ARRAY
15079: AND
15080: IFFALSE 15149
// begin tmp := mc_defender [ i ] ;
15082: LD_ADDR_VAR 0 4
15086: PUSH
15087: LD_EXP 43
15091: PUSH
15092: LD_VAR 0 2
15096: ARRAY
15097: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
15098: LD_ADDR_EXP 43
15102: PUSH
15103: LD_EXP 43
15107: PPUSH
15108: LD_VAR 0 2
15112: PPUSH
15113: EMPTY
15114: PPUSH
15115: CALL_OW 1
15119: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
15120: LD_VAR 0 2
15124: PPUSH
15125: LD_VAR 0 4
15129: PPUSH
15130: LD_EXP 44
15134: PUSH
15135: LD_VAR 0 2
15139: ARRAY
15140: PPUSH
15141: CALL 30170 0 3
// exit ;
15145: POP
15146: POP
15147: GO 15153
// end ; end ;
15149: GO 14564
15151: POP
15152: POP
// end ;
15153: LD_VAR 0 1
15157: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
15158: LD_INT 0
15160: PPUSH
15161: PPUSH
15162: PPUSH
15163: PPUSH
15164: PPUSH
15165: PPUSH
15166: PPUSH
15167: PPUSH
15168: PPUSH
15169: PPUSH
15170: PPUSH
// if not mc_bases then
15171: LD_EXP 21
15175: NOT
15176: IFFALSE 15180
// exit ;
15178: GO 16240
// for i = 1 to mc_bases do
15180: LD_ADDR_VAR 0 2
15184: PUSH
15185: DOUBLE
15186: LD_INT 1
15188: DEC
15189: ST_TO_ADDR
15190: LD_EXP 21
15194: PUSH
15195: FOR_TO
15196: IFFALSE 16238
// begin tmp := mc_lab [ i ] ;
15198: LD_ADDR_VAR 0 6
15202: PUSH
15203: LD_EXP 54
15207: PUSH
15208: LD_VAR 0 2
15212: ARRAY
15213: ST_TO_ADDR
// if not tmp then
15214: LD_VAR 0 6
15218: NOT
15219: IFFALSE 15223
// continue ;
15221: GO 15195
// idle_lab := 0 ;
15223: LD_ADDR_VAR 0 11
15227: PUSH
15228: LD_INT 0
15230: ST_TO_ADDR
// for j in tmp do
15231: LD_ADDR_VAR 0 3
15235: PUSH
15236: LD_VAR 0 6
15240: PUSH
15241: FOR_IN
15242: IFFALSE 16234
// begin researching := false ;
15244: LD_ADDR_VAR 0 10
15248: PUSH
15249: LD_INT 0
15251: ST_TO_ADDR
// side := GetSide ( j ) ;
15252: LD_ADDR_VAR 0 4
15256: PUSH
15257: LD_VAR 0 3
15261: PPUSH
15262: CALL_OW 255
15266: ST_TO_ADDR
// if not mc_tech [ side ] then
15267: LD_EXP 48
15271: PUSH
15272: LD_VAR 0 4
15276: ARRAY
15277: NOT
15278: IFFALSE 15282
// continue ;
15280: GO 15241
// if BuildingStatus ( j ) = bs_idle then
15282: LD_VAR 0 3
15286: PPUSH
15287: CALL_OW 461
15291: PUSH
15292: LD_INT 2
15294: EQUAL
15295: IFFALSE 15468
// begin if idle_lab then
15297: LD_VAR 0 11
15301: IFFALSE 15372
// begin tmp2 := UnitsInside ( idle_lab ) ;
15303: LD_ADDR_VAR 0 9
15307: PUSH
15308: LD_VAR 0 11
15312: PPUSH
15313: CALL_OW 313
15317: ST_TO_ADDR
// if tmp2 then
15318: LD_VAR 0 9
15322: IFFALSE 15364
// for x in tmp2 do
15324: LD_ADDR_VAR 0 7
15328: PUSH
15329: LD_VAR 0 9
15333: PUSH
15334: FOR_IN
15335: IFFALSE 15362
// begin ComExitBuilding ( x ) ;
15337: LD_VAR 0 7
15341: PPUSH
15342: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
15346: LD_VAR 0 7
15350: PPUSH
15351: LD_VAR 0 3
15355: PPUSH
15356: CALL_OW 180
// end ;
15360: GO 15334
15362: POP
15363: POP
// idle_lab := 0 ;
15364: LD_ADDR_VAR 0 11
15368: PUSH
15369: LD_INT 0
15371: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
15372: LD_ADDR_VAR 0 5
15376: PUSH
15377: LD_EXP 48
15381: PUSH
15382: LD_VAR 0 4
15386: ARRAY
15387: PUSH
15388: FOR_IN
15389: IFFALSE 15449
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
15391: LD_VAR 0 3
15395: PPUSH
15396: LD_VAR 0 5
15400: PPUSH
15401: CALL_OW 430
15405: PUSH
15406: LD_VAR 0 4
15410: PPUSH
15411: LD_VAR 0 5
15415: PPUSH
15416: CALL 28742 0 2
15420: AND
15421: IFFALSE 15447
// begin researching := true ;
15423: LD_ADDR_VAR 0 10
15427: PUSH
15428: LD_INT 1
15430: ST_TO_ADDR
// ComResearch ( j , t ) ;
15431: LD_VAR 0 3
15435: PPUSH
15436: LD_VAR 0 5
15440: PPUSH
15441: CALL_OW 124
// break ;
15445: GO 15449
// end ;
15447: GO 15388
15449: POP
15450: POP
// if not researching then
15451: LD_VAR 0 10
15455: NOT
15456: IFFALSE 15468
// idle_lab := j ;
15458: LD_ADDR_VAR 0 11
15462: PUSH
15463: LD_VAR 0 3
15467: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
15468: LD_VAR 0 3
15472: PPUSH
15473: CALL_OW 461
15477: PUSH
15478: LD_INT 10
15480: EQUAL
15481: IFFALSE 16069
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
15483: LD_EXP 50
15487: PUSH
15488: LD_VAR 0 2
15492: ARRAY
15493: NOT
15494: PUSH
15495: LD_EXP 51
15499: PUSH
15500: LD_VAR 0 2
15504: ARRAY
15505: NOT
15506: AND
15507: PUSH
15508: LD_EXP 48
15512: PUSH
15513: LD_VAR 0 4
15517: ARRAY
15518: PUSH
15519: LD_INT 1
15521: GREATER
15522: AND
15523: IFFALSE 15654
// begin ComCancel ( j ) ;
15525: LD_VAR 0 3
15529: PPUSH
15530: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
15534: LD_ADDR_EXP 48
15538: PUSH
15539: LD_EXP 48
15543: PPUSH
15544: LD_VAR 0 4
15548: PPUSH
15549: LD_EXP 48
15553: PUSH
15554: LD_VAR 0 4
15558: ARRAY
15559: PPUSH
15560: LD_EXP 48
15564: PUSH
15565: LD_VAR 0 4
15569: ARRAY
15570: PUSH
15571: LD_INT 1
15573: MINUS
15574: PPUSH
15575: LD_EXP 48
15579: PUSH
15580: LD_VAR 0 4
15584: ARRAY
15585: PPUSH
15586: LD_INT 0
15588: PPUSH
15589: CALL 34191 0 4
15593: PPUSH
15594: CALL_OW 1
15598: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
15599: LD_ADDR_EXP 48
15603: PUSH
15604: LD_EXP 48
15608: PPUSH
15609: LD_VAR 0 4
15613: PPUSH
15614: LD_EXP 48
15618: PUSH
15619: LD_VAR 0 4
15623: ARRAY
15624: PPUSH
15625: LD_EXP 48
15629: PUSH
15630: LD_VAR 0 4
15634: ARRAY
15635: PPUSH
15636: LD_INT 1
15638: PPUSH
15639: LD_INT 0
15641: PPUSH
15642: CALL 34191 0 4
15646: PPUSH
15647: CALL_OW 1
15651: ST_TO_ADDR
// continue ;
15652: GO 15241
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
15654: LD_EXP 50
15658: PUSH
15659: LD_VAR 0 2
15663: ARRAY
15664: PUSH
15665: LD_EXP 51
15669: PUSH
15670: LD_VAR 0 2
15674: ARRAY
15675: NOT
15676: AND
15677: IFFALSE 15804
// begin mc_ape_in_lab := Add ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
15679: LD_ADDR_EXP 51
15683: PUSH
15684: LD_EXP 51
15688: PPUSH
15689: LD_VAR 0 2
15693: PUSH
15694: LD_EXP 51
15698: PUSH
15699: LD_VAR 0 2
15703: ARRAY
15704: PUSH
15705: LD_INT 1
15707: PLUS
15708: PUSH
15709: EMPTY
15710: LIST
15711: LIST
15712: PPUSH
15713: LD_EXP 50
15717: PUSH
15718: LD_VAR 0 2
15722: ARRAY
15723: PUSH
15724: LD_INT 1
15726: ARRAY
15727: PPUSH
15728: CALL 35208 0 3
15732: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
15733: LD_EXP 50
15737: PUSH
15738: LD_VAR 0 2
15742: ARRAY
15743: PUSH
15744: LD_INT 1
15746: ARRAY
15747: PPUSH
15748: LD_INT 112
15750: PPUSH
15751: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
15755: LD_ADDR_VAR 0 9
15759: PUSH
15760: LD_EXP 50
15764: PUSH
15765: LD_VAR 0 2
15769: ARRAY
15770: PPUSH
15771: LD_INT 1
15773: PPUSH
15774: CALL_OW 3
15778: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
15779: LD_ADDR_EXP 50
15783: PUSH
15784: LD_EXP 50
15788: PPUSH
15789: LD_VAR 0 2
15793: PPUSH
15794: LD_VAR 0 9
15798: PPUSH
15799: CALL_OW 1
15803: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
15804: LD_EXP 50
15808: PUSH
15809: LD_VAR 0 2
15813: ARRAY
15814: PUSH
15815: LD_EXP 51
15819: PUSH
15820: LD_VAR 0 2
15824: ARRAY
15825: AND
15826: PUSH
15827: LD_EXP 51
15831: PUSH
15832: LD_VAR 0 2
15836: ARRAY
15837: PUSH
15838: LD_INT 1
15840: ARRAY
15841: PPUSH
15842: CALL_OW 310
15846: NOT
15847: AND
15848: PUSH
15849: LD_VAR 0 3
15853: PPUSH
15854: CALL_OW 313
15858: PUSH
15859: LD_INT 6
15861: EQUAL
15862: AND
15863: IFFALSE 15919
// begin tmp2 := UnitsInside ( j ) ;
15865: LD_ADDR_VAR 0 9
15869: PUSH
15870: LD_VAR 0 3
15874: PPUSH
15875: CALL_OW 313
15879: ST_TO_ADDR
// if tmp2 = 6 then
15880: LD_VAR 0 9
15884: PUSH
15885: LD_INT 6
15887: EQUAL
15888: IFFALSE 15919
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
15890: LD_VAR 0 9
15894: PUSH
15895: LD_INT 1
15897: ARRAY
15898: PPUSH
15899: LD_INT 112
15901: PPUSH
15902: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
15906: LD_VAR 0 9
15910: PUSH
15911: LD_INT 1
15913: ARRAY
15914: PPUSH
15915: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
15919: LD_EXP 51
15923: PUSH
15924: LD_VAR 0 2
15928: ARRAY
15929: PUSH
15930: LD_EXP 51
15934: PUSH
15935: LD_VAR 0 2
15939: ARRAY
15940: PUSH
15941: LD_INT 1
15943: ARRAY
15944: PPUSH
15945: CALL_OW 314
15949: NOT
15950: AND
15951: PUSH
15952: LD_EXP 51
15956: PUSH
15957: LD_VAR 0 2
15961: ARRAY
15962: PUSH
15963: LD_INT 1
15965: ARRAY
15966: PPUSH
15967: CALL_OW 310
15971: NOT
15972: AND
15973: IFFALSE 15999
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
15975: LD_EXP 51
15979: PUSH
15980: LD_VAR 0 2
15984: ARRAY
15985: PUSH
15986: LD_INT 1
15988: ARRAY
15989: PPUSH
15990: LD_VAR 0 3
15994: PPUSH
15995: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
15999: LD_EXP 51
16003: PUSH
16004: LD_VAR 0 2
16008: ARRAY
16009: PUSH
16010: LD_INT 1
16012: ARRAY
16013: PPUSH
16014: CALL_OW 310
16018: PUSH
16019: LD_EXP 51
16023: PUSH
16024: LD_VAR 0 2
16028: ARRAY
16029: PUSH
16030: LD_INT 1
16032: ARRAY
16033: PPUSH
16034: CALL_OW 310
16038: PPUSH
16039: CALL_OW 461
16043: PUSH
16044: LD_INT 3
16046: NONEQUAL
16047: AND
16048: IFFALSE 16069
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
16050: LD_EXP 51
16054: PUSH
16055: LD_VAR 0 2
16059: ARRAY
16060: PUSH
16061: LD_INT 1
16063: ARRAY
16064: PPUSH
16065: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
16069: LD_VAR 0 3
16073: PPUSH
16074: CALL_OW 461
16078: PUSH
16079: LD_INT 6
16081: EQUAL
16082: PUSH
16083: LD_VAR 0 6
16087: PUSH
16088: LD_INT 1
16090: GREATER
16091: AND
16092: IFFALSE 16232
// begin sci := [ ] ;
16094: LD_ADDR_VAR 0 8
16098: PUSH
16099: EMPTY
16100: ST_TO_ADDR
// for x in tmp diff j do
16101: LD_ADDR_VAR 0 7
16105: PUSH
16106: LD_VAR 0 6
16110: PUSH
16111: LD_VAR 0 3
16115: DIFF
16116: PUSH
16117: FOR_IN
16118: IFFALSE 16158
// begin if BuildingStatus ( x ) = bs_idle then
16120: LD_VAR 0 7
16124: PPUSH
16125: CALL_OW 461
16129: PUSH
16130: LD_INT 2
16132: EQUAL
16133: IFFALSE 16156
// sci := sci ^ UnitsInside ( x ) ;
16135: LD_ADDR_VAR 0 8
16139: PUSH
16140: LD_VAR 0 8
16144: PUSH
16145: LD_VAR 0 7
16149: PPUSH
16150: CALL_OW 313
16154: ADD
16155: ST_TO_ADDR
// end ;
16156: GO 16117
16158: POP
16159: POP
// if not sci then
16160: LD_VAR 0 8
16164: NOT
16165: IFFALSE 16169
// continue ;
16167: GO 15241
// for x in sci do
16169: LD_ADDR_VAR 0 7
16173: PUSH
16174: LD_VAR 0 8
16178: PUSH
16179: FOR_IN
16180: IFFALSE 16230
// if IsInUnit ( x ) and not HasTask ( x ) then
16182: LD_VAR 0 7
16186: PPUSH
16187: CALL_OW 310
16191: PUSH
16192: LD_VAR 0 7
16196: PPUSH
16197: CALL_OW 314
16201: NOT
16202: AND
16203: IFFALSE 16228
// begin ComExitBuilding ( x ) ;
16205: LD_VAR 0 7
16209: PPUSH
16210: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
16214: LD_VAR 0 7
16218: PPUSH
16219: LD_VAR 0 3
16223: PPUSH
16224: CALL_OW 180
// end ;
16228: GO 16179
16230: POP
16231: POP
// end ; end ;
16232: GO 15241
16234: POP
16235: POP
// end ;
16236: GO 15195
16238: POP
16239: POP
// end ;
16240: LD_VAR 0 1
16244: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
16245: LD_INT 0
16247: PPUSH
16248: PPUSH
// if not mc_bases then
16249: LD_EXP 21
16253: NOT
16254: IFFALSE 16258
// exit ;
16256: GO 16339
// for i = 1 to mc_bases do
16258: LD_ADDR_VAR 0 2
16262: PUSH
16263: DOUBLE
16264: LD_INT 1
16266: DEC
16267: ST_TO_ADDR
16268: LD_EXP 21
16272: PUSH
16273: FOR_TO
16274: IFFALSE 16337
// if mc_mines [ i ] and mc_miners [ i ] then
16276: LD_EXP 34
16280: PUSH
16281: LD_VAR 0 2
16285: ARRAY
16286: PUSH
16287: LD_EXP 35
16291: PUSH
16292: LD_VAR 0 2
16296: ARRAY
16297: AND
16298: IFFALSE 16335
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
16300: LD_EXP 35
16304: PUSH
16305: LD_VAR 0 2
16309: ARRAY
16310: PUSH
16311: LD_INT 1
16313: ARRAY
16314: PPUSH
16315: CALL_OW 255
16319: PPUSH
16320: LD_EXP 34
16324: PUSH
16325: LD_VAR 0 2
16329: ARRAY
16330: PPUSH
16331: CALL 31830 0 2
16335: GO 16273
16337: POP
16338: POP
// end ;
16339: LD_VAR 0 1
16343: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
16344: LD_INT 0
16346: PPUSH
16347: PPUSH
16348: PPUSH
16349: PPUSH
16350: PPUSH
16351: PPUSH
16352: PPUSH
16353: PPUSH
// if not mc_bases or not mc_parking then
16354: LD_EXP 21
16358: NOT
16359: PUSH
16360: LD_EXP 45
16364: NOT
16365: OR
16366: IFFALSE 16370
// exit ;
16368: GO 17082
// for i = 1 to mc_bases do
16370: LD_ADDR_VAR 0 2
16374: PUSH
16375: DOUBLE
16376: LD_INT 1
16378: DEC
16379: ST_TO_ADDR
16380: LD_EXP 21
16384: PUSH
16385: FOR_TO
16386: IFFALSE 17080
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
16388: LD_EXP 21
16392: PUSH
16393: LD_VAR 0 2
16397: ARRAY
16398: NOT
16399: PUSH
16400: LD_EXP 45
16404: PUSH
16405: LD_VAR 0 2
16409: ARRAY
16410: NOT
16411: OR
16412: IFFALSE 16416
// continue ;
16414: GO 16385
// if mc_scan [ i ] then
16416: LD_EXP 44
16420: PUSH
16421: LD_VAR 0 2
16425: ARRAY
16426: IFFALSE 16452
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
16428: LD_ADDR_EXP 33
16432: PUSH
16433: LD_EXP 33
16437: PPUSH
16438: LD_VAR 0 2
16442: PPUSH
16443: EMPTY
16444: PPUSH
16445: CALL_OW 1
16449: ST_TO_ADDR
// continue ;
16450: GO 16385
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
16452: LD_ADDR_VAR 0 5
16456: PUSH
16457: LD_EXP 21
16461: PUSH
16462: LD_VAR 0 2
16466: ARRAY
16467: PUSH
16468: LD_INT 1
16470: ARRAY
16471: PPUSH
16472: CALL_OW 255
16476: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
16477: LD_ADDR_VAR 0 6
16481: PUSH
16482: LD_EXP 21
16486: PUSH
16487: LD_VAR 0 2
16491: ARRAY
16492: PPUSH
16493: LD_INT 30
16495: PUSH
16496: LD_INT 3
16498: PUSH
16499: EMPTY
16500: LIST
16501: LIST
16502: PPUSH
16503: CALL_OW 72
16507: ST_TO_ADDR
// if not fac then
16508: LD_VAR 0 6
16512: NOT
16513: IFFALSE 16564
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
16515: LD_ADDR_VAR 0 6
16519: PUSH
16520: LD_EXP 21
16524: PUSH
16525: LD_VAR 0 2
16529: ARRAY
16530: PPUSH
16531: LD_INT 2
16533: PUSH
16534: LD_INT 30
16536: PUSH
16537: LD_INT 0
16539: PUSH
16540: EMPTY
16541: LIST
16542: LIST
16543: PUSH
16544: LD_INT 30
16546: PUSH
16547: LD_INT 1
16549: PUSH
16550: EMPTY
16551: LIST
16552: LIST
16553: PUSH
16554: EMPTY
16555: LIST
16556: LIST
16557: LIST
16558: PPUSH
16559: CALL_OW 72
16563: ST_TO_ADDR
// if not fac then
16564: LD_VAR 0 6
16568: NOT
16569: IFFALSE 16573
// continue ;
16571: GO 16385
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
16573: LD_ADDR_VAR 0 7
16577: PUSH
16578: LD_EXP 45
16582: PUSH
16583: LD_VAR 0 2
16587: ARRAY
16588: PPUSH
16589: LD_INT 22
16591: PUSH
16592: LD_VAR 0 5
16596: PUSH
16597: EMPTY
16598: LIST
16599: LIST
16600: PUSH
16601: LD_INT 21
16603: PUSH
16604: LD_INT 2
16606: PUSH
16607: EMPTY
16608: LIST
16609: LIST
16610: PUSH
16611: LD_INT 3
16613: PUSH
16614: LD_INT 24
16616: PUSH
16617: LD_INT 1000
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: PUSH
16628: EMPTY
16629: LIST
16630: LIST
16631: LIST
16632: PPUSH
16633: CALL_OW 70
16637: PUSH
16638: LD_INT 22
16640: PUSH
16641: LD_VAR 0 5
16645: PUSH
16646: EMPTY
16647: LIST
16648: LIST
16649: PUSH
16650: LD_INT 91
16652: PUSH
16653: LD_VAR 0 6
16657: PUSH
16658: LD_INT 1
16660: ARRAY
16661: PUSH
16662: LD_INT 25
16664: PUSH
16665: EMPTY
16666: LIST
16667: LIST
16668: LIST
16669: PUSH
16670: LD_INT 21
16672: PUSH
16673: LD_INT 2
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 3
16682: PUSH
16683: LD_INT 24
16685: PUSH
16686: LD_INT 1000
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 69
16707: UNION
16708: ST_TO_ADDR
// if not vehs then
16709: LD_VAR 0 7
16713: NOT
16714: IFFALSE 16740
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
16716: LD_ADDR_EXP 33
16720: PUSH
16721: LD_EXP 33
16725: PPUSH
16726: LD_VAR 0 2
16730: PPUSH
16731: EMPTY
16732: PPUSH
16733: CALL_OW 1
16737: ST_TO_ADDR
// continue ;
16738: GO 16385
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
16740: LD_ADDR_VAR 0 8
16744: PUSH
16745: LD_EXP 21
16749: PUSH
16750: LD_VAR 0 2
16754: ARRAY
16755: PPUSH
16756: LD_INT 30
16758: PUSH
16759: LD_INT 3
16761: PUSH
16762: EMPTY
16763: LIST
16764: LIST
16765: PPUSH
16766: CALL_OW 72
16770: ST_TO_ADDR
// if tmp then
16771: LD_VAR 0 8
16775: IFFALSE 16878
// begin for j in tmp do
16777: LD_ADDR_VAR 0 3
16781: PUSH
16782: LD_VAR 0 8
16786: PUSH
16787: FOR_IN
16788: IFFALSE 16876
// for k in UnitsInside ( j ) do
16790: LD_ADDR_VAR 0 4
16794: PUSH
16795: LD_VAR 0 3
16799: PPUSH
16800: CALL_OW 313
16804: PUSH
16805: FOR_IN
16806: IFFALSE 16872
// if k then
16808: LD_VAR 0 4
16812: IFFALSE 16870
// if not k in mc_repair_vehicle [ i ] then
16814: LD_VAR 0 4
16818: PUSH
16819: LD_EXP 33
16823: PUSH
16824: LD_VAR 0 2
16828: ARRAY
16829: IN
16830: NOT
16831: IFFALSE 16870
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
16833: LD_ADDR_EXP 33
16837: PUSH
16838: LD_EXP 33
16842: PPUSH
16843: LD_VAR 0 2
16847: PPUSH
16848: LD_EXP 33
16852: PUSH
16853: LD_VAR 0 2
16857: ARRAY
16858: PUSH
16859: LD_VAR 0 4
16863: UNION
16864: PPUSH
16865: CALL_OW 1
16869: ST_TO_ADDR
16870: GO 16805
16872: POP
16873: POP
16874: GO 16787
16876: POP
16877: POP
// end ; if not mc_repair_vehicle [ i ] then
16878: LD_EXP 33
16882: PUSH
16883: LD_VAR 0 2
16887: ARRAY
16888: NOT
16889: IFFALSE 16893
// continue ;
16891: GO 16385
// for j in mc_repair_vehicle [ i ] do
16893: LD_ADDR_VAR 0 3
16897: PUSH
16898: LD_EXP 33
16902: PUSH
16903: LD_VAR 0 2
16907: ARRAY
16908: PUSH
16909: FOR_IN
16910: IFFALSE 17076
// begin if GetClass ( j ) <> 3 then
16912: LD_VAR 0 3
16916: PPUSH
16917: CALL_OW 257
16921: PUSH
16922: LD_INT 3
16924: NONEQUAL
16925: IFFALSE 16966
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
16927: LD_ADDR_EXP 33
16931: PUSH
16932: LD_EXP 33
16936: PPUSH
16937: LD_VAR 0 2
16941: PPUSH
16942: LD_EXP 33
16946: PUSH
16947: LD_VAR 0 2
16951: ARRAY
16952: PUSH
16953: LD_VAR 0 3
16957: DIFF
16958: PPUSH
16959: CALL_OW 1
16963: ST_TO_ADDR
// continue ;
16964: GO 16909
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
16966: LD_VAR 0 3
16970: PPUSH
16971: CALL_OW 311
16975: NOT
16976: PUSH
16977: LD_VAR 0 3
16981: PUSH
16982: LD_EXP 24
16986: PUSH
16987: LD_VAR 0 2
16991: ARRAY
16992: PUSH
16993: LD_INT 1
16995: ARRAY
16996: IN
16997: NOT
16998: AND
16999: PUSH
17000: LD_VAR 0 3
17004: PUSH
17005: LD_EXP 24
17009: PUSH
17010: LD_VAR 0 2
17014: ARRAY
17015: PUSH
17016: LD_INT 2
17018: ARRAY
17019: IN
17020: NOT
17021: AND
17022: IFFALSE 17074
// begin if IsInUnit ( j ) then
17024: LD_VAR 0 3
17028: PPUSH
17029: CALL_OW 310
17033: IFFALSE 17044
// ComExitBuilding ( j ) ;
17035: LD_VAR 0 3
17039: PPUSH
17040: CALL_OW 122
// if not HasTask ( j ) then
17044: LD_VAR 0 3
17048: PPUSH
17049: CALL_OW 314
17053: NOT
17054: IFFALSE 17074
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
17056: LD_VAR 0 3
17060: PPUSH
17061: LD_VAR 0 7
17065: PUSH
17066: LD_INT 1
17068: ARRAY
17069: PPUSH
17070: CALL_OW 189
// end ; end ;
17074: GO 16909
17076: POP
17077: POP
// end ;
17078: GO 16385
17080: POP
17081: POP
// end ;
17082: LD_VAR 0 1
17086: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
17087: LD_INT 0
17089: PPUSH
17090: PPUSH
17091: PPUSH
17092: PPUSH
17093: PPUSH
17094: PPUSH
17095: PPUSH
17096: PPUSH
17097: PPUSH
17098: PPUSH
17099: PPUSH
// if not mc_bases then
17100: LD_EXP 21
17104: NOT
17105: IFFALSE 17109
// exit ;
17107: GO 17911
// for i = 1 to mc_bases do
17109: LD_ADDR_VAR 0 2
17113: PUSH
17114: DOUBLE
17115: LD_INT 1
17117: DEC
17118: ST_TO_ADDR
17119: LD_EXP 21
17123: PUSH
17124: FOR_TO
17125: IFFALSE 17909
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
17127: LD_EXP 49
17131: PUSH
17132: LD_VAR 0 2
17136: ARRAY
17137: NOT
17138: PUSH
17139: LD_EXP 24
17143: PUSH
17144: LD_VAR 0 2
17148: ARRAY
17149: PUSH
17150: LD_INT 1
17152: ARRAY
17153: OR
17154: PUSH
17155: LD_EXP 24
17159: PUSH
17160: LD_VAR 0 2
17164: ARRAY
17165: PUSH
17166: LD_INT 2
17168: ARRAY
17169: OR
17170: PUSH
17171: LD_EXP 47
17175: PUSH
17176: LD_VAR 0 2
17180: ARRAY
17181: PPUSH
17182: LD_INT 1
17184: PPUSH
17185: CALL_OW 325
17189: NOT
17190: OR
17191: PUSH
17192: LD_EXP 44
17196: PUSH
17197: LD_VAR 0 2
17201: ARRAY
17202: OR
17203: IFFALSE 17207
// continue ;
17205: GO 17124
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
17207: LD_ADDR_VAR 0 8
17211: PUSH
17212: LD_EXP 21
17216: PUSH
17217: LD_VAR 0 2
17221: ARRAY
17222: PPUSH
17223: LD_INT 25
17225: PUSH
17226: LD_INT 4
17228: PUSH
17229: EMPTY
17230: LIST
17231: LIST
17232: PUSH
17233: LD_INT 50
17235: PUSH
17236: EMPTY
17237: LIST
17238: PUSH
17239: LD_INT 3
17241: PUSH
17242: LD_INT 60
17244: PUSH
17245: EMPTY
17246: LIST
17247: PUSH
17248: EMPTY
17249: LIST
17250: LIST
17251: PUSH
17252: EMPTY
17253: LIST
17254: LIST
17255: LIST
17256: PPUSH
17257: CALL_OW 72
17261: PUSH
17262: LD_EXP 25
17266: PUSH
17267: LD_VAR 0 2
17271: ARRAY
17272: DIFF
17273: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
17274: LD_ADDR_VAR 0 9
17278: PUSH
17279: LD_EXP 21
17283: PUSH
17284: LD_VAR 0 2
17288: ARRAY
17289: PPUSH
17290: LD_INT 2
17292: PUSH
17293: LD_INT 30
17295: PUSH
17296: LD_INT 0
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 30
17305: PUSH
17306: LD_INT 1
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: PUSH
17313: EMPTY
17314: LIST
17315: LIST
17316: LIST
17317: PPUSH
17318: CALL_OW 72
17322: ST_TO_ADDR
// if not tmp or not dep then
17323: LD_VAR 0 8
17327: NOT
17328: PUSH
17329: LD_VAR 0 9
17333: NOT
17334: OR
17335: IFFALSE 17339
// continue ;
17337: GO 17124
// side := GetSide ( tmp [ 1 ] ) ;
17339: LD_ADDR_VAR 0 11
17343: PUSH
17344: LD_VAR 0 8
17348: PUSH
17349: LD_INT 1
17351: ARRAY
17352: PPUSH
17353: CALL_OW 255
17357: ST_TO_ADDR
// dep := dep [ 1 ] ;
17358: LD_ADDR_VAR 0 9
17362: PUSH
17363: LD_VAR 0 9
17367: PUSH
17368: LD_INT 1
17370: ARRAY
17371: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
17372: LD_ADDR_VAR 0 7
17376: PUSH
17377: LD_EXP 49
17381: PUSH
17382: LD_VAR 0 2
17386: ARRAY
17387: PPUSH
17388: LD_INT 22
17390: PUSH
17391: LD_INT 0
17393: PUSH
17394: EMPTY
17395: LIST
17396: LIST
17397: PUSH
17398: LD_INT 25
17400: PUSH
17401: LD_INT 12
17403: PUSH
17404: EMPTY
17405: LIST
17406: LIST
17407: PUSH
17408: EMPTY
17409: LIST
17410: LIST
17411: PPUSH
17412: CALL_OW 70
17416: PUSH
17417: LD_INT 22
17419: PUSH
17420: LD_INT 0
17422: PUSH
17423: EMPTY
17424: LIST
17425: LIST
17426: PUSH
17427: LD_INT 25
17429: PUSH
17430: LD_INT 12
17432: PUSH
17433: EMPTY
17434: LIST
17435: LIST
17436: PUSH
17437: LD_INT 91
17439: PUSH
17440: LD_VAR 0 9
17444: PUSH
17445: LD_INT 20
17447: PUSH
17448: EMPTY
17449: LIST
17450: LIST
17451: LIST
17452: PUSH
17453: EMPTY
17454: LIST
17455: LIST
17456: LIST
17457: PPUSH
17458: CALL_OW 69
17462: UNION
17463: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
17464: LD_ADDR_VAR 0 10
17468: PUSH
17469: LD_EXP 49
17473: PUSH
17474: LD_VAR 0 2
17478: ARRAY
17479: PPUSH
17480: LD_INT 81
17482: PUSH
17483: LD_VAR 0 11
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: CALL_OW 70
17496: ST_TO_ADDR
// if not apes or danger_at_area then
17497: LD_VAR 0 7
17501: NOT
17502: PUSH
17503: LD_VAR 0 10
17507: OR
17508: IFFALSE 17558
// begin if mc_taming [ i ] then
17510: LD_EXP 52
17514: PUSH
17515: LD_VAR 0 2
17519: ARRAY
17520: IFFALSE 17556
// begin MC_Reset ( i , 121 ) ;
17522: LD_VAR 0 2
17526: PPUSH
17527: LD_INT 121
17529: PPUSH
17530: CALL 3581 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
17534: LD_ADDR_EXP 52
17538: PUSH
17539: LD_EXP 52
17543: PPUSH
17544: LD_VAR 0 2
17548: PPUSH
17549: EMPTY
17550: PPUSH
17551: CALL_OW 1
17555: ST_TO_ADDR
// end ; continue ;
17556: GO 17124
// end ; for j in tmp do
17558: LD_ADDR_VAR 0 3
17562: PUSH
17563: LD_VAR 0 8
17567: PUSH
17568: FOR_IN
17569: IFFALSE 17905
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
17571: LD_VAR 0 3
17575: PUSH
17576: LD_EXP 52
17580: PUSH
17581: LD_VAR 0 2
17585: ARRAY
17586: IN
17587: NOT
17588: PUSH
17589: LD_EXP 52
17593: PUSH
17594: LD_VAR 0 2
17598: ARRAY
17599: PUSH
17600: LD_INT 3
17602: LESS
17603: AND
17604: IFFALSE 17662
// begin SetTag ( j , 121 ) ;
17606: LD_VAR 0 3
17610: PPUSH
17611: LD_INT 121
17613: PPUSH
17614: CALL_OW 109
// mc_taming := Add ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
17618: LD_ADDR_EXP 52
17622: PUSH
17623: LD_EXP 52
17627: PPUSH
17628: LD_VAR 0 2
17632: PUSH
17633: LD_EXP 52
17637: PUSH
17638: LD_VAR 0 2
17642: ARRAY
17643: PUSH
17644: LD_INT 1
17646: PLUS
17647: PUSH
17648: EMPTY
17649: LIST
17650: LIST
17651: PPUSH
17652: LD_VAR 0 3
17656: PPUSH
17657: CALL 35208 0 3
17661: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
17662: LD_VAR 0 3
17666: PUSH
17667: LD_EXP 52
17671: PUSH
17672: LD_VAR 0 2
17676: ARRAY
17677: IN
17678: IFFALSE 17903
// begin if GetClass ( j ) <> 4 then
17680: LD_VAR 0 3
17684: PPUSH
17685: CALL_OW 257
17689: PUSH
17690: LD_INT 4
17692: NONEQUAL
17693: IFFALSE 17746
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
17695: LD_ADDR_EXP 52
17699: PUSH
17700: LD_EXP 52
17704: PPUSH
17705: LD_VAR 0 2
17709: PPUSH
17710: LD_EXP 52
17714: PUSH
17715: LD_VAR 0 2
17719: ARRAY
17720: PUSH
17721: LD_VAR 0 3
17725: DIFF
17726: PPUSH
17727: CALL_OW 1
17731: ST_TO_ADDR
// SetTag ( j , 0 ) ;
17732: LD_VAR 0 3
17736: PPUSH
17737: LD_INT 0
17739: PPUSH
17740: CALL_OW 109
// continue ;
17744: GO 17568
// end ; if IsInUnit ( j ) then
17746: LD_VAR 0 3
17750: PPUSH
17751: CALL_OW 310
17755: IFFALSE 17766
// ComExitBuilding ( j ) ;
17757: LD_VAR 0 3
17761: PPUSH
17762: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
17766: LD_ADDR_VAR 0 6
17770: PUSH
17771: LD_VAR 0 7
17775: PPUSH
17776: LD_VAR 0 3
17780: PPUSH
17781: CALL_OW 74
17785: ST_TO_ADDR
// if not ape then
17786: LD_VAR 0 6
17790: NOT
17791: IFFALSE 17795
// break ;
17793: GO 17905
// x := GetX ( ape ) ;
17795: LD_ADDR_VAR 0 4
17799: PUSH
17800: LD_VAR 0 6
17804: PPUSH
17805: CALL_OW 250
17809: ST_TO_ADDR
// y := GetY ( ape ) ;
17810: LD_ADDR_VAR 0 5
17814: PUSH
17815: LD_VAR 0 6
17819: PPUSH
17820: CALL_OW 251
17824: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
17825: LD_VAR 0 4
17829: PPUSH
17830: LD_VAR 0 5
17834: PPUSH
17835: CALL_OW 488
17839: NOT
17840: PUSH
17841: LD_VAR 0 11
17845: PPUSH
17846: LD_VAR 0 4
17850: PPUSH
17851: LD_VAR 0 5
17855: PPUSH
17856: LD_INT 20
17858: PPUSH
17859: CALL 35702 0 4
17863: PUSH
17864: LD_INT 4
17866: ARRAY
17867: OR
17868: IFFALSE 17872
// break ;
17870: GO 17905
// if not HasTask ( j ) then
17872: LD_VAR 0 3
17876: PPUSH
17877: CALL_OW 314
17881: NOT
17882: IFFALSE 17903
// ComTameXY ( j , x , y ) ;
17884: LD_VAR 0 3
17888: PPUSH
17889: LD_VAR 0 4
17893: PPUSH
17894: LD_VAR 0 5
17898: PPUSH
17899: CALL_OW 131
// end ; end ;
17903: GO 17568
17905: POP
17906: POP
// end ;
17907: GO 17124
17909: POP
17910: POP
// end ;
17911: LD_VAR 0 1
17915: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
17916: LD_INT 0
17918: PPUSH
17919: PPUSH
17920: PPUSH
17921: PPUSH
17922: PPUSH
17923: PPUSH
17924: PPUSH
17925: PPUSH
// if not mc_bases then
17926: LD_EXP 21
17930: NOT
17931: IFFALSE 17935
// exit ;
17933: GO 18561
// for i = 1 to mc_bases do
17935: LD_ADDR_VAR 0 2
17939: PUSH
17940: DOUBLE
17941: LD_INT 1
17943: DEC
17944: ST_TO_ADDR
17945: LD_EXP 21
17949: PUSH
17950: FOR_TO
17951: IFFALSE 18559
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
17953: LD_EXP 50
17957: PUSH
17958: LD_VAR 0 2
17962: ARRAY
17963: NOT
17964: PUSH
17965: LD_EXP 50
17969: PUSH
17970: LD_VAR 0 2
17974: ARRAY
17975: PPUSH
17976: LD_INT 25
17978: PUSH
17979: LD_INT 12
17981: PUSH
17982: EMPTY
17983: LIST
17984: LIST
17985: PPUSH
17986: CALL_OW 72
17990: NOT
17991: OR
17992: IFFALSE 17996
// continue ;
17994: GO 17950
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
17996: LD_ADDR_VAR 0 5
18000: PUSH
18001: LD_EXP 50
18005: PUSH
18006: LD_VAR 0 2
18010: ARRAY
18011: PUSH
18012: LD_INT 1
18014: ARRAY
18015: PPUSH
18016: CALL_OW 255
18020: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
18021: LD_VAR 0 5
18025: PPUSH
18026: LD_INT 2
18028: PPUSH
18029: CALL_OW 325
18033: IFFALSE 18286
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
18035: LD_ADDR_VAR 0 4
18039: PUSH
18040: LD_EXP 50
18044: PUSH
18045: LD_VAR 0 2
18049: ARRAY
18050: PPUSH
18051: LD_INT 25
18053: PUSH
18054: LD_INT 16
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: PPUSH
18061: CALL_OW 72
18065: ST_TO_ADDR
// if tmp < 6 then
18066: LD_VAR 0 4
18070: PUSH
18071: LD_INT 6
18073: LESS
18074: IFFALSE 18286
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
18076: LD_ADDR_VAR 0 6
18080: PUSH
18081: LD_EXP 21
18085: PUSH
18086: LD_VAR 0 2
18090: ARRAY
18091: PPUSH
18092: LD_INT 2
18094: PUSH
18095: LD_INT 30
18097: PUSH
18098: LD_INT 0
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: PUSH
18105: LD_INT 30
18107: PUSH
18108: LD_INT 1
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: PUSH
18115: EMPTY
18116: LIST
18117: LIST
18118: LIST
18119: PPUSH
18120: CALL_OW 72
18124: ST_TO_ADDR
// if depot then
18125: LD_VAR 0 6
18129: IFFALSE 18286
// begin selected := 0 ;
18131: LD_ADDR_VAR 0 7
18135: PUSH
18136: LD_INT 0
18138: ST_TO_ADDR
// for j in depot do
18139: LD_ADDR_VAR 0 3
18143: PUSH
18144: LD_VAR 0 6
18148: PUSH
18149: FOR_IN
18150: IFFALSE 18181
// begin if UnitsInside ( j ) < 6 then
18152: LD_VAR 0 3
18156: PPUSH
18157: CALL_OW 313
18161: PUSH
18162: LD_INT 6
18164: LESS
18165: IFFALSE 18179
// begin selected := j ;
18167: LD_ADDR_VAR 0 7
18171: PUSH
18172: LD_VAR 0 3
18176: ST_TO_ADDR
// break ;
18177: GO 18181
// end ; end ;
18179: GO 18149
18181: POP
18182: POP
// if selected then
18183: LD_VAR 0 7
18187: IFFALSE 18286
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
18189: LD_ADDR_VAR 0 3
18193: PUSH
18194: LD_EXP 50
18198: PUSH
18199: LD_VAR 0 2
18203: ARRAY
18204: PPUSH
18205: LD_INT 25
18207: PUSH
18208: LD_INT 12
18210: PUSH
18211: EMPTY
18212: LIST
18213: LIST
18214: PPUSH
18215: CALL_OW 72
18219: PUSH
18220: FOR_IN
18221: IFFALSE 18284
// if not HasTask ( j ) then
18223: LD_VAR 0 3
18227: PPUSH
18228: CALL_OW 314
18232: NOT
18233: IFFALSE 18282
// begin if not IsInUnit ( j ) then
18235: LD_VAR 0 3
18239: PPUSH
18240: CALL_OW 310
18244: NOT
18245: IFFALSE 18261
// ComEnterUnit ( j , selected ) ;
18247: LD_VAR 0 3
18251: PPUSH
18252: LD_VAR 0 7
18256: PPUSH
18257: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
18261: LD_VAR 0 3
18265: PPUSH
18266: LD_INT 16
18268: PPUSH
18269: CALL_OW 183
// AddComExitBuilding ( j ) ;
18273: LD_VAR 0 3
18277: PPUSH
18278: CALL_OW 182
// end ;
18282: GO 18220
18284: POP
18285: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
18286: LD_VAR 0 5
18290: PPUSH
18291: LD_INT 11
18293: PPUSH
18294: CALL_OW 325
18298: IFFALSE 18557
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
18300: LD_ADDR_VAR 0 4
18304: PUSH
18305: LD_EXP 50
18309: PUSH
18310: LD_VAR 0 2
18314: ARRAY
18315: PPUSH
18316: LD_INT 25
18318: PUSH
18319: LD_INT 16
18321: PUSH
18322: EMPTY
18323: LIST
18324: LIST
18325: PPUSH
18326: CALL_OW 72
18330: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
18331: LD_VAR 0 4
18335: PUSH
18336: LD_INT 6
18338: GREATEREQUAL
18339: PUSH
18340: LD_VAR 0 5
18344: PPUSH
18345: LD_INT 2
18347: PPUSH
18348: CALL_OW 325
18352: NOT
18353: OR
18354: IFFALSE 18557
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
18356: LD_ADDR_VAR 0 8
18360: PUSH
18361: LD_EXP 21
18365: PUSH
18366: LD_VAR 0 2
18370: ARRAY
18371: PPUSH
18372: LD_INT 2
18374: PUSH
18375: LD_INT 30
18377: PUSH
18378: LD_INT 4
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: PUSH
18385: LD_INT 30
18387: PUSH
18388: LD_INT 5
18390: PUSH
18391: EMPTY
18392: LIST
18393: LIST
18394: PUSH
18395: EMPTY
18396: LIST
18397: LIST
18398: LIST
18399: PPUSH
18400: CALL_OW 72
18404: ST_TO_ADDR
// if barracks then
18405: LD_VAR 0 8
18409: IFFALSE 18557
// begin selected := 0 ;
18411: LD_ADDR_VAR 0 7
18415: PUSH
18416: LD_INT 0
18418: ST_TO_ADDR
// for j in barracks do
18419: LD_ADDR_VAR 0 3
18423: PUSH
18424: LD_VAR 0 8
18428: PUSH
18429: FOR_IN
18430: IFFALSE 18461
// begin if UnitsInside ( j ) < 6 then
18432: LD_VAR 0 3
18436: PPUSH
18437: CALL_OW 313
18441: PUSH
18442: LD_INT 6
18444: LESS
18445: IFFALSE 18459
// begin selected := j ;
18447: LD_ADDR_VAR 0 7
18451: PUSH
18452: LD_VAR 0 3
18456: ST_TO_ADDR
// break ;
18457: GO 18461
// end ; end ;
18459: GO 18429
18461: POP
18462: POP
// if selected then
18463: LD_VAR 0 7
18467: IFFALSE 18557
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
18469: LD_ADDR_VAR 0 3
18473: PUSH
18474: LD_EXP 50
18478: PUSH
18479: LD_VAR 0 2
18483: ARRAY
18484: PPUSH
18485: LD_INT 25
18487: PUSH
18488: LD_INT 12
18490: PUSH
18491: EMPTY
18492: LIST
18493: LIST
18494: PPUSH
18495: CALL_OW 72
18499: PUSH
18500: FOR_IN
18501: IFFALSE 18555
// if not IsInUnit ( j ) and not HasTask ( j ) then
18503: LD_VAR 0 3
18507: PPUSH
18508: CALL_OW 310
18512: NOT
18513: PUSH
18514: LD_VAR 0 3
18518: PPUSH
18519: CALL_OW 314
18523: NOT
18524: AND
18525: IFFALSE 18553
// begin ComEnterUnit ( j , selected ) ;
18527: LD_VAR 0 3
18531: PPUSH
18532: LD_VAR 0 7
18536: PPUSH
18537: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
18541: LD_VAR 0 3
18545: PPUSH
18546: LD_INT 15
18548: PPUSH
18549: CALL_OW 183
// end ;
18553: GO 18500
18555: POP
18556: POP
// end ; end ; end ; end ; end ;
18557: GO 17950
18559: POP
18560: POP
// end ;
18561: LD_VAR 0 1
18565: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
18566: LD_INT 0
18568: PPUSH
18569: PPUSH
18570: PPUSH
18571: PPUSH
// if not mc_bases then
18572: LD_EXP 21
18576: NOT
18577: IFFALSE 18581
// exit ;
18579: GO 18759
// for i = 1 to mc_bases do
18581: LD_ADDR_VAR 0 2
18585: PUSH
18586: DOUBLE
18587: LD_INT 1
18589: DEC
18590: ST_TO_ADDR
18591: LD_EXP 21
18595: PUSH
18596: FOR_TO
18597: IFFALSE 18757
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
18599: LD_ADDR_VAR 0 4
18603: PUSH
18604: LD_EXP 21
18608: PUSH
18609: LD_VAR 0 2
18613: ARRAY
18614: PPUSH
18615: LD_INT 25
18617: PUSH
18618: LD_INT 9
18620: PUSH
18621: EMPTY
18622: LIST
18623: LIST
18624: PPUSH
18625: CALL_OW 72
18629: ST_TO_ADDR
// if not tmp then
18630: LD_VAR 0 4
18634: NOT
18635: IFFALSE 18639
// continue ;
18637: GO 18596
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
18639: LD_EXP 47
18643: PUSH
18644: LD_VAR 0 2
18648: ARRAY
18649: PPUSH
18650: LD_INT 29
18652: PPUSH
18653: CALL_OW 325
18657: NOT
18658: PUSH
18659: LD_EXP 47
18663: PUSH
18664: LD_VAR 0 2
18668: ARRAY
18669: PPUSH
18670: LD_INT 28
18672: PPUSH
18673: CALL_OW 325
18677: NOT
18678: AND
18679: IFFALSE 18683
// continue ;
18681: GO 18596
// for j in tmp do
18683: LD_ADDR_VAR 0 3
18687: PUSH
18688: LD_VAR 0 4
18692: PUSH
18693: FOR_IN
18694: IFFALSE 18753
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
18696: LD_VAR 0 3
18700: PUSH
18701: LD_EXP 24
18705: PUSH
18706: LD_VAR 0 2
18710: ARRAY
18711: PUSH
18712: LD_INT 1
18714: ARRAY
18715: IN
18716: NOT
18717: PUSH
18718: LD_VAR 0 3
18722: PUSH
18723: LD_EXP 24
18727: PUSH
18728: LD_VAR 0 2
18732: ARRAY
18733: PUSH
18734: LD_INT 2
18736: ARRAY
18737: IN
18738: NOT
18739: AND
18740: IFFALSE 18751
// ComSpaceTimeShoot ( j ) ;
18742: LD_VAR 0 3
18746: PPUSH
18747: CALL 28833 0 1
18751: GO 18693
18753: POP
18754: POP
// end ;
18755: GO 18596
18757: POP
18758: POP
// end ;
18759: LD_VAR 0 1
18763: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
18764: LD_INT 0
18766: PPUSH
18767: PPUSH
18768: PPUSH
18769: PPUSH
18770: PPUSH
18771: PPUSH
18772: PPUSH
18773: PPUSH
18774: PPUSH
// if not mc_bases then
18775: LD_EXP 21
18779: NOT
18780: IFFALSE 18784
// exit ;
18782: GO 19406
// for i = 1 to mc_bases do
18784: LD_ADDR_VAR 0 2
18788: PUSH
18789: DOUBLE
18790: LD_INT 1
18792: DEC
18793: ST_TO_ADDR
18794: LD_EXP 21
18798: PUSH
18799: FOR_TO
18800: IFFALSE 19404
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
18802: LD_EXP 56
18806: PUSH
18807: LD_VAR 0 2
18811: ARRAY
18812: NOT
18813: PUSH
18814: LD_INT 38
18816: PPUSH
18817: LD_EXP 47
18821: PUSH
18822: LD_VAR 0 2
18826: ARRAY
18827: PPUSH
18828: CALL_OW 321
18832: PUSH
18833: LD_INT 2
18835: NONEQUAL
18836: OR
18837: IFFALSE 18841
// continue ;
18839: GO 18799
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
18841: LD_ADDR_VAR 0 8
18845: PUSH
18846: LD_EXP 21
18850: PUSH
18851: LD_VAR 0 2
18855: ARRAY
18856: PPUSH
18857: LD_INT 30
18859: PUSH
18860: LD_INT 34
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: PPUSH
18867: CALL_OW 72
18871: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
18872: LD_ADDR_VAR 0 9
18876: PUSH
18877: LD_EXP 21
18881: PUSH
18882: LD_VAR 0 2
18886: ARRAY
18887: PPUSH
18888: LD_INT 25
18890: PUSH
18891: LD_INT 4
18893: PUSH
18894: EMPTY
18895: LIST
18896: LIST
18897: PPUSH
18898: CALL_OW 72
18902: PPUSH
18903: LD_INT 0
18905: PPUSH
18906: CALL 67816 0 2
18910: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
18911: LD_VAR 0 9
18915: NOT
18916: PUSH
18917: LD_VAR 0 8
18921: NOT
18922: OR
18923: PUSH
18924: LD_EXP 21
18928: PUSH
18929: LD_VAR 0 2
18933: ARRAY
18934: PPUSH
18935: LD_INT 124
18937: PPUSH
18938: CALL 67816 0 2
18942: OR
18943: IFFALSE 18947
// continue ;
18945: GO 18799
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
18947: LD_EXP 57
18951: PUSH
18952: LD_VAR 0 2
18956: ARRAY
18957: PUSH
18958: LD_EXP 56
18962: PUSH
18963: LD_VAR 0 2
18967: ARRAY
18968: LESS
18969: PUSH
18970: LD_EXP 57
18974: PUSH
18975: LD_VAR 0 2
18979: ARRAY
18980: PUSH
18981: LD_VAR 0 8
18985: LESS
18986: AND
18987: IFFALSE 19402
// begin tmp := sci [ 1 ] ;
18989: LD_ADDR_VAR 0 7
18993: PUSH
18994: LD_VAR 0 9
18998: PUSH
18999: LD_INT 1
19001: ARRAY
19002: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
19003: LD_VAR 0 7
19007: PPUSH
19008: LD_INT 124
19010: PPUSH
19011: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
19015: LD_ADDR_VAR 0 3
19019: PUSH
19020: DOUBLE
19021: LD_EXP 56
19025: PUSH
19026: LD_VAR 0 2
19030: ARRAY
19031: INC
19032: ST_TO_ADDR
19033: LD_EXP 56
19037: PUSH
19038: LD_VAR 0 2
19042: ARRAY
19043: PUSH
19044: FOR_DOWNTO
19045: IFFALSE 19388
// begin if IsInUnit ( tmp ) then
19047: LD_VAR 0 7
19051: PPUSH
19052: CALL_OW 310
19056: IFFALSE 19067
// ComExitBuilding ( tmp ) ;
19058: LD_VAR 0 7
19062: PPUSH
19063: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
19067: LD_INT 35
19069: PPUSH
19070: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
19074: LD_VAR 0 7
19078: PPUSH
19079: CALL_OW 310
19083: NOT
19084: PUSH
19085: LD_VAR 0 7
19089: PPUSH
19090: CALL_OW 314
19094: NOT
19095: AND
19096: IFFALSE 19067
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
19098: LD_ADDR_VAR 0 6
19102: PUSH
19103: LD_VAR 0 7
19107: PPUSH
19108: CALL_OW 250
19112: PUSH
19113: LD_VAR 0 7
19117: PPUSH
19118: CALL_OW 251
19122: PUSH
19123: EMPTY
19124: LIST
19125: LIST
19126: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19127: LD_INT 35
19129: PPUSH
19130: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
19134: LD_ADDR_VAR 0 4
19138: PUSH
19139: LD_EXP 56
19143: PUSH
19144: LD_VAR 0 2
19148: ARRAY
19149: PUSH
19150: LD_VAR 0 3
19154: ARRAY
19155: PUSH
19156: LD_INT 1
19158: ARRAY
19159: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
19160: LD_ADDR_VAR 0 5
19164: PUSH
19165: LD_EXP 56
19169: PUSH
19170: LD_VAR 0 2
19174: ARRAY
19175: PUSH
19176: LD_VAR 0 3
19180: ARRAY
19181: PUSH
19182: LD_INT 2
19184: ARRAY
19185: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
19186: LD_VAR 0 7
19190: PPUSH
19191: LD_INT 10
19193: PPUSH
19194: CALL 37399 0 2
19198: PUSH
19199: LD_INT 4
19201: ARRAY
19202: IFFALSE 19240
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
19204: LD_VAR 0 7
19208: PPUSH
19209: LD_VAR 0 6
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: LD_VAR 0 6
19222: PUSH
19223: LD_INT 2
19225: ARRAY
19226: PPUSH
19227: CALL_OW 111
// wait ( 0 0$10 ) ;
19231: LD_INT 350
19233: PPUSH
19234: CALL_OW 67
// end else
19238: GO 19266
// begin ComMoveXY ( tmp , x , y ) ;
19240: LD_VAR 0 7
19244: PPUSH
19245: LD_VAR 0 4
19249: PPUSH
19250: LD_VAR 0 5
19254: PPUSH
19255: CALL_OW 111
// wait ( 0 0$3 ) ;
19259: LD_INT 105
19261: PPUSH
19262: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
19266: LD_VAR 0 7
19270: PPUSH
19271: LD_VAR 0 4
19275: PPUSH
19276: LD_VAR 0 5
19280: PPUSH
19281: CALL_OW 307
19285: IFFALSE 19127
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
19287: LD_VAR 0 7
19291: PPUSH
19292: LD_VAR 0 4
19296: PPUSH
19297: LD_VAR 0 5
19301: PPUSH
19302: LD_VAR 0 8
19306: PUSH
19307: LD_VAR 0 3
19311: ARRAY
19312: PPUSH
19313: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
19317: LD_INT 35
19319: PPUSH
19320: CALL_OW 67
// until not HasTask ( tmp ) ;
19324: LD_VAR 0 7
19328: PPUSH
19329: CALL_OW 314
19333: NOT
19334: IFFALSE 19317
// mc_teleport_exit_set := Add ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
19336: LD_ADDR_EXP 57
19340: PUSH
19341: LD_EXP 57
19345: PPUSH
19346: LD_VAR 0 2
19350: PUSH
19351: LD_EXP 57
19355: PUSH
19356: LD_VAR 0 2
19360: ARRAY
19361: PUSH
19362: LD_INT 1
19364: PLUS
19365: PUSH
19366: EMPTY
19367: LIST
19368: LIST
19369: PPUSH
19370: LD_VAR 0 8
19374: PUSH
19375: LD_VAR 0 3
19379: ARRAY
19380: PPUSH
19381: CALL 35208 0 3
19385: ST_TO_ADDR
// end ;
19386: GO 19044
19388: POP
19389: POP
// MC_Reset ( i , 124 ) ;
19390: LD_VAR 0 2
19394: PPUSH
19395: LD_INT 124
19397: PPUSH
19398: CALL 3581 0 2
// end ; end ;
19402: GO 18799
19404: POP
19405: POP
// end ;
19406: LD_VAR 0 1
19410: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
19411: LD_INT 0
19413: PPUSH
19414: PPUSH
19415: PPUSH
// if not mc_bases then
19416: LD_EXP 21
19420: NOT
19421: IFFALSE 19425
// exit ;
19423: GO 20031
// for i = 1 to mc_bases do
19425: LD_ADDR_VAR 0 2
19429: PUSH
19430: DOUBLE
19431: LD_INT 1
19433: DEC
19434: ST_TO_ADDR
19435: LD_EXP 21
19439: PUSH
19440: FOR_TO
19441: IFFALSE 20029
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: LD_EXP 21
19452: PUSH
19453: LD_VAR 0 2
19457: ARRAY
19458: PPUSH
19459: LD_INT 25
19461: PUSH
19462: LD_INT 4
19464: PUSH
19465: EMPTY
19466: LIST
19467: LIST
19468: PPUSH
19469: CALL_OW 72
19473: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
19474: LD_VAR 0 3
19478: NOT
19479: PUSH
19480: LD_EXP 58
19484: PUSH
19485: LD_VAR 0 2
19489: ARRAY
19490: NOT
19491: OR
19492: PUSH
19493: LD_EXP 21
19497: PUSH
19498: LD_VAR 0 2
19502: ARRAY
19503: PPUSH
19504: LD_INT 2
19506: PUSH
19507: LD_INT 30
19509: PUSH
19510: LD_INT 0
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: PUSH
19517: LD_INT 30
19519: PUSH
19520: LD_INT 1
19522: PUSH
19523: EMPTY
19524: LIST
19525: LIST
19526: PUSH
19527: EMPTY
19528: LIST
19529: LIST
19530: LIST
19531: PPUSH
19532: CALL_OW 72
19536: NOT
19537: OR
19538: IFFALSE 19588
// begin if mc_deposits_finder [ i ] then
19540: LD_EXP 59
19544: PUSH
19545: LD_VAR 0 2
19549: ARRAY
19550: IFFALSE 19586
// begin MC_Reset ( i , 125 ) ;
19552: LD_VAR 0 2
19556: PPUSH
19557: LD_INT 125
19559: PPUSH
19560: CALL 3581 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
19564: LD_ADDR_EXP 59
19568: PUSH
19569: LD_EXP 59
19573: PPUSH
19574: LD_VAR 0 2
19578: PPUSH
19579: EMPTY
19580: PPUSH
19581: CALL_OW 1
19585: ST_TO_ADDR
// end ; continue ;
19586: GO 19440
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
19588: LD_EXP 58
19592: PUSH
19593: LD_VAR 0 2
19597: ARRAY
19598: PUSH
19599: LD_INT 1
19601: ARRAY
19602: PUSH
19603: LD_INT 3
19605: ARRAY
19606: PUSH
19607: LD_INT 1
19609: EQUAL
19610: PUSH
19611: LD_INT 20
19613: PPUSH
19614: LD_EXP 47
19618: PUSH
19619: LD_VAR 0 2
19623: ARRAY
19624: PPUSH
19625: CALL_OW 321
19629: PUSH
19630: LD_INT 2
19632: NONEQUAL
19633: AND
19634: IFFALSE 19684
// begin if mc_deposits_finder [ i ] then
19636: LD_EXP 59
19640: PUSH
19641: LD_VAR 0 2
19645: ARRAY
19646: IFFALSE 19682
// begin MC_Reset ( i , 125 ) ;
19648: LD_VAR 0 2
19652: PPUSH
19653: LD_INT 125
19655: PPUSH
19656: CALL 3581 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
19660: LD_ADDR_EXP 59
19664: PUSH
19665: LD_EXP 59
19669: PPUSH
19670: LD_VAR 0 2
19674: PPUSH
19675: EMPTY
19676: PPUSH
19677: CALL_OW 1
19681: ST_TO_ADDR
// end ; continue ;
19682: GO 19440
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
19684: LD_EXP 58
19688: PUSH
19689: LD_VAR 0 2
19693: ARRAY
19694: PUSH
19695: LD_INT 1
19697: ARRAY
19698: PUSH
19699: LD_INT 1
19701: ARRAY
19702: PPUSH
19703: LD_EXP 58
19707: PUSH
19708: LD_VAR 0 2
19712: ARRAY
19713: PUSH
19714: LD_INT 1
19716: ARRAY
19717: PUSH
19718: LD_INT 2
19720: ARRAY
19721: PPUSH
19722: LD_EXP 47
19726: PUSH
19727: LD_VAR 0 2
19731: ARRAY
19732: PPUSH
19733: CALL_OW 440
19737: IFFALSE 19780
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
19739: LD_ADDR_EXP 58
19743: PUSH
19744: LD_EXP 58
19748: PPUSH
19749: LD_VAR 0 2
19753: PPUSH
19754: LD_EXP 58
19758: PUSH
19759: LD_VAR 0 2
19763: ARRAY
19764: PPUSH
19765: LD_INT 1
19767: PPUSH
19768: CALL_OW 3
19772: PPUSH
19773: CALL_OW 1
19777: ST_TO_ADDR
19778: GO 20027
// begin if not mc_deposits_finder [ i ] then
19780: LD_EXP 59
19784: PUSH
19785: LD_VAR 0 2
19789: ARRAY
19790: NOT
19791: IFFALSE 19843
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
19793: LD_ADDR_EXP 59
19797: PUSH
19798: LD_EXP 59
19802: PPUSH
19803: LD_VAR 0 2
19807: PPUSH
19808: LD_VAR 0 3
19812: PUSH
19813: LD_INT 1
19815: ARRAY
19816: PUSH
19817: EMPTY
19818: LIST
19819: PPUSH
19820: CALL_OW 1
19824: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
19825: LD_VAR 0 3
19829: PUSH
19830: LD_INT 1
19832: ARRAY
19833: PPUSH
19834: LD_INT 125
19836: PPUSH
19837: CALL_OW 109
// end else
19841: GO 20027
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
19843: LD_EXP 59
19847: PUSH
19848: LD_VAR 0 2
19852: ARRAY
19853: PUSH
19854: LD_INT 1
19856: ARRAY
19857: PPUSH
19858: CALL_OW 310
19862: IFFALSE 19885
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
19864: LD_EXP 59
19868: PUSH
19869: LD_VAR 0 2
19873: ARRAY
19874: PUSH
19875: LD_INT 1
19877: ARRAY
19878: PPUSH
19879: CALL_OW 122
19883: GO 20027
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
19885: LD_EXP 59
19889: PUSH
19890: LD_VAR 0 2
19894: ARRAY
19895: PUSH
19896: LD_INT 1
19898: ARRAY
19899: PPUSH
19900: CALL_OW 314
19904: NOT
19905: PUSH
19906: LD_EXP 59
19910: PUSH
19911: LD_VAR 0 2
19915: ARRAY
19916: PUSH
19917: LD_INT 1
19919: ARRAY
19920: PPUSH
19921: LD_EXP 58
19925: PUSH
19926: LD_VAR 0 2
19930: ARRAY
19931: PUSH
19932: LD_INT 1
19934: ARRAY
19935: PUSH
19936: LD_INT 1
19938: ARRAY
19939: PPUSH
19940: LD_EXP 58
19944: PUSH
19945: LD_VAR 0 2
19949: ARRAY
19950: PUSH
19951: LD_INT 1
19953: ARRAY
19954: PUSH
19955: LD_INT 2
19957: ARRAY
19958: PPUSH
19959: CALL_OW 297
19963: PUSH
19964: LD_INT 6
19966: GREATER
19967: AND
19968: IFFALSE 20027
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
19970: LD_EXP 59
19974: PUSH
19975: LD_VAR 0 2
19979: ARRAY
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PPUSH
19985: LD_EXP 58
19989: PUSH
19990: LD_VAR 0 2
19994: ARRAY
19995: PUSH
19996: LD_INT 1
19998: ARRAY
19999: PUSH
20000: LD_INT 1
20002: ARRAY
20003: PPUSH
20004: LD_EXP 58
20008: PUSH
20009: LD_VAR 0 2
20013: ARRAY
20014: PUSH
20015: LD_INT 1
20017: ARRAY
20018: PUSH
20019: LD_INT 2
20021: ARRAY
20022: PPUSH
20023: CALL_OW 111
// end ; end ; end ;
20027: GO 19440
20029: POP
20030: POP
// end ;
20031: LD_VAR 0 1
20035: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
20036: LD_INT 0
20038: PPUSH
20039: PPUSH
20040: PPUSH
20041: PPUSH
20042: PPUSH
20043: PPUSH
20044: PPUSH
20045: PPUSH
20046: PPUSH
20047: PPUSH
20048: PPUSH
// if not mc_bases then
20049: LD_EXP 21
20053: NOT
20054: IFFALSE 20058
// exit ;
20056: GO 20782
// for i = 1 to mc_bases do
20058: LD_ADDR_VAR 0 2
20062: PUSH
20063: DOUBLE
20064: LD_INT 1
20066: DEC
20067: ST_TO_ADDR
20068: LD_EXP 21
20072: PUSH
20073: FOR_TO
20074: IFFALSE 20780
// begin if not mc_bases [ i ] then
20076: LD_EXP 21
20080: PUSH
20081: LD_VAR 0 2
20085: ARRAY
20086: NOT
20087: IFFALSE 20091
// continue ;
20089: GO 20073
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
20091: LD_ADDR_VAR 0 7
20095: PUSH
20096: LD_EXP 21
20100: PUSH
20101: LD_VAR 0 2
20105: ARRAY
20106: PUSH
20107: LD_INT 1
20109: ARRAY
20110: PPUSH
20111: CALL_OW 248
20115: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
20116: LD_VAR 0 7
20120: PUSH
20121: LD_INT 3
20123: EQUAL
20124: PUSH
20125: LD_EXP 40
20129: PUSH
20130: LD_VAR 0 2
20134: ARRAY
20135: PUSH
20136: LD_EXP 43
20140: PUSH
20141: LD_VAR 0 2
20145: ARRAY
20146: UNION
20147: PPUSH
20148: LD_INT 33
20150: PUSH
20151: LD_INT 2
20153: PUSH
20154: EMPTY
20155: LIST
20156: LIST
20157: PPUSH
20158: CALL_OW 72
20162: NOT
20163: OR
20164: IFFALSE 20168
// continue ;
20166: GO 20073
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
20168: LD_ADDR_VAR 0 9
20172: PUSH
20173: LD_EXP 21
20177: PUSH
20178: LD_VAR 0 2
20182: ARRAY
20183: PPUSH
20184: LD_INT 30
20186: PUSH
20187: LD_INT 36
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: PPUSH
20194: CALL_OW 72
20198: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
20199: LD_ADDR_VAR 0 10
20203: PUSH
20204: LD_EXP 40
20208: PUSH
20209: LD_VAR 0 2
20213: ARRAY
20214: PPUSH
20215: LD_INT 34
20217: PUSH
20218: LD_INT 31
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: PPUSH
20225: CALL_OW 72
20229: ST_TO_ADDR
// if not cts and not mcts then
20230: LD_VAR 0 9
20234: NOT
20235: PUSH
20236: LD_VAR 0 10
20240: NOT
20241: AND
20242: IFFALSE 20246
// continue ;
20244: GO 20073
// x := cts ;
20246: LD_ADDR_VAR 0 11
20250: PUSH
20251: LD_VAR 0 9
20255: ST_TO_ADDR
// if not x then
20256: LD_VAR 0 11
20260: NOT
20261: IFFALSE 20273
// x := mcts ;
20263: LD_ADDR_VAR 0 11
20267: PUSH
20268: LD_VAR 0 10
20272: ST_TO_ADDR
// if mc_remote_driver [ i ] then
20273: LD_EXP 61
20277: PUSH
20278: LD_VAR 0 2
20282: ARRAY
20283: IFFALSE 20552
// for j in mc_remote_driver [ i ] do
20285: LD_ADDR_VAR 0 3
20289: PUSH
20290: LD_EXP 61
20294: PUSH
20295: LD_VAR 0 2
20299: ARRAY
20300: PUSH
20301: FOR_IN
20302: IFFALSE 20550
// begin if GetClass ( j ) <> 3 then
20304: LD_VAR 0 3
20308: PPUSH
20309: CALL_OW 257
20313: PUSH
20314: LD_INT 3
20316: NONEQUAL
20317: IFFALSE 20370
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
20319: LD_ADDR_EXP 61
20323: PUSH
20324: LD_EXP 61
20328: PPUSH
20329: LD_VAR 0 2
20333: PPUSH
20334: LD_EXP 61
20338: PUSH
20339: LD_VAR 0 2
20343: ARRAY
20344: PUSH
20345: LD_VAR 0 3
20349: DIFF
20350: PPUSH
20351: CALL_OW 1
20355: ST_TO_ADDR
// SetTag ( j , 0 ) ;
20356: LD_VAR 0 3
20360: PPUSH
20361: LD_INT 0
20363: PPUSH
20364: CALL_OW 109
// continue ;
20368: GO 20301
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
20370: LD_VAR 0 3
20374: PPUSH
20375: CALL_OW 310
20379: NOT
20380: PUSH
20381: LD_VAR 0 3
20385: PPUSH
20386: CALL_OW 310
20390: PPUSH
20391: CALL_OW 266
20395: PUSH
20396: LD_INT 36
20398: NONEQUAL
20399: PUSH
20400: LD_VAR 0 3
20404: PPUSH
20405: CALL 67904 0 1
20409: NOT
20410: AND
20411: OR
20412: IFFALSE 20548
// begin if IsInUnit ( j ) then
20414: LD_VAR 0 3
20418: PPUSH
20419: CALL_OW 310
20423: IFFALSE 20434
// ComExitBuilding ( j ) ;
20425: LD_VAR 0 3
20429: PPUSH
20430: CALL_OW 122
// ct := 0 ;
20434: LD_ADDR_VAR 0 8
20438: PUSH
20439: LD_INT 0
20441: ST_TO_ADDR
// for k in x do
20442: LD_ADDR_VAR 0 4
20446: PUSH
20447: LD_VAR 0 11
20451: PUSH
20452: FOR_IN
20453: IFFALSE 20526
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
20455: LD_VAR 0 4
20459: PPUSH
20460: CALL_OW 264
20464: PUSH
20465: LD_INT 31
20467: EQUAL
20468: PUSH
20469: LD_VAR 0 4
20473: PPUSH
20474: CALL_OW 311
20478: NOT
20479: AND
20480: PUSH
20481: LD_VAR 0 4
20485: PPUSH
20486: CALL_OW 266
20490: PUSH
20491: LD_INT 36
20493: EQUAL
20494: PUSH
20495: LD_VAR 0 4
20499: PPUSH
20500: CALL_OW 313
20504: PUSH
20505: LD_INT 3
20507: LESS
20508: AND
20509: OR
20510: IFFALSE 20524
// begin ct := k ;
20512: LD_ADDR_VAR 0 8
20516: PUSH
20517: LD_VAR 0 4
20521: ST_TO_ADDR
// break ;
20522: GO 20526
// end ;
20524: GO 20452
20526: POP
20527: POP
// if ct then
20528: LD_VAR 0 8
20532: IFFALSE 20548
// ComEnterUnit ( j , ct ) ;
20534: LD_VAR 0 3
20538: PPUSH
20539: LD_VAR 0 8
20543: PPUSH
20544: CALL_OW 120
// end ; end ;
20548: GO 20301
20550: POP
20551: POP
// places := 0 ;
20552: LD_ADDR_VAR 0 5
20556: PUSH
20557: LD_INT 0
20559: ST_TO_ADDR
// for j = 1 to x do
20560: LD_ADDR_VAR 0 3
20564: PUSH
20565: DOUBLE
20566: LD_INT 1
20568: DEC
20569: ST_TO_ADDR
20570: LD_VAR 0 11
20574: PUSH
20575: FOR_TO
20576: IFFALSE 20631
// if GetWeapon ( x [ j ] ) = ar_control_tower then
20578: LD_VAR 0 11
20582: PUSH
20583: LD_VAR 0 3
20587: ARRAY
20588: PPUSH
20589: CALL_OW 264
20593: PUSH
20594: LD_INT 31
20596: EQUAL
20597: IFFALSE 20615
// places := places + 1 else
20599: LD_ADDR_VAR 0 5
20603: PUSH
20604: LD_VAR 0 5
20608: PUSH
20609: LD_INT 1
20611: PLUS
20612: ST_TO_ADDR
20613: GO 20629
// places := places + 3 ;
20615: LD_ADDR_VAR 0 5
20619: PUSH
20620: LD_VAR 0 5
20624: PUSH
20625: LD_INT 3
20627: PLUS
20628: ST_TO_ADDR
20629: GO 20575
20631: POP
20632: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
20633: LD_ADDR_VAR 0 6
20637: PUSH
20638: LD_EXP 21
20642: PUSH
20643: LD_VAR 0 2
20647: ARRAY
20648: PPUSH
20649: LD_INT 25
20651: PUSH
20652: LD_INT 3
20654: PUSH
20655: EMPTY
20656: LIST
20657: LIST
20658: PPUSH
20659: CALL_OW 72
20663: PUSH
20664: LD_EXP 61
20668: PUSH
20669: LD_VAR 0 2
20673: ARRAY
20674: DIFF
20675: PPUSH
20676: LD_INT 3
20678: PPUSH
20679: CALL 68804 0 2
20683: ST_TO_ADDR
// if not tmp then
20684: LD_VAR 0 6
20688: NOT
20689: IFFALSE 20693
// continue ;
20691: GO 20073
// places := places - mc_remote_driver [ i ] ;
20693: LD_ADDR_VAR 0 5
20697: PUSH
20698: LD_VAR 0 5
20702: PUSH
20703: LD_EXP 61
20707: PUSH
20708: LD_VAR 0 2
20712: ARRAY
20713: MINUS
20714: ST_TO_ADDR
// if places then
20715: LD_VAR 0 5
20719: IFFALSE 20778
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
20721: LD_ADDR_EXP 61
20725: PUSH
20726: LD_EXP 61
20730: PPUSH
20731: LD_VAR 0 2
20735: PPUSH
20736: LD_EXP 61
20740: PUSH
20741: LD_VAR 0 2
20745: ARRAY
20746: PUSH
20747: LD_VAR 0 6
20751: PUSH
20752: LD_INT 1
20754: ARRAY
20755: UNION
20756: PPUSH
20757: CALL_OW 1
20761: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
20762: LD_VAR 0 6
20766: PUSH
20767: LD_INT 1
20769: ARRAY
20770: PPUSH
20771: LD_INT 126
20773: PPUSH
20774: CALL_OW 109
// end ; end ;
20778: GO 20073
20780: POP
20781: POP
// end ;
20782: LD_VAR 0 1
20786: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
20787: LD_INT 0
20789: PPUSH
20790: PPUSH
20791: PPUSH
20792: PPUSH
20793: PPUSH
20794: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
20795: LD_VAR 0 1
20799: NOT
20800: PUSH
20801: LD_VAR 0 2
20805: NOT
20806: OR
20807: PUSH
20808: LD_VAR 0 3
20812: NOT
20813: OR
20814: PUSH
20815: LD_VAR 0 4
20819: PUSH
20820: LD_INT 1
20822: PUSH
20823: LD_INT 2
20825: PUSH
20826: LD_INT 3
20828: PUSH
20829: LD_INT 4
20831: PUSH
20832: LD_INT 5
20834: PUSH
20835: LD_INT 8
20837: PUSH
20838: LD_INT 9
20840: PUSH
20841: LD_INT 15
20843: PUSH
20844: LD_INT 16
20846: PUSH
20847: EMPTY
20848: LIST
20849: LIST
20850: LIST
20851: LIST
20852: LIST
20853: LIST
20854: LIST
20855: LIST
20856: LIST
20857: IN
20858: NOT
20859: OR
20860: IFFALSE 20864
// exit ;
20862: GO 21764
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
20864: LD_ADDR_VAR 0 2
20868: PUSH
20869: LD_VAR 0 2
20873: PPUSH
20874: LD_INT 21
20876: PUSH
20877: LD_INT 3
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: LD_INT 24
20886: PUSH
20887: LD_INT 250
20889: PUSH
20890: EMPTY
20891: LIST
20892: LIST
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: PPUSH
20898: CALL_OW 72
20902: ST_TO_ADDR
// case class of 1 , 15 :
20903: LD_VAR 0 4
20907: PUSH
20908: LD_INT 1
20910: DOUBLE
20911: EQUAL
20912: IFTRUE 20922
20914: LD_INT 15
20916: DOUBLE
20917: EQUAL
20918: IFTRUE 20922
20920: GO 21007
20922: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
20923: LD_ADDR_VAR 0 8
20927: PUSH
20928: LD_VAR 0 2
20932: PPUSH
20933: LD_INT 2
20935: PUSH
20936: LD_INT 30
20938: PUSH
20939: LD_INT 32
20941: PUSH
20942: EMPTY
20943: LIST
20944: LIST
20945: PUSH
20946: LD_INT 30
20948: PUSH
20949: LD_INT 31
20951: PUSH
20952: EMPTY
20953: LIST
20954: LIST
20955: PUSH
20956: EMPTY
20957: LIST
20958: LIST
20959: LIST
20960: PPUSH
20961: CALL_OW 72
20965: PUSH
20966: LD_VAR 0 2
20970: PPUSH
20971: LD_INT 2
20973: PUSH
20974: LD_INT 30
20976: PUSH
20977: LD_INT 4
20979: PUSH
20980: EMPTY
20981: LIST
20982: LIST
20983: PUSH
20984: LD_INT 30
20986: PUSH
20987: LD_INT 5
20989: PUSH
20990: EMPTY
20991: LIST
20992: LIST
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: LIST
20998: PPUSH
20999: CALL_OW 72
21003: ADD
21004: ST_TO_ADDR
21005: GO 21253
21007: LD_INT 2
21009: DOUBLE
21010: EQUAL
21011: IFTRUE 21021
21013: LD_INT 16
21015: DOUBLE
21016: EQUAL
21017: IFTRUE 21021
21019: GO 21067
21021: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
21022: LD_ADDR_VAR 0 8
21026: PUSH
21027: LD_VAR 0 2
21031: PPUSH
21032: LD_INT 2
21034: PUSH
21035: LD_INT 30
21037: PUSH
21038: LD_INT 0
21040: PUSH
21041: EMPTY
21042: LIST
21043: LIST
21044: PUSH
21045: LD_INT 30
21047: PUSH
21048: LD_INT 1
21050: PUSH
21051: EMPTY
21052: LIST
21053: LIST
21054: PUSH
21055: EMPTY
21056: LIST
21057: LIST
21058: LIST
21059: PPUSH
21060: CALL_OW 72
21064: ST_TO_ADDR
21065: GO 21253
21067: LD_INT 3
21069: DOUBLE
21070: EQUAL
21071: IFTRUE 21075
21073: GO 21121
21075: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
21076: LD_ADDR_VAR 0 8
21080: PUSH
21081: LD_VAR 0 2
21085: PPUSH
21086: LD_INT 2
21088: PUSH
21089: LD_INT 30
21091: PUSH
21092: LD_INT 2
21094: PUSH
21095: EMPTY
21096: LIST
21097: LIST
21098: PUSH
21099: LD_INT 30
21101: PUSH
21102: LD_INT 3
21104: PUSH
21105: EMPTY
21106: LIST
21107: LIST
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: LIST
21113: PPUSH
21114: CALL_OW 72
21118: ST_TO_ADDR
21119: GO 21253
21121: LD_INT 4
21123: DOUBLE
21124: EQUAL
21125: IFTRUE 21129
21127: GO 21186
21129: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
21130: LD_ADDR_VAR 0 8
21134: PUSH
21135: LD_VAR 0 2
21139: PPUSH
21140: LD_INT 2
21142: PUSH
21143: LD_INT 30
21145: PUSH
21146: LD_INT 6
21148: PUSH
21149: EMPTY
21150: LIST
21151: LIST
21152: PUSH
21153: LD_INT 30
21155: PUSH
21156: LD_INT 7
21158: PUSH
21159: EMPTY
21160: LIST
21161: LIST
21162: PUSH
21163: LD_INT 30
21165: PUSH
21166: LD_INT 8
21168: PUSH
21169: EMPTY
21170: LIST
21171: LIST
21172: PUSH
21173: EMPTY
21174: LIST
21175: LIST
21176: LIST
21177: LIST
21178: PPUSH
21179: CALL_OW 72
21183: ST_TO_ADDR
21184: GO 21253
21186: LD_INT 5
21188: DOUBLE
21189: EQUAL
21190: IFTRUE 21206
21192: LD_INT 8
21194: DOUBLE
21195: EQUAL
21196: IFTRUE 21206
21198: LD_INT 9
21200: DOUBLE
21201: EQUAL
21202: IFTRUE 21206
21204: GO 21252
21206: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
21207: LD_ADDR_VAR 0 8
21211: PUSH
21212: LD_VAR 0 2
21216: PPUSH
21217: LD_INT 2
21219: PUSH
21220: LD_INT 30
21222: PUSH
21223: LD_INT 4
21225: PUSH
21226: EMPTY
21227: LIST
21228: LIST
21229: PUSH
21230: LD_INT 30
21232: PUSH
21233: LD_INT 5
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: LIST
21244: PPUSH
21245: CALL_OW 72
21249: ST_TO_ADDR
21250: GO 21253
21252: POP
// if not tmp then
21253: LD_VAR 0 8
21257: NOT
21258: IFFALSE 21262
// exit ;
21260: GO 21764
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
21262: LD_VAR 0 4
21266: PUSH
21267: LD_INT 1
21269: PUSH
21270: LD_INT 15
21272: PUSH
21273: EMPTY
21274: LIST
21275: LIST
21276: IN
21277: PUSH
21278: LD_EXP 30
21282: PUSH
21283: LD_VAR 0 1
21287: ARRAY
21288: AND
21289: IFFALSE 21445
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
21291: LD_ADDR_VAR 0 9
21295: PUSH
21296: LD_EXP 30
21300: PUSH
21301: LD_VAR 0 1
21305: ARRAY
21306: PUSH
21307: LD_INT 1
21309: ARRAY
21310: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
21311: LD_VAR 0 9
21315: PUSH
21316: LD_EXP 31
21320: PUSH
21321: LD_VAR 0 1
21325: ARRAY
21326: IN
21327: NOT
21328: IFFALSE 21443
// begin mc_busy_turret_list := Add ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
21330: LD_ADDR_EXP 31
21334: PUSH
21335: LD_EXP 31
21339: PPUSH
21340: LD_VAR 0 1
21344: PUSH
21345: LD_EXP 31
21349: PUSH
21350: LD_VAR 0 1
21354: ARRAY
21355: PUSH
21356: LD_INT 1
21358: PLUS
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PPUSH
21364: LD_VAR 0 9
21368: PPUSH
21369: CALL 35208 0 3
21373: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
21374: LD_ADDR_EXP 30
21378: PUSH
21379: LD_EXP 30
21383: PPUSH
21384: LD_VAR 0 1
21388: PPUSH
21389: LD_EXP 30
21393: PUSH
21394: LD_VAR 0 1
21398: ARRAY
21399: PUSH
21400: LD_VAR 0 9
21404: DIFF
21405: PPUSH
21406: CALL_OW 1
21410: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
21411: LD_VAR 0 3
21415: PPUSH
21416: LD_EXP 31
21420: PUSH
21421: LD_VAR 0 1
21425: ARRAY
21426: PUSH
21427: LD_EXP 31
21431: PUSH
21432: LD_VAR 0 1
21436: ARRAY
21437: ARRAY
21438: PPUSH
21439: CALL_OW 120
// end ; exit ;
21443: GO 21764
// end ; if tmp > 1 then
21445: LD_VAR 0 8
21449: PUSH
21450: LD_INT 1
21452: GREATER
21453: IFFALSE 21557
// for i = 2 to tmp do
21455: LD_ADDR_VAR 0 6
21459: PUSH
21460: DOUBLE
21461: LD_INT 2
21463: DEC
21464: ST_TO_ADDR
21465: LD_VAR 0 8
21469: PUSH
21470: FOR_TO
21471: IFFALSE 21555
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
21473: LD_VAR 0 8
21477: PUSH
21478: LD_VAR 0 6
21482: ARRAY
21483: PPUSH
21484: CALL_OW 461
21488: PUSH
21489: LD_INT 6
21491: EQUAL
21492: IFFALSE 21553
// begin x := tmp [ i ] ;
21494: LD_ADDR_VAR 0 9
21498: PUSH
21499: LD_VAR 0 8
21503: PUSH
21504: LD_VAR 0 6
21508: ARRAY
21509: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
21510: LD_ADDR_VAR 0 8
21514: PUSH
21515: LD_VAR 0 8
21519: PPUSH
21520: LD_VAR 0 6
21524: PPUSH
21525: CALL_OW 3
21529: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
21530: LD_ADDR_VAR 0 8
21534: PUSH
21535: LD_VAR 0 8
21539: PPUSH
21540: LD_INT 1
21542: PPUSH
21543: LD_VAR 0 9
21547: PPUSH
21548: CALL_OW 2
21552: ST_TO_ADDR
// end ;
21553: GO 21470
21555: POP
21556: POP
// for i in tmp do
21557: LD_ADDR_VAR 0 6
21561: PUSH
21562: LD_VAR 0 8
21566: PUSH
21567: FOR_IN
21568: IFFALSE 21637
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
21570: LD_VAR 0 6
21574: PPUSH
21575: CALL_OW 313
21579: PUSH
21580: LD_INT 6
21582: LESS
21583: PUSH
21584: LD_VAR 0 6
21588: PPUSH
21589: CALL_OW 266
21593: PUSH
21594: LD_INT 31
21596: PUSH
21597: LD_INT 32
21599: PUSH
21600: EMPTY
21601: LIST
21602: LIST
21603: IN
21604: NOT
21605: AND
21606: PUSH
21607: LD_VAR 0 6
21611: PPUSH
21612: CALL_OW 313
21616: PUSH
21617: LD_INT 0
21619: EQUAL
21620: OR
21621: IFFALSE 21635
// begin j := i ;
21623: LD_ADDR_VAR 0 7
21627: PUSH
21628: LD_VAR 0 6
21632: ST_TO_ADDR
// break ;
21633: GO 21637
// end ; end ;
21635: GO 21567
21637: POP
21638: POP
// if j then
21639: LD_VAR 0 7
21643: IFFALSE 21661
// ComEnterUnit ( unit , j ) else
21645: LD_VAR 0 3
21649: PPUSH
21650: LD_VAR 0 7
21654: PPUSH
21655: CALL_OW 120
21659: GO 21764
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
21661: LD_ADDR_VAR 0 10
21665: PUSH
21666: LD_VAR 0 2
21670: PPUSH
21671: LD_INT 2
21673: PUSH
21674: LD_INT 30
21676: PUSH
21677: LD_INT 0
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: PUSH
21684: LD_INT 30
21686: PUSH
21687: LD_INT 1
21689: PUSH
21690: EMPTY
21691: LIST
21692: LIST
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: LIST
21698: PPUSH
21699: CALL_OW 72
21703: ST_TO_ADDR
// if depot then
21704: LD_VAR 0 10
21708: IFFALSE 21764
// begin depot := NearestUnitToUnit ( depot , unit ) ;
21710: LD_ADDR_VAR 0 10
21714: PUSH
21715: LD_VAR 0 10
21719: PPUSH
21720: LD_VAR 0 3
21724: PPUSH
21725: CALL_OW 74
21729: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
21730: LD_VAR 0 3
21734: PPUSH
21735: LD_VAR 0 10
21739: PPUSH
21740: CALL_OW 296
21744: PUSH
21745: LD_INT 10
21747: GREATER
21748: IFFALSE 21764
// ComStandNearbyBuilding ( unit , depot ) ;
21750: LD_VAR 0 3
21754: PPUSH
21755: LD_VAR 0 10
21759: PPUSH
21760: CALL 29450 0 2
// end ; end ; end ;
21764: LD_VAR 0 5
21768: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
21769: LD_INT 0
21771: PPUSH
21772: PPUSH
21773: PPUSH
21774: PPUSH
// if not mc_bases then
21775: LD_EXP 21
21779: NOT
21780: IFFALSE 21784
// exit ;
21782: GO 22023
// for i = 1 to mc_bases do
21784: LD_ADDR_VAR 0 2
21788: PUSH
21789: DOUBLE
21790: LD_INT 1
21792: DEC
21793: ST_TO_ADDR
21794: LD_EXP 21
21798: PUSH
21799: FOR_TO
21800: IFFALSE 22021
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
21802: LD_ADDR_VAR 0 4
21806: PUSH
21807: LD_EXP 21
21811: PUSH
21812: LD_VAR 0 2
21816: ARRAY
21817: PPUSH
21818: LD_INT 21
21820: PUSH
21821: LD_INT 1
21823: PUSH
21824: EMPTY
21825: LIST
21826: LIST
21827: PPUSH
21828: CALL_OW 72
21832: PUSH
21833: LD_EXP 50
21837: PUSH
21838: LD_VAR 0 2
21842: ARRAY
21843: UNION
21844: ST_TO_ADDR
// if not tmp then
21845: LD_VAR 0 4
21849: NOT
21850: IFFALSE 21854
// continue ;
21852: GO 21799
// for j in tmp do
21854: LD_ADDR_VAR 0 3
21858: PUSH
21859: LD_VAR 0 4
21863: PUSH
21864: FOR_IN
21865: IFFALSE 22017
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
21867: LD_VAR 0 3
21871: PPUSH
21872: CALL_OW 110
21876: NOT
21877: PUSH
21878: LD_VAR 0 3
21882: PPUSH
21883: CALL_OW 314
21887: NOT
21888: AND
21889: PUSH
21890: LD_VAR 0 3
21894: PPUSH
21895: CALL_OW 311
21899: NOT
21900: AND
21901: PUSH
21902: LD_VAR 0 3
21906: PPUSH
21907: CALL_OW 310
21911: NOT
21912: AND
21913: PUSH
21914: LD_VAR 0 3
21918: PUSH
21919: LD_EXP 24
21923: PUSH
21924: LD_VAR 0 2
21928: ARRAY
21929: PUSH
21930: LD_INT 1
21932: ARRAY
21933: IN
21934: NOT
21935: AND
21936: PUSH
21937: LD_VAR 0 3
21941: PUSH
21942: LD_EXP 24
21946: PUSH
21947: LD_VAR 0 2
21951: ARRAY
21952: PUSH
21953: LD_INT 2
21955: ARRAY
21956: IN
21957: NOT
21958: AND
21959: PUSH
21960: LD_VAR 0 3
21964: PUSH
21965: LD_EXP 33
21969: PUSH
21970: LD_VAR 0 2
21974: ARRAY
21975: IN
21976: NOT
21977: AND
21978: IFFALSE 22015
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
21980: LD_VAR 0 2
21984: PPUSH
21985: LD_EXP 21
21989: PUSH
21990: LD_VAR 0 2
21994: ARRAY
21995: PPUSH
21996: LD_VAR 0 3
22000: PPUSH
22001: LD_VAR 0 3
22005: PPUSH
22006: CALL_OW 257
22010: PPUSH
22011: CALL 20787 0 4
// end ;
22015: GO 21864
22017: POP
22018: POP
// end ;
22019: GO 21799
22021: POP
22022: POP
// end ;
22023: LD_VAR 0 1
22027: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
22028: LD_INT 0
22030: PPUSH
22031: PPUSH
22032: PPUSH
22033: PPUSH
22034: PPUSH
22035: PPUSH
// if not mc_bases [ base ] then
22036: LD_EXP 21
22040: PUSH
22041: LD_VAR 0 1
22045: ARRAY
22046: NOT
22047: IFFALSE 22051
// exit ;
22049: GO 22233
// tmp := [ ] ;
22051: LD_ADDR_VAR 0 6
22055: PUSH
22056: EMPTY
22057: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
22058: LD_ADDR_VAR 0 7
22062: PUSH
22063: LD_VAR 0 3
22067: PPUSH
22068: LD_INT 0
22070: PPUSH
22071: CALL_OW 517
22075: ST_TO_ADDR
// if not list then
22076: LD_VAR 0 7
22080: NOT
22081: IFFALSE 22085
// exit ;
22083: GO 22233
// for i = 1 to amount do
22085: LD_ADDR_VAR 0 5
22089: PUSH
22090: DOUBLE
22091: LD_INT 1
22093: DEC
22094: ST_TO_ADDR
22095: LD_VAR 0 2
22099: PUSH
22100: FOR_TO
22101: IFFALSE 22181
// begin x := rand ( 1 , list [ 1 ] ) ;
22103: LD_ADDR_VAR 0 8
22107: PUSH
22108: LD_INT 1
22110: PPUSH
22111: LD_VAR 0 7
22115: PUSH
22116: LD_INT 1
22118: ARRAY
22119: PPUSH
22120: CALL_OW 12
22124: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
22125: LD_ADDR_VAR 0 6
22129: PUSH
22130: LD_VAR 0 6
22134: PPUSH
22135: LD_VAR 0 5
22139: PPUSH
22140: LD_VAR 0 7
22144: PUSH
22145: LD_INT 1
22147: ARRAY
22148: PUSH
22149: LD_VAR 0 8
22153: ARRAY
22154: PUSH
22155: LD_VAR 0 7
22159: PUSH
22160: LD_INT 2
22162: ARRAY
22163: PUSH
22164: LD_VAR 0 8
22168: ARRAY
22169: PUSH
22170: EMPTY
22171: LIST
22172: LIST
22173: PPUSH
22174: CALL_OW 1
22178: ST_TO_ADDR
// end ;
22179: GO 22100
22181: POP
22182: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
22183: LD_ADDR_EXP 34
22187: PUSH
22188: LD_EXP 34
22192: PPUSH
22193: LD_VAR 0 1
22197: PPUSH
22198: LD_VAR 0 6
22202: PPUSH
22203: CALL_OW 1
22207: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
22208: LD_ADDR_EXP 36
22212: PUSH
22213: LD_EXP 36
22217: PPUSH
22218: LD_VAR 0 1
22222: PPUSH
22223: LD_VAR 0 3
22227: PPUSH
22228: CALL_OW 1
22232: ST_TO_ADDR
// end ;
22233: LD_VAR 0 4
22237: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
22238: LD_INT 0
22240: PPUSH
// if not mc_bases [ base ] then
22241: LD_EXP 21
22245: PUSH
22246: LD_VAR 0 1
22250: ARRAY
22251: NOT
22252: IFFALSE 22256
// exit ;
22254: GO 22281
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
22256: LD_ADDR_EXP 26
22260: PUSH
22261: LD_EXP 26
22265: PPUSH
22266: LD_VAR 0 1
22270: PPUSH
22271: LD_VAR 0 2
22275: PPUSH
22276: CALL_OW 1
22280: ST_TO_ADDR
// end ;
22281: LD_VAR 0 3
22285: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
22286: LD_INT 0
22288: PPUSH
// if not mc_bases [ base ] then
22289: LD_EXP 21
22293: PUSH
22294: LD_VAR 0 1
22298: ARRAY
22299: NOT
22300: IFFALSE 22304
// exit ;
22302: GO 22341
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
22304: LD_ADDR_EXP 26
22308: PUSH
22309: LD_EXP 26
22313: PPUSH
22314: LD_VAR 0 1
22318: PPUSH
22319: LD_EXP 26
22323: PUSH
22324: LD_VAR 0 1
22328: ARRAY
22329: PUSH
22330: LD_VAR 0 2
22334: UNION
22335: PPUSH
22336: CALL_OW 1
22340: ST_TO_ADDR
// end ;
22341: LD_VAR 0 3
22345: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
22346: LD_INT 0
22348: PPUSH
// if not mc_bases [ base ] then
22349: LD_EXP 21
22353: PUSH
22354: LD_VAR 0 1
22358: ARRAY
22359: NOT
22360: IFFALSE 22364
// exit ;
22362: GO 22389
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
22364: LD_ADDR_EXP 42
22368: PUSH
22369: LD_EXP 42
22373: PPUSH
22374: LD_VAR 0 1
22378: PPUSH
22379: LD_VAR 0 2
22383: PPUSH
22384: CALL_OW 1
22388: ST_TO_ADDR
// end ;
22389: LD_VAR 0 3
22393: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
22394: LD_INT 0
22396: PPUSH
// if not mc_bases [ base ] then
22397: LD_EXP 21
22401: PUSH
22402: LD_VAR 0 1
22406: ARRAY
22407: NOT
22408: IFFALSE 22412
// exit ;
22410: GO 22449
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
22412: LD_ADDR_EXP 42
22416: PUSH
22417: LD_EXP 42
22421: PPUSH
22422: LD_VAR 0 1
22426: PPUSH
22427: LD_EXP 42
22431: PUSH
22432: LD_VAR 0 1
22436: ARRAY
22437: PUSH
22438: LD_VAR 0 2
22442: UNION
22443: PPUSH
22444: CALL_OW 1
22448: ST_TO_ADDR
// end ;
22449: LD_VAR 0 3
22453: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
22454: LD_INT 0
22456: PPUSH
// if not mc_bases [ base ] then
22457: LD_EXP 21
22461: PUSH
22462: LD_VAR 0 1
22466: ARRAY
22467: NOT
22468: IFFALSE 22472
// exit ;
22470: GO 22584
// mc_defender := Replace ( mc_defender , base , deflist ) ;
22472: LD_ADDR_EXP 43
22476: PUSH
22477: LD_EXP 43
22481: PPUSH
22482: LD_VAR 0 1
22486: PPUSH
22487: LD_VAR 0 2
22491: PPUSH
22492: CALL_OW 1
22496: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
22497: LD_ADDR_EXP 32
22501: PUSH
22502: LD_EXP 32
22506: PPUSH
22507: LD_VAR 0 1
22511: PPUSH
22512: LD_VAR 0 2
22516: PUSH
22517: LD_INT 0
22519: PLUS
22520: PPUSH
22521: CALL_OW 1
22525: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
22526: LD_ADDR_EXP 40
22530: PUSH
22531: LD_EXP 40
22535: PPUSH
22536: LD_VAR 0 1
22540: PPUSH
22541: LD_EXP 40
22545: PUSH
22546: LD_VAR 0 1
22550: ARRAY
22551: PUSH
22552: LD_EXP 43
22556: PUSH
22557: LD_VAR 0 1
22561: ARRAY
22562: PPUSH
22563: LD_INT 21
22565: PUSH
22566: LD_INT 2
22568: PUSH
22569: EMPTY
22570: LIST
22571: LIST
22572: PPUSH
22573: CALL_OW 72
22577: UNION
22578: PPUSH
22579: CALL_OW 1
22583: ST_TO_ADDR
// end ;
22584: LD_VAR 0 3
22588: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
22589: LD_INT 0
22591: PPUSH
// if not mc_bases [ base ] then
22592: LD_EXP 21
22596: PUSH
22597: LD_VAR 0 1
22601: ARRAY
22602: NOT
22603: IFFALSE 22607
// exit ;
22605: GO 22632
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
22607: LD_ADDR_EXP 32
22611: PUSH
22612: LD_EXP 32
22616: PPUSH
22617: LD_VAR 0 1
22621: PPUSH
22622: LD_VAR 0 2
22626: PPUSH
22627: CALL_OW 1
22631: ST_TO_ADDR
// end ;
22632: LD_VAR 0 3
22636: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
22637: LD_INT 0
22639: PPUSH
22640: PPUSH
22641: PPUSH
22642: PPUSH
// if not mc_bases [ base ] then
22643: LD_EXP 21
22647: PUSH
22648: LD_VAR 0 1
22652: ARRAY
22653: NOT
22654: IFFALSE 22658
// exit ;
22656: GO 22723
// mc_attack := Add ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
22658: LD_ADDR_EXP 41
22662: PUSH
22663: LD_EXP 41
22667: PPUSH
22668: LD_VAR 0 1
22672: PUSH
22673: LD_EXP 41
22677: PUSH
22678: LD_VAR 0 1
22682: ARRAY
22683: PUSH
22684: LD_INT 1
22686: PLUS
22687: PUSH
22688: EMPTY
22689: LIST
22690: LIST
22691: PPUSH
22692: LD_VAR 0 1
22696: PUSH
22697: LD_VAR 0 2
22701: PUSH
22702: LD_VAR 0 3
22706: PUSH
22707: LD_VAR 0 4
22711: PUSH
22712: EMPTY
22713: LIST
22714: LIST
22715: LIST
22716: LIST
22717: PPUSH
22718: CALL 35208 0 3
22722: ST_TO_ADDR
// end ;
22723: LD_VAR 0 5
22727: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
22728: LD_INT 0
22730: PPUSH
// if not mc_bases [ base ] then
22731: LD_EXP 21
22735: PUSH
22736: LD_VAR 0 1
22740: ARRAY
22741: NOT
22742: IFFALSE 22746
// exit ;
22744: GO 22771
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
22746: LD_ADDR_EXP 58
22750: PUSH
22751: LD_EXP 58
22755: PPUSH
22756: LD_VAR 0 1
22760: PPUSH
22761: LD_VAR 0 2
22765: PPUSH
22766: CALL_OW 1
22770: ST_TO_ADDR
// end ;
22771: LD_VAR 0 3
22775: RET
// export function MC_GetMinesField ( base ) ; begin
22776: LD_INT 0
22778: PPUSH
// result := mc_mines [ base ] ;
22779: LD_ADDR_VAR 0 2
22783: PUSH
22784: LD_EXP 34
22788: PUSH
22789: LD_VAR 0 1
22793: ARRAY
22794: ST_TO_ADDR
// end ;
22795: LD_VAR 0 2
22799: RET
// export function MC_GetProduceList ( base ) ; begin
22800: LD_INT 0
22802: PPUSH
// result := mc_produce [ base ] ;
22803: LD_ADDR_VAR 0 2
22807: PUSH
22808: LD_EXP 42
22812: PUSH
22813: LD_VAR 0 1
22817: ARRAY
22818: ST_TO_ADDR
// end ;
22819: LD_VAR 0 2
22823: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
22824: LD_INT 0
22826: PPUSH
22827: PPUSH
// if not mc_bases then
22828: LD_EXP 21
22832: NOT
22833: IFFALSE 22837
// exit ;
22835: GO 22902
// if mc_bases [ base ] then
22837: LD_EXP 21
22841: PUSH
22842: LD_VAR 0 1
22846: ARRAY
22847: IFFALSE 22902
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
22849: LD_ADDR_VAR 0 3
22853: PUSH
22854: LD_EXP 21
22858: PUSH
22859: LD_VAR 0 1
22863: ARRAY
22864: PPUSH
22865: LD_INT 30
22867: PUSH
22868: LD_VAR 0 2
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: PPUSH
22877: CALL_OW 72
22881: ST_TO_ADDR
// if result then
22882: LD_VAR 0 3
22886: IFFALSE 22902
// result := result [ 1 ] ;
22888: LD_ADDR_VAR 0 3
22892: PUSH
22893: LD_VAR 0 3
22897: PUSH
22898: LD_INT 1
22900: ARRAY
22901: ST_TO_ADDR
// end ; end ;
22902: LD_VAR 0 3
22906: RET
// export function MC_SetTame ( base , area ) ; begin
22907: LD_INT 0
22909: PPUSH
// if not mc_bases or not base then
22910: LD_EXP 21
22914: NOT
22915: PUSH
22916: LD_VAR 0 1
22920: NOT
22921: OR
22922: IFFALSE 22926
// exit ;
22924: GO 22951
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
22926: LD_ADDR_EXP 49
22930: PUSH
22931: LD_EXP 49
22935: PPUSH
22936: LD_VAR 0 1
22940: PPUSH
22941: LD_VAR 0 2
22945: PPUSH
22946: CALL_OW 1
22950: ST_TO_ADDR
// end ;
22951: LD_VAR 0 3
22955: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
22956: LD_INT 0
22958: PPUSH
22959: PPUSH
// if not mc_bases or not base then
22960: LD_EXP 21
22964: NOT
22965: PUSH
22966: LD_VAR 0 1
22970: NOT
22971: OR
22972: IFFALSE 22976
// exit ;
22974: GO 23078
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
22976: LD_ADDR_VAR 0 4
22980: PUSH
22981: LD_EXP 21
22985: PUSH
22986: LD_VAR 0 1
22990: ARRAY
22991: PPUSH
22992: LD_INT 30
22994: PUSH
22995: LD_VAR 0 2
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PPUSH
23004: CALL_OW 72
23008: ST_TO_ADDR
// if not tmp then
23009: LD_VAR 0 4
23013: NOT
23014: IFFALSE 23018
// exit ;
23016: GO 23078
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
23018: LD_ADDR_EXP 53
23022: PUSH
23023: LD_EXP 53
23027: PPUSH
23028: LD_VAR 0 1
23032: PPUSH
23033: LD_EXP 53
23037: PUSH
23038: LD_VAR 0 1
23042: ARRAY
23043: PPUSH
23044: LD_EXP 53
23048: PUSH
23049: LD_VAR 0 1
23053: ARRAY
23054: PUSH
23055: LD_INT 1
23057: PLUS
23058: PPUSH
23059: LD_VAR 0 4
23063: PUSH
23064: LD_INT 1
23066: ARRAY
23067: PPUSH
23068: CALL_OW 2
23072: PPUSH
23073: CALL_OW 1
23077: ST_TO_ADDR
// end ;
23078: LD_VAR 0 3
23082: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
23083: LD_INT 0
23085: PPUSH
23086: PPUSH
// if not mc_bases or not base or not kinds then
23087: LD_EXP 21
23091: NOT
23092: PUSH
23093: LD_VAR 0 1
23097: NOT
23098: OR
23099: PUSH
23100: LD_VAR 0 2
23104: NOT
23105: OR
23106: IFFALSE 23110
// exit ;
23108: GO 23171
// for i in kinds do
23110: LD_ADDR_VAR 0 4
23114: PUSH
23115: LD_VAR 0 2
23119: PUSH
23120: FOR_IN
23121: IFFALSE 23169
// mc_lab_upgrade := Add ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
23123: LD_ADDR_EXP 55
23127: PUSH
23128: LD_EXP 55
23132: PPUSH
23133: LD_VAR 0 1
23137: PUSH
23138: LD_EXP 55
23142: PUSH
23143: LD_VAR 0 1
23147: ARRAY
23148: PUSH
23149: LD_INT 1
23151: PLUS
23152: PUSH
23153: EMPTY
23154: LIST
23155: LIST
23156: PPUSH
23157: LD_VAR 0 4
23161: PPUSH
23162: CALL 35208 0 3
23166: ST_TO_ADDR
23167: GO 23120
23169: POP
23170: POP
// end ;
23171: LD_VAR 0 3
23175: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
23176: LD_INT 0
23178: PPUSH
// if not mc_bases or not base or not areas then
23179: LD_EXP 21
23183: NOT
23184: PUSH
23185: LD_VAR 0 1
23189: NOT
23190: OR
23191: PUSH
23192: LD_VAR 0 2
23196: NOT
23197: OR
23198: IFFALSE 23202
// exit ;
23200: GO 23227
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
23202: LD_ADDR_EXP 39
23206: PUSH
23207: LD_EXP 39
23211: PPUSH
23212: LD_VAR 0 1
23216: PPUSH
23217: LD_VAR 0 2
23221: PPUSH
23222: CALL_OW 1
23226: ST_TO_ADDR
// end ;
23227: LD_VAR 0 3
23231: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
23232: LD_INT 0
23234: PPUSH
// if not mc_bases or not base or not teleports_exit then
23235: LD_EXP 21
23239: NOT
23240: PUSH
23241: LD_VAR 0 1
23245: NOT
23246: OR
23247: PUSH
23248: LD_VAR 0 2
23252: NOT
23253: OR
23254: IFFALSE 23258
// exit ;
23256: GO 23283
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
23258: LD_ADDR_EXP 56
23262: PUSH
23263: LD_EXP 56
23267: PPUSH
23268: LD_VAR 0 1
23272: PPUSH
23273: LD_VAR 0 2
23277: PPUSH
23278: CALL_OW 1
23282: ST_TO_ADDR
// end ;
23283: LD_VAR 0 3
23287: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
23288: LD_INT 0
23290: PPUSH
23291: PPUSH
23292: PPUSH
// if not mc_bases or not base or not ext_list then
23293: LD_EXP 21
23297: NOT
23298: PUSH
23299: LD_VAR 0 1
23303: NOT
23304: OR
23305: PUSH
23306: LD_VAR 0 5
23310: NOT
23311: OR
23312: IFFALSE 23316
// exit ;
23314: GO 23489
// tmp := GetFacExtXYD ( x , y , d ) ;
23316: LD_ADDR_VAR 0 8
23320: PUSH
23321: LD_VAR 0 2
23325: PPUSH
23326: LD_VAR 0 3
23330: PPUSH
23331: LD_VAR 0 4
23335: PPUSH
23336: CALL 67934 0 3
23340: ST_TO_ADDR
// if not tmp then
23341: LD_VAR 0 8
23345: NOT
23346: IFFALSE 23350
// exit ;
23348: GO 23489
// for i in tmp do
23350: LD_ADDR_VAR 0 7
23354: PUSH
23355: LD_VAR 0 8
23359: PUSH
23360: FOR_IN
23361: IFFALSE 23487
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
23363: LD_ADDR_EXP 26
23367: PUSH
23368: LD_EXP 26
23372: PPUSH
23373: LD_VAR 0 1
23377: PPUSH
23378: LD_EXP 26
23382: PUSH
23383: LD_VAR 0 1
23387: ARRAY
23388: PPUSH
23389: LD_EXP 26
23393: PUSH
23394: LD_VAR 0 1
23398: ARRAY
23399: PUSH
23400: LD_INT 1
23402: PLUS
23403: PPUSH
23404: LD_VAR 0 5
23408: PUSH
23409: LD_INT 1
23411: ARRAY
23412: PUSH
23413: LD_VAR 0 7
23417: PUSH
23418: LD_INT 1
23420: ARRAY
23421: PUSH
23422: LD_VAR 0 7
23426: PUSH
23427: LD_INT 2
23429: ARRAY
23430: PUSH
23431: LD_VAR 0 7
23435: PUSH
23436: LD_INT 3
23438: ARRAY
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: LIST
23444: LIST
23445: PPUSH
23446: CALL_OW 2
23450: PPUSH
23451: CALL_OW 1
23455: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
23456: LD_ADDR_VAR 0 5
23460: PUSH
23461: LD_VAR 0 5
23465: PPUSH
23466: LD_INT 1
23468: PPUSH
23469: CALL_OW 3
23473: ST_TO_ADDR
// if not ext_list then
23474: LD_VAR 0 5
23478: NOT
23479: IFFALSE 23485
// exit ;
23481: POP
23482: POP
23483: GO 23489
// end ;
23485: GO 23360
23487: POP
23488: POP
// end ;
23489: LD_VAR 0 6
23493: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
23494: LD_INT 0
23496: PPUSH
// if not mc_bases or not base or not weapon_list then
23497: LD_EXP 21
23501: NOT
23502: PUSH
23503: LD_VAR 0 1
23507: NOT
23508: OR
23509: PUSH
23510: LD_VAR 0 2
23514: NOT
23515: OR
23516: IFFALSE 23520
// exit ;
23518: GO 23545
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
23520: LD_ADDR_EXP 60
23524: PUSH
23525: LD_EXP 60
23529: PPUSH
23530: LD_VAR 0 1
23534: PPUSH
23535: LD_VAR 0 2
23539: PPUSH
23540: CALL_OW 1
23544: ST_TO_ADDR
// end ;
23545: LD_VAR 0 3
23549: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
23550: LD_INT 0
23552: PPUSH
// if not mc_bases or not base or not tech_list then
23553: LD_EXP 21
23557: NOT
23558: PUSH
23559: LD_VAR 0 1
23563: NOT
23564: OR
23565: PUSH
23566: LD_VAR 0 2
23570: NOT
23571: OR
23572: IFFALSE 23576
// exit ;
23574: GO 23601
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
23576: LD_ADDR_EXP 48
23580: PUSH
23581: LD_EXP 48
23585: PPUSH
23586: LD_VAR 0 1
23590: PPUSH
23591: LD_VAR 0 2
23595: PPUSH
23596: CALL_OW 1
23600: ST_TO_ADDR
// end ;
23601: LD_VAR 0 3
23605: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
23606: LD_INT 0
23608: PPUSH
// if not mc_bases or not parking_area or not base then
23609: LD_EXP 21
23613: NOT
23614: PUSH
23615: LD_VAR 0 2
23619: NOT
23620: OR
23621: PUSH
23622: LD_VAR 0 1
23626: NOT
23627: OR
23628: IFFALSE 23632
// exit ;
23630: GO 23657
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
23632: LD_ADDR_EXP 45
23636: PUSH
23637: LD_EXP 45
23641: PPUSH
23642: LD_VAR 0 1
23646: PPUSH
23647: LD_VAR 0 2
23651: PPUSH
23652: CALL_OW 1
23656: ST_TO_ADDR
// end ;
23657: LD_VAR 0 3
23661: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
23662: LD_INT 0
23664: PPUSH
// if not mc_bases or not base or not scan_area then
23665: LD_EXP 21
23669: NOT
23670: PUSH
23671: LD_VAR 0 1
23675: NOT
23676: OR
23677: PUSH
23678: LD_VAR 0 2
23682: NOT
23683: OR
23684: IFFALSE 23688
// exit ;
23686: GO 23713
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
23688: LD_ADDR_EXP 46
23692: PUSH
23693: LD_EXP 46
23697: PPUSH
23698: LD_VAR 0 1
23702: PPUSH
23703: LD_VAR 0 2
23707: PPUSH
23708: CALL_OW 1
23712: ST_TO_ADDR
// end ;
23713: LD_VAR 0 3
23717: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
23718: LD_INT 0
23720: PPUSH
23721: PPUSH
// if not mc_bases or not base then
23722: LD_EXP 21
23726: NOT
23727: PUSH
23728: LD_VAR 0 1
23732: NOT
23733: OR
23734: IFFALSE 23738
// exit ;
23736: GO 23802
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
23738: LD_ADDR_VAR 0 3
23742: PUSH
23743: LD_INT 1
23745: PUSH
23746: LD_INT 2
23748: PUSH
23749: LD_INT 3
23751: PUSH
23752: LD_INT 4
23754: PUSH
23755: LD_INT 11
23757: PUSH
23758: EMPTY
23759: LIST
23760: LIST
23761: LIST
23762: LIST
23763: LIST
23764: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
23765: LD_ADDR_EXP 48
23769: PUSH
23770: LD_EXP 48
23774: PPUSH
23775: LD_VAR 0 1
23779: PPUSH
23780: LD_EXP 48
23784: PUSH
23785: LD_VAR 0 1
23789: ARRAY
23790: PUSH
23791: LD_VAR 0 3
23795: DIFF
23796: PPUSH
23797: CALL_OW 1
23801: ST_TO_ADDR
// end ; end_of_file
23802: LD_VAR 0 2
23806: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
23807: LD_INT 0
23809: PPUSH
23810: PPUSH
23811: PPUSH
// if not mc_bases then
23812: LD_EXP 21
23816: NOT
23817: IFFALSE 23821
// exit ;
23819: GO 23986
// for i = 1 to mc_bases do
23821: LD_ADDR_VAR 0 4
23825: PUSH
23826: DOUBLE
23827: LD_INT 1
23829: DEC
23830: ST_TO_ADDR
23831: LD_EXP 21
23835: PUSH
23836: FOR_TO
23837: IFFALSE 23984
// begin if sci in mc_bases [ i ] then
23839: LD_VAR 0 2
23843: PUSH
23844: LD_EXP 21
23848: PUSH
23849: LD_VAR 0 4
23853: ARRAY
23854: IN
23855: IFFALSE 23982
// begin mc_ape := Add ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
23857: LD_ADDR_EXP 50
23861: PUSH
23862: LD_EXP 50
23866: PPUSH
23867: LD_VAR 0 4
23871: PUSH
23872: LD_EXP 50
23876: PUSH
23877: LD_VAR 0 4
23881: ARRAY
23882: PUSH
23883: LD_INT 1
23885: PLUS
23886: PUSH
23887: EMPTY
23888: LIST
23889: LIST
23890: PPUSH
23891: LD_VAR 0 1
23895: PPUSH
23896: CALL 35208 0 3
23900: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
23901: LD_ADDR_VAR 0 5
23905: PUSH
23906: LD_EXP 21
23910: PUSH
23911: LD_VAR 0 4
23915: ARRAY
23916: PPUSH
23917: LD_INT 2
23919: PUSH
23920: LD_INT 30
23922: PUSH
23923: LD_INT 0
23925: PUSH
23926: EMPTY
23927: LIST
23928: LIST
23929: PUSH
23930: LD_INT 30
23932: PUSH
23933: LD_INT 1
23935: PUSH
23936: EMPTY
23937: LIST
23938: LIST
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: LIST
23944: PPUSH
23945: CALL_OW 72
23949: PPUSH
23950: LD_VAR 0 1
23954: PPUSH
23955: CALL_OW 74
23959: ST_TO_ADDR
// if tmp then
23960: LD_VAR 0 5
23964: IFFALSE 23980
// ComStandNearbyBuilding ( ape , tmp ) ;
23966: LD_VAR 0 1
23970: PPUSH
23971: LD_VAR 0 5
23975: PPUSH
23976: CALL 29450 0 2
// break ;
23980: GO 23984
// end ; end ;
23982: GO 23836
23984: POP
23985: POP
// end ;
23986: LD_VAR 0 3
23990: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
23991: LD_INT 0
23993: PPUSH
23994: PPUSH
23995: PPUSH
// if not mc_bases then
23996: LD_EXP 21
24000: NOT
24001: IFFALSE 24005
// exit ;
24003: GO 24094
// for i = 1 to mc_bases do
24005: LD_ADDR_VAR 0 4
24009: PUSH
24010: DOUBLE
24011: LD_INT 1
24013: DEC
24014: ST_TO_ADDR
24015: LD_EXP 21
24019: PUSH
24020: FOR_TO
24021: IFFALSE 24092
// begin if building in mc_busy_turret_list [ i ] then
24023: LD_VAR 0 1
24027: PUSH
24028: LD_EXP 31
24032: PUSH
24033: LD_VAR 0 4
24037: ARRAY
24038: IN
24039: IFFALSE 24090
// begin tmp := mc_busy_turret_list [ i ] diff building ;
24041: LD_ADDR_VAR 0 5
24045: PUSH
24046: LD_EXP 31
24050: PUSH
24051: LD_VAR 0 4
24055: ARRAY
24056: PUSH
24057: LD_VAR 0 1
24061: DIFF
24062: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
24063: LD_ADDR_EXP 31
24067: PUSH
24068: LD_EXP 31
24072: PPUSH
24073: LD_VAR 0 4
24077: PPUSH
24078: LD_VAR 0 5
24082: PPUSH
24083: CALL_OW 1
24087: ST_TO_ADDR
// break ;
24088: GO 24092
// end ; end ;
24090: GO 24020
24092: POP
24093: POP
// end ;
24094: LD_VAR 0 3
24098: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
24099: LD_INT 0
24101: PPUSH
24102: PPUSH
24103: PPUSH
// if not mc_bases then
24104: LD_EXP 21
24108: NOT
24109: IFFALSE 24113
// exit ;
24111: GO 24312
// for i = 1 to mc_bases do
24113: LD_ADDR_VAR 0 5
24117: PUSH
24118: DOUBLE
24119: LD_INT 1
24121: DEC
24122: ST_TO_ADDR
24123: LD_EXP 21
24127: PUSH
24128: FOR_TO
24129: IFFALSE 24310
// if building in mc_bases [ i ] then
24131: LD_VAR 0 1
24135: PUSH
24136: LD_EXP 21
24140: PUSH
24141: LD_VAR 0 5
24145: ARRAY
24146: IN
24147: IFFALSE 24308
// begin tmp := mc_bases [ i ] diff building ;
24149: LD_ADDR_VAR 0 6
24153: PUSH
24154: LD_EXP 21
24158: PUSH
24159: LD_VAR 0 5
24163: ARRAY
24164: PUSH
24165: LD_VAR 0 1
24169: DIFF
24170: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
24171: LD_ADDR_EXP 21
24175: PUSH
24176: LD_EXP 21
24180: PPUSH
24181: LD_VAR 0 5
24185: PPUSH
24186: LD_VAR 0 6
24190: PPUSH
24191: CALL_OW 1
24195: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
24196: LD_VAR 0 1
24200: PUSH
24201: LD_EXP 29
24205: PUSH
24206: LD_VAR 0 5
24210: ARRAY
24211: IN
24212: IFFALSE 24251
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
24214: LD_ADDR_EXP 29
24218: PUSH
24219: LD_EXP 29
24223: PPUSH
24224: LD_VAR 0 5
24228: PPUSH
24229: LD_EXP 29
24233: PUSH
24234: LD_VAR 0 5
24238: ARRAY
24239: PUSH
24240: LD_VAR 0 1
24244: DIFF
24245: PPUSH
24246: CALL_OW 1
24250: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
24251: LD_VAR 0 1
24255: PUSH
24256: LD_EXP 30
24260: PUSH
24261: LD_VAR 0 5
24265: ARRAY
24266: IN
24267: IFFALSE 24306
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
24269: LD_ADDR_EXP 30
24273: PUSH
24274: LD_EXP 30
24278: PPUSH
24279: LD_VAR 0 5
24283: PPUSH
24284: LD_EXP 30
24288: PUSH
24289: LD_VAR 0 5
24293: ARRAY
24294: PUSH
24295: LD_VAR 0 1
24299: DIFF
24300: PPUSH
24301: CALL_OW 1
24305: ST_TO_ADDR
// break ;
24306: GO 24310
// end ;
24308: GO 24128
24310: POP
24311: POP
// end ;
24312: LD_VAR 0 4
24316: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
24317: LD_INT 0
24319: PPUSH
24320: PPUSH
24321: PPUSH
// if not mc_bases or not side in mc_sides then
24322: LD_EXP 21
24326: NOT
24327: PUSH
24328: LD_VAR 0 3
24332: PUSH
24333: LD_EXP 47
24337: IN
24338: NOT
24339: OR
24340: IFFALSE 24344
// exit ;
24342: GO 24467
// for i = 1 to mc_vehicles do
24344: LD_ADDR_VAR 0 6
24348: PUSH
24349: DOUBLE
24350: LD_INT 1
24352: DEC
24353: ST_TO_ADDR
24354: LD_EXP 40
24358: PUSH
24359: FOR_TO
24360: IFFALSE 24465
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
24362: LD_VAR 0 2
24366: PUSH
24367: LD_EXP 40
24371: PUSH
24372: LD_VAR 0 6
24376: ARRAY
24377: IN
24378: PUSH
24379: LD_VAR 0 1
24383: PUSH
24384: LD_EXP 40
24388: PUSH
24389: LD_VAR 0 6
24393: ARRAY
24394: IN
24395: OR
24396: IFFALSE 24463
// begin tmp := mc_vehicles [ i ] diff old ;
24398: LD_ADDR_VAR 0 7
24402: PUSH
24403: LD_EXP 40
24407: PUSH
24408: LD_VAR 0 6
24412: ARRAY
24413: PUSH
24414: LD_VAR 0 2
24418: DIFF
24419: ST_TO_ADDR
// tmp := tmp diff new ;
24420: LD_ADDR_VAR 0 7
24424: PUSH
24425: LD_VAR 0 7
24429: PUSH
24430: LD_VAR 0 1
24434: DIFF
24435: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
24436: LD_ADDR_EXP 40
24440: PUSH
24441: LD_EXP 40
24445: PPUSH
24446: LD_VAR 0 6
24450: PPUSH
24451: LD_VAR 0 7
24455: PPUSH
24456: CALL_OW 1
24460: ST_TO_ADDR
// break ;
24461: GO 24465
// end ;
24463: GO 24359
24465: POP
24466: POP
// end ;
24467: LD_VAR 0 5
24471: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
24472: LD_INT 0
24474: PPUSH
24475: PPUSH
24476: PPUSH
24477: PPUSH
// if not mc_bases then
24478: LD_EXP 21
24482: NOT
24483: IFFALSE 24487
// exit ;
24485: GO 24870
// side := GetSide ( vehicle ) ;
24487: LD_ADDR_VAR 0 5
24491: PUSH
24492: LD_VAR 0 1
24496: PPUSH
24497: CALL_OW 255
24501: ST_TO_ADDR
// for i = 1 to mc_bases do
24502: LD_ADDR_VAR 0 4
24506: PUSH
24507: DOUBLE
24508: LD_INT 1
24510: DEC
24511: ST_TO_ADDR
24512: LD_EXP 21
24516: PUSH
24517: FOR_TO
24518: IFFALSE 24868
// begin if factory in mc_bases [ i ] then
24520: LD_VAR 0 2
24524: PUSH
24525: LD_EXP 21
24529: PUSH
24530: LD_VAR 0 4
24534: ARRAY
24535: IN
24536: IFFALSE 24866
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
24538: LD_EXP 43
24542: PUSH
24543: LD_VAR 0 4
24547: ARRAY
24548: PUSH
24549: LD_EXP 32
24553: PUSH
24554: LD_VAR 0 4
24558: ARRAY
24559: LESS
24560: PUSH
24561: LD_VAR 0 1
24565: PPUSH
24566: CALL_OW 264
24570: PUSH
24571: LD_INT 31
24573: PUSH
24574: LD_INT 32
24576: PUSH
24577: LD_INT 51
24579: PUSH
24580: LD_EXP 15
24584: PUSH
24585: LD_INT 12
24587: PUSH
24588: LD_INT 30
24590: PUSH
24591: LD_EXP 14
24595: PUSH
24596: LD_INT 11
24598: PUSH
24599: LD_INT 53
24601: PUSH
24602: LD_INT 14
24604: PUSH
24605: LD_EXP 18
24609: PUSH
24610: LD_INT 29
24612: PUSH
24613: LD_EXP 16
24617: PUSH
24618: LD_INT 13
24620: PUSH
24621: LD_INT 52
24623: PUSH
24624: LD_INT 48
24626: PUSH
24627: LD_INT 8
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: LIST
24634: LIST
24635: LIST
24636: LIST
24637: LIST
24638: LIST
24639: LIST
24640: LIST
24641: LIST
24642: LIST
24643: LIST
24644: LIST
24645: LIST
24646: LIST
24647: LIST
24648: IN
24649: NOT
24650: AND
24651: IFFALSE 24692
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
24653: LD_ADDR_EXP 43
24657: PUSH
24658: LD_EXP 43
24662: PPUSH
24663: LD_VAR 0 4
24667: PPUSH
24668: LD_EXP 43
24672: PUSH
24673: LD_VAR 0 4
24677: ARRAY
24678: PUSH
24679: LD_VAR 0 1
24683: ADD
24684: PPUSH
24685: CALL_OW 1
24689: ST_TO_ADDR
24690: GO 24736
// mc_vehicles := Add ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
24692: LD_ADDR_EXP 40
24696: PUSH
24697: LD_EXP 40
24701: PPUSH
24702: LD_VAR 0 4
24706: PUSH
24707: LD_EXP 40
24711: PUSH
24712: LD_VAR 0 4
24716: ARRAY
24717: PUSH
24718: LD_INT 1
24720: PLUS
24721: PUSH
24722: EMPTY
24723: LIST
24724: LIST
24725: PPUSH
24726: LD_VAR 0 1
24730: PPUSH
24731: CALL 35208 0 3
24735: ST_TO_ADDR
// if not mc_scan [ i ] then
24736: LD_EXP 44
24740: PUSH
24741: LD_VAR 0 4
24745: ARRAY
24746: NOT
24747: IFFALSE 24866
// begin if GetControl ( vehicle ) = control_remote then
24749: LD_VAR 0 1
24753: PPUSH
24754: CALL_OW 263
24758: PUSH
24759: LD_INT 2
24761: EQUAL
24762: IFFALSE 24782
// repeat wait ( 0 0$1 ) ;
24764: LD_INT 35
24766: PPUSH
24767: CALL_OW 67
// until IsControledBy ( vehicle ) ;
24771: LD_VAR 0 1
24775: PPUSH
24776: CALL_OW 312
24780: IFFALSE 24764
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
24782: LD_VAR 0 1
24786: PPUSH
24787: LD_EXP 45
24791: PUSH
24792: LD_VAR 0 4
24796: ARRAY
24797: PPUSH
24798: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
24802: LD_VAR 0 1
24806: PPUSH
24807: CALL_OW 263
24811: PUSH
24812: LD_INT 1
24814: NONEQUAL
24815: IFFALSE 24819
// break ;
24817: GO 24868
// repeat wait ( 0 0$1 ) ;
24819: LD_INT 35
24821: PPUSH
24822: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
24826: LD_VAR 0 1
24830: PPUSH
24831: LD_EXP 45
24835: PUSH
24836: LD_VAR 0 4
24840: ARRAY
24841: PPUSH
24842: CALL_OW 308
24846: IFFALSE 24819
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
24848: LD_VAR 0 1
24852: PPUSH
24853: CALL_OW 311
24857: PPUSH
24858: CALL_OW 121
// exit ;
24862: POP
24863: POP
24864: GO 24870
// end ; end ; end ;
24866: GO 24517
24868: POP
24869: POP
// end ;
24870: LD_VAR 0 3
24874: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
24875: LD_INT 0
24877: PPUSH
24878: PPUSH
24879: PPUSH
24880: PPUSH
// if not mc_bases then
24881: LD_EXP 21
24885: NOT
24886: IFFALSE 24890
// exit ;
24888: GO 25243
// repeat wait ( 0 0$1 ) ;
24890: LD_INT 35
24892: PPUSH
24893: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
24897: LD_VAR 0 2
24901: PPUSH
24902: LD_VAR 0 3
24906: PPUSH
24907: CALL_OW 284
24911: IFFALSE 24890
// if GetResourceTypeXY ( x , y ) = mat_artefact then
24913: LD_VAR 0 2
24917: PPUSH
24918: LD_VAR 0 3
24922: PPUSH
24923: CALL_OW 283
24927: PUSH
24928: LD_INT 4
24930: EQUAL
24931: IFFALSE 24935
// exit ;
24933: GO 25243
// for i = 1 to mc_bases do
24935: LD_ADDR_VAR 0 7
24939: PUSH
24940: DOUBLE
24941: LD_INT 1
24943: DEC
24944: ST_TO_ADDR
24945: LD_EXP 21
24949: PUSH
24950: FOR_TO
24951: IFFALSE 25241
// begin if mc_crates_area [ i ] then
24953: LD_EXP 39
24957: PUSH
24958: LD_VAR 0 7
24962: ARRAY
24963: IFFALSE 25074
// for j in mc_crates_area [ i ] do
24965: LD_ADDR_VAR 0 8
24969: PUSH
24970: LD_EXP 39
24974: PUSH
24975: LD_VAR 0 7
24979: ARRAY
24980: PUSH
24981: FOR_IN
24982: IFFALSE 25072
// if InArea ( x , y , j ) then
24984: LD_VAR 0 2
24988: PPUSH
24989: LD_VAR 0 3
24993: PPUSH
24994: LD_VAR 0 8
24998: PPUSH
24999: CALL_OW 309
25003: IFFALSE 25070
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
25005: LD_ADDR_EXP 37
25009: PUSH
25010: LD_EXP 37
25014: PPUSH
25015: LD_VAR 0 7
25019: PUSH
25020: LD_EXP 37
25024: PUSH
25025: LD_VAR 0 7
25029: ARRAY
25030: PUSH
25031: LD_INT 1
25033: PLUS
25034: PUSH
25035: EMPTY
25036: LIST
25037: LIST
25038: PPUSH
25039: LD_VAR 0 4
25043: PUSH
25044: LD_VAR 0 2
25048: PUSH
25049: LD_VAR 0 3
25053: PUSH
25054: EMPTY
25055: LIST
25056: LIST
25057: LIST
25058: PPUSH
25059: CALL 35208 0 3
25063: ST_TO_ADDR
// exit ;
25064: POP
25065: POP
25066: POP
25067: POP
25068: GO 25243
// end ;
25070: GO 24981
25072: POP
25073: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
25074: LD_ADDR_VAR 0 9
25078: PUSH
25079: LD_EXP 21
25083: PUSH
25084: LD_VAR 0 7
25088: ARRAY
25089: PPUSH
25090: LD_INT 2
25092: PUSH
25093: LD_INT 30
25095: PUSH
25096: LD_INT 0
25098: PUSH
25099: EMPTY
25100: LIST
25101: LIST
25102: PUSH
25103: LD_INT 30
25105: PUSH
25106: LD_INT 1
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: PUSH
25113: EMPTY
25114: LIST
25115: LIST
25116: LIST
25117: PPUSH
25118: CALL_OW 72
25122: ST_TO_ADDR
// if not depot then
25123: LD_VAR 0 9
25127: NOT
25128: IFFALSE 25132
// continue ;
25130: GO 24950
// for j in depot do
25132: LD_ADDR_VAR 0 8
25136: PUSH
25137: LD_VAR 0 9
25141: PUSH
25142: FOR_IN
25143: IFFALSE 25237
// if GetDistUnitXY ( j , x , y ) < 30 then
25145: LD_VAR 0 8
25149: PPUSH
25150: LD_VAR 0 2
25154: PPUSH
25155: LD_VAR 0 3
25159: PPUSH
25160: CALL_OW 297
25164: PUSH
25165: LD_INT 30
25167: LESS
25168: IFFALSE 25235
// begin mc_crates := Add ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
25170: LD_ADDR_EXP 37
25174: PUSH
25175: LD_EXP 37
25179: PPUSH
25180: LD_VAR 0 7
25184: PUSH
25185: LD_EXP 37
25189: PUSH
25190: LD_VAR 0 7
25194: ARRAY
25195: PUSH
25196: LD_INT 1
25198: PLUS
25199: PUSH
25200: EMPTY
25201: LIST
25202: LIST
25203: PPUSH
25204: LD_VAR 0 4
25208: PUSH
25209: LD_VAR 0 2
25213: PUSH
25214: LD_VAR 0 3
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: LIST
25223: PPUSH
25224: CALL 35208 0 3
25228: ST_TO_ADDR
// exit ;
25229: POP
25230: POP
25231: POP
25232: POP
25233: GO 25243
// end ;
25235: GO 25142
25237: POP
25238: POP
// end ;
25239: GO 24950
25241: POP
25242: POP
// end ;
25243: LD_VAR 0 6
25247: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
25248: LD_INT 0
25250: PPUSH
25251: PPUSH
25252: PPUSH
25253: PPUSH
// side := GetSide ( lab ) ;
25254: LD_ADDR_VAR 0 4
25258: PUSH
25259: LD_VAR 0 2
25263: PPUSH
25264: CALL_OW 255
25268: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
25269: LD_VAR 0 4
25273: PUSH
25274: LD_EXP 47
25278: IN
25279: NOT
25280: PUSH
25281: LD_EXP 48
25285: NOT
25286: OR
25287: PUSH
25288: LD_EXP 21
25292: NOT
25293: OR
25294: IFFALSE 25298
// exit ;
25296: GO 25531
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
25298: LD_ADDR_EXP 48
25302: PUSH
25303: LD_EXP 48
25307: PPUSH
25308: LD_VAR 0 4
25312: PPUSH
25313: LD_EXP 48
25317: PUSH
25318: LD_VAR 0 4
25322: ARRAY
25323: PUSH
25324: LD_VAR 0 1
25328: DIFF
25329: PPUSH
25330: CALL_OW 1
25334: ST_TO_ADDR
// for i = 1 to mc_bases do
25335: LD_ADDR_VAR 0 5
25339: PUSH
25340: DOUBLE
25341: LD_INT 1
25343: DEC
25344: ST_TO_ADDR
25345: LD_EXP 21
25349: PUSH
25350: FOR_TO
25351: IFFALSE 25529
// begin if lab in mc_bases [ i ] then
25353: LD_VAR 0 2
25357: PUSH
25358: LD_EXP 21
25362: PUSH
25363: LD_VAR 0 5
25367: ARRAY
25368: IN
25369: IFFALSE 25527
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
25371: LD_VAR 0 1
25375: PUSH
25376: LD_INT 11
25378: PUSH
25379: LD_INT 4
25381: PUSH
25382: LD_INT 3
25384: PUSH
25385: LD_INT 2
25387: PUSH
25388: EMPTY
25389: LIST
25390: LIST
25391: LIST
25392: LIST
25393: IN
25394: PUSH
25395: LD_EXP 51
25399: PUSH
25400: LD_VAR 0 5
25404: ARRAY
25405: AND
25406: IFFALSE 25527
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
25408: LD_ADDR_VAR 0 6
25412: PUSH
25413: LD_EXP 51
25417: PUSH
25418: LD_VAR 0 5
25422: ARRAY
25423: PUSH
25424: LD_INT 1
25426: ARRAY
25427: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25428: LD_ADDR_EXP 51
25432: PUSH
25433: LD_EXP 51
25437: PPUSH
25438: LD_VAR 0 5
25442: PPUSH
25443: EMPTY
25444: PPUSH
25445: CALL_OW 1
25449: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
25450: LD_VAR 0 6
25454: PPUSH
25455: LD_INT 0
25457: PPUSH
25458: CALL_OW 109
// ComExitBuilding ( tmp ) ;
25462: LD_VAR 0 6
25466: PPUSH
25467: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
25471: LD_ADDR_EXP 50
25475: PUSH
25476: LD_EXP 50
25480: PPUSH
25481: LD_VAR 0 5
25485: PPUSH
25486: LD_EXP 50
25490: PUSH
25491: LD_VAR 0 5
25495: ARRAY
25496: PPUSH
25497: LD_INT 1
25499: PPUSH
25500: LD_VAR 0 6
25504: PPUSH
25505: CALL_OW 2
25509: PPUSH
25510: CALL_OW 1
25514: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
25515: LD_VAR 0 5
25519: PPUSH
25520: LD_INT 112
25522: PPUSH
25523: CALL 3581 0 2
// end ; end ; end ;
25527: GO 25350
25529: POP
25530: POP
// end ;
25531: LD_VAR 0 3
25535: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
25536: LD_INT 0
25538: PPUSH
25539: PPUSH
25540: PPUSH
25541: PPUSH
25542: PPUSH
25543: PPUSH
25544: PPUSH
25545: PPUSH
// if not mc_bases then
25546: LD_EXP 21
25550: NOT
25551: IFFALSE 25555
// exit ;
25553: GO 26498
// for i = 1 to mc_bases do
25555: LD_ADDR_VAR 0 3
25559: PUSH
25560: DOUBLE
25561: LD_INT 1
25563: DEC
25564: ST_TO_ADDR
25565: LD_EXP 21
25569: PUSH
25570: FOR_TO
25571: IFFALSE 26496
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
25573: LD_VAR 0 1
25577: PUSH
25578: LD_EXP 21
25582: PUSH
25583: LD_VAR 0 3
25587: ARRAY
25588: IN
25589: PUSH
25590: LD_VAR 0 1
25594: PUSH
25595: LD_EXP 28
25599: PUSH
25600: LD_VAR 0 3
25604: ARRAY
25605: IN
25606: OR
25607: PUSH
25608: LD_VAR 0 1
25612: PUSH
25613: LD_EXP 40
25617: PUSH
25618: LD_VAR 0 3
25622: ARRAY
25623: IN
25624: OR
25625: PUSH
25626: LD_VAR 0 1
25630: PUSH
25631: LD_EXP 50
25635: PUSH
25636: LD_VAR 0 3
25640: ARRAY
25641: IN
25642: OR
25643: PUSH
25644: LD_VAR 0 1
25648: PUSH
25649: LD_EXP 51
25653: PUSH
25654: LD_VAR 0 3
25658: ARRAY
25659: IN
25660: OR
25661: IFFALSE 26494
// begin if un in mc_ape [ i ] then
25663: LD_VAR 0 1
25667: PUSH
25668: LD_EXP 50
25672: PUSH
25673: LD_VAR 0 3
25677: ARRAY
25678: IN
25679: IFFALSE 25718
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
25681: LD_ADDR_EXP 50
25685: PUSH
25686: LD_EXP 50
25690: PPUSH
25691: LD_VAR 0 3
25695: PPUSH
25696: LD_EXP 50
25700: PUSH
25701: LD_VAR 0 3
25705: ARRAY
25706: PUSH
25707: LD_VAR 0 1
25711: DIFF
25712: PPUSH
25713: CALL_OW 1
25717: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
25718: LD_VAR 0 1
25722: PUSH
25723: LD_EXP 51
25727: PUSH
25728: LD_VAR 0 3
25732: ARRAY
25733: IN
25734: IFFALSE 25758
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
25736: LD_ADDR_EXP 51
25740: PUSH
25741: LD_EXP 51
25745: PPUSH
25746: LD_VAR 0 3
25750: PPUSH
25751: EMPTY
25752: PPUSH
25753: CALL_OW 1
25757: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
25758: LD_VAR 0 1
25762: PPUSH
25763: CALL_OW 247
25767: PUSH
25768: LD_INT 2
25770: EQUAL
25771: PUSH
25772: LD_VAR 0 1
25776: PPUSH
25777: CALL_OW 110
25781: PUSH
25782: LD_INT 20
25784: EQUAL
25785: AND
25786: IFFALSE 25889
// begin fac := MC_GetBuilding ( i , b_factory ) ;
25788: LD_ADDR_VAR 0 8
25792: PUSH
25793: LD_VAR 0 3
25797: PPUSH
25798: LD_INT 3
25800: PPUSH
25801: CALL 22824 0 2
25805: ST_TO_ADDR
// if fac then
25806: LD_VAR 0 8
25810: IFFALSE 25889
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
25812: LD_ADDR_VAR 0 9
25816: PUSH
25817: LD_VAR 0 8
25821: PPUSH
25822: LD_VAR 0 1
25826: PPUSH
25827: CALL_OW 265
25831: PPUSH
25832: LD_VAR 0 1
25836: PPUSH
25837: CALL_OW 262
25841: PPUSH
25842: LD_VAR 0 1
25846: PPUSH
25847: CALL_OW 263
25851: PPUSH
25852: LD_VAR 0 1
25856: PPUSH
25857: CALL_OW 264
25861: PPUSH
25862: CALL 32373 0 5
25866: ST_TO_ADDR
// if components then
25867: LD_VAR 0 9
25871: IFFALSE 25887
// MC_InsertProduceList ( i , components ) ;
25873: LD_VAR 0 3
25877: PPUSH
25878: LD_VAR 0 9
25882: PPUSH
25883: CALL 22394 0 2
// break ;
25887: GO 26496
// end ; end ; if GetType ( un ) = unit_building then
25889: LD_VAR 0 1
25893: PPUSH
25894: CALL_OW 247
25898: PUSH
25899: LD_INT 3
25901: EQUAL
25902: IFFALSE 26217
// begin btype := GetBType ( un ) ;
25904: LD_ADDR_VAR 0 5
25908: PUSH
25909: LD_VAR 0 1
25913: PPUSH
25914: CALL_OW 266
25918: ST_TO_ADDR
// if btype = b_warehouse then
25919: LD_VAR 0 5
25923: PUSH
25924: LD_INT 1
25926: EQUAL
25927: IFFALSE 25945
// begin btype := b_depot ;
25929: LD_ADDR_VAR 0 5
25933: PUSH
25934: LD_INT 0
25936: ST_TO_ADDR
// pos := 1 ;
25937: LD_ADDR_VAR 0 6
25941: PUSH
25942: LD_INT 1
25944: ST_TO_ADDR
// end ; if btype = b_factory then
25945: LD_VAR 0 5
25949: PUSH
25950: LD_INT 3
25952: EQUAL
25953: IFFALSE 25971
// begin btype := b_workshop ;
25955: LD_ADDR_VAR 0 5
25959: PUSH
25960: LD_INT 2
25962: ST_TO_ADDR
// pos := 1 ;
25963: LD_ADDR_VAR 0 6
25967: PUSH
25968: LD_INT 1
25970: ST_TO_ADDR
// end ; if btype = b_barracks then
25971: LD_VAR 0 5
25975: PUSH
25976: LD_INT 5
25978: EQUAL
25979: IFFALSE 25989
// btype := b_armoury ;
25981: LD_ADDR_VAR 0 5
25985: PUSH
25986: LD_INT 4
25988: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
25989: LD_VAR 0 5
25993: PUSH
25994: LD_INT 7
25996: PUSH
25997: LD_INT 8
25999: PUSH
26000: EMPTY
26001: LIST
26002: LIST
26003: IN
26004: IFFALSE 26014
// btype := b_lab ;
26006: LD_ADDR_VAR 0 5
26010: PUSH
26011: LD_INT 6
26013: ST_TO_ADDR
// mc_build_list := Add ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
26014: LD_ADDR_EXP 26
26018: PUSH
26019: LD_EXP 26
26023: PPUSH
26024: LD_VAR 0 3
26028: PUSH
26029: LD_EXP 26
26033: PUSH
26034: LD_VAR 0 3
26038: ARRAY
26039: PUSH
26040: LD_INT 1
26042: PLUS
26043: PUSH
26044: EMPTY
26045: LIST
26046: LIST
26047: PPUSH
26048: LD_VAR 0 5
26052: PUSH
26053: LD_VAR 0 1
26057: PPUSH
26058: CALL_OW 250
26062: PUSH
26063: LD_VAR 0 1
26067: PPUSH
26068: CALL_OW 251
26072: PUSH
26073: LD_VAR 0 1
26077: PPUSH
26078: CALL_OW 254
26082: PUSH
26083: EMPTY
26084: LIST
26085: LIST
26086: LIST
26087: LIST
26088: PPUSH
26089: CALL 35208 0 3
26093: ST_TO_ADDR
// if pos = 1 then
26094: LD_VAR 0 6
26098: PUSH
26099: LD_INT 1
26101: EQUAL
26102: IFFALSE 26217
// begin tmp := mc_build_list [ i ] ;
26104: LD_ADDR_VAR 0 7
26108: PUSH
26109: LD_EXP 26
26113: PUSH
26114: LD_VAR 0 3
26118: ARRAY
26119: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
26120: LD_VAR 0 7
26124: PPUSH
26125: LD_INT 2
26127: PUSH
26128: LD_INT 30
26130: PUSH
26131: LD_INT 0
26133: PUSH
26134: EMPTY
26135: LIST
26136: LIST
26137: PUSH
26138: LD_INT 30
26140: PUSH
26141: LD_INT 1
26143: PUSH
26144: EMPTY
26145: LIST
26146: LIST
26147: PUSH
26148: EMPTY
26149: LIST
26150: LIST
26151: LIST
26152: PPUSH
26153: CALL_OW 72
26157: IFFALSE 26167
// pos := 2 ;
26159: LD_ADDR_VAR 0 6
26163: PUSH
26164: LD_INT 2
26166: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
26167: LD_ADDR_VAR 0 7
26171: PUSH
26172: LD_VAR 0 7
26176: PPUSH
26177: LD_VAR 0 6
26181: PPUSH
26182: LD_VAR 0 7
26186: PPUSH
26187: CALL 35099 0 3
26191: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
26192: LD_ADDR_EXP 26
26196: PUSH
26197: LD_EXP 26
26201: PPUSH
26202: LD_VAR 0 3
26206: PPUSH
26207: LD_VAR 0 7
26211: PPUSH
26212: CALL_OW 1
26216: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
26217: LD_VAR 0 1
26221: PUSH
26222: LD_EXP 21
26226: PUSH
26227: LD_VAR 0 3
26231: ARRAY
26232: IN
26233: IFFALSE 26272
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
26235: LD_ADDR_EXP 21
26239: PUSH
26240: LD_EXP 21
26244: PPUSH
26245: LD_VAR 0 3
26249: PPUSH
26250: LD_EXP 21
26254: PUSH
26255: LD_VAR 0 3
26259: ARRAY
26260: PUSH
26261: LD_VAR 0 1
26265: DIFF
26266: PPUSH
26267: CALL_OW 1
26271: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
26272: LD_VAR 0 1
26276: PUSH
26277: LD_EXP 28
26281: PUSH
26282: LD_VAR 0 3
26286: ARRAY
26287: IN
26288: IFFALSE 26327
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
26290: LD_ADDR_EXP 28
26294: PUSH
26295: LD_EXP 28
26299: PPUSH
26300: LD_VAR 0 3
26304: PPUSH
26305: LD_EXP 28
26309: PUSH
26310: LD_VAR 0 3
26314: ARRAY
26315: PUSH
26316: LD_VAR 0 1
26320: DIFF
26321: PPUSH
26322: CALL_OW 1
26326: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
26327: LD_VAR 0 1
26331: PUSH
26332: LD_EXP 40
26336: PUSH
26337: LD_VAR 0 3
26341: ARRAY
26342: IN
26343: IFFALSE 26382
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
26345: LD_ADDR_EXP 40
26349: PUSH
26350: LD_EXP 40
26354: PPUSH
26355: LD_VAR 0 3
26359: PPUSH
26360: LD_EXP 40
26364: PUSH
26365: LD_VAR 0 3
26369: ARRAY
26370: PUSH
26371: LD_VAR 0 1
26375: DIFF
26376: PPUSH
26377: CALL_OW 1
26381: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
26382: LD_VAR 0 1
26386: PUSH
26387: LD_EXP 30
26391: PUSH
26392: LD_VAR 0 3
26396: ARRAY
26397: IN
26398: IFFALSE 26437
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
26400: LD_ADDR_EXP 30
26404: PUSH
26405: LD_EXP 30
26409: PPUSH
26410: LD_VAR 0 3
26414: PPUSH
26415: LD_EXP 30
26419: PUSH
26420: LD_VAR 0 3
26424: ARRAY
26425: PUSH
26426: LD_VAR 0 1
26430: DIFF
26431: PPUSH
26432: CALL_OW 1
26436: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
26437: LD_VAR 0 1
26441: PUSH
26442: LD_EXP 29
26446: PUSH
26447: LD_VAR 0 3
26451: ARRAY
26452: IN
26453: IFFALSE 26492
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
26455: LD_ADDR_EXP 29
26459: PUSH
26460: LD_EXP 29
26464: PPUSH
26465: LD_VAR 0 3
26469: PPUSH
26470: LD_EXP 29
26474: PUSH
26475: LD_VAR 0 3
26479: ARRAY
26480: PUSH
26481: LD_VAR 0 1
26485: DIFF
26486: PPUSH
26487: CALL_OW 1
26491: ST_TO_ADDR
// end ; break ;
26492: GO 26496
// end ;
26494: GO 25570
26496: POP
26497: POP
// end ;
26498: LD_VAR 0 2
26502: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
26503: LD_INT 0
26505: PPUSH
26506: PPUSH
26507: PPUSH
// if not mc_bases then
26508: LD_EXP 21
26512: NOT
26513: IFFALSE 26517
// exit ;
26515: GO 26732
// for i = 1 to mc_bases do
26517: LD_ADDR_VAR 0 3
26521: PUSH
26522: DOUBLE
26523: LD_INT 1
26525: DEC
26526: ST_TO_ADDR
26527: LD_EXP 21
26531: PUSH
26532: FOR_TO
26533: IFFALSE 26730
// begin if building in mc_construct_list [ i ] then
26535: LD_VAR 0 1
26539: PUSH
26540: LD_EXP 28
26544: PUSH
26545: LD_VAR 0 3
26549: ARRAY
26550: IN
26551: IFFALSE 26728
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
26553: LD_ADDR_EXP 28
26557: PUSH
26558: LD_EXP 28
26562: PPUSH
26563: LD_VAR 0 3
26567: PPUSH
26568: LD_EXP 28
26572: PUSH
26573: LD_VAR 0 3
26577: ARRAY
26578: PUSH
26579: LD_VAR 0 1
26583: DIFF
26584: PPUSH
26585: CALL_OW 1
26589: ST_TO_ADDR
// if building in mc_lab [ i ] then
26590: LD_VAR 0 1
26594: PUSH
26595: LD_EXP 54
26599: PUSH
26600: LD_VAR 0 3
26604: ARRAY
26605: IN
26606: IFFALSE 26661
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
26608: LD_ADDR_EXP 55
26612: PUSH
26613: LD_EXP 55
26617: PPUSH
26618: LD_VAR 0 3
26622: PPUSH
26623: LD_EXP 55
26627: PUSH
26628: LD_VAR 0 3
26632: ARRAY
26633: PPUSH
26634: LD_INT 1
26636: PPUSH
26637: LD_EXP 55
26641: PUSH
26642: LD_VAR 0 3
26646: ARRAY
26647: PPUSH
26648: LD_INT 0
26650: PPUSH
26651: CALL 34191 0 4
26655: PPUSH
26656: CALL_OW 1
26660: ST_TO_ADDR
// if not building in mc_bases [ i ] then
26661: LD_VAR 0 1
26665: PUSH
26666: LD_EXP 21
26670: PUSH
26671: LD_VAR 0 3
26675: ARRAY
26676: IN
26677: NOT
26678: IFFALSE 26724
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
26680: LD_ADDR_EXP 21
26684: PUSH
26685: LD_EXP 21
26689: PPUSH
26690: LD_VAR 0 3
26694: PUSH
26695: LD_EXP 21
26699: PUSH
26700: LD_VAR 0 3
26704: ARRAY
26705: PUSH
26706: LD_INT 1
26708: PLUS
26709: PUSH
26710: EMPTY
26711: LIST
26712: LIST
26713: PPUSH
26714: LD_VAR 0 1
26718: PPUSH
26719: CALL 35208 0 3
26723: ST_TO_ADDR
// exit ;
26724: POP
26725: POP
26726: GO 26732
// end ; end ;
26728: GO 26532
26730: POP
26731: POP
// end ;
26732: LD_VAR 0 2
26736: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
26737: LD_INT 0
26739: PPUSH
26740: PPUSH
26741: PPUSH
26742: PPUSH
26743: PPUSH
26744: PPUSH
26745: PPUSH
// if not mc_bases then
26746: LD_EXP 21
26750: NOT
26751: IFFALSE 26755
// exit ;
26753: GO 27416
// for i = 1 to mc_bases do
26755: LD_ADDR_VAR 0 3
26759: PUSH
26760: DOUBLE
26761: LD_INT 1
26763: DEC
26764: ST_TO_ADDR
26765: LD_EXP 21
26769: PUSH
26770: FOR_TO
26771: IFFALSE 27414
// begin if building in mc_construct_list [ i ] then
26773: LD_VAR 0 1
26777: PUSH
26778: LD_EXP 28
26782: PUSH
26783: LD_VAR 0 3
26787: ARRAY
26788: IN
26789: IFFALSE 27412
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
26791: LD_ADDR_EXP 28
26795: PUSH
26796: LD_EXP 28
26800: PPUSH
26801: LD_VAR 0 3
26805: PPUSH
26806: LD_EXP 28
26810: PUSH
26811: LD_VAR 0 3
26815: ARRAY
26816: PUSH
26817: LD_VAR 0 1
26821: DIFF
26822: PPUSH
26823: CALL_OW 1
26827: ST_TO_ADDR
// mc_bases := Add ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
26828: LD_ADDR_EXP 21
26832: PUSH
26833: LD_EXP 21
26837: PPUSH
26838: LD_VAR 0 3
26842: PUSH
26843: LD_EXP 21
26847: PUSH
26848: LD_VAR 0 3
26852: ARRAY
26853: PUSH
26854: LD_INT 1
26856: PLUS
26857: PUSH
26858: EMPTY
26859: LIST
26860: LIST
26861: PPUSH
26862: LD_VAR 0 1
26866: PPUSH
26867: CALL 35208 0 3
26871: ST_TO_ADDR
// btype := GetBType ( building ) ;
26872: LD_ADDR_VAR 0 5
26876: PUSH
26877: LD_VAR 0 1
26881: PPUSH
26882: CALL_OW 266
26886: ST_TO_ADDR
// side := GetSide ( building ) ;
26887: LD_ADDR_VAR 0 8
26891: PUSH
26892: LD_VAR 0 1
26896: PPUSH
26897: CALL_OW 255
26901: ST_TO_ADDR
// if btype = b_lab then
26902: LD_VAR 0 5
26906: PUSH
26907: LD_INT 6
26909: EQUAL
26910: IFFALSE 26960
// begin mc_lab := Add ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
26912: LD_ADDR_EXP 54
26916: PUSH
26917: LD_EXP 54
26921: PPUSH
26922: LD_VAR 0 3
26926: PUSH
26927: LD_EXP 54
26931: PUSH
26932: LD_VAR 0 3
26936: ARRAY
26937: PUSH
26938: LD_INT 1
26940: PLUS
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PPUSH
26946: LD_VAR 0 1
26950: PPUSH
26951: CALL 35208 0 3
26955: ST_TO_ADDR
// exit ;
26956: POP
26957: POP
26958: GO 27416
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
26960: LD_VAR 0 5
26964: PUSH
26965: LD_INT 0
26967: PUSH
26968: LD_INT 2
26970: PUSH
26971: LD_INT 4
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: LIST
26978: IN
26979: IFFALSE 27103
// begin if btype = b_armoury then
26981: LD_VAR 0 5
26985: PUSH
26986: LD_INT 4
26988: EQUAL
26989: IFFALSE 26999
// btype := b_barracks ;
26991: LD_ADDR_VAR 0 5
26995: PUSH
26996: LD_INT 5
26998: ST_TO_ADDR
// if btype = b_depot then
26999: LD_VAR 0 5
27003: PUSH
27004: LD_INT 0
27006: EQUAL
27007: IFFALSE 27017
// btype := b_warehouse ;
27009: LD_ADDR_VAR 0 5
27013: PUSH
27014: LD_INT 1
27016: ST_TO_ADDR
// if btype = b_workshop then
27017: LD_VAR 0 5
27021: PUSH
27022: LD_INT 2
27024: EQUAL
27025: IFFALSE 27035
// btype := b_factory ;
27027: LD_ADDR_VAR 0 5
27031: PUSH
27032: LD_INT 3
27034: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
27035: LD_VAR 0 5
27039: PPUSH
27040: LD_VAR 0 8
27044: PPUSH
27045: CALL_OW 323
27049: PUSH
27050: LD_INT 1
27052: EQUAL
27053: IFFALSE 27099
// mc_build_upgrade := Add ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
27055: LD_ADDR_EXP 53
27059: PUSH
27060: LD_EXP 53
27064: PPUSH
27065: LD_VAR 0 3
27069: PUSH
27070: LD_EXP 53
27074: PUSH
27075: LD_VAR 0 3
27079: ARRAY
27080: PUSH
27081: LD_INT 1
27083: PLUS
27084: PUSH
27085: EMPTY
27086: LIST
27087: LIST
27088: PPUSH
27089: LD_VAR 0 1
27093: PPUSH
27094: CALL 35208 0 3
27098: ST_TO_ADDR
// exit ;
27099: POP
27100: POP
27101: GO 27416
// end ; if btype in [ b_bunker , b_turret ] then
27103: LD_VAR 0 5
27107: PUSH
27108: LD_INT 32
27110: PUSH
27111: LD_INT 33
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: IN
27118: IFFALSE 27408
// begin mc_turret_list := Add ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
27120: LD_ADDR_EXP 29
27124: PUSH
27125: LD_EXP 29
27129: PPUSH
27130: LD_VAR 0 3
27134: PUSH
27135: LD_EXP 29
27139: PUSH
27140: LD_VAR 0 3
27144: ARRAY
27145: PUSH
27146: LD_INT 1
27148: PLUS
27149: PUSH
27150: EMPTY
27151: LIST
27152: LIST
27153: PPUSH
27154: LD_VAR 0 1
27158: PPUSH
27159: CALL 35208 0 3
27163: ST_TO_ADDR
// if btype = b_bunker then
27164: LD_VAR 0 5
27168: PUSH
27169: LD_INT 32
27171: EQUAL
27172: IFFALSE 27408
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
27174: LD_ADDR_EXP 30
27178: PUSH
27179: LD_EXP 30
27183: PPUSH
27184: LD_VAR 0 3
27188: PUSH
27189: LD_EXP 30
27193: PUSH
27194: LD_VAR 0 3
27198: ARRAY
27199: PUSH
27200: LD_INT 1
27202: PLUS
27203: PUSH
27204: EMPTY
27205: LIST
27206: LIST
27207: PPUSH
27208: LD_VAR 0 1
27212: PPUSH
27213: CALL 35208 0 3
27217: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
27218: LD_ADDR_VAR 0 6
27222: PUSH
27223: LD_EXP 21
27227: PUSH
27228: LD_VAR 0 3
27232: ARRAY
27233: PPUSH
27234: LD_INT 25
27236: PUSH
27237: LD_INT 1
27239: PUSH
27240: EMPTY
27241: LIST
27242: LIST
27243: PUSH
27244: LD_INT 3
27246: PUSH
27247: LD_INT 54
27249: PUSH
27250: EMPTY
27251: LIST
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PPUSH
27261: CALL_OW 72
27265: ST_TO_ADDR
// if tmp then
27266: LD_VAR 0 6
27270: IFFALSE 27276
// exit ;
27272: POP
27273: POP
27274: GO 27416
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
27276: LD_ADDR_VAR 0 6
27280: PUSH
27281: LD_EXP 21
27285: PUSH
27286: LD_VAR 0 3
27290: ARRAY
27291: PPUSH
27292: LD_INT 2
27294: PUSH
27295: LD_INT 30
27297: PUSH
27298: LD_INT 4
27300: PUSH
27301: EMPTY
27302: LIST
27303: LIST
27304: PUSH
27305: LD_INT 30
27307: PUSH
27308: LD_INT 5
27310: PUSH
27311: EMPTY
27312: LIST
27313: LIST
27314: PUSH
27315: EMPTY
27316: LIST
27317: LIST
27318: LIST
27319: PPUSH
27320: CALL_OW 72
27324: ST_TO_ADDR
// if not tmp then
27325: LD_VAR 0 6
27329: NOT
27330: IFFALSE 27336
// exit ;
27332: POP
27333: POP
27334: GO 27416
// for j in tmp do
27336: LD_ADDR_VAR 0 4
27340: PUSH
27341: LD_VAR 0 6
27345: PUSH
27346: FOR_IN
27347: IFFALSE 27406
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
27349: LD_ADDR_VAR 0 7
27353: PUSH
27354: LD_VAR 0 4
27358: PPUSH
27359: CALL_OW 313
27363: PPUSH
27364: LD_INT 25
27366: PUSH
27367: LD_INT 1
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PPUSH
27374: CALL_OW 72
27378: ST_TO_ADDR
// if units then
27379: LD_VAR 0 7
27383: IFFALSE 27404
// begin ComExitBuilding ( units [ 1 ] ) ;
27385: LD_VAR 0 7
27389: PUSH
27390: LD_INT 1
27392: ARRAY
27393: PPUSH
27394: CALL_OW 122
// exit ;
27398: POP
27399: POP
27400: POP
27401: POP
27402: GO 27416
// end ; end ;
27404: GO 27346
27406: POP
27407: POP
// end ; end ; exit ;
27408: POP
27409: POP
27410: GO 27416
// end ; end ;
27412: GO 26770
27414: POP
27415: POP
// end ;
27416: LD_VAR 0 2
27420: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
27421: LD_INT 0
27423: PPUSH
27424: PPUSH
27425: PPUSH
27426: PPUSH
27427: PPUSH
27428: PPUSH
27429: PPUSH
// if not mc_bases then
27430: LD_EXP 21
27434: NOT
27435: IFFALSE 27439
// exit ;
27437: GO 27670
// btype := GetBType ( building ) ;
27439: LD_ADDR_VAR 0 6
27443: PUSH
27444: LD_VAR 0 1
27448: PPUSH
27449: CALL_OW 266
27453: ST_TO_ADDR
// x := GetX ( building ) ;
27454: LD_ADDR_VAR 0 7
27458: PUSH
27459: LD_VAR 0 1
27463: PPUSH
27464: CALL_OW 250
27468: ST_TO_ADDR
// y := GetY ( building ) ;
27469: LD_ADDR_VAR 0 8
27473: PUSH
27474: LD_VAR 0 1
27478: PPUSH
27479: CALL_OW 251
27483: ST_TO_ADDR
// d := GetDir ( building ) ;
27484: LD_ADDR_VAR 0 9
27488: PUSH
27489: LD_VAR 0 1
27493: PPUSH
27494: CALL_OW 254
27498: ST_TO_ADDR
// for i = 1 to mc_bases do
27499: LD_ADDR_VAR 0 4
27503: PUSH
27504: DOUBLE
27505: LD_INT 1
27507: DEC
27508: ST_TO_ADDR
27509: LD_EXP 21
27513: PUSH
27514: FOR_TO
27515: IFFALSE 27668
// begin if not mc_build_list [ i ] then
27517: LD_EXP 26
27521: PUSH
27522: LD_VAR 0 4
27526: ARRAY
27527: NOT
27528: IFFALSE 27532
// continue ;
27530: GO 27514
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
27532: LD_VAR 0 6
27536: PUSH
27537: LD_VAR 0 7
27541: PUSH
27542: LD_VAR 0 8
27546: PUSH
27547: LD_VAR 0 9
27551: PUSH
27552: EMPTY
27553: LIST
27554: LIST
27555: LIST
27556: LIST
27557: PPUSH
27558: LD_EXP 26
27562: PUSH
27563: LD_VAR 0 4
27567: ARRAY
27568: PUSH
27569: LD_INT 1
27571: ARRAY
27572: PPUSH
27573: CALL 40873 0 2
27577: IFFALSE 27666
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
27579: LD_ADDR_EXP 26
27583: PUSH
27584: LD_EXP 26
27588: PPUSH
27589: LD_VAR 0 4
27593: PPUSH
27594: LD_EXP 26
27598: PUSH
27599: LD_VAR 0 4
27603: ARRAY
27604: PPUSH
27605: LD_INT 1
27607: PPUSH
27608: CALL_OW 3
27612: PPUSH
27613: CALL_OW 1
27617: ST_TO_ADDR
// mc_construct_list := Add ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
27618: LD_ADDR_EXP 28
27622: PUSH
27623: LD_EXP 28
27627: PPUSH
27628: LD_VAR 0 4
27632: PUSH
27633: LD_EXP 28
27637: PUSH
27638: LD_VAR 0 4
27642: ARRAY
27643: PUSH
27644: LD_INT 1
27646: PLUS
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PPUSH
27652: LD_VAR 0 1
27656: PPUSH
27657: CALL 35208 0 3
27661: ST_TO_ADDR
// exit ;
27662: POP
27663: POP
27664: GO 27670
// end ; end ;
27666: GO 27514
27668: POP
27669: POP
// end ;
27670: LD_VAR 0 3
27674: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
27675: LD_INT 0
27677: PPUSH
27678: PPUSH
27679: PPUSH
// if not mc_bases then
27680: LD_EXP 21
27684: NOT
27685: IFFALSE 27689
// exit ;
27687: GO 27879
// for i = 1 to mc_bases do
27689: LD_ADDR_VAR 0 4
27693: PUSH
27694: DOUBLE
27695: LD_INT 1
27697: DEC
27698: ST_TO_ADDR
27699: LD_EXP 21
27703: PUSH
27704: FOR_TO
27705: IFFALSE 27792
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
27707: LD_VAR 0 1
27711: PUSH
27712: LD_EXP 29
27716: PUSH
27717: LD_VAR 0 4
27721: ARRAY
27722: IN
27723: PUSH
27724: LD_VAR 0 1
27728: PUSH
27729: LD_EXP 30
27733: PUSH
27734: LD_VAR 0 4
27738: ARRAY
27739: IN
27740: NOT
27741: AND
27742: IFFALSE 27790
// begin mc_empty_turret_list := Add ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
27744: LD_ADDR_EXP 30
27748: PUSH
27749: LD_EXP 30
27753: PPUSH
27754: LD_VAR 0 4
27758: PUSH
27759: LD_EXP 30
27763: PUSH
27764: LD_VAR 0 4
27768: ARRAY
27769: PUSH
27770: LD_INT 1
27772: PLUS
27773: PUSH
27774: EMPTY
27775: LIST
27776: LIST
27777: PPUSH
27778: LD_VAR 0 1
27782: PPUSH
27783: CALL 35208 0 3
27787: ST_TO_ADDR
// break ;
27788: GO 27792
// end ; end ;
27790: GO 27704
27792: POP
27793: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
27794: LD_VAR 0 1
27798: PPUSH
27799: CALL_OW 257
27803: PUSH
27804: LD_EXP 47
27808: IN
27809: PUSH
27810: LD_VAR 0 1
27814: PPUSH
27815: CALL_OW 266
27819: PUSH
27820: LD_INT 5
27822: EQUAL
27823: AND
27824: PUSH
27825: LD_VAR 0 2
27829: PPUSH
27830: CALL_OW 110
27834: PUSH
27835: LD_INT 18
27837: NONEQUAL
27838: AND
27839: IFFALSE 27879
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
27841: LD_VAR 0 2
27845: PPUSH
27846: CALL_OW 257
27850: PUSH
27851: LD_INT 5
27853: PUSH
27854: LD_INT 8
27856: PUSH
27857: LD_INT 9
27859: PUSH
27860: EMPTY
27861: LIST
27862: LIST
27863: LIST
27864: IN
27865: IFFALSE 27879
// SetClass ( unit , 1 ) ;
27867: LD_VAR 0 2
27871: PPUSH
27872: LD_INT 1
27874: PPUSH
27875: CALL_OW 336
// end ;
27879: LD_VAR 0 3
27883: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
27884: LD_INT 0
27886: PPUSH
27887: PPUSH
// if not mc_bases then
27888: LD_EXP 21
27892: NOT
27893: IFFALSE 27897
// exit ;
27895: GO 28013
// if GetLives ( abandoned_vehicle ) > 250 then
27897: LD_VAR 0 2
27901: PPUSH
27902: CALL_OW 256
27906: PUSH
27907: LD_INT 250
27909: GREATER
27910: IFFALSE 27914
// exit ;
27912: GO 28013
// for i = 1 to mc_bases do
27914: LD_ADDR_VAR 0 6
27918: PUSH
27919: DOUBLE
27920: LD_INT 1
27922: DEC
27923: ST_TO_ADDR
27924: LD_EXP 21
27928: PUSH
27929: FOR_TO
27930: IFFALSE 28011
// begin if driver in mc_bases [ i ] then
27932: LD_VAR 0 1
27936: PUSH
27937: LD_EXP 21
27941: PUSH
27942: LD_VAR 0 6
27946: ARRAY
27947: IN
27948: IFFALSE 28009
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
27950: LD_VAR 0 1
27954: PPUSH
27955: LD_EXP 21
27959: PUSH
27960: LD_VAR 0 6
27964: ARRAY
27965: PPUSH
27966: LD_INT 2
27968: PUSH
27969: LD_INT 30
27971: PUSH
27972: LD_INT 0
27974: PUSH
27975: EMPTY
27976: LIST
27977: LIST
27978: PUSH
27979: LD_INT 30
27981: PUSH
27982: LD_INT 1
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: EMPTY
27990: LIST
27991: LIST
27992: LIST
27993: PPUSH
27994: CALL_OW 72
27998: PUSH
27999: LD_INT 1
28001: ARRAY
28002: PPUSH
28003: CALL_OW 112
// break ;
28007: GO 28011
// end ; end ;
28009: GO 27929
28011: POP
28012: POP
// end ; end_of_file
28013: LD_VAR 0 5
28017: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
28018: LD_INT 0
28020: PPUSH
28021: PPUSH
// if exist_mode then
28022: LD_VAR 0 2
28026: IFFALSE 28051
// unit := CreateCharacter ( prefix & ident ) else
28028: LD_ADDR_VAR 0 5
28032: PUSH
28033: LD_VAR 0 3
28037: PUSH
28038: LD_VAR 0 1
28042: STR
28043: PPUSH
28044: CALL_OW 34
28048: ST_TO_ADDR
28049: GO 28066
// unit := NewCharacter ( ident ) ;
28051: LD_ADDR_VAR 0 5
28055: PUSH
28056: LD_VAR 0 1
28060: PPUSH
28061: CALL_OW 25
28065: ST_TO_ADDR
// result := unit ;
28066: LD_ADDR_VAR 0 4
28070: PUSH
28071: LD_VAR 0 5
28075: ST_TO_ADDR
// end ;
28076: LD_VAR 0 4
28080: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
28081: LD_INT 0
28083: PPUSH
28084: PPUSH
// if not side or not nation then
28085: LD_VAR 0 1
28089: NOT
28090: PUSH
28091: LD_VAR 0 2
28095: NOT
28096: OR
28097: IFFALSE 28101
// exit ;
28099: GO 28737
// case nation of nation_american :
28101: LD_VAR 0 2
28105: PUSH
28106: LD_INT 1
28108: DOUBLE
28109: EQUAL
28110: IFTRUE 28114
28112: GO 28284
28114: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
28115: LD_ADDR_VAR 0 4
28119: PUSH
28120: LD_INT 35
28122: PUSH
28123: LD_INT 45
28125: PUSH
28126: LD_INT 46
28128: PUSH
28129: LD_INT 47
28131: PUSH
28132: LD_INT 1
28134: PUSH
28135: LD_INT 2
28137: PUSH
28138: LD_INT 6
28140: PUSH
28141: LD_INT 15
28143: PUSH
28144: LD_INT 16
28146: PUSH
28147: LD_INT 7
28149: PUSH
28150: LD_INT 12
28152: PUSH
28153: LD_INT 13
28155: PUSH
28156: LD_INT 10
28158: PUSH
28159: LD_INT 14
28161: PUSH
28162: LD_INT 20
28164: PUSH
28165: LD_INT 21
28167: PUSH
28168: LD_INT 22
28170: PUSH
28171: LD_INT 25
28173: PUSH
28174: LD_INT 32
28176: PUSH
28177: LD_INT 27
28179: PUSH
28180: LD_INT 36
28182: PUSH
28183: LD_INT 69
28185: PUSH
28186: LD_INT 39
28188: PUSH
28189: LD_INT 34
28191: PUSH
28192: LD_INT 40
28194: PUSH
28195: LD_INT 48
28197: PUSH
28198: LD_INT 49
28200: PUSH
28201: LD_INT 50
28203: PUSH
28204: LD_INT 51
28206: PUSH
28207: LD_INT 52
28209: PUSH
28210: LD_INT 53
28212: PUSH
28213: LD_INT 54
28215: PUSH
28216: LD_INT 55
28218: PUSH
28219: LD_INT 56
28221: PUSH
28222: LD_INT 57
28224: PUSH
28225: LD_INT 58
28227: PUSH
28228: LD_INT 59
28230: PUSH
28231: LD_INT 60
28233: PUSH
28234: LD_INT 61
28236: PUSH
28237: LD_INT 62
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: LIST
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: LIST
28255: LIST
28256: LIST
28257: LIST
28258: LIST
28259: LIST
28260: LIST
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: LIST
28266: LIST
28267: LIST
28268: LIST
28269: LIST
28270: LIST
28271: LIST
28272: LIST
28273: LIST
28274: LIST
28275: LIST
28276: LIST
28277: LIST
28278: LIST
28279: LIST
28280: LIST
28281: ST_TO_ADDR
28282: GO 28661
28284: LD_INT 2
28286: DOUBLE
28287: EQUAL
28288: IFTRUE 28292
28290: GO 28470
28292: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
28293: LD_ADDR_VAR 0 4
28297: PUSH
28298: LD_INT 35
28300: PUSH
28301: LD_INT 45
28303: PUSH
28304: LD_INT 46
28306: PUSH
28307: LD_INT 47
28309: PUSH
28310: LD_INT 70
28312: PUSH
28313: LD_INT 1
28315: PUSH
28316: LD_INT 11
28318: PUSH
28319: LD_INT 3
28321: PUSH
28322: LD_INT 4
28324: PUSH
28325: LD_INT 5
28327: PUSH
28328: LD_INT 6
28330: PUSH
28331: LD_INT 15
28333: PUSH
28334: LD_INT 18
28336: PUSH
28337: LD_INT 7
28339: PUSH
28340: LD_INT 17
28342: PUSH
28343: LD_INT 8
28345: PUSH
28346: LD_INT 20
28348: PUSH
28349: LD_INT 21
28351: PUSH
28352: LD_INT 22
28354: PUSH
28355: LD_INT 72
28357: PUSH
28358: LD_INT 26
28360: PUSH
28361: LD_INT 69
28363: PUSH
28364: LD_INT 39
28366: PUSH
28367: LD_INT 40
28369: PUSH
28370: LD_INT 41
28372: PUSH
28373: LD_INT 42
28375: PUSH
28376: LD_INT 43
28378: PUSH
28379: LD_INT 48
28381: PUSH
28382: LD_INT 49
28384: PUSH
28385: LD_INT 50
28387: PUSH
28388: LD_INT 51
28390: PUSH
28391: LD_INT 52
28393: PUSH
28394: LD_INT 53
28396: PUSH
28397: LD_INT 54
28399: PUSH
28400: LD_INT 55
28402: PUSH
28403: LD_INT 56
28405: PUSH
28406: LD_INT 60
28408: PUSH
28409: LD_INT 61
28411: PUSH
28412: LD_INT 62
28414: PUSH
28415: LD_INT 66
28417: PUSH
28418: LD_INT 67
28420: PUSH
28421: LD_INT 68
28423: PUSH
28424: EMPTY
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: LIST
28436: LIST
28437: LIST
28438: LIST
28439: LIST
28440: LIST
28441: LIST
28442: LIST
28443: LIST
28444: LIST
28445: LIST
28446: LIST
28447: LIST
28448: LIST
28449: LIST
28450: LIST
28451: LIST
28452: LIST
28453: LIST
28454: LIST
28455: LIST
28456: LIST
28457: LIST
28458: LIST
28459: LIST
28460: LIST
28461: LIST
28462: LIST
28463: LIST
28464: LIST
28465: LIST
28466: LIST
28467: ST_TO_ADDR
28468: GO 28661
28470: LD_INT 3
28472: DOUBLE
28473: EQUAL
28474: IFTRUE 28478
28476: GO 28660
28478: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
28479: LD_ADDR_VAR 0 4
28483: PUSH
28484: LD_INT 46
28486: PUSH
28487: LD_INT 47
28489: PUSH
28490: LD_INT 1
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 11
28498: PUSH
28499: LD_INT 9
28501: PUSH
28502: LD_INT 20
28504: PUSH
28505: LD_INT 19
28507: PUSH
28508: LD_INT 21
28510: PUSH
28511: LD_INT 24
28513: PUSH
28514: LD_INT 22
28516: PUSH
28517: LD_INT 25
28519: PUSH
28520: LD_INT 28
28522: PUSH
28523: LD_INT 29
28525: PUSH
28526: LD_INT 30
28528: PUSH
28529: LD_INT 31
28531: PUSH
28532: LD_INT 37
28534: PUSH
28535: LD_INT 38
28537: PUSH
28538: LD_INT 32
28540: PUSH
28541: LD_INT 27
28543: PUSH
28544: LD_INT 33
28546: PUSH
28547: LD_INT 69
28549: PUSH
28550: LD_INT 39
28552: PUSH
28553: LD_INT 34
28555: PUSH
28556: LD_INT 40
28558: PUSH
28559: LD_INT 71
28561: PUSH
28562: LD_INT 23
28564: PUSH
28565: LD_INT 44
28567: PUSH
28568: LD_INT 48
28570: PUSH
28571: LD_INT 49
28573: PUSH
28574: LD_INT 50
28576: PUSH
28577: LD_INT 51
28579: PUSH
28580: LD_INT 52
28582: PUSH
28583: LD_INT 53
28585: PUSH
28586: LD_INT 54
28588: PUSH
28589: LD_INT 55
28591: PUSH
28592: LD_INT 56
28594: PUSH
28595: LD_INT 57
28597: PUSH
28598: LD_INT 58
28600: PUSH
28601: LD_INT 59
28603: PUSH
28604: LD_INT 63
28606: PUSH
28607: LD_INT 64
28609: PUSH
28610: LD_INT 65
28612: PUSH
28613: EMPTY
28614: LIST
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: LIST
28632: LIST
28633: LIST
28634: LIST
28635: LIST
28636: LIST
28637: LIST
28638: LIST
28639: LIST
28640: LIST
28641: LIST
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: LIST
28649: LIST
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: ST_TO_ADDR
28658: GO 28661
28660: POP
// if state > - 1 and state < 3 then
28661: LD_VAR 0 3
28665: PUSH
28666: LD_INT 1
28668: NEG
28669: GREATER
28670: PUSH
28671: LD_VAR 0 3
28675: PUSH
28676: LD_INT 3
28678: LESS
28679: AND
28680: IFFALSE 28737
// for i in result do
28682: LD_ADDR_VAR 0 5
28686: PUSH
28687: LD_VAR 0 4
28691: PUSH
28692: FOR_IN
28693: IFFALSE 28735
// if GetTech ( i , side ) <> state then
28695: LD_VAR 0 5
28699: PPUSH
28700: LD_VAR 0 1
28704: PPUSH
28705: CALL_OW 321
28709: PUSH
28710: LD_VAR 0 3
28714: NONEQUAL
28715: IFFALSE 28733
// result := result diff i ;
28717: LD_ADDR_VAR 0 4
28721: PUSH
28722: LD_VAR 0 4
28726: PUSH
28727: LD_VAR 0 5
28731: DIFF
28732: ST_TO_ADDR
28733: GO 28692
28735: POP
28736: POP
// end ;
28737: LD_VAR 0 4
28741: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
28742: LD_INT 0
28744: PPUSH
28745: PPUSH
28746: PPUSH
// result := true ;
28747: LD_ADDR_VAR 0 3
28751: PUSH
28752: LD_INT 1
28754: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
28755: LD_ADDR_VAR 0 5
28759: PUSH
28760: LD_VAR 0 2
28764: PPUSH
28765: CALL_OW 480
28769: ST_TO_ADDR
// if not tmp then
28770: LD_VAR 0 5
28774: NOT
28775: IFFALSE 28779
// exit ;
28777: GO 28828
// for i in tmp do
28779: LD_ADDR_VAR 0 4
28783: PUSH
28784: LD_VAR 0 5
28788: PUSH
28789: FOR_IN
28790: IFFALSE 28826
// if GetTech ( i , side ) <> state_researched then
28792: LD_VAR 0 4
28796: PPUSH
28797: LD_VAR 0 1
28801: PPUSH
28802: CALL_OW 321
28806: PUSH
28807: LD_INT 2
28809: NONEQUAL
28810: IFFALSE 28824
// begin result := false ;
28812: LD_ADDR_VAR 0 3
28816: PUSH
28817: LD_INT 0
28819: ST_TO_ADDR
// exit ;
28820: POP
28821: POP
28822: GO 28828
// end ;
28824: GO 28789
28826: POP
28827: POP
// end ;
28828: LD_VAR 0 3
28832: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
28833: LD_INT 0
28835: PPUSH
28836: PPUSH
28837: PPUSH
28838: PPUSH
28839: PPUSH
28840: PPUSH
28841: PPUSH
28842: PPUSH
28843: PPUSH
28844: PPUSH
28845: PPUSH
28846: PPUSH
28847: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
28848: LD_VAR 0 1
28852: NOT
28853: PUSH
28854: LD_VAR 0 1
28858: PPUSH
28859: CALL_OW 257
28863: PUSH
28864: LD_INT 9
28866: NONEQUAL
28867: OR
28868: IFFALSE 28872
// exit ;
28870: GO 29445
// side := GetSide ( unit ) ;
28872: LD_ADDR_VAR 0 9
28876: PUSH
28877: LD_VAR 0 1
28881: PPUSH
28882: CALL_OW 255
28886: ST_TO_ADDR
// tech_space := tech_spacanom ;
28887: LD_ADDR_VAR 0 12
28891: PUSH
28892: LD_INT 29
28894: ST_TO_ADDR
// tech_time := tech_taurad ;
28895: LD_ADDR_VAR 0 13
28899: PUSH
28900: LD_INT 28
28902: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
28903: LD_ADDR_VAR 0 11
28907: PUSH
28908: LD_VAR 0 1
28912: PPUSH
28913: CALL_OW 310
28917: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
28918: LD_VAR 0 11
28922: PPUSH
28923: CALL_OW 247
28927: PUSH
28928: LD_INT 2
28930: EQUAL
28931: IFFALSE 28935
// exit ;
28933: GO 29445
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
28935: LD_ADDR_VAR 0 8
28939: PUSH
28940: LD_INT 81
28942: PUSH
28943: LD_VAR 0 9
28947: PUSH
28948: EMPTY
28949: LIST
28950: LIST
28951: PUSH
28952: LD_INT 3
28954: PUSH
28955: LD_INT 21
28957: PUSH
28958: LD_INT 3
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: EMPTY
28970: LIST
28971: LIST
28972: PPUSH
28973: CALL_OW 69
28977: ST_TO_ADDR
// if not tmp then
28978: LD_VAR 0 8
28982: NOT
28983: IFFALSE 28987
// exit ;
28985: GO 29445
// if in_unit then
28987: LD_VAR 0 11
28991: IFFALSE 29015
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
28993: LD_ADDR_VAR 0 10
28997: PUSH
28998: LD_VAR 0 8
29002: PPUSH
29003: LD_VAR 0 11
29007: PPUSH
29008: CALL_OW 74
29012: ST_TO_ADDR
29013: GO 29035
// enemy := NearestUnitToUnit ( tmp , unit ) ;
29015: LD_ADDR_VAR 0 10
29019: PUSH
29020: LD_VAR 0 8
29024: PPUSH
29025: LD_VAR 0 1
29029: PPUSH
29030: CALL_OW 74
29034: ST_TO_ADDR
// if not enemy then
29035: LD_VAR 0 10
29039: NOT
29040: IFFALSE 29044
// exit ;
29042: GO 29445
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
29044: LD_VAR 0 11
29048: PUSH
29049: LD_VAR 0 11
29053: PPUSH
29054: LD_VAR 0 10
29058: PPUSH
29059: CALL_OW 296
29063: PUSH
29064: LD_INT 13
29066: GREATER
29067: AND
29068: PUSH
29069: LD_VAR 0 1
29073: PPUSH
29074: LD_VAR 0 10
29078: PPUSH
29079: CALL_OW 296
29083: PUSH
29084: LD_INT 12
29086: GREATER
29087: OR
29088: IFFALSE 29092
// exit ;
29090: GO 29445
// missile := [ 1 ] ;
29092: LD_ADDR_VAR 0 14
29096: PUSH
29097: LD_INT 1
29099: PUSH
29100: EMPTY
29101: LIST
29102: ST_TO_ADDR
// if Researched ( side , tech_space ) then
29103: LD_VAR 0 9
29107: PPUSH
29108: LD_VAR 0 12
29112: PPUSH
29113: CALL_OW 325
29117: IFFALSE 29146
// missile := Insert ( missile , missile + 1 , 2 ) ;
29119: LD_ADDR_VAR 0 14
29123: PUSH
29124: LD_VAR 0 14
29128: PPUSH
29129: LD_VAR 0 14
29133: PUSH
29134: LD_INT 1
29136: PLUS
29137: PPUSH
29138: LD_INT 2
29140: PPUSH
29141: CALL_OW 2
29145: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
29146: LD_VAR 0 9
29150: PPUSH
29151: LD_VAR 0 13
29155: PPUSH
29156: CALL_OW 325
29160: PUSH
29161: LD_VAR 0 10
29165: PPUSH
29166: CALL_OW 255
29170: PPUSH
29171: LD_VAR 0 13
29175: PPUSH
29176: CALL_OW 325
29180: NOT
29181: AND
29182: IFFALSE 29211
// missile := Insert ( missile , missile + 1 , 3 ) ;
29184: LD_ADDR_VAR 0 14
29188: PUSH
29189: LD_VAR 0 14
29193: PPUSH
29194: LD_VAR 0 14
29198: PUSH
29199: LD_INT 1
29201: PLUS
29202: PPUSH
29203: LD_INT 3
29205: PPUSH
29206: CALL_OW 2
29210: ST_TO_ADDR
// if missile < 2 then
29211: LD_VAR 0 14
29215: PUSH
29216: LD_INT 2
29218: LESS
29219: IFFALSE 29223
// exit ;
29221: GO 29445
// x := GetX ( enemy ) ;
29223: LD_ADDR_VAR 0 4
29227: PUSH
29228: LD_VAR 0 10
29232: PPUSH
29233: CALL_OW 250
29237: ST_TO_ADDR
// y := GetY ( enemy ) ;
29238: LD_ADDR_VAR 0 5
29242: PUSH
29243: LD_VAR 0 10
29247: PPUSH
29248: CALL_OW 251
29252: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
29253: LD_ADDR_VAR 0 6
29257: PUSH
29258: LD_VAR 0 4
29262: PUSH
29263: LD_INT 1
29265: NEG
29266: PPUSH
29267: LD_INT 1
29269: PPUSH
29270: CALL_OW 12
29274: PLUS
29275: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
29276: LD_ADDR_VAR 0 7
29280: PUSH
29281: LD_VAR 0 5
29285: PUSH
29286: LD_INT 1
29288: NEG
29289: PPUSH
29290: LD_INT 1
29292: PPUSH
29293: CALL_OW 12
29297: PLUS
29298: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
29299: LD_VAR 0 6
29303: PPUSH
29304: LD_VAR 0 7
29308: PPUSH
29309: CALL_OW 488
29313: NOT
29314: IFFALSE 29336
// begin _x := x ;
29316: LD_ADDR_VAR 0 6
29320: PUSH
29321: LD_VAR 0 4
29325: ST_TO_ADDR
// _y := y ;
29326: LD_ADDR_VAR 0 7
29330: PUSH
29331: LD_VAR 0 5
29335: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
29336: LD_ADDR_VAR 0 3
29340: PUSH
29341: LD_INT 1
29343: PPUSH
29344: LD_VAR 0 14
29348: PPUSH
29349: CALL_OW 12
29353: ST_TO_ADDR
// case i of 1 :
29354: LD_VAR 0 3
29358: PUSH
29359: LD_INT 1
29361: DOUBLE
29362: EQUAL
29363: IFTRUE 29367
29365: GO 29384
29367: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
29368: LD_VAR 0 1
29372: PPUSH
29373: LD_VAR 0 10
29377: PPUSH
29378: CALL_OW 115
29382: GO 29445
29384: LD_INT 2
29386: DOUBLE
29387: EQUAL
29388: IFTRUE 29392
29390: GO 29414
29392: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
29393: LD_VAR 0 1
29397: PPUSH
29398: LD_VAR 0 6
29402: PPUSH
29403: LD_VAR 0 7
29407: PPUSH
29408: CALL_OW 153
29412: GO 29445
29414: LD_INT 3
29416: DOUBLE
29417: EQUAL
29418: IFTRUE 29422
29420: GO 29444
29422: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
29423: LD_VAR 0 1
29427: PPUSH
29428: LD_VAR 0 6
29432: PPUSH
29433: LD_VAR 0 7
29437: PPUSH
29438: CALL_OW 154
29442: GO 29445
29444: POP
// end ;
29445: LD_VAR 0 2
29449: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
29450: LD_INT 0
29452: PPUSH
29453: PPUSH
29454: PPUSH
29455: PPUSH
29456: PPUSH
29457: PPUSH
// if not unit or not building then
29458: LD_VAR 0 1
29462: NOT
29463: PUSH
29464: LD_VAR 0 2
29468: NOT
29469: OR
29470: IFFALSE 29474
// exit ;
29472: GO 29632
// x := GetX ( building ) ;
29474: LD_ADDR_VAR 0 5
29478: PUSH
29479: LD_VAR 0 2
29483: PPUSH
29484: CALL_OW 250
29488: ST_TO_ADDR
// y := GetY ( building ) ;
29489: LD_ADDR_VAR 0 6
29493: PUSH
29494: LD_VAR 0 2
29498: PPUSH
29499: CALL_OW 251
29503: ST_TO_ADDR
// for i = 0 to 5 do
29504: LD_ADDR_VAR 0 4
29508: PUSH
29509: DOUBLE
29510: LD_INT 0
29512: DEC
29513: ST_TO_ADDR
29514: LD_INT 5
29516: PUSH
29517: FOR_TO
29518: IFFALSE 29630
// begin _x := ShiftX ( x , i , 3 ) ;
29520: LD_ADDR_VAR 0 7
29524: PUSH
29525: LD_VAR 0 5
29529: PPUSH
29530: LD_VAR 0 4
29534: PPUSH
29535: LD_INT 3
29537: PPUSH
29538: CALL_OW 272
29542: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
29543: LD_ADDR_VAR 0 8
29547: PUSH
29548: LD_VAR 0 6
29552: PPUSH
29553: LD_VAR 0 4
29557: PPUSH
29558: LD_INT 3
29560: PPUSH
29561: CALL_OW 273
29565: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
29566: LD_VAR 0 7
29570: PPUSH
29571: LD_VAR 0 8
29575: PPUSH
29576: CALL_OW 488
29580: NOT
29581: IFFALSE 29585
// continue ;
29583: GO 29517
// if HexInfo ( _x , _y ) = 0 then
29585: LD_VAR 0 7
29589: PPUSH
29590: LD_VAR 0 8
29594: PPUSH
29595: CALL_OW 428
29599: PUSH
29600: LD_INT 0
29602: EQUAL
29603: IFFALSE 29628
// begin ComMoveXY ( unit , _x , _y ) ;
29605: LD_VAR 0 1
29609: PPUSH
29610: LD_VAR 0 7
29614: PPUSH
29615: LD_VAR 0 8
29619: PPUSH
29620: CALL_OW 111
// exit ;
29624: POP
29625: POP
29626: GO 29632
// end ; end ;
29628: GO 29517
29630: POP
29631: POP
// end ;
29632: LD_VAR 0 3
29636: RET
// export function ScanBase ( side , base_area ) ; begin
29637: LD_INT 0
29639: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
29640: LD_ADDR_VAR 0 3
29644: PUSH
29645: LD_VAR 0 2
29649: PPUSH
29650: LD_INT 81
29652: PUSH
29653: LD_VAR 0 1
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PPUSH
29662: CALL_OW 70
29666: ST_TO_ADDR
// end ;
29667: LD_VAR 0 3
29671: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
29672: LD_INT 0
29674: PPUSH
29675: PPUSH
29676: PPUSH
29677: PPUSH
29678: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
29679: LD_VAR 0 1
29683: NOT
29684: PUSH
29685: LD_EXP 21
29689: PUSH
29690: LD_VAR 0 1
29694: ARRAY
29695: NOT
29696: OR
29697: PUSH
29698: LD_VAR 0 2
29702: NOT
29703: OR
29704: PUSH
29705: LD_VAR 0 3
29709: NOT
29710: OR
29711: IFFALSE 29715
// exit ;
29713: GO 30165
// side := mc_sides [ base ] ;
29715: LD_ADDR_VAR 0 6
29719: PUSH
29720: LD_EXP 47
29724: PUSH
29725: LD_VAR 0 1
29729: ARRAY
29730: ST_TO_ADDR
// if not side then
29731: LD_VAR 0 6
29735: NOT
29736: IFFALSE 29740
// exit ;
29738: GO 30165
// for i in solds do
29740: LD_ADDR_VAR 0 7
29744: PUSH
29745: LD_VAR 0 2
29749: PUSH
29750: FOR_IN
29751: IFFALSE 29812
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
29753: LD_VAR 0 7
29757: PPUSH
29758: CALL_OW 310
29762: PPUSH
29763: CALL_OW 266
29767: PUSH
29768: LD_INT 32
29770: PUSH
29771: LD_INT 31
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: IN
29778: IFFALSE 29798
// solds := solds diff i else
29780: LD_ADDR_VAR 0 2
29784: PUSH
29785: LD_VAR 0 2
29789: PUSH
29790: LD_VAR 0 7
29794: DIFF
29795: ST_TO_ADDR
29796: GO 29810
// SetTag ( i , 18 ) ;
29798: LD_VAR 0 7
29802: PPUSH
29803: LD_INT 18
29805: PPUSH
29806: CALL_OW 109
29810: GO 29750
29812: POP
29813: POP
// if not solds then
29814: LD_VAR 0 2
29818: NOT
29819: IFFALSE 29823
// exit ;
29821: GO 30165
// repeat wait ( 0 0$1 ) ;
29823: LD_INT 35
29825: PPUSH
29826: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
29830: LD_ADDR_VAR 0 5
29834: PUSH
29835: LD_VAR 0 6
29839: PPUSH
29840: LD_VAR 0 3
29844: PPUSH
29845: CALL 29637 0 2
29849: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
29850: LD_VAR 0 5
29854: NOT
29855: PUSH
29856: LD_VAR 0 5
29860: PUSH
29861: LD_INT 3
29863: GREATER
29864: OR
29865: PUSH
29866: LD_EXP 43
29870: PUSH
29871: LD_VAR 0 1
29875: ARRAY
29876: OR
29877: IFFALSE 29918
// begin for i in solds do
29879: LD_ADDR_VAR 0 7
29883: PUSH
29884: LD_VAR 0 2
29888: PUSH
29889: FOR_IN
29890: IFFALSE 29914
// if HasTask ( i ) then
29892: LD_VAR 0 7
29896: PPUSH
29897: CALL_OW 314
29901: IFFALSE 29912
// ComStop ( i ) ;
29903: LD_VAR 0 7
29907: PPUSH
29908: CALL_OW 141
29912: GO 29889
29914: POP
29915: POP
// break ;
29916: GO 30153
// end ; for i in solds do
29918: LD_ADDR_VAR 0 7
29922: PUSH
29923: LD_VAR 0 2
29927: PUSH
29928: FOR_IN
29929: IFFALSE 30145
// begin if IsInUnit ( i ) then
29931: LD_VAR 0 7
29935: PPUSH
29936: CALL_OW 310
29940: IFFALSE 29951
// ComExitBuilding ( i ) ;
29942: LD_VAR 0 7
29946: PPUSH
29947: CALL_OW 122
// if GetLives ( i ) > 333 then
29951: LD_VAR 0 7
29955: PPUSH
29956: CALL_OW 256
29960: PUSH
29961: LD_INT 333
29963: GREATER
29964: IFFALSE 29992
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
29966: LD_VAR 0 7
29970: PPUSH
29971: LD_VAR 0 5
29975: PPUSH
29976: LD_VAR 0 7
29980: PPUSH
29981: CALL_OW 74
29985: PPUSH
29986: CALL_OW 115
29990: GO 30143
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
29992: LD_ADDR_VAR 0 8
29996: PUSH
29997: LD_EXP 21
30001: PUSH
30002: LD_VAR 0 1
30006: ARRAY
30007: PPUSH
30008: LD_INT 2
30010: PUSH
30011: LD_INT 30
30013: PUSH
30014: LD_INT 0
30016: PUSH
30017: EMPTY
30018: LIST
30019: LIST
30020: PUSH
30021: LD_INT 30
30023: PUSH
30024: LD_INT 1
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 30
30033: PUSH
30034: LD_INT 6
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: PPUSH
30047: CALL_OW 72
30051: PPUSH
30052: LD_VAR 0 7
30056: PPUSH
30057: CALL_OW 74
30061: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
30062: LD_VAR 0 7
30066: PPUSH
30067: LD_VAR 0 8
30071: PPUSH
30072: CALL_OW 250
30076: PPUSH
30077: LD_INT 3
30079: PPUSH
30080: LD_INT 5
30082: PPUSH
30083: CALL_OW 272
30087: PPUSH
30088: LD_VAR 0 8
30092: PPUSH
30093: CALL_OW 251
30097: PPUSH
30098: LD_INT 3
30100: PPUSH
30101: LD_INT 5
30103: PPUSH
30104: CALL_OW 273
30108: PPUSH
30109: CALL_OW 111
// SetTag ( i , 0 ) ;
30113: LD_VAR 0 7
30117: PPUSH
30118: LD_INT 0
30120: PPUSH
30121: CALL_OW 109
// solds := solds diff i ;
30125: LD_ADDR_VAR 0 2
30129: PUSH
30130: LD_VAR 0 2
30134: PUSH
30135: LD_VAR 0 7
30139: DIFF
30140: ST_TO_ADDR
// continue ;
30141: GO 29928
// end ; end ;
30143: GO 29928
30145: POP
30146: POP
// until solds ;
30147: LD_VAR 0 2
30151: IFFALSE 29823
// MC_Reset ( base , 18 ) ;
30153: LD_VAR 0 1
30157: PPUSH
30158: LD_INT 18
30160: PPUSH
30161: CALL 3581 0 2
// end ;
30165: LD_VAR 0 4
30169: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
30170: LD_INT 0
30172: PPUSH
30173: PPUSH
30174: PPUSH
30175: PPUSH
30176: PPUSH
30177: PPUSH
30178: PPUSH
30179: PPUSH
30180: PPUSH
30181: PPUSH
30182: PPUSH
30183: PPUSH
30184: PPUSH
30185: PPUSH
30186: PPUSH
30187: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
30188: LD_ADDR_VAR 0 12
30192: PUSH
30193: LD_EXP 21
30197: PUSH
30198: LD_VAR 0 1
30202: ARRAY
30203: PPUSH
30204: LD_INT 25
30206: PUSH
30207: LD_INT 3
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PPUSH
30214: CALL_OW 72
30218: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
30219: LD_ADDR_VAR 0 8
30223: PUSH
30224: LD_EXP 21
30228: PUSH
30229: LD_VAR 0 1
30233: ARRAY
30234: PPUSH
30235: LD_INT 2
30237: PUSH
30238: LD_INT 25
30240: PUSH
30241: LD_INT 1
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: PUSH
30248: LD_INT 25
30250: PUSH
30251: LD_INT 5
30253: PUSH
30254: EMPTY
30255: LIST
30256: LIST
30257: PUSH
30258: LD_INT 25
30260: PUSH
30261: LD_INT 8
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 25
30270: PUSH
30271: LD_INT 9
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: EMPTY
30279: LIST
30280: LIST
30281: LIST
30282: LIST
30283: LIST
30284: PPUSH
30285: CALL_OW 72
30289: ST_TO_ADDR
// if not defenders and not solds then
30290: LD_VAR 0 2
30294: NOT
30295: PUSH
30296: LD_VAR 0 8
30300: NOT
30301: AND
30302: IFFALSE 30306
// exit ;
30304: GO 31672
// depot_under_attack := false ;
30306: LD_ADDR_VAR 0 16
30310: PUSH
30311: LD_INT 0
30313: ST_TO_ADDR
// sold_defenders := [ ] ;
30314: LD_ADDR_VAR 0 17
30318: PUSH
30319: EMPTY
30320: ST_TO_ADDR
// if mechs then
30321: LD_VAR 0 12
30325: IFFALSE 30454
// for i in defenders do
30327: LD_ADDR_VAR 0 5
30331: PUSH
30332: LD_VAR 0 2
30336: PUSH
30337: FOR_IN
30338: IFFALSE 30452
// begin SetTag ( i , 20 ) ;
30340: LD_VAR 0 5
30344: PPUSH
30345: LD_INT 20
30347: PPUSH
30348: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
30352: LD_VAR 0 5
30356: PPUSH
30357: CALL_OW 263
30361: PUSH
30362: LD_INT 1
30364: EQUAL
30365: PUSH
30366: LD_VAR 0 5
30370: PPUSH
30371: CALL_OW 311
30375: NOT
30376: AND
30377: PUSH
30378: LD_VAR 0 12
30382: AND
30383: IFFALSE 30450
// begin un := mechs [ 1 ] ;
30385: LD_ADDR_VAR 0 10
30389: PUSH
30390: LD_VAR 0 12
30394: PUSH
30395: LD_INT 1
30397: ARRAY
30398: ST_TO_ADDR
// ComExitBuilding ( un ) ;
30399: LD_VAR 0 10
30403: PPUSH
30404: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
30408: LD_VAR 0 10
30412: PPUSH
30413: LD_VAR 0 5
30417: PPUSH
30418: CALL_OW 180
// SetTag ( un , 19 ) ;
30422: LD_VAR 0 10
30426: PPUSH
30427: LD_INT 19
30429: PPUSH
30430: CALL_OW 109
// mechs := mechs diff un ;
30434: LD_ADDR_VAR 0 12
30438: PUSH
30439: LD_VAR 0 12
30443: PUSH
30444: LD_VAR 0 10
30448: DIFF
30449: ST_TO_ADDR
// end ; end ;
30450: GO 30337
30452: POP
30453: POP
// if solds then
30454: LD_VAR 0 8
30458: IFFALSE 30517
// for i in solds do
30460: LD_ADDR_VAR 0 5
30464: PUSH
30465: LD_VAR 0 8
30469: PUSH
30470: FOR_IN
30471: IFFALSE 30515
// if not GetTag ( i ) then
30473: LD_VAR 0 5
30477: PPUSH
30478: CALL_OW 110
30482: NOT
30483: IFFALSE 30513
// begin defenders := defenders union i ;
30485: LD_ADDR_VAR 0 2
30489: PUSH
30490: LD_VAR 0 2
30494: PUSH
30495: LD_VAR 0 5
30499: UNION
30500: ST_TO_ADDR
// SetTag ( i , 18 ) ;
30501: LD_VAR 0 5
30505: PPUSH
30506: LD_INT 18
30508: PPUSH
30509: CALL_OW 109
// end ;
30513: GO 30470
30515: POP
30516: POP
// repeat wait ( 0 0$1 ) ;
30517: LD_INT 35
30519: PPUSH
30520: CALL_OW 67
// enemy := mc_scan [ base ] ;
30524: LD_ADDR_VAR 0 3
30528: PUSH
30529: LD_EXP 44
30533: PUSH
30534: LD_VAR 0 1
30538: ARRAY
30539: ST_TO_ADDR
// for i in defenders do
30540: LD_ADDR_VAR 0 5
30544: PUSH
30545: LD_VAR 0 2
30549: PUSH
30550: FOR_IN
30551: IFFALSE 31236
// begin e := NearestUnitToUnit ( enemy , i ) ;
30553: LD_ADDR_VAR 0 13
30557: PUSH
30558: LD_VAR 0 3
30562: PPUSH
30563: LD_VAR 0 5
30567: PPUSH
30568: CALL_OW 74
30572: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
30573: LD_ADDR_VAR 0 16
30577: PUSH
30578: LD_EXP 21
30582: PUSH
30583: LD_VAR 0 1
30587: ARRAY
30588: PPUSH
30589: LD_INT 2
30591: PUSH
30592: LD_INT 30
30594: PUSH
30595: LD_INT 0
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: PUSH
30602: LD_INT 30
30604: PUSH
30605: LD_INT 1
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: LIST
30616: PPUSH
30617: CALL_OW 72
30621: NOT
30622: PUSH
30623: LD_EXP 21
30627: PUSH
30628: LD_VAR 0 1
30632: ARRAY
30633: PPUSH
30634: LD_INT 2
30636: PUSH
30637: LD_INT 30
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 30
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: LIST
30661: PPUSH
30662: CALL_OW 72
30666: PPUSH
30667: CALL_OW 256
30671: PUSH
30672: LD_INT 600
30674: LESS
30675: OR
30676: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
30677: LD_VAR 0 5
30681: PPUSH
30682: CALL_OW 247
30686: PUSH
30687: LD_INT 2
30689: DOUBLE
30690: EQUAL
30691: IFTRUE 30695
30693: GO 30942
30695: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
30696: LD_VAR 0 5
30700: PPUSH
30701: CALL_OW 256
30705: PUSH
30706: LD_INT 650
30708: GREATER
30709: PUSH
30710: LD_VAR 0 5
30714: PPUSH
30715: LD_VAR 0 13
30719: PPUSH
30720: CALL_OW 296
30724: PUSH
30725: LD_INT 40
30727: LESS
30728: AND
30729: IFFALSE 30747
// ComAttackUnit ( i , e ) else
30731: LD_VAR 0 5
30735: PPUSH
30736: LD_VAR 0 13
30740: PPUSH
30741: CALL_OW 115
30745: GO 30825
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
30747: LD_VAR 0 5
30751: PPUSH
30752: LD_VAR 0 13
30756: PPUSH
30757: CALL_OW 296
30761: PUSH
30762: LD_INT 30
30764: GREATEREQUAL
30765: PUSH
30766: LD_VAR 0 5
30770: PPUSH
30771: CALL_OW 256
30775: PUSH
30776: LD_INT 650
30778: LESSEQUAL
30779: OR
30780: PUSH
30781: LD_VAR 0 5
30785: PPUSH
30786: LD_EXP 45
30790: PUSH
30791: LD_VAR 0 1
30795: ARRAY
30796: PPUSH
30797: CALL_OW 308
30801: NOT
30802: AND
30803: IFFALSE 30825
// ComMoveToArea ( i , mc_parking [ base ] ) ;
30805: LD_VAR 0 5
30809: PPUSH
30810: LD_EXP 45
30814: PUSH
30815: LD_VAR 0 1
30819: ARRAY
30820: PPUSH
30821: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
30825: LD_VAR 0 5
30829: PPUSH
30830: CALL_OW 256
30834: PUSH
30835: LD_INT 998
30837: LESS
30838: PUSH
30839: LD_VAR 0 5
30843: PPUSH
30844: CALL_OW 263
30848: PUSH
30849: LD_INT 1
30851: EQUAL
30852: AND
30853: PUSH
30854: LD_VAR 0 5
30858: PPUSH
30859: CALL_OW 311
30863: AND
30864: PUSH
30865: LD_VAR 0 5
30869: PPUSH
30870: LD_EXP 45
30874: PUSH
30875: LD_VAR 0 1
30879: ARRAY
30880: PPUSH
30881: CALL_OW 308
30885: AND
30886: IFFALSE 30940
// begin mech := IsDrivenBy ( i ) ;
30888: LD_ADDR_VAR 0 9
30892: PUSH
30893: LD_VAR 0 5
30897: PPUSH
30898: CALL_OW 311
30902: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
30903: LD_VAR 0 9
30907: PPUSH
30908: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
30912: LD_VAR 0 9
30916: PPUSH
30917: LD_VAR 0 5
30921: PPUSH
30922: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
30926: LD_VAR 0 9
30930: PPUSH
30931: LD_VAR 0 5
30935: PPUSH
30936: CALL_OW 180
// end ; end ; unit_human :
30940: GO 31207
30942: LD_INT 1
30944: DOUBLE
30945: EQUAL
30946: IFTRUE 30950
30948: GO 31206
30950: POP
// begin b := IsInUnit ( i ) ;
30951: LD_ADDR_VAR 0 18
30955: PUSH
30956: LD_VAR 0 5
30960: PPUSH
30961: CALL_OW 310
30965: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
30966: LD_ADDR_VAR 0 19
30970: PUSH
30971: LD_VAR 0 18
30975: NOT
30976: PUSH
30977: LD_VAR 0 18
30981: PPUSH
30982: CALL_OW 266
30986: PUSH
30987: LD_INT 32
30989: PUSH
30990: LD_INT 31
30992: PUSH
30993: EMPTY
30994: LIST
30995: LIST
30996: IN
30997: OR
30998: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
30999: LD_VAR 0 16
31003: PUSH
31004: LD_VAR 0 2
31008: PPUSH
31009: LD_INT 21
31011: PUSH
31012: LD_INT 2
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PPUSH
31019: CALL_OW 72
31023: PUSH
31024: LD_INT 1
31026: LESSEQUAL
31027: OR
31028: PUSH
31029: LD_VAR 0 19
31033: AND
31034: PUSH
31035: LD_VAR 0 5
31039: PUSH
31040: LD_VAR 0 17
31044: IN
31045: NOT
31046: AND
31047: IFFALSE 31140
// begin if b then
31049: LD_VAR 0 18
31053: IFFALSE 31102
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
31055: LD_VAR 0 18
31059: PPUSH
31060: LD_VAR 0 3
31064: PPUSH
31065: LD_VAR 0 18
31069: PPUSH
31070: CALL_OW 74
31074: PPUSH
31075: CALL_OW 296
31079: PUSH
31080: LD_INT 10
31082: LESS
31083: PUSH
31084: LD_VAR 0 18
31088: PPUSH
31089: CALL_OW 461
31093: PUSH
31094: LD_INT 7
31096: NONEQUAL
31097: AND
31098: IFFALSE 31102
// continue ;
31100: GO 30550
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
31102: LD_ADDR_VAR 0 17
31106: PUSH
31107: LD_VAR 0 17
31111: PPUSH
31112: LD_VAR 0 17
31116: PUSH
31117: LD_INT 1
31119: PLUS
31120: PPUSH
31121: LD_VAR 0 5
31125: PPUSH
31126: CALL_OW 1
31130: ST_TO_ADDR
// ComExitBuilding ( i ) ;
31131: LD_VAR 0 5
31135: PPUSH
31136: CALL_OW 122
// end ; if sold_defenders then
31140: LD_VAR 0 17
31144: IFFALSE 31204
// if i in sold_defenders then
31146: LD_VAR 0 5
31150: PUSH
31151: LD_VAR 0 17
31155: IN
31156: IFFALSE 31204
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
31158: LD_VAR 0 5
31162: PPUSH
31163: CALL_OW 314
31167: NOT
31168: PUSH
31169: LD_VAR 0 5
31173: PPUSH
31174: LD_VAR 0 13
31178: PPUSH
31179: CALL_OW 296
31183: PUSH
31184: LD_INT 30
31186: LESS
31187: AND
31188: IFFALSE 31204
// ComAttackUnit ( i , e ) ;
31190: LD_VAR 0 5
31194: PPUSH
31195: LD_VAR 0 13
31199: PPUSH
31200: CALL_OW 115
// end ; end ; end ;
31204: GO 31207
31206: POP
// if IsDead ( i ) then
31207: LD_VAR 0 5
31211: PPUSH
31212: CALL_OW 301
31216: IFFALSE 31234
// defenders := defenders diff i ;
31218: LD_ADDR_VAR 0 2
31222: PUSH
31223: LD_VAR 0 2
31227: PUSH
31228: LD_VAR 0 5
31232: DIFF
31233: ST_TO_ADDR
// end ;
31234: GO 30550
31236: POP
31237: POP
// until not enemy or not defenders ;
31238: LD_VAR 0 3
31242: NOT
31243: PUSH
31244: LD_VAR 0 2
31248: NOT
31249: OR
31250: IFFALSE 30517
// MC_Reset ( base , 18 ) ;
31252: LD_VAR 0 1
31256: PPUSH
31257: LD_INT 18
31259: PPUSH
31260: CALL 3581 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
31264: LD_ADDR_VAR 0 2
31268: PUSH
31269: LD_VAR 0 2
31273: PUSH
31274: LD_VAR 0 2
31278: PPUSH
31279: LD_INT 2
31281: PUSH
31282: LD_INT 25
31284: PUSH
31285: LD_INT 1
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 25
31294: PUSH
31295: LD_INT 5
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 25
31304: PUSH
31305: LD_INT 8
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 25
31314: PUSH
31315: LD_INT 9
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: PPUSH
31329: CALL_OW 72
31333: DIFF
31334: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
31335: LD_VAR 0 3
31339: NOT
31340: PUSH
31341: LD_VAR 0 2
31345: PPUSH
31346: LD_INT 21
31348: PUSH
31349: LD_INT 2
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PPUSH
31356: CALL_OW 72
31360: AND
31361: IFFALSE 31623
// begin tmp := FilterByTag ( defenders , 19 ) ;
31363: LD_ADDR_VAR 0 11
31367: PUSH
31368: LD_VAR 0 2
31372: PPUSH
31373: LD_INT 19
31375: PPUSH
31376: CALL 67816 0 2
31380: ST_TO_ADDR
// if tmp then
31381: LD_VAR 0 11
31385: IFFALSE 31455
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
31387: LD_ADDR_VAR 0 11
31391: PUSH
31392: LD_VAR 0 11
31396: PPUSH
31397: LD_INT 25
31399: PUSH
31400: LD_INT 3
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PPUSH
31407: CALL_OW 72
31411: ST_TO_ADDR
// if tmp then
31412: LD_VAR 0 11
31416: IFFALSE 31455
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
31418: LD_ADDR_EXP 33
31422: PUSH
31423: LD_EXP 33
31427: PPUSH
31428: LD_VAR 0 1
31432: PPUSH
31433: LD_EXP 33
31437: PUSH
31438: LD_VAR 0 1
31442: ARRAY
31443: PUSH
31444: LD_VAR 0 11
31448: UNION
31449: PPUSH
31450: CALL_OW 1
31454: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
31455: LD_VAR 0 1
31459: PPUSH
31460: LD_INT 19
31462: PPUSH
31463: CALL 3581 0 2
// repeat wait ( 0 0$1 ) ;
31467: LD_INT 35
31469: PPUSH
31470: CALL_OW 67
// for i in defenders do
31474: LD_ADDR_VAR 0 5
31478: PUSH
31479: LD_VAR 0 2
31483: PUSH
31484: FOR_IN
31485: IFFALSE 31574
// begin if not IsInArea ( i , mc_parking [ base ] ) then
31487: LD_VAR 0 5
31491: PPUSH
31492: LD_EXP 45
31496: PUSH
31497: LD_VAR 0 1
31501: ARRAY
31502: PPUSH
31503: CALL_OW 308
31507: NOT
31508: IFFALSE 31532
// ComMoveToArea ( i , mc_parking [ base ] ) else
31510: LD_VAR 0 5
31514: PPUSH
31515: LD_EXP 45
31519: PUSH
31520: LD_VAR 0 1
31524: ARRAY
31525: PPUSH
31526: CALL_OW 113
31530: GO 31572
// if GetControl ( i ) = control_manual then
31532: LD_VAR 0 5
31536: PPUSH
31537: CALL_OW 263
31541: PUSH
31542: LD_INT 1
31544: EQUAL
31545: IFFALSE 31572
// if IsDrivenBy ( i ) then
31547: LD_VAR 0 5
31551: PPUSH
31552: CALL_OW 311
31556: IFFALSE 31572
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
31558: LD_VAR 0 5
31562: PPUSH
31563: CALL_OW 311
31567: PPUSH
31568: CALL_OW 121
// end ;
31572: GO 31484
31574: POP
31575: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
31576: LD_VAR 0 2
31580: PPUSH
31581: LD_INT 95
31583: PUSH
31584: LD_EXP 45
31588: PUSH
31589: LD_VAR 0 1
31593: ARRAY
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PPUSH
31599: CALL_OW 72
31603: PUSH
31604: LD_VAR 0 2
31608: EQUAL
31609: PUSH
31610: LD_EXP 44
31614: PUSH
31615: LD_VAR 0 1
31619: ARRAY
31620: OR
31621: IFFALSE 31467
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
31623: LD_ADDR_EXP 43
31627: PUSH
31628: LD_EXP 43
31632: PPUSH
31633: LD_VAR 0 1
31637: PPUSH
31638: LD_EXP 43
31642: PUSH
31643: LD_VAR 0 1
31647: ARRAY
31648: PUSH
31649: LD_VAR 0 2
31653: UNION
31654: PPUSH
31655: CALL_OW 1
31659: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
31660: LD_VAR 0 1
31664: PPUSH
31665: LD_INT 20
31667: PPUSH
31668: CALL 3581 0 2
// end ;
31672: LD_VAR 0 4
31676: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
31677: LD_INT 0
31679: PPUSH
31680: PPUSH
31681: PPUSH
31682: PPUSH
// result := false ;
31683: LD_ADDR_VAR 0 2
31687: PUSH
31688: LD_INT 0
31690: ST_TO_ADDR
// side := GetSide ( unit ) ;
31691: LD_ADDR_VAR 0 3
31695: PUSH
31696: LD_VAR 0 1
31700: PPUSH
31701: CALL_OW 255
31705: ST_TO_ADDR
// nat := GetNation ( unit ) ;
31706: LD_ADDR_VAR 0 4
31710: PUSH
31711: LD_VAR 0 1
31715: PPUSH
31716: CALL_OW 248
31720: ST_TO_ADDR
// case nat of 1 :
31721: LD_VAR 0 4
31725: PUSH
31726: LD_INT 1
31728: DOUBLE
31729: EQUAL
31730: IFTRUE 31734
31732: GO 31745
31734: POP
// tech := tech_lassight ; 2 :
31735: LD_ADDR_VAR 0 5
31739: PUSH
31740: LD_INT 12
31742: ST_TO_ADDR
31743: GO 31784
31745: LD_INT 2
31747: DOUBLE
31748: EQUAL
31749: IFTRUE 31753
31751: GO 31764
31753: POP
// tech := tech_mortar ; 3 :
31754: LD_ADDR_VAR 0 5
31758: PUSH
31759: LD_INT 41
31761: ST_TO_ADDR
31762: GO 31784
31764: LD_INT 3
31766: DOUBLE
31767: EQUAL
31768: IFTRUE 31772
31770: GO 31783
31772: POP
// tech := tech_bazooka ; end ;
31773: LD_ADDR_VAR 0 5
31777: PUSH
31778: LD_INT 44
31780: ST_TO_ADDR
31781: GO 31784
31783: POP
// if Researched ( side , tech ) then
31784: LD_VAR 0 3
31788: PPUSH
31789: LD_VAR 0 5
31793: PPUSH
31794: CALL_OW 325
31798: IFFALSE 31825
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
31800: LD_ADDR_VAR 0 2
31804: PUSH
31805: LD_INT 5
31807: PUSH
31808: LD_INT 8
31810: PUSH
31811: LD_INT 9
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: LIST
31818: PUSH
31819: LD_VAR 0 4
31823: ARRAY
31824: ST_TO_ADDR
// end ;
31825: LD_VAR 0 2
31829: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
31830: LD_INT 0
31832: PPUSH
31833: PPUSH
31834: PPUSH
// if not mines then
31835: LD_VAR 0 2
31839: NOT
31840: IFFALSE 31844
// exit ;
31842: GO 31988
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
31844: LD_ADDR_VAR 0 5
31848: PUSH
31849: LD_INT 81
31851: PUSH
31852: LD_VAR 0 1
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 3
31863: PUSH
31864: LD_INT 21
31866: PUSH
31867: LD_INT 3
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: EMPTY
31875: LIST
31876: LIST
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PPUSH
31882: CALL_OW 69
31886: ST_TO_ADDR
// for i in mines do
31887: LD_ADDR_VAR 0 4
31891: PUSH
31892: LD_VAR 0 2
31896: PUSH
31897: FOR_IN
31898: IFFALSE 31986
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
31900: LD_VAR 0 4
31904: PUSH
31905: LD_INT 1
31907: ARRAY
31908: PPUSH
31909: LD_VAR 0 4
31913: PUSH
31914: LD_INT 2
31916: ARRAY
31917: PPUSH
31918: CALL_OW 458
31922: NOT
31923: IFFALSE 31927
// continue ;
31925: GO 31897
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
31927: LD_VAR 0 4
31931: PUSH
31932: LD_INT 1
31934: ARRAY
31935: PPUSH
31936: LD_VAR 0 4
31940: PUSH
31941: LD_INT 2
31943: ARRAY
31944: PPUSH
31945: CALL_OW 428
31949: PUSH
31950: LD_VAR 0 5
31954: IN
31955: IFFALSE 31984
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
31957: LD_VAR 0 4
31961: PUSH
31962: LD_INT 1
31964: ARRAY
31965: PPUSH
31966: LD_VAR 0 4
31970: PUSH
31971: LD_INT 2
31973: ARRAY
31974: PPUSH
31975: LD_VAR 0 1
31979: PPUSH
31980: CALL_OW 456
// end ;
31984: GO 31897
31986: POP
31987: POP
// end ;
31988: LD_VAR 0 3
31992: RET
// export function Count ( array ) ; var i ; begin
31993: LD_INT 0
31995: PPUSH
31996: PPUSH
// result := 0 ;
31997: LD_ADDR_VAR 0 2
32001: PUSH
32002: LD_INT 0
32004: ST_TO_ADDR
// for i in array do
32005: LD_ADDR_VAR 0 3
32009: PUSH
32010: LD_VAR 0 1
32014: PUSH
32015: FOR_IN
32016: IFFALSE 32040
// if i then
32018: LD_VAR 0 3
32022: IFFALSE 32038
// result := result + 1 ;
32024: LD_ADDR_VAR 0 2
32028: PUSH
32029: LD_VAR 0 2
32033: PUSH
32034: LD_INT 1
32036: PLUS
32037: ST_TO_ADDR
32038: GO 32015
32040: POP
32041: POP
// end ;
32042: LD_VAR 0 2
32046: RET
// export function IsEmpty ( building ) ; begin
32047: LD_INT 0
32049: PPUSH
// if not building then
32050: LD_VAR 0 1
32054: NOT
32055: IFFALSE 32059
// exit ;
32057: GO 32102
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
32059: LD_ADDR_VAR 0 2
32063: PUSH
32064: LD_VAR 0 1
32068: PUSH
32069: LD_INT 22
32071: PUSH
32072: LD_VAR 0 1
32076: PPUSH
32077: CALL_OW 255
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: PUSH
32086: LD_INT 58
32088: PUSH
32089: EMPTY
32090: LIST
32091: PUSH
32092: EMPTY
32093: LIST
32094: LIST
32095: PPUSH
32096: CALL_OW 69
32100: IN
32101: ST_TO_ADDR
// end ;
32102: LD_VAR 0 2
32106: RET
// export function IsNotFull ( building ) ; begin
32107: LD_INT 0
32109: PPUSH
// if not building then
32110: LD_VAR 0 1
32114: NOT
32115: IFFALSE 32119
// exit ;
32117: GO 32138
// result := UnitsInside ( building ) < 6 ;
32119: LD_ADDR_VAR 0 2
32123: PUSH
32124: LD_VAR 0 1
32128: PPUSH
32129: CALL_OW 313
32133: PUSH
32134: LD_INT 6
32136: LESS
32137: ST_TO_ADDR
// end ;
32138: LD_VAR 0 2
32142: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
32143: LD_INT 0
32145: PPUSH
32146: PPUSH
32147: PPUSH
32148: PPUSH
// tmp := [ ] ;
32149: LD_ADDR_VAR 0 3
32153: PUSH
32154: EMPTY
32155: ST_TO_ADDR
// list := [ ] ;
32156: LD_ADDR_VAR 0 5
32160: PUSH
32161: EMPTY
32162: ST_TO_ADDR
// for i = 16 to 25 do
32163: LD_ADDR_VAR 0 4
32167: PUSH
32168: DOUBLE
32169: LD_INT 16
32171: DEC
32172: ST_TO_ADDR
32173: LD_INT 25
32175: PUSH
32176: FOR_TO
32177: IFFALSE 32250
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
32179: LD_ADDR_VAR 0 3
32183: PUSH
32184: LD_VAR 0 3
32188: PUSH
32189: LD_INT 22
32191: PUSH
32192: LD_VAR 0 1
32196: PPUSH
32197: CALL_OW 255
32201: PUSH
32202: EMPTY
32203: LIST
32204: LIST
32205: PUSH
32206: LD_INT 91
32208: PUSH
32209: LD_VAR 0 1
32213: PUSH
32214: LD_INT 6
32216: PUSH
32217: EMPTY
32218: LIST
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 30
32224: PUSH
32225: LD_VAR 0 4
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: LIST
32238: PUSH
32239: EMPTY
32240: LIST
32241: PPUSH
32242: CALL_OW 69
32246: ADD
32247: ST_TO_ADDR
32248: GO 32176
32250: POP
32251: POP
// for i = 1 to tmp do
32252: LD_ADDR_VAR 0 4
32256: PUSH
32257: DOUBLE
32258: LD_INT 1
32260: DEC
32261: ST_TO_ADDR
32262: LD_VAR 0 3
32266: PUSH
32267: FOR_TO
32268: IFFALSE 32356
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
32270: LD_ADDR_VAR 0 5
32274: PUSH
32275: LD_VAR 0 5
32279: PUSH
32280: LD_VAR 0 3
32284: PUSH
32285: LD_VAR 0 4
32289: ARRAY
32290: PPUSH
32291: CALL_OW 266
32295: PUSH
32296: LD_VAR 0 3
32300: PUSH
32301: LD_VAR 0 4
32305: ARRAY
32306: PPUSH
32307: CALL_OW 250
32311: PUSH
32312: LD_VAR 0 3
32316: PUSH
32317: LD_VAR 0 4
32321: ARRAY
32322: PPUSH
32323: CALL_OW 251
32327: PUSH
32328: LD_VAR 0 3
32332: PUSH
32333: LD_VAR 0 4
32337: ARRAY
32338: PPUSH
32339: CALL_OW 254
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: LIST
32348: LIST
32349: PUSH
32350: EMPTY
32351: LIST
32352: ADD
32353: ST_TO_ADDR
32354: GO 32267
32356: POP
32357: POP
// result := list ;
32358: LD_ADDR_VAR 0 2
32362: PUSH
32363: LD_VAR 0 5
32367: ST_TO_ADDR
// end ;
32368: LD_VAR 0 2
32372: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
32373: LD_INT 0
32375: PPUSH
32376: PPUSH
32377: PPUSH
32378: PPUSH
32379: PPUSH
32380: PPUSH
32381: PPUSH
// if not factory then
32382: LD_VAR 0 1
32386: NOT
32387: IFFALSE 32391
// exit ;
32389: GO 32916
// if control = control_apeman then
32391: LD_VAR 0 4
32395: PUSH
32396: LD_INT 5
32398: EQUAL
32399: IFFALSE 32508
// begin tmp := UnitsInside ( factory ) ;
32401: LD_ADDR_VAR 0 8
32405: PUSH
32406: LD_VAR 0 1
32410: PPUSH
32411: CALL_OW 313
32415: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
32416: LD_VAR 0 8
32420: PPUSH
32421: LD_INT 25
32423: PUSH
32424: LD_INT 12
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PPUSH
32431: CALL_OW 72
32435: NOT
32436: IFFALSE 32446
// control := control_manual ;
32438: LD_ADDR_VAR 0 4
32442: PUSH
32443: LD_INT 1
32445: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
32446: LD_ADDR_VAR 0 8
32450: PUSH
32451: LD_VAR 0 1
32455: PPUSH
32456: CALL 32143 0 1
32460: ST_TO_ADDR
// if tmp then
32461: LD_VAR 0 8
32465: IFFALSE 32508
// begin for i in tmp do
32467: LD_ADDR_VAR 0 7
32471: PUSH
32472: LD_VAR 0 8
32476: PUSH
32477: FOR_IN
32478: IFFALSE 32506
// if i [ 1 ] = b_ext_radar then
32480: LD_VAR 0 7
32484: PUSH
32485: LD_INT 1
32487: ARRAY
32488: PUSH
32489: LD_INT 20
32491: EQUAL
32492: IFFALSE 32504
// begin control := control_remote ;
32494: LD_ADDR_VAR 0 4
32498: PUSH
32499: LD_INT 2
32501: ST_TO_ADDR
// break ;
32502: GO 32506
// end ;
32504: GO 32477
32506: POP
32507: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
32508: LD_VAR 0 1
32512: PPUSH
32513: LD_VAR 0 2
32517: PPUSH
32518: LD_VAR 0 3
32522: PPUSH
32523: LD_VAR 0 4
32527: PPUSH
32528: LD_VAR 0 5
32532: PPUSH
32533: CALL_OW 448
32537: IFFALSE 32572
// begin result := [ chassis , engine , control , weapon ] ;
32539: LD_ADDR_VAR 0 6
32543: PUSH
32544: LD_VAR 0 2
32548: PUSH
32549: LD_VAR 0 3
32553: PUSH
32554: LD_VAR 0 4
32558: PUSH
32559: LD_VAR 0 5
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: ST_TO_ADDR
// exit ;
32570: GO 32916
// end ; _chassis := AvailableChassisList ( factory ) ;
32572: LD_ADDR_VAR 0 9
32576: PUSH
32577: LD_VAR 0 1
32581: PPUSH
32582: CALL_OW 475
32586: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
32587: LD_ADDR_VAR 0 11
32591: PUSH
32592: LD_VAR 0 1
32596: PPUSH
32597: CALL_OW 476
32601: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
32602: LD_ADDR_VAR 0 12
32606: PUSH
32607: LD_VAR 0 1
32611: PPUSH
32612: CALL_OW 477
32616: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
32617: LD_ADDR_VAR 0 10
32621: PUSH
32622: LD_VAR 0 1
32626: PPUSH
32627: CALL_OW 478
32631: ST_TO_ADDR
// if not chassis in _chassis then
32632: LD_VAR 0 2
32636: PUSH
32637: LD_VAR 0 9
32641: IN
32642: NOT
32643: IFFALSE 32669
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
32645: LD_ADDR_VAR 0 2
32649: PUSH
32650: LD_VAR 0 9
32654: PUSH
32655: LD_INT 1
32657: PPUSH
32658: LD_VAR 0 9
32662: PPUSH
32663: CALL_OW 12
32667: ARRAY
32668: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
32669: LD_VAR 0 2
32673: PPUSH
32674: LD_VAR 0 3
32678: PPUSH
32679: CALL 32921 0 2
32683: NOT
32684: IFFALSE 32743
// repeat engine := _engine [ 1 ] ;
32686: LD_ADDR_VAR 0 3
32690: PUSH
32691: LD_VAR 0 11
32695: PUSH
32696: LD_INT 1
32698: ARRAY
32699: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
32700: LD_ADDR_VAR 0 11
32704: PUSH
32705: LD_VAR 0 11
32709: PPUSH
32710: LD_INT 1
32712: PPUSH
32713: CALL_OW 3
32717: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
32718: LD_VAR 0 2
32722: PPUSH
32723: LD_VAR 0 3
32727: PPUSH
32728: CALL 32921 0 2
32732: PUSH
32733: LD_VAR 0 11
32737: PUSH
32738: EMPTY
32739: EQUAL
32740: OR
32741: IFFALSE 32686
// if not control in _control then
32743: LD_VAR 0 4
32747: PUSH
32748: LD_VAR 0 12
32752: IN
32753: NOT
32754: IFFALSE 32780
// control := _control [ rand ( 1 , _control ) ] ;
32756: LD_ADDR_VAR 0 4
32760: PUSH
32761: LD_VAR 0 12
32765: PUSH
32766: LD_INT 1
32768: PPUSH
32769: LD_VAR 0 12
32773: PPUSH
32774: CALL_OW 12
32778: ARRAY
32779: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
32780: LD_VAR 0 2
32784: PPUSH
32785: LD_VAR 0 5
32789: PPUSH
32790: CALL 33141 0 2
32794: NOT
32795: IFFALSE 32854
// repeat weapon := _weapon [ 1 ] ;
32797: LD_ADDR_VAR 0 5
32801: PUSH
32802: LD_VAR 0 10
32806: PUSH
32807: LD_INT 1
32809: ARRAY
32810: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
32811: LD_ADDR_VAR 0 10
32815: PUSH
32816: LD_VAR 0 10
32820: PPUSH
32821: LD_INT 1
32823: PPUSH
32824: CALL_OW 3
32828: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
32829: LD_VAR 0 2
32833: PPUSH
32834: LD_VAR 0 5
32838: PPUSH
32839: CALL 33141 0 2
32843: PUSH
32844: LD_VAR 0 10
32848: PUSH
32849: EMPTY
32850: EQUAL
32851: OR
32852: IFFALSE 32797
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
32854: LD_VAR 0 1
32858: PPUSH
32859: LD_VAR 0 2
32863: PPUSH
32864: LD_VAR 0 3
32868: PPUSH
32869: LD_VAR 0 4
32873: PPUSH
32874: LD_VAR 0 5
32878: PPUSH
32879: CALL_OW 448
32883: IFFALSE 32916
// result := [ chassis , engine , control , weapon ] ;
32885: LD_ADDR_VAR 0 6
32889: PUSH
32890: LD_VAR 0 2
32894: PUSH
32895: LD_VAR 0 3
32899: PUSH
32900: LD_VAR 0 4
32904: PUSH
32905: LD_VAR 0 5
32909: PUSH
32910: EMPTY
32911: LIST
32912: LIST
32913: LIST
32914: LIST
32915: ST_TO_ADDR
// end ;
32916: LD_VAR 0 6
32920: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
32921: LD_INT 0
32923: PPUSH
// if not chassis or not engine then
32924: LD_VAR 0 1
32928: NOT
32929: PUSH
32930: LD_VAR 0 2
32934: NOT
32935: OR
32936: IFFALSE 32940
// exit ;
32938: GO 33136
// case engine of engine_solar :
32940: LD_VAR 0 2
32944: PUSH
32945: LD_INT 2
32947: DOUBLE
32948: EQUAL
32949: IFTRUE 32953
32951: GO 32991
32953: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
32954: LD_ADDR_VAR 0 3
32958: PUSH
32959: LD_INT 11
32961: PUSH
32962: LD_INT 12
32964: PUSH
32965: LD_INT 13
32967: PUSH
32968: LD_INT 14
32970: PUSH
32971: LD_INT 1
32973: PUSH
32974: LD_INT 2
32976: PUSH
32977: LD_INT 3
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: ST_TO_ADDR
32989: GO 33120
32991: LD_INT 1
32993: DOUBLE
32994: EQUAL
32995: IFTRUE 32999
32997: GO 33061
32999: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
33000: LD_ADDR_VAR 0 3
33004: PUSH
33005: LD_INT 11
33007: PUSH
33008: LD_INT 12
33010: PUSH
33011: LD_INT 13
33013: PUSH
33014: LD_INT 14
33016: PUSH
33017: LD_INT 1
33019: PUSH
33020: LD_INT 2
33022: PUSH
33023: LD_INT 3
33025: PUSH
33026: LD_INT 4
33028: PUSH
33029: LD_INT 5
33031: PUSH
33032: LD_INT 21
33034: PUSH
33035: LD_INT 23
33037: PUSH
33038: LD_INT 22
33040: PUSH
33041: LD_INT 24
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: LIST
33048: LIST
33049: LIST
33050: LIST
33051: LIST
33052: LIST
33053: LIST
33054: LIST
33055: LIST
33056: LIST
33057: LIST
33058: ST_TO_ADDR
33059: GO 33120
33061: LD_INT 3
33063: DOUBLE
33064: EQUAL
33065: IFTRUE 33069
33067: GO 33119
33069: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
33070: LD_ADDR_VAR 0 3
33074: PUSH
33075: LD_INT 13
33077: PUSH
33078: LD_INT 14
33080: PUSH
33081: LD_INT 2
33083: PUSH
33084: LD_INT 3
33086: PUSH
33087: LD_INT 4
33089: PUSH
33090: LD_INT 5
33092: PUSH
33093: LD_INT 21
33095: PUSH
33096: LD_INT 22
33098: PUSH
33099: LD_INT 23
33101: PUSH
33102: LD_INT 24
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: LIST
33109: LIST
33110: LIST
33111: LIST
33112: LIST
33113: LIST
33114: LIST
33115: LIST
33116: ST_TO_ADDR
33117: GO 33120
33119: POP
// result := ( chassis in result ) ;
33120: LD_ADDR_VAR 0 3
33124: PUSH
33125: LD_VAR 0 1
33129: PUSH
33130: LD_VAR 0 3
33134: IN
33135: ST_TO_ADDR
// end ;
33136: LD_VAR 0 3
33140: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
33141: LD_INT 0
33143: PPUSH
// if not chassis or not weapon then
33144: LD_VAR 0 1
33148: NOT
33149: PUSH
33150: LD_VAR 0 2
33154: NOT
33155: OR
33156: IFFALSE 33160
// exit ;
33158: GO 34186
// case weapon of us_machine_gun :
33160: LD_VAR 0 2
33164: PUSH
33165: LD_INT 2
33167: DOUBLE
33168: EQUAL
33169: IFTRUE 33173
33171: GO 33203
33173: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
33174: LD_ADDR_VAR 0 3
33178: PUSH
33179: LD_INT 1
33181: PUSH
33182: LD_INT 2
33184: PUSH
33185: LD_INT 3
33187: PUSH
33188: LD_INT 4
33190: PUSH
33191: LD_INT 5
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: LIST
33198: LIST
33199: LIST
33200: ST_TO_ADDR
33201: GO 34170
33203: LD_INT 3
33205: DOUBLE
33206: EQUAL
33207: IFTRUE 33211
33209: GO 33241
33211: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
33212: LD_ADDR_VAR 0 3
33216: PUSH
33217: LD_INT 1
33219: PUSH
33220: LD_INT 2
33222: PUSH
33223: LD_INT 3
33225: PUSH
33226: LD_INT 4
33228: PUSH
33229: LD_INT 5
33231: PUSH
33232: EMPTY
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: ST_TO_ADDR
33239: GO 34170
33241: LD_INT 11
33243: DOUBLE
33244: EQUAL
33245: IFTRUE 33249
33247: GO 33279
33249: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
33250: LD_ADDR_VAR 0 3
33254: PUSH
33255: LD_INT 1
33257: PUSH
33258: LD_INT 2
33260: PUSH
33261: LD_INT 3
33263: PUSH
33264: LD_INT 4
33266: PUSH
33267: LD_INT 5
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: ST_TO_ADDR
33277: GO 34170
33279: LD_INT 4
33281: DOUBLE
33282: EQUAL
33283: IFTRUE 33287
33285: GO 33313
33287: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
33288: LD_ADDR_VAR 0 3
33292: PUSH
33293: LD_INT 2
33295: PUSH
33296: LD_INT 3
33298: PUSH
33299: LD_INT 4
33301: PUSH
33302: LD_INT 5
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: ST_TO_ADDR
33311: GO 34170
33313: LD_INT 5
33315: DOUBLE
33316: EQUAL
33317: IFTRUE 33321
33319: GO 33347
33321: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
33322: LD_ADDR_VAR 0 3
33326: PUSH
33327: LD_INT 2
33329: PUSH
33330: LD_INT 3
33332: PUSH
33333: LD_INT 4
33335: PUSH
33336: LD_INT 5
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: ST_TO_ADDR
33345: GO 34170
33347: LD_INT 9
33349: DOUBLE
33350: EQUAL
33351: IFTRUE 33355
33353: GO 33381
33355: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
33356: LD_ADDR_VAR 0 3
33360: PUSH
33361: LD_INT 2
33363: PUSH
33364: LD_INT 3
33366: PUSH
33367: LD_INT 4
33369: PUSH
33370: LD_INT 5
33372: PUSH
33373: EMPTY
33374: LIST
33375: LIST
33376: LIST
33377: LIST
33378: ST_TO_ADDR
33379: GO 34170
33381: LD_INT 7
33383: DOUBLE
33384: EQUAL
33385: IFTRUE 33389
33387: GO 33415
33389: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
33390: LD_ADDR_VAR 0 3
33394: PUSH
33395: LD_INT 2
33397: PUSH
33398: LD_INT 3
33400: PUSH
33401: LD_INT 4
33403: PUSH
33404: LD_INT 5
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: ST_TO_ADDR
33413: GO 34170
33415: LD_INT 12
33417: DOUBLE
33418: EQUAL
33419: IFTRUE 33423
33421: GO 33449
33423: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
33424: LD_ADDR_VAR 0 3
33428: PUSH
33429: LD_INT 2
33431: PUSH
33432: LD_INT 3
33434: PUSH
33435: LD_INT 4
33437: PUSH
33438: LD_INT 5
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: ST_TO_ADDR
33447: GO 34170
33449: LD_INT 13
33451: DOUBLE
33452: EQUAL
33453: IFTRUE 33457
33455: GO 33483
33457: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
33458: LD_ADDR_VAR 0 3
33462: PUSH
33463: LD_INT 2
33465: PUSH
33466: LD_INT 3
33468: PUSH
33469: LD_INT 4
33471: PUSH
33472: LD_INT 5
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: ST_TO_ADDR
33481: GO 34170
33483: LD_INT 14
33485: DOUBLE
33486: EQUAL
33487: IFTRUE 33491
33489: GO 33509
33491: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
33492: LD_ADDR_VAR 0 3
33496: PUSH
33497: LD_INT 4
33499: PUSH
33500: LD_INT 5
33502: PUSH
33503: EMPTY
33504: LIST
33505: LIST
33506: ST_TO_ADDR
33507: GO 34170
33509: LD_INT 6
33511: DOUBLE
33512: EQUAL
33513: IFTRUE 33517
33515: GO 33535
33517: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
33518: LD_ADDR_VAR 0 3
33522: PUSH
33523: LD_INT 4
33525: PUSH
33526: LD_INT 5
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: ST_TO_ADDR
33533: GO 34170
33535: LD_INT 10
33537: DOUBLE
33538: EQUAL
33539: IFTRUE 33543
33541: GO 33561
33543: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
33544: LD_ADDR_VAR 0 3
33548: PUSH
33549: LD_INT 4
33551: PUSH
33552: LD_INT 5
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: ST_TO_ADDR
33559: GO 34170
33561: LD_INT 22
33563: DOUBLE
33564: EQUAL
33565: IFTRUE 33569
33567: GO 33595
33569: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
33570: LD_ADDR_VAR 0 3
33574: PUSH
33575: LD_INT 11
33577: PUSH
33578: LD_INT 12
33580: PUSH
33581: LD_INT 13
33583: PUSH
33584: LD_INT 14
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: LIST
33591: LIST
33592: ST_TO_ADDR
33593: GO 34170
33595: LD_INT 23
33597: DOUBLE
33598: EQUAL
33599: IFTRUE 33603
33601: GO 33629
33603: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
33604: LD_ADDR_VAR 0 3
33608: PUSH
33609: LD_INT 11
33611: PUSH
33612: LD_INT 12
33614: PUSH
33615: LD_INT 13
33617: PUSH
33618: LD_INT 14
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: ST_TO_ADDR
33627: GO 34170
33629: LD_INT 24
33631: DOUBLE
33632: EQUAL
33633: IFTRUE 33637
33635: GO 33663
33637: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
33638: LD_ADDR_VAR 0 3
33642: PUSH
33643: LD_INT 11
33645: PUSH
33646: LD_INT 12
33648: PUSH
33649: LD_INT 13
33651: PUSH
33652: LD_INT 14
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: LIST
33659: LIST
33660: ST_TO_ADDR
33661: GO 34170
33663: LD_INT 30
33665: DOUBLE
33666: EQUAL
33667: IFTRUE 33671
33669: GO 33697
33671: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
33672: LD_ADDR_VAR 0 3
33676: PUSH
33677: LD_INT 11
33679: PUSH
33680: LD_INT 12
33682: PUSH
33683: LD_INT 13
33685: PUSH
33686: LD_INT 14
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: ST_TO_ADDR
33695: GO 34170
33697: LD_INT 25
33699: DOUBLE
33700: EQUAL
33701: IFTRUE 33705
33703: GO 33723
33705: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
33706: LD_ADDR_VAR 0 3
33710: PUSH
33711: LD_INT 13
33713: PUSH
33714: LD_INT 14
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: ST_TO_ADDR
33721: GO 34170
33723: LD_INT 27
33725: DOUBLE
33726: EQUAL
33727: IFTRUE 33731
33729: GO 33749
33731: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
33732: LD_ADDR_VAR 0 3
33736: PUSH
33737: LD_INT 13
33739: PUSH
33740: LD_INT 14
33742: PUSH
33743: EMPTY
33744: LIST
33745: LIST
33746: ST_TO_ADDR
33747: GO 34170
33749: LD_INT 28
33751: DOUBLE
33752: EQUAL
33753: IFTRUE 33757
33755: GO 33775
33757: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
33758: LD_ADDR_VAR 0 3
33762: PUSH
33763: LD_INT 13
33765: PUSH
33766: LD_INT 14
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: ST_TO_ADDR
33773: GO 34170
33775: LD_INT 29
33777: DOUBLE
33778: EQUAL
33779: IFTRUE 33783
33781: GO 33801
33783: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
33784: LD_ADDR_VAR 0 3
33788: PUSH
33789: LD_INT 13
33791: PUSH
33792: LD_INT 14
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: ST_TO_ADDR
33799: GO 34170
33801: LD_INT 31
33803: DOUBLE
33804: EQUAL
33805: IFTRUE 33809
33807: GO 33827
33809: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
33810: LD_ADDR_VAR 0 3
33814: PUSH
33815: LD_INT 13
33817: PUSH
33818: LD_INT 14
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: ST_TO_ADDR
33825: GO 34170
33827: LD_INT 26
33829: DOUBLE
33830: EQUAL
33831: IFTRUE 33835
33833: GO 33853
33835: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
33836: LD_ADDR_VAR 0 3
33840: PUSH
33841: LD_INT 13
33843: PUSH
33844: LD_INT 14
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: ST_TO_ADDR
33851: GO 34170
33853: LD_INT 42
33855: DOUBLE
33856: EQUAL
33857: IFTRUE 33861
33859: GO 33887
33861: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
33862: LD_ADDR_VAR 0 3
33866: PUSH
33867: LD_INT 21
33869: PUSH
33870: LD_INT 22
33872: PUSH
33873: LD_INT 23
33875: PUSH
33876: LD_INT 24
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: ST_TO_ADDR
33885: GO 34170
33887: LD_INT 43
33889: DOUBLE
33890: EQUAL
33891: IFTRUE 33895
33893: GO 33921
33895: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
33896: LD_ADDR_VAR 0 3
33900: PUSH
33901: LD_INT 21
33903: PUSH
33904: LD_INT 22
33906: PUSH
33907: LD_INT 23
33909: PUSH
33910: LD_INT 24
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: ST_TO_ADDR
33919: GO 34170
33921: LD_INT 44
33923: DOUBLE
33924: EQUAL
33925: IFTRUE 33929
33927: GO 33955
33929: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
33930: LD_ADDR_VAR 0 3
33934: PUSH
33935: LD_INT 21
33937: PUSH
33938: LD_INT 22
33940: PUSH
33941: LD_INT 23
33943: PUSH
33944: LD_INT 24
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: LIST
33951: LIST
33952: ST_TO_ADDR
33953: GO 34170
33955: LD_INT 45
33957: DOUBLE
33958: EQUAL
33959: IFTRUE 33963
33961: GO 33989
33963: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
33964: LD_ADDR_VAR 0 3
33968: PUSH
33969: LD_INT 21
33971: PUSH
33972: LD_INT 22
33974: PUSH
33975: LD_INT 23
33977: PUSH
33978: LD_INT 24
33980: PUSH
33981: EMPTY
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: ST_TO_ADDR
33987: GO 34170
33989: LD_INT 49
33991: DOUBLE
33992: EQUAL
33993: IFTRUE 33997
33995: GO 34023
33997: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
33998: LD_ADDR_VAR 0 3
34002: PUSH
34003: LD_INT 21
34005: PUSH
34006: LD_INT 22
34008: PUSH
34009: LD_INT 23
34011: PUSH
34012: LD_INT 24
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: LIST
34019: LIST
34020: ST_TO_ADDR
34021: GO 34170
34023: LD_INT 51
34025: DOUBLE
34026: EQUAL
34027: IFTRUE 34031
34029: GO 34057
34031: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
34032: LD_ADDR_VAR 0 3
34036: PUSH
34037: LD_INT 21
34039: PUSH
34040: LD_INT 22
34042: PUSH
34043: LD_INT 23
34045: PUSH
34046: LD_INT 24
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: ST_TO_ADDR
34055: GO 34170
34057: LD_INT 52
34059: DOUBLE
34060: EQUAL
34061: IFTRUE 34065
34063: GO 34091
34065: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
34066: LD_ADDR_VAR 0 3
34070: PUSH
34071: LD_INT 21
34073: PUSH
34074: LD_INT 22
34076: PUSH
34077: LD_INT 23
34079: PUSH
34080: LD_INT 24
34082: PUSH
34083: EMPTY
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: ST_TO_ADDR
34089: GO 34170
34091: LD_INT 53
34093: DOUBLE
34094: EQUAL
34095: IFTRUE 34099
34097: GO 34117
34099: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
34100: LD_ADDR_VAR 0 3
34104: PUSH
34105: LD_INT 23
34107: PUSH
34108: LD_INT 24
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: ST_TO_ADDR
34115: GO 34170
34117: LD_INT 46
34119: DOUBLE
34120: EQUAL
34121: IFTRUE 34125
34123: GO 34143
34125: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
34126: LD_ADDR_VAR 0 3
34130: PUSH
34131: LD_INT 23
34133: PUSH
34134: LD_INT 24
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: ST_TO_ADDR
34141: GO 34170
34143: LD_INT 47
34145: DOUBLE
34146: EQUAL
34147: IFTRUE 34151
34149: GO 34169
34151: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
34152: LD_ADDR_VAR 0 3
34156: PUSH
34157: LD_INT 23
34159: PUSH
34160: LD_INT 24
34162: PUSH
34163: EMPTY
34164: LIST
34165: LIST
34166: ST_TO_ADDR
34167: GO 34170
34169: POP
// result := ( chassis in result ) ;
34170: LD_ADDR_VAR 0 3
34174: PUSH
34175: LD_VAR 0 1
34179: PUSH
34180: LD_VAR 0 3
34184: IN
34185: ST_TO_ADDR
// end ;
34186: LD_VAR 0 3
34190: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
34191: LD_INT 0
34193: PPUSH
34194: PPUSH
34195: PPUSH
34196: PPUSH
34197: PPUSH
34198: PPUSH
34199: PPUSH
// result := array ;
34200: LD_ADDR_VAR 0 5
34204: PUSH
34205: LD_VAR 0 1
34209: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
34210: LD_VAR 0 1
34214: NOT
34215: PUSH
34216: LD_VAR 0 2
34220: NOT
34221: OR
34222: PUSH
34223: LD_VAR 0 3
34227: NOT
34228: OR
34229: PUSH
34230: LD_VAR 0 2
34234: PUSH
34235: LD_VAR 0 1
34239: GREATER
34240: OR
34241: PUSH
34242: LD_VAR 0 3
34246: PUSH
34247: LD_VAR 0 1
34251: GREATER
34252: OR
34253: IFFALSE 34257
// exit ;
34255: GO 34553
// if direction then
34257: LD_VAR 0 4
34261: IFFALSE 34325
// begin d := 1 ;
34263: LD_ADDR_VAR 0 9
34267: PUSH
34268: LD_INT 1
34270: ST_TO_ADDR
// if i_from > i_to then
34271: LD_VAR 0 2
34275: PUSH
34276: LD_VAR 0 3
34280: GREATER
34281: IFFALSE 34307
// length := ( array - i_from ) + i_to else
34283: LD_ADDR_VAR 0 11
34287: PUSH
34288: LD_VAR 0 1
34292: PUSH
34293: LD_VAR 0 2
34297: MINUS
34298: PUSH
34299: LD_VAR 0 3
34303: PLUS
34304: ST_TO_ADDR
34305: GO 34323
// length := i_to - i_from ;
34307: LD_ADDR_VAR 0 11
34311: PUSH
34312: LD_VAR 0 3
34316: PUSH
34317: LD_VAR 0 2
34321: MINUS
34322: ST_TO_ADDR
// end else
34323: GO 34386
// begin d := - 1 ;
34325: LD_ADDR_VAR 0 9
34329: PUSH
34330: LD_INT 1
34332: NEG
34333: ST_TO_ADDR
// if i_from > i_to then
34334: LD_VAR 0 2
34338: PUSH
34339: LD_VAR 0 3
34343: GREATER
34344: IFFALSE 34364
// length := i_from - i_to else
34346: LD_ADDR_VAR 0 11
34350: PUSH
34351: LD_VAR 0 2
34355: PUSH
34356: LD_VAR 0 3
34360: MINUS
34361: ST_TO_ADDR
34362: GO 34386
// length := ( array - i_to ) + i_from ;
34364: LD_ADDR_VAR 0 11
34368: PUSH
34369: LD_VAR 0 1
34373: PUSH
34374: LD_VAR 0 3
34378: MINUS
34379: PUSH
34380: LD_VAR 0 2
34384: PLUS
34385: ST_TO_ADDR
// end ; if not length then
34386: LD_VAR 0 11
34390: NOT
34391: IFFALSE 34395
// exit ;
34393: GO 34553
// tmp := array ;
34395: LD_ADDR_VAR 0 10
34399: PUSH
34400: LD_VAR 0 1
34404: ST_TO_ADDR
// for i = 1 to length do
34405: LD_ADDR_VAR 0 6
34409: PUSH
34410: DOUBLE
34411: LD_INT 1
34413: DEC
34414: ST_TO_ADDR
34415: LD_VAR 0 11
34419: PUSH
34420: FOR_TO
34421: IFFALSE 34541
// begin for j = 1 to array do
34423: LD_ADDR_VAR 0 7
34427: PUSH
34428: DOUBLE
34429: LD_INT 1
34431: DEC
34432: ST_TO_ADDR
34433: LD_VAR 0 1
34437: PUSH
34438: FOR_TO
34439: IFFALSE 34527
// begin k := j + d ;
34441: LD_ADDR_VAR 0 8
34445: PUSH
34446: LD_VAR 0 7
34450: PUSH
34451: LD_VAR 0 9
34455: PLUS
34456: ST_TO_ADDR
// if k > array then
34457: LD_VAR 0 8
34461: PUSH
34462: LD_VAR 0 1
34466: GREATER
34467: IFFALSE 34477
// k := 1 ;
34469: LD_ADDR_VAR 0 8
34473: PUSH
34474: LD_INT 1
34476: ST_TO_ADDR
// if not k then
34477: LD_VAR 0 8
34481: NOT
34482: IFFALSE 34494
// k := array ;
34484: LD_ADDR_VAR 0 8
34488: PUSH
34489: LD_VAR 0 1
34493: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
34494: LD_ADDR_VAR 0 10
34498: PUSH
34499: LD_VAR 0 10
34503: PPUSH
34504: LD_VAR 0 8
34508: PPUSH
34509: LD_VAR 0 1
34513: PUSH
34514: LD_VAR 0 7
34518: ARRAY
34519: PPUSH
34520: CALL_OW 1
34524: ST_TO_ADDR
// end ;
34525: GO 34438
34527: POP
34528: POP
// array := tmp ;
34529: LD_ADDR_VAR 0 1
34533: PUSH
34534: LD_VAR 0 10
34538: ST_TO_ADDR
// end ;
34539: GO 34420
34541: POP
34542: POP
// result := array ;
34543: LD_ADDR_VAR 0 5
34547: PUSH
34548: LD_VAR 0 1
34552: ST_TO_ADDR
// end ;
34553: LD_VAR 0 5
34557: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
34558: LD_INT 0
34560: PPUSH
34561: PPUSH
// result := 0 ;
34562: LD_ADDR_VAR 0 3
34566: PUSH
34567: LD_INT 0
34569: ST_TO_ADDR
// if not array or not value in array then
34570: LD_VAR 0 1
34574: NOT
34575: PUSH
34576: LD_VAR 0 2
34580: PUSH
34581: LD_VAR 0 1
34585: IN
34586: NOT
34587: OR
34588: IFFALSE 34592
// exit ;
34590: GO 34646
// for i = 1 to array do
34592: LD_ADDR_VAR 0 4
34596: PUSH
34597: DOUBLE
34598: LD_INT 1
34600: DEC
34601: ST_TO_ADDR
34602: LD_VAR 0 1
34606: PUSH
34607: FOR_TO
34608: IFFALSE 34644
// if value = array [ i ] then
34610: LD_VAR 0 2
34614: PUSH
34615: LD_VAR 0 1
34619: PUSH
34620: LD_VAR 0 4
34624: ARRAY
34625: EQUAL
34626: IFFALSE 34642
// begin result := i ;
34628: LD_ADDR_VAR 0 3
34632: PUSH
34633: LD_VAR 0 4
34637: ST_TO_ADDR
// exit ;
34638: POP
34639: POP
34640: GO 34646
// end ;
34642: GO 34607
34644: POP
34645: POP
// end ;
34646: LD_VAR 0 3
34650: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
34651: LD_INT 0
34653: PPUSH
// vc_chassis := chassis ;
34654: LD_ADDR_OWVAR 37
34658: PUSH
34659: LD_VAR 0 1
34663: ST_TO_ADDR
// vc_engine := engine ;
34664: LD_ADDR_OWVAR 39
34668: PUSH
34669: LD_VAR 0 2
34673: ST_TO_ADDR
// vc_control := control ;
34674: LD_ADDR_OWVAR 38
34678: PUSH
34679: LD_VAR 0 3
34683: ST_TO_ADDR
// vc_weapon := weapon ;
34684: LD_ADDR_OWVAR 40
34688: PUSH
34689: LD_VAR 0 4
34693: ST_TO_ADDR
// vc_fuel_battery := fuel ;
34694: LD_ADDR_OWVAR 41
34698: PUSH
34699: LD_VAR 0 5
34703: ST_TO_ADDR
// end ;
34704: LD_VAR 0 6
34708: RET
// export function WantPlant ( unit ) ; var task ; begin
34709: LD_INT 0
34711: PPUSH
34712: PPUSH
// result := false ;
34713: LD_ADDR_VAR 0 2
34717: PUSH
34718: LD_INT 0
34720: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
34721: LD_ADDR_VAR 0 3
34725: PUSH
34726: LD_VAR 0 1
34730: PPUSH
34731: CALL_OW 437
34735: ST_TO_ADDR
// if task then
34736: LD_VAR 0 3
34740: IFFALSE 34768
// if task [ 1 ] [ 1 ] = p then
34742: LD_VAR 0 3
34746: PUSH
34747: LD_INT 1
34749: ARRAY
34750: PUSH
34751: LD_INT 1
34753: ARRAY
34754: PUSH
34755: LD_STRING p
34757: EQUAL
34758: IFFALSE 34768
// result := true ;
34760: LD_ADDR_VAR 0 2
34764: PUSH
34765: LD_INT 1
34767: ST_TO_ADDR
// end ;
34768: LD_VAR 0 2
34772: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
34773: LD_INT 0
34775: PPUSH
34776: PPUSH
34777: PPUSH
34778: PPUSH
// if pos < 1 then
34779: LD_VAR 0 2
34783: PUSH
34784: LD_INT 1
34786: LESS
34787: IFFALSE 34791
// exit ;
34789: GO 35094
// if pos = 1 then
34791: LD_VAR 0 2
34795: PUSH
34796: LD_INT 1
34798: EQUAL
34799: IFFALSE 34832
// result := Replace ( arr , pos [ 1 ] , value ) else
34801: LD_ADDR_VAR 0 4
34805: PUSH
34806: LD_VAR 0 1
34810: PPUSH
34811: LD_VAR 0 2
34815: PUSH
34816: LD_INT 1
34818: ARRAY
34819: PPUSH
34820: LD_VAR 0 3
34824: PPUSH
34825: CALL_OW 1
34829: ST_TO_ADDR
34830: GO 35094
// begin tmp := arr ;
34832: LD_ADDR_VAR 0 6
34836: PUSH
34837: LD_VAR 0 1
34841: ST_TO_ADDR
// s_arr := [ tmp ] ;
34842: LD_ADDR_VAR 0 7
34846: PUSH
34847: LD_VAR 0 6
34851: PUSH
34852: EMPTY
34853: LIST
34854: ST_TO_ADDR
// for i = 1 to pos - 1 do
34855: LD_ADDR_VAR 0 5
34859: PUSH
34860: DOUBLE
34861: LD_INT 1
34863: DEC
34864: ST_TO_ADDR
34865: LD_VAR 0 2
34869: PUSH
34870: LD_INT 1
34872: MINUS
34873: PUSH
34874: FOR_TO
34875: IFFALSE 34920
// begin tmp := tmp [ pos [ i ] ] ;
34877: LD_ADDR_VAR 0 6
34881: PUSH
34882: LD_VAR 0 6
34886: PUSH
34887: LD_VAR 0 2
34891: PUSH
34892: LD_VAR 0 5
34896: ARRAY
34897: ARRAY
34898: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
34899: LD_ADDR_VAR 0 7
34903: PUSH
34904: LD_VAR 0 7
34908: PUSH
34909: LD_VAR 0 6
34913: PUSH
34914: EMPTY
34915: LIST
34916: ADD
34917: ST_TO_ADDR
// end ;
34918: GO 34874
34920: POP
34921: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
34922: LD_ADDR_VAR 0 6
34926: PUSH
34927: LD_VAR 0 6
34931: PPUSH
34932: LD_VAR 0 2
34936: PUSH
34937: LD_VAR 0 2
34941: ARRAY
34942: PPUSH
34943: LD_VAR 0 3
34947: PPUSH
34948: CALL_OW 1
34952: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
34953: LD_ADDR_VAR 0 7
34957: PUSH
34958: LD_VAR 0 7
34962: PPUSH
34963: LD_VAR 0 7
34967: PPUSH
34968: LD_VAR 0 6
34972: PPUSH
34973: CALL_OW 1
34977: ST_TO_ADDR
// for i = s_arr downto 2 do
34978: LD_ADDR_VAR 0 5
34982: PUSH
34983: DOUBLE
34984: LD_VAR 0 7
34988: INC
34989: ST_TO_ADDR
34990: LD_INT 2
34992: PUSH
34993: FOR_DOWNTO
34994: IFFALSE 35078
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
34996: LD_ADDR_VAR 0 6
35000: PUSH
35001: LD_VAR 0 7
35005: PUSH
35006: LD_VAR 0 5
35010: PUSH
35011: LD_INT 1
35013: MINUS
35014: ARRAY
35015: PPUSH
35016: LD_VAR 0 2
35020: PUSH
35021: LD_VAR 0 5
35025: PUSH
35026: LD_INT 1
35028: MINUS
35029: ARRAY
35030: PPUSH
35031: LD_VAR 0 7
35035: PUSH
35036: LD_VAR 0 5
35040: ARRAY
35041: PPUSH
35042: CALL_OW 1
35046: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
35047: LD_ADDR_VAR 0 7
35051: PUSH
35052: LD_VAR 0 7
35056: PPUSH
35057: LD_VAR 0 5
35061: PUSH
35062: LD_INT 1
35064: MINUS
35065: PPUSH
35066: LD_VAR 0 6
35070: PPUSH
35071: CALL_OW 1
35075: ST_TO_ADDR
// end ;
35076: GO 34993
35078: POP
35079: POP
// result := s_arr [ 1 ] ;
35080: LD_ADDR_VAR 0 4
35084: PUSH
35085: LD_VAR 0 7
35089: PUSH
35090: LD_INT 1
35092: ARRAY
35093: ST_TO_ADDR
// end ; end ;
35094: LD_VAR 0 4
35098: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
35099: LD_INT 0
35101: PPUSH
35102: PPUSH
// if not list then
35103: LD_VAR 0 1
35107: NOT
35108: IFFALSE 35112
// exit ;
35110: GO 35203
// i := list [ pos1 ] ;
35112: LD_ADDR_VAR 0 5
35116: PUSH
35117: LD_VAR 0 1
35121: PUSH
35122: LD_VAR 0 2
35126: ARRAY
35127: ST_TO_ADDR
// if not i then
35128: LD_VAR 0 5
35132: NOT
35133: IFFALSE 35137
// exit ;
35135: GO 35203
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
35137: LD_ADDR_VAR 0 1
35141: PUSH
35142: LD_VAR 0 1
35146: PPUSH
35147: LD_VAR 0 2
35151: PPUSH
35152: LD_VAR 0 1
35156: PUSH
35157: LD_VAR 0 3
35161: ARRAY
35162: PPUSH
35163: CALL_OW 1
35167: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
35168: LD_ADDR_VAR 0 1
35172: PUSH
35173: LD_VAR 0 1
35177: PPUSH
35178: LD_VAR 0 3
35182: PPUSH
35183: LD_VAR 0 5
35187: PPUSH
35188: CALL_OW 1
35192: ST_TO_ADDR
// result := list ;
35193: LD_ADDR_VAR 0 4
35197: PUSH
35198: LD_VAR 0 1
35202: ST_TO_ADDR
// end ;
35203: LD_VAR 0 4
35207: RET
// export function Add ( list , pos , val ) ; begin
35208: LD_INT 0
35210: PPUSH
// result := ReplaceIn ( list , pos , val ) end ;
35211: LD_ADDR_VAR 0 4
35215: PUSH
35216: LD_VAR 0 1
35220: PPUSH
35221: LD_VAR 0 2
35225: PPUSH
35226: LD_VAR 0 3
35230: PPUSH
35231: CALL 34773 0 3
35235: ST_TO_ADDR
35236: LD_VAR 0 4
35240: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
35241: LD_INT 0
35243: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
35244: LD_ADDR_VAR 0 5
35248: PUSH
35249: LD_VAR 0 1
35253: PPUSH
35254: CALL_OW 250
35258: PPUSH
35259: LD_VAR 0 1
35263: PPUSH
35264: CALL_OW 251
35268: PPUSH
35269: LD_VAR 0 2
35273: PPUSH
35274: LD_VAR 0 3
35278: PPUSH
35279: LD_VAR 0 4
35283: PPUSH
35284: CALL 35294 0 5
35288: ST_TO_ADDR
// end ;
35289: LD_VAR 0 5
35293: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
35294: LD_INT 0
35296: PPUSH
35297: PPUSH
35298: PPUSH
35299: PPUSH
// if not list then
35300: LD_VAR 0 3
35304: NOT
35305: IFFALSE 35309
// exit ;
35307: GO 35697
// result := [ ] ;
35309: LD_ADDR_VAR 0 6
35313: PUSH
35314: EMPTY
35315: ST_TO_ADDR
// for i in list do
35316: LD_ADDR_VAR 0 7
35320: PUSH
35321: LD_VAR 0 3
35325: PUSH
35326: FOR_IN
35327: IFFALSE 35529
// begin tmp := GetDistUnitXY ( i , x , y ) ;
35329: LD_ADDR_VAR 0 9
35333: PUSH
35334: LD_VAR 0 7
35338: PPUSH
35339: LD_VAR 0 1
35343: PPUSH
35344: LD_VAR 0 2
35348: PPUSH
35349: CALL_OW 297
35353: ST_TO_ADDR
// if not result then
35354: LD_VAR 0 6
35358: NOT
35359: IFFALSE 35385
// result := [ [ i , tmp ] ] else
35361: LD_ADDR_VAR 0 6
35365: PUSH
35366: LD_VAR 0 7
35370: PUSH
35371: LD_VAR 0 9
35375: PUSH
35376: EMPTY
35377: LIST
35378: LIST
35379: PUSH
35380: EMPTY
35381: LIST
35382: ST_TO_ADDR
35383: GO 35527
// begin if result [ result ] [ 2 ] < tmp then
35385: LD_VAR 0 6
35389: PUSH
35390: LD_VAR 0 6
35394: ARRAY
35395: PUSH
35396: LD_INT 2
35398: ARRAY
35399: PUSH
35400: LD_VAR 0 9
35404: LESS
35405: IFFALSE 35447
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
35407: LD_ADDR_VAR 0 6
35411: PUSH
35412: LD_VAR 0 6
35416: PPUSH
35417: LD_VAR 0 6
35421: PUSH
35422: LD_INT 1
35424: PLUS
35425: PPUSH
35426: LD_VAR 0 7
35430: PUSH
35431: LD_VAR 0 9
35435: PUSH
35436: EMPTY
35437: LIST
35438: LIST
35439: PPUSH
35440: CALL_OW 2
35444: ST_TO_ADDR
35445: GO 35527
// for j = 1 to result do
35447: LD_ADDR_VAR 0 8
35451: PUSH
35452: DOUBLE
35453: LD_INT 1
35455: DEC
35456: ST_TO_ADDR
35457: LD_VAR 0 6
35461: PUSH
35462: FOR_TO
35463: IFFALSE 35525
// begin if tmp < result [ j ] [ 2 ] then
35465: LD_VAR 0 9
35469: PUSH
35470: LD_VAR 0 6
35474: PUSH
35475: LD_VAR 0 8
35479: ARRAY
35480: PUSH
35481: LD_INT 2
35483: ARRAY
35484: LESS
35485: IFFALSE 35523
// begin result := Insert ( result , j , [ i , tmp ] ) ;
35487: LD_ADDR_VAR 0 6
35491: PUSH
35492: LD_VAR 0 6
35496: PPUSH
35497: LD_VAR 0 8
35501: PPUSH
35502: LD_VAR 0 7
35506: PUSH
35507: LD_VAR 0 9
35511: PUSH
35512: EMPTY
35513: LIST
35514: LIST
35515: PPUSH
35516: CALL_OW 2
35520: ST_TO_ADDR
// break ;
35521: GO 35525
// end ; end ;
35523: GO 35462
35525: POP
35526: POP
// end ; end ;
35527: GO 35326
35529: POP
35530: POP
// if result and not asc then
35531: LD_VAR 0 6
35535: PUSH
35536: LD_VAR 0 4
35540: NOT
35541: AND
35542: IFFALSE 35617
// begin tmp := result ;
35544: LD_ADDR_VAR 0 9
35548: PUSH
35549: LD_VAR 0 6
35553: ST_TO_ADDR
// for i = tmp downto 1 do
35554: LD_ADDR_VAR 0 7
35558: PUSH
35559: DOUBLE
35560: LD_VAR 0 9
35564: INC
35565: ST_TO_ADDR
35566: LD_INT 1
35568: PUSH
35569: FOR_DOWNTO
35570: IFFALSE 35615
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
35572: LD_ADDR_VAR 0 6
35576: PUSH
35577: LD_VAR 0 6
35581: PPUSH
35582: LD_VAR 0 9
35586: PUSH
35587: LD_VAR 0 7
35591: MINUS
35592: PUSH
35593: LD_INT 1
35595: PLUS
35596: PPUSH
35597: LD_VAR 0 9
35601: PUSH
35602: LD_VAR 0 7
35606: ARRAY
35607: PPUSH
35608: CALL_OW 1
35612: ST_TO_ADDR
35613: GO 35569
35615: POP
35616: POP
// end ; tmp := [ ] ;
35617: LD_ADDR_VAR 0 9
35621: PUSH
35622: EMPTY
35623: ST_TO_ADDR
// if mode then
35624: LD_VAR 0 5
35628: IFFALSE 35697
// begin for i = 1 to result do
35630: LD_ADDR_VAR 0 7
35634: PUSH
35635: DOUBLE
35636: LD_INT 1
35638: DEC
35639: ST_TO_ADDR
35640: LD_VAR 0 6
35644: PUSH
35645: FOR_TO
35646: IFFALSE 35685
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
35648: LD_ADDR_VAR 0 9
35652: PUSH
35653: LD_VAR 0 9
35657: PPUSH
35658: LD_VAR 0 7
35662: PPUSH
35663: LD_VAR 0 6
35667: PUSH
35668: LD_VAR 0 7
35672: ARRAY
35673: PUSH
35674: LD_INT 1
35676: ARRAY
35677: PPUSH
35678: CALL_OW 1
35682: ST_TO_ADDR
35683: GO 35645
35685: POP
35686: POP
// result := tmp ;
35687: LD_ADDR_VAR 0 6
35691: PUSH
35692: LD_VAR 0 9
35696: ST_TO_ADDR
// end ; end ;
35697: LD_VAR 0 6
35701: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
35702: LD_INT 0
35704: PPUSH
35705: PPUSH
35706: PPUSH
35707: PPUSH
35708: PPUSH
35709: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
35710: LD_ADDR_VAR 0 5
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: LD_INT 0
35720: PUSH
35721: LD_INT 0
35723: PUSH
35724: EMPTY
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: ST_TO_ADDR
// if not x or not y then
35732: LD_VAR 0 2
35736: NOT
35737: PUSH
35738: LD_VAR 0 3
35742: NOT
35743: OR
35744: IFFALSE 35748
// exit ;
35746: GO 37394
// if not range then
35748: LD_VAR 0 4
35752: NOT
35753: IFFALSE 35763
// range := 10 ;
35755: LD_ADDR_VAR 0 4
35759: PUSH
35760: LD_INT 10
35762: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
35763: LD_ADDR_VAR 0 8
35767: PUSH
35768: LD_INT 81
35770: PUSH
35771: LD_VAR 0 1
35775: PUSH
35776: EMPTY
35777: LIST
35778: LIST
35779: PUSH
35780: LD_INT 92
35782: PUSH
35783: LD_VAR 0 2
35787: PUSH
35788: LD_VAR 0 3
35792: PUSH
35793: LD_VAR 0 4
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: PUSH
35804: LD_INT 3
35806: PUSH
35807: LD_INT 21
35809: PUSH
35810: LD_INT 3
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: LIST
35825: PPUSH
35826: CALL_OW 69
35830: ST_TO_ADDR
// if not tmp then
35831: LD_VAR 0 8
35835: NOT
35836: IFFALSE 35840
// exit ;
35838: GO 37394
// for i in tmp do
35840: LD_ADDR_VAR 0 6
35844: PUSH
35845: LD_VAR 0 8
35849: PUSH
35850: FOR_IN
35851: IFFALSE 37369
// begin points := [ 0 , 0 , 0 ] ;
35853: LD_ADDR_VAR 0 9
35857: PUSH
35858: LD_INT 0
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: LIST
35871: ST_TO_ADDR
// bpoints := 1 ;
35872: LD_ADDR_VAR 0 10
35876: PUSH
35877: LD_INT 1
35879: ST_TO_ADDR
// case GetType ( i ) of unit_human :
35880: LD_VAR 0 6
35884: PPUSH
35885: CALL_OW 247
35889: PUSH
35890: LD_INT 1
35892: DOUBLE
35893: EQUAL
35894: IFTRUE 35898
35896: GO 36476
35898: POP
// begin if GetClass ( i ) = 1 then
35899: LD_VAR 0 6
35903: PPUSH
35904: CALL_OW 257
35908: PUSH
35909: LD_INT 1
35911: EQUAL
35912: IFFALSE 35933
// points := [ 10 , 5 , 3 ] ;
35914: LD_ADDR_VAR 0 9
35918: PUSH
35919: LD_INT 10
35921: PUSH
35922: LD_INT 5
35924: PUSH
35925: LD_INT 3
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: LIST
35932: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
35933: LD_VAR 0 6
35937: PPUSH
35938: CALL_OW 257
35942: PUSH
35943: LD_INT 2
35945: PUSH
35946: LD_INT 3
35948: PUSH
35949: LD_INT 4
35951: PUSH
35952: EMPTY
35953: LIST
35954: LIST
35955: LIST
35956: IN
35957: IFFALSE 35978
// points := [ 3 , 2 , 1 ] ;
35959: LD_ADDR_VAR 0 9
35963: PUSH
35964: LD_INT 3
35966: PUSH
35967: LD_INT 2
35969: PUSH
35970: LD_INT 1
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: LIST
35977: ST_TO_ADDR
// if GetClass ( i ) = 5 then
35978: LD_VAR 0 6
35982: PPUSH
35983: CALL_OW 257
35987: PUSH
35988: LD_INT 5
35990: EQUAL
35991: IFFALSE 36012
// points := [ 130 , 5 , 2 ] ;
35993: LD_ADDR_VAR 0 9
35997: PUSH
35998: LD_INT 130
36000: PUSH
36001: LD_INT 5
36003: PUSH
36004: LD_INT 2
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: LIST
36011: ST_TO_ADDR
// if GetClass ( i ) = 8 then
36012: LD_VAR 0 6
36016: PPUSH
36017: CALL_OW 257
36021: PUSH
36022: LD_INT 8
36024: EQUAL
36025: IFFALSE 36046
// points := [ 35 , 35 , 30 ] ;
36027: LD_ADDR_VAR 0 9
36031: PUSH
36032: LD_INT 35
36034: PUSH
36035: LD_INT 35
36037: PUSH
36038: LD_INT 30
36040: PUSH
36041: EMPTY
36042: LIST
36043: LIST
36044: LIST
36045: ST_TO_ADDR
// if GetClass ( i ) = 9 then
36046: LD_VAR 0 6
36050: PPUSH
36051: CALL_OW 257
36055: PUSH
36056: LD_INT 9
36058: EQUAL
36059: IFFALSE 36080
// points := [ 20 , 55 , 40 ] ;
36061: LD_ADDR_VAR 0 9
36065: PUSH
36066: LD_INT 20
36068: PUSH
36069: LD_INT 55
36071: PUSH
36072: LD_INT 40
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: LIST
36079: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
36080: LD_VAR 0 6
36084: PPUSH
36085: CALL_OW 257
36089: PUSH
36090: LD_INT 12
36092: PUSH
36093: LD_INT 16
36095: PUSH
36096: EMPTY
36097: LIST
36098: LIST
36099: IN
36100: IFFALSE 36121
// points := [ 5 , 3 , 2 ] ;
36102: LD_ADDR_VAR 0 9
36106: PUSH
36107: LD_INT 5
36109: PUSH
36110: LD_INT 3
36112: PUSH
36113: LD_INT 2
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: LIST
36120: ST_TO_ADDR
// if GetClass ( i ) = 17 then
36121: LD_VAR 0 6
36125: PPUSH
36126: CALL_OW 257
36130: PUSH
36131: LD_INT 17
36133: EQUAL
36134: IFFALSE 36155
// points := [ 100 , 50 , 75 ] ;
36136: LD_ADDR_VAR 0 9
36140: PUSH
36141: LD_INT 100
36143: PUSH
36144: LD_INT 50
36146: PUSH
36147: LD_INT 75
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: LIST
36154: ST_TO_ADDR
// if GetClass ( i ) = 15 then
36155: LD_VAR 0 6
36159: PPUSH
36160: CALL_OW 257
36164: PUSH
36165: LD_INT 15
36167: EQUAL
36168: IFFALSE 36189
// points := [ 10 , 5 , 3 ] ;
36170: LD_ADDR_VAR 0 9
36174: PUSH
36175: LD_INT 10
36177: PUSH
36178: LD_INT 5
36180: PUSH
36181: LD_INT 3
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: LIST
36188: ST_TO_ADDR
// if GetClass ( i ) = 14 then
36189: LD_VAR 0 6
36193: PPUSH
36194: CALL_OW 257
36198: PUSH
36199: LD_INT 14
36201: EQUAL
36202: IFFALSE 36223
// points := [ 10 , 0 , 0 ] ;
36204: LD_ADDR_VAR 0 9
36208: PUSH
36209: LD_INT 10
36211: PUSH
36212: LD_INT 0
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: LIST
36222: ST_TO_ADDR
// if GetClass ( i ) = 11 then
36223: LD_VAR 0 6
36227: PPUSH
36228: CALL_OW 257
36232: PUSH
36233: LD_INT 11
36235: EQUAL
36236: IFFALSE 36257
// points := [ 30 , 10 , 5 ] ;
36238: LD_ADDR_VAR 0 9
36242: PUSH
36243: LD_INT 30
36245: PUSH
36246: LD_INT 10
36248: PUSH
36249: LD_INT 5
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: LIST
36256: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
36257: LD_VAR 0 1
36261: PPUSH
36262: LD_INT 5
36264: PPUSH
36265: CALL_OW 321
36269: PUSH
36270: LD_INT 2
36272: EQUAL
36273: IFFALSE 36290
// bpoints := bpoints * 1.8 ;
36275: LD_ADDR_VAR 0 10
36279: PUSH
36280: LD_VAR 0 10
36284: PUSH
36285: LD_REAL  1.80000000000000E+0000
36288: MUL
36289: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
36290: LD_VAR 0 6
36294: PPUSH
36295: CALL_OW 257
36299: PUSH
36300: LD_INT 1
36302: PUSH
36303: LD_INT 2
36305: PUSH
36306: LD_INT 3
36308: PUSH
36309: LD_INT 4
36311: PUSH
36312: EMPTY
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: IN
36318: PUSH
36319: LD_VAR 0 1
36323: PPUSH
36324: LD_INT 51
36326: PPUSH
36327: CALL_OW 321
36331: PUSH
36332: LD_INT 2
36334: EQUAL
36335: AND
36336: IFFALSE 36353
// bpoints := bpoints * 1.2 ;
36338: LD_ADDR_VAR 0 10
36342: PUSH
36343: LD_VAR 0 10
36347: PUSH
36348: LD_REAL  1.20000000000000E+0000
36351: MUL
36352: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
36353: LD_VAR 0 6
36357: PPUSH
36358: CALL_OW 257
36362: PUSH
36363: LD_INT 5
36365: PUSH
36366: LD_INT 7
36368: PUSH
36369: LD_INT 9
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: IN
36377: PUSH
36378: LD_VAR 0 1
36382: PPUSH
36383: LD_INT 52
36385: PPUSH
36386: CALL_OW 321
36390: PUSH
36391: LD_INT 2
36393: EQUAL
36394: AND
36395: IFFALSE 36412
// bpoints := bpoints * 1.5 ;
36397: LD_ADDR_VAR 0 10
36401: PUSH
36402: LD_VAR 0 10
36406: PUSH
36407: LD_REAL  1.50000000000000E+0000
36410: MUL
36411: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
36412: LD_VAR 0 1
36416: PPUSH
36417: LD_INT 66
36419: PPUSH
36420: CALL_OW 321
36424: PUSH
36425: LD_INT 2
36427: EQUAL
36428: IFFALSE 36445
// bpoints := bpoints * 1.1 ;
36430: LD_ADDR_VAR 0 10
36434: PUSH
36435: LD_VAR 0 10
36439: PUSH
36440: LD_REAL  1.10000000000000E+0000
36443: MUL
36444: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
36445: LD_ADDR_VAR 0 10
36449: PUSH
36450: LD_VAR 0 10
36454: PUSH
36455: LD_VAR 0 6
36459: PPUSH
36460: LD_INT 1
36462: PPUSH
36463: CALL_OW 259
36467: PUSH
36468: LD_REAL  1.15000000000000E+0000
36471: MUL
36472: MUL
36473: ST_TO_ADDR
// end ; unit_vehicle :
36474: GO 37298
36476: LD_INT 2
36478: DOUBLE
36479: EQUAL
36480: IFTRUE 36484
36482: GO 37286
36484: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
36485: LD_VAR 0 6
36489: PPUSH
36490: CALL_OW 264
36494: PUSH
36495: LD_INT 2
36497: PUSH
36498: LD_INT 42
36500: PUSH
36501: LD_INT 24
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: LIST
36508: IN
36509: IFFALSE 36530
// points := [ 25 , 5 , 3 ] ;
36511: LD_ADDR_VAR 0 9
36515: PUSH
36516: LD_INT 25
36518: PUSH
36519: LD_INT 5
36521: PUSH
36522: LD_INT 3
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: LIST
36529: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
36530: LD_VAR 0 6
36534: PPUSH
36535: CALL_OW 264
36539: PUSH
36540: LD_INT 4
36542: PUSH
36543: LD_INT 43
36545: PUSH
36546: LD_INT 25
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: LIST
36553: IN
36554: IFFALSE 36575
// points := [ 40 , 15 , 5 ] ;
36556: LD_ADDR_VAR 0 9
36560: PUSH
36561: LD_INT 40
36563: PUSH
36564: LD_INT 15
36566: PUSH
36567: LD_INT 5
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: LIST
36574: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
36575: LD_VAR 0 6
36579: PPUSH
36580: CALL_OW 264
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: LD_INT 23
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: IN
36595: IFFALSE 36616
// points := [ 7 , 25 , 8 ] ;
36597: LD_ADDR_VAR 0 9
36601: PUSH
36602: LD_INT 7
36604: PUSH
36605: LD_INT 25
36607: PUSH
36608: LD_INT 8
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: LIST
36615: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
36616: LD_VAR 0 6
36620: PPUSH
36621: CALL_OW 264
36625: PUSH
36626: LD_INT 5
36628: PUSH
36629: LD_INT 27
36631: PUSH
36632: LD_INT 44
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: LIST
36639: IN
36640: IFFALSE 36661
// points := [ 14 , 50 , 16 ] ;
36642: LD_ADDR_VAR 0 9
36646: PUSH
36647: LD_INT 14
36649: PUSH
36650: LD_INT 50
36652: PUSH
36653: LD_INT 16
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: LIST
36660: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
36661: LD_VAR 0 6
36665: PPUSH
36666: CALL_OW 264
36670: PUSH
36671: LD_INT 6
36673: PUSH
36674: LD_INT 46
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: IN
36681: IFFALSE 36702
// points := [ 32 , 120 , 70 ] ;
36683: LD_ADDR_VAR 0 9
36687: PUSH
36688: LD_INT 32
36690: PUSH
36691: LD_INT 120
36693: PUSH
36694: LD_INT 70
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: LIST
36701: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
36702: LD_VAR 0 6
36706: PPUSH
36707: CALL_OW 264
36711: PUSH
36712: LD_INT 7
36714: PUSH
36715: LD_INT 28
36717: PUSH
36718: LD_INT 45
36720: PUSH
36721: EMPTY
36722: LIST
36723: LIST
36724: LIST
36725: IN
36726: IFFALSE 36747
// points := [ 35 , 20 , 45 ] ;
36728: LD_ADDR_VAR 0 9
36732: PUSH
36733: LD_INT 35
36735: PUSH
36736: LD_INT 20
36738: PUSH
36739: LD_INT 45
36741: PUSH
36742: EMPTY
36743: LIST
36744: LIST
36745: LIST
36746: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
36747: LD_VAR 0 6
36751: PPUSH
36752: CALL_OW 264
36756: PUSH
36757: LD_INT 47
36759: PUSH
36760: EMPTY
36761: LIST
36762: IN
36763: IFFALSE 36784
// points := [ 67 , 45 , 75 ] ;
36765: LD_ADDR_VAR 0 9
36769: PUSH
36770: LD_INT 67
36772: PUSH
36773: LD_INT 45
36775: PUSH
36776: LD_INT 75
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: LIST
36783: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
36784: LD_VAR 0 6
36788: PPUSH
36789: CALL_OW 264
36793: PUSH
36794: LD_INT 26
36796: PUSH
36797: EMPTY
36798: LIST
36799: IN
36800: IFFALSE 36821
// points := [ 120 , 30 , 80 ] ;
36802: LD_ADDR_VAR 0 9
36806: PUSH
36807: LD_INT 120
36809: PUSH
36810: LD_INT 30
36812: PUSH
36813: LD_INT 80
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: LIST
36820: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
36821: LD_VAR 0 6
36825: PPUSH
36826: CALL_OW 264
36830: PUSH
36831: LD_INT 22
36833: PUSH
36834: EMPTY
36835: LIST
36836: IN
36837: IFFALSE 36858
// points := [ 40 , 1 , 1 ] ;
36839: LD_ADDR_VAR 0 9
36843: PUSH
36844: LD_INT 40
36846: PUSH
36847: LD_INT 1
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: LIST
36857: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
36858: LD_VAR 0 6
36862: PPUSH
36863: CALL_OW 264
36867: PUSH
36868: LD_INT 29
36870: PUSH
36871: EMPTY
36872: LIST
36873: IN
36874: IFFALSE 36895
// points := [ 70 , 200 , 400 ] ;
36876: LD_ADDR_VAR 0 9
36880: PUSH
36881: LD_INT 70
36883: PUSH
36884: LD_INT 200
36886: PUSH
36887: LD_INT 400
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: LIST
36894: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
36895: LD_VAR 0 6
36899: PPUSH
36900: CALL_OW 264
36904: PUSH
36905: LD_INT 14
36907: PUSH
36908: LD_INT 53
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: IN
36915: IFFALSE 36936
// points := [ 40 , 10 , 20 ] ;
36917: LD_ADDR_VAR 0 9
36921: PUSH
36922: LD_INT 40
36924: PUSH
36925: LD_INT 10
36927: PUSH
36928: LD_INT 20
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: LIST
36935: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
36936: LD_VAR 0 6
36940: PPUSH
36941: CALL_OW 264
36945: PUSH
36946: LD_INT 9
36948: PUSH
36949: EMPTY
36950: LIST
36951: IN
36952: IFFALSE 36973
// points := [ 5 , 70 , 20 ] ;
36954: LD_ADDR_VAR 0 9
36958: PUSH
36959: LD_INT 5
36961: PUSH
36962: LD_INT 70
36964: PUSH
36965: LD_INT 20
36967: PUSH
36968: EMPTY
36969: LIST
36970: LIST
36971: LIST
36972: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
36973: LD_VAR 0 6
36977: PPUSH
36978: CALL_OW 264
36982: PUSH
36983: LD_INT 10
36985: PUSH
36986: EMPTY
36987: LIST
36988: IN
36989: IFFALSE 37010
// points := [ 35 , 110 , 70 ] ;
36991: LD_ADDR_VAR 0 9
36995: PUSH
36996: LD_INT 35
36998: PUSH
36999: LD_INT 110
37001: PUSH
37002: LD_INT 70
37004: PUSH
37005: EMPTY
37006: LIST
37007: LIST
37008: LIST
37009: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
37010: LD_VAR 0 6
37014: PPUSH
37015: CALL_OW 265
37019: PUSH
37020: LD_INT 25
37022: EQUAL
37023: IFFALSE 37044
// points := [ 80 , 65 , 100 ] ;
37025: LD_ADDR_VAR 0 9
37029: PUSH
37030: LD_INT 80
37032: PUSH
37033: LD_INT 65
37035: PUSH
37036: LD_INT 100
37038: PUSH
37039: EMPTY
37040: LIST
37041: LIST
37042: LIST
37043: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
37044: LD_VAR 0 6
37048: PPUSH
37049: CALL_OW 263
37053: PUSH
37054: LD_INT 1
37056: EQUAL
37057: IFFALSE 37092
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
37059: LD_ADDR_VAR 0 10
37063: PUSH
37064: LD_VAR 0 10
37068: PUSH
37069: LD_VAR 0 6
37073: PPUSH
37074: CALL_OW 311
37078: PPUSH
37079: LD_INT 3
37081: PPUSH
37082: CALL_OW 259
37086: PUSH
37087: LD_INT 4
37089: MUL
37090: MUL
37091: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
37092: LD_VAR 0 6
37096: PPUSH
37097: CALL_OW 263
37101: PUSH
37102: LD_INT 2
37104: EQUAL
37105: IFFALSE 37156
// begin j := IsControledBy ( i ) ;
37107: LD_ADDR_VAR 0 7
37111: PUSH
37112: LD_VAR 0 6
37116: PPUSH
37117: CALL_OW 312
37121: ST_TO_ADDR
// if j then
37122: LD_VAR 0 7
37126: IFFALSE 37156
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
37128: LD_ADDR_VAR 0 10
37132: PUSH
37133: LD_VAR 0 10
37137: PUSH
37138: LD_VAR 0 7
37142: PPUSH
37143: LD_INT 3
37145: PPUSH
37146: CALL_OW 259
37150: PUSH
37151: LD_INT 3
37153: MUL
37154: MUL
37155: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
37156: LD_VAR 0 6
37160: PPUSH
37161: CALL_OW 264
37165: PUSH
37166: LD_INT 5
37168: PUSH
37169: LD_INT 6
37171: PUSH
37172: LD_INT 46
37174: PUSH
37175: LD_INT 44
37177: PUSH
37178: LD_INT 47
37180: PUSH
37181: LD_INT 45
37183: PUSH
37184: LD_INT 28
37186: PUSH
37187: LD_INT 7
37189: PUSH
37190: LD_INT 27
37192: PUSH
37193: LD_INT 29
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: LIST
37200: LIST
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: IN
37208: PUSH
37209: LD_VAR 0 1
37213: PPUSH
37214: LD_INT 52
37216: PPUSH
37217: CALL_OW 321
37221: PUSH
37222: LD_INT 2
37224: EQUAL
37225: AND
37226: IFFALSE 37243
// bpoints := bpoints * 1.2 ;
37228: LD_ADDR_VAR 0 10
37232: PUSH
37233: LD_VAR 0 10
37237: PUSH
37238: LD_REAL  1.20000000000000E+0000
37241: MUL
37242: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
37243: LD_VAR 0 6
37247: PPUSH
37248: CALL_OW 264
37252: PUSH
37253: LD_INT 6
37255: PUSH
37256: LD_INT 46
37258: PUSH
37259: LD_INT 47
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: LIST
37266: IN
37267: IFFALSE 37284
// bpoints := bpoints * 1.2 ;
37269: LD_ADDR_VAR 0 10
37273: PUSH
37274: LD_VAR 0 10
37278: PUSH
37279: LD_REAL  1.20000000000000E+0000
37282: MUL
37283: ST_TO_ADDR
// end ; unit_building :
37284: GO 37298
37286: LD_INT 3
37288: DOUBLE
37289: EQUAL
37290: IFTRUE 37294
37292: GO 37297
37294: POP
// ; end ;
37295: GO 37298
37297: POP
// for j = 1 to 3 do
37298: LD_ADDR_VAR 0 7
37302: PUSH
37303: DOUBLE
37304: LD_INT 1
37306: DEC
37307: ST_TO_ADDR
37308: LD_INT 3
37310: PUSH
37311: FOR_TO
37312: IFFALSE 37365
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
37314: LD_ADDR_VAR 0 5
37318: PUSH
37319: LD_VAR 0 5
37323: PPUSH
37324: LD_VAR 0 7
37328: PPUSH
37329: LD_VAR 0 5
37333: PUSH
37334: LD_VAR 0 7
37338: ARRAY
37339: PUSH
37340: LD_VAR 0 9
37344: PUSH
37345: LD_VAR 0 7
37349: ARRAY
37350: PUSH
37351: LD_VAR 0 10
37355: MUL
37356: PLUS
37357: PPUSH
37358: CALL_OW 1
37362: ST_TO_ADDR
37363: GO 37311
37365: POP
37366: POP
// end ;
37367: GO 35850
37369: POP
37370: POP
// result := Replace ( result , 4 , tmp ) ;
37371: LD_ADDR_VAR 0 5
37375: PUSH
37376: LD_VAR 0 5
37380: PPUSH
37381: LD_INT 4
37383: PPUSH
37384: LD_VAR 0 8
37388: PPUSH
37389: CALL_OW 1
37393: ST_TO_ADDR
// end ;
37394: LD_VAR 0 5
37398: RET
// export function DangerAtRange ( unit , range ) ; begin
37399: LD_INT 0
37401: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
37402: LD_ADDR_VAR 0 3
37406: PUSH
37407: LD_VAR 0 1
37411: PPUSH
37412: CALL_OW 255
37416: PPUSH
37417: LD_VAR 0 1
37421: PPUSH
37422: CALL_OW 250
37426: PPUSH
37427: LD_VAR 0 1
37431: PPUSH
37432: CALL_OW 251
37436: PPUSH
37437: LD_VAR 0 2
37441: PPUSH
37442: CALL 35702 0 4
37446: ST_TO_ADDR
// end ;
37447: LD_VAR 0 3
37451: RET
// export function DangerInArea ( side , area ) ; begin
37452: LD_INT 0
37454: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
37455: LD_ADDR_VAR 0 3
37459: PUSH
37460: LD_VAR 0 2
37464: PPUSH
37465: LD_INT 81
37467: PUSH
37468: LD_VAR 0 1
37472: PUSH
37473: EMPTY
37474: LIST
37475: LIST
37476: PPUSH
37477: CALL_OW 70
37481: ST_TO_ADDR
// end ;
37482: LD_VAR 0 3
37486: RET
// export function IsExtension ( b ) ; begin
37487: LD_INT 0
37489: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
37490: LD_ADDR_VAR 0 2
37494: PUSH
37495: LD_VAR 0 1
37499: PUSH
37500: LD_INT 23
37502: PUSH
37503: LD_INT 20
37505: PUSH
37506: LD_INT 22
37508: PUSH
37509: LD_INT 17
37511: PUSH
37512: LD_INT 24
37514: PUSH
37515: LD_INT 21
37517: PUSH
37518: LD_INT 19
37520: PUSH
37521: LD_INT 16
37523: PUSH
37524: LD_INT 25
37526: PUSH
37527: LD_INT 18
37529: PUSH
37530: EMPTY
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: IN
37542: ST_TO_ADDR
// end ;
37543: LD_VAR 0 2
37547: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
37548: LD_INT 0
37550: PPUSH
37551: PPUSH
37552: PPUSH
// result := [ ] ;
37553: LD_ADDR_VAR 0 3
37557: PUSH
37558: EMPTY
37559: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
37560: LD_ADDR_VAR 0 4
37564: PUSH
37565: LD_VAR 0 2
37569: PPUSH
37570: LD_INT 21
37572: PUSH
37573: LD_INT 3
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PPUSH
37580: CALL_OW 70
37584: ST_TO_ADDR
// if not tmp then
37585: LD_VAR 0 4
37589: NOT
37590: IFFALSE 37594
// exit ;
37592: GO 37652
// for i in tmp do
37594: LD_ADDR_VAR 0 5
37598: PUSH
37599: LD_VAR 0 4
37603: PUSH
37604: FOR_IN
37605: IFFALSE 37640
// if GetBase ( i ) <> base then
37607: LD_VAR 0 5
37611: PPUSH
37612: CALL_OW 274
37616: PUSH
37617: LD_VAR 0 1
37621: NONEQUAL
37622: IFFALSE 37638
// ComLinkToBase ( base , i ) ;
37624: LD_VAR 0 1
37628: PPUSH
37629: LD_VAR 0 5
37633: PPUSH
37634: CALL_OW 169
37638: GO 37604
37640: POP
37641: POP
// result := tmp ;
37642: LD_ADDR_VAR 0 3
37646: PUSH
37647: LD_VAR 0 4
37651: ST_TO_ADDR
// end ;
37652: LD_VAR 0 3
37656: RET
// export function ComComplete ( unit , b ) ; var i ; begin
37657: LD_INT 0
37659: PPUSH
37660: PPUSH
// if BuildingStatus ( b ) = bs_build then
37661: LD_VAR 0 2
37665: PPUSH
37666: CALL_OW 461
37670: PUSH
37671: LD_INT 1
37673: EQUAL
37674: IFFALSE 37734
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
37676: LD_VAR 0 1
37680: PPUSH
37681: LD_STRING h
37683: PUSH
37684: LD_VAR 0 2
37688: PPUSH
37689: CALL_OW 250
37693: PUSH
37694: LD_VAR 0 2
37698: PPUSH
37699: CALL_OW 251
37703: PUSH
37704: LD_VAR 0 2
37708: PUSH
37709: LD_INT 0
37711: PUSH
37712: LD_INT 0
37714: PUSH
37715: LD_INT 0
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: PUSH
37727: EMPTY
37728: LIST
37729: PPUSH
37730: CALL_OW 446
// end ;
37734: LD_VAR 0 3
37738: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
37739: LD_INT 0
37741: PPUSH
37742: PPUSH
37743: PPUSH
37744: PPUSH
37745: PPUSH
37746: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
37747: LD_VAR 0 1
37751: NOT
37752: PUSH
37753: LD_VAR 0 1
37757: PPUSH
37758: CALL_OW 263
37762: PUSH
37763: LD_INT 2
37765: EQUAL
37766: NOT
37767: OR
37768: IFFALSE 37772
// exit ;
37770: GO 38088
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
37772: LD_ADDR_VAR 0 6
37776: PUSH
37777: LD_INT 22
37779: PUSH
37780: LD_VAR 0 1
37784: PPUSH
37785: CALL_OW 255
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 2
37796: PUSH
37797: LD_INT 30
37799: PUSH
37800: LD_INT 36
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 34
37809: PUSH
37810: LD_INT 31
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: LIST
37821: PUSH
37822: EMPTY
37823: LIST
37824: LIST
37825: PPUSH
37826: CALL_OW 69
37830: ST_TO_ADDR
// if not tmp then
37831: LD_VAR 0 6
37835: NOT
37836: IFFALSE 37840
// exit ;
37838: GO 38088
// result := [ ] ;
37840: LD_ADDR_VAR 0 2
37844: PUSH
37845: EMPTY
37846: ST_TO_ADDR
// for i in tmp do
37847: LD_ADDR_VAR 0 3
37851: PUSH
37852: LD_VAR 0 6
37856: PUSH
37857: FOR_IN
37858: IFFALSE 37929
// begin t := UnitsInside ( i ) ;
37860: LD_ADDR_VAR 0 4
37864: PUSH
37865: LD_VAR 0 3
37869: PPUSH
37870: CALL_OW 313
37874: ST_TO_ADDR
// if t then
37875: LD_VAR 0 4
37879: IFFALSE 37927
// for j in t do
37881: LD_ADDR_VAR 0 7
37885: PUSH
37886: LD_VAR 0 4
37890: PUSH
37891: FOR_IN
37892: IFFALSE 37925
// result := Insert ( result , result + 1 , j ) ;
37894: LD_ADDR_VAR 0 2
37898: PUSH
37899: LD_VAR 0 2
37903: PPUSH
37904: LD_VAR 0 2
37908: PUSH
37909: LD_INT 1
37911: PLUS
37912: PPUSH
37913: LD_VAR 0 7
37917: PPUSH
37918: CALL_OW 2
37922: ST_TO_ADDR
37923: GO 37891
37925: POP
37926: POP
// end ;
37927: GO 37857
37929: POP
37930: POP
// if not result then
37931: LD_VAR 0 2
37935: NOT
37936: IFFALSE 37940
// exit ;
37938: GO 38088
// mech := result [ 1 ] ;
37940: LD_ADDR_VAR 0 5
37944: PUSH
37945: LD_VAR 0 2
37949: PUSH
37950: LD_INT 1
37952: ARRAY
37953: ST_TO_ADDR
// if result > 1 then
37954: LD_VAR 0 2
37958: PUSH
37959: LD_INT 1
37961: GREATER
37962: IFFALSE 38074
// for i = 2 to result do
37964: LD_ADDR_VAR 0 3
37968: PUSH
37969: DOUBLE
37970: LD_INT 2
37972: DEC
37973: ST_TO_ADDR
37974: LD_VAR 0 2
37978: PUSH
37979: FOR_TO
37980: IFFALSE 38072
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
37982: LD_ADDR_VAR 0 4
37986: PUSH
37987: LD_VAR 0 2
37991: PUSH
37992: LD_VAR 0 3
37996: ARRAY
37997: PPUSH
37998: LD_INT 3
38000: PPUSH
38001: CALL_OW 259
38005: PUSH
38006: LD_VAR 0 2
38010: PUSH
38011: LD_VAR 0 3
38015: ARRAY
38016: PPUSH
38017: CALL_OW 432
38021: MINUS
38022: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
38023: LD_VAR 0 4
38027: PUSH
38028: LD_VAR 0 5
38032: PPUSH
38033: LD_INT 3
38035: PPUSH
38036: CALL_OW 259
38040: PUSH
38041: LD_VAR 0 5
38045: PPUSH
38046: CALL_OW 432
38050: MINUS
38051: GREATEREQUAL
38052: IFFALSE 38070
// mech := result [ i ] ;
38054: LD_ADDR_VAR 0 5
38058: PUSH
38059: LD_VAR 0 2
38063: PUSH
38064: LD_VAR 0 3
38068: ARRAY
38069: ST_TO_ADDR
// end ;
38070: GO 37979
38072: POP
38073: POP
// ComLinkTo ( vehicle , mech ) ;
38074: LD_VAR 0 1
38078: PPUSH
38079: LD_VAR 0 5
38083: PPUSH
38084: CALL_OW 135
// end ;
38088: LD_VAR 0 2
38092: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
38093: LD_INT 0
38095: PPUSH
38096: PPUSH
38097: PPUSH
38098: PPUSH
38099: PPUSH
38100: PPUSH
38101: PPUSH
38102: PPUSH
38103: PPUSH
38104: PPUSH
38105: PPUSH
38106: PPUSH
38107: PPUSH
// result := [ ] ;
38108: LD_ADDR_VAR 0 7
38112: PUSH
38113: EMPTY
38114: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
38115: LD_VAR 0 1
38119: PPUSH
38120: CALL_OW 266
38124: PUSH
38125: LD_INT 0
38127: PUSH
38128: LD_INT 1
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: IN
38135: NOT
38136: IFFALSE 38140
// exit ;
38138: GO 39669
// if name then
38140: LD_VAR 0 3
38144: IFFALSE 38160
// SetBName ( base_dep , name ) ;
38146: LD_VAR 0 1
38150: PPUSH
38151: LD_VAR 0 3
38155: PPUSH
38156: CALL_OW 500
// base := GetBase ( base_dep ) ;
38160: LD_ADDR_VAR 0 15
38164: PUSH
38165: LD_VAR 0 1
38169: PPUSH
38170: CALL_OW 274
38174: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
38175: LD_ADDR_VAR 0 16
38179: PUSH
38180: LD_VAR 0 1
38184: PPUSH
38185: CALL_OW 255
38189: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
38190: LD_ADDR_VAR 0 17
38194: PUSH
38195: LD_VAR 0 1
38199: PPUSH
38200: CALL_OW 248
38204: ST_TO_ADDR
// if sources then
38205: LD_VAR 0 5
38209: IFFALSE 38256
// for i = 1 to 3 do
38211: LD_ADDR_VAR 0 8
38215: PUSH
38216: DOUBLE
38217: LD_INT 1
38219: DEC
38220: ST_TO_ADDR
38221: LD_INT 3
38223: PUSH
38224: FOR_TO
38225: IFFALSE 38254
// AddResourceType ( base , i , sources [ i ] ) ;
38227: LD_VAR 0 15
38231: PPUSH
38232: LD_VAR 0 8
38236: PPUSH
38237: LD_VAR 0 5
38241: PUSH
38242: LD_VAR 0 8
38246: ARRAY
38247: PPUSH
38248: CALL_OW 276
38252: GO 38224
38254: POP
38255: POP
// buildings := GetBaseBuildings ( base , area ) ;
38256: LD_ADDR_VAR 0 18
38260: PUSH
38261: LD_VAR 0 15
38265: PPUSH
38266: LD_VAR 0 2
38270: PPUSH
38271: CALL 37548 0 2
38275: ST_TO_ADDR
// InitHc ;
38276: CALL_OW 19
// InitUc ;
38280: CALL_OW 18
// uc_side := side ;
38284: LD_ADDR_OWVAR 20
38288: PUSH
38289: LD_VAR 0 16
38293: ST_TO_ADDR
// uc_nation := nation ;
38294: LD_ADDR_OWVAR 21
38298: PUSH
38299: LD_VAR 0 17
38303: ST_TO_ADDR
// if buildings then
38304: LD_VAR 0 18
38308: IFFALSE 39528
// begin if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
38310: LD_VAR 0 18
38314: PPUSH
38315: LD_INT 2
38317: PUSH
38318: LD_INT 30
38320: PUSH
38321: LD_INT 32
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 30
38330: PUSH
38331: LD_INT 33
38333: PUSH
38334: EMPTY
38335: LIST
38336: LIST
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: LIST
38342: PPUSH
38343: CALL_OW 72
38347: IFFALSE 38435
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
38349: LD_ADDR_VAR 0 8
38353: PUSH
38354: LD_VAR 0 18
38358: PPUSH
38359: LD_INT 2
38361: PUSH
38362: LD_INT 30
38364: PUSH
38365: LD_INT 32
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 30
38374: PUSH
38375: LD_INT 33
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: LIST
38386: PPUSH
38387: CALL_OW 72
38391: PUSH
38392: FOR_IN
38393: IFFALSE 38433
// begin if not GetBWeapon ( i ) then
38395: LD_VAR 0 8
38399: PPUSH
38400: CALL_OW 269
38404: NOT
38405: IFFALSE 38431
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
38407: LD_VAR 0 8
38411: PPUSH
38412: LD_VAR 0 8
38416: PPUSH
38417: LD_VAR 0 2
38421: PPUSH
38422: CALL 39674 0 2
38426: PPUSH
38427: CALL_OW 431
// end ;
38431: GO 38392
38433: POP
38434: POP
// end ; for i = 1 to personel do
38435: LD_ADDR_VAR 0 8
38439: PUSH
38440: DOUBLE
38441: LD_INT 1
38443: DEC
38444: ST_TO_ADDR
38445: LD_VAR 0 6
38449: PUSH
38450: FOR_TO
38451: IFFALSE 39508
// begin if i > 4 then
38453: LD_VAR 0 8
38457: PUSH
38458: LD_INT 4
38460: GREATER
38461: IFFALSE 38465
// break ;
38463: GO 39508
// case i of 1 :
38465: LD_VAR 0 8
38469: PUSH
38470: LD_INT 1
38472: DOUBLE
38473: EQUAL
38474: IFTRUE 38478
38476: GO 38551
38478: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
38479: LD_ADDR_VAR 0 12
38483: PUSH
38484: LD_VAR 0 18
38488: PPUSH
38489: LD_INT 22
38491: PUSH
38492: LD_VAR 0 16
38496: PUSH
38497: EMPTY
38498: LIST
38499: LIST
38500: PUSH
38501: LD_INT 2
38503: PUSH
38504: LD_INT 30
38506: PUSH
38507: LD_INT 32
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: PUSH
38514: LD_INT 30
38516: PUSH
38517: LD_INT 4
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 30
38526: PUSH
38527: LD_INT 5
38529: PUSH
38530: EMPTY
38531: LIST
38532: LIST
38533: PUSH
38534: EMPTY
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: PUSH
38540: EMPTY
38541: LIST
38542: LIST
38543: PPUSH
38544: CALL_OW 72
38548: ST_TO_ADDR
38549: GO 38773
38551: LD_INT 2
38553: DOUBLE
38554: EQUAL
38555: IFTRUE 38559
38557: GO 38621
38559: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
38560: LD_ADDR_VAR 0 12
38564: PUSH
38565: LD_VAR 0 18
38569: PPUSH
38570: LD_INT 22
38572: PUSH
38573: LD_VAR 0 16
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 2
38584: PUSH
38585: LD_INT 30
38587: PUSH
38588: LD_INT 0
38590: PUSH
38591: EMPTY
38592: LIST
38593: LIST
38594: PUSH
38595: LD_INT 30
38597: PUSH
38598: LD_INT 1
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: EMPTY
38606: LIST
38607: LIST
38608: LIST
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PPUSH
38614: CALL_OW 72
38618: ST_TO_ADDR
38619: GO 38773
38621: LD_INT 3
38623: DOUBLE
38624: EQUAL
38625: IFTRUE 38629
38627: GO 38691
38629: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
38630: LD_ADDR_VAR 0 12
38634: PUSH
38635: LD_VAR 0 18
38639: PPUSH
38640: LD_INT 22
38642: PUSH
38643: LD_VAR 0 16
38647: PUSH
38648: EMPTY
38649: LIST
38650: LIST
38651: PUSH
38652: LD_INT 2
38654: PUSH
38655: LD_INT 30
38657: PUSH
38658: LD_INT 2
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 30
38667: PUSH
38668: LD_INT 3
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: LIST
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PPUSH
38684: CALL_OW 72
38688: ST_TO_ADDR
38689: GO 38773
38691: LD_INT 4
38693: DOUBLE
38694: EQUAL
38695: IFTRUE 38699
38697: GO 38772
38699: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
38700: LD_ADDR_VAR 0 12
38704: PUSH
38705: LD_VAR 0 18
38709: PPUSH
38710: LD_INT 22
38712: PUSH
38713: LD_VAR 0 16
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: PUSH
38725: LD_INT 30
38727: PUSH
38728: LD_INT 6
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 30
38737: PUSH
38738: LD_INT 7
38740: PUSH
38741: EMPTY
38742: LIST
38743: LIST
38744: PUSH
38745: LD_INT 30
38747: PUSH
38748: LD_INT 8
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PPUSH
38765: CALL_OW 72
38769: ST_TO_ADDR
38770: GO 38773
38772: POP
// if i = 1 then
38773: LD_VAR 0 8
38777: PUSH
38778: LD_INT 1
38780: EQUAL
38781: IFFALSE 38892
// begin tmp := [ ] ;
38783: LD_ADDR_VAR 0 19
38787: PUSH
38788: EMPTY
38789: ST_TO_ADDR
// for j in f do
38790: LD_ADDR_VAR 0 9
38794: PUSH
38795: LD_VAR 0 12
38799: PUSH
38800: FOR_IN
38801: IFFALSE 38874
// if GetBType ( j ) = b_bunker then
38803: LD_VAR 0 9
38807: PPUSH
38808: CALL_OW 266
38812: PUSH
38813: LD_INT 32
38815: EQUAL
38816: IFFALSE 38843
// tmp := Insert ( tmp , 1 , j ) else
38818: LD_ADDR_VAR 0 19
38822: PUSH
38823: LD_VAR 0 19
38827: PPUSH
38828: LD_INT 1
38830: PPUSH
38831: LD_VAR 0 9
38835: PPUSH
38836: CALL_OW 2
38840: ST_TO_ADDR
38841: GO 38872
// tmp := Insert ( tmp , tmp + 1 , j ) ;
38843: LD_ADDR_VAR 0 19
38847: PUSH
38848: LD_VAR 0 19
38852: PPUSH
38853: LD_VAR 0 19
38857: PUSH
38858: LD_INT 1
38860: PLUS
38861: PPUSH
38862: LD_VAR 0 9
38866: PPUSH
38867: CALL_OW 2
38871: ST_TO_ADDR
38872: GO 38800
38874: POP
38875: POP
// if tmp then
38876: LD_VAR 0 19
38880: IFFALSE 38892
// f := tmp ;
38882: LD_ADDR_VAR 0 12
38886: PUSH
38887: LD_VAR 0 19
38891: ST_TO_ADDR
// end ; x := personel [ i ] ;
38892: LD_ADDR_VAR 0 13
38896: PUSH
38897: LD_VAR 0 6
38901: PUSH
38902: LD_VAR 0 8
38906: ARRAY
38907: ST_TO_ADDR
// if x = - 1 then
38908: LD_VAR 0 13
38912: PUSH
38913: LD_INT 1
38915: NEG
38916: EQUAL
38917: IFFALSE 39126
// begin for j in f do
38919: LD_ADDR_VAR 0 9
38923: PUSH
38924: LD_VAR 0 12
38928: PUSH
38929: FOR_IN
38930: IFFALSE 39122
// repeat InitHc ;
38932: CALL_OW 19
// if GetBType ( j ) = b_barracks then
38936: LD_VAR 0 9
38940: PPUSH
38941: CALL_OW 266
38945: PUSH
38946: LD_INT 5
38948: EQUAL
38949: IFFALSE 39019
// begin if UnitsInside ( j ) < 3 then
38951: LD_VAR 0 9
38955: PPUSH
38956: CALL_OW 313
38960: PUSH
38961: LD_INT 3
38963: LESS
38964: IFFALSE 39000
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
38966: LD_INT 0
38968: PPUSH
38969: LD_INT 5
38971: PUSH
38972: LD_INT 8
38974: PUSH
38975: LD_INT 9
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: LIST
38982: PUSH
38983: LD_VAR 0 17
38987: ARRAY
38988: PPUSH
38989: LD_VAR 0 4
38993: PPUSH
38994: CALL_OW 380
38998: GO 39017
// PrepareHuman ( false , i , skill ) ;
39000: LD_INT 0
39002: PPUSH
39003: LD_VAR 0 8
39007: PPUSH
39008: LD_VAR 0 4
39012: PPUSH
39013: CALL_OW 380
// end else
39017: GO 39036
// PrepareHuman ( false , i , skill ) ;
39019: LD_INT 0
39021: PPUSH
39022: LD_VAR 0 8
39026: PPUSH
39027: LD_VAR 0 4
39031: PPUSH
39032: CALL_OW 380
// un := CreateHuman ;
39036: LD_ADDR_VAR 0 14
39040: PUSH
39041: CALL_OW 44
39045: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
39046: LD_ADDR_VAR 0 7
39050: PUSH
39051: LD_VAR 0 7
39055: PPUSH
39056: LD_INT 1
39058: PPUSH
39059: LD_VAR 0 14
39063: PPUSH
39064: CALL_OW 2
39068: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
39069: LD_VAR 0 14
39073: PPUSH
39074: LD_VAR 0 9
39078: PPUSH
39079: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
39083: LD_VAR 0 9
39087: PPUSH
39088: CALL_OW 313
39092: PUSH
39093: LD_INT 6
39095: EQUAL
39096: PUSH
39097: LD_VAR 0 9
39101: PPUSH
39102: CALL_OW 266
39106: PUSH
39107: LD_INT 32
39109: PUSH
39110: LD_INT 31
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: IN
39117: OR
39118: IFFALSE 38932
39120: GO 38929
39122: POP
39123: POP
// end else
39124: GO 39506
// for j = 1 to x do
39126: LD_ADDR_VAR 0 9
39130: PUSH
39131: DOUBLE
39132: LD_INT 1
39134: DEC
39135: ST_TO_ADDR
39136: LD_VAR 0 13
39140: PUSH
39141: FOR_TO
39142: IFFALSE 39504
// begin InitHc ;
39144: CALL_OW 19
// if not f then
39148: LD_VAR 0 12
39152: NOT
39153: IFFALSE 39242
// begin PrepareHuman ( false , i , skill ) ;
39155: LD_INT 0
39157: PPUSH
39158: LD_VAR 0 8
39162: PPUSH
39163: LD_VAR 0 4
39167: PPUSH
39168: CALL_OW 380
// un := CreateHuman ;
39172: LD_ADDR_VAR 0 14
39176: PUSH
39177: CALL_OW 44
39181: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
39182: LD_ADDR_VAR 0 7
39186: PUSH
39187: LD_VAR 0 7
39191: PPUSH
39192: LD_INT 1
39194: PPUSH
39195: LD_VAR 0 14
39199: PPUSH
39200: CALL_OW 2
39204: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
39205: LD_VAR 0 14
39209: PPUSH
39210: LD_VAR 0 1
39214: PPUSH
39215: CALL_OW 250
39219: PPUSH
39220: LD_VAR 0 1
39224: PPUSH
39225: CALL_OW 251
39229: PPUSH
39230: LD_INT 10
39232: PPUSH
39233: LD_INT 0
39235: PPUSH
39236: CALL_OW 50
// continue ;
39240: GO 39141
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
39242: LD_VAR 0 12
39246: PUSH
39247: LD_INT 1
39249: ARRAY
39250: PPUSH
39251: CALL_OW 313
39255: PUSH
39256: LD_VAR 0 12
39260: PUSH
39261: LD_INT 1
39263: ARRAY
39264: PPUSH
39265: CALL_OW 266
39269: PUSH
39270: LD_INT 32
39272: PUSH
39273: LD_INT 31
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: IN
39280: AND
39281: PUSH
39282: LD_VAR 0 12
39286: PUSH
39287: LD_INT 1
39289: ARRAY
39290: PPUSH
39291: CALL_OW 313
39295: PUSH
39296: LD_INT 6
39298: EQUAL
39299: OR
39300: IFFALSE 39320
// f := Delete ( f , 1 ) ;
39302: LD_ADDR_VAR 0 12
39306: PUSH
39307: LD_VAR 0 12
39311: PPUSH
39312: LD_INT 1
39314: PPUSH
39315: CALL_OW 3
39319: ST_TO_ADDR
// if not f then
39320: LD_VAR 0 12
39324: NOT
39325: IFFALSE 39343
// begin x := x + 2 ;
39327: LD_ADDR_VAR 0 13
39331: PUSH
39332: LD_VAR 0 13
39336: PUSH
39337: LD_INT 2
39339: PLUS
39340: ST_TO_ADDR
// continue ;
39341: GO 39141
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
39343: LD_VAR 0 12
39347: PUSH
39348: LD_INT 1
39350: ARRAY
39351: PPUSH
39352: CALL_OW 266
39356: PUSH
39357: LD_INT 5
39359: EQUAL
39360: IFFALSE 39434
// begin if UnitsInside ( f [ 1 ] ) < 3 then
39362: LD_VAR 0 12
39366: PUSH
39367: LD_INT 1
39369: ARRAY
39370: PPUSH
39371: CALL_OW 313
39375: PUSH
39376: LD_INT 3
39378: LESS
39379: IFFALSE 39415
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
39381: LD_INT 0
39383: PPUSH
39384: LD_INT 5
39386: PUSH
39387: LD_INT 8
39389: PUSH
39390: LD_INT 9
39392: PUSH
39393: EMPTY
39394: LIST
39395: LIST
39396: LIST
39397: PUSH
39398: LD_VAR 0 17
39402: ARRAY
39403: PPUSH
39404: LD_VAR 0 4
39408: PPUSH
39409: CALL_OW 380
39413: GO 39432
// PrepareHuman ( false , i , skill ) ;
39415: LD_INT 0
39417: PPUSH
39418: LD_VAR 0 8
39422: PPUSH
39423: LD_VAR 0 4
39427: PPUSH
39428: CALL_OW 380
// end else
39432: GO 39451
// PrepareHuman ( false , i , skill ) ;
39434: LD_INT 0
39436: PPUSH
39437: LD_VAR 0 8
39441: PPUSH
39442: LD_VAR 0 4
39446: PPUSH
39447: CALL_OW 380
// un := CreateHuman ;
39451: LD_ADDR_VAR 0 14
39455: PUSH
39456: CALL_OW 44
39460: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
39461: LD_ADDR_VAR 0 7
39465: PUSH
39466: LD_VAR 0 7
39470: PPUSH
39471: LD_INT 1
39473: PPUSH
39474: LD_VAR 0 14
39478: PPUSH
39479: CALL_OW 2
39483: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
39484: LD_VAR 0 14
39488: PPUSH
39489: LD_VAR 0 12
39493: PUSH
39494: LD_INT 1
39496: ARRAY
39497: PPUSH
39498: CALL_OW 52
// end ;
39502: GO 39141
39504: POP
39505: POP
// end ;
39506: GO 38450
39508: POP
39509: POP
// result := result ^ buildings ;
39510: LD_ADDR_VAR 0 7
39514: PUSH
39515: LD_VAR 0 7
39519: PUSH
39520: LD_VAR 0 18
39524: ADD
39525: ST_TO_ADDR
// end else
39526: GO 39669
// begin for i = 1 to personel do
39528: LD_ADDR_VAR 0 8
39532: PUSH
39533: DOUBLE
39534: LD_INT 1
39536: DEC
39537: ST_TO_ADDR
39538: LD_VAR 0 6
39542: PUSH
39543: FOR_TO
39544: IFFALSE 39667
// begin if i > 4 then
39546: LD_VAR 0 8
39550: PUSH
39551: LD_INT 4
39553: GREATER
39554: IFFALSE 39558
// break ;
39556: GO 39667
// x := personel [ i ] ;
39558: LD_ADDR_VAR 0 13
39562: PUSH
39563: LD_VAR 0 6
39567: PUSH
39568: LD_VAR 0 8
39572: ARRAY
39573: ST_TO_ADDR
// if x = - 1 then
39574: LD_VAR 0 13
39578: PUSH
39579: LD_INT 1
39581: NEG
39582: EQUAL
39583: IFFALSE 39587
// continue ;
39585: GO 39543
// PrepareHuman ( false , i , skill ) ;
39587: LD_INT 0
39589: PPUSH
39590: LD_VAR 0 8
39594: PPUSH
39595: LD_VAR 0 4
39599: PPUSH
39600: CALL_OW 380
// un := CreateHuman ;
39604: LD_ADDR_VAR 0 14
39608: PUSH
39609: CALL_OW 44
39613: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
39614: LD_VAR 0 14
39618: PPUSH
39619: LD_VAR 0 1
39623: PPUSH
39624: CALL_OW 250
39628: PPUSH
39629: LD_VAR 0 1
39633: PPUSH
39634: CALL_OW 251
39638: PPUSH
39639: LD_INT 10
39641: PPUSH
39642: LD_INT 0
39644: PPUSH
39645: CALL_OW 50
// result := result ^ un ;
39649: LD_ADDR_VAR 0 7
39653: PUSH
39654: LD_VAR 0 7
39658: PUSH
39659: LD_VAR 0 14
39663: ADD
39664: ST_TO_ADDR
// end ;
39665: GO 39543
39667: POP
39668: POP
// end ; end ;
39669: LD_VAR 0 7
39673: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
39674: LD_INT 0
39676: PPUSH
39677: PPUSH
39678: PPUSH
39679: PPUSH
39680: PPUSH
39681: PPUSH
39682: PPUSH
39683: PPUSH
39684: PPUSH
39685: PPUSH
39686: PPUSH
39687: PPUSH
39688: PPUSH
39689: PPUSH
39690: PPUSH
39691: PPUSH
// result := false ;
39692: LD_ADDR_VAR 0 3
39696: PUSH
39697: LD_INT 0
39699: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
39700: LD_VAR 0 1
39704: NOT
39705: PUSH
39706: LD_VAR 0 1
39710: PPUSH
39711: CALL_OW 266
39715: PUSH
39716: LD_INT 32
39718: PUSH
39719: LD_INT 33
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: IN
39726: NOT
39727: OR
39728: IFFALSE 39732
// exit ;
39730: GO 40868
// nat := GetNation ( tower ) ;
39732: LD_ADDR_VAR 0 12
39736: PUSH
39737: LD_VAR 0 1
39741: PPUSH
39742: CALL_OW 248
39746: ST_TO_ADDR
// side := GetSide ( tower ) ;
39747: LD_ADDR_VAR 0 16
39751: PUSH
39752: LD_VAR 0 1
39756: PPUSH
39757: CALL_OW 255
39761: ST_TO_ADDR
// x := GetX ( tower ) ;
39762: LD_ADDR_VAR 0 10
39766: PUSH
39767: LD_VAR 0 1
39771: PPUSH
39772: CALL_OW 250
39776: ST_TO_ADDR
// y := GetY ( tower ) ;
39777: LD_ADDR_VAR 0 11
39781: PUSH
39782: LD_VAR 0 1
39786: PPUSH
39787: CALL_OW 251
39791: ST_TO_ADDR
// if not x or not y then
39792: LD_VAR 0 10
39796: NOT
39797: PUSH
39798: LD_VAR 0 11
39802: NOT
39803: OR
39804: IFFALSE 39808
// exit ;
39806: GO 40868
// weapon := 0 ;
39808: LD_ADDR_VAR 0 18
39812: PUSH
39813: LD_INT 0
39815: ST_TO_ADDR
// fac_list := [ ] ;
39816: LD_ADDR_VAR 0 17
39820: PUSH
39821: EMPTY
39822: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
39823: LD_ADDR_VAR 0 6
39827: PUSH
39828: LD_VAR 0 1
39832: PPUSH
39833: CALL_OW 274
39837: PPUSH
39838: LD_VAR 0 2
39842: PPUSH
39843: CALL 37548 0 2
39847: PPUSH
39848: LD_INT 30
39850: PUSH
39851: LD_INT 3
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: PPUSH
39858: CALL_OW 72
39862: ST_TO_ADDR
// if not factories then
39863: LD_VAR 0 6
39867: NOT
39868: IFFALSE 39872
// exit ;
39870: GO 40868
// for i in factories do
39872: LD_ADDR_VAR 0 8
39876: PUSH
39877: LD_VAR 0 6
39881: PUSH
39882: FOR_IN
39883: IFFALSE 39908
// fac_list := fac_list union AvailableWeaponList ( i ) ;
39885: LD_ADDR_VAR 0 17
39889: PUSH
39890: LD_VAR 0 17
39894: PUSH
39895: LD_VAR 0 8
39899: PPUSH
39900: CALL_OW 478
39904: UNION
39905: ST_TO_ADDR
39906: GO 39882
39908: POP
39909: POP
// if not fac_list then
39910: LD_VAR 0 17
39914: NOT
39915: IFFALSE 39919
// exit ;
39917: GO 40868
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
39919: LD_ADDR_VAR 0 5
39923: PUSH
39924: LD_INT 4
39926: PUSH
39927: LD_INT 5
39929: PUSH
39930: LD_INT 9
39932: PUSH
39933: LD_INT 10
39935: PUSH
39936: LD_INT 6
39938: PUSH
39939: LD_INT 7
39941: PUSH
39942: LD_INT 11
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: PUSH
39954: LD_INT 27
39956: PUSH
39957: LD_INT 28
39959: PUSH
39960: LD_INT 26
39962: PUSH
39963: LD_INT 30
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 43
39974: PUSH
39975: LD_INT 44
39977: PUSH
39978: LD_INT 46
39980: PUSH
39981: LD_INT 45
39983: PUSH
39984: LD_INT 47
39986: PUSH
39987: LD_INT 49
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: LIST
40002: PUSH
40003: LD_VAR 0 12
40007: ARRAY
40008: ST_TO_ADDR
// for i in list do
40009: LD_ADDR_VAR 0 8
40013: PUSH
40014: LD_VAR 0 5
40018: PUSH
40019: FOR_IN
40020: IFFALSE 40053
// if not i in fac_list then
40022: LD_VAR 0 8
40026: PUSH
40027: LD_VAR 0 17
40031: IN
40032: NOT
40033: IFFALSE 40051
// list := list diff i ;
40035: LD_ADDR_VAR 0 5
40039: PUSH
40040: LD_VAR 0 5
40044: PUSH
40045: LD_VAR 0 8
40049: DIFF
40050: ST_TO_ADDR
40051: GO 40019
40053: POP
40054: POP
// if not list then
40055: LD_VAR 0 5
40059: NOT
40060: IFFALSE 40064
// exit ;
40062: GO 40868
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
40064: LD_VAR 0 12
40068: PUSH
40069: LD_INT 3
40071: EQUAL
40072: PUSH
40073: LD_INT 49
40075: PUSH
40076: LD_VAR 0 5
40080: IN
40081: AND
40082: PUSH
40083: LD_INT 31
40085: PPUSH
40086: LD_VAR 0 16
40090: PPUSH
40091: CALL_OW 321
40095: PUSH
40096: LD_INT 2
40098: EQUAL
40099: AND
40100: IFFALSE 40160
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
40102: LD_INT 22
40104: PUSH
40105: LD_VAR 0 16
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 35
40116: PUSH
40117: LD_INT 49
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 91
40126: PUSH
40127: LD_VAR 0 1
40131: PUSH
40132: LD_INT 10
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: LIST
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: LIST
40144: PPUSH
40145: CALL_OW 69
40149: NOT
40150: IFFALSE 40160
// weapon := ru_time_lapser ;
40152: LD_ADDR_VAR 0 18
40156: PUSH
40157: LD_INT 49
40159: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
40160: LD_VAR 0 12
40164: PUSH
40165: LD_INT 1
40167: PUSH
40168: LD_INT 2
40170: PUSH
40171: EMPTY
40172: LIST
40173: LIST
40174: IN
40175: PUSH
40176: LD_INT 11
40178: PUSH
40179: LD_VAR 0 5
40183: IN
40184: PUSH
40185: LD_INT 30
40187: PUSH
40188: LD_VAR 0 5
40192: IN
40193: OR
40194: AND
40195: PUSH
40196: LD_INT 6
40198: PPUSH
40199: LD_VAR 0 16
40203: PPUSH
40204: CALL_OW 321
40208: PUSH
40209: LD_INT 2
40211: EQUAL
40212: AND
40213: IFFALSE 40378
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
40215: LD_INT 22
40217: PUSH
40218: LD_VAR 0 16
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 2
40229: PUSH
40230: LD_INT 35
40232: PUSH
40233: LD_INT 11
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 35
40242: PUSH
40243: LD_INT 30
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: LIST
40254: PUSH
40255: LD_INT 91
40257: PUSH
40258: LD_VAR 0 1
40262: PUSH
40263: LD_INT 18
40265: PUSH
40266: EMPTY
40267: LIST
40268: LIST
40269: LIST
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: LIST
40275: PPUSH
40276: CALL_OW 69
40280: NOT
40281: PUSH
40282: LD_INT 22
40284: PUSH
40285: LD_VAR 0 16
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 2
40296: PUSH
40297: LD_INT 30
40299: PUSH
40300: LD_INT 32
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: LD_INT 30
40309: PUSH
40310: LD_INT 33
40312: PUSH
40313: EMPTY
40314: LIST
40315: LIST
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: LIST
40321: PUSH
40322: LD_INT 91
40324: PUSH
40325: LD_VAR 0 1
40329: PUSH
40330: LD_INT 12
40332: PUSH
40333: EMPTY
40334: LIST
40335: LIST
40336: LIST
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: LIST
40342: PUSH
40343: EMPTY
40344: LIST
40345: PPUSH
40346: CALL_OW 69
40350: PUSH
40351: LD_INT 2
40353: GREATER
40354: AND
40355: IFFALSE 40378
// weapon := [ us_radar , ar_radar ] [ nat ] ;
40357: LD_ADDR_VAR 0 18
40361: PUSH
40362: LD_INT 11
40364: PUSH
40365: LD_INT 30
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_VAR 0 12
40376: ARRAY
40377: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
40378: LD_VAR 0 18
40382: NOT
40383: PUSH
40384: LD_INT 40
40386: PPUSH
40387: LD_VAR 0 16
40391: PPUSH
40392: CALL_OW 321
40396: PUSH
40397: LD_INT 2
40399: EQUAL
40400: AND
40401: PUSH
40402: LD_INT 7
40404: PUSH
40405: LD_VAR 0 5
40409: IN
40410: PUSH
40411: LD_INT 28
40413: PUSH
40414: LD_VAR 0 5
40418: IN
40419: OR
40420: PUSH
40421: LD_INT 45
40423: PUSH
40424: LD_VAR 0 5
40428: IN
40429: OR
40430: AND
40431: IFFALSE 40685
// begin hex := GetHexInfo ( x , y ) ;
40433: LD_ADDR_VAR 0 4
40437: PUSH
40438: LD_VAR 0 10
40442: PPUSH
40443: LD_VAR 0 11
40447: PPUSH
40448: CALL_OW 546
40452: ST_TO_ADDR
// if hex [ 1 ] then
40453: LD_VAR 0 4
40457: PUSH
40458: LD_INT 1
40460: ARRAY
40461: IFFALSE 40465
// exit ;
40463: GO 40868
// height := hex [ 2 ] ;
40465: LD_ADDR_VAR 0 15
40469: PUSH
40470: LD_VAR 0 4
40474: PUSH
40475: LD_INT 2
40477: ARRAY
40478: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
40479: LD_ADDR_VAR 0 14
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 2
40489: PUSH
40490: LD_INT 3
40492: PUSH
40493: LD_INT 5
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: LIST
40500: LIST
40501: ST_TO_ADDR
// for i in tmp do
40502: LD_ADDR_VAR 0 8
40506: PUSH
40507: LD_VAR 0 14
40511: PUSH
40512: FOR_IN
40513: IFFALSE 40683
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
40515: LD_ADDR_VAR 0 9
40519: PUSH
40520: LD_VAR 0 10
40524: PPUSH
40525: LD_VAR 0 8
40529: PPUSH
40530: LD_INT 5
40532: PPUSH
40533: CALL_OW 272
40537: PUSH
40538: LD_VAR 0 11
40542: PPUSH
40543: LD_VAR 0 8
40547: PPUSH
40548: LD_INT 5
40550: PPUSH
40551: CALL_OW 273
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
40560: LD_VAR 0 9
40564: PUSH
40565: LD_INT 1
40567: ARRAY
40568: PPUSH
40569: LD_VAR 0 9
40573: PUSH
40574: LD_INT 2
40576: ARRAY
40577: PPUSH
40578: CALL_OW 488
40582: IFFALSE 40681
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
40584: LD_ADDR_VAR 0 4
40588: PUSH
40589: LD_VAR 0 9
40593: PUSH
40594: LD_INT 1
40596: ARRAY
40597: PPUSH
40598: LD_VAR 0 9
40602: PUSH
40603: LD_INT 2
40605: ARRAY
40606: PPUSH
40607: CALL_OW 546
40611: ST_TO_ADDR
// if hex [ 1 ] then
40612: LD_VAR 0 4
40616: PUSH
40617: LD_INT 1
40619: ARRAY
40620: IFFALSE 40624
// continue ;
40622: GO 40512
// h := hex [ 2 ] ;
40624: LD_ADDR_VAR 0 13
40628: PUSH
40629: LD_VAR 0 4
40633: PUSH
40634: LD_INT 2
40636: ARRAY
40637: ST_TO_ADDR
// if h + 7 < height then
40638: LD_VAR 0 13
40642: PUSH
40643: LD_INT 7
40645: PLUS
40646: PUSH
40647: LD_VAR 0 15
40651: LESS
40652: IFFALSE 40681
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
40654: LD_ADDR_VAR 0 18
40658: PUSH
40659: LD_INT 7
40661: PUSH
40662: LD_INT 28
40664: PUSH
40665: LD_INT 45
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: LIST
40672: PUSH
40673: LD_VAR 0 12
40677: ARRAY
40678: ST_TO_ADDR
// break ;
40679: GO 40683
// end ; end ; end ;
40681: GO 40512
40683: POP
40684: POP
// end ; if not weapon then
40685: LD_VAR 0 18
40689: NOT
40690: IFFALSE 40750
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
40692: LD_ADDR_VAR 0 5
40696: PUSH
40697: LD_VAR 0 5
40701: PUSH
40702: LD_INT 11
40704: PUSH
40705: LD_INT 30
40707: PUSH
40708: LD_INT 49
40710: PUSH
40711: EMPTY
40712: LIST
40713: LIST
40714: LIST
40715: DIFF
40716: ST_TO_ADDR
// if not list then
40717: LD_VAR 0 5
40721: NOT
40722: IFFALSE 40726
// exit ;
40724: GO 40868
// weapon := list [ rand ( 1 , list ) ] ;
40726: LD_ADDR_VAR 0 18
40730: PUSH
40731: LD_VAR 0 5
40735: PUSH
40736: LD_INT 1
40738: PPUSH
40739: LD_VAR 0 5
40743: PPUSH
40744: CALL_OW 12
40748: ARRAY
40749: ST_TO_ADDR
// end ; if weapon then
40750: LD_VAR 0 18
40754: IFFALSE 40868
// begin tmp := CostOfWeapon ( weapon ) ;
40756: LD_ADDR_VAR 0 14
40760: PUSH
40761: LD_VAR 0 18
40765: PPUSH
40766: CALL_OW 451
40770: ST_TO_ADDR
// j := GetBase ( tower ) ;
40771: LD_ADDR_VAR 0 9
40775: PUSH
40776: LD_VAR 0 1
40780: PPUSH
40781: CALL_OW 274
40785: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
40786: LD_VAR 0 9
40790: PPUSH
40791: LD_INT 1
40793: PPUSH
40794: CALL_OW 275
40798: PUSH
40799: LD_VAR 0 14
40803: PUSH
40804: LD_INT 1
40806: ARRAY
40807: GREATEREQUAL
40808: PUSH
40809: LD_VAR 0 9
40813: PPUSH
40814: LD_INT 2
40816: PPUSH
40817: CALL_OW 275
40821: PUSH
40822: LD_VAR 0 14
40826: PUSH
40827: LD_INT 2
40829: ARRAY
40830: GREATEREQUAL
40831: AND
40832: PUSH
40833: LD_VAR 0 9
40837: PPUSH
40838: LD_INT 3
40840: PPUSH
40841: CALL_OW 275
40845: PUSH
40846: LD_VAR 0 14
40850: PUSH
40851: LD_INT 3
40853: ARRAY
40854: GREATEREQUAL
40855: AND
40856: IFFALSE 40868
// result := weapon ;
40858: LD_ADDR_VAR 0 3
40862: PUSH
40863: LD_VAR 0 18
40867: ST_TO_ADDR
// end ; end ;
40868: LD_VAR 0 3
40872: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
40873: LD_INT 0
40875: PPUSH
40876: PPUSH
// result := true ;
40877: LD_ADDR_VAR 0 3
40881: PUSH
40882: LD_INT 1
40884: ST_TO_ADDR
// if array1 = array2 then
40885: LD_VAR 0 1
40889: PUSH
40890: LD_VAR 0 2
40894: EQUAL
40895: IFFALSE 40955
// begin for i = 1 to array1 do
40897: LD_ADDR_VAR 0 4
40901: PUSH
40902: DOUBLE
40903: LD_INT 1
40905: DEC
40906: ST_TO_ADDR
40907: LD_VAR 0 1
40911: PUSH
40912: FOR_TO
40913: IFFALSE 40951
// if array1 [ i ] <> array2 [ i ] then
40915: LD_VAR 0 1
40919: PUSH
40920: LD_VAR 0 4
40924: ARRAY
40925: PUSH
40926: LD_VAR 0 2
40930: PUSH
40931: LD_VAR 0 4
40935: ARRAY
40936: NONEQUAL
40937: IFFALSE 40949
// begin result := false ;
40939: LD_ADDR_VAR 0 3
40943: PUSH
40944: LD_INT 0
40946: ST_TO_ADDR
// break ;
40947: GO 40951
// end ;
40949: GO 40912
40951: POP
40952: POP
// end else
40953: GO 40963
// result := false ;
40955: LD_ADDR_VAR 0 3
40959: PUSH
40960: LD_INT 0
40962: ST_TO_ADDR
// end ;
40963: LD_VAR 0 3
40967: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
40968: LD_INT 0
40970: PPUSH
40971: PPUSH
40972: PPUSH
// pom := GetBase ( fac ) ;
40973: LD_ADDR_VAR 0 5
40977: PUSH
40978: LD_VAR 0 1
40982: PPUSH
40983: CALL_OW 274
40987: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
40988: LD_ADDR_VAR 0 4
40992: PUSH
40993: LD_VAR 0 2
40997: PUSH
40998: LD_INT 1
41000: ARRAY
41001: PPUSH
41002: LD_VAR 0 2
41006: PUSH
41007: LD_INT 2
41009: ARRAY
41010: PPUSH
41011: LD_VAR 0 2
41015: PUSH
41016: LD_INT 3
41018: ARRAY
41019: PPUSH
41020: LD_VAR 0 2
41024: PUSH
41025: LD_INT 4
41027: ARRAY
41028: PPUSH
41029: CALL_OW 449
41033: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
41034: LD_ADDR_VAR 0 3
41038: PUSH
41039: LD_VAR 0 5
41043: PPUSH
41044: LD_INT 1
41046: PPUSH
41047: CALL_OW 275
41051: PUSH
41052: LD_VAR 0 4
41056: PUSH
41057: LD_INT 1
41059: ARRAY
41060: GREATEREQUAL
41061: PUSH
41062: LD_VAR 0 5
41066: PPUSH
41067: LD_INT 2
41069: PPUSH
41070: CALL_OW 275
41074: PUSH
41075: LD_VAR 0 4
41079: PUSH
41080: LD_INT 2
41082: ARRAY
41083: GREATEREQUAL
41084: AND
41085: PUSH
41086: LD_VAR 0 5
41090: PPUSH
41091: LD_INT 3
41093: PPUSH
41094: CALL_OW 275
41098: PUSH
41099: LD_VAR 0 4
41103: PUSH
41104: LD_INT 3
41106: ARRAY
41107: GREATEREQUAL
41108: AND
41109: ST_TO_ADDR
// end ;
41110: LD_VAR 0 3
41114: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
41115: LD_INT 0
41117: PPUSH
41118: PPUSH
41119: PPUSH
41120: PPUSH
// pom := GetBase ( building ) ;
41121: LD_ADDR_VAR 0 3
41125: PUSH
41126: LD_VAR 0 1
41130: PPUSH
41131: CALL_OW 274
41135: ST_TO_ADDR
// if not pom then
41136: LD_VAR 0 3
41140: NOT
41141: IFFALSE 41145
// exit ;
41143: GO 41315
// btype := GetBType ( building ) ;
41145: LD_ADDR_VAR 0 5
41149: PUSH
41150: LD_VAR 0 1
41154: PPUSH
41155: CALL_OW 266
41159: ST_TO_ADDR
// if btype = b_armoury then
41160: LD_VAR 0 5
41164: PUSH
41165: LD_INT 4
41167: EQUAL
41168: IFFALSE 41178
// btype := b_barracks ;
41170: LD_ADDR_VAR 0 5
41174: PUSH
41175: LD_INT 5
41177: ST_TO_ADDR
// if btype = b_depot then
41178: LD_VAR 0 5
41182: PUSH
41183: LD_INT 0
41185: EQUAL
41186: IFFALSE 41196
// btype := b_warehouse ;
41188: LD_ADDR_VAR 0 5
41192: PUSH
41193: LD_INT 1
41195: ST_TO_ADDR
// if btype = b_workshop then
41196: LD_VAR 0 5
41200: PUSH
41201: LD_INT 2
41203: EQUAL
41204: IFFALSE 41214
// btype := b_factory ;
41206: LD_ADDR_VAR 0 5
41210: PUSH
41211: LD_INT 3
41213: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
41214: LD_ADDR_VAR 0 4
41218: PUSH
41219: LD_VAR 0 5
41223: PPUSH
41224: LD_VAR 0 1
41228: PPUSH
41229: CALL_OW 248
41233: PPUSH
41234: CALL_OW 450
41238: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
41239: LD_ADDR_VAR 0 2
41243: PUSH
41244: LD_VAR 0 3
41248: PPUSH
41249: LD_INT 1
41251: PPUSH
41252: CALL_OW 275
41256: PUSH
41257: LD_VAR 0 4
41261: PUSH
41262: LD_INT 1
41264: ARRAY
41265: GREATEREQUAL
41266: PUSH
41267: LD_VAR 0 3
41271: PPUSH
41272: LD_INT 2
41274: PPUSH
41275: CALL_OW 275
41279: PUSH
41280: LD_VAR 0 4
41284: PUSH
41285: LD_INT 2
41287: ARRAY
41288: GREATEREQUAL
41289: AND
41290: PUSH
41291: LD_VAR 0 3
41295: PPUSH
41296: LD_INT 3
41298: PPUSH
41299: CALL_OW 275
41303: PUSH
41304: LD_VAR 0 4
41308: PUSH
41309: LD_INT 3
41311: ARRAY
41312: GREATEREQUAL
41313: AND
41314: ST_TO_ADDR
// end ;
41315: LD_VAR 0 2
41319: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
41320: LD_INT 0
41322: PPUSH
41323: PPUSH
41324: PPUSH
// pom := GetBase ( building ) ;
41325: LD_ADDR_VAR 0 4
41329: PUSH
41330: LD_VAR 0 1
41334: PPUSH
41335: CALL_OW 274
41339: ST_TO_ADDR
// if not pom then
41340: LD_VAR 0 4
41344: NOT
41345: IFFALSE 41349
// exit ;
41347: GO 41450
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
41349: LD_ADDR_VAR 0 5
41353: PUSH
41354: LD_VAR 0 2
41358: PPUSH
41359: LD_VAR 0 1
41363: PPUSH
41364: CALL_OW 248
41368: PPUSH
41369: CALL_OW 450
41373: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
41374: LD_ADDR_VAR 0 3
41378: PUSH
41379: LD_VAR 0 4
41383: PPUSH
41384: LD_INT 1
41386: PPUSH
41387: CALL_OW 275
41391: PUSH
41392: LD_VAR 0 5
41396: PUSH
41397: LD_INT 1
41399: ARRAY
41400: GREATEREQUAL
41401: PUSH
41402: LD_VAR 0 4
41406: PPUSH
41407: LD_INT 2
41409: PPUSH
41410: CALL_OW 275
41414: PUSH
41415: LD_VAR 0 5
41419: PUSH
41420: LD_INT 2
41422: ARRAY
41423: GREATEREQUAL
41424: AND
41425: PUSH
41426: LD_VAR 0 4
41430: PPUSH
41431: LD_INT 3
41433: PPUSH
41434: CALL_OW 275
41438: PUSH
41439: LD_VAR 0 5
41443: PUSH
41444: LD_INT 3
41446: ARRAY
41447: GREATEREQUAL
41448: AND
41449: ST_TO_ADDR
// end ;
41450: LD_VAR 0 3
41454: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
41455: LD_INT 0
41457: PPUSH
41458: PPUSH
41459: PPUSH
41460: PPUSH
41461: PPUSH
41462: PPUSH
41463: PPUSH
41464: PPUSH
41465: PPUSH
41466: PPUSH
// result := false ;
41467: LD_ADDR_VAR 0 6
41471: PUSH
41472: LD_INT 0
41474: ST_TO_ADDR
// if not base or not btype or not x or not y then
41475: LD_VAR 0 1
41479: NOT
41480: PUSH
41481: LD_VAR 0 2
41485: NOT
41486: OR
41487: PUSH
41488: LD_VAR 0 3
41492: NOT
41493: OR
41494: PUSH
41495: LD_VAR 0 4
41499: NOT
41500: OR
41501: IFFALSE 41505
// exit ;
41503: GO 42019
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
41505: LD_ADDR_VAR 0 12
41509: PUSH
41510: LD_VAR 0 2
41514: PPUSH
41515: LD_VAR 0 3
41519: PPUSH
41520: LD_VAR 0 4
41524: PPUSH
41525: LD_VAR 0 5
41529: PPUSH
41530: LD_VAR 0 1
41534: PUSH
41535: LD_INT 1
41537: ARRAY
41538: PPUSH
41539: CALL_OW 248
41543: PPUSH
41544: LD_INT 0
41546: PPUSH
41547: CALL 42848 0 6
41551: ST_TO_ADDR
// if not hexes then
41552: LD_VAR 0 12
41556: NOT
41557: IFFALSE 41561
// exit ;
41559: GO 42019
// for i = 1 to hexes do
41561: LD_ADDR_VAR 0 7
41565: PUSH
41566: DOUBLE
41567: LD_INT 1
41569: DEC
41570: ST_TO_ADDR
41571: LD_VAR 0 12
41575: PUSH
41576: FOR_TO
41577: IFFALSE 42017
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
41579: LD_ADDR_VAR 0 11
41583: PUSH
41584: LD_VAR 0 12
41588: PUSH
41589: LD_VAR 0 7
41593: ARRAY
41594: PUSH
41595: LD_INT 1
41597: ARRAY
41598: PPUSH
41599: LD_VAR 0 12
41603: PUSH
41604: LD_VAR 0 7
41608: ARRAY
41609: PUSH
41610: LD_INT 2
41612: ARRAY
41613: PPUSH
41614: CALL_OW 428
41618: ST_TO_ADDR
// if not tmp or GetType ( tmp ) = unit_building then
41619: LD_VAR 0 11
41623: NOT
41624: PUSH
41625: LD_VAR 0 11
41629: PPUSH
41630: CALL_OW 247
41634: PUSH
41635: LD_INT 3
41637: EQUAL
41638: OR
41639: IFFALSE 41643
// continue ;
41641: GO 41576
// result := true ;
41643: LD_ADDR_VAR 0 6
41647: PUSH
41648: LD_INT 1
41650: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
41651: LD_ADDR_VAR 0 15
41655: PUSH
41656: LD_INT 22
41658: PUSH
41659: LD_VAR 0 11
41663: PPUSH
41664: CALL_OW 255
41668: PUSH
41669: EMPTY
41670: LIST
41671: LIST
41672: PUSH
41673: LD_INT 2
41675: PUSH
41676: LD_INT 30
41678: PUSH
41679: LD_INT 0
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 30
41688: PUSH
41689: LD_INT 1
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: EMPTY
41697: LIST
41698: LIST
41699: LIST
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PPUSH
41705: CALL_OW 69
41709: ST_TO_ADDR
// if dep then
41710: LD_VAR 0 15
41714: IFFALSE 41850
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
41716: LD_ADDR_VAR 0 14
41720: PUSH
41721: LD_VAR 0 15
41725: PUSH
41726: LD_INT 1
41728: ARRAY
41729: PPUSH
41730: CALL_OW 250
41734: PPUSH
41735: LD_VAR 0 15
41739: PUSH
41740: LD_INT 1
41742: ARRAY
41743: PPUSH
41744: CALL_OW 254
41748: PPUSH
41749: LD_INT 5
41751: PPUSH
41752: CALL_OW 272
41756: PUSH
41757: LD_VAR 0 15
41761: PUSH
41762: LD_INT 1
41764: ARRAY
41765: PPUSH
41766: CALL_OW 251
41770: PPUSH
41771: LD_VAR 0 15
41775: PUSH
41776: LD_INT 1
41778: ARRAY
41779: PPUSH
41780: CALL_OW 254
41784: PPUSH
41785: LD_INT 5
41787: PPUSH
41788: CALL_OW 273
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
41797: LD_VAR 0 14
41801: PUSH
41802: LD_INT 1
41804: ARRAY
41805: PPUSH
41806: LD_VAR 0 14
41810: PUSH
41811: LD_INT 2
41813: ARRAY
41814: PPUSH
41815: CALL_OW 488
41819: IFFALSE 41850
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
41821: LD_VAR 0 11
41825: PPUSH
41826: LD_VAR 0 14
41830: PUSH
41831: LD_INT 1
41833: ARRAY
41834: PPUSH
41835: LD_VAR 0 14
41839: PUSH
41840: LD_INT 2
41842: ARRAY
41843: PPUSH
41844: CALL_OW 111
// continue ;
41848: GO 41576
// end ; end ; r := GetDir ( tmp ) ;
41850: LD_ADDR_VAR 0 13
41854: PUSH
41855: LD_VAR 0 11
41859: PPUSH
41860: CALL_OW 254
41864: ST_TO_ADDR
// if r = 5 then
41865: LD_VAR 0 13
41869: PUSH
41870: LD_INT 5
41872: EQUAL
41873: IFFALSE 41883
// r := 0 ;
41875: LD_ADDR_VAR 0 13
41879: PUSH
41880: LD_INT 0
41882: ST_TO_ADDR
// for j = r to 5 do
41883: LD_ADDR_VAR 0 8
41887: PUSH
41888: DOUBLE
41889: LD_VAR 0 13
41893: DEC
41894: ST_TO_ADDR
41895: LD_INT 5
41897: PUSH
41898: FOR_TO
41899: IFFALSE 42013
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
41901: LD_ADDR_VAR 0 9
41905: PUSH
41906: LD_VAR 0 11
41910: PPUSH
41911: CALL_OW 250
41915: PPUSH
41916: LD_VAR 0 8
41920: PPUSH
41921: LD_INT 2
41923: PPUSH
41924: CALL_OW 272
41928: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
41929: LD_ADDR_VAR 0 10
41933: PUSH
41934: LD_VAR 0 11
41938: PPUSH
41939: CALL_OW 251
41943: PPUSH
41944: LD_VAR 0 8
41948: PPUSH
41949: LD_INT 2
41951: PPUSH
41952: CALL_OW 273
41956: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
41957: LD_VAR 0 9
41961: PPUSH
41962: LD_VAR 0 10
41966: PPUSH
41967: CALL_OW 488
41971: PUSH
41972: LD_VAR 0 9
41976: PPUSH
41977: LD_VAR 0 10
41981: PPUSH
41982: CALL_OW 428
41986: NOT
41987: AND
41988: IFFALSE 42011
// begin ComMoveXY ( tmp , _x , _y ) ;
41990: LD_VAR 0 11
41994: PPUSH
41995: LD_VAR 0 9
41999: PPUSH
42000: LD_VAR 0 10
42004: PPUSH
42005: CALL_OW 111
// break ;
42009: GO 42013
// end ; end ;
42011: GO 41898
42013: POP
42014: POP
// end ;
42015: GO 41576
42017: POP
42018: POP
// end ;
42019: LD_VAR 0 6
42023: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , pom , cost , hexes , height , dist , hex ; begin
42024: LD_INT 0
42026: PPUSH
42027: PPUSH
42028: PPUSH
42029: PPUSH
42030: PPUSH
42031: PPUSH
42032: PPUSH
42033: PPUSH
42034: PPUSH
// result := false ;
42035: LD_ADDR_VAR 0 6
42039: PUSH
42040: LD_INT 0
42042: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
42043: LD_VAR 0 1
42047: NOT
42048: PUSH
42049: LD_VAR 0 1
42053: PPUSH
42054: CALL_OW 266
42058: PUSH
42059: LD_INT 0
42061: PUSH
42062: LD_INT 1
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: IN
42069: NOT
42070: OR
42071: PUSH
42072: LD_VAR 0 2
42076: NOT
42077: OR
42078: PUSH
42079: LD_VAR 0 5
42083: PUSH
42084: LD_INT 0
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: LD_INT 2
42092: PUSH
42093: LD_INT 3
42095: PUSH
42096: LD_INT 4
42098: PUSH
42099: LD_INT 5
42101: PUSH
42102: EMPTY
42103: LIST
42104: LIST
42105: LIST
42106: LIST
42107: LIST
42108: LIST
42109: IN
42110: NOT
42111: OR
42112: PUSH
42113: LD_VAR 0 3
42117: PPUSH
42118: LD_VAR 0 4
42122: PPUSH
42123: CALL_OW 488
42127: NOT
42128: OR
42129: IFFALSE 42133
// exit ;
42131: GO 42843
// pom := GetBase ( bdepot ) ;
42133: LD_ADDR_VAR 0 9
42137: PUSH
42138: LD_VAR 0 1
42142: PPUSH
42143: CALL_OW 274
42147: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
42148: LD_ADDR_VAR 0 10
42152: PUSH
42153: LD_VAR 0 2
42157: PPUSH
42158: LD_VAR 0 1
42162: PPUSH
42163: CALL_OW 248
42167: PPUSH
42168: CALL_OW 450
42172: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
42173: LD_VAR 0 9
42177: PPUSH
42178: LD_INT 1
42180: PPUSH
42181: CALL_OW 275
42185: PUSH
42186: LD_VAR 0 10
42190: PUSH
42191: LD_INT 1
42193: ARRAY
42194: GREATEREQUAL
42195: PUSH
42196: LD_VAR 0 9
42200: PPUSH
42201: LD_INT 2
42203: PPUSH
42204: CALL_OW 275
42208: PUSH
42209: LD_VAR 0 10
42213: PUSH
42214: LD_INT 2
42216: ARRAY
42217: GREATEREQUAL
42218: AND
42219: PUSH
42220: LD_VAR 0 9
42224: PPUSH
42225: LD_INT 3
42227: PPUSH
42228: CALL_OW 275
42232: PUSH
42233: LD_VAR 0 10
42237: PUSH
42238: LD_INT 3
42240: ARRAY
42241: GREATEREQUAL
42242: AND
42243: NOT
42244: IFFALSE 42248
// exit ;
42246: GO 42843
// if GetBType ( bdepot ) = b_depot then
42248: LD_VAR 0 1
42252: PPUSH
42253: CALL_OW 266
42257: PUSH
42258: LD_INT 0
42260: EQUAL
42261: IFFALSE 42273
// dist := 28 else
42263: LD_ADDR_VAR 0 13
42267: PUSH
42268: LD_INT 28
42270: ST_TO_ADDR
42271: GO 42281
// dist := 36 ;
42273: LD_ADDR_VAR 0 13
42277: PUSH
42278: LD_INT 36
42280: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
42281: LD_VAR 0 1
42285: PPUSH
42286: LD_VAR 0 3
42290: PPUSH
42291: LD_VAR 0 4
42295: PPUSH
42296: CALL_OW 297
42300: PUSH
42301: LD_VAR 0 13
42305: GREATER
42306: IFFALSE 42310
// exit ;
42308: GO 42843
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
42310: LD_ADDR_VAR 0 11
42314: PUSH
42315: LD_VAR 0 2
42319: PPUSH
42320: LD_VAR 0 3
42324: PPUSH
42325: LD_VAR 0 4
42329: PPUSH
42330: LD_VAR 0 5
42334: PPUSH
42335: LD_VAR 0 1
42339: PPUSH
42340: CALL_OW 248
42344: PPUSH
42345: LD_INT 0
42347: PPUSH
42348: CALL 42848 0 6
42352: ST_TO_ADDR
// if not hexes then
42353: LD_VAR 0 11
42357: NOT
42358: IFFALSE 42362
// exit ;
42360: GO 42843
// hex := GetHexInfo ( x , y ) ;
42362: LD_ADDR_VAR 0 14
42366: PUSH
42367: LD_VAR 0 3
42371: PPUSH
42372: LD_VAR 0 4
42376: PPUSH
42377: CALL_OW 546
42381: ST_TO_ADDR
// if hex [ 1 ] then
42382: LD_VAR 0 14
42386: PUSH
42387: LD_INT 1
42389: ARRAY
42390: IFFALSE 42394
// exit ;
42392: GO 42843
// height := hex [ 2 ] ;
42394: LD_ADDR_VAR 0 12
42398: PUSH
42399: LD_VAR 0 14
42403: PUSH
42404: LD_INT 2
42406: ARRAY
42407: ST_TO_ADDR
// for i = 1 to hexes do
42408: LD_ADDR_VAR 0 7
42412: PUSH
42413: DOUBLE
42414: LD_INT 1
42416: DEC
42417: ST_TO_ADDR
42418: LD_VAR 0 11
42422: PUSH
42423: FOR_TO
42424: IFFALSE 42752
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
42426: LD_VAR 0 11
42430: PUSH
42431: LD_VAR 0 7
42435: ARRAY
42436: PUSH
42437: LD_INT 1
42439: ARRAY
42440: PPUSH
42441: LD_VAR 0 11
42445: PUSH
42446: LD_VAR 0 7
42450: ARRAY
42451: PUSH
42452: LD_INT 2
42454: ARRAY
42455: PPUSH
42456: CALL_OW 488
42460: NOT
42461: IFFALSE 42465
// continue ;
42463: GO 42423
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
42465: LD_ADDR_VAR 0 8
42469: PUSH
42470: LD_VAR 0 11
42474: PUSH
42475: LD_VAR 0 7
42479: ARRAY
42480: PUSH
42481: LD_INT 1
42483: ARRAY
42484: PPUSH
42485: LD_VAR 0 11
42489: PUSH
42490: LD_VAR 0 7
42494: ARRAY
42495: PUSH
42496: LD_INT 2
42498: ARRAY
42499: PPUSH
42500: CALL_OW 546
42504: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
42505: LD_VAR 0 8
42509: PUSH
42510: LD_INT 1
42512: ARRAY
42513: PUSH
42514: LD_VAR 0 8
42518: PUSH
42519: LD_INT 2
42521: ARRAY
42522: PUSH
42523: LD_VAR 0 12
42527: PUSH
42528: LD_INT 2
42530: PLUS
42531: GREATER
42532: OR
42533: PUSH
42534: LD_VAR 0 8
42538: PUSH
42539: LD_INT 2
42541: ARRAY
42542: PUSH
42543: LD_VAR 0 12
42547: PUSH
42548: LD_INT 2
42550: MINUS
42551: LESS
42552: OR
42553: PUSH
42554: LD_VAR 0 8
42558: PUSH
42559: LD_INT 3
42561: ARRAY
42562: PUSH
42563: LD_INT 0
42565: PUSH
42566: LD_INT 8
42568: PUSH
42569: LD_INT 9
42571: PUSH
42572: LD_INT 10
42574: PUSH
42575: LD_INT 11
42577: PUSH
42578: LD_INT 12
42580: PUSH
42581: LD_INT 13
42583: PUSH
42584: LD_INT 16
42586: PUSH
42587: LD_INT 17
42589: PUSH
42590: LD_INT 18
42592: PUSH
42593: LD_INT 19
42595: PUSH
42596: LD_INT 20
42598: PUSH
42599: LD_INT 21
42601: PUSH
42602: EMPTY
42603: LIST
42604: LIST
42605: LIST
42606: LIST
42607: LIST
42608: LIST
42609: LIST
42610: LIST
42611: LIST
42612: LIST
42613: LIST
42614: LIST
42615: LIST
42616: IN
42617: NOT
42618: OR
42619: PUSH
42620: LD_VAR 0 8
42624: PUSH
42625: LD_INT 5
42627: ARRAY
42628: NOT
42629: OR
42630: PUSH
42631: LD_VAR 0 8
42635: PUSH
42636: LD_INT 6
42638: ARRAY
42639: PUSH
42640: LD_INT 1
42642: PUSH
42643: LD_INT 2
42645: PUSH
42646: LD_INT 7
42648: PUSH
42649: LD_INT 9
42651: PUSH
42652: LD_INT 10
42654: PUSH
42655: LD_INT 11
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: IN
42666: NOT
42667: OR
42668: PUSH
42669: LD_VAR 0 11
42673: PUSH
42674: LD_VAR 0 7
42678: ARRAY
42679: PUSH
42680: LD_INT 1
42682: ARRAY
42683: PPUSH
42684: LD_VAR 0 11
42688: PUSH
42689: LD_VAR 0 7
42693: ARRAY
42694: PUSH
42695: LD_INT 2
42697: ARRAY
42698: PPUSH
42699: CALL_OW 428
42703: PUSH
42704: LD_INT 0
42706: GREATER
42707: OR
42708: PUSH
42709: LD_VAR 0 11
42713: PUSH
42714: LD_VAR 0 7
42718: ARRAY
42719: PUSH
42720: LD_INT 1
42722: ARRAY
42723: PPUSH
42724: LD_VAR 0 11
42728: PUSH
42729: LD_VAR 0 7
42733: ARRAY
42734: PUSH
42735: LD_INT 2
42737: ARRAY
42738: PPUSH
42739: CALL_OW 351
42743: OR
42744: IFFALSE 42750
// exit ;
42746: POP
42747: POP
42748: GO 42843
// end ;
42750: GO 42423
42752: POP
42753: POP
// if DangerAtRangeXY ( GetSide ( bdepot ) , x , y , 20 ) [ 4 ] then
42754: LD_VAR 0 1
42758: PPUSH
42759: CALL_OW 255
42763: PPUSH
42764: LD_VAR 0 3
42768: PPUSH
42769: LD_VAR 0 4
42773: PPUSH
42774: LD_INT 20
42776: PPUSH
42777: CALL 35702 0 4
42781: PUSH
42782: LD_INT 4
42784: ARRAY
42785: IFFALSE 42789
// exit ;
42787: GO 42843
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , GetSide ( bdepot ) ) then
42789: LD_VAR 0 2
42793: PUSH
42794: LD_INT 29
42796: PUSH
42797: LD_INT 30
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: IN
42804: PUSH
42805: LD_VAR 0 3
42809: PPUSH
42810: LD_VAR 0 4
42814: PPUSH
42815: LD_VAR 0 1
42819: PPUSH
42820: CALL_OW 255
42824: PPUSH
42825: CALL_OW 440
42829: NOT
42830: AND
42831: IFFALSE 42835
// exit ;
42833: GO 42843
// result := true ;
42835: LD_ADDR_VAR 0 6
42839: PUSH
42840: LD_INT 1
42842: ST_TO_ADDR
// end ;
42843: LD_VAR 0 6
42847: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
42848: LD_INT 0
42850: PPUSH
42851: PPUSH
42852: PPUSH
42853: PPUSH
42854: PPUSH
42855: PPUSH
42856: PPUSH
42857: PPUSH
42858: PPUSH
42859: PPUSH
42860: PPUSH
42861: PPUSH
42862: PPUSH
42863: PPUSH
42864: PPUSH
42865: PPUSH
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
42870: PPUSH
42871: PPUSH
42872: PPUSH
42873: PPUSH
42874: PPUSH
42875: PPUSH
42876: PPUSH
42877: PPUSH
42878: PPUSH
42879: PPUSH
42880: PPUSH
42881: PPUSH
42882: PPUSH
42883: PPUSH
42884: PPUSH
42885: PPUSH
42886: PPUSH
42887: PPUSH
42888: PPUSH
42889: PPUSH
42890: PPUSH
42891: PPUSH
42892: PPUSH
42893: PPUSH
42894: PPUSH
42895: PPUSH
42896: PPUSH
42897: PPUSH
42898: PPUSH
42899: PPUSH
42900: PPUSH
42901: PPUSH
42902: PPUSH
42903: PPUSH
42904: PPUSH
42905: PPUSH
42906: PPUSH
42907: PPUSH
// result = [ ] ;
42908: LD_ADDR_VAR 0 7
42912: PUSH
42913: EMPTY
42914: ST_TO_ADDR
// temp_list = [ ] ;
42915: LD_ADDR_VAR 0 9
42919: PUSH
42920: EMPTY
42921: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
42922: LD_VAR 0 4
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: LD_INT 1
42932: PUSH
42933: LD_INT 2
42935: PUSH
42936: LD_INT 3
42938: PUSH
42939: LD_INT 4
42941: PUSH
42942: LD_INT 5
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: LIST
42949: LIST
42950: LIST
42951: LIST
42952: IN
42953: NOT
42954: PUSH
42955: LD_VAR 0 1
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: LD_INT 1
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: IN
42970: PUSH
42971: LD_VAR 0 5
42975: PUSH
42976: LD_INT 1
42978: PUSH
42979: LD_INT 2
42981: PUSH
42982: LD_INT 3
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: LIST
42989: IN
42990: NOT
42991: AND
42992: OR
42993: IFFALSE 42997
// exit ;
42995: GO 61382
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
42997: LD_VAR 0 1
43001: PUSH
43002: LD_INT 6
43004: PUSH
43005: LD_INT 7
43007: PUSH
43008: LD_INT 8
43010: PUSH
43011: LD_INT 13
43013: PUSH
43014: LD_INT 12
43016: PUSH
43017: LD_INT 15
43019: PUSH
43020: LD_INT 11
43022: PUSH
43023: LD_INT 14
43025: PUSH
43026: LD_INT 10
43028: PUSH
43029: EMPTY
43030: LIST
43031: LIST
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: IN
43040: IFFALSE 43050
// btype = b_lab ;
43042: LD_ADDR_VAR 0 1
43046: PUSH
43047: LD_INT 6
43049: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
43050: LD_VAR 0 6
43054: PUSH
43055: LD_INT 0
43057: PUSH
43058: LD_INT 1
43060: PUSH
43061: LD_INT 2
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: LIST
43068: IN
43069: NOT
43070: PUSH
43071: LD_VAR 0 1
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: LD_INT 1
43081: PUSH
43082: LD_INT 2
43084: PUSH
43085: LD_INT 3
43087: PUSH
43088: LD_INT 6
43090: PUSH
43091: LD_INT 36
43093: PUSH
43094: LD_INT 4
43096: PUSH
43097: LD_INT 5
43099: PUSH
43100: LD_INT 31
43102: PUSH
43103: LD_INT 32
43105: PUSH
43106: LD_INT 33
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: LIST
43113: LIST
43114: LIST
43115: LIST
43116: LIST
43117: LIST
43118: LIST
43119: LIST
43120: LIST
43121: IN
43122: NOT
43123: PUSH
43124: LD_VAR 0 6
43128: PUSH
43129: LD_INT 1
43131: EQUAL
43132: AND
43133: OR
43134: PUSH
43135: LD_VAR 0 1
43139: PUSH
43140: LD_INT 2
43142: PUSH
43143: LD_INT 3
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: IN
43150: NOT
43151: PUSH
43152: LD_VAR 0 6
43156: PUSH
43157: LD_INT 2
43159: EQUAL
43160: AND
43161: OR
43162: IFFALSE 43172
// mode = 0 ;
43164: LD_ADDR_VAR 0 6
43168: PUSH
43169: LD_INT 0
43171: ST_TO_ADDR
// case mode of 0 :
43172: LD_VAR 0 6
43176: PUSH
43177: LD_INT 0
43179: DOUBLE
43180: EQUAL
43181: IFTRUE 43185
43183: GO 54638
43185: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43186: LD_ADDR_VAR 0 11
43190: PUSH
43191: LD_INT 0
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 0
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 1
43214: PUSH
43215: LD_INT 0
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 1
43224: PUSH
43225: LD_INT 1
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 0
43234: PUSH
43235: LD_INT 1
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 1
43244: NEG
43245: PUSH
43246: LD_INT 0
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: LD_INT 1
43255: NEG
43256: PUSH
43257: LD_INT 1
43259: NEG
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: PUSH
43265: LD_INT 1
43267: NEG
43268: PUSH
43269: LD_INT 2
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 0
43279: PUSH
43280: LD_INT 2
43282: NEG
43283: PUSH
43284: EMPTY
43285: LIST
43286: LIST
43287: PUSH
43288: LD_INT 1
43290: PUSH
43291: LD_INT 1
43293: NEG
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 1
43301: PUSH
43302: LD_INT 2
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 0
43311: PUSH
43312: LD_INT 2
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 1
43321: NEG
43322: PUSH
43323: LD_INT 1
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 3
43335: PUSH
43336: EMPTY
43337: LIST
43338: LIST
43339: PUSH
43340: LD_INT 0
43342: PUSH
43343: LD_INT 3
43345: PUSH
43346: EMPTY
43347: LIST
43348: LIST
43349: PUSH
43350: LD_INT 1
43352: NEG
43353: PUSH
43354: LD_INT 2
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43379: LD_ADDR_VAR 0 12
43383: PUSH
43384: LD_INT 0
43386: PUSH
43387: LD_INT 0
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 0
43396: PUSH
43397: LD_INT 1
43399: NEG
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: LD_INT 1
43407: PUSH
43408: LD_INT 0
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 1
43417: PUSH
43418: LD_INT 1
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PUSH
43425: LD_INT 0
43427: PUSH
43428: LD_INT 1
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 1
43437: NEG
43438: PUSH
43439: LD_INT 0
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: LD_INT 1
43452: NEG
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 1
43460: PUSH
43461: LD_INT 1
43463: NEG
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: PUSH
43469: LD_INT 2
43471: PUSH
43472: LD_INT 0
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 2
43481: PUSH
43482: LD_INT 1
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 1
43491: NEG
43492: PUSH
43493: LD_INT 1
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PUSH
43500: LD_INT 2
43502: NEG
43503: PUSH
43504: LD_INT 0
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 2
43513: NEG
43514: PUSH
43515: LD_INT 1
43517: NEG
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 2
43525: NEG
43526: PUSH
43527: LD_INT 1
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 3
43536: NEG
43537: PUSH
43538: LD_INT 0
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: PUSH
43545: LD_INT 3
43547: NEG
43548: PUSH
43549: LD_INT 1
43551: NEG
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43575: LD_ADDR_VAR 0 13
43579: PUSH
43580: LD_INT 0
43582: PUSH
43583: LD_INT 0
43585: PUSH
43586: EMPTY
43587: LIST
43588: LIST
43589: PUSH
43590: LD_INT 0
43592: PUSH
43593: LD_INT 1
43595: NEG
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PUSH
43601: LD_INT 1
43603: PUSH
43604: LD_INT 0
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 1
43613: PUSH
43614: LD_INT 1
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: LD_INT 1
43626: PUSH
43627: EMPTY
43628: LIST
43629: LIST
43630: PUSH
43631: LD_INT 1
43633: NEG
43634: PUSH
43635: LD_INT 0
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: LD_INT 1
43644: NEG
43645: PUSH
43646: LD_INT 1
43648: NEG
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 1
43656: NEG
43657: PUSH
43658: LD_INT 2
43660: NEG
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: LD_INT 2
43668: PUSH
43669: LD_INT 1
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 2
43678: PUSH
43679: LD_INT 2
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 1
43688: PUSH
43689: LD_INT 2
43691: PUSH
43692: EMPTY
43693: LIST
43694: LIST
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: LD_INT 1
43702: NEG
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: PUSH
43708: LD_INT 2
43710: NEG
43711: PUSH
43712: LD_INT 2
43714: NEG
43715: PUSH
43716: EMPTY
43717: LIST
43718: LIST
43719: PUSH
43720: LD_INT 2
43722: NEG
43723: PUSH
43724: LD_INT 3
43726: NEG
43727: PUSH
43728: EMPTY
43729: LIST
43730: LIST
43731: PUSH
43732: LD_INT 3
43734: NEG
43735: PUSH
43736: LD_INT 2
43738: NEG
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 3
43746: NEG
43747: PUSH
43748: LD_INT 3
43750: NEG
43751: PUSH
43752: EMPTY
43753: LIST
43754: LIST
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: LIST
43762: LIST
43763: LIST
43764: LIST
43765: LIST
43766: LIST
43767: LIST
43768: LIST
43769: LIST
43770: LIST
43771: LIST
43772: LIST
43773: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43774: LD_ADDR_VAR 0 14
43778: PUSH
43779: LD_INT 0
43781: PUSH
43782: LD_INT 0
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 0
43791: PUSH
43792: LD_INT 1
43794: NEG
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 1
43802: PUSH
43803: LD_INT 0
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: LD_INT 1
43812: PUSH
43813: LD_INT 1
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 0
43822: PUSH
43823: LD_INT 1
43825: PUSH
43826: EMPTY
43827: LIST
43828: LIST
43829: PUSH
43830: LD_INT 1
43832: NEG
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: EMPTY
43838: LIST
43839: LIST
43840: PUSH
43841: LD_INT 1
43843: NEG
43844: PUSH
43845: LD_INT 1
43847: NEG
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 1
43855: NEG
43856: PUSH
43857: LD_INT 2
43859: NEG
43860: PUSH
43861: EMPTY
43862: LIST
43863: LIST
43864: PUSH
43865: LD_INT 0
43867: PUSH
43868: LD_INT 2
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 1
43878: PUSH
43879: LD_INT 1
43881: NEG
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 1
43889: PUSH
43890: LD_INT 2
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 0
43899: PUSH
43900: LD_INT 2
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 1
43909: NEG
43910: PUSH
43911: LD_INT 1
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 1
43920: NEG
43921: PUSH
43922: LD_INT 3
43924: NEG
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PUSH
43930: LD_INT 0
43932: PUSH
43933: LD_INT 3
43935: NEG
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 1
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: EMPTY
43949: LIST
43950: LIST
43951: PUSH
43952: EMPTY
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: LIST
43968: LIST
43969: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43970: LD_ADDR_VAR 0 15
43974: PUSH
43975: LD_INT 0
43977: PUSH
43978: LD_INT 0
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 0
43987: PUSH
43988: LD_INT 1
43990: NEG
43991: PUSH
43992: EMPTY
43993: LIST
43994: LIST
43995: PUSH
43996: LD_INT 1
43998: PUSH
43999: LD_INT 0
44001: PUSH
44002: EMPTY
44003: LIST
44004: LIST
44005: PUSH
44006: LD_INT 1
44008: PUSH
44009: LD_INT 1
44011: PUSH
44012: EMPTY
44013: LIST
44014: LIST
44015: PUSH
44016: LD_INT 0
44018: PUSH
44019: LD_INT 1
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 1
44028: NEG
44029: PUSH
44030: LD_INT 0
44032: PUSH
44033: EMPTY
44034: LIST
44035: LIST
44036: PUSH
44037: LD_INT 1
44039: NEG
44040: PUSH
44041: LD_INT 1
44043: NEG
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 1
44051: PUSH
44052: LD_INT 1
44054: NEG
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 2
44062: PUSH
44063: LD_INT 0
44065: PUSH
44066: EMPTY
44067: LIST
44068: LIST
44069: PUSH
44070: LD_INT 2
44072: PUSH
44073: LD_INT 1
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 1
44082: NEG
44083: PUSH
44084: LD_INT 1
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 2
44093: NEG
44094: PUSH
44095: LD_INT 0
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 2
44104: NEG
44105: PUSH
44106: LD_INT 1
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 2
44116: PUSH
44117: LD_INT 1
44119: NEG
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: LD_INT 3
44127: PUSH
44128: LD_INT 0
44130: PUSH
44131: EMPTY
44132: LIST
44133: LIST
44134: PUSH
44135: LD_INT 3
44137: PUSH
44138: LD_INT 1
44140: PUSH
44141: EMPTY
44142: LIST
44143: LIST
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: LIST
44149: LIST
44150: LIST
44151: LIST
44152: LIST
44153: LIST
44154: LIST
44155: LIST
44156: LIST
44157: LIST
44158: LIST
44159: LIST
44160: LIST
44161: LIST
44162: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44163: LD_ADDR_VAR 0 16
44167: PUSH
44168: LD_INT 0
44170: PUSH
44171: LD_INT 0
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 0
44180: PUSH
44181: LD_INT 1
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: PUSH
44192: LD_INT 0
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 1
44201: PUSH
44202: LD_INT 1
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 0
44211: PUSH
44212: LD_INT 1
44214: PUSH
44215: EMPTY
44216: LIST
44217: LIST
44218: PUSH
44219: LD_INT 1
44221: NEG
44222: PUSH
44223: LD_INT 0
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 1
44232: NEG
44233: PUSH
44234: LD_INT 1
44236: NEG
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 1
44244: NEG
44245: PUSH
44246: LD_INT 2
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 2
44256: PUSH
44257: LD_INT 1
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 2
44266: PUSH
44267: LD_INT 2
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 1
44276: PUSH
44277: LD_INT 2
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: LD_INT 2
44286: NEG
44287: PUSH
44288: LD_INT 1
44290: NEG
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 2
44298: NEG
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 3
44310: PUSH
44311: LD_INT 2
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 3
44320: PUSH
44321: LD_INT 3
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: LD_INT 2
44330: PUSH
44331: LD_INT 3
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: LIST
44342: LIST
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44356: LD_ADDR_VAR 0 17
44360: PUSH
44361: LD_INT 0
44363: PUSH
44364: LD_INT 0
44366: PUSH
44367: EMPTY
44368: LIST
44369: LIST
44370: PUSH
44371: LD_INT 0
44373: PUSH
44374: LD_INT 1
44376: NEG
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 1
44384: PUSH
44385: LD_INT 0
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 1
44394: PUSH
44395: LD_INT 1
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: PUSH
44402: LD_INT 0
44404: PUSH
44405: LD_INT 1
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 1
44414: NEG
44415: PUSH
44416: LD_INT 0
44418: PUSH
44419: EMPTY
44420: LIST
44421: LIST
44422: PUSH
44423: LD_INT 1
44425: NEG
44426: PUSH
44427: LD_INT 1
44429: NEG
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 1
44437: NEG
44438: PUSH
44439: LD_INT 2
44441: NEG
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 0
44449: PUSH
44450: LD_INT 2
44452: NEG
44453: PUSH
44454: EMPTY
44455: LIST
44456: LIST
44457: PUSH
44458: LD_INT 1
44460: PUSH
44461: LD_INT 1
44463: NEG
44464: PUSH
44465: EMPTY
44466: LIST
44467: LIST
44468: PUSH
44469: LD_INT 2
44471: PUSH
44472: LD_INT 0
44474: PUSH
44475: EMPTY
44476: LIST
44477: LIST
44478: PUSH
44479: LD_INT 2
44481: PUSH
44482: LD_INT 1
44484: PUSH
44485: EMPTY
44486: LIST
44487: LIST
44488: PUSH
44489: LD_INT 2
44491: PUSH
44492: LD_INT 2
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: PUSH
44499: LD_INT 1
44501: PUSH
44502: LD_INT 2
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 0
44511: PUSH
44512: LD_INT 2
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 1
44521: NEG
44522: PUSH
44523: LD_INT 1
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 2
44532: NEG
44533: PUSH
44534: LD_INT 0
44536: PUSH
44537: EMPTY
44538: LIST
44539: LIST
44540: PUSH
44541: LD_INT 2
44543: NEG
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: EMPTY
44550: LIST
44551: LIST
44552: PUSH
44553: LD_INT 2
44555: NEG
44556: PUSH
44557: LD_INT 2
44559: NEG
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: LIST
44578: LIST
44579: LIST
44580: LIST
44581: LIST
44582: LIST
44583: LIST
44584: LIST
44585: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44586: LD_ADDR_VAR 0 18
44590: PUSH
44591: LD_INT 0
44593: PUSH
44594: LD_INT 0
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 0
44603: PUSH
44604: LD_INT 1
44606: NEG
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 1
44614: PUSH
44615: LD_INT 0
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PUSH
44622: LD_INT 1
44624: PUSH
44625: LD_INT 1
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 0
44634: PUSH
44635: LD_INT 1
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 1
44644: NEG
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 1
44655: NEG
44656: PUSH
44657: LD_INT 1
44659: NEG
44660: PUSH
44661: EMPTY
44662: LIST
44663: LIST
44664: PUSH
44665: LD_INT 1
44667: NEG
44668: PUSH
44669: LD_INT 2
44671: NEG
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 0
44679: PUSH
44680: LD_INT 2
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 1
44690: PUSH
44691: LD_INT 1
44693: NEG
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 2
44701: PUSH
44702: LD_INT 0
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 2
44711: PUSH
44712: LD_INT 1
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 2
44721: PUSH
44722: LD_INT 2
44724: PUSH
44725: EMPTY
44726: LIST
44727: LIST
44728: PUSH
44729: LD_INT 1
44731: PUSH
44732: LD_INT 2
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 0
44741: PUSH
44742: LD_INT 2
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: PUSH
44749: LD_INT 1
44751: NEG
44752: PUSH
44753: LD_INT 1
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 2
44762: NEG
44763: PUSH
44764: LD_INT 0
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 2
44773: NEG
44774: PUSH
44775: LD_INT 1
44777: NEG
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 2
44785: NEG
44786: PUSH
44787: LD_INT 2
44789: NEG
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: EMPTY
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
44816: LD_ADDR_VAR 0 19
44820: PUSH
44821: LD_INT 0
44823: PUSH
44824: LD_INT 0
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: LD_INT 1
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 1
44844: PUSH
44845: LD_INT 0
44847: PUSH
44848: EMPTY
44849: LIST
44850: LIST
44851: PUSH
44852: LD_INT 1
44854: PUSH
44855: LD_INT 1
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: LD_INT 0
44864: PUSH
44865: LD_INT 1
44867: PUSH
44868: EMPTY
44869: LIST
44870: LIST
44871: PUSH
44872: LD_INT 1
44874: NEG
44875: PUSH
44876: LD_INT 0
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 1
44885: NEG
44886: PUSH
44887: LD_INT 1
44889: NEG
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 1
44897: NEG
44898: PUSH
44899: LD_INT 2
44901: NEG
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: LD_INT 0
44909: PUSH
44910: LD_INT 2
44912: NEG
44913: PUSH
44914: EMPTY
44915: LIST
44916: LIST
44917: PUSH
44918: LD_INT 1
44920: PUSH
44921: LD_INT 1
44923: NEG
44924: PUSH
44925: EMPTY
44926: LIST
44927: LIST
44928: PUSH
44929: LD_INT 2
44931: PUSH
44932: LD_INT 0
44934: PUSH
44935: EMPTY
44936: LIST
44937: LIST
44938: PUSH
44939: LD_INT 2
44941: PUSH
44942: LD_INT 1
44944: PUSH
44945: EMPTY
44946: LIST
44947: LIST
44948: PUSH
44949: LD_INT 2
44951: PUSH
44952: LD_INT 2
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: PUSH
44959: LD_INT 1
44961: PUSH
44962: LD_INT 2
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 0
44971: PUSH
44972: LD_INT 2
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: LD_INT 1
44981: NEG
44982: PUSH
44983: LD_INT 1
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 2
44992: NEG
44993: PUSH
44994: LD_INT 0
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: LD_INT 2
45003: NEG
45004: PUSH
45005: LD_INT 1
45007: NEG
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 2
45015: NEG
45016: PUSH
45017: LD_INT 2
45019: NEG
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: LIST
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45046: LD_ADDR_VAR 0 20
45050: PUSH
45051: LD_INT 0
45053: PUSH
45054: LD_INT 0
45056: PUSH
45057: EMPTY
45058: LIST
45059: LIST
45060: PUSH
45061: LD_INT 0
45063: PUSH
45064: LD_INT 1
45066: NEG
45067: PUSH
45068: EMPTY
45069: LIST
45070: LIST
45071: PUSH
45072: LD_INT 1
45074: PUSH
45075: LD_INT 0
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PUSH
45082: LD_INT 1
45084: PUSH
45085: LD_INT 1
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: PUSH
45092: LD_INT 0
45094: PUSH
45095: LD_INT 1
45097: PUSH
45098: EMPTY
45099: LIST
45100: LIST
45101: PUSH
45102: LD_INT 1
45104: NEG
45105: PUSH
45106: LD_INT 0
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 1
45115: NEG
45116: PUSH
45117: LD_INT 1
45119: NEG
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 1
45127: NEG
45128: PUSH
45129: LD_INT 2
45131: NEG
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 0
45139: PUSH
45140: LD_INT 2
45142: NEG
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 1
45150: PUSH
45151: LD_INT 1
45153: NEG
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 2
45161: PUSH
45162: LD_INT 0
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 2
45171: PUSH
45172: LD_INT 1
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 2
45181: PUSH
45182: LD_INT 2
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 1
45191: PUSH
45192: LD_INT 2
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 0
45201: PUSH
45202: LD_INT 2
45204: PUSH
45205: EMPTY
45206: LIST
45207: LIST
45208: PUSH
45209: LD_INT 1
45211: NEG
45212: PUSH
45213: LD_INT 1
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 2
45222: NEG
45223: PUSH
45224: LD_INT 0
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 2
45233: NEG
45234: PUSH
45235: LD_INT 1
45237: NEG
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PUSH
45243: LD_INT 2
45245: NEG
45246: PUSH
45247: LD_INT 2
45249: NEG
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: EMPTY
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45276: LD_ADDR_VAR 0 21
45280: PUSH
45281: LD_INT 0
45283: PUSH
45284: LD_INT 0
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 0
45293: PUSH
45294: LD_INT 1
45296: NEG
45297: PUSH
45298: EMPTY
45299: LIST
45300: LIST
45301: PUSH
45302: LD_INT 1
45304: PUSH
45305: LD_INT 0
45307: PUSH
45308: EMPTY
45309: LIST
45310: LIST
45311: PUSH
45312: LD_INT 1
45314: PUSH
45315: LD_INT 1
45317: PUSH
45318: EMPTY
45319: LIST
45320: LIST
45321: PUSH
45322: LD_INT 0
45324: PUSH
45325: LD_INT 1
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 1
45334: NEG
45335: PUSH
45336: LD_INT 0
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 1
45345: NEG
45346: PUSH
45347: LD_INT 1
45349: NEG
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 1
45357: NEG
45358: PUSH
45359: LD_INT 2
45361: NEG
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 0
45369: PUSH
45370: LD_INT 2
45372: NEG
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: PUSH
45378: LD_INT 1
45380: PUSH
45381: LD_INT 1
45383: NEG
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 2
45391: PUSH
45392: LD_INT 0
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 2
45401: PUSH
45402: LD_INT 1
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 2
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: EMPTY
45416: LIST
45417: LIST
45418: PUSH
45419: LD_INT 1
45421: PUSH
45422: LD_INT 2
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 0
45431: PUSH
45432: LD_INT 2
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: LD_INT 1
45441: NEG
45442: PUSH
45443: LD_INT 1
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PUSH
45450: LD_INT 2
45452: NEG
45453: PUSH
45454: LD_INT 0
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 2
45463: NEG
45464: PUSH
45465: LD_INT 1
45467: NEG
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 2
45475: NEG
45476: PUSH
45477: LD_INT 2
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
45506: LD_ADDR_VAR 0 22
45510: PUSH
45511: LD_INT 0
45513: PUSH
45514: LD_INT 0
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 0
45523: PUSH
45524: LD_INT 1
45526: NEG
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PUSH
45532: LD_INT 1
45534: PUSH
45535: LD_INT 0
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 1
45544: PUSH
45545: LD_INT 1
45547: PUSH
45548: EMPTY
45549: LIST
45550: LIST
45551: PUSH
45552: LD_INT 0
45554: PUSH
45555: LD_INT 1
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: LD_INT 0
45568: PUSH
45569: EMPTY
45570: LIST
45571: LIST
45572: PUSH
45573: LD_INT 1
45575: NEG
45576: PUSH
45577: LD_INT 1
45579: NEG
45580: PUSH
45581: EMPTY
45582: LIST
45583: LIST
45584: PUSH
45585: LD_INT 1
45587: NEG
45588: PUSH
45589: LD_INT 2
45591: NEG
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 0
45599: PUSH
45600: LD_INT 2
45602: NEG
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: LD_INT 1
45610: PUSH
45611: LD_INT 1
45613: NEG
45614: PUSH
45615: EMPTY
45616: LIST
45617: LIST
45618: PUSH
45619: LD_INT 2
45621: PUSH
45622: LD_INT 0
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 2
45631: PUSH
45632: LD_INT 1
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 2
45641: PUSH
45642: LD_INT 2
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 1
45651: PUSH
45652: LD_INT 2
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 0
45661: PUSH
45662: LD_INT 2
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 1
45671: NEG
45672: PUSH
45673: LD_INT 1
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: LD_INT 2
45682: NEG
45683: PUSH
45684: LD_INT 0
45686: PUSH
45687: EMPTY
45688: LIST
45689: LIST
45690: PUSH
45691: LD_INT 2
45693: NEG
45694: PUSH
45695: LD_INT 1
45697: NEG
45698: PUSH
45699: EMPTY
45700: LIST
45701: LIST
45702: PUSH
45703: LD_INT 2
45705: NEG
45706: PUSH
45707: LD_INT 2
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: EMPTY
45716: LIST
45717: LIST
45718: LIST
45719: LIST
45720: LIST
45721: LIST
45722: LIST
45723: LIST
45724: LIST
45725: LIST
45726: LIST
45727: LIST
45728: LIST
45729: LIST
45730: LIST
45731: LIST
45732: LIST
45733: LIST
45734: LIST
45735: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45736: LD_ADDR_VAR 0 23
45740: PUSH
45741: LD_INT 0
45743: PUSH
45744: LD_INT 0
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PUSH
45751: LD_INT 0
45753: PUSH
45754: LD_INT 1
45756: NEG
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 1
45764: PUSH
45765: LD_INT 0
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: LD_INT 1
45774: PUSH
45775: LD_INT 1
45777: PUSH
45778: EMPTY
45779: LIST
45780: LIST
45781: PUSH
45782: LD_INT 0
45784: PUSH
45785: LD_INT 1
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 1
45794: NEG
45795: PUSH
45796: LD_INT 0
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 1
45805: NEG
45806: PUSH
45807: LD_INT 1
45809: NEG
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 1
45817: NEG
45818: PUSH
45819: LD_INT 2
45821: NEG
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 0
45829: PUSH
45830: LD_INT 2
45832: NEG
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 1
45840: PUSH
45841: LD_INT 1
45843: NEG
45844: PUSH
45845: EMPTY
45846: LIST
45847: LIST
45848: PUSH
45849: LD_INT 2
45851: PUSH
45852: LD_INT 0
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 2
45861: PUSH
45862: LD_INT 1
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: PUSH
45869: LD_INT 2
45871: PUSH
45872: LD_INT 2
45874: PUSH
45875: EMPTY
45876: LIST
45877: LIST
45878: PUSH
45879: LD_INT 1
45881: PUSH
45882: LD_INT 2
45884: PUSH
45885: EMPTY
45886: LIST
45887: LIST
45888: PUSH
45889: LD_INT 0
45891: PUSH
45892: LD_INT 2
45894: PUSH
45895: EMPTY
45896: LIST
45897: LIST
45898: PUSH
45899: LD_INT 1
45901: NEG
45902: PUSH
45903: LD_INT 1
45905: PUSH
45906: EMPTY
45907: LIST
45908: LIST
45909: PUSH
45910: LD_INT 2
45912: NEG
45913: PUSH
45914: LD_INT 0
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 2
45923: NEG
45924: PUSH
45925: LD_INT 1
45927: NEG
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 2
45935: NEG
45936: PUSH
45937: LD_INT 2
45939: NEG
45940: PUSH
45941: EMPTY
45942: LIST
45943: LIST
45944: PUSH
45945: LD_INT 2
45947: NEG
45948: PUSH
45949: LD_INT 3
45951: NEG
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: PUSH
45957: LD_INT 1
45959: NEG
45960: PUSH
45961: LD_INT 3
45963: NEG
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 1
45971: PUSH
45972: LD_INT 2
45974: NEG
45975: PUSH
45976: EMPTY
45977: LIST
45978: LIST
45979: PUSH
45980: LD_INT 2
45982: PUSH
45983: LD_INT 1
45985: NEG
45986: PUSH
45987: EMPTY
45988: LIST
45989: LIST
45990: PUSH
45991: EMPTY
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
46016: LD_ADDR_VAR 0 24
46020: PUSH
46021: LD_INT 0
46023: PUSH
46024: LD_INT 0
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 0
46033: PUSH
46034: LD_INT 1
46036: NEG
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: LD_INT 1
46044: PUSH
46045: LD_INT 0
46047: PUSH
46048: EMPTY
46049: LIST
46050: LIST
46051: PUSH
46052: LD_INT 1
46054: PUSH
46055: LD_INT 1
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: LD_INT 0
46064: PUSH
46065: LD_INT 1
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 1
46074: NEG
46075: PUSH
46076: LD_INT 0
46078: PUSH
46079: EMPTY
46080: LIST
46081: LIST
46082: PUSH
46083: LD_INT 1
46085: NEG
46086: PUSH
46087: LD_INT 1
46089: NEG
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 1
46097: NEG
46098: PUSH
46099: LD_INT 2
46101: NEG
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: PUSH
46107: LD_INT 0
46109: PUSH
46110: LD_INT 2
46112: NEG
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 1
46120: PUSH
46121: LD_INT 1
46123: NEG
46124: PUSH
46125: EMPTY
46126: LIST
46127: LIST
46128: PUSH
46129: LD_INT 2
46131: PUSH
46132: LD_INT 0
46134: PUSH
46135: EMPTY
46136: LIST
46137: LIST
46138: PUSH
46139: LD_INT 2
46141: PUSH
46142: LD_INT 1
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 2
46151: PUSH
46152: LD_INT 2
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 1
46161: PUSH
46162: LD_INT 2
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 0
46171: PUSH
46172: LD_INT 2
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 1
46181: NEG
46182: PUSH
46183: LD_INT 1
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 2
46192: NEG
46193: PUSH
46194: LD_INT 0
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 2
46203: NEG
46204: PUSH
46205: LD_INT 1
46207: NEG
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 2
46215: NEG
46216: PUSH
46217: LD_INT 2
46219: NEG
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 1
46227: PUSH
46228: LD_INT 2
46230: NEG
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 2
46238: PUSH
46239: LD_INT 1
46241: NEG
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: PUSH
46247: LD_INT 3
46249: PUSH
46250: LD_INT 1
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 3
46259: PUSH
46260: LD_INT 2
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: LIST
46271: LIST
46272: LIST
46273: LIST
46274: LIST
46275: LIST
46276: LIST
46277: LIST
46278: LIST
46279: LIST
46280: LIST
46281: LIST
46282: LIST
46283: LIST
46284: LIST
46285: LIST
46286: LIST
46287: LIST
46288: LIST
46289: LIST
46290: LIST
46291: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
46292: LD_ADDR_VAR 0 25
46296: PUSH
46297: LD_INT 0
46299: PUSH
46300: LD_INT 0
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 0
46309: PUSH
46310: LD_INT 1
46312: NEG
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: LD_INT 1
46320: PUSH
46321: LD_INT 0
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 1
46330: PUSH
46331: LD_INT 1
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 0
46340: PUSH
46341: LD_INT 1
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 1
46350: NEG
46351: PUSH
46352: LD_INT 0
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: LD_INT 1
46361: NEG
46362: PUSH
46363: LD_INT 1
46365: NEG
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 1
46373: NEG
46374: PUSH
46375: LD_INT 2
46377: NEG
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: LD_INT 0
46385: PUSH
46386: LD_INT 2
46388: NEG
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: PUSH
46394: LD_INT 1
46396: PUSH
46397: LD_INT 1
46399: NEG
46400: PUSH
46401: EMPTY
46402: LIST
46403: LIST
46404: PUSH
46405: LD_INT 2
46407: PUSH
46408: LD_INT 0
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: PUSH
46415: LD_INT 2
46417: PUSH
46418: LD_INT 1
46420: PUSH
46421: EMPTY
46422: LIST
46423: LIST
46424: PUSH
46425: LD_INT 2
46427: PUSH
46428: LD_INT 2
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: LD_INT 1
46437: PUSH
46438: LD_INT 2
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 0
46447: PUSH
46448: LD_INT 2
46450: PUSH
46451: EMPTY
46452: LIST
46453: LIST
46454: PUSH
46455: LD_INT 1
46457: NEG
46458: PUSH
46459: LD_INT 1
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: LD_INT 2
46468: NEG
46469: PUSH
46470: LD_INT 0
46472: PUSH
46473: EMPTY
46474: LIST
46475: LIST
46476: PUSH
46477: LD_INT 2
46479: NEG
46480: PUSH
46481: LD_INT 1
46483: NEG
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 2
46491: NEG
46492: PUSH
46493: LD_INT 2
46495: NEG
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 3
46503: PUSH
46504: LD_INT 1
46506: PUSH
46507: EMPTY
46508: LIST
46509: LIST
46510: PUSH
46511: LD_INT 3
46513: PUSH
46514: LD_INT 2
46516: PUSH
46517: EMPTY
46518: LIST
46519: LIST
46520: PUSH
46521: LD_INT 2
46523: PUSH
46524: LD_INT 3
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: PUSH
46531: LD_INT 1
46533: PUSH
46534: LD_INT 3
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: EMPTY
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
46566: LD_ADDR_VAR 0 26
46570: PUSH
46571: LD_INT 0
46573: PUSH
46574: LD_INT 0
46576: PUSH
46577: EMPTY
46578: LIST
46579: LIST
46580: PUSH
46581: LD_INT 0
46583: PUSH
46584: LD_INT 1
46586: NEG
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 1
46594: PUSH
46595: LD_INT 0
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: PUSH
46602: LD_INT 1
46604: PUSH
46605: LD_INT 1
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: LD_INT 0
46614: PUSH
46615: LD_INT 1
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: LD_INT 1
46624: NEG
46625: PUSH
46626: LD_INT 0
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 1
46635: NEG
46636: PUSH
46637: LD_INT 1
46639: NEG
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_INT 1
46647: NEG
46648: PUSH
46649: LD_INT 2
46651: NEG
46652: PUSH
46653: EMPTY
46654: LIST
46655: LIST
46656: PUSH
46657: LD_INT 0
46659: PUSH
46660: LD_INT 2
46662: NEG
46663: PUSH
46664: EMPTY
46665: LIST
46666: LIST
46667: PUSH
46668: LD_INT 1
46670: PUSH
46671: LD_INT 1
46673: NEG
46674: PUSH
46675: EMPTY
46676: LIST
46677: LIST
46678: PUSH
46679: LD_INT 2
46681: PUSH
46682: LD_INT 0
46684: PUSH
46685: EMPTY
46686: LIST
46687: LIST
46688: PUSH
46689: LD_INT 2
46691: PUSH
46692: LD_INT 1
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 2
46701: PUSH
46702: LD_INT 2
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 1
46711: PUSH
46712: LD_INT 2
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 0
46721: PUSH
46722: LD_INT 2
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 1
46731: NEG
46732: PUSH
46733: LD_INT 1
46735: PUSH
46736: EMPTY
46737: LIST
46738: LIST
46739: PUSH
46740: LD_INT 2
46742: NEG
46743: PUSH
46744: LD_INT 0
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 2
46753: NEG
46754: PUSH
46755: LD_INT 1
46757: NEG
46758: PUSH
46759: EMPTY
46760: LIST
46761: LIST
46762: PUSH
46763: LD_INT 2
46765: NEG
46766: PUSH
46767: LD_INT 2
46769: NEG
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: PUSH
46775: LD_INT 2
46777: PUSH
46778: LD_INT 3
46780: PUSH
46781: EMPTY
46782: LIST
46783: LIST
46784: PUSH
46785: LD_INT 1
46787: PUSH
46788: LD_INT 3
46790: PUSH
46791: EMPTY
46792: LIST
46793: LIST
46794: PUSH
46795: LD_INT 1
46797: NEG
46798: PUSH
46799: LD_INT 2
46801: PUSH
46802: EMPTY
46803: LIST
46804: LIST
46805: PUSH
46806: LD_INT 2
46808: NEG
46809: PUSH
46810: LD_INT 1
46812: PUSH
46813: EMPTY
46814: LIST
46815: LIST
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: LIST
46826: LIST
46827: LIST
46828: LIST
46829: LIST
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: LIST
46840: LIST
46841: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
46842: LD_ADDR_VAR 0 27
46846: PUSH
46847: LD_INT 0
46849: PUSH
46850: LD_INT 0
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 0
46859: PUSH
46860: LD_INT 1
46862: NEG
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 1
46870: PUSH
46871: LD_INT 0
46873: PUSH
46874: EMPTY
46875: LIST
46876: LIST
46877: PUSH
46878: LD_INT 1
46880: PUSH
46881: LD_INT 1
46883: PUSH
46884: EMPTY
46885: LIST
46886: LIST
46887: PUSH
46888: LD_INT 0
46890: PUSH
46891: LD_INT 1
46893: PUSH
46894: EMPTY
46895: LIST
46896: LIST
46897: PUSH
46898: LD_INT 1
46900: NEG
46901: PUSH
46902: LD_INT 0
46904: PUSH
46905: EMPTY
46906: LIST
46907: LIST
46908: PUSH
46909: LD_INT 1
46911: NEG
46912: PUSH
46913: LD_INT 1
46915: NEG
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PUSH
46921: LD_INT 1
46923: NEG
46924: PUSH
46925: LD_INT 2
46927: NEG
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 0
46935: PUSH
46936: LD_INT 2
46938: NEG
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PUSH
46944: LD_INT 1
46946: PUSH
46947: LD_INT 1
46949: NEG
46950: PUSH
46951: EMPTY
46952: LIST
46953: LIST
46954: PUSH
46955: LD_INT 2
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 2
46967: PUSH
46968: LD_INT 1
46970: PUSH
46971: EMPTY
46972: LIST
46973: LIST
46974: PUSH
46975: LD_INT 2
46977: PUSH
46978: LD_INT 2
46980: PUSH
46981: EMPTY
46982: LIST
46983: LIST
46984: PUSH
46985: LD_INT 1
46987: PUSH
46988: LD_INT 2
46990: PUSH
46991: EMPTY
46992: LIST
46993: LIST
46994: PUSH
46995: LD_INT 0
46997: PUSH
46998: LD_INT 2
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: PUSH
47005: LD_INT 1
47007: NEG
47008: PUSH
47009: LD_INT 1
47011: PUSH
47012: EMPTY
47013: LIST
47014: LIST
47015: PUSH
47016: LD_INT 2
47018: NEG
47019: PUSH
47020: LD_INT 0
47022: PUSH
47023: EMPTY
47024: LIST
47025: LIST
47026: PUSH
47027: LD_INT 2
47029: NEG
47030: PUSH
47031: LD_INT 1
47033: NEG
47034: PUSH
47035: EMPTY
47036: LIST
47037: LIST
47038: PUSH
47039: LD_INT 2
47041: NEG
47042: PUSH
47043: LD_INT 2
47045: NEG
47046: PUSH
47047: EMPTY
47048: LIST
47049: LIST
47050: PUSH
47051: LD_INT 1
47053: NEG
47054: PUSH
47055: LD_INT 2
47057: PUSH
47058: EMPTY
47059: LIST
47060: LIST
47061: PUSH
47062: LD_INT 2
47064: NEG
47065: PUSH
47066: LD_INT 1
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PUSH
47073: LD_INT 3
47075: NEG
47076: PUSH
47077: LD_INT 1
47079: NEG
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: PUSH
47085: LD_INT 3
47087: NEG
47088: PUSH
47089: LD_INT 2
47091: NEG
47092: PUSH
47093: EMPTY
47094: LIST
47095: LIST
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
47122: LD_ADDR_VAR 0 28
47126: PUSH
47127: LD_INT 0
47129: PUSH
47130: LD_INT 0
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 0
47139: PUSH
47140: LD_INT 1
47142: NEG
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: LD_INT 1
47150: PUSH
47151: LD_INT 0
47153: PUSH
47154: EMPTY
47155: LIST
47156: LIST
47157: PUSH
47158: LD_INT 1
47160: PUSH
47161: LD_INT 1
47163: PUSH
47164: EMPTY
47165: LIST
47166: LIST
47167: PUSH
47168: LD_INT 0
47170: PUSH
47171: LD_INT 1
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 1
47180: NEG
47181: PUSH
47182: LD_INT 0
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: LD_INT 1
47191: NEG
47192: PUSH
47193: LD_INT 1
47195: NEG
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 1
47203: NEG
47204: PUSH
47205: LD_INT 2
47207: NEG
47208: PUSH
47209: EMPTY
47210: LIST
47211: LIST
47212: PUSH
47213: LD_INT 0
47215: PUSH
47216: LD_INT 2
47218: NEG
47219: PUSH
47220: EMPTY
47221: LIST
47222: LIST
47223: PUSH
47224: LD_INT 1
47226: PUSH
47227: LD_INT 1
47229: NEG
47230: PUSH
47231: EMPTY
47232: LIST
47233: LIST
47234: PUSH
47235: LD_INT 2
47237: PUSH
47238: LD_INT 0
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: LD_INT 2
47247: PUSH
47248: LD_INT 1
47250: PUSH
47251: EMPTY
47252: LIST
47253: LIST
47254: PUSH
47255: LD_INT 2
47257: PUSH
47258: LD_INT 2
47260: PUSH
47261: EMPTY
47262: LIST
47263: LIST
47264: PUSH
47265: LD_INT 1
47267: PUSH
47268: LD_INT 2
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: PUSH
47275: LD_INT 0
47277: PUSH
47278: LD_INT 2
47280: PUSH
47281: EMPTY
47282: LIST
47283: LIST
47284: PUSH
47285: LD_INT 1
47287: NEG
47288: PUSH
47289: LD_INT 1
47291: PUSH
47292: EMPTY
47293: LIST
47294: LIST
47295: PUSH
47296: LD_INT 2
47298: NEG
47299: PUSH
47300: LD_INT 0
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: PUSH
47307: LD_INT 2
47309: NEG
47310: PUSH
47311: LD_INT 1
47313: NEG
47314: PUSH
47315: EMPTY
47316: LIST
47317: LIST
47318: PUSH
47319: LD_INT 2
47321: NEG
47322: PUSH
47323: LD_INT 2
47325: NEG
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: PUSH
47331: LD_INT 2
47333: NEG
47334: PUSH
47335: LD_INT 3
47337: NEG
47338: PUSH
47339: EMPTY
47340: LIST
47341: LIST
47342: PUSH
47343: LD_INT 1
47345: NEG
47346: PUSH
47347: LD_INT 3
47349: NEG
47350: PUSH
47351: EMPTY
47352: LIST
47353: LIST
47354: PUSH
47355: LD_INT 3
47357: NEG
47358: PUSH
47359: LD_INT 1
47361: NEG
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PUSH
47367: LD_INT 3
47369: NEG
47370: PUSH
47371: LD_INT 2
47373: NEG
47374: PUSH
47375: EMPTY
47376: LIST
47377: LIST
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: LIST
47383: LIST
47384: LIST
47385: LIST
47386: LIST
47387: LIST
47388: LIST
47389: LIST
47390: LIST
47391: LIST
47392: LIST
47393: LIST
47394: LIST
47395: LIST
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
47404: LD_ADDR_VAR 0 29
47408: PUSH
47409: LD_INT 0
47411: PUSH
47412: LD_INT 0
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: PUSH
47419: LD_INT 0
47421: PUSH
47422: LD_INT 1
47424: NEG
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: LD_INT 1
47432: PUSH
47433: LD_INT 0
47435: PUSH
47436: EMPTY
47437: LIST
47438: LIST
47439: PUSH
47440: LD_INT 1
47442: PUSH
47443: LD_INT 1
47445: PUSH
47446: EMPTY
47447: LIST
47448: LIST
47449: PUSH
47450: LD_INT 0
47452: PUSH
47453: LD_INT 1
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: PUSH
47460: LD_INT 1
47462: NEG
47463: PUSH
47464: LD_INT 0
47466: PUSH
47467: EMPTY
47468: LIST
47469: LIST
47470: PUSH
47471: LD_INT 1
47473: NEG
47474: PUSH
47475: LD_INT 1
47477: NEG
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: PUSH
47483: LD_INT 1
47485: NEG
47486: PUSH
47487: LD_INT 2
47489: NEG
47490: PUSH
47491: EMPTY
47492: LIST
47493: LIST
47494: PUSH
47495: LD_INT 0
47497: PUSH
47498: LD_INT 2
47500: NEG
47501: PUSH
47502: EMPTY
47503: LIST
47504: LIST
47505: PUSH
47506: LD_INT 1
47508: PUSH
47509: LD_INT 1
47511: NEG
47512: PUSH
47513: EMPTY
47514: LIST
47515: LIST
47516: PUSH
47517: LD_INT 2
47519: PUSH
47520: LD_INT 0
47522: PUSH
47523: EMPTY
47524: LIST
47525: LIST
47526: PUSH
47527: LD_INT 2
47529: PUSH
47530: LD_INT 1
47532: PUSH
47533: EMPTY
47534: LIST
47535: LIST
47536: PUSH
47537: LD_INT 1
47539: PUSH
47540: LD_INT 2
47542: PUSH
47543: EMPTY
47544: LIST
47545: LIST
47546: PUSH
47547: LD_INT 0
47549: PUSH
47550: LD_INT 2
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: PUSH
47557: LD_INT 1
47559: NEG
47560: PUSH
47561: LD_INT 1
47563: PUSH
47564: EMPTY
47565: LIST
47566: LIST
47567: PUSH
47568: LD_INT 2
47570: NEG
47571: PUSH
47572: LD_INT 1
47574: NEG
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 2
47582: NEG
47583: PUSH
47584: LD_INT 2
47586: NEG
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PUSH
47592: LD_INT 2
47594: NEG
47595: PUSH
47596: LD_INT 3
47598: NEG
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: PUSH
47604: LD_INT 2
47606: PUSH
47607: LD_INT 1
47609: NEG
47610: PUSH
47611: EMPTY
47612: LIST
47613: LIST
47614: PUSH
47615: LD_INT 3
47617: PUSH
47618: LD_INT 1
47620: PUSH
47621: EMPTY
47622: LIST
47623: LIST
47624: PUSH
47625: LD_INT 1
47627: PUSH
47628: LD_INT 3
47630: PUSH
47631: EMPTY
47632: LIST
47633: LIST
47634: PUSH
47635: LD_INT 1
47637: NEG
47638: PUSH
47639: LD_INT 2
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: PUSH
47646: LD_INT 3
47648: NEG
47649: PUSH
47650: LD_INT 2
47652: NEG
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: PUSH
47658: EMPTY
47659: LIST
47660: LIST
47661: LIST
47662: LIST
47663: LIST
47664: LIST
47665: LIST
47666: LIST
47667: LIST
47668: LIST
47669: LIST
47670: LIST
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
47683: LD_ADDR_VAR 0 30
47687: PUSH
47688: LD_INT 0
47690: PUSH
47691: LD_INT 0
47693: PUSH
47694: EMPTY
47695: LIST
47696: LIST
47697: PUSH
47698: LD_INT 0
47700: PUSH
47701: LD_INT 1
47703: NEG
47704: PUSH
47705: EMPTY
47706: LIST
47707: LIST
47708: PUSH
47709: LD_INT 1
47711: PUSH
47712: LD_INT 0
47714: PUSH
47715: EMPTY
47716: LIST
47717: LIST
47718: PUSH
47719: LD_INT 1
47721: PUSH
47722: LD_INT 1
47724: PUSH
47725: EMPTY
47726: LIST
47727: LIST
47728: PUSH
47729: LD_INT 0
47731: PUSH
47732: LD_INT 1
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PUSH
47739: LD_INT 1
47741: NEG
47742: PUSH
47743: LD_INT 0
47745: PUSH
47746: EMPTY
47747: LIST
47748: LIST
47749: PUSH
47750: LD_INT 1
47752: NEG
47753: PUSH
47754: LD_INT 1
47756: NEG
47757: PUSH
47758: EMPTY
47759: LIST
47760: LIST
47761: PUSH
47762: LD_INT 1
47764: NEG
47765: PUSH
47766: LD_INT 2
47768: NEG
47769: PUSH
47770: EMPTY
47771: LIST
47772: LIST
47773: PUSH
47774: LD_INT 0
47776: PUSH
47777: LD_INT 2
47779: NEG
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: LD_INT 1
47787: PUSH
47788: LD_INT 1
47790: NEG
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PUSH
47796: LD_INT 2
47798: PUSH
47799: LD_INT 0
47801: PUSH
47802: EMPTY
47803: LIST
47804: LIST
47805: PUSH
47806: LD_INT 2
47808: PUSH
47809: LD_INT 1
47811: PUSH
47812: EMPTY
47813: LIST
47814: LIST
47815: PUSH
47816: LD_INT 2
47818: PUSH
47819: LD_INT 2
47821: PUSH
47822: EMPTY
47823: LIST
47824: LIST
47825: PUSH
47826: LD_INT 1
47828: PUSH
47829: LD_INT 2
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PUSH
47836: LD_INT 1
47838: NEG
47839: PUSH
47840: LD_INT 1
47842: PUSH
47843: EMPTY
47844: LIST
47845: LIST
47846: PUSH
47847: LD_INT 2
47849: NEG
47850: PUSH
47851: LD_INT 0
47853: PUSH
47854: EMPTY
47855: LIST
47856: LIST
47857: PUSH
47858: LD_INT 2
47860: NEG
47861: PUSH
47862: LD_INT 1
47864: NEG
47865: PUSH
47866: EMPTY
47867: LIST
47868: LIST
47869: PUSH
47870: LD_INT 1
47872: NEG
47873: PUSH
47874: LD_INT 3
47876: NEG
47877: PUSH
47878: EMPTY
47879: LIST
47880: LIST
47881: PUSH
47882: LD_INT 1
47884: PUSH
47885: LD_INT 2
47887: NEG
47888: PUSH
47889: EMPTY
47890: LIST
47891: LIST
47892: PUSH
47893: LD_INT 3
47895: PUSH
47896: LD_INT 2
47898: PUSH
47899: EMPTY
47900: LIST
47901: LIST
47902: PUSH
47903: LD_INT 2
47905: PUSH
47906: LD_INT 3
47908: PUSH
47909: EMPTY
47910: LIST
47911: LIST
47912: PUSH
47913: LD_INT 2
47915: NEG
47916: PUSH
47917: LD_INT 1
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 3
47926: NEG
47927: PUSH
47928: LD_INT 1
47930: NEG
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: LIST
47940: LIST
47941: LIST
47942: LIST
47943: LIST
47944: LIST
47945: LIST
47946: LIST
47947: LIST
47948: LIST
47949: LIST
47950: LIST
47951: LIST
47952: LIST
47953: LIST
47954: LIST
47955: LIST
47956: LIST
47957: LIST
47958: LIST
47959: LIST
47960: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
47961: LD_ADDR_VAR 0 31
47965: PUSH
47966: LD_INT 0
47968: PUSH
47969: LD_INT 0
47971: PUSH
47972: EMPTY
47973: LIST
47974: LIST
47975: PUSH
47976: LD_INT 0
47978: PUSH
47979: LD_INT 1
47981: NEG
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PUSH
47987: LD_INT 1
47989: PUSH
47990: LD_INT 0
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: PUSH
47997: LD_INT 1
47999: PUSH
48000: LD_INT 1
48002: PUSH
48003: EMPTY
48004: LIST
48005: LIST
48006: PUSH
48007: LD_INT 0
48009: PUSH
48010: LD_INT 1
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_INT 1
48019: NEG
48020: PUSH
48021: LD_INT 0
48023: PUSH
48024: EMPTY
48025: LIST
48026: LIST
48027: PUSH
48028: LD_INT 1
48030: NEG
48031: PUSH
48032: LD_INT 1
48034: NEG
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: LD_INT 1
48042: NEG
48043: PUSH
48044: LD_INT 2
48046: NEG
48047: PUSH
48048: EMPTY
48049: LIST
48050: LIST
48051: PUSH
48052: LD_INT 1
48054: PUSH
48055: LD_INT 1
48057: NEG
48058: PUSH
48059: EMPTY
48060: LIST
48061: LIST
48062: PUSH
48063: LD_INT 2
48065: PUSH
48066: LD_INT 0
48068: PUSH
48069: EMPTY
48070: LIST
48071: LIST
48072: PUSH
48073: LD_INT 2
48075: PUSH
48076: LD_INT 1
48078: PUSH
48079: EMPTY
48080: LIST
48081: LIST
48082: PUSH
48083: LD_INT 2
48085: PUSH
48086: LD_INT 2
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_INT 1
48095: PUSH
48096: LD_INT 2
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: PUSH
48103: LD_INT 0
48105: PUSH
48106: LD_INT 2
48108: PUSH
48109: EMPTY
48110: LIST
48111: LIST
48112: PUSH
48113: LD_INT 1
48115: NEG
48116: PUSH
48117: LD_INT 1
48119: PUSH
48120: EMPTY
48121: LIST
48122: LIST
48123: PUSH
48124: LD_INT 2
48126: NEG
48127: PUSH
48128: LD_INT 1
48130: NEG
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: PUSH
48136: LD_INT 2
48138: NEG
48139: PUSH
48140: LD_INT 2
48142: NEG
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 2
48150: NEG
48151: PUSH
48152: LD_INT 3
48154: NEG
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: PUSH
48160: LD_INT 2
48162: PUSH
48163: LD_INT 1
48165: NEG
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: PUSH
48171: LD_INT 3
48173: PUSH
48174: LD_INT 1
48176: PUSH
48177: EMPTY
48178: LIST
48179: LIST
48180: PUSH
48181: LD_INT 1
48183: PUSH
48184: LD_INT 3
48186: PUSH
48187: EMPTY
48188: LIST
48189: LIST
48190: PUSH
48191: LD_INT 1
48193: NEG
48194: PUSH
48195: LD_INT 2
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PUSH
48202: LD_INT 3
48204: NEG
48205: PUSH
48206: LD_INT 2
48208: NEG
48209: PUSH
48210: EMPTY
48211: LIST
48212: LIST
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: LIST
48218: LIST
48219: LIST
48220: LIST
48221: LIST
48222: LIST
48223: LIST
48224: LIST
48225: LIST
48226: LIST
48227: LIST
48228: LIST
48229: LIST
48230: LIST
48231: LIST
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
48239: LD_ADDR_VAR 0 32
48243: PUSH
48244: LD_INT 0
48246: PUSH
48247: LD_INT 0
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PUSH
48254: LD_INT 0
48256: PUSH
48257: LD_INT 1
48259: NEG
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 1
48267: PUSH
48268: LD_INT 0
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: PUSH
48275: LD_INT 1
48277: PUSH
48278: LD_INT 1
48280: PUSH
48281: EMPTY
48282: LIST
48283: LIST
48284: PUSH
48285: LD_INT 0
48287: PUSH
48288: LD_INT 1
48290: PUSH
48291: EMPTY
48292: LIST
48293: LIST
48294: PUSH
48295: LD_INT 1
48297: NEG
48298: PUSH
48299: LD_INT 0
48301: PUSH
48302: EMPTY
48303: LIST
48304: LIST
48305: PUSH
48306: LD_INT 1
48308: NEG
48309: PUSH
48310: LD_INT 1
48312: NEG
48313: PUSH
48314: EMPTY
48315: LIST
48316: LIST
48317: PUSH
48318: LD_INT 1
48320: NEG
48321: PUSH
48322: LD_INT 2
48324: NEG
48325: PUSH
48326: EMPTY
48327: LIST
48328: LIST
48329: PUSH
48330: LD_INT 0
48332: PUSH
48333: LD_INT 2
48335: NEG
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 1
48343: PUSH
48344: LD_INT 1
48346: NEG
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: PUSH
48352: LD_INT 2
48354: PUSH
48355: LD_INT 1
48357: PUSH
48358: EMPTY
48359: LIST
48360: LIST
48361: PUSH
48362: LD_INT 2
48364: PUSH
48365: LD_INT 2
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: PUSH
48372: LD_INT 1
48374: PUSH
48375: LD_INT 2
48377: PUSH
48378: EMPTY
48379: LIST
48380: LIST
48381: PUSH
48382: LD_INT 0
48384: PUSH
48385: LD_INT 2
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: PUSH
48392: LD_INT 1
48394: NEG
48395: PUSH
48396: LD_INT 1
48398: PUSH
48399: EMPTY
48400: LIST
48401: LIST
48402: PUSH
48403: LD_INT 2
48405: NEG
48406: PUSH
48407: LD_INT 0
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: PUSH
48414: LD_INT 2
48416: NEG
48417: PUSH
48418: LD_INT 1
48420: NEG
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: LD_INT 1
48428: NEG
48429: PUSH
48430: LD_INT 3
48432: NEG
48433: PUSH
48434: EMPTY
48435: LIST
48436: LIST
48437: PUSH
48438: LD_INT 1
48440: PUSH
48441: LD_INT 2
48443: NEG
48444: PUSH
48445: EMPTY
48446: LIST
48447: LIST
48448: PUSH
48449: LD_INT 3
48451: PUSH
48452: LD_INT 2
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 2
48461: PUSH
48462: LD_INT 3
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: PUSH
48469: LD_INT 2
48471: NEG
48472: PUSH
48473: LD_INT 1
48475: PUSH
48476: EMPTY
48477: LIST
48478: LIST
48479: PUSH
48480: LD_INT 3
48482: NEG
48483: PUSH
48484: LD_INT 1
48486: NEG
48487: PUSH
48488: EMPTY
48489: LIST
48490: LIST
48491: PUSH
48492: EMPTY
48493: LIST
48494: LIST
48495: LIST
48496: LIST
48497: LIST
48498: LIST
48499: LIST
48500: LIST
48501: LIST
48502: LIST
48503: LIST
48504: LIST
48505: LIST
48506: LIST
48507: LIST
48508: LIST
48509: LIST
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: LIST
48516: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
48517: LD_ADDR_VAR 0 33
48521: PUSH
48522: LD_INT 0
48524: PUSH
48525: LD_INT 0
48527: PUSH
48528: EMPTY
48529: LIST
48530: LIST
48531: PUSH
48532: LD_INT 0
48534: PUSH
48535: LD_INT 1
48537: NEG
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: PUSH
48543: LD_INT 1
48545: PUSH
48546: LD_INT 0
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: PUSH
48553: LD_INT 1
48555: PUSH
48556: LD_INT 1
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PUSH
48563: LD_INT 0
48565: PUSH
48566: LD_INT 1
48568: PUSH
48569: EMPTY
48570: LIST
48571: LIST
48572: PUSH
48573: LD_INT 1
48575: NEG
48576: PUSH
48577: LD_INT 0
48579: PUSH
48580: EMPTY
48581: LIST
48582: LIST
48583: PUSH
48584: LD_INT 1
48586: NEG
48587: PUSH
48588: LD_INT 1
48590: NEG
48591: PUSH
48592: EMPTY
48593: LIST
48594: LIST
48595: PUSH
48596: LD_INT 1
48598: NEG
48599: PUSH
48600: LD_INT 2
48602: NEG
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 1
48610: PUSH
48611: LD_INT 1
48613: NEG
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: PUSH
48619: LD_INT 2
48621: PUSH
48622: LD_INT 0
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: PUSH
48629: LD_INT 2
48631: PUSH
48632: LD_INT 1
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: PUSH
48639: LD_INT 1
48641: PUSH
48642: LD_INT 2
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: PUSH
48649: LD_INT 0
48651: PUSH
48652: LD_INT 2
48654: PUSH
48655: EMPTY
48656: LIST
48657: LIST
48658: PUSH
48659: LD_INT 1
48661: NEG
48662: PUSH
48663: LD_INT 1
48665: PUSH
48666: EMPTY
48667: LIST
48668: LIST
48669: PUSH
48670: LD_INT 2
48672: NEG
48673: PUSH
48674: LD_INT 0
48676: PUSH
48677: EMPTY
48678: LIST
48679: LIST
48680: PUSH
48681: LD_INT 2
48683: NEG
48684: PUSH
48685: LD_INT 1
48687: NEG
48688: PUSH
48689: EMPTY
48690: LIST
48691: LIST
48692: PUSH
48693: LD_INT 2
48695: NEG
48696: PUSH
48697: LD_INT 2
48699: NEG
48700: PUSH
48701: EMPTY
48702: LIST
48703: LIST
48704: PUSH
48705: LD_INT 2
48707: NEG
48708: PUSH
48709: LD_INT 3
48711: NEG
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: PUSH
48717: LD_INT 2
48719: PUSH
48720: LD_INT 1
48722: NEG
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: PUSH
48728: LD_INT 3
48730: PUSH
48731: LD_INT 1
48733: PUSH
48734: EMPTY
48735: LIST
48736: LIST
48737: PUSH
48738: LD_INT 1
48740: PUSH
48741: LD_INT 3
48743: PUSH
48744: EMPTY
48745: LIST
48746: LIST
48747: PUSH
48748: LD_INT 1
48750: NEG
48751: PUSH
48752: LD_INT 2
48754: PUSH
48755: EMPTY
48756: LIST
48757: LIST
48758: PUSH
48759: LD_INT 3
48761: NEG
48762: PUSH
48763: LD_INT 2
48765: NEG
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: LIST
48775: LIST
48776: LIST
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: LIST
48785: LIST
48786: LIST
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
48796: LD_ADDR_VAR 0 34
48800: PUSH
48801: LD_INT 0
48803: PUSH
48804: LD_INT 0
48806: PUSH
48807: EMPTY
48808: LIST
48809: LIST
48810: PUSH
48811: LD_INT 0
48813: PUSH
48814: LD_INT 1
48816: NEG
48817: PUSH
48818: EMPTY
48819: LIST
48820: LIST
48821: PUSH
48822: LD_INT 1
48824: PUSH
48825: LD_INT 0
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PUSH
48832: LD_INT 1
48834: PUSH
48835: LD_INT 1
48837: PUSH
48838: EMPTY
48839: LIST
48840: LIST
48841: PUSH
48842: LD_INT 0
48844: PUSH
48845: LD_INT 1
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: PUSH
48852: LD_INT 1
48854: NEG
48855: PUSH
48856: LD_INT 0
48858: PUSH
48859: EMPTY
48860: LIST
48861: LIST
48862: PUSH
48863: LD_INT 1
48865: NEG
48866: PUSH
48867: LD_INT 1
48869: NEG
48870: PUSH
48871: EMPTY
48872: LIST
48873: LIST
48874: PUSH
48875: LD_INT 1
48877: NEG
48878: PUSH
48879: LD_INT 2
48881: NEG
48882: PUSH
48883: EMPTY
48884: LIST
48885: LIST
48886: PUSH
48887: LD_INT 0
48889: PUSH
48890: LD_INT 2
48892: NEG
48893: PUSH
48894: EMPTY
48895: LIST
48896: LIST
48897: PUSH
48898: LD_INT 1
48900: PUSH
48901: LD_INT 1
48903: NEG
48904: PUSH
48905: EMPTY
48906: LIST
48907: LIST
48908: PUSH
48909: LD_INT 2
48911: PUSH
48912: LD_INT 1
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: PUSH
48919: LD_INT 2
48921: PUSH
48922: LD_INT 2
48924: PUSH
48925: EMPTY
48926: LIST
48927: LIST
48928: PUSH
48929: LD_INT 1
48931: PUSH
48932: LD_INT 2
48934: PUSH
48935: EMPTY
48936: LIST
48937: LIST
48938: PUSH
48939: LD_INT 1
48941: NEG
48942: PUSH
48943: LD_INT 1
48945: PUSH
48946: EMPTY
48947: LIST
48948: LIST
48949: PUSH
48950: LD_INT 2
48952: NEG
48953: PUSH
48954: LD_INT 0
48956: PUSH
48957: EMPTY
48958: LIST
48959: LIST
48960: PUSH
48961: LD_INT 2
48963: NEG
48964: PUSH
48965: LD_INT 1
48967: NEG
48968: PUSH
48969: EMPTY
48970: LIST
48971: LIST
48972: PUSH
48973: LD_INT 2
48975: NEG
48976: PUSH
48977: LD_INT 2
48979: NEG
48980: PUSH
48981: EMPTY
48982: LIST
48983: LIST
48984: PUSH
48985: LD_INT 1
48987: NEG
48988: PUSH
48989: LD_INT 3
48991: NEG
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: PUSH
48997: LD_INT 1
48999: PUSH
49000: LD_INT 2
49002: NEG
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PUSH
49008: LD_INT 3
49010: PUSH
49011: LD_INT 2
49013: PUSH
49014: EMPTY
49015: LIST
49016: LIST
49017: PUSH
49018: LD_INT 2
49020: PUSH
49021: LD_INT 3
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: PUSH
49028: LD_INT 2
49030: NEG
49031: PUSH
49032: LD_INT 1
49034: PUSH
49035: EMPTY
49036: LIST
49037: LIST
49038: PUSH
49039: LD_INT 3
49041: NEG
49042: PUSH
49043: LD_INT 1
49045: NEG
49046: PUSH
49047: EMPTY
49048: LIST
49049: LIST
49050: PUSH
49051: EMPTY
49052: LIST
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
49076: LD_ADDR_VAR 0 35
49080: PUSH
49081: LD_INT 0
49083: PUSH
49084: LD_INT 0
49086: PUSH
49087: EMPTY
49088: LIST
49089: LIST
49090: PUSH
49091: LD_INT 0
49093: PUSH
49094: LD_INT 1
49096: NEG
49097: PUSH
49098: EMPTY
49099: LIST
49100: LIST
49101: PUSH
49102: LD_INT 1
49104: PUSH
49105: LD_INT 0
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PUSH
49112: LD_INT 1
49114: PUSH
49115: LD_INT 1
49117: PUSH
49118: EMPTY
49119: LIST
49120: LIST
49121: PUSH
49122: LD_INT 0
49124: PUSH
49125: LD_INT 1
49127: PUSH
49128: EMPTY
49129: LIST
49130: LIST
49131: PUSH
49132: LD_INT 1
49134: NEG
49135: PUSH
49136: LD_INT 0
49138: PUSH
49139: EMPTY
49140: LIST
49141: LIST
49142: PUSH
49143: LD_INT 1
49145: NEG
49146: PUSH
49147: LD_INT 1
49149: NEG
49150: PUSH
49151: EMPTY
49152: LIST
49153: LIST
49154: PUSH
49155: LD_INT 2
49157: PUSH
49158: LD_INT 1
49160: PUSH
49161: EMPTY
49162: LIST
49163: LIST
49164: PUSH
49165: LD_INT 2
49167: NEG
49168: PUSH
49169: LD_INT 1
49171: NEG
49172: PUSH
49173: EMPTY
49174: LIST
49175: LIST
49176: PUSH
49177: EMPTY
49178: LIST
49179: LIST
49180: LIST
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
49188: LD_ADDR_VAR 0 36
49192: PUSH
49193: LD_INT 0
49195: PUSH
49196: LD_INT 0
49198: PUSH
49199: EMPTY
49200: LIST
49201: LIST
49202: PUSH
49203: LD_INT 0
49205: PUSH
49206: LD_INT 1
49208: NEG
49209: PUSH
49210: EMPTY
49211: LIST
49212: LIST
49213: PUSH
49214: LD_INT 1
49216: PUSH
49217: LD_INT 0
49219: PUSH
49220: EMPTY
49221: LIST
49222: LIST
49223: PUSH
49224: LD_INT 1
49226: PUSH
49227: LD_INT 1
49229: PUSH
49230: EMPTY
49231: LIST
49232: LIST
49233: PUSH
49234: LD_INT 0
49236: PUSH
49237: LD_INT 1
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PUSH
49244: LD_INT 1
49246: NEG
49247: PUSH
49248: LD_INT 0
49250: PUSH
49251: EMPTY
49252: LIST
49253: LIST
49254: PUSH
49255: LD_INT 1
49257: NEG
49258: PUSH
49259: LD_INT 1
49261: NEG
49262: PUSH
49263: EMPTY
49264: LIST
49265: LIST
49266: PUSH
49267: LD_INT 1
49269: NEG
49270: PUSH
49271: LD_INT 2
49273: NEG
49274: PUSH
49275: EMPTY
49276: LIST
49277: LIST
49278: PUSH
49279: LD_INT 1
49281: PUSH
49282: LD_INT 2
49284: PUSH
49285: EMPTY
49286: LIST
49287: LIST
49288: PUSH
49289: EMPTY
49290: LIST
49291: LIST
49292: LIST
49293: LIST
49294: LIST
49295: LIST
49296: LIST
49297: LIST
49298: LIST
49299: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
49300: LD_ADDR_VAR 0 37
49304: PUSH
49305: LD_INT 0
49307: PUSH
49308: LD_INT 0
49310: PUSH
49311: EMPTY
49312: LIST
49313: LIST
49314: PUSH
49315: LD_INT 0
49317: PUSH
49318: LD_INT 1
49320: NEG
49321: PUSH
49322: EMPTY
49323: LIST
49324: LIST
49325: PUSH
49326: LD_INT 1
49328: PUSH
49329: LD_INT 0
49331: PUSH
49332: EMPTY
49333: LIST
49334: LIST
49335: PUSH
49336: LD_INT 1
49338: PUSH
49339: LD_INT 1
49341: PUSH
49342: EMPTY
49343: LIST
49344: LIST
49345: PUSH
49346: LD_INT 0
49348: PUSH
49349: LD_INT 1
49351: PUSH
49352: EMPTY
49353: LIST
49354: LIST
49355: PUSH
49356: LD_INT 1
49358: NEG
49359: PUSH
49360: LD_INT 0
49362: PUSH
49363: EMPTY
49364: LIST
49365: LIST
49366: PUSH
49367: LD_INT 1
49369: NEG
49370: PUSH
49371: LD_INT 1
49373: NEG
49374: PUSH
49375: EMPTY
49376: LIST
49377: LIST
49378: PUSH
49379: LD_INT 1
49381: PUSH
49382: LD_INT 1
49384: NEG
49385: PUSH
49386: EMPTY
49387: LIST
49388: LIST
49389: PUSH
49390: LD_INT 1
49392: NEG
49393: PUSH
49394: LD_INT 1
49396: PUSH
49397: EMPTY
49398: LIST
49399: LIST
49400: PUSH
49401: EMPTY
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
49412: LD_ADDR_VAR 0 38
49416: PUSH
49417: LD_INT 0
49419: PUSH
49420: LD_INT 0
49422: PUSH
49423: EMPTY
49424: LIST
49425: LIST
49426: PUSH
49427: LD_INT 0
49429: PUSH
49430: LD_INT 1
49432: NEG
49433: PUSH
49434: EMPTY
49435: LIST
49436: LIST
49437: PUSH
49438: LD_INT 1
49440: PUSH
49441: LD_INT 0
49443: PUSH
49444: EMPTY
49445: LIST
49446: LIST
49447: PUSH
49448: LD_INT 1
49450: PUSH
49451: LD_INT 1
49453: PUSH
49454: EMPTY
49455: LIST
49456: LIST
49457: PUSH
49458: LD_INT 0
49460: PUSH
49461: LD_INT 1
49463: PUSH
49464: EMPTY
49465: LIST
49466: LIST
49467: PUSH
49468: LD_INT 1
49470: NEG
49471: PUSH
49472: LD_INT 0
49474: PUSH
49475: EMPTY
49476: LIST
49477: LIST
49478: PUSH
49479: LD_INT 1
49481: NEG
49482: PUSH
49483: LD_INT 1
49485: NEG
49486: PUSH
49487: EMPTY
49488: LIST
49489: LIST
49490: PUSH
49491: LD_INT 2
49493: PUSH
49494: LD_INT 1
49496: PUSH
49497: EMPTY
49498: LIST
49499: LIST
49500: PUSH
49501: LD_INT 2
49503: NEG
49504: PUSH
49505: LD_INT 1
49507: NEG
49508: PUSH
49509: EMPTY
49510: LIST
49511: LIST
49512: PUSH
49513: EMPTY
49514: LIST
49515: LIST
49516: LIST
49517: LIST
49518: LIST
49519: LIST
49520: LIST
49521: LIST
49522: LIST
49523: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
49524: LD_ADDR_VAR 0 39
49528: PUSH
49529: LD_INT 0
49531: PUSH
49532: LD_INT 0
49534: PUSH
49535: EMPTY
49536: LIST
49537: LIST
49538: PUSH
49539: LD_INT 0
49541: PUSH
49542: LD_INT 1
49544: NEG
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: PUSH
49550: LD_INT 1
49552: PUSH
49553: LD_INT 0
49555: PUSH
49556: EMPTY
49557: LIST
49558: LIST
49559: PUSH
49560: LD_INT 1
49562: PUSH
49563: LD_INT 1
49565: PUSH
49566: EMPTY
49567: LIST
49568: LIST
49569: PUSH
49570: LD_INT 0
49572: PUSH
49573: LD_INT 1
49575: PUSH
49576: EMPTY
49577: LIST
49578: LIST
49579: PUSH
49580: LD_INT 1
49582: NEG
49583: PUSH
49584: LD_INT 0
49586: PUSH
49587: EMPTY
49588: LIST
49589: LIST
49590: PUSH
49591: LD_INT 1
49593: NEG
49594: PUSH
49595: LD_INT 1
49597: NEG
49598: PUSH
49599: EMPTY
49600: LIST
49601: LIST
49602: PUSH
49603: LD_INT 1
49605: NEG
49606: PUSH
49607: LD_INT 2
49609: NEG
49610: PUSH
49611: EMPTY
49612: LIST
49613: LIST
49614: PUSH
49615: LD_INT 1
49617: PUSH
49618: LD_INT 2
49620: PUSH
49621: EMPTY
49622: LIST
49623: LIST
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
49636: LD_ADDR_VAR 0 40
49640: PUSH
49641: LD_INT 0
49643: PUSH
49644: LD_INT 0
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: PUSH
49651: LD_INT 0
49653: PUSH
49654: LD_INT 1
49656: NEG
49657: PUSH
49658: EMPTY
49659: LIST
49660: LIST
49661: PUSH
49662: LD_INT 1
49664: PUSH
49665: LD_INT 0
49667: PUSH
49668: EMPTY
49669: LIST
49670: LIST
49671: PUSH
49672: LD_INT 1
49674: PUSH
49675: LD_INT 1
49677: PUSH
49678: EMPTY
49679: LIST
49680: LIST
49681: PUSH
49682: LD_INT 0
49684: PUSH
49685: LD_INT 1
49687: PUSH
49688: EMPTY
49689: LIST
49690: LIST
49691: PUSH
49692: LD_INT 1
49694: NEG
49695: PUSH
49696: LD_INT 0
49698: PUSH
49699: EMPTY
49700: LIST
49701: LIST
49702: PUSH
49703: LD_INT 1
49705: NEG
49706: PUSH
49707: LD_INT 1
49709: NEG
49710: PUSH
49711: EMPTY
49712: LIST
49713: LIST
49714: PUSH
49715: LD_INT 1
49717: PUSH
49718: LD_INT 1
49720: NEG
49721: PUSH
49722: EMPTY
49723: LIST
49724: LIST
49725: PUSH
49726: LD_INT 1
49728: NEG
49729: PUSH
49730: LD_INT 1
49732: PUSH
49733: EMPTY
49734: LIST
49735: LIST
49736: PUSH
49737: EMPTY
49738: LIST
49739: LIST
49740: LIST
49741: LIST
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
49748: LD_ADDR_VAR 0 41
49752: PUSH
49753: LD_INT 0
49755: PUSH
49756: LD_INT 0
49758: PUSH
49759: EMPTY
49760: LIST
49761: LIST
49762: PUSH
49763: LD_INT 0
49765: PUSH
49766: LD_INT 1
49768: NEG
49769: PUSH
49770: EMPTY
49771: LIST
49772: LIST
49773: PUSH
49774: LD_INT 1
49776: PUSH
49777: LD_INT 0
49779: PUSH
49780: EMPTY
49781: LIST
49782: LIST
49783: PUSH
49784: LD_INT 1
49786: PUSH
49787: LD_INT 1
49789: PUSH
49790: EMPTY
49791: LIST
49792: LIST
49793: PUSH
49794: LD_INT 0
49796: PUSH
49797: LD_INT 1
49799: PUSH
49800: EMPTY
49801: LIST
49802: LIST
49803: PUSH
49804: LD_INT 1
49806: NEG
49807: PUSH
49808: LD_INT 0
49810: PUSH
49811: EMPTY
49812: LIST
49813: LIST
49814: PUSH
49815: LD_INT 1
49817: NEG
49818: PUSH
49819: LD_INT 1
49821: NEG
49822: PUSH
49823: EMPTY
49824: LIST
49825: LIST
49826: PUSH
49827: LD_INT 1
49829: NEG
49830: PUSH
49831: LD_INT 2
49833: NEG
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: LD_INT 1
49841: PUSH
49842: LD_INT 1
49844: NEG
49845: PUSH
49846: EMPTY
49847: LIST
49848: LIST
49849: PUSH
49850: LD_INT 2
49852: PUSH
49853: LD_INT 0
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: PUSH
49860: LD_INT 2
49862: PUSH
49863: LD_INT 1
49865: PUSH
49866: EMPTY
49867: LIST
49868: LIST
49869: PUSH
49870: LD_INT 2
49872: PUSH
49873: LD_INT 2
49875: PUSH
49876: EMPTY
49877: LIST
49878: LIST
49879: PUSH
49880: LD_INT 1
49882: PUSH
49883: LD_INT 2
49885: PUSH
49886: EMPTY
49887: LIST
49888: LIST
49889: PUSH
49890: LD_INT 1
49892: NEG
49893: PUSH
49894: LD_INT 1
49896: PUSH
49897: EMPTY
49898: LIST
49899: LIST
49900: PUSH
49901: LD_INT 2
49903: NEG
49904: PUSH
49905: LD_INT 0
49907: PUSH
49908: EMPTY
49909: LIST
49910: LIST
49911: PUSH
49912: LD_INT 2
49914: NEG
49915: PUSH
49916: LD_INT 1
49918: NEG
49919: PUSH
49920: EMPTY
49921: LIST
49922: LIST
49923: PUSH
49924: LD_INT 2
49926: NEG
49927: PUSH
49928: LD_INT 2
49930: NEG
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: PUSH
49936: LD_INT 2
49938: NEG
49939: PUSH
49940: LD_INT 3
49942: NEG
49943: PUSH
49944: EMPTY
49945: LIST
49946: LIST
49947: PUSH
49948: LD_INT 2
49950: PUSH
49951: LD_INT 1
49953: NEG
49954: PUSH
49955: EMPTY
49956: LIST
49957: LIST
49958: PUSH
49959: LD_INT 3
49961: PUSH
49962: LD_INT 0
49964: PUSH
49965: EMPTY
49966: LIST
49967: LIST
49968: PUSH
49969: LD_INT 3
49971: PUSH
49972: LD_INT 1
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PUSH
49979: LD_INT 3
49981: PUSH
49982: LD_INT 2
49984: PUSH
49985: EMPTY
49986: LIST
49987: LIST
49988: PUSH
49989: LD_INT 3
49991: PUSH
49992: LD_INT 3
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: PUSH
49999: LD_INT 2
50001: PUSH
50002: LD_INT 3
50004: PUSH
50005: EMPTY
50006: LIST
50007: LIST
50008: PUSH
50009: LD_INT 2
50011: NEG
50012: PUSH
50013: LD_INT 1
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: LD_INT 3
50022: NEG
50023: PUSH
50024: LD_INT 0
50026: PUSH
50027: EMPTY
50028: LIST
50029: LIST
50030: PUSH
50031: LD_INT 3
50033: NEG
50034: PUSH
50035: LD_INT 1
50037: NEG
50038: PUSH
50039: EMPTY
50040: LIST
50041: LIST
50042: PUSH
50043: LD_INT 3
50045: NEG
50046: PUSH
50047: LD_INT 2
50049: NEG
50050: PUSH
50051: EMPTY
50052: LIST
50053: LIST
50054: PUSH
50055: LD_INT 3
50057: NEG
50058: PUSH
50059: LD_INT 3
50061: NEG
50062: PUSH
50063: EMPTY
50064: LIST
50065: LIST
50066: PUSH
50067: EMPTY
50068: LIST
50069: LIST
50070: LIST
50071: LIST
50072: LIST
50073: LIST
50074: LIST
50075: LIST
50076: LIST
50077: LIST
50078: LIST
50079: LIST
50080: LIST
50081: LIST
50082: LIST
50083: LIST
50084: LIST
50085: LIST
50086: LIST
50087: LIST
50088: LIST
50089: LIST
50090: LIST
50091: LIST
50092: LIST
50093: LIST
50094: LIST
50095: LIST
50096: LIST
50097: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
50098: LD_ADDR_VAR 0 42
50102: PUSH
50103: LD_INT 0
50105: PUSH
50106: LD_INT 0
50108: PUSH
50109: EMPTY
50110: LIST
50111: LIST
50112: PUSH
50113: LD_INT 0
50115: PUSH
50116: LD_INT 1
50118: NEG
50119: PUSH
50120: EMPTY
50121: LIST
50122: LIST
50123: PUSH
50124: LD_INT 1
50126: PUSH
50127: LD_INT 0
50129: PUSH
50130: EMPTY
50131: LIST
50132: LIST
50133: PUSH
50134: LD_INT 1
50136: PUSH
50137: LD_INT 1
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: PUSH
50144: LD_INT 0
50146: PUSH
50147: LD_INT 1
50149: PUSH
50150: EMPTY
50151: LIST
50152: LIST
50153: PUSH
50154: LD_INT 1
50156: NEG
50157: PUSH
50158: LD_INT 0
50160: PUSH
50161: EMPTY
50162: LIST
50163: LIST
50164: PUSH
50165: LD_INT 1
50167: NEG
50168: PUSH
50169: LD_INT 1
50171: NEG
50172: PUSH
50173: EMPTY
50174: LIST
50175: LIST
50176: PUSH
50177: LD_INT 1
50179: NEG
50180: PUSH
50181: LD_INT 2
50183: NEG
50184: PUSH
50185: EMPTY
50186: LIST
50187: LIST
50188: PUSH
50189: LD_INT 0
50191: PUSH
50192: LD_INT 2
50194: NEG
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: PUSH
50200: LD_INT 1
50202: PUSH
50203: LD_INT 1
50205: NEG
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: PUSH
50211: LD_INT 2
50213: PUSH
50214: LD_INT 1
50216: PUSH
50217: EMPTY
50218: LIST
50219: LIST
50220: PUSH
50221: LD_INT 2
50223: PUSH
50224: LD_INT 2
50226: PUSH
50227: EMPTY
50228: LIST
50229: LIST
50230: PUSH
50231: LD_INT 1
50233: PUSH
50234: LD_INT 2
50236: PUSH
50237: EMPTY
50238: LIST
50239: LIST
50240: PUSH
50241: LD_INT 0
50243: PUSH
50244: LD_INT 2
50246: PUSH
50247: EMPTY
50248: LIST
50249: LIST
50250: PUSH
50251: LD_INT 1
50253: NEG
50254: PUSH
50255: LD_INT 1
50257: PUSH
50258: EMPTY
50259: LIST
50260: LIST
50261: PUSH
50262: LD_INT 2
50264: NEG
50265: PUSH
50266: LD_INT 1
50268: NEG
50269: PUSH
50270: EMPTY
50271: LIST
50272: LIST
50273: PUSH
50274: LD_INT 2
50276: NEG
50277: PUSH
50278: LD_INT 2
50280: NEG
50281: PUSH
50282: EMPTY
50283: LIST
50284: LIST
50285: PUSH
50286: LD_INT 2
50288: NEG
50289: PUSH
50290: LD_INT 3
50292: NEG
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PUSH
50298: LD_INT 1
50300: NEG
50301: PUSH
50302: LD_INT 3
50304: NEG
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: PUSH
50310: LD_INT 0
50312: PUSH
50313: LD_INT 3
50315: NEG
50316: PUSH
50317: EMPTY
50318: LIST
50319: LIST
50320: PUSH
50321: LD_INT 1
50323: PUSH
50324: LD_INT 2
50326: NEG
50327: PUSH
50328: EMPTY
50329: LIST
50330: LIST
50331: PUSH
50332: LD_INT 3
50334: PUSH
50335: LD_INT 2
50337: PUSH
50338: EMPTY
50339: LIST
50340: LIST
50341: PUSH
50342: LD_INT 3
50344: PUSH
50345: LD_INT 3
50347: PUSH
50348: EMPTY
50349: LIST
50350: LIST
50351: PUSH
50352: LD_INT 2
50354: PUSH
50355: LD_INT 3
50357: PUSH
50358: EMPTY
50359: LIST
50360: LIST
50361: PUSH
50362: LD_INT 1
50364: PUSH
50365: LD_INT 3
50367: PUSH
50368: EMPTY
50369: LIST
50370: LIST
50371: PUSH
50372: LD_INT 0
50374: PUSH
50375: LD_INT 3
50377: PUSH
50378: EMPTY
50379: LIST
50380: LIST
50381: PUSH
50382: LD_INT 1
50384: NEG
50385: PUSH
50386: LD_INT 2
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PUSH
50393: LD_INT 3
50395: NEG
50396: PUSH
50397: LD_INT 2
50399: NEG
50400: PUSH
50401: EMPTY
50402: LIST
50403: LIST
50404: PUSH
50405: LD_INT 3
50407: NEG
50408: PUSH
50409: LD_INT 3
50411: NEG
50412: PUSH
50413: EMPTY
50414: LIST
50415: LIST
50416: PUSH
50417: EMPTY
50418: LIST
50419: LIST
50420: LIST
50421: LIST
50422: LIST
50423: LIST
50424: LIST
50425: LIST
50426: LIST
50427: LIST
50428: LIST
50429: LIST
50430: LIST
50431: LIST
50432: LIST
50433: LIST
50434: LIST
50435: LIST
50436: LIST
50437: LIST
50438: LIST
50439: LIST
50440: LIST
50441: LIST
50442: LIST
50443: LIST
50444: LIST
50445: LIST
50446: LIST
50447: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
50448: LD_ADDR_VAR 0 43
50452: PUSH
50453: LD_INT 0
50455: PUSH
50456: LD_INT 0
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: PUSH
50463: LD_INT 0
50465: PUSH
50466: LD_INT 1
50468: NEG
50469: PUSH
50470: EMPTY
50471: LIST
50472: LIST
50473: PUSH
50474: LD_INT 1
50476: PUSH
50477: LD_INT 0
50479: PUSH
50480: EMPTY
50481: LIST
50482: LIST
50483: PUSH
50484: LD_INT 1
50486: PUSH
50487: LD_INT 1
50489: PUSH
50490: EMPTY
50491: LIST
50492: LIST
50493: PUSH
50494: LD_INT 0
50496: PUSH
50497: LD_INT 1
50499: PUSH
50500: EMPTY
50501: LIST
50502: LIST
50503: PUSH
50504: LD_INT 1
50506: NEG
50507: PUSH
50508: LD_INT 0
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PUSH
50515: LD_INT 1
50517: NEG
50518: PUSH
50519: LD_INT 1
50521: NEG
50522: PUSH
50523: EMPTY
50524: LIST
50525: LIST
50526: PUSH
50527: LD_INT 1
50529: NEG
50530: PUSH
50531: LD_INT 2
50533: NEG
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: PUSH
50539: LD_INT 0
50541: PUSH
50542: LD_INT 2
50544: NEG
50545: PUSH
50546: EMPTY
50547: LIST
50548: LIST
50549: PUSH
50550: LD_INT 1
50552: PUSH
50553: LD_INT 1
50555: NEG
50556: PUSH
50557: EMPTY
50558: LIST
50559: LIST
50560: PUSH
50561: LD_INT 2
50563: PUSH
50564: LD_INT 0
50566: PUSH
50567: EMPTY
50568: LIST
50569: LIST
50570: PUSH
50571: LD_INT 2
50573: PUSH
50574: LD_INT 1
50576: PUSH
50577: EMPTY
50578: LIST
50579: LIST
50580: PUSH
50581: LD_INT 1
50583: PUSH
50584: LD_INT 2
50586: PUSH
50587: EMPTY
50588: LIST
50589: LIST
50590: PUSH
50591: LD_INT 0
50593: PUSH
50594: LD_INT 2
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: PUSH
50601: LD_INT 1
50603: NEG
50604: PUSH
50605: LD_INT 1
50607: PUSH
50608: EMPTY
50609: LIST
50610: LIST
50611: PUSH
50612: LD_INT 2
50614: NEG
50615: PUSH
50616: LD_INT 0
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PUSH
50623: LD_INT 2
50625: NEG
50626: PUSH
50627: LD_INT 1
50629: NEG
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: LD_INT 1
50637: NEG
50638: PUSH
50639: LD_INT 3
50641: NEG
50642: PUSH
50643: EMPTY
50644: LIST
50645: LIST
50646: PUSH
50647: LD_INT 0
50649: PUSH
50650: LD_INT 3
50652: NEG
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: PUSH
50658: LD_INT 1
50660: PUSH
50661: LD_INT 2
50663: NEG
50664: PUSH
50665: EMPTY
50666: LIST
50667: LIST
50668: PUSH
50669: LD_INT 2
50671: PUSH
50672: LD_INT 1
50674: NEG
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: PUSH
50680: LD_INT 3
50682: PUSH
50683: LD_INT 0
50685: PUSH
50686: EMPTY
50687: LIST
50688: LIST
50689: PUSH
50690: LD_INT 3
50692: PUSH
50693: LD_INT 1
50695: PUSH
50696: EMPTY
50697: LIST
50698: LIST
50699: PUSH
50700: LD_INT 1
50702: PUSH
50703: LD_INT 3
50705: PUSH
50706: EMPTY
50707: LIST
50708: LIST
50709: PUSH
50710: LD_INT 0
50712: PUSH
50713: LD_INT 3
50715: PUSH
50716: EMPTY
50717: LIST
50718: LIST
50719: PUSH
50720: LD_INT 1
50722: NEG
50723: PUSH
50724: LD_INT 2
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: PUSH
50731: LD_INT 2
50733: NEG
50734: PUSH
50735: LD_INT 1
50737: PUSH
50738: EMPTY
50739: LIST
50740: LIST
50741: PUSH
50742: LD_INT 3
50744: NEG
50745: PUSH
50746: LD_INT 0
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: PUSH
50753: LD_INT 3
50755: NEG
50756: PUSH
50757: LD_INT 1
50759: NEG
50760: PUSH
50761: EMPTY
50762: LIST
50763: LIST
50764: PUSH
50765: EMPTY
50766: LIST
50767: LIST
50768: LIST
50769: LIST
50770: LIST
50771: LIST
50772: LIST
50773: LIST
50774: LIST
50775: LIST
50776: LIST
50777: LIST
50778: LIST
50779: LIST
50780: LIST
50781: LIST
50782: LIST
50783: LIST
50784: LIST
50785: LIST
50786: LIST
50787: LIST
50788: LIST
50789: LIST
50790: LIST
50791: LIST
50792: LIST
50793: LIST
50794: LIST
50795: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
50796: LD_ADDR_VAR 0 44
50800: PUSH
50801: LD_INT 0
50803: PUSH
50804: LD_INT 0
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PUSH
50811: LD_INT 0
50813: PUSH
50814: LD_INT 1
50816: NEG
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: PUSH
50822: LD_INT 1
50824: PUSH
50825: LD_INT 0
50827: PUSH
50828: EMPTY
50829: LIST
50830: LIST
50831: PUSH
50832: LD_INT 1
50834: PUSH
50835: LD_INT 1
50837: PUSH
50838: EMPTY
50839: LIST
50840: LIST
50841: PUSH
50842: LD_INT 0
50844: PUSH
50845: LD_INT 1
50847: PUSH
50848: EMPTY
50849: LIST
50850: LIST
50851: PUSH
50852: LD_INT 1
50854: NEG
50855: PUSH
50856: LD_INT 0
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PUSH
50863: LD_INT 1
50865: NEG
50866: PUSH
50867: LD_INT 1
50869: NEG
50870: PUSH
50871: EMPTY
50872: LIST
50873: LIST
50874: PUSH
50875: LD_INT 1
50877: NEG
50878: PUSH
50879: LD_INT 2
50881: NEG
50882: PUSH
50883: EMPTY
50884: LIST
50885: LIST
50886: PUSH
50887: LD_INT 1
50889: PUSH
50890: LD_INT 1
50892: NEG
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: LD_INT 2
50900: PUSH
50901: LD_INT 0
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: PUSH
50908: LD_INT 2
50910: PUSH
50911: LD_INT 1
50913: PUSH
50914: EMPTY
50915: LIST
50916: LIST
50917: PUSH
50918: LD_INT 2
50920: PUSH
50921: LD_INT 2
50923: PUSH
50924: EMPTY
50925: LIST
50926: LIST
50927: PUSH
50928: LD_INT 1
50930: PUSH
50931: LD_INT 2
50933: PUSH
50934: EMPTY
50935: LIST
50936: LIST
50937: PUSH
50938: LD_INT 1
50940: NEG
50941: PUSH
50942: LD_INT 1
50944: PUSH
50945: EMPTY
50946: LIST
50947: LIST
50948: PUSH
50949: LD_INT 2
50951: NEG
50952: PUSH
50953: LD_INT 0
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 2
50962: NEG
50963: PUSH
50964: LD_INT 1
50966: NEG
50967: PUSH
50968: EMPTY
50969: LIST
50970: LIST
50971: PUSH
50972: LD_INT 2
50974: NEG
50975: PUSH
50976: LD_INT 2
50978: NEG
50979: PUSH
50980: EMPTY
50981: LIST
50982: LIST
50983: PUSH
50984: LD_INT 2
50986: NEG
50987: PUSH
50988: LD_INT 3
50990: NEG
50991: PUSH
50992: EMPTY
50993: LIST
50994: LIST
50995: PUSH
50996: LD_INT 2
50998: PUSH
50999: LD_INT 1
51001: NEG
51002: PUSH
51003: EMPTY
51004: LIST
51005: LIST
51006: PUSH
51007: LD_INT 3
51009: PUSH
51010: LD_INT 0
51012: PUSH
51013: EMPTY
51014: LIST
51015: LIST
51016: PUSH
51017: LD_INT 3
51019: PUSH
51020: LD_INT 1
51022: PUSH
51023: EMPTY
51024: LIST
51025: LIST
51026: PUSH
51027: LD_INT 3
51029: PUSH
51030: LD_INT 2
51032: PUSH
51033: EMPTY
51034: LIST
51035: LIST
51036: PUSH
51037: LD_INT 3
51039: PUSH
51040: LD_INT 3
51042: PUSH
51043: EMPTY
51044: LIST
51045: LIST
51046: PUSH
51047: LD_INT 2
51049: PUSH
51050: LD_INT 3
51052: PUSH
51053: EMPTY
51054: LIST
51055: LIST
51056: PUSH
51057: LD_INT 2
51059: NEG
51060: PUSH
51061: LD_INT 1
51063: PUSH
51064: EMPTY
51065: LIST
51066: LIST
51067: PUSH
51068: LD_INT 3
51070: NEG
51071: PUSH
51072: LD_INT 0
51074: PUSH
51075: EMPTY
51076: LIST
51077: LIST
51078: PUSH
51079: LD_INT 3
51081: NEG
51082: PUSH
51083: LD_INT 1
51085: NEG
51086: PUSH
51087: EMPTY
51088: LIST
51089: LIST
51090: PUSH
51091: LD_INT 3
51093: NEG
51094: PUSH
51095: LD_INT 2
51097: NEG
51098: PUSH
51099: EMPTY
51100: LIST
51101: LIST
51102: PUSH
51103: LD_INT 3
51105: NEG
51106: PUSH
51107: LD_INT 3
51109: NEG
51110: PUSH
51111: EMPTY
51112: LIST
51113: LIST
51114: PUSH
51115: EMPTY
51116: LIST
51117: LIST
51118: LIST
51119: LIST
51120: LIST
51121: LIST
51122: LIST
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: LIST
51128: LIST
51129: LIST
51130: LIST
51131: LIST
51132: LIST
51133: LIST
51134: LIST
51135: LIST
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
51146: LD_ADDR_VAR 0 45
51150: PUSH
51151: LD_INT 0
51153: PUSH
51154: LD_INT 0
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: PUSH
51161: LD_INT 0
51163: PUSH
51164: LD_INT 1
51166: NEG
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PUSH
51172: LD_INT 1
51174: PUSH
51175: LD_INT 0
51177: PUSH
51178: EMPTY
51179: LIST
51180: LIST
51181: PUSH
51182: LD_INT 1
51184: PUSH
51185: LD_INT 1
51187: PUSH
51188: EMPTY
51189: LIST
51190: LIST
51191: PUSH
51192: LD_INT 0
51194: PUSH
51195: LD_INT 1
51197: PUSH
51198: EMPTY
51199: LIST
51200: LIST
51201: PUSH
51202: LD_INT 1
51204: NEG
51205: PUSH
51206: LD_INT 0
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: PUSH
51213: LD_INT 1
51215: NEG
51216: PUSH
51217: LD_INT 1
51219: NEG
51220: PUSH
51221: EMPTY
51222: LIST
51223: LIST
51224: PUSH
51225: LD_INT 1
51227: NEG
51228: PUSH
51229: LD_INT 2
51231: NEG
51232: PUSH
51233: EMPTY
51234: LIST
51235: LIST
51236: PUSH
51237: LD_INT 0
51239: PUSH
51240: LD_INT 2
51242: NEG
51243: PUSH
51244: EMPTY
51245: LIST
51246: LIST
51247: PUSH
51248: LD_INT 1
51250: PUSH
51251: LD_INT 1
51253: NEG
51254: PUSH
51255: EMPTY
51256: LIST
51257: LIST
51258: PUSH
51259: LD_INT 2
51261: PUSH
51262: LD_INT 1
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: PUSH
51269: LD_INT 2
51271: PUSH
51272: LD_INT 2
51274: PUSH
51275: EMPTY
51276: LIST
51277: LIST
51278: PUSH
51279: LD_INT 1
51281: PUSH
51282: LD_INT 2
51284: PUSH
51285: EMPTY
51286: LIST
51287: LIST
51288: PUSH
51289: LD_INT 0
51291: PUSH
51292: LD_INT 2
51294: PUSH
51295: EMPTY
51296: LIST
51297: LIST
51298: PUSH
51299: LD_INT 1
51301: NEG
51302: PUSH
51303: LD_INT 1
51305: PUSH
51306: EMPTY
51307: LIST
51308: LIST
51309: PUSH
51310: LD_INT 2
51312: NEG
51313: PUSH
51314: LD_INT 1
51316: NEG
51317: PUSH
51318: EMPTY
51319: LIST
51320: LIST
51321: PUSH
51322: LD_INT 2
51324: NEG
51325: PUSH
51326: LD_INT 2
51328: NEG
51329: PUSH
51330: EMPTY
51331: LIST
51332: LIST
51333: PUSH
51334: LD_INT 2
51336: NEG
51337: PUSH
51338: LD_INT 3
51340: NEG
51341: PUSH
51342: EMPTY
51343: LIST
51344: LIST
51345: PUSH
51346: LD_INT 1
51348: NEG
51349: PUSH
51350: LD_INT 3
51352: NEG
51353: PUSH
51354: EMPTY
51355: LIST
51356: LIST
51357: PUSH
51358: LD_INT 0
51360: PUSH
51361: LD_INT 3
51363: NEG
51364: PUSH
51365: EMPTY
51366: LIST
51367: LIST
51368: PUSH
51369: LD_INT 1
51371: PUSH
51372: LD_INT 2
51374: NEG
51375: PUSH
51376: EMPTY
51377: LIST
51378: LIST
51379: PUSH
51380: LD_INT 3
51382: PUSH
51383: LD_INT 2
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: PUSH
51390: LD_INT 3
51392: PUSH
51393: LD_INT 3
51395: PUSH
51396: EMPTY
51397: LIST
51398: LIST
51399: PUSH
51400: LD_INT 2
51402: PUSH
51403: LD_INT 3
51405: PUSH
51406: EMPTY
51407: LIST
51408: LIST
51409: PUSH
51410: LD_INT 1
51412: PUSH
51413: LD_INT 3
51415: PUSH
51416: EMPTY
51417: LIST
51418: LIST
51419: PUSH
51420: LD_INT 0
51422: PUSH
51423: LD_INT 3
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: PUSH
51430: LD_INT 1
51432: NEG
51433: PUSH
51434: LD_INT 2
51436: PUSH
51437: EMPTY
51438: LIST
51439: LIST
51440: PUSH
51441: LD_INT 3
51443: NEG
51444: PUSH
51445: LD_INT 2
51447: NEG
51448: PUSH
51449: EMPTY
51450: LIST
51451: LIST
51452: PUSH
51453: LD_INT 3
51455: NEG
51456: PUSH
51457: LD_INT 3
51459: NEG
51460: PUSH
51461: EMPTY
51462: LIST
51463: LIST
51464: PUSH
51465: EMPTY
51466: LIST
51467: LIST
51468: LIST
51469: LIST
51470: LIST
51471: LIST
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: LIST
51477: LIST
51478: LIST
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: LIST
51484: LIST
51485: LIST
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: LIST
51494: LIST
51495: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
51496: LD_ADDR_VAR 0 46
51500: PUSH
51501: LD_INT 0
51503: PUSH
51504: LD_INT 0
51506: PUSH
51507: EMPTY
51508: LIST
51509: LIST
51510: PUSH
51511: LD_INT 0
51513: PUSH
51514: LD_INT 1
51516: NEG
51517: PUSH
51518: EMPTY
51519: LIST
51520: LIST
51521: PUSH
51522: LD_INT 1
51524: PUSH
51525: LD_INT 0
51527: PUSH
51528: EMPTY
51529: LIST
51530: LIST
51531: PUSH
51532: LD_INT 1
51534: PUSH
51535: LD_INT 1
51537: PUSH
51538: EMPTY
51539: LIST
51540: LIST
51541: PUSH
51542: LD_INT 0
51544: PUSH
51545: LD_INT 1
51547: PUSH
51548: EMPTY
51549: LIST
51550: LIST
51551: PUSH
51552: LD_INT 1
51554: NEG
51555: PUSH
51556: LD_INT 0
51558: PUSH
51559: EMPTY
51560: LIST
51561: LIST
51562: PUSH
51563: LD_INT 1
51565: NEG
51566: PUSH
51567: LD_INT 1
51569: NEG
51570: PUSH
51571: EMPTY
51572: LIST
51573: LIST
51574: PUSH
51575: LD_INT 1
51577: NEG
51578: PUSH
51579: LD_INT 2
51581: NEG
51582: PUSH
51583: EMPTY
51584: LIST
51585: LIST
51586: PUSH
51587: LD_INT 0
51589: PUSH
51590: LD_INT 2
51592: NEG
51593: PUSH
51594: EMPTY
51595: LIST
51596: LIST
51597: PUSH
51598: LD_INT 1
51600: PUSH
51601: LD_INT 1
51603: NEG
51604: PUSH
51605: EMPTY
51606: LIST
51607: LIST
51608: PUSH
51609: LD_INT 2
51611: PUSH
51612: LD_INT 0
51614: PUSH
51615: EMPTY
51616: LIST
51617: LIST
51618: PUSH
51619: LD_INT 2
51621: PUSH
51622: LD_INT 1
51624: PUSH
51625: EMPTY
51626: LIST
51627: LIST
51628: PUSH
51629: LD_INT 1
51631: PUSH
51632: LD_INT 2
51634: PUSH
51635: EMPTY
51636: LIST
51637: LIST
51638: PUSH
51639: LD_INT 0
51641: PUSH
51642: LD_INT 2
51644: PUSH
51645: EMPTY
51646: LIST
51647: LIST
51648: PUSH
51649: LD_INT 1
51651: NEG
51652: PUSH
51653: LD_INT 1
51655: PUSH
51656: EMPTY
51657: LIST
51658: LIST
51659: PUSH
51660: LD_INT 2
51662: NEG
51663: PUSH
51664: LD_INT 0
51666: PUSH
51667: EMPTY
51668: LIST
51669: LIST
51670: PUSH
51671: LD_INT 2
51673: NEG
51674: PUSH
51675: LD_INT 1
51677: NEG
51678: PUSH
51679: EMPTY
51680: LIST
51681: LIST
51682: PUSH
51683: LD_INT 1
51685: NEG
51686: PUSH
51687: LD_INT 3
51689: NEG
51690: PUSH
51691: EMPTY
51692: LIST
51693: LIST
51694: PUSH
51695: LD_INT 0
51697: PUSH
51698: LD_INT 3
51700: NEG
51701: PUSH
51702: EMPTY
51703: LIST
51704: LIST
51705: PUSH
51706: LD_INT 1
51708: PUSH
51709: LD_INT 2
51711: NEG
51712: PUSH
51713: EMPTY
51714: LIST
51715: LIST
51716: PUSH
51717: LD_INT 2
51719: PUSH
51720: LD_INT 1
51722: NEG
51723: PUSH
51724: EMPTY
51725: LIST
51726: LIST
51727: PUSH
51728: LD_INT 3
51730: PUSH
51731: LD_INT 0
51733: PUSH
51734: EMPTY
51735: LIST
51736: LIST
51737: PUSH
51738: LD_INT 3
51740: PUSH
51741: LD_INT 1
51743: PUSH
51744: EMPTY
51745: LIST
51746: LIST
51747: PUSH
51748: LD_INT 1
51750: PUSH
51751: LD_INT 3
51753: PUSH
51754: EMPTY
51755: LIST
51756: LIST
51757: PUSH
51758: LD_INT 0
51760: PUSH
51761: LD_INT 3
51763: PUSH
51764: EMPTY
51765: LIST
51766: LIST
51767: PUSH
51768: LD_INT 1
51770: NEG
51771: PUSH
51772: LD_INT 2
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: PUSH
51779: LD_INT 2
51781: NEG
51782: PUSH
51783: LD_INT 1
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: PUSH
51790: LD_INT 3
51792: NEG
51793: PUSH
51794: LD_INT 0
51796: PUSH
51797: EMPTY
51798: LIST
51799: LIST
51800: PUSH
51801: LD_INT 3
51803: NEG
51804: PUSH
51805: LD_INT 1
51807: NEG
51808: PUSH
51809: EMPTY
51810: LIST
51811: LIST
51812: PUSH
51813: EMPTY
51814: LIST
51815: LIST
51816: LIST
51817: LIST
51818: LIST
51819: LIST
51820: LIST
51821: LIST
51822: LIST
51823: LIST
51824: LIST
51825: LIST
51826: LIST
51827: LIST
51828: LIST
51829: LIST
51830: LIST
51831: LIST
51832: LIST
51833: LIST
51834: LIST
51835: LIST
51836: LIST
51837: LIST
51838: LIST
51839: LIST
51840: LIST
51841: LIST
51842: LIST
51843: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
51844: LD_ADDR_VAR 0 47
51848: PUSH
51849: LD_INT 0
51851: PUSH
51852: LD_INT 0
51854: PUSH
51855: EMPTY
51856: LIST
51857: LIST
51858: PUSH
51859: LD_INT 0
51861: PUSH
51862: LD_INT 1
51864: NEG
51865: PUSH
51866: EMPTY
51867: LIST
51868: LIST
51869: PUSH
51870: LD_INT 1
51872: PUSH
51873: LD_INT 0
51875: PUSH
51876: EMPTY
51877: LIST
51878: LIST
51879: PUSH
51880: LD_INT 1
51882: PUSH
51883: LD_INT 1
51885: PUSH
51886: EMPTY
51887: LIST
51888: LIST
51889: PUSH
51890: LD_INT 0
51892: PUSH
51893: LD_INT 1
51895: PUSH
51896: EMPTY
51897: LIST
51898: LIST
51899: PUSH
51900: LD_INT 1
51902: NEG
51903: PUSH
51904: LD_INT 0
51906: PUSH
51907: EMPTY
51908: LIST
51909: LIST
51910: PUSH
51911: LD_INT 1
51913: NEG
51914: PUSH
51915: LD_INT 1
51917: NEG
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: PUSH
51923: LD_INT 1
51925: NEG
51926: PUSH
51927: LD_INT 2
51929: NEG
51930: PUSH
51931: EMPTY
51932: LIST
51933: LIST
51934: PUSH
51935: LD_INT 0
51937: PUSH
51938: LD_INT 2
51940: NEG
51941: PUSH
51942: EMPTY
51943: LIST
51944: LIST
51945: PUSH
51946: LD_INT 1
51948: PUSH
51949: LD_INT 1
51951: NEG
51952: PUSH
51953: EMPTY
51954: LIST
51955: LIST
51956: PUSH
51957: LD_INT 2
51959: NEG
51960: PUSH
51961: LD_INT 1
51963: NEG
51964: PUSH
51965: EMPTY
51966: LIST
51967: LIST
51968: PUSH
51969: LD_INT 2
51971: NEG
51972: PUSH
51973: LD_INT 2
51975: NEG
51976: PUSH
51977: EMPTY
51978: LIST
51979: LIST
51980: PUSH
51981: EMPTY
51982: LIST
51983: LIST
51984: LIST
51985: LIST
51986: LIST
51987: LIST
51988: LIST
51989: LIST
51990: LIST
51991: LIST
51992: LIST
51993: LIST
51994: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
51995: LD_ADDR_VAR 0 48
51999: PUSH
52000: LD_INT 0
52002: PUSH
52003: LD_INT 0
52005: PUSH
52006: EMPTY
52007: LIST
52008: LIST
52009: PUSH
52010: LD_INT 0
52012: PUSH
52013: LD_INT 1
52015: NEG
52016: PUSH
52017: EMPTY
52018: LIST
52019: LIST
52020: PUSH
52021: LD_INT 1
52023: PUSH
52024: LD_INT 0
52026: PUSH
52027: EMPTY
52028: LIST
52029: LIST
52030: PUSH
52031: LD_INT 1
52033: PUSH
52034: LD_INT 1
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: PUSH
52041: LD_INT 0
52043: PUSH
52044: LD_INT 1
52046: PUSH
52047: EMPTY
52048: LIST
52049: LIST
52050: PUSH
52051: LD_INT 1
52053: NEG
52054: PUSH
52055: LD_INT 0
52057: PUSH
52058: EMPTY
52059: LIST
52060: LIST
52061: PUSH
52062: LD_INT 1
52064: NEG
52065: PUSH
52066: LD_INT 1
52068: NEG
52069: PUSH
52070: EMPTY
52071: LIST
52072: LIST
52073: PUSH
52074: LD_INT 1
52076: NEG
52077: PUSH
52078: LD_INT 2
52080: NEG
52081: PUSH
52082: EMPTY
52083: LIST
52084: LIST
52085: PUSH
52086: LD_INT 0
52088: PUSH
52089: LD_INT 2
52091: NEG
52092: PUSH
52093: EMPTY
52094: LIST
52095: LIST
52096: PUSH
52097: LD_INT 1
52099: PUSH
52100: LD_INT 1
52102: NEG
52103: PUSH
52104: EMPTY
52105: LIST
52106: LIST
52107: PUSH
52108: LD_INT 2
52110: PUSH
52111: LD_INT 0
52113: PUSH
52114: EMPTY
52115: LIST
52116: LIST
52117: PUSH
52118: LD_INT 2
52120: PUSH
52121: LD_INT 1
52123: PUSH
52124: EMPTY
52125: LIST
52126: LIST
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: LIST
52132: LIST
52133: LIST
52134: LIST
52135: LIST
52136: LIST
52137: LIST
52138: LIST
52139: LIST
52140: LIST
52141: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
52142: LD_ADDR_VAR 0 49
52146: PUSH
52147: LD_INT 0
52149: PUSH
52150: LD_INT 0
52152: PUSH
52153: EMPTY
52154: LIST
52155: LIST
52156: PUSH
52157: LD_INT 0
52159: PUSH
52160: LD_INT 1
52162: NEG
52163: PUSH
52164: EMPTY
52165: LIST
52166: LIST
52167: PUSH
52168: LD_INT 1
52170: PUSH
52171: LD_INT 0
52173: PUSH
52174: EMPTY
52175: LIST
52176: LIST
52177: PUSH
52178: LD_INT 1
52180: PUSH
52181: LD_INT 1
52183: PUSH
52184: EMPTY
52185: LIST
52186: LIST
52187: PUSH
52188: LD_INT 0
52190: PUSH
52191: LD_INT 1
52193: PUSH
52194: EMPTY
52195: LIST
52196: LIST
52197: PUSH
52198: LD_INT 1
52200: NEG
52201: PUSH
52202: LD_INT 0
52204: PUSH
52205: EMPTY
52206: LIST
52207: LIST
52208: PUSH
52209: LD_INT 1
52211: NEG
52212: PUSH
52213: LD_INT 1
52215: NEG
52216: PUSH
52217: EMPTY
52218: LIST
52219: LIST
52220: PUSH
52221: LD_INT 1
52223: PUSH
52224: LD_INT 1
52226: NEG
52227: PUSH
52228: EMPTY
52229: LIST
52230: LIST
52231: PUSH
52232: LD_INT 2
52234: PUSH
52235: LD_INT 0
52237: PUSH
52238: EMPTY
52239: LIST
52240: LIST
52241: PUSH
52242: LD_INT 2
52244: PUSH
52245: LD_INT 1
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: PUSH
52252: LD_INT 2
52254: PUSH
52255: LD_INT 2
52257: PUSH
52258: EMPTY
52259: LIST
52260: LIST
52261: PUSH
52262: LD_INT 1
52264: PUSH
52265: LD_INT 2
52267: PUSH
52268: EMPTY
52269: LIST
52270: LIST
52271: PUSH
52272: EMPTY
52273: LIST
52274: LIST
52275: LIST
52276: LIST
52277: LIST
52278: LIST
52279: LIST
52280: LIST
52281: LIST
52282: LIST
52283: LIST
52284: LIST
52285: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
52286: LD_ADDR_VAR 0 50
52290: PUSH
52291: LD_INT 0
52293: PUSH
52294: LD_INT 0
52296: PUSH
52297: EMPTY
52298: LIST
52299: LIST
52300: PUSH
52301: LD_INT 0
52303: PUSH
52304: LD_INT 1
52306: NEG
52307: PUSH
52308: EMPTY
52309: LIST
52310: LIST
52311: PUSH
52312: LD_INT 1
52314: PUSH
52315: LD_INT 0
52317: PUSH
52318: EMPTY
52319: LIST
52320: LIST
52321: PUSH
52322: LD_INT 1
52324: PUSH
52325: LD_INT 1
52327: PUSH
52328: EMPTY
52329: LIST
52330: LIST
52331: PUSH
52332: LD_INT 0
52334: PUSH
52335: LD_INT 1
52337: PUSH
52338: EMPTY
52339: LIST
52340: LIST
52341: PUSH
52342: LD_INT 1
52344: NEG
52345: PUSH
52346: LD_INT 0
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: PUSH
52353: LD_INT 1
52355: NEG
52356: PUSH
52357: LD_INT 1
52359: NEG
52360: PUSH
52361: EMPTY
52362: LIST
52363: LIST
52364: PUSH
52365: LD_INT 2
52367: PUSH
52368: LD_INT 1
52370: PUSH
52371: EMPTY
52372: LIST
52373: LIST
52374: PUSH
52375: LD_INT 2
52377: PUSH
52378: LD_INT 2
52380: PUSH
52381: EMPTY
52382: LIST
52383: LIST
52384: PUSH
52385: LD_INT 1
52387: PUSH
52388: LD_INT 2
52390: PUSH
52391: EMPTY
52392: LIST
52393: LIST
52394: PUSH
52395: LD_INT 0
52397: PUSH
52398: LD_INT 2
52400: PUSH
52401: EMPTY
52402: LIST
52403: LIST
52404: PUSH
52405: LD_INT 1
52407: NEG
52408: PUSH
52409: LD_INT 1
52411: PUSH
52412: EMPTY
52413: LIST
52414: LIST
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: LIST
52420: LIST
52421: LIST
52422: LIST
52423: LIST
52424: LIST
52425: LIST
52426: LIST
52427: LIST
52428: LIST
52429: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
52430: LD_ADDR_VAR 0 51
52434: PUSH
52435: LD_INT 0
52437: PUSH
52438: LD_INT 0
52440: PUSH
52441: EMPTY
52442: LIST
52443: LIST
52444: PUSH
52445: LD_INT 0
52447: PUSH
52448: LD_INT 1
52450: NEG
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: PUSH
52456: LD_INT 1
52458: PUSH
52459: LD_INT 0
52461: PUSH
52462: EMPTY
52463: LIST
52464: LIST
52465: PUSH
52466: LD_INT 1
52468: PUSH
52469: LD_INT 1
52471: PUSH
52472: EMPTY
52473: LIST
52474: LIST
52475: PUSH
52476: LD_INT 0
52478: PUSH
52479: LD_INT 1
52481: PUSH
52482: EMPTY
52483: LIST
52484: LIST
52485: PUSH
52486: LD_INT 1
52488: NEG
52489: PUSH
52490: LD_INT 0
52492: PUSH
52493: EMPTY
52494: LIST
52495: LIST
52496: PUSH
52497: LD_INT 1
52499: NEG
52500: PUSH
52501: LD_INT 1
52503: NEG
52504: PUSH
52505: EMPTY
52506: LIST
52507: LIST
52508: PUSH
52509: LD_INT 1
52511: PUSH
52512: LD_INT 2
52514: PUSH
52515: EMPTY
52516: LIST
52517: LIST
52518: PUSH
52519: LD_INT 0
52521: PUSH
52522: LD_INT 2
52524: PUSH
52525: EMPTY
52526: LIST
52527: LIST
52528: PUSH
52529: LD_INT 1
52531: NEG
52532: PUSH
52533: LD_INT 1
52535: PUSH
52536: EMPTY
52537: LIST
52538: LIST
52539: PUSH
52540: LD_INT 2
52542: NEG
52543: PUSH
52544: LD_INT 0
52546: PUSH
52547: EMPTY
52548: LIST
52549: LIST
52550: PUSH
52551: LD_INT 2
52553: NEG
52554: PUSH
52555: LD_INT 1
52557: NEG
52558: PUSH
52559: EMPTY
52560: LIST
52561: LIST
52562: PUSH
52563: EMPTY
52564: LIST
52565: LIST
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: LIST
52575: LIST
52576: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
52577: LD_ADDR_VAR 0 52
52581: PUSH
52582: LD_INT 0
52584: PUSH
52585: LD_INT 0
52587: PUSH
52588: EMPTY
52589: LIST
52590: LIST
52591: PUSH
52592: LD_INT 0
52594: PUSH
52595: LD_INT 1
52597: NEG
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: PUSH
52603: LD_INT 1
52605: PUSH
52606: LD_INT 0
52608: PUSH
52609: EMPTY
52610: LIST
52611: LIST
52612: PUSH
52613: LD_INT 1
52615: PUSH
52616: LD_INT 1
52618: PUSH
52619: EMPTY
52620: LIST
52621: LIST
52622: PUSH
52623: LD_INT 0
52625: PUSH
52626: LD_INT 1
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PUSH
52633: LD_INT 1
52635: NEG
52636: PUSH
52637: LD_INT 0
52639: PUSH
52640: EMPTY
52641: LIST
52642: LIST
52643: PUSH
52644: LD_INT 1
52646: NEG
52647: PUSH
52648: LD_INT 1
52650: NEG
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: PUSH
52656: LD_INT 1
52658: NEG
52659: PUSH
52660: LD_INT 2
52662: NEG
52663: PUSH
52664: EMPTY
52665: LIST
52666: LIST
52667: PUSH
52668: LD_INT 1
52670: NEG
52671: PUSH
52672: LD_INT 1
52674: PUSH
52675: EMPTY
52676: LIST
52677: LIST
52678: PUSH
52679: LD_INT 2
52681: NEG
52682: PUSH
52683: LD_INT 0
52685: PUSH
52686: EMPTY
52687: LIST
52688: LIST
52689: PUSH
52690: LD_INT 2
52692: NEG
52693: PUSH
52694: LD_INT 1
52696: NEG
52697: PUSH
52698: EMPTY
52699: LIST
52700: LIST
52701: PUSH
52702: LD_INT 2
52704: NEG
52705: PUSH
52706: LD_INT 2
52708: NEG
52709: PUSH
52710: EMPTY
52711: LIST
52712: LIST
52713: PUSH
52714: EMPTY
52715: LIST
52716: LIST
52717: LIST
52718: LIST
52719: LIST
52720: LIST
52721: LIST
52722: LIST
52723: LIST
52724: LIST
52725: LIST
52726: LIST
52727: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
52728: LD_ADDR_VAR 0 53
52732: PUSH
52733: LD_INT 0
52735: PUSH
52736: LD_INT 0
52738: PUSH
52739: EMPTY
52740: LIST
52741: LIST
52742: PUSH
52743: LD_INT 0
52745: PUSH
52746: LD_INT 1
52748: NEG
52749: PUSH
52750: EMPTY
52751: LIST
52752: LIST
52753: PUSH
52754: LD_INT 1
52756: PUSH
52757: LD_INT 0
52759: PUSH
52760: EMPTY
52761: LIST
52762: LIST
52763: PUSH
52764: LD_INT 1
52766: PUSH
52767: LD_INT 1
52769: PUSH
52770: EMPTY
52771: LIST
52772: LIST
52773: PUSH
52774: LD_INT 0
52776: PUSH
52777: LD_INT 1
52779: PUSH
52780: EMPTY
52781: LIST
52782: LIST
52783: PUSH
52784: LD_INT 1
52786: NEG
52787: PUSH
52788: LD_INT 0
52790: PUSH
52791: EMPTY
52792: LIST
52793: LIST
52794: PUSH
52795: LD_INT 1
52797: NEG
52798: PUSH
52799: LD_INT 1
52801: NEG
52802: PUSH
52803: EMPTY
52804: LIST
52805: LIST
52806: PUSH
52807: LD_INT 1
52809: NEG
52810: PUSH
52811: LD_INT 2
52813: NEG
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: PUSH
52819: LD_INT 0
52821: PUSH
52822: LD_INT 2
52824: NEG
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: PUSH
52830: LD_INT 1
52832: PUSH
52833: LD_INT 1
52835: NEG
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: PUSH
52841: LD_INT 2
52843: PUSH
52844: LD_INT 0
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: PUSH
52851: LD_INT 2
52853: PUSH
52854: LD_INT 1
52856: PUSH
52857: EMPTY
52858: LIST
52859: LIST
52860: PUSH
52861: LD_INT 2
52863: PUSH
52864: LD_INT 2
52866: PUSH
52867: EMPTY
52868: LIST
52869: LIST
52870: PUSH
52871: LD_INT 1
52873: PUSH
52874: LD_INT 2
52876: PUSH
52877: EMPTY
52878: LIST
52879: LIST
52880: PUSH
52881: LD_INT 0
52883: PUSH
52884: LD_INT 2
52886: PUSH
52887: EMPTY
52888: LIST
52889: LIST
52890: PUSH
52891: LD_INT 1
52893: NEG
52894: PUSH
52895: LD_INT 1
52897: PUSH
52898: EMPTY
52899: LIST
52900: LIST
52901: PUSH
52902: LD_INT 2
52904: NEG
52905: PUSH
52906: LD_INT 0
52908: PUSH
52909: EMPTY
52910: LIST
52911: LIST
52912: PUSH
52913: LD_INT 2
52915: NEG
52916: PUSH
52917: LD_INT 1
52919: NEG
52920: PUSH
52921: EMPTY
52922: LIST
52923: LIST
52924: PUSH
52925: LD_INT 2
52927: NEG
52928: PUSH
52929: LD_INT 2
52931: NEG
52932: PUSH
52933: EMPTY
52934: LIST
52935: LIST
52936: PUSH
52937: EMPTY
52938: LIST
52939: LIST
52940: LIST
52941: LIST
52942: LIST
52943: LIST
52944: LIST
52945: LIST
52946: LIST
52947: LIST
52948: LIST
52949: LIST
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: LIST
52955: LIST
52956: LIST
52957: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
52958: LD_ADDR_VAR 0 54
52962: PUSH
52963: LD_INT 0
52965: PUSH
52966: LD_INT 0
52968: PUSH
52969: EMPTY
52970: LIST
52971: LIST
52972: PUSH
52973: LD_INT 0
52975: PUSH
52976: LD_INT 1
52978: NEG
52979: PUSH
52980: EMPTY
52981: LIST
52982: LIST
52983: PUSH
52984: LD_INT 1
52986: PUSH
52987: LD_INT 0
52989: PUSH
52990: EMPTY
52991: LIST
52992: LIST
52993: PUSH
52994: LD_INT 1
52996: PUSH
52997: LD_INT 1
52999: PUSH
53000: EMPTY
53001: LIST
53002: LIST
53003: PUSH
53004: LD_INT 0
53006: PUSH
53007: LD_INT 1
53009: PUSH
53010: EMPTY
53011: LIST
53012: LIST
53013: PUSH
53014: LD_INT 1
53016: NEG
53017: PUSH
53018: LD_INT 0
53020: PUSH
53021: EMPTY
53022: LIST
53023: LIST
53024: PUSH
53025: LD_INT 1
53027: NEG
53028: PUSH
53029: LD_INT 1
53031: NEG
53032: PUSH
53033: EMPTY
53034: LIST
53035: LIST
53036: PUSH
53037: LD_INT 1
53039: NEG
53040: PUSH
53041: LD_INT 2
53043: NEG
53044: PUSH
53045: EMPTY
53046: LIST
53047: LIST
53048: PUSH
53049: LD_INT 0
53051: PUSH
53052: LD_INT 2
53054: NEG
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: PUSH
53060: LD_INT 1
53062: PUSH
53063: LD_INT 1
53065: NEG
53066: PUSH
53067: EMPTY
53068: LIST
53069: LIST
53070: PUSH
53071: LD_INT 2
53073: PUSH
53074: LD_INT 0
53076: PUSH
53077: EMPTY
53078: LIST
53079: LIST
53080: PUSH
53081: LD_INT 2
53083: PUSH
53084: LD_INT 1
53086: PUSH
53087: EMPTY
53088: LIST
53089: LIST
53090: PUSH
53091: LD_INT 2
53093: PUSH
53094: LD_INT 2
53096: PUSH
53097: EMPTY
53098: LIST
53099: LIST
53100: PUSH
53101: LD_INT 1
53103: PUSH
53104: LD_INT 2
53106: PUSH
53107: EMPTY
53108: LIST
53109: LIST
53110: PUSH
53111: LD_INT 0
53113: PUSH
53114: LD_INT 2
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: PUSH
53121: LD_INT 1
53123: NEG
53124: PUSH
53125: LD_INT 1
53127: PUSH
53128: EMPTY
53129: LIST
53130: LIST
53131: PUSH
53132: LD_INT 2
53134: NEG
53135: PUSH
53136: LD_INT 0
53138: PUSH
53139: EMPTY
53140: LIST
53141: LIST
53142: PUSH
53143: LD_INT 2
53145: NEG
53146: PUSH
53147: LD_INT 1
53149: NEG
53150: PUSH
53151: EMPTY
53152: LIST
53153: LIST
53154: PUSH
53155: LD_INT 2
53157: NEG
53158: PUSH
53159: LD_INT 2
53161: NEG
53162: PUSH
53163: EMPTY
53164: LIST
53165: LIST
53166: PUSH
53167: EMPTY
53168: LIST
53169: LIST
53170: LIST
53171: LIST
53172: LIST
53173: LIST
53174: LIST
53175: LIST
53176: LIST
53177: LIST
53178: LIST
53179: LIST
53180: LIST
53181: LIST
53182: LIST
53183: LIST
53184: LIST
53185: LIST
53186: LIST
53187: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
53188: LD_ADDR_VAR 0 55
53192: PUSH
53193: LD_INT 0
53195: PUSH
53196: LD_INT 0
53198: PUSH
53199: EMPTY
53200: LIST
53201: LIST
53202: PUSH
53203: LD_INT 0
53205: PUSH
53206: LD_INT 1
53208: NEG
53209: PUSH
53210: EMPTY
53211: LIST
53212: LIST
53213: PUSH
53214: LD_INT 1
53216: PUSH
53217: LD_INT 0
53219: PUSH
53220: EMPTY
53221: LIST
53222: LIST
53223: PUSH
53224: LD_INT 1
53226: PUSH
53227: LD_INT 1
53229: PUSH
53230: EMPTY
53231: LIST
53232: LIST
53233: PUSH
53234: LD_INT 0
53236: PUSH
53237: LD_INT 1
53239: PUSH
53240: EMPTY
53241: LIST
53242: LIST
53243: PUSH
53244: LD_INT 1
53246: NEG
53247: PUSH
53248: LD_INT 0
53250: PUSH
53251: EMPTY
53252: LIST
53253: LIST
53254: PUSH
53255: LD_INT 1
53257: NEG
53258: PUSH
53259: LD_INT 1
53261: NEG
53262: PUSH
53263: EMPTY
53264: LIST
53265: LIST
53266: PUSH
53267: LD_INT 1
53269: NEG
53270: PUSH
53271: LD_INT 2
53273: NEG
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: PUSH
53279: LD_INT 0
53281: PUSH
53282: LD_INT 2
53284: NEG
53285: PUSH
53286: EMPTY
53287: LIST
53288: LIST
53289: PUSH
53290: LD_INT 1
53292: PUSH
53293: LD_INT 1
53295: NEG
53296: PUSH
53297: EMPTY
53298: LIST
53299: LIST
53300: PUSH
53301: LD_INT 2
53303: PUSH
53304: LD_INT 0
53306: PUSH
53307: EMPTY
53308: LIST
53309: LIST
53310: PUSH
53311: LD_INT 2
53313: PUSH
53314: LD_INT 1
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: PUSH
53321: LD_INT 2
53323: PUSH
53324: LD_INT 2
53326: PUSH
53327: EMPTY
53328: LIST
53329: LIST
53330: PUSH
53331: LD_INT 1
53333: PUSH
53334: LD_INT 2
53336: PUSH
53337: EMPTY
53338: LIST
53339: LIST
53340: PUSH
53341: LD_INT 0
53343: PUSH
53344: LD_INT 2
53346: PUSH
53347: EMPTY
53348: LIST
53349: LIST
53350: PUSH
53351: LD_INT 1
53353: NEG
53354: PUSH
53355: LD_INT 1
53357: PUSH
53358: EMPTY
53359: LIST
53360: LIST
53361: PUSH
53362: LD_INT 2
53364: NEG
53365: PUSH
53366: LD_INT 0
53368: PUSH
53369: EMPTY
53370: LIST
53371: LIST
53372: PUSH
53373: LD_INT 2
53375: NEG
53376: PUSH
53377: LD_INT 1
53379: NEG
53380: PUSH
53381: EMPTY
53382: LIST
53383: LIST
53384: PUSH
53385: LD_INT 2
53387: NEG
53388: PUSH
53389: LD_INT 2
53391: NEG
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: PUSH
53397: EMPTY
53398: LIST
53399: LIST
53400: LIST
53401: LIST
53402: LIST
53403: LIST
53404: LIST
53405: LIST
53406: LIST
53407: LIST
53408: LIST
53409: LIST
53410: LIST
53411: LIST
53412: LIST
53413: LIST
53414: LIST
53415: LIST
53416: LIST
53417: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
53418: LD_ADDR_VAR 0 56
53422: PUSH
53423: LD_INT 0
53425: PUSH
53426: LD_INT 0
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: PUSH
53433: LD_INT 0
53435: PUSH
53436: LD_INT 1
53438: NEG
53439: PUSH
53440: EMPTY
53441: LIST
53442: LIST
53443: PUSH
53444: LD_INT 1
53446: PUSH
53447: LD_INT 0
53449: PUSH
53450: EMPTY
53451: LIST
53452: LIST
53453: PUSH
53454: LD_INT 1
53456: PUSH
53457: LD_INT 1
53459: PUSH
53460: EMPTY
53461: LIST
53462: LIST
53463: PUSH
53464: LD_INT 0
53466: PUSH
53467: LD_INT 1
53469: PUSH
53470: EMPTY
53471: LIST
53472: LIST
53473: PUSH
53474: LD_INT 1
53476: NEG
53477: PUSH
53478: LD_INT 0
53480: PUSH
53481: EMPTY
53482: LIST
53483: LIST
53484: PUSH
53485: LD_INT 1
53487: NEG
53488: PUSH
53489: LD_INT 1
53491: NEG
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: PUSH
53497: LD_INT 1
53499: NEG
53500: PUSH
53501: LD_INT 2
53503: NEG
53504: PUSH
53505: EMPTY
53506: LIST
53507: LIST
53508: PUSH
53509: LD_INT 0
53511: PUSH
53512: LD_INT 2
53514: NEG
53515: PUSH
53516: EMPTY
53517: LIST
53518: LIST
53519: PUSH
53520: LD_INT 1
53522: PUSH
53523: LD_INT 1
53525: NEG
53526: PUSH
53527: EMPTY
53528: LIST
53529: LIST
53530: PUSH
53531: LD_INT 2
53533: PUSH
53534: LD_INT 0
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: PUSH
53541: LD_INT 2
53543: PUSH
53544: LD_INT 1
53546: PUSH
53547: EMPTY
53548: LIST
53549: LIST
53550: PUSH
53551: LD_INT 2
53553: PUSH
53554: LD_INT 2
53556: PUSH
53557: EMPTY
53558: LIST
53559: LIST
53560: PUSH
53561: LD_INT 1
53563: PUSH
53564: LD_INT 2
53566: PUSH
53567: EMPTY
53568: LIST
53569: LIST
53570: PUSH
53571: LD_INT 0
53573: PUSH
53574: LD_INT 2
53576: PUSH
53577: EMPTY
53578: LIST
53579: LIST
53580: PUSH
53581: LD_INT 1
53583: NEG
53584: PUSH
53585: LD_INT 1
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PUSH
53592: LD_INT 2
53594: NEG
53595: PUSH
53596: LD_INT 0
53598: PUSH
53599: EMPTY
53600: LIST
53601: LIST
53602: PUSH
53603: LD_INT 2
53605: NEG
53606: PUSH
53607: LD_INT 1
53609: NEG
53610: PUSH
53611: EMPTY
53612: LIST
53613: LIST
53614: PUSH
53615: LD_INT 2
53617: NEG
53618: PUSH
53619: LD_INT 2
53621: NEG
53622: PUSH
53623: EMPTY
53624: LIST
53625: LIST
53626: PUSH
53627: EMPTY
53628: LIST
53629: LIST
53630: LIST
53631: LIST
53632: LIST
53633: LIST
53634: LIST
53635: LIST
53636: LIST
53637: LIST
53638: LIST
53639: LIST
53640: LIST
53641: LIST
53642: LIST
53643: LIST
53644: LIST
53645: LIST
53646: LIST
53647: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
53648: LD_ADDR_VAR 0 57
53652: PUSH
53653: LD_INT 0
53655: PUSH
53656: LD_INT 0
53658: PUSH
53659: EMPTY
53660: LIST
53661: LIST
53662: PUSH
53663: LD_INT 0
53665: PUSH
53666: LD_INT 1
53668: NEG
53669: PUSH
53670: EMPTY
53671: LIST
53672: LIST
53673: PUSH
53674: LD_INT 1
53676: PUSH
53677: LD_INT 0
53679: PUSH
53680: EMPTY
53681: LIST
53682: LIST
53683: PUSH
53684: LD_INT 1
53686: PUSH
53687: LD_INT 1
53689: PUSH
53690: EMPTY
53691: LIST
53692: LIST
53693: PUSH
53694: LD_INT 0
53696: PUSH
53697: LD_INT 1
53699: PUSH
53700: EMPTY
53701: LIST
53702: LIST
53703: PUSH
53704: LD_INT 1
53706: NEG
53707: PUSH
53708: LD_INT 0
53710: PUSH
53711: EMPTY
53712: LIST
53713: LIST
53714: PUSH
53715: LD_INT 1
53717: NEG
53718: PUSH
53719: LD_INT 1
53721: NEG
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: PUSH
53727: LD_INT 1
53729: NEG
53730: PUSH
53731: LD_INT 2
53733: NEG
53734: PUSH
53735: EMPTY
53736: LIST
53737: LIST
53738: PUSH
53739: LD_INT 0
53741: PUSH
53742: LD_INT 2
53744: NEG
53745: PUSH
53746: EMPTY
53747: LIST
53748: LIST
53749: PUSH
53750: LD_INT 1
53752: PUSH
53753: LD_INT 1
53755: NEG
53756: PUSH
53757: EMPTY
53758: LIST
53759: LIST
53760: PUSH
53761: LD_INT 2
53763: PUSH
53764: LD_INT 0
53766: PUSH
53767: EMPTY
53768: LIST
53769: LIST
53770: PUSH
53771: LD_INT 2
53773: PUSH
53774: LD_INT 1
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: LD_INT 2
53783: PUSH
53784: LD_INT 2
53786: PUSH
53787: EMPTY
53788: LIST
53789: LIST
53790: PUSH
53791: LD_INT 1
53793: PUSH
53794: LD_INT 2
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 0
53803: PUSH
53804: LD_INT 2
53806: PUSH
53807: EMPTY
53808: LIST
53809: LIST
53810: PUSH
53811: LD_INT 1
53813: NEG
53814: PUSH
53815: LD_INT 1
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: PUSH
53822: LD_INT 2
53824: NEG
53825: PUSH
53826: LD_INT 0
53828: PUSH
53829: EMPTY
53830: LIST
53831: LIST
53832: PUSH
53833: LD_INT 2
53835: NEG
53836: PUSH
53837: LD_INT 1
53839: NEG
53840: PUSH
53841: EMPTY
53842: LIST
53843: LIST
53844: PUSH
53845: LD_INT 2
53847: NEG
53848: PUSH
53849: LD_INT 2
53851: NEG
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: LIST
53861: LIST
53862: LIST
53863: LIST
53864: LIST
53865: LIST
53866: LIST
53867: LIST
53868: LIST
53869: LIST
53870: LIST
53871: LIST
53872: LIST
53873: LIST
53874: LIST
53875: LIST
53876: LIST
53877: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
53878: LD_ADDR_VAR 0 58
53882: PUSH
53883: LD_INT 0
53885: PUSH
53886: LD_INT 0
53888: PUSH
53889: EMPTY
53890: LIST
53891: LIST
53892: PUSH
53893: LD_INT 0
53895: PUSH
53896: LD_INT 1
53898: NEG
53899: PUSH
53900: EMPTY
53901: LIST
53902: LIST
53903: PUSH
53904: LD_INT 1
53906: PUSH
53907: LD_INT 0
53909: PUSH
53910: EMPTY
53911: LIST
53912: LIST
53913: PUSH
53914: LD_INT 1
53916: PUSH
53917: LD_INT 1
53919: PUSH
53920: EMPTY
53921: LIST
53922: LIST
53923: PUSH
53924: LD_INT 0
53926: PUSH
53927: LD_INT 1
53929: PUSH
53930: EMPTY
53931: LIST
53932: LIST
53933: PUSH
53934: LD_INT 1
53936: NEG
53937: PUSH
53938: LD_INT 0
53940: PUSH
53941: EMPTY
53942: LIST
53943: LIST
53944: PUSH
53945: LD_INT 1
53947: NEG
53948: PUSH
53949: LD_INT 1
53951: NEG
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: PUSH
53957: LD_INT 1
53959: NEG
53960: PUSH
53961: LD_INT 2
53963: NEG
53964: PUSH
53965: EMPTY
53966: LIST
53967: LIST
53968: PUSH
53969: LD_INT 0
53971: PUSH
53972: LD_INT 2
53974: NEG
53975: PUSH
53976: EMPTY
53977: LIST
53978: LIST
53979: PUSH
53980: LD_INT 1
53982: PUSH
53983: LD_INT 1
53985: NEG
53986: PUSH
53987: EMPTY
53988: LIST
53989: LIST
53990: PUSH
53991: LD_INT 2
53993: PUSH
53994: LD_INT 0
53996: PUSH
53997: EMPTY
53998: LIST
53999: LIST
54000: PUSH
54001: LD_INT 2
54003: PUSH
54004: LD_INT 1
54006: PUSH
54007: EMPTY
54008: LIST
54009: LIST
54010: PUSH
54011: LD_INT 2
54013: PUSH
54014: LD_INT 2
54016: PUSH
54017: EMPTY
54018: LIST
54019: LIST
54020: PUSH
54021: LD_INT 1
54023: PUSH
54024: LD_INT 2
54026: PUSH
54027: EMPTY
54028: LIST
54029: LIST
54030: PUSH
54031: LD_INT 0
54033: PUSH
54034: LD_INT 2
54036: PUSH
54037: EMPTY
54038: LIST
54039: LIST
54040: PUSH
54041: LD_INT 1
54043: NEG
54044: PUSH
54045: LD_INT 1
54047: PUSH
54048: EMPTY
54049: LIST
54050: LIST
54051: PUSH
54052: LD_INT 2
54054: NEG
54055: PUSH
54056: LD_INT 0
54058: PUSH
54059: EMPTY
54060: LIST
54061: LIST
54062: PUSH
54063: LD_INT 2
54065: NEG
54066: PUSH
54067: LD_INT 1
54069: NEG
54070: PUSH
54071: EMPTY
54072: LIST
54073: LIST
54074: PUSH
54075: LD_INT 2
54077: NEG
54078: PUSH
54079: LD_INT 2
54081: NEG
54082: PUSH
54083: EMPTY
54084: LIST
54085: LIST
54086: PUSH
54087: EMPTY
54088: LIST
54089: LIST
54090: LIST
54091: LIST
54092: LIST
54093: LIST
54094: LIST
54095: LIST
54096: LIST
54097: LIST
54098: LIST
54099: LIST
54100: LIST
54101: LIST
54102: LIST
54103: LIST
54104: LIST
54105: LIST
54106: LIST
54107: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
54108: LD_ADDR_VAR 0 59
54112: PUSH
54113: LD_INT 0
54115: PUSH
54116: LD_INT 0
54118: PUSH
54119: EMPTY
54120: LIST
54121: LIST
54122: PUSH
54123: LD_INT 0
54125: PUSH
54126: LD_INT 1
54128: NEG
54129: PUSH
54130: EMPTY
54131: LIST
54132: LIST
54133: PUSH
54134: LD_INT 1
54136: PUSH
54137: LD_INT 0
54139: PUSH
54140: EMPTY
54141: LIST
54142: LIST
54143: PUSH
54144: LD_INT 1
54146: PUSH
54147: LD_INT 1
54149: PUSH
54150: EMPTY
54151: LIST
54152: LIST
54153: PUSH
54154: LD_INT 0
54156: PUSH
54157: LD_INT 1
54159: PUSH
54160: EMPTY
54161: LIST
54162: LIST
54163: PUSH
54164: LD_INT 1
54166: NEG
54167: PUSH
54168: LD_INT 0
54170: PUSH
54171: EMPTY
54172: LIST
54173: LIST
54174: PUSH
54175: LD_INT 1
54177: NEG
54178: PUSH
54179: LD_INT 1
54181: NEG
54182: PUSH
54183: EMPTY
54184: LIST
54185: LIST
54186: PUSH
54187: EMPTY
54188: LIST
54189: LIST
54190: LIST
54191: LIST
54192: LIST
54193: LIST
54194: LIST
54195: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
54196: LD_ADDR_VAR 0 60
54200: PUSH
54201: LD_INT 0
54203: PUSH
54204: LD_INT 0
54206: PUSH
54207: EMPTY
54208: LIST
54209: LIST
54210: PUSH
54211: LD_INT 0
54213: PUSH
54214: LD_INT 1
54216: NEG
54217: PUSH
54218: EMPTY
54219: LIST
54220: LIST
54221: PUSH
54222: LD_INT 1
54224: PUSH
54225: LD_INT 0
54227: PUSH
54228: EMPTY
54229: LIST
54230: LIST
54231: PUSH
54232: LD_INT 1
54234: PUSH
54235: LD_INT 1
54237: PUSH
54238: EMPTY
54239: LIST
54240: LIST
54241: PUSH
54242: LD_INT 0
54244: PUSH
54245: LD_INT 1
54247: PUSH
54248: EMPTY
54249: LIST
54250: LIST
54251: PUSH
54252: LD_INT 1
54254: NEG
54255: PUSH
54256: LD_INT 0
54258: PUSH
54259: EMPTY
54260: LIST
54261: LIST
54262: PUSH
54263: LD_INT 1
54265: NEG
54266: PUSH
54267: LD_INT 1
54269: NEG
54270: PUSH
54271: EMPTY
54272: LIST
54273: LIST
54274: PUSH
54275: EMPTY
54276: LIST
54277: LIST
54278: LIST
54279: LIST
54280: LIST
54281: LIST
54282: LIST
54283: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
54284: LD_ADDR_VAR 0 61
54288: PUSH
54289: LD_INT 0
54291: PUSH
54292: LD_INT 0
54294: PUSH
54295: EMPTY
54296: LIST
54297: LIST
54298: PUSH
54299: LD_INT 0
54301: PUSH
54302: LD_INT 1
54304: NEG
54305: PUSH
54306: EMPTY
54307: LIST
54308: LIST
54309: PUSH
54310: LD_INT 1
54312: PUSH
54313: LD_INT 0
54315: PUSH
54316: EMPTY
54317: LIST
54318: LIST
54319: PUSH
54320: LD_INT 1
54322: PUSH
54323: LD_INT 1
54325: PUSH
54326: EMPTY
54327: LIST
54328: LIST
54329: PUSH
54330: LD_INT 0
54332: PUSH
54333: LD_INT 1
54335: PUSH
54336: EMPTY
54337: LIST
54338: LIST
54339: PUSH
54340: LD_INT 1
54342: NEG
54343: PUSH
54344: LD_INT 0
54346: PUSH
54347: EMPTY
54348: LIST
54349: LIST
54350: PUSH
54351: LD_INT 1
54353: NEG
54354: PUSH
54355: LD_INT 1
54357: NEG
54358: PUSH
54359: EMPTY
54360: LIST
54361: LIST
54362: PUSH
54363: EMPTY
54364: LIST
54365: LIST
54366: LIST
54367: LIST
54368: LIST
54369: LIST
54370: LIST
54371: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
54372: LD_ADDR_VAR 0 62
54376: PUSH
54377: LD_INT 0
54379: PUSH
54380: LD_INT 0
54382: PUSH
54383: EMPTY
54384: LIST
54385: LIST
54386: PUSH
54387: LD_INT 0
54389: PUSH
54390: LD_INT 1
54392: NEG
54393: PUSH
54394: EMPTY
54395: LIST
54396: LIST
54397: PUSH
54398: LD_INT 1
54400: PUSH
54401: LD_INT 0
54403: PUSH
54404: EMPTY
54405: LIST
54406: LIST
54407: PUSH
54408: LD_INT 1
54410: PUSH
54411: LD_INT 1
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: PUSH
54418: LD_INT 0
54420: PUSH
54421: LD_INT 1
54423: PUSH
54424: EMPTY
54425: LIST
54426: LIST
54427: PUSH
54428: LD_INT 1
54430: NEG
54431: PUSH
54432: LD_INT 0
54434: PUSH
54435: EMPTY
54436: LIST
54437: LIST
54438: PUSH
54439: LD_INT 1
54441: NEG
54442: PUSH
54443: LD_INT 1
54445: NEG
54446: PUSH
54447: EMPTY
54448: LIST
54449: LIST
54450: PUSH
54451: EMPTY
54452: LIST
54453: LIST
54454: LIST
54455: LIST
54456: LIST
54457: LIST
54458: LIST
54459: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
54460: LD_ADDR_VAR 0 63
54464: PUSH
54465: LD_INT 0
54467: PUSH
54468: LD_INT 0
54470: PUSH
54471: EMPTY
54472: LIST
54473: LIST
54474: PUSH
54475: LD_INT 0
54477: PUSH
54478: LD_INT 1
54480: NEG
54481: PUSH
54482: EMPTY
54483: LIST
54484: LIST
54485: PUSH
54486: LD_INT 1
54488: PUSH
54489: LD_INT 0
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: PUSH
54496: LD_INT 1
54498: PUSH
54499: LD_INT 1
54501: PUSH
54502: EMPTY
54503: LIST
54504: LIST
54505: PUSH
54506: LD_INT 0
54508: PUSH
54509: LD_INT 1
54511: PUSH
54512: EMPTY
54513: LIST
54514: LIST
54515: PUSH
54516: LD_INT 1
54518: NEG
54519: PUSH
54520: LD_INT 0
54522: PUSH
54523: EMPTY
54524: LIST
54525: LIST
54526: PUSH
54527: LD_INT 1
54529: NEG
54530: PUSH
54531: LD_INT 1
54533: NEG
54534: PUSH
54535: EMPTY
54536: LIST
54537: LIST
54538: PUSH
54539: EMPTY
54540: LIST
54541: LIST
54542: LIST
54543: LIST
54544: LIST
54545: LIST
54546: LIST
54547: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
54548: LD_ADDR_VAR 0 64
54552: PUSH
54553: LD_INT 0
54555: PUSH
54556: LD_INT 0
54558: PUSH
54559: EMPTY
54560: LIST
54561: LIST
54562: PUSH
54563: LD_INT 0
54565: PUSH
54566: LD_INT 1
54568: NEG
54569: PUSH
54570: EMPTY
54571: LIST
54572: LIST
54573: PUSH
54574: LD_INT 1
54576: PUSH
54577: LD_INT 0
54579: PUSH
54580: EMPTY
54581: LIST
54582: LIST
54583: PUSH
54584: LD_INT 1
54586: PUSH
54587: LD_INT 1
54589: PUSH
54590: EMPTY
54591: LIST
54592: LIST
54593: PUSH
54594: LD_INT 0
54596: PUSH
54597: LD_INT 1
54599: PUSH
54600: EMPTY
54601: LIST
54602: LIST
54603: PUSH
54604: LD_INT 1
54606: NEG
54607: PUSH
54608: LD_INT 0
54610: PUSH
54611: EMPTY
54612: LIST
54613: LIST
54614: PUSH
54615: LD_INT 1
54617: NEG
54618: PUSH
54619: LD_INT 1
54621: NEG
54622: PUSH
54623: EMPTY
54624: LIST
54625: LIST
54626: PUSH
54627: EMPTY
54628: LIST
54629: LIST
54630: LIST
54631: LIST
54632: LIST
54633: LIST
54634: LIST
54635: ST_TO_ADDR
// end ; 1 :
54636: GO 60533
54638: LD_INT 1
54640: DOUBLE
54641: EQUAL
54642: IFTRUE 54646
54644: GO 57269
54646: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
54647: LD_ADDR_VAR 0 11
54651: PUSH
54652: LD_INT 1
54654: NEG
54655: PUSH
54656: LD_INT 3
54658: NEG
54659: PUSH
54660: EMPTY
54661: LIST
54662: LIST
54663: PUSH
54664: LD_INT 0
54666: PUSH
54667: LD_INT 3
54669: NEG
54670: PUSH
54671: EMPTY
54672: LIST
54673: LIST
54674: PUSH
54675: LD_INT 1
54677: PUSH
54678: LD_INT 2
54680: NEG
54681: PUSH
54682: EMPTY
54683: LIST
54684: LIST
54685: PUSH
54686: EMPTY
54687: LIST
54688: LIST
54689: LIST
54690: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
54691: LD_ADDR_VAR 0 12
54695: PUSH
54696: LD_INT 2
54698: PUSH
54699: LD_INT 1
54701: NEG
54702: PUSH
54703: EMPTY
54704: LIST
54705: LIST
54706: PUSH
54707: LD_INT 3
54709: PUSH
54710: LD_INT 0
54712: PUSH
54713: EMPTY
54714: LIST
54715: LIST
54716: PUSH
54717: LD_INT 3
54719: PUSH
54720: LD_INT 1
54722: PUSH
54723: EMPTY
54724: LIST
54725: LIST
54726: PUSH
54727: EMPTY
54728: LIST
54729: LIST
54730: LIST
54731: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
54732: LD_ADDR_VAR 0 13
54736: PUSH
54737: LD_INT 3
54739: PUSH
54740: LD_INT 2
54742: PUSH
54743: EMPTY
54744: LIST
54745: LIST
54746: PUSH
54747: LD_INT 3
54749: PUSH
54750: LD_INT 3
54752: PUSH
54753: EMPTY
54754: LIST
54755: LIST
54756: PUSH
54757: LD_INT 2
54759: PUSH
54760: LD_INT 3
54762: PUSH
54763: EMPTY
54764: LIST
54765: LIST
54766: PUSH
54767: EMPTY
54768: LIST
54769: LIST
54770: LIST
54771: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
54772: LD_ADDR_VAR 0 14
54776: PUSH
54777: LD_INT 1
54779: PUSH
54780: LD_INT 3
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: PUSH
54787: LD_INT 0
54789: PUSH
54790: LD_INT 3
54792: PUSH
54793: EMPTY
54794: LIST
54795: LIST
54796: PUSH
54797: LD_INT 1
54799: NEG
54800: PUSH
54801: LD_INT 2
54803: PUSH
54804: EMPTY
54805: LIST
54806: LIST
54807: PUSH
54808: EMPTY
54809: LIST
54810: LIST
54811: LIST
54812: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
54813: LD_ADDR_VAR 0 15
54817: PUSH
54818: LD_INT 2
54820: NEG
54821: PUSH
54822: LD_INT 1
54824: PUSH
54825: EMPTY
54826: LIST
54827: LIST
54828: PUSH
54829: LD_INT 3
54831: NEG
54832: PUSH
54833: LD_INT 0
54835: PUSH
54836: EMPTY
54837: LIST
54838: LIST
54839: PUSH
54840: LD_INT 3
54842: NEG
54843: PUSH
54844: LD_INT 1
54846: NEG
54847: PUSH
54848: EMPTY
54849: LIST
54850: LIST
54851: PUSH
54852: EMPTY
54853: LIST
54854: LIST
54855: LIST
54856: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
54857: LD_ADDR_VAR 0 16
54861: PUSH
54862: LD_INT 2
54864: NEG
54865: PUSH
54866: LD_INT 3
54868: NEG
54869: PUSH
54870: EMPTY
54871: LIST
54872: LIST
54873: PUSH
54874: LD_INT 3
54876: NEG
54877: PUSH
54878: LD_INT 2
54880: NEG
54881: PUSH
54882: EMPTY
54883: LIST
54884: LIST
54885: PUSH
54886: LD_INT 3
54888: NEG
54889: PUSH
54890: LD_INT 3
54892: NEG
54893: PUSH
54894: EMPTY
54895: LIST
54896: LIST
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: LIST
54902: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
54903: LD_ADDR_VAR 0 17
54907: PUSH
54908: LD_INT 1
54910: NEG
54911: PUSH
54912: LD_INT 3
54914: NEG
54915: PUSH
54916: EMPTY
54917: LIST
54918: LIST
54919: PUSH
54920: LD_INT 0
54922: PUSH
54923: LD_INT 3
54925: NEG
54926: PUSH
54927: EMPTY
54928: LIST
54929: LIST
54930: PUSH
54931: LD_INT 1
54933: PUSH
54934: LD_INT 2
54936: NEG
54937: PUSH
54938: EMPTY
54939: LIST
54940: LIST
54941: PUSH
54942: EMPTY
54943: LIST
54944: LIST
54945: LIST
54946: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
54947: LD_ADDR_VAR 0 18
54951: PUSH
54952: LD_INT 2
54954: PUSH
54955: LD_INT 1
54957: NEG
54958: PUSH
54959: EMPTY
54960: LIST
54961: LIST
54962: PUSH
54963: LD_INT 3
54965: PUSH
54966: LD_INT 0
54968: PUSH
54969: EMPTY
54970: LIST
54971: LIST
54972: PUSH
54973: LD_INT 3
54975: PUSH
54976: LD_INT 1
54978: PUSH
54979: EMPTY
54980: LIST
54981: LIST
54982: PUSH
54983: EMPTY
54984: LIST
54985: LIST
54986: LIST
54987: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
54988: LD_ADDR_VAR 0 19
54992: PUSH
54993: LD_INT 3
54995: PUSH
54996: LD_INT 2
54998: PUSH
54999: EMPTY
55000: LIST
55001: LIST
55002: PUSH
55003: LD_INT 3
55005: PUSH
55006: LD_INT 3
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: PUSH
55013: LD_INT 2
55015: PUSH
55016: LD_INT 3
55018: PUSH
55019: EMPTY
55020: LIST
55021: LIST
55022: PUSH
55023: EMPTY
55024: LIST
55025: LIST
55026: LIST
55027: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
55028: LD_ADDR_VAR 0 20
55032: PUSH
55033: LD_INT 1
55035: PUSH
55036: LD_INT 3
55038: PUSH
55039: EMPTY
55040: LIST
55041: LIST
55042: PUSH
55043: LD_INT 0
55045: PUSH
55046: LD_INT 3
55048: PUSH
55049: EMPTY
55050: LIST
55051: LIST
55052: PUSH
55053: LD_INT 1
55055: NEG
55056: PUSH
55057: LD_INT 2
55059: PUSH
55060: EMPTY
55061: LIST
55062: LIST
55063: PUSH
55064: EMPTY
55065: LIST
55066: LIST
55067: LIST
55068: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
55069: LD_ADDR_VAR 0 21
55073: PUSH
55074: LD_INT 2
55076: NEG
55077: PUSH
55078: LD_INT 1
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: PUSH
55085: LD_INT 3
55087: NEG
55088: PUSH
55089: LD_INT 0
55091: PUSH
55092: EMPTY
55093: LIST
55094: LIST
55095: PUSH
55096: LD_INT 3
55098: NEG
55099: PUSH
55100: LD_INT 1
55102: NEG
55103: PUSH
55104: EMPTY
55105: LIST
55106: LIST
55107: PUSH
55108: EMPTY
55109: LIST
55110: LIST
55111: LIST
55112: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
55113: LD_ADDR_VAR 0 22
55117: PUSH
55118: LD_INT 2
55120: NEG
55121: PUSH
55122: LD_INT 3
55124: NEG
55125: PUSH
55126: EMPTY
55127: LIST
55128: LIST
55129: PUSH
55130: LD_INT 3
55132: NEG
55133: PUSH
55134: LD_INT 2
55136: NEG
55137: PUSH
55138: EMPTY
55139: LIST
55140: LIST
55141: PUSH
55142: LD_INT 3
55144: NEG
55145: PUSH
55146: LD_INT 3
55148: NEG
55149: PUSH
55150: EMPTY
55151: LIST
55152: LIST
55153: PUSH
55154: EMPTY
55155: LIST
55156: LIST
55157: LIST
55158: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
55159: LD_ADDR_VAR 0 23
55163: PUSH
55164: LD_INT 0
55166: PUSH
55167: LD_INT 3
55169: NEG
55170: PUSH
55171: EMPTY
55172: LIST
55173: LIST
55174: PUSH
55175: LD_INT 1
55177: NEG
55178: PUSH
55179: LD_INT 4
55181: NEG
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: PUSH
55187: LD_INT 1
55189: PUSH
55190: LD_INT 3
55192: NEG
55193: PUSH
55194: EMPTY
55195: LIST
55196: LIST
55197: PUSH
55198: EMPTY
55199: LIST
55200: LIST
55201: LIST
55202: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
55203: LD_ADDR_VAR 0 24
55207: PUSH
55208: LD_INT 3
55210: PUSH
55211: LD_INT 0
55213: PUSH
55214: EMPTY
55215: LIST
55216: LIST
55217: PUSH
55218: LD_INT 3
55220: PUSH
55221: LD_INT 1
55223: NEG
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: PUSH
55229: LD_INT 4
55231: PUSH
55232: LD_INT 1
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: PUSH
55239: EMPTY
55240: LIST
55241: LIST
55242: LIST
55243: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
55244: LD_ADDR_VAR 0 25
55248: PUSH
55249: LD_INT 3
55251: PUSH
55252: LD_INT 3
55254: PUSH
55255: EMPTY
55256: LIST
55257: LIST
55258: PUSH
55259: LD_INT 4
55261: PUSH
55262: LD_INT 3
55264: PUSH
55265: EMPTY
55266: LIST
55267: LIST
55268: PUSH
55269: LD_INT 3
55271: PUSH
55272: LD_INT 4
55274: PUSH
55275: EMPTY
55276: LIST
55277: LIST
55278: PUSH
55279: EMPTY
55280: LIST
55281: LIST
55282: LIST
55283: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
55284: LD_ADDR_VAR 0 26
55288: PUSH
55289: LD_INT 0
55291: PUSH
55292: LD_INT 3
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: PUSH
55299: LD_INT 1
55301: PUSH
55302: LD_INT 4
55304: PUSH
55305: EMPTY
55306: LIST
55307: LIST
55308: PUSH
55309: LD_INT 1
55311: NEG
55312: PUSH
55313: LD_INT 3
55315: PUSH
55316: EMPTY
55317: LIST
55318: LIST
55319: PUSH
55320: EMPTY
55321: LIST
55322: LIST
55323: LIST
55324: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
55325: LD_ADDR_VAR 0 27
55329: PUSH
55330: LD_INT 3
55332: NEG
55333: PUSH
55334: LD_INT 0
55336: PUSH
55337: EMPTY
55338: LIST
55339: LIST
55340: PUSH
55341: LD_INT 3
55343: NEG
55344: PUSH
55345: LD_INT 1
55347: PUSH
55348: EMPTY
55349: LIST
55350: LIST
55351: PUSH
55352: LD_INT 4
55354: NEG
55355: PUSH
55356: LD_INT 1
55358: NEG
55359: PUSH
55360: EMPTY
55361: LIST
55362: LIST
55363: PUSH
55364: EMPTY
55365: LIST
55366: LIST
55367: LIST
55368: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
55369: LD_ADDR_VAR 0 28
55373: PUSH
55374: LD_INT 3
55376: NEG
55377: PUSH
55378: LD_INT 3
55380: NEG
55381: PUSH
55382: EMPTY
55383: LIST
55384: LIST
55385: PUSH
55386: LD_INT 3
55388: NEG
55389: PUSH
55390: LD_INT 4
55392: NEG
55393: PUSH
55394: EMPTY
55395: LIST
55396: LIST
55397: PUSH
55398: LD_INT 4
55400: NEG
55401: PUSH
55402: LD_INT 3
55404: NEG
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PUSH
55410: EMPTY
55411: LIST
55412: LIST
55413: LIST
55414: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
55415: LD_ADDR_VAR 0 29
55419: PUSH
55420: LD_INT 1
55422: NEG
55423: PUSH
55424: LD_INT 3
55426: NEG
55427: PUSH
55428: EMPTY
55429: LIST
55430: LIST
55431: PUSH
55432: LD_INT 0
55434: PUSH
55435: LD_INT 3
55437: NEG
55438: PUSH
55439: EMPTY
55440: LIST
55441: LIST
55442: PUSH
55443: LD_INT 1
55445: PUSH
55446: LD_INT 2
55448: NEG
55449: PUSH
55450: EMPTY
55451: LIST
55452: LIST
55453: PUSH
55454: LD_INT 1
55456: NEG
55457: PUSH
55458: LD_INT 4
55460: NEG
55461: PUSH
55462: EMPTY
55463: LIST
55464: LIST
55465: PUSH
55466: LD_INT 0
55468: PUSH
55469: LD_INT 4
55471: NEG
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: PUSH
55477: LD_INT 1
55479: PUSH
55480: LD_INT 3
55482: NEG
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: PUSH
55488: LD_INT 1
55490: NEG
55491: PUSH
55492: LD_INT 5
55494: NEG
55495: PUSH
55496: EMPTY
55497: LIST
55498: LIST
55499: PUSH
55500: LD_INT 0
55502: PUSH
55503: LD_INT 5
55505: NEG
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: PUSH
55511: LD_INT 1
55513: PUSH
55514: LD_INT 4
55516: NEG
55517: PUSH
55518: EMPTY
55519: LIST
55520: LIST
55521: PUSH
55522: LD_INT 1
55524: NEG
55525: PUSH
55526: LD_INT 6
55528: NEG
55529: PUSH
55530: EMPTY
55531: LIST
55532: LIST
55533: PUSH
55534: LD_INT 0
55536: PUSH
55537: LD_INT 6
55539: NEG
55540: PUSH
55541: EMPTY
55542: LIST
55543: LIST
55544: PUSH
55545: LD_INT 1
55547: PUSH
55548: LD_INT 5
55550: NEG
55551: PUSH
55552: EMPTY
55553: LIST
55554: LIST
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: LIST
55560: LIST
55561: LIST
55562: LIST
55563: LIST
55564: LIST
55565: LIST
55566: LIST
55567: LIST
55568: LIST
55569: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
55570: LD_ADDR_VAR 0 30
55574: PUSH
55575: LD_INT 2
55577: PUSH
55578: LD_INT 1
55580: NEG
55581: PUSH
55582: EMPTY
55583: LIST
55584: LIST
55585: PUSH
55586: LD_INT 3
55588: PUSH
55589: LD_INT 0
55591: PUSH
55592: EMPTY
55593: LIST
55594: LIST
55595: PUSH
55596: LD_INT 3
55598: PUSH
55599: LD_INT 1
55601: PUSH
55602: EMPTY
55603: LIST
55604: LIST
55605: PUSH
55606: LD_INT 3
55608: PUSH
55609: LD_INT 1
55611: NEG
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: PUSH
55617: LD_INT 4
55619: PUSH
55620: LD_INT 0
55622: PUSH
55623: EMPTY
55624: LIST
55625: LIST
55626: PUSH
55627: LD_INT 4
55629: PUSH
55630: LD_INT 1
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: PUSH
55637: LD_INT 4
55639: PUSH
55640: LD_INT 1
55642: NEG
55643: PUSH
55644: EMPTY
55645: LIST
55646: LIST
55647: PUSH
55648: LD_INT 5
55650: PUSH
55651: LD_INT 0
55653: PUSH
55654: EMPTY
55655: LIST
55656: LIST
55657: PUSH
55658: LD_INT 5
55660: PUSH
55661: LD_INT 1
55663: PUSH
55664: EMPTY
55665: LIST
55666: LIST
55667: PUSH
55668: LD_INT 5
55670: PUSH
55671: LD_INT 1
55673: NEG
55674: PUSH
55675: EMPTY
55676: LIST
55677: LIST
55678: PUSH
55679: LD_INT 6
55681: PUSH
55682: LD_INT 0
55684: PUSH
55685: EMPTY
55686: LIST
55687: LIST
55688: PUSH
55689: LD_INT 6
55691: PUSH
55692: LD_INT 1
55694: PUSH
55695: EMPTY
55696: LIST
55697: LIST
55698: PUSH
55699: EMPTY
55700: LIST
55701: LIST
55702: LIST
55703: LIST
55704: LIST
55705: LIST
55706: LIST
55707: LIST
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
55713: LD_ADDR_VAR 0 31
55717: PUSH
55718: LD_INT 3
55720: PUSH
55721: LD_INT 2
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PUSH
55728: LD_INT 3
55730: PUSH
55731: LD_INT 3
55733: PUSH
55734: EMPTY
55735: LIST
55736: LIST
55737: PUSH
55738: LD_INT 2
55740: PUSH
55741: LD_INT 3
55743: PUSH
55744: EMPTY
55745: LIST
55746: LIST
55747: PUSH
55748: LD_INT 4
55750: PUSH
55751: LD_INT 3
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: PUSH
55758: LD_INT 4
55760: PUSH
55761: LD_INT 4
55763: PUSH
55764: EMPTY
55765: LIST
55766: LIST
55767: PUSH
55768: LD_INT 3
55770: PUSH
55771: LD_INT 4
55773: PUSH
55774: EMPTY
55775: LIST
55776: LIST
55777: PUSH
55778: LD_INT 5
55780: PUSH
55781: LD_INT 4
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: PUSH
55788: LD_INT 5
55790: PUSH
55791: LD_INT 5
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: PUSH
55798: LD_INT 4
55800: PUSH
55801: LD_INT 5
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: PUSH
55808: LD_INT 6
55810: PUSH
55811: LD_INT 5
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: PUSH
55818: LD_INT 6
55820: PUSH
55821: LD_INT 6
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: PUSH
55828: LD_INT 5
55830: PUSH
55831: LD_INT 6
55833: PUSH
55834: EMPTY
55835: LIST
55836: LIST
55837: PUSH
55838: EMPTY
55839: LIST
55840: LIST
55841: LIST
55842: LIST
55843: LIST
55844: LIST
55845: LIST
55846: LIST
55847: LIST
55848: LIST
55849: LIST
55850: LIST
55851: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
55852: LD_ADDR_VAR 0 32
55856: PUSH
55857: LD_INT 1
55859: PUSH
55860: LD_INT 3
55862: PUSH
55863: EMPTY
55864: LIST
55865: LIST
55866: PUSH
55867: LD_INT 0
55869: PUSH
55870: LD_INT 3
55872: PUSH
55873: EMPTY
55874: LIST
55875: LIST
55876: PUSH
55877: LD_INT 1
55879: NEG
55880: PUSH
55881: LD_INT 2
55883: PUSH
55884: EMPTY
55885: LIST
55886: LIST
55887: PUSH
55888: LD_INT 1
55890: PUSH
55891: LD_INT 4
55893: PUSH
55894: EMPTY
55895: LIST
55896: LIST
55897: PUSH
55898: LD_INT 0
55900: PUSH
55901: LD_INT 4
55903: PUSH
55904: EMPTY
55905: LIST
55906: LIST
55907: PUSH
55908: LD_INT 1
55910: NEG
55911: PUSH
55912: LD_INT 3
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: PUSH
55919: LD_INT 1
55921: PUSH
55922: LD_INT 5
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: PUSH
55929: LD_INT 0
55931: PUSH
55932: LD_INT 5
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: LD_INT 1
55941: NEG
55942: PUSH
55943: LD_INT 4
55945: PUSH
55946: EMPTY
55947: LIST
55948: LIST
55949: PUSH
55950: LD_INT 1
55952: PUSH
55953: LD_INT 6
55955: PUSH
55956: EMPTY
55957: LIST
55958: LIST
55959: PUSH
55960: LD_INT 0
55962: PUSH
55963: LD_INT 6
55965: PUSH
55966: EMPTY
55967: LIST
55968: LIST
55969: PUSH
55970: LD_INT 1
55972: NEG
55973: PUSH
55974: LD_INT 5
55976: PUSH
55977: EMPTY
55978: LIST
55979: LIST
55980: PUSH
55981: EMPTY
55982: LIST
55983: LIST
55984: LIST
55985: LIST
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: LIST
55991: LIST
55992: LIST
55993: LIST
55994: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
55995: LD_ADDR_VAR 0 33
55999: PUSH
56000: LD_INT 2
56002: NEG
56003: PUSH
56004: LD_INT 1
56006: PUSH
56007: EMPTY
56008: LIST
56009: LIST
56010: PUSH
56011: LD_INT 3
56013: NEG
56014: PUSH
56015: LD_INT 0
56017: PUSH
56018: EMPTY
56019: LIST
56020: LIST
56021: PUSH
56022: LD_INT 3
56024: NEG
56025: PUSH
56026: LD_INT 1
56028: NEG
56029: PUSH
56030: EMPTY
56031: LIST
56032: LIST
56033: PUSH
56034: LD_INT 3
56036: NEG
56037: PUSH
56038: LD_INT 1
56040: PUSH
56041: EMPTY
56042: LIST
56043: LIST
56044: PUSH
56045: LD_INT 4
56047: NEG
56048: PUSH
56049: LD_INT 0
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PUSH
56056: LD_INT 4
56058: NEG
56059: PUSH
56060: LD_INT 1
56062: NEG
56063: PUSH
56064: EMPTY
56065: LIST
56066: LIST
56067: PUSH
56068: LD_INT 4
56070: NEG
56071: PUSH
56072: LD_INT 1
56074: PUSH
56075: EMPTY
56076: LIST
56077: LIST
56078: PUSH
56079: LD_INT 5
56081: NEG
56082: PUSH
56083: LD_INT 0
56085: PUSH
56086: EMPTY
56087: LIST
56088: LIST
56089: PUSH
56090: LD_INT 5
56092: NEG
56093: PUSH
56094: LD_INT 1
56096: NEG
56097: PUSH
56098: EMPTY
56099: LIST
56100: LIST
56101: PUSH
56102: LD_INT 5
56104: NEG
56105: PUSH
56106: LD_INT 1
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: PUSH
56113: LD_INT 6
56115: NEG
56116: PUSH
56117: LD_INT 0
56119: PUSH
56120: EMPTY
56121: LIST
56122: LIST
56123: PUSH
56124: LD_INT 6
56126: NEG
56127: PUSH
56128: LD_INT 1
56130: NEG
56131: PUSH
56132: EMPTY
56133: LIST
56134: LIST
56135: PUSH
56136: EMPTY
56137: LIST
56138: LIST
56139: LIST
56140: LIST
56141: LIST
56142: LIST
56143: LIST
56144: LIST
56145: LIST
56146: LIST
56147: LIST
56148: LIST
56149: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
56150: LD_ADDR_VAR 0 34
56154: PUSH
56155: LD_INT 2
56157: NEG
56158: PUSH
56159: LD_INT 3
56161: NEG
56162: PUSH
56163: EMPTY
56164: LIST
56165: LIST
56166: PUSH
56167: LD_INT 3
56169: NEG
56170: PUSH
56171: LD_INT 2
56173: NEG
56174: PUSH
56175: EMPTY
56176: LIST
56177: LIST
56178: PUSH
56179: LD_INT 3
56181: NEG
56182: PUSH
56183: LD_INT 3
56185: NEG
56186: PUSH
56187: EMPTY
56188: LIST
56189: LIST
56190: PUSH
56191: LD_INT 3
56193: NEG
56194: PUSH
56195: LD_INT 4
56197: NEG
56198: PUSH
56199: EMPTY
56200: LIST
56201: LIST
56202: PUSH
56203: LD_INT 4
56205: NEG
56206: PUSH
56207: LD_INT 3
56209: NEG
56210: PUSH
56211: EMPTY
56212: LIST
56213: LIST
56214: PUSH
56215: LD_INT 4
56217: NEG
56218: PUSH
56219: LD_INT 4
56221: NEG
56222: PUSH
56223: EMPTY
56224: LIST
56225: LIST
56226: PUSH
56227: LD_INT 4
56229: NEG
56230: PUSH
56231: LD_INT 5
56233: NEG
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: PUSH
56239: LD_INT 5
56241: NEG
56242: PUSH
56243: LD_INT 4
56245: NEG
56246: PUSH
56247: EMPTY
56248: LIST
56249: LIST
56250: PUSH
56251: LD_INT 5
56253: NEG
56254: PUSH
56255: LD_INT 5
56257: NEG
56258: PUSH
56259: EMPTY
56260: LIST
56261: LIST
56262: PUSH
56263: LD_INT 5
56265: NEG
56266: PUSH
56267: LD_INT 6
56269: NEG
56270: PUSH
56271: EMPTY
56272: LIST
56273: LIST
56274: PUSH
56275: LD_INT 6
56277: NEG
56278: PUSH
56279: LD_INT 5
56281: NEG
56282: PUSH
56283: EMPTY
56284: LIST
56285: LIST
56286: PUSH
56287: LD_INT 6
56289: NEG
56290: PUSH
56291: LD_INT 6
56293: NEG
56294: PUSH
56295: EMPTY
56296: LIST
56297: LIST
56298: PUSH
56299: EMPTY
56300: LIST
56301: LIST
56302: LIST
56303: LIST
56304: LIST
56305: LIST
56306: LIST
56307: LIST
56308: LIST
56309: LIST
56310: LIST
56311: LIST
56312: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
56313: LD_ADDR_VAR 0 41
56317: PUSH
56318: LD_INT 0
56320: PUSH
56321: LD_INT 2
56323: NEG
56324: PUSH
56325: EMPTY
56326: LIST
56327: LIST
56328: PUSH
56329: LD_INT 1
56331: NEG
56332: PUSH
56333: LD_INT 3
56335: NEG
56336: PUSH
56337: EMPTY
56338: LIST
56339: LIST
56340: PUSH
56341: LD_INT 1
56343: PUSH
56344: LD_INT 2
56346: NEG
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: PUSH
56352: EMPTY
56353: LIST
56354: LIST
56355: LIST
56356: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
56357: LD_ADDR_VAR 0 42
56361: PUSH
56362: LD_INT 2
56364: PUSH
56365: LD_INT 0
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: PUSH
56372: LD_INT 2
56374: PUSH
56375: LD_INT 1
56377: NEG
56378: PUSH
56379: EMPTY
56380: LIST
56381: LIST
56382: PUSH
56383: LD_INT 3
56385: PUSH
56386: LD_INT 1
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PUSH
56393: EMPTY
56394: LIST
56395: LIST
56396: LIST
56397: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
56398: LD_ADDR_VAR 0 43
56402: PUSH
56403: LD_INT 2
56405: PUSH
56406: LD_INT 2
56408: PUSH
56409: EMPTY
56410: LIST
56411: LIST
56412: PUSH
56413: LD_INT 3
56415: PUSH
56416: LD_INT 2
56418: PUSH
56419: EMPTY
56420: LIST
56421: LIST
56422: PUSH
56423: LD_INT 2
56425: PUSH
56426: LD_INT 3
56428: PUSH
56429: EMPTY
56430: LIST
56431: LIST
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: LIST
56437: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
56438: LD_ADDR_VAR 0 44
56442: PUSH
56443: LD_INT 0
56445: PUSH
56446: LD_INT 2
56448: PUSH
56449: EMPTY
56450: LIST
56451: LIST
56452: PUSH
56453: LD_INT 1
56455: PUSH
56456: LD_INT 3
56458: PUSH
56459: EMPTY
56460: LIST
56461: LIST
56462: PUSH
56463: LD_INT 1
56465: NEG
56466: PUSH
56467: LD_INT 2
56469: PUSH
56470: EMPTY
56471: LIST
56472: LIST
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: LIST
56478: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
56479: LD_ADDR_VAR 0 45
56483: PUSH
56484: LD_INT 2
56486: NEG
56487: PUSH
56488: LD_INT 0
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: PUSH
56495: LD_INT 2
56497: NEG
56498: PUSH
56499: LD_INT 1
56501: PUSH
56502: EMPTY
56503: LIST
56504: LIST
56505: PUSH
56506: LD_INT 3
56508: NEG
56509: PUSH
56510: LD_INT 1
56512: NEG
56513: PUSH
56514: EMPTY
56515: LIST
56516: LIST
56517: PUSH
56518: EMPTY
56519: LIST
56520: LIST
56521: LIST
56522: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
56523: LD_ADDR_VAR 0 46
56527: PUSH
56528: LD_INT 2
56530: NEG
56531: PUSH
56532: LD_INT 2
56534: NEG
56535: PUSH
56536: EMPTY
56537: LIST
56538: LIST
56539: PUSH
56540: LD_INT 2
56542: NEG
56543: PUSH
56544: LD_INT 3
56546: NEG
56547: PUSH
56548: EMPTY
56549: LIST
56550: LIST
56551: PUSH
56552: LD_INT 3
56554: NEG
56555: PUSH
56556: LD_INT 2
56558: NEG
56559: PUSH
56560: EMPTY
56561: LIST
56562: LIST
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: LIST
56568: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
56569: LD_ADDR_VAR 0 47
56573: PUSH
56574: LD_INT 2
56576: NEG
56577: PUSH
56578: LD_INT 3
56580: NEG
56581: PUSH
56582: EMPTY
56583: LIST
56584: LIST
56585: PUSH
56586: LD_INT 1
56588: NEG
56589: PUSH
56590: LD_INT 3
56592: NEG
56593: PUSH
56594: EMPTY
56595: LIST
56596: LIST
56597: PUSH
56598: EMPTY
56599: LIST
56600: LIST
56601: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
56602: LD_ADDR_VAR 0 48
56606: PUSH
56607: LD_INT 1
56609: PUSH
56610: LD_INT 2
56612: NEG
56613: PUSH
56614: EMPTY
56615: LIST
56616: LIST
56617: PUSH
56618: LD_INT 2
56620: PUSH
56621: LD_INT 1
56623: NEG
56624: PUSH
56625: EMPTY
56626: LIST
56627: LIST
56628: PUSH
56629: EMPTY
56630: LIST
56631: LIST
56632: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
56633: LD_ADDR_VAR 0 49
56637: PUSH
56638: LD_INT 3
56640: PUSH
56641: LD_INT 1
56643: PUSH
56644: EMPTY
56645: LIST
56646: LIST
56647: PUSH
56648: LD_INT 3
56650: PUSH
56651: LD_INT 2
56653: PUSH
56654: EMPTY
56655: LIST
56656: LIST
56657: PUSH
56658: EMPTY
56659: LIST
56660: LIST
56661: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
56662: LD_ADDR_VAR 0 50
56666: PUSH
56667: LD_INT 2
56669: PUSH
56670: LD_INT 3
56672: PUSH
56673: EMPTY
56674: LIST
56675: LIST
56676: PUSH
56677: LD_INT 1
56679: PUSH
56680: LD_INT 3
56682: PUSH
56683: EMPTY
56684: LIST
56685: LIST
56686: PUSH
56687: EMPTY
56688: LIST
56689: LIST
56690: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
56691: LD_ADDR_VAR 0 51
56695: PUSH
56696: LD_INT 1
56698: NEG
56699: PUSH
56700: LD_INT 2
56702: PUSH
56703: EMPTY
56704: LIST
56705: LIST
56706: PUSH
56707: LD_INT 2
56709: NEG
56710: PUSH
56711: LD_INT 1
56713: PUSH
56714: EMPTY
56715: LIST
56716: LIST
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
56722: LD_ADDR_VAR 0 52
56726: PUSH
56727: LD_INT 3
56729: NEG
56730: PUSH
56731: LD_INT 1
56733: NEG
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: PUSH
56739: LD_INT 3
56741: NEG
56742: PUSH
56743: LD_INT 2
56745: NEG
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PUSH
56751: EMPTY
56752: LIST
56753: LIST
56754: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
56755: LD_ADDR_VAR 0 53
56759: PUSH
56760: LD_INT 1
56762: NEG
56763: PUSH
56764: LD_INT 3
56766: NEG
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PUSH
56772: LD_INT 0
56774: PUSH
56775: LD_INT 3
56777: NEG
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PUSH
56783: LD_INT 1
56785: PUSH
56786: LD_INT 2
56788: NEG
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PUSH
56794: EMPTY
56795: LIST
56796: LIST
56797: LIST
56798: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
56799: LD_ADDR_VAR 0 54
56803: PUSH
56804: LD_INT 2
56806: PUSH
56807: LD_INT 1
56809: NEG
56810: PUSH
56811: EMPTY
56812: LIST
56813: LIST
56814: PUSH
56815: LD_INT 3
56817: PUSH
56818: LD_INT 0
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: PUSH
56825: LD_INT 3
56827: PUSH
56828: LD_INT 1
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: LIST
56839: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
56840: LD_ADDR_VAR 0 55
56844: PUSH
56845: LD_INT 3
56847: PUSH
56848: LD_INT 2
56850: PUSH
56851: EMPTY
56852: LIST
56853: LIST
56854: PUSH
56855: LD_INT 3
56857: PUSH
56858: LD_INT 3
56860: PUSH
56861: EMPTY
56862: LIST
56863: LIST
56864: PUSH
56865: LD_INT 2
56867: PUSH
56868: LD_INT 3
56870: PUSH
56871: EMPTY
56872: LIST
56873: LIST
56874: PUSH
56875: EMPTY
56876: LIST
56877: LIST
56878: LIST
56879: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
56880: LD_ADDR_VAR 0 56
56884: PUSH
56885: LD_INT 1
56887: PUSH
56888: LD_INT 3
56890: PUSH
56891: EMPTY
56892: LIST
56893: LIST
56894: PUSH
56895: LD_INT 0
56897: PUSH
56898: LD_INT 3
56900: PUSH
56901: EMPTY
56902: LIST
56903: LIST
56904: PUSH
56905: LD_INT 1
56907: NEG
56908: PUSH
56909: LD_INT 2
56911: PUSH
56912: EMPTY
56913: LIST
56914: LIST
56915: PUSH
56916: EMPTY
56917: LIST
56918: LIST
56919: LIST
56920: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
56921: LD_ADDR_VAR 0 57
56925: PUSH
56926: LD_INT 2
56928: NEG
56929: PUSH
56930: LD_INT 1
56932: PUSH
56933: EMPTY
56934: LIST
56935: LIST
56936: PUSH
56937: LD_INT 3
56939: NEG
56940: PUSH
56941: LD_INT 0
56943: PUSH
56944: EMPTY
56945: LIST
56946: LIST
56947: PUSH
56948: LD_INT 3
56950: NEG
56951: PUSH
56952: LD_INT 1
56954: NEG
56955: PUSH
56956: EMPTY
56957: LIST
56958: LIST
56959: PUSH
56960: EMPTY
56961: LIST
56962: LIST
56963: LIST
56964: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
56965: LD_ADDR_VAR 0 58
56969: PUSH
56970: LD_INT 2
56972: NEG
56973: PUSH
56974: LD_INT 3
56976: NEG
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: PUSH
56982: LD_INT 3
56984: NEG
56985: PUSH
56986: LD_INT 2
56988: NEG
56989: PUSH
56990: EMPTY
56991: LIST
56992: LIST
56993: PUSH
56994: LD_INT 3
56996: NEG
56997: PUSH
56998: LD_INT 3
57000: NEG
57001: PUSH
57002: EMPTY
57003: LIST
57004: LIST
57005: PUSH
57006: EMPTY
57007: LIST
57008: LIST
57009: LIST
57010: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
57011: LD_ADDR_VAR 0 59
57015: PUSH
57016: LD_INT 1
57018: NEG
57019: PUSH
57020: LD_INT 2
57022: NEG
57023: PUSH
57024: EMPTY
57025: LIST
57026: LIST
57027: PUSH
57028: LD_INT 0
57030: PUSH
57031: LD_INT 2
57033: NEG
57034: PUSH
57035: EMPTY
57036: LIST
57037: LIST
57038: PUSH
57039: LD_INT 1
57041: PUSH
57042: LD_INT 1
57044: NEG
57045: PUSH
57046: EMPTY
57047: LIST
57048: LIST
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: LIST
57054: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
57055: LD_ADDR_VAR 0 60
57059: PUSH
57060: LD_INT 1
57062: PUSH
57063: LD_INT 1
57065: NEG
57066: PUSH
57067: EMPTY
57068: LIST
57069: LIST
57070: PUSH
57071: LD_INT 2
57073: PUSH
57074: LD_INT 0
57076: PUSH
57077: EMPTY
57078: LIST
57079: LIST
57080: PUSH
57081: LD_INT 2
57083: PUSH
57084: LD_INT 1
57086: PUSH
57087: EMPTY
57088: LIST
57089: LIST
57090: PUSH
57091: EMPTY
57092: LIST
57093: LIST
57094: LIST
57095: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
57096: LD_ADDR_VAR 0 61
57100: PUSH
57101: LD_INT 2
57103: PUSH
57104: LD_INT 1
57106: PUSH
57107: EMPTY
57108: LIST
57109: LIST
57110: PUSH
57111: LD_INT 2
57113: PUSH
57114: LD_INT 2
57116: PUSH
57117: EMPTY
57118: LIST
57119: LIST
57120: PUSH
57121: LD_INT 1
57123: PUSH
57124: LD_INT 2
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PUSH
57131: EMPTY
57132: LIST
57133: LIST
57134: LIST
57135: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
57136: LD_ADDR_VAR 0 62
57140: PUSH
57141: LD_INT 1
57143: PUSH
57144: LD_INT 2
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: PUSH
57151: LD_INT 0
57153: PUSH
57154: LD_INT 2
57156: PUSH
57157: EMPTY
57158: LIST
57159: LIST
57160: PUSH
57161: LD_INT 1
57163: NEG
57164: PUSH
57165: LD_INT 1
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: PUSH
57172: EMPTY
57173: LIST
57174: LIST
57175: LIST
57176: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
57177: LD_ADDR_VAR 0 63
57181: PUSH
57182: LD_INT 1
57184: NEG
57185: PUSH
57186: LD_INT 1
57188: PUSH
57189: EMPTY
57190: LIST
57191: LIST
57192: PUSH
57193: LD_INT 2
57195: NEG
57196: PUSH
57197: LD_INT 0
57199: PUSH
57200: EMPTY
57201: LIST
57202: LIST
57203: PUSH
57204: LD_INT 2
57206: NEG
57207: PUSH
57208: LD_INT 1
57210: NEG
57211: PUSH
57212: EMPTY
57213: LIST
57214: LIST
57215: PUSH
57216: EMPTY
57217: LIST
57218: LIST
57219: LIST
57220: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
57221: LD_ADDR_VAR 0 64
57225: PUSH
57226: LD_INT 1
57228: NEG
57229: PUSH
57230: LD_INT 2
57232: NEG
57233: PUSH
57234: EMPTY
57235: LIST
57236: LIST
57237: PUSH
57238: LD_INT 2
57240: NEG
57241: PUSH
57242: LD_INT 1
57244: NEG
57245: PUSH
57246: EMPTY
57247: LIST
57248: LIST
57249: PUSH
57250: LD_INT 2
57252: NEG
57253: PUSH
57254: LD_INT 2
57256: NEG
57257: PUSH
57258: EMPTY
57259: LIST
57260: LIST
57261: PUSH
57262: EMPTY
57263: LIST
57264: LIST
57265: LIST
57266: ST_TO_ADDR
// end ; 2 :
57267: GO 60533
57269: LD_INT 2
57271: DOUBLE
57272: EQUAL
57273: IFTRUE 57277
57275: GO 60532
57277: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
57278: LD_ADDR_VAR 0 29
57282: PUSH
57283: LD_INT 4
57285: PUSH
57286: LD_INT 0
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PUSH
57293: LD_INT 4
57295: PUSH
57296: LD_INT 1
57298: NEG
57299: PUSH
57300: EMPTY
57301: LIST
57302: LIST
57303: PUSH
57304: LD_INT 5
57306: PUSH
57307: LD_INT 0
57309: PUSH
57310: EMPTY
57311: LIST
57312: LIST
57313: PUSH
57314: LD_INT 5
57316: PUSH
57317: LD_INT 1
57319: PUSH
57320: EMPTY
57321: LIST
57322: LIST
57323: PUSH
57324: LD_INT 4
57326: PUSH
57327: LD_INT 1
57329: PUSH
57330: EMPTY
57331: LIST
57332: LIST
57333: PUSH
57334: LD_INT 3
57336: PUSH
57337: LD_INT 0
57339: PUSH
57340: EMPTY
57341: LIST
57342: LIST
57343: PUSH
57344: LD_INT 3
57346: PUSH
57347: LD_INT 1
57349: NEG
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: PUSH
57355: LD_INT 3
57357: PUSH
57358: LD_INT 2
57360: NEG
57361: PUSH
57362: EMPTY
57363: LIST
57364: LIST
57365: PUSH
57366: LD_INT 5
57368: PUSH
57369: LD_INT 2
57371: PUSH
57372: EMPTY
57373: LIST
57374: LIST
57375: PUSH
57376: LD_INT 3
57378: PUSH
57379: LD_INT 3
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: LD_INT 3
57388: PUSH
57389: LD_INT 2
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PUSH
57396: LD_INT 4
57398: PUSH
57399: LD_INT 3
57401: PUSH
57402: EMPTY
57403: LIST
57404: LIST
57405: PUSH
57406: LD_INT 4
57408: PUSH
57409: LD_INT 4
57411: PUSH
57412: EMPTY
57413: LIST
57414: LIST
57415: PUSH
57416: LD_INT 3
57418: PUSH
57419: LD_INT 4
57421: PUSH
57422: EMPTY
57423: LIST
57424: LIST
57425: PUSH
57426: LD_INT 2
57428: PUSH
57429: LD_INT 3
57431: PUSH
57432: EMPTY
57433: LIST
57434: LIST
57435: PUSH
57436: LD_INT 2
57438: PUSH
57439: LD_INT 2
57441: PUSH
57442: EMPTY
57443: LIST
57444: LIST
57445: PUSH
57446: LD_INT 4
57448: PUSH
57449: LD_INT 2
57451: PUSH
57452: EMPTY
57453: LIST
57454: LIST
57455: PUSH
57456: LD_INT 2
57458: PUSH
57459: LD_INT 4
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: PUSH
57466: LD_INT 0
57468: PUSH
57469: LD_INT 4
57471: PUSH
57472: EMPTY
57473: LIST
57474: LIST
57475: PUSH
57476: LD_INT 0
57478: PUSH
57479: LD_INT 3
57481: PUSH
57482: EMPTY
57483: LIST
57484: LIST
57485: PUSH
57486: LD_INT 1
57488: PUSH
57489: LD_INT 4
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: PUSH
57496: LD_INT 1
57498: PUSH
57499: LD_INT 5
57501: PUSH
57502: EMPTY
57503: LIST
57504: LIST
57505: PUSH
57506: LD_INT 0
57508: PUSH
57509: LD_INT 5
57511: PUSH
57512: EMPTY
57513: LIST
57514: LIST
57515: PUSH
57516: LD_INT 1
57518: NEG
57519: PUSH
57520: LD_INT 4
57522: PUSH
57523: EMPTY
57524: LIST
57525: LIST
57526: PUSH
57527: LD_INT 1
57529: NEG
57530: PUSH
57531: LD_INT 3
57533: PUSH
57534: EMPTY
57535: LIST
57536: LIST
57537: PUSH
57538: LD_INT 2
57540: PUSH
57541: LD_INT 5
57543: PUSH
57544: EMPTY
57545: LIST
57546: LIST
57547: PUSH
57548: LD_INT 2
57550: NEG
57551: PUSH
57552: LD_INT 3
57554: PUSH
57555: EMPTY
57556: LIST
57557: LIST
57558: PUSH
57559: LD_INT 3
57561: NEG
57562: PUSH
57563: LD_INT 0
57565: PUSH
57566: EMPTY
57567: LIST
57568: LIST
57569: PUSH
57570: LD_INT 3
57572: NEG
57573: PUSH
57574: LD_INT 1
57576: NEG
57577: PUSH
57578: EMPTY
57579: LIST
57580: LIST
57581: PUSH
57582: LD_INT 2
57584: NEG
57585: PUSH
57586: LD_INT 0
57588: PUSH
57589: EMPTY
57590: LIST
57591: LIST
57592: PUSH
57593: LD_INT 2
57595: NEG
57596: PUSH
57597: LD_INT 1
57599: PUSH
57600: EMPTY
57601: LIST
57602: LIST
57603: PUSH
57604: LD_INT 3
57606: NEG
57607: PUSH
57608: LD_INT 1
57610: PUSH
57611: EMPTY
57612: LIST
57613: LIST
57614: PUSH
57615: LD_INT 4
57617: NEG
57618: PUSH
57619: LD_INT 0
57621: PUSH
57622: EMPTY
57623: LIST
57624: LIST
57625: PUSH
57626: LD_INT 4
57628: NEG
57629: PUSH
57630: LD_INT 1
57632: NEG
57633: PUSH
57634: EMPTY
57635: LIST
57636: LIST
57637: PUSH
57638: LD_INT 4
57640: NEG
57641: PUSH
57642: LD_INT 2
57644: NEG
57645: PUSH
57646: EMPTY
57647: LIST
57648: LIST
57649: PUSH
57650: LD_INT 2
57652: NEG
57653: PUSH
57654: LD_INT 2
57656: PUSH
57657: EMPTY
57658: LIST
57659: LIST
57660: PUSH
57661: LD_INT 4
57663: NEG
57664: PUSH
57665: LD_INT 4
57667: NEG
57668: PUSH
57669: EMPTY
57670: LIST
57671: LIST
57672: PUSH
57673: LD_INT 4
57675: NEG
57676: PUSH
57677: LD_INT 5
57679: NEG
57680: PUSH
57681: EMPTY
57682: LIST
57683: LIST
57684: PUSH
57685: LD_INT 3
57687: NEG
57688: PUSH
57689: LD_INT 4
57691: NEG
57692: PUSH
57693: EMPTY
57694: LIST
57695: LIST
57696: PUSH
57697: LD_INT 3
57699: NEG
57700: PUSH
57701: LD_INT 3
57703: NEG
57704: PUSH
57705: EMPTY
57706: LIST
57707: LIST
57708: PUSH
57709: LD_INT 4
57711: NEG
57712: PUSH
57713: LD_INT 3
57715: NEG
57716: PUSH
57717: EMPTY
57718: LIST
57719: LIST
57720: PUSH
57721: LD_INT 5
57723: NEG
57724: PUSH
57725: LD_INT 4
57727: NEG
57728: PUSH
57729: EMPTY
57730: LIST
57731: LIST
57732: PUSH
57733: LD_INT 5
57735: NEG
57736: PUSH
57737: LD_INT 5
57739: NEG
57740: PUSH
57741: EMPTY
57742: LIST
57743: LIST
57744: PUSH
57745: LD_INT 3
57747: NEG
57748: PUSH
57749: LD_INT 5
57751: NEG
57752: PUSH
57753: EMPTY
57754: LIST
57755: LIST
57756: PUSH
57757: LD_INT 5
57759: NEG
57760: PUSH
57761: LD_INT 3
57763: NEG
57764: PUSH
57765: EMPTY
57766: LIST
57767: LIST
57768: PUSH
57769: EMPTY
57770: LIST
57771: LIST
57772: LIST
57773: LIST
57774: LIST
57775: LIST
57776: LIST
57777: LIST
57778: LIST
57779: LIST
57780: LIST
57781: LIST
57782: LIST
57783: LIST
57784: LIST
57785: LIST
57786: LIST
57787: LIST
57788: LIST
57789: LIST
57790: LIST
57791: LIST
57792: LIST
57793: LIST
57794: LIST
57795: LIST
57796: LIST
57797: LIST
57798: LIST
57799: LIST
57800: LIST
57801: LIST
57802: LIST
57803: LIST
57804: LIST
57805: LIST
57806: LIST
57807: LIST
57808: LIST
57809: LIST
57810: LIST
57811: LIST
57812: LIST
57813: LIST
57814: LIST
57815: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
57816: LD_ADDR_VAR 0 30
57820: PUSH
57821: LD_INT 4
57823: PUSH
57824: LD_INT 4
57826: PUSH
57827: EMPTY
57828: LIST
57829: LIST
57830: PUSH
57831: LD_INT 4
57833: PUSH
57834: LD_INT 3
57836: PUSH
57837: EMPTY
57838: LIST
57839: LIST
57840: PUSH
57841: LD_INT 5
57843: PUSH
57844: LD_INT 4
57846: PUSH
57847: EMPTY
57848: LIST
57849: LIST
57850: PUSH
57851: LD_INT 5
57853: PUSH
57854: LD_INT 5
57856: PUSH
57857: EMPTY
57858: LIST
57859: LIST
57860: PUSH
57861: LD_INT 4
57863: PUSH
57864: LD_INT 5
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PUSH
57871: LD_INT 3
57873: PUSH
57874: LD_INT 4
57876: PUSH
57877: EMPTY
57878: LIST
57879: LIST
57880: PUSH
57881: LD_INT 3
57883: PUSH
57884: LD_INT 3
57886: PUSH
57887: EMPTY
57888: LIST
57889: LIST
57890: PUSH
57891: LD_INT 5
57893: PUSH
57894: LD_INT 3
57896: PUSH
57897: EMPTY
57898: LIST
57899: LIST
57900: PUSH
57901: LD_INT 3
57903: PUSH
57904: LD_INT 5
57906: PUSH
57907: EMPTY
57908: LIST
57909: LIST
57910: PUSH
57911: LD_INT 0
57913: PUSH
57914: LD_INT 3
57916: PUSH
57917: EMPTY
57918: LIST
57919: LIST
57920: PUSH
57921: LD_INT 0
57923: PUSH
57924: LD_INT 2
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: PUSH
57931: LD_INT 1
57933: PUSH
57934: LD_INT 3
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: PUSH
57941: LD_INT 1
57943: PUSH
57944: LD_INT 4
57946: PUSH
57947: EMPTY
57948: LIST
57949: LIST
57950: PUSH
57951: LD_INT 0
57953: PUSH
57954: LD_INT 4
57956: PUSH
57957: EMPTY
57958: LIST
57959: LIST
57960: PUSH
57961: LD_INT 1
57963: NEG
57964: PUSH
57965: LD_INT 3
57967: PUSH
57968: EMPTY
57969: LIST
57970: LIST
57971: PUSH
57972: LD_INT 1
57974: NEG
57975: PUSH
57976: LD_INT 2
57978: PUSH
57979: EMPTY
57980: LIST
57981: LIST
57982: PUSH
57983: LD_INT 2
57985: PUSH
57986: LD_INT 4
57988: PUSH
57989: EMPTY
57990: LIST
57991: LIST
57992: PUSH
57993: LD_INT 2
57995: NEG
57996: PUSH
57997: LD_INT 2
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: PUSH
58004: LD_INT 4
58006: NEG
58007: PUSH
58008: LD_INT 0
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: LD_INT 4
58017: NEG
58018: PUSH
58019: LD_INT 1
58021: NEG
58022: PUSH
58023: EMPTY
58024: LIST
58025: LIST
58026: PUSH
58027: LD_INT 3
58029: NEG
58030: PUSH
58031: LD_INT 0
58033: PUSH
58034: EMPTY
58035: LIST
58036: LIST
58037: PUSH
58038: LD_INT 3
58040: NEG
58041: PUSH
58042: LD_INT 1
58044: PUSH
58045: EMPTY
58046: LIST
58047: LIST
58048: PUSH
58049: LD_INT 4
58051: NEG
58052: PUSH
58053: LD_INT 1
58055: PUSH
58056: EMPTY
58057: LIST
58058: LIST
58059: PUSH
58060: LD_INT 5
58062: NEG
58063: PUSH
58064: LD_INT 0
58066: PUSH
58067: EMPTY
58068: LIST
58069: LIST
58070: PUSH
58071: LD_INT 5
58073: NEG
58074: PUSH
58075: LD_INT 1
58077: NEG
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: PUSH
58083: LD_INT 5
58085: NEG
58086: PUSH
58087: LD_INT 2
58089: NEG
58090: PUSH
58091: EMPTY
58092: LIST
58093: LIST
58094: PUSH
58095: LD_INT 3
58097: NEG
58098: PUSH
58099: LD_INT 2
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PUSH
58106: LD_INT 3
58108: NEG
58109: PUSH
58110: LD_INT 3
58112: NEG
58113: PUSH
58114: EMPTY
58115: LIST
58116: LIST
58117: PUSH
58118: LD_INT 3
58120: NEG
58121: PUSH
58122: LD_INT 4
58124: NEG
58125: PUSH
58126: EMPTY
58127: LIST
58128: LIST
58129: PUSH
58130: LD_INT 2
58132: NEG
58133: PUSH
58134: LD_INT 3
58136: NEG
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: PUSH
58142: LD_INT 2
58144: NEG
58145: PUSH
58146: LD_INT 2
58148: NEG
58149: PUSH
58150: EMPTY
58151: LIST
58152: LIST
58153: PUSH
58154: LD_INT 3
58156: NEG
58157: PUSH
58158: LD_INT 2
58160: NEG
58161: PUSH
58162: EMPTY
58163: LIST
58164: LIST
58165: PUSH
58166: LD_INT 4
58168: NEG
58169: PUSH
58170: LD_INT 3
58172: NEG
58173: PUSH
58174: EMPTY
58175: LIST
58176: LIST
58177: PUSH
58178: LD_INT 4
58180: NEG
58181: PUSH
58182: LD_INT 4
58184: NEG
58185: PUSH
58186: EMPTY
58187: LIST
58188: LIST
58189: PUSH
58190: LD_INT 2
58192: NEG
58193: PUSH
58194: LD_INT 4
58196: NEG
58197: PUSH
58198: EMPTY
58199: LIST
58200: LIST
58201: PUSH
58202: LD_INT 4
58204: NEG
58205: PUSH
58206: LD_INT 2
58208: NEG
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: PUSH
58214: LD_INT 0
58216: PUSH
58217: LD_INT 4
58219: NEG
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PUSH
58225: LD_INT 0
58227: PUSH
58228: LD_INT 5
58230: NEG
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: PUSH
58236: LD_INT 1
58238: PUSH
58239: LD_INT 4
58241: NEG
58242: PUSH
58243: EMPTY
58244: LIST
58245: LIST
58246: PUSH
58247: LD_INT 1
58249: PUSH
58250: LD_INT 3
58252: NEG
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: PUSH
58258: LD_INT 0
58260: PUSH
58261: LD_INT 3
58263: NEG
58264: PUSH
58265: EMPTY
58266: LIST
58267: LIST
58268: PUSH
58269: LD_INT 1
58271: NEG
58272: PUSH
58273: LD_INT 4
58275: NEG
58276: PUSH
58277: EMPTY
58278: LIST
58279: LIST
58280: PUSH
58281: LD_INT 1
58283: NEG
58284: PUSH
58285: LD_INT 5
58287: NEG
58288: PUSH
58289: EMPTY
58290: LIST
58291: LIST
58292: PUSH
58293: LD_INT 2
58295: PUSH
58296: LD_INT 3
58298: NEG
58299: PUSH
58300: EMPTY
58301: LIST
58302: LIST
58303: PUSH
58304: LD_INT 2
58306: NEG
58307: PUSH
58308: LD_INT 5
58310: NEG
58311: PUSH
58312: EMPTY
58313: LIST
58314: LIST
58315: PUSH
58316: EMPTY
58317: LIST
58318: LIST
58319: LIST
58320: LIST
58321: LIST
58322: LIST
58323: LIST
58324: LIST
58325: LIST
58326: LIST
58327: LIST
58328: LIST
58329: LIST
58330: LIST
58331: LIST
58332: LIST
58333: LIST
58334: LIST
58335: LIST
58336: LIST
58337: LIST
58338: LIST
58339: LIST
58340: LIST
58341: LIST
58342: LIST
58343: LIST
58344: LIST
58345: LIST
58346: LIST
58347: LIST
58348: LIST
58349: LIST
58350: LIST
58351: LIST
58352: LIST
58353: LIST
58354: LIST
58355: LIST
58356: LIST
58357: LIST
58358: LIST
58359: LIST
58360: LIST
58361: LIST
58362: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
58363: LD_ADDR_VAR 0 31
58367: PUSH
58368: LD_INT 0
58370: PUSH
58371: LD_INT 4
58373: PUSH
58374: EMPTY
58375: LIST
58376: LIST
58377: PUSH
58378: LD_INT 0
58380: PUSH
58381: LD_INT 3
58383: PUSH
58384: EMPTY
58385: LIST
58386: LIST
58387: PUSH
58388: LD_INT 1
58390: PUSH
58391: LD_INT 4
58393: PUSH
58394: EMPTY
58395: LIST
58396: LIST
58397: PUSH
58398: LD_INT 1
58400: PUSH
58401: LD_INT 5
58403: PUSH
58404: EMPTY
58405: LIST
58406: LIST
58407: PUSH
58408: LD_INT 0
58410: PUSH
58411: LD_INT 5
58413: PUSH
58414: EMPTY
58415: LIST
58416: LIST
58417: PUSH
58418: LD_INT 1
58420: NEG
58421: PUSH
58422: LD_INT 4
58424: PUSH
58425: EMPTY
58426: LIST
58427: LIST
58428: PUSH
58429: LD_INT 1
58431: NEG
58432: PUSH
58433: LD_INT 3
58435: PUSH
58436: EMPTY
58437: LIST
58438: LIST
58439: PUSH
58440: LD_INT 2
58442: PUSH
58443: LD_INT 5
58445: PUSH
58446: EMPTY
58447: LIST
58448: LIST
58449: PUSH
58450: LD_INT 2
58452: NEG
58453: PUSH
58454: LD_INT 3
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: PUSH
58461: LD_INT 3
58463: NEG
58464: PUSH
58465: LD_INT 0
58467: PUSH
58468: EMPTY
58469: LIST
58470: LIST
58471: PUSH
58472: LD_INT 3
58474: NEG
58475: PUSH
58476: LD_INT 1
58478: NEG
58479: PUSH
58480: EMPTY
58481: LIST
58482: LIST
58483: PUSH
58484: LD_INT 2
58486: NEG
58487: PUSH
58488: LD_INT 0
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: PUSH
58495: LD_INT 2
58497: NEG
58498: PUSH
58499: LD_INT 1
58501: PUSH
58502: EMPTY
58503: LIST
58504: LIST
58505: PUSH
58506: LD_INT 3
58508: NEG
58509: PUSH
58510: LD_INT 1
58512: PUSH
58513: EMPTY
58514: LIST
58515: LIST
58516: PUSH
58517: LD_INT 4
58519: NEG
58520: PUSH
58521: LD_INT 0
58523: PUSH
58524: EMPTY
58525: LIST
58526: LIST
58527: PUSH
58528: LD_INT 4
58530: NEG
58531: PUSH
58532: LD_INT 1
58534: NEG
58535: PUSH
58536: EMPTY
58537: LIST
58538: LIST
58539: PUSH
58540: LD_INT 4
58542: NEG
58543: PUSH
58544: LD_INT 2
58546: NEG
58547: PUSH
58548: EMPTY
58549: LIST
58550: LIST
58551: PUSH
58552: LD_INT 2
58554: NEG
58555: PUSH
58556: LD_INT 2
58558: PUSH
58559: EMPTY
58560: LIST
58561: LIST
58562: PUSH
58563: LD_INT 4
58565: NEG
58566: PUSH
58567: LD_INT 4
58569: NEG
58570: PUSH
58571: EMPTY
58572: LIST
58573: LIST
58574: PUSH
58575: LD_INT 4
58577: NEG
58578: PUSH
58579: LD_INT 5
58581: NEG
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: PUSH
58587: LD_INT 3
58589: NEG
58590: PUSH
58591: LD_INT 4
58593: NEG
58594: PUSH
58595: EMPTY
58596: LIST
58597: LIST
58598: PUSH
58599: LD_INT 3
58601: NEG
58602: PUSH
58603: LD_INT 3
58605: NEG
58606: PUSH
58607: EMPTY
58608: LIST
58609: LIST
58610: PUSH
58611: LD_INT 4
58613: NEG
58614: PUSH
58615: LD_INT 3
58617: NEG
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PUSH
58623: LD_INT 5
58625: NEG
58626: PUSH
58627: LD_INT 4
58629: NEG
58630: PUSH
58631: EMPTY
58632: LIST
58633: LIST
58634: PUSH
58635: LD_INT 5
58637: NEG
58638: PUSH
58639: LD_INT 5
58641: NEG
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: PUSH
58647: LD_INT 3
58649: NEG
58650: PUSH
58651: LD_INT 5
58653: NEG
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: PUSH
58659: LD_INT 5
58661: NEG
58662: PUSH
58663: LD_INT 3
58665: NEG
58666: PUSH
58667: EMPTY
58668: LIST
58669: LIST
58670: PUSH
58671: LD_INT 0
58673: PUSH
58674: LD_INT 3
58676: NEG
58677: PUSH
58678: EMPTY
58679: LIST
58680: LIST
58681: PUSH
58682: LD_INT 0
58684: PUSH
58685: LD_INT 4
58687: NEG
58688: PUSH
58689: EMPTY
58690: LIST
58691: LIST
58692: PUSH
58693: LD_INT 1
58695: PUSH
58696: LD_INT 3
58698: NEG
58699: PUSH
58700: EMPTY
58701: LIST
58702: LIST
58703: PUSH
58704: LD_INT 1
58706: PUSH
58707: LD_INT 2
58709: NEG
58710: PUSH
58711: EMPTY
58712: LIST
58713: LIST
58714: PUSH
58715: LD_INT 0
58717: PUSH
58718: LD_INT 2
58720: NEG
58721: PUSH
58722: EMPTY
58723: LIST
58724: LIST
58725: PUSH
58726: LD_INT 1
58728: NEG
58729: PUSH
58730: LD_INT 3
58732: NEG
58733: PUSH
58734: EMPTY
58735: LIST
58736: LIST
58737: PUSH
58738: LD_INT 1
58740: NEG
58741: PUSH
58742: LD_INT 4
58744: NEG
58745: PUSH
58746: EMPTY
58747: LIST
58748: LIST
58749: PUSH
58750: LD_INT 2
58752: PUSH
58753: LD_INT 2
58755: NEG
58756: PUSH
58757: EMPTY
58758: LIST
58759: LIST
58760: PUSH
58761: LD_INT 2
58763: NEG
58764: PUSH
58765: LD_INT 4
58767: NEG
58768: PUSH
58769: EMPTY
58770: LIST
58771: LIST
58772: PUSH
58773: LD_INT 4
58775: PUSH
58776: LD_INT 0
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: PUSH
58783: LD_INT 4
58785: PUSH
58786: LD_INT 1
58788: NEG
58789: PUSH
58790: EMPTY
58791: LIST
58792: LIST
58793: PUSH
58794: LD_INT 5
58796: PUSH
58797: LD_INT 0
58799: PUSH
58800: EMPTY
58801: LIST
58802: LIST
58803: PUSH
58804: LD_INT 5
58806: PUSH
58807: LD_INT 1
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: PUSH
58814: LD_INT 4
58816: PUSH
58817: LD_INT 1
58819: PUSH
58820: EMPTY
58821: LIST
58822: LIST
58823: PUSH
58824: LD_INT 3
58826: PUSH
58827: LD_INT 0
58829: PUSH
58830: EMPTY
58831: LIST
58832: LIST
58833: PUSH
58834: LD_INT 3
58836: PUSH
58837: LD_INT 1
58839: NEG
58840: PUSH
58841: EMPTY
58842: LIST
58843: LIST
58844: PUSH
58845: LD_INT 3
58847: PUSH
58848: LD_INT 2
58850: NEG
58851: PUSH
58852: EMPTY
58853: LIST
58854: LIST
58855: PUSH
58856: LD_INT 5
58858: PUSH
58859: LD_INT 2
58861: PUSH
58862: EMPTY
58863: LIST
58864: LIST
58865: PUSH
58866: EMPTY
58867: LIST
58868: LIST
58869: LIST
58870: LIST
58871: LIST
58872: LIST
58873: LIST
58874: LIST
58875: LIST
58876: LIST
58877: LIST
58878: LIST
58879: LIST
58880: LIST
58881: LIST
58882: LIST
58883: LIST
58884: LIST
58885: LIST
58886: LIST
58887: LIST
58888: LIST
58889: LIST
58890: LIST
58891: LIST
58892: LIST
58893: LIST
58894: LIST
58895: LIST
58896: LIST
58897: LIST
58898: LIST
58899: LIST
58900: LIST
58901: LIST
58902: LIST
58903: LIST
58904: LIST
58905: LIST
58906: LIST
58907: LIST
58908: LIST
58909: LIST
58910: LIST
58911: LIST
58912: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
58913: LD_ADDR_VAR 0 32
58917: PUSH
58918: LD_INT 4
58920: NEG
58921: PUSH
58922: LD_INT 0
58924: PUSH
58925: EMPTY
58926: LIST
58927: LIST
58928: PUSH
58929: LD_INT 4
58931: NEG
58932: PUSH
58933: LD_INT 1
58935: NEG
58936: PUSH
58937: EMPTY
58938: LIST
58939: LIST
58940: PUSH
58941: LD_INT 3
58943: NEG
58944: PUSH
58945: LD_INT 0
58947: PUSH
58948: EMPTY
58949: LIST
58950: LIST
58951: PUSH
58952: LD_INT 3
58954: NEG
58955: PUSH
58956: LD_INT 1
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: PUSH
58963: LD_INT 4
58965: NEG
58966: PUSH
58967: LD_INT 1
58969: PUSH
58970: EMPTY
58971: LIST
58972: LIST
58973: PUSH
58974: LD_INT 5
58976: NEG
58977: PUSH
58978: LD_INT 0
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: PUSH
58985: LD_INT 5
58987: NEG
58988: PUSH
58989: LD_INT 1
58991: NEG
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: LD_INT 5
58999: NEG
59000: PUSH
59001: LD_INT 2
59003: NEG
59004: PUSH
59005: EMPTY
59006: LIST
59007: LIST
59008: PUSH
59009: LD_INT 3
59011: NEG
59012: PUSH
59013: LD_INT 2
59015: PUSH
59016: EMPTY
59017: LIST
59018: LIST
59019: PUSH
59020: LD_INT 3
59022: NEG
59023: PUSH
59024: LD_INT 3
59026: NEG
59027: PUSH
59028: EMPTY
59029: LIST
59030: LIST
59031: PUSH
59032: LD_INT 3
59034: NEG
59035: PUSH
59036: LD_INT 4
59038: NEG
59039: PUSH
59040: EMPTY
59041: LIST
59042: LIST
59043: PUSH
59044: LD_INT 2
59046: NEG
59047: PUSH
59048: LD_INT 3
59050: NEG
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: PUSH
59056: LD_INT 2
59058: NEG
59059: PUSH
59060: LD_INT 2
59062: NEG
59063: PUSH
59064: EMPTY
59065: LIST
59066: LIST
59067: PUSH
59068: LD_INT 3
59070: NEG
59071: PUSH
59072: LD_INT 2
59074: NEG
59075: PUSH
59076: EMPTY
59077: LIST
59078: LIST
59079: PUSH
59080: LD_INT 4
59082: NEG
59083: PUSH
59084: LD_INT 3
59086: NEG
59087: PUSH
59088: EMPTY
59089: LIST
59090: LIST
59091: PUSH
59092: LD_INT 4
59094: NEG
59095: PUSH
59096: LD_INT 4
59098: NEG
59099: PUSH
59100: EMPTY
59101: LIST
59102: LIST
59103: PUSH
59104: LD_INT 2
59106: NEG
59107: PUSH
59108: LD_INT 4
59110: NEG
59111: PUSH
59112: EMPTY
59113: LIST
59114: LIST
59115: PUSH
59116: LD_INT 4
59118: NEG
59119: PUSH
59120: LD_INT 2
59122: NEG
59123: PUSH
59124: EMPTY
59125: LIST
59126: LIST
59127: PUSH
59128: LD_INT 0
59130: PUSH
59131: LD_INT 4
59133: NEG
59134: PUSH
59135: EMPTY
59136: LIST
59137: LIST
59138: PUSH
59139: LD_INT 0
59141: PUSH
59142: LD_INT 5
59144: NEG
59145: PUSH
59146: EMPTY
59147: LIST
59148: LIST
59149: PUSH
59150: LD_INT 1
59152: PUSH
59153: LD_INT 4
59155: NEG
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: PUSH
59161: LD_INT 1
59163: PUSH
59164: LD_INT 3
59166: NEG
59167: PUSH
59168: EMPTY
59169: LIST
59170: LIST
59171: PUSH
59172: LD_INT 0
59174: PUSH
59175: LD_INT 3
59177: NEG
59178: PUSH
59179: EMPTY
59180: LIST
59181: LIST
59182: PUSH
59183: LD_INT 1
59185: NEG
59186: PUSH
59187: LD_INT 4
59189: NEG
59190: PUSH
59191: EMPTY
59192: LIST
59193: LIST
59194: PUSH
59195: LD_INT 1
59197: NEG
59198: PUSH
59199: LD_INT 5
59201: NEG
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: PUSH
59207: LD_INT 2
59209: PUSH
59210: LD_INT 3
59212: NEG
59213: PUSH
59214: EMPTY
59215: LIST
59216: LIST
59217: PUSH
59218: LD_INT 2
59220: NEG
59221: PUSH
59222: LD_INT 5
59224: NEG
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PUSH
59230: LD_INT 3
59232: PUSH
59233: LD_INT 0
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PUSH
59240: LD_INT 3
59242: PUSH
59243: LD_INT 1
59245: NEG
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: PUSH
59251: LD_INT 4
59253: PUSH
59254: LD_INT 0
59256: PUSH
59257: EMPTY
59258: LIST
59259: LIST
59260: PUSH
59261: LD_INT 4
59263: PUSH
59264: LD_INT 1
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: PUSH
59271: LD_INT 3
59273: PUSH
59274: LD_INT 1
59276: PUSH
59277: EMPTY
59278: LIST
59279: LIST
59280: PUSH
59281: LD_INT 2
59283: PUSH
59284: LD_INT 0
59286: PUSH
59287: EMPTY
59288: LIST
59289: LIST
59290: PUSH
59291: LD_INT 2
59293: PUSH
59294: LD_INT 1
59296: NEG
59297: PUSH
59298: EMPTY
59299: LIST
59300: LIST
59301: PUSH
59302: LD_INT 2
59304: PUSH
59305: LD_INT 2
59307: NEG
59308: PUSH
59309: EMPTY
59310: LIST
59311: LIST
59312: PUSH
59313: LD_INT 4
59315: PUSH
59316: LD_INT 2
59318: PUSH
59319: EMPTY
59320: LIST
59321: LIST
59322: PUSH
59323: LD_INT 4
59325: PUSH
59326: LD_INT 4
59328: PUSH
59329: EMPTY
59330: LIST
59331: LIST
59332: PUSH
59333: LD_INT 4
59335: PUSH
59336: LD_INT 3
59338: PUSH
59339: EMPTY
59340: LIST
59341: LIST
59342: PUSH
59343: LD_INT 5
59345: PUSH
59346: LD_INT 4
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: PUSH
59353: LD_INT 5
59355: PUSH
59356: LD_INT 5
59358: PUSH
59359: EMPTY
59360: LIST
59361: LIST
59362: PUSH
59363: LD_INT 4
59365: PUSH
59366: LD_INT 5
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PUSH
59373: LD_INT 3
59375: PUSH
59376: LD_INT 4
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PUSH
59383: LD_INT 3
59385: PUSH
59386: LD_INT 3
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: PUSH
59393: LD_INT 5
59395: PUSH
59396: LD_INT 3
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: PUSH
59403: LD_INT 3
59405: PUSH
59406: LD_INT 5
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: LIST
59418: LIST
59419: LIST
59420: LIST
59421: LIST
59422: LIST
59423: LIST
59424: LIST
59425: LIST
59426: LIST
59427: LIST
59428: LIST
59429: LIST
59430: LIST
59431: LIST
59432: LIST
59433: LIST
59434: LIST
59435: LIST
59436: LIST
59437: LIST
59438: LIST
59439: LIST
59440: LIST
59441: LIST
59442: LIST
59443: LIST
59444: LIST
59445: LIST
59446: LIST
59447: LIST
59448: LIST
59449: LIST
59450: LIST
59451: LIST
59452: LIST
59453: LIST
59454: LIST
59455: LIST
59456: LIST
59457: LIST
59458: LIST
59459: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
59460: LD_ADDR_VAR 0 33
59464: PUSH
59465: LD_INT 4
59467: NEG
59468: PUSH
59469: LD_INT 4
59471: NEG
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: PUSH
59477: LD_INT 4
59479: NEG
59480: PUSH
59481: LD_INT 5
59483: NEG
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: PUSH
59489: LD_INT 3
59491: NEG
59492: PUSH
59493: LD_INT 4
59495: NEG
59496: PUSH
59497: EMPTY
59498: LIST
59499: LIST
59500: PUSH
59501: LD_INT 3
59503: NEG
59504: PUSH
59505: LD_INT 3
59507: NEG
59508: PUSH
59509: EMPTY
59510: LIST
59511: LIST
59512: PUSH
59513: LD_INT 4
59515: NEG
59516: PUSH
59517: LD_INT 3
59519: NEG
59520: PUSH
59521: EMPTY
59522: LIST
59523: LIST
59524: PUSH
59525: LD_INT 5
59527: NEG
59528: PUSH
59529: LD_INT 4
59531: NEG
59532: PUSH
59533: EMPTY
59534: LIST
59535: LIST
59536: PUSH
59537: LD_INT 5
59539: NEG
59540: PUSH
59541: LD_INT 5
59543: NEG
59544: PUSH
59545: EMPTY
59546: LIST
59547: LIST
59548: PUSH
59549: LD_INT 3
59551: NEG
59552: PUSH
59553: LD_INT 5
59555: NEG
59556: PUSH
59557: EMPTY
59558: LIST
59559: LIST
59560: PUSH
59561: LD_INT 5
59563: NEG
59564: PUSH
59565: LD_INT 3
59567: NEG
59568: PUSH
59569: EMPTY
59570: LIST
59571: LIST
59572: PUSH
59573: LD_INT 0
59575: PUSH
59576: LD_INT 3
59578: NEG
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: PUSH
59584: LD_INT 0
59586: PUSH
59587: LD_INT 4
59589: NEG
59590: PUSH
59591: EMPTY
59592: LIST
59593: LIST
59594: PUSH
59595: LD_INT 1
59597: PUSH
59598: LD_INT 3
59600: NEG
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: PUSH
59606: LD_INT 1
59608: PUSH
59609: LD_INT 2
59611: NEG
59612: PUSH
59613: EMPTY
59614: LIST
59615: LIST
59616: PUSH
59617: LD_INT 0
59619: PUSH
59620: LD_INT 2
59622: NEG
59623: PUSH
59624: EMPTY
59625: LIST
59626: LIST
59627: PUSH
59628: LD_INT 1
59630: NEG
59631: PUSH
59632: LD_INT 3
59634: NEG
59635: PUSH
59636: EMPTY
59637: LIST
59638: LIST
59639: PUSH
59640: LD_INT 1
59642: NEG
59643: PUSH
59644: LD_INT 4
59646: NEG
59647: PUSH
59648: EMPTY
59649: LIST
59650: LIST
59651: PUSH
59652: LD_INT 2
59654: PUSH
59655: LD_INT 2
59657: NEG
59658: PUSH
59659: EMPTY
59660: LIST
59661: LIST
59662: PUSH
59663: LD_INT 2
59665: NEG
59666: PUSH
59667: LD_INT 4
59669: NEG
59670: PUSH
59671: EMPTY
59672: LIST
59673: LIST
59674: PUSH
59675: LD_INT 4
59677: PUSH
59678: LD_INT 0
59680: PUSH
59681: EMPTY
59682: LIST
59683: LIST
59684: PUSH
59685: LD_INT 4
59687: PUSH
59688: LD_INT 1
59690: NEG
59691: PUSH
59692: EMPTY
59693: LIST
59694: LIST
59695: PUSH
59696: LD_INT 5
59698: PUSH
59699: LD_INT 0
59701: PUSH
59702: EMPTY
59703: LIST
59704: LIST
59705: PUSH
59706: LD_INT 5
59708: PUSH
59709: LD_INT 1
59711: PUSH
59712: EMPTY
59713: LIST
59714: LIST
59715: PUSH
59716: LD_INT 4
59718: PUSH
59719: LD_INT 1
59721: PUSH
59722: EMPTY
59723: LIST
59724: LIST
59725: PUSH
59726: LD_INT 3
59728: PUSH
59729: LD_INT 0
59731: PUSH
59732: EMPTY
59733: LIST
59734: LIST
59735: PUSH
59736: LD_INT 3
59738: PUSH
59739: LD_INT 1
59741: NEG
59742: PUSH
59743: EMPTY
59744: LIST
59745: LIST
59746: PUSH
59747: LD_INT 3
59749: PUSH
59750: LD_INT 2
59752: NEG
59753: PUSH
59754: EMPTY
59755: LIST
59756: LIST
59757: PUSH
59758: LD_INT 5
59760: PUSH
59761: LD_INT 2
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: PUSH
59768: LD_INT 3
59770: PUSH
59771: LD_INT 3
59773: PUSH
59774: EMPTY
59775: LIST
59776: LIST
59777: PUSH
59778: LD_INT 3
59780: PUSH
59781: LD_INT 2
59783: PUSH
59784: EMPTY
59785: LIST
59786: LIST
59787: PUSH
59788: LD_INT 4
59790: PUSH
59791: LD_INT 3
59793: PUSH
59794: EMPTY
59795: LIST
59796: LIST
59797: PUSH
59798: LD_INT 4
59800: PUSH
59801: LD_INT 4
59803: PUSH
59804: EMPTY
59805: LIST
59806: LIST
59807: PUSH
59808: LD_INT 3
59810: PUSH
59811: LD_INT 4
59813: PUSH
59814: EMPTY
59815: LIST
59816: LIST
59817: PUSH
59818: LD_INT 2
59820: PUSH
59821: LD_INT 3
59823: PUSH
59824: EMPTY
59825: LIST
59826: LIST
59827: PUSH
59828: LD_INT 2
59830: PUSH
59831: LD_INT 2
59833: PUSH
59834: EMPTY
59835: LIST
59836: LIST
59837: PUSH
59838: LD_INT 4
59840: PUSH
59841: LD_INT 2
59843: PUSH
59844: EMPTY
59845: LIST
59846: LIST
59847: PUSH
59848: LD_INT 2
59850: PUSH
59851: LD_INT 4
59853: PUSH
59854: EMPTY
59855: LIST
59856: LIST
59857: PUSH
59858: LD_INT 0
59860: PUSH
59861: LD_INT 4
59863: PUSH
59864: EMPTY
59865: LIST
59866: LIST
59867: PUSH
59868: LD_INT 0
59870: PUSH
59871: LD_INT 3
59873: PUSH
59874: EMPTY
59875: LIST
59876: LIST
59877: PUSH
59878: LD_INT 1
59880: PUSH
59881: LD_INT 4
59883: PUSH
59884: EMPTY
59885: LIST
59886: LIST
59887: PUSH
59888: LD_INT 1
59890: PUSH
59891: LD_INT 5
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: PUSH
59898: LD_INT 0
59900: PUSH
59901: LD_INT 5
59903: PUSH
59904: EMPTY
59905: LIST
59906: LIST
59907: PUSH
59908: LD_INT 1
59910: NEG
59911: PUSH
59912: LD_INT 4
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 1
59921: NEG
59922: PUSH
59923: LD_INT 3
59925: PUSH
59926: EMPTY
59927: LIST
59928: LIST
59929: PUSH
59930: LD_INT 2
59932: PUSH
59933: LD_INT 5
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: PUSH
59940: LD_INT 2
59942: NEG
59943: PUSH
59944: LD_INT 3
59946: PUSH
59947: EMPTY
59948: LIST
59949: LIST
59950: PUSH
59951: EMPTY
59952: LIST
59953: LIST
59954: LIST
59955: LIST
59956: LIST
59957: LIST
59958: LIST
59959: LIST
59960: LIST
59961: LIST
59962: LIST
59963: LIST
59964: LIST
59965: LIST
59966: LIST
59967: LIST
59968: LIST
59969: LIST
59970: LIST
59971: LIST
59972: LIST
59973: LIST
59974: LIST
59975: LIST
59976: LIST
59977: LIST
59978: LIST
59979: LIST
59980: LIST
59981: LIST
59982: LIST
59983: LIST
59984: LIST
59985: LIST
59986: LIST
59987: LIST
59988: LIST
59989: LIST
59990: LIST
59991: LIST
59992: LIST
59993: LIST
59994: LIST
59995: LIST
59996: LIST
59997: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
59998: LD_ADDR_VAR 0 34
60002: PUSH
60003: LD_INT 0
60005: PUSH
60006: LD_INT 4
60008: NEG
60009: PUSH
60010: EMPTY
60011: LIST
60012: LIST
60013: PUSH
60014: LD_INT 0
60016: PUSH
60017: LD_INT 5
60019: NEG
60020: PUSH
60021: EMPTY
60022: LIST
60023: LIST
60024: PUSH
60025: LD_INT 1
60027: PUSH
60028: LD_INT 4
60030: NEG
60031: PUSH
60032: EMPTY
60033: LIST
60034: LIST
60035: PUSH
60036: LD_INT 1
60038: PUSH
60039: LD_INT 3
60041: NEG
60042: PUSH
60043: EMPTY
60044: LIST
60045: LIST
60046: PUSH
60047: LD_INT 0
60049: PUSH
60050: LD_INT 3
60052: NEG
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 1
60060: NEG
60061: PUSH
60062: LD_INT 4
60064: NEG
60065: PUSH
60066: EMPTY
60067: LIST
60068: LIST
60069: PUSH
60070: LD_INT 1
60072: NEG
60073: PUSH
60074: LD_INT 5
60076: NEG
60077: PUSH
60078: EMPTY
60079: LIST
60080: LIST
60081: PUSH
60082: LD_INT 2
60084: PUSH
60085: LD_INT 3
60087: NEG
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PUSH
60093: LD_INT 2
60095: NEG
60096: PUSH
60097: LD_INT 5
60099: NEG
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PUSH
60105: LD_INT 3
60107: PUSH
60108: LD_INT 0
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PUSH
60115: LD_INT 3
60117: PUSH
60118: LD_INT 1
60120: NEG
60121: PUSH
60122: EMPTY
60123: LIST
60124: LIST
60125: PUSH
60126: LD_INT 4
60128: PUSH
60129: LD_INT 0
60131: PUSH
60132: EMPTY
60133: LIST
60134: LIST
60135: PUSH
60136: LD_INT 4
60138: PUSH
60139: LD_INT 1
60141: PUSH
60142: EMPTY
60143: LIST
60144: LIST
60145: PUSH
60146: LD_INT 3
60148: PUSH
60149: LD_INT 1
60151: PUSH
60152: EMPTY
60153: LIST
60154: LIST
60155: PUSH
60156: LD_INT 2
60158: PUSH
60159: LD_INT 0
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: PUSH
60166: LD_INT 2
60168: PUSH
60169: LD_INT 1
60171: NEG
60172: PUSH
60173: EMPTY
60174: LIST
60175: LIST
60176: PUSH
60177: LD_INT 2
60179: PUSH
60180: LD_INT 2
60182: NEG
60183: PUSH
60184: EMPTY
60185: LIST
60186: LIST
60187: PUSH
60188: LD_INT 4
60190: PUSH
60191: LD_INT 2
60193: PUSH
60194: EMPTY
60195: LIST
60196: LIST
60197: PUSH
60198: LD_INT 4
60200: PUSH
60201: LD_INT 4
60203: PUSH
60204: EMPTY
60205: LIST
60206: LIST
60207: PUSH
60208: LD_INT 4
60210: PUSH
60211: LD_INT 3
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: PUSH
60218: LD_INT 5
60220: PUSH
60221: LD_INT 4
60223: PUSH
60224: EMPTY
60225: LIST
60226: LIST
60227: PUSH
60228: LD_INT 5
60230: PUSH
60231: LD_INT 5
60233: PUSH
60234: EMPTY
60235: LIST
60236: LIST
60237: PUSH
60238: LD_INT 4
60240: PUSH
60241: LD_INT 5
60243: PUSH
60244: EMPTY
60245: LIST
60246: LIST
60247: PUSH
60248: LD_INT 3
60250: PUSH
60251: LD_INT 4
60253: PUSH
60254: EMPTY
60255: LIST
60256: LIST
60257: PUSH
60258: LD_INT 3
60260: PUSH
60261: LD_INT 3
60263: PUSH
60264: EMPTY
60265: LIST
60266: LIST
60267: PUSH
60268: LD_INT 5
60270: PUSH
60271: LD_INT 3
60273: PUSH
60274: EMPTY
60275: LIST
60276: LIST
60277: PUSH
60278: LD_INT 3
60280: PUSH
60281: LD_INT 5
60283: PUSH
60284: EMPTY
60285: LIST
60286: LIST
60287: PUSH
60288: LD_INT 0
60290: PUSH
60291: LD_INT 3
60293: PUSH
60294: EMPTY
60295: LIST
60296: LIST
60297: PUSH
60298: LD_INT 0
60300: PUSH
60301: LD_INT 2
60303: PUSH
60304: EMPTY
60305: LIST
60306: LIST
60307: PUSH
60308: LD_INT 1
60310: PUSH
60311: LD_INT 3
60313: PUSH
60314: EMPTY
60315: LIST
60316: LIST
60317: PUSH
60318: LD_INT 1
60320: PUSH
60321: LD_INT 4
60323: PUSH
60324: EMPTY
60325: LIST
60326: LIST
60327: PUSH
60328: LD_INT 0
60330: PUSH
60331: LD_INT 4
60333: PUSH
60334: EMPTY
60335: LIST
60336: LIST
60337: PUSH
60338: LD_INT 1
60340: NEG
60341: PUSH
60342: LD_INT 3
60344: PUSH
60345: EMPTY
60346: LIST
60347: LIST
60348: PUSH
60349: LD_INT 1
60351: NEG
60352: PUSH
60353: LD_INT 2
60355: PUSH
60356: EMPTY
60357: LIST
60358: LIST
60359: PUSH
60360: LD_INT 2
60362: PUSH
60363: LD_INT 4
60365: PUSH
60366: EMPTY
60367: LIST
60368: LIST
60369: PUSH
60370: LD_INT 2
60372: NEG
60373: PUSH
60374: LD_INT 2
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: PUSH
60381: LD_INT 4
60383: NEG
60384: PUSH
60385: LD_INT 0
60387: PUSH
60388: EMPTY
60389: LIST
60390: LIST
60391: PUSH
60392: LD_INT 4
60394: NEG
60395: PUSH
60396: LD_INT 1
60398: NEG
60399: PUSH
60400: EMPTY
60401: LIST
60402: LIST
60403: PUSH
60404: LD_INT 3
60406: NEG
60407: PUSH
60408: LD_INT 0
60410: PUSH
60411: EMPTY
60412: LIST
60413: LIST
60414: PUSH
60415: LD_INT 3
60417: NEG
60418: PUSH
60419: LD_INT 1
60421: PUSH
60422: EMPTY
60423: LIST
60424: LIST
60425: PUSH
60426: LD_INT 4
60428: NEG
60429: PUSH
60430: LD_INT 1
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: LD_INT 5
60439: NEG
60440: PUSH
60441: LD_INT 0
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: PUSH
60448: LD_INT 5
60450: NEG
60451: PUSH
60452: LD_INT 1
60454: NEG
60455: PUSH
60456: EMPTY
60457: LIST
60458: LIST
60459: PUSH
60460: LD_INT 5
60462: NEG
60463: PUSH
60464: LD_INT 2
60466: NEG
60467: PUSH
60468: EMPTY
60469: LIST
60470: LIST
60471: PUSH
60472: LD_INT 3
60474: NEG
60475: PUSH
60476: LD_INT 2
60478: PUSH
60479: EMPTY
60480: LIST
60481: LIST
60482: PUSH
60483: EMPTY
60484: LIST
60485: LIST
60486: LIST
60487: LIST
60488: LIST
60489: LIST
60490: LIST
60491: LIST
60492: LIST
60493: LIST
60494: LIST
60495: LIST
60496: LIST
60497: LIST
60498: LIST
60499: LIST
60500: LIST
60501: LIST
60502: LIST
60503: LIST
60504: LIST
60505: LIST
60506: LIST
60507: LIST
60508: LIST
60509: LIST
60510: LIST
60511: LIST
60512: LIST
60513: LIST
60514: LIST
60515: LIST
60516: LIST
60517: LIST
60518: LIST
60519: LIST
60520: LIST
60521: LIST
60522: LIST
60523: LIST
60524: LIST
60525: LIST
60526: LIST
60527: LIST
60528: LIST
60529: ST_TO_ADDR
// end ; end ;
60530: GO 60533
60532: POP
// case btype of b_depot , b_warehouse :
60533: LD_VAR 0 1
60537: PUSH
60538: LD_INT 0
60540: DOUBLE
60541: EQUAL
60542: IFTRUE 60552
60544: LD_INT 1
60546: DOUBLE
60547: EQUAL
60548: IFTRUE 60552
60550: GO 60753
60552: POP
// case nation of nation_american :
60553: LD_VAR 0 5
60557: PUSH
60558: LD_INT 1
60560: DOUBLE
60561: EQUAL
60562: IFTRUE 60566
60564: GO 60622
60566: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
60567: LD_ADDR_VAR 0 9
60571: PUSH
60572: LD_VAR 0 11
60576: PUSH
60577: LD_VAR 0 12
60581: PUSH
60582: LD_VAR 0 13
60586: PUSH
60587: LD_VAR 0 14
60591: PUSH
60592: LD_VAR 0 15
60596: PUSH
60597: LD_VAR 0 16
60601: PUSH
60602: EMPTY
60603: LIST
60604: LIST
60605: LIST
60606: LIST
60607: LIST
60608: LIST
60609: PUSH
60610: LD_VAR 0 4
60614: PUSH
60615: LD_INT 1
60617: PLUS
60618: ARRAY
60619: ST_TO_ADDR
60620: GO 60751
60622: LD_INT 2
60624: DOUBLE
60625: EQUAL
60626: IFTRUE 60630
60628: GO 60686
60630: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
60631: LD_ADDR_VAR 0 9
60635: PUSH
60636: LD_VAR 0 17
60640: PUSH
60641: LD_VAR 0 18
60645: PUSH
60646: LD_VAR 0 19
60650: PUSH
60651: LD_VAR 0 20
60655: PUSH
60656: LD_VAR 0 21
60660: PUSH
60661: LD_VAR 0 22
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: LIST
60670: LIST
60671: LIST
60672: LIST
60673: PUSH
60674: LD_VAR 0 4
60678: PUSH
60679: LD_INT 1
60681: PLUS
60682: ARRAY
60683: ST_TO_ADDR
60684: GO 60751
60686: LD_INT 3
60688: DOUBLE
60689: EQUAL
60690: IFTRUE 60694
60692: GO 60750
60694: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
60695: LD_ADDR_VAR 0 9
60699: PUSH
60700: LD_VAR 0 23
60704: PUSH
60705: LD_VAR 0 24
60709: PUSH
60710: LD_VAR 0 25
60714: PUSH
60715: LD_VAR 0 26
60719: PUSH
60720: LD_VAR 0 27
60724: PUSH
60725: LD_VAR 0 28
60729: PUSH
60730: EMPTY
60731: LIST
60732: LIST
60733: LIST
60734: LIST
60735: LIST
60736: LIST
60737: PUSH
60738: LD_VAR 0 4
60742: PUSH
60743: LD_INT 1
60745: PLUS
60746: ARRAY
60747: ST_TO_ADDR
60748: GO 60751
60750: POP
60751: GO 61300
60753: LD_INT 2
60755: DOUBLE
60756: EQUAL
60757: IFTRUE 60767
60759: LD_INT 3
60761: DOUBLE
60762: EQUAL
60763: IFTRUE 60767
60765: GO 60823
60767: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
60768: LD_ADDR_VAR 0 9
60772: PUSH
60773: LD_VAR 0 29
60777: PUSH
60778: LD_VAR 0 30
60782: PUSH
60783: LD_VAR 0 31
60787: PUSH
60788: LD_VAR 0 32
60792: PUSH
60793: LD_VAR 0 33
60797: PUSH
60798: LD_VAR 0 34
60802: PUSH
60803: EMPTY
60804: LIST
60805: LIST
60806: LIST
60807: LIST
60808: LIST
60809: LIST
60810: PUSH
60811: LD_VAR 0 4
60815: PUSH
60816: LD_INT 1
60818: PLUS
60819: ARRAY
60820: ST_TO_ADDR
60821: GO 61300
60823: LD_INT 16
60825: DOUBLE
60826: EQUAL
60827: IFTRUE 60879
60829: LD_INT 17
60831: DOUBLE
60832: EQUAL
60833: IFTRUE 60879
60835: LD_INT 18
60837: DOUBLE
60838: EQUAL
60839: IFTRUE 60879
60841: LD_INT 19
60843: DOUBLE
60844: EQUAL
60845: IFTRUE 60879
60847: LD_INT 20
60849: DOUBLE
60850: EQUAL
60851: IFTRUE 60879
60853: LD_INT 21
60855: DOUBLE
60856: EQUAL
60857: IFTRUE 60879
60859: LD_INT 23
60861: DOUBLE
60862: EQUAL
60863: IFTRUE 60879
60865: LD_INT 24
60867: DOUBLE
60868: EQUAL
60869: IFTRUE 60879
60871: LD_INT 25
60873: DOUBLE
60874: EQUAL
60875: IFTRUE 60879
60877: GO 60935
60879: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
60880: LD_ADDR_VAR 0 9
60884: PUSH
60885: LD_VAR 0 35
60889: PUSH
60890: LD_VAR 0 36
60894: PUSH
60895: LD_VAR 0 37
60899: PUSH
60900: LD_VAR 0 38
60904: PUSH
60905: LD_VAR 0 39
60909: PUSH
60910: LD_VAR 0 40
60914: PUSH
60915: EMPTY
60916: LIST
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: LIST
60922: PUSH
60923: LD_VAR 0 4
60927: PUSH
60928: LD_INT 1
60930: PLUS
60931: ARRAY
60932: ST_TO_ADDR
60933: GO 61300
60935: LD_INT 6
60937: DOUBLE
60938: EQUAL
60939: IFTRUE 60991
60941: LD_INT 7
60943: DOUBLE
60944: EQUAL
60945: IFTRUE 60991
60947: LD_INT 8
60949: DOUBLE
60950: EQUAL
60951: IFTRUE 60991
60953: LD_INT 13
60955: DOUBLE
60956: EQUAL
60957: IFTRUE 60991
60959: LD_INT 12
60961: DOUBLE
60962: EQUAL
60963: IFTRUE 60991
60965: LD_INT 15
60967: DOUBLE
60968: EQUAL
60969: IFTRUE 60991
60971: LD_INT 11
60973: DOUBLE
60974: EQUAL
60975: IFTRUE 60991
60977: LD_INT 14
60979: DOUBLE
60980: EQUAL
60981: IFTRUE 60991
60983: LD_INT 10
60985: DOUBLE
60986: EQUAL
60987: IFTRUE 60991
60989: GO 61047
60991: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
60992: LD_ADDR_VAR 0 9
60996: PUSH
60997: LD_VAR 0 41
61001: PUSH
61002: LD_VAR 0 42
61006: PUSH
61007: LD_VAR 0 43
61011: PUSH
61012: LD_VAR 0 44
61016: PUSH
61017: LD_VAR 0 45
61021: PUSH
61022: LD_VAR 0 46
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: PUSH
61035: LD_VAR 0 4
61039: PUSH
61040: LD_INT 1
61042: PLUS
61043: ARRAY
61044: ST_TO_ADDR
61045: GO 61300
61047: LD_INT 36
61049: DOUBLE
61050: EQUAL
61051: IFTRUE 61055
61053: GO 61111
61055: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
61056: LD_ADDR_VAR 0 9
61060: PUSH
61061: LD_VAR 0 47
61065: PUSH
61066: LD_VAR 0 48
61070: PUSH
61071: LD_VAR 0 49
61075: PUSH
61076: LD_VAR 0 50
61080: PUSH
61081: LD_VAR 0 51
61085: PUSH
61086: LD_VAR 0 52
61090: PUSH
61091: EMPTY
61092: LIST
61093: LIST
61094: LIST
61095: LIST
61096: LIST
61097: LIST
61098: PUSH
61099: LD_VAR 0 4
61103: PUSH
61104: LD_INT 1
61106: PLUS
61107: ARRAY
61108: ST_TO_ADDR
61109: GO 61300
61111: LD_INT 4
61113: DOUBLE
61114: EQUAL
61115: IFTRUE 61137
61117: LD_INT 5
61119: DOUBLE
61120: EQUAL
61121: IFTRUE 61137
61123: LD_INT 34
61125: DOUBLE
61126: EQUAL
61127: IFTRUE 61137
61129: LD_INT 37
61131: DOUBLE
61132: EQUAL
61133: IFTRUE 61137
61135: GO 61193
61137: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
61138: LD_ADDR_VAR 0 9
61142: PUSH
61143: LD_VAR 0 53
61147: PUSH
61148: LD_VAR 0 54
61152: PUSH
61153: LD_VAR 0 55
61157: PUSH
61158: LD_VAR 0 56
61162: PUSH
61163: LD_VAR 0 57
61167: PUSH
61168: LD_VAR 0 58
61172: PUSH
61173: EMPTY
61174: LIST
61175: LIST
61176: LIST
61177: LIST
61178: LIST
61179: LIST
61180: PUSH
61181: LD_VAR 0 4
61185: PUSH
61186: LD_INT 1
61188: PLUS
61189: ARRAY
61190: ST_TO_ADDR
61191: GO 61300
61193: LD_INT 31
61195: DOUBLE
61196: EQUAL
61197: IFTRUE 61243
61199: LD_INT 32
61201: DOUBLE
61202: EQUAL
61203: IFTRUE 61243
61205: LD_INT 33
61207: DOUBLE
61208: EQUAL
61209: IFTRUE 61243
61211: LD_INT 27
61213: DOUBLE
61214: EQUAL
61215: IFTRUE 61243
61217: LD_INT 26
61219: DOUBLE
61220: EQUAL
61221: IFTRUE 61243
61223: LD_INT 28
61225: DOUBLE
61226: EQUAL
61227: IFTRUE 61243
61229: LD_INT 29
61231: DOUBLE
61232: EQUAL
61233: IFTRUE 61243
61235: LD_INT 30
61237: DOUBLE
61238: EQUAL
61239: IFTRUE 61243
61241: GO 61299
61243: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
61244: LD_ADDR_VAR 0 9
61248: PUSH
61249: LD_VAR 0 59
61253: PUSH
61254: LD_VAR 0 60
61258: PUSH
61259: LD_VAR 0 61
61263: PUSH
61264: LD_VAR 0 62
61268: PUSH
61269: LD_VAR 0 63
61273: PUSH
61274: LD_VAR 0 64
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: LIST
61283: LIST
61284: LIST
61285: LIST
61286: PUSH
61287: LD_VAR 0 4
61291: PUSH
61292: LD_INT 1
61294: PLUS
61295: ARRAY
61296: ST_TO_ADDR
61297: GO 61300
61299: POP
// temp_list2 = [ ] ;
61300: LD_ADDR_VAR 0 10
61304: PUSH
61305: EMPTY
61306: ST_TO_ADDR
// for i in temp_list do
61307: LD_ADDR_VAR 0 8
61311: PUSH
61312: LD_VAR 0 9
61316: PUSH
61317: FOR_IN
61318: IFFALSE 61370
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
61320: LD_ADDR_VAR 0 10
61324: PUSH
61325: LD_VAR 0 10
61329: PUSH
61330: LD_VAR 0 8
61334: PUSH
61335: LD_INT 1
61337: ARRAY
61338: PUSH
61339: LD_VAR 0 2
61343: PLUS
61344: PUSH
61345: LD_VAR 0 8
61349: PUSH
61350: LD_INT 2
61352: ARRAY
61353: PUSH
61354: LD_VAR 0 3
61358: PLUS
61359: PUSH
61360: EMPTY
61361: LIST
61362: LIST
61363: PUSH
61364: EMPTY
61365: LIST
61366: ADD
61367: ST_TO_ADDR
61368: GO 61317
61370: POP
61371: POP
// result = temp_list2 ;
61372: LD_ADDR_VAR 0 7
61376: PUSH
61377: LD_VAR 0 10
61381: ST_TO_ADDR
// end ;
61382: LD_VAR 0 7
61386: RET
// export function EnemyInRange ( unit , dist ) ; begin
61387: LD_INT 0
61389: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
61390: LD_ADDR_VAR 0 3
61394: PUSH
61395: LD_VAR 0 1
61399: PPUSH
61400: CALL_OW 255
61404: PPUSH
61405: LD_VAR 0 1
61409: PPUSH
61410: CALL_OW 250
61414: PPUSH
61415: LD_VAR 0 1
61419: PPUSH
61420: CALL_OW 251
61424: PPUSH
61425: LD_VAR 0 2
61429: PPUSH
61430: CALL 35702 0 4
61434: PUSH
61435: LD_INT 4
61437: ARRAY
61438: ST_TO_ADDR
// end ;
61439: LD_VAR 0 3
61443: RET
// export function PlayerSeeMe ( unit ) ; begin
61444: LD_INT 0
61446: PPUSH
// result := See ( your_side , unit ) ;
61447: LD_ADDR_VAR 0 2
61451: PUSH
61452: LD_OWVAR 2
61456: PPUSH
61457: LD_VAR 0 1
61461: PPUSH
61462: CALL_OW 292
61466: ST_TO_ADDR
// end ;
61467: LD_VAR 0 2
61471: RET
// export function ReverseDir ( unit ) ; begin
61472: LD_INT 0
61474: PPUSH
// if not unit then
61475: LD_VAR 0 1
61479: NOT
61480: IFFALSE 61484
// exit ;
61482: GO 61530
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
61484: LD_ADDR_VAR 0 2
61488: PUSH
61489: LD_INT 3
61491: PUSH
61492: LD_INT 4
61494: PUSH
61495: LD_INT 5
61497: PUSH
61498: LD_INT 0
61500: PUSH
61501: LD_INT 1
61503: PUSH
61504: LD_INT 2
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: LIST
61511: LIST
61512: LIST
61513: LIST
61514: PUSH
61515: LD_VAR 0 1
61519: PPUSH
61520: CALL_OW 254
61524: PUSH
61525: LD_INT 1
61527: PLUS
61528: ARRAY
61529: ST_TO_ADDR
// end ;
61530: LD_VAR 0 2
61534: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
61535: LD_INT 0
61537: PPUSH
61538: PPUSH
61539: PPUSH
61540: PPUSH
61541: PPUSH
// if not hexes then
61542: LD_VAR 0 2
61546: NOT
61547: IFFALSE 61551
// exit ;
61549: GO 61699
// dist := 9999 ;
61551: LD_ADDR_VAR 0 5
61555: PUSH
61556: LD_INT 9999
61558: ST_TO_ADDR
// for i = 1 to hexes do
61559: LD_ADDR_VAR 0 4
61563: PUSH
61564: DOUBLE
61565: LD_INT 1
61567: DEC
61568: ST_TO_ADDR
61569: LD_VAR 0 2
61573: PUSH
61574: FOR_TO
61575: IFFALSE 61687
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
61577: LD_VAR 0 1
61581: PPUSH
61582: LD_VAR 0 2
61586: PUSH
61587: LD_VAR 0 4
61591: ARRAY
61592: PUSH
61593: LD_INT 1
61595: ARRAY
61596: PPUSH
61597: LD_VAR 0 2
61601: PUSH
61602: LD_VAR 0 4
61606: ARRAY
61607: PUSH
61608: LD_INT 2
61610: ARRAY
61611: PPUSH
61612: CALL_OW 297
61616: PUSH
61617: LD_VAR 0 5
61621: LESS
61622: IFFALSE 61685
// begin hex := hexes [ i ] ;
61624: LD_ADDR_VAR 0 7
61628: PUSH
61629: LD_VAR 0 2
61633: PUSH
61634: LD_VAR 0 4
61638: ARRAY
61639: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61640: LD_ADDR_VAR 0 5
61644: PUSH
61645: LD_VAR 0 1
61649: PPUSH
61650: LD_VAR 0 2
61654: PUSH
61655: LD_VAR 0 4
61659: ARRAY
61660: PUSH
61661: LD_INT 1
61663: ARRAY
61664: PPUSH
61665: LD_VAR 0 2
61669: PUSH
61670: LD_VAR 0 4
61674: ARRAY
61675: PUSH
61676: LD_INT 2
61678: ARRAY
61679: PPUSH
61680: CALL_OW 297
61684: ST_TO_ADDR
// end ; end ;
61685: GO 61574
61687: POP
61688: POP
// result := hex ;
61689: LD_ADDR_VAR 0 3
61693: PUSH
61694: LD_VAR 0 7
61698: ST_TO_ADDR
// end ;
61699: LD_VAR 0 3
61703: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
61704: LD_INT 0
61706: PPUSH
61707: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
61708: LD_VAR 0 1
61712: NOT
61713: PUSH
61714: LD_VAR 0 1
61718: PUSH
61719: LD_INT 21
61721: PUSH
61722: LD_INT 2
61724: PUSH
61725: EMPTY
61726: LIST
61727: LIST
61728: PUSH
61729: LD_INT 23
61731: PUSH
61732: LD_INT 2
61734: PUSH
61735: EMPTY
61736: LIST
61737: LIST
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PPUSH
61743: CALL_OW 69
61747: IN
61748: NOT
61749: OR
61750: IFFALSE 61754
// exit ;
61752: GO 61801
// for i = 1 to 3 do
61754: LD_ADDR_VAR 0 3
61758: PUSH
61759: DOUBLE
61760: LD_INT 1
61762: DEC
61763: ST_TO_ADDR
61764: LD_INT 3
61766: PUSH
61767: FOR_TO
61768: IFFALSE 61799
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
61770: LD_VAR 0 1
61774: PPUSH
61775: CALL_OW 250
61779: PPUSH
61780: LD_VAR 0 1
61784: PPUSH
61785: CALL_OW 251
61789: PPUSH
61790: LD_INT 1
61792: PPUSH
61793: CALL_OW 453
61797: GO 61767
61799: POP
61800: POP
// end ;
61801: LD_VAR 0 2
61805: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
61806: LD_INT 0
61808: PPUSH
61809: PPUSH
61810: PPUSH
61811: PPUSH
61812: PPUSH
61813: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
61814: LD_VAR 0 1
61818: NOT
61819: PUSH
61820: LD_VAR 0 2
61824: NOT
61825: OR
61826: PUSH
61827: LD_VAR 0 1
61831: PPUSH
61832: CALL_OW 314
61836: OR
61837: IFFALSE 61841
// exit ;
61839: GO 62282
// x := GetX ( enemy_unit ) ;
61841: LD_ADDR_VAR 0 7
61845: PUSH
61846: LD_VAR 0 2
61850: PPUSH
61851: CALL_OW 250
61855: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
61856: LD_ADDR_VAR 0 8
61860: PUSH
61861: LD_VAR 0 2
61865: PPUSH
61866: CALL_OW 251
61870: ST_TO_ADDR
// if not x or not y then
61871: LD_VAR 0 7
61875: NOT
61876: PUSH
61877: LD_VAR 0 8
61881: NOT
61882: OR
61883: IFFALSE 61887
// exit ;
61885: GO 62282
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
61887: LD_ADDR_VAR 0 6
61891: PUSH
61892: LD_VAR 0 7
61896: PPUSH
61897: LD_INT 0
61899: PPUSH
61900: LD_INT 4
61902: PPUSH
61903: CALL_OW 272
61907: PUSH
61908: LD_VAR 0 8
61912: PPUSH
61913: LD_INT 0
61915: PPUSH
61916: LD_INT 4
61918: PPUSH
61919: CALL_OW 273
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_VAR 0 7
61932: PPUSH
61933: LD_INT 1
61935: PPUSH
61936: LD_INT 4
61938: PPUSH
61939: CALL_OW 272
61943: PUSH
61944: LD_VAR 0 8
61948: PPUSH
61949: LD_INT 1
61951: PPUSH
61952: LD_INT 4
61954: PPUSH
61955: CALL_OW 273
61959: PUSH
61960: EMPTY
61961: LIST
61962: LIST
61963: PUSH
61964: LD_VAR 0 7
61968: PPUSH
61969: LD_INT 2
61971: PPUSH
61972: LD_INT 4
61974: PPUSH
61975: CALL_OW 272
61979: PUSH
61980: LD_VAR 0 8
61984: PPUSH
61985: LD_INT 2
61987: PPUSH
61988: LD_INT 4
61990: PPUSH
61991: CALL_OW 273
61995: PUSH
61996: EMPTY
61997: LIST
61998: LIST
61999: PUSH
62000: LD_VAR 0 7
62004: PPUSH
62005: LD_INT 3
62007: PPUSH
62008: LD_INT 4
62010: PPUSH
62011: CALL_OW 272
62015: PUSH
62016: LD_VAR 0 8
62020: PPUSH
62021: LD_INT 3
62023: PPUSH
62024: LD_INT 4
62026: PPUSH
62027: CALL_OW 273
62031: PUSH
62032: EMPTY
62033: LIST
62034: LIST
62035: PUSH
62036: LD_VAR 0 7
62040: PPUSH
62041: LD_INT 4
62043: PPUSH
62044: LD_INT 4
62046: PPUSH
62047: CALL_OW 272
62051: PUSH
62052: LD_VAR 0 8
62056: PPUSH
62057: LD_INT 4
62059: PPUSH
62060: LD_INT 4
62062: PPUSH
62063: CALL_OW 273
62067: PUSH
62068: EMPTY
62069: LIST
62070: LIST
62071: PUSH
62072: LD_VAR 0 7
62076: PPUSH
62077: LD_INT 5
62079: PPUSH
62080: LD_INT 4
62082: PPUSH
62083: CALL_OW 272
62087: PUSH
62088: LD_VAR 0 8
62092: PPUSH
62093: LD_INT 5
62095: PPUSH
62096: LD_INT 4
62098: PPUSH
62099: CALL_OW 273
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: PUSH
62108: EMPTY
62109: LIST
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: LIST
62115: ST_TO_ADDR
// for i = tmp downto 1 do
62116: LD_ADDR_VAR 0 4
62120: PUSH
62121: DOUBLE
62122: LD_VAR 0 6
62126: INC
62127: ST_TO_ADDR
62128: LD_INT 1
62130: PUSH
62131: FOR_DOWNTO
62132: IFFALSE 62233
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
62134: LD_VAR 0 6
62138: PUSH
62139: LD_VAR 0 4
62143: ARRAY
62144: PUSH
62145: LD_INT 1
62147: ARRAY
62148: PPUSH
62149: LD_VAR 0 6
62153: PUSH
62154: LD_VAR 0 4
62158: ARRAY
62159: PUSH
62160: LD_INT 2
62162: ARRAY
62163: PPUSH
62164: CALL_OW 488
62168: NOT
62169: PUSH
62170: LD_VAR 0 6
62174: PUSH
62175: LD_VAR 0 4
62179: ARRAY
62180: PUSH
62181: LD_INT 1
62183: ARRAY
62184: PPUSH
62185: LD_VAR 0 6
62189: PUSH
62190: LD_VAR 0 4
62194: ARRAY
62195: PUSH
62196: LD_INT 2
62198: ARRAY
62199: PPUSH
62200: CALL_OW 428
62204: PUSH
62205: LD_INT 0
62207: NONEQUAL
62208: OR
62209: IFFALSE 62231
// tmp := Delete ( tmp , i ) ;
62211: LD_ADDR_VAR 0 6
62215: PUSH
62216: LD_VAR 0 6
62220: PPUSH
62221: LD_VAR 0 4
62225: PPUSH
62226: CALL_OW 3
62230: ST_TO_ADDR
62231: GO 62131
62233: POP
62234: POP
// j := GetClosestHex ( unit , tmp ) ;
62235: LD_ADDR_VAR 0 5
62239: PUSH
62240: LD_VAR 0 1
62244: PPUSH
62245: LD_VAR 0 6
62249: PPUSH
62250: CALL 61535 0 2
62254: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
62255: LD_VAR 0 1
62259: PPUSH
62260: LD_VAR 0 5
62264: PUSH
62265: LD_INT 1
62267: ARRAY
62268: PPUSH
62269: LD_VAR 0 5
62273: PUSH
62274: LD_INT 2
62276: ARRAY
62277: PPUSH
62278: CALL_OW 111
// end ;
62282: LD_VAR 0 3
62286: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
62287: LD_INT 0
62289: PPUSH
62290: PPUSH
62291: PPUSH
// uc_side = 0 ;
62292: LD_ADDR_OWVAR 20
62296: PUSH
62297: LD_INT 0
62299: ST_TO_ADDR
// uc_nation = 0 ;
62300: LD_ADDR_OWVAR 21
62304: PUSH
62305: LD_INT 0
62307: ST_TO_ADDR
// InitHc ;
62308: CALL_OW 19
// InitVc ;
62312: CALL_OW 20
// if mastodonts then
62316: LD_VAR 0 6
62320: IFFALSE 62387
// for i = 1 to mastodonts do
62322: LD_ADDR_VAR 0 11
62326: PUSH
62327: DOUBLE
62328: LD_INT 1
62330: DEC
62331: ST_TO_ADDR
62332: LD_VAR 0 6
62336: PUSH
62337: FOR_TO
62338: IFFALSE 62385
// begin vc_chassis := 31 ;
62340: LD_ADDR_OWVAR 37
62344: PUSH
62345: LD_INT 31
62347: ST_TO_ADDR
// vc_control := control_rider ;
62348: LD_ADDR_OWVAR 38
62352: PUSH
62353: LD_INT 4
62355: ST_TO_ADDR
// animal := CreateVehicle ;
62356: LD_ADDR_VAR 0 12
62360: PUSH
62361: CALL_OW 45
62365: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
62366: LD_VAR 0 12
62370: PPUSH
62371: LD_VAR 0 8
62375: PPUSH
62376: LD_INT 0
62378: PPUSH
62379: CALL 69093 0 3
// end ;
62383: GO 62337
62385: POP
62386: POP
// if horses then
62387: LD_VAR 0 5
62391: IFFALSE 62458
// for i = 1 to horses do
62393: LD_ADDR_VAR 0 11
62397: PUSH
62398: DOUBLE
62399: LD_INT 1
62401: DEC
62402: ST_TO_ADDR
62403: LD_VAR 0 5
62407: PUSH
62408: FOR_TO
62409: IFFALSE 62456
// begin hc_class := 21 ;
62411: LD_ADDR_OWVAR 28
62415: PUSH
62416: LD_INT 21
62418: ST_TO_ADDR
// hc_gallery :=  ;
62419: LD_ADDR_OWVAR 33
62423: PUSH
62424: LD_STRING 
62426: ST_TO_ADDR
// animal := CreateHuman ;
62427: LD_ADDR_VAR 0 12
62431: PUSH
62432: CALL_OW 44
62436: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
62437: LD_VAR 0 12
62441: PPUSH
62442: LD_VAR 0 8
62446: PPUSH
62447: LD_INT 0
62449: PPUSH
62450: CALL 69093 0 3
// end ;
62454: GO 62408
62456: POP
62457: POP
// if birds then
62458: LD_VAR 0 1
62462: IFFALSE 62529
// for i = 1 to birds do
62464: LD_ADDR_VAR 0 11
62468: PUSH
62469: DOUBLE
62470: LD_INT 1
62472: DEC
62473: ST_TO_ADDR
62474: LD_VAR 0 1
62478: PUSH
62479: FOR_TO
62480: IFFALSE 62527
// begin hc_class = 18 ;
62482: LD_ADDR_OWVAR 28
62486: PUSH
62487: LD_INT 18
62489: ST_TO_ADDR
// hc_gallery =  ;
62490: LD_ADDR_OWVAR 33
62494: PUSH
62495: LD_STRING 
62497: ST_TO_ADDR
// animal := CreateHuman ;
62498: LD_ADDR_VAR 0 12
62502: PUSH
62503: CALL_OW 44
62507: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
62508: LD_VAR 0 12
62512: PPUSH
62513: LD_VAR 0 8
62517: PPUSH
62518: LD_INT 0
62520: PPUSH
62521: CALL 69093 0 3
// end ;
62525: GO 62479
62527: POP
62528: POP
// if tigers then
62529: LD_VAR 0 2
62533: IFFALSE 62617
// for i = 1 to tigers do
62535: LD_ADDR_VAR 0 11
62539: PUSH
62540: DOUBLE
62541: LD_INT 1
62543: DEC
62544: ST_TO_ADDR
62545: LD_VAR 0 2
62549: PUSH
62550: FOR_TO
62551: IFFALSE 62615
// begin hc_class = class_tiger ;
62553: LD_ADDR_OWVAR 28
62557: PUSH
62558: LD_INT 14
62560: ST_TO_ADDR
// hc_gallery =  ;
62561: LD_ADDR_OWVAR 33
62565: PUSH
62566: LD_STRING 
62568: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
62569: LD_ADDR_OWVAR 35
62573: PUSH
62574: LD_INT 7
62576: NEG
62577: PPUSH
62578: LD_INT 7
62580: PPUSH
62581: CALL_OW 12
62585: ST_TO_ADDR
// animal := CreateHuman ;
62586: LD_ADDR_VAR 0 12
62590: PUSH
62591: CALL_OW 44
62595: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
62596: LD_VAR 0 12
62600: PPUSH
62601: LD_VAR 0 8
62605: PPUSH
62606: LD_INT 0
62608: PPUSH
62609: CALL 69093 0 3
// end ;
62613: GO 62550
62615: POP
62616: POP
// if apemans then
62617: LD_VAR 0 3
62621: IFFALSE 62744
// for i = 1 to apemans do
62623: LD_ADDR_VAR 0 11
62627: PUSH
62628: DOUBLE
62629: LD_INT 1
62631: DEC
62632: ST_TO_ADDR
62633: LD_VAR 0 3
62637: PUSH
62638: FOR_TO
62639: IFFALSE 62742
// begin hc_class = class_apeman ;
62641: LD_ADDR_OWVAR 28
62645: PUSH
62646: LD_INT 12
62648: ST_TO_ADDR
// hc_gallery =  ;
62649: LD_ADDR_OWVAR 33
62653: PUSH
62654: LD_STRING 
62656: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
62657: LD_ADDR_OWVAR 35
62661: PUSH
62662: LD_INT 5
62664: NEG
62665: PPUSH
62666: LD_INT 5
62668: PPUSH
62669: CALL_OW 12
62673: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
62674: LD_ADDR_OWVAR 31
62678: PUSH
62679: LD_INT 1
62681: PPUSH
62682: LD_INT 3
62684: PPUSH
62685: CALL_OW 12
62689: PUSH
62690: LD_INT 1
62692: PPUSH
62693: LD_INT 3
62695: PPUSH
62696: CALL_OW 12
62700: PUSH
62701: LD_INT 0
62703: PUSH
62704: LD_INT 0
62706: PUSH
62707: EMPTY
62708: LIST
62709: LIST
62710: LIST
62711: LIST
62712: ST_TO_ADDR
// animal := CreateHuman ;
62713: LD_ADDR_VAR 0 12
62717: PUSH
62718: CALL_OW 44
62722: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
62723: LD_VAR 0 12
62727: PPUSH
62728: LD_VAR 0 8
62732: PPUSH
62733: LD_INT 0
62735: PPUSH
62736: CALL 69093 0 3
// end ;
62740: GO 62638
62742: POP
62743: POP
// if enchidnas then
62744: LD_VAR 0 4
62748: IFFALSE 62815
// for i = 1 to enchidnas do
62750: LD_ADDR_VAR 0 11
62754: PUSH
62755: DOUBLE
62756: LD_INT 1
62758: DEC
62759: ST_TO_ADDR
62760: LD_VAR 0 4
62764: PUSH
62765: FOR_TO
62766: IFFALSE 62813
// begin hc_class = 13 ;
62768: LD_ADDR_OWVAR 28
62772: PUSH
62773: LD_INT 13
62775: ST_TO_ADDR
// hc_gallery =  ;
62776: LD_ADDR_OWVAR 33
62780: PUSH
62781: LD_STRING 
62783: ST_TO_ADDR
// animal := CreateHuman ;
62784: LD_ADDR_VAR 0 12
62788: PUSH
62789: CALL_OW 44
62793: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
62794: LD_VAR 0 12
62798: PPUSH
62799: LD_VAR 0 8
62803: PPUSH
62804: LD_INT 0
62806: PPUSH
62807: CALL 69093 0 3
// end ;
62811: GO 62765
62813: POP
62814: POP
// if fishes then
62815: LD_VAR 0 7
62819: IFFALSE 62886
// for i = 1 to fishes do
62821: LD_ADDR_VAR 0 11
62825: PUSH
62826: DOUBLE
62827: LD_INT 1
62829: DEC
62830: ST_TO_ADDR
62831: LD_VAR 0 7
62835: PUSH
62836: FOR_TO
62837: IFFALSE 62884
// begin hc_class = 20 ;
62839: LD_ADDR_OWVAR 28
62843: PUSH
62844: LD_INT 20
62846: ST_TO_ADDR
// hc_gallery =  ;
62847: LD_ADDR_OWVAR 33
62851: PUSH
62852: LD_STRING 
62854: ST_TO_ADDR
// animal := CreateHuman ;
62855: LD_ADDR_VAR 0 12
62859: PUSH
62860: CALL_OW 44
62864: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
62865: LD_VAR 0 12
62869: PPUSH
62870: LD_VAR 0 9
62874: PPUSH
62875: LD_INT 0
62877: PPUSH
62878: CALL 69093 0 3
// end ;
62882: GO 62836
62884: POP
62885: POP
// end ;
62886: LD_VAR 0 10
62890: RET
// export function WantHeal ( sci , unit ) ; begin
62891: LD_INT 0
62893: PPUSH
// if GetTaskList ( sci ) > 0 then
62894: LD_VAR 0 1
62898: PPUSH
62899: CALL_OW 437
62903: PUSH
62904: LD_INT 0
62906: GREATER
62907: IFFALSE 62977
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
62909: LD_VAR 0 1
62913: PPUSH
62914: CALL_OW 437
62918: PUSH
62919: LD_INT 1
62921: ARRAY
62922: PUSH
62923: LD_INT 1
62925: ARRAY
62926: PUSH
62927: LD_STRING l
62929: EQUAL
62930: PUSH
62931: LD_VAR 0 1
62935: PPUSH
62936: CALL_OW 437
62940: PUSH
62941: LD_INT 1
62943: ARRAY
62944: PUSH
62945: LD_INT 4
62947: ARRAY
62948: PUSH
62949: LD_VAR 0 2
62953: EQUAL
62954: AND
62955: IFFALSE 62967
// result := true else
62957: LD_ADDR_VAR 0 3
62961: PUSH
62962: LD_INT 1
62964: ST_TO_ADDR
62965: GO 62975
// result := false ;
62967: LD_ADDR_VAR 0 3
62971: PUSH
62972: LD_INT 0
62974: ST_TO_ADDR
// end else
62975: GO 62985
// result := false ;
62977: LD_ADDR_VAR 0 3
62981: PUSH
62982: LD_INT 0
62984: ST_TO_ADDR
// end ;
62985: LD_VAR 0 3
62989: RET
// export function HealTarget ( sci ) ; begin
62990: LD_INT 0
62992: PPUSH
// if not sci then
62993: LD_VAR 0 1
62997: NOT
62998: IFFALSE 63002
// exit ;
63000: GO 63067
// result := 0 ;
63002: LD_ADDR_VAR 0 2
63006: PUSH
63007: LD_INT 0
63009: ST_TO_ADDR
// if GetTaskList ( sci ) then
63010: LD_VAR 0 1
63014: PPUSH
63015: CALL_OW 437
63019: IFFALSE 63067
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
63021: LD_VAR 0 1
63025: PPUSH
63026: CALL_OW 437
63030: PUSH
63031: LD_INT 1
63033: ARRAY
63034: PUSH
63035: LD_INT 1
63037: ARRAY
63038: PUSH
63039: LD_STRING l
63041: EQUAL
63042: IFFALSE 63067
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
63044: LD_ADDR_VAR 0 2
63048: PUSH
63049: LD_VAR 0 1
63053: PPUSH
63054: CALL_OW 437
63058: PUSH
63059: LD_INT 1
63061: ARRAY
63062: PUSH
63063: LD_INT 4
63065: ARRAY
63066: ST_TO_ADDR
// end ;
63067: LD_VAR 0 2
63071: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
63072: LD_INT 0
63074: PPUSH
63075: PPUSH
63076: PPUSH
63077: PPUSH
63078: PPUSH
63079: PPUSH
63080: PPUSH
63081: PPUSH
63082: PPUSH
63083: PPUSH
63084: PPUSH
63085: PPUSH
63086: PPUSH
63087: PPUSH
63088: PPUSH
63089: PPUSH
63090: PPUSH
63091: PPUSH
63092: PPUSH
63093: PPUSH
63094: PPUSH
63095: PPUSH
63096: PPUSH
63097: PPUSH
63098: PPUSH
63099: PPUSH
63100: PPUSH
63101: PPUSH
63102: PPUSH
63103: PPUSH
63104: PPUSH
63105: PPUSH
63106: PPUSH
// if not list then
63107: LD_VAR 0 1
63111: NOT
63112: IFFALSE 63116
// exit ;
63114: GO 67704
// base := list [ 1 ] ;
63116: LD_ADDR_VAR 0 3
63120: PUSH
63121: LD_VAR 0 1
63125: PUSH
63126: LD_INT 1
63128: ARRAY
63129: ST_TO_ADDR
// group := list [ 2 ] ;
63130: LD_ADDR_VAR 0 4
63134: PUSH
63135: LD_VAR 0 1
63139: PUSH
63140: LD_INT 2
63142: ARRAY
63143: ST_TO_ADDR
// path := list [ 3 ] ;
63144: LD_ADDR_VAR 0 5
63148: PUSH
63149: LD_VAR 0 1
63153: PUSH
63154: LD_INT 3
63156: ARRAY
63157: ST_TO_ADDR
// flags := list [ 4 ] ;
63158: LD_ADDR_VAR 0 6
63162: PUSH
63163: LD_VAR 0 1
63167: PUSH
63168: LD_INT 4
63170: ARRAY
63171: ST_TO_ADDR
// mined := [ ] ;
63172: LD_ADDR_VAR 0 27
63176: PUSH
63177: EMPTY
63178: ST_TO_ADDR
// bombed := [ ] ;
63179: LD_ADDR_VAR 0 28
63183: PUSH
63184: EMPTY
63185: ST_TO_ADDR
// healers := [ ] ;
63186: LD_ADDR_VAR 0 31
63190: PUSH
63191: EMPTY
63192: ST_TO_ADDR
// to_heal := [ ] ;
63193: LD_ADDR_VAR 0 30
63197: PUSH
63198: EMPTY
63199: ST_TO_ADDR
// repairs := [ ] ;
63200: LD_ADDR_VAR 0 33
63204: PUSH
63205: EMPTY
63206: ST_TO_ADDR
// to_repair := [ ] ;
63207: LD_ADDR_VAR 0 32
63211: PUSH
63212: EMPTY
63213: ST_TO_ADDR
// if not group or not path then
63214: LD_VAR 0 4
63218: NOT
63219: PUSH
63220: LD_VAR 0 5
63224: NOT
63225: OR
63226: IFFALSE 63230
// exit ;
63228: GO 67704
// if flags then
63230: LD_VAR 0 6
63234: IFFALSE 63378
// begin f_ignore_area := flags [ 1 ] ;
63236: LD_ADDR_VAR 0 17
63240: PUSH
63241: LD_VAR 0 6
63245: PUSH
63246: LD_INT 1
63248: ARRAY
63249: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
63250: LD_ADDR_VAR 0 18
63254: PUSH
63255: LD_VAR 0 6
63259: PUSH
63260: LD_INT 2
63262: ARRAY
63263: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
63264: LD_ADDR_VAR 0 19
63268: PUSH
63269: LD_VAR 0 6
63273: PUSH
63274: LD_INT 3
63276: ARRAY
63277: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
63278: LD_ADDR_VAR 0 20
63282: PUSH
63283: LD_VAR 0 6
63287: PUSH
63288: LD_INT 4
63290: ARRAY
63291: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
63292: LD_ADDR_VAR 0 21
63296: PUSH
63297: LD_VAR 0 6
63301: PUSH
63302: LD_INT 5
63304: ARRAY
63305: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
63306: LD_ADDR_VAR 0 22
63310: PUSH
63311: LD_VAR 0 6
63315: PUSH
63316: LD_INT 6
63318: ARRAY
63319: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
63320: LD_ADDR_VAR 0 23
63324: PUSH
63325: LD_VAR 0 6
63329: PUSH
63330: LD_INT 7
63332: ARRAY
63333: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
63334: LD_ADDR_VAR 0 24
63338: PUSH
63339: LD_VAR 0 6
63343: PUSH
63344: LD_INT 8
63346: ARRAY
63347: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
63348: LD_ADDR_VAR 0 25
63352: PUSH
63353: LD_VAR 0 6
63357: PUSH
63358: LD_INT 9
63360: ARRAY
63361: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
63362: LD_ADDR_VAR 0 26
63366: PUSH
63367: LD_VAR 0 6
63371: PUSH
63372: LD_INT 10
63374: ARRAY
63375: ST_TO_ADDR
// end else
63376: GO 63458
// begin f_ignore_area := false ;
63378: LD_ADDR_VAR 0 17
63382: PUSH
63383: LD_INT 0
63385: ST_TO_ADDR
// f_capture := false ;
63386: LD_ADDR_VAR 0 18
63390: PUSH
63391: LD_INT 0
63393: ST_TO_ADDR
// f_ignore_civ := false ;
63394: LD_ADDR_VAR 0 19
63398: PUSH
63399: LD_INT 0
63401: ST_TO_ADDR
// f_murder := false ;
63402: LD_ADDR_VAR 0 20
63406: PUSH
63407: LD_INT 0
63409: ST_TO_ADDR
// f_mines := false ;
63410: LD_ADDR_VAR 0 21
63414: PUSH
63415: LD_INT 0
63417: ST_TO_ADDR
// f_repair := false ;
63418: LD_ADDR_VAR 0 22
63422: PUSH
63423: LD_INT 0
63425: ST_TO_ADDR
// f_heal := false ;
63426: LD_ADDR_VAR 0 23
63430: PUSH
63431: LD_INT 0
63433: ST_TO_ADDR
// f_spacetime := false ;
63434: LD_ADDR_VAR 0 24
63438: PUSH
63439: LD_INT 0
63441: ST_TO_ADDR
// f_attack_depot := false ;
63442: LD_ADDR_VAR 0 25
63446: PUSH
63447: LD_INT 0
63449: ST_TO_ADDR
// f_crawl := false ;
63450: LD_ADDR_VAR 0 26
63454: PUSH
63455: LD_INT 0
63457: ST_TO_ADDR
// end ; if f_heal then
63458: LD_VAR 0 23
63462: IFFALSE 63489
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
63464: LD_ADDR_VAR 0 31
63468: PUSH
63469: LD_VAR 0 4
63473: PPUSH
63474: LD_INT 25
63476: PUSH
63477: LD_INT 4
63479: PUSH
63480: EMPTY
63481: LIST
63482: LIST
63483: PPUSH
63484: CALL_OW 72
63488: ST_TO_ADDR
// if f_repair then
63489: LD_VAR 0 22
63493: IFFALSE 63520
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
63495: LD_ADDR_VAR 0 33
63499: PUSH
63500: LD_VAR 0 4
63504: PPUSH
63505: LD_INT 25
63507: PUSH
63508: LD_INT 3
63510: PUSH
63511: EMPTY
63512: LIST
63513: LIST
63514: PPUSH
63515: CALL_OW 72
63519: ST_TO_ADDR
// units_path := [ ] ;
63520: LD_ADDR_VAR 0 16
63524: PUSH
63525: EMPTY
63526: ST_TO_ADDR
// for i = 1 to group do
63527: LD_ADDR_VAR 0 7
63531: PUSH
63532: DOUBLE
63533: LD_INT 1
63535: DEC
63536: ST_TO_ADDR
63537: LD_VAR 0 4
63541: PUSH
63542: FOR_TO
63543: IFFALSE 63572
// units_path := Replace ( units_path , i , path ) ;
63545: LD_ADDR_VAR 0 16
63549: PUSH
63550: LD_VAR 0 16
63554: PPUSH
63555: LD_VAR 0 7
63559: PPUSH
63560: LD_VAR 0 5
63564: PPUSH
63565: CALL_OW 1
63569: ST_TO_ADDR
63570: GO 63542
63572: POP
63573: POP
// repeat for i = group downto 1 do
63574: LD_ADDR_VAR 0 7
63578: PUSH
63579: DOUBLE
63580: LD_VAR 0 4
63584: INC
63585: ST_TO_ADDR
63586: LD_INT 1
63588: PUSH
63589: FOR_DOWNTO
63590: IFFALSE 67686
// begin wait ( 5 ) ;
63592: LD_INT 5
63594: PPUSH
63595: CALL_OW 67
// tmp := [ ] ;
63599: LD_ADDR_VAR 0 14
63603: PUSH
63604: EMPTY
63605: ST_TO_ADDR
// attacking := false ;
63606: LD_ADDR_VAR 0 29
63610: PUSH
63611: LD_INT 0
63613: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
63614: LD_VAR 0 4
63618: PUSH
63619: LD_VAR 0 7
63623: ARRAY
63624: PPUSH
63625: CALL_OW 301
63629: PUSH
63630: LD_VAR 0 4
63634: PUSH
63635: LD_VAR 0 7
63639: ARRAY
63640: NOT
63641: OR
63642: IFFALSE 63751
// begin if GetType ( group [ i ] ) = unit_human then
63644: LD_VAR 0 4
63648: PUSH
63649: LD_VAR 0 7
63653: ARRAY
63654: PPUSH
63655: CALL_OW 247
63659: PUSH
63660: LD_INT 1
63662: EQUAL
63663: IFFALSE 63709
// begin to_heal := to_heal diff group [ i ] ;
63665: LD_ADDR_VAR 0 30
63669: PUSH
63670: LD_VAR 0 30
63674: PUSH
63675: LD_VAR 0 4
63679: PUSH
63680: LD_VAR 0 7
63684: ARRAY
63685: DIFF
63686: ST_TO_ADDR
// healers := healers diff group [ i ] ;
63687: LD_ADDR_VAR 0 31
63691: PUSH
63692: LD_VAR 0 31
63696: PUSH
63697: LD_VAR 0 4
63701: PUSH
63702: LD_VAR 0 7
63706: ARRAY
63707: DIFF
63708: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
63709: LD_ADDR_VAR 0 4
63713: PUSH
63714: LD_VAR 0 4
63718: PPUSH
63719: LD_VAR 0 7
63723: PPUSH
63724: CALL_OW 3
63728: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
63729: LD_ADDR_VAR 0 16
63733: PUSH
63734: LD_VAR 0 16
63738: PPUSH
63739: LD_VAR 0 7
63743: PPUSH
63744: CALL_OW 3
63748: ST_TO_ADDR
// continue ;
63749: GO 63589
// end ; if f_repair then
63751: LD_VAR 0 22
63755: IFFALSE 64244
// begin if GetType ( group [ i ] ) = unit_vehicle then
63757: LD_VAR 0 4
63761: PUSH
63762: LD_VAR 0 7
63766: ARRAY
63767: PPUSH
63768: CALL_OW 247
63772: PUSH
63773: LD_INT 2
63775: EQUAL
63776: IFFALSE 63966
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
63778: LD_VAR 0 4
63782: PUSH
63783: LD_VAR 0 7
63787: ARRAY
63788: PPUSH
63789: CALL_OW 256
63793: PUSH
63794: LD_INT 700
63796: LESS
63797: PUSH
63798: LD_VAR 0 4
63802: PUSH
63803: LD_VAR 0 7
63807: ARRAY
63808: PUSH
63809: LD_VAR 0 32
63813: IN
63814: NOT
63815: AND
63816: IFFALSE 63840
// to_repair := to_repair union group [ i ] ;
63818: LD_ADDR_VAR 0 32
63822: PUSH
63823: LD_VAR 0 32
63827: PUSH
63828: LD_VAR 0 4
63832: PUSH
63833: LD_VAR 0 7
63837: ARRAY
63838: UNION
63839: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
63840: LD_VAR 0 4
63844: PUSH
63845: LD_VAR 0 7
63849: ARRAY
63850: PPUSH
63851: CALL_OW 256
63855: PUSH
63856: LD_INT 1000
63858: EQUAL
63859: PUSH
63860: LD_VAR 0 4
63864: PUSH
63865: LD_VAR 0 7
63869: ARRAY
63870: PUSH
63871: LD_VAR 0 32
63875: IN
63876: AND
63877: IFFALSE 63901
// to_repair := to_repair diff group [ i ] ;
63879: LD_ADDR_VAR 0 32
63883: PUSH
63884: LD_VAR 0 32
63888: PUSH
63889: LD_VAR 0 4
63893: PUSH
63894: LD_VAR 0 7
63898: ARRAY
63899: DIFF
63900: ST_TO_ADDR
// if group [ i ] in to_repair then
63901: LD_VAR 0 4
63905: PUSH
63906: LD_VAR 0 7
63910: ARRAY
63911: PUSH
63912: LD_VAR 0 32
63916: IN
63917: IFFALSE 63964
// begin if not IsInArea ( group [ i ] , f_repair ) then
63919: LD_VAR 0 4
63923: PUSH
63924: LD_VAR 0 7
63928: ARRAY
63929: PPUSH
63930: LD_VAR 0 22
63934: PPUSH
63935: CALL_OW 308
63939: NOT
63940: IFFALSE 63962
// ComMoveToArea ( group [ i ] , f_repair ) ;
63942: LD_VAR 0 4
63946: PUSH
63947: LD_VAR 0 7
63951: ARRAY
63952: PPUSH
63953: LD_VAR 0 22
63957: PPUSH
63958: CALL_OW 113
// continue ;
63962: GO 63589
// end ; end else
63964: GO 64244
// if group [ i ] in repairs then
63966: LD_VAR 0 4
63970: PUSH
63971: LD_VAR 0 7
63975: ARRAY
63976: PUSH
63977: LD_VAR 0 33
63981: IN
63982: IFFALSE 64244
// begin if IsInUnit ( group [ i ] ) then
63984: LD_VAR 0 4
63988: PUSH
63989: LD_VAR 0 7
63993: ARRAY
63994: PPUSH
63995: CALL_OW 310
63999: IFFALSE 64067
// begin z := IsInUnit ( group [ i ] ) ;
64001: LD_ADDR_VAR 0 13
64005: PUSH
64006: LD_VAR 0 4
64010: PUSH
64011: LD_VAR 0 7
64015: ARRAY
64016: PPUSH
64017: CALL_OW 310
64021: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
64022: LD_VAR 0 13
64026: PUSH
64027: LD_VAR 0 32
64031: IN
64032: PUSH
64033: LD_VAR 0 13
64037: PPUSH
64038: LD_VAR 0 22
64042: PPUSH
64043: CALL_OW 308
64047: AND
64048: IFFALSE 64065
// ComExitVehicle ( group [ i ] ) ;
64050: LD_VAR 0 4
64054: PUSH
64055: LD_VAR 0 7
64059: ARRAY
64060: PPUSH
64061: CALL_OW 121
// end else
64065: GO 64244
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
64067: LD_ADDR_VAR 0 13
64071: PUSH
64072: LD_VAR 0 4
64076: PPUSH
64077: LD_INT 95
64079: PUSH
64080: LD_VAR 0 22
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 58
64091: PUSH
64092: EMPTY
64093: LIST
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PPUSH
64099: CALL_OW 72
64103: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
64104: LD_VAR 0 4
64108: PUSH
64109: LD_VAR 0 7
64113: ARRAY
64114: PPUSH
64115: CALL_OW 314
64119: NOT
64120: IFFALSE 64242
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
64122: LD_ADDR_VAR 0 10
64126: PUSH
64127: LD_VAR 0 13
64131: PPUSH
64132: LD_VAR 0 4
64136: PUSH
64137: LD_VAR 0 7
64141: ARRAY
64142: PPUSH
64143: CALL_OW 74
64147: ST_TO_ADDR
// if not x then
64148: LD_VAR 0 10
64152: NOT
64153: IFFALSE 64157
// continue ;
64155: GO 63589
// if GetLives ( x ) < 1000 then
64157: LD_VAR 0 10
64161: PPUSH
64162: CALL_OW 256
64166: PUSH
64167: LD_INT 1000
64169: LESS
64170: IFFALSE 64194
// ComRepairVehicle ( group [ i ] , x ) else
64172: LD_VAR 0 4
64176: PUSH
64177: LD_VAR 0 7
64181: ARRAY
64182: PPUSH
64183: LD_VAR 0 10
64187: PPUSH
64188: CALL_OW 129
64192: GO 64242
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
64194: LD_VAR 0 23
64198: PUSH
64199: LD_VAR 0 4
64203: PUSH
64204: LD_VAR 0 7
64208: ARRAY
64209: PPUSH
64210: CALL_OW 256
64214: PUSH
64215: LD_INT 1000
64217: LESS
64218: AND
64219: NOT
64220: IFFALSE 64242
// ComEnterUnit ( group [ i ] , x ) ;
64222: LD_VAR 0 4
64226: PUSH
64227: LD_VAR 0 7
64231: ARRAY
64232: PPUSH
64233: LD_VAR 0 10
64237: PPUSH
64238: CALL_OW 120
// end ; continue ;
64242: GO 63589
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
64244: LD_VAR 0 23
64248: PUSH
64249: LD_VAR 0 4
64253: PUSH
64254: LD_VAR 0 7
64258: ARRAY
64259: PPUSH
64260: CALL_OW 247
64264: PUSH
64265: LD_INT 1
64267: EQUAL
64268: AND
64269: IFFALSE 64747
// begin if group [ i ] in healers then
64271: LD_VAR 0 4
64275: PUSH
64276: LD_VAR 0 7
64280: ARRAY
64281: PUSH
64282: LD_VAR 0 31
64286: IN
64287: IFFALSE 64560
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
64289: LD_VAR 0 4
64293: PUSH
64294: LD_VAR 0 7
64298: ARRAY
64299: PPUSH
64300: LD_VAR 0 23
64304: PPUSH
64305: CALL_OW 308
64309: NOT
64310: PUSH
64311: LD_VAR 0 4
64315: PUSH
64316: LD_VAR 0 7
64320: ARRAY
64321: PPUSH
64322: CALL_OW 314
64326: NOT
64327: AND
64328: IFFALSE 64352
// ComMoveToArea ( group [ i ] , f_heal ) else
64330: LD_VAR 0 4
64334: PUSH
64335: LD_VAR 0 7
64339: ARRAY
64340: PPUSH
64341: LD_VAR 0 23
64345: PPUSH
64346: CALL_OW 113
64350: GO 64558
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
64352: LD_VAR 0 4
64356: PUSH
64357: LD_VAR 0 7
64361: ARRAY
64362: PPUSH
64363: CALL 62990 0 1
64367: PPUSH
64368: CALL_OW 256
64372: PUSH
64373: LD_INT 1000
64375: EQUAL
64376: IFFALSE 64395
// ComStop ( group [ i ] ) else
64378: LD_VAR 0 4
64382: PUSH
64383: LD_VAR 0 7
64387: ARRAY
64388: PPUSH
64389: CALL_OW 141
64393: GO 64558
// if not HasTask ( group [ i ] ) and to_heal then
64395: LD_VAR 0 4
64399: PUSH
64400: LD_VAR 0 7
64404: ARRAY
64405: PPUSH
64406: CALL_OW 314
64410: NOT
64411: PUSH
64412: LD_VAR 0 30
64416: AND
64417: IFFALSE 64558
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
64419: LD_ADDR_VAR 0 13
64423: PUSH
64424: LD_VAR 0 30
64428: PPUSH
64429: LD_INT 3
64431: PUSH
64432: LD_INT 54
64434: PUSH
64435: EMPTY
64436: LIST
64437: PUSH
64438: EMPTY
64439: LIST
64440: LIST
64441: PPUSH
64442: CALL_OW 72
64446: PPUSH
64447: LD_VAR 0 4
64451: PUSH
64452: LD_VAR 0 7
64456: ARRAY
64457: PPUSH
64458: CALL_OW 74
64462: ST_TO_ADDR
// if z then
64463: LD_VAR 0 13
64467: IFFALSE 64558
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
64469: LD_INT 91
64471: PUSH
64472: LD_VAR 0 13
64476: PUSH
64477: LD_INT 10
64479: PUSH
64480: EMPTY
64481: LIST
64482: LIST
64483: LIST
64484: PUSH
64485: LD_INT 81
64487: PUSH
64488: LD_VAR 0 13
64492: PPUSH
64493: CALL_OW 255
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: EMPTY
64503: LIST
64504: LIST
64505: PPUSH
64506: CALL_OW 69
64510: PUSH
64511: LD_INT 0
64513: EQUAL
64514: IFFALSE 64538
// ComHeal ( group [ i ] , z ) else
64516: LD_VAR 0 4
64520: PUSH
64521: LD_VAR 0 7
64525: ARRAY
64526: PPUSH
64527: LD_VAR 0 13
64531: PPUSH
64532: CALL_OW 128
64536: GO 64558
// ComMoveToArea ( group [ i ] , f_heal ) ;
64538: LD_VAR 0 4
64542: PUSH
64543: LD_VAR 0 7
64547: ARRAY
64548: PPUSH
64549: LD_VAR 0 23
64553: PPUSH
64554: CALL_OW 113
// end ; continue ;
64558: GO 63589
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
64560: LD_VAR 0 4
64564: PUSH
64565: LD_VAR 0 7
64569: ARRAY
64570: PPUSH
64571: CALL_OW 256
64575: PUSH
64576: LD_INT 700
64578: LESS
64579: PUSH
64580: LD_VAR 0 4
64584: PUSH
64585: LD_VAR 0 7
64589: ARRAY
64590: PUSH
64591: LD_VAR 0 30
64595: IN
64596: NOT
64597: AND
64598: IFFALSE 64622
// to_heal := to_heal union group [ i ] ;
64600: LD_ADDR_VAR 0 30
64604: PUSH
64605: LD_VAR 0 30
64609: PUSH
64610: LD_VAR 0 4
64614: PUSH
64615: LD_VAR 0 7
64619: ARRAY
64620: UNION
64621: ST_TO_ADDR
// if group [ i ] in to_heal then
64622: LD_VAR 0 4
64626: PUSH
64627: LD_VAR 0 7
64631: ARRAY
64632: PUSH
64633: LD_VAR 0 30
64637: IN
64638: IFFALSE 64747
// begin if GetLives ( group [ i ] ) = 1000 then
64640: LD_VAR 0 4
64644: PUSH
64645: LD_VAR 0 7
64649: ARRAY
64650: PPUSH
64651: CALL_OW 256
64655: PUSH
64656: LD_INT 1000
64658: EQUAL
64659: IFFALSE 64685
// to_heal := to_heal diff group [ i ] else
64661: LD_ADDR_VAR 0 30
64665: PUSH
64666: LD_VAR 0 30
64670: PUSH
64671: LD_VAR 0 4
64675: PUSH
64676: LD_VAR 0 7
64680: ARRAY
64681: DIFF
64682: ST_TO_ADDR
64683: GO 64747
// begin if not IsInArea ( group [ i ] , to_heal ) then
64685: LD_VAR 0 4
64689: PUSH
64690: LD_VAR 0 7
64694: ARRAY
64695: PPUSH
64696: LD_VAR 0 30
64700: PPUSH
64701: CALL_OW 308
64705: NOT
64706: IFFALSE 64730
// ComMoveToArea ( group [ i ] , f_heal ) else
64708: LD_VAR 0 4
64712: PUSH
64713: LD_VAR 0 7
64717: ARRAY
64718: PPUSH
64719: LD_VAR 0 23
64723: PPUSH
64724: CALL_OW 113
64728: GO 64745
// ComHold ( group [ i ] ) ;
64730: LD_VAR 0 4
64734: PUSH
64735: LD_VAR 0 7
64739: ARRAY
64740: PPUSH
64741: CALL_OW 140
// continue ;
64745: GO 63589
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
64747: LD_VAR 0 4
64751: PUSH
64752: LD_VAR 0 7
64756: ARRAY
64757: PPUSH
64758: LD_INT 10
64760: PPUSH
64761: CALL 61387 0 2
64765: NOT
64766: PUSH
64767: LD_VAR 0 16
64771: PUSH
64772: LD_VAR 0 7
64776: ARRAY
64777: PUSH
64778: EMPTY
64779: EQUAL
64780: NOT
64781: AND
64782: IFFALSE 65048
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
64784: LD_VAR 0 4
64788: PUSH
64789: LD_VAR 0 7
64793: ARRAY
64794: PPUSH
64795: CALL_OW 262
64799: PUSH
64800: LD_INT 1
64802: PUSH
64803: LD_INT 2
64805: PUSH
64806: EMPTY
64807: LIST
64808: LIST
64809: IN
64810: IFFALSE 64851
// if GetFuel ( group [ i ] ) < 10 then
64812: LD_VAR 0 4
64816: PUSH
64817: LD_VAR 0 7
64821: ARRAY
64822: PPUSH
64823: CALL_OW 261
64827: PUSH
64828: LD_INT 10
64830: LESS
64831: IFFALSE 64851
// SetFuel ( group [ i ] , 12 ) ;
64833: LD_VAR 0 4
64837: PUSH
64838: LD_VAR 0 7
64842: ARRAY
64843: PPUSH
64844: LD_INT 12
64846: PPUSH
64847: CALL_OW 240
// if units_path [ i ] then
64851: LD_VAR 0 16
64855: PUSH
64856: LD_VAR 0 7
64860: ARRAY
64861: IFFALSE 65046
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
64863: LD_VAR 0 4
64867: PUSH
64868: LD_VAR 0 7
64872: ARRAY
64873: PPUSH
64874: LD_VAR 0 16
64878: PUSH
64879: LD_VAR 0 7
64883: ARRAY
64884: PUSH
64885: LD_INT 1
64887: ARRAY
64888: PUSH
64889: LD_INT 1
64891: ARRAY
64892: PPUSH
64893: LD_VAR 0 16
64897: PUSH
64898: LD_VAR 0 7
64902: ARRAY
64903: PUSH
64904: LD_INT 1
64906: ARRAY
64907: PUSH
64908: LD_INT 2
64910: ARRAY
64911: PPUSH
64912: CALL_OW 297
64916: PUSH
64917: LD_INT 6
64919: GREATER
64920: IFFALSE 64995
// begin if not HasTask ( group [ i ] ) then
64922: LD_VAR 0 4
64926: PUSH
64927: LD_VAR 0 7
64931: ARRAY
64932: PPUSH
64933: CALL_OW 314
64937: NOT
64938: IFFALSE 64993
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
64940: LD_VAR 0 4
64944: PUSH
64945: LD_VAR 0 7
64949: ARRAY
64950: PPUSH
64951: LD_VAR 0 16
64955: PUSH
64956: LD_VAR 0 7
64960: ARRAY
64961: PUSH
64962: LD_INT 1
64964: ARRAY
64965: PUSH
64966: LD_INT 1
64968: ARRAY
64969: PPUSH
64970: LD_VAR 0 16
64974: PUSH
64975: LD_VAR 0 7
64979: ARRAY
64980: PUSH
64981: LD_INT 1
64983: ARRAY
64984: PUSH
64985: LD_INT 2
64987: ARRAY
64988: PPUSH
64989: CALL_OW 114
// end else
64993: GO 65046
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
64995: LD_ADDR_VAR 0 15
64999: PUSH
65000: LD_VAR 0 16
65004: PUSH
65005: LD_VAR 0 7
65009: ARRAY
65010: PPUSH
65011: LD_INT 1
65013: PPUSH
65014: CALL_OW 3
65018: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
65019: LD_ADDR_VAR 0 16
65023: PUSH
65024: LD_VAR 0 16
65028: PPUSH
65029: LD_VAR 0 7
65033: PPUSH
65034: LD_VAR 0 15
65038: PPUSH
65039: CALL_OW 1
65043: ST_TO_ADDR
// continue ;
65044: GO 63589
// end ; end ; end else
65046: GO 67684
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
65048: LD_ADDR_VAR 0 14
65052: PUSH
65053: LD_INT 81
65055: PUSH
65056: LD_VAR 0 4
65060: PUSH
65061: LD_VAR 0 7
65065: ARRAY
65066: PPUSH
65067: CALL_OW 255
65071: PUSH
65072: EMPTY
65073: LIST
65074: LIST
65075: PPUSH
65076: CALL_OW 69
65080: ST_TO_ADDR
// if not tmp then
65081: LD_VAR 0 14
65085: NOT
65086: IFFALSE 65090
// continue ;
65088: GO 63589
// if f_ignore_area then
65090: LD_VAR 0 17
65094: IFFALSE 65182
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
65096: LD_ADDR_VAR 0 15
65100: PUSH
65101: LD_VAR 0 14
65105: PPUSH
65106: LD_INT 3
65108: PUSH
65109: LD_INT 92
65111: PUSH
65112: LD_VAR 0 17
65116: PUSH
65117: LD_INT 1
65119: ARRAY
65120: PUSH
65121: LD_VAR 0 17
65125: PUSH
65126: LD_INT 2
65128: ARRAY
65129: PUSH
65130: LD_VAR 0 17
65134: PUSH
65135: LD_INT 3
65137: ARRAY
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: PPUSH
65149: CALL_OW 72
65153: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
65154: LD_VAR 0 14
65158: PUSH
65159: LD_VAR 0 15
65163: DIFF
65164: IFFALSE 65182
// tmp := tmp diff tmp2 ;
65166: LD_ADDR_VAR 0 14
65170: PUSH
65171: LD_VAR 0 14
65175: PUSH
65176: LD_VAR 0 15
65180: DIFF
65181: ST_TO_ADDR
// end ; if not f_murder then
65182: LD_VAR 0 20
65186: NOT
65187: IFFALSE 65245
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
65189: LD_ADDR_VAR 0 15
65193: PUSH
65194: LD_VAR 0 14
65198: PPUSH
65199: LD_INT 3
65201: PUSH
65202: LD_INT 50
65204: PUSH
65205: EMPTY
65206: LIST
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PPUSH
65212: CALL_OW 72
65216: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
65217: LD_VAR 0 14
65221: PUSH
65222: LD_VAR 0 15
65226: DIFF
65227: IFFALSE 65245
// tmp := tmp diff tmp2 ;
65229: LD_ADDR_VAR 0 14
65233: PUSH
65234: LD_VAR 0 14
65238: PUSH
65239: LD_VAR 0 15
65243: DIFF
65244: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
65245: LD_ADDR_VAR 0 14
65249: PUSH
65250: LD_VAR 0 4
65254: PUSH
65255: LD_VAR 0 7
65259: ARRAY
65260: PPUSH
65261: LD_VAR 0 14
65265: PPUSH
65266: LD_INT 1
65268: PPUSH
65269: LD_INT 1
65271: PPUSH
65272: CALL 35241 0 4
65276: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
65277: LD_VAR 0 4
65281: PUSH
65282: LD_VAR 0 7
65286: ARRAY
65287: PPUSH
65288: CALL_OW 257
65292: PUSH
65293: LD_INT 1
65295: EQUAL
65296: IFFALSE 65744
// begin if WantPlant ( group [ i ] ) then
65298: LD_VAR 0 4
65302: PUSH
65303: LD_VAR 0 7
65307: ARRAY
65308: PPUSH
65309: CALL 34709 0 1
65313: IFFALSE 65317
// continue ;
65315: GO 63589
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
65317: LD_VAR 0 18
65321: PUSH
65322: LD_VAR 0 4
65326: PUSH
65327: LD_VAR 0 7
65331: ARRAY
65332: PPUSH
65333: CALL_OW 310
65337: NOT
65338: AND
65339: PUSH
65340: LD_VAR 0 14
65344: PUSH
65345: LD_INT 1
65347: ARRAY
65348: PUSH
65349: LD_VAR 0 14
65353: PPUSH
65354: LD_INT 21
65356: PUSH
65357: LD_INT 2
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: LD_INT 58
65366: PUSH
65367: EMPTY
65368: LIST
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PPUSH
65374: CALL_OW 72
65378: IN
65379: AND
65380: IFFALSE 65416
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
65382: LD_VAR 0 4
65386: PUSH
65387: LD_VAR 0 7
65391: ARRAY
65392: PPUSH
65393: LD_VAR 0 14
65397: PUSH
65398: LD_INT 1
65400: ARRAY
65401: PPUSH
65402: CALL_OW 120
// attacking := true ;
65406: LD_ADDR_VAR 0 29
65410: PUSH
65411: LD_INT 1
65413: ST_TO_ADDR
// continue ;
65414: GO 63589
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
65416: LD_VAR 0 26
65420: PUSH
65421: LD_VAR 0 4
65425: PUSH
65426: LD_VAR 0 7
65430: ARRAY
65431: PPUSH
65432: CALL_OW 257
65436: PUSH
65437: LD_INT 1
65439: EQUAL
65440: AND
65441: PUSH
65442: LD_VAR 0 4
65446: PUSH
65447: LD_VAR 0 7
65451: ARRAY
65452: PPUSH
65453: CALL_OW 256
65457: PUSH
65458: LD_INT 800
65460: LESS
65461: AND
65462: PUSH
65463: LD_VAR 0 4
65467: PUSH
65468: LD_VAR 0 7
65472: ARRAY
65473: PPUSH
65474: CALL_OW 318
65478: NOT
65479: AND
65480: IFFALSE 65497
// ComCrawl ( group [ i ] ) ;
65482: LD_VAR 0 4
65486: PUSH
65487: LD_VAR 0 7
65491: ARRAY
65492: PPUSH
65493: CALL_OW 137
// if f_mines then
65497: LD_VAR 0 21
65501: IFFALSE 65744
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
65503: LD_VAR 0 14
65507: PUSH
65508: LD_INT 1
65510: ARRAY
65511: PPUSH
65512: CALL_OW 247
65516: PUSH
65517: LD_INT 3
65519: EQUAL
65520: PUSH
65521: LD_VAR 0 14
65525: PUSH
65526: LD_INT 1
65528: ARRAY
65529: PUSH
65530: LD_VAR 0 27
65534: IN
65535: NOT
65536: AND
65537: IFFALSE 65744
// begin x := GetX ( tmp [ 1 ] ) ;
65539: LD_ADDR_VAR 0 10
65543: PUSH
65544: LD_VAR 0 14
65548: PUSH
65549: LD_INT 1
65551: ARRAY
65552: PPUSH
65553: CALL_OW 250
65557: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
65558: LD_ADDR_VAR 0 11
65562: PUSH
65563: LD_VAR 0 14
65567: PUSH
65568: LD_INT 1
65570: ARRAY
65571: PPUSH
65572: CALL_OW 251
65576: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
65577: LD_ADDR_VAR 0 12
65581: PUSH
65582: LD_VAR 0 4
65586: PUSH
65587: LD_VAR 0 7
65591: ARRAY
65592: PPUSH
65593: CALL 61472 0 1
65597: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
65598: LD_VAR 0 4
65602: PUSH
65603: LD_VAR 0 7
65607: ARRAY
65608: PPUSH
65609: LD_VAR 0 10
65613: PPUSH
65614: LD_VAR 0 11
65618: PPUSH
65619: LD_VAR 0 14
65623: PUSH
65624: LD_INT 1
65626: ARRAY
65627: PPUSH
65628: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
65632: LD_VAR 0 4
65636: PUSH
65637: LD_VAR 0 7
65641: ARRAY
65642: PPUSH
65643: LD_VAR 0 10
65647: PPUSH
65648: LD_VAR 0 12
65652: PPUSH
65653: LD_INT 7
65655: PPUSH
65656: CALL_OW 272
65660: PPUSH
65661: LD_VAR 0 11
65665: PPUSH
65666: LD_VAR 0 12
65670: PPUSH
65671: LD_INT 7
65673: PPUSH
65674: CALL_OW 273
65678: PPUSH
65679: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
65683: LD_VAR 0 4
65687: PUSH
65688: LD_VAR 0 7
65692: ARRAY
65693: PPUSH
65694: LD_INT 71
65696: PPUSH
65697: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
65701: LD_ADDR_VAR 0 27
65705: PUSH
65706: LD_VAR 0 27
65710: PPUSH
65711: LD_VAR 0 27
65715: PUSH
65716: LD_INT 1
65718: PLUS
65719: PPUSH
65720: LD_VAR 0 14
65724: PUSH
65725: LD_INT 1
65727: ARRAY
65728: PPUSH
65729: CALL_OW 1
65733: ST_TO_ADDR
// attacking := true ;
65734: LD_ADDR_VAR 0 29
65738: PUSH
65739: LD_INT 1
65741: ST_TO_ADDR
// continue ;
65742: GO 63589
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
65744: LD_VAR 0 4
65748: PUSH
65749: LD_VAR 0 7
65753: ARRAY
65754: PPUSH
65755: CALL_OW 257
65759: PUSH
65760: LD_INT 17
65762: EQUAL
65763: PUSH
65764: LD_VAR 0 4
65768: PUSH
65769: LD_VAR 0 7
65773: ARRAY
65774: PPUSH
65775: CALL_OW 110
65779: PUSH
65780: LD_INT 71
65782: EQUAL
65783: NOT
65784: AND
65785: IFFALSE 65931
// begin attacking := false ;
65787: LD_ADDR_VAR 0 29
65791: PUSH
65792: LD_INT 0
65794: ST_TO_ADDR
// k := 5 ;
65795: LD_ADDR_VAR 0 9
65799: PUSH
65800: LD_INT 5
65802: ST_TO_ADDR
// if tmp < k then
65803: LD_VAR 0 14
65807: PUSH
65808: LD_VAR 0 9
65812: LESS
65813: IFFALSE 65825
// k := tmp ;
65815: LD_ADDR_VAR 0 9
65819: PUSH
65820: LD_VAR 0 14
65824: ST_TO_ADDR
// for j = 1 to k do
65825: LD_ADDR_VAR 0 8
65829: PUSH
65830: DOUBLE
65831: LD_INT 1
65833: DEC
65834: ST_TO_ADDR
65835: LD_VAR 0 9
65839: PUSH
65840: FOR_TO
65841: IFFALSE 65929
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
65843: LD_VAR 0 14
65847: PUSH
65848: LD_VAR 0 8
65852: ARRAY
65853: PUSH
65854: LD_VAR 0 14
65858: PPUSH
65859: LD_INT 58
65861: PUSH
65862: EMPTY
65863: LIST
65864: PPUSH
65865: CALL_OW 72
65869: IN
65870: NOT
65871: IFFALSE 65927
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
65873: LD_VAR 0 4
65877: PUSH
65878: LD_VAR 0 7
65882: ARRAY
65883: PPUSH
65884: LD_VAR 0 14
65888: PUSH
65889: LD_VAR 0 8
65893: ARRAY
65894: PPUSH
65895: CALL_OW 115
// attacking := true ;
65899: LD_ADDR_VAR 0 29
65903: PUSH
65904: LD_INT 1
65906: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
65907: LD_VAR 0 4
65911: PUSH
65912: LD_VAR 0 7
65916: ARRAY
65917: PPUSH
65918: LD_INT 71
65920: PPUSH
65921: CALL_OW 109
// continue ;
65925: GO 65840
// end ; end ;
65927: GO 65840
65929: POP
65930: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
65931: LD_VAR 0 4
65935: PUSH
65936: LD_VAR 0 7
65940: ARRAY
65941: PPUSH
65942: CALL_OW 257
65946: PUSH
65947: LD_INT 8
65949: EQUAL
65950: PUSH
65951: LD_VAR 0 4
65955: PUSH
65956: LD_VAR 0 7
65960: ARRAY
65961: PPUSH
65962: CALL_OW 264
65966: PUSH
65967: LD_INT 28
65969: PUSH
65970: LD_INT 45
65972: PUSH
65973: LD_INT 7
65975: PUSH
65976: LD_INT 47
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: IN
65985: OR
65986: IFFALSE 66216
// begin attacking := false ;
65988: LD_ADDR_VAR 0 29
65992: PUSH
65993: LD_INT 0
65995: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
65996: LD_VAR 0 14
66000: PUSH
66001: LD_INT 1
66003: ARRAY
66004: PPUSH
66005: CALL_OW 266
66009: PUSH
66010: LD_INT 32
66012: PUSH
66013: LD_INT 31
66015: PUSH
66016: LD_INT 33
66018: PUSH
66019: LD_INT 4
66021: PUSH
66022: LD_INT 5
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: LIST
66029: LIST
66030: LIST
66031: IN
66032: IFFALSE 66216
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
66034: LD_ADDR_VAR 0 9
66038: PUSH
66039: LD_VAR 0 14
66043: PUSH
66044: LD_INT 1
66046: ARRAY
66047: PPUSH
66048: CALL_OW 266
66052: PPUSH
66053: LD_VAR 0 14
66057: PUSH
66058: LD_INT 1
66060: ARRAY
66061: PPUSH
66062: CALL_OW 250
66066: PPUSH
66067: LD_VAR 0 14
66071: PUSH
66072: LD_INT 1
66074: ARRAY
66075: PPUSH
66076: CALL_OW 251
66080: PPUSH
66081: LD_VAR 0 14
66085: PUSH
66086: LD_INT 1
66088: ARRAY
66089: PPUSH
66090: CALL_OW 254
66094: PPUSH
66095: LD_VAR 0 14
66099: PUSH
66100: LD_INT 1
66102: ARRAY
66103: PPUSH
66104: CALL_OW 248
66108: PPUSH
66109: LD_INT 0
66111: PPUSH
66112: CALL 42848 0 6
66116: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
66117: LD_ADDR_VAR 0 8
66121: PUSH
66122: LD_VAR 0 4
66126: PUSH
66127: LD_VAR 0 7
66131: ARRAY
66132: PPUSH
66133: LD_VAR 0 9
66137: PPUSH
66138: CALL 61535 0 2
66142: ST_TO_ADDR
// if j then
66143: LD_VAR 0 8
66147: IFFALSE 66216
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
66149: LD_VAR 0 8
66153: PUSH
66154: LD_INT 1
66156: ARRAY
66157: PPUSH
66158: LD_VAR 0 8
66162: PUSH
66163: LD_INT 2
66165: ARRAY
66166: PPUSH
66167: CALL_OW 488
66171: IFFALSE 66216
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
66173: LD_VAR 0 4
66177: PUSH
66178: LD_VAR 0 7
66182: ARRAY
66183: PPUSH
66184: LD_VAR 0 8
66188: PUSH
66189: LD_INT 1
66191: ARRAY
66192: PPUSH
66193: LD_VAR 0 8
66197: PUSH
66198: LD_INT 2
66200: ARRAY
66201: PPUSH
66202: CALL_OW 116
// attacking := true ;
66206: LD_ADDR_VAR 0 29
66210: PUSH
66211: LD_INT 1
66213: ST_TO_ADDR
// continue ;
66214: GO 63589
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
66216: LD_VAR 0 4
66220: PUSH
66221: LD_VAR 0 7
66225: ARRAY
66226: PPUSH
66227: CALL_OW 265
66231: PUSH
66232: LD_INT 11
66234: EQUAL
66235: IFFALSE 66513
// begin k := 10 ;
66237: LD_ADDR_VAR 0 9
66241: PUSH
66242: LD_INT 10
66244: ST_TO_ADDR
// x := 0 ;
66245: LD_ADDR_VAR 0 10
66249: PUSH
66250: LD_INT 0
66252: ST_TO_ADDR
// if tmp < k then
66253: LD_VAR 0 14
66257: PUSH
66258: LD_VAR 0 9
66262: LESS
66263: IFFALSE 66275
// k := tmp ;
66265: LD_ADDR_VAR 0 9
66269: PUSH
66270: LD_VAR 0 14
66274: ST_TO_ADDR
// for j = k downto 1 do
66275: LD_ADDR_VAR 0 8
66279: PUSH
66280: DOUBLE
66281: LD_VAR 0 9
66285: INC
66286: ST_TO_ADDR
66287: LD_INT 1
66289: PUSH
66290: FOR_DOWNTO
66291: IFFALSE 66366
// begin if GetType ( tmp [ j ] ) = unit_human then
66293: LD_VAR 0 14
66297: PUSH
66298: LD_VAR 0 8
66302: ARRAY
66303: PPUSH
66304: CALL_OW 247
66308: PUSH
66309: LD_INT 1
66311: EQUAL
66312: IFFALSE 66364
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
66314: LD_VAR 0 4
66318: PUSH
66319: LD_VAR 0 7
66323: ARRAY
66324: PPUSH
66325: LD_VAR 0 14
66329: PUSH
66330: LD_VAR 0 8
66334: ARRAY
66335: PPUSH
66336: CALL 61806 0 2
// x := tmp [ j ] ;
66340: LD_ADDR_VAR 0 10
66344: PUSH
66345: LD_VAR 0 14
66349: PUSH
66350: LD_VAR 0 8
66354: ARRAY
66355: ST_TO_ADDR
// attacking := true ;
66356: LD_ADDR_VAR 0 29
66360: PUSH
66361: LD_INT 1
66363: ST_TO_ADDR
// end ; end ;
66364: GO 66290
66366: POP
66367: POP
// if not x then
66368: LD_VAR 0 10
66372: NOT
66373: IFFALSE 66513
// begin attacking := true ;
66375: LD_ADDR_VAR 0 29
66379: PUSH
66380: LD_INT 1
66382: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
66383: LD_VAR 0 4
66387: PUSH
66388: LD_VAR 0 7
66392: ARRAY
66393: PPUSH
66394: CALL_OW 250
66398: PPUSH
66399: LD_VAR 0 4
66403: PUSH
66404: LD_VAR 0 7
66408: ARRAY
66409: PPUSH
66410: CALL_OW 251
66414: PPUSH
66415: CALL_OW 546
66419: PUSH
66420: LD_INT 2
66422: ARRAY
66423: PUSH
66424: LD_VAR 0 14
66428: PUSH
66429: LD_INT 1
66431: ARRAY
66432: PPUSH
66433: CALL_OW 250
66437: PPUSH
66438: LD_VAR 0 14
66442: PUSH
66443: LD_INT 1
66445: ARRAY
66446: PPUSH
66447: CALL_OW 251
66451: PPUSH
66452: CALL_OW 546
66456: PUSH
66457: LD_INT 2
66459: ARRAY
66460: EQUAL
66461: IFFALSE 66489
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
66463: LD_VAR 0 4
66467: PUSH
66468: LD_VAR 0 7
66472: ARRAY
66473: PPUSH
66474: LD_VAR 0 14
66478: PUSH
66479: LD_INT 1
66481: ARRAY
66482: PPUSH
66483: CALL 61806 0 2
66487: GO 66513
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
66489: LD_VAR 0 4
66493: PUSH
66494: LD_VAR 0 7
66498: ARRAY
66499: PPUSH
66500: LD_VAR 0 14
66504: PUSH
66505: LD_INT 1
66507: ARRAY
66508: PPUSH
66509: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
66513: LD_VAR 0 4
66517: PUSH
66518: LD_VAR 0 7
66522: ARRAY
66523: PPUSH
66524: CALL_OW 264
66528: PUSH
66529: LD_INT 29
66531: EQUAL
66532: IFFALSE 66898
// begin if WantsToAttack ( group [ i ] ) in bombed then
66534: LD_VAR 0 4
66538: PUSH
66539: LD_VAR 0 7
66543: ARRAY
66544: PPUSH
66545: CALL_OW 319
66549: PUSH
66550: LD_VAR 0 28
66554: IN
66555: IFFALSE 66559
// continue ;
66557: GO 63589
// k := 8 ;
66559: LD_ADDR_VAR 0 9
66563: PUSH
66564: LD_INT 8
66566: ST_TO_ADDR
// x := 0 ;
66567: LD_ADDR_VAR 0 10
66571: PUSH
66572: LD_INT 0
66574: ST_TO_ADDR
// if tmp < k then
66575: LD_VAR 0 14
66579: PUSH
66580: LD_VAR 0 9
66584: LESS
66585: IFFALSE 66597
// k := tmp ;
66587: LD_ADDR_VAR 0 9
66591: PUSH
66592: LD_VAR 0 14
66596: ST_TO_ADDR
// for j = 1 to k do
66597: LD_ADDR_VAR 0 8
66601: PUSH
66602: DOUBLE
66603: LD_INT 1
66605: DEC
66606: ST_TO_ADDR
66607: LD_VAR 0 9
66611: PUSH
66612: FOR_TO
66613: IFFALSE 66745
// begin if GetType ( tmp [ j ] ) = unit_building then
66615: LD_VAR 0 14
66619: PUSH
66620: LD_VAR 0 8
66624: ARRAY
66625: PPUSH
66626: CALL_OW 247
66630: PUSH
66631: LD_INT 3
66633: EQUAL
66634: IFFALSE 66743
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
66636: LD_VAR 0 14
66640: PUSH
66641: LD_VAR 0 8
66645: ARRAY
66646: PUSH
66647: LD_VAR 0 28
66651: IN
66652: NOT
66653: PUSH
66654: LD_VAR 0 14
66658: PUSH
66659: LD_VAR 0 8
66663: ARRAY
66664: PPUSH
66665: CALL_OW 313
66669: AND
66670: IFFALSE 66743
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
66672: LD_VAR 0 4
66676: PUSH
66677: LD_VAR 0 7
66681: ARRAY
66682: PPUSH
66683: LD_VAR 0 14
66687: PUSH
66688: LD_VAR 0 8
66692: ARRAY
66693: PPUSH
66694: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
66698: LD_ADDR_VAR 0 28
66702: PUSH
66703: LD_VAR 0 28
66707: PPUSH
66708: LD_VAR 0 28
66712: PUSH
66713: LD_INT 1
66715: PLUS
66716: PPUSH
66717: LD_VAR 0 14
66721: PUSH
66722: LD_VAR 0 8
66726: ARRAY
66727: PPUSH
66728: CALL_OW 1
66732: ST_TO_ADDR
// attacking := true ;
66733: LD_ADDR_VAR 0 29
66737: PUSH
66738: LD_INT 1
66740: ST_TO_ADDR
// break ;
66741: GO 66745
// end ; end ;
66743: GO 66612
66745: POP
66746: POP
// if not attacking and f_attack_depot then
66747: LD_VAR 0 29
66751: NOT
66752: PUSH
66753: LD_VAR 0 25
66757: AND
66758: IFFALSE 66853
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66760: LD_ADDR_VAR 0 13
66764: PUSH
66765: LD_VAR 0 14
66769: PPUSH
66770: LD_INT 2
66772: PUSH
66773: LD_INT 30
66775: PUSH
66776: LD_INT 0
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 30
66785: PUSH
66786: LD_INT 1
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: LIST
66797: PPUSH
66798: CALL_OW 72
66802: ST_TO_ADDR
// if z then
66803: LD_VAR 0 13
66807: IFFALSE 66853
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
66809: LD_VAR 0 4
66813: PUSH
66814: LD_VAR 0 7
66818: ARRAY
66819: PPUSH
66820: LD_VAR 0 13
66824: PPUSH
66825: LD_VAR 0 4
66829: PUSH
66830: LD_VAR 0 7
66834: ARRAY
66835: PPUSH
66836: CALL_OW 74
66840: PPUSH
66841: CALL_OW 115
// attacking := true ;
66845: LD_ADDR_VAR 0 29
66849: PUSH
66850: LD_INT 1
66852: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
66853: LD_VAR 0 4
66857: PUSH
66858: LD_VAR 0 7
66862: ARRAY
66863: PPUSH
66864: CALL_OW 256
66868: PUSH
66869: LD_INT 500
66871: LESS
66872: IFFALSE 66898
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
66874: LD_VAR 0 4
66878: PUSH
66879: LD_VAR 0 7
66883: ARRAY
66884: PPUSH
66885: LD_VAR 0 14
66889: PUSH
66890: LD_INT 1
66892: ARRAY
66893: PPUSH
66894: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
66898: LD_VAR 0 4
66902: PUSH
66903: LD_VAR 0 7
66907: ARRAY
66908: PPUSH
66909: CALL_OW 264
66913: PUSH
66914: LD_INT 49
66916: EQUAL
66917: IFFALSE 67038
// begin if not HasTask ( group [ i ] ) then
66919: LD_VAR 0 4
66923: PUSH
66924: LD_VAR 0 7
66928: ARRAY
66929: PPUSH
66930: CALL_OW 314
66934: NOT
66935: IFFALSE 67038
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
66937: LD_ADDR_VAR 0 9
66941: PUSH
66942: LD_INT 81
66944: PUSH
66945: LD_VAR 0 4
66949: PUSH
66950: LD_VAR 0 7
66954: ARRAY
66955: PPUSH
66956: CALL_OW 255
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PPUSH
66965: CALL_OW 69
66969: PPUSH
66970: LD_VAR 0 4
66974: PUSH
66975: LD_VAR 0 7
66979: ARRAY
66980: PPUSH
66981: CALL_OW 74
66985: ST_TO_ADDR
// if k then
66986: LD_VAR 0 9
66990: IFFALSE 67038
// if GetDistUnits ( group [ i ] , k ) > 10 then
66992: LD_VAR 0 4
66996: PUSH
66997: LD_VAR 0 7
67001: ARRAY
67002: PPUSH
67003: LD_VAR 0 9
67007: PPUSH
67008: CALL_OW 296
67012: PUSH
67013: LD_INT 10
67015: GREATER
67016: IFFALSE 67038
// ComMoveUnit ( group [ i ] , k ) ;
67018: LD_VAR 0 4
67022: PUSH
67023: LD_VAR 0 7
67027: ARRAY
67028: PPUSH
67029: LD_VAR 0 9
67033: PPUSH
67034: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
67038: LD_VAR 0 4
67042: PUSH
67043: LD_VAR 0 7
67047: ARRAY
67048: PPUSH
67049: CALL_OW 256
67053: PUSH
67054: LD_INT 250
67056: LESS
67057: PUSH
67058: LD_VAR 0 4
67062: PUSH
67063: LD_VAR 0 7
67067: ARRAY
67068: PUSH
67069: LD_INT 21
67071: PUSH
67072: LD_INT 2
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 23
67081: PUSH
67082: LD_INT 2
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PPUSH
67093: CALL_OW 69
67097: IN
67098: AND
67099: IFFALSE 67224
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
67101: LD_ADDR_VAR 0 9
67105: PUSH
67106: LD_OWVAR 3
67110: PUSH
67111: LD_VAR 0 4
67115: PUSH
67116: LD_VAR 0 7
67120: ARRAY
67121: DIFF
67122: PPUSH
67123: LD_VAR 0 4
67127: PUSH
67128: LD_VAR 0 7
67132: ARRAY
67133: PPUSH
67134: CALL_OW 74
67138: ST_TO_ADDR
// if not k then
67139: LD_VAR 0 9
67143: NOT
67144: IFFALSE 67148
// continue ;
67146: GO 63589
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
67148: LD_VAR 0 9
67152: PUSH
67153: LD_INT 81
67155: PUSH
67156: LD_VAR 0 4
67160: PUSH
67161: LD_VAR 0 7
67165: ARRAY
67166: PPUSH
67167: CALL_OW 255
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PPUSH
67176: CALL_OW 69
67180: IN
67181: PUSH
67182: LD_VAR 0 9
67186: PPUSH
67187: LD_VAR 0 4
67191: PUSH
67192: LD_VAR 0 7
67196: ARRAY
67197: PPUSH
67198: CALL_OW 296
67202: PUSH
67203: LD_INT 5
67205: LESS
67206: AND
67207: IFFALSE 67224
// ComAutodestruct ( group [ i ] ) ;
67209: LD_VAR 0 4
67213: PUSH
67214: LD_VAR 0 7
67218: ARRAY
67219: PPUSH
67220: CALL 61704 0 1
// end ; if f_attack_depot then
67224: LD_VAR 0 25
67228: IFFALSE 67340
// begin k := 6 ;
67230: LD_ADDR_VAR 0 9
67234: PUSH
67235: LD_INT 6
67237: ST_TO_ADDR
// if tmp < k then
67238: LD_VAR 0 14
67242: PUSH
67243: LD_VAR 0 9
67247: LESS
67248: IFFALSE 67260
// k := tmp ;
67250: LD_ADDR_VAR 0 9
67254: PUSH
67255: LD_VAR 0 14
67259: ST_TO_ADDR
// for j = 1 to k do
67260: LD_ADDR_VAR 0 8
67264: PUSH
67265: DOUBLE
67266: LD_INT 1
67268: DEC
67269: ST_TO_ADDR
67270: LD_VAR 0 9
67274: PUSH
67275: FOR_TO
67276: IFFALSE 67338
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
67278: LD_VAR 0 8
67282: PPUSH
67283: CALL_OW 266
67287: PUSH
67288: LD_INT 0
67290: PUSH
67291: LD_INT 1
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: IN
67298: IFFALSE 67336
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
67300: LD_VAR 0 4
67304: PUSH
67305: LD_VAR 0 7
67309: ARRAY
67310: PPUSH
67311: LD_VAR 0 14
67315: PUSH
67316: LD_VAR 0 8
67320: ARRAY
67321: PPUSH
67322: CALL_OW 115
// attacking := true ;
67326: LD_ADDR_VAR 0 29
67330: PUSH
67331: LD_INT 1
67333: ST_TO_ADDR
// break ;
67334: GO 67338
// end ;
67336: GO 67275
67338: POP
67339: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
67340: LD_VAR 0 4
67344: PUSH
67345: LD_VAR 0 7
67349: ARRAY
67350: PPUSH
67351: CALL_OW 302
67355: PUSH
67356: LD_VAR 0 29
67360: NOT
67361: AND
67362: IFFALSE 67684
// begin if GetTag ( group [ i ] ) = 71 then
67364: LD_VAR 0 4
67368: PUSH
67369: LD_VAR 0 7
67373: ARRAY
67374: PPUSH
67375: CALL_OW 110
67379: PUSH
67380: LD_INT 71
67382: EQUAL
67383: IFFALSE 67424
// begin if HasTask ( group [ i ] ) then
67385: LD_VAR 0 4
67389: PUSH
67390: LD_VAR 0 7
67394: ARRAY
67395: PPUSH
67396: CALL_OW 314
67400: IFFALSE 67406
// continue else
67402: GO 63589
67404: GO 67424
// SetTag ( group [ i ] , 0 ) ;
67406: LD_VAR 0 4
67410: PUSH
67411: LD_VAR 0 7
67415: ARRAY
67416: PPUSH
67417: LD_INT 0
67419: PPUSH
67420: CALL_OW 109
// end ; k := 8 ;
67424: LD_ADDR_VAR 0 9
67428: PUSH
67429: LD_INT 8
67431: ST_TO_ADDR
// x := 0 ;
67432: LD_ADDR_VAR 0 10
67436: PUSH
67437: LD_INT 0
67439: ST_TO_ADDR
// if tmp < k then
67440: LD_VAR 0 14
67444: PUSH
67445: LD_VAR 0 9
67449: LESS
67450: IFFALSE 67462
// k := tmp ;
67452: LD_ADDR_VAR 0 9
67456: PUSH
67457: LD_VAR 0 14
67461: ST_TO_ADDR
// for j = 1 to k do
67462: LD_ADDR_VAR 0 8
67466: PUSH
67467: DOUBLE
67468: LD_INT 1
67470: DEC
67471: ST_TO_ADDR
67472: LD_VAR 0 9
67476: PUSH
67477: FOR_TO
67478: IFFALSE 67576
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
67480: LD_VAR 0 14
67484: PUSH
67485: LD_VAR 0 8
67489: ARRAY
67490: PPUSH
67491: CALL_OW 247
67495: PUSH
67496: LD_INT 1
67498: EQUAL
67499: PUSH
67500: LD_VAR 0 14
67504: PUSH
67505: LD_VAR 0 8
67509: ARRAY
67510: PPUSH
67511: CALL_OW 256
67515: PUSH
67516: LD_INT 250
67518: LESS
67519: PUSH
67520: LD_VAR 0 20
67524: AND
67525: PUSH
67526: LD_VAR 0 20
67530: NOT
67531: PUSH
67532: LD_VAR 0 14
67536: PUSH
67537: LD_VAR 0 8
67541: ARRAY
67542: PPUSH
67543: CALL_OW 256
67547: PUSH
67548: LD_INT 250
67550: GREATEREQUAL
67551: AND
67552: OR
67553: AND
67554: IFFALSE 67574
// begin x := tmp [ j ] ;
67556: LD_ADDR_VAR 0 10
67560: PUSH
67561: LD_VAR 0 14
67565: PUSH
67566: LD_VAR 0 8
67570: ARRAY
67571: ST_TO_ADDR
// break ;
67572: GO 67576
// end ;
67574: GO 67477
67576: POP
67577: POP
// if x then
67578: LD_VAR 0 10
67582: IFFALSE 67606
// ComAttackUnit ( group [ i ] , x ) else
67584: LD_VAR 0 4
67588: PUSH
67589: LD_VAR 0 7
67593: ARRAY
67594: PPUSH
67595: LD_VAR 0 10
67599: PPUSH
67600: CALL_OW 115
67604: GO 67630
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
67606: LD_VAR 0 4
67610: PUSH
67611: LD_VAR 0 7
67615: ARRAY
67616: PPUSH
67617: LD_VAR 0 14
67621: PUSH
67622: LD_INT 1
67624: ARRAY
67625: PPUSH
67626: CALL_OW 115
// if not HasTask ( group [ i ] ) then
67630: LD_VAR 0 4
67634: PUSH
67635: LD_VAR 0 7
67639: ARRAY
67640: PPUSH
67641: CALL_OW 314
67645: NOT
67646: IFFALSE 67684
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
67648: LD_VAR 0 4
67652: PUSH
67653: LD_VAR 0 7
67657: ARRAY
67658: PPUSH
67659: LD_VAR 0 14
67663: PPUSH
67664: LD_VAR 0 4
67668: PUSH
67669: LD_VAR 0 7
67673: ARRAY
67674: PPUSH
67675: CALL_OW 74
67679: PPUSH
67680: CALL_OW 115
// end ; end ; end ;
67684: GO 63589
67686: POP
67687: POP
// wait ( 0 0$1 ) ;
67688: LD_INT 35
67690: PPUSH
67691: CALL_OW 67
// until group = [ ] ;
67695: LD_VAR 0 4
67699: PUSH
67700: EMPTY
67701: EQUAL
67702: IFFALSE 63574
// end ;
67704: LD_VAR 0 2
67708: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
67709: LD_INT 0
67711: PPUSH
67712: PPUSH
67713: PPUSH
67714: PPUSH
// if not base_units then
67715: LD_VAR 0 1
67719: NOT
67720: IFFALSE 67724
// exit ;
67722: GO 67811
// result := false ;
67724: LD_ADDR_VAR 0 2
67728: PUSH
67729: LD_INT 0
67731: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
67732: LD_ADDR_VAR 0 5
67736: PUSH
67737: LD_VAR 0 1
67741: PPUSH
67742: LD_INT 21
67744: PUSH
67745: LD_INT 3
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PPUSH
67752: CALL_OW 72
67756: ST_TO_ADDR
// if not tmp then
67757: LD_VAR 0 5
67761: NOT
67762: IFFALSE 67766
// exit ;
67764: GO 67811
// for i in tmp do
67766: LD_ADDR_VAR 0 3
67770: PUSH
67771: LD_VAR 0 5
67775: PUSH
67776: FOR_IN
67777: IFFALSE 67809
// begin result := EnemyInRange ( i , 22 ) ;
67779: LD_ADDR_VAR 0 2
67783: PUSH
67784: LD_VAR 0 3
67788: PPUSH
67789: LD_INT 22
67791: PPUSH
67792: CALL 61387 0 2
67796: ST_TO_ADDR
// if result then
67797: LD_VAR 0 2
67801: IFFALSE 67807
// exit ;
67803: POP
67804: POP
67805: GO 67811
// end ;
67807: GO 67776
67809: POP
67810: POP
// end ;
67811: LD_VAR 0 2
67815: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
67816: LD_INT 0
67818: PPUSH
67819: PPUSH
// if not units then
67820: LD_VAR 0 1
67824: NOT
67825: IFFALSE 67829
// exit ;
67827: GO 67899
// result := [ ] ;
67829: LD_ADDR_VAR 0 3
67833: PUSH
67834: EMPTY
67835: ST_TO_ADDR
// for i in units do
67836: LD_ADDR_VAR 0 4
67840: PUSH
67841: LD_VAR 0 1
67845: PUSH
67846: FOR_IN
67847: IFFALSE 67897
// if GetTag ( i ) = tag then
67849: LD_VAR 0 4
67853: PPUSH
67854: CALL_OW 110
67858: PUSH
67859: LD_VAR 0 2
67863: EQUAL
67864: IFFALSE 67895
// result := Insert ( result , result + 1 , i ) ;
67866: LD_ADDR_VAR 0 3
67870: PUSH
67871: LD_VAR 0 3
67875: PPUSH
67876: LD_VAR 0 3
67880: PUSH
67881: LD_INT 1
67883: PLUS
67884: PPUSH
67885: LD_VAR 0 4
67889: PPUSH
67890: CALL_OW 2
67894: ST_TO_ADDR
67895: GO 67846
67897: POP
67898: POP
// end ;
67899: LD_VAR 0 3
67903: RET
// export function IsDriver ( un ) ; begin
67904: LD_INT 0
67906: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
67907: LD_ADDR_VAR 0 2
67911: PUSH
67912: LD_VAR 0 1
67916: PUSH
67917: LD_INT 55
67919: PUSH
67920: EMPTY
67921: LIST
67922: PPUSH
67923: CALL_OW 69
67927: IN
67928: ST_TO_ADDR
// end ;
67929: LD_VAR 0 2
67933: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
67934: LD_INT 0
67936: PPUSH
67937: PPUSH
// list := [ ] ;
67938: LD_ADDR_VAR 0 5
67942: PUSH
67943: EMPTY
67944: ST_TO_ADDR
// case d of 0 :
67945: LD_VAR 0 3
67949: PUSH
67950: LD_INT 0
67952: DOUBLE
67953: EQUAL
67954: IFTRUE 67958
67956: GO 68091
67958: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
67959: LD_ADDR_VAR 0 5
67963: PUSH
67964: LD_VAR 0 1
67968: PUSH
67969: LD_INT 4
67971: MINUS
67972: PUSH
67973: LD_VAR 0 2
67977: PUSH
67978: LD_INT 4
67980: MINUS
67981: PUSH
67982: LD_INT 2
67984: PUSH
67985: EMPTY
67986: LIST
67987: LIST
67988: LIST
67989: PUSH
67990: LD_VAR 0 1
67994: PUSH
67995: LD_INT 3
67997: MINUS
67998: PUSH
67999: LD_VAR 0 2
68003: PUSH
68004: LD_INT 1
68006: PUSH
68007: EMPTY
68008: LIST
68009: LIST
68010: LIST
68011: PUSH
68012: LD_VAR 0 1
68016: PUSH
68017: LD_INT 4
68019: PLUS
68020: PUSH
68021: LD_VAR 0 2
68025: PUSH
68026: LD_INT 4
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: LIST
68033: PUSH
68034: LD_VAR 0 1
68038: PUSH
68039: LD_INT 3
68041: PLUS
68042: PUSH
68043: LD_VAR 0 2
68047: PUSH
68048: LD_INT 3
68050: PLUS
68051: PUSH
68052: LD_INT 5
68054: PUSH
68055: EMPTY
68056: LIST
68057: LIST
68058: LIST
68059: PUSH
68060: LD_VAR 0 1
68064: PUSH
68065: LD_VAR 0 2
68069: PUSH
68070: LD_INT 4
68072: PLUS
68073: PUSH
68074: LD_INT 0
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: LIST
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: LIST
68086: LIST
68087: LIST
68088: ST_TO_ADDR
// end ; 1 :
68089: GO 68789
68091: LD_INT 1
68093: DOUBLE
68094: EQUAL
68095: IFTRUE 68099
68097: GO 68232
68099: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
68100: LD_ADDR_VAR 0 5
68104: PUSH
68105: LD_VAR 0 1
68109: PUSH
68110: LD_VAR 0 2
68114: PUSH
68115: LD_INT 4
68117: MINUS
68118: PUSH
68119: LD_INT 3
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: LIST
68126: PUSH
68127: LD_VAR 0 1
68131: PUSH
68132: LD_INT 3
68134: MINUS
68135: PUSH
68136: LD_VAR 0 2
68140: PUSH
68141: LD_INT 3
68143: MINUS
68144: PUSH
68145: LD_INT 2
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: LIST
68152: PUSH
68153: LD_VAR 0 1
68157: PUSH
68158: LD_INT 4
68160: MINUS
68161: PUSH
68162: LD_VAR 0 2
68166: PUSH
68167: LD_INT 1
68169: PUSH
68170: EMPTY
68171: LIST
68172: LIST
68173: LIST
68174: PUSH
68175: LD_VAR 0 1
68179: PUSH
68180: LD_VAR 0 2
68184: PUSH
68185: LD_INT 3
68187: PLUS
68188: PUSH
68189: LD_INT 0
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: LIST
68196: PUSH
68197: LD_VAR 0 1
68201: PUSH
68202: LD_INT 4
68204: PLUS
68205: PUSH
68206: LD_VAR 0 2
68210: PUSH
68211: LD_INT 4
68213: PLUS
68214: PUSH
68215: LD_INT 5
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: LIST
68222: PUSH
68223: EMPTY
68224: LIST
68225: LIST
68226: LIST
68227: LIST
68228: LIST
68229: ST_TO_ADDR
// end ; 2 :
68230: GO 68789
68232: LD_INT 2
68234: DOUBLE
68235: EQUAL
68236: IFTRUE 68240
68238: GO 68369
68240: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
68241: LD_ADDR_VAR 0 5
68245: PUSH
68246: LD_VAR 0 1
68250: PUSH
68251: LD_VAR 0 2
68255: PUSH
68256: LD_INT 3
68258: MINUS
68259: PUSH
68260: LD_INT 3
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: LIST
68267: PUSH
68268: LD_VAR 0 1
68272: PUSH
68273: LD_INT 4
68275: PLUS
68276: PUSH
68277: LD_VAR 0 2
68281: PUSH
68282: LD_INT 4
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: LIST
68289: PUSH
68290: LD_VAR 0 1
68294: PUSH
68295: LD_VAR 0 2
68299: PUSH
68300: LD_INT 4
68302: PLUS
68303: PUSH
68304: LD_INT 0
68306: PUSH
68307: EMPTY
68308: LIST
68309: LIST
68310: LIST
68311: PUSH
68312: LD_VAR 0 1
68316: PUSH
68317: LD_INT 3
68319: MINUS
68320: PUSH
68321: LD_VAR 0 2
68325: PUSH
68326: LD_INT 1
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: LIST
68333: PUSH
68334: LD_VAR 0 1
68338: PUSH
68339: LD_INT 4
68341: MINUS
68342: PUSH
68343: LD_VAR 0 2
68347: PUSH
68348: LD_INT 4
68350: MINUS
68351: PUSH
68352: LD_INT 2
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: LIST
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: LIST
68364: LIST
68365: LIST
68366: ST_TO_ADDR
// end ; 3 :
68367: GO 68789
68369: LD_INT 3
68371: DOUBLE
68372: EQUAL
68373: IFTRUE 68377
68375: GO 68510
68377: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
68378: LD_ADDR_VAR 0 5
68382: PUSH
68383: LD_VAR 0 1
68387: PUSH
68388: LD_INT 3
68390: PLUS
68391: PUSH
68392: LD_VAR 0 2
68396: PUSH
68397: LD_INT 4
68399: PUSH
68400: EMPTY
68401: LIST
68402: LIST
68403: LIST
68404: PUSH
68405: LD_VAR 0 1
68409: PUSH
68410: LD_INT 4
68412: PLUS
68413: PUSH
68414: LD_VAR 0 2
68418: PUSH
68419: LD_INT 4
68421: PLUS
68422: PUSH
68423: LD_INT 5
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: LIST
68430: PUSH
68431: LD_VAR 0 1
68435: PUSH
68436: LD_INT 4
68438: MINUS
68439: PUSH
68440: LD_VAR 0 2
68444: PUSH
68445: LD_INT 1
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: LIST
68452: PUSH
68453: LD_VAR 0 1
68457: PUSH
68458: LD_VAR 0 2
68462: PUSH
68463: LD_INT 4
68465: MINUS
68466: PUSH
68467: LD_INT 3
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: LIST
68474: PUSH
68475: LD_VAR 0 1
68479: PUSH
68480: LD_INT 3
68482: MINUS
68483: PUSH
68484: LD_VAR 0 2
68488: PUSH
68489: LD_INT 3
68491: MINUS
68492: PUSH
68493: LD_INT 2
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: LIST
68500: PUSH
68501: EMPTY
68502: LIST
68503: LIST
68504: LIST
68505: LIST
68506: LIST
68507: ST_TO_ADDR
// end ; 4 :
68508: GO 68789
68510: LD_INT 4
68512: DOUBLE
68513: EQUAL
68514: IFTRUE 68518
68516: GO 68651
68518: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
68519: LD_ADDR_VAR 0 5
68523: PUSH
68524: LD_VAR 0 1
68528: PUSH
68529: LD_VAR 0 2
68533: PUSH
68534: LD_INT 4
68536: PLUS
68537: PUSH
68538: LD_INT 0
68540: PUSH
68541: EMPTY
68542: LIST
68543: LIST
68544: LIST
68545: PUSH
68546: LD_VAR 0 1
68550: PUSH
68551: LD_INT 3
68553: PLUS
68554: PUSH
68555: LD_VAR 0 2
68559: PUSH
68560: LD_INT 3
68562: PLUS
68563: PUSH
68564: LD_INT 5
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: LIST
68571: PUSH
68572: LD_VAR 0 1
68576: PUSH
68577: LD_INT 4
68579: PLUS
68580: PUSH
68581: LD_VAR 0 2
68585: PUSH
68586: LD_INT 4
68588: PUSH
68589: EMPTY
68590: LIST
68591: LIST
68592: LIST
68593: PUSH
68594: LD_VAR 0 1
68598: PUSH
68599: LD_VAR 0 2
68603: PUSH
68604: LD_INT 3
68606: MINUS
68607: PUSH
68608: LD_INT 3
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: LIST
68615: PUSH
68616: LD_VAR 0 1
68620: PUSH
68621: LD_INT 4
68623: MINUS
68624: PUSH
68625: LD_VAR 0 2
68629: PUSH
68630: LD_INT 4
68632: MINUS
68633: PUSH
68634: LD_INT 2
68636: PUSH
68637: EMPTY
68638: LIST
68639: LIST
68640: LIST
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: ST_TO_ADDR
// end ; 5 :
68649: GO 68789
68651: LD_INT 5
68653: DOUBLE
68654: EQUAL
68655: IFTRUE 68659
68657: GO 68788
68659: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
68660: LD_ADDR_VAR 0 5
68664: PUSH
68665: LD_VAR 0 1
68669: PUSH
68670: LD_INT 4
68672: MINUS
68673: PUSH
68674: LD_VAR 0 2
68678: PUSH
68679: LD_INT 1
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: LIST
68686: PUSH
68687: LD_VAR 0 1
68691: PUSH
68692: LD_VAR 0 2
68696: PUSH
68697: LD_INT 4
68699: MINUS
68700: PUSH
68701: LD_INT 3
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: LIST
68708: PUSH
68709: LD_VAR 0 1
68713: PUSH
68714: LD_INT 4
68716: PLUS
68717: PUSH
68718: LD_VAR 0 2
68722: PUSH
68723: LD_INT 4
68725: PLUS
68726: PUSH
68727: LD_INT 5
68729: PUSH
68730: EMPTY
68731: LIST
68732: LIST
68733: LIST
68734: PUSH
68735: LD_VAR 0 1
68739: PUSH
68740: LD_INT 3
68742: PLUS
68743: PUSH
68744: LD_VAR 0 2
68748: PUSH
68749: LD_INT 4
68751: PUSH
68752: EMPTY
68753: LIST
68754: LIST
68755: LIST
68756: PUSH
68757: LD_VAR 0 1
68761: PUSH
68762: LD_VAR 0 2
68766: PUSH
68767: LD_INT 3
68769: PLUS
68770: PUSH
68771: LD_INT 0
68773: PUSH
68774: EMPTY
68775: LIST
68776: LIST
68777: LIST
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: LIST
68783: LIST
68784: LIST
68785: ST_TO_ADDR
// end ; end ;
68786: GO 68789
68788: POP
// result := list ;
68789: LD_ADDR_VAR 0 4
68793: PUSH
68794: LD_VAR 0 5
68798: ST_TO_ADDR
// end ;
68799: LD_VAR 0 4
68803: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
68804: LD_INT 0
68806: PPUSH
68807: PPUSH
68808: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
68809: LD_VAR 0 1
68813: NOT
68814: PUSH
68815: LD_VAR 0 2
68819: PUSH
68820: LD_INT 1
68822: PUSH
68823: LD_INT 2
68825: PUSH
68826: LD_INT 3
68828: PUSH
68829: LD_INT 4
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: LIST
68836: LIST
68837: IN
68838: NOT
68839: OR
68840: IFFALSE 68844
// exit ;
68842: GO 68936
// tmp := [ ] ;
68844: LD_ADDR_VAR 0 5
68848: PUSH
68849: EMPTY
68850: ST_TO_ADDR
// for i in units do
68851: LD_ADDR_VAR 0 4
68855: PUSH
68856: LD_VAR 0 1
68860: PUSH
68861: FOR_IN
68862: IFFALSE 68905
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
68864: LD_ADDR_VAR 0 5
68868: PUSH
68869: LD_VAR 0 5
68873: PPUSH
68874: LD_VAR 0 5
68878: PUSH
68879: LD_INT 1
68881: PLUS
68882: PPUSH
68883: LD_VAR 0 4
68887: PPUSH
68888: LD_VAR 0 2
68892: PPUSH
68893: CALL_OW 259
68897: PPUSH
68898: CALL_OW 2
68902: ST_TO_ADDR
68903: GO 68861
68905: POP
68906: POP
// if not tmp then
68907: LD_VAR 0 5
68911: NOT
68912: IFFALSE 68916
// exit ;
68914: GO 68936
// result := SortListByListDesc ( units , tmp ) ;
68916: LD_ADDR_VAR 0 3
68920: PUSH
68921: LD_VAR 0 1
68925: PPUSH
68926: LD_VAR 0 5
68930: PPUSH
68931: CALL_OW 77
68935: ST_TO_ADDR
// end ;
68936: LD_VAR 0 3
68940: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
68941: LD_INT 0
68943: PPUSH
68944: PPUSH
68945: PPUSH
// x := GetX ( building ) ;
68946: LD_ADDR_VAR 0 4
68950: PUSH
68951: LD_VAR 0 2
68955: PPUSH
68956: CALL_OW 250
68960: ST_TO_ADDR
// y := GetY ( building ) ;
68961: LD_ADDR_VAR 0 5
68965: PUSH
68966: LD_VAR 0 2
68970: PPUSH
68971: CALL_OW 251
68975: ST_TO_ADDR
// if GetTaskList ( unit ) then
68976: LD_VAR 0 1
68980: PPUSH
68981: CALL_OW 437
68985: IFFALSE 69080
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
68987: LD_STRING e
68989: PUSH
68990: LD_VAR 0 1
68994: PPUSH
68995: CALL_OW 437
68999: PUSH
69000: LD_INT 1
69002: ARRAY
69003: PUSH
69004: LD_INT 1
69006: ARRAY
69007: EQUAL
69008: PUSH
69009: LD_VAR 0 4
69013: PUSH
69014: LD_VAR 0 1
69018: PPUSH
69019: CALL_OW 437
69023: PUSH
69024: LD_INT 1
69026: ARRAY
69027: PUSH
69028: LD_INT 2
69030: ARRAY
69031: EQUAL
69032: AND
69033: PUSH
69034: LD_VAR 0 5
69038: PUSH
69039: LD_VAR 0 1
69043: PPUSH
69044: CALL_OW 437
69048: PUSH
69049: LD_INT 1
69051: ARRAY
69052: PUSH
69053: LD_INT 3
69055: ARRAY
69056: EQUAL
69057: AND
69058: IFFALSE 69070
// result := true else
69060: LD_ADDR_VAR 0 3
69064: PUSH
69065: LD_INT 1
69067: ST_TO_ADDR
69068: GO 69078
// result := false ;
69070: LD_ADDR_VAR 0 3
69074: PUSH
69075: LD_INT 0
69077: ST_TO_ADDR
// end else
69078: GO 69088
// result := false ;
69080: LD_ADDR_VAR 0 3
69084: PUSH
69085: LD_INT 0
69087: ST_TO_ADDR
// end ;
69088: LD_VAR 0 3
69092: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
69093: LD_INT 0
69095: PPUSH
69096: PPUSH
69097: PPUSH
69098: PPUSH
// if not unit or not area then
69099: LD_VAR 0 1
69103: NOT
69104: PUSH
69105: LD_VAR 0 2
69109: NOT
69110: OR
69111: IFFALSE 69115
// exit ;
69113: GO 69280
// tmp := AreaToList ( area , i ) ;
69115: LD_ADDR_VAR 0 6
69119: PUSH
69120: LD_VAR 0 2
69124: PPUSH
69125: LD_VAR 0 5
69129: PPUSH
69130: CALL_OW 517
69134: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
69135: LD_ADDR_VAR 0 5
69139: PUSH
69140: DOUBLE
69141: LD_INT 1
69143: DEC
69144: ST_TO_ADDR
69145: LD_VAR 0 6
69149: PUSH
69150: LD_INT 1
69152: ARRAY
69153: PUSH
69154: FOR_TO
69155: IFFALSE 69270
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
69157: LD_ADDR_VAR 0 7
69161: PUSH
69162: LD_VAR 0 6
69166: PUSH
69167: LD_INT 1
69169: ARRAY
69170: PUSH
69171: LD_VAR 0 5
69175: ARRAY
69176: PUSH
69177: LD_VAR 0 6
69181: PUSH
69182: LD_INT 2
69184: ARRAY
69185: PUSH
69186: LD_VAR 0 5
69190: ARRAY
69191: PUSH
69192: EMPTY
69193: LIST
69194: LIST
69195: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
69196: LD_VAR 0 7
69200: PUSH
69201: LD_INT 1
69203: ARRAY
69204: PPUSH
69205: LD_VAR 0 7
69209: PUSH
69210: LD_INT 2
69212: ARRAY
69213: PPUSH
69214: CALL_OW 428
69218: PUSH
69219: LD_INT 0
69221: EQUAL
69222: IFFALSE 69268
// begin result := true ;
69224: LD_ADDR_VAR 0 4
69228: PUSH
69229: LD_INT 1
69231: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
69232: LD_VAR 0 1
69236: PPUSH
69237: LD_VAR 0 7
69241: PUSH
69242: LD_INT 1
69244: ARRAY
69245: PPUSH
69246: LD_VAR 0 7
69250: PUSH
69251: LD_INT 2
69253: ARRAY
69254: PPUSH
69255: LD_VAR 0 3
69259: PPUSH
69260: CALL_OW 48
// exit ;
69264: POP
69265: POP
69266: GO 69280
// end ; end ;
69268: GO 69154
69270: POP
69271: POP
// result := false ;
69272: LD_ADDR_VAR 0 4
69276: PUSH
69277: LD_INT 0
69279: ST_TO_ADDR
// end ;
69280: LD_VAR 0 4
69284: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
69285: LD_INT 0
69287: PPUSH
69288: PPUSH
69289: PPUSH
// if not side or side > 8 then
69290: LD_VAR 0 1
69294: NOT
69295: PUSH
69296: LD_VAR 0 1
69300: PUSH
69301: LD_INT 8
69303: GREATER
69304: OR
69305: IFFALSE 69309
// exit ;
69307: GO 69496
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
69309: LD_ADDR_VAR 0 4
69313: PUSH
69314: LD_INT 22
69316: PUSH
69317: LD_VAR 0 1
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 21
69328: PUSH
69329: LD_INT 3
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PPUSH
69340: CALL_OW 69
69344: ST_TO_ADDR
// if not tmp then
69345: LD_VAR 0 4
69349: NOT
69350: IFFALSE 69354
// exit ;
69352: GO 69496
// enable_addtolog := true ;
69354: LD_ADDR_OWVAR 81
69358: PUSH
69359: LD_INT 1
69361: ST_TO_ADDR
// AddToLog ( [ ) ;
69362: LD_STRING [
69364: PPUSH
69365: CALL_OW 561
// for i in tmp do
69369: LD_ADDR_VAR 0 3
69373: PUSH
69374: LD_VAR 0 4
69378: PUSH
69379: FOR_IN
69380: IFFALSE 69487
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
69382: LD_STRING [
69384: PUSH
69385: LD_VAR 0 3
69389: PPUSH
69390: CALL_OW 266
69394: STR
69395: PUSH
69396: LD_STRING , 
69398: STR
69399: PUSH
69400: LD_VAR 0 3
69404: PPUSH
69405: CALL_OW 250
69409: STR
69410: PUSH
69411: LD_STRING , 
69413: STR
69414: PUSH
69415: LD_VAR 0 3
69419: PPUSH
69420: CALL_OW 251
69424: STR
69425: PUSH
69426: LD_STRING , 
69428: STR
69429: PUSH
69430: LD_VAR 0 3
69434: PPUSH
69435: CALL_OW 254
69439: STR
69440: PUSH
69441: LD_STRING , 
69443: STR
69444: PUSH
69445: LD_VAR 0 3
69449: PPUSH
69450: LD_INT 1
69452: PPUSH
69453: CALL_OW 268
69457: STR
69458: PUSH
69459: LD_STRING , 
69461: STR
69462: PUSH
69463: LD_VAR 0 3
69467: PPUSH
69468: LD_INT 2
69470: PPUSH
69471: CALL_OW 268
69475: STR
69476: PUSH
69477: LD_STRING ],
69479: STR
69480: PPUSH
69481: CALL_OW 561
// end ;
69485: GO 69379
69487: POP
69488: POP
// AddToLog ( ]; ) ;
69489: LD_STRING ];
69491: PPUSH
69492: CALL_OW 561
// end ;
69496: LD_VAR 0 2
69500: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
69501: LD_INT 0
69503: PPUSH
69504: PPUSH
69505: PPUSH
69506: PPUSH
69507: PPUSH
// if not area or not rate or not max then
69508: LD_VAR 0 1
69512: NOT
69513: PUSH
69514: LD_VAR 0 2
69518: NOT
69519: OR
69520: PUSH
69521: LD_VAR 0 4
69525: NOT
69526: OR
69527: IFFALSE 69531
// exit ;
69529: GO 69723
// while 1 do
69531: LD_INT 1
69533: IFFALSE 69723
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
69535: LD_ADDR_VAR 0 9
69539: PUSH
69540: LD_VAR 0 1
69544: PPUSH
69545: LD_INT 1
69547: PPUSH
69548: CALL_OW 287
69552: PUSH
69553: LD_INT 10
69555: MUL
69556: ST_TO_ADDR
// r := rate / 10 ;
69557: LD_ADDR_VAR 0 7
69561: PUSH
69562: LD_VAR 0 2
69566: PUSH
69567: LD_INT 10
69569: DIVREAL
69570: ST_TO_ADDR
// time := 1 1$00 ;
69571: LD_ADDR_VAR 0 8
69575: PUSH
69576: LD_INT 2100
69578: ST_TO_ADDR
// if amount < min then
69579: LD_VAR 0 9
69583: PUSH
69584: LD_VAR 0 3
69588: LESS
69589: IFFALSE 69607
// r := r * 2 else
69591: LD_ADDR_VAR 0 7
69595: PUSH
69596: LD_VAR 0 7
69600: PUSH
69601: LD_INT 2
69603: MUL
69604: ST_TO_ADDR
69605: GO 69633
// if amount > max then
69607: LD_VAR 0 9
69611: PUSH
69612: LD_VAR 0 4
69616: GREATER
69617: IFFALSE 69633
// r := r / 2 ;
69619: LD_ADDR_VAR 0 7
69623: PUSH
69624: LD_VAR 0 7
69628: PUSH
69629: LD_INT 2
69631: DIVREAL
69632: ST_TO_ADDR
// time := time / r ;
69633: LD_ADDR_VAR 0 8
69637: PUSH
69638: LD_VAR 0 8
69642: PUSH
69643: LD_VAR 0 7
69647: DIVREAL
69648: ST_TO_ADDR
// if time < 0 then
69649: LD_VAR 0 8
69653: PUSH
69654: LD_INT 0
69656: LESS
69657: IFFALSE 69674
// time := time * - 1 ;
69659: LD_ADDR_VAR 0 8
69663: PUSH
69664: LD_VAR 0 8
69668: PUSH
69669: LD_INT 1
69671: NEG
69672: MUL
69673: ST_TO_ADDR
// wait ( time ) ;
69674: LD_VAR 0 8
69678: PPUSH
69679: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
69683: LD_INT 35
69685: PPUSH
69686: LD_INT 875
69688: PPUSH
69689: CALL_OW 12
69693: PPUSH
69694: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
69698: LD_INT 1
69700: PPUSH
69701: LD_INT 5
69703: PPUSH
69704: CALL_OW 12
69708: PPUSH
69709: LD_VAR 0 1
69713: PPUSH
69714: LD_INT 1
69716: PPUSH
69717: CALL_OW 55
// end ;
69721: GO 69531
// end ;
69723: LD_VAR 0 5
69727: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
69728: LD_INT 0
69730: PPUSH
69731: PPUSH
69732: PPUSH
69733: PPUSH
69734: PPUSH
69735: PPUSH
69736: PPUSH
69737: PPUSH
// if not turrets or not factories then
69738: LD_VAR 0 1
69742: NOT
69743: PUSH
69744: LD_VAR 0 2
69748: NOT
69749: OR
69750: IFFALSE 69754
// exit ;
69752: GO 70061
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
69754: LD_ADDR_VAR 0 10
69758: PUSH
69759: LD_INT 5
69761: PUSH
69762: LD_INT 6
69764: PUSH
69765: EMPTY
69766: LIST
69767: LIST
69768: PUSH
69769: LD_INT 2
69771: PUSH
69772: LD_INT 4
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: PUSH
69779: LD_INT 3
69781: PUSH
69782: LD_INT 5
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: LIST
69793: PUSH
69794: LD_INT 24
69796: PUSH
69797: LD_INT 25
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 23
69806: PUSH
69807: LD_INT 27
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: PUSH
69818: LD_INT 42
69820: PUSH
69821: LD_INT 43
69823: PUSH
69824: EMPTY
69825: LIST
69826: LIST
69827: PUSH
69828: LD_INT 44
69830: PUSH
69831: LD_INT 46
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 45
69840: PUSH
69841: LD_INT 47
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: EMPTY
69849: LIST
69850: LIST
69851: LIST
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: LIST
69857: ST_TO_ADDR
// result := [ ] ;
69858: LD_ADDR_VAR 0 3
69862: PUSH
69863: EMPTY
69864: ST_TO_ADDR
// for i in turrets do
69865: LD_ADDR_VAR 0 4
69869: PUSH
69870: LD_VAR 0 1
69874: PUSH
69875: FOR_IN
69876: IFFALSE 70059
// begin nat := GetNation ( i ) ;
69878: LD_ADDR_VAR 0 7
69882: PUSH
69883: LD_VAR 0 4
69887: PPUSH
69888: CALL_OW 248
69892: ST_TO_ADDR
// weapon := 0 ;
69893: LD_ADDR_VAR 0 8
69897: PUSH
69898: LD_INT 0
69900: ST_TO_ADDR
// if not nat then
69901: LD_VAR 0 7
69905: NOT
69906: IFFALSE 69910
// continue ;
69908: GO 69875
// for j in list [ nat ] do
69910: LD_ADDR_VAR 0 5
69914: PUSH
69915: LD_VAR 0 10
69919: PUSH
69920: LD_VAR 0 7
69924: ARRAY
69925: PUSH
69926: FOR_IN
69927: IFFALSE 69968
// if GetBWeapon ( i ) = j [ 1 ] then
69929: LD_VAR 0 4
69933: PPUSH
69934: CALL_OW 269
69938: PUSH
69939: LD_VAR 0 5
69943: PUSH
69944: LD_INT 1
69946: ARRAY
69947: EQUAL
69948: IFFALSE 69966
// begin weapon := j [ 2 ] ;
69950: LD_ADDR_VAR 0 8
69954: PUSH
69955: LD_VAR 0 5
69959: PUSH
69960: LD_INT 2
69962: ARRAY
69963: ST_TO_ADDR
// break ;
69964: GO 69968
// end ;
69966: GO 69926
69968: POP
69969: POP
// if not weapon then
69970: LD_VAR 0 8
69974: NOT
69975: IFFALSE 69979
// continue ;
69977: GO 69875
// for k in factories do
69979: LD_ADDR_VAR 0 6
69983: PUSH
69984: LD_VAR 0 2
69988: PUSH
69989: FOR_IN
69990: IFFALSE 70055
// begin weapons := AvailableWeaponList ( k ) ;
69992: LD_ADDR_VAR 0 9
69996: PUSH
69997: LD_VAR 0 6
70001: PPUSH
70002: CALL_OW 478
70006: ST_TO_ADDR
// if not weapons then
70007: LD_VAR 0 9
70011: NOT
70012: IFFALSE 70016
// continue ;
70014: GO 69989
// if weapon in weapons then
70016: LD_VAR 0 8
70020: PUSH
70021: LD_VAR 0 9
70025: IN
70026: IFFALSE 70053
// begin result := [ i , weapon ] ;
70028: LD_ADDR_VAR 0 3
70032: PUSH
70033: LD_VAR 0 4
70037: PUSH
70038: LD_VAR 0 8
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: ST_TO_ADDR
// exit ;
70047: POP
70048: POP
70049: POP
70050: POP
70051: GO 70061
// end ; end ;
70053: GO 69989
70055: POP
70056: POP
// end ;
70057: GO 69875
70059: POP
70060: POP
// end ;
70061: LD_VAR 0 3
70065: RET
