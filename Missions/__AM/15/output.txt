// starting begin ResetFog ;
   0: CALL_OW 335
// InitVariables ;
   4: CALL 58 0 0
// InitMacro ;
   8: CALL 31546 0 0
// InitNature ;
  12: CALL 31370 0 0
// if debug then
  16: LD_EXP 1
  20: IFFALSE 29
// FogOff ( 1 ) ;
  22: LD_INT 1
  24: PPUSH
  25: CALL_OW 344
// PrepareAlliance ;
  29: CALL 9360 0 0
// PrepareRussian ;
  33: CALL 5622 0 0
// PrepareLegion ;
  37: CALL 3688 0 0
// PreparePowell ;
  41: CALL 2442 0 0
// PrepareAmerican ;
  45: CALL 1272 0 0
// Action ;
  49: CALL 13098 0 0
// MC_Start ( ) ;
  53: CALL 32693 0 0
// end ;
  57: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  58: LD_INT 0
  60: PPUSH
// debug := 0 ;
  61: LD_ADDR_EXP 1
  65: PUSH
  66: LD_INT 0
  68: ST_TO_ADDR
// missionStart := false ;
  69: LD_ADDR_EXP 13
  73: PUSH
  74: LD_INT 0
  76: ST_TO_ADDR
// missionTime := 0 0$00 ;
  77: LD_ADDR_EXP 14
  81: PUSH
  82: LD_INT 0
  84: ST_TO_ADDR
// missionStage := 1 ;
  85: LD_ADDR_EXP 15
  89: PUSH
  90: LD_INT 1
  92: ST_TO_ADDR
// activeAttacks := false ;
  93: LD_ADDR_EXP 16
  97: PUSH
  98: LD_INT 0
 100: ST_TO_ADDR
// powellAnger := 0 ;
 101: LD_ADDR_EXP 17
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// powellAllowRetreat := true ;
 109: LD_ADDR_EXP 19
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// powellCenterCameraMode := false ;
 117: LD_ADDR_EXP 20
 121: PUSH
 122: LD_INT 0
 124: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 125: LD_ADDR_EXP 18
 129: PUSH
 130: EMPTY
 131: PUSH
 132: EMPTY
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: ST_TO_ADDR
// russianDestroyed := false ;
 138: LD_ADDR_EXP 21
 142: PUSH
 143: LD_INT 0
 145: ST_TO_ADDR
// legionDestroyed := false ;
 146: LD_ADDR_EXP 22
 150: PUSH
 151: LD_INT 0
 153: ST_TO_ADDR
// allianceDestroyed := false ;
 154: LD_ADDR_EXP 23
 158: PUSH
 159: LD_INT 0
 161: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 162: LD_ADDR_EXP 2
 166: PUSH
 167: LD_STRING 14_KappaStatus_1
 169: PPUSH
 170: LD_INT 0
 172: PPUSH
 173: CALL_OW 30
 177: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 178: LD_ADDR_EXP 3
 182: PUSH
 183: LD_STRING 06_KurtStatus_1
 185: PPUSH
 186: LD_INT 0
 188: PPUSH
 189: CALL_OW 30
 193: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 194: LD_ADDR_EXP 4
 198: PUSH
 199: LD_STRING 14_JMMVeh_1
 201: PPUSH
 202: LD_INT 0
 204: PPUSH
 205: CALL_OW 30
 209: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 210: LD_ADDR_EXP 5
 214: PUSH
 215: LD_STRING 14_JMMGirlVeh_1
 217: PPUSH
 218: LD_INT 0
 220: PPUSH
 221: CALL_OW 30
 225: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 226: LD_ADDR_EXP 7
 230: PUSH
 231: LD_STRING 14_JMMGirl_1
 233: PPUSH
 234: LD_INT 0
 236: PPUSH
 237: CALL_OW 30
 241: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 242: LD_ADDR_EXP 6
 246: PUSH
 247: LD_STRING 14_JMMGirlStatus_1
 249: PPUSH
 250: LD_INT 0
 252: PPUSH
 253: CALL_OW 30
 257: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 258: LD_ADDR_EXP 8
 262: PUSH
 263: LD_STRING 10_KhatamStatus_1
 265: PPUSH
 266: LD_INT 0
 268: PPUSH
 269: CALL_OW 30
 273: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 274: LD_ADDR_EXP 9
 278: PUSH
 279: LD_STRING 13_BurlakStatus_1
 281: PPUSH
 282: LD_INT 0
 284: PPUSH
 285: CALL_OW 30
 289: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 290: LD_ADDR_EXP 10
 294: PUSH
 295: LD_STRING 13_StevensStatus_1
 297: PPUSH
 298: LD_INT 0
 300: PPUSH
 301: CALL_OW 30
 305: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 306: LD_ADDR_EXP 11
 310: PUSH
 311: LD_STRING 14_FastEnd_1
 313: PPUSH
 314: LD_INT 0
 316: PPUSH
 317: CALL_OW 30
 321: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 322: LD_ADDR_EXP 12
 326: PUSH
 327: LD_STRING 12_MainDepositFake_1
 329: PPUSH
 330: LD_INT 0
 332: PPUSH
 333: CALL_OW 30
 337: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 338: LD_ADDR_EXP 24
 342: PUSH
 343: LD_INT 1
 345: ST_TO_ADDR
// behemothUnderConstruct := false ;
 346: LD_ADDR_EXP 26
 350: PUSH
 351: LD_INT 0
 353: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 354: LD_ADDR_EXP 27
 358: PUSH
 359: LD_INT 0
 361: ST_TO_ADDR
// behemothDone := false ;
 362: LD_ADDR_EXP 28
 366: PUSH
 367: LD_INT 0
 369: ST_TO_ADDR
// allowBehemothConstruct := false ;
 370: LD_ADDR_EXP 25
 374: PUSH
 375: LD_INT 0
 377: ST_TO_ADDR
// seeBehemoth := false ;
 378: LD_ADDR_EXP 29
 382: PUSH
 383: LD_INT 0
 385: ST_TO_ADDR
// platonovHasBomb := false ;
 386: LD_ADDR_EXP 30
 390: PUSH
 391: LD_INT 0
 393: ST_TO_ADDR
// allianceActive := false ;
 394: LD_ADDR_EXP 31
 398: PUSH
 399: LD_INT 0
 401: ST_TO_ADDR
// rothCaptured := false ;
 402: LD_ADDR_EXP 33
 406: PUSH
 407: LD_INT 0
 409: ST_TO_ADDR
// lostCounter := 0 ;
 410: LD_ADDR_EXP 32
 414: PUSH
 415: LD_INT 0
 417: ST_TO_ADDR
// capturedUnit := [ ] ;
 418: LD_ADDR_EXP 34
 422: PUSH
 423: EMPTY
 424: ST_TO_ADDR
// trueAmericans := [ ] ;
 425: LD_ADDR_EXP 35
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// end ;
 432: LD_VAR 0 1
 436: RET
// export function CustomInitMacro ( ) ; begin
 437: LD_INT 0
 439: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 440: LD_ADDR_EXP 123
 444: PUSH
 445: LD_INT 2
 447: PUSH
 448: LD_INT 3
 450: PUSH
 451: LD_INT 6
 453: PUSH
 454: LD_INT 10
 456: PUSH
 457: EMPTY
 458: LIST
 459: LIST
 460: LIST
 461: LIST
 462: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 463: LD_ADDR_EXP 124
 467: PUSH
 468: LD_INT 1
 470: PUSH
 471: LD_INT 4
 473: PUSH
 474: LD_INT 5
 476: PUSH
 477: LD_INT 9
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 486: LD_INT 1
 488: PPUSH
 489: LD_INT 10
 491: PUSH
 492: LD_INT 11
 494: PUSH
 495: LD_INT 12
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: PPUSH
 503: CALL 54226 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 507: LD_INT 1
 509: PPUSH
 510: LD_INT 17
 512: PUSH
 513: EMPTY
 514: LIST
 515: PPUSH
 516: CALL 54319 0 2
// MC_SetTame ( 1 , allianceCratesArea ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 17
 525: PPUSH
 526: CALL 54050 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 530: LD_INT 2
 532: PPUSH
 533: LD_INT 10
 535: PUSH
 536: LD_INT 11
 538: PUSH
 539: LD_INT 12
 541: PUSH
 542: LD_INT 14
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PPUSH
 551: CALL 54226 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 555: LD_INT 2
 557: PPUSH
 558: LD_INT 16
 560: PUSH
 561: EMPTY
 562: LIST
 563: PPUSH
 564: CALL 54319 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] ] ) ;
 568: LD_INT 2
 570: PPUSH
 571: LD_INT 21
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: LD_INT 3
 579: PUSH
 580: LD_INT 51
 582: PUSH
 583: EMPTY
 584: LIST
 585: LIST
 586: LIST
 587: LIST
 588: PUSH
 589: EMPTY
 590: LIST
 591: PPUSH
 592: CALL 53489 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 596: LD_INT 2
 598: PPUSH
 599: LD_INT 0
 601: PPUSH
 602: CALL 54099 0 2
// MC_SetMinesField ( 2 , [ 7 , 8 , 9 ] [ Difficulty ] , legionMinefield ) ;
 606: LD_INT 2
 608: PPUSH
 609: LD_INT 7
 611: PUSH
 612: LD_INT 8
 614: PUSH
 615: LD_INT 9
 617: PUSH
 618: EMPTY
 619: LIST
 620: LIST
 621: LIST
 622: PUSH
 623: LD_OWVAR 67
 627: ARRAY
 628: PPUSH
 629: LD_INT 27
 631: PPUSH
 632: CALL 53171 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 636: LD_INT 3
 638: PPUSH
 639: LD_INT 10
 641: PUSH
 642: LD_INT 11
 644: PUSH
 645: LD_INT 13
 647: PUSH
 648: LD_INT 15
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PPUSH
 657: CALL 54226 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 661: LD_INT 3
 663: PPUSH
 664: LD_INT 15
 666: PUSH
 667: EMPTY
 668: LIST
 669: PPUSH
 670: CALL 54319 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 674: LD_ADDR_EXP 128
 678: PUSH
 679: LD_EXP 128
 683: PPUSH
 684: LD_INT 3
 686: PPUSH
 687: LD_INT 22
 689: PUSH
 690: LD_INT 8
 692: PUSH
 693: EMPTY
 694: LIST
 695: LIST
 696: PUSH
 697: LD_INT 25
 699: PUSH
 700: LD_INT 15
 702: PUSH
 703: EMPTY
 704: LIST
 705: LIST
 706: PUSH
 707: EMPTY
 708: LIST
 709: LIST
 710: PPUSH
 711: CALL_OW 69
 715: PPUSH
 716: CALL_OW 1
 720: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 721: LD_INT 3
 723: PPUSH
 724: LD_INT 13
 726: PUSH
 727: LD_INT 2
 729: PUSH
 730: LD_INT 1
 732: PUSH
 733: LD_INT 31
 735: PUSH
 736: EMPTY
 737: LIST
 738: LIST
 739: LIST
 740: LIST
 741: PUSH
 742: LD_INT 13
 744: PUSH
 745: LD_INT 2
 747: PUSH
 748: LD_INT 1
 750: PUSH
 751: LD_INT 31
 753: PUSH
 754: EMPTY
 755: LIST
 756: LIST
 757: LIST
 758: LIST
 759: PUSH
 760: LD_INT 13
 762: PUSH
 763: LD_INT 3
 765: PUSH
 766: LD_INT 2
 768: PUSH
 769: LD_INT 32
 771: PUSH
 772: EMPTY
 773: LIST
 774: LIST
 775: LIST
 776: LIST
 777: PUSH
 778: EMPTY
 779: LIST
 780: LIST
 781: LIST
 782: PPUSH
 783: CALL 53489 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
 787: LD_INT 4
 789: PPUSH
 790: LD_INT 10
 792: PUSH
 793: LD_INT 12
 795: PUSH
 796: EMPTY
 797: LIST
 798: LIST
 799: PPUSH
 800: CALL 54226 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
 804: LD_INT 4
 806: PPUSH
 807: LD_INT 9
 809: PUSH
 810: EMPTY
 811: LIST
 812: PPUSH
 813: CALL 54319 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
 817: LD_INT 4
 819: PPUSH
 820: LD_INT 26
 822: PUSH
 823: LD_INT 74
 825: PUSH
 826: LD_INT 107
 828: PUSH
 829: LD_INT 0
 831: PUSH
 832: EMPTY
 833: LIST
 834: LIST
 835: LIST
 836: LIST
 837: PUSH
 838: LD_INT 32
 840: PUSH
 841: LD_INT 77
 843: PUSH
 844: LD_INT 101
 846: PUSH
 847: LD_INT 4
 849: PUSH
 850: EMPTY
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: PUSH
 856: LD_INT 32
 858: PUSH
 859: LD_INT 69
 861: PUSH
 862: LD_INT 86
 864: PUSH
 865: LD_INT 4
 867: PUSH
 868: EMPTY
 869: LIST
 870: LIST
 871: LIST
 872: LIST
 873: PUSH
 874: LD_INT 27
 876: PUSH
 877: LD_INT 77
 879: PUSH
 880: LD_INT 110
 882: PUSH
 883: LD_INT 3
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 27
 894: PUSH
 895: LD_INT 42
 897: PUSH
 898: LD_INT 79
 900: PUSH
 901: LD_INT 5
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 29
 912: PUSH
 913: LD_INT 86
 915: PUSH
 916: LD_INT 105
 918: PUSH
 919: LD_INT 2
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: LD_INT 30
 930: PUSH
 931: LD_INT 40
 933: PUSH
 934: LD_INT 75
 936: PUSH
 937: LD_INT 1
 939: PUSH
 940: EMPTY
 941: LIST
 942: LIST
 943: LIST
 944: LIST
 945: PUSH
 946: LD_INT 32
 948: PUSH
 949: LD_INT 80
 951: PUSH
 952: LD_INT 106
 954: PUSH
 955: LD_INT 4
 957: PUSH
 958: EMPTY
 959: LIST
 960: LIST
 961: LIST
 962: LIST
 963: PUSH
 964: LD_INT 32
 966: PUSH
 967: LD_INT 75
 969: PUSH
 970: LD_INT 114
 972: PUSH
 973: LD_INT 5
 975: PUSH
 976: EMPTY
 977: LIST
 978: LIST
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 32
 984: PUSH
 985: LD_INT 82
 987: PUSH
 988: LD_INT 110
 990: PUSH
 991: LD_INT 5
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: LIST
 999: PUSH
1000: LD_INT 32
1002: PUSH
1003: LD_INT 62
1005: PUSH
1006: LD_INT 78
1008: PUSH
1009: LD_INT 4
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: LIST
1016: LIST
1017: PUSH
1018: LD_INT 4
1020: PUSH
1021: LD_INT 39
1023: PUSH
1024: LD_INT 61
1026: PUSH
1027: LD_INT 3
1029: PUSH
1030: EMPTY
1031: LIST
1032: LIST
1033: LIST
1034: LIST
1035: PUSH
1036: EMPTY
1037: LIST
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: LIST
1045: LIST
1046: LIST
1047: LIST
1048: LIST
1049: PPUSH
1050: CALL 53381 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1054: LD_INT 4
1056: PPUSH
1057: LD_INT 5
1059: PUSH
1060: LD_INT 6
1062: PUSH
1063: LD_INT 7
1065: PUSH
1066: LD_INT 9
1068: PUSH
1069: EMPTY
1070: LIST
1071: LIST
1072: LIST
1073: LIST
1074: PPUSH
1075: CALL 54637 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1079: LD_INT 4
1081: PPUSH
1082: LD_INT 40
1084: PUSH
1085: LD_INT 75
1087: PUSH
1088: LD_INT 1
1090: PUSH
1091: EMPTY
1092: LIST
1093: LIST
1094: LIST
1095: PUSH
1096: LD_INT 86
1098: PUSH
1099: LD_INT 105
1101: PUSH
1102: LD_INT 0
1104: PUSH
1105: EMPTY
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: EMPTY
1111: LIST
1112: LIST
1113: PPUSH
1114: CALL 53871 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1118: LD_INT 4
1120: PPUSH
1121: LD_INT 2
1123: PPUSH
1124: CALL 54099 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1128: LD_INT 4
1130: PPUSH
1131: LD_INT 0
1133: PPUSH
1134: CALL 54099 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1138: LD_INT 4
1140: PPUSH
1141: LD_INT 54
1143: PPUSH
1144: LD_INT 85
1146: PPUSH
1147: LD_INT 2
1149: PPUSH
1150: LD_INT 19
1152: PUSH
1153: LD_INT 16
1155: PUSH
1156: LD_INT 17
1158: PUSH
1159: LD_INT 18
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PPUSH
1168: CALL 54431 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1172: LD_INT 4
1174: PPUSH
1175: LD_INT 3
1177: PUSH
1178: LD_INT 1
1180: PUSH
1181: LD_INT 1
1183: PUSH
1184: LD_INT 5
1186: PUSH
1187: EMPTY
1188: LIST
1189: LIST
1190: LIST
1191: LIST
1192: PUSH
1193: LD_INT 4
1195: PUSH
1196: LD_INT 1
1198: PUSH
1199: LD_INT 1
1201: PUSH
1202: LD_INT 6
1204: PUSH
1205: EMPTY
1206: LIST
1207: LIST
1208: LIST
1209: LIST
1210: PUSH
1211: LD_INT 4
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: LD_INT 1
1219: PUSH
1220: LD_INT 7
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_INT 4
1231: PUSH
1232: LD_INT 1
1234: PUSH
1235: LD_INT 1
1237: PUSH
1238: LD_INT 6
1240: PUSH
1241: EMPTY
1242: LIST
1243: LIST
1244: LIST
1245: LIST
1246: PUSH
1247: EMPTY
1248: LIST
1249: LIST
1250: LIST
1251: LIST
1252: PPUSH
1253: CALL 53489 0 2
// MC_SetTame ( 4 , powellApe ) ;
1257: LD_INT 4
1259: PPUSH
1260: LD_INT 13
1262: PPUSH
1263: CALL 54050 0 2
// end ; end_of_file
1267: LD_VAR 0 1
1271: RET
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1272: LD_INT 0
1274: PPUSH
// uc_side := 1 ;
1275: LD_ADDR_OWVAR 20
1279: PUSH
1280: LD_INT 1
1282: ST_TO_ADDR
// uc_nation := 1 ;
1283: LD_ADDR_OWVAR 21
1287: PUSH
1288: LD_INT 1
1290: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1291: LD_ADDR_EXP 36
1295: PUSH
1296: LD_STRING JMM
1298: PPUSH
1299: LD_EXP 1
1303: NOT
1304: PPUSH
1305: LD_STRING 14_
1307: PPUSH
1308: CALL 59432 0 3
1312: ST_TO_ADDR
// if not JMMVeh then
1313: LD_EXP 4
1317: NOT
1318: IFFALSE 1341
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1320: LD_INT 3
1322: PPUSH
1323: LD_INT 3
1325: PPUSH
1326: LD_INT 1
1328: PPUSH
1329: LD_INT 5
1331: PPUSH
1332: LD_INT 100
1334: PPUSH
1335: CALL 66065 0 5
1339: GO 1400
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1341: LD_EXP 4
1345: PUSH
1346: LD_INT 1
1348: ARRAY
1349: PUSH
1350: LD_INT 1
1352: ARRAY
1353: PPUSH
1354: LD_EXP 4
1358: PUSH
1359: LD_INT 2
1361: ARRAY
1362: PUSH
1363: LD_INT 1
1365: ARRAY
1366: PPUSH
1367: LD_EXP 4
1371: PUSH
1372: LD_INT 3
1374: ARRAY
1375: PUSH
1376: LD_INT 1
1378: ARRAY
1379: PPUSH
1380: LD_EXP 4
1384: PUSH
1385: LD_INT 4
1387: ARRAY
1388: PUSH
1389: LD_INT 1
1391: ARRAY
1392: PPUSH
1393: LD_INT 30
1395: PPUSH
1396: CALL 66065 0 5
// JMMNewVeh := CreateVehicle ;
1400: LD_ADDR_EXP 53
1404: PUSH
1405: CALL_OW 45
1409: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1410: LD_EXP 53
1414: PPUSH
1415: LD_INT 4
1417: PPUSH
1418: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1422: LD_EXP 53
1426: PPUSH
1427: LD_INT 75
1429: PPUSH
1430: LD_INT 92
1432: PPUSH
1433: LD_INT 0
1435: PPUSH
1436: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1440: LD_EXP 36
1444: PPUSH
1445: LD_EXP 53
1449: PPUSH
1450: CALL_OW 52
// if JMMGirl and not KappaStatus then
1454: LD_EXP 7
1458: PUSH
1459: LD_EXP 2
1463: NOT
1464: AND
1465: IFFALSE 1723
// begin if not JMMGirlVeh then
1467: LD_EXP 5
1471: NOT
1472: IFFALSE 1495
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1474: LD_INT 3
1476: PPUSH
1477: LD_INT 3
1479: PPUSH
1480: LD_INT 1
1482: PPUSH
1483: LD_INT 9
1485: PPUSH
1486: LD_INT 100
1488: PPUSH
1489: CALL 66065 0 5
1493: GO 1554
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1495: LD_EXP 5
1499: PUSH
1500: LD_INT 1
1502: ARRAY
1503: PUSH
1504: LD_INT 1
1506: ARRAY
1507: PPUSH
1508: LD_EXP 5
1512: PUSH
1513: LD_INT 2
1515: ARRAY
1516: PUSH
1517: LD_INT 1
1519: ARRAY
1520: PPUSH
1521: LD_EXP 5
1525: PUSH
1526: LD_INT 3
1528: ARRAY
1529: PUSH
1530: LD_INT 1
1532: ARRAY
1533: PPUSH
1534: LD_EXP 5
1538: PUSH
1539: LD_INT 4
1541: ARRAY
1542: PUSH
1543: LD_INT 1
1545: ARRAY
1546: PPUSH
1547: LD_INT 30
1549: PPUSH
1550: CALL 66065 0 5
// GirlNewVeh := CreateVehicle ;
1554: LD_ADDR_EXP 54
1558: PUSH
1559: CALL_OW 45
1563: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1564: LD_EXP 54
1568: PPUSH
1569: LD_INT 4
1571: PPUSH
1572: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1576: LD_EXP 54
1580: PPUSH
1581: LD_INT 82
1583: PPUSH
1584: LD_INT 96
1586: PPUSH
1587: LD_INT 0
1589: PPUSH
1590: CALL_OW 48
// if JMMGirl = 1 then
1594: LD_EXP 7
1598: PUSH
1599: LD_INT 1
1601: EQUAL
1602: IFFALSE 1637
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1604: LD_ADDR_EXP 37
1608: PUSH
1609: LD_STRING Joan
1611: PPUSH
1612: LD_INT 1
1614: PPUSH
1615: LD_STRING 14_
1617: PPUSH
1618: CALL 59432 0 3
1622: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1623: LD_EXP 37
1627: PPUSH
1628: LD_EXP 54
1632: PPUSH
1633: CALL_OW 52
// end ; if JMMGirl = 2 then
1637: LD_EXP 7
1641: PUSH
1642: LD_INT 2
1644: EQUAL
1645: IFFALSE 1680
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1647: LD_ADDR_EXP 39
1651: PUSH
1652: LD_STRING Lisa
1654: PPUSH
1655: LD_INT 1
1657: PPUSH
1658: LD_STRING 14_
1660: PPUSH
1661: CALL 59432 0 3
1665: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1666: LD_EXP 39
1670: PPUSH
1671: LD_EXP 54
1675: PPUSH
1676: CALL_OW 52
// end ; if JMMGirl = 3 then
1680: LD_EXP 7
1684: PUSH
1685: LD_INT 3
1687: EQUAL
1688: IFFALSE 1723
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
1690: LD_ADDR_EXP 51
1694: PUSH
1695: LD_STRING Connie
1697: PPUSH
1698: LD_INT 1
1700: PPUSH
1701: LD_STRING 14_
1703: PPUSH
1704: CALL 59432 0 3
1708: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
1709: LD_EXP 51
1713: PPUSH
1714: LD_EXP 54
1718: PPUSH
1719: CALL_OW 52
// end ; end ; end ;
1723: LD_VAR 0 1
1727: RET
// export function PrepareStevensSquad ; var tmp ; begin
1728: LD_INT 0
1730: PPUSH
1731: PPUSH
// uc_side := 1 ;
1732: LD_ADDR_OWVAR 20
1736: PUSH
1737: LD_INT 1
1739: ST_TO_ADDR
// uc_nation := 1 ;
1740: LD_ADDR_OWVAR 21
1744: PUSH
1745: LD_INT 1
1747: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
1748: LD_ADDR_EXP 38
1752: PUSH
1753: LD_STRING Stevens
1755: PPUSH
1756: LD_EXP 1
1760: NOT
1761: PPUSH
1762: LD_STRING 13f_
1764: PPUSH
1765: CALL 59432 0 3
1769: ST_TO_ADDR
// if not Stevens then
1770: LD_EXP 38
1774: NOT
1775: IFFALSE 1831
// begin hc_name = Baker Smith ;
1777: LD_ADDR_OWVAR 26
1781: PUSH
1782: LD_STRING Baker Smith
1784: ST_TO_ADDR
// hc_gallery =  ;
1785: LD_ADDR_OWVAR 33
1789: PUSH
1790: LD_STRING 
1792: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
1793: LD_INT 1
1795: PPUSH
1796: LD_INT 10
1798: PPUSH
1799: CALL_OW 384
// Baker = CreateHuman ;
1803: LD_ADDR_EXP 52
1807: PUSH
1808: CALL_OW 44
1812: ST_TO_ADDR
// tmp := tmp ^ Baker ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: LD_VAR 0 2
1822: PUSH
1823: LD_EXP 52
1827: ADD
1828: ST_TO_ADDR
// end else
1829: GO 1847
// tmp := tmp ^ Stevens ;
1831: LD_ADDR_VAR 0 2
1835: PUSH
1836: LD_VAR 0 2
1840: PUSH
1841: LD_EXP 38
1845: ADD
1846: ST_TO_ADDR
// if not Lisa then
1847: LD_EXP 39
1851: NOT
1852: IFFALSE 1898
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
1854: LD_ADDR_EXP 39
1858: PUSH
1859: LD_STRING Lisa
1861: PPUSH
1862: LD_EXP 1
1866: NOT
1867: PPUSH
1868: LD_STRING 13f_
1870: PPUSH
1871: CALL 59432 0 3
1875: ST_TO_ADDR
// if Lisa then
1876: LD_EXP 39
1880: IFFALSE 1898
// tmp := tmp ^ Lisa ;
1882: LD_ADDR_VAR 0 2
1886: PUSH
1887: LD_VAR 0 2
1891: PUSH
1892: LD_EXP 39
1896: ADD
1897: ST_TO_ADDR
// end ; if not Donaldson then
1898: LD_EXP 40
1902: NOT
1903: IFFALSE 1949
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
1905: LD_ADDR_EXP 40
1909: PUSH
1910: LD_STRING Donaldson
1912: PPUSH
1913: LD_EXP 1
1917: NOT
1918: PPUSH
1919: LD_STRING 13f_
1921: PPUSH
1922: CALL 59432 0 3
1926: ST_TO_ADDR
// if Donaldson then
1927: LD_EXP 40
1931: IFFALSE 1949
// tmp := tmp ^ Donaldson ;
1933: LD_ADDR_VAR 0 2
1937: PUSH
1938: LD_VAR 0 2
1942: PUSH
1943: LD_EXP 40
1947: ADD
1948: ST_TO_ADDR
// end ; if not Bobby then
1949: LD_EXP 41
1953: NOT
1954: IFFALSE 2000
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
1956: LD_ADDR_EXP 41
1960: PUSH
1961: LD_STRING Bobby
1963: PPUSH
1964: LD_EXP 1
1968: NOT
1969: PPUSH
1970: LD_STRING 13f_
1972: PPUSH
1973: CALL 59432 0 3
1977: ST_TO_ADDR
// if Bobby then
1978: LD_EXP 41
1982: IFFALSE 2000
// tmp := tmp ^ Bobby ;
1984: LD_ADDR_VAR 0 2
1988: PUSH
1989: LD_VAR 0 2
1993: PUSH
1994: LD_EXP 41
1998: ADD
1999: ST_TO_ADDR
// end ; if not Cyrus then
2000: LD_EXP 42
2004: NOT
2005: IFFALSE 2051
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2007: LD_ADDR_EXP 42
2011: PUSH
2012: LD_STRING Cyrus
2014: PPUSH
2015: LD_EXP 1
2019: NOT
2020: PPUSH
2021: LD_STRING 13f_
2023: PPUSH
2024: CALL 59432 0 3
2028: ST_TO_ADDR
// if Cyrus then
2029: LD_EXP 42
2033: IFFALSE 2051
// tmp := tmp ^ Cyrus ;
2035: LD_ADDR_VAR 0 2
2039: PUSH
2040: LD_VAR 0 2
2044: PUSH
2045: LD_EXP 42
2049: ADD
2050: ST_TO_ADDR
// end ; if not Brown then
2051: LD_EXP 44
2055: NOT
2056: IFFALSE 2102
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2058: LD_ADDR_EXP 44
2062: PUSH
2063: LD_STRING Brown
2065: PPUSH
2066: LD_EXP 1
2070: NOT
2071: PPUSH
2072: LD_STRING 13f_
2074: PPUSH
2075: CALL 59432 0 3
2079: ST_TO_ADDR
// if Brown then
2080: LD_EXP 44
2084: IFFALSE 2102
// tmp := tmp ^ Brown ;
2086: LD_ADDR_VAR 0 2
2090: PUSH
2091: LD_VAR 0 2
2095: PUSH
2096: LD_EXP 44
2100: ADD
2101: ST_TO_ADDR
// end ; if not Gladstone then
2102: LD_EXP 45
2106: NOT
2107: IFFALSE 2153
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2109: LD_ADDR_EXP 45
2113: PUSH
2114: LD_STRING Gladstone
2116: PPUSH
2117: LD_EXP 1
2121: NOT
2122: PPUSH
2123: LD_STRING 13f_
2125: PPUSH
2126: CALL 59432 0 3
2130: ST_TO_ADDR
// if Gladstone then
2131: LD_EXP 45
2135: IFFALSE 2153
// tmp := tmp ^ Gladstone ;
2137: LD_ADDR_VAR 0 2
2141: PUSH
2142: LD_VAR 0 2
2146: PUSH
2147: LD_EXP 45
2151: ADD
2152: ST_TO_ADDR
// end ; if not Houten then
2153: LD_EXP 46
2157: NOT
2158: IFFALSE 2204
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2160: LD_ADDR_EXP 46
2164: PUSH
2165: LD_STRING Houten
2167: PPUSH
2168: LD_EXP 1
2172: NOT
2173: PPUSH
2174: LD_STRING 13f_
2176: PPUSH
2177: CALL 59432 0 3
2181: ST_TO_ADDR
// if Houten then
2182: LD_EXP 46
2186: IFFALSE 2204
// tmp := tmp ^ Houten ;
2188: LD_ADDR_VAR 0 2
2192: PUSH
2193: LD_VAR 0 2
2197: PUSH
2198: LD_EXP 46
2202: ADD
2203: ST_TO_ADDR
// end ; if not Cornel then
2204: LD_EXP 47
2208: NOT
2209: IFFALSE 2255
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2211: LD_ADDR_EXP 47
2215: PUSH
2216: LD_STRING Cornel
2218: PPUSH
2219: LD_EXP 1
2223: NOT
2224: PPUSH
2225: LD_STRING 13f_
2227: PPUSH
2228: CALL 59432 0 3
2232: ST_TO_ADDR
// if Cornel then
2233: LD_EXP 47
2237: IFFALSE 2255
// tmp := tmp ^ Cornel ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 47
2253: ADD
2254: ST_TO_ADDR
// end ; if not Gary then
2255: LD_EXP 48
2259: NOT
2260: IFFALSE 2306
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2262: LD_ADDR_EXP 48
2266: PUSH
2267: LD_STRING Gary
2269: PPUSH
2270: LD_EXP 1
2274: NOT
2275: PPUSH
2276: LD_STRING 13f_
2278: PPUSH
2279: CALL 59432 0 3
2283: ST_TO_ADDR
// if Gary then
2284: LD_EXP 48
2288: IFFALSE 2306
// tmp := tmp ^ Gary ;
2290: LD_ADDR_VAR 0 2
2294: PUSH
2295: LD_VAR 0 2
2299: PUSH
2300: LD_EXP 48
2304: ADD
2305: ST_TO_ADDR
// end ; if not Frank then
2306: LD_EXP 49
2310: NOT
2311: IFFALSE 2357
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2313: LD_ADDR_EXP 49
2317: PUSH
2318: LD_STRING Frank
2320: PPUSH
2321: LD_EXP 1
2325: NOT
2326: PPUSH
2327: LD_STRING 13f_
2329: PPUSH
2330: CALL 59432 0 3
2334: ST_TO_ADDR
// if Frank then
2335: LD_EXP 49
2339: IFFALSE 2357
// tmp := tmp ^ Frank ;
2341: LD_ADDR_VAR 0 2
2345: PUSH
2346: LD_VAR 0 2
2350: PUSH
2351: LD_EXP 49
2355: ADD
2356: ST_TO_ADDR
// end ; if not Kikuchi then
2357: LD_EXP 50
2361: NOT
2362: IFFALSE 2408
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2364: LD_ADDR_EXP 50
2368: PUSH
2369: LD_STRING Kikuchi
2371: PPUSH
2372: LD_EXP 1
2376: NOT
2377: PPUSH
2378: LD_STRING 13f_
2380: PPUSH
2381: CALL 59432 0 3
2385: ST_TO_ADDR
// if Kikuchi then
2386: LD_EXP 50
2390: IFFALSE 2408
// tmp := tmp ^ Kikuchi ;
2392: LD_ADDR_VAR 0 2
2396: PUSH
2397: LD_VAR 0 2
2401: PUSH
2402: LD_EXP 50
2406: ADD
2407: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2408: LD_ADDR_VAR 0 2
2412: PUSH
2413: LD_VAR 0 2
2417: PUSH
2418: LD_STRING 13_other_survivors
2420: PPUSH
2421: CALL_OW 31
2425: UNION
2426: ST_TO_ADDR
// result := tmp ;
2427: LD_ADDR_VAR 0 1
2431: PUSH
2432: LD_VAR 0 2
2436: ST_TO_ADDR
// end ; end_of_file
2437: LD_VAR 0 1
2441: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2442: LD_INT 0
2444: PPUSH
2445: PPUSH
2446: PPUSH
2447: PPUSH
2448: PPUSH
2449: PPUSH
2450: PPUSH
2451: PPUSH
2452: PPUSH
2453: PPUSH
// uc_side := 4 ;
2454: LD_ADDR_OWVAR 20
2458: PUSH
2459: LD_INT 4
2461: ST_TO_ADDR
// uc_nation := 1 ;
2462: LD_ADDR_OWVAR 21
2466: PUSH
2467: LD_INT 1
2469: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2470: LD_INT 387
2472: PPUSH
2473: CALL_OW 274
2477: PPUSH
2478: LD_INT 1
2480: PPUSH
2481: LD_INT 2500
2483: PPUSH
2484: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2488: LD_INT 387
2490: PPUSH
2491: CALL_OW 274
2495: PPUSH
2496: LD_INT 2
2498: PPUSH
2499: LD_INT 400
2501: PPUSH
2502: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2506: LD_INT 387
2508: PPUSH
2509: CALL_OW 274
2513: PPUSH
2514: LD_INT 3
2516: PPUSH
2517: LD_INT 10
2519: PPUSH
2520: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2524: LD_ADDR_EXP 55
2528: PUSH
2529: LD_STRING Powell
2531: PPUSH
2532: CALL_OW 25
2536: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2537: LD_EXP 55
2541: PPUSH
2542: LD_INT 57
2544: PPUSH
2545: LD_INT 94
2547: PPUSH
2548: LD_INT 0
2550: PPUSH
2551: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2555: LD_EXP 55
2559: PPUSH
2560: LD_INT 58
2562: PPUSH
2563: LD_INT 94
2565: PPUSH
2566: CALL_OW 118
// vip := [ ] ;
2570: LD_ADDR_EXP 56
2574: PUSH
2575: EMPTY
2576: ST_TO_ADDR
// tmp := [ ] ;
2577: LD_ADDR_VAR 0 6
2581: PUSH
2582: EMPTY
2583: ST_TO_ADDR
// if JMMGirl <> 2 then
2584: LD_EXP 7
2588: PUSH
2589: LD_INT 2
2591: NONEQUAL
2592: IFFALSE 2616
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2594: LD_ADDR_EXP 39
2598: PUSH
2599: LD_STRING Lisa
2601: PPUSH
2602: LD_EXP 1
2606: NOT
2607: PPUSH
2608: LD_STRING 13s_
2610: PPUSH
2611: CALL 59432 0 3
2615: ST_TO_ADDR
// if Lisa then
2616: LD_EXP 39
2620: IFFALSE 2638
// tmp := tmp ^ Lisa ;
2622: LD_ADDR_VAR 0 6
2626: PUSH
2627: LD_VAR 0 6
2631: PUSH
2632: LD_EXP 39
2636: ADD
2637: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2638: LD_ADDR_EXP 40
2642: PUSH
2643: LD_STRING Donaldson
2645: PPUSH
2646: LD_EXP 1
2650: NOT
2651: PPUSH
2652: LD_STRING 13s_
2654: PPUSH
2655: CALL 59432 0 3
2659: ST_TO_ADDR
// if Donaldson then
2660: LD_EXP 40
2664: IFFALSE 2682
// tmp := tmp ^ Donaldson ;
2666: LD_ADDR_VAR 0 6
2670: PUSH
2671: LD_VAR 0 6
2675: PUSH
2676: LD_EXP 40
2680: ADD
2681: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
2682: LD_ADDR_EXP 41
2686: PUSH
2687: LD_STRING Bobby
2689: PPUSH
2690: LD_EXP 1
2694: NOT
2695: PPUSH
2696: LD_STRING 13s_
2698: PPUSH
2699: CALL 59432 0 3
2703: ST_TO_ADDR
// if Bobby then
2704: LD_EXP 41
2708: IFFALSE 2726
// tmp := tmp ^ Bobby ;
2710: LD_ADDR_VAR 0 6
2714: PUSH
2715: LD_VAR 0 6
2719: PUSH
2720: LD_EXP 41
2724: ADD
2725: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
2726: LD_ADDR_EXP 42
2730: PUSH
2731: LD_STRING Cyrus
2733: PPUSH
2734: LD_EXP 1
2738: NOT
2739: PPUSH
2740: LD_STRING 13s_
2742: PPUSH
2743: CALL 59432 0 3
2747: ST_TO_ADDR
// if Cyrus then
2748: LD_EXP 42
2752: IFFALSE 2770
// tmp := tmp ^ Cyrus ;
2754: LD_ADDR_VAR 0 6
2758: PUSH
2759: LD_VAR 0 6
2763: PUSH
2764: LD_EXP 42
2768: ADD
2769: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
2770: LD_ADDR_EXP 43
2774: PUSH
2775: LD_STRING Denis
2777: PPUSH
2778: LD_EXP 1
2782: NOT
2783: PPUSH
2784: LD_STRING 13s_
2786: PPUSH
2787: CALL 59432 0 3
2791: ST_TO_ADDR
// if not Denis then
2792: LD_EXP 43
2796: NOT
2797: IFFALSE 2821
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
2799: LD_ADDR_EXP 43
2803: PUSH
2804: LD_STRING Denis
2806: PPUSH
2807: LD_EXP 1
2811: NOT
2812: PPUSH
2813: LD_STRING 13f_
2815: PPUSH
2816: CALL 59432 0 3
2820: ST_TO_ADDR
// if Denis then
2821: LD_EXP 43
2825: IFFALSE 2843
// tmp := tmp ^ Denis ;
2827: LD_ADDR_VAR 0 6
2831: PUSH
2832: LD_VAR 0 6
2836: PUSH
2837: LD_EXP 43
2841: ADD
2842: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
2843: LD_ADDR_EXP 44
2847: PUSH
2848: LD_STRING Brown
2850: PPUSH
2851: LD_EXP 1
2855: NOT
2856: PPUSH
2857: LD_STRING 13s_
2859: PPUSH
2860: CALL 59432 0 3
2864: ST_TO_ADDR
// if Brown then
2865: LD_EXP 44
2869: IFFALSE 2887
// tmp := tmp ^ Brown ;
2871: LD_ADDR_VAR 0 6
2875: PUSH
2876: LD_VAR 0 6
2880: PUSH
2881: LD_EXP 44
2885: ADD
2886: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
2887: LD_ADDR_EXP 45
2891: PUSH
2892: LD_STRING Gladstone
2894: PPUSH
2895: LD_EXP 1
2899: NOT
2900: PPUSH
2901: LD_STRING 13s_
2903: PPUSH
2904: CALL 59432 0 3
2908: ST_TO_ADDR
// if Gladstone then
2909: LD_EXP 45
2913: IFFALSE 2931
// tmp := tmp ^ Gladstone ;
2915: LD_ADDR_VAR 0 6
2919: PUSH
2920: LD_VAR 0 6
2924: PUSH
2925: LD_EXP 45
2929: ADD
2930: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
2931: LD_ADDR_EXP 46
2935: PUSH
2936: LD_STRING Houten
2938: PPUSH
2939: LD_EXP 1
2943: NOT
2944: PPUSH
2945: LD_STRING 13s_
2947: PPUSH
2948: CALL 59432 0 3
2952: ST_TO_ADDR
// if Houten then
2953: LD_EXP 46
2957: IFFALSE 2975
// tmp := tmp ^ Houten ;
2959: LD_ADDR_VAR 0 6
2963: PUSH
2964: LD_VAR 0 6
2968: PUSH
2969: LD_EXP 46
2973: ADD
2974: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
2975: LD_ADDR_EXP 47
2979: PUSH
2980: LD_STRING Cornel
2982: PPUSH
2983: LD_EXP 1
2987: NOT
2988: PPUSH
2989: LD_STRING 13s_
2991: PPUSH
2992: CALL 59432 0 3
2996: ST_TO_ADDR
// if Cornel then
2997: LD_EXP 47
3001: IFFALSE 3019
// tmp := tmp ^ Cornel ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: LD_VAR 0 6
3012: PUSH
3013: LD_EXP 47
3017: ADD
3018: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3019: LD_ADDR_EXP 48
3023: PUSH
3024: LD_STRING Gary
3026: PPUSH
3027: LD_EXP 1
3031: NOT
3032: PPUSH
3033: LD_STRING 13s_
3035: PPUSH
3036: CALL 59432 0 3
3040: ST_TO_ADDR
// if Gary then
3041: LD_EXP 48
3045: IFFALSE 3063
// tmp := tmp ^ Gary ;
3047: LD_ADDR_VAR 0 6
3051: PUSH
3052: LD_VAR 0 6
3056: PUSH
3057: LD_EXP 48
3061: ADD
3062: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 49
3067: PUSH
3068: LD_STRING Frank
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 59432 0 3
3084: ST_TO_ADDR
// if Frank then
3085: LD_EXP 49
3089: IFFALSE 3107
// tmp := tmp ^ Frank ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 49
3105: ADD
3106: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 50
3111: PUSH
3112: LD_STRING Kikuchi
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 59432 0 3
3128: ST_TO_ADDR
// if Kikuchi then
3129: LD_EXP 50
3133: IFFALSE 3151
// tmp := tmp ^ Kikuchi ;
3135: LD_ADDR_VAR 0 6
3139: PUSH
3140: LD_VAR 0 6
3144: PUSH
3145: LD_EXP 50
3149: ADD
3150: ST_TO_ADDR
// vip := tmp ;
3151: LD_ADDR_EXP 56
3155: PUSH
3156: LD_VAR 0 6
3160: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3161: LD_ADDR_VAR 0 6
3165: PUSH
3166: LD_VAR 0 6
3170: PUSH
3171: LD_STRING 13s_others
3173: PPUSH
3174: CALL_OW 31
3178: UNION
3179: ST_TO_ADDR
// if tmp < 20 then
3180: LD_VAR 0 6
3184: PUSH
3185: LD_INT 20
3187: LESS
3188: IFFALSE 3255
// for i = 1 to 20 - tmp do
3190: LD_ADDR_VAR 0 2
3194: PUSH
3195: DOUBLE
3196: LD_INT 1
3198: DEC
3199: ST_TO_ADDR
3200: LD_INT 20
3202: PUSH
3203: LD_VAR 0 6
3207: MINUS
3208: PUSH
3209: FOR_TO
3210: IFFALSE 3253
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3212: LD_INT 1
3214: PPUSH
3215: LD_VAR 0 2
3219: PUSH
3220: LD_INT 4
3222: MOD
3223: PUSH
3224: LD_INT 1
3226: PLUS
3227: PPUSH
3228: LD_INT 5
3230: PPUSH
3231: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3235: LD_ADDR_VAR 0 6
3239: PUSH
3240: LD_VAR 0 6
3244: PUSH
3245: CALL_OW 44
3249: ADD
3250: ST_TO_ADDR
// end ;
3251: GO 3209
3253: POP
3254: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3255: LD_ADDR_VAR 0 7
3259: PUSH
3260: LD_INT 22
3262: PUSH
3263: LD_INT 4
3265: PUSH
3266: EMPTY
3267: LIST
3268: LIST
3269: PUSH
3270: LD_INT 30
3272: PUSH
3273: LD_INT 0
3275: PUSH
3276: EMPTY
3277: LIST
3278: LIST
3279: PUSH
3280: EMPTY
3281: LIST
3282: LIST
3283: PPUSH
3284: CALL_OW 69
3288: PUSH
3289: LD_INT 1
3291: ARRAY
3292: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3293: LD_ADDR_VAR 0 8
3297: PUSH
3298: LD_INT 22
3300: PUSH
3301: LD_INT 4
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: LD_INT 30
3310: PUSH
3311: LD_INT 6
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: LD_INT 1
3329: ARRAY
3330: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3331: LD_ADDR_VAR 0 9
3335: PUSH
3336: LD_INT 22
3338: PUSH
3339: LD_INT 4
3341: PUSH
3342: EMPTY
3343: LIST
3344: LIST
3345: PUSH
3346: LD_INT 30
3348: PUSH
3349: LD_INT 4
3351: PUSH
3352: EMPTY
3353: LIST
3354: LIST
3355: PUSH
3356: EMPTY
3357: LIST
3358: LIST
3359: PPUSH
3360: CALL_OW 69
3364: PUSH
3365: LD_INT 1
3367: ARRAY
3368: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3369: LD_ADDR_VAR 0 10
3373: PUSH
3374: LD_INT 22
3376: PUSH
3377: LD_INT 4
3379: PUSH
3380: EMPTY
3381: LIST
3382: LIST
3383: PUSH
3384: LD_INT 30
3386: PUSH
3387: LD_INT 2
3389: PUSH
3390: EMPTY
3391: LIST
3392: LIST
3393: PUSH
3394: EMPTY
3395: LIST
3396: LIST
3397: PPUSH
3398: CALL_OW 69
3402: PUSH
3403: LD_INT 1
3405: ARRAY
3406: ST_TO_ADDR
// for i in tmp do
3407: LD_ADDR_VAR 0 2
3411: PUSH
3412: LD_VAR 0 6
3416: PUSH
3417: FOR_IN
3418: IFFALSE 3544
// begin cl := GetClass ( i ) ;
3420: LD_ADDR_VAR 0 5
3424: PUSH
3425: LD_VAR 0 2
3429: PPUSH
3430: CALL_OW 257
3434: ST_TO_ADDR
// if cl > 4 then
3435: LD_VAR 0 5
3439: PUSH
3440: LD_INT 4
3442: GREATER
3443: IFFALSE 3453
// cl := 1 ;
3445: LD_ADDR_VAR 0 5
3449: PUSH
3450: LD_INT 1
3452: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3453: LD_ADDR_VAR 0 3
3457: PUSH
3458: LD_VAR 0 9
3462: PUSH
3463: LD_VAR 0 7
3467: PUSH
3468: LD_VAR 0 10
3472: PUSH
3473: LD_VAR 0 8
3477: PUSH
3478: EMPTY
3479: LIST
3480: LIST
3481: LIST
3482: LIST
3483: PUSH
3484: LD_VAR 0 5
3488: ARRAY
3489: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3490: LD_VAR 0 3
3494: PPUSH
3495: CALL_OW 313
3499: PUSH
3500: LD_INT 5
3502: LESS
3503: IFFALSE 3521
// PlaceHumanInUnit ( i , b ) else
3505: LD_VAR 0 2
3509: PPUSH
3510: LD_VAR 0 3
3514: PPUSH
3515: CALL_OW 52
3519: GO 3542
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3521: LD_VAR 0 2
3525: PPUSH
3526: LD_INT 58
3528: PPUSH
3529: LD_INT 91
3531: PPUSH
3532: LD_INT 6
3534: PPUSH
3535: LD_INT 0
3537: PPUSH
3538: CALL_OW 50
// end ;
3542: GO 3417
3544: POP
3545: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3546: LD_INT 2
3548: PPUSH
3549: LD_INT 1
3551: PPUSH
3552: LD_INT 1
3554: PPUSH
3555: LD_INT 12
3557: PPUSH
3558: LD_INT 100
3560: PPUSH
3561: CALL 66065 0 5
// veh := CreateVehicle ;
3565: LD_ADDR_VAR 0 4
3569: PUSH
3570: CALL_OW 45
3574: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3575: LD_VAR 0 4
3579: PPUSH
3580: LD_INT 4
3582: PPUSH
3583: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3587: LD_VAR 0 4
3591: PPUSH
3592: LD_INT 49
3594: PPUSH
3595: LD_INT 88
3597: PPUSH
3598: LD_INT 0
3600: PPUSH
3601: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3605: LD_VAR 0 4
3609: PPUSH
3610: LD_INT 1
3612: PPUSH
3613: LD_INT 100
3615: PPUSH
3616: CALL_OW 290
// uc_side := 0 ;
3620: LD_ADDR_OWVAR 20
3624: PUSH
3625: LD_INT 0
3627: ST_TO_ADDR
// uc_nation := 0 ;
3628: LD_ADDR_OWVAR 21
3632: PUSH
3633: LD_INT 0
3635: ST_TO_ADDR
// for i = 1 to 4 do
3636: LD_ADDR_VAR 0 2
3640: PUSH
3641: DOUBLE
3642: LD_INT 1
3644: DEC
3645: ST_TO_ADDR
3646: LD_INT 4
3648: PUSH
3649: FOR_TO
3650: IFFALSE 3681
// begin InitHc ;
3652: CALL_OW 19
// hc_class := class_apeman ;
3656: LD_ADDR_OWVAR 28
3660: PUSH
3661: LD_INT 12
3663: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
3664: CALL_OW 44
3668: PPUSH
3669: LD_INT 13
3671: PPUSH
3672: LD_INT 0
3674: PPUSH
3675: CALL_OW 49
// end ;
3679: GO 3649
3681: POP
3682: POP
// end ; end_of_file
3683: LD_VAR 0 1
3687: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
3688: LD_INT 0
3690: PPUSH
3691: PPUSH
3692: PPUSH
3693: PPUSH
3694: PPUSH
// side := 8 ;
3695: LD_ADDR_VAR 0 3
3699: PUSH
3700: LD_INT 8
3702: ST_TO_ADDR
// uc_side := side ;
3703: LD_ADDR_OWVAR 20
3707: PUSH
3708: LD_VAR 0 3
3712: ST_TO_ADDR
// uc_nation := 2 ;
3713: LD_ADDR_OWVAR 21
3717: PUSH
3718: LD_INT 2
3720: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
3721: LD_ADDR_VAR 0 2
3725: PUSH
3726: LD_INT 22
3728: PUSH
3729: LD_VAR 0 3
3733: PUSH
3734: EMPTY
3735: LIST
3736: LIST
3737: PUSH
3738: LD_INT 21
3740: PUSH
3741: LD_INT 3
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: EMPTY
3749: LIST
3750: LIST
3751: PPUSH
3752: CALL_OW 69
3756: PUSH
3757: FOR_IN
3758: IFFALSE 3774
// SetBLevel ( i , 10 ) ;
3760: LD_VAR 0 2
3764: PPUSH
3765: LD_INT 10
3767: PPUSH
3768: CALL_OW 241
3772: GO 3757
3774: POP
3775: POP
// if KurtStatus then
3776: LD_EXP 3
3780: IFFALSE 3803
// Kurt := PrepareUnit ( Kurt , false ,  ) else
3782: LD_ADDR_EXP 57
3786: PUSH
3787: LD_STRING Kurt
3789: PPUSH
3790: LD_INT 0
3792: PPUSH
3793: LD_STRING 
3795: PPUSH
3796: CALL 59432 0 3
3800: ST_TO_ADDR
3801: GO 3825
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
3803: LD_ADDR_EXP 57
3807: PUSH
3808: LD_STRING AltKurt
3810: PPUSH
3811: LD_EXP 1
3815: NOT
3816: PPUSH
3817: LD_STRING 
3819: PPUSH
3820: CALL 59432 0 3
3824: ST_TO_ADDR
// if not Kurt then
3825: LD_EXP 57
3829: NOT
3830: IFFALSE 3856
// begin InitHc ;
3832: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
3836: LD_INT 1
3838: PPUSH
3839: LD_INT 10
3841: PPUSH
3842: CALL_OW 381
// Kurt := CreateHuman ;
3846: LD_ADDR_EXP 57
3850: PUSH
3851: CALL_OW 44
3855: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
3856: LD_EXP 57
3860: PPUSH
3861: LD_INT 324
3863: PPUSH
3864: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
3868: LD_ADDR_EXP 58
3872: PUSH
3873: LD_STRING Kozlov
3875: PPUSH
3876: LD_INT 0
3878: PPUSH
3879: LD_STRING 
3881: PPUSH
3882: CALL 59432 0 3
3886: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
3887: LD_EXP 58
3891: PPUSH
3892: LD_INT 22
3894: PUSH
3895: LD_INT 8
3897: PUSH
3898: EMPTY
3899: LIST
3900: LIST
3901: PUSH
3902: LD_INT 23
3904: PUSH
3905: LD_INT 3
3907: PUSH
3908: EMPTY
3909: LIST
3910: LIST
3911: PUSH
3912: LD_INT 30
3914: PUSH
3915: LD_INT 8
3917: PUSH
3918: EMPTY
3919: LIST
3920: LIST
3921: PUSH
3922: EMPTY
3923: LIST
3924: LIST
3925: LIST
3926: PPUSH
3927: CALL_OW 69
3931: PUSH
3932: LD_INT 1
3934: ARRAY
3935: PPUSH
3936: CALL_OW 52
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
3940: LD_ADDR_VAR 0 5
3944: PUSH
3945: LD_INT 22
3947: PUSH
3948: LD_VAR 0 3
3952: PUSH
3953: EMPTY
3954: LIST
3955: LIST
3956: PUSH
3957: LD_INT 30
3959: PUSH
3960: LD_INT 32
3962: PUSH
3963: EMPTY
3964: LIST
3965: LIST
3966: PUSH
3967: LD_INT 58
3969: PUSH
3970: EMPTY
3971: LIST
3972: PUSH
3973: EMPTY
3974: LIST
3975: LIST
3976: LIST
3977: PPUSH
3978: CALL_OW 69
3982: ST_TO_ADDR
// for i = 1 to 10 do
3983: LD_ADDR_VAR 0 2
3987: PUSH
3988: DOUBLE
3989: LD_INT 1
3991: DEC
3992: ST_TO_ADDR
3993: LD_INT 10
3995: PUSH
3996: FOR_TO
3997: IFFALSE 4069
// begin uc_nation := nation_nature ;
3999: LD_ADDR_OWVAR 21
4003: PUSH
4004: LD_INT 0
4006: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4007: LD_ADDR_OWVAR 28
4011: PUSH
4012: LD_INT 15
4014: ST_TO_ADDR
// hc_gallery :=  ;
4015: LD_ADDR_OWVAR 33
4019: PUSH
4020: LD_STRING 
4022: ST_TO_ADDR
// hc_name :=  ;
4023: LD_ADDR_OWVAR 26
4027: PUSH
4028: LD_STRING 
4030: ST_TO_ADDR
// un := CreateHuman ;
4031: LD_ADDR_VAR 0 4
4035: PUSH
4036: CALL_OW 44
4040: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4041: LD_VAR 0 4
4045: PPUSH
4046: LD_VAR 0 5
4050: PUSH
4051: LD_VAR 0 5
4055: PUSH
4056: LD_VAR 0 2
4060: MINUS
4061: ARRAY
4062: PPUSH
4063: CALL_OW 52
// end ;
4067: GO 3996
4069: POP
4070: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4071: LD_ADDR_VAR 0 5
4075: PUSH
4076: LD_STRING 12_kurt_squad
4078: PPUSH
4079: CALL_OW 31
4083: ST_TO_ADDR
// if tmp then
4084: LD_VAR 0 5
4088: IFFALSE 4122
// for i in tmp do
4090: LD_ADDR_VAR 0 2
4094: PUSH
4095: LD_VAR 0 5
4099: PUSH
4100: FOR_IN
4101: IFFALSE 4120
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4103: LD_VAR 0 2
4107: PPUSH
4108: LD_INT 5
4110: PPUSH
4111: LD_INT 0
4113: PPUSH
4114: CALL_OW 49
4118: GO 4100
4120: POP
4121: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 12 , 6 , 6 , 8 ] ) ;
4122: LD_INT 324
4124: PPUSH
4125: LD_INT 5
4127: PPUSH
4128: LD_STRING 
4130: PPUSH
4131: LD_INT 8
4133: PUSH
4134: LD_INT 9
4136: PUSH
4137: LD_INT 10
4139: PUSH
4140: EMPTY
4141: LIST
4142: LIST
4143: LIST
4144: PUSH
4145: LD_OWVAR 67
4149: ARRAY
4150: PPUSH
4151: LD_INT 3000
4153: PUSH
4154: LD_INT 500
4156: PUSH
4157: LD_INT 150
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: LIST
4164: PPUSH
4165: LD_INT 12
4167: PUSH
4168: LD_INT 6
4170: PUSH
4171: LD_INT 6
4173: PUSH
4174: LD_INT 8
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: LIST
4181: LIST
4182: PPUSH
4183: CALL 69474 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4187: LD_ADDR_EXP 99
4191: PUSH
4192: LD_EXP 99
4196: PPUSH
4197: LD_INT 3
4199: PPUSH
4200: LD_INT 22
4202: PUSH
4203: LD_VAR 0 3
4207: PUSH
4208: EMPTY
4209: LIST
4210: LIST
4211: PUSH
4212: LD_INT 23
4214: PUSH
4215: LD_INT 2
4217: PUSH
4218: EMPTY
4219: LIST
4220: LIST
4221: PUSH
4222: LD_INT 3
4224: PUSH
4225: LD_INT 21
4227: PUSH
4228: LD_INT 2
4230: PUSH
4231: EMPTY
4232: LIST
4233: LIST
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: EMPTY
4240: LIST
4241: LIST
4242: LIST
4243: PPUSH
4244: CALL_OW 69
4248: PUSH
4249: LD_EXP 57
4253: DIFF
4254: PPUSH
4255: CALL_OW 1
4259: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4260: LD_INT 1
4262: PPUSH
4263: LD_INT 7
4265: PPUSH
4266: CALL_OW 383
// Friend := CreateHuman ;
4270: LD_ADDR_EXP 59
4274: PUSH
4275: CALL_OW 44
4279: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4280: LD_INT 14
4282: PPUSH
4283: LD_INT 3
4285: PPUSH
4286: LD_INT 1
4288: PPUSH
4289: LD_INT 29
4291: PPUSH
4292: LD_INT 100
4294: PPUSH
4295: CALL 66065 0 5
// powellBomb := CreateVehicle ;
4299: LD_ADDR_EXP 60
4303: PUSH
4304: CALL_OW 45
4308: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4309: LD_EXP 60
4313: PPUSH
4314: LD_INT 90
4316: PPUSH
4317: LD_INT 51
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 48
// end ;
4327: LD_VAR 0 1
4331: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4332: LD_INT 0
4334: PPUSH
4335: PPUSH
4336: PPUSH
// if IsLive ( kozlov_fac ) then
4337: LD_INT 332
4339: PPUSH
4340: CALL_OW 300
4344: IFFALSE 4348
// exit ;
4346: GO 4915
// ComExitBuilding ( Kozlov ) ;
4348: LD_EXP 58
4352: PPUSH
4353: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4357: LD_EXP 58
4361: PPUSH
4362: CALL_OW 257
4366: PUSH
4367: LD_INT 2
4369: NONEQUAL
4370: IFFALSE 4405
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4372: LD_EXP 58
4376: PPUSH
4377: LD_INT 324
4379: PPUSH
4380: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4384: LD_EXP 58
4388: PPUSH
4389: LD_INT 2
4391: PPUSH
4392: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4396: LD_EXP 58
4400: PPUSH
4401: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4405: LD_EXP 58
4409: PPUSH
4410: LD_INT 2
4412: PPUSH
4413: LD_INT 93
4415: PPUSH
4416: LD_INT 32
4418: PPUSH
4419: LD_INT 3
4421: PPUSH
4422: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4426: LD_INT 35
4428: PPUSH
4429: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4433: LD_INT 22
4435: PUSH
4436: LD_INT 8
4438: PUSH
4439: EMPTY
4440: LIST
4441: LIST
4442: PUSH
4443: LD_INT 30
4445: PUSH
4446: LD_INT 3
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PUSH
4453: LD_INT 23
4455: PUSH
4456: LD_INT 3
4458: PUSH
4459: EMPTY
4460: LIST
4461: LIST
4462: PUSH
4463: LD_INT 57
4465: PUSH
4466: EMPTY
4467: LIST
4468: PUSH
4469: EMPTY
4470: LIST
4471: LIST
4472: LIST
4473: LIST
4474: PPUSH
4475: CALL_OW 69
4479: IFFALSE 4426
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4481: LD_ADDR_VAR 0 2
4485: PUSH
4486: LD_INT 22
4488: PUSH
4489: LD_INT 8
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: PUSH
4496: LD_INT 30
4498: PUSH
4499: LD_INT 3
4501: PUSH
4502: EMPTY
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 23
4508: PUSH
4509: LD_INT 3
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: PUSH
4516: LD_INT 57
4518: PUSH
4519: EMPTY
4520: LIST
4521: PUSH
4522: EMPTY
4523: LIST
4524: LIST
4525: LIST
4526: LIST
4527: PPUSH
4528: CALL_OW 69
4532: PUSH
4533: LD_INT 1
4535: ARRAY
4536: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4537: LD_INT 22
4539: PUSH
4540: LD_INT 8
4542: PUSH
4543: EMPTY
4544: LIST
4545: LIST
4546: PUSH
4547: LD_INT 23
4549: PUSH
4550: LD_INT 3
4552: PUSH
4553: EMPTY
4554: LIST
4555: LIST
4556: PUSH
4557: LD_INT 30
4559: PUSH
4560: LD_INT 21
4562: PUSH
4563: EMPTY
4564: LIST
4565: LIST
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PPUSH
4572: CALL_OW 69
4576: NOT
4577: IFFALSE 4655
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4579: LD_EXP 58
4583: PPUSH
4584: LD_INT 21
4586: PPUSH
4587: LD_INT 97
4589: PPUSH
4590: LD_INT 36
4592: PPUSH
4593: LD_INT 5
4595: PPUSH
4596: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4600: LD_INT 35
4602: PPUSH
4603: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4607: LD_INT 22
4609: PUSH
4610: LD_INT 8
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: PUSH
4617: LD_INT 23
4619: PUSH
4620: LD_INT 3
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PUSH
4627: LD_INT 30
4629: PUSH
4630: LD_INT 21
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PUSH
4637: LD_INT 57
4639: PUSH
4640: EMPTY
4641: LIST
4642: PUSH
4643: EMPTY
4644: LIST
4645: LIST
4646: LIST
4647: LIST
4648: PPUSH
4649: CALL_OW 69
4653: IFFALSE 4600
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
4655: LD_INT 22
4657: PUSH
4658: LD_INT 8
4660: PUSH
4661: EMPTY
4662: LIST
4663: LIST
4664: PUSH
4665: LD_INT 23
4667: PUSH
4668: LD_INT 3
4670: PUSH
4671: EMPTY
4672: LIST
4673: LIST
4674: PUSH
4675: LD_INT 30
4677: PUSH
4678: LD_INT 18
4680: PUSH
4681: EMPTY
4682: LIST
4683: LIST
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: PPUSH
4690: CALL_OW 69
4694: NOT
4695: IFFALSE 4773
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
4697: LD_EXP 58
4701: PPUSH
4702: LD_INT 18
4704: PPUSH
4705: LD_INT 89
4707: PPUSH
4708: LD_INT 32
4710: PPUSH
4711: LD_INT 1
4713: PPUSH
4714: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4718: LD_INT 35
4720: PPUSH
4721: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
4725: LD_INT 22
4727: PUSH
4728: LD_INT 8
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 23
4737: PUSH
4738: LD_INT 3
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 30
4747: PUSH
4748: LD_INT 18
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: PUSH
4755: LD_INT 57
4757: PUSH
4758: EMPTY
4759: LIST
4760: PUSH
4761: EMPTY
4762: LIST
4763: LIST
4764: LIST
4765: LIST
4766: PPUSH
4767: CALL_OW 69
4771: IFFALSE 4718
// end ; lab := kozlov_lab ;
4773: LD_ADDR_VAR 0 3
4777: PUSH
4778: LD_INT 336
4780: ST_TO_ADDR
// if not lab then
4781: LD_VAR 0 3
4785: NOT
4786: IFFALSE 4790
// exit ;
4788: GO 4915
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
4790: LD_EXP 58
4794: PPUSH
4795: LD_VAR 0 3
4799: PUSH
4800: LD_INT 1
4802: ARRAY
4803: PPUSH
4804: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
4808: LD_EXP 58
4812: PPUSH
4813: LD_INT 4
4815: PPUSH
4816: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
4820: LD_VAR 0 3
4824: PUSH
4825: LD_INT 1
4827: ARRAY
4828: PPUSH
4829: LD_INT 25
4831: PPUSH
4832: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
4836: LD_INT 35
4838: PPUSH
4839: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
4843: LD_INT 25
4845: PPUSH
4846: LD_INT 8
4848: PPUSH
4849: CALL_OW 321
4853: PUSH
4854: LD_INT 2
4856: EQUAL
4857: IFFALSE 4836
// ComExitBuilding ( Kozlov ) ;
4859: LD_EXP 58
4863: PPUSH
4864: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
4868: LD_EXP 58
4872: PPUSH
4873: LD_VAR 0 2
4877: PPUSH
4878: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
4882: LD_EXP 58
4886: PPUSH
4887: LD_INT 3
4889: PPUSH
4890: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
4894: LD_VAR 0 2
4898: PPUSH
4899: LD_INT 23
4901: PPUSH
4902: LD_INT 3
4904: PPUSH
4905: LD_INT 1
4907: PPUSH
4908: LD_INT 48
4910: PPUSH
4911: CALL_OW 125
// end ;
4915: LD_VAR 0 1
4919: RET
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 do var i , tmp , target ;
4920: LD_EXP 22
4924: NOT
4925: PUSH
4926: LD_EXP 15
4930: PUSH
4931: LD_INT 6
4933: GREATEREQUAL
4934: AND
4935: IFFALSE 5619
4937: GO 4939
4939: DISABLE
4940: LD_INT 0
4942: PPUSH
4943: PPUSH
4944: PPUSH
// begin enable ;
4945: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
4946: LD_INT 22
4948: PUSH
4949: LD_INT 8
4951: PUSH
4952: EMPTY
4953: LIST
4954: LIST
4955: PUSH
4956: LD_INT 23
4958: PUSH
4959: LD_INT 2
4961: PUSH
4962: EMPTY
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 30
4968: PUSH
4969: LD_INT 3
4971: PUSH
4972: EMPTY
4973: LIST
4974: LIST
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: LIST
4980: PPUSH
4981: CALL_OW 69
4985: NOT
4986: IFFALSE 4990
// exit ;
4988: GO 5619
// if Prob ( 40 ) then
4990: LD_INT 40
4992: PPUSH
4993: CALL_OW 13
4997: IFFALSE 5124
// begin MC_InsertProduceList ( 3 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
4999: LD_INT 3
5001: PPUSH
5002: LD_INT 13
5004: PUSH
5005: LD_INT 1
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: LD_INT 28
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: PUSH
5020: LD_INT 13
5022: PUSH
5023: LD_INT 1
5025: PUSH
5026: LD_INT 2
5028: PUSH
5029: LD_INT 28
5031: PUSH
5032: EMPTY
5033: LIST
5034: LIST
5035: LIST
5036: LIST
5037: PUSH
5038: LD_INT 13
5040: PUSH
5041: LD_INT 1
5043: PUSH
5044: LD_INT 2
5046: PUSH
5047: LD_INT 28
5049: PUSH
5050: EMPTY
5051: LIST
5052: LIST
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 13
5058: PUSH
5059: LD_INT 1
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: LD_INT 28
5067: PUSH
5068: EMPTY
5069: LIST
5070: LIST
5071: LIST
5072: LIST
5073: PUSH
5074: LD_INT 13
5076: PUSH
5077: LD_INT 1
5079: PUSH
5080: LD_INT 2
5082: PUSH
5083: LD_INT 28
5085: PUSH
5086: EMPTY
5087: LIST
5088: LIST
5089: LIST
5090: LIST
5091: PUSH
5092: LD_INT 13
5094: PUSH
5095: LD_INT 1
5097: PUSH
5098: LD_INT 2
5100: PUSH
5101: LD_INT 26
5103: PUSH
5104: EMPTY
5105: LIST
5106: LIST
5107: LIST
5108: LIST
5109: PUSH
5110: EMPTY
5111: LIST
5112: LIST
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: PPUSH
5118: CALL 53537 0 2
// end else
5122: GO 5315
// begin MC_InsertProduceList ( 3 , [ [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5124: LD_INT 3
5126: PPUSH
5127: LD_INT 13
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 27
5138: PUSH
5139: LD_INT 26
5141: PUSH
5142: LD_INT 26
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: LIST
5149: PUSH
5150: LD_OWVAR 67
5154: ARRAY
5155: PUSH
5156: EMPTY
5157: LIST
5158: LIST
5159: LIST
5160: LIST
5161: PUSH
5162: LD_INT 13
5164: PUSH
5165: LD_INT 1
5167: PUSH
5168: LD_INT 2
5170: PUSH
5171: LD_INT 27
5173: PUSH
5174: LD_INT 26
5176: PUSH
5177: LD_INT 26
5179: PUSH
5180: EMPTY
5181: LIST
5182: LIST
5183: LIST
5184: PUSH
5185: LD_OWVAR 67
5189: ARRAY
5190: PUSH
5191: EMPTY
5192: LIST
5193: LIST
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 13
5199: PUSH
5200: LD_INT 1
5202: PUSH
5203: LD_INT 2
5205: PUSH
5206: LD_INT 26
5208: PUSH
5209: LD_INT 26
5211: PUSH
5212: LD_INT 29
5214: PUSH
5215: EMPTY
5216: LIST
5217: LIST
5218: LIST
5219: PUSH
5220: LD_OWVAR 67
5224: ARRAY
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: LIST
5230: LIST
5231: PUSH
5232: LD_INT 13
5234: PUSH
5235: LD_INT 1
5237: PUSH
5238: LD_INT 2
5240: PUSH
5241: LD_INT 26
5243: PUSH
5244: LD_INT 29
5246: PUSH
5247: LD_INT 29
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: PUSH
5255: LD_OWVAR 67
5259: ARRAY
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: LIST
5265: LIST
5266: PUSH
5267: LD_INT 13
5269: PUSH
5270: LD_INT 1
5272: PUSH
5273: LD_INT 2
5275: PUSH
5276: LD_INT 29
5278: PUSH
5279: EMPTY
5280: LIST
5281: LIST
5282: LIST
5283: LIST
5284: PUSH
5285: LD_INT 13
5287: PUSH
5288: LD_INT 1
5290: PUSH
5291: LD_INT 2
5293: PUSH
5294: LD_INT 26
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: LIST
5301: LIST
5302: PUSH
5303: EMPTY
5304: LIST
5305: LIST
5306: LIST
5307: LIST
5308: LIST
5309: LIST
5310: PPUSH
5311: CALL 53537 0 2
// end ; repeat wait ( 0 0$1 ) ;
5315: LD_INT 35
5317: PPUSH
5318: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5322: LD_INT 3
5324: PPUSH
5325: LD_INT 1
5327: PPUSH
5328: CALL 54950 0 2
5332: PUSH
5333: LD_INT 6
5335: GREATEREQUAL
5336: IFFALSE 5315
// tmp := MC_GetVehicles ( 3 , true ) ;
5338: LD_ADDR_VAR 0 2
5342: PUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: CALL 54950 0 2
5353: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5354: LD_ADDR_EXP 118
5358: PUSH
5359: LD_EXP 118
5363: PPUSH
5364: LD_INT 3
5366: PPUSH
5367: LD_EXP 118
5371: PUSH
5372: LD_INT 3
5374: ARRAY
5375: PUSH
5376: LD_VAR 0 2
5380: DIFF
5381: PPUSH
5382: CALL_OW 1
5386: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
5387: LD_ADDR_VAR 0 3
5391: PUSH
5392: LD_INT 0
5394: PPUSH
5395: LD_INT 1
5397: PPUSH
5398: CALL_OW 12
5402: ST_TO_ADDR
// if target then
5403: LD_VAR 0 3
5407: IFFALSE 5466
// begin repeat ComMoveXY ( tmp , 90 , 75 ) ;
5409: LD_VAR 0 2
5413: PPUSH
5414: LD_INT 90
5416: PPUSH
5417: LD_INT 75
5419: PPUSH
5420: CALL_OW 111
// wait ( 0 0$1 ) ;
5424: LD_INT 35
5426: PPUSH
5427: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 90 , 75 , 6 ] ) > 2 ;
5431: LD_VAR 0 2
5435: PPUSH
5436: LD_INT 92
5438: PUSH
5439: LD_INT 90
5441: PUSH
5442: LD_INT 75
5444: PUSH
5445: LD_INT 6
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: PPUSH
5454: CALL_OW 72
5458: PUSH
5459: LD_INT 2
5461: GREATER
5462: IFFALSE 5409
// end else
5464: GO 5521
// begin repeat ComMoveXY ( tmp , 128 , 11 ) ;
5466: LD_VAR 0 2
5470: PPUSH
5471: LD_INT 128
5473: PPUSH
5474: LD_INT 11
5476: PPUSH
5477: CALL_OW 111
// wait ( 0 0$1 ) ;
5481: LD_INT 35
5483: PPUSH
5484: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 128 , 11 , 6 ] ) > 2 ;
5488: LD_VAR 0 2
5492: PPUSH
5493: LD_INT 92
5495: PUSH
5496: LD_INT 128
5498: PUSH
5499: LD_INT 11
5501: PUSH
5502: LD_INT 6
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: LIST
5509: LIST
5510: PPUSH
5511: CALL_OW 72
5515: PUSH
5516: LD_INT 2
5518: GREATER
5519: IFFALSE 5466
// end ; repeat wait ( 0 0$1 ) ;
5521: LD_INT 35
5523: PPUSH
5524: CALL_OW 67
// for i in tmp do
5528: LD_ADDR_VAR 0 1
5532: PUSH
5533: LD_VAR 0 2
5537: PUSH
5538: FOR_IN
5539: IFFALSE 5610
// if GetLives ( i ) > 251 then
5541: LD_VAR 0 1
5545: PPUSH
5546: CALL_OW 256
5550: PUSH
5551: LD_INT 251
5553: GREATER
5554: IFFALSE 5592
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
5556: LD_VAR 0 1
5560: PPUSH
5561: LD_INT 81
5563: PUSH
5564: LD_INT 8
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: PPUSH
5571: CALL_OW 69
5575: PPUSH
5576: LD_VAR 0 1
5580: PPUSH
5581: CALL_OW 74
5585: PPUSH
5586: CALL_OW 115
5590: GO 5608
// tmp := tmp diff i ;
5592: LD_ADDR_VAR 0 2
5596: PUSH
5597: LD_VAR 0 2
5601: PUSH
5602: LD_VAR 0 1
5606: DIFF
5607: ST_TO_ADDR
5608: GO 5538
5610: POP
5611: POP
// until not tmp ;
5612: LD_VAR 0 2
5616: NOT
5617: IFFALSE 5521
// end ; end_of_file
5619: PPOPN 3
5621: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
5622: LD_INT 0
5624: PPUSH
5625: PPUSH
5626: PPUSH
5627: PPUSH
5628: PPUSH
5629: PPUSH
5630: PPUSH
5631: PPUSH
5632: PPUSH
// side := 3 ;
5633: LD_ADDR_VAR 0 6
5637: PUSH
5638: LD_INT 3
5640: ST_TO_ADDR
// uc_side := side ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_VAR 0 6
5650: ST_TO_ADDR
// uc_nation := 3 ;
5651: LD_ADDR_OWVAR 21
5655: PUSH
5656: LD_INT 3
5658: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
5659: LD_ADDR_VAR 0 2
5663: PUSH
5664: LD_INT 22
5666: PUSH
5667: LD_VAR 0 6
5671: PUSH
5672: EMPTY
5673: LIST
5674: LIST
5675: PUSH
5676: LD_INT 21
5678: PUSH
5679: LD_INT 3
5681: PUSH
5682: EMPTY
5683: LIST
5684: LIST
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PPUSH
5690: CALL_OW 69
5694: PUSH
5695: FOR_IN
5696: IFFALSE 5712
// SetBLevel ( i , 10 ) ;
5698: LD_VAR 0 2
5702: PPUSH
5703: LD_INT 10
5705: PPUSH
5706: CALL_OW 241
5710: GO 5695
5712: POP
5713: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
5714: LD_ADDR_VAR 0 9
5718: PUSH
5719: LD_INT 22
5721: PUSH
5722: LD_VAR 0 6
5726: PUSH
5727: EMPTY
5728: LIST
5729: LIST
5730: PUSH
5731: LD_INT 30
5733: PUSH
5734: LD_INT 34
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: PPUSH
5745: CALL_OW 69
5749: ST_TO_ADDR
// if teleport then
5750: LD_VAR 0 9
5754: IFFALSE 5775
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
5756: LD_VAR 0 9
5760: PUSH
5761: LD_INT 1
5763: ARRAY
5764: PPUSH
5765: LD_INT 123
5767: PPUSH
5768: LD_INT 122
5770: PPUSH
5771: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
5775: LD_ADDR_EXP 61
5779: PUSH
5780: LD_STRING Platonov
5782: PPUSH
5783: CALL_OW 25
5787: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
5788: LD_ADDR_EXP 62
5792: PUSH
5793: LD_STRING Kovalyuk
5795: PPUSH
5796: CALL_OW 25
5800: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
5801: LD_ADDR_EXP 64
5805: PUSH
5806: LD_STRING Yakotich
5808: PPUSH
5809: CALL_OW 25
5813: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
5814: LD_ADDR_EXP 63
5818: PUSH
5819: LD_STRING Bystrov
5821: PPUSH
5822: CALL_OW 25
5826: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
5827: LD_ADDR_EXP 65
5831: PUSH
5832: LD_STRING Gleb
5834: PPUSH
5835: CALL_OW 25
5839: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
5840: LD_STRING 03_Cornel
5842: PPUSH
5843: CALL_OW 28
5847: IFFALSE 5895
// begin Bierezov := NewCharacter ( Mikhail ) ;
5849: LD_ADDR_EXP 66
5853: PUSH
5854: LD_STRING Mikhail
5856: PPUSH
5857: CALL_OW 25
5861: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
5862: LD_EXP 66
5866: PPUSH
5867: LD_INT 197
5869: PPUSH
5870: LD_INT 111
5872: PPUSH
5873: LD_INT 9
5875: PPUSH
5876: LD_INT 0
5878: PPUSH
5879: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
5883: LD_EXP 66
5887: PPUSH
5888: LD_INT 3
5890: PPUSH
5891: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
5895: LD_EXP 61
5899: PPUSH
5900: LD_INT 126
5902: PPUSH
5903: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
5907: LD_EXP 62
5911: PPUSH
5912: LD_INT 134
5914: PPUSH
5915: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
5919: LD_EXP 64
5923: PPUSH
5924: LD_INT 197
5926: PPUSH
5927: LD_INT 111
5929: PPUSH
5930: LD_INT 9
5932: PPUSH
5933: LD_INT 0
5935: PPUSH
5936: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
5940: LD_EXP 63
5944: PPUSH
5945: LD_INT 197
5947: PPUSH
5948: LD_INT 111
5950: PPUSH
5951: LD_INT 9
5953: PPUSH
5954: LD_INT 0
5956: PPUSH
5957: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
5961: LD_EXP 65
5965: PPUSH
5966: LD_INT 197
5968: PPUSH
5969: LD_INT 111
5971: PPUSH
5972: LD_INT 9
5974: PPUSH
5975: LD_INT 0
5977: PPUSH
5978: CALL_OW 50
// PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 10000 , 1000 , 300 ] , [ - 1 , 8 , 13 , 8 ] ) ;
5982: LD_INT 126
5984: PPUSH
5985: LD_INT 4
5987: PPUSH
5988: LD_STRING zhukov
5990: PPUSH
5991: LD_INT 9
5993: PUSH
5994: LD_INT 10
5996: PUSH
5997: LD_INT 10
5999: PUSH
6000: EMPTY
6001: LIST
6002: LIST
6003: LIST
6004: PUSH
6005: LD_OWVAR 67
6009: ARRAY
6010: PPUSH
6011: LD_INT 10000
6013: PUSH
6014: LD_INT 1000
6016: PUSH
6017: LD_INT 300
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: LIST
6024: PPUSH
6025: LD_INT 1
6027: NEG
6028: PUSH
6029: LD_INT 8
6031: PUSH
6032: LD_INT 13
6034: PUSH
6035: LD_INT 8
6037: PUSH
6038: EMPTY
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: PPUSH
6044: CALL 69474 0 6
// base := GetBase ( ru_depot2 ) ;
6048: LD_ADDR_VAR 0 4
6052: PUSH
6053: LD_INT 267
6055: PPUSH
6056: CALL_OW 274
6060: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 2000 ) ;
6061: LD_VAR 0 4
6065: PPUSH
6066: LD_INT 1
6068: PPUSH
6069: LD_INT 2000
6071: PPUSH
6072: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
6076: LD_VAR 0 4
6080: PPUSH
6081: LD_INT 2
6083: PPUSH
6084: LD_INT 200
6086: PPUSH
6087: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
6091: LD_VAR 0 4
6095: PPUSH
6096: LD_INT 3
6098: PPUSH
6099: LD_INT 200
6101: PPUSH
6102: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
6106: LD_ADDR_EXP 99
6110: PUSH
6111: LD_EXP 99
6115: PPUSH
6116: LD_INT 2
6118: PPUSH
6119: LD_INT 22
6121: PUSH
6122: LD_VAR 0 6
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: PUSH
6131: LD_INT 3
6133: PUSH
6134: LD_INT 21
6136: PUSH
6137: LD_INT 2
6139: PUSH
6140: EMPTY
6141: LIST
6142: LIST
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PUSH
6148: EMPTY
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: PUSH
6157: LD_EXP 61
6161: DIFF
6162: PPUSH
6163: CALL_OW 1
6167: ST_TO_ADDR
// behemoths := [ ] ;
6168: LD_ADDR_EXP 69
6172: PUSH
6173: EMPTY
6174: ST_TO_ADDR
// behemothBuilders := [ ] ;
6175: LD_ADDR_EXP 70
6179: PUSH
6180: EMPTY
6181: ST_TO_ADDR
// if Kovalyuk then
6182: LD_EXP 62
6186: IFFALSE 6208
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
6188: LD_ADDR_EXP 70
6192: PUSH
6193: LD_EXP 70
6197: PPUSH
6198: LD_EXP 62
6202: PPUSH
6203: CALL 101748 0 2
6207: ST_TO_ADDR
// j := 3 ;
6208: LD_ADDR_VAR 0 3
6212: PUSH
6213: LD_INT 3
6215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
6216: LD_ADDR_VAR 0 2
6220: PUSH
6221: LD_INT 22
6223: PUSH
6224: LD_INT 3
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: PUSH
6231: LD_INT 25
6233: PUSH
6234: LD_INT 3
6236: PUSH
6237: EMPTY
6238: LIST
6239: LIST
6240: PUSH
6241: EMPTY
6242: LIST
6243: LIST
6244: PPUSH
6245: CALL_OW 69
6249: PUSH
6250: LD_EXP 62
6254: DIFF
6255: PUSH
6256: FOR_IN
6257: IFFALSE 6307
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
6259: LD_ADDR_EXP 70
6263: PUSH
6264: LD_EXP 70
6268: PPUSH
6269: LD_VAR 0 2
6273: PPUSH
6274: CALL 101748 0 2
6278: ST_TO_ADDR
// j := j - 1 ;
6279: LD_ADDR_VAR 0 3
6283: PUSH
6284: LD_VAR 0 3
6288: PUSH
6289: LD_INT 1
6291: MINUS
6292: ST_TO_ADDR
// if j = 0 then
6293: LD_VAR 0 3
6297: PUSH
6298: LD_INT 0
6300: EQUAL
6301: IFFALSE 6305
// break ;
6303: GO 6307
// end ;
6305: GO 6256
6307: POP
6308: POP
// end ;
6309: LD_VAR 0 1
6313: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
6314: LD_INT 0
6316: PPUSH
6317: PPUSH
6318: PPUSH
6319: PPUSH
6320: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
6321: LD_ADDR_VAR 0 4
6325: PUSH
6326: LD_INT 209
6328: PUSH
6329: LD_INT 149
6331: PUSH
6332: EMPTY
6333: LIST
6334: LIST
6335: PUSH
6336: LD_INT 219
6338: PUSH
6339: LD_INT 154
6341: PUSH
6342: EMPTY
6343: LIST
6344: LIST
6345: PUSH
6346: LD_INT 223
6348: PUSH
6349: LD_INT 149
6351: PUSH
6352: EMPTY
6353: LIST
6354: LIST
6355: PUSH
6356: LD_INT 232
6358: PUSH
6359: LD_INT 155
6361: PUSH
6362: EMPTY
6363: LIST
6364: LIST
6365: PUSH
6366: EMPTY
6367: LIST
6368: LIST
6369: LIST
6370: LIST
6371: ST_TO_ADDR
// if not behemothBuilders then
6372: LD_EXP 70
6376: NOT
6377: IFFALSE 6381
// exit ;
6379: GO 6485
// j := 1 ;
6381: LD_ADDR_VAR 0 3
6385: PUSH
6386: LD_INT 1
6388: ST_TO_ADDR
// for i in behemothBuilders do
6389: LD_ADDR_VAR 0 2
6393: PUSH
6394: LD_EXP 70
6398: PUSH
6399: FOR_IN
6400: IFFALSE 6483
// begin if IsInUnit ( i ) then
6402: LD_VAR 0 2
6406: PPUSH
6407: CALL_OW 310
6411: IFFALSE 6422
// ComExitBuilding ( i ) ;
6413: LD_VAR 0 2
6417: PPUSH
6418: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
6422: LD_VAR 0 2
6426: PPUSH
6427: LD_INT 37
6429: PPUSH
6430: LD_VAR 0 4
6434: PUSH
6435: LD_VAR 0 3
6439: ARRAY
6440: PUSH
6441: LD_INT 1
6443: ARRAY
6444: PPUSH
6445: LD_VAR 0 4
6449: PUSH
6450: LD_VAR 0 3
6454: ARRAY
6455: PUSH
6456: LD_INT 2
6458: ARRAY
6459: PPUSH
6460: LD_INT 0
6462: PPUSH
6463: CALL_OW 230
// j := j + 1 ;
6467: LD_ADDR_VAR 0 3
6471: PUSH
6472: LD_VAR 0 3
6476: PUSH
6477: LD_INT 1
6479: PLUS
6480: ST_TO_ADDR
// end ;
6481: GO 6399
6483: POP
6484: POP
// end ;
6485: LD_VAR 0 1
6489: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
6490: LD_INT 24
6492: PPUSH
6493: LD_INT 30
6495: PUSH
6496: LD_INT 37
6498: PUSH
6499: EMPTY
6500: LIST
6501: LIST
6502: PPUSH
6503: CALL_OW 70
6507: IFFALSE 6520
6509: GO 6511
6511: DISABLE
// behemothUnderConstruct := true ;
6512: LD_ADDR_EXP 26
6516: PUSH
6517: LD_INT 1
6519: ST_TO_ADDR
6520: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
6521: LD_INT 3
6523: PPUSH
6524: CALL 101796 0 1
6528: PUSH
6529: LD_INT 22
6531: PUSH
6532: LD_INT 3
6534: PUSH
6535: EMPTY
6536: LIST
6537: LIST
6538: PUSH
6539: LD_INT 30
6541: PUSH
6542: LD_INT 37
6544: PUSH
6545: EMPTY
6546: LIST
6547: LIST
6548: PUSH
6549: EMPTY
6550: LIST
6551: LIST
6552: PPUSH
6553: CALL_OW 69
6557: NOT
6558: AND
6559: IFFALSE 6745
6561: GO 6563
6563: DISABLE
6564: LD_INT 0
6566: PPUSH
6567: PPUSH
// begin enable ;
6568: ENABLE
// tmp := GetBehemoths ( 3 ) ;
6569: LD_ADDR_VAR 0 2
6573: PUSH
6574: LD_INT 3
6576: PPUSH
6577: CALL 101796 0 1
6581: ST_TO_ADDR
// for i in tmp do
6582: LD_ADDR_VAR 0 1
6586: PUSH
6587: LD_VAR 0 2
6591: PUSH
6592: FOR_IN
6593: IFFALSE 6743
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
6595: LD_VAR 0 1
6599: PPUSH
6600: LD_INT 9
6602: PPUSH
6603: CALL_OW 308
6607: PUSH
6608: LD_VAR 0 1
6612: PPUSH
6613: CALL_OW 110
6617: PUSH
6618: LD_INT 2
6620: EQUAL
6621: NOT
6622: AND
6623: IFFALSE 6637
// SetTag ( i , 2 ) ;
6625: LD_VAR 0 1
6629: PPUSH
6630: LD_INT 2
6632: PPUSH
6633: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
6637: LD_INT 81
6639: PUSH
6640: LD_INT 3
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: LD_INT 91
6649: PUSH
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 12
6657: PUSH
6658: EMPTY
6659: LIST
6660: LIST
6661: LIST
6662: PUSH
6663: EMPTY
6664: LIST
6665: LIST
6666: PPUSH
6667: CALL_OW 69
6671: NOT
6672: PUSH
6673: LD_VAR 0 1
6677: PPUSH
6678: CALL_OW 110
6682: PUSH
6683: LD_INT 2
6685: EQUAL
6686: NOT
6687: AND
6688: IFFALSE 6707
// ComAgressiveMove ( i , 64 , 93 ) else
6690: LD_VAR 0 1
6694: PPUSH
6695: LD_INT 64
6697: PPUSH
6698: LD_INT 93
6700: PPUSH
6701: CALL_OW 114
6705: GO 6741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
6707: LD_VAR 0 1
6711: PPUSH
6712: LD_INT 81
6714: PUSH
6715: LD_INT 3
6717: PUSH
6718: EMPTY
6719: LIST
6720: LIST
6721: PPUSH
6722: CALL_OW 69
6726: PPUSH
6727: LD_VAR 0 1
6731: PPUSH
6732: CALL_OW 74
6736: PPUSH
6737: CALL_OW 115
// end ;
6741: GO 6592
6743: POP
6744: POP
// end ;
6745: PPOPN 2
6747: END
// export function PrepareRussianAttack ( strength ) ; var i ; begin
6748: LD_INT 0
6750: PPUSH
6751: PPUSH
// result := [ ] ;
6752: LD_ADDR_VAR 0 2
6756: PUSH
6757: EMPTY
6758: ST_TO_ADDR
// uc_side := 6 ;
6759: LD_ADDR_OWVAR 20
6763: PUSH
6764: LD_INT 6
6766: ST_TO_ADDR
// uc_nation := 3 ;
6767: LD_ADDR_OWVAR 21
6771: PUSH
6772: LD_INT 3
6774: ST_TO_ADDR
// case strength of 1 :
6775: LD_VAR 0 1
6779: PUSH
6780: LD_INT 1
6782: DOUBLE
6783: EQUAL
6784: IFTRUE 6788
6786: GO 6926
6788: POP
// begin for i = 1 to [ 3 , 4 , 5 ] [ Difficulty ] do
6789: LD_ADDR_VAR 0 3
6793: PUSH
6794: DOUBLE
6795: LD_INT 1
6797: DEC
6798: ST_TO_ADDR
6799: LD_INT 3
6801: PUSH
6802: LD_INT 4
6804: PUSH
6805: LD_INT 5
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: LIST
6812: PUSH
6813: LD_OWVAR 67
6817: ARRAY
6818: PUSH
6819: FOR_TO
6820: IFFALSE 6922
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
6822: LD_INT 22
6824: PUSH
6825: LD_INT 24
6827: PUSH
6828: EMPTY
6829: LIST
6830: LIST
6831: PUSH
6832: LD_VAR 0 3
6836: PUSH
6837: LD_INT 2
6839: MOD
6840: PUSH
6841: LD_INT 1
6843: PLUS
6844: ARRAY
6845: PPUSH
6846: LD_INT 1
6848: PUSH
6849: LD_INT 3
6851: PUSH
6852: EMPTY
6853: LIST
6854: LIST
6855: PUSH
6856: LD_INT 1
6858: PPUSH
6859: LD_INT 2
6861: PPUSH
6862: CALL_OW 12
6866: ARRAY
6867: PPUSH
6868: LD_INT 3
6870: PPUSH
6871: LD_INT 43
6873: PUSH
6874: LD_INT 44
6876: PUSH
6877: LD_INT 45
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: LIST
6884: PUSH
6885: LD_INT 1
6887: PPUSH
6888: LD_INT 3
6890: PPUSH
6891: CALL_OW 12
6895: ARRAY
6896: PPUSH
6897: LD_INT 80
6899: PPUSH
6900: CALL 66065 0 5
// result := result union CreateVehicle ;
6904: LD_ADDR_VAR 0 2
6908: PUSH
6909: LD_VAR 0 2
6913: PUSH
6914: CALL_OW 45
6918: UNION
6919: ST_TO_ADDR
// end ;
6920: GO 6819
6922: POP
6923: POP
// end ; 2 :
6924: GO 7830
6926: LD_INT 2
6928: DOUBLE
6929: EQUAL
6930: IFTRUE 6934
6932: GO 7090
6934: POP
// begin for i = 1 to [ 5 , 5 , 6 ] [ Difficulty ] do
6935: LD_ADDR_VAR 0 3
6939: PUSH
6940: DOUBLE
6941: LD_INT 1
6943: DEC
6944: ST_TO_ADDR
6945: LD_INT 5
6947: PUSH
6948: LD_INT 5
6950: PUSH
6951: LD_INT 6
6953: PUSH
6954: EMPTY
6955: LIST
6956: LIST
6957: LIST
6958: PUSH
6959: LD_OWVAR 67
6963: ARRAY
6964: PUSH
6965: FOR_TO
6966: IFFALSE 7086
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
6968: LD_INT 22
6970: PUSH
6971: LD_INT 24
6973: PUSH
6974: LD_INT 24
6976: PUSH
6977: EMPTY
6978: LIST
6979: LIST
6980: LIST
6981: PUSH
6982: LD_VAR 0 3
6986: PUSH
6987: LD_INT 3
6989: MOD
6990: PUSH
6991: LD_INT 1
6993: PLUS
6994: ARRAY
6995: PPUSH
6996: LD_INT 1
6998: PUSH
6999: LD_INT 3
7001: PUSH
7002: EMPTY
7003: LIST
7004: LIST
7005: PUSH
7006: LD_INT 1
7008: PPUSH
7009: LD_INT 2
7011: PPUSH
7012: CALL_OW 12
7016: ARRAY
7017: PPUSH
7018: LD_INT 3
7020: PPUSH
7021: LD_INT 43
7023: PUSH
7024: LD_INT 44
7026: PUSH
7027: LD_INT 45
7029: PUSH
7030: LD_INT 44
7032: PUSH
7033: LD_INT 46
7035: PUSH
7036: LD_INT 46
7038: PUSH
7039: EMPTY
7040: LIST
7041: LIST
7042: LIST
7043: LIST
7044: LIST
7045: LIST
7046: PUSH
7047: LD_VAR 0 3
7051: PUSH
7052: LD_INT 6
7054: MOD
7055: PUSH
7056: LD_INT 1
7058: PLUS
7059: ARRAY
7060: PPUSH
7061: LD_INT 80
7063: PPUSH
7064: CALL 66065 0 5
// result := result union CreateVehicle ;
7068: LD_ADDR_VAR 0 2
7072: PUSH
7073: LD_VAR 0 2
7077: PUSH
7078: CALL_OW 45
7082: UNION
7083: ST_TO_ADDR
// end ;
7084: GO 6965
7086: POP
7087: POP
// end ; 3 :
7088: GO 7830
7090: LD_INT 3
7092: DOUBLE
7093: EQUAL
7094: IFTRUE 7098
7096: GO 7254
7098: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
7099: LD_ADDR_VAR 0 3
7103: PUSH
7104: DOUBLE
7105: LD_INT 1
7107: DEC
7108: ST_TO_ADDR
7109: LD_INT 5
7111: PUSH
7112: LD_INT 6
7114: PUSH
7115: LD_INT 7
7117: PUSH
7118: EMPTY
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_OWVAR 67
7127: ARRAY
7128: PUSH
7129: FOR_TO
7130: IFFALSE 7250
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
7132: LD_INT 22
7134: PUSH
7135: LD_INT 24
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: PUSH
7146: LD_VAR 0 3
7150: PUSH
7151: LD_INT 3
7153: MOD
7154: PUSH
7155: LD_INT 1
7157: PLUS
7158: ARRAY
7159: PPUSH
7160: LD_INT 1
7162: PUSH
7163: LD_INT 3
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: PUSH
7170: LD_INT 1
7172: PPUSH
7173: LD_INT 2
7175: PPUSH
7176: CALL_OW 12
7180: ARRAY
7181: PPUSH
7182: LD_INT 3
7184: PPUSH
7185: LD_INT 43
7187: PUSH
7188: LD_INT 47
7190: PUSH
7191: LD_INT 45
7193: PUSH
7194: LD_INT 45
7196: PUSH
7197: LD_INT 46
7199: PUSH
7200: LD_INT 46
7202: PUSH
7203: EMPTY
7204: LIST
7205: LIST
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PUSH
7211: LD_VAR 0 3
7215: PUSH
7216: LD_INT 6
7218: MOD
7219: PUSH
7220: LD_INT 1
7222: PLUS
7223: ARRAY
7224: PPUSH
7225: LD_INT 80
7227: PPUSH
7228: CALL 66065 0 5
// result := result union CreateVehicle ;
7232: LD_ADDR_VAR 0 2
7236: PUSH
7237: LD_VAR 0 2
7241: PUSH
7242: CALL_OW 45
7246: UNION
7247: ST_TO_ADDR
// end ;
7248: GO 7129
7250: POP
7251: POP
// end ; 4 :
7252: GO 7830
7254: LD_INT 4
7256: DOUBLE
7257: EQUAL
7258: IFTRUE 7262
7260: GO 7829
7262: POP
// begin uc_nation := 3 ;
7263: LD_ADDR_OWVAR 21
7267: PUSH
7268: LD_INT 3
7270: ST_TO_ADDR
// for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
7271: LD_ADDR_VAR 0 3
7275: PUSH
7276: DOUBLE
7277: LD_INT 1
7279: DEC
7280: ST_TO_ADDR
7281: LD_INT 6
7283: PUSH
7284: LD_INT 7
7286: PUSH
7287: LD_INT 8
7289: PUSH
7290: EMPTY
7291: LIST
7292: LIST
7293: LIST
7294: PUSH
7295: LD_OWVAR 67
7299: ARRAY
7300: PUSH
7301: FOR_TO
7302: IFFALSE 7422
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
7304: LD_INT 22
7306: PUSH
7307: LD_INT 24
7309: PUSH
7310: LD_INT 24
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: LIST
7317: PUSH
7318: LD_VAR 0 3
7322: PUSH
7323: LD_INT 3
7325: MOD
7326: PUSH
7327: LD_INT 1
7329: PLUS
7330: ARRAY
7331: PPUSH
7332: LD_INT 1
7334: PUSH
7335: LD_INT 3
7337: PUSH
7338: EMPTY
7339: LIST
7340: LIST
7341: PUSH
7342: LD_INT 1
7344: PPUSH
7345: LD_INT 2
7347: PPUSH
7348: CALL_OW 12
7352: ARRAY
7353: PPUSH
7354: LD_INT 3
7356: PPUSH
7357: LD_INT 45
7359: PUSH
7360: LD_INT 47
7362: PUSH
7363: LD_INT 47
7365: PUSH
7366: LD_INT 45
7368: PUSH
7369: LD_INT 46
7371: PUSH
7372: LD_INT 46
7374: PUSH
7375: EMPTY
7376: LIST
7377: LIST
7378: LIST
7379: LIST
7380: LIST
7381: LIST
7382: PUSH
7383: LD_VAR 0 3
7387: PUSH
7388: LD_INT 6
7390: MOD
7391: PUSH
7392: LD_INT 1
7394: PLUS
7395: ARRAY
7396: PPUSH
7397: LD_INT 80
7399: PPUSH
7400: CALL 66065 0 5
// result := result union CreateVehicle ;
7404: LD_ADDR_VAR 0 2
7408: PUSH
7409: LD_VAR 0 2
7413: PUSH
7414: CALL_OW 45
7418: UNION
7419: ST_TO_ADDR
// end ;
7420: GO 7301
7422: POP
7423: POP
// if not KappaStatus then
7424: LD_EXP 2
7428: NOT
7429: IFFALSE 7624
// begin uc_nation := 1 ;
7431: LD_ADDR_OWVAR 21
7435: PUSH
7436: LD_INT 1
7438: ST_TO_ADDR
// for i = 1 to 3 do
7439: LD_ADDR_VAR 0 3
7443: PUSH
7444: DOUBLE
7445: LD_INT 1
7447: DEC
7448: ST_TO_ADDR
7449: LD_INT 3
7451: PUSH
7452: FOR_TO
7453: IFFALSE 7549
// begin PrepareVehicle ( [ us_medium_tracked , us_morphling ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 85 ) ;
7455: LD_INT 3
7457: PUSH
7458: LD_INT 5
7460: PUSH
7461: EMPTY
7462: LIST
7463: LIST
7464: PUSH
7465: LD_INT 1
7467: PPUSH
7468: LD_INT 2
7470: PPUSH
7471: CALL_OW 12
7475: ARRAY
7476: PPUSH
7477: LD_INT 1
7479: PUSH
7480: LD_INT 3
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: LD_INT 1
7489: PPUSH
7490: LD_INT 2
7492: PPUSH
7493: CALL_OW 12
7497: ARRAY
7498: PPUSH
7499: LD_INT 3
7501: PPUSH
7502: LD_INT 9
7504: PUSH
7505: LD_INT 7
7507: PUSH
7508: EMPTY
7509: LIST
7510: LIST
7511: PUSH
7512: LD_INT 1
7514: PPUSH
7515: LD_INT 2
7517: PPUSH
7518: CALL_OW 12
7522: ARRAY
7523: PPUSH
7524: LD_INT 85
7526: PPUSH
7527: CALL 66065 0 5
// result := result union CreateVehicle ;
7531: LD_ADDR_VAR 0 2
7535: PUSH
7536: LD_VAR 0 2
7540: PUSH
7541: CALL_OW 45
7545: UNION
7546: ST_TO_ADDR
// end ;
7547: GO 7452
7549: POP
7550: POP
// if vsevolodFirstAttack then
7551: LD_EXP 24
7555: IFFALSE 7622
// begin vsevolodFirstAttack := false ;
7557: LD_ADDR_EXP 24
7561: PUSH
7562: LD_INT 0
7564: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
7565: LD_INT 5
7567: PPUSH
7568: LD_INT 3
7570: PPUSH
7571: LD_INT 1
7573: PPUSH
7574: LD_INT 6
7576: PPUSH
7577: LD_INT 100
7579: PPUSH
7580: CALL 66065 0 5
// sewiVeh := CreateVehicle ;
7584: LD_ADDR_EXP 68
7588: PUSH
7589: CALL_OW 45
7593: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
7594: LD_EXP 68
7598: PPUSH
7599: LD_INT 1
7601: PPUSH
7602: CALL_OW 242
// result := result union sewiVeh ;
7606: LD_ADDR_VAR 0 2
7610: PUSH
7611: LD_VAR 0 2
7615: PUSH
7616: LD_EXP 68
7620: UNION
7621: ST_TO_ADDR
// end ; end else
7622: GO 7827
// if vsevolodFirstAttack then
7624: LD_EXP 24
7628: IFFALSE 7827
// begin vsevolodFirstAttack := false ;
7630: LD_ADDR_EXP 24
7634: PUSH
7635: LD_INT 0
7637: ST_TO_ADDR
// uc_nation := 3 ;
7638: LD_ADDR_OWVAR 21
7642: PUSH
7643: LD_INT 3
7645: ST_TO_ADDR
// for i = 1 to 3 do
7646: LD_ADDR_VAR 0 3
7650: PUSH
7651: DOUBLE
7652: LD_INT 1
7654: DEC
7655: ST_TO_ADDR
7656: LD_INT 3
7658: PUSH
7659: FOR_TO
7660: IFFALSE 7768
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
7662: LD_INT 22
7664: PUSH
7665: LD_INT 24
7667: PUSH
7668: LD_INT 24
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: LIST
7675: PUSH
7676: LD_VAR 0 3
7680: PUSH
7681: LD_INT 3
7683: MOD
7684: PUSH
7685: LD_INT 1
7687: PLUS
7688: ARRAY
7689: PPUSH
7690: LD_INT 1
7692: PUSH
7693: LD_INT 3
7695: PUSH
7696: EMPTY
7697: LIST
7698: LIST
7699: PUSH
7700: LD_INT 1
7702: PPUSH
7703: LD_INT 2
7705: PPUSH
7706: CALL_OW 12
7710: ARRAY
7711: PPUSH
7712: LD_INT 3
7714: PPUSH
7715: LD_INT 45
7717: PUSH
7718: LD_INT 47
7720: PUSH
7721: LD_INT 47
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: LIST
7728: PUSH
7729: LD_VAR 0 3
7733: PUSH
7734: LD_INT 3
7736: MOD
7737: PUSH
7738: LD_INT 1
7740: PLUS
7741: ARRAY
7742: PPUSH
7743: LD_INT 80
7745: PPUSH
7746: CALL 66065 0 5
// result := result union CreateVehicle ;
7750: LD_ADDR_VAR 0 2
7754: PUSH
7755: LD_VAR 0 2
7759: PUSH
7760: CALL_OW 45
7764: UNION
7765: ST_TO_ADDR
// end ;
7766: GO 7659
7768: POP
7769: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
7770: LD_INT 24
7772: PPUSH
7773: LD_INT 3
7775: PPUSH
7776: LD_INT 1
7778: PPUSH
7779: LD_INT 47
7781: PPUSH
7782: LD_INT 100
7784: PPUSH
7785: CALL 66065 0 5
// sewiVeh := CreateVehicle ;
7789: LD_ADDR_EXP 68
7793: PUSH
7794: CALL_OW 45
7798: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
7799: LD_EXP 68
7803: PPUSH
7804: LD_INT 1
7806: PPUSH
7807: CALL_OW 242
// result := result union sewiVeh ;
7811: LD_ADDR_VAR 0 2
7815: PUSH
7816: LD_VAR 0 2
7820: PUSH
7821: LD_EXP 68
7825: UNION
7826: ST_TO_ADDR
// end ; end ; end ;
7827: GO 7830
7829: POP
// end ;
7830: LD_VAR 0 2
7834: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy , x , y ;
7835: LD_EXP 16
7839: IFFALSE 8528
7841: GO 7843
7843: DISABLE
7844: LD_INT 0
7846: PPUSH
7847: PPUSH
7848: PPUSH
7849: PPUSH
7850: PPUSH
7851: PPUSH
7852: PPUSH
7853: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
7854: LD_ADDR_VAR 0 4
7858: PUSH
7859: LD_INT 11
7861: PUSH
7862: LD_INT 12
7864: PUSH
7865: EMPTY
7866: LIST
7867: LIST
7868: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
7869: LD_ADDR_VAR 0 3
7873: PUSH
7874: LD_INT 8400
7876: PUSH
7877: LD_INT 7350
7879: PUSH
7880: LD_INT 6650
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: LIST
7887: PUSH
7888: LD_OWVAR 67
7892: ARRAY
7893: ST_TO_ADDR
// xy := [ 60 , 96 ] ;
7894: LD_ADDR_VAR 0 6
7898: PUSH
7899: LD_INT 60
7901: PUSH
7902: LD_INT 96
7904: PUSH
7905: EMPTY
7906: LIST
7907: LIST
7908: ST_TO_ADDR
// repeat if missionStage = 2 then
7909: LD_EXP 15
7913: PUSH
7914: LD_INT 2
7916: EQUAL
7917: IFFALSE 7928
// wait ( 1 1$30 ) else
7919: LD_INT 3150
7921: PPUSH
7922: CALL_OW 67
7926: GO 7937
// wait ( time ) ;
7928: LD_VAR 0 3
7932: PPUSH
7933: CALL_OW 67
// if missionStage = 6 then
7937: LD_EXP 15
7941: PUSH
7942: LD_INT 6
7944: EQUAL
7945: IFFALSE 7973
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
7947: LD_INT 51
7949: PPUSH
7950: LD_INT 6
7952: PPUSH
7953: LD_INT 2
7955: PPUSH
7956: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
7960: LD_INT 57
7962: PPUSH
7963: LD_INT 6
7965: PPUSH
7966: LD_INT 2
7968: PPUSH
7969: CALL_OW 322
// end ; if missionStage = 8 then
7973: LD_EXP 15
7977: PUSH
7978: LD_INT 8
7980: EQUAL
7981: IFFALSE 8009
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
7983: LD_INT 52
7985: PPUSH
7986: LD_INT 6
7988: PPUSH
7989: LD_INT 2
7991: PPUSH
7992: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
7996: LD_INT 58
7998: PPUSH
7999: LD_INT 6
8001: PPUSH
8002: LD_INT 2
8004: PPUSH
8005: CALL_OW 322
// end ; if missionStage = 10 then
8009: LD_EXP 15
8013: PUSH
8014: LD_INT 10
8016: EQUAL
8017: IFFALSE 8045
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
8019: LD_INT 53
8021: PPUSH
8022: LD_INT 6
8024: PPUSH
8025: LD_INT 2
8027: PPUSH
8028: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
8032: LD_INT 59
8034: PPUSH
8035: LD_INT 6
8037: PPUSH
8038: LD_INT 2
8040: PPUSH
8041: CALL_OW 322
// end ; if activeAttacks then
8045: LD_EXP 16
8049: IFFALSE 8522
// begin if missionStage = 2 then
8051: LD_EXP 15
8055: PUSH
8056: LD_INT 2
8058: EQUAL
8059: IFFALSE 8069
// strength := 1 ;
8061: LD_ADDR_VAR 0 5
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// if missionStage > 2 then
8069: LD_EXP 15
8073: PUSH
8074: LD_INT 2
8076: GREATER
8077: IFFALSE 8087
// strength := 2 ;
8079: LD_ADDR_VAR 0 5
8083: PUSH
8084: LD_INT 2
8086: ST_TO_ADDR
// if missionStage > 6 then
8087: LD_EXP 15
8091: PUSH
8092: LD_INT 6
8094: GREATER
8095: IFFALSE 8105
// strength := 3 ;
8097: LD_ADDR_VAR 0 5
8101: PUSH
8102: LD_INT 3
8104: ST_TO_ADDR
// if missionStage > 10 then
8105: LD_EXP 15
8109: PUSH
8110: LD_INT 10
8112: GREATER
8113: IFFALSE 8123
// strength := 4 ;
8115: LD_ADDR_VAR 0 5
8119: PUSH
8120: LD_INT 4
8122: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
8123: LD_ADDR_VAR 0 2
8127: PUSH
8128: LD_VAR 0 5
8132: PPUSH
8133: CALL 6748 0 1
8137: ST_TO_ADDR
// for i in tmp do
8138: LD_ADDR_VAR 0 1
8142: PUSH
8143: LD_VAR 0 2
8147: PUSH
8148: FOR_IN
8149: IFFALSE 8249
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
8151: LD_VAR 0 1
8155: PPUSH
8156: LD_VAR 0 4
8160: PUSH
8161: LD_INT 1
8163: PPUSH
8164: LD_INT 2
8166: PPUSH
8167: CALL_OW 12
8171: ARRAY
8172: PPUSH
8173: LD_INT 0
8175: PPUSH
8176: CALL_OW 49
// if i = sewiVeh then
8180: LD_VAR 0 1
8184: PUSH
8185: LD_EXP 68
8189: EQUAL
8190: IFFALSE 8225
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
8192: LD_ADDR_EXP 67
8196: PUSH
8197: LD_STRING Vsevolod
8199: PPUSH
8200: LD_INT 0
8202: PPUSH
8203: LD_STRING 
8205: PPUSH
8206: CALL 59432 0 3
8210: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
8211: LD_EXP 67
8215: PPUSH
8216: LD_VAR 0 1
8220: PPUSH
8221: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
8225: LD_VAR 0 1
8229: PPUSH
8230: LD_INT 111
8232: PPUSH
8233: LD_INT 197
8235: PPUSH
8236: CALL_OW 111
// wait ( 0 0$2 ) ;
8240: LD_INT 70
8242: PPUSH
8243: CALL_OW 67
// end ;
8247: GO 8148
8249: POP
8250: POP
// repeat wait ( 0 0$1 ) ;
8251: LD_INT 35
8253: PPUSH
8254: CALL_OW 67
// for i in tmp do
8258: LD_ADDR_VAR 0 1
8262: PUSH
8263: LD_VAR 0 2
8267: PUSH
8268: FOR_IN
8269: IFFALSE 8503
// begin x := GetX ( i ) ;
8271: LD_ADDR_VAR 0 7
8275: PUSH
8276: LD_VAR 0 1
8280: PPUSH
8281: CALL_OW 250
8285: ST_TO_ADDR
// y := GetY ( i ) ;
8286: LD_ADDR_VAR 0 8
8290: PUSH
8291: LD_VAR 0 1
8295: PPUSH
8296: CALL_OW 251
8300: ST_TO_ADDR
// if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) then
8301: LD_INT 81
8303: PUSH
8304: LD_INT 6
8306: PUSH
8307: EMPTY
8308: LIST
8309: LIST
8310: PUSH
8311: LD_INT 92
8313: PUSH
8314: LD_VAR 0 7
8318: PUSH
8319: LD_VAR 0 8
8323: PUSH
8324: LD_INT 12
8326: PUSH
8327: EMPTY
8328: LIST
8329: LIST
8330: LIST
8331: LIST
8332: PUSH
8333: EMPTY
8334: LIST
8335: LIST
8336: PPUSH
8337: CALL_OW 69
8341: IFFALSE 8405
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , x , y , 12 ] ] ) , i ) ) else
8343: LD_VAR 0 1
8347: PPUSH
8348: LD_INT 81
8350: PUSH
8351: LD_INT 6
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PUSH
8358: LD_INT 92
8360: PUSH
8361: LD_VAR 0 7
8365: PUSH
8366: LD_VAR 0 8
8370: PUSH
8371: LD_INT 12
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: LIST
8378: LIST
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: PPUSH
8389: LD_VAR 0 1
8393: PPUSH
8394: CALL_OW 74
8398: PPUSH
8399: CALL_OW 115
8403: GO 8501
// if GetDistUnitXY ( i , xy [ 1 ] , xy [ 2 ] ) > 10 then
8405: LD_VAR 0 1
8409: PPUSH
8410: LD_VAR 0 6
8414: PUSH
8415: LD_INT 1
8417: ARRAY
8418: PPUSH
8419: LD_VAR 0 6
8423: PUSH
8424: LD_INT 2
8426: ARRAY
8427: PPUSH
8428: CALL_OW 297
8432: PUSH
8433: LD_INT 10
8435: GREATER
8436: IFFALSE 8467
// ComAgressiveMove ( i , xy [ 1 ] , xy [ 2 ] ) else
8438: LD_VAR 0 1
8442: PPUSH
8443: LD_VAR 0 6
8447: PUSH
8448: LD_INT 1
8450: ARRAY
8451: PPUSH
8452: LD_VAR 0 6
8456: PUSH
8457: LD_INT 2
8459: ARRAY
8460: PPUSH
8461: CALL_OW 114
8465: GO 8501
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
8467: LD_VAR 0 1
8471: PPUSH
8472: LD_INT 81
8474: PUSH
8475: LD_INT 6
8477: PUSH
8478: EMPTY
8479: LIST
8480: LIST
8481: PPUSH
8482: CALL_OW 69
8486: PPUSH
8487: LD_VAR 0 1
8491: PPUSH
8492: CALL_OW 74
8496: PPUSH
8497: CALL_OW 115
// end ;
8501: GO 8268
8503: POP
8504: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
8505: LD_INT 22
8507: PUSH
8508: LD_INT 6
8510: PUSH
8511: EMPTY
8512: LIST
8513: LIST
8514: PPUSH
8515: CALL_OW 69
8519: NOT
8520: IFFALSE 8251
// end ; until russianDestroyed ;
8522: LD_EXP 21
8526: IFFALSE 7909
// end ;
8528: PPOPN 8
8530: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 8 do var i , tmp , target , teleport ;
8531: LD_EXP 21
8535: NOT
8536: PUSH
8537: LD_EXP 15
8541: PUSH
8542: LD_INT 8
8544: GREATEREQUAL
8545: AND
8546: IFFALSE 9357
8548: GO 8550
8550: DISABLE
8551: LD_INT 0
8553: PPUSH
8554: PPUSH
8555: PPUSH
8556: PPUSH
// begin enable ;
8557: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) then
8558: LD_INT 22
8560: PUSH
8561: LD_INT 3
8563: PUSH
8564: EMPTY
8565: LIST
8566: LIST
8567: PUSH
8568: LD_INT 23
8570: PUSH
8571: LD_INT 3
8573: PUSH
8574: EMPTY
8575: LIST
8576: LIST
8577: PUSH
8578: LD_INT 30
8580: PUSH
8581: LD_INT 3
8583: PUSH
8584: EMPTY
8585: LIST
8586: LIST
8587: PUSH
8588: EMPTY
8589: LIST
8590: LIST
8591: LIST
8592: PPUSH
8593: CALL_OW 69
8597: NOT
8598: IFFALSE 8602
// exit ;
8600: GO 9357
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
8602: LD_ADDR_VAR 0 4
8606: PUSH
8607: LD_INT 22
8609: PUSH
8610: LD_INT 3
8612: PUSH
8613: EMPTY
8614: LIST
8615: LIST
8616: PUSH
8617: LD_INT 30
8619: PUSH
8620: LD_INT 34
8622: PUSH
8623: EMPTY
8624: LIST
8625: LIST
8626: PUSH
8627: EMPTY
8628: LIST
8629: LIST
8630: PPUSH
8631: CALL_OW 69
8635: ST_TO_ADDR
// if Prob ( 40 ) then
8636: LD_INT 40
8638: PPUSH
8639: CALL_OW 13
8643: IFFALSE 8770
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8645: LD_INT 2
8647: PPUSH
8648: LD_INT 22
8650: PUSH
8651: LD_INT 3
8653: PUSH
8654: LD_INT 3
8656: PUSH
8657: LD_INT 49
8659: PUSH
8660: EMPTY
8661: LIST
8662: LIST
8663: LIST
8664: LIST
8665: PUSH
8666: LD_INT 22
8668: PUSH
8669: LD_INT 3
8671: PUSH
8672: LD_INT 3
8674: PUSH
8675: LD_INT 49
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: LIST
8682: LIST
8683: PUSH
8684: LD_INT 22
8686: PUSH
8687: LD_INT 3
8689: PUSH
8690: LD_INT 3
8692: PUSH
8693: LD_INT 49
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: LIST
8700: LIST
8701: PUSH
8702: LD_INT 24
8704: PUSH
8705: LD_INT 3
8707: PUSH
8708: LD_INT 3
8710: PUSH
8711: LD_INT 46
8713: PUSH
8714: EMPTY
8715: LIST
8716: LIST
8717: LIST
8718: LIST
8719: PUSH
8720: LD_INT 24
8722: PUSH
8723: LD_INT 3
8725: PUSH
8726: LD_INT 3
8728: PUSH
8729: LD_INT 46
8731: PUSH
8732: EMPTY
8733: LIST
8734: LIST
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 24
8740: PUSH
8741: LD_INT 3
8743: PUSH
8744: LD_INT 3
8746: PUSH
8747: LD_INT 46
8749: PUSH
8750: EMPTY
8751: LIST
8752: LIST
8753: LIST
8754: LIST
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: LIST
8760: LIST
8761: LIST
8762: LIST
8763: PPUSH
8764: CALL 53537 0 2
// end else
8768: GO 8893
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
8770: LD_INT 2
8772: PPUSH
8773: LD_INT 24
8775: PUSH
8776: LD_INT 3
8778: PUSH
8779: LD_INT 3
8781: PUSH
8782: LD_INT 47
8784: PUSH
8785: EMPTY
8786: LIST
8787: LIST
8788: LIST
8789: LIST
8790: PUSH
8791: LD_INT 24
8793: PUSH
8794: LD_INT 3
8796: PUSH
8797: LD_INT 3
8799: PUSH
8800: LD_INT 47
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: LIST
8807: LIST
8808: PUSH
8809: LD_INT 24
8811: PUSH
8812: LD_INT 3
8814: PUSH
8815: LD_INT 3
8817: PUSH
8818: LD_INT 47
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 24
8829: PUSH
8830: LD_INT 3
8832: PUSH
8833: LD_INT 3
8835: PUSH
8836: LD_INT 46
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: PUSH
8845: LD_INT 24
8847: PUSH
8848: LD_INT 3
8850: PUSH
8851: LD_INT 3
8853: PUSH
8854: LD_INT 46
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: LIST
8861: LIST
8862: PUSH
8863: LD_INT 24
8865: PUSH
8866: LD_INT 3
8868: PUSH
8869: LD_INT 3
8871: PUSH
8872: LD_INT 46
8874: PUSH
8875: EMPTY
8876: LIST
8877: LIST
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: LIST
8887: LIST
8888: PPUSH
8889: CALL 53537 0 2
// end ; if Difficulty > 1 then
8893: LD_OWVAR 67
8897: PUSH
8898: LD_INT 1
8900: GREATER
8901: IFFALSE 8931
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
8903: LD_INT 2
8905: PPUSH
8906: LD_INT 24
8908: PUSH
8909: LD_INT 3
8911: PUSH
8912: LD_INT 3
8914: PUSH
8915: LD_INT 47
8917: PUSH
8918: EMPTY
8919: LIST
8920: LIST
8921: LIST
8922: LIST
8923: PUSH
8924: EMPTY
8925: LIST
8926: PPUSH
8927: CALL 53537 0 2
// repeat wait ( 0 0$1 ) ;
8931: LD_INT 35
8933: PPUSH
8934: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
8938: LD_INT 2
8940: PPUSH
8941: LD_INT 1
8943: PPUSH
8944: CALL 54950 0 2
8948: PUSH
8949: LD_INT 6
8951: PUSH
8952: LD_INT 7
8954: PUSH
8955: LD_INT 7
8957: PUSH
8958: EMPTY
8959: LIST
8960: LIST
8961: LIST
8962: PUSH
8963: LD_OWVAR 67
8967: ARRAY
8968: GREATEREQUAL
8969: IFFALSE 8931
// tmp := MC_GetVehicles ( 2 , true ) ;
8971: LD_ADDR_VAR 0 2
8975: PUSH
8976: LD_INT 2
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL 54950 0 2
8986: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
8987: LD_ADDR_EXP 118
8991: PUSH
8992: LD_EXP 118
8996: PPUSH
8997: LD_INT 2
8999: PPUSH
9000: LD_EXP 118
9004: PUSH
9005: LD_INT 2
9007: ARRAY
9008: PUSH
9009: LD_VAR 0 2
9013: DIFF
9014: PPUSH
9015: CALL_OW 1
9019: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
9020: LD_ADDR_VAR 0 3
9024: PUSH
9025: LD_INT 0
9027: PPUSH
9028: LD_INT 1
9030: PPUSH
9031: CALL_OW 12
9035: ST_TO_ADDR
// if target then
9036: LD_VAR 0 3
9040: IFFALSE 9099
// begin repeat ComMoveXY ( tmp , 139 , 89 ) ;
9042: LD_VAR 0 2
9046: PPUSH
9047: LD_INT 139
9049: PPUSH
9050: LD_INT 89
9052: PPUSH
9053: CALL_OW 111
// wait ( 0 0$1 ) ;
9057: LD_INT 35
9059: PPUSH
9060: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 6 ] ) > 3 ;
9064: LD_VAR 0 2
9068: PPUSH
9069: LD_INT 92
9071: PUSH
9072: LD_INT 139
9074: PUSH
9075: LD_INT 89
9077: PUSH
9078: LD_INT 6
9080: PUSH
9081: EMPTY
9082: LIST
9083: LIST
9084: LIST
9085: LIST
9086: PPUSH
9087: CALL_OW 72
9091: PUSH
9092: LD_INT 3
9094: GREATER
9095: IFFALSE 9042
// end else
9097: GO 9172
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
9099: LD_VAR 0 2
9103: PPUSH
9104: LD_VAR 0 4
9108: PUSH
9109: LD_INT 1
9111: ARRAY
9112: PPUSH
9113: CALL_OW 120
// repeat AddComMoveXY ( tmp , 124 , 139 ) ;
9117: LD_VAR 0 2
9121: PPUSH
9122: LD_INT 124
9124: PPUSH
9125: LD_INT 139
9127: PPUSH
9128: CALL_OW 171
// wait ( 0 0$1 ) ;
9132: LD_INT 35
9134: PPUSH
9135: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 6 ] ) > 5 ;
9139: LD_VAR 0 2
9143: PPUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 124
9149: PUSH
9150: LD_INT 139
9152: PUSH
9153: LD_INT 6
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: LIST
9161: PPUSH
9162: CALL_OW 72
9166: PUSH
9167: LD_INT 5
9169: GREATER
9170: IFFALSE 9117
// end ; repeat wait ( 0 0$1 ) ;
9172: LD_INT 35
9174: PPUSH
9175: CALL_OW 67
// for i in tmp do
9179: LD_ADDR_VAR 0 1
9183: PUSH
9184: LD_VAR 0 2
9188: PUSH
9189: FOR_IN
9190: IFFALSE 9348
// if GetLives ( i ) > 251 then
9192: LD_VAR 0 1
9196: PPUSH
9197: CALL_OW 256
9201: PUSH
9202: LD_INT 251
9204: GREATER
9205: IFFALSE 9330
// begin if GetWeapon ( i ) = ru_time_lapser then
9207: LD_VAR 0 1
9211: PPUSH
9212: CALL_OW 264
9216: PUSH
9217: LD_INT 49
9219: EQUAL
9220: IFFALSE 9276
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
9222: LD_VAR 0 1
9226: PPUSH
9227: LD_INT 2
9229: PUSH
9230: LD_INT 22
9232: PUSH
9233: LD_INT 1
9235: PUSH
9236: EMPTY
9237: LIST
9238: LIST
9239: PUSH
9240: LD_INT 22
9242: PUSH
9243: LD_INT 8
9245: PUSH
9246: EMPTY
9247: LIST
9248: LIST
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: LIST
9254: PPUSH
9255: CALL_OW 69
9259: PPUSH
9260: LD_VAR 0 1
9264: PPUSH
9265: CALL_OW 74
9269: PPUSH
9270: CALL_OW 112
9274: GO 9328
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
9276: LD_VAR 0 1
9280: PPUSH
9281: LD_INT 2
9283: PUSH
9284: LD_INT 22
9286: PUSH
9287: LD_INT 1
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 22
9296: PUSH
9297: LD_INT 8
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: LIST
9308: PPUSH
9309: CALL_OW 69
9313: PPUSH
9314: LD_VAR 0 1
9318: PPUSH
9319: CALL_OW 74
9323: PPUSH
9324: CALL_OW 115
// end else
9328: GO 9346
// tmp := tmp diff i ;
9330: LD_ADDR_VAR 0 2
9334: PUSH
9335: LD_VAR 0 2
9339: PUSH
9340: LD_VAR 0 1
9344: DIFF
9345: ST_TO_ADDR
9346: GO 9189
9348: POP
9349: POP
// until not tmp ;
9350: LD_VAR 0 2
9354: NOT
9355: IFFALSE 9172
// end ; end_of_file
9357: PPOPN 4
9359: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
9360: LD_INT 0
9362: PPUSH
9363: PPUSH
9364: PPUSH
9365: PPUSH
9366: PPUSH
9367: PPUSH
// side := 7 ;
9368: LD_ADDR_VAR 0 5
9372: PUSH
9373: LD_INT 7
9375: ST_TO_ADDR
// uc_side := side ;
9376: LD_ADDR_OWVAR 20
9380: PUSH
9381: LD_VAR 0 5
9385: ST_TO_ADDR
// uc_nation := 1 ;
9386: LD_ADDR_OWVAR 21
9390: PUSH
9391: LD_INT 1
9393: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
9394: LD_ADDR_VAR 0 2
9398: PUSH
9399: LD_INT 22
9401: PUSH
9402: LD_VAR 0 5
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 21
9413: PUSH
9414: LD_INT 3
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: FOR_IN
9431: IFFALSE 9447
// SetBLevel ( i , 10 ) ;
9433: LD_VAR 0 2
9437: PPUSH
9438: LD_INT 10
9440: PPUSH
9441: CALL_OW 241
9445: GO 9430
9447: POP
9448: POP
// base := GetBase ( al_depot ) ;
9449: LD_ADDR_VAR 0 4
9453: PUSH
9454: LD_INT 2
9456: PPUSH
9457: CALL_OW 274
9461: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
9462: LD_ADDR_VAR 0 6
9466: PUSH
9467: LD_INT 22
9469: PUSH
9470: LD_VAR 0 5
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 30
9481: PUSH
9482: LD_INT 34
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: ST_TO_ADDR
// if teleport then
9498: LD_VAR 0 6
9502: IFFALSE 9523
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
9504: LD_VAR 0 6
9508: PUSH
9509: LD_INT 1
9511: ARRAY
9512: PPUSH
9513: LD_INT 262
9515: PPUSH
9516: LD_INT 119
9518: PPUSH
9519: CALL_OW 243
// SetResourceType ( base , mat_cans , 3500 ) ;
9523: LD_VAR 0 4
9527: PPUSH
9528: LD_INT 1
9530: PPUSH
9531: LD_INT 3500
9533: PPUSH
9534: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
9538: LD_VAR 0 4
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: LD_INT 200
9548: PPUSH
9549: CALL_OW 277
// SetResourceType ( base , mat_siberit , 50 ) ;
9553: LD_VAR 0 4
9557: PPUSH
9558: LD_INT 3
9560: PPUSH
9561: LD_INT 50
9563: PPUSH
9564: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
9568: LD_ADDR_EXP 71
9572: PUSH
9573: LD_STRING Roth
9575: PPUSH
9576: CALL_OW 25
9580: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
9581: LD_ADDR_EXP 72
9585: PUSH
9586: LD_STRING Simms
9588: PPUSH
9589: LD_EXP 1
9593: NOT
9594: PPUSH
9595: LD_STRING 10c_
9597: PPUSH
9598: CALL 59432 0 3
9602: ST_TO_ADDR
// if not Simms then
9603: LD_EXP 72
9607: NOT
9608: IFFALSE 9638
// begin uc_nation := 1 ;
9610: LD_ADDR_OWVAR 21
9614: PUSH
9615: LD_INT 1
9617: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
9618: LD_INT 2
9620: PPUSH
9621: LD_INT 10
9623: PPUSH
9624: CALL_OW 384
// Simms := CreateHuman ;
9628: LD_ADDR_EXP 72
9632: PUSH
9633: CALL_OW 44
9637: ST_TO_ADDR
// end ; uc_nation := 3 ;
9638: LD_ADDR_OWVAR 21
9642: PUSH
9643: LD_INT 3
9645: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
9646: LD_ADDR_EXP 73
9650: PUSH
9651: LD_STRING Kirilenkova
9653: PPUSH
9654: CALL_OW 25
9658: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
9659: LD_ADDR_EXP 87
9663: PUSH
9664: LD_STRING Oblukov
9666: PPUSH
9667: CALL_OW 25
9671: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
9672: LD_ADDR_EXP 74
9676: PUSH
9677: LD_STRING Dolgov
9679: PPUSH
9680: CALL_OW 25
9684: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
9685: LD_ADDR_EXP 75
9689: PUSH
9690: LD_STRING Petrosyan
9692: PPUSH
9693: CALL_OW 25
9697: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
9698: LD_ADDR_EXP 86
9702: PUSH
9703: LD_STRING Scholtze
9705: PPUSH
9706: CALL_OW 25
9710: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
9711: LD_ADDR_EXP 85
9715: PUSH
9716: LD_STRING Kapitsova
9718: PPUSH
9719: CALL_OW 25
9723: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
9724: LD_ADDR_EXP 76
9728: PUSH
9729: LD_STRING Petrovova
9731: PPUSH
9732: CALL_OW 25
9736: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
9737: LD_ADDR_EXP 77
9741: PUSH
9742: LD_STRING Kuzmov
9744: PPUSH
9745: CALL_OW 25
9749: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
9750: LD_ADDR_EXP 84
9754: PUSH
9755: LD_STRING Karamazov
9757: PPUSH
9758: CALL_OW 25
9762: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
9763: LD_STRING 13_Lipshchin_1
9765: PPUSH
9766: LD_INT 0
9768: PPUSH
9769: CALL_OW 30
9773: IFFALSE 9788
// Lipshchin := NewCharacter ( Lipshchin ) ;
9775: LD_ADDR_EXP 78
9779: PUSH
9780: LD_STRING Lipshchin
9782: PPUSH
9783: CALL_OW 25
9787: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
9788: LD_STRING 13_Titov_1
9790: PPUSH
9791: LD_INT 0
9793: PPUSH
9794: CALL_OW 30
9798: IFFALSE 9813
// Titov := NewCharacter ( Titov ) ;
9800: LD_ADDR_EXP 80
9804: PUSH
9805: LD_STRING Titov
9807: PPUSH
9808: CALL_OW 25
9812: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
9813: LD_STRING 13_Gnyevko_1
9815: PPUSH
9816: LD_INT 0
9818: PPUSH
9819: CALL_OW 30
9823: IFFALSE 9838
// Gnyevko := NewCharacter ( Gnyevko ) ;
9825: LD_ADDR_EXP 79
9829: PUSH
9830: LD_STRING Gnyevko
9832: PPUSH
9833: CALL_OW 25
9837: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
9838: LD_STRING 13_Xavier_1
9840: PPUSH
9841: LD_INT 0
9843: PPUSH
9844: CALL_OW 30
9848: IFFALSE 9863
// Xavier := NewCharacter ( Xavier2 ) ;
9850: LD_ADDR_EXP 81
9854: PUSH
9855: LD_STRING Xavier2
9857: PPUSH
9858: CALL_OW 25
9862: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
9863: LD_STRING 13_Belkov_1
9865: PPUSH
9866: LD_INT 0
9868: PPUSH
9869: CALL_OW 30
9873: IFFALSE 9888
// Belkov := NewCharacter ( Belkov ) ;
9875: LD_ADDR_EXP 82
9879: PUSH
9880: LD_STRING Belkov
9882: PPUSH
9883: CALL_OW 25
9887: ST_TO_ADDR
// if not BurlakStatus then
9888: LD_EXP 9
9892: NOT
9893: IFFALSE 9908
// Burlak = NewCharacter ( Burlak ) ;
9895: LD_ADDR_EXP 83
9899: PUSH
9900: LD_STRING Burlak
9902: PPUSH
9903: CALL_OW 25
9907: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
9908: LD_ADDR_VAR 0 3
9912: PUSH
9913: LD_EXP 71
9917: PUSH
9918: LD_EXP 73
9922: PUSH
9923: LD_EXP 87
9927: PUSH
9928: LD_EXP 74
9932: PUSH
9933: LD_EXP 75
9937: PUSH
9938: LD_EXP 86
9942: PUSH
9943: LD_EXP 85
9947: PUSH
9948: LD_EXP 76
9952: PUSH
9953: LD_EXP 77
9957: PUSH
9958: LD_EXP 84
9962: PUSH
9963: EMPTY
9964: LIST
9965: LIST
9966: LIST
9967: LIST
9968: LIST
9969: LIST
9970: LIST
9971: LIST
9972: LIST
9973: LIST
9974: ST_TO_ADDR
// if Simms then
9975: LD_EXP 72
9979: IFFALSE 9997
// tmp := tmp ^ Simms ;
9981: LD_ADDR_VAR 0 3
9985: PUSH
9986: LD_VAR 0 3
9990: PUSH
9991: LD_EXP 72
9995: ADD
9996: ST_TO_ADDR
// if Titov then
9997: LD_EXP 80
10001: IFFALSE 10019
// tmp := tmp ^ Titov ;
10003: LD_ADDR_VAR 0 3
10007: PUSH
10008: LD_VAR 0 3
10012: PUSH
10013: LD_EXP 80
10017: ADD
10018: ST_TO_ADDR
// if Lipshchin then
10019: LD_EXP 78
10023: IFFALSE 10041
// tmp := tmp ^ Lipshchin ;
10025: LD_ADDR_VAR 0 3
10029: PUSH
10030: LD_VAR 0 3
10034: PUSH
10035: LD_EXP 78
10039: ADD
10040: ST_TO_ADDR
// if Gnyevko then
10041: LD_EXP 79
10045: IFFALSE 10063
// tmp := tmp ^ Gnyevko ;
10047: LD_ADDR_VAR 0 3
10051: PUSH
10052: LD_VAR 0 3
10056: PUSH
10057: LD_EXP 79
10061: ADD
10062: ST_TO_ADDR
// if Xavier then
10063: LD_EXP 81
10067: IFFALSE 10085
// tmp := tmp ^ Xavier ;
10069: LD_ADDR_VAR 0 3
10073: PUSH
10074: LD_VAR 0 3
10078: PUSH
10079: LD_EXP 81
10083: ADD
10084: ST_TO_ADDR
// if Belkov then
10085: LD_EXP 82
10089: IFFALSE 10107
// tmp := tmp ^ Belkov ;
10091: LD_ADDR_VAR 0 3
10095: PUSH
10096: LD_VAR 0 3
10100: PUSH
10101: LD_EXP 82
10105: ADD
10106: ST_TO_ADDR
// if Burlak then
10107: LD_EXP 83
10111: IFFALSE 10129
// tmp := tmp ^ Burlak ;
10113: LD_ADDR_VAR 0 3
10117: PUSH
10118: LD_VAR 0 3
10122: PUSH
10123: LD_EXP 83
10127: ADD
10128: ST_TO_ADDR
// for i = 1 to 8 do
10129: LD_ADDR_VAR 0 2
10133: PUSH
10134: DOUBLE
10135: LD_INT 1
10137: DEC
10138: ST_TO_ADDR
10139: LD_INT 8
10141: PUSH
10142: FOR_TO
10143: IFFALSE 10209
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
10145: LD_ADDR_OWVAR 21
10149: PUSH
10150: LD_INT 1
10152: PUSH
10153: LD_INT 3
10155: PUSH
10156: EMPTY
10157: LIST
10158: LIST
10159: PUSH
10160: LD_INT 1
10162: PPUSH
10163: LD_INT 2
10165: PPUSH
10166: CALL_OW 12
10170: ARRAY
10171: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
10172: LD_INT 0
10174: PPUSH
10175: LD_VAR 0 2
10179: PUSH
10180: LD_INT 2
10182: DIV
10183: PPUSH
10184: LD_INT 10
10186: PPUSH
10187: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
10191: LD_ADDR_VAR 0 3
10195: PUSH
10196: LD_VAR 0 3
10200: PUSH
10201: CALL_OW 44
10205: ADD
10206: ST_TO_ADDR
// end ;
10207: GO 10142
10209: POP
10210: POP
// for i in tmp do
10211: LD_ADDR_VAR 0 2
10215: PUSH
10216: LD_VAR 0 3
10220: PUSH
10221: FOR_IN
10222: IFFALSE 10247
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
10224: LD_VAR 0 2
10228: PPUSH
10229: LD_INT 260
10231: PPUSH
10232: LD_INT 235
10234: PPUSH
10235: LD_INT 8
10237: PPUSH
10238: LD_INT 0
10240: PPUSH
10241: CALL_OW 50
10245: GO 10221
10247: POP
10248: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
10249: LD_ADDR_EXP 99
10253: PUSH
10254: LD_EXP 99
10258: PPUSH
10259: LD_INT 1
10261: PPUSH
10262: LD_INT 22
10264: PUSH
10265: LD_VAR 0 5
10269: PUSH
10270: EMPTY
10271: LIST
10272: LIST
10273: PUSH
10274: LD_INT 3
10276: PUSH
10277: LD_INT 21
10279: PUSH
10280: LD_INT 2
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: PUSH
10287: EMPTY
10288: LIST
10289: LIST
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: PUSH
10300: LD_EXP 71
10304: PUSH
10305: LD_EXP 72
10309: PUSH
10310: EMPTY
10311: LIST
10312: LIST
10313: DIFF
10314: PPUSH
10315: CALL_OW 1
10319: ST_TO_ADDR
// uc_side := 0 ;
10320: LD_ADDR_OWVAR 20
10324: PUSH
10325: LD_INT 0
10327: ST_TO_ADDR
// uc_nation := 0 ;
10328: LD_ADDR_OWVAR 21
10332: PUSH
10333: LD_INT 0
10335: ST_TO_ADDR
// for i = 1 to 5 do
10336: LD_ADDR_VAR 0 2
10340: PUSH
10341: DOUBLE
10342: LD_INT 1
10344: DEC
10345: ST_TO_ADDR
10346: LD_INT 5
10348: PUSH
10349: FOR_TO
10350: IFFALSE 10387
// begin InitHc ;
10352: CALL_OW 19
// hc_class := class_apeman ;
10356: LD_ADDR_OWVAR 28
10360: PUSH
10361: LD_INT 12
10363: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
10364: CALL_OW 44
10368: PPUSH
10369: LD_INT 299
10371: PPUSH
10372: LD_INT 229
10374: PPUSH
10375: LD_INT 10
10377: PPUSH
10378: LD_INT 0
10380: PPUSH
10381: CALL_OW 50
// end ;
10385: GO 10349
10387: POP
10388: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
10389: LD_EXP 71
10393: PPUSH
10394: LD_INT 259
10396: PPUSH
10397: LD_INT 235
10399: PPUSH
10400: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
10404: LD_EXP 71
10408: PPUSH
10409: LD_INT 262
10411: PPUSH
10412: LD_INT 235
10414: PPUSH
10415: CALL_OW 178
// if Simms then
10419: LD_EXP 72
10423: IFFALSE 10454
// begin ComMoveXY ( Simms , 262 , 235 ) ;
10425: LD_EXP 72
10429: PPUSH
10430: LD_INT 262
10432: PPUSH
10433: LD_INT 235
10435: PPUSH
10436: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
10440: LD_EXP 72
10444: PPUSH
10445: LD_EXP 71
10449: PPUSH
10450: CALL_OW 179
// end ; end ;
10454: LD_VAR 0 1
10458: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp ;
10459: LD_EXP 31
10463: PUSH
10464: LD_EXP 23
10468: NOT
10469: AND
10470: IFFALSE 10611
10472: GO 10474
10474: DISABLE
10475: LD_INT 0
10477: PPUSH
10478: PPUSH
// begin enable ;
10479: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
10480: LD_ADDR_VAR 0 2
10484: PUSH
10485: LD_INT 81
10487: PUSH
10488: LD_INT 7
10490: PUSH
10491: EMPTY
10492: LIST
10493: LIST
10494: PUSH
10495: LD_INT 2
10497: PUSH
10498: LD_INT 32
10500: PUSH
10501: LD_INT 3
10503: PUSH
10504: EMPTY
10505: LIST
10506: LIST
10507: PUSH
10508: LD_INT 30
10510: PUSH
10511: LD_INT 30
10513: PUSH
10514: EMPTY
10515: LIST
10516: LIST
10517: PUSH
10518: LD_INT 30
10520: PUSH
10521: LD_INT 28
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: PUSH
10528: LD_INT 34
10530: PUSH
10531: LD_INT 49
10533: PUSH
10534: EMPTY
10535: LIST
10536: LIST
10537: PUSH
10538: LD_INT 34
10540: PUSH
10541: LD_INT 10
10543: PUSH
10544: EMPTY
10545: LIST
10546: LIST
10547: PUSH
10548: LD_INT 34
10550: PUSH
10551: LD_INT 8
10553: PUSH
10554: EMPTY
10555: LIST
10556: LIST
10557: PUSH
10558: EMPTY
10559: LIST
10560: LIST
10561: LIST
10562: LIST
10563: LIST
10564: LIST
10565: LIST
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: PPUSH
10571: CALL_OW 69
10575: ST_TO_ADDR
// if not tmp then
10576: LD_VAR 0 2
10580: NOT
10581: IFFALSE 10585
// exit ;
10583: GO 10611
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 0 ) ;
10585: LD_VAR 0 2
10589: PUSH
10590: LD_INT 1
10592: PPUSH
10593: LD_VAR 0 2
10597: PPUSH
10598: CALL_OW 12
10602: ARRAY
10603: PPUSH
10604: LD_INT 0
10606: PPUSH
10607: CALL_OW 234
// end ;
10611: PPOPN 2
10613: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
10614: LD_EXP 23
10618: NOT
10619: PUSH
10620: LD_EXP 31
10624: AND
10625: IFFALSE 11179
10627: GO 10629
10629: DISABLE
10630: LD_INT 0
10632: PPUSH
10633: PPUSH
10634: PPUSH
// begin uc_side := 7 ;
10635: LD_ADDR_OWVAR 20
10639: PUSH
10640: LD_INT 7
10642: ST_TO_ADDR
// uc_nation := 1 ;
10643: LD_ADDR_OWVAR 21
10647: PUSH
10648: LD_INT 1
10650: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
10651: LD_ADDR_VAR 0 3
10655: PUSH
10656: LD_INT 125
10658: PUSH
10659: LD_INT 163
10661: PUSH
10662: EMPTY
10663: LIST
10664: LIST
10665: PUSH
10666: LD_INT 185
10668: PUSH
10669: LD_INT 168
10671: PUSH
10672: EMPTY
10673: LIST
10674: LIST
10675: PUSH
10676: LD_INT 111
10678: PUSH
10679: LD_INT 97
10681: PUSH
10682: EMPTY
10683: LIST
10684: LIST
10685: PUSH
10686: EMPTY
10687: LIST
10688: LIST
10689: LIST
10690: PPUSH
10691: CALL 101840 0 1
10695: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
10696: LD_ADDR_EXP 88
10700: PUSH
10701: EMPTY
10702: ST_TO_ADDR
// for i = 1 to Difficulty do
10703: LD_ADDR_VAR 0 1
10707: PUSH
10708: DOUBLE
10709: LD_INT 1
10711: DEC
10712: ST_TO_ADDR
10713: LD_OWVAR 67
10717: PUSH
10718: FOR_TO
10719: IFFALSE 10877
// begin InitHc ;
10721: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
10725: LD_INT 0
10727: PPUSH
10728: LD_INT 8
10730: PPUSH
10731: CALL_OW 381
// un := CreateHuman ;
10735: LD_ADDR_VAR 0 2
10739: PUSH
10740: CALL_OW 44
10744: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
10745: LD_VAR 0 2
10749: PPUSH
10750: LD_INT 258
10752: PPUSH
10753: LD_INT 267
10755: PPUSH
10756: LD_INT 4
10758: PPUSH
10759: LD_INT 0
10761: PPUSH
10762: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
10766: LD_ADDR_EXP 88
10770: PUSH
10771: LD_EXP 88
10775: PUSH
10776: LD_VAR 0 2
10780: UNION
10781: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
10782: LD_VAR 0 2
10786: PPUSH
10787: LD_VAR 0 3
10791: PUSH
10792: LD_VAR 0 1
10796: ARRAY
10797: PUSH
10798: LD_INT 1
10800: ARRAY
10801: PPUSH
10802: LD_VAR 0 3
10806: PUSH
10807: LD_VAR 0 1
10811: ARRAY
10812: PUSH
10813: LD_INT 2
10815: ARRAY
10816: PPUSH
10817: LD_INT 4
10819: PPUSH
10820: LD_INT 1
10822: PPUSH
10823: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
10827: LD_VAR 0 2
10831: PPUSH
10832: LD_VAR 0 3
10836: PUSH
10837: LD_VAR 0 1
10841: ARRAY
10842: PUSH
10843: LD_INT 1
10845: ARRAY
10846: PPUSH
10847: LD_VAR 0 3
10851: PUSH
10852: LD_VAR 0 1
10856: ARRAY
10857: PUSH
10858: LD_INT 2
10860: ARRAY
10861: PPUSH
10862: CALL_OW 171
// AddComInvisible ( un ) ;
10866: LD_VAR 0 2
10870: PPUSH
10871: CALL_OW 212
// end ;
10875: GO 10718
10877: POP
10878: POP
// repeat wait ( 0 0$20 ) ;
10879: LD_INT 700
10881: PPUSH
10882: CALL_OW 67
// for i in allianceSpecialForce do
10886: LD_ADDR_VAR 0 1
10890: PUSH
10891: LD_EXP 88
10895: PUSH
10896: FOR_IN
10897: IFFALSE 11164
// begin if IsInvisible ( i ) then
10899: LD_VAR 0 1
10903: PPUSH
10904: CALL_OW 571
10908: IFFALSE 11133
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_not , [ f_driving ] ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
10910: LD_ADDR_VAR 0 3
10914: PUSH
10915: LD_INT 22
10917: PUSH
10918: LD_INT 1
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PUSH
10925: LD_INT 50
10927: PUSH
10928: EMPTY
10929: LIST
10930: PUSH
10931: LD_INT 3
10933: PUSH
10934: LD_INT 55
10936: PUSH
10937: EMPTY
10938: LIST
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: PUSH
10944: LD_INT 91
10946: PUSH
10947: LD_VAR 0 1
10951: PUSH
10952: LD_INT 25
10954: PUSH
10955: LD_INT 30
10957: PUSH
10958: LD_INT 35
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: PUSH
10966: LD_OWVAR 67
10970: ARRAY
10971: PUSH
10972: EMPTY
10973: LIST
10974: LIST
10975: LIST
10976: PUSH
10977: LD_INT 2
10979: PUSH
10980: LD_INT 25
10982: PUSH
10983: LD_INT 1
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: LD_INT 25
10992: PUSH
10993: LD_INT 2
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 25
11002: PUSH
11003: LD_INT 3
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: LD_INT 25
11012: PUSH
11013: LD_INT 4
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: LD_INT 25
11022: PUSH
11023: LD_INT 5
11025: PUSH
11026: EMPTY
11027: LIST
11028: LIST
11029: PUSH
11030: LD_INT 25
11032: PUSH
11033: LD_INT 8
11035: PUSH
11036: EMPTY
11037: LIST
11038: LIST
11039: PUSH
11040: EMPTY
11041: LIST
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: LIST
11053: LIST
11054: LIST
11055: PPUSH
11056: CALL_OW 69
11060: ST_TO_ADDR
// display_strings := [ tick , i , tmp ] ;
11061: LD_ADDR_OWVAR 47
11065: PUSH
11066: LD_OWVAR 1
11070: PUSH
11071: LD_VAR 0 1
11075: PUSH
11076: LD_VAR 0 3
11080: PUSH
11081: EMPTY
11082: LIST
11083: LIST
11084: LIST
11085: ST_TO_ADDR
// if not tmp then
11086: LD_VAR 0 3
11090: NOT
11091: IFFALSE 11095
// continue ;
11093: GO 10896
// if Prob ( 30 * Difficulty ) then
11095: LD_INT 30
11097: PUSH
11098: LD_OWVAR 67
11102: MUL
11103: PPUSH
11104: CALL_OW 13
11108: IFFALSE 11133
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
11110: LD_VAR 0 3
11114: PUSH
11115: LD_INT 1
11117: PPUSH
11118: LD_VAR 0 3
11122: PPUSH
11123: CALL_OW 12
11127: ARRAY
11128: PPUSH
11129: CALL 28060 0 1
// end ; if IsDead ( i ) then
11133: LD_VAR 0 1
11137: PPUSH
11138: CALL_OW 301
11142: IFFALSE 11162
// begin allianceSpecialForce := allianceSpecialForce diff i ;
11144: LD_ADDR_EXP 88
11148: PUSH
11149: LD_EXP 88
11153: PUSH
11154: LD_VAR 0 1
11158: DIFF
11159: ST_TO_ADDR
// continue ;
11160: GO 10896
// end ; end ;
11162: GO 10896
11164: POP
11165: POP
// until allianceDestroyed or not allianceSpecialForce ;
11166: LD_EXP 23
11170: PUSH
11171: LD_EXP 88
11175: NOT
11176: OR
11177: IFFALSE 10879
// end ;
11179: PPOPN 3
11181: END
// every 11 11$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
11182: LD_EXP 23
11186: NOT
11187: PUSH
11188: LD_EXP 31
11192: AND
11193: IFFALSE 12015
11195: GO 11197
11197: DISABLE
11198: LD_INT 0
11200: PPUSH
11201: PPUSH
11202: PPUSH
11203: PPUSH
// begin enable ;
11204: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
11205: LD_INT 22
11207: PUSH
11208: LD_INT 7
11210: PUSH
11211: EMPTY
11212: LIST
11213: LIST
11214: PUSH
11215: LD_INT 30
11217: PUSH
11218: LD_INT 3
11220: PUSH
11221: EMPTY
11222: LIST
11223: LIST
11224: PUSH
11225: EMPTY
11226: LIST
11227: LIST
11228: PPUSH
11229: CALL_OW 69
11233: NOT
11234: IFFALSE 11238
// exit ;
11236: GO 12015
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
11238: LD_ADDR_VAR 0 4
11242: PUSH
11243: LD_INT 22
11245: PUSH
11246: LD_INT 7
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: LD_INT 30
11255: PUSH
11256: LD_INT 34
11258: PUSH
11259: EMPTY
11260: LIST
11261: LIST
11262: PUSH
11263: EMPTY
11264: LIST
11265: LIST
11266: PPUSH
11267: CALL_OW 69
11271: ST_TO_ADDR
// if Prob ( 40 ) then
11272: LD_INT 40
11274: PPUSH
11275: CALL_OW 13
11279: IFFALSE 11406
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
11281: LD_INT 1
11283: PPUSH
11284: LD_INT 5
11286: PUSH
11287: LD_INT 3
11289: PUSH
11290: LD_INT 2
11292: PUSH
11293: LD_INT 6
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: LIST
11300: LIST
11301: PUSH
11302: LD_INT 5
11304: PUSH
11305: LD_INT 3
11307: PUSH
11308: LD_INT 2
11310: PUSH
11311: LD_INT 6
11313: PUSH
11314: EMPTY
11315: LIST
11316: LIST
11317: LIST
11318: LIST
11319: PUSH
11320: LD_INT 5
11322: PUSH
11323: LD_INT 3
11325: PUSH
11326: LD_INT 2
11328: PUSH
11329: LD_INT 6
11331: PUSH
11332: EMPTY
11333: LIST
11334: LIST
11335: LIST
11336: LIST
11337: PUSH
11338: LD_INT 24
11340: PUSH
11341: LD_INT 3
11343: PUSH
11344: LD_INT 3
11346: PUSH
11347: LD_INT 45
11349: PUSH
11350: EMPTY
11351: LIST
11352: LIST
11353: LIST
11354: LIST
11355: PUSH
11356: LD_INT 24
11358: PUSH
11359: LD_INT 3
11361: PUSH
11362: LD_INT 3
11364: PUSH
11365: LD_INT 47
11367: PUSH
11368: EMPTY
11369: LIST
11370: LIST
11371: LIST
11372: LIST
11373: PUSH
11374: LD_INT 24
11376: PUSH
11377: LD_INT 3
11379: PUSH
11380: LD_INT 3
11382: PUSH
11383: LD_INT 45
11385: PUSH
11386: EMPTY
11387: LIST
11388: LIST
11389: LIST
11390: LIST
11391: PUSH
11392: EMPTY
11393: LIST
11394: LIST
11395: LIST
11396: LIST
11397: LIST
11398: LIST
11399: PPUSH
11400: CALL 53537 0 2
// end else
11404: GO 11529
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
11406: LD_INT 1
11408: PPUSH
11409: LD_INT 24
11411: PUSH
11412: LD_INT 3
11414: PUSH
11415: LD_INT 3
11417: PUSH
11418: LD_INT 47
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: LIST
11425: LIST
11426: PUSH
11427: LD_INT 24
11429: PUSH
11430: LD_INT 3
11432: PUSH
11433: LD_INT 3
11435: PUSH
11436: LD_INT 47
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: LIST
11443: LIST
11444: PUSH
11445: LD_INT 24
11447: PUSH
11448: LD_INT 1
11450: PUSH
11451: LD_INT 3
11453: PUSH
11454: LD_INT 45
11456: PUSH
11457: EMPTY
11458: LIST
11459: LIST
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 24
11465: PUSH
11466: LD_INT 1
11468: PUSH
11469: LD_INT 3
11471: PUSH
11472: LD_INT 45
11474: PUSH
11475: EMPTY
11476: LIST
11477: LIST
11478: LIST
11479: LIST
11480: PUSH
11481: LD_INT 24
11483: PUSH
11484: LD_INT 1
11486: PUSH
11487: LD_INT 3
11489: PUSH
11490: LD_INT 45
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: LD_INT 24
11501: PUSH
11502: LD_INT 1
11504: PUSH
11505: LD_INT 3
11507: PUSH
11508: LD_INT 45
11510: PUSH
11511: EMPTY
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: PUSH
11517: EMPTY
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: PPUSH
11525: CALL 53537 0 2
// end ; if Difficulty > 1 then
11529: LD_OWVAR 67
11533: PUSH
11534: LD_INT 1
11536: GREATER
11537: IFFALSE 11567
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
11539: LD_INT 1
11541: PPUSH
11542: LD_INT 24
11544: PUSH
11545: LD_INT 3
11547: PUSH
11548: LD_INT 3
11550: PUSH
11551: LD_INT 47
11553: PUSH
11554: EMPTY
11555: LIST
11556: LIST
11557: LIST
11558: LIST
11559: PUSH
11560: EMPTY
11561: LIST
11562: PPUSH
11563: CALL 53537 0 2
// repeat wait ( 0 0$1 ) ;
11567: LD_INT 35
11569: PPUSH
11570: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
11574: LD_INT 1
11576: PPUSH
11577: LD_INT 1
11579: PPUSH
11580: CALL 54950 0 2
11584: PUSH
11585: LD_INT 6
11587: PUSH
11588: LD_INT 7
11590: PUSH
11591: LD_INT 7
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: LIST
11598: PUSH
11599: LD_OWVAR 67
11603: ARRAY
11604: GREATEREQUAL
11605: IFFALSE 11567
// tmp := MC_GetVehicles ( 1 , true ) ;
11607: LD_ADDR_VAR 0 2
11611: PUSH
11612: LD_INT 1
11614: PPUSH
11615: LD_INT 1
11617: PPUSH
11618: CALL 54950 0 2
11622: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
11623: LD_ADDR_EXP 118
11627: PUSH
11628: LD_EXP 118
11632: PPUSH
11633: LD_INT 1
11635: PPUSH
11636: LD_EXP 118
11640: PUSH
11641: LD_INT 1
11643: ARRAY
11644: PUSH
11645: LD_VAR 0 2
11649: DIFF
11650: PPUSH
11651: CALL_OW 1
11655: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11656: LD_ADDR_VAR 0 3
11660: PUSH
11661: LD_INT 0
11663: PPUSH
11664: LD_INT 1
11666: PPUSH
11667: CALL_OW 12
11671: ST_TO_ADDR
// if target then
11672: LD_VAR 0 3
11676: IFFALSE 11773
// begin for i in tmp do
11678: LD_ADDR_VAR 0 1
11682: PUSH
11683: LD_VAR 0 2
11687: PUSH
11688: FOR_IN
11689: IFFALSE 11714
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
11691: LD_VAR 0 1
11695: PPUSH
11696: LD_INT 179
11698: PPUSH
11699: LD_INT 209
11701: PPUSH
11702: LD_INT 8
11704: PPUSH
11705: LD_INT 1
11707: PPUSH
11708: CALL_OW 483
11712: GO 11688
11714: POP
11715: POP
// repeat AddComMoveXY ( tmp , 179 , 209 ) ;
11716: LD_VAR 0 2
11720: PPUSH
11721: LD_INT 179
11723: PPUSH
11724: LD_INT 209
11726: PPUSH
11727: CALL_OW 171
// wait ( 0 0$1 ) ;
11731: LD_INT 35
11733: PPUSH
11734: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 6 ] ) > 3 ;
11738: LD_VAR 0 2
11742: PPUSH
11743: LD_INT 92
11745: PUSH
11746: LD_INT 179
11748: PUSH
11749: LD_INT 209
11751: PUSH
11752: LD_INT 6
11754: PUSH
11755: EMPTY
11756: LIST
11757: LIST
11758: LIST
11759: LIST
11760: PPUSH
11761: CALL_OW 72
11765: PUSH
11766: LD_INT 3
11768: GREATER
11769: IFFALSE 11716
// end else
11771: GO 11866
// begin for i in tmp do
11773: LD_ADDR_VAR 0 1
11777: PUSH
11778: LD_VAR 0 2
11782: PUSH
11783: FOR_IN
11784: IFFALSE 11809
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
11786: LD_VAR 0 1
11790: PPUSH
11791: LD_INT 285
11793: PPUSH
11794: LD_INT 163
11796: PPUSH
11797: LD_INT 8
11799: PPUSH
11800: LD_INT 1
11802: PPUSH
11803: CALL_OW 483
11807: GO 11783
11809: POP
11810: POP
// repeat AddComMoveXY ( tmp , 285 , 163 ) ;
11811: LD_VAR 0 2
11815: PPUSH
11816: LD_INT 285
11818: PPUSH
11819: LD_INT 163
11821: PPUSH
11822: CALL_OW 171
// wait ( 0 0$1 ) ;
11826: LD_INT 35
11828: PPUSH
11829: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 6 ] ) > 3 ;
11833: LD_VAR 0 2
11837: PPUSH
11838: LD_INT 92
11840: PUSH
11841: LD_INT 285
11843: PUSH
11844: LD_INT 163
11846: PUSH
11847: LD_INT 6
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: PPUSH
11856: CALL_OW 72
11860: PUSH
11861: LD_INT 3
11863: GREATER
11864: IFFALSE 11811
// end ; repeat wait ( 0 0$1 ) ;
11866: LD_INT 35
11868: PPUSH
11869: CALL_OW 67
// for i in tmp do
11873: LD_ADDR_VAR 0 1
11877: PUSH
11878: LD_VAR 0 2
11882: PUSH
11883: FOR_IN
11884: IFFALSE 12006
// if GetLives ( i ) > 251 then
11886: LD_VAR 0 1
11890: PPUSH
11891: CALL_OW 256
11895: PUSH
11896: LD_INT 251
11898: GREATER
11899: IFFALSE 11988
// begin if GetWeapon ( i ) = ru_time_lapser then
11901: LD_VAR 0 1
11905: PPUSH
11906: CALL_OW 264
11910: PUSH
11911: LD_INT 49
11913: EQUAL
11914: IFFALSE 11952
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
11916: LD_VAR 0 1
11920: PPUSH
11921: LD_INT 81
11923: PUSH
11924: LD_INT 7
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: PPUSH
11931: CALL_OW 69
11935: PPUSH
11936: LD_VAR 0 1
11940: PPUSH
11941: CALL_OW 74
11945: PPUSH
11946: CALL_OW 112
11950: GO 11986
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
11952: LD_VAR 0 1
11956: PPUSH
11957: LD_INT 81
11959: PUSH
11960: LD_INT 7
11962: PUSH
11963: EMPTY
11964: LIST
11965: LIST
11966: PPUSH
11967: CALL_OW 69
11971: PPUSH
11972: LD_VAR 0 1
11976: PPUSH
11977: CALL_OW 74
11981: PPUSH
11982: CALL_OW 115
// end else
11986: GO 12004
// tmp := tmp diff i ;
11988: LD_ADDR_VAR 0 2
11992: PUSH
11993: LD_VAR 0 2
11997: PUSH
11998: LD_VAR 0 1
12002: DIFF
12003: ST_TO_ADDR
12004: GO 11883
12006: POP
12007: POP
// until not tmp ;
12008: LD_VAR 0 2
12012: NOT
12013: IFFALSE 11866
// end ; end_of_file
12015: PPOPN 4
12017: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
12018: LD_INT 0
12020: PPUSH
12021: PPUSH
12022: PPUSH
12023: PPUSH
// missionStage := 13 ;
12024: LD_ADDR_EXP 15
12028: PUSH
12029: LD_INT 13
12031: ST_TO_ADDR
// uc_side := 2 ;
12032: LD_ADDR_OWVAR 20
12036: PUSH
12037: LD_INT 2
12039: ST_TO_ADDR
// uc_nation := 2 ;
12040: LD_ADDR_OWVAR 21
12044: PUSH
12045: LD_INT 2
12047: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
12048: LD_ADDR_EXP 89
12052: PUSH
12053: LD_STRING Omar
12055: PPUSH
12056: CALL_OW 25
12060: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
12061: LD_EXP 89
12065: PPUSH
12066: LD_INT 4
12068: PPUSH
12069: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
12073: LD_EXP 89
12077: PPUSH
12078: LD_INT 242
12080: PPUSH
12081: LD_INT 75
12083: PPUSH
12084: LD_INT 0
12086: PPUSH
12087: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
12091: LD_ADDR_EXP 90
12095: PUSH
12096: LD_STRING Heike
12098: PPUSH
12099: CALL_OW 25
12103: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
12104: LD_INT 14
12106: PPUSH
12107: LD_INT 3
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: LD_INT 27
12115: PPUSH
12116: LD_INT 100
12118: PPUSH
12119: CALL 66065 0 5
// veh := CreateVehicle ;
12123: LD_ADDR_VAR 0 3
12127: PUSH
12128: CALL_OW 45
12132: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
12133: LD_VAR 0 3
12137: PPUSH
12138: LD_INT 1
12140: PPUSH
12141: CALL_OW 242
// SetDir ( veh , 4 ) ;
12145: LD_VAR 0 3
12149: PPUSH
12150: LD_INT 4
12152: PPUSH
12153: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
12157: LD_VAR 0 3
12161: PPUSH
12162: LD_INT 241
12164: PPUSH
12165: LD_INT 72
12167: PPUSH
12168: LD_INT 0
12170: PPUSH
12171: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
12175: LD_EXP 90
12179: PPUSH
12180: LD_VAR 0 3
12184: PPUSH
12185: CALL_OW 52
// if KhatamStatus then
12189: LD_EXP 8
12193: IFFALSE 12244
// begin Khatam := NewCharacter ( Khatam ) ;
12195: LD_ADDR_EXP 91
12199: PUSH
12200: LD_STRING Khatam
12202: PPUSH
12203: CALL_OW 25
12207: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
12208: LD_EXP 91
12212: PPUSH
12213: LD_INT 245
12215: PPUSH
12216: LD_INT 78
12218: PPUSH
12219: LD_INT 3
12221: PPUSH
12222: LD_INT 0
12224: PPUSH
12225: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
12229: LD_EXP 91
12233: PPUSH
12234: LD_INT 4
12236: PPUSH
12237: LD_INT 10
12239: PPUSH
12240: CALL_OW 237
// end ; for i = 1 to Difficulty do
12244: LD_ADDR_VAR 0 2
12248: PUSH
12249: DOUBLE
12250: LD_INT 1
12252: DEC
12253: ST_TO_ADDR
12254: LD_OWVAR 67
12258: PUSH
12259: FOR_TO
12260: IFFALSE 12324
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
12262: LD_INT 0
12264: PPUSH
12265: LD_INT 7
12267: PUSH
12268: LD_OWVAR 67
12272: PLUS
12273: PPUSH
12274: CALL_OW 381
// un := CreateHuman ;
12278: LD_ADDR_VAR 0 4
12282: PUSH
12283: CALL_OW 44
12287: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ rand ( 1 , 2 ) ] , false ) ;
12288: LD_VAR 0 4
12292: PPUSH
12293: LD_INT 28
12295: PUSH
12296: LD_INT 29
12298: PUSH
12299: EMPTY
12300: LIST
12301: LIST
12302: PUSH
12303: LD_INT 1
12305: PPUSH
12306: LD_INT 2
12308: PPUSH
12309: CALL_OW 12
12313: ARRAY
12314: PPUSH
12315: LD_INT 0
12317: PPUSH
12318: CALL_OW 49
// end ;
12322: GO 12259
12324: POP
12325: POP
// for i = 1 to 4 do
12326: LD_ADDR_VAR 0 2
12330: PUSH
12331: DOUBLE
12332: LD_INT 1
12334: DEC
12335: ST_TO_ADDR
12336: LD_INT 4
12338: PUSH
12339: FOR_TO
12340: IFFALSE 12385
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
12342: LD_INT 0
12344: PPUSH
12345: LD_INT 7
12347: PUSH
12348: LD_OWVAR 67
12352: PLUS
12353: PPUSH
12354: CALL_OW 381
// un := CreateHuman ;
12358: LD_ADDR_VAR 0 4
12362: PUSH
12363: CALL_OW 44
12367: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
12368: LD_VAR 0 4
12372: PPUSH
12373: LD_INT 28
12375: PPUSH
12376: LD_INT 0
12378: PPUSH
12379: CALL_OW 49
// end ;
12383: GO 12339
12385: POP
12386: POP
// for i = 1 to 3 do
12387: LD_ADDR_VAR 0 2
12391: PUSH
12392: DOUBLE
12393: LD_INT 1
12395: DEC
12396: ST_TO_ADDR
12397: LD_INT 3
12399: PUSH
12400: FOR_TO
12401: IFFALSE 12449
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
12403: LD_INT 0
12405: PPUSH
12406: LD_INT 8
12408: PPUSH
12409: LD_INT 7
12411: PUSH
12412: LD_OWVAR 67
12416: PLUS
12417: PPUSH
12418: CALL_OW 380
// un := CreateHuman ;
12422: LD_ADDR_VAR 0 4
12426: PUSH
12427: CALL_OW 44
12431: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
12432: LD_VAR 0 4
12436: PPUSH
12437: LD_INT 28
12439: PPUSH
12440: LD_INT 0
12442: PPUSH
12443: CALL_OW 49
// end ;
12447: GO 12400
12449: POP
12450: POP
// for i = 1 to 3 do
12451: LD_ADDR_VAR 0 2
12455: PUSH
12456: DOUBLE
12457: LD_INT 1
12459: DEC
12460: ST_TO_ADDR
12461: LD_INT 3
12463: PUSH
12464: FOR_TO
12465: IFFALSE 12555
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
12467: LD_INT 14
12469: PPUSH
12470: LD_INT 2
12472: PPUSH
12473: LD_INT 1
12475: PPUSH
12476: LD_INT 28
12478: PPUSH
12479: LD_INT 80
12481: PPUSH
12482: CALL 66065 0 5
// veh := CreateVehicle ;
12486: LD_ADDR_VAR 0 3
12490: PUSH
12491: CALL_OW 45
12495: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
12496: LD_VAR 0 3
12500: PPUSH
12501: LD_INT 3
12503: PPUSH
12504: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
12508: LD_VAR 0 3
12512: PPUSH
12513: LD_INT 29
12515: PPUSH
12516: LD_INT 0
12518: PPUSH
12519: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
12523: LD_INT 0
12525: PPUSH
12526: LD_INT 7
12528: PUSH
12529: LD_OWVAR 67
12533: PLUS
12534: PPUSH
12535: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
12539: CALL_OW 44
12543: PPUSH
12544: LD_VAR 0 3
12548: PPUSH
12549: CALL_OW 52
// end ;
12553: GO 12464
12555: POP
12556: POP
// for i = 1 to 6 do
12557: LD_ADDR_VAR 0 2
12561: PUSH
12562: DOUBLE
12563: LD_INT 1
12565: DEC
12566: ST_TO_ADDR
12567: LD_INT 6
12569: PUSH
12570: FOR_TO
12571: IFFALSE 12698
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
12573: LD_INT 14
12575: PPUSH
12576: LD_INT 1
12578: PPUSH
12579: LD_INT 3
12581: PPUSH
12582: CALL_OW 12
12586: PPUSH
12587: LD_INT 1
12589: PPUSH
12590: LD_INT 28
12592: PUSH
12593: LD_INT 26
12595: PUSH
12596: LD_INT 27
12598: PUSH
12599: LD_INT 25
12601: PUSH
12602: EMPTY
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: PUSH
12608: LD_VAR 0 2
12612: PUSH
12613: LD_INT 4
12615: MOD
12616: PUSH
12617: LD_INT 1
12619: PLUS
12620: ARRAY
12621: PPUSH
12622: LD_INT 80
12624: PPUSH
12625: CALL 66065 0 5
// veh := CreateVehicle ;
12629: LD_ADDR_VAR 0 3
12633: PUSH
12634: CALL_OW 45
12638: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
12639: LD_VAR 0 3
12643: PPUSH
12644: LD_INT 4
12646: PPUSH
12647: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
12651: LD_VAR 0 3
12655: PPUSH
12656: LD_INT 28
12658: PPUSH
12659: LD_INT 0
12661: PPUSH
12662: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
12666: LD_INT 0
12668: PPUSH
12669: LD_INT 7
12671: PUSH
12672: LD_OWVAR 67
12676: PLUS
12677: PPUSH
12678: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
12682: CALL_OW 44
12686: PPUSH
12687: LD_VAR 0 3
12691: PPUSH
12692: CALL_OW 52
// end ;
12696: GO 12570
12698: POP
12699: POP
// for i = 1 to 3 do
12700: LD_ADDR_VAR 0 2
12704: PUSH
12705: DOUBLE
12706: LD_INT 1
12708: DEC
12709: ST_TO_ADDR
12710: LD_INT 3
12712: PUSH
12713: FOR_TO
12714: IFFALSE 12774
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
12716: LD_INT 14
12718: PPUSH
12719: LD_INT 3
12721: PPUSH
12722: LD_INT 5
12724: PPUSH
12725: LD_INT 29
12727: PPUSH
12728: LD_INT 80
12730: PPUSH
12731: CALL 66065 0 5
// veh := CreateVehicle ;
12735: LD_ADDR_VAR 0 3
12739: PUSH
12740: CALL_OW 45
12744: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
12745: LD_VAR 0 3
12749: PPUSH
12750: LD_INT 4
12752: PPUSH
12753: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
12757: LD_VAR 0 3
12761: PPUSH
12762: LD_INT 28
12764: PPUSH
12765: LD_INT 0
12767: PPUSH
12768: CALL_OW 49
// end ;
12772: GO 12713
12774: POP
12775: POP
// end ;
12776: LD_VAR 0 1
12780: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
12781: LD_INT 22
12783: PUSH
12784: LD_INT 2
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PPUSH
12791: CALL_OW 69
12795: IFFALSE 13095
12797: GO 12799
12799: DISABLE
12800: LD_INT 0
12802: PPUSH
12803: PPUSH
12804: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
12805: LD_ADDR_VAR 0 3
12809: PUSH
12810: LD_INT 22
12812: PUSH
12813: LD_INT 2
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: PUSH
12820: LD_INT 25
12822: PUSH
12823: LD_INT 4
12825: PUSH
12826: EMPTY
12827: LIST
12828: LIST
12829: PUSH
12830: EMPTY
12831: LIST
12832: LIST
12833: PPUSH
12834: CALL_OW 69
12838: PUSH
12839: LD_EXP 91
12843: DIFF
12844: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
12845: LD_ADDR_VAR 0 2
12849: PUSH
12850: LD_INT 22
12852: PUSH
12853: LD_INT 2
12855: PUSH
12856: EMPTY
12857: LIST
12858: LIST
12859: PPUSH
12860: CALL_OW 69
12864: PUSH
12865: LD_EXP 91
12869: PUSH
12870: LD_VAR 0 3
12874: UNION
12875: DIFF
12876: ST_TO_ADDR
// if Khatam then
12877: LD_EXP 91
12881: IFFALSE 12898
// ComMoveXY ( Khatam , 211 , 92 ) ;
12883: LD_EXP 91
12887: PPUSH
12888: LD_INT 211
12890: PPUSH
12891: LD_INT 92
12893: PPUSH
12894: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
12898: LD_INT 197
12900: PPUSH
12901: LD_INT 80
12903: PPUSH
12904: LD_INT 2
12906: PPUSH
12907: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
12911: LD_INT 213
12913: PPUSH
12914: LD_INT 90
12916: PPUSH
12917: LD_INT 2
12919: PPUSH
12920: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
12924: LD_INT 215
12926: PPUSH
12927: LD_INT 129
12929: PPUSH
12930: LD_INT 2
12932: PPUSH
12933: CALL_OW 441
// if sci then
12937: LD_VAR 0 3
12941: IFFALSE 12962
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
12943: LD_VAR 0 3
12947: PUSH
12948: LD_INT 1
12950: ARRAY
12951: PPUSH
12952: LD_INT 197
12954: PPUSH
12955: LD_INT 80
12957: PPUSH
12958: CALL_OW 158
// if sci > 1 then
12962: LD_VAR 0 3
12966: PUSH
12967: LD_INT 1
12969: GREATER
12970: IFFALSE 12991
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
12972: LD_VAR 0 3
12976: PUSH
12977: LD_INT 2
12979: ARRAY
12980: PPUSH
12981: LD_INT 213
12983: PPUSH
12984: LD_INT 90
12986: PPUSH
12987: CALL_OW 158
// if sci > 2 then
12991: LD_VAR 0 3
12995: PUSH
12996: LD_INT 2
12998: GREATER
12999: IFFALSE 13020
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
13001: LD_VAR 0 3
13005: PUSH
13006: LD_INT 3
13008: ARRAY
13009: PPUSH
13010: LD_INT 215
13012: PPUSH
13013: LD_INT 129
13015: PPUSH
13016: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
13020: LD_INT 35
13022: PPUSH
13023: CALL_OW 67
// for i in tmp do
13027: LD_ADDR_VAR 0 1
13031: PUSH
13032: LD_VAR 0 2
13036: PUSH
13037: FOR_IN
13038: IFFALSE 13076
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
13040: LD_VAR 0 1
13044: PPUSH
13045: LD_INT 81
13047: PUSH
13048: LD_INT 2
13050: PUSH
13051: EMPTY
13052: LIST
13053: LIST
13054: PPUSH
13055: CALL_OW 69
13059: PPUSH
13060: LD_VAR 0 1
13064: PPUSH
13065: CALL_OW 74
13069: PPUSH
13070: CALL_OW 115
13074: GO 13037
13076: POP
13077: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
13078: LD_INT 22
13080: PUSH
13081: LD_INT 2
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PPUSH
13088: CALL_OW 69
13092: NOT
13093: IFFALSE 13020
// end ; end_of_file
13095: PPOPN 3
13097: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
13098: LD_INT 0
13100: PPUSH
13101: PPUSH
13102: PPUSH
13103: PPUSH
13104: PPUSH
13105: PPUSH
13106: PPUSH
13107: PPUSH
13108: PPUSH
// Video ( true ) ;
13109: LD_INT 1
13111: PPUSH
13112: CALL 101720 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
13116: LD_ADDR_VAR 0 5
13120: PUSH
13121: LD_INT 7
13123: PPUSH
13124: LD_INT 0
13126: PPUSH
13127: CALL_OW 517
13131: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
13132: LD_ADDR_VAR 0 2
13136: PUSH
13137: DOUBLE
13138: LD_INT 1
13140: DEC
13141: ST_TO_ADDR
13142: LD_VAR 0 5
13146: PUSH
13147: LD_INT 1
13149: ARRAY
13150: PUSH
13151: FOR_TO
13152: IFFALSE 13197
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
13154: LD_VAR 0 5
13158: PUSH
13159: LD_INT 1
13161: ARRAY
13162: PUSH
13163: LD_VAR 0 2
13167: ARRAY
13168: PPUSH
13169: LD_VAR 0 5
13173: PUSH
13174: LD_INT 2
13176: ARRAY
13177: PUSH
13178: LD_VAR 0 2
13182: ARRAY
13183: PPUSH
13184: LD_INT 1
13186: PPUSH
13187: LD_INT 15
13189: NEG
13190: PPUSH
13191: CALL 101634 0 4
13195: GO 13151
13197: POP
13198: POP
// CenterNowOnUnits ( Powell ) ;
13199: LD_EXP 55
13203: PPUSH
13204: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
13208: LD_ADDR_VAR 0 5
13212: PUSH
13213: LD_EXP 53
13217: PUSH
13218: EMPTY
13219: LIST
13220: ST_TO_ADDR
// if GirlNewVeh then
13221: LD_EXP 54
13225: IFFALSE 13243
// tmp := tmp ^ GirlNewVeh ;
13227: LD_ADDR_VAR 0 5
13231: PUSH
13232: LD_VAR 0 5
13236: PUSH
13237: LD_EXP 54
13241: ADD
13242: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
13243: LD_VAR 0 5
13247: PPUSH
13248: LD_INT 60
13250: PPUSH
13251: LD_INT 109
13253: PPUSH
13254: CALL_OW 111
// if KappaStatus then
13258: LD_EXP 2
13262: IFFALSE 13314
// begin Say ( JMM , D1T-JMM-1 ) ;
13264: LD_EXP 36
13268: PPUSH
13269: LD_STRING D1T-JMM-1
13271: PPUSH
13272: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
13276: LD_EXP 55
13280: PPUSH
13281: LD_STRING D1T-Pow-1
13283: PPUSH
13284: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
13288: LD_EXP 36
13292: PPUSH
13293: LD_STRING D1T-JMM-2
13295: PPUSH
13296: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
13300: LD_EXP 55
13304: PPUSH
13305: LD_STRING D1T-Pow-2
13307: PPUSH
13308: CALL_OW 88
// end else
13312: GO 13520
// if JMMGirlStatus then
13314: LD_EXP 6
13318: IFFALSE 13463
// begin Say ( JMM , D1T-JMM-1 ) ;
13320: LD_EXP 36
13324: PPUSH
13325: LD_STRING D1T-JMM-1
13327: PPUSH
13328: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
13332: LD_EXP 55
13336: PPUSH
13337: LD_STRING D1T-Pow-1
13339: PPUSH
13340: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
13344: LD_EXP 36
13348: PPUSH
13349: LD_STRING D1T-JMM-3
13351: PPUSH
13352: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
13356: LD_EXP 55
13360: PPUSH
13361: LD_STRING D1T-Pow-3
13363: PPUSH
13364: CALL_OW 88
// if JMMGirl then
13368: LD_EXP 7
13372: IFFALSE 13461
// begin case JMMGirl of 1 :
13374: LD_EXP 7
13378: PUSH
13379: LD_INT 1
13381: DOUBLE
13382: EQUAL
13383: IFTRUE 13387
13385: GO 13402
13387: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
13388: LD_EXP 37
13392: PPUSH
13393: LD_STRING D1T-Joan-3
13395: PPUSH
13396: CALL_OW 88
13400: GO 13449
13402: LD_INT 2
13404: DOUBLE
13405: EQUAL
13406: IFTRUE 13410
13408: GO 13425
13410: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
13411: LD_EXP 39
13415: PPUSH
13416: LD_STRING D1T-Lisa-3
13418: PPUSH
13419: CALL_OW 88
13423: GO 13449
13425: LD_INT 3
13427: DOUBLE
13428: EQUAL
13429: IFTRUE 13433
13431: GO 13448
13433: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
13434: LD_EXP 51
13438: PPUSH
13439: LD_STRING D1T-Con-3
13441: PPUSH
13442: CALL_OW 88
13446: GO 13449
13448: POP
// Say ( Powell , D1T-Pow-4 ) ;
13449: LD_EXP 55
13453: PPUSH
13454: LD_STRING D1T-Pow-4
13456: PPUSH
13457: CALL_OW 88
// end ; end else
13461: GO 13520
// if not FastEnd then
13463: LD_EXP 11
13467: NOT
13468: IFFALSE 13496
// begin Say ( JMM , D1T-JMM-4 ) ;
13470: LD_EXP 36
13474: PPUSH
13475: LD_STRING D1T-JMM-4
13477: PPUSH
13478: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
13482: LD_EXP 55
13486: PPUSH
13487: LD_STRING D1T-Pow-5
13489: PPUSH
13490: CALL_OW 88
// end else
13494: GO 13520
// begin Say ( JMM , D1nT-JMM-1 ) ;
13496: LD_EXP 36
13500: PPUSH
13501: LD_STRING D1nT-JMM-1
13503: PPUSH
13504: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
13508: LD_EXP 55
13512: PPUSH
13513: LD_STRING D1nT-Pow-1
13515: PPUSH
13516: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
13520: LD_INT 35
13522: PPUSH
13523: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
13527: LD_EXP 53
13531: PPUSH
13532: CALL_OW 314
13536: NOT
13537: IFFALSE 13520
// ComExitVehicle ( JMM ) ;
13539: LD_EXP 36
13543: PPUSH
13544: CALL_OW 121
// wait ( 3 ) ;
13548: LD_INT 3
13550: PPUSH
13551: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
13555: LD_EXP 36
13559: PPUSH
13560: LD_INT 60
13562: PPUSH
13563: LD_INT 94
13565: PPUSH
13566: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
13570: LD_EXP 36
13574: PPUSH
13575: LD_EXP 55
13579: PPUSH
13580: CALL_OW 179
// if Joan then
13584: LD_EXP 37
13588: IFFALSE 13642
// begin ComExitVehicle ( Joan ) ;
13590: LD_EXP 37
13594: PPUSH
13595: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
13599: LD_EXP 37
13603: PPUSH
13604: LD_INT 35
13606: PPUSH
13607: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
13611: LD_EXP 37
13615: PPUSH
13616: LD_INT 65
13618: PPUSH
13619: LD_INT 104
13621: PPUSH
13622: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
13626: LD_EXP 37
13630: PPUSH
13631: LD_EXP 36
13635: PPUSH
13636: CALL_OW 179
// end else
13640: GO 13776
// if Lisa and JMMGirl = 2 then
13642: LD_EXP 39
13646: PUSH
13647: LD_EXP 7
13651: PUSH
13652: LD_INT 2
13654: EQUAL
13655: AND
13656: IFFALSE 13710
// begin ComExitVehicle ( Lisa ) ;
13658: LD_EXP 39
13662: PPUSH
13663: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
13667: LD_EXP 39
13671: PPUSH
13672: LD_INT 35
13674: PPUSH
13675: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
13679: LD_EXP 39
13683: PPUSH
13684: LD_INT 65
13686: PPUSH
13687: LD_INT 104
13689: PPUSH
13690: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
13694: LD_EXP 39
13698: PPUSH
13699: LD_EXP 36
13703: PPUSH
13704: CALL_OW 179
// end else
13708: GO 13776
// if Connie and JMMGirl = 3 then
13710: LD_EXP 51
13714: PUSH
13715: LD_EXP 7
13719: PUSH
13720: LD_INT 3
13722: EQUAL
13723: AND
13724: IFFALSE 13776
// begin ComExitVehicle ( Connie ) ;
13726: LD_EXP 51
13730: PPUSH
13731: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
13735: LD_EXP 51
13739: PPUSH
13740: LD_INT 35
13742: PPUSH
13743: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
13747: LD_EXP 51
13751: PPUSH
13752: LD_INT 65
13754: PPUSH
13755: LD_INT 104
13757: PPUSH
13758: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
13762: LD_EXP 51
13766: PPUSH
13767: LD_EXP 36
13771: PPUSH
13772: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
13776: LD_INT 35
13778: PPUSH
13779: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
13783: LD_EXP 36
13787: PPUSH
13788: LD_EXP 55
13792: PPUSH
13793: CALL_OW 296
13797: PUSH
13798: LD_INT 6
13800: LESS
13801: IFFALSE 13776
// wait ( 0 0$0.5 ) ;
13803: LD_INT 18
13805: PPUSH
13806: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
13810: LD_EXP 36
13814: PPUSH
13815: LD_STRING D1-JMM-1
13817: PPUSH
13818: CALL_OW 88
// async ;
13822: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
13823: LD_EXP 55
13827: PPUSH
13828: LD_STRING D1-Pow-1
13830: PPUSH
13831: CALL_OW 88
// if not dialogue_skipped then
13835: LD_OWVAR 59
13839: NOT
13840: IFFALSE 13849
// wait ( 0 0$2 ) ;
13842: LD_INT 70
13844: PPUSH
13845: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
13849: LD_INT 170
13851: PPUSH
13852: LD_INT 99
13854: PPUSH
13855: LD_INT 1
13857: PPUSH
13858: LD_INT 6
13860: NEG
13861: PPUSH
13862: CALL 101634 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
13866: LD_INT 174
13868: PPUSH
13869: LD_INT 115
13871: PPUSH
13872: LD_INT 1
13874: PPUSH
13875: LD_INT 6
13877: NEG
13878: PPUSH
13879: CALL 101634 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
13883: LD_INT 169
13885: PPUSH
13886: LD_INT 71
13888: PPUSH
13889: LD_INT 1
13891: PPUSH
13892: LD_INT 6
13894: NEG
13895: PPUSH
13896: CALL 101634 0 4
// if not dialogue_skipped then
13900: LD_OWVAR 59
13904: NOT
13905: IFFALSE 13924
// begin CenterOnXY ( 170 , 99 ) ;
13907: LD_INT 170
13909: PPUSH
13910: LD_INT 99
13912: PPUSH
13913: CALL_OW 84
// wait ( 0 0$2.3 ) ;
13917: LD_INT 80
13919: PPUSH
13920: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
13924: LD_INT 75
13926: PPUSH
13927: LD_INT 53
13929: PPUSH
13930: LD_INT 1
13932: PPUSH
13933: LD_INT 9
13935: NEG
13936: PPUSH
13937: CALL 101634 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
13941: LD_INT 54
13943: PPUSH
13944: LD_INT 42
13946: PPUSH
13947: LD_INT 1
13949: PPUSH
13950: LD_INT 9
13952: NEG
13953: PPUSH
13954: CALL 101634 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
13958: LD_INT 62
13960: PPUSH
13961: LD_INT 51
13963: PPUSH
13964: LD_INT 1
13966: PPUSH
13967: LD_INT 9
13969: NEG
13970: PPUSH
13971: CALL 101634 0 4
// if not dialogue_skipped then
13975: LD_OWVAR 59
13979: NOT
13980: IFFALSE 13999
// begin CenterOnXY ( 75 , 53 ) ;
13982: LD_INT 75
13984: PPUSH
13985: LD_INT 53
13987: PPUSH
13988: CALL_OW 84
// wait ( 0 0$4 ) ;
13992: LD_INT 140
13994: PPUSH
13995: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
13999: LD_EXP 55
14003: PPUSH
14004: CALL_OW 87
// if not dialogue_skipped then
14008: LD_OWVAR 59
14012: NOT
14013: IFFALSE 14022
// wait ( 0 0$2 ) ;
14015: LD_INT 70
14017: PPUSH
14018: CALL_OW 67
// sync ;
14022: SYNC
// Say ( JMM , D1-JMM-2 ) ;
14023: LD_EXP 36
14027: PPUSH
14028: LD_STRING D1-JMM-2
14030: PPUSH
14031: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
14035: LD_EXP 55
14039: PPUSH
14040: LD_STRING D1-Pow-2
14042: PPUSH
14043: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
14047: LD_EXP 36
14051: PPUSH
14052: LD_STRING D1-JMM-3
14054: PPUSH
14055: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
14059: LD_EXP 55
14063: PPUSH
14064: LD_STRING D1-Pow-3
14066: PPUSH
14067: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
14071: LD_EXP 36
14075: PPUSH
14076: LD_STRING D1-JMM-4
14078: PPUSH
14079: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
14083: LD_EXP 55
14087: PPUSH
14088: LD_STRING D1-Pow-4
14090: PPUSH
14091: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
14095: LD_EXP 36
14099: PPUSH
14100: LD_STRING D1-JMM-5
14102: PPUSH
14103: CALL_OW 88
// async ;
14107: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
14108: LD_EXP 55
14112: PPUSH
14113: LD_STRING D1-Pow-5
14115: PPUSH
14116: CALL_OW 88
// if not dialogue_skipped then
14120: LD_OWVAR 59
14124: NOT
14125: IFFALSE 14134
// wait ( 0 0$3.6 ) ;
14127: LD_INT 126
14129: PPUSH
14130: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
14134: LD_INT 134
14136: PPUSH
14137: LD_INT 210
14139: PPUSH
14140: LD_INT 1
14142: PPUSH
14143: LD_INT 11
14145: NEG
14146: PPUSH
14147: CALL 101634 0 4
// if not dialogue_skipped then
14151: LD_OWVAR 59
14155: NOT
14156: IFFALSE 14175
// begin CenterOnXY ( 134 , 210 ) ;
14158: LD_INT 134
14160: PPUSH
14161: LD_INT 210
14163: PPUSH
14164: CALL_OW 84
// wait ( 0 0$2 ) ;
14168: LD_INT 70
14170: PPUSH
14171: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
14175: LD_INT 101
14177: PPUSH
14178: LD_INT 159
14180: PPUSH
14181: LD_INT 1
14183: PPUSH
14184: LD_INT 10
14186: NEG
14187: PPUSH
14188: CALL 101634 0 4
// if not dialogue_skipped then
14192: LD_OWVAR 59
14196: NOT
14197: IFFALSE 14216
// begin CenterOnXY ( 101 , 159 ) ;
14199: LD_INT 101
14201: PPUSH
14202: LD_INT 159
14204: PPUSH
14205: CALL_OW 84
// wait ( 0 0$2 ) ;
14209: LD_INT 70
14211: PPUSH
14212: CALL_OW 67
// end ; sync ;
14216: SYNC
// CenterNowOnUnits ( Powell ) ;
14217: LD_EXP 55
14221: PPUSH
14222: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
14226: LD_ADDR_VAR 0 6
14230: PUSH
14231: LD_INT 1
14233: PUSH
14234: LD_INT 2
14236: PUSH
14237: LD_INT 3
14239: PUSH
14240: LD_INT 4
14242: PUSH
14243: LD_INT 5
14245: PUSH
14246: LD_INT 6
14248: PUSH
14249: EMPTY
14250: LIST
14251: LIST
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: ST_TO_ADDR
// if not dialogue_skipped then
14257: LD_OWVAR 59
14261: NOT
14262: IFFALSE 14431
// begin game_speed := 4 ;
14264: LD_ADDR_OWVAR 65
14268: PUSH
14269: LD_INT 4
14271: ST_TO_ADDR
// wait ( 0 0$6 ) ;
14272: LD_INT 210
14274: PPUSH
14275: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
14279: LD_ADDR_VAR 0 7
14283: PUSH
14284: LD_STRING Q1
14286: PPUSH
14287: LD_VAR 0 6
14291: PPUSH
14292: CALL_OW 98
14296: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
14297: LD_ADDR_VAR 0 7
14301: PUSH
14302: LD_STRING Q1
14304: PPUSH
14305: LD_VAR 0 6
14309: PPUSH
14310: CALL_OW 98
14314: ST_TO_ADDR
// options = options diff dec ;
14315: LD_ADDR_VAR 0 6
14319: PUSH
14320: LD_VAR 0 6
14324: PUSH
14325: LD_VAR 0 7
14329: DIFF
14330: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
14331: LD_VAR 0 7
14335: PPUSH
14336: LD_VAR 0 6
14340: PPUSH
14341: CALL 15714 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
14345: LD_VAR 0 7
14349: PUSH
14350: LD_INT 5
14352: PUSH
14353: LD_INT 6
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: IN
14360: PUSH
14361: LD_VAR 0 6
14365: PUSH
14366: LD_INT 2
14368: EQUAL
14369: OR
14370: IFFALSE 14297
// if not ( dec in [ 5 , 6 ] ) then
14372: LD_VAR 0 7
14376: PUSH
14377: LD_INT 5
14379: PUSH
14380: LD_INT 6
14382: PUSH
14383: EMPTY
14384: LIST
14385: LIST
14386: IN
14387: NOT
14388: IFFALSE 14431
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
14390: LD_ADDR_VAR 0 7
14394: PUSH
14395: LD_STRING Q1a
14397: PPUSH
14398: LD_INT 1
14400: PUSH
14401: LD_INT 2
14403: PUSH
14404: EMPTY
14405: LIST
14406: LIST
14407: PPUSH
14408: CALL_OW 98
14412: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
14413: LD_VAR 0 7
14417: PUSH
14418: LD_INT 4
14420: PLUS
14421: PPUSH
14422: LD_VAR 0 6
14426: PPUSH
14427: CALL 15714 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
14431: LD_INT 81
14433: PPUSH
14434: LD_INT 127
14436: PPUSH
14437: CALL_OW 84
// amount := 5 ;
14441: LD_ADDR_VAR 0 8
14445: PUSH
14446: LD_INT 5
14448: ST_TO_ADDR
// macmilan_squad := [ ] ;
14449: LD_ADDR_VAR 0 9
14453: PUSH
14454: EMPTY
14455: ST_TO_ADDR
// if vip < amount then
14456: LD_EXP 56
14460: PUSH
14461: LD_VAR 0 8
14465: LESS
14466: IFFALSE 14510
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
14468: LD_ADDR_VAR 0 5
14472: PUSH
14473: LD_EXP 56
14477: PUSH
14478: LD_INT 22
14480: PUSH
14481: LD_INT 4
14483: PUSH
14484: EMPTY
14485: LIST
14486: LIST
14487: PUSH
14488: LD_INT 21
14490: PUSH
14491: LD_INT 1
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: PUSH
14498: EMPTY
14499: LIST
14500: LIST
14501: PPUSH
14502: CALL_OW 69
14506: UNION
14507: ST_TO_ADDR
14508: GO 14520
// tmp := vip ;
14510: LD_ADDR_VAR 0 5
14514: PUSH
14515: LD_EXP 56
14519: ST_TO_ADDR
// tmp := tmp diff Powell ;
14520: LD_ADDR_VAR 0 5
14524: PUSH
14525: LD_VAR 0 5
14529: PUSH
14530: LD_EXP 55
14534: DIFF
14535: ST_TO_ADDR
// if tmp < amount then
14536: LD_VAR 0 5
14540: PUSH
14541: LD_VAR 0 8
14545: LESS
14546: IFFALSE 14558
// amount := tmp ;
14548: LD_ADDR_VAR 0 8
14552: PUSH
14553: LD_VAR 0 5
14557: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
14558: LD_VAR 0 5
14562: PUSH
14563: LD_INT 1
14565: ARRAY
14566: PPUSH
14567: CALL_OW 257
14571: PUSH
14572: LD_INT 2
14574: NONEQUAL
14575: IFFALSE 14637
// begin if IsInUnit ( tmp [ 1 ] ) then
14577: LD_VAR 0 5
14581: PUSH
14582: LD_INT 1
14584: ARRAY
14585: PPUSH
14586: CALL_OW 310
14590: IFFALSE 14605
// ComExitBuilding ( tmp [ 1 ] ) ;
14592: LD_VAR 0 5
14596: PUSH
14597: LD_INT 1
14599: ARRAY
14600: PPUSH
14601: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
14605: LD_VAR 0 5
14609: PUSH
14610: LD_INT 1
14612: ARRAY
14613: PPUSH
14614: LD_INT 387
14616: PPUSH
14617: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
14621: LD_VAR 0 5
14625: PUSH
14626: LD_INT 1
14628: ARRAY
14629: PPUSH
14630: LD_INT 2
14632: PPUSH
14633: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
14637: LD_EXP 36
14641: PPUSH
14642: LD_INT 82
14644: PPUSH
14645: LD_INT 129
14647: PPUSH
14648: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
14652: LD_EXP 36
14656: PPUSH
14657: LD_EXP 55
14661: PPUSH
14662: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
14666: LD_INT 22
14668: PUSH
14669: LD_INT 1
14671: PUSH
14672: EMPTY
14673: LIST
14674: LIST
14675: PPUSH
14676: CALL_OW 69
14680: PUSH
14681: LD_EXP 36
14685: DIFF
14686: PPUSH
14687: LD_INT 84
14689: PPUSH
14690: LD_INT 128
14692: PPUSH
14693: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
14697: LD_INT 22
14699: PUSH
14700: LD_INT 1
14702: PUSH
14703: EMPTY
14704: LIST
14705: LIST
14706: PPUSH
14707: CALL_OW 69
14711: PUSH
14712: LD_EXP 36
14716: DIFF
14717: PPUSH
14718: LD_EXP 36
14722: PPUSH
14723: CALL_OW 179
// for i = 1 to amount do
14727: LD_ADDR_VAR 0 2
14731: PUSH
14732: DOUBLE
14733: LD_INT 1
14735: DEC
14736: ST_TO_ADDR
14737: LD_VAR 0 8
14741: PUSH
14742: FOR_TO
14743: IFFALSE 14911
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
14745: LD_ADDR_VAR 0 9
14749: PUSH
14750: LD_VAR 0 9
14754: PUSH
14755: LD_VAR 0 5
14759: PUSH
14760: LD_VAR 0 2
14764: ARRAY
14765: ADD
14766: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
14767: LD_VAR 0 5
14771: PUSH
14772: LD_VAR 0 2
14776: ARRAY
14777: PPUSH
14778: CALL_OW 310
14782: IFFALSE 14799
// AddComExitBuilding ( tmp [ i ] ) ;
14784: LD_VAR 0 5
14788: PUSH
14789: LD_VAR 0 2
14793: ARRAY
14794: PPUSH
14795: CALL_OW 182
// if i = 2 and JMMNewVeh then
14799: LD_VAR 0 2
14803: PUSH
14804: LD_INT 2
14806: EQUAL
14807: PUSH
14808: LD_EXP 53
14812: AND
14813: IFFALSE 14871
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
14815: LD_VAR 0 5
14819: PUSH
14820: LD_VAR 0 2
14824: ARRAY
14825: PPUSH
14826: LD_EXP 53
14830: PPUSH
14831: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
14835: LD_VAR 0 5
14839: PUSH
14840: LD_VAR 0 2
14844: ARRAY
14845: PPUSH
14846: LD_INT 86
14848: PPUSH
14849: LD_INT 133
14851: PPUSH
14852: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
14856: LD_VAR 0 5
14860: PUSH
14861: LD_VAR 0 2
14865: ARRAY
14866: PPUSH
14867: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
14871: LD_VAR 0 5
14875: PUSH
14876: LD_VAR 0 2
14880: ARRAY
14881: PPUSH
14882: LD_INT 8
14884: PPUSH
14885: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
14889: LD_VAR 0 5
14893: PUSH
14894: LD_VAR 0 2
14898: ARRAY
14899: PPUSH
14900: LD_EXP 36
14904: PPUSH
14905: CALL_OW 179
// end ;
14909: GO 14742
14911: POP
14912: POP
// if GirlNewVeh then
14913: LD_EXP 54
14917: IFFALSE 14931
// SetSide ( GirlNewVeh , 4 ) ;
14919: LD_EXP 54
14923: PPUSH
14924: LD_INT 4
14926: PPUSH
14927: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
14931: LD_INT 35
14933: PPUSH
14934: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
14938: LD_VAR 0 9
14942: PPUSH
14943: LD_INT 95
14945: PUSH
14946: LD_INT 9
14948: PUSH
14949: EMPTY
14950: LIST
14951: LIST
14952: PPUSH
14953: CALL_OW 72
14957: PUSH
14958: LD_INT 0
14960: EQUAL
14961: PUSH
14962: LD_EXP 36
14966: PPUSH
14967: LD_INT 9
14969: PPUSH
14970: CALL_OW 308
14974: NOT
14975: AND
14976: IFFALSE 14931
// wait ( 0 0$2 ) ;
14978: LD_INT 70
14980: PPUSH
14981: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
14985: LD_VAR 0 9
14989: PPUSH
14990: LD_INT 1
14992: PPUSH
14993: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
14997: LD_INT 21
14999: PUSH
15000: LD_INT 2
15002: PUSH
15003: EMPTY
15004: LIST
15005: LIST
15006: PUSH
15007: LD_INT 92
15009: PUSH
15010: LD_INT 83
15012: PUSH
15013: LD_INT 130
15015: PUSH
15016: LD_INT 10
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: PUSH
15025: EMPTY
15026: LIST
15027: LIST
15028: PPUSH
15029: CALL_OW 69
15033: PPUSH
15034: LD_INT 1
15036: PPUSH
15037: CALL_OW 235
// Video ( false ) ;
15041: LD_INT 0
15043: PPUSH
15044: CALL 101720 0 1
// ChangeMissionObjectives ( M1 ) ;
15048: LD_STRING M1
15050: PPUSH
15051: CALL_OW 337
// SaveForQuickRestart ;
15055: CALL_OW 22
// missionStart := true ;
15059: LD_ADDR_EXP 13
15063: PUSH
15064: LD_INT 1
15066: ST_TO_ADDR
// missionStage := 2 ;
15067: LD_ADDR_EXP 15
15071: PUSH
15072: LD_INT 2
15074: ST_TO_ADDR
// wait ( 0 0$3 ) ;
15075: LD_INT 105
15077: PPUSH
15078: CALL_OW 67
// tmp := tmp diff FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] ] ) ;
15082: LD_ADDR_VAR 0 5
15086: PUSH
15087: LD_VAR 0 5
15091: PUSH
15092: LD_INT 22
15094: PUSH
15095: LD_INT 1
15097: PUSH
15098: EMPTY
15099: LIST
15100: LIST
15101: PUSH
15102: LD_INT 21
15104: PUSH
15105: LD_INT 1
15107: PUSH
15108: EMPTY
15109: LIST
15110: LIST
15111: PUSH
15112: EMPTY
15113: LIST
15114: LIST
15115: PPUSH
15116: CALL_OW 69
15120: DIFF
15121: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
15122: LD_ADDR_EXP 99
15126: PUSH
15127: LD_EXP 99
15131: PPUSH
15132: LD_INT 4
15134: PPUSH
15135: LD_INT 22
15137: PUSH
15138: LD_INT 4
15140: PUSH
15141: EMPTY
15142: LIST
15143: LIST
15144: PUSH
15145: LD_INT 23
15147: PUSH
15148: LD_INT 1
15150: PUSH
15151: EMPTY
15152: LIST
15153: LIST
15154: PUSH
15155: LD_INT 3
15157: PUSH
15158: LD_INT 21
15160: PUSH
15161: LD_INT 2
15163: PUSH
15164: EMPTY
15165: LIST
15166: LIST
15167: PUSH
15168: EMPTY
15169: LIST
15170: LIST
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: LIST
15176: PPUSH
15177: CALL_OW 69
15181: PUSH
15182: LD_EXP 55
15186: DIFF
15187: PPUSH
15188: CALL_OW 1
15192: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
15193: LD_ADDR_VAR 0 4
15197: PUSH
15198: LD_INT 22
15200: PUSH
15201: LD_INT 4
15203: PUSH
15204: EMPTY
15205: LIST
15206: LIST
15207: PUSH
15208: LD_INT 34
15210: PUSH
15211: LD_INT 12
15213: PUSH
15214: EMPTY
15215: LIST
15216: LIST
15217: PUSH
15218: EMPTY
15219: LIST
15220: LIST
15221: PPUSH
15222: CALL_OW 69
15226: PUSH
15227: LD_INT 1
15229: ARRAY
15230: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
15231: LD_VAR 0 5
15235: PUSH
15236: LD_INT 1
15238: ARRAY
15239: PPUSH
15240: CALL_OW 310
15244: IFFALSE 15259
// ComExitBuilding ( tmp [ 1 ] ) ;
15246: LD_VAR 0 5
15250: PUSH
15251: LD_INT 1
15253: ARRAY
15254: PPUSH
15255: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
15259: LD_VAR 0 5
15263: PUSH
15264: LD_INT 1
15266: ARRAY
15267: PPUSH
15268: LD_VAR 0 4
15272: PPUSH
15273: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
15277: LD_VAR 0 5
15281: PUSH
15282: LD_INT 1
15284: ARRAY
15285: PPUSH
15286: LD_INT 80
15288: PPUSH
15289: LD_INT 136
15291: PPUSH
15292: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
15296: LD_VAR 0 5
15300: PUSH
15301: LD_INT 1
15303: ARRAY
15304: PPUSH
15305: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
15309: LD_VAR 0 5
15313: PUSH
15314: LD_INT 1
15316: ARRAY
15317: PPUSH
15318: LD_INT 59
15320: PPUSH
15321: LD_INT 112
15323: PPUSH
15324: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
15328: LD_VAR 0 5
15332: PUSH
15333: LD_INT 1
15335: ARRAY
15336: PPUSH
15337: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
15341: LD_EXP 39
15345: PUSH
15346: LD_EXP 56
15350: IN
15351: PUSH
15352: LD_EXP 39
15356: PPUSH
15357: CALL_OW 255
15361: PUSH
15362: LD_INT 1
15364: EQUAL
15365: AND
15366: IFFALSE 15382
// Say ( Lisa , D3nW-Lisa-1 ) else
15368: LD_EXP 39
15372: PPUSH
15373: LD_STRING D3nW-Lisa-1
15375: PPUSH
15376: CALL_OW 88
15380: GO 15626
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
15382: LD_EXP 42
15386: PUSH
15387: LD_EXP 56
15391: IN
15392: PUSH
15393: LD_EXP 42
15397: PPUSH
15398: CALL_OW 255
15402: PUSH
15403: LD_INT 1
15405: EQUAL
15406: AND
15407: IFFALSE 15423
// Say ( Cyrus , D3nW-Cyrus-1 ) else
15409: LD_EXP 42
15413: PPUSH
15414: LD_STRING D3nW-Cyrus-1
15416: PPUSH
15417: CALL_OW 88
15421: GO 15626
// if Bobby in vip and GetSide ( Bobby ) = 1 then
15423: LD_EXP 41
15427: PUSH
15428: LD_EXP 56
15432: IN
15433: PUSH
15434: LD_EXP 41
15438: PPUSH
15439: CALL_OW 255
15443: PUSH
15444: LD_INT 1
15446: EQUAL
15447: AND
15448: IFFALSE 15464
// Say ( Bobby , D3nW-Bobby-1 ) else
15450: LD_EXP 41
15454: PPUSH
15455: LD_STRING D3nW-Bobby-1
15457: PPUSH
15458: CALL_OW 88
15462: GO 15626
// if Gary in vip and GetSide ( Gary ) = 1 then
15464: LD_EXP 48
15468: PUSH
15469: LD_EXP 56
15473: IN
15474: PUSH
15475: LD_EXP 48
15479: PPUSH
15480: CALL_OW 255
15484: PUSH
15485: LD_INT 1
15487: EQUAL
15488: AND
15489: IFFALSE 15505
// Say ( Gary , D3nW-Gary-1 ) else
15491: LD_EXP 48
15495: PPUSH
15496: LD_STRING D3nW-Gary-1
15498: PPUSH
15499: CALL_OW 88
15503: GO 15626
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
15505: LD_EXP 40
15509: PUSH
15510: LD_EXP 56
15514: IN
15515: PUSH
15516: LD_EXP 40
15520: PPUSH
15521: CALL_OW 255
15525: PUSH
15526: LD_INT 1
15528: EQUAL
15529: AND
15530: IFFALSE 15546
// Say ( Donaldson , D3nW-Don-1 ) else
15532: LD_EXP 40
15536: PPUSH
15537: LD_STRING D3nW-Don-1
15539: PPUSH
15540: CALL_OW 88
15544: GO 15626
// if Cornel in vip and GetSide ( Cornel ) = 1 then
15546: LD_EXP 47
15550: PUSH
15551: LD_EXP 56
15555: IN
15556: PUSH
15557: LD_EXP 47
15561: PPUSH
15562: CALL_OW 255
15566: PUSH
15567: LD_INT 1
15569: EQUAL
15570: AND
15571: IFFALSE 15587
// Say ( Cornel , D3nW-Corn-1 ) else
15573: LD_EXP 47
15577: PPUSH
15578: LD_STRING D3nW-Corn-1
15580: PPUSH
15581: CALL_OW 88
15585: GO 15626
// if Frank in vip and GetSide ( Frank ) = 1 then
15587: LD_EXP 49
15591: PUSH
15592: LD_EXP 56
15596: IN
15597: PUSH
15598: LD_EXP 49
15602: PPUSH
15603: CALL_OW 255
15607: PUSH
15608: LD_INT 1
15610: EQUAL
15611: AND
15612: IFFALSE 15626
// Say ( Frank , D3nW-Frank-1 ) ;
15614: LD_EXP 49
15618: PPUSH
15619: LD_STRING D3nW-Frank-1
15621: PPUSH
15622: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
15626: LD_EXP 36
15630: PPUSH
15631: LD_STRING D3nW-JMM-1
15633: PPUSH
15634: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
15638: LD_EXP 36
15642: PPUSH
15643: LD_STRING D3nW-JMM-1a
15645: PPUSH
15646: CALL_OW 88
// t := 0 0$00 ;
15650: LD_ADDR_VAR 0 3
15654: PUSH
15655: LD_INT 0
15657: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15658: LD_INT 35
15660: PPUSH
15661: CALL_OW 67
// t := t + 0 0$1 ;
15665: LD_ADDR_VAR 0 3
15669: PUSH
15670: LD_VAR 0 3
15674: PUSH
15675: LD_INT 35
15677: PLUS
15678: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
15679: LD_INT 59
15681: PPUSH
15682: LD_INT 112
15684: PPUSH
15685: CALL_OW 428
15689: PUSH
15690: LD_VAR 0 3
15694: PUSH
15695: LD_INT 2100
15697: GREATER
15698: OR
15699: IFFALSE 15658
// activeAttacks := true ;
15701: LD_ADDR_EXP 16
15705: PUSH
15706: LD_INT 1
15708: ST_TO_ADDR
// end ;
15709: LD_VAR 0 1
15713: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
15714: LD_INT 0
15716: PPUSH
// case question of 1 :
15717: LD_VAR 0 1
15721: PUSH
15722: LD_INT 1
15724: DOUBLE
15725: EQUAL
15726: IFTRUE 15730
15728: GO 15781
15730: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
15731: LD_EXP 36
15735: PPUSH
15736: LD_STRING D2Mot-JMM-1
15738: PPUSH
15739: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
15743: LD_EXP 55
15747: PPUSH
15748: LD_STRING D2Mot-Pow-1
15750: PPUSH
15751: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
15755: LD_EXP 36
15759: PPUSH
15760: LD_STRING D2Mot-JMM-2
15762: PPUSH
15763: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
15767: LD_EXP 55
15771: PPUSH
15772: LD_STRING D2Mot-Pow-2
15774: PPUSH
15775: CALL_OW 88
// end ; 2 :
15779: GO 16124
15781: LD_INT 2
15783: DOUBLE
15784: EQUAL
15785: IFTRUE 15789
15787: GO 15865
15789: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
15790: LD_EXP 36
15794: PPUSH
15795: LD_STRING D2Rus-JMM-1
15797: PPUSH
15798: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
15802: LD_EXP 55
15806: PPUSH
15807: LD_STRING D2Rus-Pow-1
15809: PPUSH
15810: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
15814: LD_EXP 36
15818: PPUSH
15819: LD_STRING D2Rus-JMM-2
15821: PPUSH
15822: CALL_OW 88
// if not ( 3 in list_of_q ) then
15826: LD_INT 3
15828: PUSH
15829: LD_VAR 0 2
15833: IN
15834: NOT
15835: IFFALSE 15851
// Say ( Powell , D2Rus-Pow-2 ) else
15837: LD_EXP 55
15841: PPUSH
15842: LD_STRING D2Rus-Pow-2
15844: PPUSH
15845: CALL_OW 88
15849: GO 15863
// Say ( Powell , D2Rus-Pow-2a ) ;
15851: LD_EXP 55
15855: PPUSH
15856: LD_STRING D2Rus-Pow-2a
15858: PPUSH
15859: CALL_OW 88
// end ; 3 :
15863: GO 16124
15865: LD_INT 3
15867: DOUBLE
15868: EQUAL
15869: IFTRUE 15873
15871: GO 15958
15873: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
15874: LD_EXP 36
15878: PPUSH
15879: LD_STRING D2Leg-JMM-1
15881: PPUSH
15882: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
15886: LD_EXP 55
15890: PPUSH
15891: LD_STRING D2Leg-Pow-1
15893: PPUSH
15894: CALL_OW 88
// if 2 in list_of_q then
15898: LD_INT 2
15900: PUSH
15901: LD_VAR 0 2
15905: IN
15906: IFFALSE 15932
// begin Say ( JMM , D2Leg-JMM-2 ) ;
15908: LD_EXP 36
15912: PPUSH
15913: LD_STRING D2Leg-JMM-2
15915: PPUSH
15916: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
15920: LD_EXP 55
15924: PPUSH
15925: LD_STRING D2Leg-Pow-2
15927: PPUSH
15928: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
15932: LD_EXP 36
15936: PPUSH
15937: LD_STRING D2Leg-JMM-3
15939: PPUSH
15940: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
15944: LD_EXP 55
15948: PPUSH
15949: LD_STRING D2Leg-Pow-3
15951: PPUSH
15952: CALL_OW 88
// end ; 4 :
15956: GO 16124
15958: LD_INT 4
15960: DOUBLE
15961: EQUAL
15962: IFTRUE 15966
15964: GO 16041
15966: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
15967: LD_EXP 36
15971: PPUSH
15972: LD_STRING D2Ar-JMM-1
15974: PPUSH
15975: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
15979: LD_EXP 55
15983: PPUSH
15984: LD_STRING D2Ar-Pow-1
15986: PPUSH
15987: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
15991: LD_EXP 36
15995: PPUSH
15996: LD_STRING D2Ar-JMM-2
15998: PPUSH
15999: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
16003: LD_EXP 55
16007: PPUSH
16008: LD_STRING D2Ar-Pow-2
16010: PPUSH
16011: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
16015: LD_EXP 36
16019: PPUSH
16020: LD_STRING D2Ar-JMM-3
16022: PPUSH
16023: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
16027: LD_EXP 55
16031: PPUSH
16032: LD_STRING D2Ar-Pow-3
16034: PPUSH
16035: CALL_OW 88
// end ; 5 :
16039: GO 16124
16041: LD_INT 5
16043: DOUBLE
16044: EQUAL
16045: IFTRUE 16049
16047: GO 16064
16049: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
16050: LD_EXP 36
16054: PPUSH
16055: LD_STRING D2Conf-JMM-1
16057: PPUSH
16058: CALL_OW 88
16062: GO 16124
16064: LD_INT 6
16066: DOUBLE
16067: EQUAL
16068: IFTRUE 16072
16070: GO 16123
16072: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
16073: LD_EXP 36
16077: PPUSH
16078: LD_STRING D2Com-JMM-1
16080: PPUSH
16081: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
16085: LD_EXP 55
16089: PPUSH
16090: LD_STRING D2Com-Pow-1
16092: PPUSH
16093: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
16097: LD_EXP 36
16101: PPUSH
16102: LD_STRING D2Com-JMM-2
16104: PPUSH
16105: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
16109: LD_EXP 55
16113: PPUSH
16114: LD_STRING D2Com-Pow-2
16116: PPUSH
16117: CALL_OW 88
// end ; end ;
16121: GO 16124
16123: POP
// end ;
16124: LD_VAR 0 3
16128: RET
// every 0 0$5 trigger missionStart do var tmp ;
16129: LD_EXP 13
16133: IFFALSE 16416
16135: GO 16137
16137: DISABLE
16138: LD_INT 0
16140: PPUSH
// begin repeat wait ( 0 0$1 ) ;
16141: LD_INT 35
16143: PPUSH
16144: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
16148: LD_INT 14
16150: PPUSH
16151: LD_INT 22
16153: PUSH
16154: LD_INT 1
16156: PUSH
16157: EMPTY
16158: LIST
16159: LIST
16160: PPUSH
16161: CALL_OW 70
16165: PUSH
16166: LD_EXP 15
16170: PUSH
16171: LD_INT 2
16173: PUSH
16174: LD_INT 3
16176: PUSH
16177: LD_INT 4
16179: PUSH
16180: LD_INT 5
16182: PUSH
16183: EMPTY
16184: LIST
16185: LIST
16186: LIST
16187: LIST
16188: IN
16189: AND
16190: IFFALSE 16406
// begin powellAnger := powellAnger + 1 ;
16192: LD_ADDR_EXP 17
16196: PUSH
16197: LD_EXP 17
16201: PUSH
16202: LD_INT 1
16204: PLUS
16205: ST_TO_ADDR
// Video ( true ) ;
16206: LD_INT 1
16208: PPUSH
16209: CALL 101720 0 1
// CenterNowOnUnits ( tmp ) ;
16213: LD_VAR 0 1
16217: PPUSH
16218: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
16222: LD_INT 14
16224: PPUSH
16225: LD_INT 22
16227: PUSH
16228: LD_INT 1
16230: PUSH
16231: EMPTY
16232: LIST
16233: LIST
16234: PPUSH
16235: CALL_OW 70
16239: PPUSH
16240: LD_INT 86
16242: PPUSH
16243: LD_INT 133
16245: PPUSH
16246: CALL_OW 111
// async ;
16250: ASYNC
// case powellAnger of 1 :
16251: LD_EXP 17
16255: PUSH
16256: LD_INT 1
16258: DOUBLE
16259: EQUAL
16260: IFTRUE 16264
16262: GO 16279
16264: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
16265: LD_EXP 55
16269: PPUSH
16270: LD_STRING DBack1-Pow-1
16272: PPUSH
16273: CALL_OW 88
16277: GO 16326
16279: LD_INT 2
16281: DOUBLE
16282: EQUAL
16283: IFTRUE 16287
16285: GO 16302
16287: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
16288: LD_EXP 55
16292: PPUSH
16293: LD_STRING DBack2-Pow-1
16295: PPUSH
16296: CALL_OW 88
16300: GO 16326
16302: LD_INT 3
16304: DOUBLE
16305: EQUAL
16306: IFTRUE 16310
16308: GO 16325
16310: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
16311: LD_EXP 55
16315: PPUSH
16316: LD_STRING DBack3-Pow-1
16318: PPUSH
16319: CALL_OW 88
16323: GO 16326
16325: POP
// sync ;
16326: SYNC
// repeat wait ( 0 0$1 ) ;
16327: LD_INT 35
16329: PPUSH
16330: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
16334: LD_INT 14
16336: PPUSH
16337: LD_INT 22
16339: PUSH
16340: LD_INT 1
16342: PUSH
16343: EMPTY
16344: LIST
16345: LIST
16346: PPUSH
16347: CALL_OW 70
16351: PPUSH
16352: LD_INT 86
16354: PPUSH
16355: LD_INT 133
16357: PPUSH
16358: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
16362: LD_INT 14
16364: PPUSH
16365: LD_INT 22
16367: PUSH
16368: LD_INT 1
16370: PUSH
16371: EMPTY
16372: LIST
16373: LIST
16374: PPUSH
16375: CALL_OW 70
16379: NOT
16380: IFFALSE 16327
// if powellAnger >= 3 then
16382: LD_EXP 17
16386: PUSH
16387: LD_INT 3
16389: GREATEREQUAL
16390: IFFALSE 16399
// YouLost ( Dismissed ) ;
16392: LD_STRING Dismissed
16394: PPUSH
16395: CALL_OW 104
// Video ( false ) ;
16399: LD_INT 0
16401: PPUSH
16402: CALL 101720 0 1
// end ; until missionStage > 5 ;
16406: LD_EXP 15
16410: PUSH
16411: LD_INT 5
16413: GREATER
16414: IFFALSE 16141
// end ;
16416: PPOPN 1
16418: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , ru , un ;
16419: LD_EXP 13
16423: PUSH
16424: LD_INT 22
16426: PUSH
16427: LD_INT 4
16429: PUSH
16430: EMPTY
16431: LIST
16432: LIST
16433: PUSH
16434: LD_INT 21
16436: PUSH
16437: LD_INT 2
16439: PUSH
16440: EMPTY
16441: LIST
16442: LIST
16443: PUSH
16444: EMPTY
16445: LIST
16446: LIST
16447: PPUSH
16448: CALL_OW 69
16452: PUSH
16453: LD_INT 4
16455: GREATEREQUAL
16456: AND
16457: PUSH
16458: LD_EXP 15
16462: PUSH
16463: LD_INT 2
16465: EQUAL
16466: AND
16467: IFFALSE 18025
16469: GO 16471
16471: DISABLE
16472: LD_INT 0
16474: PPUSH
16475: PPUSH
16476: PPUSH
16477: PPUSH
16478: PPUSH
16479: PPUSH
16480: PPUSH
// begin missionStage := 3 ;
16481: LD_ADDR_EXP 15
16485: PUSH
16486: LD_INT 3
16488: ST_TO_ADDR
// retreat := false ;
16489: LD_ADDR_VAR 0 4
16493: PUSH
16494: LD_INT 0
16496: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
16497: LD_ADDR_VAR 0 5
16501: PUSH
16502: LD_INT 22
16504: PUSH
16505: LD_INT 4
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 30
16514: PUSH
16515: LD_INT 4
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PPUSH
16526: CALL_OW 69
16530: PUSH
16531: LD_INT 1
16533: ARRAY
16534: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
16535: LD_INT 35
16537: PPUSH
16538: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
16542: LD_EXP 118
16546: PUSH
16547: LD_INT 4
16549: ARRAY
16550: PUSH
16551: LD_INT 4
16553: GREATEREQUAL
16554: IFFALSE 16535
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
16556: LD_ADDR_VAR 0 2
16560: PUSH
16561: LD_INT 22
16563: PUSH
16564: LD_INT 4
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 25
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 25
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 25
16596: PUSH
16597: LD_INT 3
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: LD_INT 25
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: LD_INT 25
16616: PUSH
16617: LD_INT 5
16619: PUSH
16620: EMPTY
16621: LIST
16622: LIST
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: LIST
16628: LIST
16629: LIST
16630: LIST
16631: PUSH
16632: EMPTY
16633: LIST
16634: LIST
16635: PPUSH
16636: CALL_OW 69
16640: PUSH
16641: LD_EXP 55
16645: PUSH
16646: LD_EXP 56
16650: ADD
16651: DIFF
16652: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
16653: LD_ADDR_VAR 0 3
16657: PUSH
16658: LD_VAR 0 2
16662: PPUSH
16663: LD_INT 26
16665: PUSH
16666: LD_INT 1
16668: PUSH
16669: EMPTY
16670: LIST
16671: LIST
16672: PPUSH
16673: CALL_OW 72
16677: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
16678: LD_ADDR_VAR 0 2
16682: PUSH
16683: LD_VAR 0 2
16687: PUSH
16688: LD_VAR 0 3
16692: DIFF
16693: ST_TO_ADDR
// for i = 1 to 4 do
16694: LD_ADDR_VAR 0 1
16698: PUSH
16699: DOUBLE
16700: LD_INT 1
16702: DEC
16703: ST_TO_ADDR
16704: LD_INT 4
16706: PUSH
16707: FOR_TO
16708: IFFALSE 16874
// begin if tmp2 then
16710: LD_VAR 0 3
16714: IFFALSE 16795
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
16716: LD_ADDR_EXP 18
16720: PUSH
16721: LD_EXP 18
16725: PPUSH
16726: LD_INT 1
16728: PPUSH
16729: LD_EXP 18
16733: PUSH
16734: LD_INT 1
16736: ARRAY
16737: PUSH
16738: LD_VAR 0 3
16742: PUSH
16743: LD_VAR 0 3
16747: ARRAY
16748: ADD
16749: PPUSH
16750: CALL_OW 1
16754: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
16755: LD_VAR 0 3
16759: PUSH
16760: LD_VAR 0 3
16764: ARRAY
16765: PPUSH
16766: LD_INT 1
16768: PPUSH
16769: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
16773: LD_ADDR_VAR 0 3
16777: PUSH
16778: LD_VAR 0 3
16782: PPUSH
16783: LD_VAR 0 3
16787: PPUSH
16788: CALL_OW 3
16792: ST_TO_ADDR
// end else
16793: GO 16872
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
16795: LD_ADDR_EXP 18
16799: PUSH
16800: LD_EXP 18
16804: PPUSH
16805: LD_INT 1
16807: PPUSH
16808: LD_EXP 18
16812: PUSH
16813: LD_INT 1
16815: ARRAY
16816: PUSH
16817: LD_VAR 0 2
16821: PUSH
16822: LD_VAR 0 2
16826: ARRAY
16827: ADD
16828: PPUSH
16829: CALL_OW 1
16833: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
16834: LD_VAR 0 2
16838: PUSH
16839: LD_VAR 0 2
16843: ARRAY
16844: PPUSH
16845: LD_INT 1
16847: PPUSH
16848: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
16852: LD_ADDR_VAR 0 2
16856: PUSH
16857: LD_VAR 0 2
16861: PPUSH
16862: LD_VAR 0 2
16866: PPUSH
16867: CALL_OW 3
16871: ST_TO_ADDR
// end ; end ;
16872: GO 16707
16874: POP
16875: POP
// if tmp2 then
16876: LD_VAR 0 3
16880: IFFALSE 16898
// tmp := tmp union tmp2 ;
16882: LD_ADDR_VAR 0 2
16886: PUSH
16887: LD_VAR 0 2
16891: PUSH
16892: LD_VAR 0 3
16896: UNION
16897: ST_TO_ADDR
// for i = 1 to 4 do
16898: LD_ADDR_VAR 0 1
16902: PUSH
16903: DOUBLE
16904: LD_INT 1
16906: DEC
16907: ST_TO_ADDR
16908: LD_INT 4
16910: PUSH
16911: FOR_TO
16912: IFFALSE 16961
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
16914: LD_ADDR_EXP 18
16918: PUSH
16919: LD_EXP 18
16923: PPUSH
16924: LD_INT 2
16926: PPUSH
16927: LD_EXP 18
16931: PUSH
16932: LD_INT 2
16934: ARRAY
16935: PUSH
16936: LD_VAR 0 2
16940: PUSH
16941: LD_VAR 0 2
16945: PUSH
16946: LD_VAR 0 1
16950: MINUS
16951: ARRAY
16952: ADD
16953: PPUSH
16954: CALL_OW 1
16958: ST_TO_ADDR
16959: GO 16911
16961: POP
16962: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
16963: LD_ADDR_EXP 99
16967: PUSH
16968: LD_EXP 99
16972: PPUSH
16973: LD_INT 4
16975: PPUSH
16976: LD_EXP 99
16980: PUSH
16981: LD_INT 4
16983: ARRAY
16984: PUSH
16985: LD_EXP 18
16989: PUSH
16990: LD_INT 1
16992: ARRAY
16993: DIFF
16994: PPUSH
16995: CALL_OW 1
16999: ST_TO_ADDR
// for i in powellSquadAttack [ 1 ] do
17000: LD_ADDR_VAR 0 1
17004: PUSH
17005: LD_EXP 18
17009: PUSH
17010: LD_INT 1
17012: ARRAY
17013: PUSH
17014: FOR_IN
17015: IFFALSE 17118
// begin if IsInUnit ( i ) then
17017: LD_VAR 0 1
17021: PPUSH
17022: CALL_OW 310
17026: IFFALSE 17037
// ComExitBuilding ( i ) ;
17028: LD_VAR 0 1
17032: PPUSH
17033: CALL_OW 122
// if GetClass ( i ) <> 1 then
17037: LD_VAR 0 1
17041: PPUSH
17042: CALL_OW 257
17046: PUSH
17047: LD_INT 1
17049: NONEQUAL
17050: IFFALSE 17087
// begin AddComEnterUnit ( i , arm ) ;
17052: LD_VAR 0 1
17056: PPUSH
17057: LD_VAR 0 5
17061: PPUSH
17062: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
17066: LD_VAR 0 1
17070: PPUSH
17071: LD_INT 1
17073: PPUSH
17074: CALL_OW 183
// AddComExitBuilding ( i ) ;
17078: LD_VAR 0 1
17082: PPUSH
17083: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
17087: LD_VAR 0 1
17091: PPUSH
17092: LD_INT 60
17094: PPUSH
17095: LD_INT 94
17097: PPUSH
17098: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
17102: LD_VAR 0 1
17106: PPUSH
17107: LD_EXP 55
17111: PPUSH
17112: CALL_OW 179
// end ;
17116: GO 17014
17118: POP
17119: POP
// wait ( 0 0$15 ) ;
17120: LD_INT 525
17122: PPUSH
17123: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
17127: LD_EXP 55
17131: PPUSH
17132: LD_STRING D4-Pow-1
17134: PPUSH
17135: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
17139: LD_ADDR_VAR 0 2
17143: PUSH
17144: LD_EXP 18
17148: PUSH
17149: LD_INT 1
17151: ARRAY
17152: PPUSH
17153: LD_INT 26
17155: PUSH
17156: LD_INT 1
17158: PUSH
17159: EMPTY
17160: LIST
17161: LIST
17162: PPUSH
17163: CALL_OW 72
17167: ST_TO_ADDR
// if tmp then
17168: LD_VAR 0 2
17172: IFFALSE 17190
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
17174: LD_VAR 0 2
17178: PUSH
17179: LD_INT 1
17181: ARRAY
17182: PPUSH
17183: LD_STRING D4-Sol1-1
17185: PPUSH
17186: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
17190: LD_EXP 55
17194: PPUSH
17195: LD_STRING D4-Pow-2
17197: PPUSH
17198: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
17202: LD_ADDR_VAR 0 1
17206: PUSH
17207: DOUBLE
17208: LD_INT 1
17210: DEC
17211: ST_TO_ADDR
17212: LD_EXP 18
17216: PUSH
17217: LD_INT 1
17219: ARRAY
17220: PUSH
17221: FOR_TO
17222: IFFALSE 17315
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
17224: LD_EXP 18
17228: PUSH
17229: LD_INT 1
17231: ARRAY
17232: PUSH
17233: LD_VAR 0 1
17237: ARRAY
17238: PPUSH
17239: LD_EXP 118
17243: PUSH
17244: LD_INT 4
17246: ARRAY
17247: PUSH
17248: LD_INT 1
17250: ARRAY
17251: PPUSH
17252: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
17256: LD_ADDR_EXP 118
17260: PUSH
17261: LD_EXP 118
17265: PPUSH
17266: LD_INT 4
17268: PPUSH
17269: LD_EXP 118
17273: PUSH
17274: LD_INT 4
17276: ARRAY
17277: PPUSH
17278: LD_INT 1
17280: PPUSH
17281: CALL_OW 3
17285: PPUSH
17286: CALL_OW 1
17290: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
17291: LD_INT 8
17293: PPUSH
17294: LD_EXP 18
17298: PUSH
17299: LD_INT 1
17301: ARRAY
17302: PUSH
17303: LD_VAR 0 1
17307: ARRAY
17308: PPUSH
17309: CALL_OW 471
// end ;
17313: GO 17221
17315: POP
17316: POP
// repeat wait ( 0 0$1 ) ;
17317: LD_INT 35
17319: PPUSH
17320: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
17324: LD_EXP 18
17328: PUSH
17329: LD_INT 1
17331: ARRAY
17332: PPUSH
17333: LD_INT 55
17335: PUSH
17336: EMPTY
17337: LIST
17338: PPUSH
17339: CALL_OW 72
17343: PUSH
17344: LD_INT 4
17346: GREATEREQUAL
17347: IFFALSE 17317
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
17349: LD_EXP 18
17353: PUSH
17354: LD_INT 1
17356: ARRAY
17357: PPUSH
17358: LD_INT 69
17360: PPUSH
17361: LD_INT 94
17363: PPUSH
17364: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
17368: LD_EXP 18
17372: PUSH
17373: LD_INT 1
17375: ARRAY
17376: PPUSH
17377: LD_INT 82
17379: PPUSH
17380: LD_INT 83
17382: PPUSH
17383: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
17387: LD_EXP 18
17391: PUSH
17392: LD_INT 1
17394: ARRAY
17395: PPUSH
17396: LD_INT 77
17398: PPUSH
17399: LD_INT 69
17401: PPUSH
17402: CALL_OW 174
// repeat wait ( 3 ) ;
17406: LD_INT 3
17408: PPUSH
17409: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
17413: LD_ADDR_VAR 0 1
17417: PUSH
17418: LD_EXP 18
17422: PUSH
17423: LD_INT 1
17425: ARRAY
17426: PUSH
17427: FOR_IN
17428: IFFALSE 17537
// begin if GetLives ( i ) < 990 then
17430: LD_VAR 0 1
17434: PPUSH
17435: CALL_OW 256
17439: PUSH
17440: LD_INT 990
17442: LESS
17443: IFFALSE 17457
// SetLives ( i , 1000 ) ;
17445: LD_VAR 0 1
17449: PPUSH
17450: LD_INT 1000
17452: PPUSH
17453: CALL_OW 234
// if not IsInUnit ( i ) then
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 310
17466: NOT
17467: IFFALSE 17535
// begin if not retreat and GetSex ( i ) = sex_male then
17469: LD_VAR 0 4
17473: NOT
17474: PUSH
17475: LD_VAR 0 1
17479: PPUSH
17480: CALL_OW 258
17484: PUSH
17485: LD_INT 1
17487: EQUAL
17488: AND
17489: IFFALSE 17535
// begin retreat := true ;
17491: LD_ADDR_VAR 0 4
17495: PUSH
17496: LD_INT 1
17498: ST_TO_ADDR
// SetTag ( i , 2 ) ;
17499: LD_VAR 0 1
17503: PPUSH
17504: LD_INT 2
17506: PPUSH
17507: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
17511: LD_VAR 0 1
17515: PPUSH
17516: LD_STRING D4a-Sol1-1
17518: PPUSH
17519: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
17523: LD_EXP 55
17527: PPUSH
17528: LD_STRING D4a-Pow-1
17530: PPUSH
17531: CALL_OW 88
// end ; end ; end ;
17535: GO 17427
17537: POP
17538: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
17539: LD_EXP 18
17543: PUSH
17544: LD_INT 1
17546: ARRAY
17547: PPUSH
17548: LD_INT 95
17550: PUSH
17551: LD_INT 9
17553: PUSH
17554: EMPTY
17555: LIST
17556: LIST
17557: PUSH
17558: LD_INT 3
17560: PUSH
17561: LD_INT 55
17563: PUSH
17564: EMPTY
17565: LIST
17566: PUSH
17567: EMPTY
17568: LIST
17569: LIST
17570: PUSH
17571: EMPTY
17572: LIST
17573: LIST
17574: PPUSH
17575: CALL_OW 72
17579: PUSH
17580: LD_INT 4
17582: GREATEREQUAL
17583: IFFALSE 17406
// for i in powellSquadAttack [ 1 ] do
17585: LD_ADDR_VAR 0 1
17589: PUSH
17590: LD_EXP 18
17594: PUSH
17595: LD_INT 1
17597: ARRAY
17598: PUSH
17599: FOR_IN
17600: IFFALSE 17736
// begin if GetTag ( i ) = 2 then
17602: LD_VAR 0 1
17606: PPUSH
17607: CALL_OW 110
17611: PUSH
17612: LD_INT 2
17614: EQUAL
17615: IFFALSE 17677
// begin ComMoveXY ( i , 60 , 94 ) ;
17617: LD_VAR 0 1
17621: PPUSH
17622: LD_INT 60
17624: PPUSH
17625: LD_INT 94
17627: PPUSH
17628: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
17632: LD_VAR 0 1
17636: PPUSH
17637: LD_EXP 55
17641: PPUSH
17642: CALL_OW 179
// wait ( 0 0$3 ) ;
17646: LD_INT 105
17648: PPUSH
17649: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
17653: LD_VAR 0 1
17657: PPUSH
17658: LD_STRING D4a-Sol1-2
17660: PPUSH
17661: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
17665: LD_EXP 55
17669: PPUSH
17670: LD_STRING D4a-Pow-2
17672: PPUSH
17673: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
17677: LD_VAR 0 1
17681: PPUSH
17682: LD_INT 0
17684: PPUSH
17685: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
17689: LD_ADDR_EXP 99
17693: PUSH
17694: LD_EXP 99
17698: PPUSH
17699: LD_INT 4
17701: PPUSH
17702: LD_EXP 99
17706: PUSH
17707: LD_INT 4
17709: ARRAY
17710: PUSH
17711: LD_VAR 0 1
17715: UNION
17716: PPUSH
17717: CALL_OW 1
17721: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
17722: LD_INT 8
17724: PPUSH
17725: LD_VAR 0 1
17729: PPUSH
17730: CALL_OW 472
// end ;
17734: GO 17599
17736: POP
17737: POP
// wait ( 4 4$00 ) ;
17738: LD_INT 8400
17740: PPUSH
17741: CALL_OW 67
// uc_side := 6 ;
17745: LD_ADDR_OWVAR 20
17749: PUSH
17750: LD_INT 6
17752: ST_TO_ADDR
// uc_nation := 3 ;
17753: LD_ADDR_OWVAR 21
17757: PUSH
17758: LD_INT 3
17760: ST_TO_ADDR
// ru := [ ] ;
17761: LD_ADDR_VAR 0 6
17765: PUSH
17766: EMPTY
17767: ST_TO_ADDR
// for i = 1 to 4 do
17768: LD_ADDR_VAR 0 1
17772: PUSH
17773: DOUBLE
17774: LD_INT 1
17776: DEC
17777: ST_TO_ADDR
17778: LD_INT 4
17780: PUSH
17781: FOR_TO
17782: IFFALSE 17883
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
17784: LD_INT 22
17786: PPUSH
17787: LD_INT 1
17789: PPUSH
17790: LD_INT 3
17792: PPUSH
17793: LD_INT 43
17795: PUSH
17796: LD_INT 44
17798: PUSH
17799: EMPTY
17800: LIST
17801: LIST
17802: PUSH
17803: LD_INT 1
17805: PPUSH
17806: LD_INT 2
17808: PPUSH
17809: CALL_OW 12
17813: ARRAY
17814: PPUSH
17815: LD_INT 89
17817: PPUSH
17818: CALL 66065 0 5
// un := CreateVehicle ;
17822: LD_ADDR_VAR 0 7
17826: PUSH
17827: CALL_OW 45
17831: ST_TO_ADDR
// SetDir ( un , 4 ) ;
17832: LD_VAR 0 7
17836: PPUSH
17837: LD_INT 4
17839: PPUSH
17840: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
17844: LD_VAR 0 7
17848: PPUSH
17849: LD_INT 136
17851: PPUSH
17852: LD_INT 90
17854: PPUSH
17855: LD_INT 8
17857: PPUSH
17858: LD_INT 0
17860: PPUSH
17861: CALL_OW 50
// ru := ru ^ un ;
17865: LD_ADDR_VAR 0 6
17869: PUSH
17870: LD_VAR 0 6
17874: PUSH
17875: LD_VAR 0 7
17879: ADD
17880: ST_TO_ADDR
// end ;
17881: GO 17781
17883: POP
17884: POP
// if ru then
17885: LD_VAR 0 6
17889: IFFALSE 17906
// ComAgressiveMove ( ru , 80 , 93 ) ;
17891: LD_VAR 0 6
17895: PPUSH
17896: LD_INT 80
17898: PPUSH
17899: LD_INT 93
17901: PPUSH
17902: CALL_OW 114
// wait ( 8 8$00 ) ;
17906: LD_INT 16800
17908: PPUSH
17909: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
17913: LD_INT 4
17915: PPUSH
17916: LD_INT 3
17918: PUSH
17919: LD_INT 1
17921: PUSH
17922: LD_INT 1
17924: PUSH
17925: LD_INT 5
17927: PUSH
17928: EMPTY
17929: LIST
17930: LIST
17931: LIST
17932: LIST
17933: PUSH
17934: LD_INT 4
17936: PUSH
17937: LD_INT 1
17939: PUSH
17940: LD_INT 1
17942: PUSH
17943: LD_INT 6
17945: PUSH
17946: EMPTY
17947: LIST
17948: LIST
17949: LIST
17950: LIST
17951: PUSH
17952: LD_INT 4
17954: PUSH
17955: LD_INT 1
17957: PUSH
17958: LD_INT 1
17960: PUSH
17961: LD_INT 7
17963: PUSH
17964: EMPTY
17965: LIST
17966: LIST
17967: LIST
17968: LIST
17969: PUSH
17970: LD_INT 3
17972: PUSH
17973: LD_INT 1
17975: PUSH
17976: LD_INT 1
17978: PUSH
17979: LD_INT 7
17981: PUSH
17982: EMPTY
17983: LIST
17984: LIST
17985: LIST
17986: LIST
17987: PUSH
17988: LD_INT 3
17990: PUSH
17991: LD_INT 1
17993: PUSH
17994: LD_INT 1
17996: PUSH
17997: LD_INT 5
17999: PUSH
18000: EMPTY
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: PPUSH
18013: CALL 53489 0 2
// missionStage := 4 ;
18017: LD_ADDR_EXP 15
18021: PUSH
18022: LD_INT 4
18024: ST_TO_ADDR
// end ;
18025: PPOPN 7
18027: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
18028: LD_EXP 15
18032: PUSH
18033: LD_INT 4
18035: EQUAL
18036: PUSH
18037: LD_INT 22
18039: PUSH
18040: LD_INT 4
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: PUSH
18047: LD_INT 21
18049: PUSH
18050: LD_INT 2
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: PUSH
18057: EMPTY
18058: LIST
18059: LIST
18060: PPUSH
18061: CALL_OW 69
18065: PUSH
18066: LD_INT 5
18068: GREATEREQUAL
18069: AND
18070: IFFALSE 22124
18072: GO 18074
18074: DISABLE
18075: LD_INT 0
18077: PPUSH
18078: PPUSH
18079: PPUSH
18080: PPUSH
18081: PPUSH
18082: PPUSH
18083: PPUSH
18084: PPUSH
18085: PPUSH
18086: PPUSH
18087: PPUSH
18088: PPUSH
18089: PPUSH
// begin missionStage := 5 ;
18090: LD_ADDR_EXP 15
18094: PUSH
18095: LD_INT 5
18097: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
18098: LD_ADDR_VAR 0 10
18102: PUSH
18103: LD_INT 22
18105: PUSH
18106: LD_INT 4
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: PUSH
18113: LD_INT 2
18115: PUSH
18116: LD_INT 30
18118: PUSH
18119: LD_INT 4
18121: PUSH
18122: EMPTY
18123: LIST
18124: LIST
18125: PUSH
18126: LD_INT 30
18128: PUSH
18129: LD_INT 5
18131: PUSH
18132: EMPTY
18133: LIST
18134: LIST
18135: PUSH
18136: EMPTY
18137: LIST
18138: LIST
18139: LIST
18140: PUSH
18141: EMPTY
18142: LIST
18143: LIST
18144: PPUSH
18145: CALL_OW 69
18149: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
18150: LD_ADDR_VAR 0 6
18154: PUSH
18155: LD_INT 22
18157: PUSH
18158: LD_INT 4
18160: PUSH
18161: EMPTY
18162: LIST
18163: LIST
18164: PUSH
18165: LD_INT 21
18167: PUSH
18168: LD_INT 1
18170: PUSH
18171: EMPTY
18172: LIST
18173: LIST
18174: PUSH
18175: LD_INT 3
18177: PUSH
18178: LD_INT 25
18180: PUSH
18181: LD_INT 16
18183: PUSH
18184: EMPTY
18185: LIST
18186: LIST
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PUSH
18192: LD_INT 3
18194: PUSH
18195: LD_INT 25
18197: PUSH
18198: LD_INT 12
18200: PUSH
18201: EMPTY
18202: LIST
18203: LIST
18204: PUSH
18205: EMPTY
18206: LIST
18207: LIST
18208: PUSH
18209: EMPTY
18210: LIST
18211: LIST
18212: LIST
18213: LIST
18214: PPUSH
18215: CALL_OW 69
18219: PUSH
18220: LD_EXP 55
18224: DIFF
18225: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
18226: LD_ADDR_VAR 0 9
18230: PUSH
18231: LD_INT 22
18233: PUSH
18234: LD_INT 4
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: PUSH
18241: LD_INT 30
18243: PUSH
18244: LD_INT 3
18246: PUSH
18247: EMPTY
18248: LIST
18249: LIST
18250: PUSH
18251: EMPTY
18252: LIST
18253: LIST
18254: PPUSH
18255: CALL_OW 69
18259: PUSH
18260: LD_INT 1
18262: ARRAY
18263: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18264: LD_INT 35
18266: PPUSH
18267: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 ;
18271: LD_EXP 118
18275: PUSH
18276: LD_INT 4
18278: ARRAY
18279: PUSH
18280: LD_INT 5
18282: GREATEREQUAL
18283: IFFALSE 18264
// powellAllowRetreat := false ;
18285: LD_ADDR_EXP 19
18289: PUSH
18290: LD_INT 0
18292: ST_TO_ADDR
// wait ( 0 0$20 ) ;
18293: LD_INT 700
18295: PPUSH
18296: CALL_OW 67
// activeAttacks := false ;
18300: LD_ADDR_EXP 16
18304: PUSH
18305: LD_INT 0
18307: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18308: LD_INT 35
18310: PPUSH
18311: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
18315: LD_INT 22
18317: PUSH
18318: LD_INT 6
18320: PUSH
18321: EMPTY
18322: LIST
18323: LIST
18324: PPUSH
18325: CALL_OW 69
18329: PUSH
18330: LD_INT 0
18332: EQUAL
18333: IFFALSE 18308
// tmp := mc_vehicles [ 4 ] ;
18335: LD_ADDR_VAR 0 3
18339: PUSH
18340: LD_EXP 118
18344: PUSH
18345: LD_INT 4
18347: ARRAY
18348: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
18349: LD_ADDR_VAR 0 1
18353: PUSH
18354: DOUBLE
18355: LD_INT 1
18357: DEC
18358: ST_TO_ADDR
18359: LD_EXP 18
18363: PUSH
18364: FOR_TO
18365: IFFALSE 18626
// begin for j in powellSquadAttack [ i ] do
18367: LD_ADDR_VAR 0 2
18371: PUSH
18372: LD_EXP 18
18376: PUSH
18377: LD_VAR 0 1
18381: ARRAY
18382: PUSH
18383: FOR_IN
18384: IFFALSE 18622
// begin forces := forces diff j ;
18386: LD_ADDR_VAR 0 6
18390: PUSH
18391: LD_VAR 0 6
18395: PUSH
18396: LD_VAR 0 2
18400: DIFF
18401: ST_TO_ADDR
// SetTag ( j , 1 ) ;
18402: LD_VAR 0 2
18406: PPUSH
18407: LD_INT 1
18409: PPUSH
18410: CALL_OW 109
// wait ( 0 0$2 ) ;
18414: LD_INT 70
18416: PPUSH
18417: CALL_OW 67
// if IsInUnit ( j ) then
18421: LD_VAR 0 2
18425: PPUSH
18426: CALL_OW 310
18430: IFFALSE 18441
// ComExitBuilding ( j ) ;
18432: LD_VAR 0 2
18436: PPUSH
18437: CALL_OW 122
// if GetClass ( j ) <> 1 then
18441: LD_VAR 0 2
18445: PPUSH
18446: CALL_OW 257
18450: PUSH
18451: LD_INT 1
18453: NONEQUAL
18454: IFFALSE 18534
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
18456: LD_VAR 0 10
18460: PUSH
18461: LD_INT 1
18463: ARRAY
18464: PPUSH
18465: CALL_OW 313
18469: PUSH
18470: LD_INT 5
18472: GREATEREQUAL
18473: IFFALSE 18495
// AddComEnterUnit ( j , arm [ 2 ] ) else
18475: LD_VAR 0 2
18479: PPUSH
18480: LD_VAR 0 10
18484: PUSH
18485: LD_INT 2
18487: ARRAY
18488: PPUSH
18489: CALL_OW 180
18493: GO 18513
// AddComEnterUnit ( j , arm [ 1 ] ) ;
18495: LD_VAR 0 2
18499: PPUSH
18500: LD_VAR 0 10
18504: PUSH
18505: LD_INT 1
18507: ARRAY
18508: PPUSH
18509: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
18513: LD_VAR 0 2
18517: PPUSH
18518: LD_INT 1
18520: PPUSH
18521: CALL_OW 183
// AddComExitBuilding ( j ) ;
18525: LD_VAR 0 2
18529: PPUSH
18530: CALL_OW 182
// end ; if i = 2 then
18534: LD_VAR 0 1
18538: PUSH
18539: LD_INT 2
18541: EQUAL
18542: IFFALSE 18559
// AddComMoveXY ( j , 61 , 93 ) ;
18544: LD_VAR 0 2
18548: PPUSH
18549: LD_INT 61
18551: PPUSH
18552: LD_INT 93
18554: PPUSH
18555: CALL_OW 171
// if i = 1 then
18559: LD_VAR 0 1
18563: PUSH
18564: LD_INT 1
18566: EQUAL
18567: IFFALSE 18620
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
18569: LD_VAR 0 2
18573: PPUSH
18574: LD_VAR 0 3
18578: PUSH
18579: LD_INT 1
18581: ARRAY
18582: PPUSH
18583: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
18587: LD_ADDR_VAR 0 3
18591: PUSH
18592: LD_VAR 0 3
18596: PPUSH
18597: LD_INT 1
18599: PPUSH
18600: CALL_OW 3
18604: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
18605: LD_VAR 0 2
18609: PPUSH
18610: LD_INT 69
18612: PPUSH
18613: LD_INT 94
18615: PPUSH
18616: CALL_OW 171
// end ; end ;
18620: GO 18383
18622: POP
18623: POP
// end ;
18624: GO 18364
18626: POP
18627: POP
// wait ( 0 0$45 ) ;
18628: LD_INT 1575
18630: PPUSH
18631: CALL_OW 67
// MC_Kill ( 4 ) ;
18635: LD_INT 4
18637: PPUSH
18638: CALL 31781 0 1
// tmp := UnitsInside ( fac ) ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_VAR 0 9
18651: PPUSH
18652: CALL_OW 313
18656: ST_TO_ADDR
// if tmp then
18657: LD_VAR 0 3
18661: IFFALSE 18782
// for i in tmp do
18663: LD_ADDR_VAR 0 1
18667: PUSH
18668: LD_VAR 0 3
18672: PUSH
18673: FOR_IN
18674: IFFALSE 18780
// begin ComExitBuilding ( i ) ;
18676: LD_VAR 0 1
18680: PPUSH
18681: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
18685: LD_VAR 0 10
18689: PUSH
18690: LD_INT 2
18692: ARRAY
18693: PPUSH
18694: CALL_OW 313
18698: PUSH
18699: LD_INT 6
18701: LESS
18702: IFFALSE 18724
// AddComEnterUnit ( i , arm [ 2 ] ) else
18704: LD_VAR 0 1
18708: PPUSH
18709: LD_VAR 0 10
18713: PUSH
18714: LD_INT 2
18716: ARRAY
18717: PPUSH
18718: CALL_OW 180
18722: GO 18778
// if UnitsInside ( arm [ 1 ] ) < 6 then
18724: LD_VAR 0 10
18728: PUSH
18729: LD_INT 1
18731: ARRAY
18732: PPUSH
18733: CALL_OW 313
18737: PUSH
18738: LD_INT 6
18740: LESS
18741: IFFALSE 18763
// AddComEnterUnit ( i , arm [ 1 ] ) else
18743: LD_VAR 0 1
18747: PPUSH
18748: LD_VAR 0 10
18752: PUSH
18753: LD_INT 1
18755: ARRAY
18756: PPUSH
18757: CALL_OW 180
18761: GO 18778
// AddComMoveXY ( i , 37 , 68 ) ;
18763: LD_VAR 0 1
18767: PPUSH
18768: LD_INT 37
18770: PPUSH
18771: LD_INT 68
18773: PPUSH
18774: CALL_OW 171
// end ;
18778: GO 18673
18780: POP
18781: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
18782: LD_ADDR_VAR 0 11
18786: PUSH
18787: LD_VAR 0 6
18791: PPUSH
18792: LD_INT 26
18794: PUSH
18795: LD_INT 1
18797: PUSH
18798: EMPTY
18799: LIST
18800: LIST
18801: PPUSH
18802: CALL_OW 72
18806: PUSH
18807: LD_EXP 56
18811: DIFF
18812: ST_TO_ADDR
// if not speaker then
18813: LD_VAR 0 11
18817: NOT
18818: IFFALSE 18845
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
18820: LD_ADDR_VAR 0 11
18824: PUSH
18825: LD_VAR 0 6
18829: PPUSH
18830: LD_INT 26
18832: PUSH
18833: LD_INT 1
18835: PUSH
18836: EMPTY
18837: LIST
18838: LIST
18839: PPUSH
18840: CALL_OW 72
18844: ST_TO_ADDR
// if speaker then
18845: LD_VAR 0 11
18849: IFFALSE 18865
// speaker := speaker [ 1 ] ;
18851: LD_ADDR_VAR 0 11
18855: PUSH
18856: LD_VAR 0 11
18860: PUSH
18861: LD_INT 1
18863: ARRAY
18864: ST_TO_ADDR
// Video ( true ) ;
18865: LD_INT 1
18867: PPUSH
18868: CALL 101720 0 1
// CenterNowOnUnits ( Powell ) ;
18872: LD_EXP 55
18876: PPUSH
18877: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
18881: LD_ADDR_VAR 0 3
18885: PUSH
18886: LD_VAR 0 6
18890: PPUSH
18891: LD_INT 3
18893: PUSH
18894: LD_INT 25
18896: PUSH
18897: LD_INT 1
18899: PUSH
18900: EMPTY
18901: LIST
18902: LIST
18903: PUSH
18904: EMPTY
18905: LIST
18906: LIST
18907: PPUSH
18908: CALL_OW 72
18912: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
18913: LD_ADDR_VAR 0 12
18917: PUSH
18918: LD_INT 22
18920: PUSH
18921: LD_INT 4
18923: PUSH
18924: EMPTY
18925: LIST
18926: LIST
18927: PUSH
18928: LD_INT 30
18930: PUSH
18931: LD_INT 32
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: PUSH
18938: LD_INT 58
18940: PUSH
18941: EMPTY
18942: LIST
18943: PUSH
18944: EMPTY
18945: LIST
18946: LIST
18947: LIST
18948: PPUSH
18949: CALL_OW 69
18953: ST_TO_ADDR
// for i = 1 to 6 do
18954: LD_ADDR_VAR 0 1
18958: PUSH
18959: DOUBLE
18960: LD_INT 1
18962: DEC
18963: ST_TO_ADDR
18964: LD_INT 6
18966: PUSH
18967: FOR_TO
18968: IFFALSE 19109
// begin if IsInUnit ( tmp [ i ] ) then
18970: LD_VAR 0 3
18974: PUSH
18975: LD_VAR 0 1
18979: ARRAY
18980: PPUSH
18981: CALL_OW 310
18985: IFFALSE 19002
// ComExitBuilding ( tmp [ i ] ) ;
18987: LD_VAR 0 3
18991: PUSH
18992: LD_VAR 0 1
18996: ARRAY
18997: PPUSH
18998: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
19002: LD_VAR 0 3
19006: PUSH
19007: LD_VAR 0 1
19011: ARRAY
19012: PPUSH
19013: LD_VAR 0 10
19017: PUSH
19018: LD_INT 1
19020: ARRAY
19021: PPUSH
19022: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
19026: LD_VAR 0 3
19030: PUSH
19031: LD_VAR 0 1
19035: ARRAY
19036: PPUSH
19037: LD_INT 1
19039: PPUSH
19040: CALL_OW 183
// if emp_towers then
19044: LD_VAR 0 12
19048: IFFALSE 19107
// begin AddComExitBuilding ( tmp [ i ] ) ;
19050: LD_VAR 0 3
19054: PUSH
19055: LD_VAR 0 1
19059: ARRAY
19060: PPUSH
19061: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
19065: LD_VAR 0 3
19069: PUSH
19070: LD_VAR 0 1
19074: ARRAY
19075: PPUSH
19076: LD_VAR 0 12
19080: PUSH
19081: LD_INT 1
19083: ARRAY
19084: PPUSH
19085: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
19089: LD_ADDR_VAR 0 12
19093: PUSH
19094: LD_VAR 0 12
19098: PPUSH
19099: LD_INT 1
19101: PPUSH
19102: CALL_OW 3
19106: ST_TO_ADDR
// end ; end ;
19107: GO 18967
19109: POP
19110: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
19111: LD_ADDR_VAR 0 3
19115: PUSH
19116: LD_EXP 18
19120: PUSH
19121: LD_INT 1
19123: ARRAY
19124: PUSH
19125: LD_EXP 18
19129: PUSH
19130: LD_INT 2
19132: ARRAY
19133: ADD
19134: PPUSH
19135: LD_INT 26
19137: PUSH
19138: LD_INT 1
19140: PUSH
19141: EMPTY
19142: LIST
19143: LIST
19144: PPUSH
19145: CALL_OW 72
19149: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: LD_EXP 18
19159: PUSH
19160: LD_INT 2
19162: ARRAY
19163: PUSH
19164: FOR_IN
19165: IFFALSE 19183
// ComTurnUnit ( i , Powell ) ;
19167: LD_VAR 0 1
19171: PPUSH
19172: LD_EXP 55
19176: PPUSH
19177: CALL_OW 119
19181: GO 19164
19183: POP
19184: POP
// Say ( Powell , D5-Pow-1 ) ;
19185: LD_EXP 55
19189: PPUSH
19190: LD_STRING D5-Pow-1
19192: PPUSH
19193: CALL_OW 88
// if tmp then
19197: LD_VAR 0 3
19201: IFFALSE 19219
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
19203: LD_VAR 0 3
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: PPUSH
19212: LD_STRING D5-Sol2-1
19214: PPUSH
19215: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
19219: LD_EXP 55
19223: PPUSH
19224: LD_STRING D5-Pow-2
19226: PPUSH
19227: CALL_OW 88
// if tmp > 1 then
19231: LD_VAR 0 3
19235: PUSH
19236: LD_INT 1
19238: GREATER
19239: IFFALSE 19257
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
19241: LD_VAR 0 3
19245: PUSH
19246: LD_INT 2
19248: ARRAY
19249: PPUSH
19250: LD_STRING D5-Sol2-2
19252: PPUSH
19253: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
19257: LD_EXP 55
19261: PPUSH
19262: LD_STRING D5-Pow-3
19264: PPUSH
19265: CALL_OW 88
// wait ( 0 0$1 ) ;
19269: LD_INT 35
19271: PPUSH
19272: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
19276: LD_ADDR_VAR 0 3
19280: PUSH
19281: LD_EXP 18
19285: PUSH
19286: LD_INT 1
19288: ARRAY
19289: PUSH
19290: LD_EXP 18
19294: PUSH
19295: LD_INT 2
19297: ARRAY
19298: UNION
19299: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
19300: LD_VAR 0 3
19304: PPUSH
19305: LD_INT 80
19307: PPUSH
19308: LD_INT 67
19310: PPUSH
19311: CALL_OW 114
// wait ( 0 0$2 ) ;
19315: LD_INT 70
19317: PPUSH
19318: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
19322: LD_INT 79
19324: PPUSH
19325: LD_INT 72
19327: PPUSH
19328: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
19332: LD_INT 35
19334: PPUSH
19335: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
19339: LD_VAR 0 3
19343: PPUSH
19344: LD_INT 3
19346: PUSH
19347: LD_INT 24
19349: PUSH
19350: LD_INT 1000
19352: PUSH
19353: EMPTY
19354: LIST
19355: LIST
19356: PUSH
19357: EMPTY
19358: LIST
19359: LIST
19360: PPUSH
19361: CALL_OW 72
19365: IFFALSE 19332
// Say ( Powell , D5a-Pow-1 ) ;
19367: LD_EXP 55
19371: PPUSH
19372: LD_STRING D5a-Pow-1
19374: PPUSH
19375: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
19379: LD_EXP 55
19383: PPUSH
19384: LD_STRING D5a-Pow-1a
19386: PPUSH
19387: CALL_OW 88
// wait ( 0 0$0.3 ) ;
19391: LD_INT 10
19393: PPUSH
19394: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
19398: LD_EXP 55
19402: PPUSH
19403: LD_STRING D5a-Pow-1b
19405: PPUSH
19406: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
19410: LD_EXP 55
19414: PPUSH
19415: LD_STRING D5a-Pow-1c
19417: PPUSH
19418: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
19422: LD_EXP 55
19426: PPUSH
19427: LD_STRING D5a-Pow-1d
19429: PPUSH
19430: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
19434: LD_INT 35
19436: PPUSH
19437: CALL_OW 67
// if not HasTask ( tmp ) then
19441: LD_VAR 0 3
19445: PPUSH
19446: CALL_OW 314
19450: NOT
19451: IFFALSE 19468
// ComAgressiveMove ( tmp , 80 , 67 ) ;
19453: LD_VAR 0 3
19457: PPUSH
19458: LD_INT 80
19460: PPUSH
19461: LD_INT 67
19463: PPUSH
19464: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
19468: LD_VAR 0 3
19472: PPUSH
19473: LD_INT 24
19475: PUSH
19476: LD_INT 1
19478: PUSH
19479: EMPTY
19480: LIST
19481: LIST
19482: PPUSH
19483: CALL_OW 72
19487: NOT
19488: IFFALSE 19434
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
19490: LD_ADDR_VAR 0 3
19494: PUSH
19495: LD_INT 22
19497: PUSH
19498: LD_INT 4
19500: PUSH
19501: EMPTY
19502: LIST
19503: LIST
19504: PUSH
19505: LD_INT 92
19507: PUSH
19508: LD_INT 60
19510: PUSH
19511: LD_INT 93
19513: PUSH
19514: LD_INT 10
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: LIST
19521: LIST
19522: PUSH
19523: LD_INT 3
19525: PUSH
19526: LD_INT 54
19528: PUSH
19529: EMPTY
19530: LIST
19531: PUSH
19532: EMPTY
19533: LIST
19534: LIST
19535: PUSH
19536: EMPTY
19537: LIST
19538: LIST
19539: LIST
19540: PPUSH
19541: CALL_OW 69
19545: PUSH
19546: LD_EXP 55
19550: DIFF
19551: ST_TO_ADDR
// if tmp then
19552: LD_VAR 0 3
19556: IFFALSE 19590
// for i in tmp do
19558: LD_ADDR_VAR 0 1
19562: PUSH
19563: LD_VAR 0 3
19567: PUSH
19568: FOR_IN
19569: IFFALSE 19588
// ComMoveXY ( i , 36 , 67 ) ;
19571: LD_VAR 0 1
19575: PPUSH
19576: LD_INT 36
19578: PPUSH
19579: LD_INT 67
19581: PPUSH
19582: CALL_OW 111
19586: GO 19568
19588: POP
19589: POP
// wait ( 0 0$3 ) ;
19590: LD_INT 105
19592: PPUSH
19593: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
19597: LD_VAR 0 11
19601: PPUSH
19602: LD_STRING D6-Sol3-1
19604: PPUSH
19605: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
19609: LD_EXP 55
19613: PPUSH
19614: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
19618: LD_EXP 55
19622: PPUSH
19623: LD_STRING D6-Pow-1
19625: PPUSH
19626: CALL_OW 88
// tmp := [ ] ;
19630: LD_ADDR_VAR 0 3
19634: PUSH
19635: EMPTY
19636: ST_TO_ADDR
// for i = 1 to 2 do
19637: LD_ADDR_VAR 0 1
19641: PUSH
19642: DOUBLE
19643: LD_INT 1
19645: DEC
19646: ST_TO_ADDR
19647: LD_INT 2
19649: PUSH
19650: FOR_TO
19651: IFFALSE 19758
// begin uc_side := 8 ;
19653: LD_ADDR_OWVAR 20
19657: PUSH
19658: LD_INT 8
19660: ST_TO_ADDR
// uc_nation := 2 ;
19661: LD_ADDR_OWVAR 21
19665: PUSH
19666: LD_INT 2
19668: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
19669: LD_INT 14
19671: PPUSH
19672: LD_INT 3
19674: PPUSH
19675: LD_INT 2
19677: PPUSH
19678: LD_INT 29
19680: PPUSH
19681: LD_INT 100
19683: PPUSH
19684: CALL 66065 0 5
// veh := CreateVehicle ;
19688: LD_ADDR_VAR 0 13
19692: PUSH
19693: CALL_OW 45
19697: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
19698: LD_VAR 0 13
19702: PPUSH
19703: LD_INT 4
19705: PPUSH
19706: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
19710: LD_VAR 0 13
19714: PPUSH
19715: LD_INT 99
19717: PPUSH
19718: LD_INT 83
19720: PPUSH
19721: LD_INT 5
19723: PPUSH
19724: LD_INT 0
19726: PPUSH
19727: CALL_OW 50
// Connect ( veh ) ;
19731: LD_VAR 0 13
19735: PPUSH
19736: CALL 69120 0 1
// tmp := tmp ^ veh ;
19740: LD_ADDR_VAR 0 3
19744: PUSH
19745: LD_VAR 0 3
19749: PUSH
19750: LD_VAR 0 13
19754: ADD
19755: ST_TO_ADDR
// end ;
19756: GO 19650
19758: POP
19759: POP
// wait ( 0 0$1 ) ;
19760: LD_INT 35
19762: PPUSH
19763: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
19767: LD_INT 99
19769: PPUSH
19770: LD_INT 83
19772: PPUSH
19773: LD_INT 1
19775: PPUSH
19776: LD_INT 10
19778: PPUSH
19779: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
19783: LD_INT 99
19785: PPUSH
19786: LD_INT 83
19788: PPUSH
19789: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
19793: LD_VAR 0 11
19797: PPUSH
19798: LD_STRING D6-Sol3-2
19800: PPUSH
19801: CALL_OW 88
// async ;
19805: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
19806: LD_EXP 55
19810: PPUSH
19811: LD_STRING D6-Pow-2
19813: PPUSH
19814: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
19818: LD_VAR 0 3
19822: PUSH
19823: LD_INT 1
19825: ARRAY
19826: PPUSH
19827: LD_VAR 0 9
19831: PPUSH
19832: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
19836: LD_VAR 0 3
19840: PUSH
19841: LD_INT 2
19843: ARRAY
19844: PPUSH
19845: LD_INT 22
19847: PUSH
19848: LD_INT 4
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: LD_INT 21
19857: PUSH
19858: LD_INT 3
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PPUSH
19869: CALL_OW 69
19873: PPUSH
19874: LD_VAR 0 3
19878: PUSH
19879: LD_INT 2
19881: ARRAY
19882: PPUSH
19883: CALL_OW 74
19887: PPUSH
19888: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
19892: LD_EXP 55
19896: PPUSH
19897: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
19901: LD_INT 99
19903: PPUSH
19904: LD_INT 83
19906: PPUSH
19907: LD_INT 1
19909: PPUSH
19910: CALL_OW 331
// repeat wait ( 4 ) ;
19914: LD_INT 4
19916: PPUSH
19917: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
19921: LD_VAR 0 3
19925: PUSH
19926: LD_INT 1
19928: ARRAY
19929: PPUSH
19930: CALL_OW 256
19934: PUSH
19935: LD_INT 1000
19937: LESS
19938: IFFALSE 19956
// SetLives ( tmp [ 1 ] , 1000 ) ;
19940: LD_VAR 0 3
19944: PUSH
19945: LD_INT 1
19947: ARRAY
19948: PPUSH
19949: LD_INT 1000
19951: PPUSH
19952: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
19956: LD_INT 22
19958: PUSH
19959: LD_INT 4
19961: PUSH
19962: EMPTY
19963: LIST
19964: LIST
19965: PUSH
19966: LD_INT 30
19968: PUSH
19969: LD_INT 3
19971: PUSH
19972: EMPTY
19973: LIST
19974: LIST
19975: PUSH
19976: EMPTY
19977: LIST
19978: LIST
19979: PPUSH
19980: CALL_OW 69
19984: PUSH
19985: LD_INT 0
19987: EQUAL
19988: IFFALSE 19914
// sync ;
19990: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
19991: LD_EXP 55
19995: PPUSH
19996: LD_STRING D6a-Pow-1
19998: PPUSH
19999: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
20003: LD_VAR 0 11
20007: PPUSH
20008: LD_STRING D6a-Sol3-1
20010: PPUSH
20011: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
20015: LD_EXP 55
20019: PPUSH
20020: LD_STRING D6a-Pow-2
20022: PPUSH
20023: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
20027: LD_VAR 0 11
20031: PPUSH
20032: LD_STRING D6a-Sol3-2
20034: PPUSH
20035: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
20039: LD_EXP 55
20043: PPUSH
20044: LD_STRING D6a-Pow-3
20046: PPUSH
20047: CALL_OW 88
// powellCenterCameraMode := true ;
20051: LD_ADDR_EXP 20
20055: PUSH
20056: LD_INT 1
20058: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
20059: LD_ADDR_VAR 0 1
20063: PUSH
20064: LD_INT 22
20066: PUSH
20067: LD_INT 8
20069: PUSH
20070: EMPTY
20071: LIST
20072: LIST
20073: PUSH
20074: LD_INT 25
20076: PUSH
20077: LD_INT 2
20079: PUSH
20080: EMPTY
20081: LIST
20082: LIST
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PPUSH
20088: CALL_OW 69
20092: PUSH
20093: FOR_IN
20094: IFFALSE 20149
// begin SetTag ( i , 1 ) ;
20096: LD_VAR 0 1
20100: PPUSH
20101: LD_INT 1
20103: PPUSH
20104: CALL_OW 109
// ComExitBuilding ( i ) ;
20108: LD_VAR 0 1
20112: PPUSH
20113: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
20117: LD_VAR 0 1
20121: PPUSH
20122: LD_INT 35
20124: PPUSH
20125: LD_INT 6
20127: PPUSH
20128: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
20132: LD_VAR 0 1
20136: PPUSH
20137: LD_INT 53
20139: PPUSH
20140: LD_INT 4
20142: PPUSH
20143: CALL_OW 171
// end ;
20147: GO 20093
20149: POP
20150: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
20151: LD_ADDR_VAR 0 3
20155: PUSH
20156: LD_INT 22
20158: PUSH
20159: LD_INT 4
20161: PUSH
20162: EMPTY
20163: LIST
20164: LIST
20165: PUSH
20166: LD_INT 21
20168: PUSH
20169: LD_INT 2
20171: PUSH
20172: EMPTY
20173: LIST
20174: LIST
20175: PUSH
20176: LD_INT 3
20178: PUSH
20179: LD_INT 34
20181: PUSH
20182: LD_INT 12
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: PUSH
20193: EMPTY
20194: LIST
20195: LIST
20196: LIST
20197: PPUSH
20198: CALL_OW 69
20202: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
20203: LD_EXP 55
20207: PPUSH
20208: LD_VAR 0 3
20212: PPUSH
20213: LD_EXP 55
20217: PPUSH
20218: CALL_OW 74
20222: PPUSH
20223: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
20227: LD_EXP 55
20231: PPUSH
20232: LD_INT 100
20234: PPUSH
20235: LD_INT 88
20237: PPUSH
20238: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
20242: LD_EXP 55
20246: PPUSH
20247: LD_INT 100
20249: PPUSH
20250: LD_INT 75
20252: PPUSH
20253: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
20257: LD_EXP 55
20261: PPUSH
20262: LD_INT 88
20264: PPUSH
20265: LD_INT 53
20267: PPUSH
20268: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
20272: LD_INT 8
20274: PPUSH
20275: LD_EXP 55
20279: PPUSH
20280: CALL_OW 471
// repeat wait ( 3 ) ;
20284: LD_INT 3
20286: PPUSH
20287: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
20291: LD_INT 22
20293: PUSH
20294: LD_INT 4
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: PUSH
20301: LD_INT 92
20303: PUSH
20304: LD_INT 100
20306: PUSH
20307: LD_INT 75
20309: PUSH
20310: LD_INT 6
20312: PUSH
20313: EMPTY
20314: LIST
20315: LIST
20316: LIST
20317: LIST
20318: PUSH
20319: EMPTY
20320: LIST
20321: LIST
20322: PPUSH
20323: CALL_OW 69
20327: IFFALSE 20284
// async ;
20329: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
20330: LD_EXP 55
20334: PPUSH
20335: LD_STRING D6b-Pow-1
20337: PPUSH
20338: CALL_OW 88
// repeat wait ( 3 ) ;
20342: LD_INT 3
20344: PPUSH
20345: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
20349: LD_EXP 55
20353: PPUSH
20354: CALL_OW 310
20358: PPUSH
20359: CALL_OW 256
20363: PUSH
20364: LD_INT 1000
20366: LESS
20367: IFFALSE 20386
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
20369: LD_EXP 55
20373: PPUSH
20374: CALL_OW 310
20378: PPUSH
20379: LD_INT 1000
20381: PPUSH
20382: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
20386: LD_EXP 55
20390: PPUSH
20391: CALL_OW 256
20395: PUSH
20396: LD_INT 1000
20398: LESS
20399: IFFALSE 20413
// SetLives ( Powell , 1000 ) ;
20401: LD_EXP 55
20405: PPUSH
20406: LD_INT 1000
20408: PPUSH
20409: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
20413: LD_EXP 55
20417: PPUSH
20418: LD_EXP 60
20422: PPUSH
20423: CALL_OW 296
20427: PUSH
20428: LD_INT 5
20430: LESS
20431: PUSH
20432: LD_EXP 55
20436: PPUSH
20437: CALL_OW 310
20441: PPUSH
20442: LD_EXP 60
20446: PPUSH
20447: CALL_OW 296
20451: PUSH
20452: LD_INT 5
20454: LESS
20455: OR
20456: IFFALSE 20475
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
20458: LD_EXP 55
20462: PPUSH
20463: CALL_OW 310
20467: PPUSH
20468: LD_INT 100
20470: PPUSH
20471: CALL_OW 234
// until not IsInUnit ( Powell ) ;
20475: LD_EXP 55
20479: PPUSH
20480: CALL_OW 310
20484: NOT
20485: IFFALSE 20342
// game_speed := 4 ;
20487: LD_ADDR_OWVAR 65
20491: PUSH
20492: LD_INT 4
20494: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
20495: LD_EXP 55
20499: PPUSH
20500: LD_STRING D6b-Pow-1a
20502: PPUSH
20503: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
20507: LD_EXP 55
20511: PPUSH
20512: LD_EXP 60
20516: PPUSH
20517: CALL_OW 180
// sync ;
20521: SYNC
// repeat wait ( 0 0$1 ) ;
20522: LD_INT 35
20524: PPUSH
20525: CALL_OW 67
// until IsInUnit ( Powell ) ;
20529: LD_EXP 55
20533: PPUSH
20534: CALL_OW 310
20538: IFFALSE 20522
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
20540: LD_INT 8
20542: PPUSH
20543: LD_EXP 55
20547: PPUSH
20548: CALL_OW 310
20552: PPUSH
20553: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
20557: LD_EXP 55
20561: PPUSH
20562: LD_INT 91
20564: PPUSH
20565: LD_INT 44
20567: PPUSH
20568: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
20572: LD_EXP 55
20576: PPUSH
20577: LD_INT 96
20579: PPUSH
20580: LD_INT 44
20582: PPUSH
20583: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
20587: LD_EXP 55
20591: PPUSH
20592: LD_INT 96
20594: PPUSH
20595: LD_INT 41
20597: PPUSH
20598: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
20602: LD_EXP 55
20606: PPUSH
20607: LD_INT 92
20609: PPUSH
20610: LD_INT 39
20612: PPUSH
20613: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
20617: LD_EXP 55
20621: PPUSH
20622: LD_INT 88
20624: PPUSH
20625: LD_INT 41
20627: PPUSH
20628: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
20632: LD_EXP 55
20636: PPUSH
20637: LD_INT 91
20639: PPUSH
20640: LD_INT 44
20642: PPUSH
20643: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
20647: LD_EXP 55
20651: PPUSH
20652: LD_INT 96
20654: PPUSH
20655: LD_INT 44
20657: PPUSH
20658: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
20662: LD_EXP 55
20666: PPUSH
20667: LD_INT 96
20669: PPUSH
20670: LD_INT 41
20672: PPUSH
20673: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
20677: LD_EXP 55
20681: PPUSH
20682: LD_INT 92
20684: PPUSH
20685: LD_INT 39
20687: PPUSH
20688: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
20692: LD_EXP 55
20696: PPUSH
20697: LD_INT 88
20699: PPUSH
20700: LD_INT 41
20702: PPUSH
20703: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
20707: LD_EXP 55
20711: PPUSH
20712: LD_INT 91
20714: PPUSH
20715: LD_INT 44
20717: PPUSH
20718: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
20722: LD_EXP 55
20726: PPUSH
20727: LD_INT 93
20729: PPUSH
20730: LD_INT 39
20732: PPUSH
20733: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
20737: LD_EXP 55
20741: PPUSH
20742: LD_INT 93
20744: PPUSH
20745: LD_INT 36
20747: PPUSH
20748: CALL_OW 171
// wait ( 0 0$3.5 ) ;
20752: LD_INT 122
20754: PPUSH
20755: CALL_OW 67
// game_speed := 4 ;
20759: LD_ADDR_OWVAR 65
20763: PUSH
20764: LD_INT 4
20766: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
20767: LD_EXP 55
20771: PPUSH
20772: LD_STRING D6b-Pow-1b
20774: PPUSH
20775: CALL_OW 88
// tmp := [ ] ;
20779: LD_ADDR_VAR 0 3
20783: PUSH
20784: EMPTY
20785: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
20786: LD_ADDR_VAR 0 5
20790: PUSH
20791: LD_INT 78
20793: PUSH
20794: LD_INT 47
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: PUSH
20801: LD_INT 106
20803: PUSH
20804: LD_INT 53
20806: PUSH
20807: EMPTY
20808: LIST
20809: LIST
20810: PUSH
20811: EMPTY
20812: LIST
20813: LIST
20814: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
20815: LD_ADDR_VAR 0 1
20819: PUSH
20820: LD_INT 22
20822: PUSH
20823: LD_INT 8
20825: PUSH
20826: EMPTY
20827: LIST
20828: LIST
20829: PUSH
20830: LD_INT 21
20832: PUSH
20833: LD_INT 3
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: PUSH
20840: LD_INT 92
20842: PUSH
20843: LD_INT 90
20845: PUSH
20846: LD_INT 52
20848: PUSH
20849: LD_INT 12
20851: PUSH
20852: EMPTY
20853: LIST
20854: LIST
20855: LIST
20856: LIST
20857: PUSH
20858: EMPTY
20859: LIST
20860: LIST
20861: LIST
20862: PPUSH
20863: CALL_OW 69
20867: PUSH
20868: FOR_IN
20869: IFFALSE 20894
// tmp := tmp ^ UnitsInside ( i ) ;
20871: LD_ADDR_VAR 0 3
20875: PUSH
20876: LD_VAR 0 3
20880: PUSH
20881: LD_VAR 0 1
20885: PPUSH
20886: CALL_OW 313
20890: ADD
20891: ST_TO_ADDR
20892: GO 20868
20894: POP
20895: POP
// for i in tmp do
20896: LD_ADDR_VAR 0 1
20900: PUSH
20901: LD_VAR 0 3
20905: PUSH
20906: FOR_IN
20907: IFFALSE 21069
// begin dist := 9999 ;
20909: LD_ADDR_VAR 0 8
20913: PUSH
20914: LD_INT 9999
20916: ST_TO_ADDR
// _xy := [ ] ;
20917: LD_ADDR_VAR 0 7
20921: PUSH
20922: EMPTY
20923: ST_TO_ADDR
// SetTag ( i , 1 ) ;
20924: LD_VAR 0 1
20928: PPUSH
20929: LD_INT 1
20931: PPUSH
20932: CALL_OW 109
// ComExitBuilding ( i ) ;
20936: LD_VAR 0 1
20940: PPUSH
20941: CALL_OW 122
// for j in xy do
20945: LD_ADDR_VAR 0 2
20949: PUSH
20950: LD_VAR 0 5
20954: PUSH
20955: FOR_IN
20956: IFFALSE 21038
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
20958: LD_VAR 0 1
20962: PPUSH
20963: LD_VAR 0 2
20967: PUSH
20968: LD_INT 1
20970: ARRAY
20971: PPUSH
20972: LD_VAR 0 2
20976: PUSH
20977: LD_INT 2
20979: ARRAY
20980: PPUSH
20981: CALL_OW 297
20985: PUSH
20986: LD_VAR 0 8
20990: LESS
20991: IFFALSE 21036
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
20993: LD_ADDR_VAR 0 8
20997: PUSH
20998: LD_VAR 0 1
21002: PPUSH
21003: LD_VAR 0 2
21007: PUSH
21008: LD_INT 1
21010: ARRAY
21011: PPUSH
21012: LD_VAR 0 2
21016: PUSH
21017: LD_INT 2
21019: ARRAY
21020: PPUSH
21021: CALL_OW 297
21025: ST_TO_ADDR
// _xy := j ;
21026: LD_ADDR_VAR 0 7
21030: PUSH
21031: LD_VAR 0 2
21035: ST_TO_ADDR
// end ;
21036: GO 20955
21038: POP
21039: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
21040: LD_VAR 0 1
21044: PPUSH
21045: LD_VAR 0 7
21049: PUSH
21050: LD_INT 1
21052: ARRAY
21053: PPUSH
21054: LD_VAR 0 7
21058: PUSH
21059: LD_INT 2
21061: ARRAY
21062: PPUSH
21063: CALL_OW 171
// end ;
21067: GO 20906
21069: POP
21070: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
21071: LD_ADDR_VAR 0 4
21075: PUSH
21076: LD_VAR 0 3
21080: PPUSH
21081: LD_INT 26
21083: PUSH
21084: LD_INT 1
21086: PUSH
21087: EMPTY
21088: LIST
21089: LIST
21090: PUSH
21091: LD_INT 25
21093: PUSH
21094: LD_INT 1
21096: PUSH
21097: EMPTY
21098: LIST
21099: LIST
21100: PUSH
21101: EMPTY
21102: LIST
21103: LIST
21104: PPUSH
21105: CALL_OW 72
21109: ST_TO_ADDR
// if tmp2 < 2 then
21110: LD_VAR 0 4
21114: PUSH
21115: LD_INT 2
21117: LESS
21118: IFFALSE 21187
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
21120: LD_ADDR_VAR 0 4
21124: PUSH
21125: LD_INT 22
21127: PUSH
21128: LD_INT 8
21130: PUSH
21131: EMPTY
21132: LIST
21133: LIST
21134: PUSH
21135: LD_INT 26
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PUSH
21145: LD_INT 3
21147: PUSH
21148: LD_INT 25
21150: PUSH
21151: LD_INT 15
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: LIST
21166: PPUSH
21167: CALL_OW 69
21171: PUSH
21172: LD_EXP 57
21176: PUSH
21177: LD_EXP 58
21181: PUSH
21182: EMPTY
21183: LIST
21184: LIST
21185: DIFF
21186: ST_TO_ADDR
// if tmp2 then
21187: LD_VAR 0 4
21191: IFFALSE 21209
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
21193: LD_VAR 0 4
21197: PUSH
21198: LD_INT 1
21200: ARRAY
21201: PPUSH
21202: LD_STRING D6b-ArSol1-1
21204: PPUSH
21205: CALL_OW 88
// async ;
21209: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
21210: LD_EXP 55
21214: PPUSH
21215: LD_STRING D6b-Pow-2
21217: PPUSH
21218: CALL_OW 88
// if tmp2 > 1 then
21222: LD_VAR 0 4
21226: PUSH
21227: LD_INT 1
21229: GREATER
21230: IFFALSE 21248
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
21232: LD_VAR 0 4
21236: PUSH
21237: LD_INT 2
21239: ARRAY
21240: PPUSH
21241: LD_STRING D6b-ArSol2-1
21243: PPUSH
21244: CALL_OW 88
// sync ;
21248: SYNC
// repeat wait ( 5 ) ;
21249: LD_INT 5
21251: PPUSH
21252: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
21256: LD_INT 93
21258: PPUSH
21259: LD_INT 36
21261: PPUSH
21262: CALL_OW 428
21266: PPUSH
21267: CALL_OW 255
21271: PUSH
21272: LD_INT 4
21274: EQUAL
21275: IFFALSE 21249
// DialogueOn ;
21277: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
21281: LD_INT 10
21283: PPUSH
21284: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
21288: LD_EXP 55
21292: PPUSH
21293: LD_STRING D6b-Pow-2a
21295: PPUSH
21296: CALL_OW 88
// DialogueOff ;
21300: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
21304: LD_EXP 55
21308: PPUSH
21309: CALL_OW 310
21313: PPUSH
21314: LD_INT 332
21316: PPUSH
21317: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
21321: LD_INT 93
21323: PPUSH
21324: LD_INT 35
21326: PPUSH
21327: LD_INT 1
21329: PPUSH
21330: LD_INT 6
21332: NEG
21333: PPUSH
21334: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
21338: LD_INT 35
21340: PPUSH
21341: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
21345: LD_INT 332
21347: PPUSH
21348: CALL_OW 256
21352: PUSH
21353: LD_INT 1000
21355: LESS
21356: PUSH
21357: LD_INT 332
21359: PPUSH
21360: CALL_OW 300
21364: AND
21365: IFFALSE 21377
// SetLives ( kozlov_fac , 0 ) ;
21367: LD_INT 332
21369: PPUSH
21370: LD_INT 0
21372: PPUSH
21373: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
21377: LD_INT 332
21379: PPUSH
21380: CALL_OW 301
21384: PUSH
21385: LD_EXP 55
21389: PPUSH
21390: CALL_OW 301
21394: OR
21395: IFFALSE 21338
// game_speed := 4 ;
21397: LD_ADDR_OWVAR 65
21401: PUSH
21402: LD_INT 4
21404: ST_TO_ADDR
// powellCenterCameraMode := false ;
21405: LD_ADDR_EXP 20
21409: PUSH
21410: LD_INT 0
21412: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21413: LD_ADDR_VAR 0 1
21417: PUSH
21418: LD_VAR 0 3
21422: PUSH
21423: LD_INT 22
21425: PUSH
21426: LD_INT 8
21428: PUSH
21429: EMPTY
21430: LIST
21431: LIST
21432: PUSH
21433: LD_INT 25
21435: PUSH
21436: LD_INT 2
21438: PUSH
21439: EMPTY
21440: LIST
21441: LIST
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: PPUSH
21447: CALL_OW 69
21451: UNION
21452: PUSH
21453: FOR_IN
21454: IFFALSE 21470
// SetTag ( i , 0 ) ;
21456: LD_VAR 0 1
21460: PPUSH
21461: LD_INT 0
21463: PPUSH
21464: CALL_OW 109
21468: GO 21453
21470: POP
21471: POP
// wait ( 0 0$3 ) ;
21472: LD_INT 105
21474: PPUSH
21475: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
21479: LD_INT 93
21481: PPUSH
21482: LD_INT 35
21484: PPUSH
21485: LD_INT 1
21487: PPUSH
21488: CALL_OW 331
// DialogueOn ;
21492: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
21496: LD_VAR 0 11
21500: PPUSH
21501: LD_STRING D6c-Sol3-1
21503: PPUSH
21504: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
21508: LD_INT 10
21510: PPUSH
21511: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
21515: LD_EXP 36
21519: PPUSH
21520: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
21524: LD_EXP 36
21528: PPUSH
21529: LD_STRING D6c-JMM-1
21531: PPUSH
21532: CALL_OW 88
// if Cyrus then
21536: LD_EXP 42
21540: IFFALSE 21554
// Say ( Cyrus , D6c-Cyrus-1 ) ;
21542: LD_EXP 42
21546: PPUSH
21547: LD_STRING D6c-Cyrus-1
21549: PPUSH
21550: CALL_OW 88
// if Bobby then
21554: LD_EXP 41
21558: IFFALSE 21572
// Say ( Bobby , D6c-Bobby-1 ) ;
21560: LD_EXP 41
21564: PPUSH
21565: LD_STRING D6c-Bobby-1
21567: PPUSH
21568: CALL_OW 88
// if Cornel then
21572: LD_EXP 47
21576: IFFALSE 21590
// Say ( Cornel , D6c-Corn-1 ) ;
21578: LD_EXP 47
21582: PPUSH
21583: LD_STRING D6c-Corn-1
21585: PPUSH
21586: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
21590: LD_ADDR_VAR 0 4
21594: PUSH
21595: LD_INT 2
21597: PUSH
21598: LD_INT 22
21600: PUSH
21601: LD_INT 1
21603: PUSH
21604: EMPTY
21605: LIST
21606: LIST
21607: PUSH
21608: LD_INT 22
21610: PUSH
21611: LD_INT 4
21613: PUSH
21614: EMPTY
21615: LIST
21616: LIST
21617: PUSH
21618: EMPTY
21619: LIST
21620: LIST
21621: LIST
21622: PUSH
21623: LD_INT 26
21625: PUSH
21626: LD_INT 1
21628: PUSH
21629: EMPTY
21630: LIST
21631: LIST
21632: PUSH
21633: LD_INT 3
21635: PUSH
21636: LD_INT 25
21638: PUSH
21639: LD_INT 16
21641: PUSH
21642: EMPTY
21643: LIST
21644: LIST
21645: PUSH
21646: LD_INT 25
21648: PUSH
21649: LD_INT 12
21651: PUSH
21652: EMPTY
21653: LIST
21654: LIST
21655: PUSH
21656: EMPTY
21657: LIST
21658: LIST
21659: LIST
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: LIST
21665: PPUSH
21666: CALL_OW 69
21670: PUSH
21671: LD_VAR 0 11
21675: PUSH
21676: LD_EXP 36
21680: UNION
21681: PUSH
21682: LD_EXP 56
21686: UNION
21687: PUSH
21688: EMPTY
21689: LIST
21690: DIFF
21691: ST_TO_ADDR
// if tmp2 then
21692: LD_VAR 0 4
21696: IFFALSE 21714
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
21698: LD_VAR 0 4
21702: PUSH
21703: LD_INT 1
21705: ARRAY
21706: PPUSH
21707: LD_STRING D6c-Sol1-1
21709: PPUSH
21710: CALL_OW 88
// if Lisa then
21714: LD_EXP 39
21718: IFFALSE 21732
// Say ( Lisa , D6c-Lisa-1 ) ;
21720: LD_EXP 39
21724: PPUSH
21725: LD_STRING D6c-Lisa-1
21727: PPUSH
21728: CALL_OW 88
// if Gary then
21732: LD_EXP 48
21736: IFFALSE 21750
// Say ( Gary , D6c-Gary-1 ) ;
21738: LD_EXP 48
21742: PPUSH
21743: LD_STRING D6c-Gary-1
21745: PPUSH
21746: CALL_OW 88
// if Donaldson then
21750: LD_EXP 40
21754: IFFALSE 21768
// Say ( Donaldson , D6c-Don-1 ) ;
21756: LD_EXP 40
21760: PPUSH
21761: LD_STRING D6c-Don-1
21763: PPUSH
21764: CALL_OW 88
// if tmp2 > 1 then
21768: LD_VAR 0 4
21772: PUSH
21773: LD_INT 1
21775: GREATER
21776: IFFALSE 21794
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
21778: LD_VAR 0 4
21782: PUSH
21783: LD_INT 2
21785: ARRAY
21786: PPUSH
21787: LD_STRING D6c-Sol2-1
21789: PPUSH
21790: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
21794: LD_VAR 0 11
21798: PPUSH
21799: LD_STRING D6c-Sol3-2
21801: PPUSH
21802: CALL_OW 88
// dwait ( 0 0$1 ) ;
21806: LD_INT 35
21808: PPUSH
21809: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
21813: LD_EXP 36
21817: PPUSH
21818: LD_STRING D6c-JMM-2
21820: PPUSH
21821: CALL_OW 88
// DialogueOff ;
21825: CALL_OW 7
// Video ( false ) ;
21829: LD_INT 0
21831: PPUSH
21832: CALL 101720 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
21836: LD_INT 22
21838: PUSH
21839: LD_INT 4
21841: PUSH
21842: EMPTY
21843: LIST
21844: LIST
21845: PPUSH
21846: CALL_OW 69
21850: PPUSH
21851: LD_INT 1
21853: PPUSH
21854: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
21858: LD_INT 4
21860: PPUSH
21861: LD_INT 4
21863: PPUSH
21864: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
21868: LD_ADDR_VAR 0 1
21872: PUSH
21873: LD_INT 4
21875: PPUSH
21876: LD_INT 1
21878: PPUSH
21879: LD_INT 2
21881: PPUSH
21882: CALL 59495 0 3
21886: PUSH
21887: FOR_IN
21888: IFFALSE 21925
// if GetTech ( i , 1 ) <> state_researched then
21890: LD_VAR 0 1
21894: PPUSH
21895: LD_INT 1
21897: PPUSH
21898: CALL_OW 321
21902: PUSH
21903: LD_INT 2
21905: NONEQUAL
21906: IFFALSE 21923
// SetTech ( i , 1 , state_researched ) ;
21908: LD_VAR 0 1
21912: PPUSH
21913: LD_INT 1
21915: PPUSH
21916: LD_INT 2
21918: PPUSH
21919: CALL_OW 322
21923: GO 21887
21925: POP
21926: POP
// missionStage := 6 ;
21927: LD_ADDR_EXP 15
21931: PUSH
21932: LD_INT 6
21934: ST_TO_ADDR
// activeAttacks := true ;
21935: LD_ADDR_EXP 16
21939: PUSH
21940: LD_INT 1
21942: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
21943: LD_STRING M2
21945: PPUSH
21946: CALL_OW 337
// SaveForQuickRestart ;
21950: CALL_OW 22
// wait ( 0 0$40 ) ;
21954: LD_INT 1400
21956: PPUSH
21957: CALL_OW 67
// DialogueOn ;
21961: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
21965: LD_EXP 59
21969: PPUSH
21970: LD_STRING D7-Friend-1
21972: PPUSH
21973: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
21977: LD_EXP 36
21981: PPUSH
21982: LD_STRING D7-JMM-1
21984: PPUSH
21985: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
21989: LD_EXP 59
21993: PPUSH
21994: LD_STRING D7-Friend-2
21996: PPUSH
21997: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
22001: LD_EXP 36
22005: PPUSH
22006: LD_STRING D7-JMM-2
22008: PPUSH
22009: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
22013: LD_EXP 59
22017: PPUSH
22018: LD_STRING D7-Friend-3
22020: PPUSH
22021: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
22025: LD_EXP 36
22029: PPUSH
22030: LD_STRING D7-JMM-3
22032: PPUSH
22033: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
22037: LD_EXP 59
22041: PPUSH
22042: LD_STRING D7-Friend-4
22044: PPUSH
22045: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
22049: LD_EXP 36
22053: PPUSH
22054: LD_STRING D7-JMM-4
22056: PPUSH
22057: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
22061: LD_EXP 59
22065: PPUSH
22066: LD_STRING D7-Friend-5
22068: PPUSH
22069: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
22073: LD_EXP 36
22077: PPUSH
22078: LD_STRING D7-JMM-5
22080: PPUSH
22081: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
22085: LD_EXP 59
22089: PPUSH
22090: LD_STRING D7-Friend-6
22092: PPUSH
22093: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
22097: LD_EXP 36
22101: PPUSH
22102: LD_STRING D7-JMM-6
22104: PPUSH
22105: CALL_OW 88
// DialogueOff ;
22109: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
22113: LD_STRING Mlegion
22115: PPUSH
22116: CALL_OW 337
// RebuildKozlovFactory ;
22120: CALL 4332 0 0
// end ;
22124: PPOPN 13
22126: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
22127: LD_EXP 20
22131: PUSH
22132: LD_EXP 55
22136: PPUSH
22137: CALL_OW 300
22141: AND
22142: IFFALSE 22184
22144: GO 22146
22146: DISABLE
// begin enable ;
22147: ENABLE
// if IsInUnit ( Powell ) then
22148: LD_EXP 55
22152: PPUSH
22153: CALL_OW 310
22157: IFFALSE 22175
// CenterOnUnits ( IsInUnit ( Powell ) ) else
22159: LD_EXP 55
22163: PPUSH
22164: CALL_OW 310
22168: PPUSH
22169: CALL_OW 85
22173: GO 22184
// CenterOnUnits ( Powell ) ;
22175: LD_EXP 55
22179: PPUSH
22180: CALL_OW 85
// end ;
22184: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
22185: LD_INT 22
22187: PUSH
22188: LD_INT 8
22190: PUSH
22191: EMPTY
22192: LIST
22193: LIST
22194: PUSH
22195: LD_INT 34
22197: PUSH
22198: LD_INT 48
22200: PUSH
22201: EMPTY
22202: LIST
22203: LIST
22204: PUSH
22205: EMPTY
22206: LIST
22207: LIST
22208: PPUSH
22209: CALL_OW 69
22213: IFFALSE 22476
22215: GO 22217
22217: DISABLE
22218: LD_INT 0
22220: PPUSH
22221: PPUSH
// begin if missionStage < 9 then
22222: LD_EXP 15
22226: PUSH
22227: LD_INT 9
22229: LESS
22230: IFFALSE 22240
// missionStage := 9 ;
22232: LD_ADDR_EXP 15
22236: PUSH
22237: LD_INT 9
22239: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
22240: LD_ADDR_VAR 0 1
22244: PUSH
22245: LD_INT 22
22247: PUSH
22248: LD_INT 8
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: PUSH
22255: LD_INT 34
22257: PUSH
22258: LD_INT 48
22260: PUSH
22261: EMPTY
22262: LIST
22263: LIST
22264: PUSH
22265: EMPTY
22266: LIST
22267: LIST
22268: PPUSH
22269: CALL_OW 69
22273: PUSH
22274: LD_INT 1
22276: ARRAY
22277: ST_TO_ADDR
// wait ( 0 0$05 ) ;
22278: LD_INT 175
22280: PPUSH
22281: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
22285: LD_EXP 12
22289: PUSH
22290: LD_EXP 3
22294: PUSH
22295: LD_INT 0
22297: PUSH
22298: LD_INT 2
22300: PUSH
22301: EMPTY
22302: LIST
22303: LIST
22304: IN
22305: OR
22306: IFFALSE 22329
// target := [ 68 , 108 , 1 ] else
22308: LD_ADDR_VAR 0 2
22312: PUSH
22313: LD_INT 68
22315: PUSH
22316: LD_INT 108
22318: PUSH
22319: LD_INT 1
22321: PUSH
22322: EMPTY
22323: LIST
22324: LIST
22325: LIST
22326: ST_TO_ADDR
22327: GO 22348
// target := [ 181 , 88 , 2 ] ;
22329: LD_ADDR_VAR 0 2
22333: PUSH
22334: LD_INT 181
22336: PUSH
22337: LD_INT 88
22339: PUSH
22340: LD_INT 2
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: LIST
22347: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
22348: LD_VAR 0 1
22352: PPUSH
22353: LD_VAR 0 2
22357: PUSH
22358: LD_INT 1
22360: ARRAY
22361: PPUSH
22362: LD_VAR 0 2
22366: PUSH
22367: LD_INT 2
22369: ARRAY
22370: PPUSH
22371: CALL_OW 176
// if target [ 3 ] = 1 then
22375: LD_VAR 0 2
22379: PUSH
22380: LD_INT 3
22382: ARRAY
22383: PUSH
22384: LD_INT 1
22386: EQUAL
22387: IFFALSE 22403
// SayRadio ( Kurt , D12-Kurt-1 ) else
22389: LD_EXP 57
22393: PPUSH
22394: LD_STRING D12-Kurt-1
22396: PPUSH
22397: CALL_OW 94
22401: GO 22427
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
22403: LD_EXP 57
22407: PPUSH
22408: LD_STRING D12a-Kurt-1
22410: PPUSH
22411: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
22415: LD_EXP 71
22419: PPUSH
22420: LD_STRING D12a-Roth-1
22422: PPUSH
22423: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
22427: LD_INT 350
22429: PPUSH
22430: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
22434: LD_VAR 0 1
22438: PPUSH
22439: LD_INT 22
22441: PUSH
22442: LD_INT 8
22444: PUSH
22445: EMPTY
22446: LIST
22447: LIST
22448: PUSH
22449: LD_INT 30
22451: PUSH
22452: LD_INT 3
22454: PUSH
22455: EMPTY
22456: LIST
22457: LIST
22458: PUSH
22459: EMPTY
22460: LIST
22461: LIST
22462: PPUSH
22463: CALL_OW 69
22467: PUSH
22468: LD_INT 1
22470: ARRAY
22471: PPUSH
22472: CALL_OW 228
// end ;
22476: PPOPN 2
22478: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
22479: LD_INT 22
22481: PUSH
22482: LD_INT 8
22484: PUSH
22485: EMPTY
22486: LIST
22487: LIST
22488: PUSH
22489: LD_INT 21
22491: PUSH
22492: LD_INT 1
22494: PUSH
22495: EMPTY
22496: LIST
22497: LIST
22498: PUSH
22499: LD_INT 23
22501: PUSH
22502: LD_INT 2
22504: PUSH
22505: EMPTY
22506: LIST
22507: LIST
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: LIST
22513: PPUSH
22514: CALL_OW 69
22518: PUSH
22519: LD_INT 8
22521: PUSH
22522: LD_INT 7
22524: PUSH
22525: LD_INT 6
22527: PUSH
22528: EMPTY
22529: LIST
22530: LIST
22531: LIST
22532: PUSH
22533: LD_OWVAR 67
22537: ARRAY
22538: LESSEQUAL
22539: PUSH
22540: LD_INT 22
22542: PUSH
22543: LD_INT 8
22545: PUSH
22546: EMPTY
22547: LIST
22548: LIST
22549: PUSH
22550: LD_INT 34
22552: PUSH
22553: LD_INT 48
22555: PUSH
22556: EMPTY
22557: LIST
22558: LIST
22559: PUSH
22560: EMPTY
22561: LIST
22562: LIST
22563: PPUSH
22564: CALL_OW 69
22568: NOT
22569: AND
22570: PUSH
22571: LD_EXP 57
22575: PPUSH
22576: CALL_OW 302
22580: AND
22581: IFFALSE 22898
22583: GO 22585
22585: DISABLE
// begin DialogueOn ;
22586: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
22590: LD_EXP 36
22594: PPUSH
22595: LD_STRING D13-JMM-1
22597: PPUSH
22598: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
22602: LD_EXP 57
22606: PPUSH
22607: LD_STRING D13-Kurt-1
22609: PPUSH
22610: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
22614: LD_EXP 36
22618: PPUSH
22619: LD_STRING D13-JMM-2
22621: PPUSH
22622: CALL_OW 88
// if FakeInfo then
22626: LD_EXP 12
22630: IFFALSE 22650
// begin Say ( Kurt , D13-Kurt-2 ) ;
22632: LD_EXP 57
22636: PPUSH
22637: LD_STRING D13-Kurt-2
22639: PPUSH
22640: CALL_OW 88
// DialogueOff ;
22644: CALL_OW 7
// exit ;
22648: GO 22898
// end ; if not KurtStatus then
22650: LD_EXP 3
22654: NOT
22655: IFFALSE 22671
// Say ( Kurt , D13-Kurt-2b ) else
22657: LD_EXP 57
22661: PPUSH
22662: LD_STRING D13-Kurt-2b
22664: PPUSH
22665: CALL_OW 88
22669: GO 22683
// Say ( Kurt , D13-Kurt-2a ) ;
22671: LD_EXP 57
22675: PPUSH
22676: LD_STRING D13-Kurt-2a
22678: PPUSH
22679: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
22683: LD_EXP 57
22687: PPUSH
22688: LD_STRING D13-Kurt-2a
22690: PPUSH
22691: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
22695: LD_EXP 36
22699: PPUSH
22700: LD_STRING D13-JMM-3
22702: PPUSH
22703: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
22707: LD_EXP 57
22711: PPUSH
22712: LD_STRING D13-Kurt-3
22714: PPUSH
22715: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
22719: LD_EXP 36
22723: PPUSH
22724: LD_STRING D13-JMM-4
22726: PPUSH
22727: CALL_OW 88
// DialogueOff ;
22731: CALL_OW 7
// MC_Kill ( 3 ) ;
22735: LD_INT 3
22737: PPUSH
22738: CALL 31781 0 1
// KillUnit ( Kozlov ) ;
22742: LD_EXP 58
22746: PPUSH
22747: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
22751: LD_INT 22
22753: PUSH
22754: LD_INT 8
22756: PUSH
22757: EMPTY
22758: LIST
22759: LIST
22760: PUSH
22761: LD_INT 21
22763: PUSH
22764: LD_INT 3
22766: PUSH
22767: EMPTY
22768: LIST
22769: LIST
22770: PUSH
22771: LD_INT 23
22773: PUSH
22774: LD_INT 3
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: PUSH
22781: LD_INT 30
22783: PUSH
22784: LD_INT 3
22786: PUSH
22787: EMPTY
22788: LIST
22789: LIST
22790: PUSH
22791: EMPTY
22792: LIST
22793: LIST
22794: LIST
22795: LIST
22796: PPUSH
22797: CALL_OW 69
22801: PUSH
22802: LD_INT 1
22804: ARRAY
22805: PPUSH
22806: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
22810: LD_INT 8
22812: PPUSH
22813: LD_INT 1
22815: PPUSH
22816: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
22820: LD_INT 22
22822: PUSH
22823: LD_INT 8
22825: PUSH
22826: EMPTY
22827: LIST
22828: LIST
22829: PPUSH
22830: CALL_OW 69
22834: PPUSH
22835: LD_INT 1
22837: PPUSH
22838: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
22842: LD_INT 8
22844: PPUSH
22845: LD_INT 1
22847: PPUSH
22848: LD_INT 1
22850: PPUSH
22851: LD_INT 1
22853: PPUSH
22854: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
22858: LD_EXP 59
22862: PPUSH
22863: LD_INT 37
22865: PPUSH
22866: LD_INT 1
22868: PPUSH
22869: LD_INT 0
22871: PPUSH
22872: CALL_OW 48
// wait ( 0 0$1 ) ;
22876: LD_INT 35
22878: PPUSH
22879: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
22883: LD_EXP 59
22887: PPUSH
22888: LD_INT 60
22890: PPUSH
22891: LD_INT 95
22893: PPUSH
22894: CALL_OW 111
// end ;
22898: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
22899: LD_INT 22
22901: PUSH
22902: LD_INT 8
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: LD_INT 21
22911: PUSH
22912: LD_INT 1
22914: PUSH
22915: EMPTY
22916: LIST
22917: LIST
22918: PUSH
22919: EMPTY
22920: LIST
22921: LIST
22922: PPUSH
22923: CALL_OW 69
22927: PUSH
22928: LD_INT 0
22930: EQUAL
22931: IFFALSE 22951
22933: GO 22935
22935: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
22936: LD_STRING MlegionOut
22938: PPUSH
22939: CALL_OW 337
// legionDestroyed := true ;
22943: LD_ADDR_EXP 22
22947: PUSH
22948: LD_INT 1
22950: ST_TO_ADDR
// end ;
22951: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
22952: LD_INT 1
22954: PPUSH
22955: LD_EXP 59
22959: PPUSH
22960: CALL_OW 292
22964: IFFALSE 23264
22966: GO 22968
22968: DISABLE
22969: LD_INT 0
22971: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
22972: LD_EXP 59
22976: PPUSH
22977: CALL_OW 87
// DialogueOn ;
22981: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
22985: LD_EXP 36
22989: PPUSH
22990: LD_STRING D14-JMM-1
22992: PPUSH
22993: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
22997: LD_EXP 59
23001: PPUSH
23002: LD_STRING D14-Friend-1
23004: PPUSH
23005: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
23009: LD_EXP 36
23013: PPUSH
23014: LD_STRING D14-JMM-2
23016: PPUSH
23017: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
23021: LD_EXP 59
23025: PPUSH
23026: LD_STRING D14-Friend-2
23028: PPUSH
23029: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
23033: LD_EXP 36
23037: PPUSH
23038: LD_STRING D14-JMM-3
23040: PPUSH
23041: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
23045: LD_EXP 59
23049: PPUSH
23050: LD_STRING D14-Friend-3
23052: PPUSH
23053: CALL_OW 88
// DialogueOff ;
23057: CALL_OW 7
// dec = Query ( Q14 ) ;
23061: LD_ADDR_VAR 0 1
23065: PUSH
23066: LD_STRING Q14
23068: PPUSH
23069: CALL_OW 97
23073: ST_TO_ADDR
// if dec = 1 then
23074: LD_VAR 0 1
23078: PUSH
23079: LD_INT 1
23081: EQUAL
23082: IFFALSE 23116
// begin DialogueOn ;
23084: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
23088: LD_EXP 36
23092: PPUSH
23093: LD_STRING D14a-JMM-1
23095: PPUSH
23096: CALL_OW 88
// DialogueOff ;
23100: CALL_OW 7
// SetSide ( Friend , 1 ) ;
23104: LD_EXP 59
23108: PPUSH
23109: LD_INT 1
23111: PPUSH
23112: CALL_OW 235
// end ; if dec = 2 then
23116: LD_VAR 0 1
23120: PUSH
23121: LD_INT 2
23123: EQUAL
23124: IFFALSE 23170
// begin DialogueOn ;
23126: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
23130: LD_EXP 36
23134: PPUSH
23135: LD_STRING D14b-JMM-1
23137: PPUSH
23138: CALL_OW 88
// DialogueOff ;
23142: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
23146: LD_EXP 59
23150: PPUSH
23151: LD_INT 9
23153: PPUSH
23154: LD_INT 2
23156: PPUSH
23157: CALL_OW 111
// AddComHold ( Friend ) ;
23161: LD_EXP 59
23165: PPUSH
23166: CALL_OW 200
// end ; if dec = 3 then
23170: LD_VAR 0 1
23174: PUSH
23175: LD_INT 3
23177: EQUAL
23178: IFFALSE 23264
// begin DialogueOn ;
23180: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
23184: LD_EXP 36
23188: PPUSH
23189: LD_STRING D14c-JMM-1
23191: PPUSH
23192: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
23196: LD_EXP 59
23200: PPUSH
23201: LD_STRING D14c-Friend-1
23203: PPUSH
23204: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
23208: LD_EXP 36
23212: PPUSH
23213: LD_STRING D14c-JMM-2
23215: PPUSH
23216: CALL_OW 88
// DialogueOff ;
23220: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
23224: LD_INT 8
23226: PPUSH
23227: LD_INT 1
23229: PPUSH
23230: LD_INT 2
23232: PPUSH
23233: LD_INT 1
23235: PPUSH
23236: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
23240: LD_EXP 59
23244: PPUSH
23245: LD_INT 9
23247: PPUSH
23248: LD_INT 2
23250: PPUSH
23251: CALL_OW 111
// AddComHold ( Friend ) ;
23255: LD_EXP 59
23259: PPUSH
23260: CALL_OW 200
// end ; end ;
23264: PPOPN 1
23266: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
23267: LD_INT 9
23269: PPUSH
23270: LD_INT 2
23272: PPUSH
23273: CALL_OW 428
23277: PUSH
23278: LD_EXP 59
23282: EQUAL
23283: PUSH
23284: LD_EXP 59
23288: PPUSH
23289: CALL_OW 255
23293: PUSH
23294: LD_INT 8
23296: EQUAL
23297: AND
23298: IFFALSE 23312
23300: GO 23302
23302: DISABLE
// RemoveUnit ( Friend ) ;
23303: LD_EXP 59
23307: PPUSH
23308: CALL_OW 64
23312: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
23313: LD_EXP 14
23317: PUSH
23318: LD_INT 31500
23320: GREATEREQUAL
23321: PUSH
23322: LD_EXP 7
23326: AND
23327: PUSH
23328: LD_EXP 2
23332: AND
23333: IFFALSE 23763
23335: GO 23337
23337: DISABLE
23338: LD_INT 0
23340: PPUSH
23341: PPUSH
23342: PPUSH
// begin missionStage := 7 ;
23343: LD_ADDR_EXP 15
23347: PUSH
23348: LD_INT 7
23350: ST_TO_ADDR
// uc_side = 1 ;
23351: LD_ADDR_OWVAR 20
23355: PUSH
23356: LD_INT 1
23358: ST_TO_ADDR
// uc_nation = 1 ;
23359: LD_ADDR_OWVAR 21
23363: PUSH
23364: LD_INT 1
23366: ST_TO_ADDR
// for i = 1 to 5 do
23367: LD_ADDR_VAR 0 1
23371: PUSH
23372: DOUBLE
23373: LD_INT 1
23375: DEC
23376: ST_TO_ADDR
23377: LD_INT 5
23379: PUSH
23380: FOR_TO
23381: IFFALSE 23477
// begin vc_engine = 3 ;
23383: LD_ADDR_OWVAR 39
23387: PUSH
23388: LD_INT 3
23390: ST_TO_ADDR
// vc_control = 3 ;
23391: LD_ADDR_OWVAR 38
23395: PUSH
23396: LD_INT 3
23398: ST_TO_ADDR
// vc_chassis = 3 ;
23399: LD_ADDR_OWVAR 37
23403: PUSH
23404: LD_INT 3
23406: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
23407: LD_ADDR_OWVAR 40
23411: PUSH
23412: LD_INT 5
23414: PUSH
23415: LD_INT 9
23417: PUSH
23418: LD_INT 7
23420: PUSH
23421: EMPTY
23422: LIST
23423: LIST
23424: LIST
23425: PUSH
23426: LD_INT 1
23428: PPUSH
23429: LD_INT 3
23431: PPUSH
23432: CALL_OW 12
23436: ARRAY
23437: ST_TO_ADDR
// veh = CreateVehicle ;
23438: LD_ADDR_VAR 0 2
23442: PUSH
23443: CALL_OW 45
23447: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
23448: LD_VAR 0 2
23452: PPUSH
23453: LD_INT 1
23455: PPUSH
23456: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
23460: LD_VAR 0 2
23464: PPUSH
23465: LD_INT 19
23467: PPUSH
23468: LD_INT 0
23470: PPUSH
23471: CALL_OW 49
// end ;
23475: GO 23380
23477: POP
23478: POP
// vc_engine = 3 ;
23479: LD_ADDR_OWVAR 39
23483: PUSH
23484: LD_INT 3
23486: ST_TO_ADDR
// vc_control = 1 ;
23487: LD_ADDR_OWVAR 38
23491: PUSH
23492: LD_INT 1
23494: ST_TO_ADDR
// vc_chassis = 3 ;
23495: LD_ADDR_OWVAR 37
23499: PUSH
23500: LD_INT 3
23502: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
23503: LD_ADDR_OWVAR 40
23507: PUSH
23508: LD_INT 5
23510: PUSH
23511: LD_INT 9
23513: PUSH
23514: LD_INT 7
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: LIST
23521: PUSH
23522: LD_INT 1
23524: PPUSH
23525: LD_INT 3
23527: PPUSH
23528: CALL_OW 12
23532: ARRAY
23533: ST_TO_ADDR
// vehG = CreateVehicle ;
23534: LD_ADDR_VAR 0 3
23538: PUSH
23539: CALL_OW 45
23543: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
23544: LD_VAR 0 3
23548: PPUSH
23549: LD_INT 1
23551: PPUSH
23552: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
23556: LD_VAR 0 3
23560: PPUSH
23561: LD_INT 19
23563: PPUSH
23564: LD_INT 0
23566: PPUSH
23567: CALL_OW 49
// if JMMGirl = 1 then
23571: LD_EXP 7
23575: PUSH
23576: LD_INT 1
23578: EQUAL
23579: IFFALSE 23635
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
23581: LD_ADDR_EXP 37
23585: PUSH
23586: LD_STRING Joan
23588: PPUSH
23589: LD_INT 1
23591: PPUSH
23592: LD_STRING 14_
23594: PPUSH
23595: CALL 59432 0 3
23599: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
23600: LD_EXP 37
23604: PPUSH
23605: LD_VAR 0 3
23609: PPUSH
23610: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
23614: LD_VAR 0 3
23618: PPUSH
23619: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
23623: LD_EXP 37
23627: PPUSH
23628: LD_STRING D10BW-Joan-1
23630: PPUSH
23631: CALL_OW 94
// end ; if JMMGirl = 2 then
23635: LD_EXP 7
23639: PUSH
23640: LD_INT 2
23642: EQUAL
23643: IFFALSE 23699
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
23645: LD_ADDR_EXP 39
23649: PUSH
23650: LD_STRING Lisa
23652: PPUSH
23653: LD_INT 1
23655: PPUSH
23656: LD_STRING 14_
23658: PPUSH
23659: CALL 59432 0 3
23663: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
23664: LD_EXP 39
23668: PPUSH
23669: LD_VAR 0 3
23673: PPUSH
23674: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
23678: LD_VAR 0 3
23682: PPUSH
23683: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
23687: LD_EXP 39
23691: PPUSH
23692: LD_STRING D10BW-Lisa-1
23694: PPUSH
23695: CALL_OW 94
// end ; if JMMGirl = 3 then
23699: LD_EXP 7
23703: PUSH
23704: LD_INT 3
23706: EQUAL
23707: IFFALSE 23763
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
23709: LD_ADDR_EXP 51
23713: PUSH
23714: LD_STRING Connie
23716: PPUSH
23717: LD_INT 1
23719: PPUSH
23720: LD_STRING 14_
23722: PPUSH
23723: CALL 59432 0 3
23727: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
23728: LD_EXP 51
23732: PPUSH
23733: LD_VAR 0 3
23737: PPUSH
23738: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
23742: LD_VAR 0 3
23746: PPUSH
23747: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
23751: LD_EXP 39
23755: PPUSH
23756: LD_STRING D10BW-Con-1
23758: PPUSH
23759: CALL_OW 94
// end ; end ;
23763: PPOPN 3
23765: END
// every 0 0$1 trigger missionTime >= 30 30$00 do var i , veh , tmp ;
23766: LD_EXP 14
23770: PUSH
23771: LD_INT 63000
23773: GREATEREQUAL
23774: IFFALSE 24186
23776: GO 23778
23778: DISABLE
23779: LD_INT 0
23781: PPUSH
23782: PPUSH
23783: PPUSH
// begin tmp := PrepareStevensSquad ;
23784: LD_ADDR_VAR 0 3
23788: PUSH
23789: CALL 1728 0 0
23793: ST_TO_ADDR
// if not tmp then
23794: LD_VAR 0 3
23798: NOT
23799: IFFALSE 23803
// exit ;
23801: GO 24186
// uc_side := 1 ;
23803: LD_ADDR_OWVAR 20
23807: PUSH
23808: LD_INT 1
23810: ST_TO_ADDR
// uc_nation := 1 ;
23811: LD_ADDR_OWVAR 21
23815: PUSH
23816: LD_INT 1
23818: ST_TO_ADDR
// for i in tmp do
23819: LD_ADDR_VAR 0 1
23823: PUSH
23824: LD_VAR 0 3
23828: PUSH
23829: FOR_IN
23830: IFFALSE 23927
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
23832: LD_INT 3
23834: PPUSH
23835: LD_INT 3
23837: PPUSH
23838: LD_INT 1
23840: PPUSH
23841: LD_INT 5
23843: PUSH
23844: LD_INT 9
23846: PUSH
23847: LD_INT 7
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: LIST
23854: PUSH
23855: LD_INT 1
23857: PPUSH
23858: LD_INT 3
23860: PPUSH
23861: CALL_OW 12
23865: ARRAY
23866: PPUSH
23867: LD_INT 40
23869: PPUSH
23870: CALL 66065 0 5
// veh := CreateVehicle ;
23874: LD_ADDR_VAR 0 2
23878: PUSH
23879: CALL_OW 45
23883: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
23884: LD_VAR 0 2
23888: PPUSH
23889: LD_INT 1
23891: PPUSH
23892: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
23896: LD_VAR 0 2
23900: PPUSH
23901: LD_INT 19
23903: PPUSH
23904: LD_INT 0
23906: PPUSH
23907: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
23911: LD_VAR 0 1
23915: PPUSH
23916: LD_VAR 0 2
23920: PPUSH
23921: CALL_OW 52
// end ;
23925: GO 23829
23927: POP
23928: POP
// missionStage := 8 ;
23929: LD_ADDR_EXP 15
23933: PUSH
23934: LD_INT 8
23936: ST_TO_ADDR
// DialogueOn ;
23937: CALL_OW 6
// if Stevens then
23941: LD_EXP 38
23945: IFFALSE 24059
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
23947: LD_EXP 38
23951: PPUSH
23952: CALL_OW 310
23956: PPUSH
23957: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
23961: LD_EXP 38
23965: PPUSH
23966: LD_STRING D8-Huck-1
23968: PPUSH
23969: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
23973: LD_EXP 36
23977: PPUSH
23978: LD_STRING D8-JMM-1
23980: PPUSH
23981: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
23985: LD_EXP 38
23989: PPUSH
23990: LD_STRING D8-Huck-2
23992: PPUSH
23993: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
23997: LD_EXP 36
24001: PPUSH
24002: LD_STRING D8-JMM-2
24004: PPUSH
24005: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
24009: LD_EXP 38
24013: PPUSH
24014: LD_STRING D8-Huck-3
24016: PPUSH
24017: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
24021: LD_EXP 36
24025: PPUSH
24026: LD_STRING D8-JMM-3
24028: PPUSH
24029: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
24033: LD_EXP 38
24037: PPUSH
24038: LD_STRING D8-Huck-4
24040: PPUSH
24041: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
24045: LD_EXP 36
24049: PPUSH
24050: LD_STRING D8-JMM-4
24052: PPUSH
24053: CALL_OW 88
// end else
24057: GO 24169
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
24059: LD_EXP 52
24063: PPUSH
24064: CALL_OW 310
24068: PPUSH
24069: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
24073: LD_EXP 52
24077: PPUSH
24078: LD_STRING D8-Huck-1
24080: PPUSH
24081: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
24085: LD_EXP 36
24089: PPUSH
24090: LD_STRING D8-JMM-1a
24092: PPUSH
24093: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
24097: LD_EXP 52
24101: PPUSH
24102: LD_STRING D8-Huck-2
24104: PPUSH
24105: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
24109: LD_EXP 36
24113: PPUSH
24114: LD_STRING D8-JMM-2
24116: PPUSH
24117: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
24121: LD_EXP 52
24125: PPUSH
24126: LD_STRING D8-Huck-3
24128: PPUSH
24129: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
24133: LD_EXP 36
24137: PPUSH
24138: LD_STRING D8-JMM-3
24140: PPUSH
24141: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
24145: LD_EXP 52
24149: PPUSH
24150: LD_STRING D8-Huck-4
24152: PPUSH
24153: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
24157: LD_EXP 36
24161: PPUSH
24162: LD_STRING D8-JMM-4
24164: PPUSH
24165: CALL_OW 88
// end ; DialogueOff ;
24169: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
24173: LD_INT 25
24175: PPUSH
24176: LD_INT 1
24178: PPUSH
24179: LD_INT 1
24181: PPUSH
24182: CALL_OW 322
// end ;
24186: PPOPN 3
24188: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
24189: LD_INT 1
24191: PPUSH
24192: LD_EXP 68
24196: PPUSH
24197: CALL_OW 292
24201: IFFALSE 24452
24203: GO 24205
24205: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
24206: LD_EXP 68
24210: PPUSH
24211: CALL_OW 87
// DialogueOn ;
24215: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
24219: LD_EXP 36
24223: PPUSH
24224: LD_STRING D10nB-JMM-1
24226: PPUSH
24227: CALL_OW 88
// if BurlakStatus = 1 then
24231: LD_EXP 9
24235: PUSH
24236: LD_INT 1
24238: EQUAL
24239: IFFALSE 24253
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
24241: LD_EXP 67
24245: PPUSH
24246: LD_STRING D10nB-Vse-1a
24248: PPUSH
24249: CALL_OW 94
// end ; if BurlakStatus = 0 then
24253: LD_EXP 9
24257: PUSH
24258: LD_INT 0
24260: EQUAL
24261: IFFALSE 24275
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
24263: LD_EXP 67
24267: PPUSH
24268: LD_STRING D10nB-Vse-1
24270: PPUSH
24271: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
24275: LD_EXP 36
24279: PPUSH
24280: LD_STRING D10nB-JMM-2
24282: PPUSH
24283: CALL_OW 88
// if KappaStatus then
24287: LD_EXP 2
24291: IFFALSE 24305
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
24293: LD_EXP 67
24297: PPUSH
24298: LD_STRING D10nB-Vse-5a
24300: PPUSH
24301: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
24305: LD_EXP 2
24309: NOT
24310: PUSH
24311: LD_EXP 6
24315: PUSH
24316: LD_INT 0
24318: EQUAL
24319: AND
24320: IFFALSE 24448
// begin if JMMGirl = 1 then
24322: LD_EXP 7
24326: PUSH
24327: LD_INT 1
24329: EQUAL
24330: IFFALSE 24380
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
24332: LD_EXP 67
24336: PPUSH
24337: LD_STRING D10nB-Vse-2
24339: PPUSH
24340: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
24344: LD_EXP 36
24348: PPUSH
24349: LD_STRING D10nB-JMM-3
24351: PPUSH
24352: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
24356: LD_EXP 67
24360: PPUSH
24361: LD_STRING D10nB-Vse-3
24363: PPUSH
24364: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
24368: LD_EXP 36
24372: PPUSH
24373: LD_STRING D10nB-JMM-4
24375: PPUSH
24376: CALL_OW 88
// end ; if JMMGirl = 2 then
24380: LD_EXP 7
24384: PUSH
24385: LD_INT 2
24387: EQUAL
24388: IFFALSE 24414
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
24390: LD_EXP 67
24394: PPUSH
24395: LD_STRING D10nB-Vse-4
24397: PPUSH
24398: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
24402: LD_EXP 36
24406: PPUSH
24407: LD_STRING D10nB-JMM-5
24409: PPUSH
24410: CALL_OW 88
// end ; if JMMGirl = 3 then
24414: LD_EXP 7
24418: PUSH
24419: LD_INT 3
24421: EQUAL
24422: IFFALSE 24448
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
24424: LD_EXP 67
24428: PPUSH
24429: LD_STRING D10nB-Vse-5
24431: PPUSH
24432: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
24436: LD_EXP 36
24440: PPUSH
24441: LD_STRING D10nB-JMM-6
24443: PPUSH
24444: CALL_OW 88
// end ; end ; DialogueOff ;
24448: CALL_OW 7
// end ;
24452: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
24453: LD_EXP 14
24457: PUSH
24458: LD_INT 115500
24460: GREATEREQUAL
24461: IFFALSE 24813
24463: GO 24465
24465: DISABLE
24466: LD_INT 0
24468: PPUSH
// begin missionStage := 10 ;
24469: LD_ADDR_EXP 15
24473: PUSH
24474: LD_INT 10
24476: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
24477: LD_ADDR_VAR 0 1
24481: PUSH
24482: LD_INT 22
24484: PUSH
24485: LD_INT 1
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: LD_INT 26
24494: PUSH
24495: LD_INT 1
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: PUSH
24502: LD_INT 3
24504: PUSH
24505: LD_INT 25
24507: PUSH
24508: LD_INT 12
24510: PUSH
24511: EMPTY
24512: LIST
24513: LIST
24514: PUSH
24515: LD_INT 25
24517: PUSH
24518: LD_INT 16
24520: PUSH
24521: EMPTY
24522: LIST
24523: LIST
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: LIST
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: LIST
24534: PPUSH
24535: CALL_OW 69
24539: PUSH
24540: LD_EXP 36
24544: PUSH
24545: LD_EXP 38
24549: PUSH
24550: LD_EXP 52
24554: PUSH
24555: LD_EXP 39
24559: PUSH
24560: LD_EXP 40
24564: PUSH
24565: LD_EXP 41
24569: PUSH
24570: LD_EXP 42
24574: PUSH
24575: LD_EXP 43
24579: PUSH
24580: LD_EXP 44
24584: PUSH
24585: LD_EXP 45
24589: PUSH
24590: LD_EXP 46
24594: PUSH
24595: LD_EXP 47
24599: PUSH
24600: LD_EXP 48
24604: PUSH
24605: LD_EXP 49
24609: PUSH
24610: LD_EXP 50
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: LIST
24619: LIST
24620: LIST
24621: LIST
24622: LIST
24623: LIST
24624: LIST
24625: LIST
24626: LIST
24627: LIST
24628: LIST
24629: LIST
24630: LIST
24631: DIFF
24632: ST_TO_ADDR
// if not tmp and Brown then
24633: LD_VAR 0 1
24637: NOT
24638: PUSH
24639: LD_EXP 44
24643: AND
24644: IFFALSE 24659
// tmp := [ Brown ] ;
24646: LD_ADDR_VAR 0 1
24650: PUSH
24651: LD_EXP 44
24655: PUSH
24656: EMPTY
24657: LIST
24658: ST_TO_ADDR
// DialogueOn ;
24659: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
24663: LD_VAR 0 1
24667: PUSH
24668: LD_INT 1
24670: ARRAY
24671: PPUSH
24672: LD_STRING D11-Sol1-1
24674: PPUSH
24675: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
24679: LD_EXP 61
24683: PPUSH
24684: LD_STRING D11-Pla-1
24686: PPUSH
24687: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
24691: LD_EXP 62
24695: PPUSH
24696: LD_STRING D11-Kov-1
24698: PPUSH
24699: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
24703: LD_EXP 61
24707: PPUSH
24708: LD_STRING D11-Pla-2
24710: PPUSH
24711: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
24715: LD_VAR 0 1
24719: PUSH
24720: LD_INT 1
24722: ARRAY
24723: PPUSH
24724: LD_STRING D11-Sol1-2
24726: PPUSH
24727: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
24731: LD_EXP 36
24735: PPUSH
24736: LD_STRING D11-JMM-2
24738: PPUSH
24739: CALL_OW 88
// DialogueOff ;
24743: CALL_OW 7
// allowBehemothConstruct := true ;
24747: LD_ADDR_EXP 25
24751: PUSH
24752: LD_INT 1
24754: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
24755: LD_STRING M4
24757: PPUSH
24758: CALL_OW 337
// BuildBehemoths ;
24762: CALL 6314 0 0
// repeat wait ( 15 15$00 ) ;
24766: LD_INT 31500
24768: PPUSH
24769: CALL_OW 67
// if behemothDestroyedBeforeFinish then
24773: LD_EXP 27
24777: IFFALSE 24781
// break ;
24779: GO 24813
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
24781: LD_INT 267
24783: PPUSH
24784: CALL_OW 274
24788: PPUSH
24789: LD_INT 1
24791: PPUSH
24792: CALL_OW 275
24796: PUSH
24797: LD_INT 1000
24799: GREATEREQUAL
24800: IFFALSE 24806
// BuildBehemoths ;
24802: CALL 6314 0 0
// until not behemothBuilders ;
24806: LD_EXP 70
24810: NOT
24811: IFFALSE 24766
// end ;
24813: PPOPN 1
24815: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
24816: LD_EXP 70
24820: NOT
24821: PUSH
24822: LD_EXP 28
24826: NOT
24827: AND
24828: PUSH
24829: LD_EXP 25
24833: AND
24834: IFFALSE 24854
24836: GO 24838
24838: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
24839: LD_STRING M4a
24841: PPUSH
24842: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
24846: LD_ADDR_EXP 27
24850: PUSH
24851: LD_INT 1
24853: ST_TO_ADDR
// end ;
24854: END
// every 0 0$1 trigger behemothDone do
24855: LD_EXP 28
24859: IFFALSE 24871
24861: GO 24863
24863: DISABLE
// ChangeMissionObjectives ( M4b ) ;
24864: LD_STRING M4b
24866: PPUSH
24867: CALL_OW 337
24871: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
24872: LD_EXP 29
24876: NOT
24877: IFFALSE 25073
24879: GO 24881
24881: DISABLE
24882: LD_INT 0
24884: PPUSH
24885: PPUSH
// begin enable ;
24886: ENABLE
// tmp := GetBehemoths ( 3 ) ;
24887: LD_ADDR_VAR 0 1
24891: PUSH
24892: LD_INT 3
24894: PPUSH
24895: CALL 101796 0 1
24899: ST_TO_ADDR
// if not tmp and not behemothDone then
24900: LD_VAR 0 1
24904: NOT
24905: PUSH
24906: LD_EXP 28
24910: NOT
24911: AND
24912: IFFALSE 24948
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
24914: LD_ADDR_VAR 0 1
24918: PUSH
24919: LD_INT 22
24921: PUSH
24922: LD_INT 3
24924: PUSH
24925: EMPTY
24926: LIST
24927: LIST
24928: PUSH
24929: LD_INT 30
24931: PUSH
24932: LD_INT 37
24934: PUSH
24935: EMPTY
24936: LIST
24937: LIST
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PPUSH
24943: CALL_OW 69
24947: ST_TO_ADDR
// if not tmp then
24948: LD_VAR 0 1
24952: NOT
24953: IFFALSE 24957
// exit ;
24955: GO 25073
// for i in tmp do
24957: LD_ADDR_VAR 0 2
24961: PUSH
24962: LD_VAR 0 1
24966: PUSH
24967: FOR_IN
24968: IFFALSE 25071
// if See ( 1 , i ) then
24970: LD_INT 1
24972: PPUSH
24973: LD_VAR 0 2
24977: PPUSH
24978: CALL_OW 292
24982: IFFALSE 25069
// begin if GetType ( i ) = unit_building then
24984: LD_VAR 0 2
24988: PPUSH
24989: CALL_OW 247
24993: PUSH
24994: LD_INT 3
24996: EQUAL
24997: IFFALSE 25035
// begin CenterNowOnUnits ( i ) ;
24999: LD_VAR 0 2
25003: PPUSH
25004: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
25008: LD_EXP 36
25012: PPUSH
25013: LD_STRING D17a-JMM-1
25015: PPUSH
25016: CALL_OW 88
// seeBehemoth := true ;
25020: LD_ADDR_EXP 29
25024: PUSH
25025: LD_INT 1
25027: ST_TO_ADDR
// disable ;
25028: DISABLE
// exit ;
25029: POP
25030: POP
25031: GO 25073
// end else
25033: GO 25069
// begin CenterNowOnUnits ( i ) ;
25035: LD_VAR 0 2
25039: PPUSH
25040: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
25044: LD_EXP 36
25048: PPUSH
25049: LD_STRING D17b-JMM-1
25051: PPUSH
25052: CALL_OW 88
// seeBehemoth := true ;
25056: LD_ADDR_EXP 29
25060: PUSH
25061: LD_INT 1
25063: ST_TO_ADDR
// disable ;
25064: DISABLE
// exit ;
25065: POP
25066: POP
25067: GO 25073
// end ; end ;
25069: GO 24967
25071: POP
25072: POP
// end ;
25073: PPOPN 2
25075: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var bomb , dec , tmp ;
25076: LD_EXP 14
25080: PUSH
25081: LD_INT 115500
25083: GREATEREQUAL
25084: IFFALSE 26257
25086: GO 25088
25088: DISABLE
25089: LD_INT 0
25091: PPUSH
25092: PPUSH
25093: PPUSH
// begin MC_InsertProduceList ( 2 , [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ) ;
25094: LD_INT 2
25096: PPUSH
25097: LD_INT 23
25099: PUSH
25100: LD_INT 3
25102: PUSH
25103: LD_INT 3
25105: PUSH
25106: LD_INT 48
25108: PUSH
25109: EMPTY
25110: LIST
25111: LIST
25112: LIST
25113: LIST
25114: PPUSH
25115: CALL 53537 0 2
// repeat wait ( 0 0$1 ) ;
25119: LD_INT 35
25121: PPUSH
25122: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
25126: LD_INT 22
25128: PUSH
25129: LD_INT 3
25131: PUSH
25132: EMPTY
25133: LIST
25134: LIST
25135: PUSH
25136: LD_INT 34
25138: PUSH
25139: LD_INT 48
25141: PUSH
25142: EMPTY
25143: LIST
25144: LIST
25145: PUSH
25146: EMPTY
25147: LIST
25148: LIST
25149: PPUSH
25150: CALL_OW 69
25154: IFFALSE 25119
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
25156: LD_ADDR_VAR 0 1
25160: PUSH
25161: LD_INT 22
25163: PUSH
25164: LD_INT 3
25166: PUSH
25167: EMPTY
25168: LIST
25169: LIST
25170: PUSH
25171: LD_INT 34
25173: PUSH
25174: LD_INT 48
25176: PUSH
25177: EMPTY
25178: LIST
25179: LIST
25180: PUSH
25181: EMPTY
25182: LIST
25183: LIST
25184: PPUSH
25185: CALL_OW 69
25189: PUSH
25190: LD_INT 1
25192: ARRAY
25193: ST_TO_ADDR
// missionStage := 12 ;
25194: LD_ADDR_EXP 15
25198: PUSH
25199: LD_INT 12
25201: ST_TO_ADDR
// platonovHasBomb := true ;
25202: LD_ADDR_EXP 30
25206: PUSH
25207: LD_INT 1
25209: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
25210: LD_VAR 0 1
25214: PPUSH
25215: LD_INT 181
25217: PPUSH
25218: LD_INT 86
25220: PPUSH
25221: CALL_OW 171
// AddComHold ( bomb ) ;
25225: LD_VAR 0 1
25229: PPUSH
25230: CALL_OW 200
// wait ( 0 0$10 ) ;
25234: LD_INT 350
25236: PPUSH
25237: CALL_OW 67
// DialogueOn ;
25241: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
25245: LD_EXP 61
25249: PPUSH
25250: LD_STRING D15-Pla-1
25252: PPUSH
25253: CALL_OW 94
// dec = Query ( Q15a ) ;
25257: LD_ADDR_VAR 0 2
25261: PUSH
25262: LD_STRING Q15a
25264: PPUSH
25265: CALL_OW 97
25269: ST_TO_ADDR
// if dec = 1 then
25270: LD_VAR 0 2
25274: PUSH
25275: LD_INT 1
25277: EQUAL
25278: IFFALSE 25301
// begin Say ( JMM , D15a-JMM-1 ) ;
25280: LD_EXP 36
25284: PPUSH
25285: LD_STRING D15a-JMM-1
25287: PPUSH
25288: CALL_OW 88
// YouLost ( Surrender ) ;
25292: LD_STRING Surrender
25294: PPUSH
25295: CALL_OW 104
// exit ;
25299: GO 26257
// end ; if dec = 2 then
25301: LD_VAR 0 2
25305: PUSH
25306: LD_INT 2
25308: EQUAL
25309: IFFALSE 25378
// begin Say ( JMM , D15b-JMM-1 ) ;
25311: LD_EXP 36
25315: PPUSH
25316: LD_STRING D15b-JMM-1
25318: PPUSH
25319: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
25323: LD_EXP 61
25327: PPUSH
25328: LD_STRING D15b-Pla-1
25330: PPUSH
25331: CALL_OW 94
// DialogueOff ;
25335: CALL_OW 7
// wait ( 3 3$00 ) ;
25339: LD_INT 6300
25341: PPUSH
25342: CALL_OW 67
// DialogueOn ;
25346: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
25350: LD_EXP 36
25354: PPUSH
25355: LD_STRING D15d-JMM-1a
25357: PPUSH
25358: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
25362: LD_EXP 61
25366: PPUSH
25367: LD_STRING D15d-Pla-1
25369: PPUSH
25370: CALL_OW 94
// DialogueOff ;
25374: CALL_OW 7
// end ; if dec = 3 then
25378: LD_VAR 0 2
25382: PUSH
25383: LD_INT 3
25385: EQUAL
25386: IFFALSE 25440
// begin Say ( JMM , D15c-JMM-1 ) ;
25388: LD_EXP 36
25392: PPUSH
25393: LD_STRING D15c-JMM-1
25395: PPUSH
25396: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
25400: LD_EXP 61
25404: PPUSH
25405: LD_STRING D15c-Pla-1
25407: PPUSH
25408: CALL_OW 94
// DialogueOff ;
25412: CALL_OW 7
// wait ( 0 0$15 ) ;
25416: LD_INT 525
25418: PPUSH
25419: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
25423: LD_VAR 0 1
25427: PPUSH
25428: LD_INT 60
25430: PPUSH
25431: LD_INT 95
25433: PPUSH
25434: CALL_OW 116
// exit ;
25438: GO 26257
// end ; if dec = 4 then
25440: LD_VAR 0 2
25444: PUSH
25445: LD_INT 4
25447: EQUAL
25448: IFFALSE 25478
// begin Say ( JMM , D15d-JMM-1 ) ;
25450: LD_EXP 36
25454: PPUSH
25455: LD_STRING D15d-JMM-1
25457: PPUSH
25458: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
25462: LD_EXP 61
25466: PPUSH
25467: LD_STRING D15d-Pla-1
25469: PPUSH
25470: CALL_OW 94
// DialogueOff ;
25474: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
25478: LD_EXP 59
25482: PPUSH
25483: CALL_OW 302
25487: PUSH
25488: LD_EXP 59
25492: PPUSH
25493: CALL_OW 255
25497: PUSH
25498: LD_INT 1
25500: EQUAL
25501: AND
25502: PUSH
25503: LD_INT 22
25505: PUSH
25506: LD_INT 1
25508: PUSH
25509: EMPTY
25510: LIST
25511: LIST
25512: PUSH
25513: LD_INT 34
25515: PUSH
25516: LD_INT 8
25518: PUSH
25519: EMPTY
25520: LIST
25521: LIST
25522: PUSH
25523: EMPTY
25524: LIST
25525: LIST
25526: PPUSH
25527: CALL_OW 69
25531: NOT
25532: AND
25533: IFFALSE 26158
// begin SetSide ( Friend , 8 ) ;
25535: LD_EXP 59
25539: PPUSH
25540: LD_INT 8
25542: PPUSH
25543: CALL_OW 235
// if IsInUnit ( Friend ) then
25547: LD_EXP 59
25551: PPUSH
25552: CALL_OW 310
25556: IFFALSE 25567
// ComExitBuilding ( Friend ) ;
25558: LD_EXP 59
25562: PPUSH
25563: CALL_OW 122
// if IsDriver ( Friend ) then
25567: LD_EXP 59
25571: PPUSH
25572: CALL 99472 0 1
25576: IFFALSE 25587
// ComExitVehicle ( Friend ) ;
25578: LD_EXP 59
25582: PPUSH
25583: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
25587: LD_EXP 59
25591: PPUSH
25592: LD_INT 9
25594: PPUSH
25595: LD_INT 2
25597: PPUSH
25598: CALL_OW 171
// wait ( 0 0$05 ) ;
25602: LD_INT 175
25604: PPUSH
25605: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25609: LD_EXP 59
25613: PPUSH
25614: CALL_OW 87
// DialogueOn ;
25618: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
25622: LD_EXP 36
25626: PPUSH
25627: LD_STRING D16-JMM-1
25629: PPUSH
25630: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
25634: LD_EXP 59
25638: PPUSH
25639: LD_STRING D16-Friend-1
25641: PPUSH
25642: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
25646: LD_EXP 36
25650: PPUSH
25651: LD_STRING D16-JMM-2
25653: PPUSH
25654: CALL_OW 88
// DialogueOff ;
25658: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25662: LD_EXP 59
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: CALL_OW 235
// ComHold ( Friend ) ;
25674: LD_EXP 59
25678: PPUSH
25679: CALL_OW 140
// wait ( 0 0$20 ) ;
25683: LD_INT 700
25685: PPUSH
25686: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
25690: LD_EXP 59
25694: PPUSH
25695: LD_INT 9
25697: PPUSH
25698: LD_INT 2
25700: PPUSH
25701: CALL_OW 297
25705: PUSH
25706: LD_INT 30
25708: LESS
25709: IFFALSE 25778
// begin SetSide ( Friend , 8 ) ;
25711: LD_EXP 59
25715: PPUSH
25716: LD_INT 8
25718: PPUSH
25719: CALL_OW 235
// if IsInUnit ( Friend ) then
25723: LD_EXP 59
25727: PPUSH
25728: CALL_OW 310
25732: IFFALSE 25743
// ComExitBuilding ( Friend ) ;
25734: LD_EXP 59
25738: PPUSH
25739: CALL_OW 122
// if IsDriver ( Friend ) then
25743: LD_EXP 59
25747: PPUSH
25748: CALL 99472 0 1
25752: IFFALSE 25763
// ComExitVehicle ( Friend ) ;
25754: LD_EXP 59
25758: PPUSH
25759: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
25763: LD_EXP 59
25767: PPUSH
25768: LD_INT 9
25770: PPUSH
25771: LD_INT 2
25773: PPUSH
25774: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
25778: LD_INT 1050
25780: PPUSH
25781: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
25785: LD_INT 22
25787: PUSH
25788: LD_INT 1
25790: PUSH
25791: EMPTY
25792: LIST
25793: LIST
25794: PUSH
25795: LD_INT 34
25797: PUSH
25798: LD_INT 8
25800: PUSH
25801: EMPTY
25802: LIST
25803: LIST
25804: PUSH
25805: EMPTY
25806: LIST
25807: LIST
25808: PPUSH
25809: CALL_OW 69
25813: NOT
25814: IFFALSE 26136
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
25816: LD_ADDR_VAR 0 3
25820: PUSH
25821: LD_INT 22
25823: PUSH
25824: LD_INT 1
25826: PUSH
25827: EMPTY
25828: LIST
25829: LIST
25830: PUSH
25831: LD_INT 26
25833: PUSH
25834: LD_INT 1
25836: PUSH
25837: EMPTY
25838: LIST
25839: LIST
25840: PUSH
25841: LD_INT 3
25843: PUSH
25844: LD_INT 25
25846: PUSH
25847: LD_INT 12
25849: PUSH
25850: EMPTY
25851: LIST
25852: LIST
25853: PUSH
25854: LD_INT 25
25856: PUSH
25857: LD_INT 16
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: EMPTY
25870: LIST
25871: LIST
25872: LIST
25873: PPUSH
25874: CALL_OW 69
25878: PUSH
25879: LD_EXP 36
25883: PUSH
25884: LD_EXP 38
25888: PUSH
25889: LD_EXP 52
25893: PUSH
25894: LD_EXP 39
25898: PUSH
25899: LD_EXP 40
25903: PUSH
25904: LD_EXP 41
25908: PUSH
25909: LD_EXP 42
25913: PUSH
25914: LD_EXP 43
25918: PUSH
25919: LD_EXP 44
25923: PUSH
25924: LD_EXP 45
25928: PUSH
25929: LD_EXP 46
25933: PUSH
25934: LD_EXP 47
25938: PUSH
25939: LD_EXP 48
25943: PUSH
25944: LD_EXP 49
25948: PUSH
25949: LD_EXP 50
25953: PUSH
25954: EMPTY
25955: LIST
25956: LIST
25957: LIST
25958: LIST
25959: LIST
25960: LIST
25961: LIST
25962: LIST
25963: LIST
25964: LIST
25965: LIST
25966: LIST
25967: LIST
25968: LIST
25969: LIST
25970: DIFF
25971: ST_TO_ADDR
// DialogueOn ;
25972: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
25976: LD_EXP 61
25980: PPUSH
25981: LD_STRING D16a-Pla-1
25983: PPUSH
25984: CALL_OW 94
// if Stevens then
25988: LD_EXP 38
25992: IFFALSE 26008
// Say ( Stevens , D16a-Huck-1 ) else
25994: LD_EXP 38
25998: PPUSH
25999: LD_STRING D16a-Huck-1
26001: PPUSH
26002: CALL_OW 88
26006: GO 26050
// if Baker then
26008: LD_EXP 52
26012: IFFALSE 26028
// Say ( Baker , D16a-Huck-1 ) else
26014: LD_EXP 52
26018: PPUSH
26019: LD_STRING D16a-Huck-1
26021: PPUSH
26022: CALL_OW 88
26026: GO 26050
// if tmp then
26028: LD_VAR 0 3
26032: IFFALSE 26050
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
26034: LD_VAR 0 3
26038: PUSH
26039: LD_INT 1
26041: ARRAY
26042: PPUSH
26043: LD_STRING D16a-Sol1-1
26045: PPUSH
26046: CALL_OW 88
// if GetSide ( Friend ) = 8 then
26050: LD_EXP 59
26054: PPUSH
26055: CALL_OW 255
26059: PUSH
26060: LD_INT 8
26062: EQUAL
26063: IFFALSE 26079
// Say ( JMM , D16a-JMM-1 ) else
26065: LD_EXP 36
26069: PPUSH
26070: LD_STRING D16a-JMM-1
26072: PPUSH
26073: CALL_OW 88
26077: GO 26115
// begin Say ( JMM , D16a-JMM-1a ) ;
26079: LD_EXP 36
26083: PPUSH
26084: LD_STRING D16a-JMM-1a
26086: PPUSH
26087: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
26091: LD_EXP 59
26095: PPUSH
26096: LD_STRING D16a-Friend-1
26098: PPUSH
26099: CALL_OW 88
// SetSide ( Friend , 3 ) ;
26103: LD_EXP 59
26107: PPUSH
26108: LD_INT 3
26110: PPUSH
26111: CALL_OW 235
// end ; DialogueOff ;
26115: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
26119: LD_VAR 0 1
26123: PPUSH
26124: LD_INT 60
26126: PPUSH
26127: LD_INT 95
26129: PPUSH
26130: CALL_OW 116
// end else
26134: GO 26156
// begin DialogueOn ;
26136: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
26140: LD_EXP 61
26144: PPUSH
26145: LD_STRING D16c-Pla-
26147: PPUSH
26148: CALL_OW 94
// DialogueOff ;
26152: CALL_OW 7
// end ; end else
26156: GO 26257
// begin wait ( 3 3$00 ) ;
26158: LD_INT 6300
26160: PPUSH
26161: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
26165: LD_INT 22
26167: PUSH
26168: LD_INT 1
26170: PUSH
26171: EMPTY
26172: LIST
26173: LIST
26174: PUSH
26175: LD_INT 34
26177: PUSH
26178: LD_INT 8
26180: PUSH
26181: EMPTY
26182: LIST
26183: LIST
26184: PUSH
26185: EMPTY
26186: LIST
26187: LIST
26188: PPUSH
26189: CALL_OW 69
26193: NOT
26194: IFFALSE 26237
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
26196: LD_EXP 61
26200: PPUSH
26201: LD_STRING D16b-Pla-1
26203: PPUSH
26204: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
26208: LD_EXP 36
26212: PPUSH
26213: LD_STRING D16b-JMM-
26215: PPUSH
26216: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
26220: LD_VAR 0 1
26224: PPUSH
26225: LD_INT 60
26227: PPUSH
26228: LD_INT 95
26230: PPUSH
26231: CALL_OW 116
// end else
26235: GO 26257
// begin DialogueOn ;
26237: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
26241: LD_EXP 61
26245: PPUSH
26246: LD_STRING D16c-Pla-
26248: PPUSH
26249: CALL_OW 94
// DialogueOff ;
26253: CALL_OW 7
// end ; end ; end ;
26257: PPOPN 3
26259: END
// every 0 0$1 trigger missionTime >= 60 60$00 do var dec ;
26260: LD_EXP 14
26264: PUSH
26265: LD_INT 126000
26267: GREATEREQUAL
26268: IFFALSE 26626
26270: GO 26272
26272: DISABLE
26273: LD_INT 0
26275: PPUSH
// begin missionStage = 11 ;
26276: LD_ADDR_EXP 15
26280: PUSH
26281: LD_INT 11
26283: ST_TO_ADDR
// DialogueOn ;
26284: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
26288: LD_EXP 71
26292: PPUSH
26293: LD_STRING D9-Roth-1
26295: PPUSH
26296: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
26300: LD_EXP 36
26304: PPUSH
26305: LD_STRING D9-JMM-1
26307: PPUSH
26308: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
26312: LD_EXP 71
26316: PPUSH
26317: LD_STRING D9-Roth-2
26319: PPUSH
26320: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
26324: LD_EXP 71
26328: PPUSH
26329: LD_STRING D9-Roth-2a
26331: PPUSH
26332: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
26336: LD_EXP 61
26340: PPUSH
26341: LD_STRING D9-Pla-2
26343: PPUSH
26344: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
26348: LD_EXP 71
26352: PPUSH
26353: LD_STRING D9-Roth-3
26355: PPUSH
26356: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
26360: LD_EXP 61
26364: PPUSH
26365: LD_STRING D9-Pla-3
26367: PPUSH
26368: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
26372: LD_EXP 71
26376: PPUSH
26377: LD_STRING D9-Roth-4
26379: PPUSH
26380: CALL_OW 94
// dec = Query ( Q9 ) ;
26384: LD_ADDR_VAR 0 1
26388: PUSH
26389: LD_STRING Q9
26391: PPUSH
26392: CALL_OW 97
26396: ST_TO_ADDR
// if dec = 1 then
26397: LD_VAR 0 1
26401: PUSH
26402: LD_INT 1
26404: EQUAL
26405: IFFALSE 26419
// SayRadio ( Roth , D9a-Roth-1 ) ;
26407: LD_EXP 71
26411: PPUSH
26412: LD_STRING D9a-Roth-1
26414: PPUSH
26415: CALL_OW 94
// if dec = 2 then
26419: LD_VAR 0 1
26423: PUSH
26424: LD_INT 2
26426: EQUAL
26427: IFFALSE 26453
// begin Say ( JMM , D9b-JMM-1 ) ;
26429: LD_EXP 36
26433: PPUSH
26434: LD_STRING D9b-JMM-1
26436: PPUSH
26437: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
26441: LD_EXP 71
26445: PPUSH
26446: LD_STRING D9b-Roth-1
26448: PPUSH
26449: CALL_OW 94
// end ; if dec = 3 then
26453: LD_VAR 0 1
26457: PUSH
26458: LD_INT 3
26460: EQUAL
26461: IFFALSE 26523
// begin Say ( JMM , D9c-JMM-1 ) ;
26463: LD_EXP 36
26467: PPUSH
26468: LD_STRING D9c-JMM-1
26470: PPUSH
26471: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
26475: LD_EXP 71
26479: PPUSH
26480: LD_STRING D9c-Roth-1
26482: PPUSH
26483: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
26487: LD_EXP 36
26491: PPUSH
26492: LD_STRING D9c-JMM-2
26494: PPUSH
26495: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
26499: LD_EXP 71
26503: PPUSH
26504: LD_STRING D9c-Roth-2
26506: PPUSH
26507: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
26511: LD_EXP 36
26515: PPUSH
26516: LD_STRING D9c-JMM-3
26518: PPUSH
26519: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
26523: LD_EXP 71
26527: PPUSH
26528: LD_STRING D9c-Roth-3
26530: PPUSH
26531: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
26535: LD_EXP 71
26539: PPUSH
26540: LD_STRING D9cont-Roth-1
26542: PPUSH
26543: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
26547: LD_EXP 36
26551: PPUSH
26552: LD_STRING D9cont-JMM-1
26554: PPUSH
26555: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
26559: LD_EXP 71
26563: PPUSH
26564: LD_STRING D9cont-Roth-2
26566: PPUSH
26567: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
26571: LD_EXP 36
26575: PPUSH
26576: LD_STRING D9cont-JMM-2
26578: PPUSH
26579: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
26583: LD_EXP 71
26587: PPUSH
26588: LD_STRING D9cont-Roth-3
26590: PPUSH
26591: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
26595: LD_EXP 36
26599: PPUSH
26600: LD_STRING D9cont-JMM-3
26602: PPUSH
26603: CALL_OW 88
// DialogueOff ;
26607: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
26611: LD_STRING M3
26613: PPUSH
26614: CALL_OW 337
// allianceActive := true ;
26618: LD_ADDR_EXP 31
26622: PUSH
26623: LD_INT 1
26625: ST_TO_ADDR
// end ;
26626: PPOPN 1
26628: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
26629: LD_EXP 61
26633: PPUSH
26634: CALL_OW 301
26638: PUSH
26639: LD_EXP 64
26643: PPUSH
26644: CALL_OW 301
26648: AND
26649: PUSH
26650: LD_INT 22
26652: PUSH
26653: LD_INT 3
26655: PUSH
26656: EMPTY
26657: LIST
26658: LIST
26659: PUSH
26660: LD_INT 21
26662: PUSH
26663: LD_INT 1
26665: PUSH
26666: EMPTY
26667: LIST
26668: LIST
26669: PUSH
26670: LD_INT 50
26672: PUSH
26673: EMPTY
26674: LIST
26675: PUSH
26676: EMPTY
26677: LIST
26678: LIST
26679: LIST
26680: PPUSH
26681: CALL_OW 69
26685: PUSH
26686: LD_INT 7
26688: PUSH
26689: LD_INT 8
26691: PUSH
26692: LD_INT 9
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: LIST
26699: PUSH
26700: LD_OWVAR 67
26704: ARRAY
26705: LESS
26706: AND
26707: IFFALSE 27466
26709: GO 26711
26711: DISABLE
26712: LD_INT 0
26714: PPUSH
26715: PPUSH
26716: PPUSH
26717: PPUSH
// begin MC_Kill ( 1 ) ;
26718: LD_INT 1
26720: PPUSH
26721: CALL 31781 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
26725: LD_INT 1
26727: PPUSH
26728: LD_INT 3
26730: PPUSH
26731: LD_INT 1
26733: PPUSH
26734: LD_INT 1
26736: PPUSH
26737: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
26741: LD_ADDR_VAR 0 1
26745: PUSH
26746: LD_INT 22
26748: PUSH
26749: LD_INT 3
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: PUSH
26756: LD_INT 21
26758: PUSH
26759: LD_INT 1
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PUSH
26766: LD_INT 24
26768: PUSH
26769: LD_INT 900
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: PUSH
26776: EMPTY
26777: LIST
26778: LIST
26779: LIST
26780: PPUSH
26781: CALL_OW 69
26785: PUSH
26786: FOR_IN
26787: IFFALSE 26818
// if GetSex ( i ) = sex_male then
26789: LD_VAR 0 1
26793: PPUSH
26794: CALL_OW 258
26798: PUSH
26799: LD_INT 1
26801: EQUAL
26802: IFFALSE 26816
// begin tmp = i ;
26804: LD_ADDR_VAR 0 2
26808: PUSH
26809: LD_VAR 0 1
26813: ST_TO_ADDR
// break ;
26814: GO 26818
// end ;
26816: GO 26786
26818: POP
26819: POP
// if tmp = 0 then
26820: LD_VAR 0 2
26824: PUSH
26825: LD_INT 0
26827: EQUAL
26828: IFFALSE 26882
// begin uc_side = 3 ;
26830: LD_ADDR_OWVAR 20
26834: PUSH
26835: LD_INT 3
26837: ST_TO_ADDR
// uc_nation = 3 ;
26838: LD_ADDR_OWVAR 21
26842: PUSH
26843: LD_INT 3
26845: ST_TO_ADDR
// hc_name =  ;
26846: LD_ADDR_OWVAR 26
26850: PUSH
26851: LD_STRING 
26853: ST_TO_ADDR
// hc_gallery =  ;
26854: LD_ADDR_OWVAR 33
26858: PUSH
26859: LD_STRING 
26861: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
26862: LD_INT 1
26864: PPUSH
26865: LD_INT 10
26867: PPUSH
26868: CALL_OW 381
// tmp = CreateHuman ;
26872: LD_ADDR_VAR 0 2
26876: PUSH
26877: CALL_OW 44
26881: ST_TO_ADDR
// end ; DialogueOn ;
26882: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
26886: LD_VAR 0 2
26890: PPUSH
26891: LD_STRING DSurrenderRussians-RSol1-1a
26893: PPUSH
26894: CALL_OW 88
// DialogueOff ;
26898: CALL_OW 7
// russianDestroyed := true ;
26902: LD_ADDR_EXP 21
26906: PUSH
26907: LD_INT 1
26909: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
26910: LD_INT 22
26912: PUSH
26913: LD_INT 3
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 21
26922: PUSH
26923: LD_INT 1
26925: PUSH
26926: EMPTY
26927: LIST
26928: LIST
26929: PUSH
26930: EMPTY
26931: LIST
26932: LIST
26933: PPUSH
26934: CALL_OW 69
26938: PPUSH
26939: CALL_OW 122
// wait ( 0 0$1 ) ;
26943: LD_INT 35
26945: PPUSH
26946: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
26950: LD_INT 22
26952: PUSH
26953: LD_INT 3
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 21
26962: PUSH
26963: LD_INT 1
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PPUSH
26974: CALL_OW 69
26978: PPUSH
26979: LD_INT 25
26981: PPUSH
26982: CALL_OW 173
// wait ( 0 0$10 ) ;
26986: LD_INT 350
26988: PPUSH
26989: CALL_OW 67
// PrepareOmarInvasion ;
26993: CALL 12018 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
26997: LD_ADDR_VAR 0 2
27001: PUSH
27002: LD_EXP 89
27006: PPUSH
27007: CALL_OW 250
27011: PUSH
27012: LD_EXP 89
27016: PPUSH
27017: CALL_OW 251
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
27026: LD_VAR 0 2
27030: PUSH
27031: LD_INT 1
27033: ARRAY
27034: PPUSH
27035: LD_VAR 0 2
27039: PUSH
27040: LD_INT 2
27042: ARRAY
27043: PPUSH
27044: LD_INT 1
27046: PPUSH
27047: LD_INT 8
27049: NEG
27050: PPUSH
27051: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
27055: LD_EXP 89
27059: PPUSH
27060: CALL_OW 87
// DialogueOn ;
27064: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
27068: LD_EXP 36
27072: PPUSH
27073: LD_STRING D19-JMM-1
27075: PPUSH
27076: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
27080: LD_ADDR_VAR 0 3
27084: PUSH
27085: LD_INT 22
27087: PUSH
27088: LD_INT 1
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: LD_INT 26
27097: PUSH
27098: LD_INT 1
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 2
27107: PUSH
27108: LD_INT 25
27110: PUSH
27111: LD_INT 1
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: LD_INT 25
27120: PUSH
27121: LD_INT 2
27123: PUSH
27124: EMPTY
27125: LIST
27126: LIST
27127: PUSH
27128: LD_INT 25
27130: PUSH
27131: LD_INT 3
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: LD_INT 25
27140: PUSH
27141: LD_INT 4
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 25
27150: PUSH
27151: LD_INT 5
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 25
27160: PUSH
27161: LD_INT 8
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: LIST
27172: LIST
27173: LIST
27174: LIST
27175: LIST
27176: PUSH
27177: EMPTY
27178: LIST
27179: LIST
27180: LIST
27181: PPUSH
27182: CALL_OW 69
27186: PUSH
27187: LD_EXP 36
27191: PUSH
27192: LD_EXP 37
27196: PUSH
27197: LD_EXP 38
27201: PUSH
27202: LD_EXP 39
27206: PUSH
27207: LD_EXP 40
27211: PUSH
27212: LD_EXP 41
27216: PUSH
27217: LD_EXP 42
27221: PUSH
27222: LD_EXP 43
27226: PUSH
27227: LD_EXP 44
27231: PUSH
27232: LD_EXP 45
27236: PUSH
27237: LD_EXP 46
27241: PUSH
27242: LD_EXP 47
27246: PUSH
27247: LD_EXP 48
27251: PUSH
27252: LD_EXP 49
27256: PUSH
27257: LD_EXP 50
27261: PUSH
27262: LD_EXP 51
27266: PUSH
27267: LD_EXP 52
27271: PUSH
27272: EMPTY
27273: LIST
27274: LIST
27275: LIST
27276: LIST
27277: LIST
27278: LIST
27279: LIST
27280: LIST
27281: LIST
27282: LIST
27283: LIST
27284: LIST
27285: LIST
27286: LIST
27287: LIST
27288: LIST
27289: LIST
27290: DIFF
27291: ST_TO_ADDR
// if tmp2 then
27292: LD_VAR 0 3
27296: IFFALSE 27314
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
27298: LD_VAR 0 3
27302: PUSH
27303: LD_INT 1
27305: ARRAY
27306: PPUSH
27307: LD_STRING D19-Sol1-1
27309: PPUSH
27310: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
27314: LD_EXP 36
27318: PPUSH
27319: LD_STRING D19-JMM-2
27321: PPUSH
27322: CALL_OW 88
// DialogueOff ;
27326: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
27330: LD_VAR 0 2
27334: PUSH
27335: LD_INT 1
27337: ARRAY
27338: PPUSH
27339: LD_VAR 0 2
27343: PUSH
27344: LD_INT 2
27346: ARRAY
27347: PPUSH
27348: LD_INT 1
27350: PPUSH
27351: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
27355: LD_STRING M5
27357: PPUSH
27358: CALL_OW 337
// omarOnMotherLode := false ;
27362: LD_ADDR_VAR 0 4
27366: PUSH
27367: LD_INT 0
27369: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
27370: LD_INT 35
27372: PPUSH
27373: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
27377: LD_EXP 89
27381: PPUSH
27382: LD_INT 215
27384: PPUSH
27385: LD_INT 100
27387: PPUSH
27388: CALL_OW 297
27392: PUSH
27393: LD_INT 10
27395: LESS
27396: PUSH
27397: LD_VAR 0 4
27401: NOT
27402: AND
27403: IFFALSE 27425
// begin omarOnMotherLode := true ;
27405: LD_ADDR_VAR 0 4
27409: PUSH
27410: LD_INT 1
27412: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
27413: LD_EXP 36
27417: PPUSH
27418: LD_STRING D19b-JMM-1
27420: PPUSH
27421: CALL_OW 88
// end ; until IsDead ( Omar ) ;
27425: LD_EXP 89
27429: PPUSH
27430: CALL_OW 301
27434: IFFALSE 27370
// Say ( JMM , D19a-JMM-1 ) ;
27436: LD_EXP 36
27440: PPUSH
27441: LD_STRING D19a-JMM-1
27443: PPUSH
27444: CALL_OW 88
// if Heike then
27448: LD_EXP 90
27452: IFFALSE 27466
// Say ( Heike , D19a-Hke-1 ) ;
27454: LD_EXP 90
27458: PPUSH
27459: LD_STRING D19a-Hke-1
27461: PPUSH
27462: CALL_OW 88
// end ;
27466: PPOPN 4
27468: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
27469: LD_INT 22
27471: PUSH
27472: LD_INT 3
27474: PUSH
27475: EMPTY
27476: LIST
27477: LIST
27478: PUSH
27479: LD_INT 21
27481: PUSH
27482: LD_INT 1
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PUSH
27489: EMPTY
27490: LIST
27491: LIST
27492: PPUSH
27493: CALL_OW 69
27497: PUSH
27498: LD_EXP 21
27502: AND
27503: IFFALSE 27571
27505: GO 27507
27507: DISABLE
27508: LD_INT 0
27510: PPUSH
27511: PPUSH
// begin enable ;
27512: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
27513: LD_ADDR_VAR 0 2
27517: PUSH
27518: LD_INT 25
27520: PPUSH
27521: LD_INT 22
27523: PUSH
27524: LD_INT 3
27526: PUSH
27527: EMPTY
27528: LIST
27529: LIST
27530: PPUSH
27531: CALL_OW 70
27535: ST_TO_ADDR
// if not tmp then
27536: LD_VAR 0 2
27540: NOT
27541: IFFALSE 27545
// exit ;
27543: GO 27571
// for i in tmp do
27545: LD_ADDR_VAR 0 1
27549: PUSH
27550: LD_VAR 0 2
27554: PUSH
27555: FOR_IN
27556: IFFALSE 27569
// RemoveUnit ( i ) ;
27558: LD_VAR 0 1
27562: PPUSH
27563: CALL_OW 64
27567: GO 27555
27569: POP
27570: POP
// end ;
27571: PPOPN 2
27573: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
27574: LD_INT 22
27576: PUSH
27577: LD_INT 7
27579: PUSH
27580: EMPTY
27581: LIST
27582: LIST
27583: PUSH
27584: LD_INT 21
27586: PUSH
27587: LD_INT 1
27589: PUSH
27590: EMPTY
27591: LIST
27592: LIST
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PPUSH
27598: CALL_OW 69
27602: PUSH
27603: LD_INT 6
27605: LESS
27606: IFFALSE 28057
27608: GO 27610
27610: DISABLE
27611: LD_INT 0
27613: PPUSH
27614: PPUSH
// begin MC_Kill ( 1 ) ;
27615: LD_INT 1
27617: PPUSH
27618: CALL 31781 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
27622: LD_INT 7
27624: PPUSH
27625: LD_INT 1
27627: PPUSH
27628: LD_INT 1
27630: PPUSH
27631: LD_INT 1
27633: PPUSH
27634: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
27638: LD_ADDR_VAR 0 1
27642: PUSH
27643: LD_INT 22
27645: PUSH
27646: LD_INT 7
27648: PUSH
27649: EMPTY
27650: LIST
27651: LIST
27652: PUSH
27653: LD_INT 26
27655: PUSH
27656: LD_INT 1
27658: PUSH
27659: EMPTY
27660: LIST
27661: LIST
27662: PUSH
27663: EMPTY
27664: LIST
27665: LIST
27666: PPUSH
27667: CALL_OW 69
27671: PUSH
27672: LD_EXP 71
27676: DIFF
27677: ST_TO_ADDR
// if tmp then
27678: LD_VAR 0 1
27682: IFFALSE 27700
// tmp := tmp [ 1 ] else
27684: LD_ADDR_VAR 0 1
27688: PUSH
27689: LD_VAR 0 1
27693: PUSH
27694: LD_INT 1
27696: ARRAY
27697: ST_TO_ADDR
27698: GO 27736
// begin uc_side := 7 ;
27700: LD_ADDR_OWVAR 20
27704: PUSH
27705: LD_INT 7
27707: ST_TO_ADDR
// uc_nation := 1 ;
27708: LD_ADDR_OWVAR 21
27712: PUSH
27713: LD_INT 1
27715: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
27716: LD_INT 1
27718: PPUSH
27719: LD_INT 8
27721: PPUSH
27722: CALL_OW 384
// tmp := CreateHuman ;
27726: LD_ADDR_VAR 0 1
27730: PUSH
27731: CALL_OW 44
27735: ST_TO_ADDR
// end ; DialogueOn ;
27736: CALL_OW 6
// if IsOK ( Roth ) then
27740: LD_EXP 71
27744: PPUSH
27745: CALL_OW 302
27749: IFFALSE 27763
// Say ( JMM , DAb-JMM-1 ) ;
27751: LD_EXP 36
27755: PPUSH
27756: LD_STRING DAb-JMM-1
27758: PPUSH
27759: CALL_OW 88
// if IsOK ( Roth ) then
27763: LD_EXP 71
27767: PPUSH
27768: CALL_OW 302
27772: IFFALSE 27796
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
27774: LD_EXP 71
27778: PPUSH
27779: LD_STRING DSurrenderAlliance-Roth-1
27781: PPUSH
27782: CALL_OW 88
// RothCaptured := true ;
27786: LD_ADDR_EXP 33
27790: PUSH
27791: LD_INT 1
27793: ST_TO_ADDR
// end else
27794: GO 27808
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
27796: LD_VAR 0 1
27800: PPUSH
27801: LD_STRING DSurrenderAlliance-Sci1-1
27803: PPUSH
27804: CALL_OW 88
// DialogueOff ;
27808: CALL_OW 7
// allianceDestroyed := true ;
27812: LD_ADDR_EXP 23
27816: PUSH
27817: LD_INT 1
27819: ST_TO_ADDR
// if trueAmericans then
27820: LD_EXP 35
27824: IFFALSE 27900
// begin if trueAmericans = 1 then
27826: LD_EXP 35
27830: PUSH
27831: LD_INT 1
27833: EQUAL
27834: IFFALSE 27850
// Say ( JMM , DAb-JMM-1a ) else
27836: LD_EXP 36
27840: PPUSH
27841: LD_STRING DAb-JMM-1a
27843: PPUSH
27844: CALL_OW 88
27848: GO 27862
// Say ( JMM , DAb-JMM-1b ) ;
27850: LD_EXP 36
27854: PPUSH
27855: LD_STRING DAb-JMM-1b
27857: PPUSH
27858: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
27862: LD_EXP 35
27866: PPUSH
27867: CALL_OW 87
// for i in trueAmericans do
27871: LD_ADDR_VAR 0 2
27875: PUSH
27876: LD_EXP 35
27880: PUSH
27881: FOR_IN
27882: IFFALSE 27898
// SetSide ( i , 1 ) ;
27884: LD_VAR 0 2
27888: PPUSH
27889: LD_INT 1
27891: PPUSH
27892: CALL_OW 235
27896: GO 27881
27898: POP
27899: POP
// end ; repeat wait ( 0 0$1 ) ;
27900: LD_INT 35
27902: PPUSH
27903: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
27907: LD_ADDR_VAR 0 2
27911: PUSH
27912: LD_INT 22
27914: PUSH
27915: LD_INT 7
27917: PUSH
27918: EMPTY
27919: LIST
27920: LIST
27921: PUSH
27922: LD_INT 21
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: EMPTY
27929: LIST
27930: LIST
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PPUSH
27936: CALL_OW 69
27940: PUSH
27941: FOR_IN
27942: IFFALSE 28024
// begin if IsInUnit ( i ) then
27944: LD_VAR 0 2
27948: PPUSH
27949: CALL_OW 310
27953: IFFALSE 27964
// ComExitBuilding ( i ) ;
27955: LD_VAR 0 2
27959: PPUSH
27960: CALL_OW 122
// if IsDriver ( i ) then
27964: LD_VAR 0 2
27968: PPUSH
27969: CALL 99472 0 1
27973: IFFALSE 27984
// ComExitVehicle ( i ) ;
27975: LD_VAR 0 2
27979: PPUSH
27980: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
27984: LD_VAR 0 2
27988: PPUSH
27989: LD_INT 26
27991: PPUSH
27992: CALL_OW 308
27996: NOT
27997: IFFALSE 28013
// AddComMoveToArea ( i , allianceEscapeArea ) else
27999: LD_VAR 0 2
28003: PPUSH
28004: LD_INT 26
28006: PPUSH
28007: CALL_OW 173
28011: GO 28022
// RemoveUnit ( i ) ;
28013: LD_VAR 0 2
28017: PPUSH
28018: CALL_OW 64
// end ;
28022: GO 27941
28024: POP
28025: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
28026: LD_INT 22
28028: PUSH
28029: LD_INT 7
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 21
28038: PUSH
28039: LD_INT 1
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: PPUSH
28050: CALL_OW 69
28054: NOT
28055: IFFALSE 27900
// end ;
28057: PPOPN 2
28059: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
28060: LD_INT 0
28062: PPUSH
28063: PPUSH
// if not unit then
28064: LD_VAR 0 1
28068: NOT
28069: IFFALSE 28073
// exit ;
28071: GO 29562
// DoNotAttack ( 8 , unit ) ;
28073: LD_INT 8
28075: PPUSH
28076: LD_VAR 0 1
28080: PPUSH
28081: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
28085: LD_VAR 0 1
28089: PPUSH
28090: LD_INT 260
28092: PPUSH
28093: LD_INT 235
28095: PPUSH
28096: LD_INT 3
28098: PPUSH
28099: LD_INT 1
28101: PPUSH
28102: CALL_OW 483
// SetSide ( unit , 4 ) ;
28106: LD_VAR 0 1
28110: PPUSH
28111: LD_INT 4
28113: PPUSH
28114: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
28118: LD_ADDR_EXP 34
28122: PUSH
28123: LD_EXP 34
28127: PUSH
28128: LD_INT 1
28130: PLUS
28131: ST_TO_ADDR
// wait ( 0 0$2 ) ;
28132: LD_INT 70
28134: PPUSH
28135: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
28139: LD_INT 260
28141: PPUSH
28142: LD_INT 235
28144: PPUSH
28145: LD_INT 1
28147: PPUSH
28148: LD_INT 8
28150: NEG
28151: PPUSH
28152: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
28156: LD_VAR 0 1
28160: PPUSH
28161: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
28165: LD_VAR 0 1
28169: PPUSH
28170: LD_EXP 71
28174: PPUSH
28175: CALL_OW 119
// DialogueOn ;
28179: CALL_OW 6
// case unit of JMM :
28183: LD_VAR 0 1
28187: PUSH
28188: LD_EXP 36
28192: DOUBLE
28193: EQUAL
28194: IFTRUE 28198
28196: GO 28213
28198: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
28199: LD_EXP 36
28203: PPUSH
28204: LD_STRING DA1-JMM-1
28206: PPUSH
28207: CALL_OW 91
28211: GO 28655
28213: LD_EXP 37
28217: DOUBLE
28218: EQUAL
28219: IFTRUE 28223
28221: GO 28238
28223: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
28224: LD_EXP 37
28228: PPUSH
28229: LD_STRING DA1-Joan-1
28231: PPUSH
28232: CALL_OW 91
28236: GO 28655
28238: LD_EXP 39
28242: DOUBLE
28243: EQUAL
28244: IFTRUE 28248
28246: GO 28263
28248: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
28249: LD_EXP 39
28253: PPUSH
28254: LD_STRING DA1-Lisa-1
28256: PPUSH
28257: CALL_OW 91
28261: GO 28655
28263: LD_EXP 40
28267: DOUBLE
28268: EQUAL
28269: IFTRUE 28273
28271: GO 28288
28273: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
28274: LD_EXP 40
28278: PPUSH
28279: LD_STRING DA1-Don-1
28281: PPUSH
28282: CALL_OW 91
28286: GO 28655
28288: LD_EXP 47
28292: DOUBLE
28293: EQUAL
28294: IFTRUE 28298
28296: GO 28313
28298: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
28299: LD_EXP 47
28303: PPUSH
28304: LD_STRING DA1-Corn-1
28306: PPUSH
28307: CALL_OW 91
28311: GO 28655
28313: LD_EXP 43
28317: DOUBLE
28318: EQUAL
28319: IFTRUE 28323
28321: GO 28338
28323: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
28324: LD_EXP 43
28328: PPUSH
28329: LD_STRING DA1-Den-1
28331: PPUSH
28332: CALL_OW 91
28336: GO 28655
28338: LD_EXP 41
28342: DOUBLE
28343: EQUAL
28344: IFTRUE 28348
28346: GO 28363
28348: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
28349: LD_EXP 41
28353: PPUSH
28354: LD_STRING DA1-Bobby-1
28356: PPUSH
28357: CALL_OW 91
28361: GO 28655
28363: LD_EXP 45
28367: DOUBLE
28368: EQUAL
28369: IFTRUE 28373
28371: GO 28388
28373: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
28374: LD_EXP 45
28378: PPUSH
28379: LD_STRING DA1-Glad-1
28381: PPUSH
28382: CALL_OW 91
28386: GO 28655
28388: LD_EXP 42
28392: DOUBLE
28393: EQUAL
28394: IFTRUE 28398
28396: GO 28413
28398: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
28399: LD_EXP 42
28403: PPUSH
28404: LD_STRING DA1-Cyrus-1
28406: PPUSH
28407: CALL_OW 91
28411: GO 28655
28413: LD_EXP 38
28417: DOUBLE
28418: EQUAL
28419: IFTRUE 28423
28421: GO 28438
28423: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
28424: LD_EXP 38
28428: PPUSH
28429: LD_STRING DA1-Huck-1
28431: PPUSH
28432: CALL_OW 91
28436: GO 28655
28438: LD_EXP 52
28442: DOUBLE
28443: EQUAL
28444: IFTRUE 28448
28446: GO 28463
28448: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
28449: LD_EXP 52
28453: PPUSH
28454: LD_STRING DA1-Huck-1
28456: PPUSH
28457: CALL_OW 91
28461: GO 28655
28463: LD_EXP 44
28467: DOUBLE
28468: EQUAL
28469: IFTRUE 28473
28471: GO 28488
28473: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
28474: LD_EXP 44
28478: PPUSH
28479: LD_STRING DA1-Brown-1
28481: PPUSH
28482: CALL_OW 91
28486: GO 28655
28488: LD_EXP 48
28492: DOUBLE
28493: EQUAL
28494: IFTRUE 28498
28496: GO 28513
28498: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
28499: LD_EXP 48
28503: PPUSH
28504: LD_STRING DA1-Gary-1
28506: PPUSH
28507: CALL_OW 91
28511: GO 28655
28513: LD_EXP 51
28517: DOUBLE
28518: EQUAL
28519: IFTRUE 28523
28521: GO 28538
28523: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
28524: LD_EXP 51
28528: PPUSH
28529: LD_STRING DA1-Con-1
28531: PPUSH
28532: CALL_OW 91
28536: GO 28655
28538: LD_EXP 57
28542: DOUBLE
28543: EQUAL
28544: IFTRUE 28548
28546: GO 28563
28548: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
28549: LD_EXP 57
28553: PPUSH
28554: LD_STRING DA1-Kurt-1
28556: PPUSH
28557: CALL_OW 91
28561: GO 28655
28563: LD_EXP 50
28567: DOUBLE
28568: EQUAL
28569: IFTRUE 28573
28571: GO 28588
28573: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
28574: LD_EXP 50
28578: PPUSH
28579: LD_STRING DA1-Yam-1
28581: PPUSH
28582: CALL_OW 91
28586: GO 28655
28588: LD_EXP 49
28592: DOUBLE
28593: EQUAL
28594: IFTRUE 28598
28596: GO 28613
28598: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
28599: LD_EXP 49
28603: PPUSH
28604: LD_STRING DA1-Frank-1
28606: PPUSH
28607: CALL_OW 91
28611: GO 28655
28613: POP
// begin if GetSex ( unit ) = sex_male then
28614: LD_VAR 0 1
28618: PPUSH
28619: CALL_OW 258
28623: PUSH
28624: LD_INT 1
28626: EQUAL
28627: IFFALSE 28643
// ForceSay ( unit , DA1-Sol1-1 ) else
28629: LD_VAR 0 1
28633: PPUSH
28634: LD_STRING DA1-Sol1-1
28636: PPUSH
28637: CALL_OW 91
28641: GO 28655
// ForceSay ( unit , DA1-FSol1-1 ) ;
28643: LD_VAR 0 1
28647: PPUSH
28648: LD_STRING DA1-FSol1-1
28650: PPUSH
28651: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
28655: LD_EXP 71
28659: PPUSH
28660: LD_STRING DA-Roth-1
28662: PPUSH
28663: CALL_OW 88
// if capturedUnit = 1 then
28667: LD_EXP 34
28671: PUSH
28672: LD_INT 1
28674: EQUAL
28675: IFFALSE 28703
// begin Say ( Simms , DA-Sim-1 ) ;
28677: LD_EXP 72
28681: PPUSH
28682: LD_STRING DA-Sim-1
28684: PPUSH
28685: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
28689: LD_EXP 71
28693: PPUSH
28694: LD_STRING DA-Roth-2
28696: PPUSH
28697: CALL_OW 88
// end else
28701: GO 28715
// Say ( Simms , DA-Sim-2 ) ;
28703: LD_EXP 72
28707: PPUSH
28708: LD_STRING DA-Sim-2
28710: PPUSH
28711: CALL_OW 88
// case unit of JMM :
28715: LD_VAR 0 1
28719: PUSH
28720: LD_EXP 36
28724: DOUBLE
28725: EQUAL
28726: IFTRUE 28730
28728: GO 28745
28730: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
28731: LD_EXP 36
28735: PPUSH
28736: LD_STRING DA1-JMM-1a
28738: PPUSH
28739: CALL_OW 91
28743: GO 29252
28745: LD_EXP 37
28749: DOUBLE
28750: EQUAL
28751: IFTRUE 28755
28753: GO 28770
28755: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
28756: LD_EXP 37
28760: PPUSH
28761: LD_STRING DA1-Joan-1a
28763: PPUSH
28764: CALL_OW 91
28768: GO 29252
28770: LD_EXP 39
28774: DOUBLE
28775: EQUAL
28776: IFTRUE 28780
28778: GO 28795
28780: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
28781: LD_EXP 39
28785: PPUSH
28786: LD_STRING DA1-Lisa-1a
28788: PPUSH
28789: CALL_OW 91
28793: GO 29252
28795: LD_EXP 40
28799: DOUBLE
28800: EQUAL
28801: IFTRUE 28805
28803: GO 28820
28805: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
28806: LD_EXP 40
28810: PPUSH
28811: LD_STRING DA1-Don-1a
28813: PPUSH
28814: CALL_OW 91
28818: GO 29252
28820: LD_EXP 47
28824: DOUBLE
28825: EQUAL
28826: IFTRUE 28830
28828: GO 28845
28830: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
28831: LD_EXP 47
28835: PPUSH
28836: LD_STRING DA1-Corn-1a
28838: PPUSH
28839: CALL_OW 91
28843: GO 29252
28845: LD_EXP 43
28849: DOUBLE
28850: EQUAL
28851: IFTRUE 28855
28853: GO 28870
28855: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
28856: LD_EXP 43
28860: PPUSH
28861: LD_STRING DA1-Den-1a
28863: PPUSH
28864: CALL_OW 91
28868: GO 29252
28870: LD_EXP 41
28874: DOUBLE
28875: EQUAL
28876: IFTRUE 28880
28878: GO 28895
28880: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
28881: LD_EXP 41
28885: PPUSH
28886: LD_STRING DA1-Bobby-1a
28888: PPUSH
28889: CALL_OW 91
28893: GO 29252
28895: LD_EXP 45
28899: DOUBLE
28900: EQUAL
28901: IFTRUE 28905
28903: GO 28920
28905: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
28906: LD_EXP 45
28910: PPUSH
28911: LD_STRING DA1-Glad-1a
28913: PPUSH
28914: CALL_OW 91
28918: GO 29252
28920: LD_EXP 42
28924: DOUBLE
28925: EQUAL
28926: IFTRUE 28930
28928: GO 28945
28930: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
28931: LD_EXP 42
28935: PPUSH
28936: LD_STRING DA1-Cyrus-1a
28938: PPUSH
28939: CALL_OW 91
28943: GO 29252
28945: LD_EXP 38
28949: DOUBLE
28950: EQUAL
28951: IFTRUE 28955
28953: GO 28970
28955: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
28956: LD_EXP 38
28960: PPUSH
28961: LD_STRING DA1-Huck-1a
28963: PPUSH
28964: CALL_OW 91
28968: GO 29252
28970: LD_EXP 52
28974: DOUBLE
28975: EQUAL
28976: IFTRUE 28980
28978: GO 28995
28980: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
28981: LD_EXP 52
28985: PPUSH
28986: LD_STRING DA1-Huck-1a
28988: PPUSH
28989: CALL_OW 91
28993: GO 29252
28995: LD_EXP 44
28999: DOUBLE
29000: EQUAL
29001: IFTRUE 29005
29003: GO 29020
29005: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
29006: LD_EXP 44
29010: PPUSH
29011: LD_STRING DA1-Brown-1a
29013: PPUSH
29014: CALL_OW 91
29018: GO 29252
29020: LD_EXP 48
29024: DOUBLE
29025: EQUAL
29026: IFTRUE 29030
29028: GO 29045
29030: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
29031: LD_EXP 48
29035: PPUSH
29036: LD_STRING DA1-Gary-1a
29038: PPUSH
29039: CALL_OW 91
29043: GO 29252
29045: LD_EXP 51
29049: DOUBLE
29050: EQUAL
29051: IFTRUE 29055
29053: GO 29070
29055: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
29056: LD_EXP 51
29060: PPUSH
29061: LD_STRING DA1-Con-1a
29063: PPUSH
29064: CALL_OW 91
29068: GO 29252
29070: LD_EXP 57
29074: DOUBLE
29075: EQUAL
29076: IFTRUE 29080
29078: GO 29095
29080: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
29081: LD_EXP 57
29085: PPUSH
29086: LD_STRING DA1-Kurt-1a
29088: PPUSH
29089: CALL_OW 91
29093: GO 29252
29095: LD_EXP 50
29099: DOUBLE
29100: EQUAL
29101: IFTRUE 29105
29103: GO 29120
29105: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
29106: LD_EXP 50
29110: PPUSH
29111: LD_STRING DA1-Yam-1a
29113: PPUSH
29114: CALL_OW 91
29118: GO 29252
29120: LD_EXP 49
29124: DOUBLE
29125: EQUAL
29126: IFTRUE 29130
29128: GO 29145
29130: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
29131: LD_EXP 49
29135: PPUSH
29136: LD_STRING DA1-Frank-1a
29138: PPUSH
29139: CALL_OW 91
29143: GO 29252
29145: POP
// begin join := rand ( 0 , 1 ) ;
29146: LD_ADDR_VAR 0 3
29150: PUSH
29151: LD_INT 0
29153: PPUSH
29154: LD_INT 1
29156: PPUSH
29157: CALL_OW 12
29161: ST_TO_ADDR
// if join then
29162: LD_VAR 0 3
29166: IFFALSE 29211
// begin if GetSex ( unit ) = sex_male then
29168: LD_VAR 0 1
29172: PPUSH
29173: CALL_OW 258
29177: PUSH
29178: LD_INT 1
29180: EQUAL
29181: IFFALSE 29197
// ForceSay ( unit , DA1-Sol1-1b ) else
29183: LD_VAR 0 1
29187: PPUSH
29188: LD_STRING DA1-Sol1-1b
29190: PPUSH
29191: CALL_OW 91
29195: GO 29209
// ForceSay ( unit , DA1-FSol1-1b ) ;
29197: LD_VAR 0 1
29201: PPUSH
29202: LD_STRING DA1-FSol1-1b
29204: PPUSH
29205: CALL_OW 91
// end else
29209: GO 29252
// begin if GetSex ( unit ) = sex_male then
29211: LD_VAR 0 1
29215: PPUSH
29216: CALL_OW 258
29220: PUSH
29221: LD_INT 1
29223: EQUAL
29224: IFFALSE 29240
// ForceSay ( unit , DA1-Sol1-1a ) else
29226: LD_VAR 0 1
29230: PPUSH
29231: LD_STRING DA1-Sol1-1a
29233: PPUSH
29234: CALL_OW 91
29238: GO 29252
// ForceSay ( unit , DA1-FSol1-1a ) ;
29240: LD_VAR 0 1
29244: PPUSH
29245: LD_STRING DA1-FSol1-1a
29247: PPUSH
29248: CALL_OW 91
// end ; end ; end ; if unit = JMM then
29252: LD_VAR 0 1
29256: PUSH
29257: LD_EXP 36
29261: EQUAL
29262: IFFALSE 29273
// begin YouLost ( JMMCaptured ) ;
29264: LD_STRING JMMCaptured
29266: PPUSH
29267: CALL_OW 104
// exit ;
29271: GO 29562
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
29273: LD_VAR 0 1
29277: PUSH
29278: LD_EXP 40
29282: PUSH
29283: LD_EXP 43
29287: PUSH
29288: LD_EXP 41
29292: PUSH
29293: LD_EXP 38
29297: PUSH
29298: LD_EXP 52
29302: PUSH
29303: LD_EXP 44
29307: PUSH
29308: LD_EXP 50
29312: PUSH
29313: EMPTY
29314: LIST
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: IN
29322: PUSH
29323: LD_VAR 0 3
29327: OR
29328: IFFALSE 29418
// begin Say ( Roth , DA-Roth-3 ) ;
29330: LD_EXP 71
29334: PPUSH
29335: LD_STRING DA-Roth-3
29337: PPUSH
29338: CALL_OW 88
// SetSide ( unit , 7 ) ;
29342: LD_VAR 0 1
29346: PPUSH
29347: LD_INT 7
29349: PPUSH
29350: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] union unit ) ;
29354: LD_ADDR_EXP 99
29358: PUSH
29359: LD_EXP 99
29363: PPUSH
29364: LD_INT 1
29366: PPUSH
29367: LD_EXP 99
29371: PUSH
29372: LD_INT 1
29374: ARRAY
29375: PUSH
29376: LD_VAR 0 1
29380: UNION
29381: PPUSH
29382: CALL_OW 1
29386: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
29387: LD_INT 260
29389: PPUSH
29390: LD_INT 235
29392: PPUSH
29393: LD_INT 1
29395: PPUSH
29396: CALL_OW 331
// SetLives ( unit , 1000 ) ;
29400: LD_VAR 0 1
29404: PPUSH
29405: LD_INT 1000
29407: PPUSH
29408: CALL_OW 234
// DialogueOff ;
29412: CALL_OW 7
// end else
29416: GO 29499
// begin Say ( Roth , DA-Roth-3a ) ;
29418: LD_EXP 71
29422: PPUSH
29423: LD_STRING DA-Roth-3a
29425: PPUSH
29426: CALL_OW 88
// trueAmericans := trueAmericans union unit ;
29430: LD_ADDR_EXP 35
29434: PUSH
29435: LD_EXP 35
29439: PUSH
29440: LD_VAR 0 1
29444: UNION
29445: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
29446: LD_INT 260
29448: PPUSH
29449: LD_INT 235
29451: PPUSH
29452: LD_INT 1
29454: PPUSH
29455: CALL_OW 331
// SetLives ( unit , 1000 ) ;
29459: LD_VAR 0 1
29463: PPUSH
29464: LD_INT 1000
29466: PPUSH
29467: CALL_OW 234
// DialogueOff ;
29471: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
29475: LD_VAR 0 1
29479: PPUSH
29480: LD_INT 272
29482: PPUSH
29483: LD_INT 254
29485: PPUSH
29486: CALL_OW 111
// AddComHold ( unit ) ;
29490: LD_VAR 0 1
29494: PPUSH
29495: CALL_OW 200
// end ; if capturedUnit = 1 then
29499: LD_EXP 34
29503: PUSH
29504: LD_INT 1
29506: EQUAL
29507: IFFALSE 29562
// begin DialogueOn ;
29509: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
29513: LD_EXP 36
29517: PPUSH
29518: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
29522: LD_EXP 36
29526: PPUSH
29527: LD_STRING DAa-JMM-1
29529: PPUSH
29530: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
29534: LD_EXP 36
29538: PPUSH
29539: LD_STRING DAa-JMM-1a
29541: PPUSH
29542: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
29546: LD_EXP 36
29550: PPUSH
29551: LD_STRING DAa-JMM-1b
29553: PPUSH
29554: CALL_OW 88
// DialogueOff ;
29558: CALL_OW 7
// end ; end ;
29562: LD_VAR 0 2
29566: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
29567: LD_EXP 15
29571: PUSH
29572: LD_INT 13
29574: GREATEREQUAL
29575: PUSH
29576: LD_INT 22
29578: PUSH
29579: LD_INT 2
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 21
29588: PUSH
29589: LD_INT 1
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: EMPTY
29597: LIST
29598: LIST
29599: PPUSH
29600: CALL_OW 69
29604: PUSH
29605: LD_INT 0
29607: EQUAL
29608: AND
29609: PUSH
29610: LD_INT 22
29612: PUSH
29613: LD_INT 2
29615: PUSH
29616: EMPTY
29617: LIST
29618: LIST
29619: PUSH
29620: LD_INT 21
29622: PUSH
29623: LD_INT 2
29625: PUSH
29626: EMPTY
29627: LIST
29628: LIST
29629: PUSH
29630: LD_INT 50
29632: PUSH
29633: EMPTY
29634: LIST
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: LIST
29640: PPUSH
29641: CALL_OW 69
29645: PUSH
29646: LD_INT 0
29648: EQUAL
29649: AND
29650: PUSH
29651: LD_EXP 21
29655: AND
29656: PUSH
29657: LD_EXP 22
29661: AND
29662: PUSH
29663: LD_EXP 23
29667: AND
29668: IFFALSE 30149
29670: GO 29672
29672: DISABLE
// begin DialogueOn ;
29673: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
29677: LD_EXP 36
29681: PPUSH
29682: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
29686: LD_EXP 36
29690: PPUSH
29691: LD_STRING D20-JMM-1
29693: PPUSH
29694: CALL_OW 88
// if IsOK ( Joan ) then
29698: LD_EXP 37
29702: PPUSH
29703: CALL_OW 302
29707: IFFALSE 29721
// Say ( Joan , D20-Joan-1 ) ;
29709: LD_EXP 37
29713: PPUSH
29714: LD_STRING D20-Joan-1
29716: PPUSH
29717: CALL_OW 88
// if IsOk ( Lisa ) then
29721: LD_EXP 39
29725: PPUSH
29726: CALL_OW 302
29730: IFFALSE 29744
// Say ( Lisa , D20-Lisa-1 ) ;
29732: LD_EXP 39
29736: PPUSH
29737: LD_STRING D20-Lisa-1
29739: PPUSH
29740: CALL_OW 88
// if IsOk ( Donaldson ) then
29744: LD_EXP 40
29748: PPUSH
29749: CALL_OW 302
29753: IFFALSE 29767
// Say ( Donaldson , D20-Don-1 ) ;
29755: LD_EXP 40
29759: PPUSH
29760: LD_STRING D20-Don-1
29762: PPUSH
29763: CALL_OW 88
// if IsOK ( Cornel ) then
29767: LD_EXP 47
29771: PPUSH
29772: CALL_OW 302
29776: IFFALSE 29790
// Say ( Cornel , D20-Corn-1 ) ;
29778: LD_EXP 47
29782: PPUSH
29783: LD_STRING D20-Corn-1
29785: PPUSH
29786: CALL_OW 88
// if IsOk ( Denis ) then
29790: LD_EXP 43
29794: PPUSH
29795: CALL_OW 302
29799: IFFALSE 29813
// Say ( Denis , D20-Den-1 ) ;
29801: LD_EXP 43
29805: PPUSH
29806: LD_STRING D20-Den-1
29808: PPUSH
29809: CALL_OW 88
// if IsOk ( Bobby ) then
29813: LD_EXP 41
29817: PPUSH
29818: CALL_OW 302
29822: IFFALSE 29836
// Say ( Bobby , D20-Bobby-1 ) ;
29824: LD_EXP 41
29828: PPUSH
29829: LD_STRING D20-Bobby-1
29831: PPUSH
29832: CALL_OW 88
// if IsOk ( Gladstone ) then
29836: LD_EXP 45
29840: PPUSH
29841: CALL_OW 302
29845: IFFALSE 29859
// Say ( Gladstone , D20-Glad-1 ) ;
29847: LD_EXP 45
29851: PPUSH
29852: LD_STRING D20-Glad-1
29854: PPUSH
29855: CALL_OW 88
// if IsOk ( Cyrus ) then
29859: LD_EXP 42
29863: PPUSH
29864: CALL_OW 302
29868: IFFALSE 29882
// Say ( Cyrus , D20-Cyrus-1 ) ;
29870: LD_EXP 42
29874: PPUSH
29875: LD_STRING D20-Cyrus-1
29877: PPUSH
29878: CALL_OW 88
// if IsOk ( Stevens ) then
29882: LD_EXP 38
29886: PPUSH
29887: CALL_OW 302
29891: IFFALSE 29905
// Say ( Stevens , D20-Huck-1 ) ;
29893: LD_EXP 38
29897: PPUSH
29898: LD_STRING D20-Huck-1
29900: PPUSH
29901: CALL_OW 88
// if IsOk ( Brown ) then
29905: LD_EXP 44
29909: PPUSH
29910: CALL_OW 302
29914: IFFALSE 29928
// Say ( Brown , D20-Brown-1 ) ;
29916: LD_EXP 44
29920: PPUSH
29921: LD_STRING D20-Brown-1
29923: PPUSH
29924: CALL_OW 88
// if IsOk ( Gary ) then
29928: LD_EXP 48
29932: PPUSH
29933: CALL_OW 302
29937: IFFALSE 29951
// Say ( Gary , D20-Gary-1 ) ;
29939: LD_EXP 48
29943: PPUSH
29944: LD_STRING D20-Gary-1
29946: PPUSH
29947: CALL_OW 88
// if IsOk ( Connie ) then
29951: LD_EXP 51
29955: PPUSH
29956: CALL_OW 302
29960: IFFALSE 29974
// Say ( Connie , D20-Con-1 ) ;
29962: LD_EXP 51
29966: PPUSH
29967: LD_STRING D20-Con-1
29969: PPUSH
29970: CALL_OW 88
// if IsOk ( Kurt ) then
29974: LD_EXP 57
29978: PPUSH
29979: CALL_OW 302
29983: IFFALSE 29997
// Say ( Kurt , D20-Kurt-1 ) ;
29985: LD_EXP 57
29989: PPUSH
29990: LD_STRING D20-Kurt-1
29992: PPUSH
29993: CALL_OW 88
// if IsOk ( Kikuchi ) then
29997: LD_EXP 50
30001: PPUSH
30002: CALL_OW 302
30006: IFFALSE 30020
// Say ( Kikuchi , D20-Yam-1 ) ;
30008: LD_EXP 50
30012: PPUSH
30013: LD_STRING D20-Yam-1
30015: PPUSH
30016: CALL_OW 88
// if IsOk ( Frank ) then
30020: LD_EXP 49
30024: PPUSH
30025: CALL_OW 302
30029: IFFALSE 30043
// Say ( Frank , D20-Frank-1 ) ;
30031: LD_EXP 49
30035: PPUSH
30036: LD_STRING D20-Frank-1
30038: PPUSH
30039: CALL_OW 88
// DialogueOff ;
30043: CALL_OW 7
// if RothCaptured then
30047: LD_EXP 33
30051: IFFALSE 30065
// AddMedal ( Roth , 1 ) else
30053: LD_STRING Roth
30055: PPUSH
30056: LD_INT 1
30058: PPUSH
30059: CALL_OW 101
30063: GO 30076
// AddMedal ( Roth , - 1 ) ;
30065: LD_STRING Roth
30067: PPUSH
30068: LD_INT 1
30070: NEG
30071: PPUSH
30072: CALL_OW 101
// if behemothDestroyedBeforeFinish then
30076: LD_EXP 27
30080: IFFALSE 30094
// AddMedal ( Project , 1 ) else
30082: LD_STRING Project
30084: PPUSH
30085: LD_INT 1
30087: PPUSH
30088: CALL_OW 101
30092: GO 30105
// AddMedal ( Project , - 1 ) ;
30094: LD_STRING Project
30096: PPUSH
30097: LD_INT 1
30099: NEG
30100: PPUSH
30101: CALL_OW 101
// if lostCounter = 0 then
30105: LD_EXP 32
30109: PUSH
30110: LD_INT 0
30112: EQUAL
30113: IFFALSE 30127
// AddMedal ( NoLosses , 1 ) else
30115: LD_STRING NoLosses
30117: PPUSH
30118: LD_INT 1
30120: PPUSH
30121: CALL_OW 101
30125: GO 30138
// AddMedal ( NoLosses , - 1 ) ;
30127: LD_STRING NoLosses
30129: PPUSH
30130: LD_INT 1
30132: NEG
30133: PPUSH
30134: CALL_OW 101
// GiveMedals ( MAIN ) ;
30138: LD_STRING MAIN
30140: PPUSH
30141: CALL_OW 102
// YouWin ;
30145: CALL_OW 103
// end ; end_of_file
30149: END
// export function CustomEvent ( event ) ; begin
30150: LD_INT 0
30152: PPUSH
// end ;
30153: LD_VAR 0 2
30157: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
30158: LD_VAR 0 1
30162: PUSH
30163: LD_INT 1
30165: EQUAL
30166: PUSH
30167: LD_VAR 0 2
30171: PUSH
30172: LD_INT 4
30174: EQUAL
30175: AND
30176: PUSH
30177: LD_EXP 55
30181: PPUSH
30182: CALL_OW 300
30186: AND
30187: IFFALSE 30203
// begin wait ( 0 0$2 ) ;
30189: LD_INT 70
30191: PPUSH
30192: CALL_OW 67
// YouLost ( Dismissed ) ;
30196: LD_STRING Dismissed
30198: PPUSH
30199: CALL_OW 104
// end ; end ;
30203: PPOPN 2
30205: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
30206: LD_EXP 27
30210: NOT
30211: IFFALSE 30221
// behemothDone := true ;
30213: LD_ADDR_EXP 28
30217: PUSH
30218: LD_INT 1
30220: ST_TO_ADDR
// end ;
30221: PPOPN 1
30223: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
30224: LD_VAR 0 2
30228: PPUSH
30229: LD_VAR 0 3
30233: PPUSH
30234: LD_INT 18
30236: PPUSH
30237: CALL_OW 309
30241: IFFALSE 30301
// begin if GetSide ( unit ) = 1 then
30243: LD_VAR 0 1
30247: PPUSH
30248: CALL_OW 255
30252: PUSH
30253: LD_INT 1
30255: EQUAL
30256: IFFALSE 30272
// begin wait ( 0 0$6 ) ;
30258: LD_INT 210
30260: PPUSH
30261: CALL_OW 67
// YouLost ( Motherlode2 ) ;
30265: LD_STRING Motherlode2
30267: PPUSH
30268: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
30272: LD_VAR 0 1
30276: PPUSH
30277: CALL_OW 255
30281: PUSH
30282: LD_INT 8
30284: EQUAL
30285: IFFALSE 30301
// begin wait ( 0 0$6 ) ;
30287: LD_INT 210
30289: PPUSH
30290: CALL_OW 67
// YouLost ( Motherlode1 ) ;
30294: LD_STRING Motherlode1
30296: PPUSH
30297: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
30301: LD_VAR 0 1
30305: PPUSH
30306: CALL_OW 255
30310: PUSH
30311: LD_INT 3
30313: EQUAL
30314: IFFALSE 30335
// begin wait ( 0 0$5 ) ;
30316: LD_INT 175
30318: PPUSH
30319: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
30323: LD_EXP 61
30327: PPUSH
30328: LD_STRING D18-Pla-1
30330: PPUSH
30331: CALL_OW 94
// end ; end ;
30335: PPOPN 3
30337: END
// on SibDepositContaminated ( unit , x , y ) do begin if GetSide ( unit ) = 2 then
30338: LD_VAR 0 1
30342: PPUSH
30343: CALL_OW 255
30347: PUSH
30348: LD_INT 2
30350: EQUAL
30351: IFFALSE 30360
// YouLost ( Motherlode3 ) ;
30353: LD_STRING Motherlode3
30355: PPUSH
30356: CALL_OW 104
// end ;
30360: PPOPN 3
30362: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
30363: LD_VAR 0 1
30367: PUSH
30368: LD_EXP 70
30372: IN
30373: IFFALSE 30393
// begin behemothBuilders := behemothBuilders diff un ;
30375: LD_ADDR_EXP 70
30379: PUSH
30380: LD_EXP 70
30384: PUSH
30385: LD_VAR 0 1
30389: DIFF
30390: ST_TO_ADDR
// exit ;
30391: GO 30491
// end ; if un = JMM then
30393: LD_VAR 0 1
30397: PUSH
30398: LD_EXP 36
30402: EQUAL
30403: IFFALSE 30414
// begin YouLost ( JMM ) ;
30405: LD_STRING JMM
30407: PPUSH
30408: CALL_OW 104
// exit ;
30412: GO 30491
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
30414: LD_VAR 0 1
30418: PUSH
30419: LD_INT 22
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 3
30431: PUSH
30432: LD_INT 25
30434: PUSH
30435: LD_INT 16
30437: PUSH
30438: EMPTY
30439: LIST
30440: LIST
30441: PUSH
30442: LD_INT 25
30444: PUSH
30445: LD_INT 12
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: EMPTY
30453: LIST
30454: LIST
30455: LIST
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PPUSH
30461: CALL_OW 69
30465: IN
30466: IFFALSE 30482
// lostCounter := lostCounter + 1 ;
30468: LD_ADDR_EXP 32
30472: PUSH
30473: LD_EXP 32
30477: PUSH
30478: LD_INT 1
30480: PLUS
30481: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
30482: LD_VAR 0 1
30486: PPUSH
30487: CALL 56908 0 1
// end ;
30491: PPOPN 1
30493: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
30494: LD_VAR 0 1
30498: PPUSH
30499: LD_VAR 0 2
30503: PPUSH
30504: CALL 58814 0 2
// end ;
30508: PPOPN 2
30510: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
30511: LD_VAR 0 1
30515: PPUSH
30516: CALL 57882 0 1
// end ;
30520: PPOPN 1
30522: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
30523: LD_VAR 0 1
30527: PUSH
30528: LD_INT 22
30530: PUSH
30531: LD_INT 8
30533: PUSH
30534: EMPTY
30535: LIST
30536: LIST
30537: PUSH
30538: LD_INT 30
30540: PUSH
30541: LD_INT 2
30543: PUSH
30544: EMPTY
30545: LIST
30546: LIST
30547: PUSH
30548: LD_INT 23
30550: PUSH
30551: LD_INT 3
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: LIST
30562: PPUSH
30563: CALL_OW 69
30567: IN
30568: IFFALSE 30595
// begin ComUpgrade ( building ) ;
30570: LD_VAR 0 1
30574: PPUSH
30575: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
30579: LD_EXP 58
30583: PPUSH
30584: LD_VAR 0 1
30588: PPUSH
30589: CALL 69038 0 2
// exit ;
30593: GO 30604
// end ; MCE_BuildingComplete ( building ) ;
30595: LD_VAR 0 1
30599: PPUSH
30600: CALL 58123 0 1
// end ;
30604: PPOPN 1
30606: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
30607: LD_VAR 0 1
30611: PPUSH
30612: LD_VAR 0 2
30616: PPUSH
30617: CALL 56604 0 2
// end ;
30621: PPOPN 2
30623: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
30624: LD_VAR 0 1
30628: PPUSH
30629: LD_VAR 0 2
30633: PPUSH
30634: LD_VAR 0 3
30638: PPUSH
30639: LD_VAR 0 4
30643: PPUSH
30644: LD_VAR 0 5
30648: PPUSH
30649: CALL 56224 0 5
// end ;
30653: PPOPN 5
30655: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
30656: LD_VAR 0 1
30660: PPUSH
30661: LD_VAR 0 2
30665: PPUSH
30666: CALL 55814 0 2
// end ;
30670: PPOPN 2
30672: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
30673: LD_VAR 0 1
30677: PPUSH
30678: LD_VAR 0 2
30682: PPUSH
30683: LD_VAR 0 3
30687: PPUSH
30688: LD_VAR 0 4
30692: PPUSH
30693: CALL 55652 0 4
// end ;
30697: PPOPN 4
30699: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
30700: LD_VAR 0 1
30704: PPUSH
30705: LD_VAR 0 2
30709: PPUSH
30710: LD_VAR 0 3
30714: PPUSH
30715: CALL 55427 0 3
// end ;
30719: PPOPN 3
30721: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
30722: LD_VAR 0 1
30726: PPUSH
30727: LD_VAR 0 2
30731: PPUSH
30732: CALL 55312 0 2
// end ;
30736: PPOPN 2
30738: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
30739: LD_VAR 0 1
30743: PPUSH
30744: LD_VAR 0 2
30748: PPUSH
30749: CALL 59075 0 2
// end ;
30753: PPOPN 2
30755: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
30756: LD_VAR 0 1
30760: PPUSH
30761: CALL_OW 255
30765: PUSH
30766: LD_INT 4
30768: EQUAL
30769: PUSH
30770: LD_VAR 0 1
30774: PUSH
30775: LD_EXP 18
30779: PUSH
30780: LD_INT 1
30782: ARRAY
30783: IN
30784: AND
30785: PUSH
30786: LD_EXP 19
30790: AND
30791: IFFALSE 30810
// begin ComMoveXY ( driver , 61 , 93 ) ;
30793: LD_VAR 0 1
30797: PPUSH
30798: LD_INT 61
30800: PPUSH
30801: LD_INT 93
30803: PPUSH
30804: CALL_OW 111
// exit ;
30808: GO 30834
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
30810: LD_VAR 0 1
30814: PPUSH
30815: LD_VAR 0 2
30819: PPUSH
30820: LD_VAR 0 3
30824: PPUSH
30825: LD_VAR 0 4
30829: PPUSH
30830: CALL 59291 0 4
// end ;
30834: PPOPN 4
30836: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
30837: LD_VAR 0 1
30841: PPUSH
30842: LD_VAR 0 2
30846: PPUSH
30847: CALL 55121 0 2
// end ; end_of_file
30851: PPOPN 2
30853: END
// every 0 0$30 trigger missionStage = 2 do var time ;
30854: LD_EXP 15
30858: PUSH
30859: LD_INT 2
30861: EQUAL
30862: IFFALSE 31315
30864: GO 30866
30866: DISABLE
30867: LD_INT 0
30869: PPUSH
// begin time := 0 0$30 ;
30870: LD_ADDR_VAR 0 1
30874: PUSH
30875: LD_INT 1050
30877: ST_TO_ADDR
// repeat wait ( time ) ;
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
30887: LD_INT 1
30889: PPUSH
30890: LD_INT 5
30892: PPUSH
30893: CALL_OW 12
30897: PPUSH
30898: LD_INT 106
30900: PPUSH
30901: LD_INT 150
30903: PPUSH
30904: LD_INT 19
30906: PPUSH
30907: LD_INT 1
30909: PPUSH
30910: CALL_OW 56
// time := time + 0 0$9 ;
30914: LD_ADDR_VAR 0 1
30918: PUSH
30919: LD_VAR 0 1
30923: PUSH
30924: LD_INT 315
30926: PLUS
30927: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$21 ) ) ;
30928: LD_INT 455
30930: PPUSH
30931: LD_INT 735
30933: PPUSH
30934: CALL_OW 12
30938: PPUSH
30939: CALL_OW 67
// if Prob ( 50 ) then
30943: LD_INT 50
30945: PPUSH
30946: CALL_OW 13
30950: IFFALSE 30979
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
30952: LD_INT 1
30954: PPUSH
30955: LD_INT 5
30957: PPUSH
30958: CALL_OW 12
30962: PPUSH
30963: LD_INT 62
30965: PPUSH
30966: LD_INT 108
30968: PPUSH
30969: LD_INT 10
30971: PPUSH
30972: LD_INT 1
30974: PPUSH
30975: CALL_OW 56
// until missionStage > 4 ;
30979: LD_EXP 15
30983: PUSH
30984: LD_INT 4
30986: GREATER
30987: IFFALSE 30878
// repeat wait ( 0 0$1 ) ;
30989: LD_INT 35
30991: PPUSH
30992: CALL_OW 67
// until missionStage = 6 ;
30996: LD_EXP 15
31000: PUSH
31001: LD_INT 6
31003: EQUAL
31004: IFFALSE 30989
// time := 0 0$40 ;
31006: LD_ADDR_VAR 0 1
31010: PUSH
31011: LD_INT 1400
31013: ST_TO_ADDR
// repeat wait ( time ) ;
31014: LD_VAR 0 1
31018: PPUSH
31019: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 35 , true ) ;
31023: LD_INT 1
31025: PPUSH
31026: LD_INT 5
31028: PPUSH
31029: CALL_OW 12
31033: PPUSH
31034: LD_INT 106
31036: PPUSH
31037: LD_INT 89
31039: PPUSH
31040: LD_INT 35
31042: PPUSH
31043: LD_INT 1
31045: PPUSH
31046: CALL_OW 56
// time := time + 0 0$3 ;
31050: LD_ADDR_VAR 0 1
31054: PUSH
31055: LD_VAR 0 1
31059: PUSH
31060: LD_INT 105
31062: PLUS
31063: ST_TO_ADDR
// if Prob ( 30 ) then
31064: LD_INT 30
31066: PPUSH
31067: CALL_OW 13
31071: IFFALSE 31117
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
31073: LD_INT 525
31075: PPUSH
31076: LD_INT 735
31078: PPUSH
31079: CALL_OW 12
31083: PPUSH
31084: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
31088: LD_INT 1
31090: PPUSH
31091: LD_INT 5
31093: PPUSH
31094: CALL_OW 12
31098: PPUSH
31099: LD_INT 21
31101: PPUSH
31102: LD_INT 26
31104: PPUSH
31105: LD_INT 12
31107: PPUSH
31108: LD_INT 1
31110: PPUSH
31111: CALL_OW 56
// end else
31115: GO 31153
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
31117: LD_INT 700
31119: PPUSH
31120: LD_INT 1225
31122: PPUSH
31123: CALL_OW 12
31127: PPUSH
31128: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
31132: LD_INT 1
31134: PPUSH
31135: LD_INT 5
31137: PPUSH
31138: CALL_OW 12
31142: PPUSH
31143: LD_INT 16
31145: PPUSH
31146: LD_INT 1
31148: PPUSH
31149: CALL_OW 55
// end ; if Prob ( 50 ) then
31153: LD_INT 50
31155: PPUSH
31156: CALL_OW 13
31160: IFFALSE 31206
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
31162: LD_INT 700
31164: PPUSH
31165: LD_INT 1050
31167: PPUSH
31168: CALL_OW 12
31172: PPUSH
31173: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
31177: LD_INT 1
31179: PPUSH
31180: LD_INT 5
31182: PPUSH
31183: CALL_OW 12
31187: PPUSH
31188: LD_INT 181
31190: PPUSH
31191: LD_INT 218
31193: PPUSH
31194: LD_INT 16
31196: PPUSH
31197: LD_INT 1
31199: PPUSH
31200: CALL_OW 56
// end else
31204: GO 31242
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
31206: LD_INT 350
31208: PPUSH
31209: LD_INT 525
31211: PPUSH
31212: CALL_OW 12
31216: PPUSH
31217: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
31221: LD_INT 1
31223: PPUSH
31224: LD_INT 5
31226: PPUSH
31227: CALL_OW 12
31231: PPUSH
31232: LD_INT 15
31234: PPUSH
31235: LD_INT 1
31237: PPUSH
31238: CALL_OW 55
// end ; if Prob ( 45 ) then
31242: LD_INT 45
31244: PPUSH
31245: CALL_OW 13
31249: IFFALSE 31293
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
31251: LD_INT 525
31253: PPUSH
31254: LD_INT 875
31256: PPUSH
31257: CALL_OW 12
31261: PPUSH
31262: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
31266: LD_INT 1
31268: PPUSH
31269: LD_INT 5
31271: PPUSH
31272: CALL_OW 12
31276: PPUSH
31277: LD_INT 103
31279: PPUSH
31280: LD_INT 140
31282: PPUSH
31283: LD_INT 20
31285: PPUSH
31286: LD_INT 1
31288: PPUSH
31289: CALL_OW 56
// end ; if time > 2 2$20 then
31293: LD_VAR 0 1
31297: PUSH
31298: LD_INT 4900
31300: GREATER
31301: IFFALSE 31311
// time := 0 0$40 ;
31303: LD_ADDR_VAR 0 1
31307: PUSH
31308: LD_INT 1400
31310: ST_TO_ADDR
// until false ;
31311: LD_INT 0
31313: IFFALSE 31014
// end ; end_of_file
31315: PPOPN 1
31317: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
31318: LD_EXP 13
31322: PUSH
31323: LD_EXP 15
31327: PUSH
31328: LD_INT 6
31330: GREATEREQUAL
31331: AND
31332: IFFALSE 31369
31334: GO 31336
31336: DISABLE
// begin enable ;
31337: ENABLE
// missionTime := missionTime + 0 0$1 ;
31338: LD_ADDR_EXP 14
31342: PUSH
31343: LD_EXP 14
31347: PUSH
31348: LD_INT 35
31350: PLUS
31351: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
31352: LD_ADDR_OWVAR 47
31356: PUSH
31357: LD_STRING #Am15-1
31359: PUSH
31360: LD_EXP 14
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: ST_TO_ADDR
// end ; end_of_file
31369: END
// export function InitNature ; begin
31370: LD_INT 0
31372: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
31373: LD_INT 3
31375: PPUSH
31376: LD_INT 3
31378: PPUSH
31379: LD_INT 2
31381: PPUSH
31382: LD_INT 1
31384: PPUSH
31385: LD_INT 1
31387: PPUSH
31388: LD_INT 0
31390: PPUSH
31391: LD_INT 0
31393: PPUSH
31394: LD_INT 20
31396: PPUSH
31397: LD_INT 0
31399: PPUSH
31400: CALL 93855 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
31404: LD_INT 2
31406: PPUSH
31407: LD_INT 1
31409: PPUSH
31410: LD_INT 1
31412: PPUSH
31413: LD_INT 1
31415: PPUSH
31416: LD_INT 1
31418: PPUSH
31419: LD_INT 0
31421: PPUSH
31422: LD_INT 0
31424: PPUSH
31425: LD_INT 21
31427: PPUSH
31428: LD_INT 0
31430: PPUSH
31431: CALL 93855 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
31435: LD_INT 4
31437: PPUSH
31438: LD_INT 1
31440: PPUSH
31441: LD_INT 2
31443: PPUSH
31444: LD_INT 4
31446: PPUSH
31447: LD_INT 2
31449: PPUSH
31450: LD_INT 1
31452: PPUSH
31453: LD_INT 0
31455: PPUSH
31456: LD_INT 22
31458: PPUSH
31459: LD_INT 0
31461: PPUSH
31462: CALL 93855 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
31466: LD_INT 0
31468: PPUSH
31469: LD_INT 0
31471: PPUSH
31472: LD_INT 0
31474: PPUSH
31475: LD_INT 0
31477: PPUSH
31478: LD_INT 0
31480: PPUSH
31481: LD_INT 0
31483: PPUSH
31484: LD_INT 9
31486: PPUSH
31487: LD_INT 0
31489: PPUSH
31490: LD_INT 23
31492: PPUSH
31493: CALL 93855 0 9
// end ; end_of_file
31497: LD_VAR 0 1
31501: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
31502: GO 31504
31504: DISABLE
// begin ru_radar := 98 ;
31505: LD_ADDR_EXP 92
31509: PUSH
31510: LD_INT 98
31512: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
31513: LD_ADDR_EXP 93
31517: PUSH
31518: LD_INT 89
31520: ST_TO_ADDR
// us_hack := 99 ;
31521: LD_ADDR_EXP 94
31525: PUSH
31526: LD_INT 99
31528: ST_TO_ADDR
// us_artillery := 97 ;
31529: LD_ADDR_EXP 95
31533: PUSH
31534: LD_INT 97
31536: ST_TO_ADDR
// ar_bio_bomb := 91 ;
31537: LD_ADDR_EXP 96
31541: PUSH
31542: LD_INT 91
31544: ST_TO_ADDR
// end ; end_of_file
31545: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
31546: LD_INT 0
31548: PPUSH
31549: PPUSH
// skirmish := false ;
31550: LD_ADDR_EXP 97
31554: PUSH
31555: LD_INT 0
31557: ST_TO_ADDR
// debug_mc := false ;
31558: LD_ADDR_EXP 98
31562: PUSH
31563: LD_INT 0
31565: ST_TO_ADDR
// mc_bases := [ ] ;
31566: LD_ADDR_EXP 99
31570: PUSH
31571: EMPTY
31572: ST_TO_ADDR
// mc_sides := [ ] ;
31573: LD_ADDR_EXP 125
31577: PUSH
31578: EMPTY
31579: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
31580: LD_ADDR_EXP 100
31584: PUSH
31585: EMPTY
31586: ST_TO_ADDR
// mc_building_repairs := [ ] ;
31587: LD_ADDR_EXP 101
31591: PUSH
31592: EMPTY
31593: ST_TO_ADDR
// mc_need_heal := [ ] ;
31594: LD_ADDR_EXP 102
31598: PUSH
31599: EMPTY
31600: ST_TO_ADDR
// mc_healers := [ ] ;
31601: LD_ADDR_EXP 103
31605: PUSH
31606: EMPTY
31607: ST_TO_ADDR
// mc_build_list := [ ] ;
31608: LD_ADDR_EXP 104
31612: PUSH
31613: EMPTY
31614: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
31615: LD_ADDR_EXP 131
31619: PUSH
31620: EMPTY
31621: ST_TO_ADDR
// mc_builders := [ ] ;
31622: LD_ADDR_EXP 105
31626: PUSH
31627: EMPTY
31628: ST_TO_ADDR
// mc_construct_list := [ ] ;
31629: LD_ADDR_EXP 106
31633: PUSH
31634: EMPTY
31635: ST_TO_ADDR
// mc_turret_list := [ ] ;
31636: LD_ADDR_EXP 107
31640: PUSH
31641: EMPTY
31642: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
31643: LD_ADDR_EXP 108
31647: PUSH
31648: EMPTY
31649: ST_TO_ADDR
// mc_miners := [ ] ;
31650: LD_ADDR_EXP 113
31654: PUSH
31655: EMPTY
31656: ST_TO_ADDR
// mc_mines := [ ] ;
31657: LD_ADDR_EXP 112
31661: PUSH
31662: EMPTY
31663: ST_TO_ADDR
// mc_minefields := [ ] ;
31664: LD_ADDR_EXP 114
31668: PUSH
31669: EMPTY
31670: ST_TO_ADDR
// mc_crates := [ ] ;
31671: LD_ADDR_EXP 115
31675: PUSH
31676: EMPTY
31677: ST_TO_ADDR
// mc_crates_collector := [ ] ;
31678: LD_ADDR_EXP 116
31682: PUSH
31683: EMPTY
31684: ST_TO_ADDR
// mc_crates_area := [ ] ;
31685: LD_ADDR_EXP 117
31689: PUSH
31690: EMPTY
31691: ST_TO_ADDR
// mc_vehicles := [ ] ;
31692: LD_ADDR_EXP 118
31696: PUSH
31697: EMPTY
31698: ST_TO_ADDR
// mc_attack := [ ] ;
31699: LD_ADDR_EXP 119
31703: PUSH
31704: EMPTY
31705: ST_TO_ADDR
// mc_produce := [ ] ;
31706: LD_ADDR_EXP 120
31710: PUSH
31711: EMPTY
31712: ST_TO_ADDR
// mc_defender := [ ] ;
31713: LD_ADDR_EXP 121
31717: PUSH
31718: EMPTY
31719: ST_TO_ADDR
// mc_parking := [ ] ;
31720: LD_ADDR_EXP 123
31724: PUSH
31725: EMPTY
31726: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
31727: LD_ADDR_EXP 109
31731: PUSH
31732: EMPTY
31733: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
31734: LD_ADDR_EXP 111
31738: PUSH
31739: EMPTY
31740: ST_TO_ADDR
// mc_scan := [ ] ;
31741: LD_ADDR_EXP 122
31745: PUSH
31746: EMPTY
31747: ST_TO_ADDR
// mc_scan_area := [ ] ;
31748: LD_ADDR_EXP 124
31752: PUSH
31753: EMPTY
31754: ST_TO_ADDR
// mc_tech := [ ] ;
31755: LD_ADDR_EXP 126
31759: PUSH
31760: EMPTY
31761: ST_TO_ADDR
// mc_class := [ ] ;
31762: LD_ADDR_EXP 140
31766: PUSH
31767: EMPTY
31768: ST_TO_ADDR
// mc_class_case_use := [ ] ;
31769: LD_ADDR_EXP 141
31773: PUSH
31774: EMPTY
31775: ST_TO_ADDR
// end ;
31776: LD_VAR 0 1
31780: RET
// export function MC_Kill ( base ) ; begin
31781: LD_INT 0
31783: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
31784: LD_ADDR_EXP 99
31788: PUSH
31789: LD_EXP 99
31793: PPUSH
31794: LD_VAR 0 1
31798: PPUSH
31799: EMPTY
31800: PPUSH
31801: CALL_OW 1
31805: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
31806: LD_ADDR_EXP 100
31810: PUSH
31811: LD_EXP 100
31815: PPUSH
31816: LD_VAR 0 1
31820: PPUSH
31821: EMPTY
31822: PPUSH
31823: CALL_OW 1
31827: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
31828: LD_ADDR_EXP 101
31832: PUSH
31833: LD_EXP 101
31837: PPUSH
31838: LD_VAR 0 1
31842: PPUSH
31843: EMPTY
31844: PPUSH
31845: CALL_OW 1
31849: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
31850: LD_ADDR_EXP 102
31854: PUSH
31855: LD_EXP 102
31859: PPUSH
31860: LD_VAR 0 1
31864: PPUSH
31865: EMPTY
31866: PPUSH
31867: CALL_OW 1
31871: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
31872: LD_ADDR_EXP 103
31876: PUSH
31877: LD_EXP 103
31881: PPUSH
31882: LD_VAR 0 1
31886: PPUSH
31887: EMPTY
31888: PPUSH
31889: CALL_OW 1
31893: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
31894: LD_ADDR_EXP 104
31898: PUSH
31899: LD_EXP 104
31903: PPUSH
31904: LD_VAR 0 1
31908: PPUSH
31909: EMPTY
31910: PPUSH
31911: CALL_OW 1
31915: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
31916: LD_ADDR_EXP 105
31920: PUSH
31921: LD_EXP 105
31925: PPUSH
31926: LD_VAR 0 1
31930: PPUSH
31931: EMPTY
31932: PPUSH
31933: CALL_OW 1
31937: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
31938: LD_ADDR_EXP 106
31942: PUSH
31943: LD_EXP 106
31947: PPUSH
31948: LD_VAR 0 1
31952: PPUSH
31953: EMPTY
31954: PPUSH
31955: CALL_OW 1
31959: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
31960: LD_ADDR_EXP 107
31964: PUSH
31965: LD_EXP 107
31969: PPUSH
31970: LD_VAR 0 1
31974: PPUSH
31975: EMPTY
31976: PPUSH
31977: CALL_OW 1
31981: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
31982: LD_ADDR_EXP 108
31986: PUSH
31987: LD_EXP 108
31991: PPUSH
31992: LD_VAR 0 1
31996: PPUSH
31997: EMPTY
31998: PPUSH
31999: CALL_OW 1
32003: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
32004: LD_ADDR_EXP 109
32008: PUSH
32009: LD_EXP 109
32013: PPUSH
32014: LD_VAR 0 1
32018: PPUSH
32019: EMPTY
32020: PPUSH
32021: CALL_OW 1
32025: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
32026: LD_ADDR_EXP 110
32030: PUSH
32031: LD_EXP 110
32035: PPUSH
32036: LD_VAR 0 1
32040: PPUSH
32041: LD_INT 0
32043: PPUSH
32044: CALL_OW 1
32048: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
32049: LD_ADDR_EXP 111
32053: PUSH
32054: LD_EXP 111
32058: PPUSH
32059: LD_VAR 0 1
32063: PPUSH
32064: EMPTY
32065: PPUSH
32066: CALL_OW 1
32070: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
32071: LD_ADDR_EXP 112
32075: PUSH
32076: LD_EXP 112
32080: PPUSH
32081: LD_VAR 0 1
32085: PPUSH
32086: EMPTY
32087: PPUSH
32088: CALL_OW 1
32092: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
32093: LD_ADDR_EXP 113
32097: PUSH
32098: LD_EXP 113
32102: PPUSH
32103: LD_VAR 0 1
32107: PPUSH
32108: EMPTY
32109: PPUSH
32110: CALL_OW 1
32114: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
32115: LD_ADDR_EXP 114
32119: PUSH
32120: LD_EXP 114
32124: PPUSH
32125: LD_VAR 0 1
32129: PPUSH
32130: EMPTY
32131: PPUSH
32132: CALL_OW 1
32136: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
32137: LD_ADDR_EXP 115
32141: PUSH
32142: LD_EXP 115
32146: PPUSH
32147: LD_VAR 0 1
32151: PPUSH
32152: EMPTY
32153: PPUSH
32154: CALL_OW 1
32158: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
32159: LD_ADDR_EXP 116
32163: PUSH
32164: LD_EXP 116
32168: PPUSH
32169: LD_VAR 0 1
32173: PPUSH
32174: EMPTY
32175: PPUSH
32176: CALL_OW 1
32180: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
32181: LD_ADDR_EXP 117
32185: PUSH
32186: LD_EXP 117
32190: PPUSH
32191: LD_VAR 0 1
32195: PPUSH
32196: EMPTY
32197: PPUSH
32198: CALL_OW 1
32202: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
32203: LD_ADDR_EXP 118
32207: PUSH
32208: LD_EXP 118
32212: PPUSH
32213: LD_VAR 0 1
32217: PPUSH
32218: EMPTY
32219: PPUSH
32220: CALL_OW 1
32224: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
32225: LD_ADDR_EXP 119
32229: PUSH
32230: LD_EXP 119
32234: PPUSH
32235: LD_VAR 0 1
32239: PPUSH
32240: EMPTY
32241: PPUSH
32242: CALL_OW 1
32246: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
32247: LD_ADDR_EXP 120
32251: PUSH
32252: LD_EXP 120
32256: PPUSH
32257: LD_VAR 0 1
32261: PPUSH
32262: EMPTY
32263: PPUSH
32264: CALL_OW 1
32268: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
32269: LD_ADDR_EXP 121
32273: PUSH
32274: LD_EXP 121
32278: PPUSH
32279: LD_VAR 0 1
32283: PPUSH
32284: EMPTY
32285: PPUSH
32286: CALL_OW 1
32290: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
32291: LD_ADDR_EXP 122
32295: PUSH
32296: LD_EXP 122
32300: PPUSH
32301: LD_VAR 0 1
32305: PPUSH
32306: EMPTY
32307: PPUSH
32308: CALL_OW 1
32312: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
32313: LD_ADDR_EXP 123
32317: PUSH
32318: LD_EXP 123
32322: PPUSH
32323: LD_VAR 0 1
32327: PPUSH
32328: EMPTY
32329: PPUSH
32330: CALL_OW 1
32334: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
32335: LD_ADDR_EXP 124
32339: PUSH
32340: LD_EXP 124
32344: PPUSH
32345: LD_VAR 0 1
32349: PPUSH
32350: EMPTY
32351: PPUSH
32352: CALL_OW 1
32356: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
32357: LD_ADDR_EXP 126
32361: PUSH
32362: LD_EXP 126
32366: PPUSH
32367: LD_VAR 0 1
32371: PPUSH
32372: EMPTY
32373: PPUSH
32374: CALL_OW 1
32378: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
32379: LD_ADDR_EXP 128
32383: PUSH
32384: LD_EXP 128
32388: PPUSH
32389: LD_VAR 0 1
32393: PPUSH
32394: EMPTY
32395: PPUSH
32396: CALL_OW 1
32400: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
32401: LD_ADDR_EXP 129
32405: PUSH
32406: LD_EXP 129
32410: PPUSH
32411: LD_VAR 0 1
32415: PPUSH
32416: EMPTY
32417: PPUSH
32418: CALL_OW 1
32422: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
32423: LD_ADDR_EXP 130
32427: PUSH
32428: LD_EXP 130
32432: PPUSH
32433: LD_VAR 0 1
32437: PPUSH
32438: EMPTY
32439: PPUSH
32440: CALL_OW 1
32444: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
32445: LD_ADDR_EXP 131
32449: PUSH
32450: LD_EXP 131
32454: PPUSH
32455: LD_VAR 0 1
32459: PPUSH
32460: EMPTY
32461: PPUSH
32462: CALL_OW 1
32466: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
32467: LD_ADDR_EXP 132
32471: PUSH
32472: LD_EXP 132
32476: PPUSH
32477: LD_VAR 0 1
32481: PPUSH
32482: EMPTY
32483: PPUSH
32484: CALL_OW 1
32488: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
32489: LD_ADDR_EXP 133
32493: PUSH
32494: LD_EXP 133
32498: PPUSH
32499: LD_VAR 0 1
32503: PPUSH
32504: EMPTY
32505: PPUSH
32506: CALL_OW 1
32510: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
32511: LD_ADDR_EXP 134
32515: PUSH
32516: LD_EXP 134
32520: PPUSH
32521: LD_VAR 0 1
32525: PPUSH
32526: EMPTY
32527: PPUSH
32528: CALL_OW 1
32532: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
32533: LD_ADDR_EXP 135
32537: PUSH
32538: LD_EXP 135
32542: PPUSH
32543: LD_VAR 0 1
32547: PPUSH
32548: EMPTY
32549: PPUSH
32550: CALL_OW 1
32554: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
32555: LD_ADDR_EXP 136
32559: PUSH
32560: LD_EXP 136
32564: PPUSH
32565: LD_VAR 0 1
32569: PPUSH
32570: EMPTY
32571: PPUSH
32572: CALL_OW 1
32576: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
32577: LD_ADDR_EXP 137
32581: PUSH
32582: LD_EXP 137
32586: PPUSH
32587: LD_VAR 0 1
32591: PPUSH
32592: EMPTY
32593: PPUSH
32594: CALL_OW 1
32598: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
32599: LD_ADDR_EXP 138
32603: PUSH
32604: LD_EXP 138
32608: PPUSH
32609: LD_VAR 0 1
32613: PPUSH
32614: EMPTY
32615: PPUSH
32616: CALL_OW 1
32620: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
32621: LD_ADDR_EXP 139
32625: PUSH
32626: LD_EXP 139
32630: PPUSH
32631: LD_VAR 0 1
32635: PPUSH
32636: EMPTY
32637: PPUSH
32638: CALL_OW 1
32642: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
32643: LD_ADDR_EXP 140
32647: PUSH
32648: LD_EXP 140
32652: PPUSH
32653: LD_VAR 0 1
32657: PPUSH
32658: EMPTY
32659: PPUSH
32660: CALL_OW 1
32664: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
32665: LD_ADDR_EXP 141
32669: PUSH
32670: LD_EXP 141
32674: PPUSH
32675: LD_VAR 0 1
32679: PPUSH
32680: LD_INT 0
32682: PPUSH
32683: CALL_OW 1
32687: ST_TO_ADDR
// end ;
32688: LD_VAR 0 2
32692: RET
// export function MC_Start ( ) ; var i ; begin
32693: LD_INT 0
32695: PPUSH
32696: PPUSH
// for i = 1 to mc_bases do
32697: LD_ADDR_VAR 0 2
32701: PUSH
32702: DOUBLE
32703: LD_INT 1
32705: DEC
32706: ST_TO_ADDR
32707: LD_EXP 99
32711: PUSH
32712: FOR_TO
32713: IFFALSE 33790
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
32715: LD_ADDR_EXP 99
32719: PUSH
32720: LD_EXP 99
32724: PPUSH
32725: LD_VAR 0 2
32729: PPUSH
32730: LD_EXP 99
32734: PUSH
32735: LD_VAR 0 2
32739: ARRAY
32740: PUSH
32741: LD_INT 0
32743: DIFF
32744: PPUSH
32745: CALL_OW 1
32749: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
32750: LD_ADDR_EXP 100
32754: PUSH
32755: LD_EXP 100
32759: PPUSH
32760: LD_VAR 0 2
32764: PPUSH
32765: EMPTY
32766: PPUSH
32767: CALL_OW 1
32771: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
32772: LD_ADDR_EXP 101
32776: PUSH
32777: LD_EXP 101
32781: PPUSH
32782: LD_VAR 0 2
32786: PPUSH
32787: EMPTY
32788: PPUSH
32789: CALL_OW 1
32793: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
32794: LD_ADDR_EXP 102
32798: PUSH
32799: LD_EXP 102
32803: PPUSH
32804: LD_VAR 0 2
32808: PPUSH
32809: EMPTY
32810: PPUSH
32811: CALL_OW 1
32815: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
32816: LD_ADDR_EXP 103
32820: PUSH
32821: LD_EXP 103
32825: PPUSH
32826: LD_VAR 0 2
32830: PPUSH
32831: EMPTY
32832: PUSH
32833: EMPTY
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PPUSH
32839: CALL_OW 1
32843: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
32844: LD_ADDR_EXP 104
32848: PUSH
32849: LD_EXP 104
32853: PPUSH
32854: LD_VAR 0 2
32858: PPUSH
32859: EMPTY
32860: PPUSH
32861: CALL_OW 1
32865: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
32866: LD_ADDR_EXP 131
32870: PUSH
32871: LD_EXP 131
32875: PPUSH
32876: LD_VAR 0 2
32880: PPUSH
32881: EMPTY
32882: PPUSH
32883: CALL_OW 1
32887: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
32888: LD_ADDR_EXP 105
32892: PUSH
32893: LD_EXP 105
32897: PPUSH
32898: LD_VAR 0 2
32902: PPUSH
32903: EMPTY
32904: PPUSH
32905: CALL_OW 1
32909: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
32910: LD_ADDR_EXP 106
32914: PUSH
32915: LD_EXP 106
32919: PPUSH
32920: LD_VAR 0 2
32924: PPUSH
32925: EMPTY
32926: PPUSH
32927: CALL_OW 1
32931: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
32932: LD_ADDR_EXP 107
32936: PUSH
32937: LD_EXP 107
32941: PPUSH
32942: LD_VAR 0 2
32946: PPUSH
32947: LD_EXP 99
32951: PUSH
32952: LD_VAR 0 2
32956: ARRAY
32957: PPUSH
32958: LD_INT 2
32960: PUSH
32961: LD_INT 30
32963: PUSH
32964: LD_INT 32
32966: PUSH
32967: EMPTY
32968: LIST
32969: LIST
32970: PUSH
32971: LD_INT 30
32973: PUSH
32974: LD_INT 33
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: EMPTY
32982: LIST
32983: LIST
32984: LIST
32985: PPUSH
32986: CALL_OW 72
32990: PPUSH
32991: CALL_OW 1
32995: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
32996: LD_ADDR_EXP 108
33000: PUSH
33001: LD_EXP 108
33005: PPUSH
33006: LD_VAR 0 2
33010: PPUSH
33011: LD_EXP 99
33015: PUSH
33016: LD_VAR 0 2
33020: ARRAY
33021: PPUSH
33022: LD_INT 2
33024: PUSH
33025: LD_INT 30
33027: PUSH
33028: LD_INT 32
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 30
33037: PUSH
33038: LD_INT 31
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 58
33052: PUSH
33053: EMPTY
33054: LIST
33055: PUSH
33056: EMPTY
33057: LIST
33058: LIST
33059: PPUSH
33060: CALL_OW 72
33064: PPUSH
33065: CALL_OW 1
33069: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
33070: LD_ADDR_EXP 109
33074: PUSH
33075: LD_EXP 109
33079: PPUSH
33080: LD_VAR 0 2
33084: PPUSH
33085: EMPTY
33086: PPUSH
33087: CALL_OW 1
33091: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
33092: LD_ADDR_EXP 113
33096: PUSH
33097: LD_EXP 113
33101: PPUSH
33102: LD_VAR 0 2
33106: PPUSH
33107: EMPTY
33108: PPUSH
33109: CALL_OW 1
33113: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
33114: LD_ADDR_EXP 112
33118: PUSH
33119: LD_EXP 112
33123: PPUSH
33124: LD_VAR 0 2
33128: PPUSH
33129: EMPTY
33130: PPUSH
33131: CALL_OW 1
33135: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
33136: LD_ADDR_EXP 114
33140: PUSH
33141: LD_EXP 114
33145: PPUSH
33146: LD_VAR 0 2
33150: PPUSH
33151: EMPTY
33152: PPUSH
33153: CALL_OW 1
33157: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
33158: LD_ADDR_EXP 115
33162: PUSH
33163: LD_EXP 115
33167: PPUSH
33168: LD_VAR 0 2
33172: PPUSH
33173: EMPTY
33174: PPUSH
33175: CALL_OW 1
33179: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
33180: LD_ADDR_EXP 116
33184: PUSH
33185: LD_EXP 116
33189: PPUSH
33190: LD_VAR 0 2
33194: PPUSH
33195: EMPTY
33196: PPUSH
33197: CALL_OW 1
33201: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
33202: LD_ADDR_EXP 117
33206: PUSH
33207: LD_EXP 117
33211: PPUSH
33212: LD_VAR 0 2
33216: PPUSH
33217: EMPTY
33218: PPUSH
33219: CALL_OW 1
33223: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
33224: LD_ADDR_EXP 118
33228: PUSH
33229: LD_EXP 118
33233: PPUSH
33234: LD_VAR 0 2
33238: PPUSH
33239: EMPTY
33240: PPUSH
33241: CALL_OW 1
33245: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33246: LD_ADDR_EXP 119
33250: PUSH
33251: LD_EXP 119
33255: PPUSH
33256: LD_VAR 0 2
33260: PPUSH
33261: EMPTY
33262: PPUSH
33263: CALL_OW 1
33267: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
33268: LD_ADDR_EXP 120
33272: PUSH
33273: LD_EXP 120
33277: PPUSH
33278: LD_VAR 0 2
33282: PPUSH
33283: EMPTY
33284: PPUSH
33285: CALL_OW 1
33289: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
33290: LD_ADDR_EXP 121
33294: PUSH
33295: LD_EXP 121
33299: PPUSH
33300: LD_VAR 0 2
33304: PPUSH
33305: EMPTY
33306: PPUSH
33307: CALL_OW 1
33311: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
33312: LD_ADDR_EXP 110
33316: PUSH
33317: LD_EXP 110
33321: PPUSH
33322: LD_VAR 0 2
33326: PPUSH
33327: LD_INT 0
33329: PPUSH
33330: CALL_OW 1
33334: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
33335: LD_ADDR_EXP 123
33339: PUSH
33340: LD_EXP 123
33344: PPUSH
33345: LD_VAR 0 2
33349: PPUSH
33350: LD_INT 0
33352: PPUSH
33353: CALL_OW 1
33357: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
33358: LD_ADDR_EXP 111
33362: PUSH
33363: LD_EXP 111
33367: PPUSH
33368: LD_VAR 0 2
33372: PPUSH
33373: EMPTY
33374: PPUSH
33375: CALL_OW 1
33379: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
33380: LD_ADDR_EXP 122
33384: PUSH
33385: LD_EXP 122
33389: PPUSH
33390: LD_VAR 0 2
33394: PPUSH
33395: LD_INT 0
33397: PPUSH
33398: CALL_OW 1
33402: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
33403: LD_ADDR_EXP 124
33407: PUSH
33408: LD_EXP 124
33412: PPUSH
33413: LD_VAR 0 2
33417: PPUSH
33418: EMPTY
33419: PPUSH
33420: CALL_OW 1
33424: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
33425: LD_ADDR_EXP 127
33429: PUSH
33430: LD_EXP 127
33434: PPUSH
33435: LD_VAR 0 2
33439: PPUSH
33440: LD_INT 0
33442: PPUSH
33443: CALL_OW 1
33447: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
33448: LD_ADDR_EXP 128
33452: PUSH
33453: LD_EXP 128
33457: PPUSH
33458: LD_VAR 0 2
33462: PPUSH
33463: EMPTY
33464: PPUSH
33465: CALL_OW 1
33469: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
33470: LD_ADDR_EXP 129
33474: PUSH
33475: LD_EXP 129
33479: PPUSH
33480: LD_VAR 0 2
33484: PPUSH
33485: EMPTY
33486: PPUSH
33487: CALL_OW 1
33491: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
33492: LD_ADDR_EXP 130
33496: PUSH
33497: LD_EXP 130
33501: PPUSH
33502: LD_VAR 0 2
33506: PPUSH
33507: EMPTY
33508: PPUSH
33509: CALL_OW 1
33513: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
33514: LD_ADDR_EXP 132
33518: PUSH
33519: LD_EXP 132
33523: PPUSH
33524: LD_VAR 0 2
33528: PPUSH
33529: LD_EXP 99
33533: PUSH
33534: LD_VAR 0 2
33538: ARRAY
33539: PPUSH
33540: LD_INT 2
33542: PUSH
33543: LD_INT 30
33545: PUSH
33546: LD_INT 6
33548: PUSH
33549: EMPTY
33550: LIST
33551: LIST
33552: PUSH
33553: LD_INT 30
33555: PUSH
33556: LD_INT 7
33558: PUSH
33559: EMPTY
33560: LIST
33561: LIST
33562: PUSH
33563: LD_INT 30
33565: PUSH
33566: LD_INT 8
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: EMPTY
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: PPUSH
33579: CALL_OW 72
33583: PPUSH
33584: CALL_OW 1
33588: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
33589: LD_ADDR_EXP 133
33593: PUSH
33594: LD_EXP 133
33598: PPUSH
33599: LD_VAR 0 2
33603: PPUSH
33604: EMPTY
33605: PPUSH
33606: CALL_OW 1
33610: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
33611: LD_ADDR_EXP 134
33615: PUSH
33616: LD_EXP 134
33620: PPUSH
33621: LD_VAR 0 2
33625: PPUSH
33626: EMPTY
33627: PPUSH
33628: CALL_OW 1
33632: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
33633: LD_ADDR_EXP 135
33637: PUSH
33638: LD_EXP 135
33642: PPUSH
33643: LD_VAR 0 2
33647: PPUSH
33648: EMPTY
33649: PPUSH
33650: CALL_OW 1
33654: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
33655: LD_ADDR_EXP 136
33659: PUSH
33660: LD_EXP 136
33664: PPUSH
33665: LD_VAR 0 2
33669: PPUSH
33670: EMPTY
33671: PPUSH
33672: CALL_OW 1
33676: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
33677: LD_ADDR_EXP 137
33681: PUSH
33682: LD_EXP 137
33686: PPUSH
33687: LD_VAR 0 2
33691: PPUSH
33692: EMPTY
33693: PPUSH
33694: CALL_OW 1
33698: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
33699: LD_ADDR_EXP 138
33703: PUSH
33704: LD_EXP 138
33708: PPUSH
33709: LD_VAR 0 2
33713: PPUSH
33714: EMPTY
33715: PPUSH
33716: CALL_OW 1
33720: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
33721: LD_ADDR_EXP 139
33725: PUSH
33726: LD_EXP 139
33730: PPUSH
33731: LD_VAR 0 2
33735: PPUSH
33736: EMPTY
33737: PPUSH
33738: CALL_OW 1
33742: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
33743: LD_ADDR_EXP 140
33747: PUSH
33748: LD_EXP 140
33752: PPUSH
33753: LD_VAR 0 2
33757: PPUSH
33758: EMPTY
33759: PPUSH
33760: CALL_OW 1
33764: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
33765: LD_ADDR_EXP 141
33769: PUSH
33770: LD_EXP 141
33774: PPUSH
33775: LD_VAR 0 2
33779: PPUSH
33780: LD_INT 0
33782: PPUSH
33783: CALL_OW 1
33787: ST_TO_ADDR
// end ;
33788: GO 32712
33790: POP
33791: POP
// MC_InitSides ( ) ;
33792: CALL 34078 0 0
// MC_InitResearch ( ) ;
33796: CALL 33817 0 0
// CustomInitMacro ( ) ;
33800: CALL 437 0 0
// skirmish := true ;
33804: LD_ADDR_EXP 97
33808: PUSH
33809: LD_INT 1
33811: ST_TO_ADDR
// end ;
33812: LD_VAR 0 1
33816: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
33817: LD_INT 0
33819: PPUSH
33820: PPUSH
33821: PPUSH
33822: PPUSH
33823: PPUSH
33824: PPUSH
// if not mc_bases then
33825: LD_EXP 99
33829: NOT
33830: IFFALSE 33834
// exit ;
33832: GO 34073
// for i = 1 to 8 do
33834: LD_ADDR_VAR 0 2
33838: PUSH
33839: DOUBLE
33840: LD_INT 1
33842: DEC
33843: ST_TO_ADDR
33844: LD_INT 8
33846: PUSH
33847: FOR_TO
33848: IFFALSE 33874
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
33850: LD_ADDR_EXP 126
33854: PUSH
33855: LD_EXP 126
33859: PPUSH
33860: LD_VAR 0 2
33864: PPUSH
33865: EMPTY
33866: PPUSH
33867: CALL_OW 1
33871: ST_TO_ADDR
33872: GO 33847
33874: POP
33875: POP
// tmp := [ ] ;
33876: LD_ADDR_VAR 0 5
33880: PUSH
33881: EMPTY
33882: ST_TO_ADDR
// for i = 1 to mc_sides do
33883: LD_ADDR_VAR 0 2
33887: PUSH
33888: DOUBLE
33889: LD_INT 1
33891: DEC
33892: ST_TO_ADDR
33893: LD_EXP 125
33897: PUSH
33898: FOR_TO
33899: IFFALSE 33957
// if not mc_sides [ i ] in tmp then
33901: LD_EXP 125
33905: PUSH
33906: LD_VAR 0 2
33910: ARRAY
33911: PUSH
33912: LD_VAR 0 5
33916: IN
33917: NOT
33918: IFFALSE 33955
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
33920: LD_ADDR_VAR 0 5
33924: PUSH
33925: LD_VAR 0 5
33929: PPUSH
33930: LD_VAR 0 5
33934: PUSH
33935: LD_INT 1
33937: PLUS
33938: PPUSH
33939: LD_EXP 125
33943: PUSH
33944: LD_VAR 0 2
33948: ARRAY
33949: PPUSH
33950: CALL_OW 2
33954: ST_TO_ADDR
33955: GO 33898
33957: POP
33958: POP
// if not tmp then
33959: LD_VAR 0 5
33963: NOT
33964: IFFALSE 33968
// exit ;
33966: GO 34073
// for j in tmp do
33968: LD_ADDR_VAR 0 3
33972: PUSH
33973: LD_VAR 0 5
33977: PUSH
33978: FOR_IN
33979: IFFALSE 34071
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
33981: LD_ADDR_VAR 0 6
33985: PUSH
33986: LD_INT 22
33988: PUSH
33989: LD_VAR 0 3
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PPUSH
33998: CALL_OW 69
34002: ST_TO_ADDR
// if not un then
34003: LD_VAR 0 6
34007: NOT
34008: IFFALSE 34012
// continue ;
34010: GO 33978
// nation := GetNation ( un [ 1 ] ) ;
34012: LD_ADDR_VAR 0 4
34016: PUSH
34017: LD_VAR 0 6
34021: PUSH
34022: LD_INT 1
34024: ARRAY
34025: PPUSH
34026: CALL_OW 248
34030: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
34031: LD_ADDR_EXP 126
34035: PUSH
34036: LD_EXP 126
34040: PPUSH
34041: LD_VAR 0 3
34045: PPUSH
34046: LD_VAR 0 3
34050: PPUSH
34051: LD_VAR 0 4
34055: PPUSH
34056: LD_INT 1
34058: PPUSH
34059: CALL 59495 0 3
34063: PPUSH
34064: CALL_OW 1
34068: ST_TO_ADDR
// end ;
34069: GO 33978
34071: POP
34072: POP
// end ;
34073: LD_VAR 0 1
34077: RET
// export function MC_InitSides ( ) ; var i ; begin
34078: LD_INT 0
34080: PPUSH
34081: PPUSH
// if not mc_bases then
34082: LD_EXP 99
34086: NOT
34087: IFFALSE 34091
// exit ;
34089: GO 34165
// for i = 1 to mc_bases do
34091: LD_ADDR_VAR 0 2
34095: PUSH
34096: DOUBLE
34097: LD_INT 1
34099: DEC
34100: ST_TO_ADDR
34101: LD_EXP 99
34105: PUSH
34106: FOR_TO
34107: IFFALSE 34163
// if mc_bases [ i ] then
34109: LD_EXP 99
34113: PUSH
34114: LD_VAR 0 2
34118: ARRAY
34119: IFFALSE 34161
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
34121: LD_ADDR_EXP 125
34125: PUSH
34126: LD_EXP 125
34130: PPUSH
34131: LD_VAR 0 2
34135: PPUSH
34136: LD_EXP 99
34140: PUSH
34141: LD_VAR 0 2
34145: ARRAY
34146: PUSH
34147: LD_INT 1
34149: ARRAY
34150: PPUSH
34151: CALL_OW 255
34155: PPUSH
34156: CALL_OW 1
34160: ST_TO_ADDR
34161: GO 34106
34163: POP
34164: POP
// end ;
34165: LD_VAR 0 1
34169: RET
// every 0 0$01 trigger skirmish do
34170: LD_EXP 97
34174: IFFALSE 34328
34176: GO 34178
34178: DISABLE
// begin enable ;
34179: ENABLE
// MC_CheckBuildings ( ) ;
34180: CALL 38494 0 0
// MC_CheckPeopleLife ( ) ;
34184: CALL 38619 0 0
// RaiseSailEvent ( 100 ) ;
34188: LD_INT 100
34190: PPUSH
34191: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
34195: LD_INT 103
34197: PPUSH
34198: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
34202: LD_INT 104
34204: PPUSH
34205: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
34209: LD_INT 105
34211: PPUSH
34212: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
34216: LD_INT 106
34218: PPUSH
34219: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
34223: LD_INT 107
34225: PPUSH
34226: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
34230: LD_INT 108
34232: PPUSH
34233: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
34237: LD_INT 109
34239: PPUSH
34240: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
34244: LD_INT 110
34246: PPUSH
34247: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
34251: LD_INT 111
34253: PPUSH
34254: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
34258: LD_INT 112
34260: PPUSH
34261: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
34265: LD_INT 113
34267: PPUSH
34268: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
34272: LD_INT 120
34274: PPUSH
34275: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
34279: LD_INT 121
34281: PPUSH
34282: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
34286: LD_INT 122
34288: PPUSH
34289: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
34293: LD_INT 123
34295: PPUSH
34296: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
34300: LD_INT 124
34302: PPUSH
34303: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
34307: LD_INT 125
34309: PPUSH
34310: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
34314: LD_INT 126
34316: PPUSH
34317: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
34321: LD_INT 200
34323: PPUSH
34324: CALL_OW 427
// end ;
34328: END
// on SailEvent ( event ) do begin if event < 100 then
34329: LD_VAR 0 1
34333: PUSH
34334: LD_INT 100
34336: LESS
34337: IFFALSE 34348
// CustomEvent ( event ) ;
34339: LD_VAR 0 1
34343: PPUSH
34344: CALL 30150 0 1
// if event = 100 then
34348: LD_VAR 0 1
34352: PUSH
34353: LD_INT 100
34355: EQUAL
34356: IFFALSE 34362
// MC_ClassManager ( ) ;
34358: CALL 34754 0 0
// if event = 101 then
34362: LD_VAR 0 1
34366: PUSH
34367: LD_INT 101
34369: EQUAL
34370: IFFALSE 34376
// MC_RepairBuildings ( ) ;
34372: CALL 39215 0 0
// if event = 102 then
34376: LD_VAR 0 1
34380: PUSH
34381: LD_INT 102
34383: EQUAL
34384: IFFALSE 34390
// MC_Heal ( ) ;
34386: CALL 39621 0 0
// if event = 103 then
34390: LD_VAR 0 1
34394: PUSH
34395: LD_INT 103
34397: EQUAL
34398: IFFALSE 34404
// MC_Build ( ) ;
34400: CALL 40043 0 0
// if event = 104 then
34404: LD_VAR 0 1
34408: PUSH
34409: LD_INT 104
34411: EQUAL
34412: IFFALSE 34418
// MC_TurretWeapon ( ) ;
34414: CALL 41656 0 0
// if event = 105 then
34418: LD_VAR 0 1
34422: PUSH
34423: LD_INT 105
34425: EQUAL
34426: IFFALSE 34432
// MC_BuildUpgrade ( ) ;
34428: CALL 41207 0 0
// if event = 106 then
34432: LD_VAR 0 1
34436: PUSH
34437: LD_INT 106
34439: EQUAL
34440: IFFALSE 34446
// MC_PlantMines ( ) ;
34442: CALL 42086 0 0
// if event = 107 then
34446: LD_VAR 0 1
34450: PUSH
34451: LD_INT 107
34453: EQUAL
34454: IFFALSE 34460
// MC_CollectCrates ( ) ;
34456: CALL 43120 0 0
// if event = 108 then
34460: LD_VAR 0 1
34464: PUSH
34465: LD_INT 108
34467: EQUAL
34468: IFFALSE 34474
// MC_LinkRemoteControl ( ) ;
34470: CALL 44877 0 0
// if event = 109 then
34474: LD_VAR 0 1
34478: PUSH
34479: LD_INT 109
34481: EQUAL
34482: IFFALSE 34488
// MC_ProduceVehicle ( ) ;
34484: CALL 45058 0 0
// if event = 110 then
34488: LD_VAR 0 1
34492: PUSH
34493: LD_INT 110
34495: EQUAL
34496: IFFALSE 34502
// MC_SendAttack ( ) ;
34498: CALL 45539 0 0
// if event = 111 then
34502: LD_VAR 0 1
34506: PUSH
34507: LD_INT 111
34509: EQUAL
34510: IFFALSE 34516
// MC_Defend ( ) ;
34512: CALL 45647 0 0
// if event = 112 then
34516: LD_VAR 0 1
34520: PUSH
34521: LD_INT 112
34523: EQUAL
34524: IFFALSE 34530
// MC_Research ( ) ;
34526: CALL 46274 0 0
// if event = 113 then
34530: LD_VAR 0 1
34534: PUSH
34535: LD_INT 113
34537: EQUAL
34538: IFFALSE 34544
// MC_MinesTrigger ( ) ;
34540: CALL 47388 0 0
// if event = 120 then
34544: LD_VAR 0 1
34548: PUSH
34549: LD_INT 120
34551: EQUAL
34552: IFFALSE 34558
// MC_RepairVehicle ( ) ;
34554: CALL 47487 0 0
// if event = 121 then
34558: LD_VAR 0 1
34562: PUSH
34563: LD_INT 121
34565: EQUAL
34566: IFFALSE 34572
// MC_TameApe ( ) ;
34568: CALL 48230 0 0
// if event = 122 then
34572: LD_VAR 0 1
34576: PUSH
34577: LD_INT 122
34579: EQUAL
34580: IFFALSE 34586
// MC_ChangeApeClass ( ) ;
34582: CALL 49059 0 0
// if event = 123 then
34586: LD_VAR 0 1
34590: PUSH
34591: LD_INT 123
34593: EQUAL
34594: IFFALSE 34600
// MC_Bazooka ( ) ;
34596: CALL 49709 0 0
// if event = 124 then
34600: LD_VAR 0 1
34604: PUSH
34605: LD_INT 124
34607: EQUAL
34608: IFFALSE 34614
// MC_TeleportExit ( ) ;
34610: CALL 49907 0 0
// if event = 125 then
34614: LD_VAR 0 1
34618: PUSH
34619: LD_INT 125
34621: EQUAL
34622: IFFALSE 34628
// MC_Deposits ( ) ;
34624: CALL 50554 0 0
// if event = 126 then
34628: LD_VAR 0 1
34632: PUSH
34633: LD_INT 126
34635: EQUAL
34636: IFFALSE 34642
// MC_RemoteDriver ( ) ;
34638: CALL 51179 0 0
// if event = 200 then
34642: LD_VAR 0 1
34646: PUSH
34647: LD_INT 200
34649: EQUAL
34650: IFFALSE 34656
// MC_Idle ( ) ;
34652: CALL 52912 0 0
// end ;
34656: PPOPN 1
34658: END
// export function MC_Reset ( base , tag ) ; var i ; begin
34659: LD_INT 0
34661: PPUSH
34662: PPUSH
// if not mc_bases [ base ] or not tag then
34663: LD_EXP 99
34667: PUSH
34668: LD_VAR 0 1
34672: ARRAY
34673: NOT
34674: PUSH
34675: LD_VAR 0 2
34679: NOT
34680: OR
34681: IFFALSE 34685
// exit ;
34683: GO 34749
// for i in mc_bases [ base ] union mc_ape [ base ] do
34685: LD_ADDR_VAR 0 4
34689: PUSH
34690: LD_EXP 99
34694: PUSH
34695: LD_VAR 0 1
34699: ARRAY
34700: PUSH
34701: LD_EXP 128
34705: PUSH
34706: LD_VAR 0 1
34710: ARRAY
34711: UNION
34712: PUSH
34713: FOR_IN
34714: IFFALSE 34747
// if GetTag ( i ) = tag then
34716: LD_VAR 0 4
34720: PPUSH
34721: CALL_OW 110
34725: PUSH
34726: LD_VAR 0 2
34730: EQUAL
34731: IFFALSE 34745
// SetTag ( i , 0 ) ;
34733: LD_VAR 0 4
34737: PPUSH
34738: LD_INT 0
34740: PPUSH
34741: CALL_OW 109
34745: GO 34713
34747: POP
34748: POP
// end ;
34749: LD_VAR 0 3
34753: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
34754: LD_INT 0
34756: PPUSH
34757: PPUSH
34758: PPUSH
34759: PPUSH
34760: PPUSH
34761: PPUSH
34762: PPUSH
34763: PPUSH
// if not mc_bases then
34764: LD_EXP 99
34768: NOT
34769: IFFALSE 34773
// exit ;
34771: GO 35231
// for i = 1 to mc_bases do
34773: LD_ADDR_VAR 0 2
34777: PUSH
34778: DOUBLE
34779: LD_INT 1
34781: DEC
34782: ST_TO_ADDR
34783: LD_EXP 99
34787: PUSH
34788: FOR_TO
34789: IFFALSE 35229
// begin tmp := MC_ClassCheckReq ( i ) ;
34791: LD_ADDR_VAR 0 4
34795: PUSH
34796: LD_VAR 0 2
34800: PPUSH
34801: CALL 35236 0 1
34805: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
34806: LD_ADDR_EXP 140
34810: PUSH
34811: LD_EXP 140
34815: PPUSH
34816: LD_VAR 0 2
34820: PPUSH
34821: LD_VAR 0 4
34825: PPUSH
34826: CALL_OW 1
34830: ST_TO_ADDR
// if not tmp then
34831: LD_VAR 0 4
34835: NOT
34836: IFFALSE 34840
// continue ;
34838: GO 34788
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
34840: LD_ADDR_VAR 0 6
34844: PUSH
34845: LD_EXP 99
34849: PUSH
34850: LD_VAR 0 2
34854: ARRAY
34855: PPUSH
34856: LD_INT 2
34858: PUSH
34859: LD_INT 30
34861: PUSH
34862: LD_INT 4
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 30
34871: PUSH
34872: LD_INT 5
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: LIST
34883: PPUSH
34884: CALL_OW 72
34888: PUSH
34889: LD_EXP 99
34893: PUSH
34894: LD_VAR 0 2
34898: ARRAY
34899: PPUSH
34900: LD_INT 2
34902: PUSH
34903: LD_INT 30
34905: PUSH
34906: LD_INT 0
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 30
34915: PUSH
34916: LD_INT 1
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: LIST
34927: PPUSH
34928: CALL_OW 72
34932: PUSH
34933: LD_EXP 99
34937: PUSH
34938: LD_VAR 0 2
34942: ARRAY
34943: PPUSH
34944: LD_INT 30
34946: PUSH
34947: LD_INT 3
34949: PUSH
34950: EMPTY
34951: LIST
34952: LIST
34953: PPUSH
34954: CALL_OW 72
34958: PUSH
34959: LD_EXP 99
34963: PUSH
34964: LD_VAR 0 2
34968: ARRAY
34969: PPUSH
34970: LD_INT 2
34972: PUSH
34973: LD_INT 30
34975: PUSH
34976: LD_INT 6
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 30
34985: PUSH
34986: LD_INT 7
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 30
34995: PUSH
34996: LD_INT 8
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: LIST
35007: LIST
35008: PPUSH
35009: CALL_OW 72
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: ST_TO_ADDR
// for j = 1 to 4 do
35020: LD_ADDR_VAR 0 3
35024: PUSH
35025: DOUBLE
35026: LD_INT 1
35028: DEC
35029: ST_TO_ADDR
35030: LD_INT 4
35032: PUSH
35033: FOR_TO
35034: IFFALSE 35225
// begin if not tmp [ j ] then
35036: LD_VAR 0 4
35040: PUSH
35041: LD_VAR 0 3
35045: ARRAY
35046: NOT
35047: IFFALSE 35051
// continue ;
35049: GO 35033
// for p in tmp [ j ] do
35051: LD_ADDR_VAR 0 5
35055: PUSH
35056: LD_VAR 0 4
35060: PUSH
35061: LD_VAR 0 3
35065: ARRAY
35066: PUSH
35067: FOR_IN
35068: IFFALSE 35221
// begin if not b [ j ] then
35070: LD_VAR 0 6
35074: PUSH
35075: LD_VAR 0 3
35079: ARRAY
35080: NOT
35081: IFFALSE 35085
// break ;
35083: GO 35221
// e := 0 ;
35085: LD_ADDR_VAR 0 7
35089: PUSH
35090: LD_INT 0
35092: ST_TO_ADDR
// for k in b [ j ] do
35093: LD_ADDR_VAR 0 8
35097: PUSH
35098: LD_VAR 0 6
35102: PUSH
35103: LD_VAR 0 3
35107: ARRAY
35108: PUSH
35109: FOR_IN
35110: IFFALSE 35137
// if IsNotFull ( k ) then
35112: LD_VAR 0 8
35116: PPUSH
35117: CALL 63521 0 1
35121: IFFALSE 35135
// begin e := k ;
35123: LD_ADDR_VAR 0 7
35127: PUSH
35128: LD_VAR 0 8
35132: ST_TO_ADDR
// break ;
35133: GO 35137
// end ;
35135: GO 35109
35137: POP
35138: POP
// if e and not UnitGoingToBuilding ( p , e ) then
35139: LD_VAR 0 7
35143: PUSH
35144: LD_VAR 0 5
35148: PPUSH
35149: LD_VAR 0 7
35153: PPUSH
35154: CALL 100509 0 2
35158: NOT
35159: AND
35160: IFFALSE 35219
// begin if IsInUnit ( p ) then
35162: LD_VAR 0 5
35166: PPUSH
35167: CALL_OW 310
35171: IFFALSE 35182
// ComExitBuilding ( p ) ;
35173: LD_VAR 0 5
35177: PPUSH
35178: CALL_OW 122
// ComEnterUnit ( p , e ) ;
35182: LD_VAR 0 5
35186: PPUSH
35187: LD_VAR 0 7
35191: PPUSH
35192: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
35196: LD_VAR 0 5
35200: PPUSH
35201: LD_VAR 0 3
35205: PPUSH
35206: CALL_OW 183
// AddComExitBuilding ( p ) ;
35210: LD_VAR 0 5
35214: PPUSH
35215: CALL_OW 182
// end ; end ;
35219: GO 35067
35221: POP
35222: POP
// end ;
35223: GO 35033
35225: POP
35226: POP
// end ;
35227: GO 34788
35229: POP
35230: POP
// end ;
35231: LD_VAR 0 1
35235: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
35236: LD_INT 0
35238: PPUSH
35239: PPUSH
35240: PPUSH
35241: PPUSH
35242: PPUSH
35243: PPUSH
35244: PPUSH
35245: PPUSH
35246: PPUSH
35247: PPUSH
35248: PPUSH
35249: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
35250: LD_VAR 0 1
35254: NOT
35255: PUSH
35256: LD_EXP 99
35260: PUSH
35261: LD_VAR 0 1
35265: ARRAY
35266: NOT
35267: OR
35268: PUSH
35269: LD_EXP 99
35273: PUSH
35274: LD_VAR 0 1
35278: ARRAY
35279: PPUSH
35280: LD_INT 2
35282: PUSH
35283: LD_INT 30
35285: PUSH
35286: LD_INT 0
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 30
35295: PUSH
35296: LD_INT 1
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: EMPTY
35304: LIST
35305: LIST
35306: LIST
35307: PPUSH
35308: CALL_OW 72
35312: NOT
35313: OR
35314: IFFALSE 35318
// exit ;
35316: GO 38489
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35318: LD_ADDR_VAR 0 4
35322: PUSH
35323: LD_EXP 99
35327: PUSH
35328: LD_VAR 0 1
35332: ARRAY
35333: PPUSH
35334: LD_INT 2
35336: PUSH
35337: LD_INT 25
35339: PUSH
35340: LD_INT 1
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 25
35349: PUSH
35350: LD_INT 2
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 25
35359: PUSH
35360: LD_INT 3
35362: PUSH
35363: EMPTY
35364: LIST
35365: LIST
35366: PUSH
35367: LD_INT 25
35369: PUSH
35370: LD_INT 4
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 25
35379: PUSH
35380: LD_INT 5
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 25
35389: PUSH
35390: LD_INT 8
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: PUSH
35397: LD_INT 25
35399: PUSH
35400: LD_INT 9
35402: PUSH
35403: EMPTY
35404: LIST
35405: LIST
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: PPUSH
35417: CALL_OW 72
35421: ST_TO_ADDR
// for i in tmp do
35422: LD_ADDR_VAR 0 3
35426: PUSH
35427: LD_VAR 0 4
35431: PUSH
35432: FOR_IN
35433: IFFALSE 35464
// if GetTag ( i ) then
35435: LD_VAR 0 3
35439: PPUSH
35440: CALL_OW 110
35444: IFFALSE 35462
// tmp := tmp diff i ;
35446: LD_ADDR_VAR 0 4
35450: PUSH
35451: LD_VAR 0 4
35455: PUSH
35456: LD_VAR 0 3
35460: DIFF
35461: ST_TO_ADDR
35462: GO 35432
35464: POP
35465: POP
// if not tmp then
35466: LD_VAR 0 4
35470: NOT
35471: IFFALSE 35475
// exit ;
35473: GO 38489
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
35475: LD_ADDR_VAR 0 5
35479: PUSH
35480: LD_EXP 99
35484: PUSH
35485: LD_VAR 0 1
35489: ARRAY
35490: PPUSH
35491: LD_INT 2
35493: PUSH
35494: LD_INT 25
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 25
35506: PUSH
35507: LD_INT 5
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 25
35516: PUSH
35517: LD_INT 8
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 25
35526: PUSH
35527: LD_INT 9
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: PPUSH
35541: CALL_OW 72
35545: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
35546: LD_ADDR_VAR 0 6
35550: PUSH
35551: LD_EXP 99
35555: PUSH
35556: LD_VAR 0 1
35560: ARRAY
35561: PPUSH
35562: LD_INT 25
35564: PUSH
35565: LD_INT 2
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PPUSH
35572: CALL_OW 72
35576: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
35577: LD_ADDR_VAR 0 7
35581: PUSH
35582: LD_EXP 99
35586: PUSH
35587: LD_VAR 0 1
35591: ARRAY
35592: PPUSH
35593: LD_INT 25
35595: PUSH
35596: LD_INT 3
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PPUSH
35603: CALL_OW 72
35607: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
35608: LD_ADDR_VAR 0 8
35612: PUSH
35613: LD_EXP 99
35617: PUSH
35618: LD_VAR 0 1
35622: ARRAY
35623: PPUSH
35624: LD_INT 25
35626: PUSH
35627: LD_INT 4
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 24
35636: PUSH
35637: LD_INT 251
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: PPUSH
35648: CALL_OW 72
35652: ST_TO_ADDR
// if mc_scan [ base ] then
35653: LD_EXP 122
35657: PUSH
35658: LD_VAR 0 1
35662: ARRAY
35663: IFFALSE 36124
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
35665: LD_ADDR_EXP 141
35669: PUSH
35670: LD_EXP 141
35674: PPUSH
35675: LD_VAR 0 1
35679: PPUSH
35680: LD_INT 4
35682: PPUSH
35683: CALL_OW 1
35687: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
35688: LD_ADDR_VAR 0 12
35692: PUSH
35693: LD_EXP 99
35697: PUSH
35698: LD_VAR 0 1
35702: ARRAY
35703: PPUSH
35704: LD_INT 2
35706: PUSH
35707: LD_INT 30
35709: PUSH
35710: LD_INT 4
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 30
35719: PUSH
35720: LD_INT 5
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: LIST
35731: PPUSH
35732: CALL_OW 72
35736: ST_TO_ADDR
// if not b then
35737: LD_VAR 0 12
35741: NOT
35742: IFFALSE 35746
// exit ;
35744: GO 38489
// p := [ ] ;
35746: LD_ADDR_VAR 0 11
35750: PUSH
35751: EMPTY
35752: ST_TO_ADDR
// if sci >= 2 then
35753: LD_VAR 0 8
35757: PUSH
35758: LD_INT 2
35760: GREATEREQUAL
35761: IFFALSE 35792
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
35763: LD_ADDR_VAR 0 8
35767: PUSH
35768: LD_VAR 0 8
35772: PUSH
35773: LD_INT 1
35775: ARRAY
35776: PUSH
35777: LD_VAR 0 8
35781: PUSH
35782: LD_INT 2
35784: ARRAY
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: ST_TO_ADDR
35790: GO 35853
// if sci = 1 then
35792: LD_VAR 0 8
35796: PUSH
35797: LD_INT 1
35799: EQUAL
35800: IFFALSE 35821
// sci := [ sci [ 1 ] ] else
35802: LD_ADDR_VAR 0 8
35806: PUSH
35807: LD_VAR 0 8
35811: PUSH
35812: LD_INT 1
35814: ARRAY
35815: PUSH
35816: EMPTY
35817: LIST
35818: ST_TO_ADDR
35819: GO 35853
// if sci = 0 then
35821: LD_VAR 0 8
35825: PUSH
35826: LD_INT 0
35828: EQUAL
35829: IFFALSE 35853
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
35831: LD_ADDR_VAR 0 11
35835: PUSH
35836: LD_VAR 0 4
35840: PPUSH
35841: LD_INT 4
35843: PPUSH
35844: CALL 100372 0 2
35848: PUSH
35849: LD_INT 1
35851: ARRAY
35852: ST_TO_ADDR
// if eng > 4 then
35853: LD_VAR 0 6
35857: PUSH
35858: LD_INT 4
35860: GREATER
35861: IFFALSE 35907
// for i = eng downto 4 do
35863: LD_ADDR_VAR 0 3
35867: PUSH
35868: DOUBLE
35869: LD_VAR 0 6
35873: INC
35874: ST_TO_ADDR
35875: LD_INT 4
35877: PUSH
35878: FOR_DOWNTO
35879: IFFALSE 35905
// eng := eng diff eng [ i ] ;
35881: LD_ADDR_VAR 0 6
35885: PUSH
35886: LD_VAR 0 6
35890: PUSH
35891: LD_VAR 0 6
35895: PUSH
35896: LD_VAR 0 3
35900: ARRAY
35901: DIFF
35902: ST_TO_ADDR
35903: GO 35878
35905: POP
35906: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
35907: LD_ADDR_VAR 0 4
35911: PUSH
35912: LD_VAR 0 4
35916: PUSH
35917: LD_VAR 0 5
35921: PUSH
35922: LD_VAR 0 6
35926: UNION
35927: PUSH
35928: LD_VAR 0 7
35932: UNION
35933: PUSH
35934: LD_VAR 0 8
35938: UNION
35939: DIFF
35940: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
35941: LD_ADDR_VAR 0 13
35945: PUSH
35946: LD_EXP 99
35950: PUSH
35951: LD_VAR 0 1
35955: ARRAY
35956: PPUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 30
35962: PUSH
35963: LD_INT 32
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 30
35972: PUSH
35973: LD_INT 31
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: LIST
35984: PPUSH
35985: CALL_OW 72
35989: PUSH
35990: LD_EXP 99
35994: PUSH
35995: LD_VAR 0 1
35999: ARRAY
36000: PPUSH
36001: LD_INT 2
36003: PUSH
36004: LD_INT 30
36006: PUSH
36007: LD_INT 4
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 30
36016: PUSH
36017: LD_INT 5
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: EMPTY
36025: LIST
36026: LIST
36027: LIST
36028: PPUSH
36029: CALL_OW 72
36033: PUSH
36034: LD_INT 6
36036: MUL
36037: PLUS
36038: ST_TO_ADDR
// if bcount < tmp then
36039: LD_VAR 0 13
36043: PUSH
36044: LD_VAR 0 4
36048: LESS
36049: IFFALSE 36095
// for i = tmp downto bcount do
36051: LD_ADDR_VAR 0 3
36055: PUSH
36056: DOUBLE
36057: LD_VAR 0 4
36061: INC
36062: ST_TO_ADDR
36063: LD_VAR 0 13
36067: PUSH
36068: FOR_DOWNTO
36069: IFFALSE 36093
// tmp := Delete ( tmp , tmp ) ;
36071: LD_ADDR_VAR 0 4
36075: PUSH
36076: LD_VAR 0 4
36080: PPUSH
36081: LD_VAR 0 4
36085: PPUSH
36086: CALL_OW 3
36090: ST_TO_ADDR
36091: GO 36068
36093: POP
36094: POP
// result := [ tmp , 0 , 0 , p ] ;
36095: LD_ADDR_VAR 0 2
36099: PUSH
36100: LD_VAR 0 4
36104: PUSH
36105: LD_INT 0
36107: PUSH
36108: LD_INT 0
36110: PUSH
36111: LD_VAR 0 11
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: ST_TO_ADDR
// exit ;
36122: GO 38489
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
36124: LD_EXP 99
36128: PUSH
36129: LD_VAR 0 1
36133: ARRAY
36134: PPUSH
36135: LD_INT 2
36137: PUSH
36138: LD_INT 30
36140: PUSH
36141: LD_INT 6
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 30
36150: PUSH
36151: LD_INT 7
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: PUSH
36158: LD_INT 30
36160: PUSH
36161: LD_INT 8
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: EMPTY
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: PPUSH
36174: CALL_OW 72
36178: NOT
36179: PUSH
36180: LD_EXP 99
36184: PUSH
36185: LD_VAR 0 1
36189: ARRAY
36190: PPUSH
36191: LD_INT 30
36193: PUSH
36194: LD_INT 3
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PPUSH
36201: CALL_OW 72
36205: NOT
36206: AND
36207: IFFALSE 36279
// begin if eng = tmp then
36209: LD_VAR 0 6
36213: PUSH
36214: LD_VAR 0 4
36218: EQUAL
36219: IFFALSE 36223
// exit ;
36221: GO 38489
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
36223: LD_ADDR_EXP 141
36227: PUSH
36228: LD_EXP 141
36232: PPUSH
36233: LD_VAR 0 1
36237: PPUSH
36238: LD_INT 1
36240: PPUSH
36241: CALL_OW 1
36245: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
36246: LD_ADDR_VAR 0 2
36250: PUSH
36251: LD_INT 0
36253: PUSH
36254: LD_VAR 0 4
36258: PUSH
36259: LD_VAR 0 6
36263: DIFF
36264: PUSH
36265: LD_INT 0
36267: PUSH
36268: LD_INT 0
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: LIST
36275: LIST
36276: ST_TO_ADDR
// exit ;
36277: GO 38489
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
36279: LD_EXP 126
36283: PUSH
36284: LD_EXP 125
36288: PUSH
36289: LD_VAR 0 1
36293: ARRAY
36294: ARRAY
36295: PUSH
36296: LD_EXP 99
36300: PUSH
36301: LD_VAR 0 1
36305: ARRAY
36306: PPUSH
36307: LD_INT 2
36309: PUSH
36310: LD_INT 30
36312: PUSH
36313: LD_INT 6
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 30
36322: PUSH
36323: LD_INT 7
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: LD_INT 30
36332: PUSH
36333: LD_INT 8
36335: PUSH
36336: EMPTY
36337: LIST
36338: LIST
36339: PUSH
36340: EMPTY
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: PPUSH
36346: CALL_OW 72
36350: AND
36351: PUSH
36352: LD_EXP 99
36356: PUSH
36357: LD_VAR 0 1
36361: ARRAY
36362: PPUSH
36363: LD_INT 30
36365: PUSH
36366: LD_INT 3
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PPUSH
36373: CALL_OW 72
36377: NOT
36378: AND
36379: IFFALSE 36593
// begin if sci >= 6 then
36381: LD_VAR 0 8
36385: PUSH
36386: LD_INT 6
36388: GREATEREQUAL
36389: IFFALSE 36393
// exit ;
36391: GO 38489
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
36393: LD_ADDR_EXP 141
36397: PUSH
36398: LD_EXP 141
36402: PPUSH
36403: LD_VAR 0 1
36407: PPUSH
36408: LD_INT 2
36410: PPUSH
36411: CALL_OW 1
36415: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
36416: LD_ADDR_VAR 0 9
36420: PUSH
36421: LD_VAR 0 4
36425: PUSH
36426: LD_VAR 0 8
36430: DIFF
36431: PPUSH
36432: LD_INT 4
36434: PPUSH
36435: CALL 100372 0 2
36439: ST_TO_ADDR
// p := [ ] ;
36440: LD_ADDR_VAR 0 11
36444: PUSH
36445: EMPTY
36446: ST_TO_ADDR
// if sci < 6 and sort > 6 then
36447: LD_VAR 0 8
36451: PUSH
36452: LD_INT 6
36454: LESS
36455: PUSH
36456: LD_VAR 0 9
36460: PUSH
36461: LD_INT 6
36463: GREATER
36464: AND
36465: IFFALSE 36546
// begin for i = 1 to 6 - sci do
36467: LD_ADDR_VAR 0 3
36471: PUSH
36472: DOUBLE
36473: LD_INT 1
36475: DEC
36476: ST_TO_ADDR
36477: LD_INT 6
36479: PUSH
36480: LD_VAR 0 8
36484: MINUS
36485: PUSH
36486: FOR_TO
36487: IFFALSE 36542
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
36489: LD_ADDR_VAR 0 11
36493: PUSH
36494: LD_VAR 0 11
36498: PPUSH
36499: LD_VAR 0 11
36503: PUSH
36504: LD_INT 1
36506: PLUS
36507: PPUSH
36508: LD_VAR 0 9
36512: PUSH
36513: LD_INT 1
36515: ARRAY
36516: PPUSH
36517: CALL_OW 2
36521: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
36522: LD_ADDR_VAR 0 9
36526: PUSH
36527: LD_VAR 0 9
36531: PPUSH
36532: LD_INT 1
36534: PPUSH
36535: CALL_OW 3
36539: ST_TO_ADDR
// end ;
36540: GO 36486
36542: POP
36543: POP
// end else
36544: GO 36566
// if sort then
36546: LD_VAR 0 9
36550: IFFALSE 36566
// p := sort [ 1 ] ;
36552: LD_ADDR_VAR 0 11
36556: PUSH
36557: LD_VAR 0 9
36561: PUSH
36562: LD_INT 1
36564: ARRAY
36565: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
36566: LD_ADDR_VAR 0 2
36570: PUSH
36571: LD_INT 0
36573: PUSH
36574: LD_INT 0
36576: PUSH
36577: LD_INT 0
36579: PUSH
36580: LD_VAR 0 11
36584: PUSH
36585: EMPTY
36586: LIST
36587: LIST
36588: LIST
36589: LIST
36590: ST_TO_ADDR
// exit ;
36591: GO 38489
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
36593: LD_EXP 126
36597: PUSH
36598: LD_EXP 125
36602: PUSH
36603: LD_VAR 0 1
36607: ARRAY
36608: ARRAY
36609: PUSH
36610: LD_EXP 99
36614: PUSH
36615: LD_VAR 0 1
36619: ARRAY
36620: PPUSH
36621: LD_INT 2
36623: PUSH
36624: LD_INT 30
36626: PUSH
36627: LD_INT 6
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 30
36636: PUSH
36637: LD_INT 7
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 30
36646: PUSH
36647: LD_INT 8
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: PPUSH
36660: CALL_OW 72
36664: AND
36665: PUSH
36666: LD_EXP 99
36670: PUSH
36671: LD_VAR 0 1
36675: ARRAY
36676: PPUSH
36677: LD_INT 30
36679: PUSH
36680: LD_INT 3
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PPUSH
36687: CALL_OW 72
36691: AND
36692: IFFALSE 37219
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
36694: LD_ADDR_EXP 141
36698: PUSH
36699: LD_EXP 141
36703: PPUSH
36704: LD_VAR 0 1
36708: PPUSH
36709: LD_INT 3
36711: PPUSH
36712: CALL_OW 1
36716: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
36717: LD_ADDR_VAR 0 2
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: LD_INT 0
36727: PUSH
36728: LD_INT 0
36730: PUSH
36731: LD_INT 0
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: LIST
36738: LIST
36739: ST_TO_ADDR
// if not eng then
36740: LD_VAR 0 6
36744: NOT
36745: IFFALSE 36808
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
36747: LD_ADDR_VAR 0 11
36751: PUSH
36752: LD_VAR 0 4
36756: PPUSH
36757: LD_INT 2
36759: PPUSH
36760: CALL 100372 0 2
36764: PUSH
36765: LD_INT 1
36767: ARRAY
36768: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
36769: LD_ADDR_VAR 0 2
36773: PUSH
36774: LD_VAR 0 2
36778: PPUSH
36779: LD_INT 2
36781: PPUSH
36782: LD_VAR 0 11
36786: PPUSH
36787: CALL_OW 1
36791: ST_TO_ADDR
// tmp := tmp diff p ;
36792: LD_ADDR_VAR 0 4
36796: PUSH
36797: LD_VAR 0 4
36801: PUSH
36802: LD_VAR 0 11
36806: DIFF
36807: ST_TO_ADDR
// end ; if not eng then
36808: LD_VAR 0 6
36812: NOT
36813: IFFALSE 36839
// tmp := tmp diff ( mech union sci ) else
36815: LD_ADDR_VAR 0 4
36819: PUSH
36820: LD_VAR 0 4
36824: PUSH
36825: LD_VAR 0 7
36829: PUSH
36830: LD_VAR 0 8
36834: UNION
36835: DIFF
36836: ST_TO_ADDR
36837: GO 36871
// tmp := tmp diff ( eng [ 1 ] union mech union sci ) ;
36839: LD_ADDR_VAR 0 4
36843: PUSH
36844: LD_VAR 0 4
36848: PUSH
36849: LD_VAR 0 6
36853: PUSH
36854: LD_INT 1
36856: ARRAY
36857: PUSH
36858: LD_VAR 0 7
36862: UNION
36863: PUSH
36864: LD_VAR 0 8
36868: UNION
36869: DIFF
36870: ST_TO_ADDR
// if tmp and sci < 6 then
36871: LD_VAR 0 4
36875: PUSH
36876: LD_VAR 0 8
36880: PUSH
36881: LD_INT 6
36883: LESS
36884: AND
36885: IFFALSE 37044
// begin sort := SortBySkill ( tmp , 4 ) ;
36887: LD_ADDR_VAR 0 9
36891: PUSH
36892: LD_VAR 0 4
36896: PPUSH
36897: LD_INT 4
36899: PPUSH
36900: CALL 100372 0 2
36904: ST_TO_ADDR
// p := [ ] ;
36905: LD_ADDR_VAR 0 11
36909: PUSH
36910: EMPTY
36911: ST_TO_ADDR
// if sort then
36912: LD_VAR 0 9
36916: IFFALSE 37015
// for i = 1 to 6 - sci do
36918: LD_ADDR_VAR 0 3
36922: PUSH
36923: DOUBLE
36924: LD_INT 1
36926: DEC
36927: ST_TO_ADDR
36928: LD_INT 6
36930: PUSH
36931: LD_VAR 0 8
36935: MINUS
36936: PUSH
36937: FOR_TO
36938: IFFALSE 37013
// begin if i = sort then
36940: LD_VAR 0 3
36944: PUSH
36945: LD_VAR 0 9
36949: EQUAL
36950: IFFALSE 36954
// break ;
36952: GO 37013
// p := Insert ( p , p + 1 , sort [ i ] ) ;
36954: LD_ADDR_VAR 0 11
36958: PUSH
36959: LD_VAR 0 11
36963: PPUSH
36964: LD_VAR 0 11
36968: PUSH
36969: LD_INT 1
36971: PLUS
36972: PPUSH
36973: LD_VAR 0 9
36977: PUSH
36978: LD_VAR 0 3
36982: ARRAY
36983: PPUSH
36984: CALL_OW 2
36988: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
36989: LD_ADDR_VAR 0 4
36993: PUSH
36994: LD_VAR 0 4
36998: PUSH
36999: LD_VAR 0 9
37003: PUSH
37004: LD_VAR 0 3
37008: ARRAY
37009: DIFF
37010: ST_TO_ADDR
// end ;
37011: GO 36937
37013: POP
37014: POP
// if p then
37015: LD_VAR 0 11
37019: IFFALSE 37044
// result := Replace ( result , 4 , p ) ;
37021: LD_ADDR_VAR 0 2
37025: PUSH
37026: LD_VAR 0 2
37030: PPUSH
37031: LD_INT 4
37033: PPUSH
37034: LD_VAR 0 11
37038: PPUSH
37039: CALL_OW 1
37043: ST_TO_ADDR
// end ; if tmp and mech < 6 then
37044: LD_VAR 0 4
37048: PUSH
37049: LD_VAR 0 7
37053: PUSH
37054: LD_INT 6
37056: LESS
37057: AND
37058: IFFALSE 37217
// begin sort := SortBySkill ( tmp , 3 ) ;
37060: LD_ADDR_VAR 0 9
37064: PUSH
37065: LD_VAR 0 4
37069: PPUSH
37070: LD_INT 3
37072: PPUSH
37073: CALL 100372 0 2
37077: ST_TO_ADDR
// p := [ ] ;
37078: LD_ADDR_VAR 0 11
37082: PUSH
37083: EMPTY
37084: ST_TO_ADDR
// if sort then
37085: LD_VAR 0 9
37089: IFFALSE 37188
// for i = 1 to 6 - mech do
37091: LD_ADDR_VAR 0 3
37095: PUSH
37096: DOUBLE
37097: LD_INT 1
37099: DEC
37100: ST_TO_ADDR
37101: LD_INT 6
37103: PUSH
37104: LD_VAR 0 7
37108: MINUS
37109: PUSH
37110: FOR_TO
37111: IFFALSE 37186
// begin if i = sort then
37113: LD_VAR 0 3
37117: PUSH
37118: LD_VAR 0 9
37122: EQUAL
37123: IFFALSE 37127
// break ;
37125: GO 37186
// p := Insert ( p , p + 1 , sort [ i ] ) ;
37127: LD_ADDR_VAR 0 11
37131: PUSH
37132: LD_VAR 0 11
37136: PPUSH
37137: LD_VAR 0 11
37141: PUSH
37142: LD_INT 1
37144: PLUS
37145: PPUSH
37146: LD_VAR 0 9
37150: PUSH
37151: LD_VAR 0 3
37155: ARRAY
37156: PPUSH
37157: CALL_OW 2
37161: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
37162: LD_ADDR_VAR 0 4
37166: PUSH
37167: LD_VAR 0 4
37171: PUSH
37172: LD_VAR 0 9
37176: PUSH
37177: LD_VAR 0 3
37181: ARRAY
37182: DIFF
37183: ST_TO_ADDR
// end ;
37184: GO 37110
37186: POP
37187: POP
// if p then
37188: LD_VAR 0 11
37192: IFFALSE 37217
// result := Replace ( result , 3 , p ) ;
37194: LD_ADDR_VAR 0 2
37198: PUSH
37199: LD_VAR 0 2
37203: PPUSH
37204: LD_INT 3
37206: PPUSH
37207: LD_VAR 0 11
37211: PPUSH
37212: CALL_OW 1
37216: ST_TO_ADDR
// end ; exit ;
37217: GO 38489
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
37219: LD_EXP 126
37223: PUSH
37224: LD_EXP 125
37228: PUSH
37229: LD_VAR 0 1
37233: ARRAY
37234: ARRAY
37235: NOT
37236: PUSH
37237: LD_EXP 99
37241: PUSH
37242: LD_VAR 0 1
37246: ARRAY
37247: PPUSH
37248: LD_INT 30
37250: PUSH
37251: LD_INT 3
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PPUSH
37258: CALL_OW 72
37262: AND
37263: PUSH
37264: LD_EXP 104
37268: PUSH
37269: LD_VAR 0 1
37273: ARRAY
37274: AND
37275: IFFALSE 37819
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
37277: LD_ADDR_EXP 141
37281: PUSH
37282: LD_EXP 141
37286: PPUSH
37287: LD_VAR 0 1
37291: PPUSH
37292: LD_INT 5
37294: PPUSH
37295: CALL_OW 1
37299: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
37300: LD_ADDR_VAR 0 2
37304: PUSH
37305: LD_INT 0
37307: PUSH
37308: LD_INT 0
37310: PUSH
37311: LD_INT 0
37313: PUSH
37314: LD_INT 0
37316: PUSH
37317: EMPTY
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: ST_TO_ADDR
// if sci > 1 then
37323: LD_VAR 0 8
37327: PUSH
37328: LD_INT 1
37330: GREATER
37331: IFFALSE 37359
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
37333: LD_ADDR_VAR 0 4
37337: PUSH
37338: LD_VAR 0 4
37342: PUSH
37343: LD_VAR 0 8
37347: PUSH
37348: LD_VAR 0 8
37352: PUSH
37353: LD_INT 1
37355: ARRAY
37356: DIFF
37357: DIFF
37358: ST_TO_ADDR
// if tmp and not sci then
37359: LD_VAR 0 4
37363: PUSH
37364: LD_VAR 0 8
37368: NOT
37369: AND
37370: IFFALSE 37439
// begin sort := SortBySkill ( tmp , 4 ) ;
37372: LD_ADDR_VAR 0 9
37376: PUSH
37377: LD_VAR 0 4
37381: PPUSH
37382: LD_INT 4
37384: PPUSH
37385: CALL 100372 0 2
37389: ST_TO_ADDR
// if sort then
37390: LD_VAR 0 9
37394: IFFALSE 37410
// p := sort [ 1 ] ;
37396: LD_ADDR_VAR 0 11
37400: PUSH
37401: LD_VAR 0 9
37405: PUSH
37406: LD_INT 1
37408: ARRAY
37409: ST_TO_ADDR
// if p then
37410: LD_VAR 0 11
37414: IFFALSE 37439
// result := Replace ( result , 4 , p ) ;
37416: LD_ADDR_VAR 0 2
37420: PUSH
37421: LD_VAR 0 2
37425: PPUSH
37426: LD_INT 4
37428: PPUSH
37429: LD_VAR 0 11
37433: PPUSH
37434: CALL_OW 1
37438: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
37439: LD_ADDR_VAR 0 4
37443: PUSH
37444: LD_VAR 0 4
37448: PUSH
37449: LD_VAR 0 7
37453: DIFF
37454: ST_TO_ADDR
// if tmp and mech < 6 then
37455: LD_VAR 0 4
37459: PUSH
37460: LD_VAR 0 7
37464: PUSH
37465: LD_INT 6
37467: LESS
37468: AND
37469: IFFALSE 37628
// begin sort := SortBySkill ( tmp , 3 ) ;
37471: LD_ADDR_VAR 0 9
37475: PUSH
37476: LD_VAR 0 4
37480: PPUSH
37481: LD_INT 3
37483: PPUSH
37484: CALL 100372 0 2
37488: ST_TO_ADDR
// p := [ ] ;
37489: LD_ADDR_VAR 0 11
37493: PUSH
37494: EMPTY
37495: ST_TO_ADDR
// if sort then
37496: LD_VAR 0 9
37500: IFFALSE 37599
// for i = 1 to 6 - mech do
37502: LD_ADDR_VAR 0 3
37506: PUSH
37507: DOUBLE
37508: LD_INT 1
37510: DEC
37511: ST_TO_ADDR
37512: LD_INT 6
37514: PUSH
37515: LD_VAR 0 7
37519: MINUS
37520: PUSH
37521: FOR_TO
37522: IFFALSE 37597
// begin if i = sort then
37524: LD_VAR 0 3
37528: PUSH
37529: LD_VAR 0 9
37533: EQUAL
37534: IFFALSE 37538
// break ;
37536: GO 37597
// p := Insert ( p , p + 1 , sort [ i ] ) ;
37538: LD_ADDR_VAR 0 11
37542: PUSH
37543: LD_VAR 0 11
37547: PPUSH
37548: LD_VAR 0 11
37552: PUSH
37553: LD_INT 1
37555: PLUS
37556: PPUSH
37557: LD_VAR 0 9
37561: PUSH
37562: LD_VAR 0 3
37566: ARRAY
37567: PPUSH
37568: CALL_OW 2
37572: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
37573: LD_ADDR_VAR 0 4
37577: PUSH
37578: LD_VAR 0 4
37582: PUSH
37583: LD_VAR 0 9
37587: PUSH
37588: LD_VAR 0 3
37592: ARRAY
37593: DIFF
37594: ST_TO_ADDR
// end ;
37595: GO 37521
37597: POP
37598: POP
// if p then
37599: LD_VAR 0 11
37603: IFFALSE 37628
// result := Replace ( result , 3 , p ) ;
37605: LD_ADDR_VAR 0 2
37609: PUSH
37610: LD_VAR 0 2
37614: PPUSH
37615: LD_INT 3
37617: PPUSH
37618: LD_VAR 0 11
37622: PPUSH
37623: CALL_OW 1
37627: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
37628: LD_ADDR_VAR 0 4
37632: PUSH
37633: LD_VAR 0 4
37637: PUSH
37638: LD_VAR 0 6
37642: DIFF
37643: ST_TO_ADDR
// if tmp and eng < 6 then
37644: LD_VAR 0 4
37648: PUSH
37649: LD_VAR 0 6
37653: PUSH
37654: LD_INT 6
37656: LESS
37657: AND
37658: IFFALSE 37817
// begin sort := SortBySkill ( tmp , 2 ) ;
37660: LD_ADDR_VAR 0 9
37664: PUSH
37665: LD_VAR 0 4
37669: PPUSH
37670: LD_INT 2
37672: PPUSH
37673: CALL 100372 0 2
37677: ST_TO_ADDR
// p := [ ] ;
37678: LD_ADDR_VAR 0 11
37682: PUSH
37683: EMPTY
37684: ST_TO_ADDR
// if sort then
37685: LD_VAR 0 9
37689: IFFALSE 37788
// for i = 1 to 6 - eng do
37691: LD_ADDR_VAR 0 3
37695: PUSH
37696: DOUBLE
37697: LD_INT 1
37699: DEC
37700: ST_TO_ADDR
37701: LD_INT 6
37703: PUSH
37704: LD_VAR 0 6
37708: MINUS
37709: PUSH
37710: FOR_TO
37711: IFFALSE 37786
// begin if i = sort then
37713: LD_VAR 0 3
37717: PUSH
37718: LD_VAR 0 9
37722: EQUAL
37723: IFFALSE 37727
// break ;
37725: GO 37786
// p := Insert ( p , p + 1 , sort [ i ] ) ;
37727: LD_ADDR_VAR 0 11
37731: PUSH
37732: LD_VAR 0 11
37736: PPUSH
37737: LD_VAR 0 11
37741: PUSH
37742: LD_INT 1
37744: PLUS
37745: PPUSH
37746: LD_VAR 0 9
37750: PUSH
37751: LD_VAR 0 3
37755: ARRAY
37756: PPUSH
37757: CALL_OW 2
37761: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
37762: LD_ADDR_VAR 0 4
37766: PUSH
37767: LD_VAR 0 4
37771: PUSH
37772: LD_VAR 0 9
37776: PUSH
37777: LD_VAR 0 3
37781: ARRAY
37782: DIFF
37783: ST_TO_ADDR
// end ;
37784: GO 37710
37786: POP
37787: POP
// if p then
37788: LD_VAR 0 11
37792: IFFALSE 37817
// result := Replace ( result , 2 , p ) ;
37794: LD_ADDR_VAR 0 2
37798: PUSH
37799: LD_VAR 0 2
37803: PPUSH
37804: LD_INT 2
37806: PPUSH
37807: LD_VAR 0 11
37811: PPUSH
37812: CALL_OW 1
37816: ST_TO_ADDR
// end ; exit ;
37817: GO 38489
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
37819: LD_EXP 126
37823: PUSH
37824: LD_EXP 125
37828: PUSH
37829: LD_VAR 0 1
37833: ARRAY
37834: ARRAY
37835: NOT
37836: PUSH
37837: LD_EXP 99
37841: PUSH
37842: LD_VAR 0 1
37846: ARRAY
37847: PPUSH
37848: LD_INT 30
37850: PUSH
37851: LD_INT 3
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PPUSH
37858: CALL_OW 72
37862: AND
37863: PUSH
37864: LD_EXP 104
37868: PUSH
37869: LD_VAR 0 1
37873: ARRAY
37874: NOT
37875: AND
37876: IFFALSE 38489
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
37878: LD_ADDR_EXP 141
37882: PUSH
37883: LD_EXP 141
37887: PPUSH
37888: LD_VAR 0 1
37892: PPUSH
37893: LD_INT 6
37895: PPUSH
37896: CALL_OW 1
37900: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
37901: LD_ADDR_VAR 0 2
37905: PUSH
37906: LD_INT 0
37908: PUSH
37909: LD_INT 0
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: LD_INT 0
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: ST_TO_ADDR
// if sci >= 1 then
37924: LD_VAR 0 8
37928: PUSH
37929: LD_INT 1
37931: GREATEREQUAL
37932: IFFALSE 37954
// tmp := tmp diff sci [ 1 ] ;
37934: LD_ADDR_VAR 0 4
37938: PUSH
37939: LD_VAR 0 4
37943: PUSH
37944: LD_VAR 0 8
37948: PUSH
37949: LD_INT 1
37951: ARRAY
37952: DIFF
37953: ST_TO_ADDR
// if tmp and not sci then
37954: LD_VAR 0 4
37958: PUSH
37959: LD_VAR 0 8
37963: NOT
37964: AND
37965: IFFALSE 38034
// begin sort := SortBySkill ( tmp , 4 ) ;
37967: LD_ADDR_VAR 0 9
37971: PUSH
37972: LD_VAR 0 4
37976: PPUSH
37977: LD_INT 4
37979: PPUSH
37980: CALL 100372 0 2
37984: ST_TO_ADDR
// if sort then
37985: LD_VAR 0 9
37989: IFFALSE 38005
// p := sort [ 1 ] ;
37991: LD_ADDR_VAR 0 11
37995: PUSH
37996: LD_VAR 0 9
38000: PUSH
38001: LD_INT 1
38003: ARRAY
38004: ST_TO_ADDR
// if p then
38005: LD_VAR 0 11
38009: IFFALSE 38034
// result := Replace ( result , 4 , p ) ;
38011: LD_ADDR_VAR 0 2
38015: PUSH
38016: LD_VAR 0 2
38020: PPUSH
38021: LD_INT 4
38023: PPUSH
38024: LD_VAR 0 11
38028: PPUSH
38029: CALL_OW 1
38033: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
38034: LD_ADDR_VAR 0 4
38038: PUSH
38039: LD_VAR 0 4
38043: PUSH
38044: LD_VAR 0 7
38048: DIFF
38049: ST_TO_ADDR
// if tmp and mech < 6 then
38050: LD_VAR 0 4
38054: PUSH
38055: LD_VAR 0 7
38059: PUSH
38060: LD_INT 6
38062: LESS
38063: AND
38064: IFFALSE 38223
// begin sort := SortBySkill ( tmp , 3 ) ;
38066: LD_ADDR_VAR 0 9
38070: PUSH
38071: LD_VAR 0 4
38075: PPUSH
38076: LD_INT 3
38078: PPUSH
38079: CALL 100372 0 2
38083: ST_TO_ADDR
// p := [ ] ;
38084: LD_ADDR_VAR 0 11
38088: PUSH
38089: EMPTY
38090: ST_TO_ADDR
// if sort then
38091: LD_VAR 0 9
38095: IFFALSE 38194
// for i = 1 to 6 - mech do
38097: LD_ADDR_VAR 0 3
38101: PUSH
38102: DOUBLE
38103: LD_INT 1
38105: DEC
38106: ST_TO_ADDR
38107: LD_INT 6
38109: PUSH
38110: LD_VAR 0 7
38114: MINUS
38115: PUSH
38116: FOR_TO
38117: IFFALSE 38192
// begin if i = sort then
38119: LD_VAR 0 3
38123: PUSH
38124: LD_VAR 0 9
38128: EQUAL
38129: IFFALSE 38133
// break ;
38131: GO 38192
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38133: LD_ADDR_VAR 0 11
38137: PUSH
38138: LD_VAR 0 11
38142: PPUSH
38143: LD_VAR 0 11
38147: PUSH
38148: LD_INT 1
38150: PLUS
38151: PPUSH
38152: LD_VAR 0 9
38156: PUSH
38157: LD_VAR 0 3
38161: ARRAY
38162: PPUSH
38163: CALL_OW 2
38167: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38168: LD_ADDR_VAR 0 4
38172: PUSH
38173: LD_VAR 0 4
38177: PUSH
38178: LD_VAR 0 9
38182: PUSH
38183: LD_VAR 0 3
38187: ARRAY
38188: DIFF
38189: ST_TO_ADDR
// end ;
38190: GO 38116
38192: POP
38193: POP
// if p then
38194: LD_VAR 0 11
38198: IFFALSE 38223
// result := Replace ( result , 3 , p ) ;
38200: LD_ADDR_VAR 0 2
38204: PUSH
38205: LD_VAR 0 2
38209: PPUSH
38210: LD_INT 3
38212: PPUSH
38213: LD_VAR 0 11
38217: PPUSH
38218: CALL_OW 1
38222: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
38223: LD_ADDR_VAR 0 4
38227: PUSH
38228: LD_VAR 0 4
38232: PUSH
38233: LD_VAR 0 6
38237: DIFF
38238: ST_TO_ADDR
// if tmp and eng < 4 then
38239: LD_VAR 0 4
38243: PUSH
38244: LD_VAR 0 6
38248: PUSH
38249: LD_INT 4
38251: LESS
38252: AND
38253: IFFALSE 38414
// begin sort := SortBySkill ( tmp , 2 ) ;
38255: LD_ADDR_VAR 0 9
38259: PUSH
38260: LD_VAR 0 4
38264: PPUSH
38265: LD_INT 2
38267: PPUSH
38268: CALL 100372 0 2
38272: ST_TO_ADDR
// p := [ ] ;
38273: LD_ADDR_VAR 0 11
38277: PUSH
38278: EMPTY
38279: ST_TO_ADDR
// if sort then
38280: LD_VAR 0 9
38284: IFFALSE 38383
// for i = 1 to 4 - eng do
38286: LD_ADDR_VAR 0 3
38290: PUSH
38291: DOUBLE
38292: LD_INT 1
38294: DEC
38295: ST_TO_ADDR
38296: LD_INT 4
38298: PUSH
38299: LD_VAR 0 6
38303: MINUS
38304: PUSH
38305: FOR_TO
38306: IFFALSE 38381
// begin if i = sort then
38308: LD_VAR 0 3
38312: PUSH
38313: LD_VAR 0 9
38317: EQUAL
38318: IFFALSE 38322
// break ;
38320: GO 38381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
38322: LD_ADDR_VAR 0 11
38326: PUSH
38327: LD_VAR 0 11
38331: PPUSH
38332: LD_VAR 0 11
38336: PUSH
38337: LD_INT 1
38339: PLUS
38340: PPUSH
38341: LD_VAR 0 9
38345: PUSH
38346: LD_VAR 0 3
38350: ARRAY
38351: PPUSH
38352: CALL_OW 2
38356: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
38357: LD_ADDR_VAR 0 4
38361: PUSH
38362: LD_VAR 0 4
38366: PUSH
38367: LD_VAR 0 9
38371: PUSH
38372: LD_VAR 0 3
38376: ARRAY
38377: DIFF
38378: ST_TO_ADDR
// end ;
38379: GO 38305
38381: POP
38382: POP
// if p then
38383: LD_VAR 0 11
38387: IFFALSE 38412
// result := Replace ( result , 2 , p ) ;
38389: LD_ADDR_VAR 0 2
38393: PUSH
38394: LD_VAR 0 2
38398: PPUSH
38399: LD_INT 2
38401: PPUSH
38402: LD_VAR 0 11
38406: PPUSH
38407: CALL_OW 1
38411: ST_TO_ADDR
// end else
38412: GO 38458
// for i = eng downto 5 do
38414: LD_ADDR_VAR 0 3
38418: PUSH
38419: DOUBLE
38420: LD_VAR 0 6
38424: INC
38425: ST_TO_ADDR
38426: LD_INT 5
38428: PUSH
38429: FOR_DOWNTO
38430: IFFALSE 38456
// tmp := tmp union eng [ i ] ;
38432: LD_ADDR_VAR 0 4
38436: PUSH
38437: LD_VAR 0 4
38441: PUSH
38442: LD_VAR 0 6
38446: PUSH
38447: LD_VAR 0 3
38451: ARRAY
38452: UNION
38453: ST_TO_ADDR
38454: GO 38429
38456: POP
38457: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
38458: LD_ADDR_VAR 0 2
38462: PUSH
38463: LD_VAR 0 2
38467: PPUSH
38468: LD_INT 1
38470: PPUSH
38471: LD_VAR 0 4
38475: PUSH
38476: LD_VAR 0 5
38480: DIFF
38481: PPUSH
38482: CALL_OW 1
38486: ST_TO_ADDR
// exit ;
38487: GO 38489
// end ; end ;
38489: LD_VAR 0 2
38493: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
38494: LD_INT 0
38496: PPUSH
38497: PPUSH
38498: PPUSH
// if not mc_bases then
38499: LD_EXP 99
38503: NOT
38504: IFFALSE 38508
// exit ;
38506: GO 38614
// for i = 1 to mc_bases do
38508: LD_ADDR_VAR 0 2
38512: PUSH
38513: DOUBLE
38514: LD_INT 1
38516: DEC
38517: ST_TO_ADDR
38518: LD_EXP 99
38522: PUSH
38523: FOR_TO
38524: IFFALSE 38605
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
38526: LD_ADDR_VAR 0 3
38530: PUSH
38531: LD_EXP 99
38535: PUSH
38536: LD_VAR 0 2
38540: ARRAY
38541: PPUSH
38542: LD_INT 21
38544: PUSH
38545: LD_INT 3
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 3
38554: PUSH
38555: LD_INT 24
38557: PUSH
38558: LD_INT 1000
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: EMPTY
38566: LIST
38567: LIST
38568: PUSH
38569: EMPTY
38570: LIST
38571: LIST
38572: PPUSH
38573: CALL_OW 72
38577: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
38578: LD_ADDR_EXP 100
38582: PUSH
38583: LD_EXP 100
38587: PPUSH
38588: LD_VAR 0 2
38592: PPUSH
38593: LD_VAR 0 3
38597: PPUSH
38598: CALL_OW 1
38602: ST_TO_ADDR
// end ;
38603: GO 38523
38605: POP
38606: POP
// RaiseSailEvent ( 101 ) ;
38607: LD_INT 101
38609: PPUSH
38610: CALL_OW 427
// end ;
38614: LD_VAR 0 1
38618: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
38619: LD_INT 0
38621: PPUSH
38622: PPUSH
38623: PPUSH
38624: PPUSH
38625: PPUSH
38626: PPUSH
38627: PPUSH
// if not mc_bases then
38628: LD_EXP 99
38632: NOT
38633: IFFALSE 38637
// exit ;
38635: GO 39210
// for i = 1 to mc_bases do
38637: LD_ADDR_VAR 0 2
38641: PUSH
38642: DOUBLE
38643: LD_INT 1
38645: DEC
38646: ST_TO_ADDR
38647: LD_EXP 99
38651: PUSH
38652: FOR_TO
38653: IFFALSE 39201
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
38655: LD_ADDR_VAR 0 5
38659: PUSH
38660: LD_EXP 99
38664: PUSH
38665: LD_VAR 0 2
38669: ARRAY
38670: PUSH
38671: LD_EXP 128
38675: PUSH
38676: LD_VAR 0 2
38680: ARRAY
38681: UNION
38682: PPUSH
38683: LD_INT 21
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 1
38695: PUSH
38696: LD_INT 3
38698: PUSH
38699: LD_INT 54
38701: PUSH
38702: EMPTY
38703: LIST
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 3
38711: PUSH
38712: LD_INT 24
38714: PUSH
38715: LD_INT 750
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: EMPTY
38723: LIST
38724: LIST
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: LIST
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PPUSH
38735: CALL_OW 72
38739: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
38740: LD_ADDR_VAR 0 6
38744: PUSH
38745: LD_EXP 99
38749: PUSH
38750: LD_VAR 0 2
38754: ARRAY
38755: PPUSH
38756: LD_INT 21
38758: PUSH
38759: LD_INT 1
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 1
38768: PUSH
38769: LD_INT 3
38771: PUSH
38772: LD_INT 54
38774: PUSH
38775: EMPTY
38776: LIST
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 3
38784: PUSH
38785: LD_INT 24
38787: PUSH
38788: LD_INT 250
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: LIST
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PPUSH
38808: CALL_OW 72
38812: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
38813: LD_ADDR_VAR 0 7
38817: PUSH
38818: LD_VAR 0 5
38822: PUSH
38823: LD_VAR 0 6
38827: DIFF
38828: ST_TO_ADDR
// if not need_heal_1 then
38829: LD_VAR 0 6
38833: NOT
38834: IFFALSE 38867
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
38836: LD_ADDR_EXP 102
38840: PUSH
38841: LD_EXP 102
38845: PPUSH
38846: LD_VAR 0 2
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PPUSH
38858: EMPTY
38859: PPUSH
38860: CALL 66187 0 3
38864: ST_TO_ADDR
38865: GO 38937
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
38867: LD_ADDR_EXP 102
38871: PUSH
38872: LD_EXP 102
38876: PPUSH
38877: LD_VAR 0 2
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PPUSH
38889: LD_EXP 102
38893: PUSH
38894: LD_VAR 0 2
38898: ARRAY
38899: PUSH
38900: LD_INT 1
38902: ARRAY
38903: PPUSH
38904: LD_INT 3
38906: PUSH
38907: LD_INT 24
38909: PUSH
38910: LD_INT 1000
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: EMPTY
38918: LIST
38919: LIST
38920: PPUSH
38921: CALL_OW 72
38925: PUSH
38926: LD_VAR 0 6
38930: UNION
38931: PPUSH
38932: CALL 66187 0 3
38936: ST_TO_ADDR
// if not need_heal_2 then
38937: LD_VAR 0 7
38941: NOT
38942: IFFALSE 38975
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
38944: LD_ADDR_EXP 102
38948: PUSH
38949: LD_EXP 102
38953: PPUSH
38954: LD_VAR 0 2
38958: PUSH
38959: LD_INT 2
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PPUSH
38966: EMPTY
38967: PPUSH
38968: CALL 66187 0 3
38972: ST_TO_ADDR
38973: GO 39007
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
38975: LD_ADDR_EXP 102
38979: PUSH
38980: LD_EXP 102
38984: PPUSH
38985: LD_VAR 0 2
38989: PUSH
38990: LD_INT 2
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PPUSH
38997: LD_VAR 0 7
39001: PPUSH
39002: CALL 66187 0 3
39006: ST_TO_ADDR
// if need_heal_2 then
39007: LD_VAR 0 7
39011: IFFALSE 39183
// for j in need_heal_2 do
39013: LD_ADDR_VAR 0 3
39017: PUSH
39018: LD_VAR 0 7
39022: PUSH
39023: FOR_IN
39024: IFFALSE 39181
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
39026: LD_ADDR_VAR 0 5
39030: PUSH
39031: LD_EXP 99
39035: PUSH
39036: LD_VAR 0 2
39040: ARRAY
39041: PPUSH
39042: LD_INT 2
39044: PUSH
39045: LD_INT 30
39047: PUSH
39048: LD_INT 6
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 30
39057: PUSH
39058: LD_INT 7
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 30
39067: PUSH
39068: LD_INT 8
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 30
39077: PUSH
39078: LD_INT 0
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: LD_INT 30
39087: PUSH
39088: LD_INT 1
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 25
39097: PUSH
39098: LD_INT 4
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: LIST
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: PPUSH
39114: CALL_OW 72
39118: ST_TO_ADDR
// if tmp then
39119: LD_VAR 0 5
39123: IFFALSE 39179
// begin k := NearestUnitToUnit ( tmp , j ) ;
39125: LD_ADDR_VAR 0 4
39129: PUSH
39130: LD_VAR 0 5
39134: PPUSH
39135: LD_VAR 0 3
39139: PPUSH
39140: CALL_OW 74
39144: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
39145: LD_VAR 0 3
39149: PPUSH
39150: LD_VAR 0 4
39154: PPUSH
39155: CALL_OW 296
39159: PUSH
39160: LD_INT 7
39162: GREATER
39163: IFFALSE 39179
// ComMoveUnit ( j , k ) ;
39165: LD_VAR 0 3
39169: PPUSH
39170: LD_VAR 0 4
39174: PPUSH
39175: CALL_OW 112
// end ; end ;
39179: GO 39023
39181: POP
39182: POP
// if not need_heal_1 and not need_heal_2 then
39183: LD_VAR 0 6
39187: NOT
39188: PUSH
39189: LD_VAR 0 7
39193: NOT
39194: AND
39195: IFFALSE 39199
// continue ;
39197: GO 38652
// end ;
39199: GO 38652
39201: POP
39202: POP
// RaiseSailEvent ( 102 ) ;
39203: LD_INT 102
39205: PPUSH
39206: CALL_OW 427
// end ;
39210: LD_VAR 0 1
39214: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
39215: LD_INT 0
39217: PPUSH
39218: PPUSH
39219: PPUSH
39220: PPUSH
39221: PPUSH
// if not mc_bases then
39222: LD_EXP 99
39226: NOT
39227: IFFALSE 39231
// exit ;
39229: GO 39616
// for i = 1 to mc_bases do
39231: LD_ADDR_VAR 0 2
39235: PUSH
39236: DOUBLE
39237: LD_INT 1
39239: DEC
39240: ST_TO_ADDR
39241: LD_EXP 99
39245: PUSH
39246: FOR_TO
39247: IFFALSE 39614
// begin if not mc_building_need_repair [ i ] then
39249: LD_EXP 100
39253: PUSH
39254: LD_VAR 0 2
39258: ARRAY
39259: NOT
39260: IFFALSE 39298
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
39262: LD_ADDR_EXP 101
39266: PUSH
39267: LD_EXP 101
39271: PPUSH
39272: LD_VAR 0 2
39276: PPUSH
39277: EMPTY
39278: PPUSH
39279: CALL_OW 1
39283: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
39284: LD_VAR 0 2
39288: PPUSH
39289: LD_INT 101
39291: PPUSH
39292: CALL 34659 0 2
// continue ;
39296: GO 39246
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
39298: LD_ADDR_EXP 105
39302: PUSH
39303: LD_EXP 105
39307: PPUSH
39308: LD_VAR 0 2
39312: PPUSH
39313: EMPTY
39314: PPUSH
39315: CALL_OW 1
39319: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
39320: LD_VAR 0 2
39324: PPUSH
39325: LD_INT 103
39327: PPUSH
39328: CALL 34659 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
39332: LD_ADDR_VAR 0 5
39336: PUSH
39337: LD_EXP 99
39341: PUSH
39342: LD_VAR 0 2
39346: ARRAY
39347: PUSH
39348: LD_EXP 128
39352: PUSH
39353: LD_VAR 0 2
39357: ARRAY
39358: UNION
39359: PPUSH
39360: LD_INT 2
39362: PUSH
39363: LD_INT 25
39365: PUSH
39366: LD_INT 2
39368: PUSH
39369: EMPTY
39370: LIST
39371: LIST
39372: PUSH
39373: LD_INT 25
39375: PUSH
39376: LD_INT 16
39378: PUSH
39379: EMPTY
39380: LIST
39381: LIST
39382: PUSH
39383: EMPTY
39384: LIST
39385: LIST
39386: LIST
39387: PUSH
39388: EMPTY
39389: LIST
39390: PPUSH
39391: CALL_OW 72
39395: ST_TO_ADDR
// if not tmp then
39396: LD_VAR 0 5
39400: NOT
39401: IFFALSE 39405
// continue ;
39403: GO 39246
// for j in tmp do
39405: LD_ADDR_VAR 0 3
39409: PUSH
39410: LD_VAR 0 5
39414: PUSH
39415: FOR_IN
39416: IFFALSE 39610
// begin if mc_need_heal [ i ] then
39418: LD_EXP 102
39422: PUSH
39423: LD_VAR 0 2
39427: ARRAY
39428: IFFALSE 39476
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
39430: LD_VAR 0 3
39434: PUSH
39435: LD_EXP 102
39439: PUSH
39440: LD_VAR 0 2
39444: ARRAY
39445: PUSH
39446: LD_INT 1
39448: ARRAY
39449: IN
39450: PUSH
39451: LD_VAR 0 3
39455: PUSH
39456: LD_EXP 102
39460: PUSH
39461: LD_VAR 0 2
39465: ARRAY
39466: PUSH
39467: LD_INT 2
39469: ARRAY
39470: IN
39471: OR
39472: IFFALSE 39476
// continue ;
39474: GO 39415
// if IsInUnit ( j ) then
39476: LD_VAR 0 3
39480: PPUSH
39481: CALL_OW 310
39485: IFFALSE 39496
// ComExitBuilding ( j ) ;
39487: LD_VAR 0 3
39491: PPUSH
39492: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
39496: LD_VAR 0 3
39500: PUSH
39501: LD_EXP 101
39505: PUSH
39506: LD_VAR 0 2
39510: ARRAY
39511: IN
39512: NOT
39513: IFFALSE 39571
// begin SetTag ( j , 101 ) ;
39515: LD_VAR 0 3
39519: PPUSH
39520: LD_INT 101
39522: PPUSH
39523: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
39527: LD_ADDR_EXP 101
39531: PUSH
39532: LD_EXP 101
39536: PPUSH
39537: LD_VAR 0 2
39541: PUSH
39542: LD_EXP 101
39546: PUSH
39547: LD_VAR 0 2
39551: ARRAY
39552: PUSH
39553: LD_INT 1
39555: PLUS
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PPUSH
39561: LD_VAR 0 3
39565: PPUSH
39566: CALL 66187 0 3
39570: ST_TO_ADDR
// end ; wait ( 1 ) ;
39571: LD_INT 1
39573: PPUSH
39574: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
39578: LD_VAR 0 3
39582: PPUSH
39583: LD_EXP 100
39587: PUSH
39588: LD_VAR 0 2
39592: ARRAY
39593: PPUSH
39594: LD_VAR 0 3
39598: PPUSH
39599: CALL_OW 74
39603: PPUSH
39604: CALL_OW 130
// end ;
39608: GO 39415
39610: POP
39611: POP
// end ;
39612: GO 39246
39614: POP
39615: POP
// end ;
39616: LD_VAR 0 1
39620: RET
// export function MC_Heal ; var i , j , tmp ; begin
39621: LD_INT 0
39623: PPUSH
39624: PPUSH
39625: PPUSH
39626: PPUSH
// if not mc_bases then
39627: LD_EXP 99
39631: NOT
39632: IFFALSE 39636
// exit ;
39634: GO 40038
// for i = 1 to mc_bases do
39636: LD_ADDR_VAR 0 2
39640: PUSH
39641: DOUBLE
39642: LD_INT 1
39644: DEC
39645: ST_TO_ADDR
39646: LD_EXP 99
39650: PUSH
39651: FOR_TO
39652: IFFALSE 40036
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
39654: LD_EXP 102
39658: PUSH
39659: LD_VAR 0 2
39663: ARRAY
39664: PUSH
39665: LD_INT 1
39667: ARRAY
39668: NOT
39669: PUSH
39670: LD_EXP 102
39674: PUSH
39675: LD_VAR 0 2
39679: ARRAY
39680: PUSH
39681: LD_INT 2
39683: ARRAY
39684: NOT
39685: AND
39686: IFFALSE 39724
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
39688: LD_ADDR_EXP 103
39692: PUSH
39693: LD_EXP 103
39697: PPUSH
39698: LD_VAR 0 2
39702: PPUSH
39703: EMPTY
39704: PPUSH
39705: CALL_OW 1
39709: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
39710: LD_VAR 0 2
39714: PPUSH
39715: LD_INT 102
39717: PPUSH
39718: CALL 34659 0 2
// continue ;
39722: GO 39651
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39724: LD_ADDR_VAR 0 4
39728: PUSH
39729: LD_EXP 99
39733: PUSH
39734: LD_VAR 0 2
39738: ARRAY
39739: PPUSH
39740: LD_INT 25
39742: PUSH
39743: LD_INT 4
39745: PUSH
39746: EMPTY
39747: LIST
39748: LIST
39749: PPUSH
39750: CALL_OW 72
39754: ST_TO_ADDR
// if not tmp then
39755: LD_VAR 0 4
39759: NOT
39760: IFFALSE 39764
// continue ;
39762: GO 39651
// if mc_taming [ i ] then
39764: LD_EXP 130
39768: PUSH
39769: LD_VAR 0 2
39773: ARRAY
39774: IFFALSE 39798
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
39776: LD_ADDR_EXP 130
39780: PUSH
39781: LD_EXP 130
39785: PPUSH
39786: LD_VAR 0 2
39790: PPUSH
39791: EMPTY
39792: PPUSH
39793: CALL_OW 1
39797: ST_TO_ADDR
// for j in tmp do
39798: LD_ADDR_VAR 0 3
39802: PUSH
39803: LD_VAR 0 4
39807: PUSH
39808: FOR_IN
39809: IFFALSE 40032
// begin if IsInUnit ( j ) then
39811: LD_VAR 0 3
39815: PPUSH
39816: CALL_OW 310
39820: IFFALSE 39831
// ComExitBuilding ( j ) ;
39822: LD_VAR 0 3
39826: PPUSH
39827: CALL_OW 122
// if not j in mc_healers [ i ] then
39831: LD_VAR 0 3
39835: PUSH
39836: LD_EXP 103
39840: PUSH
39841: LD_VAR 0 2
39845: ARRAY
39846: IN
39847: NOT
39848: IFFALSE 39894
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
39850: LD_ADDR_EXP 103
39854: PUSH
39855: LD_EXP 103
39859: PPUSH
39860: LD_VAR 0 2
39864: PUSH
39865: LD_EXP 103
39869: PUSH
39870: LD_VAR 0 2
39874: ARRAY
39875: PUSH
39876: LD_INT 1
39878: PLUS
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PPUSH
39884: LD_VAR 0 3
39888: PPUSH
39889: CALL 66187 0 3
39893: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
39894: LD_VAR 0 3
39898: PPUSH
39899: CALL_OW 110
39903: PUSH
39904: LD_INT 102
39906: NONEQUAL
39907: IFFALSE 39921
// SetTag ( j , 102 ) ;
39909: LD_VAR 0 3
39913: PPUSH
39914: LD_INT 102
39916: PPUSH
39917: CALL_OW 109
// Wait ( 3 ) ;
39921: LD_INT 3
39923: PPUSH
39924: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
39928: LD_EXP 102
39932: PUSH
39933: LD_VAR 0 2
39937: ARRAY
39938: PUSH
39939: LD_INT 1
39941: ARRAY
39942: IFFALSE 39974
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
39944: LD_VAR 0 3
39948: PPUSH
39949: LD_EXP 102
39953: PUSH
39954: LD_VAR 0 2
39958: ARRAY
39959: PUSH
39960: LD_INT 1
39962: ARRAY
39963: PUSH
39964: LD_INT 1
39966: ARRAY
39967: PPUSH
39968: CALL_OW 128
39972: GO 40030
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
39974: LD_VAR 0 3
39978: PPUSH
39979: CALL_OW 314
39983: NOT
39984: PUSH
39985: LD_EXP 102
39989: PUSH
39990: LD_VAR 0 2
39994: ARRAY
39995: PUSH
39996: LD_INT 2
39998: ARRAY
39999: AND
40000: IFFALSE 40030
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
40002: LD_VAR 0 3
40006: PPUSH
40007: LD_EXP 102
40011: PUSH
40012: LD_VAR 0 2
40016: ARRAY
40017: PUSH
40018: LD_INT 2
40020: ARRAY
40021: PUSH
40022: LD_INT 1
40024: ARRAY
40025: PPUSH
40026: CALL_OW 128
// end ;
40030: GO 39808
40032: POP
40033: POP
// end ;
40034: GO 39651
40036: POP
40037: POP
// end ;
40038: LD_VAR 0 1
40042: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
40043: LD_INT 0
40045: PPUSH
40046: PPUSH
40047: PPUSH
40048: PPUSH
40049: PPUSH
// if not mc_bases then
40050: LD_EXP 99
40054: NOT
40055: IFFALSE 40059
// exit ;
40057: GO 41202
// for i = 1 to mc_bases do
40059: LD_ADDR_VAR 0 2
40063: PUSH
40064: DOUBLE
40065: LD_INT 1
40067: DEC
40068: ST_TO_ADDR
40069: LD_EXP 99
40073: PUSH
40074: FOR_TO
40075: IFFALSE 41200
// begin if mc_scan [ i ] then
40077: LD_EXP 122
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: IFFALSE 40091
// continue ;
40089: GO 40074
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
40091: LD_EXP 104
40095: PUSH
40096: LD_VAR 0 2
40100: ARRAY
40101: NOT
40102: PUSH
40103: LD_EXP 106
40107: PUSH
40108: LD_VAR 0 2
40112: ARRAY
40113: NOT
40114: AND
40115: PUSH
40116: LD_EXP 105
40120: PUSH
40121: LD_VAR 0 2
40125: ARRAY
40126: AND
40127: IFFALSE 40165
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
40129: LD_ADDR_EXP 105
40133: PUSH
40134: LD_EXP 105
40138: PPUSH
40139: LD_VAR 0 2
40143: PPUSH
40144: EMPTY
40145: PPUSH
40146: CALL_OW 1
40150: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
40151: LD_VAR 0 2
40155: PPUSH
40156: LD_INT 103
40158: PPUSH
40159: CALL 34659 0 2
// continue ;
40163: GO 40074
// end ; if mc_construct_list [ i ] then
40165: LD_EXP 106
40169: PUSH
40170: LD_VAR 0 2
40174: ARRAY
40175: IFFALSE 40395
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
40177: LD_ADDR_VAR 0 4
40181: PUSH
40182: LD_EXP 99
40186: PUSH
40187: LD_VAR 0 2
40191: ARRAY
40192: PPUSH
40193: LD_INT 25
40195: PUSH
40196: LD_INT 2
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PPUSH
40203: CALL_OW 72
40207: PUSH
40208: LD_EXP 101
40212: PUSH
40213: LD_VAR 0 2
40217: ARRAY
40218: DIFF
40219: ST_TO_ADDR
// if not tmp then
40220: LD_VAR 0 4
40224: NOT
40225: IFFALSE 40229
// continue ;
40227: GO 40074
// for j in tmp do
40229: LD_ADDR_VAR 0 3
40233: PUSH
40234: LD_VAR 0 4
40238: PUSH
40239: FOR_IN
40240: IFFALSE 40391
// begin if not mc_builders [ i ] then
40242: LD_EXP 105
40246: PUSH
40247: LD_VAR 0 2
40251: ARRAY
40252: NOT
40253: IFFALSE 40311
// begin SetTag ( j , 103 ) ;
40255: LD_VAR 0 3
40259: PPUSH
40260: LD_INT 103
40262: PPUSH
40263: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
40267: LD_ADDR_EXP 105
40271: PUSH
40272: LD_EXP 105
40276: PPUSH
40277: LD_VAR 0 2
40281: PUSH
40282: LD_EXP 105
40286: PUSH
40287: LD_VAR 0 2
40291: ARRAY
40292: PUSH
40293: LD_INT 1
40295: PLUS
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PPUSH
40301: LD_VAR 0 3
40305: PPUSH
40306: CALL 66187 0 3
40310: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
40311: LD_VAR 0 3
40315: PPUSH
40316: CALL_OW 310
40320: IFFALSE 40331
// ComExitBuilding ( j ) ;
40322: LD_VAR 0 3
40326: PPUSH
40327: CALL_OW 122
// wait ( 3 ) ;
40331: LD_INT 3
40333: PPUSH
40334: CALL_OW 67
// if not mc_construct_list [ i ] then
40338: LD_EXP 106
40342: PUSH
40343: LD_VAR 0 2
40347: ARRAY
40348: NOT
40349: IFFALSE 40353
// break ;
40351: GO 40391
// if not HasTask ( j ) then
40353: LD_VAR 0 3
40357: PPUSH
40358: CALL_OW 314
40362: NOT
40363: IFFALSE 40389
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
40365: LD_VAR 0 3
40369: PPUSH
40370: LD_EXP 106
40374: PUSH
40375: LD_VAR 0 2
40379: ARRAY
40380: PUSH
40381: LD_INT 1
40383: ARRAY
40384: PPUSH
40385: CALL 69038 0 2
// end ;
40389: GO 40239
40391: POP
40392: POP
// end else
40393: GO 41198
// if mc_build_list [ i ] then
40395: LD_EXP 104
40399: PUSH
40400: LD_VAR 0 2
40404: ARRAY
40405: IFFALSE 41198
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40407: LD_ADDR_VAR 0 5
40411: PUSH
40412: LD_EXP 99
40416: PUSH
40417: LD_VAR 0 2
40421: ARRAY
40422: PPUSH
40423: LD_INT 2
40425: PUSH
40426: LD_INT 30
40428: PUSH
40429: LD_INT 0
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 30
40438: PUSH
40439: LD_INT 1
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: LIST
40450: PPUSH
40451: CALL_OW 72
40455: ST_TO_ADDR
// if depot then
40456: LD_VAR 0 5
40460: IFFALSE 40478
// depot := depot [ 1 ] else
40462: LD_ADDR_VAR 0 5
40466: PUSH
40467: LD_VAR 0 5
40471: PUSH
40472: LD_INT 1
40474: ARRAY
40475: ST_TO_ADDR
40476: GO 40486
// depot := 0 ;
40478: LD_ADDR_VAR 0 5
40482: PUSH
40483: LD_INT 0
40485: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
40486: LD_EXP 104
40490: PUSH
40491: LD_VAR 0 2
40495: ARRAY
40496: PUSH
40497: LD_INT 1
40499: ARRAY
40500: PUSH
40501: LD_INT 1
40503: ARRAY
40504: PPUSH
40505: CALL 68868 0 1
40509: PUSH
40510: LD_EXP 99
40514: PUSH
40515: LD_VAR 0 2
40519: ARRAY
40520: PPUSH
40521: LD_INT 2
40523: PUSH
40524: LD_INT 30
40526: PUSH
40527: LD_INT 2
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: LD_INT 30
40536: PUSH
40537: LD_INT 3
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: LIST
40548: PPUSH
40549: CALL_OW 72
40553: NOT
40554: AND
40555: IFFALSE 40660
// begin for j = 1 to mc_build_list [ i ] do
40557: LD_ADDR_VAR 0 3
40561: PUSH
40562: DOUBLE
40563: LD_INT 1
40565: DEC
40566: ST_TO_ADDR
40567: LD_EXP 104
40571: PUSH
40572: LD_VAR 0 2
40576: ARRAY
40577: PUSH
40578: FOR_TO
40579: IFFALSE 40658
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
40581: LD_EXP 104
40585: PUSH
40586: LD_VAR 0 2
40590: ARRAY
40591: PUSH
40592: LD_VAR 0 3
40596: ARRAY
40597: PUSH
40598: LD_INT 1
40600: ARRAY
40601: PUSH
40602: LD_INT 2
40604: EQUAL
40605: IFFALSE 40656
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
40607: LD_ADDR_EXP 104
40611: PUSH
40612: LD_EXP 104
40616: PPUSH
40617: LD_VAR 0 2
40621: PPUSH
40622: LD_EXP 104
40626: PUSH
40627: LD_VAR 0 2
40631: ARRAY
40632: PPUSH
40633: LD_VAR 0 3
40637: PPUSH
40638: LD_INT 1
40640: PPUSH
40641: LD_INT 0
40643: PPUSH
40644: CALL 65605 0 4
40648: PPUSH
40649: CALL_OW 1
40653: ST_TO_ADDR
// break ;
40654: GO 40658
// end ;
40656: GO 40578
40658: POP
40659: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilded ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
40660: LD_EXP 104
40664: PUSH
40665: LD_VAR 0 2
40669: ARRAY
40670: PUSH
40671: LD_INT 1
40673: ARRAY
40674: PUSH
40675: LD_INT 1
40677: ARRAY
40678: PUSH
40679: LD_INT 0
40681: EQUAL
40682: PUSH
40683: LD_VAR 0 5
40687: PUSH
40688: LD_VAR 0 5
40692: PPUSH
40693: LD_EXP 104
40697: PUSH
40698: LD_VAR 0 2
40702: ARRAY
40703: PUSH
40704: LD_INT 1
40706: ARRAY
40707: PUSH
40708: LD_INT 1
40710: ARRAY
40711: PPUSH
40712: LD_EXP 104
40716: PUSH
40717: LD_VAR 0 2
40721: ARRAY
40722: PUSH
40723: LD_INT 1
40725: ARRAY
40726: PUSH
40727: LD_INT 2
40729: ARRAY
40730: PPUSH
40731: LD_EXP 104
40735: PUSH
40736: LD_VAR 0 2
40740: ARRAY
40741: PUSH
40742: LD_INT 1
40744: ARRAY
40745: PUSH
40746: LD_INT 3
40748: ARRAY
40749: PPUSH
40750: LD_EXP 104
40754: PUSH
40755: LD_VAR 0 2
40759: ARRAY
40760: PUSH
40761: LD_INT 1
40763: ARRAY
40764: PUSH
40765: LD_INT 4
40767: ARRAY
40768: PPUSH
40769: CALL 73584 0 5
40773: AND
40774: OR
40775: IFFALSE 41056
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
40777: LD_ADDR_VAR 0 4
40781: PUSH
40782: LD_EXP 99
40786: PUSH
40787: LD_VAR 0 2
40791: ARRAY
40792: PPUSH
40793: LD_INT 25
40795: PUSH
40796: LD_INT 2
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PPUSH
40803: CALL_OW 72
40807: PUSH
40808: LD_EXP 101
40812: PUSH
40813: LD_VAR 0 2
40817: ARRAY
40818: DIFF
40819: ST_TO_ADDR
// if not tmp then
40820: LD_VAR 0 4
40824: NOT
40825: IFFALSE 40829
// continue ;
40827: GO 40074
// for j in tmp do
40829: LD_ADDR_VAR 0 3
40833: PUSH
40834: LD_VAR 0 4
40838: PUSH
40839: FOR_IN
40840: IFFALSE 41052
// begin if not mc_builders [ i ] then
40842: LD_EXP 105
40846: PUSH
40847: LD_VAR 0 2
40851: ARRAY
40852: NOT
40853: IFFALSE 40911
// begin SetTag ( j , 103 ) ;
40855: LD_VAR 0 3
40859: PPUSH
40860: LD_INT 103
40862: PPUSH
40863: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
40867: LD_ADDR_EXP 105
40871: PUSH
40872: LD_EXP 105
40876: PPUSH
40877: LD_VAR 0 2
40881: PUSH
40882: LD_EXP 105
40886: PUSH
40887: LD_VAR 0 2
40891: ARRAY
40892: PUSH
40893: LD_INT 1
40895: PLUS
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PPUSH
40901: LD_VAR 0 3
40905: PPUSH
40906: CALL 66187 0 3
40910: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
40911: LD_VAR 0 3
40915: PPUSH
40916: CALL_OW 310
40920: IFFALSE 40931
// ComExitBuilding ( j ) ;
40922: LD_VAR 0 3
40926: PPUSH
40927: CALL_OW 122
// wait ( 3 ) ;
40931: LD_INT 3
40933: PPUSH
40934: CALL_OW 67
// if not mc_build_list [ i ] then
40938: LD_EXP 104
40942: PUSH
40943: LD_VAR 0 2
40947: ARRAY
40948: NOT
40949: IFFALSE 40953
// break ;
40951: GO 41052
// if not HasTask ( j ) then
40953: LD_VAR 0 3
40957: PPUSH
40958: CALL_OW 314
40962: NOT
40963: IFFALSE 41050
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
40965: LD_VAR 0 3
40969: PPUSH
40970: LD_EXP 104
40974: PUSH
40975: LD_VAR 0 2
40979: ARRAY
40980: PUSH
40981: LD_INT 1
40983: ARRAY
40984: PUSH
40985: LD_INT 1
40987: ARRAY
40988: PPUSH
40989: LD_EXP 104
40993: PUSH
40994: LD_VAR 0 2
40998: ARRAY
40999: PUSH
41000: LD_INT 1
41002: ARRAY
41003: PUSH
41004: LD_INT 2
41006: ARRAY
41007: PPUSH
41008: LD_EXP 104
41012: PUSH
41013: LD_VAR 0 2
41017: ARRAY
41018: PUSH
41019: LD_INT 1
41021: ARRAY
41022: PUSH
41023: LD_INT 3
41025: ARRAY
41026: PPUSH
41027: LD_EXP 104
41031: PUSH
41032: LD_VAR 0 2
41036: ARRAY
41037: PUSH
41038: LD_INT 1
41040: ARRAY
41041: PUSH
41042: LD_INT 4
41044: ARRAY
41045: PPUSH
41046: CALL_OW 145
// end ;
41050: GO 40839
41052: POP
41053: POP
// end else
41054: GO 41198
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
41056: LD_EXP 99
41060: PUSH
41061: LD_VAR 0 2
41065: ARRAY
41066: PPUSH
41067: LD_EXP 104
41071: PUSH
41072: LD_VAR 0 2
41076: ARRAY
41077: PUSH
41078: LD_INT 1
41080: ARRAY
41081: PUSH
41082: LD_INT 1
41084: ARRAY
41085: PPUSH
41086: LD_EXP 104
41090: PUSH
41091: LD_VAR 0 2
41095: ARRAY
41096: PUSH
41097: LD_INT 1
41099: ARRAY
41100: PUSH
41101: LD_INT 2
41103: ARRAY
41104: PPUSH
41105: LD_EXP 104
41109: PUSH
41110: LD_VAR 0 2
41114: ARRAY
41115: PUSH
41116: LD_INT 1
41118: ARRAY
41119: PUSH
41120: LD_INT 3
41122: ARRAY
41123: PPUSH
41124: LD_EXP 104
41128: PUSH
41129: LD_VAR 0 2
41133: ARRAY
41134: PUSH
41135: LD_INT 1
41137: ARRAY
41138: PUSH
41139: LD_INT 4
41141: ARRAY
41142: PPUSH
41143: CALL 72938 0 5
41147: NOT
41148: IFFALSE 41198
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
41150: LD_ADDR_EXP 104
41154: PUSH
41155: LD_EXP 104
41159: PPUSH
41160: LD_VAR 0 2
41164: PPUSH
41165: LD_EXP 104
41169: PUSH
41170: LD_VAR 0 2
41174: ARRAY
41175: PPUSH
41176: LD_INT 1
41178: PPUSH
41179: LD_INT 1
41181: NEG
41182: PPUSH
41183: LD_INT 0
41185: PPUSH
41186: CALL 65605 0 4
41190: PPUSH
41191: CALL_OW 1
41195: ST_TO_ADDR
// continue ;
41196: GO 40074
// end ; end ; end ;
41198: GO 40074
41200: POP
41201: POP
// end ;
41202: LD_VAR 0 1
41206: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
41207: LD_INT 0
41209: PPUSH
41210: PPUSH
41211: PPUSH
41212: PPUSH
41213: PPUSH
41214: PPUSH
// if not mc_bases then
41215: LD_EXP 99
41219: NOT
41220: IFFALSE 41224
// exit ;
41222: GO 41651
// for i = 1 to mc_bases do
41224: LD_ADDR_VAR 0 2
41228: PUSH
41229: DOUBLE
41230: LD_INT 1
41232: DEC
41233: ST_TO_ADDR
41234: LD_EXP 99
41238: PUSH
41239: FOR_TO
41240: IFFALSE 41649
// begin tmp := mc_build_upgrade [ i ] ;
41242: LD_ADDR_VAR 0 4
41246: PUSH
41247: LD_EXP 131
41251: PUSH
41252: LD_VAR 0 2
41256: ARRAY
41257: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
41258: LD_ADDR_VAR 0 6
41262: PUSH
41263: LD_EXP 132
41267: PUSH
41268: LD_VAR 0 2
41272: ARRAY
41273: PPUSH
41274: LD_INT 2
41276: PUSH
41277: LD_INT 30
41279: PUSH
41280: LD_INT 6
41282: PUSH
41283: EMPTY
41284: LIST
41285: LIST
41286: PUSH
41287: LD_INT 30
41289: PUSH
41290: LD_INT 7
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: LIST
41301: PPUSH
41302: CALL_OW 72
41306: ST_TO_ADDR
// if not tmp and not lab then
41307: LD_VAR 0 4
41311: NOT
41312: PUSH
41313: LD_VAR 0 6
41317: NOT
41318: AND
41319: IFFALSE 41323
// continue ;
41321: GO 41239
// if tmp then
41323: LD_VAR 0 4
41327: IFFALSE 41447
// for j in tmp do
41329: LD_ADDR_VAR 0 3
41333: PUSH
41334: LD_VAR 0 4
41338: PUSH
41339: FOR_IN
41340: IFFALSE 41445
// begin if UpgradeCost ( j ) then
41342: LD_VAR 0 3
41346: PPUSH
41347: CALL 72598 0 1
41351: IFFALSE 41443
// begin ComUpgrade ( j ) ;
41353: LD_VAR 0 3
41357: PPUSH
41358: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
41362: LD_ADDR_EXP 131
41366: PUSH
41367: LD_EXP 131
41371: PPUSH
41372: LD_VAR 0 2
41376: PPUSH
41377: LD_EXP 131
41381: PUSH
41382: LD_VAR 0 2
41386: ARRAY
41387: PUSH
41388: LD_VAR 0 3
41392: DIFF
41393: PPUSH
41394: CALL_OW 1
41398: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
41399: LD_ADDR_EXP 106
41403: PUSH
41404: LD_EXP 106
41408: PPUSH
41409: LD_VAR 0 2
41413: PUSH
41414: LD_EXP 106
41418: PUSH
41419: LD_VAR 0 2
41423: ARRAY
41424: PUSH
41425: LD_INT 1
41427: PLUS
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PPUSH
41433: LD_VAR 0 3
41437: PPUSH
41438: CALL 66187 0 3
41442: ST_TO_ADDR
// end ; end ;
41443: GO 41339
41445: POP
41446: POP
// if not lab or not mc_lab_upgrade [ i ] then
41447: LD_VAR 0 6
41451: NOT
41452: PUSH
41453: LD_EXP 133
41457: PUSH
41458: LD_VAR 0 2
41462: ARRAY
41463: NOT
41464: OR
41465: IFFALSE 41469
// continue ;
41467: GO 41239
// for j in lab do
41469: LD_ADDR_VAR 0 3
41473: PUSH
41474: LD_VAR 0 6
41478: PUSH
41479: FOR_IN
41480: IFFALSE 41645
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
41482: LD_VAR 0 3
41486: PPUSH
41487: CALL_OW 266
41491: PUSH
41492: LD_INT 6
41494: PUSH
41495: LD_INT 7
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: IN
41502: PUSH
41503: LD_VAR 0 3
41507: PPUSH
41508: CALL_OW 461
41512: PUSH
41513: LD_INT 1
41515: NONEQUAL
41516: AND
41517: IFFALSE 41643
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
41519: LD_VAR 0 3
41523: PPUSH
41524: LD_EXP 133
41528: PUSH
41529: LD_VAR 0 2
41533: ARRAY
41534: PUSH
41535: LD_INT 1
41537: ARRAY
41538: PPUSH
41539: CALL 72803 0 2
41543: IFFALSE 41643
// begin ComCancel ( j ) ;
41545: LD_VAR 0 3
41549: PPUSH
41550: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
41554: LD_VAR 0 3
41558: PPUSH
41559: LD_EXP 133
41563: PUSH
41564: LD_VAR 0 2
41568: ARRAY
41569: PUSH
41570: LD_INT 1
41572: ARRAY
41573: PPUSH
41574: CALL_OW 207
// if not j in mc_construct_list [ i ] then
41578: LD_VAR 0 3
41582: PUSH
41583: LD_EXP 106
41587: PUSH
41588: LD_VAR 0 2
41592: ARRAY
41593: IN
41594: NOT
41595: IFFALSE 41641
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
41597: LD_ADDR_EXP 106
41601: PUSH
41602: LD_EXP 106
41606: PPUSH
41607: LD_VAR 0 2
41611: PUSH
41612: LD_EXP 106
41616: PUSH
41617: LD_VAR 0 2
41621: ARRAY
41622: PUSH
41623: LD_INT 1
41625: PLUS
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PPUSH
41631: LD_VAR 0 3
41635: PPUSH
41636: CALL 66187 0 3
41640: ST_TO_ADDR
// break ;
41641: GO 41645
// end ; end ; end ;
41643: GO 41479
41645: POP
41646: POP
// end ;
41647: GO 41239
41649: POP
41650: POP
// end ;
41651: LD_VAR 0 1
41655: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
41656: LD_INT 0
41658: PPUSH
41659: PPUSH
41660: PPUSH
41661: PPUSH
41662: PPUSH
41663: PPUSH
41664: PPUSH
41665: PPUSH
41666: PPUSH
// if not mc_bases then
41667: LD_EXP 99
41671: NOT
41672: IFFALSE 41676
// exit ;
41674: GO 42081
// for i = 1 to mc_bases do
41676: LD_ADDR_VAR 0 2
41680: PUSH
41681: DOUBLE
41682: LD_INT 1
41684: DEC
41685: ST_TO_ADDR
41686: LD_EXP 99
41690: PUSH
41691: FOR_TO
41692: IFFALSE 42079
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
41694: LD_EXP 107
41698: PUSH
41699: LD_VAR 0 2
41703: ARRAY
41704: NOT
41705: PUSH
41706: LD_EXP 99
41710: PUSH
41711: LD_VAR 0 2
41715: ARRAY
41716: PPUSH
41717: LD_INT 30
41719: PUSH
41720: LD_INT 3
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PPUSH
41727: CALL_OW 72
41731: NOT
41732: OR
41733: IFFALSE 41737
// continue ;
41735: GO 41691
// busy := false ;
41737: LD_ADDR_VAR 0 8
41741: PUSH
41742: LD_INT 0
41744: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
41745: LD_ADDR_VAR 0 4
41749: PUSH
41750: LD_EXP 99
41754: PUSH
41755: LD_VAR 0 2
41759: ARRAY
41760: PPUSH
41761: LD_INT 30
41763: PUSH
41764: LD_INT 3
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PPUSH
41771: CALL_OW 72
41775: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
41776: LD_ADDR_VAR 0 6
41780: PUSH
41781: LD_EXP 107
41785: PUSH
41786: LD_VAR 0 2
41790: ARRAY
41791: PPUSH
41792: LD_INT 2
41794: PUSH
41795: LD_INT 30
41797: PUSH
41798: LD_INT 32
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 30
41807: PUSH
41808: LD_INT 33
41810: PUSH
41811: EMPTY
41812: LIST
41813: LIST
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: LIST
41819: PPUSH
41820: CALL_OW 72
41824: ST_TO_ADDR
// if not t then
41825: LD_VAR 0 6
41829: NOT
41830: IFFALSE 41834
// continue ;
41832: GO 41691
// for j in tmp do
41834: LD_ADDR_VAR 0 3
41838: PUSH
41839: LD_VAR 0 4
41843: PUSH
41844: FOR_IN
41845: IFFALSE 41875
// if not BuildingStatus ( j ) = bs_idle then
41847: LD_VAR 0 3
41851: PPUSH
41852: CALL_OW 461
41856: PUSH
41857: LD_INT 2
41859: EQUAL
41860: NOT
41861: IFFALSE 41873
// begin busy := true ;
41863: LD_ADDR_VAR 0 8
41867: PUSH
41868: LD_INT 1
41870: ST_TO_ADDR
// break ;
41871: GO 41875
// end ;
41873: GO 41844
41875: POP
41876: POP
// if busy then
41877: LD_VAR 0 8
41881: IFFALSE 41885
// continue ;
41883: GO 41691
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
41885: LD_ADDR_VAR 0 7
41889: PUSH
41890: LD_VAR 0 6
41894: PPUSH
41895: LD_INT 35
41897: PUSH
41898: LD_INT 0
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PPUSH
41905: CALL_OW 72
41909: ST_TO_ADDR
// if tw then
41910: LD_VAR 0 7
41914: IFFALSE 41991
// begin tw := tw [ 1 ] ;
41916: LD_ADDR_VAR 0 7
41920: PUSH
41921: LD_VAR 0 7
41925: PUSH
41926: LD_INT 1
41928: ARRAY
41929: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
41930: LD_ADDR_VAR 0 9
41934: PUSH
41935: LD_VAR 0 7
41939: PPUSH
41940: LD_EXP 124
41944: PUSH
41945: LD_VAR 0 2
41949: ARRAY
41950: PPUSH
41951: CALL 71157 0 2
41955: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
41956: LD_EXP 138
41960: PUSH
41961: LD_VAR 0 2
41965: ARRAY
41966: IFFALSE 41989
// if not weapon in mc_allowed_tower_weapons [ i ] then
41968: LD_VAR 0 9
41972: PUSH
41973: LD_EXP 138
41977: PUSH
41978: LD_VAR 0 2
41982: ARRAY
41983: IN
41984: NOT
41985: IFFALSE 41989
// continue ;
41987: GO 41691
// end else
41989: GO 42054
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
41991: LD_ADDR_VAR 0 5
41995: PUSH
41996: LD_EXP 107
42000: PUSH
42001: LD_VAR 0 2
42005: ARRAY
42006: PPUSH
42007: LD_VAR 0 4
42011: PPUSH
42012: CALL 101296 0 2
42016: ST_TO_ADDR
// if not tmp2 then
42017: LD_VAR 0 5
42021: NOT
42022: IFFALSE 42026
// continue ;
42024: GO 41691
// tw := tmp2 [ 1 ] ;
42026: LD_ADDR_VAR 0 7
42030: PUSH
42031: LD_VAR 0 5
42035: PUSH
42036: LD_INT 1
42038: ARRAY
42039: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
42040: LD_ADDR_VAR 0 9
42044: PUSH
42045: LD_VAR 0 5
42049: PUSH
42050: LD_INT 2
42052: ARRAY
42053: ST_TO_ADDR
// end ; if not weapon then
42054: LD_VAR 0 9
42058: NOT
42059: IFFALSE 42063
// continue ;
42061: GO 41691
// ComPlaceWeapon ( tw , weapon ) ;
42063: LD_VAR 0 7
42067: PPUSH
42068: LD_VAR 0 9
42072: PPUSH
42073: CALL_OW 148
// end ;
42077: GO 41691
42079: POP
42080: POP
// end ;
42081: LD_VAR 0 1
42085: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
42086: LD_INT 0
42088: PPUSH
42089: PPUSH
42090: PPUSH
42091: PPUSH
42092: PPUSH
42093: PPUSH
// if not mc_bases then
42094: LD_EXP 99
42098: NOT
42099: IFFALSE 42103
// exit ;
42101: GO 43115
// for i = 1 to mc_bases do
42103: LD_ADDR_VAR 0 2
42107: PUSH
42108: DOUBLE
42109: LD_INT 1
42111: DEC
42112: ST_TO_ADDR
42113: LD_EXP 99
42117: PUSH
42118: FOR_TO
42119: IFFALSE 43113
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
42121: LD_EXP 112
42125: PUSH
42126: LD_VAR 0 2
42130: ARRAY
42131: NOT
42132: PUSH
42133: LD_EXP 112
42137: PUSH
42138: LD_VAR 0 2
42142: ARRAY
42143: PUSH
42144: LD_EXP 113
42148: PUSH
42149: LD_VAR 0 2
42153: ARRAY
42154: EQUAL
42155: OR
42156: IFFALSE 42160
// continue ;
42158: GO 42118
// if mc_miners [ i ] then
42160: LD_EXP 113
42164: PUSH
42165: LD_VAR 0 2
42169: ARRAY
42170: IFFALSE 42800
// begin k := 1 ;
42172: LD_ADDR_VAR 0 4
42176: PUSH
42177: LD_INT 1
42179: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
42180: LD_ADDR_VAR 0 3
42184: PUSH
42185: DOUBLE
42186: LD_EXP 113
42190: PUSH
42191: LD_VAR 0 2
42195: ARRAY
42196: INC
42197: ST_TO_ADDR
42198: LD_INT 1
42200: PUSH
42201: FOR_DOWNTO
42202: IFFALSE 42798
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
42204: LD_EXP 113
42208: PUSH
42209: LD_VAR 0 2
42213: ARRAY
42214: PUSH
42215: LD_VAR 0 3
42219: ARRAY
42220: PPUSH
42221: CALL_OW 301
42225: PUSH
42226: LD_EXP 113
42230: PUSH
42231: LD_VAR 0 2
42235: ARRAY
42236: PUSH
42237: LD_VAR 0 3
42241: ARRAY
42242: PPUSH
42243: CALL_OW 257
42247: PUSH
42248: LD_INT 1
42250: NONEQUAL
42251: OR
42252: IFFALSE 42315
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
42254: LD_ADDR_VAR 0 5
42258: PUSH
42259: LD_EXP 113
42263: PUSH
42264: LD_VAR 0 2
42268: ARRAY
42269: PUSH
42270: LD_EXP 113
42274: PUSH
42275: LD_VAR 0 2
42279: ARRAY
42280: PUSH
42281: LD_VAR 0 3
42285: ARRAY
42286: DIFF
42287: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
42288: LD_ADDR_EXP 113
42292: PUSH
42293: LD_EXP 113
42297: PPUSH
42298: LD_VAR 0 2
42302: PPUSH
42303: LD_VAR 0 5
42307: PPUSH
42308: CALL_OW 1
42312: ST_TO_ADDR
// continue ;
42313: GO 42201
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
42315: LD_EXP 113
42319: PUSH
42320: LD_VAR 0 2
42324: ARRAY
42325: PUSH
42326: LD_VAR 0 3
42330: ARRAY
42331: PPUSH
42332: CALL 66123 0 1
42336: PUSH
42337: LD_EXP 113
42341: PUSH
42342: LD_VAR 0 2
42346: ARRAY
42347: PUSH
42348: LD_VAR 0 3
42352: ARRAY
42353: PPUSH
42354: CALL_OW 255
42358: PPUSH
42359: LD_EXP 112
42363: PUSH
42364: LD_VAR 0 2
42368: ARRAY
42369: PUSH
42370: LD_VAR 0 4
42374: ARRAY
42375: PUSH
42376: LD_INT 1
42378: ARRAY
42379: PPUSH
42380: LD_EXP 112
42384: PUSH
42385: LD_VAR 0 2
42389: ARRAY
42390: PUSH
42391: LD_VAR 0 4
42395: ARRAY
42396: PUSH
42397: LD_INT 2
42399: ARRAY
42400: PPUSH
42401: LD_INT 15
42403: PPUSH
42404: CALL 67083 0 4
42408: PUSH
42409: LD_INT 4
42411: ARRAY
42412: PUSH
42413: LD_EXP 113
42417: PUSH
42418: LD_VAR 0 2
42422: ARRAY
42423: PUSH
42424: LD_VAR 0 3
42428: ARRAY
42429: PPUSH
42430: LD_INT 10
42432: PPUSH
42433: CALL 68780 0 2
42437: PUSH
42438: LD_INT 4
42440: ARRAY
42441: OR
42442: AND
42443: IFFALSE 42466
// ComStop ( mc_miners [ i ] [ j ] ) ;
42445: LD_EXP 113
42449: PUSH
42450: LD_VAR 0 2
42454: ARRAY
42455: PUSH
42456: LD_VAR 0 3
42460: ARRAY
42461: PPUSH
42462: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
42466: LD_EXP 113
42470: PUSH
42471: LD_VAR 0 2
42475: ARRAY
42476: PUSH
42477: LD_VAR 0 3
42481: ARRAY
42482: PPUSH
42483: CALL_OW 257
42487: PUSH
42488: LD_INT 1
42490: EQUAL
42491: PUSH
42492: LD_EXP 113
42496: PUSH
42497: LD_VAR 0 2
42501: ARRAY
42502: PUSH
42503: LD_VAR 0 3
42507: ARRAY
42508: PPUSH
42509: CALL_OW 459
42513: NOT
42514: AND
42515: PUSH
42516: LD_EXP 113
42520: PUSH
42521: LD_VAR 0 2
42525: ARRAY
42526: PUSH
42527: LD_VAR 0 3
42531: ARRAY
42532: PPUSH
42533: CALL_OW 255
42537: PPUSH
42538: LD_EXP 112
42542: PUSH
42543: LD_VAR 0 2
42547: ARRAY
42548: PUSH
42549: LD_VAR 0 4
42553: ARRAY
42554: PUSH
42555: LD_INT 1
42557: ARRAY
42558: PPUSH
42559: LD_EXP 112
42563: PUSH
42564: LD_VAR 0 2
42568: ARRAY
42569: PUSH
42570: LD_VAR 0 4
42574: ARRAY
42575: PUSH
42576: LD_INT 2
42578: ARRAY
42579: PPUSH
42580: LD_INT 15
42582: PPUSH
42583: CALL 67083 0 4
42587: PUSH
42588: LD_INT 4
42590: ARRAY
42591: PUSH
42592: LD_INT 0
42594: EQUAL
42595: AND
42596: PUSH
42597: LD_EXP 113
42601: PUSH
42602: LD_VAR 0 2
42606: ARRAY
42607: PUSH
42608: LD_VAR 0 3
42612: ARRAY
42613: PPUSH
42614: CALL_OW 314
42618: NOT
42619: AND
42620: IFFALSE 42796
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
42622: LD_EXP 113
42626: PUSH
42627: LD_VAR 0 2
42631: ARRAY
42632: PUSH
42633: LD_VAR 0 3
42637: ARRAY
42638: PPUSH
42639: CALL_OW 310
42643: IFFALSE 42666
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
42645: LD_EXP 113
42649: PUSH
42650: LD_VAR 0 2
42654: ARRAY
42655: PUSH
42656: LD_VAR 0 3
42660: ARRAY
42661: PPUSH
42662: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
42666: LD_EXP 113
42670: PUSH
42671: LD_VAR 0 2
42675: ARRAY
42676: PUSH
42677: LD_VAR 0 3
42681: ARRAY
42682: PPUSH
42683: CALL_OW 314
42687: NOT
42688: IFFALSE 42756
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
42690: LD_EXP 113
42694: PUSH
42695: LD_VAR 0 2
42699: ARRAY
42700: PUSH
42701: LD_VAR 0 3
42705: ARRAY
42706: PPUSH
42707: LD_EXP 112
42711: PUSH
42712: LD_VAR 0 2
42716: ARRAY
42717: PUSH
42718: LD_VAR 0 4
42722: ARRAY
42723: PUSH
42724: LD_INT 1
42726: ARRAY
42727: PPUSH
42728: LD_EXP 112
42732: PUSH
42733: LD_VAR 0 2
42737: ARRAY
42738: PUSH
42739: LD_VAR 0 4
42743: ARRAY
42744: PUSH
42745: LD_INT 2
42747: ARRAY
42748: PPUSH
42749: LD_INT 0
42751: PPUSH
42752: CALL_OW 193
// k := k + 1 ;
42756: LD_ADDR_VAR 0 4
42760: PUSH
42761: LD_VAR 0 4
42765: PUSH
42766: LD_INT 1
42768: PLUS
42769: ST_TO_ADDR
// if k > mc_mines [ i ] then
42770: LD_VAR 0 4
42774: PUSH
42775: LD_EXP 112
42779: PUSH
42780: LD_VAR 0 2
42784: ARRAY
42785: GREATER
42786: IFFALSE 42796
// k := 1 ;
42788: LD_ADDR_VAR 0 4
42792: PUSH
42793: LD_INT 1
42795: ST_TO_ADDR
// end ; end ;
42796: GO 42201
42798: POP
42799: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
42800: LD_ADDR_VAR 0 5
42804: PUSH
42805: LD_EXP 99
42809: PUSH
42810: LD_VAR 0 2
42814: ARRAY
42815: PPUSH
42816: LD_INT 2
42818: PUSH
42819: LD_INT 30
42821: PUSH
42822: LD_INT 4
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: LD_INT 30
42831: PUSH
42832: LD_INT 5
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 30
42841: PUSH
42842: LD_INT 32
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: PPUSH
42855: CALL_OW 72
42859: ST_TO_ADDR
// if not tmp then
42860: LD_VAR 0 5
42864: NOT
42865: IFFALSE 42869
// continue ;
42867: GO 42118
// list := [ ] ;
42869: LD_ADDR_VAR 0 6
42873: PUSH
42874: EMPTY
42875: ST_TO_ADDR
// for j in tmp do
42876: LD_ADDR_VAR 0 3
42880: PUSH
42881: LD_VAR 0 5
42885: PUSH
42886: FOR_IN
42887: IFFALSE 42956
// begin for k in UnitsInside ( j ) do
42889: LD_ADDR_VAR 0 4
42893: PUSH
42894: LD_VAR 0 3
42898: PPUSH
42899: CALL_OW 313
42903: PUSH
42904: FOR_IN
42905: IFFALSE 42952
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
42907: LD_VAR 0 4
42911: PPUSH
42912: CALL_OW 257
42916: PUSH
42917: LD_INT 1
42919: EQUAL
42920: PUSH
42921: LD_VAR 0 4
42925: PPUSH
42926: CALL_OW 459
42930: NOT
42931: AND
42932: IFFALSE 42950
// list := list ^ k ;
42934: LD_ADDR_VAR 0 6
42938: PUSH
42939: LD_VAR 0 6
42943: PUSH
42944: LD_VAR 0 4
42948: ADD
42949: ST_TO_ADDR
42950: GO 42904
42952: POP
42953: POP
// end ;
42954: GO 42886
42956: POP
42957: POP
// list := list diff mc_miners [ i ] ;
42958: LD_ADDR_VAR 0 6
42962: PUSH
42963: LD_VAR 0 6
42967: PUSH
42968: LD_EXP 113
42972: PUSH
42973: LD_VAR 0 2
42977: ARRAY
42978: DIFF
42979: ST_TO_ADDR
// if not list then
42980: LD_VAR 0 6
42984: NOT
42985: IFFALSE 42989
// continue ;
42987: GO 42118
// k := mc_mines [ i ] - mc_miners [ i ] ;
42989: LD_ADDR_VAR 0 4
42993: PUSH
42994: LD_EXP 112
42998: PUSH
42999: LD_VAR 0 2
43003: ARRAY
43004: PUSH
43005: LD_EXP 113
43009: PUSH
43010: LD_VAR 0 2
43014: ARRAY
43015: MINUS
43016: ST_TO_ADDR
// if k > list then
43017: LD_VAR 0 4
43021: PUSH
43022: LD_VAR 0 6
43026: GREATER
43027: IFFALSE 43039
// k := list ;
43029: LD_ADDR_VAR 0 4
43033: PUSH
43034: LD_VAR 0 6
43038: ST_TO_ADDR
// for j = 1 to k do
43039: LD_ADDR_VAR 0 3
43043: PUSH
43044: DOUBLE
43045: LD_INT 1
43047: DEC
43048: ST_TO_ADDR
43049: LD_VAR 0 4
43053: PUSH
43054: FOR_TO
43055: IFFALSE 43109
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
43057: LD_ADDR_EXP 113
43061: PUSH
43062: LD_EXP 113
43066: PPUSH
43067: LD_VAR 0 2
43071: PUSH
43072: LD_EXP 113
43076: PUSH
43077: LD_VAR 0 2
43081: ARRAY
43082: PUSH
43083: LD_INT 1
43085: PLUS
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PPUSH
43091: LD_VAR 0 6
43095: PUSH
43096: LD_VAR 0 3
43100: ARRAY
43101: PPUSH
43102: CALL 66187 0 3
43106: ST_TO_ADDR
43107: GO 43054
43109: POP
43110: POP
// end ;
43111: GO 42118
43113: POP
43114: POP
// end ;
43115: LD_VAR 0 1
43119: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
43120: LD_INT 0
43122: PPUSH
43123: PPUSH
43124: PPUSH
43125: PPUSH
43126: PPUSH
43127: PPUSH
43128: PPUSH
43129: PPUSH
43130: PPUSH
43131: PPUSH
// if not mc_bases then
43132: LD_EXP 99
43136: NOT
43137: IFFALSE 43141
// exit ;
43139: GO 44872
// for i = 1 to mc_bases do
43141: LD_ADDR_VAR 0 2
43145: PUSH
43146: DOUBLE
43147: LD_INT 1
43149: DEC
43150: ST_TO_ADDR
43151: LD_EXP 99
43155: PUSH
43156: FOR_TO
43157: IFFALSE 44870
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
43159: LD_EXP 99
43163: PUSH
43164: LD_VAR 0 2
43168: ARRAY
43169: NOT
43170: PUSH
43171: LD_EXP 106
43175: PUSH
43176: LD_VAR 0 2
43180: ARRAY
43181: OR
43182: IFFALSE 43186
// continue ;
43184: GO 43156
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
43186: LD_EXP 115
43190: PUSH
43191: LD_VAR 0 2
43195: ARRAY
43196: NOT
43197: PUSH
43198: LD_EXP 116
43202: PUSH
43203: LD_VAR 0 2
43207: ARRAY
43208: AND
43209: IFFALSE 43247
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
43211: LD_ADDR_EXP 116
43215: PUSH
43216: LD_EXP 116
43220: PPUSH
43221: LD_VAR 0 2
43225: PPUSH
43226: EMPTY
43227: PPUSH
43228: CALL_OW 1
43232: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
43233: LD_VAR 0 2
43237: PPUSH
43238: LD_INT 107
43240: PPUSH
43241: CALL 34659 0 2
// continue ;
43245: GO 43156
// end ; target := [ ] ;
43247: LD_ADDR_VAR 0 6
43251: PUSH
43252: EMPTY
43253: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
43254: LD_ADDR_VAR 0 3
43258: PUSH
43259: DOUBLE
43260: LD_EXP 115
43264: PUSH
43265: LD_VAR 0 2
43269: ARRAY
43270: INC
43271: ST_TO_ADDR
43272: LD_INT 1
43274: PUSH
43275: FOR_DOWNTO
43276: IFFALSE 43536
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
43278: LD_EXP 115
43282: PUSH
43283: LD_VAR 0 2
43287: ARRAY
43288: PUSH
43289: LD_VAR 0 3
43293: ARRAY
43294: PUSH
43295: LD_INT 2
43297: ARRAY
43298: PPUSH
43299: LD_EXP 115
43303: PUSH
43304: LD_VAR 0 2
43308: ARRAY
43309: PUSH
43310: LD_VAR 0 3
43314: ARRAY
43315: PUSH
43316: LD_INT 3
43318: ARRAY
43319: PPUSH
43320: CALL_OW 488
43324: PUSH
43325: LD_EXP 115
43329: PUSH
43330: LD_VAR 0 2
43334: ARRAY
43335: PUSH
43336: LD_VAR 0 3
43340: ARRAY
43341: PUSH
43342: LD_INT 2
43344: ARRAY
43345: PPUSH
43346: LD_EXP 115
43350: PUSH
43351: LD_VAR 0 2
43355: ARRAY
43356: PUSH
43357: LD_VAR 0 3
43361: ARRAY
43362: PUSH
43363: LD_INT 3
43365: ARRAY
43366: PPUSH
43367: CALL_OW 284
43371: PUSH
43372: LD_INT 0
43374: EQUAL
43375: AND
43376: IFFALSE 43431
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
43378: LD_ADDR_VAR 0 5
43382: PUSH
43383: LD_EXP 115
43387: PUSH
43388: LD_VAR 0 2
43392: ARRAY
43393: PPUSH
43394: LD_VAR 0 3
43398: PPUSH
43399: CALL_OW 3
43403: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
43404: LD_ADDR_EXP 115
43408: PUSH
43409: LD_EXP 115
43413: PPUSH
43414: LD_VAR 0 2
43418: PPUSH
43419: LD_VAR 0 5
43423: PPUSH
43424: CALL_OW 1
43428: ST_TO_ADDR
// continue ;
43429: GO 43275
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
43431: LD_EXP 99
43435: PUSH
43436: LD_VAR 0 2
43440: ARRAY
43441: PUSH
43442: LD_INT 1
43444: ARRAY
43445: PPUSH
43446: CALL_OW 255
43450: PPUSH
43451: LD_EXP 115
43455: PUSH
43456: LD_VAR 0 2
43460: ARRAY
43461: PUSH
43462: LD_VAR 0 3
43466: ARRAY
43467: PUSH
43468: LD_INT 2
43470: ARRAY
43471: PPUSH
43472: LD_EXP 115
43476: PUSH
43477: LD_VAR 0 2
43481: ARRAY
43482: PUSH
43483: LD_VAR 0 3
43487: ARRAY
43488: PUSH
43489: LD_INT 3
43491: ARRAY
43492: PPUSH
43493: LD_INT 30
43495: PPUSH
43496: CALL 67083 0 4
43500: PUSH
43501: LD_INT 4
43503: ARRAY
43504: PUSH
43505: LD_INT 0
43507: EQUAL
43508: IFFALSE 43534
// begin target := mc_crates [ i ] [ j ] ;
43510: LD_ADDR_VAR 0 6
43514: PUSH
43515: LD_EXP 115
43519: PUSH
43520: LD_VAR 0 2
43524: ARRAY
43525: PUSH
43526: LD_VAR 0 3
43530: ARRAY
43531: ST_TO_ADDR
// break ;
43532: GO 43536
// end ; end ;
43534: GO 43275
43536: POP
43537: POP
// if not target then
43538: LD_VAR 0 6
43542: NOT
43543: IFFALSE 43547
// continue ;
43545: GO 43156
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
43547: LD_ADDR_VAR 0 7
43551: PUSH
43552: LD_EXP 118
43556: PUSH
43557: LD_VAR 0 2
43561: ARRAY
43562: PPUSH
43563: LD_INT 2
43565: PUSH
43566: LD_INT 3
43568: PUSH
43569: LD_INT 58
43571: PUSH
43572: EMPTY
43573: LIST
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 61
43581: PUSH
43582: EMPTY
43583: LIST
43584: PUSH
43585: LD_INT 33
43587: PUSH
43588: LD_INT 5
43590: PUSH
43591: EMPTY
43592: LIST
43593: LIST
43594: PUSH
43595: LD_INT 33
43597: PUSH
43598: LD_INT 3
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: EMPTY
43606: LIST
43607: LIST
43608: LIST
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 2
43614: PUSH
43615: LD_INT 34
43617: PUSH
43618: LD_INT 32
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 34
43627: PUSH
43628: LD_INT 51
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 34
43637: PUSH
43638: LD_INT 12
43640: PUSH
43641: EMPTY
43642: LIST
43643: LIST
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: LIST
43649: LIST
43650: PUSH
43651: EMPTY
43652: LIST
43653: LIST
43654: PPUSH
43655: CALL_OW 72
43659: ST_TO_ADDR
// if not cargo then
43660: LD_VAR 0 7
43664: NOT
43665: IFFALSE 44308
// begin if mc_crates_collector [ i ] < 5 then
43667: LD_EXP 116
43671: PUSH
43672: LD_VAR 0 2
43676: ARRAY
43677: PUSH
43678: LD_INT 5
43680: LESS
43681: IFFALSE 44047
// begin if mc_ape [ i ] then
43683: LD_EXP 128
43687: PUSH
43688: LD_VAR 0 2
43692: ARRAY
43693: IFFALSE 43740
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
43695: LD_ADDR_VAR 0 5
43699: PUSH
43700: LD_EXP 128
43704: PUSH
43705: LD_VAR 0 2
43709: ARRAY
43710: PPUSH
43711: LD_INT 25
43713: PUSH
43714: LD_INT 16
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: LD_INT 24
43723: PUSH
43724: LD_INT 750
43726: PUSH
43727: EMPTY
43728: LIST
43729: LIST
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PPUSH
43735: CALL_OW 72
43739: ST_TO_ADDR
// if not tmp then
43740: LD_VAR 0 5
43744: NOT
43745: IFFALSE 43792
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
43747: LD_ADDR_VAR 0 5
43751: PUSH
43752: LD_EXP 99
43756: PUSH
43757: LD_VAR 0 2
43761: ARRAY
43762: PPUSH
43763: LD_INT 25
43765: PUSH
43766: LD_INT 2
43768: PUSH
43769: EMPTY
43770: LIST
43771: LIST
43772: PUSH
43773: LD_INT 24
43775: PUSH
43776: LD_INT 750
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PPUSH
43787: CALL_OW 72
43791: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
43792: LD_EXP 128
43796: PUSH
43797: LD_VAR 0 2
43801: ARRAY
43802: PUSH
43803: LD_EXP 99
43807: PUSH
43808: LD_VAR 0 2
43812: ARRAY
43813: PPUSH
43814: LD_INT 25
43816: PUSH
43817: LD_INT 2
43819: PUSH
43820: EMPTY
43821: LIST
43822: LIST
43823: PUSH
43824: LD_INT 24
43826: PUSH
43827: LD_INT 750
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PPUSH
43838: CALL_OW 72
43842: AND
43843: PUSH
43844: LD_VAR 0 5
43848: PUSH
43849: LD_INT 5
43851: LESS
43852: AND
43853: IFFALSE 43935
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
43855: LD_ADDR_VAR 0 3
43859: PUSH
43860: LD_EXP 99
43864: PUSH
43865: LD_VAR 0 2
43869: ARRAY
43870: PPUSH
43871: LD_INT 25
43873: PUSH
43874: LD_INT 2
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 24
43883: PUSH
43884: LD_INT 750
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PPUSH
43895: CALL_OW 72
43899: PUSH
43900: FOR_IN
43901: IFFALSE 43933
// begin tmp := tmp union j ;
43903: LD_ADDR_VAR 0 5
43907: PUSH
43908: LD_VAR 0 5
43912: PUSH
43913: LD_VAR 0 3
43917: UNION
43918: ST_TO_ADDR
// if tmp >= 5 then
43919: LD_VAR 0 5
43923: PUSH
43924: LD_INT 5
43926: GREATEREQUAL
43927: IFFALSE 43931
// break ;
43929: GO 43933
// end ;
43931: GO 43900
43933: POP
43934: POP
// end ; if not tmp then
43935: LD_VAR 0 5
43939: NOT
43940: IFFALSE 43944
// continue ;
43942: GO 43156
// for j in tmp do
43944: LD_ADDR_VAR 0 3
43948: PUSH
43949: LD_VAR 0 5
43953: PUSH
43954: FOR_IN
43955: IFFALSE 44045
// if not GetTag ( j ) then
43957: LD_VAR 0 3
43961: PPUSH
43962: CALL_OW 110
43966: NOT
43967: IFFALSE 44043
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
43969: LD_ADDR_EXP 116
43973: PUSH
43974: LD_EXP 116
43978: PPUSH
43979: LD_VAR 0 2
43983: PUSH
43984: LD_EXP 116
43988: PUSH
43989: LD_VAR 0 2
43993: ARRAY
43994: PUSH
43995: LD_INT 1
43997: PLUS
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PPUSH
44003: LD_VAR 0 3
44007: PPUSH
44008: CALL 66187 0 3
44012: ST_TO_ADDR
// SetTag ( j , 107 ) ;
44013: LD_VAR 0 3
44017: PPUSH
44018: LD_INT 107
44020: PPUSH
44021: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
44025: LD_EXP 116
44029: PUSH
44030: LD_VAR 0 2
44034: ARRAY
44035: PUSH
44036: LD_INT 5
44038: GREATEREQUAL
44039: IFFALSE 44043
// break ;
44041: GO 44045
// end ;
44043: GO 43954
44045: POP
44046: POP
// end ; if mc_crates_collector [ i ] and target then
44047: LD_EXP 116
44051: PUSH
44052: LD_VAR 0 2
44056: ARRAY
44057: PUSH
44058: LD_VAR 0 6
44062: AND
44063: IFFALSE 44306
// begin if mc_crates_collector [ i ] < target [ 1 ] then
44065: LD_EXP 116
44069: PUSH
44070: LD_VAR 0 2
44074: ARRAY
44075: PUSH
44076: LD_VAR 0 6
44080: PUSH
44081: LD_INT 1
44083: ARRAY
44084: LESS
44085: IFFALSE 44105
// tmp := mc_crates_collector [ i ] else
44087: LD_ADDR_VAR 0 5
44091: PUSH
44092: LD_EXP 116
44096: PUSH
44097: LD_VAR 0 2
44101: ARRAY
44102: ST_TO_ADDR
44103: GO 44119
// tmp := target [ 1 ] ;
44105: LD_ADDR_VAR 0 5
44109: PUSH
44110: LD_VAR 0 6
44114: PUSH
44115: LD_INT 1
44117: ARRAY
44118: ST_TO_ADDR
// k := 0 ;
44119: LD_ADDR_VAR 0 4
44123: PUSH
44124: LD_INT 0
44126: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
44127: LD_ADDR_VAR 0 3
44131: PUSH
44132: LD_EXP 116
44136: PUSH
44137: LD_VAR 0 2
44141: ARRAY
44142: PUSH
44143: FOR_IN
44144: IFFALSE 44304
// begin k := k + 1 ;
44146: LD_ADDR_VAR 0 4
44150: PUSH
44151: LD_VAR 0 4
44155: PUSH
44156: LD_INT 1
44158: PLUS
44159: ST_TO_ADDR
// if k > tmp then
44160: LD_VAR 0 4
44164: PUSH
44165: LD_VAR 0 5
44169: GREATER
44170: IFFALSE 44174
// break ;
44172: GO 44304
// if not GetClass ( j ) in [ 2 , 16 ] then
44174: LD_VAR 0 3
44178: PPUSH
44179: CALL_OW 257
44183: PUSH
44184: LD_INT 2
44186: PUSH
44187: LD_INT 16
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: IN
44194: NOT
44195: IFFALSE 44248
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
44197: LD_ADDR_EXP 116
44201: PUSH
44202: LD_EXP 116
44206: PPUSH
44207: LD_VAR 0 2
44211: PPUSH
44212: LD_EXP 116
44216: PUSH
44217: LD_VAR 0 2
44221: ARRAY
44222: PUSH
44223: LD_VAR 0 3
44227: DIFF
44228: PPUSH
44229: CALL_OW 1
44233: ST_TO_ADDR
// SetTag ( j , 0 ) ;
44234: LD_VAR 0 3
44238: PPUSH
44239: LD_INT 0
44241: PPUSH
44242: CALL_OW 109
// continue ;
44246: GO 44143
// end ; if IsInUnit ( j ) then
44248: LD_VAR 0 3
44252: PPUSH
44253: CALL_OW 310
44257: IFFALSE 44268
// ComExitBuilding ( j ) ;
44259: LD_VAR 0 3
44263: PPUSH
44264: CALL_OW 122
// wait ( 3 ) ;
44268: LD_INT 3
44270: PPUSH
44271: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
44275: LD_VAR 0 3
44279: PPUSH
44280: LD_VAR 0 6
44284: PUSH
44285: LD_INT 2
44287: ARRAY
44288: PPUSH
44289: LD_VAR 0 6
44293: PUSH
44294: LD_INT 3
44296: ARRAY
44297: PPUSH
44298: CALL_OW 117
// end ;
44302: GO 44143
44304: POP
44305: POP
// end ; end else
44306: GO 44868
// begin for j in cargo do
44308: LD_ADDR_VAR 0 3
44312: PUSH
44313: LD_VAR 0 7
44317: PUSH
44318: FOR_IN
44319: IFFALSE 44866
// begin if GetTag ( j ) <> 0 then
44321: LD_VAR 0 3
44325: PPUSH
44326: CALL_OW 110
44330: PUSH
44331: LD_INT 0
44333: NONEQUAL
44334: IFFALSE 44338
// continue ;
44336: GO 44318
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL_OW 256
44347: PUSH
44348: LD_INT 1000
44350: LESS
44351: PUSH
44352: LD_VAR 0 3
44356: PPUSH
44357: LD_EXP 123
44361: PUSH
44362: LD_VAR 0 2
44366: ARRAY
44367: PPUSH
44368: CALL_OW 308
44372: NOT
44373: AND
44374: IFFALSE 44396
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44376: LD_VAR 0 3
44380: PPUSH
44381: LD_EXP 123
44385: PUSH
44386: LD_VAR 0 2
44390: ARRAY
44391: PPUSH
44392: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
44396: LD_VAR 0 3
44400: PPUSH
44401: CALL_OW 256
44405: PUSH
44406: LD_INT 1000
44408: LESS
44409: PUSH
44410: LD_VAR 0 3
44414: PPUSH
44415: LD_EXP 123
44419: PUSH
44420: LD_VAR 0 2
44424: ARRAY
44425: PPUSH
44426: CALL_OW 308
44430: AND
44431: IFFALSE 44435
// continue ;
44433: GO 44318
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
44435: LD_VAR 0 3
44439: PPUSH
44440: CALL_OW 262
44444: PUSH
44445: LD_INT 2
44447: EQUAL
44448: PUSH
44449: LD_VAR 0 3
44453: PPUSH
44454: CALL_OW 261
44458: PUSH
44459: LD_INT 15
44461: LESS
44462: AND
44463: IFFALSE 44467
// continue ;
44465: GO 44318
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
44467: LD_VAR 0 3
44471: PPUSH
44472: CALL_OW 262
44476: PUSH
44477: LD_INT 1
44479: EQUAL
44480: PUSH
44481: LD_VAR 0 3
44485: PPUSH
44486: CALL_OW 261
44490: PUSH
44491: LD_INT 10
44493: LESS
44494: AND
44495: IFFALSE 44805
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44497: LD_ADDR_VAR 0 8
44501: PUSH
44502: LD_EXP 99
44506: PUSH
44507: LD_VAR 0 2
44511: ARRAY
44512: PPUSH
44513: LD_INT 2
44515: PUSH
44516: LD_INT 30
44518: PUSH
44519: LD_INT 0
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PUSH
44526: LD_INT 30
44528: PUSH
44529: LD_INT 1
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: LIST
44540: PPUSH
44541: CALL_OW 72
44545: ST_TO_ADDR
// if not depot then
44546: LD_VAR 0 8
44550: NOT
44551: IFFALSE 44555
// continue ;
44553: GO 44318
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
44555: LD_VAR 0 3
44559: PPUSH
44560: LD_VAR 0 8
44564: PPUSH
44565: LD_VAR 0 3
44569: PPUSH
44570: CALL_OW 74
44574: PPUSH
44575: CALL_OW 296
44579: PUSH
44580: LD_INT 6
44582: LESS
44583: IFFALSE 44599
// SetFuel ( j , 100 ) else
44585: LD_VAR 0 3
44589: PPUSH
44590: LD_INT 100
44592: PPUSH
44593: CALL_OW 240
44597: GO 44805
// if GetFuel ( j ) = 0 then
44599: LD_VAR 0 3
44603: PPUSH
44604: CALL_OW 261
44608: PUSH
44609: LD_INT 0
44611: EQUAL
44612: IFFALSE 44805
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
44614: LD_ADDR_EXP 118
44618: PUSH
44619: LD_EXP 118
44623: PPUSH
44624: LD_VAR 0 2
44628: PPUSH
44629: LD_EXP 118
44633: PUSH
44634: LD_VAR 0 2
44638: ARRAY
44639: PUSH
44640: LD_VAR 0 3
44644: DIFF
44645: PPUSH
44646: CALL_OW 1
44650: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
44651: LD_VAR 0 3
44655: PPUSH
44656: CALL_OW 263
44660: PUSH
44661: LD_INT 1
44663: EQUAL
44664: IFFALSE 44680
// ComExitVehicle ( IsInUnit ( j ) ) ;
44666: LD_VAR 0 3
44670: PPUSH
44671: CALL_OW 310
44675: PPUSH
44676: CALL_OW 121
// if GetControl ( j ) = control_remote then
44680: LD_VAR 0 3
44684: PPUSH
44685: CALL_OW 263
44689: PUSH
44690: LD_INT 2
44692: EQUAL
44693: IFFALSE 44704
// ComUnlink ( j ) ;
44695: LD_VAR 0 3
44699: PPUSH
44700: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
44704: LD_ADDR_VAR 0 9
44708: PUSH
44709: LD_VAR 0 2
44713: PPUSH
44714: LD_INT 3
44716: PPUSH
44717: CALL 53967 0 2
44721: ST_TO_ADDR
// if fac then
44722: LD_VAR 0 9
44726: IFFALSE 44803
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
44728: LD_ADDR_VAR 0 10
44732: PUSH
44733: LD_VAR 0 9
44737: PPUSH
44738: LD_VAR 0 3
44742: PPUSH
44743: CALL_OW 265
44747: PPUSH
44748: LD_VAR 0 3
44752: PPUSH
44753: CALL_OW 262
44757: PPUSH
44758: LD_VAR 0 3
44762: PPUSH
44763: CALL_OW 263
44767: PPUSH
44768: LD_VAR 0 3
44772: PPUSH
44773: CALL_OW 264
44777: PPUSH
44778: CALL 63787 0 5
44782: ST_TO_ADDR
// if components then
44783: LD_VAR 0 10
44787: IFFALSE 44803
// MC_InsertProduceList ( i , components ) ;
44789: LD_VAR 0 2
44793: PPUSH
44794: LD_VAR 0 10
44798: PPUSH
44799: CALL 53537 0 2
// end ; continue ;
44803: GO 44318
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
44805: LD_VAR 0 3
44809: PPUSH
44810: LD_INT 1
44812: PPUSH
44813: CALL_OW 289
44817: PUSH
44818: LD_INT 100
44820: LESS
44821: PUSH
44822: LD_VAR 0 3
44826: PPUSH
44827: CALL_OW 314
44831: NOT
44832: AND
44833: IFFALSE 44862
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
44835: LD_VAR 0 3
44839: PPUSH
44840: LD_VAR 0 6
44844: PUSH
44845: LD_INT 2
44847: ARRAY
44848: PPUSH
44849: LD_VAR 0 6
44853: PUSH
44854: LD_INT 3
44856: ARRAY
44857: PPUSH
44858: CALL_OW 117
// break ;
44862: GO 44866
// end ;
44864: GO 44318
44866: POP
44867: POP
// end ; end ;
44868: GO 43156
44870: POP
44871: POP
// end ;
44872: LD_VAR 0 1
44876: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
44877: LD_INT 0
44879: PPUSH
44880: PPUSH
44881: PPUSH
44882: PPUSH
// if not mc_bases then
44883: LD_EXP 99
44887: NOT
44888: IFFALSE 44892
// exit ;
44890: GO 45053
// for i = 1 to mc_bases do
44892: LD_ADDR_VAR 0 2
44896: PUSH
44897: DOUBLE
44898: LD_INT 1
44900: DEC
44901: ST_TO_ADDR
44902: LD_EXP 99
44906: PUSH
44907: FOR_TO
44908: IFFALSE 45051
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
44910: LD_ADDR_VAR 0 4
44914: PUSH
44915: LD_EXP 118
44919: PUSH
44920: LD_VAR 0 2
44924: ARRAY
44925: PUSH
44926: LD_EXP 121
44930: PUSH
44931: LD_VAR 0 2
44935: ARRAY
44936: UNION
44937: PPUSH
44938: LD_INT 33
44940: PUSH
44941: LD_INT 2
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PPUSH
44948: CALL_OW 72
44952: ST_TO_ADDR
// if tmp then
44953: LD_VAR 0 4
44957: IFFALSE 45049
// for j in tmp do
44959: LD_ADDR_VAR 0 3
44963: PUSH
44964: LD_VAR 0 4
44968: PUSH
44969: FOR_IN
44970: IFFALSE 45047
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
44972: LD_VAR 0 3
44976: PPUSH
44977: CALL_OW 312
44981: NOT
44982: PUSH
44983: LD_VAR 0 3
44987: PPUSH
44988: CALL_OW 256
44992: PUSH
44993: LD_INT 250
44995: GREATEREQUAL
44996: AND
44997: IFFALSE 45010
// Connect ( j ) else
44999: LD_VAR 0 3
45003: PPUSH
45004: CALL 69120 0 1
45008: GO 45045
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
45010: LD_VAR 0 3
45014: PPUSH
45015: CALL_OW 256
45019: PUSH
45020: LD_INT 250
45022: LESS
45023: PUSH
45024: LD_VAR 0 3
45028: PPUSH
45029: CALL_OW 312
45033: AND
45034: IFFALSE 45045
// ComUnlink ( j ) ;
45036: LD_VAR 0 3
45040: PPUSH
45041: CALL_OW 136
45045: GO 44969
45047: POP
45048: POP
// end ;
45049: GO 44907
45051: POP
45052: POP
// end ;
45053: LD_VAR 0 1
45057: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
45058: LD_INT 0
45060: PPUSH
45061: PPUSH
45062: PPUSH
45063: PPUSH
45064: PPUSH
// if not mc_bases then
45065: LD_EXP 99
45069: NOT
45070: IFFALSE 45074
// exit ;
45072: GO 45534
// for i = 1 to mc_bases do
45074: LD_ADDR_VAR 0 2
45078: PUSH
45079: DOUBLE
45080: LD_INT 1
45082: DEC
45083: ST_TO_ADDR
45084: LD_EXP 99
45088: PUSH
45089: FOR_TO
45090: IFFALSE 45532
// begin if not mc_produce [ i ] then
45092: LD_EXP 120
45096: PUSH
45097: LD_VAR 0 2
45101: ARRAY
45102: NOT
45103: IFFALSE 45107
// continue ;
45105: GO 45089
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45107: LD_ADDR_VAR 0 5
45111: PUSH
45112: LD_EXP 99
45116: PUSH
45117: LD_VAR 0 2
45121: ARRAY
45122: PPUSH
45123: LD_INT 30
45125: PUSH
45126: LD_INT 3
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PPUSH
45133: CALL_OW 72
45137: ST_TO_ADDR
// if not fac then
45138: LD_VAR 0 5
45142: NOT
45143: IFFALSE 45147
// continue ;
45145: GO 45089
// for j in fac do
45147: LD_ADDR_VAR 0 3
45151: PUSH
45152: LD_VAR 0 5
45156: PUSH
45157: FOR_IN
45158: IFFALSE 45528
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
45160: LD_VAR 0 3
45164: PPUSH
45165: CALL_OW 461
45169: PUSH
45170: LD_INT 2
45172: NONEQUAL
45173: PUSH
45174: LD_VAR 0 3
45178: PPUSH
45179: LD_INT 15
45181: PPUSH
45182: CALL 68780 0 2
45186: PUSH
45187: LD_INT 4
45189: ARRAY
45190: OR
45191: PUSH
45192: LD_VAR 0 3
45196: PPUSH
45197: CALL_OW 313
45201: PUSH
45202: LD_INT 0
45204: EQUAL
45205: OR
45206: IFFALSE 45210
// continue ;
45208: GO 45157
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
45210: LD_VAR 0 3
45214: PPUSH
45215: LD_EXP 120
45219: PUSH
45220: LD_VAR 0 2
45224: ARRAY
45225: PUSH
45226: LD_INT 1
45228: ARRAY
45229: PUSH
45230: LD_INT 1
45232: ARRAY
45233: PPUSH
45234: LD_EXP 120
45238: PUSH
45239: LD_VAR 0 2
45243: ARRAY
45244: PUSH
45245: LD_INT 1
45247: ARRAY
45248: PUSH
45249: LD_INT 2
45251: ARRAY
45252: PPUSH
45253: LD_EXP 120
45257: PUSH
45258: LD_VAR 0 2
45262: ARRAY
45263: PUSH
45264: LD_INT 1
45266: ARRAY
45267: PUSH
45268: LD_INT 3
45270: ARRAY
45271: PPUSH
45272: LD_EXP 120
45276: PUSH
45277: LD_VAR 0 2
45281: ARRAY
45282: PUSH
45283: LD_INT 1
45285: ARRAY
45286: PUSH
45287: LD_INT 4
45289: ARRAY
45290: PPUSH
45291: CALL_OW 448
45295: PUSH
45296: LD_VAR 0 3
45300: PPUSH
45301: LD_EXP 120
45305: PUSH
45306: LD_VAR 0 2
45310: ARRAY
45311: PUSH
45312: LD_INT 1
45314: ARRAY
45315: PUSH
45316: LD_INT 1
45318: ARRAY
45319: PUSH
45320: LD_EXP 120
45324: PUSH
45325: LD_VAR 0 2
45329: ARRAY
45330: PUSH
45331: LD_INT 1
45333: ARRAY
45334: PUSH
45335: LD_INT 2
45337: ARRAY
45338: PUSH
45339: LD_EXP 120
45343: PUSH
45344: LD_VAR 0 2
45348: ARRAY
45349: PUSH
45350: LD_INT 1
45352: ARRAY
45353: PUSH
45354: LD_INT 3
45356: ARRAY
45357: PUSH
45358: LD_EXP 120
45362: PUSH
45363: LD_VAR 0 2
45367: ARRAY
45368: PUSH
45369: LD_INT 1
45371: ARRAY
45372: PUSH
45373: LD_INT 4
45375: ARRAY
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: LIST
45381: LIST
45382: PPUSH
45383: CALL 72451 0 2
45387: AND
45388: IFFALSE 45526
// begin ComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
45390: LD_VAR 0 3
45394: PPUSH
45395: LD_EXP 120
45399: PUSH
45400: LD_VAR 0 2
45404: ARRAY
45405: PUSH
45406: LD_INT 1
45408: ARRAY
45409: PUSH
45410: LD_INT 1
45412: ARRAY
45413: PPUSH
45414: LD_EXP 120
45418: PUSH
45419: LD_VAR 0 2
45423: ARRAY
45424: PUSH
45425: LD_INT 1
45427: ARRAY
45428: PUSH
45429: LD_INT 2
45431: ARRAY
45432: PPUSH
45433: LD_EXP 120
45437: PUSH
45438: LD_VAR 0 2
45442: ARRAY
45443: PUSH
45444: LD_INT 1
45446: ARRAY
45447: PUSH
45448: LD_INT 3
45450: ARRAY
45451: PPUSH
45452: LD_EXP 120
45456: PUSH
45457: LD_VAR 0 2
45461: ARRAY
45462: PUSH
45463: LD_INT 1
45465: ARRAY
45466: PUSH
45467: LD_INT 4
45469: ARRAY
45470: PPUSH
45471: CALL_OW 125
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
45475: LD_ADDR_VAR 0 4
45479: PUSH
45480: LD_EXP 120
45484: PUSH
45485: LD_VAR 0 2
45489: ARRAY
45490: PPUSH
45491: LD_INT 1
45493: PPUSH
45494: CALL_OW 3
45498: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45499: LD_ADDR_EXP 120
45503: PUSH
45504: LD_EXP 120
45508: PPUSH
45509: LD_VAR 0 2
45513: PPUSH
45514: LD_VAR 0 4
45518: PPUSH
45519: CALL_OW 1
45523: ST_TO_ADDR
// break ;
45524: GO 45528
// end ; end ;
45526: GO 45157
45528: POP
45529: POP
// end ;
45530: GO 45089
45532: POP
45533: POP
// end ;
45534: LD_VAR 0 1
45538: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
45539: LD_INT 0
45541: PPUSH
45542: PPUSH
45543: PPUSH
// if not mc_bases then
45544: LD_EXP 99
45548: NOT
45549: IFFALSE 45553
// exit ;
45551: GO 45642
// for i = 1 to mc_bases do
45553: LD_ADDR_VAR 0 2
45557: PUSH
45558: DOUBLE
45559: LD_INT 1
45561: DEC
45562: ST_TO_ADDR
45563: LD_EXP 99
45567: PUSH
45568: FOR_TO
45569: IFFALSE 45640
// begin if mc_attack [ i ] then
45571: LD_EXP 119
45575: PUSH
45576: LD_VAR 0 2
45580: ARRAY
45581: IFFALSE 45638
// begin tmp := mc_attack [ i ] [ 1 ] ;
45583: LD_ADDR_VAR 0 3
45587: PUSH
45588: LD_EXP 119
45592: PUSH
45593: LD_VAR 0 2
45597: ARRAY
45598: PUSH
45599: LD_INT 1
45601: ARRAY
45602: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
45603: LD_ADDR_EXP 119
45607: PUSH
45608: LD_EXP 119
45612: PPUSH
45613: LD_VAR 0 2
45617: PPUSH
45618: EMPTY
45619: PPUSH
45620: CALL_OW 1
45624: ST_TO_ADDR
// Attack ( tmp ) ;
45625: LD_VAR 0 3
45629: PPUSH
45630: CALL 94640 0 1
// exit ;
45634: POP
45635: POP
45636: GO 45642
// end ; end ;
45638: GO 45568
45640: POP
45641: POP
// end ;
45642: LD_VAR 0 1
45646: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
45647: LD_INT 0
45649: PPUSH
45650: PPUSH
45651: PPUSH
45652: PPUSH
45653: PPUSH
45654: PPUSH
45655: PPUSH
// if not mc_bases then
45656: LD_EXP 99
45660: NOT
45661: IFFALSE 45665
// exit ;
45663: GO 46269
// for i = 1 to mc_bases do
45665: LD_ADDR_VAR 0 2
45669: PUSH
45670: DOUBLE
45671: LD_INT 1
45673: DEC
45674: ST_TO_ADDR
45675: LD_EXP 99
45679: PUSH
45680: FOR_TO
45681: IFFALSE 46267
// begin if not mc_bases [ i ] then
45683: LD_EXP 99
45687: PUSH
45688: LD_VAR 0 2
45692: ARRAY
45693: NOT
45694: IFFALSE 45698
// continue ;
45696: GO 45680
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
45698: LD_ADDR_VAR 0 7
45702: PUSH
45703: LD_EXP 99
45707: PUSH
45708: LD_VAR 0 2
45712: ARRAY
45713: PUSH
45714: LD_INT 1
45716: ARRAY
45717: PPUSH
45718: CALL 63091 0 1
45722: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
45723: LD_ADDR_EXP 122
45727: PUSH
45728: LD_EXP 122
45732: PPUSH
45733: LD_VAR 0 2
45737: PPUSH
45738: LD_EXP 99
45742: PUSH
45743: LD_VAR 0 2
45747: ARRAY
45748: PUSH
45749: LD_INT 1
45751: ARRAY
45752: PPUSH
45753: CALL_OW 255
45757: PPUSH
45758: LD_EXP 124
45762: PUSH
45763: LD_VAR 0 2
45767: ARRAY
45768: PPUSH
45769: CALL 61051 0 2
45773: PPUSH
45774: CALL_OW 1
45778: ST_TO_ADDR
// if not mc_scan [ i ] then
45779: LD_EXP 122
45783: PUSH
45784: LD_VAR 0 2
45788: ARRAY
45789: NOT
45790: IFFALSE 45945
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
45792: LD_ADDR_VAR 0 4
45796: PUSH
45797: LD_EXP 99
45801: PUSH
45802: LD_VAR 0 2
45806: ARRAY
45807: PPUSH
45808: LD_INT 2
45810: PUSH
45811: LD_INT 25
45813: PUSH
45814: LD_INT 5
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 25
45823: PUSH
45824: LD_INT 8
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 25
45833: PUSH
45834: LD_INT 9
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: PPUSH
45847: CALL_OW 72
45851: ST_TO_ADDR
// if not tmp then
45852: LD_VAR 0 4
45856: NOT
45857: IFFALSE 45861
// continue ;
45859: GO 45680
// for j in tmp do
45861: LD_ADDR_VAR 0 3
45865: PUSH
45866: LD_VAR 0 4
45870: PUSH
45871: FOR_IN
45872: IFFALSE 45943
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
45874: LD_VAR 0 3
45878: PPUSH
45879: CALL_OW 310
45883: PPUSH
45884: CALL_OW 266
45888: PUSH
45889: LD_INT 5
45891: EQUAL
45892: PUSH
45893: LD_VAR 0 3
45897: PPUSH
45898: CALL_OW 257
45902: PUSH
45903: LD_INT 1
45905: EQUAL
45906: AND
45907: PUSH
45908: LD_VAR 0 3
45912: PPUSH
45913: CALL_OW 459
45917: NOT
45918: AND
45919: PUSH
45920: LD_VAR 0 7
45924: AND
45925: IFFALSE 45941
// ComChangeProfession ( j , class ) ;
45927: LD_VAR 0 3
45931: PPUSH
45932: LD_VAR 0 7
45936: PPUSH
45937: CALL_OW 123
45941: GO 45871
45943: POP
45944: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
45945: LD_EXP 122
45949: PUSH
45950: LD_VAR 0 2
45954: ARRAY
45955: PUSH
45956: LD_EXP 121
45960: PUSH
45961: LD_VAR 0 2
45965: ARRAY
45966: NOT
45967: AND
45968: PUSH
45969: LD_EXP 99
45973: PUSH
45974: LD_VAR 0 2
45978: ARRAY
45979: PPUSH
45980: LD_INT 30
45982: PUSH
45983: LD_INT 32
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PPUSH
45990: CALL_OW 72
45994: NOT
45995: AND
45996: PUSH
45997: LD_EXP 99
46001: PUSH
46002: LD_VAR 0 2
46006: ARRAY
46007: PPUSH
46008: LD_INT 2
46010: PUSH
46011: LD_INT 30
46013: PUSH
46014: LD_INT 4
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: LD_INT 30
46023: PUSH
46024: LD_INT 5
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: EMPTY
46032: LIST
46033: LIST
46034: LIST
46035: PPUSH
46036: CALL_OW 72
46040: NOT
46041: AND
46042: IFFALSE 46174
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
46044: LD_ADDR_VAR 0 4
46048: PUSH
46049: LD_EXP 99
46053: PUSH
46054: LD_VAR 0 2
46058: ARRAY
46059: PPUSH
46060: LD_INT 2
46062: PUSH
46063: LD_INT 25
46065: PUSH
46066: LD_INT 1
46068: PUSH
46069: EMPTY
46070: LIST
46071: LIST
46072: PUSH
46073: LD_INT 25
46075: PUSH
46076: LD_INT 5
46078: PUSH
46079: EMPTY
46080: LIST
46081: LIST
46082: PUSH
46083: LD_INT 25
46085: PUSH
46086: LD_INT 8
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 25
46095: PUSH
46096: LD_INT 9
46098: PUSH
46099: EMPTY
46100: LIST
46101: LIST
46102: PUSH
46103: EMPTY
46104: LIST
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: PPUSH
46110: CALL_OW 72
46114: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
46115: LD_ADDR_VAR 0 4
46119: PUSH
46120: LD_VAR 0 4
46124: PUSH
46125: LD_VAR 0 4
46129: PPUSH
46130: LD_INT 18
46132: PPUSH
46133: CALL 99384 0 2
46137: DIFF
46138: ST_TO_ADDR
// if tmp then
46139: LD_VAR 0 4
46143: IFFALSE 46174
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
46145: LD_VAR 0 2
46149: PPUSH
46150: LD_VAR 0 4
46154: PPUSH
46155: LD_EXP 124
46159: PUSH
46160: LD_VAR 0 2
46164: ARRAY
46165: PPUSH
46166: CALL 61086 0 3
// exit ;
46170: POP
46171: POP
46172: GO 46269
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
46174: LD_EXP 122
46178: PUSH
46179: LD_VAR 0 2
46183: ARRAY
46184: PUSH
46185: LD_EXP 121
46189: PUSH
46190: LD_VAR 0 2
46194: ARRAY
46195: AND
46196: IFFALSE 46265
// begin tmp := mc_defender [ i ] ;
46198: LD_ADDR_VAR 0 4
46202: PUSH
46203: LD_EXP 121
46207: PUSH
46208: LD_VAR 0 2
46212: ARRAY
46213: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
46214: LD_ADDR_EXP 121
46218: PUSH
46219: LD_EXP 121
46223: PPUSH
46224: LD_VAR 0 2
46228: PPUSH
46229: EMPTY
46230: PPUSH
46231: CALL_OW 1
46235: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
46236: LD_VAR 0 2
46240: PPUSH
46241: LD_VAR 0 4
46245: PPUSH
46246: LD_EXP 122
46250: PUSH
46251: LD_VAR 0 2
46255: ARRAY
46256: PPUSH
46257: CALL 61584 0 3
// exit ;
46261: POP
46262: POP
46263: GO 46269
// end ; end ;
46265: GO 45680
46267: POP
46268: POP
// end ;
46269: LD_VAR 0 1
46273: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
46274: LD_INT 0
46276: PPUSH
46277: PPUSH
46278: PPUSH
46279: PPUSH
46280: PPUSH
46281: PPUSH
46282: PPUSH
46283: PPUSH
46284: PPUSH
46285: PPUSH
46286: PPUSH
// if not mc_bases then
46287: LD_EXP 99
46291: NOT
46292: IFFALSE 46296
// exit ;
46294: GO 47383
// for i = 1 to mc_bases do
46296: LD_ADDR_VAR 0 2
46300: PUSH
46301: DOUBLE
46302: LD_INT 1
46304: DEC
46305: ST_TO_ADDR
46306: LD_EXP 99
46310: PUSH
46311: FOR_TO
46312: IFFALSE 47381
// begin tmp := mc_lab [ i ] ;
46314: LD_ADDR_VAR 0 6
46318: PUSH
46319: LD_EXP 132
46323: PUSH
46324: LD_VAR 0 2
46328: ARRAY
46329: ST_TO_ADDR
// if not tmp then
46330: LD_VAR 0 6
46334: NOT
46335: IFFALSE 46339
// continue ;
46337: GO 46311
// idle_lab := 0 ;
46339: LD_ADDR_VAR 0 11
46343: PUSH
46344: LD_INT 0
46346: ST_TO_ADDR
// for j in tmp do
46347: LD_ADDR_VAR 0 3
46351: PUSH
46352: LD_VAR 0 6
46356: PUSH
46357: FOR_IN
46358: IFFALSE 47377
// begin researching := false ;
46360: LD_ADDR_VAR 0 10
46364: PUSH
46365: LD_INT 0
46367: ST_TO_ADDR
// side := GetSide ( j ) ;
46368: LD_ADDR_VAR 0 4
46372: PUSH
46373: LD_VAR 0 3
46377: PPUSH
46378: CALL_OW 255
46382: ST_TO_ADDR
// if not mc_tech [ side ] then
46383: LD_EXP 126
46387: PUSH
46388: LD_VAR 0 4
46392: ARRAY
46393: NOT
46394: IFFALSE 46398
// continue ;
46396: GO 46357
// if BuildingStatus ( j ) = bs_idle then
46398: LD_VAR 0 3
46402: PPUSH
46403: CALL_OW 461
46407: PUSH
46408: LD_INT 2
46410: EQUAL
46411: IFFALSE 46599
// begin if idle_lab and UnitsInside ( j ) < 6 then
46413: LD_VAR 0 11
46417: PUSH
46418: LD_VAR 0 3
46422: PPUSH
46423: CALL_OW 313
46427: PUSH
46428: LD_INT 6
46430: LESS
46431: AND
46432: IFFALSE 46503
// begin tmp2 := UnitsInside ( idle_lab ) ;
46434: LD_ADDR_VAR 0 9
46438: PUSH
46439: LD_VAR 0 11
46443: PPUSH
46444: CALL_OW 313
46448: ST_TO_ADDR
// if tmp2 then
46449: LD_VAR 0 9
46453: IFFALSE 46495
// for x in tmp2 do
46455: LD_ADDR_VAR 0 7
46459: PUSH
46460: LD_VAR 0 9
46464: PUSH
46465: FOR_IN
46466: IFFALSE 46493
// begin ComExitBuilding ( x ) ;
46468: LD_VAR 0 7
46472: PPUSH
46473: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
46477: LD_VAR 0 7
46481: PPUSH
46482: LD_VAR 0 3
46486: PPUSH
46487: CALL_OW 180
// end ;
46491: GO 46465
46493: POP
46494: POP
// idle_lab := 0 ;
46495: LD_ADDR_VAR 0 11
46499: PUSH
46500: LD_INT 0
46502: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
46503: LD_ADDR_VAR 0 5
46507: PUSH
46508: LD_EXP 126
46512: PUSH
46513: LD_VAR 0 4
46517: ARRAY
46518: PUSH
46519: FOR_IN
46520: IFFALSE 46580
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
46522: LD_VAR 0 3
46526: PPUSH
46527: LD_VAR 0 5
46531: PPUSH
46532: CALL_OW 430
46536: PUSH
46537: LD_VAR 0 4
46541: PPUSH
46542: LD_VAR 0 5
46546: PPUSH
46547: CALL 60156 0 2
46551: AND
46552: IFFALSE 46578
// begin researching := true ;
46554: LD_ADDR_VAR 0 10
46558: PUSH
46559: LD_INT 1
46561: ST_TO_ADDR
// ComResearch ( j , t ) ;
46562: LD_VAR 0 3
46566: PPUSH
46567: LD_VAR 0 5
46571: PPUSH
46572: CALL_OW 124
// break ;
46576: GO 46580
// end ;
46578: GO 46519
46580: POP
46581: POP
// if not researching then
46582: LD_VAR 0 10
46586: NOT
46587: IFFALSE 46599
// idle_lab := j ;
46589: LD_ADDR_VAR 0 11
46593: PUSH
46594: LD_VAR 0 3
46598: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
46599: LD_VAR 0 3
46603: PPUSH
46604: CALL_OW 461
46608: PUSH
46609: LD_INT 10
46611: EQUAL
46612: IFFALSE 47200
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
46614: LD_EXP 128
46618: PUSH
46619: LD_VAR 0 2
46623: ARRAY
46624: NOT
46625: PUSH
46626: LD_EXP 129
46630: PUSH
46631: LD_VAR 0 2
46635: ARRAY
46636: NOT
46637: AND
46638: PUSH
46639: LD_EXP 126
46643: PUSH
46644: LD_VAR 0 4
46648: ARRAY
46649: PUSH
46650: LD_INT 1
46652: GREATER
46653: AND
46654: IFFALSE 46785
// begin ComCancel ( j ) ;
46656: LD_VAR 0 3
46660: PPUSH
46661: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
46665: LD_ADDR_EXP 126
46669: PUSH
46670: LD_EXP 126
46674: PPUSH
46675: LD_VAR 0 4
46679: PPUSH
46680: LD_EXP 126
46684: PUSH
46685: LD_VAR 0 4
46689: ARRAY
46690: PPUSH
46691: LD_EXP 126
46695: PUSH
46696: LD_VAR 0 4
46700: ARRAY
46701: PUSH
46702: LD_INT 1
46704: MINUS
46705: PPUSH
46706: LD_EXP 126
46710: PUSH
46711: LD_VAR 0 4
46715: ARRAY
46716: PPUSH
46717: LD_INT 0
46719: PPUSH
46720: CALL 65605 0 4
46724: PPUSH
46725: CALL_OW 1
46729: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
46730: LD_ADDR_EXP 126
46734: PUSH
46735: LD_EXP 126
46739: PPUSH
46740: LD_VAR 0 4
46744: PPUSH
46745: LD_EXP 126
46749: PUSH
46750: LD_VAR 0 4
46754: ARRAY
46755: PPUSH
46756: LD_EXP 126
46760: PUSH
46761: LD_VAR 0 4
46765: ARRAY
46766: PPUSH
46767: LD_INT 1
46769: PPUSH
46770: LD_INT 0
46772: PPUSH
46773: CALL 65605 0 4
46777: PPUSH
46778: CALL_OW 1
46782: ST_TO_ADDR
// continue ;
46783: GO 46357
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
46785: LD_EXP 128
46789: PUSH
46790: LD_VAR 0 2
46794: ARRAY
46795: PUSH
46796: LD_EXP 129
46800: PUSH
46801: LD_VAR 0 2
46805: ARRAY
46806: NOT
46807: AND
46808: IFFALSE 46935
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
46810: LD_ADDR_EXP 129
46814: PUSH
46815: LD_EXP 129
46819: PPUSH
46820: LD_VAR 0 2
46824: PUSH
46825: LD_EXP 129
46829: PUSH
46830: LD_VAR 0 2
46834: ARRAY
46835: PUSH
46836: LD_INT 1
46838: PLUS
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: PPUSH
46844: LD_EXP 128
46848: PUSH
46849: LD_VAR 0 2
46853: ARRAY
46854: PUSH
46855: LD_INT 1
46857: ARRAY
46858: PPUSH
46859: CALL 66187 0 3
46863: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
46864: LD_EXP 128
46868: PUSH
46869: LD_VAR 0 2
46873: ARRAY
46874: PUSH
46875: LD_INT 1
46877: ARRAY
46878: PPUSH
46879: LD_INT 112
46881: PPUSH
46882: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
46886: LD_ADDR_VAR 0 9
46890: PUSH
46891: LD_EXP 128
46895: PUSH
46896: LD_VAR 0 2
46900: ARRAY
46901: PPUSH
46902: LD_INT 1
46904: PPUSH
46905: CALL_OW 3
46909: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
46910: LD_ADDR_EXP 128
46914: PUSH
46915: LD_EXP 128
46919: PPUSH
46920: LD_VAR 0 2
46924: PPUSH
46925: LD_VAR 0 9
46929: PPUSH
46930: CALL_OW 1
46934: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
46935: LD_EXP 128
46939: PUSH
46940: LD_VAR 0 2
46944: ARRAY
46945: PUSH
46946: LD_EXP 129
46950: PUSH
46951: LD_VAR 0 2
46955: ARRAY
46956: AND
46957: PUSH
46958: LD_EXP 129
46962: PUSH
46963: LD_VAR 0 2
46967: ARRAY
46968: PUSH
46969: LD_INT 1
46971: ARRAY
46972: PPUSH
46973: CALL_OW 310
46977: NOT
46978: AND
46979: PUSH
46980: LD_VAR 0 3
46984: PPUSH
46985: CALL_OW 313
46989: PUSH
46990: LD_INT 6
46992: EQUAL
46993: AND
46994: IFFALSE 47050
// begin tmp2 := UnitsInside ( j ) ;
46996: LD_ADDR_VAR 0 9
47000: PUSH
47001: LD_VAR 0 3
47005: PPUSH
47006: CALL_OW 313
47010: ST_TO_ADDR
// if tmp2 = 6 then
47011: LD_VAR 0 9
47015: PUSH
47016: LD_INT 6
47018: EQUAL
47019: IFFALSE 47050
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
47021: LD_VAR 0 9
47025: PUSH
47026: LD_INT 1
47028: ARRAY
47029: PPUSH
47030: LD_INT 112
47032: PPUSH
47033: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
47037: LD_VAR 0 9
47041: PUSH
47042: LD_INT 1
47044: ARRAY
47045: PPUSH
47046: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
47050: LD_EXP 129
47054: PUSH
47055: LD_VAR 0 2
47059: ARRAY
47060: PUSH
47061: LD_EXP 129
47065: PUSH
47066: LD_VAR 0 2
47070: ARRAY
47071: PUSH
47072: LD_INT 1
47074: ARRAY
47075: PPUSH
47076: CALL_OW 314
47080: NOT
47081: AND
47082: PUSH
47083: LD_EXP 129
47087: PUSH
47088: LD_VAR 0 2
47092: ARRAY
47093: PUSH
47094: LD_INT 1
47096: ARRAY
47097: PPUSH
47098: CALL_OW 310
47102: NOT
47103: AND
47104: IFFALSE 47130
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
47106: LD_EXP 129
47110: PUSH
47111: LD_VAR 0 2
47115: ARRAY
47116: PUSH
47117: LD_INT 1
47119: ARRAY
47120: PPUSH
47121: LD_VAR 0 3
47125: PPUSH
47126: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
47130: LD_EXP 129
47134: PUSH
47135: LD_VAR 0 2
47139: ARRAY
47140: PUSH
47141: LD_INT 1
47143: ARRAY
47144: PPUSH
47145: CALL_OW 310
47149: PUSH
47150: LD_EXP 129
47154: PUSH
47155: LD_VAR 0 2
47159: ARRAY
47160: PUSH
47161: LD_INT 1
47163: ARRAY
47164: PPUSH
47165: CALL_OW 310
47169: PPUSH
47170: CALL_OW 461
47174: PUSH
47175: LD_INT 3
47177: NONEQUAL
47178: AND
47179: IFFALSE 47200
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
47181: LD_EXP 129
47185: PUSH
47186: LD_VAR 0 2
47190: ARRAY
47191: PUSH
47192: LD_INT 1
47194: ARRAY
47195: PPUSH
47196: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
47200: LD_VAR 0 3
47204: PPUSH
47205: CALL_OW 461
47209: PUSH
47210: LD_INT 6
47212: EQUAL
47213: PUSH
47214: LD_VAR 0 6
47218: PUSH
47219: LD_INT 1
47221: GREATER
47222: AND
47223: IFFALSE 47375
// begin sci := [ ] ;
47225: LD_ADDR_VAR 0 8
47229: PUSH
47230: EMPTY
47231: ST_TO_ADDR
// for x in ( tmp diff j ) do
47232: LD_ADDR_VAR 0 7
47236: PUSH
47237: LD_VAR 0 6
47241: PUSH
47242: LD_VAR 0 3
47246: DIFF
47247: PUSH
47248: FOR_IN
47249: IFFALSE 47301
// begin if sci = 6 then
47251: LD_VAR 0 8
47255: PUSH
47256: LD_INT 6
47258: EQUAL
47259: IFFALSE 47263
// break ;
47261: GO 47301
// if BuildingStatus ( x ) = bs_idle then
47263: LD_VAR 0 7
47267: PPUSH
47268: CALL_OW 461
47272: PUSH
47273: LD_INT 2
47275: EQUAL
47276: IFFALSE 47299
// sci := sci ^ UnitsInside ( x ) ;
47278: LD_ADDR_VAR 0 8
47282: PUSH
47283: LD_VAR 0 8
47287: PUSH
47288: LD_VAR 0 7
47292: PPUSH
47293: CALL_OW 313
47297: ADD
47298: ST_TO_ADDR
// end ;
47299: GO 47248
47301: POP
47302: POP
// if not sci then
47303: LD_VAR 0 8
47307: NOT
47308: IFFALSE 47312
// continue ;
47310: GO 46357
// for x in sci do
47312: LD_ADDR_VAR 0 7
47316: PUSH
47317: LD_VAR 0 8
47321: PUSH
47322: FOR_IN
47323: IFFALSE 47373
// if IsInUnit ( x ) and not HasTask ( x ) then
47325: LD_VAR 0 7
47329: PPUSH
47330: CALL_OW 310
47334: PUSH
47335: LD_VAR 0 7
47339: PPUSH
47340: CALL_OW 314
47344: NOT
47345: AND
47346: IFFALSE 47371
// begin ComExitBuilding ( x ) ;
47348: LD_VAR 0 7
47352: PPUSH
47353: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
47357: LD_VAR 0 7
47361: PPUSH
47362: LD_VAR 0 3
47366: PPUSH
47367: CALL_OW 180
// end ;
47371: GO 47322
47373: POP
47374: POP
// end ; end ;
47375: GO 46357
47377: POP
47378: POP
// end ;
47379: GO 46311
47381: POP
47382: POP
// end ;
47383: LD_VAR 0 1
47387: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
47388: LD_INT 0
47390: PPUSH
47391: PPUSH
// if not mc_bases then
47392: LD_EXP 99
47396: NOT
47397: IFFALSE 47401
// exit ;
47399: GO 47482
// for i = 1 to mc_bases do
47401: LD_ADDR_VAR 0 2
47405: PUSH
47406: DOUBLE
47407: LD_INT 1
47409: DEC
47410: ST_TO_ADDR
47411: LD_EXP 99
47415: PUSH
47416: FOR_TO
47417: IFFALSE 47480
// if mc_mines [ i ] and mc_miners [ i ] then
47419: LD_EXP 112
47423: PUSH
47424: LD_VAR 0 2
47428: ARRAY
47429: PUSH
47430: LD_EXP 113
47434: PUSH
47435: LD_VAR 0 2
47439: ARRAY
47440: AND
47441: IFFALSE 47478
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
47443: LD_EXP 113
47447: PUSH
47448: LD_VAR 0 2
47452: ARRAY
47453: PUSH
47454: LD_INT 1
47456: ARRAY
47457: PPUSH
47458: CALL_OW 255
47462: PPUSH
47463: LD_EXP 112
47467: PUSH
47468: LD_VAR 0 2
47472: ARRAY
47473: PPUSH
47474: CALL 63244 0 2
47478: GO 47416
47480: POP
47481: POP
// end ;
47482: LD_VAR 0 1
47486: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
47487: LD_INT 0
47489: PPUSH
47490: PPUSH
47491: PPUSH
47492: PPUSH
47493: PPUSH
47494: PPUSH
47495: PPUSH
47496: PPUSH
// if not mc_bases or not mc_parking then
47497: LD_EXP 99
47501: NOT
47502: PUSH
47503: LD_EXP 123
47507: NOT
47508: OR
47509: IFFALSE 47513
// exit ;
47511: GO 48225
// for i = 1 to mc_bases do
47513: LD_ADDR_VAR 0 2
47517: PUSH
47518: DOUBLE
47519: LD_INT 1
47521: DEC
47522: ST_TO_ADDR
47523: LD_EXP 99
47527: PUSH
47528: FOR_TO
47529: IFFALSE 48223
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
47531: LD_EXP 99
47535: PUSH
47536: LD_VAR 0 2
47540: ARRAY
47541: NOT
47542: PUSH
47543: LD_EXP 123
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: NOT
47554: OR
47555: IFFALSE 47559
// continue ;
47557: GO 47528
// if mc_scan [ i ] then
47559: LD_EXP 122
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: IFFALSE 47595
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
47571: LD_ADDR_EXP 111
47575: PUSH
47576: LD_EXP 111
47580: PPUSH
47581: LD_VAR 0 2
47585: PPUSH
47586: EMPTY
47587: PPUSH
47588: CALL_OW 1
47592: ST_TO_ADDR
// continue ;
47593: GO 47528
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
47595: LD_ADDR_VAR 0 5
47599: PUSH
47600: LD_EXP 99
47604: PUSH
47605: LD_VAR 0 2
47609: ARRAY
47610: PUSH
47611: LD_INT 1
47613: ARRAY
47614: PPUSH
47615: CALL_OW 255
47619: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47620: LD_ADDR_VAR 0 6
47624: PUSH
47625: LD_EXP 99
47629: PUSH
47630: LD_VAR 0 2
47634: ARRAY
47635: PPUSH
47636: LD_INT 30
47638: PUSH
47639: LD_INT 3
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: PPUSH
47646: CALL_OW 72
47650: ST_TO_ADDR
// if not fac then
47651: LD_VAR 0 6
47655: NOT
47656: IFFALSE 47707
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47658: LD_ADDR_VAR 0 6
47662: PUSH
47663: LD_EXP 99
47667: PUSH
47668: LD_VAR 0 2
47672: ARRAY
47673: PPUSH
47674: LD_INT 2
47676: PUSH
47677: LD_INT 30
47679: PUSH
47680: LD_INT 0
47682: PUSH
47683: EMPTY
47684: LIST
47685: LIST
47686: PUSH
47687: LD_INT 30
47689: PUSH
47690: LD_INT 1
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: LIST
47701: PPUSH
47702: CALL_OW 72
47706: ST_TO_ADDR
// if not fac then
47707: LD_VAR 0 6
47711: NOT
47712: IFFALSE 47716
// continue ;
47714: GO 47528
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
47716: LD_ADDR_VAR 0 7
47720: PUSH
47721: LD_EXP 123
47725: PUSH
47726: LD_VAR 0 2
47730: ARRAY
47731: PPUSH
47732: LD_INT 22
47734: PUSH
47735: LD_VAR 0 5
47739: PUSH
47740: EMPTY
47741: LIST
47742: LIST
47743: PUSH
47744: LD_INT 21
47746: PUSH
47747: LD_INT 2
47749: PUSH
47750: EMPTY
47751: LIST
47752: LIST
47753: PUSH
47754: LD_INT 3
47756: PUSH
47757: LD_INT 24
47759: PUSH
47760: LD_INT 1000
47762: PUSH
47763: EMPTY
47764: LIST
47765: LIST
47766: PUSH
47767: EMPTY
47768: LIST
47769: LIST
47770: PUSH
47771: EMPTY
47772: LIST
47773: LIST
47774: LIST
47775: PPUSH
47776: CALL_OW 70
47780: PUSH
47781: LD_INT 22
47783: PUSH
47784: LD_VAR 0 5
47788: PUSH
47789: EMPTY
47790: LIST
47791: LIST
47792: PUSH
47793: LD_INT 91
47795: PUSH
47796: LD_VAR 0 6
47800: PUSH
47801: LD_INT 1
47803: ARRAY
47804: PUSH
47805: LD_INT 25
47807: PUSH
47808: EMPTY
47809: LIST
47810: LIST
47811: LIST
47812: PUSH
47813: LD_INT 21
47815: PUSH
47816: LD_INT 2
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 3
47825: PUSH
47826: LD_INT 24
47828: PUSH
47829: LD_INT 1000
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: LIST
47844: LIST
47845: PPUSH
47846: CALL_OW 69
47850: UNION
47851: ST_TO_ADDR
// if not vehs then
47852: LD_VAR 0 7
47856: NOT
47857: IFFALSE 47883
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
47859: LD_ADDR_EXP 111
47863: PUSH
47864: LD_EXP 111
47868: PPUSH
47869: LD_VAR 0 2
47873: PPUSH
47874: EMPTY
47875: PPUSH
47876: CALL_OW 1
47880: ST_TO_ADDR
// continue ;
47881: GO 47528
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47883: LD_ADDR_VAR 0 8
47887: PUSH
47888: LD_EXP 99
47892: PUSH
47893: LD_VAR 0 2
47897: ARRAY
47898: PPUSH
47899: LD_INT 30
47901: PUSH
47902: LD_INT 3
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PPUSH
47909: CALL_OW 72
47913: ST_TO_ADDR
// if tmp then
47914: LD_VAR 0 8
47918: IFFALSE 48021
// begin for j in tmp do
47920: LD_ADDR_VAR 0 3
47924: PUSH
47925: LD_VAR 0 8
47929: PUSH
47930: FOR_IN
47931: IFFALSE 48019
// for k in UnitsInside ( j ) do
47933: LD_ADDR_VAR 0 4
47937: PUSH
47938: LD_VAR 0 3
47942: PPUSH
47943: CALL_OW 313
47947: PUSH
47948: FOR_IN
47949: IFFALSE 48015
// if k then
47951: LD_VAR 0 4
47955: IFFALSE 48013
// if not k in mc_repair_vehicle [ i ] then
47957: LD_VAR 0 4
47961: PUSH
47962: LD_EXP 111
47966: PUSH
47967: LD_VAR 0 2
47971: ARRAY
47972: IN
47973: NOT
47974: IFFALSE 48013
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
47976: LD_ADDR_EXP 111
47980: PUSH
47981: LD_EXP 111
47985: PPUSH
47986: LD_VAR 0 2
47990: PPUSH
47991: LD_EXP 111
47995: PUSH
47996: LD_VAR 0 2
48000: ARRAY
48001: PUSH
48002: LD_VAR 0 4
48006: UNION
48007: PPUSH
48008: CALL_OW 1
48012: ST_TO_ADDR
48013: GO 47948
48015: POP
48016: POP
48017: GO 47930
48019: POP
48020: POP
// end ; if not mc_repair_vehicle [ i ] then
48021: LD_EXP 111
48025: PUSH
48026: LD_VAR 0 2
48030: ARRAY
48031: NOT
48032: IFFALSE 48036
// continue ;
48034: GO 47528
// for j in mc_repair_vehicle [ i ] do
48036: LD_ADDR_VAR 0 3
48040: PUSH
48041: LD_EXP 111
48045: PUSH
48046: LD_VAR 0 2
48050: ARRAY
48051: PUSH
48052: FOR_IN
48053: IFFALSE 48219
// begin if GetClass ( j ) <> 3 then
48055: LD_VAR 0 3
48059: PPUSH
48060: CALL_OW 257
48064: PUSH
48065: LD_INT 3
48067: NONEQUAL
48068: IFFALSE 48109
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
48070: LD_ADDR_EXP 111
48074: PUSH
48075: LD_EXP 111
48079: PPUSH
48080: LD_VAR 0 2
48084: PPUSH
48085: LD_EXP 111
48089: PUSH
48090: LD_VAR 0 2
48094: ARRAY
48095: PUSH
48096: LD_VAR 0 3
48100: DIFF
48101: PPUSH
48102: CALL_OW 1
48106: ST_TO_ADDR
// continue ;
48107: GO 48052
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
48109: LD_VAR 0 3
48113: PPUSH
48114: CALL_OW 311
48118: NOT
48119: PUSH
48120: LD_VAR 0 3
48124: PUSH
48125: LD_EXP 102
48129: PUSH
48130: LD_VAR 0 2
48134: ARRAY
48135: PUSH
48136: LD_INT 1
48138: ARRAY
48139: IN
48140: NOT
48141: AND
48142: PUSH
48143: LD_VAR 0 3
48147: PUSH
48148: LD_EXP 102
48152: PUSH
48153: LD_VAR 0 2
48157: ARRAY
48158: PUSH
48159: LD_INT 2
48161: ARRAY
48162: IN
48163: NOT
48164: AND
48165: IFFALSE 48217
// begin if IsInUnit ( j ) then
48167: LD_VAR 0 3
48171: PPUSH
48172: CALL_OW 310
48176: IFFALSE 48187
// ComExitBuilding ( j ) ;
48178: LD_VAR 0 3
48182: PPUSH
48183: CALL_OW 122
// if not HasTask ( j ) then
48187: LD_VAR 0 3
48191: PPUSH
48192: CALL_OW 314
48196: NOT
48197: IFFALSE 48217
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
48199: LD_VAR 0 3
48203: PPUSH
48204: LD_VAR 0 7
48208: PUSH
48209: LD_INT 1
48211: ARRAY
48212: PPUSH
48213: CALL_OW 189
// end ; end ;
48217: GO 48052
48219: POP
48220: POP
// end ;
48221: GO 47528
48223: POP
48224: POP
// end ;
48225: LD_VAR 0 1
48229: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
48230: LD_INT 0
48232: PPUSH
48233: PPUSH
48234: PPUSH
48235: PPUSH
48236: PPUSH
48237: PPUSH
48238: PPUSH
48239: PPUSH
48240: PPUSH
48241: PPUSH
48242: PPUSH
// if not mc_bases then
48243: LD_EXP 99
48247: NOT
48248: IFFALSE 48252
// exit ;
48250: GO 49054
// for i = 1 to mc_bases do
48252: LD_ADDR_VAR 0 2
48256: PUSH
48257: DOUBLE
48258: LD_INT 1
48260: DEC
48261: ST_TO_ADDR
48262: LD_EXP 99
48266: PUSH
48267: FOR_TO
48268: IFFALSE 49052
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
48270: LD_EXP 127
48274: PUSH
48275: LD_VAR 0 2
48279: ARRAY
48280: NOT
48281: PUSH
48282: LD_EXP 102
48286: PUSH
48287: LD_VAR 0 2
48291: ARRAY
48292: PUSH
48293: LD_INT 1
48295: ARRAY
48296: OR
48297: PUSH
48298: LD_EXP 102
48302: PUSH
48303: LD_VAR 0 2
48307: ARRAY
48308: PUSH
48309: LD_INT 2
48311: ARRAY
48312: OR
48313: PUSH
48314: LD_EXP 125
48318: PUSH
48319: LD_VAR 0 2
48323: ARRAY
48324: PPUSH
48325: LD_INT 1
48327: PPUSH
48328: CALL_OW 325
48332: NOT
48333: OR
48334: PUSH
48335: LD_EXP 122
48339: PUSH
48340: LD_VAR 0 2
48344: ARRAY
48345: OR
48346: IFFALSE 48350
// continue ;
48348: GO 48267
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
48350: LD_ADDR_VAR 0 8
48354: PUSH
48355: LD_EXP 99
48359: PUSH
48360: LD_VAR 0 2
48364: ARRAY
48365: PPUSH
48366: LD_INT 25
48368: PUSH
48369: LD_INT 4
48371: PUSH
48372: EMPTY
48373: LIST
48374: LIST
48375: PUSH
48376: LD_INT 50
48378: PUSH
48379: EMPTY
48380: LIST
48381: PUSH
48382: LD_INT 3
48384: PUSH
48385: LD_INT 60
48387: PUSH
48388: EMPTY
48389: LIST
48390: PUSH
48391: EMPTY
48392: LIST
48393: LIST
48394: PUSH
48395: EMPTY
48396: LIST
48397: LIST
48398: LIST
48399: PPUSH
48400: CALL_OW 72
48404: PUSH
48405: LD_EXP 103
48409: PUSH
48410: LD_VAR 0 2
48414: ARRAY
48415: DIFF
48416: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48417: LD_ADDR_VAR 0 9
48421: PUSH
48422: LD_EXP 99
48426: PUSH
48427: LD_VAR 0 2
48431: ARRAY
48432: PPUSH
48433: LD_INT 2
48435: PUSH
48436: LD_INT 30
48438: PUSH
48439: LD_INT 0
48441: PUSH
48442: EMPTY
48443: LIST
48444: LIST
48445: PUSH
48446: LD_INT 30
48448: PUSH
48449: LD_INT 1
48451: PUSH
48452: EMPTY
48453: LIST
48454: LIST
48455: PUSH
48456: EMPTY
48457: LIST
48458: LIST
48459: LIST
48460: PPUSH
48461: CALL_OW 72
48465: ST_TO_ADDR
// if not tmp or not dep then
48466: LD_VAR 0 8
48470: NOT
48471: PUSH
48472: LD_VAR 0 9
48476: NOT
48477: OR
48478: IFFALSE 48482
// continue ;
48480: GO 48267
// side := GetSide ( tmp [ 1 ] ) ;
48482: LD_ADDR_VAR 0 11
48486: PUSH
48487: LD_VAR 0 8
48491: PUSH
48492: LD_INT 1
48494: ARRAY
48495: PPUSH
48496: CALL_OW 255
48500: ST_TO_ADDR
// dep := dep [ 1 ] ;
48501: LD_ADDR_VAR 0 9
48505: PUSH
48506: LD_VAR 0 9
48510: PUSH
48511: LD_INT 1
48513: ARRAY
48514: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
48515: LD_ADDR_VAR 0 7
48519: PUSH
48520: LD_EXP 127
48524: PUSH
48525: LD_VAR 0 2
48529: ARRAY
48530: PPUSH
48531: LD_INT 22
48533: PUSH
48534: LD_INT 0
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: LD_INT 25
48543: PUSH
48544: LD_INT 12
48546: PUSH
48547: EMPTY
48548: LIST
48549: LIST
48550: PUSH
48551: EMPTY
48552: LIST
48553: LIST
48554: PPUSH
48555: CALL_OW 70
48559: PUSH
48560: LD_INT 22
48562: PUSH
48563: LD_INT 0
48565: PUSH
48566: EMPTY
48567: LIST
48568: LIST
48569: PUSH
48570: LD_INT 25
48572: PUSH
48573: LD_INT 12
48575: PUSH
48576: EMPTY
48577: LIST
48578: LIST
48579: PUSH
48580: LD_INT 91
48582: PUSH
48583: LD_VAR 0 9
48587: PUSH
48588: LD_INT 20
48590: PUSH
48591: EMPTY
48592: LIST
48593: LIST
48594: LIST
48595: PUSH
48596: EMPTY
48597: LIST
48598: LIST
48599: LIST
48600: PPUSH
48601: CALL_OW 69
48605: UNION
48606: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
48607: LD_ADDR_VAR 0 10
48611: PUSH
48612: LD_EXP 127
48616: PUSH
48617: LD_VAR 0 2
48621: ARRAY
48622: PPUSH
48623: LD_INT 81
48625: PUSH
48626: LD_VAR 0 11
48630: PUSH
48631: EMPTY
48632: LIST
48633: LIST
48634: PPUSH
48635: CALL_OW 70
48639: ST_TO_ADDR
// if not apes or danger_at_area then
48640: LD_VAR 0 7
48644: NOT
48645: PUSH
48646: LD_VAR 0 10
48650: OR
48651: IFFALSE 48701
// begin if mc_taming [ i ] then
48653: LD_EXP 130
48657: PUSH
48658: LD_VAR 0 2
48662: ARRAY
48663: IFFALSE 48699
// begin MC_Reset ( i , 121 ) ;
48665: LD_VAR 0 2
48669: PPUSH
48670: LD_INT 121
48672: PPUSH
48673: CALL 34659 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48677: LD_ADDR_EXP 130
48681: PUSH
48682: LD_EXP 130
48686: PPUSH
48687: LD_VAR 0 2
48691: PPUSH
48692: EMPTY
48693: PPUSH
48694: CALL_OW 1
48698: ST_TO_ADDR
// end ; continue ;
48699: GO 48267
// end ; for j in tmp do
48701: LD_ADDR_VAR 0 3
48705: PUSH
48706: LD_VAR 0 8
48710: PUSH
48711: FOR_IN
48712: IFFALSE 49048
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
48714: LD_VAR 0 3
48718: PUSH
48719: LD_EXP 130
48723: PUSH
48724: LD_VAR 0 2
48728: ARRAY
48729: IN
48730: NOT
48731: PUSH
48732: LD_EXP 130
48736: PUSH
48737: LD_VAR 0 2
48741: ARRAY
48742: PUSH
48743: LD_INT 3
48745: LESS
48746: AND
48747: IFFALSE 48805
// begin SetTag ( j , 121 ) ;
48749: LD_VAR 0 3
48753: PPUSH
48754: LD_INT 121
48756: PPUSH
48757: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
48761: LD_ADDR_EXP 130
48765: PUSH
48766: LD_EXP 130
48770: PPUSH
48771: LD_VAR 0 2
48775: PUSH
48776: LD_EXP 130
48780: PUSH
48781: LD_VAR 0 2
48785: ARRAY
48786: PUSH
48787: LD_INT 1
48789: PLUS
48790: PUSH
48791: EMPTY
48792: LIST
48793: LIST
48794: PPUSH
48795: LD_VAR 0 3
48799: PPUSH
48800: CALL 66187 0 3
48804: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
48805: LD_VAR 0 3
48809: PUSH
48810: LD_EXP 130
48814: PUSH
48815: LD_VAR 0 2
48819: ARRAY
48820: IN
48821: IFFALSE 49046
// begin if GetClass ( j ) <> 4 then
48823: LD_VAR 0 3
48827: PPUSH
48828: CALL_OW 257
48832: PUSH
48833: LD_INT 4
48835: NONEQUAL
48836: IFFALSE 48889
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
48838: LD_ADDR_EXP 130
48842: PUSH
48843: LD_EXP 130
48847: PPUSH
48848: LD_VAR 0 2
48852: PPUSH
48853: LD_EXP 130
48857: PUSH
48858: LD_VAR 0 2
48862: ARRAY
48863: PUSH
48864: LD_VAR 0 3
48868: DIFF
48869: PPUSH
48870: CALL_OW 1
48874: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48875: LD_VAR 0 3
48879: PPUSH
48880: LD_INT 0
48882: PPUSH
48883: CALL_OW 109
// continue ;
48887: GO 48711
// end ; if IsInUnit ( j ) then
48889: LD_VAR 0 3
48893: PPUSH
48894: CALL_OW 310
48898: IFFALSE 48909
// ComExitBuilding ( j ) ;
48900: LD_VAR 0 3
48904: PPUSH
48905: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
48909: LD_ADDR_VAR 0 6
48913: PUSH
48914: LD_VAR 0 7
48918: PPUSH
48919: LD_VAR 0 3
48923: PPUSH
48924: CALL_OW 74
48928: ST_TO_ADDR
// if not ape then
48929: LD_VAR 0 6
48933: NOT
48934: IFFALSE 48938
// break ;
48936: GO 49048
// x := GetX ( ape ) ;
48938: LD_ADDR_VAR 0 4
48942: PUSH
48943: LD_VAR 0 6
48947: PPUSH
48948: CALL_OW 250
48952: ST_TO_ADDR
// y := GetY ( ape ) ;
48953: LD_ADDR_VAR 0 5
48957: PUSH
48958: LD_VAR 0 6
48962: PPUSH
48963: CALL_OW 251
48967: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
48968: LD_VAR 0 4
48972: PPUSH
48973: LD_VAR 0 5
48977: PPUSH
48978: CALL_OW 488
48982: NOT
48983: PUSH
48984: LD_VAR 0 11
48988: PPUSH
48989: LD_VAR 0 4
48993: PPUSH
48994: LD_VAR 0 5
48998: PPUSH
48999: LD_INT 20
49001: PPUSH
49002: CALL 67083 0 4
49006: PUSH
49007: LD_INT 4
49009: ARRAY
49010: OR
49011: IFFALSE 49015
// break ;
49013: GO 49048
// if not HasTask ( j ) then
49015: LD_VAR 0 3
49019: PPUSH
49020: CALL_OW 314
49024: NOT
49025: IFFALSE 49046
// ComTameXY ( j , x , y ) ;
49027: LD_VAR 0 3
49031: PPUSH
49032: LD_VAR 0 4
49036: PPUSH
49037: LD_VAR 0 5
49041: PPUSH
49042: CALL_OW 131
// end ; end ;
49046: GO 48711
49048: POP
49049: POP
// end ;
49050: GO 48267
49052: POP
49053: POP
// end ;
49054: LD_VAR 0 1
49058: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
49059: LD_INT 0
49061: PPUSH
49062: PPUSH
49063: PPUSH
49064: PPUSH
49065: PPUSH
49066: PPUSH
49067: PPUSH
49068: PPUSH
// if not mc_bases then
49069: LD_EXP 99
49073: NOT
49074: IFFALSE 49078
// exit ;
49076: GO 49704
// for i = 1 to mc_bases do
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: DOUBLE
49084: LD_INT 1
49086: DEC
49087: ST_TO_ADDR
49088: LD_EXP 99
49092: PUSH
49093: FOR_TO
49094: IFFALSE 49702
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
49096: LD_EXP 128
49100: PUSH
49101: LD_VAR 0 2
49105: ARRAY
49106: NOT
49107: PUSH
49108: LD_EXP 128
49112: PUSH
49113: LD_VAR 0 2
49117: ARRAY
49118: PPUSH
49119: LD_INT 25
49121: PUSH
49122: LD_INT 12
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: PPUSH
49129: CALL_OW 72
49133: NOT
49134: OR
49135: IFFALSE 49139
// continue ;
49137: GO 49093
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
49139: LD_ADDR_VAR 0 5
49143: PUSH
49144: LD_EXP 128
49148: PUSH
49149: LD_VAR 0 2
49153: ARRAY
49154: PUSH
49155: LD_INT 1
49157: ARRAY
49158: PPUSH
49159: CALL_OW 255
49163: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
49164: LD_VAR 0 5
49168: PPUSH
49169: LD_INT 2
49171: PPUSH
49172: CALL_OW 325
49176: IFFALSE 49429
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
49178: LD_ADDR_VAR 0 4
49182: PUSH
49183: LD_EXP 128
49187: PUSH
49188: LD_VAR 0 2
49192: ARRAY
49193: PPUSH
49194: LD_INT 25
49196: PUSH
49197: LD_INT 16
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: PPUSH
49204: CALL_OW 72
49208: ST_TO_ADDR
// if tmp < 6 then
49209: LD_VAR 0 4
49213: PUSH
49214: LD_INT 6
49216: LESS
49217: IFFALSE 49429
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49219: LD_ADDR_VAR 0 6
49223: PUSH
49224: LD_EXP 99
49228: PUSH
49229: LD_VAR 0 2
49233: ARRAY
49234: PPUSH
49235: LD_INT 2
49237: PUSH
49238: LD_INT 30
49240: PUSH
49241: LD_INT 0
49243: PUSH
49244: EMPTY
49245: LIST
49246: LIST
49247: PUSH
49248: LD_INT 30
49250: PUSH
49251: LD_INT 1
49253: PUSH
49254: EMPTY
49255: LIST
49256: LIST
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: LIST
49262: PPUSH
49263: CALL_OW 72
49267: ST_TO_ADDR
// if depot then
49268: LD_VAR 0 6
49272: IFFALSE 49429
// begin selected := 0 ;
49274: LD_ADDR_VAR 0 7
49278: PUSH
49279: LD_INT 0
49281: ST_TO_ADDR
// for j in depot do
49282: LD_ADDR_VAR 0 3
49286: PUSH
49287: LD_VAR 0 6
49291: PUSH
49292: FOR_IN
49293: IFFALSE 49324
// begin if UnitsInside ( j ) < 6 then
49295: LD_VAR 0 3
49299: PPUSH
49300: CALL_OW 313
49304: PUSH
49305: LD_INT 6
49307: LESS
49308: IFFALSE 49322
// begin selected := j ;
49310: LD_ADDR_VAR 0 7
49314: PUSH
49315: LD_VAR 0 3
49319: ST_TO_ADDR
// break ;
49320: GO 49324
// end ; end ;
49322: GO 49292
49324: POP
49325: POP
// if selected then
49326: LD_VAR 0 7
49330: IFFALSE 49429
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
49332: LD_ADDR_VAR 0 3
49336: PUSH
49337: LD_EXP 128
49341: PUSH
49342: LD_VAR 0 2
49346: ARRAY
49347: PPUSH
49348: LD_INT 25
49350: PUSH
49351: LD_INT 12
49353: PUSH
49354: EMPTY
49355: LIST
49356: LIST
49357: PPUSH
49358: CALL_OW 72
49362: PUSH
49363: FOR_IN
49364: IFFALSE 49427
// if not HasTask ( j ) then
49366: LD_VAR 0 3
49370: PPUSH
49371: CALL_OW 314
49375: NOT
49376: IFFALSE 49425
// begin if not IsInUnit ( j ) then
49378: LD_VAR 0 3
49382: PPUSH
49383: CALL_OW 310
49387: NOT
49388: IFFALSE 49404
// ComEnterUnit ( j , selected ) ;
49390: LD_VAR 0 3
49394: PPUSH
49395: LD_VAR 0 7
49399: PPUSH
49400: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
49404: LD_VAR 0 3
49408: PPUSH
49409: LD_INT 16
49411: PPUSH
49412: CALL_OW 183
// AddComExitBuilding ( j ) ;
49416: LD_VAR 0 3
49420: PPUSH
49421: CALL_OW 182
// end ;
49425: GO 49363
49427: POP
49428: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
49429: LD_VAR 0 5
49433: PPUSH
49434: LD_INT 11
49436: PPUSH
49437: CALL_OW 325
49441: IFFALSE 49700
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
49443: LD_ADDR_VAR 0 4
49447: PUSH
49448: LD_EXP 128
49452: PUSH
49453: LD_VAR 0 2
49457: ARRAY
49458: PPUSH
49459: LD_INT 25
49461: PUSH
49462: LD_INT 16
49464: PUSH
49465: EMPTY
49466: LIST
49467: LIST
49468: PPUSH
49469: CALL_OW 72
49473: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
49474: LD_VAR 0 4
49478: PUSH
49479: LD_INT 6
49481: GREATEREQUAL
49482: PUSH
49483: LD_VAR 0 5
49487: PPUSH
49488: LD_INT 2
49490: PPUSH
49491: CALL_OW 325
49495: NOT
49496: OR
49497: IFFALSE 49700
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
49499: LD_ADDR_VAR 0 8
49503: PUSH
49504: LD_EXP 99
49508: PUSH
49509: LD_VAR 0 2
49513: ARRAY
49514: PPUSH
49515: LD_INT 2
49517: PUSH
49518: LD_INT 30
49520: PUSH
49521: LD_INT 4
49523: PUSH
49524: EMPTY
49525: LIST
49526: LIST
49527: PUSH
49528: LD_INT 30
49530: PUSH
49531: LD_INT 5
49533: PUSH
49534: EMPTY
49535: LIST
49536: LIST
49537: PUSH
49538: EMPTY
49539: LIST
49540: LIST
49541: LIST
49542: PPUSH
49543: CALL_OW 72
49547: ST_TO_ADDR
// if barracks then
49548: LD_VAR 0 8
49552: IFFALSE 49700
// begin selected := 0 ;
49554: LD_ADDR_VAR 0 7
49558: PUSH
49559: LD_INT 0
49561: ST_TO_ADDR
// for j in barracks do
49562: LD_ADDR_VAR 0 3
49566: PUSH
49567: LD_VAR 0 8
49571: PUSH
49572: FOR_IN
49573: IFFALSE 49604
// begin if UnitsInside ( j ) < 6 then
49575: LD_VAR 0 3
49579: PPUSH
49580: CALL_OW 313
49584: PUSH
49585: LD_INT 6
49587: LESS
49588: IFFALSE 49602
// begin selected := j ;
49590: LD_ADDR_VAR 0 7
49594: PUSH
49595: LD_VAR 0 3
49599: ST_TO_ADDR
// break ;
49600: GO 49604
// end ; end ;
49602: GO 49572
49604: POP
49605: POP
// if selected then
49606: LD_VAR 0 7
49610: IFFALSE 49700
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
49612: LD_ADDR_VAR 0 3
49616: PUSH
49617: LD_EXP 128
49621: PUSH
49622: LD_VAR 0 2
49626: ARRAY
49627: PPUSH
49628: LD_INT 25
49630: PUSH
49631: LD_INT 12
49633: PUSH
49634: EMPTY
49635: LIST
49636: LIST
49637: PPUSH
49638: CALL_OW 72
49642: PUSH
49643: FOR_IN
49644: IFFALSE 49698
// if not IsInUnit ( j ) and not HasTask ( j ) then
49646: LD_VAR 0 3
49650: PPUSH
49651: CALL_OW 310
49655: NOT
49656: PUSH
49657: LD_VAR 0 3
49661: PPUSH
49662: CALL_OW 314
49666: NOT
49667: AND
49668: IFFALSE 49696
// begin ComEnterUnit ( j , selected ) ;
49670: LD_VAR 0 3
49674: PPUSH
49675: LD_VAR 0 7
49679: PPUSH
49680: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
49684: LD_VAR 0 3
49688: PPUSH
49689: LD_INT 15
49691: PPUSH
49692: CALL_OW 183
// end ;
49696: GO 49643
49698: POP
49699: POP
// end ; end ; end ; end ; end ;
49700: GO 49093
49702: POP
49703: POP
// end ;
49704: LD_VAR 0 1
49708: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
49709: LD_INT 0
49711: PPUSH
49712: PPUSH
49713: PPUSH
49714: PPUSH
// if not mc_bases then
49715: LD_EXP 99
49719: NOT
49720: IFFALSE 49724
// exit ;
49722: GO 49902
// for i = 1 to mc_bases do
49724: LD_ADDR_VAR 0 2
49728: PUSH
49729: DOUBLE
49730: LD_INT 1
49732: DEC
49733: ST_TO_ADDR
49734: LD_EXP 99
49738: PUSH
49739: FOR_TO
49740: IFFALSE 49900
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
49742: LD_ADDR_VAR 0 4
49746: PUSH
49747: LD_EXP 99
49751: PUSH
49752: LD_VAR 0 2
49756: ARRAY
49757: PPUSH
49758: LD_INT 25
49760: PUSH
49761: LD_INT 9
49763: PUSH
49764: EMPTY
49765: LIST
49766: LIST
49767: PPUSH
49768: CALL_OW 72
49772: ST_TO_ADDR
// if not tmp then
49773: LD_VAR 0 4
49777: NOT
49778: IFFALSE 49782
// continue ;
49780: GO 49739
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
49782: LD_EXP 125
49786: PUSH
49787: LD_VAR 0 2
49791: ARRAY
49792: PPUSH
49793: LD_INT 29
49795: PPUSH
49796: CALL_OW 325
49800: NOT
49801: PUSH
49802: LD_EXP 125
49806: PUSH
49807: LD_VAR 0 2
49811: ARRAY
49812: PPUSH
49813: LD_INT 28
49815: PPUSH
49816: CALL_OW 325
49820: NOT
49821: AND
49822: IFFALSE 49826
// continue ;
49824: GO 49739
// for j in tmp do
49826: LD_ADDR_VAR 0 3
49830: PUSH
49831: LD_VAR 0 4
49835: PUSH
49836: FOR_IN
49837: IFFALSE 49896
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
49839: LD_VAR 0 3
49843: PUSH
49844: LD_EXP 102
49848: PUSH
49849: LD_VAR 0 2
49853: ARRAY
49854: PUSH
49855: LD_INT 1
49857: ARRAY
49858: IN
49859: NOT
49860: PUSH
49861: LD_VAR 0 3
49865: PUSH
49866: LD_EXP 102
49870: PUSH
49871: LD_VAR 0 2
49875: ARRAY
49876: PUSH
49877: LD_INT 2
49879: ARRAY
49880: IN
49881: NOT
49882: AND
49883: IFFALSE 49894
// ComSpaceTimeShoot ( j ) ;
49885: LD_VAR 0 3
49889: PPUSH
49890: CALL 60247 0 1
49894: GO 49836
49896: POP
49897: POP
// end ;
49898: GO 49739
49900: POP
49901: POP
// end ;
49902: LD_VAR 0 1
49906: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
49907: LD_INT 0
49909: PPUSH
49910: PPUSH
49911: PPUSH
49912: PPUSH
49913: PPUSH
49914: PPUSH
49915: PPUSH
49916: PPUSH
49917: PPUSH
// if not mc_bases then
49918: LD_EXP 99
49922: NOT
49923: IFFALSE 49927
// exit ;
49925: GO 50549
// for i = 1 to mc_bases do
49927: LD_ADDR_VAR 0 2
49931: PUSH
49932: DOUBLE
49933: LD_INT 1
49935: DEC
49936: ST_TO_ADDR
49937: LD_EXP 99
49941: PUSH
49942: FOR_TO
49943: IFFALSE 50547
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
49945: LD_EXP 134
49949: PUSH
49950: LD_VAR 0 2
49954: ARRAY
49955: NOT
49956: PUSH
49957: LD_INT 38
49959: PPUSH
49960: LD_EXP 125
49964: PUSH
49965: LD_VAR 0 2
49969: ARRAY
49970: PPUSH
49971: CALL_OW 321
49975: PUSH
49976: LD_INT 2
49978: NONEQUAL
49979: OR
49980: IFFALSE 49984
// continue ;
49982: GO 49942
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
49984: LD_ADDR_VAR 0 8
49988: PUSH
49989: LD_EXP 99
49993: PUSH
49994: LD_VAR 0 2
49998: ARRAY
49999: PPUSH
50000: LD_INT 30
50002: PUSH
50003: LD_INT 34
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: PPUSH
50010: CALL_OW 72
50014: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
50015: LD_ADDR_VAR 0 9
50019: PUSH
50020: LD_EXP 99
50024: PUSH
50025: LD_VAR 0 2
50029: ARRAY
50030: PPUSH
50031: LD_INT 25
50033: PUSH
50034: LD_INT 4
50036: PUSH
50037: EMPTY
50038: LIST
50039: LIST
50040: PPUSH
50041: CALL_OW 72
50045: PPUSH
50046: LD_INT 0
50048: PPUSH
50049: CALL 99384 0 2
50053: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
50054: LD_VAR 0 9
50058: NOT
50059: PUSH
50060: LD_VAR 0 8
50064: NOT
50065: OR
50066: PUSH
50067: LD_EXP 99
50071: PUSH
50072: LD_VAR 0 2
50076: ARRAY
50077: PPUSH
50078: LD_INT 124
50080: PPUSH
50081: CALL 99384 0 2
50085: OR
50086: IFFALSE 50090
// continue ;
50088: GO 49942
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
50090: LD_EXP 135
50094: PUSH
50095: LD_VAR 0 2
50099: ARRAY
50100: PUSH
50101: LD_EXP 134
50105: PUSH
50106: LD_VAR 0 2
50110: ARRAY
50111: LESS
50112: PUSH
50113: LD_EXP 135
50117: PUSH
50118: LD_VAR 0 2
50122: ARRAY
50123: PUSH
50124: LD_VAR 0 8
50128: LESS
50129: AND
50130: IFFALSE 50545
// begin tmp := sci [ 1 ] ;
50132: LD_ADDR_VAR 0 7
50136: PUSH
50137: LD_VAR 0 9
50141: PUSH
50142: LD_INT 1
50144: ARRAY
50145: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
50146: LD_VAR 0 7
50150: PPUSH
50151: LD_INT 124
50153: PPUSH
50154: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
50158: LD_ADDR_VAR 0 3
50162: PUSH
50163: DOUBLE
50164: LD_EXP 134
50168: PUSH
50169: LD_VAR 0 2
50173: ARRAY
50174: INC
50175: ST_TO_ADDR
50176: LD_EXP 134
50180: PUSH
50181: LD_VAR 0 2
50185: ARRAY
50186: PUSH
50187: FOR_DOWNTO
50188: IFFALSE 50531
// begin if IsInUnit ( tmp ) then
50190: LD_VAR 0 7
50194: PPUSH
50195: CALL_OW 310
50199: IFFALSE 50210
// ComExitBuilding ( tmp ) ;
50201: LD_VAR 0 7
50205: PPUSH
50206: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
50210: LD_INT 35
50212: PPUSH
50213: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
50217: LD_VAR 0 7
50221: PPUSH
50222: CALL_OW 310
50226: NOT
50227: PUSH
50228: LD_VAR 0 7
50232: PPUSH
50233: CALL_OW 314
50237: NOT
50238: AND
50239: IFFALSE 50210
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
50241: LD_ADDR_VAR 0 6
50245: PUSH
50246: LD_VAR 0 7
50250: PPUSH
50251: CALL_OW 250
50255: PUSH
50256: LD_VAR 0 7
50260: PPUSH
50261: CALL_OW 251
50265: PUSH
50266: EMPTY
50267: LIST
50268: LIST
50269: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
50270: LD_INT 35
50272: PPUSH
50273: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
50277: LD_ADDR_VAR 0 4
50281: PUSH
50282: LD_EXP 134
50286: PUSH
50287: LD_VAR 0 2
50291: ARRAY
50292: PUSH
50293: LD_VAR 0 3
50297: ARRAY
50298: PUSH
50299: LD_INT 1
50301: ARRAY
50302: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
50303: LD_ADDR_VAR 0 5
50307: PUSH
50308: LD_EXP 134
50312: PUSH
50313: LD_VAR 0 2
50317: ARRAY
50318: PUSH
50319: LD_VAR 0 3
50323: ARRAY
50324: PUSH
50325: LD_INT 2
50327: ARRAY
50328: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
50329: LD_VAR 0 7
50333: PPUSH
50334: LD_INT 10
50336: PPUSH
50337: CALL 68780 0 2
50341: PUSH
50342: LD_INT 4
50344: ARRAY
50345: IFFALSE 50383
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
50347: LD_VAR 0 7
50351: PPUSH
50352: LD_VAR 0 6
50356: PUSH
50357: LD_INT 1
50359: ARRAY
50360: PPUSH
50361: LD_VAR 0 6
50365: PUSH
50366: LD_INT 2
50368: ARRAY
50369: PPUSH
50370: CALL_OW 111
// wait ( 0 0$10 ) ;
50374: LD_INT 350
50376: PPUSH
50377: CALL_OW 67
// end else
50381: GO 50409
// begin ComMoveXY ( tmp , x , y ) ;
50383: LD_VAR 0 7
50387: PPUSH
50388: LD_VAR 0 4
50392: PPUSH
50393: LD_VAR 0 5
50397: PPUSH
50398: CALL_OW 111
// wait ( 0 0$3 ) ;
50402: LD_INT 105
50404: PPUSH
50405: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
50409: LD_VAR 0 7
50413: PPUSH
50414: LD_VAR 0 4
50418: PPUSH
50419: LD_VAR 0 5
50423: PPUSH
50424: CALL_OW 307
50428: IFFALSE 50270
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
50430: LD_VAR 0 7
50434: PPUSH
50435: LD_VAR 0 4
50439: PPUSH
50440: LD_VAR 0 5
50444: PPUSH
50445: LD_VAR 0 8
50449: PUSH
50450: LD_VAR 0 3
50454: ARRAY
50455: PPUSH
50456: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
50460: LD_INT 35
50462: PPUSH
50463: CALL_OW 67
// until not HasTask ( tmp ) ;
50467: LD_VAR 0 7
50471: PPUSH
50472: CALL_OW 314
50476: NOT
50477: IFFALSE 50460
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
50479: LD_ADDR_EXP 135
50483: PUSH
50484: LD_EXP 135
50488: PPUSH
50489: LD_VAR 0 2
50493: PUSH
50494: LD_EXP 135
50498: PUSH
50499: LD_VAR 0 2
50503: ARRAY
50504: PUSH
50505: LD_INT 1
50507: PLUS
50508: PUSH
50509: EMPTY
50510: LIST
50511: LIST
50512: PPUSH
50513: LD_VAR 0 8
50517: PUSH
50518: LD_VAR 0 3
50522: ARRAY
50523: PPUSH
50524: CALL 66187 0 3
50528: ST_TO_ADDR
// end ;
50529: GO 50187
50531: POP
50532: POP
// MC_Reset ( i , 124 ) ;
50533: LD_VAR 0 2
50537: PPUSH
50538: LD_INT 124
50540: PPUSH
50541: CALL 34659 0 2
// end ; end ;
50545: GO 49942
50547: POP
50548: POP
// end ;
50549: LD_VAR 0 1
50553: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
50554: LD_INT 0
50556: PPUSH
50557: PPUSH
50558: PPUSH
// if not mc_bases then
50559: LD_EXP 99
50563: NOT
50564: IFFALSE 50568
// exit ;
50566: GO 51174
// for i = 1 to mc_bases do
50568: LD_ADDR_VAR 0 2
50572: PUSH
50573: DOUBLE
50574: LD_INT 1
50576: DEC
50577: ST_TO_ADDR
50578: LD_EXP 99
50582: PUSH
50583: FOR_TO
50584: IFFALSE 51172
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
50586: LD_ADDR_VAR 0 3
50590: PUSH
50591: LD_EXP 99
50595: PUSH
50596: LD_VAR 0 2
50600: ARRAY
50601: PPUSH
50602: LD_INT 25
50604: PUSH
50605: LD_INT 4
50607: PUSH
50608: EMPTY
50609: LIST
50610: LIST
50611: PPUSH
50612: CALL_OW 72
50616: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
50617: LD_VAR 0 3
50621: NOT
50622: PUSH
50623: LD_EXP 136
50627: PUSH
50628: LD_VAR 0 2
50632: ARRAY
50633: NOT
50634: OR
50635: PUSH
50636: LD_EXP 99
50640: PUSH
50641: LD_VAR 0 2
50645: ARRAY
50646: PPUSH
50647: LD_INT 2
50649: PUSH
50650: LD_INT 30
50652: PUSH
50653: LD_INT 0
50655: PUSH
50656: EMPTY
50657: LIST
50658: LIST
50659: PUSH
50660: LD_INT 30
50662: PUSH
50663: LD_INT 1
50665: PUSH
50666: EMPTY
50667: LIST
50668: LIST
50669: PUSH
50670: EMPTY
50671: LIST
50672: LIST
50673: LIST
50674: PPUSH
50675: CALL_OW 72
50679: NOT
50680: OR
50681: IFFALSE 50731
// begin if mc_deposits_finder [ i ] then
50683: LD_EXP 137
50687: PUSH
50688: LD_VAR 0 2
50692: ARRAY
50693: IFFALSE 50729
// begin MC_Reset ( i , 125 ) ;
50695: LD_VAR 0 2
50699: PPUSH
50700: LD_INT 125
50702: PPUSH
50703: CALL 34659 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50707: LD_ADDR_EXP 137
50711: PUSH
50712: LD_EXP 137
50716: PPUSH
50717: LD_VAR 0 2
50721: PPUSH
50722: EMPTY
50723: PPUSH
50724: CALL_OW 1
50728: ST_TO_ADDR
// end ; continue ;
50729: GO 50583
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
50731: LD_EXP 136
50735: PUSH
50736: LD_VAR 0 2
50740: ARRAY
50741: PUSH
50742: LD_INT 1
50744: ARRAY
50745: PUSH
50746: LD_INT 3
50748: ARRAY
50749: PUSH
50750: LD_INT 1
50752: EQUAL
50753: PUSH
50754: LD_INT 20
50756: PPUSH
50757: LD_EXP 125
50761: PUSH
50762: LD_VAR 0 2
50766: ARRAY
50767: PPUSH
50768: CALL_OW 321
50772: PUSH
50773: LD_INT 2
50775: NONEQUAL
50776: AND
50777: IFFALSE 50827
// begin if mc_deposits_finder [ i ] then
50779: LD_EXP 137
50783: PUSH
50784: LD_VAR 0 2
50788: ARRAY
50789: IFFALSE 50825
// begin MC_Reset ( i , 125 ) ;
50791: LD_VAR 0 2
50795: PPUSH
50796: LD_INT 125
50798: PPUSH
50799: CALL 34659 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
50803: LD_ADDR_EXP 137
50807: PUSH
50808: LD_EXP 137
50812: PPUSH
50813: LD_VAR 0 2
50817: PPUSH
50818: EMPTY
50819: PPUSH
50820: CALL_OW 1
50824: ST_TO_ADDR
// end ; continue ;
50825: GO 50583
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
50827: LD_EXP 136
50831: PUSH
50832: LD_VAR 0 2
50836: ARRAY
50837: PUSH
50838: LD_INT 1
50840: ARRAY
50841: PUSH
50842: LD_INT 1
50844: ARRAY
50845: PPUSH
50846: LD_EXP 136
50850: PUSH
50851: LD_VAR 0 2
50855: ARRAY
50856: PUSH
50857: LD_INT 1
50859: ARRAY
50860: PUSH
50861: LD_INT 2
50863: ARRAY
50864: PPUSH
50865: LD_EXP 125
50869: PUSH
50870: LD_VAR 0 2
50874: ARRAY
50875: PPUSH
50876: CALL_OW 440
50880: IFFALSE 50923
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
50882: LD_ADDR_EXP 136
50886: PUSH
50887: LD_EXP 136
50891: PPUSH
50892: LD_VAR 0 2
50896: PPUSH
50897: LD_EXP 136
50901: PUSH
50902: LD_VAR 0 2
50906: ARRAY
50907: PPUSH
50908: LD_INT 1
50910: PPUSH
50911: CALL_OW 3
50915: PPUSH
50916: CALL_OW 1
50920: ST_TO_ADDR
50921: GO 51170
// begin if not mc_deposits_finder [ i ] then
50923: LD_EXP 137
50927: PUSH
50928: LD_VAR 0 2
50932: ARRAY
50933: NOT
50934: IFFALSE 50986
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
50936: LD_ADDR_EXP 137
50940: PUSH
50941: LD_EXP 137
50945: PPUSH
50946: LD_VAR 0 2
50950: PPUSH
50951: LD_VAR 0 3
50955: PUSH
50956: LD_INT 1
50958: ARRAY
50959: PUSH
50960: EMPTY
50961: LIST
50962: PPUSH
50963: CALL_OW 1
50967: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
50968: LD_VAR 0 3
50972: PUSH
50973: LD_INT 1
50975: ARRAY
50976: PPUSH
50977: LD_INT 125
50979: PPUSH
50980: CALL_OW 109
// end else
50984: GO 51170
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
50986: LD_EXP 137
50990: PUSH
50991: LD_VAR 0 2
50995: ARRAY
50996: PUSH
50997: LD_INT 1
50999: ARRAY
51000: PPUSH
51001: CALL_OW 310
51005: IFFALSE 51028
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
51007: LD_EXP 137
51011: PUSH
51012: LD_VAR 0 2
51016: ARRAY
51017: PUSH
51018: LD_INT 1
51020: ARRAY
51021: PPUSH
51022: CALL_OW 122
51026: GO 51170
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
51028: LD_EXP 137
51032: PUSH
51033: LD_VAR 0 2
51037: ARRAY
51038: PUSH
51039: LD_INT 1
51041: ARRAY
51042: PPUSH
51043: CALL_OW 314
51047: NOT
51048: PUSH
51049: LD_EXP 137
51053: PUSH
51054: LD_VAR 0 2
51058: ARRAY
51059: PUSH
51060: LD_INT 1
51062: ARRAY
51063: PPUSH
51064: LD_EXP 136
51068: PUSH
51069: LD_VAR 0 2
51073: ARRAY
51074: PUSH
51075: LD_INT 1
51077: ARRAY
51078: PUSH
51079: LD_INT 1
51081: ARRAY
51082: PPUSH
51083: LD_EXP 136
51087: PUSH
51088: LD_VAR 0 2
51092: ARRAY
51093: PUSH
51094: LD_INT 1
51096: ARRAY
51097: PUSH
51098: LD_INT 2
51100: ARRAY
51101: PPUSH
51102: CALL_OW 297
51106: PUSH
51107: LD_INT 6
51109: GREATER
51110: AND
51111: IFFALSE 51170
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
51113: LD_EXP 137
51117: PUSH
51118: LD_VAR 0 2
51122: ARRAY
51123: PUSH
51124: LD_INT 1
51126: ARRAY
51127: PPUSH
51128: LD_EXP 136
51132: PUSH
51133: LD_VAR 0 2
51137: ARRAY
51138: PUSH
51139: LD_INT 1
51141: ARRAY
51142: PUSH
51143: LD_INT 1
51145: ARRAY
51146: PPUSH
51147: LD_EXP 136
51151: PUSH
51152: LD_VAR 0 2
51156: ARRAY
51157: PUSH
51158: LD_INT 1
51160: ARRAY
51161: PUSH
51162: LD_INT 2
51164: ARRAY
51165: PPUSH
51166: CALL_OW 111
// end ; end ; end ;
51170: GO 50583
51172: POP
51173: POP
// end ;
51174: LD_VAR 0 1
51178: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
51179: LD_INT 0
51181: PPUSH
51182: PPUSH
51183: PPUSH
51184: PPUSH
51185: PPUSH
51186: PPUSH
51187: PPUSH
51188: PPUSH
51189: PPUSH
51190: PPUSH
51191: PPUSH
// if not mc_bases then
51192: LD_EXP 99
51196: NOT
51197: IFFALSE 51201
// exit ;
51199: GO 51925
// for i = 1 to mc_bases do
51201: LD_ADDR_VAR 0 2
51205: PUSH
51206: DOUBLE
51207: LD_INT 1
51209: DEC
51210: ST_TO_ADDR
51211: LD_EXP 99
51215: PUSH
51216: FOR_TO
51217: IFFALSE 51923
// begin if not mc_bases [ i ] then
51219: LD_EXP 99
51223: PUSH
51224: LD_VAR 0 2
51228: ARRAY
51229: NOT
51230: IFFALSE 51234
// continue ;
51232: GO 51216
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
51234: LD_ADDR_VAR 0 7
51238: PUSH
51239: LD_EXP 99
51243: PUSH
51244: LD_VAR 0 2
51248: ARRAY
51249: PUSH
51250: LD_INT 1
51252: ARRAY
51253: PPUSH
51254: CALL_OW 248
51258: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
51259: LD_VAR 0 7
51263: PUSH
51264: LD_INT 3
51266: EQUAL
51267: PUSH
51268: LD_EXP 118
51272: PUSH
51273: LD_VAR 0 2
51277: ARRAY
51278: PUSH
51279: LD_EXP 121
51283: PUSH
51284: LD_VAR 0 2
51288: ARRAY
51289: UNION
51290: PPUSH
51291: LD_INT 33
51293: PUSH
51294: LD_INT 2
51296: PUSH
51297: EMPTY
51298: LIST
51299: LIST
51300: PPUSH
51301: CALL_OW 72
51305: NOT
51306: OR
51307: IFFALSE 51311
// continue ;
51309: GO 51216
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
51311: LD_ADDR_VAR 0 9
51315: PUSH
51316: LD_EXP 99
51320: PUSH
51321: LD_VAR 0 2
51325: ARRAY
51326: PPUSH
51327: LD_INT 30
51329: PUSH
51330: LD_INT 36
51332: PUSH
51333: EMPTY
51334: LIST
51335: LIST
51336: PPUSH
51337: CALL_OW 72
51341: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
51342: LD_ADDR_VAR 0 10
51346: PUSH
51347: LD_EXP 118
51351: PUSH
51352: LD_VAR 0 2
51356: ARRAY
51357: PPUSH
51358: LD_INT 34
51360: PUSH
51361: LD_INT 31
51363: PUSH
51364: EMPTY
51365: LIST
51366: LIST
51367: PPUSH
51368: CALL_OW 72
51372: ST_TO_ADDR
// if not cts and not mcts then
51373: LD_VAR 0 9
51377: NOT
51378: PUSH
51379: LD_VAR 0 10
51383: NOT
51384: AND
51385: IFFALSE 51389
// continue ;
51387: GO 51216
// x := cts ;
51389: LD_ADDR_VAR 0 11
51393: PUSH
51394: LD_VAR 0 9
51398: ST_TO_ADDR
// if not x then
51399: LD_VAR 0 11
51403: NOT
51404: IFFALSE 51416
// x := mcts ;
51406: LD_ADDR_VAR 0 11
51410: PUSH
51411: LD_VAR 0 10
51415: ST_TO_ADDR
// if mc_remote_driver [ i ] then
51416: LD_EXP 139
51420: PUSH
51421: LD_VAR 0 2
51425: ARRAY
51426: IFFALSE 51695
// for j in mc_remote_driver [ i ] do
51428: LD_ADDR_VAR 0 3
51432: PUSH
51433: LD_EXP 139
51437: PUSH
51438: LD_VAR 0 2
51442: ARRAY
51443: PUSH
51444: FOR_IN
51445: IFFALSE 51693
// begin if GetClass ( j ) <> 3 then
51447: LD_VAR 0 3
51451: PPUSH
51452: CALL_OW 257
51456: PUSH
51457: LD_INT 3
51459: NONEQUAL
51460: IFFALSE 51513
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
51462: LD_ADDR_EXP 139
51466: PUSH
51467: LD_EXP 139
51471: PPUSH
51472: LD_VAR 0 2
51476: PPUSH
51477: LD_EXP 139
51481: PUSH
51482: LD_VAR 0 2
51486: ARRAY
51487: PUSH
51488: LD_VAR 0 3
51492: DIFF
51493: PPUSH
51494: CALL_OW 1
51498: ST_TO_ADDR
// SetTag ( j , 0 ) ;
51499: LD_VAR 0 3
51503: PPUSH
51504: LD_INT 0
51506: PPUSH
51507: CALL_OW 109
// continue ;
51511: GO 51444
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
51513: LD_VAR 0 3
51517: PPUSH
51518: CALL_OW 310
51522: NOT
51523: PUSH
51524: LD_VAR 0 3
51528: PPUSH
51529: CALL_OW 310
51533: PPUSH
51534: CALL_OW 266
51538: PUSH
51539: LD_INT 36
51541: NONEQUAL
51542: PUSH
51543: LD_VAR 0 3
51547: PPUSH
51548: CALL 99472 0 1
51552: NOT
51553: AND
51554: OR
51555: IFFALSE 51691
// begin if IsInUnit ( j ) then
51557: LD_VAR 0 3
51561: PPUSH
51562: CALL_OW 310
51566: IFFALSE 51577
// ComExitBuilding ( j ) ;
51568: LD_VAR 0 3
51572: PPUSH
51573: CALL_OW 122
// ct := 0 ;
51577: LD_ADDR_VAR 0 8
51581: PUSH
51582: LD_INT 0
51584: ST_TO_ADDR
// for k in x do
51585: LD_ADDR_VAR 0 4
51589: PUSH
51590: LD_VAR 0 11
51594: PUSH
51595: FOR_IN
51596: IFFALSE 51669
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
51598: LD_VAR 0 4
51602: PPUSH
51603: CALL_OW 264
51607: PUSH
51608: LD_INT 31
51610: EQUAL
51611: PUSH
51612: LD_VAR 0 4
51616: PPUSH
51617: CALL_OW 311
51621: NOT
51622: AND
51623: PUSH
51624: LD_VAR 0 4
51628: PPUSH
51629: CALL_OW 266
51633: PUSH
51634: LD_INT 36
51636: EQUAL
51637: PUSH
51638: LD_VAR 0 4
51642: PPUSH
51643: CALL_OW 313
51647: PUSH
51648: LD_INT 3
51650: LESS
51651: AND
51652: OR
51653: IFFALSE 51667
// begin ct := k ;
51655: LD_ADDR_VAR 0 8
51659: PUSH
51660: LD_VAR 0 4
51664: ST_TO_ADDR
// break ;
51665: GO 51669
// end ;
51667: GO 51595
51669: POP
51670: POP
// if ct then
51671: LD_VAR 0 8
51675: IFFALSE 51691
// ComEnterUnit ( j , ct ) ;
51677: LD_VAR 0 3
51681: PPUSH
51682: LD_VAR 0 8
51686: PPUSH
51687: CALL_OW 120
// end ; end ;
51691: GO 51444
51693: POP
51694: POP
// places := 0 ;
51695: LD_ADDR_VAR 0 5
51699: PUSH
51700: LD_INT 0
51702: ST_TO_ADDR
// for j = 1 to x do
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: DOUBLE
51709: LD_INT 1
51711: DEC
51712: ST_TO_ADDR
51713: LD_VAR 0 11
51717: PUSH
51718: FOR_TO
51719: IFFALSE 51774
// if GetWeapon ( x [ j ] ) = ar_control_tower then
51721: LD_VAR 0 11
51725: PUSH
51726: LD_VAR 0 3
51730: ARRAY
51731: PPUSH
51732: CALL_OW 264
51736: PUSH
51737: LD_INT 31
51739: EQUAL
51740: IFFALSE 51758
// places := places + 1 else
51742: LD_ADDR_VAR 0 5
51746: PUSH
51747: LD_VAR 0 5
51751: PUSH
51752: LD_INT 1
51754: PLUS
51755: ST_TO_ADDR
51756: GO 51772
// places := places + 3 ;
51758: LD_ADDR_VAR 0 5
51762: PUSH
51763: LD_VAR 0 5
51767: PUSH
51768: LD_INT 3
51770: PLUS
51771: ST_TO_ADDR
51772: GO 51718
51774: POP
51775: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
51776: LD_ADDR_VAR 0 6
51780: PUSH
51781: LD_EXP 99
51785: PUSH
51786: LD_VAR 0 2
51790: ARRAY
51791: PPUSH
51792: LD_INT 25
51794: PUSH
51795: LD_INT 3
51797: PUSH
51798: EMPTY
51799: LIST
51800: LIST
51801: PPUSH
51802: CALL_OW 72
51806: PUSH
51807: LD_EXP 139
51811: PUSH
51812: LD_VAR 0 2
51816: ARRAY
51817: DIFF
51818: PPUSH
51819: LD_INT 3
51821: PPUSH
51822: CALL 100372 0 2
51826: ST_TO_ADDR
// if not tmp then
51827: LD_VAR 0 6
51831: NOT
51832: IFFALSE 51836
// continue ;
51834: GO 51216
// places := places - mc_remote_driver [ i ] ;
51836: LD_ADDR_VAR 0 5
51840: PUSH
51841: LD_VAR 0 5
51845: PUSH
51846: LD_EXP 139
51850: PUSH
51851: LD_VAR 0 2
51855: ARRAY
51856: MINUS
51857: ST_TO_ADDR
// if places then
51858: LD_VAR 0 5
51862: IFFALSE 51921
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
51864: LD_ADDR_EXP 139
51868: PUSH
51869: LD_EXP 139
51873: PPUSH
51874: LD_VAR 0 2
51878: PPUSH
51879: LD_EXP 139
51883: PUSH
51884: LD_VAR 0 2
51888: ARRAY
51889: PUSH
51890: LD_VAR 0 6
51894: PUSH
51895: LD_INT 1
51897: ARRAY
51898: UNION
51899: PPUSH
51900: CALL_OW 1
51904: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
51905: LD_VAR 0 6
51909: PUSH
51910: LD_INT 1
51912: ARRAY
51913: PPUSH
51914: LD_INT 126
51916: PPUSH
51917: CALL_OW 109
// end ; end ;
51921: GO 51216
51923: POP
51924: POP
// end ;
51925: LD_VAR 0 1
51929: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
51930: LD_INT 0
51932: PPUSH
51933: PPUSH
51934: PPUSH
51935: PPUSH
51936: PPUSH
51937: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
51938: LD_VAR 0 1
51942: NOT
51943: PUSH
51944: LD_VAR 0 2
51948: NOT
51949: OR
51950: PUSH
51951: LD_VAR 0 3
51955: NOT
51956: OR
51957: PUSH
51958: LD_VAR 0 4
51962: PUSH
51963: LD_INT 1
51965: PUSH
51966: LD_INT 2
51968: PUSH
51969: LD_INT 3
51971: PUSH
51972: LD_INT 4
51974: PUSH
51975: LD_INT 5
51977: PUSH
51978: LD_INT 8
51980: PUSH
51981: LD_INT 9
51983: PUSH
51984: LD_INT 15
51986: PUSH
51987: LD_INT 16
51989: PUSH
51990: EMPTY
51991: LIST
51992: LIST
51993: LIST
51994: LIST
51995: LIST
51996: LIST
51997: LIST
51998: LIST
51999: LIST
52000: IN
52001: NOT
52002: OR
52003: IFFALSE 52007
// exit ;
52005: GO 52907
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
52007: LD_ADDR_VAR 0 2
52011: PUSH
52012: LD_VAR 0 2
52016: PPUSH
52017: LD_INT 21
52019: PUSH
52020: LD_INT 3
52022: PUSH
52023: EMPTY
52024: LIST
52025: LIST
52026: PUSH
52027: LD_INT 24
52029: PUSH
52030: LD_INT 250
52032: PUSH
52033: EMPTY
52034: LIST
52035: LIST
52036: PUSH
52037: EMPTY
52038: LIST
52039: LIST
52040: PPUSH
52041: CALL_OW 72
52045: ST_TO_ADDR
// case class of 1 , 15 :
52046: LD_VAR 0 4
52050: PUSH
52051: LD_INT 1
52053: DOUBLE
52054: EQUAL
52055: IFTRUE 52065
52057: LD_INT 15
52059: DOUBLE
52060: EQUAL
52061: IFTRUE 52065
52063: GO 52150
52065: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
52066: LD_ADDR_VAR 0 8
52070: PUSH
52071: LD_VAR 0 2
52075: PPUSH
52076: LD_INT 2
52078: PUSH
52079: LD_INT 30
52081: PUSH
52082: LD_INT 32
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: PUSH
52089: LD_INT 30
52091: PUSH
52092: LD_INT 31
52094: PUSH
52095: EMPTY
52096: LIST
52097: LIST
52098: PUSH
52099: EMPTY
52100: LIST
52101: LIST
52102: LIST
52103: PPUSH
52104: CALL_OW 72
52108: PUSH
52109: LD_VAR 0 2
52113: PPUSH
52114: LD_INT 2
52116: PUSH
52117: LD_INT 30
52119: PUSH
52120: LD_INT 4
52122: PUSH
52123: EMPTY
52124: LIST
52125: LIST
52126: PUSH
52127: LD_INT 30
52129: PUSH
52130: LD_INT 5
52132: PUSH
52133: EMPTY
52134: LIST
52135: LIST
52136: PUSH
52137: EMPTY
52138: LIST
52139: LIST
52140: LIST
52141: PPUSH
52142: CALL_OW 72
52146: ADD
52147: ST_TO_ADDR
52148: GO 52396
52150: LD_INT 2
52152: DOUBLE
52153: EQUAL
52154: IFTRUE 52164
52156: LD_INT 16
52158: DOUBLE
52159: EQUAL
52160: IFTRUE 52164
52162: GO 52210
52164: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
52165: LD_ADDR_VAR 0 8
52169: PUSH
52170: LD_VAR 0 2
52174: PPUSH
52175: LD_INT 2
52177: PUSH
52178: LD_INT 30
52180: PUSH
52181: LD_INT 0
52183: PUSH
52184: EMPTY
52185: LIST
52186: LIST
52187: PUSH
52188: LD_INT 30
52190: PUSH
52191: LD_INT 1
52193: PUSH
52194: EMPTY
52195: LIST
52196: LIST
52197: PUSH
52198: EMPTY
52199: LIST
52200: LIST
52201: LIST
52202: PPUSH
52203: CALL_OW 72
52207: ST_TO_ADDR
52208: GO 52396
52210: LD_INT 3
52212: DOUBLE
52213: EQUAL
52214: IFTRUE 52218
52216: GO 52264
52218: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
52219: LD_ADDR_VAR 0 8
52223: PUSH
52224: LD_VAR 0 2
52228: PPUSH
52229: LD_INT 2
52231: PUSH
52232: LD_INT 30
52234: PUSH
52235: LD_INT 2
52237: PUSH
52238: EMPTY
52239: LIST
52240: LIST
52241: PUSH
52242: LD_INT 30
52244: PUSH
52245: LD_INT 3
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: PUSH
52252: EMPTY
52253: LIST
52254: LIST
52255: LIST
52256: PPUSH
52257: CALL_OW 72
52261: ST_TO_ADDR
52262: GO 52396
52264: LD_INT 4
52266: DOUBLE
52267: EQUAL
52268: IFTRUE 52272
52270: GO 52329
52272: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
52273: LD_ADDR_VAR 0 8
52277: PUSH
52278: LD_VAR 0 2
52282: PPUSH
52283: LD_INT 2
52285: PUSH
52286: LD_INT 30
52288: PUSH
52289: LD_INT 6
52291: PUSH
52292: EMPTY
52293: LIST
52294: LIST
52295: PUSH
52296: LD_INT 30
52298: PUSH
52299: LD_INT 7
52301: PUSH
52302: EMPTY
52303: LIST
52304: LIST
52305: PUSH
52306: LD_INT 30
52308: PUSH
52309: LD_INT 8
52311: PUSH
52312: EMPTY
52313: LIST
52314: LIST
52315: PUSH
52316: EMPTY
52317: LIST
52318: LIST
52319: LIST
52320: LIST
52321: PPUSH
52322: CALL_OW 72
52326: ST_TO_ADDR
52327: GO 52396
52329: LD_INT 5
52331: DOUBLE
52332: EQUAL
52333: IFTRUE 52349
52335: LD_INT 8
52337: DOUBLE
52338: EQUAL
52339: IFTRUE 52349
52341: LD_INT 9
52343: DOUBLE
52344: EQUAL
52345: IFTRUE 52349
52347: GO 52395
52349: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
52350: LD_ADDR_VAR 0 8
52354: PUSH
52355: LD_VAR 0 2
52359: PPUSH
52360: LD_INT 2
52362: PUSH
52363: LD_INT 30
52365: PUSH
52366: LD_INT 4
52368: PUSH
52369: EMPTY
52370: LIST
52371: LIST
52372: PUSH
52373: LD_INT 30
52375: PUSH
52376: LD_INT 5
52378: PUSH
52379: EMPTY
52380: LIST
52381: LIST
52382: PUSH
52383: EMPTY
52384: LIST
52385: LIST
52386: LIST
52387: PPUSH
52388: CALL_OW 72
52392: ST_TO_ADDR
52393: GO 52396
52395: POP
// if not tmp then
52396: LD_VAR 0 8
52400: NOT
52401: IFFALSE 52405
// exit ;
52403: GO 52907
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
52405: LD_VAR 0 4
52409: PUSH
52410: LD_INT 1
52412: PUSH
52413: LD_INT 15
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: IN
52420: PUSH
52421: LD_EXP 108
52425: PUSH
52426: LD_VAR 0 1
52430: ARRAY
52431: AND
52432: IFFALSE 52588
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
52434: LD_ADDR_VAR 0 9
52438: PUSH
52439: LD_EXP 108
52443: PUSH
52444: LD_VAR 0 1
52448: ARRAY
52449: PUSH
52450: LD_INT 1
52452: ARRAY
52453: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
52454: LD_VAR 0 9
52458: PUSH
52459: LD_EXP 109
52463: PUSH
52464: LD_VAR 0 1
52468: ARRAY
52469: IN
52470: NOT
52471: IFFALSE 52586
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
52473: LD_ADDR_EXP 109
52477: PUSH
52478: LD_EXP 109
52482: PPUSH
52483: LD_VAR 0 1
52487: PUSH
52488: LD_EXP 109
52492: PUSH
52493: LD_VAR 0 1
52497: ARRAY
52498: PUSH
52499: LD_INT 1
52501: PLUS
52502: PUSH
52503: EMPTY
52504: LIST
52505: LIST
52506: PPUSH
52507: LD_VAR 0 9
52511: PPUSH
52512: CALL 66187 0 3
52516: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
52517: LD_ADDR_EXP 108
52521: PUSH
52522: LD_EXP 108
52526: PPUSH
52527: LD_VAR 0 1
52531: PPUSH
52532: LD_EXP 108
52536: PUSH
52537: LD_VAR 0 1
52541: ARRAY
52542: PUSH
52543: LD_VAR 0 9
52547: DIFF
52548: PPUSH
52549: CALL_OW 1
52553: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
52554: LD_VAR 0 3
52558: PPUSH
52559: LD_EXP 109
52563: PUSH
52564: LD_VAR 0 1
52568: ARRAY
52569: PUSH
52570: LD_EXP 109
52574: PUSH
52575: LD_VAR 0 1
52579: ARRAY
52580: ARRAY
52581: PPUSH
52582: CALL_OW 120
// end ; exit ;
52586: GO 52907
// end ; if tmp > 1 then
52588: LD_VAR 0 8
52592: PUSH
52593: LD_INT 1
52595: GREATER
52596: IFFALSE 52700
// for i = 2 to tmp do
52598: LD_ADDR_VAR 0 6
52602: PUSH
52603: DOUBLE
52604: LD_INT 2
52606: DEC
52607: ST_TO_ADDR
52608: LD_VAR 0 8
52612: PUSH
52613: FOR_TO
52614: IFFALSE 52698
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
52616: LD_VAR 0 8
52620: PUSH
52621: LD_VAR 0 6
52625: ARRAY
52626: PPUSH
52627: CALL_OW 461
52631: PUSH
52632: LD_INT 6
52634: EQUAL
52635: IFFALSE 52696
// begin x := tmp [ i ] ;
52637: LD_ADDR_VAR 0 9
52641: PUSH
52642: LD_VAR 0 8
52646: PUSH
52647: LD_VAR 0 6
52651: ARRAY
52652: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
52653: LD_ADDR_VAR 0 8
52657: PUSH
52658: LD_VAR 0 8
52662: PPUSH
52663: LD_VAR 0 6
52667: PPUSH
52668: CALL_OW 3
52672: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
52673: LD_ADDR_VAR 0 8
52677: PUSH
52678: LD_VAR 0 8
52682: PPUSH
52683: LD_INT 1
52685: PPUSH
52686: LD_VAR 0 9
52690: PPUSH
52691: CALL_OW 2
52695: ST_TO_ADDR
// end ;
52696: GO 52613
52698: POP
52699: POP
// for i in tmp do
52700: LD_ADDR_VAR 0 6
52704: PUSH
52705: LD_VAR 0 8
52709: PUSH
52710: FOR_IN
52711: IFFALSE 52780
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
52713: LD_VAR 0 6
52717: PPUSH
52718: CALL_OW 313
52722: PUSH
52723: LD_INT 6
52725: LESS
52726: PUSH
52727: LD_VAR 0 6
52731: PPUSH
52732: CALL_OW 266
52736: PUSH
52737: LD_INT 31
52739: PUSH
52740: LD_INT 32
52742: PUSH
52743: EMPTY
52744: LIST
52745: LIST
52746: IN
52747: NOT
52748: AND
52749: PUSH
52750: LD_VAR 0 6
52754: PPUSH
52755: CALL_OW 313
52759: PUSH
52760: LD_INT 0
52762: EQUAL
52763: OR
52764: IFFALSE 52778
// begin j := i ;
52766: LD_ADDR_VAR 0 7
52770: PUSH
52771: LD_VAR 0 6
52775: ST_TO_ADDR
// break ;
52776: GO 52780
// end ; end ;
52778: GO 52710
52780: POP
52781: POP
// if j then
52782: LD_VAR 0 7
52786: IFFALSE 52804
// ComEnterUnit ( unit , j ) else
52788: LD_VAR 0 3
52792: PPUSH
52793: LD_VAR 0 7
52797: PPUSH
52798: CALL_OW 120
52802: GO 52907
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52804: LD_ADDR_VAR 0 10
52808: PUSH
52809: LD_VAR 0 2
52813: PPUSH
52814: LD_INT 2
52816: PUSH
52817: LD_INT 30
52819: PUSH
52820: LD_INT 0
52822: PUSH
52823: EMPTY
52824: LIST
52825: LIST
52826: PUSH
52827: LD_INT 30
52829: PUSH
52830: LD_INT 1
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: LIST
52841: PPUSH
52842: CALL_OW 72
52846: ST_TO_ADDR
// if depot then
52847: LD_VAR 0 10
52851: IFFALSE 52907
// begin depot := NearestUnitToUnit ( depot , unit ) ;
52853: LD_ADDR_VAR 0 10
52857: PUSH
52858: LD_VAR 0 10
52862: PPUSH
52863: LD_VAR 0 3
52867: PPUSH
52868: CALL_OW 74
52872: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
52873: LD_VAR 0 3
52877: PPUSH
52878: LD_VAR 0 10
52882: PPUSH
52883: CALL_OW 296
52887: PUSH
52888: LD_INT 10
52890: GREATER
52891: IFFALSE 52907
// ComStandNearbyBuilding ( unit , depot ) ;
52893: LD_VAR 0 3
52897: PPUSH
52898: LD_VAR 0 10
52902: PPUSH
52903: CALL 60864 0 2
// end ; end ; end ;
52907: LD_VAR 0 5
52911: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
52912: LD_INT 0
52914: PPUSH
52915: PPUSH
52916: PPUSH
52917: PPUSH
// if not mc_bases then
52918: LD_EXP 99
52922: NOT
52923: IFFALSE 52927
// exit ;
52925: GO 53166
// for i = 1 to mc_bases do
52927: LD_ADDR_VAR 0 2
52931: PUSH
52932: DOUBLE
52933: LD_INT 1
52935: DEC
52936: ST_TO_ADDR
52937: LD_EXP 99
52941: PUSH
52942: FOR_TO
52943: IFFALSE 53164
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
52945: LD_ADDR_VAR 0 4
52949: PUSH
52950: LD_EXP 99
52954: PUSH
52955: LD_VAR 0 2
52959: ARRAY
52960: PPUSH
52961: LD_INT 21
52963: PUSH
52964: LD_INT 1
52966: PUSH
52967: EMPTY
52968: LIST
52969: LIST
52970: PPUSH
52971: CALL_OW 72
52975: PUSH
52976: LD_EXP 128
52980: PUSH
52981: LD_VAR 0 2
52985: ARRAY
52986: UNION
52987: ST_TO_ADDR
// if not tmp then
52988: LD_VAR 0 4
52992: NOT
52993: IFFALSE 52997
// continue ;
52995: GO 52942
// for j in tmp do
52997: LD_ADDR_VAR 0 3
53001: PUSH
53002: LD_VAR 0 4
53006: PUSH
53007: FOR_IN
53008: IFFALSE 53160
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
53010: LD_VAR 0 3
53014: PPUSH
53015: CALL_OW 110
53019: NOT
53020: PUSH
53021: LD_VAR 0 3
53025: PPUSH
53026: CALL_OW 314
53030: NOT
53031: AND
53032: PUSH
53033: LD_VAR 0 3
53037: PPUSH
53038: CALL_OW 311
53042: NOT
53043: AND
53044: PUSH
53045: LD_VAR 0 3
53049: PPUSH
53050: CALL_OW 310
53054: NOT
53055: AND
53056: PUSH
53057: LD_VAR 0 3
53061: PUSH
53062: LD_EXP 102
53066: PUSH
53067: LD_VAR 0 2
53071: ARRAY
53072: PUSH
53073: LD_INT 1
53075: ARRAY
53076: IN
53077: NOT
53078: AND
53079: PUSH
53080: LD_VAR 0 3
53084: PUSH
53085: LD_EXP 102
53089: PUSH
53090: LD_VAR 0 2
53094: ARRAY
53095: PUSH
53096: LD_INT 2
53098: ARRAY
53099: IN
53100: NOT
53101: AND
53102: PUSH
53103: LD_VAR 0 3
53107: PUSH
53108: LD_EXP 111
53112: PUSH
53113: LD_VAR 0 2
53117: ARRAY
53118: IN
53119: NOT
53120: AND
53121: IFFALSE 53158
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
53123: LD_VAR 0 2
53127: PPUSH
53128: LD_EXP 99
53132: PUSH
53133: LD_VAR 0 2
53137: ARRAY
53138: PPUSH
53139: LD_VAR 0 3
53143: PPUSH
53144: LD_VAR 0 3
53148: PPUSH
53149: CALL_OW 257
53153: PPUSH
53154: CALL 51930 0 4
// end ;
53158: GO 53007
53160: POP
53161: POP
// end ;
53162: GO 52942
53164: POP
53165: POP
// end ;
53166: LD_VAR 0 1
53170: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
53171: LD_INT 0
53173: PPUSH
53174: PPUSH
53175: PPUSH
53176: PPUSH
53177: PPUSH
53178: PPUSH
// if not mc_bases [ base ] then
53179: LD_EXP 99
53183: PUSH
53184: LD_VAR 0 1
53188: ARRAY
53189: NOT
53190: IFFALSE 53194
// exit ;
53192: GO 53376
// tmp := [ ] ;
53194: LD_ADDR_VAR 0 6
53198: PUSH
53199: EMPTY
53200: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
53201: LD_ADDR_VAR 0 7
53205: PUSH
53206: LD_VAR 0 3
53210: PPUSH
53211: LD_INT 0
53213: PPUSH
53214: CALL_OW 517
53218: ST_TO_ADDR
// if not list then
53219: LD_VAR 0 7
53223: NOT
53224: IFFALSE 53228
// exit ;
53226: GO 53376
// for i = 1 to amount do
53228: LD_ADDR_VAR 0 5
53232: PUSH
53233: DOUBLE
53234: LD_INT 1
53236: DEC
53237: ST_TO_ADDR
53238: LD_VAR 0 2
53242: PUSH
53243: FOR_TO
53244: IFFALSE 53324
// begin x := rand ( 1 , list [ 1 ] ) ;
53246: LD_ADDR_VAR 0 8
53250: PUSH
53251: LD_INT 1
53253: PPUSH
53254: LD_VAR 0 7
53258: PUSH
53259: LD_INT 1
53261: ARRAY
53262: PPUSH
53263: CALL_OW 12
53267: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
53268: LD_ADDR_VAR 0 6
53272: PUSH
53273: LD_VAR 0 6
53277: PPUSH
53278: LD_VAR 0 5
53282: PPUSH
53283: LD_VAR 0 7
53287: PUSH
53288: LD_INT 1
53290: ARRAY
53291: PUSH
53292: LD_VAR 0 8
53296: ARRAY
53297: PUSH
53298: LD_VAR 0 7
53302: PUSH
53303: LD_INT 2
53305: ARRAY
53306: PUSH
53307: LD_VAR 0 8
53311: ARRAY
53312: PUSH
53313: EMPTY
53314: LIST
53315: LIST
53316: PPUSH
53317: CALL_OW 1
53321: ST_TO_ADDR
// end ;
53322: GO 53243
53324: POP
53325: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
53326: LD_ADDR_EXP 112
53330: PUSH
53331: LD_EXP 112
53335: PPUSH
53336: LD_VAR 0 1
53340: PPUSH
53341: LD_VAR 0 6
53345: PPUSH
53346: CALL_OW 1
53350: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
53351: LD_ADDR_EXP 114
53355: PUSH
53356: LD_EXP 114
53360: PPUSH
53361: LD_VAR 0 1
53365: PPUSH
53366: LD_VAR 0 3
53370: PPUSH
53371: CALL_OW 1
53375: ST_TO_ADDR
// end ;
53376: LD_VAR 0 4
53380: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
53381: LD_INT 0
53383: PPUSH
// if not mc_bases [ base ] then
53384: LD_EXP 99
53388: PUSH
53389: LD_VAR 0 1
53393: ARRAY
53394: NOT
53395: IFFALSE 53399
// exit ;
53397: GO 53424
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
53399: LD_ADDR_EXP 104
53403: PUSH
53404: LD_EXP 104
53408: PPUSH
53409: LD_VAR 0 1
53413: PPUSH
53414: LD_VAR 0 2
53418: PPUSH
53419: CALL_OW 1
53423: ST_TO_ADDR
// end ;
53424: LD_VAR 0 3
53428: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
53429: LD_INT 0
53431: PPUSH
// if not mc_bases [ base ] then
53432: LD_EXP 99
53436: PUSH
53437: LD_VAR 0 1
53441: ARRAY
53442: NOT
53443: IFFALSE 53447
// exit ;
53445: GO 53484
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
53447: LD_ADDR_EXP 104
53451: PUSH
53452: LD_EXP 104
53456: PPUSH
53457: LD_VAR 0 1
53461: PPUSH
53462: LD_EXP 104
53466: PUSH
53467: LD_VAR 0 1
53471: ARRAY
53472: PUSH
53473: LD_VAR 0 2
53477: UNION
53478: PPUSH
53479: CALL_OW 1
53483: ST_TO_ADDR
// end ;
53484: LD_VAR 0 3
53488: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
53489: LD_INT 0
53491: PPUSH
// if not mc_bases [ base ] then
53492: LD_EXP 99
53496: PUSH
53497: LD_VAR 0 1
53501: ARRAY
53502: NOT
53503: IFFALSE 53507
// exit ;
53505: GO 53532
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
53507: LD_ADDR_EXP 120
53511: PUSH
53512: LD_EXP 120
53516: PPUSH
53517: LD_VAR 0 1
53521: PPUSH
53522: LD_VAR 0 2
53526: PPUSH
53527: CALL_OW 1
53531: ST_TO_ADDR
// end ;
53532: LD_VAR 0 3
53536: RET
// export function MC_InsertProduceList ( base , compontents ) ; begin
53537: LD_INT 0
53539: PPUSH
// if not mc_bases [ base ] then
53540: LD_EXP 99
53544: PUSH
53545: LD_VAR 0 1
53549: ARRAY
53550: NOT
53551: IFFALSE 53555
// exit ;
53553: GO 53592
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] union compontents ) ;
53555: LD_ADDR_EXP 120
53559: PUSH
53560: LD_EXP 120
53564: PPUSH
53565: LD_VAR 0 1
53569: PPUSH
53570: LD_EXP 120
53574: PUSH
53575: LD_VAR 0 1
53579: ARRAY
53580: PUSH
53581: LD_VAR 0 2
53585: UNION
53586: PPUSH
53587: CALL_OW 1
53591: ST_TO_ADDR
// end ;
53592: LD_VAR 0 3
53596: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
53597: LD_INT 0
53599: PPUSH
// if not mc_bases [ base ] then
53600: LD_EXP 99
53604: PUSH
53605: LD_VAR 0 1
53609: ARRAY
53610: NOT
53611: IFFALSE 53615
// exit ;
53613: GO 53727
// mc_defender := Replace ( mc_defender , base , deflist ) ;
53615: LD_ADDR_EXP 121
53619: PUSH
53620: LD_EXP 121
53624: PPUSH
53625: LD_VAR 0 1
53629: PPUSH
53630: LD_VAR 0 2
53634: PPUSH
53635: CALL_OW 1
53639: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
53640: LD_ADDR_EXP 110
53644: PUSH
53645: LD_EXP 110
53649: PPUSH
53650: LD_VAR 0 1
53654: PPUSH
53655: LD_VAR 0 2
53659: PUSH
53660: LD_INT 0
53662: PLUS
53663: PPUSH
53664: CALL_OW 1
53668: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] union UnitFilter ( mc_defender [ base ] , [ f_type , unit_vehicle ] ) ) ;
53669: LD_ADDR_EXP 118
53673: PUSH
53674: LD_EXP 118
53678: PPUSH
53679: LD_VAR 0 1
53683: PPUSH
53684: LD_EXP 118
53688: PUSH
53689: LD_VAR 0 1
53693: ARRAY
53694: PUSH
53695: LD_EXP 121
53699: PUSH
53700: LD_VAR 0 1
53704: ARRAY
53705: PPUSH
53706: LD_INT 21
53708: PUSH
53709: LD_INT 2
53711: PUSH
53712: EMPTY
53713: LIST
53714: LIST
53715: PPUSH
53716: CALL_OW 72
53720: UNION
53721: PPUSH
53722: CALL_OW 1
53726: ST_TO_ADDR
// end ;
53727: LD_VAR 0 3
53731: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
53732: LD_INT 0
53734: PPUSH
// if not mc_bases [ base ] then
53735: LD_EXP 99
53739: PUSH
53740: LD_VAR 0 1
53744: ARRAY
53745: NOT
53746: IFFALSE 53750
// exit ;
53748: GO 53775
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
53750: LD_ADDR_EXP 110
53754: PUSH
53755: LD_EXP 110
53759: PPUSH
53760: LD_VAR 0 1
53764: PPUSH
53765: LD_VAR 0 2
53769: PPUSH
53770: CALL_OW 1
53774: ST_TO_ADDR
// end ;
53775: LD_VAR 0 3
53779: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
53780: LD_INT 0
53782: PPUSH
53783: PPUSH
53784: PPUSH
53785: PPUSH
// if not mc_bases [ base ] then
53786: LD_EXP 99
53790: PUSH
53791: LD_VAR 0 1
53795: ARRAY
53796: NOT
53797: IFFALSE 53801
// exit ;
53799: GO 53866
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
53801: LD_ADDR_EXP 119
53805: PUSH
53806: LD_EXP 119
53810: PPUSH
53811: LD_VAR 0 1
53815: PUSH
53816: LD_EXP 119
53820: PUSH
53821: LD_VAR 0 1
53825: ARRAY
53826: PUSH
53827: LD_INT 1
53829: PLUS
53830: PUSH
53831: EMPTY
53832: LIST
53833: LIST
53834: PPUSH
53835: LD_VAR 0 1
53839: PUSH
53840: LD_VAR 0 2
53844: PUSH
53845: LD_VAR 0 3
53849: PUSH
53850: LD_VAR 0 4
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: LIST
53860: PPUSH
53861: CALL 66187 0 3
53865: ST_TO_ADDR
// end ;
53866: LD_VAR 0 5
53870: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
53871: LD_INT 0
53873: PPUSH
// if not mc_bases [ base ] then
53874: LD_EXP 99
53878: PUSH
53879: LD_VAR 0 1
53883: ARRAY
53884: NOT
53885: IFFALSE 53889
// exit ;
53887: GO 53914
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
53889: LD_ADDR_EXP 136
53893: PUSH
53894: LD_EXP 136
53898: PPUSH
53899: LD_VAR 0 1
53903: PPUSH
53904: LD_VAR 0 2
53908: PPUSH
53909: CALL_OW 1
53913: ST_TO_ADDR
// end ;
53914: LD_VAR 0 3
53918: RET
// export function MC_GetMinesField ( base ) ; begin
53919: LD_INT 0
53921: PPUSH
// result := mc_mines [ base ] ;
53922: LD_ADDR_VAR 0 2
53926: PUSH
53927: LD_EXP 112
53931: PUSH
53932: LD_VAR 0 1
53936: ARRAY
53937: ST_TO_ADDR
// end ;
53938: LD_VAR 0 2
53942: RET
// export function MC_GetProduceList ( base ) ; begin
53943: LD_INT 0
53945: PPUSH
// result := mc_produce [ base ] ;
53946: LD_ADDR_VAR 0 2
53950: PUSH
53951: LD_EXP 120
53955: PUSH
53956: LD_VAR 0 1
53960: ARRAY
53961: ST_TO_ADDR
// end ;
53962: LD_VAR 0 2
53966: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
53967: LD_INT 0
53969: PPUSH
53970: PPUSH
// if not mc_bases then
53971: LD_EXP 99
53975: NOT
53976: IFFALSE 53980
// exit ;
53978: GO 54045
// if mc_bases [ base ] then
53980: LD_EXP 99
53984: PUSH
53985: LD_VAR 0 1
53989: ARRAY
53990: IFFALSE 54045
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
53992: LD_ADDR_VAR 0 3
53996: PUSH
53997: LD_EXP 99
54001: PUSH
54002: LD_VAR 0 1
54006: ARRAY
54007: PPUSH
54008: LD_INT 30
54010: PUSH
54011: LD_VAR 0 2
54015: PUSH
54016: EMPTY
54017: LIST
54018: LIST
54019: PPUSH
54020: CALL_OW 72
54024: ST_TO_ADDR
// if result then
54025: LD_VAR 0 3
54029: IFFALSE 54045
// result := result [ 1 ] ;
54031: LD_ADDR_VAR 0 3
54035: PUSH
54036: LD_VAR 0 3
54040: PUSH
54041: LD_INT 1
54043: ARRAY
54044: ST_TO_ADDR
// end ; end ;
54045: LD_VAR 0 3
54049: RET
// export function MC_SetTame ( base , area ) ; begin
54050: LD_INT 0
54052: PPUSH
// if not mc_bases or not base then
54053: LD_EXP 99
54057: NOT
54058: PUSH
54059: LD_VAR 0 1
54063: NOT
54064: OR
54065: IFFALSE 54069
// exit ;
54067: GO 54094
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
54069: LD_ADDR_EXP 127
54073: PUSH
54074: LD_EXP 127
54078: PPUSH
54079: LD_VAR 0 1
54083: PPUSH
54084: LD_VAR 0 2
54088: PPUSH
54089: CALL_OW 1
54093: ST_TO_ADDR
// end ;
54094: LD_VAR 0 3
54098: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
54099: LD_INT 0
54101: PPUSH
54102: PPUSH
// if not mc_bases or not base then
54103: LD_EXP 99
54107: NOT
54108: PUSH
54109: LD_VAR 0 1
54113: NOT
54114: OR
54115: IFFALSE 54119
// exit ;
54117: GO 54221
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
54119: LD_ADDR_VAR 0 4
54123: PUSH
54124: LD_EXP 99
54128: PUSH
54129: LD_VAR 0 1
54133: ARRAY
54134: PPUSH
54135: LD_INT 30
54137: PUSH
54138: LD_VAR 0 2
54142: PUSH
54143: EMPTY
54144: LIST
54145: LIST
54146: PPUSH
54147: CALL_OW 72
54151: ST_TO_ADDR
// if not tmp then
54152: LD_VAR 0 4
54156: NOT
54157: IFFALSE 54161
// exit ;
54159: GO 54221
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
54161: LD_ADDR_EXP 131
54165: PUSH
54166: LD_EXP 131
54170: PPUSH
54171: LD_VAR 0 1
54175: PPUSH
54176: LD_EXP 131
54180: PUSH
54181: LD_VAR 0 1
54185: ARRAY
54186: PPUSH
54187: LD_EXP 131
54191: PUSH
54192: LD_VAR 0 1
54196: ARRAY
54197: PUSH
54198: LD_INT 1
54200: PLUS
54201: PPUSH
54202: LD_VAR 0 4
54206: PUSH
54207: LD_INT 1
54209: ARRAY
54210: PPUSH
54211: CALL_OW 2
54215: PPUSH
54216: CALL_OW 1
54220: ST_TO_ADDR
// end ;
54221: LD_VAR 0 3
54225: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
54226: LD_INT 0
54228: PPUSH
54229: PPUSH
// if not mc_bases or not base or not kinds then
54230: LD_EXP 99
54234: NOT
54235: PUSH
54236: LD_VAR 0 1
54240: NOT
54241: OR
54242: PUSH
54243: LD_VAR 0 2
54247: NOT
54248: OR
54249: IFFALSE 54253
// exit ;
54251: GO 54314
// for i in kinds do
54253: LD_ADDR_VAR 0 4
54257: PUSH
54258: LD_VAR 0 2
54262: PUSH
54263: FOR_IN
54264: IFFALSE 54312
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
54266: LD_ADDR_EXP 133
54270: PUSH
54271: LD_EXP 133
54275: PPUSH
54276: LD_VAR 0 1
54280: PUSH
54281: LD_EXP 133
54285: PUSH
54286: LD_VAR 0 1
54290: ARRAY
54291: PUSH
54292: LD_INT 1
54294: PLUS
54295: PUSH
54296: EMPTY
54297: LIST
54298: LIST
54299: PPUSH
54300: LD_VAR 0 4
54304: PPUSH
54305: CALL 66187 0 3
54309: ST_TO_ADDR
54310: GO 54263
54312: POP
54313: POP
// end ;
54314: LD_VAR 0 3
54318: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
54319: LD_INT 0
54321: PPUSH
// if not mc_bases or not base or not areas then
54322: LD_EXP 99
54326: NOT
54327: PUSH
54328: LD_VAR 0 1
54332: NOT
54333: OR
54334: PUSH
54335: LD_VAR 0 2
54339: NOT
54340: OR
54341: IFFALSE 54345
// exit ;
54343: GO 54370
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
54345: LD_ADDR_EXP 117
54349: PUSH
54350: LD_EXP 117
54354: PPUSH
54355: LD_VAR 0 1
54359: PPUSH
54360: LD_VAR 0 2
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// end ;
54370: LD_VAR 0 3
54374: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
54375: LD_INT 0
54377: PPUSH
// if not mc_bases or not base or not teleports_exit then
54378: LD_EXP 99
54382: NOT
54383: PUSH
54384: LD_VAR 0 1
54388: NOT
54389: OR
54390: PUSH
54391: LD_VAR 0 2
54395: NOT
54396: OR
54397: IFFALSE 54401
// exit ;
54399: GO 54426
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
54401: LD_ADDR_EXP 134
54405: PUSH
54406: LD_EXP 134
54410: PPUSH
54411: LD_VAR 0 1
54415: PPUSH
54416: LD_VAR 0 2
54420: PPUSH
54421: CALL_OW 1
54425: ST_TO_ADDR
// end ;
54426: LD_VAR 0 3
54430: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
54431: LD_INT 0
54433: PPUSH
54434: PPUSH
54435: PPUSH
// if not mc_bases or not base or not ext_list then
54436: LD_EXP 99
54440: NOT
54441: PUSH
54442: LD_VAR 0 1
54446: NOT
54447: OR
54448: PUSH
54449: LD_VAR 0 5
54453: NOT
54454: OR
54455: IFFALSE 54459
// exit ;
54457: GO 54632
// tmp := GetFacExtXYD ( x , y , d ) ;
54459: LD_ADDR_VAR 0 8
54463: PUSH
54464: LD_VAR 0 2
54468: PPUSH
54469: LD_VAR 0 3
54473: PPUSH
54474: LD_VAR 0 4
54478: PPUSH
54479: CALL 99502 0 3
54483: ST_TO_ADDR
// if not tmp then
54484: LD_VAR 0 8
54488: NOT
54489: IFFALSE 54493
// exit ;
54491: GO 54632
// for i in tmp do
54493: LD_ADDR_VAR 0 7
54497: PUSH
54498: LD_VAR 0 8
54502: PUSH
54503: FOR_IN
54504: IFFALSE 54630
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
54506: LD_ADDR_EXP 104
54510: PUSH
54511: LD_EXP 104
54515: PPUSH
54516: LD_VAR 0 1
54520: PPUSH
54521: LD_EXP 104
54525: PUSH
54526: LD_VAR 0 1
54530: ARRAY
54531: PPUSH
54532: LD_EXP 104
54536: PUSH
54537: LD_VAR 0 1
54541: ARRAY
54542: PUSH
54543: LD_INT 1
54545: PLUS
54546: PPUSH
54547: LD_VAR 0 5
54551: PUSH
54552: LD_INT 1
54554: ARRAY
54555: PUSH
54556: LD_VAR 0 7
54560: PUSH
54561: LD_INT 1
54563: ARRAY
54564: PUSH
54565: LD_VAR 0 7
54569: PUSH
54570: LD_INT 2
54572: ARRAY
54573: PUSH
54574: LD_VAR 0 7
54578: PUSH
54579: LD_INT 3
54581: ARRAY
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: LIST
54587: LIST
54588: PPUSH
54589: CALL_OW 2
54593: PPUSH
54594: CALL_OW 1
54598: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
54599: LD_ADDR_VAR 0 5
54603: PUSH
54604: LD_VAR 0 5
54608: PPUSH
54609: LD_INT 1
54611: PPUSH
54612: CALL_OW 3
54616: ST_TO_ADDR
// if not ext_list then
54617: LD_VAR 0 5
54621: NOT
54622: IFFALSE 54628
// exit ;
54624: POP
54625: POP
54626: GO 54632
// end ;
54628: GO 54503
54630: POP
54631: POP
// end ;
54632: LD_VAR 0 6
54636: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
54637: LD_INT 0
54639: PPUSH
// if not mc_bases or not base or not weapon_list then
54640: LD_EXP 99
54644: NOT
54645: PUSH
54646: LD_VAR 0 1
54650: NOT
54651: OR
54652: PUSH
54653: LD_VAR 0 2
54657: NOT
54658: OR
54659: IFFALSE 54663
// exit ;
54661: GO 54688
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
54663: LD_ADDR_EXP 138
54667: PUSH
54668: LD_EXP 138
54672: PPUSH
54673: LD_VAR 0 1
54677: PPUSH
54678: LD_VAR 0 2
54682: PPUSH
54683: CALL_OW 1
54687: ST_TO_ADDR
// end ;
54688: LD_VAR 0 3
54692: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
54693: LD_INT 0
54695: PPUSH
// if not mc_bases or not base or not tech_list then
54696: LD_EXP 99
54700: NOT
54701: PUSH
54702: LD_VAR 0 1
54706: NOT
54707: OR
54708: PUSH
54709: LD_VAR 0 2
54713: NOT
54714: OR
54715: IFFALSE 54719
// exit ;
54717: GO 54744
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
54719: LD_ADDR_EXP 126
54723: PUSH
54724: LD_EXP 126
54728: PPUSH
54729: LD_VAR 0 1
54733: PPUSH
54734: LD_VAR 0 2
54738: PPUSH
54739: CALL_OW 1
54743: ST_TO_ADDR
// end ;
54744: LD_VAR 0 3
54748: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
54749: LD_INT 0
54751: PPUSH
// if not mc_bases or not parking_area or not base then
54752: LD_EXP 99
54756: NOT
54757: PUSH
54758: LD_VAR 0 2
54762: NOT
54763: OR
54764: PUSH
54765: LD_VAR 0 1
54769: NOT
54770: OR
54771: IFFALSE 54775
// exit ;
54773: GO 54800
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
54775: LD_ADDR_EXP 123
54779: PUSH
54780: LD_EXP 123
54784: PPUSH
54785: LD_VAR 0 1
54789: PPUSH
54790: LD_VAR 0 2
54794: PPUSH
54795: CALL_OW 1
54799: ST_TO_ADDR
// end ;
54800: LD_VAR 0 3
54804: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
54805: LD_INT 0
54807: PPUSH
// if not mc_bases or not base or not scan_area then
54808: LD_EXP 99
54812: NOT
54813: PUSH
54814: LD_VAR 0 1
54818: NOT
54819: OR
54820: PUSH
54821: LD_VAR 0 2
54825: NOT
54826: OR
54827: IFFALSE 54831
// exit ;
54829: GO 54856
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
54831: LD_ADDR_EXP 124
54835: PUSH
54836: LD_EXP 124
54840: PPUSH
54841: LD_VAR 0 1
54845: PPUSH
54846: LD_VAR 0 2
54850: PPUSH
54851: CALL_OW 1
54855: ST_TO_ADDR
// end ;
54856: LD_VAR 0 3
54860: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
54861: LD_INT 0
54863: PPUSH
54864: PPUSH
// if not mc_bases or not base then
54865: LD_EXP 99
54869: NOT
54870: PUSH
54871: LD_VAR 0 1
54875: NOT
54876: OR
54877: IFFALSE 54881
// exit ;
54879: GO 54945
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
54881: LD_ADDR_VAR 0 3
54885: PUSH
54886: LD_INT 1
54888: PUSH
54889: LD_INT 2
54891: PUSH
54892: LD_INT 3
54894: PUSH
54895: LD_INT 4
54897: PUSH
54898: LD_INT 11
54900: PUSH
54901: EMPTY
54902: LIST
54903: LIST
54904: LIST
54905: LIST
54906: LIST
54907: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
54908: LD_ADDR_EXP 126
54912: PUSH
54913: LD_EXP 126
54917: PPUSH
54918: LD_VAR 0 1
54922: PPUSH
54923: LD_EXP 126
54927: PUSH
54928: LD_VAR 0 1
54932: ARRAY
54933: PUSH
54934: LD_VAR 0 3
54938: DIFF
54939: PPUSH
54940: CALL_OW 1
54944: ST_TO_ADDR
// end ;
54945: LD_VAR 0 2
54949: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
54950: LD_INT 0
54952: PPUSH
// result := mc_vehicles [ base ] ;
54953: LD_ADDR_VAR 0 3
54957: PUSH
54958: LD_EXP 118
54962: PUSH
54963: LD_VAR 0 1
54967: ARRAY
54968: ST_TO_ADDR
// if onlyCombat then
54969: LD_VAR 0 2
54973: IFFALSE 55116
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] ] ) ;
54975: LD_ADDR_VAR 0 3
54979: PUSH
54980: LD_VAR 0 3
54984: PUSH
54985: LD_VAR 0 3
54989: PPUSH
54990: LD_INT 2
54992: PUSH
54993: LD_INT 34
54995: PUSH
54996: LD_INT 12
54998: PUSH
54999: EMPTY
55000: LIST
55001: LIST
55002: PUSH
55003: LD_INT 34
55005: PUSH
55006: LD_INT 51
55008: PUSH
55009: EMPTY
55010: LIST
55011: LIST
55012: PUSH
55013: LD_INT 34
55015: PUSH
55016: LD_EXP 93
55020: PUSH
55021: EMPTY
55022: LIST
55023: LIST
55024: PUSH
55025: LD_INT 34
55027: PUSH
55028: LD_INT 32
55030: PUSH
55031: EMPTY
55032: LIST
55033: LIST
55034: PUSH
55035: LD_INT 34
55037: PUSH
55038: LD_INT 13
55040: PUSH
55041: EMPTY
55042: LIST
55043: LIST
55044: PUSH
55045: LD_INT 34
55047: PUSH
55048: LD_INT 52
55050: PUSH
55051: EMPTY
55052: LIST
55053: LIST
55054: PUSH
55055: LD_INT 34
55057: PUSH
55058: LD_INT 14
55060: PUSH
55061: EMPTY
55062: LIST
55063: LIST
55064: PUSH
55065: LD_INT 34
55067: PUSH
55068: LD_INT 53
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: PUSH
55075: LD_INT 34
55077: PUSH
55078: LD_EXP 92
55082: PUSH
55083: EMPTY
55084: LIST
55085: LIST
55086: PUSH
55087: LD_INT 34
55089: PUSH
55090: LD_INT 31
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: PUSH
55097: EMPTY
55098: LIST
55099: LIST
55100: LIST
55101: LIST
55102: LIST
55103: LIST
55104: LIST
55105: LIST
55106: LIST
55107: LIST
55108: LIST
55109: PPUSH
55110: CALL_OW 72
55114: DIFF
55115: ST_TO_ADDR
// end ; end_of_file
55116: LD_VAR 0 3
55120: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
55121: LD_INT 0
55123: PPUSH
55124: PPUSH
55125: PPUSH
// if not mc_bases or not skirmish then
55126: LD_EXP 99
55130: NOT
55131: PUSH
55132: LD_EXP 97
55136: NOT
55137: OR
55138: IFFALSE 55142
// exit ;
55140: GO 55307
// for i = 1 to mc_bases do
55142: LD_ADDR_VAR 0 4
55146: PUSH
55147: DOUBLE
55148: LD_INT 1
55150: DEC
55151: ST_TO_ADDR
55152: LD_EXP 99
55156: PUSH
55157: FOR_TO
55158: IFFALSE 55305
// begin if sci in mc_bases [ i ] then
55160: LD_VAR 0 2
55164: PUSH
55165: LD_EXP 99
55169: PUSH
55170: LD_VAR 0 4
55174: ARRAY
55175: IN
55176: IFFALSE 55303
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
55178: LD_ADDR_EXP 128
55182: PUSH
55183: LD_EXP 128
55187: PPUSH
55188: LD_VAR 0 4
55192: PUSH
55193: LD_EXP 128
55197: PUSH
55198: LD_VAR 0 4
55202: ARRAY
55203: PUSH
55204: LD_INT 1
55206: PLUS
55207: PUSH
55208: EMPTY
55209: LIST
55210: LIST
55211: PPUSH
55212: LD_VAR 0 1
55216: PPUSH
55217: CALL 66187 0 3
55221: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
55222: LD_ADDR_VAR 0 5
55226: PUSH
55227: LD_EXP 99
55231: PUSH
55232: LD_VAR 0 4
55236: ARRAY
55237: PPUSH
55238: LD_INT 2
55240: PUSH
55241: LD_INT 30
55243: PUSH
55244: LD_INT 0
55246: PUSH
55247: EMPTY
55248: LIST
55249: LIST
55250: PUSH
55251: LD_INT 30
55253: PUSH
55254: LD_INT 1
55256: PUSH
55257: EMPTY
55258: LIST
55259: LIST
55260: PUSH
55261: EMPTY
55262: LIST
55263: LIST
55264: LIST
55265: PPUSH
55266: CALL_OW 72
55270: PPUSH
55271: LD_VAR 0 1
55275: PPUSH
55276: CALL_OW 74
55280: ST_TO_ADDR
// if tmp then
55281: LD_VAR 0 5
55285: IFFALSE 55301
// ComStandNearbyBuilding ( ape , tmp ) ;
55287: LD_VAR 0 1
55291: PPUSH
55292: LD_VAR 0 5
55296: PPUSH
55297: CALL 60864 0 2
// break ;
55301: GO 55305
// end ; end ;
55303: GO 55157
55305: POP
55306: POP
// end ;
55307: LD_VAR 0 3
55311: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
55312: LD_INT 0
55314: PPUSH
55315: PPUSH
55316: PPUSH
// if not mc_bases or not skirmish then
55317: LD_EXP 99
55321: NOT
55322: PUSH
55323: LD_EXP 97
55327: NOT
55328: OR
55329: IFFALSE 55333
// exit ;
55331: GO 55422
// for i = 1 to mc_bases do
55333: LD_ADDR_VAR 0 4
55337: PUSH
55338: DOUBLE
55339: LD_INT 1
55341: DEC
55342: ST_TO_ADDR
55343: LD_EXP 99
55347: PUSH
55348: FOR_TO
55349: IFFALSE 55420
// begin if building in mc_busy_turret_list [ i ] then
55351: LD_VAR 0 1
55355: PUSH
55356: LD_EXP 109
55360: PUSH
55361: LD_VAR 0 4
55365: ARRAY
55366: IN
55367: IFFALSE 55418
// begin tmp := mc_busy_turret_list [ i ] diff building ;
55369: LD_ADDR_VAR 0 5
55373: PUSH
55374: LD_EXP 109
55378: PUSH
55379: LD_VAR 0 4
55383: ARRAY
55384: PUSH
55385: LD_VAR 0 1
55389: DIFF
55390: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
55391: LD_ADDR_EXP 109
55395: PUSH
55396: LD_EXP 109
55400: PPUSH
55401: LD_VAR 0 4
55405: PPUSH
55406: LD_VAR 0 5
55410: PPUSH
55411: CALL_OW 1
55415: ST_TO_ADDR
// break ;
55416: GO 55420
// end ; end ;
55418: GO 55348
55420: POP
55421: POP
// end ;
55422: LD_VAR 0 3
55426: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
55427: LD_INT 0
55429: PPUSH
55430: PPUSH
55431: PPUSH
// if not mc_bases or not skirmish then
55432: LD_EXP 99
55436: NOT
55437: PUSH
55438: LD_EXP 97
55442: NOT
55443: OR
55444: IFFALSE 55448
// exit ;
55446: GO 55647
// for i = 1 to mc_bases do
55448: LD_ADDR_VAR 0 5
55452: PUSH
55453: DOUBLE
55454: LD_INT 1
55456: DEC
55457: ST_TO_ADDR
55458: LD_EXP 99
55462: PUSH
55463: FOR_TO
55464: IFFALSE 55645
// if building in mc_bases [ i ] then
55466: LD_VAR 0 1
55470: PUSH
55471: LD_EXP 99
55475: PUSH
55476: LD_VAR 0 5
55480: ARRAY
55481: IN
55482: IFFALSE 55643
// begin tmp := mc_bases [ i ] diff building ;
55484: LD_ADDR_VAR 0 6
55488: PUSH
55489: LD_EXP 99
55493: PUSH
55494: LD_VAR 0 5
55498: ARRAY
55499: PUSH
55500: LD_VAR 0 1
55504: DIFF
55505: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
55506: LD_ADDR_EXP 99
55510: PUSH
55511: LD_EXP 99
55515: PPUSH
55516: LD_VAR 0 5
55520: PPUSH
55521: LD_VAR 0 6
55525: PPUSH
55526: CALL_OW 1
55530: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
55531: LD_VAR 0 1
55535: PUSH
55536: LD_EXP 107
55540: PUSH
55541: LD_VAR 0 5
55545: ARRAY
55546: IN
55547: IFFALSE 55586
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
55549: LD_ADDR_EXP 107
55553: PUSH
55554: LD_EXP 107
55558: PPUSH
55559: LD_VAR 0 5
55563: PPUSH
55564: LD_EXP 107
55568: PUSH
55569: LD_VAR 0 5
55573: ARRAY
55574: PUSH
55575: LD_VAR 0 1
55579: DIFF
55580: PPUSH
55581: CALL_OW 1
55585: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
55586: LD_VAR 0 1
55590: PUSH
55591: LD_EXP 108
55595: PUSH
55596: LD_VAR 0 5
55600: ARRAY
55601: IN
55602: IFFALSE 55641
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
55604: LD_ADDR_EXP 108
55608: PUSH
55609: LD_EXP 108
55613: PPUSH
55614: LD_VAR 0 5
55618: PPUSH
55619: LD_EXP 108
55623: PUSH
55624: LD_VAR 0 5
55628: ARRAY
55629: PUSH
55630: LD_VAR 0 1
55634: DIFF
55635: PPUSH
55636: CALL_OW 1
55640: ST_TO_ADDR
// break ;
55641: GO 55645
// end ;
55643: GO 55463
55645: POP
55646: POP
// end ;
55647: LD_VAR 0 4
55651: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
55652: LD_INT 0
55654: PPUSH
55655: PPUSH
55656: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
55657: LD_EXP 99
55661: NOT
55662: PUSH
55663: LD_EXP 97
55667: NOT
55668: OR
55669: PUSH
55670: LD_VAR 0 3
55674: PUSH
55675: LD_EXP 125
55679: IN
55680: NOT
55681: OR
55682: IFFALSE 55686
// exit ;
55684: GO 55809
// for i = 1 to mc_vehicles do
55686: LD_ADDR_VAR 0 6
55690: PUSH
55691: DOUBLE
55692: LD_INT 1
55694: DEC
55695: ST_TO_ADDR
55696: LD_EXP 118
55700: PUSH
55701: FOR_TO
55702: IFFALSE 55807
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
55704: LD_VAR 0 2
55708: PUSH
55709: LD_EXP 118
55713: PUSH
55714: LD_VAR 0 6
55718: ARRAY
55719: IN
55720: PUSH
55721: LD_VAR 0 1
55725: PUSH
55726: LD_EXP 118
55730: PUSH
55731: LD_VAR 0 6
55735: ARRAY
55736: IN
55737: OR
55738: IFFALSE 55805
// begin tmp := mc_vehicles [ i ] diff old ;
55740: LD_ADDR_VAR 0 7
55744: PUSH
55745: LD_EXP 118
55749: PUSH
55750: LD_VAR 0 6
55754: ARRAY
55755: PUSH
55756: LD_VAR 0 2
55760: DIFF
55761: ST_TO_ADDR
// tmp := tmp diff new ;
55762: LD_ADDR_VAR 0 7
55766: PUSH
55767: LD_VAR 0 7
55771: PUSH
55772: LD_VAR 0 1
55776: DIFF
55777: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
55778: LD_ADDR_EXP 118
55782: PUSH
55783: LD_EXP 118
55787: PPUSH
55788: LD_VAR 0 6
55792: PPUSH
55793: LD_VAR 0 7
55797: PPUSH
55798: CALL_OW 1
55802: ST_TO_ADDR
// break ;
55803: GO 55807
// end ;
55805: GO 55701
55807: POP
55808: POP
// end ;
55809: LD_VAR 0 5
55813: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
55814: LD_INT 0
55816: PPUSH
55817: PPUSH
55818: PPUSH
55819: PPUSH
// if not mc_bases or not skirmish then
55820: LD_EXP 99
55824: NOT
55825: PUSH
55826: LD_EXP 97
55830: NOT
55831: OR
55832: IFFALSE 55836
// exit ;
55834: GO 56219
// side := GetSide ( vehicle ) ;
55836: LD_ADDR_VAR 0 5
55840: PUSH
55841: LD_VAR 0 1
55845: PPUSH
55846: CALL_OW 255
55850: ST_TO_ADDR
// for i = 1 to mc_bases do
55851: LD_ADDR_VAR 0 4
55855: PUSH
55856: DOUBLE
55857: LD_INT 1
55859: DEC
55860: ST_TO_ADDR
55861: LD_EXP 99
55865: PUSH
55866: FOR_TO
55867: IFFALSE 56217
// begin if factory in mc_bases [ i ] then
55869: LD_VAR 0 2
55873: PUSH
55874: LD_EXP 99
55878: PUSH
55879: LD_VAR 0 4
55883: ARRAY
55884: IN
55885: IFFALSE 56215
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
55887: LD_EXP 121
55891: PUSH
55892: LD_VAR 0 4
55896: ARRAY
55897: PUSH
55898: LD_EXP 110
55902: PUSH
55903: LD_VAR 0 4
55907: ARRAY
55908: LESS
55909: PUSH
55910: LD_VAR 0 1
55914: PPUSH
55915: CALL_OW 264
55919: PUSH
55920: LD_INT 31
55922: PUSH
55923: LD_INT 32
55925: PUSH
55926: LD_INT 51
55928: PUSH
55929: LD_EXP 93
55933: PUSH
55934: LD_INT 12
55936: PUSH
55937: LD_INT 30
55939: PUSH
55940: LD_EXP 92
55944: PUSH
55945: LD_INT 11
55947: PUSH
55948: LD_INT 53
55950: PUSH
55951: LD_INT 14
55953: PUSH
55954: LD_EXP 96
55958: PUSH
55959: LD_INT 29
55961: PUSH
55962: LD_EXP 94
55966: PUSH
55967: LD_INT 13
55969: PUSH
55970: LD_INT 52
55972: PUSH
55973: LD_INT 48
55975: PUSH
55976: LD_INT 8
55978: PUSH
55979: EMPTY
55980: LIST
55981: LIST
55982: LIST
55983: LIST
55984: LIST
55985: LIST
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: LIST
55991: LIST
55992: LIST
55993: LIST
55994: LIST
55995: LIST
55996: LIST
55997: IN
55998: NOT
55999: AND
56000: IFFALSE 56041
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
56002: LD_ADDR_EXP 121
56006: PUSH
56007: LD_EXP 121
56011: PPUSH
56012: LD_VAR 0 4
56016: PPUSH
56017: LD_EXP 121
56021: PUSH
56022: LD_VAR 0 4
56026: ARRAY
56027: PUSH
56028: LD_VAR 0 1
56032: ADD
56033: PPUSH
56034: CALL_OW 1
56038: ST_TO_ADDR
56039: GO 56085
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
56041: LD_ADDR_EXP 118
56045: PUSH
56046: LD_EXP 118
56050: PPUSH
56051: LD_VAR 0 4
56055: PUSH
56056: LD_EXP 118
56060: PUSH
56061: LD_VAR 0 4
56065: ARRAY
56066: PUSH
56067: LD_INT 1
56069: PLUS
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: PPUSH
56075: LD_VAR 0 1
56079: PPUSH
56080: CALL 66187 0 3
56084: ST_TO_ADDR
// if not mc_scan [ i ] then
56085: LD_EXP 122
56089: PUSH
56090: LD_VAR 0 4
56094: ARRAY
56095: NOT
56096: IFFALSE 56215
// begin if GetControl ( vehicle ) = control_remote then
56098: LD_VAR 0 1
56102: PPUSH
56103: CALL_OW 263
56107: PUSH
56108: LD_INT 2
56110: EQUAL
56111: IFFALSE 56131
// repeat wait ( 0 0$1 ) ;
56113: LD_INT 35
56115: PPUSH
56116: CALL_OW 67
// until IsControledBy ( vehicle ) ;
56120: LD_VAR 0 1
56124: PPUSH
56125: CALL_OW 312
56129: IFFALSE 56113
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
56131: LD_VAR 0 1
56135: PPUSH
56136: LD_EXP 123
56140: PUSH
56141: LD_VAR 0 4
56145: ARRAY
56146: PPUSH
56147: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
56151: LD_VAR 0 1
56155: PPUSH
56156: CALL_OW 263
56160: PUSH
56161: LD_INT 1
56163: NONEQUAL
56164: IFFALSE 56168
// break ;
56166: GO 56217
// repeat wait ( 0 0$1 ) ;
56168: LD_INT 35
56170: PPUSH
56171: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
56175: LD_VAR 0 1
56179: PPUSH
56180: LD_EXP 123
56184: PUSH
56185: LD_VAR 0 4
56189: ARRAY
56190: PPUSH
56191: CALL_OW 308
56195: IFFALSE 56168
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
56197: LD_VAR 0 1
56201: PPUSH
56202: CALL_OW 311
56206: PPUSH
56207: CALL_OW 121
// exit ;
56211: POP
56212: POP
56213: GO 56219
// end ; end ; end ;
56215: GO 55866
56217: POP
56218: POP
// end ;
56219: LD_VAR 0 3
56223: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
56224: LD_INT 0
56226: PPUSH
56227: PPUSH
56228: PPUSH
56229: PPUSH
// if not mc_bases or not skirmish then
56230: LD_EXP 99
56234: NOT
56235: PUSH
56236: LD_EXP 97
56240: NOT
56241: OR
56242: IFFALSE 56246
// exit ;
56244: GO 56599
// repeat wait ( 0 0$1 ) ;
56246: LD_INT 35
56248: PPUSH
56249: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
56253: LD_VAR 0 2
56257: PPUSH
56258: LD_VAR 0 3
56262: PPUSH
56263: CALL_OW 284
56267: IFFALSE 56246
// if GetResourceTypeXY ( x , y ) = mat_artefact then
56269: LD_VAR 0 2
56273: PPUSH
56274: LD_VAR 0 3
56278: PPUSH
56279: CALL_OW 283
56283: PUSH
56284: LD_INT 4
56286: EQUAL
56287: IFFALSE 56291
// exit ;
56289: GO 56599
// for i = 1 to mc_bases do
56291: LD_ADDR_VAR 0 7
56295: PUSH
56296: DOUBLE
56297: LD_INT 1
56299: DEC
56300: ST_TO_ADDR
56301: LD_EXP 99
56305: PUSH
56306: FOR_TO
56307: IFFALSE 56597
// begin if mc_crates_area [ i ] then
56309: LD_EXP 117
56313: PUSH
56314: LD_VAR 0 7
56318: ARRAY
56319: IFFALSE 56430
// for j in mc_crates_area [ i ] do
56321: LD_ADDR_VAR 0 8
56325: PUSH
56326: LD_EXP 117
56330: PUSH
56331: LD_VAR 0 7
56335: ARRAY
56336: PUSH
56337: FOR_IN
56338: IFFALSE 56428
// if InArea ( x , y , j ) then
56340: LD_VAR 0 2
56344: PPUSH
56345: LD_VAR 0 3
56349: PPUSH
56350: LD_VAR 0 8
56354: PPUSH
56355: CALL_OW 309
56359: IFFALSE 56426
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
56361: LD_ADDR_EXP 115
56365: PUSH
56366: LD_EXP 115
56370: PPUSH
56371: LD_VAR 0 7
56375: PUSH
56376: LD_EXP 115
56380: PUSH
56381: LD_VAR 0 7
56385: ARRAY
56386: PUSH
56387: LD_INT 1
56389: PLUS
56390: PUSH
56391: EMPTY
56392: LIST
56393: LIST
56394: PPUSH
56395: LD_VAR 0 4
56399: PUSH
56400: LD_VAR 0 2
56404: PUSH
56405: LD_VAR 0 3
56409: PUSH
56410: EMPTY
56411: LIST
56412: LIST
56413: LIST
56414: PPUSH
56415: CALL 66187 0 3
56419: ST_TO_ADDR
// exit ;
56420: POP
56421: POP
56422: POP
56423: POP
56424: GO 56599
// end ;
56426: GO 56337
56428: POP
56429: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56430: LD_ADDR_VAR 0 9
56434: PUSH
56435: LD_EXP 99
56439: PUSH
56440: LD_VAR 0 7
56444: ARRAY
56445: PPUSH
56446: LD_INT 2
56448: PUSH
56449: LD_INT 30
56451: PUSH
56452: LD_INT 0
56454: PUSH
56455: EMPTY
56456: LIST
56457: LIST
56458: PUSH
56459: LD_INT 30
56461: PUSH
56462: LD_INT 1
56464: PUSH
56465: EMPTY
56466: LIST
56467: LIST
56468: PUSH
56469: EMPTY
56470: LIST
56471: LIST
56472: LIST
56473: PPUSH
56474: CALL_OW 72
56478: ST_TO_ADDR
// if not depot then
56479: LD_VAR 0 9
56483: NOT
56484: IFFALSE 56488
// continue ;
56486: GO 56306
// for j in depot do
56488: LD_ADDR_VAR 0 8
56492: PUSH
56493: LD_VAR 0 9
56497: PUSH
56498: FOR_IN
56499: IFFALSE 56593
// if GetDistUnitXY ( j , x , y ) < 30 then
56501: LD_VAR 0 8
56505: PPUSH
56506: LD_VAR 0 2
56510: PPUSH
56511: LD_VAR 0 3
56515: PPUSH
56516: CALL_OW 297
56520: PUSH
56521: LD_INT 30
56523: LESS
56524: IFFALSE 56591
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
56526: LD_ADDR_EXP 115
56530: PUSH
56531: LD_EXP 115
56535: PPUSH
56536: LD_VAR 0 7
56540: PUSH
56541: LD_EXP 115
56545: PUSH
56546: LD_VAR 0 7
56550: ARRAY
56551: PUSH
56552: LD_INT 1
56554: PLUS
56555: PUSH
56556: EMPTY
56557: LIST
56558: LIST
56559: PPUSH
56560: LD_VAR 0 4
56564: PUSH
56565: LD_VAR 0 2
56569: PUSH
56570: LD_VAR 0 3
56574: PUSH
56575: EMPTY
56576: LIST
56577: LIST
56578: LIST
56579: PPUSH
56580: CALL 66187 0 3
56584: ST_TO_ADDR
// exit ;
56585: POP
56586: POP
56587: POP
56588: POP
56589: GO 56599
// end ;
56591: GO 56498
56593: POP
56594: POP
// end ;
56595: GO 56306
56597: POP
56598: POP
// end ;
56599: LD_VAR 0 6
56603: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
56604: LD_INT 0
56606: PPUSH
56607: PPUSH
56608: PPUSH
56609: PPUSH
// if not mc_bases or not skirmish then
56610: LD_EXP 99
56614: NOT
56615: PUSH
56616: LD_EXP 97
56620: NOT
56621: OR
56622: IFFALSE 56626
// exit ;
56624: GO 56903
// side := GetSide ( lab ) ;
56626: LD_ADDR_VAR 0 4
56630: PUSH
56631: LD_VAR 0 2
56635: PPUSH
56636: CALL_OW 255
56640: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
56641: LD_VAR 0 4
56645: PUSH
56646: LD_EXP 125
56650: IN
56651: NOT
56652: PUSH
56653: LD_EXP 126
56657: NOT
56658: OR
56659: PUSH
56660: LD_EXP 99
56664: NOT
56665: OR
56666: IFFALSE 56670
// exit ;
56668: GO 56903
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
56670: LD_ADDR_EXP 126
56674: PUSH
56675: LD_EXP 126
56679: PPUSH
56680: LD_VAR 0 4
56684: PPUSH
56685: LD_EXP 126
56689: PUSH
56690: LD_VAR 0 4
56694: ARRAY
56695: PUSH
56696: LD_VAR 0 1
56700: DIFF
56701: PPUSH
56702: CALL_OW 1
56706: ST_TO_ADDR
// for i = 1 to mc_bases do
56707: LD_ADDR_VAR 0 5
56711: PUSH
56712: DOUBLE
56713: LD_INT 1
56715: DEC
56716: ST_TO_ADDR
56717: LD_EXP 99
56721: PUSH
56722: FOR_TO
56723: IFFALSE 56901
// begin if lab in mc_bases [ i ] then
56725: LD_VAR 0 2
56729: PUSH
56730: LD_EXP 99
56734: PUSH
56735: LD_VAR 0 5
56739: ARRAY
56740: IN
56741: IFFALSE 56899
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
56743: LD_VAR 0 1
56747: PUSH
56748: LD_INT 11
56750: PUSH
56751: LD_INT 4
56753: PUSH
56754: LD_INT 3
56756: PUSH
56757: LD_INT 2
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: LIST
56764: LIST
56765: IN
56766: PUSH
56767: LD_EXP 129
56771: PUSH
56772: LD_VAR 0 5
56776: ARRAY
56777: AND
56778: IFFALSE 56899
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
56780: LD_ADDR_VAR 0 6
56784: PUSH
56785: LD_EXP 129
56789: PUSH
56790: LD_VAR 0 5
56794: ARRAY
56795: PUSH
56796: LD_INT 1
56798: ARRAY
56799: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
56800: LD_ADDR_EXP 129
56804: PUSH
56805: LD_EXP 129
56809: PPUSH
56810: LD_VAR 0 5
56814: PPUSH
56815: EMPTY
56816: PPUSH
56817: CALL_OW 1
56821: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
56822: LD_VAR 0 6
56826: PPUSH
56827: LD_INT 0
56829: PPUSH
56830: CALL_OW 109
// ComExitBuilding ( tmp ) ;
56834: LD_VAR 0 6
56838: PPUSH
56839: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
56843: LD_ADDR_EXP 128
56847: PUSH
56848: LD_EXP 128
56852: PPUSH
56853: LD_VAR 0 5
56857: PPUSH
56858: LD_EXP 128
56862: PUSH
56863: LD_VAR 0 5
56867: ARRAY
56868: PPUSH
56869: LD_INT 1
56871: PPUSH
56872: LD_VAR 0 6
56876: PPUSH
56877: CALL_OW 2
56881: PPUSH
56882: CALL_OW 1
56886: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
56887: LD_VAR 0 5
56891: PPUSH
56892: LD_INT 112
56894: PPUSH
56895: CALL 34659 0 2
// end ; end ; end ;
56899: GO 56722
56901: POP
56902: POP
// end ;
56903: LD_VAR 0 3
56907: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
56908: LD_INT 0
56910: PPUSH
56911: PPUSH
56912: PPUSH
56913: PPUSH
56914: PPUSH
56915: PPUSH
56916: PPUSH
56917: PPUSH
// if not mc_bases or not skirmish then
56918: LD_EXP 99
56922: NOT
56923: PUSH
56924: LD_EXP 97
56928: NOT
56929: OR
56930: IFFALSE 56934
// exit ;
56932: GO 57877
// for i = 1 to mc_bases do
56934: LD_ADDR_VAR 0 3
56938: PUSH
56939: DOUBLE
56940: LD_INT 1
56942: DEC
56943: ST_TO_ADDR
56944: LD_EXP 99
56948: PUSH
56949: FOR_TO
56950: IFFALSE 57875
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
56952: LD_VAR 0 1
56956: PUSH
56957: LD_EXP 99
56961: PUSH
56962: LD_VAR 0 3
56966: ARRAY
56967: IN
56968: PUSH
56969: LD_VAR 0 1
56973: PUSH
56974: LD_EXP 106
56978: PUSH
56979: LD_VAR 0 3
56983: ARRAY
56984: IN
56985: OR
56986: PUSH
56987: LD_VAR 0 1
56991: PUSH
56992: LD_EXP 118
56996: PUSH
56997: LD_VAR 0 3
57001: ARRAY
57002: IN
57003: OR
57004: PUSH
57005: LD_VAR 0 1
57009: PUSH
57010: LD_EXP 128
57014: PUSH
57015: LD_VAR 0 3
57019: ARRAY
57020: IN
57021: OR
57022: PUSH
57023: LD_VAR 0 1
57027: PUSH
57028: LD_EXP 129
57032: PUSH
57033: LD_VAR 0 3
57037: ARRAY
57038: IN
57039: OR
57040: IFFALSE 57873
// begin if un in mc_ape [ i ] then
57042: LD_VAR 0 1
57046: PUSH
57047: LD_EXP 128
57051: PUSH
57052: LD_VAR 0 3
57056: ARRAY
57057: IN
57058: IFFALSE 57097
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
57060: LD_ADDR_EXP 128
57064: PUSH
57065: LD_EXP 128
57069: PPUSH
57070: LD_VAR 0 3
57074: PPUSH
57075: LD_EXP 128
57079: PUSH
57080: LD_VAR 0 3
57084: ARRAY
57085: PUSH
57086: LD_VAR 0 1
57090: DIFF
57091: PPUSH
57092: CALL_OW 1
57096: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
57097: LD_VAR 0 1
57101: PUSH
57102: LD_EXP 129
57106: PUSH
57107: LD_VAR 0 3
57111: ARRAY
57112: IN
57113: IFFALSE 57137
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57115: LD_ADDR_EXP 129
57119: PUSH
57120: LD_EXP 129
57124: PPUSH
57125: LD_VAR 0 3
57129: PPUSH
57130: EMPTY
57131: PPUSH
57132: CALL_OW 1
57136: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and GetTag ( un ) = 20 then
57137: LD_VAR 0 1
57141: PPUSH
57142: CALL_OW 247
57146: PUSH
57147: LD_INT 2
57149: EQUAL
57150: PUSH
57151: LD_VAR 0 1
57155: PPUSH
57156: CALL_OW 110
57160: PUSH
57161: LD_INT 20
57163: EQUAL
57164: AND
57165: IFFALSE 57268
// begin fac := MC_GetBuilding ( i , b_factory ) ;
57167: LD_ADDR_VAR 0 8
57171: PUSH
57172: LD_VAR 0 3
57176: PPUSH
57177: LD_INT 3
57179: PPUSH
57180: CALL 53967 0 2
57184: ST_TO_ADDR
// if fac then
57185: LD_VAR 0 8
57189: IFFALSE 57268
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
57191: LD_ADDR_VAR 0 9
57195: PUSH
57196: LD_VAR 0 8
57200: PPUSH
57201: LD_VAR 0 1
57205: PPUSH
57206: CALL_OW 265
57210: PPUSH
57211: LD_VAR 0 1
57215: PPUSH
57216: CALL_OW 262
57220: PPUSH
57221: LD_VAR 0 1
57225: PPUSH
57226: CALL_OW 263
57230: PPUSH
57231: LD_VAR 0 1
57235: PPUSH
57236: CALL_OW 264
57240: PPUSH
57241: CALL 63787 0 5
57245: ST_TO_ADDR
// if components then
57246: LD_VAR 0 9
57250: IFFALSE 57266
// MC_InsertProduceList ( i , components ) ;
57252: LD_VAR 0 3
57256: PPUSH
57257: LD_VAR 0 9
57261: PPUSH
57262: CALL 53537 0 2
// break ;
57266: GO 57875
// end ; end ; if GetType ( un ) = unit_building then
57268: LD_VAR 0 1
57272: PPUSH
57273: CALL_OW 247
57277: PUSH
57278: LD_INT 3
57280: EQUAL
57281: IFFALSE 57596
// begin btype := GetBType ( un ) ;
57283: LD_ADDR_VAR 0 5
57287: PUSH
57288: LD_VAR 0 1
57292: PPUSH
57293: CALL_OW 266
57297: ST_TO_ADDR
// if btype = b_warehouse then
57298: LD_VAR 0 5
57302: PUSH
57303: LD_INT 1
57305: EQUAL
57306: IFFALSE 57324
// begin btype := b_depot ;
57308: LD_ADDR_VAR 0 5
57312: PUSH
57313: LD_INT 0
57315: ST_TO_ADDR
// pos := 1 ;
57316: LD_ADDR_VAR 0 6
57320: PUSH
57321: LD_INT 1
57323: ST_TO_ADDR
// end ; if btype = b_factory then
57324: LD_VAR 0 5
57328: PUSH
57329: LD_INT 3
57331: EQUAL
57332: IFFALSE 57350
// begin btype := b_workshop ;
57334: LD_ADDR_VAR 0 5
57338: PUSH
57339: LD_INT 2
57341: ST_TO_ADDR
// pos := 1 ;
57342: LD_ADDR_VAR 0 6
57346: PUSH
57347: LD_INT 1
57349: ST_TO_ADDR
// end ; if btype = b_barracks then
57350: LD_VAR 0 5
57354: PUSH
57355: LD_INT 5
57357: EQUAL
57358: IFFALSE 57368
// btype := b_armoury ;
57360: LD_ADDR_VAR 0 5
57364: PUSH
57365: LD_INT 4
57367: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
57368: LD_VAR 0 5
57372: PUSH
57373: LD_INT 7
57375: PUSH
57376: LD_INT 8
57378: PUSH
57379: EMPTY
57380: LIST
57381: LIST
57382: IN
57383: IFFALSE 57393
// btype := b_lab ;
57385: LD_ADDR_VAR 0 5
57389: PUSH
57390: LD_INT 6
57392: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
57393: LD_ADDR_EXP 104
57397: PUSH
57398: LD_EXP 104
57402: PPUSH
57403: LD_VAR 0 3
57407: PUSH
57408: LD_EXP 104
57412: PUSH
57413: LD_VAR 0 3
57417: ARRAY
57418: PUSH
57419: LD_INT 1
57421: PLUS
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: PPUSH
57427: LD_VAR 0 5
57431: PUSH
57432: LD_VAR 0 1
57436: PPUSH
57437: CALL_OW 250
57441: PUSH
57442: LD_VAR 0 1
57446: PPUSH
57447: CALL_OW 251
57451: PUSH
57452: LD_VAR 0 1
57456: PPUSH
57457: CALL_OW 254
57461: PUSH
57462: EMPTY
57463: LIST
57464: LIST
57465: LIST
57466: LIST
57467: PPUSH
57468: CALL 66187 0 3
57472: ST_TO_ADDR
// if pos = 1 then
57473: LD_VAR 0 6
57477: PUSH
57478: LD_INT 1
57480: EQUAL
57481: IFFALSE 57596
// begin tmp := mc_build_list [ i ] ;
57483: LD_ADDR_VAR 0 7
57487: PUSH
57488: LD_EXP 104
57492: PUSH
57493: LD_VAR 0 3
57497: ARRAY
57498: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
57499: LD_VAR 0 7
57503: PPUSH
57504: LD_INT 2
57506: PUSH
57507: LD_INT 30
57509: PUSH
57510: LD_INT 0
57512: PUSH
57513: EMPTY
57514: LIST
57515: LIST
57516: PUSH
57517: LD_INT 30
57519: PUSH
57520: LD_INT 1
57522: PUSH
57523: EMPTY
57524: LIST
57525: LIST
57526: PUSH
57527: EMPTY
57528: LIST
57529: LIST
57530: LIST
57531: PPUSH
57532: CALL_OW 72
57536: IFFALSE 57546
// pos := 2 ;
57538: LD_ADDR_VAR 0 6
57542: PUSH
57543: LD_INT 2
57545: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
57546: LD_ADDR_VAR 0 7
57550: PUSH
57551: LD_VAR 0 7
57555: PPUSH
57556: LD_VAR 0 6
57560: PPUSH
57561: LD_VAR 0 7
57565: PPUSH
57566: CALL 66513 0 3
57570: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
57571: LD_ADDR_EXP 104
57575: PUSH
57576: LD_EXP 104
57580: PPUSH
57581: LD_VAR 0 3
57585: PPUSH
57586: LD_VAR 0 7
57590: PPUSH
57591: CALL_OW 1
57595: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
57596: LD_VAR 0 1
57600: PUSH
57601: LD_EXP 99
57605: PUSH
57606: LD_VAR 0 3
57610: ARRAY
57611: IN
57612: IFFALSE 57651
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
57614: LD_ADDR_EXP 99
57618: PUSH
57619: LD_EXP 99
57623: PPUSH
57624: LD_VAR 0 3
57628: PPUSH
57629: LD_EXP 99
57633: PUSH
57634: LD_VAR 0 3
57638: ARRAY
57639: PUSH
57640: LD_VAR 0 1
57644: DIFF
57645: PPUSH
57646: CALL_OW 1
57650: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
57651: LD_VAR 0 1
57655: PUSH
57656: LD_EXP 106
57660: PUSH
57661: LD_VAR 0 3
57665: ARRAY
57666: IN
57667: IFFALSE 57706
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
57669: LD_ADDR_EXP 106
57673: PUSH
57674: LD_EXP 106
57678: PPUSH
57679: LD_VAR 0 3
57683: PPUSH
57684: LD_EXP 106
57688: PUSH
57689: LD_VAR 0 3
57693: ARRAY
57694: PUSH
57695: LD_VAR 0 1
57699: DIFF
57700: PPUSH
57701: CALL_OW 1
57705: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
57706: LD_VAR 0 1
57710: PUSH
57711: LD_EXP 118
57715: PUSH
57716: LD_VAR 0 3
57720: ARRAY
57721: IN
57722: IFFALSE 57761
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
57724: LD_ADDR_EXP 118
57728: PUSH
57729: LD_EXP 118
57733: PPUSH
57734: LD_VAR 0 3
57738: PPUSH
57739: LD_EXP 118
57743: PUSH
57744: LD_VAR 0 3
57748: ARRAY
57749: PUSH
57750: LD_VAR 0 1
57754: DIFF
57755: PPUSH
57756: CALL_OW 1
57760: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
57761: LD_VAR 0 1
57765: PUSH
57766: LD_EXP 108
57770: PUSH
57771: LD_VAR 0 3
57775: ARRAY
57776: IN
57777: IFFALSE 57816
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
57779: LD_ADDR_EXP 108
57783: PUSH
57784: LD_EXP 108
57788: PPUSH
57789: LD_VAR 0 3
57793: PPUSH
57794: LD_EXP 108
57798: PUSH
57799: LD_VAR 0 3
57803: ARRAY
57804: PUSH
57805: LD_VAR 0 1
57809: DIFF
57810: PPUSH
57811: CALL_OW 1
57815: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
57816: LD_VAR 0 1
57820: PUSH
57821: LD_EXP 107
57825: PUSH
57826: LD_VAR 0 3
57830: ARRAY
57831: IN
57832: IFFALSE 57871
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
57834: LD_ADDR_EXP 107
57838: PUSH
57839: LD_EXP 107
57843: PPUSH
57844: LD_VAR 0 3
57848: PPUSH
57849: LD_EXP 107
57853: PUSH
57854: LD_VAR 0 3
57858: ARRAY
57859: PUSH
57860: LD_VAR 0 1
57864: DIFF
57865: PPUSH
57866: CALL_OW 1
57870: ST_TO_ADDR
// end ; break ;
57871: GO 57875
// end ;
57873: GO 56949
57875: POP
57876: POP
// end ;
57877: LD_VAR 0 2
57881: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
57882: LD_INT 0
57884: PPUSH
57885: PPUSH
57886: PPUSH
// if not mc_bases or not skirmish then
57887: LD_EXP 99
57891: NOT
57892: PUSH
57893: LD_EXP 97
57897: NOT
57898: OR
57899: IFFALSE 57903
// exit ;
57901: GO 58118
// for i = 1 to mc_bases do
57903: LD_ADDR_VAR 0 3
57907: PUSH
57908: DOUBLE
57909: LD_INT 1
57911: DEC
57912: ST_TO_ADDR
57913: LD_EXP 99
57917: PUSH
57918: FOR_TO
57919: IFFALSE 58116
// begin if building in mc_construct_list [ i ] then
57921: LD_VAR 0 1
57925: PUSH
57926: LD_EXP 106
57930: PUSH
57931: LD_VAR 0 3
57935: ARRAY
57936: IN
57937: IFFALSE 58114
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
57939: LD_ADDR_EXP 106
57943: PUSH
57944: LD_EXP 106
57948: PPUSH
57949: LD_VAR 0 3
57953: PPUSH
57954: LD_EXP 106
57958: PUSH
57959: LD_VAR 0 3
57963: ARRAY
57964: PUSH
57965: LD_VAR 0 1
57969: DIFF
57970: PPUSH
57971: CALL_OW 1
57975: ST_TO_ADDR
// if building in mc_lab [ i ] then
57976: LD_VAR 0 1
57980: PUSH
57981: LD_EXP 132
57985: PUSH
57986: LD_VAR 0 3
57990: ARRAY
57991: IN
57992: IFFALSE 58047
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
57994: LD_ADDR_EXP 133
57998: PUSH
57999: LD_EXP 133
58003: PPUSH
58004: LD_VAR 0 3
58008: PPUSH
58009: LD_EXP 133
58013: PUSH
58014: LD_VAR 0 3
58018: ARRAY
58019: PPUSH
58020: LD_INT 1
58022: PPUSH
58023: LD_EXP 133
58027: PUSH
58028: LD_VAR 0 3
58032: ARRAY
58033: PPUSH
58034: LD_INT 0
58036: PPUSH
58037: CALL 65605 0 4
58041: PPUSH
58042: CALL_OW 1
58046: ST_TO_ADDR
// if not building in mc_bases [ i ] then
58047: LD_VAR 0 1
58051: PUSH
58052: LD_EXP 99
58056: PUSH
58057: LD_VAR 0 3
58061: ARRAY
58062: IN
58063: NOT
58064: IFFALSE 58110
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
58066: LD_ADDR_EXP 99
58070: PUSH
58071: LD_EXP 99
58075: PPUSH
58076: LD_VAR 0 3
58080: PUSH
58081: LD_EXP 99
58085: PUSH
58086: LD_VAR 0 3
58090: ARRAY
58091: PUSH
58092: LD_INT 1
58094: PLUS
58095: PUSH
58096: EMPTY
58097: LIST
58098: LIST
58099: PPUSH
58100: LD_VAR 0 1
58104: PPUSH
58105: CALL 66187 0 3
58109: ST_TO_ADDR
// exit ;
58110: POP
58111: POP
58112: GO 58118
// end ; end ;
58114: GO 57918
58116: POP
58117: POP
// end ;
58118: LD_VAR 0 2
58122: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
58123: LD_INT 0
58125: PPUSH
58126: PPUSH
58127: PPUSH
58128: PPUSH
58129: PPUSH
58130: PPUSH
58131: PPUSH
// if not mc_bases or not skirmish then
58132: LD_EXP 99
58136: NOT
58137: PUSH
58138: LD_EXP 97
58142: NOT
58143: OR
58144: IFFALSE 58148
// exit ;
58146: GO 58809
// for i = 1 to mc_bases do
58148: LD_ADDR_VAR 0 3
58152: PUSH
58153: DOUBLE
58154: LD_INT 1
58156: DEC
58157: ST_TO_ADDR
58158: LD_EXP 99
58162: PUSH
58163: FOR_TO
58164: IFFALSE 58807
// begin if building in mc_construct_list [ i ] then
58166: LD_VAR 0 1
58170: PUSH
58171: LD_EXP 106
58175: PUSH
58176: LD_VAR 0 3
58180: ARRAY
58181: IN
58182: IFFALSE 58805
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
58184: LD_ADDR_EXP 106
58188: PUSH
58189: LD_EXP 106
58193: PPUSH
58194: LD_VAR 0 3
58198: PPUSH
58199: LD_EXP 106
58203: PUSH
58204: LD_VAR 0 3
58208: ARRAY
58209: PUSH
58210: LD_VAR 0 1
58214: DIFF
58215: PPUSH
58216: CALL_OW 1
58220: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
58221: LD_ADDR_EXP 99
58225: PUSH
58226: LD_EXP 99
58230: PPUSH
58231: LD_VAR 0 3
58235: PUSH
58236: LD_EXP 99
58240: PUSH
58241: LD_VAR 0 3
58245: ARRAY
58246: PUSH
58247: LD_INT 1
58249: PLUS
58250: PUSH
58251: EMPTY
58252: LIST
58253: LIST
58254: PPUSH
58255: LD_VAR 0 1
58259: PPUSH
58260: CALL 66187 0 3
58264: ST_TO_ADDR
// btype := GetBType ( building ) ;
58265: LD_ADDR_VAR 0 5
58269: PUSH
58270: LD_VAR 0 1
58274: PPUSH
58275: CALL_OW 266
58279: ST_TO_ADDR
// side := GetSide ( building ) ;
58280: LD_ADDR_VAR 0 8
58284: PUSH
58285: LD_VAR 0 1
58289: PPUSH
58290: CALL_OW 255
58294: ST_TO_ADDR
// if btype = b_lab then
58295: LD_VAR 0 5
58299: PUSH
58300: LD_INT 6
58302: EQUAL
58303: IFFALSE 58353
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
58305: LD_ADDR_EXP 132
58309: PUSH
58310: LD_EXP 132
58314: PPUSH
58315: LD_VAR 0 3
58319: PUSH
58320: LD_EXP 132
58324: PUSH
58325: LD_VAR 0 3
58329: ARRAY
58330: PUSH
58331: LD_INT 1
58333: PLUS
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PPUSH
58339: LD_VAR 0 1
58343: PPUSH
58344: CALL 66187 0 3
58348: ST_TO_ADDR
// exit ;
58349: POP
58350: POP
58351: GO 58809
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
58353: LD_VAR 0 5
58357: PUSH
58358: LD_INT 0
58360: PUSH
58361: LD_INT 2
58363: PUSH
58364: LD_INT 4
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: LIST
58371: IN
58372: IFFALSE 58496
// begin if btype = b_armoury then
58374: LD_VAR 0 5
58378: PUSH
58379: LD_INT 4
58381: EQUAL
58382: IFFALSE 58392
// btype := b_barracks ;
58384: LD_ADDR_VAR 0 5
58388: PUSH
58389: LD_INT 5
58391: ST_TO_ADDR
// if btype = b_depot then
58392: LD_VAR 0 5
58396: PUSH
58397: LD_INT 0
58399: EQUAL
58400: IFFALSE 58410
// btype := b_warehouse ;
58402: LD_ADDR_VAR 0 5
58406: PUSH
58407: LD_INT 1
58409: ST_TO_ADDR
// if btype = b_workshop then
58410: LD_VAR 0 5
58414: PUSH
58415: LD_INT 2
58417: EQUAL
58418: IFFALSE 58428
// btype := b_factory ;
58420: LD_ADDR_VAR 0 5
58424: PUSH
58425: LD_INT 3
58427: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
58428: LD_VAR 0 5
58432: PPUSH
58433: LD_VAR 0 8
58437: PPUSH
58438: CALL_OW 323
58442: PUSH
58443: LD_INT 1
58445: EQUAL
58446: IFFALSE 58492
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
58448: LD_ADDR_EXP 131
58452: PUSH
58453: LD_EXP 131
58457: PPUSH
58458: LD_VAR 0 3
58462: PUSH
58463: LD_EXP 131
58467: PUSH
58468: LD_VAR 0 3
58472: ARRAY
58473: PUSH
58474: LD_INT 1
58476: PLUS
58477: PUSH
58478: EMPTY
58479: LIST
58480: LIST
58481: PPUSH
58482: LD_VAR 0 1
58486: PPUSH
58487: CALL 66187 0 3
58491: ST_TO_ADDR
// exit ;
58492: POP
58493: POP
58494: GO 58809
// end ; if btype in [ b_bunker , b_turret ] then
58496: LD_VAR 0 5
58500: PUSH
58501: LD_INT 32
58503: PUSH
58504: LD_INT 33
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: IN
58511: IFFALSE 58801
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
58513: LD_ADDR_EXP 107
58517: PUSH
58518: LD_EXP 107
58522: PPUSH
58523: LD_VAR 0 3
58527: PUSH
58528: LD_EXP 107
58532: PUSH
58533: LD_VAR 0 3
58537: ARRAY
58538: PUSH
58539: LD_INT 1
58541: PLUS
58542: PUSH
58543: EMPTY
58544: LIST
58545: LIST
58546: PPUSH
58547: LD_VAR 0 1
58551: PPUSH
58552: CALL 66187 0 3
58556: ST_TO_ADDR
// if btype = b_bunker then
58557: LD_VAR 0 5
58561: PUSH
58562: LD_INT 32
58564: EQUAL
58565: IFFALSE 58801
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
58567: LD_ADDR_EXP 108
58571: PUSH
58572: LD_EXP 108
58576: PPUSH
58577: LD_VAR 0 3
58581: PUSH
58582: LD_EXP 108
58586: PUSH
58587: LD_VAR 0 3
58591: ARRAY
58592: PUSH
58593: LD_INT 1
58595: PLUS
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: PPUSH
58601: LD_VAR 0 1
58605: PPUSH
58606: CALL 66187 0 3
58610: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
58611: LD_ADDR_VAR 0 6
58615: PUSH
58616: LD_EXP 99
58620: PUSH
58621: LD_VAR 0 3
58625: ARRAY
58626: PPUSH
58627: LD_INT 25
58629: PUSH
58630: LD_INT 1
58632: PUSH
58633: EMPTY
58634: LIST
58635: LIST
58636: PUSH
58637: LD_INT 3
58639: PUSH
58640: LD_INT 54
58642: PUSH
58643: EMPTY
58644: LIST
58645: PUSH
58646: EMPTY
58647: LIST
58648: LIST
58649: PUSH
58650: EMPTY
58651: LIST
58652: LIST
58653: PPUSH
58654: CALL_OW 72
58658: ST_TO_ADDR
// if tmp then
58659: LD_VAR 0 6
58663: IFFALSE 58669
// exit ;
58665: POP
58666: POP
58667: GO 58809
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58669: LD_ADDR_VAR 0 6
58673: PUSH
58674: LD_EXP 99
58678: PUSH
58679: LD_VAR 0 3
58683: ARRAY
58684: PPUSH
58685: LD_INT 2
58687: PUSH
58688: LD_INT 30
58690: PUSH
58691: LD_INT 4
58693: PUSH
58694: EMPTY
58695: LIST
58696: LIST
58697: PUSH
58698: LD_INT 30
58700: PUSH
58701: LD_INT 5
58703: PUSH
58704: EMPTY
58705: LIST
58706: LIST
58707: PUSH
58708: EMPTY
58709: LIST
58710: LIST
58711: LIST
58712: PPUSH
58713: CALL_OW 72
58717: ST_TO_ADDR
// if not tmp then
58718: LD_VAR 0 6
58722: NOT
58723: IFFALSE 58729
// exit ;
58725: POP
58726: POP
58727: GO 58809
// for j in tmp do
58729: LD_ADDR_VAR 0 4
58733: PUSH
58734: LD_VAR 0 6
58738: PUSH
58739: FOR_IN
58740: IFFALSE 58799
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
58742: LD_ADDR_VAR 0 7
58746: PUSH
58747: LD_VAR 0 4
58751: PPUSH
58752: CALL_OW 313
58756: PPUSH
58757: LD_INT 25
58759: PUSH
58760: LD_INT 1
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: PPUSH
58767: CALL_OW 72
58771: ST_TO_ADDR
// if units then
58772: LD_VAR 0 7
58776: IFFALSE 58797
// begin ComExitBuilding ( units [ 1 ] ) ;
58778: LD_VAR 0 7
58782: PUSH
58783: LD_INT 1
58785: ARRAY
58786: PPUSH
58787: CALL_OW 122
// exit ;
58791: POP
58792: POP
58793: POP
58794: POP
58795: GO 58809
// end ; end ;
58797: GO 58739
58799: POP
58800: POP
// end ; end ; exit ;
58801: POP
58802: POP
58803: GO 58809
// end ; end ;
58805: GO 58163
58807: POP
58808: POP
// end ;
58809: LD_VAR 0 2
58813: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
58814: LD_INT 0
58816: PPUSH
58817: PPUSH
58818: PPUSH
58819: PPUSH
58820: PPUSH
58821: PPUSH
58822: PPUSH
// if not mc_bases or not skirmish then
58823: LD_EXP 99
58827: NOT
58828: PUSH
58829: LD_EXP 97
58833: NOT
58834: OR
58835: IFFALSE 58839
// exit ;
58837: GO 59070
// btype := GetBType ( building ) ;
58839: LD_ADDR_VAR 0 6
58843: PUSH
58844: LD_VAR 0 1
58848: PPUSH
58849: CALL_OW 266
58853: ST_TO_ADDR
// x := GetX ( building ) ;
58854: LD_ADDR_VAR 0 7
58858: PUSH
58859: LD_VAR 0 1
58863: PPUSH
58864: CALL_OW 250
58868: ST_TO_ADDR
// y := GetY ( building ) ;
58869: LD_ADDR_VAR 0 8
58873: PUSH
58874: LD_VAR 0 1
58878: PPUSH
58879: CALL_OW 251
58883: ST_TO_ADDR
// d := GetDir ( building ) ;
58884: LD_ADDR_VAR 0 9
58888: PUSH
58889: LD_VAR 0 1
58893: PPUSH
58894: CALL_OW 254
58898: ST_TO_ADDR
// for i = 1 to mc_bases do
58899: LD_ADDR_VAR 0 4
58903: PUSH
58904: DOUBLE
58905: LD_INT 1
58907: DEC
58908: ST_TO_ADDR
58909: LD_EXP 99
58913: PUSH
58914: FOR_TO
58915: IFFALSE 59068
// begin if not mc_build_list [ i ] then
58917: LD_EXP 104
58921: PUSH
58922: LD_VAR 0 4
58926: ARRAY
58927: NOT
58928: IFFALSE 58932
// continue ;
58930: GO 58914
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
58932: LD_VAR 0 6
58936: PUSH
58937: LD_VAR 0 7
58941: PUSH
58942: LD_VAR 0 8
58946: PUSH
58947: LD_VAR 0 9
58951: PUSH
58952: EMPTY
58953: LIST
58954: LIST
58955: LIST
58956: LIST
58957: PPUSH
58958: LD_EXP 104
58962: PUSH
58963: LD_VAR 0 4
58967: ARRAY
58968: PUSH
58969: LD_INT 1
58971: ARRAY
58972: PPUSH
58973: CALL 72356 0 2
58977: IFFALSE 59066
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
58979: LD_ADDR_EXP 104
58983: PUSH
58984: LD_EXP 104
58988: PPUSH
58989: LD_VAR 0 4
58993: PPUSH
58994: LD_EXP 104
58998: PUSH
58999: LD_VAR 0 4
59003: ARRAY
59004: PPUSH
59005: LD_INT 1
59007: PPUSH
59008: CALL_OW 3
59012: PPUSH
59013: CALL_OW 1
59017: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
59018: LD_ADDR_EXP 106
59022: PUSH
59023: LD_EXP 106
59027: PPUSH
59028: LD_VAR 0 4
59032: PUSH
59033: LD_EXP 106
59037: PUSH
59038: LD_VAR 0 4
59042: ARRAY
59043: PUSH
59044: LD_INT 1
59046: PLUS
59047: PUSH
59048: EMPTY
59049: LIST
59050: LIST
59051: PPUSH
59052: LD_VAR 0 1
59056: PPUSH
59057: CALL 66187 0 3
59061: ST_TO_ADDR
// exit ;
59062: POP
59063: POP
59064: GO 59070
// end ; end ;
59066: GO 58914
59068: POP
59069: POP
// end ;
59070: LD_VAR 0 3
59074: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
59075: LD_INT 0
59077: PPUSH
59078: PPUSH
59079: PPUSH
// if not mc_bases or not skirmish then
59080: LD_EXP 99
59084: NOT
59085: PUSH
59086: LD_EXP 97
59090: NOT
59091: OR
59092: IFFALSE 59096
// exit ;
59094: GO 59286
// for i = 1 to mc_bases do
59096: LD_ADDR_VAR 0 4
59100: PUSH
59101: DOUBLE
59102: LD_INT 1
59104: DEC
59105: ST_TO_ADDR
59106: LD_EXP 99
59110: PUSH
59111: FOR_TO
59112: IFFALSE 59199
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
59114: LD_VAR 0 1
59118: PUSH
59119: LD_EXP 107
59123: PUSH
59124: LD_VAR 0 4
59128: ARRAY
59129: IN
59130: PUSH
59131: LD_VAR 0 1
59135: PUSH
59136: LD_EXP 108
59140: PUSH
59141: LD_VAR 0 4
59145: ARRAY
59146: IN
59147: NOT
59148: AND
59149: IFFALSE 59197
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
59151: LD_ADDR_EXP 108
59155: PUSH
59156: LD_EXP 108
59160: PPUSH
59161: LD_VAR 0 4
59165: PUSH
59166: LD_EXP 108
59170: PUSH
59171: LD_VAR 0 4
59175: ARRAY
59176: PUSH
59177: LD_INT 1
59179: PLUS
59180: PUSH
59181: EMPTY
59182: LIST
59183: LIST
59184: PPUSH
59185: LD_VAR 0 1
59189: PPUSH
59190: CALL 66187 0 3
59194: ST_TO_ADDR
// break ;
59195: GO 59199
// end ; end ;
59197: GO 59111
59199: POP
59200: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
59201: LD_VAR 0 1
59205: PPUSH
59206: CALL_OW 257
59210: PUSH
59211: LD_EXP 125
59215: IN
59216: PUSH
59217: LD_VAR 0 1
59221: PPUSH
59222: CALL_OW 266
59226: PUSH
59227: LD_INT 5
59229: EQUAL
59230: AND
59231: PUSH
59232: LD_VAR 0 2
59236: PPUSH
59237: CALL_OW 110
59241: PUSH
59242: LD_INT 18
59244: NONEQUAL
59245: AND
59246: IFFALSE 59286
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
59248: LD_VAR 0 2
59252: PPUSH
59253: CALL_OW 257
59257: PUSH
59258: LD_INT 5
59260: PUSH
59261: LD_INT 8
59263: PUSH
59264: LD_INT 9
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: LIST
59271: IN
59272: IFFALSE 59286
// SetClass ( unit , 1 ) ;
59274: LD_VAR 0 2
59278: PPUSH
59279: LD_INT 1
59281: PPUSH
59282: CALL_OW 336
// end ;
59286: LD_VAR 0 3
59290: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
59291: LD_INT 0
59293: PPUSH
59294: PPUSH
// if not mc_bases or not skirmish then
59295: LD_EXP 99
59299: NOT
59300: PUSH
59301: LD_EXP 97
59305: NOT
59306: OR
59307: IFFALSE 59311
// exit ;
59309: GO 59427
// if GetLives ( abandoned_vehicle ) > 250 then
59311: LD_VAR 0 2
59315: PPUSH
59316: CALL_OW 256
59320: PUSH
59321: LD_INT 250
59323: GREATER
59324: IFFALSE 59328
// exit ;
59326: GO 59427
// for i = 1 to mc_bases do
59328: LD_ADDR_VAR 0 6
59332: PUSH
59333: DOUBLE
59334: LD_INT 1
59336: DEC
59337: ST_TO_ADDR
59338: LD_EXP 99
59342: PUSH
59343: FOR_TO
59344: IFFALSE 59425
// begin if driver in mc_bases [ i ] then
59346: LD_VAR 0 1
59350: PUSH
59351: LD_EXP 99
59355: PUSH
59356: LD_VAR 0 6
59360: ARRAY
59361: IN
59362: IFFALSE 59423
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
59364: LD_VAR 0 1
59368: PPUSH
59369: LD_EXP 99
59373: PUSH
59374: LD_VAR 0 6
59378: ARRAY
59379: PPUSH
59380: LD_INT 2
59382: PUSH
59383: LD_INT 30
59385: PUSH
59386: LD_INT 0
59388: PUSH
59389: EMPTY
59390: LIST
59391: LIST
59392: PUSH
59393: LD_INT 30
59395: PUSH
59396: LD_INT 1
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: LIST
59407: PPUSH
59408: CALL_OW 72
59412: PUSH
59413: LD_INT 1
59415: ARRAY
59416: PPUSH
59417: CALL_OW 112
// break ;
59421: GO 59425
// end ; end ;
59423: GO 59343
59425: POP
59426: POP
// end ; end_of_file
59427: LD_VAR 0 5
59431: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
59432: LD_INT 0
59434: PPUSH
59435: PPUSH
// if exist_mode then
59436: LD_VAR 0 2
59440: IFFALSE 59465
// unit := CreateCharacter ( prefix & ident ) else
59442: LD_ADDR_VAR 0 5
59446: PUSH
59447: LD_VAR 0 3
59451: PUSH
59452: LD_VAR 0 1
59456: STR
59457: PPUSH
59458: CALL_OW 34
59462: ST_TO_ADDR
59463: GO 59480
// unit := NewCharacter ( ident ) ;
59465: LD_ADDR_VAR 0 5
59469: PUSH
59470: LD_VAR 0 1
59474: PPUSH
59475: CALL_OW 25
59479: ST_TO_ADDR
// result := unit ;
59480: LD_ADDR_VAR 0 4
59484: PUSH
59485: LD_VAR 0 5
59489: ST_TO_ADDR
// end ;
59490: LD_VAR 0 4
59494: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
59495: LD_INT 0
59497: PPUSH
59498: PPUSH
// if not side or not nation then
59499: LD_VAR 0 1
59503: NOT
59504: PUSH
59505: LD_VAR 0 2
59509: NOT
59510: OR
59511: IFFALSE 59515
// exit ;
59513: GO 60151
// case nation of nation_american :
59515: LD_VAR 0 2
59519: PUSH
59520: LD_INT 1
59522: DOUBLE
59523: EQUAL
59524: IFTRUE 59528
59526: GO 59698
59528: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
59529: LD_ADDR_VAR 0 4
59533: PUSH
59534: LD_INT 35
59536: PUSH
59537: LD_INT 45
59539: PUSH
59540: LD_INT 46
59542: PUSH
59543: LD_INT 47
59545: PUSH
59546: LD_INT 1
59548: PUSH
59549: LD_INT 2
59551: PUSH
59552: LD_INT 6
59554: PUSH
59555: LD_INT 15
59557: PUSH
59558: LD_INT 16
59560: PUSH
59561: LD_INT 7
59563: PUSH
59564: LD_INT 12
59566: PUSH
59567: LD_INT 13
59569: PUSH
59570: LD_INT 10
59572: PUSH
59573: LD_INT 14
59575: PUSH
59576: LD_INT 20
59578: PUSH
59579: LD_INT 21
59581: PUSH
59582: LD_INT 22
59584: PUSH
59585: LD_INT 25
59587: PUSH
59588: LD_INT 32
59590: PUSH
59591: LD_INT 27
59593: PUSH
59594: LD_INT 36
59596: PUSH
59597: LD_INT 69
59599: PUSH
59600: LD_INT 39
59602: PUSH
59603: LD_INT 34
59605: PUSH
59606: LD_INT 40
59608: PUSH
59609: LD_INT 48
59611: PUSH
59612: LD_INT 49
59614: PUSH
59615: LD_INT 50
59617: PUSH
59618: LD_INT 51
59620: PUSH
59621: LD_INT 52
59623: PUSH
59624: LD_INT 53
59626: PUSH
59627: LD_INT 54
59629: PUSH
59630: LD_INT 55
59632: PUSH
59633: LD_INT 56
59635: PUSH
59636: LD_INT 57
59638: PUSH
59639: LD_INT 58
59641: PUSH
59642: LD_INT 59
59644: PUSH
59645: LD_INT 60
59647: PUSH
59648: LD_INT 61
59650: PUSH
59651: LD_INT 62
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: LIST
59659: LIST
59660: LIST
59661: LIST
59662: LIST
59663: LIST
59664: LIST
59665: LIST
59666: LIST
59667: LIST
59668: LIST
59669: LIST
59670: LIST
59671: LIST
59672: LIST
59673: LIST
59674: LIST
59675: LIST
59676: LIST
59677: LIST
59678: LIST
59679: LIST
59680: LIST
59681: LIST
59682: LIST
59683: LIST
59684: LIST
59685: LIST
59686: LIST
59687: LIST
59688: LIST
59689: LIST
59690: LIST
59691: LIST
59692: LIST
59693: LIST
59694: LIST
59695: ST_TO_ADDR
59696: GO 60075
59698: LD_INT 2
59700: DOUBLE
59701: EQUAL
59702: IFTRUE 59706
59704: GO 59884
59706: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
59707: LD_ADDR_VAR 0 4
59711: PUSH
59712: LD_INT 35
59714: PUSH
59715: LD_INT 45
59717: PUSH
59718: LD_INT 46
59720: PUSH
59721: LD_INT 47
59723: PUSH
59724: LD_INT 70
59726: PUSH
59727: LD_INT 1
59729: PUSH
59730: LD_INT 11
59732: PUSH
59733: LD_INT 3
59735: PUSH
59736: LD_INT 4
59738: PUSH
59739: LD_INT 5
59741: PUSH
59742: LD_INT 6
59744: PUSH
59745: LD_INT 15
59747: PUSH
59748: LD_INT 18
59750: PUSH
59751: LD_INT 7
59753: PUSH
59754: LD_INT 17
59756: PUSH
59757: LD_INT 8
59759: PUSH
59760: LD_INT 20
59762: PUSH
59763: LD_INT 21
59765: PUSH
59766: LD_INT 22
59768: PUSH
59769: LD_INT 72
59771: PUSH
59772: LD_INT 26
59774: PUSH
59775: LD_INT 69
59777: PUSH
59778: LD_INT 39
59780: PUSH
59781: LD_INT 40
59783: PUSH
59784: LD_INT 41
59786: PUSH
59787: LD_INT 42
59789: PUSH
59790: LD_INT 43
59792: PUSH
59793: LD_INT 48
59795: PUSH
59796: LD_INT 49
59798: PUSH
59799: LD_INT 50
59801: PUSH
59802: LD_INT 51
59804: PUSH
59805: LD_INT 52
59807: PUSH
59808: LD_INT 53
59810: PUSH
59811: LD_INT 54
59813: PUSH
59814: LD_INT 55
59816: PUSH
59817: LD_INT 56
59819: PUSH
59820: LD_INT 60
59822: PUSH
59823: LD_INT 61
59825: PUSH
59826: LD_INT 62
59828: PUSH
59829: LD_INT 66
59831: PUSH
59832: LD_INT 67
59834: PUSH
59835: LD_INT 68
59837: PUSH
59838: EMPTY
59839: LIST
59840: LIST
59841: LIST
59842: LIST
59843: LIST
59844: LIST
59845: LIST
59846: LIST
59847: LIST
59848: LIST
59849: LIST
59850: LIST
59851: LIST
59852: LIST
59853: LIST
59854: LIST
59855: LIST
59856: LIST
59857: LIST
59858: LIST
59859: LIST
59860: LIST
59861: LIST
59862: LIST
59863: LIST
59864: LIST
59865: LIST
59866: LIST
59867: LIST
59868: LIST
59869: LIST
59870: LIST
59871: LIST
59872: LIST
59873: LIST
59874: LIST
59875: LIST
59876: LIST
59877: LIST
59878: LIST
59879: LIST
59880: LIST
59881: ST_TO_ADDR
59882: GO 60075
59884: LD_INT 3
59886: DOUBLE
59887: EQUAL
59888: IFTRUE 59892
59890: GO 60074
59892: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
59893: LD_ADDR_VAR 0 4
59897: PUSH
59898: LD_INT 46
59900: PUSH
59901: LD_INT 47
59903: PUSH
59904: LD_INT 1
59906: PUSH
59907: LD_INT 2
59909: PUSH
59910: LD_INT 11
59912: PUSH
59913: LD_INT 9
59915: PUSH
59916: LD_INT 20
59918: PUSH
59919: LD_INT 19
59921: PUSH
59922: LD_INT 21
59924: PUSH
59925: LD_INT 24
59927: PUSH
59928: LD_INT 22
59930: PUSH
59931: LD_INT 25
59933: PUSH
59934: LD_INT 28
59936: PUSH
59937: LD_INT 29
59939: PUSH
59940: LD_INT 30
59942: PUSH
59943: LD_INT 31
59945: PUSH
59946: LD_INT 37
59948: PUSH
59949: LD_INT 38
59951: PUSH
59952: LD_INT 32
59954: PUSH
59955: LD_INT 27
59957: PUSH
59958: LD_INT 33
59960: PUSH
59961: LD_INT 69
59963: PUSH
59964: LD_INT 39
59966: PUSH
59967: LD_INT 34
59969: PUSH
59970: LD_INT 40
59972: PUSH
59973: LD_INT 71
59975: PUSH
59976: LD_INT 23
59978: PUSH
59979: LD_INT 44
59981: PUSH
59982: LD_INT 48
59984: PUSH
59985: LD_INT 49
59987: PUSH
59988: LD_INT 50
59990: PUSH
59991: LD_INT 51
59993: PUSH
59994: LD_INT 52
59996: PUSH
59997: LD_INT 53
59999: PUSH
60000: LD_INT 54
60002: PUSH
60003: LD_INT 55
60005: PUSH
60006: LD_INT 56
60008: PUSH
60009: LD_INT 57
60011: PUSH
60012: LD_INT 58
60014: PUSH
60015: LD_INT 59
60017: PUSH
60018: LD_INT 63
60020: PUSH
60021: LD_INT 64
60023: PUSH
60024: LD_INT 65
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: LIST
60031: LIST
60032: LIST
60033: LIST
60034: LIST
60035: LIST
60036: LIST
60037: LIST
60038: LIST
60039: LIST
60040: LIST
60041: LIST
60042: LIST
60043: LIST
60044: LIST
60045: LIST
60046: LIST
60047: LIST
60048: LIST
60049: LIST
60050: LIST
60051: LIST
60052: LIST
60053: LIST
60054: LIST
60055: LIST
60056: LIST
60057: LIST
60058: LIST
60059: LIST
60060: LIST
60061: LIST
60062: LIST
60063: LIST
60064: LIST
60065: LIST
60066: LIST
60067: LIST
60068: LIST
60069: LIST
60070: LIST
60071: ST_TO_ADDR
60072: GO 60075
60074: POP
// if state > - 1 and state < 3 then
60075: LD_VAR 0 3
60079: PUSH
60080: LD_INT 1
60082: NEG
60083: GREATER
60084: PUSH
60085: LD_VAR 0 3
60089: PUSH
60090: LD_INT 3
60092: LESS
60093: AND
60094: IFFALSE 60151
// for i in result do
60096: LD_ADDR_VAR 0 5
60100: PUSH
60101: LD_VAR 0 4
60105: PUSH
60106: FOR_IN
60107: IFFALSE 60149
// if GetTech ( i , side ) <> state then
60109: LD_VAR 0 5
60113: PPUSH
60114: LD_VAR 0 1
60118: PPUSH
60119: CALL_OW 321
60123: PUSH
60124: LD_VAR 0 3
60128: NONEQUAL
60129: IFFALSE 60147
// result := result diff i ;
60131: LD_ADDR_VAR 0 4
60135: PUSH
60136: LD_VAR 0 4
60140: PUSH
60141: LD_VAR 0 5
60145: DIFF
60146: ST_TO_ADDR
60147: GO 60106
60149: POP
60150: POP
// end ;
60151: LD_VAR 0 4
60155: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
60156: LD_INT 0
60158: PPUSH
60159: PPUSH
60160: PPUSH
// result := true ;
60161: LD_ADDR_VAR 0 3
60165: PUSH
60166: LD_INT 1
60168: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
60169: LD_ADDR_VAR 0 5
60173: PUSH
60174: LD_VAR 0 2
60178: PPUSH
60179: CALL_OW 480
60183: ST_TO_ADDR
// if not tmp then
60184: LD_VAR 0 5
60188: NOT
60189: IFFALSE 60193
// exit ;
60191: GO 60242
// for i in tmp do
60193: LD_ADDR_VAR 0 4
60197: PUSH
60198: LD_VAR 0 5
60202: PUSH
60203: FOR_IN
60204: IFFALSE 60240
// if GetTech ( i , side ) <> state_researched then
60206: LD_VAR 0 4
60210: PPUSH
60211: LD_VAR 0 1
60215: PPUSH
60216: CALL_OW 321
60220: PUSH
60221: LD_INT 2
60223: NONEQUAL
60224: IFFALSE 60238
// begin result := false ;
60226: LD_ADDR_VAR 0 3
60230: PUSH
60231: LD_INT 0
60233: ST_TO_ADDR
// exit ;
60234: POP
60235: POP
60236: GO 60242
// end ;
60238: GO 60203
60240: POP
60241: POP
// end ;
60242: LD_VAR 0 3
60246: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
60247: LD_INT 0
60249: PPUSH
60250: PPUSH
60251: PPUSH
60252: PPUSH
60253: PPUSH
60254: PPUSH
60255: PPUSH
60256: PPUSH
60257: PPUSH
60258: PPUSH
60259: PPUSH
60260: PPUSH
60261: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
60262: LD_VAR 0 1
60266: NOT
60267: PUSH
60268: LD_VAR 0 1
60272: PPUSH
60273: CALL_OW 257
60277: PUSH
60278: LD_INT 9
60280: NONEQUAL
60281: OR
60282: IFFALSE 60286
// exit ;
60284: GO 60859
// side := GetSide ( unit ) ;
60286: LD_ADDR_VAR 0 9
60290: PUSH
60291: LD_VAR 0 1
60295: PPUSH
60296: CALL_OW 255
60300: ST_TO_ADDR
// tech_space := tech_spacanom ;
60301: LD_ADDR_VAR 0 12
60305: PUSH
60306: LD_INT 29
60308: ST_TO_ADDR
// tech_time := tech_taurad ;
60309: LD_ADDR_VAR 0 13
60313: PUSH
60314: LD_INT 28
60316: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
60317: LD_ADDR_VAR 0 11
60321: PUSH
60322: LD_VAR 0 1
60326: PPUSH
60327: CALL_OW 310
60331: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
60332: LD_VAR 0 11
60336: PPUSH
60337: CALL_OW 247
60341: PUSH
60342: LD_INT 2
60344: EQUAL
60345: IFFALSE 60349
// exit ;
60347: GO 60859
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
60349: LD_ADDR_VAR 0 8
60353: PUSH
60354: LD_INT 81
60356: PUSH
60357: LD_VAR 0 9
60361: PUSH
60362: EMPTY
60363: LIST
60364: LIST
60365: PUSH
60366: LD_INT 3
60368: PUSH
60369: LD_INT 21
60371: PUSH
60372: LD_INT 3
60374: PUSH
60375: EMPTY
60376: LIST
60377: LIST
60378: PUSH
60379: EMPTY
60380: LIST
60381: LIST
60382: PUSH
60383: EMPTY
60384: LIST
60385: LIST
60386: PPUSH
60387: CALL_OW 69
60391: ST_TO_ADDR
// if not tmp then
60392: LD_VAR 0 8
60396: NOT
60397: IFFALSE 60401
// exit ;
60399: GO 60859
// if in_unit then
60401: LD_VAR 0 11
60405: IFFALSE 60429
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
60407: LD_ADDR_VAR 0 10
60411: PUSH
60412: LD_VAR 0 8
60416: PPUSH
60417: LD_VAR 0 11
60421: PPUSH
60422: CALL_OW 74
60426: ST_TO_ADDR
60427: GO 60449
// enemy := NearestUnitToUnit ( tmp , unit ) ;
60429: LD_ADDR_VAR 0 10
60433: PUSH
60434: LD_VAR 0 8
60438: PPUSH
60439: LD_VAR 0 1
60443: PPUSH
60444: CALL_OW 74
60448: ST_TO_ADDR
// if not enemy then
60449: LD_VAR 0 10
60453: NOT
60454: IFFALSE 60458
// exit ;
60456: GO 60859
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
60458: LD_VAR 0 11
60462: PUSH
60463: LD_VAR 0 11
60467: PPUSH
60468: LD_VAR 0 10
60472: PPUSH
60473: CALL_OW 296
60477: PUSH
60478: LD_INT 13
60480: GREATER
60481: AND
60482: PUSH
60483: LD_VAR 0 1
60487: PPUSH
60488: LD_VAR 0 10
60492: PPUSH
60493: CALL_OW 296
60497: PUSH
60498: LD_INT 12
60500: GREATER
60501: OR
60502: IFFALSE 60506
// exit ;
60504: GO 60859
// missile := [ 1 ] ;
60506: LD_ADDR_VAR 0 14
60510: PUSH
60511: LD_INT 1
60513: PUSH
60514: EMPTY
60515: LIST
60516: ST_TO_ADDR
// if Researched ( side , tech_space ) then
60517: LD_VAR 0 9
60521: PPUSH
60522: LD_VAR 0 12
60526: PPUSH
60527: CALL_OW 325
60531: IFFALSE 60560
// missile := Insert ( missile , missile + 1 , 2 ) ;
60533: LD_ADDR_VAR 0 14
60537: PUSH
60538: LD_VAR 0 14
60542: PPUSH
60543: LD_VAR 0 14
60547: PUSH
60548: LD_INT 1
60550: PLUS
60551: PPUSH
60552: LD_INT 2
60554: PPUSH
60555: CALL_OW 2
60559: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
60560: LD_VAR 0 9
60564: PPUSH
60565: LD_VAR 0 13
60569: PPUSH
60570: CALL_OW 325
60574: PUSH
60575: LD_VAR 0 10
60579: PPUSH
60580: CALL_OW 255
60584: PPUSH
60585: LD_VAR 0 13
60589: PPUSH
60590: CALL_OW 325
60594: NOT
60595: AND
60596: IFFALSE 60625
// missile := Insert ( missile , missile + 1 , 3 ) ;
60598: LD_ADDR_VAR 0 14
60602: PUSH
60603: LD_VAR 0 14
60607: PPUSH
60608: LD_VAR 0 14
60612: PUSH
60613: LD_INT 1
60615: PLUS
60616: PPUSH
60617: LD_INT 3
60619: PPUSH
60620: CALL_OW 2
60624: ST_TO_ADDR
// if missile < 2 then
60625: LD_VAR 0 14
60629: PUSH
60630: LD_INT 2
60632: LESS
60633: IFFALSE 60637
// exit ;
60635: GO 60859
// x := GetX ( enemy ) ;
60637: LD_ADDR_VAR 0 4
60641: PUSH
60642: LD_VAR 0 10
60646: PPUSH
60647: CALL_OW 250
60651: ST_TO_ADDR
// y := GetY ( enemy ) ;
60652: LD_ADDR_VAR 0 5
60656: PUSH
60657: LD_VAR 0 10
60661: PPUSH
60662: CALL_OW 251
60666: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
60667: LD_ADDR_VAR 0 6
60671: PUSH
60672: LD_VAR 0 4
60676: PUSH
60677: LD_INT 1
60679: NEG
60680: PPUSH
60681: LD_INT 1
60683: PPUSH
60684: CALL_OW 12
60688: PLUS
60689: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
60690: LD_ADDR_VAR 0 7
60694: PUSH
60695: LD_VAR 0 5
60699: PUSH
60700: LD_INT 1
60702: NEG
60703: PPUSH
60704: LD_INT 1
60706: PPUSH
60707: CALL_OW 12
60711: PLUS
60712: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60713: LD_VAR 0 6
60717: PPUSH
60718: LD_VAR 0 7
60722: PPUSH
60723: CALL_OW 488
60727: NOT
60728: IFFALSE 60750
// begin _x := x ;
60730: LD_ADDR_VAR 0 6
60734: PUSH
60735: LD_VAR 0 4
60739: ST_TO_ADDR
// _y := y ;
60740: LD_ADDR_VAR 0 7
60744: PUSH
60745: LD_VAR 0 5
60749: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
60750: LD_ADDR_VAR 0 3
60754: PUSH
60755: LD_INT 1
60757: PPUSH
60758: LD_VAR 0 14
60762: PPUSH
60763: CALL_OW 12
60767: ST_TO_ADDR
// case i of 1 :
60768: LD_VAR 0 3
60772: PUSH
60773: LD_INT 1
60775: DOUBLE
60776: EQUAL
60777: IFTRUE 60781
60779: GO 60798
60781: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
60782: LD_VAR 0 1
60786: PPUSH
60787: LD_VAR 0 10
60791: PPUSH
60792: CALL_OW 115
60796: GO 60859
60798: LD_INT 2
60800: DOUBLE
60801: EQUAL
60802: IFTRUE 60806
60804: GO 60828
60806: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
60807: LD_VAR 0 1
60811: PPUSH
60812: LD_VAR 0 6
60816: PPUSH
60817: LD_VAR 0 7
60821: PPUSH
60822: CALL_OW 153
60826: GO 60859
60828: LD_INT 3
60830: DOUBLE
60831: EQUAL
60832: IFTRUE 60836
60834: GO 60858
60836: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
60837: LD_VAR 0 1
60841: PPUSH
60842: LD_VAR 0 6
60846: PPUSH
60847: LD_VAR 0 7
60851: PPUSH
60852: CALL_OW 154
60856: GO 60859
60858: POP
// end ;
60859: LD_VAR 0 2
60863: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
60864: LD_INT 0
60866: PPUSH
60867: PPUSH
60868: PPUSH
60869: PPUSH
60870: PPUSH
60871: PPUSH
// if not unit or not building then
60872: LD_VAR 0 1
60876: NOT
60877: PUSH
60878: LD_VAR 0 2
60882: NOT
60883: OR
60884: IFFALSE 60888
// exit ;
60886: GO 61046
// x := GetX ( building ) ;
60888: LD_ADDR_VAR 0 5
60892: PUSH
60893: LD_VAR 0 2
60897: PPUSH
60898: CALL_OW 250
60902: ST_TO_ADDR
// y := GetY ( building ) ;
60903: LD_ADDR_VAR 0 6
60907: PUSH
60908: LD_VAR 0 2
60912: PPUSH
60913: CALL_OW 251
60917: ST_TO_ADDR
// for i = 0 to 5 do
60918: LD_ADDR_VAR 0 4
60922: PUSH
60923: DOUBLE
60924: LD_INT 0
60926: DEC
60927: ST_TO_ADDR
60928: LD_INT 5
60930: PUSH
60931: FOR_TO
60932: IFFALSE 61044
// begin _x := ShiftX ( x , i , 3 ) ;
60934: LD_ADDR_VAR 0 7
60938: PUSH
60939: LD_VAR 0 5
60943: PPUSH
60944: LD_VAR 0 4
60948: PPUSH
60949: LD_INT 3
60951: PPUSH
60952: CALL_OW 272
60956: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
60957: LD_ADDR_VAR 0 8
60961: PUSH
60962: LD_VAR 0 6
60966: PPUSH
60967: LD_VAR 0 4
60971: PPUSH
60972: LD_INT 3
60974: PPUSH
60975: CALL_OW 273
60979: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
60980: LD_VAR 0 7
60984: PPUSH
60985: LD_VAR 0 8
60989: PPUSH
60990: CALL_OW 488
60994: NOT
60995: IFFALSE 60999
// continue ;
60997: GO 60931
// if HexInfo ( _x , _y ) = 0 then
60999: LD_VAR 0 7
61003: PPUSH
61004: LD_VAR 0 8
61008: PPUSH
61009: CALL_OW 428
61013: PUSH
61014: LD_INT 0
61016: EQUAL
61017: IFFALSE 61042
// begin ComMoveXY ( unit , _x , _y ) ;
61019: LD_VAR 0 1
61023: PPUSH
61024: LD_VAR 0 7
61028: PPUSH
61029: LD_VAR 0 8
61033: PPUSH
61034: CALL_OW 111
// exit ;
61038: POP
61039: POP
61040: GO 61046
// end ; end ;
61042: GO 60931
61044: POP
61045: POP
// end ;
61046: LD_VAR 0 3
61050: RET
// export function ScanBase ( side , base_area ) ; begin
61051: LD_INT 0
61053: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
61054: LD_ADDR_VAR 0 3
61058: PUSH
61059: LD_VAR 0 2
61063: PPUSH
61064: LD_INT 81
61066: PUSH
61067: LD_VAR 0 1
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PPUSH
61076: CALL_OW 70
61080: ST_TO_ADDR
// end ;
61081: LD_VAR 0 3
61085: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
61086: LD_INT 0
61088: PPUSH
61089: PPUSH
61090: PPUSH
61091: PPUSH
61092: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
61093: LD_VAR 0 1
61097: NOT
61098: PUSH
61099: LD_EXP 99
61103: PUSH
61104: LD_VAR 0 1
61108: ARRAY
61109: NOT
61110: OR
61111: PUSH
61112: LD_VAR 0 2
61116: NOT
61117: OR
61118: PUSH
61119: LD_VAR 0 3
61123: NOT
61124: OR
61125: IFFALSE 61129
// exit ;
61127: GO 61579
// side := mc_sides [ base ] ;
61129: LD_ADDR_VAR 0 6
61133: PUSH
61134: LD_EXP 125
61138: PUSH
61139: LD_VAR 0 1
61143: ARRAY
61144: ST_TO_ADDR
// if not side then
61145: LD_VAR 0 6
61149: NOT
61150: IFFALSE 61154
// exit ;
61152: GO 61579
// for i in solds do
61154: LD_ADDR_VAR 0 7
61158: PUSH
61159: LD_VAR 0 2
61163: PUSH
61164: FOR_IN
61165: IFFALSE 61226
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
61167: LD_VAR 0 7
61171: PPUSH
61172: CALL_OW 310
61176: PPUSH
61177: CALL_OW 266
61181: PUSH
61182: LD_INT 32
61184: PUSH
61185: LD_INT 31
61187: PUSH
61188: EMPTY
61189: LIST
61190: LIST
61191: IN
61192: IFFALSE 61212
// solds := solds diff i else
61194: LD_ADDR_VAR 0 2
61198: PUSH
61199: LD_VAR 0 2
61203: PUSH
61204: LD_VAR 0 7
61208: DIFF
61209: ST_TO_ADDR
61210: GO 61224
// SetTag ( i , 18 ) ;
61212: LD_VAR 0 7
61216: PPUSH
61217: LD_INT 18
61219: PPUSH
61220: CALL_OW 109
61224: GO 61164
61226: POP
61227: POP
// if not solds then
61228: LD_VAR 0 2
61232: NOT
61233: IFFALSE 61237
// exit ;
61235: GO 61579
// repeat wait ( 0 0$1 ) ;
61237: LD_INT 35
61239: PPUSH
61240: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
61244: LD_ADDR_VAR 0 5
61248: PUSH
61249: LD_VAR 0 6
61253: PPUSH
61254: LD_VAR 0 3
61258: PPUSH
61259: CALL 61051 0 2
61263: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
61264: LD_VAR 0 5
61268: NOT
61269: PUSH
61270: LD_VAR 0 5
61274: PUSH
61275: LD_INT 3
61277: GREATER
61278: OR
61279: PUSH
61280: LD_EXP 121
61284: PUSH
61285: LD_VAR 0 1
61289: ARRAY
61290: OR
61291: IFFALSE 61332
// begin for i in solds do
61293: LD_ADDR_VAR 0 7
61297: PUSH
61298: LD_VAR 0 2
61302: PUSH
61303: FOR_IN
61304: IFFALSE 61328
// if HasTask ( i ) then
61306: LD_VAR 0 7
61310: PPUSH
61311: CALL_OW 314
61315: IFFALSE 61326
// ComStop ( i ) ;
61317: LD_VAR 0 7
61321: PPUSH
61322: CALL_OW 141
61326: GO 61303
61328: POP
61329: POP
// break ;
61330: GO 61567
// end ; for i in solds do
61332: LD_ADDR_VAR 0 7
61336: PUSH
61337: LD_VAR 0 2
61341: PUSH
61342: FOR_IN
61343: IFFALSE 61559
// begin if IsInUnit ( i ) then
61345: LD_VAR 0 7
61349: PPUSH
61350: CALL_OW 310
61354: IFFALSE 61365
// ComExitBuilding ( i ) ;
61356: LD_VAR 0 7
61360: PPUSH
61361: CALL_OW 122
// if GetLives ( i ) > 333 then
61365: LD_VAR 0 7
61369: PPUSH
61370: CALL_OW 256
61374: PUSH
61375: LD_INT 333
61377: GREATER
61378: IFFALSE 61406
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
61380: LD_VAR 0 7
61384: PPUSH
61385: LD_VAR 0 5
61389: PPUSH
61390: LD_VAR 0 7
61394: PPUSH
61395: CALL_OW 74
61399: PPUSH
61400: CALL_OW 115
61404: GO 61557
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
61406: LD_ADDR_VAR 0 8
61410: PUSH
61411: LD_EXP 99
61415: PUSH
61416: LD_VAR 0 1
61420: ARRAY
61421: PPUSH
61422: LD_INT 2
61424: PUSH
61425: LD_INT 30
61427: PUSH
61428: LD_INT 0
61430: PUSH
61431: EMPTY
61432: LIST
61433: LIST
61434: PUSH
61435: LD_INT 30
61437: PUSH
61438: LD_INT 1
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: PUSH
61445: LD_INT 30
61447: PUSH
61448: LD_INT 6
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PUSH
61455: EMPTY
61456: LIST
61457: LIST
61458: LIST
61459: LIST
61460: PPUSH
61461: CALL_OW 72
61465: PPUSH
61466: LD_VAR 0 7
61470: PPUSH
61471: CALL_OW 74
61475: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
61476: LD_VAR 0 7
61480: PPUSH
61481: LD_VAR 0 8
61485: PPUSH
61486: CALL_OW 250
61490: PPUSH
61491: LD_INT 3
61493: PPUSH
61494: LD_INT 5
61496: PPUSH
61497: CALL_OW 272
61501: PPUSH
61502: LD_VAR 0 8
61506: PPUSH
61507: CALL_OW 251
61511: PPUSH
61512: LD_INT 3
61514: PPUSH
61515: LD_INT 5
61517: PPUSH
61518: CALL_OW 273
61522: PPUSH
61523: CALL_OW 111
// SetTag ( i , 0 ) ;
61527: LD_VAR 0 7
61531: PPUSH
61532: LD_INT 0
61534: PPUSH
61535: CALL_OW 109
// solds := solds diff i ;
61539: LD_ADDR_VAR 0 2
61543: PUSH
61544: LD_VAR 0 2
61548: PUSH
61549: LD_VAR 0 7
61553: DIFF
61554: ST_TO_ADDR
// continue ;
61555: GO 61342
// end ; end ;
61557: GO 61342
61559: POP
61560: POP
// until solds ;
61561: LD_VAR 0 2
61565: IFFALSE 61237
// MC_Reset ( base , 18 ) ;
61567: LD_VAR 0 1
61571: PPUSH
61572: LD_INT 18
61574: PPUSH
61575: CALL 34659 0 2
// end ;
61579: LD_VAR 0 4
61583: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
61584: LD_INT 0
61586: PPUSH
61587: PPUSH
61588: PPUSH
61589: PPUSH
61590: PPUSH
61591: PPUSH
61592: PPUSH
61593: PPUSH
61594: PPUSH
61595: PPUSH
61596: PPUSH
61597: PPUSH
61598: PPUSH
61599: PPUSH
61600: PPUSH
61601: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61602: LD_ADDR_VAR 0 12
61606: PUSH
61607: LD_EXP 99
61611: PUSH
61612: LD_VAR 0 1
61616: ARRAY
61617: PPUSH
61618: LD_INT 25
61620: PUSH
61621: LD_INT 3
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: PPUSH
61628: CALL_OW 72
61632: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61633: LD_ADDR_VAR 0 8
61637: PUSH
61638: LD_EXP 99
61642: PUSH
61643: LD_VAR 0 1
61647: ARRAY
61648: PPUSH
61649: LD_INT 2
61651: PUSH
61652: LD_INT 25
61654: PUSH
61655: LD_INT 1
61657: PUSH
61658: EMPTY
61659: LIST
61660: LIST
61661: PUSH
61662: LD_INT 25
61664: PUSH
61665: LD_INT 5
61667: PUSH
61668: EMPTY
61669: LIST
61670: LIST
61671: PUSH
61672: LD_INT 25
61674: PUSH
61675: LD_INT 8
61677: PUSH
61678: EMPTY
61679: LIST
61680: LIST
61681: PUSH
61682: LD_INT 25
61684: PUSH
61685: LD_INT 9
61687: PUSH
61688: EMPTY
61689: LIST
61690: LIST
61691: PUSH
61692: EMPTY
61693: LIST
61694: LIST
61695: LIST
61696: LIST
61697: LIST
61698: PPUSH
61699: CALL_OW 72
61703: ST_TO_ADDR
// if not defenders and not solds then
61704: LD_VAR 0 2
61708: NOT
61709: PUSH
61710: LD_VAR 0 8
61714: NOT
61715: AND
61716: IFFALSE 61720
// exit ;
61718: GO 63086
// depot_under_attack := false ;
61720: LD_ADDR_VAR 0 16
61724: PUSH
61725: LD_INT 0
61727: ST_TO_ADDR
// sold_defenders := [ ] ;
61728: LD_ADDR_VAR 0 17
61732: PUSH
61733: EMPTY
61734: ST_TO_ADDR
// if mechs then
61735: LD_VAR 0 12
61739: IFFALSE 61868
// for i in defenders do
61741: LD_ADDR_VAR 0 5
61745: PUSH
61746: LD_VAR 0 2
61750: PUSH
61751: FOR_IN
61752: IFFALSE 61866
// begin SetTag ( i , 20 ) ;
61754: LD_VAR 0 5
61758: PPUSH
61759: LD_INT 20
61761: PPUSH
61762: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
61766: LD_VAR 0 5
61770: PPUSH
61771: CALL_OW 263
61775: PUSH
61776: LD_INT 1
61778: EQUAL
61779: PUSH
61780: LD_VAR 0 5
61784: PPUSH
61785: CALL_OW 311
61789: NOT
61790: AND
61791: PUSH
61792: LD_VAR 0 12
61796: AND
61797: IFFALSE 61864
// begin un := mechs [ 1 ] ;
61799: LD_ADDR_VAR 0 10
61803: PUSH
61804: LD_VAR 0 12
61808: PUSH
61809: LD_INT 1
61811: ARRAY
61812: ST_TO_ADDR
// ComExitBuilding ( un ) ;
61813: LD_VAR 0 10
61817: PPUSH
61818: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
61822: LD_VAR 0 10
61826: PPUSH
61827: LD_VAR 0 5
61831: PPUSH
61832: CALL_OW 180
// SetTag ( un , 19 ) ;
61836: LD_VAR 0 10
61840: PPUSH
61841: LD_INT 19
61843: PPUSH
61844: CALL_OW 109
// mechs := mechs diff un ;
61848: LD_ADDR_VAR 0 12
61852: PUSH
61853: LD_VAR 0 12
61857: PUSH
61858: LD_VAR 0 10
61862: DIFF
61863: ST_TO_ADDR
// end ; end ;
61864: GO 61751
61866: POP
61867: POP
// if solds then
61868: LD_VAR 0 8
61872: IFFALSE 61931
// for i in solds do
61874: LD_ADDR_VAR 0 5
61878: PUSH
61879: LD_VAR 0 8
61883: PUSH
61884: FOR_IN
61885: IFFALSE 61929
// if not GetTag ( i ) then
61887: LD_VAR 0 5
61891: PPUSH
61892: CALL_OW 110
61896: NOT
61897: IFFALSE 61927
// begin defenders := defenders union i ;
61899: LD_ADDR_VAR 0 2
61903: PUSH
61904: LD_VAR 0 2
61908: PUSH
61909: LD_VAR 0 5
61913: UNION
61914: ST_TO_ADDR
// SetTag ( i , 18 ) ;
61915: LD_VAR 0 5
61919: PPUSH
61920: LD_INT 18
61922: PPUSH
61923: CALL_OW 109
// end ;
61927: GO 61884
61929: POP
61930: POP
// repeat wait ( 0 0$1 ) ;
61931: LD_INT 35
61933: PPUSH
61934: CALL_OW 67
// enemy := mc_scan [ base ] ;
61938: LD_ADDR_VAR 0 3
61942: PUSH
61943: LD_EXP 122
61947: PUSH
61948: LD_VAR 0 1
61952: ARRAY
61953: ST_TO_ADDR
// for i in defenders do
61954: LD_ADDR_VAR 0 5
61958: PUSH
61959: LD_VAR 0 2
61963: PUSH
61964: FOR_IN
61965: IFFALSE 62650
// begin e := NearestUnitToUnit ( enemy , i ) ;
61967: LD_ADDR_VAR 0 13
61971: PUSH
61972: LD_VAR 0 3
61976: PPUSH
61977: LD_VAR 0 5
61981: PPUSH
61982: CALL_OW 74
61986: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
61987: LD_ADDR_VAR 0 16
61991: PUSH
61992: LD_EXP 99
61996: PUSH
61997: LD_VAR 0 1
62001: ARRAY
62002: PPUSH
62003: LD_INT 2
62005: PUSH
62006: LD_INT 30
62008: PUSH
62009: LD_INT 0
62011: PUSH
62012: EMPTY
62013: LIST
62014: LIST
62015: PUSH
62016: LD_INT 30
62018: PUSH
62019: LD_INT 1
62021: PUSH
62022: EMPTY
62023: LIST
62024: LIST
62025: PUSH
62026: EMPTY
62027: LIST
62028: LIST
62029: LIST
62030: PPUSH
62031: CALL_OW 72
62035: NOT
62036: PUSH
62037: LD_EXP 99
62041: PUSH
62042: LD_VAR 0 1
62046: ARRAY
62047: PPUSH
62048: LD_INT 2
62050: PUSH
62051: LD_INT 30
62053: PUSH
62054: LD_INT 0
62056: PUSH
62057: EMPTY
62058: LIST
62059: LIST
62060: PUSH
62061: LD_INT 30
62063: PUSH
62064: LD_INT 1
62066: PUSH
62067: EMPTY
62068: LIST
62069: LIST
62070: PUSH
62071: EMPTY
62072: LIST
62073: LIST
62074: LIST
62075: PPUSH
62076: CALL_OW 72
62080: PPUSH
62081: CALL_OW 256
62085: PUSH
62086: LD_INT 600
62088: LESS
62089: OR
62090: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
62091: LD_VAR 0 5
62095: PPUSH
62096: CALL_OW 247
62100: PUSH
62101: LD_INT 2
62103: DOUBLE
62104: EQUAL
62105: IFTRUE 62109
62107: GO 62356
62109: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
62110: LD_VAR 0 5
62114: PPUSH
62115: CALL_OW 256
62119: PUSH
62120: LD_INT 650
62122: GREATER
62123: PUSH
62124: LD_VAR 0 5
62128: PPUSH
62129: LD_VAR 0 13
62133: PPUSH
62134: CALL_OW 296
62138: PUSH
62139: LD_INT 40
62141: LESS
62142: AND
62143: IFFALSE 62161
// ComAttackUnit ( i , e ) else
62145: LD_VAR 0 5
62149: PPUSH
62150: LD_VAR 0 13
62154: PPUSH
62155: CALL_OW 115
62159: GO 62239
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
62161: LD_VAR 0 5
62165: PPUSH
62166: LD_VAR 0 13
62170: PPUSH
62171: CALL_OW 296
62175: PUSH
62176: LD_INT 30
62178: GREATEREQUAL
62179: PUSH
62180: LD_VAR 0 5
62184: PPUSH
62185: CALL_OW 256
62189: PUSH
62190: LD_INT 650
62192: LESSEQUAL
62193: OR
62194: PUSH
62195: LD_VAR 0 5
62199: PPUSH
62200: LD_EXP 123
62204: PUSH
62205: LD_VAR 0 1
62209: ARRAY
62210: PPUSH
62211: CALL_OW 308
62215: NOT
62216: AND
62217: IFFALSE 62239
// ComMoveToArea ( i , mc_parking [ base ] ) ;
62219: LD_VAR 0 5
62223: PPUSH
62224: LD_EXP 123
62228: PUSH
62229: LD_VAR 0 1
62233: ARRAY
62234: PPUSH
62235: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
62239: LD_VAR 0 5
62243: PPUSH
62244: CALL_OW 256
62248: PUSH
62249: LD_INT 998
62251: LESS
62252: PUSH
62253: LD_VAR 0 5
62257: PPUSH
62258: CALL_OW 263
62262: PUSH
62263: LD_INT 1
62265: EQUAL
62266: AND
62267: PUSH
62268: LD_VAR 0 5
62272: PPUSH
62273: CALL_OW 311
62277: AND
62278: PUSH
62279: LD_VAR 0 5
62283: PPUSH
62284: LD_EXP 123
62288: PUSH
62289: LD_VAR 0 1
62293: ARRAY
62294: PPUSH
62295: CALL_OW 308
62299: AND
62300: IFFALSE 62354
// begin mech := IsDrivenBy ( i ) ;
62302: LD_ADDR_VAR 0 9
62306: PUSH
62307: LD_VAR 0 5
62311: PPUSH
62312: CALL_OW 311
62316: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
62317: LD_VAR 0 9
62321: PPUSH
62322: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
62326: LD_VAR 0 9
62330: PPUSH
62331: LD_VAR 0 5
62335: PPUSH
62336: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
62340: LD_VAR 0 9
62344: PPUSH
62345: LD_VAR 0 5
62349: PPUSH
62350: CALL_OW 180
// end ; end ; unit_human :
62354: GO 62621
62356: LD_INT 1
62358: DOUBLE
62359: EQUAL
62360: IFTRUE 62364
62362: GO 62620
62364: POP
// begin b := IsInUnit ( i ) ;
62365: LD_ADDR_VAR 0 18
62369: PUSH
62370: LD_VAR 0 5
62374: PPUSH
62375: CALL_OW 310
62379: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
62380: LD_ADDR_VAR 0 19
62384: PUSH
62385: LD_VAR 0 18
62389: NOT
62390: PUSH
62391: LD_VAR 0 18
62395: PPUSH
62396: CALL_OW 266
62400: PUSH
62401: LD_INT 32
62403: PUSH
62404: LD_INT 31
62406: PUSH
62407: EMPTY
62408: LIST
62409: LIST
62410: IN
62411: OR
62412: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
62413: LD_VAR 0 16
62417: PUSH
62418: LD_VAR 0 2
62422: PPUSH
62423: LD_INT 21
62425: PUSH
62426: LD_INT 2
62428: PUSH
62429: EMPTY
62430: LIST
62431: LIST
62432: PPUSH
62433: CALL_OW 72
62437: PUSH
62438: LD_INT 1
62440: LESSEQUAL
62441: OR
62442: PUSH
62443: LD_VAR 0 19
62447: AND
62448: PUSH
62449: LD_VAR 0 5
62453: PUSH
62454: LD_VAR 0 17
62458: IN
62459: NOT
62460: AND
62461: IFFALSE 62554
// begin if b then
62463: LD_VAR 0 18
62467: IFFALSE 62516
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
62469: LD_VAR 0 18
62473: PPUSH
62474: LD_VAR 0 3
62478: PPUSH
62479: LD_VAR 0 18
62483: PPUSH
62484: CALL_OW 74
62488: PPUSH
62489: CALL_OW 296
62493: PUSH
62494: LD_INT 10
62496: LESS
62497: PUSH
62498: LD_VAR 0 18
62502: PPUSH
62503: CALL_OW 461
62507: PUSH
62508: LD_INT 7
62510: NONEQUAL
62511: AND
62512: IFFALSE 62516
// continue ;
62514: GO 61964
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
62516: LD_ADDR_VAR 0 17
62520: PUSH
62521: LD_VAR 0 17
62525: PPUSH
62526: LD_VAR 0 17
62530: PUSH
62531: LD_INT 1
62533: PLUS
62534: PPUSH
62535: LD_VAR 0 5
62539: PPUSH
62540: CALL_OW 1
62544: ST_TO_ADDR
// ComExitBuilding ( i ) ;
62545: LD_VAR 0 5
62549: PPUSH
62550: CALL_OW 122
// end ; if sold_defenders then
62554: LD_VAR 0 17
62558: IFFALSE 62618
// if i in sold_defenders then
62560: LD_VAR 0 5
62564: PUSH
62565: LD_VAR 0 17
62569: IN
62570: IFFALSE 62618
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
62572: LD_VAR 0 5
62576: PPUSH
62577: CALL_OW 314
62581: NOT
62582: PUSH
62583: LD_VAR 0 5
62587: PPUSH
62588: LD_VAR 0 13
62592: PPUSH
62593: CALL_OW 296
62597: PUSH
62598: LD_INT 30
62600: LESS
62601: AND
62602: IFFALSE 62618
// ComAttackUnit ( i , e ) ;
62604: LD_VAR 0 5
62608: PPUSH
62609: LD_VAR 0 13
62613: PPUSH
62614: CALL_OW 115
// end ; end ; end ;
62618: GO 62621
62620: POP
// if IsDead ( i ) then
62621: LD_VAR 0 5
62625: PPUSH
62626: CALL_OW 301
62630: IFFALSE 62648
// defenders := defenders diff i ;
62632: LD_ADDR_VAR 0 2
62636: PUSH
62637: LD_VAR 0 2
62641: PUSH
62642: LD_VAR 0 5
62646: DIFF
62647: ST_TO_ADDR
// end ;
62648: GO 61964
62650: POP
62651: POP
// until not enemy or not defenders ;
62652: LD_VAR 0 3
62656: NOT
62657: PUSH
62658: LD_VAR 0 2
62662: NOT
62663: OR
62664: IFFALSE 61931
// MC_Reset ( base , 18 ) ;
62666: LD_VAR 0 1
62670: PPUSH
62671: LD_INT 18
62673: PPUSH
62674: CALL 34659 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62678: LD_ADDR_VAR 0 2
62682: PUSH
62683: LD_VAR 0 2
62687: PUSH
62688: LD_VAR 0 2
62692: PPUSH
62693: LD_INT 2
62695: PUSH
62696: LD_INT 25
62698: PUSH
62699: LD_INT 1
62701: PUSH
62702: EMPTY
62703: LIST
62704: LIST
62705: PUSH
62706: LD_INT 25
62708: PUSH
62709: LD_INT 5
62711: PUSH
62712: EMPTY
62713: LIST
62714: LIST
62715: PUSH
62716: LD_INT 25
62718: PUSH
62719: LD_INT 8
62721: PUSH
62722: EMPTY
62723: LIST
62724: LIST
62725: PUSH
62726: LD_INT 25
62728: PUSH
62729: LD_INT 9
62731: PUSH
62732: EMPTY
62733: LIST
62734: LIST
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: LIST
62740: LIST
62741: LIST
62742: PPUSH
62743: CALL_OW 72
62747: DIFF
62748: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
62749: LD_VAR 0 3
62753: NOT
62754: PUSH
62755: LD_VAR 0 2
62759: PPUSH
62760: LD_INT 21
62762: PUSH
62763: LD_INT 2
62765: PUSH
62766: EMPTY
62767: LIST
62768: LIST
62769: PPUSH
62770: CALL_OW 72
62774: AND
62775: IFFALSE 63037
// begin tmp := FilterByTag ( defenders , 19 ) ;
62777: LD_ADDR_VAR 0 11
62781: PUSH
62782: LD_VAR 0 2
62786: PPUSH
62787: LD_INT 19
62789: PPUSH
62790: CALL 99384 0 2
62794: ST_TO_ADDR
// if tmp then
62795: LD_VAR 0 11
62799: IFFALSE 62869
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
62801: LD_ADDR_VAR 0 11
62805: PUSH
62806: LD_VAR 0 11
62810: PPUSH
62811: LD_INT 25
62813: PUSH
62814: LD_INT 3
62816: PUSH
62817: EMPTY
62818: LIST
62819: LIST
62820: PPUSH
62821: CALL_OW 72
62825: ST_TO_ADDR
// if tmp then
62826: LD_VAR 0 11
62830: IFFALSE 62869
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
62832: LD_ADDR_EXP 111
62836: PUSH
62837: LD_EXP 111
62841: PPUSH
62842: LD_VAR 0 1
62846: PPUSH
62847: LD_EXP 111
62851: PUSH
62852: LD_VAR 0 1
62856: ARRAY
62857: PUSH
62858: LD_VAR 0 11
62862: UNION
62863: PPUSH
62864: CALL_OW 1
62868: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
62869: LD_VAR 0 1
62873: PPUSH
62874: LD_INT 19
62876: PPUSH
62877: CALL 34659 0 2
// repeat wait ( 0 0$1 ) ;
62881: LD_INT 35
62883: PPUSH
62884: CALL_OW 67
// for i in defenders do
62888: LD_ADDR_VAR 0 5
62892: PUSH
62893: LD_VAR 0 2
62897: PUSH
62898: FOR_IN
62899: IFFALSE 62988
// begin if not IsInArea ( i , mc_parking [ base ] ) then
62901: LD_VAR 0 5
62905: PPUSH
62906: LD_EXP 123
62910: PUSH
62911: LD_VAR 0 1
62915: ARRAY
62916: PPUSH
62917: CALL_OW 308
62921: NOT
62922: IFFALSE 62946
// ComMoveToArea ( i , mc_parking [ base ] ) else
62924: LD_VAR 0 5
62928: PPUSH
62929: LD_EXP 123
62933: PUSH
62934: LD_VAR 0 1
62938: ARRAY
62939: PPUSH
62940: CALL_OW 113
62944: GO 62986
// if GetControl ( i ) = control_manual then
62946: LD_VAR 0 5
62950: PPUSH
62951: CALL_OW 263
62955: PUSH
62956: LD_INT 1
62958: EQUAL
62959: IFFALSE 62986
// if IsDrivenBy ( i ) then
62961: LD_VAR 0 5
62965: PPUSH
62966: CALL_OW 311
62970: IFFALSE 62986
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
62972: LD_VAR 0 5
62976: PPUSH
62977: CALL_OW 311
62981: PPUSH
62982: CALL_OW 121
// end ;
62986: GO 62898
62988: POP
62989: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
62990: LD_VAR 0 2
62994: PPUSH
62995: LD_INT 95
62997: PUSH
62998: LD_EXP 123
63002: PUSH
63003: LD_VAR 0 1
63007: ARRAY
63008: PUSH
63009: EMPTY
63010: LIST
63011: LIST
63012: PPUSH
63013: CALL_OW 72
63017: PUSH
63018: LD_VAR 0 2
63022: EQUAL
63023: PUSH
63024: LD_EXP 122
63028: PUSH
63029: LD_VAR 0 1
63033: ARRAY
63034: OR
63035: IFFALSE 62881
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
63037: LD_ADDR_EXP 121
63041: PUSH
63042: LD_EXP 121
63046: PPUSH
63047: LD_VAR 0 1
63051: PPUSH
63052: LD_EXP 121
63056: PUSH
63057: LD_VAR 0 1
63061: ARRAY
63062: PUSH
63063: LD_VAR 0 2
63067: UNION
63068: PPUSH
63069: CALL_OW 1
63073: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
63074: LD_VAR 0 1
63078: PPUSH
63079: LD_INT 20
63081: PPUSH
63082: CALL 34659 0 2
// end ;
63086: LD_VAR 0 4
63090: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
63091: LD_INT 0
63093: PPUSH
63094: PPUSH
63095: PPUSH
63096: PPUSH
// result := false ;
63097: LD_ADDR_VAR 0 2
63101: PUSH
63102: LD_INT 0
63104: ST_TO_ADDR
// side := GetSide ( unit ) ;
63105: LD_ADDR_VAR 0 3
63109: PUSH
63110: LD_VAR 0 1
63114: PPUSH
63115: CALL_OW 255
63119: ST_TO_ADDR
// nat := GetNation ( unit ) ;
63120: LD_ADDR_VAR 0 4
63124: PUSH
63125: LD_VAR 0 1
63129: PPUSH
63130: CALL_OW 248
63134: ST_TO_ADDR
// case nat of 1 :
63135: LD_VAR 0 4
63139: PUSH
63140: LD_INT 1
63142: DOUBLE
63143: EQUAL
63144: IFTRUE 63148
63146: GO 63159
63148: POP
// tech := tech_lassight ; 2 :
63149: LD_ADDR_VAR 0 5
63153: PUSH
63154: LD_INT 12
63156: ST_TO_ADDR
63157: GO 63198
63159: LD_INT 2
63161: DOUBLE
63162: EQUAL
63163: IFTRUE 63167
63165: GO 63178
63167: POP
// tech := tech_mortar ; 3 :
63168: LD_ADDR_VAR 0 5
63172: PUSH
63173: LD_INT 41
63175: ST_TO_ADDR
63176: GO 63198
63178: LD_INT 3
63180: DOUBLE
63181: EQUAL
63182: IFTRUE 63186
63184: GO 63197
63186: POP
// tech := tech_bazooka ; end ;
63187: LD_ADDR_VAR 0 5
63191: PUSH
63192: LD_INT 44
63194: ST_TO_ADDR
63195: GO 63198
63197: POP
// if Researched ( side , tech ) then
63198: LD_VAR 0 3
63202: PPUSH
63203: LD_VAR 0 5
63207: PPUSH
63208: CALL_OW 325
63212: IFFALSE 63239
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
63214: LD_ADDR_VAR 0 2
63218: PUSH
63219: LD_INT 5
63221: PUSH
63222: LD_INT 8
63224: PUSH
63225: LD_INT 9
63227: PUSH
63228: EMPTY
63229: LIST
63230: LIST
63231: LIST
63232: PUSH
63233: LD_VAR 0 4
63237: ARRAY
63238: ST_TO_ADDR
// end ;
63239: LD_VAR 0 2
63243: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
63244: LD_INT 0
63246: PPUSH
63247: PPUSH
63248: PPUSH
// if not mines then
63249: LD_VAR 0 2
63253: NOT
63254: IFFALSE 63258
// exit ;
63256: GO 63402
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63258: LD_ADDR_VAR 0 5
63262: PUSH
63263: LD_INT 81
63265: PUSH
63266: LD_VAR 0 1
63270: PUSH
63271: EMPTY
63272: LIST
63273: LIST
63274: PUSH
63275: LD_INT 3
63277: PUSH
63278: LD_INT 21
63280: PUSH
63281: LD_INT 3
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PPUSH
63296: CALL_OW 69
63300: ST_TO_ADDR
// for i in mines do
63301: LD_ADDR_VAR 0 4
63305: PUSH
63306: LD_VAR 0 2
63310: PUSH
63311: FOR_IN
63312: IFFALSE 63400
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
63314: LD_VAR 0 4
63318: PUSH
63319: LD_INT 1
63321: ARRAY
63322: PPUSH
63323: LD_VAR 0 4
63327: PUSH
63328: LD_INT 2
63330: ARRAY
63331: PPUSH
63332: CALL_OW 458
63336: NOT
63337: IFFALSE 63341
// continue ;
63339: GO 63311
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
63341: LD_VAR 0 4
63345: PUSH
63346: LD_INT 1
63348: ARRAY
63349: PPUSH
63350: LD_VAR 0 4
63354: PUSH
63355: LD_INT 2
63357: ARRAY
63358: PPUSH
63359: CALL_OW 428
63363: PUSH
63364: LD_VAR 0 5
63368: IN
63369: IFFALSE 63398
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
63371: LD_VAR 0 4
63375: PUSH
63376: LD_INT 1
63378: ARRAY
63379: PPUSH
63380: LD_VAR 0 4
63384: PUSH
63385: LD_INT 2
63387: ARRAY
63388: PPUSH
63389: LD_VAR 0 1
63393: PPUSH
63394: CALL_OW 456
// end ;
63398: GO 63311
63400: POP
63401: POP
// end ;
63402: LD_VAR 0 3
63406: RET
// export function Count ( array ) ; var i ; begin
63407: LD_INT 0
63409: PPUSH
63410: PPUSH
// result := 0 ;
63411: LD_ADDR_VAR 0 2
63415: PUSH
63416: LD_INT 0
63418: ST_TO_ADDR
// for i in array do
63419: LD_ADDR_VAR 0 3
63423: PUSH
63424: LD_VAR 0 1
63428: PUSH
63429: FOR_IN
63430: IFFALSE 63454
// if i then
63432: LD_VAR 0 3
63436: IFFALSE 63452
// result := result + 1 ;
63438: LD_ADDR_VAR 0 2
63442: PUSH
63443: LD_VAR 0 2
63447: PUSH
63448: LD_INT 1
63450: PLUS
63451: ST_TO_ADDR
63452: GO 63429
63454: POP
63455: POP
// end ;
63456: LD_VAR 0 2
63460: RET
// export function IsEmpty ( building ) ; begin
63461: LD_INT 0
63463: PPUSH
// if not building then
63464: LD_VAR 0 1
63468: NOT
63469: IFFALSE 63473
// exit ;
63471: GO 63516
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
63473: LD_ADDR_VAR 0 2
63477: PUSH
63478: LD_VAR 0 1
63482: PUSH
63483: LD_INT 22
63485: PUSH
63486: LD_VAR 0 1
63490: PPUSH
63491: CALL_OW 255
63495: PUSH
63496: EMPTY
63497: LIST
63498: LIST
63499: PUSH
63500: LD_INT 58
63502: PUSH
63503: EMPTY
63504: LIST
63505: PUSH
63506: EMPTY
63507: LIST
63508: LIST
63509: PPUSH
63510: CALL_OW 69
63514: IN
63515: ST_TO_ADDR
// end ;
63516: LD_VAR 0 2
63520: RET
// export function IsNotFull ( building ) ; begin
63521: LD_INT 0
63523: PPUSH
// if not building then
63524: LD_VAR 0 1
63528: NOT
63529: IFFALSE 63533
// exit ;
63531: GO 63552
// result := UnitsInside ( building ) < 6 ;
63533: LD_ADDR_VAR 0 2
63537: PUSH
63538: LD_VAR 0 1
63542: PPUSH
63543: CALL_OW 313
63547: PUSH
63548: LD_INT 6
63550: LESS
63551: ST_TO_ADDR
// end ;
63552: LD_VAR 0 2
63556: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
63557: LD_INT 0
63559: PPUSH
63560: PPUSH
63561: PPUSH
63562: PPUSH
// tmp := [ ] ;
63563: LD_ADDR_VAR 0 3
63567: PUSH
63568: EMPTY
63569: ST_TO_ADDR
// list := [ ] ;
63570: LD_ADDR_VAR 0 5
63574: PUSH
63575: EMPTY
63576: ST_TO_ADDR
// for i = 16 to 25 do
63577: LD_ADDR_VAR 0 4
63581: PUSH
63582: DOUBLE
63583: LD_INT 16
63585: DEC
63586: ST_TO_ADDR
63587: LD_INT 25
63589: PUSH
63590: FOR_TO
63591: IFFALSE 63664
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
63593: LD_ADDR_VAR 0 3
63597: PUSH
63598: LD_VAR 0 3
63602: PUSH
63603: LD_INT 22
63605: PUSH
63606: LD_VAR 0 1
63610: PPUSH
63611: CALL_OW 255
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 91
63622: PUSH
63623: LD_VAR 0 1
63627: PUSH
63628: LD_INT 6
63630: PUSH
63631: EMPTY
63632: LIST
63633: LIST
63634: LIST
63635: PUSH
63636: LD_INT 30
63638: PUSH
63639: LD_VAR 0 4
63643: PUSH
63644: EMPTY
63645: LIST
63646: LIST
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: LIST
63652: PUSH
63653: EMPTY
63654: LIST
63655: PPUSH
63656: CALL_OW 69
63660: ADD
63661: ST_TO_ADDR
63662: GO 63590
63664: POP
63665: POP
// for i = 1 to tmp do
63666: LD_ADDR_VAR 0 4
63670: PUSH
63671: DOUBLE
63672: LD_INT 1
63674: DEC
63675: ST_TO_ADDR
63676: LD_VAR 0 3
63680: PUSH
63681: FOR_TO
63682: IFFALSE 63770
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
63684: LD_ADDR_VAR 0 5
63688: PUSH
63689: LD_VAR 0 5
63693: PUSH
63694: LD_VAR 0 3
63698: PUSH
63699: LD_VAR 0 4
63703: ARRAY
63704: PPUSH
63705: CALL_OW 266
63709: PUSH
63710: LD_VAR 0 3
63714: PUSH
63715: LD_VAR 0 4
63719: ARRAY
63720: PPUSH
63721: CALL_OW 250
63725: PUSH
63726: LD_VAR 0 3
63730: PUSH
63731: LD_VAR 0 4
63735: ARRAY
63736: PPUSH
63737: CALL_OW 251
63741: PUSH
63742: LD_VAR 0 3
63746: PUSH
63747: LD_VAR 0 4
63751: ARRAY
63752: PPUSH
63753: CALL_OW 254
63757: PUSH
63758: EMPTY
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: PUSH
63764: EMPTY
63765: LIST
63766: ADD
63767: ST_TO_ADDR
63768: GO 63681
63770: POP
63771: POP
// result := list ;
63772: LD_ADDR_VAR 0 2
63776: PUSH
63777: LD_VAR 0 5
63781: ST_TO_ADDR
// end ;
63782: LD_VAR 0 2
63786: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
63787: LD_INT 0
63789: PPUSH
63790: PPUSH
63791: PPUSH
63792: PPUSH
63793: PPUSH
63794: PPUSH
63795: PPUSH
// if not factory then
63796: LD_VAR 0 1
63800: NOT
63801: IFFALSE 63805
// exit ;
63803: GO 64330
// if control = control_apeman then
63805: LD_VAR 0 4
63809: PUSH
63810: LD_INT 5
63812: EQUAL
63813: IFFALSE 63922
// begin tmp := UnitsInside ( factory ) ;
63815: LD_ADDR_VAR 0 8
63819: PUSH
63820: LD_VAR 0 1
63824: PPUSH
63825: CALL_OW 313
63829: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
63830: LD_VAR 0 8
63834: PPUSH
63835: LD_INT 25
63837: PUSH
63838: LD_INT 12
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: PPUSH
63845: CALL_OW 72
63849: NOT
63850: IFFALSE 63860
// control := control_manual ;
63852: LD_ADDR_VAR 0 4
63856: PUSH
63857: LD_INT 1
63859: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
63860: LD_ADDR_VAR 0 8
63864: PUSH
63865: LD_VAR 0 1
63869: PPUSH
63870: CALL 63557 0 1
63874: ST_TO_ADDR
// if tmp then
63875: LD_VAR 0 8
63879: IFFALSE 63922
// begin for i in tmp do
63881: LD_ADDR_VAR 0 7
63885: PUSH
63886: LD_VAR 0 8
63890: PUSH
63891: FOR_IN
63892: IFFALSE 63920
// if i [ 1 ] = b_ext_radar then
63894: LD_VAR 0 7
63898: PUSH
63899: LD_INT 1
63901: ARRAY
63902: PUSH
63903: LD_INT 20
63905: EQUAL
63906: IFFALSE 63918
// begin control := control_remote ;
63908: LD_ADDR_VAR 0 4
63912: PUSH
63913: LD_INT 2
63915: ST_TO_ADDR
// break ;
63916: GO 63920
// end ;
63918: GO 63891
63920: POP
63921: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
63922: LD_VAR 0 1
63926: PPUSH
63927: LD_VAR 0 2
63931: PPUSH
63932: LD_VAR 0 3
63936: PPUSH
63937: LD_VAR 0 4
63941: PPUSH
63942: LD_VAR 0 5
63946: PPUSH
63947: CALL_OW 448
63951: IFFALSE 63986
// begin result := [ chassis , engine , control , weapon ] ;
63953: LD_ADDR_VAR 0 6
63957: PUSH
63958: LD_VAR 0 2
63962: PUSH
63963: LD_VAR 0 3
63967: PUSH
63968: LD_VAR 0 4
63972: PUSH
63973: LD_VAR 0 5
63977: PUSH
63978: EMPTY
63979: LIST
63980: LIST
63981: LIST
63982: LIST
63983: ST_TO_ADDR
// exit ;
63984: GO 64330
// end ; _chassis := AvailableChassisList ( factory ) ;
63986: LD_ADDR_VAR 0 9
63990: PUSH
63991: LD_VAR 0 1
63995: PPUSH
63996: CALL_OW 475
64000: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
64001: LD_ADDR_VAR 0 11
64005: PUSH
64006: LD_VAR 0 1
64010: PPUSH
64011: CALL_OW 476
64015: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
64016: LD_ADDR_VAR 0 12
64020: PUSH
64021: LD_VAR 0 1
64025: PPUSH
64026: CALL_OW 477
64030: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
64031: LD_ADDR_VAR 0 10
64035: PUSH
64036: LD_VAR 0 1
64040: PPUSH
64041: CALL_OW 478
64045: ST_TO_ADDR
// if not chassis in _chassis then
64046: LD_VAR 0 2
64050: PUSH
64051: LD_VAR 0 9
64055: IN
64056: NOT
64057: IFFALSE 64083
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
64059: LD_ADDR_VAR 0 2
64063: PUSH
64064: LD_VAR 0 9
64068: PUSH
64069: LD_INT 1
64071: PPUSH
64072: LD_VAR 0 9
64076: PPUSH
64077: CALL_OW 12
64081: ARRAY
64082: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
64083: LD_VAR 0 2
64087: PPUSH
64088: LD_VAR 0 3
64092: PPUSH
64093: CALL 64335 0 2
64097: NOT
64098: IFFALSE 64157
// repeat engine := _engine [ 1 ] ;
64100: LD_ADDR_VAR 0 3
64104: PUSH
64105: LD_VAR 0 11
64109: PUSH
64110: LD_INT 1
64112: ARRAY
64113: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
64114: LD_ADDR_VAR 0 11
64118: PUSH
64119: LD_VAR 0 11
64123: PPUSH
64124: LD_INT 1
64126: PPUSH
64127: CALL_OW 3
64131: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
64132: LD_VAR 0 2
64136: PPUSH
64137: LD_VAR 0 3
64141: PPUSH
64142: CALL 64335 0 2
64146: PUSH
64147: LD_VAR 0 11
64151: PUSH
64152: EMPTY
64153: EQUAL
64154: OR
64155: IFFALSE 64100
// if not control in _control then
64157: LD_VAR 0 4
64161: PUSH
64162: LD_VAR 0 12
64166: IN
64167: NOT
64168: IFFALSE 64194
// control := _control [ rand ( 1 , _control ) ] ;
64170: LD_ADDR_VAR 0 4
64174: PUSH
64175: LD_VAR 0 12
64179: PUSH
64180: LD_INT 1
64182: PPUSH
64183: LD_VAR 0 12
64187: PPUSH
64188: CALL_OW 12
64192: ARRAY
64193: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
64194: LD_VAR 0 2
64198: PPUSH
64199: LD_VAR 0 5
64203: PPUSH
64204: CALL 64555 0 2
64208: NOT
64209: IFFALSE 64268
// repeat weapon := _weapon [ 1 ] ;
64211: LD_ADDR_VAR 0 5
64215: PUSH
64216: LD_VAR 0 10
64220: PUSH
64221: LD_INT 1
64223: ARRAY
64224: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
64225: LD_ADDR_VAR 0 10
64229: PUSH
64230: LD_VAR 0 10
64234: PPUSH
64235: LD_INT 1
64237: PPUSH
64238: CALL_OW 3
64242: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
64243: LD_VAR 0 2
64247: PPUSH
64248: LD_VAR 0 5
64252: PPUSH
64253: CALL 64555 0 2
64257: PUSH
64258: LD_VAR 0 10
64262: PUSH
64263: EMPTY
64264: EQUAL
64265: OR
64266: IFFALSE 64211
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
64268: LD_VAR 0 1
64272: PPUSH
64273: LD_VAR 0 2
64277: PPUSH
64278: LD_VAR 0 3
64282: PPUSH
64283: LD_VAR 0 4
64287: PPUSH
64288: LD_VAR 0 5
64292: PPUSH
64293: CALL_OW 448
64297: IFFALSE 64330
// result := [ chassis , engine , control , weapon ] ;
64299: LD_ADDR_VAR 0 6
64303: PUSH
64304: LD_VAR 0 2
64308: PUSH
64309: LD_VAR 0 3
64313: PUSH
64314: LD_VAR 0 4
64318: PUSH
64319: LD_VAR 0 5
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: ST_TO_ADDR
// end ;
64330: LD_VAR 0 6
64334: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
64335: LD_INT 0
64337: PPUSH
// if not chassis or not engine then
64338: LD_VAR 0 1
64342: NOT
64343: PUSH
64344: LD_VAR 0 2
64348: NOT
64349: OR
64350: IFFALSE 64354
// exit ;
64352: GO 64550
// case engine of engine_solar :
64354: LD_VAR 0 2
64358: PUSH
64359: LD_INT 2
64361: DOUBLE
64362: EQUAL
64363: IFTRUE 64367
64365: GO 64405
64367: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
64368: LD_ADDR_VAR 0 3
64372: PUSH
64373: LD_INT 11
64375: PUSH
64376: LD_INT 12
64378: PUSH
64379: LD_INT 13
64381: PUSH
64382: LD_INT 14
64384: PUSH
64385: LD_INT 1
64387: PUSH
64388: LD_INT 2
64390: PUSH
64391: LD_INT 3
64393: PUSH
64394: EMPTY
64395: LIST
64396: LIST
64397: LIST
64398: LIST
64399: LIST
64400: LIST
64401: LIST
64402: ST_TO_ADDR
64403: GO 64534
64405: LD_INT 1
64407: DOUBLE
64408: EQUAL
64409: IFTRUE 64413
64411: GO 64475
64413: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
64414: LD_ADDR_VAR 0 3
64418: PUSH
64419: LD_INT 11
64421: PUSH
64422: LD_INT 12
64424: PUSH
64425: LD_INT 13
64427: PUSH
64428: LD_INT 14
64430: PUSH
64431: LD_INT 1
64433: PUSH
64434: LD_INT 2
64436: PUSH
64437: LD_INT 3
64439: PUSH
64440: LD_INT 4
64442: PUSH
64443: LD_INT 5
64445: PUSH
64446: LD_INT 21
64448: PUSH
64449: LD_INT 23
64451: PUSH
64452: LD_INT 22
64454: PUSH
64455: LD_INT 24
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: ST_TO_ADDR
64473: GO 64534
64475: LD_INT 3
64477: DOUBLE
64478: EQUAL
64479: IFTRUE 64483
64481: GO 64533
64483: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
64484: LD_ADDR_VAR 0 3
64488: PUSH
64489: LD_INT 13
64491: PUSH
64492: LD_INT 14
64494: PUSH
64495: LD_INT 2
64497: PUSH
64498: LD_INT 3
64500: PUSH
64501: LD_INT 4
64503: PUSH
64504: LD_INT 5
64506: PUSH
64507: LD_INT 21
64509: PUSH
64510: LD_INT 22
64512: PUSH
64513: LD_INT 23
64515: PUSH
64516: LD_INT 24
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: ST_TO_ADDR
64531: GO 64534
64533: POP
// result := ( chassis in result ) ;
64534: LD_ADDR_VAR 0 3
64538: PUSH
64539: LD_VAR 0 1
64543: PUSH
64544: LD_VAR 0 3
64548: IN
64549: ST_TO_ADDR
// end ;
64550: LD_VAR 0 3
64554: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
64555: LD_INT 0
64557: PPUSH
// if not chassis or not weapon then
64558: LD_VAR 0 1
64562: NOT
64563: PUSH
64564: LD_VAR 0 2
64568: NOT
64569: OR
64570: IFFALSE 64574
// exit ;
64572: GO 65600
// case weapon of us_machine_gun :
64574: LD_VAR 0 2
64578: PUSH
64579: LD_INT 2
64581: DOUBLE
64582: EQUAL
64583: IFTRUE 64587
64585: GO 64617
64587: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
64588: LD_ADDR_VAR 0 3
64592: PUSH
64593: LD_INT 1
64595: PUSH
64596: LD_INT 2
64598: PUSH
64599: LD_INT 3
64601: PUSH
64602: LD_INT 4
64604: PUSH
64605: LD_INT 5
64607: PUSH
64608: EMPTY
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: ST_TO_ADDR
64615: GO 65584
64617: LD_INT 3
64619: DOUBLE
64620: EQUAL
64621: IFTRUE 64625
64623: GO 64655
64625: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
64626: LD_ADDR_VAR 0 3
64630: PUSH
64631: LD_INT 1
64633: PUSH
64634: LD_INT 2
64636: PUSH
64637: LD_INT 3
64639: PUSH
64640: LD_INT 4
64642: PUSH
64643: LD_INT 5
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: LIST
64650: LIST
64651: LIST
64652: ST_TO_ADDR
64653: GO 65584
64655: LD_INT 11
64657: DOUBLE
64658: EQUAL
64659: IFTRUE 64663
64661: GO 64693
64663: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
64664: LD_ADDR_VAR 0 3
64668: PUSH
64669: LD_INT 1
64671: PUSH
64672: LD_INT 2
64674: PUSH
64675: LD_INT 3
64677: PUSH
64678: LD_INT 4
64680: PUSH
64681: LD_INT 5
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: ST_TO_ADDR
64691: GO 65584
64693: LD_INT 4
64695: DOUBLE
64696: EQUAL
64697: IFTRUE 64701
64699: GO 64727
64701: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
64702: LD_ADDR_VAR 0 3
64706: PUSH
64707: LD_INT 2
64709: PUSH
64710: LD_INT 3
64712: PUSH
64713: LD_INT 4
64715: PUSH
64716: LD_INT 5
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: LIST
64723: LIST
64724: ST_TO_ADDR
64725: GO 65584
64727: LD_INT 5
64729: DOUBLE
64730: EQUAL
64731: IFTRUE 64735
64733: GO 64761
64735: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
64736: LD_ADDR_VAR 0 3
64740: PUSH
64741: LD_INT 2
64743: PUSH
64744: LD_INT 3
64746: PUSH
64747: LD_INT 4
64749: PUSH
64750: LD_INT 5
64752: PUSH
64753: EMPTY
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: ST_TO_ADDR
64759: GO 65584
64761: LD_INT 9
64763: DOUBLE
64764: EQUAL
64765: IFTRUE 64769
64767: GO 64795
64769: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
64770: LD_ADDR_VAR 0 3
64774: PUSH
64775: LD_INT 2
64777: PUSH
64778: LD_INT 3
64780: PUSH
64781: LD_INT 4
64783: PUSH
64784: LD_INT 5
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: LIST
64791: LIST
64792: ST_TO_ADDR
64793: GO 65584
64795: LD_INT 7
64797: DOUBLE
64798: EQUAL
64799: IFTRUE 64803
64801: GO 64829
64803: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
64804: LD_ADDR_VAR 0 3
64808: PUSH
64809: LD_INT 2
64811: PUSH
64812: LD_INT 3
64814: PUSH
64815: LD_INT 4
64817: PUSH
64818: LD_INT 5
64820: PUSH
64821: EMPTY
64822: LIST
64823: LIST
64824: LIST
64825: LIST
64826: ST_TO_ADDR
64827: GO 65584
64829: LD_INT 12
64831: DOUBLE
64832: EQUAL
64833: IFTRUE 64837
64835: GO 64863
64837: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
64838: LD_ADDR_VAR 0 3
64842: PUSH
64843: LD_INT 2
64845: PUSH
64846: LD_INT 3
64848: PUSH
64849: LD_INT 4
64851: PUSH
64852: LD_INT 5
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: LIST
64859: LIST
64860: ST_TO_ADDR
64861: GO 65584
64863: LD_INT 13
64865: DOUBLE
64866: EQUAL
64867: IFTRUE 64871
64869: GO 64897
64871: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
64872: LD_ADDR_VAR 0 3
64876: PUSH
64877: LD_INT 2
64879: PUSH
64880: LD_INT 3
64882: PUSH
64883: LD_INT 4
64885: PUSH
64886: LD_INT 5
64888: PUSH
64889: EMPTY
64890: LIST
64891: LIST
64892: LIST
64893: LIST
64894: ST_TO_ADDR
64895: GO 65584
64897: LD_INT 14
64899: DOUBLE
64900: EQUAL
64901: IFTRUE 64905
64903: GO 64923
64905: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
64906: LD_ADDR_VAR 0 3
64910: PUSH
64911: LD_INT 4
64913: PUSH
64914: LD_INT 5
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: ST_TO_ADDR
64921: GO 65584
64923: LD_INT 6
64925: DOUBLE
64926: EQUAL
64927: IFTRUE 64931
64929: GO 64949
64931: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
64932: LD_ADDR_VAR 0 3
64936: PUSH
64937: LD_INT 4
64939: PUSH
64940: LD_INT 5
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: ST_TO_ADDR
64947: GO 65584
64949: LD_INT 10
64951: DOUBLE
64952: EQUAL
64953: IFTRUE 64957
64955: GO 64975
64957: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
64958: LD_ADDR_VAR 0 3
64962: PUSH
64963: LD_INT 4
64965: PUSH
64966: LD_INT 5
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: ST_TO_ADDR
64973: GO 65584
64975: LD_INT 22
64977: DOUBLE
64978: EQUAL
64979: IFTRUE 64983
64981: GO 65009
64983: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
64984: LD_ADDR_VAR 0 3
64988: PUSH
64989: LD_INT 11
64991: PUSH
64992: LD_INT 12
64994: PUSH
64995: LD_INT 13
64997: PUSH
64998: LD_INT 14
65000: PUSH
65001: EMPTY
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: ST_TO_ADDR
65007: GO 65584
65009: LD_INT 23
65011: DOUBLE
65012: EQUAL
65013: IFTRUE 65017
65015: GO 65043
65017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
65018: LD_ADDR_VAR 0 3
65022: PUSH
65023: LD_INT 11
65025: PUSH
65026: LD_INT 12
65028: PUSH
65029: LD_INT 13
65031: PUSH
65032: LD_INT 14
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: LIST
65039: LIST
65040: ST_TO_ADDR
65041: GO 65584
65043: LD_INT 24
65045: DOUBLE
65046: EQUAL
65047: IFTRUE 65051
65049: GO 65077
65051: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
65052: LD_ADDR_VAR 0 3
65056: PUSH
65057: LD_INT 11
65059: PUSH
65060: LD_INT 12
65062: PUSH
65063: LD_INT 13
65065: PUSH
65066: LD_INT 14
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: LIST
65073: LIST
65074: ST_TO_ADDR
65075: GO 65584
65077: LD_INT 30
65079: DOUBLE
65080: EQUAL
65081: IFTRUE 65085
65083: GO 65111
65085: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
65086: LD_ADDR_VAR 0 3
65090: PUSH
65091: LD_INT 11
65093: PUSH
65094: LD_INT 12
65096: PUSH
65097: LD_INT 13
65099: PUSH
65100: LD_INT 14
65102: PUSH
65103: EMPTY
65104: LIST
65105: LIST
65106: LIST
65107: LIST
65108: ST_TO_ADDR
65109: GO 65584
65111: LD_INT 25
65113: DOUBLE
65114: EQUAL
65115: IFTRUE 65119
65117: GO 65137
65119: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
65120: LD_ADDR_VAR 0 3
65124: PUSH
65125: LD_INT 13
65127: PUSH
65128: LD_INT 14
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: ST_TO_ADDR
65135: GO 65584
65137: LD_INT 27
65139: DOUBLE
65140: EQUAL
65141: IFTRUE 65145
65143: GO 65163
65145: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
65146: LD_ADDR_VAR 0 3
65150: PUSH
65151: LD_INT 13
65153: PUSH
65154: LD_INT 14
65156: PUSH
65157: EMPTY
65158: LIST
65159: LIST
65160: ST_TO_ADDR
65161: GO 65584
65163: LD_INT 28
65165: DOUBLE
65166: EQUAL
65167: IFTRUE 65171
65169: GO 65189
65171: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
65172: LD_ADDR_VAR 0 3
65176: PUSH
65177: LD_INT 13
65179: PUSH
65180: LD_INT 14
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: ST_TO_ADDR
65187: GO 65584
65189: LD_INT 29
65191: DOUBLE
65192: EQUAL
65193: IFTRUE 65197
65195: GO 65215
65197: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
65198: LD_ADDR_VAR 0 3
65202: PUSH
65203: LD_INT 13
65205: PUSH
65206: LD_INT 14
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: ST_TO_ADDR
65213: GO 65584
65215: LD_INT 31
65217: DOUBLE
65218: EQUAL
65219: IFTRUE 65223
65221: GO 65241
65223: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
65224: LD_ADDR_VAR 0 3
65228: PUSH
65229: LD_INT 13
65231: PUSH
65232: LD_INT 14
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: ST_TO_ADDR
65239: GO 65584
65241: LD_INT 26
65243: DOUBLE
65244: EQUAL
65245: IFTRUE 65249
65247: GO 65267
65249: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
65250: LD_ADDR_VAR 0 3
65254: PUSH
65255: LD_INT 13
65257: PUSH
65258: LD_INT 14
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: ST_TO_ADDR
65265: GO 65584
65267: LD_INT 42
65269: DOUBLE
65270: EQUAL
65271: IFTRUE 65275
65273: GO 65301
65275: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
65276: LD_ADDR_VAR 0 3
65280: PUSH
65281: LD_INT 21
65283: PUSH
65284: LD_INT 22
65286: PUSH
65287: LD_INT 23
65289: PUSH
65290: LD_INT 24
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: LIST
65297: LIST
65298: ST_TO_ADDR
65299: GO 65584
65301: LD_INT 43
65303: DOUBLE
65304: EQUAL
65305: IFTRUE 65309
65307: GO 65335
65309: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
65310: LD_ADDR_VAR 0 3
65314: PUSH
65315: LD_INT 21
65317: PUSH
65318: LD_INT 22
65320: PUSH
65321: LD_INT 23
65323: PUSH
65324: LD_INT 24
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: LIST
65331: LIST
65332: ST_TO_ADDR
65333: GO 65584
65335: LD_INT 44
65337: DOUBLE
65338: EQUAL
65339: IFTRUE 65343
65341: GO 65369
65343: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
65344: LD_ADDR_VAR 0 3
65348: PUSH
65349: LD_INT 21
65351: PUSH
65352: LD_INT 22
65354: PUSH
65355: LD_INT 23
65357: PUSH
65358: LD_INT 24
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: ST_TO_ADDR
65367: GO 65584
65369: LD_INT 45
65371: DOUBLE
65372: EQUAL
65373: IFTRUE 65377
65375: GO 65403
65377: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
65378: LD_ADDR_VAR 0 3
65382: PUSH
65383: LD_INT 21
65385: PUSH
65386: LD_INT 22
65388: PUSH
65389: LD_INT 23
65391: PUSH
65392: LD_INT 24
65394: PUSH
65395: EMPTY
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: ST_TO_ADDR
65401: GO 65584
65403: LD_INT 49
65405: DOUBLE
65406: EQUAL
65407: IFTRUE 65411
65409: GO 65437
65411: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
65412: LD_ADDR_VAR 0 3
65416: PUSH
65417: LD_INT 21
65419: PUSH
65420: LD_INT 22
65422: PUSH
65423: LD_INT 23
65425: PUSH
65426: LD_INT 24
65428: PUSH
65429: EMPTY
65430: LIST
65431: LIST
65432: LIST
65433: LIST
65434: ST_TO_ADDR
65435: GO 65584
65437: LD_INT 51
65439: DOUBLE
65440: EQUAL
65441: IFTRUE 65445
65443: GO 65471
65445: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
65446: LD_ADDR_VAR 0 3
65450: PUSH
65451: LD_INT 21
65453: PUSH
65454: LD_INT 22
65456: PUSH
65457: LD_INT 23
65459: PUSH
65460: LD_INT 24
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: ST_TO_ADDR
65469: GO 65584
65471: LD_INT 52
65473: DOUBLE
65474: EQUAL
65475: IFTRUE 65479
65477: GO 65505
65479: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
65480: LD_ADDR_VAR 0 3
65484: PUSH
65485: LD_INT 21
65487: PUSH
65488: LD_INT 22
65490: PUSH
65491: LD_INT 23
65493: PUSH
65494: LD_INT 24
65496: PUSH
65497: EMPTY
65498: LIST
65499: LIST
65500: LIST
65501: LIST
65502: ST_TO_ADDR
65503: GO 65584
65505: LD_INT 53
65507: DOUBLE
65508: EQUAL
65509: IFTRUE 65513
65511: GO 65531
65513: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
65514: LD_ADDR_VAR 0 3
65518: PUSH
65519: LD_INT 23
65521: PUSH
65522: LD_INT 24
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: ST_TO_ADDR
65529: GO 65584
65531: LD_INT 46
65533: DOUBLE
65534: EQUAL
65535: IFTRUE 65539
65537: GO 65557
65539: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
65540: LD_ADDR_VAR 0 3
65544: PUSH
65545: LD_INT 23
65547: PUSH
65548: LD_INT 24
65550: PUSH
65551: EMPTY
65552: LIST
65553: LIST
65554: ST_TO_ADDR
65555: GO 65584
65557: LD_INT 47
65559: DOUBLE
65560: EQUAL
65561: IFTRUE 65565
65563: GO 65583
65565: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
65566: LD_ADDR_VAR 0 3
65570: PUSH
65571: LD_INT 23
65573: PUSH
65574: LD_INT 24
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: ST_TO_ADDR
65581: GO 65584
65583: POP
// result := ( chassis in result ) ;
65584: LD_ADDR_VAR 0 3
65588: PUSH
65589: LD_VAR 0 1
65593: PUSH
65594: LD_VAR 0 3
65598: IN
65599: ST_TO_ADDR
// end ;
65600: LD_VAR 0 3
65604: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
65605: LD_INT 0
65607: PPUSH
65608: PPUSH
65609: PPUSH
65610: PPUSH
65611: PPUSH
65612: PPUSH
65613: PPUSH
// result := array ;
65614: LD_ADDR_VAR 0 5
65618: PUSH
65619: LD_VAR 0 1
65623: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
65624: LD_VAR 0 1
65628: NOT
65629: PUSH
65630: LD_VAR 0 2
65634: NOT
65635: OR
65636: PUSH
65637: LD_VAR 0 3
65641: NOT
65642: OR
65643: PUSH
65644: LD_VAR 0 2
65648: PUSH
65649: LD_VAR 0 1
65653: GREATER
65654: OR
65655: PUSH
65656: LD_VAR 0 3
65660: PUSH
65661: LD_VAR 0 1
65665: GREATER
65666: OR
65667: IFFALSE 65671
// exit ;
65669: GO 65967
// if direction then
65671: LD_VAR 0 4
65675: IFFALSE 65739
// begin d := 1 ;
65677: LD_ADDR_VAR 0 9
65681: PUSH
65682: LD_INT 1
65684: ST_TO_ADDR
// if i_from > i_to then
65685: LD_VAR 0 2
65689: PUSH
65690: LD_VAR 0 3
65694: GREATER
65695: IFFALSE 65721
// length := ( array - i_from ) + i_to else
65697: LD_ADDR_VAR 0 11
65701: PUSH
65702: LD_VAR 0 1
65706: PUSH
65707: LD_VAR 0 2
65711: MINUS
65712: PUSH
65713: LD_VAR 0 3
65717: PLUS
65718: ST_TO_ADDR
65719: GO 65737
// length := i_to - i_from ;
65721: LD_ADDR_VAR 0 11
65725: PUSH
65726: LD_VAR 0 3
65730: PUSH
65731: LD_VAR 0 2
65735: MINUS
65736: ST_TO_ADDR
// end else
65737: GO 65800
// begin d := - 1 ;
65739: LD_ADDR_VAR 0 9
65743: PUSH
65744: LD_INT 1
65746: NEG
65747: ST_TO_ADDR
// if i_from > i_to then
65748: LD_VAR 0 2
65752: PUSH
65753: LD_VAR 0 3
65757: GREATER
65758: IFFALSE 65778
// length := i_from - i_to else
65760: LD_ADDR_VAR 0 11
65764: PUSH
65765: LD_VAR 0 2
65769: PUSH
65770: LD_VAR 0 3
65774: MINUS
65775: ST_TO_ADDR
65776: GO 65800
// length := ( array - i_to ) + i_from ;
65778: LD_ADDR_VAR 0 11
65782: PUSH
65783: LD_VAR 0 1
65787: PUSH
65788: LD_VAR 0 3
65792: MINUS
65793: PUSH
65794: LD_VAR 0 2
65798: PLUS
65799: ST_TO_ADDR
// end ; if not length then
65800: LD_VAR 0 11
65804: NOT
65805: IFFALSE 65809
// exit ;
65807: GO 65967
// tmp := array ;
65809: LD_ADDR_VAR 0 10
65813: PUSH
65814: LD_VAR 0 1
65818: ST_TO_ADDR
// for i = 1 to length do
65819: LD_ADDR_VAR 0 6
65823: PUSH
65824: DOUBLE
65825: LD_INT 1
65827: DEC
65828: ST_TO_ADDR
65829: LD_VAR 0 11
65833: PUSH
65834: FOR_TO
65835: IFFALSE 65955
// begin for j = 1 to array do
65837: LD_ADDR_VAR 0 7
65841: PUSH
65842: DOUBLE
65843: LD_INT 1
65845: DEC
65846: ST_TO_ADDR
65847: LD_VAR 0 1
65851: PUSH
65852: FOR_TO
65853: IFFALSE 65941
// begin k := j + d ;
65855: LD_ADDR_VAR 0 8
65859: PUSH
65860: LD_VAR 0 7
65864: PUSH
65865: LD_VAR 0 9
65869: PLUS
65870: ST_TO_ADDR
// if k > array then
65871: LD_VAR 0 8
65875: PUSH
65876: LD_VAR 0 1
65880: GREATER
65881: IFFALSE 65891
// k := 1 ;
65883: LD_ADDR_VAR 0 8
65887: PUSH
65888: LD_INT 1
65890: ST_TO_ADDR
// if not k then
65891: LD_VAR 0 8
65895: NOT
65896: IFFALSE 65908
// k := array ;
65898: LD_ADDR_VAR 0 8
65902: PUSH
65903: LD_VAR 0 1
65907: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
65908: LD_ADDR_VAR 0 10
65912: PUSH
65913: LD_VAR 0 10
65917: PPUSH
65918: LD_VAR 0 8
65922: PPUSH
65923: LD_VAR 0 1
65927: PUSH
65928: LD_VAR 0 7
65932: ARRAY
65933: PPUSH
65934: CALL_OW 1
65938: ST_TO_ADDR
// end ;
65939: GO 65852
65941: POP
65942: POP
// array := tmp ;
65943: LD_ADDR_VAR 0 1
65947: PUSH
65948: LD_VAR 0 10
65952: ST_TO_ADDR
// end ;
65953: GO 65834
65955: POP
65956: POP
// result := array ;
65957: LD_ADDR_VAR 0 5
65961: PUSH
65962: LD_VAR 0 1
65966: ST_TO_ADDR
// end ;
65967: LD_VAR 0 5
65971: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
65972: LD_INT 0
65974: PPUSH
65975: PPUSH
// result := 0 ;
65976: LD_ADDR_VAR 0 3
65980: PUSH
65981: LD_INT 0
65983: ST_TO_ADDR
// if not array or not value in array then
65984: LD_VAR 0 1
65988: NOT
65989: PUSH
65990: LD_VAR 0 2
65994: PUSH
65995: LD_VAR 0 1
65999: IN
66000: NOT
66001: OR
66002: IFFALSE 66006
// exit ;
66004: GO 66060
// for i = 1 to array do
66006: LD_ADDR_VAR 0 4
66010: PUSH
66011: DOUBLE
66012: LD_INT 1
66014: DEC
66015: ST_TO_ADDR
66016: LD_VAR 0 1
66020: PUSH
66021: FOR_TO
66022: IFFALSE 66058
// if value = array [ i ] then
66024: LD_VAR 0 2
66028: PUSH
66029: LD_VAR 0 1
66033: PUSH
66034: LD_VAR 0 4
66038: ARRAY
66039: EQUAL
66040: IFFALSE 66056
// begin result := i ;
66042: LD_ADDR_VAR 0 3
66046: PUSH
66047: LD_VAR 0 4
66051: ST_TO_ADDR
// exit ;
66052: POP
66053: POP
66054: GO 66060
// end ;
66056: GO 66021
66058: POP
66059: POP
// end ;
66060: LD_VAR 0 3
66064: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
66065: LD_INT 0
66067: PPUSH
// vc_chassis := chassis ;
66068: LD_ADDR_OWVAR 37
66072: PUSH
66073: LD_VAR 0 1
66077: ST_TO_ADDR
// vc_engine := engine ;
66078: LD_ADDR_OWVAR 39
66082: PUSH
66083: LD_VAR 0 2
66087: ST_TO_ADDR
// vc_control := control ;
66088: LD_ADDR_OWVAR 38
66092: PUSH
66093: LD_VAR 0 3
66097: ST_TO_ADDR
// vc_weapon := weapon ;
66098: LD_ADDR_OWVAR 40
66102: PUSH
66103: LD_VAR 0 4
66107: ST_TO_ADDR
// vc_fuel_battery := fuel ;
66108: LD_ADDR_OWVAR 41
66112: PUSH
66113: LD_VAR 0 5
66117: ST_TO_ADDR
// end ;
66118: LD_VAR 0 6
66122: RET
// export function WantPlant ( unit ) ; var task ; begin
66123: LD_INT 0
66125: PPUSH
66126: PPUSH
// result := false ;
66127: LD_ADDR_VAR 0 2
66131: PUSH
66132: LD_INT 0
66134: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
66135: LD_ADDR_VAR 0 3
66139: PUSH
66140: LD_VAR 0 1
66144: PPUSH
66145: CALL_OW 437
66149: ST_TO_ADDR
// if task then
66150: LD_VAR 0 3
66154: IFFALSE 66182
// if task [ 1 ] [ 1 ] = p then
66156: LD_VAR 0 3
66160: PUSH
66161: LD_INT 1
66163: ARRAY
66164: PUSH
66165: LD_INT 1
66167: ARRAY
66168: PUSH
66169: LD_STRING p
66171: EQUAL
66172: IFFALSE 66182
// result := true ;
66174: LD_ADDR_VAR 0 2
66178: PUSH
66179: LD_INT 1
66181: ST_TO_ADDR
// end ;
66182: LD_VAR 0 2
66186: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
66187: LD_INT 0
66189: PPUSH
66190: PPUSH
66191: PPUSH
66192: PPUSH
// if pos < 1 then
66193: LD_VAR 0 2
66197: PUSH
66198: LD_INT 1
66200: LESS
66201: IFFALSE 66205
// exit ;
66203: GO 66508
// if pos = 1 then
66205: LD_VAR 0 2
66209: PUSH
66210: LD_INT 1
66212: EQUAL
66213: IFFALSE 66246
// result := Replace ( arr , pos [ 1 ] , value ) else
66215: LD_ADDR_VAR 0 4
66219: PUSH
66220: LD_VAR 0 1
66224: PPUSH
66225: LD_VAR 0 2
66229: PUSH
66230: LD_INT 1
66232: ARRAY
66233: PPUSH
66234: LD_VAR 0 3
66238: PPUSH
66239: CALL_OW 1
66243: ST_TO_ADDR
66244: GO 66508
// begin tmp := arr ;
66246: LD_ADDR_VAR 0 6
66250: PUSH
66251: LD_VAR 0 1
66255: ST_TO_ADDR
// s_arr := [ tmp ] ;
66256: LD_ADDR_VAR 0 7
66260: PUSH
66261: LD_VAR 0 6
66265: PUSH
66266: EMPTY
66267: LIST
66268: ST_TO_ADDR
// for i = 1 to pos - 1 do
66269: LD_ADDR_VAR 0 5
66273: PUSH
66274: DOUBLE
66275: LD_INT 1
66277: DEC
66278: ST_TO_ADDR
66279: LD_VAR 0 2
66283: PUSH
66284: LD_INT 1
66286: MINUS
66287: PUSH
66288: FOR_TO
66289: IFFALSE 66334
// begin tmp := tmp [ pos [ i ] ] ;
66291: LD_ADDR_VAR 0 6
66295: PUSH
66296: LD_VAR 0 6
66300: PUSH
66301: LD_VAR 0 2
66305: PUSH
66306: LD_VAR 0 5
66310: ARRAY
66311: ARRAY
66312: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
66313: LD_ADDR_VAR 0 7
66317: PUSH
66318: LD_VAR 0 7
66322: PUSH
66323: LD_VAR 0 6
66327: PUSH
66328: EMPTY
66329: LIST
66330: ADD
66331: ST_TO_ADDR
// end ;
66332: GO 66288
66334: POP
66335: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
66336: LD_ADDR_VAR 0 6
66340: PUSH
66341: LD_VAR 0 6
66345: PPUSH
66346: LD_VAR 0 2
66350: PUSH
66351: LD_VAR 0 2
66355: ARRAY
66356: PPUSH
66357: LD_VAR 0 3
66361: PPUSH
66362: CALL_OW 1
66366: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
66367: LD_ADDR_VAR 0 7
66371: PUSH
66372: LD_VAR 0 7
66376: PPUSH
66377: LD_VAR 0 7
66381: PPUSH
66382: LD_VAR 0 6
66386: PPUSH
66387: CALL_OW 1
66391: ST_TO_ADDR
// for i = s_arr downto 2 do
66392: LD_ADDR_VAR 0 5
66396: PUSH
66397: DOUBLE
66398: LD_VAR 0 7
66402: INC
66403: ST_TO_ADDR
66404: LD_INT 2
66406: PUSH
66407: FOR_DOWNTO
66408: IFFALSE 66492
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
66410: LD_ADDR_VAR 0 6
66414: PUSH
66415: LD_VAR 0 7
66419: PUSH
66420: LD_VAR 0 5
66424: PUSH
66425: LD_INT 1
66427: MINUS
66428: ARRAY
66429: PPUSH
66430: LD_VAR 0 2
66434: PUSH
66435: LD_VAR 0 5
66439: PUSH
66440: LD_INT 1
66442: MINUS
66443: ARRAY
66444: PPUSH
66445: LD_VAR 0 7
66449: PUSH
66450: LD_VAR 0 5
66454: ARRAY
66455: PPUSH
66456: CALL_OW 1
66460: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
66461: LD_ADDR_VAR 0 7
66465: PUSH
66466: LD_VAR 0 7
66470: PPUSH
66471: LD_VAR 0 5
66475: PUSH
66476: LD_INT 1
66478: MINUS
66479: PPUSH
66480: LD_VAR 0 6
66484: PPUSH
66485: CALL_OW 1
66489: ST_TO_ADDR
// end ;
66490: GO 66407
66492: POP
66493: POP
// result := s_arr [ 1 ] ;
66494: LD_ADDR_VAR 0 4
66498: PUSH
66499: LD_VAR 0 7
66503: PUSH
66504: LD_INT 1
66506: ARRAY
66507: ST_TO_ADDR
// end ; end ;
66508: LD_VAR 0 4
66512: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
66513: LD_INT 0
66515: PPUSH
66516: PPUSH
// if not list then
66517: LD_VAR 0 1
66521: NOT
66522: IFFALSE 66526
// exit ;
66524: GO 66617
// i := list [ pos1 ] ;
66526: LD_ADDR_VAR 0 5
66530: PUSH
66531: LD_VAR 0 1
66535: PUSH
66536: LD_VAR 0 2
66540: ARRAY
66541: ST_TO_ADDR
// if not i then
66542: LD_VAR 0 5
66546: NOT
66547: IFFALSE 66551
// exit ;
66549: GO 66617
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
66551: LD_ADDR_VAR 0 1
66555: PUSH
66556: LD_VAR 0 1
66560: PPUSH
66561: LD_VAR 0 2
66565: PPUSH
66566: LD_VAR 0 1
66570: PUSH
66571: LD_VAR 0 3
66575: ARRAY
66576: PPUSH
66577: CALL_OW 1
66581: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
66582: LD_ADDR_VAR 0 1
66586: PUSH
66587: LD_VAR 0 1
66591: PPUSH
66592: LD_VAR 0 3
66596: PPUSH
66597: LD_VAR 0 5
66601: PPUSH
66602: CALL_OW 1
66606: ST_TO_ADDR
// result := list ;
66607: LD_ADDR_VAR 0 4
66611: PUSH
66612: LD_VAR 0 1
66616: ST_TO_ADDR
// end ;
66617: LD_VAR 0 4
66621: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
66622: LD_INT 0
66624: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
66625: LD_ADDR_VAR 0 5
66629: PUSH
66630: LD_VAR 0 1
66634: PPUSH
66635: CALL_OW 250
66639: PPUSH
66640: LD_VAR 0 1
66644: PPUSH
66645: CALL_OW 251
66649: PPUSH
66650: LD_VAR 0 2
66654: PPUSH
66655: LD_VAR 0 3
66659: PPUSH
66660: LD_VAR 0 4
66664: PPUSH
66665: CALL 66675 0 5
66669: ST_TO_ADDR
// end ;
66670: LD_VAR 0 5
66674: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
66675: LD_INT 0
66677: PPUSH
66678: PPUSH
66679: PPUSH
66680: PPUSH
// if not list then
66681: LD_VAR 0 3
66685: NOT
66686: IFFALSE 66690
// exit ;
66688: GO 67078
// result := [ ] ;
66690: LD_ADDR_VAR 0 6
66694: PUSH
66695: EMPTY
66696: ST_TO_ADDR
// for i in list do
66697: LD_ADDR_VAR 0 7
66701: PUSH
66702: LD_VAR 0 3
66706: PUSH
66707: FOR_IN
66708: IFFALSE 66910
// begin tmp := GetDistUnitXY ( i , x , y ) ;
66710: LD_ADDR_VAR 0 9
66714: PUSH
66715: LD_VAR 0 7
66719: PPUSH
66720: LD_VAR 0 1
66724: PPUSH
66725: LD_VAR 0 2
66729: PPUSH
66730: CALL_OW 297
66734: ST_TO_ADDR
// if not result then
66735: LD_VAR 0 6
66739: NOT
66740: IFFALSE 66766
// result := [ [ i , tmp ] ] else
66742: LD_ADDR_VAR 0 6
66746: PUSH
66747: LD_VAR 0 7
66751: PUSH
66752: LD_VAR 0 9
66756: PUSH
66757: EMPTY
66758: LIST
66759: LIST
66760: PUSH
66761: EMPTY
66762: LIST
66763: ST_TO_ADDR
66764: GO 66908
// begin if result [ result ] [ 2 ] < tmp then
66766: LD_VAR 0 6
66770: PUSH
66771: LD_VAR 0 6
66775: ARRAY
66776: PUSH
66777: LD_INT 2
66779: ARRAY
66780: PUSH
66781: LD_VAR 0 9
66785: LESS
66786: IFFALSE 66828
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
66788: LD_ADDR_VAR 0 6
66792: PUSH
66793: LD_VAR 0 6
66797: PPUSH
66798: LD_VAR 0 6
66802: PUSH
66803: LD_INT 1
66805: PLUS
66806: PPUSH
66807: LD_VAR 0 7
66811: PUSH
66812: LD_VAR 0 9
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: PPUSH
66821: CALL_OW 2
66825: ST_TO_ADDR
66826: GO 66908
// for j = 1 to result do
66828: LD_ADDR_VAR 0 8
66832: PUSH
66833: DOUBLE
66834: LD_INT 1
66836: DEC
66837: ST_TO_ADDR
66838: LD_VAR 0 6
66842: PUSH
66843: FOR_TO
66844: IFFALSE 66906
// begin if tmp < result [ j ] [ 2 ] then
66846: LD_VAR 0 9
66850: PUSH
66851: LD_VAR 0 6
66855: PUSH
66856: LD_VAR 0 8
66860: ARRAY
66861: PUSH
66862: LD_INT 2
66864: ARRAY
66865: LESS
66866: IFFALSE 66904
// begin result := Insert ( result , j , [ i , tmp ] ) ;
66868: LD_ADDR_VAR 0 6
66872: PUSH
66873: LD_VAR 0 6
66877: PPUSH
66878: LD_VAR 0 8
66882: PPUSH
66883: LD_VAR 0 7
66887: PUSH
66888: LD_VAR 0 9
66892: PUSH
66893: EMPTY
66894: LIST
66895: LIST
66896: PPUSH
66897: CALL_OW 2
66901: ST_TO_ADDR
// break ;
66902: GO 66906
// end ; end ;
66904: GO 66843
66906: POP
66907: POP
// end ; end ;
66908: GO 66707
66910: POP
66911: POP
// if result and not asc then
66912: LD_VAR 0 6
66916: PUSH
66917: LD_VAR 0 4
66921: NOT
66922: AND
66923: IFFALSE 66998
// begin tmp := result ;
66925: LD_ADDR_VAR 0 9
66929: PUSH
66930: LD_VAR 0 6
66934: ST_TO_ADDR
// for i = tmp downto 1 do
66935: LD_ADDR_VAR 0 7
66939: PUSH
66940: DOUBLE
66941: LD_VAR 0 9
66945: INC
66946: ST_TO_ADDR
66947: LD_INT 1
66949: PUSH
66950: FOR_DOWNTO
66951: IFFALSE 66996
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
66953: LD_ADDR_VAR 0 6
66957: PUSH
66958: LD_VAR 0 6
66962: PPUSH
66963: LD_VAR 0 9
66967: PUSH
66968: LD_VAR 0 7
66972: MINUS
66973: PUSH
66974: LD_INT 1
66976: PLUS
66977: PPUSH
66978: LD_VAR 0 9
66982: PUSH
66983: LD_VAR 0 7
66987: ARRAY
66988: PPUSH
66989: CALL_OW 1
66993: ST_TO_ADDR
66994: GO 66950
66996: POP
66997: POP
// end ; tmp := [ ] ;
66998: LD_ADDR_VAR 0 9
67002: PUSH
67003: EMPTY
67004: ST_TO_ADDR
// if mode then
67005: LD_VAR 0 5
67009: IFFALSE 67078
// begin for i = 1 to result do
67011: LD_ADDR_VAR 0 7
67015: PUSH
67016: DOUBLE
67017: LD_INT 1
67019: DEC
67020: ST_TO_ADDR
67021: LD_VAR 0 6
67025: PUSH
67026: FOR_TO
67027: IFFALSE 67066
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
67029: LD_ADDR_VAR 0 9
67033: PUSH
67034: LD_VAR 0 9
67038: PPUSH
67039: LD_VAR 0 7
67043: PPUSH
67044: LD_VAR 0 6
67048: PUSH
67049: LD_VAR 0 7
67053: ARRAY
67054: PUSH
67055: LD_INT 1
67057: ARRAY
67058: PPUSH
67059: CALL_OW 1
67063: ST_TO_ADDR
67064: GO 67026
67066: POP
67067: POP
// result := tmp ;
67068: LD_ADDR_VAR 0 6
67072: PUSH
67073: LD_VAR 0 9
67077: ST_TO_ADDR
// end ; end ;
67078: LD_VAR 0 6
67082: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
67083: LD_INT 0
67085: PPUSH
67086: PPUSH
67087: PPUSH
67088: PPUSH
67089: PPUSH
67090: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
67091: LD_ADDR_VAR 0 5
67095: PUSH
67096: LD_INT 0
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: LD_INT 0
67104: PUSH
67105: EMPTY
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: LIST
67111: LIST
67112: ST_TO_ADDR
// if not x or not y then
67113: LD_VAR 0 2
67117: NOT
67118: PUSH
67119: LD_VAR 0 3
67123: NOT
67124: OR
67125: IFFALSE 67129
// exit ;
67127: GO 68775
// if not range then
67129: LD_VAR 0 4
67133: NOT
67134: IFFALSE 67144
// range := 10 ;
67136: LD_ADDR_VAR 0 4
67140: PUSH
67141: LD_INT 10
67143: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67144: LD_ADDR_VAR 0 8
67148: PUSH
67149: LD_INT 81
67151: PUSH
67152: LD_VAR 0 1
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 92
67163: PUSH
67164: LD_VAR 0 2
67168: PUSH
67169: LD_VAR 0 3
67173: PUSH
67174: LD_VAR 0 4
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: LIST
67183: LIST
67184: PUSH
67185: LD_INT 3
67187: PUSH
67188: LD_INT 21
67190: PUSH
67191: LD_INT 3
67193: PUSH
67194: EMPTY
67195: LIST
67196: LIST
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: LIST
67206: PPUSH
67207: CALL_OW 69
67211: ST_TO_ADDR
// if not tmp then
67212: LD_VAR 0 8
67216: NOT
67217: IFFALSE 67221
// exit ;
67219: GO 68775
// for i in tmp do
67221: LD_ADDR_VAR 0 6
67225: PUSH
67226: LD_VAR 0 8
67230: PUSH
67231: FOR_IN
67232: IFFALSE 68750
// begin points := [ 0 , 0 , 0 ] ;
67234: LD_ADDR_VAR 0 9
67238: PUSH
67239: LD_INT 0
67241: PUSH
67242: LD_INT 0
67244: PUSH
67245: LD_INT 0
67247: PUSH
67248: EMPTY
67249: LIST
67250: LIST
67251: LIST
67252: ST_TO_ADDR
// bpoints := 1 ;
67253: LD_ADDR_VAR 0 10
67257: PUSH
67258: LD_INT 1
67260: ST_TO_ADDR
// case GetType ( i ) of unit_human :
67261: LD_VAR 0 6
67265: PPUSH
67266: CALL_OW 247
67270: PUSH
67271: LD_INT 1
67273: DOUBLE
67274: EQUAL
67275: IFTRUE 67279
67277: GO 67857
67279: POP
// begin if GetClass ( i ) = 1 then
67280: LD_VAR 0 6
67284: PPUSH
67285: CALL_OW 257
67289: PUSH
67290: LD_INT 1
67292: EQUAL
67293: IFFALSE 67314
// points := [ 10 , 5 , 3 ] ;
67295: LD_ADDR_VAR 0 9
67299: PUSH
67300: LD_INT 10
67302: PUSH
67303: LD_INT 5
67305: PUSH
67306: LD_INT 3
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: LIST
67313: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
67314: LD_VAR 0 6
67318: PPUSH
67319: CALL_OW 257
67323: PUSH
67324: LD_INT 2
67326: PUSH
67327: LD_INT 3
67329: PUSH
67330: LD_INT 4
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: LIST
67337: IN
67338: IFFALSE 67359
// points := [ 3 , 2 , 1 ] ;
67340: LD_ADDR_VAR 0 9
67344: PUSH
67345: LD_INT 3
67347: PUSH
67348: LD_INT 2
67350: PUSH
67351: LD_INT 1
67353: PUSH
67354: EMPTY
67355: LIST
67356: LIST
67357: LIST
67358: ST_TO_ADDR
// if GetClass ( i ) = 5 then
67359: LD_VAR 0 6
67363: PPUSH
67364: CALL_OW 257
67368: PUSH
67369: LD_INT 5
67371: EQUAL
67372: IFFALSE 67393
// points := [ 130 , 5 , 2 ] ;
67374: LD_ADDR_VAR 0 9
67378: PUSH
67379: LD_INT 130
67381: PUSH
67382: LD_INT 5
67384: PUSH
67385: LD_INT 2
67387: PUSH
67388: EMPTY
67389: LIST
67390: LIST
67391: LIST
67392: ST_TO_ADDR
// if GetClass ( i ) = 8 then
67393: LD_VAR 0 6
67397: PPUSH
67398: CALL_OW 257
67402: PUSH
67403: LD_INT 8
67405: EQUAL
67406: IFFALSE 67427
// points := [ 35 , 35 , 30 ] ;
67408: LD_ADDR_VAR 0 9
67412: PUSH
67413: LD_INT 35
67415: PUSH
67416: LD_INT 35
67418: PUSH
67419: LD_INT 30
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: LIST
67426: ST_TO_ADDR
// if GetClass ( i ) = 9 then
67427: LD_VAR 0 6
67431: PPUSH
67432: CALL_OW 257
67436: PUSH
67437: LD_INT 9
67439: EQUAL
67440: IFFALSE 67461
// points := [ 20 , 55 , 40 ] ;
67442: LD_ADDR_VAR 0 9
67446: PUSH
67447: LD_INT 20
67449: PUSH
67450: LD_INT 55
67452: PUSH
67453: LD_INT 40
67455: PUSH
67456: EMPTY
67457: LIST
67458: LIST
67459: LIST
67460: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
67461: LD_VAR 0 6
67465: PPUSH
67466: CALL_OW 257
67470: PUSH
67471: LD_INT 12
67473: PUSH
67474: LD_INT 16
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: IN
67481: IFFALSE 67502
// points := [ 5 , 3 , 2 ] ;
67483: LD_ADDR_VAR 0 9
67487: PUSH
67488: LD_INT 5
67490: PUSH
67491: LD_INT 3
67493: PUSH
67494: LD_INT 2
67496: PUSH
67497: EMPTY
67498: LIST
67499: LIST
67500: LIST
67501: ST_TO_ADDR
// if GetClass ( i ) = 17 then
67502: LD_VAR 0 6
67506: PPUSH
67507: CALL_OW 257
67511: PUSH
67512: LD_INT 17
67514: EQUAL
67515: IFFALSE 67536
// points := [ 100 , 50 , 75 ] ;
67517: LD_ADDR_VAR 0 9
67521: PUSH
67522: LD_INT 100
67524: PUSH
67525: LD_INT 50
67527: PUSH
67528: LD_INT 75
67530: PUSH
67531: EMPTY
67532: LIST
67533: LIST
67534: LIST
67535: ST_TO_ADDR
// if GetClass ( i ) = 15 then
67536: LD_VAR 0 6
67540: PPUSH
67541: CALL_OW 257
67545: PUSH
67546: LD_INT 15
67548: EQUAL
67549: IFFALSE 67570
// points := [ 10 , 5 , 3 ] ;
67551: LD_ADDR_VAR 0 9
67555: PUSH
67556: LD_INT 10
67558: PUSH
67559: LD_INT 5
67561: PUSH
67562: LD_INT 3
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: LIST
67569: ST_TO_ADDR
// if GetClass ( i ) = 14 then
67570: LD_VAR 0 6
67574: PPUSH
67575: CALL_OW 257
67579: PUSH
67580: LD_INT 14
67582: EQUAL
67583: IFFALSE 67604
// points := [ 10 , 0 , 0 ] ;
67585: LD_ADDR_VAR 0 9
67589: PUSH
67590: LD_INT 10
67592: PUSH
67593: LD_INT 0
67595: PUSH
67596: LD_INT 0
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: LIST
67603: ST_TO_ADDR
// if GetClass ( i ) = 11 then
67604: LD_VAR 0 6
67608: PPUSH
67609: CALL_OW 257
67613: PUSH
67614: LD_INT 11
67616: EQUAL
67617: IFFALSE 67638
// points := [ 30 , 10 , 5 ] ;
67619: LD_ADDR_VAR 0 9
67623: PUSH
67624: LD_INT 30
67626: PUSH
67627: LD_INT 10
67629: PUSH
67630: LD_INT 5
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: LIST
67637: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
67638: LD_VAR 0 1
67642: PPUSH
67643: LD_INT 5
67645: PPUSH
67646: CALL_OW 321
67650: PUSH
67651: LD_INT 2
67653: EQUAL
67654: IFFALSE 67671
// bpoints := bpoints * 1.8 ;
67656: LD_ADDR_VAR 0 10
67660: PUSH
67661: LD_VAR 0 10
67665: PUSH
67666: LD_REAL  1.80000000000000E+0000
67669: MUL
67670: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
67671: LD_VAR 0 6
67675: PPUSH
67676: CALL_OW 257
67680: PUSH
67681: LD_INT 1
67683: PUSH
67684: LD_INT 2
67686: PUSH
67687: LD_INT 3
67689: PUSH
67690: LD_INT 4
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: LIST
67697: LIST
67698: IN
67699: PUSH
67700: LD_VAR 0 1
67704: PPUSH
67705: LD_INT 51
67707: PPUSH
67708: CALL_OW 321
67712: PUSH
67713: LD_INT 2
67715: EQUAL
67716: AND
67717: IFFALSE 67734
// bpoints := bpoints * 1.2 ;
67719: LD_ADDR_VAR 0 10
67723: PUSH
67724: LD_VAR 0 10
67728: PUSH
67729: LD_REAL  1.20000000000000E+0000
67732: MUL
67733: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
67734: LD_VAR 0 6
67738: PPUSH
67739: CALL_OW 257
67743: PUSH
67744: LD_INT 5
67746: PUSH
67747: LD_INT 7
67749: PUSH
67750: LD_INT 9
67752: PUSH
67753: EMPTY
67754: LIST
67755: LIST
67756: LIST
67757: IN
67758: PUSH
67759: LD_VAR 0 1
67763: PPUSH
67764: LD_INT 52
67766: PPUSH
67767: CALL_OW 321
67771: PUSH
67772: LD_INT 2
67774: EQUAL
67775: AND
67776: IFFALSE 67793
// bpoints := bpoints * 1.5 ;
67778: LD_ADDR_VAR 0 10
67782: PUSH
67783: LD_VAR 0 10
67787: PUSH
67788: LD_REAL  1.50000000000000E+0000
67791: MUL
67792: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
67793: LD_VAR 0 1
67797: PPUSH
67798: LD_INT 66
67800: PPUSH
67801: CALL_OW 321
67805: PUSH
67806: LD_INT 2
67808: EQUAL
67809: IFFALSE 67826
// bpoints := bpoints * 1.1 ;
67811: LD_ADDR_VAR 0 10
67815: PUSH
67816: LD_VAR 0 10
67820: PUSH
67821: LD_REAL  1.10000000000000E+0000
67824: MUL
67825: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
67826: LD_ADDR_VAR 0 10
67830: PUSH
67831: LD_VAR 0 10
67835: PUSH
67836: LD_VAR 0 6
67840: PPUSH
67841: LD_INT 1
67843: PPUSH
67844: CALL_OW 259
67848: PUSH
67849: LD_REAL  1.15000000000000E+0000
67852: MUL
67853: MUL
67854: ST_TO_ADDR
// end ; unit_vehicle :
67855: GO 68679
67857: LD_INT 2
67859: DOUBLE
67860: EQUAL
67861: IFTRUE 67865
67863: GO 68667
67865: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
67866: LD_VAR 0 6
67870: PPUSH
67871: CALL_OW 264
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: LD_INT 42
67881: PUSH
67882: LD_INT 24
67884: PUSH
67885: EMPTY
67886: LIST
67887: LIST
67888: LIST
67889: IN
67890: IFFALSE 67911
// points := [ 25 , 5 , 3 ] ;
67892: LD_ADDR_VAR 0 9
67896: PUSH
67897: LD_INT 25
67899: PUSH
67900: LD_INT 5
67902: PUSH
67903: LD_INT 3
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: LIST
67910: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
67911: LD_VAR 0 6
67915: PPUSH
67916: CALL_OW 264
67920: PUSH
67921: LD_INT 4
67923: PUSH
67924: LD_INT 43
67926: PUSH
67927: LD_INT 25
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: LIST
67934: IN
67935: IFFALSE 67956
// points := [ 40 , 15 , 5 ] ;
67937: LD_ADDR_VAR 0 9
67941: PUSH
67942: LD_INT 40
67944: PUSH
67945: LD_INT 15
67947: PUSH
67948: LD_INT 5
67950: PUSH
67951: EMPTY
67952: LIST
67953: LIST
67954: LIST
67955: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
67956: LD_VAR 0 6
67960: PPUSH
67961: CALL_OW 264
67965: PUSH
67966: LD_INT 3
67968: PUSH
67969: LD_INT 23
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: IN
67976: IFFALSE 67997
// points := [ 7 , 25 , 8 ] ;
67978: LD_ADDR_VAR 0 9
67982: PUSH
67983: LD_INT 7
67985: PUSH
67986: LD_INT 25
67988: PUSH
67989: LD_INT 8
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: LIST
67996: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
67997: LD_VAR 0 6
68001: PPUSH
68002: CALL_OW 264
68006: PUSH
68007: LD_INT 5
68009: PUSH
68010: LD_INT 27
68012: PUSH
68013: LD_INT 44
68015: PUSH
68016: EMPTY
68017: LIST
68018: LIST
68019: LIST
68020: IN
68021: IFFALSE 68042
// points := [ 14 , 50 , 16 ] ;
68023: LD_ADDR_VAR 0 9
68027: PUSH
68028: LD_INT 14
68030: PUSH
68031: LD_INT 50
68033: PUSH
68034: LD_INT 16
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: LIST
68041: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
68042: LD_VAR 0 6
68046: PPUSH
68047: CALL_OW 264
68051: PUSH
68052: LD_INT 6
68054: PUSH
68055: LD_INT 46
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: IN
68062: IFFALSE 68083
// points := [ 32 , 120 , 70 ] ;
68064: LD_ADDR_VAR 0 9
68068: PUSH
68069: LD_INT 32
68071: PUSH
68072: LD_INT 120
68074: PUSH
68075: LD_INT 70
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: LIST
68082: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
68083: LD_VAR 0 6
68087: PPUSH
68088: CALL_OW 264
68092: PUSH
68093: LD_INT 7
68095: PUSH
68096: LD_INT 28
68098: PUSH
68099: LD_INT 45
68101: PUSH
68102: EMPTY
68103: LIST
68104: LIST
68105: LIST
68106: IN
68107: IFFALSE 68128
// points := [ 35 , 20 , 45 ] ;
68109: LD_ADDR_VAR 0 9
68113: PUSH
68114: LD_INT 35
68116: PUSH
68117: LD_INT 20
68119: PUSH
68120: LD_INT 45
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: LIST
68127: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
68128: LD_VAR 0 6
68132: PPUSH
68133: CALL_OW 264
68137: PUSH
68138: LD_INT 47
68140: PUSH
68141: EMPTY
68142: LIST
68143: IN
68144: IFFALSE 68165
// points := [ 67 , 45 , 75 ] ;
68146: LD_ADDR_VAR 0 9
68150: PUSH
68151: LD_INT 67
68153: PUSH
68154: LD_INT 45
68156: PUSH
68157: LD_INT 75
68159: PUSH
68160: EMPTY
68161: LIST
68162: LIST
68163: LIST
68164: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
68165: LD_VAR 0 6
68169: PPUSH
68170: CALL_OW 264
68174: PUSH
68175: LD_INT 26
68177: PUSH
68178: EMPTY
68179: LIST
68180: IN
68181: IFFALSE 68202
// points := [ 120 , 30 , 80 ] ;
68183: LD_ADDR_VAR 0 9
68187: PUSH
68188: LD_INT 120
68190: PUSH
68191: LD_INT 30
68193: PUSH
68194: LD_INT 80
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: LIST
68201: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
68202: LD_VAR 0 6
68206: PPUSH
68207: CALL_OW 264
68211: PUSH
68212: LD_INT 22
68214: PUSH
68215: EMPTY
68216: LIST
68217: IN
68218: IFFALSE 68239
// points := [ 40 , 1 , 1 ] ;
68220: LD_ADDR_VAR 0 9
68224: PUSH
68225: LD_INT 40
68227: PUSH
68228: LD_INT 1
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: EMPTY
68235: LIST
68236: LIST
68237: LIST
68238: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
68239: LD_VAR 0 6
68243: PPUSH
68244: CALL_OW 264
68248: PUSH
68249: LD_INT 29
68251: PUSH
68252: EMPTY
68253: LIST
68254: IN
68255: IFFALSE 68276
// points := [ 70 , 200 , 400 ] ;
68257: LD_ADDR_VAR 0 9
68261: PUSH
68262: LD_INT 70
68264: PUSH
68265: LD_INT 200
68267: PUSH
68268: LD_INT 400
68270: PUSH
68271: EMPTY
68272: LIST
68273: LIST
68274: LIST
68275: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
68276: LD_VAR 0 6
68280: PPUSH
68281: CALL_OW 264
68285: PUSH
68286: LD_INT 14
68288: PUSH
68289: LD_INT 53
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: IN
68296: IFFALSE 68317
// points := [ 40 , 10 , 20 ] ;
68298: LD_ADDR_VAR 0 9
68302: PUSH
68303: LD_INT 40
68305: PUSH
68306: LD_INT 10
68308: PUSH
68309: LD_INT 20
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: LIST
68316: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
68317: LD_VAR 0 6
68321: PPUSH
68322: CALL_OW 264
68326: PUSH
68327: LD_INT 9
68329: PUSH
68330: EMPTY
68331: LIST
68332: IN
68333: IFFALSE 68354
// points := [ 5 , 70 , 20 ] ;
68335: LD_ADDR_VAR 0 9
68339: PUSH
68340: LD_INT 5
68342: PUSH
68343: LD_INT 70
68345: PUSH
68346: LD_INT 20
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: LIST
68353: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
68354: LD_VAR 0 6
68358: PPUSH
68359: CALL_OW 264
68363: PUSH
68364: LD_INT 10
68366: PUSH
68367: EMPTY
68368: LIST
68369: IN
68370: IFFALSE 68391
// points := [ 35 , 110 , 70 ] ;
68372: LD_ADDR_VAR 0 9
68376: PUSH
68377: LD_INT 35
68379: PUSH
68380: LD_INT 110
68382: PUSH
68383: LD_INT 70
68385: PUSH
68386: EMPTY
68387: LIST
68388: LIST
68389: LIST
68390: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
68391: LD_VAR 0 6
68395: PPUSH
68396: CALL_OW 265
68400: PUSH
68401: LD_INT 25
68403: EQUAL
68404: IFFALSE 68425
// points := [ 80 , 65 , 100 ] ;
68406: LD_ADDR_VAR 0 9
68410: PUSH
68411: LD_INT 80
68413: PUSH
68414: LD_INT 65
68416: PUSH
68417: LD_INT 100
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: LIST
68424: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
68425: LD_VAR 0 6
68429: PPUSH
68430: CALL_OW 263
68434: PUSH
68435: LD_INT 1
68437: EQUAL
68438: IFFALSE 68473
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
68440: LD_ADDR_VAR 0 10
68444: PUSH
68445: LD_VAR 0 10
68449: PUSH
68450: LD_VAR 0 6
68454: PPUSH
68455: CALL_OW 311
68459: PPUSH
68460: LD_INT 3
68462: PPUSH
68463: CALL_OW 259
68467: PUSH
68468: LD_INT 4
68470: MUL
68471: MUL
68472: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
68473: LD_VAR 0 6
68477: PPUSH
68478: CALL_OW 263
68482: PUSH
68483: LD_INT 2
68485: EQUAL
68486: IFFALSE 68537
// begin j := IsControledBy ( i ) ;
68488: LD_ADDR_VAR 0 7
68492: PUSH
68493: LD_VAR 0 6
68497: PPUSH
68498: CALL_OW 312
68502: ST_TO_ADDR
// if j then
68503: LD_VAR 0 7
68507: IFFALSE 68537
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
68509: LD_ADDR_VAR 0 10
68513: PUSH
68514: LD_VAR 0 10
68518: PUSH
68519: LD_VAR 0 7
68523: PPUSH
68524: LD_INT 3
68526: PPUSH
68527: CALL_OW 259
68531: PUSH
68532: LD_INT 3
68534: MUL
68535: MUL
68536: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
68537: LD_VAR 0 6
68541: PPUSH
68542: CALL_OW 264
68546: PUSH
68547: LD_INT 5
68549: PUSH
68550: LD_INT 6
68552: PUSH
68553: LD_INT 46
68555: PUSH
68556: LD_INT 44
68558: PUSH
68559: LD_INT 47
68561: PUSH
68562: LD_INT 45
68564: PUSH
68565: LD_INT 28
68567: PUSH
68568: LD_INT 7
68570: PUSH
68571: LD_INT 27
68573: PUSH
68574: LD_INT 29
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: LIST
68581: LIST
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: IN
68589: PUSH
68590: LD_VAR 0 1
68594: PPUSH
68595: LD_INT 52
68597: PPUSH
68598: CALL_OW 321
68602: PUSH
68603: LD_INT 2
68605: EQUAL
68606: AND
68607: IFFALSE 68624
// bpoints := bpoints * 1.2 ;
68609: LD_ADDR_VAR 0 10
68613: PUSH
68614: LD_VAR 0 10
68618: PUSH
68619: LD_REAL  1.20000000000000E+0000
68622: MUL
68623: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
68624: LD_VAR 0 6
68628: PPUSH
68629: CALL_OW 264
68633: PUSH
68634: LD_INT 6
68636: PUSH
68637: LD_INT 46
68639: PUSH
68640: LD_INT 47
68642: PUSH
68643: EMPTY
68644: LIST
68645: LIST
68646: LIST
68647: IN
68648: IFFALSE 68665
// bpoints := bpoints * 1.2 ;
68650: LD_ADDR_VAR 0 10
68654: PUSH
68655: LD_VAR 0 10
68659: PUSH
68660: LD_REAL  1.20000000000000E+0000
68663: MUL
68664: ST_TO_ADDR
// end ; unit_building :
68665: GO 68679
68667: LD_INT 3
68669: DOUBLE
68670: EQUAL
68671: IFTRUE 68675
68673: GO 68678
68675: POP
// ; end ;
68676: GO 68679
68678: POP
// for j = 1 to 3 do
68679: LD_ADDR_VAR 0 7
68683: PUSH
68684: DOUBLE
68685: LD_INT 1
68687: DEC
68688: ST_TO_ADDR
68689: LD_INT 3
68691: PUSH
68692: FOR_TO
68693: IFFALSE 68746
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
68695: LD_ADDR_VAR 0 5
68699: PUSH
68700: LD_VAR 0 5
68704: PPUSH
68705: LD_VAR 0 7
68709: PPUSH
68710: LD_VAR 0 5
68714: PUSH
68715: LD_VAR 0 7
68719: ARRAY
68720: PUSH
68721: LD_VAR 0 9
68725: PUSH
68726: LD_VAR 0 7
68730: ARRAY
68731: PUSH
68732: LD_VAR 0 10
68736: MUL
68737: PLUS
68738: PPUSH
68739: CALL_OW 1
68743: ST_TO_ADDR
68744: GO 68692
68746: POP
68747: POP
// end ;
68748: GO 67231
68750: POP
68751: POP
// result := Replace ( result , 4 , tmp ) ;
68752: LD_ADDR_VAR 0 5
68756: PUSH
68757: LD_VAR 0 5
68761: PPUSH
68762: LD_INT 4
68764: PPUSH
68765: LD_VAR 0 8
68769: PPUSH
68770: CALL_OW 1
68774: ST_TO_ADDR
// end ;
68775: LD_VAR 0 5
68779: RET
// export function DangerAtRange ( unit , range ) ; begin
68780: LD_INT 0
68782: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
68783: LD_ADDR_VAR 0 3
68787: PUSH
68788: LD_VAR 0 1
68792: PPUSH
68793: CALL_OW 255
68797: PPUSH
68798: LD_VAR 0 1
68802: PPUSH
68803: CALL_OW 250
68807: PPUSH
68808: LD_VAR 0 1
68812: PPUSH
68813: CALL_OW 251
68817: PPUSH
68818: LD_VAR 0 2
68822: PPUSH
68823: CALL 67083 0 4
68827: ST_TO_ADDR
// end ;
68828: LD_VAR 0 3
68832: RET
// export function DangerInArea ( side , area ) ; begin
68833: LD_INT 0
68835: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
68836: LD_ADDR_VAR 0 3
68840: PUSH
68841: LD_VAR 0 2
68845: PPUSH
68846: LD_INT 81
68848: PUSH
68849: LD_VAR 0 1
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PPUSH
68858: CALL_OW 70
68862: ST_TO_ADDR
// end ;
68863: LD_VAR 0 3
68867: RET
// export function IsExtension ( b ) ; begin
68868: LD_INT 0
68870: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
68871: LD_ADDR_VAR 0 2
68875: PUSH
68876: LD_VAR 0 1
68880: PUSH
68881: LD_INT 23
68883: PUSH
68884: LD_INT 20
68886: PUSH
68887: LD_INT 22
68889: PUSH
68890: LD_INT 17
68892: PUSH
68893: LD_INT 24
68895: PUSH
68896: LD_INT 21
68898: PUSH
68899: LD_INT 19
68901: PUSH
68902: LD_INT 16
68904: PUSH
68905: LD_INT 25
68907: PUSH
68908: LD_INT 18
68910: PUSH
68911: EMPTY
68912: LIST
68913: LIST
68914: LIST
68915: LIST
68916: LIST
68917: LIST
68918: LIST
68919: LIST
68920: LIST
68921: LIST
68922: IN
68923: ST_TO_ADDR
// end ;
68924: LD_VAR 0 2
68928: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
68929: LD_INT 0
68931: PPUSH
68932: PPUSH
68933: PPUSH
// result := [ ] ;
68934: LD_ADDR_VAR 0 3
68938: PUSH
68939: EMPTY
68940: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
68941: LD_ADDR_VAR 0 4
68945: PUSH
68946: LD_VAR 0 2
68950: PPUSH
68951: LD_INT 21
68953: PUSH
68954: LD_INT 3
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PPUSH
68961: CALL_OW 70
68965: ST_TO_ADDR
// if not tmp then
68966: LD_VAR 0 4
68970: NOT
68971: IFFALSE 68975
// exit ;
68973: GO 69033
// for i in tmp do
68975: LD_ADDR_VAR 0 5
68979: PUSH
68980: LD_VAR 0 4
68984: PUSH
68985: FOR_IN
68986: IFFALSE 69021
// if GetBase ( i ) <> base then
68988: LD_VAR 0 5
68992: PPUSH
68993: CALL_OW 274
68997: PUSH
68998: LD_VAR 0 1
69002: NONEQUAL
69003: IFFALSE 69019
// ComLinkToBase ( base , i ) ;
69005: LD_VAR 0 1
69009: PPUSH
69010: LD_VAR 0 5
69014: PPUSH
69015: CALL_OW 169
69019: GO 68985
69021: POP
69022: POP
// result := tmp ;
69023: LD_ADDR_VAR 0 3
69027: PUSH
69028: LD_VAR 0 4
69032: ST_TO_ADDR
// end ;
69033: LD_VAR 0 3
69037: RET
// export function ComComplete ( unit , b ) ; var i ; begin
69038: LD_INT 0
69040: PPUSH
69041: PPUSH
// if BuildingStatus ( b ) = bs_build then
69042: LD_VAR 0 2
69046: PPUSH
69047: CALL_OW 461
69051: PUSH
69052: LD_INT 1
69054: EQUAL
69055: IFFALSE 69115
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
69057: LD_VAR 0 1
69061: PPUSH
69062: LD_STRING h
69064: PUSH
69065: LD_VAR 0 2
69069: PPUSH
69070: CALL_OW 250
69074: PUSH
69075: LD_VAR 0 2
69079: PPUSH
69080: CALL_OW 251
69084: PUSH
69085: LD_VAR 0 2
69089: PUSH
69090: LD_INT 0
69092: PUSH
69093: LD_INT 0
69095: PUSH
69096: LD_INT 0
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: LIST
69103: LIST
69104: LIST
69105: LIST
69106: LIST
69107: PUSH
69108: EMPTY
69109: LIST
69110: PPUSH
69111: CALL_OW 446
// end ;
69115: LD_VAR 0 3
69119: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
69120: LD_INT 0
69122: PPUSH
69123: PPUSH
69124: PPUSH
69125: PPUSH
69126: PPUSH
69127: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
69128: LD_VAR 0 1
69132: NOT
69133: PUSH
69134: LD_VAR 0 1
69138: PPUSH
69139: CALL_OW 263
69143: PUSH
69144: LD_INT 2
69146: EQUAL
69147: NOT
69148: OR
69149: IFFALSE 69153
// exit ;
69151: GO 69469
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
69153: LD_ADDR_VAR 0 6
69157: PUSH
69158: LD_INT 22
69160: PUSH
69161: LD_VAR 0 1
69165: PPUSH
69166: CALL_OW 255
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PUSH
69175: LD_INT 2
69177: PUSH
69178: LD_INT 30
69180: PUSH
69181: LD_INT 36
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 34
69190: PUSH
69191: LD_INT 31
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: LIST
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PPUSH
69207: CALL_OW 69
69211: ST_TO_ADDR
// if not tmp then
69212: LD_VAR 0 6
69216: NOT
69217: IFFALSE 69221
// exit ;
69219: GO 69469
// result := [ ] ;
69221: LD_ADDR_VAR 0 2
69225: PUSH
69226: EMPTY
69227: ST_TO_ADDR
// for i in tmp do
69228: LD_ADDR_VAR 0 3
69232: PUSH
69233: LD_VAR 0 6
69237: PUSH
69238: FOR_IN
69239: IFFALSE 69310
// begin t := UnitsInside ( i ) ;
69241: LD_ADDR_VAR 0 4
69245: PUSH
69246: LD_VAR 0 3
69250: PPUSH
69251: CALL_OW 313
69255: ST_TO_ADDR
// if t then
69256: LD_VAR 0 4
69260: IFFALSE 69308
// for j in t do
69262: LD_ADDR_VAR 0 7
69266: PUSH
69267: LD_VAR 0 4
69271: PUSH
69272: FOR_IN
69273: IFFALSE 69306
// result := Insert ( result , result + 1 , j ) ;
69275: LD_ADDR_VAR 0 2
69279: PUSH
69280: LD_VAR 0 2
69284: PPUSH
69285: LD_VAR 0 2
69289: PUSH
69290: LD_INT 1
69292: PLUS
69293: PPUSH
69294: LD_VAR 0 7
69298: PPUSH
69299: CALL_OW 2
69303: ST_TO_ADDR
69304: GO 69272
69306: POP
69307: POP
// end ;
69308: GO 69238
69310: POP
69311: POP
// if not result then
69312: LD_VAR 0 2
69316: NOT
69317: IFFALSE 69321
// exit ;
69319: GO 69469
// mech := result [ 1 ] ;
69321: LD_ADDR_VAR 0 5
69325: PUSH
69326: LD_VAR 0 2
69330: PUSH
69331: LD_INT 1
69333: ARRAY
69334: ST_TO_ADDR
// if result > 1 then
69335: LD_VAR 0 2
69339: PUSH
69340: LD_INT 1
69342: GREATER
69343: IFFALSE 69455
// for i = 2 to result do
69345: LD_ADDR_VAR 0 3
69349: PUSH
69350: DOUBLE
69351: LD_INT 2
69353: DEC
69354: ST_TO_ADDR
69355: LD_VAR 0 2
69359: PUSH
69360: FOR_TO
69361: IFFALSE 69453
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
69363: LD_ADDR_VAR 0 4
69367: PUSH
69368: LD_VAR 0 2
69372: PUSH
69373: LD_VAR 0 3
69377: ARRAY
69378: PPUSH
69379: LD_INT 3
69381: PPUSH
69382: CALL_OW 259
69386: PUSH
69387: LD_VAR 0 2
69391: PUSH
69392: LD_VAR 0 3
69396: ARRAY
69397: PPUSH
69398: CALL_OW 432
69402: MINUS
69403: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
69404: LD_VAR 0 4
69408: PUSH
69409: LD_VAR 0 5
69413: PPUSH
69414: LD_INT 3
69416: PPUSH
69417: CALL_OW 259
69421: PUSH
69422: LD_VAR 0 5
69426: PPUSH
69427: CALL_OW 432
69431: MINUS
69432: GREATEREQUAL
69433: IFFALSE 69451
// mech := result [ i ] ;
69435: LD_ADDR_VAR 0 5
69439: PUSH
69440: LD_VAR 0 2
69444: PUSH
69445: LD_VAR 0 3
69449: ARRAY
69450: ST_TO_ADDR
// end ;
69451: GO 69360
69453: POP
69454: POP
// ComLinkTo ( vehicle , mech ) ;
69455: LD_VAR 0 1
69459: PPUSH
69460: LD_VAR 0 5
69464: PPUSH
69465: CALL_OW 135
// end ;
69469: LD_VAR 0 2
69473: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
69474: LD_INT 0
69476: PPUSH
69477: PPUSH
69478: PPUSH
69479: PPUSH
69480: PPUSH
69481: PPUSH
69482: PPUSH
69483: PPUSH
69484: PPUSH
69485: PPUSH
69486: PPUSH
69487: PPUSH
69488: PPUSH
// result := [ ] ;
69489: LD_ADDR_VAR 0 7
69493: PUSH
69494: EMPTY
69495: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
69496: LD_VAR 0 1
69500: PPUSH
69501: CALL_OW 266
69505: PUSH
69506: LD_INT 0
69508: PUSH
69509: LD_INT 1
69511: PUSH
69512: EMPTY
69513: LIST
69514: LIST
69515: IN
69516: NOT
69517: IFFALSE 69521
// exit ;
69519: GO 71152
// if name then
69521: LD_VAR 0 3
69525: IFFALSE 69541
// SetBName ( base_dep , name ) ;
69527: LD_VAR 0 1
69531: PPUSH
69532: LD_VAR 0 3
69536: PPUSH
69537: CALL_OW 500
// base := GetBase ( base_dep ) ;
69541: LD_ADDR_VAR 0 15
69545: PUSH
69546: LD_VAR 0 1
69550: PPUSH
69551: CALL_OW 274
69555: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
69556: LD_ADDR_VAR 0 16
69560: PUSH
69561: LD_VAR 0 1
69565: PPUSH
69566: CALL_OW 255
69570: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
69571: LD_ADDR_VAR 0 17
69575: PUSH
69576: LD_VAR 0 1
69580: PPUSH
69581: CALL_OW 248
69585: ST_TO_ADDR
// if sources then
69586: LD_VAR 0 5
69590: IFFALSE 69637
// for i = 1 to 3 do
69592: LD_ADDR_VAR 0 8
69596: PUSH
69597: DOUBLE
69598: LD_INT 1
69600: DEC
69601: ST_TO_ADDR
69602: LD_INT 3
69604: PUSH
69605: FOR_TO
69606: IFFALSE 69635
// AddResourceType ( base , i , sources [ i ] ) ;
69608: LD_VAR 0 15
69612: PPUSH
69613: LD_VAR 0 8
69617: PPUSH
69618: LD_VAR 0 5
69622: PUSH
69623: LD_VAR 0 8
69627: ARRAY
69628: PPUSH
69629: CALL_OW 276
69633: GO 69605
69635: POP
69636: POP
// buildings := GetBaseBuildings ( base , area ) ;
69637: LD_ADDR_VAR 0 18
69641: PUSH
69642: LD_VAR 0 15
69646: PPUSH
69647: LD_VAR 0 2
69651: PPUSH
69652: CALL 68929 0 2
69656: ST_TO_ADDR
// InitHc ;
69657: CALL_OW 19
// InitUc ;
69661: CALL_OW 18
// uc_side := side ;
69665: LD_ADDR_OWVAR 20
69669: PUSH
69670: LD_VAR 0 16
69674: ST_TO_ADDR
// uc_nation := nation ;
69675: LD_ADDR_OWVAR 21
69679: PUSH
69680: LD_VAR 0 17
69684: ST_TO_ADDR
// if buildings then
69685: LD_VAR 0 18
69689: IFFALSE 71011
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
69691: LD_ADDR_VAR 0 19
69695: PUSH
69696: LD_VAR 0 18
69700: PPUSH
69701: LD_INT 2
69703: PUSH
69704: LD_INT 30
69706: PUSH
69707: LD_INT 29
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 30
69716: PUSH
69717: LD_INT 30
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PUSH
69724: EMPTY
69725: LIST
69726: LIST
69727: LIST
69728: PPUSH
69729: CALL_OW 72
69733: ST_TO_ADDR
// if tmp then
69734: LD_VAR 0 19
69738: IFFALSE 69786
// for i in tmp do
69740: LD_ADDR_VAR 0 8
69744: PUSH
69745: LD_VAR 0 19
69749: PUSH
69750: FOR_IN
69751: IFFALSE 69784
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
69753: LD_VAR 0 8
69757: PPUSH
69758: CALL_OW 250
69762: PPUSH
69763: LD_VAR 0 8
69767: PPUSH
69768: CALL_OW 251
69772: PPUSH
69773: LD_VAR 0 16
69777: PPUSH
69778: CALL_OW 441
69782: GO 69750
69784: POP
69785: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
69786: LD_VAR 0 18
69790: PPUSH
69791: LD_INT 2
69793: PUSH
69794: LD_INT 30
69796: PUSH
69797: LD_INT 32
69799: PUSH
69800: EMPTY
69801: LIST
69802: LIST
69803: PUSH
69804: LD_INT 30
69806: PUSH
69807: LD_INT 33
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: EMPTY
69815: LIST
69816: LIST
69817: LIST
69818: PPUSH
69819: CALL_OW 72
69823: IFFALSE 69911
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
69825: LD_ADDR_VAR 0 8
69829: PUSH
69830: LD_VAR 0 18
69834: PPUSH
69835: LD_INT 2
69837: PUSH
69838: LD_INT 30
69840: PUSH
69841: LD_INT 32
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 30
69850: PUSH
69851: LD_INT 33
69853: PUSH
69854: EMPTY
69855: LIST
69856: LIST
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: LIST
69862: PPUSH
69863: CALL_OW 72
69867: PUSH
69868: FOR_IN
69869: IFFALSE 69909
// begin if not GetBWeapon ( i ) then
69871: LD_VAR 0 8
69875: PPUSH
69876: CALL_OW 269
69880: NOT
69881: IFFALSE 69907
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
69883: LD_VAR 0 8
69887: PPUSH
69888: LD_VAR 0 8
69892: PPUSH
69893: LD_VAR 0 2
69897: PPUSH
69898: CALL 71157 0 2
69902: PPUSH
69903: CALL_OW 431
// end ;
69907: GO 69868
69909: POP
69910: POP
// end ; for i = 1 to personel do
69911: LD_ADDR_VAR 0 8
69915: PUSH
69916: DOUBLE
69917: LD_INT 1
69919: DEC
69920: ST_TO_ADDR
69921: LD_VAR 0 6
69925: PUSH
69926: FOR_TO
69927: IFFALSE 70991
// begin if i > 4 then
69929: LD_VAR 0 8
69933: PUSH
69934: LD_INT 4
69936: GREATER
69937: IFFALSE 69941
// break ;
69939: GO 70991
// case i of 1 :
69941: LD_VAR 0 8
69945: PUSH
69946: LD_INT 1
69948: DOUBLE
69949: EQUAL
69950: IFTRUE 69954
69952: GO 70034
69954: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
69955: LD_ADDR_VAR 0 12
69959: PUSH
69960: LD_VAR 0 18
69964: PPUSH
69965: LD_INT 22
69967: PUSH
69968: LD_VAR 0 16
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: LD_INT 58
69979: PUSH
69980: EMPTY
69981: LIST
69982: PUSH
69983: LD_INT 2
69985: PUSH
69986: LD_INT 30
69988: PUSH
69989: LD_INT 32
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: LD_INT 30
69998: PUSH
69999: LD_INT 4
70001: PUSH
70002: EMPTY
70003: LIST
70004: LIST
70005: PUSH
70006: LD_INT 30
70008: PUSH
70009: LD_INT 5
70011: PUSH
70012: EMPTY
70013: LIST
70014: LIST
70015: PUSH
70016: EMPTY
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: PUSH
70022: EMPTY
70023: LIST
70024: LIST
70025: LIST
70026: PPUSH
70027: CALL_OW 72
70031: ST_TO_ADDR
70032: GO 70256
70034: LD_INT 2
70036: DOUBLE
70037: EQUAL
70038: IFTRUE 70042
70040: GO 70104
70042: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
70043: LD_ADDR_VAR 0 12
70047: PUSH
70048: LD_VAR 0 18
70052: PPUSH
70053: LD_INT 22
70055: PUSH
70056: LD_VAR 0 16
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PUSH
70065: LD_INT 2
70067: PUSH
70068: LD_INT 30
70070: PUSH
70071: LD_INT 0
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 30
70080: PUSH
70081: LD_INT 1
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: LIST
70092: PUSH
70093: EMPTY
70094: LIST
70095: LIST
70096: PPUSH
70097: CALL_OW 72
70101: ST_TO_ADDR
70102: GO 70256
70104: LD_INT 3
70106: DOUBLE
70107: EQUAL
70108: IFTRUE 70112
70110: GO 70174
70112: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
70113: LD_ADDR_VAR 0 12
70117: PUSH
70118: LD_VAR 0 18
70122: PPUSH
70123: LD_INT 22
70125: PUSH
70126: LD_VAR 0 16
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 2
70137: PUSH
70138: LD_INT 30
70140: PUSH
70141: LD_INT 2
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 30
70150: PUSH
70151: LD_INT 3
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: LIST
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PPUSH
70167: CALL_OW 72
70171: ST_TO_ADDR
70172: GO 70256
70174: LD_INT 4
70176: DOUBLE
70177: EQUAL
70178: IFTRUE 70182
70180: GO 70255
70182: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
70183: LD_ADDR_VAR 0 12
70187: PUSH
70188: LD_VAR 0 18
70192: PPUSH
70193: LD_INT 22
70195: PUSH
70196: LD_VAR 0 16
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 2
70207: PUSH
70208: LD_INT 30
70210: PUSH
70211: LD_INT 6
70213: PUSH
70214: EMPTY
70215: LIST
70216: LIST
70217: PUSH
70218: LD_INT 30
70220: PUSH
70221: LD_INT 7
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 30
70230: PUSH
70231: LD_INT 8
70233: PUSH
70234: EMPTY
70235: LIST
70236: LIST
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: LIST
70242: LIST
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PPUSH
70248: CALL_OW 72
70252: ST_TO_ADDR
70253: GO 70256
70255: POP
// if i = 1 then
70256: LD_VAR 0 8
70260: PUSH
70261: LD_INT 1
70263: EQUAL
70264: IFFALSE 70375
// begin tmp := [ ] ;
70266: LD_ADDR_VAR 0 19
70270: PUSH
70271: EMPTY
70272: ST_TO_ADDR
// for j in f do
70273: LD_ADDR_VAR 0 9
70277: PUSH
70278: LD_VAR 0 12
70282: PUSH
70283: FOR_IN
70284: IFFALSE 70357
// if GetBType ( j ) = b_bunker then
70286: LD_VAR 0 9
70290: PPUSH
70291: CALL_OW 266
70295: PUSH
70296: LD_INT 32
70298: EQUAL
70299: IFFALSE 70326
// tmp := Insert ( tmp , 1 , j ) else
70301: LD_ADDR_VAR 0 19
70305: PUSH
70306: LD_VAR 0 19
70310: PPUSH
70311: LD_INT 1
70313: PPUSH
70314: LD_VAR 0 9
70318: PPUSH
70319: CALL_OW 2
70323: ST_TO_ADDR
70324: GO 70355
// tmp := Insert ( tmp , tmp + 1 , j ) ;
70326: LD_ADDR_VAR 0 19
70330: PUSH
70331: LD_VAR 0 19
70335: PPUSH
70336: LD_VAR 0 19
70340: PUSH
70341: LD_INT 1
70343: PLUS
70344: PPUSH
70345: LD_VAR 0 9
70349: PPUSH
70350: CALL_OW 2
70354: ST_TO_ADDR
70355: GO 70283
70357: POP
70358: POP
// if tmp then
70359: LD_VAR 0 19
70363: IFFALSE 70375
// f := tmp ;
70365: LD_ADDR_VAR 0 12
70369: PUSH
70370: LD_VAR 0 19
70374: ST_TO_ADDR
// end ; x := personel [ i ] ;
70375: LD_ADDR_VAR 0 13
70379: PUSH
70380: LD_VAR 0 6
70384: PUSH
70385: LD_VAR 0 8
70389: ARRAY
70390: ST_TO_ADDR
// if x = - 1 then
70391: LD_VAR 0 13
70395: PUSH
70396: LD_INT 1
70398: NEG
70399: EQUAL
70400: IFFALSE 70609
// begin for j in f do
70402: LD_ADDR_VAR 0 9
70406: PUSH
70407: LD_VAR 0 12
70411: PUSH
70412: FOR_IN
70413: IFFALSE 70605
// repeat InitHc ;
70415: CALL_OW 19
// if GetBType ( j ) = b_barracks then
70419: LD_VAR 0 9
70423: PPUSH
70424: CALL_OW 266
70428: PUSH
70429: LD_INT 5
70431: EQUAL
70432: IFFALSE 70502
// begin if UnitsInside ( j ) < 3 then
70434: LD_VAR 0 9
70438: PPUSH
70439: CALL_OW 313
70443: PUSH
70444: LD_INT 3
70446: LESS
70447: IFFALSE 70483
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70449: LD_INT 0
70451: PPUSH
70452: LD_INT 5
70454: PUSH
70455: LD_INT 8
70457: PUSH
70458: LD_INT 9
70460: PUSH
70461: EMPTY
70462: LIST
70463: LIST
70464: LIST
70465: PUSH
70466: LD_VAR 0 17
70470: ARRAY
70471: PPUSH
70472: LD_VAR 0 4
70476: PPUSH
70477: CALL_OW 380
70481: GO 70500
// PrepareHuman ( false , i , skill ) ;
70483: LD_INT 0
70485: PPUSH
70486: LD_VAR 0 8
70490: PPUSH
70491: LD_VAR 0 4
70495: PPUSH
70496: CALL_OW 380
// end else
70500: GO 70519
// PrepareHuman ( false , i , skill ) ;
70502: LD_INT 0
70504: PPUSH
70505: LD_VAR 0 8
70509: PPUSH
70510: LD_VAR 0 4
70514: PPUSH
70515: CALL_OW 380
// un := CreateHuman ;
70519: LD_ADDR_VAR 0 14
70523: PUSH
70524: CALL_OW 44
70528: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70529: LD_ADDR_VAR 0 7
70533: PUSH
70534: LD_VAR 0 7
70538: PPUSH
70539: LD_INT 1
70541: PPUSH
70542: LD_VAR 0 14
70546: PPUSH
70547: CALL_OW 2
70551: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
70552: LD_VAR 0 14
70556: PPUSH
70557: LD_VAR 0 9
70561: PPUSH
70562: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
70566: LD_VAR 0 9
70570: PPUSH
70571: CALL_OW 313
70575: PUSH
70576: LD_INT 6
70578: EQUAL
70579: PUSH
70580: LD_VAR 0 9
70584: PPUSH
70585: CALL_OW 266
70589: PUSH
70590: LD_INT 32
70592: PUSH
70593: LD_INT 31
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: IN
70600: OR
70601: IFFALSE 70415
70603: GO 70412
70605: POP
70606: POP
// end else
70607: GO 70989
// for j = 1 to x do
70609: LD_ADDR_VAR 0 9
70613: PUSH
70614: DOUBLE
70615: LD_INT 1
70617: DEC
70618: ST_TO_ADDR
70619: LD_VAR 0 13
70623: PUSH
70624: FOR_TO
70625: IFFALSE 70987
// begin InitHc ;
70627: CALL_OW 19
// if not f then
70631: LD_VAR 0 12
70635: NOT
70636: IFFALSE 70725
// begin PrepareHuman ( false , i , skill ) ;
70638: LD_INT 0
70640: PPUSH
70641: LD_VAR 0 8
70645: PPUSH
70646: LD_VAR 0 4
70650: PPUSH
70651: CALL_OW 380
// un := CreateHuman ;
70655: LD_ADDR_VAR 0 14
70659: PUSH
70660: CALL_OW 44
70664: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70665: LD_ADDR_VAR 0 7
70669: PUSH
70670: LD_VAR 0 7
70674: PPUSH
70675: LD_INT 1
70677: PPUSH
70678: LD_VAR 0 14
70682: PPUSH
70683: CALL_OW 2
70687: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
70688: LD_VAR 0 14
70692: PPUSH
70693: LD_VAR 0 1
70697: PPUSH
70698: CALL_OW 250
70702: PPUSH
70703: LD_VAR 0 1
70707: PPUSH
70708: CALL_OW 251
70712: PPUSH
70713: LD_INT 10
70715: PPUSH
70716: LD_INT 0
70718: PPUSH
70719: CALL_OW 50
// continue ;
70723: GO 70624
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
70725: LD_VAR 0 12
70729: PUSH
70730: LD_INT 1
70732: ARRAY
70733: PPUSH
70734: CALL_OW 313
70738: PUSH
70739: LD_VAR 0 12
70743: PUSH
70744: LD_INT 1
70746: ARRAY
70747: PPUSH
70748: CALL_OW 266
70752: PUSH
70753: LD_INT 32
70755: PUSH
70756: LD_INT 31
70758: PUSH
70759: EMPTY
70760: LIST
70761: LIST
70762: IN
70763: AND
70764: PUSH
70765: LD_VAR 0 12
70769: PUSH
70770: LD_INT 1
70772: ARRAY
70773: PPUSH
70774: CALL_OW 313
70778: PUSH
70779: LD_INT 6
70781: EQUAL
70782: OR
70783: IFFALSE 70803
// f := Delete ( f , 1 ) ;
70785: LD_ADDR_VAR 0 12
70789: PUSH
70790: LD_VAR 0 12
70794: PPUSH
70795: LD_INT 1
70797: PPUSH
70798: CALL_OW 3
70802: ST_TO_ADDR
// if not f then
70803: LD_VAR 0 12
70807: NOT
70808: IFFALSE 70826
// begin x := x + 2 ;
70810: LD_ADDR_VAR 0 13
70814: PUSH
70815: LD_VAR 0 13
70819: PUSH
70820: LD_INT 2
70822: PLUS
70823: ST_TO_ADDR
// continue ;
70824: GO 70624
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
70826: LD_VAR 0 12
70830: PUSH
70831: LD_INT 1
70833: ARRAY
70834: PPUSH
70835: CALL_OW 266
70839: PUSH
70840: LD_INT 5
70842: EQUAL
70843: IFFALSE 70917
// begin if UnitsInside ( f [ 1 ] ) < 3 then
70845: LD_VAR 0 12
70849: PUSH
70850: LD_INT 1
70852: ARRAY
70853: PPUSH
70854: CALL_OW 313
70858: PUSH
70859: LD_INT 3
70861: LESS
70862: IFFALSE 70898
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
70864: LD_INT 0
70866: PPUSH
70867: LD_INT 5
70869: PUSH
70870: LD_INT 8
70872: PUSH
70873: LD_INT 9
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: LIST
70880: PUSH
70881: LD_VAR 0 17
70885: ARRAY
70886: PPUSH
70887: LD_VAR 0 4
70891: PPUSH
70892: CALL_OW 380
70896: GO 70915
// PrepareHuman ( false , i , skill ) ;
70898: LD_INT 0
70900: PPUSH
70901: LD_VAR 0 8
70905: PPUSH
70906: LD_VAR 0 4
70910: PPUSH
70911: CALL_OW 380
// end else
70915: GO 70934
// PrepareHuman ( false , i , skill ) ;
70917: LD_INT 0
70919: PPUSH
70920: LD_VAR 0 8
70924: PPUSH
70925: LD_VAR 0 4
70929: PPUSH
70930: CALL_OW 380
// un := CreateHuman ;
70934: LD_ADDR_VAR 0 14
70938: PUSH
70939: CALL_OW 44
70943: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
70944: LD_ADDR_VAR 0 7
70948: PUSH
70949: LD_VAR 0 7
70953: PPUSH
70954: LD_INT 1
70956: PPUSH
70957: LD_VAR 0 14
70961: PPUSH
70962: CALL_OW 2
70966: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
70967: LD_VAR 0 14
70971: PPUSH
70972: LD_VAR 0 12
70976: PUSH
70977: LD_INT 1
70979: ARRAY
70980: PPUSH
70981: CALL_OW 52
// end ;
70985: GO 70624
70987: POP
70988: POP
// end ;
70989: GO 69926
70991: POP
70992: POP
// result := result ^ buildings ;
70993: LD_ADDR_VAR 0 7
70997: PUSH
70998: LD_VAR 0 7
71002: PUSH
71003: LD_VAR 0 18
71007: ADD
71008: ST_TO_ADDR
// end else
71009: GO 71152
// begin for i = 1 to personel do
71011: LD_ADDR_VAR 0 8
71015: PUSH
71016: DOUBLE
71017: LD_INT 1
71019: DEC
71020: ST_TO_ADDR
71021: LD_VAR 0 6
71025: PUSH
71026: FOR_TO
71027: IFFALSE 71150
// begin if i > 4 then
71029: LD_VAR 0 8
71033: PUSH
71034: LD_INT 4
71036: GREATER
71037: IFFALSE 71041
// break ;
71039: GO 71150
// x := personel [ i ] ;
71041: LD_ADDR_VAR 0 13
71045: PUSH
71046: LD_VAR 0 6
71050: PUSH
71051: LD_VAR 0 8
71055: ARRAY
71056: ST_TO_ADDR
// if x = - 1 then
71057: LD_VAR 0 13
71061: PUSH
71062: LD_INT 1
71064: NEG
71065: EQUAL
71066: IFFALSE 71070
// continue ;
71068: GO 71026
// PrepareHuman ( false , i , skill ) ;
71070: LD_INT 0
71072: PPUSH
71073: LD_VAR 0 8
71077: PPUSH
71078: LD_VAR 0 4
71082: PPUSH
71083: CALL_OW 380
// un := CreateHuman ;
71087: LD_ADDR_VAR 0 14
71091: PUSH
71092: CALL_OW 44
71096: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
71097: LD_VAR 0 14
71101: PPUSH
71102: LD_VAR 0 1
71106: PPUSH
71107: CALL_OW 250
71111: PPUSH
71112: LD_VAR 0 1
71116: PPUSH
71117: CALL_OW 251
71121: PPUSH
71122: LD_INT 10
71124: PPUSH
71125: LD_INT 0
71127: PPUSH
71128: CALL_OW 50
// result := result ^ un ;
71132: LD_ADDR_VAR 0 7
71136: PUSH
71137: LD_VAR 0 7
71141: PUSH
71142: LD_VAR 0 14
71146: ADD
71147: ST_TO_ADDR
// end ;
71148: GO 71026
71150: POP
71151: POP
// end ; end ;
71152: LD_VAR 0 7
71156: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
71157: LD_INT 0
71159: PPUSH
71160: PPUSH
71161: PPUSH
71162: PPUSH
71163: PPUSH
71164: PPUSH
71165: PPUSH
71166: PPUSH
71167: PPUSH
71168: PPUSH
71169: PPUSH
71170: PPUSH
71171: PPUSH
71172: PPUSH
71173: PPUSH
71174: PPUSH
// result := false ;
71175: LD_ADDR_VAR 0 3
71179: PUSH
71180: LD_INT 0
71182: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
71183: LD_VAR 0 1
71187: NOT
71188: PUSH
71189: LD_VAR 0 1
71193: PPUSH
71194: CALL_OW 266
71198: PUSH
71199: LD_INT 32
71201: PUSH
71202: LD_INT 33
71204: PUSH
71205: EMPTY
71206: LIST
71207: LIST
71208: IN
71209: NOT
71210: OR
71211: IFFALSE 71215
// exit ;
71213: GO 72351
// nat := GetNation ( tower ) ;
71215: LD_ADDR_VAR 0 12
71219: PUSH
71220: LD_VAR 0 1
71224: PPUSH
71225: CALL_OW 248
71229: ST_TO_ADDR
// side := GetSide ( tower ) ;
71230: LD_ADDR_VAR 0 16
71234: PUSH
71235: LD_VAR 0 1
71239: PPUSH
71240: CALL_OW 255
71244: ST_TO_ADDR
// x := GetX ( tower ) ;
71245: LD_ADDR_VAR 0 10
71249: PUSH
71250: LD_VAR 0 1
71254: PPUSH
71255: CALL_OW 250
71259: ST_TO_ADDR
// y := GetY ( tower ) ;
71260: LD_ADDR_VAR 0 11
71264: PUSH
71265: LD_VAR 0 1
71269: PPUSH
71270: CALL_OW 251
71274: ST_TO_ADDR
// if not x or not y then
71275: LD_VAR 0 10
71279: NOT
71280: PUSH
71281: LD_VAR 0 11
71285: NOT
71286: OR
71287: IFFALSE 71291
// exit ;
71289: GO 72351
// weapon := 0 ;
71291: LD_ADDR_VAR 0 18
71295: PUSH
71296: LD_INT 0
71298: ST_TO_ADDR
// fac_list := [ ] ;
71299: LD_ADDR_VAR 0 17
71303: PUSH
71304: EMPTY
71305: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
71306: LD_ADDR_VAR 0 6
71310: PUSH
71311: LD_VAR 0 1
71315: PPUSH
71316: CALL_OW 274
71320: PPUSH
71321: LD_VAR 0 2
71325: PPUSH
71326: CALL 68929 0 2
71330: PPUSH
71331: LD_INT 30
71333: PUSH
71334: LD_INT 3
71336: PUSH
71337: EMPTY
71338: LIST
71339: LIST
71340: PPUSH
71341: CALL_OW 72
71345: ST_TO_ADDR
// if not factories then
71346: LD_VAR 0 6
71350: NOT
71351: IFFALSE 71355
// exit ;
71353: GO 72351
// for i in factories do
71355: LD_ADDR_VAR 0 8
71359: PUSH
71360: LD_VAR 0 6
71364: PUSH
71365: FOR_IN
71366: IFFALSE 71391
// fac_list := fac_list union AvailableWeaponList ( i ) ;
71368: LD_ADDR_VAR 0 17
71372: PUSH
71373: LD_VAR 0 17
71377: PUSH
71378: LD_VAR 0 8
71382: PPUSH
71383: CALL_OW 478
71387: UNION
71388: ST_TO_ADDR
71389: GO 71365
71391: POP
71392: POP
// if not fac_list then
71393: LD_VAR 0 17
71397: NOT
71398: IFFALSE 71402
// exit ;
71400: GO 72351
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
71402: LD_ADDR_VAR 0 5
71406: PUSH
71407: LD_INT 4
71409: PUSH
71410: LD_INT 5
71412: PUSH
71413: LD_INT 9
71415: PUSH
71416: LD_INT 10
71418: PUSH
71419: LD_INT 6
71421: PUSH
71422: LD_INT 7
71424: PUSH
71425: LD_INT 11
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 27
71439: PUSH
71440: LD_INT 28
71442: PUSH
71443: LD_INT 26
71445: PUSH
71446: LD_INT 30
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: LIST
71453: LIST
71454: PUSH
71455: LD_INT 43
71457: PUSH
71458: LD_INT 44
71460: PUSH
71461: LD_INT 46
71463: PUSH
71464: LD_INT 45
71466: PUSH
71467: LD_INT 47
71469: PUSH
71470: LD_INT 49
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: LIST
71477: LIST
71478: LIST
71479: LIST
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: LIST
71485: PUSH
71486: LD_VAR 0 12
71490: ARRAY
71491: ST_TO_ADDR
// for i in list do
71492: LD_ADDR_VAR 0 8
71496: PUSH
71497: LD_VAR 0 5
71501: PUSH
71502: FOR_IN
71503: IFFALSE 71536
// if not i in fac_list then
71505: LD_VAR 0 8
71509: PUSH
71510: LD_VAR 0 17
71514: IN
71515: NOT
71516: IFFALSE 71534
// list := list diff i ;
71518: LD_ADDR_VAR 0 5
71522: PUSH
71523: LD_VAR 0 5
71527: PUSH
71528: LD_VAR 0 8
71532: DIFF
71533: ST_TO_ADDR
71534: GO 71502
71536: POP
71537: POP
// if not list then
71538: LD_VAR 0 5
71542: NOT
71543: IFFALSE 71547
// exit ;
71545: GO 72351
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
71547: LD_VAR 0 12
71551: PUSH
71552: LD_INT 3
71554: EQUAL
71555: PUSH
71556: LD_INT 49
71558: PUSH
71559: LD_VAR 0 5
71563: IN
71564: AND
71565: PUSH
71566: LD_INT 31
71568: PPUSH
71569: LD_VAR 0 16
71573: PPUSH
71574: CALL_OW 321
71578: PUSH
71579: LD_INT 2
71581: EQUAL
71582: AND
71583: IFFALSE 71643
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
71585: LD_INT 22
71587: PUSH
71588: LD_VAR 0 16
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 35
71599: PUSH
71600: LD_INT 49
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 91
71609: PUSH
71610: LD_VAR 0 1
71614: PUSH
71615: LD_INT 10
71617: PUSH
71618: EMPTY
71619: LIST
71620: LIST
71621: LIST
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: LIST
71627: PPUSH
71628: CALL_OW 69
71632: NOT
71633: IFFALSE 71643
// weapon := ru_time_lapser ;
71635: LD_ADDR_VAR 0 18
71639: PUSH
71640: LD_INT 49
71642: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
71643: LD_VAR 0 12
71647: PUSH
71648: LD_INT 1
71650: PUSH
71651: LD_INT 2
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: IN
71658: PUSH
71659: LD_INT 11
71661: PUSH
71662: LD_VAR 0 5
71666: IN
71667: PUSH
71668: LD_INT 30
71670: PUSH
71671: LD_VAR 0 5
71675: IN
71676: OR
71677: AND
71678: PUSH
71679: LD_INT 6
71681: PPUSH
71682: LD_VAR 0 16
71686: PPUSH
71687: CALL_OW 321
71691: PUSH
71692: LD_INT 2
71694: EQUAL
71695: AND
71696: IFFALSE 71861
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
71698: LD_INT 22
71700: PUSH
71701: LD_VAR 0 16
71705: PUSH
71706: EMPTY
71707: LIST
71708: LIST
71709: PUSH
71710: LD_INT 2
71712: PUSH
71713: LD_INT 35
71715: PUSH
71716: LD_INT 11
71718: PUSH
71719: EMPTY
71720: LIST
71721: LIST
71722: PUSH
71723: LD_INT 35
71725: PUSH
71726: LD_INT 30
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: LIST
71737: PUSH
71738: LD_INT 91
71740: PUSH
71741: LD_VAR 0 1
71745: PUSH
71746: LD_INT 18
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: LIST
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: LIST
71758: PPUSH
71759: CALL_OW 69
71763: NOT
71764: PUSH
71765: LD_INT 22
71767: PUSH
71768: LD_VAR 0 16
71772: PUSH
71773: EMPTY
71774: LIST
71775: LIST
71776: PUSH
71777: LD_INT 2
71779: PUSH
71780: LD_INT 30
71782: PUSH
71783: LD_INT 32
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 30
71792: PUSH
71793: LD_INT 33
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 91
71807: PUSH
71808: LD_VAR 0 1
71812: PUSH
71813: LD_INT 12
71815: PUSH
71816: EMPTY
71817: LIST
71818: LIST
71819: LIST
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: LIST
71825: PUSH
71826: EMPTY
71827: LIST
71828: PPUSH
71829: CALL_OW 69
71833: PUSH
71834: LD_INT 2
71836: GREATER
71837: AND
71838: IFFALSE 71861
// weapon := [ us_radar , ar_radar ] [ nat ] ;
71840: LD_ADDR_VAR 0 18
71844: PUSH
71845: LD_INT 11
71847: PUSH
71848: LD_INT 30
71850: PUSH
71851: EMPTY
71852: LIST
71853: LIST
71854: PUSH
71855: LD_VAR 0 12
71859: ARRAY
71860: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
71861: LD_VAR 0 18
71865: NOT
71866: PUSH
71867: LD_INT 40
71869: PPUSH
71870: LD_VAR 0 16
71874: PPUSH
71875: CALL_OW 321
71879: PUSH
71880: LD_INT 2
71882: EQUAL
71883: AND
71884: PUSH
71885: LD_INT 7
71887: PUSH
71888: LD_VAR 0 5
71892: IN
71893: PUSH
71894: LD_INT 28
71896: PUSH
71897: LD_VAR 0 5
71901: IN
71902: OR
71903: PUSH
71904: LD_INT 45
71906: PUSH
71907: LD_VAR 0 5
71911: IN
71912: OR
71913: AND
71914: IFFALSE 72168
// begin hex := GetHexInfo ( x , y ) ;
71916: LD_ADDR_VAR 0 4
71920: PUSH
71921: LD_VAR 0 10
71925: PPUSH
71926: LD_VAR 0 11
71930: PPUSH
71931: CALL_OW 546
71935: ST_TO_ADDR
// if hex [ 1 ] then
71936: LD_VAR 0 4
71940: PUSH
71941: LD_INT 1
71943: ARRAY
71944: IFFALSE 71948
// exit ;
71946: GO 72351
// height := hex [ 2 ] ;
71948: LD_ADDR_VAR 0 15
71952: PUSH
71953: LD_VAR 0 4
71957: PUSH
71958: LD_INT 2
71960: ARRAY
71961: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
71962: LD_ADDR_VAR 0 14
71966: PUSH
71967: LD_INT 0
71969: PUSH
71970: LD_INT 2
71972: PUSH
71973: LD_INT 3
71975: PUSH
71976: LD_INT 5
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: ST_TO_ADDR
// for i in tmp do
71985: LD_ADDR_VAR 0 8
71989: PUSH
71990: LD_VAR 0 14
71994: PUSH
71995: FOR_IN
71996: IFFALSE 72166
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
71998: LD_ADDR_VAR 0 9
72002: PUSH
72003: LD_VAR 0 10
72007: PPUSH
72008: LD_VAR 0 8
72012: PPUSH
72013: LD_INT 5
72015: PPUSH
72016: CALL_OW 272
72020: PUSH
72021: LD_VAR 0 11
72025: PPUSH
72026: LD_VAR 0 8
72030: PPUSH
72031: LD_INT 5
72033: PPUSH
72034: CALL_OW 273
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
72043: LD_VAR 0 9
72047: PUSH
72048: LD_INT 1
72050: ARRAY
72051: PPUSH
72052: LD_VAR 0 9
72056: PUSH
72057: LD_INT 2
72059: ARRAY
72060: PPUSH
72061: CALL_OW 488
72065: IFFALSE 72164
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
72067: LD_ADDR_VAR 0 4
72071: PUSH
72072: LD_VAR 0 9
72076: PUSH
72077: LD_INT 1
72079: ARRAY
72080: PPUSH
72081: LD_VAR 0 9
72085: PUSH
72086: LD_INT 2
72088: ARRAY
72089: PPUSH
72090: CALL_OW 546
72094: ST_TO_ADDR
// if hex [ 1 ] then
72095: LD_VAR 0 4
72099: PUSH
72100: LD_INT 1
72102: ARRAY
72103: IFFALSE 72107
// continue ;
72105: GO 71995
// h := hex [ 2 ] ;
72107: LD_ADDR_VAR 0 13
72111: PUSH
72112: LD_VAR 0 4
72116: PUSH
72117: LD_INT 2
72119: ARRAY
72120: ST_TO_ADDR
// if h + 7 < height then
72121: LD_VAR 0 13
72125: PUSH
72126: LD_INT 7
72128: PLUS
72129: PUSH
72130: LD_VAR 0 15
72134: LESS
72135: IFFALSE 72164
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
72137: LD_ADDR_VAR 0 18
72141: PUSH
72142: LD_INT 7
72144: PUSH
72145: LD_INT 28
72147: PUSH
72148: LD_INT 45
72150: PUSH
72151: EMPTY
72152: LIST
72153: LIST
72154: LIST
72155: PUSH
72156: LD_VAR 0 12
72160: ARRAY
72161: ST_TO_ADDR
// break ;
72162: GO 72166
// end ; end ; end ;
72164: GO 71995
72166: POP
72167: POP
// end ; if not weapon then
72168: LD_VAR 0 18
72172: NOT
72173: IFFALSE 72233
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
72175: LD_ADDR_VAR 0 5
72179: PUSH
72180: LD_VAR 0 5
72184: PUSH
72185: LD_INT 11
72187: PUSH
72188: LD_INT 30
72190: PUSH
72191: LD_INT 49
72193: PUSH
72194: EMPTY
72195: LIST
72196: LIST
72197: LIST
72198: DIFF
72199: ST_TO_ADDR
// if not list then
72200: LD_VAR 0 5
72204: NOT
72205: IFFALSE 72209
// exit ;
72207: GO 72351
// weapon := list [ rand ( 1 , list ) ] ;
72209: LD_ADDR_VAR 0 18
72213: PUSH
72214: LD_VAR 0 5
72218: PUSH
72219: LD_INT 1
72221: PPUSH
72222: LD_VAR 0 5
72226: PPUSH
72227: CALL_OW 12
72231: ARRAY
72232: ST_TO_ADDR
// end ; if weapon then
72233: LD_VAR 0 18
72237: IFFALSE 72351
// begin tmp := CostOfWeapon ( weapon ) ;
72239: LD_ADDR_VAR 0 14
72243: PUSH
72244: LD_VAR 0 18
72248: PPUSH
72249: CALL_OW 451
72253: ST_TO_ADDR
// j := GetBase ( tower ) ;
72254: LD_ADDR_VAR 0 9
72258: PUSH
72259: LD_VAR 0 1
72263: PPUSH
72264: CALL_OW 274
72268: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
72269: LD_VAR 0 9
72273: PPUSH
72274: LD_INT 1
72276: PPUSH
72277: CALL_OW 275
72281: PUSH
72282: LD_VAR 0 14
72286: PUSH
72287: LD_INT 1
72289: ARRAY
72290: GREATEREQUAL
72291: PUSH
72292: LD_VAR 0 9
72296: PPUSH
72297: LD_INT 2
72299: PPUSH
72300: CALL_OW 275
72304: PUSH
72305: LD_VAR 0 14
72309: PUSH
72310: LD_INT 2
72312: ARRAY
72313: GREATEREQUAL
72314: AND
72315: PUSH
72316: LD_VAR 0 9
72320: PPUSH
72321: LD_INT 3
72323: PPUSH
72324: CALL_OW 275
72328: PUSH
72329: LD_VAR 0 14
72333: PUSH
72334: LD_INT 3
72336: ARRAY
72337: GREATEREQUAL
72338: AND
72339: IFFALSE 72351
// result := weapon ;
72341: LD_ADDR_VAR 0 3
72345: PUSH
72346: LD_VAR 0 18
72350: ST_TO_ADDR
// end ; end ;
72351: LD_VAR 0 3
72355: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
72356: LD_INT 0
72358: PPUSH
72359: PPUSH
// result := true ;
72360: LD_ADDR_VAR 0 3
72364: PUSH
72365: LD_INT 1
72367: ST_TO_ADDR
// if array1 = array2 then
72368: LD_VAR 0 1
72372: PUSH
72373: LD_VAR 0 2
72377: EQUAL
72378: IFFALSE 72438
// begin for i = 1 to array1 do
72380: LD_ADDR_VAR 0 4
72384: PUSH
72385: DOUBLE
72386: LD_INT 1
72388: DEC
72389: ST_TO_ADDR
72390: LD_VAR 0 1
72394: PUSH
72395: FOR_TO
72396: IFFALSE 72434
// if array1 [ i ] <> array2 [ i ] then
72398: LD_VAR 0 1
72402: PUSH
72403: LD_VAR 0 4
72407: ARRAY
72408: PUSH
72409: LD_VAR 0 2
72413: PUSH
72414: LD_VAR 0 4
72418: ARRAY
72419: NONEQUAL
72420: IFFALSE 72432
// begin result := false ;
72422: LD_ADDR_VAR 0 3
72426: PUSH
72427: LD_INT 0
72429: ST_TO_ADDR
// break ;
72430: GO 72434
// end ;
72432: GO 72395
72434: POP
72435: POP
// end else
72436: GO 72446
// result := false ;
72438: LD_ADDR_VAR 0 3
72442: PUSH
72443: LD_INT 0
72445: ST_TO_ADDR
// end ;
72446: LD_VAR 0 3
72450: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
72451: LD_INT 0
72453: PPUSH
72454: PPUSH
72455: PPUSH
// pom := GetBase ( fac ) ;
72456: LD_ADDR_VAR 0 5
72460: PUSH
72461: LD_VAR 0 1
72465: PPUSH
72466: CALL_OW 274
72470: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
72471: LD_ADDR_VAR 0 4
72475: PUSH
72476: LD_VAR 0 2
72480: PUSH
72481: LD_INT 1
72483: ARRAY
72484: PPUSH
72485: LD_VAR 0 2
72489: PUSH
72490: LD_INT 2
72492: ARRAY
72493: PPUSH
72494: LD_VAR 0 2
72498: PUSH
72499: LD_INT 3
72501: ARRAY
72502: PPUSH
72503: LD_VAR 0 2
72507: PUSH
72508: LD_INT 4
72510: ARRAY
72511: PPUSH
72512: CALL_OW 449
72516: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72517: LD_ADDR_VAR 0 3
72521: PUSH
72522: LD_VAR 0 5
72526: PPUSH
72527: LD_INT 1
72529: PPUSH
72530: CALL_OW 275
72534: PUSH
72535: LD_VAR 0 4
72539: PUSH
72540: LD_INT 1
72542: ARRAY
72543: GREATEREQUAL
72544: PUSH
72545: LD_VAR 0 5
72549: PPUSH
72550: LD_INT 2
72552: PPUSH
72553: CALL_OW 275
72557: PUSH
72558: LD_VAR 0 4
72562: PUSH
72563: LD_INT 2
72565: ARRAY
72566: GREATEREQUAL
72567: AND
72568: PUSH
72569: LD_VAR 0 5
72573: PPUSH
72574: LD_INT 3
72576: PPUSH
72577: CALL_OW 275
72581: PUSH
72582: LD_VAR 0 4
72586: PUSH
72587: LD_INT 3
72589: ARRAY
72590: GREATEREQUAL
72591: AND
72592: ST_TO_ADDR
// end ;
72593: LD_VAR 0 3
72597: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
72598: LD_INT 0
72600: PPUSH
72601: PPUSH
72602: PPUSH
72603: PPUSH
// pom := GetBase ( building ) ;
72604: LD_ADDR_VAR 0 3
72608: PUSH
72609: LD_VAR 0 1
72613: PPUSH
72614: CALL_OW 274
72618: ST_TO_ADDR
// if not pom then
72619: LD_VAR 0 3
72623: NOT
72624: IFFALSE 72628
// exit ;
72626: GO 72798
// btype := GetBType ( building ) ;
72628: LD_ADDR_VAR 0 5
72632: PUSH
72633: LD_VAR 0 1
72637: PPUSH
72638: CALL_OW 266
72642: ST_TO_ADDR
// if btype = b_armoury then
72643: LD_VAR 0 5
72647: PUSH
72648: LD_INT 4
72650: EQUAL
72651: IFFALSE 72661
// btype := b_barracks ;
72653: LD_ADDR_VAR 0 5
72657: PUSH
72658: LD_INT 5
72660: ST_TO_ADDR
// if btype = b_depot then
72661: LD_VAR 0 5
72665: PUSH
72666: LD_INT 0
72668: EQUAL
72669: IFFALSE 72679
// btype := b_warehouse ;
72671: LD_ADDR_VAR 0 5
72675: PUSH
72676: LD_INT 1
72678: ST_TO_ADDR
// if btype = b_workshop then
72679: LD_VAR 0 5
72683: PUSH
72684: LD_INT 2
72686: EQUAL
72687: IFFALSE 72697
// btype := b_factory ;
72689: LD_ADDR_VAR 0 5
72693: PUSH
72694: LD_INT 3
72696: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72697: LD_ADDR_VAR 0 4
72701: PUSH
72702: LD_VAR 0 5
72706: PPUSH
72707: LD_VAR 0 1
72711: PPUSH
72712: CALL_OW 248
72716: PPUSH
72717: CALL_OW 450
72721: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72722: LD_ADDR_VAR 0 2
72726: PUSH
72727: LD_VAR 0 3
72731: PPUSH
72732: LD_INT 1
72734: PPUSH
72735: CALL_OW 275
72739: PUSH
72740: LD_VAR 0 4
72744: PUSH
72745: LD_INT 1
72747: ARRAY
72748: GREATEREQUAL
72749: PUSH
72750: LD_VAR 0 3
72754: PPUSH
72755: LD_INT 2
72757: PPUSH
72758: CALL_OW 275
72762: PUSH
72763: LD_VAR 0 4
72767: PUSH
72768: LD_INT 2
72770: ARRAY
72771: GREATEREQUAL
72772: AND
72773: PUSH
72774: LD_VAR 0 3
72778: PPUSH
72779: LD_INT 3
72781: PPUSH
72782: CALL_OW 275
72786: PUSH
72787: LD_VAR 0 4
72791: PUSH
72792: LD_INT 3
72794: ARRAY
72795: GREATEREQUAL
72796: AND
72797: ST_TO_ADDR
// end ;
72798: LD_VAR 0 2
72802: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
72803: LD_INT 0
72805: PPUSH
72806: PPUSH
72807: PPUSH
// pom := GetBase ( building ) ;
72808: LD_ADDR_VAR 0 4
72812: PUSH
72813: LD_VAR 0 1
72817: PPUSH
72818: CALL_OW 274
72822: ST_TO_ADDR
// if not pom then
72823: LD_VAR 0 4
72827: NOT
72828: IFFALSE 72832
// exit ;
72830: GO 72933
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
72832: LD_ADDR_VAR 0 5
72836: PUSH
72837: LD_VAR 0 2
72841: PPUSH
72842: LD_VAR 0 1
72846: PPUSH
72847: CALL_OW 248
72851: PPUSH
72852: CALL_OW 450
72856: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
72857: LD_ADDR_VAR 0 3
72861: PUSH
72862: LD_VAR 0 4
72866: PPUSH
72867: LD_INT 1
72869: PPUSH
72870: CALL_OW 275
72874: PUSH
72875: LD_VAR 0 5
72879: PUSH
72880: LD_INT 1
72882: ARRAY
72883: GREATEREQUAL
72884: PUSH
72885: LD_VAR 0 4
72889: PPUSH
72890: LD_INT 2
72892: PPUSH
72893: CALL_OW 275
72897: PUSH
72898: LD_VAR 0 5
72902: PUSH
72903: LD_INT 2
72905: ARRAY
72906: GREATEREQUAL
72907: AND
72908: PUSH
72909: LD_VAR 0 4
72913: PPUSH
72914: LD_INT 3
72916: PPUSH
72917: CALL_OW 275
72921: PUSH
72922: LD_VAR 0 5
72926: PUSH
72927: LD_INT 3
72929: ARRAY
72930: GREATEREQUAL
72931: AND
72932: ST_TO_ADDR
// end ;
72933: LD_VAR 0 3
72937: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
72938: LD_INT 0
72940: PPUSH
72941: PPUSH
72942: PPUSH
72943: PPUSH
72944: PPUSH
72945: PPUSH
72946: PPUSH
72947: PPUSH
72948: PPUSH
72949: PPUSH
// result := false ;
72950: LD_ADDR_VAR 0 6
72954: PUSH
72955: LD_INT 0
72957: ST_TO_ADDR
// if not base or not btype or not x or not y then
72958: LD_VAR 0 1
72962: NOT
72963: PUSH
72964: LD_VAR 0 2
72968: NOT
72969: OR
72970: PUSH
72971: LD_VAR 0 3
72975: NOT
72976: OR
72977: PUSH
72978: LD_VAR 0 4
72982: NOT
72983: OR
72984: IFFALSE 72988
// exit ;
72986: GO 73579
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
72988: LD_ADDR_VAR 0 12
72992: PUSH
72993: LD_VAR 0 2
72997: PPUSH
72998: LD_VAR 0 3
73002: PPUSH
73003: LD_VAR 0 4
73007: PPUSH
73008: LD_VAR 0 5
73012: PPUSH
73013: LD_VAR 0 1
73017: PUSH
73018: LD_INT 1
73020: ARRAY
73021: PPUSH
73022: CALL_OW 248
73026: PPUSH
73027: LD_INT 0
73029: PPUSH
73030: CALL 74416 0 6
73034: ST_TO_ADDR
// if not hexes then
73035: LD_VAR 0 12
73039: NOT
73040: IFFALSE 73044
// exit ;
73042: GO 73579
// for i = 1 to hexes do
73044: LD_ADDR_VAR 0 7
73048: PUSH
73049: DOUBLE
73050: LD_INT 1
73052: DEC
73053: ST_TO_ADDR
73054: LD_VAR 0 12
73058: PUSH
73059: FOR_TO
73060: IFFALSE 73577
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
73062: LD_ADDR_VAR 0 11
73066: PUSH
73067: LD_VAR 0 12
73071: PUSH
73072: LD_VAR 0 7
73076: ARRAY
73077: PUSH
73078: LD_INT 1
73080: ARRAY
73081: PPUSH
73082: LD_VAR 0 12
73086: PUSH
73087: LD_VAR 0 7
73091: ARRAY
73092: PUSH
73093: LD_INT 2
73095: ARRAY
73096: PPUSH
73097: CALL_OW 428
73101: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
73102: LD_VAR 0 12
73106: PUSH
73107: LD_VAR 0 7
73111: ARRAY
73112: PUSH
73113: LD_INT 1
73115: ARRAY
73116: PPUSH
73117: LD_VAR 0 12
73121: PUSH
73122: LD_VAR 0 7
73126: ARRAY
73127: PUSH
73128: LD_INT 2
73130: ARRAY
73131: PPUSH
73132: CALL_OW 351
73136: PUSH
73137: LD_VAR 0 12
73141: PUSH
73142: LD_VAR 0 7
73146: ARRAY
73147: PUSH
73148: LD_INT 1
73150: ARRAY
73151: PPUSH
73152: LD_VAR 0 12
73156: PUSH
73157: LD_VAR 0 7
73161: ARRAY
73162: PUSH
73163: LD_INT 2
73165: ARRAY
73166: PPUSH
73167: CALL_OW 488
73171: NOT
73172: OR
73173: PUSH
73174: LD_VAR 0 11
73178: PPUSH
73179: CALL_OW 247
73183: PUSH
73184: LD_INT 3
73186: EQUAL
73187: OR
73188: IFFALSE 73194
// exit ;
73190: POP
73191: POP
73192: GO 73579
// if not tmp then
73194: LD_VAR 0 11
73198: NOT
73199: IFFALSE 73203
// continue ;
73201: GO 73059
// result := true ;
73203: LD_ADDR_VAR 0 6
73207: PUSH
73208: LD_INT 1
73210: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
73211: LD_ADDR_VAR 0 15
73215: PUSH
73216: LD_INT 22
73218: PUSH
73219: LD_VAR 0 11
73223: PPUSH
73224: CALL_OW 255
73228: PUSH
73229: EMPTY
73230: LIST
73231: LIST
73232: PUSH
73233: LD_INT 2
73235: PUSH
73236: LD_INT 30
73238: PUSH
73239: LD_INT 0
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 30
73248: PUSH
73249: LD_INT 1
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: LIST
73260: PUSH
73261: EMPTY
73262: LIST
73263: LIST
73264: PPUSH
73265: CALL_OW 69
73269: ST_TO_ADDR
// if dep then
73270: LD_VAR 0 15
73274: IFFALSE 73410
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
73276: LD_ADDR_VAR 0 14
73280: PUSH
73281: LD_VAR 0 15
73285: PUSH
73286: LD_INT 1
73288: ARRAY
73289: PPUSH
73290: CALL_OW 250
73294: PPUSH
73295: LD_VAR 0 15
73299: PUSH
73300: LD_INT 1
73302: ARRAY
73303: PPUSH
73304: CALL_OW 254
73308: PPUSH
73309: LD_INT 5
73311: PPUSH
73312: CALL_OW 272
73316: PUSH
73317: LD_VAR 0 15
73321: PUSH
73322: LD_INT 1
73324: ARRAY
73325: PPUSH
73326: CALL_OW 251
73330: PPUSH
73331: LD_VAR 0 15
73335: PUSH
73336: LD_INT 1
73338: ARRAY
73339: PPUSH
73340: CALL_OW 254
73344: PPUSH
73345: LD_INT 5
73347: PPUSH
73348: CALL_OW 273
73352: PUSH
73353: EMPTY
73354: LIST
73355: LIST
73356: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
73357: LD_VAR 0 14
73361: PUSH
73362: LD_INT 1
73364: ARRAY
73365: PPUSH
73366: LD_VAR 0 14
73370: PUSH
73371: LD_INT 2
73373: ARRAY
73374: PPUSH
73375: CALL_OW 488
73379: IFFALSE 73410
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
73381: LD_VAR 0 11
73385: PPUSH
73386: LD_VAR 0 14
73390: PUSH
73391: LD_INT 1
73393: ARRAY
73394: PPUSH
73395: LD_VAR 0 14
73399: PUSH
73400: LD_INT 2
73402: ARRAY
73403: PPUSH
73404: CALL_OW 111
// continue ;
73408: GO 73059
// end ; end ; r := GetDir ( tmp ) ;
73410: LD_ADDR_VAR 0 13
73414: PUSH
73415: LD_VAR 0 11
73419: PPUSH
73420: CALL_OW 254
73424: ST_TO_ADDR
// if r = 5 then
73425: LD_VAR 0 13
73429: PUSH
73430: LD_INT 5
73432: EQUAL
73433: IFFALSE 73443
// r := 0 ;
73435: LD_ADDR_VAR 0 13
73439: PUSH
73440: LD_INT 0
73442: ST_TO_ADDR
// for j = r to 5 do
73443: LD_ADDR_VAR 0 8
73447: PUSH
73448: DOUBLE
73449: LD_VAR 0 13
73453: DEC
73454: ST_TO_ADDR
73455: LD_INT 5
73457: PUSH
73458: FOR_TO
73459: IFFALSE 73573
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
73461: LD_ADDR_VAR 0 9
73465: PUSH
73466: LD_VAR 0 11
73470: PPUSH
73471: CALL_OW 250
73475: PPUSH
73476: LD_VAR 0 8
73480: PPUSH
73481: LD_INT 2
73483: PPUSH
73484: CALL_OW 272
73488: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
73489: LD_ADDR_VAR 0 10
73493: PUSH
73494: LD_VAR 0 11
73498: PPUSH
73499: CALL_OW 251
73503: PPUSH
73504: LD_VAR 0 8
73508: PPUSH
73509: LD_INT 2
73511: PPUSH
73512: CALL_OW 273
73516: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
73517: LD_VAR 0 9
73521: PPUSH
73522: LD_VAR 0 10
73526: PPUSH
73527: CALL_OW 488
73531: PUSH
73532: LD_VAR 0 9
73536: PPUSH
73537: LD_VAR 0 10
73541: PPUSH
73542: CALL_OW 428
73546: NOT
73547: AND
73548: IFFALSE 73571
// begin ComMoveXY ( tmp , _x , _y ) ;
73550: LD_VAR 0 11
73554: PPUSH
73555: LD_VAR 0 9
73559: PPUSH
73560: LD_VAR 0 10
73564: PPUSH
73565: CALL_OW 111
// break ;
73569: GO 73573
// end ; end ;
73571: GO 73458
73573: POP
73574: POP
// end ;
73575: GO 73059
73577: POP
73578: POP
// end ;
73579: LD_VAR 0 6
73583: RET
// export function CanBeBuilded ( bdepot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
73584: LD_INT 0
73586: PPUSH
73587: PPUSH
73588: PPUSH
73589: PPUSH
73590: PPUSH
73591: PPUSH
73592: PPUSH
73593: PPUSH
73594: PPUSH
73595: PPUSH
// result := false ;
73596: LD_ADDR_VAR 0 6
73600: PUSH
73601: LD_INT 0
73603: ST_TO_ADDR
// if not bdepot or not GetBType ( bdepot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
73604: LD_VAR 0 1
73608: NOT
73609: PUSH
73610: LD_VAR 0 1
73614: PPUSH
73615: CALL_OW 266
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 1
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: IN
73630: NOT
73631: OR
73632: PUSH
73633: LD_VAR 0 2
73637: NOT
73638: OR
73639: PUSH
73640: LD_VAR 0 5
73644: PUSH
73645: LD_INT 0
73647: PUSH
73648: LD_INT 1
73650: PUSH
73651: LD_INT 2
73653: PUSH
73654: LD_INT 3
73656: PUSH
73657: LD_INT 4
73659: PUSH
73660: LD_INT 5
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: LIST
73669: LIST
73670: IN
73671: NOT
73672: OR
73673: PUSH
73674: LD_VAR 0 3
73678: PPUSH
73679: LD_VAR 0 4
73683: PPUSH
73684: CALL_OW 488
73688: NOT
73689: OR
73690: IFFALSE 73694
// exit ;
73692: GO 74411
// pom := GetBase ( bdepot ) ;
73694: LD_ADDR_VAR 0 10
73698: PUSH
73699: LD_VAR 0 1
73703: PPUSH
73704: CALL_OW 274
73708: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( bdepot ) ) ;
73709: LD_ADDR_VAR 0 11
73713: PUSH
73714: LD_VAR 0 2
73718: PPUSH
73719: LD_VAR 0 1
73723: PPUSH
73724: CALL_OW 248
73728: PPUSH
73729: CALL_OW 450
73733: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
73734: LD_VAR 0 10
73738: PPUSH
73739: LD_INT 1
73741: PPUSH
73742: CALL_OW 275
73746: PUSH
73747: LD_VAR 0 11
73751: PUSH
73752: LD_INT 1
73754: ARRAY
73755: GREATEREQUAL
73756: PUSH
73757: LD_VAR 0 10
73761: PPUSH
73762: LD_INT 2
73764: PPUSH
73765: CALL_OW 275
73769: PUSH
73770: LD_VAR 0 11
73774: PUSH
73775: LD_INT 2
73777: ARRAY
73778: GREATEREQUAL
73779: AND
73780: PUSH
73781: LD_VAR 0 10
73785: PPUSH
73786: LD_INT 3
73788: PPUSH
73789: CALL_OW 275
73793: PUSH
73794: LD_VAR 0 11
73798: PUSH
73799: LD_INT 3
73801: ARRAY
73802: GREATEREQUAL
73803: AND
73804: NOT
73805: IFFALSE 73809
// exit ;
73807: GO 74411
// if GetBType ( bdepot ) = b_depot then
73809: LD_VAR 0 1
73813: PPUSH
73814: CALL_OW 266
73818: PUSH
73819: LD_INT 0
73821: EQUAL
73822: IFFALSE 73834
// dist := 28 else
73824: LD_ADDR_VAR 0 14
73828: PUSH
73829: LD_INT 28
73831: ST_TO_ADDR
73832: GO 73842
// dist := 36 ;
73834: LD_ADDR_VAR 0 14
73838: PUSH
73839: LD_INT 36
73841: ST_TO_ADDR
// if GetDistUnitXY ( bdepot , x , y ) > dist then
73842: LD_VAR 0 1
73846: PPUSH
73847: LD_VAR 0 3
73851: PPUSH
73852: LD_VAR 0 4
73856: PPUSH
73857: CALL_OW 297
73861: PUSH
73862: LD_VAR 0 14
73866: GREATER
73867: IFFALSE 73871
// exit ;
73869: GO 74411
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( bdepot ) , 0 ) ;
73871: LD_ADDR_VAR 0 12
73875: PUSH
73876: LD_VAR 0 2
73880: PPUSH
73881: LD_VAR 0 3
73885: PPUSH
73886: LD_VAR 0 4
73890: PPUSH
73891: LD_VAR 0 5
73895: PPUSH
73896: LD_VAR 0 1
73900: PPUSH
73901: CALL_OW 248
73905: PPUSH
73906: LD_INT 0
73908: PPUSH
73909: CALL 74416 0 6
73913: ST_TO_ADDR
// if not hexes then
73914: LD_VAR 0 12
73918: NOT
73919: IFFALSE 73923
// exit ;
73921: GO 74411
// hex := GetHexInfo ( x , y ) ;
73923: LD_ADDR_VAR 0 15
73927: PUSH
73928: LD_VAR 0 3
73932: PPUSH
73933: LD_VAR 0 4
73937: PPUSH
73938: CALL_OW 546
73942: ST_TO_ADDR
// if hex [ 1 ] then
73943: LD_VAR 0 15
73947: PUSH
73948: LD_INT 1
73950: ARRAY
73951: IFFALSE 73955
// exit ;
73953: GO 74411
// height := hex [ 2 ] ;
73955: LD_ADDR_VAR 0 13
73959: PUSH
73960: LD_VAR 0 15
73964: PUSH
73965: LD_INT 2
73967: ARRAY
73968: ST_TO_ADDR
// for i = 1 to hexes do
73969: LD_ADDR_VAR 0 7
73973: PUSH
73974: DOUBLE
73975: LD_INT 1
73977: DEC
73978: ST_TO_ADDR
73979: LD_VAR 0 12
73983: PUSH
73984: FOR_TO
73985: IFFALSE 74315
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
73987: LD_VAR 0 12
73991: PUSH
73992: LD_VAR 0 7
73996: ARRAY
73997: PUSH
73998: LD_INT 1
74000: ARRAY
74001: PPUSH
74002: LD_VAR 0 12
74006: PUSH
74007: LD_VAR 0 7
74011: ARRAY
74012: PUSH
74013: LD_INT 2
74015: ARRAY
74016: PPUSH
74017: CALL_OW 488
74021: NOT
74022: PUSH
74023: LD_VAR 0 12
74027: PUSH
74028: LD_VAR 0 7
74032: ARRAY
74033: PUSH
74034: LD_INT 1
74036: ARRAY
74037: PPUSH
74038: LD_VAR 0 12
74042: PUSH
74043: LD_VAR 0 7
74047: ARRAY
74048: PUSH
74049: LD_INT 2
74051: ARRAY
74052: PPUSH
74053: CALL_OW 428
74057: PUSH
74058: LD_INT 0
74060: GREATER
74061: OR
74062: PUSH
74063: LD_VAR 0 12
74067: PUSH
74068: LD_VAR 0 7
74072: ARRAY
74073: PUSH
74074: LD_INT 1
74076: ARRAY
74077: PPUSH
74078: LD_VAR 0 12
74082: PUSH
74083: LD_VAR 0 7
74087: ARRAY
74088: PUSH
74089: LD_INT 2
74091: ARRAY
74092: PPUSH
74093: CALL_OW 351
74097: OR
74098: IFFALSE 74104
// exit ;
74100: POP
74101: POP
74102: GO 74411
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
74104: LD_ADDR_VAR 0 8
74108: PUSH
74109: LD_VAR 0 12
74113: PUSH
74114: LD_VAR 0 7
74118: ARRAY
74119: PUSH
74120: LD_INT 1
74122: ARRAY
74123: PPUSH
74124: LD_VAR 0 12
74128: PUSH
74129: LD_VAR 0 7
74133: ARRAY
74134: PUSH
74135: LD_INT 2
74137: ARRAY
74138: PPUSH
74139: CALL_OW 546
74143: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
74144: LD_VAR 0 8
74148: PUSH
74149: LD_INT 1
74151: ARRAY
74152: PUSH
74153: LD_VAR 0 8
74157: PUSH
74158: LD_INT 2
74160: ARRAY
74161: PUSH
74162: LD_VAR 0 13
74166: PUSH
74167: LD_INT 2
74169: PLUS
74170: GREATER
74171: OR
74172: PUSH
74173: LD_VAR 0 8
74177: PUSH
74178: LD_INT 2
74180: ARRAY
74181: PUSH
74182: LD_VAR 0 13
74186: PUSH
74187: LD_INT 2
74189: MINUS
74190: LESS
74191: OR
74192: PUSH
74193: LD_VAR 0 8
74197: PUSH
74198: LD_INT 3
74200: ARRAY
74201: PUSH
74202: LD_INT 0
74204: PUSH
74205: LD_INT 8
74207: PUSH
74208: LD_INT 9
74210: PUSH
74211: LD_INT 10
74213: PUSH
74214: LD_INT 11
74216: PUSH
74217: LD_INT 12
74219: PUSH
74220: LD_INT 13
74222: PUSH
74223: LD_INT 16
74225: PUSH
74226: LD_INT 17
74228: PUSH
74229: LD_INT 18
74231: PUSH
74232: LD_INT 19
74234: PUSH
74235: LD_INT 20
74237: PUSH
74238: LD_INT 21
74240: PUSH
74241: EMPTY
74242: LIST
74243: LIST
74244: LIST
74245: LIST
74246: LIST
74247: LIST
74248: LIST
74249: LIST
74250: LIST
74251: LIST
74252: LIST
74253: LIST
74254: LIST
74255: IN
74256: NOT
74257: OR
74258: PUSH
74259: LD_VAR 0 8
74263: PUSH
74264: LD_INT 5
74266: ARRAY
74267: NOT
74268: OR
74269: PUSH
74270: LD_VAR 0 8
74274: PUSH
74275: LD_INT 6
74277: ARRAY
74278: PUSH
74279: LD_INT 1
74281: PUSH
74282: LD_INT 2
74284: PUSH
74285: LD_INT 7
74287: PUSH
74288: LD_INT 9
74290: PUSH
74291: LD_INT 10
74293: PUSH
74294: LD_INT 11
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: IN
74305: NOT
74306: OR
74307: IFFALSE 74313
// exit ;
74309: POP
74310: POP
74311: GO 74411
// end ;
74313: GO 73984
74315: POP
74316: POP
// side := GetSide ( bdepot ) ;
74317: LD_ADDR_VAR 0 9
74321: PUSH
74322: LD_VAR 0 1
74326: PPUSH
74327: CALL_OW 255
74331: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74332: LD_VAR 0 9
74336: PPUSH
74337: LD_VAR 0 3
74341: PPUSH
74342: LD_VAR 0 4
74346: PPUSH
74347: LD_INT 20
74349: PPUSH
74350: CALL 67083 0 4
74354: PUSH
74355: LD_INT 4
74357: ARRAY
74358: IFFALSE 74362
// exit ;
74360: GO 74411
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
74362: LD_VAR 0 2
74366: PUSH
74367: LD_INT 29
74369: PUSH
74370: LD_INT 30
74372: PUSH
74373: EMPTY
74374: LIST
74375: LIST
74376: IN
74377: PUSH
74378: LD_VAR 0 3
74382: PPUSH
74383: LD_VAR 0 4
74387: PPUSH
74388: LD_VAR 0 9
74392: PPUSH
74393: CALL_OW 440
74397: NOT
74398: AND
74399: IFFALSE 74403
// exit ;
74401: GO 74411
// result := true ;
74403: LD_ADDR_VAR 0 6
74407: PUSH
74408: LD_INT 1
74410: ST_TO_ADDR
// end ;
74411: LD_VAR 0 6
74415: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
74416: LD_INT 0
74418: PPUSH
74419: PPUSH
74420: PPUSH
74421: PPUSH
74422: PPUSH
74423: PPUSH
74424: PPUSH
74425: PPUSH
74426: PPUSH
74427: PPUSH
74428: PPUSH
74429: PPUSH
74430: PPUSH
74431: PPUSH
74432: PPUSH
74433: PPUSH
74434: PPUSH
74435: PPUSH
74436: PPUSH
74437: PPUSH
74438: PPUSH
74439: PPUSH
74440: PPUSH
74441: PPUSH
74442: PPUSH
74443: PPUSH
74444: PPUSH
74445: PPUSH
74446: PPUSH
74447: PPUSH
74448: PPUSH
74449: PPUSH
74450: PPUSH
74451: PPUSH
74452: PPUSH
74453: PPUSH
74454: PPUSH
74455: PPUSH
74456: PPUSH
74457: PPUSH
74458: PPUSH
74459: PPUSH
74460: PPUSH
74461: PPUSH
74462: PPUSH
74463: PPUSH
74464: PPUSH
74465: PPUSH
74466: PPUSH
74467: PPUSH
74468: PPUSH
74469: PPUSH
74470: PPUSH
74471: PPUSH
74472: PPUSH
74473: PPUSH
74474: PPUSH
74475: PPUSH
// result = [ ] ;
74476: LD_ADDR_VAR 0 7
74480: PUSH
74481: EMPTY
74482: ST_TO_ADDR
// temp_list = [ ] ;
74483: LD_ADDR_VAR 0 9
74487: PUSH
74488: EMPTY
74489: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
74490: LD_VAR 0 4
74494: PUSH
74495: LD_INT 0
74497: PUSH
74498: LD_INT 1
74500: PUSH
74501: LD_INT 2
74503: PUSH
74504: LD_INT 3
74506: PUSH
74507: LD_INT 4
74509: PUSH
74510: LD_INT 5
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: IN
74521: NOT
74522: PUSH
74523: LD_VAR 0 1
74527: PUSH
74528: LD_INT 0
74530: PUSH
74531: LD_INT 1
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: IN
74538: PUSH
74539: LD_VAR 0 5
74543: PUSH
74544: LD_INT 1
74546: PUSH
74547: LD_INT 2
74549: PUSH
74550: LD_INT 3
74552: PUSH
74553: EMPTY
74554: LIST
74555: LIST
74556: LIST
74557: IN
74558: NOT
74559: AND
74560: OR
74561: IFFALSE 74565
// exit ;
74563: GO 92950
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
74565: LD_VAR 0 1
74569: PUSH
74570: LD_INT 6
74572: PUSH
74573: LD_INT 7
74575: PUSH
74576: LD_INT 8
74578: PUSH
74579: LD_INT 13
74581: PUSH
74582: LD_INT 12
74584: PUSH
74585: LD_INT 15
74587: PUSH
74588: LD_INT 11
74590: PUSH
74591: LD_INT 14
74593: PUSH
74594: LD_INT 10
74596: PUSH
74597: EMPTY
74598: LIST
74599: LIST
74600: LIST
74601: LIST
74602: LIST
74603: LIST
74604: LIST
74605: LIST
74606: LIST
74607: IN
74608: IFFALSE 74618
// btype = b_lab ;
74610: LD_ADDR_VAR 0 1
74614: PUSH
74615: LD_INT 6
74617: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
74618: LD_VAR 0 6
74622: PUSH
74623: LD_INT 0
74625: PUSH
74626: LD_INT 1
74628: PUSH
74629: LD_INT 2
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: LIST
74636: IN
74637: NOT
74638: PUSH
74639: LD_VAR 0 1
74643: PUSH
74644: LD_INT 0
74646: PUSH
74647: LD_INT 1
74649: PUSH
74650: LD_INT 2
74652: PUSH
74653: LD_INT 3
74655: PUSH
74656: LD_INT 6
74658: PUSH
74659: LD_INT 36
74661: PUSH
74662: LD_INT 4
74664: PUSH
74665: LD_INT 5
74667: PUSH
74668: LD_INT 31
74670: PUSH
74671: LD_INT 32
74673: PUSH
74674: LD_INT 33
74676: PUSH
74677: EMPTY
74678: LIST
74679: LIST
74680: LIST
74681: LIST
74682: LIST
74683: LIST
74684: LIST
74685: LIST
74686: LIST
74687: LIST
74688: LIST
74689: IN
74690: NOT
74691: PUSH
74692: LD_VAR 0 6
74696: PUSH
74697: LD_INT 1
74699: EQUAL
74700: AND
74701: OR
74702: PUSH
74703: LD_VAR 0 1
74707: PUSH
74708: LD_INT 2
74710: PUSH
74711: LD_INT 3
74713: PUSH
74714: EMPTY
74715: LIST
74716: LIST
74717: IN
74718: NOT
74719: PUSH
74720: LD_VAR 0 6
74724: PUSH
74725: LD_INT 2
74727: EQUAL
74728: AND
74729: OR
74730: IFFALSE 74740
// mode = 0 ;
74732: LD_ADDR_VAR 0 6
74736: PUSH
74737: LD_INT 0
74739: ST_TO_ADDR
// case mode of 0 :
74740: LD_VAR 0 6
74744: PUSH
74745: LD_INT 0
74747: DOUBLE
74748: EQUAL
74749: IFTRUE 74753
74751: GO 86206
74753: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74754: LD_ADDR_VAR 0 11
74758: PUSH
74759: LD_INT 0
74761: PUSH
74762: LD_INT 0
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 1
74774: NEG
74775: PUSH
74776: EMPTY
74777: LIST
74778: LIST
74779: PUSH
74780: LD_INT 1
74782: PUSH
74783: LD_INT 0
74785: PUSH
74786: EMPTY
74787: LIST
74788: LIST
74789: PUSH
74790: LD_INT 1
74792: PUSH
74793: LD_INT 1
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: LD_INT 0
74802: PUSH
74803: LD_INT 1
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 1
74812: NEG
74813: PUSH
74814: LD_INT 0
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 1
74823: NEG
74824: PUSH
74825: LD_INT 1
74827: NEG
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: PUSH
74833: LD_INT 1
74835: NEG
74836: PUSH
74837: LD_INT 2
74839: NEG
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: PUSH
74845: LD_INT 0
74847: PUSH
74848: LD_INT 2
74850: NEG
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: LD_INT 1
74858: PUSH
74859: LD_INT 1
74861: NEG
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: LD_INT 1
74869: PUSH
74870: LD_INT 2
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 0
74879: PUSH
74880: LD_INT 2
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 1
74889: NEG
74890: PUSH
74891: LD_INT 1
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 3
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 0
74910: PUSH
74911: LD_INT 3
74913: PUSH
74914: EMPTY
74915: LIST
74916: LIST
74917: PUSH
74918: LD_INT 1
74920: NEG
74921: PUSH
74922: LD_INT 2
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: LIST
74933: LIST
74934: LIST
74935: LIST
74936: LIST
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: LIST
74943: LIST
74944: LIST
74945: LIST
74946: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74947: LD_ADDR_VAR 0 12
74951: PUSH
74952: LD_INT 0
74954: PUSH
74955: LD_INT 0
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: LD_INT 0
74964: PUSH
74965: LD_INT 1
74967: NEG
74968: PUSH
74969: EMPTY
74970: LIST
74971: LIST
74972: PUSH
74973: LD_INT 1
74975: PUSH
74976: LD_INT 0
74978: PUSH
74979: EMPTY
74980: LIST
74981: LIST
74982: PUSH
74983: LD_INT 1
74985: PUSH
74986: LD_INT 1
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 0
74995: PUSH
74996: LD_INT 1
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PUSH
75003: LD_INT 1
75005: NEG
75006: PUSH
75007: LD_INT 0
75009: PUSH
75010: EMPTY
75011: LIST
75012: LIST
75013: PUSH
75014: LD_INT 1
75016: NEG
75017: PUSH
75018: LD_INT 1
75020: NEG
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 1
75028: PUSH
75029: LD_INT 1
75031: NEG
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 2
75039: PUSH
75040: LD_INT 0
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 2
75049: PUSH
75050: LD_INT 1
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 1
75059: NEG
75060: PUSH
75061: LD_INT 1
75063: PUSH
75064: EMPTY
75065: LIST
75066: LIST
75067: PUSH
75068: LD_INT 2
75070: NEG
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 2
75081: NEG
75082: PUSH
75083: LD_INT 1
75085: NEG
75086: PUSH
75087: EMPTY
75088: LIST
75089: LIST
75090: PUSH
75091: LD_INT 2
75093: NEG
75094: PUSH
75095: LD_INT 1
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PUSH
75102: LD_INT 3
75104: NEG
75105: PUSH
75106: LD_INT 0
75108: PUSH
75109: EMPTY
75110: LIST
75111: LIST
75112: PUSH
75113: LD_INT 3
75115: NEG
75116: PUSH
75117: LD_INT 1
75119: NEG
75120: PUSH
75121: EMPTY
75122: LIST
75123: LIST
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: LIST
75134: LIST
75135: LIST
75136: LIST
75137: LIST
75138: LIST
75139: LIST
75140: LIST
75141: LIST
75142: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75143: LD_ADDR_VAR 0 13
75147: PUSH
75148: LD_INT 0
75150: PUSH
75151: LD_INT 0
75153: PUSH
75154: EMPTY
75155: LIST
75156: LIST
75157: PUSH
75158: LD_INT 0
75160: PUSH
75161: LD_INT 1
75163: NEG
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 1
75171: PUSH
75172: LD_INT 0
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 1
75181: PUSH
75182: LD_INT 1
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 0
75191: PUSH
75192: LD_INT 1
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: LD_INT 0
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 1
75212: NEG
75213: PUSH
75214: LD_INT 1
75216: NEG
75217: PUSH
75218: EMPTY
75219: LIST
75220: LIST
75221: PUSH
75222: LD_INT 1
75224: NEG
75225: PUSH
75226: LD_INT 2
75228: NEG
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 2
75236: PUSH
75237: LD_INT 1
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: PUSH
75244: LD_INT 2
75246: PUSH
75247: LD_INT 2
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: LD_INT 1
75256: PUSH
75257: LD_INT 2
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: PUSH
75264: LD_INT 2
75266: NEG
75267: PUSH
75268: LD_INT 1
75270: NEG
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 2
75278: NEG
75279: PUSH
75280: LD_INT 2
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 2
75290: NEG
75291: PUSH
75292: LD_INT 3
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: LD_INT 3
75302: NEG
75303: PUSH
75304: LD_INT 2
75306: NEG
75307: PUSH
75308: EMPTY
75309: LIST
75310: LIST
75311: PUSH
75312: LD_INT 3
75314: NEG
75315: PUSH
75316: LD_INT 3
75318: NEG
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: PUSH
75324: EMPTY
75325: LIST
75326: LIST
75327: LIST
75328: LIST
75329: LIST
75330: LIST
75331: LIST
75332: LIST
75333: LIST
75334: LIST
75335: LIST
75336: LIST
75337: LIST
75338: LIST
75339: LIST
75340: LIST
75341: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75342: LD_ADDR_VAR 0 14
75346: PUSH
75347: LD_INT 0
75349: PUSH
75350: LD_INT 0
75352: PUSH
75353: EMPTY
75354: LIST
75355: LIST
75356: PUSH
75357: LD_INT 0
75359: PUSH
75360: LD_INT 1
75362: NEG
75363: PUSH
75364: EMPTY
75365: LIST
75366: LIST
75367: PUSH
75368: LD_INT 1
75370: PUSH
75371: LD_INT 0
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: PUSH
75381: LD_INT 1
75383: PUSH
75384: EMPTY
75385: LIST
75386: LIST
75387: PUSH
75388: LD_INT 0
75390: PUSH
75391: LD_INT 1
75393: PUSH
75394: EMPTY
75395: LIST
75396: LIST
75397: PUSH
75398: LD_INT 1
75400: NEG
75401: PUSH
75402: LD_INT 0
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: LD_INT 1
75411: NEG
75412: PUSH
75413: LD_INT 1
75415: NEG
75416: PUSH
75417: EMPTY
75418: LIST
75419: LIST
75420: PUSH
75421: LD_INT 1
75423: NEG
75424: PUSH
75425: LD_INT 2
75427: NEG
75428: PUSH
75429: EMPTY
75430: LIST
75431: LIST
75432: PUSH
75433: LD_INT 0
75435: PUSH
75436: LD_INT 2
75438: NEG
75439: PUSH
75440: EMPTY
75441: LIST
75442: LIST
75443: PUSH
75444: LD_INT 1
75446: PUSH
75447: LD_INT 1
75449: NEG
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 1
75457: PUSH
75458: LD_INT 2
75460: PUSH
75461: EMPTY
75462: LIST
75463: LIST
75464: PUSH
75465: LD_INT 0
75467: PUSH
75468: LD_INT 2
75470: PUSH
75471: EMPTY
75472: LIST
75473: LIST
75474: PUSH
75475: LD_INT 1
75477: NEG
75478: PUSH
75479: LD_INT 1
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 1
75488: NEG
75489: PUSH
75490: LD_INT 3
75492: NEG
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 0
75500: PUSH
75501: LD_INT 3
75503: NEG
75504: PUSH
75505: EMPTY
75506: LIST
75507: LIST
75508: PUSH
75509: LD_INT 1
75511: PUSH
75512: LD_INT 2
75514: NEG
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: PUSH
75520: EMPTY
75521: LIST
75522: LIST
75523: LIST
75524: LIST
75525: LIST
75526: LIST
75527: LIST
75528: LIST
75529: LIST
75530: LIST
75531: LIST
75532: LIST
75533: LIST
75534: LIST
75535: LIST
75536: LIST
75537: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75538: LD_ADDR_VAR 0 15
75542: PUSH
75543: LD_INT 0
75545: PUSH
75546: LD_INT 0
75548: PUSH
75549: EMPTY
75550: LIST
75551: LIST
75552: PUSH
75553: LD_INT 0
75555: PUSH
75556: LD_INT 1
75558: NEG
75559: PUSH
75560: EMPTY
75561: LIST
75562: LIST
75563: PUSH
75564: LD_INT 1
75566: PUSH
75567: LD_INT 0
75569: PUSH
75570: EMPTY
75571: LIST
75572: LIST
75573: PUSH
75574: LD_INT 1
75576: PUSH
75577: LD_INT 1
75579: PUSH
75580: EMPTY
75581: LIST
75582: LIST
75583: PUSH
75584: LD_INT 0
75586: PUSH
75587: LD_INT 1
75589: PUSH
75590: EMPTY
75591: LIST
75592: LIST
75593: PUSH
75594: LD_INT 1
75596: NEG
75597: PUSH
75598: LD_INT 0
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 1
75607: NEG
75608: PUSH
75609: LD_INT 1
75611: NEG
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: PUSH
75617: LD_INT 1
75619: PUSH
75620: LD_INT 1
75622: NEG
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 2
75630: PUSH
75631: LD_INT 0
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 2
75640: PUSH
75641: LD_INT 1
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 1
75650: NEG
75651: PUSH
75652: LD_INT 1
75654: PUSH
75655: EMPTY
75656: LIST
75657: LIST
75658: PUSH
75659: LD_INT 2
75661: NEG
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: EMPTY
75667: LIST
75668: LIST
75669: PUSH
75670: LD_INT 2
75672: NEG
75673: PUSH
75674: LD_INT 1
75676: NEG
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 2
75684: PUSH
75685: LD_INT 1
75687: NEG
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PUSH
75693: LD_INT 3
75695: PUSH
75696: LD_INT 0
75698: PUSH
75699: EMPTY
75700: LIST
75701: LIST
75702: PUSH
75703: LD_INT 3
75705: PUSH
75706: LD_INT 1
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: PUSH
75713: EMPTY
75714: LIST
75715: LIST
75716: LIST
75717: LIST
75718: LIST
75719: LIST
75720: LIST
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75731: LD_ADDR_VAR 0 16
75735: PUSH
75736: LD_INT 0
75738: PUSH
75739: LD_INT 0
75741: PUSH
75742: EMPTY
75743: LIST
75744: LIST
75745: PUSH
75746: LD_INT 0
75748: PUSH
75749: LD_INT 1
75751: NEG
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 1
75759: PUSH
75760: LD_INT 0
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 1
75769: PUSH
75770: LD_INT 1
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: LD_INT 0
75779: PUSH
75780: LD_INT 1
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 1
75789: NEG
75790: PUSH
75791: LD_INT 0
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: LD_INT 1
75804: NEG
75805: PUSH
75806: EMPTY
75807: LIST
75808: LIST
75809: PUSH
75810: LD_INT 1
75812: NEG
75813: PUSH
75814: LD_INT 2
75816: NEG
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: PUSH
75822: LD_INT 2
75824: PUSH
75825: LD_INT 1
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 2
75834: PUSH
75835: LD_INT 2
75837: PUSH
75838: EMPTY
75839: LIST
75840: LIST
75841: PUSH
75842: LD_INT 1
75844: PUSH
75845: LD_INT 2
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: LD_INT 1
75858: NEG
75859: PUSH
75860: EMPTY
75861: LIST
75862: LIST
75863: PUSH
75864: LD_INT 2
75866: NEG
75867: PUSH
75868: LD_INT 2
75870: NEG
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 3
75878: PUSH
75879: LD_INT 2
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 3
75888: PUSH
75889: LD_INT 3
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: LD_INT 2
75898: PUSH
75899: LD_INT 3
75901: PUSH
75902: EMPTY
75903: LIST
75904: LIST
75905: PUSH
75906: EMPTY
75907: LIST
75908: LIST
75909: LIST
75910: LIST
75911: LIST
75912: LIST
75913: LIST
75914: LIST
75915: LIST
75916: LIST
75917: LIST
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75924: LD_ADDR_VAR 0 17
75928: PUSH
75929: LD_INT 0
75931: PUSH
75932: LD_INT 0
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: LD_INT 0
75941: PUSH
75942: LD_INT 1
75944: NEG
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: PUSH
75950: LD_INT 1
75952: PUSH
75953: LD_INT 0
75955: PUSH
75956: EMPTY
75957: LIST
75958: LIST
75959: PUSH
75960: LD_INT 1
75962: PUSH
75963: LD_INT 1
75965: PUSH
75966: EMPTY
75967: LIST
75968: LIST
75969: PUSH
75970: LD_INT 0
75972: PUSH
75973: LD_INT 1
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 1
75982: NEG
75983: PUSH
75984: LD_INT 0
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: LD_INT 1
75993: NEG
75994: PUSH
75995: LD_INT 1
75997: NEG
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 1
76005: NEG
76006: PUSH
76007: LD_INT 2
76009: NEG
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 0
76017: PUSH
76018: LD_INT 2
76020: NEG
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: LD_INT 1
76028: PUSH
76029: LD_INT 1
76031: NEG
76032: PUSH
76033: EMPTY
76034: LIST
76035: LIST
76036: PUSH
76037: LD_INT 2
76039: PUSH
76040: LD_INT 0
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: PUSH
76047: LD_INT 2
76049: PUSH
76050: LD_INT 1
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 2
76059: PUSH
76060: LD_INT 2
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: PUSH
76067: LD_INT 1
76069: PUSH
76070: LD_INT 2
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 0
76079: PUSH
76080: LD_INT 2
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: PUSH
76087: LD_INT 1
76089: NEG
76090: PUSH
76091: LD_INT 1
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 2
76100: NEG
76101: PUSH
76102: LD_INT 0
76104: PUSH
76105: EMPTY
76106: LIST
76107: LIST
76108: PUSH
76109: LD_INT 2
76111: NEG
76112: PUSH
76113: LD_INT 1
76115: NEG
76116: PUSH
76117: EMPTY
76118: LIST
76119: LIST
76120: PUSH
76121: LD_INT 2
76123: NEG
76124: PUSH
76125: LD_INT 2
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: LIST
76137: LIST
76138: LIST
76139: LIST
76140: LIST
76141: LIST
76142: LIST
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: LIST
76148: LIST
76149: LIST
76150: LIST
76151: LIST
76152: LIST
76153: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76154: LD_ADDR_VAR 0 18
76158: PUSH
76159: LD_INT 0
76161: PUSH
76162: LD_INT 0
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: PUSH
76169: LD_INT 0
76171: PUSH
76172: LD_INT 1
76174: NEG
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: PUSH
76180: LD_INT 1
76182: PUSH
76183: LD_INT 0
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 1
76192: PUSH
76193: LD_INT 1
76195: PUSH
76196: EMPTY
76197: LIST
76198: LIST
76199: PUSH
76200: LD_INT 0
76202: PUSH
76203: LD_INT 1
76205: PUSH
76206: EMPTY
76207: LIST
76208: LIST
76209: PUSH
76210: LD_INT 1
76212: NEG
76213: PUSH
76214: LD_INT 0
76216: PUSH
76217: EMPTY
76218: LIST
76219: LIST
76220: PUSH
76221: LD_INT 1
76223: NEG
76224: PUSH
76225: LD_INT 1
76227: NEG
76228: PUSH
76229: EMPTY
76230: LIST
76231: LIST
76232: PUSH
76233: LD_INT 1
76235: NEG
76236: PUSH
76237: LD_INT 2
76239: NEG
76240: PUSH
76241: EMPTY
76242: LIST
76243: LIST
76244: PUSH
76245: LD_INT 0
76247: PUSH
76248: LD_INT 2
76250: NEG
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: LD_INT 1
76258: PUSH
76259: LD_INT 1
76261: NEG
76262: PUSH
76263: EMPTY
76264: LIST
76265: LIST
76266: PUSH
76267: LD_INT 2
76269: PUSH
76270: LD_INT 0
76272: PUSH
76273: EMPTY
76274: LIST
76275: LIST
76276: PUSH
76277: LD_INT 2
76279: PUSH
76280: LD_INT 1
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 2
76289: PUSH
76290: LD_INT 2
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 1
76299: PUSH
76300: LD_INT 2
76302: PUSH
76303: EMPTY
76304: LIST
76305: LIST
76306: PUSH
76307: LD_INT 0
76309: PUSH
76310: LD_INT 2
76312: PUSH
76313: EMPTY
76314: LIST
76315: LIST
76316: PUSH
76317: LD_INT 1
76319: NEG
76320: PUSH
76321: LD_INT 1
76323: PUSH
76324: EMPTY
76325: LIST
76326: LIST
76327: PUSH
76328: LD_INT 2
76330: NEG
76331: PUSH
76332: LD_INT 0
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: PUSH
76339: LD_INT 2
76341: NEG
76342: PUSH
76343: LD_INT 1
76345: NEG
76346: PUSH
76347: EMPTY
76348: LIST
76349: LIST
76350: PUSH
76351: LD_INT 2
76353: NEG
76354: PUSH
76355: LD_INT 2
76357: NEG
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PUSH
76363: EMPTY
76364: LIST
76365: LIST
76366: LIST
76367: LIST
76368: LIST
76369: LIST
76370: LIST
76371: LIST
76372: LIST
76373: LIST
76374: LIST
76375: LIST
76376: LIST
76377: LIST
76378: LIST
76379: LIST
76380: LIST
76381: LIST
76382: LIST
76383: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76384: LD_ADDR_VAR 0 19
76388: PUSH
76389: LD_INT 0
76391: PUSH
76392: LD_INT 0
76394: PUSH
76395: EMPTY
76396: LIST
76397: LIST
76398: PUSH
76399: LD_INT 0
76401: PUSH
76402: LD_INT 1
76404: NEG
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 1
76412: PUSH
76413: LD_INT 0
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 1
76422: PUSH
76423: LD_INT 1
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 0
76432: PUSH
76433: LD_INT 1
76435: PUSH
76436: EMPTY
76437: LIST
76438: LIST
76439: PUSH
76440: LD_INT 1
76442: NEG
76443: PUSH
76444: LD_INT 0
76446: PUSH
76447: EMPTY
76448: LIST
76449: LIST
76450: PUSH
76451: LD_INT 1
76453: NEG
76454: PUSH
76455: LD_INT 1
76457: NEG
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 1
76465: NEG
76466: PUSH
76467: LD_INT 2
76469: NEG
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: LD_INT 0
76477: PUSH
76478: LD_INT 2
76480: NEG
76481: PUSH
76482: EMPTY
76483: LIST
76484: LIST
76485: PUSH
76486: LD_INT 1
76488: PUSH
76489: LD_INT 1
76491: NEG
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 2
76499: PUSH
76500: LD_INT 0
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: PUSH
76507: LD_INT 2
76509: PUSH
76510: LD_INT 1
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: PUSH
76517: LD_INT 2
76519: PUSH
76520: LD_INT 2
76522: PUSH
76523: EMPTY
76524: LIST
76525: LIST
76526: PUSH
76527: LD_INT 1
76529: PUSH
76530: LD_INT 2
76532: PUSH
76533: EMPTY
76534: LIST
76535: LIST
76536: PUSH
76537: LD_INT 0
76539: PUSH
76540: LD_INT 2
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 1
76549: NEG
76550: PUSH
76551: LD_INT 1
76553: PUSH
76554: EMPTY
76555: LIST
76556: LIST
76557: PUSH
76558: LD_INT 2
76560: NEG
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 2
76571: NEG
76572: PUSH
76573: LD_INT 1
76575: NEG
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: PUSH
76581: LD_INT 2
76583: NEG
76584: PUSH
76585: LD_INT 2
76587: NEG
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: LIST
76600: LIST
76601: LIST
76602: LIST
76603: LIST
76604: LIST
76605: LIST
76606: LIST
76607: LIST
76608: LIST
76609: LIST
76610: LIST
76611: LIST
76612: LIST
76613: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76614: LD_ADDR_VAR 0 20
76618: PUSH
76619: LD_INT 0
76621: PUSH
76622: LD_INT 0
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 0
76631: PUSH
76632: LD_INT 1
76634: NEG
76635: PUSH
76636: EMPTY
76637: LIST
76638: LIST
76639: PUSH
76640: LD_INT 1
76642: PUSH
76643: LD_INT 0
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 1
76652: PUSH
76653: LD_INT 1
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: LD_INT 1
76665: PUSH
76666: EMPTY
76667: LIST
76668: LIST
76669: PUSH
76670: LD_INT 1
76672: NEG
76673: PUSH
76674: LD_INT 0
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PUSH
76681: LD_INT 1
76683: NEG
76684: PUSH
76685: LD_INT 1
76687: NEG
76688: PUSH
76689: EMPTY
76690: LIST
76691: LIST
76692: PUSH
76693: LD_INT 1
76695: NEG
76696: PUSH
76697: LD_INT 2
76699: NEG
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 0
76707: PUSH
76708: LD_INT 2
76710: NEG
76711: PUSH
76712: EMPTY
76713: LIST
76714: LIST
76715: PUSH
76716: LD_INT 1
76718: PUSH
76719: LD_INT 1
76721: NEG
76722: PUSH
76723: EMPTY
76724: LIST
76725: LIST
76726: PUSH
76727: LD_INT 2
76729: PUSH
76730: LD_INT 0
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 2
76739: PUSH
76740: LD_INT 1
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 2
76749: PUSH
76750: LD_INT 2
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: PUSH
76757: LD_INT 1
76759: PUSH
76760: LD_INT 2
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: PUSH
76767: LD_INT 0
76769: PUSH
76770: LD_INT 2
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: PUSH
76777: LD_INT 1
76779: NEG
76780: PUSH
76781: LD_INT 1
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PUSH
76788: LD_INT 2
76790: NEG
76791: PUSH
76792: LD_INT 0
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 2
76801: NEG
76802: PUSH
76803: LD_INT 1
76805: NEG
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: PUSH
76811: LD_INT 2
76813: NEG
76814: PUSH
76815: LD_INT 2
76817: NEG
76818: PUSH
76819: EMPTY
76820: LIST
76821: LIST
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: LIST
76827: LIST
76828: LIST
76829: LIST
76830: LIST
76831: LIST
76832: LIST
76833: LIST
76834: LIST
76835: LIST
76836: LIST
76837: LIST
76838: LIST
76839: LIST
76840: LIST
76841: LIST
76842: LIST
76843: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76844: LD_ADDR_VAR 0 21
76848: PUSH
76849: LD_INT 0
76851: PUSH
76852: LD_INT 0
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: PUSH
76859: LD_INT 0
76861: PUSH
76862: LD_INT 1
76864: NEG
76865: PUSH
76866: EMPTY
76867: LIST
76868: LIST
76869: PUSH
76870: LD_INT 1
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: EMPTY
76877: LIST
76878: LIST
76879: PUSH
76880: LD_INT 1
76882: PUSH
76883: LD_INT 1
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 0
76892: PUSH
76893: LD_INT 1
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: LD_INT 1
76902: NEG
76903: PUSH
76904: LD_INT 0
76906: PUSH
76907: EMPTY
76908: LIST
76909: LIST
76910: PUSH
76911: LD_INT 1
76913: NEG
76914: PUSH
76915: LD_INT 1
76917: NEG
76918: PUSH
76919: EMPTY
76920: LIST
76921: LIST
76922: PUSH
76923: LD_INT 1
76925: NEG
76926: PUSH
76927: LD_INT 2
76929: NEG
76930: PUSH
76931: EMPTY
76932: LIST
76933: LIST
76934: PUSH
76935: LD_INT 0
76937: PUSH
76938: LD_INT 2
76940: NEG
76941: PUSH
76942: EMPTY
76943: LIST
76944: LIST
76945: PUSH
76946: LD_INT 1
76948: PUSH
76949: LD_INT 1
76951: NEG
76952: PUSH
76953: EMPTY
76954: LIST
76955: LIST
76956: PUSH
76957: LD_INT 2
76959: PUSH
76960: LD_INT 0
76962: PUSH
76963: EMPTY
76964: LIST
76965: LIST
76966: PUSH
76967: LD_INT 2
76969: PUSH
76970: LD_INT 1
76972: PUSH
76973: EMPTY
76974: LIST
76975: LIST
76976: PUSH
76977: LD_INT 2
76979: PUSH
76980: LD_INT 2
76982: PUSH
76983: EMPTY
76984: LIST
76985: LIST
76986: PUSH
76987: LD_INT 1
76989: PUSH
76990: LD_INT 2
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: LD_INT 0
76999: PUSH
77000: LD_INT 2
77002: PUSH
77003: EMPTY
77004: LIST
77005: LIST
77006: PUSH
77007: LD_INT 1
77009: NEG
77010: PUSH
77011: LD_INT 1
77013: PUSH
77014: EMPTY
77015: LIST
77016: LIST
77017: PUSH
77018: LD_INT 2
77020: NEG
77021: PUSH
77022: LD_INT 0
77024: PUSH
77025: EMPTY
77026: LIST
77027: LIST
77028: PUSH
77029: LD_INT 2
77031: NEG
77032: PUSH
77033: LD_INT 1
77035: NEG
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 2
77043: NEG
77044: PUSH
77045: LD_INT 2
77047: NEG
77048: PUSH
77049: EMPTY
77050: LIST
77051: LIST
77052: PUSH
77053: EMPTY
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: LIST
77070: LIST
77071: LIST
77072: LIST
77073: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77074: LD_ADDR_VAR 0 22
77078: PUSH
77079: LD_INT 0
77081: PUSH
77082: LD_INT 0
77084: PUSH
77085: EMPTY
77086: LIST
77087: LIST
77088: PUSH
77089: LD_INT 0
77091: PUSH
77092: LD_INT 1
77094: NEG
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 1
77102: PUSH
77103: LD_INT 0
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 1
77112: PUSH
77113: LD_INT 1
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 0
77122: PUSH
77123: LD_INT 1
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 1
77132: NEG
77133: PUSH
77134: LD_INT 0
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 1
77143: NEG
77144: PUSH
77145: LD_INT 1
77147: NEG
77148: PUSH
77149: EMPTY
77150: LIST
77151: LIST
77152: PUSH
77153: LD_INT 1
77155: NEG
77156: PUSH
77157: LD_INT 2
77159: NEG
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 0
77167: PUSH
77168: LD_INT 2
77170: NEG
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 1
77178: PUSH
77179: LD_INT 1
77181: NEG
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 2
77189: PUSH
77190: LD_INT 0
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 2
77199: PUSH
77200: LD_INT 1
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 2
77209: PUSH
77210: LD_INT 2
77212: PUSH
77213: EMPTY
77214: LIST
77215: LIST
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: LD_INT 2
77222: PUSH
77223: EMPTY
77224: LIST
77225: LIST
77226: PUSH
77227: LD_INT 0
77229: PUSH
77230: LD_INT 2
77232: PUSH
77233: EMPTY
77234: LIST
77235: LIST
77236: PUSH
77237: LD_INT 1
77239: NEG
77240: PUSH
77241: LD_INT 1
77243: PUSH
77244: EMPTY
77245: LIST
77246: LIST
77247: PUSH
77248: LD_INT 2
77250: NEG
77251: PUSH
77252: LD_INT 0
77254: PUSH
77255: EMPTY
77256: LIST
77257: LIST
77258: PUSH
77259: LD_INT 2
77261: NEG
77262: PUSH
77263: LD_INT 1
77265: NEG
77266: PUSH
77267: EMPTY
77268: LIST
77269: LIST
77270: PUSH
77271: LD_INT 2
77273: NEG
77274: PUSH
77275: LD_INT 2
77277: NEG
77278: PUSH
77279: EMPTY
77280: LIST
77281: LIST
77282: PUSH
77283: EMPTY
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: LIST
77289: LIST
77290: LIST
77291: LIST
77292: LIST
77293: LIST
77294: LIST
77295: LIST
77296: LIST
77297: LIST
77298: LIST
77299: LIST
77300: LIST
77301: LIST
77302: LIST
77303: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77304: LD_ADDR_VAR 0 23
77308: PUSH
77309: LD_INT 0
77311: PUSH
77312: LD_INT 0
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 0
77321: PUSH
77322: LD_INT 1
77324: NEG
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 1
77332: PUSH
77333: LD_INT 0
77335: PUSH
77336: EMPTY
77337: LIST
77338: LIST
77339: PUSH
77340: LD_INT 1
77342: PUSH
77343: LD_INT 1
77345: PUSH
77346: EMPTY
77347: LIST
77348: LIST
77349: PUSH
77350: LD_INT 0
77352: PUSH
77353: LD_INT 1
77355: PUSH
77356: EMPTY
77357: LIST
77358: LIST
77359: PUSH
77360: LD_INT 1
77362: NEG
77363: PUSH
77364: LD_INT 0
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PUSH
77371: LD_INT 1
77373: NEG
77374: PUSH
77375: LD_INT 1
77377: NEG
77378: PUSH
77379: EMPTY
77380: LIST
77381: LIST
77382: PUSH
77383: LD_INT 1
77385: NEG
77386: PUSH
77387: LD_INT 2
77389: NEG
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: PUSH
77395: LD_INT 0
77397: PUSH
77398: LD_INT 2
77400: NEG
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 1
77408: PUSH
77409: LD_INT 1
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 2
77419: PUSH
77420: LD_INT 0
77422: PUSH
77423: EMPTY
77424: LIST
77425: LIST
77426: PUSH
77427: LD_INT 2
77429: PUSH
77430: LD_INT 1
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 2
77439: PUSH
77440: LD_INT 2
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 1
77449: PUSH
77450: LD_INT 2
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: PUSH
77457: LD_INT 0
77459: PUSH
77460: LD_INT 2
77462: PUSH
77463: EMPTY
77464: LIST
77465: LIST
77466: PUSH
77467: LD_INT 1
77469: NEG
77470: PUSH
77471: LD_INT 1
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: LD_INT 2
77480: NEG
77481: PUSH
77482: LD_INT 0
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: PUSH
77489: LD_INT 2
77491: NEG
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 2
77503: NEG
77504: PUSH
77505: LD_INT 2
77507: NEG
77508: PUSH
77509: EMPTY
77510: LIST
77511: LIST
77512: PUSH
77513: LD_INT 2
77515: NEG
77516: PUSH
77517: LD_INT 3
77519: NEG
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 1
77527: NEG
77528: PUSH
77529: LD_INT 3
77531: NEG
77532: PUSH
77533: EMPTY
77534: LIST
77535: LIST
77536: PUSH
77537: LD_INT 1
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: EMPTY
77545: LIST
77546: LIST
77547: PUSH
77548: LD_INT 2
77550: PUSH
77551: LD_INT 1
77553: NEG
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: LIST
77563: LIST
77564: LIST
77565: LIST
77566: LIST
77567: LIST
77568: LIST
77569: LIST
77570: LIST
77571: LIST
77572: LIST
77573: LIST
77574: LIST
77575: LIST
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
77584: LD_ADDR_VAR 0 24
77588: PUSH
77589: LD_INT 0
77591: PUSH
77592: LD_INT 0
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 0
77601: PUSH
77602: LD_INT 1
77604: NEG
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PUSH
77610: LD_INT 1
77612: PUSH
77613: LD_INT 0
77615: PUSH
77616: EMPTY
77617: LIST
77618: LIST
77619: PUSH
77620: LD_INT 1
77622: PUSH
77623: LD_INT 1
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PUSH
77630: LD_INT 0
77632: PUSH
77633: LD_INT 1
77635: PUSH
77636: EMPTY
77637: LIST
77638: LIST
77639: PUSH
77640: LD_INT 1
77642: NEG
77643: PUSH
77644: LD_INT 0
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: LD_INT 1
77653: NEG
77654: PUSH
77655: LD_INT 1
77657: NEG
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 1
77665: NEG
77666: PUSH
77667: LD_INT 2
77669: NEG
77670: PUSH
77671: EMPTY
77672: LIST
77673: LIST
77674: PUSH
77675: LD_INT 0
77677: PUSH
77678: LD_INT 2
77680: NEG
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: LD_INT 1
77688: PUSH
77689: LD_INT 1
77691: NEG
77692: PUSH
77693: EMPTY
77694: LIST
77695: LIST
77696: PUSH
77697: LD_INT 2
77699: PUSH
77700: LD_INT 0
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 2
77709: PUSH
77710: LD_INT 1
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 2
77719: PUSH
77720: LD_INT 2
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 1
77729: PUSH
77730: LD_INT 2
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: LD_INT 0
77739: PUSH
77740: LD_INT 2
77742: PUSH
77743: EMPTY
77744: LIST
77745: LIST
77746: PUSH
77747: LD_INT 1
77749: NEG
77750: PUSH
77751: LD_INT 1
77753: PUSH
77754: EMPTY
77755: LIST
77756: LIST
77757: PUSH
77758: LD_INT 2
77760: NEG
77761: PUSH
77762: LD_INT 0
77764: PUSH
77765: EMPTY
77766: LIST
77767: LIST
77768: PUSH
77769: LD_INT 2
77771: NEG
77772: PUSH
77773: LD_INT 1
77775: NEG
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 2
77783: NEG
77784: PUSH
77785: LD_INT 2
77787: NEG
77788: PUSH
77789: EMPTY
77790: LIST
77791: LIST
77792: PUSH
77793: LD_INT 1
77795: PUSH
77796: LD_INT 2
77798: NEG
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: LD_INT 2
77806: PUSH
77807: LD_INT 1
77809: NEG
77810: PUSH
77811: EMPTY
77812: LIST
77813: LIST
77814: PUSH
77815: LD_INT 3
77817: PUSH
77818: LD_INT 1
77820: PUSH
77821: EMPTY
77822: LIST
77823: LIST
77824: PUSH
77825: LD_INT 3
77827: PUSH
77828: LD_INT 2
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: LIST
77839: LIST
77840: LIST
77841: LIST
77842: LIST
77843: LIST
77844: LIST
77845: LIST
77846: LIST
77847: LIST
77848: LIST
77849: LIST
77850: LIST
77851: LIST
77852: LIST
77853: LIST
77854: LIST
77855: LIST
77856: LIST
77857: LIST
77858: LIST
77859: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
77860: LD_ADDR_VAR 0 25
77864: PUSH
77865: LD_INT 0
77867: PUSH
77868: LD_INT 0
77870: PUSH
77871: EMPTY
77872: LIST
77873: LIST
77874: PUSH
77875: LD_INT 0
77877: PUSH
77878: LD_INT 1
77880: NEG
77881: PUSH
77882: EMPTY
77883: LIST
77884: LIST
77885: PUSH
77886: LD_INT 1
77888: PUSH
77889: LD_INT 0
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PUSH
77896: LD_INT 1
77898: PUSH
77899: LD_INT 1
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 0
77908: PUSH
77909: LD_INT 1
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 1
77918: NEG
77919: PUSH
77920: LD_INT 0
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 1
77929: NEG
77930: PUSH
77931: LD_INT 1
77933: NEG
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 1
77941: NEG
77942: PUSH
77943: LD_INT 2
77945: NEG
77946: PUSH
77947: EMPTY
77948: LIST
77949: LIST
77950: PUSH
77951: LD_INT 0
77953: PUSH
77954: LD_INT 2
77956: NEG
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 1
77964: PUSH
77965: LD_INT 1
77967: NEG
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 2
77975: PUSH
77976: LD_INT 0
77978: PUSH
77979: EMPTY
77980: LIST
77981: LIST
77982: PUSH
77983: LD_INT 2
77985: PUSH
77986: LD_INT 1
77988: PUSH
77989: EMPTY
77990: LIST
77991: LIST
77992: PUSH
77993: LD_INT 2
77995: PUSH
77996: LD_INT 2
77998: PUSH
77999: EMPTY
78000: LIST
78001: LIST
78002: PUSH
78003: LD_INT 1
78005: PUSH
78006: LD_INT 2
78008: PUSH
78009: EMPTY
78010: LIST
78011: LIST
78012: PUSH
78013: LD_INT 0
78015: PUSH
78016: LD_INT 2
78018: PUSH
78019: EMPTY
78020: LIST
78021: LIST
78022: PUSH
78023: LD_INT 1
78025: NEG
78026: PUSH
78027: LD_INT 1
78029: PUSH
78030: EMPTY
78031: LIST
78032: LIST
78033: PUSH
78034: LD_INT 2
78036: NEG
78037: PUSH
78038: LD_INT 0
78040: PUSH
78041: EMPTY
78042: LIST
78043: LIST
78044: PUSH
78045: LD_INT 2
78047: NEG
78048: PUSH
78049: LD_INT 1
78051: NEG
78052: PUSH
78053: EMPTY
78054: LIST
78055: LIST
78056: PUSH
78057: LD_INT 2
78059: NEG
78060: PUSH
78061: LD_INT 2
78063: NEG
78064: PUSH
78065: EMPTY
78066: LIST
78067: LIST
78068: PUSH
78069: LD_INT 3
78071: PUSH
78072: LD_INT 1
78074: PUSH
78075: EMPTY
78076: LIST
78077: LIST
78078: PUSH
78079: LD_INT 3
78081: PUSH
78082: LD_INT 2
78084: PUSH
78085: EMPTY
78086: LIST
78087: LIST
78088: PUSH
78089: LD_INT 2
78091: PUSH
78092: LD_INT 3
78094: PUSH
78095: EMPTY
78096: LIST
78097: LIST
78098: PUSH
78099: LD_INT 1
78101: PUSH
78102: LD_INT 3
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PUSH
78109: EMPTY
78110: LIST
78111: LIST
78112: LIST
78113: LIST
78114: LIST
78115: LIST
78116: LIST
78117: LIST
78118: LIST
78119: LIST
78120: LIST
78121: LIST
78122: LIST
78123: LIST
78124: LIST
78125: LIST
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
78134: LD_ADDR_VAR 0 26
78138: PUSH
78139: LD_INT 0
78141: PUSH
78142: LD_INT 0
78144: PUSH
78145: EMPTY
78146: LIST
78147: LIST
78148: PUSH
78149: LD_INT 0
78151: PUSH
78152: LD_INT 1
78154: NEG
78155: PUSH
78156: EMPTY
78157: LIST
78158: LIST
78159: PUSH
78160: LD_INT 1
78162: PUSH
78163: LD_INT 0
78165: PUSH
78166: EMPTY
78167: LIST
78168: LIST
78169: PUSH
78170: LD_INT 1
78172: PUSH
78173: LD_INT 1
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 0
78182: PUSH
78183: LD_INT 1
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 1
78192: NEG
78193: PUSH
78194: LD_INT 0
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 1
78203: NEG
78204: PUSH
78205: LD_INT 1
78207: NEG
78208: PUSH
78209: EMPTY
78210: LIST
78211: LIST
78212: PUSH
78213: LD_INT 1
78215: NEG
78216: PUSH
78217: LD_INT 2
78219: NEG
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 0
78227: PUSH
78228: LD_INT 2
78230: NEG
78231: PUSH
78232: EMPTY
78233: LIST
78234: LIST
78235: PUSH
78236: LD_INT 1
78238: PUSH
78239: LD_INT 1
78241: NEG
78242: PUSH
78243: EMPTY
78244: LIST
78245: LIST
78246: PUSH
78247: LD_INT 2
78249: PUSH
78250: LD_INT 0
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 2
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: LD_INT 2
78269: PUSH
78270: LD_INT 2
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: LD_INT 1
78279: PUSH
78280: LD_INT 2
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: LD_INT 0
78289: PUSH
78290: LD_INT 2
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PUSH
78297: LD_INT 1
78299: NEG
78300: PUSH
78301: LD_INT 1
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 2
78310: NEG
78311: PUSH
78312: LD_INT 0
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 2
78321: NEG
78322: PUSH
78323: LD_INT 1
78325: NEG
78326: PUSH
78327: EMPTY
78328: LIST
78329: LIST
78330: PUSH
78331: LD_INT 2
78333: NEG
78334: PUSH
78335: LD_INT 2
78337: NEG
78338: PUSH
78339: EMPTY
78340: LIST
78341: LIST
78342: PUSH
78343: LD_INT 2
78345: PUSH
78346: LD_INT 3
78348: PUSH
78349: EMPTY
78350: LIST
78351: LIST
78352: PUSH
78353: LD_INT 1
78355: PUSH
78356: LD_INT 3
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 1
78365: NEG
78366: PUSH
78367: LD_INT 2
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: EMPTY
78386: LIST
78387: LIST
78388: LIST
78389: LIST
78390: LIST
78391: LIST
78392: LIST
78393: LIST
78394: LIST
78395: LIST
78396: LIST
78397: LIST
78398: LIST
78399: LIST
78400: LIST
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78410: LD_ADDR_VAR 0 27
78414: PUSH
78415: LD_INT 0
78417: PUSH
78418: LD_INT 0
78420: PUSH
78421: EMPTY
78422: LIST
78423: LIST
78424: PUSH
78425: LD_INT 0
78427: PUSH
78428: LD_INT 1
78430: NEG
78431: PUSH
78432: EMPTY
78433: LIST
78434: LIST
78435: PUSH
78436: LD_INT 1
78438: PUSH
78439: LD_INT 0
78441: PUSH
78442: EMPTY
78443: LIST
78444: LIST
78445: PUSH
78446: LD_INT 1
78448: PUSH
78449: LD_INT 1
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: PUSH
78456: LD_INT 0
78458: PUSH
78459: LD_INT 1
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: LD_INT 0
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 1
78479: NEG
78480: PUSH
78481: LD_INT 1
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 1
78491: NEG
78492: PUSH
78493: LD_INT 2
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 0
78503: PUSH
78504: LD_INT 2
78506: NEG
78507: PUSH
78508: EMPTY
78509: LIST
78510: LIST
78511: PUSH
78512: LD_INT 1
78514: PUSH
78515: LD_INT 1
78517: NEG
78518: PUSH
78519: EMPTY
78520: LIST
78521: LIST
78522: PUSH
78523: LD_INT 2
78525: PUSH
78526: LD_INT 0
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: LD_INT 2
78535: PUSH
78536: LD_INT 1
78538: PUSH
78539: EMPTY
78540: LIST
78541: LIST
78542: PUSH
78543: LD_INT 2
78545: PUSH
78546: LD_INT 2
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: PUSH
78553: LD_INT 1
78555: PUSH
78556: LD_INT 2
78558: PUSH
78559: EMPTY
78560: LIST
78561: LIST
78562: PUSH
78563: LD_INT 0
78565: PUSH
78566: LD_INT 2
78568: PUSH
78569: EMPTY
78570: LIST
78571: LIST
78572: PUSH
78573: LD_INT 1
78575: NEG
78576: PUSH
78577: LD_INT 1
78579: PUSH
78580: EMPTY
78581: LIST
78582: LIST
78583: PUSH
78584: LD_INT 2
78586: NEG
78587: PUSH
78588: LD_INT 0
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 2
78597: NEG
78598: PUSH
78599: LD_INT 1
78601: NEG
78602: PUSH
78603: EMPTY
78604: LIST
78605: LIST
78606: PUSH
78607: LD_INT 2
78609: NEG
78610: PUSH
78611: LD_INT 2
78613: NEG
78614: PUSH
78615: EMPTY
78616: LIST
78617: LIST
78618: PUSH
78619: LD_INT 1
78621: NEG
78622: PUSH
78623: LD_INT 2
78625: PUSH
78626: EMPTY
78627: LIST
78628: LIST
78629: PUSH
78630: LD_INT 2
78632: NEG
78633: PUSH
78634: LD_INT 1
78636: PUSH
78637: EMPTY
78638: LIST
78639: LIST
78640: PUSH
78641: LD_INT 3
78643: NEG
78644: PUSH
78645: LD_INT 1
78647: NEG
78648: PUSH
78649: EMPTY
78650: LIST
78651: LIST
78652: PUSH
78653: LD_INT 3
78655: NEG
78656: PUSH
78657: LD_INT 2
78659: NEG
78660: PUSH
78661: EMPTY
78662: LIST
78663: LIST
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: LIST
78669: LIST
78670: LIST
78671: LIST
78672: LIST
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: LIST
78689: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
78690: LD_ADDR_VAR 0 28
78694: PUSH
78695: LD_INT 0
78697: PUSH
78698: LD_INT 0
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 0
78707: PUSH
78708: LD_INT 1
78710: NEG
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 1
78718: PUSH
78719: LD_INT 0
78721: PUSH
78722: EMPTY
78723: LIST
78724: LIST
78725: PUSH
78726: LD_INT 1
78728: PUSH
78729: LD_INT 1
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 0
78738: PUSH
78739: LD_INT 1
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 1
78748: NEG
78749: PUSH
78750: LD_INT 0
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: PUSH
78757: LD_INT 1
78759: NEG
78760: PUSH
78761: LD_INT 1
78763: NEG
78764: PUSH
78765: EMPTY
78766: LIST
78767: LIST
78768: PUSH
78769: LD_INT 1
78771: NEG
78772: PUSH
78773: LD_INT 2
78775: NEG
78776: PUSH
78777: EMPTY
78778: LIST
78779: LIST
78780: PUSH
78781: LD_INT 0
78783: PUSH
78784: LD_INT 2
78786: NEG
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 1
78794: PUSH
78795: LD_INT 1
78797: NEG
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 2
78805: PUSH
78806: LD_INT 0
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PUSH
78813: LD_INT 2
78815: PUSH
78816: LD_INT 1
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 2
78825: PUSH
78826: LD_INT 2
78828: PUSH
78829: EMPTY
78830: LIST
78831: LIST
78832: PUSH
78833: LD_INT 1
78835: PUSH
78836: LD_INT 2
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: LD_INT 2
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: LD_INT 1
78855: NEG
78856: PUSH
78857: LD_INT 1
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 2
78866: NEG
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 2
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 2
78889: NEG
78890: PUSH
78891: LD_INT 2
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 2
78901: NEG
78902: PUSH
78903: LD_INT 3
78905: NEG
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 1
78913: NEG
78914: PUSH
78915: LD_INT 3
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 3
78925: NEG
78926: PUSH
78927: LD_INT 1
78929: NEG
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 3
78937: NEG
78938: PUSH
78939: LD_INT 2
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: LIST
78951: LIST
78952: LIST
78953: LIST
78954: LIST
78955: LIST
78956: LIST
78957: LIST
78958: LIST
78959: LIST
78960: LIST
78961: LIST
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: LIST
78971: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
78972: LD_ADDR_VAR 0 29
78976: PUSH
78977: LD_INT 0
78979: PUSH
78980: LD_INT 0
78982: PUSH
78983: EMPTY
78984: LIST
78985: LIST
78986: PUSH
78987: LD_INT 0
78989: PUSH
78990: LD_INT 1
78992: NEG
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 1
79000: PUSH
79001: LD_INT 0
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: LD_INT 1
79010: PUSH
79011: LD_INT 1
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 0
79020: PUSH
79021: LD_INT 1
79023: PUSH
79024: EMPTY
79025: LIST
79026: LIST
79027: PUSH
79028: LD_INT 1
79030: NEG
79031: PUSH
79032: LD_INT 0
79034: PUSH
79035: EMPTY
79036: LIST
79037: LIST
79038: PUSH
79039: LD_INT 1
79041: NEG
79042: PUSH
79043: LD_INT 1
79045: NEG
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 1
79053: NEG
79054: PUSH
79055: LD_INT 2
79057: NEG
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 0
79065: PUSH
79066: LD_INT 2
79068: NEG
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 1
79076: PUSH
79077: LD_INT 1
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 2
79087: PUSH
79088: LD_INT 0
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 2
79097: PUSH
79098: LD_INT 1
79100: PUSH
79101: EMPTY
79102: LIST
79103: LIST
79104: PUSH
79105: LD_INT 1
79107: PUSH
79108: LD_INT 2
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PUSH
79115: LD_INT 0
79117: PUSH
79118: LD_INT 2
79120: PUSH
79121: EMPTY
79122: LIST
79123: LIST
79124: PUSH
79125: LD_INT 1
79127: NEG
79128: PUSH
79129: LD_INT 1
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 2
79138: NEG
79139: PUSH
79140: LD_INT 1
79142: NEG
79143: PUSH
79144: EMPTY
79145: LIST
79146: LIST
79147: PUSH
79148: LD_INT 2
79150: NEG
79151: PUSH
79152: LD_INT 2
79154: NEG
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 2
79162: NEG
79163: PUSH
79164: LD_INT 3
79166: NEG
79167: PUSH
79168: EMPTY
79169: LIST
79170: LIST
79171: PUSH
79172: LD_INT 2
79174: PUSH
79175: LD_INT 1
79177: NEG
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 3
79185: PUSH
79186: LD_INT 1
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: LD_INT 1
79195: PUSH
79196: LD_INT 3
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 1
79205: NEG
79206: PUSH
79207: LD_INT 2
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: PUSH
79214: LD_INT 3
79216: NEG
79217: PUSH
79218: LD_INT 2
79220: NEG
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79251: LD_ADDR_VAR 0 30
79255: PUSH
79256: LD_INT 0
79258: PUSH
79259: LD_INT 0
79261: PUSH
79262: EMPTY
79263: LIST
79264: LIST
79265: PUSH
79266: LD_INT 0
79268: PUSH
79269: LD_INT 1
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 1
79279: PUSH
79280: LD_INT 0
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PUSH
79287: LD_INT 1
79289: PUSH
79290: LD_INT 1
79292: PUSH
79293: EMPTY
79294: LIST
79295: LIST
79296: PUSH
79297: LD_INT 0
79299: PUSH
79300: LD_INT 1
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: PUSH
79307: LD_INT 1
79309: NEG
79310: PUSH
79311: LD_INT 0
79313: PUSH
79314: EMPTY
79315: LIST
79316: LIST
79317: PUSH
79318: LD_INT 1
79320: NEG
79321: PUSH
79322: LD_INT 1
79324: NEG
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: PUSH
79330: LD_INT 1
79332: NEG
79333: PUSH
79334: LD_INT 2
79336: NEG
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: PUSH
79342: LD_INT 0
79344: PUSH
79345: LD_INT 2
79347: NEG
79348: PUSH
79349: EMPTY
79350: LIST
79351: LIST
79352: PUSH
79353: LD_INT 1
79355: PUSH
79356: LD_INT 1
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 2
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 2
79376: PUSH
79377: LD_INT 1
79379: PUSH
79380: EMPTY
79381: LIST
79382: LIST
79383: PUSH
79384: LD_INT 2
79386: PUSH
79387: LD_INT 2
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 1
79396: PUSH
79397: LD_INT 2
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 1
79406: NEG
79407: PUSH
79408: LD_INT 1
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 2
79417: NEG
79418: PUSH
79419: LD_INT 0
79421: PUSH
79422: EMPTY
79423: LIST
79424: LIST
79425: PUSH
79426: LD_INT 2
79428: NEG
79429: PUSH
79430: LD_INT 1
79432: NEG
79433: PUSH
79434: EMPTY
79435: LIST
79436: LIST
79437: PUSH
79438: LD_INT 1
79440: NEG
79441: PUSH
79442: LD_INT 3
79444: NEG
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 1
79452: PUSH
79453: LD_INT 2
79455: NEG
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PUSH
79461: LD_INT 3
79463: PUSH
79464: LD_INT 2
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 2
79473: PUSH
79474: LD_INT 3
79476: PUSH
79477: EMPTY
79478: LIST
79479: LIST
79480: PUSH
79481: LD_INT 2
79483: NEG
79484: PUSH
79485: LD_INT 1
79487: PUSH
79488: EMPTY
79489: LIST
79490: LIST
79491: PUSH
79492: LD_INT 3
79494: NEG
79495: PUSH
79496: LD_INT 1
79498: NEG
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: LIST
79508: LIST
79509: LIST
79510: LIST
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
79529: LD_ADDR_VAR 0 31
79533: PUSH
79534: LD_INT 0
79536: PUSH
79537: LD_INT 0
79539: PUSH
79540: EMPTY
79541: LIST
79542: LIST
79543: PUSH
79544: LD_INT 0
79546: PUSH
79547: LD_INT 1
79549: NEG
79550: PUSH
79551: EMPTY
79552: LIST
79553: LIST
79554: PUSH
79555: LD_INT 1
79557: PUSH
79558: LD_INT 0
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 1
79567: PUSH
79568: LD_INT 1
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 0
79577: PUSH
79578: LD_INT 1
79580: PUSH
79581: EMPTY
79582: LIST
79583: LIST
79584: PUSH
79585: LD_INT 1
79587: NEG
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 1
79598: NEG
79599: PUSH
79600: LD_INT 1
79602: NEG
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 1
79610: NEG
79611: PUSH
79612: LD_INT 2
79614: NEG
79615: PUSH
79616: EMPTY
79617: LIST
79618: LIST
79619: PUSH
79620: LD_INT 1
79622: PUSH
79623: LD_INT 1
79625: NEG
79626: PUSH
79627: EMPTY
79628: LIST
79629: LIST
79630: PUSH
79631: LD_INT 2
79633: PUSH
79634: LD_INT 0
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: PUSH
79641: LD_INT 2
79643: PUSH
79644: LD_INT 1
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 2
79653: PUSH
79654: LD_INT 2
79656: PUSH
79657: EMPTY
79658: LIST
79659: LIST
79660: PUSH
79661: LD_INT 1
79663: PUSH
79664: LD_INT 2
79666: PUSH
79667: EMPTY
79668: LIST
79669: LIST
79670: PUSH
79671: LD_INT 0
79673: PUSH
79674: LD_INT 2
79676: PUSH
79677: EMPTY
79678: LIST
79679: LIST
79680: PUSH
79681: LD_INT 1
79683: NEG
79684: PUSH
79685: LD_INT 1
79687: PUSH
79688: EMPTY
79689: LIST
79690: LIST
79691: PUSH
79692: LD_INT 2
79694: NEG
79695: PUSH
79696: LD_INT 1
79698: NEG
79699: PUSH
79700: EMPTY
79701: LIST
79702: LIST
79703: PUSH
79704: LD_INT 2
79706: NEG
79707: PUSH
79708: LD_INT 2
79710: NEG
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: LD_INT 2
79718: NEG
79719: PUSH
79720: LD_INT 3
79722: NEG
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 2
79730: PUSH
79731: LD_INT 1
79733: NEG
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 3
79741: PUSH
79742: LD_INT 1
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 1
79751: PUSH
79752: LD_INT 3
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 1
79761: NEG
79762: PUSH
79763: LD_INT 2
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 3
79772: NEG
79773: PUSH
79774: LD_INT 2
79776: NEG
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PUSH
79782: EMPTY
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: LIST
79789: LIST
79790: LIST
79791: LIST
79792: LIST
79793: LIST
79794: LIST
79795: LIST
79796: LIST
79797: LIST
79798: LIST
79799: LIST
79800: LIST
79801: LIST
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
79807: LD_ADDR_VAR 0 32
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: LD_INT 0
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: LD_INT 0
79824: PUSH
79825: LD_INT 1
79827: NEG
79828: PUSH
79829: EMPTY
79830: LIST
79831: LIST
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: LD_INT 0
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: LD_INT 1
79845: PUSH
79846: LD_INT 1
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PUSH
79853: LD_INT 0
79855: PUSH
79856: LD_INT 1
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 1
79865: NEG
79866: PUSH
79867: LD_INT 0
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 1
79876: NEG
79877: PUSH
79878: LD_INT 1
79880: NEG
79881: PUSH
79882: EMPTY
79883: LIST
79884: LIST
79885: PUSH
79886: LD_INT 1
79888: NEG
79889: PUSH
79890: LD_INT 2
79892: NEG
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PUSH
79898: LD_INT 0
79900: PUSH
79901: LD_INT 2
79903: NEG
79904: PUSH
79905: EMPTY
79906: LIST
79907: LIST
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: LD_INT 1
79914: NEG
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 2
79922: PUSH
79923: LD_INT 1
79925: PUSH
79926: EMPTY
79927: LIST
79928: LIST
79929: PUSH
79930: LD_INT 2
79932: PUSH
79933: LD_INT 2
79935: PUSH
79936: EMPTY
79937: LIST
79938: LIST
79939: PUSH
79940: LD_INT 1
79942: PUSH
79943: LD_INT 2
79945: PUSH
79946: EMPTY
79947: LIST
79948: LIST
79949: PUSH
79950: LD_INT 0
79952: PUSH
79953: LD_INT 2
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 1
79962: NEG
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: LD_INT 2
79973: NEG
79974: PUSH
79975: LD_INT 0
79977: PUSH
79978: EMPTY
79979: LIST
79980: LIST
79981: PUSH
79982: LD_INT 2
79984: NEG
79985: PUSH
79986: LD_INT 1
79988: NEG
79989: PUSH
79990: EMPTY
79991: LIST
79992: LIST
79993: PUSH
79994: LD_INT 1
79996: NEG
79997: PUSH
79998: LD_INT 3
80000: NEG
80001: PUSH
80002: EMPTY
80003: LIST
80004: LIST
80005: PUSH
80006: LD_INT 1
80008: PUSH
80009: LD_INT 2
80011: NEG
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 3
80019: PUSH
80020: LD_INT 2
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 2
80029: PUSH
80030: LD_INT 3
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: LD_INT 2
80039: NEG
80040: PUSH
80041: LD_INT 1
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 3
80050: NEG
80051: PUSH
80052: LD_INT 1
80054: NEG
80055: PUSH
80056: EMPTY
80057: LIST
80058: LIST
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
80085: LD_ADDR_VAR 0 33
80089: PUSH
80090: LD_INT 0
80092: PUSH
80093: LD_INT 0
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: PUSH
80100: LD_INT 0
80102: PUSH
80103: LD_INT 1
80105: NEG
80106: PUSH
80107: EMPTY
80108: LIST
80109: LIST
80110: PUSH
80111: LD_INT 1
80113: PUSH
80114: LD_INT 0
80116: PUSH
80117: EMPTY
80118: LIST
80119: LIST
80120: PUSH
80121: LD_INT 1
80123: PUSH
80124: LD_INT 1
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 0
80133: PUSH
80134: LD_INT 1
80136: PUSH
80137: EMPTY
80138: LIST
80139: LIST
80140: PUSH
80141: LD_INT 1
80143: NEG
80144: PUSH
80145: LD_INT 0
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: PUSH
80152: LD_INT 1
80154: NEG
80155: PUSH
80156: LD_INT 1
80158: NEG
80159: PUSH
80160: EMPTY
80161: LIST
80162: LIST
80163: PUSH
80164: LD_INT 1
80166: NEG
80167: PUSH
80168: LD_INT 2
80170: NEG
80171: PUSH
80172: EMPTY
80173: LIST
80174: LIST
80175: PUSH
80176: LD_INT 1
80178: PUSH
80179: LD_INT 1
80181: NEG
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: LD_INT 2
80189: PUSH
80190: LD_INT 0
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PUSH
80197: LD_INT 2
80199: PUSH
80200: LD_INT 1
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 1
80209: PUSH
80210: LD_INT 2
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 0
80219: PUSH
80220: LD_INT 2
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 1
80229: NEG
80230: PUSH
80231: LD_INT 1
80233: PUSH
80234: EMPTY
80235: LIST
80236: LIST
80237: PUSH
80238: LD_INT 2
80240: NEG
80241: PUSH
80242: LD_INT 0
80244: PUSH
80245: EMPTY
80246: LIST
80247: LIST
80248: PUSH
80249: LD_INT 2
80251: NEG
80252: PUSH
80253: LD_INT 1
80255: NEG
80256: PUSH
80257: EMPTY
80258: LIST
80259: LIST
80260: PUSH
80261: LD_INT 2
80263: NEG
80264: PUSH
80265: LD_INT 2
80267: NEG
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 2
80275: NEG
80276: PUSH
80277: LD_INT 3
80279: NEG
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 2
80287: PUSH
80288: LD_INT 1
80290: NEG
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PUSH
80296: LD_INT 3
80298: PUSH
80299: LD_INT 1
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 1
80308: PUSH
80309: LD_INT 3
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 1
80318: NEG
80319: PUSH
80320: LD_INT 2
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 3
80329: NEG
80330: PUSH
80331: LD_INT 2
80333: NEG
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: LIST
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
80364: LD_ADDR_VAR 0 34
80368: PUSH
80369: LD_INT 0
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: EMPTY
80376: LIST
80377: LIST
80378: PUSH
80379: LD_INT 0
80381: PUSH
80382: LD_INT 1
80384: NEG
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 1
80392: PUSH
80393: LD_INT 0
80395: PUSH
80396: EMPTY
80397: LIST
80398: LIST
80399: PUSH
80400: LD_INT 1
80402: PUSH
80403: LD_INT 1
80405: PUSH
80406: EMPTY
80407: LIST
80408: LIST
80409: PUSH
80410: LD_INT 0
80412: PUSH
80413: LD_INT 1
80415: PUSH
80416: EMPTY
80417: LIST
80418: LIST
80419: PUSH
80420: LD_INT 1
80422: NEG
80423: PUSH
80424: LD_INT 0
80426: PUSH
80427: EMPTY
80428: LIST
80429: LIST
80430: PUSH
80431: LD_INT 1
80433: NEG
80434: PUSH
80435: LD_INT 1
80437: NEG
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 1
80445: NEG
80446: PUSH
80447: LD_INT 2
80449: NEG
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 0
80457: PUSH
80458: LD_INT 2
80460: NEG
80461: PUSH
80462: EMPTY
80463: LIST
80464: LIST
80465: PUSH
80466: LD_INT 1
80468: PUSH
80469: LD_INT 1
80471: NEG
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 2
80479: PUSH
80480: LD_INT 1
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 2
80489: PUSH
80490: LD_INT 2
80492: PUSH
80493: EMPTY
80494: LIST
80495: LIST
80496: PUSH
80497: LD_INT 1
80499: PUSH
80500: LD_INT 2
80502: PUSH
80503: EMPTY
80504: LIST
80505: LIST
80506: PUSH
80507: LD_INT 1
80509: NEG
80510: PUSH
80511: LD_INT 1
80513: PUSH
80514: EMPTY
80515: LIST
80516: LIST
80517: PUSH
80518: LD_INT 2
80520: NEG
80521: PUSH
80522: LD_INT 0
80524: PUSH
80525: EMPTY
80526: LIST
80527: LIST
80528: PUSH
80529: LD_INT 2
80531: NEG
80532: PUSH
80533: LD_INT 1
80535: NEG
80536: PUSH
80537: EMPTY
80538: LIST
80539: LIST
80540: PUSH
80541: LD_INT 2
80543: NEG
80544: PUSH
80545: LD_INT 2
80547: NEG
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: NEG
80556: PUSH
80557: LD_INT 3
80559: NEG
80560: PUSH
80561: EMPTY
80562: LIST
80563: LIST
80564: PUSH
80565: LD_INT 1
80567: PUSH
80568: LD_INT 2
80570: NEG
80571: PUSH
80572: EMPTY
80573: LIST
80574: LIST
80575: PUSH
80576: LD_INT 3
80578: PUSH
80579: LD_INT 2
80581: PUSH
80582: EMPTY
80583: LIST
80584: LIST
80585: PUSH
80586: LD_INT 2
80588: PUSH
80589: LD_INT 3
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: LD_INT 2
80598: NEG
80599: PUSH
80600: LD_INT 1
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 3
80609: NEG
80610: PUSH
80611: LD_INT 1
80613: NEG
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: LIST
80643: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80644: LD_ADDR_VAR 0 35
80648: PUSH
80649: LD_INT 0
80651: PUSH
80652: LD_INT 0
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: LD_INT 1
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: LD_INT 0
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: LD_INT 1
80682: PUSH
80683: LD_INT 1
80685: PUSH
80686: EMPTY
80687: LIST
80688: LIST
80689: PUSH
80690: LD_INT 0
80692: PUSH
80693: LD_INT 1
80695: PUSH
80696: EMPTY
80697: LIST
80698: LIST
80699: PUSH
80700: LD_INT 1
80702: NEG
80703: PUSH
80704: LD_INT 0
80706: PUSH
80707: EMPTY
80708: LIST
80709: LIST
80710: PUSH
80711: LD_INT 1
80713: NEG
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: LD_INT 2
80725: PUSH
80726: LD_INT 1
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 2
80735: NEG
80736: PUSH
80737: LD_INT 1
80739: NEG
80740: PUSH
80741: EMPTY
80742: LIST
80743: LIST
80744: PUSH
80745: EMPTY
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: LIST
80752: LIST
80753: LIST
80754: LIST
80755: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
80756: LD_ADDR_VAR 0 36
80760: PUSH
80761: LD_INT 0
80763: PUSH
80764: LD_INT 0
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 0
80773: PUSH
80774: LD_INT 1
80776: NEG
80777: PUSH
80778: EMPTY
80779: LIST
80780: LIST
80781: PUSH
80782: LD_INT 1
80784: PUSH
80785: LD_INT 0
80787: PUSH
80788: EMPTY
80789: LIST
80790: LIST
80791: PUSH
80792: LD_INT 1
80794: PUSH
80795: LD_INT 1
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 0
80804: PUSH
80805: LD_INT 1
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 1
80814: NEG
80815: PUSH
80816: LD_INT 0
80818: PUSH
80819: EMPTY
80820: LIST
80821: LIST
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: EMPTY
80832: LIST
80833: LIST
80834: PUSH
80835: LD_INT 1
80837: NEG
80838: PUSH
80839: LD_INT 2
80841: NEG
80842: PUSH
80843: EMPTY
80844: LIST
80845: LIST
80846: PUSH
80847: LD_INT 1
80849: PUSH
80850: LD_INT 2
80852: PUSH
80853: EMPTY
80854: LIST
80855: LIST
80856: PUSH
80857: EMPTY
80858: LIST
80859: LIST
80860: LIST
80861: LIST
80862: LIST
80863: LIST
80864: LIST
80865: LIST
80866: LIST
80867: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
80868: LD_ADDR_VAR 0 37
80872: PUSH
80873: LD_INT 0
80875: PUSH
80876: LD_INT 0
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 0
80885: PUSH
80886: LD_INT 1
80888: NEG
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: PUSH
80894: LD_INT 1
80896: PUSH
80897: LD_INT 0
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 1
80906: PUSH
80907: LD_INT 1
80909: PUSH
80910: EMPTY
80911: LIST
80912: LIST
80913: PUSH
80914: LD_INT 0
80916: PUSH
80917: LD_INT 1
80919: PUSH
80920: EMPTY
80921: LIST
80922: LIST
80923: PUSH
80924: LD_INT 1
80926: NEG
80927: PUSH
80928: LD_INT 0
80930: PUSH
80931: EMPTY
80932: LIST
80933: LIST
80934: PUSH
80935: LD_INT 1
80937: NEG
80938: PUSH
80939: LD_INT 1
80941: NEG
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 1
80949: PUSH
80950: LD_INT 1
80952: NEG
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 1
80960: NEG
80961: PUSH
80962: LD_INT 1
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: LIST
80973: LIST
80974: LIST
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
80980: LD_ADDR_VAR 0 38
80984: PUSH
80985: LD_INT 0
80987: PUSH
80988: LD_INT 0
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 0
80997: PUSH
80998: LD_INT 1
81000: NEG
81001: PUSH
81002: EMPTY
81003: LIST
81004: LIST
81005: PUSH
81006: LD_INT 1
81008: PUSH
81009: LD_INT 0
81011: PUSH
81012: EMPTY
81013: LIST
81014: LIST
81015: PUSH
81016: LD_INT 1
81018: PUSH
81019: LD_INT 1
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 0
81028: PUSH
81029: LD_INT 1
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 1
81038: NEG
81039: PUSH
81040: LD_INT 0
81042: PUSH
81043: EMPTY
81044: LIST
81045: LIST
81046: PUSH
81047: LD_INT 1
81049: NEG
81050: PUSH
81051: LD_INT 1
81053: NEG
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 2
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 2
81071: NEG
81072: PUSH
81073: LD_INT 1
81075: NEG
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: PUSH
81081: EMPTY
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
81092: LD_ADDR_VAR 0 39
81096: PUSH
81097: LD_INT 0
81099: PUSH
81100: LD_INT 0
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 0
81109: PUSH
81110: LD_INT 1
81112: NEG
81113: PUSH
81114: EMPTY
81115: LIST
81116: LIST
81117: PUSH
81118: LD_INT 1
81120: PUSH
81121: LD_INT 0
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: LD_INT 1
81130: PUSH
81131: LD_INT 1
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 0
81140: PUSH
81141: LD_INT 1
81143: PUSH
81144: EMPTY
81145: LIST
81146: LIST
81147: PUSH
81148: LD_INT 1
81150: NEG
81151: PUSH
81152: LD_INT 0
81154: PUSH
81155: EMPTY
81156: LIST
81157: LIST
81158: PUSH
81159: LD_INT 1
81161: NEG
81162: PUSH
81163: LD_INT 1
81165: NEG
81166: PUSH
81167: EMPTY
81168: LIST
81169: LIST
81170: PUSH
81171: LD_INT 1
81173: NEG
81174: PUSH
81175: LD_INT 2
81177: NEG
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PUSH
81183: LD_INT 1
81185: PUSH
81186: LD_INT 2
81188: PUSH
81189: EMPTY
81190: LIST
81191: LIST
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: LIST
81197: LIST
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
81204: LD_ADDR_VAR 0 40
81208: PUSH
81209: LD_INT 0
81211: PUSH
81212: LD_INT 0
81214: PUSH
81215: EMPTY
81216: LIST
81217: LIST
81218: PUSH
81219: LD_INT 0
81221: PUSH
81222: LD_INT 1
81224: NEG
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 1
81232: PUSH
81233: LD_INT 0
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 1
81242: PUSH
81243: LD_INT 1
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 0
81252: PUSH
81253: LD_INT 1
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 1
81262: NEG
81263: PUSH
81264: LD_INT 0
81266: PUSH
81267: EMPTY
81268: LIST
81269: LIST
81270: PUSH
81271: LD_INT 1
81273: NEG
81274: PUSH
81275: LD_INT 1
81277: NEG
81278: PUSH
81279: EMPTY
81280: LIST
81281: LIST
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: LD_INT 1
81288: NEG
81289: PUSH
81290: EMPTY
81291: LIST
81292: LIST
81293: PUSH
81294: LD_INT 1
81296: NEG
81297: PUSH
81298: LD_INT 1
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: EMPTY
81306: LIST
81307: LIST
81308: LIST
81309: LIST
81310: LIST
81311: LIST
81312: LIST
81313: LIST
81314: LIST
81315: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81316: LD_ADDR_VAR 0 41
81320: PUSH
81321: LD_INT 0
81323: PUSH
81324: LD_INT 0
81326: PUSH
81327: EMPTY
81328: LIST
81329: LIST
81330: PUSH
81331: LD_INT 0
81333: PUSH
81334: LD_INT 1
81336: NEG
81337: PUSH
81338: EMPTY
81339: LIST
81340: LIST
81341: PUSH
81342: LD_INT 1
81344: PUSH
81345: LD_INT 0
81347: PUSH
81348: EMPTY
81349: LIST
81350: LIST
81351: PUSH
81352: LD_INT 1
81354: PUSH
81355: LD_INT 1
81357: PUSH
81358: EMPTY
81359: LIST
81360: LIST
81361: PUSH
81362: LD_INT 0
81364: PUSH
81365: LD_INT 1
81367: PUSH
81368: EMPTY
81369: LIST
81370: LIST
81371: PUSH
81372: LD_INT 1
81374: NEG
81375: PUSH
81376: LD_INT 0
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: LD_INT 1
81385: NEG
81386: PUSH
81387: LD_INT 1
81389: NEG
81390: PUSH
81391: EMPTY
81392: LIST
81393: LIST
81394: PUSH
81395: LD_INT 1
81397: NEG
81398: PUSH
81399: LD_INT 2
81401: NEG
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: PUSH
81410: LD_INT 1
81412: NEG
81413: PUSH
81414: EMPTY
81415: LIST
81416: LIST
81417: PUSH
81418: LD_INT 2
81420: PUSH
81421: LD_INT 0
81423: PUSH
81424: EMPTY
81425: LIST
81426: LIST
81427: PUSH
81428: LD_INT 2
81430: PUSH
81431: LD_INT 1
81433: PUSH
81434: EMPTY
81435: LIST
81436: LIST
81437: PUSH
81438: LD_INT 2
81440: PUSH
81441: LD_INT 2
81443: PUSH
81444: EMPTY
81445: LIST
81446: LIST
81447: PUSH
81448: LD_INT 1
81450: PUSH
81451: LD_INT 2
81453: PUSH
81454: EMPTY
81455: LIST
81456: LIST
81457: PUSH
81458: LD_INT 1
81460: NEG
81461: PUSH
81462: LD_INT 1
81464: PUSH
81465: EMPTY
81466: LIST
81467: LIST
81468: PUSH
81469: LD_INT 2
81471: NEG
81472: PUSH
81473: LD_INT 0
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 2
81482: NEG
81483: PUSH
81484: LD_INT 1
81486: NEG
81487: PUSH
81488: EMPTY
81489: LIST
81490: LIST
81491: PUSH
81492: LD_INT 2
81494: NEG
81495: PUSH
81496: LD_INT 2
81498: NEG
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PUSH
81504: LD_INT 2
81506: NEG
81507: PUSH
81508: LD_INT 3
81510: NEG
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: PUSH
81516: LD_INT 2
81518: PUSH
81519: LD_INT 1
81521: NEG
81522: PUSH
81523: EMPTY
81524: LIST
81525: LIST
81526: PUSH
81527: LD_INT 3
81529: PUSH
81530: LD_INT 0
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 3
81539: PUSH
81540: LD_INT 1
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 3
81549: PUSH
81550: LD_INT 2
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 3
81559: PUSH
81560: LD_INT 3
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 2
81569: PUSH
81570: LD_INT 3
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 2
81579: NEG
81580: PUSH
81581: LD_INT 1
81583: PUSH
81584: EMPTY
81585: LIST
81586: LIST
81587: PUSH
81588: LD_INT 3
81590: NEG
81591: PUSH
81592: LD_INT 0
81594: PUSH
81595: EMPTY
81596: LIST
81597: LIST
81598: PUSH
81599: LD_INT 3
81601: NEG
81602: PUSH
81603: LD_INT 1
81605: NEG
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PUSH
81611: LD_INT 3
81613: NEG
81614: PUSH
81615: LD_INT 2
81617: NEG
81618: PUSH
81619: EMPTY
81620: LIST
81621: LIST
81622: PUSH
81623: LD_INT 3
81625: NEG
81626: PUSH
81627: LD_INT 3
81629: NEG
81630: PUSH
81631: EMPTY
81632: LIST
81633: LIST
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: LIST
81654: LIST
81655: LIST
81656: LIST
81657: LIST
81658: LIST
81659: LIST
81660: LIST
81661: LIST
81662: LIST
81663: LIST
81664: LIST
81665: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81666: LD_ADDR_VAR 0 42
81670: PUSH
81671: LD_INT 0
81673: PUSH
81674: LD_INT 0
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 0
81683: PUSH
81684: LD_INT 1
81686: NEG
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 1
81694: PUSH
81695: LD_INT 0
81697: PUSH
81698: EMPTY
81699: LIST
81700: LIST
81701: PUSH
81702: LD_INT 1
81704: PUSH
81705: LD_INT 1
81707: PUSH
81708: EMPTY
81709: LIST
81710: LIST
81711: PUSH
81712: LD_INT 0
81714: PUSH
81715: LD_INT 1
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: PUSH
81722: LD_INT 1
81724: NEG
81725: PUSH
81726: LD_INT 0
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 1
81735: NEG
81736: PUSH
81737: LD_INT 1
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 1
81747: NEG
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 0
81759: PUSH
81760: LD_INT 2
81762: NEG
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 1
81770: PUSH
81771: LD_INT 1
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 2
81781: PUSH
81782: LD_INT 1
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 2
81791: PUSH
81792: LD_INT 2
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 1
81801: PUSH
81802: LD_INT 2
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: LD_INT 2
81814: PUSH
81815: EMPTY
81816: LIST
81817: LIST
81818: PUSH
81819: LD_INT 1
81821: NEG
81822: PUSH
81823: LD_INT 1
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 2
81832: NEG
81833: PUSH
81834: LD_INT 1
81836: NEG
81837: PUSH
81838: EMPTY
81839: LIST
81840: LIST
81841: PUSH
81842: LD_INT 2
81844: NEG
81845: PUSH
81846: LD_INT 2
81848: NEG
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 2
81856: NEG
81857: PUSH
81858: LD_INT 3
81860: NEG
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: PUSH
81866: LD_INT 1
81868: NEG
81869: PUSH
81870: LD_INT 3
81872: NEG
81873: PUSH
81874: EMPTY
81875: LIST
81876: LIST
81877: PUSH
81878: LD_INT 0
81880: PUSH
81881: LD_INT 3
81883: NEG
81884: PUSH
81885: EMPTY
81886: LIST
81887: LIST
81888: PUSH
81889: LD_INT 1
81891: PUSH
81892: LD_INT 2
81894: NEG
81895: PUSH
81896: EMPTY
81897: LIST
81898: LIST
81899: PUSH
81900: LD_INT 3
81902: PUSH
81903: LD_INT 2
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 3
81912: PUSH
81913: LD_INT 3
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 2
81922: PUSH
81923: LD_INT 3
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 1
81932: PUSH
81933: LD_INT 3
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 0
81942: PUSH
81943: LD_INT 3
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 1
81952: NEG
81953: PUSH
81954: LD_INT 2
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 3
81963: NEG
81964: PUSH
81965: LD_INT 2
81967: NEG
81968: PUSH
81969: EMPTY
81970: LIST
81971: LIST
81972: PUSH
81973: LD_INT 3
81975: NEG
81976: PUSH
81977: LD_INT 3
81979: NEG
81980: PUSH
81981: EMPTY
81982: LIST
81983: LIST
81984: PUSH
81985: EMPTY
81986: LIST
81987: LIST
81988: LIST
81989: LIST
81990: LIST
81991: LIST
81992: LIST
81993: LIST
81994: LIST
81995: LIST
81996: LIST
81997: LIST
81998: LIST
81999: LIST
82000: LIST
82001: LIST
82002: LIST
82003: LIST
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
82016: LD_ADDR_VAR 0 43
82020: PUSH
82021: LD_INT 0
82023: PUSH
82024: LD_INT 0
82026: PUSH
82027: EMPTY
82028: LIST
82029: LIST
82030: PUSH
82031: LD_INT 0
82033: PUSH
82034: LD_INT 1
82036: NEG
82037: PUSH
82038: EMPTY
82039: LIST
82040: LIST
82041: PUSH
82042: LD_INT 1
82044: PUSH
82045: LD_INT 0
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: PUSH
82052: LD_INT 1
82054: PUSH
82055: LD_INT 1
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: LD_INT 1
82067: PUSH
82068: EMPTY
82069: LIST
82070: LIST
82071: PUSH
82072: LD_INT 1
82074: NEG
82075: PUSH
82076: LD_INT 0
82078: PUSH
82079: EMPTY
82080: LIST
82081: LIST
82082: PUSH
82083: LD_INT 1
82085: NEG
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 1
82097: NEG
82098: PUSH
82099: LD_INT 2
82101: NEG
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: LD_INT 0
82109: PUSH
82110: LD_INT 2
82112: NEG
82113: PUSH
82114: EMPTY
82115: LIST
82116: LIST
82117: PUSH
82118: LD_INT 1
82120: PUSH
82121: LD_INT 1
82123: NEG
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 2
82131: PUSH
82132: LD_INT 0
82134: PUSH
82135: EMPTY
82136: LIST
82137: LIST
82138: PUSH
82139: LD_INT 2
82141: PUSH
82142: LD_INT 1
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: PUSH
82149: LD_INT 1
82151: PUSH
82152: LD_INT 2
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: PUSH
82159: LD_INT 0
82161: PUSH
82162: LD_INT 2
82164: PUSH
82165: EMPTY
82166: LIST
82167: LIST
82168: PUSH
82169: LD_INT 1
82171: NEG
82172: PUSH
82173: LD_INT 1
82175: PUSH
82176: EMPTY
82177: LIST
82178: LIST
82179: PUSH
82180: LD_INT 2
82182: NEG
82183: PUSH
82184: LD_INT 0
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: LD_INT 2
82193: NEG
82194: PUSH
82195: LD_INT 1
82197: NEG
82198: PUSH
82199: EMPTY
82200: LIST
82201: LIST
82202: PUSH
82203: LD_INT 1
82205: NEG
82206: PUSH
82207: LD_INT 3
82209: NEG
82210: PUSH
82211: EMPTY
82212: LIST
82213: LIST
82214: PUSH
82215: LD_INT 0
82217: PUSH
82218: LD_INT 3
82220: NEG
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 1
82228: PUSH
82229: LD_INT 2
82231: NEG
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 2
82239: PUSH
82240: LD_INT 1
82242: NEG
82243: PUSH
82244: EMPTY
82245: LIST
82246: LIST
82247: PUSH
82248: LD_INT 3
82250: PUSH
82251: LD_INT 0
82253: PUSH
82254: EMPTY
82255: LIST
82256: LIST
82257: PUSH
82258: LD_INT 3
82260: PUSH
82261: LD_INT 1
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 1
82270: PUSH
82271: LD_INT 3
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: LD_INT 3
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 1
82290: NEG
82291: PUSH
82292: LD_INT 2
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 2
82301: NEG
82302: PUSH
82303: LD_INT 1
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 3
82312: NEG
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 3
82323: NEG
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: LIST
82345: LIST
82346: LIST
82347: LIST
82348: LIST
82349: LIST
82350: LIST
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: LIST
82356: LIST
82357: LIST
82358: LIST
82359: LIST
82360: LIST
82361: LIST
82362: LIST
82363: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82364: LD_ADDR_VAR 0 44
82368: PUSH
82369: LD_INT 0
82371: PUSH
82372: LD_INT 0
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 0
82381: PUSH
82382: LD_INT 1
82384: NEG
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 1
82392: PUSH
82393: LD_INT 0
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 1
82402: PUSH
82403: LD_INT 1
82405: PUSH
82406: EMPTY
82407: LIST
82408: LIST
82409: PUSH
82410: LD_INT 0
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: EMPTY
82417: LIST
82418: LIST
82419: PUSH
82420: LD_INT 1
82422: NEG
82423: PUSH
82424: LD_INT 0
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: PUSH
82431: LD_INT 1
82433: NEG
82434: PUSH
82435: LD_INT 1
82437: NEG
82438: PUSH
82439: EMPTY
82440: LIST
82441: LIST
82442: PUSH
82443: LD_INT 1
82445: NEG
82446: PUSH
82447: LD_INT 2
82449: NEG
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: LD_INT 1
82457: PUSH
82458: LD_INT 1
82460: NEG
82461: PUSH
82462: EMPTY
82463: LIST
82464: LIST
82465: PUSH
82466: LD_INT 2
82468: PUSH
82469: LD_INT 0
82471: PUSH
82472: EMPTY
82473: LIST
82474: LIST
82475: PUSH
82476: LD_INT 2
82478: PUSH
82479: LD_INT 1
82481: PUSH
82482: EMPTY
82483: LIST
82484: LIST
82485: PUSH
82486: LD_INT 2
82488: PUSH
82489: LD_INT 2
82491: PUSH
82492: EMPTY
82493: LIST
82494: LIST
82495: PUSH
82496: LD_INT 1
82498: PUSH
82499: LD_INT 2
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 1
82508: NEG
82509: PUSH
82510: LD_INT 1
82512: PUSH
82513: EMPTY
82514: LIST
82515: LIST
82516: PUSH
82517: LD_INT 2
82519: NEG
82520: PUSH
82521: LD_INT 0
82523: PUSH
82524: EMPTY
82525: LIST
82526: LIST
82527: PUSH
82528: LD_INT 2
82530: NEG
82531: PUSH
82532: LD_INT 1
82534: NEG
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 2
82542: NEG
82543: PUSH
82544: LD_INT 2
82546: NEG
82547: PUSH
82548: EMPTY
82549: LIST
82550: LIST
82551: PUSH
82552: LD_INT 2
82554: NEG
82555: PUSH
82556: LD_INT 3
82558: NEG
82559: PUSH
82560: EMPTY
82561: LIST
82562: LIST
82563: PUSH
82564: LD_INT 2
82566: PUSH
82567: LD_INT 1
82569: NEG
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 3
82577: PUSH
82578: LD_INT 0
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 3
82587: PUSH
82588: LD_INT 1
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 3
82597: PUSH
82598: LD_INT 2
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 3
82607: PUSH
82608: LD_INT 3
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: LD_INT 2
82617: PUSH
82618: LD_INT 3
82620: PUSH
82621: EMPTY
82622: LIST
82623: LIST
82624: PUSH
82625: LD_INT 2
82627: NEG
82628: PUSH
82629: LD_INT 1
82631: PUSH
82632: EMPTY
82633: LIST
82634: LIST
82635: PUSH
82636: LD_INT 3
82638: NEG
82639: PUSH
82640: LD_INT 0
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 3
82649: NEG
82650: PUSH
82651: LD_INT 1
82653: NEG
82654: PUSH
82655: EMPTY
82656: LIST
82657: LIST
82658: PUSH
82659: LD_INT 3
82661: NEG
82662: PUSH
82663: LD_INT 2
82665: NEG
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: PUSH
82671: LD_INT 3
82673: NEG
82674: PUSH
82675: LD_INT 3
82677: NEG
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: EMPTY
82684: LIST
82685: LIST
82686: LIST
82687: LIST
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: LIST
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
82714: LD_ADDR_VAR 0 45
82718: PUSH
82719: LD_INT 0
82721: PUSH
82722: LD_INT 0
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 0
82731: PUSH
82732: LD_INT 1
82734: NEG
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 1
82742: PUSH
82743: LD_INT 0
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 1
82752: PUSH
82753: LD_INT 1
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: LD_INT 1
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: NEG
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: NEG
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: LD_INT 1
82795: NEG
82796: PUSH
82797: LD_INT 2
82799: NEG
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: LD_INT 2
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: LD_INT 1
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: LD_INT 1
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 2
82839: PUSH
82840: LD_INT 2
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 1
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 0
82859: PUSH
82860: LD_INT 2
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 1
82869: NEG
82870: PUSH
82871: LD_INT 1
82873: PUSH
82874: EMPTY
82875: LIST
82876: LIST
82877: PUSH
82878: LD_INT 2
82880: NEG
82881: PUSH
82882: LD_INT 1
82884: NEG
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: LD_INT 2
82892: NEG
82893: PUSH
82894: LD_INT 2
82896: NEG
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 2
82904: NEG
82905: PUSH
82906: LD_INT 3
82908: NEG
82909: PUSH
82910: EMPTY
82911: LIST
82912: LIST
82913: PUSH
82914: LD_INT 1
82916: NEG
82917: PUSH
82918: LD_INT 3
82920: NEG
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 0
82928: PUSH
82929: LD_INT 3
82931: NEG
82932: PUSH
82933: EMPTY
82934: LIST
82935: LIST
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: LD_INT 2
82942: NEG
82943: PUSH
82944: EMPTY
82945: LIST
82946: LIST
82947: PUSH
82948: LD_INT 3
82950: PUSH
82951: LD_INT 2
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 3
82960: PUSH
82961: LD_INT 3
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 2
82970: PUSH
82971: LD_INT 3
82973: PUSH
82974: EMPTY
82975: LIST
82976: LIST
82977: PUSH
82978: LD_INT 1
82980: PUSH
82981: LD_INT 3
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: PUSH
82988: LD_INT 0
82990: PUSH
82991: LD_INT 3
82993: PUSH
82994: EMPTY
82995: LIST
82996: LIST
82997: PUSH
82998: LD_INT 1
83000: NEG
83001: PUSH
83002: LD_INT 2
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 3
83011: NEG
83012: PUSH
83013: LD_INT 2
83015: NEG
83016: PUSH
83017: EMPTY
83018: LIST
83019: LIST
83020: PUSH
83021: LD_INT 3
83023: NEG
83024: PUSH
83025: LD_INT 3
83027: NEG
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: EMPTY
83034: LIST
83035: LIST
83036: LIST
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83064: LD_ADDR_VAR 0 46
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: LD_INT 0
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: PUSH
83079: LD_INT 0
83081: PUSH
83082: LD_INT 1
83084: NEG
83085: PUSH
83086: EMPTY
83087: LIST
83088: LIST
83089: PUSH
83090: LD_INT 1
83092: PUSH
83093: LD_INT 0
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 1
83102: PUSH
83103: LD_INT 1
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: PUSH
83110: LD_INT 0
83112: PUSH
83113: LD_INT 1
83115: PUSH
83116: EMPTY
83117: LIST
83118: LIST
83119: PUSH
83120: LD_INT 1
83122: NEG
83123: PUSH
83124: LD_INT 0
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: PUSH
83131: LD_INT 1
83133: NEG
83134: PUSH
83135: LD_INT 1
83137: NEG
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 1
83145: NEG
83146: PUSH
83147: LD_INT 2
83149: NEG
83150: PUSH
83151: EMPTY
83152: LIST
83153: LIST
83154: PUSH
83155: LD_INT 0
83157: PUSH
83158: LD_INT 2
83160: NEG
83161: PUSH
83162: EMPTY
83163: LIST
83164: LIST
83165: PUSH
83166: LD_INT 1
83168: PUSH
83169: LD_INT 1
83171: NEG
83172: PUSH
83173: EMPTY
83174: LIST
83175: LIST
83176: PUSH
83177: LD_INT 2
83179: PUSH
83180: LD_INT 0
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 2
83189: PUSH
83190: LD_INT 1
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: PUSH
83197: LD_INT 1
83199: PUSH
83200: LD_INT 2
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PUSH
83207: LD_INT 0
83209: PUSH
83210: LD_INT 2
83212: PUSH
83213: EMPTY
83214: LIST
83215: LIST
83216: PUSH
83217: LD_INT 1
83219: NEG
83220: PUSH
83221: LD_INT 1
83223: PUSH
83224: EMPTY
83225: LIST
83226: LIST
83227: PUSH
83228: LD_INT 2
83230: NEG
83231: PUSH
83232: LD_INT 0
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 2
83241: NEG
83242: PUSH
83243: LD_INT 1
83245: NEG
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: PUSH
83251: LD_INT 1
83253: NEG
83254: PUSH
83255: LD_INT 3
83257: NEG
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: PUSH
83263: LD_INT 0
83265: PUSH
83266: LD_INT 3
83268: NEG
83269: PUSH
83270: EMPTY
83271: LIST
83272: LIST
83273: PUSH
83274: LD_INT 1
83276: PUSH
83277: LD_INT 2
83279: NEG
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 2
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 3
83298: PUSH
83299: LD_INT 0
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 3
83308: PUSH
83309: LD_INT 1
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 1
83318: PUSH
83319: LD_INT 3
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 0
83328: PUSH
83329: LD_INT 3
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: NEG
83339: PUSH
83340: LD_INT 2
83342: PUSH
83343: EMPTY
83344: LIST
83345: LIST
83346: PUSH
83347: LD_INT 2
83349: NEG
83350: PUSH
83351: LD_INT 1
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: PUSH
83358: LD_INT 3
83360: NEG
83361: PUSH
83362: LD_INT 0
83364: PUSH
83365: EMPTY
83366: LIST
83367: LIST
83368: PUSH
83369: LD_INT 3
83371: NEG
83372: PUSH
83373: LD_INT 1
83375: NEG
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PUSH
83381: EMPTY
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: LIST
83391: LIST
83392: LIST
83393: LIST
83394: LIST
83395: LIST
83396: LIST
83397: LIST
83398: LIST
83399: LIST
83400: LIST
83401: LIST
83402: LIST
83403: LIST
83404: LIST
83405: LIST
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83412: LD_ADDR_VAR 0 47
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: LD_INT 0
83422: PUSH
83423: EMPTY
83424: LIST
83425: LIST
83426: PUSH
83427: LD_INT 0
83429: PUSH
83430: LD_INT 1
83432: NEG
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PUSH
83438: LD_INT 1
83440: PUSH
83441: LD_INT 0
83443: PUSH
83444: EMPTY
83445: LIST
83446: LIST
83447: PUSH
83448: LD_INT 1
83450: PUSH
83451: LD_INT 1
83453: PUSH
83454: EMPTY
83455: LIST
83456: LIST
83457: PUSH
83458: LD_INT 0
83460: PUSH
83461: LD_INT 1
83463: PUSH
83464: EMPTY
83465: LIST
83466: LIST
83467: PUSH
83468: LD_INT 1
83470: NEG
83471: PUSH
83472: LD_INT 0
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 1
83481: NEG
83482: PUSH
83483: LD_INT 1
83485: NEG
83486: PUSH
83487: EMPTY
83488: LIST
83489: LIST
83490: PUSH
83491: LD_INT 1
83493: NEG
83494: PUSH
83495: LD_INT 2
83497: NEG
83498: PUSH
83499: EMPTY
83500: LIST
83501: LIST
83502: PUSH
83503: LD_INT 0
83505: PUSH
83506: LD_INT 2
83508: NEG
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: LD_INT 1
83516: PUSH
83517: LD_INT 1
83519: NEG
83520: PUSH
83521: EMPTY
83522: LIST
83523: LIST
83524: PUSH
83525: LD_INT 2
83527: NEG
83528: PUSH
83529: LD_INT 1
83531: NEG
83532: PUSH
83533: EMPTY
83534: LIST
83535: LIST
83536: PUSH
83537: LD_INT 2
83539: NEG
83540: PUSH
83541: LD_INT 2
83543: NEG
83544: PUSH
83545: EMPTY
83546: LIST
83547: LIST
83548: PUSH
83549: EMPTY
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
83563: LD_ADDR_VAR 0 48
83567: PUSH
83568: LD_INT 0
83570: PUSH
83571: LD_INT 0
83573: PUSH
83574: EMPTY
83575: LIST
83576: LIST
83577: PUSH
83578: LD_INT 0
83580: PUSH
83581: LD_INT 1
83583: NEG
83584: PUSH
83585: EMPTY
83586: LIST
83587: LIST
83588: PUSH
83589: LD_INT 1
83591: PUSH
83592: LD_INT 0
83594: PUSH
83595: EMPTY
83596: LIST
83597: LIST
83598: PUSH
83599: LD_INT 1
83601: PUSH
83602: LD_INT 1
83604: PUSH
83605: EMPTY
83606: LIST
83607: LIST
83608: PUSH
83609: LD_INT 0
83611: PUSH
83612: LD_INT 1
83614: PUSH
83615: EMPTY
83616: LIST
83617: LIST
83618: PUSH
83619: LD_INT 1
83621: NEG
83622: PUSH
83623: LD_INT 0
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PUSH
83630: LD_INT 1
83632: NEG
83633: PUSH
83634: LD_INT 1
83636: NEG
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: NEG
83645: PUSH
83646: LD_INT 2
83648: NEG
83649: PUSH
83650: EMPTY
83651: LIST
83652: LIST
83653: PUSH
83654: LD_INT 0
83656: PUSH
83657: LD_INT 2
83659: NEG
83660: PUSH
83661: EMPTY
83662: LIST
83663: LIST
83664: PUSH
83665: LD_INT 1
83667: PUSH
83668: LD_INT 1
83670: NEG
83671: PUSH
83672: EMPTY
83673: LIST
83674: LIST
83675: PUSH
83676: LD_INT 2
83678: PUSH
83679: LD_INT 0
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: PUSH
83686: LD_INT 2
83688: PUSH
83689: LD_INT 1
83691: PUSH
83692: EMPTY
83693: LIST
83694: LIST
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
83710: LD_ADDR_VAR 0 49
83714: PUSH
83715: LD_INT 0
83717: PUSH
83718: LD_INT 0
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 0
83727: PUSH
83728: LD_INT 1
83730: NEG
83731: PUSH
83732: EMPTY
83733: LIST
83734: LIST
83735: PUSH
83736: LD_INT 1
83738: PUSH
83739: LD_INT 0
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PUSH
83746: LD_INT 1
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 0
83758: PUSH
83759: LD_INT 1
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: NEG
83769: PUSH
83770: LD_INT 0
83772: PUSH
83773: EMPTY
83774: LIST
83775: LIST
83776: PUSH
83777: LD_INT 1
83779: NEG
83780: PUSH
83781: LD_INT 1
83783: NEG
83784: PUSH
83785: EMPTY
83786: LIST
83787: LIST
83788: PUSH
83789: LD_INT 1
83791: PUSH
83792: LD_INT 1
83794: NEG
83795: PUSH
83796: EMPTY
83797: LIST
83798: LIST
83799: PUSH
83800: LD_INT 2
83802: PUSH
83803: LD_INT 0
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: PUSH
83810: LD_INT 2
83812: PUSH
83813: LD_INT 1
83815: PUSH
83816: EMPTY
83817: LIST
83818: LIST
83819: PUSH
83820: LD_INT 2
83822: PUSH
83823: LD_INT 2
83825: PUSH
83826: EMPTY
83827: LIST
83828: LIST
83829: PUSH
83830: LD_INT 1
83832: PUSH
83833: LD_INT 2
83835: PUSH
83836: EMPTY
83837: LIST
83838: LIST
83839: PUSH
83840: EMPTY
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
83854: LD_ADDR_VAR 0 50
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: LD_INT 0
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PUSH
83869: LD_INT 0
83871: PUSH
83872: LD_INT 1
83874: NEG
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 1
83882: PUSH
83883: LD_INT 0
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 1
83892: PUSH
83893: LD_INT 1
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 0
83902: PUSH
83903: LD_INT 1
83905: PUSH
83906: EMPTY
83907: LIST
83908: LIST
83909: PUSH
83910: LD_INT 1
83912: NEG
83913: PUSH
83914: LD_INT 0
83916: PUSH
83917: EMPTY
83918: LIST
83919: LIST
83920: PUSH
83921: LD_INT 1
83923: NEG
83924: PUSH
83925: LD_INT 1
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 2
83935: PUSH
83936: LD_INT 1
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: PUSH
83946: LD_INT 2
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 1
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 0
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 1
83975: NEG
83976: PUSH
83977: LD_INT 1
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
83998: LD_ADDR_VAR 0 51
84002: PUSH
84003: LD_INT 0
84005: PUSH
84006: LD_INT 0
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PUSH
84013: LD_INT 0
84015: PUSH
84016: LD_INT 1
84018: NEG
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 1
84026: PUSH
84027: LD_INT 0
84029: PUSH
84030: EMPTY
84031: LIST
84032: LIST
84033: PUSH
84034: LD_INT 1
84036: PUSH
84037: LD_INT 1
84039: PUSH
84040: EMPTY
84041: LIST
84042: LIST
84043: PUSH
84044: LD_INT 0
84046: PUSH
84047: LD_INT 1
84049: PUSH
84050: EMPTY
84051: LIST
84052: LIST
84053: PUSH
84054: LD_INT 1
84056: NEG
84057: PUSH
84058: LD_INT 0
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 1
84067: NEG
84068: PUSH
84069: LD_INT 1
84071: NEG
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 1
84079: PUSH
84080: LD_INT 2
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 0
84089: PUSH
84090: LD_INT 2
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: PUSH
84097: LD_INT 1
84099: NEG
84100: PUSH
84101: LD_INT 1
84103: PUSH
84104: EMPTY
84105: LIST
84106: LIST
84107: PUSH
84108: LD_INT 2
84110: NEG
84111: PUSH
84112: LD_INT 0
84114: PUSH
84115: EMPTY
84116: LIST
84117: LIST
84118: PUSH
84119: LD_INT 2
84121: NEG
84122: PUSH
84123: LD_INT 1
84125: NEG
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84145: LD_ADDR_VAR 0 52
84149: PUSH
84150: LD_INT 0
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: LD_INT 1
84165: NEG
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 1
84173: PUSH
84174: LD_INT 0
84176: PUSH
84177: EMPTY
84178: LIST
84179: LIST
84180: PUSH
84181: LD_INT 1
84183: PUSH
84184: LD_INT 1
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: LD_INT 1
84196: PUSH
84197: EMPTY
84198: LIST
84199: LIST
84200: PUSH
84201: LD_INT 1
84203: NEG
84204: PUSH
84205: LD_INT 0
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 1
84214: NEG
84215: PUSH
84216: LD_INT 1
84218: NEG
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 1
84226: NEG
84227: PUSH
84228: LD_INT 2
84230: NEG
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: PUSH
84236: LD_INT 1
84238: NEG
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 2
84249: NEG
84250: PUSH
84251: LD_INT 0
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: LD_INT 2
84260: NEG
84261: PUSH
84262: LD_INT 1
84264: NEG
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: PUSH
84270: LD_INT 2
84272: NEG
84273: PUSH
84274: LD_INT 2
84276: NEG
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: EMPTY
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84296: LD_ADDR_VAR 0 53
84300: PUSH
84301: LD_INT 0
84303: PUSH
84304: LD_INT 0
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: PUSH
84311: LD_INT 0
84313: PUSH
84314: LD_INT 1
84316: NEG
84317: PUSH
84318: EMPTY
84319: LIST
84320: LIST
84321: PUSH
84322: LD_INT 1
84324: PUSH
84325: LD_INT 0
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 1
84334: PUSH
84335: LD_INT 1
84337: PUSH
84338: EMPTY
84339: LIST
84340: LIST
84341: PUSH
84342: LD_INT 0
84344: PUSH
84345: LD_INT 1
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: PUSH
84352: LD_INT 1
84354: NEG
84355: PUSH
84356: LD_INT 0
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 1
84365: NEG
84366: PUSH
84367: LD_INT 1
84369: NEG
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 1
84377: NEG
84378: PUSH
84379: LD_INT 2
84381: NEG
84382: PUSH
84383: EMPTY
84384: LIST
84385: LIST
84386: PUSH
84387: LD_INT 0
84389: PUSH
84390: LD_INT 2
84392: NEG
84393: PUSH
84394: EMPTY
84395: LIST
84396: LIST
84397: PUSH
84398: LD_INT 1
84400: PUSH
84401: LD_INT 1
84403: NEG
84404: PUSH
84405: EMPTY
84406: LIST
84407: LIST
84408: PUSH
84409: LD_INT 2
84411: PUSH
84412: LD_INT 0
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 2
84421: PUSH
84422: LD_INT 1
84424: PUSH
84425: EMPTY
84426: LIST
84427: LIST
84428: PUSH
84429: LD_INT 2
84431: PUSH
84432: LD_INT 2
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: PUSH
84439: LD_INT 1
84441: PUSH
84442: LD_INT 2
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 0
84451: PUSH
84452: LD_INT 2
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: PUSH
84459: LD_INT 1
84461: NEG
84462: PUSH
84463: LD_INT 1
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 2
84472: NEG
84473: PUSH
84474: LD_INT 0
84476: PUSH
84477: EMPTY
84478: LIST
84479: LIST
84480: PUSH
84481: LD_INT 2
84483: NEG
84484: PUSH
84485: LD_INT 1
84487: NEG
84488: PUSH
84489: EMPTY
84490: LIST
84491: LIST
84492: PUSH
84493: LD_INT 2
84495: NEG
84496: PUSH
84497: LD_INT 2
84499: NEG
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: LIST
84520: LIST
84521: LIST
84522: LIST
84523: LIST
84524: LIST
84525: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84526: LD_ADDR_VAR 0 54
84530: PUSH
84531: LD_INT 0
84533: PUSH
84534: LD_INT 0
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PUSH
84541: LD_INT 0
84543: PUSH
84544: LD_INT 1
84546: NEG
84547: PUSH
84548: EMPTY
84549: LIST
84550: LIST
84551: PUSH
84552: LD_INT 1
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 1
84564: PUSH
84565: LD_INT 1
84567: PUSH
84568: EMPTY
84569: LIST
84570: LIST
84571: PUSH
84572: LD_INT 0
84574: PUSH
84575: LD_INT 1
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 1
84584: NEG
84585: PUSH
84586: LD_INT 0
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 1
84595: NEG
84596: PUSH
84597: LD_INT 1
84599: NEG
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 1
84607: NEG
84608: PUSH
84609: LD_INT 2
84611: NEG
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 0
84619: PUSH
84620: LD_INT 2
84622: NEG
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 1
84630: PUSH
84631: LD_INT 1
84633: NEG
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 2
84641: PUSH
84642: LD_INT 0
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 2
84651: PUSH
84652: LD_INT 1
84654: PUSH
84655: EMPTY
84656: LIST
84657: LIST
84658: PUSH
84659: LD_INT 2
84661: PUSH
84662: LD_INT 2
84664: PUSH
84665: EMPTY
84666: LIST
84667: LIST
84668: PUSH
84669: LD_INT 1
84671: PUSH
84672: LD_INT 2
84674: PUSH
84675: EMPTY
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 0
84681: PUSH
84682: LD_INT 2
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 1
84691: NEG
84692: PUSH
84693: LD_INT 1
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 2
84702: NEG
84703: PUSH
84704: LD_INT 0
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 2
84713: NEG
84714: PUSH
84715: LD_INT 1
84717: NEG
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 2
84725: NEG
84726: PUSH
84727: LD_INT 2
84729: NEG
84730: PUSH
84731: EMPTY
84732: LIST
84733: LIST
84734: PUSH
84735: EMPTY
84736: LIST
84737: LIST
84738: LIST
84739: LIST
84740: LIST
84741: LIST
84742: LIST
84743: LIST
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84756: LD_ADDR_VAR 0 55
84760: PUSH
84761: LD_INT 0
84763: PUSH
84764: LD_INT 0
84766: PUSH
84767: EMPTY
84768: LIST
84769: LIST
84770: PUSH
84771: LD_INT 0
84773: PUSH
84774: LD_INT 1
84776: NEG
84777: PUSH
84778: EMPTY
84779: LIST
84780: LIST
84781: PUSH
84782: LD_INT 1
84784: PUSH
84785: LD_INT 0
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 1
84794: PUSH
84795: LD_INT 1
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 0
84804: PUSH
84805: LD_INT 1
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: LD_INT 1
84814: NEG
84815: PUSH
84816: LD_INT 0
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: PUSH
84823: LD_INT 1
84825: NEG
84826: PUSH
84827: LD_INT 1
84829: NEG
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 1
84837: NEG
84838: PUSH
84839: LD_INT 2
84841: NEG
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 0
84849: PUSH
84850: LD_INT 2
84852: NEG
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 1
84860: PUSH
84861: LD_INT 1
84863: NEG
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 2
84871: PUSH
84872: LD_INT 0
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 2
84881: PUSH
84882: LD_INT 1
84884: PUSH
84885: EMPTY
84886: LIST
84887: LIST
84888: PUSH
84889: LD_INT 2
84891: PUSH
84892: LD_INT 2
84894: PUSH
84895: EMPTY
84896: LIST
84897: LIST
84898: PUSH
84899: LD_INT 1
84901: PUSH
84902: LD_INT 2
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: LD_INT 0
84911: PUSH
84912: LD_INT 2
84914: PUSH
84915: EMPTY
84916: LIST
84917: LIST
84918: PUSH
84919: LD_INT 1
84921: NEG
84922: PUSH
84923: LD_INT 1
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 2
84932: NEG
84933: PUSH
84934: LD_INT 0
84936: PUSH
84937: EMPTY
84938: LIST
84939: LIST
84940: PUSH
84941: LD_INT 2
84943: NEG
84944: PUSH
84945: LD_INT 1
84947: NEG
84948: PUSH
84949: EMPTY
84950: LIST
84951: LIST
84952: PUSH
84953: LD_INT 2
84955: NEG
84956: PUSH
84957: LD_INT 2
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84986: LD_ADDR_VAR 0 56
84990: PUSH
84991: LD_INT 0
84993: PUSH
84994: LD_INT 0
84996: PUSH
84997: EMPTY
84998: LIST
84999: LIST
85000: PUSH
85001: LD_INT 0
85003: PUSH
85004: LD_INT 1
85006: NEG
85007: PUSH
85008: EMPTY
85009: LIST
85010: LIST
85011: PUSH
85012: LD_INT 1
85014: PUSH
85015: LD_INT 0
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 1
85024: PUSH
85025: LD_INT 1
85027: PUSH
85028: EMPTY
85029: LIST
85030: LIST
85031: PUSH
85032: LD_INT 0
85034: PUSH
85035: LD_INT 1
85037: PUSH
85038: EMPTY
85039: LIST
85040: LIST
85041: PUSH
85042: LD_INT 1
85044: NEG
85045: PUSH
85046: LD_INT 0
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 1
85055: NEG
85056: PUSH
85057: LD_INT 1
85059: NEG
85060: PUSH
85061: EMPTY
85062: LIST
85063: LIST
85064: PUSH
85065: LD_INT 1
85067: NEG
85068: PUSH
85069: LD_INT 2
85071: NEG
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 0
85079: PUSH
85080: LD_INT 2
85082: NEG
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 1
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: EMPTY
85096: LIST
85097: LIST
85098: PUSH
85099: LD_INT 2
85101: PUSH
85102: LD_INT 0
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 2
85111: PUSH
85112: LD_INT 1
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: PUSH
85119: LD_INT 2
85121: PUSH
85122: LD_INT 2
85124: PUSH
85125: EMPTY
85126: LIST
85127: LIST
85128: PUSH
85129: LD_INT 1
85131: PUSH
85132: LD_INT 2
85134: PUSH
85135: EMPTY
85136: LIST
85137: LIST
85138: PUSH
85139: LD_INT 0
85141: PUSH
85142: LD_INT 2
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 1
85151: NEG
85152: PUSH
85153: LD_INT 1
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 2
85162: NEG
85163: PUSH
85164: LD_INT 0
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 2
85173: NEG
85174: PUSH
85175: LD_INT 1
85177: NEG
85178: PUSH
85179: EMPTY
85180: LIST
85181: LIST
85182: PUSH
85183: LD_INT 2
85185: NEG
85186: PUSH
85187: LD_INT 2
85189: NEG
85190: PUSH
85191: EMPTY
85192: LIST
85193: LIST
85194: PUSH
85195: EMPTY
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85216: LD_ADDR_VAR 0 57
85220: PUSH
85221: LD_INT 0
85223: PUSH
85224: LD_INT 0
85226: PUSH
85227: EMPTY
85228: LIST
85229: LIST
85230: PUSH
85231: LD_INT 0
85233: PUSH
85234: LD_INT 1
85236: NEG
85237: PUSH
85238: EMPTY
85239: LIST
85240: LIST
85241: PUSH
85242: LD_INT 1
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 1
85254: PUSH
85255: LD_INT 1
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: PUSH
85262: LD_INT 0
85264: PUSH
85265: LD_INT 1
85267: PUSH
85268: EMPTY
85269: LIST
85270: LIST
85271: PUSH
85272: LD_INT 1
85274: NEG
85275: PUSH
85276: LD_INT 0
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 1
85285: NEG
85286: PUSH
85287: LD_INT 1
85289: NEG
85290: PUSH
85291: EMPTY
85292: LIST
85293: LIST
85294: PUSH
85295: LD_INT 1
85297: NEG
85298: PUSH
85299: LD_INT 2
85301: NEG
85302: PUSH
85303: EMPTY
85304: LIST
85305: LIST
85306: PUSH
85307: LD_INT 0
85309: PUSH
85310: LD_INT 2
85312: NEG
85313: PUSH
85314: EMPTY
85315: LIST
85316: LIST
85317: PUSH
85318: LD_INT 1
85320: PUSH
85321: LD_INT 1
85323: NEG
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 2
85331: PUSH
85332: LD_INT 0
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 2
85341: PUSH
85342: LD_INT 1
85344: PUSH
85345: EMPTY
85346: LIST
85347: LIST
85348: PUSH
85349: LD_INT 2
85351: PUSH
85352: LD_INT 2
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: PUSH
85359: LD_INT 1
85361: PUSH
85362: LD_INT 2
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 0
85371: PUSH
85372: LD_INT 2
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: LD_INT 1
85381: NEG
85382: PUSH
85383: LD_INT 1
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 2
85392: NEG
85393: PUSH
85394: LD_INT 0
85396: PUSH
85397: EMPTY
85398: LIST
85399: LIST
85400: PUSH
85401: LD_INT 2
85403: NEG
85404: PUSH
85405: LD_INT 1
85407: NEG
85408: PUSH
85409: EMPTY
85410: LIST
85411: LIST
85412: PUSH
85413: LD_INT 2
85415: NEG
85416: PUSH
85417: LD_INT 2
85419: NEG
85420: PUSH
85421: EMPTY
85422: LIST
85423: LIST
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: LIST
85429: LIST
85430: LIST
85431: LIST
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: LIST
85439: LIST
85440: LIST
85441: LIST
85442: LIST
85443: LIST
85444: LIST
85445: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85446: LD_ADDR_VAR 0 58
85450: PUSH
85451: LD_INT 0
85453: PUSH
85454: LD_INT 0
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: PUSH
85461: LD_INT 0
85463: PUSH
85464: LD_INT 1
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 1
85474: PUSH
85475: LD_INT 0
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 1
85484: PUSH
85485: LD_INT 1
85487: PUSH
85488: EMPTY
85489: LIST
85490: LIST
85491: PUSH
85492: LD_INT 0
85494: PUSH
85495: LD_INT 1
85497: PUSH
85498: EMPTY
85499: LIST
85500: LIST
85501: PUSH
85502: LD_INT 1
85504: NEG
85505: PUSH
85506: LD_INT 0
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 1
85515: NEG
85516: PUSH
85517: LD_INT 1
85519: NEG
85520: PUSH
85521: EMPTY
85522: LIST
85523: LIST
85524: PUSH
85525: LD_INT 1
85527: NEG
85528: PUSH
85529: LD_INT 2
85531: NEG
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 0
85539: PUSH
85540: LD_INT 2
85542: NEG
85543: PUSH
85544: EMPTY
85545: LIST
85546: LIST
85547: PUSH
85548: LD_INT 1
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: EMPTY
85556: LIST
85557: LIST
85558: PUSH
85559: LD_INT 2
85561: PUSH
85562: LD_INT 0
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 2
85571: PUSH
85572: LD_INT 1
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PUSH
85579: LD_INT 2
85581: PUSH
85582: LD_INT 2
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: LD_INT 1
85591: PUSH
85592: LD_INT 2
85594: PUSH
85595: EMPTY
85596: LIST
85597: LIST
85598: PUSH
85599: LD_INT 0
85601: PUSH
85602: LD_INT 2
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 1
85611: NEG
85612: PUSH
85613: LD_INT 1
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 2
85622: NEG
85623: PUSH
85624: LD_INT 0
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PUSH
85631: LD_INT 2
85633: NEG
85634: PUSH
85635: LD_INT 1
85637: NEG
85638: PUSH
85639: EMPTY
85640: LIST
85641: LIST
85642: PUSH
85643: LD_INT 2
85645: NEG
85646: PUSH
85647: LD_INT 2
85649: NEG
85650: PUSH
85651: EMPTY
85652: LIST
85653: LIST
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85676: LD_ADDR_VAR 0 59
85680: PUSH
85681: LD_INT 0
85683: PUSH
85684: LD_INT 0
85686: PUSH
85687: EMPTY
85688: LIST
85689: LIST
85690: PUSH
85691: LD_INT 0
85693: PUSH
85694: LD_INT 1
85696: NEG
85697: PUSH
85698: EMPTY
85699: LIST
85700: LIST
85701: PUSH
85702: LD_INT 1
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 1
85714: PUSH
85715: LD_INT 1
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PUSH
85722: LD_INT 0
85724: PUSH
85725: LD_INT 1
85727: PUSH
85728: EMPTY
85729: LIST
85730: LIST
85731: PUSH
85732: LD_INT 1
85734: NEG
85735: PUSH
85736: LD_INT 0
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 1
85745: NEG
85746: PUSH
85747: LD_INT 1
85749: NEG
85750: PUSH
85751: EMPTY
85752: LIST
85753: LIST
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85764: LD_ADDR_VAR 0 60
85768: PUSH
85769: LD_INT 0
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 0
85781: PUSH
85782: LD_INT 1
85784: NEG
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 1
85792: PUSH
85793: LD_INT 0
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: LD_INT 1
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 0
85812: PUSH
85813: LD_INT 1
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 1
85822: NEG
85823: PUSH
85824: LD_INT 0
85826: PUSH
85827: EMPTY
85828: LIST
85829: LIST
85830: PUSH
85831: LD_INT 1
85833: NEG
85834: PUSH
85835: LD_INT 1
85837: NEG
85838: PUSH
85839: EMPTY
85840: LIST
85841: LIST
85842: PUSH
85843: EMPTY
85844: LIST
85845: LIST
85846: LIST
85847: LIST
85848: LIST
85849: LIST
85850: LIST
85851: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85852: LD_ADDR_VAR 0 61
85856: PUSH
85857: LD_INT 0
85859: PUSH
85860: LD_INT 0
85862: PUSH
85863: EMPTY
85864: LIST
85865: LIST
85866: PUSH
85867: LD_INT 0
85869: PUSH
85870: LD_INT 1
85872: NEG
85873: PUSH
85874: EMPTY
85875: LIST
85876: LIST
85877: PUSH
85878: LD_INT 1
85880: PUSH
85881: LD_INT 0
85883: PUSH
85884: EMPTY
85885: LIST
85886: LIST
85887: PUSH
85888: LD_INT 1
85890: PUSH
85891: LD_INT 1
85893: PUSH
85894: EMPTY
85895: LIST
85896: LIST
85897: PUSH
85898: LD_INT 0
85900: PUSH
85901: LD_INT 1
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: PUSH
85908: LD_INT 1
85910: NEG
85911: PUSH
85912: LD_INT 0
85914: PUSH
85915: EMPTY
85916: LIST
85917: LIST
85918: PUSH
85919: LD_INT 1
85921: NEG
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
85940: LD_ADDR_VAR 0 62
85944: PUSH
85945: LD_INT 0
85947: PUSH
85948: LD_INT 0
85950: PUSH
85951: EMPTY
85952: LIST
85953: LIST
85954: PUSH
85955: LD_INT 0
85957: PUSH
85958: LD_INT 1
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 1
85968: PUSH
85969: LD_INT 0
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 1
85978: PUSH
85979: LD_INT 1
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 0
85988: PUSH
85989: LD_INT 1
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 1
85998: NEG
85999: PUSH
86000: LD_INT 0
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PUSH
86007: LD_INT 1
86009: NEG
86010: PUSH
86011: LD_INT 1
86013: NEG
86014: PUSH
86015: EMPTY
86016: LIST
86017: LIST
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86028: LD_ADDR_VAR 0 63
86032: PUSH
86033: LD_INT 0
86035: PUSH
86036: LD_INT 0
86038: PUSH
86039: EMPTY
86040: LIST
86041: LIST
86042: PUSH
86043: LD_INT 0
86045: PUSH
86046: LD_INT 1
86048: NEG
86049: PUSH
86050: EMPTY
86051: LIST
86052: LIST
86053: PUSH
86054: LD_INT 1
86056: PUSH
86057: LD_INT 0
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 1
86066: PUSH
86067: LD_INT 1
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 0
86076: PUSH
86077: LD_INT 1
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 1
86086: NEG
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 1
86097: NEG
86098: PUSH
86099: LD_INT 1
86101: NEG
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PUSH
86107: EMPTY
86108: LIST
86109: LIST
86110: LIST
86111: LIST
86112: LIST
86113: LIST
86114: LIST
86115: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
86116: LD_ADDR_VAR 0 64
86120: PUSH
86121: LD_INT 0
86123: PUSH
86124: LD_INT 0
86126: PUSH
86127: EMPTY
86128: LIST
86129: LIST
86130: PUSH
86131: LD_INT 0
86133: PUSH
86134: LD_INT 1
86136: NEG
86137: PUSH
86138: EMPTY
86139: LIST
86140: LIST
86141: PUSH
86142: LD_INT 1
86144: PUSH
86145: LD_INT 0
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PUSH
86152: LD_INT 1
86154: PUSH
86155: LD_INT 1
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 0
86164: PUSH
86165: LD_INT 1
86167: PUSH
86168: EMPTY
86169: LIST
86170: LIST
86171: PUSH
86172: LD_INT 1
86174: NEG
86175: PUSH
86176: LD_INT 0
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: LD_INT 1
86185: NEG
86186: PUSH
86187: LD_INT 1
86189: NEG
86190: PUSH
86191: EMPTY
86192: LIST
86193: LIST
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: LIST
86199: LIST
86200: LIST
86201: LIST
86202: LIST
86203: ST_TO_ADDR
// end ; 1 :
86204: GO 92101
86206: LD_INT 1
86208: DOUBLE
86209: EQUAL
86210: IFTRUE 86214
86212: GO 88837
86214: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86215: LD_ADDR_VAR 0 11
86219: PUSH
86220: LD_INT 1
86222: NEG
86223: PUSH
86224: LD_INT 3
86226: NEG
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: PUSH
86232: LD_INT 0
86234: PUSH
86235: LD_INT 3
86237: NEG
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 1
86245: PUSH
86246: LD_INT 2
86248: NEG
86249: PUSH
86250: EMPTY
86251: LIST
86252: LIST
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: LIST
86258: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86259: LD_ADDR_VAR 0 12
86263: PUSH
86264: LD_INT 2
86266: PUSH
86267: LD_INT 1
86269: NEG
86270: PUSH
86271: EMPTY
86272: LIST
86273: LIST
86274: PUSH
86275: LD_INT 3
86277: PUSH
86278: LD_INT 0
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 3
86287: PUSH
86288: LD_INT 1
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: LIST
86299: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86300: LD_ADDR_VAR 0 13
86304: PUSH
86305: LD_INT 3
86307: PUSH
86308: LD_INT 2
86310: PUSH
86311: EMPTY
86312: LIST
86313: LIST
86314: PUSH
86315: LD_INT 3
86317: PUSH
86318: LD_INT 3
86320: PUSH
86321: EMPTY
86322: LIST
86323: LIST
86324: PUSH
86325: LD_INT 2
86327: PUSH
86328: LD_INT 3
86330: PUSH
86331: EMPTY
86332: LIST
86333: LIST
86334: PUSH
86335: EMPTY
86336: LIST
86337: LIST
86338: LIST
86339: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86340: LD_ADDR_VAR 0 14
86344: PUSH
86345: LD_INT 1
86347: PUSH
86348: LD_INT 3
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 0
86357: PUSH
86358: LD_INT 3
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: LD_INT 2
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: EMPTY
86377: LIST
86378: LIST
86379: LIST
86380: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86381: LD_ADDR_VAR 0 15
86385: PUSH
86386: LD_INT 2
86388: NEG
86389: PUSH
86390: LD_INT 1
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 3
86399: NEG
86400: PUSH
86401: LD_INT 0
86403: PUSH
86404: EMPTY
86405: LIST
86406: LIST
86407: PUSH
86408: LD_INT 3
86410: NEG
86411: PUSH
86412: LD_INT 1
86414: NEG
86415: PUSH
86416: EMPTY
86417: LIST
86418: LIST
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: LIST
86424: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86425: LD_ADDR_VAR 0 16
86429: PUSH
86430: LD_INT 2
86432: NEG
86433: PUSH
86434: LD_INT 3
86436: NEG
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: PUSH
86442: LD_INT 3
86444: NEG
86445: PUSH
86446: LD_INT 2
86448: NEG
86449: PUSH
86450: EMPTY
86451: LIST
86452: LIST
86453: PUSH
86454: LD_INT 3
86456: NEG
86457: PUSH
86458: LD_INT 3
86460: NEG
86461: PUSH
86462: EMPTY
86463: LIST
86464: LIST
86465: PUSH
86466: EMPTY
86467: LIST
86468: LIST
86469: LIST
86470: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86471: LD_ADDR_VAR 0 17
86475: PUSH
86476: LD_INT 1
86478: NEG
86479: PUSH
86480: LD_INT 3
86482: NEG
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 0
86490: PUSH
86491: LD_INT 3
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 1
86501: PUSH
86502: LD_INT 2
86504: NEG
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: LIST
86514: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86515: LD_ADDR_VAR 0 18
86519: PUSH
86520: LD_INT 2
86522: PUSH
86523: LD_INT 1
86525: NEG
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 3
86533: PUSH
86534: LD_INT 0
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PUSH
86541: LD_INT 3
86543: PUSH
86544: LD_INT 1
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: EMPTY
86552: LIST
86553: LIST
86554: LIST
86555: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86556: LD_ADDR_VAR 0 19
86560: PUSH
86561: LD_INT 3
86563: PUSH
86564: LD_INT 2
86566: PUSH
86567: EMPTY
86568: LIST
86569: LIST
86570: PUSH
86571: LD_INT 3
86573: PUSH
86574: LD_INT 3
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 2
86583: PUSH
86584: LD_INT 3
86586: PUSH
86587: EMPTY
86588: LIST
86589: LIST
86590: PUSH
86591: EMPTY
86592: LIST
86593: LIST
86594: LIST
86595: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
86596: LD_ADDR_VAR 0 20
86600: PUSH
86601: LD_INT 1
86603: PUSH
86604: LD_INT 3
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 0
86613: PUSH
86614: LD_INT 3
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: LD_INT 1
86623: NEG
86624: PUSH
86625: LD_INT 2
86627: PUSH
86628: EMPTY
86629: LIST
86630: LIST
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: LIST
86636: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86637: LD_ADDR_VAR 0 21
86641: PUSH
86642: LD_INT 2
86644: NEG
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: EMPTY
86650: LIST
86651: LIST
86652: PUSH
86653: LD_INT 3
86655: NEG
86656: PUSH
86657: LD_INT 0
86659: PUSH
86660: EMPTY
86661: LIST
86662: LIST
86663: PUSH
86664: LD_INT 3
86666: NEG
86667: PUSH
86668: LD_INT 1
86670: NEG
86671: PUSH
86672: EMPTY
86673: LIST
86674: LIST
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: LIST
86680: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86681: LD_ADDR_VAR 0 22
86685: PUSH
86686: LD_INT 2
86688: NEG
86689: PUSH
86690: LD_INT 3
86692: NEG
86693: PUSH
86694: EMPTY
86695: LIST
86696: LIST
86697: PUSH
86698: LD_INT 3
86700: NEG
86701: PUSH
86702: LD_INT 2
86704: NEG
86705: PUSH
86706: EMPTY
86707: LIST
86708: LIST
86709: PUSH
86710: LD_INT 3
86712: NEG
86713: PUSH
86714: LD_INT 3
86716: NEG
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: LIST
86726: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
86727: LD_ADDR_VAR 0 23
86731: PUSH
86732: LD_INT 0
86734: PUSH
86735: LD_INT 3
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 1
86745: NEG
86746: PUSH
86747: LD_INT 4
86749: NEG
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 1
86757: PUSH
86758: LD_INT 3
86760: NEG
86761: PUSH
86762: EMPTY
86763: LIST
86764: LIST
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: LIST
86770: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
86771: LD_ADDR_VAR 0 24
86775: PUSH
86776: LD_INT 3
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 3
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 4
86799: PUSH
86800: LD_INT 1
86802: PUSH
86803: EMPTY
86804: LIST
86805: LIST
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: LIST
86811: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
86812: LD_ADDR_VAR 0 25
86816: PUSH
86817: LD_INT 3
86819: PUSH
86820: LD_INT 3
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 4
86829: PUSH
86830: LD_INT 3
86832: PUSH
86833: EMPTY
86834: LIST
86835: LIST
86836: PUSH
86837: LD_INT 3
86839: PUSH
86840: LD_INT 4
86842: PUSH
86843: EMPTY
86844: LIST
86845: LIST
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: LIST
86851: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
86852: LD_ADDR_VAR 0 26
86856: PUSH
86857: LD_INT 0
86859: PUSH
86860: LD_INT 3
86862: PUSH
86863: EMPTY
86864: LIST
86865: LIST
86866: PUSH
86867: LD_INT 1
86869: PUSH
86870: LD_INT 4
86872: PUSH
86873: EMPTY
86874: LIST
86875: LIST
86876: PUSH
86877: LD_INT 1
86879: NEG
86880: PUSH
86881: LD_INT 3
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: EMPTY
86889: LIST
86890: LIST
86891: LIST
86892: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
86893: LD_ADDR_VAR 0 27
86897: PUSH
86898: LD_INT 3
86900: NEG
86901: PUSH
86902: LD_INT 0
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: LD_INT 3
86911: NEG
86912: PUSH
86913: LD_INT 1
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 4
86922: NEG
86923: PUSH
86924: LD_INT 1
86926: NEG
86927: PUSH
86928: EMPTY
86929: LIST
86930: LIST
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: LIST
86936: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
86937: LD_ADDR_VAR 0 28
86941: PUSH
86942: LD_INT 3
86944: NEG
86945: PUSH
86946: LD_INT 3
86948: NEG
86949: PUSH
86950: EMPTY
86951: LIST
86952: LIST
86953: PUSH
86954: LD_INT 3
86956: NEG
86957: PUSH
86958: LD_INT 4
86960: NEG
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 4
86968: NEG
86969: PUSH
86970: LD_INT 3
86972: NEG
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: LIST
86982: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
86983: LD_ADDR_VAR 0 29
86987: PUSH
86988: LD_INT 1
86990: NEG
86991: PUSH
86992: LD_INT 3
86994: NEG
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 0
87002: PUSH
87003: LD_INT 3
87005: NEG
87006: PUSH
87007: EMPTY
87008: LIST
87009: LIST
87010: PUSH
87011: LD_INT 1
87013: PUSH
87014: LD_INT 2
87016: NEG
87017: PUSH
87018: EMPTY
87019: LIST
87020: LIST
87021: PUSH
87022: LD_INT 1
87024: NEG
87025: PUSH
87026: LD_INT 4
87028: NEG
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 0
87036: PUSH
87037: LD_INT 4
87039: NEG
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 1
87047: PUSH
87048: LD_INT 3
87050: NEG
87051: PUSH
87052: EMPTY
87053: LIST
87054: LIST
87055: PUSH
87056: LD_INT 1
87058: NEG
87059: PUSH
87060: LD_INT 5
87062: NEG
87063: PUSH
87064: EMPTY
87065: LIST
87066: LIST
87067: PUSH
87068: LD_INT 0
87070: PUSH
87071: LD_INT 5
87073: NEG
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 1
87081: PUSH
87082: LD_INT 4
87084: NEG
87085: PUSH
87086: EMPTY
87087: LIST
87088: LIST
87089: PUSH
87090: LD_INT 1
87092: NEG
87093: PUSH
87094: LD_INT 6
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 0
87104: PUSH
87105: LD_INT 6
87107: NEG
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 1
87115: PUSH
87116: LD_INT 5
87118: NEG
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: EMPTY
87125: LIST
87126: LIST
87127: LIST
87128: LIST
87129: LIST
87130: LIST
87131: LIST
87132: LIST
87133: LIST
87134: LIST
87135: LIST
87136: LIST
87137: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
87138: LD_ADDR_VAR 0 30
87142: PUSH
87143: LD_INT 2
87145: PUSH
87146: LD_INT 1
87148: NEG
87149: PUSH
87150: EMPTY
87151: LIST
87152: LIST
87153: PUSH
87154: LD_INT 3
87156: PUSH
87157: LD_INT 0
87159: PUSH
87160: EMPTY
87161: LIST
87162: LIST
87163: PUSH
87164: LD_INT 3
87166: PUSH
87167: LD_INT 1
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 3
87176: PUSH
87177: LD_INT 1
87179: NEG
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 4
87187: PUSH
87188: LD_INT 0
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 4
87197: PUSH
87198: LD_INT 1
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 4
87207: PUSH
87208: LD_INT 1
87210: NEG
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 5
87218: PUSH
87219: LD_INT 0
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 5
87228: PUSH
87229: LD_INT 1
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 5
87238: PUSH
87239: LD_INT 1
87241: NEG
87242: PUSH
87243: EMPTY
87244: LIST
87245: LIST
87246: PUSH
87247: LD_INT 6
87249: PUSH
87250: LD_INT 0
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 6
87259: PUSH
87260: LD_INT 1
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: EMPTY
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
87281: LD_ADDR_VAR 0 31
87285: PUSH
87286: LD_INT 3
87288: PUSH
87289: LD_INT 2
87291: PUSH
87292: EMPTY
87293: LIST
87294: LIST
87295: PUSH
87296: LD_INT 3
87298: PUSH
87299: LD_INT 3
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 2
87308: PUSH
87309: LD_INT 3
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 4
87318: PUSH
87319: LD_INT 3
87321: PUSH
87322: EMPTY
87323: LIST
87324: LIST
87325: PUSH
87326: LD_INT 4
87328: PUSH
87329: LD_INT 4
87331: PUSH
87332: EMPTY
87333: LIST
87334: LIST
87335: PUSH
87336: LD_INT 3
87338: PUSH
87339: LD_INT 4
87341: PUSH
87342: EMPTY
87343: LIST
87344: LIST
87345: PUSH
87346: LD_INT 5
87348: PUSH
87349: LD_INT 4
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PUSH
87356: LD_INT 5
87358: PUSH
87359: LD_INT 5
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 4
87368: PUSH
87369: LD_INT 5
87371: PUSH
87372: EMPTY
87373: LIST
87374: LIST
87375: PUSH
87376: LD_INT 6
87378: PUSH
87379: LD_INT 5
87381: PUSH
87382: EMPTY
87383: LIST
87384: LIST
87385: PUSH
87386: LD_INT 6
87388: PUSH
87389: LD_INT 6
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 5
87398: PUSH
87399: LD_INT 6
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
87420: LD_ADDR_VAR 0 32
87424: PUSH
87425: LD_INT 1
87427: PUSH
87428: LD_INT 3
87430: PUSH
87431: EMPTY
87432: LIST
87433: LIST
87434: PUSH
87435: LD_INT 0
87437: PUSH
87438: LD_INT 3
87440: PUSH
87441: EMPTY
87442: LIST
87443: LIST
87444: PUSH
87445: LD_INT 1
87447: NEG
87448: PUSH
87449: LD_INT 2
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 1
87458: PUSH
87459: LD_INT 4
87461: PUSH
87462: EMPTY
87463: LIST
87464: LIST
87465: PUSH
87466: LD_INT 0
87468: PUSH
87469: LD_INT 4
87471: PUSH
87472: EMPTY
87473: LIST
87474: LIST
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: LD_INT 3
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: LD_INT 1
87489: PUSH
87490: LD_INT 5
87492: PUSH
87493: EMPTY
87494: LIST
87495: LIST
87496: PUSH
87497: LD_INT 0
87499: PUSH
87500: LD_INT 5
87502: PUSH
87503: EMPTY
87504: LIST
87505: LIST
87506: PUSH
87507: LD_INT 1
87509: NEG
87510: PUSH
87511: LD_INT 4
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 1
87520: PUSH
87521: LD_INT 6
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 0
87530: PUSH
87531: LD_INT 6
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 1
87540: NEG
87541: PUSH
87542: LD_INT 5
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: LIST
87562: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
87563: LD_ADDR_VAR 0 33
87567: PUSH
87568: LD_INT 2
87570: NEG
87571: PUSH
87572: LD_INT 1
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 3
87581: NEG
87582: PUSH
87583: LD_INT 0
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 3
87592: NEG
87593: PUSH
87594: LD_INT 1
87596: NEG
87597: PUSH
87598: EMPTY
87599: LIST
87600: LIST
87601: PUSH
87602: LD_INT 3
87604: NEG
87605: PUSH
87606: LD_INT 1
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 4
87615: NEG
87616: PUSH
87617: LD_INT 0
87619: PUSH
87620: EMPTY
87621: LIST
87622: LIST
87623: PUSH
87624: LD_INT 4
87626: NEG
87627: PUSH
87628: LD_INT 1
87630: NEG
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 4
87638: NEG
87639: PUSH
87640: LD_INT 1
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 5
87649: NEG
87650: PUSH
87651: LD_INT 0
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 5
87660: NEG
87661: PUSH
87662: LD_INT 1
87664: NEG
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 5
87672: NEG
87673: PUSH
87674: LD_INT 1
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 6
87683: NEG
87684: PUSH
87685: LD_INT 0
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 6
87694: NEG
87695: PUSH
87696: LD_INT 1
87698: NEG
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: EMPTY
87705: LIST
87706: LIST
87707: LIST
87708: LIST
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
87718: LD_ADDR_VAR 0 34
87722: PUSH
87723: LD_INT 2
87725: NEG
87726: PUSH
87727: LD_INT 3
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 3
87737: NEG
87738: PUSH
87739: LD_INT 2
87741: NEG
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: PUSH
87747: LD_INT 3
87749: NEG
87750: PUSH
87751: LD_INT 3
87753: NEG
87754: PUSH
87755: EMPTY
87756: LIST
87757: LIST
87758: PUSH
87759: LD_INT 3
87761: NEG
87762: PUSH
87763: LD_INT 4
87765: NEG
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 4
87773: NEG
87774: PUSH
87775: LD_INT 3
87777: NEG
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 4
87785: NEG
87786: PUSH
87787: LD_INT 4
87789: NEG
87790: PUSH
87791: EMPTY
87792: LIST
87793: LIST
87794: PUSH
87795: LD_INT 4
87797: NEG
87798: PUSH
87799: LD_INT 5
87801: NEG
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 5
87809: NEG
87810: PUSH
87811: LD_INT 4
87813: NEG
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 5
87821: NEG
87822: PUSH
87823: LD_INT 5
87825: NEG
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 5
87833: NEG
87834: PUSH
87835: LD_INT 6
87837: NEG
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 6
87845: NEG
87846: PUSH
87847: LD_INT 5
87849: NEG
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 6
87857: NEG
87858: PUSH
87859: LD_INT 6
87861: NEG
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
87881: LD_ADDR_VAR 0 41
87885: PUSH
87886: LD_INT 0
87888: PUSH
87889: LD_INT 2
87891: NEG
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 1
87899: NEG
87900: PUSH
87901: LD_INT 3
87903: NEG
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 1
87911: PUSH
87912: LD_INT 2
87914: NEG
87915: PUSH
87916: EMPTY
87917: LIST
87918: LIST
87919: PUSH
87920: EMPTY
87921: LIST
87922: LIST
87923: LIST
87924: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
87925: LD_ADDR_VAR 0 42
87929: PUSH
87930: LD_INT 2
87932: PUSH
87933: LD_INT 0
87935: PUSH
87936: EMPTY
87937: LIST
87938: LIST
87939: PUSH
87940: LD_INT 2
87942: PUSH
87943: LD_INT 1
87945: NEG
87946: PUSH
87947: EMPTY
87948: LIST
87949: LIST
87950: PUSH
87951: LD_INT 3
87953: PUSH
87954: LD_INT 1
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: EMPTY
87962: LIST
87963: LIST
87964: LIST
87965: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
87966: LD_ADDR_VAR 0 43
87970: PUSH
87971: LD_INT 2
87973: PUSH
87974: LD_INT 2
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: PUSH
87981: LD_INT 3
87983: PUSH
87984: LD_INT 2
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: PUSH
87991: LD_INT 2
87993: PUSH
87994: LD_INT 3
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
88006: LD_ADDR_VAR 0 44
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: LD_INT 2
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 1
88023: PUSH
88024: LD_INT 3
88026: PUSH
88027: EMPTY
88028: LIST
88029: LIST
88030: PUSH
88031: LD_INT 1
88033: NEG
88034: PUSH
88035: LD_INT 2
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: LIST
88046: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88047: LD_ADDR_VAR 0 45
88051: PUSH
88052: LD_INT 2
88054: NEG
88055: PUSH
88056: LD_INT 0
88058: PUSH
88059: EMPTY
88060: LIST
88061: LIST
88062: PUSH
88063: LD_INT 2
88065: NEG
88066: PUSH
88067: LD_INT 1
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 3
88076: NEG
88077: PUSH
88078: LD_INT 1
88080: NEG
88081: PUSH
88082: EMPTY
88083: LIST
88084: LIST
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: LIST
88090: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
88091: LD_ADDR_VAR 0 46
88095: PUSH
88096: LD_INT 2
88098: NEG
88099: PUSH
88100: LD_INT 2
88102: NEG
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 2
88110: NEG
88111: PUSH
88112: LD_INT 3
88114: NEG
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 3
88122: NEG
88123: PUSH
88124: LD_INT 2
88126: NEG
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: LIST
88136: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
88137: LD_ADDR_VAR 0 47
88141: PUSH
88142: LD_INT 2
88144: NEG
88145: PUSH
88146: LD_INT 3
88148: NEG
88149: PUSH
88150: EMPTY
88151: LIST
88152: LIST
88153: PUSH
88154: LD_INT 1
88156: NEG
88157: PUSH
88158: LD_INT 3
88160: NEG
88161: PUSH
88162: EMPTY
88163: LIST
88164: LIST
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88170: LD_ADDR_VAR 0 48
88174: PUSH
88175: LD_INT 1
88177: PUSH
88178: LD_INT 2
88180: NEG
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: LD_INT 2
88188: PUSH
88189: LD_INT 1
88191: NEG
88192: PUSH
88193: EMPTY
88194: LIST
88195: LIST
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
88201: LD_ADDR_VAR 0 49
88205: PUSH
88206: LD_INT 3
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: EMPTY
88213: LIST
88214: LIST
88215: PUSH
88216: LD_INT 3
88218: PUSH
88219: LD_INT 2
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: EMPTY
88227: LIST
88228: LIST
88229: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
88230: LD_ADDR_VAR 0 50
88234: PUSH
88235: LD_INT 2
88237: PUSH
88238: LD_INT 3
88240: PUSH
88241: EMPTY
88242: LIST
88243: LIST
88244: PUSH
88245: LD_INT 1
88247: PUSH
88248: LD_INT 3
88250: PUSH
88251: EMPTY
88252: LIST
88253: LIST
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
88259: LD_ADDR_VAR 0 51
88263: PUSH
88264: LD_INT 1
88266: NEG
88267: PUSH
88268: LD_INT 2
88270: PUSH
88271: EMPTY
88272: LIST
88273: LIST
88274: PUSH
88275: LD_INT 2
88277: NEG
88278: PUSH
88279: LD_INT 1
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
88290: LD_ADDR_VAR 0 52
88294: PUSH
88295: LD_INT 3
88297: NEG
88298: PUSH
88299: LD_INT 1
88301: NEG
88302: PUSH
88303: EMPTY
88304: LIST
88305: LIST
88306: PUSH
88307: LD_INT 3
88309: NEG
88310: PUSH
88311: LD_INT 2
88313: NEG
88314: PUSH
88315: EMPTY
88316: LIST
88317: LIST
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
88323: LD_ADDR_VAR 0 53
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: PUSH
88332: LD_INT 3
88334: NEG
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 0
88342: PUSH
88343: LD_INT 3
88345: NEG
88346: PUSH
88347: EMPTY
88348: LIST
88349: LIST
88350: PUSH
88351: LD_INT 1
88353: PUSH
88354: LD_INT 2
88356: NEG
88357: PUSH
88358: EMPTY
88359: LIST
88360: LIST
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: LIST
88366: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
88367: LD_ADDR_VAR 0 54
88371: PUSH
88372: LD_INT 2
88374: PUSH
88375: LD_INT 1
88377: NEG
88378: PUSH
88379: EMPTY
88380: LIST
88381: LIST
88382: PUSH
88383: LD_INT 3
88385: PUSH
88386: LD_INT 0
88388: PUSH
88389: EMPTY
88390: LIST
88391: LIST
88392: PUSH
88393: LD_INT 3
88395: PUSH
88396: LD_INT 1
88398: PUSH
88399: EMPTY
88400: LIST
88401: LIST
88402: PUSH
88403: EMPTY
88404: LIST
88405: LIST
88406: LIST
88407: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
88408: LD_ADDR_VAR 0 55
88412: PUSH
88413: LD_INT 3
88415: PUSH
88416: LD_INT 2
88418: PUSH
88419: EMPTY
88420: LIST
88421: LIST
88422: PUSH
88423: LD_INT 3
88425: PUSH
88426: LD_INT 3
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 2
88435: PUSH
88436: LD_INT 3
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: LIST
88447: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
88448: LD_ADDR_VAR 0 56
88452: PUSH
88453: LD_INT 1
88455: PUSH
88456: LD_INT 3
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 0
88465: PUSH
88466: LD_INT 3
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 1
88475: NEG
88476: PUSH
88477: LD_INT 2
88479: PUSH
88480: EMPTY
88481: LIST
88482: LIST
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: LIST
88488: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88489: LD_ADDR_VAR 0 57
88493: PUSH
88494: LD_INT 2
88496: NEG
88497: PUSH
88498: LD_INT 1
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 3
88507: NEG
88508: PUSH
88509: LD_INT 0
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 3
88518: NEG
88519: PUSH
88520: LD_INT 1
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: LIST
88532: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88533: LD_ADDR_VAR 0 58
88537: PUSH
88538: LD_INT 2
88540: NEG
88541: PUSH
88542: LD_INT 3
88544: NEG
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 3
88552: NEG
88553: PUSH
88554: LD_INT 2
88556: NEG
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 3
88564: NEG
88565: PUSH
88566: LD_INT 3
88568: NEG
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: EMPTY
88575: LIST
88576: LIST
88577: LIST
88578: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
88579: LD_ADDR_VAR 0 59
88583: PUSH
88584: LD_INT 1
88586: NEG
88587: PUSH
88588: LD_INT 2
88590: NEG
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PUSH
88596: LD_INT 0
88598: PUSH
88599: LD_INT 2
88601: NEG
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: PUSH
88610: LD_INT 1
88612: NEG
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: LIST
88622: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88623: LD_ADDR_VAR 0 60
88627: PUSH
88628: LD_INT 1
88630: PUSH
88631: LD_INT 1
88633: NEG
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 2
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 2
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: LIST
88663: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88664: LD_ADDR_VAR 0 61
88668: PUSH
88669: LD_INT 2
88671: PUSH
88672: LD_INT 1
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: PUSH
88679: LD_INT 2
88681: PUSH
88682: LD_INT 2
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 1
88691: PUSH
88692: LD_INT 2
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: EMPTY
88700: LIST
88701: LIST
88702: LIST
88703: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88704: LD_ADDR_VAR 0 62
88708: PUSH
88709: LD_INT 1
88711: PUSH
88712: LD_INT 2
88714: PUSH
88715: EMPTY
88716: LIST
88717: LIST
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: LD_INT 2
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 1
88731: NEG
88732: PUSH
88733: LD_INT 1
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: PUSH
88740: EMPTY
88741: LIST
88742: LIST
88743: LIST
88744: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88745: LD_ADDR_VAR 0 63
88749: PUSH
88750: LD_INT 1
88752: NEG
88753: PUSH
88754: LD_INT 1
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: PUSH
88761: LD_INT 2
88763: NEG
88764: PUSH
88765: LD_INT 0
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 2
88774: NEG
88775: PUSH
88776: LD_INT 1
88778: NEG
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: EMPTY
88785: LIST
88786: LIST
88787: LIST
88788: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88789: LD_ADDR_VAR 0 64
88793: PUSH
88794: LD_INT 1
88796: NEG
88797: PUSH
88798: LD_INT 2
88800: NEG
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: LD_INT 2
88808: NEG
88809: PUSH
88810: LD_INT 1
88812: NEG
88813: PUSH
88814: EMPTY
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 2
88820: NEG
88821: PUSH
88822: LD_INT 2
88824: NEG
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: EMPTY
88831: LIST
88832: LIST
88833: LIST
88834: ST_TO_ADDR
// end ; 2 :
88835: GO 92101
88837: LD_INT 2
88839: DOUBLE
88840: EQUAL
88841: IFTRUE 88845
88843: GO 92100
88845: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
88846: LD_ADDR_VAR 0 29
88850: PUSH
88851: LD_INT 4
88853: PUSH
88854: LD_INT 0
88856: PUSH
88857: EMPTY
88858: LIST
88859: LIST
88860: PUSH
88861: LD_INT 4
88863: PUSH
88864: LD_INT 1
88866: NEG
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 5
88874: PUSH
88875: LD_INT 0
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: LD_INT 5
88884: PUSH
88885: LD_INT 1
88887: PUSH
88888: EMPTY
88889: LIST
88890: LIST
88891: PUSH
88892: LD_INT 4
88894: PUSH
88895: LD_INT 1
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: LD_INT 3
88904: PUSH
88905: LD_INT 0
88907: PUSH
88908: EMPTY
88909: LIST
88910: LIST
88911: PUSH
88912: LD_INT 3
88914: PUSH
88915: LD_INT 1
88917: NEG
88918: PUSH
88919: EMPTY
88920: LIST
88921: LIST
88922: PUSH
88923: LD_INT 3
88925: PUSH
88926: LD_INT 2
88928: NEG
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 5
88936: PUSH
88937: LD_INT 2
88939: PUSH
88940: EMPTY
88941: LIST
88942: LIST
88943: PUSH
88944: LD_INT 3
88946: PUSH
88947: LD_INT 3
88949: PUSH
88950: EMPTY
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 3
88956: PUSH
88957: LD_INT 2
88959: PUSH
88960: EMPTY
88961: LIST
88962: LIST
88963: PUSH
88964: LD_INT 4
88966: PUSH
88967: LD_INT 3
88969: PUSH
88970: EMPTY
88971: LIST
88972: LIST
88973: PUSH
88974: LD_INT 4
88976: PUSH
88977: LD_INT 4
88979: PUSH
88980: EMPTY
88981: LIST
88982: LIST
88983: PUSH
88984: LD_INT 3
88986: PUSH
88987: LD_INT 4
88989: PUSH
88990: EMPTY
88991: LIST
88992: LIST
88993: PUSH
88994: LD_INT 2
88996: PUSH
88997: LD_INT 3
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: PUSH
89004: LD_INT 2
89006: PUSH
89007: LD_INT 2
89009: PUSH
89010: EMPTY
89011: LIST
89012: LIST
89013: PUSH
89014: LD_INT 4
89016: PUSH
89017: LD_INT 2
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: LD_INT 2
89026: PUSH
89027: LD_INT 4
89029: PUSH
89030: EMPTY
89031: LIST
89032: LIST
89033: PUSH
89034: LD_INT 0
89036: PUSH
89037: LD_INT 4
89039: PUSH
89040: EMPTY
89041: LIST
89042: LIST
89043: PUSH
89044: LD_INT 0
89046: PUSH
89047: LD_INT 3
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: PUSH
89054: LD_INT 1
89056: PUSH
89057: LD_INT 4
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 1
89066: PUSH
89067: LD_INT 5
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: LD_INT 0
89076: PUSH
89077: LD_INT 5
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 1
89086: NEG
89087: PUSH
89088: LD_INT 4
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: NEG
89098: PUSH
89099: LD_INT 3
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 2
89108: PUSH
89109: LD_INT 5
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 2
89118: NEG
89119: PUSH
89120: LD_INT 3
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 3
89129: NEG
89130: PUSH
89131: LD_INT 0
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: LD_INT 3
89140: NEG
89141: PUSH
89142: LD_INT 1
89144: NEG
89145: PUSH
89146: EMPTY
89147: LIST
89148: LIST
89149: PUSH
89150: LD_INT 2
89152: NEG
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 2
89163: NEG
89164: PUSH
89165: LD_INT 1
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 3
89174: NEG
89175: PUSH
89176: LD_INT 1
89178: PUSH
89179: EMPTY
89180: LIST
89181: LIST
89182: PUSH
89183: LD_INT 4
89185: NEG
89186: PUSH
89187: LD_INT 0
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: PUSH
89194: LD_INT 4
89196: NEG
89197: PUSH
89198: LD_INT 1
89200: NEG
89201: PUSH
89202: EMPTY
89203: LIST
89204: LIST
89205: PUSH
89206: LD_INT 4
89208: NEG
89209: PUSH
89210: LD_INT 2
89212: NEG
89213: PUSH
89214: EMPTY
89215: LIST
89216: LIST
89217: PUSH
89218: LD_INT 2
89220: NEG
89221: PUSH
89222: LD_INT 2
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 4
89231: NEG
89232: PUSH
89233: LD_INT 4
89235: NEG
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 4
89243: NEG
89244: PUSH
89245: LD_INT 5
89247: NEG
89248: PUSH
89249: EMPTY
89250: LIST
89251: LIST
89252: PUSH
89253: LD_INT 3
89255: NEG
89256: PUSH
89257: LD_INT 4
89259: NEG
89260: PUSH
89261: EMPTY
89262: LIST
89263: LIST
89264: PUSH
89265: LD_INT 3
89267: NEG
89268: PUSH
89269: LD_INT 3
89271: NEG
89272: PUSH
89273: EMPTY
89274: LIST
89275: LIST
89276: PUSH
89277: LD_INT 4
89279: NEG
89280: PUSH
89281: LD_INT 3
89283: NEG
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 5
89291: NEG
89292: PUSH
89293: LD_INT 4
89295: NEG
89296: PUSH
89297: EMPTY
89298: LIST
89299: LIST
89300: PUSH
89301: LD_INT 5
89303: NEG
89304: PUSH
89305: LD_INT 5
89307: NEG
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 3
89315: NEG
89316: PUSH
89317: LD_INT 5
89319: NEG
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: PUSH
89325: LD_INT 5
89327: NEG
89328: PUSH
89329: LD_INT 3
89331: NEG
89332: PUSH
89333: EMPTY
89334: LIST
89335: LIST
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: LIST
89376: LIST
89377: LIST
89378: LIST
89379: LIST
89380: LIST
89381: LIST
89382: LIST
89383: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
89384: LD_ADDR_VAR 0 30
89388: PUSH
89389: LD_INT 4
89391: PUSH
89392: LD_INT 4
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 4
89401: PUSH
89402: LD_INT 3
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 5
89411: PUSH
89412: LD_INT 4
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 5
89421: PUSH
89422: LD_INT 5
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 4
89431: PUSH
89432: LD_INT 5
89434: PUSH
89435: EMPTY
89436: LIST
89437: LIST
89438: PUSH
89439: LD_INT 3
89441: PUSH
89442: LD_INT 4
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 3
89451: PUSH
89452: LD_INT 3
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 5
89461: PUSH
89462: LD_INT 3
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 3
89471: PUSH
89472: LD_INT 5
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 0
89481: PUSH
89482: LD_INT 3
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 1
89501: PUSH
89502: LD_INT 3
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 1
89511: PUSH
89512: LD_INT 4
89514: PUSH
89515: EMPTY
89516: LIST
89517: LIST
89518: PUSH
89519: LD_INT 0
89521: PUSH
89522: LD_INT 4
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 1
89531: NEG
89532: PUSH
89533: LD_INT 3
89535: PUSH
89536: EMPTY
89537: LIST
89538: LIST
89539: PUSH
89540: LD_INT 1
89542: NEG
89543: PUSH
89544: LD_INT 2
89546: PUSH
89547: EMPTY
89548: LIST
89549: LIST
89550: PUSH
89551: LD_INT 2
89553: PUSH
89554: LD_INT 4
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 2
89563: NEG
89564: PUSH
89565: LD_INT 2
89567: PUSH
89568: EMPTY
89569: LIST
89570: LIST
89571: PUSH
89572: LD_INT 4
89574: NEG
89575: PUSH
89576: LD_INT 0
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: PUSH
89583: LD_INT 4
89585: NEG
89586: PUSH
89587: LD_INT 1
89589: NEG
89590: PUSH
89591: EMPTY
89592: LIST
89593: LIST
89594: PUSH
89595: LD_INT 3
89597: NEG
89598: PUSH
89599: LD_INT 0
89601: PUSH
89602: EMPTY
89603: LIST
89604: LIST
89605: PUSH
89606: LD_INT 3
89608: NEG
89609: PUSH
89610: LD_INT 1
89612: PUSH
89613: EMPTY
89614: LIST
89615: LIST
89616: PUSH
89617: LD_INT 4
89619: NEG
89620: PUSH
89621: LD_INT 1
89623: PUSH
89624: EMPTY
89625: LIST
89626: LIST
89627: PUSH
89628: LD_INT 5
89630: NEG
89631: PUSH
89632: LD_INT 0
89634: PUSH
89635: EMPTY
89636: LIST
89637: LIST
89638: PUSH
89639: LD_INT 5
89641: NEG
89642: PUSH
89643: LD_INT 1
89645: NEG
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: PUSH
89651: LD_INT 5
89653: NEG
89654: PUSH
89655: LD_INT 2
89657: NEG
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 3
89665: NEG
89666: PUSH
89667: LD_INT 2
89669: PUSH
89670: EMPTY
89671: LIST
89672: LIST
89673: PUSH
89674: LD_INT 3
89676: NEG
89677: PUSH
89678: LD_INT 3
89680: NEG
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 3
89688: NEG
89689: PUSH
89690: LD_INT 4
89692: NEG
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: NEG
89701: PUSH
89702: LD_INT 3
89704: NEG
89705: PUSH
89706: EMPTY
89707: LIST
89708: LIST
89709: PUSH
89710: LD_INT 2
89712: NEG
89713: PUSH
89714: LD_INT 2
89716: NEG
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 3
89724: NEG
89725: PUSH
89726: LD_INT 2
89728: NEG
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: LD_INT 4
89736: NEG
89737: PUSH
89738: LD_INT 3
89740: NEG
89741: PUSH
89742: EMPTY
89743: LIST
89744: LIST
89745: PUSH
89746: LD_INT 4
89748: NEG
89749: PUSH
89750: LD_INT 4
89752: NEG
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 2
89760: NEG
89761: PUSH
89762: LD_INT 4
89764: NEG
89765: PUSH
89766: EMPTY
89767: LIST
89768: LIST
89769: PUSH
89770: LD_INT 4
89772: NEG
89773: PUSH
89774: LD_INT 2
89776: NEG
89777: PUSH
89778: EMPTY
89779: LIST
89780: LIST
89781: PUSH
89782: LD_INT 0
89784: PUSH
89785: LD_INT 4
89787: NEG
89788: PUSH
89789: EMPTY
89790: LIST
89791: LIST
89792: PUSH
89793: LD_INT 0
89795: PUSH
89796: LD_INT 5
89798: NEG
89799: PUSH
89800: EMPTY
89801: LIST
89802: LIST
89803: PUSH
89804: LD_INT 1
89806: PUSH
89807: LD_INT 4
89809: NEG
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: LD_INT 1
89817: PUSH
89818: LD_INT 3
89820: NEG
89821: PUSH
89822: EMPTY
89823: LIST
89824: LIST
89825: PUSH
89826: LD_INT 0
89828: PUSH
89829: LD_INT 3
89831: NEG
89832: PUSH
89833: EMPTY
89834: LIST
89835: LIST
89836: PUSH
89837: LD_INT 1
89839: NEG
89840: PUSH
89841: LD_INT 4
89843: NEG
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 1
89851: NEG
89852: PUSH
89853: LD_INT 5
89855: NEG
89856: PUSH
89857: EMPTY
89858: LIST
89859: LIST
89860: PUSH
89861: LD_INT 2
89863: PUSH
89864: LD_INT 3
89866: NEG
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 2
89874: NEG
89875: PUSH
89876: LD_INT 5
89878: NEG
89879: PUSH
89880: EMPTY
89881: LIST
89882: LIST
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: LIST
89914: LIST
89915: LIST
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
89931: LD_ADDR_VAR 0 31
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: LD_INT 4
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 0
89948: PUSH
89949: LD_INT 3
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: LD_INT 4
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 1
89968: PUSH
89969: LD_INT 5
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 0
89978: PUSH
89979: LD_INT 5
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 1
89988: NEG
89989: PUSH
89990: LD_INT 4
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 1
89999: NEG
90000: PUSH
90001: LD_INT 3
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 2
90010: PUSH
90011: LD_INT 5
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: PUSH
90018: LD_INT 2
90020: NEG
90021: PUSH
90022: LD_INT 3
90024: PUSH
90025: EMPTY
90026: LIST
90027: LIST
90028: PUSH
90029: LD_INT 3
90031: NEG
90032: PUSH
90033: LD_INT 0
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 3
90042: NEG
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 2
90054: NEG
90055: PUSH
90056: LD_INT 0
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: LD_INT 2
90065: NEG
90066: PUSH
90067: LD_INT 1
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 3
90076: NEG
90077: PUSH
90078: LD_INT 1
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: PUSH
90085: LD_INT 4
90087: NEG
90088: PUSH
90089: LD_INT 0
90091: PUSH
90092: EMPTY
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 4
90098: NEG
90099: PUSH
90100: LD_INT 1
90102: NEG
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 4
90110: NEG
90111: PUSH
90112: LD_INT 2
90114: NEG
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 2
90122: NEG
90123: PUSH
90124: LD_INT 2
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 4
90133: NEG
90134: PUSH
90135: LD_INT 4
90137: NEG
90138: PUSH
90139: EMPTY
90140: LIST
90141: LIST
90142: PUSH
90143: LD_INT 4
90145: NEG
90146: PUSH
90147: LD_INT 5
90149: NEG
90150: PUSH
90151: EMPTY
90152: LIST
90153: LIST
90154: PUSH
90155: LD_INT 3
90157: NEG
90158: PUSH
90159: LD_INT 4
90161: NEG
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 3
90169: NEG
90170: PUSH
90171: LD_INT 3
90173: NEG
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 4
90181: NEG
90182: PUSH
90183: LD_INT 3
90185: NEG
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: PUSH
90191: LD_INT 5
90193: NEG
90194: PUSH
90195: LD_INT 4
90197: NEG
90198: PUSH
90199: EMPTY
90200: LIST
90201: LIST
90202: PUSH
90203: LD_INT 5
90205: NEG
90206: PUSH
90207: LD_INT 5
90209: NEG
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: PUSH
90215: LD_INT 3
90217: NEG
90218: PUSH
90219: LD_INT 5
90221: NEG
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: LD_INT 5
90229: NEG
90230: PUSH
90231: LD_INT 3
90233: NEG
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: PUSH
90239: LD_INT 0
90241: PUSH
90242: LD_INT 3
90244: NEG
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: PUSH
90250: LD_INT 0
90252: PUSH
90253: LD_INT 4
90255: NEG
90256: PUSH
90257: EMPTY
90258: LIST
90259: LIST
90260: PUSH
90261: LD_INT 1
90263: PUSH
90264: LD_INT 3
90266: NEG
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: PUSH
90272: LD_INT 1
90274: PUSH
90275: LD_INT 2
90277: NEG
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: PUSH
90283: LD_INT 0
90285: PUSH
90286: LD_INT 2
90288: NEG
90289: PUSH
90290: EMPTY
90291: LIST
90292: LIST
90293: PUSH
90294: LD_INT 1
90296: NEG
90297: PUSH
90298: LD_INT 3
90300: NEG
90301: PUSH
90302: EMPTY
90303: LIST
90304: LIST
90305: PUSH
90306: LD_INT 1
90308: NEG
90309: PUSH
90310: LD_INT 4
90312: NEG
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 2
90320: PUSH
90321: LD_INT 2
90323: NEG
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 2
90331: NEG
90332: PUSH
90333: LD_INT 4
90335: NEG
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 4
90343: PUSH
90344: LD_INT 0
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 4
90353: PUSH
90354: LD_INT 1
90356: NEG
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: PUSH
90362: LD_INT 5
90364: PUSH
90365: LD_INT 0
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: PUSH
90372: LD_INT 5
90374: PUSH
90375: LD_INT 1
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: PUSH
90382: LD_INT 4
90384: PUSH
90385: LD_INT 1
90387: PUSH
90388: EMPTY
90389: LIST
90390: LIST
90391: PUSH
90392: LD_INT 3
90394: PUSH
90395: LD_INT 0
90397: PUSH
90398: EMPTY
90399: LIST
90400: LIST
90401: PUSH
90402: LD_INT 3
90404: PUSH
90405: LD_INT 1
90407: NEG
90408: PUSH
90409: EMPTY
90410: LIST
90411: LIST
90412: PUSH
90413: LD_INT 3
90415: PUSH
90416: LD_INT 2
90418: NEG
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 5
90426: PUSH
90427: LD_INT 2
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: EMPTY
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
90481: LD_ADDR_VAR 0 32
90485: PUSH
90486: LD_INT 4
90488: NEG
90489: PUSH
90490: LD_INT 0
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: LD_INT 4
90499: NEG
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 3
90511: NEG
90512: PUSH
90513: LD_INT 0
90515: PUSH
90516: EMPTY
90517: LIST
90518: LIST
90519: PUSH
90520: LD_INT 3
90522: NEG
90523: PUSH
90524: LD_INT 1
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: PUSH
90531: LD_INT 4
90533: NEG
90534: PUSH
90535: LD_INT 1
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 5
90544: NEG
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 5
90555: NEG
90556: PUSH
90557: LD_INT 1
90559: NEG
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: LD_INT 5
90567: NEG
90568: PUSH
90569: LD_INT 2
90571: NEG
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 3
90579: NEG
90580: PUSH
90581: LD_INT 2
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 3
90590: NEG
90591: PUSH
90592: LD_INT 3
90594: NEG
90595: PUSH
90596: EMPTY
90597: LIST
90598: LIST
90599: PUSH
90600: LD_INT 3
90602: NEG
90603: PUSH
90604: LD_INT 4
90606: NEG
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PUSH
90612: LD_INT 2
90614: NEG
90615: PUSH
90616: LD_INT 3
90618: NEG
90619: PUSH
90620: EMPTY
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 2
90626: NEG
90627: PUSH
90628: LD_INT 2
90630: NEG
90631: PUSH
90632: EMPTY
90633: LIST
90634: LIST
90635: PUSH
90636: LD_INT 3
90638: NEG
90639: PUSH
90640: LD_INT 2
90642: NEG
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PUSH
90648: LD_INT 4
90650: NEG
90651: PUSH
90652: LD_INT 3
90654: NEG
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 4
90662: NEG
90663: PUSH
90664: LD_INT 4
90666: NEG
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 2
90674: NEG
90675: PUSH
90676: LD_INT 4
90678: NEG
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 4
90686: NEG
90687: PUSH
90688: LD_INT 2
90690: NEG
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 0
90698: PUSH
90699: LD_INT 4
90701: NEG
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: LD_INT 5
90712: NEG
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: LD_INT 1
90720: PUSH
90721: LD_INT 4
90723: NEG
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 1
90731: PUSH
90732: LD_INT 3
90734: NEG
90735: PUSH
90736: EMPTY
90737: LIST
90738: LIST
90739: PUSH
90740: LD_INT 0
90742: PUSH
90743: LD_INT 3
90745: NEG
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 1
90753: NEG
90754: PUSH
90755: LD_INT 4
90757: NEG
90758: PUSH
90759: EMPTY
90760: LIST
90761: LIST
90762: PUSH
90763: LD_INT 1
90765: NEG
90766: PUSH
90767: LD_INT 5
90769: NEG
90770: PUSH
90771: EMPTY
90772: LIST
90773: LIST
90774: PUSH
90775: LD_INT 2
90777: PUSH
90778: LD_INT 3
90780: NEG
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PUSH
90786: LD_INT 2
90788: NEG
90789: PUSH
90790: LD_INT 5
90792: NEG
90793: PUSH
90794: EMPTY
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 3
90800: PUSH
90801: LD_INT 0
90803: PUSH
90804: EMPTY
90805: LIST
90806: LIST
90807: PUSH
90808: LD_INT 3
90810: PUSH
90811: LD_INT 1
90813: NEG
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 4
90821: PUSH
90822: LD_INT 0
90824: PUSH
90825: EMPTY
90826: LIST
90827: LIST
90828: PUSH
90829: LD_INT 4
90831: PUSH
90832: LD_INT 1
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: PUSH
90839: LD_INT 3
90841: PUSH
90842: LD_INT 1
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: PUSH
90849: LD_INT 2
90851: PUSH
90852: LD_INT 0
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 2
90861: PUSH
90862: LD_INT 1
90864: NEG
90865: PUSH
90866: EMPTY
90867: LIST
90868: LIST
90869: PUSH
90870: LD_INT 2
90872: PUSH
90873: LD_INT 2
90875: NEG
90876: PUSH
90877: EMPTY
90878: LIST
90879: LIST
90880: PUSH
90881: LD_INT 4
90883: PUSH
90884: LD_INT 2
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 4
90893: PUSH
90894: LD_INT 4
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 4
90903: PUSH
90904: LD_INT 3
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 5
90913: PUSH
90914: LD_INT 4
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 5
90923: PUSH
90924: LD_INT 5
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 4
90933: PUSH
90934: LD_INT 5
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 3
90943: PUSH
90944: LD_INT 4
90946: PUSH
90947: EMPTY
90948: LIST
90949: LIST
90950: PUSH
90951: LD_INT 3
90953: PUSH
90954: LD_INT 3
90956: PUSH
90957: EMPTY
90958: LIST
90959: LIST
90960: PUSH
90961: LD_INT 5
90963: PUSH
90964: LD_INT 3
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: LD_INT 3
90973: PUSH
90974: LD_INT 5
90976: PUSH
90977: EMPTY
90978: LIST
90979: LIST
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
91028: LD_ADDR_VAR 0 33
91032: PUSH
91033: LD_INT 4
91035: NEG
91036: PUSH
91037: LD_INT 4
91039: NEG
91040: PUSH
91041: EMPTY
91042: LIST
91043: LIST
91044: PUSH
91045: LD_INT 4
91047: NEG
91048: PUSH
91049: LD_INT 5
91051: NEG
91052: PUSH
91053: EMPTY
91054: LIST
91055: LIST
91056: PUSH
91057: LD_INT 3
91059: NEG
91060: PUSH
91061: LD_INT 4
91063: NEG
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: PUSH
91069: LD_INT 3
91071: NEG
91072: PUSH
91073: LD_INT 3
91075: NEG
91076: PUSH
91077: EMPTY
91078: LIST
91079: LIST
91080: PUSH
91081: LD_INT 4
91083: NEG
91084: PUSH
91085: LD_INT 3
91087: NEG
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 5
91095: NEG
91096: PUSH
91097: LD_INT 4
91099: NEG
91100: PUSH
91101: EMPTY
91102: LIST
91103: LIST
91104: PUSH
91105: LD_INT 5
91107: NEG
91108: PUSH
91109: LD_INT 5
91111: NEG
91112: PUSH
91113: EMPTY
91114: LIST
91115: LIST
91116: PUSH
91117: LD_INT 3
91119: NEG
91120: PUSH
91121: LD_INT 5
91123: NEG
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 5
91131: NEG
91132: PUSH
91133: LD_INT 3
91135: NEG
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 0
91143: PUSH
91144: LD_INT 3
91146: NEG
91147: PUSH
91148: EMPTY
91149: LIST
91150: LIST
91151: PUSH
91152: LD_INT 0
91154: PUSH
91155: LD_INT 4
91157: NEG
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 1
91165: PUSH
91166: LD_INT 3
91168: NEG
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: LD_INT 1
91176: PUSH
91177: LD_INT 2
91179: NEG
91180: PUSH
91181: EMPTY
91182: LIST
91183: LIST
91184: PUSH
91185: LD_INT 0
91187: PUSH
91188: LD_INT 2
91190: NEG
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 1
91198: NEG
91199: PUSH
91200: LD_INT 3
91202: NEG
91203: PUSH
91204: EMPTY
91205: LIST
91206: LIST
91207: PUSH
91208: LD_INT 1
91210: NEG
91211: PUSH
91212: LD_INT 4
91214: NEG
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 2
91222: PUSH
91223: LD_INT 2
91225: NEG
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 2
91233: NEG
91234: PUSH
91235: LD_INT 4
91237: NEG
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PUSH
91243: LD_INT 4
91245: PUSH
91246: LD_INT 0
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: LD_INT 4
91255: PUSH
91256: LD_INT 1
91258: NEG
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 5
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 5
91276: PUSH
91277: LD_INT 1
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 4
91286: PUSH
91287: LD_INT 1
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: PUSH
91294: LD_INT 3
91296: PUSH
91297: LD_INT 0
91299: PUSH
91300: EMPTY
91301: LIST
91302: LIST
91303: PUSH
91304: LD_INT 3
91306: PUSH
91307: LD_INT 1
91309: NEG
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 3
91317: PUSH
91318: LD_INT 2
91320: NEG
91321: PUSH
91322: EMPTY
91323: LIST
91324: LIST
91325: PUSH
91326: LD_INT 5
91328: PUSH
91329: LD_INT 2
91331: PUSH
91332: EMPTY
91333: LIST
91334: LIST
91335: PUSH
91336: LD_INT 3
91338: PUSH
91339: LD_INT 3
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: PUSH
91346: LD_INT 3
91348: PUSH
91349: LD_INT 2
91351: PUSH
91352: EMPTY
91353: LIST
91354: LIST
91355: PUSH
91356: LD_INT 4
91358: PUSH
91359: LD_INT 3
91361: PUSH
91362: EMPTY
91363: LIST
91364: LIST
91365: PUSH
91366: LD_INT 4
91368: PUSH
91369: LD_INT 4
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 3
91378: PUSH
91379: LD_INT 4
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 2
91388: PUSH
91389: LD_INT 3
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 2
91398: PUSH
91399: LD_INT 2
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 4
91408: PUSH
91409: LD_INT 2
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: LD_INT 2
91418: PUSH
91419: LD_INT 4
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: LD_INT 0
91428: PUSH
91429: LD_INT 4
91431: PUSH
91432: EMPTY
91433: LIST
91434: LIST
91435: PUSH
91436: LD_INT 0
91438: PUSH
91439: LD_INT 3
91441: PUSH
91442: EMPTY
91443: LIST
91444: LIST
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: LD_INT 4
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PUSH
91456: LD_INT 1
91458: PUSH
91459: LD_INT 5
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: LD_INT 0
91468: PUSH
91469: LD_INT 5
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: PUSH
91476: LD_INT 1
91478: NEG
91479: PUSH
91480: LD_INT 4
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 1
91489: NEG
91490: PUSH
91491: LD_INT 3
91493: PUSH
91494: EMPTY
91495: LIST
91496: LIST
91497: PUSH
91498: LD_INT 2
91500: PUSH
91501: LD_INT 5
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: LD_INT 2
91510: NEG
91511: PUSH
91512: LD_INT 3
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: LIST
91540: LIST
91541: LIST
91542: LIST
91543: LIST
91544: LIST
91545: LIST
91546: LIST
91547: LIST
91548: LIST
91549: LIST
91550: LIST
91551: LIST
91552: LIST
91553: LIST
91554: LIST
91555: LIST
91556: LIST
91557: LIST
91558: LIST
91559: LIST
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
91566: LD_ADDR_VAR 0 34
91570: PUSH
91571: LD_INT 0
91573: PUSH
91574: LD_INT 4
91576: NEG
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 0
91584: PUSH
91585: LD_INT 5
91587: NEG
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: PUSH
91596: LD_INT 4
91598: NEG
91599: PUSH
91600: EMPTY
91601: LIST
91602: LIST
91603: PUSH
91604: LD_INT 1
91606: PUSH
91607: LD_INT 3
91609: NEG
91610: PUSH
91611: EMPTY
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 0
91617: PUSH
91618: LD_INT 3
91620: NEG
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: PUSH
91626: LD_INT 1
91628: NEG
91629: PUSH
91630: LD_INT 4
91632: NEG
91633: PUSH
91634: EMPTY
91635: LIST
91636: LIST
91637: PUSH
91638: LD_INT 1
91640: NEG
91641: PUSH
91642: LD_INT 5
91644: NEG
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: PUSH
91650: LD_INT 2
91652: PUSH
91653: LD_INT 3
91655: NEG
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 2
91663: NEG
91664: PUSH
91665: LD_INT 5
91667: NEG
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 3
91675: PUSH
91676: LD_INT 0
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 3
91685: PUSH
91686: LD_INT 1
91688: NEG
91689: PUSH
91690: EMPTY
91691: LIST
91692: LIST
91693: PUSH
91694: LD_INT 4
91696: PUSH
91697: LD_INT 0
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PUSH
91704: LD_INT 4
91706: PUSH
91707: LD_INT 1
91709: PUSH
91710: EMPTY
91711: LIST
91712: LIST
91713: PUSH
91714: LD_INT 3
91716: PUSH
91717: LD_INT 1
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 2
91726: PUSH
91727: LD_INT 0
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 2
91736: PUSH
91737: LD_INT 1
91739: NEG
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: PUSH
91745: LD_INT 2
91747: PUSH
91748: LD_INT 2
91750: NEG
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: PUSH
91756: LD_INT 4
91758: PUSH
91759: LD_INT 2
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 4
91768: PUSH
91769: LD_INT 4
91771: PUSH
91772: EMPTY
91773: LIST
91774: LIST
91775: PUSH
91776: LD_INT 4
91778: PUSH
91779: LD_INT 3
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: PUSH
91786: LD_INT 5
91788: PUSH
91789: LD_INT 4
91791: PUSH
91792: EMPTY
91793: LIST
91794: LIST
91795: PUSH
91796: LD_INT 5
91798: PUSH
91799: LD_INT 5
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 4
91808: PUSH
91809: LD_INT 5
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: LD_INT 3
91818: PUSH
91819: LD_INT 4
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PUSH
91826: LD_INT 3
91828: PUSH
91829: LD_INT 3
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 5
91838: PUSH
91839: LD_INT 3
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 3
91848: PUSH
91849: LD_INT 5
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 0
91858: PUSH
91859: LD_INT 3
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 0
91868: PUSH
91869: LD_INT 2
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: LD_INT 1
91878: PUSH
91879: LD_INT 3
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 1
91888: PUSH
91889: LD_INT 4
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: LD_INT 0
91898: PUSH
91899: LD_INT 4
91901: PUSH
91902: EMPTY
91903: LIST
91904: LIST
91905: PUSH
91906: LD_INT 1
91908: NEG
91909: PUSH
91910: LD_INT 3
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: LD_INT 1
91919: NEG
91920: PUSH
91921: LD_INT 2
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 2
91930: PUSH
91931: LD_INT 4
91933: PUSH
91934: EMPTY
91935: LIST
91936: LIST
91937: PUSH
91938: LD_INT 2
91940: NEG
91941: PUSH
91942: LD_INT 2
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 4
91951: NEG
91952: PUSH
91953: LD_INT 0
91955: PUSH
91956: EMPTY
91957: LIST
91958: LIST
91959: PUSH
91960: LD_INT 4
91962: NEG
91963: PUSH
91964: LD_INT 1
91966: NEG
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: LD_INT 3
91974: NEG
91975: PUSH
91976: LD_INT 0
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: PUSH
91983: LD_INT 3
91985: NEG
91986: PUSH
91987: LD_INT 1
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 4
91996: NEG
91997: PUSH
91998: LD_INT 1
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: PUSH
92005: LD_INT 5
92007: NEG
92008: PUSH
92009: LD_INT 0
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 5
92018: NEG
92019: PUSH
92020: LD_INT 1
92022: NEG
92023: PUSH
92024: EMPTY
92025: LIST
92026: LIST
92027: PUSH
92028: LD_INT 5
92030: NEG
92031: PUSH
92032: LD_INT 2
92034: NEG
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 3
92042: NEG
92043: PUSH
92044: LD_INT 2
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: ST_TO_ADDR
// end ; end ;
92098: GO 92101
92100: POP
// case btype of b_depot , b_warehouse :
92101: LD_VAR 0 1
92105: PUSH
92106: LD_INT 0
92108: DOUBLE
92109: EQUAL
92110: IFTRUE 92120
92112: LD_INT 1
92114: DOUBLE
92115: EQUAL
92116: IFTRUE 92120
92118: GO 92321
92120: POP
// case nation of nation_american :
92121: LD_VAR 0 5
92125: PUSH
92126: LD_INT 1
92128: DOUBLE
92129: EQUAL
92130: IFTRUE 92134
92132: GO 92190
92134: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
92135: LD_ADDR_VAR 0 9
92139: PUSH
92140: LD_VAR 0 11
92144: PUSH
92145: LD_VAR 0 12
92149: PUSH
92150: LD_VAR 0 13
92154: PUSH
92155: LD_VAR 0 14
92159: PUSH
92160: LD_VAR 0 15
92164: PUSH
92165: LD_VAR 0 16
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: PUSH
92178: LD_VAR 0 4
92182: PUSH
92183: LD_INT 1
92185: PLUS
92186: ARRAY
92187: ST_TO_ADDR
92188: GO 92319
92190: LD_INT 2
92192: DOUBLE
92193: EQUAL
92194: IFTRUE 92198
92196: GO 92254
92198: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
92199: LD_ADDR_VAR 0 9
92203: PUSH
92204: LD_VAR 0 17
92208: PUSH
92209: LD_VAR 0 18
92213: PUSH
92214: LD_VAR 0 19
92218: PUSH
92219: LD_VAR 0 20
92223: PUSH
92224: LD_VAR 0 21
92228: PUSH
92229: LD_VAR 0 22
92233: PUSH
92234: EMPTY
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: PUSH
92242: LD_VAR 0 4
92246: PUSH
92247: LD_INT 1
92249: PLUS
92250: ARRAY
92251: ST_TO_ADDR
92252: GO 92319
92254: LD_INT 3
92256: DOUBLE
92257: EQUAL
92258: IFTRUE 92262
92260: GO 92318
92262: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
92263: LD_ADDR_VAR 0 9
92267: PUSH
92268: LD_VAR 0 23
92272: PUSH
92273: LD_VAR 0 24
92277: PUSH
92278: LD_VAR 0 25
92282: PUSH
92283: LD_VAR 0 26
92287: PUSH
92288: LD_VAR 0 27
92292: PUSH
92293: LD_VAR 0 28
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: LIST
92304: LIST
92305: PUSH
92306: LD_VAR 0 4
92310: PUSH
92311: LD_INT 1
92313: PLUS
92314: ARRAY
92315: ST_TO_ADDR
92316: GO 92319
92318: POP
92319: GO 92868
92321: LD_INT 2
92323: DOUBLE
92324: EQUAL
92325: IFTRUE 92335
92327: LD_INT 3
92329: DOUBLE
92330: EQUAL
92331: IFTRUE 92335
92333: GO 92391
92335: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
92336: LD_ADDR_VAR 0 9
92340: PUSH
92341: LD_VAR 0 29
92345: PUSH
92346: LD_VAR 0 30
92350: PUSH
92351: LD_VAR 0 31
92355: PUSH
92356: LD_VAR 0 32
92360: PUSH
92361: LD_VAR 0 33
92365: PUSH
92366: LD_VAR 0 34
92370: PUSH
92371: EMPTY
92372: LIST
92373: LIST
92374: LIST
92375: LIST
92376: LIST
92377: LIST
92378: PUSH
92379: LD_VAR 0 4
92383: PUSH
92384: LD_INT 1
92386: PLUS
92387: ARRAY
92388: ST_TO_ADDR
92389: GO 92868
92391: LD_INT 16
92393: DOUBLE
92394: EQUAL
92395: IFTRUE 92447
92397: LD_INT 17
92399: DOUBLE
92400: EQUAL
92401: IFTRUE 92447
92403: LD_INT 18
92405: DOUBLE
92406: EQUAL
92407: IFTRUE 92447
92409: LD_INT 19
92411: DOUBLE
92412: EQUAL
92413: IFTRUE 92447
92415: LD_INT 20
92417: DOUBLE
92418: EQUAL
92419: IFTRUE 92447
92421: LD_INT 21
92423: DOUBLE
92424: EQUAL
92425: IFTRUE 92447
92427: LD_INT 23
92429: DOUBLE
92430: EQUAL
92431: IFTRUE 92447
92433: LD_INT 24
92435: DOUBLE
92436: EQUAL
92437: IFTRUE 92447
92439: LD_INT 25
92441: DOUBLE
92442: EQUAL
92443: IFTRUE 92447
92445: GO 92503
92447: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
92448: LD_ADDR_VAR 0 9
92452: PUSH
92453: LD_VAR 0 35
92457: PUSH
92458: LD_VAR 0 36
92462: PUSH
92463: LD_VAR 0 37
92467: PUSH
92468: LD_VAR 0 38
92472: PUSH
92473: LD_VAR 0 39
92477: PUSH
92478: LD_VAR 0 40
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: PUSH
92491: LD_VAR 0 4
92495: PUSH
92496: LD_INT 1
92498: PLUS
92499: ARRAY
92500: ST_TO_ADDR
92501: GO 92868
92503: LD_INT 6
92505: DOUBLE
92506: EQUAL
92507: IFTRUE 92559
92509: LD_INT 7
92511: DOUBLE
92512: EQUAL
92513: IFTRUE 92559
92515: LD_INT 8
92517: DOUBLE
92518: EQUAL
92519: IFTRUE 92559
92521: LD_INT 13
92523: DOUBLE
92524: EQUAL
92525: IFTRUE 92559
92527: LD_INT 12
92529: DOUBLE
92530: EQUAL
92531: IFTRUE 92559
92533: LD_INT 15
92535: DOUBLE
92536: EQUAL
92537: IFTRUE 92559
92539: LD_INT 11
92541: DOUBLE
92542: EQUAL
92543: IFTRUE 92559
92545: LD_INT 14
92547: DOUBLE
92548: EQUAL
92549: IFTRUE 92559
92551: LD_INT 10
92553: DOUBLE
92554: EQUAL
92555: IFTRUE 92559
92557: GO 92615
92559: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
92560: LD_ADDR_VAR 0 9
92564: PUSH
92565: LD_VAR 0 41
92569: PUSH
92570: LD_VAR 0 42
92574: PUSH
92575: LD_VAR 0 43
92579: PUSH
92580: LD_VAR 0 44
92584: PUSH
92585: LD_VAR 0 45
92589: PUSH
92590: LD_VAR 0 46
92594: PUSH
92595: EMPTY
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: PUSH
92603: LD_VAR 0 4
92607: PUSH
92608: LD_INT 1
92610: PLUS
92611: ARRAY
92612: ST_TO_ADDR
92613: GO 92868
92615: LD_INT 36
92617: DOUBLE
92618: EQUAL
92619: IFTRUE 92623
92621: GO 92679
92623: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
92624: LD_ADDR_VAR 0 9
92628: PUSH
92629: LD_VAR 0 47
92633: PUSH
92634: LD_VAR 0 48
92638: PUSH
92639: LD_VAR 0 49
92643: PUSH
92644: LD_VAR 0 50
92648: PUSH
92649: LD_VAR 0 51
92653: PUSH
92654: LD_VAR 0 52
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: PUSH
92667: LD_VAR 0 4
92671: PUSH
92672: LD_INT 1
92674: PLUS
92675: ARRAY
92676: ST_TO_ADDR
92677: GO 92868
92679: LD_INT 4
92681: DOUBLE
92682: EQUAL
92683: IFTRUE 92705
92685: LD_INT 5
92687: DOUBLE
92688: EQUAL
92689: IFTRUE 92705
92691: LD_INT 34
92693: DOUBLE
92694: EQUAL
92695: IFTRUE 92705
92697: LD_INT 37
92699: DOUBLE
92700: EQUAL
92701: IFTRUE 92705
92703: GO 92761
92705: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
92706: LD_ADDR_VAR 0 9
92710: PUSH
92711: LD_VAR 0 53
92715: PUSH
92716: LD_VAR 0 54
92720: PUSH
92721: LD_VAR 0 55
92725: PUSH
92726: LD_VAR 0 56
92730: PUSH
92731: LD_VAR 0 57
92735: PUSH
92736: LD_VAR 0 58
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: LIST
92748: PUSH
92749: LD_VAR 0 4
92753: PUSH
92754: LD_INT 1
92756: PLUS
92757: ARRAY
92758: ST_TO_ADDR
92759: GO 92868
92761: LD_INT 31
92763: DOUBLE
92764: EQUAL
92765: IFTRUE 92811
92767: LD_INT 32
92769: DOUBLE
92770: EQUAL
92771: IFTRUE 92811
92773: LD_INT 33
92775: DOUBLE
92776: EQUAL
92777: IFTRUE 92811
92779: LD_INT 27
92781: DOUBLE
92782: EQUAL
92783: IFTRUE 92811
92785: LD_INT 26
92787: DOUBLE
92788: EQUAL
92789: IFTRUE 92811
92791: LD_INT 28
92793: DOUBLE
92794: EQUAL
92795: IFTRUE 92811
92797: LD_INT 29
92799: DOUBLE
92800: EQUAL
92801: IFTRUE 92811
92803: LD_INT 30
92805: DOUBLE
92806: EQUAL
92807: IFTRUE 92811
92809: GO 92867
92811: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
92812: LD_ADDR_VAR 0 9
92816: PUSH
92817: LD_VAR 0 59
92821: PUSH
92822: LD_VAR 0 60
92826: PUSH
92827: LD_VAR 0 61
92831: PUSH
92832: LD_VAR 0 62
92836: PUSH
92837: LD_VAR 0 63
92841: PUSH
92842: LD_VAR 0 64
92846: PUSH
92847: EMPTY
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: PUSH
92855: LD_VAR 0 4
92859: PUSH
92860: LD_INT 1
92862: PLUS
92863: ARRAY
92864: ST_TO_ADDR
92865: GO 92868
92867: POP
// temp_list2 = [ ] ;
92868: LD_ADDR_VAR 0 10
92872: PUSH
92873: EMPTY
92874: ST_TO_ADDR
// for i in temp_list do
92875: LD_ADDR_VAR 0 8
92879: PUSH
92880: LD_VAR 0 9
92884: PUSH
92885: FOR_IN
92886: IFFALSE 92938
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
92888: LD_ADDR_VAR 0 10
92892: PUSH
92893: LD_VAR 0 10
92897: PUSH
92898: LD_VAR 0 8
92902: PUSH
92903: LD_INT 1
92905: ARRAY
92906: PUSH
92907: LD_VAR 0 2
92911: PLUS
92912: PUSH
92913: LD_VAR 0 8
92917: PUSH
92918: LD_INT 2
92920: ARRAY
92921: PUSH
92922: LD_VAR 0 3
92926: PLUS
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: EMPTY
92933: LIST
92934: ADD
92935: ST_TO_ADDR
92936: GO 92885
92938: POP
92939: POP
// result = temp_list2 ;
92940: LD_ADDR_VAR 0 7
92944: PUSH
92945: LD_VAR 0 10
92949: ST_TO_ADDR
// end ;
92950: LD_VAR 0 7
92954: RET
// export function EnemyInRange ( unit , dist ) ; begin
92955: LD_INT 0
92957: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
92958: LD_ADDR_VAR 0 3
92962: PUSH
92963: LD_VAR 0 1
92967: PPUSH
92968: CALL_OW 255
92972: PPUSH
92973: LD_VAR 0 1
92977: PPUSH
92978: CALL_OW 250
92982: PPUSH
92983: LD_VAR 0 1
92987: PPUSH
92988: CALL_OW 251
92992: PPUSH
92993: LD_VAR 0 2
92997: PPUSH
92998: CALL 67083 0 4
93002: PUSH
93003: LD_INT 4
93005: ARRAY
93006: ST_TO_ADDR
// end ;
93007: LD_VAR 0 3
93011: RET
// export function PlayerSeeMe ( unit ) ; begin
93012: LD_INT 0
93014: PPUSH
// result := See ( your_side , unit ) ;
93015: LD_ADDR_VAR 0 2
93019: PUSH
93020: LD_OWVAR 2
93024: PPUSH
93025: LD_VAR 0 1
93029: PPUSH
93030: CALL_OW 292
93034: ST_TO_ADDR
// end ;
93035: LD_VAR 0 2
93039: RET
// export function ReverseDir ( unit ) ; begin
93040: LD_INT 0
93042: PPUSH
// if not unit then
93043: LD_VAR 0 1
93047: NOT
93048: IFFALSE 93052
// exit ;
93050: GO 93098
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
93052: LD_ADDR_VAR 0 2
93056: PUSH
93057: LD_INT 3
93059: PUSH
93060: LD_INT 4
93062: PUSH
93063: LD_INT 5
93065: PUSH
93066: LD_INT 0
93068: PUSH
93069: LD_INT 1
93071: PUSH
93072: LD_INT 2
93074: PUSH
93075: EMPTY
93076: LIST
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: PUSH
93083: LD_VAR 0 1
93087: PPUSH
93088: CALL_OW 254
93092: PUSH
93093: LD_INT 1
93095: PLUS
93096: ARRAY
93097: ST_TO_ADDR
// end ;
93098: LD_VAR 0 2
93102: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
93103: LD_INT 0
93105: PPUSH
93106: PPUSH
93107: PPUSH
93108: PPUSH
93109: PPUSH
// if not hexes then
93110: LD_VAR 0 2
93114: NOT
93115: IFFALSE 93119
// exit ;
93117: GO 93267
// dist := 9999 ;
93119: LD_ADDR_VAR 0 5
93123: PUSH
93124: LD_INT 9999
93126: ST_TO_ADDR
// for i = 1 to hexes do
93127: LD_ADDR_VAR 0 4
93131: PUSH
93132: DOUBLE
93133: LD_INT 1
93135: DEC
93136: ST_TO_ADDR
93137: LD_VAR 0 2
93141: PUSH
93142: FOR_TO
93143: IFFALSE 93255
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
93145: LD_VAR 0 1
93149: PPUSH
93150: LD_VAR 0 2
93154: PUSH
93155: LD_VAR 0 4
93159: ARRAY
93160: PUSH
93161: LD_INT 1
93163: ARRAY
93164: PPUSH
93165: LD_VAR 0 2
93169: PUSH
93170: LD_VAR 0 4
93174: ARRAY
93175: PUSH
93176: LD_INT 2
93178: ARRAY
93179: PPUSH
93180: CALL_OW 297
93184: PUSH
93185: LD_VAR 0 5
93189: LESS
93190: IFFALSE 93253
// begin hex := hexes [ i ] ;
93192: LD_ADDR_VAR 0 7
93196: PUSH
93197: LD_VAR 0 2
93201: PUSH
93202: LD_VAR 0 4
93206: ARRAY
93207: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
93208: LD_ADDR_VAR 0 5
93212: PUSH
93213: LD_VAR 0 1
93217: PPUSH
93218: LD_VAR 0 2
93222: PUSH
93223: LD_VAR 0 4
93227: ARRAY
93228: PUSH
93229: LD_INT 1
93231: ARRAY
93232: PPUSH
93233: LD_VAR 0 2
93237: PUSH
93238: LD_VAR 0 4
93242: ARRAY
93243: PUSH
93244: LD_INT 2
93246: ARRAY
93247: PPUSH
93248: CALL_OW 297
93252: ST_TO_ADDR
// end ; end ;
93253: GO 93142
93255: POP
93256: POP
// result := hex ;
93257: LD_ADDR_VAR 0 3
93261: PUSH
93262: LD_VAR 0 7
93266: ST_TO_ADDR
// end ;
93267: LD_VAR 0 3
93271: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
93272: LD_INT 0
93274: PPUSH
93275: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
93276: LD_VAR 0 1
93280: NOT
93281: PUSH
93282: LD_VAR 0 1
93286: PUSH
93287: LD_INT 21
93289: PUSH
93290: LD_INT 2
93292: PUSH
93293: EMPTY
93294: LIST
93295: LIST
93296: PUSH
93297: LD_INT 23
93299: PUSH
93300: LD_INT 2
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: EMPTY
93308: LIST
93309: LIST
93310: PPUSH
93311: CALL_OW 69
93315: IN
93316: NOT
93317: OR
93318: IFFALSE 93322
// exit ;
93320: GO 93369
// for i = 1 to 3 do
93322: LD_ADDR_VAR 0 3
93326: PUSH
93327: DOUBLE
93328: LD_INT 1
93330: DEC
93331: ST_TO_ADDR
93332: LD_INT 3
93334: PUSH
93335: FOR_TO
93336: IFFALSE 93367
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
93338: LD_VAR 0 1
93342: PPUSH
93343: CALL_OW 250
93347: PPUSH
93348: LD_VAR 0 1
93352: PPUSH
93353: CALL_OW 251
93357: PPUSH
93358: LD_INT 1
93360: PPUSH
93361: CALL_OW 453
93365: GO 93335
93367: POP
93368: POP
// end ;
93369: LD_VAR 0 2
93373: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
93374: LD_INT 0
93376: PPUSH
93377: PPUSH
93378: PPUSH
93379: PPUSH
93380: PPUSH
93381: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
93382: LD_VAR 0 1
93386: NOT
93387: PUSH
93388: LD_VAR 0 2
93392: NOT
93393: OR
93394: PUSH
93395: LD_VAR 0 1
93399: PPUSH
93400: CALL_OW 314
93404: OR
93405: IFFALSE 93409
// exit ;
93407: GO 93850
// x := GetX ( enemy_unit ) ;
93409: LD_ADDR_VAR 0 7
93413: PUSH
93414: LD_VAR 0 2
93418: PPUSH
93419: CALL_OW 250
93423: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
93424: LD_ADDR_VAR 0 8
93428: PUSH
93429: LD_VAR 0 2
93433: PPUSH
93434: CALL_OW 251
93438: ST_TO_ADDR
// if not x or not y then
93439: LD_VAR 0 7
93443: NOT
93444: PUSH
93445: LD_VAR 0 8
93449: NOT
93450: OR
93451: IFFALSE 93455
// exit ;
93453: GO 93850
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
93455: LD_ADDR_VAR 0 6
93459: PUSH
93460: LD_VAR 0 7
93464: PPUSH
93465: LD_INT 0
93467: PPUSH
93468: LD_INT 4
93470: PPUSH
93471: CALL_OW 272
93475: PUSH
93476: LD_VAR 0 8
93480: PPUSH
93481: LD_INT 0
93483: PPUSH
93484: LD_INT 4
93486: PPUSH
93487: CALL_OW 273
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: LD_VAR 0 7
93500: PPUSH
93501: LD_INT 1
93503: PPUSH
93504: LD_INT 4
93506: PPUSH
93507: CALL_OW 272
93511: PUSH
93512: LD_VAR 0 8
93516: PPUSH
93517: LD_INT 1
93519: PPUSH
93520: LD_INT 4
93522: PPUSH
93523: CALL_OW 273
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_VAR 0 7
93536: PPUSH
93537: LD_INT 2
93539: PPUSH
93540: LD_INT 4
93542: PPUSH
93543: CALL_OW 272
93547: PUSH
93548: LD_VAR 0 8
93552: PPUSH
93553: LD_INT 2
93555: PPUSH
93556: LD_INT 4
93558: PPUSH
93559: CALL_OW 273
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: LD_VAR 0 7
93572: PPUSH
93573: LD_INT 3
93575: PPUSH
93576: LD_INT 4
93578: PPUSH
93579: CALL_OW 272
93583: PUSH
93584: LD_VAR 0 8
93588: PPUSH
93589: LD_INT 3
93591: PPUSH
93592: LD_INT 4
93594: PPUSH
93595: CALL_OW 273
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: LD_VAR 0 7
93608: PPUSH
93609: LD_INT 4
93611: PPUSH
93612: LD_INT 4
93614: PPUSH
93615: CALL_OW 272
93619: PUSH
93620: LD_VAR 0 8
93624: PPUSH
93625: LD_INT 4
93627: PPUSH
93628: LD_INT 4
93630: PPUSH
93631: CALL_OW 273
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: PUSH
93640: LD_VAR 0 7
93644: PPUSH
93645: LD_INT 5
93647: PPUSH
93648: LD_INT 4
93650: PPUSH
93651: CALL_OW 272
93655: PUSH
93656: LD_VAR 0 8
93660: PPUSH
93661: LD_INT 5
93663: PPUSH
93664: LD_INT 4
93666: PPUSH
93667: CALL_OW 273
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: ST_TO_ADDR
// for i = tmp downto 1 do
93684: LD_ADDR_VAR 0 4
93688: PUSH
93689: DOUBLE
93690: LD_VAR 0 6
93694: INC
93695: ST_TO_ADDR
93696: LD_INT 1
93698: PUSH
93699: FOR_DOWNTO
93700: IFFALSE 93801
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
93702: LD_VAR 0 6
93706: PUSH
93707: LD_VAR 0 4
93711: ARRAY
93712: PUSH
93713: LD_INT 1
93715: ARRAY
93716: PPUSH
93717: LD_VAR 0 6
93721: PUSH
93722: LD_VAR 0 4
93726: ARRAY
93727: PUSH
93728: LD_INT 2
93730: ARRAY
93731: PPUSH
93732: CALL_OW 488
93736: NOT
93737: PUSH
93738: LD_VAR 0 6
93742: PUSH
93743: LD_VAR 0 4
93747: ARRAY
93748: PUSH
93749: LD_INT 1
93751: ARRAY
93752: PPUSH
93753: LD_VAR 0 6
93757: PUSH
93758: LD_VAR 0 4
93762: ARRAY
93763: PUSH
93764: LD_INT 2
93766: ARRAY
93767: PPUSH
93768: CALL_OW 428
93772: PUSH
93773: LD_INT 0
93775: NONEQUAL
93776: OR
93777: IFFALSE 93799
// tmp := Delete ( tmp , i ) ;
93779: LD_ADDR_VAR 0 6
93783: PUSH
93784: LD_VAR 0 6
93788: PPUSH
93789: LD_VAR 0 4
93793: PPUSH
93794: CALL_OW 3
93798: ST_TO_ADDR
93799: GO 93699
93801: POP
93802: POP
// j := GetClosestHex ( unit , tmp ) ;
93803: LD_ADDR_VAR 0 5
93807: PUSH
93808: LD_VAR 0 1
93812: PPUSH
93813: LD_VAR 0 6
93817: PPUSH
93818: CALL 93103 0 2
93822: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
93823: LD_VAR 0 1
93827: PPUSH
93828: LD_VAR 0 5
93832: PUSH
93833: LD_INT 1
93835: ARRAY
93836: PPUSH
93837: LD_VAR 0 5
93841: PUSH
93842: LD_INT 2
93844: ARRAY
93845: PPUSH
93846: CALL_OW 111
// end ;
93850: LD_VAR 0 3
93854: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
93855: LD_INT 0
93857: PPUSH
93858: PPUSH
93859: PPUSH
// uc_side = 0 ;
93860: LD_ADDR_OWVAR 20
93864: PUSH
93865: LD_INT 0
93867: ST_TO_ADDR
// uc_nation = 0 ;
93868: LD_ADDR_OWVAR 21
93872: PUSH
93873: LD_INT 0
93875: ST_TO_ADDR
// InitHc ;
93876: CALL_OW 19
// InitVc ;
93880: CALL_OW 20
// if mastodonts then
93884: LD_VAR 0 6
93888: IFFALSE 93955
// for i = 1 to mastodonts do
93890: LD_ADDR_VAR 0 11
93894: PUSH
93895: DOUBLE
93896: LD_INT 1
93898: DEC
93899: ST_TO_ADDR
93900: LD_VAR 0 6
93904: PUSH
93905: FOR_TO
93906: IFFALSE 93953
// begin vc_chassis := 31 ;
93908: LD_ADDR_OWVAR 37
93912: PUSH
93913: LD_INT 31
93915: ST_TO_ADDR
// vc_control := control_rider ;
93916: LD_ADDR_OWVAR 38
93920: PUSH
93921: LD_INT 4
93923: ST_TO_ADDR
// animal := CreateVehicle ;
93924: LD_ADDR_VAR 0 12
93928: PUSH
93929: CALL_OW 45
93933: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
93934: LD_VAR 0 12
93938: PPUSH
93939: LD_VAR 0 8
93943: PPUSH
93944: LD_INT 0
93946: PPUSH
93947: CALL 100661 0 3
// end ;
93951: GO 93905
93953: POP
93954: POP
// if horses then
93955: LD_VAR 0 5
93959: IFFALSE 94026
// for i = 1 to horses do
93961: LD_ADDR_VAR 0 11
93965: PUSH
93966: DOUBLE
93967: LD_INT 1
93969: DEC
93970: ST_TO_ADDR
93971: LD_VAR 0 5
93975: PUSH
93976: FOR_TO
93977: IFFALSE 94024
// begin hc_class := 21 ;
93979: LD_ADDR_OWVAR 28
93983: PUSH
93984: LD_INT 21
93986: ST_TO_ADDR
// hc_gallery :=  ;
93987: LD_ADDR_OWVAR 33
93991: PUSH
93992: LD_STRING 
93994: ST_TO_ADDR
// animal := CreateHuman ;
93995: LD_ADDR_VAR 0 12
93999: PUSH
94000: CALL_OW 44
94004: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94005: LD_VAR 0 12
94009: PPUSH
94010: LD_VAR 0 8
94014: PPUSH
94015: LD_INT 0
94017: PPUSH
94018: CALL 100661 0 3
// end ;
94022: GO 93976
94024: POP
94025: POP
// if birds then
94026: LD_VAR 0 1
94030: IFFALSE 94097
// for i = 1 to birds do
94032: LD_ADDR_VAR 0 11
94036: PUSH
94037: DOUBLE
94038: LD_INT 1
94040: DEC
94041: ST_TO_ADDR
94042: LD_VAR 0 1
94046: PUSH
94047: FOR_TO
94048: IFFALSE 94095
// begin hc_class = 18 ;
94050: LD_ADDR_OWVAR 28
94054: PUSH
94055: LD_INT 18
94057: ST_TO_ADDR
// hc_gallery =  ;
94058: LD_ADDR_OWVAR 33
94062: PUSH
94063: LD_STRING 
94065: ST_TO_ADDR
// animal := CreateHuman ;
94066: LD_ADDR_VAR 0 12
94070: PUSH
94071: CALL_OW 44
94075: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94076: LD_VAR 0 12
94080: PPUSH
94081: LD_VAR 0 8
94085: PPUSH
94086: LD_INT 0
94088: PPUSH
94089: CALL 100661 0 3
// end ;
94093: GO 94047
94095: POP
94096: POP
// if tigers then
94097: LD_VAR 0 2
94101: IFFALSE 94185
// for i = 1 to tigers do
94103: LD_ADDR_VAR 0 11
94107: PUSH
94108: DOUBLE
94109: LD_INT 1
94111: DEC
94112: ST_TO_ADDR
94113: LD_VAR 0 2
94117: PUSH
94118: FOR_TO
94119: IFFALSE 94183
// begin hc_class = class_tiger ;
94121: LD_ADDR_OWVAR 28
94125: PUSH
94126: LD_INT 14
94128: ST_TO_ADDR
// hc_gallery =  ;
94129: LD_ADDR_OWVAR 33
94133: PUSH
94134: LD_STRING 
94136: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
94137: LD_ADDR_OWVAR 35
94141: PUSH
94142: LD_INT 7
94144: NEG
94145: PPUSH
94146: LD_INT 7
94148: PPUSH
94149: CALL_OW 12
94153: ST_TO_ADDR
// animal := CreateHuman ;
94154: LD_ADDR_VAR 0 12
94158: PUSH
94159: CALL_OW 44
94163: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94164: LD_VAR 0 12
94168: PPUSH
94169: LD_VAR 0 8
94173: PPUSH
94174: LD_INT 0
94176: PPUSH
94177: CALL 100661 0 3
// end ;
94181: GO 94118
94183: POP
94184: POP
// if apemans then
94185: LD_VAR 0 3
94189: IFFALSE 94312
// for i = 1 to apemans do
94191: LD_ADDR_VAR 0 11
94195: PUSH
94196: DOUBLE
94197: LD_INT 1
94199: DEC
94200: ST_TO_ADDR
94201: LD_VAR 0 3
94205: PUSH
94206: FOR_TO
94207: IFFALSE 94310
// begin hc_class = class_apeman ;
94209: LD_ADDR_OWVAR 28
94213: PUSH
94214: LD_INT 12
94216: ST_TO_ADDR
// hc_gallery =  ;
94217: LD_ADDR_OWVAR 33
94221: PUSH
94222: LD_STRING 
94224: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
94225: LD_ADDR_OWVAR 35
94229: PUSH
94230: LD_INT 5
94232: NEG
94233: PPUSH
94234: LD_INT 5
94236: PPUSH
94237: CALL_OW 12
94241: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
94242: LD_ADDR_OWVAR 31
94246: PUSH
94247: LD_INT 1
94249: PPUSH
94250: LD_INT 3
94252: PPUSH
94253: CALL_OW 12
94257: PUSH
94258: LD_INT 1
94260: PPUSH
94261: LD_INT 3
94263: PPUSH
94264: CALL_OW 12
94268: PUSH
94269: LD_INT 0
94271: PUSH
94272: LD_INT 0
94274: PUSH
94275: EMPTY
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: ST_TO_ADDR
// animal := CreateHuman ;
94281: LD_ADDR_VAR 0 12
94285: PUSH
94286: CALL_OW 44
94290: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94291: LD_VAR 0 12
94295: PPUSH
94296: LD_VAR 0 8
94300: PPUSH
94301: LD_INT 0
94303: PPUSH
94304: CALL 100661 0 3
// end ;
94308: GO 94206
94310: POP
94311: POP
// if enchidnas then
94312: LD_VAR 0 4
94316: IFFALSE 94383
// for i = 1 to enchidnas do
94318: LD_ADDR_VAR 0 11
94322: PUSH
94323: DOUBLE
94324: LD_INT 1
94326: DEC
94327: ST_TO_ADDR
94328: LD_VAR 0 4
94332: PUSH
94333: FOR_TO
94334: IFFALSE 94381
// begin hc_class = 13 ;
94336: LD_ADDR_OWVAR 28
94340: PUSH
94341: LD_INT 13
94343: ST_TO_ADDR
// hc_gallery =  ;
94344: LD_ADDR_OWVAR 33
94348: PUSH
94349: LD_STRING 
94351: ST_TO_ADDR
// animal := CreateHuman ;
94352: LD_ADDR_VAR 0 12
94356: PUSH
94357: CALL_OW 44
94361: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
94362: LD_VAR 0 12
94366: PPUSH
94367: LD_VAR 0 8
94371: PPUSH
94372: LD_INT 0
94374: PPUSH
94375: CALL 100661 0 3
// end ;
94379: GO 94333
94381: POP
94382: POP
// if fishes then
94383: LD_VAR 0 7
94387: IFFALSE 94454
// for i = 1 to fishes do
94389: LD_ADDR_VAR 0 11
94393: PUSH
94394: DOUBLE
94395: LD_INT 1
94397: DEC
94398: ST_TO_ADDR
94399: LD_VAR 0 7
94403: PUSH
94404: FOR_TO
94405: IFFALSE 94452
// begin hc_class = 20 ;
94407: LD_ADDR_OWVAR 28
94411: PUSH
94412: LD_INT 20
94414: ST_TO_ADDR
// hc_gallery =  ;
94415: LD_ADDR_OWVAR 33
94419: PUSH
94420: LD_STRING 
94422: ST_TO_ADDR
// animal := CreateHuman ;
94423: LD_ADDR_VAR 0 12
94427: PUSH
94428: CALL_OW 44
94432: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
94433: LD_VAR 0 12
94437: PPUSH
94438: LD_VAR 0 9
94442: PPUSH
94443: LD_INT 0
94445: PPUSH
94446: CALL 100661 0 3
// end ;
94450: GO 94404
94452: POP
94453: POP
// end ;
94454: LD_VAR 0 10
94458: RET
// export function WantHeal ( sci , unit ) ; begin
94459: LD_INT 0
94461: PPUSH
// if GetTaskList ( sci ) > 0 then
94462: LD_VAR 0 1
94466: PPUSH
94467: CALL_OW 437
94471: PUSH
94472: LD_INT 0
94474: GREATER
94475: IFFALSE 94545
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
94477: LD_VAR 0 1
94481: PPUSH
94482: CALL_OW 437
94486: PUSH
94487: LD_INT 1
94489: ARRAY
94490: PUSH
94491: LD_INT 1
94493: ARRAY
94494: PUSH
94495: LD_STRING l
94497: EQUAL
94498: PUSH
94499: LD_VAR 0 1
94503: PPUSH
94504: CALL_OW 437
94508: PUSH
94509: LD_INT 1
94511: ARRAY
94512: PUSH
94513: LD_INT 4
94515: ARRAY
94516: PUSH
94517: LD_VAR 0 2
94521: EQUAL
94522: AND
94523: IFFALSE 94535
// result := true else
94525: LD_ADDR_VAR 0 3
94529: PUSH
94530: LD_INT 1
94532: ST_TO_ADDR
94533: GO 94543
// result := false ;
94535: LD_ADDR_VAR 0 3
94539: PUSH
94540: LD_INT 0
94542: ST_TO_ADDR
// end else
94543: GO 94553
// result := false ;
94545: LD_ADDR_VAR 0 3
94549: PUSH
94550: LD_INT 0
94552: ST_TO_ADDR
// end ;
94553: LD_VAR 0 3
94557: RET
// export function HealTarget ( sci ) ; begin
94558: LD_INT 0
94560: PPUSH
// if not sci then
94561: LD_VAR 0 1
94565: NOT
94566: IFFALSE 94570
// exit ;
94568: GO 94635
// result := 0 ;
94570: LD_ADDR_VAR 0 2
94574: PUSH
94575: LD_INT 0
94577: ST_TO_ADDR
// if GetTaskList ( sci ) then
94578: LD_VAR 0 1
94582: PPUSH
94583: CALL_OW 437
94587: IFFALSE 94635
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
94589: LD_VAR 0 1
94593: PPUSH
94594: CALL_OW 437
94598: PUSH
94599: LD_INT 1
94601: ARRAY
94602: PUSH
94603: LD_INT 1
94605: ARRAY
94606: PUSH
94607: LD_STRING l
94609: EQUAL
94610: IFFALSE 94635
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
94612: LD_ADDR_VAR 0 2
94616: PUSH
94617: LD_VAR 0 1
94621: PPUSH
94622: CALL_OW 437
94626: PUSH
94627: LD_INT 1
94629: ARRAY
94630: PUSH
94631: LD_INT 4
94633: ARRAY
94634: ST_TO_ADDR
// end ;
94635: LD_VAR 0 2
94639: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs ; begin
94640: LD_INT 0
94642: PPUSH
94643: PPUSH
94644: PPUSH
94645: PPUSH
94646: PPUSH
94647: PPUSH
94648: PPUSH
94649: PPUSH
94650: PPUSH
94651: PPUSH
94652: PPUSH
94653: PPUSH
94654: PPUSH
94655: PPUSH
94656: PPUSH
94657: PPUSH
94658: PPUSH
94659: PPUSH
94660: PPUSH
94661: PPUSH
94662: PPUSH
94663: PPUSH
94664: PPUSH
94665: PPUSH
94666: PPUSH
94667: PPUSH
94668: PPUSH
94669: PPUSH
94670: PPUSH
94671: PPUSH
94672: PPUSH
94673: PPUSH
94674: PPUSH
// if not list then
94675: LD_VAR 0 1
94679: NOT
94680: IFFALSE 94684
// exit ;
94682: GO 99272
// base := list [ 1 ] ;
94684: LD_ADDR_VAR 0 3
94688: PUSH
94689: LD_VAR 0 1
94693: PUSH
94694: LD_INT 1
94696: ARRAY
94697: ST_TO_ADDR
// group := list [ 2 ] ;
94698: LD_ADDR_VAR 0 4
94702: PUSH
94703: LD_VAR 0 1
94707: PUSH
94708: LD_INT 2
94710: ARRAY
94711: ST_TO_ADDR
// path := list [ 3 ] ;
94712: LD_ADDR_VAR 0 5
94716: PUSH
94717: LD_VAR 0 1
94721: PUSH
94722: LD_INT 3
94724: ARRAY
94725: ST_TO_ADDR
// flags := list [ 4 ] ;
94726: LD_ADDR_VAR 0 6
94730: PUSH
94731: LD_VAR 0 1
94735: PUSH
94736: LD_INT 4
94738: ARRAY
94739: ST_TO_ADDR
// mined := [ ] ;
94740: LD_ADDR_VAR 0 27
94744: PUSH
94745: EMPTY
94746: ST_TO_ADDR
// bombed := [ ] ;
94747: LD_ADDR_VAR 0 28
94751: PUSH
94752: EMPTY
94753: ST_TO_ADDR
// healers := [ ] ;
94754: LD_ADDR_VAR 0 31
94758: PUSH
94759: EMPTY
94760: ST_TO_ADDR
// to_heal := [ ] ;
94761: LD_ADDR_VAR 0 30
94765: PUSH
94766: EMPTY
94767: ST_TO_ADDR
// repairs := [ ] ;
94768: LD_ADDR_VAR 0 33
94772: PUSH
94773: EMPTY
94774: ST_TO_ADDR
// to_repair := [ ] ;
94775: LD_ADDR_VAR 0 32
94779: PUSH
94780: EMPTY
94781: ST_TO_ADDR
// if not group or not path then
94782: LD_VAR 0 4
94786: NOT
94787: PUSH
94788: LD_VAR 0 5
94792: NOT
94793: OR
94794: IFFALSE 94798
// exit ;
94796: GO 99272
// if flags then
94798: LD_VAR 0 6
94802: IFFALSE 94946
// begin f_ignore_area := flags [ 1 ] ;
94804: LD_ADDR_VAR 0 17
94808: PUSH
94809: LD_VAR 0 6
94813: PUSH
94814: LD_INT 1
94816: ARRAY
94817: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
94818: LD_ADDR_VAR 0 18
94822: PUSH
94823: LD_VAR 0 6
94827: PUSH
94828: LD_INT 2
94830: ARRAY
94831: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
94832: LD_ADDR_VAR 0 19
94836: PUSH
94837: LD_VAR 0 6
94841: PUSH
94842: LD_INT 3
94844: ARRAY
94845: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
94846: LD_ADDR_VAR 0 20
94850: PUSH
94851: LD_VAR 0 6
94855: PUSH
94856: LD_INT 4
94858: ARRAY
94859: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
94860: LD_ADDR_VAR 0 21
94864: PUSH
94865: LD_VAR 0 6
94869: PUSH
94870: LD_INT 5
94872: ARRAY
94873: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
94874: LD_ADDR_VAR 0 22
94878: PUSH
94879: LD_VAR 0 6
94883: PUSH
94884: LD_INT 6
94886: ARRAY
94887: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
94888: LD_ADDR_VAR 0 23
94892: PUSH
94893: LD_VAR 0 6
94897: PUSH
94898: LD_INT 7
94900: ARRAY
94901: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
94902: LD_ADDR_VAR 0 24
94906: PUSH
94907: LD_VAR 0 6
94911: PUSH
94912: LD_INT 8
94914: ARRAY
94915: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
94916: LD_ADDR_VAR 0 25
94920: PUSH
94921: LD_VAR 0 6
94925: PUSH
94926: LD_INT 9
94928: ARRAY
94929: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
94930: LD_ADDR_VAR 0 26
94934: PUSH
94935: LD_VAR 0 6
94939: PUSH
94940: LD_INT 10
94942: ARRAY
94943: ST_TO_ADDR
// end else
94944: GO 95026
// begin f_ignore_area := false ;
94946: LD_ADDR_VAR 0 17
94950: PUSH
94951: LD_INT 0
94953: ST_TO_ADDR
// f_capture := false ;
94954: LD_ADDR_VAR 0 18
94958: PUSH
94959: LD_INT 0
94961: ST_TO_ADDR
// f_ignore_civ := false ;
94962: LD_ADDR_VAR 0 19
94966: PUSH
94967: LD_INT 0
94969: ST_TO_ADDR
// f_murder := false ;
94970: LD_ADDR_VAR 0 20
94974: PUSH
94975: LD_INT 0
94977: ST_TO_ADDR
// f_mines := false ;
94978: LD_ADDR_VAR 0 21
94982: PUSH
94983: LD_INT 0
94985: ST_TO_ADDR
// f_repair := false ;
94986: LD_ADDR_VAR 0 22
94990: PUSH
94991: LD_INT 0
94993: ST_TO_ADDR
// f_heal := false ;
94994: LD_ADDR_VAR 0 23
94998: PUSH
94999: LD_INT 0
95001: ST_TO_ADDR
// f_spacetime := false ;
95002: LD_ADDR_VAR 0 24
95006: PUSH
95007: LD_INT 0
95009: ST_TO_ADDR
// f_attack_depot := false ;
95010: LD_ADDR_VAR 0 25
95014: PUSH
95015: LD_INT 0
95017: ST_TO_ADDR
// f_crawl := false ;
95018: LD_ADDR_VAR 0 26
95022: PUSH
95023: LD_INT 0
95025: ST_TO_ADDR
// end ; if f_heal then
95026: LD_VAR 0 23
95030: IFFALSE 95057
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
95032: LD_ADDR_VAR 0 31
95036: PUSH
95037: LD_VAR 0 4
95041: PPUSH
95042: LD_INT 25
95044: PUSH
95045: LD_INT 4
95047: PUSH
95048: EMPTY
95049: LIST
95050: LIST
95051: PPUSH
95052: CALL_OW 72
95056: ST_TO_ADDR
// if f_repair then
95057: LD_VAR 0 22
95061: IFFALSE 95088
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
95063: LD_ADDR_VAR 0 33
95067: PUSH
95068: LD_VAR 0 4
95072: PPUSH
95073: LD_INT 25
95075: PUSH
95076: LD_INT 3
95078: PUSH
95079: EMPTY
95080: LIST
95081: LIST
95082: PPUSH
95083: CALL_OW 72
95087: ST_TO_ADDR
// units_path := [ ] ;
95088: LD_ADDR_VAR 0 16
95092: PUSH
95093: EMPTY
95094: ST_TO_ADDR
// for i = 1 to group do
95095: LD_ADDR_VAR 0 7
95099: PUSH
95100: DOUBLE
95101: LD_INT 1
95103: DEC
95104: ST_TO_ADDR
95105: LD_VAR 0 4
95109: PUSH
95110: FOR_TO
95111: IFFALSE 95140
// units_path := Replace ( units_path , i , path ) ;
95113: LD_ADDR_VAR 0 16
95117: PUSH
95118: LD_VAR 0 16
95122: PPUSH
95123: LD_VAR 0 7
95127: PPUSH
95128: LD_VAR 0 5
95132: PPUSH
95133: CALL_OW 1
95137: ST_TO_ADDR
95138: GO 95110
95140: POP
95141: POP
// repeat for i = group downto 1 do
95142: LD_ADDR_VAR 0 7
95146: PUSH
95147: DOUBLE
95148: LD_VAR 0 4
95152: INC
95153: ST_TO_ADDR
95154: LD_INT 1
95156: PUSH
95157: FOR_DOWNTO
95158: IFFALSE 99254
// begin wait ( 5 ) ;
95160: LD_INT 5
95162: PPUSH
95163: CALL_OW 67
// tmp := [ ] ;
95167: LD_ADDR_VAR 0 14
95171: PUSH
95172: EMPTY
95173: ST_TO_ADDR
// attacking := false ;
95174: LD_ADDR_VAR 0 29
95178: PUSH
95179: LD_INT 0
95181: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
95182: LD_VAR 0 4
95186: PUSH
95187: LD_VAR 0 7
95191: ARRAY
95192: PPUSH
95193: CALL_OW 301
95197: PUSH
95198: LD_VAR 0 4
95202: PUSH
95203: LD_VAR 0 7
95207: ARRAY
95208: NOT
95209: OR
95210: IFFALSE 95319
// begin if GetType ( group [ i ] ) = unit_human then
95212: LD_VAR 0 4
95216: PUSH
95217: LD_VAR 0 7
95221: ARRAY
95222: PPUSH
95223: CALL_OW 247
95227: PUSH
95228: LD_INT 1
95230: EQUAL
95231: IFFALSE 95277
// begin to_heal := to_heal diff group [ i ] ;
95233: LD_ADDR_VAR 0 30
95237: PUSH
95238: LD_VAR 0 30
95242: PUSH
95243: LD_VAR 0 4
95247: PUSH
95248: LD_VAR 0 7
95252: ARRAY
95253: DIFF
95254: ST_TO_ADDR
// healers := healers diff group [ i ] ;
95255: LD_ADDR_VAR 0 31
95259: PUSH
95260: LD_VAR 0 31
95264: PUSH
95265: LD_VAR 0 4
95269: PUSH
95270: LD_VAR 0 7
95274: ARRAY
95275: DIFF
95276: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
95277: LD_ADDR_VAR 0 4
95281: PUSH
95282: LD_VAR 0 4
95286: PPUSH
95287: LD_VAR 0 7
95291: PPUSH
95292: CALL_OW 3
95296: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
95297: LD_ADDR_VAR 0 16
95301: PUSH
95302: LD_VAR 0 16
95306: PPUSH
95307: LD_VAR 0 7
95311: PPUSH
95312: CALL_OW 3
95316: ST_TO_ADDR
// continue ;
95317: GO 95157
// end ; if f_repair then
95319: LD_VAR 0 22
95323: IFFALSE 95812
// begin if GetType ( group [ i ] ) = unit_vehicle then
95325: LD_VAR 0 4
95329: PUSH
95330: LD_VAR 0 7
95334: ARRAY
95335: PPUSH
95336: CALL_OW 247
95340: PUSH
95341: LD_INT 2
95343: EQUAL
95344: IFFALSE 95534
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
95346: LD_VAR 0 4
95350: PUSH
95351: LD_VAR 0 7
95355: ARRAY
95356: PPUSH
95357: CALL_OW 256
95361: PUSH
95362: LD_INT 700
95364: LESS
95365: PUSH
95366: LD_VAR 0 4
95370: PUSH
95371: LD_VAR 0 7
95375: ARRAY
95376: PUSH
95377: LD_VAR 0 32
95381: IN
95382: NOT
95383: AND
95384: IFFALSE 95408
// to_repair := to_repair union group [ i ] ;
95386: LD_ADDR_VAR 0 32
95390: PUSH
95391: LD_VAR 0 32
95395: PUSH
95396: LD_VAR 0 4
95400: PUSH
95401: LD_VAR 0 7
95405: ARRAY
95406: UNION
95407: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
95408: LD_VAR 0 4
95412: PUSH
95413: LD_VAR 0 7
95417: ARRAY
95418: PPUSH
95419: CALL_OW 256
95423: PUSH
95424: LD_INT 1000
95426: EQUAL
95427: PUSH
95428: LD_VAR 0 4
95432: PUSH
95433: LD_VAR 0 7
95437: ARRAY
95438: PUSH
95439: LD_VAR 0 32
95443: IN
95444: AND
95445: IFFALSE 95469
// to_repair := to_repair diff group [ i ] ;
95447: LD_ADDR_VAR 0 32
95451: PUSH
95452: LD_VAR 0 32
95456: PUSH
95457: LD_VAR 0 4
95461: PUSH
95462: LD_VAR 0 7
95466: ARRAY
95467: DIFF
95468: ST_TO_ADDR
// if group [ i ] in to_repair then
95469: LD_VAR 0 4
95473: PUSH
95474: LD_VAR 0 7
95478: ARRAY
95479: PUSH
95480: LD_VAR 0 32
95484: IN
95485: IFFALSE 95532
// begin if not IsInArea ( group [ i ] , f_repair ) then
95487: LD_VAR 0 4
95491: PUSH
95492: LD_VAR 0 7
95496: ARRAY
95497: PPUSH
95498: LD_VAR 0 22
95502: PPUSH
95503: CALL_OW 308
95507: NOT
95508: IFFALSE 95530
// ComMoveToArea ( group [ i ] , f_repair ) ;
95510: LD_VAR 0 4
95514: PUSH
95515: LD_VAR 0 7
95519: ARRAY
95520: PPUSH
95521: LD_VAR 0 22
95525: PPUSH
95526: CALL_OW 113
// continue ;
95530: GO 95157
// end ; end else
95532: GO 95812
// if group [ i ] in repairs then
95534: LD_VAR 0 4
95538: PUSH
95539: LD_VAR 0 7
95543: ARRAY
95544: PUSH
95545: LD_VAR 0 33
95549: IN
95550: IFFALSE 95812
// begin if IsInUnit ( group [ i ] ) then
95552: LD_VAR 0 4
95556: PUSH
95557: LD_VAR 0 7
95561: ARRAY
95562: PPUSH
95563: CALL_OW 310
95567: IFFALSE 95635
// begin z := IsInUnit ( group [ i ] ) ;
95569: LD_ADDR_VAR 0 13
95573: PUSH
95574: LD_VAR 0 4
95578: PUSH
95579: LD_VAR 0 7
95583: ARRAY
95584: PPUSH
95585: CALL_OW 310
95589: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
95590: LD_VAR 0 13
95594: PUSH
95595: LD_VAR 0 32
95599: IN
95600: PUSH
95601: LD_VAR 0 13
95605: PPUSH
95606: LD_VAR 0 22
95610: PPUSH
95611: CALL_OW 308
95615: AND
95616: IFFALSE 95633
// ComExitVehicle ( group [ i ] ) ;
95618: LD_VAR 0 4
95622: PUSH
95623: LD_VAR 0 7
95627: ARRAY
95628: PPUSH
95629: CALL_OW 121
// end else
95633: GO 95812
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
95635: LD_ADDR_VAR 0 13
95639: PUSH
95640: LD_VAR 0 4
95644: PPUSH
95645: LD_INT 95
95647: PUSH
95648: LD_VAR 0 22
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PUSH
95657: LD_INT 58
95659: PUSH
95660: EMPTY
95661: LIST
95662: PUSH
95663: EMPTY
95664: LIST
95665: LIST
95666: PPUSH
95667: CALL_OW 72
95671: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
95672: LD_VAR 0 4
95676: PUSH
95677: LD_VAR 0 7
95681: ARRAY
95682: PPUSH
95683: CALL_OW 314
95687: NOT
95688: IFFALSE 95810
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
95690: LD_ADDR_VAR 0 10
95694: PUSH
95695: LD_VAR 0 13
95699: PPUSH
95700: LD_VAR 0 4
95704: PUSH
95705: LD_VAR 0 7
95709: ARRAY
95710: PPUSH
95711: CALL_OW 74
95715: ST_TO_ADDR
// if not x then
95716: LD_VAR 0 10
95720: NOT
95721: IFFALSE 95725
// continue ;
95723: GO 95157
// if GetLives ( x ) < 1000 then
95725: LD_VAR 0 10
95729: PPUSH
95730: CALL_OW 256
95734: PUSH
95735: LD_INT 1000
95737: LESS
95738: IFFALSE 95762
// ComRepairVehicle ( group [ i ] , x ) else
95740: LD_VAR 0 4
95744: PUSH
95745: LD_VAR 0 7
95749: ARRAY
95750: PPUSH
95751: LD_VAR 0 10
95755: PPUSH
95756: CALL_OW 129
95760: GO 95810
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
95762: LD_VAR 0 23
95766: PUSH
95767: LD_VAR 0 4
95771: PUSH
95772: LD_VAR 0 7
95776: ARRAY
95777: PPUSH
95778: CALL_OW 256
95782: PUSH
95783: LD_INT 1000
95785: LESS
95786: AND
95787: NOT
95788: IFFALSE 95810
// ComEnterUnit ( group [ i ] , x ) ;
95790: LD_VAR 0 4
95794: PUSH
95795: LD_VAR 0 7
95799: ARRAY
95800: PPUSH
95801: LD_VAR 0 10
95805: PPUSH
95806: CALL_OW 120
// end ; continue ;
95810: GO 95157
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
95812: LD_VAR 0 23
95816: PUSH
95817: LD_VAR 0 4
95821: PUSH
95822: LD_VAR 0 7
95826: ARRAY
95827: PPUSH
95828: CALL_OW 247
95832: PUSH
95833: LD_INT 1
95835: EQUAL
95836: AND
95837: IFFALSE 96315
// begin if group [ i ] in healers then
95839: LD_VAR 0 4
95843: PUSH
95844: LD_VAR 0 7
95848: ARRAY
95849: PUSH
95850: LD_VAR 0 31
95854: IN
95855: IFFALSE 96128
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
95857: LD_VAR 0 4
95861: PUSH
95862: LD_VAR 0 7
95866: ARRAY
95867: PPUSH
95868: LD_VAR 0 23
95872: PPUSH
95873: CALL_OW 308
95877: NOT
95878: PUSH
95879: LD_VAR 0 4
95883: PUSH
95884: LD_VAR 0 7
95888: ARRAY
95889: PPUSH
95890: CALL_OW 314
95894: NOT
95895: AND
95896: IFFALSE 95920
// ComMoveToArea ( group [ i ] , f_heal ) else
95898: LD_VAR 0 4
95902: PUSH
95903: LD_VAR 0 7
95907: ARRAY
95908: PPUSH
95909: LD_VAR 0 23
95913: PPUSH
95914: CALL_OW 113
95918: GO 96126
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
95920: LD_VAR 0 4
95924: PUSH
95925: LD_VAR 0 7
95929: ARRAY
95930: PPUSH
95931: CALL 94558 0 1
95935: PPUSH
95936: CALL_OW 256
95940: PUSH
95941: LD_INT 1000
95943: EQUAL
95944: IFFALSE 95963
// ComStop ( group [ i ] ) else
95946: LD_VAR 0 4
95950: PUSH
95951: LD_VAR 0 7
95955: ARRAY
95956: PPUSH
95957: CALL_OW 141
95961: GO 96126
// if not HasTask ( group [ i ] ) and to_heal then
95963: LD_VAR 0 4
95967: PUSH
95968: LD_VAR 0 7
95972: ARRAY
95973: PPUSH
95974: CALL_OW 314
95978: NOT
95979: PUSH
95980: LD_VAR 0 30
95984: AND
95985: IFFALSE 96126
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
95987: LD_ADDR_VAR 0 13
95991: PUSH
95992: LD_VAR 0 30
95996: PPUSH
95997: LD_INT 3
95999: PUSH
96000: LD_INT 54
96002: PUSH
96003: EMPTY
96004: LIST
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PPUSH
96010: CALL_OW 72
96014: PPUSH
96015: LD_VAR 0 4
96019: PUSH
96020: LD_VAR 0 7
96024: ARRAY
96025: PPUSH
96026: CALL_OW 74
96030: ST_TO_ADDR
// if z then
96031: LD_VAR 0 13
96035: IFFALSE 96126
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
96037: LD_INT 91
96039: PUSH
96040: LD_VAR 0 13
96044: PUSH
96045: LD_INT 10
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: LIST
96052: PUSH
96053: LD_INT 81
96055: PUSH
96056: LD_VAR 0 13
96060: PPUSH
96061: CALL_OW 255
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PPUSH
96074: CALL_OW 69
96078: PUSH
96079: LD_INT 0
96081: EQUAL
96082: IFFALSE 96106
// ComHeal ( group [ i ] , z ) else
96084: LD_VAR 0 4
96088: PUSH
96089: LD_VAR 0 7
96093: ARRAY
96094: PPUSH
96095: LD_VAR 0 13
96099: PPUSH
96100: CALL_OW 128
96104: GO 96126
// ComMoveToArea ( group [ i ] , f_heal ) ;
96106: LD_VAR 0 4
96110: PUSH
96111: LD_VAR 0 7
96115: ARRAY
96116: PPUSH
96117: LD_VAR 0 23
96121: PPUSH
96122: CALL_OW 113
// end ; continue ;
96126: GO 95157
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
96128: LD_VAR 0 4
96132: PUSH
96133: LD_VAR 0 7
96137: ARRAY
96138: PPUSH
96139: CALL_OW 256
96143: PUSH
96144: LD_INT 700
96146: LESS
96147: PUSH
96148: LD_VAR 0 4
96152: PUSH
96153: LD_VAR 0 7
96157: ARRAY
96158: PUSH
96159: LD_VAR 0 30
96163: IN
96164: NOT
96165: AND
96166: IFFALSE 96190
// to_heal := to_heal union group [ i ] ;
96168: LD_ADDR_VAR 0 30
96172: PUSH
96173: LD_VAR 0 30
96177: PUSH
96178: LD_VAR 0 4
96182: PUSH
96183: LD_VAR 0 7
96187: ARRAY
96188: UNION
96189: ST_TO_ADDR
// if group [ i ] in to_heal then
96190: LD_VAR 0 4
96194: PUSH
96195: LD_VAR 0 7
96199: ARRAY
96200: PUSH
96201: LD_VAR 0 30
96205: IN
96206: IFFALSE 96315
// begin if GetLives ( group [ i ] ) = 1000 then
96208: LD_VAR 0 4
96212: PUSH
96213: LD_VAR 0 7
96217: ARRAY
96218: PPUSH
96219: CALL_OW 256
96223: PUSH
96224: LD_INT 1000
96226: EQUAL
96227: IFFALSE 96253
// to_heal := to_heal diff group [ i ] else
96229: LD_ADDR_VAR 0 30
96233: PUSH
96234: LD_VAR 0 30
96238: PUSH
96239: LD_VAR 0 4
96243: PUSH
96244: LD_VAR 0 7
96248: ARRAY
96249: DIFF
96250: ST_TO_ADDR
96251: GO 96315
// begin if not IsInArea ( group [ i ] , to_heal ) then
96253: LD_VAR 0 4
96257: PUSH
96258: LD_VAR 0 7
96262: ARRAY
96263: PPUSH
96264: LD_VAR 0 30
96268: PPUSH
96269: CALL_OW 308
96273: NOT
96274: IFFALSE 96298
// ComMoveToArea ( group [ i ] , f_heal ) else
96276: LD_VAR 0 4
96280: PUSH
96281: LD_VAR 0 7
96285: ARRAY
96286: PPUSH
96287: LD_VAR 0 23
96291: PPUSH
96292: CALL_OW 113
96296: GO 96313
// ComHold ( group [ i ] ) ;
96298: LD_VAR 0 4
96302: PUSH
96303: LD_VAR 0 7
96307: ARRAY
96308: PPUSH
96309: CALL_OW 140
// continue ;
96313: GO 95157
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
96315: LD_VAR 0 4
96319: PUSH
96320: LD_VAR 0 7
96324: ARRAY
96325: PPUSH
96326: LD_INT 10
96328: PPUSH
96329: CALL 92955 0 2
96333: NOT
96334: PUSH
96335: LD_VAR 0 16
96339: PUSH
96340: LD_VAR 0 7
96344: ARRAY
96345: PUSH
96346: EMPTY
96347: EQUAL
96348: NOT
96349: AND
96350: IFFALSE 96616
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
96352: LD_VAR 0 4
96356: PUSH
96357: LD_VAR 0 7
96361: ARRAY
96362: PPUSH
96363: CALL_OW 262
96367: PUSH
96368: LD_INT 1
96370: PUSH
96371: LD_INT 2
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: IN
96378: IFFALSE 96419
// if GetFuel ( group [ i ] ) < 10 then
96380: LD_VAR 0 4
96384: PUSH
96385: LD_VAR 0 7
96389: ARRAY
96390: PPUSH
96391: CALL_OW 261
96395: PUSH
96396: LD_INT 10
96398: LESS
96399: IFFALSE 96419
// SetFuel ( group [ i ] , 12 ) ;
96401: LD_VAR 0 4
96405: PUSH
96406: LD_VAR 0 7
96410: ARRAY
96411: PPUSH
96412: LD_INT 12
96414: PPUSH
96415: CALL_OW 240
// if units_path [ i ] then
96419: LD_VAR 0 16
96423: PUSH
96424: LD_VAR 0 7
96428: ARRAY
96429: IFFALSE 96614
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
96431: LD_VAR 0 4
96435: PUSH
96436: LD_VAR 0 7
96440: ARRAY
96441: PPUSH
96442: LD_VAR 0 16
96446: PUSH
96447: LD_VAR 0 7
96451: ARRAY
96452: PUSH
96453: LD_INT 1
96455: ARRAY
96456: PUSH
96457: LD_INT 1
96459: ARRAY
96460: PPUSH
96461: LD_VAR 0 16
96465: PUSH
96466: LD_VAR 0 7
96470: ARRAY
96471: PUSH
96472: LD_INT 1
96474: ARRAY
96475: PUSH
96476: LD_INT 2
96478: ARRAY
96479: PPUSH
96480: CALL_OW 297
96484: PUSH
96485: LD_INT 6
96487: GREATER
96488: IFFALSE 96563
// begin if not HasTask ( group [ i ] ) then
96490: LD_VAR 0 4
96494: PUSH
96495: LD_VAR 0 7
96499: ARRAY
96500: PPUSH
96501: CALL_OW 314
96505: NOT
96506: IFFALSE 96561
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
96508: LD_VAR 0 4
96512: PUSH
96513: LD_VAR 0 7
96517: ARRAY
96518: PPUSH
96519: LD_VAR 0 16
96523: PUSH
96524: LD_VAR 0 7
96528: ARRAY
96529: PUSH
96530: LD_INT 1
96532: ARRAY
96533: PUSH
96534: LD_INT 1
96536: ARRAY
96537: PPUSH
96538: LD_VAR 0 16
96542: PUSH
96543: LD_VAR 0 7
96547: ARRAY
96548: PUSH
96549: LD_INT 1
96551: ARRAY
96552: PUSH
96553: LD_INT 2
96555: ARRAY
96556: PPUSH
96557: CALL_OW 114
// end else
96561: GO 96614
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
96563: LD_ADDR_VAR 0 15
96567: PUSH
96568: LD_VAR 0 16
96572: PUSH
96573: LD_VAR 0 7
96577: ARRAY
96578: PPUSH
96579: LD_INT 1
96581: PPUSH
96582: CALL_OW 3
96586: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
96587: LD_ADDR_VAR 0 16
96591: PUSH
96592: LD_VAR 0 16
96596: PPUSH
96597: LD_VAR 0 7
96601: PPUSH
96602: LD_VAR 0 15
96606: PPUSH
96607: CALL_OW 1
96611: ST_TO_ADDR
// continue ;
96612: GO 95157
// end ; end ; end else
96614: GO 99252
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
96616: LD_ADDR_VAR 0 14
96620: PUSH
96621: LD_INT 81
96623: PUSH
96624: LD_VAR 0 4
96628: PUSH
96629: LD_VAR 0 7
96633: ARRAY
96634: PPUSH
96635: CALL_OW 255
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PPUSH
96644: CALL_OW 69
96648: ST_TO_ADDR
// if not tmp then
96649: LD_VAR 0 14
96653: NOT
96654: IFFALSE 96658
// continue ;
96656: GO 95157
// if f_ignore_area then
96658: LD_VAR 0 17
96662: IFFALSE 96750
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
96664: LD_ADDR_VAR 0 15
96668: PUSH
96669: LD_VAR 0 14
96673: PPUSH
96674: LD_INT 3
96676: PUSH
96677: LD_INT 92
96679: PUSH
96680: LD_VAR 0 17
96684: PUSH
96685: LD_INT 1
96687: ARRAY
96688: PUSH
96689: LD_VAR 0 17
96693: PUSH
96694: LD_INT 2
96696: ARRAY
96697: PUSH
96698: LD_VAR 0 17
96702: PUSH
96703: LD_INT 3
96705: ARRAY
96706: PUSH
96707: EMPTY
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: PUSH
96713: EMPTY
96714: LIST
96715: LIST
96716: PPUSH
96717: CALL_OW 72
96721: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
96722: LD_VAR 0 14
96726: PUSH
96727: LD_VAR 0 15
96731: DIFF
96732: IFFALSE 96750
// tmp := tmp diff tmp2 ;
96734: LD_ADDR_VAR 0 14
96738: PUSH
96739: LD_VAR 0 14
96743: PUSH
96744: LD_VAR 0 15
96748: DIFF
96749: ST_TO_ADDR
// end ; if not f_murder then
96750: LD_VAR 0 20
96754: NOT
96755: IFFALSE 96813
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
96757: LD_ADDR_VAR 0 15
96761: PUSH
96762: LD_VAR 0 14
96766: PPUSH
96767: LD_INT 3
96769: PUSH
96770: LD_INT 50
96772: PUSH
96773: EMPTY
96774: LIST
96775: PUSH
96776: EMPTY
96777: LIST
96778: LIST
96779: PPUSH
96780: CALL_OW 72
96784: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
96785: LD_VAR 0 14
96789: PUSH
96790: LD_VAR 0 15
96794: DIFF
96795: IFFALSE 96813
// tmp := tmp diff tmp2 ;
96797: LD_ADDR_VAR 0 14
96801: PUSH
96802: LD_VAR 0 14
96806: PUSH
96807: LD_VAR 0 15
96811: DIFF
96812: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
96813: LD_ADDR_VAR 0 14
96817: PUSH
96818: LD_VAR 0 4
96822: PUSH
96823: LD_VAR 0 7
96827: ARRAY
96828: PPUSH
96829: LD_VAR 0 14
96833: PPUSH
96834: LD_INT 1
96836: PPUSH
96837: LD_INT 1
96839: PPUSH
96840: CALL 66622 0 4
96844: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
96845: LD_VAR 0 4
96849: PUSH
96850: LD_VAR 0 7
96854: ARRAY
96855: PPUSH
96856: CALL_OW 257
96860: PUSH
96861: LD_INT 1
96863: EQUAL
96864: IFFALSE 97312
// begin if WantPlant ( group [ i ] ) then
96866: LD_VAR 0 4
96870: PUSH
96871: LD_VAR 0 7
96875: ARRAY
96876: PPUSH
96877: CALL 66123 0 1
96881: IFFALSE 96885
// continue ;
96883: GO 95157
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
96885: LD_VAR 0 18
96889: PUSH
96890: LD_VAR 0 4
96894: PUSH
96895: LD_VAR 0 7
96899: ARRAY
96900: PPUSH
96901: CALL_OW 310
96905: NOT
96906: AND
96907: PUSH
96908: LD_VAR 0 14
96912: PUSH
96913: LD_INT 1
96915: ARRAY
96916: PUSH
96917: LD_VAR 0 14
96921: PPUSH
96922: LD_INT 21
96924: PUSH
96925: LD_INT 2
96927: PUSH
96928: EMPTY
96929: LIST
96930: LIST
96931: PUSH
96932: LD_INT 58
96934: PUSH
96935: EMPTY
96936: LIST
96937: PUSH
96938: EMPTY
96939: LIST
96940: LIST
96941: PPUSH
96942: CALL_OW 72
96946: IN
96947: AND
96948: IFFALSE 96984
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
96950: LD_VAR 0 4
96954: PUSH
96955: LD_VAR 0 7
96959: ARRAY
96960: PPUSH
96961: LD_VAR 0 14
96965: PUSH
96966: LD_INT 1
96968: ARRAY
96969: PPUSH
96970: CALL_OW 120
// attacking := true ;
96974: LD_ADDR_VAR 0 29
96978: PUSH
96979: LD_INT 1
96981: ST_TO_ADDR
// continue ;
96982: GO 95157
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
96984: LD_VAR 0 26
96988: PUSH
96989: LD_VAR 0 4
96993: PUSH
96994: LD_VAR 0 7
96998: ARRAY
96999: PPUSH
97000: CALL_OW 257
97004: PUSH
97005: LD_INT 1
97007: EQUAL
97008: AND
97009: PUSH
97010: LD_VAR 0 4
97014: PUSH
97015: LD_VAR 0 7
97019: ARRAY
97020: PPUSH
97021: CALL_OW 256
97025: PUSH
97026: LD_INT 800
97028: LESS
97029: AND
97030: PUSH
97031: LD_VAR 0 4
97035: PUSH
97036: LD_VAR 0 7
97040: ARRAY
97041: PPUSH
97042: CALL_OW 318
97046: NOT
97047: AND
97048: IFFALSE 97065
// ComCrawl ( group [ i ] ) ;
97050: LD_VAR 0 4
97054: PUSH
97055: LD_VAR 0 7
97059: ARRAY
97060: PPUSH
97061: CALL_OW 137
// if f_mines then
97065: LD_VAR 0 21
97069: IFFALSE 97312
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
97071: LD_VAR 0 14
97075: PUSH
97076: LD_INT 1
97078: ARRAY
97079: PPUSH
97080: CALL_OW 247
97084: PUSH
97085: LD_INT 3
97087: EQUAL
97088: PUSH
97089: LD_VAR 0 14
97093: PUSH
97094: LD_INT 1
97096: ARRAY
97097: PUSH
97098: LD_VAR 0 27
97102: IN
97103: NOT
97104: AND
97105: IFFALSE 97312
// begin x := GetX ( tmp [ 1 ] ) ;
97107: LD_ADDR_VAR 0 10
97111: PUSH
97112: LD_VAR 0 14
97116: PUSH
97117: LD_INT 1
97119: ARRAY
97120: PPUSH
97121: CALL_OW 250
97125: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
97126: LD_ADDR_VAR 0 11
97130: PUSH
97131: LD_VAR 0 14
97135: PUSH
97136: LD_INT 1
97138: ARRAY
97139: PPUSH
97140: CALL_OW 251
97144: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
97145: LD_ADDR_VAR 0 12
97149: PUSH
97150: LD_VAR 0 4
97154: PUSH
97155: LD_VAR 0 7
97159: ARRAY
97160: PPUSH
97161: CALL 93040 0 1
97165: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
97166: LD_VAR 0 4
97170: PUSH
97171: LD_VAR 0 7
97175: ARRAY
97176: PPUSH
97177: LD_VAR 0 10
97181: PPUSH
97182: LD_VAR 0 11
97186: PPUSH
97187: LD_VAR 0 14
97191: PUSH
97192: LD_INT 1
97194: ARRAY
97195: PPUSH
97196: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
97200: LD_VAR 0 4
97204: PUSH
97205: LD_VAR 0 7
97209: ARRAY
97210: PPUSH
97211: LD_VAR 0 10
97215: PPUSH
97216: LD_VAR 0 12
97220: PPUSH
97221: LD_INT 7
97223: PPUSH
97224: CALL_OW 272
97228: PPUSH
97229: LD_VAR 0 11
97233: PPUSH
97234: LD_VAR 0 12
97238: PPUSH
97239: LD_INT 7
97241: PPUSH
97242: CALL_OW 273
97246: PPUSH
97247: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
97251: LD_VAR 0 4
97255: PUSH
97256: LD_VAR 0 7
97260: ARRAY
97261: PPUSH
97262: LD_INT 71
97264: PPUSH
97265: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
97269: LD_ADDR_VAR 0 27
97273: PUSH
97274: LD_VAR 0 27
97278: PPUSH
97279: LD_VAR 0 27
97283: PUSH
97284: LD_INT 1
97286: PLUS
97287: PPUSH
97288: LD_VAR 0 14
97292: PUSH
97293: LD_INT 1
97295: ARRAY
97296: PPUSH
97297: CALL_OW 1
97301: ST_TO_ADDR
// attacking := true ;
97302: LD_ADDR_VAR 0 29
97306: PUSH
97307: LD_INT 1
97309: ST_TO_ADDR
// continue ;
97310: GO 95157
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
97312: LD_VAR 0 4
97316: PUSH
97317: LD_VAR 0 7
97321: ARRAY
97322: PPUSH
97323: CALL_OW 257
97327: PUSH
97328: LD_INT 17
97330: EQUAL
97331: PUSH
97332: LD_VAR 0 4
97336: PUSH
97337: LD_VAR 0 7
97341: ARRAY
97342: PPUSH
97343: CALL_OW 110
97347: PUSH
97348: LD_INT 71
97350: EQUAL
97351: NOT
97352: AND
97353: IFFALSE 97499
// begin attacking := false ;
97355: LD_ADDR_VAR 0 29
97359: PUSH
97360: LD_INT 0
97362: ST_TO_ADDR
// k := 5 ;
97363: LD_ADDR_VAR 0 9
97367: PUSH
97368: LD_INT 5
97370: ST_TO_ADDR
// if tmp < k then
97371: LD_VAR 0 14
97375: PUSH
97376: LD_VAR 0 9
97380: LESS
97381: IFFALSE 97393
// k := tmp ;
97383: LD_ADDR_VAR 0 9
97387: PUSH
97388: LD_VAR 0 14
97392: ST_TO_ADDR
// for j = 1 to k do
97393: LD_ADDR_VAR 0 8
97397: PUSH
97398: DOUBLE
97399: LD_INT 1
97401: DEC
97402: ST_TO_ADDR
97403: LD_VAR 0 9
97407: PUSH
97408: FOR_TO
97409: IFFALSE 97497
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
97411: LD_VAR 0 14
97415: PUSH
97416: LD_VAR 0 8
97420: ARRAY
97421: PUSH
97422: LD_VAR 0 14
97426: PPUSH
97427: LD_INT 58
97429: PUSH
97430: EMPTY
97431: LIST
97432: PPUSH
97433: CALL_OW 72
97437: IN
97438: NOT
97439: IFFALSE 97495
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
97441: LD_VAR 0 4
97445: PUSH
97446: LD_VAR 0 7
97450: ARRAY
97451: PPUSH
97452: LD_VAR 0 14
97456: PUSH
97457: LD_VAR 0 8
97461: ARRAY
97462: PPUSH
97463: CALL_OW 115
// attacking := true ;
97467: LD_ADDR_VAR 0 29
97471: PUSH
97472: LD_INT 1
97474: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
97475: LD_VAR 0 4
97479: PUSH
97480: LD_VAR 0 7
97484: ARRAY
97485: PPUSH
97486: LD_INT 71
97488: PPUSH
97489: CALL_OW 109
// continue ;
97493: GO 97408
// end ; end ;
97495: GO 97408
97497: POP
97498: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
97499: LD_VAR 0 4
97503: PUSH
97504: LD_VAR 0 7
97508: ARRAY
97509: PPUSH
97510: CALL_OW 257
97514: PUSH
97515: LD_INT 8
97517: EQUAL
97518: PUSH
97519: LD_VAR 0 4
97523: PUSH
97524: LD_VAR 0 7
97528: ARRAY
97529: PPUSH
97530: CALL_OW 264
97534: PUSH
97535: LD_INT 28
97537: PUSH
97538: LD_INT 45
97540: PUSH
97541: LD_INT 7
97543: PUSH
97544: LD_INT 47
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: IN
97553: OR
97554: IFFALSE 97784
// begin attacking := false ;
97556: LD_ADDR_VAR 0 29
97560: PUSH
97561: LD_INT 0
97563: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
97564: LD_VAR 0 14
97568: PUSH
97569: LD_INT 1
97571: ARRAY
97572: PPUSH
97573: CALL_OW 266
97577: PUSH
97578: LD_INT 32
97580: PUSH
97581: LD_INT 31
97583: PUSH
97584: LD_INT 33
97586: PUSH
97587: LD_INT 4
97589: PUSH
97590: LD_INT 5
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: LIST
97597: LIST
97598: LIST
97599: IN
97600: IFFALSE 97784
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
97602: LD_ADDR_VAR 0 9
97606: PUSH
97607: LD_VAR 0 14
97611: PUSH
97612: LD_INT 1
97614: ARRAY
97615: PPUSH
97616: CALL_OW 266
97620: PPUSH
97621: LD_VAR 0 14
97625: PUSH
97626: LD_INT 1
97628: ARRAY
97629: PPUSH
97630: CALL_OW 250
97634: PPUSH
97635: LD_VAR 0 14
97639: PUSH
97640: LD_INT 1
97642: ARRAY
97643: PPUSH
97644: CALL_OW 251
97648: PPUSH
97649: LD_VAR 0 14
97653: PUSH
97654: LD_INT 1
97656: ARRAY
97657: PPUSH
97658: CALL_OW 254
97662: PPUSH
97663: LD_VAR 0 14
97667: PUSH
97668: LD_INT 1
97670: ARRAY
97671: PPUSH
97672: CALL_OW 248
97676: PPUSH
97677: LD_INT 0
97679: PPUSH
97680: CALL 74416 0 6
97684: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
97685: LD_ADDR_VAR 0 8
97689: PUSH
97690: LD_VAR 0 4
97694: PUSH
97695: LD_VAR 0 7
97699: ARRAY
97700: PPUSH
97701: LD_VAR 0 9
97705: PPUSH
97706: CALL 93103 0 2
97710: ST_TO_ADDR
// if j then
97711: LD_VAR 0 8
97715: IFFALSE 97784
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
97717: LD_VAR 0 8
97721: PUSH
97722: LD_INT 1
97724: ARRAY
97725: PPUSH
97726: LD_VAR 0 8
97730: PUSH
97731: LD_INT 2
97733: ARRAY
97734: PPUSH
97735: CALL_OW 488
97739: IFFALSE 97784
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
97741: LD_VAR 0 4
97745: PUSH
97746: LD_VAR 0 7
97750: ARRAY
97751: PPUSH
97752: LD_VAR 0 8
97756: PUSH
97757: LD_INT 1
97759: ARRAY
97760: PPUSH
97761: LD_VAR 0 8
97765: PUSH
97766: LD_INT 2
97768: ARRAY
97769: PPUSH
97770: CALL_OW 116
// attacking := true ;
97774: LD_ADDR_VAR 0 29
97778: PUSH
97779: LD_INT 1
97781: ST_TO_ADDR
// continue ;
97782: GO 95157
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
97784: LD_VAR 0 4
97788: PUSH
97789: LD_VAR 0 7
97793: ARRAY
97794: PPUSH
97795: CALL_OW 265
97799: PUSH
97800: LD_INT 11
97802: EQUAL
97803: IFFALSE 98081
// begin k := 10 ;
97805: LD_ADDR_VAR 0 9
97809: PUSH
97810: LD_INT 10
97812: ST_TO_ADDR
// x := 0 ;
97813: LD_ADDR_VAR 0 10
97817: PUSH
97818: LD_INT 0
97820: ST_TO_ADDR
// if tmp < k then
97821: LD_VAR 0 14
97825: PUSH
97826: LD_VAR 0 9
97830: LESS
97831: IFFALSE 97843
// k := tmp ;
97833: LD_ADDR_VAR 0 9
97837: PUSH
97838: LD_VAR 0 14
97842: ST_TO_ADDR
// for j = k downto 1 do
97843: LD_ADDR_VAR 0 8
97847: PUSH
97848: DOUBLE
97849: LD_VAR 0 9
97853: INC
97854: ST_TO_ADDR
97855: LD_INT 1
97857: PUSH
97858: FOR_DOWNTO
97859: IFFALSE 97934
// begin if GetType ( tmp [ j ] ) = unit_human then
97861: LD_VAR 0 14
97865: PUSH
97866: LD_VAR 0 8
97870: ARRAY
97871: PPUSH
97872: CALL_OW 247
97876: PUSH
97877: LD_INT 1
97879: EQUAL
97880: IFFALSE 97932
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
97882: LD_VAR 0 4
97886: PUSH
97887: LD_VAR 0 7
97891: ARRAY
97892: PPUSH
97893: LD_VAR 0 14
97897: PUSH
97898: LD_VAR 0 8
97902: ARRAY
97903: PPUSH
97904: CALL 93374 0 2
// x := tmp [ j ] ;
97908: LD_ADDR_VAR 0 10
97912: PUSH
97913: LD_VAR 0 14
97917: PUSH
97918: LD_VAR 0 8
97922: ARRAY
97923: ST_TO_ADDR
// attacking := true ;
97924: LD_ADDR_VAR 0 29
97928: PUSH
97929: LD_INT 1
97931: ST_TO_ADDR
// end ; end ;
97932: GO 97858
97934: POP
97935: POP
// if not x then
97936: LD_VAR 0 10
97940: NOT
97941: IFFALSE 98081
// begin attacking := true ;
97943: LD_ADDR_VAR 0 29
97947: PUSH
97948: LD_INT 1
97950: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
97951: LD_VAR 0 4
97955: PUSH
97956: LD_VAR 0 7
97960: ARRAY
97961: PPUSH
97962: CALL_OW 250
97966: PPUSH
97967: LD_VAR 0 4
97971: PUSH
97972: LD_VAR 0 7
97976: ARRAY
97977: PPUSH
97978: CALL_OW 251
97982: PPUSH
97983: CALL_OW 546
97987: PUSH
97988: LD_INT 2
97990: ARRAY
97991: PUSH
97992: LD_VAR 0 14
97996: PUSH
97997: LD_INT 1
97999: ARRAY
98000: PPUSH
98001: CALL_OW 250
98005: PPUSH
98006: LD_VAR 0 14
98010: PUSH
98011: LD_INT 1
98013: ARRAY
98014: PPUSH
98015: CALL_OW 251
98019: PPUSH
98020: CALL_OW 546
98024: PUSH
98025: LD_INT 2
98027: ARRAY
98028: EQUAL
98029: IFFALSE 98057
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
98031: LD_VAR 0 4
98035: PUSH
98036: LD_VAR 0 7
98040: ARRAY
98041: PPUSH
98042: LD_VAR 0 14
98046: PUSH
98047: LD_INT 1
98049: ARRAY
98050: PPUSH
98051: CALL 93374 0 2
98055: GO 98081
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98057: LD_VAR 0 4
98061: PUSH
98062: LD_VAR 0 7
98066: ARRAY
98067: PPUSH
98068: LD_VAR 0 14
98072: PUSH
98073: LD_INT 1
98075: ARRAY
98076: PPUSH
98077: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
98081: LD_VAR 0 4
98085: PUSH
98086: LD_VAR 0 7
98090: ARRAY
98091: PPUSH
98092: CALL_OW 264
98096: PUSH
98097: LD_INT 29
98099: EQUAL
98100: IFFALSE 98466
// begin if WantsToAttack ( group [ i ] ) in bombed then
98102: LD_VAR 0 4
98106: PUSH
98107: LD_VAR 0 7
98111: ARRAY
98112: PPUSH
98113: CALL_OW 319
98117: PUSH
98118: LD_VAR 0 28
98122: IN
98123: IFFALSE 98127
// continue ;
98125: GO 95157
// k := 8 ;
98127: LD_ADDR_VAR 0 9
98131: PUSH
98132: LD_INT 8
98134: ST_TO_ADDR
// x := 0 ;
98135: LD_ADDR_VAR 0 10
98139: PUSH
98140: LD_INT 0
98142: ST_TO_ADDR
// if tmp < k then
98143: LD_VAR 0 14
98147: PUSH
98148: LD_VAR 0 9
98152: LESS
98153: IFFALSE 98165
// k := tmp ;
98155: LD_ADDR_VAR 0 9
98159: PUSH
98160: LD_VAR 0 14
98164: ST_TO_ADDR
// for j = 1 to k do
98165: LD_ADDR_VAR 0 8
98169: PUSH
98170: DOUBLE
98171: LD_INT 1
98173: DEC
98174: ST_TO_ADDR
98175: LD_VAR 0 9
98179: PUSH
98180: FOR_TO
98181: IFFALSE 98313
// begin if GetType ( tmp [ j ] ) = unit_building then
98183: LD_VAR 0 14
98187: PUSH
98188: LD_VAR 0 8
98192: ARRAY
98193: PPUSH
98194: CALL_OW 247
98198: PUSH
98199: LD_INT 3
98201: EQUAL
98202: IFFALSE 98311
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
98204: LD_VAR 0 14
98208: PUSH
98209: LD_VAR 0 8
98213: ARRAY
98214: PUSH
98215: LD_VAR 0 28
98219: IN
98220: NOT
98221: PUSH
98222: LD_VAR 0 14
98226: PUSH
98227: LD_VAR 0 8
98231: ARRAY
98232: PPUSH
98233: CALL_OW 313
98237: AND
98238: IFFALSE 98311
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98240: LD_VAR 0 4
98244: PUSH
98245: LD_VAR 0 7
98249: ARRAY
98250: PPUSH
98251: LD_VAR 0 14
98255: PUSH
98256: LD_VAR 0 8
98260: ARRAY
98261: PPUSH
98262: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
98266: LD_ADDR_VAR 0 28
98270: PUSH
98271: LD_VAR 0 28
98275: PPUSH
98276: LD_VAR 0 28
98280: PUSH
98281: LD_INT 1
98283: PLUS
98284: PPUSH
98285: LD_VAR 0 14
98289: PUSH
98290: LD_VAR 0 8
98294: ARRAY
98295: PPUSH
98296: CALL_OW 1
98300: ST_TO_ADDR
// attacking := true ;
98301: LD_ADDR_VAR 0 29
98305: PUSH
98306: LD_INT 1
98308: ST_TO_ADDR
// break ;
98309: GO 98313
// end ; end ;
98311: GO 98180
98313: POP
98314: POP
// if not attacking and f_attack_depot then
98315: LD_VAR 0 29
98319: NOT
98320: PUSH
98321: LD_VAR 0 25
98325: AND
98326: IFFALSE 98421
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98328: LD_ADDR_VAR 0 13
98332: PUSH
98333: LD_VAR 0 14
98337: PPUSH
98338: LD_INT 2
98340: PUSH
98341: LD_INT 30
98343: PUSH
98344: LD_INT 0
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: PUSH
98351: LD_INT 30
98353: PUSH
98354: LD_INT 1
98356: PUSH
98357: EMPTY
98358: LIST
98359: LIST
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: LIST
98365: PPUSH
98366: CALL_OW 72
98370: ST_TO_ADDR
// if z then
98371: LD_VAR 0 13
98375: IFFALSE 98421
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
98377: LD_VAR 0 4
98381: PUSH
98382: LD_VAR 0 7
98386: ARRAY
98387: PPUSH
98388: LD_VAR 0 13
98392: PPUSH
98393: LD_VAR 0 4
98397: PUSH
98398: LD_VAR 0 7
98402: ARRAY
98403: PPUSH
98404: CALL_OW 74
98408: PPUSH
98409: CALL_OW 115
// attacking := true ;
98413: LD_ADDR_VAR 0 29
98417: PUSH
98418: LD_INT 1
98420: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
98421: LD_VAR 0 4
98425: PUSH
98426: LD_VAR 0 7
98430: ARRAY
98431: PPUSH
98432: CALL_OW 256
98436: PUSH
98437: LD_INT 500
98439: LESS
98440: IFFALSE 98466
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98442: LD_VAR 0 4
98446: PUSH
98447: LD_VAR 0 7
98451: ARRAY
98452: PPUSH
98453: LD_VAR 0 14
98457: PUSH
98458: LD_INT 1
98460: ARRAY
98461: PPUSH
98462: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
98466: LD_VAR 0 4
98470: PUSH
98471: LD_VAR 0 7
98475: ARRAY
98476: PPUSH
98477: CALL_OW 264
98481: PUSH
98482: LD_INT 49
98484: EQUAL
98485: IFFALSE 98606
// begin if not HasTask ( group [ i ] ) then
98487: LD_VAR 0 4
98491: PUSH
98492: LD_VAR 0 7
98496: ARRAY
98497: PPUSH
98498: CALL_OW 314
98502: NOT
98503: IFFALSE 98606
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
98505: LD_ADDR_VAR 0 9
98509: PUSH
98510: LD_INT 81
98512: PUSH
98513: LD_VAR 0 4
98517: PUSH
98518: LD_VAR 0 7
98522: ARRAY
98523: PPUSH
98524: CALL_OW 255
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PPUSH
98533: CALL_OW 69
98537: PPUSH
98538: LD_VAR 0 4
98542: PUSH
98543: LD_VAR 0 7
98547: ARRAY
98548: PPUSH
98549: CALL_OW 74
98553: ST_TO_ADDR
// if k then
98554: LD_VAR 0 9
98558: IFFALSE 98606
// if GetDistUnits ( group [ i ] , k ) > 10 then
98560: LD_VAR 0 4
98564: PUSH
98565: LD_VAR 0 7
98569: ARRAY
98570: PPUSH
98571: LD_VAR 0 9
98575: PPUSH
98576: CALL_OW 296
98580: PUSH
98581: LD_INT 10
98583: GREATER
98584: IFFALSE 98606
// ComMoveUnit ( group [ i ] , k ) ;
98586: LD_VAR 0 4
98590: PUSH
98591: LD_VAR 0 7
98595: ARRAY
98596: PPUSH
98597: LD_VAR 0 9
98601: PPUSH
98602: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98606: LD_VAR 0 4
98610: PUSH
98611: LD_VAR 0 7
98615: ARRAY
98616: PPUSH
98617: CALL_OW 256
98621: PUSH
98622: LD_INT 250
98624: LESS
98625: PUSH
98626: LD_VAR 0 4
98630: PUSH
98631: LD_VAR 0 7
98635: ARRAY
98636: PUSH
98637: LD_INT 21
98639: PUSH
98640: LD_INT 2
98642: PUSH
98643: EMPTY
98644: LIST
98645: LIST
98646: PUSH
98647: LD_INT 23
98649: PUSH
98650: LD_INT 2
98652: PUSH
98653: EMPTY
98654: LIST
98655: LIST
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: PPUSH
98661: CALL_OW 69
98665: IN
98666: AND
98667: IFFALSE 98792
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
98669: LD_ADDR_VAR 0 9
98673: PUSH
98674: LD_OWVAR 3
98678: PUSH
98679: LD_VAR 0 4
98683: PUSH
98684: LD_VAR 0 7
98688: ARRAY
98689: DIFF
98690: PPUSH
98691: LD_VAR 0 4
98695: PUSH
98696: LD_VAR 0 7
98700: ARRAY
98701: PPUSH
98702: CALL_OW 74
98706: ST_TO_ADDR
// if not k then
98707: LD_VAR 0 9
98711: NOT
98712: IFFALSE 98716
// continue ;
98714: GO 95157
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
98716: LD_VAR 0 9
98720: PUSH
98721: LD_INT 81
98723: PUSH
98724: LD_VAR 0 4
98728: PUSH
98729: LD_VAR 0 7
98733: ARRAY
98734: PPUSH
98735: CALL_OW 255
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: PPUSH
98744: CALL_OW 69
98748: IN
98749: PUSH
98750: LD_VAR 0 9
98754: PPUSH
98755: LD_VAR 0 4
98759: PUSH
98760: LD_VAR 0 7
98764: ARRAY
98765: PPUSH
98766: CALL_OW 296
98770: PUSH
98771: LD_INT 5
98773: LESS
98774: AND
98775: IFFALSE 98792
// ComAutodestruct ( group [ i ] ) ;
98777: LD_VAR 0 4
98781: PUSH
98782: LD_VAR 0 7
98786: ARRAY
98787: PPUSH
98788: CALL 93272 0 1
// end ; if f_attack_depot then
98792: LD_VAR 0 25
98796: IFFALSE 98908
// begin k := 6 ;
98798: LD_ADDR_VAR 0 9
98802: PUSH
98803: LD_INT 6
98805: ST_TO_ADDR
// if tmp < k then
98806: LD_VAR 0 14
98810: PUSH
98811: LD_VAR 0 9
98815: LESS
98816: IFFALSE 98828
// k := tmp ;
98818: LD_ADDR_VAR 0 9
98822: PUSH
98823: LD_VAR 0 14
98827: ST_TO_ADDR
// for j = 1 to k do
98828: LD_ADDR_VAR 0 8
98832: PUSH
98833: DOUBLE
98834: LD_INT 1
98836: DEC
98837: ST_TO_ADDR
98838: LD_VAR 0 9
98842: PUSH
98843: FOR_TO
98844: IFFALSE 98906
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
98846: LD_VAR 0 8
98850: PPUSH
98851: CALL_OW 266
98855: PUSH
98856: LD_INT 0
98858: PUSH
98859: LD_INT 1
98861: PUSH
98862: EMPTY
98863: LIST
98864: LIST
98865: IN
98866: IFFALSE 98904
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98868: LD_VAR 0 4
98872: PUSH
98873: LD_VAR 0 7
98877: ARRAY
98878: PPUSH
98879: LD_VAR 0 14
98883: PUSH
98884: LD_VAR 0 8
98888: ARRAY
98889: PPUSH
98890: CALL_OW 115
// attacking := true ;
98894: LD_ADDR_VAR 0 29
98898: PUSH
98899: LD_INT 1
98901: ST_TO_ADDR
// break ;
98902: GO 98906
// end ;
98904: GO 98843
98906: POP
98907: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
98908: LD_VAR 0 4
98912: PUSH
98913: LD_VAR 0 7
98917: ARRAY
98918: PPUSH
98919: CALL_OW 302
98923: PUSH
98924: LD_VAR 0 29
98928: NOT
98929: AND
98930: IFFALSE 99252
// begin if GetTag ( group [ i ] ) = 71 then
98932: LD_VAR 0 4
98936: PUSH
98937: LD_VAR 0 7
98941: ARRAY
98942: PPUSH
98943: CALL_OW 110
98947: PUSH
98948: LD_INT 71
98950: EQUAL
98951: IFFALSE 98992
// begin if HasTask ( group [ i ] ) then
98953: LD_VAR 0 4
98957: PUSH
98958: LD_VAR 0 7
98962: ARRAY
98963: PPUSH
98964: CALL_OW 314
98968: IFFALSE 98974
// continue else
98970: GO 95157
98972: GO 98992
// SetTag ( group [ i ] , 0 ) ;
98974: LD_VAR 0 4
98978: PUSH
98979: LD_VAR 0 7
98983: ARRAY
98984: PPUSH
98985: LD_INT 0
98987: PPUSH
98988: CALL_OW 109
// end ; k := 8 ;
98992: LD_ADDR_VAR 0 9
98996: PUSH
98997: LD_INT 8
98999: ST_TO_ADDR
// x := 0 ;
99000: LD_ADDR_VAR 0 10
99004: PUSH
99005: LD_INT 0
99007: ST_TO_ADDR
// if tmp < k then
99008: LD_VAR 0 14
99012: PUSH
99013: LD_VAR 0 9
99017: LESS
99018: IFFALSE 99030
// k := tmp ;
99020: LD_ADDR_VAR 0 9
99024: PUSH
99025: LD_VAR 0 14
99029: ST_TO_ADDR
// for j = 1 to k do
99030: LD_ADDR_VAR 0 8
99034: PUSH
99035: DOUBLE
99036: LD_INT 1
99038: DEC
99039: ST_TO_ADDR
99040: LD_VAR 0 9
99044: PUSH
99045: FOR_TO
99046: IFFALSE 99144
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
99048: LD_VAR 0 14
99052: PUSH
99053: LD_VAR 0 8
99057: ARRAY
99058: PPUSH
99059: CALL_OW 247
99063: PUSH
99064: LD_INT 1
99066: EQUAL
99067: PUSH
99068: LD_VAR 0 14
99072: PUSH
99073: LD_VAR 0 8
99077: ARRAY
99078: PPUSH
99079: CALL_OW 256
99083: PUSH
99084: LD_INT 250
99086: LESS
99087: PUSH
99088: LD_VAR 0 20
99092: AND
99093: PUSH
99094: LD_VAR 0 20
99098: NOT
99099: PUSH
99100: LD_VAR 0 14
99104: PUSH
99105: LD_VAR 0 8
99109: ARRAY
99110: PPUSH
99111: CALL_OW 256
99115: PUSH
99116: LD_INT 250
99118: GREATEREQUAL
99119: AND
99120: OR
99121: AND
99122: IFFALSE 99142
// begin x := tmp [ j ] ;
99124: LD_ADDR_VAR 0 10
99128: PUSH
99129: LD_VAR 0 14
99133: PUSH
99134: LD_VAR 0 8
99138: ARRAY
99139: ST_TO_ADDR
// break ;
99140: GO 99144
// end ;
99142: GO 99045
99144: POP
99145: POP
// if x then
99146: LD_VAR 0 10
99150: IFFALSE 99174
// ComAttackUnit ( group [ i ] , x ) else
99152: LD_VAR 0 4
99156: PUSH
99157: LD_VAR 0 7
99161: ARRAY
99162: PPUSH
99163: LD_VAR 0 10
99167: PPUSH
99168: CALL_OW 115
99172: GO 99198
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99174: LD_VAR 0 4
99178: PUSH
99179: LD_VAR 0 7
99183: ARRAY
99184: PPUSH
99185: LD_VAR 0 14
99189: PUSH
99190: LD_INT 1
99192: ARRAY
99193: PPUSH
99194: CALL_OW 115
// if not HasTask ( group [ i ] ) then
99198: LD_VAR 0 4
99202: PUSH
99203: LD_VAR 0 7
99207: ARRAY
99208: PPUSH
99209: CALL_OW 314
99213: NOT
99214: IFFALSE 99252
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
99216: LD_VAR 0 4
99220: PUSH
99221: LD_VAR 0 7
99225: ARRAY
99226: PPUSH
99227: LD_VAR 0 14
99231: PPUSH
99232: LD_VAR 0 4
99236: PUSH
99237: LD_VAR 0 7
99241: ARRAY
99242: PPUSH
99243: CALL_OW 74
99247: PPUSH
99248: CALL_OW 115
// end ; end ; end ;
99252: GO 95157
99254: POP
99255: POP
// wait ( 0 0$1 ) ;
99256: LD_INT 35
99258: PPUSH
99259: CALL_OW 67
// until group = [ ] ;
99263: LD_VAR 0 4
99267: PUSH
99268: EMPTY
99269: EQUAL
99270: IFFALSE 95142
// end ;
99272: LD_VAR 0 2
99276: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
99277: LD_INT 0
99279: PPUSH
99280: PPUSH
99281: PPUSH
99282: PPUSH
// if not base_units then
99283: LD_VAR 0 1
99287: NOT
99288: IFFALSE 99292
// exit ;
99290: GO 99379
// result := false ;
99292: LD_ADDR_VAR 0 2
99296: PUSH
99297: LD_INT 0
99299: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
99300: LD_ADDR_VAR 0 5
99304: PUSH
99305: LD_VAR 0 1
99309: PPUSH
99310: LD_INT 21
99312: PUSH
99313: LD_INT 3
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PPUSH
99320: CALL_OW 72
99324: ST_TO_ADDR
// if not tmp then
99325: LD_VAR 0 5
99329: NOT
99330: IFFALSE 99334
// exit ;
99332: GO 99379
// for i in tmp do
99334: LD_ADDR_VAR 0 3
99338: PUSH
99339: LD_VAR 0 5
99343: PUSH
99344: FOR_IN
99345: IFFALSE 99377
// begin result := EnemyInRange ( i , 22 ) ;
99347: LD_ADDR_VAR 0 2
99351: PUSH
99352: LD_VAR 0 3
99356: PPUSH
99357: LD_INT 22
99359: PPUSH
99360: CALL 92955 0 2
99364: ST_TO_ADDR
// if result then
99365: LD_VAR 0 2
99369: IFFALSE 99375
// exit ;
99371: POP
99372: POP
99373: GO 99379
// end ;
99375: GO 99344
99377: POP
99378: POP
// end ;
99379: LD_VAR 0 2
99383: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
99384: LD_INT 0
99386: PPUSH
99387: PPUSH
// if not units then
99388: LD_VAR 0 1
99392: NOT
99393: IFFALSE 99397
// exit ;
99395: GO 99467
// result := [ ] ;
99397: LD_ADDR_VAR 0 3
99401: PUSH
99402: EMPTY
99403: ST_TO_ADDR
// for i in units do
99404: LD_ADDR_VAR 0 4
99408: PUSH
99409: LD_VAR 0 1
99413: PUSH
99414: FOR_IN
99415: IFFALSE 99465
// if GetTag ( i ) = tag then
99417: LD_VAR 0 4
99421: PPUSH
99422: CALL_OW 110
99426: PUSH
99427: LD_VAR 0 2
99431: EQUAL
99432: IFFALSE 99463
// result := Insert ( result , result + 1 , i ) ;
99434: LD_ADDR_VAR 0 3
99438: PUSH
99439: LD_VAR 0 3
99443: PPUSH
99444: LD_VAR 0 3
99448: PUSH
99449: LD_INT 1
99451: PLUS
99452: PPUSH
99453: LD_VAR 0 4
99457: PPUSH
99458: CALL_OW 2
99462: ST_TO_ADDR
99463: GO 99414
99465: POP
99466: POP
// end ;
99467: LD_VAR 0 3
99471: RET
// export function IsDriver ( un ) ; begin
99472: LD_INT 0
99474: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
99475: LD_ADDR_VAR 0 2
99479: PUSH
99480: LD_VAR 0 1
99484: PUSH
99485: LD_INT 55
99487: PUSH
99488: EMPTY
99489: LIST
99490: PPUSH
99491: CALL_OW 69
99495: IN
99496: ST_TO_ADDR
// end ;
99497: LD_VAR 0 2
99501: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
99502: LD_INT 0
99504: PPUSH
99505: PPUSH
// list := [ ] ;
99506: LD_ADDR_VAR 0 5
99510: PUSH
99511: EMPTY
99512: ST_TO_ADDR
// case d of 0 :
99513: LD_VAR 0 3
99517: PUSH
99518: LD_INT 0
99520: DOUBLE
99521: EQUAL
99522: IFTRUE 99526
99524: GO 99659
99526: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
99527: LD_ADDR_VAR 0 5
99531: PUSH
99532: LD_VAR 0 1
99536: PUSH
99537: LD_INT 4
99539: MINUS
99540: PUSH
99541: LD_VAR 0 2
99545: PUSH
99546: LD_INT 4
99548: MINUS
99549: PUSH
99550: LD_INT 2
99552: PUSH
99553: EMPTY
99554: LIST
99555: LIST
99556: LIST
99557: PUSH
99558: LD_VAR 0 1
99562: PUSH
99563: LD_INT 3
99565: MINUS
99566: PUSH
99567: LD_VAR 0 2
99571: PUSH
99572: LD_INT 1
99574: PUSH
99575: EMPTY
99576: LIST
99577: LIST
99578: LIST
99579: PUSH
99580: LD_VAR 0 1
99584: PUSH
99585: LD_INT 4
99587: PLUS
99588: PUSH
99589: LD_VAR 0 2
99593: PUSH
99594: LD_INT 4
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: LIST
99601: PUSH
99602: LD_VAR 0 1
99606: PUSH
99607: LD_INT 3
99609: PLUS
99610: PUSH
99611: LD_VAR 0 2
99615: PUSH
99616: LD_INT 3
99618: PLUS
99619: PUSH
99620: LD_INT 5
99622: PUSH
99623: EMPTY
99624: LIST
99625: LIST
99626: LIST
99627: PUSH
99628: LD_VAR 0 1
99632: PUSH
99633: LD_VAR 0 2
99637: PUSH
99638: LD_INT 4
99640: PLUS
99641: PUSH
99642: LD_INT 0
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: LIST
99649: PUSH
99650: EMPTY
99651: LIST
99652: LIST
99653: LIST
99654: LIST
99655: LIST
99656: ST_TO_ADDR
// end ; 1 :
99657: GO 100357
99659: LD_INT 1
99661: DOUBLE
99662: EQUAL
99663: IFTRUE 99667
99665: GO 99800
99667: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
99668: LD_ADDR_VAR 0 5
99672: PUSH
99673: LD_VAR 0 1
99677: PUSH
99678: LD_VAR 0 2
99682: PUSH
99683: LD_INT 4
99685: MINUS
99686: PUSH
99687: LD_INT 3
99689: PUSH
99690: EMPTY
99691: LIST
99692: LIST
99693: LIST
99694: PUSH
99695: LD_VAR 0 1
99699: PUSH
99700: LD_INT 3
99702: MINUS
99703: PUSH
99704: LD_VAR 0 2
99708: PUSH
99709: LD_INT 3
99711: MINUS
99712: PUSH
99713: LD_INT 2
99715: PUSH
99716: EMPTY
99717: LIST
99718: LIST
99719: LIST
99720: PUSH
99721: LD_VAR 0 1
99725: PUSH
99726: LD_INT 4
99728: MINUS
99729: PUSH
99730: LD_VAR 0 2
99734: PUSH
99735: LD_INT 1
99737: PUSH
99738: EMPTY
99739: LIST
99740: LIST
99741: LIST
99742: PUSH
99743: LD_VAR 0 1
99747: PUSH
99748: LD_VAR 0 2
99752: PUSH
99753: LD_INT 3
99755: PLUS
99756: PUSH
99757: LD_INT 0
99759: PUSH
99760: EMPTY
99761: LIST
99762: LIST
99763: LIST
99764: PUSH
99765: LD_VAR 0 1
99769: PUSH
99770: LD_INT 4
99772: PLUS
99773: PUSH
99774: LD_VAR 0 2
99778: PUSH
99779: LD_INT 4
99781: PLUS
99782: PUSH
99783: LD_INT 5
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: LIST
99790: PUSH
99791: EMPTY
99792: LIST
99793: LIST
99794: LIST
99795: LIST
99796: LIST
99797: ST_TO_ADDR
// end ; 2 :
99798: GO 100357
99800: LD_INT 2
99802: DOUBLE
99803: EQUAL
99804: IFTRUE 99808
99806: GO 99937
99808: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
99809: LD_ADDR_VAR 0 5
99813: PUSH
99814: LD_VAR 0 1
99818: PUSH
99819: LD_VAR 0 2
99823: PUSH
99824: LD_INT 3
99826: MINUS
99827: PUSH
99828: LD_INT 3
99830: PUSH
99831: EMPTY
99832: LIST
99833: LIST
99834: LIST
99835: PUSH
99836: LD_VAR 0 1
99840: PUSH
99841: LD_INT 4
99843: PLUS
99844: PUSH
99845: LD_VAR 0 2
99849: PUSH
99850: LD_INT 4
99852: PUSH
99853: EMPTY
99854: LIST
99855: LIST
99856: LIST
99857: PUSH
99858: LD_VAR 0 1
99862: PUSH
99863: LD_VAR 0 2
99867: PUSH
99868: LD_INT 4
99870: PLUS
99871: PUSH
99872: LD_INT 0
99874: PUSH
99875: EMPTY
99876: LIST
99877: LIST
99878: LIST
99879: PUSH
99880: LD_VAR 0 1
99884: PUSH
99885: LD_INT 3
99887: MINUS
99888: PUSH
99889: LD_VAR 0 2
99893: PUSH
99894: LD_INT 1
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: LIST
99901: PUSH
99902: LD_VAR 0 1
99906: PUSH
99907: LD_INT 4
99909: MINUS
99910: PUSH
99911: LD_VAR 0 2
99915: PUSH
99916: LD_INT 4
99918: MINUS
99919: PUSH
99920: LD_INT 2
99922: PUSH
99923: EMPTY
99924: LIST
99925: LIST
99926: LIST
99927: PUSH
99928: EMPTY
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: ST_TO_ADDR
// end ; 3 :
99935: GO 100357
99937: LD_INT 3
99939: DOUBLE
99940: EQUAL
99941: IFTRUE 99945
99943: GO 100078
99945: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
99946: LD_ADDR_VAR 0 5
99950: PUSH
99951: LD_VAR 0 1
99955: PUSH
99956: LD_INT 3
99958: PLUS
99959: PUSH
99960: LD_VAR 0 2
99964: PUSH
99965: LD_INT 4
99967: PUSH
99968: EMPTY
99969: LIST
99970: LIST
99971: LIST
99972: PUSH
99973: LD_VAR 0 1
99977: PUSH
99978: LD_INT 4
99980: PLUS
99981: PUSH
99982: LD_VAR 0 2
99986: PUSH
99987: LD_INT 4
99989: PLUS
99990: PUSH
99991: LD_INT 5
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: LIST
99998: PUSH
99999: LD_VAR 0 1
100003: PUSH
100004: LD_INT 4
100006: MINUS
100007: PUSH
100008: LD_VAR 0 2
100012: PUSH
100013: LD_INT 1
100015: PUSH
100016: EMPTY
100017: LIST
100018: LIST
100019: LIST
100020: PUSH
100021: LD_VAR 0 1
100025: PUSH
100026: LD_VAR 0 2
100030: PUSH
100031: LD_INT 4
100033: MINUS
100034: PUSH
100035: LD_INT 3
100037: PUSH
100038: EMPTY
100039: LIST
100040: LIST
100041: LIST
100042: PUSH
100043: LD_VAR 0 1
100047: PUSH
100048: LD_INT 3
100050: MINUS
100051: PUSH
100052: LD_VAR 0 2
100056: PUSH
100057: LD_INT 3
100059: MINUS
100060: PUSH
100061: LD_INT 2
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: LIST
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: ST_TO_ADDR
// end ; 4 :
100076: GO 100357
100078: LD_INT 4
100080: DOUBLE
100081: EQUAL
100082: IFTRUE 100086
100084: GO 100219
100086: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100087: LD_ADDR_VAR 0 5
100091: PUSH
100092: LD_VAR 0 1
100096: PUSH
100097: LD_VAR 0 2
100101: PUSH
100102: LD_INT 4
100104: PLUS
100105: PUSH
100106: LD_INT 0
100108: PUSH
100109: EMPTY
100110: LIST
100111: LIST
100112: LIST
100113: PUSH
100114: LD_VAR 0 1
100118: PUSH
100119: LD_INT 3
100121: PLUS
100122: PUSH
100123: LD_VAR 0 2
100127: PUSH
100128: LD_INT 3
100130: PLUS
100131: PUSH
100132: LD_INT 5
100134: PUSH
100135: EMPTY
100136: LIST
100137: LIST
100138: LIST
100139: PUSH
100140: LD_VAR 0 1
100144: PUSH
100145: LD_INT 4
100147: PLUS
100148: PUSH
100149: LD_VAR 0 2
100153: PUSH
100154: LD_INT 4
100156: PUSH
100157: EMPTY
100158: LIST
100159: LIST
100160: LIST
100161: PUSH
100162: LD_VAR 0 1
100166: PUSH
100167: LD_VAR 0 2
100171: PUSH
100172: LD_INT 3
100174: MINUS
100175: PUSH
100176: LD_INT 3
100178: PUSH
100179: EMPTY
100180: LIST
100181: LIST
100182: LIST
100183: PUSH
100184: LD_VAR 0 1
100188: PUSH
100189: LD_INT 4
100191: MINUS
100192: PUSH
100193: LD_VAR 0 2
100197: PUSH
100198: LD_INT 4
100200: MINUS
100201: PUSH
100202: LD_INT 2
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: LIST
100209: PUSH
100210: EMPTY
100211: LIST
100212: LIST
100213: LIST
100214: LIST
100215: LIST
100216: ST_TO_ADDR
// end ; 5 :
100217: GO 100357
100219: LD_INT 5
100221: DOUBLE
100222: EQUAL
100223: IFTRUE 100227
100225: GO 100356
100227: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100228: LD_ADDR_VAR 0 5
100232: PUSH
100233: LD_VAR 0 1
100237: PUSH
100238: LD_INT 4
100240: MINUS
100241: PUSH
100242: LD_VAR 0 2
100246: PUSH
100247: LD_INT 1
100249: PUSH
100250: EMPTY
100251: LIST
100252: LIST
100253: LIST
100254: PUSH
100255: LD_VAR 0 1
100259: PUSH
100260: LD_VAR 0 2
100264: PUSH
100265: LD_INT 4
100267: MINUS
100268: PUSH
100269: LD_INT 3
100271: PUSH
100272: EMPTY
100273: LIST
100274: LIST
100275: LIST
100276: PUSH
100277: LD_VAR 0 1
100281: PUSH
100282: LD_INT 4
100284: PLUS
100285: PUSH
100286: LD_VAR 0 2
100290: PUSH
100291: LD_INT 4
100293: PLUS
100294: PUSH
100295: LD_INT 5
100297: PUSH
100298: EMPTY
100299: LIST
100300: LIST
100301: LIST
100302: PUSH
100303: LD_VAR 0 1
100307: PUSH
100308: LD_INT 3
100310: PLUS
100311: PUSH
100312: LD_VAR 0 2
100316: PUSH
100317: LD_INT 4
100319: PUSH
100320: EMPTY
100321: LIST
100322: LIST
100323: LIST
100324: PUSH
100325: LD_VAR 0 1
100329: PUSH
100330: LD_VAR 0 2
100334: PUSH
100335: LD_INT 3
100337: PLUS
100338: PUSH
100339: LD_INT 0
100341: PUSH
100342: EMPTY
100343: LIST
100344: LIST
100345: LIST
100346: PUSH
100347: EMPTY
100348: LIST
100349: LIST
100350: LIST
100351: LIST
100352: LIST
100353: ST_TO_ADDR
// end ; end ;
100354: GO 100357
100356: POP
// result := list ;
100357: LD_ADDR_VAR 0 4
100361: PUSH
100362: LD_VAR 0 5
100366: ST_TO_ADDR
// end ;
100367: LD_VAR 0 4
100371: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
100372: LD_INT 0
100374: PPUSH
100375: PPUSH
100376: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
100377: LD_VAR 0 1
100381: NOT
100382: PUSH
100383: LD_VAR 0 2
100387: PUSH
100388: LD_INT 1
100390: PUSH
100391: LD_INT 2
100393: PUSH
100394: LD_INT 3
100396: PUSH
100397: LD_INT 4
100399: PUSH
100400: EMPTY
100401: LIST
100402: LIST
100403: LIST
100404: LIST
100405: IN
100406: NOT
100407: OR
100408: IFFALSE 100412
// exit ;
100410: GO 100504
// tmp := [ ] ;
100412: LD_ADDR_VAR 0 5
100416: PUSH
100417: EMPTY
100418: ST_TO_ADDR
// for i in units do
100419: LD_ADDR_VAR 0 4
100423: PUSH
100424: LD_VAR 0 1
100428: PUSH
100429: FOR_IN
100430: IFFALSE 100473
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
100432: LD_ADDR_VAR 0 5
100436: PUSH
100437: LD_VAR 0 5
100441: PPUSH
100442: LD_VAR 0 5
100446: PUSH
100447: LD_INT 1
100449: PLUS
100450: PPUSH
100451: LD_VAR 0 4
100455: PPUSH
100456: LD_VAR 0 2
100460: PPUSH
100461: CALL_OW 259
100465: PPUSH
100466: CALL_OW 2
100470: ST_TO_ADDR
100471: GO 100429
100473: POP
100474: POP
// if not tmp then
100475: LD_VAR 0 5
100479: NOT
100480: IFFALSE 100484
// exit ;
100482: GO 100504
// result := SortListByListDesc ( units , tmp ) ;
100484: LD_ADDR_VAR 0 3
100488: PUSH
100489: LD_VAR 0 1
100493: PPUSH
100494: LD_VAR 0 5
100498: PPUSH
100499: CALL_OW 77
100503: ST_TO_ADDR
// end ;
100504: LD_VAR 0 3
100508: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
100509: LD_INT 0
100511: PPUSH
100512: PPUSH
100513: PPUSH
// x := GetX ( building ) ;
100514: LD_ADDR_VAR 0 4
100518: PUSH
100519: LD_VAR 0 2
100523: PPUSH
100524: CALL_OW 250
100528: ST_TO_ADDR
// y := GetY ( building ) ;
100529: LD_ADDR_VAR 0 5
100533: PUSH
100534: LD_VAR 0 2
100538: PPUSH
100539: CALL_OW 251
100543: ST_TO_ADDR
// if GetTaskList ( unit ) then
100544: LD_VAR 0 1
100548: PPUSH
100549: CALL_OW 437
100553: IFFALSE 100648
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
100555: LD_STRING e
100557: PUSH
100558: LD_VAR 0 1
100562: PPUSH
100563: CALL_OW 437
100567: PUSH
100568: LD_INT 1
100570: ARRAY
100571: PUSH
100572: LD_INT 1
100574: ARRAY
100575: EQUAL
100576: PUSH
100577: LD_VAR 0 4
100581: PUSH
100582: LD_VAR 0 1
100586: PPUSH
100587: CALL_OW 437
100591: PUSH
100592: LD_INT 1
100594: ARRAY
100595: PUSH
100596: LD_INT 2
100598: ARRAY
100599: EQUAL
100600: AND
100601: PUSH
100602: LD_VAR 0 5
100606: PUSH
100607: LD_VAR 0 1
100611: PPUSH
100612: CALL_OW 437
100616: PUSH
100617: LD_INT 1
100619: ARRAY
100620: PUSH
100621: LD_INT 3
100623: ARRAY
100624: EQUAL
100625: AND
100626: IFFALSE 100638
// result := true else
100628: LD_ADDR_VAR 0 3
100632: PUSH
100633: LD_INT 1
100635: ST_TO_ADDR
100636: GO 100646
// result := false ;
100638: LD_ADDR_VAR 0 3
100642: PUSH
100643: LD_INT 0
100645: ST_TO_ADDR
// end else
100646: GO 100656
// result := false ;
100648: LD_ADDR_VAR 0 3
100652: PUSH
100653: LD_INT 0
100655: ST_TO_ADDR
// end ;
100656: LD_VAR 0 3
100660: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
100661: LD_INT 0
100663: PPUSH
100664: PPUSH
100665: PPUSH
100666: PPUSH
// if not unit or not area then
100667: LD_VAR 0 1
100671: NOT
100672: PUSH
100673: LD_VAR 0 2
100677: NOT
100678: OR
100679: IFFALSE 100683
// exit ;
100681: GO 100848
// tmp := AreaToList ( area , i ) ;
100683: LD_ADDR_VAR 0 6
100687: PUSH
100688: LD_VAR 0 2
100692: PPUSH
100693: LD_VAR 0 5
100697: PPUSH
100698: CALL_OW 517
100702: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
100703: LD_ADDR_VAR 0 5
100707: PUSH
100708: DOUBLE
100709: LD_INT 1
100711: DEC
100712: ST_TO_ADDR
100713: LD_VAR 0 6
100717: PUSH
100718: LD_INT 1
100720: ARRAY
100721: PUSH
100722: FOR_TO
100723: IFFALSE 100838
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
100725: LD_ADDR_VAR 0 7
100729: PUSH
100730: LD_VAR 0 6
100734: PUSH
100735: LD_INT 1
100737: ARRAY
100738: PUSH
100739: LD_VAR 0 5
100743: ARRAY
100744: PUSH
100745: LD_VAR 0 6
100749: PUSH
100750: LD_INT 2
100752: ARRAY
100753: PUSH
100754: LD_VAR 0 5
100758: ARRAY
100759: PUSH
100760: EMPTY
100761: LIST
100762: LIST
100763: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
100764: LD_VAR 0 7
100768: PUSH
100769: LD_INT 1
100771: ARRAY
100772: PPUSH
100773: LD_VAR 0 7
100777: PUSH
100778: LD_INT 2
100780: ARRAY
100781: PPUSH
100782: CALL_OW 428
100786: PUSH
100787: LD_INT 0
100789: EQUAL
100790: IFFALSE 100836
// begin result := true ;
100792: LD_ADDR_VAR 0 4
100796: PUSH
100797: LD_INT 1
100799: ST_TO_ADDR
// PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
100800: LD_VAR 0 1
100804: PPUSH
100805: LD_VAR 0 7
100809: PUSH
100810: LD_INT 1
100812: ARRAY
100813: PPUSH
100814: LD_VAR 0 7
100818: PUSH
100819: LD_INT 2
100821: ARRAY
100822: PPUSH
100823: LD_VAR 0 3
100827: PPUSH
100828: CALL_OW 48
// exit ;
100832: POP
100833: POP
100834: GO 100848
// end ; end ;
100836: GO 100722
100838: POP
100839: POP
// result := false ;
100840: LD_ADDR_VAR 0 4
100844: PUSH
100845: LD_INT 0
100847: ST_TO_ADDR
// end ;
100848: LD_VAR 0 4
100852: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
100853: LD_INT 0
100855: PPUSH
100856: PPUSH
100857: PPUSH
// if not side or side > 8 then
100858: LD_VAR 0 1
100862: NOT
100863: PUSH
100864: LD_VAR 0 1
100868: PUSH
100869: LD_INT 8
100871: GREATER
100872: OR
100873: IFFALSE 100877
// exit ;
100875: GO 101064
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
100877: LD_ADDR_VAR 0 4
100881: PUSH
100882: LD_INT 22
100884: PUSH
100885: LD_VAR 0 1
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PUSH
100894: LD_INT 21
100896: PUSH
100897: LD_INT 3
100899: PUSH
100900: EMPTY
100901: LIST
100902: LIST
100903: PUSH
100904: EMPTY
100905: LIST
100906: LIST
100907: PPUSH
100908: CALL_OW 69
100912: ST_TO_ADDR
// if not tmp then
100913: LD_VAR 0 4
100917: NOT
100918: IFFALSE 100922
// exit ;
100920: GO 101064
// enable_addtolog := true ;
100922: LD_ADDR_OWVAR 81
100926: PUSH
100927: LD_INT 1
100929: ST_TO_ADDR
// AddToLog ( [ ) ;
100930: LD_STRING [
100932: PPUSH
100933: CALL_OW 561
// for i in tmp do
100937: LD_ADDR_VAR 0 3
100941: PUSH
100942: LD_VAR 0 4
100946: PUSH
100947: FOR_IN
100948: IFFALSE 101055
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
100950: LD_STRING [
100952: PUSH
100953: LD_VAR 0 3
100957: PPUSH
100958: CALL_OW 266
100962: STR
100963: PUSH
100964: LD_STRING , 
100966: STR
100967: PUSH
100968: LD_VAR 0 3
100972: PPUSH
100973: CALL_OW 250
100977: STR
100978: PUSH
100979: LD_STRING , 
100981: STR
100982: PUSH
100983: LD_VAR 0 3
100987: PPUSH
100988: CALL_OW 251
100992: STR
100993: PUSH
100994: LD_STRING , 
100996: STR
100997: PUSH
100998: LD_VAR 0 3
101002: PPUSH
101003: CALL_OW 254
101007: STR
101008: PUSH
101009: LD_STRING , 
101011: STR
101012: PUSH
101013: LD_VAR 0 3
101017: PPUSH
101018: LD_INT 1
101020: PPUSH
101021: CALL_OW 268
101025: STR
101026: PUSH
101027: LD_STRING , 
101029: STR
101030: PUSH
101031: LD_VAR 0 3
101035: PPUSH
101036: LD_INT 2
101038: PPUSH
101039: CALL_OW 268
101043: STR
101044: PUSH
101045: LD_STRING ],
101047: STR
101048: PPUSH
101049: CALL_OW 561
// end ;
101053: GO 100947
101055: POP
101056: POP
// AddToLog ( ]; ) ;
101057: LD_STRING ];
101059: PPUSH
101060: CALL_OW 561
// end ;
101064: LD_VAR 0 2
101068: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101069: LD_INT 0
101071: PPUSH
101072: PPUSH
101073: PPUSH
101074: PPUSH
101075: PPUSH
// if not area or not rate or not max then
101076: LD_VAR 0 1
101080: NOT
101081: PUSH
101082: LD_VAR 0 2
101086: NOT
101087: OR
101088: PUSH
101089: LD_VAR 0 4
101093: NOT
101094: OR
101095: IFFALSE 101099
// exit ;
101097: GO 101291
// while 1 do
101099: LD_INT 1
101101: IFFALSE 101291
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101103: LD_ADDR_VAR 0 9
101107: PUSH
101108: LD_VAR 0 1
101112: PPUSH
101113: LD_INT 1
101115: PPUSH
101116: CALL_OW 287
101120: PUSH
101121: LD_INT 10
101123: MUL
101124: ST_TO_ADDR
// r := rate / 10 ;
101125: LD_ADDR_VAR 0 7
101129: PUSH
101130: LD_VAR 0 2
101134: PUSH
101135: LD_INT 10
101137: DIVREAL
101138: ST_TO_ADDR
// time := 1 1$00 ;
101139: LD_ADDR_VAR 0 8
101143: PUSH
101144: LD_INT 2100
101146: ST_TO_ADDR
// if amount < min then
101147: LD_VAR 0 9
101151: PUSH
101152: LD_VAR 0 3
101156: LESS
101157: IFFALSE 101175
// r := r * 2 else
101159: LD_ADDR_VAR 0 7
101163: PUSH
101164: LD_VAR 0 7
101168: PUSH
101169: LD_INT 2
101171: MUL
101172: ST_TO_ADDR
101173: GO 101201
// if amount > max then
101175: LD_VAR 0 9
101179: PUSH
101180: LD_VAR 0 4
101184: GREATER
101185: IFFALSE 101201
// r := r / 2 ;
101187: LD_ADDR_VAR 0 7
101191: PUSH
101192: LD_VAR 0 7
101196: PUSH
101197: LD_INT 2
101199: DIVREAL
101200: ST_TO_ADDR
// time := time / r ;
101201: LD_ADDR_VAR 0 8
101205: PUSH
101206: LD_VAR 0 8
101210: PUSH
101211: LD_VAR 0 7
101215: DIVREAL
101216: ST_TO_ADDR
// if time < 0 then
101217: LD_VAR 0 8
101221: PUSH
101222: LD_INT 0
101224: LESS
101225: IFFALSE 101242
// time := time * - 1 ;
101227: LD_ADDR_VAR 0 8
101231: PUSH
101232: LD_VAR 0 8
101236: PUSH
101237: LD_INT 1
101239: NEG
101240: MUL
101241: ST_TO_ADDR
// wait ( time ) ;
101242: LD_VAR 0 8
101246: PPUSH
101247: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
101251: LD_INT 35
101253: PPUSH
101254: LD_INT 875
101256: PPUSH
101257: CALL_OW 12
101261: PPUSH
101262: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
101266: LD_INT 1
101268: PPUSH
101269: LD_INT 5
101271: PPUSH
101272: CALL_OW 12
101276: PPUSH
101277: LD_VAR 0 1
101281: PPUSH
101282: LD_INT 1
101284: PPUSH
101285: CALL_OW 55
// end ;
101289: GO 101099
// end ;
101291: LD_VAR 0 5
101295: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
101296: LD_INT 0
101298: PPUSH
101299: PPUSH
101300: PPUSH
101301: PPUSH
101302: PPUSH
101303: PPUSH
101304: PPUSH
101305: PPUSH
// if not turrets or not factories then
101306: LD_VAR 0 1
101310: NOT
101311: PUSH
101312: LD_VAR 0 2
101316: NOT
101317: OR
101318: IFFALSE 101322
// exit ;
101320: GO 101629
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
101322: LD_ADDR_VAR 0 10
101326: PUSH
101327: LD_INT 5
101329: PUSH
101330: LD_INT 6
101332: PUSH
101333: EMPTY
101334: LIST
101335: LIST
101336: PUSH
101337: LD_INT 2
101339: PUSH
101340: LD_INT 4
101342: PUSH
101343: EMPTY
101344: LIST
101345: LIST
101346: PUSH
101347: LD_INT 3
101349: PUSH
101350: LD_INT 5
101352: PUSH
101353: EMPTY
101354: LIST
101355: LIST
101356: PUSH
101357: EMPTY
101358: LIST
101359: LIST
101360: LIST
101361: PUSH
101362: LD_INT 24
101364: PUSH
101365: LD_INT 25
101367: PUSH
101368: EMPTY
101369: LIST
101370: LIST
101371: PUSH
101372: LD_INT 23
101374: PUSH
101375: LD_INT 27
101377: PUSH
101378: EMPTY
101379: LIST
101380: LIST
101381: PUSH
101382: EMPTY
101383: LIST
101384: LIST
101385: PUSH
101386: LD_INT 42
101388: PUSH
101389: LD_INT 43
101391: PUSH
101392: EMPTY
101393: LIST
101394: LIST
101395: PUSH
101396: LD_INT 44
101398: PUSH
101399: LD_INT 46
101401: PUSH
101402: EMPTY
101403: LIST
101404: LIST
101405: PUSH
101406: LD_INT 45
101408: PUSH
101409: LD_INT 47
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: EMPTY
101417: LIST
101418: LIST
101419: LIST
101420: PUSH
101421: EMPTY
101422: LIST
101423: LIST
101424: LIST
101425: ST_TO_ADDR
// result := [ ] ;
101426: LD_ADDR_VAR 0 3
101430: PUSH
101431: EMPTY
101432: ST_TO_ADDR
// for i in turrets do
101433: LD_ADDR_VAR 0 4
101437: PUSH
101438: LD_VAR 0 1
101442: PUSH
101443: FOR_IN
101444: IFFALSE 101627
// begin nat := GetNation ( i ) ;
101446: LD_ADDR_VAR 0 7
101450: PUSH
101451: LD_VAR 0 4
101455: PPUSH
101456: CALL_OW 248
101460: ST_TO_ADDR
// weapon := 0 ;
101461: LD_ADDR_VAR 0 8
101465: PUSH
101466: LD_INT 0
101468: ST_TO_ADDR
// if not nat then
101469: LD_VAR 0 7
101473: NOT
101474: IFFALSE 101478
// continue ;
101476: GO 101443
// for j in list [ nat ] do
101478: LD_ADDR_VAR 0 5
101482: PUSH
101483: LD_VAR 0 10
101487: PUSH
101488: LD_VAR 0 7
101492: ARRAY
101493: PUSH
101494: FOR_IN
101495: IFFALSE 101536
// if GetBWeapon ( i ) = j [ 1 ] then
101497: LD_VAR 0 4
101501: PPUSH
101502: CALL_OW 269
101506: PUSH
101507: LD_VAR 0 5
101511: PUSH
101512: LD_INT 1
101514: ARRAY
101515: EQUAL
101516: IFFALSE 101534
// begin weapon := j [ 2 ] ;
101518: LD_ADDR_VAR 0 8
101522: PUSH
101523: LD_VAR 0 5
101527: PUSH
101528: LD_INT 2
101530: ARRAY
101531: ST_TO_ADDR
// break ;
101532: GO 101536
// end ;
101534: GO 101494
101536: POP
101537: POP
// if not weapon then
101538: LD_VAR 0 8
101542: NOT
101543: IFFALSE 101547
// continue ;
101545: GO 101443
// for k in factories do
101547: LD_ADDR_VAR 0 6
101551: PUSH
101552: LD_VAR 0 2
101556: PUSH
101557: FOR_IN
101558: IFFALSE 101623
// begin weapons := AvailableWeaponList ( k ) ;
101560: LD_ADDR_VAR 0 9
101564: PUSH
101565: LD_VAR 0 6
101569: PPUSH
101570: CALL_OW 478
101574: ST_TO_ADDR
// if not weapons then
101575: LD_VAR 0 9
101579: NOT
101580: IFFALSE 101584
// continue ;
101582: GO 101557
// if weapon in weapons then
101584: LD_VAR 0 8
101588: PUSH
101589: LD_VAR 0 9
101593: IN
101594: IFFALSE 101621
// begin result := [ i , weapon ] ;
101596: LD_ADDR_VAR 0 3
101600: PUSH
101601: LD_VAR 0 4
101605: PUSH
101606: LD_VAR 0 8
101610: PUSH
101611: EMPTY
101612: LIST
101613: LIST
101614: ST_TO_ADDR
// exit ;
101615: POP
101616: POP
101617: POP
101618: POP
101619: GO 101629
// end ; end ;
101621: GO 101557
101623: POP
101624: POP
// end ;
101625: GO 101443
101627: POP
101628: POP
// end ;
101629: LD_VAR 0 3
101633: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
101634: LD_INT 0
101636: PPUSH
// if not side or side > 8 then
101637: LD_VAR 0 3
101641: NOT
101642: PUSH
101643: LD_VAR 0 3
101647: PUSH
101648: LD_INT 8
101650: GREATER
101651: OR
101652: IFFALSE 101656
// exit ;
101654: GO 101715
// if not range then
101656: LD_VAR 0 4
101660: NOT
101661: IFFALSE 101672
// range := - 12 ;
101663: LD_ADDR_VAR 0 4
101667: PUSH
101668: LD_INT 12
101670: NEG
101671: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
101672: LD_VAR 0 1
101676: PPUSH
101677: LD_VAR 0 2
101681: PPUSH
101682: LD_VAR 0 3
101686: PPUSH
101687: LD_VAR 0 4
101691: PPUSH
101692: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
101696: LD_VAR 0 1
101700: PPUSH
101701: LD_VAR 0 2
101705: PPUSH
101706: LD_VAR 0 3
101710: PPUSH
101711: CALL_OW 331
// end ;
101715: LD_VAR 0 5
101719: RET
// export function Video ( mode ) ; begin
101720: LD_INT 0
101722: PPUSH
// ingame_video = mode ;
101723: LD_ADDR_OWVAR 52
101727: PUSH
101728: LD_VAR 0 1
101732: ST_TO_ADDR
// interface_hidden = mode ;
101733: LD_ADDR_OWVAR 54
101737: PUSH
101738: LD_VAR 0 1
101742: ST_TO_ADDR
// end ;
101743: LD_VAR 0 2
101747: RET
// export function Join ( array , element ) ; begin
101748: LD_INT 0
101750: PPUSH
// result := array ^ element ;
101751: LD_ADDR_VAR 0 3
101755: PUSH
101756: LD_VAR 0 1
101760: PUSH
101761: LD_VAR 0 2
101765: ADD
101766: ST_TO_ADDR
// end ;
101767: LD_VAR 0 3
101771: RET
// export function JoinUnion ( array , element ) ; begin
101772: LD_INT 0
101774: PPUSH
// result := array union element ;
101775: LD_ADDR_VAR 0 3
101779: PUSH
101780: LD_VAR 0 1
101784: PUSH
101785: LD_VAR 0 2
101789: UNION
101790: ST_TO_ADDR
// end ;
101791: LD_VAR 0 3
101795: RET
// export function GetBehemoths ( side ) ; begin
101796: LD_INT 0
101798: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
101799: LD_ADDR_VAR 0 2
101803: PUSH
101804: LD_INT 22
101806: PUSH
101807: LD_VAR 0 1
101811: PUSH
101812: EMPTY
101813: LIST
101814: LIST
101815: PUSH
101816: LD_INT 31
101818: PUSH
101819: LD_INT 25
101821: PUSH
101822: EMPTY
101823: LIST
101824: LIST
101825: PUSH
101826: EMPTY
101827: LIST
101828: LIST
101829: PPUSH
101830: CALL_OW 69
101834: ST_TO_ADDR
// end ;
101835: LD_VAR 0 2
101839: RET
// export function Shuffle ( array ) ; var i , index ; begin
101840: LD_INT 0
101842: PPUSH
101843: PPUSH
101844: PPUSH
// result := [ ] ;
101845: LD_ADDR_VAR 0 2
101849: PUSH
101850: EMPTY
101851: ST_TO_ADDR
// if not array then
101852: LD_VAR 0 1
101856: NOT
101857: IFFALSE 101861
// exit ;
101859: GO 101960
// Randomize ;
101861: CALL_OW 10
// for i = array downto 1 do
101865: LD_ADDR_VAR 0 3
101869: PUSH
101870: DOUBLE
101871: LD_VAR 0 1
101875: INC
101876: ST_TO_ADDR
101877: LD_INT 1
101879: PUSH
101880: FOR_DOWNTO
101881: IFFALSE 101958
// begin index := rand ( 1 , array ) ;
101883: LD_ADDR_VAR 0 4
101887: PUSH
101888: LD_INT 1
101890: PPUSH
101891: LD_VAR 0 1
101895: PPUSH
101896: CALL_OW 12
101900: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
101901: LD_ADDR_VAR 0 2
101905: PUSH
101906: LD_VAR 0 2
101910: PPUSH
101911: LD_VAR 0 2
101915: PUSH
101916: LD_INT 1
101918: PLUS
101919: PPUSH
101920: LD_VAR 0 1
101924: PUSH
101925: LD_VAR 0 4
101929: ARRAY
101930: PPUSH
101931: CALL_OW 2
101935: ST_TO_ADDR
// array := Delete ( array , index ) ;
101936: LD_ADDR_VAR 0 1
101940: PUSH
101941: LD_VAR 0 1
101945: PPUSH
101946: LD_VAR 0 4
101950: PPUSH
101951: CALL_OW 3
101955: ST_TO_ADDR
// end ;
101956: GO 101880
101958: POP
101959: POP
// end ;
101960: LD_VAR 0 2
101964: RET
